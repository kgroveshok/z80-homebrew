# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 80 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 1  
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 1  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c				call break_point_state  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			debug_mark: equ hardware_word - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_active-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_view_disable - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c				ld a, ' ' 
801c				ld (os_view_disable), a 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 16 ed				ld hl, display_fb1  
801f 22 d2 eb				ld (display_fb_active), hl  
8022			  
8022 cd af 8a				call clear_display  
8025			  
8025 21 d4 eb				ld hl, display_fb2  
8028 22 d2 eb				ld (display_fb_active), hl  
802b			  
802b cd af 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 b7 ed				ld hl, display_fb0  
8031 22 d2 eb				ld (display_fb_active), hl  
8034			  
8034 cd af 8a				call clear_display  
8037			  
8037			  
8037 cd c5 e2				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd 67 e3			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 7f 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd d2 8a			call update_display  
8046 cd f2 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd b4 8a			call fill_display  
804e cd d2 8a			call update_display  
8051 cd f2 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd b4 8a			call fill_display  
8059 cd d2 8a			call update_display  
805c cd f2 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd b4 8a			call fill_display  
8064 cd d2 8a			call update_display  
8067 cd f2 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a			        ld a, display_row_1    
806a			else  
806a 3e 0a		        ld a, display_row_1 +10   
806c			endif  
806c 11 b3 96			ld de, prom_bootmsg  
806f cd c2 8a			call str_at_display  
8072 cd d2 8a			call update_display  
8075			  
8075			  
8075 cd f2 89			call delay1s  
8078 cd f2 89			call delay1s  
807b			if display_cols == 20	  
807b			            LD   A, display_row_3+2  
807b			else  
807b 3e 5c		            LD   A, display_row_3+12  
807d			endif  
807d 11 c8 96			ld de, prom_bootmsg1  
8080 cd c2 8a			call str_at_display  
8083 cd d2 8a			call update_display  
8086 cd f2 89			call delay1s  
8089 cd f2 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 71 ee		ld (debug_mark),a  
8091 32 72 ee		ld (debug_mark+1),a  
8094 32 73 ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 74 ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 79 ea			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 71 ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 72 ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 73 ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd dd 94			call break_point_state  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 80 ea			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 71 ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 72 ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 73 ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd dd 94			call break_point_state  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 80 ea				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 71 ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 72 ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 73 ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd dd 94			call break_point_state  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd 05 8d				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 79 ea				ld hl, (store_tmp1) 
8110 11 83 ea				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 71 ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 72 ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 73 ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd dd 94			call break_point_state  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 72 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 71 ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 72 ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 73 ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd dd 94			call break_point_state  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 71 ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 72 ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 73 ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd dd 94			call break_point_state  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 71 ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 72 ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 73 ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd dd 94			call break_point_state  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 71 ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 72 ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 73 ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd dd 94			call break_point_state  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd 05 8d			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 80 ea			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 82 ea			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 71 ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 72 ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 73 ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd dd 94			call break_point_state  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 71 ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 72 ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 73 ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd dd 94			call break_point_state  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 80 ea			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 71 ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 72 ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 73 ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 80 ea				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd dd 94			call break_point_state  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 81 ea			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 71 ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 72 ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 73 ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd dd 94			call break_point_state  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 71 ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 72 ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 73 ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd dd 94			call break_point_state  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd b5 89			call storage_clear_page 
829b			 
829b 21 80 ea			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 81 ea		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 83 ea		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 8c ea			ld hl, store_page+3+9 
82b5 3a 65 ea			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 80 ea			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 71 ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 72 ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 73 ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd dd 94			call break_point_state  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 71 ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 72 ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 73 ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd dd 94			call break_point_state  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd d7 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd d7 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd dc 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd d7 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd d7 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd dc 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 71 ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 72 ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 73 ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd dd 94			call break_point_state  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 83 ea		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 71 ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 72 ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 73 ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd dd 94			call break_point_state  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 80 ea			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 71 ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 72 ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 73 ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd dd 94			call break_point_state  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 71 ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 72 ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 73 ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd dd 94			call break_point_state  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd 05 8d			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 80 ea			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd 05 8d			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 71 ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 72 ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 73 ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd dd 94			call break_point_state  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 80 ea			ld a, (store_page)	; get file id 
8410 32 74 ea			ld (store_tmpid), a 
8413			 
8413 3a 82 ea			ld a, (store_page+2)    ; get count of extends 
8416 32 73 ea			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 80 ea			ld (store_page), a 
841f 32 81 ea			ld (store_page+1),a 
8422 11 80 ea			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 71 ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 72 ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 73 ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd dd 94			call break_point_state  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a 73 ea			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a 74 ea			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 71 ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 72 ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 73 ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd dd 94			call break_point_state  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd 05 8d			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 80 ea			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 80 ea			ld (store_page), a 
8482 32 81 ea			ld (store_page+1),a 
8485 11 80 ea			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 71 ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 72 ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 73 ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd dd 94			call break_point_state  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 71 ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 72 ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 73 ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd dd 94			call break_point_state  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd fa 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd dc 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd fa 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd dc 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 71 ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 72 ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 73 ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd dd 94			call break_point_state  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 71 ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 72 ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 73 ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd dd 94			call break_point_state  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd dc 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd dc 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 71 ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 72 ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 73 ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd dd 94			call break_point_state  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 80 ea			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 80 ea			ld (store_page),a 
85a3				 
85a3 32 74 ea			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 80 ea			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 71 ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 72 ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 73 ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd dd 94			call break_point_state  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 80 ea				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 71 ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 72 ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 73 ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd dd 94			call break_point_state  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 6b ea			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 71 ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 72 ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 73 ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd dd 94			call break_point_state  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 6b ea			ld (store_tmppageid), hl 
8615				 
8615 3a 74 ea			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 80 ea			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 81 ea			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 82 ea			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 83 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 71 ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 72 ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 73 ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd dd 94			call break_point_state  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd 45 91			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 71 ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 72 ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 73 ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd dd 94			call break_point_state  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 71 ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 72 ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 73 ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd dd 94			call break_point_state  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a 6b ea			ld hl,(store_tmppageid) 
868b 11 80 ea			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 71 ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 72 ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 73 ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd dd 94			call break_point_state  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a 74 ea			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 71 ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 72 ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 73 ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd dd 94			call break_point_state  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 7e ea			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 7c ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 71 ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 72 ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 73 ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd dd 94			call break_point_state  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 71 ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 72 ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 73 ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd dd 94			call break_point_state  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd 05 8d			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; save current address for use by higher level words etc 
871f			 
871f 22 71 ea			ld (store_openaddr),hl 
8722			 
8722			 
8722				; hl contains page number to load 
8722 d1				pop de   ; get storage 
8723 ed 53 7c ea		ld (store_readbuf), de     ; current buffer to load in to 
8727 d5				push de 
8728				if DEBUG_STORESE 
8728					DMARK "srg" 
8728 f5				push af  
8729 3a 3d 87			ld a, (.dmark)  
872c 32 71 ee			ld (debug_mark),a  
872f 3a 3e 87			ld a, (.dmark+1)  
8732 32 72 ee			ld (debug_mark+1),a  
8735 3a 3f 87			ld a, (.dmark+2)  
8738 32 73 ee			ld (debug_mark+2),a  
873b 18 03			jr .pastdmark  
873d ..			.dmark: db "srg"  
8740 f1			.pastdmark: pop af  
8741			endm  
# End of macro DMARK
8741					CALLMONITOR 
8741 cd dd 94			call break_point_state  
8744				endm  
# End of macro CALLMONITOR
8744				endif 
8744 cd 79 81			call storage_read_block 
8747			 
8747				; if this a continuation read??? 
8747			 
8747 2a 7c ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874a			 
874a 3e 3f			ld a, STORE_BLOCK_PHY-1 
874c cd dc 8c			call addatohl 
874f 7e				ld a,(hl) 
8750 fe 00			cp 0 
8752 28 02			jr z, .markiscont 
8754 3e ff			ld a, 255 
8756			 
8756			.markiscont: 
8756 32 73 ea			ld (store_readcont), a 
8759			 
8759				if DEBUG_STORESE 
8759					DMARK "srC" 
8759 f5				push af  
875a 3a 6e 87			ld a, (.dmark)  
875d 32 71 ee			ld (debug_mark),a  
8760 3a 6f 87			ld a, (.dmark+1)  
8763 32 72 ee			ld (debug_mark+1),a  
8766 3a 70 87			ld a, (.dmark+2)  
8769 32 73 ee			ld (debug_mark+2),a  
876c 18 03			jr .pastdmark  
876e ..			.dmark: db "srC"  
8771 f1			.pastdmark: pop af  
8772			endm  
# End of macro DMARK
8772					CALLMONITOR 
8772 cd dd 94			call break_point_state  
8775				endm  
# End of macro CALLMONITOR
8775				endif 
8775				; only short reads enabled 
8775			 
8775 3a 7b ea			ld a, (store_longread) 
8778 fe 00			cp 0 
877a ca 47 88			jp z, .readdone 
877d			 
877d			; TODO if block has no zeros then need to read next block  
877d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877d			; check last byte of physical block. 
877d			; if not zero then the next block needs to be loaded 
877d			 
877d			 
877d 2a 7c ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8780			 
8780 3e 3f			ld a, STORE_BLOCK_PHY-1 
8782 cd dc 8c			call addatohl 
8785				;dec hl 
8785 7e				ld a,(hl) 
8786				if DEBUG_STORESE 
8786					DMARK "sr?" 
8786 f5				push af  
8787 3a 9b 87			ld a, (.dmark)  
878a 32 71 ee			ld (debug_mark),a  
878d 3a 9c 87			ld a, (.dmark+1)  
8790 32 72 ee			ld (debug_mark+1),a  
8793 3a 9d 87			ld a, (.dmark+2)  
8796 32 73 ee			ld (debug_mark+2),a  
8799 18 03			jr .pastdmark  
879b ..			.dmark: db "sr?"  
879e f1			.pastdmark: pop af  
879f			endm  
# End of macro DMARK
879f					CALLMONITOR 
879f cd dd 94			call break_point_state  
87a2				endm  
# End of macro CALLMONITOR
87a2				endif 
87a2 fe 00			cp 0 
87a4 ca 47 88			jp z, .readdone 
87a7			 
87a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a7			 
87a7 23				inc hl 
87a8			 
87a8 22 7c ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ab			 
87ab ed 5b 7e ea		ld de, (store_readptr)     ; save the current extent to load 
87af			 
87af eb				ex de, hl 
87b0			 
87b0				; next ext 
87b0			 
87b0 23				inc hl 
87b1 22 7e ea			ld  (store_readptr), hl     ; save the current extent to load 
87b4			 
87b4				if DEBUG_STORESE 
87b4					DMARK "sF2" 
87b4 f5				push af  
87b5 3a c9 87			ld a, (.dmark)  
87b8 32 71 ee			ld (debug_mark),a  
87bb 3a ca 87			ld a, (.dmark+1)  
87be 32 72 ee			ld (debug_mark+1),a  
87c1 3a cb 87			ld a, (.dmark+2)  
87c4 32 73 ee			ld (debug_mark+2),a  
87c7 18 03			jr .pastdmark  
87c9 ..			.dmark: db "sF2"  
87cc f1			.pastdmark: pop af  
87cd			endm  
# End of macro DMARK
87cd					CALLMONITOR 
87cd cd dd 94			call break_point_state  
87d0				endm  
# End of macro CALLMONITOR
87d0				endif 
87d0			 
87d0				; get and load block 
87d0			 
87d0 cd ac 84			call storage_findnextid 
87d3			 
87d3				if DEBUG_STORESE 
87d3					DMARK "sf2" 
87d3 f5				push af  
87d4 3a e8 87			ld a, (.dmark)  
87d7 32 71 ee			ld (debug_mark),a  
87da 3a e9 87			ld a, (.dmark+1)  
87dd 32 72 ee			ld (debug_mark+1),a  
87e0 3a ea 87			ld a, (.dmark+2)  
87e3 32 73 ee			ld (debug_mark+2),a  
87e6 18 03			jr .pastdmark  
87e8 ..			.dmark: db "sf2"  
87eb f1			.pastdmark: pop af  
87ec			endm  
# End of macro DMARK
87ec					CALLMONITOR 
87ec cd dd 94			call break_point_state  
87ef				endm  
# End of macro CALLMONITOR
87ef				endif 
87ef cd 05 8d			call ishlzero 
87f2			;	ld a, l 
87f2			;	add h 
87f2			;	cp 0 
87f2 ca d0 86			jp z,.sr_fail			; block not found so EOF 
87f5				 
87f5				; save current address for use by higher level words etc 
87f5			 
87f5 22 71 ea			ld (store_openaddr),hl 
87f8			 
87f8 cd 79 81			call storage_read_block 
87fb			 
87fb				; on a continuation block, we now have the file id and ext in the middle of the block 
87fb				; we need to pull everything back  
87fb			 
87fb ed 5b 7c ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87ff 2a 7c ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8802 23				inc hl 
8803 23				inc hl     ; skip id and ext 
8804 01 40 00			ld bc, STORE_BLOCK_PHY 
8807				if DEBUG_STORESE 
8807					DMARK "SR<" 
8807 f5				push af  
8808 3a 1c 88			ld a, (.dmark)  
880b 32 71 ee			ld (debug_mark),a  
880e 3a 1d 88			ld a, (.dmark+1)  
8811 32 72 ee			ld (debug_mark+1),a  
8814 3a 1e 88			ld a, (.dmark+2)  
8817 32 73 ee			ld (debug_mark+2),a  
881a 18 03			jr .pastdmark  
881c ..			.dmark: db "SR<"  
881f f1			.pastdmark: pop af  
8820			endm  
# End of macro DMARK
8820					CALLMONITOR 
8820 cd dd 94			call break_point_state  
8823				endm  
# End of macro CALLMONITOR
8823				endif 
8823 ed b0			ldir     ; copy data 
8825			 
8825				; move the pointer back and pretend we have a full buffer for next recheck 
8825			 
8825 1b				dec de 
8826 1b				dec de 
8827			 
8827			; TODO do pop below now short circuit loop????? 
8827 c1				pop bc     ; get rid of spare de on stack 
8828				if DEBUG_STORESE 
8828					DMARK "SR>" 
8828 f5				push af  
8829 3a 3d 88			ld a, (.dmark)  
882c 32 71 ee			ld (debug_mark),a  
882f 3a 3e 88			ld a, (.dmark+1)  
8832 32 72 ee			ld (debug_mark+1),a  
8835 3a 3f 88			ld a, (.dmark+2)  
8838 32 73 ee			ld (debug_mark+2),a  
883b 18 03			jr .pastdmark  
883d ..			.dmark: db "SR>"  
8840 f1			.pastdmark: pop af  
8841			endm  
# End of macro DMARK
8841					CALLMONITOR 
8841 cd dd 94			call break_point_state  
8844				endm  
# End of macro CALLMONITOR
8844				endif 
8844 c3 d5 86			jp .srext 
8847			 
8847			 
8847			 
8847			 
8847			 
8847			.readdone:		 
8847 e1				pop hl 		 ; return start of data to show as not EOF 
8848 23				inc hl   ; past file id 
8849 23				inc hl   ; past ext 
884a				if DEBUG_STORESE 
884a					DMARK "SRe" 
884a f5				push af  
884b 3a 5f 88			ld a, (.dmark)  
884e 32 71 ee			ld (debug_mark),a  
8851 3a 60 88			ld a, (.dmark+1)  
8854 32 72 ee			ld (debug_mark+1),a  
8857 3a 61 88			ld a, (.dmark+2)  
885a 32 73 ee			ld (debug_mark+2),a  
885d 18 03			jr .pastdmark  
885f ..			.dmark: db "SRe"  
8862 f1			.pastdmark: pop af  
8863			endm  
# End of macro DMARK
8863					CALLMONITOR 
8863 cd dd 94			call break_point_state  
8866				endm  
# End of macro CALLMONITOR
8866				endif 
8866 c9					ret 
8867			 
8867			 
8867			 
8867			; 
8867			; Append File 
8867			; 
8867			; hl - file id to locate 
8867			; de - pointer to (multi block) string to write 
8867			 
8867			.sa_notfound: 
8867 d1				pop de 
8868 c9				ret 
8869			 
8869			 
8869			storage_append: 
8869				; hl -  file id to append to 
8869				; de - string to append 
8869			 
8869 d5				push de 
886a				 
886a				if DEBUG_STORESE 
886a					DMARK "AP1" 
886a f5				push af  
886b 3a 7f 88			ld a, (.dmark)  
886e 32 71 ee			ld (debug_mark),a  
8871 3a 80 88			ld a, (.dmark+1)  
8874 32 72 ee			ld (debug_mark+1),a  
8877 3a 81 88			ld a, (.dmark+2)  
887a 32 73 ee			ld (debug_mark+2),a  
887d 18 03			jr .pastdmark  
887f ..			.dmark: db "AP1"  
8882 f1			.pastdmark: pop af  
8883			endm  
# End of macro DMARK
8883					CALLMONITOR 
8883 cd dd 94			call break_point_state  
8886				endm  
# End of macro CALLMONITOR
8886				endif 
8886			 
8886 7d				ld a, l 
8887 32 74 ea			ld (store_tmpid), a 
888a			 
888a				; get file header  
888a			 
888a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888c 3a 74 ea			ld a, (store_tmpid) 
888f 5f				ld e, a 
8890			 
8890 21 40 00				ld hl, STORE_BLOCK_PHY 
8893 cd ac 84				call storage_findnextid 
8896			 
8896 cd 05 8d			call ishlzero 
8899 28 cc			jr z, .sa_notfound 
889b			 
889b 22 6b ea			ld (store_tmppageid), hl 
889e			 
889e				; TODO handle file id not found 
889e			 
889e				if DEBUG_STORESE 
889e					DMARK "AP2" 
889e f5				push af  
889f 3a b3 88			ld a, (.dmark)  
88a2 32 71 ee			ld (debug_mark),a  
88a5 3a b4 88			ld a, (.dmark+1)  
88a8 32 72 ee			ld (debug_mark+1),a  
88ab 3a b5 88			ld a, (.dmark+2)  
88ae 32 73 ee			ld (debug_mark+2),a  
88b1 18 03			jr .pastdmark  
88b3 ..			.dmark: db "AP2"  
88b6 f1			.pastdmark: pop af  
88b7			endm  
# End of macro DMARK
88b7					CALLMONITOR 
88b7 cd dd 94			call break_point_state  
88ba				endm  
# End of macro CALLMONITOR
88ba				endif 
88ba			 
88ba				; update file extent count 
88ba			 
88ba 11 80 ea			ld de, store_page 
88bd			 
88bd cd 79 81			call storage_read_block 
88c0			 
88c0				if DEBUG_STORESE 
88c0					DMARK "AP3" 
88c0 f5				push af  
88c1 3a d5 88			ld a, (.dmark)  
88c4 32 71 ee			ld (debug_mark),a  
88c7 3a d6 88			ld a, (.dmark+1)  
88ca 32 72 ee			ld (debug_mark+1),a  
88cd 3a d7 88			ld a, (.dmark+2)  
88d0 32 73 ee			ld (debug_mark+2),a  
88d3 18 03			jr .pastdmark  
88d5 ..			.dmark: db "AP3"  
88d8 f1			.pastdmark: pop af  
88d9			endm  
# End of macro DMARK
88d9					CALLMONITOR 
88d9 cd dd 94			call break_point_state  
88dc				endm  
# End of macro CALLMONITOR
88dc				endif 
88dc			;	ld (store_tmppageid), hl 
88dc			 
88dc 3a 82 ea			ld a, (store_page+2) 
88df 3c				inc a 
88e0 32 82 ea			ld (store_page+2), a 
88e3 32 73 ea			ld (store_tmpext), a 
88e6				 
88e6				if DEBUG_STORESE 
88e6					DMARK "AP3" 
88e6 f5				push af  
88e7 3a fb 88			ld a, (.dmark)  
88ea 32 71 ee			ld (debug_mark),a  
88ed 3a fc 88			ld a, (.dmark+1)  
88f0 32 72 ee			ld (debug_mark+1),a  
88f3 3a fd 88			ld a, (.dmark+2)  
88f6 32 73 ee			ld (debug_mark+2),a  
88f9 18 03			jr .pastdmark  
88fb ..			.dmark: db "AP3"  
88fe f1			.pastdmark: pop af  
88ff			endm  
# End of macro DMARK
88ff					CALLMONITOR 
88ff cd dd 94			call break_point_state  
8902				endm  
# End of macro CALLMONITOR
8902				endif 
8902 2a 6b ea			ld hl, (store_tmppageid) 
8905 11 80 ea			ld de, store_page 
8908 cd de 81			call storage_write_block 
890b			 
890b				; find free block 
890b			 
890b 11 00 00			ld de, 0			 ; file extent to locate 
890e			 
890e 21 40 00				ld hl, STORE_BLOCK_PHY 
8911 cd ac 84				call storage_findnextid 
8914 cd 05 8d			call ishlzero 
8917 ca 67 88			jp z, .sa_notfound 
891a			 
891a					; TODO handle no space left 
891a					 
891a 22 6b ea				ld (store_tmppageid), hl 
891d			 
891d				if DEBUG_STORESE 
891d					DMARK "AP4" 
891d f5				push af  
891e 3a 32 89			ld a, (.dmark)  
8921 32 71 ee			ld (debug_mark),a  
8924 3a 33 89			ld a, (.dmark+1)  
8927 32 72 ee			ld (debug_mark+1),a  
892a 3a 34 89			ld a, (.dmark+2)  
892d 32 73 ee			ld (debug_mark+2),a  
8930 18 03			jr .pastdmark  
8932 ..			.dmark: db "AP4"  
8935 f1			.pastdmark: pop af  
8936			endm  
# End of macro DMARK
8936					CALLMONITOR 
8936 cd dd 94			call break_point_state  
8939				endm  
# End of macro CALLMONITOR
8939				endif 
8939					; init the buffer with zeros so we can id if the buffer is full or not 
8939			 
8939 e5					push hl 
893a c5					push bc 
893b			 
893b 21 80 ea				ld hl, store_page 
893e 06 40				ld b, STORE_BLOCK_PHY 
8940 3e 00				ld a, 0 
8942 77			.zeroblock:	ld (hl), a 
8943 23					inc hl 
8944 10 fc				djnz .zeroblock 
8946			 
8946 c1					pop bc 
8947 e1					pop hl 
8948			 
8948					; construct block 
8948			 
8948 3a 74 ea				ld a, (store_tmpid) 
894b 32 80 ea				ld (store_page), a   ; file id 
894e 3a 73 ea				ld a, (store_tmpext)   ; extent for this block 
8951 32 81 ea				ld (store_page+1), a 
8954			 
8954 e1					pop hl    ; get string to write 
8955 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8957 11 82 ea				ld de, store_page+2 
895a			 
895a				if DEBUG_STORESE 
895a					DMARK "AP5" 
895a f5				push af  
895b 3a 6f 89			ld a, (.dmark)  
895e 32 71 ee			ld (debug_mark),a  
8961 3a 70 89			ld a, (.dmark+1)  
8964 32 72 ee			ld (debug_mark+1),a  
8967 3a 71 89			ld a, (.dmark+2)  
896a 32 73 ee			ld (debug_mark+2),a  
896d 18 03			jr .pastdmark  
896f ..			.dmark: db "AP5"  
8972 f1			.pastdmark: pop af  
8973			endm  
# End of macro DMARK
8973					CALLMONITOR 
8973 cd dd 94			call break_point_state  
8976				endm  
# End of macro CALLMONITOR
8976				endif 
8976			 
8976			 
8976			 
8976					; fill buffer with data until end of string or full block 
8976			 
8976 7e			.appd:		ld a, (hl) 
8977 12					ld (de), a 
8978 fe 00				cp 0 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f6				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a 6b ea			ld hl, (store_tmppageid) 
8985 11 80 ea			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 71 ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 72 ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 73 ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd dd 94			call break_point_state  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd de 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9 fe 00				cp 0		 ; no, string was fully written 
89ab c8					ret z 
89ac			 
89ac					; setup vars for next cycle 
89ac			 
89ac 3a 74 ea				ld a, (store_tmpid) 
89af 6f					ld l, a 
89b0 26 00				ld h, 0 
89b2			 
89b2 c3 69 88			 	jp storage_append	 ; yes, need to write out some more 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			if DEBUG_STORECF 
89b5			storageput:	 
89b5					ret 
89b5			storageread: 
89b5					ld hl, store_page 
89b5					ld b, 200 
89b5					ld a,0 
89b5			.src:		ld (hl),a 
89b5					inc hl 
89b5					djnz .src 
89b5					 
89b5			 
89b5					ld de, 0 
89b5					ld bc, 1 
89b5					ld hl, store_page 
89b5					call cfRead 
89b5			 
89b5				call cfGetError 
89b5				ld hl,scratch 
89b5				call hexout 
89b5				ld hl, scratch+2 
89b5				ld a, 0 
89b5				ld (hl),a 
89b5				ld de, scratch 
89b5				ld a,display_row_1 
89b5				call str_at_display 
89b5				call update_display 
89b5			 
89b5					ld hl, store_page 
89b5					ld (os_cur_ptr),hl 
89b5			 
89b5					ret 
89b5			endif 
89b5			 
89b5			 
89b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b5			 
89b5			storage_clear_page: 
89b5 e5				push hl 
89b6 d5				push de 
89b7 c5				push bc 
89b8 21 80 ea			ld hl, store_page 
89bb 3e 00			ld a, 0 
89bd 77				ld (hl), a 
89be			 
89be 11 81 ea			ld de, store_page+1 
89c1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c4			 
89c4 ed b0			ldir 
89c6				 
89c6 c1				pop bc 
89c7 d1				pop de 
89c8 e1				pop hl 
89c9 c9				ret 
89ca			 
89ca			; eof 
# End of file firmware_storage.asm
89ca			  
89ca			; support routines for above hardware abstraction layer  
89ca			  
89ca			include "firmware_general.asm"        ; general support functions  
89ca			 
89ca			; word look up 
89ca			 
89ca			; in 
89ca			; a is the index 
89ca			; hl is pointer start of array 
89ca			; 
89ca			; returns 
89ca			; hl to the word 
89ca			; 
89ca			 
89ca			table_lookup:  
89ca d5					push de 
89cb eb					ex de, hl 
89cc			 
89cc 6f					ld l, a 
89cd 26 00				ld h, 0 
89cf 29					add hl, hl 
89d0 19					add hl, de 
89d1 7e					ld a, (hl) 
89d2 23					inc hl 
89d3 66					ld h,(hl) 
89d4 6f					ld l, a 
89d5			 
89d5 d1					pop de 
89d6 c9					ret 
89d7			 
89d7			; Delay loops 
89d7			 
89d7			 
89d7			 
89d7			aDelayInMS: 
89d7 c5				push bc 
89d8 47				ld b,a 
89d9			msdelay: 
89d9 c5				push bc 
89da				 
89da			 
89da 01 41 00			ld bc,041h 
89dd cd f5 89			call delayloop 
89e0 c1				pop bc 
89e1 05				dec b 
89e2 20 f5			jr nz,msdelay 
89e4			 
89e4			;if CPU_CLOCK_8MHZ 
89e4			;msdelay8: 
89e4			;	push bc 
89e4			;	 
89e4			; 
89e4			;	ld bc,041h 
89e4			;	call delayloop 
89e4			;	pop bc 
89e4			;	dec b 
89e4			;	jr nz,msdelay8 
89e4			;endif 
89e4			 
89e4			 
89e4 c1				pop bc 
89e5 c9				ret 
89e6			 
89e6			 
89e6			delay250ms: 
89e6				;push de 
89e6 01 00 40			ld bc, 04000h 
89e9 c3 f5 89			jp delayloop 
89ec			delay500ms: 
89ec				;push de 
89ec 01 00 80			ld bc, 08000h 
89ef c3 f5 89			jp delayloop 
89f2			delay1s: 
89f2				;push bc 
89f2			   ; Clobbers A, d and e 
89f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f5			delayloop: 
89f5 c5			    push bc 
89f6			 
89f6			if BASE_CPM 
89f6				ld bc, CPM_DELAY_TUNE 
89f6			.cpmloop: 
89f6				push bc 
89f6			 
89f6			endif 
89f6			 
89f6			 
89f6			 
89f6			delayloopi: 
89f6			;	push bc 
89f6			;.dl: 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa cb 47		    bit     0,a    	; 8 
89fc e6 ff		    and     255  	; 7 
89fe 0b			    dec     bc      	; 6 
89ff 79			    ld      a,c     	; 4 
8a00 b0			    or      b     	; 4 
8a01 c2 f6 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a04			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a04				;pop de 
8a04			;pop bc 
8a04			 
8a04			if BASE_CPM 
8a04				pop bc 
8a04				 
8a04			    dec     bc      	; 6 
8a04			    ld      a,c     	; 4 
8a04			    or      b     	; 4 
8a04			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a04				 
8a04			 
8a04			endif 
8a04			;if CPU_CLOCK_8MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04			 
8a04			;if CPU_CLOCK_10MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04 c1			    pop bc 
8a05			 
8a05 c9				ret 
8a06			 
8a06			 
8a06			 
8a06			; eof 
# End of file firmware_general.asm
8a06			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a06			; display routines that use the physical hardware abstraction layer 
8a06			 
8a06			 
8a06			; Display an activity indicator 
8a06			; Each call returns the new char pointed to in hl 
8a06			 
8a06			active: 
8a06 3a cc eb			ld a, (display_active) 
8a09 fe 06			cp 6 
8a0b			 
8a0b 20 02			jr nz, .sne 
8a0d				; gone past the last one reset sequence 
8a0d 3e ff			ld a, 255 
8a0f			 
8a0f			.sne:   
8a0f				; get the next char in seq 
8a0f 3c				inc a 
8a10 32 cc eb			ld (display_active), a 
8a13			 
8a13				; look up the string in the table 
8a13 21 2a 8a			ld hl, actseq 
8a16 cb 27			sla a 
8a18 cd dc 8c			call addatohl 
8a1b cd aa 9e			call loadwordinhl 
8a1e			 
8a1e				; forth will write the to string when pushing so move from rom to ram 
8a1e			 
8a1e 11 cd eb			ld de, display_active+1 
8a21 01 02 00			ld bc, 2 
8a24 ed b0			ldir 
8a26			 
8a26 21 cd eb			ld hl, display_active+1 
8a29 c9				ret 
8a2a				 
8a2a				 
8a2a			 
8a2a			 
8a2a			;db "|/-\|-\" 
8a2a			 
8a2a			actseq: 
8a2a			 
8a2a 38 8a		dw spin0 
8a2c 3a 8a		dw spin1 
8a2e 3c 8a		dw spin2 
8a30 3e 8a		dw spin3 
8a32 3c 8a		dw spin2 
8a34 3a 8a		dw spin1 
8a36 38 8a		dw spin0 
8a38			 
8a38 .. 00		spin0: db " ", 0 
8a3a .. 00		spin1: db "-", 0 
8a3c .. 00		spin2: db "+", 0 
8a3e .. 00		spin3: db "#", 0 
8a40			 
8a40			 
8a40			; information window 
8a40			 
8a40			; pass hl with 1st string to display 
8a40			; pass de with 2nd string to display 
8a40			 
8a40			info_panel: 
8a40 e5				push hl 
8a41			 
8a41 2a d2 eb			ld hl, (display_fb_active) 
8a44 e5				push hl    ; future de destination 
8a45 21 b7 ed				ld hl, display_fb0 
8a48 22 d2 eb				ld (display_fb_active), hl 
8a4b			 
8a4b			;	call clear_display 
8a4b			 
8a4b				if BASE_CPM 
8a4b				ld a, '.' 
8a4b				else 
8a4b 3e a5			ld a, 165 
8a4d				endif 
8a4d cd b4 8a			call fill_display 
8a50			 
8a50			 
8a50 3e 55			ld a, display_row_3 + 5 
8a52 cd c2 8a			call str_at_display 
8a55			 
8a55 e1				pop hl 
8a56 d1				pop de 
8a57			 
8a57 e5				push hl 
8a58			 
8a58			 
8a58 3e 2d			ld a, display_row_2 + 5 
8a5a cd c2 8a			call str_at_display 
8a5d			 
8a5d			 
8a5d cd d2 8a			call update_display 
8a60 cd f3 9a			call next_page_prompt 
8a63 cd af 8a			call clear_display 
8a66			 
8a66				 
8a66 21 16 ed				ld hl, display_fb1 
8a69 22 d2 eb				ld (display_fb_active), hl 
8a6c cd d2 8a			call update_display 
8a6f			 
8a6f e1				pop hl 
8a70			 
8a70 c9				ret 
8a71			 
8a71			 
8a71			 
8a71			 
8a71			; TODO windowing? 
8a71			 
8a71			; TODO scroll line up 
8a71			 
8a71			scroll_up: 
8a71			 
8a71 e5				push hl 
8a72 d5				push de 
8a73 c5				push bc 
8a74			 
8a74				; get frame buffer  
8a74			 
8a74 2a d2 eb			ld hl, (display_fb_active) 
8a77 e5				push hl    ; future de destination 
8a78			 
8a78 11 28 00			ld  de, display_cols 
8a7b 19				add hl, de 
8a7c			 
8a7c d1				pop de 
8a7d			 
8a7d				;ex de, hl 
8a7d 01 9f 00			ld bc, display_fb_len -1  
8a80			;if DEBUG_FORTH_WORDS 
8a80			;	DMARK "SCL" 
8a80			;	CALLMONITOR 
8a80			;endif	 
8a80 ed b0			ldir 
8a82			 
8a82				; wipe bottom row 
8a82			 
8a82			 
8a82 2a d2 eb			ld hl, (display_fb_active) 
8a85 11 a0 00			ld de, display_cols*display_rows 
8a88 19				add hl, de 
8a89 06 28			ld b, display_cols 
8a8b 3e 20			ld a, ' ' 
8a8d			.scwipe: 
8a8d 77				ld (hl), a 
8a8e 2b				dec hl 
8a8f 10 fc			djnz .scwipe 
8a91			 
8a91				;pop hl 
8a91			 
8a91 c1				pop bc 
8a92 d1				pop de 
8a93 e1				pop hl 
8a94			 
8a94 c9				ret 
8a95			 
8a95			 
8a95			;scroll_upo: 
8a95			;	ld de, display_row_1 
8a95			 ;	ld hl, display_row_2 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_2 
8a95			 ;	ld hl, display_row_3 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_3 
8a95			 ;	ld hl, display_row_4 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			 
8a95			; TODO clear row 4 
8a95			 
8a95			;	ret 
8a95			 
8a95				 
8a95			scroll_down: 
8a95			 
8a95 e5				push hl 
8a96 d5				push de 
8a97 c5				push bc 
8a98			 
8a98				; get frame buffer  
8a98			 
8a98 2a d2 eb			ld hl, (display_fb_active) 
8a9b			 
8a9b 11 9f 00			ld de, display_fb_len - 1 
8a9e 19				add hl, de 
8a9f			 
8a9f e5			push hl    ; future de destination 
8aa0			 
8aa0 11 28 00			ld  de, display_cols 
8aa3 ed 52			sbc hl, de 
8aa5			 
8aa5			 
8aa5 d1				pop de 
8aa6			 
8aa6			;	ex de, hl 
8aa6 01 9f 00			ld bc, display_fb_len -1  
8aa9			 
8aa9			 
8aa9				 
8aa9			 
8aa9 ed b0			ldir 
8aab			 
8aab				; wipe bottom row 
8aab			 
8aab			 
8aab			;	ld hl, (display_fb_active) 
8aab			;;	ld de, display_cols*display_rows 
8aab			;;	add hl, de 
8aab			;	ld b, display_cols 
8aab			;	ld a, ' ' 
8aab			;.scwiped: 
8aab			;	ld (hl), a 
8aab			;	dec hl 
8aab			;	djnz .scwiped 
8aab			 
8aab				;pop hl 
8aab			 
8aab c1				pop bc 
8aac d1				pop de 
8aad e1				pop hl 
8aae			 
8aae c9				ret 
8aaf			;scroll_down: 
8aaf			;	ld de, display_row_4 
8aaf			;	ld hl, display_row_3 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_3 
8aaf			; 	ld hl, display_row_2 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_2 
8aaf			;	ld hl, display_row_1 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;;; TODO clear row 1 
8aaf			;	ret 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			; clear active frame buffer 
8aaf			 
8aaf			clear_display: 
8aaf 3e 20			ld a, ' ' 
8ab1 c3 b4 8a			jp fill_display 
8ab4			 
8ab4			; fill active frame buffer with a char in A 
8ab4			 
8ab4			fill_display: 
8ab4 06 a0			ld b,display_fb_len 
8ab6 2a d2 eb			ld hl, (display_fb_active) 
8ab9 77			.fd1:	ld (hl),a 
8aba 23				inc hl 
8abb 10 fc			djnz .fd1 
8abd 23				inc hl 
8abe 3e 00			ld a,0 
8ac0 77				ld (hl),a 
8ac1			 
8ac1			 
8ac1 c9				ret 
8ac2			; Write string (DE) at pos (A) to active frame buffer 
8ac2			 
8ac2 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
8ac5 06 00					ld b,0 
8ac7 4f					ld c,a 
8ac8 09					add hl,bc 
8ac9 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8aca b7			            OR   A              ;Null terminator? 
8acb c8			            RET  Z              ;Yes, so finished 
8acc 77					ld (hl),a 
8acd 23				inc hl 
8ace 13			            INC  DE             ;Point to next character 
8acf 18 f8		            JR   .sad1     ;Repeat 
8ad1 c9					ret 
8ad2			 
8ad2			; using current frame buffer write to physical display 
8ad2			 
8ad2			update_display: 
8ad2 e5				push hl 
8ad3 2a d2 eb			ld hl, (display_fb_active) 
8ad6 cd dc e2			call write_display 
8ad9 e1				pop hl 
8ada c9				ret 
8adb			 
8adb			; TODO scrolling 
8adb			 
8adb			 
8adb			; move cursor right one char 
8adb			cursor_right: 
8adb			 
8adb				; TODO shift right 
8adb				; TODO if beyond max col 
8adb				; TODO       cursor_next_line 
8adb			 
8adb c9				ret 
8adc			 
8adc			 
8adc			cursor_next_line: 
8adc				; TODO first char 
8adc				; TODO line down 
8adc				; TODO if past last row 
8adc				; TODO    scroll up 
8adc			 
8adc c9				ret 
8add			 
8add			cursor_left: 
8add				; TODO shift left 
8add				; TODO if beyond left  
8add				; TODO     cursor prev line 
8add				 
8add c9				ret 
8ade			 
8ade			cursor_prev_line: 
8ade				; TODO last char 
8ade				; TODO line up 
8ade				; TODO if past first row 
8ade				; TODO   scroll down 
8ade			 
8ade c9				ret 
8adf			 
8adf			 
8adf			cout: 
8adf				; A - char 
8adf c9				ret 
8ae0			 
8ae0			 
8ae0			; Display a menu and allow item selection (optional toggle items) 
8ae0			; 
8ae0			; format: 
8ae0			; hl pointer to word array with zero term for items 
8ae0			; e.g.    db item1 
8ae0			;         db .... 
8ae0			;         db 0 
8ae0			; 
8ae0			; a = starting menu item  
8ae0			; 
8ae0			; de = pointer item toggle array   (todo) 
8ae0			; 
8ae0			; returns item selected in a 1-... 
8ae0			; returns 0 if back button pressed 
8ae0			; 
8ae0			; NOTE: Uses system frame buffer to display 
8ae0			; 
8ae0			; LEFT, Q = go back 
8ae0			; RIGHT, SPACE, CR = select 
8ae0			; UP, A - Up 
8ae0			; DOWN, Z - Down 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			menu: 
8ae0			 
8ae0					; keep array pointer 
8ae0			 
8ae0 22 79 ea				ld (store_tmp1), hl 
8ae3 32 77 ea				ld (store_tmp2), a 
8ae6			 
8ae6					; check for key bounce 
8ae6			 
8ae6			if BASE_KEV 
8ae6			 
8ae6			.mbounce:	call cin 
8ae6					cp 0 
8ae6					jr nz, .mbounce 
8ae6			endif 
8ae6					; for ease use ex 
8ae6			 
8ae6					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae6 21 b7 ed				ld hl, display_fb0 
8ae9 22 d2 eb				ld (display_fb_active), hl 
8aec			 
8aec cd af 8a		.mloop:		call clear_display 
8aef cd d2 8a				call update_display 
8af2			 
8af2					; draw selection id '>' at 1 
8af2			 
8af2					; init start of list display 
8af2			 
8af2 3e 05				ld a, 5 
8af4 32 75 ea				ld (store_tmp3), a   ; display row count 
8af7 3a 77 ea				ld a,( store_tmp2) 
8afa 32 78 ea				ld (store_tmp2+1), a   ; display item count 
8afd			 
8afd					 
8afd			.mitem:	 
8afd			 
8afd			 
8afd 3a 78 ea				ld a,(store_tmp2+1) 
8b00 6f					ld l, a 
8b01 26 00				ld h, 0 
8b03 29					add hl, hl 
8b04 ed 5b 79 ea			ld de, (store_tmp1) 
8b08 19					add hl, de 
8b09 7e					ld a, (hl) 
8b0a 23					inc hl 
8b0b 66					ld h,(hl) 
8b0c 6f					ld l, a 
8b0d			 
8b0d cd 05 8d				call ishlzero 
8b10 28 1a				jr z, .mdone 
8b12			 
8b12 eb					ex de, hl 
8b13 3a 75 ea				ld a, (store_tmp3) 
8b16 cd c2 8a				call str_at_display 
8b19					 
8b19			 
8b19					; next item 
8b19 3a 78 ea				ld a, (store_tmp2+1) 
8b1c 3c					inc a 
8b1d 32 78 ea				ld (store_tmp2+1), a   ; display item count 
8b20			 
8b20			 		; next row 
8b20			 
8b20 3a 75 ea				ld a, (store_tmp3) 
8b23 c6 28				add display_cols 
8b25 32 75 ea				ld (store_tmp3), a 
8b28			 
8b28					; at end of screen? 
8b28			 
8b28 fe 10				cp display_rows*4 
8b2a 20 d1				jr nz, .mitem 
8b2c			 
8b2c			 
8b2c			.mdone: 
8b2c cd 05 8d				call ishlzero 
8b2f 28 08				jr z, .nodn 
8b31			 
8b31 3e 78				ld a, display_row_4 
8b33 11 b2 8b				ld de, .mdown 
8b36 cd c2 8a				call str_at_display 
8b39			 
8b39					; draw options to fill the screens with active item on line 1 
8b39					; if current option is 2 or more then display ^ in top 
8b39			 
8b39 3a 77 ea		.nodn:		ld a, (store_tmp2) 
8b3c fe 00				cp 0 
8b3e 28 08				jr z, .noup 
8b40			 
8b40 3e 00				ld a, 0 
8b42 11 b0 8b				ld de, .mup 
8b45 cd c2 8a				call str_at_display 
8b48			 
8b48 3e 02		.noup:		ld a, 2 
8b4a 11 ae 8b				ld de, .msel 
8b4d cd c2 8a				call str_at_display 
8b50			 
8b50					; if current option + 1 is not null then display V in bottom 
8b50					; get key 
8b50 cd d2 8a				call update_display 
8b53			 
8b53			 
8b53					; handle key 
8b53			 
8b53 cd 68 e3				call cin_wait 
8b56			 
8b56 fe 05				cp KEY_UP 
8b58 28 2b				jr z, .mgoup 
8b5a fe 61				cp 'a' 
8b5c 28 27				jr z, .mgoup 
8b5e fe 0a				cp KEY_DOWN 
8b60 28 32				jr z, .mgod 
8b62 fe 7a				cp 'z' 
8b64 28 2e				jr z, .mgod 
8b66 fe 20				cp ' ' 
8b68 28 34				jr z, .goend 
8b6a fe 0c				cp KEY_RIGHT 
8b6c 28 30				jr z, .goend 
8b6e fe 0d				cp KEY_CR 
8b70 28 2c				jr z, .goend 
8b72 fe 71				cp 'q' 
8b74 28 0b				jr z, .goback 
8b76			 
8b76 fe 0b				cp KEY_LEFT 
8b78 28 07				jr z, .goback 
8b7a fe 08				cp KEY_BS 
8b7c 28 03				jr z, .goback 
8b7e c3 ec 8a				jp .mloop 
8b81			 
8b81			.goback: 
8b81 3e 00			ld a, 0 
8b83 18 1d			jr .goend2 
8b85			 
8b85				; move up one 
8b85			.mgoup: 
8b85 3a 77 ea				ld a, (store_tmp2) 
8b88 fe 00				cp 0 
8b8a ca ec 8a				jp z, .mloop 
8b8d 3d					dec a 
8b8e 32 77 ea				ld (store_tmp2), a 
8b91 c3 ec 8a				jp .mloop 
8b94			 
8b94				; move down one 
8b94			.mgod: 
8b94 3a 77 ea				ld a, (store_tmp2) 
8b97 3c					inc a 
8b98 32 77 ea				ld (store_tmp2), a 
8b9b c3 ec 8a				jp .mloop 
8b9e			 
8b9e			 
8b9e			.goend: 
8b9e					; get selected item number 
8b9e			 
8b9e 3a 77 ea				ld a, (store_tmp2) 
8ba1 3c					inc a 
8ba2			 
8ba2			.goend2: 
8ba2 f5					push af 
8ba3			 
8ba3					; restore active fb 
8ba3					; TODO BUG assumes fb1 
8ba3			 
8ba3 21 16 ed				ld hl, display_fb1 
8ba6 22 d2 eb				ld (display_fb_active), hl 
8ba9			 
8ba9					; restore main regs 
8ba9			 
8ba9			 
8ba9 cd d2 8a				call update_display 
8bac			 
8bac f1					pop af 
8bad			 
8bad c9				ret 
8bae			 
8bae .. 00		.msel:   db ">",0 
8bb0 .. 00		.mup:   db "^",0 
8bb2 .. 00		.mdown:   db "v",0 
8bb4			 
8bb4			 
8bb4			; eof 
8bb4			 
# End of file firmware_display.asm
8bb4			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb4			; random number generators 
8bb4			 
8bb4			 
8bb4			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb4			 
8bb4			 
8bb4			;-----> Generate a random number 
8bb4			; output a=answer 0<=a<=255 
8bb4			; all registers are preserved except: af 
8bb4			random: 
8bb4 e5			        push    hl 
8bb5 d5			        push    de 
8bb6 2a b1 eb		        ld      hl,(randData) 
8bb9 ed 5f		        ld      a,r 
8bbb 57			        ld      d,a 
8bbc 5e			        ld      e,(hl) 
8bbd 19			        add     hl,de 
8bbe 85			        add     a,l 
8bbf ac			        xor     h 
8bc0 22 b1 eb		        ld      (randData),hl 
8bc3 d1			        pop     de 
8bc4 e1			        pop     hl 
8bc5 c9			        ret 
8bc6			 
8bc6			 
8bc6			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc6			 
8bc6			 
8bc6			 
8bc6			;------LFSR------ 
8bc6			;James Montelongo 
8bc6			;optimized by Spencer Putt 
8bc6			;out: 
8bc6			; a = 8 bit random number 
8bc6			RandLFSR: 
8bc6 21 b7 eb		        ld hl,LFSRSeed+4 
8bc9 5e			        ld e,(hl) 
8bca 23			        inc hl 
8bcb 56			        ld d,(hl) 
8bcc 23			        inc hl 
8bcd 4e			        ld c,(hl) 
8bce 23			        inc hl 
8bcf 7e			        ld a,(hl) 
8bd0 47			        ld b,a 
8bd1 cb 13		        rl e  
8bd3 cb 12			rl d 
8bd5 cb 11		        rl c  
8bd7 17				rla 
8bd8 cb 13		        rl e  
8bda cb 12			rl d 
8bdc cb 11		        rl c  
8bde 17				rla 
8bdf cb 13		        rl e  
8be1 cb 12			rl d 
8be3 cb 11		        rl c  
8be5 17				rla 
8be6 67			        ld h,a 
8be7 cb 13		        rl e  
8be9 cb 12			rl d 
8beb cb 11		        rl c  
8bed 17				rla 
8bee a8			        xor b 
8bef cb 13		        rl e  
8bf1 cb 12			rl d 
8bf3 ac			        xor h 
8bf4 a9			        xor c 
8bf5 aa			        xor d 
8bf6 21 b9 eb		        ld hl,LFSRSeed+6 
8bf9 11 ba eb		        ld de,LFSRSeed+7 
8bfc 01 07 00		        ld bc,7 
8bff ed b8		        lddr 
8c01 12			        ld (de),a 
8c02 c9			        ret 
8c03			 
8c03			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c03			 
8c03			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c03			 
8c03			 
8c03			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c03			 
8c03			prng16: 
8c03			;Inputs: 
8c03			;   (seed1) contains a 16-bit seed value 
8c03			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c03			;Outputs: 
8c03			;   HL is the result 
8c03			;   BC is the result of the LCG, so not that great of quality 
8c03			;   DE is preserved 
8c03			;Destroys: 
8c03			;   AF 
8c03			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c03			;160cc 
8c03			;26 bytes 
8c03 2a ab eb		    ld hl,(seed1) 
8c06 44			    ld b,h 
8c07 4d			    ld c,l 
8c08 29			    add hl,hl 
8c09 29			    add hl,hl 
8c0a 2c			    inc l 
8c0b 09			    add hl,bc 
8c0c 22 ab eb		    ld (seed1),hl 
8c0f 2a a9 eb		    ld hl,(seed2) 
8c12 29			    add hl,hl 
8c13 9f			    sbc a,a 
8c14 e6 2d		    and %00101101 
8c16 ad			    xor l 
8c17 6f			    ld l,a 
8c18 22 a9 eb		    ld (seed2),hl 
8c1b 09			    add hl,bc 
8c1c c9			    ret 
8c1d			 
8c1d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1d			 
8c1d			rand32: 
8c1d			;Inputs: 
8c1d			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1d			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1d			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1d			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1d			;   **NOTE: seed2 must be non-zero 
8c1d			;Outputs: 
8c1d			;   HL is the result 
8c1d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1d			;Destroys: 
8c1d			;   AF 
8c1d			;Tested and passes all CAcert tests 
8c1d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1d			;it has a period of 18,446,744,069,414,584,320 
8c1d			;roughly 18.4 quintillion. 
8c1d			;LFSR taps: 0,2,6,7  = 11000101 
8c1d			;291cc 
8c1d			;seed1_0=$+1 
8c1d			;    ld hl,12345 
8c1d			;seed1_1=$+1 
8c1d			;    ld de,6789 
8c1d			;    ld b,h 
8c1d			;    ld c,l 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    inc l 
8c1d			;    add hl,bc 
8c1d			;    ld (seed1_0),hl 
8c1d			;    ld hl,(seed1_1) 
8c1d			;    adc hl,de 
8c1d			;    ld (seed1_1),hl 
8c1d			;    ex de,hl 
8c1d			;seed2_0=$+1 
8c1d			;    ld hl,9876 
8c1d			;seed2_1=$+1 
8c1d			;    ld bc,54321 
8c1d			;    add hl,hl \ rl c \ rl b 
8c1d			;    ld (seed2_1),bc 
8c1d			;    sbc a,a 
8c1d			;    and %11000101 
8c1d			;    xor l 
8c1d			;    ld l,a 
8c1d			;    ld (seed2_0),hl 
8c1d			;    ex de,hl 
8c1d			;    add hl,bc 
8c1d			;    ret 
8c1d			; 
8c1d			 
8c1d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1d			; 20 bytes, 86 cycles (excluding ret) 
8c1d			 
8c1d			; returns   hl = pseudorandom number 
8c1d			; corrupts   a 
8c1d			 
8c1d			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1d			; using the xorshift method: 
8c1d			 
8c1d			; hl ^= hl << 7 
8c1d			; hl ^= hl >> 9 
8c1d			; hl ^= hl << 8 
8c1d			 
8c1d			; some alternative shift triplets which also perform well are: 
8c1d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1d			 
8c1d			;  org 32768 
8c1d			 
8c1d			xrnd: 
8c1d 2a af eb		  ld hl,(xrandc)       ; seed must not be 0 
8c20 3e 00		  ld a,0 
8c22 bd			  cp l 
8c23 20 02		  jr nz, .xrnd1 
8c25 2e 01		  ld l, 1 
8c27			.xrnd1: 
8c27			 
8c27 7c			  ld a,h 
8c28 1f			  rra 
8c29 7d			  ld a,l 
8c2a 1f			  rra 
8c2b ac			  xor h 
8c2c 67			  ld h,a 
8c2d 7d			  ld a,l 
8c2e 1f			  rra 
8c2f 7c			  ld a,h 
8c30 1f			  rra 
8c31 ad			  xor l 
8c32 6f			  ld l,a 
8c33 ac			  xor h 
8c34 67			  ld h,a 
8c35			 
8c35 22 af eb		  ld (xrandc),hl 
8c38			 
8c38 c9			  ret 
8c39			;  
8c39			 
8c39			 
8c39			;;;; int maths 
8c39			 
8c39			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c39			; Divide 16-bit values (with 16-bit result) 
8c39			; In: Divide BC by divider DE 
8c39			; Out: BC = result, HL = rest 
8c39			; 
8c39			Div16: 
8c39 21 00 00		    ld hl,0 
8c3c 78			    ld a,b 
8c3d 06 08		    ld b,8 
8c3f			Div16_Loop1: 
8c3f 17			    rla 
8c40 ed 6a		    adc hl,hl 
8c42 ed 52		    sbc hl,de 
8c44 30 01		    jr nc,Div16_NoAdd1 
8c46 19			    add hl,de 
8c47			Div16_NoAdd1: 
8c47 10 f6		    djnz Div16_Loop1 
8c49 17			    rla 
8c4a 2f			    cpl 
8c4b 47			    ld b,a 
8c4c 79			    ld a,c 
8c4d 48			    ld c,b 
8c4e 06 08		    ld b,8 
8c50			Div16_Loop2: 
8c50 17			    rla 
8c51 ed 6a		    adc hl,hl 
8c53 ed 52		    sbc hl,de 
8c55 30 01		    jr nc,Div16_NoAdd2 
8c57 19			    add hl,de 
8c58			Div16_NoAdd2: 
8c58 10 f6		    djnz Div16_Loop2 
8c5a 17			    rla 
8c5b 2f			    cpl 
8c5c 41			    ld b,c 
8c5d 4f			    ld c,a 
8c5e c9			ret 
8c5f			 
8c5f			 
8c5f			;http://z80-heaven.wikidot.com/math 
8c5f			; 
8c5f			;Inputs: 
8c5f			;     DE and A are factors 
8c5f			;Outputs: 
8c5f			;     A is not changed 
8c5f			;     B is 0 
8c5f			;     C is not changed 
8c5f			;     DE is not changed 
8c5f			;     HL is the product 
8c5f			;Time: 
8c5f			;     342+6x 
8c5f			; 
8c5f			Mult16: 
8c5f			 
8c5f 06 08		     ld b,8          ;7           7 
8c61 21 00 00		     ld hl,0         ;10         10 
8c64 29			       add hl,hl     ;11*8       88 
8c65 07			       rlca          ;4*8        32 
8c66 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c68 19			         add hl,de   ;--         -- 
8c69 10 f9		       djnz $-5      ;13*7+8     99 
8c6b c9			ret 
8c6c			 
8c6c			; 
8c6c			; Square root of 16-bit value 
8c6c			; In:  HL = value 
8c6c			; Out:  D = result (rounded down) 
8c6c			; 
8c6c			;Sqr16: 
8c6c			;    ld de,#0040 
8c6c			;    ld a,l 
8c6c			;    ld l,h 
8c6c			;    ld h,d 
8c6c			;    or a 
8c6c			;    ld b,8 
8c6c			;Sqr16_Loop: 
8c6c			;    sbc hl,de 
8c6c			;    jr nc,Sqr16_Skip 
8c6c			;    add hl,de 
8c6c			;Sqr16_Skip: 
8c6c			;    ccf 
8c6c			;    rl d 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    djnz Sqr16_Loop 
8c6c			;    ret 
8c6c			; 
8c6c			; 
8c6c			; Divide 8-bit values 
8c6c			; In: Divide E by divider C 
8c6c			; Out: A = result, B = rest 
8c6c			; 
8c6c			Div8: 
8c6c af			    xor a 
8c6d 06 08		    ld b,8 
8c6f			Div8_Loop: 
8c6f cb 13		    rl e 
8c71 17			    rla 
8c72 91			    sub c 
8c73 30 01		    jr nc,Div8_NoAdd 
8c75 81			    add a,c 
8c76			Div8_NoAdd: 
8c76 10 f7		    djnz Div8_Loop 
8c78 47			    ld b,a 
8c79 7b			    ld a,e 
8c7a 17			    rla 
8c7b 2f			    cpl 
8c7c c9			    ret 
8c7d			 
8c7d			; 
8c7d			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7d			; In: Multiply A with DE 
8c7d			; Out: HL = result 
8c7d			; 
8c7d			Mult12U: 
8c7d 2e 00		    ld l,0 
8c7f 87			    add a,a 
8c80 30 01		    jr nc,Mult12U_NoAdd0 
8c82 19			    add hl,de 
8c83			Mult12U_NoAdd0: 
8c83 29			    add hl,hl 
8c84 87			    add a,a 
8c85 30 01		    jr nc,Mult12U_NoAdd1 
8c87 19			    add hl,de 
8c88			Mult12U_NoAdd1: 
8c88 29			    add hl,hl 
8c89 87			    add a,a 
8c8a 30 01		    jr nc,Mult12U_NoAdd2 
8c8c 19			    add hl,de 
8c8d			Mult12U_NoAdd2: 
8c8d 29			    add hl,hl 
8c8e 87			    add a,a 
8c8f 30 01		    jr nc,Mult12U_NoAdd3 
8c91 19			    add hl,de 
8c92			Mult12U_NoAdd3: 
8c92 29			    add hl,hl 
8c93 87			    add a,a 
8c94 30 01		    jr nc,Mult12U_NoAdd4 
8c96 19			    add hl,de 
8c97			Mult12U_NoAdd4: 
8c97 29			    add hl,hl 
8c98 87			    add a,a 
8c99 30 01		    jr nc,Mult12U_NoAdd5 
8c9b 19			    add hl,de 
8c9c			Mult12U_NoAdd5: 
8c9c 29			    add hl,hl 
8c9d 87			    add a,a 
8c9e 30 01		    jr nc,Mult12U_NoAdd6 
8ca0 19			    add hl,de 
8ca1			Mult12U_NoAdd6: 
8ca1 29			    add hl,hl 
8ca2 87			    add a,a 
8ca3 d0			    ret nc 
8ca4 19			    add hl,de 
8ca5 c9			    ret 
8ca6			 
8ca6			; 
8ca6			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca6			; In: Multiply A with DE 
8ca6			;      Put lowest value in A for most efficient calculation 
8ca6			; Out: HL = result 
8ca6			; 
8ca6			Mult12R: 
8ca6 21 00 00		    ld hl,0 
8ca9			Mult12R_Loop: 
8ca9 cb 3f		    srl a 
8cab 30 01		    jr nc,Mult12R_NoAdd 
8cad 19			    add hl,de 
8cae			Mult12R_NoAdd: 
8cae cb 23		    sla e 
8cb0 cb 12		    rl d 
8cb2 b7			    or a 
8cb3 c2 a9 8c		    jp nz,Mult12R_Loop 
8cb6 c9			    ret 
8cb7			 
8cb7			; 
8cb7			; Multiply 16-bit values (with 32-bit result) 
8cb7			; In: Multiply BC with DE 
8cb7			; Out: BCHL = result 
8cb7			; 
8cb7			Mult32: 
8cb7 79			    ld a,c 
8cb8 48			    ld c,b 
8cb9 21 00 00		    ld hl,0 
8cbc 06 10		    ld b,16 
8cbe			Mult32_Loop: 
8cbe 29			    add hl,hl 
8cbf 17			    rla 
8cc0 cb 11		    rl c 
8cc2 30 07		    jr nc,Mult32_NoAdd 
8cc4 19			    add hl,de 
8cc5 ce 00		    adc a,0 
8cc7 d2 cb 8c		    jp nc,Mult32_NoAdd 
8cca 0c			    inc c 
8ccb			Mult32_NoAdd: 
8ccb 10 f1		    djnz Mult32_Loop 
8ccd 41			    ld b,c 
8cce 4f			    ld c,a 
8ccf c9			    ret 
8cd0			 
8cd0			 
8cd0			 
8cd0			; 
8cd0			; Multiply 8-bit values 
8cd0			; In:  Multiply H with E 
8cd0			; Out: HL = result 
8cd0			; 
8cd0			Mult8: 
8cd0 16 00		    ld d,0 
8cd2 6a			    ld l,d 
8cd3 06 08		    ld b,8 
8cd5			Mult8_Loop: 
8cd5 29			    add hl,hl 
8cd6 30 01		    jr nc,Mult8_NoAdd 
8cd8 19			    add hl,de 
8cd9			Mult8_NoAdd: 
8cd9 10 fa		    djnz Mult8_Loop 
8cdb c9			    ret 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			;;http://z80-heaven.wikidot.com/math 
8cdc			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdc			; 
8cdc			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdc			;     ld a,16        ;7 
8cdc			;     ld hl,0        ;10 
8cdc			;     jp $+5         ;10 
8cdc			;.DivLoop: 
8cdc			;       add hl,bc    ;-- 
8cdc			;       dec a        ;64 
8cdc			;       jr z,.DivLoopEnd        ;86 
8cdc			; 
8cdc			;       sla e        ;128 
8cdc			;       rl d         ;128 
8cdc			;       adc hl,hl    ;240 
8cdc			;       sbc hl,bc    ;240 
8cdc			;       jr nc,.DivLoop ;23|21 
8cdc			;       inc e        ;-- 
8cdc			;       jp .DivLoop+1 
8cdc			; 
8cdc			;.DivLoopEnd: 
8cdc			 
8cdc			;HL_Div_C: 
8cdc			;Inputs: 
8cdc			;     HL is the numerator 
8cdc			;     C is the denominator 
8cdc			;Outputs: 
8cdc			;     A is the remainder 
8cdc			;     B is 0 
8cdc			;     C is not changed 
8cdc			;     DE is not changed 
8cdc			;     HL is the quotient 
8cdc			; 
8cdc			;       ld b,16 
8cdc			;       xor a 
8cdc			;         add hl,hl 
8cdc			;         rla 
8cdc			;         cp c 
8cdc			;         jr c,$+4 
8cdc			;           inc l 
8cdc			;           sub c 
8cdc			;         djnz $-7 
8cdc			 
8cdc			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdc			 
8cdc			addatohl: 
8cdc 85			    add   a, l    ; A = A+L 
8cdd 6f			    ld    l, a    ; L = A+L 
8cde 8c			    adc   a, h    ; A = A+L+H+carry 
8cdf 95			    sub   l       ; A = H+carry 
8ce0 67			    ld    h, a    ; H = H+carry 
8ce1 c9			ret 
8ce2			 
8ce2			addatode: 
8ce2 83			    add   a, e    ; A = A+L 
8ce3 5f			    ld    e, a    ; L = A+L 
8ce4 8a			    adc   a, d    ; A = A+L+H+carry 
8ce5 93			    sub   e       ; A = H+carry 
8ce6 57			    ld    d, a    ; H = H+carry 
8ce7 c9			ret 
8ce8			 
8ce8			 
8ce8			addatobc: 
8ce8 81			    add   a, c    ; A = A+L 
8ce9 4f			    ld    c, a    ; L = A+L 
8cea 88			    adc   a, b    ; A = A+L+H+carry 
8ceb 91			    sub   c       ; A = H+carry 
8cec 47			    ld    b, a    ; H = H+carry 
8ced c9			ret 
8cee			 
8cee			subafromhl: 
8cee			   ; If A=0 do nothing 
8cee			    ; Otherwise flip A's sign. Since 
8cee			    ; the upper byte becomes -1, also 
8cee			    ; substract 1 from H. 
8cee ed 44		    neg 
8cf0 ca f9 8c		    jp    z, Skip 
8cf3 25			    dec   h 
8cf4			     
8cf4			    ; Now add the low byte as usual 
8cf4			    ; Two's complement takes care of 
8cf4			    ; ensuring the result is correct 
8cf4 85			    add   a, l 
8cf5 6f			    ld    l, a 
8cf6 8c			    adc   a, h 
8cf7 95			    sub   l 
8cf8 67			    ld    h, a 
8cf9			Skip: 
8cf9 c9				ret 
8cfa			 
8cfa			 
8cfa			; compare hl and de 
8cfa			; returns:  
8cfa			; if hl = de, z=1, s=0, c0=0 
8cfa			; if hl > de, z=0, s=0, c=0 
8cfa			; if hl < de, z=0, s=1, c=1 
8cfa			cmp16:	 
8cfa b7				or a 
8cfb ed 52			sbc hl,de 
8cfd e0				ret po 
8cfe 7c				ld a,h 
8cff 1f				rra 
8d00 ee 40			xor 01000000B 
8d02 37				scf 
8d03 8f				adc a,a 
8d04 c9				ret 
8d05			 
8d05			 
8d05			; test if hl contains zero   - A is destroyed 
8d05			 
8d05			ishlzero:    
8d05 b7				or a     ; reset flags 
8d06 7c				ld a, h 
8d07 b5				or l        	 
8d08			 
8d08 c9				ret 
8d09			 
8d09			 
8d09			 
8d09			 
8d09			if FORTH_ENABLE_FLOATMATH 
8d09			;include "float/bbcmath.z80" 
8d09			include "float/lpfpcalc.asm" 
8d09			endif 
8d09			 
8d09			 
8d09			; eof 
8d09			 
# End of file firmware_maths.asm
8d09			include "firmware_strings.asm"   ; string handling  
8d09			 
8d09			 
8d09			; TODO string len 
8d09			; input text string, end on cr with zero term 
8d09			; a offset into frame buffer to start prompt 
8d09			; d is max length 
8d09			; e is display size TODO 
8d09			; c is current cursor position 
8d09			; hl is ptr to where string will be stored 
8d09			 
8d09			 
8d09			; TODO check limit of buffer for new inserts 
8d09			; TODO check insert does not push beyond buffer 
8d09			; TODO scroll in a limited display area 
8d09			; TODO scroll whole screen on page wrap 
8d09			 
8d09			 
8d09			; TODO handle KEY_PREVWORD 
8d09			; TODO handle KEY_NEXTWORD 
8d09			; TODO handle KEY_HOME 
8d09			; TODO handle KEY_END 
8d09			; TODO use LCD cursor? 
8d09			 
8d09 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8d0c 81					add c 
8d0d 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8d10 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
8d13 79					ld a, c 
8d14 cd dc 8c				call addatohl 
8d17 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8d1a 7a					ld a,d 
8d1b 32 6c ee			        ld (input_size), a       ; save length of input area 
8d1e 79					ld a, c 
8d1f 32 5b ee				ld (input_cursor),a      ; init cursor start position  
8d22 7b					ld a,e 
8d23 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d26					 
8d26					 
8d26			 
8d26			;		ld a,(input_ptr) 
8d26			;		ld (input_under_cursor),a 	; save what is under the cursor 
8d26			 
8d26			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d26					; init cursor shape if not set by the cin routines 
8d26 21 c7 eb				ld hl, cursor_shape 
8d29 3e ff				ld a, 255 
8d2b 77					ld (hl), a 
8d2c 23					inc hl 
8d2d 3e 00				ld a, 0 
8d2f 77					ld (hl), a 
8d30			 
8d30 3e 0f				ld a, CUR_BLINK_RATE 
8d32 32 66 ee				ld (input_cur_flash), a 
8d35 3e 01				ld a, 1 
8d37 32 65 ee				ld (input_cur_onoff),a 
8d3a			 
8d3a			;	if DEBUG_INPUT 
8d3a			;		push af 
8d3a			;		ld a, 'I' 
8d3a			;		ld (debug_mark),a 
8d3a			;		pop af 
8d3a			;		CALLMONITOR 
8d3a			;	endif 
8d3a			.is1:		; main entry loop 
8d3a			 
8d3a			 
8d3a			 
8d3a					; pause 1ms 
8d3a			 
8d3a 3e 01				ld a, 1 
8d3c cd d7 89				call aDelayInMS 
8d3f			 
8d3f					; dec flash counter 
8d3f 3a 66 ee				ld a, (input_cur_flash) 
8d42 3d					dec a 
8d43 32 66 ee				ld (input_cur_flash), a 
8d46 fe 00				cp 0 
8d48 20 0d				jr nz, .nochgstate 
8d4a			 
8d4a			 
8d4a					; change state 
8d4a 3a 65 ee				ld a,(input_cur_onoff) 
8d4d ed 44				neg 
8d4f 32 65 ee				ld (input_cur_onoff),a 
8d52			 
8d52			 
8d52					; reset on change of state 
8d52 3e 0f				ld a, CUR_BLINK_RATE 
8d54 32 66 ee				ld (input_cur_flash), a 
8d57			 
8d57			.nochgstate: 
8d57					 
8d57					 
8d57			 
8d57					; display cursor  
8d57			 
8d57			;		ld hl, (input_start) 
8d57			;		ld a, (input_cursor) 
8d57			;		call addatohl 
8d57			 
8d57					; get char under cursor and replace with cursor 
8d57 2a 6f ee		ld hl, (input_ptr) 
8d5a			;		ld a, (hl) 
8d5a			;		ld (input_under_cursor),a 
8d5a			;		ld a, '_' 
8d5a			;		ld (hl), a 
8d5a			 
8d5a					; display string 
8d5a			 
8d5a ed 5b 6d ee			ld de, (input_start) 
8d5e 3a 6a ee				ld a, (input_at_pos) 
8d61 cd c2 8a				call str_at_display 
8d64			;	        call update_display 
8d64			 
8d64					; find place to put the cursor 
8d64			;		add h 
8d64			;		ld l, display_row_1 
8d64			;		sub l 
8d64			; (input_at_pos) 
8d64					;ld c, a 
8d64			;		ld a, (input_cursor) 
8d64			;		ld l, (input_at_pos) 
8d64			;		;ld b, h 
8d64			;		add l 
8d64			;		ld (input_at_cursor),a 
8d64					;ld l,h 
8d64			 
8d64			;		ld h, 0 
8d64			;		ld l,(input_at_pos) 
8d64			;		ld a, (input_cursor) 
8d64			;		call addatohl 
8d64			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d64			;		call subafromhl 
8d64			;		ld a,l 
8d64			;		ld (input_at_cursor), a 
8d64			 
8d64				if DEBUG_INPUT 
8d64					ld a, (hardware_diag) 
8d64					cp 0 
8d64					jr z, .skip_input_diag 
8d64			 
8d64					ld a,(input_at_pos) 
8d64					ld hl, LFSRSeed 
8d64					call hexout 
8d64					ld a, (input_cursor) 
8d64					ld hl, LFSRSeed+2 
8d64					call hexout 
8d64					ld a,(input_at_cursor) 
8d64					ld hl, LFSRSeed+4 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_onoff) 
8d64					ld hl, LFSRSeed+6 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_flash) 
8d64					ld hl, LFSRSeed+8 
8d64					call hexout 
8d64			 
8d64					ld a,(input_len) 
8d64					ld hl, LFSRSeed+10 
8d64					call hexout 
8d64					ld hl, LFSRSeed+12 
8d64					ld a, 0 
8d64					ld (hl),a 
8d64					ld a, display_row_4 
8d64					ld de, LFSRSeed 
8d64					call str_at_display 
8d64					.skip_input_diag: 
8d64				endif 
8d64			 
8d64					; decide on if we are showing the cursor this time round 
8d64			 
8d64 3a 65 ee				ld a, (input_cur_onoff) 
8d67 fe ff				cp 255 
8d69 28 13				jr z, .skipcur 
8d6b			 
8d6b			 
8d6b 3a 68 ee				ld a,(input_at_cursor) 
8d6e 11 c7 eb				ld de, cursor_shape 
8d71 cd c2 8a				call str_at_display 
8d74			 
8d74					; save length of current input string 
8d74 2a 6d ee				ld hl, (input_start) 
8d77 cd 3a 91				call strlenz 
8d7a 7d					ld a,l 
8d7b 32 60 ee				ld (input_len),a 
8d7e			 
8d7e			.skipcur: 
8d7e			 
8d7e cd d2 8a			        call update_display 
8d81					 
8d81			 
8d81			 
8d81					; wait 
8d81				 
8d81					; TODO loop without wait to flash the cursor and char under cursor	 
8d81 cd 6e e3				call cin    ; _wait 
8d84			 
8d84 fe 00				cp 0 
8d86 ca 3a 8d				jp z, .is1 
8d89			 
8d89					; get ptr to char to input into 
8d89			 
8d89 4f					ld c,a 
8d8a 2a 6d ee				ld hl, (input_start) 
8d8d 3a 5b ee				ld a, (input_cursor) 
8d90 cd dc 8c				call addatohl 
8d93 22 6f ee				ld (input_ptr), hl 
8d96 79					ld a,c 
8d97			 
8d97					; replace char under cursor 
8d97			 
8d97			;		ld hl, (input_ptr) 
8d97			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d97			;		ld (hl), a 
8d97			 
8d97			;	if DEBUG_INPUT 
8d97			;		push af 
8d97			;		ld a, 'i' 
8d97			;		ld (debug_mark),a 
8d97			;		pop af 
8d97			;		CALLMONITOR 
8d97			;	endif 
8d97 fe 0e				cp KEY_HOME 
8d99 20 0e				jr nz, .iske 
8d9b			 
8d9b 3a 6a ee				ld a, (input_at_pos) 
8d9e 32 68 ee				ld (input_at_cursor),a 
8da1 3e 00				ld a, 0 
8da3 32 5b ee				ld (input_cursor), a 
8da6 c3 3a 8d				jp .is1 
8da9					 
8da9 fe 0f		.iske:		cp KEY_END 
8dab 20 03				jr nz, .isknw 
8dad c3 3a 8d				jp .is1 
8db0			 
8db0 fe 06		.isknw:		cp KEY_NEXTWORD 
8db2 20 1b				jr nz, .iskpw 
8db4			 
8db4 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
8db7 7e					ld a,(hl)	 
8db8 fe 00				cp 0 
8dba ca 3a 8d				jp z, .is1    ; end of string 
8dbd fe 20				cp ' ' 
8dbf ca 3a 8d				jp z, .is1    ; end of word 
8dc2 23					inc hl 
8dc3 22 6f ee				ld (input_ptr), hl 
8dc6 3a 68 ee				ld a, (input_at_cursor) 
8dc9 3c					inc a 
8dca 32 68 ee				ld (input_at_cursor), a 
8dcd 18 e5				jr .isknwm 
8dcf			 
8dcf fe 07		.iskpw:		cp KEY_PREVWORD 
8dd1 20 1b				jr nz, .iskl 
8dd3			.iskpwm:	 
8dd3 2a 6f ee				ld hl, (input_ptr) 
8dd6 7e					ld a,(hl)	 
8dd7 fe 00				cp 0  
8dd9 ca 3a 8d				jp z, .is1    ; end of string 
8ddc fe 20				cp ' ' 
8dde ca 3a 8d				jp z, .is1    ; end of word 
8de1 2b					dec hl 
8de2 22 6f ee				ld (input_ptr), hl 
8de5 3a 68 ee				ld a, (input_at_cursor) 
8de8 3d					dec a 
8de9 32 68 ee				ld (input_at_cursor), a 
8dec 18 e5				jr .iskpwm 
8dee			 
8dee			 
8dee fe 0b		.iskl:		cp KEY_LEFT 
8df0 20 27				jr nz, .isk1 
8df2			 
8df2 3a 5b ee				ld a, (input_cursor) 
8df5			 
8df5 fe 00				cp 0 
8df7 ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8dfa			 
8dfa 3d					dec  a 		; TODO check underflow 
8dfb 32 5b ee				ld (input_cursor), a 
8dfe			 
8dfe 2a 6f ee				ld hl, (input_ptr) 
8e01 2b					dec hl 
8e02 22 6f ee				ld (input_ptr), hl 
8e05					 
8e05 3a 68 ee				ld a, (input_at_cursor) 
8e08 3d					dec a 
8e09 32 68 ee				ld (input_at_cursor), a 
8e0c			 
8e0c 3e 01				ld a, 1		; show cursor moving 
8e0e 32 65 ee				ld (input_cur_onoff),a 
8e11 3e 0f				ld a, CUR_BLINK_RATE 
8e13 32 66 ee				ld (input_cur_flash), a 
8e16			 
8e16 c3 3a 8d				jp .is1 
8e19			 
8e19 fe 0c		.isk1:		cp KEY_RIGHT 
8e1b 20 2a				jr nz, .isk2 
8e1d			 
8e1d 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8e20 5f					ld e,a 
8e21 3a 5b ee				ld a, (input_cursor) 
8e24 bb					cp e 
8e25 ca 3a 8d				jp z, .is1		; at the end of string so dont go right 
8e28			 
8e28 3c					inc  a 		; TODO check overflow 
8e29 32 5b ee				ld (input_cursor), a 
8e2c			 
8e2c 3a 68 ee				ld a, (input_at_cursor) 
8e2f 3c					inc a 
8e30 32 68 ee				ld (input_at_cursor), a 
8e33			 
8e33 2a 6f ee				ld hl, (input_ptr) 
8e36 23					inc hl 
8e37 22 6f ee				ld (input_ptr), hl 
8e3a			 
8e3a 3e 01				ld a, 1		; show cursor moving 
8e3c 32 65 ee				ld (input_cur_onoff),a 
8e3f 3e 0f				ld a, CUR_BLINK_RATE 
8e41 32 66 ee				ld (input_cur_flash), a 
8e44			 
8e44 c3 3a 8d				jp .is1 
8e47			 
8e47 fe 05		.isk2:		cp KEY_UP 
8e49			 
8e49 20 26				jr nz, .isk3 
8e4b			 
8e4b					; swap last command with the current on 
8e4b			 
8e4b					; move cursor to start of string 
8e4b 2a 6d ee				ld hl, (input_start) 
8e4e 22 6f ee				ld (input_ptr), hl 
8e51			 
8e51 3a 6a ee				ld a, (input_at_pos) 
8e54 32 68 ee				ld (input_at_cursor), a 
8e57			 
8e57 3e 00				ld a, 0 
8e59 32 5b ee				ld (input_cursor), a 
8e5c					 
8e5c					; swap input and last command buffers 
8e5c			 
8e5c 21 ee e5				ld hl, os_cli_cmd 
8e5f 11 ed e6				ld de, os_last_cmd 
8e62 06 ff				ld b, 255 
8e64 7e			.swap1:		ld a, (hl) 
8e65 4f					ld c,a 
8e66 1a					ld a, (de) 
8e67 77					ld (hl), a 
8e68 79					ld a,c 
8e69 12					ld (de),a 
8e6a 23					inc hl 
8e6b 13					inc de 
8e6c 10 f6				djnz .swap1 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e c3 3a 8d				jp .is1 
8e71			 
8e71 fe 08		.isk3:		cp KEY_BS 
8e73 20 3c				jr nz, .isk4 
8e75			 
8e75 3a 5b ee				ld a, (input_cursor) 
8e78			 
8e78 fe 00				cp 0 
8e7a ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8e7d			 
8e7d 3d					dec  a 		; TODO check underflow 
8e7e 32 5b ee				ld (input_cursor), a 
8e81			 
8e81					; hl is source 
8e81					; de needs to be source - 1 
8e81			 
8e81			;		ld a, 0 
8e81			;		dec hl 
8e81			;		ld (hl), a 
8e81			 
8e81 2a 6f ee				ld hl, (input_ptr) 
8e84 2b					dec hl 
8e85 22 6f ee				ld (input_ptr), hl 
8e88			 
8e88					; shift all data 
8e88			 
8e88 e5					push hl 
8e89 23					inc hl 
8e8a d1					pop de 
8e8b 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e8e 4f					ld c,a 
8e8f 06 00				ld b,0 
8e91 ed b0				ldir  
8e93			 
8e93			 
8e93			 
8e93			 
8e93 3a 68 ee				ld a, (input_at_cursor) 
8e96 3d					dec a 
8e97 32 68 ee				ld (input_at_cursor), a 
8e9a			 
8e9a			 
8e9a 3e 01				ld a, 1		; show cursor moving 
8e9c 32 65 ee				ld (input_cur_onoff),a 
8e9f 3e 0f				ld a, CUR_BLINK_RATE 
8ea1 32 66 ee				ld (input_cur_flash), a 
8ea4			 
8ea4					; remove char 
8ea4 3a 68 ee				ld a, (input_at_cursor) 
8ea7 3c					inc a 
8ea8 11 32 8f				ld de,.iblank 
8eab cd c2 8a				call str_at_display 
8eae			 
8eae c3 3a 8d				jp .is1 
8eb1			 
8eb1 fe 0d		.isk4:		cp KEY_CR 
8eb3 28 6c				jr z, .endinput 
8eb5			 
8eb5					; else add the key press to the end 
8eb5			 
8eb5 4f					ld c, a			; save key pressed 
8eb6			 
8eb6 7e					ld a,(hl)		; get what is currently under char 
8eb7			 
8eb7 fe 00				cp 0			; we are at the end of the string 
8eb9 20 2f				jr nz, .onchar 
8ebb					 
8ebb					; add a char to the end of the string 
8ebb				 
8ebb 71					ld (hl),c 
8ebc 23					inc hl 
8ebd			;		ld a,' ' 
8ebd			;		ld (hl),a 
8ebd			;		inc hl 
8ebd 3e 00				ld a,0 
8ebf 77					ld (hl),a 
8ec0 2b					dec hl 
8ec1			 
8ec1 3a 5b ee				ld a, (input_cursor) 
8ec4 3c					inc a				; TODO check max string length and scroll  
8ec5 32 5b ee				ld (input_cursor), a		; inc cursor pos 
8ec8							 
8ec8 3a 68 ee				ld a, (input_at_cursor) 
8ecb 3c					inc a 
8ecc 32 68 ee				ld (input_at_cursor), a 
8ecf			 
8ecf 2a 6f ee				ld hl, (input_ptr) 
8ed2 23					inc hl 
8ed3 22 6f ee				ld (input_ptr), hl 
8ed6			 
8ed6 2a 6f ee				ld hl, (input_ptr) 
8ed9 23					inc hl 
8eda 22 6f ee				ld (input_ptr), hl 
8edd			;	if DEBUG_INPUT 
8edd			;		push af 
8edd			;		ld a, '+' 
8edd			;		ld (debug_mark),a 
8edd			;		pop af 
8edd			;		CALLMONITOR 
8edd			;	endif 
8edd 3e 01				ld a, 1		; show cursor moving 
8edf 32 65 ee				ld (input_cur_onoff),a 
8ee2 3e 0f				ld a, CUR_BLINK_RATE 
8ee4 32 66 ee				ld (input_cur_flash), a 
8ee7 c3 3a 8d				jp .is1 
8eea					 
8eea			 
8eea			 
8eea					; if on a char then insert 
8eea			.onchar: 
8eea			 
8eea					; TODO over flow check: make sure insert does not blow out buffer 
8eea			 
8eea					; need to do some maths to use lddr 
8eea			 
8eea e5					push hl   ; save char pos 
8eeb c5					push bc 
8eec			 
8eec 2a 6d ee				ld hl, (input_start) 
8eef 3a 60 ee				ld a, (input_len) 
8ef2 cd dc 8c				call addatohl  		; end of string 
8ef5 23					inc hl 
8ef6 23					inc hl		; past zero term 
8ef7 e5					push hl 
8ef8 23					inc hl 
8ef9 e5					push hl  
8efa			 
8efa								; start and end of lddr set, now how much to move? 
8efa			 
8efa							 
8efa 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8efd 47					ld b,a 
8efe 3a 60 ee				ld a,(input_len) 
8f01 5f					ld e,a 
8f02 90					sub b 
8f03 3c					inc a		;?? 
8f04 3c					inc a		;?? 
8f05 3c					inc a		;?? 
8f06			 
8f06 06 00				ld b,0 
8f08 4f					ld c,a 
8f09			 
8f09				if DEBUG_INPUT 
8f09					push af 
8f09					ld a, 'i' 
8f09					ld (debug_mark),a 
8f09					pop af 
8f09			;		CALLMONITOR 
8f09				endif 
8f09 d1					pop de 
8f0a e1					pop hl 
8f0b				if DEBUG_INPUT 
8f0b					push af 
8f0b					ld a, 'I' 
8f0b					ld (debug_mark),a 
8f0b					pop af 
8f0b			;		CALLMONITOR 
8f0b				endif 
8f0b ed b8				lddr 
8f0d				 
8f0d			 
8f0d			 
8f0d					; TODO have a key for insert/overwrite mode???? 
8f0d c1					pop bc 
8f0e e1					pop hl 
8f0f 71					ld (hl), c		; otherwise overwrite current char 
8f10					 
8f10			 
8f10			 
8f10			 
8f10 3a 5b ee				ld a, (input_cursor) 
8f13 3c					inc  a 		; TODO check overflow 
8f14 32 5b ee				ld (input_cursor), a 
8f17			 
8f17 3a 68 ee				ld a, (input_at_cursor) 
8f1a 3c					inc a 
8f1b 32 68 ee				ld (input_at_cursor), a 
8f1e			 
8f1e c3 3a 8d				jp .is1 
8f21			 
8f21			.endinput:	; TODO look for end of string 
8f21			 
8f21					; add trailing space for end of token 
8f21			 
8f21 2a 6d ee				ld hl, (input_start) 
8f24 3a 60 ee				ld a,(input_len) 
8f27 cd dc 8c				call addatohl 
8f2a 3e 20				ld a, ' ' 
8f2c 77					ld (hl),a 
8f2d					; TODO eof of parse marker 
8f2d			 
8f2d 23					inc hl 
8f2e 3e 00				ld a, 0 
8f30 77					ld (hl),a 
8f31			 
8f31			 
8f31 c9					ret 
8f32			 
8f32 .. 00		.iblank: db " ",0 
8f34			 
8f34			 
8f34 32 6a ee		input_str_prev:	ld (input_at_pos), a 
8f37 22 6d ee				ld (input_start), hl 
8f3a 3e 01				ld a,1			; add cursor 
8f3c 77					ld (hl),a 
8f3d 23					inc hl 
8f3e 3e 00				ld a,0 
8f40 77					ld (hl),a 
8f41 22 6f ee				ld (input_ptr), hl 
8f44 7a					ld a,d 
8f45 32 6c ee				ld (input_size), a 
8f48 3e 00				ld a,0 
8f4a 32 5b ee				ld (input_cursor),a 
8f4d			.instr1:	 
8f4d			 
8f4d					; TODO do block cursor 
8f4d					; TODO switch cursor depending on the modifer key 
8f4d			 
8f4d					; update cursor shape change on key hold 
8f4d			 
8f4d 2a 6f ee				ld hl, (input_ptr) 
8f50 2b					dec hl 
8f51 3a c7 eb				ld a,(cursor_shape) 
8f54 77					ld (hl), a 
8f55			 
8f55					; display entered text 
8f55 3a 6a ee				ld a,(input_at_pos) 
8f58 cd cc e2		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f5b ed 5b 6d ee	            	LD   de, (input_start) 
8f5f cd c6 e2		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f62			 
8f62 cd 6e e3				call cin 
8f65 fe 00				cp 0 
8f67 28 e4				jr z, .instr1 
8f69			 
8f69					; proecess keyboard controls first 
8f69			 
8f69 2a 6f ee				ld hl,(input_ptr) 
8f6c			 
8f6c fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f6e 28 5a				jr z, .instrcr 
8f70			 
8f70 fe 08				cp KEY_BS 	; back space 
8f72 20 0f				jr nz, .instr2 
8f74					; process back space 
8f74			 
8f74					; TODO stop back space if at start of string 
8f74 2b					dec hl 
8f75 2b					dec hl ; to over write cursor 
8f76 3a c7 eb				ld a,(cursor_shape) 
8f79					;ld a,0 
8f79 77					ld (hl),a 
8f7a 23					inc hl 
8f7b 3e 20				ld a," " 
8f7d 77					ld (hl),a 
8f7e 22 6f ee				ld (input_ptr),hl 
8f81					 
8f81			 
8f81 18 ca				jr .instr1 
8f83			 
8f83 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f85 20 06				jr nz, .instr3 
8f87 2b					dec hl 
8f88 22 6f ee				ld (input_ptr),hl 
8f8b 18 c0				jr .instr1 
8f8d				 
8f8d fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f8f 20 06				jr nz, .instr4 
8f91 23					inc hl 
8f92 22 6f ee				ld (input_ptr),hl 
8f95 18 b6				jr .instr1 
8f97			 
8f97 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f99 20 06				jr nz, .instr5 
8f9b 2b					dec hl 
8f9c 22 6f ee				ld (input_ptr),hl 
8f9f 18 ac				jr .instr1 
8fa1			 
8fa1 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8fa3 20 06				jr nz, .instr6 
8fa5 2b					dec hl 
8fa6 22 6f ee				ld (input_ptr),hl 
8fa9 18 a2				jr .instr1 
8fab fe 05		.instr6:        cp KEY_UP      ; recall last command 
8fad 20 0b				jr nz, .instrnew 
8faf			 
8faf 21 c7 e2			ld hl, scratch 
8fb2 11 ed e6			ld de, os_last_cmd 
8fb5 cd d3 8f			call strcpy 
8fb8 18 93				jr .instr1 
8fba			 
8fba			 
8fba			.instrnew:	; no special key pressed to see if we have room to store it 
8fba			 
8fba					; TODO do string size test 
8fba			 
8fba 2b					dec hl ; to over write cursor 
8fbb 77					ld (hl),a 
8fbc 23					inc hl 
8fbd 3a c7 eb				ld a,(cursor_shape) 
8fc0 77					ld (hl),a 
8fc1 23					inc hl 
8fc2 3e 00				ld a,0 
8fc4 77					ld (hl),a 
8fc5			 
8fc5 22 6f ee				ld (input_ptr),hl 
8fc8					 
8fc8 18 83				jr .instr1 
8fca 2b			.instrcr:	dec hl		; remove cursor 
8fcb 3e 20				ld a,' '	; TODO add a trailing space for safety 
8fcd 77					ld (hl),a 
8fce 23					inc hl 
8fcf 3e 00				ld a,0 
8fd1 77					ld (hl),a 
8fd2			 
8fd2			 
8fd2					; if at end of line scroll up    
8fd2					; TODO detecting only end of line 4 for scroll up  
8fd2			 
8fd2					;ld   
8fd2			 
8fd2 c9					ret 
8fd3			 
8fd3			 
8fd3			; strcpy hl = dest, de source 
8fd3			 
8fd3 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8fd4 b7			            OR   A              ;Null terminator? 
8fd5 c8			            RET  Z              ;Yes, so finished 
8fd6 1a					ld a,(de) 
8fd7 77					ld (hl),a 
8fd8 13			            INC  DE             ;Point to next character 
8fd9 23					inc hl 
8fda 18 f7		            JR   strcpy       ;Repeat 
8fdc c9					ret 
8fdd			 
8fdd			 
8fdd			; TODO string_at  
8fdd			; pass string which starts with lcd offset address and then null term string 
8fdd			 
8fdd			; TODO string to dec 
8fdd			; TODO string to hex 
8fdd			; TODO byte to string hex 
8fdd			; TODO byte to string dec 
8fdd			 
8fdd			 
8fdd			 
8fdd			; from z80uartmonitor 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8fdd			; pass hl for where to put the text 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd c5			hexout:	PUSH BC 
8fde f5					PUSH AF 
8fdf 47					LD B, A 
8fe0					; Upper nybble 
8fe0 cb 3f				SRL A 
8fe2 cb 3f				SRL A 
8fe4 cb 3f				SRL A 
8fe6 cb 3f				SRL A 
8fe8 cd f8 8f				CALL tohex 
8feb 77					ld (hl),a 
8fec 23					inc hl	 
8fed					 
8fed					; Lower nybble 
8fed 78					LD A, B 
8fee e6 0f				AND 0FH 
8ff0 cd f8 8f				CALL tohex 
8ff3 77					ld (hl),a 
8ff4 23					inc hl	 
8ff5					 
8ff5 f1					POP AF 
8ff6 c1					POP BC 
8ff7 c9					RET 
8ff8					 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			tohex: 
8ff8 e5					PUSH HL 
8ff9 d5					PUSH DE 
8ffa 16 00				LD D, 0 
8ffc 5f					LD E, A 
8ffd 21 05 90				LD HL, .DATA 
9000 19					ADD HL, DE 
9001 7e					LD A, (HL) 
9002 d1					POP DE 
9003 e1					POP HL 
9004 c9					RET 
9005			 
9005			.DATA: 
9005 30					DEFB	30h	; 0 
9006 31					DEFB	31h	; 1 
9007 32					DEFB	32h	; 2 
9008 33					DEFB	33h	; 3 
9009 34					DEFB	34h	; 4 
900a 35					DEFB	35h	; 5 
900b 36					DEFB	36h	; 6 
900c 37					DEFB	37h	; 7 
900d 38					DEFB	38h	; 8 
900e 39					DEFB	39h	; 9 
900f 41					DEFB	41h	; A 
9010 42					DEFB	42h	; B 
9011 43					DEFB	43h	; C 
9012 44					DEFB	44h	; D 
9013 45					DEFB	45h	; E 
9014 46					DEFB	46h	; F 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
9015			;;    subtract $30, if result > 9 then subtract $7 more 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			atohex: 
9015 d6 30				SUB $30 
9017 fe 0a				CP 10 
9019 f8					RET M		; If result negative it was 0-9 so we're done 
901a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
901c c9					RET		 
901d			 
901d			 
901d			 
901d			 
901d			; Get 2 ASCII characters as hex byte from pointer in hl 
901d			 
901d			BYTERD: 
901d 16 00			LD	D,00h		;Set up 
901f cd 27 90			CALL	HEXCON		;Get byte and convert to hex 
9022 87				ADD	A,A		;First nibble so 
9023 87				ADD	A,A		;multiply by 16 
9024 87				ADD	A,A		; 
9025 87				ADD	A,A		; 
9026 57				LD	D,A		;Save hi nibble in D 
9027			HEXCON: 
9027 7e				ld a, (hl)		;Get next chr 
9028 23				inc hl 
9029 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
902b fe 0a			CP	00Ah		;Is it 0-9 ? 
902d 38 02			JR	C,NALPHA	;If so miss next bit 
902f d6 07			SUB	007h		;Else convert alpha 
9031			NALPHA: 
9031 b2				OR	D		;Add hi nibble back 
9032 c9				RET			; 
9033			 
9033			 
9033			; 
9033			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
9033			; Since the routines get_byte and therefore get_nibble are called, only valid 
9033			; characters (0-9a-f) are accepted. 
9033			; 
9033			;get_word        push    af 
9033			;                call    get_byte        ; Get the upper byte 
9033			;                ld      h, a 
9033			;                call    get_byte        ; Get the lower byte 
9033			;                ld      l, a 
9033			;                pop     af 
9033			;                ret 
9033			; 
9033			; Get a byte in hexadecimal notation. The result is returned in A. Since 
9033			; the routine get_nibble is used only valid characters are accepted - the  
9033			; input routine only accepts characters 0-9a-f. 
9033			; 
9033 c5			get_byte:        push    bc              ; Save contents of B (and C) 
9034 7e					ld a,(hl) 
9035 23					inc hl 
9036 cd 5b 90		                call    nibble2val      ; Get upper nibble 
9039 cb 07		                rlc     a 
903b cb 07		                rlc     a 
903d cb 07		                rlc     a 
903f cb 07		                rlc     a 
9041 47			                ld      b, a            ; Save upper four bits 
9042 7e					ld a,(hl) 
9043 cd 5b 90		                call    nibble2val      ; Get lower nibble 
9046 b0			                or      b               ; Combine both nibbles 
9047 c1			                pop     bc              ; Restore B (and C) 
9048 c9			                ret 
9049			; 
9049			; Get a hexadecimal digit from the serial line. This routine blocks until 
9049			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
9049			; to the serial line interface. The lower 4 bits of A contain the value of  
9049			; that particular digit. 
9049			; 
9049			;get_nibble      ld a,(hl)           ; Read a character 
9049			;                call    to_upper        ; Convert to upper case 
9049			;                call    is_hex          ; Was it a hex digit? 
9049			;                jr      nc, get_nibble  ; No, get another character 
9049			 ;               call    nibble2val      ; Convert nibble to value 
9049			 ;               call    print_nibble 
9049			 ;               ret 
9049			; 
9049			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
9049			; A valid hexadecimal digit is denoted by a set C flag. 
9049			; 
9049			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
9049			;                ret     nc              ; Yes 
9049			;                cp      '0'             ; Less than '0'? 
9049			;                jr      nc, is_hex_1    ; No, continue 
9049			;                ccf                     ; Complement carry (i.e. clear it) 
9049			;                ret 
9049			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
9049			;                ret     c               ; Yes 
9049			;                cp      'A'             ; Less than 'A'? 
9049			;                jr      nc, is_hex_2    ; No, continue 
9049			;                ccf                     ; Yes - clear carry and return 
9049			;                ret 
9049			;is_hex_2        scf                     ; Set carry 
9049			;                ret 
9049			; 
9049			; Convert a single character contained in A to upper case: 
9049			; 
9049 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
904b d8			                ret     c 
904c fe 7b		                cp      'z' + 1         ; > 'z'? 
904e d0			                ret     nc              ; Nothing to do, either 
904f e6 5f		                and     $5f             ; Convert to upper case 
9051 c9			                ret 
9052			 
9052			 
9052			to_lower: 
9052			 
9052			   ; if char is in [A-Z] make it lower case 
9052			 
9052			   ; enter : a = char 
9052			   ; exit  : a = lower case char 
9052			   ; uses  : af 
9052			 
9052 fe 41		   cp 'A' 
9054 d8			   ret c 
9055			    
9055 fe 5b		   cp 'Z'+1 
9057 d0			   ret nc 
9058			    
9058 f6 20		   or $20 
905a c9			   ret 
905b			 
905b			; 
905b			; Expects a hexadecimal digit (upper case!) in A and returns the 
905b			; corresponding value in A. 
905b			; 
905b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
905d 38 02		                jr      c, nibble2val_1 ; Yes 
905f d6 07		                sub     7               ; Adjust for A-F 
9061 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9063 e6 0f		                and     $f              ; Only return lower 4 bits 
9065 c9			                ret 
9066			; 
9066			; Print_nibble prints a single hex nibble which is contained in the lower  
9066			; four bits of A: 
9066			; 
9066			;print_nibble    push    af              ; We won't destroy the contents of A 
9066			;                and     $f              ; Just in case... 
9066			;                add     a, '0'             ; If we have a digit we are done here. 
9066			;                cp      '9' + 1         ; Is the result > 9? 
9066			;                jr      c, print_nibble_1 
9066			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
9066			;print_nibble_1  call    putc            ; Print the nibble and 
9066			;                pop     af              ; restore the original value of A 
9066			;                ret 
9066			;; 
9066			;; Send a CR/LF pair: 
9066			; 
9066			;crlf            push    af 
9066			;                ld      a, cr 
9066			;                call    putc 
9066			;                ld      a, lf 
9066			;                call    putc 
9066			;                pop     af 
9066			;                ret 
9066			; 
9066			; Print_word prints the four hex digits of a word to the serial line. The  
9066			; word is expected to be in HL. 
9066			; 
9066			;print_word      push    hl 
9066			;                push    af 
9066			;                ld      a, h 
9066			;                call    print_byte 
9066			;                ld      a, l 
9066			;                call    print_byte 
9066			;                pop     af 
9066			;                pop     hl 
9066			;                ret 
9066			; 
9066			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
9066			; The byte to be printed is expected to be in A. 
9066			; 
9066			;print_byte      push    af              ; Save the contents of the registers 
9066			;                push    bc 
9066			;                ld      b, a 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                call    print_nibble    ; Print high nibble 
9066			;                ld      a, b 
9066			;                call    print_nibble    ; Print low nibble 
9066			;                pop     bc              ; Restore original register contents 
9066			;                pop     af 
9066			;                ret 
9066			 
9066			 
9066			 
9066			 
9066			 
9066			fourehexhl:  
9066 7e				ld a,(hl) 
9067 cd 15 90			call atohex 
906a cb 3f				SRL A 
906c cb 3f				SRL A 
906e cb 3f				SRL A 
9070 cb 3f				SRL A 
9072 47				ld b, a 
9073 23				inc hl 
9074 7e				ld a,(hl) 
9075 23				inc hl 
9076 cd 15 90			call atohex 
9079 80				add b 
907a 57				ld d,a 
907b 7e				ld a,(hl) 
907c cd 15 90			call atohex 
907f cb 3f				SRL A 
9081 cb 3f				SRL A 
9083 cb 3f				SRL A 
9085 cb 3f				SRL A 
9087 47				ld b, a 
9088 23				inc hl 
9089 7e				ld a,(hl) 
908a 23				inc hl 
908b cd 15 90			call atohex 
908e 80				add b 
908f 5f				ld e, a 
9090 d5				push de 
9091 e1				pop hl 
9092 c9				ret 
9093			 
9093			; pass hl. returns z set if the byte at hl is a digit 
9093			;isdigithl:  
9093			;	push bc 
9093			;	ld a,(hl) 
9093			;	cp ':' 
9093			;	jr nc, .isdf 		; > 
9093			;	cp '0' 
9093			;	jr c, .isdf		; < 
9093			; 
9093			;	; TODO find a better way to set z 
9093			; 
9093			;	ld b,a 
9093			;	cp b 
9093			;	pop bc 
9093			;	ret 
9093			; 
9093			;.isdf:	; not digit so clear z 
9093			; 
9093			;	; TODO find a better way to unset z 
9093			; 
9093			;	ld b,a 
9093			;	inc b 
9093			;	cp b 
9093			; 
9093			;	pop bc 
9093			;	ret 
9093				 
9093				 
9093			 
9093			 
9093			; pass hl as the four byte address to load 
9093			 
9093			get_word_hl:  
9093 e5				push hl 
9094 cd 33 90			call get_byte 
9097				 
9097 47				ld b, a 
9098			 
9098 e1				pop hl 
9099 23				inc hl 
909a 23				inc hl 
909b			 
909b			; TODO not able to handle a-f  
909b 7e				ld a,(hl) 
909c			;	;cp ':' 
909c			;	cp 'g' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp 'G' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp '0' 
909c			;	jr c, .single_byte_hl		; < 
909c			 
909c				;call isdigithl 
909c fe 00			cp 0 
909e 28 06			jr z, .single_byte_hl 
90a0			 
90a0			.getwhln:   ; hex word so get next byte 
90a0			 
90a0 cd 33 90			call get_byte 
90a3 6f				ld l, a 
90a4 60				ld h,b 
90a5 c9				ret 
90a6 68			.single_byte_hl:   ld l,b 
90a7 26 00				ld h,0 
90a9 c9					ret 
90aa			 
90aa			 
90aa			 
90aa			 
90aa 21 6a 98			ld hl,asc+1 
90ad			;	ld a, (hl) 
90ad			;	call nibble2val 
90ad cd 33 90			call get_byte 
90b0			 
90b0			;	call fourehexhl 
90b0 32 fb e2			ld (scratch+52),a 
90b3				 
90b3 21 f9 e2			ld hl,scratch+50 
90b6 22 ea e5			ld (os_cur_ptr),hl 
90b9			 
90b9 c9				ret 
90ba			 
90ba			 
90ba			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
90ba			 
90ba			; Decimal Unsigned Version 
90ba			 
90ba			;Number in a to decimal ASCII 
90ba			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
90ba			;Example: display a=56 as "056" 
90ba			;input: a = number 
90ba			;Output: a=0,value of a in the screen 
90ba			;destroys af,bc (don't know about hl and de) 
90ba			DispAToASCII: 
90ba 0e 9c			ld	c,-100 
90bc cd c6 90			call	.Na1 
90bf 0e f6			ld	c,-10 
90c1 cd c6 90			call	.Na1 
90c4 0e ff			ld	c,-1 
90c6 06 2f		.Na1:	ld	b,'0'-1 
90c8 04			.Na2:	inc	b 
90c9 81				add	a,c 
90ca 38 fc			jr	c,.Na2 
90cc 91				sub	c		;works as add 100/10/1 
90cd f5				push af		;safer than ld c,a 
90ce 78				ld	a,b		;char is in b 
90cf			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
90cf f1				pop af		;safer than ld a,c 
90d0 c9				ret 
90d1			 
90d1			; Decimal Signed Version 
90d1			 
90d1			; DispA 
90d1			; -------------------------------------------------------------- 
90d1			; Converts a signed integer value to a zero-terminated ASCII 
90d1			; string representative of that value (using radix 10). 
90d1			; -------------------------------------------------------------- 
90d1			; INPUTS: 
90d1			;     HL     Value to convert (two's complement integer). 
90d1			;     DE     Base address of string destination. (pointer). 
90d1			; -------------------------------------------------------------- 
90d1			; OUTPUTS: 
90d1			;     None 
90d1			; -------------------------------------------------------------- 
90d1			; REGISTERS/MEMORY DESTROYED 
90d1			; AF HL 
90d1			; -------------------------------------------------------------- 
90d1			 
90d1			;DispHLToASCII: 
90d1			;   push    de 
90d1			;   push    bc 
90d1			; 
90d1			;; Detect sign of HL. 
90d1			;    bit    7, h 
90d1			;    jr     z, ._DoConvert 
90d1			; 
90d1			;; HL is negative. Output '-' to string and negate HL. 
90d1			;    ld     a, '-' 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			; 
90d1			;; Negate HL (using two's complement) 
90d1			;    xor    a 
90d1			;    sub    l 
90d1			;    ld     l, a 
90d1			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
90d1			;    sbc    a, h 
90d1			;    ld     h, a 
90d1			; 
90d1			;; Convert HL to digit characters 
90d1			;._DoConvert: 
90d1			;    ld     b, 0     ; B will count character length of number 
90d1			;-   ld     a, 10 
90d1			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
90d1			;    push   af 
90d1			;    inc    b 
90d1			;    ld     a, h 
90d1			;    or     l 
90d1			;    jr     nz, - 
90d1			; 
90d1			;; Retrieve digits from stack 
90d1			;-   pop    af 
90d1			;    or     $30 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			;    djnz   - 
90d1			; 
90d1			;; Terminate string with NULL 
90d1			;    xor    a 
90d1			;    ld     (de), a 
90d1			; 
90d1			;    pop    bc 
90d1			;    pop    de 
90d1			;    ret 
90d1			 
90d1			;Comments 
90d1			; 
90d1			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
90d1			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
90d1			;    Note that the output string will not be fixed-width. 
90d1			; 
90d1			;Example Usage 
90d1			; 
90d1			;    ld    hl, -1004 
90d1			;    ld    de, OP1 
90d1			;    call  DispA 
90d1			;    ld    hl, OP1 
90d1			;    syscall  PutS 
90d1			 
90d1			 
90d1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90d1			 
90d1			 
90d1			;Converts an ASCII string to an unsigned 16-bit integer 
90d1			;Quits when it reaches a non-decimal digit 
90d1			 
90d1			string_to_uint16: 
90d1			atoui_16: 
90d1			;Input: 
90d1			;     DE points to the string 
90d1			;Outputs: 
90d1			;     HL is the result 
90d1			;     A is the 8-bit value of the number 
90d1			;     DE points to the byte after the number 
90d1			;Destroys: 
90d1			;     BC 
90d1			;       if the string is non-empty, BC is HL/10 
90d1			;Size:  24 bytes 
90d1			;Speed: 42+d(104+{0,9}) 
90d1			;       d is the number of digits in the number 
90d1			;       max is 640 cycles for a 5 digit number 
90d1			;Assuming no leading zeros: 
90d1			;1 digit:  146cc 
90d1			;2 digit:  250cc 
90d1			;3 digit:  354cc or 363cc (avg: 354.126cc) 
90d1			;4 digit:  458cc or 467cc (avg: 458.27cc) 
90d1			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
90d1			;avg: 544.81158447265625cc (544+13297/16384) 
90d1			;=============================================================== 
90d1 21 00 00		  ld hl,0 
90d4			.u16a: 
90d4 1a			  ld a,(de) 
90d5 d6 30		  sub 30h 
90d7 fe 0a		  cp 10 
90d9 d0			  ret nc 
90da 13			  inc de 
90db 44			  ld b,h 
90dc 4d			  ld c,l 
90dd 29			  add hl,hl 
90de 29			  add hl,hl 
90df 09			  add hl,bc 
90e0 29			  add hl,hl 
90e1 85			  add a,l 
90e2 6f			  ld l,a 
90e3 30 ef		  jr nc,.u16a 
90e5 24			  inc h 
90e6 c3 d4 90		  jp .u16a 
90e9			 
90e9			 
90e9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90e9			 
90e9			;written by Zeda 
90e9			;Converts a 16-bit unsigned integer to an ASCII string. 
90e9			 
90e9			uitoa_16: 
90e9			;Input: 
90e9			;   DE is the number to convert 
90e9			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90e9			;Output: 
90e9			;   HL points to the null-terminated ASCII string 
90e9			;      NOTE: This isn't necessarily the same as the input HL. 
90e9 d5			  push de 
90ea c5			  push bc 
90eb f5			  push af 
90ec eb			  ex de,hl 
90ed			 
90ed 01 f0 d8		  ld bc,-10000 
90f0 3e 2f		  ld a,'0'-1 
90f2 3c			  inc a 
90f3 09			  add hl,bc  
90f4 38 fc		   jr c,$-2 
90f6 12			  ld (de),a 
90f7 13			  inc de 
90f8			 
90f8 01 e8 03		  ld bc,1000 
90fb 3e 3a		  ld a,'9'+1 
90fd 3d			  dec a  
90fe 09			  add hl,bc  
90ff 30 fc		   jr nc,$-2 
9101 12			  ld (de),a 
9102 13			  inc de 
9103			 
9103 01 9c ff		  ld bc,-100 
9106 3e 2f		  ld a,'0'-1 
9108 3c			  inc a  
9109 09			  add hl,bc  
910a 38 fc		   jr c,$-2 
910c 12			  ld (de),a 
910d 13			  inc de 
910e			 
910e 7d			  ld a,l 
910f 26 3a		  ld h,'9'+1 
9111 25			  dec h  
9112 c6 0a		  add a,10  
9114 30 fb		   jr nc,$-3 
9116 c6 30		  add a,'0' 
9118 eb			  ex de,hl 
9119 72			  ld (hl),d 
911a 23			  inc hl 
911b 77			  ld (hl),a 
911c 23			  inc hl 
911d 36 00		  ld (hl),0 
911f			 
911f			;Now strip the leading zeros 
911f 0e fa		  ld c,-6 
9121 09			  add hl,bc 
9122 3e 30		  ld a,'0' 
9124 23			  inc hl  
9125 be			  cp (hl)  
9126 28 fc		  jr z,$-2 
9128			 
9128			;Make sure that the string is non-empty! 
9128 7e			  ld a,(hl) 
9129 b7			  or a 
912a 20 01		  jr nz,.atoub 
912c 2b			  dec hl 
912d			.atoub: 
912d			 
912d f1			  pop af 
912e c1			  pop bc 
912f d1			  pop de 
9130 c9			  ret 
9131			 
9131			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9131			 
9131			toUpper: 
9131			;A is the char. 
9131			;If A is a lowercase letter, this sets it to the matching uppercase 
9131			;18cc or 30cc or 41cc 
9131			;avg: 26.75cc 
9131 fe 61		  cp 'a' 
9133 d8			  ret c 
9134 fe 7b		  cp 'z'+1 
9136 d0			  ret nc 
9137 d6 20		  sub 'a'-'A' 
9139 c9			  ret 
913a			 
913a			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
913a			 
913a			; String Length 
913a			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
913a			 
913a			; Get the length of the null-terminated string starting at $8000 hl 
913a			;    LD     HL, $8000 
913a			 
913a			strlenz: 
913a			 
913a af			    XOR    A               ; Zero is the value we are looking for. 
913b 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
913c 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
913d			                           ; 65, 536 bytes (the entire addressable memory space). 
913d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
913f			 
913f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
913f 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9140 6f			    LD     L, A             ; number of bytes 
9141 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9143 2b			    DEC    HL              ; Compensate for null. 
9144 c9				ret 
9145			 
9145			; Get the length of the A terminated string starting at $8000 hl 
9145			;    LD     HL, $8000 
9145			 
9145			strlent: 
9145			 
9145			                  ; A is the value we are looking for. 
9145 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
9147 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9149			                           ; 65, 536 bytes (the entire addressable memory space). 
9149 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
914b			 
914b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
914b 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
914d 2e 00		    LD     L, 0             ; number of bytes 
914f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9151 2b			    DEC    HL              ; Compensate for null. 
9152 c9				ret 
9153			 
9153			 
9153			;Comparing Strings 
9153			 
9153			;IN    HL     Address of string1. 
9153			;      DE     Address of string2. 
9153			 
9153			; doc given but wrong??? 
9153			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9153			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9153			; tested 
9153			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9153			 
9153			strcmp_old: 
9153 e5			    PUSH   HL 
9154 d5			    PUSH   DE 
9155			 
9155 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
9156 be			    CP     (HL)            ; (want to minimize work). 
9157 38 01		    JR     C, Str1IsBigger 
9159 7e			    LD     A, (HL) 
915a			 
915a			Str1IsBigger: 
915a 4f			    LD     C, A             ; Put length in BC 
915b 06 00		    LD     B, 0 
915d 13			    INC    DE              ; Increment pointers to meat of string. 
915e 23			    INC    HL 
915f			 
915f			CmpLoop: 
915f 1a			    LD     A, (DE)          ; Compare bytes. 
9160 ed a1		    CPI 
9162 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9164 13			    INC    DE              ; Update pointer. 
9165 ea 5f 91		    JP     PE, CmpLoop 
9168			 
9168 d1			    POP    DE 
9169 e1			    POP    HL 
916a 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
916b be			    CP     (HL) 
916c c9			    RET 
916d			 
916d			NoMatch: 
916d 2b			    DEC    HL 
916e be			    CP     (HL)            ; Compare again to affect carry. 
916f d1			    POP    DE 
9170 e1			    POP    HL 
9171 c9			    RET 
9172			 
9172			;; test strmp 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr z, .z1 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z1: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr z, .z2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr c, .c1 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c1: 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr c, .c2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;	NEXTW 
9172			;.str1:   db "string1",0 
9172			;.str2:   db "string2",0 
9172			 
9172			; only care about direct match or not 
9172			; hl and de strings 
9172			; zero set if the same 
9172			 
9172			strcmp: 
9172 1a				ld a, (de) 
9173 be				cp (hl) 
9174 28 02			jr z, .ssame 
9176 b7				or a 
9177 c9				ret 
9178			 
9178			.ssame:  
9178 fe 00			cp 0 
917a c8				ret z 
917b			 
917b 23				inc hl 
917c 13				inc de 
917d 18 f3			jr strcmp 
917f				 
917f				 
917f			 
917f			 
917f			 
917f			 
917f			; eof 
917f			 
917f			 
917f			 
917f			 
917f			 
917f			 
# End of file firmware_strings.asm
917f			include "firmware_memory.asm"   ; malloc and free  
917f			 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			.mallocsize: db "Wants malloc >256",0 
917f			.mallocasize: db "MALLOC gives >256",0 
917f			.malloczero: db "MALLOC gives zero",0 
917f			 
917f			malloc_guard_zerolen: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f				ld de, 0 
917f			        call cmp16 
917f				jr nz, .lowalloz 
917f			 
917f				push hl 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .malloczero 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f				ld a, 0 
917f				ld (os_view_disable), a 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f			.lowalloz: 
917f			 
917f			 
917f				pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_entry: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowalloc 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocsize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f				ld a, 0 
917f				ld (os_view_disable), a 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f				jr .lowdone 
917f			.lowalloc: 
917f			 
917f			 
917f				pop hl 
917f			.lowdone:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_exit: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowallocx 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocasize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f				ld a, 0 
917f				ld (os_view_disable), a 
917f				pop de 
917f				pop hl 
917f			 
917f				CALLMONITOR 
917f				jr .lowdonex 
917f			.lowallocx: 
917f			 
917f				pop hl 
917f			.lowdonex:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			endif 
917f			 
917f			if MALLOC_2 
917f			; Z80 Malloc and Free Functions 
917f			 
917f			; Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc: 
917f				 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_entry 
917f			endif 
917f			 
917f			 
917f			 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "mal" 
917f						CALLMONITOR 
917f					endif 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of size into A 
917f			    or h               ; Check if size is zero 
917f			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
917f			 
917f			    ; Allocate memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma1" 
917f						CALLMONITOR 
917f					endif 
917f			    call malloc_internal ; Call internal malloc function 
917f			    pop af             ; Restore AF register 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret                ; Return 
917f			 
917f			; Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free: 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of pointer into A 
917f			    or h               ; Check if pointer is NULL 
917f			    jp z, free_exit    ; If pointer is NULL, exit 
917f			 
917f			    ; Free memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f			    call free_internal  ; Call internal free function 
917f			    pop af             ; Restore AF register 
917f			    ret                ; Return 
917f			 
917f			; Internal Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc_internal: 
917f			    ld bc, 2           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to requested size 
917f			    ex de, hl          ; Save total size in DE, and keep it in HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			 
917f			    ; Search for free memory block 
917f			    ld de, (heap_end)  ; Load end of heap into DE 
917f			    ld bc, 0           ; Initialize counter 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			malloc_search_loop: 
917f			    ; Check if current block is free 
917f			    ld a, (hl)         ; Load current block's status (free or used) 
917f			    cp 0               ; Compare with zero (free) 
917f			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
917f			 
917f			    ; Check if current block is large enough 
917f			    ld a, (hl+1)       ; Load high byte of block size 
917f			    cp l               ; Compare with low byte of requested size 
917f			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
917f			 
917f			    ld a, (hl+2)       ; Load low byte of block size 
917f			    cp h               ; Compare with high byte of requested size 
917f			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
917f			 
917f			    ; Mark block as used 
917f			    ld (hl), 0xFF      ; Set status byte to indicate used block 
917f			 
917f			    ; Calculate remaining space in block 
917f			    ld bc, 0           ; Clear BC 
917f			    add hl, bc         ; Increment HL to point to start of data block 
917f			    add hl, de         ; HL = HL + DE (total size) 
917f			    ld bc, 1           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to start of data block 
917f			 
917f			    ; Save pointer to allocated block in HL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma5" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			malloc_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3           ; Size of management overhead 
917f			    add hl, bc         ; Move to the next block 
917f			    inc de             ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e            ; Load low byte of heap end address 
917f			    cp (hl)            ; Compare with low byte of current address 
917f			    jr nz, malloc_search_loop  ; If not equal, continue searching 
917f			    ld a, d            ; Load high byte of heap end address 
917f			    cp 0               ; Check if it's zero (end of memory) 
917f			    jr nz, malloc_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, allocation failed 
917f			    xor a              ; Set result to NULL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma6" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			malloc_exit: 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma7" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			; Internal Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free_internal: 
917f			    ld de, (heap_start) ; Load start of heap into DE 
917f			    ld bc, 0            ; Initialize counter 
917f			 
917f			free_search_loop: 
917f			    ; Check if current block contains the pointer 
917f			    ld a, l             ; Load low byte of pointer 
917f			    cp (hl+1)           ; Compare with high byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			    ld a, h             ; Load high byte of pointer 
917f			    cp (hl+2)           ; Compare with low byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			 
917f			    ; Mark block as free 
917f			    ld (hl), 0          ; Set status byte to indicate free block 
917f			    ret                 ; Return 
917f			 
917f			free_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3            ; Size of management overhead 
917f			    add hl, bc          ; Move to the next block 
917f			    inc de              ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e             ; Load low byte of heap end address 
917f			    cp (hl)             ; Compare with low byte of current address 
917f			    jr nz, free_search_loop  ; If not equal, continue searching 
917f			    ld a, d             ; Load high byte of heap end address 
917f			    cp 0                ; Check if it's zero (end of memory) 
917f			    jr nz, free_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, pointer is not found in heap 
917f			    ret 
917f			 
917f			free_exit: 
917f			    ret                 ; Return 
917f			 
917f			; Define heap start and end addresses 
917f			;heap_start:    .dw 0xC000   ; Start of heap 
917f			;heap_end:      .dw 0xE000   ; End of heap 
917f			 
917f			endif 
917f			 
917f			 
917f			if MALLOC_1 
917f			 
917f			 
917f			 
917f			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
917f			 
917f			;moved to firmware.asm 
917f			;heap_start        .equ  0x9000      ; Starting address of heap 
917f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
917f			 
917f			;      .org 0 
917f			;      jp    main 
917f			 
917f			 
917f			;      .org  0x100 
917f			;main: 
917f			;      ld    HL, 0x8100 
917f			;      ld    SP, HL 
917f			; 
917f			;      call  heap_init 
917f			; 
917f			;      ; Make some allocations 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9004 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9014 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9024 
917f			; 
917f			;      ; Free some allocations 
917f			;      ld    HL, 0x9014 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9004 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9024 
917f			;      call  free 
917f			; 
917f			; 
917f			;      halt 
917f			 
917f			 
917f			;------------------------------------------------------------------------------ 
917f			;     heap_init                                                               : 
917f			;                                                                             : 
917f			; Description                                                                 : 
917f			;     Initialise the heap and make it ready for malloc and free operations.   : 
917f			;                                                                             : 
917f			;     The heap is maintained as a linked list, starting with an initial       : 
917f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
917f			;     the first free block in the heap. Each block then points to the next    : 
917f			;     free block within the heap, and the free list ends at the first block   : 
917f			;     with a null pointer to the next free block.                             : 
917f			;                                                                             : 
917f			; Parameters                                                                  : 
917f			;     Inputs are compile-time only. Two defines which specify the starting    : 
917f			;     address of the heap and its size are required, along with a memory      : 
917f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
917f			;     principally stores a pointer to the first free block in the heap.       : 
917f			;                                                                             : 
917f			; Returns                                                                     : 
917f			;     Nothing                                                                 : 
917f			;------------------------------------------------------------------------------ 
917f			heap_init: 
917f e5			      push  HL 
9180			 
9180			      ; Initialise free list struct 
9180 21 8c e3		      ld    HL, heap_start 
9183 22 87 e3		      ld    (free_list), HL 
9186 21 00 00		      ld    HL, 0 
9189 22 89 e3		      ld    (free_list+2), HL 
918c			 
918c			      ; Insert first free block at bottom of heap, consumes entire heap 
918c 21 a9 e2		      ld    HL, heap_start+heap_size-4 
918f 22 8c e3		      ld    (heap_start), HL        ; Next block (end of free list) 
9192 21 1d ff		      ld    HL, heap_size-4 
9195 22 8e e3		      ld    (heap_start+2), HL      ; Block size 
9198			 
9198			      ; Insert end of free list block at top of heap - two null words will 
9198			      ; terminate the free list 
9198 21 00 00		      ld    HL, 0 
919b 22 ab e2		      ld    (heap_start+heap_size-2), HL 
919e 22 a9 e2		      ld    (heap_start+heap_size-4), HL 
91a1			 
91a1 e1			      pop   HL 
91a2			 
91a2 c9			      ret 
91a3			 
91a3			 
91a3			;------------------------------------------------------------------------------ 
91a3			;     malloc                                                                  : 
91a3			;                                                                             : 
91a3			; Description                                                                 : 
91a3			;     Allocates the wanted space from the heap and returns the address of the : 
91a3			;     first useable byte of the allocation.                                   : 
91a3			;                                                                             : 
91a3			;     Allocations can happen in one of two ways:                              : 
91a3			;                                                                             : 
91a3			;     1. A free block may be found which is the exact size wanted. In this    : 
91a3			;        case the block is removed from the free list and retuedn to the      : 
91a3			;        caller.                                                              : 
91a3			;     2. A free block may be found which is larger than the size wanted. In   : 
91a3			;        this case, the larger block is split into two. The first portion of  : 
91a3			;        this block will become the requested space by the malloc call and    : 
91a3			;        is returned to the caller. The second portion becomes a new free     : 
91a3			;        block, and the free list is adjusted to maintain continuity via this : 
91a3			;        newly created block.                                                 : 
91a3			;                                                                             : 
91a3			;     malloc does not set any initial value in the allocated space, the       : 
91a3			;     caller is required to do this as required.                              : 
91a3			;                                                                             : 
91a3			;     This implementation of malloc uses the stack exclusively, and is        : 
91a3			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91a3			;     advisable to disable interrupts before calling malloc, and recommended  : 
91a3			;     to avoid the use of malloc inside ISRs in general.                      : 
91a3			;                                                                             : 
91a3			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91a3			;                                                                             : 
91a3			; Parameters                                                                  : 
91a3			;     HL  Number of bytes wanted                                              : 
91a3			;                                                                             : 
91a3			; Returns                                                                     : 
91a3			;     HL  Address of the first useable byte of the allocation                 : 
91a3			;                                                                             : 
91a3			; Flags                                                                       : 
91a3			;     Z   Set if the allocation did not succeed, clear otherwise              : 
91a3			;                                                                             : 
91a3			; Stack frame                                                                 : 
91a3			;       |             |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     BC      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     DE      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     IX      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |  prev_free  |                                                       : 
91a3			;   +4  +-------------+                                                       : 
91a3			;       |  this_free  |                                                       : 
91a3			;   +2  +-------------+                                                       : 
91a3			;       |  next_free  |                                                       : 
91a3			;   +0  +-------------+                                                       : 
91a3			;       |             |                                                       : 
91a3			;                                                                             : 
91a3			;------------------------------------------------------------------------------ 
91a3			 
91a3			 
91a3			;malloc: 
91a3			; 
91a3			;	SAVESP ON 1 
91a3			; 
91a3			;	call malloc_code 
91a3			; 
91a3			;	CHECKSP ON 1 
91a3			;	ret 
91a3			 
91a3			 
91a3			malloc: 
91a3 c5			      push  BC 
91a4 d5			      push  DE 
91a5 dd e5		      push  IX 
91a7			if DEBUG_FORTH_MALLOC_HIGH 
91a7			call malloc_guard_entry 
91a7			endif 
91a7			 
91a7					if DEBUG_FORTH_MALLOC 
91a7						DMARK "mal" 
91a7						CALLMONITOR 
91a7					endif 
91a7 7c			      ld    A, H                    ; Exit if no space requested 
91a8 b5			      or    L 
91a9 ca 68 92		      jp    Z, malloc_early_exit 
91ac			 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			; 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			 
91ac			 
91ac			 
91ac			 
91ac					if DEBUG_FORTH_MALLOC 
91ac						DMARK "maA" 
91ac						CALLMONITOR 
91ac					endif 
91ac			      ; Set up stack frame 
91ac eb			      ex    DE, HL 
91ad 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
91b0 39			      add   HL, SP 
91b1 f9			      ld    SP, HL 
91b2 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91b6 dd 39		      add   IX, SP 
91b8			 
91b8			      ; Setup initial state 
91b8 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
91bb 19			      add   HL, DE 
91bc			 
91bc 44			      ld    B, H                    ; Move want to BC 
91bd 4d			      ld    C, L 
91be			 
91be 21 87 e3		      ld    HL, free_list           ; Store prev_free ptr to stack 
91c1 dd 75 04		      ld    (IX+4), L 
91c4 dd 74 05		      ld    (IX+5), H 
91c7			 
91c7 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
91c8 23			      inc   HL 
91c9 56			      ld    D, (HL) 
91ca dd 73 02		      ld    (IX+2), E 
91cd dd 72 03		      ld    (IX+3), D 
91d0 eb			      ex    DE, HL                  ; this_free ptr into HL 
91d1			 
91d1					if DEBUG_FORTH_MALLOC 
91d1						DMARK "maB" 
91d1						CALLMONITOR 
91d1					endif 
91d1			      ; Loop through free block list to find some space 
91d1			malloc_find_space: 
91d1 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
91d2 23			      inc   HL 
91d3 56			      ld    D, (HL) 
91d4			 
91d4 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
91d5 b3			      or    E 
91d6 ca 62 92		      jp    Z, malloc_no_space 
91d9			 
91d9 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
91dc dd 72 01		      ld    (IX+1), D 
91df			 
91df			      ; Does this block have enough space to make the allocation? 
91df 23			      inc   HL                      ; Load free block size into DE 
91e0 5e			      ld    E, (HL) 
91e1 23			      inc   HL 
91e2 56			      ld    D, (HL) 
91e3			 
91e3 eb			      ex    DE, HL                  ; Check size of block against want 
91e4 b7			      or    A                       ; Ensure carry flag clear 
91e5 ed 42		      sbc   HL, BC 
91e7 e5			      push  HL                      ; Store the result for later (new block size) 
91e8			 
91e8 ca 37 92		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91eb 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91ed			 
91ed			      ; this_free block is not big enough, setup ptrs to test next free block 
91ed e1			      pop   HL                      ; Discard previous result 
91ee			 
91ee dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91f1 dd 66 03		      ld    H, (IX+3) 
91f4 dd 75 04		      ld    (IX+4), L 
91f7 dd 74 05		      ld    (IX+5), H 
91fa			 
91fa dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91fd dd 66 01		      ld    H, (IX+1) 
9200 dd 75 02		      ld    (IX+2), L 
9203 dd 74 03		      ld    (IX+3), H 
9206			 
9206					if DEBUG_FORTH_MALLOC 
9206						DMARK "MA>" 
9206						CALLMONITOR 
9206					endif 
9206 18 c9		      jr    malloc_find_space 
9208			 
9208			      ; split a bigger block into two - requested size and remaining size 
9208			malloc_alloc_split: 
9208					if DEBUG_FORTH_MALLOC 
9208						DMARK "MAs" 
9208						CALLMONITOR 
9208					endif 
9208 eb			      ex    DE, HL                  ; Calculate address of new free block 
9209 2b			      dec   HL 
920a 2b			      dec   HL 
920b 2b			      dec   HL 
920c 09			      add   HL, BC 
920d			 
920d			      ; Create a new block and point it at next_free 
920d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9210 dd 56 01		      ld    D, (IX+1) 
9213			 
9213 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9214 23			      inc   HL 
9215 72			      ld    (HL), D 
9216			 
9216 d1			      pop   DE                      ; Store size of new block into new block 
9217 23			      inc   HL 
9218 73			      ld    (HL), E 
9219 23			      inc   HL 
921a 72			      ld    (HL), D 
921b			 
921b			      ; Update this_free ptr to point to new block 
921b 2b			      dec   HL 
921c 2b			      dec   HL 
921d 2b			      dec   HL 
921e			 
921e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9221 dd 56 03		      ld    D, (IX+3) 
9224			 
9224 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9227 dd 74 03		      ld    (IX+3), H 
922a			 
922a			      ; Modify this_free block to be allocation 
922a eb			      ex    DE, HL 
922b af			      xor   A                       ; Null the next block ptr of allocated block 
922c 77			      ld    (HL), A 
922d 23			      inc   HL 
922e 77			      ld    (HL), A 
922f			 
922f 23			      inc   HL                      ; Store want size into allocated block 
9230 71			      ld    (HL), C 
9231 23			      inc   HL 
9232 70			      ld    (HL), B 
9233 23			      inc   HL 
9234 e5			      push  HL                      ; Address of allocation to return 
9235			 
9235 18 19		      jr    malloc_update_links 
9237			 
9237			malloc_alloc_fit: 
9237 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9238			 
9238					if DEBUG_FORTH_MALLOC 
9238						DMARK "MAf" 
9238						CALLMONITOR 
9238					endif 
9238			      ; Modify this_free block to be allocation 
9238 eb			      ex    DE, HL 
9239 2b			      dec   HL 
923a 2b			      dec   HL 
923b 2b			      dec   HL 
923c			 
923c af			      xor   A                       ; Null the next block ptr of allocated block 
923d 77			      ld    (HL), A 
923e 23			      inc   HL 
923f 77			      ld    (HL), A 
9240			 
9240 23			      inc   HL                      ; Store address of allocation to return 
9241 23			      inc   HL 
9242 23			      inc   HL 
9243 e5			      push  HL 
9244			 
9244			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9244 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9247 dd 66 01		      ld    H, (IX+1) 
924a			 
924a dd 75 02		      ld    (IX+2), L               ; HL to this_free 
924d dd 74 03		      ld    (IX+3), H 
9250			 
9250			 
9250			malloc_update_links: 
9250			      ; Update prev_free ptr to point to this_free 
9250 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9253 dd 66 05		      ld    H, (IX+5) 
9256			 
9256 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9259 dd 56 03		      ld    D, (IX+3) 
925c			 
925c 73			      ld    (HL), E                 ; this_free ptr into prev_free 
925d 23			      inc   HL 
925e 72			      ld    (HL), D 
925f			 
925f					if DEBUG_FORTH_MALLOC 
925f						DMARK "Mul" 
925f						CALLMONITOR 
925f					endif 
925f			      ; Clear the Z flag to indicate successful allocation 
925f 7a			      ld    A, D 
9260 b3			      or    E 
9261			 
9261 d1			      pop   DE                      ; Address of allocation 
9262					if DEBUG_FORTH_MALLOC 
9262						DMARK "MAu" 
9262						CALLMONITOR 
9262					endif 
9262			 
9262			malloc_no_space: 
9262 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9265 39			      add   HL, SP 
9266 f9			      ld    SP, HL 
9267			 
9267 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAN" 
9268						CALLMONITOR 
9268					endif 
9268			 
9268			malloc_early_exit: 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAx" 
9268						CALLMONITOR 
9268					endif 
9268 dd e1		      pop   IX 
926a d1			      pop   DE 
926b c1			      pop   BC 
926c			 
926c			if DEBUG_FORTH_MALLOC_HIGH 
926c			call malloc_guard_exit 
926c			call malloc_guard_zerolen 
926c			endif 
926c c9			      ret 
926d			 
926d			 
926d			;------------------------------------------------------------------------------ 
926d			;     free                                                                    : 
926d			;                                                                             : 
926d			; Description                                                                 : 
926d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
926d			;     returned by malloc, otherwise the behaviour is undefined.               : 
926d			;                                                                             : 
926d			;     Where possible, directly adjacent free blocks will be merged together   : 
926d			;     into larger blocks to help ensure that the heap does not become         : 
926d			;     excessively fragmented.                                                 : 
926d			;                                                                             : 
926d			;     free does not clear or set any other value into the freed space, and    : 
926d			;     therefore its contents may be visible through subsequent malloc's. The  : 
926d			;     caller should clear the freed space as required.                        : 
926d			;                                                                             : 
926d			;     This implementation of free uses the stack exclusively, and is          : 
926d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
926d			;     advisable to disable interrupts before calling free, and recommended    : 
926d			;     to avoid the use of free inside ISRs in general.                        : 
926d			;                                                                             : 
926d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
926d			;                                                                             : 
926d			; Parameters                                                                  : 
926d			;     HL  Pointer to address of first byte of allocation to be freed          : 
926d			;                                                                             : 
926d			; Returns                                                                     : 
926d			;     Nothing                                                                 : 
926d			;                                                                             : 
926d			; Stack frame                                                                 : 
926d			;       |             |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     BC      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     DE      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     IX      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |  prev_free  |                                                       : 
926d			;   +2  +-------------+                                                       : 
926d			;       |  next_free  |                                                       : 
926d			;   +0  +-------------+                                                       : 
926d			;       |             |                                                       : 
926d			;                                                                             : 
926d			;------------------------------------------------------------------------------ 
926d			free: 
926d c5			      push  BC 
926e d5			      push  DE 
926f dd e5		      push  IX 
9271			 
9271 7c			      ld    A, H                    ; Exit if ptr is null 
9272 b5			      or    L 
9273 ca 37 93		      jp    Z, free_early_exit 
9276			 
9276			      ; Set up stack frame 
9276 eb			      ex    DE, HL 
9277 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
927a 39			      add   HL, SP 
927b f9			      ld    SP, HL 
927c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9280 dd 39		      add   IX, SP 
9282			 
9282			      ; The address in HL points to the start of the useable allocated space, 
9282			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9282			      ; address of the block itself. 
9282 eb			      ex    DE, HL 
9283 11 fc ff		      ld    DE, -4 
9286 19			      add   HL, DE 
9287			 
9287			      ; An allocated block must have a null next block pointer in it 
9287 7e			      ld    A, (HL) 
9288 23			      inc   HL 
9289 b6			      or    (HL) 
928a c2 32 93		      jp    NZ, free_done 
928d			 
928d 2b			      dec   HL 
928e			 
928e 44			      ld    B, H                    ; Copy HL to BC 
928f 4d			      ld    C, L 
9290			 
9290			      ; Loop through the free list to find the first block with an address 
9290			      ; higher than the block being freed 
9290 21 87 e3		      ld    HL, free_list 
9293			 
9293			free_find_higher_block: 
9293 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9294 23			      inc   HL 
9295 56			      ld    D, (HL) 
9296 2b			      dec   HL 
9297			 
9297 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
929a dd 72 01		      ld    (IX+1), D 
929d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
92a0 dd 74 03		      ld    (IX+3), H 
92a3			 
92a3 78			      ld    A, B                    ; Check if DE is greater than BC 
92a4 ba			      cp    D                       ; Compare MSB first 
92a5 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
92a7 30 04		      jr    NC, free_find_higher_block_skip 
92a9 79			      ld    A, C 
92aa bb			      cp    E                       ; Then compare LSB 
92ab 38 08		      jr    C, free_found_higher_block 
92ad			 
92ad			free_find_higher_block_skip: 
92ad 7a			      ld    A, D                    ; Reached the end of the free list? 
92ae b3			      or    E 
92af ca 32 93		      jp    Z, free_done 
92b2			 
92b2 eb			      ex    DE, HL 
92b3			 
92b3 18 de		      jr    free_find_higher_block 
92b5			 
92b5			free_found_higher_block: 
92b5			      ; Insert freed block between prev and next free blocks 
92b5 71			      ld    (HL), C                 ; Point prev free block to freed block 
92b6 23			      inc   HL 
92b7 70			      ld    (HL), B 
92b8			 
92b8 60			      ld    H, B                    ; Point freed block at next free block 
92b9 69			      ld    L, C 
92ba 73			      ld    (HL), E 
92bb 23			      inc   HL 
92bc 72			      ld    (HL), D 
92bd			 
92bd			      ; Check if the freed block is adjacent to the next free block 
92bd 23			      inc   HL                      ; Load size of freed block into HL 
92be 5e			      ld    E, (HL) 
92bf 23			      inc   HL 
92c0 56			      ld    D, (HL) 
92c1 eb			      ex    DE, HL 
92c2			 
92c2 09			      add   HL, BC                  ; Add addr of freed block and its size 
92c3			 
92c3 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
92c6 dd 56 01		      ld    D, (IX+1) 
92c9			 
92c9 b7			      or    A                       ; Clear the carry flag 
92ca ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
92cc 20 22		      jr    NZ, free_check_adjacent_to_prev 
92ce			 
92ce			      ; Freed block is adjacent to next, merge into one bigger block 
92ce eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
92cf 5e			      ld    E, (HL) 
92d0 23			      inc   HL 
92d1 56			      ld    D, (HL) 
92d2 e5			      push  HL                      ; Save ptr to next block for later 
92d3			 
92d3 60			      ld    H, B                    ; Store ptr from next block into freed block 
92d4 69			      ld    L, C 
92d5 73			      ld    (HL), E 
92d6 23			      inc   HL 
92d7 72			      ld    (HL), D 
92d8			 
92d8 e1			      pop   HL                      ; Restore ptr to next block 
92d9 23			      inc   HL                      ; Load size of next block into DE 
92da 5e			      ld    E, (HL) 
92db 23			      inc   HL 
92dc 56			      ld    D, (HL) 
92dd d5			      push  DE                      ; Save next block size for later 
92de			 
92de 60			      ld    H, B                    ; Load size of freed block into HL 
92df 69			      ld    L, C 
92e0 23			      inc   HL 
92e1 23			      inc   HL 
92e2 5e			      ld    E, (HL) 
92e3 23			      inc   HL 
92e4 56			      ld    D, (HL) 
92e5 eb			      ex    DE, HL 
92e6			 
92e6 d1			      pop   DE                      ; Restore size of next block 
92e7 19			      add   HL, DE                  ; Add sizes of both blocks 
92e8 eb			      ex    DE, HL 
92e9			 
92e9 60			      ld    H, B                    ; Store new bigger size into freed block 
92ea 69			      ld    L, C 
92eb 23			      inc   HL 
92ec 23			      inc   HL 
92ed 73			      ld    (HL), E 
92ee 23			      inc   HL 
92ef 72			      ld    (HL), D 
92f0			 
92f0			free_check_adjacent_to_prev: 
92f0			      ; Check if the freed block is adjacent to the prev free block 
92f0 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92f3 dd 66 03		      ld    H, (IX+3) 
92f6			 
92f6 23			      inc   HL                      ; Size of prev free block into DE 
92f7 23			      inc   HL 
92f8 5e			      ld    E, (HL) 
92f9 23			      inc   HL 
92fa 56			      ld    D, (HL) 
92fb 2b			      dec   HL 
92fc 2b			      dec   HL 
92fd 2b			      dec   HL 
92fe			 
92fe 19			      add   HL, DE                  ; Add prev block addr and size 
92ff			 
92ff b7			      or    A                       ; Clear the carry flag 
9300 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9302 20 2e		      jr    NZ, free_done 
9304			 
9304			      ; Freed block is adjacent to prev, merge into one bigger block 
9304 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9305 69			      ld    L, C 
9306 5e			      ld    E, (HL) 
9307 23			      inc   HL 
9308 56			      ld    D, (HL) 
9309 e5			      push  HL                      ; Save freed block ptr for later 
930a			 
930a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
930d dd 66 03		      ld    H, (IX+3) 
9310 73			      ld    (HL), E 
9311 23			      inc   HL 
9312 72			      ld    (HL), D 
9313			 
9313 e1			      pop   HL                      ; Restore freed block ptr 
9314 23			      inc   HL                      ; Load size of freed block into DE 
9315 5e			      ld    E, (HL) 
9316 23			      inc   HL 
9317 56			      ld    D, (HL) 
9318 d5			      push  DE                      ; Save freed block size for later 
9319			 
9319 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
931c dd 66 03		      ld    H, (IX+3) 
931f 23			      inc   HL 
9320 23			      inc   HL 
9321 5e			      ld    E, (HL) 
9322 23			      inc   HL 
9323 56			      ld    D, (HL) 
9324			 
9324 e1			      pop   HL                      ; Add sizes of both blocks 
9325 19			      add   HL, DE 
9326 eb			      ex    DE, HL 
9327			 
9327 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
932a dd 66 03		      ld    H, (IX+3) 
932d 23			      inc   HL 
932e 23			      inc   HL 
932f 73			      ld    (HL), E 
9330 23			      inc   HL 
9331 72			      ld    (HL), D 
9332			 
9332			free_done: 
9332 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9335 39			      add   HL, SP 
9336 f9			      ld    SP, HL 
9337			 
9337			free_early_exit: 
9337 dd e1		      pop   IX 
9339 d1			      pop   DE 
933a c1			      pop   BC 
933b			 
933b c9			      ret 
933c			 
933c			; moved to firmware.asm 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			;                  .dw   0 
933c			 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_3 
933c			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
933c			;heap_start        .equ  0x9000      ; Starting address of heap 
933c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
933c			; 
933c			 ;     .org 0 
933c			  ;    jp    main 
933c			; 
933c			; 
933c			 ;     .org  0x100 
933c			;main: 
933c			 ;     ld    HL, 0x8100 
933c			  ;    ld    SP, HL 
933c			; 
933c			;      call  heap_init 
933c			 
933c			      ; Make some allocations 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9004 
933c			; 
933c			 ;     ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9014 
933c			 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9024 
933c			 
933c			      ; Free some allocations 
933c			;      ld    HL, 0x9014 
933c			;      call  free 
933c			 
933c			;      ld    HL, 0x9004 
933c			;      call  free 
933c			; 
933c			;      ld    HL, 0x9024 
933c			;      call  free 
933c			 
933c			 
933c			 ;     halt 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     heap_init                                                               : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Initialise the heap and make it ready for malloc and free operations.   : 
933c			;                                                                             : 
933c			;     The heap is maintained as a linked list, starting with an initial       : 
933c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
933c			;     the first free block in the heap. Each block then points to the next    : 
933c			;     free block within the heap, and the free list ends at the first block   : 
933c			;     with a null pointer to the next free block.                             : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     Inputs are compile-time only. Two defines which specify the starting    : 
933c			;     address of the heap and its size are required, along with a memory      : 
933c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
933c			;     principally stores a pointer to the first free block in the heap.       : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;------------------------------------------------------------------------------ 
933c			heap_init: 
933c			      push  HL 
933c			 
933c			      ; Initialise free list struct 
933c			      ld    HL, heap_start 
933c			      ld    (free_list), HL 
933c			      ld    HL, 0 
933c			      ld    (free_list+2), HL 
933c			 
933c			      ; Insert first free block at bottom of heap, consumes entire heap 
933c			      ld    HL, heap_start+heap_size-4 
933c			      ld    (heap_start), HL        ; Next block (end of free list) 
933c			      ld    HL, heap_size-4 
933c			      ld    (heap_start+2), HL      ; Block size 
933c			 
933c			      ; Insert end of free list block at top of heap - two null words will 
933c			      ; terminate the free list 
933c			      ld    HL, 0 
933c			      ld    (heap_start+heap_size-2), HL 
933c			      ld    (heap_start+heap_size-4), HL 
933c			 
933c			      pop   HL 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     malloc                                                                  : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Allocates the wanted space from the heap and returns the address of the : 
933c			;     first useable byte of the allocation.                                   : 
933c			;                                                                             : 
933c			;     Allocations can happen in one of two ways:                              : 
933c			;                                                                             : 
933c			;     1. A free block may be found which is the exact size wanted. In this    : 
933c			;        case the block is removed from the free list and retuedn to the      : 
933c			;        caller.                                                              : 
933c			;     2. A free block may be found which is larger than the size wanted. In   : 
933c			;        this case, the larger block is split into two. The first portion of  : 
933c			;        this block will become the requested space by the malloc call and    : 
933c			;        is returned to the caller. The second portion becomes a new free     : 
933c			;        block, and the free list is adjusted to maintain continuity via this : 
933c			;        newly created block.                                                 : 
933c			;                                                                             : 
933c			;     malloc does not set any initial value in the allocated space, the       : 
933c			;     caller is required to do this as required.                              : 
933c			;                                                                             : 
933c			;     This implementation of malloc uses the stack exclusively, and is        : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling malloc, and recommended  : 
933c			;     to avoid the use of malloc inside ISRs in general.                      : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Number of bytes wanted                                              : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     HL  Address of the first useable byte of the allocation                 : 
933c			;                                                                             : 
933c			; Flags                                                                       : 
933c			;     Z   Set if the allocation did not succeed, clear otherwise              : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +4  +-------------+                                                       : 
933c			;       |  this_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			malloc: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if no space requested 
933c			      or    L 
933c			      jp    Z, malloc_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; Setup initial state 
933c			      ld    HL, 4                   ; want must also include space used by block struct 
933c			      add   HL, DE 
933c			 
933c			      ld    B, H                    ; Move want to BC 
933c			      ld    C, L 
933c			 
933c			      ld    HL, free_list           ; Store prev_free ptr to stack 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    E, (HL)                 ; Store this_free ptr to stack 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ld    (IX+2), E 
933c			      ld    (IX+3), D 
933c			      ex    DE, HL                  ; this_free ptr into HL 
933c			 
933c			      ; Loop through free block list to find some space 
933c			malloc_find_space: 
933c			      ld    E, (HL)                 ; Load next_free ptr into DE 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ld    A, D                    ; Check for null next_free ptr - end of free list 
933c			      or    E 
933c			      jp    Z, malloc_no_space 
933c			 
933c			      ld    (IX+0), E               ; Store next_free ptr to stack 
933c			      ld    (IX+1), D 
933c			 
933c			      ; Does this block have enough space to make the allocation? 
933c			      inc   HL                      ; Load free block size into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ex    DE, HL                  ; Check size of block against want 
933c			      or    A                       ; Ensure carry flag clear 
933c			      sbc   HL, BC 
933c			      push  HL                      ; Store the result for later (new block size) 
933c			 
933c			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
933c			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
933c			 
933c			      ; this_free block is not big enough, setup ptrs to test next free block 
933c			      pop   HL                      ; Discard previous result 
933c			 
933c			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
933c			      ld    H, (IX+3) 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
933c			      ld    H, (IX+1) 
933c			      ld    (IX+2), L 
933c			      ld    (IX+3), H 
933c			 
933c			      jr    malloc_find_space 
933c			 
933c			      ; split a bigger block into two - requested size and remaining size 
933c			malloc_alloc_split: 
933c			      ex    DE, HL                  ; Calculate address of new free block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      add   HL, BC 
933c			 
933c			      ; Create a new block and point it at next_free 
933c			      ld    E, (IX+0)               ; Load next_free ptr into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      ld    (HL), E                 ; Store next_free ptr into new block 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   DE                      ; Store size of new block into new block 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Update this_free ptr to point to new block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
933c			      ld    (IX+3), H 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store want size into allocated block 
933c			      ld    (HL), C 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			      inc   HL 
933c			      push  HL                      ; Address of allocation to return 
933c			 
933c			      jr    malloc_update_links 
933c			 
933c			malloc_alloc_fit: 
933c			      pop   HL                      ; Dont need new block size, want is exact fit 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store address of allocation to return 
933c			      inc   HL 
933c			      inc   HL 
933c			      push  HL 
933c			 
933c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
933c			      ld    L, (IX+0)               ; next_free to HL 
933c			      ld    H, (IX+1) 
933c			 
933c			      ld    (IX+2), L               ; HL to this_free 
933c			      ld    (IX+3), H 
933c			 
933c			 
933c			malloc_update_links: 
933c			      ; Update prev_free ptr to point to this_free 
933c			      ld    L, (IX+4)               ; prev_free ptr to HL 
933c			      ld    H, (IX+5) 
933c			 
933c			      ld    E, (IX+2)               ; this_free ptr to DE 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (HL), E                 ; this_free ptr into prev_free 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Clear the Z flag to indicate successful allocation 
933c			      ld    A, D 
933c			      or    E 
933c			 
933c			      pop   DE                      ; Address of allocation 
933c			 
933c			malloc_no_space: 
933c			      ld    HL, 6                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			      ex    DE, HL                  ; Alloc addr into HL for return 
933c			 
933c			malloc_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     free                                                                    : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
933c			;     returned by malloc, otherwise the behaviour is undefined.               : 
933c			;                                                                             : 
933c			;     Where possible, directly adjacent free blocks will be merged together   : 
933c			;     into larger blocks to help ensure that the heap does not become         : 
933c			;     excessively fragmented.                                                 : 
933c			;                                                                             : 
933c			;     free does not clear or set any other value into the freed space, and    : 
933c			;     therefore its contents may be visible through subsequent malloc's. The  : 
933c			;     caller should clear the freed space as required.                        : 
933c			;                                                                             : 
933c			;     This implementation of free uses the stack exclusively, and is          : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling free, and recommended    : 
933c			;     to avoid the use of free inside ISRs in general.                        : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Pointer to address of first byte of allocation to be freed          : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			free: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if ptr is null 
933c			      or    L 
933c			      jp    Z, free_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; The address in HL points to the start of the useable allocated space, 
933c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
933c			      ; address of the block itself. 
933c			      ex    DE, HL 
933c			      ld    DE, -4 
933c			      add   HL, DE 
933c			 
933c			      ; An allocated block must have a null next block pointer in it 
933c			      ld    A, (HL) 
933c			      inc   HL 
933c			      or    (HL) 
933c			      jp    NZ, free_done 
933c			 
933c			      dec   HL 
933c			 
933c			      ld    B, H                    ; Copy HL to BC 
933c			      ld    C, L 
933c			 
933c			      ; Loop through the free list to find the first block with an address 
933c			      ; higher than the block being freed 
933c			      ld    HL, free_list 
933c			 
933c			free_find_higher_block: 
933c			      ld    E, (HL)                 ; Load next ptr from free block 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			 
933c			      ld    (IX+0), E               ; Save ptr to next free block 
933c			      ld    (IX+1), D 
933c			      ld    (IX+2), L               ; Save ptr to prev free block 
933c			      ld    (IX+3), H 
933c			 
933c			      ld    A, B                    ; Check if DE is greater than BC 
933c			      cp    D                       ; Compare MSB first 
933c			      jr    Z, $+4                  ; MSB the same, compare LSB 
933c			      jr    NC, free_find_higher_block_skip 
933c			      ld    A, C 
933c			      cp    E                       ; Then compare LSB 
933c			      jr    C, free_found_higher_block 
933c			 
933c			free_find_higher_block_skip: 
933c			      ld    A, D                    ; Reached the end of the free list? 
933c			      or    E 
933c			      jp    Z, free_done 
933c			 
933c			      ex    DE, HL 
933c			 
933c			      jr    free_find_higher_block 
933c			 
933c			free_found_higher_block: 
933c			      ; Insert freed block between prev and next free blocks 
933c			      ld    (HL), C                 ; Point prev free block to freed block 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			 
933c			      ld    H, B                    ; Point freed block at next free block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Check if the freed block is adjacent to the next free block 
933c			      inc   HL                      ; Load size of freed block into HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      add   HL, BC                  ; Add addr of freed block and its size 
933c			 
933c			      ld    E, (IX+0)               ; Load addr of next free block into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_check_adjacent_to_prev 
933c			 
933c			      ; Freed block is adjacent to next, merge into one bigger block 
933c			      ex    DE, HL                  ; Load next ptr from next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save ptr to next block for later 
933c			 
933c			      ld    H, B                    ; Store ptr from next block into freed block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore ptr to next block 
933c			      inc   HL                      ; Load size of next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save next block size for later 
933c			 
933c			      ld    H, B                    ; Load size of freed block into HL 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      pop   DE                      ; Restore size of next block 
933c			      add   HL, DE                  ; Add sizes of both blocks 
933c			      ex    DE, HL 
933c			 
933c			      ld    H, B                    ; Store new bigger size into freed block 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_check_adjacent_to_prev: 
933c			      ; Check if the freed block is adjacent to the prev free block 
933c			      ld    L, (IX+2)               ; Prev free block ptr into HL 
933c			      ld    H, (IX+3) 
933c			 
933c			      inc   HL                      ; Size of prev free block into DE 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      add   HL, DE                  ; Add prev block addr and size 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_done 
933c			 
933c			      ; Freed block is adjacent to prev, merge into one bigger block 
933c			      ld    H, B                    ; Load next ptr from freed block into DE 
933c			      ld    L, C 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save freed block ptr for later 
933c			 
933c			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
933c			      ld    H, (IX+3) 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore freed block ptr 
933c			      inc   HL                      ; Load size of freed block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save freed block size for later 
933c			 
933c			      ld    L, (IX+2)               ; Load size of prev block into DE 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      pop   HL                      ; Add sizes of both blocks 
933c			      add   HL, DE 
933c			      ex    DE, HL 
933c			 
933c			      ld    L, (IX+2)               ; Store new bigger size into prev block 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_done: 
933c			      ld    HL, 4                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			free_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;      .org 0x8000 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			 ;                 .dw   0 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_4 
933c			 
933c			; My memory allocation code. Very very simple.... 
933c			; allocate space under 250 chars 
933c			 
933c			heap_init: 
933c				; init start of heap as zero 
933c				;  
933c			 
933c				ld hl, heap_start 
933c				ld a, 0 
933c				ld (hl), a      ; empty block 
933c				inc hl 
933c				ld a, 0 
933c				ld (hl), a      ; length of block 
933c				; write end of list 
933c				inc hl 
933c				ld a,(hl) 
933c				inc hl 
933c				ld a,(hl) 
933c				 
933c			 
933c				; init some malloc vars 
933c			 
933c				ld hl, 0 
933c				ld (free_list), hl       ; store last malloc location 
933c			 
933c				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
933c				ld a, 0 
933c				ld (hl), a 
933c			 
933c			 
933c				ld hl, heap_start 
933c				;  
933c				  
933c				ret 
933c			 
933c			 
933c			;    free block marker 
933c			;    requested size  
933c			;    pointer to next block 
933c			;    .... 
933c			;    next block marker 
933c			 
933c			 
933c			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
933c			; 
933c			 
933c			 
933c			malloc:  
933c				push de 
933c				push bc 
933c				push af 
933c			 
933c				; hl space required 
933c				 
933c				ld c, l    ; hold space   (TODO only a max of 255) 
933c			 
933c			;	inc c     ; TODO BUG need to fix memory leak on push str 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			 
933c			 
933c			 
933c				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
933c			 
933c				ld a, (free_list+3) 
933c				cp 0 
933c				jr z, .contheap 
933c			 
933c				ld hl, (free_list)     ; get last alloc 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mrs" 
933c						CALLMONITOR 
933c					endif 
933c				jr .startalloc 
933c			 
933c			.contheap: 
933c				ld hl, heap_start 
933c			 
933c			.startalloc: 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mym" 
933c						CALLMONITOR 
933c					endif 
933c			.findblock: 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmf" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c				ld a,(hl)  
933c				; if byte is zero then clear to use 
933c			 
933c				cp 0 
933c				jr z, .foundemptyblock 
933c			 
933c				; if byte is not clear 
933c				;     then byte is offset to next block 
933c			 
933c				inc hl 
933c				ld a, (hl) ; get size 
933c			.nextblock:	inc hl 
933c					ld e, (hl) 
933c					inc hl 
933c					ld d, (hl) 
933c					ex de, hl 
933c			;	inc hl  ; move past the store space 
933c			;	inc hl  ; move past zero index  
933c			 
933c				; TODO detect no more space 
933c			 
933c				push hl 
933c				ld de, heap_end 
933c				call cmp16 
933c				pop hl 
933c				jr nc, .nospace 
933c			 
933c				jr .findblock 
933c			 
933c			.nospace: ld hl, 0 
933c				jp .exit 
933c			 
933c			 
933c			.foundemptyblock:	 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mme" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; TODO has block enough space if reusing??? 
933c			 
933c				;  
933c			 
933c			; see if this block has been previously used 
933c				inc hl 
933c				ld a, (hl) 
933c				dec hl 
933c				cp 0 
933c				jr z, .newblock 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meR" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; no reusing previously allocated block 
933c			 
933c			; is it smaller than previously used? 
933c				 
933c				inc hl    ; move to size 
933c				ld a, c 
933c				sub (hl)        ; we want c < (hl) 
933c				dec hl    ; move back to marker 
933c			        jr z, .findblock 
933c			 
933c				; update with the new size which should be lower 
933c			 
933c			        ;inc  hl   ; negate next move. move back to size  
933c			 
933c			.newblock: 
933c				; need to be at marker here 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meN" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			 
933c				ld a, c 
933c			 
933c				ld (free_list+3), a	 ; flag resume from last malloc  
933c				ld (free_list), hl    ; save out last location 
933c			 
933c			 
933c				;inc a     ; space for length byte 
933c				ld (hl), a     ; save block in use marker 
933c			 
933c				inc hl   ; move to space marker 
933c				ld (hl), a    ; save new space 
933c			 
933c				inc hl   ; move to start of allocated area 
933c				 
933c			;	push hl     ; save where we are - 1  
933c			 
933c			;	inc hl  ; move past zero index  
933c				; skip space to set down new marker 
933c			 
933c				; provide some extra space for now 
933c			 
933c				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
933c				inc a 
933c				inc a 
933c			 
933c				push hl   ; save where we are in the node block 
933c			 
933c				call addatohl 
933c			 
933c				; write linked list point 
933c			 
933c				pop de     ; get our node position 
933c				ex de, hl 
933c			 
933c				ld (hl), e 
933c				inc hl 
933c				ld (hl), d 
933c			 
933c				inc hl 
933c			 
933c				; now at start of allocated data so save pointer 
933c			 
933c				push hl 
933c			 
933c				; jump to position of next node and setup empty header in DE 
933c			 
933c				ex de, hl 
933c			 
933c			;	inc hl ; move past end of block 
933c			 
933c				ld a, 0 
933c				ld (hl), a   ; empty marker 
933c				inc hl 
933c				ld (hl), a   ; size 
933c				inc hl  
933c				ld (hl), a   ; ptr 
933c				inc hl 
933c				ld (hl), a   ; ptr 
933c			 
933c			 
933c				pop hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmr" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			.exit: 
933c				pop af 
933c				pop bc 
933c				pop de  
933c				ret 
933c			 
933c			 
933c			 
933c			 
933c			free:  
933c				push hl 
933c				push af 
933c				; get address in hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "fre" 
933c						CALLMONITOR 
933c					endif 
933c				; data is at hl - move to block count 
933c				dec hl 
933c				dec hl    ; get past pointer 
933c				dec hl 
933c			 
933c				ld a, (hl)    ; need this for a validation check 
933c			 
933c				dec hl    ; move to block marker 
933c			 
933c				; now check that the block count and block marker are the same  
933c			        ; this checks that we are on a malloc node and not random memory 
933c			        ; OK a faint chance this could be a problem but rare - famous last words! 
933c			 
933c				ld c, a 
933c				ld a, (hl)    
933c			 
933c				cp c 
933c				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
933c			 
933c				; yes good chance we are on a malloc node 
933c			 
933c				ld a, 0      
933c				ld (hl), a   ; mark as free 
933c			 
933c				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
933c			 
933c			.freeignore:  
933c			 
933c				pop af 
933c				pop hl 
933c			 
933c				ret 
933c			 
933c			 
933c			 
933c			endif 
933c			 
933c			; eof 
# End of file firmware_memory.asm
933c			  
933c			; device C  
933c			if SOUND_ENABLE  
933c				include "firmware_sound.asm"  
933c			endif  
933c			  
933c			include "firmware_diags.asm"  
933c			; Hardware diags menu 
933c			 
933c			 
933c			config: 
933c			 
933c 3e 00			ld a, 0 
933e 21 6c 93			ld hl, .configmn 
9341 cd e0 8a			call menu 
9344			 
9344 fe 00			cp 0 
9346 c8				ret z 
9347			 
9347 fe 01			cp 1 
9349 cc 9a 93			call z, .savetostore 
934c			 
934c fe 02			cp 2 
934e			if STARTUP_V1 
934e cc 86 93			call z, .selautoload 
9351			endif 
9351			 
9351			if STARTUP_V2 
9351				call z, .enautoload 
9351			endif 
9351 fe 03			cp 3 
9353 cc 7c 93			call z, .disautoload 
9356 fe 04			cp 4 
9358 cc 90 93			call z, .selbank 
935b fe 05			cp 5 
935d cc a4 93			call z, .debug_tog 
9360 fe 06			cp 6 
9362 cc e7 94			call z, .bpsgo 
9365 fe 07			cp 7 
9367 cc ca 93			call z, hardware_diags 
936a			if STARTUP_V2 
936a				cp 8 
936a				call z, create_startup 
936a			endif 
936a 18 d0			jr config 
936c			 
936c			.configmn: 
936c d8 96			dw prom_c3 
936e ef 96			dw prom_c2 
9370 04 97			dw prom_c2a 
9372 1a 97			dw prom_c2b 
9374			;	dw prom_c4 
9374 37 97			dw prom_m4 
9376 52 97			dw prom_m4b 
9378 5a 97			dw prom_c1 
937a			if STARTUP_V2 
937a				dw prom_c9 
937a			endif 
937a 00 00			dw 0 
937c				 
937c			 
937c			if STARTUP_V2 
937c			.enautoload: 
937c				if STORAGE_SE 
937c				ld a, $fe      ; bit 0 clear 
937c				ld (spi_device), a 
937c			 
937c				call storage_get_block_0 
937c			 
937c				ld a, 1 
937c				ld (store_page+STORE_0_AUTOFILE), a 
937c			 
937c					ld hl, 0 
937c					ld de, store_page 
937c				call storage_write_block	 ; save update 
937c				else 
937c			 
937c				ld hl, prom_notav 
937c				ld de, prom_empty 
937c				call info_panel 
937c				endif 
937c			 
937c			 
937c				ret 
937c			endif 
937c			 
937c			.disautoload: 
937c				if STORAGE_SE 
937c				ld a, $fe      ; bit 0 clear 
937c				ld (spi_device), a 
937c			 
937c				call storage_get_block_0 
937c			 
937c				ld a, 0 
937c				ld (store_page+STORE_0_AUTOFILE), a 
937c			 
937c					ld hl, 0 
937c					ld de, store_page 
937c				call storage_write_block	 ; save update 
937c				else 
937c			 
937c 21 69 97			ld hl, prom_notav 
937f 11 7f 97			ld de, prom_empty 
9382 cd 40 8a			call info_panel 
9385				endif 
9385			 
9385			 
9385 c9				ret 
9386			 
9386			if STARTUP_V1 
9386			 
9386			; Select auto start 
9386			 
9386			.selautoload: 
9386			 
9386				 
9386				if STORAGE_SE 
9386			 
9386					call config_dir 
9386				        ld hl, scratch 
9386					ld a, 0 
9386					call menu 
9386			 
9386					cp 0 
9386					ret z 
9386			 
9386					dec a 
9386			 
9386			 
9386					; locate menu option 
9386			 
9386					ld hl, scratch 
9386					call table_lookup 
9386			 
9386					if DEBUG_FORTH_WORDS 
9386						DMARK "ALl" 
9386						CALLMONITOR 
9386					endif 
9386					; with the pointer to the menu it, the byte following the zero term is the file id 
9386			 
9386					ld a, 0 
9386					ld bc, 50   ; max of bytes to look at 
9386					cpir  
9386			 
9386					if DEBUG_FORTH_WORDS 
9386						DMARK "ALb" 
9386						CALLMONITOR 
9386					endif 
9386					;inc hl 
9386			 
9386					ld a, (hl)   ; file id 
9386					 
9386				        ; save bank and file ids 
9386			 
9386					push af 
9386			 
9386			; TODO need to save to block 0 on bank 1	 
9386			 
9386					call storage_get_block_0 
9386			 
9386					if DEBUG_FORTH_WORDS 
9386						DMARK "AL0" 
9386						CALLMONITOR 
9386					endif 
9386					pop af 
9386			 
9386					ld (store_page+STORE_0_FILERUN),a 
9386					 
9386					; save bank id 
9386			 
9386					ld a,(spi_device) 
9386					ld (store_page+STORE_0_BANKRUN),a 
9386			 
9386					; enable auto run of store file 
9386			 
9386					ld a, 1 
9386					ld (store_page+STORE_0_AUTOFILE),a 
9386			 
9386					; save buffer 
9386			 
9386					ld hl, 0 
9386					ld de, store_page 
9386					if DEBUG_FORTH_WORDS 
9386						DMARK "ALw" 
9386						CALLMONITOR 
9386					endif 
9386				call storage_write_block	 ; save update 
9386			  
9386			 
9386			 
9386			 
9386					ld hl, scratch 
9386					call config_fdir 
9386			 
9386				else 
9386			 
9386 21 69 97			ld hl, prom_notav 
9389 11 7f 97			ld de, prom_empty 
938c cd 40 8a			call info_panel 
938f			 
938f				endif 
938f c9				ret 
9390			endif 
9390			 
9390			 
9390			; Select storage bank 
9390			 
9390			.selbank: 
9390			 
9390				if STORAGE_SE 
9390				else 
9390			 
9390 21 69 97			ld hl, prom_notav 
9393 11 7f 97			ld de, prom_empty 
9396 cd 40 8a			call info_panel 
9399				endif 
9399				 
9399 c9				ret 
939a			 
939a			if STORAGE_SE 
939a			 
939a			.config_ldir:   
939a				; Load storage bank labels into menu array 
939a			 
939a				 
939a			 
939a			 
939a				ret 
939a			 
939a			 
939a			endif 
939a			 
939a			 
939a			; Save user words to storage 
939a			 
939a			.savetostore: 
939a			 
939a				if STORAGE_SE 
939a			 
939a					call config_dir 
939a				        ld hl, scratch 
939a					ld a, 0 
939a					call menu 
939a					 
939a					ld hl, scratch 
939a					call config_fdir 
939a			 
939a				else 
939a			 
939a 21 69 97			ld hl, prom_notav 
939d 11 7f 97			ld de, prom_empty 
93a0 cd 40 8a			call info_panel 
93a3			 
93a3				endif 
93a3			 
93a3 c9				ret 
93a4			 
93a4			if STARTUP_V2 
93a4			 
93a4			create_startup: 
93a4			 
93a4				ld a, 0 
93a4				ld hl, .crstart 
93a4				call menu 
93a4			 
93a4				cp 0 
93a4				ret z 
93a4			 
93a4				cp 1 
93a4				call z, .genlsword 
93a4				cp 2 
93a4				call z, .genedword 
93a4			 
93a4				cp 3 
93a4				call z, .gendemword 
93a4			 
93a4				cp 4 
93a4				call z, .genutlword 
93a4				cp 5 
93a4				call z, .genspiword 
93a4				cp 6 
93a4				call z, .genkeyword 
93a4				jr create_startup 
93a4			 
93a4			.genlsword: 
93a4				ld hl, crs_s1 
93a4				ld de, .lsworddef 
93a4				call .genfile 
93a4				ret 
93a4			 
93a4			.genedword: 
93a4				ld de, .edworddef 
93a4				ld hl, crs_s2 
93a4				call .genfile 
93a4				ret 
93a4			 
93a4			.gendemword: 
93a4				ld de, .demoworddef 
93a4				ld hl, crs_s3 
93a4				call .genfile 
93a4				ret 
93a4			 
93a4			.genutlword: 
93a4				ld hl, crs_s4 
93a4				ld de, .utilwordef 
93a4				call .genfile 
93a4				ret 
93a4			.genspiword: 
93a4				ld hl, crs_s5 
93a4				ld de, .spiworddef 
93a4				call .genfile 
93a4				ret 
93a4			.genkeyword: 
93a4				ld hl, crs_s6 
93a4				ld de, .keyworddef 
93a4				call .genfile 
93a4				ret 
93a4			 
93a4			; hl - points to file name 
93a4			; de - points to strings to add to file 
93a4			 
93a4			.genfile: 
93a4				push hl 
93a4				push de 
93a4			 
93a4				call clear_display 
93a4				ld a, display_row_1 
93a4				ld de, .genfiletxt 
93a4				call str_at_display 
93a4				call update_display 
93a4			 
93a4				pop de 
93a4				pop hl 
93a4			 
93a4			 
93a4				push de 
93a4				call storage_create 
93a4				; id in hl 
93a4				pop de   ; table of strings to add 
93a4			 
93a4			.genloop: 
93a4			 
93a4				push hl ; save id for next time around 
93a4				push de ; save de for next time around 
93a4			 
93a4				ex de, hl 
93a4				call loadwordinhl 
93a4				ex de, hl 
93a4			 
93a4				; need hl to be the id 
93a4				; need de to be the string ptr 
93a4				 
93a4				call storage_append 
93a4			 
93a4				pop de 
93a4				pop hl 
93a4			 
93a4				inc de 
93a4				inc de 
93a4			 
93a4				ld a,(de) 
93a4				cp 0 
93a4				jr nz, .genloop 
93a4				inc de 
93a4				ld a, (de) 
93a4				dec de 
93a4				cp 0 
93a4				jr nz, .genloop	 
93a4			 
93a4				ret 
93a4			 
93a4			.genfiletxt:  db "Creating file...",0 
93a4			 
93a4			.utilwordef: 
93a4				dw strncpy 
93a4				dw type 
93a4				dw clrstack 
93a4				dw longread 
93a4				dw start1 
93a4				dw start2 
93a4				dw start3b 
93a4				dw start3c 
93a4				dw list 
93a4				dw 0 
93a4			 
93a4			.lsworddef: 
93a4				dw start3b 
93a4				dw 0 
93a4			 
93a4			.edworddef: 
93a4				dw edit1 
93a4				dw edit2 
93a4				dw edit3 
93a4				dw 0 
93a4			 
93a4			.demoworddef: 
93a4				dw test5 
93a4				dw test6 
93a4				dw test7 
93a4				dw test8 
93a4				dw test9 
93a4				dw test10 
93a4				dw game1 
93a4				dw game1a 
93a4				dw game1b 
93a4				dw game1c 
93a4				dw game1d 
93a4				dw game1s 
93a4				dw game1t 
93a4				dw game1f 
93a4				dw game1z 
93a4				dw game1zz 
93a4				dw ssv2 
93a4				dw ssv3 
93a4				dw ssv4 
93a4				dw ssv5 
93a4				dw ssv1 
93a4				dw ssv1cpm	 
93a4				dw game2b 
93a4				dw game2bf 
93a4				dw game2mba 
93a4				dw game2mbas	 
93a4				dw game2mbht 
93a4				dw game2mbms 
93a4				dw game2mb 
93a4				dw game3w 
93a4				dw game3p 
93a4				dw game3sc 
93a4				dw game3vsi 
93a4				dw game3vs 
93a4				dw 0 
93a4			 
93a4			 
93a4			.spiworddef: 
93a4			 
93a4			    dw spi1 
93a4			    dw spi2 
93a4			    dw spi3 
93a4			    dw spi4 
93a4			    dw spi5 
93a4			    dw spi6 
93a4			    dw spi7 
93a4			 
93a4			    dw spi8 
93a4			    dw spi9 
93a4			    dw spi10 
93a4			    dw 0 
93a4			 
93a4			.keyworddef: 
93a4			 
93a4				dw keyup 
93a4				dw keydown 
93a4				dw keyleft 
93a4				dw keyright 
93a4				dw 	keyf1 
93a4				dw keyf2 
93a4				dw keyf3 
93a4				dw keyf4 
93a4				dw keyf5 
93a4				dw keyf6 
93a4				dw keyf7 
93a4				dw keyf8 
93a4				dw keyf9 
93a4				dw keyf10 
93a4				dw keyf11 
93a4				dw keyf12 
93a4				dw keytab 
93a4				dw keycr 
93a4				dw keyhome 
93a4				dw keyend 
93a4				dw keybs 
93a4				dw 0 
93a4			 
93a4			.crstart: 
93a4				dw crs_s1 
93a4				dw crs_s2 
93a4				dw crs_s3 
93a4				dw crs_s4 
93a4				dw crs_s5 
93a4				dw crs_s6 
93a4				dw 0 
93a4			 
93a4			endif 
93a4			 
93a4			 
93a4			if STORAGE_SE 
93a4			 
93a4			config_fdir: 
93a4				; using the scratch dir go through and release the memory allocated for each string 
93a4				 
93a4				ld hl, scratch 
93a4			.cfdir:	ld e,(hl) 
93a4				inc hl 
93a4				ld d,(hl) 
93a4				inc hl 
93a4			 
93a4				ex de, hl 
93a4				call ishlzero 
93a4				ret z     ; return on null pointer 
93a4				call free 
93a4				ex de, hl 
93a4				jr .cfdir 
93a4			 
93a4			 
93a4				ret 
93a4			 
93a4			 
93a4			config_dir: 
93a4			 
93a4				; for the config menus that need to build a directory of storage call this routine 
93a4				; it will construct a menu in scratch to pass to menu 
93a4			 
93a4				; open storage device 
93a4			 
93a4				; execute DIR to build a list of files and their ids into scratch in menu format 
93a4				; once the menu has finished then will need to call config_fdir to release the strings 
93a4				 
93a4				; c = number items 
93a4			 
93a4				 
93a4				call storage_get_block_0 
93a4			 
93a4				ld hl, store_page     ; get current id count 
93a4				ld b, (hl) 
93a4				ld c, 0    ; count of files   
93a4			 
93a4			 
93a4				ld hl, scratch 
93a4				ld (store_tmp2), hl    ; location to poke strings 
93a4			 
93a4				; check for empty drive 
93a4			 
93a4				ld a, 0 
93a4				cp b 
93a4				jp z, .dirdone 
93a4			 
93a4				 
93a4					if DEBUG_FORTH_WORDS 
93a4						DMARK "Cdc" 
93a4						CALLMONITOR 
93a4					endif 
93a4			 
93a4			 
93a4			.diritem:	 
93a4				push bc 
93a4				; for each of the current ids do a search for them and if found push to stack 
93a4			 
93a4					ld hl, STORE_BLOCK_PHY 
93a4					ld d, 0		 ; look for extent 0 of block id as this contains file name 
93a4					ld e,b 
93a4			 
93a4					call storage_findnextid 
93a4			 
93a4			 
93a4					; if found hl will be non zero 
93a4			 
93a4					call ishlzero 
93a4					jr z, .dirnotfound 
93a4			 
93a4					; increase count 
93a4			 
93a4					pop bc	 
93a4					inc c 
93a4					push bc 
93a4					 
93a4			 
93a4					; get file header and push the file name 
93a4			 
93a4					ld de, store_page 
93a4					call storage_read_block 
93a4			 
93a4					; push file id to stack 
93a4				 
93a4					ld a, (store_page) 
93a4					ld h, 0 
93a4					ld l, a 
93a4			 
93a4					;call forth_push_numhl 
93a4					; TODO store id 
93a4			 
93a4					push hl 
93a4			 
93a4					; push extent count to stack  
93a4				 
93a4					ld hl, store_page+3 
93a4			 
93a4					; get file name length 
93a4			 
93a4					call strlenz   
93a4			 
93a4					inc hl   ; cover zero term 
93a4					inc hl  ; stick the id at the end of the area 
93a4			 
93a4					push hl 
93a4					pop bc    ; move length to bc 
93a4			 
93a4					call malloc 
93a4			 
93a4					; TODO save malloc area to scratch 
93a4			 
93a4					ex de, hl 
93a4					ld hl, (store_tmp2) 
93a4					ld (hl), e 
93a4					inc hl 
93a4					ld (hl), d 
93a4					inc hl 
93a4					ld (store_tmp2), hl 
93a4			 
93a4					 
93a4			 
93a4					;pop hl   ; get source 
93a4			;		ex de, hl    ; swap aronund	 
93a4			 
93a4					ld hl, store_page+3 
93a4					if DEBUG_FORTH_WORDS 
93a4						DMARK "CFd" 
93a4						CALLMONITOR 
93a4					endif 
93a4					ldir 
93a4			 
93a4					; de is past string, move back one and store id 
93a4					 
93a4					dec de 
93a4			 
93a4					; store file id 
93a4			 
93a4					pop hl 
93a4					ex de,hl 
93a4					ld (hl), e 
93a4			 
93a4					if DEBUG_FORTH_WORDS 
93a4						DMARK "Cdi" 
93a4						CALLMONITOR 
93a4					endif 
93a4					 
93a4			.dirnotfound: 
93a4					pop bc     
93a4					djnz .diritem 
93a4				 
93a4			.dirdone:	 
93a4			 
93a4					ld a, 0 
93a4					ld hl, (store_tmp2) 
93a4					ld (hl), a 
93a4					inc hl 
93a4					ld (hl), a 
93a4					inc hl 
93a4					; push a count of the dir items found 
93a4			 
93a4			;		ld h, 0 
93a4			;		ld l, c 
93a4			 
93a4				ret 
93a4			 
93a4			endif 
93a4			 
93a4			 
93a4			; Settings 
93a4			; Run  
93a4			 
93a4			 
93a4			 
93a4			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
93a4			;;hd_menu2:   db "        2: Editor",0   
93a4			;hd_menu2:   db "        2: Editor       6: Menu",0   
93a4			;hd_menu3:   db "        3: Storage",0 
93a4			;hd_menu4:   db "0=quit  4: Debug",0 
93a4			;hd_don:     db "ON",0 
93a4			;hd_doff:     db "OFF",0 
93a4			; 
93a4			; 
93a4			; 
93a4			;hardware_diags_old:       
93a4			; 
93a4			;.diagmenu: 
93a4			;	call clear_display 
93a4			;	ld a, display_row_1 
93a4			;	ld de, hd_menu1 
93a4			;	call str_at_display 
93a4			; 
93a4			;	ld a, display_row_2 
93a4			;	ld de, hd_menu2 
93a4			;	call str_at_display 
93a4			; 
93a4			;	ld a, display_row_3 
93a4			;	ld de, hd_menu3 
93a4			;	call str_at_display 
93a4			; 
93a4			;	ld a,  display_row_4 
93a4			;	ld de, hd_menu4 
93a4			;	call str_at_display 
93a4			; 
93a4			;	; display debug state 
93a4			; 
93a4			;	ld de, hd_don 
93a4			;	ld a, (os_view_disable) 
93a4			;	cp 0 
93a4			;	jr z, .distog 
93a4			;	ld de, hd_doff 
93a4			;.distog: ld a, display_row_4+17 
93a4			;	call str_at_display 
93a4			; 
93a4			;	call update_display 
93a4			; 
93a4			;	call cin_wait 
93a4			; 
93a4			; 
93a4			; 
93a4			;	cp '4' 
93a4			;	jr nz, .diagn1 
93a4			; 
93a4			;	; debug toggle 
93a4			; 
93a4			;	ld a, (os_view_disable) 
93a4			;	ld b, '*' 
93a4			;	cp 0 
93a4			;	jr z, .debtog 
93a4			;	ld b, 0 
93a4			;.debtog:	 
93a4			;	ld a,b 
93a4			;	ld (os_view_disable),a 
93a4			; 
93a4			;.diagn1: cp '0' 
93a4			;	 ret z 
93a4			; 
93a4			;;	cp '1' 
93a4			;;       jp z, matrix	 
93a4			;;   TODO keyboard matrix test 
93a4			; 
93a4			;	cp '2' 
93a4			;	jp z, .diagedit 
93a4			; 
93a4			;;	cp '6' 
93a4			;;	jp z, .menutest 
93a4			;;if ENABLE_BASIC 
93a4			;;	cp '6' 
93a4			;;	jp z, basic 
93a4			;;endif 
93a4			 ; 
93a4			;	jp .diagmenu 
93a4			; 
93a4			; 
93a4			;	ret 
93a4			 
93a4			 
93a4			.debug_tog: 
93a4 21 eb 93			ld hl, .menudebug 
93a7				 
93a7 3a b8 e2			ld a, (os_view_disable) 
93aa fe 2a			cp '*' 
93ac 20 04			jr nz,.tdon  
93ae 3e 01			ld a, 1 
93b0 18 02			jr .tog1 
93b2 3e 00		.tdon: ld a, 0 
93b4			 
93b4			.tog1: 
93b4 cd e0 8a			call menu 
93b7 fe 00			cp 0 
93b9 c8				ret z 
93ba fe 01			cp 1    ; disable debug 
93bc 28 04			jr z, .dtog0 
93be 3e 2a			ld a, '*' 
93c0 18 02			jr .dtogset 
93c2 3e 00		.dtog0: ld a, 0 
93c4 32 b8 e2		.dtogset:  ld (os_view_disable), a 
93c7 c3 a4 93			jp .debug_tog 
93ca			 
93ca			 
93ca			hardware_diags:       
93ca			 
93ca			.diagm: 
93ca 21 dd 93			ld hl, .menuitems 
93cd 3e 00			ld a, 0 
93cf cd e0 8a			call menu 
93d2			 
93d2 fe 00		         cp 0 
93d4 c8				 ret z 
93d5			 
93d5 fe 02			cp 2 
93d7 ca 36 94			jp z, .diagedit 
93da			 
93da			;	cp '6' 
93da			;	jp z, .menutest 
93da			;if ENABLE_BASIC 
93da			;	cp '6' 
93da			;	jp z, basic 
93da			;endif 
93da			  
93da c3 ca 93			jp .diagm 
93dd			 
93dd				 
93dd f1 93		.menuitems:   	dw .m1 
93df fc 93				dw .m2 
93e1 03 94				dw .m3 
93e3 0b 94				dw .m5 
93e5 11 94				dw .m5a 
93e7 1a 94				dw .m5b 
93e9 00 00				dw 0 
93eb			 
93eb			.menudebug: 
93eb 23 94				dw .m6 
93ed 2c 94				dw .m7 
93ef 00 00				dw 0 
93f1			 
93f1 .. 00		.m1:   db "Key Matrix",0 
93fc .. 00		.m2:   db "Editor",0 
9403 .. 00		.m3:   db "Storage",0 
940b .. 00		.m5:   db "Sound",0 
9411 .. 00		.m5a:  db "RAM Test",0 
941a .. 00		.m5b:  db "LCD Test",0 
9423			 
9423 .. 00		.m6:   db "Debug ON",0 
942c .. 00		.m7:   db "Debug OFF",0 
9436			 
9436			; debug editor 
9436			 
9436			.diagedit: 
9436			 
9436 21 c7 e2			ld hl, scratch 
9439			;	ld bc, 250 
9439			;	ldir 
9439				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9439 3e 00			ld a, 0 
943b 77				ld (hl), a 
943c 23				inc hl 
943d 77				ld (hl), a 
943e 23				inc hl 
943f 77				ld (hl), a 
9440			 
9440 cd af 8a		        call clear_display 
9443 cd d2 8a			call update_display 
9446				;ld a, 1 
9446				;ld (hardware_diag), a 
9446			.diloop: 
9446 3e 00			ld a, display_row_1 
9448 0e 00			ld c, 0 
944a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
944c 1e 28			ld e, 40 
944e			 
944e 21 c7 e2			ld hl, scratch	 
9451 cd 09 8d			call input_str 
9454			 
9454 3e 28			ld a, display_row_2 
9456 11 c7 e2			ld de, scratch 
9459 cd c2 8a			call str_at_display 
945c cd d2 8a			call update_display 
945f			 
945f c3 46 94			jp .diloop 
9462			 
9462			 
9462			; pass word in hl 
9462			; a has display location 
9462			display_word_at: 
9462 f5				push af 
9463 e5				push hl 
9464 7c				ld a,h 
9465 21 cc e5			ld hl, os_word_scratch 
9468 cd dd 8f			call hexout 
946b e1				pop hl 
946c 7d				ld a,l 
946d 21 ce e5			ld hl, os_word_scratch+2 
9470 cd dd 8f			call hexout 
9473 21 d0 e5			ld hl, os_word_scratch+4 
9476 3e 00			ld a,0 
9478 77				ld (hl),a 
9479 11 cc e5			ld de,os_word_scratch 
947c f1				pop af 
947d cd c2 8a				call str_at_display 
9480 c9				ret 
9481			 
9481			display_ptr_state: 
9481			 
9481				; to restore afterwards 
9481			 
9481 d5				push de 
9482 c5				push bc 
9483 e5				push hl 
9484 f5				push af 
9485			 
9485				; for use in here 
9485			 
9485			;	push bc 
9485			;	push de 
9485			;	push hl 
9485			;	push af 
9485			 
9485 cd af 8a			call clear_display 
9488			 
9488 11 5b 96			ld de, .ptrstate 
948b 3e 00			ld a, display_row_1 
948d cd c2 8a			call str_at_display 
9490			 
9490				; display debug step 
9490			 
9490			 
9490 11 71 ee			ld de, debug_mark 
9493 3e 26			ld a, display_row_1+display_cols-2 
9495 cd c2 8a			call str_at_display 
9498			 
9498				; display a 
9498 11 65 96			ld de, .ptrcliptr 
949b 3e 28			ld a, display_row_2 
949d cd c2 8a			call str_at_display 
94a0			 
94a0 f1				pop af 
94a1 2a 46 ea			ld hl,(cli_ptr) 
94a4 3e 30			ld a, display_row_2+8 
94a6 cd 62 94			call display_word_at 
94a9			 
94a9			 
94a9				; display hl 
94a9			 
94a9			 
94a9 11 6d 96			ld de, .ptrclioptr 
94ac 3e 32			ld a, display_row_2+10 
94ae cd c2 8a			call str_at_display 
94b1			; 
94b1			;	pop hl 
94b1 3e 35			ld a, display_row_2+13 
94b3 2a 44 ea			ld hl,(cli_origptr) 
94b6 cd 62 94			call display_word_at 
94b9			; 
94b9			;	 
94b9			;	; display de 
94b9			 
94b9			;	ld de, .regstatede 
94b9			;	ld a, display_row_3 
94b9			;	call str_at_display 
94b9			 
94b9			;	pop de 
94b9			;	ld h,d 
94b9			;	ld l, e 
94b9			;	ld a, display_row_3+3 
94b9			;	call display_word_at 
94b9			 
94b9			 
94b9				; display bc 
94b9			 
94b9			;	ld de, .regstatebc 
94b9			;	ld a, display_row_3+10 
94b9			;	call str_at_display 
94b9			 
94b9			;	pop bc 
94b9			;	ld h,b 
94b9			;	ld l, c 
94b9			;	ld a, display_row_3+13 
94b9			;	call display_word_at 
94b9			 
94b9			 
94b9				; display dsp 
94b9			 
94b9			;	ld de, .regstatedsp 
94b9			;	ld a, display_row_4 
94b9			;	call str_at_display 
94b9			 
94b9				 
94b9			;	ld hl,(cli_data_sp) 
94b9			;	ld a, display_row_4+4 
94b9			;	call display_word_at 
94b9			 
94b9				; display rsp 
94b9			 
94b9 11 9c 96			ld de, .regstatersp 
94bc 3e 82			ld a, display_row_4+10 
94be cd c2 8a			call str_at_display 
94c1			 
94c1				 
94c1 2a f8 e9			ld hl,(cli_ret_sp) 
94c4 3e 86			ld a, display_row_4+14 
94c6 cd 62 94			call display_word_at 
94c9			 
94c9 cd d2 8a			call update_display 
94cc			 
94cc cd f2 89			call delay1s 
94cf cd f2 89			call delay1s 
94d2 cd f2 89			call delay1s 
94d5			 
94d5			 
94d5 cd f3 9a			call next_page_prompt 
94d8			 
94d8				; restore  
94d8			 
94d8 f1				pop af 
94d9 e1				pop hl 
94da c1				pop bc 
94db d1				pop de 
94dc c9				ret 
94dd			 
94dd			break_point_state: 
94dd f5				push af 
94de			 
94de				; see if disabled 
94de			 
94de 3a b8 e2			ld a, (os_view_disable) 
94e1 fe 2a			cp '*' 
94e3 20 02			jr nz, .bpsgo 
94e5 f1				pop af 
94e6 c9				ret 
94e7			 
94e7			.bpsgo: 
94e7 f1				pop af 
94e8 f5				push af 
94e9 22 b4 e2			ld (os_view_hl), hl 
94ec ed 53 b2 e2		ld (os_view_de), de 
94f0 ed 43 b0 e2		ld (os_view_bc), bc 
94f4 e5				push hl 
94f5 6f				ld l, a 
94f6 26 00			ld h, 0 
94f8 22 b6 e2			ld (os_view_af),hl 
94fb			 
94fb 21 b7 ed				ld hl, display_fb0 
94fe 22 d2 eb				ld (display_fb_active), hl 
9501 e1				pop hl	 
9502			 
9502 3e 31			ld a, '1' 
9504 fe 2a		.bps1:  cp '*' 
9506 20 03			jr nz, .bps1b 
9508 32 b8 e2			ld (os_view_disable),a 
950b fe 31		.bps1b:  cp '1' 
950d 20 14			jr nz, .bps2 
950f			 
950f				; display reg 
950f			 
950f				 
950f			 
950f 3a b6 e2			ld a, (os_view_af) 
9512 2a b4 e2			ld hl, (os_view_hl) 
9515 ed 5b b2 e2		ld de, (os_view_de) 
9519 ed 4b b0 e2		ld bc, (os_view_bc) 
951d cd b7 95			call display_reg_state 
9520 c3 a3 95			jp .bpschk 
9523			 
9523 fe 32		.bps2:  cp '2' 
9525 20 08			jr nz, .bps3 
9527				 
9527				; display hl 
9527 2a b4 e2			ld hl, (os_view_hl) 
952a cd a1 96			call display_dump_at_hl 
952d			 
952d 18 74			jr .bpschk 
952f			 
952f fe 33		.bps3:  cp '3' 
9531 20 08			jr nz, .bps4 
9533			 
9533			        ; display de 
9533 2a b2 e2			ld hl, (os_view_de) 
9536 cd a1 96			call display_dump_at_hl 
9539			 
9539 18 68			jr .bpschk 
953b fe 34		.bps4:  cp '4' 
953d 20 08			jr nz, .bps5 
953f			 
953f			        ; display bc 
953f 2a b0 e2			ld hl, (os_view_bc) 
9542 cd a1 96			call display_dump_at_hl 
9545			 
9545 18 5c			jr .bpschk 
9547 fe 35		.bps5:  cp '5' 
9549 20 08		        jr nz, .bps7 
954b			 
954b				; display cur ptr 
954b 2a 46 ea			ld hl, (cli_ptr) 
954e cd a1 96			call display_dump_at_hl 
9551			 
9551 18 50			jr .bpschk 
9553 fe 36		.bps7:  cp '6' 
9555 20 08			jr nz, .bps8b 
9557				 
9557				; display cur orig ptr 
9557 2a 44 ea			ld hl, (cli_origptr) 
955a cd a1 96			call display_dump_at_hl 
955d 18 44			jr .bpschk 
955f fe 37		.bps8b:  cp '7' 
9561 20 08			jr nz, .bps9 
9563				 
9563				; display dsp 
9563 2a f4 e9			ld hl, (cli_data_sp) 
9566 cd a1 96			call display_dump_at_hl 
9569			 
9569 18 38			jr .bpschk 
956b fe 39		.bps9:  cp '9' 
956d 20 05			jr nz, .bps8c 
956f				 
956f				; display SP 
956f			;	ld hl, sp 
956f cd a1 96			call display_dump_at_hl 
9572			 
9572 18 2f			jr .bpschk 
9574 fe 38		.bps8c:  cp '8' 
9576 20 08			jr nz, .bps8d 
9578				 
9578				; display rsp 
9578 2a f8 e9			ld hl, (cli_ret_sp) 
957b cd a1 96			call display_dump_at_hl 
957e			 
957e 18 23			jr .bpschk 
9580 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9582 20 05			jr nz, .bps8 
9584 cd c1 98			call monitor 
9587			 
9587 18 1a			jr .bpschk 
9589 fe 30		.bps8:  cp '0' 
958b 20 16			jr nz, .bpschk 
958d			 
958d 21 16 ed				ld hl, display_fb1 
9590 22 d2 eb				ld (display_fb_active), hl 
9593 cd d2 8a				call update_display 
9596			 
9596				;ld a, (os_view_af) 
9596 2a b4 e2			ld hl, (os_view_hl) 
9599 ed 5b b2 e2		ld de, (os_view_de) 
959d ed 4b b0 e2		ld bc, (os_view_bc) 
95a1 f1				pop af 
95a2 c9				ret 
95a3			 
95a3			.bpschk:   
95a3 cd f2 89			call delay1s 
95a6 3e 9f		ld a,display_row_4 + display_cols - 1 
95a8 11 f1 9a		        ld de, endprg 
95ab cd c2 8a			call str_at_display 
95ae cd d2 8a			call update_display 
95b1 cd 68 e3			call cin_wait 
95b4			 
95b4 c3 04 95			jp .bps1 
95b7			 
95b7			 
95b7			display_reg_state: 
95b7			 
95b7				; to restore afterwards 
95b7			 
95b7 d5				push de 
95b8 c5				push bc 
95b9 e5				push hl 
95ba f5				push af 
95bb			 
95bb				; for use in here 
95bb			 
95bb c5				push bc 
95bc d5				push de 
95bd e5				push hl 
95be f5				push af 
95bf			 
95bf cd af 8a			call clear_display 
95c2			 
95c2 11 77 96			ld de, .regstate 
95c5 3e 00			ld a, display_row_1 
95c7 cd c2 8a			call str_at_display 
95ca			 
95ca				; display debug step 
95ca			 
95ca			 
95ca 11 71 ee			ld de, debug_mark 
95cd 3e 25			ld a, display_row_1+display_cols-3 
95cf cd c2 8a			call str_at_display 
95d2			 
95d2				; display a 
95d2 11 93 96			ld de, .regstatea 
95d5 3e 28			ld a, display_row_2 
95d7 cd c2 8a			call str_at_display 
95da			 
95da e1				pop hl 
95db			;	ld h,0 
95db			;	ld l, a 
95db 3e 2b			ld a, display_row_2+3 
95dd cd 62 94			call display_word_at 
95e0			 
95e0			 
95e0				; display hl 
95e0			 
95e0			 
95e0 11 87 96			ld de, .regstatehl 
95e3 3e 32			ld a, display_row_2+10 
95e5 cd c2 8a			call str_at_display 
95e8			 
95e8 e1				pop hl 
95e9 3e 35			ld a, display_row_2+13 
95eb cd 62 94			call display_word_at 
95ee			 
95ee				 
95ee				; display de 
95ee			 
95ee 11 8b 96			ld de, .regstatede 
95f1 3e 50			ld a, display_row_3 
95f3 cd c2 8a			call str_at_display 
95f6			 
95f6 e1				pop hl 
95f7			;	ld h,d 
95f7			;	ld l, e 
95f7 3e 53			ld a, display_row_3+3 
95f9 cd 62 94			call display_word_at 
95fc			 
95fc			 
95fc				; display bc 
95fc			 
95fc 11 8f 96			ld de, .regstatebc 
95ff 3e 5a			ld a, display_row_3+10 
9601 cd c2 8a			call str_at_display 
9604			 
9604 e1				pop hl 
9605			;	ld h,b 
9605			;	ld l, c 
9605 3e 5d			ld a, display_row_3+13 
9607 cd 62 94			call display_word_at 
960a			 
960a			 
960a				; display dsp 
960a			 
960a 11 97 96			ld de, .regstatedsp 
960d 3e 78			ld a, display_row_4 
960f cd c2 8a			call str_at_display 
9612			 
9612				 
9612 2a f4 e9			ld hl,(cli_data_sp) 
9615 3e 7c			ld a, display_row_4+4 
9617 cd 62 94			call display_word_at 
961a			 
961a				; display rsp 
961a			 
961a 11 9c 96			ld de, .regstatersp 
961d 3e 82			ld a, display_row_4+10 
961f cd c2 8a			call str_at_display 
9622			 
9622				 
9622 2a f8 e9			ld hl,(cli_ret_sp) 
9625 3e 86			ld a, display_row_4+14 
9627 cd 62 94			call display_word_at 
962a			 
962a cd d2 8a			call update_display 
962d			 
962d			;	call delay1s 
962d			;	call delay1s 
962d			;	call delay1s 
962d			 
962d			 
962d			;	call next_page_prompt 
962d			 
962d				; restore  
962d			 
962d f1				pop af 
962e e1				pop hl 
962f c1				pop bc 
9630 d1				pop de 
9631 c9				ret 
9632			 
9632 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9646 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
965b .. 00		.ptrstate:	db "Ptr State",0 
9665 .. 00		.ptrcliptr:     db "cli_ptr",0 
966d .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9677 .. 00		.regstate:	db "Reg State (1/0)",0 
9687 .. 00		.regstatehl:	db "HL:",0 
968b .. 00		.regstatede:	db "DE:",0 
968f .. 00		.regstatebc:	db "BC:",0 
9693 .. 00		.regstatea:	db "A :",0 
9697 .. 00		.regstatedsp:	db "DSP:",0 
969c .. 00		.regstatersp:	db "RSP:",0 
96a1			 
96a1			display_dump_at_hl: 
96a1 e5				push hl 
96a2 d5				push de 
96a3 c5				push bc 
96a4 f5				push af 
96a5			 
96a5 22 ea e5			ld (os_cur_ptr),hl	 
96a8 cd af 8a			call clear_display 
96ab cd fb 99			call dumpcont 
96ae			;	call delay1s 
96ae			;	call next_page_prompt 
96ae			 
96ae			 
96ae f1				pop af 
96af c1				pop bc 
96b0 d1				pop de 
96b1 e1				pop hl 
96b2 c9				ret 
96b3			 
96b3			;if ENABLE_BASIC 
96b3			;	include "nascombasic.asm" 
96b3			;	basic: 
96b3			;	include "forth/FORTH.ASM" 
96b3			;endif 
96b3			 
96b3			; eof 
96b3			 
96b3			 
# End of file firmware_diags.asm
96b3			  
96b3			include "firmware_prompts.asm"  
96b3			; Prompts  
96b3			 
96b3			; boot messages 
96b3			 
96b3 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
96c8 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
96d8			 
96d8			 
96d8			; config menus 
96d8			 
96d8 .. 00		prom_c3: db "Add Dictionary To File",0 
96ef			 
96ef			if STARTUP_V1 
96ef .. 00		prom_c2: db "Select Autoload File",0 
9704 .. 00		prom_c2a: db "Disable Autoload File", 0 
971a			endif 
971a			 
971a			if STARTUP_V2 
971a			prom_c2: db "Enable Autoload Files",0 
971a			prom_c2a: db "Disable Autoload Files", 0 
971a			 
971a			crs_s1: db "*ls-word", 0 
971a			crs_s2: db "*ed-word", 0 
971a			crs_s3: db "*Demo-Programs", 0 
971a			crs_s4: db "*Utils", 0 
971a			crs_s5: db "*SPI-Addons", 0 
971a			crs_s6: db "*Key-constants", 0 
971a			 
971a			 
971a			 
971a			endif 
971a .. 00		prom_c2b: db "Select Storage Bank",0 
972e .. 00		prom_c4: db "Settings",0 
9737 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9752 .. 00		prom_m4b:   db "Monitor",0 
975a .. 00		prom_c1: db "Hardware Diags",0 
9769			 
9769			 
9769			if STARTUP_V2 
9769			prom_c9: db "Create Startup Files",0 
9769			endif 
9769			 
9769 .. 00		prom_notav:    db "Feature not available",0 
977f .. 00		prom_empty:    db "",0 
9780			 
9780			; eof 
9780			 
# End of file firmware_prompts.asm
9780			  
9780			  
9780			; eof  
9780			  
# End of file firmware.asm
9780			 
9780			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9780			;if BASE_KEV  
9780			;baseram: equ 08000h 
9780			;endif 
9780			 
9780			;if BASE_SC114 
9780			;baseram:     equ    endofcode 
9780			;endif 
9780			 
9780			 
9780			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
9780			 
9780			; start system 
9780			 
9780			coldstart: 
9780				; set sp 
9780				; di/ei 
9780			 
9780 f3				di 
9781 31 00 f0			ld sp, tos 
9784			;	ei 
9784			 
9784				; init spinner 
9784 3e 00			ld a,0 
9786 32 cc eb			ld (display_active), a 
9789			 
9789				; disable breakpoint by default 
9789			 
9789 3e 2a			ld a,'*' 
978b 32 b8 e2			ld (os_view_disable),a 
978e			 
978e				; init hardware 
978e			 
978e				; init keyboard and screen hardware 
978e			 
978e cd 1c 80			call hardware_init 
9791			 
9791			 
9791 cd f2 89			call delay1s 
9794 3e 58			ld a, display_row_3+8 
9796 11 03 80			ld de, buildtime 
9799 cd c2 8a			call str_at_display 
979c cd d2 8a			call update_display 
979f			 
979f cd f2 89			call delay1s 
97a2 cd f2 89			call delay1s 
97a5 cd f2 89			call delay1s 
97a8			 
97a8				; detect if any keys are held down to enable breakpoints at start up 
97a8			 
97a8 cd 6e e3			call cin  
97ab fe 00			cp 0 
97ad 28 03			jr z, .nokeys 
97af			 
97af				;call hardware_diags 
97af cd 3c 93			call config 
97b2			 
97b2			;	ld de, .bpen 
97b2			;	ld a, display_row_4 
97b2			;	call str_at_display 
97b2			;	call update_display 
97b2			; 
97b2			;	ld a,0 
97b2			;	ld (os_view_disable),a 
97b2			; 
97b2			;.bpwait: 
97b2			;	call cin 
97b2			;	cp 0 
97b2			;	jr z, .bpwait 
97b2			;	jr .nokeys 
97b2			; 
97b2			; 
97b2			;.bpen:  db "Break points enabled!",0 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			.nokeys: 
97b2			 
97b2			 
97b2				 
97b2			 
97b2			;jp  testkey 
97b2			 
97b2			;call storage_get_block_0 
97b2			; 
97b2			;ld hl, 0 
97b2			;ld de, store_page 
97b2			;call storage_read_block 
97b2			 
97b2				 
97b2			;ld hl, 10 
97b2			;ld de, store_page 
97b2			;call storage_read_block 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			;stop:	nop 
97b2			;	jp stop 
97b2			 
97b2			 
97b2			 
97b2			main: 
97b2 cd af 8a			call clear_display 
97b5 cd d2 8a			call update_display 
97b8			 
97b8			 
97b8			 
97b8			;	call testlcd 
97b8			 
97b8			 
97b8			 
97b8 cd f8 9e			call forth_init 
97bb			 
97bb			 
97bb			warmstart: 
97bb cd ce 9e			call forth_warmstart 
97be			 
97be				; run startup word load 
97be			        ; TODO prevent this running at warmstart after crash  
97be			 
97be				if STARTUP_ENABLE 
97be			 
97be					if STARTUP_V1 
97be			 
97be						if STORAGE_SE 
97be							call forth_autoload 
97be						endif 
97be cd 15 e2					call forth_startup 
97c1					endif 
97c1			 
97c1					if STARTUP_V2 
97c1			 
97c1						if STORAGE_SE 
97c1							call forth_autoload 
97c1						else 
97c1							call forth_startup 
97c1						endif 
97c1			 
97c1			 
97c1					endif 
97c1			 
97c1				endif 
97c1			 
97c1				; show free memory after boot 
97c1 11 5b 98			ld de, freeram 
97c4 3e 00			ld a, display_row_1 
97c6 cd c2 8a			call str_at_display 
97c9			 
97c9			; Or use heap_size word???? 
97c9 21 ad e2			ld hl, heap_end 
97cc 11 8c e3			ld de, heap_start 
97cf ed 52			sbc hl, de 
97d1 e5				push hl 
97d2 7c				ld a,h	         	 
97d3 21 cc e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
97d6 cd dd 8f			call hexout 
97d9 e1			   	pop hl 
97da			 
97da 7d				ld a,l 
97db 21 ce e5			ld hl, os_word_scratch+2 
97de cd dd 8f			call hexout 
97e1 21 d0 e5			ld hl, os_word_scratch+4 
97e4 3e 00			ld a, 0 
97e6 77				ld (hl),a 
97e7 11 cc e5			ld de, os_word_scratch 
97ea 3e 0d			ld a, display_row_1 + 13 
97ec cd c2 8a			call str_at_display 
97ef cd d2 8a			call update_display 
97f2			 
97f2			 
97f2				;call demo 
97f2			 
97f2			 
97f2				; init scratch input area for cli commands 
97f2			 
97f2 21 ee e5			ld hl, os_cli_cmd 
97f5 3e 00			ld a,0 
97f7 77				ld (hl),a 
97f8 23				inc hl 
97f9 77				ld (hl),a 
97fa			 
97fa 3e 00			ld a,0 
97fc 32 ed e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97ff			 
97ff 32 ea e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
9802 32 eb e5			ld (os_cur_ptr+1),a	 
9805			 
9805 32 cc e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
9808 32 cd e5			ld (os_word_scratch+1),a	 
980b				 
980b			 
980b				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
980b 21 ee e5			ld hl, os_cli_cmd 
980e			 
980e 3e 00			ld a, 0		 ; init cli input 
9810 77				ld (hl), a 
9811 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9813			cli: 
9813				; show cli prompt 
9813				;push af 
9813				;ld a, 0 
9813				;ld de, prompt 
9813				;call str_at_display 
9813			 
9813				;call update_display 
9813				;pop af 
9813				;inc a 
9813				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9813 0e 00			ld c, 0 
9815 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9817 1e 28			ld e, 40 
9819			 
9819 21 ee e5			ld hl, os_cli_cmd 
981c			 
981c				STACKFRAME OFF $fefe $9f9f 
981c				if DEBUG_STACK_IMB 
981c					if OFF 
981c						exx 
981c						ld de, $fefe 
981c						ld a, d 
981c						ld hl, curframe 
981c						call hexout 
981c						ld a, e 
981c						ld hl, curframe+2 
981c						call hexout 
981c						ld hl, $fefe 
981c						push hl 
981c						ld hl, $9f9f 
981c						push hl 
981c						exx 
981c					endif 
981c				endif 
981c			endm 
# End of macro STACKFRAME
981c			 
981c cd 09 8d			call input_str 
981f			 
981f				STACKFRAMECHK OFF $fefe $9f9f 
981f				if DEBUG_STACK_IMB 
981f					if OFF 
981f						exx 
981f						ld hl, $9f9f 
981f						pop de   ; $9f9f 
981f						call cmp16 
981f						jr nz, .spnosame 
981f						ld hl, $fefe 
981f						pop de   ; $fefe 
981f						call cmp16 
981f						jr z, .spfrsame 
981f						.spnosame: call showsperror 
981f						.spfrsame: nop 
981f						exx 
981f					endif 
981f				endif 
981f			endm 
# End of macro STACKFRAMECHK
981f			 
981f				; copy input to last command 
981f			 
981f 21 ee e5			ld hl, os_cli_cmd 
9822 11 ed e6			ld de, os_last_cmd 
9825 01 ff 00			ld bc, 255 
9828 ed b0			ldir 
982a			 
982a				; wipe current buffer 
982a			 
982a			;	ld a, 0 
982a			;	ld hl, os_cli_cmd 
982a			;	ld de, os_cli_cmd+1 
982a			;	ld bc, 254 
982a			;	ldir 
982a				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
982a			;	call strcpy 
982a			;	ld a, 0 
982a			;	ld (hl), a 
982a			;	inc hl 
982a			;	ld (hl), a 
982a			;	inc hl 
982a			;	ld (hl), a 
982a			 
982a				; switch frame buffer to program  
982a			 
982a 21 16 ed				ld hl, display_fb1 
982d 22 d2 eb				ld (display_fb_active), hl 
9830			 
9830			;	nop 
9830				STACKFRAME ON $fbfe $8f9f 
9830				if DEBUG_STACK_IMB 
9830					if ON 
9830						exx 
9830						ld de, $fbfe 
9830						ld a, d 
9830						ld hl, curframe 
9830						call hexout 
9830						ld a, e 
9830						ld hl, curframe+2 
9830						call hexout 
9830						ld hl, $fbfe 
9830						push hl 
9830						ld hl, $8f9f 
9830						push hl 
9830						exx 
9830					endif 
9830				endif 
9830			endm 
# End of macro STACKFRAME
9830				; first time into the parser so pass over the current scratch pad 
9830 21 ee e5			ld hl,os_cli_cmd 
9833				; tokenise the entered statement(s) in HL 
9833 cd 76 9f			call forthparse 
9836			        ; exec forth statements in top of return stack 
9836 cd b6 9f			call forthexec 
9839				;call forthexec_cleanup 
9839			;	call parsenext 
9839			 
9839				STACKFRAMECHK ON $fbfe $8f9f 
9839				if DEBUG_STACK_IMB 
9839					if ON 
9839						exx 
9839						ld hl, $8f9f 
9839						pop de   ; $8f9f 
9839						call cmp16 
9839						jr nz, .spnosame 
9839						ld hl, $fbfe 
9839						pop de   ; $fbfe 
9839						call cmp16 
9839						jr z, .spfrsame 
9839						.spnosame: call showsperror 
9839						.spfrsame: nop 
9839						exx 
9839					endif 
9839				endif 
9839			endm 
# End of macro STACKFRAMECHK
9839				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9839			 
9839 3e 78			ld a, display_row_4 
983b 11 6d 98			ld de, endprog 
983e			 
983e cd d2 8a			call update_display		 
9841			 
9841 cd f3 9a			call next_page_prompt 
9844			 
9844				; switch frame buffer to cli 
9844			 
9844 21 b7 ed				ld hl, display_fb0 
9847 22 d2 eb				ld (display_fb_active), hl 
984a			 
984a			 
984a cd af 8a		        call clear_display 
984d cd d2 8a			call update_display		 
9850			 
9850 21 ee e5			ld hl, os_cli_cmd 
9853			 
9853 3e 00			ld a, 0		 ; init cli input 
9855 77				ld (hl), a 
9856			 
9856				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9856			 
9856				; now on last line 
9856			 
9856				; TODO scroll screen up 
9856			 
9856				; TODO instead just clear screen and place at top of screen 
9856			 
9856			;	ld a, 0 
9856			;	ld (f_cursor_ptr),a 
9856			 
9856				;call clear_display 
9856				;call update_display 
9856			 
9856				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9856 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9858 c3 13 98			jp cli 
985b			 
985b .. 00		freeram: db "Free bytes: $",0 
9869 ..			asc: db "1A2F" 
986d .. 00		endprog: db "End prog...",0 
9879			 
9879			testenter2:   
9879 21 f9 e2			ld hl,scratch+50 
987c 22 ea e5			ld (os_cur_ptr),hl 
987f c3 13 98			jp cli 
9882			 
9882			testenter:  
9882			 
9882 21 69 98			ld hl,asc 
9885			;	ld a,(hl) 
9885			;	call nibble2val 
9885 cd 33 90			call get_byte 
9888			 
9888			 
9888			;	ld a,(hl) 
9888			;	call atohex 
9888			 
9888			;	call fourehexhl 
9888 32 f9 e2			ld (scratch+50),a 
988b			 
988b			 
988b			 
988b 21 6b 98			ld hl,asc+2 
988e			;	ld a, (hl) 
988e			;	call nibble2val 
988e cd 33 90			call get_byte 
9891			 
9891			;	call fourehexhl 
9891 32 fb e2			ld (scratch+52),a 
9894				 
9894 21 f9 e2			ld hl,scratch+50 
9897 22 ea e5			ld (os_cur_ptr),hl 
989a c3 13 98			jp cli 
989d			 
989d			enter:	 
989d 3a cb e2			ld a,(scratch+4) 
98a0 fe 00			cp 0 
98a2 28 0c			jr z, .entercont 
98a4				; no, not a null term line so has an address to work out.... 
98a4			 
98a4 21 c9 e2			ld hl,scratch+2 
98a7 cd 93 90			call get_word_hl 
98aa			 
98aa 22 ea e5			ld (os_cur_ptr),hl	 
98ad c3 13 98			jp cli 
98b0			 
98b0			 
98b0			.entercont:  
98b0			 
98b0 21 c9 e2			ld hl, scratch+2 
98b3 cd 33 90			call get_byte 
98b6			 
98b6 2a ea e5		   	ld hl,(os_cur_ptr) 
98b9 77					ld (hl),a 
98ba 23					inc hl 
98bb 22 ea e5				ld (os_cur_ptr),hl 
98be				 
98be			; get byte  
98be			 
98be			 
98be c3 13 98			jp cli 
98c1			 
98c1			 
98c1			; basic monitor support 
98c1			 
98c1			monitor: 
98c1				;  
98c1 cd af 8a			call clear_display 
98c4 3e 00			ld a, 0 
98c6 11 15 99			ld de, .monprompt 
98c9 cd c2 8a			call str_at_display 
98cc cd d2 8a			call update_display 
98cf			 
98cf				; get a monitor command 
98cf			 
98cf 0e 00			ld c, 0     ; entry at top left 
98d1 16 64			ld d, 100   ; max buffer size 
98d3 1e 0f			ld e, 15    ; input scroll area 
98d5 3e 00			ld a, 0     ; init string 
98d7 21 c5 e4			ld hl, os_input 
98da 77				ld (hl), a 
98db 23				inc hl 
98dc 77				ld (hl), a 
98dd 21 c5 e4			ld hl, os_input 
98e0 3e 01			ld a, 1     ; init string 
98e2 cd 09 8d			call input_str 
98e5			 
98e5 cd af 8a		        call clear_display 
98e8 cd d2 8a			call update_display		 
98eb			 
98eb 3a c5 e4			ld a, (os_input) 
98ee cd 31 91			call toUpper 
98f1 fe 48		        cp 'H' 
98f3 ca 7a 99		        jp z, .monhelp 
98f6 fe 44			cp 'D'		; dump 
98f8 ca ad 99			jp z, .mondump	 
98fb fe 43			cp 'C'		; dump 
98fd ca c7 99			jp z, .moncdump	 
9900 fe 4d			cp 'M'		; dump 
9902 ca 17 99			jp z, .moneditstart 
9905 fe 55			cp 'U'		; dump 
9907 ca 23 99			jp z, .monedit	 
990a fe 47			cp 'G'		; dump 
990c ca a3 99			jp z, .monjump 
990f fe 51			cp 'Q'		; dump 
9911 c8				ret z	 
9912			 
9912			 
9912				; TODO "S" to access symbol by name and not need the address 
9912				; TODO "F" to find a string in memory 
9912			 
9912 c3 c1 98			jp monitor 
9915			 
9915 .. 00		.monprompt: db ">", 0 
9917			 
9917			.moneditstart: 
9917				; get starting address 
9917			 
9917 21 c7 e4			ld hl,os_input+2 
991a cd 93 90			call get_word_hl 
991d			 
991d 22 ea e5			ld (os_cur_ptr),hl	 
9920			 
9920 c3 c1 98			jp monitor 
9923			 
9923			.monedit: 
9923				; get byte to load 
9923			 
9923 21 c7 e4			ld hl,os_input+2 
9926 cd 33 90			call get_byte 
9929			 
9929				; get address to update 
9929 2a ea e5			ld hl, (os_cur_ptr) 
992c			 
992c				; update byte 
992c			 
992c 77				ld (hl), a 
992d			 
992d				; move to next address and save it 
992d			 
992d 23				inc hl 
992e 22 ea e5			ld (os_cur_ptr),hl	 
9931			 
9931 c3 c1 98			jp monitor 
9934			 
9934			 
9934 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9948 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9964 .. 00		.monhelptext3:  db "G-Call address",0 
9973 .. 00		.monhelptext4:  db "Q-Quit",0 
997a			        
997a			.monhelp: 
997a 3e 00			ld a, display_row_1 
997c 11 34 99		        ld de, .monhelptext1 
997f			 
997f cd c2 8a			call str_at_display 
9982 3e 28			ld a, display_row_2 
9984 11 48 99		        ld de, .monhelptext2 
9987					 
9987 cd c2 8a			call str_at_display 
998a 3e 50			ld a, display_row_3 
998c 11 64 99		        ld de, .monhelptext3 
998f					 
998f cd c2 8a			call str_at_display 
9992 3e 78			ld a, display_row_4 
9994 11 73 99		        ld de, .monhelptext4 
9997 cd c2 8a			call str_at_display 
999a			 
999a cd d2 8a			call update_display		 
999d			 
999d cd f3 9a			call next_page_prompt 
99a0 c3 c1 98			jp monitor 
99a3			 
99a3			.monjump:    
99a3 21 c7 e4			ld hl,os_input+2 
99a6 cd 93 90			call get_word_hl 
99a9			 
99a9 e9				jp (hl) 
99aa c3 c1 98			jp monitor 
99ad			 
99ad			.mondump:    
99ad 21 c7 e4			ld hl,os_input+2 
99b0 cd 93 90			call get_word_hl 
99b3			 
99b3 22 ea e5			ld (os_cur_ptr),hl	 
99b6 cd fb 99			call dumpcont 
99b9 3e 78			ld a, display_row_4 
99bb 11 6d 98			ld de, endprog 
99be			 
99be cd d2 8a			call update_display		 
99c1			 
99c1 cd f3 9a			call next_page_prompt 
99c4 c3 c1 98			jp monitor 
99c7			.moncdump: 
99c7 cd fb 99			call dumpcont 
99ca 3e 78			ld a, display_row_4 
99cc 11 6d 98			ld de, endprog 
99cf			 
99cf cd d2 8a			call update_display		 
99d2			 
99d2 cd f3 9a			call next_page_prompt 
99d5 c3 c1 98			jp monitor 
99d8			 
99d8			 
99d8			; TODO symbol access  
99d8			 
99d8			.symbols:     ;; A list of symbols that can be called up  
99d8 b7 ed			dw display_fb0 
99da .. 00			db "fb0",0  
99de 80 ea		     	dw store_page 
99e0 .. 00			db "store_page",0 
99eb			 
99eb			 
99eb			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
99eb			 
99eb 3a c8 e2			ld a,(scratch+1) 
99ee fe 00			cp 0 
99f0 28 09			jr z, dumpcont 
99f2			 
99f2				; no, not a null term line so has an address to work out.... 
99f2			 
99f2 21 c9 e2			ld hl,scratch+2 
99f5 cd 93 90			call get_word_hl 
99f8			 
99f8 22 ea e5			ld (os_cur_ptr),hl	 
99fb			 
99fb			 
99fb			 
99fb			dumpcont: 
99fb			 
99fb				; dump bytes at ptr 
99fb			 
99fb			 
99fb 3e 00			ld a, display_row_1 
99fd 2a d2 eb			ld hl, (display_fb_active) 
9a00 cd dc 8c			call addatohl 
9a03 cd 2b 9a			call .dumpbyterow 
9a06			 
9a06 3e 28			ld a, display_row_2 
9a08 2a d2 eb			ld hl, (display_fb_active) 
9a0b cd dc 8c			call addatohl 
9a0e cd 2b 9a			call .dumpbyterow 
9a11			 
9a11			 
9a11 3e 50			ld a, display_row_3 
9a13 2a d2 eb			ld hl, (display_fb_active) 
9a16 cd dc 8c			call addatohl 
9a19 cd 2b 9a			call .dumpbyterow 
9a1c			 
9a1c 3e 78			ld a, display_row_4 
9a1e 2a d2 eb			ld hl, (display_fb_active) 
9a21 cd dc 8c			call addatohl 
9a24 cd 2b 9a			call .dumpbyterow 
9a27			 
9a27 cd d2 8a			call update_display 
9a2a			;		jp cli 
9a2a c9				ret 
9a2b			 
9a2b			.dumpbyterow: 
9a2b			 
9a2b				;push af 
9a2b			 
9a2b e5				push hl 
9a2c			 
9a2c				; calc where to poke the ascii 
9a2c			if display_cols == 20 
9a2c				ld a, 16 
9a2c			else 
9a2c 3e 1f			ld a, 31 
9a2e			endif 
9a2e			 
9a2e cd dc 8c			call addatohl 
9a31 22 cc e5			ld (os_word_scratch),hl  		; save pos for later 
9a34			 
9a34			 
9a34			; display decoding address 
9a34 2a ea e5		   	ld hl,(os_cur_ptr) 
9a37			 
9a37 7c				ld a,h 
9a38 e1				pop hl 
9a39 e5				push hl 
9a3a			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9a3a cd dd 8f			call hexout 
9a3d 2a ea e5		   	ld hl,(os_cur_ptr) 
9a40			 
9a40 7d				ld a,l 
9a41 e1				pop hl 
9a42 23				inc hl 
9a43 23				inc hl 
9a44 e5				push hl 
9a45			;	ld hl, os_word_scratch+2 
9a45 cd dd 8f			call hexout 
9a48 e1				pop hl 
9a49 23				inc hl 
9a4a 23				inc hl 
9a4b				;ld hl, os_word_scratch+4 
9a4b 3e 3a			ld a, ':' 
9a4d 77				ld (hl),a 
9a4e 23				inc hl 
9a4f				;ld a, 0 
9a4f				;ld (hl),a 
9a4f				;ld de, os_word_scratch 
9a4f				;pop af 
9a4f				;push af 
9a4f			;		ld a, display_row_2 
9a4f			;		call str_at_display 
9a4f			;		call update_display 
9a4f			 
9a4f			 
9a4f			;pop af 
9a4f			;	add 5 
9a4f			 
9a4f			if display_cols == 20 
9a4f				ld b, 4 
9a4f			else 
9a4f 06 08			ld b, 8 
9a51			endif	 
9a51			 
9a51			.dumpbyte: 
9a51 c5				push bc 
9a52 e5				push hl 
9a53			 
9a53			 
9a53 2a ea e5		   	ld hl,(os_cur_ptr) 
9a56 7e					ld a,(hl) 
9a57			 
9a57					; poke the ascii to display 
9a57 2a cc e5				ld hl,(os_word_scratch) 
9a5a 77					ld (hl),a 
9a5b 23					inc hl 
9a5c 22 cc e5				ld (os_word_scratch),hl 
9a5f			 
9a5f					 
9a5f			 
9a5f			 
9a5f e1					pop hl 
9a60 e5					push hl 
9a61			 
9a61 cd dd 8f				call hexout 
9a64			 
9a64					 
9a64 2a ea e5		   	ld hl,(os_cur_ptr) 
9a67 23				inc hl 
9a68 22 ea e5		   	ld (os_cur_ptr),hl 
9a6b			 
9a6b e1					pop hl 
9a6c 23					inc hl 
9a6d 23					inc hl 
9a6e 23					inc hl 
9a6f			 
9a6f			 
9a6f			 
9a6f					;ld a,0 
9a6f					;ld (os_word_scratch+2),a 
9a6f					;pop af 
9a6f					;push af 
9a6f			 
9a6f					;ld de, os_word_scratch 
9a6f					;call str_at_display 
9a6f			;		call update_display 
9a6f			;		pop af 
9a6f c1					pop bc 
9a70 c6 03				add 3 
9a72 10 dd			djnz .dumpbyte 
9a74			 
9a74				 
9a74			 
9a74 c9				ret 
9a75			 
9a75			jump:	 
9a75			 
9a75 21 c9 e2			ld hl,scratch+2 
9a78 cd 93 90			call get_word_hl 
9a7b				;ld hl,(scratch+2) 
9a7b				;call fourehexhl 
9a7b			 
9a7b 22 ea e5			ld (os_cur_ptr),hl	 
9a7e			 
9a7e e9				jp (hl) 
9a7f			 
9a7f			 
9a7f			 
9a7f			; TODO implement a basic monitor mode to start with 
9a7f			 
9a7f			 
9a7f			 
9a7f			 
9a7f			 
9a7f			 
9a7f			 
9a7f			 
9a7f			 
9a7f			; testing and demo code during development 
9a7f			 
9a7f			 
9a7f .. 00		str1: db "Enter some text...",0 
9a92 .. 00		clear: db "                    ",0 
9aa7			 
9aa7			demo: 
9aa7			 
9aa7			 
9aa7			 
9aa7			;	call update_display 
9aa7			 
9aa7				; init scratch input area for testing 
9aa7 21 c7 e2			ld hl, scratch	 
9aaa 3e 00			ld a,0 
9aac 77				ld (hl),a 
9aad			 
9aad			 
9aad 3e 28		            LD   A, display_row_2 
9aaf			;            CALL fLCD_Pos       ;Position cursor to location in A 
9aaf 11 7f 9a		            LD   DE, str1 
9ab2 cd c2 8a			call str_at_display 
9ab5			 
9ab5			;            CALL fLCD_Str       ;Display string pointed to by DE 
9ab5			cloop:	 
9ab5 3e 50		            LD   A, display_row_3 
9ab7			;            CALL fLCD_Pos       ;Position cursor to location in A 
9ab7 11 92 9a		            LD   DE, clear 
9aba			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9aba cd c2 8a				call str_at_display 
9abd 3e 78			ld a, display_row_4 
9abf 11 ef 9a			ld de, prompt 
9ac2			 
9ac2 cd c2 8a				call str_at_display 
9ac5 cd d2 8a			call update_display 
9ac8			 
9ac8 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9aca 16 0a			ld d, 10 
9acc 21 c7 e2			ld hl, scratch	 
9acf cd 09 8d			call input_str 
9ad2			 
9ad2			;	call clear_display 
9ad2			;'	call update_display 
9ad2			 
9ad2 3e 00		            LD   A, display_row_1 
9ad4			;            CALL fLCD_Pos       ;Position cursor to location in A 
9ad4 11 92 9a		            LD   DE, clear 
9ad7 cd c2 8a				call str_at_display 
9ada			;            CALL fLCD_Str       ;Display string pointed to by DE 
9ada 3e 00		            LD   A, display_row_1 
9adc			;            CALL fLCD_Pos       ;Position cursor to location in A 
9adc 11 c7 e2		            LD   DE, scratch 
9adf			;            CALL fLCD_Str       ;Display string pointed to by DE 
9adf cd c2 8a				call str_at_display 
9ae2 cd d2 8a			call update_display 
9ae5			 
9ae5 3e 00				ld a,0 
9ae7 21 c7 e2			ld hl, scratch 
9aea 77				ld (hl),a 
9aeb			 
9aeb 00				nop 
9aec c3 b5 9a			jp cloop 
9aef			 
9aef			 
9aef			 
9aef			; OS Prompt 
9aef			 
9aef .. 00		prompt: db ">",0 
9af1 .. 00		endprg: db "?",0 
9af3			 
9af3			 
9af3			; handy next page prompt 
9af3			next_page_prompt: 
9af3 e5				push hl 
9af4 d5				push de 
9af5 f5				push af 
9af6 c5				push bc 
9af7			 
9af7 3e 9f			ld a,display_row_4 + display_cols - 1 
9af9 11 f1 9a		        ld de, endprg 
9afc cd c2 8a			call str_at_display 
9aff cd d2 8a			call update_display 
9b02 cd 68 e3			call cin_wait 
9b05 c1				pop bc 
9b06 f1				pop af 
9b07 d1				pop de 
9b08 e1				pop hl 
9b09			 
9b09			 
9b09 c9				ret 
9b0a			 
9b0a			 
9b0a			; forth parser 
9b0a			 
9b0a			; My forth kernel 
9b0a			include "forth_kernel.asm" 
9b0a			; 
9b0a			; kernel to the forth OS 
9b0a			 
9b0a			DS_TYPE_STR: equ 1     ; string type 
9b0a			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9b0a			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9b0a			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9b0a			 
9b0a			FORTH_PARSEV1: equ 0 
9b0a			FORTH_PARSEV2: equ 0 
9b0a			FORTH_PARSEV3: equ 0 
9b0a			FORTH_PARSEV4: equ 0 
9b0a			FORTH_PARSEV5: equ 1 
9b0a			 
9b0a			;if FORTH_PARSEV5 
9b0a			;	FORTH_END_BUFFER: equ 0 
9b0a			;else 
9b0a			FORTH_END_BUFFER: equ 127 
9b0a			;endif 
9b0a			 
9b0a			FORTH_TRUE: equ 1 
9b0a			FORTH_FALSE: equ 0 
9b0a			 
9b0a			if FORTH_PARSEV4 
9b0a			include "forth_stackops.asm" 
9b0a			endif 
9b0a			 
9b0a			if FORTH_PARSEV5 
9b0a			include "forth_stackopsv5.asm" 
9b0a			 
9b0a			; Stack operations for v5 parser on wards 
9b0a			; * DATA stack 
9b0a			; * LOOP stack 
9b0a			; * RETURN stack 
9b0a			 
9b0a			 
9b0a			 
9b0a			FORTH_CHK_DSP_UNDER: macro 
9b0a				push hl 
9b0a				push de 
9b0a				ld hl,(cli_data_sp) 
9b0a				ld de, cli_data_stack 
9b0a				call cmp16 
9b0a				jp c, fault_dsp_under 
9b0a				pop de 
9b0a				pop hl 
9b0a				endm 
9b0a			 
9b0a			 
9b0a			FORTH_CHK_RSP_UNDER: macro 
9b0a				push hl 
9b0a				push de 
9b0a				ld hl,(cli_ret_sp) 
9b0a				ld de, cli_ret_stack 
9b0a				call cmp16 
9b0a				jp c, fault_rsp_under 
9b0a				pop de 
9b0a				pop hl 
9b0a				endm 
9b0a			 
9b0a			FORTH_CHK_LOOP_UNDER: macro 
9b0a				push hl 
9b0a				push de 
9b0a				ld hl,(cli_loop_sp) 
9b0a				ld de, cli_loop_stack 
9b0a				call cmp16 
9b0a				jp c, fault_loop_under 
9b0a				pop de 
9b0a				pop hl 
9b0a				endm 
9b0a			 
9b0a			FORTH_ERR_TOS_NOTSTR: macro 
9b0a				; TOSO might need more for checks when used 
9b0a				push af 
9b0a				ld a,(hl) 
9b0a				cp DS_TYPE_STR 
9b0a				jp nz, type_faultn   
9b0a				pop af 
9b0a				endm 
9b0a			 
9b0a			FORTH_ERR_TOS_NOTNUM: macro 
9b0a				push af 
9b0a				ld a,(hl) 
9b0a				cp DS_TYPE_INUM 
9b0a				jp nz, type_faultn   
9b0a				pop af 
9b0a				endm 
9b0a			 
9b0a			 
9b0a			; increase data stack pointer and save hl to it 
9b0a				 
9b0a			FORTH_DSP_NEXT: macro 
9b0a				call macro_forth_dsp_next 
9b0a				endm 
9b0a			 
9b0a			 
9b0a			macro_forth_dsp_next: 
9b0a				if DEBUG_FORTH_STACK_GUARD 
9b0a cd f6 df				call check_stacks 
9b0d				endif 
9b0d e5				push hl 
9b0e d5				push de 
9b0f eb				ex de,hl 
9b10 2a f4 e9			ld hl,(cli_data_sp) 
9b13 23				inc hl 
9b14 23				inc hl 
9b15			 
9b15			; PARSEV5 
9b15 23				inc hl 
9b16 22 f4 e9			ld (cli_data_sp),hl 
9b19 73				ld (hl), e 
9b1a 23				inc hl 
9b1b 72				ld (hl), d 
9b1c d1				pop de 
9b1d e1				pop hl 
9b1e				if DEBUG_FORTH_STACK_GUARD 
9b1e cd f6 df				call check_stacks 
9b21				endif 
9b21 c9				ret 
9b22			 
9b22			 
9b22			; increase ret stack pointer and save hl to it 
9b22				 
9b22			FORTH_RSP_NEXT: macro 
9b22				call macro_forth_rsp_next 
9b22				endm 
9b22			 
9b22			macro_forth_rsp_next: 
9b22				if DEBUG_FORTH_STACK_GUARD 
9b22 cd f6 df				call check_stacks 
9b25				endif 
9b25 e5				push hl 
9b26 d5				push de 
9b27 eb				ex de,hl 
9b28 2a f8 e9			ld hl,(cli_ret_sp) 
9b2b 23				inc hl 
9b2c 23				inc hl 
9b2d 22 f8 e9			ld (cli_ret_sp),hl 
9b30 73				ld (hl), e 
9b31 23				inc hl 
9b32 72				ld (hl), d 
9b33 d1				pop de 
9b34 e1				pop hl 
9b35				if DEBUG_FORTH_STACK_GUARD 
9b35 cd f6 df				call check_stacks 
9b38				endif 
9b38 c9				ret 
9b39			 
9b39			; get current ret stack pointer and save to hl  
9b39				 
9b39			FORTH_RSP_TOS: macro 
9b39				call macro_forth_rsp_tos 
9b39				endm 
9b39			 
9b39			macro_forth_rsp_tos: 
9b39				;push de 
9b39 2a f8 e9			ld hl,(cli_ret_sp) 
9b3c cd 74 9b			call loadhlptrtohl 
9b3f				;ld e, (hl) 
9b3f				;inc hl 
9b3f				;ld d, (hl) 
9b3f				;ex de, hl 
9b3f					if DEBUG_FORTH_WORDS 
9b3f			;			DMARK "RST" 
9b3f						CALLMONITOR 
9b3f cd dd 94			call break_point_state  
9b42				endm  
# End of macro CALLMONITOR
9b42					endif 
9b42				;pop de 
9b42 c9				ret 
9b43			 
9b43			; pop ret stack pointer 
9b43				 
9b43			FORTH_RSP_POP: macro 
9b43				call macro_forth_rsp_pop 
9b43				endm 
9b43			 
9b43			 
9b43			macro_forth_rsp_pop: 
9b43				if DEBUG_FORTH_STACK_GUARD 
9b43			;		DMARK "RPP" 
9b43 cd f6 df				call check_stacks 
9b46					FORTH_CHK_RSP_UNDER 
9b46 e5				push hl 
9b47 d5				push de 
9b48 2a f8 e9			ld hl,(cli_ret_sp) 
9b4b 11 b2 e9			ld de, cli_ret_stack 
9b4e cd fa 8c			call cmp16 
9b51 da 0a e1			jp c, fault_rsp_under 
9b54 d1				pop de 
9b55 e1				pop hl 
9b56				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b56				endif 
9b56 e5				push hl 
9b57 2a f8 e9			ld hl,(cli_ret_sp) 
9b5a			 
9b5a			 
9b5a				if FORTH_ENABLE_FREE 
9b5a			 
9b5a					; get pointer 
9b5a			 
9b5a					push de 
9b5a					push hl 
9b5a			 
9b5a					ld e, (hl) 
9b5a					inc hl 
9b5a					ld d, (hl) 
9b5a			 
9b5a					ex de, hl 
9b5a					call free 
9b5a			 
9b5a					pop hl 
9b5a					pop de 
9b5a			 
9b5a			 
9b5a				endif 
9b5a			 
9b5a			 
9b5a 2b				dec hl 
9b5b 2b				dec hl 
9b5c 22 f8 e9			ld (cli_ret_sp), hl 
9b5f				; do stack underflow checks 
9b5f e1				pop hl 
9b60				if DEBUG_FORTH_STACK_GUARD 
9b60 cd f6 df				call check_stacks 
9b63					FORTH_CHK_RSP_UNDER 
9b63 e5				push hl 
9b64 d5				push de 
9b65 2a f8 e9			ld hl,(cli_ret_sp) 
9b68 11 b2 e9			ld de, cli_ret_stack 
9b6b cd fa 8c			call cmp16 
9b6e da 0a e1			jp c, fault_rsp_under 
9b71 d1				pop de 
9b72 e1				pop hl 
9b73				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b73				endif 
9b73 c9				ret 
9b74			 
9b74			 
9b74			 
9b74			; routine to load word pointed to by hl into hl 
9b74			 
9b74			loadhlptrtohl: 
9b74			 
9b74 d5				push de 
9b75 5e				ld e, (hl) 
9b76 23				inc hl 
9b77 56				ld d, (hl) 
9b78 eb				ex de, hl 
9b79 d1				pop de 
9b7a			 
9b7a c9				ret 
9b7b			 
9b7b			 
9b7b			 
9b7b			 
9b7b			 
9b7b			; push a number held in HL onto the data stack 
9b7b			; entry point for pushing a value when already in hl used in function above 
9b7b			 
9b7b			forth_push_numhl: 
9b7b			 
9b7b e5				push hl    ; save value to push 
9b7c			 
9b7c			if DEBUG_FORTH_PUSH 
9b7c				; see if disabled 
9b7c			 
9b7c			 
9b7c f5				push af 
9b7d 3a b8 e2			ld a, (os_view_disable) 
9b80 fe 2a			cp '*' 
9b82 28 34			jr z, .pskip2 
9b84 e5				push hl 
9b85 e5			push hl 
9b86 cd af 8a			call clear_display 
9b89 e1			pop hl 
9b8a 7c				ld a,h 
9b8b 21 cc e5			ld hl, os_word_scratch 
9b8e cd dd 8f			call hexout 
9b91 e1				pop hl 
9b92 7d				ld a,l 
9b93 21 ce e5			ld hl, os_word_scratch+2 
9b96 cd dd 8f			call hexout 
9b99			 
9b99 21 d0 e5			ld hl, os_word_scratch+4 
9b9c 3e 00			ld a,0 
9b9e 77				ld (hl),a 
9b9f 11 cc e5			ld de,os_word_scratch 
9ba2 3e 28				ld a, display_row_2 
9ba4 cd c2 8a				call str_at_display 
9ba7 11 db cb			ld de, .push_num 
9baa 3e 00			ld a, display_row_1 
9bac			 
9bac cd c2 8a				call str_at_display 
9baf			 
9baf			 
9baf cd d2 8a			call update_display 
9bb2 cd f2 89			call delay1s 
9bb5 cd f2 89			call delay1s 
9bb8			.pskip2:  
9bb8			 
9bb8 f1				pop af 
9bb9			endif	 
9bb9			 
9bb9			 
9bb9				FORTH_DSP_NEXT 
9bb9 cd 0a 9b			call macro_forth_dsp_next 
9bbc				endm 
# End of macro FORTH_DSP_NEXT
9bbc			 
9bbc 2a f4 e9			ld hl, (cli_data_sp) 
9bbf			 
9bbf				; save item type 
9bbf 3e 02			ld a,  DS_TYPE_INUM 
9bc1 77				ld (hl), a 
9bc2 23				inc hl 
9bc3			 
9bc3				; get word off stack 
9bc3 d1				pop de 
9bc4 7b				ld a,e 
9bc5 77				ld (hl), a 
9bc6 23				inc hl 
9bc7 7a				ld a,d 
9bc8 77				ld (hl), a 
9bc9			 
9bc9			if DEBUG_FORTH_PUSH 
9bc9 2b				dec hl 
9bca 2b				dec hl 
9bcb 2b				dec hl 
9bcc						DMARK "PH5" 
9bcc f5				push af  
9bcd 3a e1 9b			ld a, (.dmark)  
9bd0 32 71 ee			ld (debug_mark),a  
9bd3 3a e2 9b			ld a, (.dmark+1)  
9bd6 32 72 ee			ld (debug_mark+1),a  
9bd9 3a e3 9b			ld a, (.dmark+2)  
9bdc 32 73 ee			ld (debug_mark+2),a  
9bdf 18 03			jr .pastdmark  
9be1 ..			.dmark: db "PH5"  
9be4 f1			.pastdmark: pop af  
9be5			endm  
# End of macro DMARK
9be5				CALLMONITOR 
9be5 cd dd 94			call break_point_state  
9be8				endm  
# End of macro CALLMONITOR
9be8			endif	 
9be8			 
9be8 c9				ret 
9be9			 
9be9			 
9be9			; Push a string to stack pointed to by hl 
9be9			 
9be9			forth_push_str: 
9be9			 
9be9			if DEBUG_FORTH_PUSH 
9be9						DMARK "PSQ" 
9be9 f5				push af  
9bea 3a fe 9b			ld a, (.dmark)  
9bed 32 71 ee			ld (debug_mark),a  
9bf0 3a ff 9b			ld a, (.dmark+1)  
9bf3 32 72 ee			ld (debug_mark+1),a  
9bf6 3a 00 9c			ld a, (.dmark+2)  
9bf9 32 73 ee			ld (debug_mark+2),a  
9bfc 18 03			jr .pastdmark  
9bfe ..			.dmark: db "PSQ"  
9c01 f1			.pastdmark: pop af  
9c02			endm  
# End of macro DMARK
9c02				CALLMONITOR 
9c02 cd dd 94			call break_point_state  
9c05				endm  
# End of macro CALLMONITOR
9c05			endif	 
9c05			    
9c05 e5				push hl 
9c06 e5				push hl 
9c07			 
9c07			;	ld a, 0   ; find end of string 
9c07 cd 3a 91			call strlenz 
9c0a			if DEBUG_FORTH_PUSH 
9c0a						DMARK "PQ2" 
9c0a f5				push af  
9c0b 3a 1f 9c			ld a, (.dmark)  
9c0e 32 71 ee			ld (debug_mark),a  
9c11 3a 20 9c			ld a, (.dmark+1)  
9c14 32 72 ee			ld (debug_mark+1),a  
9c17 3a 21 9c			ld a, (.dmark+2)  
9c1a 32 73 ee			ld (debug_mark+2),a  
9c1d 18 03			jr .pastdmark  
9c1f ..			.dmark: db "PQ2"  
9c22 f1			.pastdmark: pop af  
9c23			endm  
# End of macro DMARK
9c23				CALLMONITOR 
9c23 cd dd 94			call break_point_state  
9c26				endm  
# End of macro CALLMONITOR
9c26			endif	 
9c26 eb				ex de, hl 
9c27 e1				pop hl   ; get ptr to start of string 
9c28			if DEBUG_FORTH_PUSH 
9c28						DMARK "PQ3" 
9c28 f5				push af  
9c29 3a 3d 9c			ld a, (.dmark)  
9c2c 32 71 ee			ld (debug_mark),a  
9c2f 3a 3e 9c			ld a, (.dmark+1)  
9c32 32 72 ee			ld (debug_mark+1),a  
9c35 3a 3f 9c			ld a, (.dmark+2)  
9c38 32 73 ee			ld (debug_mark+2),a  
9c3b 18 03			jr .pastdmark  
9c3d ..			.dmark: db "PQ3"  
9c40 f1			.pastdmark: pop af  
9c41			endm  
# End of macro DMARK
9c41				CALLMONITOR 
9c41 cd dd 94			call break_point_state  
9c44				endm  
# End of macro CALLMONITOR
9c44			endif	 
9c44 19				add hl,de 
9c45			if DEBUG_FORTH_PUSH 
9c45						DMARK "PQE" 
9c45 f5				push af  
9c46 3a 5a 9c			ld a, (.dmark)  
9c49 32 71 ee			ld (debug_mark),a  
9c4c 3a 5b 9c			ld a, (.dmark+1)  
9c4f 32 72 ee			ld (debug_mark+1),a  
9c52 3a 5c 9c			ld a, (.dmark+2)  
9c55 32 73 ee			ld (debug_mark+2),a  
9c58 18 03			jr .pastdmark  
9c5a ..			.dmark: db "PQE"  
9c5d f1			.pastdmark: pop af  
9c5e			endm  
# End of macro DMARK
9c5e				CALLMONITOR 
9c5e cd dd 94			call break_point_state  
9c61				endm  
# End of macro CALLMONITOR
9c61			endif	 
9c61			 
9c61 2b				dec hl    ; see if there is an optional trailing double quote 
9c62 7e				ld a,(hl) 
9c63 fe 22			cp '"' 
9c65 20 03			jr nz, .strnoq 
9c67 3e 00			ld a, 0      ; get rid of double quote 
9c69 77				ld (hl), a 
9c6a 23			.strnoq: inc hl 
9c6b			 
9c6b 3e 00			ld a, 0 
9c6d 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c6e			 
9c6e 13				inc de ; add one for the type string 
9c6f 13				inc de ; add one for null term??? 
9c70			 
9c70				; tos is get string pointer again 
9c70				; de contains space to allocate 
9c70				 
9c70 d5				push de 
9c71			 
9c71 eb				ex de, hl 
9c72			 
9c72				;push af 
9c72			 
9c72			if DEBUG_FORTH_PUSH 
9c72						DMARK "PHm" 
9c72 f5				push af  
9c73 3a 87 9c			ld a, (.dmark)  
9c76 32 71 ee			ld (debug_mark),a  
9c79 3a 88 9c			ld a, (.dmark+1)  
9c7c 32 72 ee			ld (debug_mark+1),a  
9c7f 3a 89 9c			ld a, (.dmark+2)  
9c82 32 73 ee			ld (debug_mark+2),a  
9c85 18 03			jr .pastdmark  
9c87 ..			.dmark: db "PHm"  
9c8a f1			.pastdmark: pop af  
9c8b			endm  
# End of macro DMARK
9c8b				CALLMONITOR 
9c8b cd dd 94			call break_point_state  
9c8e				endm  
# End of macro CALLMONITOR
9c8e			endif	 
9c8e cd a3 91			call malloc	; on ret hl now contains allocated memory 
9c91				if DEBUG_FORTH_MALLOC_GUARD 
9c91 cc 33 cc				call z,malloc_error 
9c94				endif 
9c94			 
9c94				 
9c94 c1				pop bc    ; get length 
9c95 d1				pop de   ;  get string start    
9c96			 
9c96				; hl has destination from malloc 
9c96			 
9c96 eb				ex de, hl    ; prep for ldir 
9c97			 
9c97 d5				push de   ; save malloc area for DSP later 
9c98				;push hl   ; save malloc area for DSP later 
9c98			 
9c98			if DEBUG_FORTH_PUSH 
9c98						DMARK "PHc" 
9c98 f5				push af  
9c99 3a ad 9c			ld a, (.dmark)  
9c9c 32 71 ee			ld (debug_mark),a  
9c9f 3a ae 9c			ld a, (.dmark+1)  
9ca2 32 72 ee			ld (debug_mark+1),a  
9ca5 3a af 9c			ld a, (.dmark+2)  
9ca8 32 73 ee			ld (debug_mark+2),a  
9cab 18 03			jr .pastdmark  
9cad ..			.dmark: db "PHc"  
9cb0 f1			.pastdmark: pop af  
9cb1			endm  
# End of macro DMARK
9cb1				CALLMONITOR 
9cb1 cd dd 94			call break_point_state  
9cb4				endm  
# End of macro CALLMONITOR
9cb4			endif	 
9cb4			 
9cb4			 
9cb4 ed b0			ldir 
9cb6			 
9cb6			 
9cb6				; push malloc to data stack     macro?????  
9cb6			 
9cb6				FORTH_DSP_NEXT 
9cb6 cd 0a 9b			call macro_forth_dsp_next 
9cb9				endm 
# End of macro FORTH_DSP_NEXT
9cb9			 
9cb9				; save value and type 
9cb9			 
9cb9 2a f4 e9			ld hl, (cli_data_sp) 
9cbc			 
9cbc				; save item type 
9cbc 3e 01			ld a,  DS_TYPE_STR 
9cbe 77				ld (hl), a 
9cbf 23				inc hl 
9cc0			 
9cc0				; get malloc word off stack 
9cc0 d1				pop de 
9cc1 73				ld (hl), e 
9cc2 23				inc hl 
9cc3 72				ld (hl), d 
9cc4			 
9cc4			 
9cc4			 
9cc4			if DEBUG_FORTH_PUSH 
9cc4 2a f4 e9			ld hl, (cli_data_sp) 
9cc7						DMARK "PHS" 
9cc7 f5				push af  
9cc8 3a dc 9c			ld a, (.dmark)  
9ccb 32 71 ee			ld (debug_mark),a  
9cce 3a dd 9c			ld a, (.dmark+1)  
9cd1 32 72 ee			ld (debug_mark+1),a  
9cd4 3a de 9c			ld a, (.dmark+2)  
9cd7 32 73 ee			ld (debug_mark+2),a  
9cda 18 03			jr .pastdmark  
9cdc ..			.dmark: db "PHS"  
9cdf f1			.pastdmark: pop af  
9ce0			endm  
# End of macro DMARK
9ce0				CALLMONITOR 
9ce0 cd dd 94			call break_point_state  
9ce3				endm  
# End of macro CALLMONITOR
9ce3			;	ex de,hl 
9ce3			endif	 
9ce3				; in case of spaces, skip the ptr past the copied string 
9ce3				;pop af 
9ce3				;ld (cli_origptr),hl 
9ce3			 
9ce3 c9				ret 
9ce4			 
9ce4			 
9ce4			 
9ce4			; TODO ascii push input onto stack given hl to start of input 
9ce4			 
9ce4			; identify type 
9ce4			; if starts with a " then a string 
9ce4			; otherwise it is a number 
9ce4			;  
9ce4			; if a string 
9ce4			;     scan for ending " to get length of string to malloc for + 1 
9ce4			;     malloc 
9ce4			;     put pointer to string on stack first byte flags as string 
9ce4			; 
9ce4			; else a number 
9ce4			;    look for number format identifier 
9ce4			;    $xx hex 
9ce4			;    %xxxxx bin 
9ce4			;    xxxxx decimal 
9ce4			;    convert number to 16bit word.  
9ce4			;    malloc word + 1 with flag to identiy as num 
9ce4			;    put pointer to number on stack 
9ce4			;   
9ce4			;  
9ce4			  
9ce4			forth_apush: 
9ce4				; kernel push 
9ce4			 
9ce4			if DEBUG_FORTH_PUSH 
9ce4						DMARK "PSH" 
9ce4 f5				push af  
9ce5 3a f9 9c			ld a, (.dmark)  
9ce8 32 71 ee			ld (debug_mark),a  
9ceb 3a fa 9c			ld a, (.dmark+1)  
9cee 32 72 ee			ld (debug_mark+1),a  
9cf1 3a fb 9c			ld a, (.dmark+2)  
9cf4 32 73 ee			ld (debug_mark+2),a  
9cf7 18 03			jr .pastdmark  
9cf9 ..			.dmark: db "PSH"  
9cfc f1			.pastdmark: pop af  
9cfd			endm  
# End of macro DMARK
9cfd				CALLMONITOR 
9cfd cd dd 94			call break_point_state  
9d00				endm  
# End of macro CALLMONITOR
9d00			endif	 
9d00				; identify input type 
9d00			 
9d00 7e				ld a,(hl) 
9d01 fe 22			cp '"' 
9d03 28 0a			jr z, .fapstr 
9d05 fe 24			cp '$' 
9d07 ca 2f 9d			jp z, .faphex 
9d0a fe 25			cp '%' 
9d0c ca 17 9d			jp z, .fapbin 
9d0f			;	cp 'b' 
9d0f			;	jp z, .fabin 
9d0f				; else decimal 
9d0f			 
9d0f				; TODO do decimal conversion 
9d0f				; decimal is stored as a 16bit word 
9d0f			 
9d0f				; by default everything is a string if type is not detected 
9d0f			.fapstr: ; 
9d0f fe 22			cp '"' 
9d11 20 01			jr nz, .strnoqu 
9d13 23				inc hl 
9d14			.strnoqu: 
9d14 c3 e9 9b			jp forth_push_str 
9d17			 
9d17			 
9d17			 
9d17			.fapbin:    ; push a binary string.  
9d17 11 00 00			ld de, 0   ; hold a 16bit value 
9d1a			 
9d1a 23			.fapbinshift:	inc hl  
9d1b 7e				ld a,(hl) 
9d1c fe 00			cp 0     ; done scanning  
9d1e 28 0b			jr z, .fapbdone  	; got it in HL so push  
9d20			 
9d20				; left shift de 
9d20 eb				ex de, hl	 
9d21 29				add hl, hl 
9d22			 
9d22				; is 1 
9d22 fe 31			cp '1' 
9d24 20 02			jr nz, .binzero 
9d26 cb 4d			bit 1, l 
9d28			.binzero: 
9d28 eb				ex de, hl	 ; save current de 
9d29 18 ef			jr .fapbinshift 
9d2b			 
9d2b			.fapbdone: 
9d2b eb				ex de, hl 
9d2c c3 7b 9b			jp forth_push_numhl 
9d2f			 
9d2f			 
9d2f			.faphex:   ; hex is always stored as a 16bit word 
9d2f				; skip number prefix 
9d2f 23				inc hl 
9d30				; turn ascii into number 
9d30 cd 93 90			call get_word_hl	; ret 16bit word in hl 
9d33			 
9d33 c3 7b 9b			jp forth_push_numhl 
9d36			 
9d36 00				 nop 
9d37			 
9d37			.fabin:   ; TODO bin conversion 
9d37			 
9d37			 
9d37 c9				ret 
9d38			 
9d38			 
9d38			; get either a string ptr or a 16bit word from the data stack 
9d38			 
9d38			FORTH_DSP: macro 
9d38				call macro_forth_dsp 
9d38				endm 
9d38			 
9d38			macro_forth_dsp: 
9d38				; data stack pointer points to current word on tos 
9d38			 
9d38 2a f4 e9			ld hl,(cli_data_sp) 
9d3b			 
9d3b				if DEBUG_FORTH_PUSH 
9d3b						DMARK "DSP" 
9d3b f5				push af  
9d3c 3a 50 9d			ld a, (.dmark)  
9d3f 32 71 ee			ld (debug_mark),a  
9d42 3a 51 9d			ld a, (.dmark+1)  
9d45 32 72 ee			ld (debug_mark+1),a  
9d48 3a 52 9d			ld a, (.dmark+2)  
9d4b 32 73 ee			ld (debug_mark+2),a  
9d4e 18 03			jr .pastdmark  
9d50 ..			.dmark: db "DSP"  
9d53 f1			.pastdmark: pop af  
9d54			endm  
# End of macro DMARK
9d54			 
9d54 cd 68 cc				call display_data_sp 
9d57				;call break_point_state 
9d57				;rst 030h 
9d57				CALLMONITOR 
9d57 cd dd 94			call break_point_state  
9d5a				endm  
# End of macro CALLMONITOR
9d5a				endif 
9d5a			 
9d5a c9				ret 
9d5b			 
9d5b			; return hl to start of value on stack 
9d5b			 
9d5b			FORTH_DSP_VALUE: macro 
9d5b				call macro_forth_dsp_value 
9d5b				endm 
9d5b			 
9d5b			macro_forth_dsp_value: 
9d5b			 
9d5b				FORTH_DSP 
9d5b cd 38 9d			call macro_forth_dsp 
9d5e				endm 
# End of macro FORTH_DSP
9d5e			 
9d5e d5				push de 
9d5f			 
9d5f 23				inc hl ; skip type 
9d60			 
9d60 5e				ld e, (hl) 
9d61 23				inc hl 
9d62 56				ld d, (hl) 
9d63 eb				ex de,hl  
9d64			 
9d64 d1				pop de 
9d65			 
9d65 c9				ret 
9d66			 
9d66			; return hl to start of value to second item on stack 
9d66			 
9d66			FORTH_DSP_VALUEM1: macro 
9d66				call macro_forth_dsp_value_m1 
9d66				endm 
9d66			 
9d66			macro_forth_dsp_value_m1: 
9d66			 
9d66				FORTH_DSP 
9d66 cd 38 9d			call macro_forth_dsp 
9d69				endm 
# End of macro FORTH_DSP
9d69			 
9d69 2b				dec hl 
9d6a 2b				dec hl 
9d6b			;	dec hl 
9d6b			 
9d6b d5				push de 
9d6c			 
9d6c 5e				ld e, (hl) 
9d6d 23				inc hl 
9d6e 56				ld d, (hl) 
9d6f eb				ex de,hl  
9d70			 
9d70 d1				pop de 
9d71			 
9d71 c9				ret 
9d72			 
9d72				 
9d72			 
9d72			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d72			 
9d72			FORTH_DSP_POP: macro 
9d72				call macro_forth_dsp_pop 
9d72				endm 
9d72			 
9d72			 
9d72			; get the tos data type 
9d72			 
9d72			FORTH_DSP_TYPE:   macro 
9d72			 
9d72				;FORTH_DSP_VALUE 
9d72				FORTH_DSP 
9d72				 
9d72				; hl points to value 
9d72				; check type 
9d72			 
9d72				ld a,(hl) 
9d72			 
9d72				endm 
9d72			 
9d72			; load the tos value into hl 
9d72			 
9d72			 
9d72			FORTH_DSP_VALUEHL:  macro 
9d72				call macro_dsp_valuehl 
9d72				endm 
9d72			 
9d72			 
9d72			 
9d72			macro_dsp_valuehl: 
9d72				FORTH_DSP_VALUE 
9d72 cd 5b 9d			call macro_forth_dsp_value 
9d75				endm 
# End of macro FORTH_DSP_VALUE
9d75			 
9d75				;FORTH_ERR_TOS_NOTNUM 
9d75			 
9d75				;inc hl   ; skip type id 
9d75			 
9d75			;	push de 
9d75			; 
9d75			;	ld e, (hl) 
9d75			;	inc hl 
9d75			;	ld d, (hl) 
9d75			;	ex de,hl  
9d75			 
9d75			;	pop de 
9d75			 
9d75				if DEBUG_FORTH_PUSH 
9d75						DMARK "DVL" 
9d75 f5				push af  
9d76 3a 8a 9d			ld a, (.dmark)  
9d79 32 71 ee			ld (debug_mark),a  
9d7c 3a 8b 9d			ld a, (.dmark+1)  
9d7f 32 72 ee			ld (debug_mark+1),a  
9d82 3a 8c 9d			ld a, (.dmark+2)  
9d85 32 73 ee			ld (debug_mark+2),a  
9d88 18 03			jr .pastdmark  
9d8a ..			.dmark: db "DVL"  
9d8d f1			.pastdmark: pop af  
9d8e			endm  
# End of macro DMARK
9d8e				CALLMONITOR 
9d8e cd dd 94			call break_point_state  
9d91				endm  
# End of macro CALLMONITOR
9d91				endif 
9d91 c9				ret 
9d92			 
9d92			forth_apushstrhl:      
9d92				; push of string requires use of cli_origptr 
9d92				; bodge use 
9d92			 
9d92				; get current cli_origptr, save, update with temp pointer  
9d92 ed 5b 44 ea		ld de, (cli_origptr) 
9d96 22 44 ea			ld (cli_origptr), hl 
9d99 d5				push de 
9d9a cd e4 9c			call forth_apush 
9d9d d1				pop de 
9d9e ed 53 44 ea		ld (cli_origptr), de 
9da2 c9			        ret	 
9da3			 
9da3			 
9da3			; increase loop stack pointer and save hl to it 
9da3				 
9da3			FORTH_LOOP_NEXT: macro 
9da3				call macro_forth_loop_next 
9da3				;nop 
9da3				endm 
9da3			 
9da3			macro_forth_loop_next: 
9da3				if DEBUG_FORTH_STACK_GUARD 
9da3 cd f6 df				call check_stacks 
9da6				endif 
9da6 e5				push hl 
9da7 d5				push de 
9da8 eb				ex de,hl 
9da9 2a f6 e9			ld hl,(cli_loop_sp) 
9dac 23				inc hl 
9dad 23				inc hl 
9dae					if DEBUG_FORTH_WORDS 
9dae						DMARK "LNX" 
9dae f5				push af  
9daf 3a c3 9d			ld a, (.dmark)  
9db2 32 71 ee			ld (debug_mark),a  
9db5 3a c4 9d			ld a, (.dmark+1)  
9db8 32 72 ee			ld (debug_mark+1),a  
9dbb 3a c5 9d			ld a, (.dmark+2)  
9dbe 32 73 ee			ld (debug_mark+2),a  
9dc1 18 03			jr .pastdmark  
9dc3 ..			.dmark: db "LNX"  
9dc6 f1			.pastdmark: pop af  
9dc7			endm  
# End of macro DMARK
9dc7						CALLMONITOR 
9dc7 cd dd 94			call break_point_state  
9dca				endm  
# End of macro CALLMONITOR
9dca					endif 
9dca 22 f6 e9			ld (cli_loop_sp),hl 
9dcd 73				ld (hl), e 
9dce 23				inc hl 
9dcf 72				ld (hl), d 
9dd0 d1				pop de    ; been reversed so save a swap on restore 
9dd1 e1				pop hl 
9dd2				if DEBUG_FORTH_STACK_GUARD 
9dd2 cd f6 df				call check_stacks 
9dd5				endif 
9dd5 c9				ret 
9dd6			 
9dd6			; get current ret stack pointer and save to hl  
9dd6				 
9dd6			FORTH_LOOP_TOS: macro 
9dd6				call macro_forth_loop_tos 
9dd6				endm 
9dd6			 
9dd6			macro_forth_loop_tos: 
9dd6 d5				push de 
9dd7 2a f6 e9			ld hl,(cli_loop_sp) 
9dda 5e				ld e, (hl) 
9ddb 23				inc hl 
9ddc 56				ld d, (hl) 
9ddd eb				ex de, hl 
9dde d1				pop de 
9ddf c9				ret 
9de0			 
9de0			; pop loop stack pointer 
9de0				 
9de0			FORTH_LOOP_POP: macro 
9de0				call macro_forth_loop_pop 
9de0				endm 
9de0			 
9de0			 
9de0			macro_forth_loop_pop: 
9de0				if DEBUG_FORTH_STACK_GUARD 
9de0					DMARK "LPP" 
9de0 f5				push af  
9de1 3a f5 9d			ld a, (.dmark)  
9de4 32 71 ee			ld (debug_mark),a  
9de7 3a f6 9d			ld a, (.dmark+1)  
9dea 32 72 ee			ld (debug_mark+1),a  
9ded 3a f7 9d			ld a, (.dmark+2)  
9df0 32 73 ee			ld (debug_mark+2),a  
9df3 18 03			jr .pastdmark  
9df5 ..			.dmark: db "LPP"  
9df8 f1			.pastdmark: pop af  
9df9			endm  
# End of macro DMARK
9df9 cd f6 df				call check_stacks 
9dfc					FORTH_CHK_LOOP_UNDER 
9dfc e5				push hl 
9dfd d5				push de 
9dfe 2a f6 e9			ld hl,(cli_loop_sp) 
9e01 11 30 e9			ld de, cli_loop_stack 
9e04 cd fa 8c			call cmp16 
9e07 da 10 e1			jp c, fault_loop_under 
9e0a d1				pop de 
9e0b e1				pop hl 
9e0c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9e0c				endif 
9e0c e5				push hl 
9e0d 2a f6 e9			ld hl,(cli_loop_sp) 
9e10 2b				dec hl 
9e11 2b				dec hl 
9e12 22 f6 e9			ld (cli_loop_sp), hl 
9e15				; TODO do stack underflow checks 
9e15 e1				pop hl 
9e16				if DEBUG_FORTH_STACK_GUARD 
9e16 cd f6 df				call check_stacks 
9e19					FORTH_CHK_LOOP_UNDER 
9e19 e5				push hl 
9e1a d5				push de 
9e1b 2a f6 e9			ld hl,(cli_loop_sp) 
9e1e 11 30 e9			ld de, cli_loop_stack 
9e21 cd fa 8c			call cmp16 
9e24 da 10 e1			jp c, fault_loop_under 
9e27 d1				pop de 
9e28 e1				pop hl 
9e29				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9e29				endif 
9e29 c9				ret 
9e2a			 
9e2a			macro_forth_dsp_pop: 
9e2a			 
9e2a e5				push hl 
9e2b			 
9e2b				; release malloc data 
9e2b			 
9e2b				if DEBUG_FORTH_STACK_GUARD 
9e2b cd f6 df				call check_stacks 
9e2e					FORTH_CHK_DSP_UNDER 
9e2e e5				push hl 
9e2f d5				push de 
9e30 2a f4 e9			ld hl,(cli_data_sp) 
9e33 11 2e e8			ld de, cli_data_stack 
9e36 cd fa 8c			call cmp16 
9e39 da 04 e1			jp c, fault_dsp_under 
9e3c d1				pop de 
9e3d e1				pop hl 
9e3e				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e3e				endif 
9e3e				;ld hl,(cli_data_sp) 
9e3e			if DEBUG_FORTH_DOT 
9e3e				DMARK "DPP" 
9e3e f5				push af  
9e3f 3a 53 9e			ld a, (.dmark)  
9e42 32 71 ee			ld (debug_mark),a  
9e45 3a 54 9e			ld a, (.dmark+1)  
9e48 32 72 ee			ld (debug_mark+1),a  
9e4b 3a 55 9e			ld a, (.dmark+2)  
9e4e 32 73 ee			ld (debug_mark+2),a  
9e51 18 03			jr .pastdmark  
9e53 ..			.dmark: db "DPP"  
9e56 f1			.pastdmark: pop af  
9e57			endm  
# End of macro DMARK
9e57				CALLMONITOR 
9e57 cd dd 94			call break_point_state  
9e5a				endm  
# End of macro CALLMONITOR
9e5a			endif	 
9e5a			 
9e5a			 
9e5a			if FORTH_ENABLE_DSPPOPFREE 
9e5a			 
9e5a				FORTH_DSP 
9e5a cd 38 9d			call macro_forth_dsp 
9e5d				endm 
# End of macro FORTH_DSP
9e5d			 
9e5d 7e				ld a, (hl) 
9e5e fe 01			cp DS_TYPE_STR 
9e60 20 23			jr nz, .skippopfree 
9e62			 
9e62				FORTH_DSP_VALUEHL 
9e62 cd 72 9d			call macro_dsp_valuehl 
9e65				endm 
# End of macro FORTH_DSP_VALUEHL
9e65 00				nop 
9e66			if DEBUG_FORTH_DOT 
9e66				DMARK "DPf" 
9e66 f5				push af  
9e67 3a 7b 9e			ld a, (.dmark)  
9e6a 32 71 ee			ld (debug_mark),a  
9e6d 3a 7c 9e			ld a, (.dmark+1)  
9e70 32 72 ee			ld (debug_mark+1),a  
9e73 3a 7d 9e			ld a, (.dmark+2)  
9e76 32 73 ee			ld (debug_mark+2),a  
9e79 18 03			jr .pastdmark  
9e7b ..			.dmark: db "DPf"  
9e7e f1			.pastdmark: pop af  
9e7f			endm  
# End of macro DMARK
9e7f				CALLMONITOR 
9e7f cd dd 94			call break_point_state  
9e82				endm  
# End of macro CALLMONITOR
9e82			endif	 
9e82 cd 6d 92			call free 
9e85			.skippopfree: 
9e85				 
9e85			 
9e85			endif 
9e85			 
9e85			if DEBUG_FORTH_DOT_KEY 
9e85				DMARK "DP2" 
9e85				CALLMONITOR 
9e85			endif	 
9e85			 
9e85				; move pointer down 
9e85			 
9e85 2a f4 e9			ld hl,(cli_data_sp) 
9e88 2b				dec hl 
9e89 2b				dec hl 
9e8a			; PARSEV5 
9e8a 2b				dec hl 
9e8b 22 f4 e9			ld (cli_data_sp), hl 
9e8e			 
9e8e				if DEBUG_FORTH_STACK_GUARD 
9e8e cd f6 df				call check_stacks 
9e91					FORTH_CHK_DSP_UNDER 
9e91 e5				push hl 
9e92 d5				push de 
9e93 2a f4 e9			ld hl,(cli_data_sp) 
9e96 11 2e e8			ld de, cli_data_stack 
9e99 cd fa 8c			call cmp16 
9e9c da 04 e1			jp c, fault_dsp_under 
9e9f d1				pop de 
9ea0 e1				pop hl 
9ea1				endm 
# End of macro FORTH_CHK_DSP_UNDER
9ea1				endif 
9ea1			 
9ea1 e1				pop hl 
9ea2			 
9ea2 c9				ret 
9ea3			 
9ea3			getwordathl: 
9ea3				; hl points to an address 
9ea3				; load hl with the word at that address 
9ea3			 
9ea3 d5				push de 
9ea4			 
9ea4 5e				ld e, (hl) 
9ea5 23				inc hl 
9ea6 56				ld d, (hl) 
9ea7 eb				ex de, hl 
9ea8			 
9ea8 d1				pop de 
9ea9 c9				ret 
9eaa			 
9eaa			 
9eaa			 
9eaa			 
9eaa			 
9eaa			; eof 
9eaa			 
# End of file forth_stackopsv5.asm
9eaa			endif 
9eaa			 
9eaa			loadwordinhl:	 
9eaa			 
9eaa d5				push de 
9eab			 
9eab 5e				ld e, (hl) 
9eac 23				inc hl 
9ead 56				ld d, (hl) 
9eae eb				ex de,hl  
9eaf			 
9eaf d1				pop de 
9eb0			 
9eb0 c9				ret 
9eb1			 
9eb1			user_word_eol:  
9eb1				; hl contains the pointer to where to create a linked list item from the end 
9eb1				; of the user dict to continue on at the system word dict 
9eb1				 
9eb1				; poke the stub of the word list linked list to repoint to rom words 
9eb1			 
9eb1				; stub format 
9eb1				; db   word id 
9eb1				; dw    link to next word 
9eb1			        ; db char length of token 
9eb1				; db string + 0 term 
9eb1				; db exec code....  
9eb1			 
9eb1 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9eb3 77				ld (hl), a		; word id 
9eb4 23				inc hl 
9eb5			 
9eb5 11 80 a0			ld de, sysdict 
9eb8 73				ld (hl), e		; next word link ie system dict 
9eb9 23				inc hl 
9eba 72				ld (hl), d		; next word link ie system dict 
9ebb 23				inc hl	 
9ebc			 
9ebc			;	ld (hl), sysdict		; next word link ie system dict 
9ebc			;	inc hl 
9ebc			;	inc hl 
9ebc			 
9ebc			;	inc hl 
9ebc			;	inc hl 
9ebc			 
9ebc 3e 02			ld a, 2			; word length is 0 
9ebe 77				ld (hl), a	 
9ebf 23				inc hl 
9ec0			 
9ec0 3e 7e			ld a, '~'			; word length is 0 
9ec2 77				ld (hl), a	 
9ec3 23				inc hl 
9ec4 3e 00			ld a, 0			; save empty word 
9ec6 77				ld (hl), a 
9ec7			 
9ec7 c9				ret 
9ec8			 
9ec8				 
9ec8			 
9ec8			forthexec_cleanup: 
9ec8				FORTH_RSP_POP 
9ec8 cd 43 9b			call macro_forth_rsp_pop 
9ecb				endm 
# End of macro FORTH_RSP_POP
9ecb c9				ret 
9ecc			 
9ecc			forth_call_hl: 
9ecc				; taking hl 
9ecc e5				push hl 
9ecd c9				ret 
9ece			 
9ece			; this is called to reset Forth system but keep existing uwords etc 
9ece			 
9ece			forth_warmstart: 
9ece				; setup stack over/under flow checks 
9ece				if DEBUG_FORTH_STACK_GUARD 
9ece cd dc df				call chk_stk_init 
9ed1				endif 
9ed1			 
9ed1				; init stack pointers  - * these stacks go upwards *  
9ed1 21 b2 e9			ld hl, cli_ret_stack 
9ed4 22 f8 e9			ld (cli_ret_sp), hl	 
9ed7				; set bottom of stack 
9ed7 3e 00			ld a,0 
9ed9 77				ld (hl),a 
9eda 23				inc hl 
9edb 77				ld (hl),a 
9edc			 
9edc 21 2e e8			ld hl, cli_data_stack 
9edf 22 f4 e9			ld (cli_data_sp), hl	 
9ee2				; set bottom of stack 
9ee2 3e 00			ld a,0 
9ee4 77				ld (hl),a 
9ee5 23				inc hl 
9ee6 77				ld (hl),a 
9ee7			 
9ee7 21 30 e9			ld hl, cli_loop_stack 
9eea 22 f6 e9			ld (cli_loop_sp), hl	 
9eed				; set bottom of stack 
9eed 3e 00			ld a,0 
9eef 77				ld (hl),a 
9ef0 23				inc hl 
9ef1 77				ld (hl),a 
9ef2			 
9ef2				; init extent of current open file 
9ef2			 
9ef2 3e 00			ld a, 0 
9ef4 32 70 ea			ld (store_openext), a 
9ef7			 
9ef7 c9				ret 
9ef8			 
9ef8			 
9ef8			; Cold Start - this is called to setup the whole Forth system 
9ef8			 
9ef8			forth_init: 
9ef8			 
9ef8				; setup stack over/under flow checks 
9ef8			 
9ef8			;	if DEBUG_FORTH_STACK_GUARD 
9ef8			;		call chk_stk_init 
9ef8			;	endif 
9ef8			 
9ef8				; enable auto display updates (slow.....) 
9ef8			 
9ef8 3e 01			ld a, 1 
9efa 32 42 ea			ld (cli_autodisplay), a 
9efd			 
9efd				; if storage is in use disable long reads for now 
9efd 3e 00			ld a, 0 
9eff 32 7b ea			ld (store_longread), a 
9f02			 
9f02			 
9f02				; show start up screen 
9f02			 
9f02 cd af 8a			call clear_display 
9f05			 
9f05 3e 00			ld a,0 
9f07 32 64 ea			ld (f_cursor_ptr), a 
9f0a			 
9f0a				; set start of word list in start of ram - for use when creating user words 
9f0a			 
9f0a 21 7d e3			ld hl, baseram 
9f0d 22 c4 e5			ld (os_last_new_uword), hl 
9f10 cd b1 9e			call user_word_eol 
9f13				 
9f13			;		call display_data_sp 
9f13			;		call next_page_prompt 
9f13			 
9f13			 
9f13			 
9f13			 
9f13 c9				ret 
9f14			 
9f14 .. 00		.bootforth: db " Forth Kernel Init ",0 
9f28			 
9f28			; TODO push to stack 
9f28			 
9f28			;  
9f28			 
9f28			if FORTH_PARSEV2 
9f28			 
9f28			 
9f28				include "forth_parserv2.asm" 
9f28			 
9f28			endif 
9f28			 
9f28			 
9f28			; parse cli version 1 
9f28			 
9f28			if FORTH_PARSEV1 
9f28			 
9f28			 
9f28			 
9f28			      include "forth_parserv1.asm" 
9f28			endif 
9f28				 
9f28			if FORTH_PARSEV3 
9f28			 
9f28			 
9f28			 
9f28			      include "forth_parserv3.asm" 
9f28				include "forth_wordsv3.asm" 
9f28			endif 
9f28			 
9f28			if FORTH_PARSEV4 
9f28			 
9f28			 
9f28			 
9f28			      include "forth_parserv4.asm" 
9f28				include "forth_wordsv4.asm" 
9f28			endif 
9f28			 
9f28			if FORTH_PARSEV5 
9f28			 
9f28			 
9f28			 
9f28			      include "forth_parserv5.asm" 
9f28			 
9f28			 
9f28			; A better parser without using malloc and string copies all over the place.  
9f28			; Exec in situ should be faster 
9f28			 
9f28			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9f28			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9f28			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9f28			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9f28			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9f28			WORD_SYS_END: equ 0   ; Opcode for all user words 
9f28			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9f28			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9f28			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9f28			 
9f28			; Core word preamble macro 
9f28			 
9f28			CWHEAD:   macro nxtword opcode lit len opflags 
9f28				db WORD_SYS_CORE+opcode             
9f28				; internal op code number 
9f28				dw nxtword            
9f28				; link to next dict word block 
9f28				db len + 1 
9f28				; literal length of dict word inc zero term 
9f28				db lit,0              
9f28				; literal dict word 
9f28			        ; TODO db opflags        
9f28				endm 
9f28			 
9f28			 
9f28			NEXTW: macro  
9f28				jp macro_next 
9f28				endm 
9f28			 
9f28			macro_next: 
9f28			if DEBUG_FORTH_PARSE_KEY 
9f28				DMARK "NXT" 
9f28				CALLMONITOR 
9f28			endif	 
9f28			;	inc hl  ; skip token null term  
9f28 ed 4b 46 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9f2c ed 5b 44 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9f30 2a c8 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9f33			if DEBUG_FORTH_PARSE_KEY 
9f33				DMARK "}AA" 
9f33				CALLMONITOR 
9f33			endif	 
9f33 c3 36 a0			jp execnext 
9f36				;jp exec1 
9f36			       
9f36			 
9f36			 
9f36			; Another go at the parser to compile  
9f36			 
9f36			 
9f36			; TODO rework parser to change all of the string words to byte tokens 
9f36			; TODO do a search for  
9f36			 
9f36			; TODO first run normal parser to zero term sections 
9f36			; TODO for each word do a token look up to get the op code 
9f36			; TODO need some means to flag to the exec that this is a byte code form    
9f36			 
9f36			 
9f36			forthcompile: 
9f36			 
9f36			; 
9f36			; line parse: 
9f36			;       parse raw input buffer 
9f36			;       tokenise the words 
9f36			;       malloc new copy (for looping etc) 
9f36			;       copy to malloc + current pc in line to start of string and add line term 
9f36			;       save on new rsp 
9f36			; 
9f36			 
9f36			; hl to point to the line to tokenise 
9f36			 
9f36			;	push hl 
9f36 22 c8 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f39			 
9f39			;	ld a,0		; string term on input 
9f39			;	call strlent 
9f39			 
9f39			;	ld (os_tok_len), hl	 ; save string length 
9f39			 
9f39			;if DEBUG_FORTH_TOK 
9f39			;	ex de,hl		 
9f39			;endif 
9f39			 
9f39			;	pop hl 		; get back string pointer 
9f39			 
9f39			if DEBUG_FORTH_TOK 
9f39						DMARK "TOc" 
9f39				CALLMONITOR 
9f39			endif 
9f39 7e			.cptoken2:    ld a,(hl) 
9f3a 23				inc hl 
9f3b fe 7f			cp FORTH_END_BUFFER 
9f3d 28 29			jr z, .cptokendone2 
9f3f fe 00			cp 0 
9f41 28 25			jr z, .cptokendone2 
9f43 fe 22			cp '"' 
9f45 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9f47 fe 20			cp ' ' 
9f49 20 ee			jr nz,  .cptoken2 
9f4b			 
9f4b			; TODO consume comments held between ( and ) 
9f4b			 
9f4b				; we have a space so change to zero term for dict match later 
9f4b 2b				dec hl 
9f4c 3e 00			ld a,0 
9f4e 77				ld (hl), a 
9f4f 23				inc hl 
9f50 18 e7			jr .cptoken2 
9f52				 
9f52			 
9f52			.cptokenstr2: 
9f52				; skip all white space until either eol (because forgot to term) or end double quote 
9f52			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f52				;inc hl ; skip current double quote 
9f52 7e				ld a,(hl) 
9f53 23				inc hl 
9f54 fe 22			cp '"' 
9f56 28 e1			jr z, .cptoken2 
9f58 fe 7f			cp FORTH_END_BUFFER 
9f5a 28 0c			jr z, .cptokendone2 
9f5c fe 00			cp 0 
9f5e 28 08			jr z, .cptokendone2 
9f60 fe 20			cp ' ' 
9f62 28 02			jr z, .cptmp2 
9f64 18 ec			jr .cptokenstr2 
9f66			 
9f66			.cptmp2:	; we have a space so change to zero term for dict match later 
9f66				;dec hl 
9f66				;ld a,"-"	; TODO remove this when working 
9f66				;ld (hl), a 
9f66				;inc hl 
9f66 18 ea			jr .cptokenstr2 
9f68			 
9f68			.cptokendone2: 
9f68				;inc hl 
9f68 3e 7f			ld a, FORTH_END_BUFFER 
9f6a 77				ld (hl),a 
9f6b 23				inc hl 
9f6c 3e 21			ld a, '!' 
9f6e 77				ld (hl),a 
9f6f			 
9f6f 2a c8 e5			ld hl,(os_tok_ptr) 
9f72			         
9f72			if DEBUG_FORTH_TOK 
9f72						DMARK "Tc1" 
9f72				CALLMONITOR 
9f72			endif 
9f72			 
9f72				; push exec string to top of return stack 
9f72				FORTH_RSP_NEXT 
9f72 cd 22 9b			call macro_forth_rsp_next 
9f75				endm 
# End of macro FORTH_RSP_NEXT
9f75 c9				ret 
9f76			 
9f76			; Another go at the parser need to simplify the process 
9f76			 
9f76			forthparse: 
9f76			 
9f76			; 
9f76			; line parse: 
9f76			;       parse raw input buffer 
9f76			;       tokenise the words 
9f76			;       malloc new copy (for looping etc) 
9f76			;       copy to malloc + current pc in line to start of string and add line term 
9f76			;       save on new rsp 
9f76			; 
9f76			 
9f76			; hl to point to the line to tokenise 
9f76			 
9f76			;	push hl 
9f76 22 c8 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f79			 
9f79			;	ld a,0		; string term on input 
9f79			;	call strlent 
9f79			 
9f79			;	ld (os_tok_len), hl	 ; save string length 
9f79			 
9f79			;if DEBUG_FORTH_TOK 
9f79			;	ex de,hl		 
9f79			;endif 
9f79			 
9f79			;	pop hl 		; get back string pointer 
9f79			 
9f79			if DEBUG_FORTH_TOK 
9f79						DMARK "TOK" 
9f79				CALLMONITOR 
9f79			endif 
9f79 7e			.ptoken2:    ld a,(hl) 
9f7a 23				inc hl 
9f7b fe 7f			cp FORTH_END_BUFFER 
9f7d 28 29			jr z, .ptokendone2 
9f7f fe 00			cp 0 
9f81 28 25			jr z, .ptokendone2 
9f83 fe 22			cp '"' 
9f85 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9f87 fe 20			cp ' ' 
9f89 20 ee			jr nz,  .ptoken2 
9f8b			 
9f8b			; TODO consume comments held between ( and ) 
9f8b			 
9f8b				; we have a space so change to zero term for dict match later 
9f8b 2b				dec hl 
9f8c 3e 00			ld a,0 
9f8e 77				ld (hl), a 
9f8f 23				inc hl 
9f90 18 e7			jr .ptoken2 
9f92				 
9f92			 
9f92			.ptokenstr2: 
9f92				; skip all white space until either eol (because forgot to term) or end double quote 
9f92			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f92				;inc hl ; skip current double quote 
9f92 7e				ld a,(hl) 
9f93 23				inc hl 
9f94 fe 22			cp '"' 
9f96 28 e1			jr z, .ptoken2 
9f98 fe 7f			cp FORTH_END_BUFFER 
9f9a 28 0c			jr z, .ptokendone2 
9f9c fe 00			cp 0 
9f9e 28 08			jr z, .ptokendone2 
9fa0 fe 20			cp ' ' 
9fa2 28 02			jr z, .ptmp2 
9fa4 18 ec			jr .ptokenstr2 
9fa6			 
9fa6			.ptmp2:	; we have a space so change to zero term for dict match later 
9fa6				;dec hl 
9fa6				;ld a,"-"	; TODO remove this when working 
9fa6				;ld (hl), a 
9fa6				;inc hl 
9fa6 18 ea			jr .ptokenstr2 
9fa8			 
9fa8			.ptokendone2: 
9fa8				;inc hl 
9fa8 3e 7f			ld a, FORTH_END_BUFFER 
9faa 77				ld (hl),a 
9fab 23				inc hl 
9fac 3e 21			ld a, '!' 
9fae 77				ld (hl),a 
9faf			 
9faf 2a c8 e5			ld hl,(os_tok_ptr) 
9fb2			         
9fb2			if DEBUG_FORTH_TOK 
9fb2						DMARK "TK1" 
9fb2				CALLMONITOR 
9fb2			endif 
9fb2			 
9fb2				; push exec string to top of return stack 
9fb2				FORTH_RSP_NEXT 
9fb2 cd 22 9b			call macro_forth_rsp_next 
9fb5				endm 
# End of macro FORTH_RSP_NEXT
9fb5 c9				ret 
9fb6			 
9fb6			; 
9fb6			;	; malloc size + buffer pointer + if is loop flag 
9fb6			;	ld hl,(os_tok_len) 		 ; get string length 
9fb6			; 
9fb6			;	ld a,l 
9fb6			; 
9fb6			;	cp 0			; we dont want to use a null string 
9fb6			;	ret z 
9fb6			; 
9fb6			;;	add 3    ; prefix malloc with buffer for current word ptr 
9fb6			; 
9fb6			;	add 5     ; TODO when certain not over writing memory remove 
9fb6			; 
9fb6			;		 
9fb6			; 
9fb6			;if DEBUG_FORTH_TOK 
9fb6			;			DMARK "TKE" 
9fb6			;	CALLMONITOR 
9fb6			;endif 
9fb6			; 
9fb6			;	ld l,a 
9fb6			;	ld h,0 
9fb6			;;	push hl   ; save required space for the copy later 
9fb6			;	call malloc 
9fb6			;if DEBUG_FORTH_TOK 
9fb6			;			DMARK "TKM" 
9fb6			;	CALLMONITOR 
9fb6			;endif 
9fb6			;	if DEBUG_FORTH_MALLOC_GUARD 
9fb6			;		push af 
9fb6			;		call ishlzero 
9fb6			;;		ld a, l 
9fb6			;;		add h 
9fb6			;;		cp 0 
9fb6			;		pop af 
9fb6			;		 
9fb6			;		call z,malloc_error 
9fb6			;	endif 
9fb6			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9fb6			; 
9fb6			; 
9fb6			;if DEBUG_FORTH_TOK 
9fb6			;			DMARK "TKR" 
9fb6			;	CALLMONITOR 
9fb6			;endif 
9fb6			; 
9fb6			;	FORTH_RSP_NEXT 
9fb6			; 
9fb6			;	;inc hl	 ; go past current buffer pointer 
9fb6			;	;inc hl 
9fb6			;	;inc hl   ; and past if loop flag 
9fb6			;		; TODO Need to set flag  
9fb6			; 
9fb6			;	 
9fb6			;	 
9fb6			;	ex de,hl	; malloc is dest 
9fb6			;	ld hl, (os_tok_len) 
9fb6			;;	pop bc 
9fb6			;	ld c, l                
9fb6			;	ld b,0 
9fb6			;	ld hl, (os_tok_ptr) 
9fb6			; 
9fb6			;if DEBUG_FORTH_TOK 
9fb6			;			DMARK "TKT" 
9fb6			;	CALLMONITOR 
9fb6			;endif 
9fb6			; 
9fb6			;	; do str cpy 
9fb6			; 
9fb6			;	ldir      ; copy byte in hl to de 
9fb6			; 
9fb6			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9fb6			; 
9fb6			;if DEBUG_FORTH_TOK 
9fb6			; 
9fb6			;			DMARK "TKY" 
9fb6			;	CALLMONITOR 
9fb6			;endif 
9fb6			;	;ld a,0 
9fb6			;	;ld a,FORTH_END_BUFFER 
9fb6			;	ex de, hl 
9fb6			;	;dec hl			 ; go back over the space delim at the end of word 
9fb6			;	;ld (hl),a 
9fb6			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9fb6			;	ld a,FORTH_END_BUFFER 
9fb6			;	ld (hl),a 
9fb6			;	inc hl 
9fb6			;	ld a,FORTH_END_BUFFER 
9fb6			;	ld (hl),a 
9fb6			; 
9fb6			;	; init the malloc area data 
9fb6			;	; set pc for in current area 
9fb6			;	;ld hl, (os_tok_malloc) 
9fb6			;	;inc hl 
9fb6			;	;inc hl 
9fb6			;	;inc hl 
9fb6			;	;ex de,hl 
9fb6			;	;ld hl, (os_tok_malloc) 
9fb6			;	;ld (hl),e 
9fb6			;	;inc hl 
9fb6			;	;ld (hl),d 
9fb6			; 
9fb6			; 
9fb6			;	ld hl,(os_tok_malloc) 
9fb6			;if DEBUG_FORTH_PARSE_KEY 
9fb6			;			DMARK "TKU" 
9fb6			;	CALLMONITOR 
9fb6			;endif 
9fb6			; 
9fb6			;	ret 
9fb6			 
9fb6			forthexec: 
9fb6			 
9fb6			; line exec: 
9fb6			; forth parser 
9fb6			 
9fb6			; 
9fb6			;       get current exec line on rsp 
9fb6			 
9fb6				FORTH_RSP_TOS 
9fb6 cd 39 9b			call macro_forth_rsp_tos 
9fb9				endm 
# End of macro FORTH_RSP_TOS
9fb9			 
9fb9			;       restore current pc - hl points to malloc of data 
9fb9			 
9fb9				;ld e, (hl) 
9fb9				;inc hl 
9fb9				;ld d, (hl) 
9fb9				;ex de,hl 
9fb9			 
9fb9			 
9fb9			exec1: 
9fb9 22 c8 e5			ld (os_tok_ptr), hl 
9fbc			 
9fbc				; copy our PC to working vars  
9fbc 22 46 ea			ld (cli_ptr), hl 
9fbf 22 44 ea			ld (cli_origptr), hl 
9fc2			 
9fc2 7e				ld a,(hl) 
9fc3 fe 7f			cp FORTH_END_BUFFER 
9fc5 c8				ret z 
9fc6			 
9fc6				; skip any nulls 
9fc6			 
9fc6 fe 00			cp 0 
9fc8 20 03			jr nz, .execword 
9fca 23				inc hl 
9fcb 18 ec			jr exec1 
9fcd			 
9fcd			 
9fcd			.execword: 
9fcd			 
9fcd			 
9fcd			 
9fcd			if DEBUG_FORTH_PARSE_KEY 
9fcd						DMARK "KYQ" 
9fcd				CALLMONITOR 
9fcd			endif 
9fcd			;       while at start of word: 
9fcd			; get start of dict (in user area first) 
9fcd			 
9fcd 21 7d e3		ld hl, baseram 
9fd0			;ld hl, sysdict 
9fd0 22 48 ea		ld (cli_nextword),hl 
9fd3			;           match word at pc 
9fd3			;           exec word 
9fd3			;           or push to dsp 
9fd3			;           forward to next token 
9fd3			;           if line term pop rsp and exit 
9fd3			;        
9fd3			 
9fd3			if DEBUG_FORTH_PARSE_KEY 
9fd3						DMARK "KYq" 
9fd3				CALLMONITOR 
9fd3			endif 
9fd3			 
9fd3			; 
9fd3			; word comp 
9fd3			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9fd3			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9fd3			;    move to start of word  
9fd3			;    compare word to cli_token 
9fd3			 
9fd3			.execpnword:	; HL at start of a word in the dictionary to check 
9fd3			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9fd3			;	ld (cli_ptr), hl 
9fd3			 
9fd3 2a 48 ea			ld hl,(cli_nextword) 
9fd6			 
9fd6 cd 79 a0			call forth_tok_next 
9fd9			; tok next start here 
9fd9			;	; TODO skip compiled symbol for now 
9fd9			;	inc hl 
9fd9			; 
9fd9			;	; save pointer to next word 
9fd9			; 
9fd9			;	; hl now points to the address of the next word pointer  
9fd9			;	ld e, (hl) 
9fd9			;	inc hl 
9fd9			;	ld d, (hl) 
9fd9			;	inc l 
9fd9			; 
9fd9			;	ex de,hl 
9fd9			;if DEBUG_FORTH_PARSE_NEXTWORD 
9fd9			;	push bc 
9fd9			;	ld bc, (cli_nextword) 
9fd9			;			DMARK "NXW" 
9fd9			;	CALLMONITOR 
9fd9			;	pop bc 
9fd9			;endif 
9fd9			; tok next end here 
9fd9 22 48 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9fdc eb				ex de, hl 
9fdd			 
9fdd			 
9fdd				; save the pointer of the current token - 1 to check against 
9fdd				 
9fdd 22 4c ea			ld (cli_token), hl   
9fe0				; TODO maybe remove below save if no debug 
9fe0				; save token string ptr for any debug later 
9fe0 23				inc hl  
9fe1 22 4e ea			ld (cli_origtoken), hl 
9fe4 2b				dec hl 
9fe5				; save pointer to the start of the next dictionay word 
9fe5 7e				ld a,(hl)   ; get string length 
9fe6 47				ld b,a 
9fe7			.execpnwordinc:  
9fe7 23				inc hl 
9fe8 10 fd			djnz .execpnwordinc 
9fea 22 4a ea			ld (cli_execword), hl      ; save start of this words code 
9fed			 
9fed				; now check the word token against the string being parsed 
9fed			 
9fed 2a 4c ea			ld hl,(cli_token) 
9ff0 23				inc hl     ; skip string length (use zero term instead to end) 
9ff1 22 4c ea			ld (cli_token), hl 
9ff4			 
9ff4			if DEBUG_FORTH_PARSE_KEY 
9ff4						DMARK "KY2" 
9ff4			endif 
9ff4			if DEBUG_FORTH_PARSE_EXEC 
9ff4				; see if disabled 
9ff4			 
9ff4				ld a, (os_view_disable) 
9ff4				cp '*' 
9ff4				jr z, .skip 
9ff4			 
9ff4				push hl 
9ff4				push hl 
9ff4				call clear_display 
9ff4				ld de, .compword 
9ff4				ld a, display_row_1 
9ff4				call str_at_display 
9ff4				pop de 
9ff4				ld a, display_row_2 
9ff4				call str_at_display 
9ff4				ld hl,(cli_ptr) 
9ff4				ld a,(hl) 
9ff4			        ld hl, os_word_scratch 
9ff4				ld (hl),a 
9ff4				ld a,0 
9ff4				inc hl 
9ff4				ld (hl),a 	 
9ff4				ld de, os_word_scratch 
9ff4				ld a, display_row_2+10 
9ff4				call str_at_display 
9ff4				call update_display 
9ff4				ld a, 100 
9ff4				call aDelayInMS 
9ff4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ff4				call delay250ms 
9ff4				endif 
9ff4				pop hl 
9ff4			.skip:  
9ff4			endif	 
9ff4			.execpnchar:    ; compare char between token and string to parse 
9ff4			 
9ff4			if DEBUG_FORTH_PARSE_KEY 
9ff4						DMARK "Ky3" 
9ff4			endif 
9ff4			if DEBUG_FORTH_PARSE_EXEC 
9ff4				; see if disabled 
9ff4			 
9ff4				ld a, (os_view_disable) 
9ff4				cp '*' 
9ff4				jr z, .skip2 
9ff4			 
9ff4			;	call clear_display 
9ff4			ld hl,(cli_token) 
9ff4			ld a,(hl) 
9ff4			ld (os_word_scratch),a 
9ff4				ld hl,(cli_ptr) 
9ff4			ld a,(hl) 
9ff4				ld (os_word_scratch+1),a 
9ff4				ld a,0 
9ff4				ld (os_word_scratch+2),a 
9ff4				ld de,os_word_scratch 
9ff4				ld a,display_row_4 
9ff4				call str_at_display 
9ff4				call update_display 
9ff4			.skip2:  
9ff4			endif 
9ff4 2a 4c ea			ld hl,(cli_token) 
9ff7 7e				ld a, (hl)	 ; char in word token 
9ff8 23				inc hl 		; move to next char 
9ff9 22 4c ea			ld (cli_token), hl ; and save it 
9ffc 47				ld b,a 
9ffd			 
9ffd 2a 46 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
a000 7e				ld a,(hl) 
a001 23				inc hl 
a002 22 46 ea			ld (cli_ptr), hl		; move to next char 
a005 cd 31 91			call toUpper 		; make sure the input string matches case 
a008			 
a008			if DEBUG_FORTH_PARSE 
a008			endif 
a008			 
a008				; input stream end of token is a space so get rid of it 
a008			 
a008			;	cp ' ' 
a008			;	jr nz, .pnskipspace 
a008			; 
a008			;	ld a, 0		; make same term as word token term 
a008			; 
a008			;.pnskipspace: 
a008			 
a008			if DEBUG_FORTH_PARSE_KEY 
a008						DMARK "KY7" 
a008			endif 
a008 b8				cp b 
a009 c2 1f a0			jp nz, .execpnskipword	 ; no match so move to next word 
a00c				 
a00c			;    if same 
a00c			;       scan for string terms 0 for token and 32 for input 
a00c			 
a00c				 
a00c			if DEBUG_FORTH_PARSE_KEY 
a00c						DMARK "KY8" 
a00c			endif 
a00c			 
a00c 80				add b			 
a00d fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
a00f							; TODO need to make sure last word in zero term string is accounted for 
a00f 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
a011			 
a011			 
a011				; at end of both strings so both are exact match 
a011			 
a011			;       skip ptr for next word 
a011			 
a011 2a 46 ea			ld hl,(cli_ptr) 	; at input string term 
a014 23				inc hl			 ; at next char 
a015 22 46 ea			ld (cli_ptr), hl     ; save for next round of the parser 
a018 22 44 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
a01b				 
a01b				 
a01b			if DEBUG_FORTH_PARSE_KEY 
a01b						DMARK "KY3" 
a01b			endif 
a01b			 
a01b			 
a01b			 
a01b			;       exec code block 
a01b			if DEBUG_FORTH_JP 
a01b				call clear_display 
a01b				call update_display 
a01b				call delay1s 
a01b				ld hl, (cli_execword)     ; save for next check if no match on this word 
a01b				ld a,h 
a01b				ld hl, os_word_scratch 
a01b				call hexout 
a01b				ld hl, (cli_execword)     ; save for next check if no match on this word 
a01b				ld a,l 
a01b				ld hl, os_word_scratch+2 
a01b				call hexout 
a01b				ld hl, os_word_scratch+4 
a01b				ld a,0 
a01b				ld (hl),a 
a01b				ld de,os_word_scratch 
a01b				call str_at_display 
a01b					ld a, display_row_2 
a01b					call str_at_display 
a01b				ld de, (cli_origtoken) 
a01b				ld a, display_row_1+10 
a01b					call str_at_display 
a01b			 
a01b				ld a,display_row_1 
a01b				ld de, .foundword 
a01b				ld a, display_row_3 
a01b				call str_at_display 
a01b				call update_display 
a01b				call delay1s 
a01b				call delay1s 
a01b				call delay1s 
a01b			endif 
a01b			 
a01b			if DEBUG_FORTH_PARSE_KEY 
a01b						DMARK "KYj" 
a01b			endif 
a01b				; TODO save the word pointer in this exec 
a01b			 
a01b 2a 4a ea			ld hl,(cli_execword) 
a01e e9				jp (hl) 
a01f			 
a01f			 
a01f			;    if not same 
a01f			;	scan for zero term 
a01f			;	get ptr for next word 
a01f			;	goto word comp 
a01f			 
a01f			.execpnskipword:	; get pointer to next word 
a01f 2a 48 ea			ld hl,(cli_nextword) 
a022			 
a022 7e				ld a,(hl) 
a023 fe 00			cp WORD_SYS_END 
a025			;	cp 0 
a025 28 09			jr z, .execendofdict			 ; at end of words 
a027			 
a027			if DEBUG_FORTH_PARSE_KEY 
a027						DMARK "KY4" 
a027			endif 
a027			if DEBUG_FORTH_PARSE_EXEC 
a027			 
a027				; see if disabled 
a027			 
a027				ld a, (os_view_disable) 
a027				cp '*' 
a027				jr z, .noskip 
a027			 
a027			 
a027				ld de, .nowordfound 
a027				ld a, display_row_3 
a027				call str_at_display 
a027				call update_display 
a027				ld a, 100 
a027				call aDelayInMS 
a027				 
a027				if DEBUG_FORTH_PARSE_EXEC_SLOW 
a027					call delay250ms 
a027				endif 
a027			.noskip:  
a027			 
a027			endif	 
a027			 
a027 2a 44 ea			ld hl,(cli_origptr) 
a02a 22 46 ea			ld (cli_ptr),hl 
a02d			 
a02d			if DEBUG_FORTH_PARSE_KEY 
a02d						DMARK "KY5" 
a02d			endif 
a02d c3 d3 9f			jp .execpnword			; else go to next word 
a030			 
a030			.execendofdict:  
a030			 
a030			if DEBUG_FORTH_PARSE_KEY 
a030						DMARK "KYe" 
a030			endif 
a030			if DEBUG_FORTH_PARSE_EXEC 
a030				; see if disabled 
a030			 
a030				ld a, (os_view_disable) 
a030				cp '*' 
a030				jr z, .ispskip 
a030			 
a030				call clear_display 
a030				call update_display 
a030				call delay1s 
a030				ld de, (cli_origptr) 
a030				ld a, display_row_1 
a030				call str_at_display 
a030				 
a030				ld de, .enddict 
a030				ld a, display_row_3 
a030				call str_at_display 
a030				call update_display 
a030				ld a, 100 
a030				call aDelayInMS 
a030				if DEBUG_FORTH_PARSE_EXEC_SLOW 
a030				call delay1s 
a030				call delay1s 
a030				call delay1s 
a030				endif 
a030			.ispskip:  
a030				 
a030			endif	 
a030			 
a030			 
a030			 
a030				; if the word is not a keyword then must be a literal so push it to stack 
a030			 
a030			; push token to stack to end of word 
a030			 
a030				STACKFRAME ON $1efe $2f9f 
a030				if DEBUG_STACK_IMB 
a030					if ON 
a030						exx 
a030						ld de, $1efe 
a030						ld a, d 
a030						ld hl, curframe 
a030						call hexout 
a030						ld a, e 
a030						ld hl, curframe+2 
a030						call hexout 
a030						ld hl, $1efe 
a030						push hl 
a030						ld hl, $2f9f 
a030						push hl 
a030						exx 
a030					endif 
a030				endif 
a030			endm 
# End of macro STACKFRAME
a030			 
a030 2a c8 e5		ld hl,(os_tok_ptr) 
a033 cd e4 9c		call forth_apush 
a036			 
a036				STACKFRAMECHK ON $1efe $2f9f 
a036				if DEBUG_STACK_IMB 
a036					if ON 
a036						exx 
a036						ld hl, $2f9f 
a036						pop de   ; $2f9f 
a036						call cmp16 
a036						jr nz, .spnosame 
a036						ld hl, $1efe 
a036						pop de   ; $1efe 
a036						call cmp16 
a036						jr z, .spfrsame 
a036						.spnosame: call showsperror 
a036						.spfrsame: nop 
a036						exx 
a036					endif 
a036				endif 
a036			endm 
# End of macro STACKFRAMECHK
a036			 
a036			execnext: 
a036			 
a036			if DEBUG_FORTH_PARSE_KEY 
a036						DMARK "KY>" 
a036			endif 
a036			; move past token to next word 
a036			 
a036 2a c8 e5		ld hl, (os_tok_ptr) 
a039 3e 00		ld a, 0 
a03b 01 ff 00		ld bc, 255     ; input buffer size 
a03e ed b1		cpir 
a040			 
a040			if DEBUG_FORTH_PARSE_KEY 
a040						DMARK "KY!" 
a040				CALLMONITOR 
a040			endif	 
a040			; TODO this might place hl on the null, so will need to forward on??? 
a040			;inc hl   ; see if this gets onto the next item 
a040			 
a040			 
a040			; TODO pass a pointer to the buffer to push 
a040			; TODO call function to push 
a040			 
a040			; look for end of input 
a040			 
a040			;inc hl 
a040			;ld a,(hl) 
a040			;cp FORTH_END_BUFFER 
a040			;ret z 
a040			 
a040			 
a040 c3 b9 9f		jp exec1 
a043			 
a043			 
a043			 
a043			 
a043			 
a043			 
a043			 
a043			 
a043			 
a043			findnexttok: 
a043			 
a043				; hl is pointer to move 
a043				; de is the token to locate 
a043			 
a043					if DEBUG_FORTH 
a043						DMARK "NTK" 
a043						CALLMONITOR 
a043					endif 
a043 d5				push de 
a044			 
a044			.fnt1:	 
a044				; find first char of token to locate 
a044			 
a044 1a				ld a, (de) 
a045 4f				ld c,a 
a046 7e				ld a,(hl) 
a047 cd 31 91			call toUpper 
a04a					if DEBUG_FORTH 
a04a						DMARK "NT1" 
a04a						CALLMONITOR 
a04a					endif 
a04a b9				cp c 
a04b			 
a04b 28 03			jr z, .fnt2cmpmorefirst	 
a04d			 
a04d				; first char not found move to next char 
a04d			 
a04d 23				inc hl 
a04e 18 f4			jr .fnt1 
a050			 
a050			.fnt2cmpmorefirst:	 
a050				; first char of token found.  
a050			 
a050 e5				push hl     ; save start of token just in case it is the right one 
a051 d9				exx 
a052 e1				pop hl        ; save it to hl' 
a053 d9				exx 
a054			 
a054			 
a054			.fnt2cmpmore:	 
a054				; compare the rest 
a054				 
a054 23				inc hl 
a055 13				inc de 
a056				 
a056 1a				ld a, (de) 
a057 4f				ld c,a 
a058 7e				ld a,(hl) 
a059 cd 31 91			call toUpper 
a05c			 
a05c					if DEBUG_FORTH 
a05c						DMARK "NT2" 
a05c						CALLMONITOR 
a05c					endif 
a05c				; c has the token to find char 
a05c				; a has the mem to scan char 
a05c			 
a05c b9				cp c 
a05d 28 04			jr z,.fntmatch1 
a05f			 
a05f				; they are not the same 
a05f			 
a05f					if DEBUG_FORTH 
a05f						DMARK "NT3" 
a05f						CALLMONITOR 
a05f					endif 
a05f d1				pop de	; reset de token to look for 
a060 d5				push de 
a061 18 e1			jr .fnt1 
a063				 
a063			.fntmatch1: 
a063			 
a063				; is the same char a null which means we might have a full hit? 
a063					if DEBUG_FORTH 
a063						DMARK "NT4" 
a063						CALLMONITOR 
a063					endif 
a063			 
a063 fe 00			cp 0 
a065 28 0b			jr z, .fntmatchyes 
a067			 
a067				; are we at the end of the token to find? 
a067			 
a067					if DEBUG_FORTH 
a067						DMARK "NT5" 
a067						CALLMONITOR 
a067					endif 
a067 3e 00			ld a, 0 
a069 b9				cp c 
a06a			 
a06a c2 54 a0			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
a06d			 
a06d					if DEBUG_FORTH 
a06d						DMARK "NT6" 
a06d						CALLMONITOR 
a06d					endif 
a06d				; token to find is exhusted but no match to stream 
a06d			 
a06d				; restore tok pointer and continue on 
a06d d1				pop de 
a06e d5				push de 
a06f c3 44 a0			jp .fnt1 
a072			 
a072			 
a072			.fntmatchyes: 
a072			 
a072				; hl now contains the end of the found token 
a072			 
a072				; get rid of saved token pointer to find 
a072			 
a072 d1				pop de 
a073			 
a073					if DEBUG_FORTH 
a073						DMARK "NT9" 
a073						CALLMONITOR 
a073					endif 
a073			 
a073				; hl will be on the null term so forward on 
a073			 
a073				; get back the saved start of the token 
a073			 
a073 d9				exx 
a074 e5				push hl     ; save start of token just in case it is the right one 
a075 d9				exx 
a076 e1				pop hl        ; save it to hl 
a077			 
a077 c9				ret 
a078			 
a078			 
a078			; LIST needs to find a specific token   
a078			; FORGET needs to find a spefici token 
a078			 
a078			; SAVE needs to find all tokens by flag 
a078			; WORDS just needs to scan through all  by flag 
a078			; UWORDS needs to scan through all by flag 
a078			 
a078			 
a078			; given hl as pointer to start of dict look up string 
a078			; return hl as pointer to start of word block 
a078			; or 0 if not found 
a078			 
a078			forth_find_tok: 
a078 c9				ret 
a079			 
a079			; given hl as pointer to dict structure 
a079			; move to the next dict block structure 
a079			 
a079			forth_tok_next: 
a079				; hl now points to the address of the next word pointer  
a079				; TODO skip compiled symbol for now 
a079			;	push de 
a079 23				inc hl 
a07a 5e				ld e, (hl) 
a07b 23				inc hl 
a07c 56				ld d, (hl) 
a07d 23				inc hl 
a07e			 
a07e eb				ex de,hl 
a07f			if DEBUG_FORTH_PARSE_NEXTWORD 
a07f				push bc 
a07f				ld bc, (cli_nextword) 
a07f						DMARK "NXW" 
a07f				CALLMONITOR 
a07f				pop bc 
a07f			endif 
a07f			;	pop de	 
a07f c9				ret 
a080			 
a080			 
a080			 
a080			; eof 
# End of file forth_parserv5.asm
a080				include "forth_wordsv4.asm" 
a080			 
a080			; the core word dictionary v4 
a080			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a080			 
a080			; this is a linked list for each of the system words used 
a080			; user defined words will follow the same format but will be in ram 
a080			 
a080			 
a080			; 
a080			; 
a080			; define linked list: 
a080			; 
a080			; 1. compiled byte op code 
a080			; 2. len of text word 
a080			; 3. text word 
a080			; 4. ptr to next dictionary word 
a080			; 5. asm, calls etc for the word 
a080			; 
a080			;  if 1 == 0 then last word in dict  
a080			;   
a080			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a080			;  
a080			;  
a080			; create basic standard set of words 
a080			; 
a080			;  
a080			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a080			; 2DUP 2DROP 2SWAP  
a080			; @ C@ - get byte  
a080			; ! C! - store byte 
a080			; 0< true if less than zero 
a080			; 0= true if zero 
a080			; < >  
a080			; = true if same 
a080			; variables 
a080			 
a080			 
a080			; Hardware specific words I may need 
a080			; 
a080			; IN OUT  
a080			; calls to key util functions 
a080			; calls to hardward abstraction stuff 
a080			; easy control of frame buffers and lcd i/o 
a080			; keyboard  
a080			 
a080			 
a080			;DICT: macro 
a080			; op_code, len, word, next 
a080			;    word: 
a080			;    db op_code 
a080			;    ds word zero term 
a080			;    dw next 
a080			;    endm 
a080			 
a080			 
a080			 
a080			 
a080			; op code 1 is a flag for user define words which are to be handled differently 
a080			 
a080			 
a080			; 
a080			; 
a080			;    TODO on entry to a word this should be the expected environment 
a080			;    hl - tos value if number then held, if string this is the ptr 
a080			;    de -  
a080			 
a080			 
a080			; opcode ranges 
a080			; 0 - end of word dict 
a080			; 255 - user define words 
a080			 
a080			sysdict: 
a080			include "forth_opcodes.asm" 
a080			; op codes for forth keywords 
a080			; free to use code 0  
a080				OPCODE_HEAP: equ  1 
a080				OPCODE_EXEC: equ 2 
a080				OPCODE_DUP: equ 3 
a080				OPCODE_SWAP: equ 4 
a080				OPCODE_COLN: equ 5 
a080				OPCODE_SCOLN: equ 6 
a080				OPCODE_DROP: equ 7 
a080				OPCODE_DUP2: equ 8 
a080				OPCODE_DROP2: equ 9 
a080				OPCODE_SWAP2: equ 10 
a080				OPCODE_AT: equ 11 
a080				OPCODE_CAT: equ 12 
a080				OPCODE_BANG: equ 13 
a080				OPCODE_CBANG: equ 14 
a080				OPCODE_SCALL: equ 15 
a080				OPCODE_DEPTH: equ 16 
a080				OPCODE_OVER: equ 17 
a080				OPCODE_PAUSE: equ 18 
a080				OPCODE_PAUSES: equ 19 
a080				OPCODE_ROT: equ 20 
a080			;free to reuse	OPCODE_WORDS: equ 21 
a080			        OPCODE_NOT: equ 21 
a080				OPCODE_UWORDS: equ 22 
a080				OPCODE_BP: equ 23 
a080				OPCODE_MONITOR: equ 24  
a080				OPCODE_MALLOC: equ 25 
a080				OPCODE_FREE: equ 26 
a080				OPCODE_LIST: equ 27 
a080				OPCODE_FORGET: equ 28 
a080				OPCODE_NOP: equ 29 
a080				OPCODE_COMO: equ 30 
a080				OPCODE_COMC: equ 31 
a080			;free to reuse	OPCODE_ENDCORE: equ 32 
a080				OPCODE_AFTERSOUND: equ 33 
a080				OPCODE_GP2: equ 34 
a080				OPCODE_GP3: equ 35 
a080				OPCODE_GP4: equ 36 
a080				OPCODE_SIN: equ 37 
a080				OPCODE_SOUT: equ 38 
a080				OPCODE_SPIO: equ 39 
a080				OPCODE_SPICEH: equ 40 
a080				OPCODE_SPIOb: equ 41 
a080				OPCODE_SPII: equ 42 
a080				OPCODE_SESEL: equ 43 
a080				OPCODE_CARTDEV: equ 44 
a080			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a080				OPCODE_FB: equ 46 
a080				OPCODE_EMIT: equ 47 
a080				OPCODE_DOTH: equ 48 
a080				OPCODE_DOTF: equ 49 
a080				OPCODE_DOT: equ 50 
a080				OPCODE_CLS: equ 51 
a080				OPCODE_DRAW: equ 52 
a080				OPCODE_DUMP: equ 53 
a080				OPCODE_CDUMP: equ 54 
a080				OPCODE_DAT: equ 55 
a080				OPCODE_HOME: equ 56 
a080				OPCODE_SPACE: equ 57 
a080				OPCODE_SPACES: equ 58 
a080				OPCODE_SCROLL: equ 59 
a080				OPCODE_ATQ: equ 60 
a080				OPCODE_AUTODSP: equ 61 
a080				OPCODE_MENU: equ 62 
a080			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a080				OPCODE_THEN: equ 64 
a080				OPCODE_ELSE: equ 65 
a080				OPCODE_DO: equ 66 
a080				OPCODE_LOOP: equ 67 
a080				OPCODE_I: equ 68 
a080				OPCODE_DLOOP: equ 69  
a080				OPCODE_REPEAT: equ 70  
a080				OPCODE_UNTIL: equ 71 
a080				OPCODE_ENDFLOW: equ 72 
a080				OPCODE_WAITK: equ 73 
a080				OPCODE_ACCEPT: equ 74 
a080				OPCODE_EDIT: equ 75 
a080			;free to reuse	OPCODE_ENDKEY: equ 76 
a080				OPCODE_LZERO: equ 77 
a080				OPCODE_TZERO: equ 78 
a080				OPCODE_LESS: equ 79 
a080				OPCODE_GT: equ 80 
a080				OPCODE_EQUAL: equ 81  
a080			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a080				OPCODE_NEG: equ 83 
a080				OPCODE_DIV: equ 84 
a080				OPCODE_MUL: equ 85 
a080				OPCODE_MIN: equ 86 
a080				OPCODE_MAX: equ 87 
a080				OPCODE_RND16: equ 88 
a080				OPCODE_RND8: equ 89 
a080				OPCODE_RND: equ 90 
a080			;free to reuse	OPCODE_ENDMATHS: equ 91  
a080				OPCODE_BYNAME: equ 92 
a080				OPCODE_DIR: equ 93 
a080				OPCODE_SAVE: equ 94 
a080				OPCODE_LOAD: equ 95 
a080				OPCODE_BSAVE: equ 96 
a080				OPCODE_BLOAD: equ 97 
a080				OPCODE_SEO: equ 98  
a080				OPCODE_SEI: equ 99 
a080				OPCODE_SFREE: equ 100 
a080				OPCODE_SIZE: equ 101 
a080				OPCODE_CREATE: equ 102 
a080				OPCODE_APPEND: equ 103 
a080				OPCODE_SDEL: equ 104 
a080				OPCODE_OPEN: equ 105 
a080				OPCODE_READ: equ 106 
a080				OPCODE_EOF: equ 106 
a080				OPCODE_FORMAT: equ 107 
a080				OPCODE_LABEL: equ 108 
a080				OPCODE_LABELS: equ 109 
a080			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a080				OPCODE_UPPER: equ 111 
a080				OPCODE_LOWER: equ 112 
a080				OPCODE_SUBSTR: equ 113 
a080				OPCODE_LEFT: equ 114 
a080				OPCODE_RIGHT: equ 115 
a080				OPCODE_STR2NUM: equ 116 
a080				OPCODE_NUM2STR: equ 117 
a080				OPCODE_CONCAT: equ 118 
a080				OPCODE_FIND: equ 119 
a080				OPCODE_LEN: equ 120 
a080				OPCODE_CHAR: equ 121 
a080			; free to reuse	OPCODE_STRLEN: equ 122 
a080			; free to reuse	OPCODE_ENDSTR: equ 123 
a080				OPCODE_V0S: equ 124 
a080				OPCODE_V0Q: equ 125 
a080				OPCODE_V1S: equ 126 
a080				OPCODE_V1Q: equ 127 
a080				OPCODE_V2S: equ 128 
a080				OPCODE_V2Q: equ 129 
a080				OPCODE_V3S: equ 130 
a080				OPCODE_V3Q: equ 131 
a080			;free to reuse	OPCODE_END: equ 132 
a080				OPCODE_ZDUP: equ 133 
a080			 
a080			; eof 
# End of file forth_opcodes.asm
a080			 
a080			include "forth_words_core.asm" 
a080			 
a080			; | ## Core Words 
a080			 
a080			;if MALLOC_4 
a080			 
a080			.HEAP: 
a080				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a080 15				db WORD_SYS_CORE+OPCODE_HEAP             
a081 bf a0			dw .EXEC            
a083 05				db 4 + 1 
a084 .. 00			db "HEAP",0              
a089				endm 
# End of macro CWHEAD
a089			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a089			; | | u1 - Current number of bytes in the heap 
a089			; | | u2 - Remaining bytes left on the heap 
a089			; | |  
a089			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a089			 
a089			 
a089					if DEBUG_FORTH_WORDS_KEY 
a089						DMARK "HEP" 
a089 f5				push af  
a08a 3a 9e a0			ld a, (.dmark)  
a08d 32 71 ee			ld (debug_mark),a  
a090 3a 9f a0			ld a, (.dmark+1)  
a093 32 72 ee			ld (debug_mark+1),a  
a096 3a a0 a0			ld a, (.dmark+2)  
a099 32 73 ee			ld (debug_mark+2),a  
a09c 18 03			jr .pastdmark  
a09e ..			.dmark: db "HEP"  
a0a1 f1			.pastdmark: pop af  
a0a2			endm  
# End of macro DMARK
a0a2						CALLMONITOR 
a0a2 cd dd 94			call break_point_state  
a0a5				endm  
# End of macro CALLMONITOR
a0a5					endif 
a0a5 2a 87 e3				ld hl, (free_list )      
a0a8 11 8c e3				ld de, heap_start 
a0ab			 
a0ab ed 52				sbc hl, de  
a0ad			 
a0ad cd 7b 9b				call forth_push_numhl 
a0b0			 
a0b0			 
a0b0 ed 5b 87 e3			ld de, (free_list )      
a0b4 21 ad e2				ld hl, heap_end 
a0b7			 
a0b7 ed 52				sbc hl, de 
a0b9			 
a0b9 cd 7b 9b				call forth_push_numhl 
a0bc					 
a0bc			 
a0bc					 
a0bc			 
a0bc			 
a0bc			 
a0bc					NEXTW 
a0bc c3 28 9f			jp macro_next 
a0bf				endm 
# End of macro NEXTW
a0bf			;endif 
a0bf			 
a0bf			.EXEC: 
a0bf			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a0bf			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a0bf			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a0bf			;; > > 
a0bf			;; > >   
a0bf			;	STACKFRAME OFF $5efe $5f9f 
a0bf			; 
a0bf			;		if DEBUG_FORTH_WORDS_KEY 
a0bf			;			DMARK "EXE" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			; 
a0bf			;	FORTH_DSP_VALUEHL 
a0bf			; 
a0bf			;	FORTH_DSP_POP 
a0bf			; 
a0bf			;		if DEBUG_FORTH_WORDS 
a0bf			;			DMARK "EX1" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			;;	ld e,(hl) 
a0bf			;;	inc hl 
a0bf			;;	ld d,(hl) 
a0bf			;;	ex de,hl 
a0bf			; 
a0bf			;;		if DEBUG_FORTH_WORDS 
a0bf			;;			DMARK "EX2" 
a0bf			;;			CALLMONITOR 
a0bf			;;		endif 
a0bf			;	push hl 
a0bf			; 
a0bf			;	;ld a, 0 
a0bf			;	;ld a, FORTH_END_BUFFER 
a0bf			;	call strlenz 
a0bf			;	inc hl   ; include zero term to copy 
a0bf			;	inc hl   ; include term 
a0bf			;	inc hl   ; include term 
a0bf			;	ld b,0 
a0bf			;	ld c,l 
a0bf			;	pop hl 
a0bf			;	ld de, execscratch 
a0bf			;		if DEBUG_FORTH_WORDS 
a0bf			;			DMARK "EX3" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			;	ldir 
a0bf			; 
a0bf			; 
a0bf			;	ld hl, execscratch 
a0bf			; 
a0bf			;		if DEBUG_FORTH_WORDS 
a0bf			;			DMARK "EXe" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			; 
a0bf			;	call forthparse 
a0bf			;	call forthexec 
a0bf			;;	call forthexec_cleanup 
a0bf			;;	call forthparse 
a0bf			;;	call forthexec 
a0bf			; 
a0bf			;	STACKFRAMECHK OFF $5efe $5f9f 
a0bf			; 
a0bf			;	; an immediate word so no need to process any more words 
a0bf			;	ret 
a0bf			;	NEXTW 
a0bf			 
a0bf			; dead code - old version  
a0bf			;	FORTH_RSP_NEXT 
a0bf			 
a0bf			;  
a0bf			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a0bf			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a0bf			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a0bf			;	push hl 
a0bf			;	push de 
a0bf			;	push bc 
a0bf			; 
a0bf			; 
a0bf			;		if DEBUG_FORTH_WORDS_KEY 
a0bf			;			DMARK "EXR" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			; 
a0bf			; 
a0bf			; 
a0bf			;	;v5 FORTH_DSP_VALUE 
a0bf			;	FORTH_DSP_VALUEHL 
a0bf			; 
a0bf			;	; TODO do string type checks 
a0bf			; 
a0bf			;;v5	inc hl   ; skip type 
a0bf			; 
a0bf			;	push hl  ; source code  
a0bf			;		if DEBUG_FORTH_WORDS 
a0bf			;			DMARK "EX1" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			;	ld a, 0 
a0bf			;	call strlent 
a0bf			; 
a0bf			;	inc hl 
a0bf			;	inc hl 
a0bf			;	inc hl 
a0bf			;	inc hl 
a0bf			; 
a0bf			;	push hl    ; size 
a0bf			; 
a0bf			;		if DEBUG_FORTH_WORDS 
a0bf			;			DMARK "EX2" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			;	call malloc 
a0bf			; 
a0bf			;	ex de, hl    ; de now contains malloc area 
a0bf			;	pop bc   	; get byte count 
a0bf			;	pop hl      ; get string to copy 
a0bf			; 
a0bf			;	push de     ; save malloc for free later 
a0bf			; 
a0bf			;		if DEBUG_FORTH_WORDS 
a0bf			;			DMARK "EX3" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			;	ldir       ; duplicate string 
a0bf			; 
a0bf			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a0bf			;	 
a0bf			;	; TODO fix the parse would be better than this...  
a0bf			;	ex de, hl 
a0bf			;	dec hl 
a0bf			;	ld a, 0 
a0bf			;	ld (hl), a 
a0bf			;	dec hl 
a0bf			;	ld a, ' ' 
a0bf			;	ld (hl), a 
a0bf			;	dec hl 
a0bf			;	ld (hl), a 
a0bf			; 
a0bf			;	dec hl 
a0bf			;	ld (hl), a 
a0bf			; 
a0bf			; 
a0bf			;	FORTH_DSP_POP  
a0bf			; 
a0bf			;	pop hl     
a0bf			;	push hl    ; save malloc area 
a0bf			; 
a0bf			;		if DEBUG_FORTH_WORDS 
a0bf			;			DMARK "EX4" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			; 
a0bf			;	call forthparse 
a0bf			;	call forthexec 
a0bf			;	 
a0bf			;	pop hl 
a0bf			;	if DEBUG_FORTH_WORDS 
a0bf			;		DMARK "EX5" 
a0bf			;		CALLMONITOR 
a0bf			;	endif 
a0bf			; 
a0bf			;	if FORTH_ENABLE_FREE 
a0bf			;	call free 
a0bf			;	endif 
a0bf			; 
a0bf			;	if DEBUG_FORTH_WORDS 
a0bf			;		DMARK "EX6" 
a0bf			;		CALLMONITOR 
a0bf			;	endif 
a0bf			; 
a0bf			;	pop bc 
a0bf			;	pop de 
a0bf			;	pop hl 
a0bf			;;	FORTH_RSP_POP	  
a0bf			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a0bf			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a0bf			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a0bf			; 
a0bf			;	if DEBUG_FORTH_WORDS 
a0bf			;		DMARK "EX7" 
a0bf			;		CALLMONITOR 
a0bf			;	endif 
a0bf			;	NEXTW 
a0bf			 
a0bf			;.STKEXEC: 
a0bf			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a0bf			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a0bf			; 
a0bf			; 
a0bf			;		if DEBUG_FORTH_WORDS_KEY 
a0bf			;			DMARK "STX" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			; 
a0bf			;	FORTH_DSP_VALUEHL 
a0bf			; 
a0bf			;	ld (store_tmp1), hl    ; count 
a0bf			; 
a0bf			;	FORTH_DSP_POP 
a0bf			;.stkexec1: 
a0bf			;	ld hl, (store_tmp1)   ; count 
a0bf			;	ld a, 0 
a0bf			;	cp l 
a0bf			;	ret z 
a0bf			; 
a0bf			;	dec hl 
a0bf			;	ld (store_tmp1), hl    ; count 
a0bf			;	 
a0bf			;	FORTH_DSP_VALUEHL 
a0bf			;	push hl 
a0bf			;	 
a0bf			;		if DEBUG_FORTH_WORDS 
a0bf			;			DMARK "EXp" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			;	FORTH_DSP_POP 
a0bf			; 
a0bf			;	call strlenz 
a0bf			;	inc hl   ; include zero term to copy 
a0bf			;	inc hl   ; include zero term to copy 
a0bf			;	inc hl   ; include zero term to copy 
a0bf			;	ld b,0 
a0bf			;	ld c,l 
a0bf			;	pop hl 
a0bf			;	ld de, execscratch 
a0bf			;		if DEBUG_FORTH_WORDS 
a0bf			;			DMARK "EX3" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			;	ldir 
a0bf			; 
a0bf			; 
a0bf			;	ld hl, execscratch 
a0bf			; 
a0bf			;		if DEBUG_FORTH_WORDS 
a0bf			;			DMARK "EXP" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			; 
a0bf			;	call forthparse 
a0bf			;	ld hl, execscratch 
a0bf			;		if DEBUG_FORTH_WORDS 
a0bf			;			DMARK "EXx" 
a0bf			;			CALLMONITOR 
a0bf			;		endif 
a0bf			;	call forthexec 
a0bf			; 
a0bf			;	jp .stkexec1 
a0bf			; 
a0bf			;	ret 
a0bf			 
a0bf			 
a0bf			.DUP: 
a0bf				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a0bf 17				db WORD_SYS_CORE+OPCODE_DUP             
a0c0 35 a1			dw .ZDUP            
a0c2 04				db 3 + 1 
a0c3 .. 00			db "DUP",0              
a0c7				endm 
# End of macro CWHEAD
a0c7			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a0c7			 
a0c7					if DEBUG_FORTH_WORDS_KEY 
a0c7						DMARK "DUP" 
a0c7 f5				push af  
a0c8 3a dc a0			ld a, (.dmark)  
a0cb 32 71 ee			ld (debug_mark),a  
a0ce 3a dd a0			ld a, (.dmark+1)  
a0d1 32 72 ee			ld (debug_mark+1),a  
a0d4 3a de a0			ld a, (.dmark+2)  
a0d7 32 73 ee			ld (debug_mark+2),a  
a0da 18 03			jr .pastdmark  
a0dc ..			.dmark: db "DUP"  
a0df f1			.pastdmark: pop af  
a0e0			endm  
# End of macro DMARK
a0e0						CALLMONITOR 
a0e0 cd dd 94			call break_point_state  
a0e3				endm  
# End of macro CALLMONITOR
a0e3					endif 
a0e3			 
a0e3					FORTH_DSP 
a0e3 cd 38 9d			call macro_forth_dsp 
a0e6				endm 
# End of macro FORTH_DSP
a0e6			 
a0e6 7e					ld a, (HL) 
a0e7 fe 01				cp DS_TYPE_STR 
a0e9 20 25				jr nz, .dupinum 
a0eb			 
a0eb					; push another string 
a0eb			 
a0eb					FORTH_DSP_VALUEHL     		 
a0eb cd 72 9d			call macro_dsp_valuehl 
a0ee				endm 
# End of macro FORTH_DSP_VALUEHL
a0ee			 
a0ee				if DEBUG_FORTH_WORDS 
a0ee					DMARK "DUs" 
a0ee f5				push af  
a0ef 3a 03 a1			ld a, (.dmark)  
a0f2 32 71 ee			ld (debug_mark),a  
a0f5 3a 04 a1			ld a, (.dmark+1)  
a0f8 32 72 ee			ld (debug_mark+1),a  
a0fb 3a 05 a1			ld a, (.dmark+2)  
a0fe 32 73 ee			ld (debug_mark+2),a  
a101 18 03			jr .pastdmark  
a103 ..			.dmark: db "DUs"  
a106 f1			.pastdmark: pop af  
a107			endm  
# End of macro DMARK
a107					CALLMONITOR 
a107 cd dd 94			call break_point_state  
a10a				endm  
# End of macro CALLMONITOR
a10a				endif 
a10a cd e9 9b				call forth_push_str 
a10d			 
a10d					NEXTW 
a10d c3 28 9f			jp macro_next 
a110				endm 
# End of macro NEXTW
a110			 
a110			 
a110			.dupinum: 
a110					 
a110			 
a110			 
a110					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a110 cd 72 9d			call macro_dsp_valuehl 
a113				endm 
# End of macro FORTH_DSP_VALUEHL
a113			 
a113				; TODO add floating point number detection 
a113			 
a113				if DEBUG_FORTH_WORDS 
a113					DMARK "DUi" 
a113 f5				push af  
a114 3a 28 a1			ld a, (.dmark)  
a117 32 71 ee			ld (debug_mark),a  
a11a 3a 29 a1			ld a, (.dmark+1)  
a11d 32 72 ee			ld (debug_mark+1),a  
a120 3a 2a a1			ld a, (.dmark+2)  
a123 32 73 ee			ld (debug_mark+2),a  
a126 18 03			jr .pastdmark  
a128 ..			.dmark: db "DUi"  
a12b f1			.pastdmark: pop af  
a12c			endm  
# End of macro DMARK
a12c					CALLMONITOR 
a12c cd dd 94			call break_point_state  
a12f				endm  
# End of macro CALLMONITOR
a12f				endif 
a12f			 
a12f cd 7b 9b				call forth_push_numhl 
a132					NEXTW 
a132 c3 28 9f			jp macro_next 
a135				endm 
# End of macro NEXTW
a135			.ZDUP: 
a135				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a135 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a136 6d a1			dw .SWAP            
a138 05				db 4 + 1 
a139 .. 00			db "?DUP",0              
a13e				endm 
# End of macro CWHEAD
a13e			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a13e			 
a13e					if DEBUG_FORTH_WORDS_KEY 
a13e						DMARK "qDU" 
a13e f5				push af  
a13f 3a 53 a1			ld a, (.dmark)  
a142 32 71 ee			ld (debug_mark),a  
a145 3a 54 a1			ld a, (.dmark+1)  
a148 32 72 ee			ld (debug_mark+1),a  
a14b 3a 55 a1			ld a, (.dmark+2)  
a14e 32 73 ee			ld (debug_mark+2),a  
a151 18 03			jr .pastdmark  
a153 ..			.dmark: db "qDU"  
a156 f1			.pastdmark: pop af  
a157			endm  
# End of macro DMARK
a157						CALLMONITOR 
a157 cd dd 94			call break_point_state  
a15a				endm  
# End of macro CALLMONITOR
a15a					endif 
a15a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a15a cd 72 9d			call macro_dsp_valuehl 
a15d				endm 
# End of macro FORTH_DSP_VALUEHL
a15d			 
a15d e5					push hl 
a15e			 
a15e					; is it a zero? 
a15e			 
a15e 3e 00				ld a, 0 
a160 84					add h 
a161 85					add l 
a162			 
a162 e1					pop hl 
a163			 
a163 fe 00				cp 0 
a165 28 03				jr z, .dup2orig 
a167			 
a167			 
a167 cd 7b 9b				call forth_push_numhl 
a16a			 
a16a			 
a16a				; TODO add floating point number detection 
a16a			 
a16a			.dup2orig: 
a16a			 
a16a					NEXTW 
a16a c3 28 9f			jp macro_next 
a16d				endm 
# End of macro NEXTW
a16d			.SWAP: 
a16d				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a16d 18				db WORD_SYS_CORE+OPCODE_SWAP             
a16e ac a1			dw .COLN            
a170 05				db 4 + 1 
a171 .. 00			db "SWAP",0              
a176				endm 
# End of macro CWHEAD
a176			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a176					if DEBUG_FORTH_WORDS_KEY 
a176						DMARK "SWP" 
a176 f5				push af  
a177 3a 8b a1			ld a, (.dmark)  
a17a 32 71 ee			ld (debug_mark),a  
a17d 3a 8c a1			ld a, (.dmark+1)  
a180 32 72 ee			ld (debug_mark+1),a  
a183 3a 8d a1			ld a, (.dmark+2)  
a186 32 73 ee			ld (debug_mark+2),a  
a189 18 03			jr .pastdmark  
a18b ..			.dmark: db "SWP"  
a18e f1			.pastdmark: pop af  
a18f			endm  
# End of macro DMARK
a18f						CALLMONITOR 
a18f cd dd 94			call break_point_state  
a192				endm  
# End of macro CALLMONITOR
a192					endif 
a192			 
a192					FORTH_DSP_VALUEHL 
a192 cd 72 9d			call macro_dsp_valuehl 
a195				endm 
# End of macro FORTH_DSP_VALUEHL
a195 e5					push hl     ; w2 
a196			 
a196					FORTH_DSP_POP 
a196 cd 2a 9e			call macro_forth_dsp_pop 
a199				endm 
# End of macro FORTH_DSP_POP
a199			 
a199					FORTH_DSP_VALUEHL 
a199 cd 72 9d			call macro_dsp_valuehl 
a19c				endm 
# End of macro FORTH_DSP_VALUEHL
a19c			 
a19c					FORTH_DSP_POP 
a19c cd 2a 9e			call macro_forth_dsp_pop 
a19f				endm 
# End of macro FORTH_DSP_POP
a19f			 
a19f d1					pop de     ; w2	, hl = w1 
a1a0			 
a1a0 eb					ex de, hl 
a1a1 d5					push de 
a1a2			 
a1a2 cd 7b 9b				call forth_push_numhl 
a1a5			 
a1a5 e1					pop hl 
a1a6			 
a1a6 cd 7b 9b				call forth_push_numhl 
a1a9					 
a1a9			 
a1a9					NEXTW 
a1a9 c3 28 9f			jp macro_next 
a1ac				endm 
# End of macro NEXTW
a1ac			.COLN: 
a1ac				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a1ac 19				db WORD_SYS_CORE+OPCODE_COLN             
a1ad 38 a3			dw .SCOLN            
a1af 02				db 1 + 1 
a1b0 .. 00			db ":",0              
a1b2				endm 
# End of macro CWHEAD
a1b2			; | : ( -- )         Create new word | DONE 
a1b2			 
a1b2					if DEBUG_FORTH_WORDS_KEY 
a1b2						DMARK "CLN" 
a1b2 f5				push af  
a1b3 3a c7 a1			ld a, (.dmark)  
a1b6 32 71 ee			ld (debug_mark),a  
a1b9 3a c8 a1			ld a, (.dmark+1)  
a1bc 32 72 ee			ld (debug_mark+1),a  
a1bf 3a c9 a1			ld a, (.dmark+2)  
a1c2 32 73 ee			ld (debug_mark+2),a  
a1c5 18 03			jr .pastdmark  
a1c7 ..			.dmark: db "CLN"  
a1ca f1			.pastdmark: pop af  
a1cb			endm  
# End of macro DMARK
a1cb						CALLMONITOR 
a1cb cd dd 94			call break_point_state  
a1ce				endm  
# End of macro CALLMONITOR
a1ce					endif 
a1ce				STACKFRAME OFF $8efe $989f 
a1ce				if DEBUG_STACK_IMB 
a1ce					if OFF 
a1ce						exx 
a1ce						ld de, $8efe 
a1ce						ld a, d 
a1ce						ld hl, curframe 
a1ce						call hexout 
a1ce						ld a, e 
a1ce						ld hl, curframe+2 
a1ce						call hexout 
a1ce						ld hl, $8efe 
a1ce						push hl 
a1ce						ld hl, $989f 
a1ce						push hl 
a1ce						exx 
a1ce					endif 
a1ce				endif 
a1ce			endm 
# End of macro STACKFRAME
a1ce				; get parser buffer length  of new word 
a1ce			 
a1ce				 
a1ce			 
a1ce					; move tok past this to start of name defintition 
a1ce					; TODO get word to define 
a1ce					; TODO Move past word token 
a1ce					; TODO get length of string up to the ';' 
a1ce			 
a1ce 2a c8 e5			ld hl, (os_tok_ptr) 
a1d1 23				inc hl 
a1d2 23				inc hl 
a1d3			 
a1d3 3e 3b			ld a, ';' 
a1d5 cd 45 91			call strlent 
a1d8			 
a1d8 7d				ld a,l 
a1d9 32 c3 e2			ld (os_new_parse_len), a 
a1dc			 
a1dc			 
a1dc			if DEBUG_FORTH_UWORD 
a1dc ed 5b c8 e5		ld de, (os_tok_ptr) 
a1e0						DMARK ":01" 
a1e0 f5				push af  
a1e1 3a f5 a1			ld a, (.dmark)  
a1e4 32 71 ee			ld (debug_mark),a  
a1e7 3a f6 a1			ld a, (.dmark+1)  
a1ea 32 72 ee			ld (debug_mark+1),a  
a1ed 3a f7 a1			ld a, (.dmark+2)  
a1f0 32 73 ee			ld (debug_mark+2),a  
a1f3 18 03			jr .pastdmark  
a1f5 ..			.dmark: db ":01"  
a1f8 f1			.pastdmark: pop af  
a1f9			endm  
# End of macro DMARK
a1f9				CALLMONITOR 
a1f9 cd dd 94			call break_point_state  
a1fc				endm  
# End of macro CALLMONITOR
a1fc			endif 
a1fc			 
a1fc			; 
a1fc			;  new word memory layout: 
a1fc			;  
a1fc			;    : adg 6666 ;  
a1fc			; 
a1fc			;    db   1     ; user defined word  
a1fc 23				inc hl    
a1fd			;    dw   sysdict 
a1fd 23				inc hl 
a1fe 23				inc hl 
a1ff			;    db <word len>+1 (for null) 
a1ff 23				inc hl 
a200			;    db .... <word> 
a200			; 
a200			 
a200 23				inc hl    ; some extras for the word preamble before the above 
a201 23				inc hl 
a202 23				inc hl 
a203 23				inc hl 
a204 23				inc hl 
a205 23				inc hl 
a206 23				inc hl  
a207 23				inc hl 
a208 23				inc hl 
a209 23				inc hl 
a20a 23				inc hl 
a20b 23				inc hl 
a20c 23				inc hl 
a20d 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a20e			;       exec word buffer 
a20e			;	<ptr word>   
a20e 23				inc hl 
a20f 23				inc hl 
a210			;       <word list><null term> 7F final term 
a210			 
a210			 
a210			if DEBUG_FORTH_UWORD 
a210						DMARK ":02" 
a210 f5				push af  
a211 3a 25 a2			ld a, (.dmark)  
a214 32 71 ee			ld (debug_mark),a  
a217 3a 26 a2			ld a, (.dmark+1)  
a21a 32 72 ee			ld (debug_mark+1),a  
a21d 3a 27 a2			ld a, (.dmark+2)  
a220 32 73 ee			ld (debug_mark+2),a  
a223 18 03			jr .pastdmark  
a225 ..			.dmark: db ":02"  
a228 f1			.pastdmark: pop af  
a229			endm  
# End of macro DMARK
a229				CALLMONITOR 
a229 cd dd 94			call break_point_state  
a22c				endm  
# End of macro CALLMONITOR
a22c			endif 
a22c			 
a22c				 
a22c					; malloc the size 
a22c			 
a22c cd a3 91				call malloc 
a22f 22 c5 e2				ld (os_new_malloc), hl     ; save malloc start 
a232			 
a232			;    db   1     ; user defined word  
a232 3e 01				ld a, WORD_SYS_UWORD  
a234 77					ld (hl), a 
a235				 
a235 23				inc hl    
a236			;    dw   sysdict 
a236 11 80 a0			ld de, sysdict       ; continue on with the scan to the system dict 
a239 73				ld (hl), e 
a23a 23				inc hl 
a23b 72				ld (hl), d 
a23c 23				inc hl 
a23d			 
a23d			 
a23d			;    Setup dict word 
a23d			 
a23d 23				inc hl 
a23e 22 bf e2			ld (os_new_work_ptr), hl     ; save start of dict word  
a241			 
a241				; 1. get length of dict word 
a241			 
a241			 
a241 2a c8 e5			ld hl, (os_tok_ptr) 
a244 23				inc hl 
a245 23				inc hl    ; position to start of dict word 
a246 3e 00			ld a, 0 
a248 cd 45 91			call strlent 
a24b			 
a24b			 
a24b 23				inc hl    ; to include null??? 
a24c			 
a24c				; write length of dict word 
a24c			 
a24c ed 5b bf e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a250 1b				dec de 
a251 eb				ex de, hl 
a252 73				ld (hl), e 
a253 eb				ex de, hl 
a254			 
a254				 
a254			 
a254				; copy  
a254 4d				ld c, l 
a255 06 00			ld b, 0 
a257 ed 5b bf e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a25b 2a c8 e5			ld hl, (os_tok_ptr) 
a25e 23				inc hl 
a25f 23				inc hl    ; position to start of dict word 
a260				 
a260			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a260				 
a260				; TODO need to convert word to upper case 
a260			 
a260			ucasetok:	 
a260 7e				ld a,(hl) 
a261 cd 31 91			call toUpper 
a264 77				ld (hl),a 
a265 ed a0			ldi 
a267 f2 60 a2		 	jp p, ucasetok 
a26a			 
a26a			 
a26a			 
a26a				; de now points to start of where the word body code should be placed 
a26a ed 53 bf e2		ld (os_new_work_ptr), de 
a26e				; hl now points to the words to throw at forthexec which needs to be copied 
a26e 22 bd e2			ld (os_new_src_ptr), hl 
a271			 
a271				; TODO add 'call to forthexec' 
a271			 
a271			if DEBUG_FORTH_UWORD 
a271 c5				push bc 
a272 ed 4b c5 e2		ld bc, (os_new_malloc) 
a276						DMARK ":0x" 
a276 f5				push af  
a277 3a 8b a2			ld a, (.dmark)  
a27a 32 71 ee			ld (debug_mark),a  
a27d 3a 8c a2			ld a, (.dmark+1)  
a280 32 72 ee			ld (debug_mark+1),a  
a283 3a 8d a2			ld a, (.dmark+2)  
a286 32 73 ee			ld (debug_mark+2),a  
a289 18 03			jr .pastdmark  
a28b ..			.dmark: db ":0x"  
a28e f1			.pastdmark: pop af  
a28f			endm  
# End of macro DMARK
a28f				CALLMONITOR 
a28f cd dd 94			call break_point_state  
a292				endm  
# End of macro CALLMONITOR
a292 c1				pop bc 
a293			endif 
a293			 
a293			 
a293				; create word preamble which should be: 
a293			 
a293			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a293			 
a293				;    ld hl, <word code> 
a293				;    jp user_exec 
a293			        ;    <word code bytes> 
a293			 
a293			 
a293			;	inc de     ; TODO ??? or are we already past the word's null 
a293 eb				ex de, hl 
a294			 
a294 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a296			 
a296 23				inc hl 
a297 22 b9 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a29a 23				inc hl 
a29b			 
a29b 23				inc hl 
a29c 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a29e			 
a29e 01 61 cb			ld bc, user_exec 
a2a1 23				inc hl 
a2a2 71				ld (hl), c     ; poke address of user_exec 
a2a3 23				inc hl 
a2a4 70				ld (hl), b     
a2a5			 ; 
a2a5			;	inc hl 
a2a5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a2a5			; 
a2a5			; 
a2a5			;	ld bc, macro_forth_rsp_next 
a2a5			;	inc hl 
a2a5			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a2a5			;	inc hl 
a2a5			;	ld (hl), b     
a2a5			 ; 
a2a5			;	inc hl 
a2a5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a2a5			; 
a2a5			; 
a2a5			;	inc hl 
a2a5			;	ld bc, forthexec 
a2a5			;	ld (hl), c     ; poke address of forthexec 
a2a5			;	inc hl 
a2a5			;	ld (hl), b      
a2a5			; 
a2a5			;	inc hl 
a2a5			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a2a5			; 
a2a5			;	ld bc, user_dict_next 
a2a5			;	inc hl 
a2a5			;	ld (hl), c     ; poke address of forthexec 
a2a5			;	inc hl 
a2a5			;	ld (hl), b      
a2a5			 
a2a5				; hl is now where we need to copy the word byte data to save this 
a2a5			 
a2a5 23				inc hl 
a2a6 22 bb e2			ld (os_new_exec), hl 
a2a9				 
a2a9				; copy definition 
a2a9			 
a2a9 eb				ex de, hl 
a2aa			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a2aa			;	inc de    ; skip the PC for this parse 
a2aa 3a c3 e2			ld a, (os_new_parse_len) 
a2ad 4f				ld c, a 
a2ae 06 00			ld b, 0 
a2b0 ed b0			ldir		 ; copy defintion 
a2b2			 
a2b2			 
a2b2				; poke the address of where the new word bytes live for forthexec 
a2b2			 
a2b2 2a b9 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a2b5			 
a2b5 ed 5b bb e2		ld de, (os_new_exec)      
a2b9				 
a2b9 73				ld (hl), e 
a2ba 23				inc hl 
a2bb 72				ld (hl), d 
a2bc			 
a2bc					; TODO copy last user dict word next link to this word 
a2bc					; TODO update last user dict word to point to this word 
a2bc			; 
a2bc			; hl f923 de 812a ; bc 811a 
a2bc			 
a2bc			if DEBUG_FORTH_UWORD 
a2bc c5				push bc 
a2bd ed 4b c5 e2		ld bc, (os_new_malloc) 
a2c1						DMARK ":0A" 
a2c1 f5				push af  
a2c2 3a d6 a2			ld a, (.dmark)  
a2c5 32 71 ee			ld (debug_mark),a  
a2c8 3a d7 a2			ld a, (.dmark+1)  
a2cb 32 72 ee			ld (debug_mark+1),a  
a2ce 3a d8 a2			ld a, (.dmark+2)  
a2d1 32 73 ee			ld (debug_mark+2),a  
a2d4 18 03			jr .pastdmark  
a2d6 ..			.dmark: db ":0A"  
a2d9 f1			.pastdmark: pop af  
a2da			endm  
# End of macro DMARK
a2da				CALLMONITOR 
a2da cd dd 94			call break_point_state  
a2dd				endm  
# End of macro CALLMONITOR
a2dd c1				pop bc 
a2de			endif 
a2de			if DEBUG_FORTH_UWORD 
a2de c5				push bc 
a2df ed 4b c5 e2		ld bc, (os_new_malloc) 
a2e3 03				inc bc 
a2e4 03				inc bc 
a2e5 03				inc bc 
a2e6 03				inc bc 
a2e7 03				inc bc 
a2e8 03				inc bc 
a2e9 03				inc bc 
a2ea 03				inc bc 
a2eb			 
a2eb						DMARK ":0B" 
a2eb f5				push af  
a2ec 3a 00 a3			ld a, (.dmark)  
a2ef 32 71 ee			ld (debug_mark),a  
a2f2 3a 01 a3			ld a, (.dmark+1)  
a2f5 32 72 ee			ld (debug_mark+1),a  
a2f8 3a 02 a3			ld a, (.dmark+2)  
a2fb 32 73 ee			ld (debug_mark+2),a  
a2fe 18 03			jr .pastdmark  
a300 ..			.dmark: db ":0B"  
a303 f1			.pastdmark: pop af  
a304			endm  
# End of macro DMARK
a304				CALLMONITOR 
a304 cd dd 94			call break_point_state  
a307				endm  
# End of macro CALLMONITOR
a307 c1				pop bc 
a308			endif 
a308			 
a308			; update word dict linked list for new word 
a308			 
a308			 
a308 2a c4 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a30b 23			inc hl     ; move to next work linked list ptr 
a30c			 
a30c ed 5b c5 e2	ld de, (os_new_malloc)		 ; new next word 
a310 73			ld (hl), e 
a311 23			inc hl 
a312 72			ld (hl), d 
a313			 
a313			if DEBUG_FORTH_UWORD 
a313 ed 4b c4 e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a317			endif 
a317			 
a317 ed 53 c4 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a31b			 
a31b			 
a31b			if DEBUG_FORTH_UWORD 
a31b						DMARK ":0+" 
a31b f5				push af  
a31c 3a 30 a3			ld a, (.dmark)  
a31f 32 71 ee			ld (debug_mark),a  
a322 3a 31 a3			ld a, (.dmark+1)  
a325 32 72 ee			ld (debug_mark+1),a  
a328 3a 32 a3			ld a, (.dmark+2)  
a32b 32 73 ee			ld (debug_mark+2),a  
a32e 18 03			jr .pastdmark  
a330 ..			.dmark: db ":0+"  
a333 f1			.pastdmark: pop af  
a334			endm  
# End of macro DMARK
a334				CALLMONITOR 
a334 cd dd 94			call break_point_state  
a337				endm  
# End of macro CALLMONITOR
a337			endif 
a337			 
a337				STACKFRAMECHK OFF $8efe $989f 
a337				if DEBUG_STACK_IMB 
a337					if OFF 
a337						exx 
a337						ld hl, $989f 
a337						pop de   ; $989f 
a337						call cmp16 
a337						jr nz, .spnosame 
a337						ld hl, $8efe 
a337						pop de   ; $8efe 
a337						call cmp16 
a337						jr z, .spfrsame 
a337						.spnosame: call showsperror 
a337						.spfrsame: nop 
a337						exx 
a337					endif 
a337				endif 
a337			endm 
# End of macro STACKFRAMECHK
a337			 
a337 c9			ret    ; dont process any remaining parser tokens as they form new word 
a338			 
a338			 
a338			 
a338			 
a338			;		NEXT 
a338			.SCOLN: 
a338			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a338 06				db OPCODE_SCOLN 
a339 84 a3			dw .DROP 
a33b 02				db 2 
a33c .. 00			db ";",0           
a33e			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a33e					if DEBUG_FORTH_WORDS_KEY 
a33e						DMARK "SCN" 
a33e f5				push af  
a33f 3a 53 a3			ld a, (.dmark)  
a342 32 71 ee			ld (debug_mark),a  
a345 3a 54 a3			ld a, (.dmark+1)  
a348 32 72 ee			ld (debug_mark+1),a  
a34b 3a 55 a3			ld a, (.dmark+2)  
a34e 32 73 ee			ld (debug_mark+2),a  
a351 18 03			jr .pastdmark  
a353 ..			.dmark: db "SCN"  
a356 f1			.pastdmark: pop af  
a357			endm  
# End of macro DMARK
a357						CALLMONITOR 
a357 cd dd 94			call break_point_state  
a35a				endm  
# End of macro CALLMONITOR
a35a					endif 
a35a					FORTH_RSP_TOS 
a35a cd 39 9b			call macro_forth_rsp_tos 
a35d				endm 
# End of macro FORTH_RSP_TOS
a35d e5					push hl 
a35e					FORTH_RSP_POP 
a35e cd 43 9b			call macro_forth_rsp_pop 
a361				endm 
# End of macro FORTH_RSP_POP
a361 e1					pop hl 
a362			;		ex de,hl 
a362 22 c8 e5				ld (os_tok_ptr),hl 
a365			 
a365			if DEBUG_FORTH_UWORD 
a365						DMARK "SCL" 
a365 f5				push af  
a366 3a 7a a3			ld a, (.dmark)  
a369 32 71 ee			ld (debug_mark),a  
a36c 3a 7b a3			ld a, (.dmark+1)  
a36f 32 72 ee			ld (debug_mark+1),a  
a372 3a 7c a3			ld a, (.dmark+2)  
a375 32 73 ee			ld (debug_mark+2),a  
a378 18 03			jr .pastdmark  
a37a ..			.dmark: db "SCL"  
a37d f1			.pastdmark: pop af  
a37e			endm  
# End of macro DMARK
a37e				CALLMONITOR 
a37e cd dd 94			call break_point_state  
a381				endm  
# End of macro CALLMONITOR
a381			endif 
a381					NEXTW 
a381 c3 28 9f			jp macro_next 
a384				endm 
# End of macro NEXTW
a384			 
a384			.DROP: 
a384				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a384 1b				db WORD_SYS_CORE+OPCODE_DROP             
a385 af a3			dw .DUP2            
a387 05				db 4 + 1 
a388 .. 00			db "DROP",0              
a38d				endm 
# End of macro CWHEAD
a38d			; | DROP ( w -- )   drop the TOS item   | DONE 
a38d					if DEBUG_FORTH_WORDS_KEY 
a38d						DMARK "DRP" 
a38d f5				push af  
a38e 3a a2 a3			ld a, (.dmark)  
a391 32 71 ee			ld (debug_mark),a  
a394 3a a3 a3			ld a, (.dmark+1)  
a397 32 72 ee			ld (debug_mark+1),a  
a39a 3a a4 a3			ld a, (.dmark+2)  
a39d 32 73 ee			ld (debug_mark+2),a  
a3a0 18 03			jr .pastdmark  
a3a2 ..			.dmark: db "DRP"  
a3a5 f1			.pastdmark: pop af  
a3a6			endm  
# End of macro DMARK
a3a6						CALLMONITOR 
a3a6 cd dd 94			call break_point_state  
a3a9				endm  
# End of macro CALLMONITOR
a3a9					endif 
a3a9					FORTH_DSP_POP 
a3a9 cd 2a 9e			call macro_forth_dsp_pop 
a3ac				endm 
# End of macro FORTH_DSP_POP
a3ac					NEXTW 
a3ac c3 28 9f			jp macro_next 
a3af				endm 
# End of macro NEXTW
a3af			.DUP2: 
a3af				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a3af 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a3b0 f4 a3			dw .DROP2            
a3b2 05				db 4 + 1 
a3b3 .. 00			db "2DUP",0              
a3b8				endm 
# End of macro CWHEAD
a3b8			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a3b8					if DEBUG_FORTH_WORDS_KEY 
a3b8						DMARK "2DU" 
a3b8 f5				push af  
a3b9 3a cd a3			ld a, (.dmark)  
a3bc 32 71 ee			ld (debug_mark),a  
a3bf 3a ce a3			ld a, (.dmark+1)  
a3c2 32 72 ee			ld (debug_mark+1),a  
a3c5 3a cf a3			ld a, (.dmark+2)  
a3c8 32 73 ee			ld (debug_mark+2),a  
a3cb 18 03			jr .pastdmark  
a3cd ..			.dmark: db "2DU"  
a3d0 f1			.pastdmark: pop af  
a3d1			endm  
# End of macro DMARK
a3d1						CALLMONITOR 
a3d1 cd dd 94			call break_point_state  
a3d4				endm  
# End of macro CALLMONITOR
a3d4					endif 
a3d4					FORTH_DSP_VALUEHL 
a3d4 cd 72 9d			call macro_dsp_valuehl 
a3d7				endm 
# End of macro FORTH_DSP_VALUEHL
a3d7 e5					push hl      ; 2 
a3d8			 
a3d8					FORTH_DSP_POP 
a3d8 cd 2a 9e			call macro_forth_dsp_pop 
a3db				endm 
# End of macro FORTH_DSP_POP
a3db					 
a3db					FORTH_DSP_VALUEHL 
a3db cd 72 9d			call macro_dsp_valuehl 
a3de				endm 
# End of macro FORTH_DSP_VALUEHL
a3de			;		push hl      ; 1 
a3de			 
a3de					FORTH_DSP_POP 
a3de cd 2a 9e			call macro_forth_dsp_pop 
a3e1				endm 
# End of macro FORTH_DSP_POP
a3e1			 
a3e1			;		pop hl       ; 1 
a3e1 d1					pop de       ; 2 
a3e2			 
a3e2 cd 7b 9b				call forth_push_numhl 
a3e5 eb					ex de, hl 
a3e6 cd 7b 9b				call forth_push_numhl 
a3e9			 
a3e9					 
a3e9 eb					ex de, hl 
a3ea			 
a3ea cd 7b 9b				call forth_push_numhl 
a3ed eb					ex de, hl 
a3ee cd 7b 9b				call forth_push_numhl 
a3f1			 
a3f1			 
a3f1					NEXTW 
a3f1 c3 28 9f			jp macro_next 
a3f4				endm 
# End of macro NEXTW
a3f4			.DROP2: 
a3f4				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a3f4 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a3f5 23 a4			dw .SWAP2            
a3f7 06				db 5 + 1 
a3f8 .. 00			db "2DROP",0              
a3fe				endm 
# End of macro CWHEAD
a3fe			; | 2DROP ( w w -- )    Double drop | DONE 
a3fe					if DEBUG_FORTH_WORDS_KEY 
a3fe						DMARK "2DR" 
a3fe f5				push af  
a3ff 3a 13 a4			ld a, (.dmark)  
a402 32 71 ee			ld (debug_mark),a  
a405 3a 14 a4			ld a, (.dmark+1)  
a408 32 72 ee			ld (debug_mark+1),a  
a40b 3a 15 a4			ld a, (.dmark+2)  
a40e 32 73 ee			ld (debug_mark+2),a  
a411 18 03			jr .pastdmark  
a413 ..			.dmark: db "2DR"  
a416 f1			.pastdmark: pop af  
a417			endm  
# End of macro DMARK
a417						CALLMONITOR 
a417 cd dd 94			call break_point_state  
a41a				endm  
# End of macro CALLMONITOR
a41a					endif 
a41a					FORTH_DSP_POP 
a41a cd 2a 9e			call macro_forth_dsp_pop 
a41d				endm 
# End of macro FORTH_DSP_POP
a41d					FORTH_DSP_POP 
a41d cd 2a 9e			call macro_forth_dsp_pop 
a420				endm 
# End of macro FORTH_DSP_POP
a420					NEXTW 
a420 c3 28 9f			jp macro_next 
a423				endm 
# End of macro NEXTW
a423			.SWAP2: 
a423				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a423 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a424 4c a4			dw .AT            
a426 06				db 5 + 1 
a427 .. 00			db "2SWAP",0              
a42d				endm 
# End of macro CWHEAD
a42d			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a42d					if DEBUG_FORTH_WORDS_KEY 
a42d						DMARK "2SW" 
a42d f5				push af  
a42e 3a 42 a4			ld a, (.dmark)  
a431 32 71 ee			ld (debug_mark),a  
a434 3a 43 a4			ld a, (.dmark+1)  
a437 32 72 ee			ld (debug_mark+1),a  
a43a 3a 44 a4			ld a, (.dmark+2)  
a43d 32 73 ee			ld (debug_mark+2),a  
a440 18 03			jr .pastdmark  
a442 ..			.dmark: db "2SW"  
a445 f1			.pastdmark: pop af  
a446			endm  
# End of macro DMARK
a446						CALLMONITOR 
a446 cd dd 94			call break_point_state  
a449				endm  
# End of macro CALLMONITOR
a449					endif 
a449					NEXTW 
a449 c3 28 9f			jp macro_next 
a44c				endm 
# End of macro NEXTW
a44c			.AT: 
a44c				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a44c 1f				db WORD_SYS_CORE+OPCODE_AT             
a44d 7e a4			dw .CAT            
a44f 02				db 1 + 1 
a450 .. 00			db "@",0              
a452				endm 
# End of macro CWHEAD
a452			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a452			 
a452					if DEBUG_FORTH_WORDS_KEY 
a452						DMARK "AT." 
a452 f5				push af  
a453 3a 67 a4			ld a, (.dmark)  
a456 32 71 ee			ld (debug_mark),a  
a459 3a 68 a4			ld a, (.dmark+1)  
a45c 32 72 ee			ld (debug_mark+1),a  
a45f 3a 69 a4			ld a, (.dmark+2)  
a462 32 73 ee			ld (debug_mark+2),a  
a465 18 03			jr .pastdmark  
a467 ..			.dmark: db "AT."  
a46a f1			.pastdmark: pop af  
a46b			endm  
# End of macro DMARK
a46b						CALLMONITOR 
a46b cd dd 94			call break_point_state  
a46e				endm  
# End of macro CALLMONITOR
a46e					endif 
a46e			.getbyteat:	 
a46e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a46e cd 72 9d			call macro_dsp_valuehl 
a471				endm 
# End of macro FORTH_DSP_VALUEHL
a471					 
a471			;		push hl 
a471				 
a471					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a471 cd 2a 9e			call macro_forth_dsp_pop 
a474				endm 
# End of macro FORTH_DSP_POP
a474			 
a474			;		pop hl 
a474			 
a474 7e					ld a, (hl) 
a475			 
a475 6f					ld l, a 
a476 26 00				ld h, 0 
a478 cd 7b 9b				call forth_push_numhl 
a47b			 
a47b					NEXTW 
a47b c3 28 9f			jp macro_next 
a47e				endm 
# End of macro NEXTW
a47e			.CAT: 
a47e				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a47e 20				db WORD_SYS_CORE+OPCODE_CAT             
a47f a7 a4			dw .BANG            
a481 03				db 2 + 1 
a482 .. 00			db "C@",0              
a485				endm 
# End of macro CWHEAD
a485			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a485					if DEBUG_FORTH_WORDS_KEY 
a485						DMARK "CAA" 
a485 f5				push af  
a486 3a 9a a4			ld a, (.dmark)  
a489 32 71 ee			ld (debug_mark),a  
a48c 3a 9b a4			ld a, (.dmark+1)  
a48f 32 72 ee			ld (debug_mark+1),a  
a492 3a 9c a4			ld a, (.dmark+2)  
a495 32 73 ee			ld (debug_mark+2),a  
a498 18 03			jr .pastdmark  
a49a ..			.dmark: db "CAA"  
a49d f1			.pastdmark: pop af  
a49e			endm  
# End of macro DMARK
a49e						CALLMONITOR 
a49e cd dd 94			call break_point_state  
a4a1				endm  
# End of macro CALLMONITOR
a4a1					endif 
a4a1 c3 6e a4				jp .getbyteat 
a4a4					NEXTW 
a4a4 c3 28 9f			jp macro_next 
a4a7				endm 
# End of macro NEXTW
a4a7			.BANG: 
a4a7				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a4a7 21				db WORD_SYS_CORE+OPCODE_BANG             
a4a8 dd a4			dw .CBANG            
a4aa 02				db 1 + 1 
a4ab .. 00			db "!",0              
a4ad				endm 
# End of macro CWHEAD
a4ad			; | ! ( x w -- ) Store x at address w      | DONE 
a4ad					if DEBUG_FORTH_WORDS_KEY 
a4ad						DMARK "BNG" 
a4ad f5				push af  
a4ae 3a c2 a4			ld a, (.dmark)  
a4b1 32 71 ee			ld (debug_mark),a  
a4b4 3a c3 a4			ld a, (.dmark+1)  
a4b7 32 72 ee			ld (debug_mark+1),a  
a4ba 3a c4 a4			ld a, (.dmark+2)  
a4bd 32 73 ee			ld (debug_mark+2),a  
a4c0 18 03			jr .pastdmark  
a4c2 ..			.dmark: db "BNG"  
a4c5 f1			.pastdmark: pop af  
a4c6			endm  
# End of macro DMARK
a4c6						CALLMONITOR 
a4c6 cd dd 94			call break_point_state  
a4c9				endm  
# End of macro CALLMONITOR
a4c9					endif 
a4c9			 
a4c9			.storebyteat:		 
a4c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4c9 cd 72 9d			call macro_dsp_valuehl 
a4cc				endm 
# End of macro FORTH_DSP_VALUEHL
a4cc					 
a4cc e5					push hl 
a4cd				 
a4cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4cd cd 2a 9e			call macro_forth_dsp_pop 
a4d0				endm 
# End of macro FORTH_DSP_POP
a4d0			 
a4d0					; get byte to poke 
a4d0			 
a4d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4d0 cd 72 9d			call macro_dsp_valuehl 
a4d3				endm 
# End of macro FORTH_DSP_VALUEHL
a4d3 e5					push hl 
a4d4			 
a4d4			 
a4d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4d4 cd 2a 9e			call macro_forth_dsp_pop 
a4d7				endm 
# End of macro FORTH_DSP_POP
a4d7			 
a4d7			 
a4d7 d1					pop de 
a4d8 e1					pop hl 
a4d9			 
a4d9 73					ld (hl),e 
a4da			 
a4da			 
a4da					NEXTW 
a4da c3 28 9f			jp macro_next 
a4dd				endm 
# End of macro NEXTW
a4dd			.CBANG: 
a4dd				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a4dd 22				db WORD_SYS_CORE+OPCODE_CBANG             
a4de 06 a5			dw .SCALL            
a4e0 03				db 2 + 1 
a4e1 .. 00			db "C!",0              
a4e4				endm 
# End of macro CWHEAD
a4e4			; | C!  ( x w -- ) Store x at address w  | DONE 
a4e4					if DEBUG_FORTH_WORDS_KEY 
a4e4						DMARK "CBA" 
a4e4 f5				push af  
a4e5 3a f9 a4			ld a, (.dmark)  
a4e8 32 71 ee			ld (debug_mark),a  
a4eb 3a fa a4			ld a, (.dmark+1)  
a4ee 32 72 ee			ld (debug_mark+1),a  
a4f1 3a fb a4			ld a, (.dmark+2)  
a4f4 32 73 ee			ld (debug_mark+2),a  
a4f7 18 03			jr .pastdmark  
a4f9 ..			.dmark: db "CBA"  
a4fc f1			.pastdmark: pop af  
a4fd			endm  
# End of macro DMARK
a4fd						CALLMONITOR 
a4fd cd dd 94			call break_point_state  
a500				endm  
# End of macro CALLMONITOR
a500					endif 
a500 c3 c9 a4				jp .storebyteat 
a503					NEXTW 
a503 c3 28 9f			jp macro_next 
a506				endm 
# End of macro NEXTW
a506			.SCALL: 
a506				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a506 23				db WORD_SYS_CORE+OPCODE_SCALL             
a507 3a a5			dw .DEPTH            
a509 05				db 4 + 1 
a50a .. 00			db "CALL",0              
a50f				endm 
# End of macro CWHEAD
a50f			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a50f					if DEBUG_FORTH_WORDS_KEY 
a50f						DMARK "CLL" 
a50f f5				push af  
a510 3a 24 a5			ld a, (.dmark)  
a513 32 71 ee			ld (debug_mark),a  
a516 3a 25 a5			ld a, (.dmark+1)  
a519 32 72 ee			ld (debug_mark+1),a  
a51c 3a 26 a5			ld a, (.dmark+2)  
a51f 32 73 ee			ld (debug_mark+2),a  
a522 18 03			jr .pastdmark  
a524 ..			.dmark: db "CLL"  
a527 f1			.pastdmark: pop af  
a528			endm  
# End of macro DMARK
a528						CALLMONITOR 
a528 cd dd 94			call break_point_state  
a52b				endm  
# End of macro CALLMONITOR
a52b					endif 
a52b			 
a52b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a52b cd 72 9d			call macro_dsp_valuehl 
a52e				endm 
# End of macro FORTH_DSP_VALUEHL
a52e			 
a52e			;		push hl 
a52e			 
a52e					; destroy value TOS 
a52e			 
a52e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a52e cd 2a 9e			call macro_forth_dsp_pop 
a531				endm 
# End of macro FORTH_DSP_POP
a531			 
a531						 
a531			;		pop hl 
a531			 
a531					; how to do a call with hl???? save SP? 
a531 cd cc 9e				call forth_call_hl 
a534			 
a534			 
a534					; TODO push value back onto stack for another op etc 
a534			 
a534 cd 7b 9b				call forth_push_numhl 
a537					NEXTW 
a537 c3 28 9f			jp macro_next 
a53a				endm 
# End of macro NEXTW
a53a			.DEPTH: 
a53a				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a53a 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a53b 77 a5			dw .OVER            
a53d 06				db 5 + 1 
a53e .. 00			db "DEPTH",0              
a544				endm 
# End of macro CWHEAD
a544			; | DEPTH ( -- u ) Push count of stack | DONE 
a544					; take current TOS and remove from base value div by two to get count 
a544					if DEBUG_FORTH_WORDS_KEY 
a544						DMARK "DEP" 
a544 f5				push af  
a545 3a 59 a5			ld a, (.dmark)  
a548 32 71 ee			ld (debug_mark),a  
a54b 3a 5a a5			ld a, (.dmark+1)  
a54e 32 72 ee			ld (debug_mark+1),a  
a551 3a 5b a5			ld a, (.dmark+2)  
a554 32 73 ee			ld (debug_mark+2),a  
a557 18 03			jr .pastdmark  
a559 ..			.dmark: db "DEP"  
a55c f1			.pastdmark: pop af  
a55d			endm  
# End of macro DMARK
a55d						CALLMONITOR 
a55d cd dd 94			call break_point_state  
a560				endm  
# End of macro CALLMONITOR
a560					endif 
a560			 
a560			 
a560 2a f4 e9			ld hl, (cli_data_sp) 
a563 11 2e e8			ld de, cli_data_stack 
a566 ed 52			sbc hl,de 
a568				 
a568				; div by size of stack item 
a568			 
a568 5d				ld e,l 
a569 0e 03			ld c, 3 
a56b cd 6c 8c			call Div8 
a56e			 
a56e 6f				ld l,a 
a56f 26 00			ld h,0 
a571			 
a571				;srl h 
a571				;rr l 
a571			 
a571 cd 7b 9b				call forth_push_numhl 
a574					NEXTW 
a574 c3 28 9f			jp macro_next 
a577				endm 
# End of macro NEXTW
a577			.OVER: 
a577				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a577 42				db WORD_SYS_CORE+46             
a578 be a5			dw .PAUSE            
a57a 05				db 4 + 1 
a57b .. 00			db "OVER",0              
a580				endm 
# End of macro CWHEAD
a580			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a580					if DEBUG_FORTH_WORDS_KEY 
a580						DMARK "OVR" 
a580 f5				push af  
a581 3a 95 a5			ld a, (.dmark)  
a584 32 71 ee			ld (debug_mark),a  
a587 3a 96 a5			ld a, (.dmark+1)  
a58a 32 72 ee			ld (debug_mark+1),a  
a58d 3a 97 a5			ld a, (.dmark+2)  
a590 32 73 ee			ld (debug_mark+2),a  
a593 18 03			jr .pastdmark  
a595 ..			.dmark: db "OVR"  
a598 f1			.pastdmark: pop af  
a599			endm  
# End of macro DMARK
a599						CALLMONITOR 
a599 cd dd 94			call break_point_state  
a59c				endm  
# End of macro CALLMONITOR
a59c					endif 
a59c			 
a59c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a59c cd 72 9d			call macro_dsp_valuehl 
a59f				endm 
# End of macro FORTH_DSP_VALUEHL
a59f e5					push hl    ; n2 
a5a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5a0 cd 2a 9e			call macro_forth_dsp_pop 
a5a3				endm 
# End of macro FORTH_DSP_POP
a5a3			 
a5a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5a3 cd 72 9d			call macro_dsp_valuehl 
a5a6				endm 
# End of macro FORTH_DSP_VALUEHL
a5a6 e5					push hl    ; n1 
a5a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5a7 cd 2a 9e			call macro_forth_dsp_pop 
a5aa				endm 
# End of macro FORTH_DSP_POP
a5aa			 
a5aa d1					pop de     ; n1 
a5ab e1					pop hl     ; n2 
a5ac			 
a5ac d5					push de 
a5ad e5					push hl 
a5ae d5					push de 
a5af			 
a5af					; push back  
a5af			 
a5af e1					pop hl 
a5b0 cd 7b 9b				call forth_push_numhl 
a5b3 e1					pop hl 
a5b4 cd 7b 9b				call forth_push_numhl 
a5b7 e1					pop hl 
a5b8 cd 7b 9b				call forth_push_numhl 
a5bb					NEXTW 
a5bb c3 28 9f			jp macro_next 
a5be				endm 
# End of macro NEXTW
a5be			 
a5be			.PAUSE: 
a5be				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a5be 43				db WORD_SYS_CORE+47             
a5bf f3 a5			dw .PAUSES            
a5c1 08				db 7 + 1 
a5c2 .. 00			db "PAUSEMS",0              
a5ca				endm 
# End of macro CWHEAD
a5ca			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a5ca					if DEBUG_FORTH_WORDS_KEY 
a5ca						DMARK "PMS" 
a5ca f5				push af  
a5cb 3a df a5			ld a, (.dmark)  
a5ce 32 71 ee			ld (debug_mark),a  
a5d1 3a e0 a5			ld a, (.dmark+1)  
a5d4 32 72 ee			ld (debug_mark+1),a  
a5d7 3a e1 a5			ld a, (.dmark+2)  
a5da 32 73 ee			ld (debug_mark+2),a  
a5dd 18 03			jr .pastdmark  
a5df ..			.dmark: db "PMS"  
a5e2 f1			.pastdmark: pop af  
a5e3			endm  
# End of macro DMARK
a5e3						CALLMONITOR 
a5e3 cd dd 94			call break_point_state  
a5e6				endm  
# End of macro CALLMONITOR
a5e6					endif 
a5e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5e6 cd 72 9d			call macro_dsp_valuehl 
a5e9				endm 
# End of macro FORTH_DSP_VALUEHL
a5e9			;		push hl    ; n2 
a5e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5e9 cd 2a 9e			call macro_forth_dsp_pop 
a5ec				endm 
# End of macro FORTH_DSP_POP
a5ec			;		pop hl 
a5ec			 
a5ec 7d					ld a, l 
a5ed cd d7 89				call aDelayInMS 
a5f0				       NEXTW 
a5f0 c3 28 9f			jp macro_next 
a5f3				endm 
# End of macro NEXTW
a5f3			.PAUSES:  
a5f3				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a5f3 44				db WORD_SYS_CORE+48             
a5f4 62 a6			dw .ROT            
a5f6 06				db 5 + 1 
a5f7 .. 00			db "PAUSE",0              
a5fd				endm 
# End of macro CWHEAD
a5fd			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a5fd					if DEBUG_FORTH_WORDS_KEY 
a5fd						DMARK "PAU" 
a5fd f5				push af  
a5fe 3a 12 a6			ld a, (.dmark)  
a601 32 71 ee			ld (debug_mark),a  
a604 3a 13 a6			ld a, (.dmark+1)  
a607 32 72 ee			ld (debug_mark+1),a  
a60a 3a 14 a6			ld a, (.dmark+2)  
a60d 32 73 ee			ld (debug_mark+2),a  
a610 18 03			jr .pastdmark  
a612 ..			.dmark: db "PAU"  
a615 f1			.pastdmark: pop af  
a616			endm  
# End of macro DMARK
a616						CALLMONITOR 
a616 cd dd 94			call break_point_state  
a619				endm  
# End of macro CALLMONITOR
a619					endif 
a619					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a619 cd 72 9d			call macro_dsp_valuehl 
a61c				endm 
# End of macro FORTH_DSP_VALUEHL
a61c			;		push hl    ; n2 
a61c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a61c cd 2a 9e			call macro_forth_dsp_pop 
a61f				endm 
# End of macro FORTH_DSP_POP
a61f			;		pop hl 
a61f 45					ld b, l 
a620					if DEBUG_FORTH_WORDS 
a620						DMARK "PAU" 
a620 f5				push af  
a621 3a 35 a6			ld a, (.dmark)  
a624 32 71 ee			ld (debug_mark),a  
a627 3a 36 a6			ld a, (.dmark+1)  
a62a 32 72 ee			ld (debug_mark+1),a  
a62d 3a 37 a6			ld a, (.dmark+2)  
a630 32 73 ee			ld (debug_mark+2),a  
a633 18 03			jr .pastdmark  
a635 ..			.dmark: db "PAU"  
a638 f1			.pastdmark: pop af  
a639			endm  
# End of macro DMARK
a639						CALLMONITOR 
a639 cd dd 94			call break_point_state  
a63c				endm  
# End of macro CALLMONITOR
a63c					endif 
a63c c5			.pauses1:	push bc 
a63d cd f2 89				call delay1s 
a640 c1					pop bc 
a641					if DEBUG_FORTH_WORDS 
a641						DMARK "PA1" 
a641 f5				push af  
a642 3a 56 a6			ld a, (.dmark)  
a645 32 71 ee			ld (debug_mark),a  
a648 3a 57 a6			ld a, (.dmark+1)  
a64b 32 72 ee			ld (debug_mark+1),a  
a64e 3a 58 a6			ld a, (.dmark+2)  
a651 32 73 ee			ld (debug_mark+2),a  
a654 18 03			jr .pastdmark  
a656 ..			.dmark: db "PA1"  
a659 f1			.pastdmark: pop af  
a65a			endm  
# End of macro DMARK
a65a						CALLMONITOR 
a65a cd dd 94			call break_point_state  
a65d				endm  
# End of macro CALLMONITOR
a65d					endif 
a65d 10 dd				djnz .pauses1 
a65f			 
a65f				       NEXTW 
a65f c3 28 9f			jp macro_next 
a662				endm 
# End of macro NEXTW
a662			.ROT: 
a662				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a662 45				db WORD_SYS_CORE+49             
a663 b0 a6			dw .UWORDS            
a665 04				db 3 + 1 
a666 .. 00			db "ROT",0              
a66a				endm 
# End of macro CWHEAD
a66a			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a66a					if DEBUG_FORTH_WORDS_KEY 
a66a						DMARK "ROT" 
a66a f5				push af  
a66b 3a 7f a6			ld a, (.dmark)  
a66e 32 71 ee			ld (debug_mark),a  
a671 3a 80 a6			ld a, (.dmark+1)  
a674 32 72 ee			ld (debug_mark+1),a  
a677 3a 81 a6			ld a, (.dmark+2)  
a67a 32 73 ee			ld (debug_mark+2),a  
a67d 18 03			jr .pastdmark  
a67f ..			.dmark: db "ROT"  
a682 f1			.pastdmark: pop af  
a683			endm  
# End of macro DMARK
a683						CALLMONITOR 
a683 cd dd 94			call break_point_state  
a686				endm  
# End of macro CALLMONITOR
a686					endif 
a686			 
a686					FORTH_DSP_VALUEHL 
a686 cd 72 9d			call macro_dsp_valuehl 
a689				endm 
# End of macro FORTH_DSP_VALUEHL
a689 e5					push hl    ; u3  
a68a			 
a68a					FORTH_DSP_POP 
a68a cd 2a 9e			call macro_forth_dsp_pop 
a68d				endm 
# End of macro FORTH_DSP_POP
a68d			   
a68d					FORTH_DSP_VALUEHL 
a68d cd 72 9d			call macro_dsp_valuehl 
a690				endm 
# End of macro FORTH_DSP_VALUEHL
a690 e5					push hl     ; u2 
a691			 
a691					FORTH_DSP_POP 
a691 cd 2a 9e			call macro_forth_dsp_pop 
a694				endm 
# End of macro FORTH_DSP_POP
a694			 
a694					FORTH_DSP_VALUEHL 
a694 cd 72 9d			call macro_dsp_valuehl 
a697				endm 
# End of macro FORTH_DSP_VALUEHL
a697 e5					push hl     ; u1 
a698			 
a698					FORTH_DSP_POP 
a698 cd 2a 9e			call macro_forth_dsp_pop 
a69b				endm 
# End of macro FORTH_DSP_POP
a69b			 
a69b c1					pop bc      ; u1 
a69c e1					pop hl      ; u2 
a69d d1					pop de      ; u3 
a69e			 
a69e			 
a69e c5					push bc 
a69f d5					push de 
a6a0 e5					push hl 
a6a1			 
a6a1			 
a6a1 e1					pop hl 
a6a2 cd 7b 9b				call forth_push_numhl 
a6a5			 
a6a5 e1					pop hl 
a6a6 cd 7b 9b				call forth_push_numhl 
a6a9			 
a6a9 e1					pop hl 
a6aa cd 7b 9b				call forth_push_numhl 
a6ad					 
a6ad			 
a6ad			 
a6ad			 
a6ad			 
a6ad			 
a6ad				       NEXTW 
a6ad c3 28 9f			jp macro_next 
a6b0				endm 
# End of macro NEXTW
a6b0			 
a6b0			.UWORDS: 
a6b0				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a6b0 50				db WORD_SYS_CORE+60             
a6b1 72 a7			dw .BP            
a6b3 07				db 6 + 1 
a6b4 .. 00			db "UWORDS",0              
a6bb				endm 
# End of macro CWHEAD
a6bb			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a6bb			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a6bb			; | | Following the count are the individual words. 
a6bb			; | | 
a6bb			; | | e.g. UWORDS 
a6bb			; | | BOX DIRLIST 2 
a6bb			; | |  
a6bb			; | | Can be used to save the words to storage via: 
a6bb			; | | UWORDS $01 DO $01 APPEND LOOP 
a6bb				if DEBUG_FORTH_WORDS_KEY 
a6bb					DMARK "UWR" 
a6bb f5				push af  
a6bc 3a d0 a6			ld a, (.dmark)  
a6bf 32 71 ee			ld (debug_mark),a  
a6c2 3a d1 a6			ld a, (.dmark+1)  
a6c5 32 72 ee			ld (debug_mark+1),a  
a6c8 3a d2 a6			ld a, (.dmark+2)  
a6cb 32 73 ee			ld (debug_mark+2),a  
a6ce 18 03			jr .pastdmark  
a6d0 ..			.dmark: db "UWR"  
a6d3 f1			.pastdmark: pop af  
a6d4			endm  
# End of macro DMARK
a6d4					CALLMONITOR 
a6d4 cd dd 94			call break_point_state  
a6d7				endm  
# End of macro CALLMONITOR
a6d7				endif 
a6d7 21 7d e3				ld hl, baseram 
a6da					;ld hl, baseusermem 
a6da 01 00 00				ld bc, 0    ; start a counter 
a6dd			 
a6dd				; skip dict stub 
a6dd			 
a6dd cd 79 a0				call forth_tok_next 
a6e0			 
a6e0			 
a6e0			; while we have words to look for 
a6e0			 
a6e0 7e			.douscan:	ld a, (hl)      
a6e1				if DEBUG_FORTH_WORDS 
a6e1					DMARK "UWs" 
a6e1 f5				push af  
a6e2 3a f6 a6			ld a, (.dmark)  
a6e5 32 71 ee			ld (debug_mark),a  
a6e8 3a f7 a6			ld a, (.dmark+1)  
a6eb 32 72 ee			ld (debug_mark+1),a  
a6ee 3a f8 a6			ld a, (.dmark+2)  
a6f1 32 73 ee			ld (debug_mark+2),a  
a6f4 18 03			jr .pastdmark  
a6f6 ..			.dmark: db "UWs"  
a6f9 f1			.pastdmark: pop af  
a6fa			endm  
# End of macro DMARK
a6fa					CALLMONITOR 
a6fa cd dd 94			call break_point_state  
a6fd				endm  
# End of macro CALLMONITOR
a6fd				endif 
a6fd fe 00				cp WORD_SYS_END 
a6ff 28 4d				jr z, .udone 
a701 fe 01				cp WORD_SYS_UWORD 
a703 20 44				jr nz, .nuword 
a705			 
a705				if DEBUG_FORTH_WORDS 
a705					DMARK "UWu" 
a705 f5				push af  
a706 3a 1a a7			ld a, (.dmark)  
a709 32 71 ee			ld (debug_mark),a  
a70c 3a 1b a7			ld a, (.dmark+1)  
a70f 32 72 ee			ld (debug_mark+1),a  
a712 3a 1c a7			ld a, (.dmark+2)  
a715 32 73 ee			ld (debug_mark+2),a  
a718 18 03			jr .pastdmark  
a71a ..			.dmark: db "UWu"  
a71d f1			.pastdmark: pop af  
a71e			endm  
# End of macro DMARK
a71e					CALLMONITOR 
a71e cd dd 94			call break_point_state  
a721				endm  
# End of macro CALLMONITOR
a721				endif 
a721					; we have a uword so push its name to the stack 
a721			 
a721 e5				   	push hl  ; save so we can move to next dict block 
a722			 
a722					; skip opcode 
a722 23					inc hl  
a723					; skip next ptr 
a723 23					inc hl  
a724 23					inc hl 
a725					; skip len 
a725 23					inc hl 
a726				if DEBUG_FORTH_WORDS 
a726					DMARK "UWt" 
a726 f5				push af  
a727 3a 3b a7			ld a, (.dmark)  
a72a 32 71 ee			ld (debug_mark),a  
a72d 3a 3c a7			ld a, (.dmark+1)  
a730 32 72 ee			ld (debug_mark+1),a  
a733 3a 3d a7			ld a, (.dmark+2)  
a736 32 73 ee			ld (debug_mark+2),a  
a739 18 03			jr .pastdmark  
a73b ..			.dmark: db "UWt"  
a73e f1			.pastdmark: pop af  
a73f			endm  
# End of macro DMARK
a73f					CALLMONITOR 
a73f cd dd 94			call break_point_state  
a742				endm  
# End of macro CALLMONITOR
a742				endif 
a742 03					inc bc 
a743			 
a743 c5					push bc 
a744 cd e9 9b				call forth_push_str 
a747 c1					pop bc 
a748			 
a748 e1					pop hl 	 
a749			 
a749 cd 79 a0		.nuword:	call forth_tok_next 
a74c 18 92				jr .douscan  
a74e			 
a74e			.udone:		 ; push count of uwords found 
a74e c5					push bc 
a74f e1					pop hl 
a750			 
a750				if DEBUG_FORTH_WORDS 
a750					DMARK "UWc" 
a750 f5				push af  
a751 3a 65 a7			ld a, (.dmark)  
a754 32 71 ee			ld (debug_mark),a  
a757 3a 66 a7			ld a, (.dmark+1)  
a75a 32 72 ee			ld (debug_mark+1),a  
a75d 3a 67 a7			ld a, (.dmark+2)  
a760 32 73 ee			ld (debug_mark+2),a  
a763 18 03			jr .pastdmark  
a765 ..			.dmark: db "UWc"  
a768 f1			.pastdmark: pop af  
a769			endm  
# End of macro DMARK
a769					CALLMONITOR 
a769 cd dd 94			call break_point_state  
a76c				endm  
# End of macro CALLMONITOR
a76c				endif 
a76c cd 7b 9b				call forth_push_numhl 
a76f			 
a76f			 
a76f				       NEXTW 
a76f c3 28 9f			jp macro_next 
a772				endm 
# End of macro NEXTW
a772			 
a772			.BP: 
a772				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a772 54				db WORD_SYS_CORE+64             
a773 a8 a7			dw .MONITOR            
a775 03				db 2 + 1 
a776 .. 00			db "BP",0              
a779				endm 
# End of macro CWHEAD
a779			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a779			; | | $00 Will enable the break points within specific code paths 
a779			; | | $01 Will disable break points 
a779			; | |  
a779			; | | By default break points are off. Either the above can be used to enable them 
a779			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a779			; | | and on release of the pressed key a message will be disaplayed to notify 
a779			; | | that break points are enabled. Pressing any key will then continue boot process. 
a779					; get byte count 
a779					if DEBUG_FORTH_WORDS_KEY 
a779						DMARK "BP." 
a779 f5				push af  
a77a 3a 8e a7			ld a, (.dmark)  
a77d 32 71 ee			ld (debug_mark),a  
a780 3a 8f a7			ld a, (.dmark+1)  
a783 32 72 ee			ld (debug_mark+1),a  
a786 3a 90 a7			ld a, (.dmark+2)  
a789 32 73 ee			ld (debug_mark+2),a  
a78c 18 03			jr .pastdmark  
a78e ..			.dmark: db "BP."  
a791 f1			.pastdmark: pop af  
a792			endm  
# End of macro DMARK
a792						CALLMONITOR 
a792 cd dd 94			call break_point_state  
a795				endm  
# End of macro CALLMONITOR
a795					endif 
a795			 
a795					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a795 cd 72 9d			call macro_dsp_valuehl 
a798				endm 
# End of macro FORTH_DSP_VALUEHL
a798			 
a798			;		push hl 
a798			 
a798					; destroy value TOS 
a798			 
a798					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a798 cd 2a 9e			call macro_forth_dsp_pop 
a79b				endm 
# End of macro FORTH_DSP_POP
a79b			 
a79b			;		pop hl 
a79b			 
a79b 3e 00				ld a,0 
a79d bd					cp l 
a79e 28 02				jr z, .bpset 
a7a0 3e 2a				ld a, '*' 
a7a2			 
a7a2 32 b8 e2		.bpset:		ld (os_view_disable), a 
a7a5			 
a7a5			 
a7a5					NEXTW 
a7a5 c3 28 9f			jp macro_next 
a7a8				endm 
# End of macro NEXTW
a7a8			 
a7a8			 
a7a8			.MONITOR: 
a7a8				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a7a8 55				db WORD_SYS_CORE+65             
a7a9 db a7			dw .MALLOC            
a7ab 08				db 7 + 1 
a7ac .. 00			db "MONITOR",0              
a7b4				endm 
# End of macro CWHEAD
a7b4			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a7b4			; | | At start the current various registers will be displayed with contents. 
a7b4			; | | Top right corner will show the most recent debug marker seen. 
a7b4			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a7b4			; | | and the return stack pointer (RSP). 
a7b4			; | | Pressing: 
a7b4			; | |    1 - Initial screen 
a7b4			; | |    2 - Display a data dump of HL 
a7b4			; | |    3 - Display a data dump of DE 
a7b4			; | |    4 - Display a data dump of BC 
a7b4			; | |    5 - Display a data dump of HL 
a7b4			; | |    6 - Display a data dump of DSP 
a7b4			; | |    7 - Display a data dump of RSP 
a7b4			; | |    8 - Display a data dump of what is at DSP 
a7b4			; | |    9 - Display a data dump of what is at RSP 
a7b4			; | |    0 - Exit monitor and continue running. This will also enable break points 
a7b4			; | |    * - Disable break points 
a7b4			; | |    # - Enter traditional monitor mode 
a7b4			; | | 
a7b4			; | | Monitor Mode 
a7b4			; | | ------------ 
a7b4			; | | A prompt of '>' will be shown for various commands: 
a7b4			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a7b4			; | |    C - Continue display a data dump from the last set address 
a7b4			; | |    M xxxx - Set start of memory edit at address xx 
a7b4			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a7b4			; | |    Q - Return to previous 
a7b4					if DEBUG_FORTH_WORDS_KEY 
a7b4						DMARK "MON" 
a7b4 f5				push af  
a7b5 3a c9 a7			ld a, (.dmark)  
a7b8 32 71 ee			ld (debug_mark),a  
a7bb 3a ca a7			ld a, (.dmark+1)  
a7be 32 72 ee			ld (debug_mark+1),a  
a7c1 3a cb a7			ld a, (.dmark+2)  
a7c4 32 73 ee			ld (debug_mark+2),a  
a7c7 18 03			jr .pastdmark  
a7c9 ..			.dmark: db "MON"  
a7cc f1			.pastdmark: pop af  
a7cd			endm  
# End of macro DMARK
a7cd						CALLMONITOR 
a7cd cd dd 94			call break_point_state  
a7d0				endm  
# End of macro CALLMONITOR
a7d0					endif 
a7d0 3e 00				ld a, 0 
a7d2 32 b8 e2				ld (os_view_disable), a 
a7d5			 
a7d5					CALLMONITOR 
a7d5 cd dd 94			call break_point_state  
a7d8				endm  
# End of macro CALLMONITOR
a7d8			 
a7d8			;	call monitor 
a7d8			 
a7d8					NEXTW 
a7d8 c3 28 9f			jp macro_next 
a7db				endm 
# End of macro NEXTW
a7db			 
a7db			 
a7db			.MALLOC: 
a7db				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a7db 56				db WORD_SYS_CORE+66             
a7dc 04 a8			dw .MALLOC2            
a7de 06				db 5 + 1 
a7df .. 00			db "ALLOT",0              
a7e5				endm 
# End of macro CWHEAD
a7e5			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7e5					if DEBUG_FORTH_WORDS_KEY 
a7e5						DMARK "ALL" 
a7e5 f5				push af  
a7e6 3a fa a7			ld a, (.dmark)  
a7e9 32 71 ee			ld (debug_mark),a  
a7ec 3a fb a7			ld a, (.dmark+1)  
a7ef 32 72 ee			ld (debug_mark+1),a  
a7f2 3a fc a7			ld a, (.dmark+2)  
a7f5 32 73 ee			ld (debug_mark+2),a  
a7f8 18 03			jr .pastdmark  
a7fa ..			.dmark: db "ALL"  
a7fd f1			.pastdmark: pop af  
a7fe			endm  
# End of macro DMARK
a7fe						CALLMONITOR 
a7fe cd dd 94			call break_point_state  
a801				endm  
# End of macro CALLMONITOR
a801					endif 
a801 c3 2b a8				jp .mallocc 
a804			.MALLOC2: 
a804				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a804 56				db WORD_SYS_CORE+66             
a805 42 a8			dw .FREE            
a807 07				db 6 + 1 
a808 .. 00			db "MALLOC",0              
a80f				endm 
# End of macro CWHEAD
a80f			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a80f					; get byte count 
a80f					if DEBUG_FORTH_WORDS_KEY 
a80f						DMARK "MAL" 
a80f f5				push af  
a810 3a 24 a8			ld a, (.dmark)  
a813 32 71 ee			ld (debug_mark),a  
a816 3a 25 a8			ld a, (.dmark+1)  
a819 32 72 ee			ld (debug_mark+1),a  
a81c 3a 26 a8			ld a, (.dmark+2)  
a81f 32 73 ee			ld (debug_mark+2),a  
a822 18 03			jr .pastdmark  
a824 ..			.dmark: db "MAL"  
a827 f1			.pastdmark: pop af  
a828			endm  
# End of macro DMARK
a828						CALLMONITOR 
a828 cd dd 94			call break_point_state  
a82b				endm  
# End of macro CALLMONITOR
a82b					endif 
a82b			.mallocc: 
a82b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a82b cd 72 9d			call macro_dsp_valuehl 
a82e				endm 
# End of macro FORTH_DSP_VALUEHL
a82e			 
a82e			;		push hl 
a82e			 
a82e					; destroy value TOS 
a82e			 
a82e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a82e cd 2a 9e			call macro_forth_dsp_pop 
a831				endm 
# End of macro FORTH_DSP_POP
a831			 
a831			;		pop hl 
a831 cd a3 91				call malloc 
a834				if DEBUG_FORTH_MALLOC_GUARD 
a834 f5					push af 
a835 cd 05 8d				call ishlzero 
a838			;		ld a, l 
a838			;		add h 
a838			;		cp 0 
a838 f1					pop af 
a839					 
a839 cc 33 cc				call z,malloc_error 
a83c				endif 
a83c			 
a83c cd 7b 9b				call forth_push_numhl 
a83f					NEXTW 
a83f c3 28 9f			jp macro_next 
a842				endm 
# End of macro NEXTW
a842			 
a842			.FREE: 
a842				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a842 57				db WORD_SYS_CORE+67             
a843 73 a8			dw .LIST            
a845 05				db 4 + 1 
a846 .. 00			db "FREE",0              
a84b				endm 
# End of macro CWHEAD
a84b			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a84b					if DEBUG_FORTH_WORDS_KEY 
a84b						DMARK "FRE" 
a84b f5				push af  
a84c 3a 60 a8			ld a, (.dmark)  
a84f 32 71 ee			ld (debug_mark),a  
a852 3a 61 a8			ld a, (.dmark+1)  
a855 32 72 ee			ld (debug_mark+1),a  
a858 3a 62 a8			ld a, (.dmark+2)  
a85b 32 73 ee			ld (debug_mark+2),a  
a85e 18 03			jr .pastdmark  
a860 ..			.dmark: db "FRE"  
a863 f1			.pastdmark: pop af  
a864			endm  
# End of macro DMARK
a864						CALLMONITOR 
a864 cd dd 94			call break_point_state  
a867				endm  
# End of macro CALLMONITOR
a867					endif 
a867					; get address 
a867			 
a867					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a867 cd 72 9d			call macro_dsp_valuehl 
a86a				endm 
# End of macro FORTH_DSP_VALUEHL
a86a			 
a86a			;		push hl 
a86a			 
a86a					; destroy value TOS 
a86a			 
a86a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a86a cd 2a 9e			call macro_forth_dsp_pop 
a86d				endm 
# End of macro FORTH_DSP_POP
a86d			 
a86d			;		pop hl 
a86d			if FORTH_ENABLE_MALLOCFREE 
a86d cd 6d 92				call free 
a870			endif 
a870					NEXTW 
a870 c3 28 9f			jp macro_next 
a873				endm 
# End of macro NEXTW
a873			.LIST: 
a873				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a873 5c				db WORD_SYS_CORE+72             
a874 61 aa			dw .FORGET            
a876 05				db 4 + 1 
a877 .. 00			db "LIST",0              
a87c				endm 
# End of macro CWHEAD
a87c			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a87c			; | | The quoted word must be in upper case. 
a87c				if DEBUG_FORTH_WORDS_KEY 
a87c					DMARK "LST" 
a87c f5				push af  
a87d 3a 91 a8			ld a, (.dmark)  
a880 32 71 ee			ld (debug_mark),a  
a883 3a 92 a8			ld a, (.dmark+1)  
a886 32 72 ee			ld (debug_mark+1),a  
a889 3a 93 a8			ld a, (.dmark+2)  
a88c 32 73 ee			ld (debug_mark+2),a  
a88f 18 03			jr .pastdmark  
a891 ..			.dmark: db "LST"  
a894 f1			.pastdmark: pop af  
a895			endm  
# End of macro DMARK
a895					CALLMONITOR 
a895 cd dd 94			call break_point_state  
a898				endm  
# End of macro CALLMONITOR
a898				endif 
a898			 
a898					FORTH_DSP_VALUEHL 
a898 cd 72 9d			call macro_dsp_valuehl 
a89b				endm 
# End of macro FORTH_DSP_VALUEHL
a89b			 
a89b e5					push hl 
a89c					FORTH_DSP_POP 
a89c cd 2a 9e			call macro_forth_dsp_pop 
a89f				endm 
# End of macro FORTH_DSP_POP
a89f c1					pop bc 
a8a0			 
a8a0			; Start format of scratch string 
a8a0			 
a8a0 21 c7 e2				ld hl, scratch 
a8a3			 
a8a3 3e 3a				ld a, ':' 
a8a5 77					ld (hl),a 
a8a6 23					inc hl 
a8a7 3e 20				ld a, ' ' 
a8a9 77					ld (hl), a 
a8aa			 
a8aa					; Get ptr to the word we need to look up 
a8aa			 
a8aa			;		FORTH_DSP_VALUEHL 
a8aa					;v5 FORTH_DSP_VALUE 
a8aa				; TODO type check 
a8aa			;		inc hl    ; Skip type check  
a8aa			;		push hl 
a8aa			;		ex de, hl    ; put into DE 
a8aa			 
a8aa			 
a8aa 21 7d e3				ld hl, baseram 
a8ad					;ld hl, baseusermem 
a8ad			 
a8ad e5			push hl   ; sacreifical push 
a8ae			 
a8ae			.ldouscanm: 
a8ae e1				pop hl 
a8af			.ldouscan: 
a8af				if DEBUG_FORTH_WORDS 
a8af					DMARK "LSs" 
a8af f5				push af  
a8b0 3a c4 a8			ld a, (.dmark)  
a8b3 32 71 ee			ld (debug_mark),a  
a8b6 3a c5 a8			ld a, (.dmark+1)  
a8b9 32 72 ee			ld (debug_mark+1),a  
a8bc 3a c6 a8			ld a, (.dmark+2)  
a8bf 32 73 ee			ld (debug_mark+2),a  
a8c2 18 03			jr .pastdmark  
a8c4 ..			.dmark: db "LSs"  
a8c7 f1			.pastdmark: pop af  
a8c8			endm  
# End of macro DMARK
a8c8					CALLMONITOR 
a8c8 cd dd 94			call break_point_state  
a8cb				endm  
# End of macro CALLMONITOR
a8cb				endif 
a8cb				; skip dict stub 
a8cb cd 79 a0				call forth_tok_next 
a8ce			 
a8ce			 
a8ce			; while we have words to look for 
a8ce			 
a8ce 7e				ld a, (hl)      
a8cf				if DEBUG_FORTH_WORDS 
a8cf					DMARK "LSk" 
a8cf f5				push af  
a8d0 3a e4 a8			ld a, (.dmark)  
a8d3 32 71 ee			ld (debug_mark),a  
a8d6 3a e5 a8			ld a, (.dmark+1)  
a8d9 32 72 ee			ld (debug_mark+1),a  
a8dc 3a e6 a8			ld a, (.dmark+2)  
a8df 32 73 ee			ld (debug_mark+2),a  
a8e2 18 03			jr .pastdmark  
a8e4 ..			.dmark: db "LSk"  
a8e7 f1			.pastdmark: pop af  
a8e8			endm  
# End of macro DMARK
a8e8					CALLMONITOR 
a8e8 cd dd 94			call break_point_state  
a8eb				endm  
# End of macro CALLMONITOR
a8eb				endif 
a8eb					;cp WORD_SYS_END 
a8eb					;jp z, .lunotfound 
a8eb			 
a8eb					; if we hit non uwords then gone too far 
a8eb fe 01				cp WORD_SYS_UWORD 
a8ed c2 1d aa				jp nz, .lunotfound 
a8f0			 
a8f0				if DEBUG_FORTH_WORDS 
a8f0					DMARK "LSu" 
a8f0 f5				push af  
a8f1 3a 05 a9			ld a, (.dmark)  
a8f4 32 71 ee			ld (debug_mark),a  
a8f7 3a 06 a9			ld a, (.dmark+1)  
a8fa 32 72 ee			ld (debug_mark+1),a  
a8fd 3a 07 a9			ld a, (.dmark+2)  
a900 32 73 ee			ld (debug_mark+2),a  
a903 18 03			jr .pastdmark  
a905 ..			.dmark: db "LSu"  
a908 f1			.pastdmark: pop af  
a909			endm  
# End of macro DMARK
a909					CALLMONITOR 
a909 cd dd 94			call break_point_state  
a90c				endm  
# End of macro CALLMONITOR
a90c				endif 
a90c			 
a90c					; found a uword but is it the one we want... 
a90c			 
a90c c5					push bc     ; uword to find is on bc 
a90d d1					pop de 
a90e			 
a90e e5					push hl  ; to save the ptr 
a90f			 
a90f					; skip opcode 
a90f 23					inc hl  
a910					; skip next ptr 
a910 23					inc hl  
a911 23					inc hl 
a912					; skip len 
a912 23					inc hl 
a913			 
a913				if DEBUG_FORTH_WORDS 
a913					DMARK "LSc" 
a913 f5				push af  
a914 3a 28 a9			ld a, (.dmark)  
a917 32 71 ee			ld (debug_mark),a  
a91a 3a 29 a9			ld a, (.dmark+1)  
a91d 32 72 ee			ld (debug_mark+1),a  
a920 3a 2a a9			ld a, (.dmark+2)  
a923 32 73 ee			ld (debug_mark+2),a  
a926 18 03			jr .pastdmark  
a928 ..			.dmark: db "LSc"  
a92b f1			.pastdmark: pop af  
a92c			endm  
# End of macro DMARK
a92c					CALLMONITOR 
a92c cd dd 94			call break_point_state  
a92f				endm  
# End of macro CALLMONITOR
a92f				endif 
a92f cd 72 91				call strcmp 
a932 c2 ae a8				jp nz, .ldouscanm 
a935				 
a935			 
a935			 
a935					; we have a uword so push its name to the stack 
a935			 
a935			;	   	push hl  ; save so we can move to next dict block 
a935 e1			pop hl 
a936			 
a936				if DEBUG_FORTH_WORDS 
a936					DMARK "LSm" 
a936 f5				push af  
a937 3a 4b a9			ld a, (.dmark)  
a93a 32 71 ee			ld (debug_mark),a  
a93d 3a 4c a9			ld a, (.dmark+1)  
a940 32 72 ee			ld (debug_mark+1),a  
a943 3a 4d a9			ld a, (.dmark+2)  
a946 32 73 ee			ld (debug_mark+2),a  
a949 18 03			jr .pastdmark  
a94b ..			.dmark: db "LSm"  
a94e f1			.pastdmark: pop af  
a94f			endm  
# End of macro DMARK
a94f					CALLMONITOR 
a94f cd dd 94			call break_point_state  
a952				endm  
# End of macro CALLMONITOR
a952				endif 
a952			 
a952					; skip opcode 
a952 23					inc hl  
a953					; skip next ptr 
a953 23					inc hl  
a954 23					inc hl 
a955					; skip len 
a955 7e					ld a, (hl)   ; save length to add 
a956				if DEBUG_FORTH_WORDS 
a956					DMARK "LS2" 
a956 f5				push af  
a957 3a 6b a9			ld a, (.dmark)  
a95a 32 71 ee			ld (debug_mark),a  
a95d 3a 6c a9			ld a, (.dmark+1)  
a960 32 72 ee			ld (debug_mark+1),a  
a963 3a 6d a9			ld a, (.dmark+2)  
a966 32 73 ee			ld (debug_mark+2),a  
a969 18 03			jr .pastdmark  
a96b ..			.dmark: db "LS2"  
a96e f1			.pastdmark: pop af  
a96f			endm  
# End of macro DMARK
a96f					CALLMONITOR 
a96f cd dd 94			call break_point_state  
a972				endm  
# End of macro CALLMONITOR
a972				endif 
a972			 
a972					; save this location 
a972				 
a972 e5					push hl 
a973			 
a973 23					inc hl 
a974 11 c9 e2				ld de, scratch+2 
a977 4f					ld c, a 
a978 06 00				ld b, 0 
a97a			 
a97a				if DEBUG_FORTH_WORDS 
a97a					DMARK "LSn" 
a97a f5				push af  
a97b 3a 8f a9			ld a, (.dmark)  
a97e 32 71 ee			ld (debug_mark),a  
a981 3a 90 a9			ld a, (.dmark+1)  
a984 32 72 ee			ld (debug_mark+1),a  
a987 3a 91 a9			ld a, (.dmark+2)  
a98a 32 73 ee			ld (debug_mark+2),a  
a98d 18 03			jr .pastdmark  
a98f ..			.dmark: db "LSn"  
a992 f1			.pastdmark: pop af  
a993			endm  
# End of macro DMARK
a993					CALLMONITOR 
a993 cd dd 94			call break_point_state  
a996				endm  
# End of macro CALLMONITOR
a996				endif 
a996			 
a996					; copy uword name to scratch 
a996			 
a996 ed b0				ldir 
a998			 
a998 1b					dec de 
a999 3e 20				ld a, ' '    ; change null to space 
a99b 12					ld (de), a 
a99c			 
a99c 13					inc de 
a99d			 
a99d d5					push de 
a99e c1					pop bc     ; move scratch pointer to end of word name and save it 
a99f			 
a99f e1					pop hl 
a9a0 7e					ld a, (hl) 
a9a1					;inc hl 
a9a1					; skip word string 
a9a1 cd dc 8c				call addatohl 
a9a4			 
a9a4 23					inc hl 
a9a5			 
a9a5				if DEBUG_FORTH_WORDS 
a9a5					DMARK "LS3" 
a9a5 f5				push af  
a9a6 3a ba a9			ld a, (.dmark)  
a9a9 32 71 ee			ld (debug_mark),a  
a9ac 3a bb a9			ld a, (.dmark+1)  
a9af 32 72 ee			ld (debug_mark+1),a  
a9b2 3a bc a9			ld a, (.dmark+2)  
a9b5 32 73 ee			ld (debug_mark+2),a  
a9b8 18 03			jr .pastdmark  
a9ba ..			.dmark: db "LS3"  
a9bd f1			.pastdmark: pop af  
a9be			endm  
# End of macro DMARK
a9be					CALLMONITOR 
a9be cd dd 94			call break_point_state  
a9c1				endm  
# End of macro CALLMONITOR
a9c1				endif 
a9c1					; should now be at the start of the machine code to setup the eval of the uword 
a9c1					; now locate the ptr to the string defintion 
a9c1			 
a9c1					; skip ld hl, 
a9c1					; then load the ptr 
a9c1			; TODO use get from hl ptr 
a9c1 23					inc hl 
a9c2 5e					ld e, (hl) 
a9c3 23					inc hl 
a9c4 56					ld d, (hl) 
a9c5 eb					ex de, hl 
a9c6			 
a9c6			 
a9c6				if DEBUG_FORTH_WORDS 
a9c6					DMARK "LSt" 
a9c6 f5				push af  
a9c7 3a db a9			ld a, (.dmark)  
a9ca 32 71 ee			ld (debug_mark),a  
a9cd 3a dc a9			ld a, (.dmark+1)  
a9d0 32 72 ee			ld (debug_mark+1),a  
a9d3 3a dd a9			ld a, (.dmark+2)  
a9d6 32 73 ee			ld (debug_mark+2),a  
a9d9 18 03			jr .pastdmark  
a9db ..			.dmark: db "LSt"  
a9de f1			.pastdmark: pop af  
a9df			endm  
# End of macro DMARK
a9df					CALLMONITOR 
a9df cd dd 94			call break_point_state  
a9e2				endm  
# End of macro CALLMONITOR
a9e2				endif 
a9e2			 
a9e2			; cant push right now due to tokenised strings  
a9e2			 
a9e2			; get the destination of where to copy this definition to. 
a9e2			 
a9e2 c5					push bc 
a9e3 d1					pop de 
a9e4			 
a9e4 7e			.listl:         ld a,(hl) 
a9e5 fe 00				cp 0 
a9e7 28 09				jr z, .lreplsp     ; replace zero with space 
a9e9					;cp FORTH_END_BUFFER 
a9e9 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a9eb 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a9ed				 
a9ed					; just copy this char as is then 
a9ed			 
a9ed 12					ld (de), a 
a9ee			 
a9ee 23			.listnxt:	inc hl 
a9ef 13					inc de 
a9f0 18 f2				jr .listl 
a9f2			 
a9f2 3e 20		.lreplsp:	ld a,' ' 
a9f4 12					ld (de), a 
a9f5 18 f7				jr .listnxt 
a9f7			 
a9f7			; close up uword def 
a9f7			 
a9f7			.listdone: 
a9f7 12					ld (de), a 
a9f8 13					inc de 
a9f9 3e 00				ld a, 0 
a9fb 12					ld (de), a 
a9fc			 
a9fc			; now have def so clean up and push to stack 
a9fc			 
a9fc 21 c7 e2				ld hl, scratch 
a9ff				if DEBUG_FORTH_WORDS 
a9ff					DMARK "Ltp" 
a9ff f5				push af  
aa00 3a 14 aa			ld a, (.dmark)  
aa03 32 71 ee			ld (debug_mark),a  
aa06 3a 15 aa			ld a, (.dmark+1)  
aa09 32 72 ee			ld (debug_mark+1),a  
aa0c 3a 16 aa			ld a, (.dmark+2)  
aa0f 32 73 ee			ld (debug_mark+2),a  
aa12 18 03			jr .pastdmark  
aa14 ..			.dmark: db "Ltp"  
aa17 f1			.pastdmark: pop af  
aa18			endm  
# End of macro DMARK
aa18					CALLMONITOR 
aa18 cd dd 94			call break_point_state  
aa1b				endm  
# End of macro CALLMONITOR
aa1b				endif 
aa1b			 
aa1b 18 1f			jr .listpush 
aa1d			 
aa1d			;.lnuword:	pop hl 
aa1d			;		call forth_tok_next 
aa1d			;		jp .ldouscan  
aa1d			 
aa1d			.lunotfound:		  
aa1d			 
aa1d				if DEBUG_FORTH_WORDS 
aa1d					DMARK "LSn" 
aa1d f5				push af  
aa1e 3a 32 aa			ld a, (.dmark)  
aa21 32 71 ee			ld (debug_mark),a  
aa24 3a 33 aa			ld a, (.dmark+1)  
aa27 32 72 ee			ld (debug_mark+1),a  
aa2a 3a 34 aa			ld a, (.dmark+2)  
aa2d 32 73 ee			ld (debug_mark+2),a  
aa30 18 03			jr .pastdmark  
aa32 ..			.dmark: db "LSn"  
aa35 f1			.pastdmark: pop af  
aa36			endm  
# End of macro DMARK
aa36					CALLMONITOR 
aa36 cd dd 94			call break_point_state  
aa39				endm  
# End of macro CALLMONITOR
aa39				endif 
aa39			 
aa39					 
aa39			;		FORTH_DSP_POP 
aa39			;		ld hl, .luno 
aa39			 
aa39					NEXTW			 
aa39 c3 28 9f			jp macro_next 
aa3c				endm 
# End of macro NEXTW
aa3c			 
aa3c			.listpush: 
aa3c				if DEBUG_FORTH_WORDS 
aa3c					DMARK "LS>" 
aa3c f5				push af  
aa3d 3a 51 aa			ld a, (.dmark)  
aa40 32 71 ee			ld (debug_mark),a  
aa43 3a 52 aa			ld a, (.dmark+1)  
aa46 32 72 ee			ld (debug_mark+1),a  
aa49 3a 53 aa			ld a, (.dmark+2)  
aa4c 32 73 ee			ld (debug_mark+2),a  
aa4f 18 03			jr .pastdmark  
aa51 ..			.dmark: db "LS>"  
aa54 f1			.pastdmark: pop af  
aa55			endm  
# End of macro DMARK
aa55					CALLMONITOR 
aa55 cd dd 94			call break_point_state  
aa58				endm  
# End of macro CALLMONITOR
aa58				endif 
aa58 cd e9 9b				call forth_push_str 
aa5b			 
aa5b			 
aa5b			 
aa5b					NEXTW 
aa5b c3 28 9f			jp macro_next 
aa5e				endm 
# End of macro NEXTW
aa5e			 
aa5e			;.luno:    db "Word not found",0 
aa5e			 
aa5e			 
aa5e			 
aa5e			 
aa5e			 
aa5e			;		push hl   ; save pointer to start of uword def string 
aa5e			; 
aa5e			;; look for FORTH_EOL_LINE 
aa5e			;		ld a, FORTH_END_BUFFER 
aa5e			;		call strlent 
aa5e			; 
aa5e			;		inc hl		 ; space for coln def 
aa5e			;		inc hl 
aa5e			;		inc hl          ; space for terms 
aa5e			;		inc hl 
aa5e			; 
aa5e			;		ld a, 20   ; TODO get actual length 
aa5e			;		call addatohl    ; include a random amount of room for the uword name 
aa5e			; 
aa5e			;		 
aa5e			;	if DEBUG_FORTH_WORDS 
aa5e			;		DMARK "Lt1" 
aa5e			;		CALLMONITOR 
aa5e			;	endif 
aa5e			;		 
aa5e			; 
aa5e			;; malloc space for the string because we cant change it 
aa5e			; 
aa5e			;		call malloc 
aa5e			;	if DEBUG_FORTH_MALLOC_GUARD 
aa5e			;		push af 
aa5e			;		call ishlzero 
aa5e			;		pop af 
aa5e			;		 
aa5e			;		call z,malloc_error 
aa5e			;	endif 
aa5e			; 
aa5e			;	if DEBUG_FORTH_WORDS 
aa5e			;		DMARK "Lt2" 
aa5e			;		CALLMONITOR 
aa5e			;	endif 
aa5e			;		pop de 
aa5e			;		push hl    ; push the malloc to release later 
aa5e			;		push hl   ;  push back a copy for the later stack push 
aa5e			;		 
aa5e			;; copy the string swapping out the zero terms for spaces 
aa5e			; 
aa5e			;		; de has our source 
aa5e			;		; hl has our dest 
aa5e			; 
aa5e			;; add the coln def 
aa5e			; 
aa5e			;		ld a, ':' 
aa5e			;		ld (hl), a 
aa5e			;		inc hl 
aa5e			;		ld a, ' ' 
aa5e			;		ld (hl), a 
aa5e			;		inc hl 
aa5e			; 
aa5e			;; add the uname word 
aa5e			;		push de   ; save our string for now 
aa5e			;		ex de, hl 
aa5e			; 
aa5e			;		FORTH_DSP_VALUE 
aa5e			;		;v5 FORTH_DSP_VALUE 
aa5e			; 
aa5e			;		inc hl   ; skip type but we know by now this is OK 
aa5e			; 
aa5e			;.luword:	ld a,(hl) 
aa5e			;		cp 0 
aa5e			;		jr z, .luword2 
aa5e			;		ld (de), a 
aa5e			;		inc de 
aa5e			;		inc hl 
aa5e			;		jr .luword 
aa5e			; 
aa5e			;.luword2:	ld a, ' ' 
aa5e			;		ld (de), a 
aa5e			;;		inc hl 
aa5e			;;		inc de 
aa5e			;;		ld (de), a 
aa5e			;;		inc hl 
aa5e			;		inc de 
aa5e			; 
aa5e			;		ex de, hl 
aa5e			;		pop de 
aa5e			;		 
aa5e			;		 
aa5e			; 
aa5e			;; detoken that string and copy it 
aa5e			; 
aa5e			;	if DEBUG_FORTH_WORDS 
aa5e			;		DMARK "Lt2" 
aa5e			;		CALLMONITOR 
aa5e			;	endif 
aa5e			;.ldetok:	ld a, (de) 
aa5e			;		cp FORTH_END_BUFFER 
aa5e			;		jr z, .ldetokend 
aa5e			;		; swap out any zero term for space 
aa5e			;		cp 0 
aa5e			;		jr nz, .ldetoknext 
aa5e			;		ld a, ' ' 
aa5e			; 
aa5e			;	if DEBUG_FORTH_WORDS 
aa5e			;		DMARK "LtS" 
aa5e			;		CALLMONITOR 
aa5e			;	endif 
aa5e			;.ldetoknext:	ld (hl), a 
aa5e			;		inc de 
aa5e			;		inc hl 
aa5e			;		jr .ldetok 
aa5e			; 
aa5e			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
aa5e			;		ld (hl), a  
aa5e			; 
aa5e			;; free that temp malloc 
aa5e			; 
aa5e			;		pop hl    
aa5e			; 
aa5e			;	if DEBUG_FORTH_WORDS 
aa5e			;		DMARK "Lt4" 
aa5e			;		CALLMONITOR 
aa5e			;	endif 
aa5e			;		call forth_apushstrhl 
aa5e			; 
aa5e			;		; get rid of temp malloc area 
aa5e			; 
aa5e			;		pop hl 
aa5e			;		call free 
aa5e			; 
aa5e			;		jr .ludone 
aa5e			; 
aa5e			;.lnuword:	pop hl 
aa5e			;		call forth_tok_next 
aa5e			;		jp .ldouscan  
aa5e			; 
aa5e			;.ludone:		 pop hl 
aa5e			; 
aa5e					NEXTW 
aa5e c3 28 9f			jp macro_next 
aa61				endm 
# End of macro NEXTW
aa61			 
aa61			.FORGET: 
aa61				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
aa61 5d				db WORD_SYS_CORE+73             
aa62 da aa			dw .NOP            
aa64 07				db 6 + 1 
aa65 .. 00			db "FORGET",0              
aa6c				endm 
# End of macro CWHEAD
aa6c			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
aa6c			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
aa6c			; | |  
aa6c			; | | e.g. "MORE" forget 
aa6c					if DEBUG_FORTH_WORDS_KEY 
aa6c						DMARK "FRG" 
aa6c f5				push af  
aa6d 3a 81 aa			ld a, (.dmark)  
aa70 32 71 ee			ld (debug_mark),a  
aa73 3a 82 aa			ld a, (.dmark+1)  
aa76 32 72 ee			ld (debug_mark+1),a  
aa79 3a 83 aa			ld a, (.dmark+2)  
aa7c 32 73 ee			ld (debug_mark+2),a  
aa7f 18 03			jr .pastdmark  
aa81 ..			.dmark: db "FRG"  
aa84 f1			.pastdmark: pop af  
aa85			endm  
# End of macro DMARK
aa85						CALLMONITOR 
aa85 cd dd 94			call break_point_state  
aa88				endm  
# End of macro CALLMONITOR
aa88					endif 
aa88			 
aa88				; find uword 
aa88			        ; update start of word with "_" 
aa88				; replace uword with deleted flag 
aa88			 
aa88			 
aa88			;	if DEBUG_FORTH_WORDS 
aa88			;		DMARK "FOG" 
aa88			;		CALLMONITOR 
aa88			;	endif 
aa88			 
aa88			 
aa88					; Get ptr to the word we need to look up 
aa88			 
aa88					FORTH_DSP_VALUEHL 
aa88 cd 72 9d			call macro_dsp_valuehl 
aa8b				endm 
# End of macro FORTH_DSP_VALUEHL
aa8b					;v5 FORTH_DSP_VALUE 
aa8b				; TODO type check 
aa8b			;		inc hl    ; Skip type check  
aa8b e5					push hl 
aa8c c1					pop bc 
aa8d			;		ex de, hl    ; put into DE 
aa8d			 
aa8d			 
aa8d 21 7d e3				ld hl, baseram 
aa90					;ld hl, baseusermem 
aa90			 
aa90				; skip dict stub 
aa90			;	call forth_tok_next 
aa90 e5			push hl   ; sacreifical push 
aa91			 
aa91			.fldouscanm: 
aa91 e1				pop hl 
aa92			.fldouscan: 
aa92			;	if DEBUG_FORTH_WORDS 
aa92			;		DMARK "LSs" 
aa92			;		CALLMONITOR 
aa92			;	endif 
aa92				; skip dict stub 
aa92 cd 79 a0				call forth_tok_next 
aa95			 
aa95			 
aa95			; while we have words to look for 
aa95			 
aa95 7e				ld a, (hl)      
aa96			;	if DEBUG_FORTH_WORDS 
aa96			;		DMARK "LSk" 
aa96			;		CALLMONITOR 
aa96			;	endif 
aa96 fe 00				cp WORD_SYS_END 
aa98 ca d4 aa				jp z, .flunotfound 
aa9b fe 01				cp WORD_SYS_UWORD 
aa9d c2 92 aa				jp nz, .fldouscan 
aaa0			 
aaa0			;	if DEBUG_FORTH_WORDS 
aaa0			;		DMARK "LSu" 
aaa0			;		CALLMONITOR 
aaa0			;	endif 
aaa0			 
aaa0					; found a uword but is it the one we want... 
aaa0			 
aaa0 c5					push bc     ; uword to find is on bc 
aaa1 d1					pop de 
aaa2			 
aaa2 e5					push hl  ; to save the ptr 
aaa3			 
aaa3					; skip opcode 
aaa3 23					inc hl  
aaa4					; skip next ptr 
aaa4 23					inc hl  
aaa5 23					inc hl 
aaa6					; skip len 
aaa6 23					inc hl 
aaa7			 
aaa7			;	if DEBUG_FORTH_WORDS 
aaa7			;		DMARK "LSc" 
aaa7			;		CALLMONITOR 
aaa7			;	endif 
aaa7 cd 72 91				call strcmp 
aaaa c2 91 aa				jp nz, .fldouscanm 
aaad			; 
aaad			; 
aaad			;; while we have words to look for 
aaad			; 
aaad			;.fdouscan:	ld a, (hl)      
aaad			;	if DEBUG_FORTH_WORDS 
aaad			;		DMARK "LSs" 
aaad			;		CALLMONITOR 
aaad			;	endif 
aaad			;		cp WORD_SYS_END 
aaad			;		jp z, .fudone 
aaad			;		cp WORD_SYS_UWORD 
aaad			;		jp nz, .fnuword 
aaad			; 
aaad			;	if DEBUG_FORTH_WORDS 
aaad			;		DMARK "FGu" 
aaad			;		CALLMONITOR 
aaad			;	endif 
aaad			; 
aaad			;		; found a uword but is it the one we want... 
aaad			; 
aaad			; 
aaad			;	        pop de   ; get back the dsp name 
aaad			;		push de 
aaad			; 
aaad			;		push hl  ; to save the ptr 
aaad			; 
aaad			;		; skip opcode 
aaad			;		inc hl  
aaad			;		; skip next ptr 
aaad			;		inc hl  
aaad			;		inc hl 
aaad			;		; skip len 
aaad			;		inc hl 
aaad			; 
aaad			;	if DEBUG_FORTH_WORDS 
aaad			;		DMARK "FGc" 
aaad			;		CALLMONITOR 
aaad			;	endif 
aaad			;		call strcmp 
aaad			;		jp nz, .fnuword 
aaad			 
aaad			 
aaad e1			pop hl 
aaae			 
aaae				 
aaae				if DEBUG_FORTH_WORDS 
aaae					DMARK "FGm" 
aaae f5				push af  
aaaf 3a c3 aa			ld a, (.dmark)  
aab2 32 71 ee			ld (debug_mark),a  
aab5 3a c4 aa			ld a, (.dmark+1)  
aab8 32 72 ee			ld (debug_mark+1),a  
aabb 3a c5 aa			ld a, (.dmark+2)  
aabe 32 73 ee			ld (debug_mark+2),a  
aac1 18 03			jr .pastdmark  
aac3 ..			.dmark: db "FGm"  
aac6 f1			.pastdmark: pop af  
aac7			endm  
# End of macro DMARK
aac7					CALLMONITOR 
aac7 cd dd 94			call break_point_state  
aaca				endm  
# End of macro CALLMONITOR
aaca				endif 
aaca			 
aaca			 
aaca			 
aaca					; we have a uword so push its name to the stack 
aaca			 
aaca			;	   	push hl  ; save so we can move to next dict block 
aaca			;pop hl 
aaca			 
aaca					; update opcode to deleted 
aaca 3e 03				ld a, WORD_SYS_DELETED 
aacc 77					ld (hl), a 
aacd			 
aacd 23					inc hl  
aace					; skip next ptr 
aace 23					inc hl  
aacf 23					inc hl 
aad0					; skip len 
aad0 23					inc hl 
aad1			 
aad1					; TODO change parser to skip deleted words but for now mark it out 
aad1 3e 5f				ld a, "_" 
aad3 77					ld  (hl),a 
aad4			 
aad4			;		jr .fudone 
aad4			; 
aad4			;.fnuword:	pop hl 
aad4			;		call forth_tok_next 
aad4			;		jp .fdouscan  
aad4			 
aad4			.flunotfound:		  
aad4			 
aad4			 
aad4					 
aad4					FORTH_DSP_POP 
aad4 cd 2a 9e			call macro_forth_dsp_pop 
aad7				endm 
# End of macro FORTH_DSP_POP
aad7			;		ld hl, .luno 
aad7			;.fudone:		 pop hl 
aad7					NEXTW 
aad7 c3 28 9f			jp macro_next 
aada				endm 
# End of macro NEXTW
aada			.NOP: 
aada				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aada 61				db WORD_SYS_CORE+77             
aadb 01 ab			dw .COMO            
aadd 04				db 3 + 1 
aade .. 00			db "NOP",0              
aae2				endm 
# End of macro CWHEAD
aae2			; | NOP (  --  ) Do nothing | DONE 
aae2					if DEBUG_FORTH_WORDS_KEY 
aae2						DMARK "NOP" 
aae2 f5				push af  
aae3 3a f7 aa			ld a, (.dmark)  
aae6 32 71 ee			ld (debug_mark),a  
aae9 3a f8 aa			ld a, (.dmark+1)  
aaec 32 72 ee			ld (debug_mark+1),a  
aaef 3a f9 aa			ld a, (.dmark+2)  
aaf2 32 73 ee			ld (debug_mark+2),a  
aaf5 18 03			jr .pastdmark  
aaf7 ..			.dmark: db "NOP"  
aafa f1			.pastdmark: pop af  
aafb			endm  
# End of macro DMARK
aafb						CALLMONITOR 
aafb cd dd 94			call break_point_state  
aafe				endm  
# End of macro CALLMONITOR
aafe					endif 
aafe				       NEXTW 
aafe c3 28 9f			jp macro_next 
ab01				endm 
# End of macro NEXTW
ab01			.COMO: 
ab01				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
ab01 6e				db WORD_SYS_CORE+90             
ab02 53 ab			dw .COMC            
ab04 02				db 1 + 1 
ab05 .. 00			db "(",0              
ab07				endm 
# End of macro CWHEAD
ab07			; | ( ( -- )  Start of comment | DONE 
ab07			 
ab07			 
ab07 2a c8 e5				ld hl, ( os_tok_ptr) 
ab0a 11 4e ab			ld de, .closepar 
ab0d					 
ab0d					if DEBUG_FORTH_WORDS 
ab0d						DMARK ").." 
ab0d f5				push af  
ab0e 3a 22 ab			ld a, (.dmark)  
ab11 32 71 ee			ld (debug_mark),a  
ab14 3a 23 ab			ld a, (.dmark+1)  
ab17 32 72 ee			ld (debug_mark+1),a  
ab1a 3a 24 ab			ld a, (.dmark+2)  
ab1d 32 73 ee			ld (debug_mark+2),a  
ab20 18 03			jr .pastdmark  
ab22 ..			.dmark: db ").."  
ab25 f1			.pastdmark: pop af  
ab26			endm  
# End of macro DMARK
ab26						CALLMONITOR 
ab26 cd dd 94			call break_point_state  
ab29				endm  
# End of macro CALLMONITOR
ab29					endif 
ab29 cd 43 a0			call findnexttok  
ab2c			 
ab2c					if DEBUG_FORTH_WORDS 
ab2c						DMARK "IF5" 
ab2c f5				push af  
ab2d 3a 41 ab			ld a, (.dmark)  
ab30 32 71 ee			ld (debug_mark),a  
ab33 3a 42 ab			ld a, (.dmark+1)  
ab36 32 72 ee			ld (debug_mark+1),a  
ab39 3a 43 ab			ld a, (.dmark+2)  
ab3c 32 73 ee			ld (debug_mark+2),a  
ab3f 18 03			jr .pastdmark  
ab41 ..			.dmark: db "IF5"  
ab44 f1			.pastdmark: pop af  
ab45			endm  
# End of macro DMARK
ab45						CALLMONITOR 
ab45 cd dd 94			call break_point_state  
ab48				endm  
# End of macro CALLMONITOR
ab48					endif 
ab48				; replace below with ) exec using tok_ptr 
ab48 22 c8 e5			ld (os_tok_ptr), hl 
ab4b c3 b9 9f			jp exec1 
ab4e			 
ab4e .. 00			.closepar:   db ")",0 
ab50			 
ab50				       NEXTW 
ab50 c3 28 9f			jp macro_next 
ab53				endm 
# End of macro NEXTW
ab53			.COMC: 
ab53				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ab53 6f				db WORD_SYS_CORE+91             
ab54 5c ab			dw .SCRATCH            
ab56 02				db 1 + 1 
ab57 .. 00			db ")",0              
ab59				endm 
# End of macro CWHEAD
ab59			; | ) ( -- )  End of comment |  DONE  
ab59				       NEXTW 
ab59 c3 28 9f			jp macro_next 
ab5c				endm 
# End of macro NEXTW
ab5c			 
ab5c			.SCRATCH: 
ab5c				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ab5c 6f				db WORD_SYS_CORE+91             
ab5d 97 ab			dw .INC            
ab5f 08				db 7 + 1 
ab60 .. 00			db "SCRATCH",0              
ab68				endm 
# End of macro CWHEAD
ab68			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ab68			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ab68			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ab68			; | |  
ab68			; | | e.g.    : score $00 scratch ; 
ab68			; | |  
ab68			; | | $00 score ! 
ab68			; | | $01 score +! 
ab68			; | |  
ab68			; | | e.g.   : varword $0a scratch ;  
ab68			; | | 
ab68			; | | $8000 varword ! 
ab68					if DEBUG_FORTH_WORDS_KEY 
ab68						DMARK "SCR" 
ab68 f5				push af  
ab69 3a 7d ab			ld a, (.dmark)  
ab6c 32 71 ee			ld (debug_mark),a  
ab6f 3a 7e ab			ld a, (.dmark+1)  
ab72 32 72 ee			ld (debug_mark+1),a  
ab75 3a 7f ab			ld a, (.dmark+2)  
ab78 32 73 ee			ld (debug_mark+2),a  
ab7b 18 03			jr .pastdmark  
ab7d ..			.dmark: db "SCR"  
ab80 f1			.pastdmark: pop af  
ab81			endm  
# End of macro DMARK
ab81						CALLMONITOR 
ab81 cd dd 94			call break_point_state  
ab84				endm  
# End of macro CALLMONITOR
ab84					endif 
ab84			 
ab84					FORTH_DSP_VALUEHL 
ab84 cd 72 9d			call macro_dsp_valuehl 
ab87				endm 
# End of macro FORTH_DSP_VALUEHL
ab87				 
ab87					FORTH_DSP_POP 
ab87 cd 2a 9e			call macro_forth_dsp_pop 
ab8a				endm 
# End of macro FORTH_DSP_POP
ab8a			 
ab8a 7d					ld a, l 
ab8b 21 ec e7				ld hl, os_var_array 
ab8e cd dc 8c				call addatohl 
ab91			 
ab91 cd 7b 9b				call forth_push_numhl 
ab94			 
ab94				       NEXTW 
ab94 c3 28 9f			jp macro_next 
ab97				endm 
# End of macro NEXTW
ab97			 
ab97			.INC: 
ab97				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ab97 6f				db WORD_SYS_CORE+91             
ab98 eb ab			dw .DEC            
ab9a 03				db 2 + 1 
ab9b .. 00			db "+!",0              
ab9e				endm 
# End of macro CWHEAD
ab9e			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ab9e					if DEBUG_FORTH_WORDS_KEY 
ab9e						DMARK "+s_" 
ab9e f5				push af  
ab9f 3a b3 ab			ld a, (.dmark)  
aba2 32 71 ee			ld (debug_mark),a  
aba5 3a b4 ab			ld a, (.dmark+1)  
aba8 32 72 ee			ld (debug_mark+1),a  
abab 3a b5 ab			ld a, (.dmark+2)  
abae 32 73 ee			ld (debug_mark+2),a  
abb1 18 03			jr .pastdmark  
abb3 ..			.dmark: db "+s_"  
abb6 f1			.pastdmark: pop af  
abb7			endm  
# End of macro DMARK
abb7						CALLMONITOR 
abb7 cd dd 94			call break_point_state  
abba				endm  
# End of macro CALLMONITOR
abba					endif 
abba			 
abba					FORTH_DSP_VALUEHL 
abba cd 72 9d			call macro_dsp_valuehl 
abbd				endm 
# End of macro FORTH_DSP_VALUEHL
abbd			 
abbd e5					push hl   ; save address 
abbe			 
abbe					FORTH_DSP_POP 
abbe cd 2a 9e			call macro_forth_dsp_pop 
abc1				endm 
# End of macro FORTH_DSP_POP
abc1			 
abc1					FORTH_DSP_VALUEHL 
abc1 cd 72 9d			call macro_dsp_valuehl 
abc4				endm 
# End of macro FORTH_DSP_VALUEHL
abc4			 
abc4					FORTH_DSP_POP 
abc4 cd 2a 9e			call macro_forth_dsp_pop 
abc7				endm 
# End of macro FORTH_DSP_POP
abc7			 
abc7					; hl contains value to add to byte at a 
abc7				 
abc7 eb					ex de, hl 
abc8			 
abc8 e1					pop hl 
abc9			 
abc9					if DEBUG_FORTH_WORDS 
abc9						DMARK "INC" 
abc9 f5				push af  
abca 3a de ab			ld a, (.dmark)  
abcd 32 71 ee			ld (debug_mark),a  
abd0 3a df ab			ld a, (.dmark+1)  
abd3 32 72 ee			ld (debug_mark+1),a  
abd6 3a e0 ab			ld a, (.dmark+2)  
abd9 32 73 ee			ld (debug_mark+2),a  
abdc 18 03			jr .pastdmark  
abde ..			.dmark: db "INC"  
abe1 f1			.pastdmark: pop af  
abe2			endm  
# End of macro DMARK
abe2						CALLMONITOR 
abe2 cd dd 94			call break_point_state  
abe5				endm  
# End of macro CALLMONITOR
abe5					endif 
abe5			 
abe5 7e					ld a,(hl) 
abe6 83					add e 
abe7 77					ld (hl),a 
abe8			 
abe8			 
abe8			 
abe8				       NEXTW 
abe8 c3 28 9f			jp macro_next 
abeb				endm 
# End of macro NEXTW
abeb			 
abeb			.DEC: 
abeb				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
abeb 6f				db WORD_SYS_CORE+91             
abec 3c ac			dw .INC2            
abee 03				db 2 + 1 
abef .. 00			db "-!",0              
abf2				endm 
# End of macro CWHEAD
abf2			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
abf2					if DEBUG_FORTH_WORDS_KEY 
abf2						DMARK "-s_" 
abf2 f5				push af  
abf3 3a 07 ac			ld a, (.dmark)  
abf6 32 71 ee			ld (debug_mark),a  
abf9 3a 08 ac			ld a, (.dmark+1)  
abfc 32 72 ee			ld (debug_mark+1),a  
abff 3a 09 ac			ld a, (.dmark+2)  
ac02 32 73 ee			ld (debug_mark+2),a  
ac05 18 03			jr .pastdmark  
ac07 ..			.dmark: db "-s_"  
ac0a f1			.pastdmark: pop af  
ac0b			endm  
# End of macro DMARK
ac0b						CALLMONITOR 
ac0b cd dd 94			call break_point_state  
ac0e				endm  
# End of macro CALLMONITOR
ac0e					endif 
ac0e			 
ac0e					FORTH_DSP_VALUEHL 
ac0e cd 72 9d			call macro_dsp_valuehl 
ac11				endm 
# End of macro FORTH_DSP_VALUEHL
ac11			 
ac11 e5					push hl   ; save address 
ac12			 
ac12					FORTH_DSP_POP 
ac12 cd 2a 9e			call macro_forth_dsp_pop 
ac15				endm 
# End of macro FORTH_DSP_POP
ac15			 
ac15					FORTH_DSP_VALUEHL 
ac15 cd 72 9d			call macro_dsp_valuehl 
ac18				endm 
# End of macro FORTH_DSP_VALUEHL
ac18			 
ac18					; hl contains value to add to byte at a 
ac18				 
ac18 eb					ex de, hl 
ac19			 
ac19 e1					pop hl 
ac1a			 
ac1a					if DEBUG_FORTH_WORDS 
ac1a						DMARK "DEC" 
ac1a f5				push af  
ac1b 3a 2f ac			ld a, (.dmark)  
ac1e 32 71 ee			ld (debug_mark),a  
ac21 3a 30 ac			ld a, (.dmark+1)  
ac24 32 72 ee			ld (debug_mark+1),a  
ac27 3a 31 ac			ld a, (.dmark+2)  
ac2a 32 73 ee			ld (debug_mark+2),a  
ac2d 18 03			jr .pastdmark  
ac2f ..			.dmark: db "DEC"  
ac32 f1			.pastdmark: pop af  
ac33			endm  
# End of macro DMARK
ac33						CALLMONITOR 
ac33 cd dd 94			call break_point_state  
ac36				endm  
# End of macro CALLMONITOR
ac36					endif 
ac36			 
ac36 7e					ld a,(hl) 
ac37 93					sub e 
ac38 77					ld (hl),a 
ac39			 
ac39			 
ac39			 
ac39				       NEXTW 
ac39 c3 28 9f			jp macro_next 
ac3c				endm 
# End of macro NEXTW
ac3c			 
ac3c			.INC2: 
ac3c				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ac3c 6f				db WORD_SYS_CORE+91             
ac3d e6 ac			dw .DEC2            
ac3f 04				db 3 + 1 
ac40 .. 00			db "+2!",0              
ac44				endm 
# End of macro CWHEAD
ac44			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ac44			 
ac44					if DEBUG_FORTH_WORDS_KEY 
ac44						DMARK "+2s" 
ac44 f5				push af  
ac45 3a 59 ac			ld a, (.dmark)  
ac48 32 71 ee			ld (debug_mark),a  
ac4b 3a 5a ac			ld a, (.dmark+1)  
ac4e 32 72 ee			ld (debug_mark+1),a  
ac51 3a 5b ac			ld a, (.dmark+2)  
ac54 32 73 ee			ld (debug_mark+2),a  
ac57 18 03			jr .pastdmark  
ac59 ..			.dmark: db "+2s"  
ac5c f1			.pastdmark: pop af  
ac5d			endm  
# End of macro DMARK
ac5d						CALLMONITOR 
ac5d cd dd 94			call break_point_state  
ac60				endm  
# End of macro CALLMONITOR
ac60					endif 
ac60			 
ac60					; Address 
ac60			 
ac60					FORTH_DSP_VALUEHL 
ac60 cd 72 9d			call macro_dsp_valuehl 
ac63				endm 
# End of macro FORTH_DSP_VALUEHL
ac63			 
ac63 e5					push hl    ; save address 
ac64			 
ac64					; load content into de 
ac64			 
ac64 5e					ld e,(hl) 
ac65 23					inc hl 
ac66 56					ld d, (hl) 
ac67			 
ac67					if DEBUG_FORTH_WORDS 
ac67						DMARK "+2a" 
ac67 f5				push af  
ac68 3a 7c ac			ld a, (.dmark)  
ac6b 32 71 ee			ld (debug_mark),a  
ac6e 3a 7d ac			ld a, (.dmark+1)  
ac71 32 72 ee			ld (debug_mark+1),a  
ac74 3a 7e ac			ld a, (.dmark+2)  
ac77 32 73 ee			ld (debug_mark+2),a  
ac7a 18 03			jr .pastdmark  
ac7c ..			.dmark: db "+2a"  
ac7f f1			.pastdmark: pop af  
ac80			endm  
# End of macro DMARK
ac80						CALLMONITOR 
ac80 cd dd 94			call break_point_state  
ac83				endm  
# End of macro CALLMONITOR
ac83					endif 
ac83			 
ac83					FORTH_DSP_POP 
ac83 cd 2a 9e			call macro_forth_dsp_pop 
ac86				endm 
# End of macro FORTH_DSP_POP
ac86			 
ac86					; Get value to add 
ac86			 
ac86					FORTH_DSP_VALUE 
ac86 cd 5b 9d			call macro_forth_dsp_value 
ac89				endm 
# End of macro FORTH_DSP_VALUE
ac89			 
ac89					if DEBUG_FORTH_WORDS 
ac89						DMARK "+2v" 
ac89 f5				push af  
ac8a 3a 9e ac			ld a, (.dmark)  
ac8d 32 71 ee			ld (debug_mark),a  
ac90 3a 9f ac			ld a, (.dmark+1)  
ac93 32 72 ee			ld (debug_mark+1),a  
ac96 3a a0 ac			ld a, (.dmark+2)  
ac99 32 73 ee			ld (debug_mark+2),a  
ac9c 18 03			jr .pastdmark  
ac9e ..			.dmark: db "+2v"  
aca1 f1			.pastdmark: pop af  
aca2			endm  
# End of macro DMARK
aca2						CALLMONITOR 
aca2 cd dd 94			call break_point_state  
aca5				endm  
# End of macro CALLMONITOR
aca5					endif 
aca5			 
aca5 19					add hl, de 
aca6			 
aca6					if DEBUG_FORTH_WORDS 
aca6						DMARK "+2+" 
aca6 f5				push af  
aca7 3a bb ac			ld a, (.dmark)  
acaa 32 71 ee			ld (debug_mark),a  
acad 3a bc ac			ld a, (.dmark+1)  
acb0 32 72 ee			ld (debug_mark+1),a  
acb3 3a bd ac			ld a, (.dmark+2)  
acb6 32 73 ee			ld (debug_mark+2),a  
acb9 18 03			jr .pastdmark  
acbb ..			.dmark: db "+2+"  
acbe f1			.pastdmark: pop af  
acbf			endm  
# End of macro DMARK
acbf						CALLMONITOR 
acbf cd dd 94			call break_point_state  
acc2				endm  
# End of macro CALLMONITOR
acc2					endif 
acc2			 
acc2					; move result to de 
acc2			 
acc2 eb					ex de, hl 
acc3			 
acc3					; Address 
acc3			 
acc3 e1					pop hl 
acc4			 
acc4					; save it back 
acc4			 
acc4 73					ld (hl), e 
acc5 23					inc hl 
acc6 72					ld (hl), d 
acc7			 
acc7					if DEBUG_FORTH_WORDS 
acc7						DMARK "+2e" 
acc7 f5				push af  
acc8 3a dc ac			ld a, (.dmark)  
accb 32 71 ee			ld (debug_mark),a  
acce 3a dd ac			ld a, (.dmark+1)  
acd1 32 72 ee			ld (debug_mark+1),a  
acd4 3a de ac			ld a, (.dmark+2)  
acd7 32 73 ee			ld (debug_mark+2),a  
acda 18 03			jr .pastdmark  
acdc ..			.dmark: db "+2e"  
acdf f1			.pastdmark: pop af  
ace0			endm  
# End of macro DMARK
ace0						CALLMONITOR 
ace0 cd dd 94			call break_point_state  
ace3				endm  
# End of macro CALLMONITOR
ace3					endif 
ace3			 
ace3			 
ace3			 
ace3			 
ace3			 
ace3				       NEXTW 
ace3 c3 28 9f			jp macro_next 
ace6				endm 
# End of macro NEXTW
ace6			 
ace6			.DEC2: 
ace6				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
ace6 6f				db WORD_SYS_CORE+91             
ace7 92 ad			dw .GET2            
ace9 04				db 3 + 1 
acea .. 00			db "-2!",0              
acee				endm 
# End of macro CWHEAD
acee			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
acee			 
acee			 
acee					if DEBUG_FORTH_WORDS_KEY 
acee						DMARK "-2s" 
acee f5				push af  
acef 3a 03 ad			ld a, (.dmark)  
acf2 32 71 ee			ld (debug_mark),a  
acf5 3a 04 ad			ld a, (.dmark+1)  
acf8 32 72 ee			ld (debug_mark+1),a  
acfb 3a 05 ad			ld a, (.dmark+2)  
acfe 32 73 ee			ld (debug_mark+2),a  
ad01 18 03			jr .pastdmark  
ad03 ..			.dmark: db "-2s"  
ad06 f1			.pastdmark: pop af  
ad07			endm  
# End of macro DMARK
ad07						CALLMONITOR 
ad07 cd dd 94			call break_point_state  
ad0a				endm  
# End of macro CALLMONITOR
ad0a					endif 
ad0a			 
ad0a					; Address 
ad0a			 
ad0a					FORTH_DSP_VALUEHL 
ad0a cd 72 9d			call macro_dsp_valuehl 
ad0d				endm 
# End of macro FORTH_DSP_VALUEHL
ad0d			 
ad0d e5					push hl    ; save address 
ad0e			 
ad0e					; load content into de 
ad0e			 
ad0e 5e					ld e,(hl) 
ad0f 23					inc hl 
ad10 56					ld d, (hl) 
ad11			 
ad11					if DEBUG_FORTH_WORDS 
ad11						DMARK "-2a" 
ad11 f5				push af  
ad12 3a 26 ad			ld a, (.dmark)  
ad15 32 71 ee			ld (debug_mark),a  
ad18 3a 27 ad			ld a, (.dmark+1)  
ad1b 32 72 ee			ld (debug_mark+1),a  
ad1e 3a 28 ad			ld a, (.dmark+2)  
ad21 32 73 ee			ld (debug_mark+2),a  
ad24 18 03			jr .pastdmark  
ad26 ..			.dmark: db "-2a"  
ad29 f1			.pastdmark: pop af  
ad2a			endm  
# End of macro DMARK
ad2a						CALLMONITOR 
ad2a cd dd 94			call break_point_state  
ad2d				endm  
# End of macro CALLMONITOR
ad2d					endif 
ad2d			 
ad2d					FORTH_DSP_POP 
ad2d cd 2a 9e			call macro_forth_dsp_pop 
ad30				endm 
# End of macro FORTH_DSP_POP
ad30			 
ad30					; Get value to remove 
ad30			 
ad30					FORTH_DSP_VALUE 
ad30 cd 5b 9d			call macro_forth_dsp_value 
ad33				endm 
# End of macro FORTH_DSP_VALUE
ad33			 
ad33					if DEBUG_FORTH_WORDS 
ad33						DMARK "-2v" 
ad33 f5				push af  
ad34 3a 48 ad			ld a, (.dmark)  
ad37 32 71 ee			ld (debug_mark),a  
ad3a 3a 49 ad			ld a, (.dmark+1)  
ad3d 32 72 ee			ld (debug_mark+1),a  
ad40 3a 4a ad			ld a, (.dmark+2)  
ad43 32 73 ee			ld (debug_mark+2),a  
ad46 18 03			jr .pastdmark  
ad48 ..			.dmark: db "-2v"  
ad4b f1			.pastdmark: pop af  
ad4c			endm  
# End of macro DMARK
ad4c						CALLMONITOR 
ad4c cd dd 94			call break_point_state  
ad4f				endm  
# End of macro CALLMONITOR
ad4f					endif 
ad4f			 
ad4f eb					ex de, hl 
ad50 ed 52				sbc hl, de 
ad52			 
ad52					if DEBUG_FORTH_WORDS 
ad52						DMARK "-2d" 
ad52 f5				push af  
ad53 3a 67 ad			ld a, (.dmark)  
ad56 32 71 ee			ld (debug_mark),a  
ad59 3a 68 ad			ld a, (.dmark+1)  
ad5c 32 72 ee			ld (debug_mark+1),a  
ad5f 3a 69 ad			ld a, (.dmark+2)  
ad62 32 73 ee			ld (debug_mark+2),a  
ad65 18 03			jr .pastdmark  
ad67 ..			.dmark: db "-2d"  
ad6a f1			.pastdmark: pop af  
ad6b			endm  
# End of macro DMARK
ad6b						CALLMONITOR 
ad6b cd dd 94			call break_point_state  
ad6e				endm  
# End of macro CALLMONITOR
ad6e					endif 
ad6e			 
ad6e					; move result to de 
ad6e			 
ad6e eb					ex de, hl 
ad6f			 
ad6f					; Address 
ad6f			 
ad6f e1					pop hl 
ad70			 
ad70					; save it back 
ad70			 
ad70 73					ld (hl), e 
ad71 23					inc hl 
ad72 72					ld (hl), d 
ad73			 
ad73					if DEBUG_FORTH_WORDS 
ad73						DMARK "-2e" 
ad73 f5				push af  
ad74 3a 88 ad			ld a, (.dmark)  
ad77 32 71 ee			ld (debug_mark),a  
ad7a 3a 89 ad			ld a, (.dmark+1)  
ad7d 32 72 ee			ld (debug_mark+1),a  
ad80 3a 8a ad			ld a, (.dmark+2)  
ad83 32 73 ee			ld (debug_mark+2),a  
ad86 18 03			jr .pastdmark  
ad88 ..			.dmark: db "-2e"  
ad8b f1			.pastdmark: pop af  
ad8c			endm  
# End of macro DMARK
ad8c						CALLMONITOR 
ad8c cd dd 94			call break_point_state  
ad8f				endm  
# End of macro CALLMONITOR
ad8f					endif 
ad8f			 
ad8f			 
ad8f			 
ad8f			 
ad8f			 
ad8f				       NEXTW 
ad8f c3 28 9f			jp macro_next 
ad92				endm 
# End of macro NEXTW
ad92			.GET2: 
ad92				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ad92 6f				db WORD_SYS_CORE+91             
ad93 c2 ad			dw .BANG2            
ad95 03				db 2 + 1 
ad96 .. 00			db "2@",0              
ad99				endm 
# End of macro CWHEAD
ad99			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ad99					if DEBUG_FORTH_WORDS_KEY 
ad99						DMARK "2A_" 
ad99 f5				push af  
ad9a 3a ae ad			ld a, (.dmark)  
ad9d 32 71 ee			ld (debug_mark),a  
ada0 3a af ad			ld a, (.dmark+1)  
ada3 32 72 ee			ld (debug_mark+1),a  
ada6 3a b0 ad			ld a, (.dmark+2)  
ada9 32 73 ee			ld (debug_mark+2),a  
adac 18 03			jr .pastdmark  
adae ..			.dmark: db "2A_"  
adb1 f1			.pastdmark: pop af  
adb2			endm  
# End of macro DMARK
adb2						CALLMONITOR 
adb2 cd dd 94			call break_point_state  
adb5				endm  
# End of macro CALLMONITOR
adb5					endif 
adb5			 
adb5					FORTH_DSP_VALUEHL 
adb5 cd 72 9d			call macro_dsp_valuehl 
adb8				endm 
# End of macro FORTH_DSP_VALUEHL
adb8			 
adb8 5e					ld e, (hl) 
adb9 23					inc hl 
adba 56					ld d, (hl) 
adbb			 
adbb eb					ex de, hl 
adbc			 
adbc cd 7b 9b				call forth_push_numhl 
adbf			 
adbf				       NEXTW 
adbf c3 28 9f			jp macro_next 
adc2				endm 
# End of macro NEXTW
adc2			.BANG2: 
adc2				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
adc2 6f				db WORD_SYS_CORE+91             
adc3 fa ad			dw .CONFIG            
adc5 03				db 2 + 1 
adc6 .. 00			db "2!",0              
adc9				endm 
# End of macro CWHEAD
adc9			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
adc9					if DEBUG_FORTH_WORDS_KEY 
adc9						DMARK "2S_" 
adc9 f5				push af  
adca 3a de ad			ld a, (.dmark)  
adcd 32 71 ee			ld (debug_mark),a  
add0 3a df ad			ld a, (.dmark+1)  
add3 32 72 ee			ld (debug_mark+1),a  
add6 3a e0 ad			ld a, (.dmark+2)  
add9 32 73 ee			ld (debug_mark+2),a  
addc 18 03			jr .pastdmark  
adde ..			.dmark: db "2S_"  
ade1 f1			.pastdmark: pop af  
ade2			endm  
# End of macro DMARK
ade2						CALLMONITOR 
ade2 cd dd 94			call break_point_state  
ade5				endm  
# End of macro CALLMONITOR
ade5					endif 
ade5			 
ade5					FORTH_DSP_VALUEHL 
ade5 cd 72 9d			call macro_dsp_valuehl 
ade8				endm 
# End of macro FORTH_DSP_VALUEHL
ade8			 
ade8 e5					push hl   ; save address 
ade9			 
ade9			 
ade9					FORTH_DSP_POP 
ade9 cd 2a 9e			call macro_forth_dsp_pop 
adec				endm 
# End of macro FORTH_DSP_POP
adec			 
adec					 
adec					FORTH_DSP_VALUEHL 
adec cd 72 9d			call macro_dsp_valuehl 
adef				endm 
# End of macro FORTH_DSP_VALUEHL
adef			 
adef					FORTH_DSP_POP 
adef cd 2a 9e			call macro_forth_dsp_pop 
adf2				endm 
# End of macro FORTH_DSP_POP
adf2			 
adf2 eb					ex de, hl    ; value now in de 
adf3			 
adf3 e1					pop hl 
adf4			 
adf4 73					ld (hl), e 
adf5			 
adf5 23					inc hl 
adf6			 
adf6 72					ld (hl), d 
adf7			 
adf7			 
adf7				       NEXTW 
adf7 c3 28 9f			jp macro_next 
adfa				endm 
# End of macro NEXTW
adfa			.CONFIG: 
adfa				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
adfa 6f				db WORD_SYS_CORE+91             
adfb 0b ae			dw .ENDCORE            
adfd 07				db 6 + 1 
adfe .. 00			db "CONFIG",0              
ae05				endm 
# End of macro CWHEAD
ae05			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ae05			 
ae05 cd 3c 93				call config 
ae08					NEXTW 
ae08 c3 28 9f			jp macro_next 
ae0b				endm 
# End of macro NEXTW
ae0b			.ENDCORE: 
ae0b			 
ae0b			; eof 
ae0b			 
ae0b			 
# End of file forth_words_core.asm
ae0b			include "forth_words_flow.asm" 
ae0b			 
ae0b			; | ## Program Flow Words 
ae0b			 
ae0b			.IF: 
ae0b				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ae0b 1e				db WORD_SYS_CORE+10             
ae0c 00 af			dw .THEN            
ae0e 03				db 2 + 1 
ae0f .. 00			db "IF",0              
ae12				endm 
# End of macro CWHEAD
ae12			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ae12			; 
ae12					if DEBUG_FORTH_WORDS_KEY 
ae12						DMARK "IF." 
ae12 f5				push af  
ae13 3a 27 ae			ld a, (.dmark)  
ae16 32 71 ee			ld (debug_mark),a  
ae19 3a 28 ae			ld a, (.dmark+1)  
ae1c 32 72 ee			ld (debug_mark+1),a  
ae1f 3a 29 ae			ld a, (.dmark+2)  
ae22 32 73 ee			ld (debug_mark+2),a  
ae25 18 03			jr .pastdmark  
ae27 ..			.dmark: db "IF."  
ae2a f1			.pastdmark: pop af  
ae2b			endm  
# End of macro DMARK
ae2b						CALLMONITOR 
ae2b cd dd 94			call break_point_state  
ae2e				endm  
# End of macro CALLMONITOR
ae2e					endif 
ae2e			; eval TOS 
ae2e			 
ae2e				FORTH_DSP_VALUEHL 
ae2e cd 72 9d			call macro_dsp_valuehl 
ae31				endm 
# End of macro FORTH_DSP_VALUEHL
ae31			 
ae31			;	push hl 
ae31				FORTH_DSP_POP 
ae31 cd 2a 9e			call macro_forth_dsp_pop 
ae34				endm 
# End of macro FORTH_DSP_POP
ae34			;	pop hl 
ae34			 
ae34					if DEBUG_FORTH_WORDS 
ae34						DMARK "IF1" 
ae34 f5				push af  
ae35 3a 49 ae			ld a, (.dmark)  
ae38 32 71 ee			ld (debug_mark),a  
ae3b 3a 4a ae			ld a, (.dmark+1)  
ae3e 32 72 ee			ld (debug_mark+1),a  
ae41 3a 4b ae			ld a, (.dmark+2)  
ae44 32 73 ee			ld (debug_mark+2),a  
ae47 18 03			jr .pastdmark  
ae49 ..			.dmark: db "IF1"  
ae4c f1			.pastdmark: pop af  
ae4d			endm  
# End of macro DMARK
ae4d						CALLMONITOR 
ae4d cd dd 94			call break_point_state  
ae50				endm  
# End of macro CALLMONITOR
ae50					endif 
ae50 b7				or a        ; clear carry flag 
ae51 11 00 00			ld de, 0 
ae54 eb				ex de,hl 
ae55 ed 52			sbc hl, de 
ae57 c2 e1 ae			jp nz, .iftrue 
ae5a			 
ae5a					if DEBUG_FORTH_WORDS 
ae5a						DMARK "IF2" 
ae5a f5				push af  
ae5b 3a 6f ae			ld a, (.dmark)  
ae5e 32 71 ee			ld (debug_mark),a  
ae61 3a 70 ae			ld a, (.dmark+1)  
ae64 32 72 ee			ld (debug_mark+1),a  
ae67 3a 71 ae			ld a, (.dmark+2)  
ae6a 32 73 ee			ld (debug_mark+2),a  
ae6d 18 03			jr .pastdmark  
ae6f ..			.dmark: db "IF2"  
ae72 f1			.pastdmark: pop af  
ae73			endm  
# End of macro DMARK
ae73						CALLMONITOR 
ae73 cd dd 94			call break_point_state  
ae76				endm  
# End of macro CALLMONITOR
ae76					endif 
ae76			 
ae76			; if not true then skip to THEN 
ae76			 
ae76				; TODO get tok_ptr 
ae76				; TODO consume toks until we get to THEN 
ae76			 
ae76 2a c8 e5			ld hl, (os_tok_ptr) 
ae79					if DEBUG_FORTH_WORDS 
ae79						DMARK "IF3" 
ae79 f5				push af  
ae7a 3a 8e ae			ld a, (.dmark)  
ae7d 32 71 ee			ld (debug_mark),a  
ae80 3a 8f ae			ld a, (.dmark+1)  
ae83 32 72 ee			ld (debug_mark+1),a  
ae86 3a 90 ae			ld a, (.dmark+2)  
ae89 32 73 ee			ld (debug_mark+2),a  
ae8c 18 03			jr .pastdmark  
ae8e ..			.dmark: db "IF3"  
ae91 f1			.pastdmark: pop af  
ae92			endm  
# End of macro DMARK
ae92						CALLMONITOR 
ae92 cd dd 94			call break_point_state  
ae95				endm  
# End of macro CALLMONITOR
ae95						 
ae95					endif 
ae95 11 dc ae			ld de, .ifthen 
ae98					if DEBUG_FORTH_WORDS 
ae98						DMARK "IF4" 
ae98 f5				push af  
ae99 3a ad ae			ld a, (.dmark)  
ae9c 32 71 ee			ld (debug_mark),a  
ae9f 3a ae ae			ld a, (.dmark+1)  
aea2 32 72 ee			ld (debug_mark+1),a  
aea5 3a af ae			ld a, (.dmark+2)  
aea8 32 73 ee			ld (debug_mark+2),a  
aeab 18 03			jr .pastdmark  
aead ..			.dmark: db "IF4"  
aeb0 f1			.pastdmark: pop af  
aeb1			endm  
# End of macro DMARK
aeb1						CALLMONITOR 
aeb1 cd dd 94			call break_point_state  
aeb4				endm  
# End of macro CALLMONITOR
aeb4					endif 
aeb4 cd 43 a0			call findnexttok  
aeb7			 
aeb7					if DEBUG_FORTH_WORDS 
aeb7						DMARK "IF5" 
aeb7 f5				push af  
aeb8 3a cc ae			ld a, (.dmark)  
aebb 32 71 ee			ld (debug_mark),a  
aebe 3a cd ae			ld a, (.dmark+1)  
aec1 32 72 ee			ld (debug_mark+1),a  
aec4 3a ce ae			ld a, (.dmark+2)  
aec7 32 73 ee			ld (debug_mark+2),a  
aeca 18 03			jr .pastdmark  
aecc ..			.dmark: db "IF5"  
aecf f1			.pastdmark: pop af  
aed0			endm  
# End of macro DMARK
aed0						CALLMONITOR 
aed0 cd dd 94			call break_point_state  
aed3				endm  
# End of macro CALLMONITOR
aed3					endif 
aed3				; TODO replace below with ; exec using tok_ptr 
aed3 22 c8 e5			ld (os_tok_ptr), hl 
aed6 c3 b9 9f			jp exec1 
aed9				NEXTW 
aed9 c3 28 9f			jp macro_next 
aedc				endm 
# End of macro NEXTW
aedc			 
aedc .. 00		.ifthen:  db "THEN",0 
aee1			 
aee1			.iftrue:		 
aee1				; Exec next words normally 
aee1			 
aee1				; if true then exec following IF as normal 
aee1					if DEBUG_FORTH_WORDS 
aee1						DMARK "IFT" 
aee1 f5				push af  
aee2 3a f6 ae			ld a, (.dmark)  
aee5 32 71 ee			ld (debug_mark),a  
aee8 3a f7 ae			ld a, (.dmark+1)  
aeeb 32 72 ee			ld (debug_mark+1),a  
aeee 3a f8 ae			ld a, (.dmark+2)  
aef1 32 73 ee			ld (debug_mark+2),a  
aef4 18 03			jr .pastdmark  
aef6 ..			.dmark: db "IFT"  
aef9 f1			.pastdmark: pop af  
aefa			endm  
# End of macro DMARK
aefa						CALLMONITOR 
aefa cd dd 94			call break_point_state  
aefd				endm  
# End of macro CALLMONITOR
aefd					endif 
aefd			 
aefd					NEXTW 
aefd c3 28 9f			jp macro_next 
af00				endm 
# End of macro NEXTW
af00			.THEN: 
af00				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
af00 1f				db WORD_SYS_CORE+11             
af01 28 af			dw .ELSE            
af03 05				db 4 + 1 
af04 .. 00			db "THEN",0              
af09				endm 
# End of macro CWHEAD
af09			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
af09					if DEBUG_FORTH_WORDS_KEY 
af09						DMARK "THN" 
af09 f5				push af  
af0a 3a 1e af			ld a, (.dmark)  
af0d 32 71 ee			ld (debug_mark),a  
af10 3a 1f af			ld a, (.dmark+1)  
af13 32 72 ee			ld (debug_mark+1),a  
af16 3a 20 af			ld a, (.dmark+2)  
af19 32 73 ee			ld (debug_mark+2),a  
af1c 18 03			jr .pastdmark  
af1e ..			.dmark: db "THN"  
af21 f1			.pastdmark: pop af  
af22			endm  
# End of macro DMARK
af22						CALLMONITOR 
af22 cd dd 94			call break_point_state  
af25				endm  
# End of macro CALLMONITOR
af25					endif 
af25					NEXTW 
af25 c3 28 9f			jp macro_next 
af28				endm 
# End of macro NEXTW
af28			.ELSE: 
af28				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
af28 20				db WORD_SYS_CORE+12             
af29 50 af			dw .DO            
af2b 03				db 2 + 1 
af2c .. 00			db "ELSE",0              
af31				endm 
# End of macro CWHEAD
af31			; | ELSE ( -- ) Not supported - does nothing | TODO 
af31			 
af31					if DEBUG_FORTH_WORDS_KEY 
af31						DMARK "ELS" 
af31 f5				push af  
af32 3a 46 af			ld a, (.dmark)  
af35 32 71 ee			ld (debug_mark),a  
af38 3a 47 af			ld a, (.dmark+1)  
af3b 32 72 ee			ld (debug_mark+1),a  
af3e 3a 48 af			ld a, (.dmark+2)  
af41 32 73 ee			ld (debug_mark+2),a  
af44 18 03			jr .pastdmark  
af46 ..			.dmark: db "ELS"  
af49 f1			.pastdmark: pop af  
af4a			endm  
# End of macro DMARK
af4a						CALLMONITOR 
af4a cd dd 94			call break_point_state  
af4d				endm  
# End of macro CALLMONITOR
af4d					endif 
af4d			 
af4d			 
af4d					NEXTW 
af4d c3 28 9f			jp macro_next 
af50				endm 
# End of macro NEXTW
af50			.DO: 
af50				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
af50 21				db WORD_SYS_CORE+13             
af51 77 b0			dw .LOOP            
af53 03				db 2 + 1 
af54 .. 00			db "DO",0              
af57				endm 
# End of macro CWHEAD
af57			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
af57			 
af57					if DEBUG_FORTH_WORDS_KEY 
af57						DMARK "DO." 
af57 f5				push af  
af58 3a 6c af			ld a, (.dmark)  
af5b 32 71 ee			ld (debug_mark),a  
af5e 3a 6d af			ld a, (.dmark+1)  
af61 32 72 ee			ld (debug_mark+1),a  
af64 3a 6e af			ld a, (.dmark+2)  
af67 32 73 ee			ld (debug_mark+2),a  
af6a 18 03			jr .pastdmark  
af6c ..			.dmark: db "DO."  
af6f f1			.pastdmark: pop af  
af70			endm  
# End of macro DMARK
af70						CALLMONITOR 
af70 cd dd 94			call break_point_state  
af73				endm  
# End of macro CALLMONITOR
af73					endif 
af73			;  push pc to rsp stack past the DO 
af73			 
af73 2a c8 e5				ld hl, (os_tok_ptr) 
af76 23					inc hl   ; D 
af77 23					inc hl  ; O 
af78 23					inc hl   ; null 
af79					if DEBUG_FORTH_WORDS 
af79						DMARK "DO2" 
af79 f5				push af  
af7a 3a 8e af			ld a, (.dmark)  
af7d 32 71 ee			ld (debug_mark),a  
af80 3a 8f af			ld a, (.dmark+1)  
af83 32 72 ee			ld (debug_mark+1),a  
af86 3a 90 af			ld a, (.dmark+2)  
af89 32 73 ee			ld (debug_mark+2),a  
af8c 18 03			jr .pastdmark  
af8e ..			.dmark: db "DO2"  
af91 f1			.pastdmark: pop af  
af92			endm  
# End of macro DMARK
af92						CALLMONITOR 
af92 cd dd 94			call break_point_state  
af95				endm  
# End of macro CALLMONITOR
af95					endif 
af95					FORTH_RSP_NEXT 
af95 cd 22 9b			call macro_forth_rsp_next 
af98				endm 
# End of macro FORTH_RSP_NEXT
af98					if DEBUG_FORTH_WORDS 
af98						DMARK "DO3" 
af98 f5				push af  
af99 3a ad af			ld a, (.dmark)  
af9c 32 71 ee			ld (debug_mark),a  
af9f 3a ae af			ld a, (.dmark+1)  
afa2 32 72 ee			ld (debug_mark+1),a  
afa5 3a af af			ld a, (.dmark+2)  
afa8 32 73 ee			ld (debug_mark+2),a  
afab 18 03			jr .pastdmark  
afad ..			.dmark: db "DO3"  
afb0 f1			.pastdmark: pop af  
afb1			endm  
# End of macro DMARK
afb1						CALLMONITOR 
afb1 cd dd 94			call break_point_state  
afb4				endm  
# End of macro CALLMONITOR
afb4					endif 
afb4			 
afb4					;if DEBUG_FORTH_WORDS 
afb4				;		push hl 
afb4			;		endif  
afb4			 
afb4			; get counters from data stack 
afb4			 
afb4			 
afb4					FORTH_DSP_VALUEHL 
afb4 cd 72 9d			call macro_dsp_valuehl 
afb7				endm 
# End of macro FORTH_DSP_VALUEHL
afb7 e5					push hl		 ; hl now has starting counter which needs to be tos 
afb8			 
afb8					if DEBUG_FORTH_WORDS 
afb8						DMARK "DO4" 
afb8 f5				push af  
afb9 3a cd af			ld a, (.dmark)  
afbc 32 71 ee			ld (debug_mark),a  
afbf 3a ce af			ld a, (.dmark+1)  
afc2 32 72 ee			ld (debug_mark+1),a  
afc5 3a cf af			ld a, (.dmark+2)  
afc8 32 73 ee			ld (debug_mark+2),a  
afcb 18 03			jr .pastdmark  
afcd ..			.dmark: db "DO4"  
afd0 f1			.pastdmark: pop af  
afd1			endm  
# End of macro DMARK
afd1						CALLMONITOR 
afd1 cd dd 94			call break_point_state  
afd4				endm  
# End of macro CALLMONITOR
afd4					endif 
afd4					FORTH_DSP_POP 
afd4 cd 2a 9e			call macro_forth_dsp_pop 
afd7				endm 
# End of macro FORTH_DSP_POP
afd7			 
afd7					if DEBUG_FORTH_WORDS 
afd7						DMARK "DO5" 
afd7 f5				push af  
afd8 3a ec af			ld a, (.dmark)  
afdb 32 71 ee			ld (debug_mark),a  
afde 3a ed af			ld a, (.dmark+1)  
afe1 32 72 ee			ld (debug_mark+1),a  
afe4 3a ee af			ld a, (.dmark+2)  
afe7 32 73 ee			ld (debug_mark+2),a  
afea 18 03			jr .pastdmark  
afec ..			.dmark: db "DO5"  
afef f1			.pastdmark: pop af  
aff0			endm  
# End of macro DMARK
aff0						CALLMONITOR 
aff0 cd dd 94			call break_point_state  
aff3				endm  
# End of macro CALLMONITOR
aff3					endif 
aff3			 
aff3					FORTH_DSP_VALUEHL 
aff3 cd 72 9d			call macro_dsp_valuehl 
aff6				endm 
# End of macro FORTH_DSP_VALUEHL
aff6			;		push hl		 ; hl now has starting limit counter 
aff6			 
aff6					if DEBUG_FORTH_WORDS 
aff6						DMARK "DO6" 
aff6 f5				push af  
aff7 3a 0b b0			ld a, (.dmark)  
affa 32 71 ee			ld (debug_mark),a  
affd 3a 0c b0			ld a, (.dmark+1)  
b000 32 72 ee			ld (debug_mark+1),a  
b003 3a 0d b0			ld a, (.dmark+2)  
b006 32 73 ee			ld (debug_mark+2),a  
b009 18 03			jr .pastdmark  
b00b ..			.dmark: db "DO6"  
b00e f1			.pastdmark: pop af  
b00f			endm  
# End of macro DMARK
b00f						CALLMONITOR 
b00f cd dd 94			call break_point_state  
b012				endm  
# End of macro CALLMONITOR
b012					endif 
b012					FORTH_DSP_POP 
b012 cd 2a 9e			call macro_forth_dsp_pop 
b015				endm 
# End of macro FORTH_DSP_POP
b015			 
b015			; put counters on the loop stack 
b015			 
b015			;		pop hl			 ; limit counter 
b015 d1					pop de			; start counter 
b016			 
b016					; push limit counter 
b016			 
b016					if DEBUG_FORTH_WORDS 
b016						DMARK "DO7" 
b016 f5				push af  
b017 3a 2b b0			ld a, (.dmark)  
b01a 32 71 ee			ld (debug_mark),a  
b01d 3a 2c b0			ld a, (.dmark+1)  
b020 32 72 ee			ld (debug_mark+1),a  
b023 3a 2d b0			ld a, (.dmark+2)  
b026 32 73 ee			ld (debug_mark+2),a  
b029 18 03			jr .pastdmark  
b02b ..			.dmark: db "DO7"  
b02e f1			.pastdmark: pop af  
b02f			endm  
# End of macro DMARK
b02f						CALLMONITOR 
b02f cd dd 94			call break_point_state  
b032				endm  
# End of macro CALLMONITOR
b032					endif 
b032					FORTH_LOOP_NEXT 
b032 cd a3 9d			call macro_forth_loop_next 
b035				endm 
# End of macro FORTH_LOOP_NEXT
b035			 
b035					; push start counter 
b035			 
b035 eb					ex de, hl 
b036					if DEBUG_FORTH_WORDS 
b036						DMARK "DO7" 
b036 f5				push af  
b037 3a 4b b0			ld a, (.dmark)  
b03a 32 71 ee			ld (debug_mark),a  
b03d 3a 4c b0			ld a, (.dmark+1)  
b040 32 72 ee			ld (debug_mark+1),a  
b043 3a 4d b0			ld a, (.dmark+2)  
b046 32 73 ee			ld (debug_mark+2),a  
b049 18 03			jr .pastdmark  
b04b ..			.dmark: db "DO7"  
b04e f1			.pastdmark: pop af  
b04f			endm  
# End of macro DMARK
b04f						CALLMONITOR 
b04f cd dd 94			call break_point_state  
b052				endm  
# End of macro CALLMONITOR
b052					endif 
b052					FORTH_LOOP_NEXT 
b052 cd a3 9d			call macro_forth_loop_next 
b055				endm 
# End of macro FORTH_LOOP_NEXT
b055			 
b055			 
b055					; init first round of I counter 
b055			 
b055 22 ec e5				ld (os_current_i), hl 
b058			 
b058					if DEBUG_FORTH_WORDS 
b058						DMARK "DO8" 
b058 f5				push af  
b059 3a 6d b0			ld a, (.dmark)  
b05c 32 71 ee			ld (debug_mark),a  
b05f 3a 6e b0			ld a, (.dmark+1)  
b062 32 72 ee			ld (debug_mark+1),a  
b065 3a 6f b0			ld a, (.dmark+2)  
b068 32 73 ee			ld (debug_mark+2),a  
b06b 18 03			jr .pastdmark  
b06d ..			.dmark: db "DO8"  
b070 f1			.pastdmark: pop af  
b071			endm  
# End of macro DMARK
b071						CALLMONITOR 
b071 cd dd 94			call break_point_state  
b074				endm  
# End of macro CALLMONITOR
b074					endif 
b074			 
b074					NEXTW 
b074 c3 28 9f			jp macro_next 
b077				endm 
# End of macro NEXTW
b077			.LOOP: 
b077				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b077 22				db WORD_SYS_CORE+14             
b078 8f b1			dw .I            
b07a 05				db 4 + 1 
b07b .. 00			db "LOOP",0              
b080				endm 
# End of macro CWHEAD
b080			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b080			 
b080				; pop tos as current loop count to hl 
b080			 
b080				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b080			 
b080				FORTH_LOOP_TOS 
b080 cd d6 9d			call macro_forth_loop_tos 
b083				endm 
# End of macro FORTH_LOOP_TOS
b083 e5				push hl 
b084			 
b084					if DEBUG_FORTH_WORDS_KEY 
b084						DMARK "LOP" 
b084 f5				push af  
b085 3a 99 b0			ld a, (.dmark)  
b088 32 71 ee			ld (debug_mark),a  
b08b 3a 9a b0			ld a, (.dmark+1)  
b08e 32 72 ee			ld (debug_mark+1),a  
b091 3a 9b b0			ld a, (.dmark+2)  
b094 32 73 ee			ld (debug_mark+2),a  
b097 18 03			jr .pastdmark  
b099 ..			.dmark: db "LOP"  
b09c f1			.pastdmark: pop af  
b09d			endm  
# End of macro DMARK
b09d						CALLMONITOR 
b09d cd dd 94			call break_point_state  
b0a0				endm  
# End of macro CALLMONITOR
b0a0					endif 
b0a0				; next item on the stack is the limit. get it 
b0a0			 
b0a0			 
b0a0				FORTH_LOOP_POP 
b0a0 cd e0 9d			call macro_forth_loop_pop 
b0a3				endm 
# End of macro FORTH_LOOP_POP
b0a3			 
b0a3				FORTH_LOOP_TOS 
b0a3 cd d6 9d			call macro_forth_loop_tos 
b0a6				endm 
# End of macro FORTH_LOOP_TOS
b0a6			 
b0a6 d1				pop de		 ; de = i, hl = limit 
b0a7			 
b0a7					if DEBUG_FORTH_WORDS 
b0a7						DMARK "LP1" 
b0a7 f5				push af  
b0a8 3a bc b0			ld a, (.dmark)  
b0ab 32 71 ee			ld (debug_mark),a  
b0ae 3a bd b0			ld a, (.dmark+1)  
b0b1 32 72 ee			ld (debug_mark+1),a  
b0b4 3a be b0			ld a, (.dmark+2)  
b0b7 32 73 ee			ld (debug_mark+2),a  
b0ba 18 03			jr .pastdmark  
b0bc ..			.dmark: db "LP1"  
b0bf f1			.pastdmark: pop af  
b0c0			endm  
# End of macro DMARK
b0c0						CALLMONITOR 
b0c0 cd dd 94			call break_point_state  
b0c3				endm  
# End of macro CALLMONITOR
b0c3					endif 
b0c3			 
b0c3				; go back to previous word 
b0c3			 
b0c3 d5				push de    ; save I for inc later 
b0c4			 
b0c4			 
b0c4				; get limit 
b0c4				;  is I at limit? 
b0c4			 
b0c4			 
b0c4					if DEBUG_FORTH_WORDS 
b0c4						DMARK "LP1" 
b0c4 f5				push af  
b0c5 3a d9 b0			ld a, (.dmark)  
b0c8 32 71 ee			ld (debug_mark),a  
b0cb 3a da b0			ld a, (.dmark+1)  
b0ce 32 72 ee			ld (debug_mark+1),a  
b0d1 3a db b0			ld a, (.dmark+2)  
b0d4 32 73 ee			ld (debug_mark+2),a  
b0d7 18 03			jr .pastdmark  
b0d9 ..			.dmark: db "LP1"  
b0dc f1			.pastdmark: pop af  
b0dd			endm  
# End of macro DMARK
b0dd						CALLMONITOR 
b0dd cd dd 94			call break_point_state  
b0e0				endm  
# End of macro CALLMONITOR
b0e0					endif 
b0e0			 
b0e0 ed 52			sbc hl, de 
b0e2			 
b0e2			 
b0e2				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b0e2			 
b0e2 20 26				jr nz, .loopnotdone 
b0e4			 
b0e4 e1				pop hl   ; get rid of saved I 
b0e5				FORTH_LOOP_POP     ; get rid of limit 
b0e5 cd e0 9d			call macro_forth_loop_pop 
b0e8				endm 
# End of macro FORTH_LOOP_POP
b0e8			 
b0e8				FORTH_RSP_POP     ; get rid of DO ptr 
b0e8 cd 43 9b			call macro_forth_rsp_pop 
b0eb				endm 
# End of macro FORTH_RSP_POP
b0eb			 
b0eb			if DEBUG_FORTH_WORDS 
b0eb						DMARK "LP>" 
b0eb f5				push af  
b0ec 3a 00 b1			ld a, (.dmark)  
b0ef 32 71 ee			ld (debug_mark),a  
b0f2 3a 01 b1			ld a, (.dmark+1)  
b0f5 32 72 ee			ld (debug_mark+1),a  
b0f8 3a 02 b1			ld a, (.dmark+2)  
b0fb 32 73 ee			ld (debug_mark+2),a  
b0fe 18 03			jr .pastdmark  
b100 ..			.dmark: db "LP>"  
b103 f1			.pastdmark: pop af  
b104			endm  
# End of macro DMARK
b104				CALLMONITOR 
b104 cd dd 94			call break_point_state  
b107				endm  
# End of macro CALLMONITOR
b107			endif 
b107			 
b107					NEXTW 
b107 c3 28 9f			jp macro_next 
b10a				endm 
# End of macro NEXTW
b10a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b10a			 
b10a			.loopnotdone: 
b10a			 
b10a e1				pop hl    ; get I 
b10b 23				inc hl 
b10c			 
b10c			   	; save new I 
b10c			 
b10c			 
b10c					; set I counter 
b10c			 
b10c 22 ec e5				ld (os_current_i), hl 
b10f			 
b10f					if DEBUG_FORTH_WORDS 
b10f						DMARK "LPN" 
b10f f5				push af  
b110 3a 24 b1			ld a, (.dmark)  
b113 32 71 ee			ld (debug_mark),a  
b116 3a 25 b1			ld a, (.dmark+1)  
b119 32 72 ee			ld (debug_mark+1),a  
b11c 3a 26 b1			ld a, (.dmark+2)  
b11f 32 73 ee			ld (debug_mark+2),a  
b122 18 03			jr .pastdmark  
b124 ..			.dmark: db "LPN"  
b127 f1			.pastdmark: pop af  
b128			endm  
# End of macro DMARK
b128					CALLMONITOR 
b128 cd dd 94			call break_point_state  
b12b				endm  
# End of macro CALLMONITOR
b12b					endif 
b12b					 
b12b				FORTH_LOOP_NEXT 
b12b cd a3 9d			call macro_forth_loop_next 
b12e				endm 
# End of macro FORTH_LOOP_NEXT
b12e			 
b12e			 
b12e					if DEBUG_FORTH_WORDS 
b12e eb						ex de,hl 
b12f					endif 
b12f			 
b12f			;	; get DO ptr 
b12f			; 
b12f					if DEBUG_FORTH_WORDS 
b12f						DMARK "LP7" 
b12f f5				push af  
b130 3a 44 b1			ld a, (.dmark)  
b133 32 71 ee			ld (debug_mark),a  
b136 3a 45 b1			ld a, (.dmark+1)  
b139 32 72 ee			ld (debug_mark+1),a  
b13c 3a 46 b1			ld a, (.dmark+2)  
b13f 32 73 ee			ld (debug_mark+2),a  
b142 18 03			jr .pastdmark  
b144 ..			.dmark: db "LP7"  
b147 f1			.pastdmark: pop af  
b148			endm  
# End of macro DMARK
b148					CALLMONITOR 
b148 cd dd 94			call break_point_state  
b14b				endm  
# End of macro CALLMONITOR
b14b					endif 
b14b				FORTH_RSP_TOS 
b14b cd 39 9b			call macro_forth_rsp_tos 
b14e				endm 
# End of macro FORTH_RSP_TOS
b14e			 
b14e					if DEBUG_FORTH_WORDS 
b14e						DMARK "LP8" 
b14e f5				push af  
b14f 3a 63 b1			ld a, (.dmark)  
b152 32 71 ee			ld (debug_mark),a  
b155 3a 64 b1			ld a, (.dmark+1)  
b158 32 72 ee			ld (debug_mark+1),a  
b15b 3a 65 b1			ld a, (.dmark+2)  
b15e 32 73 ee			ld (debug_mark+2),a  
b161 18 03			jr .pastdmark  
b163 ..			.dmark: db "LP8"  
b166 f1			.pastdmark: pop af  
b167			endm  
# End of macro DMARK
b167					CALLMONITOR 
b167 cd dd 94			call break_point_state  
b16a				endm  
# End of macro CALLMONITOR
b16a					endif 
b16a				;push hl 
b16a			 
b16a				; not going to DO any more 
b16a				; get rid of the RSP pointer as DO will add it back in 
b16a				;FORTH_RSP_POP 
b16a				;pop hl 
b16a			 
b16a				;ld hl,(cli_ret_sp) 
b16a				;ld e, (hl) 
b16a				;inc hl 
b16a				;ld d, (hl) 
b16a				;ex de,hl 
b16a 22 c8 e5			ld (os_tok_ptr), hl 
b16d					if DEBUG_FORTH_WORDS 
b16d						DMARK "LP<" 
b16d f5				push af  
b16e 3a 82 b1			ld a, (.dmark)  
b171 32 71 ee			ld (debug_mark),a  
b174 3a 83 b1			ld a, (.dmark+1)  
b177 32 72 ee			ld (debug_mark+1),a  
b17a 3a 84 b1			ld a, (.dmark+2)  
b17d 32 73 ee			ld (debug_mark+2),a  
b180 18 03			jr .pastdmark  
b182 ..			.dmark: db "LP<"  
b185 f1			.pastdmark: pop af  
b186			endm  
# End of macro DMARK
b186					CALLMONITOR 
b186 cd dd 94			call break_point_state  
b189				endm  
# End of macro CALLMONITOR
b189				endif 
b189 c3 b9 9f			jp exec1 
b18c			 
b18c					 
b18c			 
b18c			 
b18c					NEXTW 
b18c c3 28 9f			jp macro_next 
b18f				endm 
# End of macro NEXTW
b18f			.I:  
b18f			 
b18f				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b18f 5e				db WORD_SYS_CORE+74             
b190 ba b1			dw .DLOOP            
b192 02				db 1 + 1 
b193 .. 00			db "I",0              
b195				endm 
# End of macro CWHEAD
b195			; | I ( -- ) Current loop counter | DONE 
b195					if DEBUG_FORTH_WORDS_KEY 
b195						DMARK "I.." 
b195 f5				push af  
b196 3a aa b1			ld a, (.dmark)  
b199 32 71 ee			ld (debug_mark),a  
b19c 3a ab b1			ld a, (.dmark+1)  
b19f 32 72 ee			ld (debug_mark+1),a  
b1a2 3a ac b1			ld a, (.dmark+2)  
b1a5 32 73 ee			ld (debug_mark+2),a  
b1a8 18 03			jr .pastdmark  
b1aa ..			.dmark: db "I.."  
b1ad f1			.pastdmark: pop af  
b1ae			endm  
# End of macro DMARK
b1ae						CALLMONITOR 
b1ae cd dd 94			call break_point_state  
b1b1				endm  
# End of macro CALLMONITOR
b1b1					endif 
b1b1			 
b1b1 2a ec e5				ld hl,(os_current_i) 
b1b4 cd 7b 9b				call forth_push_numhl 
b1b7			 
b1b7					NEXTW 
b1b7 c3 28 9f			jp macro_next 
b1ba				endm 
# End of macro NEXTW
b1ba			.DLOOP: 
b1ba				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b1ba 5f				db WORD_SYS_CORE+75             
b1bb 9b b2			dw .REPEAT            
b1bd 06				db 5 + 1 
b1be .. 00			db "-LOOP",0              
b1c4				endm 
# End of macro CWHEAD
b1c4			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b1c4				; pop tos as current loop count to hl 
b1c4					if DEBUG_FORTH_WORDS_KEY 
b1c4						DMARK "-LP" 
b1c4 f5				push af  
b1c5 3a d9 b1			ld a, (.dmark)  
b1c8 32 71 ee			ld (debug_mark),a  
b1cb 3a da b1			ld a, (.dmark+1)  
b1ce 32 72 ee			ld (debug_mark+1),a  
b1d1 3a db b1			ld a, (.dmark+2)  
b1d4 32 73 ee			ld (debug_mark+2),a  
b1d7 18 03			jr .pastdmark  
b1d9 ..			.dmark: db "-LP"  
b1dc f1			.pastdmark: pop af  
b1dd			endm  
# End of macro DMARK
b1dd						CALLMONITOR 
b1dd cd dd 94			call break_point_state  
b1e0				endm  
# End of macro CALLMONITOR
b1e0					endif 
b1e0			 
b1e0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b1e0			 
b1e0				FORTH_LOOP_TOS 
b1e0 cd d6 9d			call macro_forth_loop_tos 
b1e3				endm 
# End of macro FORTH_LOOP_TOS
b1e3 e5				push hl 
b1e4			 
b1e4					if DEBUG_FORTH_WORDS 
b1e4						DMARK "-LP" 
b1e4 f5				push af  
b1e5 3a f9 b1			ld a, (.dmark)  
b1e8 32 71 ee			ld (debug_mark),a  
b1eb 3a fa b1			ld a, (.dmark+1)  
b1ee 32 72 ee			ld (debug_mark+1),a  
b1f1 3a fb b1			ld a, (.dmark+2)  
b1f4 32 73 ee			ld (debug_mark+2),a  
b1f7 18 03			jr .pastdmark  
b1f9 ..			.dmark: db "-LP"  
b1fc f1			.pastdmark: pop af  
b1fd			endm  
# End of macro DMARK
b1fd						CALLMONITOR 
b1fd cd dd 94			call break_point_state  
b200				endm  
# End of macro CALLMONITOR
b200					endif 
b200				; next item on the stack is the limit. get it 
b200			 
b200			 
b200				FORTH_LOOP_POP 
b200 cd e0 9d			call macro_forth_loop_pop 
b203				endm 
# End of macro FORTH_LOOP_POP
b203			 
b203				FORTH_LOOP_TOS 
b203 cd d6 9d			call macro_forth_loop_tos 
b206				endm 
# End of macro FORTH_LOOP_TOS
b206			 
b206 d1				pop de		 ; de = i, hl = limit 
b207			 
b207					if DEBUG_FORTH_WORDS 
b207						DMARK "-L1" 
b207 f5				push af  
b208 3a 1c b2			ld a, (.dmark)  
b20b 32 71 ee			ld (debug_mark),a  
b20e 3a 1d b2			ld a, (.dmark+1)  
b211 32 72 ee			ld (debug_mark+1),a  
b214 3a 1e b2			ld a, (.dmark+2)  
b217 32 73 ee			ld (debug_mark+2),a  
b21a 18 03			jr .pastdmark  
b21c ..			.dmark: db "-L1"  
b21f f1			.pastdmark: pop af  
b220			endm  
# End of macro DMARK
b220						CALLMONITOR 
b220 cd dd 94			call break_point_state  
b223				endm  
# End of macro CALLMONITOR
b223					endif 
b223			 
b223				; go back to previous word 
b223			 
b223 d5				push de    ; save I for inc later 
b224			 
b224			 
b224				; get limit 
b224				;  is I at limit? 
b224			 
b224			 
b224					if DEBUG_FORTH_WORDS 
b224						DMARK "-L1" 
b224 f5				push af  
b225 3a 39 b2			ld a, (.dmark)  
b228 32 71 ee			ld (debug_mark),a  
b22b 3a 3a b2			ld a, (.dmark+1)  
b22e 32 72 ee			ld (debug_mark+1),a  
b231 3a 3b b2			ld a, (.dmark+2)  
b234 32 73 ee			ld (debug_mark+2),a  
b237 18 03			jr .pastdmark  
b239 ..			.dmark: db "-L1"  
b23c f1			.pastdmark: pop af  
b23d			endm  
# End of macro DMARK
b23d						CALLMONITOR 
b23d cd dd 94			call break_point_state  
b240				endm  
# End of macro CALLMONITOR
b240					endif 
b240			 
b240 ed 52			sbc hl, de 
b242			 
b242			 
b242				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b242			 
b242 20 26				jr nz, .mloopnotdone 
b244			 
b244 e1				pop hl   ; get rid of saved I 
b245				FORTH_LOOP_POP     ; get rid of limit 
b245 cd e0 9d			call macro_forth_loop_pop 
b248				endm 
# End of macro FORTH_LOOP_POP
b248			 
b248				FORTH_RSP_POP     ; get rid of DO ptr 
b248 cd 43 9b			call macro_forth_rsp_pop 
b24b				endm 
# End of macro FORTH_RSP_POP
b24b			 
b24b			if DEBUG_FORTH_WORDS 
b24b						DMARK "-L>" 
b24b f5				push af  
b24c 3a 60 b2			ld a, (.dmark)  
b24f 32 71 ee			ld (debug_mark),a  
b252 3a 61 b2			ld a, (.dmark+1)  
b255 32 72 ee			ld (debug_mark+1),a  
b258 3a 62 b2			ld a, (.dmark+2)  
b25b 32 73 ee			ld (debug_mark+2),a  
b25e 18 03			jr .pastdmark  
b260 ..			.dmark: db "-L>"  
b263 f1			.pastdmark: pop af  
b264			endm  
# End of macro DMARK
b264				CALLMONITOR 
b264 cd dd 94			call break_point_state  
b267				endm  
# End of macro CALLMONITOR
b267			endif 
b267			 
b267					NEXTW 
b267 c3 28 9f			jp macro_next 
b26a				endm 
# End of macro NEXTW
b26a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b26a			 
b26a			.mloopnotdone: 
b26a			 
b26a e1				pop hl    ; get I 
b26b 2b				dec hl 
b26c			 
b26c			   	; save new I 
b26c			 
b26c			 
b26c					; set I counter 
b26c			 
b26c 22 ec e5				ld (os_current_i), hl 
b26f			 
b26f					 
b26f				FORTH_LOOP_NEXT 
b26f cd a3 9d			call macro_forth_loop_next 
b272				endm 
# End of macro FORTH_LOOP_NEXT
b272			 
b272			 
b272					if DEBUG_FORTH_WORDS 
b272 eb						ex de,hl 
b273					endif 
b273			 
b273			;	; get DO ptr 
b273			; 
b273				FORTH_RSP_TOS 
b273 cd 39 9b			call macro_forth_rsp_tos 
b276				endm 
# End of macro FORTH_RSP_TOS
b276			 
b276				;push hl 
b276			 
b276				; not going to DO any more 
b276				; get rid of the RSP pointer as DO will add it back in 
b276				;FORTH_RSP_POP 
b276				;pop hl 
b276			 
b276			 
b276 22 c8 e5			ld (os_tok_ptr), hl 
b279					if DEBUG_FORTH_WORDS 
b279						DMARK "-L<" 
b279 f5				push af  
b27a 3a 8e b2			ld a, (.dmark)  
b27d 32 71 ee			ld (debug_mark),a  
b280 3a 8f b2			ld a, (.dmark+1)  
b283 32 72 ee			ld (debug_mark+1),a  
b286 3a 90 b2			ld a, (.dmark+2)  
b289 32 73 ee			ld (debug_mark+2),a  
b28c 18 03			jr .pastdmark  
b28e ..			.dmark: db "-L<"  
b291 f1			.pastdmark: pop af  
b292			endm  
# End of macro DMARK
b292					CALLMONITOR 
b292 cd dd 94			call break_point_state  
b295				endm  
# End of macro CALLMONITOR
b295				endif 
b295 c3 b9 9f			jp exec1 
b298			 
b298					 
b298			 
b298			 
b298			 
b298				NEXTW 
b298 c3 28 9f			jp macro_next 
b29b				endm 
# End of macro NEXTW
b29b			 
b29b			 
b29b			 
b29b			 
b29b			.REPEAT: 
b29b				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b29b 71				db WORD_SYS_CORE+93             
b29c ee b2			dw .UNTIL            
b29e 06				db 5 + 1 
b29f .. 00			db "REPEAT",0              
b2a6				endm 
# End of macro CWHEAD
b2a6			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b2a6			;  push pc to rsp stack past the REPEAT 
b2a6					if DEBUG_FORTH_WORDS_KEY 
b2a6						DMARK "REP" 
b2a6 f5				push af  
b2a7 3a bb b2			ld a, (.dmark)  
b2aa 32 71 ee			ld (debug_mark),a  
b2ad 3a bc b2			ld a, (.dmark+1)  
b2b0 32 72 ee			ld (debug_mark+1),a  
b2b3 3a bd b2			ld a, (.dmark+2)  
b2b6 32 73 ee			ld (debug_mark+2),a  
b2b9 18 03			jr .pastdmark  
b2bb ..			.dmark: db "REP"  
b2be f1			.pastdmark: pop af  
b2bf			endm  
# End of macro DMARK
b2bf						CALLMONITOR 
b2bf cd dd 94			call break_point_state  
b2c2				endm  
# End of macro CALLMONITOR
b2c2					endif 
b2c2			 
b2c2 2a c8 e5				ld hl, (os_tok_ptr) 
b2c5 23					inc hl   ; R 
b2c6 23					inc hl  ; E 
b2c7 23					inc hl   ; P 
b2c8 23					inc hl   ; E 
b2c9 23					inc hl   ; A 
b2ca 23					inc hl   ; T 
b2cb 23					inc hl   ; zero 
b2cc					FORTH_RSP_NEXT 
b2cc cd 22 9b			call macro_forth_rsp_next 
b2cf				endm 
# End of macro FORTH_RSP_NEXT
b2cf			 
b2cf			 
b2cf					if DEBUG_FORTH_WORDS 
b2cf						DMARK "REP" 
b2cf f5				push af  
b2d0 3a e4 b2			ld a, (.dmark)  
b2d3 32 71 ee			ld (debug_mark),a  
b2d6 3a e5 b2			ld a, (.dmark+1)  
b2d9 32 72 ee			ld (debug_mark+1),a  
b2dc 3a e6 b2			ld a, (.dmark+2)  
b2df 32 73 ee			ld (debug_mark+2),a  
b2e2 18 03			jr .pastdmark  
b2e4 ..			.dmark: db "REP"  
b2e7 f1			.pastdmark: pop af  
b2e8			endm  
# End of macro DMARK
b2e8						;pop bc    ; TODO BUG ?????? what is this for???? 
b2e8						CALLMONITOR 
b2e8 cd dd 94			call break_point_state  
b2eb				endm  
# End of macro CALLMONITOR
b2eb					endif 
b2eb			 
b2eb					NEXTW 
b2eb c3 28 9f			jp macro_next 
b2ee				endm 
# End of macro NEXTW
b2ee			;	       NEXTW 
b2ee			 
b2ee			.UNTIL: 
b2ee				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b2ee 72				db WORD_SYS_CORE+94             
b2ef 85 b3			dw .ENDFLOW            
b2f1 06				db 5 + 1 
b2f2 .. 00			db "UNTIL",0              
b2f8				endm 
# End of macro CWHEAD
b2f8			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b2f8			 
b2f8				; pop tos as check 
b2f8			 
b2f8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b2f8			 
b2f8				FORTH_DSP_VALUEHL 
b2f8 cd 72 9d			call macro_dsp_valuehl 
b2fb				endm 
# End of macro FORTH_DSP_VALUEHL
b2fb			 
b2fb					if DEBUG_FORTH_WORDS_KEY 
b2fb						DMARK "UNT" 
b2fb f5				push af  
b2fc 3a 10 b3			ld a, (.dmark)  
b2ff 32 71 ee			ld (debug_mark),a  
b302 3a 11 b3			ld a, (.dmark+1)  
b305 32 72 ee			ld (debug_mark+1),a  
b308 3a 12 b3			ld a, (.dmark+2)  
b30b 32 73 ee			ld (debug_mark+2),a  
b30e 18 03			jr .pastdmark  
b310 ..			.dmark: db "UNT"  
b313 f1			.pastdmark: pop af  
b314			endm  
# End of macro DMARK
b314						CALLMONITOR 
b314 cd dd 94			call break_point_state  
b317				endm  
# End of macro CALLMONITOR
b317					endif 
b317			 
b317			;	push hl 
b317				FORTH_DSP_POP 
b317 cd 2a 9e			call macro_forth_dsp_pop 
b31a				endm 
# End of macro FORTH_DSP_POP
b31a			 
b31a			;	pop hl 
b31a			 
b31a				; test if true 
b31a			 
b31a cd 05 8d			call ishlzero 
b31d			;	ld a,l 
b31d			;	add h 
b31d			; 
b31d			;	cp 0 
b31d			 
b31d 20 3e			jr nz, .untilnotdone 
b31f			 
b31f					if DEBUG_FORTH_WORDS 
b31f						DMARK "UNf" 
b31f f5				push af  
b320 3a 34 b3			ld a, (.dmark)  
b323 32 71 ee			ld (debug_mark),a  
b326 3a 35 b3			ld a, (.dmark+1)  
b329 32 72 ee			ld (debug_mark+1),a  
b32c 3a 36 b3			ld a, (.dmark+2)  
b32f 32 73 ee			ld (debug_mark+2),a  
b332 18 03			jr .pastdmark  
b334 ..			.dmark: db "UNf"  
b337 f1			.pastdmark: pop af  
b338			endm  
# End of macro DMARK
b338						CALLMONITOR 
b338 cd dd 94			call break_point_state  
b33b				endm  
# End of macro CALLMONITOR
b33b					endif 
b33b			 
b33b			 
b33b			 
b33b				FORTH_RSP_POP     ; get rid of DO ptr 
b33b cd 43 9b			call macro_forth_rsp_pop 
b33e				endm 
# End of macro FORTH_RSP_POP
b33e			 
b33e			if DEBUG_FORTH_WORDS 
b33e						DMARK "UN>" 
b33e f5				push af  
b33f 3a 53 b3			ld a, (.dmark)  
b342 32 71 ee			ld (debug_mark),a  
b345 3a 54 b3			ld a, (.dmark+1)  
b348 32 72 ee			ld (debug_mark+1),a  
b34b 3a 55 b3			ld a, (.dmark+2)  
b34e 32 73 ee			ld (debug_mark+2),a  
b351 18 03			jr .pastdmark  
b353 ..			.dmark: db "UN>"  
b356 f1			.pastdmark: pop af  
b357			endm  
# End of macro DMARK
b357				CALLMONITOR 
b357 cd dd 94			call break_point_state  
b35a				endm  
# End of macro CALLMONITOR
b35a			endif 
b35a			 
b35a					NEXTW 
b35a c3 28 9f			jp macro_next 
b35d				endm 
# End of macro NEXTW
b35d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b35d			 
b35d			.untilnotdone: 
b35d			 
b35d			 
b35d			;	; get DO ptr 
b35d			; 
b35d				FORTH_RSP_TOS 
b35d cd 39 9b			call macro_forth_rsp_tos 
b360				endm 
# End of macro FORTH_RSP_TOS
b360			 
b360				;push hl 
b360			 
b360				; not going to DO any more 
b360				; get rid of the RSP pointer as DO will add it back in 
b360				;FORTH_RSP_POP 
b360				;pop hl 
b360			 
b360			 
b360 22 c8 e5			ld (os_tok_ptr), hl 
b363					if DEBUG_FORTH_WORDS 
b363						DMARK "UN<" 
b363 f5				push af  
b364 3a 78 b3			ld a, (.dmark)  
b367 32 71 ee			ld (debug_mark),a  
b36a 3a 79 b3			ld a, (.dmark+1)  
b36d 32 72 ee			ld (debug_mark+1),a  
b370 3a 7a b3			ld a, (.dmark+2)  
b373 32 73 ee			ld (debug_mark+2),a  
b376 18 03			jr .pastdmark  
b378 ..			.dmark: db "UN<"  
b37b f1			.pastdmark: pop af  
b37c			endm  
# End of macro DMARK
b37c					CALLMONITOR 
b37c cd dd 94			call break_point_state  
b37f				endm  
# End of macro CALLMONITOR
b37f				endif 
b37f c3 b9 9f			jp exec1 
b382			 
b382					 
b382			 
b382			 
b382					NEXTW 
b382 c3 28 9f			jp macro_next 
b385				endm 
# End of macro NEXTW
b385			 
b385			 
b385			.ENDFLOW: 
b385			 
b385			; eof 
b385			 
# End of file forth_words_flow.asm
b385			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b385			include "forth_words_logic.asm" 
b385			 
b385			; | ## Logic Words 
b385			 
b385			.NOT: 
b385				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b385 2d				db WORD_SYS_CORE+25             
b386 cd b3			dw .IS            
b388 04				db 3 + 1 
b389 .. 00			db "NOT",0              
b38d				endm 
# End of macro CWHEAD
b38d			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b38d					if DEBUG_FORTH_WORDS_KEY 
b38d						DMARK "NOT" 
b38d f5				push af  
b38e 3a a2 b3			ld a, (.dmark)  
b391 32 71 ee			ld (debug_mark),a  
b394 3a a3 b3			ld a, (.dmark+1)  
b397 32 72 ee			ld (debug_mark+1),a  
b39a 3a a4 b3			ld a, (.dmark+2)  
b39d 32 73 ee			ld (debug_mark+2),a  
b3a0 18 03			jr .pastdmark  
b3a2 ..			.dmark: db "NOT"  
b3a5 f1			.pastdmark: pop af  
b3a6			endm  
# End of macro DMARK
b3a6						CALLMONITOR 
b3a6 cd dd 94			call break_point_state  
b3a9				endm  
# End of macro CALLMONITOR
b3a9					endif 
b3a9					FORTH_DSP 
b3a9 cd 38 9d			call macro_forth_dsp 
b3ac				endm 
# End of macro FORTH_DSP
b3ac 7e					ld a,(hl)	; get type of value on TOS 
b3ad fe 02				cp DS_TYPE_INUM  
b3af 28 03				jr z, .noti 
b3b1					NEXTW 
b3b1 c3 28 9f			jp macro_next 
b3b4				endm 
# End of macro NEXTW
b3b4			.noti:          FORTH_DSP_VALUEHL 
b3b4 cd 72 9d			call macro_dsp_valuehl 
b3b7				endm 
# End of macro FORTH_DSP_VALUEHL
b3b7			;		push hl 
b3b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3b7 cd 2a 9e			call macro_forth_dsp_pop 
b3ba				endm 
# End of macro FORTH_DSP_POP
b3ba			;		pop hl 
b3ba 3e 00				ld a,0 
b3bc bd					cp l 
b3bd 28 04				jr z, .not2t 
b3bf 2e 00				ld l, 0 
b3c1 18 02				jr .notip 
b3c3			 
b3c3 2e ff		.not2t:		ld l, 255 
b3c5			 
b3c5 26 00		.notip:		ld h, 0	 
b3c7			 
b3c7 cd 7b 9b				call forth_push_numhl 
b3ca					NEXTW 
b3ca c3 28 9f			jp macro_next 
b3cd				endm 
# End of macro NEXTW
b3cd			 
b3cd			.IS: 
b3cd				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b3cd 2d				db WORD_SYS_CORE+25             
b3ce f3 b3			dw .LZERO            
b3d0 03				db 2 + 1 
b3d1 .. 00			db "IS",0              
b3d4				endm 
# End of macro CWHEAD
b3d4			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b3d4					if DEBUG_FORTH_WORDS_KEY 
b3d4						DMARK "IS." 
b3d4 f5				push af  
b3d5 3a e9 b3			ld a, (.dmark)  
b3d8 32 71 ee			ld (debug_mark),a  
b3db 3a ea b3			ld a, (.dmark+1)  
b3de 32 72 ee			ld (debug_mark+1),a  
b3e1 3a eb b3			ld a, (.dmark+2)  
b3e4 32 73 ee			ld (debug_mark+2),a  
b3e7 18 03			jr .pastdmark  
b3e9 ..			.dmark: db "IS."  
b3ec f1			.pastdmark: pop af  
b3ed			endm  
# End of macro DMARK
b3ed						CALLMONITOR 
b3ed cd dd 94			call break_point_state  
b3f0				endm  
# End of macro CALLMONITOR
b3f0					endif 
b3f0					NEXTW 
b3f0 c3 28 9f			jp macro_next 
b3f3				endm 
# End of macro NEXTW
b3f3			.LZERO: 
b3f3				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b3f3 2d				db WORD_SYS_CORE+25             
b3f4 fd b3			dw .TZERO            
b3f6 03				db 2 + 1 
b3f7 .. 00			db "0<",0              
b3fa				endm 
# End of macro CWHEAD
b3fa			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b3fa					NEXTW 
b3fa c3 28 9f			jp macro_next 
b3fd				endm 
# End of macro NEXTW
b3fd			.TZERO: 
b3fd				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b3fd 2e				db WORD_SYS_CORE+26             
b3fe 44 b4			dw .LESS            
b400 03				db 2 + 1 
b401 .. 00			db "0=",0              
b404				endm 
# End of macro CWHEAD
b404			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b404				; TODO add floating point number detection 
b404					;v5 FORTH_DSP_VALUE 
b404					if DEBUG_FORTH_WORDS_KEY 
b404						DMARK "0=." 
b404 f5				push af  
b405 3a 19 b4			ld a, (.dmark)  
b408 32 71 ee			ld (debug_mark),a  
b40b 3a 1a b4			ld a, (.dmark+1)  
b40e 32 72 ee			ld (debug_mark+1),a  
b411 3a 1b b4			ld a, (.dmark+2)  
b414 32 73 ee			ld (debug_mark+2),a  
b417 18 03			jr .pastdmark  
b419 ..			.dmark: db "0=."  
b41c f1			.pastdmark: pop af  
b41d			endm  
# End of macro DMARK
b41d						CALLMONITOR 
b41d cd dd 94			call break_point_state  
b420				endm  
# End of macro CALLMONITOR
b420					endif 
b420					FORTH_DSP 
b420 cd 38 9d			call macro_forth_dsp 
b423				endm 
# End of macro FORTH_DSP
b423 7e					ld a,(hl)	; get type of value on TOS 
b424 fe 02				cp DS_TYPE_INUM  
b426 28 00				jr z, .tz_inum 
b428			 
b428				if FORTH_ENABLE_FLOATMATH 
b428					jr .tz_done 
b428			 
b428				endif 
b428					 
b428			 
b428			.tz_inum: 
b428					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b428 cd 72 9d			call macro_dsp_valuehl 
b42b				endm 
# End of macro FORTH_DSP_VALUEHL
b42b			 
b42b			;		push hl 
b42b			 
b42b					; destroy value TOS 
b42b			 
b42b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b42b cd 2a 9e			call macro_forth_dsp_pop 
b42e				endm 
# End of macro FORTH_DSP_POP
b42e			 
b42e			;		pop hl 
b42e			 
b42e 3e 00				ld a,0 
b430			 
b430 bd					cp l 
b431 20 08				jr nz, .tz_notzero 
b433			 
b433 bc					cp h 
b434			 
b434 20 05				jr nz, .tz_notzero 
b436			 
b436			 
b436 21 01 00				ld hl, FORTH_TRUE 
b439 18 03				jr .tz_done 
b43b			 
b43b 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b43e			 
b43e					; push value back onto stack for another op etc 
b43e			 
b43e			.tz_done: 
b43e cd 7b 9b				call forth_push_numhl 
b441			 
b441					NEXTW 
b441 c3 28 9f			jp macro_next 
b444				endm 
# End of macro NEXTW
b444			.LESS: 
b444				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b444 2f				db WORD_SYS_CORE+27             
b445 ad b4			dw .GT            
b447 02				db 1 + 1 
b448 .. 00			db "<",0              
b44a				endm 
# End of macro CWHEAD
b44a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b44a				; TODO add floating point number detection 
b44a					if DEBUG_FORTH_WORDS_KEY 
b44a						DMARK "LES" 
b44a f5				push af  
b44b 3a 5f b4			ld a, (.dmark)  
b44e 32 71 ee			ld (debug_mark),a  
b451 3a 60 b4			ld a, (.dmark+1)  
b454 32 72 ee			ld (debug_mark+1),a  
b457 3a 61 b4			ld a, (.dmark+2)  
b45a 32 73 ee			ld (debug_mark+2),a  
b45d 18 03			jr .pastdmark  
b45f ..			.dmark: db "LES"  
b462 f1			.pastdmark: pop af  
b463			endm  
# End of macro DMARK
b463						CALLMONITOR 
b463 cd dd 94			call break_point_state  
b466				endm  
# End of macro CALLMONITOR
b466					endif 
b466					FORTH_DSP 
b466 cd 38 9d			call macro_forth_dsp 
b469				endm 
# End of macro FORTH_DSP
b469					;v5 FORTH_DSP_VALUE 
b469 7e					ld a,(hl)	; get type of value on TOS 
b46a fe 02				cp DS_TYPE_INUM  
b46c 28 00				jr z, .less_inum 
b46e			 
b46e				if FORTH_ENABLE_FLOATMATH 
b46e					jr .less_done 
b46e			 
b46e				endif 
b46e					 
b46e			 
b46e			.less_inum: 
b46e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b46e cd 72 9d			call macro_dsp_valuehl 
b471				endm 
# End of macro FORTH_DSP_VALUEHL
b471			 
b471 e5					push hl  ; u2 
b472			 
b472					; destroy value TOS 
b472			 
b472					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b472 cd 2a 9e			call macro_forth_dsp_pop 
b475				endm 
# End of macro FORTH_DSP_POP
b475			 
b475			 
b475					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b475 cd 72 9d			call macro_dsp_valuehl 
b478				endm 
# End of macro FORTH_DSP_VALUEHL
b478			 
b478 e5					push hl    ; u1 
b479			 
b479					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b479 cd 2a 9e			call macro_forth_dsp_pop 
b47c				endm 
# End of macro FORTH_DSP_POP
b47c			 
b47c			 
b47c b7			 or a      ;clear carry flag 
b47d 01 00 00		 ld bc, FORTH_FALSE 
b480 e1			  pop hl    ; u1 
b481 d1			  pop de    ; u2 
b482 ed 52		  sbc hl,de 
b484 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b486			 
b486 01 01 00		 ld bc, FORTH_TRUE 
b489			.lscont:  
b489 c5					push bc 
b48a e1					pop hl 
b48b			 
b48b					if DEBUG_FORTH_WORDS 
b48b						DMARK "LT1" 
b48b f5				push af  
b48c 3a a0 b4			ld a, (.dmark)  
b48f 32 71 ee			ld (debug_mark),a  
b492 3a a1 b4			ld a, (.dmark+1)  
b495 32 72 ee			ld (debug_mark+1),a  
b498 3a a2 b4			ld a, (.dmark+2)  
b49b 32 73 ee			ld (debug_mark+2),a  
b49e 18 03			jr .pastdmark  
b4a0 ..			.dmark: db "LT1"  
b4a3 f1			.pastdmark: pop af  
b4a4			endm  
# End of macro DMARK
b4a4						CALLMONITOR 
b4a4 cd dd 94			call break_point_state  
b4a7				endm  
# End of macro CALLMONITOR
b4a7					endif 
b4a7 cd 7b 9b				call forth_push_numhl 
b4aa			 
b4aa					NEXTW 
b4aa c3 28 9f			jp macro_next 
b4ad				endm 
# End of macro NEXTW
b4ad			.GT: 
b4ad				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b4ad 30				db WORD_SYS_CORE+28             
b4ae 16 b5			dw .EQUAL            
b4b0 02				db 1 + 1 
b4b1 .. 00			db ">",0              
b4b3				endm 
# End of macro CWHEAD
b4b3			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b4b3				; TODO add floating point number detection 
b4b3					if DEBUG_FORTH_WORDS_KEY 
b4b3						DMARK "GRT" 
b4b3 f5				push af  
b4b4 3a c8 b4			ld a, (.dmark)  
b4b7 32 71 ee			ld (debug_mark),a  
b4ba 3a c9 b4			ld a, (.dmark+1)  
b4bd 32 72 ee			ld (debug_mark+1),a  
b4c0 3a ca b4			ld a, (.dmark+2)  
b4c3 32 73 ee			ld (debug_mark+2),a  
b4c6 18 03			jr .pastdmark  
b4c8 ..			.dmark: db "GRT"  
b4cb f1			.pastdmark: pop af  
b4cc			endm  
# End of macro DMARK
b4cc						CALLMONITOR 
b4cc cd dd 94			call break_point_state  
b4cf				endm  
# End of macro CALLMONITOR
b4cf					endif 
b4cf					FORTH_DSP 
b4cf cd 38 9d			call macro_forth_dsp 
b4d2				endm 
# End of macro FORTH_DSP
b4d2					;FORTH_DSP_VALUE 
b4d2 7e					ld a,(hl)	; get type of value on TOS 
b4d3 fe 02				cp DS_TYPE_INUM  
b4d5 28 00				jr z, .gt_inum 
b4d7			 
b4d7				if FORTH_ENABLE_FLOATMATH 
b4d7					jr .gt_done 
b4d7			 
b4d7				endif 
b4d7					 
b4d7			 
b4d7			.gt_inum: 
b4d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4d7 cd 72 9d			call macro_dsp_valuehl 
b4da				endm 
# End of macro FORTH_DSP_VALUEHL
b4da			 
b4da e5					push hl  ; u2 
b4db			 
b4db					; destroy value TOS 
b4db			 
b4db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4db cd 2a 9e			call macro_forth_dsp_pop 
b4de				endm 
# End of macro FORTH_DSP_POP
b4de			 
b4de			 
b4de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4de cd 72 9d			call macro_dsp_valuehl 
b4e1				endm 
# End of macro FORTH_DSP_VALUEHL
b4e1			 
b4e1 e5					push hl    ; u1 
b4e2			 
b4e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4e2 cd 2a 9e			call macro_forth_dsp_pop 
b4e5				endm 
# End of macro FORTH_DSP_POP
b4e5			 
b4e5			 
b4e5 b7			 or a      ;clear carry flag 
b4e6 01 00 00		 ld bc, FORTH_FALSE 
b4e9 e1			  pop hl    ; u1 
b4ea d1			  pop de    ; u2 
b4eb ed 52		  sbc hl,de 
b4ed 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b4ef			 
b4ef 01 01 00		 ld bc, FORTH_TRUE 
b4f2			.gtcont:  
b4f2 c5					push bc 
b4f3 e1					pop hl 
b4f4			 
b4f4					if DEBUG_FORTH_WORDS 
b4f4						DMARK "GT1" 
b4f4 f5				push af  
b4f5 3a 09 b5			ld a, (.dmark)  
b4f8 32 71 ee			ld (debug_mark),a  
b4fb 3a 0a b5			ld a, (.dmark+1)  
b4fe 32 72 ee			ld (debug_mark+1),a  
b501 3a 0b b5			ld a, (.dmark+2)  
b504 32 73 ee			ld (debug_mark+2),a  
b507 18 03			jr .pastdmark  
b509 ..			.dmark: db "GT1"  
b50c f1			.pastdmark: pop af  
b50d			endm  
# End of macro DMARK
b50d						CALLMONITOR 
b50d cd dd 94			call break_point_state  
b510				endm  
# End of macro CALLMONITOR
b510					endif 
b510 cd 7b 9b				call forth_push_numhl 
b513			 
b513					NEXTW 
b513 c3 28 9f			jp macro_next 
b516				endm 
# End of macro NEXTW
b516			.EQUAL: 
b516				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b516 31				db WORD_SYS_CORE+29             
b517 81 b5			dw .ENDLOGIC            
b519 02				db 1 + 1 
b51a .. 00			db "=",0              
b51c				endm 
# End of macro CWHEAD
b51c			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b51c				; TODO add floating point number detection 
b51c					if DEBUG_FORTH_WORDS_KEY 
b51c						DMARK "EQ." 
b51c f5				push af  
b51d 3a 31 b5			ld a, (.dmark)  
b520 32 71 ee			ld (debug_mark),a  
b523 3a 32 b5			ld a, (.dmark+1)  
b526 32 72 ee			ld (debug_mark+1),a  
b529 3a 33 b5			ld a, (.dmark+2)  
b52c 32 73 ee			ld (debug_mark+2),a  
b52f 18 03			jr .pastdmark  
b531 ..			.dmark: db "EQ."  
b534 f1			.pastdmark: pop af  
b535			endm  
# End of macro DMARK
b535						CALLMONITOR 
b535 cd dd 94			call break_point_state  
b538				endm  
# End of macro CALLMONITOR
b538					endif 
b538					FORTH_DSP 
b538 cd 38 9d			call macro_forth_dsp 
b53b				endm 
# End of macro FORTH_DSP
b53b					;v5 FORTH_DSP_VALUE 
b53b 7e					ld a,(hl)	; get type of value on TOS 
b53c fe 02				cp DS_TYPE_INUM  
b53e 28 00				jr z, .eq_inum 
b540			 
b540				if FORTH_ENABLE_FLOATMATH 
b540					jr .eq_done 
b540			 
b540				endif 
b540					 
b540			 
b540			.eq_inum: 
b540					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b540 cd 72 9d			call macro_dsp_valuehl 
b543				endm 
# End of macro FORTH_DSP_VALUEHL
b543			 
b543 e5					push hl 
b544			 
b544					; destroy value TOS 
b544			 
b544					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b544 cd 2a 9e			call macro_forth_dsp_pop 
b547				endm 
# End of macro FORTH_DSP_POP
b547			 
b547			 
b547					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b547 cd 72 9d			call macro_dsp_valuehl 
b54a				endm 
# End of macro FORTH_DSP_VALUEHL
b54a			 
b54a					; one value on hl get other one back 
b54a			 
b54a e5					push hl 
b54b			 
b54b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b54b cd 2a 9e			call macro_forth_dsp_pop 
b54e				endm 
# End of macro FORTH_DSP_POP
b54e			 
b54e 0e 00				ld c, FORTH_FALSE 
b550			 
b550 e1					pop hl 
b551 d1					pop de 
b552			 
b552 7b					ld a, e 
b553 bd					cp l 
b554			 
b554 20 06				jr nz, .eq_done 
b556			 
b556 7a					ld a, d 
b557 bc					cp h 
b558			 
b558 20 02				jr nz, .eq_done 
b55a			 
b55a 0e 01				ld c, FORTH_TRUE 
b55c					 
b55c			 
b55c			 
b55c			.eq_done: 
b55c			 
b55c					; TODO push value back onto stack for another op etc 
b55c			 
b55c 26 00				ld h, 0 
b55e 69					ld l, c 
b55f					if DEBUG_FORTH_WORDS 
b55f						DMARK "EQ1" 
b55f f5				push af  
b560 3a 74 b5			ld a, (.dmark)  
b563 32 71 ee			ld (debug_mark),a  
b566 3a 75 b5			ld a, (.dmark+1)  
b569 32 72 ee			ld (debug_mark+1),a  
b56c 3a 76 b5			ld a, (.dmark+2)  
b56f 32 73 ee			ld (debug_mark+2),a  
b572 18 03			jr .pastdmark  
b574 ..			.dmark: db "EQ1"  
b577 f1			.pastdmark: pop af  
b578			endm  
# End of macro DMARK
b578						CALLMONITOR 
b578 cd dd 94			call break_point_state  
b57b				endm  
# End of macro CALLMONITOR
b57b					endif 
b57b cd 7b 9b				call forth_push_numhl 
b57e			 
b57e					NEXTW 
b57e c3 28 9f			jp macro_next 
b581				endm 
# End of macro NEXTW
b581			 
b581			 
b581			.ENDLOGIC: 
b581			; eof 
b581			 
b581			 
# End of file forth_words_logic.asm
b581			include "forth_words_maths.asm" 
b581			 
b581			; | ## Maths Words 
b581			 
b581			.PLUS:	 
b581				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b581 15				db WORD_SYS_CORE+1             
b582 df b5			dw .NEG            
b584 02				db 1 + 1 
b585 .. 00			db "+",0              
b587				endm 
# End of macro CWHEAD
b587			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b587					if DEBUG_FORTH_WORDS_KEY 
b587						DMARK "PLU" 
b587 f5				push af  
b588 3a 9c b5			ld a, (.dmark)  
b58b 32 71 ee			ld (debug_mark),a  
b58e 3a 9d b5			ld a, (.dmark+1)  
b591 32 72 ee			ld (debug_mark+1),a  
b594 3a 9e b5			ld a, (.dmark+2)  
b597 32 73 ee			ld (debug_mark+2),a  
b59a 18 03			jr .pastdmark  
b59c ..			.dmark: db "PLU"  
b59f f1			.pastdmark: pop af  
b5a0			endm  
# End of macro DMARK
b5a0						CALLMONITOR 
b5a0 cd dd 94			call break_point_state  
b5a3				endm  
# End of macro CALLMONITOR
b5a3					endif 
b5a3					; add top two values and push back result 
b5a3			 
b5a3					;for v5 FORTH_DSP_VALUE 
b5a3					FORTH_DSP 
b5a3 cd 38 9d			call macro_forth_dsp 
b5a6				endm 
# End of macro FORTH_DSP
b5a6 7e					ld a,(hl)	; get type of value on TOS 
b5a7 fe 02				cp DS_TYPE_INUM  
b5a9 28 03				jr z, .dot_inum 
b5ab			 
b5ab					NEXTW 
b5ab c3 28 9f			jp macro_next 
b5ae				endm 
# End of macro NEXTW
b5ae			 
b5ae			; float maths 
b5ae			 
b5ae				if FORTH_ENABLE_FLOATMATH 
b5ae						inc hl      ; now at start of numeric as string 
b5ae			 
b5ae					if DEBUG_FORTH_MATHS 
b5ae						DMARK "ADD" 
b5ae				CALLMONITOR 
b5ae					endif 
b5ae			 
b5ae					;ld ix, hl 
b5ae					call CON 
b5ae			 
b5ae			 
b5ae					push hl 
b5ae					 
b5ae					 
b5ae			 
b5ae						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b5ae			 
b5ae					; get next number 
b5ae			 
b5ae						FORTH_DSP_VALUE 
b5ae			 
b5ae						inc hl      ; now at start of numeric as string 
b5ae			 
b5ae					;ld ix, hl 
b5ae					call CON 
b5ae			 
b5ae					push hl 
b5ae			 
b5ae			 
b5ae						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5ae			 
b5ae						; TODO do add 
b5ae			 
b5ae						call IADD 
b5ae			 
b5ae						; TODO get result back as ascii 
b5ae			 
b5ae						; TODO push result  
b5ae			 
b5ae			 
b5ae			 
b5ae						jr .dot_done 
b5ae				endif 
b5ae			 
b5ae			.dot_inum: 
b5ae			 
b5ae			 
b5ae					if DEBUG_FORTH_DOT 
b5ae						DMARK "+IT" 
b5ae f5				push af  
b5af 3a c3 b5			ld a, (.dmark)  
b5b2 32 71 ee			ld (debug_mark),a  
b5b5 3a c4 b5			ld a, (.dmark+1)  
b5b8 32 72 ee			ld (debug_mark+1),a  
b5bb 3a c5 b5			ld a, (.dmark+2)  
b5be 32 73 ee			ld (debug_mark+2),a  
b5c1 18 03			jr .pastdmark  
b5c3 ..			.dmark: db "+IT"  
b5c6 f1			.pastdmark: pop af  
b5c7			endm  
# End of macro DMARK
b5c7				CALLMONITOR 
b5c7 cd dd 94			call break_point_state  
b5ca				endm  
# End of macro CALLMONITOR
b5ca					endif 
b5ca			 
b5ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5ca cd 72 9d			call macro_dsp_valuehl 
b5cd				endm 
# End of macro FORTH_DSP_VALUEHL
b5cd			 
b5cd				; TODO add floating point number detection 
b5cd			 
b5cd e5					push hl 
b5ce			 
b5ce					; destroy value TOS 
b5ce			 
b5ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5ce cd 2a 9e			call macro_forth_dsp_pop 
b5d1				endm 
# End of macro FORTH_DSP_POP
b5d1			 
b5d1			 
b5d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5d1 cd 72 9d			call macro_dsp_valuehl 
b5d4				endm 
# End of macro FORTH_DSP_VALUEHL
b5d4			 
b5d4					; one value on hl get other one back 
b5d4			 
b5d4 d1					pop de 
b5d5			 
b5d5					; do the add 
b5d5			 
b5d5 19					add hl,de 
b5d6			 
b5d6					; save it 
b5d6			 
b5d6			;		push hl	 
b5d6			 
b5d6					; 
b5d6			 
b5d6					; destroy value TOS 
b5d6			 
b5d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5d6 cd 2a 9e			call macro_forth_dsp_pop 
b5d9				endm 
# End of macro FORTH_DSP_POP
b5d9			 
b5d9					; TODO push value back onto stack for another op etc 
b5d9			 
b5d9			;		pop hl 
b5d9			 
b5d9			.dot_done: 
b5d9 cd 7b 9b				call forth_push_numhl 
b5dc			 
b5dc					NEXTW 
b5dc c3 28 9f			jp macro_next 
b5df				endm 
# End of macro NEXTW
b5df			.NEG: 
b5df			 
b5df				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b5df 17				db WORD_SYS_CORE+3             
b5e0 22 b6			dw .DIV            
b5e2 02				db 1 + 1 
b5e3 .. 00			db "-",0              
b5e5				endm 
# End of macro CWHEAD
b5e5			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b5e5					if DEBUG_FORTH_WORDS_KEY 
b5e5						DMARK "SUB" 
b5e5 f5				push af  
b5e6 3a fa b5			ld a, (.dmark)  
b5e9 32 71 ee			ld (debug_mark),a  
b5ec 3a fb b5			ld a, (.dmark+1)  
b5ef 32 72 ee			ld (debug_mark+1),a  
b5f2 3a fc b5			ld a, (.dmark+2)  
b5f5 32 73 ee			ld (debug_mark+2),a  
b5f8 18 03			jr .pastdmark  
b5fa ..			.dmark: db "SUB"  
b5fd f1			.pastdmark: pop af  
b5fe			endm  
# End of macro DMARK
b5fe						CALLMONITOR 
b5fe cd dd 94			call break_point_state  
b601				endm  
# End of macro CALLMONITOR
b601					endif 
b601			 
b601			 
b601				; TODO add floating point number detection 
b601					; v5 FORTH_DSP_VALUE 
b601					FORTH_DSP 
b601 cd 38 9d			call macro_forth_dsp 
b604				endm 
# End of macro FORTH_DSP
b604 7e					ld a,(hl)	; get type of value on TOS 
b605 fe 02				cp DS_TYPE_INUM  
b607 28 03				jr z, .neg_inum 
b609			 
b609					NEXTW 
b609 c3 28 9f			jp macro_next 
b60c				endm 
# End of macro NEXTW
b60c			 
b60c			; float maths 
b60c			 
b60c				if FORTH_ENABLE_FLOATMATH 
b60c					jr .neg_done 
b60c			 
b60c				endif 
b60c					 
b60c			 
b60c			.neg_inum: 
b60c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b60c cd 72 9d			call macro_dsp_valuehl 
b60f				endm 
# End of macro FORTH_DSP_VALUEHL
b60f			 
b60f e5					push hl 
b610			 
b610					; destroy value TOS 
b610			 
b610					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b610 cd 2a 9e			call macro_forth_dsp_pop 
b613				endm 
# End of macro FORTH_DSP_POP
b613			 
b613			 
b613					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b613 cd 72 9d			call macro_dsp_valuehl 
b616				endm 
# End of macro FORTH_DSP_VALUEHL
b616			 
b616					; one value on hl get other one back 
b616			 
b616 d1					pop de 
b617			 
b617					; do the sub 
b617			;		ex de, hl 
b617			 
b617 ed 52				sbc hl,de 
b619			 
b619					; save it 
b619			 
b619			;		push hl	 
b619			 
b619					; 
b619			 
b619					; destroy value TOS 
b619			 
b619					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b619 cd 2a 9e			call macro_forth_dsp_pop 
b61c				endm 
# End of macro FORTH_DSP_POP
b61c			 
b61c					; TODO push value back onto stack for another op etc 
b61c			 
b61c			;		pop hl 
b61c			 
b61c cd 7b 9b				call forth_push_numhl 
b61f			.neg_done: 
b61f			 
b61f					NEXTW 
b61f c3 28 9f			jp macro_next 
b622				endm 
# End of macro NEXTW
b622			.DIV: 
b622				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b622 18				db WORD_SYS_CORE+4             
b623 6f b6			dw .MUL            
b625 02				db 1 + 1 
b626 .. 00			db "/",0              
b628				endm 
# End of macro CWHEAD
b628			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b628					if DEBUG_FORTH_WORDS_KEY 
b628						DMARK "DIV" 
b628 f5				push af  
b629 3a 3d b6			ld a, (.dmark)  
b62c 32 71 ee			ld (debug_mark),a  
b62f 3a 3e b6			ld a, (.dmark+1)  
b632 32 72 ee			ld (debug_mark+1),a  
b635 3a 3f b6			ld a, (.dmark+2)  
b638 32 73 ee			ld (debug_mark+2),a  
b63b 18 03			jr .pastdmark  
b63d ..			.dmark: db "DIV"  
b640 f1			.pastdmark: pop af  
b641			endm  
# End of macro DMARK
b641						CALLMONITOR 
b641 cd dd 94			call break_point_state  
b644				endm  
# End of macro CALLMONITOR
b644					endif 
b644				; TODO add floating point number detection 
b644					; v5 FORTH_DSP_VALUE 
b644					FORTH_DSP 
b644 cd 38 9d			call macro_forth_dsp 
b647				endm 
# End of macro FORTH_DSP
b647 7e					ld a,(hl)	; get type of value on TOS 
b648 fe 02				cp DS_TYPE_INUM  
b64a 28 03				jr z, .div_inum 
b64c			 
b64c				if FORTH_ENABLE_FLOATMATH 
b64c					jr .div_done 
b64c			 
b64c				endif 
b64c					NEXTW 
b64c c3 28 9f			jp macro_next 
b64f				endm 
# End of macro NEXTW
b64f			.div_inum: 
b64f			 
b64f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b64f cd 72 9d			call macro_dsp_valuehl 
b652				endm 
# End of macro FORTH_DSP_VALUEHL
b652			 
b652 e5					push hl    ; to go to bc 
b653			 
b653					; destroy value TOS 
b653			 
b653					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b653 cd 2a 9e			call macro_forth_dsp_pop 
b656				endm 
# End of macro FORTH_DSP_POP
b656			 
b656			 
b656					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b656 cd 72 9d			call macro_dsp_valuehl 
b659				endm 
# End of macro FORTH_DSP_VALUEHL
b659			 
b659					; hl to go to de 
b659			 
b659 e5					push hl 
b65a			 
b65a c1					pop bc 
b65b d1					pop de		 
b65c			 
b65c			 
b65c					if DEBUG_FORTH_MATHS 
b65c						DMARK "DIV" 
b65c				CALLMONITOR 
b65c					endif 
b65c					; one value on hl but move to a get other one back 
b65c			 
b65c			        
b65c cd 39 8c			call Div16 
b65f			 
b65f			;	push af	 
b65f e5				push hl 
b660 c5				push bc 
b661			 
b661					if DEBUG_FORTH_MATHS 
b661						DMARK "DI1" 
b661				CALLMONITOR 
b661					endif 
b661			 
b661					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b661 cd 2a 9e			call macro_forth_dsp_pop 
b664				endm 
# End of macro FORTH_DSP_POP
b664			 
b664			 
b664			 
b664 e1					pop hl    ; result 
b665			 
b665 cd 7b 9b				call forth_push_numhl 
b668			 
b668 e1					pop hl    ; reminder 
b669			;		ld h,0 
b669			;		ld l,d 
b669			 
b669 cd 7b 9b				call forth_push_numhl 
b66c			.div_done: 
b66c					NEXTW 
b66c c3 28 9f			jp macro_next 
b66f				endm 
# End of macro NEXTW
b66f			.MUL: 
b66f				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b66f 19				db WORD_SYS_CORE+5             
b670 b4 b6			dw .MIN            
b672 02				db 1 + 1 
b673 .. 00			db "*",0              
b675				endm 
# End of macro CWHEAD
b675			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b675				; TODO add floating point number detection 
b675					if DEBUG_FORTH_WORDS_KEY 
b675						DMARK "MUL" 
b675 f5				push af  
b676 3a 8a b6			ld a, (.dmark)  
b679 32 71 ee			ld (debug_mark),a  
b67c 3a 8b b6			ld a, (.dmark+1)  
b67f 32 72 ee			ld (debug_mark+1),a  
b682 3a 8c b6			ld a, (.dmark+2)  
b685 32 73 ee			ld (debug_mark+2),a  
b688 18 03			jr .pastdmark  
b68a ..			.dmark: db "MUL"  
b68d f1			.pastdmark: pop af  
b68e			endm  
# End of macro DMARK
b68e						CALLMONITOR 
b68e cd dd 94			call break_point_state  
b691				endm  
# End of macro CALLMONITOR
b691					endif 
b691					FORTH_DSP 
b691 cd 38 9d			call macro_forth_dsp 
b694				endm 
# End of macro FORTH_DSP
b694					; v5 FORTH_DSP_VALUE 
b694 7e					ld a,(hl)	; get type of value on TOS 
b695 fe 02				cp DS_TYPE_INUM  
b697 28 03				jr z, .mul_inum 
b699			 
b699				if FORTH_ENABLE_FLOATMATH 
b699					jr .mul_done 
b699			 
b699				endif 
b699			 
b699					NEXTW 
b699 c3 28 9f			jp macro_next 
b69c				endm 
# End of macro NEXTW
b69c			.mul_inum:	 
b69c			 
b69c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b69c cd 72 9d			call macro_dsp_valuehl 
b69f				endm 
# End of macro FORTH_DSP_VALUEHL
b69f			 
b69f e5					push hl 
b6a0			 
b6a0					; destroy value TOS 
b6a0			 
b6a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6a0 cd 2a 9e			call macro_forth_dsp_pop 
b6a3				endm 
# End of macro FORTH_DSP_POP
b6a3			 
b6a3			 
b6a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6a3 cd 72 9d			call macro_dsp_valuehl 
b6a6				endm 
# End of macro FORTH_DSP_VALUEHL
b6a6			 
b6a6					; one value on hl but move to a get other one back 
b6a6			 
b6a6 7d					ld a, l 
b6a7			 
b6a7 d1					pop de 
b6a8			 
b6a8					; do the mull 
b6a8			;		ex de, hl 
b6a8			 
b6a8 cd 5f 8c				call Mult16 
b6ab					; save it 
b6ab			 
b6ab			;		push hl	 
b6ab			 
b6ab					; 
b6ab			 
b6ab					; destroy value TOS 
b6ab			 
b6ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6ab cd 2a 9e			call macro_forth_dsp_pop 
b6ae				endm 
# End of macro FORTH_DSP_POP
b6ae			 
b6ae					; TODO push value back onto stack for another op etc 
b6ae			 
b6ae			;		pop hl 
b6ae			 
b6ae cd 7b 9b				call forth_push_numhl 
b6b1			 
b6b1			.mul_done: 
b6b1					NEXTW 
b6b1 c3 28 9f			jp macro_next 
b6b4				endm 
# End of macro NEXTW
b6b4			 
b6b4			 
b6b4			 
b6b4			 
b6b4			.MIN: 
b6b4				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b6b4 49				db WORD_SYS_CORE+53             
b6b5 35 b7			dw .MAX            
b6b7 04				db 3 + 1 
b6b8 .. 00			db "MIN",0              
b6bc				endm 
# End of macro CWHEAD
b6bc			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b6bc					if DEBUG_FORTH_WORDS_KEY 
b6bc						DMARK "MIN" 
b6bc f5				push af  
b6bd 3a d1 b6			ld a, (.dmark)  
b6c0 32 71 ee			ld (debug_mark),a  
b6c3 3a d2 b6			ld a, (.dmark+1)  
b6c6 32 72 ee			ld (debug_mark+1),a  
b6c9 3a d3 b6			ld a, (.dmark+2)  
b6cc 32 73 ee			ld (debug_mark+2),a  
b6cf 18 03			jr .pastdmark  
b6d1 ..			.dmark: db "MIN"  
b6d4 f1			.pastdmark: pop af  
b6d5			endm  
# End of macro DMARK
b6d5						CALLMONITOR 
b6d5 cd dd 94			call break_point_state  
b6d8				endm  
# End of macro CALLMONITOR
b6d8					endif 
b6d8					; get u2 
b6d8			 
b6d8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6d8 cd 72 9d			call macro_dsp_valuehl 
b6db				endm 
# End of macro FORTH_DSP_VALUEHL
b6db			 
b6db e5					push hl   ; u2 
b6dc			 
b6dc					; destroy value TOS 
b6dc			 
b6dc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6dc cd 2a 9e			call macro_forth_dsp_pop 
b6df				endm 
# End of macro FORTH_DSP_POP
b6df			 
b6df					; get u1 
b6df			 
b6df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6df cd 72 9d			call macro_dsp_valuehl 
b6e2				endm 
# End of macro FORTH_DSP_VALUEHL
b6e2			 
b6e2 e5					push hl  ; u1 
b6e3			 
b6e3					; destroy value TOS 
b6e3			 
b6e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6e3 cd 2a 9e			call macro_forth_dsp_pop 
b6e6				endm 
# End of macro FORTH_DSP_POP
b6e6			 
b6e6 b7			 or a      ;clear carry flag 
b6e7 e1			  pop hl    ; u1 
b6e8 d1			  pop de    ; u2 
b6e9 e5				push hl   ; saved in case hl is lowest 
b6ea ed 52		  sbc hl,de 
b6ec 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b6ee			 
b6ee e1				pop hl 
b6ef					if DEBUG_FORTH_WORDS 
b6ef						DMARK "MIN" 
b6ef f5				push af  
b6f0 3a 04 b7			ld a, (.dmark)  
b6f3 32 71 ee			ld (debug_mark),a  
b6f6 3a 05 b7			ld a, (.dmark+1)  
b6f9 32 72 ee			ld (debug_mark+1),a  
b6fc 3a 06 b7			ld a, (.dmark+2)  
b6ff 32 73 ee			ld (debug_mark+2),a  
b702 18 03			jr .pastdmark  
b704 ..			.dmark: db "MIN"  
b707 f1			.pastdmark: pop af  
b708			endm  
# End of macro DMARK
b708						CALLMONITOR 
b708 cd dd 94			call break_point_state  
b70b				endm  
# End of macro CALLMONITOR
b70b					endif 
b70b cd 7b 9b				call forth_push_numhl 
b70e			 
b70e				       NEXTW 
b70e c3 28 9f			jp macro_next 
b711				endm 
# End of macro NEXTW
b711			 
b711			.mincont:  
b711 c1				pop bc   ; tidy up 
b712 eb				ex de , hl  
b713					if DEBUG_FORTH_WORDS 
b713						DMARK "MI1" 
b713 f5				push af  
b714 3a 28 b7			ld a, (.dmark)  
b717 32 71 ee			ld (debug_mark),a  
b71a 3a 29 b7			ld a, (.dmark+1)  
b71d 32 72 ee			ld (debug_mark+1),a  
b720 3a 2a b7			ld a, (.dmark+2)  
b723 32 73 ee			ld (debug_mark+2),a  
b726 18 03			jr .pastdmark  
b728 ..			.dmark: db "MI1"  
b72b f1			.pastdmark: pop af  
b72c			endm  
# End of macro DMARK
b72c						CALLMONITOR 
b72c cd dd 94			call break_point_state  
b72f				endm  
# End of macro CALLMONITOR
b72f					endif 
b72f cd 7b 9b				call forth_push_numhl 
b732			 
b732				       NEXTW 
b732 c3 28 9f			jp macro_next 
b735				endm 
# End of macro NEXTW
b735			.MAX: 
b735				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b735 4a				db WORD_SYS_CORE+54             
b736 b6 b7			dw .RND16            
b738 04				db 3 + 1 
b739 .. 00			db "MAX",0              
b73d				endm 
# End of macro CWHEAD
b73d			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b73d					if DEBUG_FORTH_WORDS_KEY 
b73d						DMARK "MAX" 
b73d f5				push af  
b73e 3a 52 b7			ld a, (.dmark)  
b741 32 71 ee			ld (debug_mark),a  
b744 3a 53 b7			ld a, (.dmark+1)  
b747 32 72 ee			ld (debug_mark+1),a  
b74a 3a 54 b7			ld a, (.dmark+2)  
b74d 32 73 ee			ld (debug_mark+2),a  
b750 18 03			jr .pastdmark  
b752 ..			.dmark: db "MAX"  
b755 f1			.pastdmark: pop af  
b756			endm  
# End of macro DMARK
b756						CALLMONITOR 
b756 cd dd 94			call break_point_state  
b759				endm  
# End of macro CALLMONITOR
b759					endif 
b759					; get u2 
b759			 
b759					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b759 cd 72 9d			call macro_dsp_valuehl 
b75c				endm 
# End of macro FORTH_DSP_VALUEHL
b75c			 
b75c e5					push hl   ; u2 
b75d			 
b75d					; destroy value TOS 
b75d			 
b75d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b75d cd 2a 9e			call macro_forth_dsp_pop 
b760				endm 
# End of macro FORTH_DSP_POP
b760			 
b760					; get u1 
b760			 
b760					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b760 cd 72 9d			call macro_dsp_valuehl 
b763				endm 
# End of macro FORTH_DSP_VALUEHL
b763			 
b763 e5					push hl  ; u1 
b764			 
b764					; destroy value TOS 
b764			 
b764					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b764 cd 2a 9e			call macro_forth_dsp_pop 
b767				endm 
# End of macro FORTH_DSP_POP
b767			 
b767 b7			 or a      ;clear carry flag 
b768 e1			  pop hl    ; u1 
b769 d1			  pop de    ; u2 
b76a e5				push hl   ; saved in case hl is lowest 
b76b ed 52		  sbc hl,de 
b76d 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b76f			 
b76f e1				pop hl 
b770					if DEBUG_FORTH_WORDS 
b770						DMARK "MAX" 
b770 f5				push af  
b771 3a 85 b7			ld a, (.dmark)  
b774 32 71 ee			ld (debug_mark),a  
b777 3a 86 b7			ld a, (.dmark+1)  
b77a 32 72 ee			ld (debug_mark+1),a  
b77d 3a 87 b7			ld a, (.dmark+2)  
b780 32 73 ee			ld (debug_mark+2),a  
b783 18 03			jr .pastdmark  
b785 ..			.dmark: db "MAX"  
b788 f1			.pastdmark: pop af  
b789			endm  
# End of macro DMARK
b789						CALLMONITOR 
b789 cd dd 94			call break_point_state  
b78c				endm  
# End of macro CALLMONITOR
b78c					endif 
b78c cd 7b 9b				call forth_push_numhl 
b78f			 
b78f				       NEXTW 
b78f c3 28 9f			jp macro_next 
b792				endm 
# End of macro NEXTW
b792			 
b792			.maxcont:  
b792 c1				pop bc   ; tidy up 
b793 eb				ex de , hl  
b794					if DEBUG_FORTH_WORDS 
b794						DMARK "MA1" 
b794 f5				push af  
b795 3a a9 b7			ld a, (.dmark)  
b798 32 71 ee			ld (debug_mark),a  
b79b 3a aa b7			ld a, (.dmark+1)  
b79e 32 72 ee			ld (debug_mark+1),a  
b7a1 3a ab b7			ld a, (.dmark+2)  
b7a4 32 73 ee			ld (debug_mark+2),a  
b7a7 18 03			jr .pastdmark  
b7a9 ..			.dmark: db "MA1"  
b7ac f1			.pastdmark: pop af  
b7ad			endm  
# End of macro DMARK
b7ad						CALLMONITOR 
b7ad cd dd 94			call break_point_state  
b7b0				endm  
# End of macro CALLMONITOR
b7b0					endif 
b7b0 cd 7b 9b				call forth_push_numhl 
b7b3				       NEXTW 
b7b3 c3 28 9f			jp macro_next 
b7b6				endm 
# End of macro NEXTW
b7b6			 
b7b6			.RND16: 
b7b6				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b7b6 4e				db WORD_SYS_CORE+58             
b7b7 e5 b7			dw .RND8            
b7b9 06				db 5 + 1 
b7ba .. 00			db "RND16",0              
b7c0				endm 
# End of macro CWHEAD
b7c0			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b7c0					if DEBUG_FORTH_WORDS_KEY 
b7c0						DMARK "R16" 
b7c0 f5				push af  
b7c1 3a d5 b7			ld a, (.dmark)  
b7c4 32 71 ee			ld (debug_mark),a  
b7c7 3a d6 b7			ld a, (.dmark+1)  
b7ca 32 72 ee			ld (debug_mark+1),a  
b7cd 3a d7 b7			ld a, (.dmark+2)  
b7d0 32 73 ee			ld (debug_mark+2),a  
b7d3 18 03			jr .pastdmark  
b7d5 ..			.dmark: db "R16"  
b7d8 f1			.pastdmark: pop af  
b7d9			endm  
# End of macro DMARK
b7d9						CALLMONITOR 
b7d9 cd dd 94			call break_point_state  
b7dc				endm  
# End of macro CALLMONITOR
b7dc					endif 
b7dc cd 03 8c				call prng16  
b7df cd 7b 9b				call forth_push_numhl 
b7e2				       NEXTW 
b7e2 c3 28 9f			jp macro_next 
b7e5				endm 
# End of macro NEXTW
b7e5			.RND8: 
b7e5				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b7e5 60				db WORD_SYS_CORE+76             
b7e6 1a b8			dw .RND            
b7e8 05				db 4 + 1 
b7e9 .. 00			db "RND8",0              
b7ee				endm 
# End of macro CWHEAD
b7ee			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b7ee					if DEBUG_FORTH_WORDS_KEY 
b7ee						DMARK "RN8" 
b7ee f5				push af  
b7ef 3a 03 b8			ld a, (.dmark)  
b7f2 32 71 ee			ld (debug_mark),a  
b7f5 3a 04 b8			ld a, (.dmark+1)  
b7f8 32 72 ee			ld (debug_mark+1),a  
b7fb 3a 05 b8			ld a, (.dmark+2)  
b7fe 32 73 ee			ld (debug_mark+2),a  
b801 18 03			jr .pastdmark  
b803 ..			.dmark: db "RN8"  
b806 f1			.pastdmark: pop af  
b807			endm  
# End of macro DMARK
b807						CALLMONITOR 
b807 cd dd 94			call break_point_state  
b80a				endm  
# End of macro CALLMONITOR
b80a					endif 
b80a 2a af eb				ld hl,(xrandc) 
b80d 23					inc hl 
b80e cd 1d 8c				call xrnd 
b811 6f					ld l,a	 
b812 26 00				ld h,0 
b814 cd 7b 9b				call forth_push_numhl 
b817				       NEXTW 
b817 c3 28 9f			jp macro_next 
b81a				endm 
# End of macro NEXTW
b81a			.RND: 
b81a				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b81a 60				db WORD_SYS_CORE+76             
b81b 20 b9			dw .ENDMATHS            
b81d 04				db 3 + 1 
b81e .. 00			db "RND",0              
b822				endm 
# End of macro CWHEAD
b822			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b822			 
b822					if DEBUG_FORTH_WORDS_KEY 
b822						DMARK "RND" 
b822 f5				push af  
b823 3a 37 b8			ld a, (.dmark)  
b826 32 71 ee			ld (debug_mark),a  
b829 3a 38 b8			ld a, (.dmark+1)  
b82c 32 72 ee			ld (debug_mark+1),a  
b82f 3a 39 b8			ld a, (.dmark+2)  
b832 32 73 ee			ld (debug_mark+2),a  
b835 18 03			jr .pastdmark  
b837 ..			.dmark: db "RND"  
b83a f1			.pastdmark: pop af  
b83b			endm  
# End of macro DMARK
b83b						CALLMONITOR 
b83b cd dd 94			call break_point_state  
b83e				endm  
# End of macro CALLMONITOR
b83e					endif 
b83e					 
b83e					FORTH_DSP_VALUEHL    ; upper range 
b83e cd 72 9d			call macro_dsp_valuehl 
b841				endm 
# End of macro FORTH_DSP_VALUEHL
b841			 
b841 22 b3 eb				ld (LFSRSeed), hl	 
b844			 
b844					if DEBUG_FORTH_WORDS 
b844						DMARK "RN1" 
b844 f5				push af  
b845 3a 59 b8			ld a, (.dmark)  
b848 32 71 ee			ld (debug_mark),a  
b84b 3a 5a b8			ld a, (.dmark+1)  
b84e 32 72 ee			ld (debug_mark+1),a  
b851 3a 5b b8			ld a, (.dmark+2)  
b854 32 73 ee			ld (debug_mark+2),a  
b857 18 03			jr .pastdmark  
b859 ..			.dmark: db "RN1"  
b85c f1			.pastdmark: pop af  
b85d			endm  
# End of macro DMARK
b85d						CALLMONITOR 
b85d cd dd 94			call break_point_state  
b860				endm  
# End of macro CALLMONITOR
b860					endif 
b860					FORTH_DSP_POP 
b860 cd 2a 9e			call macro_forth_dsp_pop 
b863				endm 
# End of macro FORTH_DSP_POP
b863			 
b863					FORTH_DSP_VALUEHL    ; low range 
b863 cd 72 9d			call macro_dsp_valuehl 
b866				endm 
# End of macro FORTH_DSP_VALUEHL
b866			 
b866					if DEBUG_FORTH_WORDS 
b866						DMARK "RN2" 
b866 f5				push af  
b867 3a 7b b8			ld a, (.dmark)  
b86a 32 71 ee			ld (debug_mark),a  
b86d 3a 7c b8			ld a, (.dmark+1)  
b870 32 72 ee			ld (debug_mark+1),a  
b873 3a 7d b8			ld a, (.dmark+2)  
b876 32 73 ee			ld (debug_mark+2),a  
b879 18 03			jr .pastdmark  
b87b ..			.dmark: db "RN2"  
b87e f1			.pastdmark: pop af  
b87f			endm  
# End of macro DMARK
b87f						CALLMONITOR 
b87f cd dd 94			call break_point_state  
b882				endm  
# End of macro CALLMONITOR
b882					endif 
b882 22 b5 eb				ld (LFSRSeed+2), hl 
b885			 
b885					FORTH_DSP_POP 
b885 cd 2a 9e			call macro_forth_dsp_pop 
b888				endm 
# End of macro FORTH_DSP_POP
b888			 
b888 e5					push hl 
b889			 
b889 e1			.inrange:	pop hl 
b88a cd 03 8c				call prng16  
b88d					if DEBUG_FORTH_WORDS 
b88d						DMARK "RN3" 
b88d f5				push af  
b88e 3a a2 b8			ld a, (.dmark)  
b891 32 71 ee			ld (debug_mark),a  
b894 3a a3 b8			ld a, (.dmark+1)  
b897 32 72 ee			ld (debug_mark+1),a  
b89a 3a a4 b8			ld a, (.dmark+2)  
b89d 32 73 ee			ld (debug_mark+2),a  
b8a0 18 03			jr .pastdmark  
b8a2 ..			.dmark: db "RN3"  
b8a5 f1			.pastdmark: pop af  
b8a6			endm  
# End of macro DMARK
b8a6						CALLMONITOR 
b8a6 cd dd 94			call break_point_state  
b8a9				endm  
# End of macro CALLMONITOR
b8a9					endif 
b8a9					 
b8a9					; if the range is 8bit knock out the high byte 
b8a9			 
b8a9 ed 5b b3 eb			ld de, (LFSRSeed)     ; check high level 
b8ad			 
b8ad 3e 00				ld a, 0 
b8af ba					cp d  
b8b0 20 1e				jr nz, .hirange 
b8b2 26 00				ld h, 0   ; knock it down to 8bit 
b8b4			 
b8b4					if DEBUG_FORTH_WORDS 
b8b4						DMARK "RNk" 
b8b4 f5				push af  
b8b5 3a c9 b8			ld a, (.dmark)  
b8b8 32 71 ee			ld (debug_mark),a  
b8bb 3a ca b8			ld a, (.dmark+1)  
b8be 32 72 ee			ld (debug_mark+1),a  
b8c1 3a cb b8			ld a, (.dmark+2)  
b8c4 32 73 ee			ld (debug_mark+2),a  
b8c7 18 03			jr .pastdmark  
b8c9 ..			.dmark: db "RNk"  
b8cc f1			.pastdmark: pop af  
b8cd			endm  
# End of macro DMARK
b8cd						CALLMONITOR 
b8cd cd dd 94			call break_point_state  
b8d0				endm  
# End of macro CALLMONITOR
b8d0					endif 
b8d0			.hirange:   
b8d0 e5					push hl  
b8d1 b7					or a  
b8d2 ed 52		                sbc hl, de 
b8d4			 
b8d4					;call cmp16 
b8d4			 
b8d4 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b8d6 e1					pop hl 
b8d7 e5					push hl 
b8d8			 
b8d8					if DEBUG_FORTH_WORDS 
b8d8						DMARK "RN4" 
b8d8 f5				push af  
b8d9 3a ed b8			ld a, (.dmark)  
b8dc 32 71 ee			ld (debug_mark),a  
b8df 3a ee b8			ld a, (.dmark+1)  
b8e2 32 72 ee			ld (debug_mark+1),a  
b8e5 3a ef b8			ld a, (.dmark+2)  
b8e8 32 73 ee			ld (debug_mark+2),a  
b8eb 18 03			jr .pastdmark  
b8ed ..			.dmark: db "RN4"  
b8f0 f1			.pastdmark: pop af  
b8f1			endm  
# End of macro DMARK
b8f1						CALLMONITOR 
b8f1 cd dd 94			call break_point_state  
b8f4				endm  
# End of macro CALLMONITOR
b8f4					endif 
b8f4 ed 5b b5 eb			ld de, (LFSRSeed+2)   ; check low range 
b8f8					;call cmp16 
b8f8				 
b8f8 b7					or a  
b8f9 ed 52		                sbc hl, de 
b8fb 38 8c				jr c, .inrange 
b8fd			 
b8fd e1					pop hl 
b8fe					 
b8fe					if DEBUG_FORTH_WORDS 
b8fe						DMARK "RNd" 
b8fe f5				push af  
b8ff 3a 13 b9			ld a, (.dmark)  
b902 32 71 ee			ld (debug_mark),a  
b905 3a 14 b9			ld a, (.dmark+1)  
b908 32 72 ee			ld (debug_mark+1),a  
b90b 3a 15 b9			ld a, (.dmark+2)  
b90e 32 73 ee			ld (debug_mark+2),a  
b911 18 03			jr .pastdmark  
b913 ..			.dmark: db "RNd"  
b916 f1			.pastdmark: pop af  
b917			endm  
# End of macro DMARK
b917						CALLMONITOR 
b917 cd dd 94			call break_point_state  
b91a				endm  
# End of macro CALLMONITOR
b91a					endif 
b91a			 
b91a			 
b91a cd 7b 9b				call forth_push_numhl 
b91d				       NEXTW 
b91d c3 28 9f			jp macro_next 
b920				endm 
# End of macro NEXTW
b920			 
b920			.ENDMATHS: 
b920			 
b920			; eof 
b920			 
# End of file forth_words_maths.asm
b920			include "forth_words_display.asm" 
b920			 
b920			; | ## Display Words 
b920			 
b920			.ACT: 
b920			 
b920				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b920 62				db WORD_SYS_CORE+78             
b921 6c b9			dw .INFO            
b923 07				db 6 + 1 
b924 .. 00			db "ACTIVE",0              
b92b				endm 
# End of macro CWHEAD
b92b			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b92b			;  
b92b			; | | e.g. $ff $00 do active . $01 pause loop 
b92b			 
b92b					if DEBUG_FORTH_WORDS_KEY 
b92b						DMARK "ACT" 
b92b f5				push af  
b92c 3a 40 b9			ld a, (.dmark)  
b92f 32 71 ee			ld (debug_mark),a  
b932 3a 41 b9			ld a, (.dmark+1)  
b935 32 72 ee			ld (debug_mark+1),a  
b938 3a 42 b9			ld a, (.dmark+2)  
b93b 32 73 ee			ld (debug_mark+2),a  
b93e 18 03			jr .pastdmark  
b940 ..			.dmark: db "ACT"  
b943 f1			.pastdmark: pop af  
b944			endm  
# End of macro DMARK
b944						CALLMONITOR 
b944 cd dd 94			call break_point_state  
b947				endm  
# End of macro CALLMONITOR
b947					endif 
b947 cd 06 8a				call active 
b94a					if DEBUG_FORTH_WORDS 
b94a						DMARK "ACp" 
b94a f5				push af  
b94b 3a 5f b9			ld a, (.dmark)  
b94e 32 71 ee			ld (debug_mark),a  
b951 3a 60 b9			ld a, (.dmark+1)  
b954 32 72 ee			ld (debug_mark+1),a  
b957 3a 61 b9			ld a, (.dmark+2)  
b95a 32 73 ee			ld (debug_mark+2),a  
b95d 18 03			jr .pastdmark  
b95f ..			.dmark: db "ACp"  
b962 f1			.pastdmark: pop af  
b963			endm  
# End of macro DMARK
b963						CALLMONITOR 
b963 cd dd 94			call break_point_state  
b966				endm  
# End of macro CALLMONITOR
b966					endif 
b966 cd e9 9b				call forth_push_str 
b969			 
b969					NEXTW 
b969 c3 28 9f			jp macro_next 
b96c				endm 
# End of macro NEXTW
b96c			.INFO: 
b96c			 
b96c				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b96c 62				db WORD_SYS_CORE+78             
b96d 89 b9			dw .ATP            
b96f 05				db 4 + 1 
b970 .. 00			db "INFO",0              
b975				endm 
# End of macro CWHEAD
b975			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b975					FORTH_DSP_VALUEHL 
b975 cd 72 9d			call macro_dsp_valuehl 
b978				endm 
# End of macro FORTH_DSP_VALUEHL
b978			 
b978					FORTH_DSP_POP 
b978 cd 2a 9e			call macro_forth_dsp_pop 
b97b				endm 
# End of macro FORTH_DSP_POP
b97b			 
b97b e5					push hl 
b97c			 
b97c					FORTH_DSP_VALUEHL 
b97c cd 72 9d			call macro_dsp_valuehl 
b97f				endm 
# End of macro FORTH_DSP_VALUEHL
b97f			 
b97f					FORTH_DSP_POP 
b97f cd 2a 9e			call macro_forth_dsp_pop 
b982				endm 
# End of macro FORTH_DSP_POP
b982			 
b982 d1					pop de 
b983			 
b983 cd 40 8a				call info_panel 
b986			 
b986			 
b986					NEXTW 
b986 c3 28 9f			jp macro_next 
b989				endm 
# End of macro NEXTW
b989			.ATP: 
b989				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b989 62				db WORD_SYS_CORE+78             
b98a 00 ba			dw .FB            
b98c 04				db 3 + 1 
b98d .. 00			db "AT?",0              
b991				endm 
# End of macro CWHEAD
b991			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b991					if DEBUG_FORTH_WORDS_KEY 
b991						DMARK "AT?" 
b991 f5				push af  
b992 3a a6 b9			ld a, (.dmark)  
b995 32 71 ee			ld (debug_mark),a  
b998 3a a7 b9			ld a, (.dmark+1)  
b99b 32 72 ee			ld (debug_mark+1),a  
b99e 3a a8 b9			ld a, (.dmark+2)  
b9a1 32 73 ee			ld (debug_mark+2),a  
b9a4 18 03			jr .pastdmark  
b9a6 ..			.dmark: db "AT?"  
b9a9 f1			.pastdmark: pop af  
b9aa			endm  
# End of macro DMARK
b9aa						CALLMONITOR 
b9aa cd dd 94			call break_point_state  
b9ad				endm  
# End of macro CALLMONITOR
b9ad					endif 
b9ad 3a 64 ea				ld a, (f_cursor_ptr) 
b9b0			 
b9b0			if DEBUG_FORTH_WORDS 
b9b0				DMARK "AT?" 
b9b0 f5				push af  
b9b1 3a c5 b9			ld a, (.dmark)  
b9b4 32 71 ee			ld (debug_mark),a  
b9b7 3a c6 b9			ld a, (.dmark+1)  
b9ba 32 72 ee			ld (debug_mark+1),a  
b9bd 3a c7 b9			ld a, (.dmark+2)  
b9c0 32 73 ee			ld (debug_mark+2),a  
b9c3 18 03			jr .pastdmark  
b9c5 ..			.dmark: db "AT?"  
b9c8 f1			.pastdmark: pop af  
b9c9			endm  
# End of macro DMARK
b9c9				CALLMONITOR 
b9c9 cd dd 94			call break_point_state  
b9cc				endm  
# End of macro CALLMONITOR
b9cc			endif	 
b9cc					; count the number of rows 
b9cc			 
b9cc 06 00				ld b, 0 
b9ce 4f			.atpr:		ld c, a    ; save in case we go below zero 
b9cf d6 28				sub display_cols 
b9d1 f2 d7 b9				jp p, .atprunder 
b9d4 04					inc b 
b9d5 18 f7				jr .atpr 
b9d7			.atprunder:	 
b9d7			if DEBUG_FORTH_WORDS 
b9d7				DMARK "A?2" 
b9d7 f5				push af  
b9d8 3a ec b9			ld a, (.dmark)  
b9db 32 71 ee			ld (debug_mark),a  
b9de 3a ed b9			ld a, (.dmark+1)  
b9e1 32 72 ee			ld (debug_mark+1),a  
b9e4 3a ee b9			ld a, (.dmark+2)  
b9e7 32 73 ee			ld (debug_mark+2),a  
b9ea 18 03			jr .pastdmark  
b9ec ..			.dmark: db "A?2"  
b9ef f1			.pastdmark: pop af  
b9f0			endm  
# End of macro DMARK
b9f0				CALLMONITOR 
b9f0 cd dd 94			call break_point_state  
b9f3				endm  
# End of macro CALLMONITOR
b9f3			endif	 
b9f3 26 00				ld h, 0 
b9f5 69					ld l, c 
b9f6 cd 7b 9b				call forth_push_numhl 
b9f9 68					ld l, b  
b9fa cd 7b 9b				call forth_push_numhl 
b9fd			 
b9fd			 
b9fd				NEXTW 
b9fd c3 28 9f			jp macro_next 
ba00				endm 
# End of macro NEXTW
ba00			 
ba00			.FB: 
ba00				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
ba00 1b				db WORD_SYS_CORE+7             
ba01 4e ba			dw .EMIT            
ba03 03				db 2 + 1 
ba04 .. 00			db "FB",0              
ba07				endm 
# End of macro CWHEAD
ba07			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
ba07			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
ba07			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
ba07			; | | If automatic display is off then updates will not be shown until DRAW is used. 
ba07					if DEBUG_FORTH_WORDS_KEY 
ba07						DMARK "FB." 
ba07 f5				push af  
ba08 3a 1c ba			ld a, (.dmark)  
ba0b 32 71 ee			ld (debug_mark),a  
ba0e 3a 1d ba			ld a, (.dmark+1)  
ba11 32 72 ee			ld (debug_mark+1),a  
ba14 3a 1e ba			ld a, (.dmark+2)  
ba17 32 73 ee			ld (debug_mark+2),a  
ba1a 18 03			jr .pastdmark  
ba1c ..			.dmark: db "FB."  
ba1f f1			.pastdmark: pop af  
ba20			endm  
# End of macro DMARK
ba20						CALLMONITOR 
ba20 cd dd 94			call break_point_state  
ba23				endm  
# End of macro CALLMONITOR
ba23					endif 
ba23			 
ba23					FORTH_DSP_VALUEHL 
ba23 cd 72 9d			call macro_dsp_valuehl 
ba26				endm 
# End of macro FORTH_DSP_VALUEHL
ba26			 
ba26 7d					ld a, l 
ba27 fe 01				cp 1 
ba29 20 05				jr nz, .fbn1 
ba2b 21 16 ed				ld hl, display_fb1 
ba2e 18 15				jr .fbset 
ba30 fe 02		.fbn1:		cp 2 
ba32 20 05				jr nz, .fbn2 
ba34 21 d4 eb				ld hl, display_fb2 
ba37 18 0c				jr .fbset 
ba39 fe 03		.fbn2:		cp 3 
ba3b 20 05				jr nz, .fbn3 
ba3d 21 75 ec				ld hl, display_fb3 
ba40 18 03				jr .fbset 
ba42			.fbn3:		 ; if invalid number select first 
ba42 21 16 ed				ld hl, display_fb1 
ba45 22 d2 eb		.fbset:		ld (display_fb_active), hl 
ba48			 
ba48					FORTH_DSP_POP 
ba48 cd 2a 9e			call macro_forth_dsp_pop 
ba4b				endm 
# End of macro FORTH_DSP_POP
ba4b			 
ba4b					NEXTW 
ba4b c3 28 9f			jp macro_next 
ba4e				endm 
# End of macro NEXTW
ba4e			 
ba4e			 
ba4e			.EMIT: 
ba4e				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
ba4e 1b				db WORD_SYS_CORE+7             
ba4f 9f ba			dw .DOTH            
ba51 05				db 4 + 1 
ba52 .. 00			db "EMIT",0              
ba57				endm 
# End of macro CWHEAD
ba57			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
ba57					; get value off TOS and display it 
ba57			 
ba57					if DEBUG_FORTH_WORDS_KEY 
ba57						DMARK "EMT" 
ba57 f5				push af  
ba58 3a 6c ba			ld a, (.dmark)  
ba5b 32 71 ee			ld (debug_mark),a  
ba5e 3a 6d ba			ld a, (.dmark+1)  
ba61 32 72 ee			ld (debug_mark+1),a  
ba64 3a 6e ba			ld a, (.dmark+2)  
ba67 32 73 ee			ld (debug_mark+2),a  
ba6a 18 03			jr .pastdmark  
ba6c ..			.dmark: db "EMT"  
ba6f f1			.pastdmark: pop af  
ba70			endm  
# End of macro DMARK
ba70						CALLMONITOR 
ba70 cd dd 94			call break_point_state  
ba73				endm  
# End of macro CALLMONITOR
ba73					endif 
ba73			 
ba73					FORTH_DSP_VALUEHL 
ba73 cd 72 9d			call macro_dsp_valuehl 
ba76				endm 
# End of macro FORTH_DSP_VALUEHL
ba76			 
ba76 7d					ld a,l 
ba77			 
ba77					; TODO write to display 
ba77			 
ba77 32 c5 e4				ld (os_input), a 
ba7a 3e 00				ld a, 0 
ba7c 32 c6 e4				ld (os_input+1), a 
ba7f					 
ba7f 3a 64 ea				ld a, (f_cursor_ptr) 
ba82 11 c5 e4				ld de, os_input 
ba85 cd c2 8a				call str_at_display 
ba88			 
ba88			 
ba88 3a 42 ea				ld a,(cli_autodisplay) 
ba8b fe 00				cp 0 
ba8d 28 03				jr z, .enoupdate 
ba8f cd d2 8a						call update_display 
ba92					.enoupdate: 
ba92			 
ba92 3a 64 ea				ld a, (f_cursor_ptr) 
ba95 3c					inc a 
ba96 32 64 ea				ld (f_cursor_ptr), a   ; save new pos 
ba99			 
ba99			 
ba99					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba99 cd 2a 9e			call macro_forth_dsp_pop 
ba9c				endm 
# End of macro FORTH_DSP_POP
ba9c			  
ba9c			 
ba9c					NEXTW 
ba9c c3 28 9f			jp macro_next 
ba9f				endm 
# End of macro NEXTW
ba9f			.DOTH: 
ba9f				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
ba9f 1c				db WORD_SYS_CORE+8             
baa0 cf ba			dw .DOTF            
baa2 03				db 2 + 1 
baa3 .. 00			db ".-",0              
baa6				endm 
# End of macro CWHEAD
baa6			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
baa6					; get value off TOS and display it 
baa6					if DEBUG_FORTH_WORDS_KEY 
baa6						DMARK "DTD" 
baa6 f5				push af  
baa7 3a bb ba			ld a, (.dmark)  
baaa 32 71 ee			ld (debug_mark),a  
baad 3a bc ba			ld a, (.dmark+1)  
bab0 32 72 ee			ld (debug_mark+1),a  
bab3 3a bd ba			ld a, (.dmark+2)  
bab6 32 73 ee			ld (debug_mark+2),a  
bab9 18 03			jr .pastdmark  
babb ..			.dmark: db "DTD"  
babe f1			.pastdmark: pop af  
babf			endm  
# End of macro DMARK
babf						CALLMONITOR 
babf cd dd 94			call break_point_state  
bac2				endm  
# End of macro CALLMONITOR
bac2					endif 
bac2 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
bac4 3e 00			ld a, 0 
bac6 32 43 ea			ld (cli_mvdot), a 
bac9 c3 26 bb			jp .dotgo 
bacc				NEXTW 
bacc c3 28 9f			jp macro_next 
bacf				endm 
# End of macro NEXTW
bacf			.DOTF: 
bacf				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
bacf 1c				db WORD_SYS_CORE+8             
bad0 fd ba			dw .DOT            
bad2 03				db 2 + 1 
bad3 .. 00			db ".>",0              
bad6				endm 
# End of macro CWHEAD
bad6			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
bad6					; get value off TOS and display it 
bad6			        ; TODO BUG adds extra spaces 
bad6			        ; TODO BUG handle numerics? 
bad6					if DEBUG_FORTH_WORDS_KEY 
bad6						DMARK "DTC" 
bad6 f5				push af  
bad7 3a eb ba			ld a, (.dmark)  
bada 32 71 ee			ld (debug_mark),a  
badd 3a ec ba			ld a, (.dmark+1)  
bae0 32 72 ee			ld (debug_mark+1),a  
bae3 3a ed ba			ld a, (.dmark+2)  
bae6 32 73 ee			ld (debug_mark+2),a  
bae9 18 03			jr .pastdmark  
baeb ..			.dmark: db "DTC"  
baee f1			.pastdmark: pop af  
baef			endm  
# End of macro DMARK
baef						CALLMONITOR 
baef cd dd 94			call break_point_state  
baf2				endm  
# End of macro CALLMONITOR
baf2					endif 
baf2 3e 01			ld a, 1 
baf4 32 43 ea			ld (cli_mvdot), a 
baf7 c3 26 bb			jp .dotgo 
bafa				NEXTW 
bafa c3 28 9f			jp macro_next 
bafd				endm 
# End of macro NEXTW
bafd			 
bafd			.DOT: 
bafd				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bafd 1c				db WORD_SYS_CORE+8             
bafe d9 bc			dw .CLS            
bb00 02				db 1 + 1 
bb01 .. 00			db ".",0              
bb03				endm 
# End of macro CWHEAD
bb03			        ; | . ( u -- ) Display TOS | DONE 
bb03					; get value off TOS and display it 
bb03			 
bb03					if DEBUG_FORTH_WORDS_KEY 
bb03						DMARK "DOT" 
bb03 f5				push af  
bb04 3a 18 bb			ld a, (.dmark)  
bb07 32 71 ee			ld (debug_mark),a  
bb0a 3a 19 bb			ld a, (.dmark+1)  
bb0d 32 72 ee			ld (debug_mark+1),a  
bb10 3a 1a bb			ld a, (.dmark+2)  
bb13 32 73 ee			ld (debug_mark+2),a  
bb16 18 03			jr .pastdmark  
bb18 ..			.dmark: db "DOT"  
bb1b f1			.pastdmark: pop af  
bb1c			endm  
# End of macro DMARK
bb1c						CALLMONITOR 
bb1c cd dd 94			call break_point_state  
bb1f				endm  
# End of macro CALLMONITOR
bb1f					endif 
bb1f 3e 00			ld a, 0 
bb21 32 43 ea			ld (cli_mvdot), a 
bb24 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
bb26				 
bb26			 
bb26			.dotgo: 
bb26			 
bb26			; move up type to on stack for parserv5 
bb26					FORTH_DSP 
bb26 cd 38 9d			call macro_forth_dsp 
bb29				endm 
# End of macro FORTH_DSP
bb29				;FORTH_DSP_VALUE  
bb29			 
bb29			if DEBUG_FORTH_DOT 
bb29				DMARK "DOT" 
bb29 f5				push af  
bb2a 3a 3e bb			ld a, (.dmark)  
bb2d 32 71 ee			ld (debug_mark),a  
bb30 3a 3f bb			ld a, (.dmark+1)  
bb33 32 72 ee			ld (debug_mark+1),a  
bb36 3a 40 bb			ld a, (.dmark+2)  
bb39 32 73 ee			ld (debug_mark+2),a  
bb3c 18 03			jr .pastdmark  
bb3e ..			.dmark: db "DOT"  
bb41 f1			.pastdmark: pop af  
bb42			endm  
# End of macro DMARK
bb42				CALLMONITOR 
bb42 cd dd 94			call break_point_state  
bb45				endm  
# End of macro CALLMONITOR
bb45			endif	 
bb45			;		.print: 
bb45			 
bb45 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bb46 23				inc hl   ; position to the actual value 
bb47 fe 01			cp DS_TYPE_STR 
bb49 20 06			jr nz, .dotnum1  
bb4b			 
bb4b			; display string 
bb4b				FORTH_DSP_VALUE  
bb4b cd 5b 9d			call macro_forth_dsp_value 
bb4e				endm 
# End of macro FORTH_DSP_VALUE
bb4e eb				ex de,hl 
bb4f 18 49			jr .dotwrite 
bb51			 
bb51			.dotnum1: 
bb51 fe 02			cp DS_TYPE_INUM 
bb53 20 44			jr nz, .dotflot 
bb55			 
bb55			 
bb55			; display number 
bb55			 
bb55			;	push hl 
bb55			;	call clear_display 
bb55			;	pop hl 
bb55			 
bb55 5e				ld e, (hl) 
bb56 23				inc hl 
bb57 56				ld d, (hl) 
bb58 21 c7 e2			ld hl, scratch 
bb5b			if DEBUG_FORTH_DOT 
bb5b				DMARK "DT1" 
bb5b f5				push af  
bb5c 3a 70 bb			ld a, (.dmark)  
bb5f 32 71 ee			ld (debug_mark),a  
bb62 3a 71 bb			ld a, (.dmark+1)  
bb65 32 72 ee			ld (debug_mark+1),a  
bb68 3a 72 bb			ld a, (.dmark+2)  
bb6b 32 73 ee			ld (debug_mark+2),a  
bb6e 18 03			jr .pastdmark  
bb70 ..			.dmark: db "DT1"  
bb73 f1			.pastdmark: pop af  
bb74			endm  
# End of macro DMARK
bb74				CALLMONITOR 
bb74 cd dd 94			call break_point_state  
bb77				endm  
# End of macro CALLMONITOR
bb77			endif	 
bb77			 
bb77 cd e9 90			call uitoa_16 
bb7a eb				ex de,hl 
bb7b			 
bb7b			if DEBUG_FORTH_DOT 
bb7b				DMARK "DT2" 
bb7b f5				push af  
bb7c 3a 90 bb			ld a, (.dmark)  
bb7f 32 71 ee			ld (debug_mark),a  
bb82 3a 91 bb			ld a, (.dmark+1)  
bb85 32 72 ee			ld (debug_mark+1),a  
bb88 3a 92 bb			ld a, (.dmark+2)  
bb8b 32 73 ee			ld (debug_mark+2),a  
bb8e 18 03			jr .pastdmark  
bb90 ..			.dmark: db "DT2"  
bb93 f1			.pastdmark: pop af  
bb94			endm  
# End of macro DMARK
bb94				CALLMONITOR 
bb94 cd dd 94			call break_point_state  
bb97				endm  
# End of macro CALLMONITOR
bb97			endif	 
bb97			 
bb97			;	ld de, os_word_scratch 
bb97 18 01			jr .dotwrite 
bb99			 
bb99 00			.dotflot:   nop 
bb9a			; TODO print floating point number 
bb9a			 
bb9a			.dotwrite:		 
bb9a			 
bb9a					; if c is set then set all '-' to spaces 
bb9a					; need to also take into account .>  
bb9a			 
bb9a 3e 01				ld a, 1 
bb9c b9					cp c 
bb9d 20 67				jr nz, .nodashswap 
bb9f			 
bb9f					; DE has the string to write, working with HL 
bb9f			 
bb9f 06 ff				ld b, 255 
bba1 d5					push de 
bba2 e1					pop hl 
bba3			 
bba3			if DEBUG_FORTH_DOT 
bba3				DMARK "DT-" 
bba3 f5				push af  
bba4 3a b8 bb			ld a, (.dmark)  
bba7 32 71 ee			ld (debug_mark),a  
bbaa 3a b9 bb			ld a, (.dmark+1)  
bbad 32 72 ee			ld (debug_mark+1),a  
bbb0 3a ba bb			ld a, (.dmark+2)  
bbb3 32 73 ee			ld (debug_mark+2),a  
bbb6 18 03			jr .pastdmark  
bbb8 ..			.dmark: db "DT-"  
bbbb f1			.pastdmark: pop af  
bbbc			endm  
# End of macro DMARK
bbbc				CALLMONITOR 
bbbc cd dd 94			call break_point_state  
bbbf				endm  
# End of macro CALLMONITOR
bbbf			endif	 
bbbf 7e			.dashscan:	ld a, (hl) 
bbc0 fe 00				cp 0 
bbc2 28 42				jr z, .nodashswap 
bbc4 fe 2d				cp '-' 
bbc6 20 03				jr nz, .dashskip 
bbc8 3e 20				ld a, ' ' 
bbca 77					ld (hl), a 
bbcb 23			.dashskip:	inc hl 
bbcc			if DEBUG_FORTH_DOT 
bbcc				DMARK "D-2" 
bbcc f5				push af  
bbcd 3a e1 bb			ld a, (.dmark)  
bbd0 32 71 ee			ld (debug_mark),a  
bbd3 3a e2 bb			ld a, (.dmark+1)  
bbd6 32 72 ee			ld (debug_mark+1),a  
bbd9 3a e3 bb			ld a, (.dmark+2)  
bbdc 32 73 ee			ld (debug_mark+2),a  
bbdf 18 03			jr .pastdmark  
bbe1 ..			.dmark: db "D-2"  
bbe4 f1			.pastdmark: pop af  
bbe5			endm  
# End of macro DMARK
bbe5				CALLMONITOR 
bbe5 cd dd 94			call break_point_state  
bbe8				endm  
# End of macro CALLMONITOR
bbe8			endif	 
bbe8 10 d5				djnz .dashscan 
bbea			 
bbea			if DEBUG_FORTH_DOT 
bbea				DMARK "D-1" 
bbea f5				push af  
bbeb 3a ff bb			ld a, (.dmark)  
bbee 32 71 ee			ld (debug_mark),a  
bbf1 3a 00 bc			ld a, (.dmark+1)  
bbf4 32 72 ee			ld (debug_mark+1),a  
bbf7 3a 01 bc			ld a, (.dmark+2)  
bbfa 32 73 ee			ld (debug_mark+2),a  
bbfd 18 03			jr .pastdmark  
bbff ..			.dmark: db "D-1"  
bc02 f1			.pastdmark: pop af  
bc03			endm  
# End of macro DMARK
bc03				CALLMONITOR 
bc03 cd dd 94			call break_point_state  
bc06				endm  
# End of macro CALLMONITOR
bc06			endif	 
bc06			 
bc06			.nodashswap: 
bc06			 
bc06			if DEBUG_FORTH_DOT 
bc06				DMARK "D-o" 
bc06 f5				push af  
bc07 3a 1b bc			ld a, (.dmark)  
bc0a 32 71 ee			ld (debug_mark),a  
bc0d 3a 1c bc			ld a, (.dmark+1)  
bc10 32 72 ee			ld (debug_mark+1),a  
bc13 3a 1d bc			ld a, (.dmark+2)  
bc16 32 73 ee			ld (debug_mark+2),a  
bc19 18 03			jr .pastdmark  
bc1b ..			.dmark: db "D-o"  
bc1e f1			.pastdmark: pop af  
bc1f			endm  
# End of macro DMARK
bc1f				CALLMONITOR 
bc1f cd dd 94			call break_point_state  
bc22				endm  
# End of macro CALLMONITOR
bc22			endif	 
bc22			 
bc22 d5					push de   ; save string start in case we need to advance print 
bc23			 
bc23 3a 64 ea				ld a, (f_cursor_ptr) 
bc26 cd c2 8a				call str_at_display 
bc29 3a 42 ea				ld a,(cli_autodisplay) 
bc2c fe 00				cp 0 
bc2e 28 03				jr z, .noupdate 
bc30 cd d2 8a						call update_display 
bc33					.noupdate: 
bc33			 
bc33			 
bc33					; see if we need to advance the print position 
bc33			 
bc33 e1					pop hl   ; get back string 
bc34			;		ex de,hl 
bc34			 
bc34 3a 43 ea				ld a, (cli_mvdot) 
bc37			if DEBUG_FORTH_DOT 
bc37			;		ld e,a 
bc37				DMARK "D>1" 
bc37 f5				push af  
bc38 3a 4c bc			ld a, (.dmark)  
bc3b 32 71 ee			ld (debug_mark),a  
bc3e 3a 4d bc			ld a, (.dmark+1)  
bc41 32 72 ee			ld (debug_mark+1),a  
bc44 3a 4e bc			ld a, (.dmark+2)  
bc47 32 73 ee			ld (debug_mark+2),a  
bc4a 18 03			jr .pastdmark  
bc4c ..			.dmark: db "D>1"  
bc4f f1			.pastdmark: pop af  
bc50			endm  
# End of macro DMARK
bc50				CALLMONITOR 
bc50 cd dd 94			call break_point_state  
bc53				endm  
# End of macro CALLMONITOR
bc53			endif	 
bc53 fe 00				cp 0 
bc55 28 44				jr z, .noadv 
bc57					; yes, lets advance the print position 
bc57 3e 00				ld a, 0 
bc59 cd 45 91				call strlent 
bc5c			if DEBUG_FORTH_DOT 
bc5c				DMARK "D-?" 
bc5c f5				push af  
bc5d 3a 71 bc			ld a, (.dmark)  
bc60 32 71 ee			ld (debug_mark),a  
bc63 3a 72 bc			ld a, (.dmark+1)  
bc66 32 72 ee			ld (debug_mark+1),a  
bc69 3a 73 bc			ld a, (.dmark+2)  
bc6c 32 73 ee			ld (debug_mark+2),a  
bc6f 18 03			jr .pastdmark  
bc71 ..			.dmark: db "D-?"  
bc74 f1			.pastdmark: pop af  
bc75			endm  
# End of macro DMARK
bc75				CALLMONITOR 
bc75 cd dd 94			call break_point_state  
bc78				endm  
# End of macro CALLMONITOR
bc78			endif	 
bc78 3a 64 ea				ld a, (f_cursor_ptr) 
bc7b 85					add a,l 
bc7c					;call addatohl 
bc7c					;ld a, l 
bc7c 32 64 ea				ld (f_cursor_ptr), a   ; save new pos 
bc7f			 
bc7f			if DEBUG_FORTH_DOT 
bc7f				DMARK "D->" 
bc7f f5				push af  
bc80 3a 94 bc			ld a, (.dmark)  
bc83 32 71 ee			ld (debug_mark),a  
bc86 3a 95 bc			ld a, (.dmark+1)  
bc89 32 72 ee			ld (debug_mark+1),a  
bc8c 3a 96 bc			ld a, (.dmark+2)  
bc8f 32 73 ee			ld (debug_mark+2),a  
bc92 18 03			jr .pastdmark  
bc94 ..			.dmark: db "D->"  
bc97 f1			.pastdmark: pop af  
bc98			endm  
# End of macro DMARK
bc98				CALLMONITOR 
bc98 cd dd 94			call break_point_state  
bc9b				endm  
# End of macro CALLMONITOR
bc9b			endif	 
bc9b			 
bc9b			.noadv:	 
bc9b			 
bc9b					if DEBUG_FORTH_DOT_WAIT 
bc9b							call next_page_prompt 
bc9b					endif	 
bc9b			; TODO this pop off the stack causes a crash. i dont know why 
bc9b			 
bc9b			 
bc9b			if DEBUG_FORTH_DOT 
bc9b				DMARK "DTh" 
bc9b f5				push af  
bc9c 3a b0 bc			ld a, (.dmark)  
bc9f 32 71 ee			ld (debug_mark),a  
bca2 3a b1 bc			ld a, (.dmark+1)  
bca5 32 72 ee			ld (debug_mark+1),a  
bca8 3a b2 bc			ld a, (.dmark+2)  
bcab 32 73 ee			ld (debug_mark+2),a  
bcae 18 03			jr .pastdmark  
bcb0 ..			.dmark: db "DTh"  
bcb3 f1			.pastdmark: pop af  
bcb4			endm  
# End of macro DMARK
bcb4				CALLMONITOR 
bcb4 cd dd 94			call break_point_state  
bcb7				endm  
# End of macro CALLMONITOR
bcb7			endif	 
bcb7			 
bcb7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bcb7 cd 2a 9e			call macro_forth_dsp_pop 
bcba				endm 
# End of macro FORTH_DSP_POP
bcba			 
bcba			if DEBUG_FORTH_DOT 
bcba				DMARK "DTi" 
bcba f5				push af  
bcbb 3a cf bc			ld a, (.dmark)  
bcbe 32 71 ee			ld (debug_mark),a  
bcc1 3a d0 bc			ld a, (.dmark+1)  
bcc4 32 72 ee			ld (debug_mark+1),a  
bcc7 3a d1 bc			ld a, (.dmark+2)  
bcca 32 73 ee			ld (debug_mark+2),a  
bccd 18 03			jr .pastdmark  
bccf ..			.dmark: db "DTi"  
bcd2 f1			.pastdmark: pop af  
bcd3			endm  
# End of macro DMARK
bcd3				CALLMONITOR 
bcd3 cd dd 94			call break_point_state  
bcd6				endm  
# End of macro CALLMONITOR
bcd6			endif	 
bcd6			 
bcd6			 
bcd6					NEXTW 
bcd6 c3 28 9f			jp macro_next 
bcd9				endm 
# End of macro NEXTW
bcd9			 
bcd9			.CLS: 
bcd9				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bcd9 35				db WORD_SYS_CORE+33             
bcda 06 bd			dw .DRAW            
bcdc 04				db 3 + 1 
bcdd .. 00			db "CLS",0              
bce1				endm 
# End of macro CWHEAD
bce1			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bce1					if DEBUG_FORTH_WORDS_KEY 
bce1						DMARK "CLS" 
bce1 f5				push af  
bce2 3a f6 bc			ld a, (.dmark)  
bce5 32 71 ee			ld (debug_mark),a  
bce8 3a f7 bc			ld a, (.dmark+1)  
bceb 32 72 ee			ld (debug_mark+1),a  
bcee 3a f8 bc			ld a, (.dmark+2)  
bcf1 32 73 ee			ld (debug_mark+2),a  
bcf4 18 03			jr .pastdmark  
bcf6 ..			.dmark: db "CLS"  
bcf9 f1			.pastdmark: pop af  
bcfa			endm  
# End of macro DMARK
bcfa						CALLMONITOR 
bcfa cd dd 94			call break_point_state  
bcfd				endm  
# End of macro CALLMONITOR
bcfd					endif 
bcfd cd af 8a				call clear_display 
bd00 c3 14 be				jp .home		; and home cursor 
bd03					NEXTW 
bd03 c3 28 9f			jp macro_next 
bd06				endm 
# End of macro NEXTW
bd06			 
bd06			.DRAW: 
bd06				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bd06 36				db WORD_SYS_CORE+34             
bd07 31 bd			dw .DUMP            
bd09 05				db 4 + 1 
bd0a .. 00			db "DRAW",0              
bd0f				endm 
# End of macro CWHEAD
bd0f			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bd0f					if DEBUG_FORTH_WORDS_KEY 
bd0f						DMARK "DRW" 
bd0f f5				push af  
bd10 3a 24 bd			ld a, (.dmark)  
bd13 32 71 ee			ld (debug_mark),a  
bd16 3a 25 bd			ld a, (.dmark+1)  
bd19 32 72 ee			ld (debug_mark+1),a  
bd1c 3a 26 bd			ld a, (.dmark+2)  
bd1f 32 73 ee			ld (debug_mark+2),a  
bd22 18 03			jr .pastdmark  
bd24 ..			.dmark: db "DRW"  
bd27 f1			.pastdmark: pop af  
bd28			endm  
# End of macro DMARK
bd28						CALLMONITOR 
bd28 cd dd 94			call break_point_state  
bd2b				endm  
# End of macro CALLMONITOR
bd2b					endif 
bd2b cd d2 8a				call update_display 
bd2e					NEXTW 
bd2e c3 28 9f			jp macro_next 
bd31				endm 
# End of macro NEXTW
bd31			 
bd31			.DUMP: 
bd31				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bd31 37				db WORD_SYS_CORE+35             
bd32 69 bd			dw .CDUMP            
bd34 05				db 4 + 1 
bd35 .. 00			db "DUMP",0              
bd3a				endm 
# End of macro CWHEAD
bd3a			; | DUMP ( x -- ) With address x display dump   | DONE 
bd3a			; TODO pop address to use off of the stack 
bd3a					if DEBUG_FORTH_WORDS_KEY 
bd3a						DMARK "DUM" 
bd3a f5				push af  
bd3b 3a 4f bd			ld a, (.dmark)  
bd3e 32 71 ee			ld (debug_mark),a  
bd41 3a 50 bd			ld a, (.dmark+1)  
bd44 32 72 ee			ld (debug_mark+1),a  
bd47 3a 51 bd			ld a, (.dmark+2)  
bd4a 32 73 ee			ld (debug_mark+2),a  
bd4d 18 03			jr .pastdmark  
bd4f ..			.dmark: db "DUM"  
bd52 f1			.pastdmark: pop af  
bd53			endm  
# End of macro DMARK
bd53						CALLMONITOR 
bd53 cd dd 94			call break_point_state  
bd56				endm  
# End of macro CALLMONITOR
bd56					endif 
bd56 cd af 8a				call clear_display 
bd59			 
bd59					; get address 
bd59			 
bd59					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd59 cd 72 9d			call macro_dsp_valuehl 
bd5c				endm 
# End of macro FORTH_DSP_VALUEHL
bd5c				 
bd5c					; save it for cdump 
bd5c			 
bd5c 22 ea e5				ld (os_cur_ptr),hl 
bd5f			 
bd5f					; destroy value TOS 
bd5f			 
bd5f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd5f cd 2a 9e			call macro_forth_dsp_pop 
bd62				endm 
# End of macro FORTH_DSP_POP
bd62			 
bd62 cd fb 99				call dumpcont	; skip old style of param parsing	 
bd65 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bd66					NEXTW 
bd66 c3 28 9f			jp macro_next 
bd69				endm 
# End of macro NEXTW
bd69			.CDUMP: 
bd69				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bd69 38				db WORD_SYS_CORE+36             
bd6a 99 bd			dw .DAT            
bd6c 06				db 5 + 1 
bd6d .. 00			db "CDUMP",0              
bd73				endm 
# End of macro CWHEAD
bd73			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bd73					if DEBUG_FORTH_WORDS_KEY 
bd73						DMARK "CDP" 
bd73 f5				push af  
bd74 3a 88 bd			ld a, (.dmark)  
bd77 32 71 ee			ld (debug_mark),a  
bd7a 3a 89 bd			ld a, (.dmark+1)  
bd7d 32 72 ee			ld (debug_mark+1),a  
bd80 3a 8a bd			ld a, (.dmark+2)  
bd83 32 73 ee			ld (debug_mark+2),a  
bd86 18 03			jr .pastdmark  
bd88 ..			.dmark: db "CDP"  
bd8b f1			.pastdmark: pop af  
bd8c			endm  
# End of macro DMARK
bd8c						CALLMONITOR 
bd8c cd dd 94			call break_point_state  
bd8f				endm  
# End of macro CALLMONITOR
bd8f					endif 
bd8f cd af 8a				call clear_display 
bd92 cd fb 99				call dumpcont	 
bd95 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bd96					NEXTW 
bd96 c3 28 9f			jp macro_next 
bd99				endm 
# End of macro NEXTW
bd99			 
bd99			 
bd99			 
bd99			 
bd99			.DAT: 
bd99				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bd99 3d				db WORD_SYS_CORE+41             
bd9a ef bd			dw .HOME            
bd9c 03				db 2 + 1 
bd9d .. 00			db "AT",0              
bda0				endm 
# End of macro CWHEAD
bda0			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bda0					if DEBUG_FORTH_WORDS_KEY 
bda0						DMARK "AT." 
bda0 f5				push af  
bda1 3a b5 bd			ld a, (.dmark)  
bda4 32 71 ee			ld (debug_mark),a  
bda7 3a b6 bd			ld a, (.dmark+1)  
bdaa 32 72 ee			ld (debug_mark+1),a  
bdad 3a b7 bd			ld a, (.dmark+2)  
bdb0 32 73 ee			ld (debug_mark+2),a  
bdb3 18 03			jr .pastdmark  
bdb5 ..			.dmark: db "AT."  
bdb8 f1			.pastdmark: pop af  
bdb9			endm  
# End of macro DMARK
bdb9						CALLMONITOR 
bdb9 cd dd 94			call break_point_state  
bdbc				endm  
# End of macro CALLMONITOR
bdbc					endif 
bdbc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bdbc cd 72 9d			call macro_dsp_valuehl 
bdbf				endm 
# End of macro FORTH_DSP_VALUEHL
bdbf			 
bdbf			 
bdbf					; TODO save cursor row 
bdbf 7d					ld a,l 
bdc0 fe 02				cp 2 
bdc2 20 04				jr nz, .crow3 
bdc4 3e 28				ld a, display_row_2 
bdc6 18 12				jr .ccol1 
bdc8 fe 03		.crow3:		cp 3 
bdca 20 04				jr nz, .crow4 
bdcc 3e 50				ld a, display_row_3 
bdce 18 0a				jr .ccol1 
bdd0 fe 04		.crow4:		cp 4 
bdd2 20 04				jr nz, .crow1 
bdd4 3e 78				ld a, display_row_4 
bdd6 18 02				jr .ccol1 
bdd8 3e 00		.crow1:		ld a,display_row_1 
bdda f5			.ccol1:		push af			; got row offset 
bddb 6f					ld l,a 
bddc 26 00				ld h,0 
bdde					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdde cd 2a 9e			call macro_forth_dsp_pop 
bde1				endm 
# End of macro FORTH_DSP_POP
bde1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bde1 cd 72 9d			call macro_dsp_valuehl 
bde4				endm 
# End of macro FORTH_DSP_VALUEHL
bde4					; TODO save cursor col 
bde4 f1					pop af 
bde5 85					add l		; add col offset 
bde6 32 64 ea				ld (f_cursor_ptr), a 
bde9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bde9 cd 2a 9e			call macro_forth_dsp_pop 
bdec				endm 
# End of macro FORTH_DSP_POP
bdec			 
bdec					; calculate  
bdec			 
bdec					NEXTW 
bdec c3 28 9f			jp macro_next 
bdef				endm 
# End of macro NEXTW
bdef			 
bdef			 
bdef			.HOME: 
bdef				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
bdef 41				db WORD_SYS_CORE+45             
bdf0 1c be			dw .SPACE            
bdf2 05				db 4 + 1 
bdf3 .. 00			db "HOME",0              
bdf8				endm 
# End of macro CWHEAD
bdf8			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bdf8					if DEBUG_FORTH_WORDS_KEY 
bdf8						DMARK "HOM" 
bdf8 f5				push af  
bdf9 3a 0d be			ld a, (.dmark)  
bdfc 32 71 ee			ld (debug_mark),a  
bdff 3a 0e be			ld a, (.dmark+1)  
be02 32 72 ee			ld (debug_mark+1),a  
be05 3a 0f be			ld a, (.dmark+2)  
be08 32 73 ee			ld (debug_mark+2),a  
be0b 18 03			jr .pastdmark  
be0d ..			.dmark: db "HOM"  
be10 f1			.pastdmark: pop af  
be11			endm  
# End of macro DMARK
be11						CALLMONITOR 
be11 cd dd 94			call break_point_state  
be14				endm  
# End of macro CALLMONITOR
be14					endif 
be14 3e 00		.home:		ld a, 0		; and home cursor 
be16 32 64 ea				ld (f_cursor_ptr), a 
be19					NEXTW 
be19 c3 28 9f			jp macro_next 
be1c				endm 
# End of macro NEXTW
be1c			 
be1c			 
be1c			.SPACE: 
be1c				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
be1c 46				db WORD_SYS_CORE+50             
be1d 52 be			dw .SPACES            
be1f 03				db 2 + 1 
be20 .. 00			db "BL",0              
be23				endm 
# End of macro CWHEAD
be23			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
be23					if DEBUG_FORTH_WORDS_KEY 
be23						DMARK "BL." 
be23 f5				push af  
be24 3a 38 be			ld a, (.dmark)  
be27 32 71 ee			ld (debug_mark),a  
be2a 3a 39 be			ld a, (.dmark+1)  
be2d 32 72 ee			ld (debug_mark+1),a  
be30 3a 3a be			ld a, (.dmark+2)  
be33 32 73 ee			ld (debug_mark+2),a  
be36 18 03			jr .pastdmark  
be38 ..			.dmark: db "BL."  
be3b f1			.pastdmark: pop af  
be3c			endm  
# End of macro DMARK
be3c						CALLMONITOR 
be3c cd dd 94			call break_point_state  
be3f				endm  
# End of macro CALLMONITOR
be3f					endif 
be3f 3e 20				ld a, " " 
be41 32 c7 e2				ld (scratch),a 
be44 3e 00				ld a, 0 
be46 32 c8 e2				ld (scratch+1),a 
be49 21 c7 e2				ld hl, scratch 
be4c cd e9 9b				call forth_push_str 
be4f					 
be4f				       NEXTW 
be4f c3 28 9f			jp macro_next 
be52				endm 
# End of macro NEXTW
be52			 
be52			;.blstr: db " ", 0 
be52			 
be52			.SPACES: 
be52				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
be52 47				db WORD_SYS_CORE+51             
be53 ed be			dw .SCROLL            
be55 07				db 6 + 1 
be56 .. 00			db "SPACES",0              
be5d				endm 
# End of macro CWHEAD
be5d			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
be5d					if DEBUG_FORTH_WORDS_KEY 
be5d						DMARK "SPS" 
be5d f5				push af  
be5e 3a 72 be			ld a, (.dmark)  
be61 32 71 ee			ld (debug_mark),a  
be64 3a 73 be			ld a, (.dmark+1)  
be67 32 72 ee			ld (debug_mark+1),a  
be6a 3a 74 be			ld a, (.dmark+2)  
be6d 32 73 ee			ld (debug_mark+2),a  
be70 18 03			jr .pastdmark  
be72 ..			.dmark: db "SPS"  
be75 f1			.pastdmark: pop af  
be76			endm  
# End of macro DMARK
be76						CALLMONITOR 
be76 cd dd 94			call break_point_state  
be79				endm  
# End of macro CALLMONITOR
be79					endif 
be79			 
be79			 
be79					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be79 cd 72 9d			call macro_dsp_valuehl 
be7c				endm 
# End of macro FORTH_DSP_VALUEHL
be7c			 
be7c e5					push hl    ; u 
be7d					if DEBUG_FORTH_WORDS 
be7d						DMARK "SPA" 
be7d f5				push af  
be7e 3a 92 be			ld a, (.dmark)  
be81 32 71 ee			ld (debug_mark),a  
be84 3a 93 be			ld a, (.dmark+1)  
be87 32 72 ee			ld (debug_mark+1),a  
be8a 3a 94 be			ld a, (.dmark+2)  
be8d 32 73 ee			ld (debug_mark+2),a  
be90 18 03			jr .pastdmark  
be92 ..			.dmark: db "SPA"  
be95 f1			.pastdmark: pop af  
be96			endm  
# End of macro DMARK
be96						CALLMONITOR 
be96 cd dd 94			call break_point_state  
be99				endm  
# End of macro CALLMONITOR
be99					endif 
be99			 
be99					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be99 cd 2a 9e			call macro_forth_dsp_pop 
be9c				endm 
# End of macro FORTH_DSP_POP
be9c e1					pop hl 
be9d 0e 00				ld c, 0 
be9f 45					ld b, l 
bea0 21 c7 e2				ld hl, scratch  
bea3			 
bea3					if DEBUG_FORTH_WORDS 
bea3						DMARK "SP2" 
bea3 f5				push af  
bea4 3a b8 be			ld a, (.dmark)  
bea7 32 71 ee			ld (debug_mark),a  
beaa 3a b9 be			ld a, (.dmark+1)  
bead 32 72 ee			ld (debug_mark+1),a  
beb0 3a ba be			ld a, (.dmark+2)  
beb3 32 73 ee			ld (debug_mark+2),a  
beb6 18 03			jr .pastdmark  
beb8 ..			.dmark: db "SP2"  
bebb f1			.pastdmark: pop af  
bebc			endm  
# End of macro DMARK
bebc						CALLMONITOR 
bebc cd dd 94			call break_point_state  
bebf				endm  
# End of macro CALLMONITOR
bebf					endif 
bebf 3e 20				ld a, ' ' 
bec1			.spaces1:	 
bec1 77					ld (hl),a 
bec2 23					inc hl 
bec3					 
bec3 10 fc				djnz .spaces1 
bec5 3e 00				ld a,0 
bec7 77					ld (hl),a 
bec8 21 c7 e2				ld hl, scratch 
becb					if DEBUG_FORTH_WORDS 
becb						DMARK "SP3" 
becb f5				push af  
becc 3a e0 be			ld a, (.dmark)  
becf 32 71 ee			ld (debug_mark),a  
bed2 3a e1 be			ld a, (.dmark+1)  
bed5 32 72 ee			ld (debug_mark+1),a  
bed8 3a e2 be			ld a, (.dmark+2)  
bedb 32 73 ee			ld (debug_mark+2),a  
bede 18 03			jr .pastdmark  
bee0 ..			.dmark: db "SP3"  
bee3 f1			.pastdmark: pop af  
bee4			endm  
# End of macro DMARK
bee4						CALLMONITOR 
bee4 cd dd 94			call break_point_state  
bee7				endm  
# End of macro CALLMONITOR
bee7					endif 
bee7 cd e9 9b				call forth_push_str 
beea			 
beea				       NEXTW 
beea c3 28 9f			jp macro_next 
beed				endm 
# End of macro NEXTW
beed			 
beed			 
beed			 
beed			.SCROLL: 
beed				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
beed 53				db WORD_SYS_CORE+63             
beee 1a bf			dw .SCROLLD            
bef0 07				db 6 + 1 
bef1 .. 00			db "SCROLL",0              
bef8				endm 
# End of macro CWHEAD
bef8			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bef8					if DEBUG_FORTH_WORDS_KEY 
bef8						DMARK "SCR" 
bef8 f5				push af  
bef9 3a 0d bf			ld a, (.dmark)  
befc 32 71 ee			ld (debug_mark),a  
beff 3a 0e bf			ld a, (.dmark+1)  
bf02 32 72 ee			ld (debug_mark+1),a  
bf05 3a 0f bf			ld a, (.dmark+2)  
bf08 32 73 ee			ld (debug_mark+2),a  
bf0b 18 03			jr .pastdmark  
bf0d ..			.dmark: db "SCR"  
bf10 f1			.pastdmark: pop af  
bf11			endm  
# End of macro DMARK
bf11						CALLMONITOR 
bf11 cd dd 94			call break_point_state  
bf14				endm  
# End of macro CALLMONITOR
bf14					endif 
bf14			 
bf14 cd 71 8a			call scroll_up 
bf17			;	call update_display 
bf17			 
bf17					NEXTW 
bf17 c3 28 9f			jp macro_next 
bf1a				endm 
# End of macro NEXTW
bf1a			 
bf1a			 
bf1a			 
bf1a			;		; get dir 
bf1a			; 
bf1a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf1a			; 
bf1a			;		push hl 
bf1a			; 
bf1a			;		; destroy value TOS 
bf1a			; 
bf1a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf1a			; 
bf1a			;		; get count 
bf1a			; 
bf1a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf1a			; 
bf1a			;		push hl 
bf1a			; 
bf1a			;		; destroy value TOS 
bf1a			; 
bf1a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf1a			; 
bf1a			;		; one value on hl get other one back 
bf1a			; 
bf1a			;		pop bc    ; count 
bf1a			; 
bf1a			;		pop de   ; dir 
bf1a			; 
bf1a			; 
bf1a			;		ld b, c 
bf1a			; 
bf1a			;.scrolldir:     push bc 
bf1a			;		push de 
bf1a			; 
bf1a			;		ld a, 0 
bf1a			;		cp e 
bf1a			;		jr z, .scrollup  
bf1a			;		call scroll_down 
bf1a			;		jr .scrollnext 
bf1a			;.scrollup:	call scroll_up 
bf1a			; 
bf1a			;		 
bf1a			;.scrollnext: 
bf1a			;		pop de 
bf1a			;		pop bc 
bf1a			;		djnz .scrolldir 
bf1a			; 
bf1a			; 
bf1a			; 
bf1a			; 
bf1a			; 
bf1a			;		NEXTW 
bf1a			 
bf1a			.SCROLLD: 
bf1a				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bf1a 53				db WORD_SYS_CORE+63             
bf1b 48 bf			dw .ATQ            
bf1d 08				db 7 + 1 
bf1e .. 00			db "SCROLLD",0              
bf26				endm 
# End of macro CWHEAD
bf26			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bf26					if DEBUG_FORTH_WORDS_KEY 
bf26						DMARK "SCD" 
bf26 f5				push af  
bf27 3a 3b bf			ld a, (.dmark)  
bf2a 32 71 ee			ld (debug_mark),a  
bf2d 3a 3c bf			ld a, (.dmark+1)  
bf30 32 72 ee			ld (debug_mark+1),a  
bf33 3a 3d bf			ld a, (.dmark+2)  
bf36 32 73 ee			ld (debug_mark+2),a  
bf39 18 03			jr .pastdmark  
bf3b ..			.dmark: db "SCD"  
bf3e f1			.pastdmark: pop af  
bf3f			endm  
# End of macro DMARK
bf3f						CALLMONITOR 
bf3f cd dd 94			call break_point_state  
bf42				endm  
# End of macro CALLMONITOR
bf42					endif 
bf42			 
bf42 cd 95 8a			call scroll_down 
bf45			;	call update_display 
bf45			 
bf45					NEXTW 
bf45 c3 28 9f			jp macro_next 
bf48				endm 
# End of macro NEXTW
bf48			 
bf48			 
bf48			.ATQ: 
bf48				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bf48 62				db WORD_SYS_CORE+78             
bf49 a6 bf			dw .AUTODSP            
bf4b 04				db 3 + 1 
bf4c .. 00			db "AT@",0              
bf50				endm 
# End of macro CWHEAD
bf50			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bf50					if DEBUG_FORTH_WORDS_KEY 
bf50						DMARK "ATA" 
bf50 f5				push af  
bf51 3a 65 bf			ld a, (.dmark)  
bf54 32 71 ee			ld (debug_mark),a  
bf57 3a 66 bf			ld a, (.dmark+1)  
bf5a 32 72 ee			ld (debug_mark+1),a  
bf5d 3a 67 bf			ld a, (.dmark+2)  
bf60 32 73 ee			ld (debug_mark+2),a  
bf63 18 03			jr .pastdmark  
bf65 ..			.dmark: db "ATA"  
bf68 f1			.pastdmark: pop af  
bf69			endm  
# End of macro DMARK
bf69						CALLMONITOR 
bf69 cd dd 94			call break_point_state  
bf6c				endm  
# End of macro CALLMONITOR
bf6c					endif 
bf6c			 
bf6c			 
bf6c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf6c cd 72 9d			call macro_dsp_valuehl 
bf6f				endm 
# End of macro FORTH_DSP_VALUEHL
bf6f			 
bf6f					; TODO save cursor row 
bf6f 7d					ld a,l 
bf70 fe 02				cp 2 
bf72 20 04				jr nz, .crow3aq 
bf74 3e 28				ld a, display_row_2 
bf76 18 12				jr .ccol1aq 
bf78 fe 03		.crow3aq:		cp 3 
bf7a 20 04				jr nz, .crow4aq 
bf7c 3e 50				ld a, display_row_3 
bf7e 18 0a				jr .ccol1aq 
bf80 fe 04		.crow4aq:		cp 4 
bf82 20 04				jr nz, .crow1aq 
bf84 3e 78				ld a, display_row_4 
bf86 18 02				jr .ccol1aq 
bf88 3e 00		.crow1aq:		ld a,display_row_1 
bf8a f5			.ccol1aq:		push af			; got row offset 
bf8b 6f					ld l,a 
bf8c 26 00				ld h,0 
bf8e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf8e cd 2a 9e			call macro_forth_dsp_pop 
bf91				endm 
# End of macro FORTH_DSP_POP
bf91					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf91 cd 72 9d			call macro_dsp_valuehl 
bf94				endm 
# End of macro FORTH_DSP_VALUEHL
bf94					; TODO save cursor col 
bf94 f1					pop af 
bf95 85					add l		; add col offset 
bf96			 
bf96					; add current frame buffer address 
bf96 2a d2 eb				ld hl, (display_fb_active) 
bf99 cd dc 8c				call addatohl 
bf9c			 
bf9c			 
bf9c			 
bf9c			 
bf9c					; get char frame buffer location offset in hl 
bf9c			 
bf9c 7e					ld a,(hl) 
bf9d 26 00				ld h, 0 
bf9f 6f					ld l, a 
bfa0			 
bfa0 cd 7b 9b				call forth_push_numhl 
bfa3			 
bfa3			 
bfa3					NEXTW 
bfa3 c3 28 9f			jp macro_next 
bfa6				endm 
# End of macro NEXTW
bfa6			 
bfa6			.AUTODSP: 
bfa6				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bfa6 63				db WORD_SYS_CORE+79             
bfa7 bc bf			dw .MENU            
bfa9 05				db 4 + 1 
bfaa .. 00			db "ADSP",0              
bfaf				endm 
# End of macro CWHEAD
bfaf			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bfaf			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bfaf			 
bfaf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfaf cd 72 9d			call macro_dsp_valuehl 
bfb2				endm 
# End of macro FORTH_DSP_VALUEHL
bfb2			 
bfb2			;		push hl 
bfb2			 
bfb2					; destroy value TOS 
bfb2			 
bfb2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfb2 cd 2a 9e			call macro_forth_dsp_pop 
bfb5				endm 
# End of macro FORTH_DSP_POP
bfb5			 
bfb5			;		pop hl 
bfb5			 
bfb5 7d					ld a,l 
bfb6 32 42 ea				ld (cli_autodisplay), a 
bfb9				       NEXTW 
bfb9 c3 28 9f			jp macro_next 
bfbc				endm 
# End of macro NEXTW
bfbc			 
bfbc			.MENU: 
bfbc				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bfbc 70				db WORD_SYS_CORE+92             
bfbd 65 c0			dw .ENDDISPLAY            
bfbf 05				db 4 + 1 
bfc0 .. 00			db "MENU",0              
bfc5				endm 
# End of macro CWHEAD
bfc5			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bfc5			 
bfc5			;		; get number of items on the stack 
bfc5			; 
bfc5				 
bfc5					FORTH_DSP_VALUEHL 
bfc5 cd 72 9d			call macro_dsp_valuehl 
bfc8				endm 
# End of macro FORTH_DSP_VALUEHL
bfc8				 
bfc8					if DEBUG_FORTH_WORDS_KEY 
bfc8						DMARK "MNU" 
bfc8 f5				push af  
bfc9 3a dd bf			ld a, (.dmark)  
bfcc 32 71 ee			ld (debug_mark),a  
bfcf 3a de bf			ld a, (.dmark+1)  
bfd2 32 72 ee			ld (debug_mark+1),a  
bfd5 3a df bf			ld a, (.dmark+2)  
bfd8 32 73 ee			ld (debug_mark+2),a  
bfdb 18 03			jr .pastdmark  
bfdd ..			.dmark: db "MNU"  
bfe0 f1			.pastdmark: pop af  
bfe1			endm  
# End of macro DMARK
bfe1						CALLMONITOR 
bfe1 cd dd 94			call break_point_state  
bfe4				endm  
# End of macro CALLMONITOR
bfe4					endif 
bfe4			 
bfe4 45					ld b, l	 
bfe5 05					dec b 
bfe6			 
bfe6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfe6 cd 2a 9e			call macro_forth_dsp_pop 
bfe9				endm 
# End of macro FORTH_DSP_POP
bfe9			 
bfe9			 
bfe9					; go directly through the stack to pluck out the string pointers and build an array 
bfe9			 
bfe9			;		FORTH_DSP 
bfe9			 
bfe9					; hl contains top most stack item 
bfe9				 
bfe9 11 c7 e2				ld de, scratch 
bfec			 
bfec			.mbuild: 
bfec			 
bfec					FORTH_DSP_VALUEHL 
bfec cd 72 9d			call macro_dsp_valuehl 
bfef				endm 
# End of macro FORTH_DSP_VALUEHL
bfef			 
bfef					if DEBUG_FORTH_WORDS 
bfef						DMARK "MN3" 
bfef f5				push af  
bff0 3a 04 c0			ld a, (.dmark)  
bff3 32 71 ee			ld (debug_mark),a  
bff6 3a 05 c0			ld a, (.dmark+1)  
bff9 32 72 ee			ld (debug_mark+1),a  
bffc 3a 06 c0			ld a, (.dmark+2)  
bfff 32 73 ee			ld (debug_mark+2),a  
c002 18 03			jr .pastdmark  
c004 ..			.dmark: db "MN3"  
c007 f1			.pastdmark: pop af  
c008			endm  
# End of macro DMARK
c008						CALLMONITOR 
c008 cd dd 94			call break_point_state  
c00b				endm  
# End of macro CALLMONITOR
c00b					endif 
c00b eb					ex de, hl 
c00c 73					ld (hl), e 
c00d 23					inc hl 
c00e 72					ld (hl), d 
c00f 23					inc hl 
c010 eb					ex de, hl 
c011			 
c011					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c011 cd 2a 9e			call macro_forth_dsp_pop 
c014				endm 
# End of macro FORTH_DSP_POP
c014			 
c014 10 d6				djnz .mbuild 
c016			 
c016					; done add term 
c016			 
c016 eb					ex de, hl 
c017 36 00				ld (hl), 0 
c019 23					inc hl 
c01a 36 00				ld (hl), 0 
c01c			 
c01c				 
c01c					 
c01c 21 c7 e2				ld hl, scratch 
c01f			 
c01f					if DEBUG_FORTH_WORDS 
c01f						DMARK "MNx" 
c01f f5				push af  
c020 3a 34 c0			ld a, (.dmark)  
c023 32 71 ee			ld (debug_mark),a  
c026 3a 35 c0			ld a, (.dmark+1)  
c029 32 72 ee			ld (debug_mark+1),a  
c02c 3a 36 c0			ld a, (.dmark+2)  
c02f 32 73 ee			ld (debug_mark+2),a  
c032 18 03			jr .pastdmark  
c034 ..			.dmark: db "MNx"  
c037 f1			.pastdmark: pop af  
c038			endm  
# End of macro DMARK
c038						CALLMONITOR 
c038 cd dd 94			call break_point_state  
c03b				endm  
# End of macro CALLMONITOR
c03b					endif 
c03b			 
c03b			 
c03b			 
c03b 3e 00				ld a, 0 
c03d cd e0 8a				call menu 
c040			 
c040			 
c040 6f					ld l, a 
c041 26 00				ld h, 0 
c043			 
c043					if DEBUG_FORTH_WORDS 
c043						DMARK "MNr" 
c043 f5				push af  
c044 3a 58 c0			ld a, (.dmark)  
c047 32 71 ee			ld (debug_mark),a  
c04a 3a 59 c0			ld a, (.dmark+1)  
c04d 32 72 ee			ld (debug_mark+1),a  
c050 3a 5a c0			ld a, (.dmark+2)  
c053 32 73 ee			ld (debug_mark+2),a  
c056 18 03			jr .pastdmark  
c058 ..			.dmark: db "MNr"  
c05b f1			.pastdmark: pop af  
c05c			endm  
# End of macro DMARK
c05c						CALLMONITOR 
c05c cd dd 94			call break_point_state  
c05f				endm  
# End of macro CALLMONITOR
c05f					endif 
c05f			 
c05f cd 7b 9b				call forth_push_numhl 
c062			 
c062			 
c062			 
c062			 
c062				       NEXTW 
c062 c3 28 9f			jp macro_next 
c065				endm 
# End of macro NEXTW
c065			 
c065			 
c065			.ENDDISPLAY: 
c065			 
c065			; eof 
# End of file forth_words_display.asm
c065			include "forth_words_str.asm" 
c065			 
c065			; | ## String Words 
c065			 
c065			.PTR:   
c065			 
c065				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c065 48				db WORD_SYS_CORE+52             
c066 92 c0			dw .STYPE            
c068 04				db 3 + 1 
c069 .. 00			db "PTR",0              
c06d				endm 
# End of macro CWHEAD
c06d			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c06d			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c06d			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c06d			 
c06d					if DEBUG_FORTH_WORDS_KEY 
c06d						DMARK "PTR" 
c06d f5				push af  
c06e 3a 82 c0			ld a, (.dmark)  
c071 32 71 ee			ld (debug_mark),a  
c074 3a 83 c0			ld a, (.dmark+1)  
c077 32 72 ee			ld (debug_mark+1),a  
c07a 3a 84 c0			ld a, (.dmark+2)  
c07d 32 73 ee			ld (debug_mark+2),a  
c080 18 03			jr .pastdmark  
c082 ..			.dmark: db "PTR"  
c085 f1			.pastdmark: pop af  
c086			endm  
# End of macro DMARK
c086						CALLMONITOR 
c086 cd dd 94			call break_point_state  
c089				endm  
# End of macro CALLMONITOR
c089					endif 
c089					FORTH_DSP_VALUEHL 
c089 cd 72 9d			call macro_dsp_valuehl 
c08c				endm 
# End of macro FORTH_DSP_VALUEHL
c08c cd 7b 9b				call forth_push_numhl 
c08f			 
c08f			 
c08f					NEXTW 
c08f c3 28 9f			jp macro_next 
c092				endm 
# End of macro NEXTW
c092			.STYPE: 
c092				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c092 48				db WORD_SYS_CORE+52             
c093 e1 c0			dw .UPPER            
c095 06				db 5 + 1 
c096 .. 00			db "STYPE",0              
c09c				endm 
# End of macro CWHEAD
c09c			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c09c					if DEBUG_FORTH_WORDS_KEY 
c09c						DMARK "STY" 
c09c f5				push af  
c09d 3a b1 c0			ld a, (.dmark)  
c0a0 32 71 ee			ld (debug_mark),a  
c0a3 3a b2 c0			ld a, (.dmark+1)  
c0a6 32 72 ee			ld (debug_mark+1),a  
c0a9 3a b3 c0			ld a, (.dmark+2)  
c0ac 32 73 ee			ld (debug_mark+2),a  
c0af 18 03			jr .pastdmark  
c0b1 ..			.dmark: db "STY"  
c0b4 f1			.pastdmark: pop af  
c0b5			endm  
# End of macro DMARK
c0b5						CALLMONITOR 
c0b5 cd dd 94			call break_point_state  
c0b8				endm  
# End of macro CALLMONITOR
c0b8					endif 
c0b8					FORTH_DSP 
c0b8 cd 38 9d			call macro_forth_dsp 
c0bb				endm 
# End of macro FORTH_DSP
c0bb					;v5 FORTH_DSP_VALUE 
c0bb			 
c0bb 7e					ld a, (hl) 
c0bc			 
c0bc f5					push af 
c0bd			 
c0bd			; Dont destroy TOS		FORTH_DSP_POP 
c0bd			 
c0bd f1					pop af 
c0be			 
c0be fe 01				cp DS_TYPE_STR 
c0c0 28 09				jr z, .typestr 
c0c2			 
c0c2 fe 02				cp DS_TYPE_INUM 
c0c4 28 0a				jr z, .typeinum 
c0c6			 
c0c6 21 df c0				ld hl, .tna 
c0c9 18 0a				jr .tpush 
c0cb			 
c0cb 21 db c0		.typestr:	ld hl, .tstr 
c0ce 18 05				jr .tpush 
c0d0 21 dd c0		.typeinum:	ld hl, .tinum 
c0d3 18 00				jr .tpush 
c0d5			 
c0d5			.tpush: 
c0d5			 
c0d5 cd e9 9b				call forth_push_str 
c0d8			 
c0d8					NEXTW 
c0d8 c3 28 9f			jp macro_next 
c0db				endm 
# End of macro NEXTW
c0db .. 00		.tstr:	db "s",0 
c0dd .. 00		.tinum:  db "i",0 
c0df .. 00		.tna:   db "?", 0 
c0e1			 
c0e1			 
c0e1			.UPPER: 
c0e1				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c0e1 48				db WORD_SYS_CORE+52             
c0e2 1c c1			dw .LOWER            
c0e4 06				db 5 + 1 
c0e5 .. 00			db "UPPER",0              
c0eb				endm 
# End of macro CWHEAD
c0eb			; | UPPER ( s -- s ) Upper case string s  | DONE 
c0eb					if DEBUG_FORTH_WORDS_KEY 
c0eb						DMARK "UPR" 
c0eb f5				push af  
c0ec 3a 00 c1			ld a, (.dmark)  
c0ef 32 71 ee			ld (debug_mark),a  
c0f2 3a 01 c1			ld a, (.dmark+1)  
c0f5 32 72 ee			ld (debug_mark+1),a  
c0f8 3a 02 c1			ld a, (.dmark+2)  
c0fb 32 73 ee			ld (debug_mark+2),a  
c0fe 18 03			jr .pastdmark  
c100 ..			.dmark: db "UPR"  
c103 f1			.pastdmark: pop af  
c104			endm  
# End of macro DMARK
c104						CALLMONITOR 
c104 cd dd 94			call break_point_state  
c107				endm  
# End of macro CALLMONITOR
c107					endif 
c107			 
c107					FORTH_DSP 
c107 cd 38 9d			call macro_forth_dsp 
c10a				endm 
# End of macro FORTH_DSP
c10a					 
c10a			; TODO check is string type 
c10a			 
c10a					FORTH_DSP_VALUEHL 
c10a cd 72 9d			call macro_dsp_valuehl 
c10d				endm 
# End of macro FORTH_DSP_VALUEHL
c10d			; get pointer to string in hl 
c10d			 
c10d 7e			.toup:		ld a, (hl) 
c10e fe 00				cp 0 
c110 28 07				jr z, .toupdone 
c112			 
c112 cd 49 90				call to_upper 
c115			 
c115 77					ld (hl), a 
c116 23					inc hl 
c117 18 f4				jr .toup 
c119			 
c119					 
c119			 
c119			 
c119			; for each char convert to upper 
c119					 
c119			.toupdone: 
c119			 
c119			 
c119					NEXTW 
c119 c3 28 9f			jp macro_next 
c11c				endm 
# End of macro NEXTW
c11c			.LOWER: 
c11c				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c11c 48				db WORD_SYS_CORE+52             
c11d 57 c1			dw .TCASE            
c11f 06				db 5 + 1 
c120 .. 00			db "LOWER",0              
c126				endm 
# End of macro CWHEAD
c126			; | LOWER ( s -- s ) Lower case string s  | DONE 
c126					if DEBUG_FORTH_WORDS_KEY 
c126						DMARK "LWR" 
c126 f5				push af  
c127 3a 3b c1			ld a, (.dmark)  
c12a 32 71 ee			ld (debug_mark),a  
c12d 3a 3c c1			ld a, (.dmark+1)  
c130 32 72 ee			ld (debug_mark+1),a  
c133 3a 3d c1			ld a, (.dmark+2)  
c136 32 73 ee			ld (debug_mark+2),a  
c139 18 03			jr .pastdmark  
c13b ..			.dmark: db "LWR"  
c13e f1			.pastdmark: pop af  
c13f			endm  
# End of macro DMARK
c13f						CALLMONITOR 
c13f cd dd 94			call break_point_state  
c142				endm  
# End of macro CALLMONITOR
c142					endif 
c142			 
c142					FORTH_DSP 
c142 cd 38 9d			call macro_forth_dsp 
c145				endm 
# End of macro FORTH_DSP
c145					 
c145			; TODO check is string type 
c145			 
c145					FORTH_DSP_VALUEHL 
c145 cd 72 9d			call macro_dsp_valuehl 
c148				endm 
# End of macro FORTH_DSP_VALUEHL
c148			; get pointer to string in hl 
c148			 
c148 7e			.tolow:		ld a, (hl) 
c149 fe 00				cp 0 
c14b 28 07				jr z, .tolowdone 
c14d			 
c14d cd 52 90				call to_lower 
c150			 
c150 77					ld (hl), a 
c151 23					inc hl 
c152 18 f4				jr .tolow 
c154			 
c154					 
c154			 
c154			 
c154			; for each char convert to low 
c154					 
c154			.tolowdone: 
c154					NEXTW 
c154 c3 28 9f			jp macro_next 
c157				endm 
# End of macro NEXTW
c157			.TCASE: 
c157				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c157 48				db WORD_SYS_CORE+52             
c158 8d c2			dw .SUBSTR            
c15a 06				db 5 + 1 
c15b .. 00			db "TCASE",0              
c161				endm 
# End of macro CWHEAD
c161			; | TCASE ( s -- s ) Title case string s  | DONE 
c161					if DEBUG_FORTH_WORDS_KEY 
c161						DMARK "TCS" 
c161 f5				push af  
c162 3a 76 c1			ld a, (.dmark)  
c165 32 71 ee			ld (debug_mark),a  
c168 3a 77 c1			ld a, (.dmark+1)  
c16b 32 72 ee			ld (debug_mark+1),a  
c16e 3a 78 c1			ld a, (.dmark+2)  
c171 32 73 ee			ld (debug_mark+2),a  
c174 18 03			jr .pastdmark  
c176 ..			.dmark: db "TCS"  
c179 f1			.pastdmark: pop af  
c17a			endm  
# End of macro DMARK
c17a						CALLMONITOR 
c17a cd dd 94			call break_point_state  
c17d				endm  
# End of macro CALLMONITOR
c17d					endif 
c17d			 
c17d					FORTH_DSP 
c17d cd 38 9d			call macro_forth_dsp 
c180				endm 
# End of macro FORTH_DSP
c180					 
c180			; TODO check is string type 
c180			 
c180					FORTH_DSP_VALUEHL 
c180 cd 72 9d			call macro_dsp_valuehl 
c183				endm 
# End of macro FORTH_DSP_VALUEHL
c183			; get pointer to string in hl 
c183			 
c183					if DEBUG_FORTH_WORDS 
c183						DMARK "TC1" 
c183 f5				push af  
c184 3a 98 c1			ld a, (.dmark)  
c187 32 71 ee			ld (debug_mark),a  
c18a 3a 99 c1			ld a, (.dmark+1)  
c18d 32 72 ee			ld (debug_mark+1),a  
c190 3a 9a c1			ld a, (.dmark+2)  
c193 32 73 ee			ld (debug_mark+2),a  
c196 18 03			jr .pastdmark  
c198 ..			.dmark: db "TC1"  
c19b f1			.pastdmark: pop af  
c19c			endm  
# End of macro DMARK
c19c						CALLMONITOR 
c19c cd dd 94			call break_point_state  
c19f				endm  
# End of macro CALLMONITOR
c19f					endif 
c19f			 
c19f					; first time in turn to upper case first char 
c19f			 
c19f 7e					ld a, (hl) 
c1a0 c3 2a c2				jp .totsiptou 
c1a3			 
c1a3			 
c1a3 7e			.tot:		ld a, (hl) 
c1a4 fe 00				cp 0 
c1a6 ca 6e c2				jp z, .totdone 
c1a9			 
c1a9					if DEBUG_FORTH_WORDS 
c1a9						DMARK "TC2" 
c1a9 f5				push af  
c1aa 3a be c1			ld a, (.dmark)  
c1ad 32 71 ee			ld (debug_mark),a  
c1b0 3a bf c1			ld a, (.dmark+1)  
c1b3 32 72 ee			ld (debug_mark+1),a  
c1b6 3a c0 c1			ld a, (.dmark+2)  
c1b9 32 73 ee			ld (debug_mark+2),a  
c1bc 18 03			jr .pastdmark  
c1be ..			.dmark: db "TC2"  
c1c1 f1			.pastdmark: pop af  
c1c2			endm  
# End of macro DMARK
c1c2						CALLMONITOR 
c1c2 cd dd 94			call break_point_state  
c1c5				endm  
# End of macro CALLMONITOR
c1c5					endif 
c1c5					; check to see if current char is a space 
c1c5			 
c1c5 fe 20				cp ' ' 
c1c7 28 21				jr z, .totsp 
c1c9 cd 52 90				call to_lower 
c1cc					if DEBUG_FORTH_WORDS 
c1cc						DMARK "TC3" 
c1cc f5				push af  
c1cd 3a e1 c1			ld a, (.dmark)  
c1d0 32 71 ee			ld (debug_mark),a  
c1d3 3a e2 c1			ld a, (.dmark+1)  
c1d6 32 72 ee			ld (debug_mark+1),a  
c1d9 3a e3 c1			ld a, (.dmark+2)  
c1dc 32 73 ee			ld (debug_mark+2),a  
c1df 18 03			jr .pastdmark  
c1e1 ..			.dmark: db "TC3"  
c1e4 f1			.pastdmark: pop af  
c1e5			endm  
# End of macro DMARK
c1e5						CALLMONITOR 
c1e5 cd dd 94			call break_point_state  
c1e8				endm  
# End of macro CALLMONITOR
c1e8					endif 
c1e8 18 63				jr .totnxt 
c1ea			 
c1ea			.totsp:         ; on a space, find next char which should be upper 
c1ea			 
c1ea					if DEBUG_FORTH_WORDS 
c1ea						DMARK "TC4" 
c1ea f5				push af  
c1eb 3a ff c1			ld a, (.dmark)  
c1ee 32 71 ee			ld (debug_mark),a  
c1f1 3a 00 c2			ld a, (.dmark+1)  
c1f4 32 72 ee			ld (debug_mark+1),a  
c1f7 3a 01 c2			ld a, (.dmark+2)  
c1fa 32 73 ee			ld (debug_mark+2),a  
c1fd 18 03			jr .pastdmark  
c1ff ..			.dmark: db "TC4"  
c202 f1			.pastdmark: pop af  
c203			endm  
# End of macro DMARK
c203						CALLMONITOR 
c203 cd dd 94			call break_point_state  
c206				endm  
# End of macro CALLMONITOR
c206					endif 
c206					;; 
c206			 
c206 fe 20				cp ' ' 
c208 20 20				jr nz, .totsiptou 
c20a 23					inc hl 
c20b 7e					ld a, (hl) 
c20c					if DEBUG_FORTH_WORDS 
c20c						DMARK "TC5" 
c20c f5				push af  
c20d 3a 21 c2			ld a, (.dmark)  
c210 32 71 ee			ld (debug_mark),a  
c213 3a 22 c2			ld a, (.dmark+1)  
c216 32 72 ee			ld (debug_mark+1),a  
c219 3a 23 c2			ld a, (.dmark+2)  
c21c 32 73 ee			ld (debug_mark+2),a  
c21f 18 03			jr .pastdmark  
c221 ..			.dmark: db "TC5"  
c224 f1			.pastdmark: pop af  
c225			endm  
# End of macro DMARK
c225						CALLMONITOR 
c225 cd dd 94			call break_point_state  
c228				endm  
# End of macro CALLMONITOR
c228					endif 
c228 18 c0				jr .totsp 
c22a fe 00		.totsiptou:    cp 0 
c22c 28 40				jr z, .totdone 
c22e					; not space and not zero term so upper case it 
c22e cd 49 90				call to_upper 
c231			 
c231					if DEBUG_FORTH_WORDS 
c231						DMARK "TC6" 
c231 f5				push af  
c232 3a 46 c2			ld a, (.dmark)  
c235 32 71 ee			ld (debug_mark),a  
c238 3a 47 c2			ld a, (.dmark+1)  
c23b 32 72 ee			ld (debug_mark+1),a  
c23e 3a 48 c2			ld a, (.dmark+2)  
c241 32 73 ee			ld (debug_mark+2),a  
c244 18 03			jr .pastdmark  
c246 ..			.dmark: db "TC6"  
c249 f1			.pastdmark: pop af  
c24a			endm  
# End of macro DMARK
c24a						CALLMONITOR 
c24a cd dd 94			call break_point_state  
c24d				endm  
# End of macro CALLMONITOR
c24d					endif 
c24d			 
c24d			 
c24d			.totnxt: 
c24d			 
c24d 77					ld (hl), a 
c24e 23					inc hl 
c24f					if DEBUG_FORTH_WORDS 
c24f						DMARK "TC7" 
c24f f5				push af  
c250 3a 64 c2			ld a, (.dmark)  
c253 32 71 ee			ld (debug_mark),a  
c256 3a 65 c2			ld a, (.dmark+1)  
c259 32 72 ee			ld (debug_mark+1),a  
c25c 3a 66 c2			ld a, (.dmark+2)  
c25f 32 73 ee			ld (debug_mark+2),a  
c262 18 03			jr .pastdmark  
c264 ..			.dmark: db "TC7"  
c267 f1			.pastdmark: pop af  
c268			endm  
# End of macro DMARK
c268						CALLMONITOR 
c268 cd dd 94			call break_point_state  
c26b				endm  
# End of macro CALLMONITOR
c26b					endif 
c26b c3 a3 c1				jp .tot 
c26e			 
c26e					 
c26e			 
c26e			 
c26e			; for each char convert to low 
c26e					 
c26e			.totdone: 
c26e					if DEBUG_FORTH_WORDS 
c26e						DMARK "TCd" 
c26e f5				push af  
c26f 3a 83 c2			ld a, (.dmark)  
c272 32 71 ee			ld (debug_mark),a  
c275 3a 84 c2			ld a, (.dmark+1)  
c278 32 72 ee			ld (debug_mark+1),a  
c27b 3a 85 c2			ld a, (.dmark+2)  
c27e 32 73 ee			ld (debug_mark+2),a  
c281 18 03			jr .pastdmark  
c283 ..			.dmark: db "TCd"  
c286 f1			.pastdmark: pop af  
c287			endm  
# End of macro DMARK
c287						CALLMONITOR 
c287 cd dd 94			call break_point_state  
c28a				endm  
# End of macro CALLMONITOR
c28a					endif 
c28a					NEXTW 
c28a c3 28 9f			jp macro_next 
c28d				endm 
# End of macro NEXTW
c28d			 
c28d			.SUBSTR: 
c28d				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c28d 48				db WORD_SYS_CORE+52             
c28e eb c2			dw .LEFT            
c290 07				db 6 + 1 
c291 .. 00			db "SUBSTR",0              
c298				endm 
# End of macro CWHEAD
c298			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c298			 
c298					if DEBUG_FORTH_WORDS_KEY 
c298						DMARK "SST" 
c298 f5				push af  
c299 3a ad c2			ld a, (.dmark)  
c29c 32 71 ee			ld (debug_mark),a  
c29f 3a ae c2			ld a, (.dmark+1)  
c2a2 32 72 ee			ld (debug_mark+1),a  
c2a5 3a af c2			ld a, (.dmark+2)  
c2a8 32 73 ee			ld (debug_mark+2),a  
c2ab 18 03			jr .pastdmark  
c2ad ..			.dmark: db "SST"  
c2b0 f1			.pastdmark: pop af  
c2b1			endm  
# End of macro DMARK
c2b1						CALLMONITOR 
c2b1 cd dd 94			call break_point_state  
c2b4				endm  
# End of macro CALLMONITOR
c2b4					endif 
c2b4			; TODO check string type 
c2b4					FORTH_DSP_VALUEHL 
c2b4 cd 72 9d			call macro_dsp_valuehl 
c2b7				endm 
# End of macro FORTH_DSP_VALUEHL
c2b7			 
c2b7 e5					push hl      ; string length 
c2b8			 
c2b8					FORTH_DSP_POP 
c2b8 cd 2a 9e			call macro_forth_dsp_pop 
c2bb				endm 
# End of macro FORTH_DSP_POP
c2bb			 
c2bb					FORTH_DSP_VALUEHL 
c2bb cd 72 9d			call macro_dsp_valuehl 
c2be				endm 
# End of macro FORTH_DSP_VALUEHL
c2be			 
c2be e5					push hl     ; start char 
c2bf			 
c2bf					FORTH_DSP_POP 
c2bf cd 2a 9e			call macro_forth_dsp_pop 
c2c2				endm 
# End of macro FORTH_DSP_POP
c2c2			 
c2c2			 
c2c2					FORTH_DSP_VALUE 
c2c2 cd 5b 9d			call macro_forth_dsp_value 
c2c5				endm 
# End of macro FORTH_DSP_VALUE
c2c5			 
c2c5 d1					pop de    ; get start post offset 
c2c6			 
c2c6 19					add hl, de    ; starting offset 
c2c7			 
c2c7 c1					pop bc 
c2c8 c5					push bc      ; grab size of string 
c2c9			 
c2c9 e5					push hl    ; save string start  
c2ca			 
c2ca 26 00				ld h, 0 
c2cc 69					ld l, c 
c2cd 23					inc hl 
c2ce 23					inc hl 
c2cf			 
c2cf cd a3 91				call malloc 
c2d2				if DEBUG_FORTH_MALLOC_GUARD 
c2d2 cc 33 cc				call z,malloc_error 
c2d5				endif 
c2d5			 
c2d5 eb					ex de, hl      ; save malloc area for string copy 
c2d6 e1					pop hl    ; get back source 
c2d7 c1					pop bc    ; get length of string back 
c2d8			 
c2d8 d5					push de    ; save malloc area for after we push 
c2d9 ed b0				ldir     ; copy substr 
c2db			 
c2db			 
c2db eb					ex de, hl 
c2dc 3e 00				ld a, 0 
c2de 77					ld (hl), a   ; term substr 
c2df			 
c2df					 
c2df e1					pop hl    ; get malloc so we can push it 
c2e0 e5					push hl   ; save so we can free it afterwards 
c2e1			 
c2e1 cd e9 9b				call forth_push_str 
c2e4			 
c2e4 e1					pop hl 
c2e5 cd 6d 92				call free 
c2e8			 
c2e8					 
c2e8					 
c2e8			 
c2e8			 
c2e8					NEXTW 
c2e8 c3 28 9f			jp macro_next 
c2eb				endm 
# End of macro NEXTW
c2eb			 
c2eb			.LEFT: 
c2eb				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c2eb 48				db WORD_SYS_CORE+52             
c2ec 13 c3			dw .RIGHT            
c2ee 05				db 4 + 1 
c2ef .. 00			db "LEFT",0              
c2f4				endm 
# End of macro CWHEAD
c2f4			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c2f4					if DEBUG_FORTH_WORDS_KEY 
c2f4						DMARK "LEF" 
c2f4 f5				push af  
c2f5 3a 09 c3			ld a, (.dmark)  
c2f8 32 71 ee			ld (debug_mark),a  
c2fb 3a 0a c3			ld a, (.dmark+1)  
c2fe 32 72 ee			ld (debug_mark+1),a  
c301 3a 0b c3			ld a, (.dmark+2)  
c304 32 73 ee			ld (debug_mark+2),a  
c307 18 03			jr .pastdmark  
c309 ..			.dmark: db "LEF"  
c30c f1			.pastdmark: pop af  
c30d			endm  
# End of macro DMARK
c30d						CALLMONITOR 
c30d cd dd 94			call break_point_state  
c310				endm  
# End of macro CALLMONITOR
c310					endif 
c310			 
c310					NEXTW 
c310 c3 28 9f			jp macro_next 
c313				endm 
# End of macro NEXTW
c313			.RIGHT: 
c313				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c313 48				db WORD_SYS_CORE+52             
c314 3c c3			dw .STR2NUM            
c316 06				db 5 + 1 
c317 .. 00			db "RIGHT",0              
c31d				endm 
# End of macro CWHEAD
c31d			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c31d					if DEBUG_FORTH_WORDS_KEY 
c31d						DMARK "RIG" 
c31d f5				push af  
c31e 3a 32 c3			ld a, (.dmark)  
c321 32 71 ee			ld (debug_mark),a  
c324 3a 33 c3			ld a, (.dmark+1)  
c327 32 72 ee			ld (debug_mark+1),a  
c32a 3a 34 c3			ld a, (.dmark+2)  
c32d 32 73 ee			ld (debug_mark+2),a  
c330 18 03			jr .pastdmark  
c332 ..			.dmark: db "RIG"  
c335 f1			.pastdmark: pop af  
c336			endm  
# End of macro DMARK
c336						CALLMONITOR 
c336 cd dd 94			call break_point_state  
c339				endm  
# End of macro CALLMONITOR
c339					endif 
c339			 
c339					NEXTW 
c339 c3 28 9f			jp macro_next 
c33c				endm 
# End of macro NEXTW
c33c			 
c33c			 
c33c			.STR2NUM: 
c33c				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c33c 48				db WORD_SYS_CORE+52             
c33d c8 c3			dw .NUM2STR            
c33f 08				db 7 + 1 
c340 .. 00			db "STR2NUM",0              
c348				endm 
# End of macro CWHEAD
c348			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c348			 
c348			 
c348			; TODO STR type check to do 
c348					if DEBUG_FORTH_WORDS_KEY 
c348						DMARK "S2N" 
c348 f5				push af  
c349 3a 5d c3			ld a, (.dmark)  
c34c 32 71 ee			ld (debug_mark),a  
c34f 3a 5e c3			ld a, (.dmark+1)  
c352 32 72 ee			ld (debug_mark+1),a  
c355 3a 5f c3			ld a, (.dmark+2)  
c358 32 73 ee			ld (debug_mark+2),a  
c35b 18 03			jr .pastdmark  
c35d ..			.dmark: db "S2N"  
c360 f1			.pastdmark: pop af  
c361			endm  
# End of macro DMARK
c361						CALLMONITOR 
c361 cd dd 94			call break_point_state  
c364				endm  
# End of macro CALLMONITOR
c364					endif 
c364			 
c364					;FORTH_DSP 
c364					FORTH_DSP_VALUE 
c364 cd 5b 9d			call macro_forth_dsp_value 
c367				endm 
# End of macro FORTH_DSP_VALUE
c367					;inc hl 
c367			 
c367 eb					ex de, hl 
c368					if DEBUG_FORTH_WORDS 
c368						DMARK "S2a" 
c368 f5				push af  
c369 3a 7d c3			ld a, (.dmark)  
c36c 32 71 ee			ld (debug_mark),a  
c36f 3a 7e c3			ld a, (.dmark+1)  
c372 32 72 ee			ld (debug_mark+1),a  
c375 3a 7f c3			ld a, (.dmark+2)  
c378 32 73 ee			ld (debug_mark+2),a  
c37b 18 03			jr .pastdmark  
c37d ..			.dmark: db "S2a"  
c380 f1			.pastdmark: pop af  
c381			endm  
# End of macro DMARK
c381						CALLMONITOR 
c381 cd dd 94			call break_point_state  
c384				endm  
# End of macro CALLMONITOR
c384					endif 
c384 cd d1 90				call string_to_uint16 
c387			 
c387					if DEBUG_FORTH_WORDS 
c387						DMARK "S2b" 
c387 f5				push af  
c388 3a 9c c3			ld a, (.dmark)  
c38b 32 71 ee			ld (debug_mark),a  
c38e 3a 9d c3			ld a, (.dmark+1)  
c391 32 72 ee			ld (debug_mark+1),a  
c394 3a 9e c3			ld a, (.dmark+2)  
c397 32 73 ee			ld (debug_mark+2),a  
c39a 18 03			jr .pastdmark  
c39c ..			.dmark: db "S2b"  
c39f f1			.pastdmark: pop af  
c3a0			endm  
# End of macro DMARK
c3a0						CALLMONITOR 
c3a0 cd dd 94			call break_point_state  
c3a3				endm  
# End of macro CALLMONITOR
c3a3					endif 
c3a3			;		push hl 
c3a3					FORTH_DSP_POP 
c3a3 cd 2a 9e			call macro_forth_dsp_pop 
c3a6				endm 
# End of macro FORTH_DSP_POP
c3a6			;		pop hl 
c3a6					 
c3a6					if DEBUG_FORTH_WORDS 
c3a6						DMARK "S2b" 
c3a6 f5				push af  
c3a7 3a bb c3			ld a, (.dmark)  
c3aa 32 71 ee			ld (debug_mark),a  
c3ad 3a bc c3			ld a, (.dmark+1)  
c3b0 32 72 ee			ld (debug_mark+1),a  
c3b3 3a bd c3			ld a, (.dmark+2)  
c3b6 32 73 ee			ld (debug_mark+2),a  
c3b9 18 03			jr .pastdmark  
c3bb ..			.dmark: db "S2b"  
c3be f1			.pastdmark: pop af  
c3bf			endm  
# End of macro DMARK
c3bf						CALLMONITOR 
c3bf cd dd 94			call break_point_state  
c3c2				endm  
# End of macro CALLMONITOR
c3c2					endif 
c3c2 cd 7b 9b				call forth_push_numhl	 
c3c5			 
c3c5				 
c3c5				       NEXTW 
c3c5 c3 28 9f			jp macro_next 
c3c8				endm 
# End of macro NEXTW
c3c8			.NUM2STR: 
c3c8				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c3c8 48				db WORD_SYS_CORE+52             
c3c9 d7 c3			dw .CONCAT            
c3cb 08				db 7 + 1 
c3cc .. 00			db "NUM2STR",0              
c3d4				endm 
# End of macro CWHEAD
c3d4			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c3d4			 
c3d4			;		; malloc a string to target 
c3d4			;		ld hl, 10     ; TODO max string size should be fine 
c3d4			;		call malloc 
c3d4			;		push hl    ; save malloc location 
c3d4			; 
c3d4			; 
c3d4			;; TODO check int type 
c3d4			;		FORTH_DSP_VALUEHL 
c3d4			;		ld a, l 
c3d4			;		call DispAToASCII   
c3d4			;;TODO need to chage above call to dump into string 
c3d4			; 
c3d4			; 
c3d4			 
c3d4				       NEXTW 
c3d4 c3 28 9f			jp macro_next 
c3d7				endm 
# End of macro NEXTW
c3d7			 
c3d7			.CONCAT: 
c3d7				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c3d7 48				db WORD_SYS_CORE+52             
c3d8 8a c4			dw .FIND            
c3da 07				db 6 + 1 
c3db .. 00			db "CONCAT",0              
c3e2				endm 
# End of macro CWHEAD
c3e2			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c3e2			 
c3e2			; TODO check string type 
c3e2			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c3e2			 
c3e2					if DEBUG_FORTH_WORDS_KEY 
c3e2						DMARK "CON" 
c3e2 f5				push af  
c3e3 3a f7 c3			ld a, (.dmark)  
c3e6 32 71 ee			ld (debug_mark),a  
c3e9 3a f8 c3			ld a, (.dmark+1)  
c3ec 32 72 ee			ld (debug_mark+1),a  
c3ef 3a f9 c3			ld a, (.dmark+2)  
c3f2 32 73 ee			ld (debug_mark+2),a  
c3f5 18 03			jr .pastdmark  
c3f7 ..			.dmark: db "CON"  
c3fa f1			.pastdmark: pop af  
c3fb			endm  
# End of macro DMARK
c3fb						CALLMONITOR 
c3fb cd dd 94			call break_point_state  
c3fe				endm  
# End of macro CALLMONITOR
c3fe					endif 
c3fe			 
c3fe			 
c3fe					FORTH_DSP_VALUE 
c3fe cd 5b 9d			call macro_forth_dsp_value 
c401				endm 
# End of macro FORTH_DSP_VALUE
c401 e5					push hl   ; s2 
c402			 
c402					FORTH_DSP_POP 
c402 cd 2a 9e			call macro_forth_dsp_pop 
c405				endm 
# End of macro FORTH_DSP_POP
c405			 
c405					FORTH_DSP_VALUE 
c405 cd 5b 9d			call macro_forth_dsp_value 
c408				endm 
# End of macro FORTH_DSP_VALUE
c408			 
c408 e5					push hl   ; s1 
c409			 
c409					FORTH_DSP_POP 
c409 cd 2a 9e			call macro_forth_dsp_pop 
c40c				endm 
# End of macro FORTH_DSP_POP
c40c					 
c40c			 
c40c					; copy s1 
c40c			 
c40c				 
c40c					; save ptr 
c40c e1					pop hl  
c40d e5					push hl 
c40e 3e 00				ld a, 0 
c410 cd 45 91				call strlent 
c413					;inc hl    ; zer0 
c413 06 00				ld b, 0 
c415 4d					ld c, l 
c416 e1					pop hl		 
c417 11 c7 e2				ld de, scratch	 
c41a					if DEBUG_FORTH_WORDS 
c41a						DMARK "CO1" 
c41a f5				push af  
c41b 3a 2f c4			ld a, (.dmark)  
c41e 32 71 ee			ld (debug_mark),a  
c421 3a 30 c4			ld a, (.dmark+1)  
c424 32 72 ee			ld (debug_mark+1),a  
c427 3a 31 c4			ld a, (.dmark+2)  
c42a 32 73 ee			ld (debug_mark+2),a  
c42d 18 03			jr .pastdmark  
c42f ..			.dmark: db "CO1"  
c432 f1			.pastdmark: pop af  
c433			endm  
# End of macro DMARK
c433						CALLMONITOR 
c433 cd dd 94			call break_point_state  
c436				endm  
# End of macro CALLMONITOR
c436					endif 
c436 ed b0				ldir 
c438			 
c438 e1					pop hl 
c439 e5					push hl 
c43a d5					push de 
c43b			 
c43b			 
c43b 3e 00				ld a, 0 
c43d cd 45 91				call strlent 
c440 23					inc hl    ; zer0 
c441 23					inc hl 
c442 06 00				ld b, 0 
c444 4d					ld c, l 
c445 d1					pop de 
c446 e1					pop hl		 
c447					if DEBUG_FORTH_WORDS 
c447						DMARK "CO2" 
c447 f5				push af  
c448 3a 5c c4			ld a, (.dmark)  
c44b 32 71 ee			ld (debug_mark),a  
c44e 3a 5d c4			ld a, (.dmark+1)  
c451 32 72 ee			ld (debug_mark+1),a  
c454 3a 5e c4			ld a, (.dmark+2)  
c457 32 73 ee			ld (debug_mark+2),a  
c45a 18 03			jr .pastdmark  
c45c ..			.dmark: db "CO2"  
c45f f1			.pastdmark: pop af  
c460			endm  
# End of macro DMARK
c460						CALLMONITOR 
c460 cd dd 94			call break_point_state  
c463				endm  
# End of macro CALLMONITOR
c463					endif 
c463 ed b0				ldir 
c465			 
c465			 
c465			 
c465 21 c7 e2				ld hl, scratch 
c468					if DEBUG_FORTH_WORDS 
c468						DMARK "CO5" 
c468 f5				push af  
c469 3a 7d c4			ld a, (.dmark)  
c46c 32 71 ee			ld (debug_mark),a  
c46f 3a 7e c4			ld a, (.dmark+1)  
c472 32 72 ee			ld (debug_mark+1),a  
c475 3a 7f c4			ld a, (.dmark+2)  
c478 32 73 ee			ld (debug_mark+2),a  
c47b 18 03			jr .pastdmark  
c47d ..			.dmark: db "CO5"  
c480 f1			.pastdmark: pop af  
c481			endm  
# End of macro DMARK
c481						CALLMONITOR 
c481 cd dd 94			call break_point_state  
c484				endm  
# End of macro CALLMONITOR
c484					endif 
c484			 
c484 cd e9 9b				call forth_push_str 
c487			 
c487			 
c487			 
c487			 
c487				       NEXTW 
c487 c3 28 9f			jp macro_next 
c48a				endm 
# End of macro NEXTW
c48a			 
c48a			 
c48a			.FIND: 
c48a				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c48a 4b				db WORD_SYS_CORE+55             
c48b 48 c5			dw .LEN            
c48d 05				db 4 + 1 
c48e .. 00			db "FIND",0              
c493				endm 
# End of macro CWHEAD
c493			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c493			 
c493					if DEBUG_FORTH_WORDS_KEY 
c493						DMARK "FND" 
c493 f5				push af  
c494 3a a8 c4			ld a, (.dmark)  
c497 32 71 ee			ld (debug_mark),a  
c49a 3a a9 c4			ld a, (.dmark+1)  
c49d 32 72 ee			ld (debug_mark+1),a  
c4a0 3a aa c4			ld a, (.dmark+2)  
c4a3 32 73 ee			ld (debug_mark+2),a  
c4a6 18 03			jr .pastdmark  
c4a8 ..			.dmark: db "FND"  
c4ab f1			.pastdmark: pop af  
c4ac			endm  
# End of macro DMARK
c4ac						CALLMONITOR 
c4ac cd dd 94			call break_point_state  
c4af				endm  
# End of macro CALLMONITOR
c4af					endif 
c4af			 
c4af			; TODO check string type 
c4af					FORTH_DSP_VALUE 
c4af cd 5b 9d			call macro_forth_dsp_value 
c4b2				endm 
# End of macro FORTH_DSP_VALUE
c4b2			 
c4b2 e5					push hl    
c4b3 7e					ld a,(hl)    ; char to find   
c4b4			; TODO change char to substr 
c4b4			 
c4b4 f5					push af 
c4b5					 
c4b5			 
c4b5			 
c4b5					if DEBUG_FORTH_WORDS 
c4b5						DMARK "FN1" 
c4b5 f5				push af  
c4b6 3a ca c4			ld a, (.dmark)  
c4b9 32 71 ee			ld (debug_mark),a  
c4bc 3a cb c4			ld a, (.dmark+1)  
c4bf 32 72 ee			ld (debug_mark+1),a  
c4c2 3a cc c4			ld a, (.dmark+2)  
c4c5 32 73 ee			ld (debug_mark+2),a  
c4c8 18 03			jr .pastdmark  
c4ca ..			.dmark: db "FN1"  
c4cd f1			.pastdmark: pop af  
c4ce			endm  
# End of macro DMARK
c4ce						CALLMONITOR 
c4ce cd dd 94			call break_point_state  
c4d1				endm  
# End of macro CALLMONITOR
c4d1					endif 
c4d1			 
c4d1					FORTH_DSP_POP 
c4d1 cd 2a 9e			call macro_forth_dsp_pop 
c4d4				endm 
# End of macro FORTH_DSP_POP
c4d4			 
c4d4					; string to search 
c4d4			 
c4d4					FORTH_DSP_VALUE 
c4d4 cd 5b 9d			call macro_forth_dsp_value 
c4d7				endm 
# End of macro FORTH_DSP_VALUE
c4d7			 
c4d7 d1					pop de  ; d is char to find  
c4d8			 
c4d8					if DEBUG_FORTH_WORDS 
c4d8						DMARK "FN2" 
c4d8 f5				push af  
c4d9 3a ed c4			ld a, (.dmark)  
c4dc 32 71 ee			ld (debug_mark),a  
c4df 3a ee c4			ld a, (.dmark+1)  
c4e2 32 72 ee			ld (debug_mark+1),a  
c4e5 3a ef c4			ld a, (.dmark+2)  
c4e8 32 73 ee			ld (debug_mark+2),a  
c4eb 18 03			jr .pastdmark  
c4ed ..			.dmark: db "FN2"  
c4f0 f1			.pastdmark: pop af  
c4f1			endm  
# End of macro DMARK
c4f1						CALLMONITOR 
c4f1 cd dd 94			call break_point_state  
c4f4				endm  
# End of macro CALLMONITOR
c4f4					endif 
c4f4					 
c4f4 01 00 00				ld bc, 0 
c4f7 7e			.findchar:      ld a,(hl) 
c4f8 fe 00				cp 0   		 
c4fa 28 27				jr z, .finddone     
c4fc ba					cp d 
c4fd 28 20				jr z, .foundchar 
c4ff 03					inc bc 
c500 23					inc hl 
c501					if DEBUG_FORTH_WORDS 
c501						DMARK "FN3" 
c501 f5				push af  
c502 3a 16 c5			ld a, (.dmark)  
c505 32 71 ee			ld (debug_mark),a  
c508 3a 17 c5			ld a, (.dmark+1)  
c50b 32 72 ee			ld (debug_mark+1),a  
c50e 3a 18 c5			ld a, (.dmark+2)  
c511 32 73 ee			ld (debug_mark+2),a  
c514 18 03			jr .pastdmark  
c516 ..			.dmark: db "FN3"  
c519 f1			.pastdmark: pop af  
c51a			endm  
# End of macro DMARK
c51a						CALLMONITOR 
c51a cd dd 94			call break_point_state  
c51d				endm  
# End of macro CALLMONITOR
c51d					endif 
c51d 18 d8				jr .findchar 
c51f			 
c51f			 
c51f c5			.foundchar:	push bc 
c520 e1					pop hl 
c521 18 03				jr .findexit 
c523			 
c523			 
c523							 
c523			 
c523			.finddone:     ; got to end of string with no find 
c523 21 00 00				ld hl, 0 
c526			.findexit: 
c526			 
c526					if DEBUG_FORTH_WORDS 
c526						DMARK "FNd" 
c526 f5				push af  
c527 3a 3b c5			ld a, (.dmark)  
c52a 32 71 ee			ld (debug_mark),a  
c52d 3a 3c c5			ld a, (.dmark+1)  
c530 32 72 ee			ld (debug_mark+1),a  
c533 3a 3d c5			ld a, (.dmark+2)  
c536 32 73 ee			ld (debug_mark+2),a  
c539 18 03			jr .pastdmark  
c53b ..			.dmark: db "FNd"  
c53e f1			.pastdmark: pop af  
c53f			endm  
# End of macro DMARK
c53f						CALLMONITOR 
c53f cd dd 94			call break_point_state  
c542				endm  
# End of macro CALLMONITOR
c542					endif 
c542 cd 7b 9b			call forth_push_numhl 
c545			 
c545				       NEXTW 
c545 c3 28 9f			jp macro_next 
c548				endm 
# End of macro NEXTW
c548			 
c548			.LEN: 
c548				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c548 4c				db WORD_SYS_CORE+56             
c549 b2 c5			dw .ASC            
c54b 06				db 5 + 1 
c54c .. 00			db "COUNT",0              
c552				endm 
# End of macro CWHEAD
c552			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c552			 
c552					if DEBUG_FORTH_WORDS_KEY 
c552						DMARK "CNT" 
c552 f5				push af  
c553 3a 67 c5			ld a, (.dmark)  
c556 32 71 ee			ld (debug_mark),a  
c559 3a 68 c5			ld a, (.dmark+1)  
c55c 32 72 ee			ld (debug_mark+1),a  
c55f 3a 69 c5			ld a, (.dmark+2)  
c562 32 73 ee			ld (debug_mark+2),a  
c565 18 03			jr .pastdmark  
c567 ..			.dmark: db "CNT"  
c56a f1			.pastdmark: pop af  
c56b			endm  
# End of macro DMARK
c56b						CALLMONITOR 
c56b cd dd 94			call break_point_state  
c56e				endm  
# End of macro CALLMONITOR
c56e					endif 
c56e			; TODO check string type 
c56e					FORTH_DSP_VALUE 
c56e cd 5b 9d			call macro_forth_dsp_value 
c571				endm 
# End of macro FORTH_DSP_VALUE
c571			 
c571			 
c571					if DEBUG_FORTH_WORDS 
c571						DMARK "CN?" 
c571 f5				push af  
c572 3a 86 c5			ld a, (.dmark)  
c575 32 71 ee			ld (debug_mark),a  
c578 3a 87 c5			ld a, (.dmark+1)  
c57b 32 72 ee			ld (debug_mark+1),a  
c57e 3a 88 c5			ld a, (.dmark+2)  
c581 32 73 ee			ld (debug_mark+2),a  
c584 18 03			jr .pastdmark  
c586 ..			.dmark: db "CN?"  
c589 f1			.pastdmark: pop af  
c58a			endm  
# End of macro DMARK
c58a						CALLMONITOR 
c58a cd dd 94			call break_point_state  
c58d				endm  
# End of macro CALLMONITOR
c58d					endif 
c58d cd 3a 91				call strlenz 
c590					if DEBUG_FORTH_WORDS 
c590						DMARK "CNl" 
c590 f5				push af  
c591 3a a5 c5			ld a, (.dmark)  
c594 32 71 ee			ld (debug_mark),a  
c597 3a a6 c5			ld a, (.dmark+1)  
c59a 32 72 ee			ld (debug_mark+1),a  
c59d 3a a7 c5			ld a, (.dmark+2)  
c5a0 32 73 ee			ld (debug_mark+2),a  
c5a3 18 03			jr .pastdmark  
c5a5 ..			.dmark: db "CNl"  
c5a8 f1			.pastdmark: pop af  
c5a9			endm  
# End of macro DMARK
c5a9						CALLMONITOR 
c5a9 cd dd 94			call break_point_state  
c5ac				endm  
# End of macro CALLMONITOR
c5ac					endif 
c5ac			 
c5ac cd 7b 9b				call forth_push_numhl 
c5af			 
c5af			 
c5af			 
c5af				       NEXTW 
c5af c3 28 9f			jp macro_next 
c5b2				endm 
# End of macro NEXTW
c5b2			.ASC: 
c5b2				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c5b2 4d				db WORD_SYS_CORE+57             
c5b3 20 c6			dw .CHR            
c5b5 04				db 3 + 1 
c5b6 .. 00			db "ASC",0              
c5ba				endm 
# End of macro CWHEAD
c5ba			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c5ba					if DEBUG_FORTH_WORDS_KEY 
c5ba						DMARK "ASC" 
c5ba f5				push af  
c5bb 3a cf c5			ld a, (.dmark)  
c5be 32 71 ee			ld (debug_mark),a  
c5c1 3a d0 c5			ld a, (.dmark+1)  
c5c4 32 72 ee			ld (debug_mark+1),a  
c5c7 3a d1 c5			ld a, (.dmark+2)  
c5ca 32 73 ee			ld (debug_mark+2),a  
c5cd 18 03			jr .pastdmark  
c5cf ..			.dmark: db "ASC"  
c5d2 f1			.pastdmark: pop af  
c5d3			endm  
# End of macro DMARK
c5d3						CALLMONITOR 
c5d3 cd dd 94			call break_point_state  
c5d6				endm  
# End of macro CALLMONITOR
c5d6					endif 
c5d6					FORTH_DSP_VALUE 
c5d6 cd 5b 9d			call macro_forth_dsp_value 
c5d9				endm 
# End of macro FORTH_DSP_VALUE
c5d9					;v5 FORTH_DSP_VALUE 
c5d9			;		inc hl      ; now at start of numeric as string 
c5d9			 
c5d9 e5					push hl 
c5da			 
c5da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5da cd 2a 9e			call macro_forth_dsp_pop 
c5dd				endm 
# End of macro FORTH_DSP_POP
c5dd			 
c5dd e1					pop hl 
c5de			 
c5de					if DEBUG_FORTH_WORDS 
c5de						DMARK "AS1" 
c5de f5				push af  
c5df 3a f3 c5			ld a, (.dmark)  
c5e2 32 71 ee			ld (debug_mark),a  
c5e5 3a f4 c5			ld a, (.dmark+1)  
c5e8 32 72 ee			ld (debug_mark+1),a  
c5eb 3a f5 c5			ld a, (.dmark+2)  
c5ee 32 73 ee			ld (debug_mark+2),a  
c5f1 18 03			jr .pastdmark  
c5f3 ..			.dmark: db "AS1"  
c5f6 f1			.pastdmark: pop af  
c5f7			endm  
# End of macro DMARK
c5f7						CALLMONITOR 
c5f7 cd dd 94			call break_point_state  
c5fa				endm  
# End of macro CALLMONITOR
c5fa					endif 
c5fa					; push the content of a onto the stack as a value 
c5fa			 
c5fa 7e					ld a,(hl)   ; get char 
c5fb 26 00				ld h,0 
c5fd 6f					ld l,a 
c5fe					if DEBUG_FORTH_WORDS 
c5fe						DMARK "AS2" 
c5fe f5				push af  
c5ff 3a 13 c6			ld a, (.dmark)  
c602 32 71 ee			ld (debug_mark),a  
c605 3a 14 c6			ld a, (.dmark+1)  
c608 32 72 ee			ld (debug_mark+1),a  
c60b 3a 15 c6			ld a, (.dmark+2)  
c60e 32 73 ee			ld (debug_mark+2),a  
c611 18 03			jr .pastdmark  
c613 ..			.dmark: db "AS2"  
c616 f1			.pastdmark: pop af  
c617			endm  
# End of macro DMARK
c617						CALLMONITOR 
c617 cd dd 94			call break_point_state  
c61a				endm  
# End of macro CALLMONITOR
c61a					endif 
c61a cd 7b 9b				call forth_push_numhl 
c61d			 
c61d				       NEXTW 
c61d c3 28 9f			jp macro_next 
c620				endm 
# End of macro NEXTW
c620			 
c620			.CHR: 
c620				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c620 4d				db WORD_SYS_CORE+57             
c621 5c c6			dw .ENDSTR            
c623 04				db 3 + 1 
c624 .. 00			db "CHR",0              
c628				endm 
# End of macro CWHEAD
c628			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c628					if DEBUG_FORTH_WORDS_KEY 
c628						DMARK "CHR" 
c628 f5				push af  
c629 3a 3d c6			ld a, (.dmark)  
c62c 32 71 ee			ld (debug_mark),a  
c62f 3a 3e c6			ld a, (.dmark+1)  
c632 32 72 ee			ld (debug_mark+1),a  
c635 3a 3f c6			ld a, (.dmark+2)  
c638 32 73 ee			ld (debug_mark+2),a  
c63b 18 03			jr .pastdmark  
c63d ..			.dmark: db "CHR"  
c640 f1			.pastdmark: pop af  
c641			endm  
# End of macro DMARK
c641						CALLMONITOR 
c641 cd dd 94			call break_point_state  
c644				endm  
# End of macro CALLMONITOR
c644					endif 
c644					FORTH_DSP_VALUEHL 
c644 cd 72 9d			call macro_dsp_valuehl 
c647				endm 
# End of macro FORTH_DSP_VALUEHL
c647			 
c647					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c647 cd 2a 9e			call macro_forth_dsp_pop 
c64a				endm 
# End of macro FORTH_DSP_POP
c64a			 
c64a					; save asci byte as a zero term string and push string 
c64a			 
c64a 7d					ld a,l 
c64b 32 c7 e2				ld (scratch), a 
c64e			 
c64e 3e 00				ld a, 0 
c650 32 c8 e2				ld (scratch+1), a 
c653			 
c653 21 c7 e2				ld hl, scratch 
c656 cd e9 9b				call forth_push_str 
c659			 
c659			 
c659				       NEXTW 
c659 c3 28 9f			jp macro_next 
c65c				endm 
# End of macro NEXTW
c65c			 
c65c			 
c65c			 
c65c			 
c65c			.ENDSTR: 
c65c			; eof 
c65c			 
# End of file forth_words_str.asm
c65c			include "forth_words_key.asm" 
c65c			 
c65c			; | ## Keyboard Words 
c65c			 
c65c			.KEY: 
c65c				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c65c 3e				db WORD_SYS_CORE+42             
c65d 8c c6			dw .WAITK            
c65f 04				db 3 + 1 
c660 .. 00			db "KEY",0              
c664				endm 
# End of macro CWHEAD
c664			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c664			 
c664					if DEBUG_FORTH_WORDS_KEY 
c664						DMARK "KEY" 
c664 f5				push af  
c665 3a 79 c6			ld a, (.dmark)  
c668 32 71 ee			ld (debug_mark),a  
c66b 3a 7a c6			ld a, (.dmark+1)  
c66e 32 72 ee			ld (debug_mark+1),a  
c671 3a 7b c6			ld a, (.dmark+2)  
c674 32 73 ee			ld (debug_mark+2),a  
c677 18 03			jr .pastdmark  
c679 ..			.dmark: db "KEY"  
c67c f1			.pastdmark: pop af  
c67d			endm  
# End of macro DMARK
c67d						CALLMONITOR 
c67d cd dd 94			call break_point_state  
c680				endm  
# End of macro CALLMONITOR
c680					endif 
c680			; TODO currently waits 
c680 cd 6e e3				call cin 
c683					;call cin_wait 
c683 6f					ld l, a 
c684 26 00				ld h, 0 
c686 cd 7b 9b				call forth_push_numhl 
c689					NEXTW 
c689 c3 28 9f			jp macro_next 
c68c				endm 
# End of macro NEXTW
c68c			.WAITK: 
c68c				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c68c 3f				db WORD_SYS_CORE+43             
c68d be c6			dw .ACCEPT            
c68f 06				db 5 + 1 
c690 .. 00			db "WAITK",0              
c696				endm 
# End of macro CWHEAD
c696			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c696					if DEBUG_FORTH_WORDS_KEY 
c696						DMARK "WAI" 
c696 f5				push af  
c697 3a ab c6			ld a, (.dmark)  
c69a 32 71 ee			ld (debug_mark),a  
c69d 3a ac c6			ld a, (.dmark+1)  
c6a0 32 72 ee			ld (debug_mark+1),a  
c6a3 3a ad c6			ld a, (.dmark+2)  
c6a6 32 73 ee			ld (debug_mark+2),a  
c6a9 18 03			jr .pastdmark  
c6ab ..			.dmark: db "WAI"  
c6ae f1			.pastdmark: pop af  
c6af			endm  
# End of macro DMARK
c6af						CALLMONITOR 
c6af cd dd 94			call break_point_state  
c6b2				endm  
# End of macro CALLMONITOR
c6b2					endif 
c6b2 cd 68 e3				call cin_wait 
c6b5 6f					ld l, a 
c6b6 26 00				ld h, 0 
c6b8 cd 7b 9b				call forth_push_numhl 
c6bb					NEXTW 
c6bb c3 28 9f			jp macro_next 
c6be				endm 
# End of macro NEXTW
c6be			.ACCEPT: 
c6be				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c6be 40				db WORD_SYS_CORE+44             
c6bf 1c c7			dw .EDIT            
c6c1 07				db 6 + 1 
c6c2 .. 00			db "ACCEPT",0              
c6c9				endm 
# End of macro CWHEAD
c6c9			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c6c9					; TODO crashes on push 
c6c9					if DEBUG_FORTH_WORDS_KEY 
c6c9						DMARK "ACC" 
c6c9 f5				push af  
c6ca 3a de c6			ld a, (.dmark)  
c6cd 32 71 ee			ld (debug_mark),a  
c6d0 3a df c6			ld a, (.dmark+1)  
c6d3 32 72 ee			ld (debug_mark+1),a  
c6d6 3a e0 c6			ld a, (.dmark+2)  
c6d9 32 73 ee			ld (debug_mark+2),a  
c6dc 18 03			jr .pastdmark  
c6de ..			.dmark: db "ACC"  
c6e1 f1			.pastdmark: pop af  
c6e2			endm  
# End of macro DMARK
c6e2						CALLMONITOR 
c6e2 cd dd 94			call break_point_state  
c6e5				endm  
# End of macro CALLMONITOR
c6e5					endif 
c6e5 21 c5 e4				ld hl, os_input 
c6e8 3e 00				ld a, 0 
c6ea 77					ld (hl),a 
c6eb 3a 64 ea				ld a,(f_cursor_ptr) 
c6ee 16 64				ld d, 100 
c6f0 0e 00				ld c, 0 
c6f2 1e 28				ld e, 40 
c6f4 cd 09 8d				call input_str 
c6f7					; TODO perhaps do a type check and wrap in quotes if not a number 
c6f7 21 c5 e4				ld hl, os_input 
c6fa					if DEBUG_FORTH_WORDS 
c6fa						DMARK "AC1" 
c6fa f5				push af  
c6fb 3a 0f c7			ld a, (.dmark)  
c6fe 32 71 ee			ld (debug_mark),a  
c701 3a 10 c7			ld a, (.dmark+1)  
c704 32 72 ee			ld (debug_mark+1),a  
c707 3a 11 c7			ld a, (.dmark+2)  
c70a 32 73 ee			ld (debug_mark+2),a  
c70d 18 03			jr .pastdmark  
c70f ..			.dmark: db "AC1"  
c712 f1			.pastdmark: pop af  
c713			endm  
# End of macro DMARK
c713						CALLMONITOR 
c713 cd dd 94			call break_point_state  
c716				endm  
# End of macro CALLMONITOR
c716					endif 
c716 cd e9 9b				call forth_push_str 
c719					NEXTW 
c719 c3 28 9f			jp macro_next 
c71c				endm 
# End of macro NEXTW
c71c			 
c71c			.EDIT: 
c71c				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c71c 40				db WORD_SYS_CORE+44             
c71d be c7			dw .DEDIT            
c71f 05				db 4 + 1 
c720 .. 00			db "EDIT",0              
c725				endm 
# End of macro CWHEAD
c725			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c725			 
c725					; TODO does not copy from stack 
c725					if DEBUG_FORTH_WORDS_KEY 
c725						DMARK "EDT" 
c725 f5				push af  
c726 3a 3a c7			ld a, (.dmark)  
c729 32 71 ee			ld (debug_mark),a  
c72c 3a 3b c7			ld a, (.dmark+1)  
c72f 32 72 ee			ld (debug_mark+1),a  
c732 3a 3c c7			ld a, (.dmark+2)  
c735 32 73 ee			ld (debug_mark+2),a  
c738 18 03			jr .pastdmark  
c73a ..			.dmark: db "EDT"  
c73d f1			.pastdmark: pop af  
c73e			endm  
# End of macro DMARK
c73e						CALLMONITOR 
c73e cd dd 94			call break_point_state  
c741				endm  
# End of macro CALLMONITOR
c741					endif 
c741			 
c741					;FORTH_DSP 
c741					FORTH_DSP_VALUEHL 
c741 cd 72 9d			call macro_dsp_valuehl 
c744				endm 
# End of macro FORTH_DSP_VALUEHL
c744			;		inc hl    ; TODO do type check 
c744			 
c744			;		call get_word_hl 
c744 e5					push hl 
c745					if DEBUG_FORTH_WORDS 
c745						DMARK "EDp" 
c745 f5				push af  
c746 3a 5a c7			ld a, (.dmark)  
c749 32 71 ee			ld (debug_mark),a  
c74c 3a 5b c7			ld a, (.dmark+1)  
c74f 32 72 ee			ld (debug_mark+1),a  
c752 3a 5c c7			ld a, (.dmark+2)  
c755 32 73 ee			ld (debug_mark+2),a  
c758 18 03			jr .pastdmark  
c75a ..			.dmark: db "EDp"  
c75d f1			.pastdmark: pop af  
c75e			endm  
# End of macro DMARK
c75e						CALLMONITOR 
c75e cd dd 94			call break_point_state  
c761				endm  
# End of macro CALLMONITOR
c761					endif 
c761				;	ld a, 0 
c761 cd 3a 91				call strlenz 
c764 23					inc hl 
c765			 
c765 06 00				ld b, 0 
c767 4d					ld c, l 
c768			 
c768 e1					pop hl 
c769 11 c5 e4				ld de, os_input 
c76c					if DEBUG_FORTH_WORDS_KEY 
c76c						DMARK "EDc" 
c76c f5				push af  
c76d 3a 81 c7			ld a, (.dmark)  
c770 32 71 ee			ld (debug_mark),a  
c773 3a 82 c7			ld a, (.dmark+1)  
c776 32 72 ee			ld (debug_mark+1),a  
c779 3a 83 c7			ld a, (.dmark+2)  
c77c 32 73 ee			ld (debug_mark+2),a  
c77f 18 03			jr .pastdmark  
c781 ..			.dmark: db "EDc"  
c784 f1			.pastdmark: pop af  
c785			endm  
# End of macro DMARK
c785						CALLMONITOR 
c785 cd dd 94			call break_point_state  
c788				endm  
# End of macro CALLMONITOR
c788					endif 
c788 ed b0				ldir 
c78a			 
c78a			 
c78a 21 c5 e4				ld hl, os_input 
c78d					;ld a, 0 
c78d					;ld (hl),a 
c78d 3a 64 ea				ld a,(f_cursor_ptr) 
c790 16 64				ld d, 100 
c792 0e 00				ld c, 0 
c794 1e 28				ld e, 40 
c796 cd 09 8d				call input_str 
c799					; TODO perhaps do a type check and wrap in quotes if not a number 
c799 21 c5 e4				ld hl, os_input 
c79c					if DEBUG_FORTH_WORDS 
c79c						DMARK "ED1" 
c79c f5				push af  
c79d 3a b1 c7			ld a, (.dmark)  
c7a0 32 71 ee			ld (debug_mark),a  
c7a3 3a b2 c7			ld a, (.dmark+1)  
c7a6 32 72 ee			ld (debug_mark+1),a  
c7a9 3a b3 c7			ld a, (.dmark+2)  
c7ac 32 73 ee			ld (debug_mark+2),a  
c7af 18 03			jr .pastdmark  
c7b1 ..			.dmark: db "ED1"  
c7b4 f1			.pastdmark: pop af  
c7b5			endm  
# End of macro DMARK
c7b5						CALLMONITOR 
c7b5 cd dd 94			call break_point_state  
c7b8				endm  
# End of macro CALLMONITOR
c7b8					endif 
c7b8 cd e9 9b				call forth_push_str 
c7bb					NEXTW 
c7bb c3 28 9f			jp macro_next 
c7be				endm 
# End of macro NEXTW
c7be			 
c7be			.DEDIT: 
c7be				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c7be 40				db WORD_SYS_CORE+44             
c7bf 20 c8			dw .ENDKEY            
c7c1 06				db 5 + 1 
c7c2 .. 00			db "DEDIT",0              
c7c8				endm 
# End of macro CWHEAD
c7c8			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c7c8			 
c7c8					; TODO does not copy from stack 
c7c8					if DEBUG_FORTH_WORDS_KEY 
c7c8						DMARK "DED" 
c7c8 f5				push af  
c7c9 3a dd c7			ld a, (.dmark)  
c7cc 32 71 ee			ld (debug_mark),a  
c7cf 3a de c7			ld a, (.dmark+1)  
c7d2 32 72 ee			ld (debug_mark+1),a  
c7d5 3a df c7			ld a, (.dmark+2)  
c7d8 32 73 ee			ld (debug_mark+2),a  
c7db 18 03			jr .pastdmark  
c7dd ..			.dmark: db "DED"  
c7e0 f1			.pastdmark: pop af  
c7e1			endm  
# End of macro DMARK
c7e1						CALLMONITOR 
c7e1 cd dd 94			call break_point_state  
c7e4				endm  
# End of macro CALLMONITOR
c7e4					endif 
c7e4			 
c7e4					;FORTH_DSP 
c7e4					FORTH_DSP_VALUEHL 
c7e4 cd 72 9d			call macro_dsp_valuehl 
c7e7				endm 
# End of macro FORTH_DSP_VALUEHL
c7e7			;		inc hl    ; TODO do type check 
c7e7			 
c7e7			;		call get_word_hl 
c7e7 e5					push hl 
c7e8 e5					push hl 
c7e9					FORTH_DSP_POP 
c7e9 cd 2a 9e			call macro_forth_dsp_pop 
c7ec				endm 
# End of macro FORTH_DSP_POP
c7ec e1					pop hl 
c7ed					if DEBUG_FORTH_WORDS 
c7ed						DMARK "EDp" 
c7ed f5				push af  
c7ee 3a 02 c8			ld a, (.dmark)  
c7f1 32 71 ee			ld (debug_mark),a  
c7f4 3a 03 c8			ld a, (.dmark+1)  
c7f7 32 72 ee			ld (debug_mark+1),a  
c7fa 3a 04 c8			ld a, (.dmark+2)  
c7fd 32 73 ee			ld (debug_mark+2),a  
c800 18 03			jr .pastdmark  
c802 ..			.dmark: db "EDp"  
c805 f1			.pastdmark: pop af  
c806			endm  
# End of macro DMARK
c806						CALLMONITOR 
c806 cd dd 94			call break_point_state  
c809				endm  
# End of macro CALLMONITOR
c809					endif 
c809				;	ld a, 0 
c809 cd 3a 91				call strlenz 
c80c 23					inc hl 
c80d			 
c80d 06 00				ld b, 0 
c80f 4d					ld c, l 
c810			 
c810 e1					pop hl 
c811			 
c811					;ld a, 0 
c811					;ld (hl),a 
c811 3a 64 ea				ld a,(f_cursor_ptr) 
c814 16 64				ld d, 100 
c816 0e 00				ld c, 0 
c818 1e 28				ld e, 40 
c81a cd 09 8d				call input_str 
c81d					; TODO perhaps do a type check and wrap in quotes if not a number 
c81d					NEXTW 
c81d c3 28 9f			jp macro_next 
c820				endm 
# End of macro NEXTW
c820			 
c820			 
c820			.ENDKEY: 
c820			; eof 
c820			 
# End of file forth_words_key.asm
c820			include "forth_words_const.asm" 
c820			 
c820			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c820			 
c820			 
c820			.SPITIME: 
c820				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c820 77				db WORD_SYS_CORE+99             
c821 35 c8			dw .VA            
c823 08				db 7 + 1 
c824 .. 00			db "SPITIME",0              
c82c				endm 
# End of macro CWHEAD
c82c			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
c82c			; 
c82c			; | If using BANK devices then leave as is. 
c82c			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
c82c			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
c82c			 
c82c 21 6a ea				ld hl, spi_clktime  
c82f cd 7b 9b				call forth_push_numhl 
c832			 
c832					NEXTW 
c832 c3 28 9f			jp macro_next 
c835				endm 
# End of macro NEXTW
c835			 
c835			 
c835			.VA: 
c835				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c835 77				db WORD_SYS_CORE+99             
c836 45 c8			dw .SYMBOL            
c838 03				db 2 + 1 
c839 .. 00			db "VA",0              
c83c				endm 
# End of macro CWHEAD
c83c			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
c83c 21 2e ea				ld hl, cli_var_array 
c83f cd 7b 9b				call forth_push_numhl 
c842			 
c842					NEXTW 
c842 c3 28 9f			jp macro_next 
c845				endm 
# End of macro NEXTW
c845			 
c845			.SYMBOL: 
c845				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c845 77				db WORD_SYS_CORE+99             
c846 7d c9			dw .ENDCONST            
c848 07				db 6 + 1 
c849 .. 00			db "SYMBOL",0              
c850				endm 
# End of macro CWHEAD
c850			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c850			; | 
c850			; | The value is the number reference and the final address is pushed to stack 
c850			 
c850					if DEBUG_FORTH_WORDS_KEY 
c850						DMARK "SYM" 
c850 f5				push af  
c851 3a 65 c8			ld a, (.dmark)  
c854 32 71 ee			ld (debug_mark),a  
c857 3a 66 c8			ld a, (.dmark+1)  
c85a 32 72 ee			ld (debug_mark+1),a  
c85d 3a 67 c8			ld a, (.dmark+2)  
c860 32 73 ee			ld (debug_mark+2),a  
c863 18 03			jr .pastdmark  
c865 ..			.dmark: db "SYM"  
c868 f1			.pastdmark: pop af  
c869			endm  
# End of macro DMARK
c869						CALLMONITOR 
c869 cd dd 94			call break_point_state  
c86c				endm  
# End of macro CALLMONITOR
c86c					endif 
c86c			 
c86c					FORTH_DSP_VALUEHL 
c86c cd 72 9d			call macro_dsp_valuehl 
c86f				endm 
# End of macro FORTH_DSP_VALUEHL
c86f			 
c86f 7d					ld a, l     
c870			 
c870			 
c870					if DEBUG_FORTH_WORDS 
c870						DMARK "SY1" 
c870 f5				push af  
c871 3a 85 c8			ld a, (.dmark)  
c874 32 71 ee			ld (debug_mark),a  
c877 3a 86 c8			ld a, (.dmark+1)  
c87a 32 72 ee			ld (debug_mark+1),a  
c87d 3a 87 c8			ld a, (.dmark+2)  
c880 32 73 ee			ld (debug_mark+2),a  
c883 18 03			jr .pastdmark  
c885 ..			.dmark: db "SY1"  
c888 f1			.pastdmark: pop af  
c889			endm  
# End of macro DMARK
c889						CALLMONITOR 
c889 cd dd 94			call break_point_state  
c88c				endm  
# End of macro CALLMONITOR
c88c					endif 
c88c					 
c88c f5					push af	 
c88d					FORTH_DSP_POP 
c88d cd 2a 9e			call macro_forth_dsp_pop 
c890				endm 
# End of macro FORTH_DSP_POP
c890 f1					pop af 
c891			 
c891 cb 27				sla a  
c893				 
c893					 
c893					if DEBUG_FORTH_WORDS 
c893						DMARK "SY" 
c893 f5				push af  
c894 3a a8 c8			ld a, (.dmark)  
c897 32 71 ee			ld (debug_mark),a  
c89a 3a a9 c8			ld a, (.dmark+1)  
c89d 32 72 ee			ld (debug_mark+1),a  
c8a0 3a aa c8			ld a, (.dmark+2)  
c8a3 32 73 ee			ld (debug_mark+2),a  
c8a6 18 02			jr .pastdmark  
c8a8 ..			.dmark: db "SY"  
c8aa f1			.pastdmark: pop af  
c8ab			endm  
# End of macro DMARK
c8ab						CALLMONITOR 
c8ab cd dd 94			call break_point_state  
c8ae				endm  
# End of macro CALLMONITOR
c8ae					endif 
c8ae			 
c8ae 21 bd c8				ld hl, sym_table 
c8b1 cd dc 8c				call addatohl 
c8b4 cd aa 9e				call loadwordinhl 
c8b7 cd 7b 9b				call forth_push_numhl 
c8ba			 
c8ba			 
c8ba				       NEXTW 
c8ba c3 28 9f			jp macro_next 
c8bd				endm 
# End of macro NEXTW
c8bd			 
c8bd			sym_table: 
c8bd			 
c8bd			; 0 
c8bd 42 ea		dw cli_autodisplay 
c8bf 50 ea		dw cli_buffer 
c8c1 f4 e9		dw cli_data_sp 
c8c3 2e e8		dw cli_data_stack 
c8c5 4a ea		dw cli_execword 
c8c7 f6 e9		dw cli_loop_sp 
c8c9 30 e9		dw cli_loop_stack 
c8cb 43 ea		dw cli_mvdot 
c8cd 48 ea		dw cli_nextword 
c8cf 44 ea		dw cli_origptr 
c8d1 4e ea		dw cli_origtoken 
c8d3			; 11 
c8d3 46 ea		dw cli_ptr 
c8d5 f8 e9		dw cli_ret_sp 
c8d7 b2 e9		dw cli_ret_stack 
c8d9 4c ea		dw cli_token 
c8db 2e ea		dw cli_var_array 
c8dd cb eb		dw cursor_col 
c8df c9 eb		dw cursor_ptr 
c8e1 ca eb		dw cursor_row 
c8e3 c7 eb		dw cursor_shape 
c8e5 71 ee		dw debug_mark 
c8e7			; 21 
c8e7 b7 ed		dw display_fb0 
c8e9 16 ed		dw display_fb1 
c8eb d4 eb		dw display_fb2 
c8ed 75 ec		dw display_fb3 
c8ef d2 eb		dw display_fb_active 
c8f1 c6 e3		dw execscratch 
c8f3 64 ea		dw f_cursor_ptr 
c8f5 75 ee		dw hardware_word 
c8f7 68 ee		dw input_at_cursor 
c8f9 6a ee		dw input_at_pos 
c8fb			; 31 
c8fb 66 ee		dw input_cur_flash 
c8fd 65 ee		dw input_cur_onoff 
c8ff 5b ee		dw input_cursor 
c901 6b ee		dw input_display_size 
c903 60 ee		dw input_len 
c905 6f ee		dw input_ptr 
c907 6c ee		dw input_size 
c909 6d ee		dw input_start 
c90b 09 8d		dw input_str 
c90d 69 ee		dw input_under_cursor 
c90f			; 41 
c90f 5a ee		dw key_actual_pressed 
c911 85 ee		dw key_fa 
c913 81 ee		dw key_face_held 
c915 84 ee		dw key_fb 
c917 83 ee		dw key_fc 
c919 82 ee		dw key_fd 
c91b 8b ee		dw key_held 
c91d 8a ee		dw key_held_prev 
c91f 67 e3		dw key_init 
c921 86 ee		dw key_repeat_ct 
c923			; 51 
c923 05 00		dw key_rows 
c925 58 ee		dw key_shift 
c927 59 ee		dw key_symbol 
c929 8c ee		dw keyscan_scancol 
c92b 96 ee		dw keyscan_table 
c92d f5 ee		dw keyscan_table_row1 
c92f ea ee		dw keyscan_table_row2 
c931 df ee		dw keyscan_table_row3 
c933 d4 ee		dw keyscan_table_row4 
c935 c9 ee		dw keyscan_table_row5 
c937			; 61 
c937 ee e5		dw os_cli_cmd 
c939 ea e5		dw os_cur_ptr 
c93b ec e5		dw os_current_i 
c93d c5 e4		dw os_input 
c93f ed e6		dw os_last_cmd 
c941 c4 e5		dw os_last_new_uword 
c943 b8 e2		dw os_view_disable 
c945 b4 e2		dw os_view_hl 
c947 cc e5		dw os_word_scratch 
c949 c3 00		dw portbctl 
c94b			; 71 
c94b c1 00		dw portbdata 
c94d 69 ea		dw spi_cartdev 
c94f 68 ea		dw spi_cartdev2 
c951 6a ea		dw spi_clktime 
c953 66 ea		dw spi_device 
c955 65 ea		dw spi_device_id 
c957 67 ea		dw spi_portbyte 
c959 ad eb		dw stackstore 
c95b			if STORAGE_SE 
c95b			dw storage_actl 
c95b			dw storage_adata 
c95b			else 
c95b 00 00		dw 0 
c95d 00 00		dw 0 
c95f			endif 
c95f			; 81 
c95f 69 88		dw storage_append 
c961			if STORAGE_SE 
c961			dw storage_bctl 
c961			else 
c961 00 00		dw 0 
c963			endif 
c963 99 eb		dw store_bank_active 
c965 6d ea		dw store_filecache 
c967 7b ea		dw store_longread 
c969 71 ea		dw store_openaddr 
c96b 70 ea		dw store_openext 
c96d 6f ea		dw store_openmaxext 
c96f 80 ea		dw store_page 
c971 7c ea		dw store_readbuf 
c973			; 91 
c973 73 ea		dw store_readcont 
c975 7e ea		dw store_readptr 
c977 73 ea		dw store_tmpext 
c979 74 ea		dw store_tmpid 
c97b 6b ea		dw store_tmppageid 
c97d			 
c97d			 
c97d			.ENDCONST: 
c97d			 
c97d			; eof 
c97d			 
c97d			 
# End of file forth_words_const.asm
c97d			 
c97d			if STORAGE_SE 
c97d			   	include "forth_words_storage.asm" 
c97d			endif 
c97d				include "forth_words_device.asm" 
c97d			; Device related words 
c97d			 
c97d			; | ## Device Words 
c97d			 
c97d			;if SOUND_ENABLE 
c97d			;.NOTE: 
c97d			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c97d			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c97d			;		if DEBUG_FORTH_WORDS_KEY 
c97d			;			DMARK "NTE" 
c97d			;			CALLMONITOR 
c97d			;		endif 
c97d			; 
c97d			;	 
c97d			; 
c97d			;		NEXTW 
c97d			;.AFTERSOUND: 
c97d			;endif 
c97d			 
c97d			 
c97d			USE_GPIO: equ 0 
c97d			 
c97d			if USE_GPIO 
c97d			.GP1: 
c97d				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c97d			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c97d					NEXTW 
c97d			.GP2: 
c97d				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c97d			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c97d			 
c97d					NEXTW 
c97d			 
c97d			.GP3: 
c97d				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c97d			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c97d			 
c97d					NEXTW 
c97d			 
c97d			.GP4: 
c97d				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c97d			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c97d			 
c97d					NEXTW 
c97d			.SIN: 
c97d			 
c97d			 
c97d			endif 
c97d			 
c97d			 
c97d				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c97d 33				db WORD_SYS_CORE+31             
c97e b2 c9			dw .SOUT            
c980 03				db 2 + 1 
c981 .. 00			db "IN",0              
c984				endm 
# End of macro CWHEAD
c984			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c984					if DEBUG_FORTH_WORDS_KEY 
c984						DMARK "IN." 
c984 f5				push af  
c985 3a 99 c9			ld a, (.dmark)  
c988 32 71 ee			ld (debug_mark),a  
c98b 3a 9a c9			ld a, (.dmark+1)  
c98e 32 72 ee			ld (debug_mark+1),a  
c991 3a 9b c9			ld a, (.dmark+2)  
c994 32 73 ee			ld (debug_mark+2),a  
c997 18 03			jr .pastdmark  
c999 ..			.dmark: db "IN."  
c99c f1			.pastdmark: pop af  
c99d			endm  
# End of macro DMARK
c99d						CALLMONITOR 
c99d cd dd 94			call break_point_state  
c9a0				endm  
# End of macro CALLMONITOR
c9a0					endif 
c9a0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9a0 cd 72 9d			call macro_dsp_valuehl 
c9a3				endm 
# End of macro FORTH_DSP_VALUEHL
c9a3			 
c9a3 e5					push hl 
c9a4			 
c9a4					; destroy value TOS 
c9a4			 
c9a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9a4 cd 2a 9e			call macro_forth_dsp_pop 
c9a7				endm 
# End of macro FORTH_DSP_POP
c9a7			 
c9a7					; one value on hl get other one back 
c9a7			 
c9a7 c1					pop bc 
c9a8			 
c9a8					; do the sub 
c9a8			;		ex de, hl 
c9a8			 
c9a8 ed 68				in l,(c) 
c9aa			 
c9aa					; save it 
c9aa			 
c9aa 26 00				ld h,0 
c9ac			 
c9ac					; TODO push value back onto stack for another op etc 
c9ac			 
c9ac cd 7b 9b				call forth_push_numhl 
c9af					NEXTW 
c9af c3 28 9f			jp macro_next 
c9b2				endm 
# End of macro NEXTW
c9b2			.SOUT: 
c9b2				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c9b2 34				db WORD_SYS_CORE+32             
c9b3 05 ca			dw .SPIO            
c9b5 04				db 3 + 1 
c9b6 .. 00			db "OUT",0              
c9ba				endm 
# End of macro CWHEAD
c9ba			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c9ba					if DEBUG_FORTH_WORDS_KEY 
c9ba						DMARK "OUT" 
c9ba f5				push af  
c9bb 3a cf c9			ld a, (.dmark)  
c9be 32 71 ee			ld (debug_mark),a  
c9c1 3a d0 c9			ld a, (.dmark+1)  
c9c4 32 72 ee			ld (debug_mark+1),a  
c9c7 3a d1 c9			ld a, (.dmark+2)  
c9ca 32 73 ee			ld (debug_mark+2),a  
c9cd 18 03			jr .pastdmark  
c9cf ..			.dmark: db "OUT"  
c9d2 f1			.pastdmark: pop af  
c9d3			endm  
# End of macro DMARK
c9d3						CALLMONITOR 
c9d3 cd dd 94			call break_point_state  
c9d6				endm  
# End of macro CALLMONITOR
c9d6					endif 
c9d6			 
c9d6					; get port 
c9d6			 
c9d6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9d6 cd 72 9d			call macro_dsp_valuehl 
c9d9				endm 
# End of macro FORTH_DSP_VALUEHL
c9d9			 
c9d9 e5					push hl 
c9da			 
c9da					; destroy value TOS 
c9da			 
c9da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9da cd 2a 9e			call macro_forth_dsp_pop 
c9dd				endm 
# End of macro FORTH_DSP_POP
c9dd			 
c9dd					; get byte to send 
c9dd			 
c9dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9dd cd 72 9d			call macro_dsp_valuehl 
c9e0				endm 
# End of macro FORTH_DSP_VALUEHL
c9e0			 
c9e0			;		push hl 
c9e0			 
c9e0					; destroy value TOS 
c9e0			 
c9e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9e0 cd 2a 9e			call macro_forth_dsp_pop 
c9e3				endm 
# End of macro FORTH_DSP_POP
c9e3			 
c9e3					; one value on hl get other one back 
c9e3			 
c9e3			;		pop hl 
c9e3			 
c9e3 c1					pop bc 
c9e4			 
c9e4					if DEBUG_FORTH_WORDS 
c9e4						DMARK "OUT" 
c9e4 f5				push af  
c9e5 3a f9 c9			ld a, (.dmark)  
c9e8 32 71 ee			ld (debug_mark),a  
c9eb 3a fa c9			ld a, (.dmark+1)  
c9ee 32 72 ee			ld (debug_mark+1),a  
c9f1 3a fb c9			ld a, (.dmark+2)  
c9f4 32 73 ee			ld (debug_mark+2),a  
c9f7 18 03			jr .pastdmark  
c9f9 ..			.dmark: db "OUT"  
c9fc f1			.pastdmark: pop af  
c9fd			endm  
# End of macro DMARK
c9fd						CALLMONITOR 
c9fd cd dd 94			call break_point_state  
ca00				endm  
# End of macro CALLMONITOR
ca00					endif 
ca00			 
ca00 ed 69				out (c), l 
ca02			 
ca02					NEXTW 
ca02 c3 28 9f			jp macro_next 
ca05				endm 
# End of macro NEXTW
ca05			 
ca05			 
ca05			.SPIO: 
ca05			 
ca05			if STORAGE_SE 
ca05				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
ca05			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
ca05			 
ca05					call spi_ce_low 
ca05			    NEXTW 
ca05			 
ca05			.SPICEH: 
ca05				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
ca05			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
ca05			 
ca05					call spi_ce_high 
ca05			    NEXTW 
ca05			 
ca05			 
ca05			.SPIOb: 
ca05			 
ca05				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
ca05			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
ca05			 
ca05					if DEBUG_FORTH_WORDS_KEY 
ca05						DMARK "SPo" 
ca05						CALLMONITOR 
ca05					endif 
ca05					; get port 
ca05			 
ca05			 
ca05					; get byte to send 
ca05			 
ca05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca05			 
ca05			;		push hl    ; u1  
ca05			 
ca05					; destroy value TOS 
ca05			 
ca05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca05			 
ca05					; one value on hl get other one back 
ca05			 
ca05			;		pop hl   ; u2 - addr 
ca05			 
ca05					; TODO Send SPI byte 
ca05			 
ca05			;		push hl 
ca05			;		call spi_ce_low 
ca05			;		pop hl 
ca05					ld a, l 
ca05					call spi_send_byte 
ca05			;		call spi_ce_high 
ca05			 
ca05					NEXTW 
ca05			 
ca05			.SPII: 
ca05				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
ca05			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
ca05					if DEBUG_FORTH_WORDS_KEY 
ca05						DMARK "SPi" 
ca05						CALLMONITOR 
ca05					endif 
ca05			 
ca05					; TODO Get SPI byte 
ca05			 
ca05					call spi_read_byte 
ca05			 
ca05					if DEBUG_FORTH_WORDS 
ca05						DMARK "Si2" 
ca05						CALLMONITOR 
ca05					endif 
ca05					ld h, 0 
ca05					ld l, a 
ca05					if DEBUG_FORTH_WORDS 
ca05						DMARK "Si3" 
ca05						CALLMONITOR 
ca05					endif 
ca05					call forth_push_numhl 
ca05			 
ca05					NEXTW 
ca05			 
ca05			 
ca05			 
ca05			.SESEL: 
ca05				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
ca05			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
ca05					if DEBUG_FORTH_WORDS_KEY 
ca05						DMARK "BNK" 
ca05						CALLMONITOR 
ca05					endif 
ca05			 
ca05					ld a, 255 
ca05					ld (spi_cartdev), a 
ca05			 
ca05					; get bank 
ca05			 
ca05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca05			 
ca05			;		push hl 
ca05			 
ca05					; destroy value TOS 
ca05			 
ca05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca05			 
ca05					; one value on hl get other one back 
ca05			 
ca05			;		pop hl 
ca05			 
ca05			 
ca05					ld c, SPI_CE_HIGH 
ca05					ld b, '0'    ; human readable bank number 
ca05			 
ca05					ld a, l 
ca05			 
ca05					if DEBUG_FORTH_WORDS 
ca05						DMARK "BNK" 
ca05						CALLMONITOR 
ca05					endif 
ca05			 
ca05					; active low 
ca05			 
ca05					cp 0 
ca05					jr z, .bset 
ca05					cp 1 
ca05					jr nz, .b2 
ca05					res 0, c 
ca05					ld b, '1'    ; human readable bank number 
ca05			.b2:		cp 2 
ca05					jr nz, .b3 
ca05					res 1, c 
ca05					ld b, '2'    ; human readable bank number 
ca05			.b3:		cp 3 
ca05					jr nz, .b4 
ca05					res 2, c 
ca05					ld b, '3'    ; human readable bank number 
ca05			.b4:		cp 4 
ca05					jr nz, .b5 
ca05					res 3, c 
ca05					ld b, '4'    ; human readable bank number 
ca05			.b5:		cp 5 
ca05					jr nz, .bset 
ca05					res 4, c 
ca05					ld b, '5'    ; human readable bank number 
ca05			 
ca05			.bset: 
ca05					ld a, c 
ca05					ld (spi_device),a 
ca05					ld a, b 
ca05					ld (spi_device_id),a 
ca05					if DEBUG_FORTH_WORDS 
ca05						DMARK "BN2" 
ca05						CALLMONITOR 
ca05					endif 
ca05			 
ca05					; set default SPI clk pulse time as disabled for BANK use 
ca05			 
ca05					ld a, 0 
ca05					ld (spi_clktime), a 
ca05			 
ca05					NEXTW 
ca05			 
ca05			.CARTDEV: 
ca05				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
ca05			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
ca05					if DEBUG_FORTH_WORDS_KEY 
ca05						DMARK "CDV" 
ca05						CALLMONITOR 
ca05					endif 
ca05			 
ca05					; disable se storage bank selection 
ca05			 
ca05					ld a, SPI_CE_HIGH		; ce high 
ca05					ld (spi_device), a 
ca05			 
ca05					; get bank 
ca05			 
ca05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca05			 
ca05			;		push hl 
ca05			 
ca05					; destroy value TOS 
ca05			 
ca05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca05			 
ca05					; one value on hl get other one back 
ca05			 
ca05			;		pop hl 
ca05			 
ca05					; active low 
ca05			 
ca05					ld c, 255 
ca05			 
ca05					ld a, l 
ca05					if DEBUG_FORTH_WORDS 
ca05						DMARK "CDV" 
ca05						CALLMONITOR 
ca05					endif 
ca05					cp 0 
ca05					jr z, .cset 
ca05					cp 1 
ca05					jr nz, .c2 
ca05					res 0, c 
ca05			.c2:		cp 2 
ca05					jr nz, .c3 
ca05					res 1, c 
ca05			.c3:		cp 3 
ca05					jr nz, .c4 
ca05					res 2, c 
ca05			.c4:		cp 4 
ca05					jr nz, .c5 
ca05					res 3, c 
ca05			.c5:		cp 5 
ca05					jr nz, .c6 
ca05					res 4, c 
ca05			.c6:		cp 6 
ca05					jr nz, .c7 
ca05					res 5, c 
ca05			.c7:		cp 7 
ca05					jr nz, .c8 
ca05					res 6, c 
ca05			.c8:		cp 8 
ca05					jr nz, .cset 
ca05					res 7, c 
ca05			.cset:		ld a, c 
ca05					ld (spi_cartdev),a 
ca05			 
ca05					if DEBUG_FORTH_WORDS 
ca05						DMARK "CD2" 
ca05						CALLMONITOR 
ca05					endif 
ca05			 
ca05					; set default SPI clk pulse time as 10ms for CARTDEV use 
ca05			 
ca05					ld a, $0a 
ca05					ld (spi_clktime), a 
ca05					NEXTW 
ca05			endif 
ca05			 
ca05			.ENDDEVICE: 
ca05			; eof 
ca05			 
# End of file forth_words_device.asm
ca05			 
ca05			; var handler 
ca05			 
ca05			 
ca05			.VARS: 
ca05				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
ca05 77				db WORD_SYS_CORE+99             
ca06 b6 ca			dw .V0            
ca08 04				db 3 + 1 
ca09 .. 00			db "VAR",0              
ca0d				endm 
# End of macro CWHEAD
ca0d			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
ca0d			;| 
ca0d			;| The variable name should consist of a single letter. e.g. "a" 
ca0d			;! If a full string is passed then only the first char is looked at 
ca0d			;| Any other char could exceed bounds checks!  
ca0d			 
ca0d					if DEBUG_FORTH_WORDS_KEY 
ca0d						DMARK "VAR" 
ca0d f5				push af  
ca0e 3a 22 ca			ld a, (.dmark)  
ca11 32 71 ee			ld (debug_mark),a  
ca14 3a 23 ca			ld a, (.dmark+1)  
ca17 32 72 ee			ld (debug_mark+1),a  
ca1a 3a 24 ca			ld a, (.dmark+2)  
ca1d 32 73 ee			ld (debug_mark+2),a  
ca20 18 03			jr .pastdmark  
ca22 ..			.dmark: db "VAR"  
ca25 f1			.pastdmark: pop af  
ca26			endm  
# End of macro DMARK
ca26						CALLMONITOR 
ca26 cd dd 94			call break_point_state  
ca29				endm  
# End of macro CALLMONITOR
ca29					endif 
ca29			 
ca29					FORTH_DSP_VALUEHL 
ca29 cd 72 9d			call macro_dsp_valuehl 
ca2c				endm 
# End of macro FORTH_DSP_VALUEHL
ca2c			 
ca2c 7e					ld a, (hl)    ; get first char on of the string 
ca2d			 
ca2d			 
ca2d					if DEBUG_FORTH_WORDS 
ca2d						DMARK "VR1" 
ca2d f5				push af  
ca2e 3a 42 ca			ld a, (.dmark)  
ca31 32 71 ee			ld (debug_mark),a  
ca34 3a 43 ca			ld a, (.dmark+1)  
ca37 32 72 ee			ld (debug_mark+1),a  
ca3a 3a 44 ca			ld a, (.dmark+2)  
ca3d 32 73 ee			ld (debug_mark+2),a  
ca40 18 03			jr .pastdmark  
ca42 ..			.dmark: db "VR1"  
ca45 f1			.pastdmark: pop af  
ca46			endm  
# End of macro DMARK
ca46						CALLMONITOR 
ca46 cd dd 94			call break_point_state  
ca49				endm  
# End of macro CALLMONITOR
ca49					endif 
ca49					 
ca49 f5					push af	 
ca4a					FORTH_DSP_POP 
ca4a cd 2a 9e			call macro_forth_dsp_pop 
ca4d				endm 
# End of macro FORTH_DSP_POP
ca4d f1					pop af 
ca4e			 
ca4e					; convert to upper 
ca4e			 
ca4e cd 49 90				call to_upper 
ca51					if DEBUG_FORTH_WORDS 
ca51						DMARK "Vaa" 
ca51 f5				push af  
ca52 3a 66 ca			ld a, (.dmark)  
ca55 32 71 ee			ld (debug_mark),a  
ca58 3a 67 ca			ld a, (.dmark+1)  
ca5b 32 72 ee			ld (debug_mark+1),a  
ca5e 3a 68 ca			ld a, (.dmark+2)  
ca61 32 73 ee			ld (debug_mark+2),a  
ca64 18 03			jr .pastdmark  
ca66 ..			.dmark: db "Vaa"  
ca69 f1			.pastdmark: pop af  
ca6a			endm  
# End of macro DMARK
ca6a						CALLMONITOR 
ca6a cd dd 94			call break_point_state  
ca6d				endm  
# End of macro CALLMONITOR
ca6d					endif 
ca6d 06 41				ld b, 'A' 
ca6f 90					sub b			; set offset 
ca70					if DEBUG_FORTH_WORDS 
ca70						DMARK "Vbb" 
ca70 f5				push af  
ca71 3a 85 ca			ld a, (.dmark)  
ca74 32 71 ee			ld (debug_mark),a  
ca77 3a 86 ca			ld a, (.dmark+1)  
ca7a 32 72 ee			ld (debug_mark+1),a  
ca7d 3a 87 ca			ld a, (.dmark+2)  
ca80 32 73 ee			ld (debug_mark+2),a  
ca83 18 03			jr .pastdmark  
ca85 ..			.dmark: db "Vbb"  
ca88 f1			.pastdmark: pop af  
ca89			endm  
# End of macro DMARK
ca89						CALLMONITOR 
ca89 cd dd 94			call break_point_state  
ca8c				endm  
# End of macro CALLMONITOR
ca8c					endif 
ca8c cb 27				sla a  
ca8e				 
ca8e					 
ca8e					if DEBUG_FORTH_WORDS 
ca8e						DMARK "VR2" 
ca8e f5				push af  
ca8f 3a a3 ca			ld a, (.dmark)  
ca92 32 71 ee			ld (debug_mark),a  
ca95 3a a4 ca			ld a, (.dmark+1)  
ca98 32 72 ee			ld (debug_mark+1),a  
ca9b 3a a5 ca			ld a, (.dmark+2)  
ca9e 32 73 ee			ld (debug_mark+2),a  
caa1 18 03			jr .pastdmark  
caa3 ..			.dmark: db "VR2"  
caa6 f1			.pastdmark: pop af  
caa7			endm  
# End of macro DMARK
caa7						CALLMONITOR 
caa7 cd dd 94			call break_point_state  
caaa				endm  
# End of macro CALLMONITOR
caaa					endif 
caaa			 
caaa 21 fa e9				ld hl, cli_var_array2 
caad cd dc 8c				call addatohl 
cab0 cd 7b 9b				call forth_push_numhl 
cab3			 
cab3			 
cab3				       NEXTW 
cab3 c3 28 9f			jp macro_next 
cab6				endm 
# End of macro NEXTW
cab6			.V0: 
cab6				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
cab6 78				db WORD_SYS_CORE+100             
cab7 ce ca			dw .V0Q            
cab9 04				db 3 + 1 
caba .. 00			db "V0!",0              
cabe				endm 
# End of macro CWHEAD
cabe			;| V0! ( u1 -- )  Store value to v0  | DONE 
cabe			 
cabe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cabe cd 72 9d			call macro_dsp_valuehl 
cac1				endm 
# End of macro FORTH_DSP_VALUEHL
cac1			 
cac1 11 2e ea				ld de, cli_var_array 
cac4			 
cac4 eb					ex de, hl 
cac5 73					ld (hl), e 
cac6 23					inc hl 
cac7 72					ld (hl), d 
cac8			 
cac8					; destroy value TOS 
cac8			 
cac8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cac8 cd 2a 9e			call macro_forth_dsp_pop 
cacb				endm 
# End of macro FORTH_DSP_POP
cacb			 
cacb				       NEXTW 
cacb c3 28 9f			jp macro_next 
cace				endm 
# End of macro NEXTW
cace			.V0Q: 
cace				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
cace 79				db WORD_SYS_CORE+101             
cacf df ca			dw .V1S            
cad1 04				db 3 + 1 
cad2 .. 00			db "V0@",0              
cad6				endm 
# End of macro CWHEAD
cad6			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
cad6 2a 2e ea				ld hl, (cli_var_array) 
cad9 cd 7b 9b				call forth_push_numhl 
cadc			 
cadc				       NEXTW 
cadc c3 28 9f			jp macro_next 
cadf				endm 
# End of macro NEXTW
cadf			.V1S: 
cadf				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
cadf 7a				db WORD_SYS_CORE+102             
cae0 f7 ca			dw .V1Q            
cae2 04				db 3 + 1 
cae3 .. 00			db "V1!",0              
cae7				endm 
# End of macro CWHEAD
cae7			;| V1! ( u1 -- )  Store value to v1 | DONE 
cae7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cae7 cd 72 9d			call macro_dsp_valuehl 
caea				endm 
# End of macro FORTH_DSP_VALUEHL
caea			 
caea 11 30 ea				ld de, cli_var_array+2 
caed				 
caed eb					ex de, hl 
caee 73					ld (hl), e 
caef 23					inc hl 
caf0 72					ld (hl), d 
caf1			 
caf1					; destroy value TOS 
caf1			 
caf1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
caf1 cd 2a 9e			call macro_forth_dsp_pop 
caf4				endm 
# End of macro FORTH_DSP_POP
caf4				       NEXTW 
caf4 c3 28 9f			jp macro_next 
caf7				endm 
# End of macro NEXTW
caf7			.V1Q: 
caf7				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
caf7 7b				db WORD_SYS_CORE+103             
caf8 08 cb			dw .V2S            
cafa 04				db 3 + 1 
cafb .. 00			db "V1@",0              
caff				endm 
# End of macro CWHEAD
caff			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
caff 2a 30 ea				ld hl, (cli_var_array+2) 
cb02 cd 7b 9b				call forth_push_numhl 
cb05				       NEXTW 
cb05 c3 28 9f			jp macro_next 
cb08				endm 
# End of macro NEXTW
cb08			.V2S: 
cb08				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cb08 7c				db WORD_SYS_CORE+104             
cb09 20 cb			dw .V2Q            
cb0b 04				db 3 + 1 
cb0c .. 00			db "V2!",0              
cb10				endm 
# End of macro CWHEAD
cb10			;| V2! ( u1 -- )  Store value to v2 | DONE 
cb10					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb10 cd 72 9d			call macro_dsp_valuehl 
cb13				endm 
# End of macro FORTH_DSP_VALUEHL
cb13			 
cb13 11 32 ea				ld de, cli_var_array+4 
cb16				 
cb16 eb					ex de, hl 
cb17 73					ld (hl), e 
cb18 23					inc hl 
cb19 72					ld (hl), d 
cb1a			 
cb1a					; destroy value TOS 
cb1a			 
cb1a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb1a cd 2a 9e			call macro_forth_dsp_pop 
cb1d				endm 
# End of macro FORTH_DSP_POP
cb1d				       NEXTW 
cb1d c3 28 9f			jp macro_next 
cb20				endm 
# End of macro NEXTW
cb20			.V2Q: 
cb20				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cb20 7d				db WORD_SYS_CORE+105             
cb21 31 cb			dw .V3S            
cb23 04				db 3 + 1 
cb24 .. 00			db "V2@",0              
cb28				endm 
# End of macro CWHEAD
cb28			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cb28 2a 32 ea				ld hl, (cli_var_array+4) 
cb2b cd 7b 9b				call forth_push_numhl 
cb2e				       NEXTW 
cb2e c3 28 9f			jp macro_next 
cb31				endm 
# End of macro NEXTW
cb31			.V3S: 
cb31				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cb31 7c				db WORD_SYS_CORE+104             
cb32 49 cb			dw .V3Q            
cb34 04				db 3 + 1 
cb35 .. 00			db "V3!",0              
cb39				endm 
# End of macro CWHEAD
cb39			;| V3! ( u1 -- )  Store value to v3 | DONE 
cb39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb39 cd 72 9d			call macro_dsp_valuehl 
cb3c				endm 
# End of macro FORTH_DSP_VALUEHL
cb3c			 
cb3c 11 34 ea				ld de, cli_var_array+6 
cb3f				 
cb3f eb					ex de, hl 
cb40 73					ld (hl), e 
cb41 23					inc hl 
cb42 72					ld (hl), d 
cb43			 
cb43					; destroy value TOS 
cb43			 
cb43					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb43 cd 2a 9e			call macro_forth_dsp_pop 
cb46				endm 
# End of macro FORTH_DSP_POP
cb46				       NEXTW 
cb46 c3 28 9f			jp macro_next 
cb49				endm 
# End of macro NEXTW
cb49			.V3Q: 
cb49				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cb49 7d				db WORD_SYS_CORE+105             
cb4a 5a cb			dw .END            
cb4c 04				db 3 + 1 
cb4d .. 00			db "V3@",0              
cb51				endm 
# End of macro CWHEAD
cb51			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cb51 2a 34 ea				ld hl, (cli_var_array+6) 
cb54 cd 7b 9b				call forth_push_numhl 
cb57				       NEXTW 
cb57 c3 28 9f			jp macro_next 
cb5a				endm 
# End of macro NEXTW
cb5a			 
cb5a			 
cb5a			 
cb5a			 
cb5a			 
cb5a			; end of dict marker 
cb5a			 
cb5a 00			.END:    db WORD_SYS_END 
cb5b 00 00			dw 0 
cb5d 00				db 0 
cb5e			 
cb5e			; use to jp here for user dict words to save on macro expansion  
cb5e			 
cb5e			user_dict_next: 
cb5e				NEXTW 
cb5e c3 28 9f			jp macro_next 
cb61				endm 
# End of macro NEXTW
cb61			 
cb61			 
cb61			user_exec: 
cb61				;    ld hl, <word code> 
cb61				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cb61				;    call forthexec 
cb61				;    jp user_dict_next   (NEXT) 
cb61			        ;    <word code bytes> 
cb61 eb				ex de, hl 
cb62 2a c8 e5			ld hl,(os_tok_ptr) 
cb65				 
cb65				FORTH_RSP_NEXT 
cb65 cd 22 9b			call macro_forth_rsp_next 
cb68				endm 
# End of macro FORTH_RSP_NEXT
cb68			 
cb68			if DEBUG_FORTH_UWORD 
cb68						DMARK "UEX" 
cb68 f5				push af  
cb69 3a 7d cb			ld a, (.dmark)  
cb6c 32 71 ee			ld (debug_mark),a  
cb6f 3a 7e cb			ld a, (.dmark+1)  
cb72 32 72 ee			ld (debug_mark+1),a  
cb75 3a 7f cb			ld a, (.dmark+2)  
cb78 32 73 ee			ld (debug_mark+2),a  
cb7b 18 03			jr .pastdmark  
cb7d ..			.dmark: db "UEX"  
cb80 f1			.pastdmark: pop af  
cb81			endm  
# End of macro DMARK
cb81				CALLMONITOR 
cb81 cd dd 94			call break_point_state  
cb84				endm  
# End of macro CALLMONITOR
cb84			endif 
cb84			 
cb84			 
cb84			 
cb84 eb				ex de, hl 
cb85 22 c8 e5			ld (os_tok_ptr), hl 
cb88				 
cb88				; Don't use next - Skips the first word in uword. 
cb88			 
cb88 c3 b9 9f			jp exec1 
cb8b			;	NEXT 
cb8b			 
cb8b			 
cb8b			; eof 
# End of file forth_wordsv4.asm
cb8b			endif 
cb8b			;;;;;;;;;;;;;; Debug code 
cb8b			 
cb8b			 
cb8b			;if DEBUG_FORTH_PARSE 
cb8b .. 00		.nowordfound: db "No match",0 
cb94 .. 00		.compword:	db "Comparing word ",0 
cba4 .. 00		.nextwordat:	db "Next word at",0 
cbb1 .. 00		.charmatch:	db "Char match",0 
cbbc			;endif 
cbbc			if DEBUG_FORTH_JP 
cbbc			.foundword:	db "Word match. Exec..",0 
cbbc			endif 
cbbc			;if DEBUG_FORTH_PUSH 
cbbc .. 00		.enddict:	db "Dict end. Push.",0 
cbcc .. 00		.push_str:	db "Pushing string",0 
cbdb .. 00		.push_num:	db "Pushing number",0 
cbea .. 00		.data_sp:	db "SP:",0 
cbee .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cc00 .. 00		.wordinde:	db "Word in DE (3/0):",0 
cc12 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cc24			;endif 
cc24			;if DEBUG_FORTH_MALLOC 
cc24 .. 00		.push_malloc:	db "Malloc address",0 
cc33			;endif 
cc33			 
cc33			 
cc33			 
cc33			; display malloc address and current data stack pointer  
cc33			 
cc33			malloc_error: 
cc33 d5				push de 
cc34 f5				push af 
cc35 e5				push hl 
cc36 cd af 8a			call clear_display 
cc39 11 5b cc			ld de, .mallocerr 
cc3c 3e 00			ld a,0 
cc3e			;	ld de,os_word_scratch 
cc3e cd c2 8a			call str_at_display 
cc41 3e 11			ld a, display_row_1+17 
cc43 11 71 ee			ld de, debug_mark 
cc46 cd c2 8a			call str_at_display 
cc49 cd d2 8a			call update_display 
cc4c				;call break_point_state 
cc4c cd 68 e3			call cin_wait 
cc4f			 
cc4f 3e 20			ld a, ' ' 
cc51 32 b8 e2			ld (os_view_disable), a 
cc54 e1				pop hl 
cc55 f1				pop af 
cc56 d1				pop de	 
cc57				CALLMONITOR 
cc57 cd dd 94			call break_point_state  
cc5a				endm  
# End of macro CALLMONITOR
cc5a c9				ret 
cc5b			 
cc5b .. 00		.mallocerr: 	db "Malloc Error",0 
cc68			;if DEBUG_FORTH_PUSH 
cc68			display_data_sp: 
cc68 f5				push af 
cc69			 
cc69				; see if disabled 
cc69			 
cc69 3a b8 e2			ld a, (os_view_disable) 
cc6c fe 2a			cp '*' 
cc6e 28 67			jr z, .skipdsp 
cc70			 
cc70 e5				push hl 
cc71 e5				push hl 
cc72 e5			push hl 
cc73 cd af 8a			call clear_display 
cc76 e1			pop hl 
cc77 7c				ld a,h 
cc78 21 cc e5			ld hl, os_word_scratch 
cc7b cd dd 8f			call hexout 
cc7e e1				pop hl 
cc7f 7d				ld a,l 
cc80 21 ce e5			ld hl, os_word_scratch+2 
cc83 cd dd 8f			call hexout 
cc86 21 d0 e5			ld hl, os_word_scratch+4 
cc89 3e 00			ld a,0 
cc8b 77				ld (hl),a 
cc8c 11 cc e5			ld de,os_word_scratch 
cc8f 3e 28				ld a, display_row_2 
cc91 cd c2 8a				call str_at_display 
cc94 11 ee cb			ld de, .wordinhl 
cc97 3e 00			ld a, display_row_1 
cc99			 
cc99 cd c2 8a				call str_at_display 
cc9c 11 71 ee			ld de, debug_mark 
cc9f 3e 11			ld a, display_row_1+17 
cca1			 
cca1 cd c2 8a				call str_at_display 
cca4			 
cca4				; display current data stack pointer 
cca4 11 ea cb			ld de,.data_sp 
cca7 3e 30				ld a, display_row_2 + 8 
cca9 cd c2 8a				call str_at_display 
ccac			 
ccac 2a f4 e9			ld hl,(cli_data_sp) 
ccaf e5				push hl 
ccb0 7c				ld a,h 
ccb1 21 cc e5			ld hl, os_word_scratch 
ccb4 cd dd 8f			call hexout 
ccb7 e1				pop hl 
ccb8 7d				ld a,l 
ccb9 21 ce e5			ld hl, os_word_scratch+2 
ccbc cd dd 8f			call hexout 
ccbf 21 d0 e5			ld hl, os_word_scratch+4 
ccc2 3e 00			ld a,0 
ccc4 77				ld (hl),a 
ccc5 11 cc e5			ld de,os_word_scratch 
ccc8 3e 33				ld a, display_row_2 + 11 
ccca cd c2 8a				call str_at_display 
cccd			 
cccd			 
cccd cd d2 8a			call update_display 
ccd0 cd f2 89			call delay1s 
ccd3 cd f2 89			call delay1s 
ccd6 e1				pop hl 
ccd7			.skipdsp: 
ccd7 f1				pop af 
ccd8 c9				ret 
ccd9			 
ccd9			display_data_malloc: 
ccd9			 
ccd9 f5				push af 
ccda e5				push hl 
ccdb e5				push hl 
ccdc e5			push hl 
ccdd cd af 8a			call clear_display 
cce0 e1			pop hl 
cce1 7c				ld a,h 
cce2 21 cc e5			ld hl, os_word_scratch 
cce5 cd dd 8f			call hexout 
cce8 e1				pop hl 
cce9 7d				ld a,l 
ccea 21 ce e5			ld hl, os_word_scratch+2 
cced cd dd 8f			call hexout 
ccf0 21 d0 e5			ld hl, os_word_scratch+4 
ccf3 3e 00			ld a,0 
ccf5 77				ld (hl),a 
ccf6 11 cc e5			ld de,os_word_scratch 
ccf9 3e 28				ld a, display_row_2 
ccfb cd c2 8a				call str_at_display 
ccfe 11 24 cc			ld de, .push_malloc 
cd01 3e 00			ld a, display_row_1 
cd03			 
cd03 cd c2 8a				call str_at_display 
cd06			 
cd06				; display current data stack pointer 
cd06 11 ea cb			ld de,.data_sp 
cd09 3e 30				ld a, display_row_2 + 8 
cd0b cd c2 8a				call str_at_display 
cd0e			 
cd0e 2a f4 e9			ld hl,(cli_data_sp) 
cd11 e5				push hl 
cd12 7c				ld a,h 
cd13 21 cc e5			ld hl, os_word_scratch 
cd16 cd dd 8f			call hexout 
cd19 e1				pop hl 
cd1a 7d				ld a,l 
cd1b 21 ce e5			ld hl, os_word_scratch+2 
cd1e cd dd 8f			call hexout 
cd21 21 d0 e5			ld hl, os_word_scratch+4 
cd24 3e 00			ld a,0 
cd26 77				ld (hl),a 
cd27 11 cc e5			ld de,os_word_scratch 
cd2a 3e 33				ld a, display_row_2 + 11 
cd2c cd c2 8a				call str_at_display 
cd2f			 
cd2f cd d2 8a			call update_display 
cd32 cd f2 89			call delay1s 
cd35 cd f2 89			call delay1s 
cd38 e1				pop hl 
cd39 f1				pop af 
cd3a c9				ret 
cd3b			;endif 
cd3b			 
cd3b			include "forth_autostart.asm" 
cd3b			; list of commands to perform at system start up 
cd3b			 
cd3b			startcmds: 
cd3b			;	dw test11 
cd3b			;	dw test12 
cd3b			;	dw test13 
cd3b			;	dw test14 
cd3b			;	dw test15 
cd3b			;	dw test16 
cd3b			;	dw test17 
cd3b			;	dw ifthtest1 
cd3b			;	dw ifthtest2 
cd3b			;	dw ifthtest3 
cd3b			;	dw mmtest1 
cd3b			;	dw mmtest2 
cd3b			;	dw mmtest3 
cd3b			;	dw mmtest4 
cd3b			;	dw mmtest5 
cd3b			;	dw mmtest6 
cd3b			;	dw iftest1 
cd3b			;	dw iftest2 
cd3b			;	dw iftest3 
cd3b			;	dw looptest1 
cd3b			;	dw looptest2 
cd3b			;	dw test1 
cd3b			;	dw test2 
cd3b			;	dw test3 
cd3b			;	dw test4 
cd3b			;	dw game2r 
cd3b			;	dw game2b1 
cd3b			;	dw game2b2 
cd3b			 
cd3b				; start up words that are actually useful 
cd3b			 
cd3b 43 ce		    dw spi1 
cd3d 9c ce		    dw spi2 
cd3f 2a cf		    dw spi3 
cd41 d2 ce		    dw spi4 
cd43 fd ce		    dw spi5 
cd45 90 cf		    dw spi6 
cd47 e5 cf		    dw spi7 
cd49			 
cd49 3d d0		    dw spi8 
cd4b 5c d0		    dw spi9 
cd4d b4 d0		    dw spi10 
cd4f			 
cd4f			; file editor 
cd4f b5 cd			dw edit1 
cd51 d6 cd			dw edit2 
cd53 0b ce			dw edit3 
cd55			 
cd55 27 d1			dw longread 
cd57 6e d1			dw clrstack 
cd59 a1 d1			dw type 
cd5b 8c d3			dw stest 
cd5d c5 d1			dw strncpy 
cd5f 22 d3			dw list 
cd61 26 d2			dw start1 
cd63 36 d2			dw start2 
cd65			;	dw start3 
cd65 47 d2			dw start3b 
cd67 c2 d2			dw start3c 
cd69			 
cd69				; (unit) testing words 
cd69			 
cd69 03 d4			dw mtesta 
cd6b b8 d4			dw mtestb 
cd6d 5b d5			dw mtestc 
cd6f 10 d6			dw mtestd 
cd71 b4 d6			dw mteste 
cd73			 
cd73				; demo/game words 
cd73			 
cd73 c0 dd		        dw game3w 
cd75 ee dd		        dw game3p 
cd77 0c de		        dw game3sc 
cd79 3d de		        dw game3vsi 
cd7b 69 de		        dw game3vs 
cd7d				 
cd7d b3 db			dw game2b 
cd7f 21 dc			dw game2bf 
cd81 6b dc			dw game2mba 
cd83 01 dd			dw game2mbas 
cd85 43 dd			dw game2mb 
cd87			 
cd87 74 d8			dw game1 
cd89 85 d8			dw game1a 
cd8b e7 d8			dw game1b 
cd8d 1c d9			dw game1c 
cd8f 52 d9			dw game1d 
cd91 83 d9			dw game1s 
cd93 97 d9			dw game1t 
cd95 ac d9			dw game1f 
cd97 e0 d9			dw game1z 
cd99 24 da			dw game1zz 
cd9b			 
cd9b 6a d7			dw test5 
cd9d a2 d7			dw test6 
cd9f da d7			dw test7 
cda1 ee d7			dw test8 
cda3 1a d8			dw test9 
cda5 30 d8			dw test10 
cda7				 
cda7 fb da		        dw ssv5 
cda9 df da		        dw ssv4 
cdab c3 da		        dw ssv3 
cdad 8d da		        dw ssv2 
cdaf 14 db		        dw ssv1 
cdb1 5c db		        dw ssv1cpm 
cdb3			;	dw keyup 
cdb3			;	dw keydown 
cdb3			;	dw keyleft 
cdb3			;	dw keyright 
cdb3			;	dw 	keyf1 
cdb3			;	dw keyf2 
cdb3			;	dw keyf3 
cdb3			;	dw keyf4 
cdb3			;	dw keyf5 
cdb3			;	dw keyf6 
cdb3			;	dw keyf7 
cdb3			;	dw keyf8 
cdb3			;	dw keyf9 
cdb3			;	dw keyf10 
cdb3			;	dw keyf11 
cdb3			;	dw keyf12 
cdb3			;	dw keytab 
cdb3			;	dw keycr 
cdb3			;	dw keyhome 
cdb3			;	dw keyend 
cdb3			;	dw keybs 
cdb3 00 00			db 0, 0	 
cdb5			 
cdb5			 
cdb5			; File Editor 
cdb5			 
cdb5			; ( id - ) use 'e' to edit the displayed line 
cdb5 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cdd6 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
ce0b			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
ce0b .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
ce43			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
ce43			 
ce43			; SPI Net support words 
ce43			 
ce43			; v0! = node to send to 
ce43			; ( str count - ) 
ce43 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
ce9c			 
ce9c			; spiputchr ( char node - ) 
ce9c .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
ced2			 
ced2			; spigetchr ( - n ) 
ced2 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
cefd			 
cefd			; getnode ( - n ) 
cefd .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
cf2a			 
cf2a			; ( str node - )  
cf2a .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cf90			; store string ( str i - ) 
cf90			 
cf90			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cf90 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cfe5			 
cfe5			; get string ( addr i -  )    TO FIX 
cfe5			 
cfe5 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d03d			 
d03d			 
d03d			; NETCHAT (TODO) 
d03d			; Program to allow two nodes to chat with eachother 
d03d			; 
d03d			; v0 - target node 
d03d			;  
d03d			; accept input at 0,0 
d03d			; if input is string send spitype to target node 
d03d			; starting at row 2,0 , while spigetchr is not zero ->  
d03d			; 
d03d			; 
d03d			; TODO add paging of get request 
d03d			 
d03d			; ( node - ) 
d03d .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d05c .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d0b4 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
d127			 
d127			 
d127			; Long read of currently open file 
d127 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d16e			 
d16e			; clear stack  
d16e			 
d16e .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
d1a1			 
d1a1			; type ( addr count - ) 
d1a1 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
d1c5			 
d1c5			; some direct memory words 
d1c5			; strncpy ( len t f -- t ) 
d1c5			 
d1c5 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d226			 
d226 .. 00		start1:     	db ": bpon $00 bp ;",0 
d236 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d247 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d2c2 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d322			 
d322			 
d322			; a handy word to list items on the stack 
d322			 
d322 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d38c			 
d38c			 
d38c			; test stack  
d38c			; rnd8 stest 
d38c			 
d38c .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d403			 
d403			; random malloc and free cycles 
d403			 
d403 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d4b8			 
d4b8			; fixed malloc and free cycles 
d4b8			 
d4b8 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d55b			 
d55b			; fixed double string push and drop cycle  
d55b			 
d55b .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d610			 
d610			; consistent fixed string push and drop cycle  
d610			 
d610 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d6b4			 
d6b4 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d76a			 
d76a			;test1:		db ": aa 1 2 3 ;", 0 
d76a			;test2:     	db "111 aa 888 999",0 
d76a			;test3:     	db ": bb 77 ;",0 
d76a			;test4:     	db "$02 $01 do i . loop bb",0 
d76a			 
d76a .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d7a2 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d7da .. 00		test7:     	db ": box hline vline ;",0 
d7ee .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d81a .. 00		test9:     	db ": sw $01 adsp world ;",0 
d830 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d855 .. 00		test11:     	db "hello create .",0 
d864 .. 00		test12:     	db "hello2 create .",0 
d874			 
d874			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d874			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d874			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d874			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d874			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d874			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d874			 
d874			;iftest1:     	db "$0001 IF cls .",0 
d874			;iftest2:     	db "$0000 IF cls .",0 
d874			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d874			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d874			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d874			 
d874			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d874			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d874			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d874			 
d874			 
d874			 
d874			; a small guess the number game 
d874			 
d874 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d885 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d8e7			 
d8e7 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d91c .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d952 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d983 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d997 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d9ac .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
d9e0 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
da24			 
da24			; Using 'ga' save a high score across multiple runs using external storage 
da24			 
da24 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
da8d			 
da8d			 
da8d			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
da8d			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
da8d			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
da8d			 
da8d			; simple screen saver to test code memory reuse to destruction 
da8d			 
da8d .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
dac3 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
dadf .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
dafb .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
db14 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
db5c .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
dbb3			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
dbb3			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
dbb3			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
dbb3			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
dbb3			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
dbb3			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
dbb3			 
dbb3			 
dbb3			 
dbb3			; minesweeper/battleship finding game 
dbb3			; draws a game board of random ship/mine positions 
dbb3			; user enters coords to see if it hits on 
dbb3			; game ends when all are hit 
dbb3			; when hit or miss says how many may be in the area 
dbb3			 
dbb3			; setup the game board and then hide it 
dbb3 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
dc21 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dc6b			; prompt for where to target 
dc6b .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
dd01 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
dd26			; TODO see if the entered coords hits or misses pushes char hit of miss 
dd26 .. 00		game2mbht:      db ": mbckht nop ;",0 
dd35 .. 00		game2mbms:      db ": mbcms nop ;",0 
dd43			; TODO how many might be near by 
dd43 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
ddc0			 
ddc0			; Game 3 
ddc0			 
ddc0			; Vert scroller ski game - avoid the trees! 
ddc0			 
ddc0			; v0 score (ie turns) 
ddc0			; v1 player pos 
ddc0			; v2 left wall 
ddc0			; v3 right wall 
ddc0			 
ddc0			; Draw side walls randomly 
ddc0			 
ddc0 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
ddee			 
ddee			; Draw player 
ddee .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
de0c			 
de0c			; TODO Get Key 
de0c			 
de0c			; TODO Move left right 
de0c			 
de0c			; scroll and move walls a bit 
de0c			 
de0c .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
de3d			 
de3d			; main game loop 
de3d			 
de3d .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
de69 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
dea8			 
dea8			; key board defs 
dea8			 
dea8 .. 00		keyup:       db ": keyup $05 ;",0 
deb6 .. 00		keydown:       db ": keydown $0a ;",0 
dec6 .. 00		keyleft:       db ": keyleft $0b ;",0 
ded6 .. 00		keyright:       db ": keyright $0c ;",0 
dee7 .. 00		keyf1:       db ": keyf1 $10 ;",0 
def5 .. 00		keyf2:       db ": keyf2 $11 ;",0 
df03 .. 00		keyf3:       db ": keyf3 $12 ;",0 
df11 .. 00		keyf4:       db ": keyf4 $13 ;",0 
df1f .. 00		keyf5:       db ": keyf5 $14 ;",0 
df2d .. 00		keyf6:       db ": keyf6 $15 ;",0 
df3b .. 00		keyf7:       db ": keyf7 $16 ;",0 
df49 .. 00		keyf8:       db ": keyf8 $17 ;",0 
df57 .. 00		keyf9:       db ": keyf9 $18 ;",0 
df65 .. 00		keyf10:       db ": keyf10 $19 ;",0 
df74 .. 00		keyf11:       db ": keyf11 $1a ;",0 
df83 .. 00		keyf12:       db ": keyf12 $1b ;",0 
df92			 
df92 .. 00		keytab:       db ": keytab $09 ;",0 
dfa1 .. 00		keycr:       db ": keycr $0d ;",0 
dfaf .. 00		keyhome:       db ": keyhome $0e ;",0 
dfbf .. 00		keyend:       db ": keyend $0f ;",0 
dfce .. 00		keybs:       db ": keybs $08 ;",0 
dfdc			 
dfdc			   
dfdc			 
dfdc			 
dfdc			 
dfdc			; eof 
# End of file forth_autostart.asm
dfdc			 
dfdc			 
dfdc			 
dfdc			; stack over and underflow checks 
dfdc			 
dfdc			; init the words to detect the under/overflow 
dfdc			 
dfdc			chk_stk_init: 
dfdc				; a vague random number to check so we dont get any "lucky" hits 
dfdc 3e 2d			ld a, 45 
dfde 6f				ld l, a 
dfdf 00				nop 
dfe0 3e 17			ld a, 23 
dfe2 67				ld h, a 
dfe3			 
dfe3 22 ae e2			ld (chk_word), hl     ; the word we need to check against 
dfe6			 
dfe6			;	ld (chk_stund), hl	; stack points.... 
dfe6 22 00 ef			ld (chk_stovr), hl 
dfe9 22 f2 e9			ld (chk_ret_und), hl 
dfec 22 b0 e9			ld (chk_ret_ovr), hl 
dfef 22 2e e9			ld (chk_loop_ovr), hl 
dff2 22 2c e8			ld (chk_data_ovr), hl 
dff5 c9				ret 
dff6				 
dff6			check_stacks: 
dff6				; check all stack words 
dff6			 
dff6 e5				push hl 
dff7 d5				push de 
dff8			 
dff8			;	ld de,(chk_word) 
dff8			;	ld hl, (chk_stund)	; stack points.... 
dff8			;	if DEBUG_STK_FAULT 
dff8			;		DMARK "FAa" 
dff8			;		CALLMONITOR 
dff8			;	endif 
dff8			;	call cmp16 
dff8			;	jp z, .chk_faulta 
dff8			; 
dff8			;	ld de, sfaultsu 
dff8			;	jp .chk_fault 
dff8			 
dff8 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
dffb ed 5b ae e2		ld de,(chk_word) 
dfff				if DEBUG_STK_FAULT 
dfff					DMARK "FAb" 
dfff					CALLMONITOR 
dfff				endif 
dfff cd fa 8c			call cmp16 
e002 28 06			jr z, .chk_fault1 
e004 11 a5 e0			ld de, sfaultso 
e007 c3 59 e0			jp .chk_fault 
e00a			.chk_fault1:  
e00a 2a f2 e9			ld hl, (chk_ret_und) 
e00d ed 5b ae e2		ld de,(chk_word) 
e011				if DEBUG_STK_FAULT 
e011					DMARK "FAU" 
e011					CALLMONITOR 
e011				endif 
e011 cd fa 8c			call cmp16 
e014 ca 1d e0			jp z, .chk_fault2 
e017 11 b5 e0			ld de, sfaultru 
e01a c3 59 e0			jp .chk_fault 
e01d			.chk_fault2:  
e01d 2a b0 e9			ld hl, (chk_ret_ovr) 
e020 ed 5b ae e2		ld de,(chk_word) 
e024				if DEBUG_STK_FAULT 
e024					DMARK "FA1" 
e024					CALLMONITOR 
e024				endif 
e024 cd fa 8c			call cmp16 
e027 ca 30 e0			jp z, .chk_fault3 
e02a 11 c3 e0			ld de, sfaultro 
e02d c3 59 e0			jp .chk_fault 
e030			.chk_fault3:  
e030 2a 2e e9			ld hl, (chk_loop_ovr) 
e033 ed 5b ae e2		ld de,(chk_word) 
e037				if DEBUG_STK_FAULT 
e037					DMARK "FA2" 
e037					CALLMONITOR 
e037				endif 
e037 cd fa 8c			call cmp16 
e03a ca 43 e0			jp z, .chk_fault4 
e03d 11 dd e0			ld de, sfaultlo 
e040 c3 59 e0			jp .chk_fault 
e043			.chk_fault4:  
e043 2a 2c e8			ld hl, (chk_data_ovr) 
e046 ed 5b ae e2		ld de,(chk_word) 
e04a				if DEBUG_STK_FAULT 
e04a					DMARK "FA3" 
e04a					CALLMONITOR 
e04a				endif 
e04a cd fa 8c			call cmp16 
e04d ca 56 e0			jp z, .chk_fault5 
e050 11 f7 e0			ld de, sfaultdo 
e053 c3 59 e0			jp .chk_fault 
e056			 
e056			 
e056			.chk_fault5:  
e056 d1				pop de 
e057 e1				pop hl 
e058			 
e058 c9				ret 
e059			 
e059 cd af 8a		.chk_fault: 	call clear_display 
e05c 3e 28				ld a, display_row_2 
e05e cd c2 8a				call str_at_display 
e061 11 87 e0				   ld de, .stackfault 
e064 3e 00				ld a, display_row_1 
e066 cd c2 8a				call str_at_display 
e069 11 71 ee				    ld de, debug_mark 
e06c 3e 11				ld a, display_row_1+17 
e06e cd c2 8a				call str_at_display 
e071 cd d2 8a				call update_display 
e074			 
e074				; prompt before entering montior for investigating issue 
e074			 
e074 3e 78			ld a, display_row_4 
e076 11 6d 98			ld de, endprog 
e079			 
e079 cd d2 8a			call update_display		 
e07c			 
e07c cd f3 9a			call next_page_prompt 
e07f			 
e07f d1				pop de 
e080 e1				pop hl 
e081 cd c1 98				call monitor 
e084 c3 bb 97				jp warmstart 
e087					;jp 0 
e087					;halt 
e087			 
e087			 
e087			 
e087 .. 00		.stackfault: 	db "Stack fault:",0 
e094			 
e094 .. 00		sfaultsu: 	db	"Stack under flow",0 
e0a5 .. 00		sfaultso: 	db	"Stack over flow",0 
e0b5 .. 00		sfaultru:	db "RTS underflow",0 
e0c3 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e0dd .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e0f7 .. 00		sfaultdo:	db "DTS overflow", 0 
e104			 
e104			 
e104			fault_dsp_under: 
e104 11 16 e1			ld de, .dsp_under 
e107 c3 c6 e1			jp .show_fault 
e10a			 
e10a			fault_rsp_under: 
e10a 11 24 e1			ld de, .rsp_under 
e10d c3 c6 e1			jp .show_fault 
e110			fault_loop_under: 
e110 11 32 e1			ld de, .loop_under 
e113 c3 c6 e1			jp .show_fault 
e116			 
e116 .. 00		.dsp_under: db "DSP Underflow",0 
e124 .. 00		.rsp_under: db "RSP Underflow",0 
e132 .. 00		.loop_under: db "LOOP Underflow",0 
e141			 
e141			 
e141 d5			type_faultn: 	push de 
e142 e5					push hl 
e143 cd af 8a				call clear_display 
e146 11 6d e1				   ld de, .typefaultn 
e149 3e 00				ld a, display_row_1 
e14b cd c2 8a				call str_at_display 
e14e 11 71 ee				    ld de, debug_mark 
e151 3e 11				ld a, display_row_1+17 
e153 cd c2 8a				call str_at_display 
e156 cd d2 8a				call update_display 
e159			 
e159				; prompt before entering montior for investigating issue 
e159			 
e159 3e 78			ld a, display_row_4 
e15b 11 6d 98			ld de, endprog 
e15e			 
e15e cd d2 8a			call update_display		 
e161			 
e161 cd f3 9a			call next_page_prompt 
e164			 
e164 e5					push hl 
e165 d5					push de 
e166 cd c1 98				call monitor 
e169 c3 bb 97				jp warmstart 
e16c 76					halt 
e16d			 
e16d			 
e16d .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e184			 
e184 d5			type_faults: 	push de 
e185 e5					push hl 
e186 cd af 8a				call clear_display 
e189 11 af e1				   ld de, .typefaults 
e18c 3e 00				ld a, display_row_1 
e18e cd c2 8a				call str_at_display 
e191 11 71 ee				    ld de, debug_mark 
e194 3e 11				ld a, display_row_1+17 
e196 cd c2 8a				call str_at_display 
e199 cd d2 8a				call update_display 
e19c			 
e19c				; prompt before entering montior for investigating issue 
e19c			 
e19c 3e 78			ld a, display_row_4 
e19e 11 6d 98			ld de, endprog 
e1a1			 
e1a1 cd d2 8a			call update_display		 
e1a4			 
e1a4 cd f3 9a			call next_page_prompt 
e1a7			 
e1a7 e1					pop hl 
e1a8 d1					pop de 
e1a9 cd c1 98				call monitor 
e1ac c3 bb 97				jp warmstart 
e1af			 
e1af			 
e1af .. 00		.typefaults: db "STR Type Expected TOS!",0 
e1c6			 
e1c6			.show_fault: 	 
e1c6 d5					push de 
e1c7 cd af 8a				call clear_display 
e1ca d1					pop de 
e1cb 3e 00				ld a, display_row_1 
e1cd cd c2 8a				call str_at_display 
e1d0 11 71 ee				    ld de, debug_mark 
e1d3 3e 11				ld a, display_row_1+17 
e1d5 cd c2 8a				call str_at_display 
e1d8 cd d2 8a				call update_display 
e1db			 
e1db				; prompt before entering montior for investigating issue 
e1db			 
e1db 3e 78			ld a, display_row_4 
e1dd 11 6d 98			ld de, endprog 
e1e0			 
e1e0 cd d2 8a			call update_display		 
e1e3			 
e1e3 cd f3 9a			call next_page_prompt 
e1e6			 
e1e6 e1					pop hl 
e1e7 d1					pop de 
e1e8 cd c1 98				call monitor 
e1eb			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e1eb			; TODO Make optional fault restart to cli or warm boot? 
e1eb					;jp warmstart 
e1eb c3 13 98				jp cli 
e1ee 76					halt 
e1ef			 
e1ef			; handle the auto run of code from files in storage 
e1ef			 
e1ef			 
e1ef			include "forth_startup.asm" 
e1ef			; Which startup method to use? 
e1ef			; 
e1ef			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e1ef			; followed by loading of a list of scripts in eeprom 
e1ef			 
e1ef			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e1ef			; from eeprom 
e1ef			 
e1ef			; Select with define in main stubs 
e1ef			 
e1ef			if STARTUP_V1 
e1ef				include "forth_startupv1.asm" 
e1ef			; Startup script loading version 1 
e1ef			 
e1ef			; If SE storage is available first stage is to use the selected file 
e1ef			; then go through the eeprom list 
e1ef			 
e1ef .. 00		sprompt1: db "Startup load...",0 
e1ff .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e215			 
e215			 
e215			 
e215			 
e215			forth_startup: 
e215 21 3b cd			ld hl, startcmds 
e218 3e 00			ld a, 0 
e21a 32 ed e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e21d			 
e21d e5			.start1:	push hl 
e21e cd af 8a			call clear_display 
e221 11 ef e1			ld de, sprompt1 
e224 3e 00		        ld a, display_row_1 
e226 cd c2 8a			call str_at_display 
e229 11 ff e1			ld de, sprompt2 
e22c 3e 28		        ld a, display_row_2 
e22e cd c2 8a			call str_at_display 
e231 e1				pop hl 
e232 e5				push hl 
e233 5e				ld e,(hl) 
e234 23				inc hl 
e235 56				ld d,(hl) 
e236 3e 50		        ld a, display_row_3 
e238 cd c2 8a			call str_at_display 
e23b cd d2 8a			call update_display 
e23e			 
e23e			 
e23e 3a ed e6			ld a, (os_last_cmd) 
e241 fe 00			cp 0 
e243 28 05			jr z, .startprompt 
e245 cd e6 89			call delay250ms 
e248 18 24			jr .startdo 
e24a				 
e24a				 
e24a			 
e24a			.startprompt: 
e24a			 
e24a 3e 9f			ld a,display_row_4 + display_cols - 1 
e24c 11 f1 9a		        ld de, endprg 
e24f cd c2 8a			call str_at_display 
e252 cd d2 8a			call update_display 
e255 cd f2 89			call delay1s 
e258 cd 68 e3			call cin_wait 
e25b						 
e25b fe 2a			cp '*' 
e25d 28 5e			jr z, .startupend1 
e25f fe 23			cp '#' 
e261 20 07			jr nz, .startno 
e263 3e 01			ld a, 1 
e265 32 ed e6			ld (os_last_cmd),a 
e268 18 04			jr .startdo 
e26a fe 31		.startno:	cp '1' 
e26c 28 3a			jr z,.startnxt  
e26e			 
e26e				; exec startup line 
e26e			.startdo:	 
e26e e1				pop hl 
e26f e5				push hl 
e270				 
e270 5e				ld e,(hl) 
e271 23				inc hl 
e272 56				ld d,(hl) 
e273 eb				ex de,hl 
e274			 
e274 e5				push hl 
e275			 
e275 3e 00			ld a, 0 
e277				;ld a, FORTH_END_BUFFER 
e277 cd 45 91			call strlent 
e27a 23				inc hl   ; include zero term to copy 
e27b 06 00			ld b,0 
e27d 4d				ld c,l 
e27e e1				pop hl 
e27f 11 c7 e2			ld de, scratch 
e282 ed b0			ldir 
e284			 
e284			 
e284 21 c7 e2			ld hl, scratch 
e287 cd 76 9f			call forthparse 
e28a cd b6 9f			call forthexec 
e28d cd c8 9e			call forthexec_cleanup 
e290			 
e290 3e 78			ld a, display_row_4 
e292 11 6d 98			ld de, endprog 
e295			 
e295 cd d2 8a			call update_display		 
e298			 
e298 3a ed e6			ld a, (os_last_cmd) 
e29b fe 00			cp 0 
e29d 20 09			jr nz, .startnxt 
e29f cd f3 9a			call next_page_prompt 
e2a2 cd af 8a		        call clear_display 
e2a5 cd d2 8a			call update_display		 
e2a8			 
e2a8				; move onto next startup line? 
e2a8			.startnxt: 
e2a8			 
e2a8 cd e6 89			call delay250ms 
e2ab e1				pop hl 
e2ac			 
e2ac 23				inc hl 
e2ad 23				inc hl 
e2ae			 
e2ae e5				push hl 
e2af 5e				ld e, (hl) 
e2b0 23				inc hl 
e2b1 56				ld d, (hl) 
e2b2 e1				pop hl 
e2b3				; TODO replace 0 test 
e2b3			 
e2b3 eb				ex de, hl 
e2b4 cd 05 8d			call ishlzero 
e2b7			;	ld a,e 
e2b7			;	add d 
e2b7			;	cp 0    ; any left to do? 
e2b7 eb				ex de, hl 
e2b8 c2 1d e2			jp nz, .start1 
e2bb 18 01			jr .startupend 
e2bd			 
e2bd e1			.startupend1: pop hl 
e2be			.startupend: 
e2be			 
e2be cd af 8a			call clear_display 
e2c1 cd d2 8a			call update_display 
e2c4 c9				ret 
e2c5			if STORAGE_SE 
e2c5			 
e2c5			sprompt3: db "Loading from start-up file?:",0 
e2c5			sprompt4: db "(Y=Any key/N=No)",0 
e2c5			 
e2c5			 
e2c5			forth_autoload: 
e2c5			 
e2c5				; load block 0 of store 1 
e2c5				 
e2c5				ld a, $fe      ; bit 0 clear 
e2c5				ld (spi_device), a 
e2c5			 
e2c5				call storage_get_block_0 
e2c5			 
e2c5				ld a, (store_page+STORE_0_AUTOFILE) 
e2c5			 
e2c5				cp 0 
e2c5				ret z     ; auto start not enabled 
e2c5			 
e2c5				call clear_display 
e2c5			 
e2c5				; set bank 
e2c5			 
e2c5					ld a, (store_page+STORE_0_BANKRUN) 
e2c5					ld (spi_device), a 
e2c5			 
e2c5				; get file id to load from and get the file name to display 
e2c5			 
e2c5					ld a, (store_page+STORE_0_FILERUN) 
e2c5			 
e2c5					ld l, 0 
e2c5					ld h, a 
e2c5					ld de, store_page 
e2c5			 
e2c5					if DEBUG_FORTH_WORDS 
e2c5						DMARK "ASp" 
e2c5						CALLMONITOR 
e2c5					endif 
e2c5					call storage_read 
e2c5			 
e2c5					if DEBUG_FORTH_WORDS 
e2c5						DMARK "ASr" 
e2c5						CALLMONITOR 
e2c5					endif 
e2c5			 
e2c5					call ishlzero 
e2c5					ret z             ; file not found 
e2c5			 
e2c5					ld a, display_row_2 + 10 
e2c5					ld de, store_page+3 
e2c5					call str_at_display 
e2c5				 
e2c5			; 
e2c5			 
e2c5				ld a, display_row_1+5 
e2c5				ld de, sprompt3 
e2c5				call str_at_display 
e2c5				ld a, display_row_3+15 
e2c5				ld de, sprompt4 
e2c5				call str_at_display 
e2c5			 
e2c5				call update_display 
e2c5			 
e2c5				call cin_wait 
e2c5				cp 'n' 
e2c5				ret z 
e2c5				cp 'N' 
e2c5				ret z 
e2c5			 
e2c5				call delay1s 
e2c5			 
e2c5				ld a, (store_page+2) 
e2c5				ld (store_openmaxext), a    ; save count of ext 
e2c5				ld a, 1  
e2c5				ld (store_openext), a    ; save count of ext 
e2c5			 
e2c5			.autof:  
e2c5				ld l , a 
e2c5				 
e2c5				ld a, (store_page) 
e2c5				ld h, a	 
e2c5				ld de, store_page 
e2c5					if DEBUG_FORTH_WORDS 
e2c5						DMARK "ASl" 
e2c5						CALLMONITOR 
e2c5					endif 
e2c5					call storage_read 
e2c5				call ishlzero 
e2c5				ret z 
e2c5			;	jr z, .autoend 
e2c5			 
e2c5					if DEBUG_FORTH_WORDS 
e2c5						DMARK "ASc" 
e2c5						CALLMONITOR 
e2c5					endif 
e2c5				ld de, store_page+2 
e2c5				ld a, display_row_4 
e2c5				call str_at_display 
e2c5			 
e2c5				call update_display 
e2c5				call delay250ms 
e2c5			 
e2c5			 
e2c5			 
e2c5				ld hl, store_page+2 
e2c5				call forthparse 
e2c5				call forthexec 
e2c5				call forthexec_cleanup 
e2c5			 
e2c5				 
e2c5				ld a, (store_openext) 
e2c5				inc a 
e2c5				ld (store_openext), a    ; save count of ext 
e2c5			 
e2c5				jr .autof 
e2c5			;.autofdone: 
e2c5			; 
e2c5			;		if DEBUG_FORTH_WORDS 
e2c5			;			DMARK "ASx" 
e2c5			;			CALLMONITOR 
e2c5			;		endif 
e2c5			;;	call clear_display 
e2c5			;	ret 
e2c5			 
e2c5			 
e2c5			 
e2c5			endif 
# End of file forth_startupv1.asm
e2c5			endif 
e2c5			if STARTUP_V2 
e2c5				include "forth_startupv2.asm" 
e2c5			endif 
e2c5			 
# End of file forth_startup.asm
e2c5			 
e2c5			; eof 
# End of file forth_kernel.asm
e2c5			;include "nascombasic.asm" 
e2c5			 
e2c5			 
e2c5			; find out where the code ends if loaded into RAM (for SC114) 
e2c5			;endofcode:  
e2c5			;	nop 
e2c5			 
e2c5			 
e2c5			; eof 
e2c5			 
# End of file main.asm
e2c5			;include "firmware_lcd_4x40.asm" 
e2c5			;;include "firmware_lcd_4x20.asm" 
e2c5			include "firmware_serial_display.asm" 
e2c5			 
e2c5			; Serial display interface for SC114 
e2c5			 
e2c5			 
e2c5			display_row_1: equ 0 
e2c5			display_row_2: equ display_row_1+display_cols 
e2c5			display_row_3: equ display_row_2 + display_cols 
e2c5			display_row_4: equ display_row_3 + display_cols 
e2c5			 
e2c5			kLCDWidth:  EQU display_cols             ;Width in characters 
e2c5			kLCD_Line1: EQU 0x00  
e2c5			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e2c5			; E1 
e2c5			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e2c5			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e2c5			 
e2c5			lcd_init: 
e2c5				; no init as handled by the SCM bios 
e2c5 c9				ret 
e2c6			 
e2c6			 
e2c6			; low level functions for direct screen writes 
e2c6			 
e2c6			; output char at pos? 
e2c6			fLCD_Str: 
e2c6			        ;out (SC114_SIO_1_OUT),a 
e2c6 c5				push bc 
e2c7 0e 02			ld c, $02 
e2c9 f7				rst $30 
e2ca c1				pop bc 
e2cb c9				ret 
e2cc			 
e2cc			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e2cc			fLCD_Pos: 
e2cc				; use ASCII escape to position 
e2cc			        ;out (SC114_SIO_1_OUT),a 
e2cc c5				push bc 
e2cd 0e 02			ld c, $02 
e2cf f7				rst $30 
e2d0 c1				pop bc 
e2d1			 
e2d1 c9				ret 
e2d2			 
e2d2			; output char at pos 
e2d2			fLCD_Data: 
e2d2			      ;  out (SC114_SIO_1_OUT),a 
e2d2 c5				push bc 
e2d3 0e 02			ld c, $02 
e2d5 f7				rst $30 
e2d6 c1				pop bc 
e2d7			 
e2d7 c9				ret 
e2d8			 
e2d8			; ascii cls  
e2d8			 
e2d8 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e2dc			 
e2dc			; write the frame buffer given in hl to hardware  
e2dc			write_display: 
e2dc			 
e2dc			API: equ 0 
e2dc			 
e2dc			if API 
e2dc				push bc 
e2dc				ld b, 4 
e2dc			 
e2dc			        ld (display_write_tmp), hl 	  
e2dc			 
e2dc				; clear and home cursor 
e2dc			 
e2dc				ld c, 6 
e2dc				ld de, .cls 
e2dc				rst $30 
e2dc			 
e2dc			 
e2dc			.writeln: 
e2dc			 
e2dc				ld de, (display_write_tmp) 
e2dc				ld c, 6 
e2dc				rst $30 
e2dc				ld c, 7 
e2dc				rst $30 
e2dc			 
e2dc				ld hl, (display_write_tmp) 
e2dc				ld de, display_cols 
e2dc				add hl,de 
e2dc				ld (display_write_tmp),hl 
e2dc			 
e2dc				djnz  .writeln 
e2dc			 
e2dc				pop bc 
e2dc			 
e2dc			 
e2dc				ret 
e2dc			endif 
e2dc e5				push hl 
e2dd c5				push bc 
e2de d5				push de 
e2df			 
e2df			;	ld c, 2 
e2df			;	;ld de, .cls 
e2df			;	ld a, 27 
e2df			;	rst $30 
e2df			;	ld c, 2 
e2df			;	;ld de, .cls 
e2df			;	ld a, '[' 
e2df			;	rst $30 
e2df			; 
e2df			;	ld c, 2 
e2df			;	;ld de, .cls 
e2df			;	ld a, 'H' 
e2df			;	rst $30 
e2df			; 
e2df			 
e2df 0e 02			ld c, 2 
e2e1				;ld de, .cls 
e2e1 3e 1b			ld a, 27 
e2e3 f7				rst $30 
e2e4			 
e2e4			 
e2e4 0e 02			ld c, 2 
e2e6				;ld de, .cls 
e2e6 3e 5b			ld a, '[' 
e2e8 f7				rst $30 
e2e9 0e 02			ld c, 2 
e2eb				;ld de, .cls 
e2eb 3e 32			ld a, '2' 
e2ed f7				rst $30 
e2ee 0e 02			ld c, 2 
e2f0				;ld de, .cls 
e2f0 3e 4a			ld a, 'J' 
e2f2 f7				rst $30 
e2f3 d1				pop de 
e2f4 c1				pop bc 
e2f5 e1				pop hl 
e2f6			 
e2f6			 
e2f6 22 cf eb		        ld (display_write_tmp), hl 	  
e2f9 3e 00			ld a, kLCD_Line1 
e2fb			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e2fb 06 28			ld b, display_cols 
e2fd ed 5b cf eb		ld de, (display_write_tmp) 
e301 cd 5f e3			call write_len_string 
e304				 
e304			 
e304 e5			push hl 
e305 d5			push de 
e306 c5			push bc 
e307 0e 07			ld c, 7 
e309 f7				rst $30 
e30a c1			pop bc 
e30b d1			pop de 
e30c e1			pop hl 
e30d			 
e30d				 
e30d 2a cf eb			ld hl, (display_write_tmp) 
e310 11 28 00			ld de, display_cols 
e313 19				add hl,de 
e314 22 cf eb			ld (display_write_tmp),hl 
e317			 
e317				 
e317 3e 28			ld a, kLCD_Line2 
e319			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e319 06 28			ld b, display_cols 
e31b ed 5b cf eb		ld de, (display_write_tmp) 
e31f cd 5f e3			call write_len_string 
e322				 
e322 2a cf eb			ld hl, (display_write_tmp) 
e325 11 28 00			ld de, display_cols 
e328 19				add hl,de 
e329 22 cf eb			ld (display_write_tmp),hl 
e32c			 
e32c e5			push hl 
e32d d5			push de 
e32e c5			push bc 
e32f 0e 07			ld c, 7 
e331 f7				rst $30 
e332 c1			pop bc 
e333 d1			pop de 
e334 e1			pop hl 
e335			 
e335				 
e335 3e 50			ld a, kLCD_Line3 
e337			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e337 06 28			ld b, display_cols 
e339 ed 5b cf eb		ld de, (display_write_tmp) 
e33d cd 5f e3			call write_len_string 
e340				 
e340 2a cf eb			ld hl, (display_write_tmp) 
e343 11 28 00			ld de, display_cols 
e346 19				add hl,de 
e347 22 cf eb			ld (display_write_tmp),hl 
e34a			 
e34a e5			push hl 
e34b d5			push de 
e34c c5			push bc 
e34d 0e 07			ld c, 7 
e34f f7				rst $30 
e350 c1			pop bc 
e351 d1			pop de 
e352 e1			pop hl 
e353			 
e353				 
e353 3e 78			ld a, kLCD_Line4 
e355			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e355 06 28			ld b, display_cols 
e357 ed 5b cf eb		ld de, (display_write_tmp) 
e35b cd 5f e3			call write_len_string 
e35e c9					ret 
e35f			 
e35f			 
e35f				; write out a fixed length string given in b from de 
e35f			 
e35f 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e360 cd d2 e2		            CALL fLCD_Data      ;Write character to display 
e363 13				inc de 
e364 10 f9			djnz write_len_string 
e366 c9				ret 
e367			 
e367			 
e367			; eof 
# End of file firmware_serial_display.asm
e367			;include "firmware_key_5x10.asm" 
e367			;;include "firmware_key_4x10.asm" 
e367			include "firmware_key_serial.asm" 
e367			; Serial keyboard interface for SC114 
e367			 
e367			key_init: 
e367				; no init as handled by the SCM bios 
e367 c9				ret 
e368			 
e368			 
e368			cin_wait: 
e368			;	ld a, 0 
e368			;	ret 
e368			 
e368				;in a,(SC114_SIO_1_IN) 
e368			        ; Use SCM API to get from whatever console device we are using 
e368 c5				push bc 
e369 0e 01			ld c, $01 
e36b f7				rst $30 
e36c c1				pop bc 
e36d c9				ret 
e36e			 
e36e			cin: 
e36e			 
e36e			 
e36e c5				push bc 
e36f			 
e36f				; any key waiting to process? 
e36f 0e 03			ld c, $03 
e371 f7				rst $30 
e372 28 05			jr z, .cin_skip 
e374			 
e374				; yep, get it 
e374			 
e374 0e 01			ld c, $01 
e376 f7				rst $30 
e377 c1				pop bc 
e378 c9				ret 
e379			.cin_skip: 
e379 3e 00			ld a, 0 
e37b c1				pop bc 
e37c c9				ret 
e37d			 
e37d			 
e37d			 
e37d			 
# End of file firmware_key_serial.asm
e37d			endofcode:  
e37d			baseram:  
e37d 00				nop 
e37e			 
e37e			heap_start: equ baseram+15  ; Starting address of heap 
e37e			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e37e			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e37e			;VDU:  EQU     endofcode           ; BASIC Work space 
e37e			; eof 
e37e			 
# End of file os_mega_sc114.asm
e37e
