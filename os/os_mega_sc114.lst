# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 46 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 1  
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 1  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c				call break_point_state  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			debug_mark: equ hardware_word - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_write_tmp-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_view_disable - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c				ld a, ' ' 
801c				ld (os_view_disable), a 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 16 ed				ld hl, display_fb1  
801f 22 d2 eb				ld (display_fb_active), hl  
8022			  
8022 cd 75 8a				call clear_display  
8025			  
8025 21 d4 eb				ld hl, display_fb2  
8028 22 d2 eb				ld (display_fb_active), hl  
802b			  
802b cd 75 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 b7 ed				ld hl, display_fb0  
8031 22 d2 eb				ld (display_fb_active), hl  
8034			  
8034 cd 75 8a				call clear_display  
8037			  
8037			  
8037 cd 12 e2				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd b4 e2			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 45 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd 98 8a			call update_display  
8046 cd f2 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd 7a 8a			call fill_display  
804e cd 98 8a			call update_display  
8051 cd f2 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd 7a 8a			call fill_display  
8059 cd 98 8a			call update_display  
805c cd f2 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd 7a 8a			call fill_display  
8064 cd 98 8a			call update_display  
8067 cd f2 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a			        ld a, display_row_1    
806a			else  
806a 3e 0a		        ld a, display_row_1 +10   
806c			endif  
806c 11 79 96			ld de, prom_bootmsg  
806f cd 88 8a			call str_at_display  
8072 cd 98 8a			call update_display  
8075			  
8075			  
8075 cd f2 89			call delay1s  
8078 cd f2 89			call delay1s  
807b			if display_cols == 20	  
807b			            LD   A, display_row_3+2  
807b			else  
807b 3e 5c		            LD   A, display_row_3+12  
807d			endif  
807d 11 8e 96			ld de, prom_bootmsg1  
8080 cd 88 8a			call str_at_display  
8083 cd 98 8a			call update_display  
8086 cd f2 89			call delay1s  
8089 cd f2 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 71 ee		ld (debug_mark),a  
8091 32 72 ee		ld (debug_mark+1),a  
8094 32 73 ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 74 ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 7d ea			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 71 ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 72 ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 73 ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd a3 94			call break_point_state  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 84 ea			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 71 ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 72 ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 73 ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd a3 94			call break_point_state  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 84 ea				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 71 ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 72 ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 73 ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd a3 94			call break_point_state  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd cb 8c				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 7d ea				ld hl, (store_tmp1) 
8110 11 87 ea				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 71 ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 72 ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 73 ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd a3 94			call break_point_state  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 38 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 71 ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 72 ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 73 ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd a3 94			call break_point_state  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 71 ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 72 ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 73 ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd a3 94			call break_point_state  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 71 ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 72 ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 73 ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd a3 94			call break_point_state  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 71 ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 72 ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 73 ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd a3 94			call break_point_state  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd cb 8c			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 84 ea			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 86 ea			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 71 ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 72 ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 73 ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd a3 94			call break_point_state  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 71 ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 72 ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 73 ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd a3 94			call break_point_state  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 84 ea			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 71 ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 72 ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 73 ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 84 ea				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd a3 94			call break_point_state  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 85 ea			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 71 ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 72 ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 73 ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd a3 94			call break_point_state  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 71 ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 72 ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 73 ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd a3 94			call break_point_state  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd b5 89			call storage_clear_page 
829b			 
829b 21 84 ea			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 85 ea		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 87 ea		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 90 ea			ld hl, store_page+3+9 
82b5 3a 69 ea			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 84 ea			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 71 ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 72 ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 73 ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd a3 94			call break_point_state  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 71 ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 72 ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 73 ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd a3 94			call break_point_state  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd d7 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd d7 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd a2 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd d7 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd d7 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd a2 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 71 ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 72 ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 73 ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd a3 94			call break_point_state  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 87 ea		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 71 ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 72 ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 73 ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd a3 94			call break_point_state  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 84 ea			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 71 ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 72 ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 73 ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd a3 94			call break_point_state  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 71 ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 72 ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 73 ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd a3 94			call break_point_state  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd cb 8c			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 84 ea			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd cb 8c			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 71 ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 72 ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 73 ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd a3 94			call break_point_state  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 84 ea			ld a, (store_page)	; get file id 
8410 32 78 ea			ld (store_tmpid), a 
8413			 
8413 3a 86 ea			ld a, (store_page+2)    ; get count of extends 
8416 32 77 ea			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 84 ea			ld (store_page), a 
841f 32 85 ea			ld (store_page+1),a 
8422 11 84 ea			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 71 ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 72 ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 73 ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd a3 94			call break_point_state  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a 77 ea			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a 78 ea			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 71 ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 72 ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 73 ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd a3 94			call break_point_state  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd cb 8c			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 84 ea			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 84 ea			ld (store_page), a 
8482 32 85 ea			ld (store_page+1),a 
8485 11 84 ea			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 71 ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 72 ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 73 ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd a3 94			call break_point_state  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 71 ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 72 ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 73 ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd a3 94			call break_point_state  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd c0 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd a2 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd c0 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd a2 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 71 ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 72 ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 73 ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd a3 94			call break_point_state  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 71 ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 72 ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 73 ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd a3 94			call break_point_state  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd a2 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd a2 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 71 ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 72 ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 73 ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd a3 94			call break_point_state  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 84 ea			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 84 ea			ld (store_page),a 
85a3				 
85a3 32 78 ea			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 84 ea			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 71 ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 72 ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 73 ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd a3 94			call break_point_state  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 84 ea				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 71 ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 72 ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 73 ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd a3 94			call break_point_state  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 6f ea			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 71 ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 72 ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 73 ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd a3 94			call break_point_state  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 6f ea			ld (store_tmppageid), hl 
8615				 
8615 3a 78 ea			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 84 ea			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 85 ea			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 86 ea			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 87 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 71 ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 72 ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 73 ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd a3 94			call break_point_state  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd 0b 91			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 71 ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 72 ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 73 ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd a3 94			call break_point_state  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 71 ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 72 ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 73 ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd a3 94			call break_point_state  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a 6f ea			ld hl,(store_tmppageid) 
868b 11 84 ea			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 71 ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 72 ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 73 ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd a3 94			call break_point_state  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a 78 ea			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 71 ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 72 ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 73 ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd a3 94			call break_point_state  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 82 ea			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 80 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 71 ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 72 ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 73 ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd a3 94			call break_point_state  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 71 ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 72 ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 73 ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd a3 94			call break_point_state  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd cb 8c			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; save current address for use by higher level words etc 
871f			 
871f 22 75 ea			ld (store_openaddr),hl 
8722			 
8722			 
8722				; hl contains page number to load 
8722 d1				pop de   ; get storage 
8723 ed 53 80 ea		ld (store_readbuf), de     ; current buffer to load in to 
8727 d5				push de 
8728				if DEBUG_STORESE 
8728					DMARK "srg" 
8728 f5				push af  
8729 3a 3d 87			ld a, (.dmark)  
872c 32 71 ee			ld (debug_mark),a  
872f 3a 3e 87			ld a, (.dmark+1)  
8732 32 72 ee			ld (debug_mark+1),a  
8735 3a 3f 87			ld a, (.dmark+2)  
8738 32 73 ee			ld (debug_mark+2),a  
873b 18 03			jr .pastdmark  
873d ..			.dmark: db "srg"  
8740 f1			.pastdmark: pop af  
8741			endm  
# End of macro DMARK
8741					CALLMONITOR 
8741 cd a3 94			call break_point_state  
8744				endm  
# End of macro CALLMONITOR
8744				endif 
8744 cd 79 81			call storage_read_block 
8747			 
8747				; if this a continuation read??? 
8747			 
8747 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874a			 
874a 3e 3f			ld a, STORE_BLOCK_PHY-1 
874c cd a2 8c			call addatohl 
874f 7e				ld a,(hl) 
8750 fe 00			cp 0 
8752 28 02			jr z, .markiscont 
8754 3e ff			ld a, 255 
8756			 
8756			.markiscont: 
8756 32 77 ea			ld (store_readcont), a 
8759			 
8759				if DEBUG_STORESE 
8759					DMARK "srC" 
8759 f5				push af  
875a 3a 6e 87			ld a, (.dmark)  
875d 32 71 ee			ld (debug_mark),a  
8760 3a 6f 87			ld a, (.dmark+1)  
8763 32 72 ee			ld (debug_mark+1),a  
8766 3a 70 87			ld a, (.dmark+2)  
8769 32 73 ee			ld (debug_mark+2),a  
876c 18 03			jr .pastdmark  
876e ..			.dmark: db "srC"  
8771 f1			.pastdmark: pop af  
8772			endm  
# End of macro DMARK
8772					CALLMONITOR 
8772 cd a3 94			call break_point_state  
8775				endm  
# End of macro CALLMONITOR
8775				endif 
8775				; only short reads enabled 
8775			 
8775 3a 7f ea			ld a, (store_longread) 
8778 fe 00			cp 0 
877a ca 47 88			jp z, .readdone 
877d			 
877d			; TODO if block has no zeros then need to read next block  
877d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877d			; check last byte of physical block. 
877d			; if not zero then the next block needs to be loaded 
877d			 
877d			 
877d 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8780			 
8780 3e 3f			ld a, STORE_BLOCK_PHY-1 
8782 cd a2 8c			call addatohl 
8785				;dec hl 
8785 7e				ld a,(hl) 
8786				if DEBUG_STORESE 
8786					DMARK "sr?" 
8786 f5				push af  
8787 3a 9b 87			ld a, (.dmark)  
878a 32 71 ee			ld (debug_mark),a  
878d 3a 9c 87			ld a, (.dmark+1)  
8790 32 72 ee			ld (debug_mark+1),a  
8793 3a 9d 87			ld a, (.dmark+2)  
8796 32 73 ee			ld (debug_mark+2),a  
8799 18 03			jr .pastdmark  
879b ..			.dmark: db "sr?"  
879e f1			.pastdmark: pop af  
879f			endm  
# End of macro DMARK
879f					CALLMONITOR 
879f cd a3 94			call break_point_state  
87a2				endm  
# End of macro CALLMONITOR
87a2				endif 
87a2 fe 00			cp 0 
87a4 ca 47 88			jp z, .readdone 
87a7			 
87a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a7			 
87a7 23				inc hl 
87a8			 
87a8 22 80 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ab			 
87ab ed 5b 82 ea		ld de, (store_readptr)     ; save the current extent to load 
87af			 
87af eb				ex de, hl 
87b0			 
87b0				; next ext 
87b0			 
87b0 23				inc hl 
87b1 22 82 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b4			 
87b4				if DEBUG_STORESE 
87b4					DMARK "sF2" 
87b4 f5				push af  
87b5 3a c9 87			ld a, (.dmark)  
87b8 32 71 ee			ld (debug_mark),a  
87bb 3a ca 87			ld a, (.dmark+1)  
87be 32 72 ee			ld (debug_mark+1),a  
87c1 3a cb 87			ld a, (.dmark+2)  
87c4 32 73 ee			ld (debug_mark+2),a  
87c7 18 03			jr .pastdmark  
87c9 ..			.dmark: db "sF2"  
87cc f1			.pastdmark: pop af  
87cd			endm  
# End of macro DMARK
87cd					CALLMONITOR 
87cd cd a3 94			call break_point_state  
87d0				endm  
# End of macro CALLMONITOR
87d0				endif 
87d0			 
87d0				; get and load block 
87d0			 
87d0 cd ac 84			call storage_findnextid 
87d3			 
87d3				if DEBUG_STORESE 
87d3					DMARK "sf2" 
87d3 f5				push af  
87d4 3a e8 87			ld a, (.dmark)  
87d7 32 71 ee			ld (debug_mark),a  
87da 3a e9 87			ld a, (.dmark+1)  
87dd 32 72 ee			ld (debug_mark+1),a  
87e0 3a ea 87			ld a, (.dmark+2)  
87e3 32 73 ee			ld (debug_mark+2),a  
87e6 18 03			jr .pastdmark  
87e8 ..			.dmark: db "sf2"  
87eb f1			.pastdmark: pop af  
87ec			endm  
# End of macro DMARK
87ec					CALLMONITOR 
87ec cd a3 94			call break_point_state  
87ef				endm  
# End of macro CALLMONITOR
87ef				endif 
87ef cd cb 8c			call ishlzero 
87f2			;	ld a, l 
87f2			;	add h 
87f2			;	cp 0 
87f2 ca d0 86			jp z,.sr_fail			; block not found so EOF 
87f5				 
87f5				; save current address for use by higher level words etc 
87f5			 
87f5 22 75 ea			ld (store_openaddr),hl 
87f8			 
87f8 cd 79 81			call storage_read_block 
87fb			 
87fb				; on a continuation block, we now have the file id and ext in the middle of the block 
87fb				; we need to pull everything back  
87fb			 
87fb ed 5b 80 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87ff 2a 80 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8802 23				inc hl 
8803 23				inc hl     ; skip id and ext 
8804 01 40 00			ld bc, STORE_BLOCK_PHY 
8807				if DEBUG_STORESE 
8807					DMARK "SR<" 
8807 f5				push af  
8808 3a 1c 88			ld a, (.dmark)  
880b 32 71 ee			ld (debug_mark),a  
880e 3a 1d 88			ld a, (.dmark+1)  
8811 32 72 ee			ld (debug_mark+1),a  
8814 3a 1e 88			ld a, (.dmark+2)  
8817 32 73 ee			ld (debug_mark+2),a  
881a 18 03			jr .pastdmark  
881c ..			.dmark: db "SR<"  
881f f1			.pastdmark: pop af  
8820			endm  
# End of macro DMARK
8820					CALLMONITOR 
8820 cd a3 94			call break_point_state  
8823				endm  
# End of macro CALLMONITOR
8823				endif 
8823 ed b0			ldir     ; copy data 
8825			 
8825				; move the pointer back and pretend we have a full buffer for next recheck 
8825			 
8825 1b				dec de 
8826 1b				dec de 
8827			 
8827			; TODO do pop below now short circuit loop????? 
8827 c1				pop bc     ; get rid of spare de on stack 
8828				if DEBUG_STORESE 
8828					DMARK "SR>" 
8828 f5				push af  
8829 3a 3d 88			ld a, (.dmark)  
882c 32 71 ee			ld (debug_mark),a  
882f 3a 3e 88			ld a, (.dmark+1)  
8832 32 72 ee			ld (debug_mark+1),a  
8835 3a 3f 88			ld a, (.dmark+2)  
8838 32 73 ee			ld (debug_mark+2),a  
883b 18 03			jr .pastdmark  
883d ..			.dmark: db "SR>"  
8840 f1			.pastdmark: pop af  
8841			endm  
# End of macro DMARK
8841					CALLMONITOR 
8841 cd a3 94			call break_point_state  
8844				endm  
# End of macro CALLMONITOR
8844				endif 
8844 c3 d5 86			jp .srext 
8847			 
8847			 
8847			 
8847			 
8847			 
8847			.readdone:		 
8847 e1				pop hl 		 ; return start of data to show as not EOF 
8848 23				inc hl   ; past file id 
8849 23				inc hl   ; past ext 
884a				if DEBUG_STORESE 
884a					DMARK "SRe" 
884a f5				push af  
884b 3a 5f 88			ld a, (.dmark)  
884e 32 71 ee			ld (debug_mark),a  
8851 3a 60 88			ld a, (.dmark+1)  
8854 32 72 ee			ld (debug_mark+1),a  
8857 3a 61 88			ld a, (.dmark+2)  
885a 32 73 ee			ld (debug_mark+2),a  
885d 18 03			jr .pastdmark  
885f ..			.dmark: db "SRe"  
8862 f1			.pastdmark: pop af  
8863			endm  
# End of macro DMARK
8863					CALLMONITOR 
8863 cd a3 94			call break_point_state  
8866				endm  
# End of macro CALLMONITOR
8866				endif 
8866 c9					ret 
8867			 
8867			 
8867			 
8867			; 
8867			; Append File 
8867			; 
8867			; hl - file id to locate 
8867			; de - pointer to (multi block) string to write 
8867			 
8867			.sa_notfound: 
8867 d1				pop de 
8868 c9				ret 
8869			 
8869			 
8869			storage_append: 
8869				; hl -  file id to append to 
8869				; de - string to append 
8869			 
8869 d5				push de 
886a				 
886a				if DEBUG_STORESE 
886a					DMARK "AP1" 
886a f5				push af  
886b 3a 7f 88			ld a, (.dmark)  
886e 32 71 ee			ld (debug_mark),a  
8871 3a 80 88			ld a, (.dmark+1)  
8874 32 72 ee			ld (debug_mark+1),a  
8877 3a 81 88			ld a, (.dmark+2)  
887a 32 73 ee			ld (debug_mark+2),a  
887d 18 03			jr .pastdmark  
887f ..			.dmark: db "AP1"  
8882 f1			.pastdmark: pop af  
8883			endm  
# End of macro DMARK
8883					CALLMONITOR 
8883 cd a3 94			call break_point_state  
8886				endm  
# End of macro CALLMONITOR
8886				endif 
8886			 
8886 7d				ld a, l 
8887 32 78 ea			ld (store_tmpid), a 
888a			 
888a				; get file header  
888a			 
888a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888c 3a 78 ea			ld a, (store_tmpid) 
888f 5f				ld e, a 
8890			 
8890 21 40 00				ld hl, STORE_BLOCK_PHY 
8893 cd ac 84				call storage_findnextid 
8896			 
8896 cd cb 8c			call ishlzero 
8899 28 cc			jr z, .sa_notfound 
889b			 
889b 22 6f ea			ld (store_tmppageid), hl 
889e			 
889e				; TODO handle file id not found 
889e			 
889e				if DEBUG_STORESE 
889e					DMARK "AP2" 
889e f5				push af  
889f 3a b3 88			ld a, (.dmark)  
88a2 32 71 ee			ld (debug_mark),a  
88a5 3a b4 88			ld a, (.dmark+1)  
88a8 32 72 ee			ld (debug_mark+1),a  
88ab 3a b5 88			ld a, (.dmark+2)  
88ae 32 73 ee			ld (debug_mark+2),a  
88b1 18 03			jr .pastdmark  
88b3 ..			.dmark: db "AP2"  
88b6 f1			.pastdmark: pop af  
88b7			endm  
# End of macro DMARK
88b7					CALLMONITOR 
88b7 cd a3 94			call break_point_state  
88ba				endm  
# End of macro CALLMONITOR
88ba				endif 
88ba			 
88ba				; update file extent count 
88ba			 
88ba 11 84 ea			ld de, store_page 
88bd			 
88bd cd 79 81			call storage_read_block 
88c0			 
88c0				if DEBUG_STORESE 
88c0					DMARK "AP3" 
88c0 f5				push af  
88c1 3a d5 88			ld a, (.dmark)  
88c4 32 71 ee			ld (debug_mark),a  
88c7 3a d6 88			ld a, (.dmark+1)  
88ca 32 72 ee			ld (debug_mark+1),a  
88cd 3a d7 88			ld a, (.dmark+2)  
88d0 32 73 ee			ld (debug_mark+2),a  
88d3 18 03			jr .pastdmark  
88d5 ..			.dmark: db "AP3"  
88d8 f1			.pastdmark: pop af  
88d9			endm  
# End of macro DMARK
88d9					CALLMONITOR 
88d9 cd a3 94			call break_point_state  
88dc				endm  
# End of macro CALLMONITOR
88dc				endif 
88dc			;	ld (store_tmppageid), hl 
88dc			 
88dc 3a 86 ea			ld a, (store_page+2) 
88df 3c				inc a 
88e0 32 86 ea			ld (store_page+2), a 
88e3 32 77 ea			ld (store_tmpext), a 
88e6				 
88e6				if DEBUG_STORESE 
88e6					DMARK "AP3" 
88e6 f5				push af  
88e7 3a fb 88			ld a, (.dmark)  
88ea 32 71 ee			ld (debug_mark),a  
88ed 3a fc 88			ld a, (.dmark+1)  
88f0 32 72 ee			ld (debug_mark+1),a  
88f3 3a fd 88			ld a, (.dmark+2)  
88f6 32 73 ee			ld (debug_mark+2),a  
88f9 18 03			jr .pastdmark  
88fb ..			.dmark: db "AP3"  
88fe f1			.pastdmark: pop af  
88ff			endm  
# End of macro DMARK
88ff					CALLMONITOR 
88ff cd a3 94			call break_point_state  
8902				endm  
# End of macro CALLMONITOR
8902				endif 
8902 2a 6f ea			ld hl, (store_tmppageid) 
8905 11 84 ea			ld de, store_page 
8908 cd de 81			call storage_write_block 
890b			 
890b				; find free block 
890b			 
890b 11 00 00			ld de, 0			 ; file extent to locate 
890e			 
890e 21 40 00				ld hl, STORE_BLOCK_PHY 
8911 cd ac 84				call storage_findnextid 
8914 cd cb 8c			call ishlzero 
8917 ca 67 88			jp z, .sa_notfound 
891a			 
891a					; TODO handle no space left 
891a					 
891a 22 6f ea				ld (store_tmppageid), hl 
891d			 
891d				if DEBUG_STORESE 
891d					DMARK "AP4" 
891d f5				push af  
891e 3a 32 89			ld a, (.dmark)  
8921 32 71 ee			ld (debug_mark),a  
8924 3a 33 89			ld a, (.dmark+1)  
8927 32 72 ee			ld (debug_mark+1),a  
892a 3a 34 89			ld a, (.dmark+2)  
892d 32 73 ee			ld (debug_mark+2),a  
8930 18 03			jr .pastdmark  
8932 ..			.dmark: db "AP4"  
8935 f1			.pastdmark: pop af  
8936			endm  
# End of macro DMARK
8936					CALLMONITOR 
8936 cd a3 94			call break_point_state  
8939				endm  
# End of macro CALLMONITOR
8939				endif 
8939					; init the buffer with zeros so we can id if the buffer is full or not 
8939			 
8939 e5					push hl 
893a c5					push bc 
893b			 
893b 21 84 ea				ld hl, store_page 
893e 06 40				ld b, STORE_BLOCK_PHY 
8940 3e 00				ld a, 0 
8942 77			.zeroblock:	ld (hl), a 
8943 23					inc hl 
8944 10 fc				djnz .zeroblock 
8946			 
8946 c1					pop bc 
8947 e1					pop hl 
8948			 
8948					; construct block 
8948			 
8948 3a 78 ea				ld a, (store_tmpid) 
894b 32 84 ea				ld (store_page), a   ; file id 
894e 3a 77 ea				ld a, (store_tmpext)   ; extent for this block 
8951 32 85 ea				ld (store_page+1), a 
8954			 
8954 e1					pop hl    ; get string to write 
8955 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8957 11 86 ea				ld de, store_page+2 
895a			 
895a				if DEBUG_STORESE 
895a					DMARK "AP5" 
895a f5				push af  
895b 3a 6f 89			ld a, (.dmark)  
895e 32 71 ee			ld (debug_mark),a  
8961 3a 70 89			ld a, (.dmark+1)  
8964 32 72 ee			ld (debug_mark+1),a  
8967 3a 71 89			ld a, (.dmark+2)  
896a 32 73 ee			ld (debug_mark+2),a  
896d 18 03			jr .pastdmark  
896f ..			.dmark: db "AP5"  
8972 f1			.pastdmark: pop af  
8973			endm  
# End of macro DMARK
8973					CALLMONITOR 
8973 cd a3 94			call break_point_state  
8976				endm  
# End of macro CALLMONITOR
8976				endif 
8976			 
8976			 
8976			 
8976					; fill buffer with data until end of string or full block 
8976			 
8976 7e			.appd:		ld a, (hl) 
8977 12					ld (de), a 
8978 fe 00				cp 0 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f6				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a 6f ea			ld hl, (store_tmppageid) 
8985 11 84 ea			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 71 ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 72 ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 73 ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd a3 94			call break_point_state  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd de 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9 fe 00				cp 0		 ; no, string was fully written 
89ab c8					ret z 
89ac			 
89ac					; setup vars for next cycle 
89ac			 
89ac 3a 78 ea				ld a, (store_tmpid) 
89af 6f					ld l, a 
89b0 26 00				ld h, 0 
89b2			 
89b2 c3 69 88			 	jp storage_append	 ; yes, need to write out some more 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			if DEBUG_STORECF 
89b5			storageput:	 
89b5					ret 
89b5			storageread: 
89b5					ld hl, store_page 
89b5					ld b, 200 
89b5					ld a,0 
89b5			.src:		ld (hl),a 
89b5					inc hl 
89b5					djnz .src 
89b5					 
89b5			 
89b5					ld de, 0 
89b5					ld bc, 1 
89b5					ld hl, store_page 
89b5					call cfRead 
89b5			 
89b5				call cfGetError 
89b5				ld hl,scratch 
89b5				call hexout 
89b5				ld hl, scratch+2 
89b5				ld a, 0 
89b5				ld (hl),a 
89b5				ld de, scratch 
89b5				ld a,display_row_1 
89b5				call str_at_display 
89b5				call update_display 
89b5			 
89b5					ld hl, store_page 
89b5					ld (os_cur_ptr),hl 
89b5			 
89b5					ret 
89b5			endif 
89b5			 
89b5			 
89b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b5			 
89b5			storage_clear_page: 
89b5 e5				push hl 
89b6 d5				push de 
89b7 c5				push bc 
89b8 21 84 ea			ld hl, store_page 
89bb 3e 00			ld a, 0 
89bd 77				ld (hl), a 
89be			 
89be 11 85 ea			ld de, store_page+1 
89c1 01 18 01			ld bc, STORE_BLOCK_LOG 
89c4			 
89c4 ed b0			ldir 
89c6				 
89c6 c1				pop bc 
89c7 d1				pop de 
89c8 e1				pop hl 
89c9 c9				ret 
89ca			 
89ca			; eof 
# End of file firmware_storage.asm
89ca			  
89ca			; support routines for above hardware abstraction layer  
89ca			  
89ca			include "firmware_general.asm"        ; general support functions  
89ca			 
89ca			; word look up 
89ca			 
89ca			; in 
89ca			; a is the index 
89ca			; hl is pointer start of array 
89ca			; 
89ca			; returns 
89ca			; hl to the word 
89ca			; 
89ca			 
89ca			table_lookup:  
89ca d5					push de 
89cb eb					ex de, hl 
89cc			 
89cc 6f					ld l, a 
89cd 26 00				ld h, 0 
89cf 29					add hl, hl 
89d0 19					add hl, de 
89d1 7e					ld a, (hl) 
89d2 23					inc hl 
89d3 66					ld h,(hl) 
89d4 6f					ld l, a 
89d5			 
89d5 d1					pop de 
89d6 c9					ret 
89d7			 
89d7			; Delay loops 
89d7			 
89d7			 
89d7			 
89d7			aDelayInMS: 
89d7 c5				push bc 
89d8 47				ld b,a 
89d9			msdelay: 
89d9 c5				push bc 
89da				 
89da			 
89da 01 41 00			ld bc,041h 
89dd cd f5 89			call delayloop 
89e0 c1				pop bc 
89e1 05				dec b 
89e2 20 f5			jr nz,msdelay 
89e4			 
89e4			;if CPU_CLOCK_8MHZ 
89e4			;msdelay8: 
89e4			;	push bc 
89e4			;	 
89e4			; 
89e4			;	ld bc,041h 
89e4			;	call delayloop 
89e4			;	pop bc 
89e4			;	dec b 
89e4			;	jr nz,msdelay8 
89e4			;endif 
89e4			 
89e4			 
89e4 c1				pop bc 
89e5 c9				ret 
89e6			 
89e6			 
89e6			delay250ms: 
89e6				;push de 
89e6 01 00 40			ld bc, 04000h 
89e9 c3 f5 89			jp delayloop 
89ec			delay500ms: 
89ec				;push de 
89ec 01 00 80			ld bc, 08000h 
89ef c3 f5 89			jp delayloop 
89f2			delay1s: 
89f2				;push bc 
89f2			   ; Clobbers A, d and e 
89f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f5			delayloop: 
89f5 c5			    push bc 
89f6			 
89f6			if BASE_CPM 
89f6				ld bc, CPM_DELAY_TUNE 
89f6			.cpmloop: 
89f6				push bc 
89f6			 
89f6			endif 
89f6			 
89f6			 
89f6			 
89f6			delayloopi: 
89f6			;	push bc 
89f6			;.dl: 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa cb 47		    bit     0,a    	; 8 
89fc e6 ff		    and     255  	; 7 
89fe 0b			    dec     bc      	; 6 
89ff 79			    ld      a,c     	; 4 
8a00 b0			    or      b     	; 4 
8a01 c2 f6 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a04			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a04				;pop de 
8a04			;pop bc 
8a04			 
8a04			if BASE_CPM 
8a04				pop bc 
8a04				 
8a04			    dec     bc      	; 6 
8a04			    ld      a,c     	; 4 
8a04			    or      b     	; 4 
8a04			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a04				 
8a04			 
8a04			endif 
8a04			;if CPU_CLOCK_8MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04			 
8a04			;if CPU_CLOCK_10MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04 c1			    pop bc 
8a05			 
8a05 c9				ret 
8a06			 
8a06			 
8a06			 
8a06			; eof 
# End of file firmware_general.asm
8a06			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a06			; display routines that use the physical hardware abstraction layer 
8a06			 
8a06			 
8a06			; information window 
8a06			 
8a06			; pass hl with 1st string to display 
8a06			; pass de with 2nd string to display 
8a06			 
8a06			info_panel: 
8a06 e5				push hl 
8a07			 
8a07 2a d2 eb			ld hl, (display_fb_active) 
8a0a e5				push hl    ; future de destination 
8a0b 21 b7 ed				ld hl, display_fb0 
8a0e 22 d2 eb				ld (display_fb_active), hl 
8a11			 
8a11			;	call clear_display 
8a11			 
8a11				if BASE_CPM 
8a11				ld a, '.' 
8a11				else 
8a11 3e a5			ld a, 165 
8a13				endif 
8a13 cd 7a 8a			call fill_display 
8a16			 
8a16			 
8a16 3e 55			ld a, display_row_3 + 5 
8a18 cd 88 8a			call str_at_display 
8a1b			 
8a1b e1				pop hl 
8a1c d1				pop de 
8a1d			 
8a1d e5				push hl 
8a1e			 
8a1e			 
8a1e 3e 2d			ld a, display_row_2 + 5 
8a20 cd 88 8a			call str_at_display 
8a23			 
8a23			 
8a23 cd 98 8a			call update_display 
8a26 cd 8c 9a			call next_page_prompt 
8a29 cd 75 8a			call clear_display 
8a2c			 
8a2c				 
8a2c 21 16 ed				ld hl, display_fb1 
8a2f 22 d2 eb				ld (display_fb_active), hl 
8a32 cd 98 8a			call update_display 
8a35			 
8a35 e1				pop hl 
8a36			 
8a36 c9				ret 
8a37			 
8a37			 
8a37			 
8a37			 
8a37			; TODO windowing? 
8a37			 
8a37			; TODO scroll line up 
8a37			 
8a37			scroll_up: 
8a37			 
8a37 e5				push hl 
8a38 d5				push de 
8a39 c5				push bc 
8a3a			 
8a3a				; get frame buffer  
8a3a			 
8a3a 2a d2 eb			ld hl, (display_fb_active) 
8a3d e5				push hl    ; future de destination 
8a3e			 
8a3e 11 28 00			ld  de, display_cols 
8a41 19				add hl, de 
8a42			 
8a42 d1				pop de 
8a43			 
8a43				;ex de, hl 
8a43 01 9f 00			ld bc, display_fb_len -1  
8a46			;if DEBUG_FORTH_WORDS 
8a46			;	DMARK "SCL" 
8a46			;	CALLMONITOR 
8a46			;endif	 
8a46 ed b0			ldir 
8a48			 
8a48				; wipe bottom row 
8a48			 
8a48			 
8a48 2a d2 eb			ld hl, (display_fb_active) 
8a4b 11 a0 00			ld de, display_cols*display_rows 
8a4e 19				add hl, de 
8a4f 06 28			ld b, display_cols 
8a51 3e 20			ld a, ' ' 
8a53			.scwipe: 
8a53 77				ld (hl), a 
8a54 2b				dec hl 
8a55 10 fc			djnz .scwipe 
8a57			 
8a57				;pop hl 
8a57			 
8a57 c1				pop bc 
8a58 d1				pop de 
8a59 e1				pop hl 
8a5a			 
8a5a c9				ret 
8a5b			 
8a5b			 
8a5b			;scroll_upo: 
8a5b			;	ld de, display_row_1 
8a5b			 ;	ld hl, display_row_2 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			;	ld de, display_row_2 
8a5b			 ;	ld hl, display_row_3 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			;	ld de, display_row_3 
8a5b			 ;	ld hl, display_row_4 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			 
8a5b			; TODO clear row 4 
8a5b			 
8a5b			;	ret 
8a5b			 
8a5b				 
8a5b			scroll_down: 
8a5b			 
8a5b e5				push hl 
8a5c d5				push de 
8a5d c5				push bc 
8a5e			 
8a5e				; get frame buffer  
8a5e			 
8a5e 2a d2 eb			ld hl, (display_fb_active) 
8a61			 
8a61 11 9f 00			ld de, display_fb_len - 1 
8a64 19				add hl, de 
8a65			 
8a65 e5			push hl    ; future de destination 
8a66			 
8a66 11 28 00			ld  de, display_cols 
8a69 ed 52			sbc hl, de 
8a6b			 
8a6b			 
8a6b d1				pop de 
8a6c			 
8a6c			;	ex de, hl 
8a6c 01 9f 00			ld bc, display_fb_len -1  
8a6f			 
8a6f			 
8a6f				 
8a6f			 
8a6f ed b0			ldir 
8a71			 
8a71				; wipe bottom row 
8a71			 
8a71			 
8a71			;	ld hl, (display_fb_active) 
8a71			;;	ld de, display_cols*display_rows 
8a71			;;	add hl, de 
8a71			;	ld b, display_cols 
8a71			;	ld a, ' ' 
8a71			;.scwiped: 
8a71			;	ld (hl), a 
8a71			;	dec hl 
8a71			;	djnz .scwiped 
8a71			 
8a71				;pop hl 
8a71			 
8a71 c1				pop bc 
8a72 d1				pop de 
8a73 e1				pop hl 
8a74			 
8a74 c9				ret 
8a75			;scroll_down: 
8a75			;	ld de, display_row_4 
8a75			;	ld hl, display_row_3 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;	ld de, display_row_3 
8a75			; 	ld hl, display_row_2 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;	ld de, display_row_2 
8a75			;	ld hl, display_row_1 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;;; TODO clear row 1 
8a75			;	ret 
8a75			 
8a75			 
8a75			 
8a75			 
8a75			 
8a75			; clear active frame buffer 
8a75			 
8a75			clear_display: 
8a75 3e 20			ld a, ' ' 
8a77 c3 7a 8a			jp fill_display 
8a7a			 
8a7a			; fill active frame buffer with a char in A 
8a7a			 
8a7a			fill_display: 
8a7a 06 a0			ld b,display_fb_len 
8a7c 2a d2 eb			ld hl, (display_fb_active) 
8a7f 77			.fd1:	ld (hl),a 
8a80 23				inc hl 
8a81 10 fc			djnz .fd1 
8a83 23				inc hl 
8a84 3e 00			ld a,0 
8a86 77				ld (hl),a 
8a87			 
8a87			 
8a87 c9				ret 
8a88			; Write string (DE) at pos (A) to active frame buffer 
8a88			 
8a88 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
8a8b 06 00					ld b,0 
8a8d 4f					ld c,a 
8a8e 09					add hl,bc 
8a8f 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8a90 b7			            OR   A              ;Null terminator? 
8a91 c8			            RET  Z              ;Yes, so finished 
8a92 77					ld (hl),a 
8a93 23				inc hl 
8a94 13			            INC  DE             ;Point to next character 
8a95 18 f8		            JR   .sad1     ;Repeat 
8a97 c9					ret 
8a98			 
8a98			; using current frame buffer write to physical display 
8a98			 
8a98			update_display: 
8a98 e5				push hl 
8a99 2a d2 eb			ld hl, (display_fb_active) 
8a9c cd 29 e2			call write_display 
8a9f e1				pop hl 
8aa0 c9				ret 
8aa1			 
8aa1			; TODO scrolling 
8aa1			 
8aa1			 
8aa1			; move cursor right one char 
8aa1			cursor_right: 
8aa1			 
8aa1				; TODO shift right 
8aa1				; TODO if beyond max col 
8aa1				; TODO       cursor_next_line 
8aa1			 
8aa1 c9				ret 
8aa2			 
8aa2			 
8aa2			cursor_next_line: 
8aa2				; TODO first char 
8aa2				; TODO line down 
8aa2				; TODO if past last row 
8aa2				; TODO    scroll up 
8aa2			 
8aa2 c9				ret 
8aa3			 
8aa3			cursor_left: 
8aa3				; TODO shift left 
8aa3				; TODO if beyond left  
8aa3				; TODO     cursor prev line 
8aa3				 
8aa3 c9				ret 
8aa4			 
8aa4			cursor_prev_line: 
8aa4				; TODO last char 
8aa4				; TODO line up 
8aa4				; TODO if past first row 
8aa4				; TODO   scroll down 
8aa4			 
8aa4 c9				ret 
8aa5			 
8aa5			 
8aa5			cout: 
8aa5				; A - char 
8aa5 c9				ret 
8aa6			 
8aa6			 
8aa6			; Display a menu and allow item selection (optional toggle items) 
8aa6			; 
8aa6			; format: 
8aa6			; hl pointer to word array with zero term for items 
8aa6			; e.g.    db item1 
8aa6			;         db .... 
8aa6			;         db 0 
8aa6			; 
8aa6			; a = starting menu item  
8aa6			; 
8aa6			; de = pointer item toggle array   (todo) 
8aa6			; 
8aa6			; returns item selected in a 1-... 
8aa6			; returns 0 if back button pressed 
8aa6			; 
8aa6			; NOTE: Uses system frame buffer to display 
8aa6			; 
8aa6			; LEFT, Q = go back 
8aa6			; RIGHT, SPACE, CR = select 
8aa6			; UP, A - Up 
8aa6			; DOWN, Z - Down 
8aa6			 
8aa6			 
8aa6			 
8aa6			 
8aa6			 
8aa6			menu: 
8aa6			 
8aa6					; keep array pointer 
8aa6			 
8aa6 22 7d ea				ld (store_tmp1), hl 
8aa9 32 7b ea				ld (store_tmp2), a 
8aac			 
8aac					; check for key bounce 
8aac			 
8aac			if BASE_KEV 
8aac			 
8aac			.mbounce:	call cin 
8aac					cp 0 
8aac					jr nz, .mbounce 
8aac			endif 
8aac					; for ease use ex 
8aac			 
8aac					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8aac 21 b7 ed				ld hl, display_fb0 
8aaf 22 d2 eb				ld (display_fb_active), hl 
8ab2			 
8ab2 cd 75 8a		.mloop:		call clear_display 
8ab5 cd 98 8a				call update_display 
8ab8			 
8ab8					; draw selection id '>' at 1 
8ab8			 
8ab8					; init start of list display 
8ab8			 
8ab8 3e 05				ld a, 5 
8aba 32 79 ea				ld (store_tmp3), a   ; display row count 
8abd 3a 7b ea				ld a,( store_tmp2) 
8ac0 32 7c ea				ld (store_tmp2+1), a   ; display item count 
8ac3			 
8ac3					 
8ac3			.mitem:	 
8ac3			 
8ac3			 
8ac3 3a 7c ea				ld a,(store_tmp2+1) 
8ac6 6f					ld l, a 
8ac7 26 00				ld h, 0 
8ac9 29					add hl, hl 
8aca ed 5b 7d ea			ld de, (store_tmp1) 
8ace 19					add hl, de 
8acf 7e					ld a, (hl) 
8ad0 23					inc hl 
8ad1 66					ld h,(hl) 
8ad2 6f					ld l, a 
8ad3			 
8ad3 cd cb 8c				call ishlzero 
8ad6 28 1a				jr z, .mdone 
8ad8			 
8ad8 eb					ex de, hl 
8ad9 3a 79 ea				ld a, (store_tmp3) 
8adc cd 88 8a				call str_at_display 
8adf					 
8adf			 
8adf					; next item 
8adf 3a 7c ea				ld a, (store_tmp2+1) 
8ae2 3c					inc a 
8ae3 32 7c ea				ld (store_tmp2+1), a   ; display item count 
8ae6			 
8ae6			 		; next row 
8ae6			 
8ae6 3a 79 ea				ld a, (store_tmp3) 
8ae9 c6 28				add display_cols 
8aeb 32 79 ea				ld (store_tmp3), a 
8aee			 
8aee					; at end of screen? 
8aee			 
8aee fe 10				cp display_rows*4 
8af0 20 d1				jr nz, .mitem 
8af2			 
8af2			 
8af2			.mdone: 
8af2 cd cb 8c				call ishlzero 
8af5 28 08				jr z, .nodn 
8af7			 
8af7 3e 78				ld a, display_row_4 
8af9 11 78 8b				ld de, .mdown 
8afc cd 88 8a				call str_at_display 
8aff			 
8aff					; draw options to fill the screens with active item on line 1 
8aff					; if current option is 2 or more then display ^ in top 
8aff			 
8aff 3a 7b ea		.nodn:		ld a, (store_tmp2) 
8b02 fe 00				cp 0 
8b04 28 08				jr z, .noup 
8b06			 
8b06 3e 00				ld a, 0 
8b08 11 76 8b				ld de, .mup 
8b0b cd 88 8a				call str_at_display 
8b0e			 
8b0e 3e 02		.noup:		ld a, 2 
8b10 11 74 8b				ld de, .msel 
8b13 cd 88 8a				call str_at_display 
8b16			 
8b16					; if current option + 1 is not null then display V in bottom 
8b16					; get key 
8b16 cd 98 8a				call update_display 
8b19			 
8b19			 
8b19					; handle key 
8b19			 
8b19 cd b5 e2				call cin_wait 
8b1c			 
8b1c fe 05				cp KEY_UP 
8b1e 28 2b				jr z, .mgoup 
8b20 fe 61				cp 'a' 
8b22 28 27				jr z, .mgoup 
8b24 fe 0a				cp KEY_DOWN 
8b26 28 32				jr z, .mgod 
8b28 fe 7a				cp 'z' 
8b2a 28 2e				jr z, .mgod 
8b2c fe 20				cp ' ' 
8b2e 28 34				jr z, .goend 
8b30 fe 0c				cp KEY_RIGHT 
8b32 28 30				jr z, .goend 
8b34 fe 0d				cp KEY_CR 
8b36 28 2c				jr z, .goend 
8b38 fe 71				cp 'q' 
8b3a 28 0b				jr z, .goback 
8b3c			 
8b3c fe 0b				cp KEY_LEFT 
8b3e 28 07				jr z, .goback 
8b40 fe 08				cp KEY_BS 
8b42 28 03				jr z, .goback 
8b44 c3 b2 8a				jp .mloop 
8b47			 
8b47			.goback: 
8b47 3e 00			ld a, 0 
8b49 18 1d			jr .goend2 
8b4b			 
8b4b				; move up one 
8b4b			.mgoup: 
8b4b 3a 7b ea				ld a, (store_tmp2) 
8b4e fe 00				cp 0 
8b50 ca b2 8a				jp z, .mloop 
8b53 3d					dec a 
8b54 32 7b ea				ld (store_tmp2), a 
8b57 c3 b2 8a				jp .mloop 
8b5a			 
8b5a				; move down one 
8b5a			.mgod: 
8b5a 3a 7b ea				ld a, (store_tmp2) 
8b5d 3c					inc a 
8b5e 32 7b ea				ld (store_tmp2), a 
8b61 c3 b2 8a				jp .mloop 
8b64			 
8b64			 
8b64			.goend: 
8b64					; get selected item number 
8b64			 
8b64 3a 7b ea				ld a, (store_tmp2) 
8b67 3c					inc a 
8b68			 
8b68			.goend2: 
8b68 f5					push af 
8b69			 
8b69					; restore active fb 
8b69					; TODO BUG assumes fb1 
8b69			 
8b69 21 16 ed				ld hl, display_fb1 
8b6c 22 d2 eb				ld (display_fb_active), hl 
8b6f			 
8b6f					; restore main regs 
8b6f			 
8b6f			 
8b6f cd 98 8a				call update_display 
8b72			 
8b72 f1					pop af 
8b73			 
8b73 c9				ret 
8b74			 
8b74 .. 00		.msel:   db ">",0 
8b76 .. 00		.mup:   db "^",0 
8b78 .. 00		.mdown:   db "v",0 
8b7a			 
8b7a			 
8b7a			; eof 
8b7a			 
# End of file firmware_display.asm
8b7a			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8b7a			; random number generators 
8b7a			 
8b7a			 
8b7a			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8b7a			 
8b7a			 
8b7a			;-----> Generate a random number 
8b7a			; output a=answer 0<=a<=255 
8b7a			; all registers are preserved except: af 
8b7a			random: 
8b7a e5			        push    hl 
8b7b d5			        push    de 
8b7c 2a b4 eb		        ld      hl,(randData) 
8b7f ed 5f		        ld      a,r 
8b81 57			        ld      d,a 
8b82 5e			        ld      e,(hl) 
8b83 19			        add     hl,de 
8b84 85			        add     a,l 
8b85 ac			        xor     h 
8b86 22 b4 eb		        ld      (randData),hl 
8b89 d1			        pop     de 
8b8a e1			        pop     hl 
8b8b c9			        ret 
8b8c			 
8b8c			 
8b8c			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8b8c			 
8b8c			 
8b8c			 
8b8c			;------LFSR------ 
8b8c			;James Montelongo 
8b8c			;optimized by Spencer Putt 
8b8c			;out: 
8b8c			; a = 8 bit random number 
8b8c			RandLFSR: 
8b8c 21 ba eb		        ld hl,LFSRSeed+4 
8b8f 5e			        ld e,(hl) 
8b90 23			        inc hl 
8b91 56			        ld d,(hl) 
8b92 23			        inc hl 
8b93 4e			        ld c,(hl) 
8b94 23			        inc hl 
8b95 7e			        ld a,(hl) 
8b96 47			        ld b,a 
8b97 cb 13		        rl e  
8b99 cb 12			rl d 
8b9b cb 11		        rl c  
8b9d 17				rla 
8b9e cb 13		        rl e  
8ba0 cb 12			rl d 
8ba2 cb 11		        rl c  
8ba4 17				rla 
8ba5 cb 13		        rl e  
8ba7 cb 12			rl d 
8ba9 cb 11		        rl c  
8bab 17				rla 
8bac 67			        ld h,a 
8bad cb 13		        rl e  
8baf cb 12			rl d 
8bb1 cb 11		        rl c  
8bb3 17				rla 
8bb4 a8			        xor b 
8bb5 cb 13		        rl e  
8bb7 cb 12			rl d 
8bb9 ac			        xor h 
8bba a9			        xor c 
8bbb aa			        xor d 
8bbc 21 bc eb		        ld hl,LFSRSeed+6 
8bbf 11 bd eb		        ld de,LFSRSeed+7 
8bc2 01 07 00		        ld bc,7 
8bc5 ed b8		        lddr 
8bc7 12			        ld (de),a 
8bc8 c9			        ret 
8bc9			 
8bc9			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8bc9			 
8bc9			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8bc9			 
8bc9			 
8bc9			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8bc9			 
8bc9			prng16: 
8bc9			;Inputs: 
8bc9			;   (seed1) contains a 16-bit seed value 
8bc9			;   (seed2) contains a NON-ZERO 16-bit seed value 
8bc9			;Outputs: 
8bc9			;   HL is the result 
8bc9			;   BC is the result of the LCG, so not that great of quality 
8bc9			;   DE is preserved 
8bc9			;Destroys: 
8bc9			;   AF 
8bc9			;cycle: 4,294,901,760 (almost 4.3 billion) 
8bc9			;160cc 
8bc9			;26 bytes 
8bc9 2a ae eb		    ld hl,(seed1) 
8bcc 44			    ld b,h 
8bcd 4d			    ld c,l 
8bce 29			    add hl,hl 
8bcf 29			    add hl,hl 
8bd0 2c			    inc l 
8bd1 09			    add hl,bc 
8bd2 22 ae eb		    ld (seed1),hl 
8bd5 2a ac eb		    ld hl,(seed2) 
8bd8 29			    add hl,hl 
8bd9 9f			    sbc a,a 
8bda e6 2d		    and %00101101 
8bdc ad			    xor l 
8bdd 6f			    ld l,a 
8bde 22 ac eb		    ld (seed2),hl 
8be1 09			    add hl,bc 
8be2 c9			    ret 
8be3			 
8be3			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8be3			 
8be3			rand32: 
8be3			;Inputs: 
8be3			;   (seed1_0) holds the lower 16 bits of the first seed 
8be3			;   (seed1_1) holds the upper 16 bits of the first seed 
8be3			;   (seed2_0) holds the lower 16 bits of the second seed 
8be3			;   (seed2_1) holds the upper 16 bits of the second seed 
8be3			;   **NOTE: seed2 must be non-zero 
8be3			;Outputs: 
8be3			;   HL is the result 
8be3			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8be3			;Destroys: 
8be3			;   AF 
8be3			;Tested and passes all CAcert tests 
8be3			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8be3			;it has a period of 18,446,744,069,414,584,320 
8be3			;roughly 18.4 quintillion. 
8be3			;LFSR taps: 0,2,6,7  = 11000101 
8be3			;291cc 
8be3			;seed1_0=$+1 
8be3			;    ld hl,12345 
8be3			;seed1_1=$+1 
8be3			;    ld de,6789 
8be3			;    ld b,h 
8be3			;    ld c,l 
8be3			;    add hl,hl \ rl e \ rl d 
8be3			;    add hl,hl \ rl e \ rl d 
8be3			;    inc l 
8be3			;    add hl,bc 
8be3			;    ld (seed1_0),hl 
8be3			;    ld hl,(seed1_1) 
8be3			;    adc hl,de 
8be3			;    ld (seed1_1),hl 
8be3			;    ex de,hl 
8be3			;seed2_0=$+1 
8be3			;    ld hl,9876 
8be3			;seed2_1=$+1 
8be3			;    ld bc,54321 
8be3			;    add hl,hl \ rl c \ rl b 
8be3			;    ld (seed2_1),bc 
8be3			;    sbc a,a 
8be3			;    and %11000101 
8be3			;    xor l 
8be3			;    ld l,a 
8be3			;    ld (seed2_0),hl 
8be3			;    ex de,hl 
8be3			;    add hl,bc 
8be3			;    ret 
8be3			; 
8be3			 
8be3			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8be3			; 20 bytes, 86 cycles (excluding ret) 
8be3			 
8be3			; returns   hl = pseudorandom number 
8be3			; corrupts   a 
8be3			 
8be3			; generates 16-bit pseudorandom numbers with a period of 65535 
8be3			; using the xorshift method: 
8be3			 
8be3			; hl ^= hl << 7 
8be3			; hl ^= hl >> 9 
8be3			; hl ^= hl << 8 
8be3			 
8be3			; some alternative shift triplets which also perform well are: 
8be3			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8be3			 
8be3			;  org 32768 
8be3			 
8be3			xrnd: 
8be3 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
8be6 3e 00		  ld a,0 
8be8 bd			  cp l 
8be9 20 02		  jr nz, .xrnd1 
8beb 2e 01		  ld l, 1 
8bed			.xrnd1: 
8bed			 
8bed 7c			  ld a,h 
8bee 1f			  rra 
8bef 7d			  ld a,l 
8bf0 1f			  rra 
8bf1 ac			  xor h 
8bf2 67			  ld h,a 
8bf3 7d			  ld a,l 
8bf4 1f			  rra 
8bf5 7c			  ld a,h 
8bf6 1f			  rra 
8bf7 ad			  xor l 
8bf8 6f			  ld l,a 
8bf9 ac			  xor h 
8bfa 67			  ld h,a 
8bfb			 
8bfb 22 b2 eb		  ld (xrandc),hl 
8bfe			 
8bfe c9			  ret 
8bff			;  
8bff			 
8bff			 
8bff			;;;; int maths 
8bff			 
8bff			; https://map.grauw.nl/articles/mult_div_shifts.php 
8bff			; Divide 16-bit values (with 16-bit result) 
8bff			; In: Divide BC by divider DE 
8bff			; Out: BC = result, HL = rest 
8bff			; 
8bff			Div16: 
8bff 21 00 00		    ld hl,0 
8c02 78			    ld a,b 
8c03 06 08		    ld b,8 
8c05			Div16_Loop1: 
8c05 17			    rla 
8c06 ed 6a		    adc hl,hl 
8c08 ed 52		    sbc hl,de 
8c0a 30 01		    jr nc,Div16_NoAdd1 
8c0c 19			    add hl,de 
8c0d			Div16_NoAdd1: 
8c0d 10 f6		    djnz Div16_Loop1 
8c0f 17			    rla 
8c10 2f			    cpl 
8c11 47			    ld b,a 
8c12 79			    ld a,c 
8c13 48			    ld c,b 
8c14 06 08		    ld b,8 
8c16			Div16_Loop2: 
8c16 17			    rla 
8c17 ed 6a		    adc hl,hl 
8c19 ed 52		    sbc hl,de 
8c1b 30 01		    jr nc,Div16_NoAdd2 
8c1d 19			    add hl,de 
8c1e			Div16_NoAdd2: 
8c1e 10 f6		    djnz Div16_Loop2 
8c20 17			    rla 
8c21 2f			    cpl 
8c22 41			    ld b,c 
8c23 4f			    ld c,a 
8c24 c9			ret 
8c25			 
8c25			 
8c25			;http://z80-heaven.wikidot.com/math 
8c25			; 
8c25			;Inputs: 
8c25			;     DE and A are factors 
8c25			;Outputs: 
8c25			;     A is not changed 
8c25			;     B is 0 
8c25			;     C is not changed 
8c25			;     DE is not changed 
8c25			;     HL is the product 
8c25			;Time: 
8c25			;     342+6x 
8c25			; 
8c25			Mult16: 
8c25			 
8c25 06 08		     ld b,8          ;7           7 
8c27 21 00 00		     ld hl,0         ;10         10 
8c2a 29			       add hl,hl     ;11*8       88 
8c2b 07			       rlca          ;4*8        32 
8c2c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c2e 19			         add hl,de   ;--         -- 
8c2f 10 f9		       djnz $-5      ;13*7+8     99 
8c31 c9			ret 
8c32			 
8c32			; 
8c32			; Square root of 16-bit value 
8c32			; In:  HL = value 
8c32			; Out:  D = result (rounded down) 
8c32			; 
8c32			;Sqr16: 
8c32			;    ld de,#0040 
8c32			;    ld a,l 
8c32			;    ld l,h 
8c32			;    ld h,d 
8c32			;    or a 
8c32			;    ld b,8 
8c32			;Sqr16_Loop: 
8c32			;    sbc hl,de 
8c32			;    jr nc,Sqr16_Skip 
8c32			;    add hl,de 
8c32			;Sqr16_Skip: 
8c32			;    ccf 
8c32			;    rl d 
8c32			;    add a,a 
8c32			;    adc hl,hl 
8c32			;    add a,a 
8c32			;    adc hl,hl 
8c32			;    djnz Sqr16_Loop 
8c32			;    ret 
8c32			; 
8c32			; 
8c32			; Divide 8-bit values 
8c32			; In: Divide E by divider C 
8c32			; Out: A = result, B = rest 
8c32			; 
8c32			Div8: 
8c32 af			    xor a 
8c33 06 08		    ld b,8 
8c35			Div8_Loop: 
8c35 cb 13		    rl e 
8c37 17			    rla 
8c38 91			    sub c 
8c39 30 01		    jr nc,Div8_NoAdd 
8c3b 81			    add a,c 
8c3c			Div8_NoAdd: 
8c3c 10 f7		    djnz Div8_Loop 
8c3e 47			    ld b,a 
8c3f 7b			    ld a,e 
8c40 17			    rla 
8c41 2f			    cpl 
8c42 c9			    ret 
8c43			 
8c43			; 
8c43			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c43			; In: Multiply A with DE 
8c43			; Out: HL = result 
8c43			; 
8c43			Mult12U: 
8c43 2e 00		    ld l,0 
8c45 87			    add a,a 
8c46 30 01		    jr nc,Mult12U_NoAdd0 
8c48 19			    add hl,de 
8c49			Mult12U_NoAdd0: 
8c49 29			    add hl,hl 
8c4a 87			    add a,a 
8c4b 30 01		    jr nc,Mult12U_NoAdd1 
8c4d 19			    add hl,de 
8c4e			Mult12U_NoAdd1: 
8c4e 29			    add hl,hl 
8c4f 87			    add a,a 
8c50 30 01		    jr nc,Mult12U_NoAdd2 
8c52 19			    add hl,de 
8c53			Mult12U_NoAdd2: 
8c53 29			    add hl,hl 
8c54 87			    add a,a 
8c55 30 01		    jr nc,Mult12U_NoAdd3 
8c57 19			    add hl,de 
8c58			Mult12U_NoAdd3: 
8c58 29			    add hl,hl 
8c59 87			    add a,a 
8c5a 30 01		    jr nc,Mult12U_NoAdd4 
8c5c 19			    add hl,de 
8c5d			Mult12U_NoAdd4: 
8c5d 29			    add hl,hl 
8c5e 87			    add a,a 
8c5f 30 01		    jr nc,Mult12U_NoAdd5 
8c61 19			    add hl,de 
8c62			Mult12U_NoAdd5: 
8c62 29			    add hl,hl 
8c63 87			    add a,a 
8c64 30 01		    jr nc,Mult12U_NoAdd6 
8c66 19			    add hl,de 
8c67			Mult12U_NoAdd6: 
8c67 29			    add hl,hl 
8c68 87			    add a,a 
8c69 d0			    ret nc 
8c6a 19			    add hl,de 
8c6b c9			    ret 
8c6c			 
8c6c			; 
8c6c			; Multiply 8-bit value with a 16-bit value (right rotating) 
8c6c			; In: Multiply A with DE 
8c6c			;      Put lowest value in A for most efficient calculation 
8c6c			; Out: HL = result 
8c6c			; 
8c6c			Mult12R: 
8c6c 21 00 00		    ld hl,0 
8c6f			Mult12R_Loop: 
8c6f cb 3f		    srl a 
8c71 30 01		    jr nc,Mult12R_NoAdd 
8c73 19			    add hl,de 
8c74			Mult12R_NoAdd: 
8c74 cb 23		    sla e 
8c76 cb 12		    rl d 
8c78 b7			    or a 
8c79 c2 6f 8c		    jp nz,Mult12R_Loop 
8c7c c9			    ret 
8c7d			 
8c7d			; 
8c7d			; Multiply 16-bit values (with 32-bit result) 
8c7d			; In: Multiply BC with DE 
8c7d			; Out: BCHL = result 
8c7d			; 
8c7d			Mult32: 
8c7d 79			    ld a,c 
8c7e 48			    ld c,b 
8c7f 21 00 00		    ld hl,0 
8c82 06 10		    ld b,16 
8c84			Mult32_Loop: 
8c84 29			    add hl,hl 
8c85 17			    rla 
8c86 cb 11		    rl c 
8c88 30 07		    jr nc,Mult32_NoAdd 
8c8a 19			    add hl,de 
8c8b ce 00		    adc a,0 
8c8d d2 91 8c		    jp nc,Mult32_NoAdd 
8c90 0c			    inc c 
8c91			Mult32_NoAdd: 
8c91 10 f1		    djnz Mult32_Loop 
8c93 41			    ld b,c 
8c94 4f			    ld c,a 
8c95 c9			    ret 
8c96			 
8c96			 
8c96			 
8c96			; 
8c96			; Multiply 8-bit values 
8c96			; In:  Multiply H with E 
8c96			; Out: HL = result 
8c96			; 
8c96			Mult8: 
8c96 16 00		    ld d,0 
8c98 6a			    ld l,d 
8c99 06 08		    ld b,8 
8c9b			Mult8_Loop: 
8c9b 29			    add hl,hl 
8c9c 30 01		    jr nc,Mult8_NoAdd 
8c9e 19			    add hl,de 
8c9f			Mult8_NoAdd: 
8c9f 10 fa		    djnz Mult8_Loop 
8ca1 c9			    ret 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			;;http://z80-heaven.wikidot.com/math 
8ca2			;;This divides DE by BC, storing the result in DE, remainder in HL 
8ca2			; 
8ca2			;DE_Div_BC:          ;1281-2x, x is at most 16 
8ca2			;     ld a,16        ;7 
8ca2			;     ld hl,0        ;10 
8ca2			;     jp $+5         ;10 
8ca2			;.DivLoop: 
8ca2			;       add hl,bc    ;-- 
8ca2			;       dec a        ;64 
8ca2			;       jr z,.DivLoopEnd        ;86 
8ca2			; 
8ca2			;       sla e        ;128 
8ca2			;       rl d         ;128 
8ca2			;       adc hl,hl    ;240 
8ca2			;       sbc hl,bc    ;240 
8ca2			;       jr nc,.DivLoop ;23|21 
8ca2			;       inc e        ;-- 
8ca2			;       jp .DivLoop+1 
8ca2			; 
8ca2			;.DivLoopEnd: 
8ca2			 
8ca2			;HL_Div_C: 
8ca2			;Inputs: 
8ca2			;     HL is the numerator 
8ca2			;     C is the denominator 
8ca2			;Outputs: 
8ca2			;     A is the remainder 
8ca2			;     B is 0 
8ca2			;     C is not changed 
8ca2			;     DE is not changed 
8ca2			;     HL is the quotient 
8ca2			; 
8ca2			;       ld b,16 
8ca2			;       xor a 
8ca2			;         add hl,hl 
8ca2			;         rla 
8ca2			;         cp c 
8ca2			;         jr c,$+4 
8ca2			;           inc l 
8ca2			;           sub c 
8ca2			;         djnz $-7 
8ca2			 
8ca2			; https://plutiedev.com/z80-add-8bit-to-16bit 
8ca2			 
8ca2			addatohl: 
8ca2 85			    add   a, l    ; A = A+L 
8ca3 6f			    ld    l, a    ; L = A+L 
8ca4 8c			    adc   a, h    ; A = A+L+H+carry 
8ca5 95			    sub   l       ; A = H+carry 
8ca6 67			    ld    h, a    ; H = H+carry 
8ca7 c9			ret 
8ca8			 
8ca8			addatode: 
8ca8 83			    add   a, e    ; A = A+L 
8ca9 5f			    ld    e, a    ; L = A+L 
8caa 8a			    adc   a, d    ; A = A+L+H+carry 
8cab 93			    sub   e       ; A = H+carry 
8cac 57			    ld    d, a    ; H = H+carry 
8cad c9			ret 
8cae			 
8cae			 
8cae			addatobc: 
8cae 81			    add   a, c    ; A = A+L 
8caf 4f			    ld    c, a    ; L = A+L 
8cb0 88			    adc   a, b    ; A = A+L+H+carry 
8cb1 91			    sub   c       ; A = H+carry 
8cb2 47			    ld    b, a    ; H = H+carry 
8cb3 c9			ret 
8cb4			 
8cb4			subafromhl: 
8cb4			   ; If A=0 do nothing 
8cb4			    ; Otherwise flip A's sign. Since 
8cb4			    ; the upper byte becomes -1, also 
8cb4			    ; substract 1 from H. 
8cb4 ed 44		    neg 
8cb6 ca bf 8c		    jp    z, Skip 
8cb9 25			    dec   h 
8cba			     
8cba			    ; Now add the low byte as usual 
8cba			    ; Two's complement takes care of 
8cba			    ; ensuring the result is correct 
8cba 85			    add   a, l 
8cbb 6f			    ld    l, a 
8cbc 8c			    adc   a, h 
8cbd 95			    sub   l 
8cbe 67			    ld    h, a 
8cbf			Skip: 
8cbf c9				ret 
8cc0			 
8cc0			 
8cc0			; compare hl and de 
8cc0			; returns:  
8cc0			; if hl = de, z=1, s=0, c0=0 
8cc0			; if hl > de, z=0, s=0, c=0 
8cc0			; if hl < de, z=0, s=1, c=1 
8cc0			cmp16:	 
8cc0 b7				or a 
8cc1 ed 52			sbc hl,de 
8cc3 e0				ret po 
8cc4 7c				ld a,h 
8cc5 1f				rra 
8cc6 ee 40			xor 01000000B 
8cc8 37				scf 
8cc9 8f				adc a,a 
8cca c9				ret 
8ccb			 
8ccb			 
8ccb			; test if hl contains zero   - A is destroyed 
8ccb			 
8ccb			ishlzero:    
8ccb b7				or a     ; reset flags 
8ccc 7c				ld a, h 
8ccd b5				or l        	 
8cce			 
8cce c9				ret 
8ccf			 
8ccf			 
8ccf			 
8ccf			 
8ccf			if FORTH_ENABLE_FLOATMATH 
8ccf			;include "float/bbcmath.z80" 
8ccf			include "float/lpfpcalc.asm" 
8ccf			endif 
8ccf			 
8ccf			 
8ccf			; eof 
8ccf			 
# End of file firmware_maths.asm
8ccf			include "firmware_strings.asm"   ; string handling  
8ccf			 
8ccf			 
8ccf			; TODO string len 
8ccf			; input text string, end on cr with zero term 
8ccf			; a offset into frame buffer to start prompt 
8ccf			; d is max length 
8ccf			; e is display size TODO 
8ccf			; c is current cursor position 
8ccf			; hl is ptr to where string will be stored 
8ccf			 
8ccf			 
8ccf			; TODO check limit of buffer for new inserts 
8ccf			; TODO check insert does not push beyond buffer 
8ccf			; TODO scroll in a limited display area 
8ccf			; TODO scroll whole screen on page wrap 
8ccf			 
8ccf			 
8ccf			; TODO handle KEY_PREVWORD 
8ccf			; TODO handle KEY_NEXTWORD 
8ccf			; TODO handle KEY_HOME 
8ccf			; TODO handle KEY_END 
8ccf			; TODO use LCD cursor? 
8ccf			 
8ccf 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8cd2 81					add c 
8cd3 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8cd6 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
8cd9 79					ld a, c 
8cda cd a2 8c				call addatohl 
8cdd 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8ce0 7a					ld a,d 
8ce1 32 6c ee			        ld (input_size), a       ; save length of input area 
8ce4 79					ld a, c 
8ce5 32 5b ee				ld (input_cursor),a      ; init cursor start position  
8ce8 7b					ld a,e 
8ce9 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8cec					 
8cec					 
8cec			 
8cec			;		ld a,(input_ptr) 
8cec			;		ld (input_under_cursor),a 	; save what is under the cursor 
8cec			 
8cec			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8cec					; init cursor shape if not set by the cin routines 
8cec 21 ca eb				ld hl, cursor_shape 
8cef 3e ff				ld a, 255 
8cf1 77					ld (hl), a 
8cf2 23					inc hl 
8cf3 3e 00				ld a, 0 
8cf5 77					ld (hl), a 
8cf6			 
8cf6 3e 0f				ld a, CUR_BLINK_RATE 
8cf8 32 66 ee				ld (input_cur_flash), a 
8cfb 3e 01				ld a, 1 
8cfd 32 65 ee				ld (input_cur_onoff),a 
8d00			 
8d00			;	if DEBUG_INPUT 
8d00			;		push af 
8d00			;		ld a, 'I' 
8d00			;		ld (debug_mark),a 
8d00			;		pop af 
8d00			;		CALLMONITOR 
8d00			;	endif 
8d00			.is1:		; main entry loop 
8d00			 
8d00			 
8d00			 
8d00					; pause 1ms 
8d00			 
8d00 3e 01				ld a, 1 
8d02 cd d7 89				call aDelayInMS 
8d05			 
8d05					; dec flash counter 
8d05 3a 66 ee				ld a, (input_cur_flash) 
8d08 3d					dec a 
8d09 32 66 ee				ld (input_cur_flash), a 
8d0c fe 00				cp 0 
8d0e 20 0d				jr nz, .nochgstate 
8d10			 
8d10			 
8d10					; change state 
8d10 3a 65 ee				ld a,(input_cur_onoff) 
8d13 ed 44				neg 
8d15 32 65 ee				ld (input_cur_onoff),a 
8d18			 
8d18			 
8d18					; reset on change of state 
8d18 3e 0f				ld a, CUR_BLINK_RATE 
8d1a 32 66 ee				ld (input_cur_flash), a 
8d1d			 
8d1d			.nochgstate: 
8d1d					 
8d1d					 
8d1d			 
8d1d					; display cursor  
8d1d			 
8d1d			;		ld hl, (input_start) 
8d1d			;		ld a, (input_cursor) 
8d1d			;		call addatohl 
8d1d			 
8d1d					; get char under cursor and replace with cursor 
8d1d 2a 6f ee		ld hl, (input_ptr) 
8d20			;		ld a, (hl) 
8d20			;		ld (input_under_cursor),a 
8d20			;		ld a, '_' 
8d20			;		ld (hl), a 
8d20			 
8d20					; display string 
8d20			 
8d20 ed 5b 6d ee			ld de, (input_start) 
8d24 3a 6a ee				ld a, (input_at_pos) 
8d27 cd 88 8a				call str_at_display 
8d2a			;	        call update_display 
8d2a			 
8d2a					; find place to put the cursor 
8d2a			;		add h 
8d2a			;		ld l, display_row_1 
8d2a			;		sub l 
8d2a			; (input_at_pos) 
8d2a					;ld c, a 
8d2a			;		ld a, (input_cursor) 
8d2a			;		ld l, (input_at_pos) 
8d2a			;		;ld b, h 
8d2a			;		add l 
8d2a			;		ld (input_at_cursor),a 
8d2a					;ld l,h 
8d2a			 
8d2a			;		ld h, 0 
8d2a			;		ld l,(input_at_pos) 
8d2a			;		ld a, (input_cursor) 
8d2a			;		call addatohl 
8d2a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d2a			;		call subafromhl 
8d2a			;		ld a,l 
8d2a			;		ld (input_at_cursor), a 
8d2a			 
8d2a				if DEBUG_INPUT 
8d2a					ld a, (hardware_diag) 
8d2a					cp 0 
8d2a					jr z, .skip_input_diag 
8d2a			 
8d2a					ld a,(input_at_pos) 
8d2a					ld hl, LFSRSeed 
8d2a					call hexout 
8d2a					ld a, (input_cursor) 
8d2a					ld hl, LFSRSeed+2 
8d2a					call hexout 
8d2a					ld a,(input_at_cursor) 
8d2a					ld hl, LFSRSeed+4 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_cur_onoff) 
8d2a					ld hl, LFSRSeed+6 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_cur_flash) 
8d2a					ld hl, LFSRSeed+8 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_len) 
8d2a					ld hl, LFSRSeed+10 
8d2a					call hexout 
8d2a					ld hl, LFSRSeed+12 
8d2a					ld a, 0 
8d2a					ld (hl),a 
8d2a					ld a, display_row_4 
8d2a					ld de, LFSRSeed 
8d2a					call str_at_display 
8d2a					.skip_input_diag: 
8d2a				endif 
8d2a			 
8d2a					; decide on if we are showing the cursor this time round 
8d2a			 
8d2a 3a 65 ee				ld a, (input_cur_onoff) 
8d2d fe ff				cp 255 
8d2f 28 13				jr z, .skipcur 
8d31			 
8d31			 
8d31 3a 68 ee				ld a,(input_at_cursor) 
8d34 11 ca eb				ld de, cursor_shape 
8d37 cd 88 8a				call str_at_display 
8d3a			 
8d3a					; save length of current input string 
8d3a 2a 6d ee				ld hl, (input_start) 
8d3d cd 00 91				call strlenz 
8d40 7d					ld a,l 
8d41 32 60 ee				ld (input_len),a 
8d44			 
8d44			.skipcur: 
8d44			 
8d44 cd 98 8a			        call update_display 
8d47					 
8d47			 
8d47			 
8d47					; wait 
8d47				 
8d47					; TODO loop without wait to flash the cursor and char under cursor	 
8d47 cd bb e2				call cin    ; _wait 
8d4a			 
8d4a fe 00				cp 0 
8d4c ca 00 8d				jp z, .is1 
8d4f			 
8d4f					; get ptr to char to input into 
8d4f			 
8d4f 4f					ld c,a 
8d50 2a 6d ee				ld hl, (input_start) 
8d53 3a 5b ee				ld a, (input_cursor) 
8d56 cd a2 8c				call addatohl 
8d59 22 6f ee				ld (input_ptr), hl 
8d5c 79					ld a,c 
8d5d			 
8d5d					; replace char under cursor 
8d5d			 
8d5d			;		ld hl, (input_ptr) 
8d5d			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d5d			;		ld (hl), a 
8d5d			 
8d5d			;	if DEBUG_INPUT 
8d5d			;		push af 
8d5d			;		ld a, 'i' 
8d5d	