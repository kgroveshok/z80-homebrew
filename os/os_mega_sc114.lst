# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 b4 95			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-09-11 17:03' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
801f			 
801f			 
801f			 
801f			;        nop  
801f			;        nop 
801f			;;	org 05h		; null out bdos call 
801f			; 
801f			;        nop  
801f			;        nop  
801f			;        nop 
801f			;;	org 08h 
801f			;;; 
801f			;;	jp cin		; rst 8 - char in 
801f			;;; 
801f			; 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;	org 010h 
801f			;; 
801f			;	jp cout		; rest 010h  - char out 
801f			;; 
801f			;	org 01bh   
801f			; 
801f			;	;jp  		; rst 01bh   - write string to display 
801f			;	jp str_at_display 
801f			; 
801f			; 
801f			;	org 020h 
801f			; 
801f			;	; jp		 ; rst 020h - read char at screen location 
801f			; 
801f			;	org 028h 
801f			 
801f				; jp		 ; rst 028h  - storage i/o 
801f			 
801f			; 	org 030h 
801f			;	jp break_point_state 
801f			  
801f			; $30  
801f			; org 038h 
801f			; $38 
801f			 
801f			; TODO any more important entry points to add to jump table for easier coding use? 
801f			 
801f			if BASE_KEV = 1  
801f			 
801f				; need to be at $66 for nmi support 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255 
801f				jp nmi 
801f			endif 
801f			 
801f			include "firmware.asm" 
801f			  
801f			; main constants (used here and in firmware)  
801f			  
801f			; TODO have page 0 of storage as bios  
801f			  
801f			Device_A: equ 0h  
801f			Device_B: equ 040h          ; Sound  
801f			  
801f			if BASE_KEV  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_SC114  
801f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			; TODO fixup for CPM  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			Device_D: equ 0c0h             ; Keyboard and LCD  
801f			  
801f			; Odd specific debug points for testing hardware dev  
801f			  
801f			;if DEBUG_LEVEL0  
801f			;	include "debug_level0.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL1  
801f			;	include "debug_level1.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL2  
801f			;	include "debug_level2.asm"  
801f			;endif  
801f			  
801f			  
801f			CALLMONITOR: macro  
801f			;	call break_point_state  
801f			; now use the break point debug vector  
801f				call debug_vector  
801f				endm  
801f			  
801f			MALLOC_1: equ 1        ; from dk88   
801f			MALLOC_2: equ 0           ; broke  
801f			MALLOC_3: equ 0           ; really broke  
801f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801f			  
801f			if BASE_KEV   
801f			;stacksize: equ 256  
801f			; each stack entry is three bytes (type + word)  
801f			stacksize: equ 3*150  
801f			  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 512  
801f			endif  
801f			if BASE_SC114  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			;if STORAGE_SE == 0  
801f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801f			;endif  
801f			  
801f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801f			  
801f			STORE_0_AUTORUN: equ $20  
801f			  
801f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801f			  
801f			STORE_0_AUTOFILE: equ $21  
801f			STORE_0_BANKRUN: equ $23  
801f			STORE_0_FILERUN: equ $24  
801f			STORE_0_BANKRUNN: equ $25   ; human readable bank id  
801f			  
801f			; Block 0 offsets for settings  
801f			  
801f			; if set then skip prompt for start up and accept all  
801f			  
801f			STORE_0_QUICKSTART: equ $25  
801f			  
801f			; Blocks where directory table is held  
801f			  
801f			; Reducing the number of entries increases the max file size  
801f			  
801f			;STORE_DIR_START: equ 1  
801f			;STORE_DIR_END: equ 33  
801f			  
801f			; Blocks from where file data is stored  
801f			  
801f			;STORE_DATA_START: equ STORE_DIR_END + 1  
801f			  
801f			; Block indicators (<32 are data files)  
801f			  
801f			;STORE_BLOCK_CFG: equ $8f       ; config block  
801f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801f			;STORE_BLOCK_FREE: equ $85       ; data block free  
801f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801f			  
801f			  
801f			  
801f			; Directory entry flags  
801f			  
801f			;STORE_DIR_FREE: equ 0  
801f			;STORE_DIR_FILE:  equ 1  
801f			  
801f			; Structure offsets to directory entries  
801f			;STORE_DE_FLAG: equ 0  
801f			;STORE_DE_MAXEXT: equ 1  
801f			;STORE_DE_FILENAME: equ 2  
801f			  
801f			; Structure offsets to block 0  
801f			  
801f			;STORE_BK0_ISFOR: equ 1  
801f			;STORE_BK0_LABEL: equ 3  
801f			  
801f			; memory allocation   
801f			  
801f			chk_stund: equ tos+2           ; underflow check word  
801f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801f			  
801f			; keyscan table needs rows x cols buffer  
801f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801f			  
801f			keyscan_table_row1: equ chk_stovr -key_cols-1  
801f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801f			keyscan_scancol: equ keyscan_table-key_cols  
801f			;keyscan_table_len: equ key_rows*key_cols  
801f			;keybufptr: equ keyscan_table - 2  
801f			;keysymbol: equ keybufptr - 1  
801f			key_held: equ keyscan_scancol-1	; currently held  
801f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801f			key_fa: equ key_repeat_ct -1 ;  
801f			key_fb: equ key_fa -1 ;  
801f			key_fc: equ key_fb -1 ;  
801f			key_fd: equ key_fc -1 ;  
801f			key_face_held: equ key_fd - 1   
801f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801f			  
801f			hardware_config: equ key_face_held - 10  
801f			  
801f			; hardware config switches  
801f			; TODO add bitmasks on includes for hardware  
801f			; high byte for expansion ids  
801f			;     0000 0000  no card inserted  
801f			;     0000 0001  storage card inserted  
801f			;     0000 0010  spi sd card active  
801f			  
801f			;       
801f			; low byte:  
801f			;     0000 0001   4x4 keypad  
801f			;     0000 0010   full keyboard  
801f			;     0000 0011   spi/ext keyboard  
801f			;     0000 0100   20x4 lcd  
801f			;     0000 1000   40x4 lcd  
801f			;     0000 1100   spi/ext display  
801f			;     0001 0000   ide interface available  
801f			  
801f			hardware_word: equ hardware_config - 2  
801f			  
801f			; debug marker - optional display of debug point on the debug screens  
801f			  
801f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801f			parse_vector:  equ debug_vector - 3 ; vector to the parser vector  
801f			  
801f			debug_umark: equ parse_vector - 6  ; current user mark  
801f			debug_mark: equ debug_umark - 4    ; internal word debug points  
801f			  
801f			; input_str vars  
801f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801f			input_size: equ input_start -1  ; number of chars  
801f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801f			input_len: equ input_cur_onoff - 5 ; length of current input  
801f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801f			  
801f			; cursor blink rate  
801f			CUR_BLINK_RATE: equ $09  
801f			;CUR_BLINK_RATE: equ 15  
801f			  
801f			key_actual_pressed: equ input_cursor - 1   
801f			key_symbol: equ key_actual_pressed - 1   
801f			key_shift: equ key_symbol - 1   
801f			  
801f			; Display allocation  
801f			  
801f			;display_rows: equ 4     ; move out to mini and mega files  
801f			;display_cols: equ 20  
801f			  
801f			display_fb_len: equ display_rows*display_cols  
801f			  
801f			; primary frame buffer     
801f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801f			; working frame buffers  
801f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801f			display_fb3: equ  display_fb1-display_fb_len - 1  
801f			display_fb2: equ  display_fb3-display_fb_len - 1  
801f			;  
801f			; pointer to active frame buffer  
801f			display_fb_active: equ display_fb2 - 2  
801f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801f			display_write_tmp: equ display_lcde1e2 - 2  
801f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801f			  
801f			;  
801f			  
801f			;; can load into de directory  
801f			cursor_col: equ display_active-1  
801f			cursor_row: equ cursor_col-1  
801f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801f			  
801f			; maths vars  
801f			  
801f			LFSRSeed: equ cursor_shape -20   
801f			randData: equ LFSRSeed - 2  
801f			xrandc: equ randData - 2  
801f			stackstore: equ xrandc - 2  
801f			seed1: equ  stackstore -2   
801f			seed2: equ seed1 - 2  
801f			  
801f			; cf storage vars  
801f			  
801f			iErrorNum:  equ seed2-1         ;Error number  
801f			iErrorReg:  equ iErrorNum -1              ;Error register  
801f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801f			  
801f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801f			  
801f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801f			  
801f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801f			store_tmpid: equ store_tmp3 - 1		; page temp id  
801f			store_tmpext: equ store_tmpid - 1		; file extent temp  
801f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801f			;  
801f			; spi vars  
801f			  
801f			  
801f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801f			spi_device_id: equ spi_device - 1    ; human readable bank number  
801f			  
801f			;;;;; forth cli params  
801f			  
801f			; TODO use a different frame buffer for forth???  
801f			  
801f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801f			  
801f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801f			  
801f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801f			  
801f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801f			  
801f			; os/forth token vars  
801f			  
801f			os_last_cmd: equ os_var_array-255  
801f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801f			os_current_i: equ os_cli_cmd-2  
801f			os_cur_ptr: equ os_current_i-2  
801f			os_word_scratch: equ os_cur_ptr-30  
801f			os_tok_len: equ os_word_scratch - 2  
801f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801f			os_tok_malloc: equ os_tok_ptr - 2  
801f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801f			execscratch: equ os_input-255        ; exec cmd eval buffer  
801f			scratch: equ execscratch-255  
801f			  
801f			os_stack_1: equ scratch - 3       ; stack holding area 1  
801f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801f			  
801f			  
801f			; temp locations for new word processing to save on adding more   
801f			  
801f			os_new_malloc: equ os_stack_4-2  
801f			os_new_parse_len: equ os_new_malloc - 2  
801f			os_new_word_len: equ os_new_parse_len - 2  
801f			os_new_work_ptr: equ os_new_word_len - 2  
801f			os_new_src_ptr: equ os_new_work_ptr - 2  
801f			os_new_exec: equ os_new_src_ptr - 2  
801f			os_new_exec_ptr: equ os_new_exec - 2  
801f			  
801f			; resume memory alloocations....  
801f			  
801f			;os_view_disable: equ os_new_exec_ptr - 1  
801f			os_view_af: equ os_new_exec_ptr - 2  
801f			os_view_hl: equ os_view_af -2  
801f			os_view_de: equ os_view_hl - 2  
801f			os_view_bc: equ os_view_de - 2  
801f			  
801f			; stack checksum word  
801f			if DEBUG_STACK_IMB  
801f				curframe: equ  os_view_de - 5  
801f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			else  
801f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			endif  
801f			  
801f			; with data stack could see memory filled with junk. need some memory management   
801f			; malloc and free entry points added  
801f			  
801f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			;heap_end: equ free_list-1  ; Starting address of heap  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			heap_end: equ chk_word-1  ; Starting address of heap  
801f			  
801f			  
801f			;if BASE_KEV   
801f			;heap_start: equ 0800eh  ; Starting address of heap  
801f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;heap_start: equ baseram+15  ; Starting address of heap  
801f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;endif  
801f			  
801f			  
801f			;;;;  
801f			  
801f			  
801f			; change below to point to last memory alloc above  
801f			topusermem:  equ   heap_start  
801f			  
801f			;if BASE_KEV   
801f			;baseusermem: equ 08000h  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;;aseusermem:     equ    12  
801f			;baseusermem:     equ    prompt  
801f			;;baseusermem:     equ    endofcode  
801f			;endif  
801f			  
801f			  
801f			; **********************************************************************  
801f			; **  Constants  
801f			; **********************************************************************  
801f			  
801f			; Constants used by this code module  
801f			kDataReg:   EQU Device_D           ;PIO port A data register  
801f			kContReg:   EQU Device_D+2           ;PIO port A control register  
801f			  
801f			  
801f			portbdata:  equ Device_D+1    ; port b data  
801f			portbctl:   equ Device_D+3    ; port b control  
801f			  
801f			  
801f			;KEY_SHIFT:   equ 5  
801f			;KEY_SYMBOLSHIFT:  equ 6  
801f			  
801f			KEY_SHIFTLOCK: equ 4  
801f			  
801f			  
801f			KEY_UP: equ 5  
801f			KEY_NEXTWORD: equ 6  
801f			KEY_PREVWORD: equ 7  
801f			KEY_BS: equ 8  
801f			KEY_TAB:  equ 9  
801f			KEY_DOWN: equ 10  
801f			KEY_LEFT: equ 11  
801f			KEY_RIGHT: equ 12  
801f			KEY_CR:   equ 13  
801f			KEY_HOME: equ 14  
801f			KEY_END: equ 15  
801f			  
801f			KEY_F1: equ 16  
801f			KEY_F2: equ 17  
801f			KEY_F3: equ 18  
801f			KEY_F4: equ 19  
801f			  
801f			KEY_F5: equ 20  
801f			KEY_F6: equ 21  
801f			KEY_F7: equ 22  
801f			KEY_F8: equ 23  
801f			  
801f			KEY_F9: equ 24  
801f			KEY_F10: equ 25  
801f			KEY_F11: equ 26  
801f			KEY_F12: equ 27  
801f			  
801f			;if DEBUG_KEY  
801f			;	KEY_MATRIX_NO_PRESS: equ '.'  
801f			;	KEY_SHIFT:   equ '.'  
801f			;	KEY_SYMBOLSHIFT:  equ '.'  
801f			;else  
801f				KEY_SHIFT:   equ '~'  
801f				KEY_SYMBOLSHIFT:  equ '~'  
801f				KEY_MATRIX_NO_PRESS: equ '~'  
801f			;endi  
801f			  
801f			  
801f			  
801f			  
801f			; Macro to make adding debug marks easier  
801f			  
801f			DMARK: macro str  
801f				push af  
801f				ld a, (.dmark)  
801f				ld (debug_mark),a  
801f				ld a, (.dmark+1)  
801f				ld (debug_mark+1),a  
801f				ld a, (.dmark+2)  
801f				ld (debug_mark+2),a  
801f				jr .pastdmark  
801f			.dmark: db str  
801f			.pastdmark: pop af  
801f			  
801f			endm  
801f			  
801f			  
801f			; macro to detect for stack imbalances  
801f			  
801f			include "stackimbal.asm"  
801f			; Macro and code to detect stock imbalances 
801f			 
801f			SPPUSH: equ 0 
801f			 
801f			; Add a stack frame which can be checked before return 
801f			 
801f			STACKFRAME: macro onoff frame1 frame2 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f						exx 
801f			 
801f						ld de, frame1 
801f						ld a, d 
801f						ld hl, curframe 
801f						call hexout 
801f						ld a, e 
801f						ld hl, curframe+2 
801f						call hexout 
801f			  
801f						ld hl, frame1 
801f						push hl 
801f						ld hl, frame2 
801f						push hl 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			endm 
801f			 
801f			STACKFRAMECHK: macro onoff frame1 frame2 
801f			 
801f					 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						exx 
801f						; check stack frame SP 
801f			 
801f						ld hl, frame2 
801f						pop de   ; frame2 
801f			 
801f						call cmp16 
801f						jr nz, .spnosame 
801f						 
801f			 
801f						ld hl, frame1 
801f						pop de   ; frame1 
801f			 
801f						call cmp16 
801f						jr z, .spfrsame 
801f			 
801f						.spnosame: call showsperror 
801f			 
801f						.spfrsame: nop 
801f			 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			 
801f			 
801f			endm 
801f			 
801f			 
801f			; for a sub routine, wrap SP collection and comparisons 
801f			 
801f			; Usage: 
801f			; 
801f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801f			 
801f			SAVESP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f			 
801f						ld (store_sp+(storeword*4)), sp 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			CHECKSP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f			 
801f						; save SP after last save 
801f				 
801f						ld (store_sp+(storeword*4)+2), sp 
801f			 
801f						push hl 
801f						ld hl, store_sp+(storeword*4) 
801f						call check_stack_sp  
801f						pop hl 
801f			 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			if DEBUG_STACK_IMB 
801f			 
801f			check_stack_sp: 
801f					push de 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					push de 
801f			 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					pop hl 
801f			 
801f			 
801f					; check to see if the same 
801f			 
801f					call cmp16 
801f					jr z, .spsame 
801f			 
801f					; not same 
801f			 
801f					call showsperror 
801f			.spsame: 
801f			 
801f					pop de 
801f			 
801f					ret 
801f			 
801f			.sperr:  db "Stack imbalance",0 
801f			 
801f			 
801f			showsperror: 
801f			 
801f			 
801f				push hl 
801f				push af 
801f				push de 
801f				call clear_display 
801f				ld de, .sperr 
801f				ld a,0 
801f			;	ld de,os_word_scratch 
801f				call str_at_display 
801f				ld a, display_row_1+17 
801f				ld de, debug_mark 
801f				call str_at_display 
801f				ld a, 0 
801f				ld (curframe+4),a 
801f				ld hl, curframe 
801f				ld de, os_word_scratch 
801f				ld a, display_row_4 
801f				call str_at_display 
801f				call update_display 
801f				;call break_point_state 
801f				call cin_wait 
801f			 
801f			;	ld a, ' ' 
801f			;	ld (os_view_disable), a 
801f				call bp_on 
801f				pop de	 
801f				pop af 
801f				pop hl 
801f				CALLMONITOR 
801f				ret 
801f			 
801f			endif 
801f			 
801f			 
801f			 
801f			; eof 
# End of file stackimbal.asm
801f			  
801f			;TODO macro to calc col and row offset into screen  
801f			  
801f			  
801f			  
801f			hardware_init:  
801f			  
801f				  
801f			  
801f					;ld a, 0  
801f					;ld (hardware_diag), a  
801f			  
801f					; clear all the buffers  
801f			  
801f 21 07 ed				ld hl, display_fb1  
8022 22 c3 eb				ld (display_fb_active), hl  
8025			  
8025 cd ac 8a				call clear_display  
8028			  
8028 21 c5 eb				ld hl, display_fb2  
802b 22 c3 eb				ld (display_fb_active), hl  
802e			  
802e cd ac 8a				call clear_display  
8031			  
8031					; init primary frame buffer area  
8031 21 a8 ed				ld hl, display_fb0  
8034 22 c3 eb				ld (display_fb_active), hl  
8037			  
8037 cd ac 8a				call clear_display  
803a			  
803a			  
803a cd ae e3				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803d			  
803d cd 50 e4			call key_init  
8040 cd ad 80			call storage_init  
8043			  
8043				; setup malloc functions  
8043			  
8043				if MALLOC_1  
8043 cd 7e 90				call  heap_init  
8046				endif  
8046				if MALLOC_4  
8046					call  heap_init  
8046				endif  
8046			  
8046				; init sound hardware if present  
8046			  
8046				if SOUND_ENABLE  
8046					call sound_init  
8046				endif  
8046			  
8046				; lcd test sequence  
8046					  
8046 cd ce 8a			call update_display  
8049 cd f0 89			call delay1s  
804c 3e 2b			ld a,'+'  
804e cd b1 8a			call fill_display  
8051 cd ce 8a			call update_display  
8054 cd f0 89			call delay1s  
8057 3e 2a			ld a,'*'  
8059 cd b1 8a			call fill_display  
805c cd ce 8a			call update_display  
805f cd f0 89			call delay1s  
8062 3e 2d			ld a,'-'  
8064 cd b1 8a			call fill_display  
8067 cd ce 8a			call update_display  
806a cd f0 89			call delay1s  
806d			  
806d			; boot splash screen  
806d			if display_cols == 20	  
806d			        ld a, display_row_1    
806d			else  
806d 3e 0a		        ld a, display_row_1 +10   
806f			endif  
806f 11 21 95			ld de, prom_bootmsg  
8072 cd be 8a			call str_at_display  
8075 cd ce 8a			call update_display  
8078			  
8078			  
8078 cd f0 89			call delay1s  
807b cd f0 89			call delay1s  
807e			if display_cols == 20	  
807e			            LD   A, display_row_3+2  
807e			else  
807e 3e 5c		            LD   A, display_row_3+12  
8080			endif  
8080 11 36 95			ld de, prom_bootmsg1  
8083 cd be 8a			call str_at_display  
8086			; display debug level  
8086 3e 78		            LD   A, display_row_4  
8088 11 1b 80			ld de, debuglevel  
808b cd be 8a			call str_at_display  
808e			  
808e cd ce 8a			call update_display  
8091 cd f0 89			call delay1s  
8094 cd f0 89			call delay1s  
8097			  
8097			;	ld a, display_row_4+3  
8097			;	ld de, bootmsg2  
8097			;	call str_at_display  
8097			;	call update_display  
8097			;	call delay1s  
8097			;	call delay1s  
8097			  
8097			; debug mark setup  
8097			  
8097 3e 5f		ld a, '_'  
8099 32 62 ee		ld (debug_mark),a  
809c 32 63 ee		ld (debug_mark+1),a  
809f 32 64 ee		ld (debug_mark+2),a  
80a2 3e 00		ld a,0  
80a4 32 65 ee		ld (debug_mark+3),a  
80a7 32 66 ee		ld (debug_umark),a  
80aa			  
80aa c9					ret  
80ab			  
80ab			  
80ab			;bootmsg2:	db "Firmware v0.1",0  
80ab			  
80ab			; a 4x20 lcd  
80ab			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ab			  
80ab			;if display_cols == 20  
80ab			;	include "firmware_lcd_4x20.asm"  
80ab			;endif  
80ab			  
80ab			;if display_cols == 40  
80ab			;	include "firmware_lcd_4x40.asm"  
80ab			;endif  
80ab			  
80ab			;  
80ab			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ab			; TODO abstract the bit bang video out interface for dual display  
80ab			; TODO wire video out to tx pin on rc2014 bus  
80ab			  
80ab			; must supply cin, and cin_wait for low level hardware abstraction   
80ab			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ab			; test scancode  
80ab			  
80ab			;;;;;  
80ab			;;;  
80ab			; Moved out to mini and maxi versions  
80ab			;  
80ab			; include "firmware_key_4x4.asm"  
80ab			; using existing 4 wire x 4 resistor array for input  
80ab			;include "firmware_key_4x10.asm"  
80ab			; need to mod the board for 5 rows due to resistor array  
80ab			;include "firmware_key_5x10.asm"  
80ab			  
80ab			; storage hardware interface  
80ab			  
80ab			; use microchip serial eeprom for storage  
80ab			  
80ab			  
80ab			if STORAGE_SE  
80ab				include "firmware_spi.asm"  
80ab				include "firmware_seeprom.asm"  
80ab			else  
80ab			   ; create some stubs for the labels  
80ab c9			se_readbyte: ret  
80ac c9			se_writebyte: ret  
80ad c9			storage_init: ret  
80ae			  
80ae			endif  
80ae			  
80ae			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80ae			;include "firmware_cf.asm"  
80ae			  
80ae			; load up high level storage hardward abstractions  
80ae			include "firmware_storage.asm"  
80ae			 
80ae			; persisent storage hardware abstraction layer  
80ae			 
80ae			 
80ae			 
80ae			; Block 0 on storage is a config state 
80ae			 
80ae			 
80ae			 
80ae			; TODO add read phy block and write phy block functions 
80ae			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80ae			 
80ae			; Abstraction layer  
80ae			 
80ae			; Logocial block size is same size as physical size - using tape concept 
80ae			 
80ae			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80ae			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80ae			 
80ae			 
80ae			 
80ae			; Filesystem layout (Logical layout) 
80ae			; 
80ae			; Block 0 - Bank config  
80ae			; 
80ae			;      Byte - 0 file id counter 
80ae			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80ae			;      Byte - 3-20 zero terminated bank label 
80ae			; 
80ae			; Block 1 > File storage 
80ae			; 
80ae			;      Byte 0 file id    - block 0 file details 
80ae			;      Byte 1 block id - block 0 is file  
80ae			;            Byte 2-15 - File name 
80ae			; 
80ae			;       - to end of block data 
80ae			; 
80ae			 
80ae			; Get ID for the file named in pointer held HL 
80ae			; Returns ID in HL = 255 if no file found 
80ae			 
80ae			storage_getid: 
80ae			 
80ae 22 6a ea			ld (store_tmp1), hl 
80b1			 
80b1				if DEBUG_STORESE 
80b1					DMARK "SGI" 
80b1 f5				push af  
80b2 3a c6 80			ld a, (.dmark)  
80b5 32 62 ee			ld (debug_mark),a  
80b8 3a c7 80			ld a, (.dmark+1)  
80bb 32 63 ee			ld (debug_mark+1),a  
80be 3a c8 80			ld a, (.dmark+2)  
80c1 32 64 ee			ld (debug_mark+2),a  
80c4 18 03			jr .pastdmark  
80c6 ..			.dmark: db "SGI"  
80c9 f1			.pastdmark: pop af  
80ca			endm  
# End of macro DMARK
80ca					CALLMONITOR 
80ca cd 6f ee			call debug_vector  
80cd				endm  
# End of macro CALLMONITOR
80cd				endif 
80cd				; get block 0 and set counter for number of files to scan 
80cd			 
80cd cd 35 82			call storage_get_block_0 
80d0			 
80d0 3a 71 ea			ld a, (store_page) 
80d3 47				ld b, a 
80d4			 
80d4				; get extent 0 of each file id 
80d4			 
80d4				if DEBUG_STORESE 
80d4					DMARK "SGc" 
80d4 f5				push af  
80d5 3a e9 80			ld a, (.dmark)  
80d8 32 62 ee			ld (debug_mark),a  
80db 3a ea 80			ld a, (.dmark+1)  
80de 32 63 ee			ld (debug_mark+1),a  
80e1 3a eb 80			ld a, (.dmark+2)  
80e4 32 64 ee			ld (debug_mark+2),a  
80e7 18 03			jr .pastdmark  
80e9 ..			.dmark: db "SGc"  
80ec f1			.pastdmark: pop af  
80ed			endm  
# End of macro DMARK
80ed					CALLMONITOR 
80ed cd 6f ee			call debug_vector  
80f0				endm  
# End of macro CALLMONITOR
80f0				endif 
80f0 60			.getloop:	ld h, b 
80f1 2e 00				ld l, 0 
80f3 c5					push bc 
80f4			 
80f4 11 71 ea				ld de, store_page 
80f7				if DEBUG_STORESE 
80f7					DMARK "SGr" 
80f7 f5				push af  
80f8 3a 0c 81			ld a, (.dmark)  
80fb 32 62 ee			ld (debug_mark),a  
80fe 3a 0d 81			ld a, (.dmark+1)  
8101 32 63 ee			ld (debug_mark+1),a  
8104 3a 0e 81			ld a, (.dmark+2)  
8107 32 64 ee			ld (debug_mark+2),a  
810a 18 03			jr .pastdmark  
810c ..			.dmark: db "SGr"  
810f f1			.pastdmark: pop af  
8110			endm  
# End of macro DMARK
8110					CALLMONITOR 
8110 cd 6f ee			call debug_vector  
8113				endm  
# End of macro CALLMONITOR
8113				endif 
8113 cd d7 86				call storage_read 
8116 cd ff 8c				call ishlzero 
8119 28 2d				jr z, .gap 
811b					 
811b					; have a file name read. Is it one we want. 
811b			 
811b 2a 6a ea				ld hl, (store_tmp1) 
811e 11 74 ea				ld de, store_page+3   ; file name 
8121			 
8121				if DEBUG_STORESE 
8121					DMARK "SGc" 
8121 f5				push af  
8122 3a 36 81			ld a, (.dmark)  
8125 32 62 ee			ld (debug_mark),a  
8128 3a 37 81			ld a, (.dmark+1)  
812b 32 63 ee			ld (debug_mark+1),a  
812e 3a 38 81			ld a, (.dmark+2)  
8131 32 64 ee			ld (debug_mark+2),a  
8134 18 03			jr .pastdmark  
8136 ..			.dmark: db "SGc"  
8139 f1			.pastdmark: pop af  
813a			endm  
# End of macro DMARK
813a					CALLMONITOR 
813a cd 6f ee			call debug_vector  
813d				endm  
# End of macro CALLMONITOR
813d				endif 
813d cd 66 90				call strcmp 
8140 20 06				jr nz, .gap   ; not this one 
8142			 
8142 c1				        pop bc 
8143			 
8143 26 00				ld h, 0 
8145 68					ld l, b 
8146 18 22				jr .getdone 
8148						 
8148			 
8148			 
8148			 
8148			.gap: 
8148				if DEBUG_STORESE 
8148					DMARK "SGg" 
8148 f5				push af  
8149 3a 5d 81			ld a, (.dmark)  
814c 32 62 ee			ld (debug_mark),a  
814f 3a 5e 81			ld a, (.dmark+1)  
8152 32 63 ee			ld (debug_mark+1),a  
8155 3a 5f 81			ld a, (.dmark+2)  
8158 32 64 ee			ld (debug_mark+2),a  
815b 18 03			jr .pastdmark  
815d ..			.dmark: db "SGg"  
8160 f1			.pastdmark: pop af  
8161			endm  
# End of macro DMARK
8161					CALLMONITOR 
8161 cd 6f ee			call debug_vector  
8164				endm  
# End of macro CALLMONITOR
8164				endif 
8164			 
8164 c1					pop bc 
8165 10 89				djnz .getloop 
8167 21 ff 00				ld hl, 255 
816a			.getdone: 
816a			 
816a				if DEBUG_STORESE 
816a					DMARK "SGe" 
816a f5				push af  
816b 3a 7f 81			ld a, (.dmark)  
816e 32 62 ee			ld (debug_mark),a  
8171 3a 80 81			ld a, (.dmark+1)  
8174 32 63 ee			ld (debug_mark+1),a  
8177 3a 81 81			ld a, (.dmark+2)  
817a 32 64 ee			ld (debug_mark+2),a  
817d 18 03			jr .pastdmark  
817f ..			.dmark: db "SGe"  
8182 f1			.pastdmark: pop af  
8183			endm  
# End of macro DMARK
8183					CALLMONITOR 
8183 cd 6f ee			call debug_vector  
8186				endm  
# End of macro CALLMONITOR
8186				endif 
8186			 
8186 c9				ret 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			; Read Block 
8187			; ---------- 
8187			; 
8187			; With current bank 
8187			;  
8187			; Get block number to read 
8187			; Load physical blocks starting at start block into buffer 
8187			 
8187			; de points to buffer to use 
8187			; hl holds logical block number  
8187			 
8187			storage_read_block: 
8187			 
8187				; TODO bank selection 
8187			 
8187				; for each of the physical blocks read it into the buffer 
8187 06 40			ld b, STORE_BLOCK_PHY 
8189			 
8189				if DEBUG_STORESE 
8189 d5					push de 
818a				endif 
818a				 
818a			.rl1:    
818a			 
818a				; read physical block at hl into de 
818a			        ; increment hl and de to next read position on exit 
818a			 
818a e5				push hl 
818b d5				push de	 
818c c5				push bc 
818d			;	if DEBUG_STORESE 
818d			;		push af 
818d			;		ld a, 'R' 
818d			;		ld (debug_mark),a 
818d			;		pop af 
818d			;		CALLMONITOR 
818d			;	endif 
818d cd ab 80			call se_readbyte 
8190			;	if DEBUG_STORESE 
8190			;		ld a,(spi_portbyte) 
8190			;		ld l, a 
8190			;		push af 
8190			;		ld a, '1' 
8190			;		ld (debug_mark),a 
8190			;		pop af 
8190			;		CALLMONITOR 
8190			;	endif 
8190 c1				pop bc 
8191 d1				pop de 
8192 e1				pop hl 
8193 12				ld (de),a 
8194 23				inc hl 
8195 13				inc de 
8196			 
8196			;	if DEBUG_STORESE 
8196			;		push af 
8196			;		ld a, 'r' 
8196			;		ld (debug_mark),a 
8196			;		pop af 
8196			;		CALLMONITOR 
8196			;	endif 
8196			 
8196 10 f2			djnz .rl1 
8198			 
8198				if DEBUG_STORESE 
8198					DMARK "SRB" 
8198 f5				push af  
8199 3a ad 81			ld a, (.dmark)  
819c 32 62 ee			ld (debug_mark),a  
819f 3a ae 81			ld a, (.dmark+1)  
81a2 32 63 ee			ld (debug_mark+1),a  
81a5 3a af 81			ld a, (.dmark+2)  
81a8 32 64 ee			ld (debug_mark+2),a  
81ab 18 03			jr .pastdmark  
81ad ..			.dmark: db "SRB"  
81b0 f1			.pastdmark: pop af  
81b1			endm  
# End of macro DMARK
81b1 d1					pop de 
81b2			; 
81b2			;		push af 
81b2			;		ld a, 'R' 
81b2			;		ld (debug_mark),a 
81b2			;		pop af 
81b2					CALLMONITOR 
81b2 cd 6f ee			call debug_vector  
81b5				endm  
# End of macro CALLMONITOR
81b5				endif 
81b5 c9				ret	 
81b6				 
81b6			 
81b6			; File Size 
81b6			; --------- 
81b6			; 
81b6			;   hl file id 
81b6			; 
81b6			;  returns in hl the number of blocks 
81b6			 
81b6			storage_file_size: 
81b6 5d				ld e, l 
81b7 16 00			ld d, 0 
81b9 21 40 00			ld hl, STORE_BLOCK_PHY 
81bc					if DEBUG_FORTH_WORDS 
81bc						DMARK "SIZ" 
81bc f5				push af  
81bd 3a d1 81			ld a, (.dmark)  
81c0 32 62 ee			ld (debug_mark),a  
81c3 3a d2 81			ld a, (.dmark+1)  
81c6 32 63 ee			ld (debug_mark+1),a  
81c9 3a d3 81			ld a, (.dmark+2)  
81cc 32 64 ee			ld (debug_mark+2),a  
81cf 18 03			jr .pastdmark  
81d1 ..			.dmark: db "SIZ"  
81d4 f1			.pastdmark: pop af  
81d5			endm  
# End of macro DMARK
81d5						CALLMONITOR 
81d5 cd 6f ee			call debug_vector  
81d8				endm  
# End of macro CALLMONITOR
81d8					endif 
81d8 cd b3 84			call storage_findnextid 
81db			 
81db cd ff 8c			call ishlzero 
81de			;	ld a, l 
81de			;	add h 
81de			;	cp 0 
81de c8				ret z			; block not found so EOF 
81df			 
81df 11 71 ea			ld de, store_page 
81e2 cd 87 81			call storage_read_block 
81e5			 
81e5 3a 73 ea			ld a, (store_page+2)	 ; get extent count 
81e8 6f				ld l, a 
81e9 26 00			ld h, 0 
81eb c9			 	ret 
81ec			 
81ec			 
81ec			; Write Block 
81ec			; ----------- 
81ec			; 
81ec			; With current bank 
81ec			;  
81ec			; Get block number to write 
81ec			; Write physical blocks starting at start block from buffer 
81ec			  
81ec			storage_write_block: 
81ec				; TODO bank selection 
81ec			 
81ec				; for each of the physical blocks read it into the buffer 
81ec 06 40			ld b, STORE_BLOCK_PHY 
81ee			 
81ee				if DEBUG_STORESE 
81ee					DMARK "SWB" 
81ee f5				push af  
81ef 3a 03 82			ld a, (.dmark)  
81f2 32 62 ee			ld (debug_mark),a  
81f5 3a 04 82			ld a, (.dmark+1)  
81f8 32 63 ee			ld (debug_mark+1),a  
81fb 3a 05 82			ld a, (.dmark+2)  
81fe 32 64 ee			ld (debug_mark+2),a  
8201 18 03			jr .pastdmark  
8203 ..			.dmark: db "SWB"  
8206 f1			.pastdmark: pop af  
8207			endm  
# End of macro DMARK
8207			 
8207					;push af 
8207					;ld a, 'W' 
8207					;ld (debug_mark),a 
8207					;pop af 
8207					CALLMONITOR 
8207 cd 6f ee			call debug_vector  
820a				endm  
# End of macro CALLMONITOR
820a				endif 
820a			 
820a			; might not be working 
820a			;	call se_writepage 
820a			 
820a			;	ret 
820a			; 
820a			 
820a			 
820a			 
820a			.wl1:    
820a			 
820a				; read physical block at hl into de 
820a			        ; increment hl and de to next read position on exit 
820a			 
820a e5				push hl 
820b d5				push de	 
820c c5				push bc 
820d 1a				ld a,(de) 
820e				;if DEBUG_STORESE 
820e			;		push af 
820e			;		ld a, 'W' 
820e			;		ld (debug_mark),a 
820e			;		pop af 
820e			;		CALLMONITOR 
820e			;	endif 
820e cd ac 80			call se_writebyte 
8211			;	call delay250ms 
8211			;	nop 
8211			;	nop 
8211			;	nop 
8211			;	if DEBUG_STORESE 
8211			;		push af 
8211			;		ld a, 'w' 
8211			;		ld (debug_mark),a 
8211			;		pop af 
8211			;		CALLMONITOR 
8211			;	endif 
8211 c1				pop bc 
8212 d1				pop de 
8213 e1				pop hl 
8214 23				inc hl 
8215 13				inc de 
8216			 
8216			 
8216 10 f2			djnz .wl1 
8218			 
8218				if DEBUG_STORESE 
8218					DMARK "SW2" 
8218 f5				push af  
8219 3a 2d 82			ld a, (.dmark)  
821c 32 62 ee			ld (debug_mark),a  
821f 3a 2e 82			ld a, (.dmark+1)  
8222 32 63 ee			ld (debug_mark+1),a  
8225 3a 2f 82			ld a, (.dmark+2)  
8228 32 64 ee			ld (debug_mark+2),a  
822b 18 03			jr .pastdmark  
822d ..			.dmark: db "SW2"  
8230 f1			.pastdmark: pop af  
8231			endm  
# End of macro DMARK
8231			 
8231					;push af 
8231					;ld a, 'W' 
8231					;ld (debug_mark),a 
8231					;pop af 
8231					CALLMONITOR 
8231 cd 6f ee			call debug_vector  
8234				endm  
# End of macro CALLMONITOR
8234				endif 
8234 c9				ret	 
8235			 
8235			; Init bank 
8235			; --------- 
8235			; 
8235			; With current bank 
8235			; 
8235			; Setup block 0 config 
8235			;     Set 0 file id counter 
8235			;     Set formatted byte pattern 
8235			;     Zero out bank label 
8235			;      
8235			; For every logical block write 0-1 byte as null 
8235			 
8235			storage_get_block_0: 
8235			 
8235				; TODO check presence 
8235			 
8235				; get block 0 config 
8235			 
8235 21 00 00			ld hl, 0 
8238 11 71 ea			ld de, store_page 
823b cd 87 81			call storage_read_block 
823e			 
823e				if DEBUG_STORESE 
823e					DMARK "SB0" 
823e f5				push af  
823f 3a 53 82			ld a, (.dmark)  
8242 32 62 ee			ld (debug_mark),a  
8245 3a 54 82			ld a, (.dmark+1)  
8248 32 63 ee			ld (debug_mark+1),a  
824b 3a 55 82			ld a, (.dmark+2)  
824e 32 64 ee			ld (debug_mark+2),a  
8251 18 03			jr .pastdmark  
8253 ..			.dmark: db "SB0"  
8256 f1			.pastdmark: pop af  
8257			endm  
# End of macro DMARK
8257 11 71 ea				ld de, store_page 
825a			;		push af 
825a			;		ld a, 'i' 
825a			;		ld (debug_mark),a 
825a			;		pop af 
825a					CALLMONITOR 
825a cd 6f ee			call debug_vector  
825d				endm  
# End of macro CALLMONITOR
825d				endif 
825d			 
825d				; is this area formatted? 
825d			 
825d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
825d 2a 72 ea			ld hl, (store_page+1) 
8260 3e 80			ld a,0x80 
8262 bd				cp l 
8263 20 22			jr nz, .ininotformatted 
8265				; do a double check 
8265 3e 27			ld a, 0x27 
8267 bc				cp h 
8268 20 1d			jr nz, .ininotformatted 
826a			 
826a				; formatted then 
826a			 
826a				if DEBUG_STORESE 
826a					DMARK "SB1" 
826a f5				push af  
826b 3a 7f 82			ld a, (.dmark)  
826e 32 62 ee			ld (debug_mark),a  
8271 3a 80 82			ld a, (.dmark+1)  
8274 32 63 ee			ld (debug_mark+1),a  
8277 3a 81 82			ld a, (.dmark+2)  
827a 32 64 ee			ld (debug_mark+2),a  
827d 18 03			jr .pastdmark  
827f ..			.dmark: db "SB1"  
8282 f1			.pastdmark: pop af  
8283			endm  
# End of macro DMARK
8283					;push af 
8283					;ld a, 'I' 
8283					;ld (debug_mark),a 
8283					;pop af 
8283					CALLMONITOR 
8283 cd 6f ee			call debug_vector  
8286				endm  
# End of macro CALLMONITOR
8286				endif 
8286 c9				ret 
8287			 
8287			.ininotformatted: 
8287				; bank not formatted so poke various bits to make sure 
8287			 
8287				if DEBUG_STORESE 
8287					DMARK "SB2" 
8287 f5				push af  
8288 3a 9c 82			ld a, (.dmark)  
828b 32 62 ee			ld (debug_mark),a  
828e 3a 9d 82			ld a, (.dmark+1)  
8291 32 63 ee			ld (debug_mark+1),a  
8294 3a 9e 82			ld a, (.dmark+2)  
8297 32 64 ee			ld (debug_mark+2),a  
829a 18 03			jr .pastdmark  
829c ..			.dmark: db "SB2"  
829f f1			.pastdmark: pop af  
82a0			endm  
# End of macro DMARK
82a0					;push af 
82a0					;ld a, 'f' 
82a0					;ld (debug_mark),a 
82a0					;pop af 
82a0					CALLMONITOR 
82a0 cd 6f ee			call debug_vector  
82a3				endm  
# End of macro CALLMONITOR
82a3				endif 
82a3			 
82a3 cd b4 89			call storage_clear_page 
82a6			 
82a6 21 71 ea			ld hl, store_page 
82a9			;	ld a, 0 
82a9				 
82a9 36 00			ld (hl),0   ; reset file counter 
82ab			 
82ab 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82ae 22 72 ea		 	ld (store_page+1), hl	 
82b1			 
82b1				; set default label 
82b1			 
82b1 21 4a 83			ld hl, .defaultbanklabl 
82b4 11 74 ea		 	ld de, store_page+3 
82b7 01 0f 00			ld bc, 15 
82ba ed b0			ldir 
82bc			 
82bc				; Append the current bank id 
82bc 21 7d ea			ld hl, store_page+3+9 
82bf 3a 56 ea			ld a, (spi_device_id) 
82c2 77				ld (hl), a 
82c3			 
82c3				; save default page 0 
82c3			 
82c3 21 00 00			ld hl, 0 
82c6 11 71 ea			ld de, store_page 
82c9				if DEBUG_STORESE 
82c9					DMARK "SB3" 
82c9 f5				push af  
82ca 3a de 82			ld a, (.dmark)  
82cd 32 62 ee			ld (debug_mark),a  
82d0 3a df 82			ld a, (.dmark+1)  
82d3 32 63 ee			ld (debug_mark+1),a  
82d6 3a e0 82			ld a, (.dmark+2)  
82d9 32 64 ee			ld (debug_mark+2),a  
82dc 18 03			jr .pastdmark  
82de ..			.dmark: db "SB3"  
82e1 f1			.pastdmark: pop af  
82e2			endm  
# End of macro DMARK
82e2			;		push af 
82e2			;		ld a, 'F' 
82e2			;		ld (debug_mark),a 
82e2			;		pop af 
82e2					CALLMONITOR 
82e2 cd 6f ee			call debug_vector  
82e5				endm  
# End of macro CALLMONITOR
82e5				endif 
82e5 cd ec 81			call storage_write_block 
82e8				if DEBUG_STORESE 
82e8					DMARK "SB4" 
82e8 f5				push af  
82e9 3a fd 82			ld a, (.dmark)  
82ec 32 62 ee			ld (debug_mark),a  
82ef 3a fe 82			ld a, (.dmark+1)  
82f2 32 63 ee			ld (debug_mark+1),a  
82f5 3a ff 82			ld a, (.dmark+2)  
82f8 32 64 ee			ld (debug_mark+2),a  
82fb 18 03			jr .pastdmark  
82fd ..			.dmark: db "SB4"  
8300 f1			.pastdmark: pop af  
8301			endm  
# End of macro DMARK
8301			;		push af 
8301			;		ld a, '>' 
8301			;		ld (debug_mark),a 
8301			;		pop af 
8301					CALLMONITOR 
8301 cd 6f ee			call debug_vector  
8304				endm  
# End of macro CALLMONITOR
8304				endif 
8304			 
8304			;	nop 
8304			;	nop 
8304			;	nop 
8304			 
8304				; now set 0 in every page to mark as a free block 
8304			 
8304 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8306 21 40 00			ld hl, STORE_BLOCK_PHY 
8309			 
8309 3e 00		.setmark1:   	ld a,0 
830b e5					push hl 
830c c5					push bc 
830d cd ac 80				call se_writebyte 
8310 3e 0a			ld a, 10 
8312 cd d5 89			call aDelayInMS 
8315 23				inc hl 
8316 cd ac 80				call se_writebyte 
8319 3e 0a			ld a, 10 
831b cd d5 89			call aDelayInMS 
831e 2b				dec hl 
831f c1					pop bc 
8320 e1					pop hl 
8321 3e 40				ld a, STORE_BLOCK_PHY 
8323 cd d6 8c				call addatohl 
8326 10 e1				djnz .setmark1 
8328			 
8328 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
832a 3e 00		.setmark2:   	ld a,0 
832c e5					push hl 
832d c5					push bc 
832e cd ac 80				call se_writebyte 
8331 3e 0a			ld a, 10 
8333 cd d5 89			call aDelayInMS 
8336 23				inc hl 
8337 cd ac 80				call se_writebyte 
833a 3e 0a			ld a, 10 
833c cd d5 89			call aDelayInMS 
833f 2b				dec hl 
8340 c1					pop bc 
8341 e1					pop hl 
8342 3e 40				ld a, STORE_BLOCK_PHY 
8344 cd d6 8c				call addatohl 
8347 10 e1				djnz .setmark2 
8349			 
8349					 
8349			 
8349			 
8349 c9				ret 
834a			 
834a			 
834a			 
834a			 
834a .. 00		.defaultbanklabl:   db "BankLabel_",0 
8355			 
8355			 
8355			 
8355			; Label Bank 
8355			; ---------- 
8355			; 
8355			; With current bank 
8355			; Read block 0 
8355			; Set label 
8355			; Write block 0 
8355			 
8355			; label str pointer in hl 
8355			 
8355			storage_label:     
8355			 
8355				if DEBUG_STORESE 
8355					DMARK "LBL" 
8355 f5				push af  
8356 3a 6a 83			ld a, (.dmark)  
8359 32 62 ee			ld (debug_mark),a  
835c 3a 6b 83			ld a, (.dmark+1)  
835f 32 63 ee			ld (debug_mark+1),a  
8362 3a 6c 83			ld a, (.dmark+2)  
8365 32 64 ee			ld (debug_mark+2),a  
8368 18 03			jr .pastdmark  
836a ..			.dmark: db "LBL"  
836d f1			.pastdmark: pop af  
836e			endm  
# End of macro DMARK
836e					CALLMONITOR 
836e cd 6f ee			call debug_vector  
8371				endm  
# End of macro CALLMONITOR
8371				endif 
8371			 
8371 e5				push hl 
8372			 
8372 cd 35 82			call storage_get_block_0 
8375			 
8375				; set default label 
8375			 
8375 e1				pop hl 
8376			 
8376 11 74 ea		 	ld de, store_page+3 
8379 01 0f 00			ld bc, 15 
837c				if DEBUG_STORESE 
837c					DMARK "LB3" 
837c f5				push af  
837d 3a 91 83			ld a, (.dmark)  
8380 32 62 ee			ld (debug_mark),a  
8383 3a 92 83			ld a, (.dmark+1)  
8386 32 63 ee			ld (debug_mark+1),a  
8389 3a 93 83			ld a, (.dmark+2)  
838c 32 64 ee			ld (debug_mark+2),a  
838f 18 03			jr .pastdmark  
8391 ..			.dmark: db "LB3"  
8394 f1			.pastdmark: pop af  
8395			endm  
# End of macro DMARK
8395					CALLMONITOR 
8395 cd 6f ee			call debug_vector  
8398				endm  
# End of macro CALLMONITOR
8398				endif 
8398 ed b0			ldir 
839a				; save default page 0 
839a			 
839a 21 00 00			ld hl, 0 
839d 11 71 ea			ld de, store_page 
83a0				if DEBUG_STORESE 
83a0					DMARK "LBW" 
83a0 f5				push af  
83a1 3a b5 83			ld a, (.dmark)  
83a4 32 62 ee			ld (debug_mark),a  
83a7 3a b6 83			ld a, (.dmark+1)  
83aa 32 63 ee			ld (debug_mark+1),a  
83ad 3a b7 83			ld a, (.dmark+2)  
83b0 32 64 ee			ld (debug_mark+2),a  
83b3 18 03			jr .pastdmark  
83b5 ..			.dmark: db "LBW"  
83b8 f1			.pastdmark: pop af  
83b9			endm  
# End of macro DMARK
83b9					CALLMONITOR 
83b9 cd 6f ee			call debug_vector  
83bc				endm  
# End of macro CALLMONITOR
83bc				endif 
83bc cd ec 81			call storage_write_block 
83bf			 
83bf c9				ret 
83c0			 
83c0			 
83c0			 
83c0			; Read Block 0 - Config 
83c0			; --------------------- 
83c0			; 
83c0			; With current bank 
83c0			; Call presence test 
83c0			;    If not present format/init bank  
83c0			; Read block 0  
83c0			;  
83c0			 
83c0			 
83c0			; Dir 
83c0			; --- 
83c0			; 
83c0			; With current bank 
83c0			; Load Block 0 Config 
83c0			; Get max file id number 
83c0			; For each logical block 
83c0			;    Read block read byte 2 
83c0			;      if first block of file 
83c0			;         Display file name 
83c0			;         Display type flags for file 
83c0			;        
83c0			 
83c0			; moving to words as this requires stack control 
83c0			 
83c0			 
83c0			; Delete File 
83c0			; ----------- 
83c0			; 
83c0			; With current bank 
83c0			; 
83c0			; Load Block 0 Config 
83c0			; Get max file id number 
83c0			; For each logical block 
83c0			;    Read block file id 
83c0			;      If first block of file and dont have file id 
83c0			;         if file to delete 
83c0			;         Save file id 
83c0			;         Null file id 
83c0			;         Write this block back 
83c0			;      If file id is one saved 
83c0			;         Null file id 
83c0			;         Write this block back 
83c0			 
83c0			 
83c0			.se_done: 
83c0 e1				pop hl 
83c1 c9				ret 
83c2			 
83c2			storage_erase: 
83c2			 
83c2				; hl contains the file id 
83c2			 
83c2 5d				ld e, l 
83c3 16 00			ld d, 0 
83c5 21 40 00			ld hl, STORE_BLOCK_PHY 
83c8					if DEBUG_FORTH_WORDS 
83c8						DMARK "ERA" 
83c8 f5				push af  
83c9 3a dd 83			ld a, (.dmark)  
83cc 32 62 ee			ld (debug_mark),a  
83cf 3a de 83			ld a, (.dmark+1)  
83d2 32 63 ee			ld (debug_mark+1),a  
83d5 3a df 83			ld a, (.dmark+2)  
83d8 32 64 ee			ld (debug_mark+2),a  
83db 18 03			jr .pastdmark  
83dd ..			.dmark: db "ERA"  
83e0 f1			.pastdmark: pop af  
83e1			endm  
# End of macro DMARK
83e1						CALLMONITOR 
83e1 cd 6f ee			call debug_vector  
83e4				endm  
# End of macro CALLMONITOR
83e4					endif 
83e4 cd b3 84			call storage_findnextid 
83e7 cd ff 8c			call ishlzero 
83ea c8				ret z 
83eb			 
83eb e5				push hl 
83ec			 
83ec				; TODO check file not found 
83ec			 
83ec 11 71 ea			ld de, store_page 
83ef cd 87 81			call storage_read_block 
83f2			 
83f2 cd ff 8c			call ishlzero 
83f5 ca c0 83			jp z,.se_done 
83f8			 
83f8					if DEBUG_FORTH_WORDS 
83f8						DMARK "ER1" 
83f8 f5				push af  
83f9 3a 0d 84			ld a, (.dmark)  
83fc 32 62 ee			ld (debug_mark),a  
83ff 3a 0e 84			ld a, (.dmark+1)  
8402 32 63 ee			ld (debug_mark+1),a  
8405 3a 0f 84			ld a, (.dmark+2)  
8408 32 64 ee			ld (debug_mark+2),a  
840b 18 03			jr .pastdmark  
840d ..			.dmark: db "ER1"  
8410 f1			.pastdmark: pop af  
8411			endm  
# End of macro DMARK
8411						CALLMONITOR 
8411 cd 6f ee			call debug_vector  
8414				endm  
# End of macro CALLMONITOR
8414					endif 
8414 3a 71 ea			ld a, (store_page)	; get file id 
8417 32 65 ea			ld (store_tmpid), a 
841a			 
841a 3a 73 ea			ld a, (store_page+2)    ; get count of extends 
841d 32 64 ea			ld (store_tmpext), a 
8420			 
8420				; wipe file header 
8420			 
8420 e1				pop hl 
8421 3e 00			ld a, 0 
8423 32 71 ea			ld (store_page), a 
8426 32 72 ea			ld (store_page+1),a 
8429 11 71 ea			ld de, store_page 
842c					if DEBUG_FORTH_WORDS 
842c						DMARK "ER2" 
842c f5				push af  
842d 3a 41 84			ld a, (.dmark)  
8430 32 62 ee			ld (debug_mark),a  
8433 3a 42 84			ld a, (.dmark+1)  
8436 32 63 ee			ld (debug_mark+1),a  
8439 3a 43 84			ld a, (.dmark+2)  
843c 32 64 ee			ld (debug_mark+2),a  
843f 18 03			jr .pastdmark  
8441 ..			.dmark: db "ER2"  
8444 f1			.pastdmark: pop af  
8445			endm  
# End of macro DMARK
8445						CALLMONITOR 
8445 cd 6f ee			call debug_vector  
8448				endm  
# End of macro CALLMONITOR
8448					endif 
8448 cd ec 81			call storage_write_block 
844b			 
844b			 
844b				; wipe file extents 
844b			 
844b 3a 64 ea			ld a, (store_tmpext) 
844e 47				ld b, a 
844f			 
844f			.eraext:	  
844f c5				push bc 
8450			 
8450 21 40 00			ld hl, STORE_BLOCK_PHY 
8453 3a 65 ea			ld a,(store_tmpid) 
8456 5f				ld e, a 
8457 50				ld d, b	 
8458					if DEBUG_FORTH_WORDS 
8458						DMARK "ER3" 
8458 f5				push af  
8459 3a 6d 84			ld a, (.dmark)  
845c 32 62 ee			ld (debug_mark),a  
845f 3a 6e 84			ld a, (.dmark+1)  
8462 32 63 ee			ld (debug_mark+1),a  
8465 3a 6f 84			ld a, (.dmark+2)  
8468 32 64 ee			ld (debug_mark+2),a  
846b 18 03			jr .pastdmark  
846d ..			.dmark: db "ER3"  
8470 f1			.pastdmark: pop af  
8471			endm  
# End of macro DMARK
8471						CALLMONITOR 
8471 cd 6f ee			call debug_vector  
8474				endm  
# End of macro CALLMONITOR
8474					endif 
8474 cd b3 84			call storage_findnextid 
8477 cd ff 8c			call ishlzero 
847a ca c0 83			jp z,.se_done 
847d			 
847d e5				push hl 
847e 11 71 ea			ld de, store_page 
8481 cd 87 81			call storage_read_block 
8484			 
8484				; free block	 
8484			 
8484 3e 00			ld a, 0 
8486 32 71 ea			ld (store_page), a 
8489 32 72 ea			ld (store_page+1),a 
848c 11 71 ea			ld de, store_page 
848f e1				pop hl 
8490					if DEBUG_FORTH_WORDS 
8490						DMARK "ER4" 
8490 f5				push af  
8491 3a a5 84			ld a, (.dmark)  
8494 32 62 ee			ld (debug_mark),a  
8497 3a a6 84			ld a, (.dmark+1)  
849a 32 63 ee			ld (debug_mark+1),a  
849d 3a a7 84			ld a, (.dmark+2)  
84a0 32 64 ee			ld (debug_mark+2),a  
84a3 18 03			jr .pastdmark  
84a5 ..			.dmark: db "ER4"  
84a8 f1			.pastdmark: pop af  
84a9			endm  
# End of macro DMARK
84a9						CALLMONITOR 
84a9 cd 6f ee			call debug_vector  
84ac				endm  
# End of macro CALLMONITOR
84ac					endif 
84ac cd ec 81			call storage_write_block 
84af			 
84af c1				pop bc 
84b0 10 9d			djnz .eraext 
84b2			 
84b2 c9				ret 
84b3			 
84b3			 
84b3			; Find Free Block 
84b3			; --------------- 
84b3			; 
84b3			; With current bank 
84b3			;  
84b3			; From given starting logical block 
84b3			;    Read block  
84b3			;    If no file id 
84b3			;         Return block id 
84b3			 
84b3			 
84b3			; hl starting page number 
84b3			; hl contains free page number or zero if no pages free 
84b3			; e contains the file id to locate 
84b3			; d contains the block number 
84b3			 
84b3			; TODO change to find file id and use zero for free block 
84b3			 
84b3			storage_findnextid: 
84b3			 
84b3				; now locate first 0 page to mark as a free block 
84b3			 
84b3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84b5			;	ld hl, STORE_BLOCK_PHY 
84b5			 
84b5					if DEBUG_FORTH_WORDS 
84b5					DMARK "FNI" 
84b5 f5				push af  
84b6 3a ca 84			ld a, (.dmark)  
84b9 32 62 ee			ld (debug_mark),a  
84bc 3a cb 84			ld a, (.dmark+1)  
84bf 32 63 ee			ld (debug_mark+1),a  
84c2 3a cc 84			ld a, (.dmark+2)  
84c5 32 64 ee			ld (debug_mark+2),a  
84c8 18 03			jr .pastdmark  
84ca ..			.dmark: db "FNI"  
84cd f1			.pastdmark: pop af  
84ce			endm  
# End of macro DMARK
84ce						CALLMONITOR 
84ce cd 6f ee			call debug_vector  
84d1				endm  
# End of macro CALLMONITOR
84d1					endif 
84d1			.ff1:   	 
84d1 e5					push hl 
84d2 c5					push bc 
84d3 d5					push de 
84d4 cd ab 80				call se_readbyte 
84d7 5f					ld e,a 
84d8 23					inc hl 
84d9 cd ab 80				call se_readbyte 
84dc 57					ld d, a 
84dd e1					pop hl 
84de e5					push hl 
84df cd f4 8c				call cmp16 
84e2 28 49				jr z, .fffound 
84e4			 
84e4 d1					pop de 
84e5 c1					pop bc 
84e6 e1					pop hl 
84e7			 
84e7					; is found? 
84e7					;cp e 
84e7					;ret z 
84e7			 
84e7 3e 40				ld a, STORE_BLOCK_PHY 
84e9 cd d6 8c				call addatohl 
84ec 10 e3				djnz .ff1 
84ee			 
84ee 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84f0			.ff2:   	 
84f0			 
84f0 e5					push hl 
84f1 c5					push bc 
84f2 d5					push de 
84f3 cd ab 80				call se_readbyte 
84f6 5f					ld e,a 
84f7 23					inc hl 
84f8 cd ab 80				call se_readbyte 
84fb 57					ld d, a 
84fc			 
84fc e1					pop hl 
84fd e5					push hl 
84fe cd f4 8c				call cmp16 
8501 28 2a				jr z, .fffound 
8503			 
8503 d1					pop de 
8504 c1					pop bc 
8505 e1					pop hl 
8506					; is found? 
8506					;cp e 
8506					;ret z 
8506			 
8506 3e 40				ld a, STORE_BLOCK_PHY 
8508 cd d6 8c				call addatohl 
850b 10 e3				djnz .ff2 
850d			 
850d			 
850d					if DEBUG_FORTH_WORDS 
850d					DMARK "FN-" 
850d f5				push af  
850e 3a 22 85			ld a, (.dmark)  
8511 32 62 ee			ld (debug_mark),a  
8514 3a 23 85			ld a, (.dmark+1)  
8517 32 63 ee			ld (debug_mark+1),a  
851a 3a 24 85			ld a, (.dmark+2)  
851d 32 64 ee			ld (debug_mark+2),a  
8520 18 03			jr .pastdmark  
8522 ..			.dmark: db "FN-"  
8525 f1			.pastdmark: pop af  
8526			endm  
# End of macro DMARK
8526					;	push af 
8526					;	ld a, 'n' 
8526					;	ld (debug_mark),a 
8526					;	pop af 
8526						CALLMONITOR 
8526 cd 6f ee			call debug_vector  
8529				endm  
# End of macro CALLMONITOR
8529					endif 
8529				; no free marks! 
8529 21 00 00				ld hl, 0 
852c c9				ret 
852d			.fffound: 
852d				 
852d			 
852d d1					pop de 
852e c1					pop bc 
852f e1					pop hl 
8530					if DEBUG_FORTH_WORDS 
8530					DMARK "FNF" 
8530 f5				push af  
8531 3a 45 85			ld a, (.dmark)  
8534 32 62 ee			ld (debug_mark),a  
8537 3a 46 85			ld a, (.dmark+1)  
853a 32 63 ee			ld (debug_mark+1),a  
853d 3a 47 85			ld a, (.dmark+2)  
8540 32 64 ee			ld (debug_mark+2),a  
8543 18 03			jr .pastdmark  
8545 ..			.dmark: db "FNF"  
8548 f1			.pastdmark: pop af  
8549			endm  
# End of macro DMARK
8549					;	push af 
8549					;	ld a, 'n' 
8549					;	ld (debug_mark),a 
8549					;	pop af 
8549						CALLMONITOR 
8549 cd 6f ee			call debug_vector  
854c				endm  
# End of macro CALLMONITOR
854c					endif 
854c c9				ret 
854d			 
854d			 
854d			 
854d			; Free Space 
854d			; ---------- 
854d			; 
854d			; With current bank 
854d			; 
854d			; Set block count to zero 
854d			; Starting with first logical block 
854d			;      Find free block  
854d			;      If block id given, increment block count 
854d			; 
854d			;  
854d			 
854d			 
854d			; hl contains count of free blocks 
854d			 
854d			storage_freeblocks: 
854d			 
854d				; now locate first 0 page to mark as a free block 
854d			 
854d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
854f 21 40 00			ld hl, STORE_BLOCK_PHY 
8552 11 00 00			ld de, 0 
8555			 
8555			.fb1:   	 
8555 e5					push hl 
8556 c5					push bc 
8557 d5					push de 
8558 cd ab 80				call se_readbyte 
855b d1					pop de 
855c c1					pop bc 
855d e1					pop hl 
855e			 
855e					; is free? 
855e			;		cp 0 
855e b7					or a 
855f 20 01				jr nz, .ff1cont 
8561 13					inc de 
8562			 
8562			.ff1cont: 
8562			 
8562			 
8562 3e 40				ld a, STORE_BLOCK_PHY 
8564 cd d6 8c				call addatohl 
8567 10 ec				djnz .fb1 
8569			 
8569 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
856b			.fb2:   	 
856b e5					push hl 
856c c5					push bc 
856d d5					push de 
856e cd ab 80				call se_readbyte 
8571 d1					pop de 
8572 c1					pop bc 
8573 e1					pop hl 
8574			 
8574					; is free? 
8574			;		cp 0 
8574 b7					or a 
8575 20 01				jr nz, .ff2cont 
8577 13					inc de 
8578			 
8578			.ff2cont: 
8578			 
8578 3e 40				ld a, STORE_BLOCK_PHY 
857a cd d6 8c				call addatohl 
857d 10 ec				djnz .fb2 
857f			 
857f eb				ex de, hl 
8580 c9				ret 
8581			 
8581			; Get File ID 
8581			; ----------- 
8581			; 
8581			; With current bank 
8581			;  
8581			; Load Block 0 Config 
8581			; Get max file id number 
8581			; For each logical block 
8581			;    Read block file id 
8581			;      If first block of file and dont have file id 
8581			;         if file get id and exit 
8581			 
8581			 
8581			 
8581			 
8581			; Create File 
8581			; ----------- 
8581			; 
8581			; With current bank  
8581			; Load Block 0 Config 
8581			; Get max file id number 
8581			; Increment file id number 
8581			; Save Config 
8581			; Find free block 
8581			; Set buffer with file name and file id 
8581			; Write buffer to free block  
8581			 
8581			 
8581			; hl point to file name 
8581			; hl returns file id 
8581			 
8581			; file format: 
8581			; byte 0 - file id 
8581			; byte 1 - extent number 
8581			; byte 2-> data 
8581			 
8581			; format for extent number 0: 
8581			; 
8581			; byte 0 - file id 
8581			; byte 1 - extent 0 
8581			; byte 2 - extent count 
8581			; byte 3 -> file name and meta data 
8581			 
8581			 
8581			storage_create: 
8581				if DEBUG_STORESE 
8581					DMARK "SCR" 
8581 f5				push af  
8582 3a 96 85			ld a, (.dmark)  
8585 32 62 ee			ld (debug_mark),a  
8588 3a 97 85			ld a, (.dmark+1)  
858b 32 63 ee			ld (debug_mark+1),a  
858e 3a 98 85			ld a, (.dmark+2)  
8591 32 64 ee			ld (debug_mark+2),a  
8594 18 03			jr .pastdmark  
8596 ..			.dmark: db "SCR"  
8599 f1			.pastdmark: pop af  
859a			endm  
# End of macro DMARK
859a					CALLMONITOR 
859a cd 6f ee			call debug_vector  
859d				endm  
# End of macro CALLMONITOR
859d				endif 
859d			 
859d e5				push hl		; save file name pointer 
859e			 
859e cd 35 82			call storage_get_block_0 
85a1			 
85a1 3a 71 ea			ld a,(store_page)	; get current file id 
85a4 3c				inc a 
85a5 32 71 ea			ld (store_page),a 
85a8				 
85a8 32 65 ea			ld (store_tmpid),a			; save id 
85ab			 
85ab 21 00 00			ld hl, 0 
85ae 11 71 ea			ld de, store_page 
85b1				if DEBUG_STORESE 
85b1					DMARK "SCw" 
85b1 f5				push af  
85b2 3a c6 85			ld a, (.dmark)  
85b5 32 62 ee			ld (debug_mark),a  
85b8 3a c7 85			ld a, (.dmark+1)  
85bb 32 63 ee			ld (debug_mark+1),a  
85be 3a c8 85			ld a, (.dmark+2)  
85c1 32 64 ee			ld (debug_mark+2),a  
85c4 18 03			jr .pastdmark  
85c6 ..			.dmark: db "SCw"  
85c9 f1			.pastdmark: pop af  
85ca			endm  
# End of macro DMARK
85ca					CALLMONITOR 
85ca cd 6f ee			call debug_vector  
85cd				endm  
# End of macro CALLMONITOR
85cd				endif 
85cd cd ec 81			call storage_write_block	 ; save update 
85d0			 
85d0				if DEBUG_STORESE 
85d0 11 71 ea				ld de, store_page 
85d3					DMARK "SCC" 
85d3 f5				push af  
85d4 3a e8 85			ld a, (.dmark)  
85d7 32 62 ee			ld (debug_mark),a  
85da 3a e9 85			ld a, (.dmark+1)  
85dd 32 63 ee			ld (debug_mark+1),a  
85e0 3a ea 85			ld a, (.dmark+2)  
85e3 32 64 ee			ld (debug_mark+2),a  
85e6 18 03			jr .pastdmark  
85e8 ..			.dmark: db "SCC"  
85eb f1			.pastdmark: pop af  
85ec			endm  
# End of macro DMARK
85ec					CALLMONITOR 
85ec cd 6f ee			call debug_vector  
85ef				endm  
# End of macro CALLMONITOR
85ef				endif 
85ef				;  
85ef				 
85ef 21 40 00			ld hl, STORE_BLOCK_PHY 
85f2 11 00 00			ld de, 0 
85f5 cd b3 84			call storage_findnextid 
85f8			 
85f8 22 5c ea			ld (store_tmppageid), hl    ; save page to use  
85fb			 
85fb				; TODO detect 0 = no spare blocks 
85fb			 
85fb				; hl now contains the free page to use for the file header page 
85fb			 
85fb				if DEBUG_STORESE 
85fb				DMARK "SCF" 
85fb f5				push af  
85fc 3a 10 86			ld a, (.dmark)  
85ff 32 62 ee			ld (debug_mark),a  
8602 3a 11 86			ld a, (.dmark+1)  
8605 32 63 ee			ld (debug_mark+1),a  
8608 3a 12 86			ld a, (.dmark+2)  
860b 32 64 ee			ld (debug_mark+2),a  
860e 18 03			jr .pastdmark  
8610 ..			.dmark: db "SCF"  
8613 f1			.pastdmark: pop af  
8614			endm  
# End of macro DMARK
8614					CALLMONITOR 
8614 cd 6f ee			call debug_vector  
8617				endm  
# End of macro CALLMONITOR
8617				endif 
8617			 
8617 22 5c ea			ld (store_tmppageid), hl 
861a				 
861a 3a 65 ea			ld a,(store_tmpid)    ; get file id 
861d			;	ld a, (store_filecache)			; save to cache 
861d			 
861d 32 71 ea			ld (store_page),a    ; set page id 
8620 3e 00			ld a, 0			 ; extent 0 is file header 
8622 32 72 ea			ld (store_page+1), a   ; set file extent 
8625			 
8625 32 73 ea			ld (store_page+2), a   ; extent count for the file 
8628			 
8628			;	inc hl 		; init block 0 of file 
8628			;	inc hl   		; skip file and extent id 
8628			 ;       ld a, 0 
8628			;	ld (hl),a 
8628			;	ld a, (store_filecache+1)  	; save to cache 
8628			 
8628			;	inc hl    ; file name 
8628				 
8628				 
8628 11 74 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
862b				if DEBUG_STORESE 
862b					DMARK "SCc" 
862b f5				push af  
862c 3a 40 86			ld a, (.dmark)  
862f 32 62 ee			ld (debug_mark),a  
8632 3a 41 86			ld a, (.dmark+1)  
8635 32 63 ee			ld (debug_mark+1),a  
8638 3a 42 86			ld a, (.dmark+2)  
863b 32 64 ee			ld (debug_mark+2),a  
863e 18 03			jr .pastdmark  
8640 ..			.dmark: db "SCc"  
8643 f1			.pastdmark: pop af  
8644			endm  
# End of macro DMARK
8644					CALLMONITOR 
8644 cd 6f ee			call debug_vector  
8647				endm  
# End of macro CALLMONITOR
8647				endif 
8647 e1				pop hl    ; get zero term string 
8648 e5				push hl 
8649 3e 00			ld a, 0 
864b cd 39 90			call strlent 
864e 23				inc hl   ; cover zero term 
864f 06 00			ld b,0 
8651 4d				ld c,l 
8652 e1				pop hl 
8653				;ex de, hl 
8653				if DEBUG_STORESE 
8653					DMARK "SCa" 
8653 f5				push af  
8654 3a 68 86			ld a, (.dmark)  
8657 32 62 ee			ld (debug_mark),a  
865a 3a 69 86			ld a, (.dmark+1)  
865d 32 63 ee			ld (debug_mark+1),a  
8660 3a 6a 86			ld a, (.dmark+2)  
8663 32 64 ee			ld (debug_mark+2),a  
8666 18 03			jr .pastdmark  
8668 ..			.dmark: db "SCa"  
866b f1			.pastdmark: pop af  
866c			endm  
# End of macro DMARK
866c					;push af 
866c					;ld a, 'a' 
866c					;ld (debug_mark),a 
866c					;pop af 
866c					CALLMONITOR 
866c cd 6f ee			call debug_vector  
866f				endm  
# End of macro CALLMONITOR
866f				endif 
866f ed b0			ldir    ; copy zero term string 
8671				if DEBUG_STORESE 
8671					DMARK "SCA" 
8671 f5				push af  
8672 3a 86 86			ld a, (.dmark)  
8675 32 62 ee			ld (debug_mark),a  
8678 3a 87 86			ld a, (.dmark+1)  
867b 32 63 ee			ld (debug_mark+1),a  
867e 3a 88 86			ld a, (.dmark+2)  
8681 32 64 ee			ld (debug_mark+2),a  
8684 18 03			jr .pastdmark  
8686 ..			.dmark: db "SCA"  
8689 f1			.pastdmark: pop af  
868a			endm  
# End of macro DMARK
868a					CALLMONITOR 
868a cd 6f ee			call debug_vector  
868d				endm  
# End of macro CALLMONITOR
868d				endif 
868d			 
868d				; write file header page 
868d			 
868d 2a 5c ea			ld hl,(store_tmppageid) 
8690 11 71 ea			ld de, store_page 
8693				if DEBUG_STORESE 
8693					DMARK "SCb" 
8693 f5				push af  
8694 3a a8 86			ld a, (.dmark)  
8697 32 62 ee			ld (debug_mark),a  
869a 3a a9 86			ld a, (.dmark+1)  
869d 32 63 ee			ld (debug_mark+1),a  
86a0 3a aa 86			ld a, (.dmark+2)  
86a3 32 64 ee			ld (debug_mark+2),a  
86a6 18 03			jr .pastdmark  
86a8 ..			.dmark: db "SCb"  
86ab f1			.pastdmark: pop af  
86ac			endm  
# End of macro DMARK
86ac					;push af 
86ac					;ld a, 'b' 
86ac					;ld (debug_mark),a 
86ac					;pop af 
86ac					CALLMONITOR 
86ac cd 6f ee			call debug_vector  
86af				endm  
# End of macro CALLMONITOR
86af				endif 
86af cd ec 81			call storage_write_block 
86b2			 
86b2 3a 65 ea			ld a, (store_tmpid) 
86b5 6f				ld l, a 
86b6 26 00			ld h,0 
86b8				if DEBUG_STORESE 
86b8					DMARK "SCz" 
86b8 f5				push af  
86b9 3a cd 86			ld a, (.dmark)  
86bc 32 62 ee			ld (debug_mark),a  
86bf 3a ce 86			ld a, (.dmark+1)  
86c2 32 63 ee			ld (debug_mark+1),a  
86c5 3a cf 86			ld a, (.dmark+2)  
86c8 32 64 ee			ld (debug_mark+2),a  
86cb 18 03			jr .pastdmark  
86cd ..			.dmark: db "SCz"  
86d0 f1			.pastdmark: pop af  
86d1			endm  
# End of macro DMARK
86d1					CALLMONITOR 
86d1 cd 6f ee			call debug_vector  
86d4				endm  
# End of macro CALLMONITOR
86d4				endif 
86d4 c9				ret 
86d5				 
86d5			 
86d5			 
86d5			; 
86d5			; Read File 
86d5			; 
86d5			; h - file id to locate 
86d5			; l - extent to locate 
86d5			; de - pointer to string to read into 
86d5			; 
86d5			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d5			 
86d5			.sr_fail: 
86d5 d1				pop de 
86d6 c9				ret 
86d7			 
86d7			storage_read: 
86d7			 
86d7			 
86d7 d5				push de 
86d8			 
86d8			; TODO BUG the above push is it popped before the RET Z? 
86d8			 
86d8			; TODO how to handle multiple part blocks 
86d8			 
86d8				; locate file extent to read 
86d8			 
86d8 5c				ld e, h 
86d9 55				ld d, l 
86da			 
86da			.srext: 
86da 22 6f ea			ld (store_readptr), hl     ; save the current extent to load 
86dd ed 53 6d ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86e1			 
86e1 21 40 00			ld hl, STORE_BLOCK_PHY 
86e4				if DEBUG_STORESE 
86e4					DMARK "sre" 
86e4 f5				push af  
86e5 3a f9 86			ld a, (.dmark)  
86e8 32 62 ee			ld (debug_mark),a  
86eb 3a fa 86			ld a, (.dmark+1)  
86ee 32 63 ee			ld (debug_mark+1),a  
86f1 3a fb 86			ld a, (.dmark+2)  
86f4 32 64 ee			ld (debug_mark+2),a  
86f7 18 03			jr .pastdmark  
86f9 ..			.dmark: db "sre"  
86fc f1			.pastdmark: pop af  
86fd			endm  
# End of macro DMARK
86fd					CALLMONITOR 
86fd cd 6f ee			call debug_vector  
8700				endm  
# End of macro CALLMONITOR
8700				endif 
8700 cd b3 84			call storage_findnextid 
8703			 
8703				if DEBUG_STORESE 
8703					DMARK "srf" 
8703 f5				push af  
8704 3a 18 87			ld a, (.dmark)  
8707 32 62 ee			ld (debug_mark),a  
870a 3a 19 87			ld a, (.dmark+1)  
870d 32 63 ee			ld (debug_mark+1),a  
8710 3a 1a 87			ld a, (.dmark+2)  
8713 32 64 ee			ld (debug_mark+2),a  
8716 18 03			jr .pastdmark  
8718 ..			.dmark: db "srf"  
871b f1			.pastdmark: pop af  
871c			endm  
# End of macro DMARK
871c					CALLMONITOR 
871c cd 6f ee			call debug_vector  
871f				endm  
# End of macro CALLMONITOR
871f				endif 
871f cd ff 8c			call ishlzero 
8722			;	ld a, l 
8722			;	add h 
8722			;	cp 0 
8722 28 b1			jr z,.sr_fail			; block not found so EOF 
8724			 
8724				; save current address for use by higher level words etc 
8724			 
8724 22 62 ea			ld (store_openaddr),hl 
8727			 
8727			 
8727				; hl contains page number to load 
8727 d1				pop de   ; get storage 
8728 ed 53 6d ea		ld (store_readbuf), de     ; current buffer to load in to 
872c d5				push de 
872d				if DEBUG_STORESE 
872d					DMARK "srg" 
872d f5				push af  
872e 3a 42 87			ld a, (.dmark)  
8731 32 62 ee			ld (debug_mark),a  
8734 3a 43 87			ld a, (.dmark+1)  
8737 32 63 ee			ld (debug_mark+1),a  
873a 3a 44 87			ld a, (.dmark+2)  
873d 32 64 ee			ld (debug_mark+2),a  
8740 18 03			jr .pastdmark  
8742 ..			.dmark: db "srg"  
8745 f1			.pastdmark: pop af  
8746			endm  
# End of macro DMARK
8746					CALLMONITOR 
8746 cd 6f ee			call debug_vector  
8749				endm  
# End of macro CALLMONITOR
8749				endif 
8749 cd 87 81			call storage_read_block 
874c			 
874c				; if this a continuation read??? 
874c			 
874c 2a 6d ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874f			 
874f 3e 3f			ld a, STORE_BLOCK_PHY-1 
8751 cd d6 8c			call addatohl 
8754 7e				ld a,(hl) 
8755			;	cp 0 
8755 b7				or a 
8756 28 02			jr z, .markiscont 
8758 3e ff			ld a, 255 
875a			 
875a			.markiscont: 
875a 32 64 ea			ld (store_readcont), a 
875d			 
875d				if DEBUG_STORESE 
875d					DMARK "srC" 
875d f5				push af  
875e 3a 72 87			ld a, (.dmark)  
8761 32 62 ee			ld (debug_mark),a  
8764 3a 73 87			ld a, (.dmark+1)  
8767 32 63 ee			ld (debug_mark+1),a  
876a 3a 74 87			ld a, (.dmark+2)  
876d 32 64 ee			ld (debug_mark+2),a  
8770 18 03			jr .pastdmark  
8772 ..			.dmark: db "srC"  
8775 f1			.pastdmark: pop af  
8776			endm  
# End of macro DMARK
8776					CALLMONITOR 
8776 cd 6f ee			call debug_vector  
8779				endm  
# End of macro CALLMONITOR
8779				endif 
8779				; only short reads enabled 
8779			 
8779 3a 6c ea			ld a, (store_longread) 
877c			;	cp 0 
877c b7				or a 
877d ca 49 88			jp z, .readdone 
8780			 
8780			; TODO if block has no zeros then need to read next block  
8780			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
8780			; check last byte of physical block. 
8780			; if not zero then the next block needs to be loaded 
8780			 
8780			 
8780 2a 6d ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8783			 
8783 3e 3f			ld a, STORE_BLOCK_PHY-1 
8785 cd d6 8c			call addatohl 
8788				;dec hl 
8788 7e				ld a,(hl) 
8789				if DEBUG_STORESE 
8789					DMARK "sr?" 
8789 f5				push af  
878a 3a 9e 87			ld a, (.dmark)  
878d 32 62 ee			ld (debug_mark),a  
8790 3a 9f 87			ld a, (.dmark+1)  
8793 32 63 ee			ld (debug_mark+1),a  
8796 3a a0 87			ld a, (.dmark+2)  
8799 32 64 ee			ld (debug_mark+2),a  
879c 18 03			jr .pastdmark  
879e ..			.dmark: db "sr?"  
87a1 f1			.pastdmark: pop af  
87a2			endm  
# End of macro DMARK
87a2					CALLMONITOR 
87a2 cd 6f ee			call debug_vector  
87a5				endm  
# End of macro CALLMONITOR
87a5				endif 
87a5			;	cp 0 
87a5 b7				or a 
87a6 ca 49 88			jp z, .readdone 
87a9			 
87a9				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a9			 
87a9 23				inc hl 
87aa			 
87aa 22 6d ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ad			 
87ad ed 5b 6f ea		ld de, (store_readptr)     ; save the current extent to load 
87b1			 
87b1 eb				ex de, hl 
87b2			 
87b2				; next ext 
87b2			 
87b2 23				inc hl 
87b3 22 6f ea			ld  (store_readptr), hl     ; save the current extent to load 
87b6			 
87b6				if DEBUG_STORESE 
87b6					DMARK "sF2" 
87b6 f5				push af  
87b7 3a cb 87			ld a, (.dmark)  
87ba 32 62 ee			ld (debug_mark),a  
87bd 3a cc 87			ld a, (.dmark+1)  
87c0 32 63 ee			ld (debug_mark+1),a  
87c3 3a cd 87			ld a, (.dmark+2)  
87c6 32 64 ee			ld (debug_mark+2),a  
87c9 18 03			jr .pastdmark  
87cb ..			.dmark: db "sF2"  
87ce f1			.pastdmark: pop af  
87cf			endm  
# End of macro DMARK
87cf					CALLMONITOR 
87cf cd 6f ee			call debug_vector  
87d2				endm  
# End of macro CALLMONITOR
87d2				endif 
87d2			 
87d2				; get and load block 
87d2			 
87d2 cd b3 84			call storage_findnextid 
87d5			 
87d5				if DEBUG_STORESE 
87d5					DMARK "sf2" 
87d5 f5				push af  
87d6 3a ea 87			ld a, (.dmark)  
87d9 32 62 ee			ld (debug_mark),a  
87dc 3a eb 87			ld a, (.dmark+1)  
87df 32 63 ee			ld (debug_mark+1),a  
87e2 3a ec 87			ld a, (.dmark+2)  
87e5 32 64 ee			ld (debug_mark+2),a  
87e8 18 03			jr .pastdmark  
87ea ..			.dmark: db "sf2"  
87ed f1			.pastdmark: pop af  
87ee			endm  
# End of macro DMARK
87ee					CALLMONITOR 
87ee cd 6f ee			call debug_vector  
87f1				endm  
# End of macro CALLMONITOR
87f1				endif 
87f1 cd ff 8c			call ishlzero 
87f4			;	ld a, l 
87f4			;	add h 
87f4			;	cp 0 
87f4 ca d5 86			jp z,.sr_fail			; block not found so EOF 
87f7				 
87f7				; save current address for use by higher level words etc 
87f7			 
87f7 22 62 ea			ld (store_openaddr),hl 
87fa			 
87fa cd 87 81			call storage_read_block 
87fd			 
87fd				; on a continuation block, we now have the file id and ext in the middle of the block 
87fd				; we need to pull everything back  
87fd			 
87fd ed 5b 6d ea		ld de, (store_readbuf)     ; current buffer to nudge into 
8801 2a 6d ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8804 23				inc hl 
8805 23				inc hl     ; skip id and ext 
8806 01 40 00			ld bc, STORE_BLOCK_PHY 
8809				if DEBUG_STORESE 
8809					DMARK "SR<" 
8809 f5				push af  
880a 3a 1e 88			ld a, (.dmark)  
880d 32 62 ee			ld (debug_mark),a  
8810 3a 1f 88			ld a, (.dmark+1)  
8813 32 63 ee			ld (debug_mark+1),a  
8816 3a 20 88			ld a, (.dmark+2)  
8819 32 64 ee			ld (debug_mark+2),a  
881c 18 03			jr .pastdmark  
881e ..			.dmark: db "SR<"  
8821 f1			.pastdmark: pop af  
8822			endm  
# End of macro DMARK
8822					CALLMONITOR 
8822 cd 6f ee			call debug_vector  
8825				endm  
# End of macro CALLMONITOR
8825				endif 
8825 ed b0			ldir     ; copy data 
8827			 
8827				; move the pointer back and pretend we have a full buffer for next recheck 
8827			 
8827 1b				dec de 
8828 1b				dec de 
8829			 
8829			; TODO do pop below now short circuit loop????? 
8829 c1				pop bc     ; get rid of spare de on stack 
882a				if DEBUG_STORESE 
882a					DMARK "SR>" 
882a f5				push af  
882b 3a 3f 88			ld a, (.dmark)  
882e 32 62 ee			ld (debug_mark),a  
8831 3a 40 88			ld a, (.dmark+1)  
8834 32 63 ee			ld (debug_mark+1),a  
8837 3a 41 88			ld a, (.dmark+2)  
883a 32 64 ee			ld (debug_mark+2),a  
883d 18 03			jr .pastdmark  
883f ..			.dmark: db "SR>"  
8842 f1			.pastdmark: pop af  
8843			endm  
# End of macro DMARK
8843					CALLMONITOR 
8843 cd 6f ee			call debug_vector  
8846				endm  
# End of macro CALLMONITOR
8846				endif 
8846 c3 da 86			jp .srext 
8849			 
8849			 
8849			 
8849			 
8849			 
8849			.readdone:		 
8849 e1				pop hl 		 ; return start of data to show as not EOF 
884a 23				inc hl   ; past file id 
884b 23				inc hl   ; past ext 
884c				if DEBUG_STORESE 
884c					DMARK "SRe" 
884c f5				push af  
884d 3a 61 88			ld a, (.dmark)  
8850 32 62 ee			ld (debug_mark),a  
8853 3a 62 88			ld a, (.dmark+1)  
8856 32 63 ee			ld (debug_mark+1),a  
8859 3a 63 88			ld a, (.dmark+2)  
885c 32 64 ee			ld (debug_mark+2),a  
885f 18 03			jr .pastdmark  
8861 ..			.dmark: db "SRe"  
8864 f1			.pastdmark: pop af  
8865			endm  
# End of macro DMARK
8865					CALLMONITOR 
8865 cd 6f ee			call debug_vector  
8868				endm  
# End of macro CALLMONITOR
8868				endif 
8868 c9					ret 
8869			 
8869			 
8869			 
8869			; 
8869			; Append File 
8869			; 
8869			; hl - file id to locate 
8869			; de - pointer to (multi block) string to write 
8869			 
8869			.sa_notfound: 
8869 d1				pop de 
886a c9				ret 
886b			 
886b			 
886b			storage_append: 
886b				; hl -  file id to append to 
886b				; de - string to append 
886b			 
886b d5				push de 
886c				 
886c				if DEBUG_STORESE 
886c					DMARK "AP1" 
886c f5				push af  
886d 3a 81 88			ld a, (.dmark)  
8870 32 62 ee			ld (debug_mark),a  
8873 3a 82 88			ld a, (.dmark+1)  
8876 32 63 ee			ld (debug_mark+1),a  
8879 3a 83 88			ld a, (.dmark+2)  
887c 32 64 ee			ld (debug_mark+2),a  
887f 18 03			jr .pastdmark  
8881 ..			.dmark: db "AP1"  
8884 f1			.pastdmark: pop af  
8885			endm  
# End of macro DMARK
8885					CALLMONITOR 
8885 cd 6f ee			call debug_vector  
8888				endm  
# End of macro CALLMONITOR
8888				endif 
8888			 
8888 7d				ld a, l 
8889 32 65 ea			ld (store_tmpid), a 
888c			 
888c				; get file header  
888c			 
888c 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888e 3a 65 ea			ld a, (store_tmpid) 
8891 5f				ld e, a 
8892			 
8892 21 40 00				ld hl, STORE_BLOCK_PHY 
8895 cd b3 84				call storage_findnextid 
8898			 
8898 cd ff 8c			call ishlzero 
889b 28 cc			jr z, .sa_notfound 
889d			 
889d 22 5c ea			ld (store_tmppageid), hl 
88a0			 
88a0				; TODO handle file id not found 
88a0			 
88a0				if DEBUG_STORESE 
88a0					DMARK "AP2" 
88a0 f5				push af  
88a1 3a b5 88			ld a, (.dmark)  
88a4 32 62 ee			ld (debug_mark),a  
88a7 3a b6 88			ld a, (.dmark+1)  
88aa 32 63 ee			ld (debug_mark+1),a  
88ad 3a b7 88			ld a, (.dmark+2)  
88b0 32 64 ee			ld (debug_mark+2),a  
88b3 18 03			jr .pastdmark  
88b5 ..			.dmark: db "AP2"  
88b8 f1			.pastdmark: pop af  
88b9			endm  
# End of macro DMARK
88b9					CALLMONITOR 
88b9 cd 6f ee			call debug_vector  
88bc				endm  
# End of macro CALLMONITOR
88bc				endif 
88bc			 
88bc				; update file extent count 
88bc			 
88bc 11 71 ea			ld de, store_page 
88bf			 
88bf cd 87 81			call storage_read_block 
88c2			 
88c2				if DEBUG_STORESE 
88c2					DMARK "AP3" 
88c2 f5				push af  
88c3 3a d7 88			ld a, (.dmark)  
88c6 32 62 ee			ld (debug_mark),a  
88c9 3a d8 88			ld a, (.dmark+1)  
88cc 32 63 ee			ld (debug_mark+1),a  
88cf 3a d9 88			ld a, (.dmark+2)  
88d2 32 64 ee			ld (debug_mark+2),a  
88d5 18 03			jr .pastdmark  
88d7 ..			.dmark: db "AP3"  
88da f1			.pastdmark: pop af  
88db			endm  
# End of macro DMARK
88db					CALLMONITOR 
88db cd 6f ee			call debug_vector  
88de				endm  
# End of macro CALLMONITOR
88de				endif 
88de			;	ld (store_tmppageid), hl 
88de			 
88de 3a 73 ea			ld a, (store_page+2) 
88e1 3c				inc a 
88e2 32 73 ea			ld (store_page+2), a 
88e5 32 64 ea			ld (store_tmpext), a 
88e8				 
88e8				if DEBUG_STORESE 
88e8					DMARK "AP3" 
88e8 f5				push af  
88e9 3a fd 88			ld a, (.dmark)  
88ec 32 62 ee			ld (debug_mark),a  
88ef 3a fe 88			ld a, (.dmark+1)  
88f2 32 63 ee			ld (debug_mark+1),a  
88f5 3a ff 88			ld a, (.dmark+2)  
88f8 32 64 ee			ld (debug_mark+2),a  
88fb 18 03			jr .pastdmark  
88fd ..			.dmark: db "AP3"  
8900 f1			.pastdmark: pop af  
8901			endm  
# End of macro DMARK
8901					CALLMONITOR 
8901 cd 6f ee			call debug_vector  
8904				endm  
# End of macro CALLMONITOR
8904				endif 
8904 2a 5c ea			ld hl, (store_tmppageid) 
8907 11 71 ea			ld de, store_page 
890a cd ec 81			call storage_write_block 
890d			 
890d				; find free block 
890d			 
890d 11 00 00			ld de, 0			 ; file extent to locate 
8910			 
8910 21 40 00				ld hl, STORE_BLOCK_PHY 
8913 cd b3 84				call storage_findnextid 
8916 cd ff 8c			call ishlzero 
8919 ca 69 88			jp z, .sa_notfound 
891c			 
891c					; TODO handle no space left 
891c					 
891c 22 5c ea				ld (store_tmppageid), hl 
891f			 
891f				if DEBUG_STORESE 
891f					DMARK "AP4" 
891f f5				push af  
8920 3a 34 89			ld a, (.dmark)  
8923 32 62 ee			ld (debug_mark),a  
8926 3a 35 89			ld a, (.dmark+1)  
8929 32 63 ee			ld (debug_mark+1),a  
892c 3a 36 89			ld a, (.dmark+2)  
892f 32 64 ee			ld (debug_mark+2),a  
8932 18 03			jr .pastdmark  
8934 ..			.dmark: db "AP4"  
8937 f1			.pastdmark: pop af  
8938			endm  
# End of macro DMARK
8938					CALLMONITOR 
8938 cd 6f ee			call debug_vector  
893b				endm  
# End of macro CALLMONITOR
893b				endif 
893b					; init the buffer with zeros so we can id if the buffer is full or not 
893b			 
893b e5					push hl 
893c c5					push bc 
893d			 
893d 21 71 ea				ld hl, store_page 
8940 06 40				ld b, STORE_BLOCK_PHY 
8942			;		ld a, 0 
8942 36 00		.zeroblock:	ld (hl), 0 
8944 23					inc hl 
8945 10 fb				djnz .zeroblock 
8947			 
8947 c1					pop bc 
8948 e1					pop hl 
8949			 
8949					; construct block 
8949			 
8949 3a 65 ea				ld a, (store_tmpid) 
894c 32 71 ea				ld (store_page), a   ; file id 
894f 3a 64 ea				ld a, (store_tmpext)   ; extent for this block 
8952 32 72 ea				ld (store_page+1), a 
8955			 
8955 e1					pop hl    ; get string to write 
8956 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8958 11 73 ea				ld de, store_page+2 
895b			 
895b				if DEBUG_STORESE 
895b					DMARK "AP5" 
895b f5				push af  
895c 3a 70 89			ld a, (.dmark)  
895f 32 62 ee			ld (debug_mark),a  
8962 3a 71 89			ld a, (.dmark+1)  
8965 32 63 ee			ld (debug_mark+1),a  
8968 3a 72 89			ld a, (.dmark+2)  
896b 32 64 ee			ld (debug_mark+2),a  
896e 18 03			jr .pastdmark  
8970 ..			.dmark: db "AP5"  
8973 f1			.pastdmark: pop af  
8974			endm  
# End of macro DMARK
8974					CALLMONITOR 
8974 cd 6f ee			call debug_vector  
8977				endm  
# End of macro CALLMONITOR
8977				endif 
8977			 
8977			 
8977			 
8977					; fill buffer with data until end of string or full block 
8977			 
8977 7e			.appd:		ld a, (hl) 
8978 12					ld (de), a 
8979			;		cp 0 
8979 b7					or a 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f7				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a 5c ea			ld hl, (store_tmppageid) 
8985 11 71 ea			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 62 ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 63 ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 64 ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd 6f ee			call debug_vector  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd ec 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9					;cp 0		 ; no, string was fully written 
89a9 b7					or a 
89aa c8					ret z 
89ab			 
89ab					; setup vars for next cycle 
89ab			 
89ab 3a 65 ea				ld a, (store_tmpid) 
89ae 6f					ld l, a 
89af 26 00				ld h, 0 
89b1			 
89b1 c3 6b 88			 	jp storage_append	 ; yes, need to write out some more 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			if DEBUG_STORECF 
89b4			storageput:	 
89b4					ret 
89b4			storageread: 
89b4					ld hl, store_page 
89b4					ld b, 200 
89b4			;		ld a,0 
89b4			.src:		ld (hl),0 
89b4					inc hl 
89b4					djnz .src 
89b4					 
89b4			 
89b4					ld de, 0 
89b4					ld bc, 1 
89b4					ld hl, store_page 
89b4					call cfRead 
89b4			 
89b4				call cfGetError 
89b4				ld hl,scratch 
89b4				call hexout 
89b4				ld hl, scratch+2 
89b4			;	ld a, 0 
89b4				ld (hl),0 
89b4				ld de, scratch 
89b4				ld a,display_row_1 
89b4				call str_at_display 
89b4				call update_display 
89b4			 
89b4					ld hl, store_page 
89b4					ld (os_cur_ptr),hl 
89b4			 
89b4					ret 
89b4			endif 
89b4			 
89b4			 
89b4			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b4			 
89b4			storage_clear_page: 
89b4 e5				push hl 
89b5 d5				push de 
89b6 c5				push bc 
89b7 21 71 ea			ld hl, store_page 
89ba			;	ld a, 0 
89ba 36 00			ld (hl), 0 
89bc			 
89bc 11 72 ea			ld de, store_page+1 
89bf 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c2			 
89c2 ed b0			ldir 
89c4				 
89c4 c1				pop bc 
89c5 d1				pop de 
89c6 e1				pop hl 
89c7 c9				ret 
89c8			 
89c8			; eof 
# End of file firmware_storage.asm
89c8			  
89c8			; support routines for above hardware abstraction layer  
89c8			  
89c8			include "firmware_general.asm"        ; general support functions  
89c8			 
89c8			; word look up 
89c8			 
89c8			; in 
89c8			; a is the index 
89c8			; hl is pointer start of array 
89c8			; 
89c8			; returns 
89c8			; hl to the word 
89c8			; 
89c8			 
89c8			table_lookup:  
89c8 d5					push de 
89c9 eb					ex de, hl 
89ca			 
89ca 6f					ld l, a 
89cb 26 00				ld h, 0 
89cd 29					add hl, hl 
89ce 19					add hl, de 
89cf 7e					ld a, (hl) 
89d0 23					inc hl 
89d1 66					ld h,(hl) 
89d2 6f					ld l, a 
89d3			 
89d3 d1					pop de 
89d4 c9					ret 
89d5			 
89d5			; Delay loops 
89d5			 
89d5			 
89d5			 
89d5			aDelayInMS: 
89d5 c5				push bc 
89d6 47				ld b,a 
89d7			msdelay: 
89d7 c5				push bc 
89d8				 
89d8			 
89d8 01 41 00			ld bc,041h 
89db cd f3 89			call delayloop 
89de c1				pop bc 
89df 05				dec b 
89e0 20 f5			jr nz,msdelay 
89e2			 
89e2			;if CPU_CLOCK_8MHZ 
89e2			;msdelay8: 
89e2			;	push bc 
89e2			;	 
89e2			; 
89e2			;	ld bc,041h 
89e2			;	call delayloop 
89e2			;	pop bc 
89e2			;	dec b 
89e2			;	jr nz,msdelay8 
89e2			;endif 
89e2			 
89e2			 
89e2 c1				pop bc 
89e3 c9				ret 
89e4			 
89e4			 
89e4			delay250ms: 
89e4				;push de 
89e4 01 00 40			ld bc, 04000h 
89e7 c3 f3 89			jp delayloop 
89ea			delay500ms: 
89ea				;push de 
89ea 01 00 80			ld bc, 08000h 
89ed c3 f3 89			jp delayloop 
89f0			delay1s: 
89f0				;push bc 
89f0			   ; Clobbers A, d and e 
89f0 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f3			delayloop: 
89f3 c5			    push bc 
89f4			 
89f4			if BASE_CPM 
89f4				ld bc, CPM_DELAY_TUNE 
89f4			.cpmloop: 
89f4				push bc 
89f4			 
89f4			endif 
89f4			 
89f4			 
89f4			 
89f4			delayloopi: 
89f4			;	push bc 
89f4			;.dl: 
89f4 cb 47		    bit     0,a    	; 8 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa e6 ff		    and     255  	; 7 
89fc 0b			    dec     bc      	; 6 
89fd 79			    ld      a,c     	; 4 
89fe b0			    or      b     	; 4 
89ff c2 f4 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a02			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a02				;pop de 
8a02			;pop bc 
8a02			 
8a02			if BASE_CPM 
8a02				pop bc 
8a02				 
8a02			    dec     bc      	; 6 
8a02			    ld      a,c     	; 4 
8a02			    or      b     	; 4 
8a02			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a02				 
8a02			 
8a02			endif 
8a02			;if CPU_CLOCK_8MHZ 
8a02			;    pop bc 
8a02			;    push bc 
8a02			;.dl8: 
8a02			;    bit     0,a    	; 8 
8a02			;    bit     0,a    	; 8 
8a02			;    bit     0,a    	; 8 
8a02			;    and     255  	; 7 
8a02			;    dec     bc      	; 6 
8a02			;    ld      a,c     	; 4 
8a02			;    or      b     	; 4 
8a02			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a02			;endif 
8a02			 
8a02			;if CPU_CLOCK_10MHZ 
8a02			;    pop bc 
8a02			;    push bc 
8a02			;.dl8: 
8a02			;    bit     0,a    	; 8 
8a02			;    bit     0,a    	; 8 
8a02			;    bit     0,a    	; 8 
8a02			;    and     255  	; 7 
8a02			;    dec     bc      	; 6 
8a02			;    ld      a,c     	; 4 
8a02			;    or      b     	; 4 
8a02			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a02			;endif 
8a02 c1			    pop bc 
8a03			 
8a03 c9				ret 
8a04			 
8a04			 
8a04			 
8a04			; eof 
# End of file firmware_general.asm
8a04			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a04			; display routines that use the physical hardware abstraction layer 
8a04			 
8a04			 
8a04			; Display an activity indicator 
8a04			; Each call returns the new char pointed to in hl 
8a04			 
8a04			active: 
8a04 3a bd eb			ld a, (display_active) 
8a07 fe 06			cp 6 
8a09			 
8a09 20 02			jr nz, .sne 
8a0b				; gone past the last one reset sequence 
8a0b 3e ff			ld a, 255 
8a0d			 
8a0d			.sne:   
8a0d				; get the next char in seq 
8a0d 3c				inc a 
8a0e 32 bd eb			ld (display_active), a 
8a11			 
8a11				; look up the string in the table 
8a11 21 28 8a			ld hl, actseq 
8a14 cb 27			sla a 
8a16 cd d6 8c			call addatohl 
8a19 cd 30 9d			call loadwordinhl 
8a1c			 
8a1c				; forth will write the to string when pushing so move from rom to ram 
8a1c			 
8a1c 11 be eb			ld de, display_active+1 
8a1f 01 02 00			ld bc, 2 
8a22 ed b0			ldir 
8a24			 
8a24 21 be eb			ld hl, display_active+1 
8a27 c9				ret 
8a28				 
8a28				 
8a28			 
8a28			 
8a28			;db "|/-\|-\" 
8a28			 
8a28			actseq: 
8a28			 
8a28 36 8a		dw spin0 
8a2a 38 8a		dw spin1 
8a2c 3a 8a		dw spin2 
8a2e 3c 8a		dw spin3 
8a30 3a 8a		dw spin2 
8a32 38 8a		dw spin1 
8a34 36 8a		dw spin0 
8a36			 
8a36 .. 00		spin0: db " ", 0 
8a38 .. 00		spin1: db "-", 0 
8a3a .. 00		spin2: db "+", 0 
8a3c .. 00		spin3: db "#", 0 
8a3e			 
8a3e			 
8a3e			; information window 
8a3e			 
8a3e			; pass hl with 1st string to display 
8a3e			; pass de with 2nd string to display 
8a3e			 
8a3e			info_panel: 
8a3e e5				push hl 
8a3f			 
8a3f 2a c3 eb			ld hl, (display_fb_active) 
8a42 e5				push hl    ; future de destination 
8a43 21 a8 ed				ld hl, display_fb0 
8a46 22 c3 eb				ld (display_fb_active), hl 
8a49			 
8a49			;	call clear_display 
8a49			 
8a49				if BASE_CPM 
8a49				ld a, '.' 
8a49				else 
8a49 3e a5			ld a, 165 
8a4b				endif 
8a4b cd b1 8a			call fill_display 
8a4e			 
8a4e			 
8a4e 3e 55			ld a, display_row_3 + 5 
8a50 cd be 8a			call str_at_display 
8a53			 
8a53 e1				pop hl 
8a54 d1				pop de 
8a55			 
8a55 e5				push hl 
8a56			 
8a56			 
8a56 3e 2d			ld a, display_row_2 + 5 
8a58 cd be 8a			call str_at_display 
8a5b			 
8a5b			 
8a5b cd ce 8a			call update_display 
8a5e cd 3f 99			call next_page_prompt 
8a61 cd ac 8a			call clear_display 
8a64			 
8a64				 
8a64 21 07 ed				ld hl, display_fb1 
8a67 22 c3 eb				ld (display_fb_active), hl 
8a6a cd ce 8a			call update_display 
8a6d			 
8a6d e1				pop hl 
8a6e			 
8a6e c9				ret 
8a6f			 
8a6f			 
8a6f			 
8a6f			 
8a6f			; TODO windowing? 
8a6f			 
8a6f			; TODO scroll line up 
8a6f			 
8a6f			scroll_up: 
8a6f			 
8a6f e5				push hl 
8a70 d5				push de 
8a71 c5				push bc 
8a72			 
8a72				; get frame buffer  
8a72			 
8a72 2a c3 eb			ld hl, (display_fb_active) 
8a75 e5				push hl    ; future de destination 
8a76			 
8a76 11 28 00			ld  de, display_cols 
8a79 19				add hl, de 
8a7a			 
8a7a d1				pop de 
8a7b			 
8a7b				;ex de, hl 
8a7b 01 9f 00			ld bc, display_fb_len -1  
8a7e			;if DEBUG_FORTH_WORDS 
8a7e			;	DMARK "SCL" 
8a7e			;	CALLMONITOR 
8a7e			;endif	 
8a7e ed b0			ldir 
8a80			 
8a80				; wipe bottom row 
8a80			 
8a80			 
8a80 2a c3 eb			ld hl, (display_fb_active) 
8a83 11 a0 00			ld de, display_cols*display_rows 
8a86 19				add hl, de 
8a87 06 28			ld b, display_cols 
8a89			;	ld a, ' ' 
8a89			.scwipe: 
8a89 36 20			ld (hl), ' ' 
8a8b 2b				dec hl 
8a8c 10 fb			djnz .scwipe 
8a8e			 
8a8e				;pop hl 
8a8e			 
8a8e c1				pop bc 
8a8f d1				pop de 
8a90 e1				pop hl 
8a91			 
8a91 c9				ret 
8a92			 
8a92			 
8a92			;scroll_upo: 
8a92			;	ld de, display_row_1 
8a92			 ;	ld hl, display_row_2 
8a92			;	ld bc, display_cols 
8a92			;	ldir 
8a92			;	ld de, display_row_2 
8a92			 ;	ld hl, display_row_3 
8a92			;	ld bc, display_cols 
8a92			;	ldir 
8a92			;	ld de, display_row_3 
8a92			 ;	ld hl, display_row_4 
8a92			;	ld bc, display_cols 
8a92			;	ldir 
8a92			 
8a92			; TODO clear row 4 
8a92			 
8a92			;	ret 
8a92			 
8a92				 
8a92			scroll_down: 
8a92			 
8a92 e5				push hl 
8a93 d5				push de 
8a94 c5				push bc 
8a95			 
8a95				; get frame buffer  
8a95			 
8a95 2a c3 eb			ld hl, (display_fb_active) 
8a98			 
8a98 11 9f 00			ld de, display_fb_len - 1 
8a9b 19				add hl, de 
8a9c			 
8a9c e5			push hl    ; future de destination 
8a9d			 
8a9d 11 28 00			ld  de, display_cols 
8aa0 ed 52			sbc hl, de 
8aa2			 
8aa2			 
8aa2 d1				pop de 
8aa3			 
8aa3			;	ex de, hl 
8aa3 01 9f 00			ld bc, display_fb_len -1  
8aa6			 
8aa6			 
8aa6				 
8aa6			 
8aa6 ed b0			ldir 
8aa8			 
8aa8				; wipe bottom row 
8aa8			 
8aa8			 
8aa8			;	ld hl, (display_fb_active) 
8aa8			;;	ld de, display_cols*display_rows 
8aa8			;;	add hl, de 
8aa8			;	ld b, display_cols 
8aa8			;	ld a, ' ' 
8aa8			;.scwiped: 
8aa8			;	ld (hl), a 
8aa8			;	dec hl 
8aa8			;	djnz .scwiped 
8aa8			 
8aa8				;pop hl 
8aa8			 
8aa8 c1				pop bc 
8aa9 d1				pop de 
8aaa e1				pop hl 
8aab			 
8aab c9				ret 
8aac			;scroll_down: 
8aac			;	ld de, display_row_4 
8aac			;	ld hl, display_row_3 
8aac			;	ld bc, display_cols 
8aac			;	ldir 
8aac			;	ld de, display_row_3 
8aac			; 	ld hl, display_row_2 
8aac			;	ld bc, display_cols 
8aac			;	ldir 
8aac			;	ld de, display_row_2 
8aac			;	ld hl, display_row_1 
8aac			;	ld bc, display_cols 
8aac			;	ldir 
8aac			;;; TODO clear row 1 
8aac			;	ret 
8aac			 
8aac			 
8aac			 
8aac			 
8aac			 
8aac			; clear active frame buffer 
8aac			 
8aac			clear_display: 
8aac 3e 20			ld a, ' ' 
8aae c3 b1 8a			jp fill_display 
8ab1			 
8ab1			; fill active frame buffer with a char in A 
8ab1			 
8ab1			fill_display: 
8ab1 06 a0			ld b,display_fb_len 
8ab3 2a c3 eb			ld hl, (display_fb_active) 
8ab6 77			.fd1:	ld (hl),a 
8ab7 23				inc hl 
8ab8 10 fc			djnz .fd1 
8aba 23				inc hl 
8abb			;	ld a,0 
8abb 36 00			ld (hl),0 
8abd			 
8abd			 
8abd c9				ret 
8abe			; Write string (DE) at pos (A) to active frame buffer 
8abe			 
8abe 2a c3 eb		str_at_display:    ld hl,(display_fb_active) 
8ac1 06 00					ld b,0 
8ac3 4f					ld c,a 
8ac4 09					add hl,bc 
8ac5 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ac6 b7			            OR   A              ;Null terminator? 
8ac7 c8			            RET  Z              ;Yes, so finished 
8ac8 77					ld (hl),a 
8ac9 23				inc hl 
8aca 13			            INC  DE             ;Point to next character 
8acb 18 f8		            JR   .sad1     ;Repeat 
8acd c9					ret 
8ace			 
8ace			; using current frame buffer write to physical display 
8ace			 
8ace			update_display: 
8ace e5				push hl 
8acf 2a c3 eb			ld hl, (display_fb_active) 
8ad2 cd c5 e3			call write_display 
8ad5 e1				pop hl 
8ad6 c9				ret 
8ad7			 
8ad7			; TODO scrolling 
8ad7			 
8ad7			 
8ad7			; move cursor right one char 
8ad7			cursor_right: 
8ad7			 
8ad7				; TODO shift right 
8ad7				; TODO if beyond max col 
8ad7				; TODO       cursor_next_line 
8ad7			 
8ad7 c9				ret 
8ad8			 
8ad8			 
8ad8			cursor_next_line: 
8ad8				; TODO first char 
8ad8				; TODO line down 
8ad8				; TODO if past last row 
8ad8				; TODO    scroll up 
8ad8			 
8ad8 c9				ret 
8ad9			 
8ad9			cursor_left: 
8ad9				; TODO shift left 
8ad9				; TODO if beyond left  
8ad9				; TODO     cursor prev line 
8ad9				 
8ad9 c9				ret 
8ada			 
8ada			cursor_prev_line: 
8ada				; TODO last char 
8ada				; TODO line up 
8ada				; TODO if past first row 
8ada				; TODO   scroll down 
8ada			 
8ada c9				ret 
8adb			 
8adb			 
8adb			cout: 
8adb				; A - char 
8adb c9				ret 
8adc			 
8adc			 
8adc			; Display a menu and allow item selection (optional toggle items) 
8adc			; 
8adc			; format: 
8adc			; hl pointer to word array with zero term for items 
8adc			; e.g.    db item1 
8adc			;         db .... 
8adc			;         db 0 
8adc			; 
8adc			; a = starting menu item  
8adc			; 
8adc			; de = pointer item toggle array   (todo) 
8adc			; 
8adc			; returns item selected in a 1-... 
8adc			; returns 0 if back button pressed 
8adc			; 
8adc			; NOTE: Uses system frame buffer to display 
8adc			; 
8adc			; LEFT, Q = go back 
8adc			; RIGHT, SPACE, CR = select 
8adc			; UP, A - Up 
8adc			; DOWN, Z - Down 
8adc			 
8adc			 
8adc			 
8adc			 
8adc			 
8adc			menu: 
8adc			 
8adc					; keep array pointer 
8adc			 
8adc 22 6a ea				ld (store_tmp1), hl 
8adf 32 68 ea				ld (store_tmp2), a 
8ae2			 
8ae2					; check for key bounce 
8ae2			 
8ae2			if BASE_KEV 
8ae2			 
8ae2			.mbounce:	call cin 
8ae2			;		cp 0 
8ae2					or a 
8ae2					jr nz, .mbounce 
8ae2			endif 
8ae2					; for ease use ex 
8ae2			 
8ae2					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae2 21 a8 ed				ld hl, display_fb0 
8ae5 22 c3 eb				ld (display_fb_active), hl 
8ae8			 
8ae8 cd ac 8a		.mloop:		call clear_display 
8aeb cd ce 8a				call update_display 
8aee			 
8aee					; draw selection id '>' at 1 
8aee			 
8aee					; init start of list display 
8aee			 
8aee 3e 05				ld a, 5 
8af0 32 66 ea				ld (store_tmp3), a   ; display row count 
8af3 3a 68 ea				ld a,( store_tmp2) 
8af6 32 69 ea				ld (store_tmp2+1), a   ; display item count 
8af9			 
8af9					 
8af9			.mitem:	 
8af9			 
8af9			 
8af9 3a 69 ea				ld a,(store_tmp2+1) 
8afc 6f					ld l, a 
8afd 26 00				ld h, 0 
8aff 29					add hl, hl 
8b00 ed 5b 6a ea			ld de, (store_tmp1) 
8b04 19					add hl, de 
8b05 7e					ld a, (hl) 
8b06 23					inc hl 
8b07 66					ld h,(hl) 
8b08 6f					ld l, a 
8b09			 
8b09 cd ff 8c				call ishlzero 
8b0c 28 1a				jr z, .mdone 
8b0e			 
8b0e eb					ex de, hl 
8b0f 3a 66 ea				ld a, (store_tmp3) 
8b12 cd be 8a				call str_at_display 
8b15					 
8b15			 
8b15					; next item 
8b15 3a 69 ea				ld a, (store_tmp2+1) 
8b18 3c					inc a 
8b19 32 69 ea				ld (store_tmp2+1), a   ; display item count 
8b1c			 
8b1c			 		; next row 
8b1c			 
8b1c 3a 66 ea				ld a, (store_tmp3) 
8b1f c6 28				add display_cols 
8b21 32 66 ea				ld (store_tmp3), a 
8b24			 
8b24					; at end of screen? 
8b24			 
8b24 fe 10				cp display_rows*4 
8b26 20 d1				jr nz, .mitem 
8b28			 
8b28			 
8b28			.mdone: 
8b28 cd ff 8c				call ishlzero 
8b2b 28 08				jr z, .nodn 
8b2d			 
8b2d 3e 78				ld a, display_row_4 
8b2f 11 ac 8b				ld de, .mdown 
8b32 cd be 8a				call str_at_display 
8b35			 
8b35					; draw options to fill the screens with active item on line 1 
8b35					; if current option is 2 or more then display ^ in top 
8b35			 
8b35 3a 68 ea		.nodn:		ld a, (store_tmp2) 
8b38			;		cp 0 
8b38 b7					or a 
8b39 28 08				jr z, .noup 
8b3b			 
8b3b 3e 00				ld a, 0 
8b3d 11 aa 8b				ld de, .mup 
8b40 cd be 8a				call str_at_display 
8b43			 
8b43 3e 02		.noup:		ld a, 2 
8b45 11 a8 8b				ld de, .msel 
8b48 cd be 8a				call str_at_display 
8b4b			 
8b4b					; if current option + 1 is not null then display V in bottom 
8b4b					; get key 
8b4b cd ce 8a				call update_display 
8b4e			 
8b4e			 
8b4e					; handle key 
8b4e			 
8b4e cd 51 e4				call cin_wait 
8b51			 
8b51 fe 05				cp KEY_UP 
8b53 28 2b				jr z, .mgoup 
8b55 fe 61				cp 'a' 
8b57 28 27				jr z, .mgoup 
8b59 fe 0a				cp KEY_DOWN 
8b5b 28 31				jr z, .mgod 
8b5d fe 7a				cp 'z' 
8b5f 28 2d				jr z, .mgod 
8b61 fe 20				cp ' ' 
8b63 28 33				jr z, .goend 
8b65 fe 0c				cp KEY_RIGHT 
8b67 28 2f				jr z, .goend 
8b69 fe 0d				cp KEY_CR 
8b6b 28 2b				jr z, .goend 
8b6d fe 71				cp 'q' 
8b6f 28 0b				jr z, .goback 
8b71			 
8b71 fe 0b				cp KEY_LEFT 
8b73 28 07				jr z, .goback 
8b75 fe 08				cp KEY_BS 
8b77 28 03				jr z, .goback 
8b79 c3 e8 8a				jp .mloop 
8b7c			 
8b7c			.goback: 
8b7c 3e 00			ld a, 0 
8b7e 18 1c			jr .goend2 
8b80			 
8b80				; move up one 
8b80			.mgoup: 
8b80 3a 68 ea				ld a, (store_tmp2) 
8b83			;		cp 0 
8b83 b7					or a 
8b84 ca e8 8a				jp z, .mloop 
8b87 3d					dec a 
8b88 32 68 ea				ld (store_tmp2), a 
8b8b c3 e8 8a				jp .mloop 
8b8e			 
8b8e				; move down one 
8b8e			.mgod: 
8b8e 3a 68 ea				ld a, (store_tmp2) 
8b91 3c					inc a 
8b92 32 68 ea				ld (store_tmp2), a 
8b95 c3 e8 8a				jp .mloop 
8b98			 
8b98			 
8b98			.goend: 
8b98					; get selected item number 
8b98			 
8b98 3a 68 ea				ld a, (store_tmp2) 
8b9b 3c					inc a 
8b9c			 
8b9c			.goend2: 
8b9c f5					push af 
8b9d			 
8b9d					; restore active fb 
8b9d					; TODO BUG assumes fb1 
8b9d			 
8b9d 21 07 ed				ld hl, display_fb1 
8ba0 22 c3 eb				ld (display_fb_active), hl 
8ba3			 
8ba3					; restore main regs 
8ba3			 
8ba3			 
8ba3 cd ce 8a				call update_display 
8ba6			 
8ba6 f1					pop af 
8ba7			 
8ba7 c9				ret 
8ba8			 
8ba8 .. 00		.msel:   db ">",0 
8baa .. 00		.mup:   db "^",0 
8bac .. 00		.mdown:   db "v",0 
8bae			 
8bae			 
8bae			; eof 
8bae			 
# End of file firmware_display.asm
8bae			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bae			; random number generators 
8bae			 
8bae			 
8bae			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bae			 
8bae			 
8bae			;-----> Generate a random number 
8bae			; output a=answer 0<=a<=255 
8bae			; all registers are preserved except: af 
8bae			random: 
8bae e5			        push    hl 
8baf d5			        push    de 
8bb0 2a a2 eb		        ld      hl,(randData) 
8bb3 ed 5f		        ld      a,r 
8bb5 57			        ld      d,a 
8bb6 5e			        ld      e,(hl) 
8bb7 19			        add     hl,de 
8bb8 85			        add     a,l 
8bb9 ac			        xor     h 
8bba 22 a2 eb		        ld      (randData),hl 
8bbd d1			        pop     de 
8bbe e1			        pop     hl 
8bbf c9			        ret 
8bc0			 
8bc0			 
8bc0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc0			 
8bc0			 
8bc0			 
8bc0			;------LFSR------ 
8bc0			;James Montelongo 
8bc0			;optimized by Spencer Putt 
8bc0			;out: 
8bc0			; a = 8 bit random number 
8bc0			RandLFSR: 
8bc0 21 a8 eb		        ld hl,LFSRSeed+4 
8bc3 5e			        ld e,(hl) 
8bc4 23			        inc hl 
8bc5 56			        ld d,(hl) 
8bc6 23			        inc hl 
8bc7 4e			        ld c,(hl) 
8bc8 23			        inc hl 
8bc9 7e			        ld a,(hl) 
8bca 47			        ld b,a 
8bcb cb 13		        rl e  
8bcd cb 12			rl d 
8bcf cb 11		        rl c  
8bd1 17				rla 
8bd2 cb 13		        rl e  
8bd4 cb 12			rl d 
8bd6 cb 11		        rl c  
8bd8 17				rla 
8bd9 cb 13		        rl e  
8bdb cb 12			rl d 
8bdd cb 11		        rl c  
8bdf 17				rla 
8be0 67			        ld h,a 
8be1 cb 13		        rl e  
8be3 cb 12			rl d 
8be5 cb 11		        rl c  
8be7 17				rla 
8be8 a8			        xor b 
8be9 cb 13		        rl e  
8beb cb 12			rl d 
8bed ac			        xor h 
8bee a9			        xor c 
8bef aa			        xor d 
8bf0 21 aa eb		        ld hl,LFSRSeed+6 
8bf3 11 ab eb		        ld de,LFSRSeed+7 
8bf6 01 07 00		        ld bc,7 
8bf9 ed b8		        lddr 
8bfb 12			        ld (de),a 
8bfc c9			        ret 
8bfd			 
8bfd			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8bfd			 
8bfd			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8bfd			 
8bfd			 
8bfd			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8bfd			 
8bfd			prng16: 
8bfd			;Inputs: 
8bfd			;   (seed1) contains a 16-bit seed value 
8bfd			;   (seed2) contains a NON-ZERO 16-bit seed value 
8bfd			;Outputs: 
8bfd			;   HL is the result 
8bfd			;   BC is the result of the LCG, so not that great of quality 
8bfd			;   DE is preserved 
8bfd			;Destroys: 
8bfd			;   AF 
8bfd			;cycle: 4,294,901,760 (almost 4.3 billion) 
8bfd			;160cc 
8bfd			;26 bytes 
8bfd 2a 9c eb		    ld hl,(seed1) 
8c00 44			    ld b,h 
8c01 4d			    ld c,l 
8c02 29			    add hl,hl 
8c03 29			    add hl,hl 
8c04 2c			    inc l 
8c05 09			    add hl,bc 
8c06 22 9c eb		    ld (seed1),hl 
8c09 2a 9a eb		    ld hl,(seed2) 
8c0c 29			    add hl,hl 
8c0d 9f			    sbc a,a 
8c0e e6 2d		    and %00101101 
8c10 ad			    xor l 
8c11 6f			    ld l,a 
8c12 22 9a eb		    ld (seed2),hl 
8c15 09			    add hl,bc 
8c16 c9			    ret 
8c17			 
8c17			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c17			 
8c17			rand32: 
8c17			;Inputs: 
8c17			;   (seed1_0) holds the lower 16 bits of the first seed 
8c17			;   (seed1_1) holds the upper 16 bits of the first seed 
8c17			;   (seed2_0) holds the lower 16 bits of the second seed 
8c17			;   (seed2_1) holds the upper 16 bits of the second seed 
8c17			;   **NOTE: seed2 must be non-zero 
8c17			;Outputs: 
8c17			;   HL is the result 
8c17			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c17			;Destroys: 
8c17			;   AF 
8c17			;Tested and passes all CAcert tests 
8c17			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c17			;it has a period of 18,446,744,069,414,584,320 
8c17			;roughly 18.4 quintillion. 
8c17			;LFSR taps: 0,2,6,7  = 11000101 
8c17			;291cc 
8c17			;seed1_0=$+1 
8c17			;    ld hl,12345 
8c17			;seed1_1=$+1 
8c17			;    ld de,6789 
8c17			;    ld b,h 
8c17			;    ld c,l 
8c17			;    add hl,hl \ rl e \ rl d 
8c17			;    add hl,hl \ rl e \ rl d 
8c17			;    inc l 
8c17			;    add hl,bc 
8c17			;    ld (seed1_0),hl 
8c17			;    ld hl,(seed1_1) 
8c17			;    adc hl,de 
8c17			;    ld (seed1_1),hl 
8c17			;    ex de,hl 
8c17			;seed2_0=$+1 
8c17			;    ld hl,9876 
8c17			;seed2_1=$+1 
8c17			;    ld bc,54321 
8c17			;    add hl,hl \ rl c \ rl b 
8c17			;    ld (seed2_1),bc 
8c17			;    sbc a,a 
8c17			;    and %11000101 
8c17			;    xor l 
8c17			;    ld l,a 
8c17			;    ld (seed2_0),hl 
8c17			;    ex de,hl 
8c17			;    add hl,bc 
8c17			;    ret 
8c17			; 
8c17			 
8c17			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c17			; 20 bytes, 86 cycles (excluding ret) 
8c17			 
8c17			; returns   hl = pseudorandom number 
8c17			; corrupts   a 
8c17			 
8c17			; generates 16-bit pseudorandom numbers with a period of 65535 
8c17			; using the xorshift method: 
8c17			 
8c17			; hl ^= hl << 7 
8c17			; hl ^= hl >> 9 
8c17			; hl ^= hl << 8 
8c17			 
8c17			; some alternative shift triplets which also perform well are: 
8c17			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c17			 
8c17			;  org 32768 
8c17			 
8c17			xrnd: 
8c17 2a a0 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c1a 3e 00		  ld a,0 
8c1c bd			  cp l 
8c1d 20 02		  jr nz, .xrnd1 
8c1f 2e 01		  ld l, 1 
8c21			.xrnd1: 
8c21			 
8c21 7c			  ld a,h 
8c22 1f			  rra 
8c23 7d			  ld a,l 
8c24 1f			  rra 
8c25 ac			  xor h 
8c26 67			  ld h,a 
8c27 7d			  ld a,l 
8c28 1f			  rra 
8c29 7c			  ld a,h 
8c2a 1f			  rra 
8c2b ad			  xor l 
8c2c 6f			  ld l,a 
8c2d ac			  xor h 
8c2e 67			  ld h,a 
8c2f			 
8c2f 22 a0 eb		  ld (xrandc),hl 
8c32			 
8c32 c9			  ret 
8c33			;  
8c33			 
8c33			 
8c33			;;;; int maths 
8c33			 
8c33			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c33			; Divide 16-bit values (with 16-bit result) 
8c33			; In: Divide BC by divider DE 
8c33			; Out: BC = result, HL = rest 
8c33			; 
8c33			Div16: 
8c33 21 00 00		    ld hl,0 
8c36 78			    ld a,b 
8c37 06 08		    ld b,8 
8c39			Div16_Loop1: 
8c39 17			    rla 
8c3a ed 6a		    adc hl,hl 
8c3c ed 52		    sbc hl,de 
8c3e 30 01		    jr nc,Div16_NoAdd1 
8c40 19			    add hl,de 
8c41			Div16_NoAdd1: 
8c41 10 f6		    djnz Div16_Loop1 
8c43 17			    rla 
8c44 2f			    cpl 
8c45 47			    ld b,a 
8c46 79			    ld a,c 
8c47 48			    ld c,b 
8c48 06 08		    ld b,8 
8c4a			Div16_Loop2: 
8c4a 17			    rla 
8c4b ed 6a		    adc hl,hl 
8c4d ed 52		    sbc hl,de 
8c4f 30 01		    jr nc,Div16_NoAdd2 
8c51 19			    add hl,de 
8c52			Div16_NoAdd2: 
8c52 10 f6		    djnz Div16_Loop2 
8c54 17			    rla 
8c55 2f			    cpl 
8c56 41			    ld b,c 
8c57 4f			    ld c,a 
8c58 c9			ret 
8c59			 
8c59			 
8c59			;http://z80-heaven.wikidot.com/math 
8c59			; 
8c59			;Inputs: 
8c59			;     DE and A are factors 
8c59			;Outputs: 
8c59			;     A is not changed 
8c59			;     B is 0 
8c59			;     C is not changed 
8c59			;     DE is not changed 
8c59			;     HL is the product 
8c59			;Time: 
8c59			;     342+6x 
8c59			; 
8c59			Mult16: 
8c59			 
8c59 06 08		     ld b,8          ;7           7 
8c5b 21 00 00		     ld hl,0         ;10         10 
8c5e 29			       add hl,hl     ;11*8       88 
8c5f 07			       rlca          ;4*8        32 
8c60 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c62 19			         add hl,de   ;--         -- 
8c63 10 f9		       djnz $-5      ;13*7+8     99 
8c65 c9			ret 
8c66			 
8c66			; 
8c66			; Square root of 16-bit value 
8c66			; In:  HL = value 
8c66			; Out:  D = result (rounded down) 
8c66			; 
8c66			;Sqr16: 
8c66			;    ld de,#0040 
8c66			;    ld a,l 
8c66			;    ld l,h 
8c66			;    ld h,d 
8c66			;    or a 
8c66			;    ld b,8 
8c66			;Sqr16_Loop: 
8c66			;    sbc hl,de 
8c66			;    jr nc,Sqr16_Skip 
8c66			;    add hl,de 
8c66			;Sqr16_Skip: 
8c66			;    ccf 
8c66			;    rl d 
8c66			;    add a,a 
8c66			;    adc hl,hl 
8c66			;    add a,a 
8c66			;    adc hl,hl 
8c66			;    djnz Sqr16_Loop 
8c66			;    ret 
8c66			; 
8c66			; 
8c66			; Divide 8-bit values 
8c66			; In: Divide E by divider C 
8c66			; Out: A = result, B = rest 
8c66			; 
8c66			Div8: 
8c66 af			    xor a 
8c67 06 08		    ld b,8 
8c69			Div8_Loop: 
8c69 cb 13		    rl e 
8c6b 17			    rla 
8c6c 91			    sub c 
8c6d 30 01		    jr nc,Div8_NoAdd 
8c6f 81			    add a,c 
8c70			Div8_NoAdd: 
8c70 10 f7		    djnz Div8_Loop 
8c72 47			    ld b,a 
8c73 7b			    ld a,e 
8c74 17			    rla 
8c75 2f			    cpl 
8c76 c9			    ret 
8c77			 
8c77			; 
8c77			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c77			; In: Multiply A with DE 
8c77			; Out: HL = result 
8c77			; 
8c77			Mult12U: 
8c77 2e 00		    ld l,0 
8c79 87			    add a,a 
8c7a 30 01		    jr nc,Mult12U_NoAdd0 
8c7c 19			    add hl,de 
8c7d			Mult12U_NoAdd0: 
8c7d 29			    add hl,hl 
8c7e 87			    add a,a 
8c7f 30 01		    jr nc,Mult12U_NoAdd1 
8c81 19			    add hl,de 
8c82			Mult12U_NoAdd1: 
8c82 29			    add hl,hl 
8c83 87			    add a,a 
8c84 30 01		    jr nc,Mult12U_NoAdd2 
8c86 19			    add hl,de 
8c87			Mult12U_NoAdd2: 
8c87 29			    add hl,hl 
8c88 87			    add a,a 
8c89 30 01		    jr nc,Mult12U_NoAdd3 
8c8b 19			    add hl,de 
8c8c			Mult12U_NoAdd3: 
8c8c 29			    add hl,hl 
8c8d 87			    add a,a 
8c8e 30 01		    jr nc,Mult12U_NoAdd4 
8c90 19			    add hl,de 
8c91			Mult12U_NoAdd4: 
8c91 29			    add hl,hl 
8c92 87			    add a,a 
8c93 30 01		    jr nc,Mult12U_NoAdd5 
8c95 19			    add hl,de 
8c96			Mult12U_NoAdd5: 
8c96 29			    add hl,hl 
8c97 87			    add a,a 
8c98 30 01		    jr nc,Mult12U_NoAdd6 
8c9a 19			    add hl,de 
8c9b			Mult12U_NoAdd6: 
8c9b 29			    add hl,hl 
8c9c 87			    add a,a 
8c9d d0			    ret nc 
8c9e 19			    add hl,de 
8c9f c9			    ret 
8ca0			 
8ca0			; 
8ca0			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca0			; In: Multiply A with DE 
8ca0			;      Put lowest value in A for most efficient calculation 
8ca0			; Out: HL = result 
8ca0			; 
8ca0			Mult12R: 
8ca0 21 00 00		    ld hl,0 
8ca3			Mult12R_Loop: 
8ca3 cb 3f		    srl a 
8ca5 30 01		    jr nc,Mult12R_NoAdd 
8ca7 19			    add hl,de 
8ca8			Mult12R_NoAdd: 
8ca8 cb 23		    sla e 
8caa cb 12		    rl d 
8cac b7			    or a 
8cad c2 a3 8c		    jp nz,Mult12R_Loop 
8cb0 c9			    ret 
8cb1			 
8cb1			; 
8cb1			; Multiply 16-bit values (with 32-bit result) 
8cb1			; In: Multiply BC with DE 
8cb1			; Out: BCHL = result 
8cb1			; 
8cb1			Mult32: 
8cb1 79			    ld a,c 
8cb2 48			    ld c,b 
8cb3 21 00 00		    ld hl,0 
8cb6 06 10		    ld b,16 
8cb8			Mult32_Loop: 
8cb8 29			    add hl,hl 
8cb9 17			    rla 
8cba cb 11		    rl c 
8cbc 30 07		    jr nc,Mult32_NoAdd 
8cbe 19			    add hl,de 
8cbf ce 00		    adc a,0 
8cc1 d2 c5 8c		    jp nc,Mult32_NoAdd 
8cc4 0c			    inc c 
8cc5			Mult32_NoAdd: 
8cc5 10 f1		    djnz Mult32_Loop 
8cc7 41			    ld b,c 
8cc8 4f			    ld c,a 
8cc9 c9			    ret 
8cca			 
8cca			 
8cca			 
8cca			; 
8cca			; Multiply 8-bit values 
8cca			; In:  Multiply H with E 
8cca			; Out: HL = result 
8cca			; 
8cca			Mult8: 
8cca 16 00		    ld d,0 
8ccc 6a			    ld l,d 
8ccd 06 08		    ld b,8 
8ccf			Mult8_Loop: 
8ccf 29			    add hl,hl 
8cd0 30 01		    jr nc,Mult8_NoAdd 
8cd2 19			    add hl,de 
8cd3			Mult8_NoAdd: 
8cd3 10 fa		    djnz Mult8_Loop 
8cd5 c9			    ret 
8cd6			 
8cd6			 
8cd6			 
8cd6			 
8cd6			 
8cd6			 
8cd6			 
8cd6			 
8cd6			;;http://z80-heaven.wikidot.com/math 
8cd6			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cd6			; 
8cd6			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cd6			;     ld a,16        ;7 
8cd6			;     ld hl,0        ;10 
8cd6			;     jp $+5         ;10 
8cd6			;.DivLoop: 
8cd6			;       add hl,bc    ;-- 
8cd6			;       dec a        ;64 
8cd6			;       jr z,.DivLoopEnd        ;86 
8cd6			; 
8cd6			;       sla e        ;128 
8cd6			;       rl d         ;128 
8cd6			;       adc hl,hl    ;240 
8cd6			;       sbc hl,bc    ;240 
8cd6			;       jr nc,.DivLoop ;23|21 
8cd6			;       inc e        ;-- 
8cd6			;       jp .DivLoop+1 
8cd6			; 
8cd6			;.DivLoopEnd: 
8cd6			 
8cd6			;HL_Div_C: 
8cd6			;Inputs: 
8cd6			;     HL is the numerator 
8cd6			;     C is the denominator 
8cd6			;Outputs: 
8cd6			;     A is the remainder 
8cd6			;     B is 0 
8cd6			;     C is not changed 
8cd6			;     DE is not changed 
8cd6			;     HL is the quotient 
8cd6			; 
8cd6			;       ld b,16 
8cd6			;       xor a 
8cd6			;         add hl,hl 
8cd6			;         rla 
8cd6			;         cp c 
8cd6			;         jr c,$+4 
8cd6			;           inc l 
8cd6			;           sub c 
8cd6			;         djnz $-7 
8cd6			 
8cd6			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cd6			 
8cd6			addatohl: 
8cd6 85			    add   a, l    ; A = A+L 
8cd7 6f			    ld    l, a    ; L = A+L 
8cd8 8c			    adc   a, h    ; A = A+L+H+carry 
8cd9 95			    sub   l       ; A = H+carry 
8cda 67			    ld    h, a    ; H = H+carry 
8cdb c9			ret 
8cdc			 
8cdc			addatode: 
8cdc 83			    add   a, e    ; A = A+L 
8cdd 5f			    ld    e, a    ; L = A+L 
8cde 8a			    adc   a, d    ; A = A+L+H+carry 
8cdf 93			    sub   e       ; A = H+carry 
8ce0 57			    ld    d, a    ; H = H+carry 
8ce1 c9			ret 
8ce2			 
8ce2			 
8ce2			addatobc: 
8ce2 81			    add   a, c    ; A = A+L 
8ce3 4f			    ld    c, a    ; L = A+L 
8ce4 88			    adc   a, b    ; A = A+L+H+carry 
8ce5 91			    sub   c       ; A = H+carry 
8ce6 47			    ld    b, a    ; H = H+carry 
8ce7 c9			ret 
8ce8			 
8ce8			subafromhl: 
8ce8			   ; If A=0 do nothing 
8ce8			    ; Otherwise flip A's sign. Since 
8ce8			    ; the upper byte becomes -1, also 
8ce8			    ; substract 1 from H. 
8ce8 ed 44		    neg 
8cea ca f3 8c		    jp    z, Skip 
8ced 25			    dec   h 
8cee			     
8cee			    ; Now add the low byte as usual 
8cee			    ; Two's complement takes care of 
8cee			    ; ensuring the result is correct 
8cee 85			    add   a, l 
8cef 6f			    ld    l, a 
8cf0 8c			    adc   a, h 
8cf1 95			    sub   l 
8cf2 67			    ld    h, a 
8cf3			Skip: 
8cf3 c9				ret 
8cf4			 
8cf4			 
8cf4			; compare hl and de 
8cf4			; returns:  
8cf4			; if hl = de, z=1, s=0, c0=0 
8cf4			; if hl > de, z=0, s=0, c=0 
8cf4			; if hl < de, z=0, s=1, c=1 
8cf4			cmp16:	 
8cf4 b7				or a 
8cf5 ed 52			sbc hl,de 
8cf7 e0				ret po 
8cf8 7c				ld a,h 
8cf9 1f				rra 
8cfa ee 40			xor 01000000B 
8cfc 37				scf 
8cfd 8f				adc a,a 
8cfe c9				ret 
8cff			 
8cff			 
8cff			; test if hl contains zero   - A is destroyed 
8cff			 
8cff			ishlzero:    
8cff b7				or a     ; reset flags 
8d00 7c				ld a, h 
8d01 b5				or l        	 
8d02			 
8d02 c9				ret 
8d03			 
8d03			 
8d03			 
8d03			 
8d03			if FORTH_ENABLE_FLOATMATH 
8d03			;include "float/bbcmath.z80" 
8d03			include "float/lpfpcalc.asm" 
8d03			endif 
8d03			 
8d03			 
8d03			; eof 
8d03			 
# End of file firmware_maths.asm
8d03			include "firmware_strings.asm"   ; string handling  
8d03			 
8d03			 
8d03			; TODO string len 
8d03			; input text string, end on cr with zero term 
8d03			; a offset into frame buffer to start prompt 
8d03			; d is max length 
8d03			; e is display size TODO 
8d03			; c is current cursor position 
8d03			; hl is ptr to where string will be stored and edited directly 
8d03			 
8d03			 
8d03			; TODO check limit of buffer for new inserts 
8d03			; TODO check insert does not push beyond buffer 
8d03			; TODO scroll in a limited display area 
8d03			; TODO scroll whole screen on page wrap 
8d03			 
8d03			 
8d03			; TODO use LCD cursor? 
8d03			 
8d03			EDIT_V1: equ 0 
8d03			EDIT_V2: equ 1 
8d03			 
8d03			 
8d03			 
8d03			if EDIT_V2 
8d03			input_str: 
8d03			 
8d03 32 5b ee			    	ld (input_at_pos),a      ; save display position to start 
8d06			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
8d06 22 5e ee				ld (input_start), hl     ; save ptr to buffer 
8d09			;		ld a, c 
8d09			;		call addatohl 
8d09			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
8d09 7a					ld a,d 
8d0a 32 5d ee			        ld (input_size), a       ; save length of input area 
8d0d 79					ld a, c 
8d0e 32 4c ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
8d11 7b					ld a,e 
8d12 32 5c ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d15			 
8d15			 
8d15					; add a trailing space to make screen refresh nicer 
8d15			 
8d15					;ld hl, (input_start) 
8d15					;push hl 
8d15					;ld a, 0 
8d15					;call strlent 
8d15					;ld a, l 
8d15					;pop hl 
8d15					;call addatohl 
8d15					;dec hl 
8d15					;ld a, ' ' 
8d15					;ld (hl), a 
8d15					;inc hl 
8d15					;ld (hl), a 
8d15					;inc hl 
8d15					;ld a, 0 
8d15					;ld (hl), a 
8d15			 
8d15			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d15					; init cursor shape if not set by the cin routines 
8d15 21 b8 eb				ld hl, cursor_shape 
8d18			if BASE_KEV 
8d18			;		ld a, 255 
8d18					ld (hl), 255 
8d18			else 
8d18					;ld a, '#' 
8d18 36 23				ld (hl), '#' 
8d1a			endif 
8d1a 23					inc hl 
8d1b			;		ld a, 0 
8d1b 36 00				ld (hl), 0 
8d1d			 
8d1d 3e 09				ld a, CUR_BLINK_RATE 
8d1f 32 57 ee				ld (input_cur_flash), a 
8d22 3e 01				ld a, 1 
8d24 32 56 ee				ld (input_cur_onoff),a 
8d27			.inmain:	 
8d27			 
8d27 cd 48 8e				call input_disp_ref 
8d2a			 
8d2a					; save current length of string 
8d2a			 
8d2a 2a 5e ee				ld hl, (input_start) 
8d2d 3e 00				ld a, 0 
8d2f cd 39 90				call strlent 
8d32 7d					ld a,l 
8d33 32 51 ee				ld (input_len), a 
8d36			 
8d36					;call input_disp_oncur 
8d36			 
8d36					; display current state of input buffer 
8d36			 
8d36					; clean any backspace chars 
8d36			 
8d36 3e 20				ld a, " " 
8d38 32 b8 e2				ld (scratch),a 
8d3b 3e 00				ld a, 0 
8d3d 32 b9 e2				ld (scratch+1),a 
8d40 3a 5b ee				ld a,(input_at_pos) 
8d43 85					add l 
8d44 11 b8 e2				ld de, scratch 
8d47 cd be 8a				call str_at_display 
8d4a			 
8d4a					; pause 1ms 
8d4a			 
8d4a 3e 01				ld a, 1 
8d4c cd d5 89				call aDelayInMS 
8d4f			 
8d4f			; display cursor if visible on this cycle 
8d4f			 
8d4f					; dec flash counter 
8d4f 3a 57 ee				ld a, (input_cur_flash) 
8d52 3d					dec a 
8d53 32 57 ee				ld (input_cur_flash), a 
8d56			;		cp 0 
8d56 b7					or a 
8d57 20 0d				jr nz, .inochgstate 
8d59			 
8d59			 
8d59					; reset on change of state 
8d59 3e 09				ld a, CUR_BLINK_RATE 
8d5b 32 57 ee				ld (input_cur_flash), a 
8d5e			 
8d5e					; change state 
8d5e 3a 56 ee				ld a,(input_cur_onoff) 
8d61 ed 44				neg 
8d63 32 56 ee				ld (input_cur_onoff),a 
8d66			 
8d66			 
8d66			 
8d66			 
8d66					; TODO is cursor visible? 
8d66					; TODO if so then over write the char at curspos pos with the cursor shape 
8d66			 
8d66								 
8d66			 
8d66			.inochgstate: 
8d66 3a 56 ee				ld a,(input_cur_onoff) 
8d69 fe ff				cp 255 
8d6b 28 0e				jr z, .skipcursor 
8d6d 3a 5b ee				ld a, (input_at_pos) 
8d70 47					ld b, a 
8d71 3a 4c ee				ld a, (input_cursor) 
8d74 80					add b 
8d75 11 b8 eb				ld de, cursor_shape 
8d78					 
8d78 cd be 8a				call str_at_display 
8d7b			 
8d7b			.skipcursor: 
8d7b				if DEBUG_INPUTV2 
8d7b			 
8d7b					ld a,(input_at_pos) 
8d7b					ld hl, LFSRSeed 
8d7b					call hexout 
8d7b					ld a, (input_cursor) 
8d7b					ld hl, LFSRSeed+2 
8d7b					call hexout 
8d7b					ld a,(input_size) 
8d7b					ld hl, LFSRSeed+4 
8d7b					call hexout 
8d7b			 
8d7b					ld a,(input_cur_onoff) 
8d7b					ld hl, LFSRSeed+6 
8d7b					call hexout 
8d7b			 
8d7b					ld a,(input_cur_flash) 
8d7b					ld hl, LFSRSeed+8 
8d7b					call hexout 
8d7b			 
8d7b					ld a,(input_len) 
8d7b					ld hl, LFSRSeed+10 
8d7b					call hexout 
8d7b					ld hl, LFSRSeed+12 
8d7b			;		ld a, 0 
8d7b					ld (hl),0 
8d7b					ld a, display_row_4 
8d7b					ld de, LFSRSeed 
8d7b					call str_at_display 
8d7b				endif 
8d7b cd ce 8a				call update_display 
8d7e			 
8d7e					; TODO keyboard processing 
8d7e			 
8d7e			if BASE_CPM 
8d7e					call cin_wait 
8d7e			else 
8d7e cd 57 e4				call cin    ; _wait 
8d81			endif 
8d81			;		cp 0 
8d81 b7					or a 
8d82 ca 27 8d				jp z, .inmain 
8d85			 
8d85 fe 0b				cp KEY_LEFT    ; cursor left 
8d87 ca 3a 8e				jp z, input_left 
8d8a				 
8d8a fe 0c				cp KEY_RIGHT      ; cursor right 
8d8c ca 41 8e				jp z, input_right 
8d8f			 
8d8f fe 0d				cp KEY_CR 
8d91 c8					ret z 
8d92			 
8d92 fe 08				cp KEY_BS 
8d94 ca ac 8e				jp z, input_delchar 
8d97			 
8d97 fe 06				cp KEY_NEXTWORD 
8d99 ca c0 8d				jp z, input_nxtword 
8d9c			 
8d9c fe 07				cp KEY_PREVWORD 
8d9e ca e5 8d				jp z, input_prvword 
8da1			 
8da1 fe 0e				cp KEY_HOME    ; jump to start of line 
8da3 20 08				jr nz, .ikh 
8da5 3e 00				ld a, 0 
8da7 32 4c ee				ld (input_cursor), a 
8daa ca 27 8d				jp z, .inmain 
8dad			.ikh: 
8dad			 
8dad fe 0f				cp KEY_END     ; jump to end of line 
8daf 20 09				jr nz, .ike 
8db1 3a 51 ee				ld a, (input_len) 
8db4 32 4c ee				ld (input_cursor),a 
8db7 ca 27 8d				jp z, .inmain 
8dba			.ike: 
8dba fe 05			        cp KEY_UP      ; recall last command 
8dbc c8					ret z 
8dbd			;jr nz, .irec 
8dbd			; TODO next word 
8dbd			; TODO prev word 
8dbd			;  
8dbd			; 
8dbd			;	ld hl, scratch 
8dbd			;	ld de, os_last_cmd 
8dbd			;	call strcpy 
8dbd			;		jp  .inmain 
8dbd			.irec: 
8dbd			;		jr .instr1 
8dbd			 
8dbd			 
8dbd			 
8dbd					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
8dbd			 
8dbd			; TODO return if any special keys are given 
8dbd			;		ld l, a 
8dbd			;		ld a, 28 ; KEY_F12   ; 27 
8dbd			;		sub l 
8dbd			;		ret m 
8dbd			;		ld a, l 
8dbd					; if no special key then insert as a char 
8dbd			 
8dbd c3 81 8e				jp input_inschr 
8dc0			 
8dc0				 
8dc0			input_nxtword: 
8dc0				; jump to start next word after the cursor 
8dc0			 
8dc0			.insknwn:	 
8dc0 cd 77 8e				call input_curptr	 
8dc3 7e					ld a,(hl)	 
8dc4			;		cp 0 
8dc4 b7					or a 
8dc5 ca 27 8d				jp z, .inmain    ; end of string 
8dc8			 
8dc8			; if we are on a word, then move off of it 
8dc8			 
8dc8 fe 20				cp ' ' 
8dca 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
8dcc 21 4c ee				ld hl, input_cursor 
8dcf 34					inc (hl) 
8dd0 18 ee				jr .insknwn 
8dd2			 
8dd2			.inspace: 
8dd2			 
8dd2 cd 77 8e				call input_curptr	 
8dd5 7e					ld a,(hl)	 
8dd6			;		cp 0 
8dd6 b7					or a 
8dd7 ca 27 8d				jp z, .inmain    ; end of string 
8dda			 
8dda			; if we are on a word, then move off of it 
8dda			 
8dda fe 20				cp ' ' 
8ddc c2 27 8d				jp nz, .inmain     ; we are on non space so at next word 
8ddf 21 4c ee				ld hl, input_cursor 
8de2 34					inc (hl) 
8de3 18 ed				jr .inspace 
8de5			 
8de5			 
8de5			 
8de5			 
8de5			input_prvword: 
8de5				; jump to the start of previous word before the cursor 
8de5			 
8de5			; where are we to start with currently? 
8de5			 
8de5 cd 77 8e				call input_curptr	 
8de8 7e					ld a, (hl) 
8de9 fe 20				cp ' ' 
8deb 28 1c				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
8ded			 
8ded			 
8ded			 
8ded			.inskpwn:	 
8ded 3a 4c ee				ld a,(input_cursor) 
8df0			;		cp 0 
8df0 b7					or a 
8df1 ca 27 8d				jp z, .inmain    ; start of string 
8df4			 
8df4			;if we are on a word, then move off of it 
8df4			 
8df4 cd 77 8e				call input_curptr	 
8df7 7e					ld a, (hl) 
8df8 fe 20				cp ' ' 
8dfa 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
8dfc					;jp z, .inmain    ; start of string 
8dfc 21 4c ee				ld hl, input_cursor 
8dff 35					dec (hl) 
8e00 18 eb				jr .inskpwn 
8e02			.iwstart: 
8e02 21 4c ee				ld hl, input_cursor 
8e05 34					inc (hl) 
8e06 c3 27 8d				jp .inmain 
8e09					 
8e09			 
8e09			.inspacep: 
8e09			 
8e09					;jp .inmain    ; start of string 
8e09			 
8e09			 
8e09			 
8e09 3a 4c ee				ld a,(input_cursor) 
8e0c			;		cp 0 
8e0c b7					or a 
8e0d ca 27 8d				jp z, .inmain    ; start of string 
8e10			 
8e10			; if we are on a word, then move off of it 
8e10			 
8e10 cd 77 8e				call input_curptr	 
8e13 7e					ld a, (hl) 
8e14 fe 20				cp ' ' 
8e16 c2 1f 8e				jp nz, .incharp     ; we are on non space so at end of prev word 
8e19 21 4c ee				ld hl, input_cursor 
8e1c 35					dec (hl) 
8e1d 18 ea				jr .inspacep 
8e1f			 
8e1f			 
8e1f			.incharp:	 
8e1f					; eat the word to get to the start 
8e1f 3a 4c ee				ld a,(input_cursor) 
8e22			;		cp 0 
8e22 b7					or a 
8e23 ca 27 8d				jp z, .inmain    ; start of string 
8e26			 
8e26			; if we are on a word, then move off of it 
8e26			 
8e26 cd 77 8e				call input_curptr	 
8e29 7e					ld a, (hl) 
8e2a fe 20				cp ' ' 
8e2c 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
8e2e 21 4c ee				ld hl, input_cursor 
8e31 35					dec (hl) 
8e32 18 eb				jr .incharp 
8e34			.ipwordst: 
8e34					; at space before the prev word so reposition over it 
8e34 21 4c ee				ld hl, input_cursor 
8e37 34					inc (hl) 
8e38 18 b3				jr .inskpwn 
8e3a					 
8e3a			 
8e3a			 
8e3a			input_left: 
8e3a				; move cursor left 
8e3a 21 4c ee			ld hl, input_cursor 
8e3d 35				dec (hl) 
8e3e			;	cp 0 
8e3e			;	jp z, .inmain    ; ignore left as at the start of the string 
8e3e c3 27 8d			jp .inmain 
8e41			 
8e41			input_right: 
8e41				; move cursor right 
8e41				 
8e41				;ld a, (input_size) 
8e41				;ld b, a 
8e41 21 4c ee			ld hl, input_cursor 
8e44 34				inc (hl) 
8e45				;dec b 
8e45				;cp 0 
8e45				;jp z, .inmain   ; ignore as at end of the string buffer 
8e45				;ld a, b 
8e45				;inc a 
8e45				;ld (input_cursor), a 
8e45 c3 27 8d			jp .inmain 
8e48			 
8e48			 
8e48			 
8e48			input_disp_ref: 
8e48				; display the text from start of buffer (ie full refresh) 
8e48 3a 5b ee			ld a, (input_at_pos) 
8e4b 2a 5e ee			ld hl,(input_start) 
8e4e eb				ex de, hl 
8e4f cd be 8a			call str_at_display  
8e52 c9				ret 
8e53			input_disp_oncur: 
8e53				; display the text from cursor position to end of buffer 
8e53				; TODO position start of string at cursor position on screen 
8e53				; TODO draw from that point on 
8e53 3a 4c ee			ld a, (input_cursor) 
8e56 47				ld b, a 
8e57 3a 5b ee			ld a, (input_at_pos) 
8e5a 80				add b 
8e5b 48				ld c, b     ; save a 
8e5c 78				ld a, b     ; inc string start for cursor 
8e5d 2a 5e ee			ld hl,(input_start) 
8e60 cd d6 8c			call addatohl 
8e63 eb				ex de, hl 
8e64 79				ld a, c 
8e65 cd be 8a			call str_at_display  
8e68 c9				ret 
8e69			 
8e69			input_nxtw: 
8e69				; Find next word 
8e69 c9				ret 
8e6a			 
8e6a			input_prvw: 
8e6a				; Find previous word 
8e6a c9				ret 
8e6b			 
8e6b			input_lenrem:   
8e6b				; Calculate the length of string remaining from current cursor 
8e6b				; position to end of buffer (exc null term) 
8e6b				 
8e6b 3a 4c ee			ld a, (input_cursor) 
8e6e 4f				ld c, a 
8e6f 3a 5d ee			ld a, (input_size) 
8e72 91				sub c 
8e73 06 00			ld b, 0 
8e75 0d				dec c 
8e76 c9				ret	 
8e77			 
8e77			input_curptr: 
8e77				; calc address of the character under the cursor 
8e77				 
8e77 2a 5e ee			ld hl, (input_start) 
8e7a 3a 4c ee			ld a, (input_cursor) 
8e7d cd d6 8c			call addatohl 
8e80 c9				ret 
8e81			 
8e81			input_inschr: 
8e81				; Insert char at cursor position 
8e81 f5				push af   ; save char 
8e82				;call input_lenrem    ; get bc length of remaining string 
8e82			 
8e82				 
8e82 cd 77 8e			call input_curptr 
8e85			;	ld hl, (input_start) 
8e85			;	ld a, (input_cursor) 
8e85			;	call addatohl 
8e85				;push hl   ; save to come back to 
8e85			 
8e85				; shift everything up one to end of buffer 
8e85			 
8e85				;push hl 
8e85				;dec de 
8e85				;inc de 
8e85			;	ldir 
8e85				 
8e85				;pop hl 
8e85			 
8e85				; are we adding to the end of line? 
8e85			 
8e85 3a 4c ee			ld a, (input_cursor) 
8e88 47				ld b, a 
8e89 3a 51 ee			ld a, (input_len) 
8e8c b8				cp b 
8e8d 20 08			jr nz, .insmid   ; no, insert in middle of text 
8e8f			 
8e8f				; tack on the end of the line 
8e8f f1				pop af 
8e90 77				ld (hl), a   ; save new char 
8e91 23				inc hl 
8e92			;	ld a, 0 
8e92 36 00			ld (hl), 0 
8e94 c3 41 8e			jp input_right 
8e97				 
8e97			.insmid: 
8e97				; hl has insertion point so move everything up one to allow for insertion 
8e97				;call input_shiftright 
8e97 f1				pop af 
8e98			 
8e98			.shufinsmid: 
8e98 47				ld b, a     ; b contains new char, c prev char at this position  
8e99 7e				ld a, (hl) 
8e9a			 
8e9a			;	cp 0    ; at end of string need to then dump new char and add term 
8e9a b7				or a 
8e9b 28 07			jr z, .endinsmid 
8e9d 4f				ld c, a 
8e9e 78				ld a, b 
8e9f 77				ld (hl), a 
8ea0 23				inc hl 
8ea1 79				ld a, c 
8ea2 18 f4			jr .shufinsmid 
8ea4				 
8ea4			 
8ea4			 
8ea4			 
8ea4			.endinsmid: 
8ea4 78				ld a, b 
8ea5 77				ld (hl), a 
8ea6 23				inc hl 
8ea7			;	ld a, 0 
8ea7 36 00			ld (hl), 0 
8ea9			 
8ea9			 
8ea9			;	ld (hl), a   ; save new char 
8ea9			 
8ea9 c3 41 8e			jp input_right 
8eac			 
8eac			;input_shiftright: 
8eac			;	; shift text right at cursor, hl has shift start 
8eac			;	push hl 
8eac			;	push de 
8eac			;	push bc 
8eac			; 
8eac			; 
8eac			;	; move to end of string past zero term 
8eac			;	ld hl,(input_start) 
8eac			;	ld a, (input_len) 
8eac			;	call addatohl 
8eac			;	inc hl 
8eac			;;	inc hl 
8eac			;;	inc hl 
8eac			;	ld a, 0 
8eac			;	ld (hl), a 
8eac			;;	dec hl 
8eac			;	 
8eac			;;	ld (hl), a 
8eac			;;	dec hl 
8eac			; 
8eac			;	push hl 
8eac			;	pop de 
8eac			;	inc de 
8eac			;	 
8eac			; 
8eac			;;	ld hl,(input_start) 
8eac			;;	ld a, (input_cursor) 
8eac			;;	call addatohl 
8eac			; 
8eac			; 
8eac			;	; calc how many bytes from cursor pos to end of string we need to shift 
8eac			;	call input_lenrem    ; get bc length of remaining string 
8eac			;	;ld a, (input_cursor) 
8eac			;	;ld c, a 
8eac			;	ld a, (input_len) 
8eac			;	cp 2 
8eac			;	jr z, .iskipzero	 
8eac			;	;sub c 
8eac			;	;inc a 
8eac			;	;ld c, a 
8eac			;	;ld b, 0 
8eac			;	inc c 
8eac			;	inc c 
8eac			;	; move data 
8eac			;	lddr 
8eac			;.iskipzero: 
8eac			; 
8eac			;	pop bc 
8eac			;	pop de 
8eac			;	pop hl 
8eac			;	ret	 
8eac			 
8eac			input_delchar: 
8eac				; Delete char at cursor position 
8eac cd 6b 8e			call input_lenrem    ; get bc length of remaining string 
8eaf 2a 5e ee			ld hl, (input_start) 
8eb2 3a 4c ee			ld a, (input_cursor) 
8eb5 cd d6 8c			call addatohl 
8eb8			 
8eb8 e5				push hl 
8eb9 d1				pop de 
8eba 1b				dec de 
8ebb			 
8ebb			.dl:	 
8ebb ed a0			ldi  
8ebd 7e				ld a, (hl) 
8ebe			;	cp 0 
8ebe b7				or a 
8ebf 28 02			jr z, .dldone 
8ec1 18 f8			jr .dl 
8ec3			.dldone: 
8ec3 ed a0			ldi 
8ec5			 
8ec5 c3 3a 8e			jp input_left 
8ec8			 
8ec8			 
8ec8			endif 
8ec8			 
8ec8			 
8ec8			 
8ec8			if EDIT_V1 
8ec8			input_str: 
8ec8			 
8ec8				    	ld (input_at_pos),a      ; save display position to start 
8ec8					add c 
8ec8					ld (input_at_cursor),a	; save draw pos of cursor 
8ec8					ld (input_start), hl     ; save ptr to buffer 
8ec8					ld a, c 
8ec8					call addatohl 
8ec8					ld (input_ptr), hl     ; save ptr to point under the cursor 
8ec8					ld a,d 
8ec8				        ld (input_size), a       ; save length of input area 
8ec8					ld a, c 
8ec8					ld (input_cursor),a      ; init cursor start position  
8ec8					ld a,e 
8ec8				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8ec8					 
8ec8					 
8ec8			 
8ec8			;		ld a,(input_ptr) 
8ec8			;		ld (input_under_cursor),a 	; save what is under the cursor 
8ec8			 
8ec8			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8ec8					; init cursor shape if not set by the cin routines 
8ec8					ld hl, cursor_shape 
8ec8			if BASE_KEV 
8ec8					ld a, 255 
8ec8			else 
8ec8					ld a, '#' 
8ec8			endif 
8ec8					ld (hl), a 
8ec8					inc hl 
8ec8					ld a, 0 
8ec8					ld (hl), a 
8ec8			 
8ec8					ld a, CUR_BLINK_RATE 
8ec8					ld (input_cur_flash), a 
8ec8					ld a, 1 
8ec8					ld (input_cur_onoff),a 
8ec8			 
8ec8			;	if DEBUG_INPUT 
8ec8			;		push af 
8ec8			;		ld a, 'I' 
8ec8			;		ld (debug_mark),a 
8ec8			;		pop af 
8ec8			;		CALLMONITOR 
8ec8			;	endif 
8ec8			.is1:		; main entry loop 
8ec8			 
8ec8			 
8ec8			 
8ec8					; pause 1ms 
8ec8			 
8ec8					ld a, 1 
8ec8					call aDelayInMS 
8ec8			 
8ec8					; dec flash counter 
8ec8					ld a, (input_cur_flash) 
8ec8					dec a 
8ec8					ld (input_cur_flash), a 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jr nz, .nochgstate 
8ec8			 
8ec8			 
8ec8					; change state 
8ec8					ld a,(input_cur_onoff) 
8ec8					neg 
8ec8					ld (input_cur_onoff),a 
8ec8			 
8ec8			 
8ec8					; reset on change of state 
8ec8					ld a, CUR_BLINK_RATE 
8ec8					ld (input_cur_flash), a 
8ec8			 
8ec8			.nochgstate: 
8ec8					 
8ec8					 
8ec8			 
8ec8					; display cursor  
8ec8			 
8ec8			;		ld hl, (input_start) 
8ec8			;		ld a, (input_cursor) 
8ec8			;		call addatohl 
8ec8			 
8ec8					; get char under cursor and replace with cursor 
8ec8			ld hl, (input_ptr) 
8ec8			;		ld a, (hl) 
8ec8			;		ld (input_under_cursor),a 
8ec8			;		ld a, '_' 
8ec8			;		ld (hl), a 
8ec8			 
8ec8					; display string 
8ec8			 
8ec8					ld de, (input_start) 
8ec8					ld a, (input_at_pos) 
8ec8					call str_at_display 
8ec8			;	        call update_display 
8ec8			 
8ec8					; find place to put the cursor 
8ec8			;		add h 
8ec8			;		ld l, display_row_1 
8ec8			;		sub l 
8ec8			; (input_at_pos) 
8ec8					;ld c, a 
8ec8			;		ld a, (input_cursor) 
8ec8			;		ld l, (input_at_pos) 
8ec8			;		;ld b, h 
8ec8			;		add l 
8ec8			;		ld (input_at_cursor),a 
8ec8					;ld l,h 
8ec8			 
8ec8			;		ld h, 0 
8ec8			;		ld l,(input_at_pos) 
8ec8			;		ld a, (input_cursor) 
8ec8			;		call addatohl 
8ec8			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8ec8			;		call subafromhl 
8ec8			;		ld a,l 
8ec8			;		ld (input_at_cursor), a 
8ec8			 
8ec8				if DEBUG_INPUT 
8ec8					ld a, (hardware_diag) 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jr z, .skip_input_diag 
8ec8			 
8ec8					ld a,(input_at_pos) 
8ec8					ld hl, LFSRSeed 
8ec8					call hexout 
8ec8					ld a, (input_cursor) 
8ec8					ld hl, LFSRSeed+2 
8ec8					call hexout 
8ec8					ld a,(input_at_cursor) 
8ec8					ld hl, LFSRSeed+4 
8ec8					call hexout 
8ec8			 
8ec8					ld a,(input_cur_onoff) 
8ec8					ld hl, LFSRSeed+6 
8ec8					call hexout 
8ec8			 
8ec8					ld a,(input_cur_flash) 
8ec8					ld hl, LFSRSeed+8 
8ec8					call hexout 
8ec8			 
8ec8					ld a,(input_len) 
8ec8					ld hl, LFSRSeed+10 
8ec8					call hexout 
8ec8					ld hl, LFSRSeed+12 
8ec8					ld a, 0 
8ec8					ld (hl),a 
8ec8					ld a, display_row_4 
8ec8					ld de, LFSRSeed 
8ec8					call str_at_display 
8ec8					.skip_input_diag: 
8ec8				endif 
8ec8			 
8ec8					; decide on if we are showing the cursor this time round 
8ec8			 
8ec8					ld a, (input_cur_onoff) 
8ec8					cp 255 
8ec8					jr z, .skipcur 
8ec8			 
8ec8			 
8ec8					ld a,(input_at_cursor) 
8ec8					ld de, cursor_shape 
8ec8					call str_at_display 
8ec8			 
8ec8					; save length of current input string 
8ec8					ld hl, (input_start) 
8ec8					ld a, 0 
8ec8					call strlent 
8ec8					ld a,l 
8ec8					ld (input_len),a 
8ec8			 
8ec8			.skipcur: 
8ec8			 
8ec8				        call update_display 
8ec8					 
8ec8			 
8ec8			 
8ec8					; wait 
8ec8				 
8ec8					; TODO loop without wait to flash the cursor and char under cursor	 
8ec8					call cin    ; _wait 
8ec8			 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jp z, .is1 
8ec8			 
8ec8					; get ptr to char to input into 
8ec8			 
8ec8					ld c,a 
8ec8					ld hl, (input_start) 
8ec8					ld a, (input_cursor) 
8ec8					call addatohl 
8ec8					ld (input_ptr), hl 
8ec8					ld a,c 
8ec8			 
8ec8					; replace char under cursor 
8ec8			 
8ec8			;		ld hl, (input_ptr) 
8ec8			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8ec8			;		ld (hl), a 
8ec8			 
8ec8			;	if DEBUG_INPUT 
8ec8			;		push af 
8ec8			;		ld a, 'i' 
8ec8			;		ld (debug_mark),a 
8ec8			;		pop af 
8ec8			;		CALLMONITOR 
8ec8			;	endif 
8ec8					cp KEY_HOME 
8ec8					jr nz, .iske 
8ec8			 
8ec8					ld a, (input_at_pos) 
8ec8					ld (input_at_cursor),a 
8ec8					ld a, 0 
8ec8					ld (input_cursor), a 
8ec8					jp .is1 
8ec8					 
8ec8			.iske:		cp KEY_END 
8ec8					jr nz, .isknw 
8ec8					jp .is1 
8ec8			 
8ec8			.isknw:		cp KEY_NEXTWORD 
8ec8					jr nz, .iskpw 
8ec8			 
8ec8			.isknwm:	ld hl, (input_ptr) 
8ec8					ld a,(hl)	 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jp z, .is1    ; end of string 
8ec8					cp ' ' 
8ec8					jp z, .is1    ; end of word 
8ec8					inc hl 
8ec8					ld (input_ptr), hl 
8ec8					ld a, (input_at_cursor) 
8ec8					inc a 
8ec8					ld (input_at_cursor), a 
8ec8					jr .isknwm 
8ec8			 
8ec8			.iskpw:		cp KEY_PREVWORD 
8ec8					jr nz, .iskl 
8ec8			.iskpwm:	 
8ec8					ld hl, (input_ptr) 
8ec8					ld a,(hl)	 
8ec8			;		cp 0  
8ec8					or a 
8ec8					jp z, .is1    ; end of string 
8ec8					cp ' ' 
8ec8					jp z, .is1    ; end of word 
8ec8					dec hl 
8ec8					ld (input_ptr), hl 
8ec8					ld a, (input_at_cursor) 
8ec8					dec a 
8ec8					ld (input_at_cursor), a 
8ec8					jr .iskpwm 
8ec8			 
8ec8			 
8ec8			.iskl:		cp KEY_LEFT 
8ec8					jr nz, .isk1 
8ec8			 
8ec8					ld a, (input_cursor) 
8ec8			 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jp z, .is1 		; at start of line to ignore  
8ec8			 
8ec8					dec  a 		; TODO check underflow 
8ec8					ld (input_cursor), a 
8ec8			 
8ec8					ld hl, (input_ptr) 
8ec8					dec hl 
8ec8					ld (input_ptr), hl 
8ec8					 
8ec8					ld a, (input_at_cursor) 
8ec8					dec a 
8ec8					ld (input_at_cursor), a 
8ec8			 
8ec8					ld a, 1		; show cursor moving 
8ec8					ld (input_cur_onoff),a 
8ec8					ld a, CUR_BLINK_RATE 
8ec8					ld (input_cur_flash), a 
8ec8			 
8ec8					jp .is1 
8ec8			 
8ec8			.isk1:		cp KEY_RIGHT 
8ec8					jr nz, .isk2 
8ec8			 
8ec8					ld a,(input_len)		; TODO BUG why cant i load e direct? 
8ec8					ld e,a 
8ec8					ld a, (input_cursor) 
8ec8					cp e 
8ec8					jp z, .is1		; at the end of string so dont go right 
8ec8			 
8ec8					inc  a 		; TODO check overflow 
8ec8					ld (input_cursor), a 
8ec8			 
8ec8					ld a, (input_at_cursor) 
8ec8					inc a 
8ec8					ld (input_at_cursor), a 
8ec8			 
8ec8					ld hl, (input_ptr) 
8ec8					inc hl 
8ec8					ld (input_ptr), hl 
8ec8			 
8ec8					ld a, 1		; show cursor moving 
8ec8					ld (input_cur_onoff),a 
8ec8					ld a, CUR_BLINK_RATE 
8ec8					ld (input_cur_flash), a 
8ec8			 
8ec8					jp .is1 
8ec8			 
8ec8			.isk2:		cp KEY_UP 
8ec8			 
8ec8					jr nz, .isk3 
8ec8			 
8ec8					; swap last command with the current on 
8ec8			 
8ec8					; move cursor to start of string 
8ec8					ld hl, (input_start) 
8ec8					ld (input_ptr), hl 
8ec8			 
8ec8					ld a, (input_at_pos) 
8ec8					ld (input_at_cursor), a 
8ec8			 
8ec8					ld a, 0 
8ec8					ld (input_cursor), a 
8ec8					 
8ec8					; swap input and last command buffers 
8ec8			 
8ec8					ld hl, os_cli_cmd 
8ec8					ld de, os_last_cmd 
8ec8					ld b, 255 
8ec8			.swap1:		ld a, (hl) 
8ec8					ld c,a 
8ec8					ld a, (de) 
8ec8					ld (hl), a 
8ec8					ld a,c 
8ec8					ld (de),a 
8ec8					inc hl 
8ec8					inc de 
8ec8					djnz .swap1 
8ec8			 
8ec8			 
8ec8			 
8ec8			 
8ec8			 
8ec8					jp .is1 
8ec8			 
8ec8			.isk3:		cp KEY_BS 
8ec8					jr nz, .isk4 
8ec8			 
8ec8					ld a, (input_cursor) 
8ec8			 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jp z, .is1 		; at start of line to ignore  
8ec8			 
8ec8					dec  a 		; TODO check underflow 
8ec8					ld (input_cursor), a 
8ec8			 
8ec8					; hl is source 
8ec8					; de needs to be source - 1 
8ec8			 
8ec8			;		ld a, 0 
8ec8			;		dec hl 
8ec8			;		ld (hl), a 
8ec8			 
8ec8					ld hl, (input_ptr) 
8ec8					dec hl 
8ec8					ld (input_ptr), hl 
8ec8			 
8ec8					; shift all data 
8ec8			 
8ec8					push hl 
8ec8					inc hl 
8ec8					pop de 
8ec8					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8ec8					ld c,a 
8ec8					ld b,0 
8ec8					ldir  
8ec8			 
8ec8			 
8ec8			 
8ec8			 
8ec8					ld a, (input_at_cursor) 
8ec8					dec a 
8ec8					ld (input_at_cursor), a 
8ec8			 
8ec8			 
8ec8					ld a, 1		; show cursor moving 
8ec8					ld (input_cur_onoff),a 
8ec8					ld a, CUR_BLINK_RATE 
8ec8					ld (input_cur_flash), a 
8ec8			 
8ec8					; remove char 
8ec8					ld a, (input_at_cursor) 
8ec8					inc a 
8ec8					ld de,.iblank 
8ec8					call str_at_display 
8ec8			 
8ec8					jp .is1 
8ec8			 
8ec8			.isk4:		cp KEY_CR 
8ec8					jr z, .endinput 
8ec8			 
8ec8					; else add the key press to the end 
8ec8			 
8ec8					ld c, a			; save key pressed 
8ec8			 
8ec8					ld a,(hl)		; get what is currently under char 
8ec8			 
8ec8			;		cp 0			; we are at the end of the string 
8ec8					or a 
8ec8					jr nz, .onchar 
8ec8					 
8ec8					; add a char to the end of the string 
8ec8				 
8ec8					ld (hl),c 
8ec8					inc hl 
8ec8			;		ld a,' ' 
8ec8			;		ld (hl),a 
8ec8			;		inc hl 
8ec8					ld a,0 
8ec8					ld (hl),a 
8ec8					dec hl 
8ec8			 
8ec8					ld a, (input_cursor) 
8ec8					inc a				; TODO check max string length and scroll  
8ec8					ld (input_cursor), a		; inc cursor pos 
8ec8							 
8ec8					ld a, (input_at_cursor) 
8ec8					inc a 
8ec8					ld (input_at_cursor), a 
8ec8			 
8ec8					ld hl, (input_ptr) 
8ec8					inc hl 
8ec8					ld (input_ptr), hl 
8ec8			 
8ec8					ld hl, (input_ptr) 
8ec8					inc hl 
8ec8					ld (input_ptr), hl 
8ec8			;	if DEBUG_INPUT 
8ec8			;		push af 
8ec8			;		ld a, '+' 
8ec8			;		ld (debug_mark),a 
8ec8			;		pop af 
8ec8			;		CALLMONITOR 
8ec8			;	endif 
8ec8					ld a, 1		; show cursor moving 
8ec8					ld (input_cur_onoff),a 
8ec8					ld a, CUR_BLINK_RATE 
8ec8					ld (input_cur_flash), a 
8ec8					jp .is1 
8ec8					 
8ec8			 
8ec8			 
8ec8					; if on a char then insert 
8ec8			.onchar: 
8ec8			 
8ec8					; TODO over flow check: make sure insert does not blow out buffer 
8ec8			 
8ec8					; need to do some maths to use lddr 
8ec8			 
8ec8					push hl   ; save char pos 
8ec8					push bc 
8ec8			 
8ec8					ld hl, (input_start) 
8ec8					ld a, (input_len) 
8ec8					call addatohl  		; end of string 
8ec8					inc hl 
8ec8					inc hl		; past zero term 
8ec8					push hl 
8ec8					inc hl 
8ec8					push hl  
8ec8			 
8ec8								; start and end of lddr set, now how much to move? 
8ec8			 
8ec8							 
8ec8					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ec8					ld b,a 
8ec8					ld a,(input_len) 
8ec8					ld e,a 
8ec8					sub b 
8ec8					inc a		;?? 
8ec8					inc a		;?? 
8ec8					inc a		;?? 
8ec8			 
8ec8					ld b,0 
8ec8					ld c,a 
8ec8			 
8ec8				if DEBUG_INPUT 
8ec8					push af 
8ec8					ld a, 'i' 
8ec8					ld (debug_mark),a 
8ec8					pop af 
8ec8			;		CALLMONITOR 
8ec8				endif 
8ec8					pop de 
8ec8					pop hl 
8ec8				if DEBUG_INPUT 
8ec8					push af 
8ec8					ld a, 'I' 
8ec8					ld (debug_mark),a 
8ec8					pop af 
8ec8			;		CALLMONITOR 
8ec8				endif 
8ec8					lddr 
8ec8				 
8ec8			 
8ec8			 
8ec8					; TODO have a key for insert/overwrite mode???? 
8ec8					pop bc 
8ec8					pop hl 
8ec8					ld (hl), c		; otherwise overwrite current char 
8ec8					 
8ec8			 
8ec8			 
8ec8			 
8ec8					ld a, (input_cursor) 
8ec8					inc  a 		; TODO check overflow 
8ec8					ld (input_cursor), a 
8ec8			 
8ec8					ld a, (input_at_cursor) 
8ec8					inc a 
8ec8					ld (input_at_cursor), a 
8ec8			 
8ec8					jp .is1 
8ec8			 
8ec8			.endinput:	; TODO look for end of string 
8ec8			 
8ec8					; add trailing space for end of token 
8ec8			 
8ec8					ld hl, (input_start) 
8ec8					ld a,(input_len) 
8ec8					call addatohl 
8ec8					ld a, ' ' 
8ec8					ld (hl),a 
8ec8					; TODO eof of parse marker 
8ec8			 
8ec8					inc hl 
8ec8					ld a, 0 
8ec8					ld (hl),a 
8ec8			 
8ec8			 
8ec8					ret 
8ec8			 
8ec8			.iblank: db " ",0 
8ec8			 
8ec8			 
8ec8			input_str_prev:	ld (input_at_pos), a 
8ec8					ld (input_start), hl 
8ec8					ld a,1			; add cursor 
8ec8					ld (hl),a 
8ec8					inc hl 
8ec8					ld a,0 
8ec8					ld (hl),a 
8ec8					ld (input_ptr), hl 
8ec8					ld a,d 
8ec8					ld (input_size), a 
8ec8					ld a,0 
8ec8					ld (input_cursor),a 
8ec8			.instr1:	 
8ec8			 
8ec8					; TODO do block cursor 
8ec8					; TODO switch cursor depending on the modifer key 
8ec8			 
8ec8					; update cursor shape change on key hold 
8ec8			 
8ec8					ld hl, (input_ptr) 
8ec8					dec hl 
8ec8					ld a,(cursor_shape) 
8ec8					ld (hl), a 
8ec8			 
8ec8					; display entered text 
8ec8					ld a,(input_at_pos) 
8ec8			            	CALL fLCD_Pos       ;Position cursor to location in A 
8ec8			            	LD   de, (input_start) 
8ec8			            	CALL fLCD_Str       ;Display string pointed to by DE 
8ec8			 
8ec8					call cin 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jr z, .instr1 
8ec8			 
8ec8					; proecess keyboard controls first 
8ec8			 
8ec8					ld hl,(input_ptr) 
8ec8			 
8ec8					cp KEY_CR	 ; pressing enter ends input 
8ec8					jr z, .instrcr 
8ec8			 
8ec8					cp KEY_BS 	; back space 
8ec8					jr nz, .instr2 
8ec8					; process back space 
8ec8			 
8ec8					; TODO stop back space if at start of string 
8ec8					dec hl 
8ec8					dec hl ; to over write cursor 
8ec8					ld a,(cursor_shape) 
8ec8					;ld a,0 
8ec8					ld (hl),a 
8ec8					inc hl 
8ec8					ld a," " 
8ec8					ld (hl),a 
8ec8					ld (input_ptr),hl 
8ec8					 
8ec8			 
8ec8					jr .instr1 
8ec8			 
8ec8			.instr2:	cp KEY_LEFT    ; cursor left 
8ec8					jr nz, .instr3 
8ec8					dec hl 
8ec8					ld (input_ptr),hl 
8ec8					jr .instr1 
8ec8				 
8ec8			.instr3:	cp KEY_RIGHT      ; cursor right 
8ec8					jr nz, .instr4 
8ec8					inc hl 
8ec8					ld (input_ptr),hl 
8ec8					jr .instr1 
8ec8			 
8ec8			.instr4:	cp KEY_HOME    ; jump to start of line 
8ec8					jr nz, .instr5 
8ec8					dec hl 
8ec8					ld (input_ptr),hl 
8ec8					jr .instr1 
8ec8			 
8ec8			.instr5:	cp KEY_END     ; jump to end of line 
8ec8					jr nz, .instr6 
8ec8					dec hl 
8ec8					ld (input_ptr),hl 
8ec8					jr .instr1 
8ec8			.instr6:        cp KEY_UP      ; recall last command 
8ec8					jr nz, .instrnew 
8ec8			 
8ec8				ld hl, scratch 
8ec8				ld de, os_last_cmd 
8ec8				call strcpy 
8ec8					jr .instr1 
8ec8			 
8ec8			 
8ec8			.instrnew:	; no special key pressed to see if we have room to store it 
8ec8			 
8ec8					; TODO do string size test 
8ec8			 
8ec8					dec hl ; to over write cursor 
8ec8					ld (hl),a 
8ec8					inc hl 
8ec8					ld a,(cursor_shape) 
8ec8					ld (hl),a 
8ec8					inc hl 
8ec8					ld a,0 
8ec8					ld (hl),a 
8ec8			 
8ec8					ld (input_ptr),hl 
8ec8					 
8ec8					jr .instr1 
8ec8			.instrcr:	dec hl		; remove cursor 
8ec8					ld a,' '	; TODO add a trailing space for safety 
8ec8					ld (hl),a 
8ec8					inc hl 
8ec8					ld a,0 
8ec8					ld (hl),a 
8ec8			 
8ec8			 
8ec8					; if at end of line scroll up    
8ec8					; TODO detecting only end of line 4 for scroll up  
8ec8			 
8ec8					;ld   
8ec8			 
8ec8					ret 
8ec8			 
8ec8			 
8ec8			endif 
8ec8			; strcpy hl = dest, de source 
8ec8			 
8ec8 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8ec9 b7			            OR   A              ;Null terminator? 
8eca c8			            RET  Z              ;Yes, so finished 
8ecb 1a					ld a,(de) 
8ecc 77					ld (hl),a 
8ecd 13			            INC  DE             ;Point to next character 
8ece 23					inc hl 
8ecf 18 f7		            JR   strcpy       ;Repeat 
8ed1 c9					ret 
8ed2			 
8ed2			 
8ed2			; TODO string_at  
8ed2			; pass string which starts with lcd offset address and then null term string 
8ed2			 
8ed2			; TODO string to dec 
8ed2			; TODO string to hex 
8ed2			; TODO byte to string hex 
8ed2			; TODO byte to string dec 
8ed2			 
8ed2			 
8ed2			 
8ed2			; from z80uartmonitor 
8ed2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ed2			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8ed2			; pass hl for where to put the text 
8ed2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ed2 c5			hexout:	PUSH BC 
8ed3 f5					PUSH AF 
8ed4 47					LD B, A 
8ed5					; Upper nybble 
8ed5 cb 3f				SRL A 
8ed7 cb 3f				SRL A 
8ed9 cb 3f				SRL A 
8edb cb 3f				SRL A 
8edd cd ed 8e				CALL tohex 
8ee0 77					ld (hl),a 
8ee1 23					inc hl	 
8ee2					 
8ee2					; Lower nybble 
8ee2 78					LD A, B 
8ee3 e6 0f				AND 0FH 
8ee5 cd ed 8e				CALL tohex 
8ee8 77					ld (hl),a 
8ee9 23					inc hl	 
8eea					 
8eea f1					POP AF 
8eeb c1					POP BC 
8eec c9					RET 
8eed					 
8eed			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8eed			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8eed			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8eed			tohex: 
8eed e5					PUSH HL 
8eee d5					PUSH DE 
8eef 16 00				LD D, 0 
8ef1 5f					LD E, A 
8ef2 21 fa 8e				LD HL, .DATA 
8ef5 19					ADD HL, DE 
8ef6 7e					LD A, (HL) 
8ef7 d1					POP DE 
8ef8 e1					POP HL 
8ef9 c9					RET 
8efa			 
8efa			.DATA: 
8efa 30					DEFB	30h	; 0 
8efb 31					DEFB	31h	; 1 
8efc 32					DEFB	32h	; 2 
8efd 33					DEFB	33h	; 3 
8efe 34					DEFB	34h	; 4 
8eff 35					DEFB	35h	; 5 
8f00 36					DEFB	36h	; 6 
8f01 37					DEFB	37h	; 7 
8f02 38					DEFB	38h	; 8 
8f03 39					DEFB	39h	; 9 
8f04 41					DEFB	41h	; A 
8f05 42					DEFB	42h	; B 
8f06 43					DEFB	43h	; C 
8f07 44					DEFB	44h	; D 
8f08 45					DEFB	45h	; E 
8f09 46					DEFB	46h	; F 
8f0a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f0a			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8f0a			;;    subtract $30, if result > 9 then subtract $7 more 
8f0a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f0a			atohex: 
8f0a d6 30				SUB $30 
8f0c fe 0a				CP 10 
8f0e f8					RET M		; If result negative it was 0-9 so we're done 
8f0f d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8f11 c9					RET		 
8f12			 
8f12			 
8f12			 
8f12			 
8f12			; Get 2 ASCII characters as hex byte from pointer in hl 
8f12			 
8f12			BYTERD: 
8f12 16 00			LD	D,00h		;Set up 
8f14 cd 1c 8f			CALL	HEXCON		;Get byte and convert to hex 
8f17 87				ADD	A,A		;First nibble so 
8f18 87				ADD	A,A		;multiply by 16 
8f19 87				ADD	A,A		; 
8f1a 87				ADD	A,A		; 
8f1b 57				LD	D,A		;Save hi nibble in D 
8f1c			HEXCON: 
8f1c 7e				ld a, (hl)		;Get next chr 
8f1d 23				inc hl 
8f1e d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8f20 fe 0a			CP	00Ah		;Is it 0-9 ? 
8f22 38 02			JR	C,NALPHA	;If so miss next bit 
8f24 d6 07			SUB	007h		;Else convert alpha 
8f26			NALPHA: 
8f26 b2				OR	D		;Add hi nibble back 
8f27 c9				RET			; 
8f28			 
8f28			 
8f28			; 
8f28			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8f28			; Since the routines get_byte and therefore get_nibble are called, only valid 
8f28			; characters (0-9a-f) are accepted. 
8f28			; 
8f28			;get_word        push    af 
8f28			;                call    get_byte        ; Get the upper byte 
8f28			;                ld      h, a 
8f28			;                call    get_byte        ; Get the lower byte 
8f28			;                ld      l, a 
8f28			;                pop     af 
8f28			;                ret 
8f28			; 
8f28			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8f28			; the routine get_nibble is used only valid characters are accepted - the  
8f28			; input routine only accepts characters 0-9a-f. 
8f28			; 
8f28 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8f29 7e					ld a,(hl) 
8f2a 23					inc hl 
8f2b cd 50 8f		                call    nibble2val      ; Get upper nibble 
8f2e cb 07		                rlc     a 
8f30 cb 07		                rlc     a 
8f32 cb 07		                rlc     a 
8f34 cb 07		                rlc     a 
8f36 47			                ld      b, a            ; Save upper four bits 
8f37 7e					ld a,(hl) 
8f38 cd 50 8f		                call    nibble2val      ; Get lower nibble 
8f3b b0			                or      b               ; Combine both nibbles 
8f3c c1			                pop     bc              ; Restore B (and C) 
8f3d c9			                ret 
8f3e			; 
8f3e			; Get a hexadecimal digit from the serial line. This routine blocks until 
8f3e			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8f3e			; to the serial line interface. The lower 4 bits of A contain the value of  
8f3e			; that particular digit. 
8f3e			; 
8f3e			;get_nibble      ld a,(hl)           ; Read a character 
8f3e			;                call    to_upper        ; Convert to upper case 
8f3e			;                call    is_hex          ; Was it a hex digit? 
8f3e			;                jr      nc, get_nibble  ; No, get another character 
8f3e			 ;               call    nibble2val      ; Convert nibble to value 
8f3e			 ;               call    print_nibble 
8f3e			 ;               ret 
8f3e			; 
8f3e			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8f3e			; A valid hexadecimal digit is denoted by a set C flag. 
8f3e			; 
8f3e			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8f3e			;                ret     nc              ; Yes 
8f3e			;                cp      '0'             ; Less than '0'? 
8f3e			;                jr      nc, is_hex_1    ; No, continue 
8f3e			;                ccf                     ; Complement carry (i.e. clear it) 
8f3e			;                ret 
8f3e			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8f3e			;                ret     c               ; Yes 
8f3e			;                cp      'A'             ; Less than 'A'? 
8f3e			;                jr      nc, is_hex_2    ; No, continue 
8f3e			;                ccf                     ; Yes - clear carry and return 
8f3e			;                ret 
8f3e			;is_hex_2        scf                     ; Set carry 
8f3e			;                ret 
8f3e			; 
8f3e			; Convert a single character contained in A to upper case: 
8f3e			; 
8f3e fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8f40 d8			                ret     c 
8f41 fe 7b		                cp      'z' + 1         ; > 'z'? 
8f43 d0			                ret     nc              ; Nothing to do, either 
8f44 e6 5f		                and     $5f             ; Convert to upper case 
8f46 c9			                ret 
8f47			 
8f47			 
8f47			to_lower: 
8f47			 
8f47			   ; if char is in [A-Z] make it lower case 
8f47			 
8f47			   ; enter : a = char 
8f47			   ; exit  : a = lower case char 
8f47			   ; uses  : af 
8f47			 
8f47 fe 41		   cp 'A' 
8f49 d8			   ret c 
8f4a			    
8f4a fe 5b		   cp 'Z'+1 
8f4c d0			   ret nc 
8f4d			    
8f4d f6 20		   or $20 
8f4f c9			   ret 
8f50			 
8f50			; 
8f50			; Expects a hexadecimal digit (upper case!) in A and returns the 
8f50			; corresponding value in A. 
8f50			; 
8f50 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8f52 38 02		                jr      c, nibble2val_1 ; Yes 
8f54 d6 07		                sub     7               ; Adjust for A-F 
8f56 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8f58 e6 0f		                and     $f              ; Only return lower 4 bits 
8f5a c9			                ret 
8f5b			; 
8f5b			; Print_nibble prints a single hex nibble which is contained in the lower  
8f5b			; four bits of A: 
8f5b			; 
8f5b			;print_nibble    push    af              ; We won't destroy the contents of A 
8f5b			;                and     $f              ; Just in case... 
8f5b			;                add     a, '0'             ; If we have a digit we are done here. 
8f5b			;                cp      '9' + 1         ; Is the result > 9? 
8f5b			;                jr      c, print_nibble_1 
8f5b			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8f5b			;print_nibble_1  call    putc            ; Print the nibble and 
8f5b			;                pop     af              ; restore the original value of A 
8f5b			;                ret 
8f5b			;; 
8f5b			;; Send a CR/LF pair: 
8f5b			; 
8f5b			;crlf            push    af 
8f5b			;                ld      a, cr 
8f5b			;                call    putc 
8f5b			;                ld      a, lf 
8f5b			;                call    putc 
8f5b			;                pop     af 
8f5b			;                ret 
8f5b			; 
8f5b			; Print_word prints the four hex digits of a word to the serial line. The  
8f5b			; word is expected to be in HL. 
8f5b			; 
8f5b			;print_word      push    hl 
8f5b			;                push    af 
8f5b			;                ld      a, h 
8f5b			;                call    print_byte 
8f5b			;                ld      a, l 
8f5b			;                call    print_byte 
8f5b			;                pop     af 
8f5b			;                pop     hl 
8f5b			;                ret 
8f5b			; 
8f5b			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8f5b			; The byte to be printed is expected to be in A. 
8f5b			; 
8f5b			;print_byte      push    af              ; Save the contents of the registers 
8f5b			;                push    bc 
8f5b			;                ld      b, a 
8f5b			;                rrca 
8f5b			;                rrca 
8f5b			;                rrca 
8f5b			;                rrca 
8f5b			;                call    print_nibble    ; Print high nibble 
8f5b			;                ld      a, b 
8f5b			;                call    print_nibble    ; Print low nibble 
8f5b			;                pop     bc              ; Restore original register contents 
8f5b			;                pop     af 
8f5b			;                ret 
8f5b			 
8f5b			 
8f5b			 
8f5b			 
8f5b			 
8f5b			fourehexhl:  
8f5b 7e				ld a,(hl) 
8f5c cd 0a 8f			call atohex 
8f5f cb 3f				SRL A 
8f61 cb 3f				SRL A 
8f63 cb 3f				SRL A 
8f65 cb 3f				SRL A 
8f67 47				ld b, a 
8f68 23				inc hl 
8f69 7e				ld a,(hl) 
8f6a 23				inc hl 
8f6b cd 0a 8f			call atohex 
8f6e 80				add b 
8f6f 57				ld d,a 
8f70 7e				ld a,(hl) 
8f71 cd 0a 8f			call atohex 
8f74 cb 3f				SRL A 
8f76 cb 3f				SRL A 
8f78 cb 3f				SRL A 
8f7a cb 3f				SRL A 
8f7c 47				ld b, a 
8f7d 23				inc hl 
8f7e 7e				ld a,(hl) 
8f7f 23				inc hl 
8f80 cd 0a 8f			call atohex 
8f83 80				add b 
8f84 5f				ld e, a 
8f85 d5				push de 
8f86 e1				pop hl 
8f87 c9				ret 
8f88			 
8f88			; pass hl. returns z set if the byte at hl is a digit 
8f88			;isdigithl:  
8f88			;	push bc 
8f88			;	ld a,(hl) 
8f88			;	cp ':' 
8f88			;	jr nc, .isdf 		; > 
8f88			;	cp '0' 
8f88			;	jr c, .isdf		; < 
8f88			; 
8f88			;	; TODO find a better way to set z 
8f88			; 
8f88			;	ld b,a 
8f88			;	cp b 
8f88			;	pop bc 
8f88			;	ret 
8f88			; 
8f88			;.isdf:	; not digit so clear z 
8f88			; 
8f88			;	; TODO find a better way to unset z 
8f88			; 
8f88			;	ld b,a 
8f88			;	inc b 
8f88			;	cp b 
8f88			; 
8f88			;	pop bc 
8f88			;	ret 
8f88				 
8f88				 
8f88			 
8f88			 
8f88			; pass hl as the four byte address to load 
8f88			 
8f88			get_word_hl:  
8f88 e5				push hl 
8f89 cd 28 8f			call get_byte 
8f8c				 
8f8c 47				ld b, a 
8f8d			 
8f8d e1				pop hl 
8f8e 23				inc hl 
8f8f 23				inc hl 
8f90			 
8f90			; TODO not able to handle a-f  
8f90 7e				ld a,(hl) 
8f91			;	;cp ':' 
8f91			;	cp 'g' 
8f91			;	jr nc, .single_byte_hl 		; > 
8f91			;	cp 'G' 
8f91			;	jr nc, .single_byte_hl 		; > 
8f91			;	cp '0' 
8f91			;	jr c, .single_byte_hl		; < 
8f91			 
8f91				;call isdigithl 
8f91			;	cp 0 
8f91 b7				or a 
8f92 28 06			jr z, .single_byte_hl 
8f94			 
8f94			.getwhln:   ; hex word so get next byte 
8f94			 
8f94 cd 28 8f			call get_byte 
8f97 6f				ld l, a 
8f98 60				ld h,b 
8f99 c9				ret 
8f9a 68			.single_byte_hl:   ld l,b 
8f9b 26 00				ld h,0 
8f9d c9					ret 
8f9e			 
8f9e			 
8f9e			 
8f9e			 
8f9e 21 a6 96			ld hl,asc+1 
8fa1			;	ld a, (hl) 
8fa1			;	call nibble2val 
8fa1 cd 28 8f			call get_byte 
8fa4			 
8fa4			;	call fourehexhl 
8fa4 32 ec e2			ld (scratch+52),a 
8fa7				 
8fa7 21 ea e2			ld hl,scratch+50 
8faa 22 db e5			ld (os_cur_ptr),hl 
8fad			 
8fad c9				ret 
8fae			 
8fae			 
8fae			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8fae			 
8fae			; Decimal Unsigned Version 
8fae			 
8fae			;Number in a to decimal ASCII 
8fae			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8fae			;Example: display a=56 as "056" 
8fae			;input: a = number 
8fae			;Output: a=0,value of a in the screen 
8fae			;destroys af,bc (don't know about hl and de) 
8fae			DispAToASCII: 
8fae 0e 9c			ld	c,-100 
8fb0 cd ba 8f			call	.Na1 
8fb3 0e f6			ld	c,-10 
8fb5 cd ba 8f			call	.Na1 
8fb8 0e ff			ld	c,-1 
8fba 06 2f		.Na1:	ld	b,'0'-1 
8fbc 04			.Na2:	inc	b 
8fbd 81				add	a,c 
8fbe 38 fc			jr	c,.Na2 
8fc0 91				sub	c		;works as add 100/10/1 
8fc1 f5				push af		;safer than ld c,a 
8fc2 78				ld	a,b		;char is in b 
8fc3			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8fc3 f1				pop af		;safer than ld a,c 
8fc4 c9				ret 
8fc5			 
8fc5			; Decimal Signed Version 
8fc5			 
8fc5			; DispA 
8fc5			; -------------------------------------------------------------- 
8fc5			; Converts a signed integer value to a zero-terminated ASCII 
8fc5			; string representative of that value (using radix 10). 
8fc5			; -------------------------------------------------------------- 
8fc5			; INPUTS: 
8fc5			;     HL     Value to convert (two's complement integer). 
8fc5			;     DE     Base address of string destination. (pointer). 
8fc5			; -------------------------------------------------------------- 
8fc5			; OUTPUTS: 
8fc5			;     None 
8fc5			; -------------------------------------------------------------- 
8fc5			; REGISTERS/MEMORY DESTROYED 
8fc5			; AF HL 
8fc5			; -------------------------------------------------------------- 
8fc5			 
8fc5			;DispHLToASCII: 
8fc5			;   push    de 
8fc5			;   push    bc 
8fc5			; 
8fc5			;; Detect sign of HL. 
8fc5			;    bit    7, h 
8fc5			;    jr     z, ._DoConvert 
8fc5			; 
8fc5			;; HL is negative. Output '-' to string and negate HL. 
8fc5			;    ld     a, '-' 
8fc5			;    ld     (de), a 
8fc5			;    inc    de 
8fc5			; 
8fc5			;; Negate HL (using two's complement) 
8fc5			;    xor    a 
8fc5			;    sub    l 
8fc5			;    ld     l, a 
8fc5			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8fc5			;    sbc    a, h 
8fc5			;    ld     h, a 
8fc5			; 
8fc5			;; Convert HL to digit characters 
8fc5			;._DoConvert: 
8fc5			;    ld     b, 0     ; B will count character length of number 
8fc5			;-   ld     a, 10 
8fc5			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8fc5			;    push   af 
8fc5			;    inc    b 
8fc5			;    ld     a, h 
8fc5			;    or     l 
8fc5			;    jr     nz, - 
8fc5			; 
8fc5			;; Retrieve digits from stack 
8fc5			;-   pop    af 
8fc5			;    or     $30 
8fc5			;    ld     (de), a 
8fc5			;    inc    de 
8fc5			;    djnz   - 
8fc5			; 
8fc5			;; Terminate string with NULL 
8fc5			;    xor    a 
8fc5			;    ld     (de), a 
8fc5			; 
8fc5			;    pop    bc 
8fc5			;    pop    de 
8fc5			;    ret 
8fc5			 
8fc5			;Comments 
8fc5			; 
8fc5			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8fc5			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8fc5			;    Note that the output string will not be fixed-width. 
8fc5			; 
8fc5			;Example Usage 
8fc5			; 
8fc5			;    ld    hl, -1004 
8fc5			;    ld    de, OP1 
8fc5			;    call  DispA 
8fc5			;    ld    hl, OP1 
8fc5			;    syscall  PutS 
8fc5			 
8fc5			 
8fc5			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fc5			 
8fc5			 
8fc5			;Converts an ASCII string to an unsigned 16-bit integer 
8fc5			;Quits when it reaches a non-decimal digit 
8fc5			 
8fc5			string_to_uint16: 
8fc5			atoui_16: 
8fc5			;Input: 
8fc5			;     DE points to the string 
8fc5			;Outputs: 
8fc5			;     HL is the result 
8fc5			;     A is the 8-bit value of the number 
8fc5			;     DE points to the byte after the number 
8fc5			;Destroys: 
8fc5			;     BC 
8fc5			;       if the string is non-empty, BC is HL/10 
8fc5			;Size:  24 bytes 
8fc5			;Speed: 42+d(104+{0,9}) 
8fc5			;       d is the number of digits in the number 
8fc5			;       max is 640 cycles for a 5 digit number 
8fc5			;Assuming no leading zeros: 
8fc5			;1 digit:  146cc 
8fc5			;2 digit:  250cc 
8fc5			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8fc5			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8fc5			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8fc5			;avg: 544.81158447265625cc (544+13297/16384) 
8fc5			;=============================================================== 
8fc5 21 00 00		  ld hl,0 
8fc8			.u16a: 
8fc8 1a			  ld a,(de) 
8fc9 d6 30		  sub 30h 
8fcb fe 0a		  cp 10 
8fcd d0			  ret nc 
8fce 13			  inc de 
8fcf 44			  ld b,h 
8fd0 4d			  ld c,l 
8fd1 29			  add hl,hl 
8fd2 29			  add hl,hl 
8fd3 09			  add hl,bc 
8fd4 29			  add hl,hl 
8fd5 85			  add a,l 
8fd6 6f			  ld l,a 
8fd7 30 ef		  jr nc,.u16a 
8fd9 24			  inc h 
8fda c3 c8 8f		  jp .u16a 
8fdd			 
8fdd			 
8fdd			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fdd			 
8fdd			;written by Zeda 
8fdd			;Converts a 16-bit unsigned integer to an ASCII string. 
8fdd			 
8fdd			uitoa_16: 
8fdd			;Input: 
8fdd			;   DE is the number to convert 
8fdd			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8fdd			;Output: 
8fdd			;   HL points to the null-terminated ASCII string 
8fdd			;      NOTE: This isn't necessarily the same as the input HL. 
8fdd d5			  push de 
8fde c5			  push bc 
8fdf f5			  push af 
8fe0 eb			  ex de,hl 
8fe1			 
8fe1 01 f0 d8		  ld bc,-10000 
8fe4 3e 2f		  ld a,'0'-1 
8fe6 3c			  inc a 
8fe7 09			  add hl,bc  
8fe8 38 fc		   jr c,$-2 
8fea 12			  ld (de),a 
8feb 13			  inc de 
8fec			 
8fec 01 e8 03		  ld bc,1000 
8fef 3e 3a		  ld a,'9'+1 
8ff1 3d			  dec a  
8ff2 09			  add hl,bc  
8ff3 30 fc		   jr nc,$-2 
8ff5 12			  ld (de),a 
8ff6 13			  inc de 
8ff7			 
8ff7 01 9c ff		  ld bc,-100 
8ffa 3e 2f		  ld a,'0'-1 
8ffc 3c			  inc a  
8ffd 09			  add hl,bc  
8ffe 38 fc		   jr c,$-2 
9000 12			  ld (de),a 
9001 13			  inc de 
9002			 
9002 7d			  ld a,l 
9003 26 3a		  ld h,'9'+1 
9005 25			  dec h  
9006 c6 0a		  add a,10  
9008 30 fb		   jr nc,$-3 
900a c6 30		  add a,'0' 
900c eb			  ex de,hl 
900d 72			  ld (hl),d 
900e 23			  inc hl 
900f 77			  ld (hl),a 
9010 23			  inc hl 
9011 36 00		  ld (hl),0 
9013			 
9013			;Now strip the leading zeros 
9013 0e fa		  ld c,-6 
9015 09			  add hl,bc 
9016 3e 30		  ld a,'0' 
9018 23			  inc hl  
9019 be			  cp (hl)  
901a 28 fc		  jr z,$-2 
901c			 
901c			;Make sure that the string is non-empty! 
901c 7e			  ld a,(hl) 
901d b7			  or a 
901e 20 01		  jr nz,.atoub 
9020 2b			  dec hl 
9021			.atoub: 
9021			 
9021 f1			  pop af 
9022 c1			  pop bc 
9023 d1			  pop de 
9024 c9			  ret 
9025			 
9025			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9025			 
9025			toUpper: 
9025			;A is the char. 
9025			;If A is a lowercase letter, this sets it to the matching uppercase 
9025			;18cc or 30cc or 41cc 
9025			;avg: 26.75cc 
9025 fe 61		  cp 'a' 
9027 d8			  ret c 
9028 fe 7b		  cp 'z'+1 
902a d0			  ret nc 
902b d6 20		  sub 'a'-'A' 
902d c9			  ret 
902e			 
902e			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
902e			 
902e			; String Length 
902e			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
902e			 
902e			; Get the length of the null-terminated string starting at $8000 hl 
902e			;    LD     HL, $8000 
902e			 
902e			strlenz: 
902e			 
902e af			    XOR    A               ; Zero is the value we are looking for. 
902f 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9030 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9031			                           ; 65, 536 bytes (the entire addressable memory space). 
9031 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9033			 
9033			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9033 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9034 6f			    LD     L, A             ; number of bytes 
9035 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9037 2b			    DEC    HL              ; Compensate for null. 
9038 c9				ret 
9039			 
9039			; Get the length of the A terminated string starting at $8000 hl 
9039			;    LD     HL, $8000 
9039			 
9039			strlent: 
9039			 
9039			                  ; A is the value we are looking for. 
9039 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
903b 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
903d			                           ; 65, 536 bytes (the entire addressable memory space). 
903d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
903f			 
903f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
903f 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9041 2e 00		    LD     L, 0             ; number of bytes 
9043 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9045 2b			    DEC    HL              ; Compensate for null. 
9046 c9				ret 
9047			 
9047			 
9047			;Comparing Strings 
9047			 
9047			;IN    HL     Address of string1. 
9047			;      DE     Address of string2. 
9047			 
9047			; doc given but wrong??? 
9047			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9047			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9047			; tested 
9047			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9047			 
9047			strcmp_old: 
9047 e5			    PUSH   HL 
9048 d5			    PUSH   DE 
9049			 
9049 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
904a be			    CP     (HL)            ; (want to minimize work). 
904b 38 01		    JR     C, Str1IsBigger 
904d 7e			    LD     A, (HL) 
904e			 
904e			Str1IsBigger: 
904e 4f			    LD     C, A             ; Put length in BC 
904f 06 00		    LD     B, 0 
9051 13			    INC    DE              ; Increment pointers to meat of string. 
9052 23			    INC    HL 
9053			 
9053			CmpLoop: 
9053 1a			    LD     A, (DE)          ; Compare bytes. 
9054 ed a1		    CPI 
9056 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9058 13			    INC    DE              ; Update pointer. 
9059 ea 53 90		    JP     PE, CmpLoop 
905c			 
905c d1			    POP    DE 
905d e1			    POP    HL 
905e 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
905f be			    CP     (HL) 
9060 c9			    RET 
9061			 
9061			NoMatch: 
9061 2b			    DEC    HL 
9062 be			    CP     (HL)            ; Compare again to affect carry. 
9063 d1			    POP    DE 
9064 e1			    POP    HL 
9065 c9			    RET 
9066			 
9066			;; test strmp 
9066			; 
9066			;ld de, .str1 
9066			;ld hl, .str2 
9066			;call strcmp 
9066			;jr z, .z1 
9066			;;this 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "NZ1" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			;.z1: 
9066			; 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "ZZ1" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			; 
9066			;ld de, .str1 
9066			;ld hl, .str1 
9066			;call strcmp 
9066			;jr z, .z2 
9066			;;this 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "NZ2" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			;.z2: 
9066			; 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "ZZ2" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			; 
9066			;ld de, .str1 
9066			;ld hl, .str2 
9066			;call strcmp 
9066			;jr c, .c1 
9066			; 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "Nc1" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			;.c1: 
9066			;;this 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "cc1" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			; 
9066			;ld de, .str1 
9066			;ld hl, .str1 
9066			;call strcmp 
9066			;jr c, .c2 
9066			;;this 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "Nc2" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			;.c2: 
9066			; 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "cc2" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			;	NEXTW 
9066			;.str1:   db "string1",0 
9066			;.str2:   db "string2",0 
9066			 
9066			; only care about direct match or not 
9066			; hl and de strings 
9066			; zero set if the same 
9066			 
9066			strcmp: 
9066 1a				ld a, (de) 
9067 be				cp (hl) 
9068 28 02			jr z, .ssame 
906a b7				or a 
906b c9				ret 
906c			 
906c			.ssame:  
906c			;	cp 0 
906c b7				or a 
906d c8				ret z 
906e			 
906e 23				inc hl 
906f 13				inc de 
9070 18 f4			jr strcmp 
9072				 
9072				 
9072			 
9072			;Copyright (c) 2014, Luke Maurits 
9072			;All rights reserved. 
9072			; 
9072			;Redistribution and use in source and binary forms, with or without 
9072			;modification, are permitted provided that the following conditions are met: 
9072			; 
9072			;* Redistributions of source code must retain the above copyright notice, this 
9072			;  list of conditions and the following disclaimer. 
9072			; 
9072			;* Redistributions in binary form must reproduce the above copyright notice, 
9072			;  this list of conditions and the following disclaimer in the documentation 
9072			;  and/or other materials provided with the distribution. 
9072			; 
9072			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
9072			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
9072			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
9072			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
9072			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
9072			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
9072			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
9072			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
9072			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
9072			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
9072			 
9072			; https://github.com/lmaurits/lm512/blob/master/string.z80 
9072			 
9072			StrictStrCmp: 
9072				; Load next chars of each string 
9072 1a				ld a, (de) 
9073 47				ld b, a 
9074 7e				ld a, (hl) 
9075				; Compare 
9075 b8				cp b 
9076				; Return non-zero if chars don't match 
9076 c0				ret nz 
9077				; Check for end of both strings 
9077 fe 00			cp "\0" 
9079				; Return if strings have ended 
9079 c8				ret z 
907a				; Otherwise, advance to next chars 
907a 23				inc hl 
907b 13				inc de 
907c 18 f4			jr StrictStrCmp 
907e			 
907e			;end 
907e			; eof 
907e			 
907e			 
907e			 
907e			 
907e			 
907e			 
# End of file firmware_strings.asm
907e			include "firmware_memory.asm"   ; malloc and free  
907e			 
907e			if DEBUG_FORTH_MALLOC_HIGH 
907e			.mallocsize: db "Wants malloc >256",0 
907e			.mallocasize: db "MALLOC gives >256",0 
907e			.malloczero: db "MALLOC gives zero",0 
907e			 
907e			malloc_guard_zerolen: 
907e				push hl 
907e				push de 
907e				push af 
907e			 
907e				ld de, 0 
907e			        call cmp16 
907e				jr nz, .lowalloz 
907e			 
907e				push hl 
907e				push de 
907e					ld hl, display_fb0 
907e					ld (display_fb_active), hl 
907e				call clear_display 
907e				ld a, 0 
907e				ld de, .malloczero 
907e				call str_at_display 
907e				call update_display 
907e				call delay1s 
907e				call delay1s 
907e				call bp_on 
907e			;	ld a, 0 
907e			;	ld (os_view_disable), a 
907e			 
907e				pop de 
907e				pop hl 
907e			 
907e				 
907e			 
907e				CALLMONITOR 
907e			.lowalloz: 
907e			 
907e			 
907e				pop af 
907e				pop de 
907e				pop hl 
907e			ret 
907e			 
907e			malloc_guard_entry: 
907e				push hl 
907e				push de 
907e				push af 
907e			 
907e			 	or a      ;clear carry flag 
907e				push hl 
907e				ld de, 255 
907e				sbc hl, de 
907e				jr c, .lowalloc 
907e			 
907e				push de 
907e					ld hl, display_fb0 
907e					ld (display_fb_active), hl 
907e				call clear_display 
907e				ld a, 0 
907e				ld de, .mallocsize 
907e				call str_at_display 
907e				call update_display 
907e				call delay1s 
907e				call delay1s 
907e			;	ld a, 0 
907e			;	ld (os_view_disable), a 
907e				call bp_on 
907e			 
907e				pop de 
907e				pop hl 
907e			 
907e				 
907e			 
907e				CALLMONITOR 
907e				jr .lowdone 
907e			.lowalloc: 
907e			 
907e			 
907e				pop hl 
907e			.lowdone:	pop af 
907e				pop de 
907e				pop hl 
907e			ret 
907e			 
907e			malloc_guard_exit: 
907e				push hl 
907e				push de 
907e				push af 
907e			 
907e			 	or a      ;clear carry flag 
907e				push hl 
907e				ld de, 255 
907e				sbc hl, de 
907e				jr c, .lowallocx 
907e			 
907e				push de 
907e					ld hl, display_fb0 
907e					ld (display_fb_active), hl 
907e				call clear_display 
907e				ld a, 0 
907e				ld de, .mallocasize 
907e				call str_at_display 
907e				call update_display 
907e				call delay1s 
907e				call delay1s 
907e			;	ld a, 0 
907e			;	ld (os_view_disable), a 
907e				call bp_on 
907e				pop de 
907e				pop hl 
907e			 
907e				CALLMONITOR 
907e				jr .lowdonex 
907e			.lowallocx: 
907e			 
907e				pop hl 
907e			.lowdonex:	pop af 
907e				pop de 
907e				pop hl 
907e			ret 
907e			endif 
907e			 
907e			if MALLOC_2 
907e			; Z80 Malloc and Free Functions 
907e			 
907e			; Malloc Function: 
907e			; Input: 
907e			;   HL: Size of block to allocate 
907e			; Output: 
907e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
907e			 
907e			malloc: 
907e				 
907e			if DEBUG_FORTH_MALLOC_HIGH 
907e			call malloc_guard_entry 
907e			endif 
907e			 
907e			 
907e			 
907e			 
907e					if DEBUG_FORTH_MALLOC 
907e						DMARK "mal" 
907e						CALLMONITOR 
907e					endif 
907e			    push af            ; Save AF register 
907e			    ld a, l            ; Load low byte of size into A 
907e			    or h               ; Check if size is zero 
907e			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
907e			 
907e			    ; Allocate memory 
907e			    ld hl, (heap_start) ; Load start of heap into HL 
907e					if DEBUG_FORTH_MALLOC 
907e						DMARK "ma1" 
907e						CALLMONITOR 
907e					endif 
907e			    call malloc_internal ; Call internal malloc function 
907e			    pop af             ; Restore AF register 
907e			if DEBUG_FORTH_MALLOC_HIGH 
907e			call malloc_guard_exit 
907e			call malloc_guard_zerolen 
907e			endif 
907e			    ret                ; Return 
907e			 
907e			; Free Function: 
907e			; Input: 
907e			;   HL: Pointer to memory block to free 
907e			; Output: 
907e			;   None 
907e			 
907e			free: 
907e			    push af            ; Save AF register 
907e			    ld a, l            ; Load low byte of pointer into A 
907e			    or h               ; Check if pointer is NULL 
907e			    jp z, free_exit    ; If pointer is NULL, exit 
907e			 
907e			    ; Free memory 
907e			    ld hl, (heap_start) ; Load start of heap into HL 
907e			    call free_internal  ; Call internal free function 
907e			    pop af             ; Restore AF register 
907e			    ret                ; Return 
907e			 
907e			; Internal Malloc Function: 
907e			; Input: 
907e			;   HL: Size of block to allocate 
907e			; Output: 
907e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
907e			 
907e			malloc_internal: 
907e			    ld bc, 2           ; Number of bytes to allocate for management overhead 
907e			    add hl, bc         ; Add management overhead to requested size 
907e			    ex de, hl          ; Save total size in DE, and keep it in HL 
907e					if DEBUG_FORTH_MALLOC 
907e						DMARK "ma2" 
907e						CALLMONITOR 
907e					endif 
907e			 
907e			    ; Search for free memory block 
907e			    ld de, (heap_end)  ; Load end of heap into DE 
907e			    ld bc, 0           ; Initialize counter 
907e			 
907e					if DEBUG_FORTH_MALLOC 
907e						DMARK "ma2" 
907e						CALLMONITOR 
907e					endif 
907e			malloc_search_loop: 
907e			    ; Check if current block is free 
907e			    ld a, (hl)         ; Load current block's status (free or used) 
907e			;    cp 0               ; Compare with zero (free) 
907e				or a 
907e			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
907e			 
907e			    ; Check if current block is large enough 
907e			    ld a, (hl+1)       ; Load high byte of block size 
907e			    cp l               ; Compare with low byte of requested size 
907e			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
907e			 
907e			    ld a, (hl+2)       ; Load low byte of block size 
907e			    cp h               ; Compare with high byte of requested size 
907e			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
907e			 
907e			    ; Mark block as used 
907e			    ld (hl), 0xFF      ; Set status byte to indicate used block 
907e			 
907e			    ; Calculate remaining space in block 
907e			    ld bc, 0           ; Clear BC 
907e			    add hl, bc         ; Increment HL to point to start of data block 
907e			    add hl, de         ; HL = HL + DE (total size) 
907e			    ld bc, 1           ; Number of bytes to allocate for management overhead 
907e			    add hl, bc         ; Add management overhead to start of data block 
907e			 
907e			    ; Save pointer to allocated block in HL 
907e			if DEBUG_FORTH_MALLOC_HIGH 
907e						DMARK "ma5" 
907e			call malloc_guard_exit 
907e			call malloc_guard_zerolen 
907e			endif 
907e			    ret 
907e			 
907e			malloc_skip_block_check: 
907e			    ; Move to the next block 
907e			    ld bc, 3           ; Size of management overhead 
907e			    add hl, bc         ; Move to the next block 
907e			    inc de             ; Increment counter 
907e			 
907e			    ; Check if we have reached the end of heap 
907e			    ld a, e            ; Load low byte of heap end address 
907e			    cp (hl)            ; Compare with low byte of current address 
907e			    jr nz, malloc_search_loop  ; If not equal, continue searching 
907e			    ld a, d            ; Load high byte of heap end address 
907e			;    cp 0               ; Check if it's zero (end of memory) 
907e				or a 
907e			    jr nz, malloc_search_loop  ; If not zero, continue searching 
907e			 
907e			    ; If we reached here, allocation failed 
907e			    xor a              ; Set result to NULL 
907e			if DEBUG_FORTH_MALLOC_HIGH 
907e						DMARK "ma6" 
907e			call malloc_guard_exit 
907e			call malloc_guard_zerolen 
907e			endif 
907e			    ret 
907e			malloc_exit: 
907e			if DEBUG_FORTH_MALLOC_HIGH 
907e						DMARK "ma7" 
907e			call malloc_guard_exit 
907e			call malloc_guard_zerolen 
907e			endif 
907e			    ret 
907e			 
907e			; Internal Free Function: 
907e			; Input: 
907e			;   HL: Pointer to memory block to free 
907e			; Output: 
907e			;   None 
907e			 
907e			free_internal: 
907e			    ld de, (heap_start) ; Load start of heap into DE 
907e			    ld bc, 0            ; Initialize counter 
907e			 
907e			free_search_loop: 
907e			    ; Check if current block contains the pointer 
907e			    ld a, l             ; Load low byte of pointer 
907e			    cp (hl+1)           ; Compare with high byte of current block's address 
907e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
907e			    ld a, h             ; Load high byte of pointer 
907e			    cp (hl+2)           ; Compare with low byte of current block's address 
907e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
907e			 
907e			    ; Mark block as free 
907e			    ld (hl), 0          ; Set status byte to indicate free block 
907e			    ret                 ; Return 
907e			 
907e			free_skip_block_check: 
907e			    ; Move to the next block 
907e			    ld bc, 3            ; Size of management overhead 
907e			    add hl, bc          ; Move to the next block 
907e			    inc de              ; Increment counter 
907e			 
907e			    ; Check if we have reached the end of heap 
907e			    ld a, e             ; Load low byte of heap end address 
907e			    cp (hl)             ; Compare with low byte of current address 
907e			    jr nz, free_search_loop  ; If not equal, continue searching 
907e			    ld a, d             ; Load high byte of heap end address 
907e			;    cp 0                ; Check if it's zero (end of memory) 
907e				or a 
907e			    jr nz, free_search_loop  ; If not zero, continue searching 
907e			 
907e			    ; If we reached here, pointer is not found in heap 
907e			    ret 
907e			 
907e			free_exit: 
907e			    ret                 ; Return 
907e			 
907e			; Define heap start and end addresses 
907e			;heap_start:    .dw 0xC000   ; Start of heap 
907e			;heap_end:      .dw 0xE000   ; End of heap 
907e			 
907e			endif 
907e			 
907e			 
907e			if MALLOC_1 
907e			 
907e			 
907e			 
907e			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
907e			 
907e			;moved to firmware.asm 
907e			;heap_start        .equ  0x9000      ; Starting address of heap 
907e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
907e			 
907e			;      .org 0 
907e			;      jp    main 
907e			 
907e			 
907e			;      .org  0x100 
907e			;main: 
907e			;      ld    HL, 0x8100 
907e			;      ld    SP, HL 
907e			; 
907e			;      call  heap_init 
907e			; 
907e			;      ; Make some allocations 
907e			;      ld    HL, 12 
907e			;      call  malloc            ; Allocates 0x9004 
907e			; 
907e			;      ld    HL, 12 
907e			;      call  malloc            ; Allocates 0x9014 
907e			; 
907e			;      ld    HL, 12 
907e			;      call  malloc            ; Allocates 0x9024 
907e			; 
907e			;      ; Free some allocations 
907e			;      ld    HL, 0x9014 
907e			;      call  free 
907e			; 
907e			;      ld    HL, 0x9004 
907e			;      call  free 
907e			; 
907e			;      ld    HL, 0x9024 
907e			;      call  free 
907e			; 
907e			; 
907e			;      halt 
907e			 
907e			 
907e			;------------------------------------------------------------------------------ 
907e			;     heap_init                                                               : 
907e			;                                                                             : 
907e			; Description                                                                 : 
907e			;     Initialise the heap and make it ready for malloc and free operations.   : 
907e			;                                                                             : 
907e			;     The heap is maintained as a linked list, starting with an initial       : 
907e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
907e			;     the first free block in the heap. Each block then points to the next    : 
907e			;     free block within the heap, and the free list ends at the first block   : 
907e			;     with a null pointer to the next free block.                             : 
907e			;                                                                             : 
907e			; Parameters                                                                  : 
907e			;     Inputs are compile-time only. Two defines which specify the starting    : 
907e			;     address of the heap and its size are required, along with a memory      : 
907e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
907e			;     principally stores a pointer to the first free block in the heap.       : 
907e			;                                                                             : 
907e			; Returns                                                                     : 
907e			;     Nothing                                                                 : 
907e			;------------------------------------------------------------------------------ 
907e			heap_init: 
907e e5			      push  HL 
907f			 
907f			      ; Initialise free list struct 
907f 21 75 e4		      ld    HL, heap_start 
9082 22 70 e4		      ld    (free_list), HL 
9085 21 00 00		      ld    HL, 0 
9088 22 72 e4		      ld    (free_list+2), HL 
908b			 
908b			      ; Insert first free block at bottom of heap, consumes entire heap 
908b 21 8f e2		      ld    HL, heap_start+heap_size-4 
908e 22 75 e4		      ld    (heap_start), HL        ; Next block (end of free list) 
9091 21 1a fe		      ld    HL, heap_size-4 
9094 22 77 e4		      ld    (heap_start+2), HL      ; Block size 
9097			 
9097			      ; Insert end of free list block at top of heap - two null words will 
9097			      ; terminate the free list 
9097 21 00 00		      ld    HL, 0 
909a 22 91 e2		      ld    (heap_start+heap_size-2), HL 
909d 22 8f e2		      ld    (heap_start+heap_size-4), HL 
90a0			 
90a0 e1			      pop   HL 
90a1			 
90a1 c9			      ret 
90a2			 
90a2			 
90a2			;------------------------------------------------------------------------------ 
90a2			;     malloc                                                                  : 
90a2			;                                                                             : 
90a2			; Description                                                                 : 
90a2			;     Allocates the wanted space from the heap and returns the address of the : 
90a2			;     first useable byte of the allocation.                                   : 
90a2			;                                                                             : 
90a2			;     Allocations can happen in one of two ways:                              : 
90a2			;                                                                             : 
90a2			;     1. A free block may be found which is the exact size wanted. In this    : 
90a2			;        case the block is removed from the free list and retuedn to the      : 
90a2			;        caller.                                                              : 
90a2			;     2. A free block may be found which is larger than the size wanted. In   : 
90a2			;        this case, the larger block is split into two. The first portion of  : 
90a2			;        this block will become the requested space by the malloc call and    : 
90a2			;        is returned to the caller. The second portion becomes a new free     : 
90a2			;        block, and the free list is adjusted to maintain continuity via this : 
90a2			;        newly created block.                                                 : 
90a2			;                                                                             : 
90a2			;     malloc does not set any initial value in the allocated space, the       : 
90a2			;     caller is required to do this as required.                              : 
90a2			;                                                                             : 
90a2			;     This implementation of malloc uses the stack exclusively, and is        : 
90a2			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90a2			;     advisable to disable interrupts before calling malloc, and recommended  : 
90a2			;     to avoid the use of malloc inside ISRs in general.                      : 
90a2			;                                                                             : 
90a2			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90a2			;                                                                             : 
90a2			; Parameters                                                                  : 
90a2			;     HL  Number of bytes wanted                                              : 
90a2			;                                                                             : 
90a2			; Returns                                                                     : 
90a2			;     HL  Address of the first useable byte of the allocation                 : 
90a2			;                                                                             : 
90a2			; Flags                                                                       : 
90a2			;     Z   Set if the allocation did not succeed, clear otherwise              : 
90a2			;                                                                             : 
90a2			; Stack frame                                                                 : 
90a2			;       |             |                                                       : 
90a2			;       +-------------+                                                       : 
90a2			;       |     BC      |                                                       : 
90a2			;       +-------------+                                                       : 
90a2			;       |     DE      |                                                       : 
90a2			;       +-------------+                                                       : 
90a2			;       |     IX      |                                                       : 
90a2			;       +-------------+                                                       : 
90a2			;       |  prev_free  |                                                       : 
90a2			;   +4  +-------------+                                                       : 
90a2			;       |  this_free  |                                                       : 
90a2			;   +2  +-------------+                                                       : 
90a2			;       |  next_free  |                                                       : 
90a2			;   +0  +-------------+                                                       : 
90a2			;       |             |                                                       : 
90a2			;                                                                             : 
90a2			;------------------------------------------------------------------------------ 
90a2			 
90a2			 
90a2			;malloc: 
90a2			; 
90a2			;	SAVESP ON 1 
90a2			; 
90a2			;	call malloc_code 
90a2			; 
90a2			;	CHECKSP ON 1 
90a2			;	ret 
90a2			 
90a2			 
90a2			malloc: 
90a2 c5			      push  BC 
90a3 d5			      push  DE 
90a4 dd e5		      push  IX 
90a6			if DEBUG_FORTH_MALLOC_HIGH 
90a6			call malloc_guard_entry 
90a6			endif 
90a6			 
90a6					if DEBUG_FORTH_MALLOC 
90a6						DMARK "mal" 
90a6						CALLMONITOR 
90a6					endif 
90a6 7c			      ld    A, H                    ; Exit if no space requested 
90a7 b5			      or    L 
90a8 ca 67 91		      jp    Z, malloc_early_exit 
90ab			 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			; 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			 
90ab			 
90ab			 
90ab			 
90ab					if DEBUG_FORTH_MALLOC 
90ab						DMARK "maA" 
90ab						CALLMONITOR 
90ab					endif 
90ab			      ; Set up stack frame 
90ab eb			      ex    DE, HL 
90ac 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
90af 39			      add   HL, SP 
90b0 f9			      ld    SP, HL 
90b1 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
90b5 dd 39		      add   IX, SP 
90b7			 
90b7			      ; Setup initial state 
90b7 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
90ba 19			      add   HL, DE 
90bb			 
90bb 44			      ld    B, H                    ; Move want to BC 
90bc 4d			      ld    C, L 
90bd			 
90bd 21 70 e4		      ld    HL, free_list           ; Store prev_free ptr to stack 
90c0 dd 75 04		      ld    (IX+4), L 
90c3 dd 74 05		      ld    (IX+5), H 
90c6			 
90c6 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
90c7 23			      inc   HL 
90c8 56			      ld    D, (HL) 
90c9 dd 73 02		      ld    (IX+2), E 
90cc dd 72 03		      ld    (IX+3), D 
90cf eb			      ex    DE, HL                  ; this_free ptr into HL 
90d0			 
90d0					if DEBUG_FORTH_MALLOC 
90d0						DMARK "maB" 
90d0						CALLMONITOR 
90d0					endif 
90d0			      ; Loop through free block list to find some space 
90d0			malloc_find_space: 
90d0 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
90d1 23			      inc   HL 
90d2 56			      ld    D, (HL) 
90d3			 
90d3 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
90d4 b3			      or    E 
90d5 ca 61 91		      jp    Z, malloc_no_space 
90d8			 
90d8 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
90db dd 72 01		      ld    (IX+1), D 
90de			 
90de			      ; Does this block have enough space to make the allocation? 
90de 23			      inc   HL                      ; Load free block size into DE 
90df 5e			      ld    E, (HL) 
90e0 23			      inc   HL 
90e1 56			      ld    D, (HL) 
90e2			 
90e2 eb			      ex    DE, HL                  ; Check size of block against want 
90e3 b7			      or    A                       ; Ensure carry flag clear 
90e4 ed 42		      sbc   HL, BC 
90e6 e5			      push  HL                      ; Store the result for later (new block size) 
90e7			 
90e7 ca 36 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
90ea 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
90ec			 
90ec			      ; this_free block is not big enough, setup ptrs to test next free block 
90ec e1			      pop   HL                      ; Discard previous result 
90ed			 
90ed dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
90f0 dd 66 03		      ld    H, (IX+3) 
90f3 dd 75 04		      ld    (IX+4), L 
90f6 dd 74 05		      ld    (IX+5), H 
90f9			 
90f9 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
90fc dd 66 01		      ld    H, (IX+1) 
90ff dd 75 02		      ld    (IX+2), L 
9102 dd 74 03		      ld    (IX+3), H 
9105			 
9105					if DEBUG_FORTH_MALLOC 
9105						DMARK "MA>" 
9105						CALLMONITOR 
9105					endif 
9105 18 c9		      jr    malloc_find_space 
9107			 
9107			      ; split a bigger block into two - requested size and remaining size 
9107			malloc_alloc_split: 
9107					if DEBUG_FORTH_MALLOC 
9107						DMARK "MAs" 
9107						CALLMONITOR 
9107					endif 
9107 eb			      ex    DE, HL                  ; Calculate address of new free block 
9108 2b			      dec   HL 
9109 2b			      dec   HL 
910a 2b			      dec   HL 
910b 09			      add   HL, BC 
910c			 
910c			      ; Create a new block and point it at next_free 
910c dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
910f dd 56 01		      ld    D, (IX+1) 
9112			 
9112 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9113 23			      inc   HL 
9114 72			      ld    (HL), D 
9115			 
9115 d1			      pop   DE                      ; Store size of new block into new block 
9116 23			      inc   HL 
9117 73			      ld    (HL), E 
9118 23			      inc   HL 
9119 72			      ld    (HL), D 
911a			 
911a			      ; Update this_free ptr to point to new block 
911a 2b			      dec   HL 
911b 2b			      dec   HL 
911c 2b			      dec   HL 
911d			 
911d dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9120 dd 56 03		      ld    D, (IX+3) 
9123			 
9123 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9126 dd 74 03		      ld    (IX+3), H 
9129			 
9129			      ; Modify this_free block to be allocation 
9129 eb			      ex    DE, HL 
912a af			      xor   A                       ; Null the next block ptr of allocated block 
912b 77			      ld    (HL), A 
912c 23			      inc   HL 
912d 77			      ld    (HL), A 
912e			 
912e 23			      inc   HL                      ; Store want size into allocated block 
912f 71			      ld    (HL), C 
9130 23			      inc   HL 
9131 70			      ld    (HL), B 
9132 23			      inc   HL 
9133 e5			      push  HL                      ; Address of allocation to return 
9134			 
9134 18 19		      jr    malloc_update_links 
9136			 
9136			malloc_alloc_fit: 
9136 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9137			 
9137					if DEBUG_FORTH_MALLOC 
9137						DMARK "MAf" 
9137						CALLMONITOR 
9137					endif 
9137			      ; Modify this_free block to be allocation 
9137 eb			      ex    DE, HL 
9138 2b			      dec   HL 
9139 2b			      dec   HL 
913a 2b			      dec   HL 
913b			 
913b af			      xor   A                       ; Null the next block ptr of allocated block 
913c 77			      ld    (HL), A 
913d 23			      inc   HL 
913e 77			      ld    (HL), A 
913f			 
913f 23			      inc   HL                      ; Store address of allocation to return 
9140 23			      inc   HL 
9141 23			      inc   HL 
9142 e5			      push  HL 
9143			 
9143			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9143 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9146 dd 66 01		      ld    H, (IX+1) 
9149			 
9149 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
914c dd 74 03		      ld    (IX+3), H 
914f			 
914f			 
914f			malloc_update_links: 
914f			      ; Update prev_free ptr to point to this_free 
914f dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9152 dd 66 05		      ld    H, (IX+5) 
9155			 
9155 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9158 dd 56 03		      ld    D, (IX+3) 
915b			 
915b 73			      ld    (HL), E                 ; this_free ptr into prev_free 
915c 23			      inc   HL 
915d 72			      ld    (HL), D 
915e			 
915e					if DEBUG_FORTH_MALLOC 
915e						DMARK "Mul" 
915e						CALLMONITOR 
915e					endif 
915e			      ; Clear the Z flag to indicate successful allocation 
915e 7a			      ld    A, D 
915f b3			      or    E 
9160			 
9160 d1			      pop   DE                      ; Address of allocation 
9161					if DEBUG_FORTH_MALLOC 
9161						DMARK "MAu" 
9161						CALLMONITOR 
9161					endif 
9161			 
9161			malloc_no_space: 
9161 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9164 39			      add   HL, SP 
9165 f9			      ld    SP, HL 
9166			 
9166 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9167					if DEBUG_FORTH_MALLOC 
9167						DMARK "MAN" 
9167						CALLMONITOR 
9167					endif 
9167			 
9167			malloc_early_exit: 
9167					if DEBUG_FORTH_MALLOC 
9167						DMARK "MAx" 
9167						CALLMONITOR 
9167					endif 
9167 dd e1		      pop   IX 
9169 d1			      pop   DE 
916a c1			      pop   BC 
916b			 
916b			if DEBUG_FORTH_MALLOC_HIGH 
916b			call malloc_guard_exit 
916b			call malloc_guard_zerolen 
916b			endif 
916b c9			      ret 
916c			 
916c			 
916c			;------------------------------------------------------------------------------ 
916c			;     free                                                                    : 
916c			;                                                                             : 
916c			; Description                                                                 : 
916c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
916c			;     returned by malloc, otherwise the behaviour is undefined.               : 
916c			;                                                                             : 
916c			;     Where possible, directly adjacent free blocks will be merged together   : 
916c			;     into larger blocks to help ensure that the heap does not become         : 
916c			;     excessively fragmented.                                                 : 
916c			;                                                                             : 
916c			;     free does not clear or set any other value into the freed space, and    : 
916c			;     therefore its contents may be visible through subsequent malloc's. The  : 
916c			;     caller should clear the freed space as required.                        : 
916c			;                                                                             : 
916c			;     This implementation of free uses the stack exclusively, and is          : 
916c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
916c			;     advisable to disable interrupts before calling free, and recommended    : 
916c			;     to avoid the use of free inside ISRs in general.                        : 
916c			;                                                                             : 
916c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
916c			;                                                                             : 
916c			; Parameters                                                                  : 
916c			;     HL  Pointer to address of first byte of allocation to be freed          : 
916c			;                                                                             : 
916c			; Returns                                                                     : 
916c			;     Nothing                                                                 : 
916c			;                                                                             : 
916c			; Stack frame                                                                 : 
916c			;       |             |                                                       : 
916c			;       +-------------+                                                       : 
916c			;       |     BC      |                                                       : 
916c			;       +-------------+                                                       : 
916c			;       |     DE      |                                                       : 
916c			;       +-------------+                                                       : 
916c			;       |     IX      |                                                       : 
916c			;       +-------------+                                                       : 
916c			;       |  prev_free  |                                                       : 
916c			;   +2  +-------------+                                                       : 
916c			;       |  next_free  |                                                       : 
916c			;   +0  +-------------+                                                       : 
916c			;       |             |                                                       : 
916c			;                                                                             : 
916c			;------------------------------------------------------------------------------ 
916c			free: 
916c c5			      push  BC 
916d d5			      push  DE 
916e dd e5		      push  IX 
9170			 
9170 7c			      ld    A, H                    ; Exit if ptr is null 
9171 b5			      or    L 
9172 ca 36 92		      jp    Z, free_early_exit 
9175			 
9175			      ; Set up stack frame 
9175 eb			      ex    DE, HL 
9176 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9179 39			      add   HL, SP 
917a f9			      ld    SP, HL 
917b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
917f dd 39		      add   IX, SP 
9181			 
9181			      ; The address in HL points to the start of the useable allocated space, 
9181			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9181			      ; address of the block itself. 
9181 eb			      ex    DE, HL 
9182 11 fc ff		      ld    DE, -4 
9185 19			      add   HL, DE 
9186			 
9186			      ; An allocated block must have a null next block pointer in it 
9186 7e			      ld    A, (HL) 
9187 23			      inc   HL 
9188 b6			      or    (HL) 
9189 c2 31 92		      jp    NZ, free_done 
918c			 
918c 2b			      dec   HL 
918d			 
918d 44			      ld    B, H                    ; Copy HL to BC 
918e 4d			      ld    C, L 
918f			 
918f			      ; Loop through the free list to find the first block with an address 
918f			      ; higher than the block being freed 
918f 21 70 e4		      ld    HL, free_list 
9192			 
9192			free_find_higher_block: 
9192 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9193 23			      inc   HL 
9194 56			      ld    D, (HL) 
9195 2b			      dec   HL 
9196			 
9196 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9199 dd 72 01		      ld    (IX+1), D 
919c dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
919f dd 74 03		      ld    (IX+3), H 
91a2			 
91a2 78			      ld    A, B                    ; Check if DE is greater than BC 
91a3 ba			      cp    D                       ; Compare MSB first 
91a4 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
91a6 30 04		      jr    NC, free_find_higher_block_skip 
91a8 79			      ld    A, C 
91a9 bb			      cp    E                       ; Then compare LSB 
91aa 38 08		      jr    C, free_found_higher_block 
91ac			 
91ac			free_find_higher_block_skip: 
91ac 7a			      ld    A, D                    ; Reached the end of the free list? 
91ad b3			      or    E 
91ae ca 31 92		      jp    Z, free_done 
91b1			 
91b1 eb			      ex    DE, HL 
91b2			 
91b2 18 de		      jr    free_find_higher_block 
91b4			 
91b4			free_found_higher_block: 
91b4			      ; Insert freed block between prev and next free blocks 
91b4 71			      ld    (HL), C                 ; Point prev free block to freed block 
91b5 23			      inc   HL 
91b6 70			      ld    (HL), B 
91b7			 
91b7 60			      ld    H, B                    ; Point freed block at next free block 
91b8 69			      ld    L, C 
91b9 73			      ld    (HL), E 
91ba 23			      inc   HL 
91bb 72			      ld    (HL), D 
91bc			 
91bc			      ; Check if the freed block is adjacent to the next free block 
91bc 23			      inc   HL                      ; Load size of freed block into HL 
91bd 5e			      ld    E, (HL) 
91be 23			      inc   HL 
91bf 56			      ld    D, (HL) 
91c0 eb			      ex    DE, HL 
91c1			 
91c1 09			      add   HL, BC                  ; Add addr of freed block and its size 
91c2			 
91c2 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
91c5 dd 56 01		      ld    D, (IX+1) 
91c8			 
91c8 b7			      or    A                       ; Clear the carry flag 
91c9 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
91cb 20 22		      jr    NZ, free_check_adjacent_to_prev 
91cd			 
91cd			      ; Freed block is adjacent to next, merge into one bigger block 
91cd eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
91ce 5e			      ld    E, (HL) 
91cf 23			      inc   HL 
91d0 56			      ld    D, (HL) 
91d1 e5			      push  HL                      ; Save ptr to next block for later 
91d2			 
91d2 60			      ld    H, B                    ; Store ptr from next block into freed block 
91d3 69			      ld    L, C 
91d4 73			      ld    (HL), E 
91d5 23			      inc   HL 
91d6 72			      ld    (HL), D 
91d7			 
91d7 e1			      pop   HL                      ; Restore ptr to next block 
91d8 23			      inc   HL                      ; Load size of next block into DE 
91d9 5e			      ld    E, (HL) 
91da 23			      inc   HL 
91db 56			      ld    D, (HL) 
91dc d5			      push  DE                      ; Save next block size for later 
91dd			 
91dd 60			      ld    H, B                    ; Load size of freed block into HL 
91de 69			      ld    L, C 
91df 23			      inc   HL 
91e0 23			      inc   HL 
91e1 5e			      ld    E, (HL) 
91e2 23			      inc   HL 
91e3 56			      ld    D, (HL) 
91e4 eb			      ex    DE, HL 
91e5			 
91e5 d1			      pop   DE                      ; Restore size of next block 
91e6 19			      add   HL, DE                  ; Add sizes of both blocks 
91e7 eb			      ex    DE, HL 
91e8			 
91e8 60			      ld    H, B                    ; Store new bigger size into freed block 
91e9 69			      ld    L, C 
91ea 23			      inc   HL 
91eb 23			      inc   HL 
91ec 73			      ld    (HL), E 
91ed 23			      inc   HL 
91ee 72			      ld    (HL), D 
91ef			 
91ef			free_check_adjacent_to_prev: 
91ef			      ; Check if the freed block is adjacent to the prev free block 
91ef dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
91f2 dd 66 03		      ld    H, (IX+3) 
91f5			 
91f5 23			      inc   HL                      ; Size of prev free block into DE 
91f6 23			      inc   HL 
91f7 5e			      ld    E, (HL) 
91f8 23			      inc   HL 
91f9 56			      ld    D, (HL) 
91fa 2b			      dec   HL 
91fb 2b			      dec   HL 
91fc 2b			      dec   HL 
91fd			 
91fd 19			      add   HL, DE                  ; Add prev block addr and size 
91fe			 
91fe b7			      or    A                       ; Clear the carry flag 
91ff ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9201 20 2e		      jr    NZ, free_done 
9203			 
9203			      ; Freed block is adjacent to prev, merge into one bigger block 
9203 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9204 69			      ld    L, C 
9205 5e			      ld    E, (HL) 
9206 23			      inc   HL 
9207 56			      ld    D, (HL) 
9208 e5			      push  HL                      ; Save freed block ptr for later 
9209			 
9209 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
920c dd 66 03		      ld    H, (IX+3) 
920f 73			      ld    (HL), E 
9210 23			      inc   HL 
9211 72			      ld    (HL), D 
9212			 
9212 e1			      pop   HL                      ; Restore freed block ptr 
9213 23			      inc   HL                      ; Load size of freed block into DE 
9214 5e			      ld    E, (HL) 
9215 23			      inc   HL 
9216 56			      ld    D, (HL) 
9217 d5			      push  DE                      ; Save freed block size for later 
9218			 
9218 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
921b dd 66 03		      ld    H, (IX+3) 
921e 23			      inc   HL 
921f 23			      inc   HL 
9220 5e			      ld    E, (HL) 
9221 23			      inc   HL 
9222 56			      ld    D, (HL) 
9223			 
9223 e1			      pop   HL                      ; Add sizes of both blocks 
9224 19			      add   HL, DE 
9225 eb			      ex    DE, HL 
9226			 
9226 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
9229 dd 66 03		      ld    H, (IX+3) 
922c 23			      inc   HL 
922d 23			      inc   HL 
922e 73			      ld    (HL), E 
922f 23			      inc   HL 
9230 72			      ld    (HL), D 
9231			 
9231			free_done: 
9231 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9234 39			      add   HL, SP 
9235 f9			      ld    SP, HL 
9236			 
9236			free_early_exit: 
9236 dd e1		      pop   IX 
9238 d1			      pop   DE 
9239 c1			      pop   BC 
923a			 
923a c9			      ret 
923b			 
923b			; moved to firmware.asm 
923b			; 
923b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
923b			;                  .dw   0 
923b			 
923b			 
923b			endif 
923b			 
923b			 
923b			if MALLOC_3 
923b			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
923b			;heap_start        .equ  0x9000      ; Starting address of heap 
923b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
923b			; 
923b			 ;     .org 0 
923b			  ;    jp    main 
923b			; 
923b			; 
923b			 ;     .org  0x100 
923b			;main: 
923b			 ;     ld    HL, 0x8100 
923b			  ;    ld    SP, HL 
923b			; 
923b			;      call  heap_init 
923b			 
923b			      ; Make some allocations 
923b			;      ld    HL, 12 
923b			;      call  malloc            ; Allocates 0x9004 
923b			; 
923b			 ;     ld    HL, 12 
923b			;      call  malloc            ; Allocates 0x9014 
923b			 
923b			;      ld    HL, 12 
923b			;      call  malloc            ; Allocates 0x9024 
923b			 
923b			      ; Free some allocations 
923b			;      ld    HL, 0x9014 
923b			;      call  free 
923b			 
923b			;      ld    HL, 0x9004 
923b			;      call  free 
923b			; 
923b			;      ld    HL, 0x9024 
923b			;      call  free 
923b			 
923b			 
923b			 ;     halt 
923b			 
923b			 
923b			;------------------------------------------------------------------------------ 
923b			;     heap_init                                                               : 
923b			;                                                                             : 
923b			; Description                                                                 : 
923b			;     Initialise the heap and make it ready for malloc and free operations.   : 
923b			;                                                                             : 
923b			;     The heap is maintained as a linked list, starting with an initial       : 
923b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
923b			;     the first free block in the heap. Each block then points to the next    : 
923b			;     free block within the heap, and the free list ends at the first block   : 
923b			;     with a null pointer to the next free block.                             : 
923b			;                                                                             : 
923b			; Parameters                                                                  : 
923b			;     Inputs are compile-time only. Two defines which specify the starting    : 
923b			;     address of the heap and its size are required, along with a memory      : 
923b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
923b			;     principally stores a pointer to the first free block in the heap.       : 
923b			;                                                                             : 
923b			; Returns                                                                     : 
923b			;     Nothing                                                                 : 
923b			;------------------------------------------------------------------------------ 
923b			heap_init: 
923b			      push  HL 
923b			 
923b			      ; Initialise free list struct 
923b			      ld    HL, heap_start 
923b			      ld    (free_list), HL 
923b			      ld    HL, 0 
923b			      ld    (free_list+2), HL 
923b			 
923b			      ; Insert first free block at bottom of heap, consumes entire heap 
923b			      ld    HL, heap_start+heap_size-4 
923b			      ld    (heap_start), HL        ; Next block (end of free list) 
923b			      ld    HL, heap_size-4 
923b			      ld    (heap_start+2), HL      ; Block size 
923b			 
923b			      ; Insert end of free list block at top of heap - two null words will 
923b			      ; terminate the free list 
923b			      ld    HL, 0 
923b			      ld    (heap_start+heap_size-2), HL 
923b			      ld    (heap_start+heap_size-4), HL 
923b			 
923b			      pop   HL 
923b			 
923b			      ret 
923b			 
923b			 
923b			;------------------------------------------------------------------------------ 
923b			;     malloc                                                                  : 
923b			;                                                                             : 
923b			; Description                                                                 : 
923b			;     Allocates the wanted space from the heap and returns the address of the : 
923b			;     first useable byte of the allocation.                                   : 
923b			;                                                                             : 
923b			;     Allocations can happen in one of two ways:                              : 
923b			;                                                                             : 
923b			;     1. A free block may be found which is the exact size wanted. In this    : 
923b			;        case the block is removed from the free list and retuedn to the      : 
923b			;        caller.                                                              : 
923b			;     2. A free block may be found which is larger than the size wanted. In   : 
923b			;        this case, the larger block is split into two. The first portion of  : 
923b			;        this block will become the requested space by the malloc call and    : 
923b			;        is returned to the caller. The second portion becomes a new free     : 
923b			;        block, and the free list is adjusted to maintain continuity via this : 
923b			;        newly created block.                                                 : 
923b			;                                                                             : 
923b			;     malloc does not set any initial value in the allocated space, the       : 
923b			;     caller is required to do this as required.                              : 
923b			;                                                                             : 
923b			;     This implementation of malloc uses the stack exclusively, and is        : 
923b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
923b			;     advisable to disable interrupts before calling malloc, and recommended  : 
923b			;     to avoid the use of malloc inside ISRs in general.                      : 
923b			;                                                                             : 
923b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
923b			;                                                                             : 
923b			; Parameters                                                                  : 
923b			;     HL  Number of bytes wanted                                              : 
923b			;                                                                             : 
923b			; Returns                                                                     : 
923b			;     HL  Address of the first useable byte of the allocation                 : 
923b			;                                                                             : 
923b			; Flags                                                                       : 
923b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
923b			;                                                                             : 
923b			; Stack frame                                                                 : 
923b			;       |             |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |     BC      |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |     DE      |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |     IX      |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |  prev_free  |                                                       : 
923b			;   +4  +-------------+                                                       : 
923b			;       |  this_free  |                                                       : 
923b			;   +2  +-------------+                                                       : 
923b			;       |  next_free  |                                                       : 
923b			;   +0  +-------------+                                                       : 
923b			;       |             |                                                       : 
923b			;                                                                             : 
923b			;------------------------------------------------------------------------------ 
923b			malloc: 
923b			      push  BC 
923b			      push  DE 
923b			      push  IX 
923b			 
923b			      ld    A, H                    ; Exit if no space requested 
923b			      or    L 
923b			      jp    Z, malloc_early_exit 
923b			 
923b			      ; Set up stack frame 
923b			      ex    DE, HL 
923b			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
923b			      add   HL, SP 
923b			      ld    SP, HL 
923b			      ld    IX, 0                   ; Use IX as a frame pointer 
923b			      add   IX, SP 
923b			 
923b			      ; Setup initial state 
923b			      ld    HL, 4                   ; want must also include space used by block struct 
923b			      add   HL, DE 
923b			 
923b			      ld    B, H                    ; Move want to BC 
923b			      ld    C, L 
923b			 
923b			      ld    HL, free_list           ; Store prev_free ptr to stack 
923b			      ld    (IX+4), L 
923b			      ld    (IX+5), H 
923b			 
923b			      ld    E, (HL)                 ; Store this_free ptr to stack 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      ld    (IX+2), E 
923b			      ld    (IX+3), D 
923b			      ex    DE, HL                  ; this_free ptr into HL 
923b			 
923b			      ; Loop through free block list to find some space 
923b			malloc_find_space: 
923b			      ld    E, (HL)                 ; Load next_free ptr into DE 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			 
923b			      ld    A, D                    ; Check for null next_free ptr - end of free list 
923b			      or    E 
923b			      jp    Z, malloc_no_space 
923b			 
923b			      ld    (IX+0), E               ; Store next_free ptr to stack 
923b			      ld    (IX+1), D 
923b			 
923b			      ; Does this block have enough space to make the allocation? 
923b			      inc   HL                      ; Load free block size into DE 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			 
923b			      ex    DE, HL                  ; Check size of block against want 
923b			      or    A                       ; Ensure carry flag clear 
923b			      sbc   HL, BC 
923b			      push  HL                      ; Store the result for later (new block size) 
923b			 
923b			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
923b			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
923b			 
923b			      ; this_free block is not big enough, setup ptrs to test next free block 
923b			      pop   HL                      ; Discard previous result 
923b			 
923b			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
923b			      ld    H, (IX+3) 
923b			      ld    (IX+4), L 
923b			      ld    (IX+5), H 
923b			 
923b			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
923b			      ld    H, (IX+1) 
923b			      ld    (IX+2), L 
923b			      ld    (IX+3), H 
923b			 
923b			      jr    malloc_find_space 
923b			 
923b			      ; split a bigger block into two - requested size and remaining size 
923b			malloc_alloc_split: 
923b			      ex    DE, HL                  ; Calculate address of new free block 
923b			      dec   HL 
923b			      dec   HL 
923b			      dec   HL 
923b			      add   HL, BC 
923b			 
923b			      ; Create a new block and point it at next_free 
923b			      ld    E, (IX+0)               ; Load next_free ptr into DE 
923b			      ld    D, (IX+1) 
923b			 
923b			      ld    (HL), E                 ; Store next_free ptr into new block 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			      pop   DE                      ; Store size of new block into new block 
923b			      inc   HL 
923b			      ld    (HL), E 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			      ; Update this_free ptr to point to new block 
923b			      dec   HL 
923b			      dec   HL 
923b			      dec   HL 
923b			 
923b			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
923b			      ld    D, (IX+3) 
923b			 
923b			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
923b			      ld    (IX+3), H 
923b			 
923b			      ; Modify this_free block to be allocation 
923b			      ex    DE, HL 
923b			      xor   A                       ; Null the next block ptr of allocated block 
923b			      ld    (HL), A 
923b			      inc   HL 
923b			      ld    (HL), A 
923b			 
923b			      inc   HL                      ; Store want size into allocated block 
923b			      ld    (HL), C 
923b			      inc   HL 
923b			      ld    (HL), B 
923b			      inc   HL 
923b			      push  HL                      ; Address of allocation to return 
923b			 
923b			      jr    malloc_update_links 
923b			 
923b			malloc_alloc_fit: 
923b			      pop   HL                      ; Dont need new block size, want is exact fit 
923b			 
923b			      ; Modify this_free block to be allocation 
923b			      ex    DE, HL 
923b			      dec   HL 
923b			      dec   HL 
923b			      dec   HL 
923b			 
923b			      xor   A                       ; Null the next block ptr of allocated block 
923b			      ld    (HL), A 
923b			      inc   HL 
923b			      ld    (HL), A 
923b			 
923b			      inc   HL                      ; Store address of allocation to return 
923b			      inc   HL 
923b			      inc   HL 
923b			      push  HL 
923b			 
923b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
923b			      ld    L, (IX+0)               ; next_free to HL 
923b			      ld    H, (IX+1) 
923b			 
923b			      ld    (IX+2), L               ; HL to this_free 
923b			      ld    (IX+3), H 
923b			 
923b			 
923b			malloc_update_links: 
923b			      ; Update prev_free ptr to point to this_free 
923b			      ld    L, (IX+4)               ; prev_free ptr to HL 
923b			      ld    H, (IX+5) 
923b			 
923b			      ld    E, (IX+2)               ; this_free ptr to DE 
923b			      ld    D, (IX+3) 
923b			 
923b			      ld    (HL), E                 ; this_free ptr into prev_free 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			      ; Clear the Z flag to indicate successful allocation 
923b			      ld    A, D 
923b			      or    E 
923b			 
923b			      pop   DE                      ; Address of allocation 
923b			 
923b			malloc_no_space: 
923b			      ld    HL, 6                   ; Clean up stack frame 
923b			      add   HL, SP 
923b			      ld    SP, HL 
923b			 
923b			      ex    DE, HL                  ; Alloc addr into HL for return 
923b			 
923b			malloc_early_exit: 
923b			      pop   IX 
923b			      pop   DE 
923b			      pop   BC 
923b			 
923b			      ret 
923b			 
923b			 
923b			;------------------------------------------------------------------------------ 
923b			;     free                                                                    : 
923b			;                                                                             : 
923b			; Description                                                                 : 
923b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
923b			;     returned by malloc, otherwise the behaviour is undefined.               : 
923b			;                                                                             : 
923b			;     Where possible, directly adjacent free blocks will be merged together   : 
923b			;     into larger blocks to help ensure that the heap does not become         : 
923b			;     excessively fragmented.                                                 : 
923b			;                                                                             : 
923b			;     free does not clear or set any other value into the freed space, and    : 
923b			;     therefore its contents may be visible through subsequent malloc's. The  : 
923b			;     caller should clear the freed space as required.                        : 
923b			;                                                                             : 
923b			;     This implementation of free uses the stack exclusively, and is          : 
923b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
923b			;     advisable to disable interrupts before calling free, and recommended    : 
923b			;     to avoid the use of free inside ISRs in general.                        : 
923b			;                                                                             : 
923b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
923b			;                                                                             : 
923b			; Parameters                                                                  : 
923b			;     HL  Pointer to address of first byte of allocation to be freed          : 
923b			;                                                                             : 
923b			; Returns                                                                     : 
923b			;     Nothing                                                                 : 
923b			;                                                                             : 
923b			; Stack frame                                                                 : 
923b			;       |             |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |     BC      |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |     DE      |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |     IX      |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |  prev_free  |                                                       : 
923b			;   +2  +-------------+                                                       : 
923b			;       |  next_free  |                                                       : 
923b			;   +0  +-------------+                                                       : 
923b			;       |             |                                                       : 
923b			;                                                                             : 
923b			;------------------------------------------------------------------------------ 
923b			free: 
923b			      push  BC 
923b			      push  DE 
923b			      push  IX 
923b			 
923b			      ld    A, H                    ; Exit if ptr is null 
923b			      or    L 
923b			      jp    Z, free_early_exit 
923b			 
923b			      ; Set up stack frame 
923b			      ex    DE, HL 
923b			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
923b			      add   HL, SP 
923b			      ld    SP, HL 
923b			      ld    IX, 0                   ; Use IX as a frame pointer 
923b			      add   IX, SP 
923b			 
923b			      ; The address in HL points to the start of the useable allocated space, 
923b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
923b			      ; address of the block itself. 
923b			      ex    DE, HL 
923b			      ld    DE, -4 
923b			      add   HL, DE 
923b			 
923b			      ; An allocated block must have a null next block pointer in it 
923b			      ld    A, (HL) 
923b			      inc   HL 
923b			      or    (HL) 
923b			      jp    NZ, free_done 
923b			 
923b			      dec   HL 
923b			 
923b			      ld    B, H                    ; Copy HL to BC 
923b			      ld    C, L 
923b			 
923b			      ; Loop through the free list to find the first block with an address 
923b			      ; higher than the block being freed 
923b			      ld    HL, free_list 
923b			 
923b			free_find_higher_block: 
923b			      ld    E, (HL)                 ; Load next ptr from free block 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      dec   HL 
923b			 
923b			      ld    (IX+0), E               ; Save ptr to next free block 
923b			      ld    (IX+1), D 
923b			      ld    (IX+2), L               ; Save ptr to prev free block 
923b			      ld    (IX+3), H 
923b			 
923b			      ld    A, B                    ; Check if DE is greater than BC 
923b			      cp    D                       ; Compare MSB first 
923b			      jr    Z, $+4                  ; MSB the same, compare LSB 
923b			      jr    NC, free_find_higher_block_skip 
923b			      ld    A, C 
923b			      cp    E                       ; Then compare LSB 
923b			      jr    C, free_found_higher_block 
923b			 
923b			free_find_higher_block_skip: 
923b			      ld    A, D                    ; Reached the end of the free list? 
923b			      or    E 
923b			      jp    Z, free_done 
923b			 
923b			      ex    DE, HL 
923b			 
923b			      jr    free_find_higher_block 
923b			 
923b			free_found_higher_block: 
923b			      ; Insert freed block between prev and next free blocks 
923b			      ld    (HL), C                 ; Point prev free block to freed block 
923b			      inc   HL 
923b			      ld    (HL), B 
923b			 
923b			      ld    H, B                    ; Point freed block at next free block 
923b			      ld    L, C 
923b			      ld    (HL), E 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			      ; Check if the freed block is adjacent to the next free block 
923b			      inc   HL                      ; Load size of freed block into HL 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      ex    DE, HL 
923b			 
923b			      add   HL, BC                  ; Add addr of freed block and its size 
923b			 
923b			      ld    E, (IX+0)               ; Load addr of next free block into DE 
923b			      ld    D, (IX+1) 
923b			 
923b			      or    A                       ; Clear the carry flag 
923b			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
923b			      jr    NZ, free_check_adjacent_to_prev 
923b			 
923b			      ; Freed block is adjacent to next, merge into one bigger block 
923b			      ex    DE, HL                  ; Load next ptr from next block into DE 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      push  HL                      ; Save ptr to next block for later 
923b			 
923b			      ld    H, B                    ; Store ptr from next block into freed block 
923b			      ld    L, C 
923b			      ld    (HL), E 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			      pop   HL                      ; Restore ptr to next block 
923b			      inc   HL                      ; Load size of next block into DE 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      push  DE                      ; Save next block size for later 
923b			 
923b			      ld    H, B                    ; Load size of freed block into HL 
923b			      ld    L, C 
923b			      inc   HL 
923b			      inc   HL 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      ex    DE, HL 
923b			 
923b			      pop   DE                      ; Restore size of next block 
923b			      add   HL, DE                  ; Add sizes of both blocks 
923b			      ex    DE, HL 
923b			 
923b			      ld    H, B                    ; Store new bigger size into freed block 
923b			      ld    L, C 
923b			      inc   HL 
923b			      inc   HL 
923b			      ld    (HL), E 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			free_check_adjacent_to_prev: 
923b			      ; Check if the freed block is adjacent to the prev free block 
923b			      ld    L, (IX+2)               ; Prev free block ptr into HL 
923b			      ld    H, (IX+3) 
923b			 
923b			      inc   HL                      ; Size of prev free block into DE 
923b			      inc   HL 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      dec   HL 
923b			      dec   HL 
923b			      dec   HL 
923b			 
923b			      add   HL, DE                  ; Add prev block addr and size 
923b			 
923b			      or    A                       ; Clear the carry flag 
923b			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
923b			      jr    NZ, free_done 
923b			 
923b			      ; Freed block is adjacent to prev, merge into one bigger block 
923b			      ld    H, B                    ; Load next ptr from freed block into DE 
923b			      ld    L, C 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      push  HL                      ; Save freed block ptr for later 
923b			 
923b			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
923b			      ld    H, (IX+3) 
923b			      ld    (HL), E 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			      pop   HL                      ; Restore freed block ptr 
923b			      inc   HL                      ; Load size of freed block into DE 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      push  DE                      ; Save freed block size for later 
923b			 
923b			      ld    L, (IX+2)               ; Load size of prev block into DE 
923b			      ld    H, (IX+3) 
923b			      inc   HL 
923b			      inc   HL 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			 
923b			      pop   HL                      ; Add sizes of both blocks 
923b			      add   HL, DE 
923b			      ex    DE, HL 
923b			 
923b			      ld    L, (IX+2)               ; Store new bigger size into prev block 
923b			      ld    H, (IX+3) 
923b			      inc   HL 
923b			      inc   HL 
923b			      ld    (HL), E 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			free_done: 
923b			      ld    HL, 4                   ; Clean up stack frame 
923b			      add   HL, SP 
923b			      ld    SP, HL 
923b			 
923b			free_early_exit: 
923b			      pop   IX 
923b			      pop   DE 
923b			      pop   BC 
923b			 
923b			      ret 
923b			 
923b			 
923b			;      .org 0x8000 
923b			; 
923b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
923b			 ;                 .dw   0 
923b			 
923b			endif 
923b			 
923b			 
923b			if MALLOC_4 
923b			 
923b			; My memory allocation code. Very very simple.... 
923b			; allocate space under 250 chars 
923b			 
923b			heap_init: 
923b				; init start of heap as zero 
923b				;  
923b			 
923b				ld hl, heap_start 
923b			;	ld a, 0 
923b				ld (hl), 0      ; empty block 
923b				inc hl 
923b			;	ld a, 0 
923b				ld (hl), 0      ; length of block 
923b				; write end of list 
923b				inc hl 
923b				ld a,(hl) 
923b				inc hl 
923b				ld a,(hl) 
923b				 
923b			 
923b				; init some malloc vars 
923b			 
923b				ld hl, 0 
923b				ld (free_list), hl       ; store last malloc location 
923b			 
923b				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
923b			;	ld a, 0 
923b				ld (hl), 0 
923b			 
923b			 
923b				ld hl, heap_start 
923b				;  
923b				  
923b				ret 
923b			 
923b			 
923b			;    free block marker 
923b			;    requested size  
923b			;    pointer to next block 
923b			;    .... 
923b			;    next block marker 
923b			 
923b			 
923b			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
923b			; 
923b			 
923b			 
923b			malloc:  
923b				push de 
923b				push bc 
923b				push af 
923b			 
923b				; hl space required 
923b				 
923b				ld c, l    ; hold space   (TODO only a max of 255) 
923b			 
923b			;	inc c     ; TODO BUG need to fix memory leak on push str 
923b			;	inc c 
923b			;	inc c 
923b			;	inc c 
923b			;	inc c 
923b			;	inc c 
923b			;	inc c 
923b			 
923b			 
923b			 
923b				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
923b			 
923b				ld a, (free_list+3) 
923b			;	cp 0 
923b				or a 
923b				jr z, .contheap 
923b			 
923b				ld hl, (free_list)     ; get last alloc 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "mrs" 
923b						CALLMONITOR 
923b					endif 
923b				jr .startalloc 
923b			 
923b			.contheap: 
923b				ld hl, heap_start 
923b			 
923b			.startalloc: 
923b			 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "mym" 
923b						CALLMONITOR 
923b					endif 
923b			.findblock: 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "mmf" 
923b						CALLMONITOR 
923b					endif 
923b			 
923b				ld a,(hl)  
923b				; if byte is zero then clear to use 
923b			 
923b			;	cp 0 
923b				or a 
923b				jr z, .foundemptyblock 
923b			 
923b				; if byte is not clear 
923b				;     then byte is offset to next block 
923b			 
923b				inc hl 
923b				ld a, (hl) ; get size 
923b			.nextblock:	inc hl 
923b					ld e, (hl) 
923b					inc hl 
923b					ld d, (hl) 
923b					ex de, hl 
923b			;	inc hl  ; move past the store space 
923b			;	inc hl  ; move past zero index  
923b			 
923b				; TODO detect no more space 
923b			 
923b				push hl 
923b				ld de, heap_end 
923b				call cmp16 
923b				pop hl 
923b				jr nc, .nospace 
923b			 
923b				jr .findblock 
923b			 
923b			.nospace: ld hl, 0 
923b				jp .exit 
923b			 
923b			 
923b			.foundemptyblock:	 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "mme" 
923b						CALLMONITOR 
923b					endif 
923b			 
923b			; TODO has block enough space if reusing??? 
923b			 
923b				;  
923b			 
923b			; see if this block has been previously used 
923b				inc hl 
923b				ld a, (hl) 
923b				dec hl 
923b			;	cp 0 
923b				or a 
923b				jr z, .newblock 
923b			 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "meR" 
923b						CALLMONITOR 
923b					endif 
923b			 
923b			; no reusing previously allocated block 
923b			 
923b			; is it smaller than previously used? 
923b				 
923b				inc hl    ; move to size 
923b				ld a, c 
923b				sub (hl)        ; we want c < (hl) 
923b				dec hl    ; move back to marker 
923b			        jr z, .findblock 
923b			 
923b				; update with the new size which should be lower 
923b			 
923b			        ;inc  hl   ; negate next move. move back to size  
923b			 
923b			.newblock: 
923b				; need to be at marker here 
923b			 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "meN" 
923b						CALLMONITOR 
923b					endif 
923b			 
923b			 
923b				ld a, c 
923b			 
923b				ld (free_list+3), a	 ; flag resume from last malloc  
923b				ld (free_list), hl    ; save out last location 
923b			 
923b			 
923b				;inc a     ; space for length byte 
923b				ld (hl), a     ; save block in use marker 
923b			 
923b				inc hl   ; move to space marker 
923b				ld (hl), a    ; save new space 
923b			 
923b				inc hl   ; move to start of allocated area 
923b				 
923b			;	push hl     ; save where we are - 1  
923b			 
923b			;	inc hl  ; move past zero index  
923b				; skip space to set down new marker 
923b			 
923b				; provide some extra space for now 
923b			 
923b				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
923b				inc a 
923b				inc a 
923b			 
923b				push hl   ; save where we are in the node block 
923b			 
923b				call addatohl 
923b			 
923b				; write linked list point 
923b			 
923b				pop de     ; get our node position 
923b				ex de, hl 
923b			 
923b				ld (hl), e 
923b				inc hl 
923b				ld (hl), d 
923b			 
923b				inc hl 
923b			 
923b				; now at start of allocated data so save pointer 
923b			 
923b				push hl 
923b			 
923b				; jump to position of next node and setup empty header in DE 
923b			 
923b				ex de, hl 
923b			 
923b			;	inc hl ; move past end of block 
923b			 
923b			;	ld a, 0 
923b				ld (hl), 0   ; empty marker 
923b				inc hl 
923b				ld (hl), 0   ; size 
923b				inc hl  
923b				ld (hl), 0   ; ptr 
923b				inc hl 
923b				ld (hl), 0   ; ptr 
923b			 
923b			 
923b				pop hl 
923b			 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "mmr" 
923b						CALLMONITOR 
923b					endif 
923b			 
923b			.exit: 
923b				pop af 
923b				pop bc 
923b				pop de  
923b				ret 
923b			 
923b			 
923b			 
923b			 
923b			free:  
923b				push hl 
923b				push af 
923b				; get address in hl 
923b			 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "fre" 
923b						CALLMONITOR 
923b					endif 
923b				; data is at hl - move to block count 
923b				dec hl 
923b				dec hl    ; get past pointer 
923b				dec hl 
923b			 
923b				ld a, (hl)    ; need this for a validation check 
923b			 
923b				dec hl    ; move to block marker 
923b			 
923b				; now check that the block count and block marker are the same  
923b			        ; this checks that we are on a malloc node and not random memory 
923b			        ; OK a faint chance this could be a problem but rare - famous last words! 
923b			 
923b				ld c, a 
923b				ld a, (hl)    
923b			 
923b				cp c 
923b				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
923b			 
923b				; yes good chance we are on a malloc node 
923b			 
923b			;	ld a, 0      
923b				ld (hl), 0   ; mark as free 
923b			 
923b				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
923b			 
923b			.freeignore:  
923b			 
923b				pop af 
923b				pop hl 
923b			 
923b				ret 
923b			 
923b			 
923b			 
923b			endif 
923b			 
923b			; eof 
# End of file firmware_memory.asm
923b			  
923b			; device C  
923b			; Now handled by SPI  
923b			;if SOUND_ENABLE  
923b			;	include "firmware_sound.asm"  
923b			;endif  
923b			  
923b			include "firmware_diags.asm"  
923b			; Hardware diags menu 
923b			 
923b			 
923b			config: 
923b			 
923b 3e 00			ld a, 0 
923d 21 58 92			ld hl, .configmn 
9240 cd dc 8a			call menu 
9243			 
9243 fe 00			cp 0 
9245 c8				ret z 
9246			 
9246			;	cp 1 
9246			;	call z, .savetostore 
9246			 
9246 3d				dec a 
9247			if STARTUP_V1 
9247 cc 6c 92			call z, .selautoload 
924a			endif 
924a			 
924a			if STARTUP_V2 
924a				call z, .enautoload 
924a			endif 
924a				;cp 2 
924a 3d				dec a 
924b cc 62 92			call z, .disautoload 
924e			if STARTUP_V2 
924e				dec a 
924e				call z, .selbank 
924e			endif 
924e			;	cp 3 
924e			;	call z, .selbank 
924e			;	cp 3 
924e 3d				dec a 
924f cc 8a 92			call z, .debug_tog 
9252			;	cp 4 
9252 3d				dec a 
9253 cc 58 93			call z, .bpsgo 
9256			;	cp 5 
9256			;	call z, hardware_diags 
9256			if STARTUP_V2 
9256			;	cp 5 
9256				dec a 
9256				call z, create_startup 
9256			endif 
9256 18 e3			jr config 
9258			 
9258			.configmn: 
9258			;	dw prom_c3 
9258 46 95			dw prom_c2 
925a 5b 95			dw prom_c2a 
925c			if STARTUP_V2 
925c				dw prom_bsel  
925c			endif 
925c			;	dw prom_c2b 
925c			;	dw prom_c4 
925c 7a 95			dw prom_m4 
925e 95 95			dw prom_m4b 
9260			;	dw prom_c1 
9260			if STARTUP_V2 
9260				dw prom_c9 
9260			endif 
9260 00 00			dw 0 
9262				 
9262			 
9262			if STARTUP_V2 
9262			.enautoload: 
9262				if STORAGE_SE 
9262				ld a, $fe      ; bit 0 clear 
9262				ld (spi_device), a 
9262			 
9262				call storage_get_block_0 
9262			 
9262				ld a, 1 
9262				ld (store_page+STORE_0_AUTOFILE), a 
9262			 
9262					ld hl, 0 
9262					ld de, store_page 
9262				call storage_write_block	 ; save update 
9262				else 
9262			 
9262				ld hl, prom_notav 
9262				ld de, prom_empty 
9262				call info_panel 
9262				endif 
9262			 
9262			 
9262				ret 
9262			endif 
9262			 
9262			.disautoload: 
9262				if STORAGE_SE 
9262				ld a, $fe      ; bit 0 clear 
9262				ld (spi_device), a 
9262			 
9262				call storage_get_block_0 
9262			 
9262				ld a, 0 
9262				ld (store_page+STORE_0_AUTOFILE), a 
9262			 
9262					ld hl, 0 
9262					ld de, store_page 
9262				call storage_write_block	 ; save update 
9262				else 
9262			 
9262 21 9d 95			ld hl, prom_notav 
9265 11 b3 95			ld de, prom_empty 
9268 cd 3e 8a			call info_panel 
926b				endif 
926b			 
926b			 
926b c9				ret 
926c			 
926c			if STARTUP_V1 
926c			 
926c			; Select auto start 
926c			 
926c			.selautoload: 
926c			 
926c				 
926c				if STORAGE_SE 
926c			 
926c					call config_dir 
926c				        ld hl, scratch 
926c					ld a, 0 
926c					call menu 
926c			 
926c					cp 0 
926c					ret z 
926c			 
926c					dec a 
926c			 
926c			 
926c					; locate menu option 
926c			 
926c					ld hl, scratch 
926c					call table_lookup 
926c			 
926c					if DEBUG_FORTH_WORDS 
926c						DMARK "ALl" 
926c						CALLMONITOR 
926c					endif 
926c					; with the pointer to the menu it, the byte following the zero term is the file id 
926c			 
926c					ld a, 0 
926c					ld bc, 50   ; max of bytes to look at 
926c					cpir  
926c			 
926c					if DEBUG_FORTH_WORDS 
926c						DMARK "ALb" 
926c						CALLMONITOR 
926c					endif 
926c					;inc hl 
926c			 
926c					ld a, (hl)   ; file id 
926c					 
926c				        ; save bank and file ids 
926c			 
926c					push af 
926c			 
926c			; TODO need to save to block 0 on bank 1	 
926c			 
926c					call storage_get_block_0 
926c			 
926c					if DEBUG_FORTH_WORDS 
926c						DMARK "AL0" 
926c						CALLMONITOR 
926c					endif 
926c					pop af 
926c			 
926c					ld (store_page+STORE_0_FILERUN),a 
926c					 
926c					; save bank id 
926c			 
926c					ld a,(spi_device) 
926c					ld (store_page+STORE_0_BANKRUN),a 
926c			 
926c					; enable auto run of store file 
926c			 
926c					ld a, 1 
926c					ld (store_page+STORE_0_AUTOFILE),a 
926c			 
926c					; save buffer 
926c			 
926c					ld hl, 0 
926c					ld de, store_page 
926c					if DEBUG_FORTH_WORDS 
926c						DMARK "ALw" 
926c						CALLMONITOR 
926c					endif 
926c				call storage_write_block	 ; save update 
926c			  
926c			 
926c			 
926c			 
926c					ld hl, scratch 
926c					call config_fdir 
926c			 
926c				else 
926c			 
926c 21 9d 95			ld hl, prom_notav 
926f 11 b3 95			ld de, prom_empty 
9272 cd 3e 8a			call info_panel 
9275			 
9275				endif 
9275 c9				ret 
9276			endif 
9276			 
9276			 
9276			; Select storage bank 
9276			 
9276			.selbank: 
9276			 
9276			if STARTUP_V2 
9276			;	if STORAGE_SE 
9276			;	else 
9276			 
9276				ld hl, prom_banks 
9276				call menu 
9276				cp 0 
9276				ret z 
9276				 
9276				; set the bank number from the result 
9276			 
9276				 
9276					ld c, SPI_CE_HIGH 
9276					ld b, '0'    ; human readable bank number 
9276			 
9276			 
9276					; active low 
9276			 
9276			;		cp 0 
9276					or a 
9276					jr z, .bset 
9276					cp 1 
9276					jr nz, .b2 
9276					res 0, c 
9276					ld b, '1'    ; human readable bank number 
9276			.b2:		cp 2 
9276					jr nz, .b3 
9276					res 1, c 
9276					ld b, '2'    ; human readable bank number 
9276			.b3:		cp 3 
9276					jr nz, .b4 
9276					res 2, c 
9276					ld b, '3'    ; human readable bank number 
9276			.b4:		cp 4 
9276					jr nz, .b5 
9276					res 3, c 
9276					ld b, '4'    ; human readable bank number 
9276			.b5:		cp 5 
9276					jr nz, .bset 
9276					res 4, c 
9276					ld b, '5'    ; human readable bank number 
9276			 
9276			.bset: 
9276			 
9276					ld a, c 
9276			;		ld (spi_device),a 
9276					ld a, b 
9276			;		ld (spi_device_id),a 
9276					push bc 
9276			 
9276					; select bank 1 and load block 0  
9276			 
9276				ld a, $fe      ; bit 0 clear 
9276				ld (spi_device), a 
9276			 
9276				call storage_get_block_0 
9276			 
9276				pop bc 
9276				ld a,c 
9276				ld (store_page+STORE_0_BANKRUN), a 
9276				ld a,b 
9276				ld (store_page+STORE_0_BANKRUNN), a 
9276					ld hl, 0 
9276					ld de, store_page 
9276				call storage_write_block 
9276			 
9276			else 
9276 21 9d 95			ld hl, prom_notav 
9279 11 b3 95			ld de, prom_empty 
927c cd 3e 8a			call info_panel 
927f			;	endif 
927f				 
927f			endif 
927f c9				ret 
9280			 
9280			if STORAGE_SE 
9280			 
9280			.config_ldir:   
9280				; Load storage bank labels into menu array 
9280			 
9280				 
9280			 
9280			 
9280				ret 
9280			 
9280			 
9280			endif 
9280			 
9280			 
9280			; Save user words to storage 
9280			 
9280			.savetostore: 
9280			 
9280			;	if STORAGE_SE 
9280			; 
9280			;		call config_dir 
9280			;	        ld hl, scratch 
9280			;		ld a, 0 
9280			;		call menu 
9280			;		 
9280			;		ld hl, scratch 
9280			;		call config_fdir 
9280			; 
9280			;	else 
9280			 
9280 21 9d 95			ld hl, prom_notav 
9283 11 b3 95			ld de, prom_empty 
9286 cd 3e 8a			call info_panel 
9289			 
9289			;	endif 
9289			 
9289 c9				ret 
928a			 
928a			if STARTUP_V2 
928a			 
928a			create_startup: 
928a			 
928a				ld a, 0 
928a				ld hl, .crstart 
928a				call menu 
928a			 
928a				cp 0 
928a				ret z 
928a			 
928a				cp 1 
928a				call z, .genlsword 
928a				cp 2 
928a				call z, .genedword 
928a			 
928a				cp 3 
928a				call z, .gendemword 
928a			 
928a				cp 4 
928a				call z, .genutlword 
928a				cp 5 
928a				call z, .genspiword 
928a				cp 6 
928a				call z, .genkeyword 
928a				cp 7 
928a				call z, .gensoundword 
928a				cp 8 
928a				call z, .genhwword 
928a				jr create_startup 
928a			 
928a			.genhwword: 
928a				ld hl, crs_hw 
928a				ld de, .hwworddef 
928a				call .genfile 
928a				ret 
928a			.gensoundword: 
928a				ld hl, crs_sound 
928a				ld de, .soundworddef 
928a				call .genfile 
928a				ret 
928a			.genlsword: 
928a				ld hl, crs_s1 
928a				ld de, .lsworddef 
928a				call .genfile 
928a				ret 
928a			 
928a			.genedword: 
928a				ld de, .edworddef 
928a				ld hl, crs_s2 
928a				call .genfile 
928a				ret 
928a			 
928a			.gendemword: 
928a				ld de, .demoworddef 
928a				ld hl, crs_s3 
928a				call .genfile 
928a				ret 
928a			 
928a			.genutlword: 
928a				ld hl, crs_s4 
928a				ld de, .utilwordef 
928a				call .genfile 
928a				ret 
928a			.genspiword: 
928a				ld hl, crs_s5 
928a				ld de, .spiworddef 
928a				call .genfile 
928a				ret 
928a			.genkeyword: 
928a				ld hl, crs_s6 
928a				ld de, .keyworddef 
928a				call .genfile 
928a				ret 
928a			 
928a			; hl - points to file name 
928a			; de - points to strings to add to file 
928a			 
928a			.genfile: 
928a				push hl 
928a				push de 
928a			 
928a				call clear_display 
928a				ld a, display_row_1 
928a				ld de, .genfiletxt 
928a				call str_at_display 
928a				call update_display 
928a			 
928a				pop de 
928a				pop hl 
928a			 
928a			 
928a				push de 
928a				call storage_create 
928a				; id in hl 
928a				pop de   ; table of strings to add 
928a			 
928a			.genloop: 
928a			 
928a				push hl ; save id for next time around 
928a				push de ; save de for next time around 
928a			 
928a				ex de, hl 
928a				call loadwordinhl 
928a				ex de, hl 
928a			 
928a				; need hl to be the id 
928a				; need de to be the string ptr 
928a				 
928a				call storage_append 
928a			 
928a				pop de 
928a				pop hl 
928a			 
928a				inc de 
928a				inc de 
928a			 
928a				ld a,(de) 
928a				cp 0 
928a				jr nz, .genloop 
928a				inc de 
928a				ld a, (de) 
928a				dec de 
928a				cp 0 
928a				jr nz, .genloop	 
928a			 
928a				ret 
928a			 
928a			.genfiletxt:  db "Creating file...",0 
928a			 
928a			.hwworddef: 
928a				dw test5 
928a				dw test6 
928a				dw test7 
928a				dw test8 
928a				dw test9 
928a				dw test10 
928a				dw 0 
928a			 
928a			.soundworddef: 
928a				dw sound1 
928a				dw sound2 
928a				dw sound3 
928a				dw sound4 
928a				dw sound5 
928a				dw sound6 
928a				dw sound7 
928a				dw sound8 
928a				dw sound9 
928a				dw 0 
928a			 
928a			.utilwordef: 
928a				dw strncpy 
928a				dw type 
928a				dw tuck 
928a				dw clrstack 
928a				dw longread 
928a				dw start1 
928a				dw start2 
928a			; duplicated 
928a			;	dw start3b 
928a			;	dw start3c 
928a				dw list 
928a				dw 0 
928a			 
928a			.lsworddef: 
928a				dw start3b 
928a				dw 0 
928a			 
928a			.edworddef: 
928a				dw edit1 
928a				dw edit2 
928a				dw edit3 
928a				dw 0 
928a			 
928a			.demoworddef: 
928a				dw game1 
928a				dw game1a 
928a				dw game1b 
928a				dw game1c 
928a				dw game1d 
928a				dw game1s 
928a				dw game1t 
928a				dw game1f 
928a				dw game1z 
928a				dw game1zz 
928a				dw ssv2 
928a				dw ssv3 
928a				dw ssv4 
928a				dw ssv5 
928a				dw ssv1 
928a				dw ssv1cpm	 
928a			;	dw game2b 
928a			;	dw game2bf 
928a			;	dw game2mba 
928a			;	dw game2mbas	 
928a			;	dw game2mbht 
928a			;	dw game2mbms 
928a			;	dw game2mb 
928a			;	dw game3w 
928a			;	dw game3p 
928a			;	dw game3sc 
928a			;	dw game3vsi 
928a			;	dw game3vs 
928a				dw 0 
928a			 
928a			 
928a			.spiworddef: 
928a			 
928a			    dw spi1 
928a			    dw spi2 
928a			    dw spi2b 
928a			    dw spi3 
928a			    dw spi4 
928a			    dw spi5 
928a			;    dw spi6 
928a			;    dw spi7 
928a			 
928a			;    dw spi8 
928a			;    dw spi9 
928a			;    dw spi10 
928a			    dw 0 
928a			 
928a			.keyworddef: 
928a			 
928a				dw keyup 
928a				dw keydown 
928a				dw keyleft 
928a				dw keyright 
928a				dw 	keyf1 
928a				dw keyf2 
928a				dw keyf3 
928a				dw keyf4 
928a				dw keyf5 
928a				dw keyf6 
928a				dw keyf7 
928a				dw keyf8 
928a				dw keyf9 
928a				dw keyf10 
928a				dw keyf11 
928a				dw keyf12 
928a				dw keytab 
928a				dw keycr 
928a				dw keyhome 
928a				dw keyend 
928a				dw keybs 
928a				dw 0 
928a			 
928a			.crstart: 
928a				dw crs_s1 
928a				dw crs_s2 
928a				dw crs_s3 
928a				dw crs_s4 
928a				dw crs_s5 
928a				dw crs_s6 
928a				dw crs_sound 
928a				dw crs_hw 
928a				dw 0 
928a			 
928a			endif 
928a			 
928a			 
928a			if STORAGE_SE 
928a			 
928a			config_fdir: 
928a				; using the scratch dir go through and release the memory allocated for each string 
928a				 
928a				ld hl, scratch 
928a			.cfdir:	ld e,(hl) 
928a				inc hl 
928a				ld d,(hl) 
928a				inc hl 
928a			 
928a				ex de, hl 
928a				call ishlzero 
928a				ret z     ; return on null pointer 
928a				call free 
928a				ex de, hl 
928a				jr .cfdir 
928a			 
928a			 
928a				ret 
928a			 
928a			 
928a			config_dir: 
928a			 
928a				; for the config menus that need to build a directory of storage call this routine 
928a				; it will construct a menu in scratch to pass to menu 
928a			 
928a				; open storage device 
928a			 
928a				; execute DIR to build a list of files and their ids into scratch in menu format 
928a				; once the menu has finished then will need to call config_fdir to release the strings 
928a				 
928a				; c = number items 
928a			 
928a				 
928a				call storage_get_block_0 
928a			 
928a				ld hl, store_page     ; get current id count 
928a				ld b, (hl) 
928a				ld c, 0    ; count of files   
928a			 
928a			 
928a				ld hl, scratch 
928a				ld (store_tmp2), hl    ; location to poke strings 
928a			 
928a				; check for empty drive 
928a			 
928a				ld a, 0 
928a				cp b 
928a				jp z, .dirdone 
928a			 
928a				 
928a					if DEBUG_FORTH_WORDS 
928a						DMARK "Cdc" 
928a						CALLMONITOR 
928a					endif 
928a			 
928a			 
928a			.diritem:	 
928a				push bc 
928a				; for each of the current ids do a search for them and if found push to stack 
928a			 
928a					ld hl, STORE_BLOCK_PHY 
928a					ld d, 0		 ; look for extent 0 of block id as this contains file name 
928a					ld e,b 
928a			 
928a					call storage_findnextid 
928a			 
928a			 
928a					; if found hl will be non zero 
928a			 
928a					call ishlzero 
928a					jr z, .dirnotfound 
928a			 
928a					; increase count 
928a			 
928a					pop bc	 
928a					inc c 
928a					push bc 
928a					 
928a			 
928a					; get file header and push the file name 
928a			 
928a					ld de, store_page 
928a					call storage_read_block 
928a			 
928a					; push file id to stack 
928a				 
928a					ld a, (store_page) 
928a					ld h, 0 
928a					ld l, a 
928a			 
928a					;call forth_push_numhl 
928a					; TODO store id 
928a			 
928a					push hl 
928a			 
928a					; push extent count to stack  
928a				 
928a					ld hl, store_page+3 
928a			 
928a					; get file name length 
928a			 
928a					call strlenz   
928a			 
928a					inc hl   ; cover zero term 
928a					inc hl  ; stick the id at the end of the area 
928a			 
928a					push hl 
928a					pop bc    ; move length to bc 
928a			 
928a					call malloc 
928a			 
928a					; TODO save malloc area to scratch 
928a			 
928a					ex de, hl 
928a					ld hl, (store_tmp2) 
928a					ld (hl), e 
928a					inc hl 
928a					ld (hl), d 
928a					inc hl 
928a					ld (store_tmp2), hl 
928a			 
928a					 
928a			 
928a					;pop hl   ; get source 
928a			;		ex de, hl    ; swap aronund	 
928a			 
928a					ld hl, store_page+3 
928a					if DEBUG_FORTH_WORDS 
928a						DMARK "CFd" 
928a						CALLMONITOR 
928a					endif 
928a					ldir 
928a			 
928a					; de is past string, move back one and store id 
928a					 
928a					dec de 
928a			 
928a					; store file id 
928a			 
928a					pop hl 
928a					ex de,hl 
928a					ld (hl), e 
928a			 
928a					if DEBUG_FORTH_WORDS 
928a						DMARK "Cdi" 
928a						CALLMONITOR 
928a					endif 
928a					 
928a			.dirnotfound: 
928a					pop bc     
928a					djnz .diritem 
928a				 
928a			.dirdone:	 
928a			 
928a			;		ld a, 0 
928a					ld hl, (store_tmp2) 
928a					ld (hl), 0 
928a					inc hl 
928a					ld (hl), 0 
928a					inc hl 
928a					; push a count of the dir items found 
928a			 
928a			;		ld h, 0 
928a			;		ld l, c 
928a			 
928a				ret 
928a			 
928a			endif 
928a			 
928a			 
928a			; Settings 
928a			; Run  
928a			 
928a			 
928a			 
928a			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
928a			;;hd_menu2:   db "        2: Editor",0   
928a			;hd_menu2:   db "        2: Editor       6: Menu",0   
928a			;hd_menu3:   db "        3: Storage",0 
928a			;hd_menu4:   db "0=quit  4: Debug",0 
928a			;hd_don:     db "ON",0 
928a			;hd_doff:     db "OFF",0 
928a			; 
928a			; 
928a			; 
928a			;hardware_diags_old:       
928a			; 
928a			;.diagmenu: 
928a			;	call clear_display 
928a			;	ld a, display_row_1 
928a			;	ld de, hd_menu1 
928a			;	call str_at_display 
928a			; 
928a			;	ld a, display_row_2 
928a			;	ld de, hd_menu2 
928a			;	call str_at_display 
928a			; 
928a			;	ld a, display_row_3 
928a			;	ld de, hd_menu3 
928a			;	call str_at_display 
928a			; 
928a			;	ld a,  display_row_4 
928a			;	ld de, hd_menu4 
928a			;	call str_at_display 
928a			; 
928a			;	; display debug state 
928a			; 
928a			;	ld de, hd_don 
928a			;	ld a, (os_view_disable) 
928a			;	cp 0 
928a			;	jr z, .distog 
928a			;	ld de, hd_doff 
928a			;.distog: ld a, display_row_4+17 
928a			;	call str_at_display 
928a			; 
928a			;	call update_display 
928a			; 
928a			;	call cin_wait 
928a			; 
928a			; 
928a			; 
928a			;	cp '4' 
928a			;	jr nz, .diagn1 
928a			; 
928a			;	; debug toggle 
928a			; 
928a			;	ld a, (os_view_disable) 
928a			;	ld b, '*' 
928a			;	cp 0 
928a			;	jr z, .debtog 
928a			;	ld b, 0 
928a			;.debtog:	 
928a			;	ld a,b 
928a			;	ld (os_view_disable),a 
928a			; 
928a			;.diagn1: cp '0' 
928a			;	 ret z 
928a			; 
928a			;;	cp '1' 
928a			;;       jp z, matrix	 
928a			;;   TODO keyboard matrix test 
928a			; 
928a			;	cp '2' 
928a			;	jp z, .diagedit 
928a			; 
928a			;;	cp '6' 
928a			;;	jp z, .menutest 
928a			;;if ENABLE_BASIC 
928a			;;	cp '6' 
928a			;;	jp z, basic 
928a			;;endif 
928a			 ; 
928a			;	jp .diagmenu 
928a			; 
928a			; 
928a			;	ret 
928a			 
928a			 
928a			.debug_tog: 
928a 21 b3 92			ld hl, .menudebug 
928d				 
928d			;	ld a, (os_view_disable) 
928d			;	cp '*' 
928d 3a 6f ee			ld a,(debug_vector) 
9290 fe c9			cp $C9   ; RET 
9292 20 04			jr nz,.tdon  
9294 3e 01			ld a, 1 
9296 18 02			jr .tog1 
9298 3e 00		.tdon: ld a, 0 
929a			 
929a			.tog1: 
929a cd dc 8a			call menu 
929d fe 00			cp 0 
929f c8				ret z 
92a0 fe 01			cp 1    ; disable debug 
92a2 28 04			jr z, .dtog0 
92a4 3e 2a			ld a, '*' 
92a6 18 05			jr .dtogset 
92a8			.dtog0:  
92a8				;ld a, 0 
92a8 cd 46 93			call bp_on 
92ab 18 dd			jr .debug_tog 
92ad			.dtogset:  
92ad				; ld (os_view_disable), a 
92ad cd 52 93			call bp_off 
92b0 c3 8a 92			jp .debug_tog 
92b3			 
92b3			 
92b3			.menudebug: 
92b3 b9 92				dw .m6 
92b5 c2 92				dw .m7 
92b7 00 00				dw 0 
92b9 .. 00		.m6:   db "Debug ON",0 
92c2 .. 00		.m7:   db "Debug OFF",0 
92cc			;hardware_diags:       
92cc			 
92cc			ENABLE_HDIAGS: equ 0 
92cc			 
92cc			if ENABLE_HDIAGS 
92cc			.diagm: 
92cc				ld hl, .menuitems 
92cc				ld a, 0 
92cc				call menu 
92cc			 
92cc			         cp 0 
92cc				 ret z 
92cc			 
92cc				cp 2 
92cc				jp z, .diagedit 
92cc			 
92cc			;	cp '6' 
92cc			;	jp z, .menutest 
92cc			;if ENABLE_BASIC 
92cc			;	cp '6' 
92cc			;	jp z, basic 
92cc			;endif 
92cc			  
92cc				jp .diagm 
92cc			 
92cc				 
92cc			.menuitems:   	dw .m1 
92cc					dw .m2 
92cc					dw .m3 
92cc					dw .m5 
92cc					dw .m5a 
92cc					dw .m5b 
92cc					dw 0 
92cc			 
92cc			 
92cc			.m1:   db "Key Matrix",0 
92cc			.m2:   db "Editor",0 
92cc			.m3:   db "Storage",0 
92cc			.m5:   db "Sound",0 
92cc			.m5a:  db "RAM Test",0 
92cc			.m5b:  db "LCD Test",0 
92cc			 
92cc			 
92cc			; debug editor 
92cc			 
92cc			.diagedit: 
92cc			 
92cc				ld hl, scratch 
92cc			;	ld bc, 250 
92cc			;	ldir 
92cc				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
92cc			;	ld a, 0 
92cc				ld (hl), 0 
92cc				inc hl 
92cc				ld (hl), 0 
92cc				inc hl 
92cc				ld (hl), 0 
92cc			 
92cc			        call clear_display 
92cc				call update_display 
92cc				;ld a, 1 
92cc				;ld (hardware_diag), a 
92cc			.diloop: 
92cc				ld a, display_row_1 
92cc				ld c, 0 
92cc				ld d, 255    ; TODO fix input_str to actually take note of max string input length 
92cc				ld e, 40 
92cc			 
92cc				ld hl, scratch	 
92cc				call input_str 
92cc			 
92cc				ld a, display_row_2 
92cc				ld de, scratch 
92cc				call str_at_display 
92cc				call update_display 
92cc			 
92cc				jp .diloop 
92cc			endif 
92cc			 
92cc			; pass word in hl 
92cc			; a has display location 
92cc			display_word_at: 
92cc f5				push af 
92cd e5				push hl 
92ce 7c				ld a,h 
92cf 21 bd e5			ld hl, os_word_scratch 
92d2 cd d2 8e			call hexout 
92d5 e1				pop hl 
92d6 7d				ld a,l 
92d7 21 bf e5			ld hl, os_word_scratch+2 
92da cd d2 8e			call hexout 
92dd 21 c1 e5			ld hl, os_word_scratch+4 
92e0			;	ld a,0 
92e0 36 00			ld (hl),0 
92e2 11 bd e5			ld de,os_word_scratch 
92e5 f1				pop af 
92e6 cd be 8a				call str_at_display 
92e9 c9				ret 
92ea			 
92ea			display_ptr_state: 
92ea			 
92ea				; to restore afterwards 
92ea			 
92ea d5				push de 
92eb c5				push bc 
92ec e5				push hl 
92ed f5				push af 
92ee			 
92ee				; for use in here 
92ee			 
92ee			;	push bc 
92ee			;	push de 
92ee			;	push hl 
92ee			;	push af 
92ee			 
92ee cd ac 8a			call clear_display 
92f1			 
92f1 11 c9 94			ld de, .ptrstate 
92f4 3e 00			ld a, display_row_1 
92f6 cd be 8a			call str_at_display 
92f9			 
92f9				; display debug step 
92f9			 
92f9			 
92f9 11 62 ee			ld de, debug_mark 
92fc 3e 26			ld a, display_row_1+display_cols-2 
92fe cd be 8a			call str_at_display 
9301			 
9301				; display a 
9301 11 d3 94			ld de, .ptrcliptr 
9304 3e 28			ld a, display_row_2 
9306 cd be 8a			call str_at_display 
9309			 
9309 f1				pop af 
930a 2a 37 ea			ld hl,(cli_ptr) 
930d 3e 30			ld a, display_row_2+8 
930f cd cc 92			call display_word_at 
9312			 
9312			 
9312				; display hl 
9312			 
9312			 
9312 11 db 94			ld de, .ptrclioptr 
9315 3e 32			ld a, display_row_2+10 
9317 cd be 8a			call str_at_display 
931a			; 
931a			;	pop hl 
931a 3e 35			ld a, display_row_2+13 
931c 2a 35 ea			ld hl,(cli_origptr) 
931f cd cc 92			call display_word_at 
9322			; 
9322			;	 
9322			;	; display de 
9322			 
9322			;	ld de, .regstatede 
9322			;	ld a, display_row_3 
9322			;	call str_at_display 
9322			 
9322			;	pop de 
9322			;	ld h,d 
9322			;	ld l, e 
9322			;	ld a, display_row_3+3 
9322			;	call display_word_at 
9322			 
9322			 
9322				; display bc 
9322			 
9322			;	ld de, .regstatebc 
9322			;	ld a, display_row_3+10 
9322			;	call str_at_display 
9322			 
9322			;	pop bc 
9322			;	ld h,b 
9322			;	ld l, c 
9322			;	ld a, display_row_3+13 
9322			;	call display_word_at 
9322			 
9322			 
9322				; display dsp 
9322			 
9322			;	ld de, .regstatedsp 
9322			;	ld a, display_row_4 
9322			;	call str_at_display 
9322			 
9322				 
9322			;	ld hl,(cli_data_sp) 
9322			;	ld a, display_row_4+4 
9322			;	call display_word_at 
9322			 
9322				; display rsp 
9322			 
9322 11 0a 95			ld de, .regstatersp 
9325 3e 82			ld a, display_row_4+10 
9327 cd be 8a			call str_at_display 
932a			 
932a				 
932a 2a e9 e9			ld hl,(cli_ret_sp) 
932d 3e 86			ld a, display_row_4+14 
932f cd cc 92			call display_word_at 
9332			 
9332 cd ce 8a			call update_display 
9335			 
9335 cd f0 89			call delay1s 
9338 cd f0 89			call delay1s 
933b cd f0 89			call delay1s 
933e			 
933e			 
933e cd 3f 99			call next_page_prompt 
9341			 
9341				; restore  
9341			 
9341 f1				pop af 
9342 e1				pop hl 
9343 c1				pop bc 
9344 d1				pop de 
9345 c9				ret 
9346			 
9346			; Update the break point vector so that the user can hook a new routine 
9346			 
9346			bp_on: 
9346 3e c3			ld a, $c3    ; JP 
9348 32 6f ee			ld (debug_vector), a 
934b 21 58 93			ld hl, break_point_state 
934e 22 70 ee			ld (debug_vector+1), hl 
9351 c9				ret 
9352			 
9352			bp_off: 
9352 3e c9			ld a, $c9    ; RET 
9354 32 6f ee			ld (debug_vector), a 
9357 c9				ret 
9358			 
9358			 
9358			break_point_state: 
9358			;	push af 
9358			; 
9358			;	; see if disabled 
9358			; 
9358			;	ld a, (os_view_disable) 
9358			;	cp '*' 
9358			;	jr nz, .bpsgo 
9358			;	pop af 
9358			;	ret 
9358			 
9358			.bpsgo: 
9358			;	pop af 
9358 f5				push af 
9359 22 9a e2			ld (os_view_hl), hl 
935c ed 53 98 e2		ld (os_view_de), de 
9360 ed 43 96 e2		ld (os_view_bc), bc 
9364 e5				push hl 
9365 6f				ld l, a 
9366 26 00			ld h, 0 
9368 22 9c e2			ld (os_view_af),hl 
936b			 
936b 21 a8 ed				ld hl, display_fb0 
936e 22 c3 eb				ld (display_fb_active), hl 
9371 e1				pop hl	 
9372			 
9372 3e 31			ld a, '1' 
9374 fe 2a		.bps1:  cp '*' 
9376 cc 52 93			call z, bp_off 
9379			;	jr nz, .bps1b 
9379			;	ld (os_view_disable),a 
9379 fe 31		.bps1b:  cp '1' 
937b 20 14			jr nz, .bps2 
937d			 
937d				; display reg 
937d			 
937d				 
937d			 
937d 3a 9c e2			ld a, (os_view_af) 
9380 2a 9a e2			ld hl, (os_view_hl) 
9383 ed 5b 98 e2		ld de, (os_view_de) 
9387 ed 4b 96 e2		ld bc, (os_view_bc) 
938b cd 25 94			call display_reg_state 
938e c3 11 94			jp .bpschk 
9391			 
9391 fe 32		.bps2:  cp '2' 
9393 20 08			jr nz, .bps3 
9395				 
9395				; display hl 
9395 2a 9a e2			ld hl, (os_view_hl) 
9398 cd 0f 95			call display_dump_at_hl 
939b			 
939b 18 74			jr .bpschk 
939d			 
939d fe 33		.bps3:  cp '3' 
939f 20 08			jr nz, .bps4 
93a1			 
93a1			        ; display de 
93a1 2a 98 e2			ld hl, (os_view_de) 
93a4 cd 0f 95			call display_dump_at_hl 
93a7			 
93a7 18 68			jr .bpschk 
93a9 fe 34		.bps4:  cp '4' 
93ab 20 08			jr nz, .bps5 
93ad			 
93ad			        ; display bc 
93ad 2a 96 e2			ld hl, (os_view_bc) 
93b0 cd 0f 95			call display_dump_at_hl 
93b3			 
93b3 18 5c			jr .bpschk 
93b5 fe 35		.bps5:  cp '5' 
93b7 20 08		        jr nz, .bps7 
93b9			 
93b9				; display cur ptr 
93b9 2a 37 ea			ld hl, (cli_ptr) 
93bc cd 0f 95			call display_dump_at_hl 
93bf			 
93bf 18 50			jr .bpschk 
93c1 fe 36		.bps7:  cp '6' 
93c3 20 08			jr nz, .bps8b 
93c5				 
93c5				; display cur orig ptr 
93c5 2a 35 ea			ld hl, (cli_origptr) 
93c8 cd 0f 95			call display_dump_at_hl 
93cb 18 44			jr .bpschk 
93cd fe 37		.bps8b:  cp '7' 
93cf 20 08			jr nz, .bps9 
93d1				 
93d1				; display dsp 
93d1 2a e5 e9			ld hl, (cli_data_sp) 
93d4 cd 0f 95			call display_dump_at_hl 
93d7			 
93d7 18 38			jr .bpschk 
93d9 fe 39		.bps9:  cp '9' 
93db 20 05			jr nz, .bps8c 
93dd				 
93dd				; display SP 
93dd			;	ld hl, sp 
93dd cd 0f 95			call display_dump_at_hl 
93e0			 
93e0 18 2f			jr .bpschk 
93e2 fe 38		.bps8c:  cp '8' 
93e4 20 08			jr nz, .bps8d 
93e6				 
93e6				; display rsp 
93e6 2a e9 e9			ld hl, (cli_ret_sp) 
93e9 cd 0f 95			call display_dump_at_hl 
93ec			 
93ec 18 23			jr .bpschk 
93ee fe 23		.bps8d:  cp '#'     ; access monitor sub system 
93f0 20 05			jr nz, .bps8 
93f2 cd fd 96			call monitor 
93f5			 
93f5 18 1a			jr .bpschk 
93f7 fe 30		.bps8:  cp '0' 
93f9 20 16			jr nz, .bpschk 
93fb			 
93fb 21 07 ed				ld hl, display_fb1 
93fe 22 c3 eb				ld (display_fb_active), hl 
9401 cd ce 8a				call update_display 
9404			 
9404				;ld a, (os_view_af) 
9404 2a 9a e2			ld hl, (os_view_hl) 
9407 ed 5b 98 e2		ld de, (os_view_de) 
940b ed 4b 96 e2		ld bc, (os_view_bc) 
940f f1				pop af 
9410 c9				ret 
9411			 
9411			.bpschk:   
9411 cd f0 89			call delay1s 
9414 3e 9f		ld a,display_row_4 + display_cols - 1 
9416 11 3d 99		        ld de, endprg 
9419 cd be 8a			call str_at_display 
941c cd ce 8a			call update_display 
941f cd 51 e4			call cin_wait 
9422			 
9422 c3 74 93			jp .bps1 
9425			 
9425			 
9425			display_reg_state: 
9425			 
9425				; to restore afterwards 
9425			 
9425 d5				push de 
9426 c5				push bc 
9427 e5				push hl 
9428 f5				push af 
9429			 
9429				; for use in here 
9429			 
9429 c5				push bc 
942a d5				push de 
942b e5				push hl 
942c f5				push af 
942d			 
942d cd ac 8a			call clear_display 
9430			 
9430 11 e5 94			ld de, .regstate 
9433 3e 00			ld a, display_row_1 
9435 cd be 8a			call str_at_display 
9438			 
9438				; display debug step 
9438			 
9438			 
9438 11 62 ee			ld de, debug_mark 
943b 3e 25			ld a, display_row_1+display_cols-3 
943d cd be 8a			call str_at_display 
9440			 
9440				; display a 
9440 11 01 95			ld de, .regstatea 
9443 3e 28			ld a, display_row_2 
9445 cd be 8a			call str_at_display 
9448			 
9448 e1				pop hl 
9449			;	ld h,0 
9449			;	ld l, a 
9449 3e 2b			ld a, display_row_2+3 
944b cd cc 92			call display_word_at 
944e			 
944e			 
944e				; display hl 
944e			 
944e			 
944e 11 f5 94			ld de, .regstatehl 
9451 3e 32			ld a, display_row_2+10 
9453 cd be 8a			call str_at_display 
9456			 
9456 e1				pop hl 
9457 3e 35			ld a, display_row_2+13 
9459 cd cc 92			call display_word_at 
945c			 
945c				 
945c				; display de 
945c			 
945c 11 f9 94			ld de, .regstatede 
945f 3e 50			ld a, display_row_3 
9461 cd be 8a			call str_at_display 
9464			 
9464 e1				pop hl 
9465			;	ld h,d 
9465			;	ld l, e 
9465 3e 53			ld a, display_row_3+3 
9467 cd cc 92			call display_word_at 
946a			 
946a			 
946a				; display bc 
946a			 
946a 11 fd 94			ld de, .regstatebc 
946d 3e 5a			ld a, display_row_3+10 
946f cd be 8a			call str_at_display 
9472			 
9472 e1				pop hl 
9473			;	ld h,b 
9473			;	ld l, c 
9473 3e 5d			ld a, display_row_3+13 
9475 cd cc 92			call display_word_at 
9478			 
9478			 
9478				; display dsp 
9478			 
9478 11 05 95			ld de, .regstatedsp 
947b 3e 78			ld a, display_row_4 
947d cd be 8a			call str_at_display 
9480			 
9480				 
9480 2a e5 e9			ld hl,(cli_data_sp) 
9483 3e 7c			ld a, display_row_4+4 
9485 cd cc 92			call display_word_at 
9488			 
9488				; display rsp 
9488			 
9488 11 0a 95			ld de, .regstatersp 
948b 3e 82			ld a, display_row_4+10 
948d cd be 8a			call str_at_display 
9490			 
9490				 
9490 2a e9 e9			ld hl,(cli_ret_sp) 
9493 3e 86			ld a, display_row_4+14 
9495 cd cc 92			call display_word_at 
9498			 
9498 cd ce 8a			call update_display 
949b			 
949b			;	call delay1s 
949b			;	call delay1s 
949b			;	call delay1s 
949b			 
949b			 
949b			;	call next_page_prompt 
949b			 
949b				; restore  
949b			 
949b f1				pop af 
949c e1				pop hl 
949d c1				pop bc 
949e d1				pop de 
949f c9				ret 
94a0			 
94a0 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
94b4 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
94c9 .. 00		.ptrstate:	db "Ptr State",0 
94d3 .. 00		.ptrcliptr:     db "cli_ptr",0 
94db .. 00		.ptrclioptr:     db "cli_o_ptr",0 
94e5 .. 00		.regstate:	db "Reg State (1/0)",0 
94f5 .. 00		.regstatehl:	db "HL:",0 
94f9 .. 00		.regstatede:	db "DE:",0 
94fd .. 00		.regstatebc:	db "BC:",0 
9501 .. 00		.regstatea:	db "A :",0 
9505 .. 00		.regstatedsp:	db "DSP:",0 
950a .. 00		.regstatersp:	db "RSP:",0 
950f			 
950f			display_dump_at_hl: 
950f e5				push hl 
9510 d5				push de 
9511 c5				push bc 
9512 f5				push af 
9513			 
9513 22 db e5			ld (os_cur_ptr),hl	 
9516 cd ac 8a			call clear_display 
9519 cd 4b 98			call dumpcont 
951c			;	call delay1s 
951c			;	call next_page_prompt 
951c			 
951c			 
951c f1				pop af 
951d c1				pop bc 
951e d1				pop de 
951f e1				pop hl 
9520 c9				ret 
9521			 
9521			;if ENABLE_BASIC 
9521			;	include "nascombasic.asm" 
9521			;	basic: 
9521			;	include "forth/FORTH.ASM" 
9521			;endif 
9521			 
9521			; eof 
9521			 
9521			 
# End of file firmware_diags.asm
9521			  
9521			include "firmware_prompts.asm"  
9521			; Prompts  
9521			 
9521			; boot messages 
9521			 
9521 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
9536 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
9546			 
9546			 
9546			; config menus 
9546			 
9546			;prom_c3: db "Add Dictionary To File",0 
9546			 
9546			if STARTUP_V1 
9546 .. 00		prom_c2: db "Select Autoload File",0 
955b .. 00		prom_c2a: db "Disable Autoload File", 0 
9571			endif 
9571			 
9571			if STARTUP_V2 
9571			prom_c2: db "Enable Autoload Files",0 
9571			prom_c2a: db "Disable Autoload Files", 0 
9571			 
9571			crs_s1: db "*ls-word", 0 
9571			crs_s2: db "*ed-word", 0 
9571			crs_s3: db "*Demo-Games", 0 
9571			crs_s4: db "*Utils", 0 
9571			crs_s5: db "*SPI-Util", 0 
9571			crs_s6: db "*Key-Constants", 0 
9571			crs_sound: db "*Sound-Util", 0 
9571			crs_hw: db "*Hello-World",0 
9571			 
9571			 
9571			 
9571			endif 
9571			;prom_c2b: db "Select Storage Bank",0 
9571 .. 00		prom_c4: db "Settings",0 
957a .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9595 .. 00		prom_m4b:   db "Monitor",0 
959d			;prom_c1: db "Hardware Diags",0 
959d			 
959d			 
959d			if STARTUP_V2 
959d			prom_c9: db "Create Startup Files",0 
959d			prom_bsel: db "Start From Bank...",0 
959d			prom_bsel1: db "Bank 1",0 
959d			prom_bsel2: db "Bank 2",0 
959d			prom_bsel3: db "Bank 3",0 
959d			prom_bsel4: db "Bank 4",0 
959d			prom_bsel5: db "Bank 5",0 
959d			 
959d			prom_banks: 
959d				dw prom_bsel1 
959d				dw prom_bsel2 
959d				dw prom_bsel3 
959d				dw prom_bsel4 
959d				dw prom_bsel5 
959d				dw 0 
959d			endif 
959d			 
959d .. 00		prom_notav:    db "Feature not available",0 
95b3 .. 00		prom_empty:    db "",0 
95b4			 
95b4			; eof 
95b4			 
# End of file firmware_prompts.asm
95b4			  
95b4			; eof  
95b4			  
# End of file firmware.asm
95b4			 
95b4			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
95b4			;if BASE_KEV  
95b4			;baseram: equ 08000h 
95b4			;endif 
95b4			 
95b4			;if BASE_SC114 
95b4			;baseram:     equ    endofcode 
95b4			;endif 
95b4			 
95b4			 
95b4			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
95b4			 
95b4			; start system 
95b4			 
95b4			coldstart: 
95b4				; set sp 
95b4				; di/ei 
95b4			 
95b4 f3				di 
95b5 31 00 f0			ld sp, tos 
95b8 cd 9b e3			call init_nmi 
95bb			;	ei 
95bb			 
95bb				; init spinner 
95bb 3e 00			ld a,0 
95bd 32 bd eb			ld (display_active), a 
95c0			 
95c0				; disable breakpoint by default 
95c0			 
95c0				;ld a,'*' 
95c0			;	ld a,' ' 
95c0			;	ld (os_view_disable),a 
95c0			 
95c0				; set break point vector as new break point on or off 
95c0 cd 52 93			call bp_off 
95c3			 
95c3			 
95c3				; default the parse vector to just a RET 
95c3 3e c9			ld a, $c9 
95c5 32 6c ee			ld (parse_vector), a 
95c8			 
95c8				; init hardware 
95c8			 
95c8				; init keyboard and screen hardware 
95c8			 
95c8 cd 1f 80			call hardware_init 
95cb			 
95cb			 
95cb cd f0 89			call delay1s 
95ce 3e 58			ld a, display_row_3+8 
95d0 11 03 80			ld de, buildtime 
95d3 cd be 8a			call str_at_display 
95d6 cd ce 8a			call update_display 
95d9			 
95d9 cd f0 89			call delay1s 
95dc cd f0 89			call delay1s 
95df cd f0 89			call delay1s 
95e2			 
95e2				; detect if any keys are held down to enable breakpoints at start up 
95e2			 
95e2 cd 57 e4			call cin  
95e5 fe 00			cp 0 
95e7 28 03			jr z, .nokeys 
95e9			 
95e9				;call hardware_diags 
95e9 cd 3b 92			call config 
95ec			 
95ec			;	ld de, .bpen 
95ec			;	ld a, display_row_4 
95ec			;	call str_at_display 
95ec			;	call update_display 
95ec			; 
95ec			;	ld a,0 
95ec			;	ld (os_view_disable),a 
95ec			; 
95ec			;.bpwait: 
95ec			;	call cin 
95ec			;	cp 0 
95ec			;	jr z, .bpwait 
95ec			;	jr .nokeys 
95ec			; 
95ec			; 
95ec			;.bpen:  db "Break points enabled!",0 
95ec			 
95ec			 
95ec			 
95ec			 
95ec			 
95ec			 
95ec			.nokeys: 
95ec			 
95ec			 
95ec				 
95ec			 
95ec			;jp  testkey 
95ec			 
95ec			;call storage_get_block_0 
95ec			; 
95ec			;ld hl, 0 
95ec			;ld de, store_page 
95ec			;call storage_read_block 
95ec			 
95ec				 
95ec			;ld hl, 10 
95ec			;ld de, store_page 
95ec			;call storage_read_block 
95ec			 
95ec			 
95ec			 
95ec			 
95ec			 
95ec			;stop:	nop 
95ec			;	jp stop 
95ec			 
95ec			 
95ec			 
95ec			main: 
95ec cd ac 8a			call clear_display 
95ef cd ce 8a			call update_display 
95f2			 
95f2			 
95f2			 
95f2			;	call testlcd 
95f2			 
95f2			 
95f2			 
95f2 cd 7a 9d			call forth_init 
95f5			 
95f5			 
95f5			warmstart: 
95f5 cd 50 9d			call forth_warmstart 
95f8			 
95f8				; run startup word load 
95f8			        ; TODO prevent this running at warmstart after crash  
95f8			 
95f8				if STARTUP_ENABLE 
95f8			 
95f8					if STARTUP_V1 
95f8			 
95f8						if STORAGE_SE 
95f8							call forth_autoload 
95f8						endif 
95f8 cd eb e2					call forth_startup 
95fb					endif 
95fb			 
95fb					if STARTUP_V2 
95fb			 
95fb						if STORAGE_SE 
95fb							call forth_autoload 
95fb						else 
95fb							call forth_startup 
95fb						endif 
95fb			 
95fb			 
95fb					endif 
95fb			 
95fb				endif 
95fb			 
95fb			warmstart_afterauto: 
95fb			 
95fb				; show free memory after boot 
95fb 11 98 96			ld de, freeram 
95fe 3e 00			ld a, display_row_1 
9600 cd be 8a			call str_at_display 
9603			 
9603				; get current heap start after loading any uwords 
9603			 
9603				;ld de, (os_last_new_uword) 
9603				;ex de, hl 
9603			 
9603			; Or use heap_size word???? 
9603				;ld hl, heap_end 
9603				;ld hl, heap_size 
9603				;ld de, topusermem 
9603				;ld de, heap_start 
9603 ed 5b 70 e4			ld de, (free_list )      
9607 21 93 e2				ld hl, heap_end 
960a ed 52			sbc hl, de 
960c				;push hl 
960c				;ld a,h	         	 
960c				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
960c				;call hexout 
960c			   	;pop hl 
960c			; 
960c			;	ld a,l 
960c			;	ld hl, os_word_scratch+2 
960c			;	call hexout 
960c			;	ld hl, os_word_scratch+4 
960c			;	ld a, 0 
960c			;	ld (hl),a 
960c eb				ex de, hl 
960d 21 bd e5			ld hl, os_word_scratch 
9610 cd dd 8f			call uitoa_16 
9613			 
9613			 
9613 11 bd e5			ld de, os_word_scratch 
9616 3e 0d			ld a, display_row_1 + 13 
9618 cd be 8a			call str_at_display 
961b cd ce 8a			call update_display 
961e			 
961e			 
961e				;call demo 
961e			 
961e			 
961e				; init scratch input area for cli commands 
961e			 
961e 21 df e5			ld hl, os_cli_cmd 
9621			;	ld a,0 
9621 36 00			ld (hl),0 
9623 23				inc hl 
9624 36 00			ld (hl),0 
9626			 
9626 3e 00			ld a,0 
9628 32 de e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
962b			 
962b 32 db e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
962e 32 dc e5			ld (os_cur_ptr+1),a	 
9631			 
9631 32 bd e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
9634 32 be e5			ld (os_word_scratch+1),a	 
9637				 
9637			 
9637				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9637 21 df e5			ld hl, os_cli_cmd 
963a			 
963a			;	ld a, 0		 ; init cli input 
963a 36 00			ld (hl), 0 
963c 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
963e			cli: 
963e				; show cli prompt 
963e				;push af 
963e				;ld a, 0 
963e				;ld de, prompt 
963e				;call str_at_display 
963e			 
963e				;call update_display 
963e				;pop af 
963e				;inc a 
963e				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
963e			 
963e			.lastrecall: 
963e			 
963e 0e 00			ld c, 0 
9640 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9642 1e 28			ld e, 40 
9644			 
9644 21 df e5			ld hl, os_cli_cmd 
9647			 
9647				STACKFRAME OFF $fefe $9f9f 
9647				if DEBUG_STACK_IMB 
9647					if OFF 
9647						exx 
9647						ld de, $fefe 
9647						ld a, d 
9647						ld hl, curframe 
9647						call hexout 
9647						ld a, e 
9647						ld hl, curframe+2 
9647						call hexout 
9647						ld hl, $fefe 
9647						push hl 
9647						ld hl, $9f9f 
9647						push hl 
9647						exx 
9647					endif 
9647				endif 
9647			endm 
# End of macro STACKFRAME
9647			 
9647 cd 03 8d			call input_str 
964a			 
964a				STACKFRAMECHK OFF $fefe $9f9f 
964a				if DEBUG_STACK_IMB 
964a					if OFF 
964a						exx 
964a						ld hl, $9f9f 
964a						pop de   ; $9f9f 
964a						call cmp16 
964a						jr nz, .spnosame 
964a						ld hl, $fefe 
964a						pop de   ; $fefe 
964a						call cmp16 
964a						jr z, .spfrsame 
964a						.spnosame: call showsperror 
964a						.spfrsame: nop 
964a						exx 
964a					endif 
964a				endif 
964a			endm 
# End of macro STACKFRAMECHK
964a			 
964a			 
964a				; check to see if last line recall has been requested 
964a			 
964a			if EDIT_V2 
964a fe 05			cp KEY_UP 
964c 20 0f			jr nz, .noexecline 
964e			 
964e 11 df e5			ld de, os_cli_cmd 
9651 21 de e6			ld hl, os_last_cmd 
9654 01 ff 00			ld bc, 255 
9657 ed b0			ldir 
9659 3e 00			ld a, 0 
965b 18 e1			jr .lastrecall 
965d			endif 
965d			 
965d			.noexecline: 
965d				; no so exec the line		 
965d			 
965d				; copy input to last command 
965d			 
965d 21 df e5			ld hl, os_cli_cmd 
9660 11 de e6			ld de, os_last_cmd 
9663 01 ff 00			ld bc, 255 
9666 ed b0			ldir 
9668			 
9668				; wipe current buffer 
9668			 
9668			;	ld a, 0 
9668			;	ld hl, os_cli_cmd 
9668			;	ld de, os_cli_cmd+1 
9668			;	ld bc, 254 
9668			;	ldir 
9668				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9668			;	call strcpy 
9668			;	ld a, 0 
9668			;	ld (hl), a 
9668			;	inc hl 
9668			;	ld (hl), a 
9668			;	inc hl 
9668			;	ld (hl), a 
9668			 
9668				; switch frame buffer to program  
9668			 
9668 21 07 ed				ld hl, display_fb1 
966b 22 c3 eb				ld (display_fb_active), hl 
966e			 
966e			;	nop 
966e				STACKFRAME ON $fbfe $8f9f 
966e				if DEBUG_STACK_IMB 
966e					if ON 
966e						exx 
966e						ld de, $fbfe 
966e						ld a, d 
966e						ld hl, curframe 
966e						call hexout 
966e						ld a, e 
966e						ld hl, curframe+2 
966e						call hexout 
966e						ld hl, $fbfe 
966e						push hl 
966e						ld hl, $8f9f 
966e						push hl 
966e						exx 
966e					endif 
966e				endif 
966e			endm 
# End of macro STACKFRAME
966e				; first time into the parser so pass over the current scratch pad 
966e 21 df e5			ld hl,os_cli_cmd 
9671				; tokenise the entered statement(s) in HL 
9671 cd f0 9d			call forthparse 
9674			        ; exec forth statements in top of return stack 
9674 cd 28 9e			call forthexec 
9677				;call forthexec_cleanup 
9677			;	call parsenext 
9677			 
9677				STACKFRAMECHK ON $fbfe $8f9f 
9677				if DEBUG_STACK_IMB 
9677					if ON 
9677						exx 
9677						ld hl, $8f9f 
9677						pop de   ; $8f9f 
9677						call cmp16 
9677						jr nz, .spnosame 
9677						ld hl, $fbfe 
9677						pop de   ; $fbfe 
9677						call cmp16 
9677						jr z, .spfrsame 
9677						.spnosame: call showsperror 
9677						.spfrsame: nop 
9677						exx 
9677					endif 
9677				endif 
9677			endm 
# End of macro STACKFRAMECHK
9677				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9677			 
9677 3e 78			ld a, display_row_4 
9679 11 a9 96			ld de, endprog 
967c			 
967c cd ce 8a			call update_display		 
967f			 
967f cd 3f 99			call next_page_prompt 
9682			 
9682				; switch frame buffer to cli 
9682			 
9682 21 a8 ed				ld hl, display_fb0 
9685 22 c3 eb				ld (display_fb_active), hl 
9688			 
9688			 
9688 cd ac 8a		        call clear_display 
968b cd ce 8a			call update_display		 
968e			 
968e 21 df e5			ld hl, os_cli_cmd 
9691			 
9691			;	ld a, 0		 ; init cli input 
9691 36 00			ld (hl), 0 
9693			 
9693				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9693			 
9693				; now on last line 
9693			 
9693				; TODO scroll screen up 
9693			 
9693				; TODO instead just clear screen and place at top of screen 
9693			 
9693			;	ld a, 0 
9693			;	ld (f_cursor_ptr),a 
9693			 
9693				;call clear_display 
9693				;call update_display 
9693			 
9693				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9693 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9695 c3 3e 96			jp cli 
9698			 
9698 .. 00		freeram: db "Free bytes: ",0 
96a5 ..			asc: db "1A2F" 
96a9 .. 00		endprog: db "End prog...",0 
96b5			 
96b5			testenter2:   
96b5 21 ea e2			ld hl,scratch+50 
96b8 22 db e5			ld (os_cur_ptr),hl 
96bb c3 3e 96			jp cli 
96be			 
96be			testenter:  
96be			 
96be 21 a5 96			ld hl,asc 
96c1			;	ld a,(hl) 
96c1			;	call nibble2val 
96c1 cd 28 8f			call get_byte 
96c4			 
96c4			 
96c4			;	ld a,(hl) 
96c4			;	call atohex 
96c4			 
96c4			;	call fourehexhl 
96c4 32 ea e2			ld (scratch+50),a 
96c7			 
96c7			 
96c7			 
96c7 21 a7 96			ld hl,asc+2 
96ca			;	ld a, (hl) 
96ca			;	call nibble2val 
96ca cd 28 8f			call get_byte 
96cd			 
96cd			;	call fourehexhl 
96cd 32 ec e2			ld (scratch+52),a 
96d0				 
96d0 21 ea e2			ld hl,scratch+50 
96d3 22 db e5			ld (os_cur_ptr),hl 
96d6 c3 3e 96			jp cli 
96d9			 
96d9			enter:	 
96d9 3a bc e2			ld a,(scratch+4) 
96dc fe 00			cp 0 
96de 28 0c			jr z, .entercont 
96e0				; no, not a null term line so has an address to work out.... 
96e0			 
96e0 21 ba e2			ld hl,scratch+2 
96e3 cd 88 8f			call get_word_hl 
96e6			 
96e6 22 db e5			ld (os_cur_ptr),hl	 
96e9 c3 3e 96			jp cli 
96ec			 
96ec			 
96ec			.entercont:  
96ec			 
96ec 21 ba e2			ld hl, scratch+2 
96ef cd 28 8f			call get_byte 
96f2			 
96f2 2a db e5		   	ld hl,(os_cur_ptr) 
96f5 77					ld (hl),a 
96f6 23					inc hl 
96f7 22 db e5				ld (os_cur_ptr),hl 
96fa				 
96fa			; get byte  
96fa			 
96fa			 
96fa c3 3e 96			jp cli 
96fd			 
96fd			 
96fd			; basic monitor support 
96fd			 
96fd			monitor: 
96fd				;  
96fd cd ac 8a			call clear_display 
9700 3e 00			ld a, 0 
9702 11 56 97			ld de, .monprompt 
9705 cd be 8a			call str_at_display 
9708 cd ce 8a			call update_display 
970b			 
970b				; get a monitor command 
970b			 
970b 0e 00			ld c, 0     ; entry at top left 
970d 16 64			ld d, 100   ; max buffer size 
970f 1e 0f			ld e, 15    ; input scroll area 
9711			;	ld a, 0     ; init string 
9711 21 b6 e4			ld hl, os_input 
9714 36 00			ld (hl), 0 
9716 23				inc hl 
9717 36 00			ld (hl), 0 
9719 21 b6 e4			ld hl, os_input 
971c 3e 01			ld a, 1     ; init string 
971e cd 03 8d			call input_str 
9721			 
9721 cd ac 8a		        call clear_display 
9724 cd ce 8a			call update_display		 
9727			 
9727 3a b6 e4			ld a, (os_input) 
972a cd 25 90			call toUpper 
972d fe 48		        cp 'H' 
972f ca ca 97		        jp z, .monhelp 
9732 fe 44			cp 'D'		; dump 
9734 ca fd 97			jp z, .mondump	 
9737 fe 43			cp 'C'		; dump 
9739 ca 17 98			jp z, .moncdump	 
973c fe 4d			cp 'M'		; dump 
973e ca 58 97			jp z, .moneditstart 
9741 fe 55			cp 'U'		; dump 
9743 ca 64 97			jp z, .monedit	 
9746 fe 47			cp 'G'		; dump 
9748 ca f3 97			jp z, .monjump 
974b fe 42			cp 'B'		; forth breakpoint 
974d cc 58 93			call z, break_point_state 
9750 fe 51			cp 'Q'		; dump 
9752 c8				ret z	 
9753			 
9753			 
9753				; TODO "S" to access symbol by name and not need the address 
9753				; TODO "F" to find a string in memory 
9753			 
9753 c3 fd 96			jp monitor 
9756			 
9756 .. 00		.monprompt: db ">", 0 
9758			 
9758			.moneditstart: 
9758				; get starting address 
9758			 
9758 21 b8 e4			ld hl,os_input+2 
975b cd 88 8f			call get_word_hl 
975e			 
975e 22 db e5			ld (os_cur_ptr),hl	 
9761			 
9761 c3 fd 96			jp monitor 
9764			 
9764			.monedit: 
9764				; get byte to load 
9764			 
9764 21 b8 e4			ld hl,os_input+2 
9767 cd 28 8f			call get_byte 
976a			 
976a				; get address to update 
976a 2a db e5			ld hl, (os_cur_ptr) 
976d			 
976d				; update byte 
976d			 
976d 77				ld (hl), a 
976e			 
976e				; move to next address and save it 
976e			 
976e 23				inc hl 
976f 22 db e5			ld (os_cur_ptr),hl	 
9772			 
9772 c3 fd 96			jp monitor 
9775			 
9775			 
9775 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9789 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
97a5 .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
97c3 .. 00		.monhelptext4:  db "Q-Quit",0 
97ca			        
97ca			.monhelp: 
97ca 3e 00			ld a, display_row_1 
97cc 11 75 97		        ld de, .monhelptext1 
97cf			 
97cf cd be 8a			call str_at_display 
97d2 3e 28			ld a, display_row_2 
97d4 11 89 97		        ld de, .monhelptext2 
97d7					 
97d7 cd be 8a			call str_at_display 
97da 3e 50			ld a, display_row_3 
97dc 11 a5 97		        ld de, .monhelptext3 
97df					 
97df cd be 8a			call str_at_display 
97e2 3e 78			ld a, display_row_4 
97e4 11 c3 97		        ld de, .monhelptext4 
97e7 cd be 8a			call str_at_display 
97ea			 
97ea cd ce 8a			call update_display		 
97ed			 
97ed cd 3f 99			call next_page_prompt 
97f0 c3 fd 96			jp monitor 
97f3			 
97f3			.monjump:    
97f3 21 b8 e4			ld hl,os_input+2 
97f6 cd 88 8f			call get_word_hl 
97f9			 
97f9 e9				jp (hl) 
97fa c3 fd 96			jp monitor 
97fd			 
97fd			.mondump:    
97fd 21 b8 e4			ld hl,os_input+2 
9800 cd 88 8f			call get_word_hl 
9803			 
9803 22 db e5			ld (os_cur_ptr),hl	 
9806 cd 4b 98			call dumpcont 
9809 3e 78			ld a, display_row_4 
980b 11 a9 96			ld de, endprog 
980e			 
980e cd ce 8a			call update_display		 
9811			 
9811 cd 3f 99			call next_page_prompt 
9814 c3 fd 96			jp monitor 
9817			.moncdump: 
9817 cd 4b 98			call dumpcont 
981a 3e 78			ld a, display_row_4 
981c 11 a9 96			ld de, endprog 
981f			 
981f cd ce 8a			call update_display		 
9822			 
9822 cd 3f 99			call next_page_prompt 
9825 c3 fd 96			jp monitor 
9828			 
9828			 
9828			; TODO symbol access  
9828			 
9828			.symbols:     ;; A list of symbols that can be called up  
9828 a8 ed			dw display_fb0 
982a .. 00			db "fb0",0  
982e 71 ea		     	dw store_page 
9830 .. 00			db "store_page",0 
983b			 
983b			 
983b			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
983b			 
983b 3a b9 e2			ld a,(scratch+1) 
983e fe 00			cp 0 
9840 28 09			jr z, dumpcont 
9842			 
9842				; no, not a null term line so has an address to work out.... 
9842			 
9842 21 ba e2			ld hl,scratch+2 
9845 cd 88 8f			call get_word_hl 
9848			 
9848 22 db e5			ld (os_cur_ptr),hl	 
984b			 
984b			 
984b			 
984b			dumpcont: 
984b			 
984b				; dump bytes at ptr 
984b			 
984b			 
984b 3e 00			ld a, display_row_1 
984d 2a c3 eb			ld hl, (display_fb_active) 
9850 cd d6 8c			call addatohl 
9853 cd 7b 98			call .dumpbyterow 
9856			 
9856 3e 28			ld a, display_row_2 
9858 2a c3 eb			ld hl, (display_fb_active) 
985b cd d6 8c			call addatohl 
985e cd 7b 98			call .dumpbyterow 
9861			 
9861			 
9861 3e 50			ld a, display_row_3 
9863 2a c3 eb			ld hl, (display_fb_active) 
9866 cd d6 8c			call addatohl 
9869 cd 7b 98			call .dumpbyterow 
986c			 
986c 3e 78			ld a, display_row_4 
986e 2a c3 eb			ld hl, (display_fb_active) 
9871 cd d6 8c			call addatohl 
9874 cd 7b 98			call .dumpbyterow 
9877			 
9877 cd ce 8a			call update_display 
987a			;		jp cli 
987a c9				ret 
987b			 
987b			.dumpbyterow: 
987b			 
987b				;push af 
987b			 
987b e5				push hl 
987c			 
987c				; calc where to poke the ascii 
987c			if display_cols == 20 
987c				ld a, 16 
987c			else 
987c 3e 1f			ld a, 31 
987e			endif 
987e			 
987e cd d6 8c			call addatohl 
9881 22 bd e5			ld (os_word_scratch),hl  		; save pos for later 
9884			 
9884			 
9884			; display decoding address 
9884 2a db e5		   	ld hl,(os_cur_ptr) 
9887			 
9887 7c				ld a,h 
9888 e1				pop hl 
9889 e5				push hl 
988a			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
988a cd d2 8e			call hexout 
988d 2a db e5		   	ld hl,(os_cur_ptr) 
9890			 
9890 7d				ld a,l 
9891 e1				pop hl 
9892 23				inc hl 
9893 23				inc hl 
9894 e5				push hl 
9895			;	ld hl, os_word_scratch+2 
9895 cd d2 8e			call hexout 
9898 e1				pop hl 
9899 23				inc hl 
989a 23				inc hl 
989b				;ld hl, os_word_scratch+4 
989b			;	ld a, ':' 
989b 36 3a			ld (hl),':' 
989d 23				inc hl 
989e				;ld a, 0 
989e				;ld (hl),a 
989e				;ld de, os_word_scratch 
989e				;pop af 
989e				;push af 
989e			;		ld a, display_row_2 
989e			;		call str_at_display 
989e			;		call update_display 
989e			 
989e			 
989e			;pop af 
989e			;	add 5 
989e			 
989e			if display_cols == 20 
989e				ld b, 4 
989e			else 
989e 06 08			ld b, 8 
98a0			endif	 
98a0			 
98a0			.dumpbyte: 
98a0 c5				push bc 
98a1 e5				push hl 
98a2			 
98a2			 
98a2 2a db e5		   	ld hl,(os_cur_ptr) 
98a5 7e					ld a,(hl) 
98a6			 
98a6					; poke the ascii to display 
98a6 2a bd e5				ld hl,(os_word_scratch) 
98a9 77					ld (hl),a 
98aa 23					inc hl 
98ab 22 bd e5				ld (os_word_scratch),hl 
98ae			 
98ae					 
98ae			 
98ae			 
98ae e1					pop hl 
98af e5					push hl 
98b0			 
98b0 cd d2 8e				call hexout 
98b3			 
98b3					 
98b3 2a db e5		   	ld hl,(os_cur_ptr) 
98b6 23				inc hl 
98b7 22 db e5		   	ld (os_cur_ptr),hl 
98ba			 
98ba e1					pop hl 
98bb 23					inc hl 
98bc 23					inc hl 
98bd 23					inc hl 
98be			 
98be			 
98be			 
98be					;ld a,0 
98be					;ld (os_word_scratch+2),a 
98be					;pop af 
98be					;push af 
98be			 
98be					;ld de, os_word_scratch 
98be					;call str_at_display 
98be			;		call update_display 
98be			;		pop af 
98be c1					pop bc 
98bf c6 03				add 3 
98c1 10 dd			djnz .dumpbyte 
98c3			 
98c3				 
98c3			 
98c3 c9				ret 
98c4			 
98c4			jump:	 
98c4			 
98c4 21 ba e2			ld hl,scratch+2 
98c7 cd 88 8f			call get_word_hl 
98ca				;ld hl,(scratch+2) 
98ca				;call fourehexhl 
98ca			 
98ca 22 db e5			ld (os_cur_ptr),hl	 
98cd			 
98cd e9				jp (hl) 
98ce			 
98ce			 
98ce			 
98ce			; TODO implement a basic monitor mode to start with 
98ce			 
98ce			 
98ce			 
98ce			 
98ce			 
98ce			 
98ce			 
98ce			 
98ce			 
98ce			; testing and demo code during development 
98ce			 
98ce			 
98ce .. 00		str1: db "Enter some text...",0 
98e1 .. 00		clear: db "                    ",0 
98f6			 
98f6			demo: 
98f6			 
98f6			 
98f6			 
98f6			;	call update_display 
98f6			 
98f6				; init scratch input area for testing 
98f6 21 b8 e2			ld hl, scratch	 
98f9			;	ld a,0 
98f9 36 00			ld (hl),0 
98fb			 
98fb			 
98fb 3e 28		            LD   A, display_row_2 
98fd			;            CALL fLCD_Pos       ;Position cursor to location in A 
98fd 11 ce 98		            LD   DE, str1 
9900 cd be 8a			call str_at_display 
9903			 
9903			;            CALL fLCD_Str       ;Display string pointed to by DE 
9903			cloop:	 
9903 3e 50		            LD   A, display_row_3 
9905			;            CALL fLCD_Pos       ;Position cursor to location in A 
9905 11 e1 98		            LD   DE, clear 
9908			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9908 cd be 8a				call str_at_display 
990b 3e 78			ld a, display_row_4 
990d 11 3b 99			ld de, prompt 
9910			 
9910 cd be 8a				call str_at_display 
9913 cd ce 8a			call update_display 
9916			 
9916 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9918 16 0a			ld d, 10 
991a 21 b8 e2			ld hl, scratch	 
991d cd 03 8d			call input_str 
9920			 
9920			;	call clear_display 
9920			;'	call update_display 
9920			 
9920 3e 00		            LD   A, display_row_1 
9922			;            CALL fLCD_Pos       ;Position cursor to location in A 
9922 11 e1 98		            LD   DE, clear 
9925 cd be 8a				call str_at_display 
9928			;            CALL fLCD_Str       ;Display string pointed to by DE 
9928 3e 00		            LD   A, display_row_1 
992a			;            CALL fLCD_Pos       ;Position cursor to location in A 
992a 11 b8 e2		            LD   DE, scratch 
992d			;            CALL fLCD_Str       ;Display string pointed to by DE 
992d cd be 8a				call str_at_display 
9930 cd ce 8a			call update_display 
9933			 
9933			;		ld a,0 
9933 21 b8 e2			ld hl, scratch 
9936 36 00			ld (hl),0 
9938			 
9938			;	nop 
9938 c3 03 99			jp cloop 
993b			 
993b			 
993b			 
993b			; OS Prompt 
993b			 
993b .. 00		prompt: db ">",0 
993d .. 00		endprg: db "?",0 
993f			 
993f			 
993f			; handy next page prompt 
993f			next_page_prompt: 
993f e5				push hl 
9940 d5				push de 
9941 f5				push af 
9942 c5				push bc 
9943			 
9943 3e 9f			ld a,display_row_4 + display_cols - 1 
9945 11 3d 99		        ld de, endprg 
9948 cd be 8a			call str_at_display 
994b cd ce 8a			call update_display 
994e cd 51 e4			call cin_wait 
9951 c1				pop bc 
9952 f1				pop af 
9953 d1				pop de 
9954 e1				pop hl 
9955			 
9955			 
9955 c9				ret 
9956			 
9956			 
9956			; forth parser 
9956			 
9956			; My forth kernel 
9956			include "forth_kernel.asm" 
9956			; 
9956			; kernel to the forth OS 
9956			 
9956			DS_TYPE_STR: equ 1     ; string type 
9956			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9956			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9956			DS_TYPE_CONST: equ 4     ; string type that won't be freed on a POP 
9956			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9956			 
9956			FORTH_PARSEV1: equ 0 
9956			FORTH_PARSEV2: equ 0 
9956			FORTH_PARSEV3: equ 0 
9956			FORTH_PARSEV4: equ 0 
9956			FORTH_PARSEV5: equ 0 
9956			FORTH_PARSEV6: equ 1 
9956			 
9956			;if FORTH_PARSEV5 
9956			;	FORTH_END_BUFFER: equ 0 
9956			;else 
9956			FORTH_END_BUFFER: equ 127 
9956			;endif 
9956			 
9956			FORTH_TRUE: equ 1 
9956			FORTH_FALSE: equ 0 
9956			 
9956			if FORTH_PARSEV4 
9956			include "forth_stackops.asm" 
9956			endif 
9956			 
9956			if FORTH_PARSEV5 
9956			include "forth_stackopsv5.asm" 
9956			endif 
9956			 
9956			if FORTH_PARSEV6 
9956			include "forth_stackopsv5.asm" 
9956			 
9956			; Stack operations for v5 parser on wards 
9956			; * DATA stack 
9956			; * LOOP stack 
9956			; * RETURN stack 
9956			 
9956			 
9956			 
9956			FORTH_CHK_DSP_UNDER: macro 
9956				push hl 
9956				push de 
9956				ld hl,(cli_data_sp) 
9956				ld de, cli_data_stack 
9956				call cmp16 
9956				jp c, fault_dsp_under 
9956				pop de 
9956				pop hl 
9956				endm 
9956			 
9956			 
9956			FORTH_CHK_RSP_UNDER: macro 
9956				push hl 
9956				push de 
9956				ld hl,(cli_ret_sp) 
9956				ld de, cli_ret_stack 
9956				call cmp16 
9956				jp c, fault_rsp_under 
9956				pop de 
9956				pop hl 
9956				endm 
9956			 
9956			FORTH_CHK_LOOP_UNDER: macro 
9956				push hl 
9956				push de 
9956				ld hl,(cli_loop_sp) 
9956				ld de, cli_loop_stack 
9956				call cmp16 
9956				jp c, fault_loop_under 
9956				pop de 
9956				pop hl 
9956				endm 
9956			 
9956			FORTH_ERR_TOS_NOTSTR: macro 
9956				; TOSO might need more for checks when used 
9956				push af 
9956				ld a,(hl) 
9956				cp DS_TYPE_STR 
9956				jp nz, type_faultn   
9956				pop af 
9956				endm 
9956			 
9956			FORTH_ERR_TOS_NOTNUM: macro 
9956				push af 
9956				ld a,(hl) 
9956				cp DS_TYPE_INUM 
9956				jp nz, type_faultn   
9956				pop af 
9956				endm 
9956			 
9956			 
9956			; increase data stack pointer and save hl to it 
9956				 
9956			FORTH_DSP_NEXT: macro 
9956				call macro_forth_dsp_next 
9956				endm 
9956			 
9956			 
9956			macro_forth_dsp_next: 
9956				if DEBUG_FORTH_STACK_GUARD 
9956 cd c3 e0				call check_stacks 
9959				endif 
9959 e5				push hl 
995a d5				push de 
995b eb				ex de,hl 
995c 2a e5 e9			ld hl,(cli_data_sp) 
995f 23				inc hl 
9960 23				inc hl 
9961			 
9961			; PARSEV5 
9961 23				inc hl 
9962 22 e5 e9			ld (cli_data_sp),hl 
9965 73				ld (hl), e 
9966 23				inc hl 
9967 72				ld (hl), d 
9968 d1				pop de 
9969 e1				pop hl 
996a				if DEBUG_FORTH_STACK_GUARD 
996a cd c3 e0				call check_stacks 
996d				endif 
996d c9				ret 
996e			 
996e			 
996e			; increase ret stack pointer and save hl to it 
996e				 
996e			FORTH_RSP_NEXT: macro 
996e				call macro_forth_rsp_next 
996e				endm 
996e			 
996e			macro_forth_rsp_next: 
996e				if DEBUG_FORTH_STACK_GUARD 
996e cd c3 e0				call check_stacks 
9971				endif 
9971 e5				push hl 
9972 d5				push de 
9973 eb				ex de,hl 
9974 2a e9 e9			ld hl,(cli_ret_sp) 
9977 23				inc hl 
9978 23				inc hl 
9979 22 e9 e9			ld (cli_ret_sp),hl 
997c 73				ld (hl), e 
997d 23				inc hl 
997e 72				ld (hl), d 
997f d1				pop de 
9980 e1				pop hl 
9981				if DEBUG_FORTH_STACK_GUARD 
9981 cd c3 e0				call check_stacks 
9984				endif 
9984 c9				ret 
9985			 
9985			; get current ret stack pointer and save to hl  
9985				 
9985			FORTH_RSP_TOS: macro 
9985				call macro_forth_rsp_tos 
9985				endm 
9985			 
9985			macro_forth_rsp_tos: 
9985				;push de 
9985 2a e9 e9			ld hl,(cli_ret_sp) 
9988 cd c0 99			call loadhlptrtohl 
998b				;ld e, (hl) 
998b				;inc hl 
998b				;ld d, (hl) 
998b				;ex de, hl 
998b					if DEBUG_FORTH_WORDS 
998b			;			DMARK "RST" 
998b						CALLMONITOR 
998b cd 6f ee			call debug_vector  
998e				endm  
# End of macro CALLMONITOR
998e					endif 
998e				;pop de 
998e c9				ret 
998f			 
998f			; pop ret stack pointer 
998f				 
998f			FORTH_RSP_POP: macro 
998f				call macro_forth_rsp_pop 
998f				endm 
998f			 
998f			 
998f			macro_forth_rsp_pop: 
998f				if DEBUG_FORTH_STACK_GUARD 
998f			;		DMARK "RPP" 
998f cd c3 e0				call check_stacks 
9992					FORTH_CHK_RSP_UNDER 
9992 e5				push hl 
9993 d5				push de 
9994 2a e9 e9			ld hl,(cli_ret_sp) 
9997 11 a3 e9			ld de, cli_ret_stack 
999a cd f4 8c			call cmp16 
999d da da e1			jp c, fault_rsp_under 
99a0 d1				pop de 
99a1 e1				pop hl 
99a2				endm 
# End of macro FORTH_CHK_RSP_UNDER
99a2				endif 
99a2 e5				push hl 
99a3 2a e9 e9			ld hl,(cli_ret_sp) 
99a6			 
99a6			 
99a6				if FORTH_ENABLE_FREE 
99a6			 
99a6					; get pointer 
99a6			 
99a6					push de 
99a6					push hl 
99a6			 
99a6					ld e, (hl) 
99a6					inc hl 
99a6					ld d, (hl) 
99a6			 
99a6					ex de, hl 
99a6					call free 
99a6			 
99a6					pop hl 
99a6					pop de 
99a6			 
99a6			 
99a6				endif 
99a6			 
99a6			 
99a6 2b				dec hl 
99a7 2b				dec hl 
99a8 22 e9 e9			ld (cli_ret_sp), hl 
99ab				; do stack underflow checks 
99ab e1				pop hl 
99ac				if DEBUG_FORTH_STACK_GUARD 
99ac cd c3 e0				call check_stacks 
99af					FORTH_CHK_RSP_UNDER 
99af e5				push hl 
99b0 d5				push de 
99b1 2a e9 e9			ld hl,(cli_ret_sp) 
99b4 11 a3 e9			ld de, cli_ret_stack 
99b7 cd f4 8c			call cmp16 
99ba da da e1			jp c, fault_rsp_under 
99bd d1				pop de 
99be e1				pop hl 
99bf				endm 
# End of macro FORTH_CHK_RSP_UNDER
99bf				endif 
99bf c9				ret 
99c0			 
99c0			 
99c0			 
99c0			; routine to load word pointed to by hl into hl 
99c0			 
99c0			loadhlptrtohl: 
99c0			 
99c0 d5				push de 
99c1 5e				ld e, (hl) 
99c2 23				inc hl 
99c3 56				ld d, (hl) 
99c4 eb				ex de, hl 
99c5 d1				pop de 
99c6			 
99c6 c9				ret 
99c7			 
99c7			 
99c7			 
99c7			 
99c7			 
99c7			; push a number held in HL onto the data stack 
99c7			; entry point for pushing a value when already in hl used in function above 
99c7			 
99c7			forth_push_numhl: 
99c7			 
99c7 e5				push hl    ; save value to push 
99c8			 
99c8			if DEBUG_FORTH_PUSH 
99c8				; see if disabled 
99c8			 
99c8			 
99c8 f5				push af 
99c9 3a 6f ee			ld a,(debug_vector) 
99cc fe c9			cp $c9   ; ret 
99ce			;	ld a, (os_view_disable) 
99ce			;	cp '*' 
99ce 28 33			jr z, .pskip2 
99d0 e5				push hl 
99d1 e5			push hl 
99d2 cd ac 8a			call clear_display 
99d5 e1			pop hl 
99d6 7c				ld a,h 
99d7 21 bd e5			ld hl, os_word_scratch 
99da cd d2 8e			call hexout 
99dd e1				pop hl 
99de 7d				ld a,l 
99df 21 bf e5			ld hl, os_word_scratch+2 
99e2 cd d2 8e			call hexout 
99e5			 
99e5 21 c1 e5			ld hl, os_word_scratch+4 
99e8			;	ld a,0 
99e8 36 00			ld (hl),0 
99ea 11 bd e5			ld de,os_word_scratch 
99ed 3e 28				ld a, display_row_2 
99ef cd be 8a				call str_at_display 
99f2 11 c0 d2			ld de, .push_num 
99f5 3e 00			ld a, display_row_1 
99f7			 
99f7 cd be 8a				call str_at_display 
99fa			 
99fa			 
99fa cd ce 8a			call update_display 
99fd cd f0 89			call delay1s 
9a00 cd f0 89			call delay1s 
9a03			.pskip2:  
9a03			 
9a03 f1				pop af 
9a04			endif	 
9a04			 
9a04			 
9a04				FORTH_DSP_NEXT 
9a04 cd 56 99			call macro_forth_dsp_next 
9a07				endm 
# End of macro FORTH_DSP_NEXT
9a07			 
9a07 2a e5 e9			ld hl, (cli_data_sp) 
9a0a			 
9a0a				; save item type 
9a0a			;	ld a,  DS_TYPE_INUM 
9a0a 36 02			ld (hl), DS_TYPE_INUM 
9a0c 23				inc hl 
9a0d			 
9a0d				; get word off stack 
9a0d d1				pop de 
9a0e				;ld a,e 
9a0e 73				ld (hl), e 
9a0f 23				inc hl 
9a10			;	ld a,d 
9a10 72				ld (hl), d 
9a11			 
9a11			if DEBUG_FORTH_PUSH 
9a11 2b				dec hl 
9a12 2b				dec hl 
9a13 2b				dec hl 
9a14						DMARK "PH5" 
9a14 f5				push af  
9a15 3a 29 9a			ld a, (.dmark)  
9a18 32 62 ee			ld (debug_mark),a  
9a1b 3a 2a 9a			ld a, (.dmark+1)  
9a1e 32 63 ee			ld (debug_mark+1),a  
9a21 3a 2b 9a			ld a, (.dmark+2)  
9a24 32 64 ee			ld (debug_mark+2),a  
9a27 18 03			jr .pastdmark  
9a29 ..			.dmark: db "PH5"  
9a2c f1			.pastdmark: pop af  
9a2d			endm  
# End of macro DMARK
9a2d				CALLMONITOR 
9a2d cd 6f ee			call debug_vector  
9a30				endm  
# End of macro CALLMONITOR
9a30			endif	 
9a30			 
9a30 c9				ret 
9a31			 
9a31			 
9a31			; Push a string to stack pointed to by hl 
9a31			 
9a31			forth_push_str: 
9a31			 
9a31			if DEBUG_FORTH_PUSH 
9a31						DMARK "PSQ" 
9a31 f5				push af  
9a32 3a 46 9a			ld a, (.dmark)  
9a35 32 62 ee			ld (debug_mark),a  
9a38 3a 47 9a			ld a, (.dmark+1)  
9a3b 32 63 ee			ld (debug_mark+1),a  
9a3e 3a 48 9a			ld a, (.dmark+2)  
9a41 32 64 ee			ld (debug_mark+2),a  
9a44 18 03			jr .pastdmark  
9a46 ..			.dmark: db "PSQ"  
9a49 f1			.pastdmark: pop af  
9a4a			endm  
# End of macro DMARK
9a4a				CALLMONITOR 
9a4a cd 6f ee			call debug_vector  
9a4d				endm  
# End of macro CALLMONITOR
9a4d			endif	 
9a4d			 
9a4d			 
9a4d			    
9a4d e5				push hl 
9a4e e5				push hl 
9a4f			 
9a4f			;	ld a, 0   ; find end of string 
9a4f cd 2e 90			call strlenz 
9a52			if DEBUG_FORTH_PUSH 
9a52						DMARK "PQ2" 
9a52 f5				push af  
9a53 3a 67 9a			ld a, (.dmark)  
9a56 32 62 ee			ld (debug_mark),a  
9a59 3a 68 9a			ld a, (.dmark+1)  
9a5c 32 63 ee			ld (debug_mark+1),a  
9a5f 3a 69 9a			ld a, (.dmark+2)  
9a62 32 64 ee			ld (debug_mark+2),a  
9a65 18 03			jr .pastdmark  
9a67 ..			.dmark: db "PQ2"  
9a6a f1			.pastdmark: pop af  
9a6b			endm  
# End of macro DMARK
9a6b				CALLMONITOR 
9a6b cd 6f ee			call debug_vector  
9a6e				endm  
# End of macro CALLMONITOR
9a6e			endif	 
9a6e eb				ex de, hl 
9a6f e1				pop hl   ; get ptr to start of string 
9a70			if DEBUG_FORTH_PUSH 
9a70						DMARK "PQ3" 
9a70 f5				push af  
9a71 3a 85 9a			ld a, (.dmark)  
9a74 32 62 ee			ld (debug_mark),a  
9a77 3a 86 9a			ld a, (.dmark+1)  
9a7a 32 63 ee			ld (debug_mark+1),a  
9a7d 3a 87 9a			ld a, (.dmark+2)  
9a80 32 64 ee			ld (debug_mark+2),a  
9a83 18 03			jr .pastdmark  
9a85 ..			.dmark: db "PQ3"  
9a88 f1			.pastdmark: pop af  
9a89			endm  
# End of macro DMARK
9a89				CALLMONITOR 
9a89 cd 6f ee			call debug_vector  
9a8c				endm  
# End of macro CALLMONITOR
9a8c			endif	 
9a8c 19				add hl,de 
9a8d			if DEBUG_FORTH_PUSH 
9a8d						DMARK "PQE" 
9a8d f5				push af  
9a8e 3a a2 9a			ld a, (.dmark)  
9a91 32 62 ee			ld (debug_mark),a  
9a94 3a a3 9a			ld a, (.dmark+1)  
9a97 32 63 ee			ld (debug_mark+1),a  
9a9a 3a a4 9a			ld a, (.dmark+2)  
9a9d 32 64 ee			ld (debug_mark+2),a  
9aa0 18 03			jr .pastdmark  
9aa2 ..			.dmark: db "PQE"  
9aa5 f1			.pastdmark: pop af  
9aa6			endm  
# End of macro DMARK
9aa6				CALLMONITOR 
9aa6 cd 6f ee			call debug_vector  
9aa9				endm  
# End of macro CALLMONITOR
9aa9			endif	 
9aa9			 
9aa9 2b				dec hl    ; see if there is an optional trailing double quote 
9aaa 7e				ld a,(hl) 
9aab fe 22			cp '"' 
9aad 20 02			jr nz, .strnoq 
9aaf			;	ld a, 0      ; get rid of double quote 
9aaf 36 00			ld (hl), 0 
9ab1 23			.strnoq: inc hl 
9ab2			 
9ab2			;	ld a, 0 
9ab2 36 00			ld (hl), 0     ; add null term and get rid of trailing double quote 
9ab4			 
9ab4 13				inc de ; add one for the type string 
9ab5 13				inc de ; add one for null term??? 
9ab6			 
9ab6				; tos is get string pointer again 
9ab6				; de contains space to allocate 
9ab6				 
9ab6 d5				push de 
9ab7			 
9ab7 eb				ex de, hl 
9ab8			 
9ab8				;push af 
9ab8			 
9ab8			if DEBUG_FORTH_PUSH 
9ab8						DMARK "PHm" 
9ab8 f5				push af  
9ab9 3a cd 9a			ld a, (.dmark)  
9abc 32 62 ee			ld (debug_mark),a  
9abf 3a ce 9a			ld a, (.dmark+1)  
9ac2 32 63 ee			ld (debug_mark+1),a  
9ac5 3a cf 9a			ld a, (.dmark+2)  
9ac8 32 64 ee			ld (debug_mark+2),a  
9acb 18 03			jr .pastdmark  
9acd ..			.dmark: db "PHm"  
9ad0 f1			.pastdmark: pop af  
9ad1			endm  
# End of macro DMARK
9ad1				CALLMONITOR 
9ad1 cd 6f ee			call debug_vector  
9ad4				endm  
# End of macro CALLMONITOR
9ad4			endif	 
9ad4 cd a2 90			call malloc	; on ret hl now contains allocated memory 
9ad7				if DEBUG_FORTH_MALLOC_GUARD 
9ad7 cc 18 d3				call z,malloc_error 
9ada				endif 
9ada			 
9ada				 
9ada c1				pop bc    ; get length 
9adb d1				pop de   ;  get string start    
9adc			 
9adc				; hl has destination from malloc 
9adc			 
9adc eb				ex de, hl    ; prep for ldir 
9add			 
9add d5				push de   ; save malloc area for DSP later 
9ade				;push hl   ; save malloc area for DSP later 
9ade			 
9ade			if DEBUG_FORTH_PUSH 
9ade						DMARK "PHc" 
9ade f5				push af  
9adf 3a f3 9a			ld a, (.dmark)  
9ae2 32 62 ee			ld (debug_mark),a  
9ae5 3a f4 9a			ld a, (.dmark+1)  
9ae8 32 63 ee			ld (debug_mark+1),a  
9aeb 3a f5 9a			ld a, (.dmark+2)  
9aee 32 64 ee			ld (debug_mark+2),a  
9af1 18 03			jr .pastdmark  
9af3 ..			.dmark: db "PHc"  
9af6 f1			.pastdmark: pop af  
9af7			endm  
# End of macro DMARK
9af7				CALLMONITOR 
9af7 cd 6f ee			call debug_vector  
9afa				endm  
# End of macro CALLMONITOR
9afa			endif	 
9afa			 
9afa			 
9afa ed b0			ldir 
9afc			 
9afc			 
9afc				; push malloc to data stack     macro?????  
9afc			 
9afc				FORTH_DSP_NEXT 
9afc cd 56 99			call macro_forth_dsp_next 
9aff				endm 
# End of macro FORTH_DSP_NEXT
9aff			 
9aff				; save value and type 
9aff			 
9aff 2a e5 e9			ld hl, (cli_data_sp) 
9b02			 
9b02				; save item type 
9b02			;	ld a,  DS_TYPE_STR 
9b02 36 01			ld (hl), DS_TYPE_STR 
9b04 23				inc hl 
9b05			 
9b05				; get malloc word off stack 
9b05 d1				pop de 
9b06 73				ld (hl), e 
9b07 23				inc hl 
9b08 72				ld (hl), d 
9b09			 
9b09			 
9b09			 
9b09			if DEBUG_FORTH_PUSH 
9b09 2a e5 e9			ld hl, (cli_data_sp) 
9b0c						DMARK "PHS" 
9b0c f5				push af  
9b0d 3a 21 9b			ld a, (.dmark)  
9b10 32 62 ee			ld (debug_mark),a  
9b13 3a 22 9b			ld a, (.dmark+1)  
9b16 32 63 ee			ld (debug_mark+1),a  
9b19 3a 23 9b			ld a, (.dmark+2)  
9b1c 32 64 ee			ld (debug_mark+2),a  
9b1f 18 03			jr .pastdmark  
9b21 ..			.dmark: db "PHS"  
9b24 f1			.pastdmark: pop af  
9b25			endm  
# End of macro DMARK
9b25				CALLMONITOR 
9b25 cd 6f ee			call debug_vector  
9b28				endm  
# End of macro CALLMONITOR
9b28			;	ex de,hl 
9b28			endif	 
9b28				; in case of spaces, skip the ptr past the copied string 
9b28				;pop af 
9b28				;ld (cli_origptr),hl 
9b28			 
9b28 c9				ret 
9b29			 
9b29			 
9b29			 
9b29			; TODO ascii push input onto stack given hl to start of input 
9b29			 
9b29			; identify type 
9b29			; if starts with a " then a string 
9b29			; otherwise it is a number 
9b29			;  
9b29			; if a string 
9b29			;     scan for ending " to get length of string to malloc for + 1 
9b29			;     malloc 
9b29			;     put pointer to string on stack first byte flags as string 
9b29			; 
9b29			; else a number 
9b29			;    look for number format identifier 
9b29			;    $xx hex 
9b29			;    %xxxxx bin 
9b29			;    xxxxx decimal 
9b29			;    convert number to 16bit word.  
9b29			;    malloc word + 1 with flag to identiy as num 
9b29			;    put pointer to number on stack 
9b29			;   
9b29			;  
9b29			  
9b29			forth_apush: 
9b29				; kernel push 
9b29			 
9b29			if DEBUG_FORTH_PUSH 
9b29						DMARK "PSH" 
9b29 f5				push af  
9b2a 3a 3e 9b			ld a, (.dmark)  
9b2d 32 62 ee			ld (debug_mark),a  
9b30 3a 3f 9b			ld a, (.dmark+1)  
9b33 32 63 ee			ld (debug_mark+1),a  
9b36 3a 40 9b			ld a, (.dmark+2)  
9b39 32 64 ee			ld (debug_mark+2),a  
9b3c 18 03			jr .pastdmark  
9b3e ..			.dmark: db "PSH"  
9b41 f1			.pastdmark: pop af  
9b42			endm  
# End of macro DMARK
9b42				CALLMONITOR 
9b42 cd 6f ee			call debug_vector  
9b45				endm  
# End of macro CALLMONITOR
9b45			endif	 
9b45				; identify input type 
9b45			 
9b45 7e				ld a,(hl) 
9b46			 
9b46 fe 23			cp '#' 
9b48 ca 80 9b			jp z, .fapdec 
9b4b			 
9b4b			 
9b4b fe 22			cp '"' 
9b4d 28 0a			jr z, .fapstr 
9b4f fe 24			cp '$' 
9b51 ca 78 9b			jp z, .faphex 
9b54 fe 25			cp '%' 
9b56 ca 61 9b			jp z, .fapbin 
9b59			;	cp 'b' 
9b59			;	jp z, .fabin 
9b59				; else decimal 
9b59			 
9b59				; TODO do decimal conversion 
9b59				; decimal is stored as a 16bit word 
9b59			 
9b59				; by default everything is a string if type is not detected 
9b59			.fapstr: ; 
9b59 fe 22			cp '"' 
9b5b 20 01			jr nz, .strnoqu 
9b5d 23				inc hl 
9b5e			.strnoqu: 
9b5e c3 31 9a			jp forth_push_str 
9b61			 
9b61			 
9b61			 
9b61			.fapbin:    ; push a binary string.  
9b61 11 00 00			ld de, 0   ; hold a 16bit value 
9b64			 
9b64 23			.fapbinshift:	inc hl  
9b65 7e				ld a,(hl) 
9b66			;	cp 0     ; done scanning  
9b66 b7				or a 
9b67 28 0b			jr z, .fapbdone  	; got it in HL so push  
9b69			 
9b69				; left shift de 
9b69 eb				ex de, hl	 
9b6a 29				add hl, hl 
9b6b			 
9b6b				; is 1 
9b6b fe 31			cp '1' 
9b6d 20 02			jr nz, .binzero 
9b6f cb 4d			bit 1, l 
9b71			.binzero: 
9b71 eb				ex de, hl	 ; save current de 
9b72 18 f0			jr .fapbinshift 
9b74			 
9b74			.fapbdone: 
9b74 eb				ex de, hl 
9b75 c3 c7 99			jp forth_push_numhl 
9b78			 
9b78			 
9b78			.faphex:   ; hex is always stored as a 16bit word 
9b78				; skip number prefix 
9b78 23				inc hl 
9b79				; turn ascii into number 
9b79 cd 88 8f			call get_word_hl	; ret 16bit word in hl 
9b7c			 
9b7c c3 c7 99			jp forth_push_numhl 
9b7f			 
9b7f			;	 nop 
9b7f			 
9b7f			.fabin:   ; TODO bin conversion 
9b7f			 
9b7f			 
9b7f c9				ret 
9b80			.fapdec:	 
9b80				; string to dec conversion 
9b80 23				inc hl 
9b81 eb				ex de, hl 
9b82 cd c5 8f			call string_to_uint16 
9b85 c3 c7 99			jp forth_push_numhl 
9b88 c9				ret 
9b89				 
9b89			;atoui_16: 
9b89			 
9b89			; get either a string ptr or a 16bit word from the data stack 
9b89			 
9b89			FORTH_DSP: macro 
9b89				call macro_forth_dsp 
9b89				endm 
9b89			 
9b89			macro_forth_dsp: 
9b89				; data stack pointer points to current word on tos 
9b89			 
9b89 2a e5 e9			ld hl,(cli_data_sp) 
9b8c			 
9b8c				if DEBUG_FORTH_PUSH 
9b8c						DMARK "DSP" 
9b8c f5				push af  
9b8d 3a a1 9b			ld a, (.dmark)  
9b90 32 62 ee			ld (debug_mark),a  
9b93 3a a2 9b			ld a, (.dmark+1)  
9b96 32 63 ee			ld (debug_mark+1),a  
9b99 3a a3 9b			ld a, (.dmark+2)  
9b9c 32 64 ee			ld (debug_mark+2),a  
9b9f 18 03			jr .pastdmark  
9ba1 ..			.dmark: db "DSP"  
9ba4 f1			.pastdmark: pop af  
9ba5			endm  
# End of macro DMARK
9ba5			 
9ba5 cd 4b d3				call display_data_sp 
9ba8				;call break_point_state 
9ba8				;rst 030h 
9ba8				CALLMONITOR 
9ba8 cd 6f ee			call debug_vector  
9bab				endm  
# End of macro CALLMONITOR
9bab				endif 
9bab			 
9bab c9				ret 
9bac			 
9bac			; return hl to start of value on stack 
9bac			 
9bac			FORTH_DSP_VALUE: macro 
9bac				call macro_forth_dsp_value 
9bac				endm 
9bac			 
9bac			macro_forth_dsp_value: 
9bac			 
9bac				FORTH_DSP 
9bac cd 89 9b			call macro_forth_dsp 
9baf				endm 
# End of macro FORTH_DSP
9baf			 
9baf d5				push de 
9bb0			 
9bb0 23				inc hl ; skip type 
9bb1			 
9bb1 5e				ld e, (hl) 
9bb2 23				inc hl 
9bb3 56				ld d, (hl) 
9bb4 eb				ex de,hl  
9bb5			 
9bb5 d1				pop de 
9bb6			 
9bb6 c9				ret 
9bb7			 
9bb7			; return hl to start of value to second item on stack 
9bb7			 
9bb7			FORTH_DSP_VALUEM1: macro 
9bb7				call macro_forth_dsp_value_m1 
9bb7				endm 
9bb7			 
9bb7			macro_forth_dsp_value_m1: 
9bb7			 
9bb7				FORTH_DSP 
9bb7 cd 89 9b			call macro_forth_dsp 
9bba				endm 
# End of macro FORTH_DSP
9bba			 
9bba 2b				dec hl 
9bbb 2b				dec hl 
9bbc			;	dec hl 
9bbc			 
9bbc d5				push de 
9bbd			 
9bbd 5e				ld e, (hl) 
9bbe 23				inc hl 
9bbf 56				ld d, (hl) 
9bc0 eb				ex de,hl  
9bc1			 
9bc1 d1				pop de 
9bc2			 
9bc2 c9				ret 
9bc3			 
9bc3				 
9bc3			 
9bc3			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9bc3			 
9bc3			FORTH_DSP_POP: macro 
9bc3				call macro_forth_dsp_pop 
9bc3				endm 
9bc3			 
9bc3			 
9bc3			; get the tos data type 
9bc3			 
9bc3			FORTH_DSP_TYPE:   macro 
9bc3			 
9bc3				;FORTH_DSP_VALUE 
9bc3				FORTH_DSP 
9bc3				 
9bc3				; hl points to value 
9bc3				; check type 
9bc3			 
9bc3				ld a,(hl) 
9bc3			 
9bc3				endm 
9bc3			 
9bc3			; load the tos value into hl 
9bc3			 
9bc3			 
9bc3			FORTH_DSP_VALUEHL:  macro 
9bc3				call macro_dsp_valuehl 
9bc3				endm 
9bc3			 
9bc3			 
9bc3			 
9bc3			macro_dsp_valuehl: 
9bc3				FORTH_DSP_VALUE 
9bc3 cd ac 9b			call macro_forth_dsp_value 
9bc6				endm 
# End of macro FORTH_DSP_VALUE
9bc6			 
9bc6				;FORTH_ERR_TOS_NOTNUM 
9bc6			 
9bc6				;inc hl   ; skip type id 
9bc6			 
9bc6			;	push de 
9bc6			; 
9bc6			;	ld e, (hl) 
9bc6			;	inc hl 
9bc6			;	ld d, (hl) 
9bc6			;	ex de,hl  
9bc6			 
9bc6			;	pop de 
9bc6			 
9bc6				if DEBUG_FORTH_PUSH 
9bc6						DMARK "DVL" 
9bc6 f5				push af  
9bc7 3a db 9b			ld a, (.dmark)  
9bca 32 62 ee			ld (debug_mark),a  
9bcd 3a dc 9b			ld a, (.dmark+1)  
9bd0 32 63 ee			ld (debug_mark+1),a  
9bd3 3a dd 9b			ld a, (.dmark+2)  
9bd6 32 64 ee			ld (debug_mark+2),a  
9bd9 18 03			jr .pastdmark  
9bdb ..			.dmark: db "DVL"  
9bde f1			.pastdmark: pop af  
9bdf			endm  
# End of macro DMARK
9bdf				CALLMONITOR 
9bdf cd 6f ee			call debug_vector  
9be2				endm  
# End of macro CALLMONITOR
9be2				endif 
9be2 c9				ret 
9be3			 
9be3			forth_apushstrhl:      
9be3				; push of string requires use of cli_origptr 
9be3				; bodge use 
9be3			 
9be3				; get current cli_origptr, save, update with temp pointer  
9be3 ed 5b 35 ea		ld de, (cli_origptr) 
9be7 22 35 ea			ld (cli_origptr), hl 
9bea d5				push de 
9beb cd 29 9b			call forth_apush 
9bee d1				pop de 
9bef ed 53 35 ea		ld (cli_origptr), de 
9bf3 c9			        ret	 
9bf4			 
9bf4			 
9bf4			; increase loop stack pointer and save hl to it 
9bf4				 
9bf4			FORTH_LOOP_NEXT: macro 
9bf4				call macro_forth_loop_next 
9bf4				;nop 
9bf4				endm 
9bf4			 
9bf4			macro_forth_loop_next: 
9bf4				if DEBUG_FORTH_STACK_GUARD 
9bf4 cd c3 e0				call check_stacks 
9bf7				endif 
9bf7 e5				push hl 
9bf8 d5				push de 
9bf9 eb				ex de,hl 
9bfa 2a e7 e9			ld hl,(cli_loop_sp) 
9bfd 23				inc hl 
9bfe 23				inc hl 
9bff					if DEBUG_FORTH_WORDS 
9bff						DMARK "LNX" 
9bff f5				push af  
9c00 3a 14 9c			ld a, (.dmark)  
9c03 32 62 ee			ld (debug_mark),a  
9c06 3a 15 9c			ld a, (.dmark+1)  
9c09 32 63 ee			ld (debug_mark+1),a  
9c0c 3a 16 9c			ld a, (.dmark+2)  
9c0f 32 64 ee			ld (debug_mark+2),a  
9c12 18 03			jr .pastdmark  
9c14 ..			.dmark: db "LNX"  
9c17 f1			.pastdmark: pop af  
9c18			endm  
# End of macro DMARK
9c18						CALLMONITOR 
9c18 cd 6f ee			call debug_vector  
9c1b				endm  
# End of macro CALLMONITOR
9c1b					endif 
9c1b 22 e7 e9			ld (cli_loop_sp),hl 
9c1e 73				ld (hl), e 
9c1f 23				inc hl 
9c20 72				ld (hl), d 
9c21 d1				pop de    ; been reversed so save a swap on restore 
9c22 e1				pop hl 
9c23				if DEBUG_FORTH_STACK_GUARD 
9c23 cd c3 e0				call check_stacks 
9c26				endif 
9c26 c9				ret 
9c27			 
9c27			; get current ret stack pointer and save to hl  
9c27				 
9c27			FORTH_LOOP_TOS: macro 
9c27				call macro_forth_loop_tos 
9c27				endm 
9c27			 
9c27			macro_forth_loop_tos: 
9c27 d5				push de 
9c28 2a e7 e9			ld hl,(cli_loop_sp) 
9c2b 5e				ld e, (hl) 
9c2c 23				inc hl 
9c2d 56				ld d, (hl) 
9c2e eb				ex de, hl 
9c2f d1				pop de 
9c30 c9				ret 
9c31			 
9c31			; pop loop stack pointer 
9c31				 
9c31			FORTH_LOOP_POP: macro 
9c31				call macro_forth_loop_pop 
9c31				endm 
9c31			 
9c31			 
9c31			macro_forth_loop_pop: 
9c31				if DEBUG_FORTH_STACK_GUARD 
9c31					DMARK "LPP" 
9c31 f5				push af  
9c32 3a 46 9c			ld a, (.dmark)  
9c35 32 62 ee			ld (debug_mark),a  
9c38 3a 47 9c			ld a, (.dmark+1)  
9c3b 32 63 ee			ld (debug_mark+1),a  
9c3e 3a 48 9c			ld a, (.dmark+2)  
9c41 32 64 ee			ld (debug_mark+2),a  
9c44 18 03			jr .pastdmark  
9c46 ..			.dmark: db "LPP"  
9c49 f1			.pastdmark: pop af  
9c4a			endm  
# End of macro DMARK
9c4a cd c3 e0				call check_stacks 
9c4d					FORTH_CHK_LOOP_UNDER 
9c4d e5				push hl 
9c4e d5				push de 
9c4f 2a e7 e9			ld hl,(cli_loop_sp) 
9c52 11 21 e9			ld de, cli_loop_stack 
9c55 cd f4 8c			call cmp16 
9c58 da e0 e1			jp c, fault_loop_under 
9c5b d1				pop de 
9c5c e1				pop hl 
9c5d				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9c5d				endif 
9c5d e5				push hl 
9c5e 2a e7 e9			ld hl,(cli_loop_sp) 
9c61 2b				dec hl 
9c62 2b				dec hl 
9c63 22 e7 e9			ld (cli_loop_sp), hl 
9c66				; TODO do stack underflow checks 
9c66 e1				pop hl 
9c67				if DEBUG_FORTH_STACK_GUARD 
9c67 cd c3 e0				call check_stacks 
9c6a					FORTH_CHK_LOOP_UNDER 
9c6a e5				push hl 
9c6b d5				push de 
9c6c 2a e7 e9			ld hl,(cli_loop_sp) 
9c6f 11 21 e9			ld de, cli_loop_stack 
9c72 cd f4 8c			call cmp16 
9c75 da e0 e1			jp c, fault_loop_under 
9c78 d1				pop de 
9c79 e1				pop hl 
9c7a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9c7a				endif 
9c7a c9				ret 
9c7b			 
9c7b			macro_forth_dsp_pop: 
9c7b			 
9c7b e5				push hl 
9c7c			 
9c7c				; release malloc data 
9c7c			 
9c7c				if DEBUG_FORTH_STACK_GUARD 
9c7c cd c3 e0				call check_stacks 
9c7f					FORTH_CHK_DSP_UNDER 
9c7f e5				push hl 
9c80 d5				push de 
9c81 2a e5 e9			ld hl,(cli_data_sp) 
9c84 11 1f e8			ld de, cli_data_stack 
9c87 cd f4 8c			call cmp16 
9c8a da d4 e1			jp c, fault_dsp_under 
9c8d d1				pop de 
9c8e e1				pop hl 
9c8f				endm 
# End of macro FORTH_CHK_DSP_UNDER
9c8f				endif 
9c8f				;ld hl,(cli_data_sp) 
9c8f			if DEBUG_FORTH_DOT 
9c8f				DMARK "DPP" 
9c8f f5				push af  
9c90 3a a4 9c			ld a, (.dmark)  
9c93 32 62 ee			ld (debug_mark),a  
9c96 3a a5 9c			ld a, (.dmark+1)  
9c99 32 63 ee			ld (debug_mark+1),a  
9c9c 3a a6 9c			ld a, (.dmark+2)  
9c9f 32 64 ee			ld (debug_mark+2),a  
9ca2 18 03			jr .pastdmark  
9ca4 ..			.dmark: db "DPP"  
9ca7 f1			.pastdmark: pop af  
9ca8			endm  
# End of macro DMARK
9ca8				CALLMONITOR 
9ca8 cd 6f ee			call debug_vector  
9cab				endm  
# End of macro CALLMONITOR
9cab			endif	 
9cab			 
9cab			 
9cab			if FORTH_ENABLE_DSPPOPFREE 
9cab			 
9cab				FORTH_DSP 
9cab cd 89 9b			call macro_forth_dsp 
9cae				endm 
# End of macro FORTH_DSP
9cae			 
9cae 7e				ld a, (hl) 
9caf fe 01			cp DS_TYPE_STR             ; implies that DS_TYPE_CONST *WONT* be freed 
9cb1 20 22			jr nz, .skippopfree 
9cb3			 
9cb3				FORTH_DSP_VALUEHL 
9cb3 cd c3 9b			call macro_dsp_valuehl 
9cb6				endm 
# End of macro FORTH_DSP_VALUEHL
9cb6			;	nop 
9cb6			if DEBUG_FORTH_DOT 
9cb6				DMARK "DPf" 
9cb6 f5				push af  
9cb7 3a cb 9c			ld a, (.dmark)  
9cba 32 62 ee			ld (debug_mark),a  
9cbd 3a cc 9c			ld a, (.dmark+1)  
9cc0 32 63 ee			ld (debug_mark+1),a  
9cc3 3a cd 9c			ld a, (.dmark+2)  
9cc6 32 64 ee			ld (debug_mark+2),a  
9cc9 18 03			jr .pastdmark  
9ccb ..			.dmark: db "DPf"  
9cce f1			.pastdmark: pop af  
9ccf			endm  
# End of macro DMARK
9ccf				CALLMONITOR 
9ccf cd 6f ee			call debug_vector  
9cd2				endm  
# End of macro CALLMONITOR
9cd2			endif	 
9cd2 cd 6c 91			call free 
9cd5			.skippopfree: 
9cd5				 
9cd5			 
9cd5			endif 
9cd5			 
9cd5			if DEBUG_FORTH_DOT_KEY 
9cd5				DMARK "DP2" 
9cd5				CALLMONITOR 
9cd5			endif	 
9cd5			 
9cd5				; move pointer down 
9cd5			 
9cd5 2a e5 e9			ld hl,(cli_data_sp) 
9cd8 2b				dec hl 
9cd9 2b				dec hl 
9cda			; PARSEV5 
9cda 2b				dec hl 
9cdb 22 e5 e9			ld (cli_data_sp), hl 
9cde			 
9cde				if DEBUG_FORTH_STACK_GUARD 
9cde cd c3 e0				call check_stacks 
9ce1					FORTH_CHK_DSP_UNDER 
9ce1 e5				push hl 
9ce2 d5				push de 
9ce3 2a e5 e9			ld hl,(cli_data_sp) 
9ce6 11 1f e8			ld de, cli_data_stack 
9ce9 cd f4 8c			call cmp16 
9cec da d4 e1			jp c, fault_dsp_under 
9cef d1				pop de 
9cf0 e1				pop hl 
9cf1				endm 
# End of macro FORTH_CHK_DSP_UNDER
9cf1				endif 
9cf1			 
9cf1 e1				pop hl 
9cf2			 
9cf2 c9				ret 
9cf3			 
9cf3			getwordathl: 
9cf3				; hl points to an address 
9cf3				; load hl with the word at that address 
9cf3			 
9cf3 d5				push de 
9cf4			 
9cf4 5e				ld e, (hl) 
9cf5 23				inc hl 
9cf6 56				ld d, (hl) 
9cf7 eb				ex de, hl 
9cf8			 
9cf8 d1				pop de 
9cf9 c9				ret 
9cfa			 
9cfa			 
9cfa			; functions to manuplite stack pointers 
9cfa			 
9cfa			; generate fragment to set hl to be pointer to a stack item 
9cfa			 
9cfa			FORTH_DSP_PTR: macro  x 
9cfa				ld hl,(cli_data_sp) 
9cfa				ld de, x * 3 
9cfa				sbc hl, de 
9cfa				endm 
9cfa			 
9cfa			 
9cfa			 
9cfa			; copy point in hl to stack tmp storage slots 1-4 
9cfa			hltostack1: 
9cfa 11 b5 e2			ld de, os_stack_1  
9cfd c3 28 9d			jp hltostackmv 
9d00			 
9d00			hltostack2:  
9d00 11 b2 e2			ld de, os_stack_2 
9d03 c3 28 9d			jp hltostackmv 
9d06			 
9d06			hltostack3:  
9d06 11 af e2			ld de, os_stack_3 
9d09 c3 28 9d			jp hltostackmv 
9d0c			 
9d0c			hltostack4:  
9d0c 11 ac e2			ld de, os_stack_4  
9d0f c3 28 9d			jp hltostackmv 
9d12			 
9d12			; copy to point in hl from stack tmp storage slots 1-4 
9d12			hlfromstack1: 
9d12 11 b5 e2			ld de, os_stack_1 
9d15 c3 27 9d			jp hlfromsttackmv 
9d18			 
9d18			hlfromstack2:  
9d18 11 b2 e2			ld de, os_stack_2 
9d1b c3 27 9d			jp hlfromsttackmv 
9d1e			 
9d1e			hlfromstack3:  
9d1e 11 af e2			ld de, os_stack_3 
9d21 c3 27 9d			jp hlfromsttackmv 
9d24			 
9d24			hlfromstack4:  
9d24 11 ac e2			ld de, os_stack_4 
9d27			 
9d27			hlfromsttackmv: 
9d27 eb				ex de, hl 
9d28			 
9d28			hltostackmv: 
9d28			 
9d28				; do stack move 
9d28 c5				push bc 
9d29 01 03 00			ld bc, 3 
9d2c ed b0			ldir  
9d2e c1				pop bc	 
9d2f c9				ret 
9d30			 
9d30			; eof 
9d30			 
# End of file forth_stackopsv5.asm
9d30			endif 
9d30			loadwordinhl:	 
9d30			 
9d30 d5				push de 
9d31			 
9d31 5e				ld e, (hl) 
9d32 23				inc hl 
9d33 56				ld d, (hl) 
9d34 eb				ex de,hl  
9d35			 
9d35 d1				pop de 
9d36			 
9d36 c9				ret 
9d37			 
9d37			user_word_eol:  
9d37				; hl contains the pointer to where to create a linked list item from the end 
9d37				; of the user dict to continue on at the system word dict 
9d37				 
9d37				; poke the stub of the word list linked list to repoint to rom words 
9d37			 
9d37				; stub format 
9d37				; db   word id 
9d37				; dw    link to next word 
9d37			        ; db char length of token 
9d37				; db string + 0 term 
9d37				; db exec code....  
9d37			 
9d37			;	ld a, WORD_SYS_ROOT     ; root word 
9d37 36 00			ld (hl), WORD_SYS_ROOT		; word id 
9d39 23				inc hl 
9d3a			 
9d3a 11 e3 9e			ld de, sysdict 
9d3d 73				ld (hl), e		; next word link ie system dict 
9d3e 23				inc hl 
9d3f 72				ld (hl), d		; next word link ie system dict 
9d40 23				inc hl	 
9d41			 
9d41			;	ld (hl), sysdict		; next word link ie system dict 
9d41			;	inc hl 
9d41			;	inc hl 
9d41			 
9d41			;	inc hl 
9d41			;	inc hl 
9d41			 
9d41			;	ld a, 2			; word length is 0 
9d41 36 02			ld (hl), 2 
9d43 23				inc hl 
9d44			 
9d44			;	ld a, '~'			; word length is 0 
9d44 36 7e			ld (hl), '~' 
9d46 23				inc hl 
9d47			;	ld a, 0			; save empty word 
9d47 36 00			ld (hl), 0 
9d49			 
9d49 c9				ret 
9d4a			 
9d4a				 
9d4a			 
9d4a			forthexec_cleanup: 
9d4a				FORTH_RSP_POP 
9d4a cd 8f 99			call macro_forth_rsp_pop 
9d4d				endm 
# End of macro FORTH_RSP_POP
9d4d c9				ret 
9d4e			 
9d4e			forth_call_hl: 
9d4e				; taking hl 
9d4e e5				push hl 
9d4f c9				ret 
9d50			 
9d50			; this is called to reset Forth system but keep existing uwords etc 
9d50			 
9d50			forth_warmstart: 
9d50				; setup stack over/under flow checks 
9d50				if DEBUG_FORTH_STACK_GUARD 
9d50 cd a9 e0				call chk_stk_init 
9d53				endif 
9d53			 
9d53				; init stack pointers  - * these stacks go upwards *  
9d53 21 a3 e9			ld hl, cli_ret_stack 
9d56 22 e9 e9			ld (cli_ret_sp), hl	 
9d59				; set bottom of stack 
9d59			;	ld a,0 
9d59 36 00			ld (hl),0 
9d5b 23				inc hl 
9d5c 36 00			ld (hl),0 
9d5e			 
9d5e 21 1f e8			ld hl, cli_data_stack 
9d61 22 e5 e9			ld (cli_data_sp), hl	 
9d64				; set bottom of stack 
9d64			;	ld a,0 
9d64 36 00			ld (hl),0 
9d66 23				inc hl 
9d67 36 00			ld (hl),0 
9d69			 
9d69 21 21 e9			ld hl, cli_loop_stack 
9d6c 22 e7 e9			ld (cli_loop_sp), hl	 
9d6f				; set bottom of stack 
9d6f			;	ld a,0 
9d6f 36 00			ld (hl),0 
9d71 23				inc hl 
9d72 36 00			ld (hl),0 
9d74			 
9d74				; init extent of current open file 
9d74			 
9d74 3e 00			ld a, 0 
9d76 32 61 ea			ld (store_openext), a 
9d79			 
9d79 c9				ret 
9d7a			 
9d7a			 
9d7a			 
9d7a			; Cold Start - this is called to setup the whole Forth system 
9d7a			 
9d7a			forth_init: 
9d7a			 
9d7a				; setup stack over/under flow checks 
9d7a			 
9d7a			;	if DEBUG_FORTH_STACK_GUARD 
9d7a			;		call chk_stk_init 
9d7a			;	endif 
9d7a			 
9d7a				; enable auto display updates (slow.....) 
9d7a			 
9d7a 3e 01			ld a, 1 
9d7c 32 33 ea			ld (cli_autodisplay), a 
9d7f			 
9d7f				; if storage is in use disable long reads for now 
9d7f 3e 00			ld a, 0 
9d81 32 6c ea			ld (store_longread), a 
9d84			 
9d84			 
9d84				; show start up screen 
9d84			 
9d84 cd ac 8a			call clear_display 
9d87			 
9d87 3e 00			ld a,0 
9d89 32 55 ea			ld (f_cursor_ptr), a 
9d8c			 
9d8c				; set start of word list in start of ram - for use when creating user words 
9d8c			 
9d8c 21 66 e4			ld hl, baseram 
9d8f 22 b5 e5			ld (os_last_new_uword), hl 
9d92 cd 37 9d			call user_word_eol 
9d95				 
9d95			;		call display_data_sp 
9d95			;		call next_page_prompt 
9d95			 
9d95			 
9d95			 
9d95			 
9d95 c9				ret 
9d96			 
9d96 .. 00		.bootforth: db " Forth Kernel Init ",0 
9daa			 
9daa			; TODO push to stack 
9daa			 
9daa			;  
9daa			 
9daa			if FORTH_PARSEV2 
9daa			 
9daa			 
9daa				include "forth_parserv2.asm" 
9daa			 
9daa			endif 
9daa			 
9daa			 
9daa			; parse cli version 1 
9daa			 
9daa			if FORTH_PARSEV1 
9daa			 
9daa			 
9daa			 
9daa			      include "forth_parserv1.asm" 
9daa			endif 
9daa				 
9daa			if FORTH_PARSEV3 
9daa			      include "forth_parserv3.asm" 
9daa				include "forth_wordsv3.asm" 
9daa			endif 
9daa			 
9daa			if FORTH_PARSEV4 
9daa			      include "forth_parserv4.asm" 
9daa				include "forth_wordsv4.asm" 
9daa			endif 
9daa			 
9daa			if FORTH_PARSEV5 
9daa			      include "forth_parserv5.asm" 
9daa				include "forth_wordsv4.asm" 
9daa			endif 
9daa			 
9daa			if FORTH_PARSEV6 
9daa			      include "forth_parserv6.asm" 
9daa			 
9daa			 
9daa			; A better parser without using malloc and string copies all over the place.  
9daa			; Exec in situ should be faster 
9daa			 
9daa			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9daa			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9daa			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9daa			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9daa			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9daa			WORD_SYS_END: equ 0   ; Opcode for all user words 
9daa			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9daa			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9daa			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9daa			 
9daa			; Core word preamble macro 
9daa			 
9daa			CWHEAD:   macro nxtword opcode lit len opflags 
9daa				db WORD_SYS_CORE+opcode             
9daa				; internal op code number 
9daa				dw nxtword            
9daa				; link to next dict word block 
9daa				db len + 1 
9daa				; literal length of dict word inc zero term 
9daa				db lit,0              
9daa				; literal dict word 
9daa			        ; TODO db opflags        
9daa				endm 
9daa			 
9daa			 
9daa			NEXTW: macro  
9daa				call parse_vector 
9daa				jp macro_next 
9daa				endm 
9daa			 
9daa			macro_next: 
9daa			if DEBUG_FORTH_PARSE_EXEC 
9daa				DMARK "NXT" 
9daa				CALLMONITOR 
9daa			endif	 
9daa			;	inc hl  ; skip token null term  
9daa ed 4b 37 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9dae ed 5b 35 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9db2 2a b9 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9db5			if DEBUG_FORTH_PARSE_EXEC 
9db5				DMARK "}AA" 
9db5				CALLMONITOR 
9db5			endif	 
9db5 c3 9a 9e			jp execnext 
9db8				;jp exec1 
9db8			       
9db8			 
9db8			 
9db8			; Another go at the parser to compile  
9db8			 
9db8			 
9db8			; TODO rework parser to change all of the string words to byte tokens 
9db8			; TODO do a search for  
9db8			 
9db8			; TODO first run normal parser to zero term sections 
9db8			; TODO for each word do a token look up to get the op code 
9db8			; TODO need some means to flag to the exec that this is a byte code form    
9db8			 
9db8			 
9db8			forthcompile: 
9db8			 
9db8			; 
9db8			; line parse: 
9db8			;       parse raw input buffer 
9db8			;       tokenise the words 
9db8			;       malloc new copy (for looping etc) 
9db8			;       copy to malloc + current pc in line to start of string and add line term 
9db8			;       save on new rsp 
9db8			; 
9db8			 
9db8			; hl to point to the line to tokenise 
9db8			 
9db8			;	push hl 
9db8 22 b9 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9dbb			 
9dbb			;	ld a,0		; string term on input 
9dbb			;	call strlent 
9dbb			 
9dbb			;	ld (os_tok_len), hl	 ; save string length 
9dbb			 
9dbb			;if DEBUG_FORTH_TOK 
9dbb			;	ex de,hl		 
9dbb			;endif 
9dbb			 
9dbb			;	pop hl 		; get back string pointer 
9dbb			 
9dbb			if DEBUG_FORTH_TOK 
9dbb						DMARK "TOc" 
9dbb				CALLMONITOR 
9dbb			endif 
9dbb 7e			.cptoken2:    ld a,(hl) 
9dbc 23				inc hl 
9dbd fe 7f			cp FORTH_END_BUFFER 
9dbf 28 26			jr z, .cptokendone2 
9dc1			;	cp 0 
9dc1 b7				or a 
9dc2 28 23			jr z, .cptokendone2 
9dc4 fe 22			cp '"' 
9dc6 28 0a			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9dc8 fe 20			cp ' ' 
9dca 20 ef			jr nz,  .cptoken2 
9dcc			 
9dcc			; TODO consume comments held between ( and ) 
9dcc			 
9dcc				; we have a space so change to zero term for dict match later 
9dcc 2b				dec hl 
9dcd			;	ld a,0 
9dcd 36 00			ld (hl), 0 
9dcf 23				inc hl 
9dd0 18 e9			jr .cptoken2 
9dd2				 
9dd2			 
9dd2			.cptokenstr2: 
9dd2				; skip all white space until either eol (because forgot to term) or end double quote 
9dd2			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9dd2				;inc hl ; skip current double quote 
9dd2 7e				ld a,(hl) 
9dd3 23				inc hl 
9dd4 fe 22			cp '"' 
9dd6 28 e3			jr z, .cptoken2 
9dd8 fe 7f			cp FORTH_END_BUFFER 
9dda 28 0b			jr z, .cptokendone2 
9ddc			;	cp 0 
9ddc b7				or a 
9ddd 28 08			jr z, .cptokendone2 
9ddf fe 20			cp ' ' 
9de1 28 02			jr z, .cptmp2 
9de3 18 ed			jr .cptokenstr2 
9de5			 
9de5			.cptmp2:	; we have a space so change to zero term for dict match later 
9de5				;dec hl 
9de5				;ld a,"-"	; TODO remove this when working 
9de5				;ld (hl), a 
9de5				;inc hl 
9de5 18 eb			jr .cptokenstr2 
9de7			 
9de7			.cptokendone2: 
9de7				;inc hl 
9de7			;	ld a, FORTH_END_BUFFER 
9de7 36 7f			ld (hl),FORTH_END_BUFFER 
9de9			;	inc hl 
9de9			;	ld a, '!' 
9de9			;	ld (hl),a 
9de9			 
9de9 2a b9 e5			ld hl,(os_tok_ptr) 
9dec			         
9dec			if DEBUG_FORTH_TOK 
9dec						DMARK "Tc1" 
9dec				CALLMONITOR 
9dec			endif 
9dec			 
9dec				; push exec string to top of return stack 
9dec				FORTH_RSP_NEXT 
9dec cd 6e 99			call macro_forth_rsp_next 
9def				endm 
# End of macro FORTH_RSP_NEXT
9def c9				ret 
9df0			 
9df0			; Another go at the parser need to simplify the process 
9df0			 
9df0			forthparse: 
9df0			 
9df0			; 
9df0			; line parse: 
9df0			;       parse raw input buffer 
9df0			;       tokenise the words 
9df0			;       malloc new copy (for looping etc) 
9df0			;       copy to malloc + current pc in line to start of string and add line term 
9df0			;       save on new rsp 
9df0			; 
9df0			 
9df0			; hl to point to the line to tokenise 
9df0			 
9df0			;	push hl 
9df0 22 b9 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9df3			 
9df3			;	ld a,0		; string term on input 
9df3			;	call strlent 
9df3			 
9df3			;	ld (os_tok_len), hl	 ; save string length 
9df3			 
9df3			;if DEBUG_FORTH_TOK 
9df3			;	ex de,hl		 
9df3			;endif 
9df3			 
9df3			;	pop hl 		; get back string pointer 
9df3			 
9df3			if DEBUG_FORTH_TOK 
9df3						DMARK "TOK" 
9df3				CALLMONITOR 
9df3			endif 
9df3 7e			.ptoken2:    ld a,(hl) 
9df4 23				inc hl 
9df5 fe 7f			cp FORTH_END_BUFFER 
9df7 28 26			jr z, .ptokendone2 
9df9			;	cp 0 
9df9 b7				or a 
9dfa 28 23			jr z, .ptokendone2 
9dfc fe 22			cp '"' 
9dfe 28 0a			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9e00 fe 20			cp ' ' 
9e02 20 ef			jr nz,  .ptoken2 
9e04			 
9e04			; TODO consume comments held between ( and ) 
9e04			 
9e04				; we have a space so change to zero term for dict match later 
9e04 2b				dec hl 
9e05			;	ld a,0 
9e05 36 00			ld (hl), 0 
9e07 23				inc hl 
9e08 18 e9			jr .ptoken2 
9e0a				 
9e0a			 
9e0a			.ptokenstr2: 
9e0a				; skip all white space until either eol (because forgot to term) or end double quote 
9e0a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e0a				;inc hl ; skip current double quote 
9e0a 7e				ld a,(hl) 
9e0b 23				inc hl 
9e0c fe 22			cp '"' 
9e0e 28 e3			jr z, .ptoken2 
9e10 fe 7f			cp FORTH_END_BUFFER 
9e12 28 0b			jr z, .ptokendone2 
9e14			;	cp 0 
9e14 b7				or a 
9e15 28 08			jr z, .ptokendone2 
9e17 fe 20			cp ' ' 
9e19 28 02			jr z, .ptmp2 
9e1b 18 ed			jr .ptokenstr2 
9e1d			 
9e1d			.ptmp2:	; we have a space so change to zero term for dict match later 
9e1d				;dec hl 
9e1d				;ld a,"-"	; TODO remove this when working 
9e1d				;ld (hl), a 
9e1d				;inc hl 
9e1d 18 eb			jr .ptokenstr2 
9e1f			 
9e1f			.ptokendone2: 
9e1f				;inc hl 
9e1f			;	ld a, FORTH_END_BUFFER 
9e1f 36 7f			ld (hl),FORTH_END_BUFFER 
9e21			;	inc hl 
9e21			;	ld a, '!' 
9e21			;	ld (hl),a 
9e21			 
9e21 2a b9 e5			ld hl,(os_tok_ptr) 
9e24			         
9e24			if DEBUG_FORTH_TOK 
9e24						DMARK "TK1" 
9e24				CALLMONITOR 
9e24			endif 
9e24			 
9e24				; push exec string to top of return stack 
9e24				FORTH_RSP_NEXT 
9e24 cd 6e 99			call macro_forth_rsp_next 
9e27				endm 
# End of macro FORTH_RSP_NEXT
9e27 c9				ret 
9e28			 
9e28			; 
9e28			;	; malloc size + buffer pointer + if is loop flag 
9e28			;	ld hl,(os_tok_len) 		 ; get string length 
9e28			; 
9e28			;	ld a,l 
9e28			; 
9e28			;	cp 0			; we dont want to use a null string 
9e28			;	ret z 
9e28			; 
9e28			;;	add 3    ; prefix malloc with buffer for current word ptr 
9e28			; 
9e28			;	add 5     ; TODO when certain not over writing memory remove 
9e28			; 
9e28			;		 
9e28			; 
9e28			;if DEBUG_FORTH_TOK 
9e28			;			DMARK "TKE" 
9e28			;	CALLMONITOR 
9e28			;endif 
9e28			; 
9e28			;	ld l,a 
9e28			;	ld h,0 
9e28			;;	push hl   ; save required space for the copy later 
9e28			;	call malloc 
9e28			;if DEBUG_FORTH_TOK 
9e28			;			DMARK "TKM" 
9e28			;	CALLMONITOR 
9e28			;endif 
9e28			;	if DEBUG_FORTH_MALLOC_GUARD 
9e28			;		push af 
9e28			;		call ishlzero 
9e28			;;		ld a, l 
9e28			;;		add h 
9e28			;;		cp 0 
9e28			;		pop af 
9e28			;		 
9e28			;		call z,malloc_error 
9e28			;	endif 
9e28			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9e28			; 
9e28			; 
9e28			;if DEBUG_FORTH_TOK 
9e28			;			DMARK "TKR" 
9e28			;	CALLMONITOR 
9e28			;endif 
9e28			; 
9e28			;	FORTH_RSP_NEXT 
9e28			; 
9e28			;	;inc hl	 ; go past current buffer pointer 
9e28			;	;inc hl 
9e28			;	;inc hl   ; and past if loop flag 
9e28			;		; TODO Need to set flag  
9e28			; 
9e28			;	 
9e28			;	 
9e28			;	ex de,hl	; malloc is dest 
9e28			;	ld hl, (os_tok_len) 
9e28			;;	pop bc 
9e28			;	ld c, l                
9e28			;	ld b,0 
9e28			;	ld hl, (os_tok_ptr) 
9e28			; 
9e28			;if DEBUG_FORTH_TOK 
9e28			;			DMARK "TKT" 
9e28			;	CALLMONITOR 
9e28			;endif 
9e28			; 
9e28			;	; do str cpy 
9e28			; 
9e28			;	ldir      ; copy byte in hl to de 
9e28			; 
9e28			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9e28			; 
9e28			;if DEBUG_FORTH_TOK 
9e28			; 
9e28			;			DMARK "TKY" 
9e28			;	CALLMONITOR 
9e28			;endif 
9e28			;	;ld a,0 
9e28			;	;ld a,FORTH_END_BUFFER 
9e28			;	ex de, hl 
9e28			;	;dec hl			 ; go back over the space delim at the end of word 
9e28			;	;ld (hl),a 
9e28			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9e28			;	ld a,FORTH_END_BUFFER 
9e28			;	ld (hl),a 
9e28			;	inc hl 
9e28			;	ld a,FORTH_END_BUFFER 
9e28			;	ld (hl),a 
9e28			; 
9e28			;	; init the malloc area data 
9e28			;	; set pc for in current area 
9e28			;	;ld hl, (os_tok_malloc) 
9e28			;	;inc hl 
9e28			;	;inc hl 
9e28			;	;inc hl 
9e28			;	;ex de,hl 
9e28			;	;ld hl, (os_tok_malloc) 
9e28			;	;ld (hl),e 
9e28			;	;inc hl 
9e28			;	;ld (hl),d 
9e28			; 
9e28			; 
9e28			;	ld hl,(os_tok_malloc) 
9e28			;if DEBUG_FORTH_PARSE_KEY 
9e28			;			DMARK "TKU" 
9e28			;	CALLMONITOR 
9e28			;endif 
9e28			; 
9e28			;	ret 
9e28			 
9e28			forthexec: 
9e28			 
9e28			; line exec: 
9e28			; forth parser 
9e28			 
9e28			; 
9e28			;       get current exec line on rsp 
9e28			 
9e28				FORTH_RSP_TOS 
9e28 cd 85 99			call macro_forth_rsp_tos 
9e2b				endm 
# End of macro FORTH_RSP_TOS
9e2b			 
9e2b			;       restore current pc - hl points to malloc of data 
9e2b			 
9e2b				;ld e, (hl) 
9e2b				;inc hl 
9e2b				;ld d, (hl) 
9e2b				;ex de,hl 
9e2b			 
9e2b			 
9e2b			exec1: 
9e2b 22 b9 e5			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
9e2e			 
9e2e				; copy our PC to working vars  
9e2e 22 37 ea			ld (cli_ptr), hl                    ; here 
9e31 22 35 ea			ld (cli_origptr), hl                ; here 
9e34			 
9e34 7e				ld a,(hl)                           ; here make hl be the ram ptr 
9e35 fe 7f			cp FORTH_END_BUFFER 
9e37 c8				ret z 
9e38			 
9e38				; skip any nulls 
9e38			 
9e38			;	cp 0 
9e38 b7				or a 
9e39 20 03			jr nz, .execword 
9e3b 23				inc hl 
9e3c 18 ed			jr exec1 
9e3e			 
9e3e			 
9e3e			.execword: 
9e3e			 
9e3e			 
9e3e			 
9e3e			if DEBUG_FORTH_PARSE_EXEC 
9e3e						DMARK "KYQ" 
9e3e				CALLMONITOR 
9e3e			endif 
9e3e			;       while at start of word: 
9e3e			; get start of dict (in user area first) 
9e3e			 
9e3e 21 66 e4		ld hl, baseram 
9e41			;ld hl, sysdict 
9e41 22 39 ea		ld (cli_nextword),hl                            ; here do we need to do this? 
9e44			;           match word at pc 
9e44			;           exec word 
9e44			;           or push to dsp 
9e44			;           forward to next token 
9e44			;           if line term pop rsp and exit 
9e44			;        
9e44			 
9e44			if DEBUG_FORTH_PARSE_EXEC 
9e44						DMARK "KYq" 
9e44				CALLMONITOR 
9e44			endif 
9e44			 
9e44			; 
9e44			; word comp 
9e44			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9e44			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9e44			;    move to start of word  
9e44			;    compare word to cli_token 
9e44			 
9e44			.execpnword:	; HL at start of a word in the dictionary to check 
9e44			 
9e44 2a 39 ea			ld hl,(cli_nextword)                  ; here remove the need to store???? 
9e47			 
9e47 cd dc 9e			call forth_tok_next 
9e4a			; tok next end here 
9e4a 22 39 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9e4d eb				ex de, hl 
9e4e			 
9e4e			 
9e4e				; save the pointer of the current token - 1 to check against 
9e4e				 
9e4e 22 3d ea			ld (cli_token), hl   
9e51				; TODO maybe remove below save if no debug 
9e51				; save token string ptr for any debug later 
9e51 23				inc hl  
9e52 22 3f ea			ld (cli_origtoken), hl 
9e55 2b				dec hl 
9e56				; save pointer to the start of the next dictionay word 
9e56 7e				ld a,(hl)   ; get string length 
9e57 47				ld b,a 
9e58			.execpnwordinc:  
9e58 23				inc hl 
9e59 10 fd			djnz .execpnwordinc 
9e5b 22 3b ea			ld (cli_execword), hl      ; save start of this words code 
9e5e			 
9e5e				; now check the word token against the string being parsed 
9e5e			 
9e5e 2a 3d ea			ld hl,(cli_token) 
9e61 23				inc hl     ; skip string length (use zero term instead to end) 
9e62				;ld (cli_token), hl 
9e62			 
9e62			.execpnchar:    ; compare char between token and string to parse 
9e62			 
9e62			 
9e62				;ld hl, (cli_token)     ; the dict word  
9e62 ed 5b 37 ea		ld de, (cli_ptr)     ; cli to parse 
9e66			 
9e66			 
9e66			.execpncharl:    ; compare char between token and string to parse (loop) 
9e66			 
9e66 1a				ld a,(de) 
9e67 cd 25 90			call toUpper 		; make sure the input string matches case 
9e6a be				cp (hl) 
9e6b			 
9e6b c2 83 9e			jp nz, .execpnskipword	 ; no match so move to next word 
9e6e				 
9e6e			;    if same 
9e6e			;       scan for string terms 0 for token and 32 for input 
9e6e 46				ld b,(hl) 
9e6f 80				add b			 
9e70 23				inc hl 
9e71 13				inc de 
9e72 b7				or a 
9e73			;	cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9e73							; TODO need to make sure last word in zero term string is accounted for 
9e73 20 f1			jr nz, .execpncharl 		 ; not at end of strings yet 
9e75			 
9e75			 
9e75				; at end of both strings so both are exact match 
9e75			 
9e75			;       skip ptr for next word 
9e75			 
9e75 2a 37 ea			ld hl,(cli_ptr) 	; at input string term 
9e78 23				inc hl			 ; at next char 
9e79 22 37 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9e7c 22 35 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9e7f				 
9e7f				 
9e7f			 
9e7f			 
9e7f			 
9e7f			;       exec code block 
9e7f			if DEBUG_FORTH_JP 
9e7f				call clear_display 
9e7f				call update_display 
9e7f				call delay1s 
9e7f				ld hl, (cli_execword)     ; save for next check if no match on this word 
9e7f				ld a,h 
9e7f				ld hl, os_word_scratch 
9e7f				call hexout 
9e7f				ld hl, (cli_execword)     ; save for next check if no match on this word 
9e7f				ld a,l 
9e7f				ld hl, os_word_scratch+2 
9e7f				call hexout 
9e7f				ld hl, os_word_scratch+4 
9e7f			;	ld a,0 
9e7f				ld (hl),0 
9e7f				ld de,os_word_scratch 
9e7f				call str_at_display 
9e7f					ld a, display_row_2 
9e7f					call str_at_display 
9e7f				ld de, (cli_origtoken) 
9e7f				ld a, display_row_1+10 
9e7f					call str_at_display 
9e7f			 
9e7f				ld a,display_row_1 
9e7f				ld de, .foundword 
9e7f				ld a, display_row_3 
9e7f				call str_at_display 
9e7f				call update_display 
9e7f				call delay1s 
9e7f				call delay1s 
9e7f				call delay1s 
9e7f			endif 
9e7f			 
9e7f			if DEBUG_FORTH_PARSE_EXEC 
9e7f						DMARK "KYj" 
9e7f			endif 
9e7f				; TODO save the word pointer in this exec 
9e7f			 
9e7f 2a 3b ea			ld hl,(cli_execword) 
9e82 e9				jp (hl) 
9e83			 
9e83			 
9e83			;    if not same 
9e83			;	scan for zero term 
9e83			;	get ptr for next word 
9e83			;	goto word comp 
9e83			 
9e83			.execpnskipword:	; get pointer to next word 
9e83 2a 39 ea			ld hl,(cli_nextword) 
9e86			 
9e86 7e				ld a,(hl) 
9e87 fe 00			cp WORD_SYS_END 
9e89			;	cp 0 
9e89 28 09			jr z, .execendofdict			 ; at end of words 
9e8b			 
9e8b			if DEBUG_FORTH_PARSE_EXEC 
9e8b						DMARK "KY4" 
9e8b			endif 
9e8b			if DEBUG_FORTH_PARSE_EXEC 
9e8b			 
9e8b				; see if disabled 
9e8b			 
9e8b			;	ld a, (os_view_disable) 
9e8b			;	cp '*' 
9e8b				ld a,(debug_vector) 
9e8b				cp $c9   ; RET 
9e8b				jr z, .noskip 
9e8b			 
9e8b			 
9e8b				ld de, .nowordfound 
9e8b				ld a, display_row_3 
9e8b				call str_at_display 
9e8b				call update_display 
9e8b				ld a, 100 
9e8b				call aDelayInMS 
9e8b				 
9e8b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9e8b					call delay250ms 
9e8b				endif 
9e8b			.noskip:  
9e8b			 
9e8b			endif	 
9e8b			 
9e8b 2a 35 ea			ld hl,(cli_origptr) 
9e8e 22 37 ea			ld (cli_ptr),hl 
9e91			 
9e91			if DEBUG_FORTH_PARSE_EXEC 
9e91						DMARK "KY5" 
9e91			endif 
9e91 c3 44 9e			jp .execpnword			; else go to next word 
9e94			 
9e94			.execendofdict:  
9e94			 
9e94			if DEBUG_FORTH_PARSE_EXEC 
9e94						DMARK "KYe" 
9e94			endif 
9e94			if DEBUG_FORTH_PARSE_EXEC 
9e94				; see if disabled 
9e94			 
9e94			;	ld a, (os_view_disable) 
9e94			;	cp '*' 
9e94				ld a,(debug_vector) 
9e94				cp $c9   ; ret 
9e94				jr z, .ispskip 
9e94			 
9e94				call clear_display 
9e94				call update_display 
9e94				call delay1s 
9e94				ld de, (cli_origptr) 
9e94				ld a, display_row_1 
9e94				call str_at_display 
9e94				 
9e94				ld de, .enddict 
9e94				ld a, display_row_3 
9e94				call str_at_display 
9e94				call update_display 
9e94				ld a, 100 
9e94				call aDelayInMS 
9e94				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9e94				call delay1s 
9e94				call delay1s 
9e94				call delay1s 
9e94				endif 
9e94			.ispskip:  
9e94				 
9e94			endif	 
9e94			 
9e94			 
9e94			 
9e94				; if the word is not a keyword then must be a literal so push it to stack 
9e94			 
9e94			; push token to stack to end of word 
9e94			 
9e94				STACKFRAME ON $1efe $2f9f 
9e94				if DEBUG_STACK_IMB 
9e94					if ON 
9e94						exx 
9e94						ld de, $1efe 
9e94						ld a, d 
9e94						ld hl, curframe 
9e94						call hexout 
9e94						ld a, e 
9e94						ld hl, curframe+2 
9e94						call hexout 
9e94						ld hl, $1efe 
9e94						push hl 
9e94						ld hl, $2f9f 
9e94						push hl 
9e94						exx 
9e94					endif 
9e94				endif 
9e94			endm 
# End of macro STACKFRAME
9e94			 
9e94 2a b9 e5		ld hl,(os_tok_ptr) 
9e97 cd 29 9b		call forth_apush 
9e9a			 
9e9a				STACKFRAMECHK ON $1efe $2f9f 
9e9a				if DEBUG_STACK_IMB 
9e9a					if ON 
9e9a						exx 
9e9a						ld hl, $2f9f 
9e9a						pop de   ; $2f9f 
9e9a						call cmp16 
9e9a						jr nz, .spnosame 
9e9a						ld hl, $1efe 
9e9a						pop de   ; $1efe 
9e9a						call cmp16 
9e9a						jr z, .spfrsame 
9e9a						.spnosame: call showsperror 
9e9a						.spfrsame: nop 
9e9a						exx 
9e9a					endif 
9e9a				endif 
9e9a			endm 
# End of macro STACKFRAMECHK
9e9a			 
9e9a			execnext: 
9e9a			 
9e9a			if DEBUG_FORTH_PARSE_EXEC 
9e9a						DMARK "KY>" 
9e9a			endif 
9e9a			; move past token to next word 
9e9a			 
9e9a 2a b9 e5		ld hl, (os_tok_ptr) 
9e9d 3e 00		ld a, 0 
9e9f 01 ff 00		ld bc, 255     ; input buffer size 
9ea2 ed b1		cpir 
9ea4			 
9ea4			if DEBUG_FORTH_PARSE_EXEC 
9ea4						DMARK "KY!" 
9ea4				CALLMONITOR 
9ea4			endif	 
9ea4			; TODO this might place hl on the null, so will need to forward on??? 
9ea4			;inc hl   ; see if this gets onto the next item 
9ea4			 
9ea4			 
9ea4			; TODO pass a pointer to the buffer to push 
9ea4			; TODO call function to push 
9ea4			 
9ea4			; look for end of input 
9ea4			 
9ea4			;inc hl 
9ea4			;ld a,(hl) 
9ea4			;cp FORTH_END_BUFFER 
9ea4			;ret z 
9ea4			 
9ea4			 
9ea4 c3 2b 9e		jp exec1 
9ea7			 
9ea7			 
9ea7			 
9ea7			 
9ea7			 
9ea7			 
9ea7			 
9ea7			 
9ea7			 
9ea7			findnexttok: 
9ea7			 
9ea7				; hl is pointer to move 
9ea7				; de is the token to locate 
9ea7			 
9ea7					if DEBUG_FORTH 
9ea7						DMARK "NTK" 
9ea7						CALLMONITOR 
9ea7					endif 
9ea7 d5				push de 
9ea8			 
9ea8			.fnt1:	 
9ea8				; find first char of token to locate 
9ea8			 
9ea8 1a				ld a, (de) 
9ea9 4f				ld c,a 
9eaa 7e				ld a,(hl) 
9eab cd 25 90			call toUpper 
9eae					if DEBUG_FORTH 
9eae						DMARK "NT1" 
9eae						CALLMONITOR 
9eae					endif 
9eae b9				cp c 
9eaf			 
9eaf 28 03			jr z, .fnt2cmpmorefirst	 
9eb1			 
9eb1				; first char not found move to next char 
9eb1			 
9eb1 23				inc hl 
9eb2 18 f4			jr .fnt1 
9eb4			 
9eb4			.fnt2cmpmorefirst:	 
9eb4				; first char of token found.  
9eb4			 
9eb4 e5				push hl     ; save start of token just in case it is the right one 
9eb5 d9				exx 
9eb6 e1				pop hl        ; save it to hl' 
9eb7 d9				exx 
9eb8			 
9eb8			 
9eb8			.fnt2cmpmore:	 
9eb8				; compare the rest 
9eb8				 
9eb8 23				inc hl 
9eb9 13				inc de 
9eba				 
9eba 1a				ld a, (de) 
9ebb 4f				ld c,a 
9ebc 7e				ld a,(hl) 
9ebd cd 25 90			call toUpper 
9ec0			 
9ec0					if DEBUG_FORTH 
9ec0						DMARK "NT2" 
9ec0						CALLMONITOR 
9ec0					endif 
9ec0				; c has the token to find char 
9ec0				; a has the mem to scan char 
9ec0			 
9ec0 b9				cp c 
9ec1 28 04			jr z,.fntmatch1 
9ec3			 
9ec3				; they are not the same 
9ec3			 
9ec3					if DEBUG_FORTH 
9ec3						DMARK "NT3" 
9ec3						CALLMONITOR 
9ec3					endif 
9ec3 d1				pop de	; reset de token to look for 
9ec4 d5				push de 
9ec5 18 e1			jr .fnt1 
9ec7				 
9ec7			.fntmatch1: 
9ec7			 
9ec7				; is the same char a null which means we might have a full hit? 
9ec7					if DEBUG_FORTH 
9ec7						DMARK "NT4" 
9ec7						CALLMONITOR 
9ec7					endif 
9ec7			 
9ec7			;	cp 0 
9ec7 b7				or a 
9ec8 28 0b			jr z, .fntmatchyes 
9eca			 
9eca				; are we at the end of the token to find? 
9eca			 
9eca					if DEBUG_FORTH 
9eca						DMARK "NT5" 
9eca						CALLMONITOR 
9eca					endif 
9eca 3e 00			ld a, 0 
9ecc b9				cp c 
9ecd			 
9ecd c2 b8 9e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9ed0			 
9ed0					if DEBUG_FORTH 
9ed0						DMARK "NT6" 
9ed0						CALLMONITOR 
9ed0					endif 
9ed0				; token to find is exhusted but no match to stream 
9ed0			 
9ed0				; restore tok pointer and continue on 
9ed0 d1				pop de 
9ed1 d5				push de 
9ed2 c3 a8 9e			jp .fnt1 
9ed5			 
9ed5			 
9ed5			.fntmatchyes: 
9ed5			 
9ed5				; hl now contains the end of the found token 
9ed5			 
9ed5				; get rid of saved token pointer to find 
9ed5			 
9ed5 d1				pop de 
9ed6			 
9ed6					if DEBUG_FORTH 
9ed6						DMARK "NT9" 
9ed6						CALLMONITOR 
9ed6					endif 
9ed6			 
9ed6				; hl will be on the null term so forward on 
9ed6			 
9ed6				; get back the saved start of the token 
9ed6			 
9ed6 d9				exx 
9ed7 e5				push hl     ; save start of token just in case it is the right one 
9ed8 d9				exx 
9ed9 e1				pop hl        ; save it to hl 
9eda			 
9eda c9				ret 
9edb			 
9edb			 
9edb			; LIST needs to find a specific token   
9edb			; FORGET needs to find a spefici token 
9edb			 
9edb			; SAVE needs to find all tokens by flag 
9edb			; WORDS just needs to scan through all  by flag 
9edb			; UWORDS needs to scan through all by flag 
9edb			 
9edb			 
9edb			; given hl as pointer to start of dict look up string 
9edb			; return hl as pointer to start of word block 
9edb			; or 0 if not found 
9edb			 
9edb			forth_find_tok: 
9edb c9				ret 
9edc			 
9edc			; given hl as pointer to dict structure 
9edc			; move to the next dict block structure 
9edc			 
9edc			forth_tok_next: 
9edc				; hl now points to the address of the next word pointer  
9edc				; TODO skip compiled symbol for now 
9edc			;	push de 
9edc 23				inc hl 
9edd 5e				ld e, (hl) 
9ede 23				inc hl 
9edf 56				ld d, (hl) 
9ee0 23				inc hl 
9ee1			 
9ee1 eb				ex de,hl 
9ee2			if DEBUG_FORTH_PARSE_NEXTWORD 
9ee2				push bc 
9ee2				ld bc, (cli_nextword) 
9ee2						DMARK "NXW" 
9ee2				CALLMONITOR 
9ee2				pop bc 
9ee2			endif 
9ee2			;	pop de	 
9ee2 c9				ret 
9ee3			 
9ee3			 
9ee3			 
9ee3			; eof 
# End of file forth_parserv6.asm
9ee3				include "forth_wordsv4.asm" 
9ee3			 
9ee3			; the core word dictionary v4 
9ee3			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9ee3			 
9ee3			; this is a linked list for each of the system words used 
9ee3			; user defined words will follow the same format but will be in ram 
9ee3			 
9ee3			 
9ee3			; 
9ee3			; 
9ee3			; define linked list: 
9ee3			; 
9ee3			; 1. compiled byte op code 
9ee3			; 2. len of text word 
9ee3			; 3. text word 
9ee3			; 4. ptr to next dictionary word 
9ee3			; 5. asm, calls etc for the word 
9ee3			; 
9ee3			;  if 1 == 0 then last word in dict  
9ee3			;   
9ee3			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9ee3			;  
9ee3			;  
9ee3			; create basic standard set of words 
9ee3			; 
9ee3			;  
9ee3			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9ee3			; 2DUP 2DROP 2SWAP  
9ee3			; @ C@ - get byte  
9ee3			; ! C! - store byte 
9ee3			; 0< true if less than zero 
9ee3			; 0= true if zero 
9ee3			; < >  
9ee3			; = true if same 
9ee3			; variables 
9ee3			 
9ee3			 
9ee3			; Hardware specific words I may need 
9ee3			; 
9ee3			; IN OUT  
9ee3			; calls to key util functions 
9ee3			; calls to hardward abstraction stuff 
9ee3			; easy control of frame buffers and lcd i/o 
9ee3			; keyboard  
9ee3			 
9ee3			 
9ee3			;DICT: macro 
9ee3			; op_code, len, word, next 
9ee3			;    word: 
9ee3			;    db op_code 
9ee3			;    ds word zero term 
9ee3			;    dw next 
9ee3			;    endm 
9ee3			 
9ee3			 
9ee3			 
9ee3			 
9ee3			; op code 1 is a flag for user define words which are to be handled differently 
9ee3			 
9ee3			 
9ee3			; 
9ee3			; 
9ee3			;    TODO on entry to a word this should be the expected environment 
9ee3			;    hl - tos value if number then held, if string this is the ptr 
9ee3			;    de -  
9ee3			 
9ee3			 
9ee3			; opcode ranges 
9ee3			; 0 - end of word dict 
9ee3			; 255 - user define words 
9ee3			 
9ee3			sysdict: 
9ee3			include "forth_opcodes.asm" 
9ee3			; op codes for forth keywords 
9ee3			 
9ee3			; Changing use of opcodes to flag is the word exists in compiled form or not.  
9ee3			; This provides a means to compile uwords if required for higher performance 
9ee3			; by avoiding the use of the keyword parser and just jumping directly to the code 
9ee3			; Actually there is already a flag for if the code exists as binary thinking about it... 
9ee3			 
9ee3			 
9ee3			 
9ee3			 
9ee3			 
9ee3			; free to use code 0  
9ee3				OPCODE_HEAP: equ  1 
9ee3				OPCODE_EXEC: equ 2 
9ee3				OPCODE_DUP: equ 3 
9ee3				OPCODE_SWAP: equ 4 
9ee3				OPCODE_COLN: equ 5 
9ee3				OPCODE_SCOLN: equ 6 
9ee3				OPCODE_DROP: equ 7 
9ee3				OPCODE_DUP2: equ 8 
9ee3				OPCODE_DROP2: equ 9 
9ee3				OPCODE_SWAP2: equ 10 
9ee3				OPCODE_AT: equ 11 
9ee3				OPCODE_CAT: equ 12 
9ee3				OPCODE_BANG: equ 13 
9ee3				OPCODE_CBANG: equ 14 
9ee3				OPCODE_SCALL: equ 15 
9ee3				OPCODE_DEPTH: equ 16 
9ee3				OPCODE_OVER: equ 17 
9ee3				OPCODE_PAUSE: equ 18 
9ee3				OPCODE_PAUSES: equ 19 
9ee3				OPCODE_ROT: equ 20 
9ee3			;free to reuse	OPCODE_WORDS: equ 21 
9ee3			        OPCODE_NOT: equ 21 
9ee3				OPCODE_UWORDS: equ 22 
9ee3				OPCODE_BP: equ 23 
9ee3				OPCODE_MONITOR: equ 24  
9ee3				OPCODE_MALLOC: equ 25 
9ee3				OPCODE_FREE: equ 26 
9ee3				OPCODE_LIST: equ 27 
9ee3				OPCODE_FORGET: equ 28 
9ee3				OPCODE_NOP: equ 29 
9ee3				OPCODE_COMO: equ 30 
9ee3				OPCODE_COMC: equ 31 
9ee3			;free to reuse	OPCODE_ENDCORE: equ 32 
9ee3				OPCODE_AFTERSOUND: equ 33 
9ee3				OPCODE_GP2: equ 34 
9ee3				OPCODE_GP3: equ 35 
9ee3				OPCODE_GP4: equ 36 
9ee3				OPCODE_SIN: equ 37 
9ee3				OPCODE_SOUT: equ 38 
9ee3				OPCODE_SPIO: equ 39 
9ee3				OPCODE_SPICEH: equ 40 
9ee3				OPCODE_SPIOb: equ 41 
9ee3				OPCODE_SPII: equ 42 
9ee3				OPCODE_SESEL: equ 43 
9ee3				OPCODE_CARTDEV: equ 44 
9ee3			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9ee3				OPCODE_FB: equ 46 
9ee3				OPCODE_EMIT: equ 47 
9ee3				OPCODE_DOTH: equ 48 
9ee3				OPCODE_DOTF: equ 49 
9ee3				OPCODE_DOT: equ 50 
9ee3				OPCODE_CLS: equ 51 
9ee3				OPCODE_DRAW: equ 52 
9ee3				OPCODE_DUMP: equ 53 
9ee3				OPCODE_CDUMP: equ 54 
9ee3				OPCODE_DAT: equ 55 
9ee3				OPCODE_HOME: equ 56 
9ee3				OPCODE_SPACE: equ 57 
9ee3				OPCODE_SPACES: equ 58 
9ee3				OPCODE_SCROLL: equ 59 
9ee3				OPCODE_ATQ: equ 60 
9ee3				OPCODE_AUTODSP: equ 61 
9ee3				OPCODE_MENU: equ 62 
9ee3			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9ee3				OPCODE_THEN: equ 64 
9ee3				OPCODE_ELSE: equ 65 
9ee3				OPCODE_DO: equ 66 
9ee3				OPCODE_LOOP: equ 67 
9ee3				OPCODE_I: equ 68 
9ee3				OPCODE_DLOOP: equ 69  
9ee3				OPCODE_REPEAT: equ 70  
9ee3				OPCODE_UNTIL: equ 71 
9ee3				OPCODE_ENDFLOW: equ 72 
9ee3				OPCODE_WAITK: equ 73 
9ee3				OPCODE_ACCEPT: equ 74 
9ee3				OPCODE_EDIT: equ 75 
9ee3			;free to reuse	OPCODE_ENDKEY: equ 76 
9ee3				OPCODE_LZERO: equ 77 
9ee3				OPCODE_TZERO: equ 78 
9ee3				OPCODE_LESS: equ 79 
9ee3				OPCODE_GT: equ 80 
9ee3				OPCODE_EQUAL: equ 81  
9ee3			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9ee3				OPCODE_NEG: equ 83 
9ee3				OPCODE_DIV: equ 84 
9ee3				OPCODE_MUL: equ 85 
9ee3				OPCODE_MIN: equ 86 
9ee3				OPCODE_MAX: equ 87 
9ee3				OPCODE_RND16: equ 88 
9ee3				OPCODE_RND8: equ 89 
9ee3				OPCODE_RND: equ 90 
9ee3			;free to reuse	OPCODE_ENDMATHS: equ 91  
9ee3				OPCODE_BYNAME: equ 92 
9ee3				OPCODE_DIR: equ 93 
9ee3				OPCODE_SAVE: equ 94 
9ee3				OPCODE_LOAD: equ 95 
9ee3				OPCODE_BSAVE: equ 96 
9ee3				OPCODE_BLOAD: equ 97 
9ee3				OPCODE_SEO: equ 98  
9ee3				OPCODE_SEI: equ 99 
9ee3				OPCODE_SFREE: equ 100 
9ee3				OPCODE_SIZE: equ 101 
9ee3				OPCODE_CREATE: equ 102 
9ee3				OPCODE_APPEND: equ 103 
9ee3				OPCODE_SDEL: equ 104 
9ee3				OPCODE_OPEN: equ 105 
9ee3				OPCODE_READ: equ 106 
9ee3				OPCODE_EOF: equ 106 
9ee3				OPCODE_FORMAT: equ 107 
9ee3				OPCODE_LABEL: equ 108 
9ee3				OPCODE_LABELS: equ 109 
9ee3			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9ee3				OPCODE_UPPER: equ 111 
9ee3				OPCODE_LOWER: equ 112 
9ee3				OPCODE_SUBSTR: equ 113 
9ee3				OPCODE_LEFT: equ 114 
9ee3				OPCODE_RIGHT: equ 115 
9ee3				OPCODE_STR2NUM: equ 116 
9ee3				OPCODE_NUM2STR: equ 117 
9ee3				OPCODE_CONCAT: equ 118 
9ee3				OPCODE_FIND: equ 119 
9ee3				OPCODE_LEN: equ 120 
9ee3				OPCODE_CHAR: equ 121 
9ee3			; free to reuse	OPCODE_STRLEN: equ 122 
9ee3			; free to reuse	OPCODE_ENDSTR: equ 123 
9ee3				OPCODE_V0S: equ 124 
9ee3				OPCODE_V0Q: equ 125 
9ee3				OPCODE_V1S: equ 126 
9ee3				OPCODE_V1Q: equ 127 
9ee3				OPCODE_V2S: equ 128 
9ee3				OPCODE_V2Q: equ 129 
9ee3				OPCODE_V3S: equ 130 
9ee3				OPCODE_V3Q: equ 131 
9ee3			;free to reuse	OPCODE_END: equ 132 
9ee3				OPCODE_ZDUP: equ 133 
9ee3			 
9ee3			; eof 
# End of file forth_opcodes.asm
9ee3			 
9ee3			include "forth_words_core.asm" 
9ee3			 
9ee3			; | ## Core Words 
9ee3			 
9ee3			;if MALLOC_4 
9ee3			 
9ee3			.HEAP: 
9ee3			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9ee3 15				db WORD_SYS_CORE+OPCODE_HEAP             
9ee4 25 9f			dw .EXEC            
9ee6 05				db 4 + 1 
9ee7 .. 00			db "HEAP",0              
9eec				endm 
# End of macro CWHEAD
9eec			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9eec			; | | u1 - Current number of bytes in the heap 
9eec			; | | u2 - Remaining bytes left on the heap 
9eec			; | |  
9eec			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9eec			 
9eec			 
9eec				if DEBUG_FORTH_WORDS_KEY 
9eec					DMARK "HEP" 
9eec f5				push af  
9eed 3a 01 9f			ld a, (.dmark)  
9ef0 32 62 ee			ld (debug_mark),a  
9ef3 3a 02 9f			ld a, (.dmark+1)  
9ef6 32 63 ee			ld (debug_mark+1),a  
9ef9 3a 03 9f			ld a, (.dmark+2)  
9efc 32 64 ee			ld (debug_mark+2),a  
9eff 18 03			jr .pastdmark  
9f01 ..			.dmark: db "HEP"  
9f04 f1			.pastdmark: pop af  
9f05			endm  
# End of macro DMARK
9f05					CALLMONITOR 
9f05 cd 6f ee			call debug_vector  
9f08				endm  
# End of macro CALLMONITOR
9f08				endif 
9f08 2a 70 e4			ld hl, (free_list )      
9f0b 11 75 e4			ld de, heap_start 
9f0e			 
9f0e ed 52			sbc hl, de  
9f10			 
9f10 cd c7 99			call forth_push_numhl 
9f13			 
9f13			 
9f13 ed 5b 70 e4		ld de, (free_list )      
9f17 21 93 e2			ld hl, heap_end 
9f1a			 
9f1a ed 52			sbc hl, de 
9f1c			 
9f1c cd c7 99			call forth_push_numhl 
9f1f				 
9f1f			 
9f1f				 
9f1f			 
9f1f			 
9f1f			 
9f1f				NEXTW 
9f1f cd 6c ee			call parse_vector 
9f22 c3 aa 9d			jp macro_next 
9f25				endm 
# End of macro NEXTW
9f25			;endif 
9f25			 
9f25			.EXEC: 
9f25			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9f25			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9f25			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9f25			;; > > 
9f25			;; > >   
9f25			;	STACKFRAME OFF $5efe $5f9f 
9f25			; 
9f25			;		if DEBUG_FORTH_WORDS_KEY 
9f25			;			DMARK "EXE" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			; 
9f25			;	FORTH_DSP_VALUEHL 
9f25			; 
9f25			;	FORTH_DSP_POP 
9f25			; 
9f25			;		if DEBUG_FORTH_WORDS 
9f25			;			DMARK "EX1" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			;;	ld e,(hl) 
9f25			;;	inc hl 
9f25			;;	ld d,(hl) 
9f25			;;	ex de,hl 
9f25			; 
9f25			;;		if DEBUG_FORTH_WORDS 
9f25			;;			DMARK "EX2" 
9f25			;;			CALLMONITOR 
9f25			;;		endif 
9f25			;	push hl 
9f25			; 
9f25			;	;ld a, 0 
9f25			;	;ld a, FORTH_END_BUFFER 
9f25			;	call strlenz 
9f25			;	inc hl   ; include zero term to copy 
9f25			;	inc hl   ; include term 
9f25			;	inc hl   ; include term 
9f25			;	ld b,0 
9f25			;	ld c,l 
9f25			;	pop hl 
9f25			;	ld de, execscratch 
9f25			;		if DEBUG_FORTH_WORDS 
9f25			;			DMARK "EX3" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			;	ldir 
9f25			; 
9f25			; 
9f25			;	ld hl, execscratch 
9f25			; 
9f25			;		if DEBUG_FORTH_WORDS 
9f25			;			DMARK "EXe" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			; 
9f25			;	call forthparse 
9f25			;	call forthexec 
9f25			;;	call forthexec_cleanup 
9f25			;;	call forthparse 
9f25			;;	call forthexec 
9f25			; 
9f25			;	STACKFRAMECHK OFF $5efe $5f9f 
9f25			; 
9f25			;	; an immediate word so no need to process any more words 
9f25			;	ret 
9f25			;	NEXTW 
9f25			 
9f25			; dead code - old version  
9f25			;	FORTH_RSP_NEXT 
9f25			 
9f25			;  
9f25			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9f25			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9f25			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9f25			;	push hl 
9f25			;	push de 
9f25			;	push bc 
9f25			; 
9f25			; 
9f25			;		if DEBUG_FORTH_WORDS_KEY 
9f25			;			DMARK "EXR" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			; 
9f25			; 
9f25			; 
9f25			;	;v5 FORTH_DSP_VALUE 
9f25			;	FORTH_DSP_VALUEHL 
9f25			; 
9f25			;	; TODO do string type checks 
9f25			; 
9f25			;;v5	inc hl   ; skip type 
9f25			; 
9f25			;	push hl  ; source code  
9f25			;		if DEBUG_FORTH_WORDS 
9f25			;			DMARK "EX1" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			;	ld a, 0 
9f25			;	call strlent 
9f25			; 
9f25			;	inc hl 
9f25			;	inc hl 
9f25			;	inc hl 
9f25			;	inc hl 
9f25			; 
9f25			;	push hl    ; size 
9f25			; 
9f25			;		if DEBUG_FORTH_WORDS 
9f25			;			DMARK "EX2" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			;	call malloc 
9f25			; 
9f25			;	ex de, hl    ; de now contains malloc area 
9f25			;	pop bc   	; get byte count 
9f25			;	pop hl      ; get string to copy 
9f25			; 
9f25			;	push de     ; save malloc for free later 
9f25			; 
9f25			;		if DEBUG_FORTH_WORDS 
9f25			;			DMARK "EX3" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			;	ldir       ; duplicate string 
9f25			; 
9f25			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9f25			;	 
9f25			;	; TODO fix the parse would be better than this...  
9f25			;	ex de, hl 
9f25			;	dec hl 
9f25			;	ld a, 0 
9f25			;	ld (hl), a 
9f25			;	dec hl 
9f25			;	ld a, ' ' 
9f25			;	ld (hl), a 
9f25			;	dec hl 
9f25			;	ld (hl), a 
9f25			; 
9f25			;	dec hl 
9f25			;	ld (hl), a 
9f25			; 
9f25			; 
9f25			;	FORTH_DSP_POP  
9f25			; 
9f25			;	pop hl     
9f25			;	push hl    ; save malloc area 
9f25			; 
9f25			;		if DEBUG_FORTH_WORDS 
9f25			;			DMARK "EX4" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			; 
9f25			;	call forthparse 
9f25			;	call forthexec 
9f25			;	 
9f25			;	pop hl 
9f25			;	if DEBUG_FORTH_WORDS 
9f25			;		DMARK "EX5" 
9f25			;		CALLMONITOR 
9f25			;	endif 
9f25			; 
9f25			;	if FORTH_ENABLE_FREE 
9f25			;	call free 
9f25			;	endif 
9f25			; 
9f25			;	if DEBUG_FORTH_WORDS 
9f25			;		DMARK "EX6" 
9f25			;		CALLMONITOR 
9f25			;	endif 
9f25			; 
9f25			;	pop bc 
9f25			;	pop de 
9f25			;	pop hl 
9f25			;;	FORTH_RSP_POP	  
9f25			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9f25			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9f25			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9f25			; 
9f25			;	if DEBUG_FORTH_WORDS 
9f25			;		DMARK "EX7" 
9f25			;		CALLMONITOR 
9f25			;	endif 
9f25			;	NEXTW 
9f25			 
9f25			;.STKEXEC: 
9f25			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9f25			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9f25			; 
9f25			; 
9f25			;		if DEBUG_FORTH_WORDS_KEY 
9f25			;			DMARK "STX" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			; 
9f25			;	FORTH_DSP_VALUEHL 
9f25			; 
9f25			;	ld (store_tmp1), hl    ; count 
9f25			; 
9f25			;	FORTH_DSP_POP 
9f25			;.stkexec1: 
9f25			;	ld hl, (store_tmp1)   ; count 
9f25			;	ld a, 0 
9f25			;	cp l 
9f25			;	ret z 
9f25			; 
9f25			;	dec hl 
9f25			;	ld (store_tmp1), hl    ; count 
9f25			;	 
9f25			;	FORTH_DSP_VALUEHL 
9f25			;	push hl 
9f25			;	 
9f25			;		if DEBUG_FORTH_WORDS 
9f25			;			DMARK "EXp" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			;	FORTH_DSP_POP 
9f25			; 
9f25			;	call strlenz 
9f25			;	inc hl   ; include zero term to copy 
9f25			;	inc hl   ; include zero term to copy 
9f25			;	inc hl   ; include zero term to copy 
9f25			;	ld b,0 
9f25			;	ld c,l 
9f25			;	pop hl 
9f25			;	ld de, execscratch 
9f25			;		if DEBUG_FORTH_WORDS 
9f25			;			DMARK "EX3" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			;	ldir 
9f25			; 
9f25			; 
9f25			;	ld hl, execscratch 
9f25			; 
9f25			;		if DEBUG_FORTH_WORDS 
9f25			;			DMARK "EXP" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			; 
9f25			;	call forthparse 
9f25			;	ld hl, execscratch 
9f25			;		if DEBUG_FORTH_WORDS 
9f25			;			DMARK "EXx" 
9f25			;			CALLMONITOR 
9f25			;		endif 
9f25			;	call forthexec 
9f25			; 
9f25			;	jp .stkexec1 
9f25			; 
9f25			;	ret 
9f25			 
9f25			 
9f25			.DUP: 
9f25			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9f25 17				db WORD_SYS_CORE+OPCODE_DUP             
9f26 a1 9f			dw .ZDUP            
9f28 04				db 3 + 1 
9f29 .. 00			db "DUP",0              
9f2d				endm 
# End of macro CWHEAD
9f2d			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9f2d			; | | >[!NOTE] 
9f2d			; | | > If the duplicated item is a string it is safely duplicated 
9f2d			 
9f2d				if DEBUG_FORTH_WORDS_KEY 
9f2d					DMARK "DUP" 
9f2d f5				push af  
9f2e 3a 42 9f			ld a, (.dmark)  
9f31 32 62 ee			ld (debug_mark),a  
9f34 3a 43 9f			ld a, (.dmark+1)  
9f37 32 63 ee			ld (debug_mark+1),a  
9f3a 3a 44 9f			ld a, (.dmark+2)  
9f3d 32 64 ee			ld (debug_mark+2),a  
9f40 18 03			jr .pastdmark  
9f42 ..			.dmark: db "DUP"  
9f45 f1			.pastdmark: pop af  
9f46			endm  
# End of macro DMARK
9f46					CALLMONITOR 
9f46 cd 6f ee			call debug_vector  
9f49				endm  
# End of macro CALLMONITOR
9f49				endif 
9f49			 
9f49				FORTH_DSP 
9f49 cd 89 9b			call macro_forth_dsp 
9f4c				endm 
# End of macro FORTH_DSP
9f4c			 
9f4c 7e				ld a, (HL) 
9f4d fe 01			cp DS_TYPE_STR 
9f4f 20 28			jr nz, .dupinum 
9f51			 
9f51				; push another string 
9f51			 
9f51				FORTH_DSP_VALUEHL     		 
9f51 cd c3 9b			call macro_dsp_valuehl 
9f54				endm 
# End of macro FORTH_DSP_VALUEHL
9f54			 
9f54			if DEBUG_FORTH_WORDS 
9f54				DMARK "DUs" 
9f54 f5				push af  
9f55 3a 69 9f			ld a, (.dmark)  
9f58 32 62 ee			ld (debug_mark),a  
9f5b 3a 6a 9f			ld a, (.dmark+1)  
9f5e 32 63 ee			ld (debug_mark+1),a  
9f61 3a 6b 9f			ld a, (.dmark+2)  
9f64 32 64 ee			ld (debug_mark+2),a  
9f67 18 03			jr .pastdmark  
9f69 ..			.dmark: db "DUs"  
9f6c f1			.pastdmark: pop af  
9f6d			endm  
# End of macro DMARK
9f6d				CALLMONITOR 
9f6d cd 6f ee			call debug_vector  
9f70				endm  
# End of macro CALLMONITOR
9f70			endif 
9f70 cd 31 9a			call forth_push_str 
9f73			 
9f73				NEXTW 
9f73 cd 6c ee			call parse_vector 
9f76 c3 aa 9d			jp macro_next 
9f79				endm 
# End of macro NEXTW
9f79			 
9f79			 
9f79			.dupinum: 
9f79				 
9f79			 
9f79			 
9f79				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9f79 cd c3 9b			call macro_dsp_valuehl 
9f7c				endm 
# End of macro FORTH_DSP_VALUEHL
9f7c			 
9f7c			; TODO add floating point number detection 
9f7c			 
9f7c			if DEBUG_FORTH_WORDS 
9f7c				DMARK "DUi" 
9f7c f5				push af  
9f7d 3a 91 9f			ld a, (.dmark)  
9f80 32 62 ee			ld (debug_mark),a  
9f83 3a 92 9f			ld a, (.dmark+1)  
9f86 32 63 ee			ld (debug_mark+1),a  
9f89 3a 93 9f			ld a, (.dmark+2)  
9f8c 32 64 ee			ld (debug_mark+2),a  
9f8f 18 03			jr .pastdmark  
9f91 ..			.dmark: db "DUi"  
9f94 f1			.pastdmark: pop af  
9f95			endm  
# End of macro DMARK
9f95				CALLMONITOR 
9f95 cd 6f ee			call debug_vector  
9f98				endm  
# End of macro CALLMONITOR
9f98			endif 
9f98			 
9f98 cd c7 99			call forth_push_numhl 
9f9b				NEXTW 
9f9b cd 6c ee			call parse_vector 
9f9e c3 aa 9d			jp macro_next 
9fa1				endm 
# End of macro NEXTW
9fa1			.ZDUP: 
9fa1			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9fa1 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9fa2 db 9f			dw .DMRK            
9fa4 05				db 4 + 1 
9fa5 .. 00			db "?DUP",0              
9faa				endm 
# End of macro CWHEAD
9faa			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
9faa			; | | >[!NOTE] 
9faa			; | | > If the duplicated item is a string it is not safely duplicated and remain as pointer to the origin 
9faa			 
9faa				if DEBUG_FORTH_WORDS_KEY 
9faa					DMARK "qDU" 
9faa f5				push af  
9fab 3a bf 9f			ld a, (.dmark)  
9fae 32 62 ee			ld (debug_mark),a  
9fb1 3a c0 9f			ld a, (.dmark+1)  
9fb4 32 63 ee			ld (debug_mark+1),a  
9fb7 3a c1 9f			ld a, (.dmark+2)  
9fba 32 64 ee			ld (debug_mark+2),a  
9fbd 18 03			jr .pastdmark  
9fbf ..			.dmark: db "qDU"  
9fc2 f1			.pastdmark: pop af  
9fc3			endm  
# End of macro DMARK
9fc3					CALLMONITOR 
9fc3 cd 6f ee			call debug_vector  
9fc6				endm  
# End of macro CALLMONITOR
9fc6				endif 
9fc6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9fc6 cd c3 9b			call macro_dsp_valuehl 
9fc9				endm 
# End of macro FORTH_DSP_VALUEHL
9fc9			 
9fc9 e5				push hl 
9fca			 
9fca				; is it a zero? 
9fca			 
9fca 3e 00			ld a, 0 
9fcc 84				add h 
9fcd 85				add l 
9fce			 
9fce e1				pop hl 
9fcf			 
9fcf			;	cp 0 
9fcf b7				or a 
9fd0 28 03			jr z, .dup2orig 
9fd2			 
9fd2			 
9fd2 cd c7 99			call forth_push_numhl 
9fd5			 
9fd5			 
9fd5			; TODO add floating point number detection 
9fd5			 
9fd5			.dup2orig: 
9fd5			 
9fd5				NEXTW 
9fd5 cd 6c ee			call parse_vector 
9fd8 c3 aa 9d			jp macro_next 
9fdb				endm 
# End of macro NEXTW
9fdb			.DMRK: 
9fdb			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
9fdb 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9fdc 1b a0			dw .LSHIFT            
9fde 06				db 5 + 1 
9fdf .. 00			db "DMARK",0              
9fe5				endm 
# End of macro CWHEAD
9fe5			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
9fe5			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
9fe5				if DEBUG_FORTH_WORDS_KEY 
9fe5					DMARK "DMK" 
9fe5 f5				push af  
9fe6 3a fa 9f			ld a, (.dmark)  
9fe9 32 62 ee			ld (debug_mark),a  
9fec 3a fb 9f			ld a, (.dmark+1)  
9fef 32 63 ee			ld (debug_mark+1),a  
9ff2 3a fc 9f			ld a, (.dmark+2)  
9ff5 32 64 ee			ld (debug_mark+2),a  
9ff8 18 03			jr .pastdmark  
9ffa ..			.dmark: db "DMK"  
9ffd f1			.pastdmark: pop af  
9ffe			endm  
# End of macro DMARK
9ffe					CALLMONITOR 
9ffe cd 6f ee			call debug_vector  
a001				endm  
# End of macro CALLMONITOR
a001				endif 
a001				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a001 cd c3 9b			call macro_dsp_valuehl 
a004				endm 
# End of macro FORTH_DSP_VALUEHL
a004			 
a004 7e				ld a, (hl) 
a005 32 62 ee			ld (debug_mark),a 
a008 23				inc hl 
a009 7e				ld a, (hl) 
a00a 32 63 ee			ld (debug_mark+1),a 
a00d 23				inc hl 
a00e 7e				ld a, (hl) 
a00f 32 64 ee			ld (debug_mark+2),a 
a012			 
a012			 
a012				FORTH_DSP_POP 
a012 cd 7b 9c			call macro_forth_dsp_pop 
a015				endm 
# End of macro FORTH_DSP_POP
a015				NEXTW 
a015 cd 6c ee			call parse_vector 
a018 c3 aa 9d			jp macro_next 
a01b				endm 
# End of macro NEXTW
a01b			.LSHIFT: 
a01b			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
a01b 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a01c 52 a0			dw .RSHIFT            
a01e 07				db 6 + 1 
a01f .. 00			db "LSHIFT",0              
a026				endm 
# End of macro CWHEAD
a026			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
a026				if DEBUG_FORTH_WORDS_KEY 
a026					DMARK "LSH" 
a026 f5				push af  
a027 3a 3b a0			ld a, (.dmark)  
a02a 32 62 ee			ld (debug_mark),a  
a02d 3a 3c a0			ld a, (.dmark+1)  
a030 32 63 ee			ld (debug_mark+1),a  
a033 3a 3d a0			ld a, (.dmark+2)  
a036 32 64 ee			ld (debug_mark+2),a  
a039 18 03			jr .pastdmark  
a03b ..			.dmark: db "LSH"  
a03e f1			.pastdmark: pop af  
a03f			endm  
# End of macro DMARK
a03f					CALLMONITOR 
a03f cd 6f ee			call debug_vector  
a042				endm  
# End of macro CALLMONITOR
a042				endif 
a042				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a042 cd c3 9b			call macro_dsp_valuehl 
a045				endm 
# End of macro FORTH_DSP_VALUEHL
a045				FORTH_DSP_POP 
a045 cd 7b 9c			call macro_forth_dsp_pop 
a048				endm 
# End of macro FORTH_DSP_POP
a048			 
a048 29				add hl, hl 
a049 cd c7 99			call forth_push_numhl 
a04c				NEXTW 
a04c cd 6c ee			call parse_vector 
a04f c3 aa 9d			jp macro_next 
a052				endm 
# End of macro NEXTW
a052			.RSHIFT: 
a052			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
a052 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a053 8c a0			dw .SWAP            
a055 07				db 6 + 1 
a056 .. 00			db "RSHIFT",0              
a05d				endm 
# End of macro CWHEAD
a05d			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
a05d				if DEBUG_FORTH_WORDS_KEY 
a05d					DMARK "RSH" 
a05d f5				push af  
a05e 3a 72 a0			ld a, (.dmark)  
a061 32 62 ee			ld (debug_mark),a  
a064 3a 73 a0			ld a, (.dmark+1)  
a067 32 63 ee			ld (debug_mark+1),a  
a06a 3a 74 a0			ld a, (.dmark+2)  
a06d 32 64 ee			ld (debug_mark+2),a  
a070 18 03			jr .pastdmark  
a072 ..			.dmark: db "RSH"  
a075 f1			.pastdmark: pop af  
a076			endm  
# End of macro DMARK
a076					CALLMONITOR 
a076 cd 6f ee			call debug_vector  
a079				endm  
# End of macro CALLMONITOR
a079				endif 
a079				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a079 cd c3 9b			call macro_dsp_valuehl 
a07c				endm 
# End of macro FORTH_DSP_VALUEHL
a07c				FORTH_DSP_POP 
a07c cd 7b 9c			call macro_forth_dsp_pop 
a07f				endm 
# End of macro FORTH_DSP_POP
a07f cb 3c			srl h 
a081 cb 1d			rr l 
a083 cd c7 99			call forth_push_numhl 
a086				NEXTW 
a086 cd 6c ee			call parse_vector 
a089 c3 aa 9d			jp macro_next 
a08c				endm 
# End of macro NEXTW
a08c			.SWAP: 
a08c			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a08c 18				db WORD_SYS_CORE+OPCODE_SWAP             
a08d e3 a0			dw .COLN            
a08f 05				db 4 + 1 
a090 .. 00			db "SWAP",0              
a095				endm 
# End of macro CWHEAD
a095			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a095				if DEBUG_FORTH_WORDS_KEY 
a095					DMARK "SWP" 
a095 f5				push af  
a096 3a aa a0			ld a, (.dmark)  
a099 32 62 ee			ld (debug_mark),a  
a09c 3a ab a0			ld a, (.dmark+1)  
a09f 32 63 ee			ld (debug_mark+1),a  
a0a2 3a ac a0			ld a, (.dmark+2)  
a0a5 32 64 ee			ld (debug_mark+2),a  
a0a8 18 03			jr .pastdmark  
a0aa ..			.dmark: db "SWP"  
a0ad f1			.pastdmark: pop af  
a0ae			endm  
# End of macro DMARK
a0ae					CALLMONITOR 
a0ae cd 6f ee			call debug_vector  
a0b1				endm  
# End of macro CALLMONITOR
a0b1				endif 
a0b1			 
a0b1			; DONE Use os stack swap memory 
a0b1			 
a0b1				FORTH_DSP_PTR 0     ; TOS 
a0b1 2a e5 e9			ld hl,(cli_data_sp) 
a0b4 11 00 00			ld de, 0 * 3 
a0b7 ed 52			sbc hl, de 
a0b9				endm 
# End of macro FORTH_DSP_PTR
a0b9 cd fa 9c			call hltostack1 
a0bc			  
a0bc				FORTH_DSP_PTR 1     ; TOS 
a0bc 2a e5 e9			ld hl,(cli_data_sp) 
a0bf 11 03 00			ld de, 1 * 3 
a0c2 ed 52			sbc hl, de 
a0c4				endm 
# End of macro FORTH_DSP_PTR
a0c4 cd 00 9d			call hltostack2 
a0c7			 
a0c7				FORTH_DSP_PTR 0     ; TOS 
a0c7 2a e5 e9			ld hl,(cli_data_sp) 
a0ca 11 00 00			ld de, 0 * 3 
a0cd ed 52			sbc hl, de 
a0cf				endm 
# End of macro FORTH_DSP_PTR
a0cf cd 18 9d			call hlfromstack2 
a0d2			 
a0d2				FORTH_DSP_PTR 1     ; TOS 
a0d2 2a e5 e9			ld hl,(cli_data_sp) 
a0d5 11 03 00			ld de, 1 * 3 
a0d8 ed 52			sbc hl, de 
a0da				endm 
# End of macro FORTH_DSP_PTR
a0da cd 12 9d			call hlfromstack1 
a0dd			;	FORTH_DSP_VALUEHL 
a0dd			;	push hl     ; w2 
a0dd			; 
a0dd			;	FORTH_DSP_POP 
a0dd			; 
a0dd			;	FORTH_DSP_VALUEHL 
a0dd			; 
a0dd			;	FORTH_DSP_POP 
a0dd			; 
a0dd			;	pop de     ; w2	, hl = w1 
a0dd			; 
a0dd			;	ex de, hl 
a0dd			;	push de 
a0dd			; 
a0dd			;	call forth_push_numhl 
a0dd			; 
a0dd			;	pop hl 
a0dd			; 
a0dd			;	call forth_push_numhl 
a0dd				 
a0dd			 
a0dd				NEXTW 
a0dd cd 6c ee			call parse_vector 
a0e0 c3 aa 9d			jp macro_next 
a0e3				endm 
# End of macro NEXTW
a0e3			.COLN: 
a0e3			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a0e3 19				db WORD_SYS_CORE+OPCODE_COLN             
a0e4 6e a2			dw .SCOLN            
a0e6 02				db 1 + 1 
a0e7 .. 00			db ":",0              
a0e9				endm 
# End of macro CWHEAD
a0e9			; | : ( -- )         Create new word | DONE 
a0e9			 
a0e9				if DEBUG_FORTH_WORDS_KEY 
a0e9					DMARK "CLN" 
a0e9 f5				push af  
a0ea 3a fe a0			ld a, (.dmark)  
a0ed 32 62 ee			ld (debug_mark),a  
a0f0 3a ff a0			ld a, (.dmark+1)  
a0f3 32 63 ee			ld (debug_mark+1),a  
a0f6 3a 00 a1			ld a, (.dmark+2)  
a0f9 32 64 ee			ld (debug_mark+2),a  
a0fc 18 03			jr .pastdmark  
a0fe ..			.dmark: db "CLN"  
a101 f1			.pastdmark: pop af  
a102			endm  
# End of macro DMARK
a102					CALLMONITOR 
a102 cd 6f ee			call debug_vector  
a105				endm  
# End of macro CALLMONITOR
a105				endif 
a105			STACKFRAME OFF $8efe $989f 
a105				if DEBUG_STACK_IMB 
a105					if OFF 
a105						exx 
a105						ld de, $8efe 
a105						ld a, d 
a105						ld hl, curframe 
a105						call hexout 
a105						ld a, e 
a105						ld hl, curframe+2 
a105						call hexout 
a105						ld hl, $8efe 
a105						push hl 
a105						ld hl, $989f 
a105						push hl 
a105						exx 
a105					endif 
a105				endif 
a105			endm 
# End of macro STACKFRAME
a105			; get parser buffer length  of new word 
a105			 
a105			 
a105			 
a105				; move tok past this to start of name defintition 
a105				; TODO get word to define 
a105				; TODO Move past word token 
a105				; TODO get length of string up to the ';' 
a105			 
a105 2a b9 e5		ld hl, (os_tok_ptr) 
a108 23			inc hl 
a109 23			inc hl 
a10a			 
a10a 3e 3b		ld a, ';' 
a10c cd 39 90		call strlent 
a10f			 
a10f 7d			ld a,l 
a110 32 a8 e2		ld (os_new_parse_len), a 
a113			 
a113			 
a113			if DEBUG_FORTH_UWORD 
a113 ed 5b b9 e5	ld de, (os_tok_ptr) 
a117					DMARK ":01" 
a117 f5				push af  
a118 3a 2c a1			ld a, (.dmark)  
a11b 32 62 ee			ld (debug_mark),a  
a11e 3a 2d a1			ld a, (.dmark+1)  
a121 32 63 ee			ld (debug_mark+1),a  
a124 3a 2e a1			ld a, (.dmark+2)  
a127 32 64 ee			ld (debug_mark+2),a  
a12a 18 03			jr .pastdmark  
a12c ..			.dmark: db ":01"  
a12f f1			.pastdmark: pop af  
a130			endm  
# End of macro DMARK
a130			CALLMONITOR 
a130 cd 6f ee			call debug_vector  
a133				endm  
# End of macro CALLMONITOR
a133			endif 
a133			 
a133			; 
a133			;  new word memory layout: 
a133			;  
a133			;    : adg 6666 ;  
a133			; 
a133			;    db   1     ; user defined word  
a133 23			inc hl    
a134			;    dw   sysdict 
a134 23			inc hl 
a135 23			inc hl 
a136			;    db <word len>+1 (for null) 
a136 23			inc hl 
a137			;    db .... <word> 
a137			; 
a137			 
a137 23			inc hl    ; some extras for the word preamble before the above 
a138 23			inc hl 
a139 23			inc hl 
a13a 23			inc hl 
a13b 23			inc hl 
a13c 23			inc hl 
a13d 23			inc hl  
a13e 23			inc hl 
a13f 23			inc hl 
a140 23			inc hl 
a141 23			inc hl 
a142 23			inc hl 
a143 23			inc hl 
a144 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a145			;       exec word buffer 
a145			;	<ptr word>   
a145 23			inc hl 
a146 23			inc hl 
a147			;       <word list><null term> 7F final term 
a147			 
a147			 
a147			if DEBUG_FORTH_UWORD 
a147					DMARK ":02" 
a147 f5				push af  
a148 3a 5c a1			ld a, (.dmark)  
a14b 32 62 ee			ld (debug_mark),a  
a14e 3a 5d a1			ld a, (.dmark+1)  
a151 32 63 ee			ld (debug_mark+1),a  
a154 3a 5e a1			ld a, (.dmark+2)  
a157 32 64 ee			ld (debug_mark+2),a  
a15a 18 03			jr .pastdmark  
a15c ..			.dmark: db ":02"  
a15f f1			.pastdmark: pop af  
a160			endm  
# End of macro DMARK
a160			CALLMONITOR 
a160 cd 6f ee			call debug_vector  
a163				endm  
# End of macro CALLMONITOR
a163			endif 
a163			 
a163			 
a163				; malloc the size 
a163			 
a163 cd a2 90			call malloc 
a166 22 aa e2			ld (os_new_malloc), hl     ; save malloc start 
a169			 
a169			;    db   1     ; user defined word  
a169			;	ld a, WORD_SYS_UWORD  
a169 36 01			ld (hl), WORD_SYS_UWORD 
a16b			 
a16b 23			inc hl    
a16c			;    dw   sysdict 
a16c 11 e3 9e		ld de, sysdict       ; continue on with the scan to the system dict 
a16f 73			ld (hl), e 
a170 23			inc hl 
a171 72			ld (hl), d 
a172 23			inc hl 
a173			 
a173			 
a173			;    Setup dict word 
a173			 
a173 23			inc hl 
a174 22 a4 e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a177			 
a177			; 1. get length of dict word 
a177			 
a177			 
a177 2a b9 e5		ld hl, (os_tok_ptr) 
a17a 23			inc hl 
a17b 23			inc hl    ; position to start of dict word 
a17c 3e 00		ld a, 0 
a17e cd 39 90		call strlent 
a181			 
a181			 
a181 23			inc hl    ; to include null??? 
a182			 
a182			; write length of dict word 
a182			 
a182 ed 5b a4 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a186 1b			dec de 
a187 eb			ex de, hl 
a188 73			ld (hl), e 
a189 eb			ex de, hl 
a18a			 
a18a			 
a18a			 
a18a			; copy  
a18a 4d			ld c, l 
a18b 06 00		ld b, 0 
a18d ed 5b a4 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a191 2a b9 e5		ld hl, (os_tok_ptr) 
a194 23			inc hl 
a195 23			inc hl    ; position to start of dict word 
a196			 
a196			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a196			 
a196			; TODO need to convert word to upper case 
a196			 
a196			ucasetok:	 
a196 7e			ld a,(hl) 
a197 cd 25 90		call toUpper 
a19a 77			ld (hl),a 
a19b ed a0		ldi 
a19d f2 96 a1		jp p, ucasetok 
a1a0			 
a1a0			 
a1a0			 
a1a0			; de now points to start of where the word body code should be placed 
a1a0 ed 53 a4 e2	ld (os_new_work_ptr), de 
a1a4			; hl now points to the words to throw at forthexec which needs to be copied 
a1a4 22 a2 e2		ld (os_new_src_ptr), hl 
a1a7			 
a1a7			; TODO add 'call to forthexec' 
a1a7			 
a1a7			if DEBUG_FORTH_UWORD 
a1a7 c5			push bc 
a1a8 ed 4b aa e2	ld bc, (os_new_malloc) 
a1ac					DMARK ":0x" 
a1ac f5				push af  
a1ad 3a c1 a1			ld a, (.dmark)  
a1b0 32 62 ee			ld (debug_mark),a  
a1b3 3a c2 a1			ld a, (.dmark+1)  
a1b6 32 63 ee			ld (debug_mark+1),a  
a1b9 3a c3 a1			ld a, (.dmark+2)  
a1bc 32 64 ee			ld (debug_mark+2),a  
a1bf 18 03			jr .pastdmark  
a1c1 ..			.dmark: db ":0x"  
a1c4 f1			.pastdmark: pop af  
a1c5			endm  
# End of macro DMARK
a1c5			CALLMONITOR 
a1c5 cd 6f ee			call debug_vector  
a1c8				endm  
# End of macro CALLMONITOR
a1c8 c1			pop bc 
a1c9			endif 
a1c9			 
a1c9			 
a1c9			; create word preamble which should be: 
a1c9			 
a1c9			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a1c9			 
a1c9			;    ld hl, <word code> 
a1c9			;    jp user_exec 
a1c9			;    <word code bytes> 
a1c9			 
a1c9			 
a1c9			;	inc de     ; TODO ??? or are we already past the word's null 
a1c9 eb			ex de, hl 
a1ca			 
a1ca 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a1cc			 
a1cc 23			inc hl 
a1cd 22 9e e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a1d0 23			inc hl 
a1d1			 
a1d1 23			inc hl 
a1d2 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a1d4			 
a1d4 01 46 d2		ld bc, user_exec 
a1d7 23			inc hl 
a1d8 71			ld (hl), c     ; poke address of user_exec 
a1d9 23			inc hl 
a1da 70			ld (hl), b     
a1db			; 
a1db			;	inc hl 
a1db			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1db			; 
a1db			; 
a1db			;	ld bc, macro_forth_rsp_next 
a1db			;	inc hl 
a1db			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a1db			;	inc hl 
a1db			;	ld (hl), b     
a1db			; 
a1db			;	inc hl 
a1db			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1db			; 
a1db			; 
a1db			;	inc hl 
a1db			;	ld bc, forthexec 
a1db			;	ld (hl), c     ; poke address of forthexec 
a1db			;	inc hl 
a1db			;	ld (hl), b      
a1db			; 
a1db			;	inc hl 
a1db			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a1db			; 
a1db			;	ld bc, user_dict_next 
a1db			;	inc hl 
a1db			;	ld (hl), c     ; poke address of forthexec 
a1db			;	inc hl 
a1db			;	ld (hl), b      
a1db			 
a1db			; hl is now where we need to copy the word byte data to save this 
a1db			 
a1db 23			inc hl 
a1dc 22 a0 e2		ld (os_new_exec), hl 
a1df			 
a1df			; copy definition 
a1df			 
a1df eb			ex de, hl 
a1e0			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a1e0			;	inc de    ; skip the PC for this parse 
a1e0 3a a8 e2		ld a, (os_new_parse_len) 
a1e3 4f			ld c, a 
a1e4 06 00		ld b, 0 
a1e6 ed b0		ldir		 ; copy defintion 
a1e8			 
a1e8			 
a1e8			; poke the address of where the new word bytes live for forthexec 
a1e8			 
a1e8 2a 9e e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a1eb			 
a1eb ed 5b a0 e2	ld de, (os_new_exec)      
a1ef			 
a1ef 73			ld (hl), e 
a1f0 23			inc hl 
a1f1 72			ld (hl), d 
a1f2			 
a1f2				; TODO copy last user dict word next link to this word 
a1f2				; TODO update last user dict word to point to this word 
a1f2			; 
a1f2			; hl f923 de 812a ; bc 811a 
a1f2			 
a1f2			if DEBUG_FORTH_UWORD 
a1f2 c5			push bc 
a1f3 ed 4b aa e2	ld bc, (os_new_malloc) 
a1f7					DMARK ":0A" 
a1f7 f5				push af  
a1f8 3a 0c a2			ld a, (.dmark)  
a1fb 32 62 ee			ld (debug_mark),a  
a1fe 3a 0d a2			ld a, (.dmark+1)  
a201 32 63 ee			ld (debug_mark+1),a  
a204 3a 0e a2			ld a, (.dmark+2)  
a207 32 64 ee			ld (debug_mark+2),a  
a20a 18 03			jr .pastdmark  
a20c ..			.dmark: db ":0A"  
a20f f1			.pastdmark: pop af  
a210			endm  
# End of macro DMARK
a210			CALLMONITOR 
a210 cd 6f ee			call debug_vector  
a213				endm  
# End of macro CALLMONITOR
a213 c1			pop bc 
a214			endif 
a214			if DEBUG_FORTH_UWORD 
a214 c5			push bc 
a215 ed 4b aa e2	ld bc, (os_new_malloc) 
a219 03			inc bc 
a21a 03			inc bc 
a21b 03			inc bc 
a21c 03			inc bc 
a21d 03			inc bc 
a21e 03			inc bc 
a21f 03			inc bc 
a220 03			inc bc 
a221			 
a221					DMARK ":0B" 
a221 f5				push af  
a222 3a 36 a2			ld a, (.dmark)  
a225 32 62 ee			ld (debug_mark),a  
a228 3a 37 a2			ld a, (.dmark+1)  
a22b 32 63 ee			ld (debug_mark+1),a  
a22e 3a 38 a2			ld a, (.dmark+2)  
a231 32 64 ee			ld (debug_mark+2),a  
a234 18 03			jr .pastdmark  
a236 ..			.dmark: db ":0B"  
a239 f1			.pastdmark: pop af  
a23a			endm  
# End of macro DMARK
a23a			CALLMONITOR 
a23a cd 6f ee			call debug_vector  
a23d				endm  
# End of macro CALLMONITOR
a23d c1			pop bc 
a23e			endif 
a23e			 
a23e			; update word dict linked list for new word 
a23e			 
a23e			 
a23e 2a b5 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a241 23			inc hl     ; move to next work linked list ptr 
a242			 
a242 ed 5b aa e2	ld de, (os_new_malloc)		 ; new next word 
a246 73			ld (hl), e 
a247 23			inc hl 
a248 72			ld (hl), d 
a249			 
a249			if DEBUG_FORTH_UWORD 
a249 ed 4b b5 e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a24d			endif 
a24d			 
a24d ed 53 b5 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a251			 
a251			 
a251			if DEBUG_FORTH_UWORD 
a251					DMARK ":0+" 
a251 f5				push af  
a252 3a 66 a2			ld a, (.dmark)  
a255 32 62 ee			ld (debug_mark),a  
a258 3a 67 a2			ld a, (.dmark+1)  
a25b 32 63 ee			ld (debug_mark+1),a  
a25e 3a 68 a2			ld a, (.dmark+2)  
a261 32 64 ee			ld (debug_mark+2),a  
a264 18 03			jr .pastdmark  
a266 ..			.dmark: db ":0+"  
a269 f1			.pastdmark: pop af  
a26a			endm  
# End of macro DMARK
a26a			CALLMONITOR 
a26a cd 6f ee			call debug_vector  
a26d				endm  
# End of macro CALLMONITOR
a26d			endif 
a26d			 
a26d			STACKFRAMECHK OFF $8efe $989f 
a26d				if DEBUG_STACK_IMB 
a26d					if OFF 
a26d						exx 
a26d						ld hl, $989f 
a26d						pop de   ; $989f 
a26d						call cmp16 
a26d						jr nz, .spnosame 
a26d						ld hl, $8efe 
a26d						pop de   ; $8efe 
a26d						call cmp16 
a26d						jr z, .spfrsame 
a26d						.spnosame: call showsperror 
a26d						.spfrsame: nop 
a26d						exx 
a26d					endif 
a26d				endif 
a26d			endm 
# End of macro STACKFRAMECHK
a26d			 
a26d c9			ret    ; dont process any remaining parser tokens as they form new word 
a26e			 
a26e			 
a26e			 
a26e			 
a26e			;		NEXT 
a26e			.SCOLN: 
a26e			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a26e 06			db OPCODE_SCOLN 
a26f bd a2		dw .DROP 
a271 02			db 2 
a272 .. 00		db ";",0           
a274			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a274				if DEBUG_FORTH_WORDS_KEY 
a274					DMARK "SCN" 
a274 f5				push af  
a275 3a 89 a2			ld a, (.dmark)  
a278 32 62 ee			ld (debug_mark),a  
a27b 3a 8a a2			ld a, (.dmark+1)  
a27e 32 63 ee			ld (debug_mark+1),a  
a281 3a 8b a2			ld a, (.dmark+2)  
a284 32 64 ee			ld (debug_mark+2),a  
a287 18 03			jr .pastdmark  
a289 ..			.dmark: db "SCN"  
a28c f1			.pastdmark: pop af  
a28d			endm  
# End of macro DMARK
a28d					CALLMONITOR 
a28d cd 6f ee			call debug_vector  
a290				endm  
# End of macro CALLMONITOR
a290				endif 
a290				FORTH_RSP_TOS 
a290 cd 85 99			call macro_forth_rsp_tos 
a293				endm 
# End of macro FORTH_RSP_TOS
a293 e5				push hl 
a294				FORTH_RSP_POP 
a294 cd 8f 99			call macro_forth_rsp_pop 
a297				endm 
# End of macro FORTH_RSP_POP
a297 e1				pop hl 
a298			;		ex de,hl 
a298 22 b9 e5			ld (os_tok_ptr),hl 
a29b			 
a29b			if DEBUG_FORTH_UWORD 
a29b					DMARK "SCL" 
a29b f5				push af  
a29c 3a b0 a2			ld a, (.dmark)  
a29f 32 62 ee			ld (debug_mark),a  
a2a2 3a b1 a2			ld a, (.dmark+1)  
a2a5 32 63 ee			ld (debug_mark+1),a  
a2a8 3a b2 a2			ld a, (.dmark+2)  
a2ab 32 64 ee			ld (debug_mark+2),a  
a2ae 18 03			jr .pastdmark  
a2b0 ..			.dmark: db "SCL"  
a2b3 f1			.pastdmark: pop af  
a2b4			endm  
# End of macro DMARK
a2b4			CALLMONITOR 
a2b4 cd 6f ee			call debug_vector  
a2b7				endm  
# End of macro CALLMONITOR
a2b7			endif 
a2b7				NEXTW 
a2b7 cd 6c ee			call parse_vector 
a2ba c3 aa 9d			jp macro_next 
a2bd				endm 
# End of macro NEXTW
a2bd			 
a2bd			.DROP: 
a2bd			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a2bd 1b				db WORD_SYS_CORE+OPCODE_DROP             
a2be eb a2			dw .DUP2            
a2c0 05				db 4 + 1 
a2c1 .. 00			db "DROP",0              
a2c6				endm 
# End of macro CWHEAD
a2c6			; | DROP ( w -- )   drop the TOS item   | DONE 
a2c6				if DEBUG_FORTH_WORDS_KEY 
a2c6					DMARK "DRP" 
a2c6 f5				push af  
a2c7 3a db a2			ld a, (.dmark)  
a2ca 32 62 ee			ld (debug_mark),a  
a2cd 3a dc a2			ld a, (.dmark+1)  
a2d0 32 63 ee			ld (debug_mark+1),a  
a2d3 3a dd a2			ld a, (.dmark+2)  
a2d6 32 64 ee			ld (debug_mark+2),a  
a2d9 18 03			jr .pastdmark  
a2db ..			.dmark: db "DRP"  
a2de f1			.pastdmark: pop af  
a2df			endm  
# End of macro DMARK
a2df					CALLMONITOR 
a2df cd 6f ee			call debug_vector  
a2e2				endm  
# End of macro CALLMONITOR
a2e2				endif 
a2e2				FORTH_DSP_POP 
a2e2 cd 7b 9c			call macro_forth_dsp_pop 
a2e5				endm 
# End of macro FORTH_DSP_POP
a2e5				NEXTW 
a2e5 cd 6c ee			call parse_vector 
a2e8 c3 aa 9d			jp macro_next 
a2eb				endm 
# End of macro NEXTW
a2eb			.DUP2: 
a2eb			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a2eb 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a2ec 33 a3			dw .DROP2            
a2ee 05				db 4 + 1 
a2ef .. 00			db "2DUP",0              
a2f4				endm 
# End of macro CWHEAD
a2f4			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
a2f4			; | | >[!NOTE] 
a2f4			; | | > If the duplicated items are string pointers, string are not safely duplicated and remain as pointers to the origin 
a2f4				if DEBUG_FORTH_WORDS_KEY 
a2f4					DMARK "2DU" 
a2f4 f5				push af  
a2f5 3a 09 a3			ld a, (.dmark)  
a2f8 32 62 ee			ld (debug_mark),a  
a2fb 3a 0a a3			ld a, (.dmark+1)  
a2fe 32 63 ee			ld (debug_mark+1),a  
a301 3a 0b a3			ld a, (.dmark+2)  
a304 32 64 ee			ld (debug_mark+2),a  
a307 18 03			jr .pastdmark  
a309 ..			.dmark: db "2DU"  
a30c f1			.pastdmark: pop af  
a30d			endm  
# End of macro DMARK
a30d					CALLMONITOR 
a30d cd 6f ee			call debug_vector  
a310				endm  
# End of macro CALLMONITOR
a310				endif 
a310				FORTH_DSP_VALUEHL 
a310 cd c3 9b			call macro_dsp_valuehl 
a313				endm 
# End of macro FORTH_DSP_VALUEHL
a313 e5				push hl      ; 2 
a314			 
a314				FORTH_DSP_POP 
a314 cd 7b 9c			call macro_forth_dsp_pop 
a317				endm 
# End of macro FORTH_DSP_POP
a317				 
a317				FORTH_DSP_VALUEHL 
a317 cd c3 9b			call macro_dsp_valuehl 
a31a				endm 
# End of macro FORTH_DSP_VALUEHL
a31a			;		push hl      ; 1 
a31a			 
a31a				FORTH_DSP_POP 
a31a cd 7b 9c			call macro_forth_dsp_pop 
a31d				endm 
# End of macro FORTH_DSP_POP
a31d			 
a31d			;		pop hl       ; 1 
a31d d1				pop de       ; 2 
a31e			 
a31e cd c7 99			call forth_push_numhl 
a321 eb				ex de, hl 
a322 cd c7 99			call forth_push_numhl 
a325			 
a325				 
a325 eb				ex de, hl 
a326			 
a326 cd c7 99			call forth_push_numhl 
a329 eb				ex de, hl 
a32a cd c7 99			call forth_push_numhl 
a32d			 
a32d			 
a32d				NEXTW 
a32d cd 6c ee			call parse_vector 
a330 c3 aa 9d			jp macro_next 
a333				endm 
# End of macro NEXTW
a333			.DROP2: 
a333			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a333 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a334 65 a3			dw .PICK            
a336 06				db 5 + 1 
a337 .. 00			db "2DROP",0              
a33d				endm 
# End of macro CWHEAD
a33d			; | 2DROP ( w w -- )    Double drop | DONE 
a33d				if DEBUG_FORTH_WORDS_KEY 
a33d					DMARK "2DR" 
a33d f5				push af  
a33e 3a 52 a3			ld a, (.dmark)  
a341 32 62 ee			ld (debug_mark),a  
a344 3a 53 a3			ld a, (.dmark+1)  
a347 32 63 ee			ld (debug_mark+1),a  
a34a 3a 54 a3			ld a, (.dmark+2)  
a34d 32 64 ee			ld (debug_mark+2),a  
a350 18 03			jr .pastdmark  
a352 ..			.dmark: db "2DR"  
a355 f1			.pastdmark: pop af  
a356			endm  
# End of macro DMARK
a356					CALLMONITOR 
a356 cd 6f ee			call debug_vector  
a359				endm  
# End of macro CALLMONITOR
a359				endif 
a359				FORTH_DSP_POP 
a359 cd 7b 9c			call macro_forth_dsp_pop 
a35c				endm 
# End of macro FORTH_DSP_POP
a35c				FORTH_DSP_POP 
a35c cd 7b 9c			call macro_forth_dsp_pop 
a35f				endm 
# End of macro FORTH_DSP_POP
a35f				NEXTW 
a35f cd 6c ee			call parse_vector 
a362 c3 aa 9d			jp macro_next 
a365				endm 
# End of macro NEXTW
a365			.PICK: 
a365			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
a365 77				db WORD_SYS_CORE+99             
a366 02 a4			dw .SWAP2            
a368 05				db 4 + 1 
a369 .. 00			db "PICK",0              
a36e				endm 
# End of macro CWHEAD
a36e			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
a36e			; | | >[!NOTE] 
a36e			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
a36e				if DEBUG_FORTH_WORDS_KEY 
a36e					DMARK "PIK" 
a36e f5				push af  
a36f 3a 83 a3			ld a, (.dmark)  
a372 32 62 ee			ld (debug_mark),a  
a375 3a 84 a3			ld a, (.dmark+1)  
a378 32 63 ee			ld (debug_mark+1),a  
a37b 3a 85 a3			ld a, (.dmark+2)  
a37e 32 64 ee			ld (debug_mark+2),a  
a381 18 03			jr .pastdmark  
a383 ..			.dmark: db "PIK"  
a386 f1			.pastdmark: pop af  
a387			endm  
# End of macro DMARK
a387					CALLMONITOR 
a387 cd 6f ee			call debug_vector  
a38a				endm  
# End of macro CALLMONITOR
a38a				endif 
a38a			 
a38a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a38a cd c3 9b			call macro_dsp_valuehl 
a38d				endm 
# End of macro FORTH_DSP_VALUEHL
a38d				 
a38d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a38d cd 7b 9c			call macro_forth_dsp_pop 
a390				endm 
# End of macro FORTH_DSP_POP
a390			 
a390				; init from TOS 
a390 e5				push hl 
a391				FORTH_DSP 
a391 cd 89 9b			call macro_forth_dsp 
a394				endm 
# End of macro FORTH_DSP
a394			;	ld hl, cli_data_sp 
a394				if DEBUG_FORTH_WORDS 
a394					DMARK "PK1" 
a394 f5				push af  
a395 3a a9 a3			ld a, (.dmark)  
a398 32 62 ee			ld (debug_mark),a  
a39b 3a aa a3			ld a, (.dmark+1)  
a39e 32 63 ee			ld (debug_mark+1),a  
a3a1 3a ab a3			ld a, (.dmark+2)  
a3a4 32 64 ee			ld (debug_mark+2),a  
a3a7 18 03			jr .pastdmark  
a3a9 ..			.dmark: db "PK1"  
a3ac f1			.pastdmark: pop af  
a3ad			endm  
# End of macro DMARK
a3ad					CALLMONITOR 
a3ad cd 6f ee			call debug_vector  
a3b0				endm  
# End of macro CALLMONITOR
a3b0				endif 
a3b0 c1				pop bc 
a3b1 41				ld b,c 
a3b2 3e 00			ld a, 0 
a3b4 b8				cp b 
a3b5 28 21			jr z, .pdone	 
a3b7			.pkl: 
a3b7 2b				dec hl 
a3b8 2b				dec hl 
a3b9 2b				dec hl 
a3ba			 
a3ba				if DEBUG_FORTH_WORDS 
a3ba					DMARK "PKl" 
a3ba f5				push af  
a3bb 3a cf a3			ld a, (.dmark)  
a3be 32 62 ee			ld (debug_mark),a  
a3c1 3a d0 a3			ld a, (.dmark+1)  
a3c4 32 63 ee			ld (debug_mark+1),a  
a3c7 3a d1 a3			ld a, (.dmark+2)  
a3ca 32 64 ee			ld (debug_mark+2),a  
a3cd 18 03			jr .pastdmark  
a3cf ..			.dmark: db "PKl"  
a3d2 f1			.pastdmark: pop af  
a3d3			endm  
# End of macro DMARK
a3d3					CALLMONITOR 
a3d3 cd 6f ee			call debug_vector  
a3d6				endm  
# End of macro CALLMONITOR
a3d6				endif 
a3d6 10 df			djnz .pkl 
a3d8			.pdone: 
a3d8				 
a3d8				; TODO do type check with correct push 
a3d8			 
a3d8 23				inc hl 
a3d9				;call loadwordinhl 
a3d9 5e				ld e, (hl) 
a3da 23				inc hl 
a3db 56				ld d, (hl) 
a3dc eb				ex de,hl 
a3dd				if DEBUG_FORTH_WORDS 
a3dd					DMARK "PKp" 
a3dd f5				push af  
a3de 3a f2 a3			ld a, (.dmark)  
a3e1 32 62 ee			ld (debug_mark),a  
a3e4 3a f3 a3			ld a, (.dmark+1)  
a3e7 32 63 ee			ld (debug_mark+1),a  
a3ea 3a f4 a3			ld a, (.dmark+2)  
a3ed 32 64 ee			ld (debug_mark+2),a  
a3f0 18 03			jr .pastdmark  
a3f2 ..			.dmark: db "PKp"  
a3f5 f1			.pastdmark: pop af  
a3f6			endm  
# End of macro DMARK
a3f6					CALLMONITOR 
a3f6 cd 6f ee			call debug_vector  
a3f9				endm  
# End of macro CALLMONITOR
a3f9				endif 
a3f9 cd c7 99			call forth_push_numhl 
a3fc			 
a3fc				NEXTW 
a3fc cd 6c ee			call parse_vector 
a3ff c3 aa 9d			jp macro_next 
a402				endm 
# End of macro NEXTW
a402			.SWAP2: 
a402			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a402 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a403 86 a4			dw .AT            
a405 06				db 5 + 1 
a406 .. 00			db "2SWAP",0              
a40c				endm 
# End of macro CWHEAD
a40c			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | DONE 
a40c				if DEBUG_FORTH_WORDS_KEY 
a40c					DMARK "2SW" 
a40c f5				push af  
a40d 3a 21 a4			ld a, (.dmark)  
a410 32 62 ee			ld (debug_mark),a  
a413 3a 22 a4			ld a, (.dmark+1)  
a416 32 63 ee			ld (debug_mark+1),a  
a419 3a 23 a4			ld a, (.dmark+2)  
a41c 32 64 ee			ld (debug_mark+2),a  
a41f 18 03			jr .pastdmark  
a421 ..			.dmark: db "2SW"  
a424 f1			.pastdmark: pop af  
a425			endm  
# End of macro DMARK
a425					CALLMONITOR 
a425 cd 6f ee			call debug_vector  
a428				endm  
# End of macro CALLMONITOR
a428				endif 
a428			; TODO Use os stack swap memory 
a428			 
a428				FORTH_DSP_PTR 0     ; TOS    w4 
a428 2a e5 e9			ld hl,(cli_data_sp) 
a42b 11 00 00			ld de, 0 * 3 
a42e ed 52			sbc hl, de 
a430				endm 
# End of macro FORTH_DSP_PTR
a430 cd fa 9c			call hltostack1 
a433			  
a433				FORTH_DSP_PTR 1     ; TOS    w3 
a433 2a e5 e9			ld hl,(cli_data_sp) 
a436 11 03 00			ld de, 1 * 3 
a439 ed 52			sbc hl, de 
a43b				endm 
# End of macro FORTH_DSP_PTR
a43b cd 00 9d			call hltostack2 
a43e			 
a43e			 
a43e			 
a43e				FORTH_DSP_PTR 2     ; TOS    w2 
a43e 2a e5 e9			ld hl,(cli_data_sp) 
a441 11 06 00			ld de, 2 * 3 
a444 ed 52			sbc hl, de 
a446				endm 
# End of macro FORTH_DSP_PTR
a446 cd 06 9d			call hltostack3 
a449			 
a449				FORTH_DSP_PTR 3     ; TOS   w1 
a449 2a e5 e9			ld hl,(cli_data_sp) 
a44c 11 09 00			ld de, 3 * 3 
a44f ed 52			sbc hl, de 
a451				endm 
# End of macro FORTH_DSP_PTR
a451 cd 0c 9d			call hltostack4 
a454			 
a454			 
a454			 
a454			 
a454				FORTH_DSP_PTR 0     ; TOS 
a454 2a e5 e9			ld hl,(cli_data_sp) 
a457 11 00 00			ld de, 0 * 3 
a45a ed 52			sbc hl, de 
a45c				endm 
# End of macro FORTH_DSP_PTR
a45c cd 1e 9d			call hlfromstack3 
a45f			 
a45f				FORTH_DSP_PTR 1     ; TOS 
a45f 2a e5 e9			ld hl,(cli_data_sp) 
a462 11 03 00			ld de, 1 * 3 
a465 ed 52			sbc hl, de 
a467				endm 
# End of macro FORTH_DSP_PTR
a467 cd 24 9d			call hlfromstack4 
a46a			 
a46a			 
a46a			 
a46a				FORTH_DSP_PTR 2     ; TOS 
a46a 2a e5 e9			ld hl,(cli_data_sp) 
a46d 11 06 00			ld de, 2 * 3 
a470 ed 52			sbc hl, de 
a472				endm 
# End of macro FORTH_DSP_PTR
a472 cd 12 9d			call hlfromstack1 
a475			 
a475				FORTH_DSP_PTR 3     ; TOS 
a475 2a e5 e9			ld hl,(cli_data_sp) 
a478 11 09 00			ld de, 3 * 3 
a47b ed 52			sbc hl, de 
a47d				endm 
# End of macro FORTH_DSP_PTR
a47d cd 18 9d			call hlfromstack2 
a480			 
a480				NEXTW 
a480 cd 6c ee			call parse_vector 
a483 c3 aa 9d			jp macro_next 
a486				endm 
# End of macro NEXTW
a486			.AT: 
a486			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a486 1f				db WORD_SYS_CORE+OPCODE_AT             
a487 bb a4			dw .CAT            
a489 02				db 1 + 1 
a48a .. 00			db "@",0              
a48c				endm 
# End of macro CWHEAD
a48c			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a48c			 
a48c				if DEBUG_FORTH_WORDS_KEY 
a48c					DMARK "AT." 
a48c f5				push af  
a48d 3a a1 a4			ld a, (.dmark)  
a490 32 62 ee			ld (debug_mark),a  
a493 3a a2 a4			ld a, (.dmark+1)  
a496 32 63 ee			ld (debug_mark+1),a  
a499 3a a3 a4			ld a, (.dmark+2)  
a49c 32 64 ee			ld (debug_mark+2),a  
a49f 18 03			jr .pastdmark  
a4a1 ..			.dmark: db "AT."  
a4a4 f1			.pastdmark: pop af  
a4a5			endm  
# End of macro DMARK
a4a5					CALLMONITOR 
a4a5 cd 6f ee			call debug_vector  
a4a8				endm  
# End of macro CALLMONITOR
a4a8				endif 
a4a8			.getbyteat:	 
a4a8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4a8 cd c3 9b			call macro_dsp_valuehl 
a4ab				endm 
# End of macro FORTH_DSP_VALUEHL
a4ab				 
a4ab			;		push hl 
a4ab			 
a4ab				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4ab cd 7b 9c			call macro_forth_dsp_pop 
a4ae				endm 
# End of macro FORTH_DSP_POP
a4ae			 
a4ae			;		pop hl 
a4ae			 
a4ae 7e				ld a, (hl) 
a4af			 
a4af 6f				ld l, a 
a4b0 26 00			ld h, 0 
a4b2 cd c7 99			call forth_push_numhl 
a4b5			 
a4b5				NEXTW 
a4b5 cd 6c ee			call parse_vector 
a4b8 c3 aa 9d			jp macro_next 
a4bb				endm 
# End of macro NEXTW
a4bb			.CAT: 
a4bb			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a4bb 20				db WORD_SYS_CORE+OPCODE_CAT             
a4bc e7 a4			dw .BANG            
a4be 03				db 2 + 1 
a4bf .. 00			db "C@",0              
a4c2				endm 
# End of macro CWHEAD
a4c2			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a4c2				if DEBUG_FORTH_WORDS_KEY 
a4c2					DMARK "CAA" 
a4c2 f5				push af  
a4c3 3a d7 a4			ld a, (.dmark)  
a4c6 32 62 ee			ld (debug_mark),a  
a4c9 3a d8 a4			ld a, (.dmark+1)  
a4cc 32 63 ee			ld (debug_mark+1),a  
a4cf 3a d9 a4			ld a, (.dmark+2)  
a4d2 32 64 ee			ld (debug_mark+2),a  
a4d5 18 03			jr .pastdmark  
a4d7 ..			.dmark: db "CAA"  
a4da f1			.pastdmark: pop af  
a4db			endm  
# End of macro DMARK
a4db					CALLMONITOR 
a4db cd 6f ee			call debug_vector  
a4de				endm  
# End of macro CALLMONITOR
a4de				endif 
a4de c3 a8 a4			jp .getbyteat 
a4e1				NEXTW 
a4e1 cd 6c ee			call parse_vector 
a4e4 c3 aa 9d			jp macro_next 
a4e7				endm 
# End of macro NEXTW
a4e7			.BANG: 
a4e7			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a4e7 21				db WORD_SYS_CORE+OPCODE_BANG             
a4e8 20 a5			dw .CBANG            
a4ea 02				db 1 + 1 
a4eb .. 00			db "!",0              
a4ed				endm 
# End of macro CWHEAD
a4ed			; | ! ( x w -- ) Store x at address w      | DONE 
a4ed				if DEBUG_FORTH_WORDS_KEY 
a4ed					DMARK "BNG" 
a4ed f5				push af  
a4ee 3a 02 a5			ld a, (.dmark)  
a4f1 32 62 ee			ld (debug_mark),a  
a4f4 3a 03 a5			ld a, (.dmark+1)  
a4f7 32 63 ee			ld (debug_mark+1),a  
a4fa 3a 04 a5			ld a, (.dmark+2)  
a4fd 32 64 ee			ld (debug_mark+2),a  
a500 18 03			jr .pastdmark  
a502 ..			.dmark: db "BNG"  
a505 f1			.pastdmark: pop af  
a506			endm  
# End of macro DMARK
a506					CALLMONITOR 
a506 cd 6f ee			call debug_vector  
a509				endm  
# End of macro CALLMONITOR
a509				endif 
a509			 
a509			.storebyteat:		 
a509				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a509 cd c3 9b			call macro_dsp_valuehl 
a50c				endm 
# End of macro FORTH_DSP_VALUEHL
a50c				 
a50c e5				push hl 
a50d			 
a50d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a50d cd 7b 9c			call macro_forth_dsp_pop 
a510				endm 
# End of macro FORTH_DSP_POP
a510			 
a510				; get byte to poke 
a510			 
a510				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a510 cd c3 9b			call macro_dsp_valuehl 
a513				endm 
# End of macro FORTH_DSP_VALUEHL
a513 e5				push hl 
a514			 
a514			 
a514				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a514 cd 7b 9c			call macro_forth_dsp_pop 
a517				endm 
# End of macro FORTH_DSP_POP
a517			 
a517			 
a517 d1				pop de 
a518 e1				pop hl 
a519			 
a519 73				ld (hl),e 
a51a			 
a51a			 
a51a				NEXTW 
a51a cd 6c ee			call parse_vector 
a51d c3 aa 9d			jp macro_next 
a520				endm 
# End of macro NEXTW
a520			.CBANG: 
a520			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a520 22				db WORD_SYS_CORE+OPCODE_CBANG             
a521 4c a5			dw .SCALL            
a523 03				db 2 + 1 
a524 .. 00			db "C!",0              
a527				endm 
# End of macro CWHEAD
a527			; | C!  ( x w -- ) Store x at address w  | DONE 
a527				if DEBUG_FORTH_WORDS_KEY 
a527					DMARK "CBA" 
a527 f5				push af  
a528 3a 3c a5			ld a, (.dmark)  
a52b 32 62 ee			ld (debug_mark),a  
a52e 3a 3d a5			ld a, (.dmark+1)  
a531 32 63 ee			ld (debug_mark+1),a  
a534 3a 3e a5			ld a, (.dmark+2)  
a537 32 64 ee			ld (debug_mark+2),a  
a53a 18 03			jr .pastdmark  
a53c ..			.dmark: db "CBA"  
a53f f1			.pastdmark: pop af  
a540			endm  
# End of macro DMARK
a540					CALLMONITOR 
a540 cd 6f ee			call debug_vector  
a543				endm  
# End of macro CALLMONITOR
a543				endif 
a543 c3 09 a5			jp .storebyteat 
a546				NEXTW 
a546 cd 6c ee			call parse_vector 
a549 c3 aa 9d			jp macro_next 
a54c				endm 
# End of macro NEXTW
a54c			.SCALL: 
a54c			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a54c 23				db WORD_SYS_CORE+OPCODE_SCALL             
a54d 83 a5			dw .DEPTH            
a54f 05				db 4 + 1 
a550 .. 00			db "CALL",0              
a555				endm 
# End of macro CWHEAD
a555			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a555				if DEBUG_FORTH_WORDS_KEY 
a555					DMARK "CLL" 
a555 f5				push af  
a556 3a 6a a5			ld a, (.dmark)  
a559 32 62 ee			ld (debug_mark),a  
a55c 3a 6b a5			ld a, (.dmark+1)  
a55f 32 63 ee			ld (debug_mark+1),a  
a562 3a 6c a5			ld a, (.dmark+2)  
a565 32 64 ee			ld (debug_mark+2),a  
a568 18 03			jr .pastdmark  
a56a ..			.dmark: db "CLL"  
a56d f1			.pastdmark: pop af  
a56e			endm  
# End of macro DMARK
a56e					CALLMONITOR 
a56e cd 6f ee			call debug_vector  
a571				endm  
# End of macro CALLMONITOR
a571				endif 
a571			 
a571				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a571 cd c3 9b			call macro_dsp_valuehl 
a574				endm 
# End of macro FORTH_DSP_VALUEHL
a574			 
a574			;		push hl 
a574			 
a574				; destroy value TOS 
a574			 
a574				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a574 cd 7b 9c			call macro_forth_dsp_pop 
a577				endm 
# End of macro FORTH_DSP_POP
a577			 
a577					 
a577			;		pop hl 
a577			 
a577				; how to do a call with hl???? save SP? 
a577 cd 4e 9d			call forth_call_hl 
a57a			 
a57a			 
a57a				; TODO push value back onto stack for another op etc 
a57a			 
a57a cd c7 99			call forth_push_numhl 
a57d				NEXTW 
a57d cd 6c ee			call parse_vector 
a580 c3 aa 9d			jp macro_next 
a583				endm 
# End of macro NEXTW
a583			.DEPTH: 
a583			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a583 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a584 c3 a5			dw .OVER            
a586 06				db 5 + 1 
a587 .. 00			db "DEPTH",0              
a58d				endm 
# End of macro CWHEAD
a58d			; | DEPTH ( -- u ) Push count of stack | DONE 
a58d				; take current TOS and remove from base value div by two to get count 
a58d				if DEBUG_FORTH_WORDS_KEY 
a58d					DMARK "DEP" 
a58d f5				push af  
a58e 3a a2 a5			ld a, (.dmark)  
a591 32 62 ee			ld (debug_mark),a  
a594 3a a3 a5			ld a, (.dmark+1)  
a597 32 63 ee			ld (debug_mark+1),a  
a59a 3a a4 a5			ld a, (.dmark+2)  
a59d 32 64 ee			ld (debug_mark+2),a  
a5a0 18 03			jr .pastdmark  
a5a2 ..			.dmark: db "DEP"  
a5a5 f1			.pastdmark: pop af  
a5a6			endm  
# End of macro DMARK
a5a6					CALLMONITOR 
a5a6 cd 6f ee			call debug_vector  
a5a9				endm  
# End of macro CALLMONITOR
a5a9				endif 
a5a9			 
a5a9			 
a5a9 2a e5 e9		ld hl, (cli_data_sp) 
a5ac 11 1f e8		ld de, cli_data_stack 
a5af ed 52		sbc hl,de 
a5b1			 
a5b1			; div by size of stack item 
a5b1			 
a5b1 5d			ld e,l 
a5b2 0e 03		ld c, 3 
a5b4 cd 66 8c		call Div8 
a5b7			 
a5b7 6f			ld l,a 
a5b8 26 00		ld h,0 
a5ba			 
a5ba			;srl h 
a5ba			;rr l 
a5ba			 
a5ba cd c7 99			call forth_push_numhl 
a5bd				NEXTW 
a5bd cd 6c ee			call parse_vector 
a5c0 c3 aa 9d			jp macro_next 
a5c3				endm 
# End of macro NEXTW
a5c3			.OVER: 
a5c3			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a5c3 42				db WORD_SYS_CORE+46             
a5c4 13 a6			dw .PAUSE            
a5c6 05				db 4 + 1 
a5c7 .. 00			db "OVER",0              
a5cc				endm 
# End of macro CWHEAD
a5cc			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a5cc			; | | >[!NOTE] 
a5cc			; | | > If the copied item is a string it is properly duplicated allowing for a safe release after use.  
a5cc				if DEBUG_FORTH_WORDS_KEY 
a5cc					DMARK "OVR" 
a5cc f5				push af  
a5cd 3a e1 a5			ld a, (.dmark)  
a5d0 32 62 ee			ld (debug_mark),a  
a5d3 3a e2 a5			ld a, (.dmark+1)  
a5d6 32 63 ee			ld (debug_mark+1),a  
a5d9 3a e3 a5			ld a, (.dmark+2)  
a5dc 32 64 ee			ld (debug_mark+2),a  
a5df 18 03			jr .pastdmark  
a5e1 ..			.dmark: db "OVR"  
a5e4 f1			.pastdmark: pop af  
a5e5			endm  
# End of macro DMARK
a5e5					CALLMONITOR 
a5e5 cd 6f ee			call debug_vector  
a5e8				endm  
# End of macro CALLMONITOR
a5e8				endif 
a5e8			 
a5e8			; TODO Use os stack swap memory 
a5e8			 
a5e8				; work out what type we are looking at 
a5e8			 
a5e8				FORTH_DSP_PTR 1 
a5e8 2a e5 e9			ld hl,(cli_data_sp) 
a5eb 11 03 00			ld de, 1 * 3 
a5ee ed 52			sbc hl, de 
a5f0				endm 
# End of macro FORTH_DSP_PTR
a5f0			 
a5f0 7e				ld a, (hl) 
a5f1				 
a5f1 f5				push af 
a5f2				; whatever the type lets get the pointer or word 
a5f2 23				inc hl 
a5f3			;; 
a5f3			 
a5f3				; type check now to decide on how to push  
a5f3			 
a5f3 cd 30 9d			call loadwordinhl 
a5f6 f1				pop af 
a5f7 fe 01			cp DS_TYPE_STR 
a5f9 28 09			jr z, .ovstr 
a5fb			 
a5fb				; we have a numeric so load the word and push 
a5fb			;	ld e, (hl) 
a5fb			;	inc hl 
a5fb			;	ld d, (hl) 
a5fb			;	ex de, hl 
a5fb cd c7 99			call forth_push_numhl 
a5fe				NEXTW 
a5fe cd 6c ee			call parse_vector 
a601 c3 aa 9d			jp macro_next 
a604				endm 
# End of macro NEXTW
a604			 
a604			.ovstr: 
a604				; ok, a string so get the pointer and push as a string 
a604			 
a604			;	call loadwordinhl 
a604 cd 31 9a			call forth_push_str 
a607				NEXTW 
a607 cd 6c ee			call parse_vector 
a60a c3 aa 9d			jp macro_next 
a60d				endm 
# End of macro NEXTW
a60d			 
a60d			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a60d			;	push hl    ; n2 
a60d			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a60d			; 
a60d			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a60d			;	push hl    ; n1 
a60d			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a60d			; 
a60d			;	pop de     ; n1 
a60d			;	pop hl     ; n2 
a60d			; 
a60d			;	push de 
a60d			;	push hl 
a60d			;	push de 
a60d			 
a60d				; push back  
a60d			 
a60d			;	pop hl 
a60d			;	call forth_push_numhl 
a60d			;	pop hl 
a60d			;	call forth_push_numhl 
a60d			;	pop hl 
a60d			;	call forth_push_numhl 
a60d				NEXTW 
a60d cd 6c ee			call parse_vector 
a610 c3 aa 9d			jp macro_next 
a613				endm 
# End of macro NEXTW
a613			 
a613			.PAUSE: 
a613			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a613 43				db WORD_SYS_CORE+47             
a614 4b a6			dw .PAUSES            
a616 08				db 7 + 1 
a617 .. 00			db "PAUSEMS",0              
a61f				endm 
# End of macro CWHEAD
a61f			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a61f				if DEBUG_FORTH_WORDS_KEY 
a61f					DMARK "PMS" 
a61f f5				push af  
a620 3a 34 a6			ld a, (.dmark)  
a623 32 62 ee			ld (debug_mark),a  
a626 3a 35 a6			ld a, (.dmark+1)  
a629 32 63 ee			ld (debug_mark+1),a  
a62c 3a 36 a6			ld a, (.dmark+2)  
a62f 32 64 ee			ld (debug_mark+2),a  
a632 18 03			jr .pastdmark  
a634 ..			.dmark: db "PMS"  
a637 f1			.pastdmark: pop af  
a638			endm  
# End of macro DMARK
a638					CALLMONITOR 
a638 cd 6f ee			call debug_vector  
a63b				endm  
# End of macro CALLMONITOR
a63b				endif 
a63b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a63b cd c3 9b			call macro_dsp_valuehl 
a63e				endm 
# End of macro FORTH_DSP_VALUEHL
a63e			;		push hl    ; n2 
a63e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a63e cd 7b 9c			call macro_forth_dsp_pop 
a641				endm 
# End of macro FORTH_DSP_POP
a641			;		pop hl 
a641			 
a641 7d				ld a, l 
a642 cd d5 89			call aDelayInMS 
a645			       NEXTW 
a645 cd 6c ee			call parse_vector 
a648 c3 aa 9d			jp macro_next 
a64b				endm 
# End of macro NEXTW
a64b			.PAUSES:  
a64b			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a64b 44				db WORD_SYS_CORE+48             
a64c bd a6			dw .ROT            
a64e 06				db 5 + 1 
a64f .. 00			db "PAUSE",0              
a655				endm 
# End of macro CWHEAD
a655			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a655				if DEBUG_FORTH_WORDS_KEY 
a655					DMARK "PAU" 
a655 f5				push af  
a656 3a 6a a6			ld a, (.dmark)  
a659 32 62 ee			ld (debug_mark),a  
a65c 3a 6b a6			ld a, (.dmark+1)  
a65f 32 63 ee			ld (debug_mark+1),a  
a662 3a 6c a6			ld a, (.dmark+2)  
a665 32 64 ee			ld (debug_mark+2),a  
a668 18 03			jr .pastdmark  
a66a ..			.dmark: db "PAU"  
a66d f1			.pastdmark: pop af  
a66e			endm  
# End of macro DMARK
a66e					CALLMONITOR 
a66e cd 6f ee			call debug_vector  
a671				endm  
# End of macro CALLMONITOR
a671				endif 
a671				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a671 cd c3 9b			call macro_dsp_valuehl 
a674				endm 
# End of macro FORTH_DSP_VALUEHL
a674			;		push hl    ; n2 
a674				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a674 cd 7b 9c			call macro_forth_dsp_pop 
a677				endm 
# End of macro FORTH_DSP_POP
a677			;		pop hl 
a677 45				ld b, l 
a678				if DEBUG_FORTH_WORDS 
a678					DMARK "PAU" 
a678 f5				push af  
a679 3a 8d a6			ld a, (.dmark)  
a67c 32 62 ee			ld (debug_mark),a  
a67f 3a 8e a6			ld a, (.dmark+1)  
a682 32 63 ee			ld (debug_mark+1),a  
a685 3a 8f a6			ld a, (.dmark+2)  
a688 32 64 ee			ld (debug_mark+2),a  
a68b 18 03			jr .pastdmark  
a68d ..			.dmark: db "PAU"  
a690 f1			.pastdmark: pop af  
a691			endm  
# End of macro DMARK
a691					CALLMONITOR 
a691 cd 6f ee			call debug_vector  
a694				endm  
# End of macro CALLMONITOR
a694				endif 
a694 c5			.pauses1:	push bc 
a695 cd f0 89			call delay1s 
a698 c1				pop bc 
a699				if DEBUG_FORTH_WORDS 
a699					DMARK "PA1" 
a699 f5				push af  
a69a 3a ae a6			ld a, (.dmark)  
a69d 32 62 ee			ld (debug_mark),a  
a6a0 3a af a6			ld a, (.dmark+1)  
a6a3 32 63 ee			ld (debug_mark+1),a  
a6a6 3a b0 a6			ld a, (.dmark+2)  
a6a9 32 64 ee			ld (debug_mark+2),a  
a6ac 18 03			jr .pastdmark  
a6ae ..			.dmark: db "PA1"  
a6b1 f1			.pastdmark: pop af  
a6b2			endm  
# End of macro DMARK
a6b2					CALLMONITOR 
a6b2 cd 6f ee			call debug_vector  
a6b5				endm  
# End of macro CALLMONITOR
a6b5				endif 
a6b5 10 dd			djnz .pauses1 
a6b7			 
a6b7			       NEXTW 
a6b7 cd 6c ee			call parse_vector 
a6ba c3 aa 9d			jp macro_next 
a6bd				endm 
# End of macro NEXTW
a6bd			.ROT: 
a6bd			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a6bd 45				db WORD_SYS_CORE+49             
a6be 29 a7			dw .UWORDS            
a6c0 04				db 3 + 1 
a6c1 .. 00			db "ROT",0              
a6c5				endm 
# End of macro CWHEAD
a6c5			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a6c5				if DEBUG_FORTH_WORDS_KEY 
a6c5					DMARK "ROT" 
a6c5 f5				push af  
a6c6 3a da a6			ld a, (.dmark)  
a6c9 32 62 ee			ld (debug_mark),a  
a6cc 3a db a6			ld a, (.dmark+1)  
a6cf 32 63 ee			ld (debug_mark+1),a  
a6d2 3a dc a6			ld a, (.dmark+2)  
a6d5 32 64 ee			ld (debug_mark+2),a  
a6d8 18 03			jr .pastdmark  
a6da ..			.dmark: db "ROT"  
a6dd f1			.pastdmark: pop af  
a6de			endm  
# End of macro DMARK
a6de					CALLMONITOR 
a6de cd 6f ee			call debug_vector  
a6e1				endm  
# End of macro CALLMONITOR
a6e1				endif 
a6e1			 
a6e1			; DONE Use os stack swap memory 
a6e1			 
a6e1				FORTH_DSP_PTR 0     ; u3 
a6e1 2a e5 e9			ld hl,(cli_data_sp) 
a6e4 11 00 00			ld de, 0 * 3 
a6e7 ed 52			sbc hl, de 
a6e9				endm 
# End of macro FORTH_DSP_PTR
a6e9 cd fa 9c			call hltostack1     
a6ec			  
a6ec				FORTH_DSP_PTR 1     ; u2 
a6ec 2a e5 e9			ld hl,(cli_data_sp) 
a6ef 11 03 00			ld de, 1 * 3 
a6f2 ed 52			sbc hl, de 
a6f4				endm 
# End of macro FORTH_DSP_PTR
a6f4 cd 00 9d			call hltostack2      
a6f7			 
a6f7				FORTH_DSP_PTR 2     ; u1 
a6f7 2a e5 e9			ld hl,(cli_data_sp) 
a6fa 11 06 00			ld de, 2 * 3 
a6fd ed 52			sbc hl, de 
a6ff				endm 
# End of macro FORTH_DSP_PTR
a6ff cd 06 9d			call hltostack3 
a702			 
a702			 
a702				FORTH_DSP_PTR 0     ;  
a702 2a e5 e9			ld hl,(cli_data_sp) 
a705 11 00 00			ld de, 0 * 3 
a708 ed 52			sbc hl, de 
a70a				endm 
# End of macro FORTH_DSP_PTR
a70a cd 1e 9d			call hlfromstack3 
a70d			 
a70d				FORTH_DSP_PTR 1     ; TOS 
a70d 2a e5 e9			ld hl,(cli_data_sp) 
a710 11 03 00			ld de, 1 * 3 
a713 ed 52			sbc hl, de 
a715				endm 
# End of macro FORTH_DSP_PTR
a715 cd 12 9d			call hlfromstack1 
a718			 
a718				FORTH_DSP_PTR 2     ; TOS 
a718 2a e5 e9			ld hl,(cli_data_sp) 
a71b 11 06 00			ld de, 2 * 3 
a71e ed 52			sbc hl, de 
a720				endm 
# End of macro FORTH_DSP_PTR
a720 cd 18 9d			call hlfromstack2 
a723			 
a723			 
a723			;	FORTH_DSP_VALUEHL 
a723			;	push hl    ; u3  
a723			; 
a723			;	FORTH_DSP_POP 
a723			; 
a723			;	FORTH_DSP_VALUEHL 
a723			;	push hl     ; u2 
a723			; 
a723			;	FORTH_DSP_POP 
a723			; 
a723			;	FORTH_DSP_VALUEHL 
a723			;	push hl     ; u1 
a723			; 
a723			;	FORTH_DSP_POP 
a723			; 
a723			;	pop bc      ; u1 
a723			;	pop hl      ; u2 
a723			;	pop de      ; u3 
a723			; 
a723			; 
a723			;	push bc 
a723			;	push de 
a723			;	push hl 
a723			; 
a723			; 
a723			;	pop hl 
a723			;	call forth_push_numhl 
a723			; 
a723			;	pop hl 
a723			;	call forth_push_numhl 
a723			; 
a723			;	pop hl 
a723			;	call forth_push_numhl 
a723				 
a723			 
a723			 
a723			 
a723			 
a723			 
a723			       NEXTW 
a723 cd 6c ee			call parse_vector 
a726 c3 aa 9d			jp macro_next 
a729				endm 
# End of macro NEXTW
a729			 
a729			.UWORDS: 
a729			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a729 50				db WORD_SYS_CORE+60             
a72a ee a7			dw .BP            
a72c 07				db 6 + 1 
a72d .. 00			db "UWORDS",0              
a734				endm 
# End of macro CWHEAD
a734			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a734			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a734			; | | Following the count are the individual words. 
a734			; | | 
a734			; | | e.g. UWORDS 
a734			; | | BOX DIRLIST 2 
a734			; | |  
a734			; | | Can be used to save the words to storage via: 
a734			; | | UWORDS $01 DO $01 APPEND LOOP 
a734			if DEBUG_FORTH_WORDS_KEY 
a734				DMARK "UWR" 
a734 f5				push af  
a735 3a 49 a7			ld a, (.dmark)  
a738 32 62 ee			ld (debug_mark),a  
a73b 3a 4a a7			ld a, (.dmark+1)  
a73e 32 63 ee			ld (debug_mark+1),a  
a741 3a 4b a7			ld a, (.dmark+2)  
a744 32 64 ee			ld (debug_mark+2),a  
a747 18 03			jr .pastdmark  
a749 ..			.dmark: db "UWR"  
a74c f1			.pastdmark: pop af  
a74d			endm  
# End of macro DMARK
a74d				CALLMONITOR 
a74d cd 6f ee			call debug_vector  
a750				endm  
# End of macro CALLMONITOR
a750			endif 
a750 21 66 e4			ld hl, baseram 
a753				;ld hl, baseusermem 
a753 01 00 00			ld bc, 0    ; start a counter 
a756			 
a756			; skip dict stub 
a756			 
a756 cd dc 9e			call forth_tok_next 
a759			 
a759			 
a759			; while we have words to look for 
a759			 
a759 7e			.douscan:	ld a, (hl)      
a75a			if DEBUG_FORTH_WORDS 
a75a				DMARK "UWs" 
a75a f5				push af  
a75b 3a 6f a7			ld a, (.dmark)  
a75e 32 62 ee			ld (debug_mark),a  
a761 3a 70 a7			ld a, (.dmark+1)  
a764 32 63 ee			ld (debug_mark+1),a  
a767 3a 71 a7			ld a, (.dmark+2)  
a76a 32 64 ee			ld (debug_mark+2),a  
a76d 18 03			jr .pastdmark  
a76f ..			.dmark: db "UWs"  
a772 f1			.pastdmark: pop af  
a773			endm  
# End of macro DMARK
a773				CALLMONITOR 
a773 cd 6f ee			call debug_vector  
a776				endm  
# End of macro CALLMONITOR
a776			endif 
a776 fe 00			cp WORD_SYS_END 
a778 28 4d			jr z, .udone 
a77a fe 01			cp WORD_SYS_UWORD 
a77c 20 44			jr nz, .nuword 
a77e			 
a77e			if DEBUG_FORTH_WORDS 
a77e				DMARK "UWu" 
a77e f5				push af  
a77f 3a 93 a7			ld a, (.dmark)  
a782 32 62 ee			ld (debug_mark),a  
a785 3a 94 a7			ld a, (.dmark+1)  
a788 32 63 ee			ld (debug_mark+1),a  
a78b 3a 95 a7			ld a, (.dmark+2)  
a78e 32 64 ee			ld (debug_mark+2),a  
a791 18 03			jr .pastdmark  
a793 ..			.dmark: db "UWu"  
a796 f1			.pastdmark: pop af  
a797			endm  
# End of macro DMARK
a797				CALLMONITOR 
a797 cd 6f ee			call debug_vector  
a79a				endm  
# End of macro CALLMONITOR
a79a			endif 
a79a				; we have a uword so push its name to the stack 
a79a			 
a79a e5				push hl  ; save so we can move to next dict block 
a79b			 
a79b				; skip opcode 
a79b 23				inc hl  
a79c				; skip next ptr 
a79c 23				inc hl  
a79d 23				inc hl 
a79e				; skip len 
a79e 23				inc hl 
a79f			if DEBUG_FORTH_WORDS 
a79f				DMARK "UWt" 
a79f f5				push af  
a7a0 3a b4 a7			ld a, (.dmark)  
a7a3 32 62 ee			ld (debug_mark),a  
a7a6 3a b5 a7			ld a, (.dmark+1)  
a7a9 32 63 ee			ld (debug_mark+1),a  
a7ac 3a b6 a7			ld a, (.dmark+2)  
a7af 32 64 ee			ld (debug_mark+2),a  
a7b2 18 03			jr .pastdmark  
a7b4 ..			.dmark: db "UWt"  
a7b7 f1			.pastdmark: pop af  
a7b8			endm  
# End of macro DMARK
a7b8				CALLMONITOR 
a7b8 cd 6f ee			call debug_vector  
a7bb				endm  
# End of macro CALLMONITOR
a7bb			endif 
a7bb 03				inc bc 
a7bc			 
a7bc c5				push bc 
a7bd cd 31 9a			call forth_push_str 
a7c0 c1				pop bc 
a7c1			 
a7c1 e1				pop hl 	 
a7c2			 
a7c2 cd dc 9e		.nuword:	call forth_tok_next 
a7c5 18 92			jr .douscan  
a7c7			 
a7c7			.udone:		 ; push count of uwords found 
a7c7 c5				push bc 
a7c8 e1				pop hl 
a7c9			 
a7c9			if DEBUG_FORTH_WORDS 
a7c9				DMARK "UWc" 
a7c9 f5				push af  
a7ca 3a de a7			ld a, (.dmark)  
a7cd 32 62 ee			ld (debug_mark),a  
a7d0 3a df a7			ld a, (.dmark+1)  
a7d3 32 63 ee			ld (debug_mark+1),a  
a7d6 3a e0 a7			ld a, (.dmark+2)  
a7d9 32 64 ee			ld (debug_mark+2),a  
a7dc 18 03			jr .pastdmark  
a7de ..			.dmark: db "UWc"  
a7e1 f1			.pastdmark: pop af  
a7e2			endm  
# End of macro DMARK
a7e2				CALLMONITOR 
a7e2 cd 6f ee			call debug_vector  
a7e5				endm  
# End of macro CALLMONITOR
a7e5			endif 
a7e5 cd c7 99			call forth_push_numhl 
a7e8			 
a7e8			 
a7e8			       NEXTW 
a7e8 cd 6c ee			call parse_vector 
a7eb c3 aa 9d			jp macro_next 
a7ee				endm 
# End of macro NEXTW
a7ee			 
a7ee			.BP: 
a7ee			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a7ee 54				db WORD_SYS_CORE+64             
a7ef 2e a8			dw .MONITOR            
a7f1 03				db 2 + 1 
a7f2 .. 00			db "BP",0              
a7f5				endm 
# End of macro CWHEAD
a7f5			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a7f5			; | | $00 Will enable the break points within specific code paths 
a7f5			; | | $01 Will disable break points 
a7f5			; | |  
a7f5			; | | By default break points are off. Either the above can be used to enable them 
a7f5			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a7f5			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a7f5			; | | can disable break points. Exiting will then continue boot process. 
a7f5				; get byte count 
a7f5				if DEBUG_FORTH_WORDS_KEY 
a7f5					DMARK "BP." 
a7f5 f5				push af  
a7f6 3a 0a a8			ld a, (.dmark)  
a7f9 32 62 ee			ld (debug_mark),a  
a7fc 3a 0b a8			ld a, (.dmark+1)  
a7ff 32 63 ee			ld (debug_mark+1),a  
a802 3a 0c a8			ld a, (.dmark+2)  
a805 32 64 ee			ld (debug_mark+2),a  
a808 18 03			jr .pastdmark  
a80a ..			.dmark: db "BP."  
a80d f1			.pastdmark: pop af  
a80e			endm  
# End of macro DMARK
a80e					CALLMONITOR 
a80e cd 6f ee			call debug_vector  
a811				endm  
# End of macro CALLMONITOR
a811				endif 
a811			 
a811				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a811 cd c3 9b			call macro_dsp_valuehl 
a814				endm 
# End of macro FORTH_DSP_VALUEHL
a814			 
a814			;		push hl 
a814			 
a814				; destroy value TOS 
a814			 
a814				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a814 cd 7b 9c			call macro_forth_dsp_pop 
a817				endm 
# End of macro FORTH_DSP_POP
a817			 
a817			;		pop hl 
a817			 
a817 3e 00			ld a,0 
a819 bd				cp l 
a81a 28 09			jr z, .bpset 
a81c			;		ld a, '*' 
a81c cd 52 93			call bp_off 
a81f				NEXTW 
a81f cd 6c ee			call parse_vector 
a822 c3 aa 9d			jp macro_next 
a825				endm 
# End of macro NEXTW
a825			 
a825			.bpset:	 
a825				;	ld (os_view_disable), a 
a825 cd 46 93			call bp_on 
a828			 
a828			 
a828				NEXTW 
a828 cd 6c ee			call parse_vector 
a82b c3 aa 9d			jp macro_next 
a82e				endm 
# End of macro NEXTW
a82e			 
a82e			 
a82e			.MONITOR: 
a82e			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a82e 55				db WORD_SYS_CORE+65             
a82f 62 a8			dw .MALLOC            
a831 08				db 7 + 1 
a832 .. 00			db "MONITOR",0              
a83a				endm 
# End of macro CWHEAD
a83a			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a83a			; | | At start the current various registers will be displayed with contents. 
a83a			; | | Top right corner will show the most recent debug marker seen. 
a83a			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a83a			; | | and the return stack pointer (RSP). 
a83a			; | | Pressing: 
a83a			; | |  
a83a			; | |    1 - Initial screen 
a83a			; | |  
a83a			; | |    2 - Display a data dump of HL 
a83a			; | |  
a83a			; | |    3 - Display a data dump of DE 
a83a			; | |  
a83a			; | |    4 - Display a data dump of BC 
a83a			; | |  
a83a			; | |    5 - Display a data dump of HL 
a83a			; | |  
a83a			; | |    6 - Display a data dump of DSP 
a83a			; | |  
a83a			; | |    7 - Display a data dump of RSP 
a83a			; | |  
a83a			; | |    8 - Display a data dump of what is at DSP 
a83a			; | |  
a83a			; | |    9 - Display a data dump of what is at RSP 
a83a			; | |  
a83a			; | |    0 - Exit monitor and continue running. This will also enable break points 
a83a			; | |  
a83a			; | |    * - Disable break points 
a83a			; | |  
a83a			; | |    # - Enter traditional monitor mode 
a83a			; | |  
a83a			; | | 
a83a			; | | Monitor Mode 
a83a			; | | ------------ 
a83a			; | | A prompt of '>' will be shown for various commands: 
a83a			; | |  
a83a			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a83a			; | |  
a83a			; | |    C - Continue display a data dump from the last set address 
a83a			; | |  
a83a			; | |    M xxxx - Set start of memory edit at address xx 
a83a			; | |  
a83a			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a83a			; | |  
a83a			; | |    G xxxx - Exec code at specific address 
a83a			; | |  
a83a			; | |    Q - Return to previous 
a83a				if DEBUG_FORTH_WORDS_KEY 
a83a					DMARK "MON" 
a83a f5				push af  
a83b 3a 4f a8			ld a, (.dmark)  
a83e 32 62 ee			ld (debug_mark),a  
a841 3a 50 a8			ld a, (.dmark+1)  
a844 32 63 ee			ld (debug_mark+1),a  
a847 3a 51 a8			ld a, (.dmark+2)  
a84a 32 64 ee			ld (debug_mark+2),a  
a84d 18 03			jr .pastdmark  
a84f ..			.dmark: db "MON"  
a852 f1			.pastdmark: pop af  
a853			endm  
# End of macro DMARK
a853					CALLMONITOR 
a853 cd 6f ee			call debug_vector  
a856				endm  
# End of macro CALLMONITOR
a856				endif 
a856			;		ld a, 0 
a856			;		ld (os_view_disable), a 
a856 cd 46 93			call bp_on 
a859			 
a859				CALLMONITOR 
a859 cd 6f ee			call debug_vector  
a85c				endm  
# End of macro CALLMONITOR
a85c			 
a85c			;	call monitor 
a85c			 
a85c				NEXTW 
a85c cd 6c ee			call parse_vector 
a85f c3 aa 9d			jp macro_next 
a862				endm 
# End of macro NEXTW
a862			 
a862			 
a862			.MALLOC: 
a862			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a862 56				db WORD_SYS_CORE+66             
a863 8b a8			dw .MALLOC2            
a865 06				db 5 + 1 
a866 .. 00			db "ALLOT",0              
a86c				endm 
# End of macro CWHEAD
a86c			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a86c				if DEBUG_FORTH_WORDS_KEY 
a86c					DMARK "ALL" 
a86c f5				push af  
a86d 3a 81 a8			ld a, (.dmark)  
a870 32 62 ee			ld (debug_mark),a  
a873 3a 82 a8			ld a, (.dmark+1)  
a876 32 63 ee			ld (debug_mark+1),a  
a879 3a 83 a8			ld a, (.dmark+2)  
a87c 32 64 ee			ld (debug_mark+2),a  
a87f 18 03			jr .pastdmark  
a881 ..			.dmark: db "ALL"  
a884 f1			.pastdmark: pop af  
a885			endm  
# End of macro DMARK
a885					CALLMONITOR 
a885 cd 6f ee			call debug_vector  
a888				endm  
# End of macro CALLMONITOR
a888				endif 
a888 c3 b2 a8			jp .mallocc 
a88b			.MALLOC2: 
a88b			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a88b 56				db WORD_SYS_CORE+66             
a88c cc a8			dw .FREE            
a88e 07				db 6 + 1 
a88f .. 00			db "MALLOC",0              
a896				endm 
# End of macro CWHEAD
a896			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a896				; get byte count 
a896				if DEBUG_FORTH_WORDS_KEY 
a896					DMARK "MAL" 
a896 f5				push af  
a897 3a ab a8			ld a, (.dmark)  
a89a 32 62 ee			ld (debug_mark),a  
a89d 3a ac a8			ld a, (.dmark+1)  
a8a0 32 63 ee			ld (debug_mark+1),a  
a8a3 3a ad a8			ld a, (.dmark+2)  
a8a6 32 64 ee			ld (debug_mark+2),a  
a8a9 18 03			jr .pastdmark  
a8ab ..			.dmark: db "MAL"  
a8ae f1			.pastdmark: pop af  
a8af			endm  
# End of macro DMARK
a8af					CALLMONITOR 
a8af cd 6f ee			call debug_vector  
a8b2				endm  
# End of macro CALLMONITOR
a8b2				endif 
a8b2			.mallocc: 
a8b2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a8b2 cd c3 9b			call macro_dsp_valuehl 
a8b5				endm 
# End of macro FORTH_DSP_VALUEHL
a8b5			 
a8b5			;		push hl 
a8b5			 
a8b5				; destroy value TOS 
a8b5			 
a8b5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a8b5 cd 7b 9c			call macro_forth_dsp_pop 
a8b8				endm 
# End of macro FORTH_DSP_POP
a8b8			 
a8b8			;		pop hl 
a8b8 cd a2 90			call malloc 
a8bb			if DEBUG_FORTH_MALLOC_GUARD 
a8bb f5				push af 
a8bc cd ff 8c			call ishlzero 
a8bf			;		ld a, l 
a8bf			;		add h 
a8bf			;		cp 0 
a8bf f1				pop af 
a8c0				 
a8c0 cc 18 d3			call z,malloc_error 
a8c3			endif 
a8c3			 
a8c3 cd c7 99			call forth_push_numhl 
a8c6				NEXTW 
a8c6 cd 6c ee			call parse_vector 
a8c9 c3 aa 9d			jp macro_next 
a8cc				endm 
# End of macro NEXTW
a8cc			 
a8cc			.FREE: 
a8cc			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
a8cc 57				db WORD_SYS_CORE+67             
a8cd 00 a9			dw .UPTR            
a8cf 05				db 4 + 1 
a8d0 .. 00			db "FREE",0              
a8d5				endm 
# End of macro CWHEAD
a8d5			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a8d5				if DEBUG_FORTH_WORDS_KEY 
a8d5					DMARK "FRE" 
a8d5 f5				push af  
a8d6 3a ea a8			ld a, (.dmark)  
a8d9 32 62 ee			ld (debug_mark),a  
a8dc 3a eb a8			ld a, (.dmark+1)  
a8df 32 63 ee			ld (debug_mark+1),a  
a8e2 3a ec a8			ld a, (.dmark+2)  
a8e5 32 64 ee			ld (debug_mark+2),a  
a8e8 18 03			jr .pastdmark  
a8ea ..			.dmark: db "FRE"  
a8ed f1			.pastdmark: pop af  
a8ee			endm  
# End of macro DMARK
a8ee					CALLMONITOR 
a8ee cd 6f ee			call debug_vector  
a8f1				endm  
# End of macro CALLMONITOR
a8f1				endif 
a8f1				; get address 
a8f1			 
a8f1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a8f1 cd c3 9b			call macro_dsp_valuehl 
a8f4				endm 
# End of macro FORTH_DSP_VALUEHL
a8f4			 
a8f4			;		push hl 
a8f4			 
a8f4				; destroy value TOS 
a8f4			 
a8f4				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a8f4 cd 7b 9c			call macro_forth_dsp_pop 
a8f7				endm 
# End of macro FORTH_DSP_POP
a8f7			 
a8f7			;		pop hl 
a8f7			if FORTH_ENABLE_MALLOCFREE 
a8f7 cd 6c 91			call free 
a8fa			endif 
a8fa				NEXTW 
a8fa cd 6c ee			call parse_vector 
a8fd c3 aa 9d			jp macro_next 
a900				endm 
# End of macro NEXTW
a900			.UPTR: 
a900			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
a900 57				db WORD_SYS_CORE+67             
a901 06 aa			dw .LIST            
a903 05				db 4 + 1 
a904 .. 00			db "UPTR",0              
a909				endm 
# End of macro CWHEAD
a909			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
a909				if DEBUG_FORTH_WORDS_KEY 
a909					DMARK "UPT" 
a909 f5				push af  
a90a 3a 1e a9			ld a, (.dmark)  
a90d 32 62 ee			ld (debug_mark),a  
a910 3a 1f a9			ld a, (.dmark+1)  
a913 32 63 ee			ld (debug_mark+1),a  
a916 3a 20 a9			ld a, (.dmark+2)  
a919 32 64 ee			ld (debug_mark+2),a  
a91c 18 03			jr .pastdmark  
a91e ..			.dmark: db "UPT"  
a921 f1			.pastdmark: pop af  
a922			endm  
# End of macro DMARK
a922					CALLMONITOR 
a922 cd 6f ee			call debug_vector  
a925				endm  
# End of macro CALLMONITOR
a925				endif 
a925				FORTH_DSP_VALUEHL 
a925 cd c3 9b			call macro_dsp_valuehl 
a928				endm 
# End of macro FORTH_DSP_VALUEHL
a928			 
a928 e5				push hl 
a929				FORTH_DSP_POP 
a929 cd 7b 9c			call macro_forth_dsp_pop 
a92c				endm 
# End of macro FORTH_DSP_POP
a92c c1				pop bc 
a92d			 
a92d			 
a92d				; Get ptr to the word we need to look up 
a92d			 
a92d			;		FORTH_DSP_VALUEHL 
a92d				;v5 FORTH_DSP_VALUE 
a92d			; TODO type check 
a92d			;		inc hl    ; Skip type check  
a92d			;		push hl 
a92d			;		ex de, hl    ; put into DE 
a92d			 
a92d			 
a92d 21 66 e4			ld hl, baseram 
a930				;ld hl, baseusermem 
a930			 
a930 e5			push hl   ; sacreifical push 
a931			 
a931			.uldouscanm: 
a931 e1			pop hl 
a932			.uldouscan: 
a932			if DEBUG_FORTH_WORDS 
a932				DMARK "LSs" 
a932 f5				push af  
a933 3a 47 a9			ld a, (.dmark)  
a936 32 62 ee			ld (debug_mark),a  
a939 3a 48 a9			ld a, (.dmark+1)  
a93c 32 63 ee			ld (debug_mark+1),a  
a93f 3a 49 a9			ld a, (.dmark+2)  
a942 32 64 ee			ld (debug_mark+2),a  
a945 18 03			jr .pastdmark  
a947 ..			.dmark: db "LSs"  
a94a f1			.pastdmark: pop af  
a94b			endm  
# End of macro DMARK
a94b				CALLMONITOR 
a94b cd 6f ee			call debug_vector  
a94e				endm  
# End of macro CALLMONITOR
a94e			endif 
a94e			; skip dict stub 
a94e cd dc 9e			call forth_tok_next 
a951			 
a951			 
a951			; while we have words to look for 
a951			 
a951 7e			ld a, (hl)      
a952			if DEBUG_FORTH_WORDS 
a952				DMARK "LSk" 
a952 f5				push af  
a953 3a 67 a9			ld a, (.dmark)  
a956 32 62 ee			ld (debug_mark),a  
a959 3a 68 a9			ld a, (.dmark+1)  
a95c 32 63 ee			ld (debug_mark+1),a  
a95f 3a 69 a9			ld a, (.dmark+2)  
a962 32 64 ee			ld (debug_mark+2),a  
a965 18 03			jr .pastdmark  
a967 ..			.dmark: db "LSk"  
a96a f1			.pastdmark: pop af  
a96b			endm  
# End of macro DMARK
a96b				CALLMONITOR 
a96b cd 6f ee			call debug_vector  
a96e				endm  
# End of macro CALLMONITOR
a96e			endif 
a96e				;cp WORD_SYS_END 
a96e				;jp z, .lunotfound 
a96e			 
a96e					; if we hit non uwords then gone too far 
a96e fe 01				cp WORD_SYS_UWORD 
a970 c2 fd a9				jp nz, .ulunotfound 
a973			 
a973				if DEBUG_FORTH_WORDS 
a973					DMARK "LSu" 
a973 f5				push af  
a974 3a 88 a9			ld a, (.dmark)  
a977 32 62 ee			ld (debug_mark),a  
a97a 3a 89 a9			ld a, (.dmark+1)  
a97d 32 63 ee			ld (debug_mark+1),a  
a980 3a 8a a9			ld a, (.dmark+2)  
a983 32 64 ee			ld (debug_mark+2),a  
a986 18 03			jr .pastdmark  
a988 ..			.dmark: db "LSu"  
a98b f1			.pastdmark: pop af  
a98c			endm  
# End of macro DMARK
a98c					CALLMONITOR 
a98c cd 6f ee			call debug_vector  
a98f				endm  
# End of macro CALLMONITOR
a98f				endif 
a98f			 
a98f					; found a uword but is it the one we want... 
a98f			 
a98f c5					push bc     ; uword to find is on bc 
a990 d1					pop de 
a991			 
a991 e5					push hl  ; to save the ptr 
a992			 
a992					; skip opcode 
a992 23					inc hl  
a993					; skip next ptr 
a993 23					inc hl  
a994 23					inc hl 
a995					; skip len 
a995 23					inc hl 
a996			 
a996				if DEBUG_FORTH_WORDS 
a996					DMARK "LSc" 
a996 f5				push af  
a997 3a ab a9			ld a, (.dmark)  
a99a 32 62 ee			ld (debug_mark),a  
a99d 3a ac a9			ld a, (.dmark+1)  
a9a0 32 63 ee			ld (debug_mark+1),a  
a9a3 3a ad a9			ld a, (.dmark+2)  
a9a6 32 64 ee			ld (debug_mark+2),a  
a9a9 18 03			jr .pastdmark  
a9ab ..			.dmark: db "LSc"  
a9ae f1			.pastdmark: pop af  
a9af			endm  
# End of macro DMARK
a9af					CALLMONITOR 
a9af cd 6f ee			call debug_vector  
a9b2				endm  
# End of macro CALLMONITOR
a9b2				endif 
a9b2			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
a9b2			; ie. If WOO is defined first and then WO. Couldnt list WO. 
a9b2			; Nope that has gone the other way. It needs to be exact not on first zero 
a9b2			;		call strcmp 
a9b2 c5					push bc 
a9b3 cd 72 90				call StrictStrCmp 
a9b6 c1					pop bc 
a9b7 c2 31 a9				jp nz, .uldouscanm 
a9ba				 
a9ba			 
a9ba			 
a9ba					; we have a uword so push its name to the stack 
a9ba			 
a9ba			;	   	push hl  ; save so we can move to next dict block 
a9ba e1			pop hl 
a9bb			 
a9bb				if DEBUG_FORTH_WORDS 
a9bb					DMARK "LSm" 
a9bb f5				push af  
a9bc 3a d0 a9			ld a, (.dmark)  
a9bf 32 62 ee			ld (debug_mark),a  
a9c2 3a d1 a9			ld a, (.dmark+1)  
a9c5 32 63 ee			ld (debug_mark+1),a  
a9c8 3a d2 a9			ld a, (.dmark+2)  
a9cb 32 64 ee			ld (debug_mark+2),a  
a9ce 18 03			jr .pastdmark  
a9d0 ..			.dmark: db "LSm"  
a9d3 f1			.pastdmark: pop af  
a9d4			endm  
# End of macro DMARK
a9d4					CALLMONITOR 
a9d4 cd 6f ee			call debug_vector  
a9d7				endm  
# End of macro CALLMONITOR
a9d7				endif 
a9d7			 
a9d7					; skip opcode 
a9d7 23					inc hl  
a9d8					; skip next ptr 
a9d8 23					inc hl  
a9d9 23					inc hl 
a9da					; skip len 
a9da 7e					ld a, (hl)   ; save length to add 
a9db				if DEBUG_FORTH_WORDS 
a9db					DMARK "LS2" 
a9db f5				push af  
a9dc 3a f0 a9			ld a, (.dmark)  
a9df 32 62 ee			ld (debug_mark),a  
a9e2 3a f1 a9			ld a, (.dmark+1)  
a9e5 32 63 ee			ld (debug_mark+1),a  
a9e8 3a f2 a9			ld a, (.dmark+2)  
a9eb 32 64 ee			ld (debug_mark+2),a  
a9ee 18 03			jr .pastdmark  
a9f0 ..			.dmark: db "LS2"  
a9f3 f1			.pastdmark: pop af  
a9f4			endm  
# End of macro DMARK
a9f4					CALLMONITOR 
a9f4 cd 6f ee			call debug_vector  
a9f7				endm  
# End of macro CALLMONITOR
a9f7				endif 
a9f7			 
a9f7				; skip zero term and other uword defs to position right at the exec code 
a9f7 06 04			ld b, 4 
a9f9 80				add a,b 
a9fa			 
a9fa cd d6 8c			call addatohl 
a9fd					; save this location 
a9fd				 
a9fd			.ulunotfound: 
a9fd cd c7 99			call forth_push_numhl 
aa00						 
aa00				NEXTW 
aa00 cd 6c ee			call parse_vector 
aa03 c3 aa 9d			jp macro_next 
aa06				endm 
# End of macro NEXTW
aa06			.LIST: 
aa06			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
aa06 5c				db WORD_SYS_CORE+72             
aa07 08 ac			dw .FORGET            
aa09 05				db 4 + 1 
aa0a .. 00			db "LIST",0              
aa0f				endm 
# End of macro CWHEAD
aa0f			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
aa0f			; | | The quoted word must be in upper case. 
aa0f			if DEBUG_FORTH_WORDS_KEY 
aa0f				DMARK "LST" 
aa0f f5				push af  
aa10 3a 24 aa			ld a, (.dmark)  
aa13 32 62 ee			ld (debug_mark),a  
aa16 3a 25 aa			ld a, (.dmark+1)  
aa19 32 63 ee			ld (debug_mark+1),a  
aa1c 3a 26 aa			ld a, (.dmark+2)  
aa1f 32 64 ee			ld (debug_mark+2),a  
aa22 18 03			jr .pastdmark  
aa24 ..			.dmark: db "LST"  
aa27 f1			.pastdmark: pop af  
aa28			endm  
# End of macro DMARK
aa28				CALLMONITOR 
aa28 cd 6f ee			call debug_vector  
aa2b				endm  
# End of macro CALLMONITOR
aa2b			endif 
aa2b			 
aa2b				FORTH_DSP_VALUEHL 
aa2b cd c3 9b			call macro_dsp_valuehl 
aa2e				endm 
# End of macro FORTH_DSP_VALUEHL
aa2e			 
aa2e e5				push hl 
aa2f				FORTH_DSP_POP 
aa2f cd 7b 9c			call macro_forth_dsp_pop 
aa32				endm 
# End of macro FORTH_DSP_POP
aa32 c1				pop bc 
aa33			 
aa33			; Start format of scratch string 
aa33			 
aa33 21 b8 e2			ld hl, scratch 
aa36			 
aa36			;	ld a, ':' 
aa36 36 3a			ld (hl),':' 
aa38 23				inc hl 
aa39			;	ld a, ' ' 
aa39 36 20			ld (hl), ' ' 
aa3b			 
aa3b				; Get ptr to the word we need to look up 
aa3b			 
aa3b			;		FORTH_DSP_VALUEHL 
aa3b				;v5 FORTH_DSP_VALUE 
aa3b			; TODO type check 
aa3b			;		inc hl    ; Skip type check  
aa3b			;		push hl 
aa3b			;		ex de, hl    ; put into DE 
aa3b			 
aa3b			 
aa3b 21 66 e4			ld hl, baseram 
aa3e				;ld hl, baseusermem 
aa3e			 
aa3e e5			push hl   ; sacreifical push 
aa3f			 
aa3f			.ldouscanm: 
aa3f e1			pop hl 
aa40			.ldouscan: 
aa40			if DEBUG_FORTH_WORDS 
aa40				DMARK "LSs" 
aa40 f5				push af  
aa41 3a 55 aa			ld a, (.dmark)  
aa44 32 62 ee			ld (debug_mark),a  
aa47 3a 56 aa			ld a, (.dmark+1)  
aa4a 32 63 ee			ld (debug_mark+1),a  
aa4d 3a 57 aa			ld a, (.dmark+2)  
aa50 32 64 ee			ld (debug_mark+2),a  
aa53 18 03			jr .pastdmark  
aa55 ..			.dmark: db "LSs"  
aa58 f1			.pastdmark: pop af  
aa59			endm  
# End of macro DMARK
aa59				CALLMONITOR 
aa59 cd 6f ee			call debug_vector  
aa5c				endm  
# End of macro CALLMONITOR
aa5c			endif 
aa5c			; skip dict stub 
aa5c cd dc 9e			call forth_tok_next 
aa5f			 
aa5f			 
aa5f			; while we have words to look for 
aa5f			 
aa5f 7e			ld a, (hl)      
aa60			if DEBUG_FORTH_WORDS 
aa60				DMARK "LSk" 
aa60 f5				push af  
aa61 3a 75 aa			ld a, (.dmark)  
aa64 32 62 ee			ld (debug_mark),a  
aa67 3a 76 aa			ld a, (.dmark+1)  
aa6a 32 63 ee			ld (debug_mark+1),a  
aa6d 3a 77 aa			ld a, (.dmark+2)  
aa70 32 64 ee			ld (debug_mark+2),a  
aa73 18 03			jr .pastdmark  
aa75 ..			.dmark: db "LSk"  
aa78 f1			.pastdmark: pop af  
aa79			endm  
# End of macro DMARK
aa79				CALLMONITOR 
aa79 cd 6f ee			call debug_vector  
aa7c				endm  
# End of macro CALLMONITOR
aa7c			endif 
aa7c				;cp WORD_SYS_END 
aa7c				;jp z, .lunotfound 
aa7c			 
aa7c					; if we hit non uwords then gone too far 
aa7c fe 01				cp WORD_SYS_UWORD 
aa7e c2 bb ab				jp nz, .lunotfound 
aa81			 
aa81				if DEBUG_FORTH_WORDS 
aa81					DMARK "LSu" 
aa81 f5				push af  
aa82 3a 96 aa			ld a, (.dmark)  
aa85 32 62 ee			ld (debug_mark),a  
aa88 3a 97 aa			ld a, (.dmark+1)  
aa8b 32 63 ee			ld (debug_mark+1),a  
aa8e 3a 98 aa			ld a, (.dmark+2)  
aa91 32 64 ee			ld (debug_mark+2),a  
aa94 18 03			jr .pastdmark  
aa96 ..			.dmark: db "LSu"  
aa99 f1			.pastdmark: pop af  
aa9a			endm  
# End of macro DMARK
aa9a					CALLMONITOR 
aa9a cd 6f ee			call debug_vector  
aa9d				endm  
# End of macro CALLMONITOR
aa9d				endif 
aa9d			 
aa9d					; found a uword but is it the one we want... 
aa9d			 
aa9d c5					push bc     ; uword to find is on bc 
aa9e d1					pop de 
aa9f			 
aa9f e5					push hl  ; to save the ptr 
aaa0			 
aaa0					; skip opcode 
aaa0 23					inc hl  
aaa1					; skip next ptr 
aaa1 23					inc hl  
aaa2 23					inc hl 
aaa3					; skip len 
aaa3 23					inc hl 
aaa4			 
aaa4				if DEBUG_FORTH_WORDS 
aaa4					DMARK "LSc" 
aaa4 f5				push af  
aaa5 3a b9 aa			ld a, (.dmark)  
aaa8 32 62 ee			ld (debug_mark),a  
aaab 3a ba aa			ld a, (.dmark+1)  
aaae 32 63 ee			ld (debug_mark+1),a  
aab1 3a bb aa			ld a, (.dmark+2)  
aab4 32 64 ee			ld (debug_mark+2),a  
aab7 18 03			jr .pastdmark  
aab9 ..			.dmark: db "LSc"  
aabc f1			.pastdmark: pop af  
aabd			endm  
# End of macro DMARK
aabd					CALLMONITOR 
aabd cd 6f ee			call debug_vector  
aac0				endm  
# End of macro CALLMONITOR
aac0				endif 
aac0			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
aac0			; ie. If WOO is defined first and then WO. Couldnt list WO. 
aac0			; Nope that has gone the other way. It needs to be exact not on first zero 
aac0			;		call strcmp 
aac0 c5					push bc 
aac1 cd 72 90				call StrictStrCmp 
aac4 c1					pop bc 
aac5 c2 3f aa				jp nz, .ldouscanm 
aac8				 
aac8			 
aac8			 
aac8					; we have a uword so push its name to the stack 
aac8			 
aac8			;	   	push hl  ; save so we can move to next dict block 
aac8 e1			pop hl 
aac9			 
aac9				if DEBUG_FORTH_WORDS 
aac9					DMARK "LSm" 
aac9 f5				push af  
aaca 3a de aa			ld a, (.dmark)  
aacd 32 62 ee			ld (debug_mark),a  
aad0 3a df aa			ld a, (.dmark+1)  
aad3 32 63 ee			ld (debug_mark+1),a  
aad6 3a e0 aa			ld a, (.dmark+2)  
aad9 32 64 ee			ld (debug_mark+2),a  
aadc 18 03			jr .pastdmark  
aade ..			.dmark: db "LSm"  
aae1 f1			.pastdmark: pop af  
aae2			endm  
# End of macro DMARK
aae2					CALLMONITOR 
aae2 cd 6f ee			call debug_vector  
aae5				endm  
# End of macro CALLMONITOR
aae5				endif 
aae5			 
aae5					; skip opcode 
aae5 23					inc hl  
aae6					; skip next ptr 
aae6 23					inc hl  
aae7 23					inc hl 
aae8					; skip len 
aae8 7e					ld a, (hl)   ; save length to add 
aae9				if DEBUG_FORTH_WORDS 
aae9					DMARK "LS2" 
aae9 f5				push af  
aaea 3a fe aa			ld a, (.dmark)  
aaed 32 62 ee			ld (debug_mark),a  
aaf0 3a ff aa			ld a, (.dmark+1)  
aaf3 32 63 ee			ld (debug_mark+1),a  
aaf6 3a 00 ab			ld a, (.dmark+2)  
aaf9 32 64 ee			ld (debug_mark+2),a  
aafc 18 03			jr .pastdmark  
aafe ..			.dmark: db "LS2"  
ab01 f1			.pastdmark: pop af  
ab02			endm  
# End of macro DMARK
ab02					CALLMONITOR 
ab02 cd 6f ee			call debug_vector  
ab05				endm  
# End of macro CALLMONITOR
ab05				endif 
ab05			 
ab05					; save this location 
ab05				 
ab05 e5					push hl 
ab06			 
ab06 23					inc hl 
ab07 11 ba e2				ld de, scratch+2 
ab0a 4f					ld c, a 
ab0b 06 00				ld b, 0 
ab0d			 
ab0d				if DEBUG_FORTH_WORDS 
ab0d					DMARK "LSn" 
ab0d f5				push af  
ab0e 3a 22 ab			ld a, (.dmark)  
ab11 32 62 ee			ld (debug_mark),a  
ab14 3a 23 ab			ld a, (.dmark+1)  
ab17 32 63 ee			ld (debug_mark+1),a  
ab1a 3a 24 ab			ld a, (.dmark+2)  
ab1d 32 64 ee			ld (debug_mark+2),a  
ab20 18 03			jr .pastdmark  
ab22 ..			.dmark: db "LSn"  
ab25 f1			.pastdmark: pop af  
ab26			endm  
# End of macro DMARK
ab26					CALLMONITOR 
ab26 cd 6f ee			call debug_vector  
ab29				endm  
# End of macro CALLMONITOR
ab29				endif 
ab29			 
ab29					; copy uword name to scratch 
ab29			 
ab29			;		ldir 
ab29			.licplw:	; copy uword name to scratch converting to lower case as we go 
ab29 ed a0				ldi 
ab2b 1b					dec de 
ab2c 1a					ld a, (de) 
ab2d cd 47 8f				call to_lower 
ab30 12					ld (de),a 
ab31 13					inc de 
ab32 3e 00				ld a, 0 
ab34 b9					cp c 
ab35 20 f2				jr nz, .licplw 
ab37			 
ab37			 
ab37			 
ab37 1b					dec de 
ab38 3e 20				ld a, ' '    ; change null to space 
ab3a 12					ld (de), a 
ab3b			 
ab3b 13					inc de 
ab3c			 
ab3c d5					push de 
ab3d c1					pop bc     ; move scratch pointer to end of word name and save it 
ab3e			 
ab3e e1					pop hl 
ab3f 7e					ld a, (hl) 
ab40					;inc hl 
ab40					; skip word string 
ab40 cd d6 8c				call addatohl 
ab43			 
ab43 23					inc hl 
ab44			 
ab44				if DEBUG_FORTH_WORDS 
ab44					DMARK "LS3" 
ab44 f5				push af  
ab45 3a 59 ab			ld a, (.dmark)  
ab48 32 62 ee			ld (debug_mark),a  
ab4b 3a 5a ab			ld a, (.dmark+1)  
ab4e 32 63 ee			ld (debug_mark+1),a  
ab51 3a 5b ab			ld a, (.dmark+2)  
ab54 32 64 ee			ld (debug_mark+2),a  
ab57 18 03			jr .pastdmark  
ab59 ..			.dmark: db "LS3"  
ab5c f1			.pastdmark: pop af  
ab5d			endm  
# End of macro DMARK
ab5d					CALLMONITOR 
ab5d cd 6f ee			call debug_vector  
ab60				endm  
# End of macro CALLMONITOR
ab60				endif 
ab60					; should now be at the start of the machine code to setup the eval of the uword 
ab60					; now locate the ptr to the string defintion 
ab60			 
ab60					; skip ld hl, 
ab60					; then load the ptr 
ab60			; TODO use get from hl ptr 
ab60 23					inc hl 
ab61 5e					ld e, (hl) 
ab62 23					inc hl 
ab63 56					ld d, (hl) 
ab64 eb					ex de, hl 
ab65			 
ab65			 
ab65				if DEBUG_FORTH_WORDS 
ab65					DMARK "LSt" 
ab65 f5				push af  
ab66 3a 7a ab			ld a, (.dmark)  
ab69 32 62 ee			ld (debug_mark),a  
ab6c 3a 7b ab			ld a, (.dmark+1)  
ab6f 32 63 ee			ld (debug_mark+1),a  
ab72 3a 7c ab			ld a, (.dmark+2)  
ab75 32 64 ee			ld (debug_mark+2),a  
ab78 18 03			jr .pastdmark  
ab7a ..			.dmark: db "LSt"  
ab7d f1			.pastdmark: pop af  
ab7e			endm  
# End of macro DMARK
ab7e					CALLMONITOR 
ab7e cd 6f ee			call debug_vector  
ab81				endm  
# End of macro CALLMONITOR
ab81				endif 
ab81			 
ab81			; cant push right now due to tokenised strings  
ab81			 
ab81			; get the destination of where to copy this definition to. 
ab81			 
ab81 c5					push bc 
ab82 d1					pop de 
ab83			 
ab83 7e			.listl:         ld a,(hl) 
ab84			;		cp 0 
ab84 b7					or a 
ab85 28 09				jr z, .lreplsp     ; replace zero with space 
ab87					;cp FORTH_END_BUFFER 
ab87 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
ab89 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
ab8b				 
ab8b					; just copy this char as is then 
ab8b			 
ab8b 12					ld (de), a 
ab8c			 
ab8c 23			.listnxt:	inc hl 
ab8d 13					inc de 
ab8e 18 f3				jr .listl 
ab90			 
ab90 3e 20		.lreplsp:	ld a,' ' 
ab92 12					ld (de), a 
ab93 18 f7				jr .listnxt 
ab95			 
ab95			; close up uword def 
ab95			 
ab95			.listdone: 
ab95 12					ld (de), a 
ab96 13					inc de 
ab97 3e 00				ld a, 0 
ab99 12					ld (de), a 
ab9a			 
ab9a			; now have def so clean up and push to stack 
ab9a			 
ab9a 21 b8 e2				ld hl, scratch 
ab9d				if DEBUG_FORTH_WORDS 
ab9d					DMARK "Ltp" 
ab9d f5				push af  
ab9e 3a b2 ab			ld a, (.dmark)  
aba1 32 62 ee			ld (debug_mark),a  
aba4 3a b3 ab			ld a, (.dmark+1)  
aba7 32 63 ee			ld (debug_mark+1),a  
abaa 3a b4 ab			ld a, (.dmark+2)  
abad 32 64 ee			ld (debug_mark+2),a  
abb0 18 03			jr .pastdmark  
abb2 ..			.dmark: db "Ltp"  
abb5 f1			.pastdmark: pop af  
abb6			endm  
# End of macro DMARK
abb6					CALLMONITOR 
abb6 cd 6f ee			call debug_vector  
abb9				endm  
# End of macro CALLMONITOR
abb9				endif 
abb9			 
abb9 18 22			jr .listpush 
abbb			 
abbb			;.lnuword:	pop hl 
abbb			;		call forth_tok_next 
abbb			;		jp .ldouscan  
abbb			 
abbb			.lunotfound:		  
abbb			 
abbb				if DEBUG_FORTH_WORDS 
abbb					DMARK "LSn" 
abbb f5				push af  
abbc 3a d0 ab			ld a, (.dmark)  
abbf 32 62 ee			ld (debug_mark),a  
abc2 3a d1 ab			ld a, (.dmark+1)  
abc5 32 63 ee			ld (debug_mark+1),a  
abc8 3a d2 ab			ld a, (.dmark+2)  
abcb 32 64 ee			ld (debug_mark+2),a  
abce 18 03			jr .pastdmark  
abd0 ..			.dmark: db "LSn"  
abd3 f1			.pastdmark: pop af  
abd4			endm  
# End of macro DMARK
abd4					CALLMONITOR 
abd4 cd 6f ee			call debug_vector  
abd7				endm  
# End of macro CALLMONITOR
abd7				endif 
abd7			 
abd7					 
abd7			;		FORTH_DSP_POP 
abd7			;		ld hl, .luno 
abd7			 
abd7					NEXTW			 
abd7 cd 6c ee			call parse_vector 
abda c3 aa 9d			jp macro_next 
abdd				endm 
# End of macro NEXTW
abdd			 
abdd			.listpush: 
abdd				if DEBUG_FORTH_WORDS 
abdd					DMARK "LS>" 
abdd f5				push af  
abde 3a f2 ab			ld a, (.dmark)  
abe1 32 62 ee			ld (debug_mark),a  
abe4 3a f3 ab			ld a, (.dmark+1)  
abe7 32 63 ee			ld (debug_mark+1),a  
abea 3a f4 ab			ld a, (.dmark+2)  
abed 32 64 ee			ld (debug_mark+2),a  
abf0 18 03			jr .pastdmark  
abf2 ..			.dmark: db "LS>"  
abf5 f1			.pastdmark: pop af  
abf6			endm  
# End of macro DMARK
abf6					CALLMONITOR 
abf6 cd 6f ee			call debug_vector  
abf9				endm  
# End of macro CALLMONITOR
abf9				endif 
abf9 cd 31 9a				call forth_push_str 
abfc			 
abfc			 
abfc			 
abfc					NEXTW 
abfc cd 6c ee			call parse_vector 
abff c3 aa 9d			jp macro_next 
ac02				endm 
# End of macro NEXTW
ac02			 
ac02			;.luno:    db "Word not found",0 
ac02			 
ac02			 
ac02			 
ac02			 
ac02			 
ac02			;		push hl   ; save pointer to start of uword def string 
ac02			; 
ac02			;; look for FORTH_EOL_LINE 
ac02			;		ld a, FORTH_END_BUFFER 
ac02			;		call strlent 
ac02			; 
ac02			;		inc hl		 ; space for coln def 
ac02			;		inc hl 
ac02			;		inc hl          ; space for terms 
ac02			;		inc hl 
ac02			; 
ac02			;		ld a, 20   ; TODO get actual length 
ac02			;		call addatohl    ; include a random amount of room for the uword name 
ac02			; 
ac02			;		 
ac02			;	if DEBUG_FORTH_WORDS 
ac02			;		DMARK "Lt1" 
ac02			;		CALLMONITOR 
ac02			;	endif 
ac02			;		 
ac02			; 
ac02			;; malloc space for the string because we cant change it 
ac02			; 
ac02			;		call malloc 
ac02			;	if DEBUG_FORTH_MALLOC_GUARD 
ac02			;		push af 
ac02			;		call ishlzero 
ac02			;		pop af 
ac02			;		 
ac02			;		call z,malloc_error 
ac02			;	endif 
ac02			; 
ac02			;	if DEBUG_FORTH_WORDS 
ac02			;		DMARK "Lt2" 
ac02			;		CALLMONITOR 
ac02			;	endif 
ac02			;		pop de 
ac02			;		push hl    ; push the malloc to release later 
ac02			;		push hl   ;  push back a copy for the later stack push 
ac02			;		 
ac02			;; copy the string swapping out the zero terms for spaces 
ac02			; 
ac02			;		; de has our source 
ac02			;		; hl has our dest 
ac02			; 
ac02			;; add the coln def 
ac02			; 
ac02			;		ld a, ':' 
ac02			;		ld (hl), a 
ac02			;		inc hl 
ac02			;		ld a, ' ' 
ac02			;		ld (hl), a 
ac02			;		inc hl 
ac02			; 
ac02			;; add the uname word 
ac02			;		push de   ; save our string for now 
ac02			;		ex de, hl 
ac02			; 
ac02			;		FORTH_DSP_VALUE 
ac02			;		;v5 FORTH_DSP_VALUE 
ac02			; 
ac02			;		inc hl   ; skip type but we know by now this is OK 
ac02			; 
ac02			;.luword:	ld a,(hl) 
ac02			;		cp 0 
ac02			;		jr z, .luword2 
ac02			;		ld (de), a 
ac02			;		inc de 
ac02			;		inc hl 
ac02			;		jr .luword 
ac02			; 
ac02			;.luword2:	ld a, ' ' 
ac02			;		ld (de), a 
ac02			;;		inc hl 
ac02			;;		inc de 
ac02			;;		ld (de), a 
ac02			;;		inc hl 
ac02			;		inc de 
ac02			; 
ac02			;		ex de, hl 
ac02			;		pop de 
ac02			;		 
ac02			;		 
ac02			; 
ac02			;; detoken that string and copy it 
ac02			; 
ac02			;	if DEBUG_FORTH_WORDS 
ac02			;		DMARK "Lt2" 
ac02			;		CALLMONITOR 
ac02			;	endif 
ac02			;.ldetok:	ld a, (de) 
ac02			;		cp FORTH_END_BUFFER 
ac02			;		jr z, .ldetokend 
ac02			;		; swap out any zero term for space 
ac02			;		cp 0 
ac02			;		jr nz, .ldetoknext 
ac02			;		ld a, ' ' 
ac02			; 
ac02			;	if DEBUG_FORTH_WORDS 
ac02			;		DMARK "LtS" 
ac02			;		CALLMONITOR 
ac02			;	endif 
ac02			;.ldetoknext:	ld (hl), a 
ac02			;		inc de 
ac02			;		inc hl 
ac02			;		jr .ldetok 
ac02			; 
ac02			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
ac02			;		ld (hl), a  
ac02			; 
ac02			;; free that temp malloc 
ac02			; 
ac02			;		pop hl    
ac02			; 
ac02			;	if DEBUG_FORTH_WORDS 
ac02			;		DMARK "Lt4" 
ac02			;		CALLMONITOR 
ac02			;	endif 
ac02			;		call forth_apushstrhl 
ac02			; 
ac02			;		; get rid of temp malloc area 
ac02			; 
ac02			;		pop hl 
ac02			;		call free 
ac02			; 
ac02			;		jr .ludone 
ac02			; 
ac02			;.lnuword:	pop hl 
ac02			;		call forth_tok_next 
ac02			;		jp .ldouscan  
ac02			; 
ac02			;.ludone:		 pop hl 
ac02			; 
ac02					NEXTW 
ac02 cd 6c ee			call parse_vector 
ac05 c3 aa 9d			jp macro_next 
ac08				endm 
# End of macro NEXTW
ac08			 
ac08			.FORGET: 
ac08				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
ac08 5d				db WORD_SYS_CORE+73             
ac09 83 ac			dw .NOP            
ac0b 07				db 6 + 1 
ac0c .. 00			db "FORGET",0              
ac13				endm 
# End of macro CWHEAD
ac13			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
ac13			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
ac13			; | |  
ac13			; | | e.g. "MORE" forget 
ac13					if DEBUG_FORTH_WORDS_KEY 
ac13						DMARK "FRG" 
ac13 f5				push af  
ac14 3a 28 ac			ld a, (.dmark)  
ac17 32 62 ee			ld (debug_mark),a  
ac1a 3a 29 ac			ld a, (.dmark+1)  
ac1d 32 63 ee			ld (debug_mark+1),a  
ac20 3a 2a ac			ld a, (.dmark+2)  
ac23 32 64 ee			ld (debug_mark+2),a  
ac26 18 03			jr .pastdmark  
ac28 ..			.dmark: db "FRG"  
ac2b f1			.pastdmark: pop af  
ac2c			endm  
# End of macro DMARK
ac2c						CALLMONITOR 
ac2c cd 6f ee			call debug_vector  
ac2f				endm  
# End of macro CALLMONITOR
ac2f					endif 
ac2f			 
ac2f				; find uword 
ac2f			        ; update start of word with "_" 
ac2f				; replace uword with deleted flag 
ac2f			 
ac2f			 
ac2f			;	if DEBUG_FORTH_WORDS 
ac2f			;		DMARK "FOG" 
ac2f			;		CALLMONITOR 
ac2f			;	endif 
ac2f			 
ac2f			 
ac2f					; Get ptr to the word we need to look up 
ac2f			 
ac2f					FORTH_DSP_VALUEHL 
ac2f cd c3 9b			call macro_dsp_valuehl 
ac32				endm 
# End of macro FORTH_DSP_VALUEHL
ac32					;v5 FORTH_DSP_VALUE 
ac32				; TODO type check 
ac32			;		inc hl    ; Skip type check  
ac32 e5					push hl 
ac33 c1					pop bc 
ac34			;		ex de, hl    ; put into DE 
ac34			 
ac34			 
ac34 21 66 e4				ld hl, baseram 
ac37					;ld hl, baseusermem 
ac37			 
ac37				; skip dict stub 
ac37			;	call forth_tok_next 
ac37 e5			push hl   ; sacreifical push 
ac38			 
ac38			.fldouscanm: 
ac38 e1				pop hl 
ac39			.fldouscan: 
ac39			;	if DEBUG_FORTH_WORDS 
ac39			;		DMARK "LSs" 
ac39			;		CALLMONITOR 
ac39			;	endif 
ac39				; skip dict stub 
ac39 cd dc 9e				call forth_tok_next 
ac3c			 
ac3c			 
ac3c			; while we have words to look for 
ac3c			 
ac3c 7e				ld a, (hl)      
ac3d			;	if DEBUG_FORTH_WORDS 
ac3d			;		DMARK "LSk" 
ac3d			;		CALLMONITOR 
ac3d			;	endif 
ac3d fe 00				cp WORD_SYS_END 
ac3f ca 7a ac				jp z, .flunotfound 
ac42 fe 01				cp WORD_SYS_UWORD 
ac44 c2 39 ac				jp nz, .fldouscan 
ac47			 
ac47			;	if DEBUG_FORTH_WORDS 
ac47			;		DMARK "LSu" 
ac47			;		CALLMONITOR 
ac47			;	endif 
ac47			 
ac47					; found a uword but is it the one we want... 
ac47			 
ac47 c5					push bc     ; uword to find is on bc 
ac48 d1					pop de 
ac49			 
ac49 e5					push hl  ; to save the ptr 
ac4a			 
ac4a					; skip opcode 
ac4a 23					inc hl  
ac4b					; skip next ptr 
ac4b 23					inc hl  
ac4c 23					inc hl 
ac4d					; skip len 
ac4d 23					inc hl 
ac4e			 
ac4e			;	if DEBUG_FORTH_WORDS 
ac4e			;		DMARK "LSc" 
ac4e			;		CALLMONITOR 
ac4e			;	endif 
ac4e cd 66 90				call strcmp 
ac51 c2 38 ac				jp nz, .fldouscanm 
ac54			; 
ac54			; 
ac54			;; while we have words to look for 
ac54			; 
ac54			;.fdouscan:	ld a, (hl)      
ac54			;	if DEBUG_FORTH_WORDS 
ac54			;		DMARK "LSs" 
ac54			;		CALLMONITOR 
ac54			;	endif 
ac54			;		cp WORD_SYS_END 
ac54			;		jp z, .fudone 
ac54			;		cp WORD_SYS_UWORD 
ac54			;		jp nz, .fnuword 
ac54			; 
ac54			;	if DEBUG_FORTH_WORDS 
ac54			;		DMARK "FGu" 
ac54			;		CALLMONITOR 
ac54			;	endif 
ac54			; 
ac54			;		; found a uword but is it the one we want... 
ac54			; 
ac54			; 
ac54			;	        pop de   ; get back the dsp name 
ac54			;		push de 
ac54			; 
ac54			;		push hl  ; to save the ptr 
ac54			; 
ac54			;		; skip opcode 
ac54			;		inc hl  
ac54			;		; skip next ptr 
ac54			;		inc hl  
ac54			;		inc hl 
ac54			;		; skip len 
ac54			;		inc hl 
ac54			; 
ac54			;	if DEBUG_FORTH_WORDS 
ac54			;		DMARK "FGc" 
ac54			;		CALLMONITOR 
ac54			;	endif 
ac54			;		call strcmp 
ac54			;		jp nz, .fnuword 
ac54			 
ac54			 
ac54 e1			pop hl 
ac55			 
ac55				 
ac55				if DEBUG_FORTH_WORDS 
ac55					DMARK "FGm" 
ac55 f5				push af  
ac56 3a 6a ac			ld a, (.dmark)  
ac59 32 62 ee			ld (debug_mark),a  
ac5c 3a 6b ac			ld a, (.dmark+1)  
ac5f 32 63 ee			ld (debug_mark+1),a  
ac62 3a 6c ac			ld a, (.dmark+2)  
ac65 32 64 ee			ld (debug_mark+2),a  
ac68 18 03			jr .pastdmark  
ac6a ..			.dmark: db "FGm"  
ac6d f1			.pastdmark: pop af  
ac6e			endm  
# End of macro DMARK
ac6e					CALLMONITOR 
ac6e cd 6f ee			call debug_vector  
ac71				endm  
# End of macro CALLMONITOR
ac71				endif 
ac71			 
ac71			 
ac71			 
ac71					; we have a uword so push its name to the stack 
ac71			 
ac71			;	   	push hl  ; save so we can move to next dict block 
ac71			;pop hl 
ac71			 
ac71					; update opcode to deleted 
ac71			;		ld a, WORD_SYS_DELETED 
ac71 36 03				ld (hl), WORD_SYS_DELETED 
ac73			 
ac73 23					inc hl  
ac74					; skip next ptr 
ac74 23					inc hl  
ac75 23					inc hl 
ac76					; skip len 
ac76 23					inc hl 
ac77			 
ac77					; TODO change parser to skip deleted words but for now mark it out 
ac77 3e 5f				ld a, "_" 
ac79 77					ld  (hl),a 
ac7a			 
ac7a			;		jr .fudone 
ac7a			; 
ac7a			;.fnuword:	pop hl 
ac7a			;		call forth_tok_next 
ac7a			;		jp .fdouscan  
ac7a			 
ac7a			.flunotfound:		  
ac7a			 
ac7a			 
ac7a					 
ac7a					FORTH_DSP_POP 
ac7a cd 7b 9c			call macro_forth_dsp_pop 
ac7d				endm 
# End of macro FORTH_DSP_POP
ac7d			;		ld hl, .luno 
ac7d			;.fudone:		 pop hl 
ac7d					NEXTW 
ac7d cd 6c ee			call parse_vector 
ac80 c3 aa 9d			jp macro_next 
ac83				endm 
# End of macro NEXTW
ac83			.NOP: 
ac83				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
ac83 61				db WORD_SYS_CORE+77             
ac84 ad ac			dw .COMO            
ac86 04				db 3 + 1 
ac87 .. 00			db "NOP",0              
ac8b				endm 
# End of macro CWHEAD
ac8b			; | NOP (  --  ) Do nothing | DONE 
ac8b					if DEBUG_FORTH_WORDS_KEY 
ac8b						DMARK "NOP" 
ac8b f5				push af  
ac8c 3a a0 ac			ld a, (.dmark)  
ac8f 32 62 ee			ld (debug_mark),a  
ac92 3a a1 ac			ld a, (.dmark+1)  
ac95 32 63 ee			ld (debug_mark+1),a  
ac98 3a a2 ac			ld a, (.dmark+2)  
ac9b 32 64 ee			ld (debug_mark+2),a  
ac9e 18 03			jr .pastdmark  
aca0 ..			.dmark: db "NOP"  
aca3 f1			.pastdmark: pop af  
aca4			endm  
# End of macro DMARK
aca4						CALLMONITOR 
aca4 cd 6f ee			call debug_vector  
aca7				endm  
# End of macro CALLMONITOR
aca7					endif 
aca7				       NEXTW 
aca7 cd 6c ee			call parse_vector 
acaa c3 aa 9d			jp macro_next 
acad				endm 
# End of macro NEXTW
acad			.COMO: 
acad				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
acad 6e				db WORD_SYS_CORE+90             
acae 02 ad			dw .COMC            
acb0 02				db 1 + 1 
acb1 .. 00			db "(",0              
acb3				endm 
# End of macro CWHEAD
acb3			; | ( ( -- )  Start of comment | DONE 
acb3			 
acb3			 
acb3 2a b9 e5				ld hl, ( os_tok_ptr) 
acb6 11 fa ac			ld de, .closepar 
acb9					 
acb9					if DEBUG_FORTH_WORDS 
acb9						DMARK ").." 
acb9 f5				push af  
acba 3a ce ac			ld a, (.dmark)  
acbd 32 62 ee			ld (debug_mark),a  
acc0 3a cf ac			ld a, (.dmark+1)  
acc3 32 63 ee			ld (debug_mark+1),a  
acc6 3a d0 ac			ld a, (.dmark+2)  
acc9 32 64 ee			ld (debug_mark+2),a  
accc 18 03			jr .pastdmark  
acce ..			.dmark: db ").."  
acd1 f1			.pastdmark: pop af  
acd2			endm  
# End of macro DMARK
acd2						CALLMONITOR 
acd2 cd 6f ee			call debug_vector  
acd5				endm  
# End of macro CALLMONITOR
acd5					endif 
acd5 cd a7 9e			call findnexttok  
acd8			 
acd8					if DEBUG_FORTH_WORDS 
acd8						DMARK "IF5" 
acd8 f5				push af  
acd9 3a ed ac			ld a, (.dmark)  
acdc 32 62 ee			ld (debug_mark),a  
acdf 3a ee ac			ld a, (.dmark+1)  
ace2 32 63 ee			ld (debug_mark+1),a  
ace5 3a ef ac			ld a, (.dmark+2)  
ace8 32 64 ee			ld (debug_mark+2),a  
aceb 18 03			jr .pastdmark  
aced ..			.dmark: db "IF5"  
acf0 f1			.pastdmark: pop af  
acf1			endm  
# End of macro DMARK
acf1						CALLMONITOR 
acf1 cd 6f ee			call debug_vector  
acf4				endm  
# End of macro CALLMONITOR
acf4					endif 
acf4				; replace below with ) exec using tok_ptr 
acf4 22 b9 e5			ld (os_tok_ptr), hl 
acf7 c3 2b 9e			jp exec1 
acfa			 
acfa .. 00			.closepar:   db ")",0 
acfc			 
acfc				       NEXTW 
acfc cd 6c ee			call parse_vector 
acff c3 aa 9d			jp macro_next 
ad02				endm 
# End of macro NEXTW
ad02			.COMC: 
ad02				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ad02 6f				db WORD_SYS_CORE+91             
ad03 0e ad			dw .SCRATCH            
ad05 02				db 1 + 1 
ad06 .. 00			db ")",0              
ad08				endm 
# End of macro CWHEAD
ad08			; | ) ( -- )  End of comment |  DONE  
ad08				       NEXTW 
ad08 cd 6c ee			call parse_vector 
ad0b c3 aa 9d			jp macro_next 
ad0e				endm 
# End of macro NEXTW
ad0e			 
ad0e			.SCRATCH: 
ad0e				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ad0e 6f				db WORD_SYS_CORE+91             
ad0f 4c ad			dw .INC            
ad11 08				db 7 + 1 
ad12 .. 00			db "SCRATCH",0              
ad1a				endm 
# End of macro CWHEAD
ad1a			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ad1a			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ad1a			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ad1a			; | |  
ad1a			; | | e.g.    : score $00 scratch ; 
ad1a			; | |  
ad1a			; | | $00 score ! 
ad1a			; | | $01 score +! 
ad1a			; | |  
ad1a			; | | e.g.   : varword $0a scratch ;  
ad1a			; | | 
ad1a			; | | $8000 varword ! 
ad1a					if DEBUG_FORTH_WORDS_KEY 
ad1a						DMARK "SCR" 
ad1a f5				push af  
ad1b 3a 2f ad			ld a, (.dmark)  
ad1e 32 62 ee			ld (debug_mark),a  
ad21 3a 30 ad			ld a, (.dmark+1)  
ad24 32 63 ee			ld (debug_mark+1),a  
ad27 3a 31 ad			ld a, (.dmark+2)  
ad2a 32 64 ee			ld (debug_mark+2),a  
ad2d 18 03			jr .pastdmark  
ad2f ..			.dmark: db "SCR"  
ad32 f1			.pastdmark: pop af  
ad33			endm  
# End of macro DMARK
ad33						CALLMONITOR 
ad33 cd 6f ee			call debug_vector  
ad36				endm  
# End of macro CALLMONITOR
ad36					endif 
ad36			 
ad36					FORTH_DSP_VALUEHL 
ad36 cd c3 9b			call macro_dsp_valuehl 
ad39				endm 
# End of macro FORTH_DSP_VALUEHL
ad39				 
ad39					FORTH_DSP_POP 
ad39 cd 7b 9c			call macro_forth_dsp_pop 
ad3c				endm 
# End of macro FORTH_DSP_POP
ad3c			 
ad3c 7d					ld a, l 
ad3d 21 dd e7				ld hl, os_var_array 
ad40 cd d6 8c				call addatohl 
ad43			 
ad43 cd c7 99				call forth_push_numhl 
ad46			 
ad46				       NEXTW 
ad46 cd 6c ee			call parse_vector 
ad49 c3 aa 9d			jp macro_next 
ad4c				endm 
# End of macro NEXTW
ad4c			 
ad4c			.INC: 
ad4c				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ad4c 6f				db WORD_SYS_CORE+91             
ad4d a5 ad			dw .DEC            
ad4f 03				db 2 + 1 
ad50 .. 00			db "+!",0              
ad53				endm 
# End of macro CWHEAD
ad53			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ad53					if DEBUG_FORTH_WORDS_KEY 
ad53						DMARK "+s_" 
ad53 f5				push af  
ad54 3a 68 ad			ld a, (.dmark)  
ad57 32 62 ee			ld (debug_mark),a  
ad5a 3a 69 ad			ld a, (.dmark+1)  
ad5d 32 63 ee			ld (debug_mark+1),a  
ad60 3a 6a ad			ld a, (.dmark+2)  
ad63 32 64 ee			ld (debug_mark+2),a  
ad66 18 03			jr .pastdmark  
ad68 ..			.dmark: db "+s_"  
ad6b f1			.pastdmark: pop af  
ad6c			endm  
# End of macro DMARK
ad6c						CALLMONITOR 
ad6c cd 6f ee			call debug_vector  
ad6f				endm  
# End of macro CALLMONITOR
ad6f					endif 
ad6f			 
ad6f					FORTH_DSP_VALUEHL 
ad6f cd c3 9b			call macro_dsp_valuehl 
ad72				endm 
# End of macro FORTH_DSP_VALUEHL
ad72			 
ad72 e5					push hl   ; save address 
ad73			 
ad73					FORTH_DSP_POP 
ad73 cd 7b 9c			call macro_forth_dsp_pop 
ad76				endm 
# End of macro FORTH_DSP_POP
ad76			 
ad76					FORTH_DSP_VALUEHL 
ad76 cd c3 9b			call macro_dsp_valuehl 
ad79				endm 
# End of macro FORTH_DSP_VALUEHL
ad79			 
ad79 e5					push hl 
ad7a					FORTH_DSP_POP 
ad7a cd 7b 9c			call macro_forth_dsp_pop 
ad7d				endm 
# End of macro FORTH_DSP_POP
ad7d e1					pop hl 
ad7e			 
ad7e					; hl contains value to add to byte at a 
ad7e				 
ad7e eb					ex de, hl 
ad7f			 
ad7f e1					pop hl 
ad80			 
ad80					if DEBUG_FORTH_WORDS 
ad80						DMARK "INC" 
ad80 f5				push af  
ad81 3a 95 ad			ld a, (.dmark)  
ad84 32 62 ee			ld (debug_mark),a  
ad87 3a 96 ad			ld a, (.dmark+1)  
ad8a 32 63 ee			ld (debug_mark+1),a  
ad8d 3a 97 ad			ld a, (.dmark+2)  
ad90 32 64 ee			ld (debug_mark+2),a  
ad93 18 03			jr .pastdmark  
ad95 ..			.dmark: db "INC"  
ad98 f1			.pastdmark: pop af  
ad99			endm  
# End of macro DMARK
ad99						CALLMONITOR 
ad99 cd 6f ee			call debug_vector  
ad9c				endm  
# End of macro CALLMONITOR
ad9c					endif 
ad9c			 
ad9c 7e					ld a,(hl) 
ad9d 83					add e 
ad9e 77					ld (hl),a 
ad9f			 
ad9f			 
ad9f			 
ad9f				       NEXTW 
ad9f cd 6c ee			call parse_vector 
ada2 c3 aa 9d			jp macro_next 
ada5				endm 
# End of macro NEXTW
ada5			 
ada5			.DEC: 
ada5				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
ada5 6f				db WORD_SYS_CORE+91             
ada6 fc ad			dw .INC2            
ada8 03				db 2 + 1 
ada9 .. 00			db "-!",0              
adac				endm 
# End of macro CWHEAD
adac			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
adac					if DEBUG_FORTH_WORDS_KEY 
adac						DMARK "-s_" 
adac f5				push af  
adad 3a c1 ad			ld a, (.dmark)  
adb0 32 62 ee			ld (debug_mark),a  
adb3 3a c2 ad			ld a, (.dmark+1)  
adb6 32 63 ee			ld (debug_mark+1),a  
adb9 3a c3 ad			ld a, (.dmark+2)  
adbc 32 64 ee			ld (debug_mark+2),a  
adbf 18 03			jr .pastdmark  
adc1 ..			.dmark: db "-s_"  
adc4 f1			.pastdmark: pop af  
adc5			endm  
# End of macro DMARK
adc5						CALLMONITOR 
adc5 cd 6f ee			call debug_vector  
adc8				endm  
# End of macro CALLMONITOR
adc8					endif 
adc8			 
adc8					FORTH_DSP_VALUEHL 
adc8 cd c3 9b			call macro_dsp_valuehl 
adcb				endm 
# End of macro FORTH_DSP_VALUEHL
adcb			 
adcb e5					push hl   ; save address 
adcc			 
adcc					FORTH_DSP_POP 
adcc cd 7b 9c			call macro_forth_dsp_pop 
adcf				endm 
# End of macro FORTH_DSP_POP
adcf			 
adcf					FORTH_DSP_VALUEHL 
adcf cd c3 9b			call macro_dsp_valuehl 
add2				endm 
# End of macro FORTH_DSP_VALUEHL
add2			 
add2					; hl contains value to add to byte at a 
add2				 
add2 eb					ex de, hl 
add3			 
add3 e1					pop hl 
add4			 
add4					if DEBUG_FORTH_WORDS 
add4						DMARK "DEC" 
add4 f5				push af  
add5 3a e9 ad			ld a, (.dmark)  
add8 32 62 ee			ld (debug_mark),a  
addb 3a ea ad			ld a, (.dmark+1)  
adde 32 63 ee			ld (debug_mark+1),a  
ade1 3a eb ad			ld a, (.dmark+2)  
ade4 32 64 ee			ld (debug_mark+2),a  
ade7 18 03			jr .pastdmark  
ade9 ..			.dmark: db "DEC"  
adec f1			.pastdmark: pop af  
aded			endm  
# End of macro DMARK
aded						CALLMONITOR 
aded cd 6f ee			call debug_vector  
adf0				endm  
# End of macro CALLMONITOR
adf0					endif 
adf0			 
adf0 7e					ld a,(hl) 
adf1 93					sub e 
adf2 77					ld (hl),a 
adf3			 
adf3			 
adf3					FORTH_DSP_POP 
adf3 cd 7b 9c			call macro_forth_dsp_pop 
adf6				endm 
# End of macro FORTH_DSP_POP
adf6			 
adf6				       NEXTW 
adf6 cd 6c ee			call parse_vector 
adf9 c3 aa 9d			jp macro_next 
adfc				endm 
# End of macro NEXTW
adfc			 
adfc			.INC2: 
adfc				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
adfc 6f				db WORD_SYS_CORE+91             
adfd ac ae			dw .DEC2            
adff 04				db 3 + 1 
ae00 .. 00			db "+2!",0              
ae04				endm 
# End of macro CWHEAD
ae04			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ae04			 
ae04					if DEBUG_FORTH_WORDS_KEY 
ae04						DMARK "+2s" 
ae04 f5				push af  
ae05 3a 19 ae			ld a, (.dmark)  
ae08 32 62 ee			ld (debug_mark),a  
ae0b 3a 1a ae			ld a, (.dmark+1)  
ae0e 32 63 ee			ld (debug_mark+1),a  
ae11 3a 1b ae			ld a, (.dmark+2)  
ae14 32 64 ee			ld (debug_mark+2),a  
ae17 18 03			jr .pastdmark  
ae19 ..			.dmark: db "+2s"  
ae1c f1			.pastdmark: pop af  
ae1d			endm  
# End of macro DMARK
ae1d						CALLMONITOR 
ae1d cd 6f ee			call debug_vector  
ae20				endm  
# End of macro CALLMONITOR
ae20					endif 
ae20			 
ae20					; Address 
ae20			 
ae20					FORTH_DSP_VALUEHL 
ae20 cd c3 9b			call macro_dsp_valuehl 
ae23				endm 
# End of macro FORTH_DSP_VALUEHL
ae23			 
ae23 e5					push hl    ; save address 
ae24			 
ae24					; load content into de 
ae24			 
ae24 5e					ld e,(hl) 
ae25 23					inc hl 
ae26 56					ld d, (hl) 
ae27			 
ae27					if DEBUG_FORTH_WORDS 
ae27						DMARK "+2a" 
ae27 f5				push af  
ae28 3a 3c ae			ld a, (.dmark)  
ae2b 32 62 ee			ld (debug_mark),a  
ae2e 3a 3d ae			ld a, (.dmark+1)  
ae31 32 63 ee			ld (debug_mark+1),a  
ae34 3a 3e ae			ld a, (.dmark+2)  
ae37 32 64 ee			ld (debug_mark+2),a  
ae3a 18 03			jr .pastdmark  
ae3c ..			.dmark: db "+2a"  
ae3f f1			.pastdmark: pop af  
ae40			endm  
# End of macro DMARK
ae40						CALLMONITOR 
ae40 cd 6f ee			call debug_vector  
ae43				endm  
# End of macro CALLMONITOR
ae43					endif 
ae43			 
ae43					FORTH_DSP_POP 
ae43 cd 7b 9c			call macro_forth_dsp_pop 
ae46				endm 
# End of macro FORTH_DSP_POP
ae46			 
ae46					; Get value to add 
ae46			 
ae46					FORTH_DSP_VALUE 
ae46 cd ac 9b			call macro_forth_dsp_value 
ae49				endm 
# End of macro FORTH_DSP_VALUE
ae49			 
ae49					if DEBUG_FORTH_WORDS 
ae49						DMARK "+2v" 
ae49 f5				push af  
ae4a 3a 5e ae			ld a, (.dmark)  
ae4d 32 62 ee			ld (debug_mark),a  
ae50 3a 5f ae			ld a, (.dmark+1)  
ae53 32 63 ee			ld (debug_mark+1),a  
ae56 3a 60 ae			ld a, (.dmark+2)  
ae59 32 64 ee			ld (debug_mark+2),a  
ae5c 18 03			jr .pastdmark  
ae5e ..			.dmark: db "+2v"  
ae61 f1			.pastdmark: pop af  
ae62			endm  
# End of macro DMARK
ae62						CALLMONITOR 
ae62 cd 6f ee			call debug_vector  
ae65				endm  
# End of macro CALLMONITOR
ae65					endif 
ae65			 
ae65 19					add hl, de 
ae66			 
ae66					if DEBUG_FORTH_WORDS 
ae66						DMARK "+2+" 
ae66 f5				push af  
ae67 3a 7b ae			ld a, (.dmark)  
ae6a 32 62 ee			ld (debug_mark),a  
ae6d 3a 7c ae			ld a, (.dmark+1)  
ae70 32 63 ee			ld (debug_mark+1),a  
ae73 3a 7d ae			ld a, (.dmark+2)  
ae76 32 64 ee			ld (debug_mark+2),a  
ae79 18 03			jr .pastdmark  
ae7b ..			.dmark: db "+2+"  
ae7e f1			.pastdmark: pop af  
ae7f			endm  
# End of macro DMARK
ae7f						CALLMONITOR 
ae7f cd 6f ee			call debug_vector  
ae82				endm  
# End of macro CALLMONITOR
ae82					endif 
ae82			 
ae82					; move result to de 
ae82			 
ae82 eb					ex de, hl 
ae83			 
ae83					; Address 
ae83			 
ae83 e1					pop hl 
ae84			 
ae84					; save it back 
ae84			 
ae84 73					ld (hl), e 
ae85 23					inc hl 
ae86 72					ld (hl), d 
ae87			 
ae87					if DEBUG_FORTH_WORDS 
ae87						DMARK "+2e" 
ae87 f5				push af  
ae88 3a 9c ae			ld a, (.dmark)  
ae8b 32 62 ee			ld (debug_mark),a  
ae8e 3a 9d ae			ld a, (.dmark+1)  
ae91 32 63 ee			ld (debug_mark+1),a  
ae94 3a 9e ae			ld a, (.dmark+2)  
ae97 32 64 ee			ld (debug_mark+2),a  
ae9a 18 03			jr .pastdmark  
ae9c ..			.dmark: db "+2e"  
ae9f f1			.pastdmark: pop af  
aea0			endm  
# End of macro DMARK
aea0						CALLMONITOR 
aea0 cd 6f ee			call debug_vector  
aea3				endm  
# End of macro CALLMONITOR
aea3					endif 
aea3			 
aea3			 
aea3			 
aea3					FORTH_DSP_POP 
aea3 cd 7b 9c			call macro_forth_dsp_pop 
aea6				endm 
# End of macro FORTH_DSP_POP
aea6			 
aea6			 
aea6				       NEXTW 
aea6 cd 6c ee			call parse_vector 
aea9 c3 aa 9d			jp macro_next 
aeac				endm 
# End of macro NEXTW
aeac			 
aeac			.DEC2: 
aeac				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aeac 6f				db WORD_SYS_CORE+91             
aead 5e af			dw .GET2            
aeaf 04				db 3 + 1 
aeb0 .. 00			db "-2!",0              
aeb4				endm 
# End of macro CWHEAD
aeb4			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
aeb4			 
aeb4			 
aeb4					if DEBUG_FORTH_WORDS_KEY 
aeb4						DMARK "-2s" 
aeb4 f5				push af  
aeb5 3a c9 ae			ld a, (.dmark)  
aeb8 32 62 ee			ld (debug_mark),a  
aebb 3a ca ae			ld a, (.dmark+1)  
aebe 32 63 ee			ld (debug_mark+1),a  
aec1 3a cb ae			ld a, (.dmark+2)  
aec4 32 64 ee			ld (debug_mark+2),a  
aec7 18 03			jr .pastdmark  
aec9 ..			.dmark: db "-2s"  
aecc f1			.pastdmark: pop af  
aecd			endm  
# End of macro DMARK
aecd						CALLMONITOR 
aecd cd 6f ee			call debug_vector  
aed0				endm  
# End of macro CALLMONITOR
aed0					endif 
aed0			 
aed0					; Address 
aed0			 
aed0					FORTH_DSP_VALUEHL 
aed0 cd c3 9b			call macro_dsp_valuehl 
aed3				endm 
# End of macro FORTH_DSP_VALUEHL
aed3			 
aed3 e5					push hl    ; save address 
aed4			 
aed4					; load content into de 
aed4			 
aed4 5e					ld e,(hl) 
aed5 23					inc hl 
aed6 56					ld d, (hl) 
aed7			 
aed7					if DEBUG_FORTH_WORDS 
aed7						DMARK "-2a" 
aed7 f5				push af  
aed8 3a ec ae			ld a, (.dmark)  
aedb 32 62 ee			ld (debug_mark),a  
aede 3a ed ae			ld a, (.dmark+1)  
aee1 32 63 ee			ld (debug_mark+1),a  
aee4 3a ee ae			ld a, (.dmark+2)  
aee7 32 64 ee			ld (debug_mark+2),a  
aeea 18 03			jr .pastdmark  
aeec ..			.dmark: db "-2a"  
aeef f1			.pastdmark: pop af  
aef0			endm  
# End of macro DMARK
aef0						CALLMONITOR 
aef0 cd 6f ee			call debug_vector  
aef3				endm  
# End of macro CALLMONITOR
aef3					endif 
aef3			 
aef3					FORTH_DSP_POP 
aef3 cd 7b 9c			call macro_forth_dsp_pop 
aef6				endm 
# End of macro FORTH_DSP_POP
aef6			 
aef6					; Get value to remove 
aef6			 
aef6					FORTH_DSP_VALUE 
aef6 cd ac 9b			call macro_forth_dsp_value 
aef9				endm 
# End of macro FORTH_DSP_VALUE
aef9			 
aef9					if DEBUG_FORTH_WORDS 
aef9						DMARK "-2v" 
aef9 f5				push af  
aefa 3a 0e af			ld a, (.dmark)  
aefd 32 62 ee			ld (debug_mark),a  
af00 3a 0f af			ld a, (.dmark+1)  
af03 32 63 ee			ld (debug_mark+1),a  
af06 3a 10 af			ld a, (.dmark+2)  
af09 32 64 ee			ld (debug_mark+2),a  
af0c 18 03			jr .pastdmark  
af0e ..			.dmark: db "-2v"  
af11 f1			.pastdmark: pop af  
af12			endm  
# End of macro DMARK
af12						CALLMONITOR 
af12 cd 6f ee			call debug_vector  
af15				endm  
# End of macro CALLMONITOR
af15					endif 
af15			 
af15 eb					ex de, hl 
af16 ed 52				sbc hl, de 
af18			 
af18					if DEBUG_FORTH_WORDS 
af18						DMARK "-2d" 
af18 f5				push af  
af19 3a 2d af			ld a, (.dmark)  
af1c 32 62 ee			ld (debug_mark),a  
af1f 3a 2e af			ld a, (.dmark+1)  
af22 32 63 ee			ld (debug_mark+1),a  
af25 3a 2f af			ld a, (.dmark+2)  
af28 32 64 ee			ld (debug_mark+2),a  
af2b 18 03			jr .pastdmark  
af2d ..			.dmark: db "-2d"  
af30 f1			.pastdmark: pop af  
af31			endm  
# End of macro DMARK
af31						CALLMONITOR 
af31 cd 6f ee			call debug_vector  
af34				endm  
# End of macro CALLMONITOR
af34					endif 
af34			 
af34					; move result to de 
af34			 
af34 eb					ex de, hl 
af35			 
af35					; Address 
af35			 
af35 e1					pop hl 
af36			 
af36					; save it back 
af36			 
af36 73					ld (hl), e 
af37 23					inc hl 
af38 72					ld (hl), d 
af39			 
af39					if DEBUG_FORTH_WORDS 
af39						DMARK "-2e" 
af39 f5				push af  
af3a 3a 4e af			ld a, (.dmark)  
af3d 32 62 ee			ld (debug_mark),a  
af40 3a 4f af			ld a, (.dmark+1)  
af43 32 63 ee			ld (debug_mark+1),a  
af46 3a 50 af			ld a, (.dmark+2)  
af49 32 64 ee			ld (debug_mark+2),a  
af4c 18 03			jr .pastdmark  
af4e ..			.dmark: db "-2e"  
af51 f1			.pastdmark: pop af  
af52			endm  
# End of macro DMARK
af52						CALLMONITOR 
af52 cd 6f ee			call debug_vector  
af55				endm  
# End of macro CALLMONITOR
af55					endif 
af55			 
af55			 
af55					FORTH_DSP_POP 
af55 cd 7b 9c			call macro_forth_dsp_pop 
af58				endm 
# End of macro FORTH_DSP_POP
af58			 
af58			 
af58			 
af58				       NEXTW 
af58 cd 6c ee			call parse_vector 
af5b c3 aa 9d			jp macro_next 
af5e				endm 
# End of macro NEXTW
af5e			.GET2: 
af5e				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
af5e 6f				db WORD_SYS_CORE+91             
af5f 96 af			dw .BANG2            
af61 03				db 2 + 1 
af62 .. 00			db "2@",0              
af65				endm 
# End of macro CWHEAD
af65			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
af65					if DEBUG_FORTH_WORDS_KEY 
af65						DMARK "2A_" 
af65 f5				push af  
af66 3a 7a af			ld a, (.dmark)  
af69 32 62 ee			ld (debug_mark),a  
af6c 3a 7b af			ld a, (.dmark+1)  
af6f 32 63 ee			ld (debug_mark+1),a  
af72 3a 7c af			ld a, (.dmark+2)  
af75 32 64 ee			ld (debug_mark+2),a  
af78 18 03			jr .pastdmark  
af7a ..			.dmark: db "2A_"  
af7d f1			.pastdmark: pop af  
af7e			endm  
# End of macro DMARK
af7e						CALLMONITOR 
af7e cd 6f ee			call debug_vector  
af81				endm  
# End of macro CALLMONITOR
af81					endif 
af81			 
af81					FORTH_DSP_VALUEHL 
af81 cd c3 9b			call macro_dsp_valuehl 
af84				endm 
# End of macro FORTH_DSP_VALUEHL
af84			 
af84 e5					push hl   ; save address 
af85			 
af85					FORTH_DSP_POP 
af85 cd 7b 9c			call macro_forth_dsp_pop 
af88				endm 
# End of macro FORTH_DSP_POP
af88			 
af88 e1					pop hl 
af89			 
af89 5e					ld e, (hl) 
af8a 23					inc hl 
af8b 56					ld d, (hl) 
af8c			 
af8c eb					ex de, hl 
af8d			 
af8d cd c7 99				call forth_push_numhl 
af90			 
af90				       NEXTW 
af90 cd 6c ee			call parse_vector 
af93 c3 aa 9d			jp macro_next 
af96				endm 
# End of macro NEXTW
af96			.BANG2: 
af96				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
af96 6f				db WORD_SYS_CORE+91             
af97 d1 af			dw .CONFIG            
af99 03				db 2 + 1 
af9a .. 00			db "2!",0              
af9d				endm 
# End of macro CWHEAD
af9d			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
af9d					if DEBUG_FORTH_WORDS_KEY 
af9d						DMARK "2S_" 
af9d f5				push af  
af9e 3a b2 af			ld a, (.dmark)  
afa1 32 62 ee			ld (debug_mark),a  
afa4 3a b3 af			ld a, (.dmark+1)  
afa7 32 63 ee			ld (debug_mark+1),a  
afaa 3a b4 af			ld a, (.dmark+2)  
afad 32 64 ee			ld (debug_mark+2),a  
afb0 18 03			jr .pastdmark  
afb2 ..			.dmark: db "2S_"  
afb5 f1			.pastdmark: pop af  
afb6			endm  
# End of macro DMARK
afb6						CALLMONITOR 
afb6 cd 6f ee			call debug_vector  
afb9				endm  
# End of macro CALLMONITOR
afb9					endif 
afb9			 
afb9					FORTH_DSP_VALUEHL 
afb9 cd c3 9b			call macro_dsp_valuehl 
afbc				endm 
# End of macro FORTH_DSP_VALUEHL
afbc			 
afbc e5					push hl   ; save address 
afbd			 
afbd			 
afbd					FORTH_DSP_POP 
afbd cd 7b 9c			call macro_forth_dsp_pop 
afc0				endm 
# End of macro FORTH_DSP_POP
afc0			 
afc0					 
afc0					FORTH_DSP_VALUEHL 
afc0 cd c3 9b			call macro_dsp_valuehl 
afc3				endm 
# End of macro FORTH_DSP_VALUEHL
afc3			 
afc3					FORTH_DSP_POP 
afc3 cd 7b 9c			call macro_forth_dsp_pop 
afc6				endm 
# End of macro FORTH_DSP_POP
afc6			 
afc6 eb					ex de, hl    ; value now in de 
afc7			 
afc7 e1					pop hl 
afc8			 
afc8 73					ld (hl), e 
afc9			 
afc9 23					inc hl 
afca			 
afca 72					ld (hl), d 
afcb			 
afcb			 
afcb				       NEXTW 
afcb cd 6c ee			call parse_vector 
afce c3 aa 9d			jp macro_next 
afd1				endm 
# End of macro NEXTW
afd1			.CONFIG: 
afd1				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
afd1 6f				db WORD_SYS_CORE+91             
afd2 e5 af			dw .ADTOS            
afd4 07				db 6 + 1 
afd5 .. 00			db "CONFIG",0              
afdc				endm 
# End of macro CWHEAD
afdc			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
afdc			 
afdc cd 3b 92				call config 
afdf					NEXTW 
afdf cd 6c ee			call parse_vector 
afe2 c3 aa 9d			jp macro_next 
afe5				endm 
# End of macro NEXTW
afe5			 
afe5			.ADTOS: 
afe5				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
afe5 6f				db WORD_SYS_CORE+91             
afe6 fe af			dw .SBTOS            
afe8 03				db 2 + 1 
afe9 .. 00			db "1+",0              
afec				endm 
# End of macro CWHEAD
afec			; | 1+ ( u -- u )  Increment value on TOS | DONE 
afec			 
afec					FORTH_DSP_VALUEHL 
afec cd c3 9b			call macro_dsp_valuehl 
afef				endm 
# End of macro FORTH_DSP_VALUEHL
afef e5					push hl 
aff0			 
aff0					FORTH_DSP_POP 
aff0 cd 7b 9c			call macro_forth_dsp_pop 
aff3				endm 
# End of macro FORTH_DSP_POP
aff3 e1					pop hl 
aff4			 
aff4 23					inc hl 
aff5 cd c7 99				call forth_push_numhl 
aff8					 
aff8					NEXTW 
aff8 cd 6c ee			call parse_vector 
affb c3 aa 9d			jp macro_next 
affe				endm 
# End of macro NEXTW
affe			.SBTOS: 
affe				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
affe 6f				db WORD_SYS_CORE+91             
afff 17 b0			dw .ADSTORE            
b001 03				db 2 + 1 
b002 .. 00			db "1-",0              
b005				endm 
# End of macro CWHEAD
b005			; | 1- ( u -- u )  Decrement value on TOS | DONE 
b005			 
b005					FORTH_DSP_VALUEHL 
b005 cd c3 9b			call macro_dsp_valuehl 
b008				endm 
# End of macro FORTH_DSP_VALUEHL
b008 e5					push hl 
b009			 
b009					FORTH_DSP_POP 
b009 cd 7b 9c			call macro_forth_dsp_pop 
b00c				endm 
# End of macro FORTH_DSP_POP
b00c e1					pop hl 
b00d			 
b00d 2b					dec hl 
b00e cd c7 99				call forth_push_numhl 
b011					 
b011					NEXTW 
b011 cd 6c ee			call parse_vector 
b014 c3 aa 9d			jp macro_next 
b017				endm 
# End of macro NEXTW
b017			.ADSTORE: 
b017				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
b017 6f				db WORD_SYS_CORE+91             
b018 30 b0			dw .ADWSTORE            
b01a 04				db 3 + 1 
b01b .. 00			db "1+!",0              
b01f				endm 
# End of macro CWHEAD
b01f			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
b01f			 
b01f					FORTH_DSP_VALUEHL 
b01f cd c3 9b			call macro_dsp_valuehl 
b022				endm 
# End of macro FORTH_DSP_VALUEHL
b022 e5					push hl 
b023			 
b023					FORTH_DSP_POP 
b023 cd 7b 9c			call macro_forth_dsp_pop 
b026				endm 
# End of macro FORTH_DSP_POP
b026 e1					pop hl 
b027			 
b027 7e					ld a, (hl) 
b028 3c					inc a 
b029 77					ld (hl), a 
b02a					 
b02a					NEXTW 
b02a cd 6c ee			call parse_vector 
b02d c3 aa 9d			jp macro_next 
b030				endm 
# End of macro NEXTW
b030			.ADWSTORE: 
b030				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
b030 6f				db WORD_SYS_CORE+91             
b031 51 b0			dw .SBSTORE            
b033 05				db 4 + 1 
b034 .. 00			db "1+2!",0              
b039				endm 
# End of macro CWHEAD
b039			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
b039			 
b039					FORTH_DSP_VALUEHL 
b039 cd c3 9b			call macro_dsp_valuehl 
b03c				endm 
# End of macro FORTH_DSP_VALUEHL
b03c e5					push hl 
b03d			 
b03d					FORTH_DSP_POP 
b03d cd 7b 9c			call macro_forth_dsp_pop 
b040				endm 
# End of macro FORTH_DSP_POP
b040 e1					pop hl 
b041			 
b041 e5					push hl 
b042			 
b042 cd 30 9d				call loadwordinhl 
b045 23					inc hl 
b046			 
b046 d1					pop de 
b047 eb					ex de, hl 
b048 73					ld (hl), e 
b049 23					inc hl 
b04a 72					ld (hl), d 
b04b					 
b04b					NEXTW 
b04b cd 6c ee			call parse_vector 
b04e c3 aa 9d			jp macro_next 
b051				endm 
# End of macro NEXTW
b051			.SBSTORE: 
b051				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
b051 6f				db WORD_SYS_CORE+91             
b052 6a b0			dw .SBWSTORE            
b054 04				db 3 + 1 
b055 .. 00			db "1-!",0              
b059				endm 
# End of macro CWHEAD
b059			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
b059			 
b059					FORTH_DSP_VALUEHL 
b059 cd c3 9b			call macro_dsp_valuehl 
b05c				endm 
# End of macro FORTH_DSP_VALUEHL
b05c e5					push hl 
b05d			 
b05d					FORTH_DSP_POP 
b05d cd 7b 9c			call macro_forth_dsp_pop 
b060				endm 
# End of macro FORTH_DSP_POP
b060 e1					pop hl 
b061			 
b061 7e					ld a, (hl) 
b062 3d					dec a 
b063 77					ld (hl), a 
b064					 
b064					NEXTW 
b064 cd 6c ee			call parse_vector 
b067 c3 aa 9d			jp macro_next 
b06a				endm 
# End of macro NEXTW
b06a			.SBWSTORE: 
b06a				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
b06a 6f				db WORD_SYS_CORE+91             
b06b 8b b0			dw .ENDCORE            
b06d 05				db 4 + 1 
b06e .. 00			db "1-2!",0              
b073				endm 
# End of macro CWHEAD
b073			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
b073			 
b073					FORTH_DSP_VALUEHL 
b073 cd c3 9b			call macro_dsp_valuehl 
b076				endm 
# End of macro FORTH_DSP_VALUEHL
b076 e5					push hl 
b077			 
b077					FORTH_DSP_POP 
b077 cd 7b 9c			call macro_forth_dsp_pop 
b07a				endm 
# End of macro FORTH_DSP_POP
b07a e1					pop hl 
b07b			 
b07b e5					push hl 
b07c			 
b07c cd 30 9d				call loadwordinhl 
b07f 2b					dec hl 
b080			 
b080 d1					pop de 
b081 eb					ex de, hl 
b082 73					ld (hl), e 
b083 23					inc hl 
b084 72					ld (hl), d 
b085					 
b085					NEXTW 
b085 cd 6c ee			call parse_vector 
b088 c3 aa 9d			jp macro_next 
b08b				endm 
# End of macro NEXTW
b08b			.ENDCORE: 
b08b			 
b08b			; eof 
b08b			 
b08b			 
# End of file forth_words_core.asm
b08b			include "forth_words_flow.asm" 
b08b			 
b08b			; | ## Program Flow Words 
b08b			 
b08b			.IF: 
b08b				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
b08b 1e				db WORD_SYS_CORE+10             
b08c 86 b1			dw .THEN            
b08e 03				db 2 + 1 
b08f .. 00			db "IF",0              
b092				endm 
# End of macro CWHEAD
b092			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
b092			; | | Note: currently not supporting ELSE or nested IF 
b092			; 
b092					if DEBUG_FORTH_WORDS_KEY 
b092						DMARK "IF." 
b092 f5				push af  
b093 3a a7 b0			ld a, (.dmark)  
b096 32 62 ee			ld (debug_mark),a  
b099 3a a8 b0			ld a, (.dmark+1)  
b09c 32 63 ee			ld (debug_mark+1),a  
b09f 3a a9 b0			ld a, (.dmark+2)  
b0a2 32 64 ee			ld (debug_mark+2),a  
b0a5 18 03			jr .pastdmark  
b0a7 ..			.dmark: db "IF."  
b0aa f1			.pastdmark: pop af  
b0ab			endm  
# End of macro DMARK
b0ab						CALLMONITOR 
b0ab cd 6f ee			call debug_vector  
b0ae				endm  
# End of macro CALLMONITOR
b0ae					endif 
b0ae			; eval TOS 
b0ae			 
b0ae				FORTH_DSP_VALUEHL 
b0ae cd c3 9b			call macro_dsp_valuehl 
b0b1				endm 
# End of macro FORTH_DSP_VALUEHL
b0b1			 
b0b1			;	push hl 
b0b1				FORTH_DSP_POP 
b0b1 cd 7b 9c			call macro_forth_dsp_pop 
b0b4				endm 
# End of macro FORTH_DSP_POP
b0b4			;	pop hl 
b0b4			 
b0b4					if DEBUG_FORTH_WORDS 
b0b4						DMARK "IF1" 
b0b4 f5				push af  
b0b5 3a c9 b0			ld a, (.dmark)  
b0b8 32 62 ee			ld (debug_mark),a  
b0bb 3a ca b0			ld a, (.dmark+1)  
b0be 32 63 ee			ld (debug_mark+1),a  
b0c1 3a cb b0			ld a, (.dmark+2)  
b0c4 32 64 ee			ld (debug_mark+2),a  
b0c7 18 03			jr .pastdmark  
b0c9 ..			.dmark: db "IF1"  
b0cc f1			.pastdmark: pop af  
b0cd			endm  
# End of macro DMARK
b0cd						CALLMONITOR 
b0cd cd 6f ee			call debug_vector  
b0d0				endm  
# End of macro CALLMONITOR
b0d0					endif 
b0d0 b7				or a        ; clear carry flag 
b0d1 11 00 00			ld de, 0 
b0d4 eb				ex de,hl 
b0d5 ed 52			sbc hl, de 
b0d7 c2 64 b1			jp nz, .iftrue 
b0da			 
b0da					if DEBUG_FORTH_WORDS 
b0da						DMARK "IF2" 
b0da f5				push af  
b0db 3a ef b0			ld a, (.dmark)  
b0de 32 62 ee			ld (debug_mark),a  
b0e1 3a f0 b0			ld a, (.dmark+1)  
b0e4 32 63 ee			ld (debug_mark+1),a  
b0e7 3a f1 b0			ld a, (.dmark+2)  
b0ea 32 64 ee			ld (debug_mark+2),a  
b0ed 18 03			jr .pastdmark  
b0ef ..			.dmark: db "IF2"  
b0f2 f1			.pastdmark: pop af  
b0f3			endm  
# End of macro DMARK
b0f3						CALLMONITOR 
b0f3 cd 6f ee			call debug_vector  
b0f6				endm  
# End of macro CALLMONITOR
b0f6					endif 
b0f6			 
b0f6			; if not true then skip to THEN 
b0f6			 
b0f6				; TODO get tok_ptr 
b0f6				; TODO consume toks until we get to THEN 
b0f6			 
b0f6 2a b9 e5			ld hl, (os_tok_ptr) 
b0f9					if DEBUG_FORTH_WORDS 
b0f9						DMARK "IF3" 
b0f9 f5				push af  
b0fa 3a 0e b1			ld a, (.dmark)  
b0fd 32 62 ee			ld (debug_mark),a  
b100 3a 0f b1			ld a, (.dmark+1)  
b103 32 63 ee			ld (debug_mark+1),a  
b106 3a 10 b1			ld a, (.dmark+2)  
b109 32 64 ee			ld (debug_mark+2),a  
b10c 18 03			jr .pastdmark  
b10e ..			.dmark: db "IF3"  
b111 f1			.pastdmark: pop af  
b112			endm  
# End of macro DMARK
b112						CALLMONITOR 
b112 cd 6f ee			call debug_vector  
b115				endm  
# End of macro CALLMONITOR
b115						 
b115					endif 
b115 11 5f b1			ld de, .ifthen 
b118					if DEBUG_FORTH_WORDS 
b118						DMARK "IF4" 
b118 f5				push af  
b119 3a 2d b1			ld a, (.dmark)  
b11c 32 62 ee			ld (debug_mark),a  
b11f 3a 2e b1			ld a, (.dmark+1)  
b122 32 63 ee			ld (debug_mark+1),a  
b125 3a 2f b1			ld a, (.dmark+2)  
b128 32 64 ee			ld (debug_mark+2),a  
b12b 18 03			jr .pastdmark  
b12d ..			.dmark: db "IF4"  
b130 f1			.pastdmark: pop af  
b131			endm  
# End of macro DMARK
b131						CALLMONITOR 
b131 cd 6f ee			call debug_vector  
b134				endm  
# End of macro CALLMONITOR
b134					endif 
b134 cd a7 9e			call findnexttok  
b137			 
b137					if DEBUG_FORTH_WORDS 
b137						DMARK "IF5" 
b137 f5				push af  
b138 3a 4c b1			ld a, (.dmark)  
b13b 32 62 ee			ld (debug_mark),a  
b13e 3a 4d b1			ld a, (.dmark+1)  
b141 32 63 ee			ld (debug_mark+1),a  
b144 3a 4e b1			ld a, (.dmark+2)  
b147 32 64 ee			ld (debug_mark+2),a  
b14a 18 03			jr .pastdmark  
b14c ..			.dmark: db "IF5"  
b14f f1			.pastdmark: pop af  
b150			endm  
# End of macro DMARK
b150						CALLMONITOR 
b150 cd 6f ee			call debug_vector  
b153				endm  
# End of macro CALLMONITOR
b153					endif 
b153				; TODO replace below with ; exec using tok_ptr 
b153 22 b9 e5			ld (os_tok_ptr), hl 
b156 c3 2b 9e			jp exec1 
b159				NEXTW 
b159 cd 6c ee			call parse_vector 
b15c c3 aa 9d			jp macro_next 
b15f				endm 
# End of macro NEXTW
b15f			 
b15f .. 00		.ifthen:  db "THEN",0 
b164			 
b164			.iftrue:		 
b164				; Exec next words normally 
b164			 
b164				; if true then exec following IF as normal 
b164					if DEBUG_FORTH_WORDS 
b164						DMARK "IFT" 
b164 f5				push af  
b165 3a 79 b1			ld a, (.dmark)  
b168 32 62 ee			ld (debug_mark),a  
b16b 3a 7a b1			ld a, (.dmark+1)  
b16e 32 63 ee			ld (debug_mark+1),a  
b171 3a 7b b1			ld a, (.dmark+2)  
b174 32 64 ee			ld (debug_mark+2),a  
b177 18 03			jr .pastdmark  
b179 ..			.dmark: db "IFT"  
b17c f1			.pastdmark: pop af  
b17d			endm  
# End of macro DMARK
b17d						CALLMONITOR 
b17d cd 6f ee			call debug_vector  
b180				endm  
# End of macro CALLMONITOR
b180					endif 
b180			 
b180					NEXTW 
b180 cd 6c ee			call parse_vector 
b183 c3 aa 9d			jp macro_next 
b186				endm 
# End of macro NEXTW
b186			.THEN: 
b186				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
b186 1f				db WORD_SYS_CORE+11             
b187 b1 b1			dw .ELSE            
b189 05				db 4 + 1 
b18a .. 00			db "THEN",0              
b18f				endm 
# End of macro CWHEAD
b18f			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
b18f					if DEBUG_FORTH_WORDS_KEY 
b18f						DMARK "THN" 
b18f f5				push af  
b190 3a a4 b1			ld a, (.dmark)  
b193 32 62 ee			ld (debug_mark),a  
b196 3a a5 b1			ld a, (.dmark+1)  
b199 32 63 ee			ld (debug_mark+1),a  
b19c 3a a6 b1			ld a, (.dmark+2)  
b19f 32 64 ee			ld (debug_mark+2),a  
b1a2 18 03			jr .pastdmark  
b1a4 ..			.dmark: db "THN"  
b1a7 f1			.pastdmark: pop af  
b1a8			endm  
# End of macro DMARK
b1a8						CALLMONITOR 
b1a8 cd 6f ee			call debug_vector  
b1ab				endm  
# End of macro CALLMONITOR
b1ab					endif 
b1ab					NEXTW 
b1ab cd 6c ee			call parse_vector 
b1ae c3 aa 9d			jp macro_next 
b1b1				endm 
# End of macro NEXTW
b1b1			.ELSE: 
b1b1				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
b1b1 20				db WORD_SYS_CORE+12             
b1b2 dc b1			dw .DO            
b1b4 03				db 2 + 1 
b1b5 .. 00			db "ELSE",0              
b1ba				endm 
# End of macro CWHEAD
b1ba			; | ELSE ( -- ) Not supported - does nothing | TODO 
b1ba			 
b1ba					if DEBUG_FORTH_WORDS_KEY 
b1ba						DMARK "ELS" 
b1ba f5				push af  
b1bb 3a cf b1			ld a, (.dmark)  
b1be 32 62 ee			ld (debug_mark),a  
b1c1 3a d0 b1			ld a, (.dmark+1)  
b1c4 32 63 ee			ld (debug_mark+1),a  
b1c7 3a d1 b1			ld a, (.dmark+2)  
b1ca 32 64 ee			ld (debug_mark+2),a  
b1cd 18 03			jr .pastdmark  
b1cf ..			.dmark: db "ELS"  
b1d2 f1			.pastdmark: pop af  
b1d3			endm  
# End of macro DMARK
b1d3						CALLMONITOR 
b1d3 cd 6f ee			call debug_vector  
b1d6				endm  
# End of macro CALLMONITOR
b1d6					endif 
b1d6			 
b1d6			 
b1d6					NEXTW 
b1d6 cd 6c ee			call parse_vector 
b1d9 c3 aa 9d			jp macro_next 
b1dc				endm 
# End of macro NEXTW
b1dc			.DO: 
b1dc				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
b1dc 21				db WORD_SYS_CORE+13             
b1dd 06 b3			dw .LOOP            
b1df 03				db 2 + 1 
b1e0 .. 00			db "DO",0              
b1e3				endm 
# End of macro CWHEAD
b1e3			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
b1e3			 
b1e3					if DEBUG_FORTH_WORDS_KEY 
b1e3						DMARK "DO." 
b1e3 f5				push af  
b1e4 3a f8 b1			ld a, (.dmark)  
b1e7 32 62 ee			ld (debug_mark),a  
b1ea 3a f9 b1			ld a, (.dmark+1)  
b1ed 32 63 ee			ld (debug_mark+1),a  
b1f0 3a fa b1			ld a, (.dmark+2)  
b1f3 32 64 ee			ld (debug_mark+2),a  
b1f6 18 03			jr .pastdmark  
b1f8 ..			.dmark: db "DO."  
b1fb f1			.pastdmark: pop af  
b1fc			endm  
# End of macro DMARK
b1fc						CALLMONITOR 
b1fc cd 6f ee			call debug_vector  
b1ff				endm  
# End of macro CALLMONITOR
b1ff					endif 
b1ff			;  push pc to rsp stack past the DO 
b1ff			 
b1ff 2a b9 e5				ld hl, (os_tok_ptr) 
b202 23					inc hl   ; D 
b203 23					inc hl  ; O 
b204 23					inc hl   ; null 
b205					if DEBUG_FORTH_WORDS 
b205						DMARK "DO2" 
b205 f5				push af  
b206 3a 1a b2			ld a, (.dmark)  
b209 32 62 ee			ld (debug_mark),a  
b20c 3a 1b b2			ld a, (.dmark+1)  
b20f 32 63 ee			ld (debug_mark+1),a  
b212 3a 1c b2			ld a, (.dmark+2)  
b215 32 64 ee			ld (debug_mark+2),a  
b218 18 03			jr .pastdmark  
b21a ..			.dmark: db "DO2"  
b21d f1			.pastdmark: pop af  
b21e			endm  
# End of macro DMARK
b21e						CALLMONITOR 
b21e cd 6f ee			call debug_vector  
b221				endm  
# End of macro CALLMONITOR
b221					endif 
b221					FORTH_RSP_NEXT 
b221 cd 6e 99			call macro_forth_rsp_next 
b224				endm 
# End of macro FORTH_RSP_NEXT
b224					if DEBUG_FORTH_WORDS 
b224						DMARK "DO3" 
b224 f5				push af  
b225 3a 39 b2			ld a, (.dmark)  
b228 32 62 ee			ld (debug_mark),a  
b22b 3a 3a b2			ld a, (.dmark+1)  
b22e 32 63 ee			ld (debug_mark+1),a  
b231 3a 3b b2			ld a, (.dmark+2)  
b234 32 64 ee			ld (debug_mark+2),a  
b237 18 03			jr .pastdmark  
b239 ..			.dmark: db "DO3"  
b23c f1			.pastdmark: pop af  
b23d			endm  
# End of macro DMARK
b23d						CALLMONITOR 
b23d cd 6f ee			call debug_vector  
b240				endm  
# End of macro CALLMONITOR
b240					endif 
b240			 
b240					;if DEBUG_FORTH_WORDS 
b240				;		push hl 
b240			;		endif  
b240			 
b240			; get counters from data stack 
b240			 
b240			 
b240					FORTH_DSP_VALUEHL 
b240 cd c3 9b			call macro_dsp_valuehl 
b243				endm 
# End of macro FORTH_DSP_VALUEHL
b243 e5					push hl		 ; hl now has starting counter which needs to be tos 
b244			 
b244					if DEBUG_FORTH_WORDS 
b244						DMARK "DO4" 
b244 f5				push af  
b245 3a 59 b2			ld a, (.dmark)  
b248 32 62 ee			ld (debug_mark),a  
b24b 3a 5a b2			ld a, (.dmark+1)  
b24e 32 63 ee			ld (debug_mark+1),a  
b251 3a 5b b2			ld a, (.dmark+2)  
b254 32 64 ee			ld (debug_mark+2),a  
b257 18 03			jr .pastdmark  
b259 ..			.dmark: db "DO4"  
b25c f1			.pastdmark: pop af  
b25d			endm  
# End of macro DMARK
b25d						CALLMONITOR 
b25d cd 6f ee			call debug_vector  
b260				endm  
# End of macro CALLMONITOR
b260					endif 
b260					FORTH_DSP_POP 
b260 cd 7b 9c			call macro_forth_dsp_pop 
b263				endm 
# End of macro FORTH_DSP_POP
b263			 
b263					if DEBUG_FORTH_WORDS 
b263						DMARK "DO5" 
b263 f5				push af  
b264 3a 78 b2			ld a, (.dmark)  
b267 32 62 ee			ld (debug_mark),a  
b26a 3a 79 b2			ld a, (.dmark+1)  
b26d 32 63 ee			ld (debug_mark+1),a  
b270 3a 7a b2			ld a, (.dmark+2)  
b273 32 64 ee			ld (debug_mark+2),a  
b276 18 03			jr .pastdmark  
b278 ..			.dmark: db "DO5"  
b27b f1			.pastdmark: pop af  
b27c			endm  
# End of macro DMARK
b27c						CALLMONITOR 
b27c cd 6f ee			call debug_vector  
b27f				endm  
# End of macro CALLMONITOR
b27f					endif 
b27f			 
b27f					FORTH_DSP_VALUEHL 
b27f cd c3 9b			call macro_dsp_valuehl 
b282				endm 
# End of macro FORTH_DSP_VALUEHL
b282			;		push hl		 ; hl now has starting limit counter 
b282			 
b282					if DEBUG_FORTH_WORDS 
b282						DMARK "DO6" 
b282 f5				push af  
b283 3a 97 b2			ld a, (.dmark)  
b286 32 62 ee			ld (debug_mark),a  
b289 3a 98 b2			ld a, (.dmark+1)  
b28c 32 63 ee			ld (debug_mark+1),a  
b28f 3a 99 b2			ld a, (.dmark+2)  
b292 32 64 ee			ld (debug_mark+2),a  
b295 18 03			jr .pastdmark  
b297 ..			.dmark: db "DO6"  
b29a f1			.pastdmark: pop af  
b29b			endm  
# End of macro DMARK
b29b						CALLMONITOR 
b29b cd 6f ee			call debug_vector  
b29e				endm  
# End of macro CALLMONITOR
b29e					endif 
b29e					FORTH_DSP_POP 
b29e cd 7b 9c			call macro_forth_dsp_pop 
b2a1				endm 
# End of macro FORTH_DSP_POP
b2a1			 
b2a1			; put counters on the loop stack 
b2a1			 
b2a1			;		pop hl			 ; limit counter 
b2a1 d1					pop de			; start counter 
b2a2			 
b2a2					; push limit counter 
b2a2			 
b2a2					if DEBUG_FORTH_WORDS 
b2a2						DMARK "DO7" 
b2a2 f5				push af  
b2a3 3a b7 b2			ld a, (.dmark)  
b2a6 32 62 ee			ld (debug_mark),a  
b2a9 3a b8 b2			ld a, (.dmark+1)  
b2ac 32 63 ee			ld (debug_mark+1),a  
b2af 3a b9 b2			ld a, (.dmark+2)  
b2b2 32 64 ee			ld (debug_mark+2),a  
b2b5 18 03			jr .pastdmark  
b2b7 ..			.dmark: db "DO7"  
b2ba f1			.pastdmark: pop af  
b2bb			endm  
# End of macro DMARK
b2bb						CALLMONITOR 
b2bb cd 6f ee			call debug_vector  
b2be				endm  
# End of macro CALLMONITOR
b2be					endif 
b2be					FORTH_LOOP_NEXT 
b2be cd f4 9b			call macro_forth_loop_next 
b2c1				endm 
# End of macro FORTH_LOOP_NEXT
b2c1			 
b2c1					; push start counter 
b2c1			 
b2c1 eb					ex de, hl 
b2c2					if DEBUG_FORTH_WORDS 
b2c2						DMARK "DO7" 
b2c2 f5				push af  
b2c3 3a d7 b2			ld a, (.dmark)  
b2c6 32 62 ee			ld (debug_mark),a  
b2c9 3a d8 b2			ld a, (.dmark+1)  
b2cc 32 63 ee			ld (debug_mark+1),a  
b2cf 3a d9 b2			ld a, (.dmark+2)  
b2d2 32 64 ee			ld (debug_mark+2),a  
b2d5 18 03			jr .pastdmark  
b2d7 ..			.dmark: db "DO7"  
b2da f1			.pastdmark: pop af  
b2db			endm  
# End of macro DMARK
b2db						CALLMONITOR 
b2db cd 6f ee			call debug_vector  
b2de				endm  
# End of macro CALLMONITOR
b2de					endif 
b2de					FORTH_LOOP_NEXT 
b2de cd f4 9b			call macro_forth_loop_next 
b2e1				endm 
# End of macro FORTH_LOOP_NEXT
b2e1			 
b2e1			 
b2e1					; init first round of I counter 
b2e1			 
b2e1 22 dd e5				ld (os_current_i), hl 
b2e4			 
b2e4					if DEBUG_FORTH_WORDS 
b2e4						DMARK "DO8" 
b2e4 f5				push af  
b2e5 3a f9 b2			ld a, (.dmark)  
b2e8 32 62 ee			ld (debug_mark),a  
b2eb 3a fa b2			ld a, (.dmark+1)  
b2ee 32 63 ee			ld (debug_mark+1),a  
b2f1 3a fb b2			ld a, (.dmark+2)  
b2f4 32 64 ee			ld (debug_mark+2),a  
b2f7 18 03			jr .pastdmark  
b2f9 ..			.dmark: db "DO8"  
b2fc f1			.pastdmark: pop af  
b2fd			endm  
# End of macro DMARK
b2fd						CALLMONITOR 
b2fd cd 6f ee			call debug_vector  
b300				endm  
# End of macro CALLMONITOR
b300					endif 
b300			 
b300					NEXTW 
b300 cd 6c ee			call parse_vector 
b303 c3 aa 9d			jp macro_next 
b306				endm 
# End of macro NEXTW
b306			.LOOP: 
b306				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b306 22				db WORD_SYS_CORE+14             
b307 24 b4			dw .I            
b309 05				db 4 + 1 
b30a .. 00			db "LOOP",0              
b30f				endm 
# End of macro CWHEAD
b30f			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b30f			 
b30f				; pop tos as current loop count to hl 
b30f			 
b30f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b30f			 
b30f				FORTH_LOOP_TOS 
b30f cd 27 9c			call macro_forth_loop_tos 
b312				endm 
# End of macro FORTH_LOOP_TOS
b312 e5				push hl 
b313			 
b313					if DEBUG_FORTH_WORDS_KEY 
b313						DMARK "LOP" 
b313 f5				push af  
b314 3a 28 b3			ld a, (.dmark)  
b317 32 62 ee			ld (debug_mark),a  
b31a 3a 29 b3			ld a, (.dmark+1)  
b31d 32 63 ee			ld (debug_mark+1),a  
b320 3a 2a b3			ld a, (.dmark+2)  
b323 32 64 ee			ld (debug_mark+2),a  
b326 18 03			jr .pastdmark  
b328 ..			.dmark: db "LOP"  
b32b f1			.pastdmark: pop af  
b32c			endm  
# End of macro DMARK
b32c						CALLMONITOR 
b32c cd 6f ee			call debug_vector  
b32f				endm  
# End of macro CALLMONITOR
b32f					endif 
b32f				; next item on the stack is the limit. get it 
b32f			 
b32f			 
b32f				FORTH_LOOP_POP 
b32f cd 31 9c			call macro_forth_loop_pop 
b332				endm 
# End of macro FORTH_LOOP_POP
b332			 
b332				FORTH_LOOP_TOS 
b332 cd 27 9c			call macro_forth_loop_tos 
b335				endm 
# End of macro FORTH_LOOP_TOS
b335			 
b335 d1				pop de		 ; de = i, hl = limit 
b336			 
b336					if DEBUG_FORTH_WORDS 
b336						DMARK "LP1" 
b336 f5				push af  
b337 3a 4b b3			ld a, (.dmark)  
b33a 32 62 ee			ld (debug_mark),a  
b33d 3a 4c b3			ld a, (.dmark+1)  
b340 32 63 ee			ld (debug_mark+1),a  
b343 3a 4d b3			ld a, (.dmark+2)  
b346 32 64 ee			ld (debug_mark+2),a  
b349 18 03			jr .pastdmark  
b34b ..			.dmark: db "LP1"  
b34e f1			.pastdmark: pop af  
b34f			endm  
# End of macro DMARK
b34f						CALLMONITOR 
b34f cd 6f ee			call debug_vector  
b352				endm  
# End of macro CALLMONITOR
b352					endif 
b352			 
b352				; go back to previous word 
b352			 
b352 d5				push de    ; save I for inc later 
b353			 
b353			 
b353				; get limit 
b353				;  is I at limit? 
b353			 
b353			 
b353					if DEBUG_FORTH_WORDS 
b353						DMARK "LP1" 
b353 f5				push af  
b354 3a 68 b3			ld a, (.dmark)  
b357 32 62 ee			ld (debug_mark),a  
b35a 3a 69 b3			ld a, (.dmark+1)  
b35d 32 63 ee			ld (debug_mark+1),a  
b360 3a 6a b3			ld a, (.dmark+2)  
b363 32 64 ee			ld (debug_mark+2),a  
b366 18 03			jr .pastdmark  
b368 ..			.dmark: db "LP1"  
b36b f1			.pastdmark: pop af  
b36c			endm  
# End of macro DMARK
b36c						CALLMONITOR 
b36c cd 6f ee			call debug_vector  
b36f				endm  
# End of macro CALLMONITOR
b36f					endif 
b36f			 
b36f ed 52			sbc hl, de 
b371			 
b371			 
b371				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b371			 
b371 20 29				jr nz, .loopnotdone 
b373			 
b373 e1				pop hl   ; get rid of saved I 
b374				FORTH_LOOP_POP     ; get rid of limit 
b374 cd 31 9c			call macro_forth_loop_pop 
b377				endm 
# End of macro FORTH_LOOP_POP
b377			 
b377				FORTH_RSP_POP     ; get rid of DO ptr 
b377 cd 8f 99			call macro_forth_rsp_pop 
b37a				endm 
# End of macro FORTH_RSP_POP
b37a			 
b37a			if DEBUG_FORTH_WORDS 
b37a						DMARK "LP>" 
b37a f5				push af  
b37b 3a 8f b3			ld a, (.dmark)  
b37e 32 62 ee			ld (debug_mark),a  
b381 3a 90 b3			ld a, (.dmark+1)  
b384 32 63 ee			ld (debug_mark+1),a  
b387 3a 91 b3			ld a, (.dmark+2)  
b38a 32 64 ee			ld (debug_mark+2),a  
b38d 18 03			jr .pastdmark  
b38f ..			.dmark: db "LP>"  
b392 f1			.pastdmark: pop af  
b393			endm  
# End of macro DMARK
b393				CALLMONITOR 
b393 cd 6f ee			call debug_vector  
b396				endm  
# End of macro CALLMONITOR
b396			endif 
b396			 
b396					NEXTW 
b396 cd 6c ee			call parse_vector 
b399 c3 aa 9d			jp macro_next 
b39c				endm 
# End of macro NEXTW
b39c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b39c			 
b39c			.loopnotdone: 
b39c			 
b39c e1				pop hl    ; get I 
b39d 23				inc hl 
b39e			 
b39e			   	; save new I 
b39e			 
b39e			 
b39e					; set I counter 
b39e			 
b39e 22 dd e5				ld (os_current_i), hl 
b3a1			 
b3a1					if DEBUG_FORTH_WORDS 
b3a1						DMARK "LPN" 
b3a1 f5				push af  
b3a2 3a b6 b3			ld a, (.dmark)  
b3a5 32 62 ee			ld (debug_mark),a  
b3a8 3a b7 b3			ld a, (.dmark+1)  
b3ab 32 63 ee			ld (debug_mark+1),a  
b3ae 3a b8 b3			ld a, (.dmark+2)  
b3b1 32 64 ee			ld (debug_mark+2),a  
b3b4 18 03			jr .pastdmark  
b3b6 ..			.dmark: db "LPN"  
b3b9 f1			.pastdmark: pop af  
b3ba			endm  
# End of macro DMARK
b3ba					CALLMONITOR 
b3ba cd 6f ee			call debug_vector  
b3bd				endm  
# End of macro CALLMONITOR
b3bd					endif 
b3bd					 
b3bd				FORTH_LOOP_NEXT 
b3bd cd f4 9b			call macro_forth_loop_next 
b3c0				endm 
# End of macro FORTH_LOOP_NEXT
b3c0			 
b3c0			 
b3c0					if DEBUG_FORTH_WORDS 
b3c0 eb						ex de,hl 
b3c1					endif 
b3c1			 
b3c1			;	; get DO ptr 
b3c1			; 
b3c1					if DEBUG_FORTH_WORDS 
b3c1						DMARK "LP7" 
b3c1 f5				push af  
b3c2 3a d6 b3			ld a, (.dmark)  
b3c5 32 62 ee			ld (debug_mark),a  
b3c8 3a d7 b3			ld a, (.dmark+1)  
b3cb 32 63 ee			ld (debug_mark+1),a  
b3ce 3a d8 b3			ld a, (.dmark+2)  
b3d1 32 64 ee			ld (debug_mark+2),a  
b3d4 18 03			jr .pastdmark  
b3d6 ..			.dmark: db "LP7"  
b3d9 f1			.pastdmark: pop af  
b3da			endm  
# End of macro DMARK
b3da					CALLMONITOR 
b3da cd 6f ee			call debug_vector  
b3dd				endm  
# End of macro CALLMONITOR
b3dd					endif 
b3dd				FORTH_RSP_TOS 
b3dd cd 85 99			call macro_forth_rsp_tos 
b3e0				endm 
# End of macro FORTH_RSP_TOS
b3e0			 
b3e0					if DEBUG_FORTH_WORDS 
b3e0						DMARK "LP8" 
b3e0 f5				push af  
b3e1 3a f5 b3			ld a, (.dmark)  
b3e4 32 62 ee			ld (debug_mark),a  
b3e7 3a f6 b3			ld a, (.dmark+1)  
b3ea 32 63 ee			ld (debug_mark+1),a  
b3ed 3a f7 b3			ld a, (.dmark+2)  
b3f0 32 64 ee			ld (debug_mark+2),a  
b3f3 18 03			jr .pastdmark  
b3f5 ..			.dmark: db "LP8"  
b3f8 f1			.pastdmark: pop af  
b3f9			endm  
# End of macro DMARK
b3f9					CALLMONITOR 
b3f9 cd 6f ee			call debug_vector  
b3fc				endm  
# End of macro CALLMONITOR
b3fc					endif 
b3fc				;push hl 
b3fc			 
b3fc				; not going to DO any more 
b3fc				; get rid of the RSP pointer as DO will add it back in 
b3fc				;FORTH_RSP_POP 
b3fc				;pop hl 
b3fc			 
b3fc				;ld hl,(cli_ret_sp) 
b3fc				;ld e, (hl) 
b3fc				;inc hl 
b3fc				;ld d, (hl) 
b3fc				;ex de,hl 
b3fc 22 b9 e5			ld (os_tok_ptr), hl 
b3ff					if DEBUG_FORTH_WORDS 
b3ff						DMARK "LP<" 
b3ff f5				push af  
b400 3a 14 b4			ld a, (.dmark)  
b403 32 62 ee			ld (debug_mark),a  
b406 3a 15 b4			ld a, (.dmark+1)  
b409 32 63 ee			ld (debug_mark+1),a  
b40c 3a 16 b4			ld a, (.dmark+2)  
b40f 32 64 ee			ld (debug_mark+2),a  
b412 18 03			jr .pastdmark  
b414 ..			.dmark: db "LP<"  
b417 f1			.pastdmark: pop af  
b418			endm  
# End of macro DMARK
b418					CALLMONITOR 
b418 cd 6f ee			call debug_vector  
b41b				endm  
# End of macro CALLMONITOR
b41b				endif 
b41b c3 2b 9e			jp exec1 
b41e			 
b41e					 
b41e			 
b41e			 
b41e					NEXTW 
b41e cd 6c ee			call parse_vector 
b421 c3 aa 9d			jp macro_next 
b424				endm 
# End of macro NEXTW
b424			.I:  
b424			 
b424				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b424 5e				db WORD_SYS_CORE+74             
b425 52 b4			dw .DLOOP            
b427 02				db 1 + 1 
b428 .. 00			db "I",0              
b42a				endm 
# End of macro CWHEAD
b42a			; | I ( -- ) Current loop counter | DONE 
b42a					if DEBUG_FORTH_WORDS_KEY 
b42a						DMARK "I.." 
b42a f5				push af  
b42b 3a 3f b4			ld a, (.dmark)  
b42e 32 62 ee			ld (debug_mark),a  
b431 3a 40 b4			ld a, (.dmark+1)  
b434 32 63 ee			ld (debug_mark+1),a  
b437 3a 41 b4			ld a, (.dmark+2)  
b43a 32 64 ee			ld (debug_mark+2),a  
b43d 18 03			jr .pastdmark  
b43f ..			.dmark: db "I.."  
b442 f1			.pastdmark: pop af  
b443			endm  
# End of macro DMARK
b443						CALLMONITOR 
b443 cd 6f ee			call debug_vector  
b446				endm  
# End of macro CALLMONITOR
b446					endif 
b446			 
b446 2a dd e5				ld hl,(os_current_i) 
b449 cd c7 99				call forth_push_numhl 
b44c			 
b44c					NEXTW 
b44c cd 6c ee			call parse_vector 
b44f c3 aa 9d			jp macro_next 
b452				endm 
# End of macro NEXTW
b452			.DLOOP: 
b452				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b452 5f				db WORD_SYS_CORE+75             
b453 39 b5			dw .REPEAT            
b455 06				db 5 + 1 
b456 .. 00			db "-LOOP",0              
b45c				endm 
# End of macro CWHEAD
b45c			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b45c				; pop tos as current loop count to hl 
b45c					if DEBUG_FORTH_WORDS_KEY 
b45c						DMARK "-LP" 
b45c f5				push af  
b45d 3a 71 b4			ld a, (.dmark)  
b460 32 62 ee			ld (debug_mark),a  
b463 3a 72 b4			ld a, (.dmark+1)  
b466 32 63 ee			ld (debug_mark+1),a  
b469 3a 73 b4			ld a, (.dmark+2)  
b46c 32 64 ee			ld (debug_mark+2),a  
b46f 18 03			jr .pastdmark  
b471 ..			.dmark: db "-LP"  
b474 f1			.pastdmark: pop af  
b475			endm  
# End of macro DMARK
b475						CALLMONITOR 
b475 cd 6f ee			call debug_vector  
b478				endm  
# End of macro CALLMONITOR
b478					endif 
b478			 
b478				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b478			 
b478				FORTH_LOOP_TOS 
b478 cd 27 9c			call macro_forth_loop_tos 
b47b				endm 
# End of macro FORTH_LOOP_TOS
b47b e5				push hl 
b47c			 
b47c					if DEBUG_FORTH_WORDS 
b47c						DMARK "-LP" 
b47c f5				push af  
b47d 3a 91 b4			ld a, (.dmark)  
b480 32 62 ee			ld (debug_mark),a  
b483 3a 92 b4			ld a, (.dmark+1)  
b486 32 63 ee			ld (debug_mark+1),a  
b489 3a 93 b4			ld a, (.dmark+2)  
b48c 32 64 ee			ld (debug_mark+2),a  
b48f 18 03			jr .pastdmark  
b491 ..			.dmark: db "-LP"  
b494 f1			.pastdmark: pop af  
b495			endm  
# End of macro DMARK
b495						CALLMONITOR 
b495 cd 6f ee			call debug_vector  
b498				endm  
# End of macro CALLMONITOR
b498					endif 
b498				; next item on the stack is the limit. get it 
b498			 
b498			 
b498				FORTH_LOOP_POP 
b498 cd 31 9c			call macro_forth_loop_pop 
b49b				endm 
# End of macro FORTH_LOOP_POP
b49b			 
b49b				FORTH_LOOP_TOS 
b49b cd 27 9c			call macro_forth_loop_tos 
b49e				endm 
# End of macro FORTH_LOOP_TOS
b49e			 
b49e d1				pop de		 ; de = i, hl = limit 
b49f			 
b49f					if DEBUG_FORTH_WORDS 
b49f						DMARK "-L1" 
b49f f5				push af  
b4a0 3a b4 b4			ld a, (.dmark)  
b4a3 32 62 ee			ld (debug_mark),a  
b4a6 3a b5 b4			ld a, (.dmark+1)  
b4a9 32 63 ee			ld (debug_mark+1),a  
b4ac 3a b6 b4			ld a, (.dmark+2)  
b4af 32 64 ee			ld (debug_mark+2),a  
b4b2 18 03			jr .pastdmark  
b4b4 ..			.dmark: db "-L1"  
b4b7 f1			.pastdmark: pop af  
b4b8			endm  
# End of macro DMARK
b4b8						CALLMONITOR 
b4b8 cd 6f ee			call debug_vector  
b4bb				endm  
# End of macro CALLMONITOR
b4bb					endif 
b4bb			 
b4bb				; go back to previous word 
b4bb			 
b4bb d5				push de    ; save I for inc later 
b4bc			 
b4bc			 
b4bc				; get limit 
b4bc				;  is I at limit? 
b4bc			 
b4bc			 
b4bc					if DEBUG_FORTH_WORDS 
b4bc						DMARK "-L1" 
b4bc f5				push af  
b4bd 3a d1 b4			ld a, (.dmark)  
b4c0 32 62 ee			ld (debug_mark),a  
b4c3 3a d2 b4			ld a, (.dmark+1)  
b4c6 32 63 ee			ld (debug_mark+1),a  
b4c9 3a d3 b4			ld a, (.dmark+2)  
b4cc 32 64 ee			ld (debug_mark+2),a  
b4cf 18 03			jr .pastdmark  
b4d1 ..			.dmark: db "-L1"  
b4d4 f1			.pastdmark: pop af  
b4d5			endm  
# End of macro DMARK
b4d5						CALLMONITOR 
b4d5 cd 6f ee			call debug_vector  
b4d8				endm  
# End of macro CALLMONITOR
b4d8					endif 
b4d8			 
b4d8 ed 52			sbc hl, de 
b4da			 
b4da			 
b4da				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b4da			 
b4da 20 29				jr nz, .mloopnotdone 
b4dc			 
b4dc e1				pop hl   ; get rid of saved I 
b4dd				FORTH_LOOP_POP     ; get rid of limit 
b4dd cd 31 9c			call macro_forth_loop_pop 
b4e0				endm 
# End of macro FORTH_LOOP_POP
b4e0			 
b4e0				FORTH_RSP_POP     ; get rid of DO ptr 
b4e0 cd 8f 99			call macro_forth_rsp_pop 
b4e3				endm 
# End of macro FORTH_RSP_POP
b4e3			 
b4e3			if DEBUG_FORTH_WORDS 
b4e3						DMARK "-L>" 
b4e3 f5				push af  
b4e4 3a f8 b4			ld a, (.dmark)  
b4e7 32 62 ee			ld (debug_mark),a  
b4ea 3a f9 b4			ld a, (.dmark+1)  
b4ed 32 63 ee			ld (debug_mark+1),a  
b4f0 3a fa b4			ld a, (.dmark+2)  
b4f3 32 64 ee			ld (debug_mark+2),a  
b4f6 18 03			jr .pastdmark  
b4f8 ..			.dmark: db "-L>"  
b4fb f1			.pastdmark: pop af  
b4fc			endm  
# End of macro DMARK
b4fc				CALLMONITOR 
b4fc cd 6f ee			call debug_vector  
b4ff				endm  
# End of macro CALLMONITOR
b4ff			endif 
b4ff			 
b4ff					NEXTW 
b4ff cd 6c ee			call parse_vector 
b502 c3 aa 9d			jp macro_next 
b505				endm 
# End of macro NEXTW
b505				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b505			 
b505			.mloopnotdone: 
b505			 
b505 e1				pop hl    ; get I 
b506 2b				dec hl 
b507			 
b507			   	; save new I 
b507			 
b507			 
b507					; set I counter 
b507			 
b507 22 dd e5				ld (os_current_i), hl 
b50a			 
b50a					 
b50a				FORTH_LOOP_NEXT 
b50a cd f4 9b			call macro_forth_loop_next 
b50d				endm 
# End of macro FORTH_LOOP_NEXT
b50d			 
b50d			 
b50d					if DEBUG_FORTH_WORDS 
b50d eb						ex de,hl 
b50e					endif 
b50e			 
b50e			;	; get DO ptr 
b50e			; 
b50e				FORTH_RSP_TOS 
b50e cd 85 99			call macro_forth_rsp_tos 
b511				endm 
# End of macro FORTH_RSP_TOS
b511			 
b511				;push hl 
b511			 
b511				; not going to DO any more 
b511				; get rid of the RSP pointer as DO will add it back in 
b511				;FORTH_RSP_POP 
b511				;pop hl 
b511			 
b511			 
b511 22 b9 e5			ld (os_tok_ptr), hl 
b514					if DEBUG_FORTH_WORDS 
b514						DMARK "-L<" 
b514 f5				push af  
b515 3a 29 b5			ld a, (.dmark)  
b518 32 62 ee			ld (debug_mark),a  
b51b 3a 2a b5			ld a, (.dmark+1)  
b51e 32 63 ee			ld (debug_mark+1),a  
b521 3a 2b b5			ld a, (.dmark+2)  
b524 32 64 ee			ld (debug_mark+2),a  
b527 18 03			jr .pastdmark  
b529 ..			.dmark: db "-L<"  
b52c f1			.pastdmark: pop af  
b52d			endm  
# End of macro DMARK
b52d					CALLMONITOR 
b52d cd 6f ee			call debug_vector  
b530				endm  
# End of macro CALLMONITOR
b530				endif 
b530 c3 2b 9e			jp exec1 
b533			 
b533					 
b533			 
b533			 
b533			 
b533				NEXTW 
b533 cd 6c ee			call parse_vector 
b536 c3 aa 9d			jp macro_next 
b539				endm 
# End of macro NEXTW
b539			 
b539			 
b539			 
b539			 
b539			.REPEAT: 
b539				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b539 71				db WORD_SYS_CORE+93             
b53a 8f b5			dw .UNTIL            
b53c 06				db 5 + 1 
b53d .. 00			db "REPEAT",0              
b544				endm 
# End of macro CWHEAD
b544			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b544			;  push pc to rsp stack past the REPEAT 
b544					if DEBUG_FORTH_WORDS_KEY 
b544						DMARK "REP" 
b544 f5				push af  
b545 3a 59 b5			ld a, (.dmark)  
b548 32 62 ee			ld (debug_mark),a  
b54b 3a 5a b5			ld a, (.dmark+1)  
b54e 32 63 ee			ld (debug_mark+1),a  
b551 3a 5b b5			ld a, (.dmark+2)  
b554 32 64 ee			ld (debug_mark+2),a  
b557 18 03			jr .pastdmark  
b559 ..			.dmark: db "REP"  
b55c f1			.pastdmark: pop af  
b55d			endm  
# End of macro DMARK
b55d						CALLMONITOR 
b55d cd 6f ee			call debug_vector  
b560				endm  
# End of macro CALLMONITOR
b560					endif 
b560			 
b560 2a b9 e5				ld hl, (os_tok_ptr) 
b563 23					inc hl   ; R 
b564 23					inc hl  ; E 
b565 23					inc hl   ; P 
b566 23					inc hl   ; E 
b567 23					inc hl   ; A 
b568 23					inc hl   ; T 
b569 23					inc hl   ; zero 
b56a					FORTH_RSP_NEXT 
b56a cd 6e 99			call macro_forth_rsp_next 
b56d				endm 
# End of macro FORTH_RSP_NEXT
b56d			 
b56d			 
b56d					if DEBUG_FORTH_WORDS 
b56d						DMARK "REP" 
b56d f5				push af  
b56e 3a 82 b5			ld a, (.dmark)  
b571 32 62 ee			ld (debug_mark),a  
b574 3a 83 b5			ld a, (.dmark+1)  
b577 32 63 ee			ld (debug_mark+1),a  
b57a 3a 84 b5			ld a, (.dmark+2)  
b57d 32 64 ee			ld (debug_mark+2),a  
b580 18 03			jr .pastdmark  
b582 ..			.dmark: db "REP"  
b585 f1			.pastdmark: pop af  
b586			endm  
# End of macro DMARK
b586						;pop bc    ; TODO BUG ?????? what is this for???? 
b586						CALLMONITOR 
b586 cd 6f ee			call debug_vector  
b589				endm  
# End of macro CALLMONITOR
b589					endif 
b589			 
b589					NEXTW 
b589 cd 6c ee			call parse_vector 
b58c c3 aa 9d			jp macro_next 
b58f				endm 
# End of macro NEXTW
b58f			;	       NEXTW 
b58f			 
b58f			.UNTIL: 
b58f				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b58f 72				db WORD_SYS_CORE+94             
b590 2c b6			dw .ENDFLOW            
b592 06				db 5 + 1 
b593 .. 00			db "UNTIL",0              
b599				endm 
# End of macro CWHEAD
b599			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b599			 
b599				; pop tos as check 
b599			 
b599				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b599			 
b599				FORTH_DSP_VALUEHL 
b599 cd c3 9b			call macro_dsp_valuehl 
b59c				endm 
# End of macro FORTH_DSP_VALUEHL
b59c			 
b59c					if DEBUG_FORTH_WORDS_KEY 
b59c						DMARK "UNT" 
b59c f5				push af  
b59d 3a b1 b5			ld a, (.dmark)  
b5a0 32 62 ee			ld (debug_mark),a  
b5a3 3a b2 b5			ld a, (.dmark+1)  
b5a6 32 63 ee			ld (debug_mark+1),a  
b5a9 3a b3 b5			ld a, (.dmark+2)  
b5ac 32 64 ee			ld (debug_mark+2),a  
b5af 18 03			jr .pastdmark  
b5b1 ..			.dmark: db "UNT"  
b5b4 f1			.pastdmark: pop af  
b5b5			endm  
# End of macro DMARK
b5b5						CALLMONITOR 
b5b5 cd 6f ee			call debug_vector  
b5b8				endm  
# End of macro CALLMONITOR
b5b8					endif 
b5b8			 
b5b8			;	push hl 
b5b8				FORTH_DSP_POP 
b5b8 cd 7b 9c			call macro_forth_dsp_pop 
b5bb				endm 
# End of macro FORTH_DSP_POP
b5bb			 
b5bb			;	pop hl 
b5bb			 
b5bb				; test if true 
b5bb			 
b5bb cd ff 8c			call ishlzero 
b5be			;	ld a,l 
b5be			;	add h 
b5be			; 
b5be			;	cp 0 
b5be			 
b5be 20 41			jr nz, .untilnotdone 
b5c0			 
b5c0					if DEBUG_FORTH_WORDS 
b5c0						DMARK "UNf" 
b5c0 f5				push af  
b5c1 3a d5 b5			ld a, (.dmark)  
b5c4 32 62 ee			ld (debug_mark),a  
b5c7 3a d6 b5			ld a, (.dmark+1)  
b5ca 32 63 ee			ld (debug_mark+1),a  
b5cd 3a d7 b5			ld a, (.dmark+2)  
b5d0 32 64 ee			ld (debug_mark+2),a  
b5d3 18 03			jr .pastdmark  
b5d5 ..			.dmark: db "UNf"  
b5d8 f1			.pastdmark: pop af  
b5d9			endm  
# End of macro DMARK
b5d9						CALLMONITOR 
b5d9 cd 6f ee			call debug_vector  
b5dc				endm  
# End of macro CALLMONITOR
b5dc					endif 
b5dc			 
b5dc			 
b5dc			 
b5dc				FORTH_RSP_POP     ; get rid of DO ptr 
b5dc cd 8f 99			call macro_forth_rsp_pop 
b5df				endm 
# End of macro FORTH_RSP_POP
b5df			 
b5df			if DEBUG_FORTH_WORDS 
b5df						DMARK "UN>" 
b5df f5				push af  
b5e0 3a f4 b5			ld a, (.dmark)  
b5e3 32 62 ee			ld (debug_mark),a  
b5e6 3a f5 b5			ld a, (.dmark+1)  
b5e9 32 63 ee			ld (debug_mark+1),a  
b5ec 3a f6 b5			ld a, (.dmark+2)  
b5ef 32 64 ee			ld (debug_mark+2),a  
b5f2 18 03			jr .pastdmark  
b5f4 ..			.dmark: db "UN>"  
b5f7 f1			.pastdmark: pop af  
b5f8			endm  
# End of macro DMARK
b5f8				CALLMONITOR 
b5f8 cd 6f ee			call debug_vector  
b5fb				endm  
# End of macro CALLMONITOR
b5fb			endif 
b5fb			 
b5fb					NEXTW 
b5fb cd 6c ee			call parse_vector 
b5fe c3 aa 9d			jp macro_next 
b601				endm 
# End of macro NEXTW
b601				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b601			 
b601			.untilnotdone: 
b601			 
b601			 
b601			;	; get DO ptr 
b601			; 
b601				FORTH_RSP_TOS 
b601 cd 85 99			call macro_forth_rsp_tos 
b604				endm 
# End of macro FORTH_RSP_TOS
b604			 
b604				;push hl 
b604			 
b604				; not going to DO any more 
b604				; get rid of the RSP pointer as DO will add it back in 
b604				;FORTH_RSP_POP 
b604				;pop hl 
b604			 
b604			 
b604 22 b9 e5			ld (os_tok_ptr), hl 
b607					if DEBUG_FORTH_WORDS 
b607						DMARK "UN<" 
b607 f5				push af  
b608 3a 1c b6			ld a, (.dmark)  
b60b 32 62 ee			ld (debug_mark),a  
b60e 3a 1d b6			ld a, (.dmark+1)  
b611 32 63 ee			ld (debug_mark+1),a  
b614 3a 1e b6			ld a, (.dmark+2)  
b617 32 64 ee			ld (debug_mark+2),a  
b61a 18 03			jr .pastdmark  
b61c ..			.dmark: db "UN<"  
b61f f1			.pastdmark: pop af  
b620			endm  
# End of macro DMARK
b620					CALLMONITOR 
b620 cd 6f ee			call debug_vector  
b623				endm  
# End of macro CALLMONITOR
b623				endif 
b623 c3 2b 9e			jp exec1 
b626			 
b626					 
b626			 
b626			 
b626					NEXTW 
b626 cd 6c ee			call parse_vector 
b629 c3 aa 9d			jp macro_next 
b62c				endm 
# End of macro NEXTW
b62c			 
b62c			 
b62c			.ENDFLOW: 
b62c			 
b62c			; eof 
b62c			 
# End of file forth_words_flow.asm
b62c			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b62c			include "forth_words_logic.asm" 
b62c			 
b62c			; | ## Logic Words 
b62c			 
b62c			.NOT: 
b62c				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b62c 2d				db WORD_SYS_CORE+25             
b62d 7a b6			dw .IS            
b62f 04				db 3 + 1 
b630 .. 00			db "NOT",0              
b634				endm 
# End of macro CWHEAD
b634			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b634					if DEBUG_FORTH_WORDS_KEY 
b634						DMARK "NOT" 
b634 f5				push af  
b635 3a 49 b6			ld a, (.dmark)  
b638 32 62 ee			ld (debug_mark),a  
b63b 3a 4a b6			ld a, (.dmark+1)  
b63e 32 63 ee			ld (debug_mark+1),a  
b641 3a 4b b6			ld a, (.dmark+2)  
b644 32 64 ee			ld (debug_mark+2),a  
b647 18 03			jr .pastdmark  
b649 ..			.dmark: db "NOT"  
b64c f1			.pastdmark: pop af  
b64d			endm  
# End of macro DMARK
b64d						CALLMONITOR 
b64d cd 6f ee			call debug_vector  
b650				endm  
# End of macro CALLMONITOR
b650					endif 
b650					FORTH_DSP 
b650 cd 89 9b			call macro_forth_dsp 
b653				endm 
# End of macro FORTH_DSP
b653 7e					ld a,(hl)	; get type of value on TOS 
b654 fe 02				cp DS_TYPE_INUM  
b656 28 06				jr z, .noti 
b658					NEXTW 
b658 cd 6c ee			call parse_vector 
b65b c3 aa 9d			jp macro_next 
b65e				endm 
# End of macro NEXTW
b65e			.noti:          FORTH_DSP_VALUEHL 
b65e cd c3 9b			call macro_dsp_valuehl 
b661				endm 
# End of macro FORTH_DSP_VALUEHL
b661			;		push hl 
b661					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b661 cd 7b 9c			call macro_forth_dsp_pop 
b664				endm 
# End of macro FORTH_DSP_POP
b664			;		pop hl 
b664 3e 00				ld a,0 
b666 bd					cp l 
b667 28 04				jr z, .not2t 
b669 2e 00				ld l, 0 
b66b 18 02				jr .notip 
b66d			 
b66d 2e ff		.not2t:		ld l, 255 
b66f			 
b66f 26 00		.notip:		ld h, 0	 
b671			 
b671 cd c7 99				call forth_push_numhl 
b674					NEXTW 
b674 cd 6c ee			call parse_vector 
b677 c3 aa 9d			jp macro_next 
b67a				endm 
# End of macro NEXTW
b67a			 
b67a			.IS: 
b67a				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
b67a 2d				db WORD_SYS_CORE+25             
b67b be b6			dw .LZERO            
b67d 08				db 7 + 1 
b67e .. 00			db "COMPARE",0              
b686				endm 
# End of macro CWHEAD
b686			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
b686					if DEBUG_FORTH_WORDS_KEY 
b686						DMARK "CMP" 
b686 f5				push af  
b687 3a 9b b6			ld a, (.dmark)  
b68a 32 62 ee			ld (debug_mark),a  
b68d 3a 9c b6			ld a, (.dmark+1)  
b690 32 63 ee			ld (debug_mark+1),a  
b693 3a 9d b6			ld a, (.dmark+2)  
b696 32 64 ee			ld (debug_mark+2),a  
b699 18 03			jr .pastdmark  
b69b ..			.dmark: db "CMP"  
b69e f1			.pastdmark: pop af  
b69f			endm  
# End of macro DMARK
b69f						CALLMONITOR 
b69f cd 6f ee			call debug_vector  
b6a2				endm  
# End of macro CALLMONITOR
b6a2					endif 
b6a2			 
b6a2					FORTH_DSP_VALUEHL 
b6a2 cd c3 9b			call macro_dsp_valuehl 
b6a5				endm 
# End of macro FORTH_DSP_VALUEHL
b6a5			 
b6a5 e5					push hl 
b6a6			 
b6a6					FORTH_DSP_VALUEM1 
b6a6 cd b7 9b			call macro_forth_dsp_value_m1 
b6a9				endm 
# End of macro FORTH_DSP_VALUEM1
b6a9			 
b6a9 d1					pop de 
b6aa			 
b6aa					; got pointers to both. Now check. 
b6aa			 
b6aa cd 66 90				call strcmp 
b6ad				 
b6ad 26 00				ld h, 0 
b6af 2e 00				ld l, 0 
b6b1 20 02				jr nz, .compnsame 
b6b3 2e 01				ld l, 1	 
b6b5			.compnsame: 
b6b5 cd c7 99				call forth_push_numhl 
b6b8			 
b6b8					NEXTW 
b6b8 cd 6c ee			call parse_vector 
b6bb c3 aa 9d			jp macro_next 
b6be				endm 
# End of macro NEXTW
b6be			.LZERO: 
b6be				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b6be 2d				db WORD_SYS_CORE+25             
b6bf cb b6			dw .TZERO            
b6c1 03				db 2 + 1 
b6c2 .. 00			db "0<",0              
b6c5				endm 
# End of macro CWHEAD
b6c5			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b6c5					NEXTW 
b6c5 cd 6c ee			call parse_vector 
b6c8 c3 aa 9d			jp macro_next 
b6cb				endm 
# End of macro NEXTW
b6cb			.TZERO: 
b6cb				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b6cb 2e				db WORD_SYS_CORE+26             
b6cc 15 b7			dw .LESS            
b6ce 03				db 2 + 1 
b6cf .. 00			db "0=",0              
b6d2				endm 
# End of macro CWHEAD
b6d2			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b6d2				; TODO add floating point number detection 
b6d2					;v5 FORTH_DSP_VALUE 
b6d2					if DEBUG_FORTH_WORDS_KEY 
b6d2						DMARK "0=." 
b6d2 f5				push af  
b6d3 3a e7 b6			ld a, (.dmark)  
b6d6 32 62 ee			ld (debug_mark),a  
b6d9 3a e8 b6			ld a, (.dmark+1)  
b6dc 32 63 ee			ld (debug_mark+1),a  
b6df 3a e9 b6			ld a, (.dmark+2)  
b6e2 32 64 ee			ld (debug_mark+2),a  
b6e5 18 03			jr .pastdmark  
b6e7 ..			.dmark: db "0=."  
b6ea f1			.pastdmark: pop af  
b6eb			endm  
# End of macro DMARK
b6eb						CALLMONITOR 
b6eb cd 6f ee			call debug_vector  
b6ee				endm  
# End of macro CALLMONITOR
b6ee					endif 
b6ee					FORTH_DSP 
b6ee cd 89 9b			call macro_forth_dsp 
b6f1				endm 
# End of macro FORTH_DSP
b6f1 7e					ld a,(hl)	; get type of value on TOS 
b6f2 fe 02				cp DS_TYPE_INUM  
b6f4 28 00				jr z, .tz_inum 
b6f6			 
b6f6				if FORTH_ENABLE_FLOATMATH 
b6f6					jr .tz_done 
b6f6			 
b6f6				endif 
b6f6					 
b6f6			 
b6f6			.tz_inum: 
b6f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6f6 cd c3 9b			call macro_dsp_valuehl 
b6f9				endm 
# End of macro FORTH_DSP_VALUEHL
b6f9			 
b6f9			;		push hl 
b6f9			 
b6f9					; destroy value TOS 
b6f9			 
b6f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6f9 cd 7b 9c			call macro_forth_dsp_pop 
b6fc				endm 
# End of macro FORTH_DSP_POP
b6fc			 
b6fc			;		pop hl 
b6fc			 
b6fc 3e 00				ld a,0 
b6fe			 
b6fe bd					cp l 
b6ff 20 08				jr nz, .tz_notzero 
b701			 
b701 bc					cp h 
b702			 
b702 20 05				jr nz, .tz_notzero 
b704			 
b704			 
b704 21 01 00				ld hl, FORTH_TRUE 
b707 18 03				jr .tz_done 
b709			 
b709 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b70c			 
b70c					; push value back onto stack for another op etc 
b70c			 
b70c			.tz_done: 
b70c cd c7 99				call forth_push_numhl 
b70f			 
b70f					NEXTW 
b70f cd 6c ee			call parse_vector 
b712 c3 aa 9d			jp macro_next 
b715				endm 
# End of macro NEXTW
b715			.LESS: 
b715				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b715 2f				db WORD_SYS_CORE+27             
b716 81 b7			dw .GT            
b718 02				db 1 + 1 
b719 .. 00			db "<",0              
b71b				endm 
# End of macro CWHEAD
b71b			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b71b				; TODO add floating point number detection 
b71b					if DEBUG_FORTH_WORDS_KEY 
b71b						DMARK "LES" 
b71b f5				push af  
b71c 3a 30 b7			ld a, (.dmark)  
b71f 32 62 ee			ld (debug_mark),a  
b722 3a 31 b7			ld a, (.dmark+1)  
b725 32 63 ee			ld (debug_mark+1),a  
b728 3a 32 b7			ld a, (.dmark+2)  
b72b 32 64 ee			ld (debug_mark+2),a  
b72e 18 03			jr .pastdmark  
b730 ..			.dmark: db "LES"  
b733 f1			.pastdmark: pop af  
b734			endm  
# End of macro DMARK
b734						CALLMONITOR 
b734 cd 6f ee			call debug_vector  
b737				endm  
# End of macro CALLMONITOR
b737					endif 
b737					FORTH_DSP 
b737 cd 89 9b			call macro_forth_dsp 
b73a				endm 
# End of macro FORTH_DSP
b73a					;v5 FORTH_DSP_VALUE 
b73a 7e					ld a,(hl)	; get type of value on TOS 
b73b fe 02				cp DS_TYPE_INUM  
b73d 28 00				jr z, .less_inum 
b73f			 
b73f				if FORTH_ENABLE_FLOATMATH 
b73f					jr .less_done 
b73f			 
b73f				endif 
b73f					 
b73f			 
b73f			.less_inum: 
b73f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b73f cd c3 9b			call macro_dsp_valuehl 
b742				endm 
# End of macro FORTH_DSP_VALUEHL
b742			 
b742 e5					push hl  ; u2 
b743			 
b743					; destroy value TOS 
b743			 
b743					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b743 cd 7b 9c			call macro_forth_dsp_pop 
b746				endm 
# End of macro FORTH_DSP_POP
b746			 
b746			 
b746					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b746 cd c3 9b			call macro_dsp_valuehl 
b749				endm 
# End of macro FORTH_DSP_VALUEHL
b749			 
b749 e5					push hl    ; u1 
b74a			 
b74a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b74a cd 7b 9c			call macro_forth_dsp_pop 
b74d				endm 
# End of macro FORTH_DSP_POP
b74d			 
b74d			 
b74d b7			 or a      ;clear carry flag 
b74e 01 00 00		 ld bc, FORTH_FALSE 
b751 e1			  pop hl    ; u1 
b752 d1			  pop de    ; u2 
b753 ed 52		  sbc hl,de 
b755 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b757			 
b757 01 01 00		 ld bc, FORTH_TRUE 
b75a			.lscont:  
b75a c5					push bc 
b75b e1					pop hl 
b75c			 
b75c					if DEBUG_FORTH_WORDS 
b75c						DMARK "LT1" 
b75c f5				push af  
b75d 3a 71 b7			ld a, (.dmark)  
b760 32 62 ee			ld (debug_mark),a  
b763 3a 72 b7			ld a, (.dmark+1)  
b766 32 63 ee			ld (debug_mark+1),a  
b769 3a 73 b7			ld a, (.dmark+2)  
b76c 32 64 ee			ld (debug_mark+2),a  
b76f 18 03			jr .pastdmark  
b771 ..			.dmark: db "LT1"  
b774 f1			.pastdmark: pop af  
b775			endm  
# End of macro DMARK
b775						CALLMONITOR 
b775 cd 6f ee			call debug_vector  
b778				endm  
# End of macro CALLMONITOR
b778					endif 
b778 cd c7 99				call forth_push_numhl 
b77b			 
b77b					NEXTW 
b77b cd 6c ee			call parse_vector 
b77e c3 aa 9d			jp macro_next 
b781				endm 
# End of macro NEXTW
b781			.GT: 
b781				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b781 30				db WORD_SYS_CORE+28             
b782 ed b7			dw .EQUAL            
b784 02				db 1 + 1 
b785 .. 00			db ">",0              
b787				endm 
# End of macro CWHEAD
b787			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b787				; TODO add floating point number detection 
b787					if DEBUG_FORTH_WORDS_KEY 
b787						DMARK "GRT" 
b787 f5				push af  
b788 3a 9c b7			ld a, (.dmark)  
b78b 32 62 ee			ld (debug_mark),a  
b78e 3a 9d b7			ld a, (.dmark+1)  
b791 32 63 ee			ld (debug_mark+1),a  
b794 3a 9e b7			ld a, (.dmark+2)  
b797 32 64 ee			ld (debug_mark+2),a  
b79a 18 03			jr .pastdmark  
b79c ..			.dmark: db "GRT"  
b79f f1			.pastdmark: pop af  
b7a0			endm  
# End of macro DMARK
b7a0						CALLMONITOR 
b7a0 cd 6f ee			call debug_vector  
b7a3				endm  
# End of macro CALLMONITOR
b7a3					endif 
b7a3					FORTH_DSP 
b7a3 cd 89 9b			call macro_forth_dsp 
b7a6				endm 
# End of macro FORTH_DSP
b7a6					;FORTH_DSP_VALUE 
b7a6 7e					ld a,(hl)	; get type of value on TOS 
b7a7 fe 02				cp DS_TYPE_INUM  
b7a9 28 00				jr z, .gt_inum 
b7ab			 
b7ab				if FORTH_ENABLE_FLOATMATH 
b7ab					jr .gt_done 
b7ab			 
b7ab				endif 
b7ab					 
b7ab			 
b7ab			.gt_inum: 
b7ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7ab cd c3 9b			call macro_dsp_valuehl 
b7ae				endm 
# End of macro FORTH_DSP_VALUEHL
b7ae			 
b7ae e5					push hl  ; u2 
b7af			 
b7af					; destroy value TOS 
b7af			 
b7af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7af cd 7b 9c			call macro_forth_dsp_pop 
b7b2				endm 
# End of macro FORTH_DSP_POP
b7b2			 
b7b2			 
b7b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7b2 cd c3 9b			call macro_dsp_valuehl 
b7b5				endm 
# End of macro FORTH_DSP_VALUEHL
b7b5			 
b7b5 e5					push hl    ; u1 
b7b6			 
b7b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7b6 cd 7b 9c			call macro_forth_dsp_pop 
b7b9				endm 
# End of macro FORTH_DSP_POP
b7b9			 
b7b9			 
b7b9 b7			 or a      ;clear carry flag 
b7ba 01 00 00		 ld bc, FORTH_FALSE 
b7bd e1			  pop hl    ; u1 
b7be d1			  pop de    ; u2 
b7bf ed 52		  sbc hl,de 
b7c1 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b7c3			 
b7c3 01 01 00		 ld bc, FORTH_TRUE 
b7c6			.gtcont:  
b7c6 c5					push bc 
b7c7 e1					pop hl 
b7c8			 
b7c8					if DEBUG_FORTH_WORDS 
b7c8						DMARK "GT1" 
b7c8 f5				push af  
b7c9 3a dd b7			ld a, (.dmark)  
b7cc 32 62 ee			ld (debug_mark),a  
b7cf 3a de b7			ld a, (.dmark+1)  
b7d2 32 63 ee			ld (debug_mark+1),a  
b7d5 3a df b7			ld a, (.dmark+2)  
b7d8 32 64 ee			ld (debug_mark+2),a  
b7db 18 03			jr .pastdmark  
b7dd ..			.dmark: db "GT1"  
b7e0 f1			.pastdmark: pop af  
b7e1			endm  
# End of macro DMARK
b7e1						CALLMONITOR 
b7e1 cd 6f ee			call debug_vector  
b7e4				endm  
# End of macro CALLMONITOR
b7e4					endif 
b7e4 cd c7 99				call forth_push_numhl 
b7e7			 
b7e7					NEXTW 
b7e7 cd 6c ee			call parse_vector 
b7ea c3 aa 9d			jp macro_next 
b7ed				endm 
# End of macro NEXTW
b7ed			.EQUAL: 
b7ed				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b7ed 31				db WORD_SYS_CORE+29             
b7ee 5b b8			dw .ENDLOGIC            
b7f0 02				db 1 + 1 
b7f1 .. 00			db "=",0              
b7f3				endm 
# End of macro CWHEAD
b7f3			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b7f3				; TODO add floating point number detection 
b7f3					if DEBUG_FORTH_WORDS_KEY 
b7f3						DMARK "EQ." 
b7f3 f5				push af  
b7f4 3a 08 b8			ld a, (.dmark)  
b7f7 32 62 ee			ld (debug_mark),a  
b7fa 3a 09 b8			ld a, (.dmark+1)  
b7fd 32 63 ee			ld (debug_mark+1),a  
b800 3a 0a b8			ld a, (.dmark+2)  
b803 32 64 ee			ld (debug_mark+2),a  
b806 18 03			jr .pastdmark  
b808 ..			.dmark: db "EQ."  
b80b f1			.pastdmark: pop af  
b80c			endm  
# End of macro DMARK
b80c						CALLMONITOR 
b80c cd 6f ee			call debug_vector  
b80f				endm  
# End of macro CALLMONITOR
b80f					endif 
b80f					FORTH_DSP 
b80f cd 89 9b			call macro_forth_dsp 
b812				endm 
# End of macro FORTH_DSP
b812					;v5 FORTH_DSP_VALUE 
b812 7e					ld a,(hl)	; get type of value on TOS 
b813 fe 02				cp DS_TYPE_INUM  
b815 28 00				jr z, .eq_inum 
b817			 
b817				if FORTH_ENABLE_FLOATMATH 
b817					jr .eq_done 
b817			 
b817				endif 
b817					 
b817			 
b817			.eq_inum: 
b817					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b817 cd c3 9b			call macro_dsp_valuehl 
b81a				endm 
# End of macro FORTH_DSP_VALUEHL
b81a			 
b81a e5					push hl 
b81b			 
b81b					; destroy value TOS 
b81b			 
b81b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b81b cd 7b 9c			call macro_forth_dsp_pop 
b81e				endm 
# End of macro FORTH_DSP_POP
b81e			 
b81e			 
b81e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b81e cd c3 9b			call macro_dsp_valuehl 
b821				endm 
# End of macro FORTH_DSP_VALUEHL
b821			 
b821					; one value on hl get other one back 
b821			 
b821 e5					push hl 
b822			 
b822					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b822 cd 7b 9c			call macro_forth_dsp_pop 
b825				endm 
# End of macro FORTH_DSP_POP
b825			 
b825 0e 00				ld c, FORTH_FALSE 
b827			 
b827 e1					pop hl 
b828 d1					pop de 
b829			 
b829 7b					ld a, e 
b82a bd					cp l 
b82b			 
b82b 20 06				jr nz, .eq_done 
b82d			 
b82d 7a					ld a, d 
b82e bc					cp h 
b82f			 
b82f 20 02				jr nz, .eq_done 
b831			 
b831 0e 01				ld c, FORTH_TRUE 
b833					 
b833			 
b833			 
b833			.eq_done: 
b833			 
b833					; TODO push value back onto stack for another op etc 
b833			 
b833 26 00				ld h, 0 
b835 69					ld l, c 
b836					if DEBUG_FORTH_WORDS 
b836						DMARK "EQ1" 
b836 f5				push af  
b837 3a 4b b8			ld a, (.dmark)  
b83a 32 62 ee			ld (debug_mark),a  
b83d 3a 4c b8			ld a, (.dmark+1)  
b840 32 63 ee			ld (debug_mark+1),a  
b843 3a 4d b8			ld a, (.dmark+2)  
b846 32 64 ee			ld (debug_mark+2),a  
b849 18 03			jr .pastdmark  
b84b ..			.dmark: db "EQ1"  
b84e f1			.pastdmark: pop af  
b84f			endm  
# End of macro DMARK
b84f						CALLMONITOR 
b84f cd 6f ee			call debug_vector  
b852				endm  
# End of macro CALLMONITOR
b852					endif 
b852 cd c7 99				call forth_push_numhl 
b855			 
b855					NEXTW 
b855 cd 6c ee			call parse_vector 
b858 c3 aa 9d			jp macro_next 
b85b				endm 
# End of macro NEXTW
b85b			 
b85b			 
b85b			.ENDLOGIC: 
b85b			; eof 
b85b			 
b85b			 
# End of file forth_words_logic.asm
b85b			include "forth_words_maths.asm" 
b85b			 
b85b			; | ## Maths Words 
b85b			 
b85b			.PLUS:	 
b85b				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b85b 15				db WORD_SYS_CORE+1             
b85c bf b8			dw .NEG            
b85e 02				db 1 + 1 
b85f .. 00			db "+",0              
b861				endm 
# End of macro CWHEAD
b861			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b861					if DEBUG_FORTH_WORDS_KEY 
b861						DMARK "PLU" 
b861 f5				push af  
b862 3a 76 b8			ld a, (.dmark)  
b865 32 62 ee			ld (debug_mark),a  
b868 3a 77 b8			ld a, (.dmark+1)  
b86b 32 63 ee			ld (debug_mark+1),a  
b86e 3a 78 b8			ld a, (.dmark+2)  
b871 32 64 ee			ld (debug_mark+2),a  
b874 18 03			jr .pastdmark  
b876 ..			.dmark: db "PLU"  
b879 f1			.pastdmark: pop af  
b87a			endm  
# End of macro DMARK
b87a						CALLMONITOR 
b87a cd 6f ee			call debug_vector  
b87d				endm  
# End of macro CALLMONITOR
b87d					endif 
b87d					; add top two values and push back result 
b87d			 
b87d					;for v5 FORTH_DSP_VALUE 
b87d					FORTH_DSP 
b87d cd 89 9b			call macro_forth_dsp 
b880				endm 
# End of macro FORTH_DSP
b880 7e					ld a,(hl)	; get type of value on TOS 
b881 fe 02				cp DS_TYPE_INUM  
b883 28 06				jr z, .dot_inum 
b885			 
b885					NEXTW 
b885 cd 6c ee			call parse_vector 
b888 c3 aa 9d			jp macro_next 
b88b				endm 
# End of macro NEXTW
b88b			 
b88b			; float maths 
b88b			 
b88b				if FORTH_ENABLE_FLOATMATH 
b88b						inc hl      ; now at start of numeric as string 
b88b			 
b88b					if DEBUG_FORTH_MATHS 
b88b						DMARK "ADD" 
b88b				CALLMONITOR 
b88b					endif 
b88b			 
b88b					;ld ix, hl 
b88b					call CON 
b88b			 
b88b			 
b88b					push hl 
b88b					 
b88b					 
b88b			 
b88b						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b88b			 
b88b					; get next number 
b88b			 
b88b						FORTH_DSP_VALUE 
b88b			 
b88b						inc hl      ; now at start of numeric as string 
b88b			 
b88b					;ld ix, hl 
b88b					call CON 
b88b			 
b88b					push hl 
b88b			 
b88b			 
b88b						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b88b			 
b88b						; TODO do add 
b88b			 
b88b						call IADD 
b88b			 
b88b						; TODO get result back as ascii 
b88b			 
b88b						; TODO push result  
b88b			 
b88b			 
b88b			 
b88b						jr .dot_done 
b88b				endif 
b88b			 
b88b			.dot_inum: 
b88b			 
b88b			 
b88b					if DEBUG_FORTH_DOT 
b88b						DMARK "+IT" 
b88b f5				push af  
b88c 3a a0 b8			ld a, (.dmark)  
b88f 32 62 ee			ld (debug_mark),a  
b892 3a a1 b8			ld a, (.dmark+1)  
b895 32 63 ee			ld (debug_mark+1),a  
b898 3a a2 b8			ld a, (.dmark+2)  
b89b 32 64 ee			ld (debug_mark+2),a  
b89e 18 03			jr .pastdmark  
b8a0 ..			.dmark: db "+IT"  
b8a3 f1			.pastdmark: pop af  
b8a4			endm  
# End of macro DMARK
b8a4				CALLMONITOR 
b8a4 cd 6f ee			call debug_vector  
b8a7				endm  
# End of macro CALLMONITOR
b8a7					endif 
b8a7			 
b8a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8a7 cd c3 9b			call macro_dsp_valuehl 
b8aa				endm 
# End of macro FORTH_DSP_VALUEHL
b8aa			 
b8aa				; TODO add floating point number detection 
b8aa			 
b8aa e5					push hl 
b8ab			 
b8ab					; destroy value TOS 
b8ab			 
b8ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8ab cd 7b 9c			call macro_forth_dsp_pop 
b8ae				endm 
# End of macro FORTH_DSP_POP
b8ae			 
b8ae			 
b8ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8ae cd c3 9b			call macro_dsp_valuehl 
b8b1				endm 
# End of macro FORTH_DSP_VALUEHL
b8b1			 
b8b1					; one value on hl get other one back 
b8b1			 
b8b1 d1					pop de 
b8b2			 
b8b2					; do the add 
b8b2			 
b8b2 19					add hl,de 
b8b3			 
b8b3					; save it 
b8b3			 
b8b3			;		push hl	 
b8b3			 
b8b3					; 
b8b3			 
b8b3					; destroy value TOS 
b8b3			 
b8b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8b3 cd 7b 9c			call macro_forth_dsp_pop 
b8b6				endm 
# End of macro FORTH_DSP_POP
b8b6			 
b8b6					; TODO push value back onto stack for another op etc 
b8b6			 
b8b6			;		pop hl 
b8b6			 
b8b6			.dot_done: 
b8b6 cd c7 99				call forth_push_numhl 
b8b9			 
b8b9					NEXTW 
b8b9 cd 6c ee			call parse_vector 
b8bc c3 aa 9d			jp macro_next 
b8bf				endm 
# End of macro NEXTW
b8bf			.NEG: 
b8bf			 
b8bf				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b8bf 17				db WORD_SYS_CORE+3             
b8c0 08 b9			dw .DIV            
b8c2 02				db 1 + 1 
b8c3 .. 00			db "-",0              
b8c5				endm 
# End of macro CWHEAD
b8c5			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b8c5					if DEBUG_FORTH_WORDS_KEY 
b8c5						DMARK "SUB" 
b8c5 f5				push af  
b8c6 3a da b8			ld a, (.dmark)  
b8c9 32 62 ee			ld (debug_mark),a  
b8cc 3a db b8			ld a, (.dmark+1)  
b8cf 32 63 ee			ld (debug_mark+1),a  
b8d2 3a dc b8			ld a, (.dmark+2)  
b8d5 32 64 ee			ld (debug_mark+2),a  
b8d8 18 03			jr .pastdmark  
b8da ..			.dmark: db "SUB"  
b8dd f1			.pastdmark: pop af  
b8de			endm  
# End of macro DMARK
b8de						CALLMONITOR 
b8de cd 6f ee			call debug_vector  
b8e1				endm  
# End of macro CALLMONITOR
b8e1					endif 
b8e1			 
b8e1			 
b8e1				; TODO add floating point number detection 
b8e1					; v5 FORTH_DSP_VALUE 
b8e1					FORTH_DSP 
b8e1 cd 89 9b			call macro_forth_dsp 
b8e4				endm 
# End of macro FORTH_DSP
b8e4 7e					ld a,(hl)	; get type of value on TOS 
b8e5 fe 02				cp DS_TYPE_INUM  
b8e7 28 06				jr z, .neg_inum 
b8e9			 
b8e9					NEXTW 
b8e9 cd 6c ee			call parse_vector 
b8ec c3 aa 9d			jp macro_next 
b8ef				endm 
# End of macro NEXTW
b8ef			 
b8ef			; float maths 
b8ef			 
b8ef				if FORTH_ENABLE_FLOATMATH 
b8ef					jr .neg_done 
b8ef			 
b8ef				endif 
b8ef					 
b8ef			 
b8ef			.neg_inum: 
b8ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8ef cd c3 9b			call macro_dsp_valuehl 
b8f2				endm 
# End of macro FORTH_DSP_VALUEHL
b8f2			 
b8f2 e5					push hl 
b8f3			 
b8f3					; destroy value TOS 
b8f3			 
b8f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8f3 cd 7b 9c			call macro_forth_dsp_pop 
b8f6				endm 
# End of macro FORTH_DSP_POP
b8f6			 
b8f6			 
b8f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8f6 cd c3 9b			call macro_dsp_valuehl 
b8f9				endm 
# End of macro FORTH_DSP_VALUEHL
b8f9			 
b8f9					; one value on hl get other one back 
b8f9			 
b8f9 d1					pop de 
b8fa			 
b8fa					; do the sub 
b8fa			;		ex de, hl 
b8fa			 
b8fa ed 52				sbc hl,de 
b8fc			 
b8fc					; save it 
b8fc			 
b8fc			;		push hl	 
b8fc			 
b8fc					; 
b8fc			 
b8fc					; destroy value TOS 
b8fc			 
b8fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8fc cd 7b 9c			call macro_forth_dsp_pop 
b8ff				endm 
# End of macro FORTH_DSP_POP
b8ff			 
b8ff					; TODO push value back onto stack for another op etc 
b8ff			 
b8ff			;		pop hl 
b8ff			 
b8ff cd c7 99				call forth_push_numhl 
b902			.neg_done: 
b902			 
b902					NEXTW 
b902 cd 6c ee			call parse_vector 
b905 c3 aa 9d			jp macro_next 
b908				endm 
# End of macro NEXTW
b908			.DIV: 
b908				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b908 18				db WORD_SYS_CORE+4             
b909 5b b9			dw .MUL            
b90b 02				db 1 + 1 
b90c .. 00			db "/",0              
b90e				endm 
# End of macro CWHEAD
b90e			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b90e					if DEBUG_FORTH_WORDS_KEY 
b90e						DMARK "DIV" 
b90e f5				push af  
b90f 3a 23 b9			ld a, (.dmark)  
b912 32 62 ee			ld (debug_mark),a  
b915 3a 24 b9			ld a, (.dmark+1)  
b918 32 63 ee			ld (debug_mark+1),a  
b91b 3a 25 b9			ld a, (.dmark+2)  
b91e 32 64 ee			ld (debug_mark+2),a  
b921 18 03			jr .pastdmark  
b923 ..			.dmark: db "DIV"  
b926 f1			.pastdmark: pop af  
b927			endm  
# End of macro DMARK
b927						CALLMONITOR 
b927 cd 6f ee			call debug_vector  
b92a				endm  
# End of macro CALLMONITOR
b92a					endif 
b92a				; TODO add floating point number detection 
b92a					; v5 FORTH_DSP_VALUE 
b92a					FORTH_DSP 
b92a cd 89 9b			call macro_forth_dsp 
b92d				endm 
# End of macro FORTH_DSP
b92d 7e					ld a,(hl)	; get type of value on TOS 
b92e fe 02				cp DS_TYPE_INUM  
b930 28 06				jr z, .div_inum 
b932			 
b932				if FORTH_ENABLE_FLOATMATH 
b932					jr .div_done 
b932			 
b932				endif 
b932					NEXTW 
b932 cd 6c ee			call parse_vector 
b935 c3 aa 9d			jp macro_next 
b938				endm 
# End of macro NEXTW
b938			.div_inum: 
b938			 
b938					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b938 cd c3 9b			call macro_dsp_valuehl 
b93b				endm 
# End of macro FORTH_DSP_VALUEHL
b93b			 
b93b e5					push hl    ; to go to bc 
b93c			 
b93c					; destroy value TOS 
b93c			 
b93c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b93c cd 7b 9c			call macro_forth_dsp_pop 
b93f				endm 
# End of macro FORTH_DSP_POP
b93f			 
b93f			 
b93f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b93f cd c3 9b			call macro_dsp_valuehl 
b942				endm 
# End of macro FORTH_DSP_VALUEHL
b942			 
b942					; hl to go to de 
b942			 
b942 e5					push hl 
b943			 
b943 c1					pop bc 
b944 d1					pop de		 
b945			 
b945			 
b945					if DEBUG_FORTH_MATHS 
b945						DMARK "DIV" 
b945				CALLMONITOR 
b945					endif 
b945					; one value on hl but move to a get other one back 
b945			 
b945			        
b945 cd 33 8c			call Div16 
b948			 
b948			;	push af	 
b948 e5				push hl 
b949 c5				push bc 
b94a			 
b94a					if DEBUG_FORTH_MATHS 
b94a						DMARK "DI1" 
b94a				CALLMONITOR 
b94a					endif 
b94a			 
b94a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b94a cd 7b 9c			call macro_forth_dsp_pop 
b94d				endm 
# End of macro FORTH_DSP_POP
b94d			 
b94d			 
b94d			 
b94d e1					pop hl    ; result 
b94e			 
b94e cd c7 99				call forth_push_numhl 
b951			 
b951 e1					pop hl    ; reminder 
b952			;		ld h,0 
b952			;		ld l,d 
b952			 
b952 cd c7 99				call forth_push_numhl 
b955			.div_done: 
b955					NEXTW 
b955 cd 6c ee			call parse_vector 
b958 c3 aa 9d			jp macro_next 
b95b				endm 
# End of macro NEXTW
b95b			.MUL: 
b95b				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b95b 19				db WORD_SYS_CORE+5             
b95c a6 b9			dw .MIN            
b95e 02				db 1 + 1 
b95f .. 00			db "*",0              
b961				endm 
# End of macro CWHEAD
b961			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b961				; TODO add floating point number detection 
b961					if DEBUG_FORTH_WORDS_KEY 
b961						DMARK "MUL" 
b961 f5				push af  
b962 3a 76 b9			ld a, (.dmark)  
b965 32 62 ee			ld (debug_mark),a  
b968 3a 77 b9			ld a, (.dmark+1)  
b96b 32 63 ee			ld (debug_mark+1),a  
b96e 3a 78 b9			ld a, (.dmark+2)  
b971 32 64 ee			ld (debug_mark+2),a  
b974 18 03			jr .pastdmark  
b976 ..			.dmark: db "MUL"  
b979 f1			.pastdmark: pop af  
b97a			endm  
# End of macro DMARK
b97a						CALLMONITOR 
b97a cd 6f ee			call debug_vector  
b97d				endm  
# End of macro CALLMONITOR
b97d					endif 
b97d					FORTH_DSP 
b97d cd 89 9b			call macro_forth_dsp 
b980				endm 
# End of macro FORTH_DSP
b980					; v5 FORTH_DSP_VALUE 
b980 7e					ld a,(hl)	; get type of value on TOS 
b981 fe 02				cp DS_TYPE_INUM  
b983 28 06				jr z, .mul_inum 
b985			 
b985				if FORTH_ENABLE_FLOATMATH 
b985					jr .mul_done 
b985			 
b985				endif 
b985			 
b985					NEXTW 
b985 cd 6c ee			call parse_vector 
b988 c3 aa 9d			jp macro_next 
b98b				endm 
# End of macro NEXTW
b98b			.mul_inum:	 
b98b			 
b98b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b98b cd c3 9b			call macro_dsp_valuehl 
b98e				endm 
# End of macro FORTH_DSP_VALUEHL
b98e			 
b98e e5					push hl 
b98f			 
b98f					; destroy value TOS 
b98f			 
b98f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b98f cd 7b 9c			call macro_forth_dsp_pop 
b992				endm 
# End of macro FORTH_DSP_POP
b992			 
b992			 
b992					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b992 cd c3 9b			call macro_dsp_valuehl 
b995				endm 
# End of macro FORTH_DSP_VALUEHL
b995			 
b995					; one value on hl but move to a get other one back 
b995			 
b995 7d					ld a, l 
b996			 
b996 d1					pop de 
b997			 
b997					; do the mull 
b997			;		ex de, hl 
b997			 
b997 cd 59 8c				call Mult16 
b99a					; save it 
b99a			 
b99a			;		push hl	 
b99a			 
b99a					; 
b99a			 
b99a					; destroy value TOS 
b99a			 
b99a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b99a cd 7b 9c			call macro_forth_dsp_pop 
b99d				endm 
# End of macro FORTH_DSP_POP
b99d			 
b99d					; TODO push value back onto stack for another op etc 
b99d			 
b99d			;		pop hl 
b99d			 
b99d cd c7 99				call forth_push_numhl 
b9a0			 
b9a0			.mul_done: 
b9a0					NEXTW 
b9a0 cd 6c ee			call parse_vector 
b9a3 c3 aa 9d			jp macro_next 
b9a6				endm 
# End of macro NEXTW
b9a6			 
b9a6			 
b9a6			 
b9a6			 
b9a6			.MIN: 
b9a6				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b9a6 49				db WORD_SYS_CORE+53             
b9a7 2d ba			dw .MAX            
b9a9 04				db 3 + 1 
b9aa .. 00			db "MIN",0              
b9ae				endm 
# End of macro CWHEAD
b9ae			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b9ae					if DEBUG_FORTH_WORDS_KEY 
b9ae						DMARK "MIN" 
b9ae f5				push af  
b9af 3a c3 b9			ld a, (.dmark)  
b9b2 32 62 ee			ld (debug_mark),a  
b9b5 3a c4 b9			ld a, (.dmark+1)  
b9b8 32 63 ee			ld (debug_mark+1),a  
b9bb 3a c5 b9			ld a, (.dmark+2)  
b9be 32 64 ee			ld (debug_mark+2),a  
b9c1 18 03			jr .pastdmark  
b9c3 ..			.dmark: db "MIN"  
b9c6 f1			.pastdmark: pop af  
b9c7			endm  
# End of macro DMARK
b9c7						CALLMONITOR 
b9c7 cd 6f ee			call debug_vector  
b9ca				endm  
# End of macro CALLMONITOR
b9ca					endif 
b9ca					; get u2 
b9ca			 
b9ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9ca cd c3 9b			call macro_dsp_valuehl 
b9cd				endm 
# End of macro FORTH_DSP_VALUEHL
b9cd			 
b9cd e5					push hl   ; u2 
b9ce			 
b9ce					; destroy value TOS 
b9ce			 
b9ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9ce cd 7b 9c			call macro_forth_dsp_pop 
b9d1				endm 
# End of macro FORTH_DSP_POP
b9d1			 
b9d1					; get u1 
b9d1			 
b9d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9d1 cd c3 9b			call macro_dsp_valuehl 
b9d4				endm 
# End of macro FORTH_DSP_VALUEHL
b9d4			 
b9d4 e5					push hl  ; u1 
b9d5			 
b9d5					; destroy value TOS 
b9d5			 
b9d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9d5 cd 7b 9c			call macro_forth_dsp_pop 
b9d8				endm 
# End of macro FORTH_DSP_POP
b9d8			 
b9d8 b7			 or a      ;clear carry flag 
b9d9 e1			  pop hl    ; u1 
b9da d1			  pop de    ; u2 
b9db e5				push hl   ; saved in case hl is lowest 
b9dc ed 52		  sbc hl,de 
b9de 30 26		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b9e0			 
b9e0 e1				pop hl 
b9e1					if DEBUG_FORTH_WORDS 
b9e1						DMARK "MIN" 
b9e1 f5				push af  
b9e2 3a f6 b9			ld a, (.dmark)  
b9e5 32 62 ee			ld (debug_mark),a  
b9e8 3a f7 b9			ld a, (.dmark+1)  
b9eb 32 63 ee			ld (debug_mark+1),a  
b9ee 3a f8 b9			ld a, (.dmark+2)  
b9f1 32 64 ee			ld (debug_mark+2),a  
b9f4 18 03			jr .pastdmark  
b9f6 ..			.dmark: db "MIN"  
b9f9 f1			.pastdmark: pop af  
b9fa			endm  
# End of macro DMARK
b9fa						CALLMONITOR 
b9fa cd 6f ee			call debug_vector  
b9fd				endm  
# End of macro CALLMONITOR
b9fd					endif 
b9fd cd c7 99				call forth_push_numhl 
ba00			 
ba00				       NEXTW 
ba00 cd 6c ee			call parse_vector 
ba03 c3 aa 9d			jp macro_next 
ba06				endm 
# End of macro NEXTW
ba06			 
ba06			.mincont:  
ba06 c1				pop bc   ; tidy up 
ba07 eb				ex de , hl  
ba08					if DEBUG_FORTH_WORDS 
ba08						DMARK "MI1" 
ba08 f5				push af  
ba09 3a 1d ba			ld a, (.dmark)  
ba0c 32 62 ee			ld (debug_mark),a  
ba0f 3a 1e ba			ld a, (.dmark+1)  
ba12 32 63 ee			ld (debug_mark+1),a  
ba15 3a 1f ba			ld a, (.dmark+2)  
ba18 32 64 ee			ld (debug_mark+2),a  
ba1b 18 03			jr .pastdmark  
ba1d ..			.dmark: db "MI1"  
ba20 f1			.pastdmark: pop af  
ba21			endm  
# End of macro DMARK
ba21						CALLMONITOR 
ba21 cd 6f ee			call debug_vector  
ba24				endm  
# End of macro CALLMONITOR
ba24					endif 
ba24 cd c7 99				call forth_push_numhl 
ba27			 
ba27				       NEXTW 
ba27 cd 6c ee			call parse_vector 
ba2a c3 aa 9d			jp macro_next 
ba2d				endm 
# End of macro NEXTW
ba2d			.MAX: 
ba2d				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
ba2d 4a				db WORD_SYS_CORE+54             
ba2e b4 ba			dw .RND16            
ba30 04				db 3 + 1 
ba31 .. 00			db "MAX",0              
ba35				endm 
# End of macro CWHEAD
ba35			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
ba35					if DEBUG_FORTH_WORDS_KEY 
ba35						DMARK "MAX" 
ba35 f5				push af  
ba36 3a 4a ba			ld a, (.dmark)  
ba39 32 62 ee			ld (debug_mark),a  
ba3c 3a 4b ba			ld a, (.dmark+1)  
ba3f 32 63 ee			ld (debug_mark+1),a  
ba42 3a 4c ba			ld a, (.dmark+2)  
ba45 32 64 ee			ld (debug_mark+2),a  
ba48 18 03			jr .pastdmark  
ba4a ..			.dmark: db "MAX"  
ba4d f1			.pastdmark: pop af  
ba4e			endm  
# End of macro DMARK
ba4e						CALLMONITOR 
ba4e cd 6f ee			call debug_vector  
ba51				endm  
# End of macro CALLMONITOR
ba51					endif 
ba51					; get u2 
ba51			 
ba51					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba51 cd c3 9b			call macro_dsp_valuehl 
ba54				endm 
# End of macro FORTH_DSP_VALUEHL
ba54			 
ba54 e5					push hl   ; u2 
ba55			 
ba55					; destroy value TOS 
ba55			 
ba55					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba55 cd 7b 9c			call macro_forth_dsp_pop 
ba58				endm 
# End of macro FORTH_DSP_POP
ba58			 
ba58					; get u1 
ba58			 
ba58					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba58 cd c3 9b			call macro_dsp_valuehl 
ba5b				endm 
# End of macro FORTH_DSP_VALUEHL
ba5b			 
ba5b e5					push hl  ; u1 
ba5c			 
ba5c					; destroy value TOS 
ba5c			 
ba5c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba5c cd 7b 9c			call macro_forth_dsp_pop 
ba5f				endm 
# End of macro FORTH_DSP_POP
ba5f			 
ba5f b7			 or a      ;clear carry flag 
ba60 e1			  pop hl    ; u1 
ba61 d1			  pop de    ; u2 
ba62 e5				push hl   ; saved in case hl is lowest 
ba63 ed 52		  sbc hl,de 
ba65 38 26		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
ba67			 
ba67 e1				pop hl 
ba68					if DEBUG_FORTH_WORDS 
ba68						DMARK "MAX" 
ba68 f5				push af  
ba69 3a 7d ba			ld a, (.dmark)  
ba6c 32 62 ee			ld (debug_mark),a  
ba6f 3a 7e ba			ld a, (.dmark+1)  
ba72 32 63 ee			ld (debug_mark+1),a  
ba75 3a 7f ba			ld a, (.dmark+2)  
ba78 32 64 ee			ld (debug_mark+2),a  
ba7b 18 03			jr .pastdmark  
ba7d ..			.dmark: db "MAX"  
ba80 f1			.pastdmark: pop af  
ba81			endm  
# End of macro DMARK
ba81						CALLMONITOR 
ba81 cd 6f ee			call debug_vector  
ba84				endm  
# End of macro CALLMONITOR
ba84					endif 
ba84 cd c7 99				call forth_push_numhl 
ba87			 
ba87				       NEXTW 
ba87 cd 6c ee			call parse_vector 
ba8a c3 aa 9d			jp macro_next 
ba8d				endm 
# End of macro NEXTW
ba8d			 
ba8d			.maxcont:  
ba8d c1				pop bc   ; tidy up 
ba8e eb				ex de , hl  
ba8f					if DEBUG_FORTH_WORDS 
ba8f						DMARK "MA1" 
ba8f f5				push af  
ba90 3a a4 ba			ld a, (.dmark)  
ba93 32 62 ee			ld (debug_mark),a  
ba96 3a a5 ba			ld a, (.dmark+1)  
ba99 32 63 ee			ld (debug_mark+1),a  
ba9c 3a a6 ba			ld a, (.dmark+2)  
ba9f 32 64 ee			ld (debug_mark+2),a  
baa2 18 03			jr .pastdmark  
baa4 ..			.dmark: db "MA1"  
baa7 f1			.pastdmark: pop af  
baa8			endm  
# End of macro DMARK
baa8						CALLMONITOR 
baa8 cd 6f ee			call debug_vector  
baab				endm  
# End of macro CALLMONITOR
baab					endif 
baab cd c7 99				call forth_push_numhl 
baae				       NEXTW 
baae cd 6c ee			call parse_vector 
bab1 c3 aa 9d			jp macro_next 
bab4				endm 
# End of macro NEXTW
bab4			 
bab4			.RND16: 
bab4				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
bab4 4e				db WORD_SYS_CORE+58             
bab5 e6 ba			dw .RND8            
bab7 06				db 5 + 1 
bab8 .. 00			db "RND16",0              
babe				endm 
# End of macro CWHEAD
babe			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
babe					if DEBUG_FORTH_WORDS_KEY 
babe						DMARK "R16" 
babe f5				push af  
babf 3a d3 ba			ld a, (.dmark)  
bac2 32 62 ee			ld (debug_mark),a  
bac5 3a d4 ba			ld a, (.dmark+1)  
bac8 32 63 ee			ld (debug_mark+1),a  
bacb 3a d5 ba			ld a, (.dmark+2)  
bace 32 64 ee			ld (debug_mark+2),a  
bad1 18 03			jr .pastdmark  
bad3 ..			.dmark: db "R16"  
bad6 f1			.pastdmark: pop af  
bad7			endm  
# End of macro DMARK
bad7						CALLMONITOR 
bad7 cd 6f ee			call debug_vector  
bada				endm  
# End of macro CALLMONITOR
bada					endif 
bada cd fd 8b				call prng16  
badd cd c7 99				call forth_push_numhl 
bae0				       NEXTW 
bae0 cd 6c ee			call parse_vector 
bae3 c3 aa 9d			jp macro_next 
bae6				endm 
# End of macro NEXTW
bae6			.RND8: 
bae6				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
bae6 60				db WORD_SYS_CORE+76             
bae7 1e bb			dw .RND            
bae9 05				db 4 + 1 
baea .. 00			db "RND8",0              
baef				endm 
# End of macro CWHEAD
baef			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
baef					if DEBUG_FORTH_WORDS_KEY 
baef						DMARK "RN8" 
baef f5				push af  
baf0 3a 04 bb			ld a, (.dmark)  
baf3 32 62 ee			ld (debug_mark),a  
baf6 3a 05 bb			ld a, (.dmark+1)  
baf9 32 63 ee			ld (debug_mark+1),a  
bafc 3a 06 bb			ld a, (.dmark+2)  
baff 32 64 ee			ld (debug_mark+2),a  
bb02 18 03			jr .pastdmark  
bb04 ..			.dmark: db "RN8"  
bb07 f1			.pastdmark: pop af  
bb08			endm  
# End of macro DMARK
bb08						CALLMONITOR 
bb08 cd 6f ee			call debug_vector  
bb0b				endm  
# End of macro CALLMONITOR
bb0b					endif 
bb0b 2a a0 eb				ld hl,(xrandc) 
bb0e 23					inc hl 
bb0f cd 17 8c				call xrnd 
bb12 6f					ld l,a	 
bb13 26 00				ld h,0 
bb15 cd c7 99				call forth_push_numhl 
bb18				       NEXTW 
bb18 cd 6c ee			call parse_vector 
bb1b c3 aa 9d			jp macro_next 
bb1e				endm 
# End of macro NEXTW
bb1e			.RND: 
bb1e				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
bb1e 60				db WORD_SYS_CORE+76             
bb1f 27 bc			dw .ENDMATHS            
bb21 04				db 3 + 1 
bb22 .. 00			db "RND",0              
bb26				endm 
# End of macro CWHEAD
bb26			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
bb26			 
bb26					if DEBUG_FORTH_WORDS_KEY 
bb26						DMARK "RND" 
bb26 f5				push af  
bb27 3a 3b bb			ld a, (.dmark)  
bb2a 32 62 ee			ld (debug_mark),a  
bb2d 3a 3c bb			ld a, (.dmark+1)  
bb30 32 63 ee			ld (debug_mark+1),a  
bb33 3a 3d bb			ld a, (.dmark+2)  
bb36 32 64 ee			ld (debug_mark+2),a  
bb39 18 03			jr .pastdmark  
bb3b ..			.dmark: db "RND"  
bb3e f1			.pastdmark: pop af  
bb3f			endm  
# End of macro DMARK
bb3f						CALLMONITOR 
bb3f cd 6f ee			call debug_vector  
bb42				endm  
# End of macro CALLMONITOR
bb42					endif 
bb42					 
bb42					FORTH_DSP_VALUEHL    ; upper range 
bb42 cd c3 9b			call macro_dsp_valuehl 
bb45				endm 
# End of macro FORTH_DSP_VALUEHL
bb45			 
bb45 22 a4 eb				ld (LFSRSeed), hl	 
bb48			 
bb48					if DEBUG_FORTH_WORDS 
bb48						DMARK "RN1" 
bb48 f5				push af  
bb49 3a 5d bb			ld a, (.dmark)  
bb4c 32 62 ee			ld (debug_mark),a  
bb4f 3a 5e bb			ld a, (.dmark+1)  
bb52 32 63 ee			ld (debug_mark+1),a  
bb55 3a 5f bb			ld a, (.dmark+2)  
bb58 32 64 ee			ld (debug_mark+2),a  
bb5b 18 03			jr .pastdmark  
bb5d ..			.dmark: db "RN1"  
bb60 f1			.pastdmark: pop af  
bb61			endm  
# End of macro DMARK
bb61						CALLMONITOR 
bb61 cd 6f ee			call debug_vector  
bb64				endm  
# End of macro CALLMONITOR
bb64					endif 
bb64					FORTH_DSP_POP 
bb64 cd 7b 9c			call macro_forth_dsp_pop 
bb67				endm 
# End of macro FORTH_DSP_POP
bb67			 
bb67					FORTH_DSP_VALUEHL    ; low range 
bb67 cd c3 9b			call macro_dsp_valuehl 
bb6a				endm 
# End of macro FORTH_DSP_VALUEHL
bb6a			 
bb6a					if DEBUG_FORTH_WORDS 
bb6a						DMARK "RN2" 
bb6a f5				push af  
bb6b 3a 7f bb			ld a, (.dmark)  
bb6e 32 62 ee			ld (debug_mark),a  
bb71 3a 80 bb			ld a, (.dmark+1)  
bb74 32 63 ee			ld (debug_mark+1),a  
bb77 3a 81 bb			ld a, (.dmark+2)  
bb7a 32 64 ee			ld (debug_mark+2),a  
bb7d 18 03			jr .pastdmark  
bb7f ..			.dmark: db "RN2"  
bb82 f1			.pastdmark: pop af  
bb83			endm  
# End of macro DMARK
bb83						CALLMONITOR 
bb83 cd 6f ee			call debug_vector  
bb86				endm  
# End of macro CALLMONITOR
bb86					endif 
bb86 22 a6 eb				ld (LFSRSeed+2), hl 
bb89			 
bb89					FORTH_DSP_POP 
bb89 cd 7b 9c			call macro_forth_dsp_pop 
bb8c				endm 
# End of macro FORTH_DSP_POP
bb8c			 
bb8c e5					push hl 
bb8d			 
bb8d e1			.inrange:	pop hl 
bb8e cd fd 8b				call prng16  
bb91					if DEBUG_FORTH_WORDS 
bb91						DMARK "RN3" 
bb91 f5				push af  
bb92 3a a6 bb			ld a, (.dmark)  
bb95 32 62 ee			ld (debug_mark),a  
bb98 3a a7 bb			ld a, (.dmark+1)  
bb9b 32 63 ee			ld (debug_mark+1),a  
bb9e 3a a8 bb			ld a, (.dmark+2)  
bba1 32 64 ee			ld (debug_mark+2),a  
bba4 18 03			jr .pastdmark  
bba6 ..			.dmark: db "RN3"  
bba9 f1			.pastdmark: pop af  
bbaa			endm  
# End of macro DMARK
bbaa						CALLMONITOR 
bbaa cd 6f ee			call debug_vector  
bbad				endm  
# End of macro CALLMONITOR
bbad					endif 
bbad					 
bbad					; if the range is 8bit knock out the high byte 
bbad			 
bbad ed 5b a4 eb			ld de, (LFSRSeed)     ; check high level 
bbb1			 
bbb1 3e 00				ld a, 0 
bbb3 ba					cp d  
bbb4 20 1e				jr nz, .hirange 
bbb6 26 00				ld h, 0   ; knock it down to 8bit 
bbb8			 
bbb8					if DEBUG_FORTH_WORDS 
bbb8						DMARK "RNk" 
bbb8 f5				push af  
bbb9 3a cd bb			ld a, (.dmark)  
bbbc 32 62 ee			ld (debug_mark),a  
bbbf 3a ce bb			ld a, (.dmark+1)  
bbc2 32 63 ee			ld (debug_mark+1),a  
bbc5 3a cf bb			ld a, (.dmark+2)  
bbc8 32 64 ee			ld (debug_mark+2),a  
bbcb 18 03			jr .pastdmark  
bbcd ..			.dmark: db "RNk"  
bbd0 f1			.pastdmark: pop af  
bbd1			endm  
# End of macro DMARK
bbd1						CALLMONITOR 
bbd1 cd 6f ee			call debug_vector  
bbd4				endm  
# End of macro CALLMONITOR
bbd4					endif 
bbd4			.hirange:   
bbd4 e5					push hl  
bbd5 b7					or a  
bbd6 ed 52		                sbc hl, de 
bbd8			 
bbd8					;call cmp16 
bbd8			 
bbd8 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
bbda e1					pop hl 
bbdb e5					push hl 
bbdc			 
bbdc					if DEBUG_FORTH_WORDS 
bbdc						DMARK "RN4" 
bbdc f5				push af  
bbdd 3a f1 bb			ld a, (.dmark)  
bbe0 32 62 ee			ld (debug_mark),a  
bbe3 3a f2 bb			ld a, (.dmark+1)  
bbe6 32 63 ee			ld (debug_mark+1),a  
bbe9 3a f3 bb			ld a, (.dmark+2)  
bbec 32 64 ee			ld (debug_mark+2),a  
bbef 18 03			jr .pastdmark  
bbf1 ..			.dmark: db "RN4"  
bbf4 f1			.pastdmark: pop af  
bbf5			endm  
# End of macro DMARK
bbf5						CALLMONITOR 
bbf5 cd 6f ee			call debug_vector  
bbf8				endm  
# End of macro CALLMONITOR
bbf8					endif 
bbf8 ed 5b a6 eb			ld de, (LFSRSeed+2)   ; check low range 
bbfc					;call cmp16 
bbfc				 
bbfc b7					or a  
bbfd ed 52		                sbc hl, de 
bbff 38 8c				jr c, .inrange 
bc01			 
bc01 e1					pop hl 
bc02					 
bc02					if DEBUG_FORTH_WORDS 
bc02						DMARK "RNd" 
bc02 f5				push af  
bc03 3a 17 bc			ld a, (.dmark)  
bc06 32 62 ee			ld (debug_mark),a  
bc09 3a 18 bc			ld a, (.dmark+1)  
bc0c 32 63 ee			ld (debug_mark+1),a  
bc0f 3a 19 bc			ld a, (.dmark+2)  
bc12 32 64 ee			ld (debug_mark+2),a  
bc15 18 03			jr .pastdmark  
bc17 ..			.dmark: db "RNd"  
bc1a f1			.pastdmark: pop af  
bc1b			endm  
# End of macro DMARK
bc1b						CALLMONITOR 
bc1b cd 6f ee			call debug_vector  
bc1e				endm  
# End of macro CALLMONITOR
bc1e					endif 
bc1e			 
bc1e			 
bc1e cd c7 99				call forth_push_numhl 
bc21				       NEXTW 
bc21 cd 6c ee			call parse_vector 
bc24 c3 aa 9d			jp macro_next 
bc27				endm 
# End of macro NEXTW
bc27			 
bc27			.ENDMATHS: 
bc27			 
bc27			; eof 
bc27			 
# End of file forth_words_maths.asm
bc27			include "forth_words_display.asm" 
bc27			 
bc27			; | ## Display Words 
bc27			 
bc27			.ACT: 
bc27			 
bc27				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
bc27 62				db WORD_SYS_CORE+78             
bc28 76 bc			dw .INFO            
bc2a 07				db 6 + 1 
bc2b .. 00			db "ACTIVE",0              
bc32				endm 
# End of macro CWHEAD
bc32			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
bc32			;  
bc32			; | | To display a pulsing activity indicator in a processing loop do this... 
bc32			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
bc32			 
bc32					if DEBUG_FORTH_WORDS_KEY 
bc32						DMARK "ACT" 
bc32 f5				push af  
bc33 3a 47 bc			ld a, (.dmark)  
bc36 32 62 ee			ld (debug_mark),a  
bc39 3a 48 bc			ld a, (.dmark+1)  
bc3c 32 63 ee			ld (debug_mark+1),a  
bc3f 3a 49 bc			ld a, (.dmark+2)  
bc42 32 64 ee			ld (debug_mark+2),a  
bc45 18 03			jr .pastdmark  
bc47 ..			.dmark: db "ACT"  
bc4a f1			.pastdmark: pop af  
bc4b			endm  
# End of macro DMARK
bc4b						CALLMONITOR 
bc4b cd 6f ee			call debug_vector  
bc4e				endm  
# End of macro CALLMONITOR
bc4e					endif 
bc4e cd 04 8a				call active 
bc51					if DEBUG_FORTH_WORDS 
bc51						DMARK "ACp" 
bc51 f5				push af  
bc52 3a 66 bc			ld a, (.dmark)  
bc55 32 62 ee			ld (debug_mark),a  
bc58 3a 67 bc			ld a, (.dmark+1)  
bc5b 32 63 ee			ld (debug_mark+1),a  
bc5e 3a 68 bc			ld a, (.dmark+2)  
bc61 32 64 ee			ld (debug_mark+2),a  
bc64 18 03			jr .pastdmark  
bc66 ..			.dmark: db "ACp"  
bc69 f1			.pastdmark: pop af  
bc6a			endm  
# End of macro DMARK
bc6a						CALLMONITOR 
bc6a cd 6f ee			call debug_vector  
bc6d				endm  
# End of macro CALLMONITOR
bc6d					endif 
bc6d cd 31 9a				call forth_push_str 
bc70			 
bc70					NEXTW 
bc70 cd 6c ee			call parse_vector 
bc73 c3 aa 9d			jp macro_next 
bc76				endm 
# End of macro NEXTW
bc76			.INFO: 
bc76			 
bc76				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
bc76 62				db WORD_SYS_CORE+78             
bc77 96 bc			dw .ATP            
bc79 05				db 4 + 1 
bc7a .. 00			db "INFO",0              
bc7f				endm 
# End of macro CWHEAD
bc7f			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
bc7f					FORTH_DSP_VALUEHL 
bc7f cd c3 9b			call macro_dsp_valuehl 
bc82				endm 
# End of macro FORTH_DSP_VALUEHL
bc82			 
bc82					FORTH_DSP_POP 
bc82 cd 7b 9c			call macro_forth_dsp_pop 
bc85				endm 
# End of macro FORTH_DSP_POP
bc85			 
bc85 e5					push hl 
bc86			 
bc86					FORTH_DSP_VALUEHL 
bc86 cd c3 9b			call macro_dsp_valuehl 
bc89				endm 
# End of macro FORTH_DSP_VALUEHL
bc89			 
bc89					FORTH_DSP_POP 
bc89 cd 7b 9c			call macro_forth_dsp_pop 
bc8c				endm 
# End of macro FORTH_DSP_POP
bc8c			 
bc8c d1					pop de 
bc8d			 
bc8d cd 3e 8a				call info_panel 
bc90			 
bc90			 
bc90					NEXTW 
bc90 cd 6c ee			call parse_vector 
bc93 c3 aa 9d			jp macro_next 
bc96				endm 
# End of macro NEXTW
bc96			.ATP: 
bc96				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
bc96 62				db WORD_SYS_CORE+78             
bc97 10 bd			dw .FB            
bc99 04				db 3 + 1 
bc9a .. 00			db "AT?",0              
bc9e				endm 
# End of macro CWHEAD
bc9e			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
bc9e					if DEBUG_FORTH_WORDS_KEY 
bc9e						DMARK "AT?" 
bc9e f5				push af  
bc9f 3a b3 bc			ld a, (.dmark)  
bca2 32 62 ee			ld (debug_mark),a  
bca5 3a b4 bc			ld a, (.dmark+1)  
bca8 32 63 ee			ld (debug_mark+1),a  
bcab 3a b5 bc			ld a, (.dmark+2)  
bcae 32 64 ee			ld (debug_mark+2),a  
bcb1 18 03			jr .pastdmark  
bcb3 ..			.dmark: db "AT?"  
bcb6 f1			.pastdmark: pop af  
bcb7			endm  
# End of macro DMARK
bcb7						CALLMONITOR 
bcb7 cd 6f ee			call debug_vector  
bcba				endm  
# End of macro CALLMONITOR
bcba					endif 
bcba 3a 55 ea				ld a, (f_cursor_ptr) 
bcbd			 
bcbd			if DEBUG_FORTH_WORDS 
bcbd				DMARK "AT?" 
bcbd f5				push af  
bcbe 3a d2 bc			ld a, (.dmark)  
bcc1 32 62 ee			ld (debug_mark),a  
bcc4 3a d3 bc			ld a, (.dmark+1)  
bcc7 32 63 ee			ld (debug_mark+1),a  
bcca 3a d4 bc			ld a, (.dmark+2)  
bccd 32 64 ee			ld (debug_mark+2),a  
bcd0 18 03			jr .pastdmark  
bcd2 ..			.dmark: db "AT?"  
bcd5 f1			.pastdmark: pop af  
bcd6			endm  
# End of macro DMARK
bcd6				CALLMONITOR 
bcd6 cd 6f ee			call debug_vector  
bcd9				endm  
# End of macro CALLMONITOR
bcd9			endif	 
bcd9					; count the number of rows 
bcd9			 
bcd9 06 00				ld b, 0 
bcdb 4f			.atpr:		ld c, a    ; save in case we go below zero 
bcdc d6 28				sub display_cols 
bcde f2 e4 bc				jp p, .atprunder 
bce1 04					inc b 
bce2 18 f7				jr .atpr 
bce4			.atprunder:	 
bce4			if DEBUG_FORTH_WORDS 
bce4				DMARK "A?2" 
bce4 f5				push af  
bce5 3a f9 bc			ld a, (.dmark)  
bce8 32 62 ee			ld (debug_mark),a  
bceb 3a fa bc			ld a, (.dmark+1)  
bcee 32 63 ee			ld (debug_mark+1),a  
bcf1 3a fb bc			ld a, (.dmark+2)  
bcf4 32 64 ee			ld (debug_mark+2),a  
bcf7 18 03			jr .pastdmark  
bcf9 ..			.dmark: db "A?2"  
bcfc f1			.pastdmark: pop af  
bcfd			endm  
# End of macro DMARK
bcfd				CALLMONITOR 
bcfd cd 6f ee			call debug_vector  
bd00				endm  
# End of macro CALLMONITOR
bd00			endif	 
bd00 26 00				ld h, 0 
bd02 69					ld l, c 
bd03 cd c7 99				call forth_push_numhl 
bd06 68					ld l, b  
bd07 cd c7 99				call forth_push_numhl 
bd0a			 
bd0a			 
bd0a				NEXTW 
bd0a cd 6c ee			call parse_vector 
bd0d c3 aa 9d			jp macro_next 
bd10				endm 
# End of macro NEXTW
bd10			 
bd10			.FB: 
bd10				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
bd10 1b				db WORD_SYS_CORE+7             
bd11 61 bd			dw .EMIT            
bd13 03				db 2 + 1 
bd14 .. 00			db "FB",0              
bd17				endm 
# End of macro CWHEAD
bd17			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
bd17			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
bd17			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
bd17			; | | If automatic display is off then updates will not be shown until DRAW is used. 
bd17					if DEBUG_FORTH_WORDS_KEY 
bd17						DMARK "FB." 
bd17 f5				push af  
bd18 3a 2c bd			ld a, (.dmark)  
bd1b 32 62 ee			ld (debug_mark),a  
bd1e 3a 2d bd			ld a, (.dmark+1)  
bd21 32 63 ee			ld (debug_mark+1),a  
bd24 3a 2e bd			ld a, (.dmark+2)  
bd27 32 64 ee			ld (debug_mark+2),a  
bd2a 18 03			jr .pastdmark  
bd2c ..			.dmark: db "FB."  
bd2f f1			.pastdmark: pop af  
bd30			endm  
# End of macro DMARK
bd30						CALLMONITOR 
bd30 cd 6f ee			call debug_vector  
bd33				endm  
# End of macro CALLMONITOR
bd33					endif 
bd33			 
bd33					FORTH_DSP_VALUEHL 
bd33 cd c3 9b			call macro_dsp_valuehl 
bd36				endm 
# End of macro FORTH_DSP_VALUEHL
bd36			 
bd36 7d					ld a, l 
bd37 fe 01				cp 1 
bd39 20 05				jr nz, .fbn1 
bd3b 21 07 ed				ld hl, display_fb1 
bd3e 18 15				jr .fbset 
bd40 fe 02		.fbn1:		cp 2 
bd42 20 05				jr nz, .fbn2 
bd44 21 c5 eb				ld hl, display_fb2 
bd47 18 0c				jr .fbset 
bd49 fe 03		.fbn2:		cp 3 
bd4b 20 05				jr nz, .fbn3 
bd4d 21 66 ec				ld hl, display_fb3 
bd50 18 03				jr .fbset 
bd52			.fbn3:		 ; if invalid number select first 
bd52 21 07 ed				ld hl, display_fb1 
bd55 22 c3 eb		.fbset:		ld (display_fb_active), hl 
bd58			 
bd58					FORTH_DSP_POP 
bd58 cd 7b 9c			call macro_forth_dsp_pop 
bd5b				endm 
# End of macro FORTH_DSP_POP
bd5b			 
bd5b					NEXTW 
bd5b cd 6c ee			call parse_vector 
bd5e c3 aa 9d			jp macro_next 
bd61				endm 
# End of macro NEXTW
bd61			 
bd61			 
bd61			.EMIT: 
bd61				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
bd61 1b				db WORD_SYS_CORE+7             
bd62 b4 bd			dw .DOTH            
bd64 05				db 4 + 1 
bd65 .. 00			db "EMIT",0              
bd6a				endm 
# End of macro CWHEAD
bd6a			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
bd6a					; get value off TOS and display it 
bd6a			 
bd6a					if DEBUG_FORTH_WORDS_KEY 
bd6a						DMARK "EMT" 
bd6a f5				push af  
bd6b 3a 7f bd			ld a, (.dmark)  
bd6e 32 62 ee			ld (debug_mark),a  
bd71 3a 80 bd			ld a, (.dmark+1)  
bd74 32 63 ee			ld (debug_mark+1),a  
bd77 3a 81 bd			ld a, (.dmark+2)  
bd7a 32 64 ee			ld (debug_mark+2),a  
bd7d 18 03			jr .pastdmark  
bd7f ..			.dmark: db "EMT"  
bd82 f1			.pastdmark: pop af  
bd83			endm  
# End of macro DMARK
bd83						CALLMONITOR 
bd83 cd 6f ee			call debug_vector  
bd86				endm  
# End of macro CALLMONITOR
bd86					endif 
bd86			 
bd86					FORTH_DSP_VALUEHL 
bd86 cd c3 9b			call macro_dsp_valuehl 
bd89				endm 
# End of macro FORTH_DSP_VALUEHL
bd89			 
bd89 7d					ld a,l 
bd8a			 
bd8a					; TODO write to display 
bd8a			 
bd8a 32 b6 e4				ld (os_input), a 
bd8d 3e 00				ld a, 0 
bd8f 32 b7 e4				ld (os_input+1), a 
bd92					 
bd92 3a 55 ea				ld a, (f_cursor_ptr) 
bd95 11 b6 e4				ld de, os_input 
bd98 cd be 8a				call str_at_display 
bd9b			 
bd9b			 
bd9b 3a 33 ea				ld a,(cli_autodisplay) 
bd9e			;		cp 0 
bd9e b7					or a 
bd9f 28 03				jr z, .enoupdate 
bda1 cd ce 8a						call update_display 
bda4					.enoupdate: 
bda4			 
bda4 3a 55 ea				ld a, (f_cursor_ptr) 
bda7 3c					inc a 
bda8 32 55 ea				ld (f_cursor_ptr), a   ; save new pos 
bdab			 
bdab			 
bdab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdab cd 7b 9c			call macro_forth_dsp_pop 
bdae				endm 
# End of macro FORTH_DSP_POP
bdae			  
bdae			 
bdae					NEXTW 
bdae cd 6c ee			call parse_vector 
bdb1 c3 aa 9d			jp macro_next 
bdb4				endm 
# End of macro NEXTW
bdb4			.DOTH: 
bdb4				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
bdb4 1c				db WORD_SYS_CORE+8             
bdb5 e7 bd			dw .DOTF            
bdb7 03				db 2 + 1 
bdb8 .. 00			db ".-",0              
bdbb				endm 
# End of macro CWHEAD
bdbb			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
bdbb					; get value off TOS and display it 
bdbb					if DEBUG_FORTH_WORDS_KEY 
bdbb						DMARK "DTD" 
bdbb f5				push af  
bdbc 3a d0 bd			ld a, (.dmark)  
bdbf 32 62 ee			ld (debug_mark),a  
bdc2 3a d1 bd			ld a, (.dmark+1)  
bdc5 32 63 ee			ld (debug_mark+1),a  
bdc8 3a d2 bd			ld a, (.dmark+2)  
bdcb 32 64 ee			ld (debug_mark+2),a  
bdce 18 03			jr .pastdmark  
bdd0 ..			.dmark: db "DTD"  
bdd3 f1			.pastdmark: pop af  
bdd4			endm  
# End of macro DMARK
bdd4						CALLMONITOR 
bdd4 cd 6f ee			call debug_vector  
bdd7				endm  
# End of macro CALLMONITOR
bdd7					endif 
bdd7 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
bdd9 3e 00			ld a, 0 
bddb 32 34 ea			ld (cli_mvdot), a 
bdde c3 41 be			jp .dotgo 
bde1				NEXTW 
bde1 cd 6c ee			call parse_vector 
bde4 c3 aa 9d			jp macro_next 
bde7				endm 
# End of macro NEXTW
bde7			.DOTF: 
bde7				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
bde7 1c				db WORD_SYS_CORE+8             
bde8 18 be			dw .DOT            
bdea 03				db 2 + 1 
bdeb .. 00			db ".>",0              
bdee				endm 
# End of macro CWHEAD
bdee			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
bdee					; get value off TOS and display it 
bdee			        ; TODO BUG adds extra spaces 
bdee			        ; TODO BUG handle numerics? 
bdee					if DEBUG_FORTH_WORDS_KEY 
bdee						DMARK "DTC" 
bdee f5				push af  
bdef 3a 03 be			ld a, (.dmark)  
bdf2 32 62 ee			ld (debug_mark),a  
bdf5 3a 04 be			ld a, (.dmark+1)  
bdf8 32 63 ee			ld (debug_mark+1),a  
bdfb 3a 05 be			ld a, (.dmark+2)  
bdfe 32 64 ee			ld (debug_mark+2),a  
be01 18 03			jr .pastdmark  
be03 ..			.dmark: db "DTC"  
be06 f1			.pastdmark: pop af  
be07			endm  
# End of macro DMARK
be07						CALLMONITOR 
be07 cd 6f ee			call debug_vector  
be0a				endm  
# End of macro CALLMONITOR
be0a					endif 
be0a 3e 01			ld a, 1 
be0c 32 34 ea			ld (cli_mvdot), a 
be0f c3 41 be			jp .dotgo 
be12				NEXTW 
be12 cd 6c ee			call parse_vector 
be15 c3 aa 9d			jp macro_next 
be18				endm 
# End of macro NEXTW
be18			 
be18			.DOT: 
be18				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
be18 1c				db WORD_SYS_CORE+8             
be19 f3 bf			dw .CLS            
be1b 02				db 1 + 1 
be1c .. 00			db ".",0              
be1e				endm 
# End of macro CWHEAD
be1e			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
be1e					; get value off TOS and display it 
be1e			 
be1e					if DEBUG_FORTH_WORDS_KEY 
be1e						DMARK "DOT" 
be1e f5				push af  
be1f 3a 33 be			ld a, (.dmark)  
be22 32 62 ee			ld (debug_mark),a  
be25 3a 34 be			ld a, (.dmark+1)  
be28 32 63 ee			ld (debug_mark+1),a  
be2b 3a 35 be			ld a, (.dmark+2)  
be2e 32 64 ee			ld (debug_mark+2),a  
be31 18 03			jr .pastdmark  
be33 ..			.dmark: db "DOT"  
be36 f1			.pastdmark: pop af  
be37			endm  
# End of macro DMARK
be37						CALLMONITOR 
be37 cd 6f ee			call debug_vector  
be3a				endm  
# End of macro CALLMONITOR
be3a					endif 
be3a 3e 00			ld a, 0 
be3c 32 34 ea			ld (cli_mvdot), a 
be3f 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
be41				 
be41			 
be41			.dotgo: 
be41			 
be41			; move up type to on stack for parserv5 
be41					FORTH_DSP 
be41 cd 89 9b			call macro_forth_dsp 
be44				endm 
# End of macro FORTH_DSP
be44				;FORTH_DSP_VALUE  
be44			 
be44			if DEBUG_FORTH_DOT 
be44				DMARK "DOT" 
be44 f5				push af  
be45 3a 59 be			ld a, (.dmark)  
be48 32 62 ee			ld (debug_mark),a  
be4b 3a 5a be			ld a, (.dmark+1)  
be4e 32 63 ee			ld (debug_mark+1),a  
be51 3a 5b be			ld a, (.dmark+2)  
be54 32 64 ee			ld (debug_mark+2),a  
be57 18 03			jr .pastdmark  
be59 ..			.dmark: db "DOT"  
be5c f1			.pastdmark: pop af  
be5d			endm  
# End of macro DMARK
be5d				CALLMONITOR 
be5d cd 6f ee			call debug_vector  
be60				endm  
# End of macro CALLMONITOR
be60			endif	 
be60			;		.print: 
be60			 
be60 7e				ld a,(hl)  ; work out what type of value is on the TOS 
be61 23				inc hl   ; position to the actual value 
be62 fe 01			cp DS_TYPE_STR 
be64 20 06			jr nz, .dotnum1  
be66			 
be66			; display string 
be66				FORTH_DSP_VALUE  
be66 cd ac 9b			call macro_forth_dsp_value 
be69				endm 
# End of macro FORTH_DSP_VALUE
be69 eb				ex de,hl 
be6a 18 49			jr .dotwrite 
be6c			 
be6c			.dotnum1: 
be6c fe 02			cp DS_TYPE_INUM 
be6e 20 44			jr nz, .dotflot 
be70			 
be70			 
be70			; display number 
be70			 
be70			;	push hl 
be70			;	call clear_display 
be70			;	pop hl 
be70			 
be70 5e				ld e, (hl) 
be71 23				inc hl 
be72 56				ld d, (hl) 
be73 21 b8 e2			ld hl, scratch 
be76			if DEBUG_FORTH_DOT 
be76				DMARK "DT1" 
be76 f5				push af  
be77 3a 8b be			ld a, (.dmark)  
be7a 32 62 ee			ld (debug_mark),a  
be7d 3a 8c be			ld a, (.dmark+1)  
be80 32 63 ee			ld (debug_mark+1),a  
be83 3a 8d be			ld a, (.dmark+2)  
be86 32 64 ee			ld (debug_mark+2),a  
be89 18 03			jr .pastdmark  
be8b ..			.dmark: db "DT1"  
be8e f1			.pastdmark: pop af  
be8f			endm  
# End of macro DMARK
be8f				CALLMONITOR 
be8f cd 6f ee			call debug_vector  
be92				endm  
# End of macro CALLMONITOR
be92			endif	 
be92			 
be92 cd dd 8f			call uitoa_16 
be95 eb				ex de,hl 
be96			 
be96			if DEBUG_FORTH_DOT 
be96				DMARK "DT2" 
be96 f5				push af  
be97 3a ab be			ld a, (.dmark)  
be9a 32 62 ee			ld (debug_mark),a  
be9d 3a ac be			ld a, (.dmark+1)  
bea0 32 63 ee			ld (debug_mark+1),a  
bea3 3a ad be			ld a, (.dmark+2)  
bea6 32 64 ee			ld (debug_mark+2),a  
bea9 18 03			jr .pastdmark  
beab ..			.dmark: db "DT2"  
beae f1			.pastdmark: pop af  
beaf			endm  
# End of macro DMARK
beaf				CALLMONITOR 
beaf cd 6f ee			call debug_vector  
beb2				endm  
# End of macro CALLMONITOR
beb2			endif	 
beb2			 
beb2			;	ld de, os_word_scratch 
beb2 18 01			jr .dotwrite 
beb4			 
beb4 00			.dotflot:   nop 
beb5			; TODO print floating point number 
beb5			 
beb5			.dotwrite:		 
beb5			 
beb5					; if c is set then set all '-' to spaces 
beb5					; need to also take into account .>  
beb5			 
beb5 3e 01				ld a, 1 
beb7 b9					cp c 
beb8 20 65				jr nz, .nodashswap 
beba			 
beba					; DE has the string to write, working with HL 
beba			 
beba 06 ff				ld b, 255 
bebc d5					push de 
bebd e1					pop hl 
bebe			 
bebe			if DEBUG_FORTH_DOT 
bebe				DMARK "DT-" 
bebe f5				push af  
bebf 3a d3 be			ld a, (.dmark)  
bec2 32 62 ee			ld (debug_mark),a  
bec5 3a d4 be			ld a, (.dmark+1)  
bec8 32 63 ee			ld (debug_mark+1),a  
becb 3a d5 be			ld a, (.dmark+2)  
bece 32 64 ee			ld (debug_mark+2),a  
bed1 18 03			jr .pastdmark  
bed3 ..			.dmark: db "DT-"  
bed6 f1			.pastdmark: pop af  
bed7			endm  
# End of macro DMARK
bed7				CALLMONITOR 
bed7 cd 6f ee			call debug_vector  
beda				endm  
# End of macro CALLMONITOR
beda			endif	 
beda 7e			.dashscan:	ld a, (hl) 
bedb			;		cp 0 
bedb b7					or a 
bedc 28 41				jr z, .nodashswap 
bede fe 2d				cp '-' 
bee0 20 02				jr nz, .dashskip 
bee2			;		ld a, ' ' 
bee2 36 20				ld (hl), ' ' 
bee4 23			.dashskip:	inc hl 
bee5			if DEBUG_FORTH_DOT 
bee5				DMARK "D-2" 
bee5 f5				push af  
bee6 3a fa be			ld a, (.dmark)  
bee9 32 62 ee			ld (debug_mark),a  
beec 3a fb be			ld a, (.dmark+1)  
beef 32 63 ee			ld (debug_mark+1),a  
bef2 3a fc be			ld a, (.dmark+2)  
bef5 32 64 ee			ld (debug_mark+2),a  
bef8 18 03			jr .pastdmark  
befa ..			.dmark: db "D-2"  
befd f1			.pastdmark: pop af  
befe			endm  
# End of macro DMARK
befe				CALLMONITOR 
befe cd 6f ee			call debug_vector  
bf01				endm  
# End of macro CALLMONITOR
bf01			endif	 
bf01 10 d7				djnz .dashscan 
bf03			 
bf03			if DEBUG_FORTH_DOT 
bf03				DMARK "D-1" 
bf03 f5				push af  
bf04 3a 18 bf			ld a, (.dmark)  
bf07 32 62 ee			ld (debug_mark),a  
bf0a 3a 19 bf			ld a, (.dmark+1)  
bf0d 32 63 ee			ld (debug_mark+1),a  
bf10 3a 1a bf			ld a, (.dmark+2)  
bf13 32 64 ee			ld (debug_mark+2),a  
bf16 18 03			jr .pastdmark  
bf18 ..			.dmark: db "D-1"  
bf1b f1			.pastdmark: pop af  
bf1c			endm  
# End of macro DMARK
bf1c				CALLMONITOR 
bf1c cd 6f ee			call debug_vector  
bf1f				endm  
# End of macro CALLMONITOR
bf1f			endif	 
bf1f			 
bf1f			.nodashswap: 
bf1f			 
bf1f			if DEBUG_FORTH_DOT 
bf1f				DMARK "D-o" 
bf1f f5				push af  
bf20 3a 34 bf			ld a, (.dmark)  
bf23 32 62 ee			ld (debug_mark),a  
bf26 3a 35 bf			ld a, (.dmark+1)  
bf29 32 63 ee			ld (debug_mark+1),a  
bf2c 3a 36 bf			ld a, (.dmark+2)  
bf2f 32 64 ee			ld (debug_mark+2),a  
bf32 18 03			jr .pastdmark  
bf34 ..			.dmark: db "D-o"  
bf37 f1			.pastdmark: pop af  
bf38			endm  
# End of macro DMARK
bf38				CALLMONITOR 
bf38 cd 6f ee			call debug_vector  
bf3b				endm  
# End of macro CALLMONITOR
bf3b			endif	 
bf3b			 
bf3b d5					push de   ; save string start in case we need to advance print 
bf3c			 
bf3c 3a 55 ea				ld a, (f_cursor_ptr) 
bf3f cd be 8a				call str_at_display 
bf42 3a 33 ea				ld a,(cli_autodisplay) 
bf45			;		cp 0 
bf45 b7					or a 
bf46 28 03				jr z, .noupdate 
bf48 cd ce 8a						call update_display 
bf4b					.noupdate: 
bf4b			 
bf4b			 
bf4b					; see if we need to advance the print position 
bf4b			 
bf4b e1					pop hl   ; get back string 
bf4c			;		ex de,hl 
bf4c			 
bf4c 3a 34 ea				ld a, (cli_mvdot) 
bf4f			if DEBUG_FORTH_DOT 
bf4f			;		ld e,a 
bf4f				DMARK "D>1" 
bf4f f5				push af  
bf50 3a 64 bf			ld a, (.dmark)  
bf53 32 62 ee			ld (debug_mark),a  
bf56 3a 65 bf			ld a, (.dmark+1)  
bf59 32 63 ee			ld (debug_mark+1),a  
bf5c 3a 66 bf			ld a, (.dmark+2)  
bf5f 32 64 ee			ld (debug_mark+2),a  
bf62 18 03			jr .pastdmark  
bf64 ..			.dmark: db "D>1"  
bf67 f1			.pastdmark: pop af  
bf68			endm  
# End of macro DMARK
bf68				CALLMONITOR 
bf68 cd 6f ee			call debug_vector  
bf6b				endm  
# End of macro CALLMONITOR
bf6b			endif	 
bf6b			;		cp 0 
bf6b b7					or a 
bf6c 28 44				jr z, .noadv 
bf6e					; yes, lets advance the print position 
bf6e 3e 00				ld a, 0 
bf70 cd 39 90				call strlent 
bf73			if DEBUG_FORTH_DOT 
bf73				DMARK "D-?" 
bf73 f5				push af  
bf74 3a 88 bf			ld a, (.dmark)  
bf77 32 62 ee			ld (debug_mark),a  
bf7a 3a 89 bf			ld a, (.dmark+1)  
bf7d 32 63 ee			ld (debug_mark+1),a  
bf80 3a 8a bf			ld a, (.dmark+2)  
bf83 32 64 ee			ld (debug_mark+2),a  
bf86 18 03			jr .pastdmark  
bf88 ..			.dmark: db "D-?"  
bf8b f1			.pastdmark: pop af  
bf8c			endm  
# End of macro DMARK
bf8c				CALLMONITOR 
bf8c cd 6f ee			call debug_vector  
bf8f				endm  
# End of macro CALLMONITOR
bf8f			endif	 
bf8f 3a 55 ea				ld a, (f_cursor_ptr) 
bf92 85					add a,l 
bf93					;call addatohl 
bf93					;ld a, l 
bf93 32 55 ea				ld (f_cursor_ptr), a   ; save new pos 
bf96			 
bf96			if DEBUG_FORTH_DOT 
bf96				DMARK "D->" 
bf96 f5				push af  
bf97 3a ab bf			ld a, (.dmark)  
bf9a 32 62 ee			ld (debug_mark),a  
bf9d 3a ac bf			ld a, (.dmark+1)  
bfa0 32 63 ee			ld (debug_mark+1),a  
bfa3 3a ad bf			ld a, (.dmark+2)  
bfa6 32 64 ee			ld (debug_mark+2),a  
bfa9 18 03			jr .pastdmark  
bfab ..			.dmark: db "D->"  
bfae f1			.pastdmark: pop af  
bfaf			endm  
# End of macro DMARK
bfaf				CALLMONITOR 
bfaf cd 6f ee			call debug_vector  
bfb2				endm  
# End of macro CALLMONITOR
bfb2			endif	 
bfb2			 
bfb2			.noadv:	 
bfb2			 
bfb2					if DEBUG_FORTH_DOT_WAIT 
bfb2							call next_page_prompt 
bfb2					endif	 
bfb2			; TODO this pop off the stack causes a crash. i dont know why 
bfb2			 
bfb2			 
bfb2			if DEBUG_FORTH_DOT 
bfb2				DMARK "DTh" 
bfb2 f5				push af  
bfb3 3a c7 bf			ld a, (.dmark)  
bfb6 32 62 ee			ld (debug_mark),a  
bfb9 3a c8 bf			ld a, (.dmark+1)  
bfbc 32 63 ee			ld (debug_mark+1),a  
bfbf 3a c9 bf			ld a, (.dmark+2)  
bfc2 32 64 ee			ld (debug_mark+2),a  
bfc5 18 03			jr .pastdmark  
bfc7 ..			.dmark: db "DTh"  
bfca f1			.pastdmark: pop af  
bfcb			endm  
# End of macro DMARK
bfcb				CALLMONITOR 
bfcb cd 6f ee			call debug_vector  
bfce				endm  
# End of macro CALLMONITOR
bfce			endif	 
bfce			 
bfce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfce cd 7b 9c			call macro_forth_dsp_pop 
bfd1				endm 
# End of macro FORTH_DSP_POP
bfd1			 
bfd1			if DEBUG_FORTH_DOT 
bfd1				DMARK "DTi" 
bfd1 f5				push af  
bfd2 3a e6 bf			ld a, (.dmark)  
bfd5 32 62 ee			ld (debug_mark),a  
bfd8 3a e7 bf			ld a, (.dmark+1)  
bfdb 32 63 ee			ld (debug_mark+1),a  
bfde 3a e8 bf			ld a, (.dmark+2)  
bfe1 32 64 ee			ld (debug_mark+2),a  
bfe4 18 03			jr .pastdmark  
bfe6 ..			.dmark: db "DTi"  
bfe9 f1			.pastdmark: pop af  
bfea			endm  
# End of macro DMARK
bfea				CALLMONITOR 
bfea cd 6f ee			call debug_vector  
bfed				endm  
# End of macro CALLMONITOR
bfed			endif	 
bfed			 
bfed			 
bfed					NEXTW 
bfed cd 6c ee			call parse_vector 
bff0 c3 aa 9d			jp macro_next 
bff3				endm 
# End of macro NEXTW
bff3			 
bff3			.CLS: 
bff3				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bff3 35				db WORD_SYS_CORE+33             
bff4 23 c0			dw .DRAW            
bff6 04				db 3 + 1 
bff7 .. 00			db "CLS",0              
bffb				endm 
# End of macro CWHEAD
bffb			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bffb					if DEBUG_FORTH_WORDS_KEY 
bffb						DMARK "CLS" 
bffb f5				push af  
bffc 3a 10 c0			ld a, (.dmark)  
bfff 32 62 ee			ld (debug_mark),a  
c002 3a 11 c0			ld a, (.dmark+1)  
c005 32 63 ee			ld (debug_mark+1),a  
c008 3a 12 c0			ld a, (.dmark+2)  
c00b 32 64 ee			ld (debug_mark+2),a  
c00e 18 03			jr .pastdmark  
c010 ..			.dmark: db "CLS"  
c013 f1			.pastdmark: pop af  
c014			endm  
# End of macro DMARK
c014						CALLMONITOR 
c014 cd 6f ee			call debug_vector  
c017				endm  
# End of macro CALLMONITOR
c017					endif 
c017 cd ac 8a				call clear_display 
c01a c3 3d c1				jp .home		; and home cursor 
c01d					NEXTW 
c01d cd 6c ee			call parse_vector 
c020 c3 aa 9d			jp macro_next 
c023				endm 
# End of macro NEXTW
c023			 
c023			.DRAW: 
c023				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
c023 36				db WORD_SYS_CORE+34             
c024 51 c0			dw .DUMP            
c026 05				db 4 + 1 
c027 .. 00			db "DRAW",0              
c02c				endm 
# End of macro CWHEAD
c02c			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
c02c					if DEBUG_FORTH_WORDS_KEY 
c02c						DMARK "DRW" 
c02c f5				push af  
c02d 3a 41 c0			ld a, (.dmark)  
c030 32 62 ee			ld (debug_mark),a  
c033 3a 42 c0			ld a, (.dmark+1)  
c036 32 63 ee			ld (debug_mark+1),a  
c039 3a 43 c0			ld a, (.dmark+2)  
c03c 32 64 ee			ld (debug_mark+2),a  
c03f 18 03			jr .pastdmark  
c041 ..			.dmark: db "DRW"  
c044 f1			.pastdmark: pop af  
c045			endm  
# End of macro DMARK
c045						CALLMONITOR 
c045 cd 6f ee			call debug_vector  
c048				endm  
# End of macro CALLMONITOR
c048					endif 
c048 cd ce 8a				call update_display 
c04b					NEXTW 
c04b cd 6c ee			call parse_vector 
c04e c3 aa 9d			jp macro_next 
c051				endm 
# End of macro NEXTW
c051			 
c051			.DUMP: 
c051				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
c051 37				db WORD_SYS_CORE+35             
c052 8c c0			dw .CDUMP            
c054 05				db 4 + 1 
c055 .. 00			db "DUMP",0              
c05a				endm 
# End of macro CWHEAD
c05a			; | DUMP ( x -- ) With address x display dump   | DONE 
c05a			; TODO pop address to use off of the stack 
c05a					if DEBUG_FORTH_WORDS_KEY 
c05a						DMARK "DUM" 
c05a f5				push af  
c05b 3a 6f c0			ld a, (.dmark)  
c05e 32 62 ee			ld (debug_mark),a  
c061 3a 70 c0			ld a, (.dmark+1)  
c064 32 63 ee			ld (debug_mark+1),a  
c067 3a 71 c0			ld a, (.dmark+2)  
c06a 32 64 ee			ld (debug_mark+2),a  
c06d 18 03			jr .pastdmark  
c06f ..			.dmark: db "DUM"  
c072 f1			.pastdmark: pop af  
c073			endm  
# End of macro DMARK
c073						CALLMONITOR 
c073 cd 6f ee			call debug_vector  
c076				endm  
# End of macro CALLMONITOR
c076					endif 
c076 cd ac 8a				call clear_display 
c079			 
c079					; get address 
c079			 
c079					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c079 cd c3 9b			call macro_dsp_valuehl 
c07c				endm 
# End of macro FORTH_DSP_VALUEHL
c07c				 
c07c					; save it for cdump 
c07c			 
c07c 22 db e5				ld (os_cur_ptr),hl 
c07f			 
c07f					; destroy value TOS 
c07f			 
c07f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c07f cd 7b 9c			call macro_forth_dsp_pop 
c082				endm 
# End of macro FORTH_DSP_POP
c082			 
c082 cd 4b 98				call dumpcont	; skip old style of param parsing	 
c085 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
c086					NEXTW 
c086 cd 6c ee			call parse_vector 
c089 c3 aa 9d			jp macro_next 
c08c				endm 
# End of macro NEXTW
c08c			.CDUMP: 
c08c				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
c08c 38				db WORD_SYS_CORE+36             
c08d bf c0			dw .DAT            
c08f 06				db 5 + 1 
c090 .. 00			db "CDUMP",0              
c096				endm 
# End of macro CWHEAD
c096			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
c096					if DEBUG_FORTH_WORDS_KEY 
c096						DMARK "CDP" 
c096 f5				push af  
c097 3a ab c0			ld a, (.dmark)  
c09a 32 62 ee			ld (debug_mark),a  
c09d 3a ac c0			ld a, (.dmark+1)  
c0a0 32 63 ee			ld (debug_mark+1),a  
c0a3 3a ad c0			ld a, (.dmark+2)  
c0a6 32 64 ee			ld (debug_mark+2),a  
c0a9 18 03			jr .pastdmark  
c0ab ..			.dmark: db "CDP"  
c0ae f1			.pastdmark: pop af  
c0af			endm  
# End of macro DMARK
c0af						CALLMONITOR 
c0af cd 6f ee			call debug_vector  
c0b2				endm  
# End of macro CALLMONITOR
c0b2					endif 
c0b2 cd ac 8a				call clear_display 
c0b5 cd 4b 98				call dumpcont	 
c0b8 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
c0b9					NEXTW 
c0b9 cd 6c ee			call parse_vector 
c0bc c3 aa 9d			jp macro_next 
c0bf				endm 
# End of macro NEXTW
c0bf			 
c0bf			 
c0bf			 
c0bf			 
c0bf			.DAT: 
c0bf				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
c0bf 3d				db WORD_SYS_CORE+41             
c0c0 18 c1			dw .HOME            
c0c2 03				db 2 + 1 
c0c3 .. 00			db "AT",0              
c0c6				endm 
# End of macro CWHEAD
c0c6			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
c0c6					if DEBUG_FORTH_WORDS_KEY 
c0c6						DMARK "AT." 
c0c6 f5				push af  
c0c7 3a db c0			ld a, (.dmark)  
c0ca 32 62 ee			ld (debug_mark),a  
c0cd 3a dc c0			ld a, (.dmark+1)  
c0d0 32 63 ee			ld (debug_mark+1),a  
c0d3 3a dd c0			ld a, (.dmark+2)  
c0d6 32 64 ee			ld (debug_mark+2),a  
c0d9 18 03			jr .pastdmark  
c0db ..			.dmark: db "AT."  
c0de f1			.pastdmark: pop af  
c0df			endm  
# End of macro DMARK
c0df						CALLMONITOR 
c0df cd 6f ee			call debug_vector  
c0e2				endm  
# End of macro CALLMONITOR
c0e2					endif 
c0e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c0e2 cd c3 9b			call macro_dsp_valuehl 
c0e5				endm 
# End of macro FORTH_DSP_VALUEHL
c0e5			 
c0e5			 
c0e5					; TODO save cursor row 
c0e5 7d					ld a,l 
c0e6 fe 02				cp 2 
c0e8 20 04				jr nz, .crow3 
c0ea 3e 28				ld a, display_row_2 
c0ec 18 12				jr .ccol1 
c0ee fe 03		.crow3:		cp 3 
c0f0 20 04				jr nz, .crow4 
c0f2 3e 50				ld a, display_row_3 
c0f4 18 0a				jr .ccol1 
c0f6 fe 04		.crow4:		cp 4 
c0f8 20 04				jr nz, .crow1 
c0fa 3e 78				ld a, display_row_4 
c0fc 18 02				jr .ccol1 
c0fe 3e 00		.crow1:		ld a,display_row_1 
c100 f5			.ccol1:		push af			; got row offset 
c101 6f					ld l,a 
c102 26 00				ld h,0 
c104					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c104 cd 7b 9c			call macro_forth_dsp_pop 
c107				endm 
# End of macro FORTH_DSP_POP
c107					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c107 cd c3 9b			call macro_dsp_valuehl 
c10a				endm 
# End of macro FORTH_DSP_VALUEHL
c10a					; TODO save cursor col 
c10a f1					pop af 
c10b 85					add l		; add col offset 
c10c 32 55 ea				ld (f_cursor_ptr), a 
c10f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c10f cd 7b 9c			call macro_forth_dsp_pop 
c112				endm 
# End of macro FORTH_DSP_POP
c112			 
c112					; calculate  
c112			 
c112					NEXTW 
c112 cd 6c ee			call parse_vector 
c115 c3 aa 9d			jp macro_next 
c118				endm 
# End of macro NEXTW
c118			 
c118			 
c118			.HOME: 
c118				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
c118 41				db WORD_SYS_CORE+45             
c119 48 c1			dw .CR            
c11b 05				db 4 + 1 
c11c .. 00			db "HOME",0              
c121				endm 
# End of macro CWHEAD
c121			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
c121					if DEBUG_FORTH_WORDS_KEY 
c121						DMARK "HOM" 
c121 f5				push af  
c122 3a 36 c1			ld a, (.dmark)  
c125 32 62 ee			ld (debug_mark),a  
c128 3a 37 c1			ld a, (.dmark+1)  
c12b 32 63 ee			ld (debug_mark+1),a  
c12e 3a 38 c1			ld a, (.dmark+2)  
c131 32 64 ee			ld (debug_mark+2),a  
c134 18 03			jr .pastdmark  
c136 ..			.dmark: db "HOM"  
c139 f1			.pastdmark: pop af  
c13a			endm  
# End of macro DMARK
c13a						CALLMONITOR 
c13a cd 6f ee			call debug_vector  
c13d				endm  
# End of macro CALLMONITOR
c13d					endif 
c13d 3e 00		.home:		ld a, 0		; and home cursor 
c13f 32 55 ea				ld (f_cursor_ptr), a 
c142					NEXTW 
c142 cd 6c ee			call parse_vector 
c145 c3 aa 9d			jp macro_next 
c148				endm 
# End of macro NEXTW
c148			 
c148			 
c148			.CR: 
c148				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
c148 46				db WORD_SYS_CORE+50             
c149 86 c1			dw .SPACE            
c14b 03				db 2 + 1 
c14c .. 00			db "CR",0              
c14f				endm 
# End of macro CWHEAD
c14f			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
c14f					if DEBUG_FORTH_WORDS_KEY 
c14f						DMARK "CR." 
c14f f5				push af  
c150 3a 64 c1			ld a, (.dmark)  
c153 32 62 ee			ld (debug_mark),a  
c156 3a 65 c1			ld a, (.dmark+1)  
c159 32 63 ee			ld (debug_mark+1),a  
c15c 3a 66 c1			ld a, (.dmark+2)  
c15f 32 64 ee			ld (debug_mark+2),a  
c162 18 03			jr .pastdmark  
c164 ..			.dmark: db "CR."  
c167 f1			.pastdmark: pop af  
c168			endm  
# End of macro DMARK
c168						CALLMONITOR 
c168 cd 6f ee			call debug_vector  
c16b				endm  
# End of macro CALLMONITOR
c16b					endif 
c16b 3e 0d				ld a, 13 
c16d 32 b8 e2				ld (scratch),a 
c170 3e 0a				ld a, 10 
c172 32 b9 e2				ld (scratch+1),a 
c175 3e 00				ld a, 0 
c177 32 ba e2				ld (scratch+2),a 
c17a 21 b8 e2				ld hl, scratch 
c17d cd 31 9a				call forth_push_str 
c180					 
c180				       NEXTW 
c180 cd 6c ee			call parse_vector 
c183 c3 aa 9d			jp macro_next 
c186				endm 
# End of macro NEXTW
c186			.SPACE: 
c186				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
c186 46				db WORD_SYS_CORE+50             
c187 bf c1			dw .SPACES            
c189 03				db 2 + 1 
c18a .. 00			db "BL",0              
c18d				endm 
# End of macro CWHEAD
c18d			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
c18d					if DEBUG_FORTH_WORDS_KEY 
c18d						DMARK "BL." 
c18d f5				push af  
c18e 3a a2 c1			ld a, (.dmark)  
c191 32 62 ee			ld (debug_mark),a  
c194 3a a3 c1			ld a, (.dmark+1)  
c197 32 63 ee			ld (debug_mark+1),a  
c19a 3a a4 c1			ld a, (.dmark+2)  
c19d 32 64 ee			ld (debug_mark+2),a  
c1a0 18 03			jr .pastdmark  
c1a2 ..			.dmark: db "BL."  
c1a5 f1			.pastdmark: pop af  
c1a6			endm  
# End of macro DMARK
c1a6						CALLMONITOR 
c1a6 cd 6f ee			call debug_vector  
c1a9				endm  
# End of macro CALLMONITOR
c1a9					endif 
c1a9 3e 20				ld a, " " 
c1ab 32 b8 e2				ld (scratch),a 
c1ae 3e 00				ld a, 0 
c1b0 32 b9 e2				ld (scratch+1),a 
c1b3 21 b8 e2				ld hl, scratch 
c1b6 cd 31 9a				call forth_push_str 
c1b9					 
c1b9				       NEXTW 
c1b9 cd 6c ee			call parse_vector 
c1bc c3 aa 9d			jp macro_next 
c1bf				endm 
# End of macro NEXTW
c1bf			 
c1bf			;.blstr: db " ", 0 
c1bf			 
c1bf			.SPACES: 
c1bf				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
c1bf 47				db WORD_SYS_CORE+51             
c1c0 5b c2			dw .SCROLL            
c1c2 07				db 6 + 1 
c1c3 .. 00			db "SPACES",0              
c1ca				endm 
# End of macro CWHEAD
c1ca			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
c1ca					if DEBUG_FORTH_WORDS_KEY 
c1ca						DMARK "SPS" 
c1ca f5				push af  
c1cb 3a df c1			ld a, (.dmark)  
c1ce 32 62 ee			ld (debug_mark),a  
c1d1 3a e0 c1			ld a, (.dmark+1)  
c1d4 32 63 ee			ld (debug_mark+1),a  
c1d7 3a e1 c1			ld a, (.dmark+2)  
c1da 32 64 ee			ld (debug_mark+2),a  
c1dd 18 03			jr .pastdmark  
c1df ..			.dmark: db "SPS"  
c1e2 f1			.pastdmark: pop af  
c1e3			endm  
# End of macro DMARK
c1e3						CALLMONITOR 
c1e3 cd 6f ee			call debug_vector  
c1e6				endm  
# End of macro CALLMONITOR
c1e6					endif 
c1e6			 
c1e6			 
c1e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c1e6 cd c3 9b			call macro_dsp_valuehl 
c1e9				endm 
# End of macro FORTH_DSP_VALUEHL
c1e9			 
c1e9 e5					push hl    ; u 
c1ea					if DEBUG_FORTH_WORDS 
c1ea						DMARK "SPA" 
c1ea f5				push af  
c1eb 3a ff c1			ld a, (.dmark)  
c1ee 32 62 ee			ld (debug_mark),a  
c1f1 3a 00 c2			ld a, (.dmark+1)  
c1f4 32 63 ee			ld (debug_mark+1),a  
c1f7 3a 01 c2			ld a, (.dmark+2)  
c1fa 32 64 ee			ld (debug_mark+2),a  
c1fd 18 03			jr .pastdmark  
c1ff ..			.dmark: db "SPA"  
c202 f1			.pastdmark: pop af  
c203			endm  
# End of macro DMARK
c203						CALLMONITOR 
c203 cd 6f ee			call debug_vector  
c206				endm  
# End of macro CALLMONITOR
c206					endif 
c206			 
c206					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c206 cd 7b 9c			call macro_forth_dsp_pop 
c209				endm 
# End of macro FORTH_DSP_POP
c209 e1					pop hl 
c20a 0e 00				ld c, 0 
c20c 45					ld b, l 
c20d 21 b8 e2				ld hl, scratch  
c210			 
c210					if DEBUG_FORTH_WORDS 
c210						DMARK "SP2" 
c210 f5				push af  
c211 3a 25 c2			ld a, (.dmark)  
c214 32 62 ee			ld (debug_mark),a  
c217 3a 26 c2			ld a, (.dmark+1)  
c21a 32 63 ee			ld (debug_mark+1),a  
c21d 3a 27 c2			ld a, (.dmark+2)  
c220 32 64 ee			ld (debug_mark+2),a  
c223 18 03			jr .pastdmark  
c225 ..			.dmark: db "SP2"  
c228 f1			.pastdmark: pop af  
c229			endm  
# End of macro DMARK
c229						CALLMONITOR 
c229 cd 6f ee			call debug_vector  
c22c				endm  
# End of macro CALLMONITOR
c22c					endif 
c22c			;		ld a, ' ' 
c22c			.spaces1:	 
c22c 36 20				ld (hl),' ' 
c22e 23					inc hl 
c22f					 
c22f 10 fb				djnz .spaces1 
c231			;		ld a,0 
c231 36 00				ld (hl),0 
c233 21 b8 e2				ld hl, scratch 
c236					if DEBUG_FORTH_WORDS 
c236						DMARK "SP3" 
c236 f5				push af  
c237 3a 4b c2			ld a, (.dmark)  
c23a 32 62 ee			ld (debug_mark),a  
c23d 3a 4c c2			ld a, (.dmark+1)  
c240 32 63 ee			ld (debug_mark+1),a  
c243 3a 4d c2			ld a, (.dmark+2)  
c246 32 64 ee			ld (debug_mark+2),a  
c249 18 03			jr .pastdmark  
c24b ..			.dmark: db "SP3"  
c24e f1			.pastdmark: pop af  
c24f			endm  
# End of macro DMARK
c24f						CALLMONITOR 
c24f cd 6f ee			call debug_vector  
c252				endm  
# End of macro CALLMONITOR
c252					endif 
c252 cd 31 9a				call forth_push_str 
c255			 
c255				       NEXTW 
c255 cd 6c ee			call parse_vector 
c258 c3 aa 9d			jp macro_next 
c25b				endm 
# End of macro NEXTW
c25b			 
c25b			 
c25b			 
c25b			.SCROLL: 
c25b				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
c25b 53				db WORD_SYS_CORE+63             
c25c 8b c2			dw .SCROLLD            
c25e 07				db 6 + 1 
c25f .. 00			db "SCROLL",0              
c266				endm 
# End of macro CWHEAD
c266			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
c266					if DEBUG_FORTH_WORDS_KEY 
c266						DMARK "SCR" 
c266 f5				push af  
c267 3a 7b c2			ld a, (.dmark)  
c26a 32 62 ee			ld (debug_mark),a  
c26d 3a 7c c2			ld a, (.dmark+1)  
c270 32 63 ee			ld (debug_mark+1),a  
c273 3a 7d c2			ld a, (.dmark+2)  
c276 32 64 ee			ld (debug_mark+2),a  
c279 18 03			jr .pastdmark  
c27b ..			.dmark: db "SCR"  
c27e f1			.pastdmark: pop af  
c27f			endm  
# End of macro DMARK
c27f						CALLMONITOR 
c27f cd 6f ee			call debug_vector  
c282				endm  
# End of macro CALLMONITOR
c282					endif 
c282			 
c282 cd 6f 8a			call scroll_up 
c285			;	call update_display 
c285			 
c285					NEXTW 
c285 cd 6c ee			call parse_vector 
c288 c3 aa 9d			jp macro_next 
c28b				endm 
# End of macro NEXTW
c28b			 
c28b			 
c28b			 
c28b			;		; get dir 
c28b			; 
c28b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c28b			; 
c28b			;		push hl 
c28b			; 
c28b			;		; destroy value TOS 
c28b			; 
c28b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c28b			; 
c28b			;		; get count 
c28b			; 
c28b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c28b			; 
c28b			;		push hl 
c28b			; 
c28b			;		; destroy value TOS 
c28b			; 
c28b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c28b			; 
c28b			;		; one value on hl get other one back 
c28b			; 
c28b			;		pop bc    ; count 
c28b			; 
c28b			;		pop de   ; dir 
c28b			; 
c28b			; 
c28b			;		ld b, c 
c28b			; 
c28b			;.scrolldir:     push bc 
c28b			;		push de 
c28b			; 
c28b			;		ld a, 0 
c28b			;		cp e 
c28b			;		jr z, .scrollup  
c28b			;		call scroll_down 
c28b			;		jr .scrollnext 
c28b			;.scrollup:	call scroll_up 
c28b			; 
c28b			;		 
c28b			;.scrollnext: 
c28b			;		pop de 
c28b			;		pop bc 
c28b			;		djnz .scrolldir 
c28b			; 
c28b			; 
c28b			; 
c28b			; 
c28b			; 
c28b			;		NEXTW 
c28b			 
c28b			.SCROLLD: 
c28b				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
c28b 53				db WORD_SYS_CORE+63             
c28c bc c2			dw .ATQ            
c28e 08				db 7 + 1 
c28f .. 00			db "SCROLLD",0              
c297				endm 
# End of macro CWHEAD
c297			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
c297					if DEBUG_FORTH_WORDS_KEY 
c297						DMARK "SCD" 
c297 f5				push af  
c298 3a ac c2			ld a, (.dmark)  
c29b 32 62 ee			ld (debug_mark),a  
c29e 3a ad c2			ld a, (.dmark+1)  
c2a1 32 63 ee			ld (debug_mark+1),a  
c2a4 3a ae c2			ld a, (.dmark+2)  
c2a7 32 64 ee			ld (debug_mark+2),a  
c2aa 18 03			jr .pastdmark  
c2ac ..			.dmark: db "SCD"  
c2af f1			.pastdmark: pop af  
c2b0			endm  
# End of macro DMARK
c2b0						CALLMONITOR 
c2b0 cd 6f ee			call debug_vector  
c2b3				endm  
# End of macro CALLMONITOR
c2b3					endif 
c2b3			 
c2b3 cd 92 8a			call scroll_down 
c2b6			;	call update_display 
c2b6			 
c2b6					NEXTW 
c2b6 cd 6c ee			call parse_vector 
c2b9 c3 aa 9d			jp macro_next 
c2bc				endm 
# End of macro NEXTW
c2bc			 
c2bc			 
c2bc			.ATQ: 
c2bc				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
c2bc 62				db WORD_SYS_CORE+78             
c2bd 1d c3			dw .AUTODSP            
c2bf 04				db 3 + 1 
c2c0 .. 00			db "AT@",0              
c2c4				endm 
# End of macro CWHEAD
c2c4			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
c2c4					if DEBUG_FORTH_WORDS_KEY 
c2c4						DMARK "ATA" 
c2c4 f5				push af  
c2c5 3a d9 c2			ld a, (.dmark)  
c2c8 32 62 ee			ld (debug_mark),a  
c2cb 3a da c2			ld a, (.dmark+1)  
c2ce 32 63 ee			ld (debug_mark+1),a  
c2d1 3a db c2			ld a, (.dmark+2)  
c2d4 32 64 ee			ld (debug_mark+2),a  
c2d7 18 03			jr .pastdmark  
c2d9 ..			.dmark: db "ATA"  
c2dc f1			.pastdmark: pop af  
c2dd			endm  
# End of macro DMARK
c2dd						CALLMONITOR 
c2dd cd 6f ee			call debug_vector  
c2e0				endm  
# End of macro CALLMONITOR
c2e0					endif 
c2e0			 
c2e0			 
c2e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2e0 cd c3 9b			call macro_dsp_valuehl 
c2e3				endm 
# End of macro FORTH_DSP_VALUEHL
c2e3			 
c2e3					; TODO save cursor row 
c2e3 7d					ld a,l 
c2e4 fe 02				cp 2 
c2e6 20 04				jr nz, .crow3aq 
c2e8 3e 28				ld a, display_row_2 
c2ea 18 12				jr .ccol1aq 
c2ec fe 03		.crow3aq:		cp 3 
c2ee 20 04				jr nz, .crow4aq 
c2f0 3e 50				ld a, display_row_3 
c2f2 18 0a				jr .ccol1aq 
c2f4 fe 04		.crow4aq:		cp 4 
c2f6 20 04				jr nz, .crow1aq 
c2f8 3e 78				ld a, display_row_4 
c2fa 18 02				jr .ccol1aq 
c2fc 3e 00		.crow1aq:		ld a,display_row_1 
c2fe f5			.ccol1aq:		push af			; got row offset 
c2ff 6f					ld l,a 
c300 26 00				ld h,0 
c302					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c302 cd 7b 9c			call macro_forth_dsp_pop 
c305				endm 
# End of macro FORTH_DSP_POP
c305					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c305 cd c3 9b			call macro_dsp_valuehl 
c308				endm 
# End of macro FORTH_DSP_VALUEHL
c308					; TODO save cursor col 
c308 f1					pop af 
c309 85					add l		; add col offset 
c30a			 
c30a					; add current frame buffer address 
c30a 2a c3 eb				ld hl, (display_fb_active) 
c30d cd d6 8c				call addatohl 
c310			 
c310			 
c310			 
c310			 
c310					; get char frame buffer location offset in hl 
c310			 
c310 7e					ld a,(hl) 
c311 26 00				ld h, 0 
c313 6f					ld l, a 
c314			 
c314 cd c7 99				call forth_push_numhl 
c317			 
c317			 
c317					NEXTW 
c317 cd 6c ee			call parse_vector 
c31a c3 aa 9d			jp macro_next 
c31d				endm 
# End of macro NEXTW
c31d			 
c31d			.AUTODSP: 
c31d				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
c31d 63				db WORD_SYS_CORE+79             
c31e 36 c3			dw .MENU            
c320 05				db 4 + 1 
c321 .. 00			db "ADSP",0              
c326				endm 
# End of macro CWHEAD
c326			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
c326			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
c326			 
c326					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c326 cd c3 9b			call macro_dsp_valuehl 
c329				endm 
# End of macro FORTH_DSP_VALUEHL
c329			 
c329			;		push hl 
c329			 
c329					; destroy value TOS 
c329			 
c329					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c329 cd 7b 9c			call macro_forth_dsp_pop 
c32c				endm 
# End of macro FORTH_DSP_POP
c32c			 
c32c			;		pop hl 
c32c			 
c32c 7d					ld a,l 
c32d 32 33 ea				ld (cli_autodisplay), a 
c330				       NEXTW 
c330 cd 6c ee			call parse_vector 
c333 c3 aa 9d			jp macro_next 
c336				endm 
# End of macro NEXTW
c336			 
c336			.MENU: 
c336				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
c336 70				db WORD_SYS_CORE+92             
c337 e2 c3			dw .ENDDISPLAY            
c339 05				db 4 + 1 
c33a .. 00			db "MENU",0              
c33f				endm 
# End of macro CWHEAD
c33f			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
c33f			 
c33f			;		; get number of items on the stack 
c33f			; 
c33f				 
c33f					FORTH_DSP_VALUEHL 
c33f cd c3 9b			call macro_dsp_valuehl 
c342				endm 
# End of macro FORTH_DSP_VALUEHL
c342				 
c342					if DEBUG_FORTH_WORDS_KEY 
c342						DMARK "MNU" 
c342 f5				push af  
c343 3a 57 c3			ld a, (.dmark)  
c346 32 62 ee			ld (debug_mark),a  
c349 3a 58 c3			ld a, (.dmark+1)  
c34c 32 63 ee			ld (debug_mark+1),a  
c34f 3a 59 c3			ld a, (.dmark+2)  
c352 32 64 ee			ld (debug_mark+2),a  
c355 18 03			jr .pastdmark  
c357 ..			.dmark: db "MNU"  
c35a f1			.pastdmark: pop af  
c35b			endm  
# End of macro DMARK
c35b						CALLMONITOR 
c35b cd 6f ee			call debug_vector  
c35e				endm  
# End of macro CALLMONITOR
c35e					endif 
c35e			 
c35e 45					ld b, l	 
c35f 05					dec b 
c360			 
c360					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c360 cd 7b 9c			call macro_forth_dsp_pop 
c363				endm 
# End of macro FORTH_DSP_POP
c363			 
c363			 
c363					; go directly through the stack to pluck out the string pointers and build an array 
c363			 
c363			;		FORTH_DSP 
c363			 
c363					; hl contains top most stack item 
c363				 
c363 11 b8 e2				ld de, scratch 
c366			 
c366			.mbuild: 
c366			 
c366					FORTH_DSP_VALUEHL 
c366 cd c3 9b			call macro_dsp_valuehl 
c369				endm 
# End of macro FORTH_DSP_VALUEHL
c369			 
c369					if DEBUG_FORTH_WORDS 
c369						DMARK "MN3" 
c369 f5				push af  
c36a 3a 7e c3			ld a, (.dmark)  
c36d 32 62 ee			ld (debug_mark),a  
c370 3a 7f c3			ld a, (.dmark+1)  
c373 32 63 ee			ld (debug_mark+1),a  
c376 3a 80 c3			ld a, (.dmark+2)  
c379 32 64 ee			ld (debug_mark+2),a  
c37c 18 03			jr .pastdmark  
c37e ..			.dmark: db "MN3"  
c381 f1			.pastdmark: pop af  
c382			endm  
# End of macro DMARK
c382						CALLMONITOR 
c382 cd 6f ee			call debug_vector  
c385				endm  
# End of macro CALLMONITOR
c385					endif 
c385 eb					ex de, hl 
c386 73					ld (hl), e 
c387 23					inc hl 
c388 72					ld (hl), d 
c389 23					inc hl 
c38a eb					ex de, hl 
c38b			 
c38b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c38b cd 7b 9c			call macro_forth_dsp_pop 
c38e				endm 
# End of macro FORTH_DSP_POP
c38e			 
c38e 10 d6				djnz .mbuild 
c390			 
c390					; done add term 
c390			 
c390 eb					ex de, hl 
c391 36 00				ld (hl), 0 
c393 23					inc hl 
c394 36 00				ld (hl), 0 
c396			 
c396				 
c396					 
c396 21 b8 e2				ld hl, scratch 
c399			 
c399					if DEBUG_FORTH_WORDS 
c399						DMARK "MNx" 
c399 f5				push af  
c39a 3a ae c3			ld a, (.dmark)  
c39d 32 62 ee			ld (debug_mark),a  
c3a0 3a af c3			ld a, (.dmark+1)  
c3a3 32 63 ee			ld (debug_mark+1),a  
c3a6 3a b0 c3			ld a, (.dmark+2)  
c3a9 32 64 ee			ld (debug_mark+2),a  
c3ac 18 03			jr .pastdmark  
c3ae ..			.dmark: db "MNx"  
c3b1 f1			.pastdmark: pop af  
c3b2			endm  
# End of macro DMARK
c3b2						CALLMONITOR 
c3b2 cd 6f ee			call debug_vector  
c3b5				endm  
# End of macro CALLMONITOR
c3b5					endif 
c3b5			 
c3b5			 
c3b5			 
c3b5 3e 00				ld a, 0 
c3b7 cd dc 8a				call menu 
c3ba			 
c3ba			 
c3ba 6f					ld l, a 
c3bb 26 00				ld h, 0 
c3bd			 
c3bd					if DEBUG_FORTH_WORDS 
c3bd						DMARK "MNr" 
c3bd f5				push af  
c3be 3a d2 c3			ld a, (.dmark)  
c3c1 32 62 ee			ld (debug_mark),a  
c3c4 3a d3 c3			ld a, (.dmark+1)  
c3c7 32 63 ee			ld (debug_mark+1),a  
c3ca 3a d4 c3			ld a, (.dmark+2)  
c3cd 32 64 ee			ld (debug_mark+2),a  
c3d0 18 03			jr .pastdmark  
c3d2 ..			.dmark: db "MNr"  
c3d5 f1			.pastdmark: pop af  
c3d6			endm  
# End of macro DMARK
c3d6						CALLMONITOR 
c3d6 cd 6f ee			call debug_vector  
c3d9				endm  
# End of macro CALLMONITOR
c3d9					endif 
c3d9			 
c3d9 cd c7 99				call forth_push_numhl 
c3dc			 
c3dc			 
c3dc			 
c3dc			 
c3dc				       NEXTW 
c3dc cd 6c ee			call parse_vector 
c3df c3 aa 9d			jp macro_next 
c3e2				endm 
# End of macro NEXTW
c3e2			 
c3e2			 
c3e2			.ENDDISPLAY: 
c3e2			 
c3e2			; eof 
# End of file forth_words_display.asm
c3e2			include "forth_words_str.asm" 
c3e2			 
c3e2			; | ## String Words 
c3e2			 
c3e2			.CONST: 
c3e2				 
c3e2				CWHEAD .MOVE 52 "CONST" 5 WORD_FLAG_CODE 
c3e2 48				db WORD_SYS_CORE+52             
c3e3 f7 c3			dw .MOVE            
c3e5 06				db 5 + 1 
c3e6 .. 00			db "CONST",0              
c3ec				endm 
# End of macro CWHEAD
c3ec			; | CONST ( u -- u ) Change the type of var on TOS to a constant. i.e. if a string it won't be freed on consuption, | TODO 
c3ec					FORTH_DSP 
c3ec cd 89 9b			call macro_forth_dsp 
c3ef				endm 
# End of macro FORTH_DSP
c3ef 36 04				ld (hl), DS_TYPE_CONST 
c3f1					NEXTW 
c3f1 cd 6c ee			call parse_vector 
c3f4 c3 aa 9d			jp macro_next 
c3f7				endm 
# End of macro NEXTW
c3f7			 
c3f7			.MOVE:   
c3f7			 
c3f7				CWHEAD .ZMOVE 52 "MOVE" 4 WORD_FLAG_CODE 
c3f7 48				db WORD_SYS_CORE+52             
c3f8 1e c4			dw .ZMOVE            
c3fa 05				db 4 + 1 
c3fb .. 00			db "MOVE",0              
c400				endm 
# End of macro CWHEAD
c400			; | MOVE ( a1 a2 c -- ) Copy from address a1 to address a2 for the length of c | DONE 
c400			 
c400					FORTH_DSP_VALUEHL 
c400 cd c3 9b			call macro_dsp_valuehl 
c403				endm 
# End of macro FORTH_DSP_VALUEHL
c403 e5					push hl    ; push count 
c404			 
c404					FORTH_DSP_POP 
c404 cd 7b 9c			call macro_forth_dsp_pop 
c407				endm 
# End of macro FORTH_DSP_POP
c407			 
c407					FORTH_DSP_VALUEHL 
c407 cd c3 9b			call macro_dsp_valuehl 
c40a				endm 
# End of macro FORTH_DSP_VALUEHL
c40a e5					push hl    ; dest 
c40b			 
c40b					FORTH_DSP_POP 
c40b cd 7b 9c			call macro_forth_dsp_pop 
c40e				endm 
# End of macro FORTH_DSP_POP
c40e			 
c40e					FORTH_DSP_VALUEHL 
c40e cd c3 9b			call macro_dsp_valuehl 
c411				endm 
# End of macro FORTH_DSP_VALUEHL
c411			 
c411					FORTH_DSP_POP 
c411 cd 7b 9c			call macro_forth_dsp_pop 
c414				endm 
# End of macro FORTH_DSP_POP
c414			 
c414 d1					pop de 
c415 c1					pop bc 
c416				 
c416 ed b0				ldir 
c418				NEXTW 
c418 cd 6c ee			call parse_vector 
c41b c3 aa 9d			jp macro_next 
c41e				endm 
# End of macro NEXTW
c41e			.ZMOVE:   
c41e			 
c41e				CWHEAD .TABLE 52 "ZMOVE" 5 WORD_FLAG_CODE 
c41e 48				db WORD_SYS_CORE+52             
c41f 47 c4			dw .TABLE            
c421 06				db 5 + 1 
c422 .. 00			db "ZMOVE",0              
c428				endm 
# End of macro CWHEAD
c428					 
c428			; | ZMOVE ( a1 a2 -- ) Copy from address a1 to address a2 until a1 hits zero term string | DONE 
c428			; | | Ensure you have enough space! 
c428			 
c428			 
c428					FORTH_DSP_VALUEHL 
c428 cd c3 9b			call macro_dsp_valuehl 
c42b				endm 
# End of macro FORTH_DSP_VALUEHL
c42b e5					push hl    ; dest 
c42c			 
c42c					FORTH_DSP_POP 
c42c cd 7b 9c			call macro_forth_dsp_pop 
c42f				endm 
# End of macro FORTH_DSP_POP
c42f			 
c42f					FORTH_DSP_VALUEHL 
c42f cd c3 9b			call macro_dsp_valuehl 
c432				endm 
# End of macro FORTH_DSP_VALUEHL
c432			 
c432					FORTH_DSP_POP 
c432 cd 7b 9c			call macro_forth_dsp_pop 
c435				endm 
# End of macro FORTH_DSP_POP
c435			 
c435 d1					pop de 
c436			 
c436 01 ff 00				ld bc, 255 
c439 ed a0		.zmovel:	ldi 
c43b 2b					dec hl 
c43c 7e					ld a,(hl) 
c43d 23					inc hl 
c43e b7					or a  
c43f 20 f8				jr nz, .zmovel    
c441					 
c441			 
c441				NEXTW 
c441 cd 6c ee			call parse_vector 
c444 c3 aa 9d			jp macro_next 
c447				endm 
# End of macro NEXTW
c447			 
c447			.TABLE:   
c447			 
c447				CWHEAD .SPLIT 52 "TABLE" 5 WORD_FLAG_CODE 
c447 48				db WORD_SYS_CORE+52             
c448 ac c4			dw .SPLIT            
c44a 06				db 5 + 1 
c44b .. 00			db "TABLE",0              
c451				endm 
# End of macro CWHEAD
c451					 
c451			; | TABLE ( s .. sx c -- a) For the number c of strings s on the stack. Generate a look up table array a | DONE 
c451			; | | Takes a list of strings and creates a block of pointers to each string which can then be used 
c451			; | | in any kind of lookup or iteration.  
c451			; | | Last item in the array will be a zero pointer for ease of iteration 
c451			 
c451			 
c451				; get the count of strings 
c451			 
c451					FORTH_DSP_VALUEHL 
c451 cd c3 9b			call macro_dsp_valuehl 
c454				endm 
# End of macro FORTH_DSP_VALUEHL
c454			 
c454					FORTH_DSP_POP 
c454 cd 7b 9c			call macro_forth_dsp_pop 
c457				endm 
# End of macro FORTH_DSP_POP
c457			 
c457				; allocate memory for (count + 1 ) * 2 for word array plus zero pointer 
c457			 
c457					; l contains count 
c457			 
c457 7d					ld a,l 
c458 32 b8 e2				ld (scratch), a     ; save it for the loading loop 
c45b			 
c45b 2c					inc l  ; for zero pointer 
c45c eb					ex de, hl 
c45d 3e 02				ld a, 2 
c45f cd 59 8c				call Mult16 
c462			 
c462					; hl is the size of block to allocate 
c462			 
c462 cd a2 90				call malloc 
c465				if DEBUG_FORTH_MALLOC_GUARD 
c465 cc 18 d3				call z,malloc_error 
c468				endif 
c468					; hl is the pointer to the array block 
c468						 
c468 22 b9 e2				ld (scratch+1), hl    ; save the base for later push to stack 
c46b 22 bb e2				ld (scratch+3), hl    ; save the base for current string to push 
c46e			 
c46e 3a b8 e2				ld a, (scratch) 
c471 47					ld b, a 
c472			 
c472				; for each string 
c472			 
c472			.tablelop: 
c472			 
c472 c5					push bc 
c473			 
c473				;     get string pointer 
c473			 
c473					FORTH_DSP_VALUEHL 
c473 cd c3 9b			call macro_dsp_valuehl 
c476				endm 
# End of macro FORTH_DSP_VALUEHL
c476			 
c476 e5					push hl 
c477			 
c477				;     get string length 
c477			 
c477 3e 00				ld a,0 
c479 cd 39 90				call strlent 
c47c			 
c47c 23					inc hl 
c47d e5					push hl 
c47e			 
c47e				;     allocate string length 
c47e			 
c47e cd a2 90				call malloc 
c481			 
c481			        ;     copy string to block 
c481			 
c481 c1					pop bc 
c482 eb					ex de, hl 
c483 e1					pop hl 
c484 d5					push de 
c485			 
c485 ed b0				ldir 
c487			 
c487			 
c487			        ;     add pointer to string to array block 
c487			 
c487 2a bb e2				ld hl, (scratch+3)    ; save the base for current string to push 
c48a			 
c48a d1					pop de     ; the pointer to the newly copied string to add to the array 
c48b 73					ld (hl), e 
c48c 23					inc hl 
c48d 72					ld (hl), d	 
c48e 23					inc hl 
c48f				 
c48f 22 bb e2				ld (scratch+3), hl    ; save the base for current string to push 
c492			 
c492					FORTH_DSP_POP 
c492 cd 7b 9c			call macro_forth_dsp_pop 
c495				endm 
# End of macro FORTH_DSP_POP
c495			 
c495 c1					pop bc 
c496 10 da				djnz .tablelop 
c498			 
c498			        ;  push array block pointer 
c498			 
c498 2a bb e2				ld hl, (scratch+3)    ; save the base for current string to push 
c49b 36 00				ld (hl), 0 
c49d 23					inc hl 
c49e 36 00				ld (hl), 0 
c4a0			 
c4a0			 
c4a0				 
c4a0 2a b9 e2				ld hl, (scratch+1)    ; save the base for current string to push 
c4a3 cd c7 99				call forth_push_numhl 
c4a6			 
c4a6				NEXTW 
c4a6 cd 6c ee			call parse_vector 
c4a9 c3 aa 9d			jp macro_next 
c4ac				endm 
# End of macro NEXTW
c4ac			 
c4ac			.SPLIT:   
c4ac			 
c4ac				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
c4ac 48				db WORD_SYS_CORE+52             
c4ad a3 c5			dw .PTR            
c4af 06				db 5 + 1 
c4b0 .. 00			db "SPLIT",0              
c4b6				endm 
# End of macro CWHEAD
c4b6			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
c4b6					if DEBUG_FORTH_WORDS_KEY 
c4b6						DMARK "SPT" 
c4b6 f5				push af  
c4b7 3a cb c4			ld a, (.dmark)  
c4ba 32 62 ee			ld (debug_mark),a  
c4bd 3a cc c4			ld a, (.dmark+1)  
c4c0 32 63 ee			ld (debug_mark+1),a  
c4c3 3a cd c4			ld a, (.dmark+2)  
c4c6 32 64 ee			ld (debug_mark+2),a  
c4c9 18 03			jr .pastdmark  
c4cb ..			.dmark: db "SPT"  
c4ce f1			.pastdmark: pop af  
c4cf			endm  
# End of macro DMARK
c4cf						CALLMONITOR 
c4cf cd 6f ee			call debug_vector  
c4d2				endm  
# End of macro CALLMONITOR
c4d2					endif 
c4d2			 
c4d2					; get delim 
c4d2					FORTH_DSP_VALUEHL 
c4d2 cd c3 9b			call macro_dsp_valuehl 
c4d5				endm 
# End of macro FORTH_DSP_VALUEHL
c4d5			 
c4d5					FORTH_DSP_POP 
c4d5 cd 7b 9c			call macro_forth_dsp_pop 
c4d8				endm 
# End of macro FORTH_DSP_POP
c4d8					 
c4d8			 
c4d8 45					ld b, l    ; move delim to b 
c4d9 0e 01				ld c, 1   ; count of poritions 
c4db			 
c4db c5					push bc 
c4dc			 
c4dc					if DEBUG_FORTH_WORDS 
c4dc						DMARK "SPa" 
c4dc f5				push af  
c4dd 3a f1 c4			ld a, (.dmark)  
c4e0 32 62 ee			ld (debug_mark),a  
c4e3 3a f2 c4			ld a, (.dmark+1)  
c4e6 32 63 ee			ld (debug_mark+1),a  
c4e9 3a f3 c4			ld a, (.dmark+2)  
c4ec 32 64 ee			ld (debug_mark+2),a  
c4ef 18 03			jr .pastdmark  
c4f1 ..			.dmark: db "SPa"  
c4f4 f1			.pastdmark: pop af  
c4f5			endm  
# End of macro DMARK
c4f5						CALLMONITOR 
c4f5 cd 6f ee			call debug_vector  
c4f8				endm  
# End of macro CALLMONITOR
c4f8					endif 
c4f8					; get pointer to string to chop up 
c4f8					FORTH_DSP_VALUEHL 
c4f8 cd c3 9b			call macro_dsp_valuehl 
c4fb				endm 
# End of macro FORTH_DSP_VALUEHL
c4fb			 
c4fb			;		push hl 
c4fb 11 b8 e2				ld de, scratch 
c4fe			.spllop: 
c4fe c1					pop bc 
c4ff c5					push bc 
c500			;		pop hl 
c500					if DEBUG_FORTH_WORDS 
c500						DMARK "SPl" 
c500 f5				push af  
c501 3a 15 c5			ld a, (.dmark)  
c504 32 62 ee			ld (debug_mark),a  
c507 3a 16 c5			ld a, (.dmark+1)  
c50a 32 63 ee			ld (debug_mark+1),a  
c50d 3a 17 c5			ld a, (.dmark+2)  
c510 32 64 ee			ld (debug_mark+2),a  
c513 18 03			jr .pastdmark  
c515 ..			.dmark: db "SPl"  
c518 f1			.pastdmark: pop af  
c519			endm  
# End of macro DMARK
c519						CALLMONITOR 
c519 cd 6f ee			call debug_vector  
c51c				endm  
# End of macro CALLMONITOR
c51c					endif 
c51c 7e					ld a, (hl) 
c51d b8					cp b 
c51e 28 07				jr z, .splnxt 
c520			;		cp 0 
c520 b7					or a 
c521 28 34				jr z, .splend 
c523 ed a0				ldi 
c525 18 d7				jr .spllop 
c527			 
c527					; hit dlim 
c527			 
c527			.splnxt: 
c527					if DEBUG_FORTH_WORDS 
c527						DMARK "SPx" 
c527 f5				push af  
c528 3a 3c c5			ld a, (.dmark)  
c52b 32 62 ee			ld (debug_mark),a  
c52e 3a 3d c5			ld a, (.dmark+1)  
c531 32 63 ee			ld (debug_mark+1),a  
c534 3a 3e c5			ld a, (.dmark+2)  
c537 32 64 ee			ld (debug_mark+2),a  
c53a 18 03			jr .pastdmark  
c53c ..			.dmark: db "SPx"  
c53f f1			.pastdmark: pop af  
c540			endm  
# End of macro DMARK
c540						CALLMONITOR 
c540 cd 6f ee			call debug_vector  
c543				endm  
# End of macro CALLMONITOR
c543					endif 
c543 3e 00				ld a, 0 
c545 12					ld (de), a 
c546					;ex de, hl 
c546 e5					push hl 
c547 21 b8 e2				ld hl, scratch 
c54a cd 31 9a				call forth_push_str 
c54d e1					pop hl 
c54e					;ex de, hl 
c54e 23					inc hl 
c54f c1					pop bc 
c550 0c					inc c 
c551 c5					push bc 
c552 11 b8 e2				ld de, scratch 
c555 18 a7				jr .spllop 
c557			 
c557			.splend:		 
c557					if DEBUG_FORTH_WORDS 
c557						DMARK "SPe" 
c557 f5				push af  
c558 3a 6c c5			ld a, (.dmark)  
c55b 32 62 ee			ld (debug_mark),a  
c55e 3a 6d c5			ld a, (.dmark+1)  
c561 32 63 ee			ld (debug_mark+1),a  
c564 3a 6e c5			ld a, (.dmark+2)  
c567 32 64 ee			ld (debug_mark+2),a  
c56a 18 03			jr .pastdmark  
c56c ..			.dmark: db "SPe"  
c56f f1			.pastdmark: pop af  
c570			endm  
# End of macro DMARK
c570						CALLMONITOR 
c570 cd 6f ee			call debug_vector  
c573				endm  
# End of macro CALLMONITOR
c573					endif 
c573 12					ld (de), a 
c574 eb					ex de, hl 
c575			;		push hl 
c575 21 b8 e2				ld hl, scratch 
c578 cd 31 9a				call forth_push_str 
c57b					 
c57b					if DEBUG_FORTH_WORDS 
c57b						DMARK "SPc" 
c57b f5				push af  
c57c 3a 90 c5			ld a, (.dmark)  
c57f 32 62 ee			ld (debug_mark),a  
c582 3a 91 c5			ld a, (.dmark+1)  
c585 32 63 ee			ld (debug_mark+1),a  
c588 3a 92 c5			ld a, (.dmark+2)  
c58b 32 64 ee			ld (debug_mark+2),a  
c58e 18 03			jr .pastdmark  
c590 ..			.dmark: db "SPc"  
c593 f1			.pastdmark: pop af  
c594			endm  
# End of macro DMARK
c594						CALLMONITOR 
c594 cd 6f ee			call debug_vector  
c597				endm  
# End of macro CALLMONITOR
c597					endif 
c597			 
c597 e1					pop hl    ; get counter from bc which has been push 
c598 26 00				ld h, 0 
c59a			;		ld l, c 
c59a cd c7 99				call forth_push_numhl 
c59d			 
c59d			 
c59d				NEXTW 
c59d cd 6c ee			call parse_vector 
c5a0 c3 aa 9d			jp macro_next 
c5a3				endm 
# End of macro NEXTW
c5a3			.PTR:   
c5a3			 
c5a3				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c5a3 48				db WORD_SYS_CORE+52             
c5a4 d3 c5			dw .STYPE            
c5a6 04				db 3 + 1 
c5a7 .. 00			db "PTR",0              
c5ab				endm 
# End of macro CWHEAD
c5ab			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c5ab			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c5ab			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c5ab			 
c5ab					if DEBUG_FORTH_WORDS_KEY 
c5ab						DMARK "PTR" 
c5ab f5				push af  
c5ac 3a c0 c5			ld a, (.dmark)  
c5af 32 62 ee			ld (debug_mark),a  
c5b2 3a c1 c5			ld a, (.dmark+1)  
c5b5 32 63 ee			ld (debug_mark+1),a  
c5b8 3a c2 c5			ld a, (.dmark+2)  
c5bb 32 64 ee			ld (debug_mark+2),a  
c5be 18 03			jr .pastdmark  
c5c0 ..			.dmark: db "PTR"  
c5c3 f1			.pastdmark: pop af  
c5c4			endm  
# End of macro DMARK
c5c4						CALLMONITOR 
c5c4 cd 6f ee			call debug_vector  
c5c7				endm  
# End of macro CALLMONITOR
c5c7					endif 
c5c7					FORTH_DSP_VALUEHL 
c5c7 cd c3 9b			call macro_dsp_valuehl 
c5ca				endm 
# End of macro FORTH_DSP_VALUEHL
c5ca cd c7 99				call forth_push_numhl 
c5cd			 
c5cd			 
c5cd					NEXTW 
c5cd cd 6c ee			call parse_vector 
c5d0 c3 aa 9d			jp macro_next 
c5d3				endm 
# End of macro NEXTW
c5d3			.STYPE: 
c5d3				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c5d3 48				db WORD_SYS_CORE+52             
c5d4 30 c6			dw .UPPER            
c5d6 06				db 5 + 1 
c5d7 .. 00			db "STYPE",0              
c5dd				endm 
# End of macro CWHEAD
c5dd			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
c5dd			; | | 's' string or 'i' integer or 'c' const 
c5dd					if DEBUG_FORTH_WORDS_KEY 
c5dd						DMARK "STY" 
c5dd f5				push af  
c5de 3a f2 c5			ld a, (.dmark)  
c5e1 32 62 ee			ld (debug_mark),a  
c5e4 3a f3 c5			ld a, (.dmark+1)  
c5e7 32 63 ee			ld (debug_mark+1),a  
c5ea 3a f4 c5			ld a, (.dmark+2)  
c5ed 32 64 ee			ld (debug_mark+2),a  
c5f0 18 03			jr .pastdmark  
c5f2 ..			.dmark: db "STY"  
c5f5 f1			.pastdmark: pop af  
c5f6			endm  
# End of macro DMARK
c5f6						CALLMONITOR 
c5f6 cd 6f ee			call debug_vector  
c5f9				endm  
# End of macro CALLMONITOR
c5f9					endif 
c5f9					FORTH_DSP 
c5f9 cd 89 9b			call macro_forth_dsp 
c5fc				endm 
# End of macro FORTH_DSP
c5fc					;v5 FORTH_DSP_VALUE 
c5fc			 
c5fc 7e					ld a, (hl) 
c5fd			 
c5fd f5					push af 
c5fe			 
c5fe			; Dont destroy TOS		FORTH_DSP_POP 
c5fe			 
c5fe f1					pop af 
c5ff			 
c5ff fe 01				cp DS_TYPE_STR 
c601 28 12				jr z, .typestr 
c603 fe 04				cp DS_TYPE_CONST 
c605 28 09				jr z, .typeconst 
c607			 
c607 fe 02				cp DS_TYPE_INUM 
c609 28 0f				jr z, .typeinum 
c60b			 
c60b 21 2e c6				ld hl, .tna 
c60e 18 0f				jr .tpush 
c610			 
c610 21 2a c6		.typeconst:	ld hl, .tconst 
c613 18 0a				jr .tpush 
c615 21 28 c6		.typestr:	ld hl, .tstr 
c618 18 05				jr .tpush 
c61a 21 2c c6		.typeinum:	ld hl, .tinum 
c61d 18 00				jr .tpush 
c61f			 
c61f			.tpush: 
c61f			 
c61f cd 31 9a				call forth_push_str 
c622			 
c622					NEXTW 
c622 cd 6c ee			call parse_vector 
c625 c3 aa 9d			jp macro_next 
c628				endm 
# End of macro NEXTW
c628 .. 00		.tstr:	db "s",0 
c62a .. 00		.tconst:	db "c",0 
c62c .. 00		.tinum:  db "i",0 
c62e .. 00		.tna:   db "?", 0 
c630			 
c630			 
c630			.UPPER: 
c630				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c630 48				db WORD_SYS_CORE+52             
c631 6d c6			dw .LOWER            
c633 06				db 5 + 1 
c634 .. 00			db "UPPER",0              
c63a				endm 
# End of macro CWHEAD
c63a			; | UPPER ( s -- s ) Upper case string s  | DONE 
c63a					if DEBUG_FORTH_WORDS_KEY 
c63a						DMARK "UPR" 
c63a f5				push af  
c63b 3a 4f c6			ld a, (.dmark)  
c63e 32 62 ee			ld (debug_mark),a  
c641 3a 50 c6			ld a, (.dmark+1)  
c644 32 63 ee			ld (debug_mark+1),a  
c647 3a 51 c6			ld a, (.dmark+2)  
c64a 32 64 ee			ld (debug_mark+2),a  
c64d 18 03			jr .pastdmark  
c64f ..			.dmark: db "UPR"  
c652 f1			.pastdmark: pop af  
c653			endm  
# End of macro DMARK
c653						CALLMONITOR 
c653 cd 6f ee			call debug_vector  
c656				endm  
# End of macro CALLMONITOR
c656					endif 
c656			 
c656					FORTH_DSP 
c656 cd 89 9b			call macro_forth_dsp 
c659				endm 
# End of macro FORTH_DSP
c659					 
c659			; TODO check is string type 
c659			 
c659					FORTH_DSP_VALUEHL 
c659 cd c3 9b			call macro_dsp_valuehl 
c65c				endm 
# End of macro FORTH_DSP_VALUEHL
c65c			; get pointer to string in hl 
c65c			 
c65c 7e			.toup:		ld a, (hl) 
c65d			;		cp 0 
c65d b7					or a 
c65e 28 07				jr z, .toupdone 
c660			 
c660 cd 3e 8f				call to_upper 
c663			 
c663 77					ld (hl), a 
c664 23					inc hl 
c665 18 f5				jr .toup 
c667			 
c667					 
c667			 
c667			 
c667			; for each char convert to upper 
c667					 
c667			.toupdone: 
c667			 
c667			 
c667					NEXTW 
c667 cd 6c ee			call parse_vector 
c66a c3 aa 9d			jp macro_next 
c66d				endm 
# End of macro NEXTW
c66d			.LOWER: 
c66d				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c66d 48				db WORD_SYS_CORE+52             
c66e aa c6			dw .TCASE            
c670 06				db 5 + 1 
c671 .. 00			db "LOWER",0              
c677				endm 
# End of macro CWHEAD
c677			; | LOWER ( s -- s ) Lower case string s  | DONE 
c677					if DEBUG_FORTH_WORDS_KEY 
c677						DMARK "LWR" 
c677 f5				push af  
c678 3a 8c c6			ld a, (.dmark)  
c67b 32 62 ee			ld (debug_mark),a  
c67e 3a 8d c6			ld a, (.dmark+1)  
c681 32 63 ee			ld (debug_mark+1),a  
c684 3a 8e c6			ld a, (.dmark+2)  
c687 32 64 ee			ld (debug_mark+2),a  
c68a 18 03			jr .pastdmark  
c68c ..			.dmark: db "LWR"  
c68f f1			.pastdmark: pop af  
c690			endm  
# End of macro DMARK
c690						CALLMONITOR 
c690 cd 6f ee			call debug_vector  
c693				endm  
# End of macro CALLMONITOR
c693					endif 
c693			 
c693					FORTH_DSP 
c693 cd 89 9b			call macro_forth_dsp 
c696				endm 
# End of macro FORTH_DSP
c696					 
c696			; TODO check is string type 
c696			 
c696					FORTH_DSP_VALUEHL 
c696 cd c3 9b			call macro_dsp_valuehl 
c699				endm 
# End of macro FORTH_DSP_VALUEHL
c699			; get pointer to string in hl 
c699			 
c699 7e			.tolow:		ld a, (hl) 
c69a			;		cp 0 
c69a b7					or a 
c69b 28 07				jr z, .tolowdone 
c69d			 
c69d cd 47 8f				call to_lower 
c6a0			 
c6a0 77					ld (hl), a 
c6a1 23					inc hl 
c6a2 18 f5				jr .tolow 
c6a4			 
c6a4					 
c6a4			 
c6a4			 
c6a4			; for each char convert to low 
c6a4					 
c6a4			.tolowdone: 
c6a4					NEXTW 
c6a4 cd 6c ee			call parse_vector 
c6a7 c3 aa 9d			jp macro_next 
c6aa				endm 
# End of macro NEXTW
c6aa			.TCASE: 
c6aa				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c6aa 48				db WORD_SYS_CORE+52             
c6ab e1 c7			dw .SUBSTR            
c6ad 06				db 5 + 1 
c6ae .. 00			db "TCASE",0              
c6b4				endm 
# End of macro CWHEAD
c6b4			; | TCASE ( s -- s ) Title case string s  | DONE 
c6b4					if DEBUG_FORTH_WORDS_KEY 
c6b4						DMARK "TCS" 
c6b4 f5				push af  
c6b5 3a c9 c6			ld a, (.dmark)  
c6b8 32 62 ee			ld (debug_mark),a  
c6bb 3a ca c6			ld a, (.dmark+1)  
c6be 32 63 ee			ld (debug_mark+1),a  
c6c1 3a cb c6			ld a, (.dmark+2)  
c6c4 32 64 ee			ld (debug_mark+2),a  
c6c7 18 03			jr .pastdmark  
c6c9 ..			.dmark: db "TCS"  
c6cc f1			.pastdmark: pop af  
c6cd			endm  
# End of macro DMARK
c6cd						CALLMONITOR 
c6cd cd 6f ee			call debug_vector  
c6d0				endm  
# End of macro CALLMONITOR
c6d0					endif 
c6d0			 
c6d0					FORTH_DSP 
c6d0 cd 89 9b			call macro_forth_dsp 
c6d3				endm 
# End of macro FORTH_DSP
c6d3					 
c6d3			; TODO check is string type 
c6d3			 
c6d3					FORTH_DSP_VALUEHL 
c6d3 cd c3 9b			call macro_dsp_valuehl 
c6d6				endm 
# End of macro FORTH_DSP_VALUEHL
c6d6			; get pointer to string in hl 
c6d6			 
c6d6					if DEBUG_FORTH_WORDS 
c6d6						DMARK "TC1" 
c6d6 f5				push af  
c6d7 3a eb c6			ld a, (.dmark)  
c6da 32 62 ee			ld (debug_mark),a  
c6dd 3a ec c6			ld a, (.dmark+1)  
c6e0 32 63 ee			ld (debug_mark+1),a  
c6e3 3a ed c6			ld a, (.dmark+2)  
c6e6 32 64 ee			ld (debug_mark+2),a  
c6e9 18 03			jr .pastdmark  
c6eb ..			.dmark: db "TC1"  
c6ee f1			.pastdmark: pop af  
c6ef			endm  
# End of macro DMARK
c6ef						CALLMONITOR 
c6ef cd 6f ee			call debug_vector  
c6f2				endm  
# End of macro CALLMONITOR
c6f2					endif 
c6f2			 
c6f2					; first time in turn to upper case first char 
c6f2			 
c6f2 7e					ld a, (hl) 
c6f3 c3 7c c7				jp .totsiptou 
c6f6			 
c6f6			 
c6f6 7e			.tot:		ld a, (hl) 
c6f7			;		cp 0 
c6f7 b7					or a 
c6f8 ca bf c7				jp z, .totdone 
c6fb			 
c6fb					if DEBUG_FORTH_WORDS 
c6fb						DMARK "TC2" 
c6fb f5				push af  
c6fc 3a 10 c7			ld a, (.dmark)  
c6ff 32 62 ee			ld (debug_mark),a  
c702 3a 11 c7			ld a, (.dmark+1)  
c705 32 63 ee			ld (debug_mark+1),a  
c708 3a 12 c7			ld a, (.dmark+2)  
c70b 32 64 ee			ld (debug_mark+2),a  
c70e 18 03			jr .pastdmark  
c710 ..			.dmark: db "TC2"  
c713 f1			.pastdmark: pop af  
c714			endm  
# End of macro DMARK
c714						CALLMONITOR 
c714 cd 6f ee			call debug_vector  
c717				endm  
# End of macro CALLMONITOR
c717					endif 
c717					; check to see if current char is a space 
c717			 
c717 fe 20				cp ' ' 
c719 28 21				jr z, .totsp 
c71b cd 47 8f				call to_lower 
c71e					if DEBUG_FORTH_WORDS 
c71e						DMARK "TC3" 
c71e f5				push af  
c71f 3a 33 c7			ld a, (.dmark)  
c722 32 62 ee			ld (debug_mark),a  
c725 3a 34 c7			ld a, (.dmark+1)  
c728 32 63 ee			ld (debug_mark+1),a  
c72b 3a 35 c7			ld a, (.dmark+2)  
c72e 32 64 ee			ld (debug_mark+2),a  
c731 18 03			jr .pastdmark  
c733 ..			.dmark: db "TC3"  
c736 f1			.pastdmark: pop af  
c737			endm  
# End of macro DMARK
c737						CALLMONITOR 
c737 cd 6f ee			call debug_vector  
c73a				endm  
# End of macro CALLMONITOR
c73a					endif 
c73a 18 62				jr .totnxt 
c73c			 
c73c			.totsp:         ; on a space, find next char which should be upper 
c73c			 
c73c					if DEBUG_FORTH_WORDS 
c73c						DMARK "TC4" 
c73c f5				push af  
c73d 3a 51 c7			ld a, (.dmark)  
c740 32 62 ee			ld (debug_mark),a  
c743 3a 52 c7			ld a, (.dmark+1)  
c746 32 63 ee			ld (debug_mark+1),a  
c749 3a 53 c7			ld a, (.dmark+2)  
c74c 32 64 ee			ld (debug_mark+2),a  
c74f 18 03			jr .pastdmark  
c751 ..			.dmark: db "TC4"  
c754 f1			.pastdmark: pop af  
c755			endm  
# End of macro DMARK
c755						CALLMONITOR 
c755 cd 6f ee			call debug_vector  
c758				endm  
# End of macro CALLMONITOR
c758					endif 
c758					;; 
c758			 
c758 fe 20				cp ' ' 
c75a 20 20				jr nz, .totsiptou 
c75c 23					inc hl 
c75d 7e					ld a, (hl) 
c75e					if DEBUG_FORTH_WORDS 
c75e						DMARK "TC5" 
c75e f5				push af  
c75f 3a 73 c7			ld a, (.dmark)  
c762 32 62 ee			ld (debug_mark),a  
c765 3a 74 c7			ld a, (.dmark+1)  
c768 32 63 ee			ld (debug_mark+1),a  
c76b 3a 75 c7			ld a, (.dmark+2)  
c76e 32 64 ee			ld (debug_mark+2),a  
c771 18 03			jr .pastdmark  
c773 ..			.dmark: db "TC5"  
c776 f1			.pastdmark: pop af  
c777			endm  
# End of macro DMARK
c777						CALLMONITOR 
c777 cd 6f ee			call debug_vector  
c77a				endm  
# End of macro CALLMONITOR
c77a					endif 
c77a 18 c0				jr .totsp 
c77c			.totsiptou:     
c77c					;cp 0 
c77c b7					or a 
c77d 28 40				jr z, .totdone 
c77f					; not space and not zero term so upper case it 
c77f cd 3e 8f				call to_upper 
c782			 
c782					if DEBUG_FORTH_WORDS 
c782						DMARK "TC6" 
c782 f5				push af  
c783 3a 97 c7			ld a, (.dmark)  
c786 32 62 ee			ld (debug_mark),a  
c789 3a 98 c7			ld a, (.dmark+1)  
c78c 32 63 ee			ld (debug_mark+1),a  
c78f 3a 99 c7			ld a, (.dmark+2)  
c792 32 64 ee			ld (debug_mark+2),a  
c795 18 03			jr .pastdmark  
c797 ..			.dmark: db "TC6"  
c79a f1			.pastdmark: pop af  
c79b			endm  
# End of macro DMARK
c79b						CALLMONITOR 
c79b cd 6f ee			call debug_vector  
c79e				endm  
# End of macro CALLMONITOR
c79e					endif 
c79e			 
c79e			 
c79e			.totnxt: 
c79e			 
c79e 77					ld (hl), a 
c79f 23					inc hl 
c7a0					if DEBUG_FORTH_WORDS 
c7a0						DMARK "TC7" 
c7a0 f5				push af  
c7a1 3a b5 c7			ld a, (.dmark)  
c7a4 32 62 ee			ld (debug_mark),a  
c7a7 3a b6 c7			ld a, (.dmark+1)  
c7aa 32 63 ee			ld (debug_mark+1),a  
c7ad 3a b7 c7			ld a, (.dmark+2)  
c7b0 32 64 ee			ld (debug_mark+2),a  
c7b3 18 03			jr .pastdmark  
c7b5 ..			.dmark: db "TC7"  
c7b8 f1			.pastdmark: pop af  
c7b9			endm  
# End of macro DMARK
c7b9						CALLMONITOR 
c7b9 cd 6f ee			call debug_vector  
c7bc				endm  
# End of macro CALLMONITOR
c7bc					endif 
c7bc c3 f6 c6				jp .tot 
c7bf			 
c7bf					 
c7bf			 
c7bf			 
c7bf			; for each char convert to low 
c7bf					 
c7bf			.totdone: 
c7bf					if DEBUG_FORTH_WORDS 
c7bf						DMARK "TCd" 
c7bf f5				push af  
c7c0 3a d4 c7			ld a, (.dmark)  
c7c3 32 62 ee			ld (debug_mark),a  
c7c6 3a d5 c7			ld a, (.dmark+1)  
c7c9 32 63 ee			ld (debug_mark+1),a  
c7cc 3a d6 c7			ld a, (.dmark+2)  
c7cf 32 64 ee			ld (debug_mark+2),a  
c7d2 18 03			jr .pastdmark  
c7d4 ..			.dmark: db "TCd"  
c7d7 f1			.pastdmark: pop af  
c7d8			endm  
# End of macro DMARK
c7d8						CALLMONITOR 
c7d8 cd 6f ee			call debug_vector  
c7db				endm  
# End of macro CALLMONITOR
c7db					endif 
c7db					NEXTW 
c7db cd 6c ee			call parse_vector 
c7de c3 aa 9d			jp macro_next 
c7e1				endm 
# End of macro NEXTW
c7e1			 
c7e1			.SUBSTR: 
c7e1				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c7e1 48				db WORD_SYS_CORE+52             
c7e2 41 c8			dw .LEFT            
c7e4 07				db 6 + 1 
c7e5 .. 00			db "SUBSTR",0              
c7ec				endm 
# End of macro CWHEAD
c7ec			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c7ec			 
c7ec					if DEBUG_FORTH_WORDS_KEY 
c7ec						DMARK "SST" 
c7ec f5				push af  
c7ed 3a 01 c8			ld a, (.dmark)  
c7f0 32 62 ee			ld (debug_mark),a  
c7f3 3a 02 c8			ld a, (.dmark+1)  
c7f6 32 63 ee			ld (debug_mark+1),a  
c7f9 3a 03 c8			ld a, (.dmark+2)  
c7fc 32 64 ee			ld (debug_mark+2),a  
c7ff 18 03			jr .pastdmark  
c801 ..			.dmark: db "SST"  
c804 f1			.pastdmark: pop af  
c805			endm  
# End of macro DMARK
c805						CALLMONITOR 
c805 cd 6f ee			call debug_vector  
c808				endm  
# End of macro CALLMONITOR
c808					endif 
c808			; TODO check string type 
c808					FORTH_DSP_VALUEHL 
c808 cd c3 9b			call macro_dsp_valuehl 
c80b				endm 
# End of macro FORTH_DSP_VALUEHL
c80b			 
c80b e5					push hl      ; string length 
c80c			 
c80c					FORTH_DSP_POP 
c80c cd 7b 9c			call macro_forth_dsp_pop 
c80f				endm 
# End of macro FORTH_DSP_POP
c80f			 
c80f					FORTH_DSP_VALUEHL 
c80f cd c3 9b			call macro_dsp_valuehl 
c812				endm 
# End of macro FORTH_DSP_VALUEHL
c812			 
c812 e5					push hl     ; start char 
c813			 
c813					FORTH_DSP_POP 
c813 cd 7b 9c			call macro_forth_dsp_pop 
c816				endm 
# End of macro FORTH_DSP_POP
c816			 
c816			 
c816					FORTH_DSP_VALUE 
c816 cd ac 9b			call macro_forth_dsp_value 
c819				endm 
# End of macro FORTH_DSP_VALUE
c819			 
c819 d1					pop de    ; get start post offset 
c81a			 
c81a 19					add hl, de    ; starting offset 
c81b			 
c81b c1					pop bc 
c81c c5					push bc      ; grab size of string 
c81d			 
c81d e5					push hl    ; save string start  
c81e			 
c81e 26 00				ld h, 0 
c820 69					ld l, c 
c821 23					inc hl 
c822 23					inc hl 
c823			 
c823 cd a2 90				call malloc 
c826				if DEBUG_FORTH_MALLOC_GUARD 
c826 cc 18 d3				call z,malloc_error 
c829				endif 
c829			 
c829 eb					ex de, hl      ; save malloc area for string copy 
c82a e1					pop hl    ; get back source 
c82b c1					pop bc    ; get length of string back 
c82c			 
c82c d5					push de    ; save malloc area for after we push 
c82d ed b0				ldir     ; copy substr 
c82f			 
c82f			 
c82f eb					ex de, hl 
c830			;		ld a, 0 
c830 36 00				ld (hl), 0   ; term substr 
c832			 
c832					 
c832 e1					pop hl    ; get malloc so we can push it 
c833 e5					push hl   ; save so we can free it afterwards 
c834			 
c834 cd 31 9a				call forth_push_str 
c837			 
c837 e1					pop hl 
c838 cd 6c 91				call free 
c83b			 
c83b					 
c83b					 
c83b			 
c83b			 
c83b					NEXTW 
c83b cd 6c ee			call parse_vector 
c83e c3 aa 9d			jp macro_next 
c841				endm 
# End of macro NEXTW
c841			 
c841			.LEFT: 
c841				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c841 48				db WORD_SYS_CORE+52             
c842 85 c8			dw .RIGHT            
c844 05				db 4 + 1 
c845 .. 00			db "LEFT",0              
c84a				endm 
# End of macro CWHEAD
c84a			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
c84a					if DEBUG_FORTH_WORDS_KEY 
c84a						DMARK "LEF" 
c84a f5				push af  
c84b 3a 5f c8			ld a, (.dmark)  
c84e 32 62 ee			ld (debug_mark),a  
c851 3a 60 c8			ld a, (.dmark+1)  
c854 32 63 ee			ld (debug_mark+1),a  
c857 3a 61 c8			ld a, (.dmark+2)  
c85a 32 64 ee			ld (debug_mark+2),a  
c85d 18 03			jr .pastdmark  
c85f ..			.dmark: db "LEF"  
c862 f1			.pastdmark: pop af  
c863			endm  
# End of macro DMARK
c863						CALLMONITOR 
c863 cd 6f ee			call debug_vector  
c866				endm  
# End of macro CALLMONITOR
c866					endif 
c866			 
c866					 
c866			; TODO check string type 
c866					FORTH_DSP_VALUEHL 
c866 cd c3 9b			call macro_dsp_valuehl 
c869				endm 
# End of macro FORTH_DSP_VALUEHL
c869			 
c869 e5					push hl      ; string length 
c86a			 
c86a					FORTH_DSP_POP 
c86a cd 7b 9c			call macro_forth_dsp_pop 
c86d				endm 
# End of macro FORTH_DSP_POP
c86d			 
c86d					FORTH_DSP_VALUEHL 
c86d cd c3 9b			call macro_dsp_valuehl 
c870				endm 
# End of macro FORTH_DSP_VALUEHL
c870			 
c870 c1					pop bc 
c871			 
c871 11 b8 e2				ld de, scratch 
c874 ed b0				ldir 
c876 3e 00				ld a, 0 
c878 12					ld (de), a 
c879					 
c879 21 b8 e2				ld hl, scratch 
c87c cd 31 9a				call forth_push_str 
c87f			 
c87f					NEXTW 
c87f cd 6c ee			call parse_vector 
c882 c3 aa 9d			jp macro_next 
c885				endm 
# End of macro NEXTW
c885			.RIGHT: 
c885				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c885 48				db WORD_SYS_CORE+52             
c886 46 c9			dw .STR2NUM            
c888 06				db 5 + 1 
c889 .. 00			db "RIGHT",0              
c88f				endm 
# End of macro CWHEAD
c88f			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
c88f					if DEBUG_FORTH_WORDS_KEY 
c88f						DMARK "RIG" 
c88f f5				push af  
c890 3a a4 c8			ld a, (.dmark)  
c893 32 62 ee			ld (debug_mark),a  
c896 3a a5 c8			ld a, (.dmark+1)  
c899 32 63 ee			ld (debug_mark+1),a  
c89c 3a a6 c8			ld a, (.dmark+2)  
c89f 32 64 ee			ld (debug_mark+2),a  
c8a2 18 03			jr .pastdmark  
c8a4 ..			.dmark: db "RIG"  
c8a7 f1			.pastdmark: pop af  
c8a8			endm  
# End of macro DMARK
c8a8						CALLMONITOR 
c8a8 cd 6f ee			call debug_vector  
c8ab				endm  
# End of macro CALLMONITOR
c8ab					endif 
c8ab			 
c8ab			; TODO check string type 
c8ab					FORTH_DSP_VALUEHL 
c8ab cd c3 9b			call macro_dsp_valuehl 
c8ae				endm 
# End of macro FORTH_DSP_VALUEHL
c8ae			 
c8ae e5					push hl      ; string length 
c8af			 
c8af					FORTH_DSP_POP 
c8af cd 7b 9c			call macro_forth_dsp_pop 
c8b2				endm 
# End of macro FORTH_DSP_POP
c8b2			 
c8b2					FORTH_DSP_VALUEHL 
c8b2 cd c3 9b			call macro_dsp_valuehl 
c8b5				endm 
# End of macro FORTH_DSP_VALUEHL
c8b5			 
c8b5					if DEBUG_FORTH_WORDS 
c8b5						DMARK "RI1" 
c8b5 f5				push af  
c8b6 3a ca c8			ld a, (.dmark)  
c8b9 32 62 ee			ld (debug_mark),a  
c8bc 3a cb c8			ld a, (.dmark+1)  
c8bf 32 63 ee			ld (debug_mark+1),a  
c8c2 3a cc c8			ld a, (.dmark+2)  
c8c5 32 64 ee			ld (debug_mark+2),a  
c8c8 18 03			jr .pastdmark  
c8ca ..			.dmark: db "RI1"  
c8cd f1			.pastdmark: pop af  
c8ce			endm  
# End of macro DMARK
c8ce						CALLMONITOR 
c8ce cd 6f ee			call debug_vector  
c8d1				endm  
# End of macro CALLMONITOR
c8d1					endif 
c8d1					; from the pointer to string get to the end of string 
c8d1			 
c8d1 01 ff 00				ld bc, 255 
c8d4 3e 00				ld a, 0 
c8d6 ed b1				cpir 
c8d8 2b					dec hl 
c8d9			 
c8d9					;  
c8d9			 
c8d9					if DEBUG_FORTH_WORDS 
c8d9						DMARK "RI2" 
c8d9 f5				push af  
c8da 3a ee c8			ld a, (.dmark)  
c8dd 32 62 ee			ld (debug_mark),a  
c8e0 3a ef c8			ld a, (.dmark+1)  
c8e3 32 63 ee			ld (debug_mark+1),a  
c8e6 3a f0 c8			ld a, (.dmark+2)  
c8e9 32 64 ee			ld (debug_mark+2),a  
c8ec 18 03			jr .pastdmark  
c8ee ..			.dmark: db "RI2"  
c8f1 f1			.pastdmark: pop af  
c8f2			endm  
# End of macro DMARK
c8f2						CALLMONITOR 
c8f2 cd 6f ee			call debug_vector  
c8f5				endm  
# End of macro CALLMONITOR
c8f5					endif 
c8f5			 
c8f5 c1					pop bc    ;  length of string to copy 
c8f6			 
c8f6 79					ld a, c 
c8f7 eb					ex de, hl 
c8f8 21 b8 e2				ld hl, scratch  
c8fb cd d6 8c				call addatohl 
c8fe			 
c8fe eb					ex de, hl 
c8ff			 
c8ff					if DEBUG_FORTH_WORDS 
c8ff						DMARK "RI3" 
c8ff f5				push af  
c900 3a 14 c9			ld a, (.dmark)  
c903 32 62 ee			ld (debug_mark),a  
c906 3a 15 c9			ld a, (.dmark+1)  
c909 32 63 ee			ld (debug_mark+1),a  
c90c 3a 16 c9			ld a, (.dmark+2)  
c90f 32 64 ee			ld (debug_mark+2),a  
c912 18 03			jr .pastdmark  
c914 ..			.dmark: db "RI3"  
c917 f1			.pastdmark: pop af  
c918			endm  
# End of macro DMARK
c918						CALLMONITOR 
c918 cd 6f ee			call debug_vector  
c91b				endm  
# End of macro CALLMONITOR
c91b					endif 
c91b			 
c91b 03					inc bc 
c91c ed b8				lddr 
c91e					 
c91e 21 b8 e2				ld hl, scratch 
c921					if DEBUG_FORTH_WORDS 
c921						DMARK "RI4" 
c921 f5				push af  
c922 3a 36 c9			ld a, (.dmark)  
c925 32 62 ee			ld (debug_mark),a  
c928 3a 37 c9			ld a, (.dmark+1)  
c92b 32 63 ee			ld (debug_mark+1),a  
c92e 3a 38 c9			ld a, (.dmark+2)  
c931 32 64 ee			ld (debug_mark+2),a  
c934 18 03			jr .pastdmark  
c936 ..			.dmark: db "RI4"  
c939 f1			.pastdmark: pop af  
c93a			endm  
# End of macro DMARK
c93a						CALLMONITOR 
c93a cd 6f ee			call debug_vector  
c93d				endm  
# End of macro CALLMONITOR
c93d					endif 
c93d cd 31 9a				call forth_push_str 
c940			 
c940			 
c940					NEXTW 
c940 cd 6c ee			call parse_vector 
c943 c3 aa 9d			jp macro_next 
c946				endm 
# End of macro NEXTW
c946			 
c946			 
c946			.STR2NUM: 
c946				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c946 48				db WORD_SYS_CORE+52             
c947 d5 c9			dw .NUM2STR            
c949 08				db 7 + 1 
c94a .. 00			db "STR2NUM",0              
c952				endm 
# End of macro CWHEAD
c952			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c952			 
c952			 
c952			; TODO STR type check to do 
c952					if DEBUG_FORTH_WORDS_KEY 
c952						DMARK "S2N" 
c952 f5				push af  
c953 3a 67 c9			ld a, (.dmark)  
c956 32 62 ee			ld (debug_mark),a  
c959 3a 68 c9			ld a, (.dmark+1)  
c95c 32 63 ee			ld (debug_mark+1),a  
c95f 3a 69 c9			ld a, (.dmark+2)  
c962 32 64 ee			ld (debug_mark+2),a  
c965 18 03			jr .pastdmark  
c967 ..			.dmark: db "S2N"  
c96a f1			.pastdmark: pop af  
c96b			endm  
# End of macro DMARK
c96b						CALLMONITOR 
c96b cd 6f ee			call debug_vector  
c96e				endm  
# End of macro CALLMONITOR
c96e					endif 
c96e			 
c96e					;FORTH_DSP 
c96e					FORTH_DSP_VALUE 
c96e cd ac 9b			call macro_forth_dsp_value 
c971				endm 
# End of macro FORTH_DSP_VALUE
c971					;inc hl 
c971			 
c971 eb					ex de, hl 
c972					if DEBUG_FORTH_WORDS 
c972						DMARK "S2a" 
c972 f5				push af  
c973 3a 87 c9			ld a, (.dmark)  
c976 32 62 ee			ld (debug_mark),a  
c979 3a 88 c9			ld a, (.dmark+1)  
c97c 32 63 ee			ld (debug_mark+1),a  
c97f 3a 89 c9			ld a, (.dmark+2)  
c982 32 64 ee			ld (debug_mark+2),a  
c985 18 03			jr .pastdmark  
c987 ..			.dmark: db "S2a"  
c98a f1			.pastdmark: pop af  
c98b			endm  
# End of macro DMARK
c98b						CALLMONITOR 
c98b cd 6f ee			call debug_vector  
c98e				endm  
# End of macro CALLMONITOR
c98e					endif 
c98e cd c5 8f				call string_to_uint16 
c991			 
c991					if DEBUG_FORTH_WORDS 
c991						DMARK "S2b" 
c991 f5				push af  
c992 3a a6 c9			ld a, (.dmark)  
c995 32 62 ee			ld (debug_mark),a  
c998 3a a7 c9			ld a, (.dmark+1)  
c99b 32 63 ee			ld (debug_mark+1),a  
c99e 3a a8 c9			ld a, (.dmark+2)  
c9a1 32 64 ee			ld (debug_mark+2),a  
c9a4 18 03			jr .pastdmark  
c9a6 ..			.dmark: db "S2b"  
c9a9 f1			.pastdmark: pop af  
c9aa			endm  
# End of macro DMARK
c9aa						CALLMONITOR 
c9aa cd 6f ee			call debug_vector  
c9ad				endm  
# End of macro CALLMONITOR
c9ad					endif 
c9ad			;		push hl 
c9ad					FORTH_DSP_POP 
c9ad cd 7b 9c			call macro_forth_dsp_pop 
c9b0				endm 
# End of macro FORTH_DSP_POP
c9b0			;		pop hl 
c9b0					 
c9b0					if DEBUG_FORTH_WORDS 
c9b0						DMARK "S2b" 
c9b0 f5				push af  
c9b1 3a c5 c9			ld a, (.dmark)  
c9b4 32 62 ee			ld (debug_mark),a  
c9b7 3a c6 c9			ld a, (.dmark+1)  
c9ba 32 63 ee			ld (debug_mark+1),a  
c9bd 3a c7 c9			ld a, (.dmark+2)  
c9c0 32 64 ee			ld (debug_mark+2),a  
c9c3 18 03			jr .pastdmark  
c9c5 ..			.dmark: db "S2b"  
c9c8 f1			.pastdmark: pop af  
c9c9			endm  
# End of macro DMARK
c9c9						CALLMONITOR 
c9c9 cd 6f ee			call debug_vector  
c9cc				endm  
# End of macro CALLMONITOR
c9cc					endif 
c9cc cd c7 99				call forth_push_numhl	 
c9cf			 
c9cf				 
c9cf				       NEXTW 
c9cf cd 6c ee			call parse_vector 
c9d2 c3 aa 9d			jp macro_next 
c9d5				endm 
# End of macro NEXTW
c9d5			.NUM2STR: 
c9d5				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c9d5 48				db WORD_SYS_CORE+52             
c9d6 6a ca			dw .CONCAT            
c9d8 08				db 7 + 1 
c9d9 .. 00			db "NUM2STR",0              
c9e1				endm 
# End of macro CWHEAD
c9e1			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
c9e1			 
c9e1			;		; malloc a string to target 
c9e1			;		ld hl, 10     ; TODO max string size should be fine 
c9e1			;		call malloc 
c9e1			;		push hl    ; save malloc location 
c9e1			; 
c9e1			; 
c9e1			;; TODO check int type 
c9e1					if DEBUG_FORTH_WORDS_KEY 
c9e1						DMARK "N2S" 
c9e1 f5				push af  
c9e2 3a f6 c9			ld a, (.dmark)  
c9e5 32 62 ee			ld (debug_mark),a  
c9e8 3a f7 c9			ld a, (.dmark+1)  
c9eb 32 63 ee			ld (debug_mark+1),a  
c9ee 3a f8 c9			ld a, (.dmark+2)  
c9f1 32 64 ee			ld (debug_mark+2),a  
c9f4 18 03			jr .pastdmark  
c9f6 ..			.dmark: db "N2S"  
c9f9 f1			.pastdmark: pop af  
c9fa			endm  
# End of macro DMARK
c9fa						CALLMONITOR 
c9fa cd 6f ee			call debug_vector  
c9fd				endm  
# End of macro CALLMONITOR
c9fd					endif 
c9fd			 
c9fd					FORTH_DSP_VALUEHL 
c9fd cd c3 9b			call macro_dsp_valuehl 
ca00				endm 
# End of macro FORTH_DSP_VALUEHL
ca00			 
ca00					if DEBUG_FORTH_WORDS 
ca00						DMARK "NS1" 
ca00 f5				push af  
ca01 3a 15 ca			ld a, (.dmark)  
ca04 32 62 ee			ld (debug_mark),a  
ca07 3a 16 ca			ld a, (.dmark+1)  
ca0a 32 63 ee			ld (debug_mark+1),a  
ca0d 3a 17 ca			ld a, (.dmark+2)  
ca10 32 64 ee			ld (debug_mark+2),a  
ca13 18 03			jr .pastdmark  
ca15 ..			.dmark: db "NS1"  
ca18 f1			.pastdmark: pop af  
ca19			endm  
# End of macro DMARK
ca19						CALLMONITOR 
ca19 cd 6f ee			call debug_vector  
ca1c				endm  
# End of macro CALLMONITOR
ca1c					endif 
ca1c					FORTH_DSP_POP 
ca1c cd 7b 9c			call macro_forth_dsp_pop 
ca1f				endm 
# End of macro FORTH_DSP_POP
ca1f			 
ca1f eb					ex de, hl 
ca20 21 b8 e2				ld hl, scratch 
ca23					if DEBUG_FORTH_WORDS 
ca23						DMARK "NS2" 
ca23 f5				push af  
ca24 3a 38 ca			ld a, (.dmark)  
ca27 32 62 ee			ld (debug_mark),a  
ca2a 3a 39 ca			ld a, (.dmark+1)  
ca2d 32 63 ee			ld (debug_mark+1),a  
ca30 3a 3a ca			ld a, (.dmark+2)  
ca33 32 64 ee			ld (debug_mark+2),a  
ca36 18 03			jr .pastdmark  
ca38 ..			.dmark: db "NS2"  
ca3b f1			.pastdmark: pop af  
ca3c			endm  
# End of macro DMARK
ca3c						CALLMONITOR 
ca3c cd 6f ee			call debug_vector  
ca3f				endm  
# End of macro CALLMONITOR
ca3f					endif 
ca3f cd dd 8f				call uitoa_16 
ca42 21 b8 e2				ld hl, scratch 
ca45					if DEBUG_FORTH_WORDS 
ca45						DMARK "NS3" 
ca45 f5				push af  
ca46 3a 5a ca			ld a, (.dmark)  
ca49 32 62 ee			ld (debug_mark),a  
ca4c 3a 5b ca			ld a, (.dmark+1)  
ca4f 32 63 ee			ld (debug_mark+1),a  
ca52 3a 5c ca			ld a, (.dmark+2)  
ca55 32 64 ee			ld (debug_mark+2),a  
ca58 18 03			jr .pastdmark  
ca5a ..			.dmark: db "NS3"  
ca5d f1			.pastdmark: pop af  
ca5e			endm  
# End of macro DMARK
ca5e						CALLMONITOR 
ca5e cd 6f ee			call debug_vector  
ca61				endm  
# End of macro CALLMONITOR
ca61					endif 
ca61 cd 31 9a				call forth_push_str 
ca64			;		ld a, l 
ca64			;		call DispAToASCII   
ca64			;;TODO need to chage above call to dump into string 
ca64			; 
ca64			; 
ca64			 
ca64				       NEXTW 
ca64 cd 6c ee			call parse_vector 
ca67 c3 aa 9d			jp macro_next 
ca6a				endm 
# End of macro NEXTW
ca6a			 
ca6a			.CONCAT: 
ca6a				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
ca6a 48				db WORD_SYS_CORE+52             
ca6b 20 cb			dw .FIND            
ca6d 07				db 6 + 1 
ca6e .. 00			db "CONCAT",0              
ca75				endm 
# End of macro CWHEAD
ca75			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
ca75			 
ca75			; TODO check string type 
ca75			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
ca75			 
ca75					if DEBUG_FORTH_WORDS_KEY 
ca75						DMARK "CON" 
ca75 f5				push af  
ca76 3a 8a ca			ld a, (.dmark)  
ca79 32 62 ee			ld (debug_mark),a  
ca7c 3a 8b ca			ld a, (.dmark+1)  
ca7f 32 63 ee			ld (debug_mark+1),a  
ca82 3a 8c ca			ld a, (.dmark+2)  
ca85 32 64 ee			ld (debug_mark+2),a  
ca88 18 03			jr .pastdmark  
ca8a ..			.dmark: db "CON"  
ca8d f1			.pastdmark: pop af  
ca8e			endm  
# End of macro DMARK
ca8e						CALLMONITOR 
ca8e cd 6f ee			call debug_vector  
ca91				endm  
# End of macro CALLMONITOR
ca91					endif 
ca91			 
ca91			 
ca91					FORTH_DSP_VALUE 
ca91 cd ac 9b			call macro_forth_dsp_value 
ca94				endm 
# End of macro FORTH_DSP_VALUE
ca94 e5					push hl   ; s2 
ca95			 
ca95					FORTH_DSP_POP 
ca95 cd 7b 9c			call macro_forth_dsp_pop 
ca98				endm 
# End of macro FORTH_DSP_POP
ca98			 
ca98					FORTH_DSP_VALUE 
ca98 cd ac 9b			call macro_forth_dsp_value 
ca9b				endm 
# End of macro FORTH_DSP_VALUE
ca9b			 
ca9b e5					push hl   ; s1 
ca9c			 
ca9c					FORTH_DSP_POP 
ca9c cd 7b 9c			call macro_forth_dsp_pop 
ca9f				endm 
# End of macro FORTH_DSP_POP
ca9f					 
ca9f			 
ca9f					; copy s1 
ca9f			 
ca9f				 
ca9f					; save ptr 
ca9f e1					pop hl  
caa0 e5					push hl 
caa1 3e 00				ld a, 0 
caa3 cd 39 90				call strlent 
caa6					;inc hl    ; zer0 
caa6 06 00				ld b, 0 
caa8 4d					ld c, l 
caa9 e1					pop hl		 
caaa 11 b8 e2				ld de, scratch	 
caad					if DEBUG_FORTH_WORDS 
caad						DMARK "CO1" 
caad f5				push af  
caae 3a c2 ca			ld a, (.dmark)  
cab1 32 62 ee			ld (debug_mark),a  
cab4 3a c3 ca			ld a, (.dmark+1)  
cab7 32 63 ee			ld (debug_mark+1),a  
caba 3a c4 ca			ld a, (.dmark+2)  
cabd 32 64 ee			ld (debug_mark+2),a  
cac0 18 03			jr .pastdmark  
cac2 ..			.dmark: db "CO1"  
cac5 f1			.pastdmark: pop af  
cac6			endm  
# End of macro DMARK
cac6						CALLMONITOR 
cac6 cd 6f ee			call debug_vector  
cac9				endm  
# End of macro CALLMONITOR
cac9					endif 
cac9 ed b0				ldir 
cacb			 
cacb e1					pop hl 
cacc e5					push hl 
cacd d5					push de 
cace			 
cace			 
cace 3e 00				ld a, 0 
cad0 cd 39 90				call strlent 
cad3 23					inc hl    ; zer0 
cad4 23					inc hl 
cad5 06 00				ld b, 0 
cad7 4d					ld c, l 
cad8 d1					pop de 
cad9 e1					pop hl		 
cada					if DEBUG_FORTH_WORDS 
cada						DMARK "CO2" 
cada f5				push af  
cadb 3a ef ca			ld a, (.dmark)  
cade 32 62 ee			ld (debug_mark),a  
cae1 3a f0 ca			ld a, (.dmark+1)  
cae4 32 63 ee			ld (debug_mark+1),a  
cae7 3a f1 ca			ld a, (.dmark+2)  
caea 32 64 ee			ld (debug_mark+2),a  
caed 18 03			jr .pastdmark  
caef ..			.dmark: db "CO2"  
caf2 f1			.pastdmark: pop af  
caf3			endm  
# End of macro DMARK
caf3						CALLMONITOR 
caf3 cd 6f ee			call debug_vector  
caf6				endm  
# End of macro CALLMONITOR
caf6					endif 
caf6 ed b0				ldir 
caf8			 
caf8			 
caf8			 
caf8 21 b8 e2				ld hl, scratch 
cafb					if DEBUG_FORTH_WORDS 
cafb						DMARK "CO5" 
cafb f5				push af  
cafc 3a 10 cb			ld a, (.dmark)  
caff 32 62 ee			ld (debug_mark),a  
cb02 3a 11 cb			ld a, (.dmark+1)  
cb05 32 63 ee			ld (debug_mark+1),a  
cb08 3a 12 cb			ld a, (.dmark+2)  
cb0b 32 64 ee			ld (debug_mark+2),a  
cb0e 18 03			jr .pastdmark  
cb10 ..			.dmark: db "CO5"  
cb13 f1			.pastdmark: pop af  
cb14			endm  
# End of macro DMARK
cb14						CALLMONITOR 
cb14 cd 6f ee			call debug_vector  
cb17				endm  
# End of macro CALLMONITOR
cb17					endif 
cb17			 
cb17 cd 31 9a				call forth_push_str 
cb1a			 
cb1a			 
cb1a			 
cb1a			 
cb1a				       NEXTW 
cb1a cd 6c ee			call parse_vector 
cb1d c3 aa 9d			jp macro_next 
cb20				endm 
# End of macro NEXTW
cb20			 
cb20			 
cb20			.FIND: 
cb20				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
cb20 4b				db WORD_SYS_CORE+55             
cb21 e0 cb			dw .LEN            
cb23 05				db 4 + 1 
cb24 .. 00			db "FIND",0              
cb29				endm 
# End of macro CWHEAD
cb29			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
cb29			 
cb29					if DEBUG_FORTH_WORDS_KEY 
cb29						DMARK "FND" 
cb29 f5				push af  
cb2a 3a 3e cb			ld a, (.dmark)  
cb2d 32 62 ee			ld (debug_mark),a  
cb30 3a 3f cb			ld a, (.dmark+1)  
cb33 32 63 ee			ld (debug_mark+1),a  
cb36 3a 40 cb			ld a, (.dmark+2)  
cb39 32 64 ee			ld (debug_mark+2),a  
cb3c 18 03			jr .pastdmark  
cb3e ..			.dmark: db "FND"  
cb41 f1			.pastdmark: pop af  
cb42			endm  
# End of macro DMARK
cb42						CALLMONITOR 
cb42 cd 6f ee			call debug_vector  
cb45				endm  
# End of macro CALLMONITOR
cb45					endif 
cb45			 
cb45			; TODO check string type 
cb45					FORTH_DSP_VALUE 
cb45 cd ac 9b			call macro_forth_dsp_value 
cb48				endm 
# End of macro FORTH_DSP_VALUE
cb48			 
cb48 e5					push hl    
cb49 7e					ld a,(hl)    ; char to find   
cb4a			; TODO change char to substr 
cb4a			 
cb4a f5					push af 
cb4b					 
cb4b			 
cb4b			 
cb4b					if DEBUG_FORTH_WORDS 
cb4b						DMARK "FN1" 
cb4b f5				push af  
cb4c 3a 60 cb			ld a, (.dmark)  
cb4f 32 62 ee			ld (debug_mark),a  
cb52 3a 61 cb			ld a, (.dmark+1)  
cb55 32 63 ee			ld (debug_mark+1),a  
cb58 3a 62 cb			ld a, (.dmark+2)  
cb5b 32 64 ee			ld (debug_mark+2),a  
cb5e 18 03			jr .pastdmark  
cb60 ..			.dmark: db "FN1"  
cb63 f1			.pastdmark: pop af  
cb64			endm  
# End of macro DMARK
cb64						CALLMONITOR 
cb64 cd 6f ee			call debug_vector  
cb67				endm  
# End of macro CALLMONITOR
cb67					endif 
cb67			 
cb67					FORTH_DSP_POP 
cb67 cd 7b 9c			call macro_forth_dsp_pop 
cb6a				endm 
# End of macro FORTH_DSP_POP
cb6a			 
cb6a					; string to search 
cb6a			 
cb6a					FORTH_DSP_VALUE 
cb6a cd ac 9b			call macro_forth_dsp_value 
cb6d				endm 
# End of macro FORTH_DSP_VALUE
cb6d			 
cb6d d1					pop de  ; d is char to find  
cb6e			 
cb6e					if DEBUG_FORTH_WORDS 
cb6e						DMARK "FN2" 
cb6e f5				push af  
cb6f 3a 83 cb			ld a, (.dmark)  
cb72 32 62 ee			ld (debug_mark),a  
cb75 3a 84 cb			ld a, (.dmark+1)  
cb78 32 63 ee			ld (debug_mark+1),a  
cb7b 3a 85 cb			ld a, (.dmark+2)  
cb7e 32 64 ee			ld (debug_mark+2),a  
cb81 18 03			jr .pastdmark  
cb83 ..			.dmark: db "FN2"  
cb86 f1			.pastdmark: pop af  
cb87			endm  
# End of macro DMARK
cb87						CALLMONITOR 
cb87 cd 6f ee			call debug_vector  
cb8a				endm  
# End of macro CALLMONITOR
cb8a					endif 
cb8a					 
cb8a 01 00 00				ld bc, 0 
cb8d 7e			.findchar:      ld a,(hl) 
cb8e			;		cp 0   		 
cb8e b7					or a 
cb8f 28 27				jr z, .finddone     
cb91 ba					cp d 
cb92 28 20				jr z, .foundchar 
cb94 03					inc bc 
cb95 23					inc hl 
cb96					if DEBUG_FORTH_WORDS 
cb96						DMARK "FN3" 
cb96 f5				push af  
cb97 3a ab cb			ld a, (.dmark)  
cb9a 32 62 ee			ld (debug_mark),a  
cb9d 3a ac cb			ld a, (.dmark+1)  
cba0 32 63 ee			ld (debug_mark+1),a  
cba3 3a ad cb			ld a, (.dmark+2)  
cba6 32 64 ee			ld (debug_mark+2),a  
cba9 18 03			jr .pastdmark  
cbab ..			.dmark: db "FN3"  
cbae f1			.pastdmark: pop af  
cbaf			endm  
# End of macro DMARK
cbaf						CALLMONITOR 
cbaf cd 6f ee			call debug_vector  
cbb2				endm  
# End of macro CALLMONITOR
cbb2					endif 
cbb2 18 d9				jr .findchar 
cbb4			 
cbb4			 
cbb4 c5			.foundchar:	push bc 
cbb5 e1					pop hl 
cbb6 18 03				jr .findexit 
cbb8			 
cbb8			 
cbb8							 
cbb8			 
cbb8			.finddone:     ; got to end of string with no find 
cbb8 21 00 00				ld hl, 0 
cbbb			.findexit: 
cbbb			 
cbbb					if DEBUG_FORTH_WORDS 
cbbb						DMARK "FNd" 
cbbb f5				push af  
cbbc 3a d0 cb			ld a, (.dmark)  
cbbf 32 62 ee			ld (debug_mark),a  
cbc2 3a d1 cb			ld a, (.dmark+1)  
cbc5 32 63 ee			ld (debug_mark+1),a  
cbc8 3a d2 cb			ld a, (.dmark+2)  
cbcb 32 64 ee			ld (debug_mark+2),a  
cbce 18 03			jr .pastdmark  
cbd0 ..			.dmark: db "FNd"  
cbd3 f1			.pastdmark: pop af  
cbd4			endm  
# End of macro DMARK
cbd4						CALLMONITOR 
cbd4 cd 6f ee			call debug_vector  
cbd7				endm  
# End of macro CALLMONITOR
cbd7					endif 
cbd7 cd c7 99			call forth_push_numhl 
cbda			 
cbda				       NEXTW 
cbda cd 6c ee			call parse_vector 
cbdd c3 aa 9d			jp macro_next 
cbe0				endm 
# End of macro NEXTW
cbe0			 
cbe0			.LEN: 
cbe0				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
cbe0 4c				db WORD_SYS_CORE+56             
cbe1 4d cc			dw .ASC            
cbe3 06				db 5 + 1 
cbe4 .. 00			db "COUNT",0              
cbea				endm 
# End of macro CWHEAD
cbea			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
cbea			 
cbea					if DEBUG_FORTH_WORDS_KEY 
cbea						DMARK "CNT" 
cbea f5				push af  
cbeb 3a ff cb			ld a, (.dmark)  
cbee 32 62 ee			ld (debug_mark),a  
cbf1 3a 00 cc			ld a, (.dmark+1)  
cbf4 32 63 ee			ld (debug_mark+1),a  
cbf7 3a 01 cc			ld a, (.dmark+2)  
cbfa 32 64 ee			ld (debug_mark+2),a  
cbfd 18 03			jr .pastdmark  
cbff ..			.dmark: db "CNT"  
cc02 f1			.pastdmark: pop af  
cc03			endm  
# End of macro DMARK
cc03						CALLMONITOR 
cc03 cd 6f ee			call debug_vector  
cc06				endm  
# End of macro CALLMONITOR
cc06					endif 
cc06			; TODO check string type 
cc06					FORTH_DSP_VALUE 
cc06 cd ac 9b			call macro_forth_dsp_value 
cc09				endm 
# End of macro FORTH_DSP_VALUE
cc09			 
cc09			 
cc09					if DEBUG_FORTH_WORDS 
cc09						DMARK "CN?" 
cc09 f5				push af  
cc0a 3a 1e cc			ld a, (.dmark)  
cc0d 32 62 ee			ld (debug_mark),a  
cc10 3a 1f cc			ld a, (.dmark+1)  
cc13 32 63 ee			ld (debug_mark+1),a  
cc16 3a 20 cc			ld a, (.dmark+2)  
cc19 32 64 ee			ld (debug_mark+2),a  
cc1c 18 03			jr .pastdmark  
cc1e ..			.dmark: db "CN?"  
cc21 f1			.pastdmark: pop af  
cc22			endm  
# End of macro DMARK
cc22						CALLMONITOR 
cc22 cd 6f ee			call debug_vector  
cc25				endm  
# End of macro CALLMONITOR
cc25					endif 
cc25 cd 2e 90				call strlenz 
cc28					if DEBUG_FORTH_WORDS 
cc28						DMARK "CNl" 
cc28 f5				push af  
cc29 3a 3d cc			ld a, (.dmark)  
cc2c 32 62 ee			ld (debug_mark),a  
cc2f 3a 3e cc			ld a, (.dmark+1)  
cc32 32 63 ee			ld (debug_mark+1),a  
cc35 3a 3f cc			ld a, (.dmark+2)  
cc38 32 64 ee			ld (debug_mark+2),a  
cc3b 18 03			jr .pastdmark  
cc3d ..			.dmark: db "CNl"  
cc40 f1			.pastdmark: pop af  
cc41			endm  
# End of macro DMARK
cc41						CALLMONITOR 
cc41 cd 6f ee			call debug_vector  
cc44				endm  
# End of macro CALLMONITOR
cc44					endif 
cc44			 
cc44 cd c7 99				call forth_push_numhl 
cc47			 
cc47			 
cc47			 
cc47				       NEXTW 
cc47 cd 6c ee			call parse_vector 
cc4a c3 aa 9d			jp macro_next 
cc4d				endm 
# End of macro NEXTW
cc4d			.ASC: 
cc4d				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
cc4d 4d				db WORD_SYS_CORE+57             
cc4e be cc			dw .CHR            
cc50 04				db 3 + 1 
cc51 .. 00			db "ASC",0              
cc55				endm 
# End of macro CWHEAD
cc55			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
cc55					if DEBUG_FORTH_WORDS_KEY 
cc55						DMARK "ASC" 
cc55 f5				push af  
cc56 3a 6a cc			ld a, (.dmark)  
cc59 32 62 ee			ld (debug_mark),a  
cc5c 3a 6b cc			ld a, (.dmark+1)  
cc5f 32 63 ee			ld (debug_mark+1),a  
cc62 3a 6c cc			ld a, (.dmark+2)  
cc65 32 64 ee			ld (debug_mark+2),a  
cc68 18 03			jr .pastdmark  
cc6a ..			.dmark: db "ASC"  
cc6d f1			.pastdmark: pop af  
cc6e			endm  
# End of macro DMARK
cc6e						CALLMONITOR 
cc6e cd 6f ee			call debug_vector  
cc71				endm  
# End of macro CALLMONITOR
cc71					endif 
cc71					FORTH_DSP_VALUE 
cc71 cd ac 9b			call macro_forth_dsp_value 
cc74				endm 
# End of macro FORTH_DSP_VALUE
cc74					;v5 FORTH_DSP_VALUE 
cc74			;		inc hl      ; now at start of numeric as string 
cc74			 
cc74 e5					push hl 
cc75			 
cc75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cc75 cd 7b 9c			call macro_forth_dsp_pop 
cc78				endm 
# End of macro FORTH_DSP_POP
cc78			 
cc78 e1					pop hl 
cc79			 
cc79					if DEBUG_FORTH_WORDS 
cc79						DMARK "AS1" 
cc79 f5				push af  
cc7a 3a 8e cc			ld a, (.dmark)  
cc7d 32 62 ee			ld (debug_mark),a  
cc80 3a 8f cc			ld a, (.dmark+1)  
cc83 32 63 ee			ld (debug_mark+1),a  
cc86 3a 90 cc			ld a, (.dmark+2)  
cc89 32 64 ee			ld (debug_mark+2),a  
cc8c 18 03			jr .pastdmark  
cc8e ..			.dmark: db "AS1"  
cc91 f1			.pastdmark: pop af  
cc92			endm  
# End of macro DMARK
cc92						CALLMONITOR 
cc92 cd 6f ee			call debug_vector  
cc95				endm  
# End of macro CALLMONITOR
cc95					endif 
cc95					; push the content of a onto the stack as a value 
cc95			 
cc95 7e					ld a,(hl)   ; get char 
cc96 26 00				ld h,0 
cc98 6f					ld l,a 
cc99					if DEBUG_FORTH_WORDS 
cc99						DMARK "AS2" 
cc99 f5				push af  
cc9a 3a ae cc			ld a, (.dmark)  
cc9d 32 62 ee			ld (debug_mark),a  
cca0 3a af cc			ld a, (.dmark+1)  
cca3 32 63 ee			ld (debug_mark+1),a  
cca6 3a b0 cc			ld a, (.dmark+2)  
cca9 32 64 ee			ld (debug_mark+2),a  
ccac 18 03			jr .pastdmark  
ccae ..			.dmark: db "AS2"  
ccb1 f1			.pastdmark: pop af  
ccb2			endm  
# End of macro DMARK
ccb2						CALLMONITOR 
ccb2 cd 6f ee			call debug_vector  
ccb5				endm  
# End of macro CALLMONITOR
ccb5					endif 
ccb5 cd c7 99				call forth_push_numhl 
ccb8			 
ccb8				       NEXTW 
ccb8 cd 6c ee			call parse_vector 
ccbb c3 aa 9d			jp macro_next 
ccbe				endm 
# End of macro NEXTW
ccbe			 
ccbe			.CHR: 
ccbe				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
ccbe 4d				db WORD_SYS_CORE+57             
ccbf fd cc			dw .ENDSTR            
ccc1 04				db 3 + 1 
ccc2 .. 00			db "CHR",0              
ccc6				endm 
# End of macro CWHEAD
ccc6			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
ccc6					if DEBUG_FORTH_WORDS_KEY 
ccc6						DMARK "CHR" 
ccc6 f5				push af  
ccc7 3a db cc			ld a, (.dmark)  
ccca 32 62 ee			ld (debug_mark),a  
cccd 3a dc cc			ld a, (.dmark+1)  
ccd0 32 63 ee			ld (debug_mark+1),a  
ccd3 3a dd cc			ld a, (.dmark+2)  
ccd6 32 64 ee			ld (debug_mark+2),a  
ccd9 18 03			jr .pastdmark  
ccdb ..			.dmark: db "CHR"  
ccde f1			.pastdmark: pop af  
ccdf			endm  
# End of macro DMARK
ccdf						CALLMONITOR 
ccdf cd 6f ee			call debug_vector  
cce2				endm  
# End of macro CALLMONITOR
cce2					endif 
cce2					FORTH_DSP_VALUEHL 
cce2 cd c3 9b			call macro_dsp_valuehl 
cce5				endm 
# End of macro FORTH_DSP_VALUEHL
cce5			 
cce5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cce5 cd 7b 9c			call macro_forth_dsp_pop 
cce8				endm 
# End of macro FORTH_DSP_POP
cce8			 
cce8					; save asci byte as a zero term string and push string 
cce8			 
cce8 7d					ld a,l 
cce9 32 b8 e2				ld (scratch), a 
ccec			 
ccec 3e 00				ld a, 0 
ccee 32 b9 e2				ld (scratch+1), a 
ccf1			 
ccf1 21 b8 e2				ld hl, scratch 
ccf4 cd 31 9a				call forth_push_str 
ccf7			 
ccf7			 
ccf7				       NEXTW 
ccf7 cd 6c ee			call parse_vector 
ccfa c3 aa 9d			jp macro_next 
ccfd				endm 
# End of macro NEXTW
ccfd			 
ccfd			 
ccfd			 
ccfd			 
ccfd			.ENDSTR: 
ccfd			; eof 
ccfd			 
# End of file forth_words_str.asm
ccfd			include "forth_words_key.asm" 
ccfd			 
ccfd			; | ## Keyboard Words 
ccfd			 
ccfd			.KEY: 
ccfd				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
ccfd 3e				db WORD_SYS_CORE+42             
ccfe 30 cd			dw .KEYDB            
cd00 04				db 3 + 1 
cd01 .. 00			db "KEY",0              
cd05				endm 
# End of macro CWHEAD
cd05			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
cd05			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
cd05			; | | Can use something like this to process: 
cd05			; | | > repeat active . key ?dup if emit then #1 until  
cd05			 
cd05					if DEBUG_FORTH_WORDS_KEY 
cd05						DMARK "KEY" 
cd05 f5				push af  
cd06 3a 1a cd			ld a, (.dmark)  
cd09 32 62 ee			ld (debug_mark),a  
cd0c 3a 1b cd			ld a, (.dmark+1)  
cd0f 32 63 ee			ld (debug_mark+1),a  
cd12 3a 1c cd			ld a, (.dmark+2)  
cd15 32 64 ee			ld (debug_mark+2),a  
cd18 18 03			jr .pastdmark  
cd1a ..			.dmark: db "KEY"  
cd1d f1			.pastdmark: pop af  
cd1e			endm  
# End of macro DMARK
cd1e						CALLMONITOR 
cd1e cd 6f ee			call debug_vector  
cd21				endm  
# End of macro CALLMONITOR
cd21					endif 
cd21			; TODO currently waits 
cd21 cd 57 e4				call cinndb 
cd24					;call cin_wait 
cd24 6f					ld l, a 
cd25 26 00				ld h, 0 
cd27 cd c7 99				call forth_push_numhl 
cd2a					NEXTW 
cd2a cd 6c ee			call parse_vector 
cd2d c3 aa 9d			jp macro_next 
cd30				endm 
# End of macro NEXTW
cd30			.KEYDB: 
cd30				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
cd30 3e				db WORD_SYS_CORE+42             
cd31 65 cd			dw .WAITK            
cd33 06				db 5 + 1 
cd34 .. 00			db "KEYDB",0              
cd3a				endm 
# End of macro CWHEAD
cd3a			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
cd3a			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
cd3a			; | | Can use something like this to process: 
cd3a			; | | > repeat active . key ?dup if emit then #1 until  
cd3a			 
cd3a					if DEBUG_FORTH_WORDS_KEY 
cd3a						DMARK "KEB" 
cd3a f5				push af  
cd3b 3a 4f cd			ld a, (.dmark)  
cd3e 32 62 ee			ld (debug_mark),a  
cd41 3a 50 cd			ld a, (.dmark+1)  
cd44 32 63 ee			ld (debug_mark+1),a  
cd47 3a 51 cd			ld a, (.dmark+2)  
cd4a 32 64 ee			ld (debug_mark+2),a  
cd4d 18 03			jr .pastdmark  
cd4f ..			.dmark: db "KEB"  
cd52 f1			.pastdmark: pop af  
cd53			endm  
# End of macro DMARK
cd53						CALLMONITOR 
cd53 cd 6f ee			call debug_vector  
cd56				endm  
# End of macro CALLMONITOR
cd56					endif 
cd56			; TODO currently waits 
cd56 cd 57 e4				call cin 
cd59					;call cin_wait 
cd59 6f					ld l, a 
cd5a 26 00				ld h, 0 
cd5c cd c7 99				call forth_push_numhl 
cd5f					NEXTW 
cd5f cd 6c ee			call parse_vector 
cd62 c3 aa 9d			jp macro_next 
cd65				endm 
# End of macro NEXTW
cd65			.WAITK: 
cd65				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
cd65 3f				db WORD_SYS_CORE+43             
cd66 9a cd			dw .ACCEPT            
cd68 06				db 5 + 1 
cd69 .. 00			db "WAITK",0              
cd6f				endm 
# End of macro CWHEAD
cd6f			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
cd6f					if DEBUG_FORTH_WORDS_KEY 
cd6f						DMARK "WAI" 
cd6f f5				push af  
cd70 3a 84 cd			ld a, (.dmark)  
cd73 32 62 ee			ld (debug_mark),a  
cd76 3a 85 cd			ld a, (.dmark+1)  
cd79 32 63 ee			ld (debug_mark+1),a  
cd7c 3a 86 cd			ld a, (.dmark+2)  
cd7f 32 64 ee			ld (debug_mark+2),a  
cd82 18 03			jr .pastdmark  
cd84 ..			.dmark: db "WAI"  
cd87 f1			.pastdmark: pop af  
cd88			endm  
# End of macro DMARK
cd88						CALLMONITOR 
cd88 cd 6f ee			call debug_vector  
cd8b				endm  
# End of macro CALLMONITOR
cd8b					endif 
cd8b cd 51 e4				call cin_wait 
cd8e 6f					ld l, a 
cd8f 26 00				ld h, 0 
cd91 cd c7 99				call forth_push_numhl 
cd94					NEXTW 
cd94 cd 6c ee			call parse_vector 
cd97 c3 aa 9d			jp macro_next 
cd9a				endm 
# End of macro NEXTW
cd9a			.ACCEPT: 
cd9a				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
cd9a 40				db WORD_SYS_CORE+44             
cd9b fa cd			dw .EDIT            
cd9d 07				db 6 + 1 
cd9e .. 00			db "ACCEPT",0              
cda5				endm 
# End of macro CWHEAD
cda5			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
cda5					; TODO crashes on push 
cda5					if DEBUG_FORTH_WORDS_KEY 
cda5						DMARK "ACC" 
cda5 f5				push af  
cda6 3a ba cd			ld a, (.dmark)  
cda9 32 62 ee			ld (debug_mark),a  
cdac 3a bb cd			ld a, (.dmark+1)  
cdaf 32 63 ee			ld (debug_mark+1),a  
cdb2 3a bc cd			ld a, (.dmark+2)  
cdb5 32 64 ee			ld (debug_mark+2),a  
cdb8 18 03			jr .pastdmark  
cdba ..			.dmark: db "ACC"  
cdbd f1			.pastdmark: pop af  
cdbe			endm  
# End of macro DMARK
cdbe						CALLMONITOR 
cdbe cd 6f ee			call debug_vector  
cdc1				endm  
# End of macro CALLMONITOR
cdc1					endif 
cdc1 21 b6 e4				ld hl, os_input 
cdc4			;		ld a, 0 
cdc4 36 00				ld (hl),0 
cdc6 3a 55 ea				ld a,(f_cursor_ptr) 
cdc9 16 64				ld d, 100 
cdcb 0e 00				ld c, 0 
cdcd 1e 28				ld e, 40 
cdcf cd 03 8d				call input_str 
cdd2					; TODO perhaps do a type check and wrap in quotes if not a number 
cdd2 21 b6 e4				ld hl, os_input 
cdd5					if DEBUG_FORTH_WORDS 
cdd5						DMARK "AC1" 
cdd5 f5				push af  
cdd6 3a ea cd			ld a, (.dmark)  
cdd9 32 62 ee			ld (debug_mark),a  
cddc 3a eb cd			ld a, (.dmark+1)  
cddf 32 63 ee			ld (debug_mark+1),a  
cde2 3a ec cd			ld a, (.dmark+2)  
cde5 32 64 ee			ld (debug_mark+2),a  
cde8 18 03			jr .pastdmark  
cdea ..			.dmark: db "AC1"  
cded f1			.pastdmark: pop af  
cdee			endm  
# End of macro DMARK
cdee						CALLMONITOR 
cdee cd 6f ee			call debug_vector  
cdf1				endm  
# End of macro CALLMONITOR
cdf1					endif 
cdf1 cd 31 9a				call forth_push_str 
cdf4					NEXTW 
cdf4 cd 6c ee			call parse_vector 
cdf7 c3 aa 9d			jp macro_next 
cdfa				endm 
# End of macro NEXTW
cdfa			 
cdfa			.EDIT: 
cdfa				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
cdfa 40				db WORD_SYS_CORE+44             
cdfb 9f ce			dw .DEDIT            
cdfd 05				db 4 + 1 
cdfe .. 00			db "EDIT",0              
ce03				endm 
# End of macro CWHEAD
ce03			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
ce03			 
ce03					; TODO does not copy from stack 
ce03					if DEBUG_FORTH_WORDS_KEY 
ce03						DMARK "EDT" 
ce03 f5				push af  
ce04 3a 18 ce			ld a, (.dmark)  
ce07 32 62 ee			ld (debug_mark),a  
ce0a 3a 19 ce			ld a, (.dmark+1)  
ce0d 32 63 ee			ld (debug_mark+1),a  
ce10 3a 1a ce			ld a, (.dmark+2)  
ce13 32 64 ee			ld (debug_mark+2),a  
ce16 18 03			jr .pastdmark  
ce18 ..			.dmark: db "EDT"  
ce1b f1			.pastdmark: pop af  
ce1c			endm  
# End of macro DMARK
ce1c						CALLMONITOR 
ce1c cd 6f ee			call debug_vector  
ce1f				endm  
# End of macro CALLMONITOR
ce1f					endif 
ce1f			 
ce1f					;FORTH_DSP 
ce1f					FORTH_DSP_VALUEHL 
ce1f cd c3 9b			call macro_dsp_valuehl 
ce22				endm 
# End of macro FORTH_DSP_VALUEHL
ce22			;		inc hl    ; TODO do type check 
ce22			 
ce22			;		call get_word_hl 
ce22 e5					push hl 
ce23					if DEBUG_FORTH_WORDS 
ce23						DMARK "EDp" 
ce23 f5				push af  
ce24 3a 38 ce			ld a, (.dmark)  
ce27 32 62 ee			ld (debug_mark),a  
ce2a 3a 39 ce			ld a, (.dmark+1)  
ce2d 32 63 ee			ld (debug_mark+1),a  
ce30 3a 3a ce			ld a, (.dmark+2)  
ce33 32 64 ee			ld (debug_mark+2),a  
ce36 18 03			jr .pastdmark  
ce38 ..			.dmark: db "EDp"  
ce3b f1			.pastdmark: pop af  
ce3c			endm  
# End of macro DMARK
ce3c						CALLMONITOR 
ce3c cd 6f ee			call debug_vector  
ce3f				endm  
# End of macro CALLMONITOR
ce3f					endif 
ce3f				;	ld a, 0 
ce3f cd 2e 90				call strlenz 
ce42 23					inc hl 
ce43			 
ce43 06 00				ld b, 0 
ce45 4d					ld c, l 
ce46			 
ce46 e1					pop hl 
ce47 11 b6 e4				ld de, os_input 
ce4a					if DEBUG_FORTH_WORDS_KEY 
ce4a						DMARK "EDc" 
ce4a f5				push af  
ce4b 3a 5f ce			ld a, (.dmark)  
ce4e 32 62 ee			ld (debug_mark),a  
ce51 3a 60 ce			ld a, (.dmark+1)  
ce54 32 63 ee			ld (debug_mark+1),a  
ce57 3a 61 ce			ld a, (.dmark+2)  
ce5a 32 64 ee			ld (debug_mark+2),a  
ce5d 18 03			jr .pastdmark  
ce5f ..			.dmark: db "EDc"  
ce62 f1			.pastdmark: pop af  
ce63			endm  
# End of macro DMARK
ce63						CALLMONITOR 
ce63 cd 6f ee			call debug_vector  
ce66				endm  
# End of macro CALLMONITOR
ce66					endif 
ce66 ed b0				ldir 
ce68			 
ce68			 
ce68 21 b6 e4				ld hl, os_input 
ce6b					;ld a, 0 
ce6b					;ld (hl),a 
ce6b 3a 55 ea				ld a,(f_cursor_ptr) 
ce6e 16 64				ld d, 100 
ce70 0e 00				ld c, 0 
ce72 1e 28				ld e, 40 
ce74 cd 03 8d				call input_str 
ce77					; TODO perhaps do a type check and wrap in quotes if not a number 
ce77 21 b6 e4				ld hl, os_input 
ce7a					if DEBUG_FORTH_WORDS 
ce7a						DMARK "ED1" 
ce7a f5				push af  
ce7b 3a 8f ce			ld a, (.dmark)  
ce7e 32 62 ee			ld (debug_mark),a  
ce81 3a 90 ce			ld a, (.dmark+1)  
ce84 32 63 ee			ld (debug_mark+1),a  
ce87 3a 91 ce			ld a, (.dmark+2)  
ce8a 32 64 ee			ld (debug_mark+2),a  
ce8d 18 03			jr .pastdmark  
ce8f ..			.dmark: db "ED1"  
ce92 f1			.pastdmark: pop af  
ce93			endm  
# End of macro DMARK
ce93						CALLMONITOR 
ce93 cd 6f ee			call debug_vector  
ce96				endm  
# End of macro CALLMONITOR
ce96					endif 
ce96 cd 31 9a				call forth_push_str 
ce99					NEXTW 
ce99 cd 6c ee			call parse_vector 
ce9c c3 aa 9d			jp macro_next 
ce9f				endm 
# End of macro NEXTW
ce9f			 
ce9f			.DEDIT: 
ce9f				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
ce9f 40				db WORD_SYS_CORE+44             
cea0 04 cf			dw .ENDKEY            
cea2 06				db 5 + 1 
cea3 .. 00			db "DEDIT",0              
cea9				endm 
# End of macro CWHEAD
cea9			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
cea9			 
cea9					; TODO does not copy from stack 
cea9					if DEBUG_FORTH_WORDS_KEY 
cea9						DMARK "DED" 
cea9 f5				push af  
ceaa 3a be ce			ld a, (.dmark)  
cead 32 62 ee			ld (debug_mark),a  
ceb0 3a bf ce			ld a, (.dmark+1)  
ceb3 32 63 ee			ld (debug_mark+1),a  
ceb6 3a c0 ce			ld a, (.dmark+2)  
ceb9 32 64 ee			ld (debug_mark+2),a  
cebc 18 03			jr .pastdmark  
cebe ..			.dmark: db "DED"  
cec1 f1			.pastdmark: pop af  
cec2			endm  
# End of macro DMARK
cec2						CALLMONITOR 
cec2 cd 6f ee			call debug_vector  
cec5				endm  
# End of macro CALLMONITOR
cec5					endif 
cec5			 
cec5					;FORTH_DSP 
cec5					FORTH_DSP_VALUEHL 
cec5 cd c3 9b			call macro_dsp_valuehl 
cec8				endm 
# End of macro FORTH_DSP_VALUEHL
cec8			;		inc hl    ; TODO do type check 
cec8			 
cec8			;		call get_word_hl 
cec8 e5					push hl 
cec9 e5					push hl 
ceca					FORTH_DSP_POP 
ceca cd 7b 9c			call macro_forth_dsp_pop 
cecd				endm 
# End of macro FORTH_DSP_POP
cecd e1					pop hl 
cece					if DEBUG_FORTH_WORDS 
cece						DMARK "EDp" 
cece f5				push af  
cecf 3a e3 ce			ld a, (.dmark)  
ced2 32 62 ee			ld (debug_mark),a  
ced5 3a e4 ce			ld a, (.dmark+1)  
ced8 32 63 ee			ld (debug_mark+1),a  
cedb 3a e5 ce			ld a, (.dmark+2)  
cede 32 64 ee			ld (debug_mark+2),a  
cee1 18 03			jr .pastdmark  
cee3 ..			.dmark: db "EDp"  
cee6 f1			.pastdmark: pop af  
cee7			endm  
# End of macro DMARK
cee7						CALLMONITOR 
cee7 cd 6f ee			call debug_vector  
ceea				endm  
# End of macro CALLMONITOR
ceea					endif 
ceea				;	ld a, 0 
ceea cd 2e 90				call strlenz 
ceed 23					inc hl 
ceee			 
ceee 06 00				ld b, 0 
cef0 4d					ld c, l 
cef1			 
cef1 e1					pop hl 
cef2			 
cef2					;ld a, 0 
cef2					;ld (hl),a 
cef2 3a 55 ea				ld a,(f_cursor_ptr) 
cef5 16 64				ld d, 100 
cef7 0e 00				ld c, 0 
cef9 1e 28				ld e, 40 
cefb cd 03 8d				call input_str 
cefe					; TODO perhaps do a type check and wrap in quotes if not a number 
cefe					NEXTW 
cefe cd 6c ee			call parse_vector 
cf01 c3 aa 9d			jp macro_next 
cf04				endm 
# End of macro NEXTW
cf04			 
cf04			 
cf04			.ENDKEY: 
cf04			; eof 
cf04			 
# End of file forth_words_key.asm
cf04			include "forth_words_const.asm" 
cf04			 
cf04			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
cf04			 
cf04			 
cf04			.SPITIME: 
cf04				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
cf04 77				db WORD_SYS_CORE+99             
cf05 1c cf			dw .VA            
cf07 08				db 7 + 1 
cf08 .. 00			db "SPITIME",0              
cf10				endm 
# End of macro CWHEAD
cf10			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
cf10			; 
cf10			; | | If using BANK devices then leave as is. 
cf10			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
cf10			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
cf10			 
cf10 21 5b ea				ld hl, spi_clktime  
cf13 cd c7 99				call forth_push_numhl 
cf16			 
cf16					NEXTW 
cf16 cd 6c ee			call parse_vector 
cf19 c3 aa 9d			jp macro_next 
cf1c				endm 
# End of macro NEXTW
cf1c			 
cf1c			 
cf1c			.VA: 
cf1c				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
cf1c 77				db WORD_SYS_CORE+99             
cf1d 2f cf			dw .SYMBOL            
cf1f 03				db 2 + 1 
cf20 .. 00			db "VA",0              
cf23				endm 
# End of macro CWHEAD
cf23			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
cf23 21 1f ea				ld hl, cli_var_array 
cf26 cd c7 99				call forth_push_numhl 
cf29			 
cf29					NEXTW 
cf29 cd 6c ee			call parse_vector 
cf2c c3 aa 9d			jp macro_next 
cf2f				endm 
# End of macro NEXTW
cf2f			 
cf2f			.SYMBOL: 
cf2f				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
cf2f 77				db WORD_SYS_CORE+99             
cf30 3e d0			dw .ENDCONST            
cf32 07				db 6 + 1 
cf33 .. 00			db "SYMBOL",0              
cf3a				endm 
# End of macro CWHEAD
cf3a			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
cf3a			; | 
cf3a			; | | The value is the number reference and the final address is pushed to stack 
cf3a			 
cf3a			; | | ``` 
cf3a			; | | dw sym_table 
cf3a			; | | dw nmi_vector 
cf3a			; | | dw cli_autodisplay 
cf3a			; | | dw cli_data_sp 
cf3a			; | | dw cli_data_stack 
cf3a			; | | dw cli_loop_sp 
cf3a			; | | dw cli_loop_stack 
cf3a			; | | dw cli_var_array 
cf3a			; | | dw cursor_col 
cf3a			; | | dw cursor_ptr 
cf3a			; | | ; 10 
cf3a			; | | dw cursor_row 
cf3a			; | | dw debug_mark 
cf3a			; | | dw display_fb0 
cf3a			; | | dw display_fb1 
cf3a			; | | dw display_fb2 
cf3a			; | | dw display_fb3 
cf3a			; | | dw display_fb_active 
cf3a			; | | dw execscratch 
cf3a			; | | dw f_cursor_ptr 
cf3a			; | | dw hardware_word 
cf3a			; | | ;20 
cf3a			; | | dw input_at_cursor 
cf3a			; | | dw input_at_pos 
cf3a			; | | dw input_cur_flash 
cf3a			; | | dw input_cur_onoff 
cf3a			; | | dw input_cursor 
cf3a			; | | dw input_display_size 
cf3a			; | | dw input_len 
cf3a			; | | dw input_ptr 
cf3a			; | | dw input_size 
cf3a			; | | dw input_start 
cf3a			; | | ; 30 
cf3a			; | | dw input_str 
cf3a			; | | dw input_under_cursor 
cf3a			; | | dw os_cli_cmd 
cf3a			; | | dw os_cur_ptr 
cf3a			; | | dw os_current_i 
cf3a			; | | dw os_input 
cf3a			; | | dw os_last_cmd 
cf3a			; | | dw os_last_new_uword 
cf3a			; | | dw debug_vector 
cf3a			; | | dw os_view_hl 
cf3a			; | | ;40 
cf3a			; | | dw os_word_scratch 
cf3a			; | | dw portbctl 
cf3a			; | | dw portbdata 
cf3a			; | | dw spi_cartdev 
cf3a			; | | dw spi_cartdev2 
cf3a			; | | dw spi_clktime 
cf3a			; | | dw spi_device 
cf3a			; | | dw spi_device_id 
cf3a			; | | dw spi_portbyte 
cf3a			; | | dw stackstore 
cf3a			; | | ; 50 
cf3a			; | | if STORAGE_SE 
cf3a			; | | dw storage_actl 
cf3a			; | | dw storage_adata 
cf3a			; | | else 
cf3a			; | | dw 0 
cf3a			; | | dw 0 
cf3a			; | | endif 
cf3a			; | | dw storage_append 
cf3a			; | | if STORAGE_SE 
cf3a			; | | dw storage_bctl 
cf3a			; | | else 
cf3a			; | | dw 0 
cf3a			; | | endif 
cf3a			; | | dw store_bank_active 
cf3a			; | | dw store_filecache 
cf3a			; | | dw store_longread 
cf3a			; | | dw store_openaddr 
cf3a			; | | dw store_openext 
cf3a			; | | dw store_openmaxext 
cf3a			; | | ; 60 
cf3a			; | | dw store_page 
cf3a			; | | dw store_readbuf 
cf3a			; | | dw store_readcont 
cf3a			; | | dw store_readptr 
cf3a			; | | dw store_tmpext 
cf3a			; | | dw store_tmpid 
cf3a			; | | dw store_tmppageid 
cf3a			; | | dw malloc 
cf3a			; | | dw free 
cf3a			; | | dw cin 
cf3a			; | | ; 70 
cf3a			; | | dw cin_wait 
cf3a			; | | dw forth_push_numhl 
cf3a			; | | dw forth_push_str 
cf3a			; | | dw parse_vector 
cf3a			; | | ``` 
cf3a			 
cf3a					if DEBUG_FORTH_WORDS_KEY 
cf3a						DMARK "SYM" 
cf3a f5				push af  
cf3b 3a 4f cf			ld a, (.dmark)  
cf3e 32 62 ee			ld (debug_mark),a  
cf41 3a 50 cf			ld a, (.dmark+1)  
cf44 32 63 ee			ld (debug_mark+1),a  
cf47 3a 51 cf			ld a, (.dmark+2)  
cf4a 32 64 ee			ld (debug_mark+2),a  
cf4d 18 03			jr .pastdmark  
cf4f ..			.dmark: db "SYM"  
cf52 f1			.pastdmark: pop af  
cf53			endm  
# End of macro DMARK
cf53						CALLMONITOR 
cf53 cd 6f ee			call debug_vector  
cf56				endm  
# End of macro CALLMONITOR
cf56					endif 
cf56			 
cf56					FORTH_DSP_VALUEHL 
cf56 cd c3 9b			call macro_dsp_valuehl 
cf59				endm 
# End of macro FORTH_DSP_VALUEHL
cf59			 
cf59 7d					ld a, l     
cf5a			 
cf5a			 
cf5a					if DEBUG_FORTH_WORDS 
cf5a						DMARK "SY1" 
cf5a f5				push af  
cf5b 3a 6f cf			ld a, (.dmark)  
cf5e 32 62 ee			ld (debug_mark),a  
cf61 3a 70 cf			ld a, (.dmark+1)  
cf64 32 63 ee			ld (debug_mark+1),a  
cf67 3a 71 cf			ld a, (.dmark+2)  
cf6a 32 64 ee			ld (debug_mark+2),a  
cf6d 18 03			jr .pastdmark  
cf6f ..			.dmark: db "SY1"  
cf72 f1			.pastdmark: pop af  
cf73			endm  
# End of macro DMARK
cf73						CALLMONITOR 
cf73 cd 6f ee			call debug_vector  
cf76				endm  
# End of macro CALLMONITOR
cf76					endif 
cf76					 
cf76 f5					push af	 
cf77					FORTH_DSP_POP 
cf77 cd 7b 9c			call macro_forth_dsp_pop 
cf7a				endm 
# End of macro FORTH_DSP_POP
cf7a f1					pop af 
cf7b			 
cf7b cb 27				sla a  
cf7d				 
cf7d					 
cf7d					if DEBUG_FORTH_WORDS 
cf7d						DMARK "SY" 
cf7d f5				push af  
cf7e 3a 92 cf			ld a, (.dmark)  
cf81 32 62 ee			ld (debug_mark),a  
cf84 3a 93 cf			ld a, (.dmark+1)  
cf87 32 63 ee			ld (debug_mark+1),a  
cf8a 3a 94 cf			ld a, (.dmark+2)  
cf8d 32 64 ee			ld (debug_mark+2),a  
cf90 18 02			jr .pastdmark  
cf92 ..			.dmark: db "SY"  
cf94 f1			.pastdmark: pop af  
cf95			endm  
# End of macro DMARK
cf95						CALLMONITOR 
cf95 cd 6f ee			call debug_vector  
cf98				endm  
# End of macro CALLMONITOR
cf98					endif 
cf98			 
cf98 21 aa cf				ld hl, sym_table 
cf9b cd d6 8c				call addatohl 
cf9e cd 30 9d				call loadwordinhl 
cfa1 cd c7 99				call forth_push_numhl 
cfa4			 
cfa4			 
cfa4				       NEXTW 
cfa4 cd 6c ee			call parse_vector 
cfa7 c3 aa 9d			jp macro_next 
cfaa				endm 
# End of macro NEXTW
cfaa			 
cfaa			sym_table: 
cfaa			 
cfaa			; 0 
cfaa aa cf		dw sym_table 
cfac 72 ee		dw nmi_vector 
cfae 33 ea		dw cli_autodisplay 
cfb0 e5 e9		dw cli_data_sp 
cfb2 1f e8		dw cli_data_stack 
cfb4 e7 e9		dw cli_loop_sp 
cfb6 21 e9		dw cli_loop_stack 
cfb8 1f ea		dw cli_var_array 
cfba bc eb		dw cursor_col 
cfbc ba eb		dw cursor_ptr 
cfbe			; 10 
cfbe bb eb		dw cursor_row 
cfc0 62 ee		dw debug_mark 
cfc2 a8 ed		dw display_fb0 
cfc4 07 ed		dw display_fb1 
cfc6 c5 eb		dw display_fb2 
cfc8 66 ec		dw display_fb3 
cfca c3 eb		dw display_fb_active 
cfcc b7 e3		dw execscratch 
cfce 55 ea		dw f_cursor_ptr 
cfd0 75 ee		dw hardware_word 
cfd2			;20 
cfd2 59 ee		dw input_at_cursor 
cfd4 5b ee		dw input_at_pos 
cfd6 57 ee		dw input_cur_flash 
cfd8 56 ee		dw input_cur_onoff 
cfda 4c ee		dw input_cursor 
cfdc 5c ee		dw input_display_size 
cfde 51 ee		dw input_len 
cfe0 60 ee		dw input_ptr 
cfe2 5d ee		dw input_size 
cfe4 5e ee		dw input_start 
cfe6			; 30 
cfe6 03 8d		dw input_str 
cfe8 5a ee		dw input_under_cursor 
cfea df e5		dw os_cli_cmd 
cfec db e5		dw os_cur_ptr 
cfee dd e5		dw os_current_i 
cff0 b6 e4		dw os_input 
cff2 de e6		dw os_last_cmd 
cff4 b5 e5		dw os_last_new_uword 
cff6 6f ee		dw debug_vector 
cff8 9a e2		dw os_view_hl 
cffa			;40 
cffa bd e5		dw os_word_scratch 
cffc c3 00		dw portbctl 
cffe c1 00		dw portbdata 
d000 5a ea		dw spi_cartdev 
d002 59 ea		dw spi_cartdev2 
d004 5b ea		dw spi_clktime 
d006 57 ea		dw spi_device 
d008 56 ea		dw spi_device_id 
d00a 58 ea		dw spi_portbyte 
d00c 9e eb		dw stackstore 
d00e			; 50 
d00e			if STORAGE_SE 
d00e			dw storage_actl 
d00e			dw storage_adata 
d00e			else 
d00e 00 00		dw 0 
d010 00 00		dw 0 
d012			endif 
d012 6b 88		dw storage_append 
d014			if STORAGE_SE 
d014			dw storage_bctl 
d014			else 
d014 00 00		dw 0 
d016			endif 
d016 8a eb		dw store_bank_active 
d018 5e ea		dw store_filecache 
d01a 6c ea		dw store_longread 
d01c 62 ea		dw store_openaddr 
d01e 61 ea		dw store_openext 
d020 60 ea		dw store_openmaxext 
d022			; 60 
d022 71 ea		dw store_page 
d024 6d ea		dw store_readbuf 
d026 64 ea		dw store_readcont 
d028 6f ea		dw store_readptr 
d02a 64 ea		dw store_tmpext 
d02c 65 ea		dw store_tmpid 
d02e 5c ea		dw store_tmppageid 
d030 a2 90		dw malloc 
d032 6c 91		dw free 
d034 57 e4		dw cin 
d036			; 70 
d036 51 e4		dw cin_wait 
d038 c7 99		dw forth_push_numhl 
d03a 31 9a		dw forth_push_str 
d03c 6c ee		dw parse_vector 
d03e			 
d03e			.ENDCONST: 
d03e			 
d03e			; eof 
d03e			 
d03e			 
# End of file forth_words_const.asm
d03e			 
d03e			if STORAGE_SE 
d03e			   	include "forth_words_storage.asm" 
d03e			endif 
d03e				include "forth_words_device.asm" 
d03e			; Device related words 
d03e			 
d03e			; | ## Device Words 
d03e			 
d03e			;if SOUND_ENABLE 
d03e			;.NOTE: 
d03e			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
d03e			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
d03e			;		if DEBUG_FORTH_WORDS_KEY 
d03e			;			DMARK "NTE" 
d03e			;			CALLMONITOR 
d03e			;		endif 
d03e			; 
d03e			;	 
d03e			; 
d03e			;		NEXTW 
d03e			;.AFTERSOUND: 
d03e			;endif 
d03e			 
d03e			 
d03e			USE_GPIO: equ 0 
d03e			 
d03e			if USE_GPIO 
d03e			.GP1: 
d03e				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
d03e			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
d03e					NEXTW 
d03e			.GP2: 
d03e				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
d03e			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
d03e			 
d03e					NEXTW 
d03e			 
d03e			.GP3: 
d03e				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
d03e			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
d03e			 
d03e					NEXTW 
d03e			 
d03e			.GP4: 
d03e				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
d03e			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
d03e			 
d03e					NEXTW 
d03e			.SIN: 
d03e			 
d03e			 
d03e			endif 
d03e			 
d03e			 
d03e				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
d03e 33				db WORD_SYS_CORE+31             
d03f 76 d0			dw .SOUT            
d041 03				db 2 + 1 
d042 .. 00			db "IN",0              
d045				endm 
# End of macro CWHEAD
d045			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
d045					if DEBUG_FORTH_WORDS_KEY 
d045						DMARK "IN." 
d045 f5				push af  
d046 3a 5a d0			ld a, (.dmark)  
d049 32 62 ee			ld (debug_mark),a  
d04c 3a 5b d0			ld a, (.dmark+1)  
d04f 32 63 ee			ld (debug_mark+1),a  
d052 3a 5c d0			ld a, (.dmark+2)  
d055 32 64 ee			ld (debug_mark+2),a  
d058 18 03			jr .pastdmark  
d05a ..			.dmark: db "IN."  
d05d f1			.pastdmark: pop af  
d05e			endm  
# End of macro DMARK
d05e						CALLMONITOR 
d05e cd 6f ee			call debug_vector  
d061				endm  
# End of macro CALLMONITOR
d061					endif 
d061					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d061 cd c3 9b			call macro_dsp_valuehl 
d064				endm 
# End of macro FORTH_DSP_VALUEHL
d064			 
d064 e5					push hl 
d065			 
d065					; destroy value TOS 
d065			 
d065					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d065 cd 7b 9c			call macro_forth_dsp_pop 
d068				endm 
# End of macro FORTH_DSP_POP
d068			 
d068					; one value on hl get other one back 
d068			 
d068 c1					pop bc 
d069			 
d069					; do the sub 
d069			;		ex de, hl 
d069			 
d069 ed 68				in l,(c) 
d06b			 
d06b					; save it 
d06b			 
d06b 26 00				ld h,0 
d06d			 
d06d					; TODO push value back onto stack for another op etc 
d06d			 
d06d cd c7 99				call forth_push_numhl 
d070					NEXTW 
d070 cd 6c ee			call parse_vector 
d073 c3 aa 9d			jp macro_next 
d076				endm 
# End of macro NEXTW
d076			.SOUT: 
d076				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
d076 34				db WORD_SYS_CORE+32             
d077 cc d0			dw .SPIO            
d079 04				db 3 + 1 
d07a .. 00			db "OUT",0              
d07e				endm 
# End of macro CWHEAD
d07e			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
d07e					if DEBUG_FORTH_WORDS_KEY 
d07e						DMARK "OUT" 
d07e f5				push af  
d07f 3a 93 d0			ld a, (.dmark)  
d082 32 62 ee			ld (debug_mark),a  
d085 3a 94 d0			ld a, (.dmark+1)  
d088 32 63 ee			ld (debug_mark+1),a  
d08b 3a 95 d0			ld a, (.dmark+2)  
d08e 32 64 ee			ld (debug_mark+2),a  
d091 18 03			jr .pastdmark  
d093 ..			.dmark: db "OUT"  
d096 f1			.pastdmark: pop af  
d097			endm  
# End of macro DMARK
d097						CALLMONITOR 
d097 cd 6f ee			call debug_vector  
d09a				endm  
# End of macro CALLMONITOR
d09a					endif 
d09a			 
d09a					; get port 
d09a			 
d09a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d09a cd c3 9b			call macro_dsp_valuehl 
d09d				endm 
# End of macro FORTH_DSP_VALUEHL
d09d			 
d09d e5					push hl 
d09e			 
d09e					; destroy value TOS 
d09e			 
d09e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d09e cd 7b 9c			call macro_forth_dsp_pop 
d0a1				endm 
# End of macro FORTH_DSP_POP
d0a1			 
d0a1					; get byte to send 
d0a1			 
d0a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d0a1 cd c3 9b			call macro_dsp_valuehl 
d0a4				endm 
# End of macro FORTH_DSP_VALUEHL
d0a4			 
d0a4			;		push hl 
d0a4			 
d0a4					; destroy value TOS 
d0a4			 
d0a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d0a4 cd 7b 9c			call macro_forth_dsp_pop 
d0a7				endm 
# End of macro FORTH_DSP_POP
d0a7			 
d0a7					; one value on hl get other one back 
d0a7			 
d0a7			;		pop hl 
d0a7			 
d0a7 c1					pop bc 
d0a8			 
d0a8					if DEBUG_FORTH_WORDS 
d0a8						DMARK "OUT" 
d0a8 f5				push af  
d0a9 3a bd d0			ld a, (.dmark)  
d0ac 32 62 ee			ld (debug_mark),a  
d0af 3a be d0			ld a, (.dmark+1)  
d0b2 32 63 ee			ld (debug_mark+1),a  
d0b5 3a bf d0			ld a, (.dmark+2)  
d0b8 32 64 ee			ld (debug_mark+2),a  
d0bb 18 03			jr .pastdmark  
d0bd ..			.dmark: db "OUT"  
d0c0 f1			.pastdmark: pop af  
d0c1			endm  
# End of macro DMARK
d0c1						CALLMONITOR 
d0c1 cd 6f ee			call debug_vector  
d0c4				endm  
# End of macro CALLMONITOR
d0c4					endif 
d0c4			 
d0c4 ed 69				out (c), l 
d0c6			 
d0c6					NEXTW 
d0c6 cd 6c ee			call parse_vector 
d0c9 c3 aa 9d			jp macro_next 
d0cc				endm 
# End of macro NEXTW
d0cc			 
d0cc			 
d0cc			.SPIO: 
d0cc			 
d0cc			if STORAGE_SE 
d0cc				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
d0cc			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
d0cc			 
d0cc					call spi_ce_low 
d0cc			    NEXTW 
d0cc			 
d0cc			.SPICEH: 
d0cc				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
d0cc			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
d0cc			 
d0cc					call spi_ce_high 
d0cc			    NEXTW 
d0cc			 
d0cc			 
d0cc			.SPIOb: 
d0cc			 
d0cc				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
d0cc			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
d0cc			 
d0cc					if DEBUG_FORTH_WORDS_KEY 
d0cc						DMARK "SPo" 
d0cc						CALLMONITOR 
d0cc					endif 
d0cc					; get port 
d0cc			 
d0cc			 
d0cc					; get byte to send 
d0cc			 
d0cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d0cc			 
d0cc			;		push hl    ; u1  
d0cc			 
d0cc					; destroy value TOS 
d0cc			 
d0cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d0cc			 
d0cc					; one value on hl get other one back 
d0cc			 
d0cc			;		pop hl   ; u2 - addr 
d0cc			 
d0cc					; TODO Send SPI byte 
d0cc			 
d0cc			;		push hl 
d0cc			;		call spi_ce_low 
d0cc			;		pop hl 
d0cc					ld a, l 
d0cc					call spi_send_byte 
d0cc			;		call spi_ce_high 
d0cc			 
d0cc					NEXTW 
d0cc			 
d0cc			.SPII: 
d0cc				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
d0cc			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
d0cc					if DEBUG_FORTH_WORDS_KEY 
d0cc						DMARK "SPi" 
d0cc						CALLMONITOR 
d0cc					endif 
d0cc			 
d0cc					; TODO Get SPI byte 
d0cc			 
d0cc					call spi_read_byte 
d0cc			 
d0cc					if DEBUG_FORTH_WORDS 
d0cc						DMARK "Si2" 
d0cc						CALLMONITOR 
d0cc					endif 
d0cc					ld h, 0 
d0cc					ld l, a 
d0cc					if DEBUG_FORTH_WORDS 
d0cc						DMARK "Si3" 
d0cc						CALLMONITOR 
d0cc					endif 
d0cc					call forth_push_numhl 
d0cc			 
d0cc					NEXTW 
d0cc			 
d0cc			 
d0cc			 
d0cc			.SESEL: 
d0cc				CWHEAD .SESELS 82 "BANK?" 5 WORD_FLAG_CODE 
d0cc			; | BANK? ( -- u ) Reports on the serial EEPROM Bank Device at bank address u1 1-5.  | DONE 
d0cc			; | | Zero is disabled storage. 
d0cc					if DEBUG_FORTH_WORDS_KEY 
d0cc						DMARK "BN?" 
d0cc						CALLMONITOR 
d0cc					endif 
d0cc					ld a, (spi_device_id) 
d0cc					sub '0' 
d0cc					ld h, 0 
d0cc					ld l, a 
d0cc					call forth_push_numhl 
d0cc					NEXTW 
d0cc			.SESELS: 
d0cc				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
d0cc			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV).  | DONE 
d0cc			; | | Set to zero to disable storage. 
d0cc					if DEBUG_FORTH_WORDS_KEY 
d0cc						DMARK "BNK" 
d0cc						CALLMONITOR 
d0cc					endif 
d0cc			 
d0cc					ld a, 255 
d0cc					ld (spi_cartdev), a 
d0cc			 
d0cc					; get bank 
d0cc			 
d0cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d0cc			 
d0cc			;		push hl 
d0cc			 
d0cc					; destroy value TOS 
d0cc			 
d0cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d0cc			 
d0cc					; one value on hl get other one back 
d0cc			 
d0cc			;		pop hl 
d0cc			 
d0cc			 
d0cc					ld c, SPI_CE_HIGH 
d0cc					ld b, '0'    ; human readable bank number 
d0cc			 
d0cc					ld a, l 
d0cc			 
d0cc					if DEBUG_FORTH_WORDS 
d0cc						DMARK "BNK" 
d0cc						CALLMONITOR 
d0cc					endif 
d0cc			 
d0cc					; active low 
d0cc			 
d0cc			;		cp 0 
d0cc					or a 
d0cc					jr z, .bset 
d0cc					cp 1 
d0cc					jr nz, .b2 
d0cc					res 0, c 
d0cc					ld b, '1'    ; human readable bank number 
d0cc			.b2:		cp 2 
d0cc					jr nz, .b3 
d0cc					res 1, c 
d0cc					ld b, '2'    ; human readable bank number 
d0cc			.b3:		cp 3 
d0cc					jr nz, .b4 
d0cc					res 2, c 
d0cc					ld b, '3'    ; human readable bank number 
d0cc			.b4:		cp 4 
d0cc					jr nz, .b5 
d0cc					res 3, c 
d0cc					ld b, '4'    ; human readable bank number 
d0cc			.b5:		cp 5 
d0cc					jr nz, .bset 
d0cc					res 4, c 
d0cc					ld b, '5'    ; human readable bank number 
d0cc			 
d0cc			.bset: 
d0cc					ld a, c 
d0cc					ld (spi_device),a 
d0cc					ld a, b 
d0cc					ld (spi_device_id),a 
d0cc					if DEBUG_FORTH_WORDS 
d0cc						DMARK "BN2" 
d0cc						CALLMONITOR 
d0cc					endif 
d0cc			 
d0cc					; set default SPI clk pulse time as disabled for BANK use 
d0cc			 
d0cc					ld a, 0 
d0cc					ld (spi_clktime), a 
d0cc			 
d0cc					NEXTW 
d0cc			 
d0cc			.CARTDEV: 
d0cc				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
d0cc			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). | DONE 
d0cc			; | | Set to zero to disable devices. 
d0cc					if DEBUG_FORTH_WORDS_KEY 
d0cc						DMARK "CDV" 
d0cc						CALLMONITOR 
d0cc					endif 
d0cc			 
d0cc					; disable se storage bank selection 
d0cc			 
d0cc					ld a, SPI_CE_HIGH		; ce high 
d0cc					ld (spi_device), a 
d0cc			 
d0cc					; get bank 
d0cc			 
d0cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d0cc			 
d0cc			;		push hl 
d0cc			 
d0cc					; destroy value TOS 
d0cc			 
d0cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d0cc			 
d0cc					; one value on hl get other one back 
d0cc			 
d0cc			;		pop hl 
d0cc			 
d0cc					; active low 
d0cc			 
d0cc					ld c, 255 
d0cc			 
d0cc					ld a, l 
d0cc					if DEBUG_FORTH_WORDS 
d0cc						DMARK "CDV" 
d0cc						CALLMONITOR 
d0cc					endif 
d0cc			;		cp 0 
d0cc					or a 
d0cc					jr z, .cset 
d0cc					cp 1 
d0cc					jr nz, .c2 
d0cc					res 0, c 
d0cc			.c2:		cp 2 
d0cc					jr nz, .c3 
d0cc					res 1, c 
d0cc			.c3:		cp 3 
d0cc					jr nz, .c4 
d0cc					res 2, c 
d0cc			.c4:		cp 4 
d0cc					jr nz, .c5 
d0cc					res 3, c 
d0cc			.c5:		cp 5 
d0cc					jr nz, .c6 
d0cc					res 4, c 
d0cc			.c6:		cp 6 
d0cc					jr nz, .c7 
d0cc					res 5, c 
d0cc			.c7:		cp 7 
d0cc					jr nz, .c8 
d0cc					res 6, c 
d0cc			.c8:		cp 8 
d0cc					jr nz, .cset 
d0cc					res 7, c 
d0cc			.cset:		ld a, c 
d0cc					ld (spi_cartdev),a 
d0cc			 
d0cc					if DEBUG_FORTH_WORDS 
d0cc						DMARK "CD2" 
d0cc						CALLMONITOR 
d0cc					endif 
d0cc			 
d0cc					; set default SPI clk pulse time as 10ms for CARTDEV use 
d0cc			 
d0cc					ld a, $0a 
d0cc					ld (spi_clktime), a 
d0cc					NEXTW 
d0cc			endif 
d0cc			 
d0cc			.ENDDEVICE: 
d0cc			; eof 
d0cc			 
# End of file forth_words_device.asm
d0cc			 
d0cc			; var handler 
d0cc			 
d0cc			 
d0cc			.VARS: 
d0cc				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
d0cc 77				db WORD_SYS_CORE+99             
d0cd 80 d1			dw .V0            
d0cf 04				db 3 + 1 
d0d0 .. 00			db "VAR",0              
d0d4				endm 
# End of macro CWHEAD
d0d4			; | VAR ( u1 -- )  Get the address of the (word) variable referenced on TOS  | DONE 
d0d4			; | 
d0d4			; | | The variable name should consist of a single letter (a-z). e.g. "a" 
d0d4			; | |  
d0d4			; | | e.g. 
d0d4			; | |         #30 a var ! 
d0d4			; | |         a var @ . 
d0d4			; | |   
d0d4			; | |     Displays the number 30 
d0d4			; | | 
d0d4			; | | Each variable pointer is a word so can use for any words that use that:  
d0d4			; | |  
d0d4			; | | e.g. 
d0d4			; | |  
d0d4			; | |         #30 a var 2! 
d0d4			; | |         a var 2@ . 
d0d4			; | |   
d0d4			; | |     Displays the number 30 
d0d4			; | |  
d0d4			; | | > [!NOTE]  
d0d4			; ! | > If a full string is passed then only the first char is looked at 
d0d4			; | | > Any other char could exceed bounds checks!  
d0d4			; | | > 
d0d4			; | | > Each variable location follows the previous. Watch you don't clobber any others. 
d0d4			 
d0d4					if DEBUG_FORTH_WORDS_KEY 
d0d4						DMARK "VAR" 
d0d4 f5				push af  
d0d5 3a e9 d0			ld a, (.dmark)  
d0d8 32 62 ee			ld (debug_mark),a  
d0db 3a ea d0			ld a, (.dmark+1)  
d0de 32 63 ee			ld (debug_mark+1),a  
d0e1 3a eb d0			ld a, (.dmark+2)  
d0e4 32 64 ee			ld (debug_mark+2),a  
d0e7 18 03			jr .pastdmark  
d0e9 ..			.dmark: db "VAR"  
d0ec f1			.pastdmark: pop af  
d0ed			endm  
# End of macro DMARK
d0ed						CALLMONITOR 
d0ed cd 6f ee			call debug_vector  
d0f0				endm  
# End of macro CALLMONITOR
d0f0					endif 
d0f0			 
d0f0					FORTH_DSP_VALUEHL 
d0f0 cd c3 9b			call macro_dsp_valuehl 
d0f3				endm 
# End of macro FORTH_DSP_VALUEHL
d0f3			 
d0f3 7e					ld a, (hl)    ; get first char on of the string 
d0f4			 
d0f4			 
d0f4					if DEBUG_FORTH_WORDS 
d0f4						DMARK "VR1" 
d0f4 f5				push af  
d0f5 3a 09 d1			ld a, (.dmark)  
d0f8 32 62 ee			ld (debug_mark),a  
d0fb 3a 0a d1			ld a, (.dmark+1)  
d0fe 32 63 ee			ld (debug_mark+1),a  
d101 3a 0b d1			ld a, (.dmark+2)  
d104 32 64 ee			ld (debug_mark+2),a  
d107 18 03			jr .pastdmark  
d109 ..			.dmark: db "VR1"  
d10c f1			.pastdmark: pop af  
d10d			endm  
# End of macro DMARK
d10d						CALLMONITOR 
d10d cd 6f ee			call debug_vector  
d110				endm  
# End of macro CALLMONITOR
d110					endif 
d110					 
d110 f5					push af	 
d111					FORTH_DSP_POP 
d111 cd 7b 9c			call macro_forth_dsp_pop 
d114				endm 
# End of macro FORTH_DSP_POP
d114 f1					pop af 
d115			 
d115					; convert to upper 
d115			 
d115 cd 3e 8f				call to_upper 
d118					if DEBUG_FORTH_WORDS 
d118						DMARK "Vaa" 
d118 f5				push af  
d119 3a 2d d1			ld a, (.dmark)  
d11c 32 62 ee			ld (debug_mark),a  
d11f 3a 2e d1			ld a, (.dmark+1)  
d122 32 63 ee			ld (debug_mark+1),a  
d125 3a 2f d1			ld a, (.dmark+2)  
d128 32 64 ee			ld (debug_mark+2),a  
d12b 18 03			jr .pastdmark  
d12d ..			.dmark: db "Vaa"  
d130 f1			.pastdmark: pop af  
d131			endm  
# End of macro DMARK
d131						CALLMONITOR 
d131 cd 6f ee			call debug_vector  
d134				endm  
# End of macro CALLMONITOR
d134					endif 
d134 06 41				ld b, 'A' 
d136 90					sub b			; set offset 
d137					if DEBUG_FORTH_WORDS 
d137						DMARK "Vbb" 
d137 f5				push af  
d138 3a 4c d1			ld a, (.dmark)  
d13b 32 62 ee			ld (debug_mark),a  
d13e 3a 4d d1			ld a, (.dmark+1)  
d141 32 63 ee			ld (debug_mark+1),a  
d144 3a 4e d1			ld a, (.dmark+2)  
d147 32 64 ee			ld (debug_mark+2),a  
d14a 18 03			jr .pastdmark  
d14c ..			.dmark: db "Vbb"  
d14f f1			.pastdmark: pop af  
d150			endm  
# End of macro DMARK
d150						CALLMONITOR 
d150 cd 6f ee			call debug_vector  
d153				endm  
# End of macro CALLMONITOR
d153					endif 
d153 cb 27				sla a  
d155				 
d155					 
d155					if DEBUG_FORTH_WORDS 
d155						DMARK "VR2" 
d155 f5				push af  
d156 3a 6a d1			ld a, (.dmark)  
d159 32 62 ee			ld (debug_mark),a  
d15c 3a 6b d1			ld a, (.dmark+1)  
d15f 32 63 ee			ld (debug_mark+1),a  
d162 3a 6c d1			ld a, (.dmark+2)  
d165 32 64 ee			ld (debug_mark+2),a  
d168 18 03			jr .pastdmark  
d16a ..			.dmark: db "VR2"  
d16d f1			.pastdmark: pop af  
d16e			endm  
# End of macro DMARK
d16e						CALLMONITOR 
d16e cd 6f ee			call debug_vector  
d171				endm  
# End of macro CALLMONITOR
d171					endif 
d171			 
d171 21 eb e9				ld hl, cli_var_array2 
d174 cd d6 8c				call addatohl 
d177 cd c7 99				call forth_push_numhl 
d17a			 
d17a			 
d17a				       NEXTW 
d17a cd 6c ee			call parse_vector 
d17d c3 aa 9d			jp macro_next 
d180				endm 
# End of macro NEXTW
d180			.V0: 
d180				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
d180 78				db WORD_SYS_CORE+100             
d181 9b d1			dw .V0Q            
d183 04				db 3 + 1 
d184 .. 00			db "V0!",0              
d188				endm 
# End of macro CWHEAD
d188			;| V0! ( u1 -- )  Store value to v0  | DONE 
d188			 
d188					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d188 cd c3 9b			call macro_dsp_valuehl 
d18b				endm 
# End of macro FORTH_DSP_VALUEHL
d18b			 
d18b 11 1f ea				ld de, cli_var_array 
d18e			 
d18e eb					ex de, hl 
d18f 73					ld (hl), e 
d190 23					inc hl 
d191 72					ld (hl), d 
d192			 
d192					; destroy value TOS 
d192			 
d192					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d192 cd 7b 9c			call macro_forth_dsp_pop 
d195				endm 
# End of macro FORTH_DSP_POP
d195			 
d195				       NEXTW 
d195 cd 6c ee			call parse_vector 
d198 c3 aa 9d			jp macro_next 
d19b				endm 
# End of macro NEXTW
d19b			.V0Q: 
d19b				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
d19b 79				db WORD_SYS_CORE+101             
d19c af d1			dw .V1S            
d19e 04				db 3 + 1 
d19f .. 00			db "V0@",0              
d1a3				endm 
# End of macro CWHEAD
d1a3			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
d1a3 2a 1f ea				ld hl, (cli_var_array) 
d1a6 cd c7 99				call forth_push_numhl 
d1a9			 
d1a9				       NEXTW 
d1a9 cd 6c ee			call parse_vector 
d1ac c3 aa 9d			jp macro_next 
d1af				endm 
# End of macro NEXTW
d1af			.V1S: 
d1af				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
d1af 7a				db WORD_SYS_CORE+102             
d1b0 ca d1			dw .V1Q            
d1b2 04				db 3 + 1 
d1b3 .. 00			db "V1!",0              
d1b7				endm 
# End of macro CWHEAD
d1b7			;| V1! ( u1 -- )  Store value to v1 | DONE 
d1b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d1b7 cd c3 9b			call macro_dsp_valuehl 
d1ba				endm 
# End of macro FORTH_DSP_VALUEHL
d1ba			 
d1ba 11 21 ea				ld de, cli_var_array+2 
d1bd				 
d1bd eb					ex de, hl 
d1be 73					ld (hl), e 
d1bf 23					inc hl 
d1c0 72					ld (hl), d 
d1c1			 
d1c1					; destroy value TOS 
d1c1			 
d1c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d1c1 cd 7b 9c			call macro_forth_dsp_pop 
d1c4				endm 
# End of macro FORTH_DSP_POP
d1c4				       NEXTW 
d1c4 cd 6c ee			call parse_vector 
d1c7 c3 aa 9d			jp macro_next 
d1ca				endm 
# End of macro NEXTW
d1ca			.V1Q: 
d1ca				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
d1ca 7b				db WORD_SYS_CORE+103             
d1cb de d1			dw .V2S            
d1cd 04				db 3 + 1 
d1ce .. 00			db "V1@",0              
d1d2				endm 
# End of macro CWHEAD
d1d2			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
d1d2 2a 21 ea				ld hl, (cli_var_array+2) 
d1d5 cd c7 99				call forth_push_numhl 
d1d8				       NEXTW 
d1d8 cd 6c ee			call parse_vector 
d1db c3 aa 9d			jp macro_next 
d1de				endm 
# End of macro NEXTW
d1de			.V2S: 
d1de				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
d1de 7c				db WORD_SYS_CORE+104             
d1df f9 d1			dw .V2Q            
d1e1 04				db 3 + 1 
d1e2 .. 00			db "V2!",0              
d1e6				endm 
# End of macro CWHEAD
d1e6			;| V2! ( u1 -- )  Store value to v2 | DONE 
d1e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d1e6 cd c3 9b			call macro_dsp_valuehl 
d1e9				endm 
# End of macro FORTH_DSP_VALUEHL
d1e9			 
d1e9 11 23 ea				ld de, cli_var_array+4 
d1ec				 
d1ec eb					ex de, hl 
d1ed 73					ld (hl), e 
d1ee 23					inc hl 
d1ef 72					ld (hl), d 
d1f0			 
d1f0					; destroy value TOS 
d1f0			 
d1f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d1f0 cd 7b 9c			call macro_forth_dsp_pop 
d1f3				endm 
# End of macro FORTH_DSP_POP
d1f3				       NEXTW 
d1f3 cd 6c ee			call parse_vector 
d1f6 c3 aa 9d			jp macro_next 
d1f9				endm 
# End of macro NEXTW
d1f9			.V2Q: 
d1f9				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
d1f9 7d				db WORD_SYS_CORE+105             
d1fa 0d d2			dw .V3S            
d1fc 04				db 3 + 1 
d1fd .. 00			db "V2@",0              
d201				endm 
# End of macro CWHEAD
d201			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
d201 2a 23 ea				ld hl, (cli_var_array+4) 
d204 cd c7 99				call forth_push_numhl 
d207				       NEXTW 
d207 cd 6c ee			call parse_vector 
d20a c3 aa 9d			jp macro_next 
d20d				endm 
# End of macro NEXTW
d20d			.V3S: 
d20d				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
d20d 7c				db WORD_SYS_CORE+104             
d20e 28 d2			dw .V3Q            
d210 04				db 3 + 1 
d211 .. 00			db "V3!",0              
d215				endm 
# End of macro CWHEAD
d215			;| V3! ( u1 -- )  Store value to v3 | DONE 
d215					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d215 cd c3 9b			call macro_dsp_valuehl 
d218				endm 
# End of macro FORTH_DSP_VALUEHL
d218			 
d218 11 25 ea				ld de, cli_var_array+6 
d21b				 
d21b eb					ex de, hl 
d21c 73					ld (hl), e 
d21d 23					inc hl 
d21e 72					ld (hl), d 
d21f			 
d21f					; destroy value TOS 
d21f			 
d21f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d21f cd 7b 9c			call macro_forth_dsp_pop 
d222				endm 
# End of macro FORTH_DSP_POP
d222				       NEXTW 
d222 cd 6c ee			call parse_vector 
d225 c3 aa 9d			jp macro_next 
d228				endm 
# End of macro NEXTW
d228			.V3Q: 
d228				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
d228 7d				db WORD_SYS_CORE+105             
d229 3c d2			dw .END            
d22b 04				db 3 + 1 
d22c .. 00			db "V3@",0              
d230				endm 
# End of macro CWHEAD
d230			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
d230 2a 25 ea				ld hl, (cli_var_array+6) 
d233 cd c7 99				call forth_push_numhl 
d236				       NEXTW 
d236 cd 6c ee			call parse_vector 
d239 c3 aa 9d			jp macro_next 
d23c				endm 
# End of macro NEXTW
d23c			 
d23c			 
d23c			 
d23c			 
d23c			 
d23c			; end of dict marker 
d23c			 
d23c 00			.END:    db WORD_SYS_END 
d23d 00 00			dw 0 
d23f 00				db 0 
d240			 
d240			; use to jp here for user dict words to save on macro expansion  
d240			 
d240			user_dict_next: 
d240				NEXTW 
d240 cd 6c ee			call parse_vector 
d243 c3 aa 9d			jp macro_next 
d246				endm 
# End of macro NEXTW
d246			 
d246			 
d246			user_exec: 
d246				;    ld hl, <word code> 
d246				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
d246				;    call forthexec 
d246				;    jp user_dict_next   (NEXT) 
d246			        ;    <word code bytes> 
d246 eb				ex de, hl 
d247 2a b9 e5			ld hl,(os_tok_ptr) 
d24a				 
d24a				FORTH_RSP_NEXT 
d24a cd 6e 99			call macro_forth_rsp_next 
d24d				endm 
# End of macro FORTH_RSP_NEXT
d24d			 
d24d			if DEBUG_FORTH_UWORD 
d24d						DMARK "UEX" 
d24d f5				push af  
d24e 3a 62 d2			ld a, (.dmark)  
d251 32 62 ee			ld (debug_mark),a  
d254 3a 63 d2			ld a, (.dmark+1)  
d257 32 63 ee			ld (debug_mark+1),a  
d25a 3a 64 d2			ld a, (.dmark+2)  
d25d 32 64 ee			ld (debug_mark+2),a  
d260 18 03			jr .pastdmark  
d262 ..			.dmark: db "UEX"  
d265 f1			.pastdmark: pop af  
d266			endm  
# End of macro DMARK
d266				CALLMONITOR 
d266 cd 6f ee			call debug_vector  
d269				endm  
# End of macro CALLMONITOR
d269			endif 
d269			 
d269			 
d269			 
d269 eb				ex de, hl 
d26a 22 b9 e5			ld (os_tok_ptr), hl 
d26d				 
d26d				; Don't use next - Skips the first word in uword. 
d26d			 
d26d c3 2b 9e			jp exec1 
d270			;	NEXT 
d270			 
d270			 
d270			; eof 
# End of file forth_wordsv4.asm
d270			endif 
d270			;;;;;;;;;;;;;; Debug code 
d270			 
d270			 
d270			;if DEBUG_FORTH_PARSE 
d270 .. 00		.nowordfound: db "No match",0 
d279 .. 00		.compword:	db "Comparing word ",0 
d289 .. 00		.nextwordat:	db "Next word at",0 
d296 .. 00		.charmatch:	db "Char match",0 
d2a1			;endif 
d2a1			if DEBUG_FORTH_JP 
d2a1			.foundword:	db "Word match. Exec..",0 
d2a1			endif 
d2a1			;if DEBUG_FORTH_PUSH 
d2a1 .. 00		.enddict:	db "Dict end. Push.",0 
d2b1 .. 00		.push_str:	db "Pushing string",0 
d2c0 .. 00		.push_num:	db "Pushing number",0 
d2cf .. 00		.data_sp:	db "SP:",0 
d2d3 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
d2e5 .. 00		.wordinde:	db "Word in DE (3/0):",0 
d2f7 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
d309			;endif 
d309			;if DEBUG_FORTH_MALLOC 
d309 .. 00		.push_malloc:	db "Malloc address",0 
d318			;endif 
d318			 
d318			 
d318			 
d318			; display malloc address and current data stack pointer  
d318			 
d318			malloc_error: 
d318 d5				push de 
d319 f5				push af 
d31a e5				push hl 
d31b cd ac 8a			call clear_display 
d31e 11 3e d3			ld de, .mallocerr 
d321 3e 00			ld a,0 
d323			;	ld de,os_word_scratch 
d323 cd be 8a			call str_at_display 
d326 3e 11			ld a, display_row_1+17 
d328 11 62 ee			ld de, debug_mark 
d32b cd be 8a			call str_at_display 
d32e cd ce 8a			call update_display 
d331				;call break_point_state 
d331 cd 51 e4			call cin_wait 
d334			 
d334			;	ld a, ' ' 
d334			;	ld (os_view_disable), a 
d334 cd 46 93			call bp_on 
d337 e1				pop hl 
d338 f1				pop af 
d339 d1				pop de	 
d33a				CALLMONITOR 
d33a cd 6f ee			call debug_vector  
d33d				endm  
# End of macro CALLMONITOR
d33d c9				ret 
d33e			 
d33e .. 00		.mallocerr: 	db "Malloc Error",0 
d34b			;if DEBUG_FORTH_PUSH 
d34b			display_data_sp: 
d34b f5				push af 
d34c			 
d34c				; see if disabled 
d34c			 
d34c			 
d34c 3a 6f ee			ld a, (debug_vector) 
d34f fe c9			cp $C9  ; RET 
d351				;ld a, (os_view_disable) 
d351				;cp '*' 
d351 28 65			jr z, .skipdsp 
d353			 
d353 e5				push hl 
d354 e5				push hl 
d355 e5			push hl 
d356 cd ac 8a			call clear_display 
d359 e1			pop hl 
d35a 7c				ld a,h 
d35b 21 bd e5			ld hl, os_word_scratch 
d35e cd d2 8e			call hexout 
d361 e1				pop hl 
d362 7d				ld a,l 
d363 21 bf e5			ld hl, os_word_scratch+2 
d366 cd d2 8e			call hexout 
d369 21 c1 e5			ld hl, os_word_scratch+4 
d36c			;	ld a,0 
d36c 36 00			ld (hl),0 
d36e 11 bd e5			ld de,os_word_scratch 
d371 3e 28				ld a, display_row_2 
d373 cd be 8a				call str_at_display 
d376 11 d3 d2			ld de, .wordinhl 
d379 3e 00			ld a, display_row_1 
d37b			 
d37b cd be 8a				call str_at_display 
d37e 11 62 ee			ld de, debug_mark 
d381 3e 11			ld a, display_row_1+17 
d383			 
d383 cd be 8a				call str_at_display 
d386			 
d386				; display current data stack pointer 
d386 11 cf d2			ld de,.data_sp 
d389 3e 30				ld a, display_row_2 + 8 
d38b cd be 8a				call str_at_display 
d38e			 
d38e 2a e5 e9			ld hl,(cli_data_sp) 
d391 e5				push hl 
d392 7c				ld a,h 
d393 21 bd e5			ld hl, os_word_scratch 
d396 cd d2 8e			call hexout 
d399 e1				pop hl 
d39a 7d				ld a,l 
d39b 21 bf e5			ld hl, os_word_scratch+2 
d39e cd d2 8e			call hexout 
d3a1 21 c1 e5			ld hl, os_word_scratch+4 
d3a4			;	ld a,0 
d3a4 36 00			ld (hl),0 
d3a6 11 bd e5			ld de,os_word_scratch 
d3a9 3e 33				ld a, display_row_2 + 11 
d3ab cd be 8a				call str_at_display 
d3ae			 
d3ae			 
d3ae cd ce 8a			call update_display 
d3b1 cd f0 89			call delay1s 
d3b4 cd f0 89			call delay1s 
d3b7 e1				pop hl 
d3b8			.skipdsp: 
d3b8 f1				pop af 
d3b9 c9				ret 
d3ba			 
d3ba			display_data_malloc: 
d3ba			 
d3ba f5				push af 
d3bb e5				push hl 
d3bc e5				push hl 
d3bd e5			push hl 
d3be cd ac 8a			call clear_display 
d3c1 e1			pop hl 
d3c2 7c				ld a,h 
d3c3 21 bd e5			ld hl, os_word_scratch 
d3c6 cd d2 8e			call hexout 
d3c9 e1				pop hl 
d3ca 7d				ld a,l 
d3cb 21 bf e5			ld hl, os_word_scratch+2 
d3ce cd d2 8e			call hexout 
d3d1 21 c1 e5			ld hl, os_word_scratch+4 
d3d4			;	ld a,0 
d3d4 36 00			ld (hl),0 
d3d6 11 bd e5			ld de,os_word_scratch 
d3d9 3e 28				ld a, display_row_2 
d3db cd be 8a				call str_at_display 
d3de 11 09 d3			ld de, .push_malloc 
d3e1 3e 00			ld a, display_row_1 
d3e3			 
d3e3 cd be 8a				call str_at_display 
d3e6			 
d3e6				; display current data stack pointer 
d3e6 11 cf d2			ld de,.data_sp 
d3e9 3e 30				ld a, display_row_2 + 8 
d3eb cd be 8a				call str_at_display 
d3ee			 
d3ee 2a e5 e9			ld hl,(cli_data_sp) 
d3f1 e5				push hl 
d3f2 7c				ld a,h 
d3f3 21 bd e5			ld hl, os_word_scratch 
d3f6 cd d2 8e			call hexout 
d3f9 e1				pop hl 
d3fa 7d				ld a,l 
d3fb 21 bf e5			ld hl, os_word_scratch+2 
d3fe cd d2 8e			call hexout 
d401 21 c1 e5			ld hl, os_word_scratch+4 
d404			;	ld a,0 
d404 36 00			ld (hl),0 
d406 11 bd e5			ld de,os_word_scratch 
d409 3e 33				ld a, display_row_2 + 11 
d40b cd be 8a				call str_at_display 
d40e			 
d40e cd ce 8a			call update_display 
d411 cd f0 89			call delay1s 
d414 cd f0 89			call delay1s 
d417 e1				pop hl 
d418 f1				pop af 
d419 c9				ret 
d41a			;endif 
d41a			 
d41a			include "forth_autostart.asm" 
d41a			; list of commands to perform at system start up 
d41a			 
d41a			startcmds: 
d41a			;	dw test11 
d41a			;	dw test12 
d41a			;	dw test13 
d41a			;	dw test14 
d41a			;	dw test15 
d41a			;	dw test16 
d41a			;	dw test17 
d41a			;	dw ifthtest1 
d41a			;	dw ifthtest2 
d41a			;	dw ifthtest3 
d41a			;	dw mmtest1 
d41a			;	dw mmtest2 
d41a			;	dw mmtest3 
d41a			;	dw mmtest4 
d41a			;	dw mmtest5 
d41a			;	dw mmtest6 
d41a			;	dw iftest1 
d41a			;	dw iftest2 
d41a			;	dw iftest3 
d41a			;	dw looptest1 
d41a			;	dw looptest2 
d41a			;	dw test1 
d41a			;	dw test2 
d41a			;	dw test3 
d41a			;	dw test4 
d41a			;	dw game2r 
d41a			;	dw game2b1 
d41a			;	dw game2b2 
d41a			 
d41a				; start up words that are actually useful 
d41a			 
d41a			;    dw spi1 
d41a			;    dw spi2 
d41a			;    dw spi3 
d41a			;    dw spi4 
d41a			;    dw spi5 
d41a			;    dw spi6 
d41a			;    dw spi7 
d41a			; 
d41a			;    dw spi8 
d41a			;    dw spi9 
d41a			;    dw spi10 
d41a			 
d41a			; file editor 
d41a			;	dw edit1 
d41a			;	dw edit2 
d41a			;	dw edit3 
d41a			 
d41a			;	dw longread 
d41a 3c d8			dw clrstack 
d41c 70 d8			dw type 
d41e			;	dw stest 
d41e 95 d8			dw strncpy 
d420 05 da			dw list 
d422 f6 d8			dw start1 
d424 06 d9			dw start2 
d426			;	dw start3 
d426			;	dw start3b 
d426			;	dw start3c 
d426			 
d426				; (unit) testing words 
d426			 
d426			;	dw mtesta 
d426			;	dw mtestb 
d426			;	dw mtestc 
d426			;	dw mtestd 
d426			;	dw mteste 
d426			 
d426				; demo/game words 
d426			 
d426			;        dw game3w 
d426			;        dw game3p 
d426			;        dw game3sc 
d426			;        dw game3vsi 
d426			;        dw game3vs 
d426				 
d426			;	dw game2b 
d426			;	dw game2bf 
d426			;	dw game2mba 
d426			;	dw game2mbas 
d426			;	dw game2mb 
d426			 
d426 36 dc			dw game1 
d428 47 dc			dw game1a 
d42a a9 dc			dw game1b 
d42c de dc			dw game1c 
d42e 14 dd			dw game1d 
d430 45 dd			dw game1s 
d432 59 dd			dw game1t 
d434 6e dd			dw game1f 
d436 a2 dd			dw game1z 
d438 e6 dd			dw game1zz 
d43a			 
d43a 6f da			dw test5 
d43c a7 da			dw test6 
d43e df da			dw test7 
d440 f3 da			dw test8 
d442 1f db			dw test9 
d444 35 db			dw test10 
d446				 
d446 bd de		        dw ssv5 
d448 a1 de		        dw ssv4 
d44a 85 de		        dw ssv3 
d44c 4f de		        dw ssv2 
d44e d6 de		        dw ssv1 
d450 1e df		        dw ssv1cpm 
d452			;	dw keyup 
d452			;	dw keydown 
d452			;	dw keyleft 
d452			;	dw keyright 
d452			;	dw 	keyf1 
d452			;	dw keyf2 
d452			;	dw keyf3 
d452			;	dw keyf4 
d452			;	dw keyf5 
d452			;	dw keyf6 
d452			;	dw keyf7 
d452			;	dw keyf8 
d452			;	dw keyf9 
d452			;	dw keyf10 
d452			;	dw keyf11 
d452			;	dw keyf12 
d452			;	dw keytab 
d452			;	dw keycr 
d452			;	dw keyhome 
d452			;	dw keyend 
d452			;	dw keybs 
d452 00 00			db 0, 0	 
d454			 
d454			 
d454			; File Editor 
d454			 
d454			; ( id - ) use 'e' to edit the displayed line 
d454 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
d475 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
d4aa			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
d4aa .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
d4e2			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
d4e2			 
d4e2			; SPI Net support words 
d4e2			 
d4e2			; v0! = node to send to 
d4e2			; ( str count - ) 
d4e2 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
d53b			 
d53b			; spiputc ( char node - ) 
d53b .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
d56f			; spiputc ( u node - ) 
d56f .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
d59d			 
d59d			; spigetc ( - n ) 
d59d .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
d5c6			 
d5c6			; getnode ( - n ) 
d5c6 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
d5f3			 
d5f3			; ( str node - )  
d5f3 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
d659			; store string ( str i - ) 
d659			 
d659			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
d659 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
d6ae			 
d6ae			; get string ( addr i -  )    TO FIX 
d6ae			 
d6ae .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d706			 
d706			 
d706			; NETCHAT (TODO) 
d706			; Program to allow two nodes to chat with eachother 
d706			; 
d706			; v0 - target node 
d706			;  
d706			; accept input at 0,0 
d706			; if input is string send spitype to target node 
d706			; starting at row 2,0 , while spigetchr is not zero ->  
d706			; 
d706			; 
d706			; TODO add paging of get request 
d706			 
d706			; ( node - ) 
d706 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d725 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d77d .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d7f5			 
d7f5			 
d7f5			; Long read of currently open file 
d7f5 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d83c			 
d83c			; clear stack  
d83c			 
d83c .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d870			 
d870			; type ( addr count - ) 
d870 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d895			 
d895			; some direct memory words 
d895			; strncpy ( len t f -- t ) 
d895			 
d895 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d8f6			 
d8f6 .. 00		start1:     	db ": bpon $00 bp ;",0 
d906 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d917 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d992 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d9f2			 
d9f2 .. 00		tuck:         db ": tuck swap over ;", 0 
da05			 
da05			; a handy word to list items on the stack 
da05			 
da05 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
da6f			 
da6f			 
da6f			; test stack  
da6f			; rnd8 stest 
da6f			 
da6f			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
da6f			 
da6f			; random malloc and free cycles 
da6f			 
da6f			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
da6f			 
da6f			; fixed malloc and free cycles 
da6f			 
da6f			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
da6f			 
da6f			; fixed double string push and drop cycle  
da6f			 
da6f			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
da6f			 
da6f			; consistent fixed string push and drop cycle  
da6f			 
da6f			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
da6f			 
da6f			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
da6f			 
da6f			;test1:		db ": aa 1 2 3 ;", 0 
da6f			;test2:     	db "111 aa 888 999",0 
da6f			;test3:     	db ": bb 77 ;",0 
da6f			;test4:     	db "$02 $01 do i . loop bb",0 
da6f			 
da6f .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
daa7 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
dadf .. 00		test7:     	db ": box hline vline ;",0 
daf3 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
db1f .. 00		test9:     	db ": sw $01 adsp world ;",0 
db35 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
db5a			;test11:     	db "hello create .",0 
db5a			;test12:     	db "hello2 create .",0 
db5a			 
db5a			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
db5a			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
db5a			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
db5a			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
db5a			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
db5a			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
db5a			 
db5a			;iftest1:     	db "$0001 IF cls .",0 
db5a			;iftest2:     	db "$0000 IF cls .",0 
db5a			;iftest3:     	db "$0002 $0003 - IF cls .",0 
db5a			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
db5a			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
db5a			 
db5a			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
db5a			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
db5a			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
db5a			 
db5a			 
db5a .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
db7e .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
dbae .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
dbd3 .. 00		sound4: db ": cha $00 ; ",0 
dbe0 .. 00		sound5: db ": chb $20 ; ",0 
dbed .. 00		sound6: db ": chc $40 ; ",0 
dbfa .. 00		sound7: db ": chd $60 ; ",0 
dc07 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
dc1f .. 00		sound9: db ": cvol $90 + + note ; ", 0 
dc36			 
dc36			 
dc36			 
dc36			 
dc36			; a small guess the number game 
dc36			 
dc36 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
dc47 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
dca9			 
dca9 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
dcde .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
dd14 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
dd45 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
dd59 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
dd6e .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
dda2 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
dde6			 
dde6			; Using 'ga' save a high score across multiple runs using external storage 
dde6			 
dde6 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
de4f			 
de4f			 
de4f			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
de4f			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
de4f			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
de4f			 
de4f			; simple screen saver to test code memory reuse to destruction 
de4f			 
de4f .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
de85 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
dea1 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
debd .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
ded6 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
df1e .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
df75			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
df75			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
df75			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
df75			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
df75			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
df75			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
df75			 
df75			 
df75			 
df75			; minesweeper/battleship finding game 
df75			; draws a game board of random ship/mine positions 
df75			; user enters coords to see if it hits on 
df75			; game ends when all are hit 
df75			; when hit or miss says how many may be in the area 
df75			 
df75			; setup the game board and then hide it 
df75			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
df75			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
df75			;; prompt for where to target 
df75			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
df75			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
df75			;; TODO see if the entered coords hits or misses pushes char hit of miss 
df75			;game2mbht:      db ": mbckht nop ;",0 
df75			;game2mbms:      db ": mbcms nop ;",0 
df75			; TODO how many might be near by 
df75			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
df75			 
df75			; Game 3 
df75			 
df75			; Vert scroller ski game - avoid the trees! 
df75			 
df75			; v0 score (ie turns) 
df75			; v1 player pos 
df75			; v2 left wall 
df75			; v3 right wall 
df75			 
df75			; Draw side walls randomly 
df75			 
df75			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
df75			 
df75			; Draw player 
df75			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
df75			 
df75			; TODO Get Key 
df75			 
df75			; TODO Move left right 
df75			 
df75			; scroll and move walls a bit 
df75			 
df75			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
df75			 
df75			; main game loop 
df75			 
df75			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
df75			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
df75			 
df75			; key board defs 
df75			 
df75 .. 00		keyup:       db ": keyup $05 ;",0 
df83 .. 00		keydown:       db ": keydown $0a ;",0 
df93 .. 00		keyleft:       db ": keyleft $0b ;",0 
dfa3 .. 00		keyright:       db ": keyright $0c ;",0 
dfb4 .. 00		keyf1:       db ": keyf1 $10 ;",0 
dfc2 .. 00		keyf2:       db ": keyf2 $11 ;",0 
dfd0 .. 00		keyf3:       db ": keyf3 $12 ;",0 
dfde .. 00		keyf4:       db ": keyf4 $13 ;",0 
dfec .. 00		keyf5:       db ": keyf5 $14 ;",0 
dffa .. 00		keyf6:       db ": keyf6 $15 ;",0 
e008 .. 00		keyf7:       db ": keyf7 $16 ;",0 
e016 .. 00		keyf8:       db ": keyf8 $17 ;",0 
e024 .. 00		keyf9:       db ": keyf9 $18 ;",0 
e032 .. 00		keyf10:       db ": keyf10 $19 ;",0 
e041 .. 00		keyf11:       db ": keyf11 $1a ;",0 
e050 .. 00		keyf12:       db ": keyf12 $1b ;",0 
e05f			 
e05f .. 00		keytab:       db ": keytab $09 ;",0 
e06e .. 00		keycr:       db ": keycr $0d ;",0 
e07c .. 00		keyhome:       db ": keyhome $0e ;",0 
e08c .. 00		keyend:       db ": keyend $0f ;",0 
e09b .. 00		keybs:       db ": keybs $08 ;",0 
e0a9			 
e0a9			   
e0a9			 
e0a9			 
e0a9			 
e0a9			; eof 
# End of file forth_autostart.asm
e0a9			 
e0a9			 
e0a9			 
e0a9			; stack over and underflow checks 
e0a9			 
e0a9			; init the words to detect the under/overflow 
e0a9			 
e0a9			chk_stk_init: 
e0a9				; a vague random number to check so we dont get any "lucky" hits 
e0a9 3e 2d			ld a, 45 
e0ab 6f				ld l, a 
e0ac 00				nop 
e0ad 3e 17			ld a, 23 
e0af 67				ld h, a 
e0b0			 
e0b0 22 94 e2			ld (chk_word), hl     ; the word we need to check against 
e0b3			 
e0b3			;	ld (chk_stund), hl	; stack points.... 
e0b3 22 00 ef			ld (chk_stovr), hl 
e0b6 22 e3 e9			ld (chk_ret_und), hl 
e0b9 22 a1 e9			ld (chk_ret_ovr), hl 
e0bc 22 1f e9			ld (chk_loop_ovr), hl 
e0bf 22 1d e8			ld (chk_data_ovr), hl 
e0c2 c9				ret 
e0c3				 
e0c3			check_stacks: 
e0c3				; check all stack words 
e0c3			 
e0c3 e5				push hl 
e0c4 d5				push de 
e0c5			 
e0c5			;	ld de,(chk_word) 
e0c5			;	ld hl, (chk_stund)	; stack points.... 
e0c5			;	if DEBUG_STK_FAULT 
e0c5			;		DMARK "FAa" 
e0c5			;		CALLMONITOR 
e0c5			;	endif 
e0c5			;	call cmp16 
e0c5			;	jp z, .chk_faulta 
e0c5			; 
e0c5			;	ld de, sfaultsu 
e0c5			;	jp .chk_fault 
e0c5			 
e0c5 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
e0c8 ed 5b 94 e2		ld de,(chk_word) 
e0cc				if DEBUG_STK_FAULT 
e0cc					DMARK "FAb" 
e0cc					CALLMONITOR 
e0cc				endif 
e0cc cd f4 8c			call cmp16 
e0cf 28 06			jr z, .chk_fault1 
e0d1 11 75 e1			ld de, sfaultso 
e0d4 c3 26 e1			jp .chk_fault 
e0d7			.chk_fault1:  
e0d7 2a e3 e9			ld hl, (chk_ret_und) 
e0da ed 5b 94 e2		ld de,(chk_word) 
e0de				if DEBUG_STK_FAULT 
e0de					DMARK "FAU" 
e0de					CALLMONITOR 
e0de				endif 
e0de cd f4 8c			call cmp16 
e0e1 ca ea e0			jp z, .chk_fault2 
e0e4 11 85 e1			ld de, sfaultru 
e0e7 c3 26 e1			jp .chk_fault 
e0ea			.chk_fault2:  
e0ea 2a a1 e9			ld hl, (chk_ret_ovr) 
e0ed ed 5b 94 e2		ld de,(chk_word) 
e0f1				if DEBUG_STK_FAULT 
e0f1					DMARK "FA1" 
e0f1					CALLMONITOR 
e0f1				endif 
e0f1 cd f4 8c			call cmp16 
e0f4 ca fd e0			jp z, .chk_fault3 
e0f7 11 93 e1			ld de, sfaultro 
e0fa c3 26 e1			jp .chk_fault 
e0fd			.chk_fault3:  
e0fd 2a 1f e9			ld hl, (chk_loop_ovr) 
e100 ed 5b 94 e2		ld de,(chk_word) 
e104				if DEBUG_STK_FAULT 
e104					DMARK "FA2" 
e104					CALLMONITOR 
e104				endif 
e104 cd f4 8c			call cmp16 
e107 ca 10 e1			jp z, .chk_fault4 
e10a 11 ad e1			ld de, sfaultlo 
e10d c3 26 e1			jp .chk_fault 
e110			.chk_fault4:  
e110 2a 1d e8			ld hl, (chk_data_ovr) 
e113 ed 5b 94 e2		ld de,(chk_word) 
e117				if DEBUG_STK_FAULT 
e117					DMARK "FA3" 
e117					CALLMONITOR 
e117				endif 
e117 cd f4 8c			call cmp16 
e11a ca 23 e1			jp z, .chk_fault5 
e11d 11 c7 e1			ld de, sfaultdo 
e120 c3 26 e1			jp .chk_fault 
e123			 
e123			 
e123			.chk_fault5:  
e123 d1				pop de 
e124 e1				pop hl 
e125			 
e125 c9				ret 
e126			 
e126 cd ac 8a		.chk_fault: 	call clear_display 
e129 3e 28				ld a, display_row_2 
e12b cd be 8a				call str_at_display 
e12e 11 57 e1				   ld de, .stackfault 
e131 3e 00				ld a, display_row_1 
e133 cd be 8a				call str_at_display 
e136 11 62 ee				    ld de, debug_mark 
e139 3e 11				ld a, display_row_1+17 
e13b cd be 8a				call str_at_display 
e13e cd ce 8a				call update_display 
e141			 
e141				; prompt before entering montior for investigating issue 
e141			 
e141 3e 78			ld a, display_row_4 
e143 11 a9 96			ld de, endprog 
e146			 
e146 cd ce 8a			call update_display		 
e149			 
e149 cd 3f 99			call next_page_prompt 
e14c			 
e14c d1				pop de 
e14d e1				pop hl 
e14e cd fd 96				call monitor 
e151 cd 50 9d				call forth_warmstart 
e154 c3 fb 95				jp warmstart_afterauto 
e157					;jp 0 
e157					;halt 
e157			 
e157			 
e157			 
e157 .. 00		.stackfault: 	db "Stack fault:",0 
e164			 
e164 .. 00		sfaultsu: 	db	"Stack under flow",0 
e175 .. 00		sfaultso: 	db	"Stack over flow",0 
e185 .. 00		sfaultru:	db "RTS underflow",0 
e193 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e1ad .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e1c7 .. 00		sfaultdo:	db "DTS overflow", 0 
e1d4			 
e1d4			 
e1d4			fault_dsp_under: 
e1d4 11 e6 e1			ld de, .dsp_under 
e1d7 c3 9c e2			jp .show_fault 
e1da			 
e1da			fault_rsp_under: 
e1da 11 f4 e1			ld de, .rsp_under 
e1dd c3 9c e2			jp .show_fault 
e1e0			fault_loop_under: 
e1e0 11 02 e2			ld de, .loop_under 
e1e3 c3 9c e2			jp .show_fault 
e1e6			 
e1e6 .. 00		.dsp_under: db "DSP Underflow",0 
e1f4 .. 00		.rsp_under: db "RSP Underflow",0 
e202 .. 00		.loop_under: db "LOOP Underflow",0 
e211			 
e211			 
e211 d5			type_faultn: 	push de 
e212 e5					push hl 
e213 cd ac 8a				call clear_display 
e216 11 40 e2				   ld de, .typefaultn 
e219 3e 00				ld a, display_row_1 
e21b cd be 8a				call str_at_display 
e21e 11 62 ee				    ld de, debug_mark 
e221 3e 11				ld a, display_row_1+17 
e223 cd be 8a				call str_at_display 
e226 cd ce 8a				call update_display 
e229			 
e229				; prompt before entering montior for investigating issue 
e229			 
e229 3e 78			ld a, display_row_4 
e22b 11 a9 96			ld de, endprog 
e22e			 
e22e cd ce 8a			call update_display		 
e231			 
e231 cd 3f 99			call next_page_prompt 
e234			 
e234 e5					push hl 
e235 d5					push de 
e236 cd fd 96				call monitor 
e239 cd 50 9d				call forth_warmstart 
e23c c3 fb 95				jp warmstart_afterauto 
e23f 76					halt 
e240			 
e240			 
e240 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e257			 
e257 d5			type_faults: 	push de 
e258 e5					push hl 
e259 cd ac 8a				call clear_display 
e25c 11 85 e2				   ld de, .typefaults 
e25f 3e 00				ld a, display_row_1 
e261 cd be 8a				call str_at_display 
e264 11 62 ee				    ld de, debug_mark 
e267 3e 11				ld a, display_row_1+17 
e269 cd be 8a				call str_at_display 
e26c cd ce 8a				call update_display 
e26f			 
e26f				; prompt before entering montior for investigating issue 
e26f			 
e26f 3e 78			ld a, display_row_4 
e271 11 a9 96			ld de, endprog 
e274			 
e274 cd ce 8a			call update_display		 
e277			 
e277 cd 3f 99			call next_page_prompt 
e27a			 
e27a e1					pop hl 
e27b d1					pop de 
e27c cd fd 96				call monitor 
e27f cd 50 9d				call forth_warmstart 
e282 c3 fb 95				jp warmstart_afterauto 
e285			 
e285			 
e285 .. 00		.typefaults: db "STR Type Expected TOS!",0 
e29c			 
e29c			.show_fault: 	 
e29c d5					push de 
e29d cd ac 8a				call clear_display 
e2a0 d1					pop de 
e2a1 3e 00				ld a, display_row_1 
e2a3 cd be 8a				call str_at_display 
e2a6 11 62 ee				    ld de, debug_mark 
e2a9 3e 11				ld a, display_row_1+17 
e2ab cd be 8a				call str_at_display 
e2ae cd ce 8a				call update_display 
e2b1			 
e2b1				; prompt before entering montior for investigating issue 
e2b1			 
e2b1 3e 78			ld a, display_row_4 
e2b3 11 a9 96			ld de, endprog 
e2b6			 
e2b6 cd ce 8a			call update_display		 
e2b9			 
e2b9 cd 3f 99			call next_page_prompt 
e2bc			 
e2bc e1					pop hl 
e2bd d1					pop de 
e2be cd fd 96				call monitor 
e2c1			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e2c1			; TODO Make optional fault restart to cli or warm boot? 
e2c1					;jp warmstart 
e2c1 c3 3e 96				jp cli 
e2c4 76					halt 
e2c5			 
e2c5			 
e2c5			; handle the auto run of code from files in storage 
e2c5			 
e2c5			 
e2c5			include "forth_startup.asm" 
e2c5			; Which startup method to use? 
e2c5			; 
e2c5			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e2c5			; followed by loading of a list of scripts in eeprom 
e2c5			 
e2c5			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e2c5			; from eeprom 
e2c5			 
e2c5			; Select with define in main stubs 
e2c5			 
e2c5			if STARTUP_V1 
e2c5				include "forth_startupv1.asm" 
e2c5			; Startup script loading version 1 
e2c5			 
e2c5			; If SE storage is available first stage is to use the selected file 
e2c5			; then go through the eeprom list 
e2c5			 
e2c5 .. 00		sprompt1: db "Startup load...",0 
e2d5 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e2eb			 
e2eb			 
e2eb			 
e2eb			 
e2eb			forth_startup: 
e2eb 21 1a d4			ld hl, startcmds 
e2ee 3e 00			ld a, 0 
e2f0 32 de e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e2f3			 
e2f3 e5			.start1:	push hl 
e2f4 cd ac 8a			call clear_display 
e2f7 11 c5 e2			ld de, sprompt1 
e2fa 3e 00		        ld a, display_row_1 
e2fc cd be 8a			call str_at_display 
e2ff 11 d5 e2			ld de, sprompt2 
e302 3e 28		        ld a, display_row_2 
e304 cd be 8a			call str_at_display 
e307 e1				pop hl 
e308 e5				push hl 
e309 5e				ld e,(hl) 
e30a 23				inc hl 
e30b 56				ld d,(hl) 
e30c 3e 50		        ld a, display_row_3 
e30e cd be 8a			call str_at_display 
e311 cd ce 8a			call update_display 
e314			 
e314			 
e314 3a de e6			ld a, (os_last_cmd) 
e317 fe 00			cp 0 
e319 28 05			jr z, .startprompt 
e31b cd e4 89			call delay250ms 
e31e 18 24			jr .startdo 
e320				 
e320				 
e320			 
e320			.startprompt: 
e320			 
e320 3e 9f			ld a,display_row_4 + display_cols - 1 
e322 11 3d 99		        ld de, endprg 
e325 cd be 8a			call str_at_display 
e328 cd ce 8a			call update_display 
e32b cd f0 89			call delay1s 
e32e cd 51 e4			call cin_wait 
e331						 
e331 fe 2a			cp '*' 
e333 28 5e			jr z, .startupend1 
e335 fe 23			cp '#' 
e337 20 07			jr nz, .startno 
e339 3e 01			ld a, 1 
e33b 32 de e6			ld (os_last_cmd),a 
e33e 18 04			jr .startdo 
e340 fe 31		.startno:	cp '1' 
e342 28 3a			jr z,.startnxt  
e344			 
e344				; exec startup line 
e344			.startdo:	 
e344 e1				pop hl 
e345 e5				push hl 
e346				 
e346 5e				ld e,(hl) 
e347 23				inc hl 
e348 56				ld d,(hl) 
e349 eb				ex de,hl 
e34a			 
e34a e5				push hl 
e34b			 
e34b 3e 00			ld a, 0 
e34d				;ld a, FORTH_END_BUFFER 
e34d cd 39 90			call strlent 
e350 23				inc hl   ; include zero term to copy 
e351 06 00			ld b,0 
e353 4d				ld c,l 
e354 e1				pop hl 
e355 11 b8 e2			ld de, scratch 
e358 ed b0			ldir 
e35a			 
e35a			 
e35a 21 b8 e2			ld hl, scratch 
e35d cd f0 9d			call forthparse 
e360 cd 28 9e			call forthexec 
e363 cd 4a 9d			call forthexec_cleanup 
e366			 
e366 3e 78			ld a, display_row_4 
e368 11 a9 96			ld de, endprog 
e36b			 
e36b cd ce 8a			call update_display		 
e36e			 
e36e 3a de e6			ld a, (os_last_cmd) 
e371 fe 00			cp 0 
e373 20 09			jr nz, .startnxt 
e375 cd 3f 99			call next_page_prompt 
e378 cd ac 8a		        call clear_display 
e37b cd ce 8a			call update_display		 
e37e			 
e37e				; move onto next startup line? 
e37e			.startnxt: 
e37e			 
e37e cd e4 89			call delay250ms 
e381 e1				pop hl 
e382			 
e382 23				inc hl 
e383 23				inc hl 
e384			 
e384 e5				push hl 
e385 5e				ld e, (hl) 
e386 23				inc hl 
e387 56				ld d, (hl) 
e388 e1				pop hl 
e389				; TODO replace 0 test 
e389			 
e389 eb				ex de, hl 
e38a cd ff 8c			call ishlzero 
e38d			;	ld a,e 
e38d			;	add d 
e38d			;	cp 0    ; any left to do? 
e38d eb				ex de, hl 
e38e c2 f3 e2			jp nz, .start1 
e391 18 01			jr .startupend 
e393			 
e393 e1			.startupend1: pop hl 
e394			.startupend: 
e394			 
e394 cd ac 8a			call clear_display 
e397 cd ce 8a			call update_display 
e39a c9				ret 
e39b			if STORAGE_SE 
e39b			 
e39b			sprompt3: db "Loading from start-up file?:",0 
e39b			sprompt4: db "(Y=Any key/N=No)",0 
e39b			 
e39b			 
e39b			forth_autoload: 
e39b			 
e39b				; load block 0 of store 1 
e39b				 
e39b				ld a, $fe      ; bit 0 clear 
e39b				ld (spi_device), a 
e39b			 
e39b				call storage_get_block_0 
e39b			 
e39b				ld a, (store_page+STORE_0_AUTOFILE) 
e39b			 
e39b				cp 0 
e39b				ret z     ; auto start not enabled 
e39b			 
e39b				call clear_display 
e39b			 
e39b				; set bank 
e39b			 
e39b					ld a, (store_page+STORE_0_BANKRUN) 
e39b					ld (spi_device), a 
e39b			 
e39b				; get file id to load from and get the file name to display 
e39b			 
e39b					ld a, (store_page+STORE_0_FILERUN) 
e39b			 
e39b					ld l, 0 
e39b					ld h, a 
e39b					ld de, store_page 
e39b			 
e39b					if DEBUG_FORTH_WORDS 
e39b						DMARK "ASp" 
e39b						CALLMONITOR 
e39b					endif 
e39b					call storage_read 
e39b			 
e39b					if DEBUG_FORTH_WORDS 
e39b						DMARK "ASr" 
e39b						CALLMONITOR 
e39b					endif 
e39b			 
e39b					call ishlzero 
e39b					ret z             ; file not found 
e39b			 
e39b					ld a, display_row_2 + 10 
e39b					ld de, store_page+3 
e39b					call str_at_display 
e39b				 
e39b			; 
e39b			 
e39b				ld a, display_row_1+5 
e39b				ld de, sprompt3 
e39b				call str_at_display 
e39b				ld a, display_row_3+15 
e39b				ld de, sprompt4 
e39b				call str_at_display 
e39b			 
e39b				call update_display 
e39b			 
e39b				call cin_wait 
e39b				cp 'n' 
e39b				ret z 
e39b				cp 'N' 
e39b				ret z 
e39b			 
e39b				call delay1s 
e39b			 
e39b				ld a, (store_page+2) 
e39b				ld (store_openmaxext), a    ; save count of ext 
e39b				ld a, 1  
e39b				ld (store_openext), a    ; save count of ext 
e39b			 
e39b			.autof:  
e39b				ld l , a 
e39b				 
e39b				ld a, (store_page) 
e39b				ld h, a	 
e39b				ld de, store_page 
e39b					if DEBUG_FORTH_WORDS 
e39b						DMARK "ASl" 
e39b						CALLMONITOR 
e39b					endif 
e39b					call storage_read 
e39b				call ishlzero 
e39b				ret z 
e39b			;	jr z, .autoend 
e39b			 
e39b					if DEBUG_FORTH_WORDS 
e39b						DMARK "ASc" 
e39b						CALLMONITOR 
e39b					endif 
e39b				ld de, store_page+2 
e39b				ld a, display_row_4 
e39b				call str_at_display 
e39b			 
e39b				call update_display 
e39b				call delay250ms 
e39b			 
e39b			 
e39b			 
e39b				ld hl, store_page+2 
e39b				call forthparse 
e39b				call forthexec 
e39b				call forthexec_cleanup 
e39b			 
e39b				 
e39b				ld a, (store_openext) 
e39b				inc a 
e39b				ld (store_openext), a    ; save count of ext 
e39b			 
e39b				jr .autof 
e39b			;.autofdone: 
e39b			; 
e39b			;		if DEBUG_FORTH_WORDS 
e39b			;			DMARK "ASx" 
e39b			;			CALLMONITOR 
e39b			;		endif 
e39b			;;	call clear_display 
e39b			;	ret 
e39b			 
e39b			 
e39b			 
e39b			endif 
# End of file forth_startupv1.asm
e39b			endif 
e39b			if STARTUP_V2 
e39b				include "forth_startupv2.asm" 
e39b			endif 
e39b			 
# End of file forth_startup.asm
e39b			 
e39b			; eof 
# End of file forth_kernel.asm
e39b			;include "nascombasic.asm" 
e39b			;include "basicZ80.asm" 
e39b			 
e39b			 
e39b			 
e39b			; find out where the code ends if loaded into RAM (for SC114) 
e39b			;endofcode:  
e39b			;	nop 
e39b			 
e39b			 
e39b			; jump to nmi vector 
e39b			 
e39b			init_nmi: 
e39b 3e c9			ld a, $c9   ; RET 
e39d 32 72 ee			ld (nmi_vector), a 
e3a0 c9				ret 
e3a1			nmi: 
e3a1 e5				push hl 
e3a2 d5				push de 
e3a3 c5				push bc 
e3a4 f5				push af 
e3a5 cd 72 ee			call nmi_vector 
e3a8 f5				push af 
e3a9 c5				push bc 
e3aa d5				push de 
e3ab e5				push hl 
e3ac ed 4d			reti 
e3ae			 
e3ae			 
e3ae			; eof 
e3ae			 
# End of file main.asm
e3ae			;include "firmware_lcd_4x40.asm" 
e3ae			;;include "firmware_lcd_4x20.asm" 
e3ae			include "firmware_serial_display.asm" 
e3ae			 
e3ae			; Serial display interface for SC114 
e3ae			 
e3ae			 
e3ae			display_row_1: equ 0 
e3ae			display_row_2: equ display_row_1+display_cols 
e3ae			display_row_3: equ display_row_2 + display_cols 
e3ae			display_row_4: equ display_row_3 + display_cols 
e3ae			 
e3ae			kLCDWidth:  EQU display_cols             ;Width in characters 
e3ae			kLCD_Line1: EQU 0x00  
e3ae			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e3ae			; E1 
e3ae			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e3ae			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e3ae			 
e3ae			lcd_init: 
e3ae				; no init as handled by the SCM bios 
e3ae c9				ret 
e3af			 
e3af			 
e3af			; low level functions for direct screen writes 
e3af			 
e3af			; output char at pos? 
e3af			fLCD_Str: 
e3af			        ;out (SC114_SIO_1_OUT),a 
e3af c5				push bc 
e3b0 0e 02			ld c, $02 
e3b2 f7				rst $30 
e3b3 c1				pop bc 
e3b4 c9				ret 
e3b5			 
e3b5			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e3b5			fLCD_Pos: 
e3b5				; use ASCII escape to position 
e3b5			        ;out (SC114_SIO_1_OUT),a 
e3b5 c5				push bc 
e3b6 0e 02			ld c, $02 
e3b8 f7				rst $30 
e3b9 c1				pop bc 
e3ba			 
e3ba c9				ret 
e3bb			 
e3bb			; output char at pos 
e3bb			fLCD_Data: 
e3bb			      ;  out (SC114_SIO_1_OUT),a 
e3bb c5				push bc 
e3bc 0e 02			ld c, $02 
e3be f7				rst $30 
e3bf c1				pop bc 
e3c0			 
e3c0 c9				ret 
e3c1			 
e3c1			; ascii cls  
e3c1			 
e3c1 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e3c5			 
e3c5			; write the frame buffer given in hl to hardware  
e3c5			write_display: 
e3c5			 
e3c5			API: equ 0 
e3c5			 
e3c5			if API 
e3c5				push bc 
e3c5				ld b, 4 
e3c5			 
e3c5			        ld (display_write_tmp), hl 	  
e3c5			 
e3c5				; clear and home cursor 
e3c5			 
e3c5				ld c, 6 
e3c5				ld de, .cls 
e3c5				rst $30 
e3c5			 
e3c5			 
e3c5			.writeln: 
e3c5			 
e3c5				ld de, (display_write_tmp) 
e3c5				ld c, 6 
e3c5				rst $30 
e3c5				ld c, 7 
e3c5				rst $30 
e3c5			 
e3c5				ld hl, (display_write_tmp) 
e3c5				ld de, display_cols 
e3c5				add hl,de 
e3c5				ld (display_write_tmp),hl 
e3c5			 
e3c5				djnz  .writeln 
e3c5			 
e3c5				pop bc 
e3c5			 
e3c5			 
e3c5				ret 
e3c5			endif 
e3c5 e5				push hl 
e3c6 c5				push bc 
e3c7 d5				push de 
e3c8			 
e3c8			;	ld c, 2 
e3c8			;	;ld de, .cls 
e3c8			;	ld a, 27 
e3c8			;	rst $30 
e3c8			;	ld c, 2 
e3c8			;	;ld de, .cls 
e3c8			;	ld a, '[' 
e3c8			;	rst $30 
e3c8			; 
e3c8			;	ld c, 2 
e3c8			;	;ld de, .cls 
e3c8			;	ld a, 'H' 
e3c8			;	rst $30 
e3c8			; 
e3c8			 
e3c8 0e 02			ld c, 2 
e3ca				;ld de, .cls 
e3ca 3e 1b			ld a, 27 
e3cc f7				rst $30 
e3cd			 
e3cd			 
e3cd 0e 02			ld c, 2 
e3cf				;ld de, .cls 
e3cf 3e 5b			ld a, '[' 
e3d1 f7				rst $30 
e3d2 0e 02			ld c, 2 
e3d4				;ld de, .cls 
e3d4 3e 32			ld a, '2' 
e3d6 f7				rst $30 
e3d7 0e 02			ld c, 2 
e3d9				;ld de, .cls 
e3d9 3e 4a			ld a, 'J' 
e3db f7				rst $30 
e3dc d1				pop de 
e3dd c1				pop bc 
e3de e1				pop hl 
e3df			 
e3df			 
e3df 22 c0 eb		        ld (display_write_tmp), hl 	  
e3e2 3e 00			ld a, kLCD_Line1 
e3e4			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e3e4 06 28			ld b, display_cols 
e3e6 ed 5b c0 eb		ld de, (display_write_tmp) 
e3ea cd 48 e4			call write_len_string 
e3ed				 
e3ed			 
e3ed e5			push hl 
e3ee d5			push de 
e3ef c5			push bc 
e3f0 0e 07			ld c, 7 
e3f2 f7				rst $30 
e3f3 c1			pop bc 
e3f4 d1			pop de 
e3f5 e1			pop hl 
e3f6			 
e3f6				 
e3f6 2a c0 eb			ld hl, (display_write_tmp) 
e3f9 11 28 00			ld de, display_cols 
e3fc 19				add hl,de 
e3fd 22 c0 eb			ld (display_write_tmp),hl 
e400			 
e400				 
e400 3e 28			ld a, kLCD_Line2 
e402			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e402 06 28			ld b, display_cols 
e404 ed 5b c0 eb		ld de, (display_write_tmp) 
e408 cd 48 e4			call write_len_string 
e40b				 
e40b 2a c0 eb			ld hl, (display_write_tmp) 
e40e 11 28 00			ld de, display_cols 
e411 19				add hl,de 
e412 22 c0 eb			ld (display_write_tmp),hl 
e415			 
e415 e5			push hl 
e416 d5			push de 
e417 c5			push bc 
e418 0e 07			ld c, 7 
e41a f7				rst $30 
e41b c1			pop bc 
e41c d1			pop de 
e41d e1			pop hl 
e41e			 
e41e				 
e41e 3e 50			ld a, kLCD_Line3 
e420			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e420 06 28			ld b, display_cols 
e422 ed 5b c0 eb		ld de, (display_write_tmp) 
e426 cd 48 e4			call write_len_string 
e429				 
e429 2a c0 eb			ld hl, (display_write_tmp) 
e42c 11 28 00			ld de, display_cols 
e42f 19				add hl,de 
e430 22 c0 eb			ld (display_write_tmp),hl 
e433			 
e433 e5			push hl 
e434 d5			push de 
e435 c5			push bc 
e436 0e 07			ld c, 7 
e438 f7				rst $30 
e439 c1			pop bc 
e43a d1			pop de 
e43b e1			pop hl 
e43c			 
e43c				 
e43c 3e 78			ld a, kLCD_Line4 
e43e			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e43e 06 28			ld b, display_cols 
e440 ed 5b c0 eb		ld de, (display_write_tmp) 
e444 cd 48 e4			call write_len_string 
e447 c9					ret 
e448			 
e448			 
e448				; write out a fixed length string given in b from de 
e448			 
e448 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e449 cd bb e3		            CALL fLCD_Data      ;Write character to display 
e44c 13				inc de 
e44d 10 f9			djnz write_len_string 
e44f c9				ret 
e450			 
e450			 
e450			; eof 
# End of file firmware_serial_display.asm
e450			;include "firmware_key_5x10.asm" 
e450			;;include "firmware_key_4x10.asm" 
e450			include "firmware_key_serial.asm" 
e450			; Serial keyboard interface for SC114 
e450			 
e450			key_init: 
e450				; no init as handled by the SCM bios 
e450 c9				ret 
e451			 
e451			 
e451			cin_wait: 
e451			;	ld a, 0 
e451			;	ret 
e451			 
e451				;in a,(SC114_SIO_1_IN) 
e451			        ; Use SCM API to get from whatever console device we are using 
e451 c5				push bc 
e452 0e 01			ld c, $01 
e454 f7				rst $30 
e455 c1				pop bc 
e456 c9				ret 
e457			 
e457			cinndb: 	 
e457			cin: 
e457			 
e457			 
e457 c5				push bc 
e458			 
e458				; any key waiting to process? 
e458 0e 03			ld c, $03 
e45a f7				rst $30 
e45b 28 05			jr z, .cin_skip 
e45d			 
e45d				; yep, get it 
e45d			 
e45d 0e 01			ld c, $01 
e45f f7				rst $30 
e460 c1				pop bc 
e461 c9				ret 
e462			.cin_skip: 
e462 3e 00			ld a, 0 
e464 c1				pop bc 
e465 c9				ret 
e466			 
e466			 
e466			 
e466			 
# End of file firmware_key_serial.asm
e466			endofcode:  
e466			baseram:  
e466 00				nop 
e467			 
e467			heap_start: equ baseram+15  ; Starting address of heap 
e467			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e467			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e467			;VDU:  EQU     endofcode           ; BASIC Work space 
e467			; eof 
e467			 
# End of file os_mega_sc114.asm
e467
