# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 f8 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 1  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_active-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
001c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
001c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 13 fd				ld hl, display_fb1  
001f 22 cf fb				ld (display_fb_active), hl  
0022			  
0022 cd 52 0d				call clear_display  
0025			  
0025 21 d1 fb				ld hl, display_fb2  
0028 22 cf fb				ld (display_fb_active), hl  
002b			  
002b cd 52 0d				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 b4 fd				ld hl, display_fb0  
0031 22 cf fb				ld (display_fb_active), hl  
0034			  
0034 cd 52 0d				call clear_display  
0037			  
0037			  
0037 cd 33 75				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd ca 77			call key_init  
003d cd fe 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd 29 14				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043 cd e6 15				call sound_init  
0046				endif  
0046			  
0046				; lcd test sequence  
0046					  
0046 cd 75 0d			call update_display  
0049 cd 95 0c			call delay1s  
004c 3e 2b			ld a,'+'  
004e cd 57 0d			call fill_display  
0051 cd 75 0d			call update_display  
0054 cd 95 0c			call delay1s  
0057 3e 2a			ld a,'*'  
0059 cd 57 0d			call fill_display  
005c cd 75 0d			call update_display  
005f cd 95 0c			call delay1s  
0062 3e 2d			ld a,'-'  
0064 cd 57 0d			call fill_display  
0067 cd 75 0d			call update_display  
006a cd 95 0c			call delay1s  
006d			  
006d			; boot splash screen  
006d			if display_cols == 20	  
006d			        ld a, display_row_1    
006d			else  
006d 3e 0a		        ld a, display_row_1 +10   
006f			endif  
006f 11 d1 1b			ld de, prom_bootmsg  
0072 cd 65 0d			call str_at_display  
0075 cd 75 0d			call update_display  
0078			  
0078			  
0078 cd 95 0c			call delay1s  
007b cd 95 0c			call delay1s  
007e			if display_cols == 20	  
007e			            LD   A, display_row_3+2  
007e			else  
007e 3e 5c		            LD   A, display_row_3+12  
0080			endif  
0080 11 e6 1b			ld de, prom_bootmsg1  
0083 cd 65 0d			call str_at_display  
0086 cd 75 0d			call update_display  
0089 cd 95 0c			call delay1s  
008c cd 95 0c			call delay1s  
008f			  
008f			;	ld a, display_row_4+3  
008f			;	ld de, bootmsg2  
008f			;	call str_at_display  
008f			;	call update_display  
008f			;	call delay1s  
008f			;	call delay1s  
008f			  
008f			; debug mark setup  
008f			  
008f 3e 5f		ld a, '_'  
0091 32 6e fe		ld (debug_mark),a  
0094 32 6f fe		ld (debug_mark+1),a  
0097 32 70 fe		ld (debug_mark+2),a  
009a 3e 00		ld a,0  
009c 32 71 fe		ld (debug_mark+3),a  
009f			  
009f c9					ret  
00a0			  
00a0			  
00a0			;bootmsg2:	db "Firmware v0.1",0  
00a0			  
00a0			; a 4x20 lcd  
00a0			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a0			  
00a0			;if display_cols == 20  
00a0			;	include "firmware_lcd_4x20.asm"  
00a0			;endif  
00a0			  
00a0			;if display_cols == 40  
00a0			;	include "firmware_lcd_4x40.asm"  
00a0			;endif  
00a0			  
00a0			;  
00a0			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a0			; TODO abstract the bit bang video out interface for dual display  
00a0			; TODO wire video out to tx pin on rc2014 bus  
00a0			  
00a0			; must supply cin, and cin_wait for low level hardware abstraction   
00a0			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a0			; test scancode  
00a0			  
00a0			;;;;;  
00a0			;;;  
00a0			; Moved out to mini and maxi versions  
00a0			;  
00a0			; include "firmware_key_4x4.asm"  
00a0			; using existing 4 wire x 4 resistor array for input  
00a0			;include "firmware_key_4x10.asm"  
00a0			; need to mod the board for 5 rows due to resistor array  
00a0			;include "firmware_key_5x10.asm"  
00a0			  
00a0			; storage hardware interface  
00a0			  
00a0			; use microchip serial eeprom for storage  
00a0			  
00a0			  
00a0			if STORAGE_SE  
00a0				include "firmware_spi.asm"  
00a0			; my spi protocol (used by storage) 
00a0			 
00a0			; SPI pins 
00a0			 
00a0			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a0			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a0			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a0			 
00a0			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a0			; chip pin 4 gnd 
00a0			 
00a0			 
00a0			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a0			SPI_CE1: equ 1      ;    port a1 pin 14  
00a0			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a0			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a0			SPI_CE4: equ 4      ; port a4     pin 10 
00a0			 
00a0			; active low AND masks 
00a0			 
00a0			;SPI_CE0_MASK: equ    255-1 
00a0			;SPI_CE1_MASK: equ   255-2 
00a0			;SPI_CE2_MASK: equ   255-4 
00a0			;SPI_CE3_MASK: equ   255-8 
00a0			;SPI_CE4_MASK: equ   255-16 
00a0			SPI_CE_HIGH:  equ 255 
00a0			 
00a0			 
00a0			 
00a0			;  Perform SCLK wait pulse 
00a0			 
00a0			spi_clk: 
00a0 f5				push af 
00a1 3a 67 fa			ld a, (spi_clktime) 
00a4 fe 00			cp 0 
00a6 28 03			jr z, .scskip 
00a8 cd 7a 0c			call aDelayInMS 
00ab			.scskip: 
00ab f1				pop af 
00ac c9				ret 
00ad			 
00ad			 
00ad			 
00ad			; TODO store port id for spi device ie dev c 
00ad			; TODO store pin for SO 
00ad			; TODO store pin for SI 
00ad			; TODO store pin for SCLK 
00ad			 
00ad			; 
00ad			 
00ad			; ensure that spi bus is in a stable state with default pins  
00ad			 
00ad			se_stable_spi:   
00ad			 
00ad				 ; set DI high, CE high , SCLK low 
00ad				;ld a, SPI_DI | SPI_CE0 
00ad 3e 07			ld a, SPI_DI  
00af cd b9 01			call spi_ce_high 
00b2 d3 80			 out (storage_adata),a 
00b4 32 64 fa			ld (spi_portbyte),a 
00b7			 
00b7				if DEBUG_SPI 
00b7					push hl 
00b7					ld l, a 
00b7					DMARK "SPI" 
00b7					CALLMONITOR 
00b7					pop hl 
00b7				endif 
00b7 c9				ret 
00b8			 
00b8			; byte to send in a 
00b8			 
00b8			spi_send_byte: 
00b8				; save byte to send for bit mask shift out 
00b8 4f			        ld c,a 
00b9 3a 64 fa			ld a,(spi_portbyte) 
00bc				  
00bc				; clock out	each bit of the byte msb first 
00bc			 
00bc 06 08			ld b, 8 
00be			.ssb1: 
00be				; clear so bit  
00be cb bf			res SPI_DI, a 
00c0 cb 11			rl c 
00c2				; if bit 7 is set then carry is set 
00c2 30 02			jr nc, .ssb2 
00c4 cb ff			set SPI_DI,a 
00c6			.ssb2:  ; output bit to ensure it is stable 
00c6 d3 80			out (storage_adata),a 
00c8 00				nop 
00c9				; clock bit high 
00c9 cb ef			set SPI_SCLK,a 
00cb d3 80			out (storage_adata),a 
00cd 00				nop 
00ce cd a0 00			call spi_clk 
00d1				; then low 
00d1 cb af			res SPI_SCLK,a 
00d3 d3 80			out (storage_adata),a 
00d5 00				nop 
00d6 cd a0 00			call spi_clk 
00d9 10 e3			djnz .ssb1 
00db			 
00db 32 64 fa			ld (spi_portbyte),a 
00de c9				ret 
00df			 
00df			; TODO low level get byte into A on spi 
00df			 
00df			spi_read_byte:  
00df			 
00df				; save byte to send for bit mask shift out 
00df 0e 00		    ld c,0 
00e1 3a 64 fa			ld a,(spi_portbyte) 
00e4				  
00e4				; clock out	each bit of the byte msb first 
00e4			 
00e4			 
00e4				; clock bit high 
00e4 cb ef			set SPI_SCLK,a 
00e6 d3 80			out (storage_adata),a 
00e8 00				nop 
00e9 cd a0 00			call spi_clk 
00ec			 
00ec			    ; read DO  
00ec			 
00ec cb f9		    set 7,c 
00ee db 80			in a,(storage_adata) 
00f0 cb 77		    bit SPI_DO,a 
00f2 20 02		    jr nz, .b7 
00f4 cb b9		    res 7,c 
00f6			.b7: 
00f6				; then low 
00f6 cb af			res SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb cd a0 00			call spi_clk 
00fe			     
00fe			 
00fe				; clock bit high 
00fe cb ef			set SPI_SCLK,a 
0100 d3 80			out (storage_adata),a 
0102 00				nop 
0103 cd a0 00			call spi_clk 
0106			 
0106			    ; read DO  
0106			 
0106 cb f1		    set 6,c 
0108 db 80			in a,(storage_adata) 
010a cb 77		    bit SPI_DO,a 
010c 20 02		    jr nz, .b6 
010e cb b1		    res 6,c 
0110			.b6: 
0110				; then low 
0110 cb af			res SPI_SCLK,a 
0112 d3 80			out (storage_adata),a 
0114 00				nop 
0115 cd a0 00			call spi_clk 
0118			 
0118				; clock bit high 
0118 cb ef			set SPI_SCLK,a 
011a d3 80			out (storage_adata),a 
011c 00				nop 
011d cd a0 00			call spi_clk 
0120			 
0120			 
0120			    ; read DO  
0120			 
0120 cb e9		    set 5,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b5 
0128 cb a9		    res 5,c 
012a			.b5: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f cd a0 00			call spi_clk 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137 cd a0 00			call spi_clk 
013a			 
013a			    ; read DO  
013a			 
013a cb e1		    set 4,c 
013c db 80			in a,(storage_adata) 
013e cb 77		    bit SPI_DO,a 
0140 20 02		    jr nz, .b4 
0142 cb a1		    res 4,c 
0144			.b4: 
0144				; then low 
0144 cb af			res SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149 cd a0 00			call spi_clk 
014c				; clock bit high 
014c cb ef			set SPI_SCLK,a 
014e d3 80			out (storage_adata),a 
0150 00				nop 
0151 cd a0 00			call spi_clk 
0154			 
0154			    ; read DO  
0154			 
0154 cb d9		    set 3,c 
0156 db 80			in a,(storage_adata) 
0158 cb 77		    bit SPI_DO,a 
015a 20 02		    jr nz, .b3 
015c cb 99		    res 3,c 
015e			.b3: 
015e				; then low 
015e cb af			res SPI_SCLK,a 
0160 d3 80			out (storage_adata),a 
0162 00				nop 
0163 cd a0 00			call spi_clk 
0166				; clock bit high 
0166 cb ef			set SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b cd a0 00			call spi_clk 
016e			 
016e			    ; read DO  
016e			 
016e cb d1		    set 2,c 
0170 db 80			in a,(storage_adata) 
0172 cb 77		    bit SPI_DO,a 
0174 20 02		    jr nz, .b2 
0176 cb 91		    res 2,c 
0178			.b2: 
0178				; then low 
0178 cb af			res SPI_SCLK,a 
017a d3 80			out (storage_adata),a 
017c 00				nop 
017d cd a0 00			call spi_clk 
0180				; clock bit high 
0180 cb ef			set SPI_SCLK,a 
0182 d3 80			out (storage_adata),a 
0184 00				nop 
0185 cd a0 00			call spi_clk 
0188			 
0188			    ; read DO  
0188			 
0188 cb c9		    set 1,c 
018a db 80			in a,(storage_adata) 
018c cb 77		    bit SPI_DO,a 
018e 20 02		    jr nz, .b1 
0190 cb 89		    res 1,c 
0192			.b1: 
0192				; then low 
0192 cb af			res SPI_SCLK,a 
0194 d3 80			out (storage_adata),a 
0196 00				nop 
0197 cd a0 00			call spi_clk 
019a				; clock bit high 
019a cb ef			set SPI_SCLK,a 
019c d3 80			out (storage_adata),a 
019e 00				nop 
019f cd a0 00			call spi_clk 
01a2			 
01a2			    ; read DO  
01a2			 
01a2 cb c1		    set 0,c 
01a4 db 80			in a,(storage_adata) 
01a6 cb 77		    bit SPI_DO,a 
01a8 20 02		    jr nz, .b0 
01aa cb 81		    res 0,c 
01ac			.b0: 
01ac				; then low 
01ac cb af			res SPI_SCLK,a 
01ae d3 80			out (storage_adata),a 
01b0 00				nop 
01b1 cd a0 00			call spi_clk 
01b4			 
01b4			 
01b4 32 64 fa			ld (spi_portbyte),a 
01b7			 
01b7			    ; return byte 
01b7 79			    ld a,c 
01b8			 
01b8			 
01b8 c9				ret 
01b9			 
01b9			 
01b9			 
01b9			spi_ce_high: 
01b9			 
01b9				if DEBUG_SPI_HARD_CE0 
01b9			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01b9					ret 
01b9			 
01b9				endif 
01b9			 
01b9			 
01b9 f5				push af 
01ba			 
01ba				; send direct ce to port b 
01ba 3e ff			ld a, 255 
01bc d3 81			out (storage_bdata), a 
01be			 
01be f1				pop af 
01bf			 
01bf				; for port a that shares with spi lines AND the mask 
01bf			  
01bf				if DEBUG_SPI 
01bf					push hl 
01bf					ld h, a 
01bf				endif 
01bf			;	ld c, SPI_CE_HIGH 
01bf			;	and c 
01bf cb c7			set SPI_CE0, a 
01c1 cb cf			set SPI_CE1, a 
01c3 cb d7			set SPI_CE2, a 
01c5 cb df			set SPI_CE3, a 
01c7 cb e7			set SPI_CE4, a 
01c9			 
01c9				if DEBUG_SPI 
01c9					ld l, a 
01c9					DMARK "CEh" 
01c9					CALLMONITOR 
01c9					pop hl 
01c9				endif 
01c9 c9				ret 
01ca			 
01ca			 
01ca			spi_ce_low: 
01ca			 
01ca				if DEBUG_SPI_HARD_CE0 
01ca			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ca					ret 
01ca			 
01ca				endif 
01ca			 
01ca c5				push bc 
01cb f5				push af 
01cc			 
01cc				; send direct ce to port b 
01cc 3a 66 fa			ld a, (spi_cartdev) 
01cf d3 81			out (storage_bdata), a 
01d1			 
01d1			 
01d1			 
01d1				; for port a that shares with spi lines AND the mask 
01d1			 
01d1 3a 63 fa			ld a, (spi_device)  
01d4 4f				ld c, a 
01d5			 
01d5 f1				pop af 
01d6			 
01d6				; detect CEx 
01d6			 
01d6				if DEBUG_SPI 
01d6					push hl 
01d6					ld h, a 
01d6				endif 
01d6			 
01d6 cb 41			bit SPI_CE0, c 
01d8 20 04			jr nz, .cel1 
01da cb 87			res SPI_CE0, a 
01dc 18 1e			jr .celn 
01de			.cel1: 
01de cb 49			bit SPI_CE1, c 
01e0 20 04			jr nz, .cel2 
01e2 cb 8f			res SPI_CE1, a 
01e4 18 16			jr .celn 
01e6			.cel2: 
01e6 cb 51			bit SPI_CE2, c 
01e8 20 04			jr nz, .cel3 
01ea cb 97			res SPI_CE2, a 
01ec 18 0e			jr .celn 
01ee			.cel3: 
01ee cb 59			bit SPI_CE3, c 
01f0 20 04			jr nz, .cel4 
01f2 cb 9f			res SPI_CE3, a 
01f4 18 06			jr .celn 
01f6			.cel4: 
01f6 cb 61			bit SPI_CE4, c 
01f8 20 02			jr nz, .celn 
01fa cb a7			res SPI_CE4, a 
01fc			.celn: 
01fc			 
01fc			 
01fc			 
01fc			;	add c 
01fc			 
01fc				if DEBUG_SPI 
01fc					ld l, a 
01fc					DMARK "CEl" 
01fc					CALLMONITOR 
01fc					pop hl 
01fc				endif 
01fc c1				pop bc 
01fd c9				ret 
01fe			 
01fe			 
01fe			 
01fe			; eof 
01fe			 
01fe			 
01fe			 
01fe			 
01fe			 
# End of file firmware_spi.asm
01fe				include "firmware_seeprom.asm"  
01fe			; 
01fe			; persisent storage interface via microchip serial eeprom 
01fe			 
01fe			; port a pio 2 
01fe			; pa 7 - si 
01fe			; pa 6 - sclk  
01fe			; pa 5 - so 
01fe			; pa 4 - cs 
01fe			; pa 3 - cs 
01fe			; pa 2 - cs 
01fe			; pa 1 - cs 
01fe			; pa 0 - cs 
01fe			; 
01fe			; TODO get block 
01fe			; TODO save block 
01fe			; TODO load file 
01fe			; TODO save file 
01fe			; TODO get dir  
01fe			 
01fe			;  
01fe			storage_adata: equ Device_C    ; device c port a - onboard storage 
01fe			storage_actl: equ Device_C+2     ; device c port a 
01fe			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01fe			storage_bctl: equ Device_C+3     ; device c port b 
01fe			 
01fe			 
01fe			; TODO move these to hardware driver file 
01fe			 
01fe			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01fe			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01fe			; storage bank file system format 
01fe			; 
01fe			; first page of bank: 
01fe			; 	addr 0 - status check 
01fe			;       addr 1 - write protect flag 
01fe			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01fe			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01fe			;         TODO see if scanning whole of for available next file id is fast enough 
01fe			;	addr 4 > zero term string of bank label 
01fe			; 
01fe			;        
01fe			;  
01fe			; first page of any file: 
01fe			;      byte 0 - file id  
01fe			;      byte 1-17 - fixed file name  
01fe			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01fe			; 
01fe			; other pages of any file: 
01fe			;      byte 0 - file id 
01fe			;      byte 1> - file data 
01fe			; 
01fe			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01fe			;  
01fe			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01fe			 
01fe			 
01fe			;storage_so_bit: 5 
01fe			;storage_si_bit: 7 
01fe			;storage_sclk_bit: 6 
01fe			  
01fe			 
01fe			; init storage pio 
01fe			 
01fe			storage_init: 
01fe			 
01fe			 
01fe					; set default SPI clk pulse time as disabled 
01fe			 
01fe 3e 00				ld a, 0 
0200 32 67 fa				ld (spi_clktime), a 
0203			 
0203					; init hardware 
0203			 
0203 3e cf		            LD   A, 11001111b 
0205 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0207 3e 00		            LD   A, 00000000b 
0209 cb f7			set SPI_DO,a 
020b			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
020b d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
020d			 
020d 3e cf		            LD   A, 11001111b 
020f d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0211 3e 00		            LD   A, 00000000b 
0213 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0215			 
0215				; set all external spi devices off  
0215 3e ff			ld a, 255 
0217 32 63 fa			ld (spi_device), a 
021a 32 66 fa			ld (spi_cartdev), a 
021d			 
021d					; ensure the spi bus is in a default stable state 
021d cd ad 00				call se_stable_spi 
0220			 
0220			; TODO scan spi bus and gather which storage banks are present 
0220			 
0220			; populate store_bank_active  
0220			; for each ce line activate and attempt to write first byte of bank and read back 
0220			; if zero is returned then bank is empty 
0220			;   
0220			; 
0220			 
0220					; init file extent cache to save on slow reads 
0220			 
0220			;	ld hl, store_filecache 
0220			;	ld de, 0 
0220			;	ld hl,(de)	 
0220			 
0220			 
0220 c9			    ret 
0221			 
0221			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0221			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0221			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0221			 
0221			; INSTRUCTION SET 
0221			; READ 0000 0011 Read data from memory array beginning at selected address 
0221			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0221			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0221			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0221			; RDSR 0000 0101 Read STATUS register 
0221			; WRSR 0000 0001 Write STATUS register 
0221			; PE 0100 0010 Page Erase – erase one page in memory array 
0221			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0221			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0221			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0221			 
0221			; TODO send byte steam for page without setting the address for every single byte 
0221			; TODO read byte  
0221			 
0221			; byte in a 
0221			; address in hl  
0221			se_writebyte: 
0221			        
0221			    ;   ld c, a 
0221 f5			        push af 
0222 e5			        push hl 
0223			 
0223			    ; initi write mode 
0223			    ; 
0223			    ;CS low 
0223			 
0223 3a 64 fa		       ld a,(spi_portbyte) 
0226 cd ca 01			call spi_ce_low 
0229			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0229 d3 80		       out (storage_adata),a 
022b 32 64 fa		       ld (spi_portbyte), a 
022e			 
022e			    ;clock out wren instruction 
022e			 
022e 3e 06		    ld a, store_wren_ins 
0230 cd b8 00		    call spi_send_byte  
0233			 
0233			    ;cs high to enable write latch 
0233			 
0233 3a 64 fa		       ld a,(spi_portbyte) 
0236 cd b9 01			call spi_ce_high 
0239			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0239 d3 80		       out (storage_adata),a 
023b 32 64 fa		       ld (spi_portbyte), a 
023e			 
023e 00				nop 
023f			    ; 
023f			    ; intial write data 
023f			    ; 
023f			    ; cs low 
023f			     
023f 3a 64 fa		       ld a,(spi_portbyte) 
0242 cd ca 01			call spi_ce_low 
0245			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0245 d3 80		       out (storage_adata),a 
0247 32 64 fa		       ld (spi_portbyte), a 
024a			 
024a			    ; clock out write instruction 
024a			     
024a 3e 02		    ld a, store_write_ins  
024c cd b8 00		    call spi_send_byte  
024f			 
024f			    ; clock out address (depending on address size) 
024f			     
024f e1			    pop hl 
0250 7c			    ld a,h    ; address out msb first 
0251 cd b8 00		    call spi_send_byte  
0254 7d			    ld a,l 
0255 cd b8 00		    call spi_send_byte  
0258			 
0258			    ; clock out byte(s) for page 
0258			 
0258 f1			    pop af 
0259 cd b8 00		    call spi_send_byte  
025c			 
025c			    ; end write with ce high 
025c 3a 64 fa		       ld a,(spi_portbyte) 
025f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
025f cd b9 01			call spi_ce_high 
0262 d3 80		       out (storage_adata),a 
0264 32 64 fa		       ld (spi_portbyte), a 
0267			 
0267				; pause for internal write cycle 
0267 3e 0a			ld a, 10 
0269 cd 7a 0c			call aDelayInMS 
026c c9			    ret 
026d			 
026d			; buffer to write in de 
026d			; address in hl  
026d			se_writepage: 
026d			        
026d			    ;   ld c, a 
026d d5				push de 
026e e5			        push hl 
026f			 
026f			    ; initi write mode 
026f			    ; 
026f			    ;CS low 
026f			 
026f 3a 64 fa		       ld a,(spi_portbyte) 
0272 cd ca 01			call spi_ce_low 
0275			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0275 d3 80		       out (storage_adata),a 
0277 32 64 fa		       ld (spi_portbyte), a 
027a			 
027a			    ;clock out wren instruction 
027a			 
027a 3e 06		    ld a, store_wren_ins 
027c cd b8 00		    call spi_send_byte  
027f			 
027f			    ;cs high to enable write latch 
027f			 
027f 3a 64 fa		       ld a,(spi_portbyte) 
0282 cd b9 01			call spi_ce_high 
0285			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0285 d3 80		       out (storage_adata),a 
0287 32 64 fa		       ld (spi_portbyte), a 
028a			 
028a 00				nop 
028b			    ; 
028b			    ; intial write data 
028b			    ; 
028b			    ; cs low 
028b			     
028b 3a 64 fa		       ld a,(spi_portbyte) 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e cd ca 01			call spi_ce_low 
0291 d3 80		       out (storage_adata),a 
0293 32 64 fa		       ld (spi_portbyte), a 
0296			 
0296			    ; clock out write instruction 
0296			     
0296 3e 02		    ld a, store_write_ins  
0298 cd b8 00		    call spi_send_byte  
029b			 
029b			    ; clock out address (depending on address size) 
029b			     
029b e1			    pop hl 
029c 7c			    ld a,h    ; address out msb first 
029d cd b8 00		    call spi_send_byte  
02a0 7d			    ld a,l 
02a1 cd b8 00		    call spi_send_byte  
02a4			 
02a4			    ; clock out byte(s) for page 
02a4			 
02a4 e1				pop hl 
02a5 06 40			ld b, STORE_BLOCK_PHY 
02a7			.bytewrite: 
02a7			 
02a7 7e				ld a,(hl) 
02a8 e5			    push hl 
02a9 c5				push bc 
02aa cd b8 00		    call spi_send_byte  
02ad c1				pop bc 
02ae e1				pop hl 
02af			 
02af			    ; end write with ce high 
02af 3a 64 fa		       ld a,(spi_portbyte) 
02b2 cd b9 01			call spi_ce_high 
02b5			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b5 d3 80		       out (storage_adata),a 
02b7 32 64 fa		       ld (spi_portbyte), a 
02ba			 
02ba 23				inc hl 
02bb 10 ea			djnz .bytewrite 
02bd			 
02bd				; pause for internal write cycle 
02bd 3e 64			ld a, 100 
02bf cd 7a 0c			call aDelayInMS 
02c2 c9			    ret 
02c3			; returns byte in a 
02c3			; address in hl  
02c3			se_readbyte: 
02c3 d5				push de 
02c4 c5				push bc 
02c5			 
02c5			    ;   ld c, a 
02c5 e5			        push hl 
02c6			 
02c6			    ; initi write mode 
02c6			    ; 
02c6			    ;CS low 
02c6			 
02c6 3a 64 fa		       ld a,(spi_portbyte) 
02c9 cd ca 01			call spi_ce_low 
02cc			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cc d3 80		       out (storage_adata),a 
02ce 32 64 fa		       ld (spi_portbyte), a 
02d1			 
02d1			    ;clock out wren instruction 
02d1			 
02d1 3e 03		    ld a, store_read_ins 
02d3 cd b8 00		    call spi_send_byte  
02d6			 
02d6			 
02d6			    ; clock out address (depending on address size) 
02d6			     
02d6 e1			    pop hl 
02d7 7c			    ld a,h    ; address out msb first 
02d8 cd b8 00		    call spi_send_byte  
02db 7d			    ld a,l 
02dc cd b8 00		    call spi_send_byte  
02df			 
02df			    ; clock in byte(s) for page 
02df			 
02df cd df 00		    call spi_read_byte  
02e2 f5				push af 
02e3			 
02e3			    ; end write with ce high 
02e3 3a 64 fa		       ld a,(spi_portbyte) 
02e6			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02e6 cd b9 01			call spi_ce_high 
02e9 d3 80		       out (storage_adata),a 
02eb 32 64 fa		       ld (spi_portbyte), a 
02ee			 
02ee f1				pop af 
02ef			 
02ef c1				pop bc 
02f0 d1				pop de 
02f1			 
02f1 c9			    ret 
02f2			 
02f2			if DEBUG_STORESE 
02f2			 
02f2			storageput:  
02f2			 
02f2			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02f2			 
02f2 21 c6 f1			ld hl,scratch+2 
02f5 cd 3d 13			call get_word_hl 
02f8			 
02f8				; stuff it here for the moment as it will be overwritten later anyway 
02f8			 
02f8 22 e7 f4			ld (os_cur_ptr),hl	 
02fb			 
02fb			 
02fb			; get pointer to start of string 
02fb			 
02fb 21 cb f1			ld hl, scratch+7 
02fe			 
02fe			; loop writing char of string to eeprom 
02fe			 
02fe 7e			.writestr:	ld a,(hl) 
02ff fe 00				cp 0 
0301 28 12				jr z, .wsdone		; done writing 
0303 e5					push hl 
0304 2a e7 f4				ld hl,(os_cur_ptr) 
0307 cd 21 02				call se_writebyte 
030a			 
030a 2a e7 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
030d 23					inc hl 
030e 22 e7 f4				ld (os_cur_ptr),hl 
0311			 
0311					; restore string pointer and get next char 
0311			 
0311 e1					pop hl 
0312 23					inc hl 
0313 18 e9				jr .writestr 
0315			 
0315			 
0315			 
0315			.wsdone: 
0315			 
0315			 
0315			; when done load first page into a buffer  
0315			 
0315 21 00 80				ld hl,08000h		; start in ram 
0318 22 e7 f4				ld (os_cur_ptr),hl 
031b 21 00 00				ld hl, 0		 ; start of page 
031e 22 ec f1				ld (scratch+40),hl	; hang on to it 
0321			 
0321 06 80				ld b, 128		; actually get more then one page 
0323 c5			.wsload:	push bc 
0324 2a ec f1				ld hl,(scratch+40) 
0327 e5					push hl 
0328 cd c3 02				call se_readbyte 
032b			 
032b					; a now as the byte 
032b			 
032b 2a e7 f4				ld hl,(os_cur_ptr) 
032e 77					ld (hl),a 
032f					; inc next buffer area 
032f 23					inc hl 
0330 22 e7 f4				ld (os_cur_ptr),hl 
0333			 
0333					; get eeprom position, inc and save for next round 
0333 e1					pop hl		 
0334 23					inc hl 
0335 22 ec f1				ld (scratch+40),hl 
0338 c1					pop bc 
0339 10 e8				djnz .wsload 
033b			 
033b			; set 'd' pointer to start of buffer 
033b			 
033b 21 00 80				ld hl,08000h 
033e 22 e7 f4				ld (os_cur_ptr),hl 
0341			 
0341			 
0341 c9			ret 
0342			 
0342			 
0342 c9			storageread: ret 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			endif 
0343			 
0343			 
0343			 
# End of file firmware_seeprom.asm
0343			else  
0343			   ; create some stubs for the labels  
0343			se_readbyte: ret  
0343			se_writebyte: ret  
0343			storage_init: ret  
0343			  
0343			endif  
0343			  
0343			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0343			;include "firmware_cf.asm"  
0343			  
0343			; load up high level storage hardward abstractions  
0343			include "firmware_storage.asm"  
0343			 
0343			; persisent storage hardware abstraction layer  
0343			 
0343			 
0343			 
0343			; Block 0 on storage is a config state 
0343			 
0343			 
0343			 
0343			; TODO add read phy block and write phy block functions 
0343			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0343			 
0343			; Abstraction layer  
0343			 
0343			; Logocial block size is same size as physical size - using tape concept 
0343			 
0343			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0343			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0343			 
0343			 
0343			 
0343			; Filesystem layout (Logical layout) 
0343			; 
0343			; Block 0 - Bank config  
0343			; 
0343			;      Byte - 0 file id counter 
0343			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0343			;      Byte - 3-20 zero terminated bank label 
0343			; 
0343			; Block 1 > File storage 
0343			; 
0343			;      Byte 0 file id    - block 0 file details 
0343			;      Byte 1 block id - block 0 is file  
0343			;            Byte 2-15 - File name 
0343			; 
0343			;       - to end of block data 
0343			; 
0343			 
0343			; Get ID for the file named in pointer held HL 
0343			; Returns ID in HL = 255 if no file found 
0343			 
0343			storage_getid: 
0343			 
0343 22 76 fa			ld (store_tmp1), hl 
0346			 
0346				if DEBUG_STORESE 
0346					DMARK "SGI" 
0346 f5				push af  
0347 3a 5b 03			ld a, (.dmark)  
034a 32 6e fe			ld (debug_mark),a  
034d 3a 5c 03			ld a, (.dmark+1)  
0350 32 6f fe			ld (debug_mark+1),a  
0353 3a 5d 03			ld a, (.dmark+2)  
0356 32 70 fe			ld (debug_mark+2),a  
0359 18 03			jr .pastdmark  
035b ..			.dmark: db "SGI"  
035e f1			.pastdmark: pop af  
035f			endm  
# End of macro DMARK
035f					CALLMONITOR 
035f cd fb 19			call break_point_state  
0362				endm  
# End of macro CALLMONITOR
0362				endif 
0362				; get block 0 and set counter for number of files to scan 
0362			 
0362 cd cd 04			call storage_get_block_0 
0365			 
0365 3a 7d fa			ld a, (store_page) 
0368 47				ld b, a 
0369			 
0369				; get extent 0 of each file id 
0369			 
0369				if DEBUG_STORESE 
0369					DMARK "SGc" 
0369 f5				push af  
036a 3a 7e 03			ld a, (.dmark)  
036d 32 6e fe			ld (debug_mark),a  
0370 3a 7f 03			ld a, (.dmark+1)  
0373 32 6f fe			ld (debug_mark+1),a  
0376 3a 80 03			ld a, (.dmark+2)  
0379 32 70 fe			ld (debug_mark+2),a  
037c 18 03			jr .pastdmark  
037e ..			.dmark: db "SGc"  
0381 f1			.pastdmark: pop af  
0382			endm  
# End of macro DMARK
0382					CALLMONITOR 
0382 cd fb 19			call break_point_state  
0385				endm  
# End of macro CALLMONITOR
0385				endif 
0385 60			.getloop:	ld h, b 
0386 2e 00				ld l, 0 
0388 c5					push bc 
0389			 
0389 11 7d fa				ld de, store_page 
038c				if DEBUG_STORESE 
038c					DMARK "SGr" 
038c f5				push af  
038d 3a a1 03			ld a, (.dmark)  
0390 32 6e fe			ld (debug_mark),a  
0393 3a a2 03			ld a, (.dmark+1)  
0396 32 6f fe			ld (debug_mark+1),a  
0399 3a a3 03			ld a, (.dmark+2)  
039c 32 70 fe			ld (debug_mark+2),a  
039f 18 03			jr .pastdmark  
03a1 ..			.dmark: db "SGr"  
03a4 f1			.pastdmark: pop af  
03a5			endm  
# End of macro DMARK
03a5					CALLMONITOR 
03a5 cd fb 19			call break_point_state  
03a8				endm  
# End of macro CALLMONITOR
03a8				endif 
03a8 cd 75 09				call storage_read 
03ab cd af 0f				call ishlzero 
03ae 28 2d				jr z, .gap 
03b0					 
03b0					; have a file name read. Is it one we want. 
03b0			 
03b0 2a 76 fa				ld hl, (store_tmp1) 
03b3 11 80 fa				ld de, store_page+3   ; file name 
03b6			 
03b6				if DEBUG_STORESE 
03b6					DMARK "SGc" 
03b6 f5				push af  
03b7 3a cb 03			ld a, (.dmark)  
03ba 32 6e fe			ld (debug_mark),a  
03bd 3a cc 03			ld a, (.dmark+1)  
03c0 32 6f fe			ld (debug_mark+1),a  
03c3 3a cd 03			ld a, (.dmark+2)  
03c6 32 70 fe			ld (debug_mark+2),a  
03c9 18 03			jr .pastdmark  
03cb ..			.dmark: db "SGc"  
03ce f1			.pastdmark: pop af  
03cf			endm  
# End of macro DMARK
03cf					CALLMONITOR 
03cf cd fb 19			call break_point_state  
03d2				endm  
# End of macro CALLMONITOR
03d2				endif 
03d2 cd 1c 14				call strcmp 
03d5 20 06				jr nz, .gap   ; not this one 
03d7			 
03d7 c1				        pop bc 
03d8			 
03d8 26 00				ld h, 0 
03da 68					ld l, b 
03db 18 22				jr .getdone 
03dd						 
03dd			 
03dd			 
03dd			 
03dd			.gap: 
03dd				if DEBUG_STORESE 
03dd					DMARK "SGg" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6e fe			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6f fe			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 70 fe			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SGg"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6					CALLMONITOR 
03f6 cd fb 19			call break_point_state  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 c1					pop bc 
03fa 10 89				djnz .getloop 
03fc 21 ff 00				ld hl, 255 
03ff			.getdone: 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGe" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 6e fe			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 6f fe			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 70 fe			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGe"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd fb 19			call break_point_state  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b			 
041b c9				ret 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			; Read Block 
041c			; ---------- 
041c			; 
041c			; With current bank 
041c			;  
041c			; Get block number to read 
041c			; Load physical blocks starting at start block into buffer 
041c			 
041c			; de points to buffer to use 
041c			; hl holds logical block number  
041c			 
041c			storage_read_block: 
041c			 
041c				; TODO bank selection 
041c			 
041c				; for each of the physical blocks read it into the buffer 
041c 06 40			ld b, STORE_BLOCK_PHY 
041e			 
041e				if DEBUG_STORESE 
041e d5					push de 
041f				endif 
041f				 
041f			.rl1:    
041f			 
041f				; read physical block at hl into de 
041f			        ; increment hl and de to next read position on exit 
041f			 
041f e5				push hl 
0420 d5				push de	 
0421 c5				push bc 
0422			;	if DEBUG_STORESE 
0422			;		push af 
0422			;		ld a, 'R' 
0422			;		ld (debug_mark),a 
0422			;		pop af 
0422			;		CALLMONITOR 
0422			;	endif 
0422 cd c3 02			call se_readbyte 
0425			;	if DEBUG_STORESE 
0425			;		ld a,(spi_portbyte) 
0425			;		ld l, a 
0425			;		push af 
0425			;		ld a, '1' 
0425			;		ld (debug_mark),a 
0425			;		pop af 
0425			;		CALLMONITOR 
0425			;	endif 
0425 c1				pop bc 
0426 d1				pop de 
0427 e1				pop hl 
0428 12				ld (de),a 
0429 23				inc hl 
042a 13				inc de 
042b			 
042b			;	if DEBUG_STORESE 
042b			;		push af 
042b			;		ld a, 'r' 
042b			;		ld (debug_mark),a 
042b			;		pop af 
042b			;		CALLMONITOR 
042b			;	endif 
042b			 
042b 10 f2			djnz .rl1 
042d			 
042d				if DEBUG_STORESE 
042d					DMARK "SRB" 
042d f5				push af  
042e 3a 42 04			ld a, (.dmark)  
0431 32 6e fe			ld (debug_mark),a  
0434 3a 43 04			ld a, (.dmark+1)  
0437 32 6f fe			ld (debug_mark+1),a  
043a 3a 44 04			ld a, (.dmark+2)  
043d 32 70 fe			ld (debug_mark+2),a  
0440 18 03			jr .pastdmark  
0442 ..			.dmark: db "SRB"  
0445 f1			.pastdmark: pop af  
0446			endm  
# End of macro DMARK
0446 d1					pop de 
0447			; 
0447			;		push af 
0447			;		ld a, 'R' 
0447			;		ld (debug_mark),a 
0447			;		pop af 
0447					CALLMONITOR 
0447 cd fb 19			call break_point_state  
044a				endm  
# End of macro CALLMONITOR
044a				endif 
044a c9				ret	 
044b				 
044b			 
044b			; File Size 
044b			; --------- 
044b			; 
044b			;   hl file id 
044b			; 
044b			;  returns in hl the number of blocks 
044b			 
044b			storage_file_size: 
044b 5d				ld e, l 
044c 16 00			ld d, 0 
044e 21 40 00			ld hl, STORE_BLOCK_PHY 
0451					if DEBUG_FORTH_WORDS 
0451						DMARK "SIZ" 
0451 f5				push af  
0452 3a 66 04			ld a, (.dmark)  
0455 32 6e fe			ld (debug_mark),a  
0458 3a 67 04			ld a, (.dmark+1)  
045b 32 6f fe			ld (debug_mark+1),a  
045e 3a 68 04			ld a, (.dmark+2)  
0461 32 70 fe			ld (debug_mark+2),a  
0464 18 03			jr .pastdmark  
0466 ..			.dmark: db "SIZ"  
0469 f1			.pastdmark: pop af  
046a			endm  
# End of macro DMARK
046a						CALLMONITOR 
046a cd fb 19			call break_point_state  
046d				endm  
# End of macro CALLMONITOR
046d					endif 
046d cd 4f 07			call storage_findnextid 
0470			 
0470 cd af 0f			call ishlzero 
0473			;	ld a, l 
0473			;	add h 
0473			;	cp 0 
0473 c8				ret z			; block not found so EOF 
0474			 
0474 11 7d fa			ld de, store_page 
0477 cd 1c 04			call storage_read_block 
047a			 
047a 3a 7f fa			ld a, (store_page+2)	 ; get extent count 
047d 6f				ld l, a 
047e 26 00			ld h, 0 
0480 c9			 	ret 
0481			 
0481			 
0481			; Write Block 
0481			; ----------- 
0481			; 
0481			; With current bank 
0481			;  
0481			; Get block number to write 
0481			; Write physical blocks starting at start block from buffer 
0481			  
0481			storage_write_block: 
0481				; TODO bank selection 
0481			 
0481				; for each of the physical blocks read it into the buffer 
0481 06 40			ld b, STORE_BLOCK_PHY 
0483			 
0483				if DEBUG_STORESE 
0483					DMARK "SWB" 
0483 f5				push af  
0484 3a 98 04			ld a, (.dmark)  
0487 32 6e fe			ld (debug_mark),a  
048a 3a 99 04			ld a, (.dmark+1)  
048d 32 6f fe			ld (debug_mark+1),a  
0490 3a 9a 04			ld a, (.dmark+2)  
0493 32 70 fe			ld (debug_mark+2),a  
0496 18 03			jr .pastdmark  
0498 ..			.dmark: db "SWB"  
049b f1			.pastdmark: pop af  
049c			endm  
# End of macro DMARK
049c			 
049c					;push af 
049c					;ld a, 'W' 
049c					;ld (debug_mark),a 
049c					;pop af 
049c					CALLMONITOR 
049c cd fb 19			call break_point_state  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f			 
049f			; might not be working 
049f			;	call se_writepage 
049f			 
049f			;	ret 
049f			; 
049f			 
049f			 
049f			 
049f			.wl1:    
049f			 
049f				; read physical block at hl into de 
049f			        ; increment hl and de to next read position on exit 
049f			 
049f e5				push hl 
04a0 d5				push de	 
04a1 c5				push bc 
04a2 1a				ld a,(de) 
04a3				;if DEBUG_STORESE 
04a3			;		push af 
04a3			;		ld a, 'W' 
04a3			;		ld (debug_mark),a 
04a3			;		pop af 
04a3			;		CALLMONITOR 
04a3			;	endif 
04a3 cd 21 02			call se_writebyte 
04a6			;	call delay250ms 
04a6 00				nop 
04a7 00				nop 
04a8 00				nop 
04a9			;	if DEBUG_STORESE 
04a9			;		push af 
04a9			;		ld a, 'w' 
04a9			;		ld (debug_mark),a 
04a9			;		pop af 
04a9			;		CALLMONITOR 
04a9			;	endif 
04a9 c1				pop bc 
04aa d1				pop de 
04ab e1				pop hl 
04ac 23				inc hl 
04ad 13				inc de 
04ae			 
04ae			 
04ae 10 ef			djnz .wl1 
04b0			 
04b0				if DEBUG_STORESE 
04b0					DMARK "SW2" 
04b0 f5				push af  
04b1 3a c5 04			ld a, (.dmark)  
04b4 32 6e fe			ld (debug_mark),a  
04b7 3a c6 04			ld a, (.dmark+1)  
04ba 32 6f fe			ld (debug_mark+1),a  
04bd 3a c7 04			ld a, (.dmark+2)  
04c0 32 70 fe			ld (debug_mark+2),a  
04c3 18 03			jr .pastdmark  
04c5 ..			.dmark: db "SW2"  
04c8 f1			.pastdmark: pop af  
04c9			endm  
# End of macro DMARK
04c9			 
04c9					;push af 
04c9					;ld a, 'W' 
04c9					;ld (debug_mark),a 
04c9					;pop af 
04c9					CALLMONITOR 
04c9 cd fb 19			call break_point_state  
04cc				endm  
# End of macro CALLMONITOR
04cc				endif 
04cc c9				ret	 
04cd			 
04cd			; Init bank 
04cd			; --------- 
04cd			; 
04cd			; With current bank 
04cd			; 
04cd			; Setup block 0 config 
04cd			;     Set 0 file id counter 
04cd			;     Set formatted byte pattern 
04cd			;     Zero out bank label 
04cd			;      
04cd			; For every logical block write 0-1 byte as null 
04cd			 
04cd			storage_get_block_0: 
04cd			 
04cd				; TODO check presence 
04cd			 
04cd				; get block 0 config 
04cd			 
04cd 21 00 00			ld hl, 0 
04d0 11 7d fa			ld de, store_page 
04d3 cd 1c 04			call storage_read_block 
04d6			 
04d6				if DEBUG_STORESE 
04d6					DMARK "SB0" 
04d6 f5				push af  
04d7 3a eb 04			ld a, (.dmark)  
04da 32 6e fe			ld (debug_mark),a  
04dd 3a ec 04			ld a, (.dmark+1)  
04e0 32 6f fe			ld (debug_mark+1),a  
04e3 3a ed 04			ld a, (.dmark+2)  
04e6 32 70 fe			ld (debug_mark+2),a  
04e9 18 03			jr .pastdmark  
04eb ..			.dmark: db "SB0"  
04ee f1			.pastdmark: pop af  
04ef			endm  
# End of macro DMARK
04ef 11 7d fa				ld de, store_page 
04f2			;		push af 
04f2			;		ld a, 'i' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2					CALLMONITOR 
04f2 cd fb 19			call break_point_state  
04f5				endm  
# End of macro CALLMONITOR
04f5				endif 
04f5			 
04f5				; is this area formatted? 
04f5			 
04f5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04f5 2a 7e fa			ld hl, (store_page+1) 
04f8 3e 80			ld a,0x80 
04fa bd				cp l 
04fb 20 22			jr nz, .ininotformatted 
04fd				; do a double check 
04fd 3e 27			ld a, 0x27 
04ff bc				cp h 
0500 20 1d			jr nz, .ininotformatted 
0502			 
0502				; formatted then 
0502			 
0502				if DEBUG_STORESE 
0502					DMARK "SB1" 
0502 f5				push af  
0503 3a 17 05			ld a, (.dmark)  
0506 32 6e fe			ld (debug_mark),a  
0509 3a 18 05			ld a, (.dmark+1)  
050c 32 6f fe			ld (debug_mark+1),a  
050f 3a 19 05			ld a, (.dmark+2)  
0512 32 70 fe			ld (debug_mark+2),a  
0515 18 03			jr .pastdmark  
0517 ..			.dmark: db "SB1"  
051a f1			.pastdmark: pop af  
051b			endm  
# End of macro DMARK
051b					;push af 
051b					;ld a, 'I' 
051b					;ld (debug_mark),a 
051b					;pop af 
051b					CALLMONITOR 
051b cd fb 19			call break_point_state  
051e				endm  
# End of macro CALLMONITOR
051e				endif 
051e c9				ret 
051f			 
051f			.ininotformatted: 
051f				; bank not formatted so poke various bits to make sure 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB2" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 6e fe			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 6f fe			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 70 fe			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB2"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538					;push af 
0538					;ld a, 'f' 
0538					;ld (debug_mark),a 
0538					;pop af 
0538					CALLMONITOR 
0538 cd fb 19			call break_point_state  
053b				endm  
# End of macro CALLMONITOR
053b				endif 
053b			 
053b cd 58 0c			call storage_clear_page 
053e			 
053e 21 7d fa			ld hl, store_page 
0541 3e 00			ld a, 0 
0543				 
0543 77				ld (hl),a   ; reset file counter 
0544			 
0544 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0547 22 7e fa		 	ld (store_page+1), hl	 
054a			 
054a				; set default label 
054a			 
054a 21 e6 05			ld hl, .defaultbanklabl 
054d 11 80 fa		 	ld de, store_page+3 
0550 01 0f 00			ld bc, 15 
0553 ed b0			ldir 
0555			 
0555				; Append the current bank id 
0555 21 89 fa			ld hl, store_page+3+9 
0558 3a 62 fa			ld a, (spi_device_id) 
055b 77				ld (hl), a 
055c			 
055c				; save default page 0 
055c			 
055c 21 00 00			ld hl, 0 
055f 11 7d fa			ld de, store_page 
0562				if DEBUG_STORESE 
0562					DMARK "SB3" 
0562 f5				push af  
0563 3a 77 05			ld a, (.dmark)  
0566 32 6e fe			ld (debug_mark),a  
0569 3a 78 05			ld a, (.dmark+1)  
056c 32 6f fe			ld (debug_mark+1),a  
056f 3a 79 05			ld a, (.dmark+2)  
0572 32 70 fe			ld (debug_mark+2),a  
0575 18 03			jr .pastdmark  
0577 ..			.dmark: db "SB3"  
057a f1			.pastdmark: pop af  
057b			endm  
# End of macro DMARK
057b			;		push af 
057b			;		ld a, 'F' 
057b			;		ld (debug_mark),a 
057b			;		pop af 
057b					CALLMONITOR 
057b cd fb 19			call break_point_state  
057e				endm  
# End of macro CALLMONITOR
057e				endif 
057e cd 81 04			call storage_write_block 
0581				if DEBUG_STORESE 
0581					DMARK "SB4" 
0581 f5				push af  
0582 3a 96 05			ld a, (.dmark)  
0585 32 6e fe			ld (debug_mark),a  
0588 3a 97 05			ld a, (.dmark+1)  
058b 32 6f fe			ld (debug_mark+1),a  
058e 3a 98 05			ld a, (.dmark+2)  
0591 32 70 fe			ld (debug_mark+2),a  
0594 18 03			jr .pastdmark  
0596 ..			.dmark: db "SB4"  
0599 f1			.pastdmark: pop af  
059a			endm  
# End of macro DMARK
059a			;		push af 
059a			;		ld a, '>' 
059a			;		ld (debug_mark),a 
059a			;		pop af 
059a					CALLMONITOR 
059a cd fb 19			call break_point_state  
059d				endm  
# End of macro CALLMONITOR
059d				endif 
059d			 
059d 00				nop 
059e 00				nop 
059f 00				nop 
05a0			 
05a0				; now set 0 in every page to mark as a free block 
05a0			 
05a0 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05a2 21 40 00			ld hl, STORE_BLOCK_PHY 
05a5			 
05a5 3e 00		.setmark1:   	ld a,0 
05a7 e5					push hl 
05a8 c5					push bc 
05a9 cd 21 02				call se_writebyte 
05ac 3e 0a			ld a, 10 
05ae cd 7a 0c			call aDelayInMS 
05b1 23				inc hl 
05b2 cd 21 02				call se_writebyte 
05b5 3e 0a			ld a, 10 
05b7 cd 7a 0c			call aDelayInMS 
05ba 2b				dec hl 
05bb c1					pop bc 
05bc e1					pop hl 
05bd 3e 40				ld a, STORE_BLOCK_PHY 
05bf cd 86 0f				call addatohl 
05c2 10 e1				djnz .setmark1 
05c4			 
05c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c6 3e 00		.setmark2:   	ld a,0 
05c8 e5					push hl 
05c9 c5					push bc 
05ca cd 21 02				call se_writebyte 
05cd 3e 0a			ld a, 10 
05cf cd 7a 0c			call aDelayInMS 
05d2 23				inc hl 
05d3 cd 21 02				call se_writebyte 
05d6 3e 0a			ld a, 10 
05d8 cd 7a 0c			call aDelayInMS 
05db 2b				dec hl 
05dc c1					pop bc 
05dd e1					pop hl 
05de 3e 40				ld a, STORE_BLOCK_PHY 
05e0 cd 86 0f				call addatohl 
05e3 10 e1				djnz .setmark2 
05e5			 
05e5					 
05e5			 
05e5			 
05e5 c9				ret 
05e6			 
05e6			 
05e6			 
05e6			 
05e6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
05f1			 
05f1			 
05f1			 
05f1			; Label Bank 
05f1			; ---------- 
05f1			; 
05f1			; With current bank 
05f1			; Read block 0 
05f1			; Set label 
05f1			; Write block 0 
05f1			 
05f1			; label str pointer in hl 
05f1			 
05f1			storage_label:     
05f1			 
05f1				if DEBUG_STORESE 
05f1					DMARK "LBL" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 6e fe			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 6f fe			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 70 fe			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "LBL"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd fb 19			call break_point_state  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d			 
060d e5				push hl 
060e			 
060e cd cd 04			call storage_get_block_0 
0611			 
0611				; set default label 
0611			 
0611 e1				pop hl 
0612			 
0612 11 80 fa		 	ld de, store_page+3 
0615 01 0f 00			ld bc, 15 
0618				if DEBUG_STORESE 
0618					DMARK "LB3" 
0618 f5				push af  
0619 3a 2d 06			ld a, (.dmark)  
061c 32 6e fe			ld (debug_mark),a  
061f 3a 2e 06			ld a, (.dmark+1)  
0622 32 6f fe			ld (debug_mark+1),a  
0625 3a 2f 06			ld a, (.dmark+2)  
0628 32 70 fe			ld (debug_mark+2),a  
062b 18 03			jr .pastdmark  
062d ..			.dmark: db "LB3"  
0630 f1			.pastdmark: pop af  
0631			endm  
# End of macro DMARK
0631					CALLMONITOR 
0631 cd fb 19			call break_point_state  
0634				endm  
# End of macro CALLMONITOR
0634				endif 
0634 ed b0			ldir 
0636				; save default page 0 
0636			 
0636 21 00 00			ld hl, 0 
0639 11 7d fa			ld de, store_page 
063c				if DEBUG_STORESE 
063c					DMARK "LBW" 
063c f5				push af  
063d 3a 51 06			ld a, (.dmark)  
0640 32 6e fe			ld (debug_mark),a  
0643 3a 52 06			ld a, (.dmark+1)  
0646 32 6f fe			ld (debug_mark+1),a  
0649 3a 53 06			ld a, (.dmark+2)  
064c 32 70 fe			ld (debug_mark+2),a  
064f 18 03			jr .pastdmark  
0651 ..			.dmark: db "LBW"  
0654 f1			.pastdmark: pop af  
0655			endm  
# End of macro DMARK
0655					CALLMONITOR 
0655 cd fb 19			call break_point_state  
0658				endm  
# End of macro CALLMONITOR
0658				endif 
0658 cd 81 04			call storage_write_block 
065b			 
065b c9				ret 
065c			 
065c			 
065c			 
065c			; Read Block 0 - Config 
065c			; --------------------- 
065c			; 
065c			; With current bank 
065c			; Call presence test 
065c			;    If not present format/init bank  
065c			; Read block 0  
065c			;  
065c			 
065c			 
065c			; Dir 
065c			; --- 
065c			; 
065c			; With current bank 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block read byte 2 
065c			;      if first block of file 
065c			;         Display file name 
065c			;         Display type flags for file 
065c			;        
065c			 
065c			; moving to words as this requires stack control 
065c			 
065c			 
065c			; Delete File 
065c			; ----------- 
065c			; 
065c			; With current bank 
065c			; 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block file id 
065c			;      If first block of file and dont have file id 
065c			;         if file to delete 
065c			;         Save file id 
065c			;         Null file id 
065c			;         Write this block back 
065c			;      If file id is one saved 
065c			;         Null file id 
065c			;         Write this block back 
065c			 
065c			 
065c			.se_done: 
065c e1				pop hl 
065d c9				ret 
065e			 
065e			storage_erase: 
065e			 
065e				; hl contains the file id 
065e			 
065e 5d				ld e, l 
065f 16 00			ld d, 0 
0661 21 40 00			ld hl, STORE_BLOCK_PHY 
0664					if DEBUG_FORTH_WORDS 
0664						DMARK "ERA" 
0664 f5				push af  
0665 3a 79 06			ld a, (.dmark)  
0668 32 6e fe			ld (debug_mark),a  
066b 3a 7a 06			ld a, (.dmark+1)  
066e 32 6f fe			ld (debug_mark+1),a  
0671 3a 7b 06			ld a, (.dmark+2)  
0674 32 70 fe			ld (debug_mark+2),a  
0677 18 03			jr .pastdmark  
0679 ..			.dmark: db "ERA"  
067c f1			.pastdmark: pop af  
067d			endm  
# End of macro DMARK
067d						CALLMONITOR 
067d cd fb 19			call break_point_state  
0680				endm  
# End of macro CALLMONITOR
0680					endif 
0680 cd 4f 07			call storage_findnextid 
0683 cd af 0f			call ishlzero 
0686 c8				ret z 
0687			 
0687 e5				push hl 
0688			 
0688				; TODO check file not found 
0688			 
0688 11 7d fa			ld de, store_page 
068b cd 1c 04			call storage_read_block 
068e			 
068e cd af 0f			call ishlzero 
0691 ca 5c 06			jp z,.se_done 
0694			 
0694					if DEBUG_FORTH_WORDS 
0694						DMARK "ER1" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 6e fe			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 6f fe			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 70 fe			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "ER1"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad						CALLMONITOR 
06ad cd fb 19			call break_point_state  
06b0				endm  
# End of macro CALLMONITOR
06b0					endif 
06b0 3a 7d fa			ld a, (store_page)	; get file id 
06b3 32 71 fa			ld (store_tmpid), a 
06b6			 
06b6 3a 7f fa			ld a, (store_page+2)    ; get count of extends 
06b9 32 70 fa			ld (store_tmpext), a 
06bc			 
06bc				; wipe file header 
06bc			 
06bc e1				pop hl 
06bd 3e 00			ld a, 0 
06bf 32 7d fa			ld (store_page), a 
06c2 32 7e fa			ld (store_page+1),a 
06c5 11 7d fa			ld de, store_page 
06c8					if DEBUG_FORTH_WORDS 
06c8						DMARK "ER2" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 6e fe			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 6f fe			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 70 fe			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "ER2"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1						CALLMONITOR 
06e1 cd fb 19			call break_point_state  
06e4				endm  
# End of macro CALLMONITOR
06e4					endif 
06e4 cd 81 04			call storage_write_block 
06e7			 
06e7			 
06e7				; wipe file extents 
06e7			 
06e7 3a 70 fa			ld a, (store_tmpext) 
06ea 47				ld b, a 
06eb			 
06eb			.eraext:	  
06eb c5				push bc 
06ec			 
06ec 21 40 00			ld hl, STORE_BLOCK_PHY 
06ef 3a 71 fa			ld a,(store_tmpid) 
06f2 5f				ld e, a 
06f3 50				ld d, b	 
06f4					if DEBUG_FORTH_WORDS 
06f4						DMARK "ER3" 
06f4 f5				push af  
06f5 3a 09 07			ld a, (.dmark)  
06f8 32 6e fe			ld (debug_mark),a  
06fb 3a 0a 07			ld a, (.dmark+1)  
06fe 32 6f fe			ld (debug_mark+1),a  
0701 3a 0b 07			ld a, (.dmark+2)  
0704 32 70 fe			ld (debug_mark+2),a  
0707 18 03			jr .pastdmark  
0709 ..			.dmark: db "ER3"  
070c f1			.pastdmark: pop af  
070d			endm  
# End of macro DMARK
070d						CALLMONITOR 
070d cd fb 19			call break_point_state  
0710				endm  
# End of macro CALLMONITOR
0710					endif 
0710 cd 4f 07			call storage_findnextid 
0713 cd af 0f			call ishlzero 
0716 ca 5c 06			jp z,.se_done 
0719			 
0719 e5				push hl 
071a 11 7d fa			ld de, store_page 
071d cd 1c 04			call storage_read_block 
0720			 
0720				; free block	 
0720			 
0720 3e 00			ld a, 0 
0722 32 7d fa			ld (store_page), a 
0725 32 7e fa			ld (store_page+1),a 
0728 11 7d fa			ld de, store_page 
072b e1				pop hl 
072c					if DEBUG_FORTH_WORDS 
072c						DMARK "ER4" 
072c f5				push af  
072d 3a 41 07			ld a, (.dmark)  
0730 32 6e fe			ld (debug_mark),a  
0733 3a 42 07			ld a, (.dmark+1)  
0736 32 6f fe			ld (debug_mark+1),a  
0739 3a 43 07			ld a, (.dmark+2)  
073c 32 70 fe			ld (debug_mark+2),a  
073f 18 03			jr .pastdmark  
0741 ..			.dmark: db "ER4"  
0744 f1			.pastdmark: pop af  
0745			endm  
# End of macro DMARK
0745						CALLMONITOR 
0745 cd fb 19			call break_point_state  
0748				endm  
# End of macro CALLMONITOR
0748					endif 
0748 cd 81 04			call storage_write_block 
074b			 
074b c1				pop bc 
074c 10 9d			djnz .eraext 
074e			 
074e c9				ret 
074f			 
074f			 
074f			; Find Free Block 
074f			; --------------- 
074f			; 
074f			; With current bank 
074f			;  
074f			; From given starting logical block 
074f			;    Read block  
074f			;    If no file id 
074f			;         Return block id 
074f			 
074f			 
074f			; hl starting page number 
074f			; hl contains free page number or zero if no pages free 
074f			; e contains the file id to locate 
074f			; d contains the block number 
074f			 
074f			; TODO change to find file id and use zero for free block 
074f			 
074f			storage_findnextid: 
074f			 
074f				; now locate first 0 page to mark as a free block 
074f			 
074f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0751			;	ld hl, STORE_BLOCK_PHY 
0751			 
0751					if DEBUG_FORTH_WORDS 
0751					DMARK "FNI" 
0751 f5				push af  
0752 3a 66 07			ld a, (.dmark)  
0755 32 6e fe			ld (debug_mark),a  
0758 3a 67 07			ld a, (.dmark+1)  
075b 32 6f fe			ld (debug_mark+1),a  
075e 3a 68 07			ld a, (.dmark+2)  
0761 32 70 fe			ld (debug_mark+2),a  
0764 18 03			jr .pastdmark  
0766 ..			.dmark: db "FNI"  
0769 f1			.pastdmark: pop af  
076a			endm  
# End of macro DMARK
076a						CALLMONITOR 
076a cd fb 19			call break_point_state  
076d				endm  
# End of macro CALLMONITOR
076d					endif 
076d			.ff1:   	 
076d e5					push hl 
076e c5					push bc 
076f d5					push de 
0770 cd c3 02				call se_readbyte 
0773 5f					ld e,a 
0774 23					inc hl 
0775 cd c3 02				call se_readbyte 
0778 57					ld d, a 
0779 e1					pop hl 
077a e5					push hl 
077b cd a4 0f				call cmp16 
077e 28 49				jr z, .fffound 
0780			 
0780 d1					pop de 
0781 c1					pop bc 
0782 e1					pop hl 
0783			 
0783					; is found? 
0783					;cp e 
0783					;ret z 
0783			 
0783 3e 40				ld a, STORE_BLOCK_PHY 
0785 cd 86 0f				call addatohl 
0788 10 e3				djnz .ff1 
078a			 
078a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
078c			.ff2:   	 
078c			 
078c e5					push hl 
078d c5					push bc 
078e d5					push de 
078f cd c3 02				call se_readbyte 
0792 5f					ld e,a 
0793 23					inc hl 
0794 cd c3 02				call se_readbyte 
0797 57					ld d, a 
0798			 
0798 e1					pop hl 
0799 e5					push hl 
079a cd a4 0f				call cmp16 
079d 28 2a				jr z, .fffound 
079f			 
079f d1					pop de 
07a0 c1					pop bc 
07a1 e1					pop hl 
07a2					; is found? 
07a2					;cp e 
07a2					;ret z 
07a2			 
07a2 3e 40				ld a, STORE_BLOCK_PHY 
07a4 cd 86 0f				call addatohl 
07a7 10 e3				djnz .ff2 
07a9			 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FN-" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 6e fe			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 6f fe			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 70 fe			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FN-"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2					;	push af 
07c2					;	ld a, 'n' 
07c2					;	ld (debug_mark),a 
07c2					;	pop af 
07c2						CALLMONITOR 
07c2 cd fb 19			call break_point_state  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5				; no free marks! 
07c5 21 00 00				ld hl, 0 
07c8 c9				ret 
07c9			.fffound: 
07c9				 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc					if DEBUG_FORTH_WORDS 
07cc					DMARK "FNF" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 6e fe			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 6f fe			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 70 fe			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "FNF"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;	push af 
07e5					;	ld a, 'n' 
07e5					;	ld (debug_mark),a 
07e5					;	pop af 
07e5						CALLMONITOR 
07e5 cd fb 19			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8					endif 
07e8 c9				ret 
07e9			 
07e9			 
07e9			 
07e9			; Free Space 
07e9			; ---------- 
07e9			; 
07e9			; With current bank 
07e9			; 
07e9			; Set block count to zero 
07e9			; Starting with first logical block 
07e9			;      Find free block  
07e9			;      If block id given, increment block count 
07e9			; 
07e9			;  
07e9			 
07e9			 
07e9			; hl contains count of free blocks 
07e9			 
07e9			storage_freeblocks: 
07e9			 
07e9				; now locate first 0 page to mark as a free block 
07e9			 
07e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07eb 21 40 00			ld hl, STORE_BLOCK_PHY 
07ee 11 00 00			ld de, 0 
07f1			 
07f1			.fb1:   	 
07f1 e5					push hl 
07f2 c5					push bc 
07f3 d5					push de 
07f4 cd c3 02				call se_readbyte 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa			 
07fa					; is free? 
07fa fe 00				cp 0 
07fc 20 01				jr nz, .ff1cont 
07fe 13					inc de 
07ff			 
07ff			.ff1cont: 
07ff			 
07ff			 
07ff 3e 40				ld a, STORE_BLOCK_PHY 
0801 cd 86 0f				call addatohl 
0804 10 eb				djnz .fb1 
0806			 
0806 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0808			.fb2:   	 
0808 e5					push hl 
0809 c5					push bc 
080a d5					push de 
080b cd c3 02				call se_readbyte 
080e d1					pop de 
080f c1					pop bc 
0810 e1					pop hl 
0811			 
0811					; is free? 
0811 fe 00				cp 0 
0813 20 01				jr nz, .ff2cont 
0815 13					inc de 
0816			 
0816			.ff2cont: 
0816			 
0816 3e 40				ld a, STORE_BLOCK_PHY 
0818 cd 86 0f				call addatohl 
081b 10 eb				djnz .fb2 
081d			 
081d eb				ex de, hl 
081e c9				ret 
081f			 
081f			; Get File ID 
081f			; ----------- 
081f			; 
081f			; With current bank 
081f			;  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; For each logical block 
081f			;    Read block file id 
081f			;      If first block of file and dont have file id 
081f			;         if file get id and exit 
081f			 
081f			 
081f			 
081f			 
081f			; Create File 
081f			; ----------- 
081f			; 
081f			; With current bank  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; Increment file id number 
081f			; Save Config 
081f			; Find free block 
081f			; Set buffer with file name and file id 
081f			; Write buffer to free block  
081f			 
081f			 
081f			; hl point to file name 
081f			; hl returns file id 
081f			 
081f			; file format: 
081f			; byte 0 - file id 
081f			; byte 1 - extent number 
081f			; byte 2-> data 
081f			 
081f			; format for extent number 0: 
081f			; 
081f			; byte 0 - file id 
081f			; byte 1 - extent 0 
081f			; byte 2 - extent count 
081f			; byte 3 -> file name and meta data 
081f			 
081f			 
081f			storage_create: 
081f				if DEBUG_STORESE 
081f					DMARK "SCR" 
081f f5				push af  
0820 3a 34 08			ld a, (.dmark)  
0823 32 6e fe			ld (debug_mark),a  
0826 3a 35 08			ld a, (.dmark+1)  
0829 32 6f fe			ld (debug_mark+1),a  
082c 3a 36 08			ld a, (.dmark+2)  
082f 32 70 fe			ld (debug_mark+2),a  
0832 18 03			jr .pastdmark  
0834 ..			.dmark: db "SCR"  
0837 f1			.pastdmark: pop af  
0838			endm  
# End of macro DMARK
0838					CALLMONITOR 
0838 cd fb 19			call break_point_state  
083b				endm  
# End of macro CALLMONITOR
083b				endif 
083b			 
083b e5				push hl		; save file name pointer 
083c			 
083c cd cd 04			call storage_get_block_0 
083f			 
083f 3a 7d fa			ld a,(store_page)	; get current file id 
0842 3c				inc a 
0843 32 7d fa			ld (store_page),a 
0846				 
0846 32 71 fa			ld (store_tmpid),a			; save id 
0849			 
0849 21 00 00			ld hl, 0 
084c 11 7d fa			ld de, store_page 
084f				if DEBUG_STORESE 
084f					DMARK "SCw" 
084f f5				push af  
0850 3a 64 08			ld a, (.dmark)  
0853 32 6e fe			ld (debug_mark),a  
0856 3a 65 08			ld a, (.dmark+1)  
0859 32 6f fe			ld (debug_mark+1),a  
085c 3a 66 08			ld a, (.dmark+2)  
085f 32 70 fe			ld (debug_mark+2),a  
0862 18 03			jr .pastdmark  
0864 ..			.dmark: db "SCw"  
0867 f1			.pastdmark: pop af  
0868			endm  
# End of macro DMARK
0868					CALLMONITOR 
0868 cd fb 19			call break_point_state  
086b				endm  
# End of macro CALLMONITOR
086b				endif 
086b cd 81 04			call storage_write_block	 ; save update 
086e			 
086e				if DEBUG_STORESE 
086e 11 7d fa				ld de, store_page 
0871					DMARK "SCC" 
0871 f5				push af  
0872 3a 86 08			ld a, (.dmark)  
0875 32 6e fe			ld (debug_mark),a  
0878 3a 87 08			ld a, (.dmark+1)  
087b 32 6f fe			ld (debug_mark+1),a  
087e 3a 88 08			ld a, (.dmark+2)  
0881 32 70 fe			ld (debug_mark+2),a  
0884 18 03			jr .pastdmark  
0886 ..			.dmark: db "SCC"  
0889 f1			.pastdmark: pop af  
088a			endm  
# End of macro DMARK
088a					CALLMONITOR 
088a cd fb 19			call break_point_state  
088d				endm  
# End of macro CALLMONITOR
088d				endif 
088d				;  
088d				 
088d 21 40 00			ld hl, STORE_BLOCK_PHY 
0890 11 00 00			ld de, 0 
0893 cd 4f 07			call storage_findnextid 
0896			 
0896 22 68 fa			ld (store_tmppageid), hl    ; save page to use  
0899			 
0899				; TODO detect 0 = no spare blocks 
0899			 
0899				; hl now contains the free page to use for the file header page 
0899			 
0899				if DEBUG_STORESE 
0899				DMARK "SCF" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 6e fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 6f fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 70 fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCF"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd fb 19			call break_point_state  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5			 
08b5 22 68 fa			ld (store_tmppageid), hl 
08b8				 
08b8 3a 71 fa			ld a,(store_tmpid)    ; get file id 
08bb			;	ld a, (store_filecache)			; save to cache 
08bb			 
08bb 32 7d fa			ld (store_page),a    ; set page id 
08be 3e 00			ld a, 0			 ; extent 0 is file header 
08c0 32 7e fa			ld (store_page+1), a   ; set file extent 
08c3			 
08c3 32 7f fa			ld (store_page+2), a   ; extent count for the file 
08c6			 
08c6			;	inc hl 		; init block 0 of file 
08c6			;	inc hl   		; skip file and extent id 
08c6			 ;       ld a, 0 
08c6			;	ld (hl),a 
08c6			;	ld a, (store_filecache+1)  	; save to cache 
08c6			 
08c6			;	inc hl    ; file name 
08c6				 
08c6				 
08c6 11 80 fa			ld de, store_page+3    ; get buffer for term string to use as file name 
08c9				if DEBUG_STORESE 
08c9					DMARK "SCc" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 6e fe			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 6f fe			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 70 fe			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCc"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd fb 19			call break_point_state  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5 e1				pop hl    ; get zero term string 
08e6 e5				push hl 
08e7 3e 00			ld a, 0 
08e9 cd ef 13			call strlent 
08ec 23				inc hl   ; cover zero term 
08ed 06 00			ld b,0 
08ef 4d				ld c,l 
08f0 e1				pop hl 
08f1				;ex de, hl 
08f1				if DEBUG_STORESE 
08f1					DMARK "SCa" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 6e fe			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 6f fe			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 70 fe			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCa"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					;push af 
090a					;ld a, 'a' 
090a					;ld (debug_mark),a 
090a					;pop af 
090a					CALLMONITOR 
090a cd fb 19			call break_point_state  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d ed b0			ldir    ; copy zero term string 
090f				if DEBUG_STORESE 
090f					DMARK "SCA" 
090f f5				push af  
0910 3a 24 09			ld a, (.dmark)  
0913 32 6e fe			ld (debug_mark),a  
0916 3a 25 09			ld a, (.dmark+1)  
0919 32 6f fe			ld (debug_mark+1),a  
091c 3a 26 09			ld a, (.dmark+2)  
091f 32 70 fe			ld (debug_mark+2),a  
0922 18 03			jr .pastdmark  
0924 ..			.dmark: db "SCA"  
0927 f1			.pastdmark: pop af  
0928			endm  
# End of macro DMARK
0928					CALLMONITOR 
0928 cd fb 19			call break_point_state  
092b				endm  
# End of macro CALLMONITOR
092b				endif 
092b			 
092b				; write file header page 
092b			 
092b 2a 68 fa			ld hl,(store_tmppageid) 
092e 11 7d fa			ld de, store_page 
0931				if DEBUG_STORESE 
0931					DMARK "SCb" 
0931 f5				push af  
0932 3a 46 09			ld a, (.dmark)  
0935 32 6e fe			ld (debug_mark),a  
0938 3a 47 09			ld a, (.dmark+1)  
093b 32 6f fe			ld (debug_mark+1),a  
093e 3a 48 09			ld a, (.dmark+2)  
0941 32 70 fe			ld (debug_mark+2),a  
0944 18 03			jr .pastdmark  
0946 ..			.dmark: db "SCb"  
0949 f1			.pastdmark: pop af  
094a			endm  
# End of macro DMARK
094a					;push af 
094a					;ld a, 'b' 
094a					;ld (debug_mark),a 
094a					;pop af 
094a					CALLMONITOR 
094a cd fb 19			call break_point_state  
094d				endm  
# End of macro CALLMONITOR
094d				endif 
094d cd 81 04			call storage_write_block 
0950			 
0950 3a 71 fa			ld a, (store_tmpid) 
0953 6f				ld l, a 
0954 26 00			ld h,0 
0956				if DEBUG_STORESE 
0956					DMARK "SCz" 
0956 f5				push af  
0957 3a 6b 09			ld a, (.dmark)  
095a 32 6e fe			ld (debug_mark),a  
095d 3a 6c 09			ld a, (.dmark+1)  
0960 32 6f fe			ld (debug_mark+1),a  
0963 3a 6d 09			ld a, (.dmark+2)  
0966 32 70 fe			ld (debug_mark+2),a  
0969 18 03			jr .pastdmark  
096b ..			.dmark: db "SCz"  
096e f1			.pastdmark: pop af  
096f			endm  
# End of macro DMARK
096f					CALLMONITOR 
096f cd fb 19			call break_point_state  
0972				endm  
# End of macro CALLMONITOR
0972				endif 
0972 c9				ret 
0973				 
0973			 
0973			 
0973			; 
0973			; Read File 
0973			; 
0973			; h - file id to locate 
0973			; l - extent to locate 
0973			; de - pointer to string to read into 
0973			; 
0973			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0973			 
0973			.sr_fail: 
0973 d1				pop de 
0974 c9				ret 
0975			 
0975			storage_read: 
0975			 
0975			 
0975 d5				push de 
0976			 
0976			; TODO BUG the above push is it popped before the RET Z? 
0976			 
0976			; TODO how to handle multiple part blocks 
0976			 
0976				; locate file extent to read 
0976			 
0976 5c				ld e, h 
0977 55				ld d, l 
0978			 
0978			.srext: 
0978 22 7b fa			ld (store_readptr), hl     ; save the current extent to load 
097b ed 53 79 fa		ld (store_readbuf), de     ; save the current buffer to load in to 
097f			 
097f 21 40 00			ld hl, STORE_BLOCK_PHY 
0982				if DEBUG_STORESE 
0982					DMARK "sre" 
0982 f5				push af  
0983 3a 97 09			ld a, (.dmark)  
0986 32 6e fe			ld (debug_mark),a  
0989 3a 98 09			ld a, (.dmark+1)  
098c 32 6f fe			ld (debug_mark+1),a  
098f 3a 99 09			ld a, (.dmark+2)  
0992 32 70 fe			ld (debug_mark+2),a  
0995 18 03			jr .pastdmark  
0997 ..			.dmark: db "sre"  
099a f1			.pastdmark: pop af  
099b			endm  
# End of macro DMARK
099b					CALLMONITOR 
099b cd fb 19			call break_point_state  
099e				endm  
# End of macro CALLMONITOR
099e				endif 
099e cd 4f 07			call storage_findnextid 
09a1			 
09a1				if DEBUG_STORESE 
09a1					DMARK "srf" 
09a1 f5				push af  
09a2 3a b6 09			ld a, (.dmark)  
09a5 32 6e fe			ld (debug_mark),a  
09a8 3a b7 09			ld a, (.dmark+1)  
09ab 32 6f fe			ld (debug_mark+1),a  
09ae 3a b8 09			ld a, (.dmark+2)  
09b1 32 70 fe			ld (debug_mark+2),a  
09b4 18 03			jr .pastdmark  
09b6 ..			.dmark: db "srf"  
09b9 f1			.pastdmark: pop af  
09ba			endm  
# End of macro DMARK
09ba					CALLMONITOR 
09ba cd fb 19			call break_point_state  
09bd				endm  
# End of macro CALLMONITOR
09bd				endif 
09bd cd af 0f			call ishlzero 
09c0			;	ld a, l 
09c0			;	add h 
09c0			;	cp 0 
09c0 28 b1			jr z,.sr_fail			; block not found so EOF 
09c2			 
09c2				; save current address for use by higher level words etc 
09c2			 
09c2 22 6e fa			ld (store_openaddr),hl 
09c5			 
09c5			 
09c5				; hl contains page number to load 
09c5 d1				pop de   ; get storage 
09c6 ed 53 79 fa		ld (store_readbuf), de     ; current buffer to load in to 
09ca d5				push de 
09cb				if DEBUG_STORESE 
09cb					DMARK "srg" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 6e fe			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 6f fe			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 70 fe			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "srg"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd fb 19			call break_point_state  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 1c 04			call storage_read_block 
09ea			 
09ea				; if this a continuation read??? 
09ea			 
09ea 2a 79 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09ed			 
09ed 3e 3f			ld a, STORE_BLOCK_PHY-1 
09ef cd 86 0f			call addatohl 
09f2 7e				ld a,(hl) 
09f3 fe 00			cp 0 
09f5 28 02			jr z, .markiscont 
09f7 3e ff			ld a, 255 
09f9			 
09f9			.markiscont: 
09f9 32 70 fa			ld (store_readcont), a 
09fc			 
09fc				if DEBUG_STORESE 
09fc					DMARK "srC" 
09fc f5				push af  
09fd 3a 11 0a			ld a, (.dmark)  
0a00 32 6e fe			ld (debug_mark),a  
0a03 3a 12 0a			ld a, (.dmark+1)  
0a06 32 6f fe			ld (debug_mark+1),a  
0a09 3a 13 0a			ld a, (.dmark+2)  
0a0c 32 70 fe			ld (debug_mark+2),a  
0a0f 18 03			jr .pastdmark  
0a11 ..			.dmark: db "srC"  
0a14 f1			.pastdmark: pop af  
0a15			endm  
# End of macro DMARK
0a15					CALLMONITOR 
0a15 cd fb 19			call break_point_state  
0a18				endm  
# End of macro CALLMONITOR
0a18				endif 
0a18				; only short reads enabled 
0a18			 
0a18 3a 78 fa			ld a, (store_longread) 
0a1b fe 00			cp 0 
0a1d ca ea 0a			jp z, .readdone 
0a20			 
0a20			; TODO if block has no zeros then need to read next block  
0a20			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a20			; check last byte of physical block. 
0a20			; if not zero then the next block needs to be loaded 
0a20			 
0a20			 
0a20 2a 79 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a23			 
0a23 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a25 cd 86 0f			call addatohl 
0a28				;dec hl 
0a28 7e				ld a,(hl) 
0a29				if DEBUG_STORESE 
0a29					DMARK "sr?" 
0a29 f5				push af  
0a2a 3a 3e 0a			ld a, (.dmark)  
0a2d 32 6e fe			ld (debug_mark),a  
0a30 3a 3f 0a			ld a, (.dmark+1)  
0a33 32 6f fe			ld (debug_mark+1),a  
0a36 3a 40 0a			ld a, (.dmark+2)  
0a39 32 70 fe			ld (debug_mark+2),a  
0a3c 18 03			jr .pastdmark  
0a3e ..			.dmark: db "sr?"  
0a41 f1			.pastdmark: pop af  
0a42			endm  
# End of macro DMARK
0a42					CALLMONITOR 
0a42 cd fb 19			call break_point_state  
0a45				endm  
# End of macro CALLMONITOR
0a45				endif 
0a45 fe 00			cp 0 
0a47 ca ea 0a			jp z, .readdone 
0a4a			 
0a4a				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a4a			 
0a4a 23				inc hl 
0a4b			 
0a4b 22 79 fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a4e			 
0a4e ed 5b 7b fa		ld de, (store_readptr)     ; save the current extent to load 
0a52			 
0a52 eb				ex de, hl 
0a53			 
0a53				; next ext 
0a53			 
0a53 23				inc hl 
0a54 22 7b fa			ld  (store_readptr), hl     ; save the current extent to load 
0a57			 
0a57				if DEBUG_STORESE 
0a57					DMARK "sF2" 
0a57 f5				push af  
0a58 3a 6c 0a			ld a, (.dmark)  
0a5b 32 6e fe			ld (debug_mark),a  
0a5e 3a 6d 0a			ld a, (.dmark+1)  
0a61 32 6f fe			ld (debug_mark+1),a  
0a64 3a 6e 0a			ld a, (.dmark+2)  
0a67 32 70 fe			ld (debug_mark+2),a  
0a6a 18 03			jr .pastdmark  
0a6c ..			.dmark: db "sF2"  
0a6f f1			.pastdmark: pop af  
0a70			endm  
# End of macro DMARK
0a70					CALLMONITOR 
0a70 cd fb 19			call break_point_state  
0a73				endm  
# End of macro CALLMONITOR
0a73				endif 
0a73			 
0a73				; get and load block 
0a73			 
0a73 cd 4f 07			call storage_findnextid 
0a76			 
0a76				if DEBUG_STORESE 
0a76					DMARK "sf2" 
0a76 f5				push af  
0a77 3a 8b 0a			ld a, (.dmark)  
0a7a 32 6e fe			ld (debug_mark),a  
0a7d 3a 8c 0a			ld a, (.dmark+1)  
0a80 32 6f fe			ld (debug_mark+1),a  
0a83 3a 8d 0a			ld a, (.dmark+2)  
0a86 32 70 fe			ld (debug_mark+2),a  
0a89 18 03			jr .pastdmark  
0a8b ..			.dmark: db "sf2"  
0a8e f1			.pastdmark: pop af  
0a8f			endm  
# End of macro DMARK
0a8f					CALLMONITOR 
0a8f cd fb 19			call break_point_state  
0a92				endm  
# End of macro CALLMONITOR
0a92				endif 
0a92 cd af 0f			call ishlzero 
0a95			;	ld a, l 
0a95			;	add h 
0a95			;	cp 0 
0a95 ca 73 09			jp z,.sr_fail			; block not found so EOF 
0a98				 
0a98				; save current address for use by higher level words etc 
0a98			 
0a98 22 6e fa			ld (store_openaddr),hl 
0a9b			 
0a9b cd 1c 04			call storage_read_block 
0a9e			 
0a9e				; on a continuation block, we now have the file id and ext in the middle of the block 
0a9e				; we need to pull everything back  
0a9e			 
0a9e ed 5b 79 fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aa2 2a 79 fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aa5 23				inc hl 
0aa6 23				inc hl     ; skip id and ext 
0aa7 01 40 00			ld bc, STORE_BLOCK_PHY 
0aaa				if DEBUG_STORESE 
0aaa					DMARK "SR<" 
0aaa f5				push af  
0aab 3a bf 0a			ld a, (.dmark)  
0aae 32 6e fe			ld (debug_mark),a  
0ab1 3a c0 0a			ld a, (.dmark+1)  
0ab4 32 6f fe			ld (debug_mark+1),a  
0ab7 3a c1 0a			ld a, (.dmark+2)  
0aba 32 70 fe			ld (debug_mark+2),a  
0abd 18 03			jr .pastdmark  
0abf ..			.dmark: db "SR<"  
0ac2 f1			.pastdmark: pop af  
0ac3			endm  
# End of macro DMARK
0ac3					CALLMONITOR 
0ac3 cd fb 19			call break_point_state  
0ac6				endm  
# End of macro CALLMONITOR
0ac6				endif 
0ac6 ed b0			ldir     ; copy data 
0ac8			 
0ac8				; move the pointer back and pretend we have a full buffer for next recheck 
0ac8			 
0ac8 1b				dec de 
0ac9 1b				dec de 
0aca			 
0aca			; TODO do pop below now short circuit loop????? 
0aca c1				pop bc     ; get rid of spare de on stack 
0acb				if DEBUG_STORESE 
0acb					DMARK "SR>" 
0acb f5				push af  
0acc 3a e0 0a			ld a, (.dmark)  
0acf 32 6e fe			ld (debug_mark),a  
0ad2 3a e1 0a			ld a, (.dmark+1)  
0ad5 32 6f fe			ld (debug_mark+1),a  
0ad8 3a e2 0a			ld a, (.dmark+2)  
0adb 32 70 fe			ld (debug_mark+2),a  
0ade 18 03			jr .pastdmark  
0ae0 ..			.dmark: db "SR>"  
0ae3 f1			.pastdmark: pop af  
0ae4			endm  
# End of macro DMARK
0ae4					CALLMONITOR 
0ae4 cd fb 19			call break_point_state  
0ae7				endm  
# End of macro CALLMONITOR
0ae7				endif 
0ae7 c3 78 09			jp .srext 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			.readdone:		 
0aea e1				pop hl 		 ; return start of data to show as not EOF 
0aeb 23				inc hl   ; past file id 
0aec 23				inc hl   ; past ext 
0aed				if DEBUG_STORESE 
0aed					DMARK "SRe" 
0aed f5				push af  
0aee 3a 02 0b			ld a, (.dmark)  
0af1 32 6e fe			ld (debug_mark),a  
0af4 3a 03 0b			ld a, (.dmark+1)  
0af7 32 6f fe			ld (debug_mark+1),a  
0afa 3a 04 0b			ld a, (.dmark+2)  
0afd 32 70 fe			ld (debug_mark+2),a  
0b00 18 03			jr .pastdmark  
0b02 ..			.dmark: db "SRe"  
0b05 f1			.pastdmark: pop af  
0b06			endm  
# End of macro DMARK
0b06					CALLMONITOR 
0b06 cd fb 19			call break_point_state  
0b09				endm  
# End of macro CALLMONITOR
0b09				endif 
0b09 c9					ret 
0b0a			 
0b0a			 
0b0a			 
0b0a			; 
0b0a			; Append File 
0b0a			; 
0b0a			; hl - file id to locate 
0b0a			; de - pointer to (multi block) string to write 
0b0a			 
0b0a			.sa_notfound: 
0b0a d1				pop de 
0b0b c9				ret 
0b0c			 
0b0c			 
0b0c			storage_append: 
0b0c				; hl -  file id to append to 
0b0c				; de - string to append 
0b0c			 
0b0c d5				push de 
0b0d				 
0b0d				if DEBUG_STORESE 
0b0d					DMARK "AP1" 
0b0d f5				push af  
0b0e 3a 22 0b			ld a, (.dmark)  
0b11 32 6e fe			ld (debug_mark),a  
0b14 3a 23 0b			ld a, (.dmark+1)  
0b17 32 6f fe			ld (debug_mark+1),a  
0b1a 3a 24 0b			ld a, (.dmark+2)  
0b1d 32 70 fe			ld (debug_mark+2),a  
0b20 18 03			jr .pastdmark  
0b22 ..			.dmark: db "AP1"  
0b25 f1			.pastdmark: pop af  
0b26			endm  
# End of macro DMARK
0b26					CALLMONITOR 
0b26 cd fb 19			call break_point_state  
0b29				endm  
# End of macro CALLMONITOR
0b29				endif 
0b29			 
0b29 7d				ld a, l 
0b2a 32 71 fa			ld (store_tmpid), a 
0b2d			 
0b2d				; get file header  
0b2d			 
0b2d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b2f 3a 71 fa			ld a, (store_tmpid) 
0b32 5f				ld e, a 
0b33			 
0b33 21 40 00				ld hl, STORE_BLOCK_PHY 
0b36 cd 4f 07				call storage_findnextid 
0b39			 
0b39 cd af 0f			call ishlzero 
0b3c 28 cc			jr z, .sa_notfound 
0b3e			 
0b3e 22 68 fa			ld (store_tmppageid), hl 
0b41			 
0b41				; TODO handle file id not found 
0b41			 
0b41				if DEBUG_STORESE 
0b41					DMARK "AP2" 
0b41 f5				push af  
0b42 3a 56 0b			ld a, (.dmark)  
0b45 32 6e fe			ld (debug_mark),a  
0b48 3a 57 0b			ld a, (.dmark+1)  
0b4b 32 6f fe			ld (debug_mark+1),a  
0b4e 3a 58 0b			ld a, (.dmark+2)  
0b51 32 70 fe			ld (debug_mark+2),a  
0b54 18 03			jr .pastdmark  
0b56 ..			.dmark: db "AP2"  
0b59 f1			.pastdmark: pop af  
0b5a			endm  
# End of macro DMARK
0b5a					CALLMONITOR 
0b5a cd fb 19			call break_point_state  
0b5d				endm  
# End of macro CALLMONITOR
0b5d				endif 
0b5d			 
0b5d				; update file extent count 
0b5d			 
0b5d 11 7d fa			ld de, store_page 
0b60			 
0b60 cd 1c 04			call storage_read_block 
0b63			 
0b63				if DEBUG_STORESE 
0b63					DMARK "AP3" 
0b63 f5				push af  
0b64 3a 78 0b			ld a, (.dmark)  
0b67 32 6e fe			ld (debug_mark),a  
0b6a 3a 79 0b			ld a, (.dmark+1)  
0b6d 32 6f fe			ld (debug_mark+1),a  
0b70 3a 7a 0b			ld a, (.dmark+2)  
0b73 32 70 fe			ld (debug_mark+2),a  
0b76 18 03			jr .pastdmark  
0b78 ..			.dmark: db "AP3"  
0b7b f1			.pastdmark: pop af  
0b7c			endm  
# End of macro DMARK
0b7c					CALLMONITOR 
0b7c cd fb 19			call break_point_state  
0b7f				endm  
# End of macro CALLMONITOR
0b7f				endif 
0b7f			;	ld (store_tmppageid), hl 
0b7f			 
0b7f 3a 7f fa			ld a, (store_page+2) 
0b82 3c				inc a 
0b83 32 7f fa			ld (store_page+2), a 
0b86 32 70 fa			ld (store_tmpext), a 
0b89				 
0b89				if DEBUG_STORESE 
0b89					DMARK "AP3" 
0b89 f5				push af  
0b8a 3a 9e 0b			ld a, (.dmark)  
0b8d 32 6e fe			ld (debug_mark),a  
0b90 3a 9f 0b			ld a, (.dmark+1)  
0b93 32 6f fe			ld (debug_mark+1),a  
0b96 3a a0 0b			ld a, (.dmark+2)  
0b99 32 70 fe			ld (debug_mark+2),a  
0b9c 18 03			jr .pastdmark  
0b9e ..			.dmark: db "AP3"  
0ba1 f1			.pastdmark: pop af  
0ba2			endm  
# End of macro DMARK
0ba2					CALLMONITOR 
0ba2 cd fb 19			call break_point_state  
0ba5				endm  
# End of macro CALLMONITOR
0ba5				endif 
0ba5 2a 68 fa			ld hl, (store_tmppageid) 
0ba8 11 7d fa			ld de, store_page 
0bab cd 81 04			call storage_write_block 
0bae			 
0bae				; find free block 
0bae			 
0bae 11 00 00			ld de, 0			 ; file extent to locate 
0bb1			 
0bb1 21 40 00				ld hl, STORE_BLOCK_PHY 
0bb4 cd 4f 07				call storage_findnextid 
0bb7 cd af 0f			call ishlzero 
0bba ca 0a 0b			jp z, .sa_notfound 
0bbd			 
0bbd					; TODO handle no space left 
0bbd					 
0bbd 22 68 fa				ld (store_tmppageid), hl 
0bc0			 
0bc0				if DEBUG_STORESE 
0bc0					DMARK "AP4" 
0bc0 f5				push af  
0bc1 3a d5 0b			ld a, (.dmark)  
0bc4 32 6e fe			ld (debug_mark),a  
0bc7 3a d6 0b			ld a, (.dmark+1)  
0bca 32 6f fe			ld (debug_mark+1),a  
0bcd 3a d7 0b			ld a, (.dmark+2)  
0bd0 32 70 fe			ld (debug_mark+2),a  
0bd3 18 03			jr .pastdmark  
0bd5 ..			.dmark: db "AP4"  
0bd8 f1			.pastdmark: pop af  
0bd9			endm  
# End of macro DMARK
0bd9					CALLMONITOR 
0bd9 cd fb 19			call break_point_state  
0bdc				endm  
# End of macro CALLMONITOR
0bdc				endif 
0bdc					; init the buffer with zeros so we can id if the buffer is full or not 
0bdc			 
0bdc e5					push hl 
0bdd c5					push bc 
0bde			 
0bde 21 7d fa				ld hl, store_page 
0be1 06 40				ld b, STORE_BLOCK_PHY 
0be3 3e 00				ld a, 0 
0be5 77			.zeroblock:	ld (hl), a 
0be6 23					inc hl 
0be7 10 fc				djnz .zeroblock 
0be9			 
0be9 c1					pop bc 
0bea e1					pop hl 
0beb			 
0beb					; construct block 
0beb			 
0beb 3a 71 fa				ld a, (store_tmpid) 
0bee 32 7d fa				ld (store_page), a   ; file id 
0bf1 3a 70 fa				ld a, (store_tmpext)   ; extent for this block 
0bf4 32 7e fa				ld (store_page+1), a 
0bf7			 
0bf7 e1					pop hl    ; get string to write 
0bf8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bfa 11 7f fa				ld de, store_page+2 
0bfd			 
0bfd				if DEBUG_STORESE 
0bfd					DMARK "AP5" 
0bfd f5				push af  
0bfe 3a 12 0c			ld a, (.dmark)  
0c01 32 6e fe			ld (debug_mark),a  
0c04 3a 13 0c			ld a, (.dmark+1)  
0c07 32 6f fe			ld (debug_mark+1),a  
0c0a 3a 14 0c			ld a, (.dmark+2)  
0c0d 32 70 fe			ld (debug_mark+2),a  
0c10 18 03			jr .pastdmark  
0c12 ..			.dmark: db "AP5"  
0c15 f1			.pastdmark: pop af  
0c16			endm  
# End of macro DMARK
0c16					CALLMONITOR 
0c16 cd fb 19			call break_point_state  
0c19				endm  
# End of macro CALLMONITOR
0c19				endif 
0c19			 
0c19			 
0c19			 
0c19					; fill buffer with data until end of string or full block 
0c19			 
0c19 7e			.appd:		ld a, (hl) 
0c1a 12					ld (de), a 
0c1b fe 00				cp 0 
0c1d 28 04				jr z, .appdone 
0c1f 23					inc hl 
0c20 13					inc de 
0c21 10 f6				djnz .appd 
0c23			 
0c23 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c24 f5					push af   		; save last byte dumped 
0c25			 
0c25			 
0c25 2a 68 fa			ld hl, (store_tmppageid) 
0c28 11 7d fa			ld de, store_page 
0c2b				if DEBUG_STORESE 
0c2b					DMARK "AP6" 
0c2b f5				push af  
0c2c 3a 40 0c			ld a, (.dmark)  
0c2f 32 6e fe			ld (debug_mark),a  
0c32 3a 41 0c			ld a, (.dmark+1)  
0c35 32 6f fe			ld (debug_mark+1),a  
0c38 3a 42 0c			ld a, (.dmark+2)  
0c3b 32 70 fe			ld (debug_mark+2),a  
0c3e 18 03			jr .pastdmark  
0c40 ..			.dmark: db "AP6"  
0c43 f1			.pastdmark: pop af  
0c44			endm  
# End of macro DMARK
0c44					CALLMONITOR 
0c44 cd fb 19			call break_point_state  
0c47				endm  
# End of macro CALLMONITOR
0c47				endif 
0c47 cd 81 04				call storage_write_block 
0c4a			 
0c4a			 
0c4a				; was that a full block of data written? 
0c4a				; any more to write out? 
0c4a			 
0c4a				; if yes then set vars and jump to start of function again 
0c4a			 
0c4a f1					pop af 
0c4b d1					pop de 
0c4c			 
0c4c fe 00				cp 0		 ; no, string was fully written 
0c4e c8					ret z 
0c4f			 
0c4f					; setup vars for next cycle 
0c4f			 
0c4f 3a 71 fa				ld a, (store_tmpid) 
0c52 6f					ld l, a 
0c53 26 00				ld h, 0 
0c55			 
0c55 c3 0c 0b			 	jp storage_append	 ; yes, need to write out some more 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			if DEBUG_STORECF 
0c58			storageput:	 
0c58					ret 
0c58			storageread: 
0c58					ld hl, store_page 
0c58					ld b, 200 
0c58					ld a,0 
0c58			.src:		ld (hl),a 
0c58					inc hl 
0c58					djnz .src 
0c58					 
0c58			 
0c58					ld de, 0 
0c58					ld bc, 1 
0c58					ld hl, store_page 
0c58					call cfRead 
0c58			 
0c58				call cfGetError 
0c58				ld hl,scratch 
0c58				call hexout 
0c58				ld hl, scratch+2 
0c58				ld a, 0 
0c58				ld (hl),a 
0c58				ld de, scratch 
0c58				ld a,display_row_1 
0c58				call str_at_display 
0c58				call update_display 
0c58			 
0c58					ld hl, store_page 
0c58					ld (os_cur_ptr),hl 
0c58			 
0c58					ret 
0c58			endif 
0c58			 
0c58			 
0c58			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c58			 
0c58			storage_clear_page: 
0c58 e5				push hl 
0c59 d5				push de 
0c5a c5				push bc 
0c5b 21 7d fa			ld hl, store_page 
0c5e 3e 00			ld a, 0 
0c60 77				ld (hl), a 
0c61			 
0c61 11 7e fa			ld de, store_page+1 
0c64 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0c67			 
0c67 ed b0			ldir 
0c69				 
0c69 c1				pop bc 
0c6a d1				pop de 
0c6b e1				pop hl 
0c6c c9				ret 
0c6d			 
0c6d			; eof 
# End of file firmware_storage.asm
0c6d			  
0c6d			; support routines for above hardware abstraction layer  
0c6d			  
0c6d			include "firmware_general.asm"        ; general support functions  
0c6d			 
0c6d			; word look up 
0c6d			 
0c6d			; in 
0c6d			; a is the index 
0c6d			; hl is pointer start of array 
0c6d			; 
0c6d			; returns 
0c6d			; hl to the word 
0c6d			; 
0c6d			 
0c6d			table_lookup:  
0c6d d5					push de 
0c6e eb					ex de, hl 
0c6f			 
0c6f 6f					ld l, a 
0c70 26 00				ld h, 0 
0c72 29					add hl, hl 
0c73 19					add hl, de 
0c74 7e					ld a, (hl) 
0c75 23					inc hl 
0c76 66					ld h,(hl) 
0c77 6f					ld l, a 
0c78			 
0c78 d1					pop de 
0c79 c9					ret 
0c7a			 
0c7a			; Delay loops 
0c7a			 
0c7a			 
0c7a			 
0c7a			aDelayInMS: 
0c7a c5				push bc 
0c7b 47				ld b,a 
0c7c			msdelay: 
0c7c c5				push bc 
0c7d				 
0c7d			 
0c7d 01 41 00			ld bc,041h 
0c80 cd 98 0c			call delayloop 
0c83 c1				pop bc 
0c84 05				dec b 
0c85 20 f5			jr nz,msdelay 
0c87			 
0c87			;if CPU_CLOCK_8MHZ 
0c87			;msdelay8: 
0c87			;	push bc 
0c87			;	 
0c87			; 
0c87			;	ld bc,041h 
0c87			;	call delayloop 
0c87			;	pop bc 
0c87			;	dec b 
0c87			;	jr nz,msdelay8 
0c87			;endif 
0c87			 
0c87			 
0c87 c1				pop bc 
0c88 c9				ret 
0c89			 
0c89			 
0c89			delay250ms: 
0c89				;push de 
0c89 01 00 40			ld bc, 04000h 
0c8c c3 98 0c			jp delayloop 
0c8f			delay500ms: 
0c8f				;push de 
0c8f 01 00 80			ld bc, 08000h 
0c92 c3 98 0c			jp delayloop 
0c95			delay1s: 
0c95				;push bc 
0c95			   ; Clobbers A, d and e 
0c95 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c98			delayloop: 
0c98 c5			    push bc 
0c99			 
0c99			if BASE_CPM 
0c99				ld bc, CPM_DELAY_TUNE 
0c99			.cpmloop: 
0c99				push bc 
0c99			 
0c99			endif 
0c99			 
0c99			 
0c99			 
0c99			delayloopi: 
0c99			;	push bc 
0c99			;.dl: 
0c99 cb 47		    bit     0,a    	; 8 
0c9b cb 47		    bit     0,a    	; 8 
0c9d cb 47		    bit     0,a    	; 8 
0c9f e6 ff		    and     255  	; 7 
0ca1 0b			    dec     bc      	; 6 
0ca2 79			    ld      a,c     	; 4 
0ca3 b0			    or      b     	; 4 
0ca4 c2 99 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ca7			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ca7				;pop de 
0ca7			;pop bc 
0ca7			 
0ca7			if BASE_CPM 
0ca7				pop bc 
0ca7				 
0ca7			    dec     bc      	; 6 
0ca7			    ld      a,c     	; 4 
0ca7			    or      b     	; 4 
0ca7			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ca7				 
0ca7			 
0ca7			endif 
0ca7			;if CPU_CLOCK_8MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7			 
0ca7			;if CPU_CLOCK_10MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7 c1			    pop bc 
0ca8			 
0ca8 c9				ret 
0ca9			 
0ca9			 
0ca9			 
0ca9			; eof 
# End of file firmware_general.asm
0ca9			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ca9			; display routines that use the physical hardware abstraction layer 
0ca9			 
0ca9			 
0ca9			; Display an activity indicator 
0ca9			; Each call returns the new char pointed to in hl 
0ca9			 
0ca9			active: 
0ca9 3a c9 fb			ld a, (display_active) 
0cac fe 06			cp 6 
0cae			 
0cae 20 02			jr nz, .sne 
0cb0				; gone past the last one reset sequence 
0cb0 3e ff			ld a, 255 
0cb2			 
0cb2			.sne:   
0cb2				; get the next char in seq 
0cb2 3c				inc a 
0cb3 32 c9 fb			ld (display_active), a 
0cb6			 
0cb6				; look up the string in the table 
0cb6 21 cd 0c			ld hl, actseq 
0cb9 cb 27			sla a 
0cbb cd 86 0f			call addatohl 
0cbe cd fa 23			call loadwordinhl 
0cc1			 
0cc1				; forth will write the to string when pushing so move from rom to ram 
0cc1			 
0cc1 11 ca fb			ld de, display_active+1 
0cc4 01 02 00			ld bc, 2 
0cc7 ed b0			ldir 
0cc9			 
0cc9 21 ca fb			ld hl, display_active+1 
0ccc c9				ret 
0ccd				 
0ccd				 
0ccd			 
0ccd			 
0ccd			;db "|/-\|-\" 
0ccd			 
0ccd			actseq: 
0ccd			 
0ccd db 0c		dw spin0 
0ccf dd 0c		dw spin1 
0cd1 df 0c		dw spin2 
0cd3 e1 0c		dw spin3 
0cd5 df 0c		dw spin2 
0cd7 dd 0c		dw spin1 
0cd9 db 0c		dw spin0 
0cdb			 
0cdb .. 00		spin0: db " ", 0 
0cdd .. 00		spin1: db "-", 0 
0cdf .. 00		spin2: db "+", 0 
0ce1 .. 00		spin3: db "#", 0 
0ce3			 
0ce3			 
0ce3			; information window 
0ce3			 
0ce3			; pass hl with 1st string to display 
0ce3			; pass de with 2nd string to display 
0ce3			 
0ce3			info_panel: 
0ce3 e5				push hl 
0ce4			 
0ce4 2a cf fb			ld hl, (display_fb_active) 
0ce7 e5				push hl    ; future de destination 
0ce8 21 b4 fd				ld hl, display_fb0 
0ceb 22 cf fb				ld (display_fb_active), hl 
0cee			 
0cee			;	call clear_display 
0cee			 
0cee				if BASE_CPM 
0cee				ld a, '.' 
0cee				else 
0cee 3e a5			ld a, 165 
0cf0				endif 
0cf0 cd 57 0d			call fill_display 
0cf3			 
0cf3			 
0cf3 3e 55			ld a, display_row_3 + 5 
0cf5 cd 65 0d			call str_at_display 
0cf8			 
0cf8 e1				pop hl 
0cf9 d1				pop de 
0cfa			 
0cfa e5				push hl 
0cfb			 
0cfb			 
0cfb 3e 2d			ld a, display_row_2 + 5 
0cfd cd 65 0d			call str_at_display 
0d00			 
0d00			 
0d00 cd 75 0d			call update_display 
0d03 cd 43 20			call next_page_prompt 
0d06 cd 52 0d			call clear_display 
0d09			 
0d09				 
0d09 21 13 fd				ld hl, display_fb1 
0d0c 22 cf fb				ld (display_fb_active), hl 
0d0f cd 75 0d			call update_display 
0d12			 
0d12 e1				pop hl 
0d13			 
0d13 c9				ret 
0d14			 
0d14			 
0d14			 
0d14			 
0d14			; TODO windowing? 
0d14			 
0d14			; TODO scroll line up 
0d14			 
0d14			scroll_up: 
0d14			 
0d14 e5				push hl 
0d15 d5				push de 
0d16 c5				push bc 
0d17			 
0d17				; get frame buffer  
0d17			 
0d17 2a cf fb			ld hl, (display_fb_active) 
0d1a e5				push hl    ; future de destination 
0d1b			 
0d1b 11 28 00			ld  de, display_cols 
0d1e 19				add hl, de 
0d1f			 
0d1f d1				pop de 
0d20			 
0d20				;ex de, hl 
0d20 01 9f 00			ld bc, display_fb_len -1  
0d23			;if DEBUG_FORTH_WORDS 
0d23			;	DMARK "SCL" 
0d23			;	CALLMONITOR 
0d23			;endif	 
0d23 ed b0			ldir 
0d25			 
0d25				; wipe bottom row 
0d25			 
0d25			 
0d25 2a cf fb			ld hl, (display_fb_active) 
0d28 11 a0 00			ld de, display_cols*display_rows 
0d2b 19				add hl, de 
0d2c 06 28			ld b, display_cols 
0d2e 3e 20			ld a, ' ' 
0d30			.scwipe: 
0d30 77				ld (hl), a 
0d31 2b				dec hl 
0d32 10 fc			djnz .scwipe 
0d34			 
0d34				;pop hl 
0d34			 
0d34 c1				pop bc 
0d35 d1				pop de 
0d36 e1				pop hl 
0d37			 
0d37 c9				ret 
0d38			 
0d38			 
0d38			;scroll_upo: 
0d38			;	ld de, display_row_1 
0d38			 ;	ld hl, display_row_2 
0d38			;	ld bc, display_cols 
0d38			;	ldir 
0d38			;	ld de, display_row_2 
0d38			 ;	ld hl, display_row_3 
0d38			;	ld bc, display_cols 
0d38			;	ldir 
0d38			;	ld de, display_row_3 
0d38			 ;	ld hl, display_row_4 
0d38			;	ld bc, display_cols 
0d38			;	ldir 
0d38			 
0d38			; TODO clear row 4 
0d38			 
0d38			;	ret 
0d38			 
0d38				 
0d38			scroll_down: 
0d38			 
0d38 e5				push hl 
0d39 d5				push de 
0d3a c5				push bc 
0d3b			 
0d3b				; get frame buffer  
0d3b			 
0d3b 2a cf fb			ld hl, (display_fb_active) 
0d3e			 
0d3e 11 9f 00			ld de, display_fb_len - 1 
0d41 19				add hl, de 
0d42			 
0d42 e5			push hl    ; future de destination 
0d43			 
0d43 11 28 00			ld  de, display_cols 
0d46 ed 52			sbc hl, de 
0d48			 
0d48			 
0d48 d1				pop de 
0d49			 
0d49			;	ex de, hl 
0d49 01 9f 00			ld bc, display_fb_len -1  
0d4c			 
0d4c			 
0d4c				 
0d4c			 
0d4c ed b0			ldir 
0d4e			 
0d4e				; wipe bottom row 
0d4e			 
0d4e			 
0d4e			;	ld hl, (display_fb_active) 
0d4e			;;	ld de, display_cols*display_rows 
0d4e			;;	add hl, de 
0d4e			;	ld b, display_cols 
0d4e			;	ld a, ' ' 
0d4e			;.scwiped: 
0d4e			;	ld (hl), a 
0d4e			;	dec hl 
0d4e			;	djnz .scwiped 
0d4e			 
0d4e				;pop hl 
0d4e			 
0d4e c1				pop bc 
0d4f d1				pop de 
0d50 e1				pop hl 
0d51			 
0d51 c9				ret 
0d52			;scroll_down: 
0d52			;	ld de, display_row_4 
0d52			;	ld hl, display_row_3 
0d52			;	ld bc, display_cols 
0d52			;	ldir 
0d52			;	ld de, display_row_3 
0d52			; 	ld hl, display_row_2 
0d52			;	ld bc, display_cols 
0d52			;	ldir 
0d52			;	ld de, display_row_2 
0d52			;	ld hl, display_row_1 
0d52			;	ld bc, display_cols 
0d52			;	ldir 
0d52			;;; TODO clear row 1 
0d52			;	ret 
0d52			 
0d52			 
0d52			 
0d52			 
0d52			 
0d52			; clear active frame buffer 
0d52			 
0d52			clear_display: 
0d52 3e 20			ld a, ' ' 
0d54 c3 57 0d			jp fill_display 
0d57			 
0d57			; fill active frame buffer with a char in A 
0d57			 
0d57			fill_display: 
0d57 06 a0			ld b,display_fb_len 
0d59 2a cf fb			ld hl, (display_fb_active) 
0d5c 77			.fd1:	ld (hl),a 
0d5d 23				inc hl 
0d5e 10 fc			djnz .fd1 
0d60 23				inc hl 
0d61 3e 00			ld a,0 
0d63 77				ld (hl),a 
0d64			 
0d64			 
0d64 c9				ret 
0d65			; Write string (DE) at pos (A) to active frame buffer 
0d65			 
0d65 2a cf fb		str_at_display:    ld hl,(display_fb_active) 
0d68 06 00					ld b,0 
0d6a 4f					ld c,a 
0d6b 09					add hl,bc 
0d6c 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d6d b7			            OR   A              ;Null terminator? 
0d6e c8			            RET  Z              ;Yes, so finished 
0d6f 77					ld (hl),a 
0d70 23				inc hl 
0d71 13			            INC  DE             ;Point to next character 
0d72 18 f8		            JR   .sad1     ;Repeat 
0d74 c9					ret 
0d75			 
0d75			; using current frame buffer write to physical display 
0d75			 
0d75			update_display: 
0d75 e5				push hl 
0d76 2a cf fb			ld hl, (display_fb_active) 
0d79 cd 5f 75			call write_display 
0d7c e1				pop hl 
0d7d c9				ret 
0d7e			 
0d7e			; TODO scrolling 
0d7e			 
0d7e			 
0d7e			; move cursor right one char 
0d7e			cursor_right: 
0d7e			 
0d7e				; TODO shift right 
0d7e				; TODO if beyond max col 
0d7e				; TODO       cursor_next_line 
0d7e			 
0d7e c9				ret 
0d7f			 
0d7f			 
0d7f			cursor_next_line: 
0d7f				; TODO first char 
0d7f				; TODO line down 
0d7f				; TODO if past last row 
0d7f				; TODO    scroll up 
0d7f			 
0d7f c9				ret 
0d80			 
0d80			cursor_left: 
0d80				; TODO shift left 
0d80				; TODO if beyond left  
0d80				; TODO     cursor prev line 
0d80				 
0d80 c9				ret 
0d81			 
0d81			cursor_prev_line: 
0d81				; TODO last char 
0d81				; TODO line up 
0d81				; TODO if past first row 
0d81				; TODO   scroll down 
0d81			 
0d81 c9				ret 
0d82			 
0d82			 
0d82			cout: 
0d82				; A - char 
0d82 c9				ret 
0d83			 
0d83			 
0d83			; Display a menu and allow item selection (optional toggle items) 
0d83			; 
0d83			; format: 
0d83			; hl pointer to word array with zero term for items 
0d83			; e.g.    db item1 
0d83			;         db .... 
0d83			;         db 0 
0d83			; 
0d83			; a = starting menu item  
0d83			; 
0d83			; de = pointer item toggle array   (todo) 
0d83			; 
0d83			; returns item selected in a 1-... 
0d83			; returns 0 if back button pressed 
0d83			; 
0d83			; NOTE: Uses system frame buffer to display 
0d83			; 
0d83			; LEFT, Q = go back 
0d83			; RIGHT, SPACE, CR = select 
0d83			; UP, A - Up 
0d83			; DOWN, Z - Down 
0d83			 
0d83			 
0d83			 
0d83			 
0d83			 
0d83			menu: 
0d83			 
0d83					; keep array pointer 
0d83			 
0d83 22 76 fa				ld (store_tmp1), hl 
0d86 32 74 fa				ld (store_tmp2), a 
0d89			 
0d89					; check for key bounce 
0d89			 
0d89			if BASE_KEV 
0d89			 
0d89 cd aa 78		.mbounce:	call cin 
0d8c fe 00				cp 0 
0d8e 20 f9				jr nz, .mbounce 
0d90			endif 
0d90					; for ease use ex 
0d90			 
0d90					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d90 21 b4 fd				ld hl, display_fb0 
0d93 22 cf fb				ld (display_fb_active), hl 
0d96			 
0d96 cd 52 0d		.mloop:		call clear_display 
0d99 cd 75 0d				call update_display 
0d9c			 
0d9c					; draw selection id '>' at 1 
0d9c			 
0d9c					; init start of list display 
0d9c			 
0d9c 3e 05				ld a, 5 
0d9e 32 72 fa				ld (store_tmp3), a   ; display row count 
0da1 3a 74 fa				ld a,( store_tmp2) 
0da4 32 75 fa				ld (store_tmp2+1), a   ; display item count 
0da7			 
0da7					 
0da7			.mitem:	 
0da7			 
0da7			 
0da7 3a 75 fa				ld a,(store_tmp2+1) 
0daa 6f					ld l, a 
0dab 26 00				ld h, 0 
0dad 29					add hl, hl 
0dae ed 5b 76 fa			ld de, (store_tmp1) 
0db2 19					add hl, de 
0db3 7e					ld a, (hl) 
0db4 23					inc hl 
0db5 66					ld h,(hl) 
0db6 6f					ld l, a 
0db7			 
0db7 cd af 0f				call ishlzero 
0dba 28 1a				jr z, .mdone 
0dbc			 
0dbc eb					ex de, hl 
0dbd 3a 72 fa				ld a, (store_tmp3) 
0dc0 cd 65 0d				call str_at_display 
0dc3					 
0dc3			 
0dc3					; next item 
0dc3 3a 75 fa				ld a, (store_tmp2+1) 
0dc6 3c					inc a 
0dc7 32 75 fa				ld (store_tmp2+1), a   ; display item count 
0dca			 
0dca			 		; next row 
0dca			 
0dca 3a 72 fa				ld a, (store_tmp3) 
0dcd c6 28				add display_cols 
0dcf 32 72 fa				ld (store_tmp3), a 
0dd2			 
0dd2					; at end of screen? 
0dd2			 
0dd2 fe 10				cp display_rows*4 
0dd4 20 d1				jr nz, .mitem 
0dd6			 
0dd6			 
0dd6			.mdone: 
0dd6 cd af 0f				call ishlzero 
0dd9 28 08				jr z, .nodn 
0ddb			 
0ddb 3e 78				ld a, display_row_4 
0ddd 11 5c 0e				ld de, .mdown 
0de0 cd 65 0d				call str_at_display 
0de3			 
0de3					; draw options to fill the screens with active item on line 1 
0de3					; if current option is 2 or more then display ^ in top 
0de3			 
0de3 3a 74 fa		.nodn:		ld a, (store_tmp2) 
0de6 fe 00				cp 0 
0de8 28 08				jr z, .noup 
0dea			 
0dea 3e 00				ld a, 0 
0dec 11 5a 0e				ld de, .mup 
0def cd 65 0d				call str_at_display 
0df2			 
0df2 3e 02		.noup:		ld a, 2 
0df4 11 58 0e				ld de, .msel 
0df7 cd 65 0d				call str_at_display 
0dfa			 
0dfa					; if current option + 1 is not null then display V in bottom 
0dfa					; get key 
0dfa cd 75 0d				call update_display 
0dfd			 
0dfd			 
0dfd					; handle key 
0dfd			 
0dfd cd 99 78				call cin_wait 
0e00			 
0e00 fe 05				cp KEY_UP 
0e02 28 2b				jr z, .mgoup 
0e04 fe 61				cp 'a' 
0e06 28 27				jr z, .mgoup 
0e08 fe 0a				cp KEY_DOWN 
0e0a 28 32				jr z, .mgod 
0e0c fe 7a				cp 'z' 
0e0e 28 2e				jr z, .mgod 
0e10 fe 20				cp ' ' 
0e12 28 34				jr z, .goend 
0e14 fe 0c				cp KEY_RIGHT 
0e16 28 30				jr z, .goend 
0e18 fe 0d				cp KEY_CR 
0e1a 28 2c				jr z, .goend 
0e1c fe 71				cp 'q' 
0e1e 28 0b				jr z, .goback 
0e20			 
0e20 fe 0b				cp KEY_LEFT 
0e22 28 07				jr z, .goback 
0e24 fe 08				cp KEY_BS 
0e26 28 03				jr z, .goback 
0e28 c3 96 0d				jp .mloop 
0e2b			 
0e2b			.goback: 
0e2b 3e 00			ld a, 0 
0e2d 18 1d			jr .goend2 
0e2f			 
0e2f				; move up one 
0e2f			.mgoup: 
0e2f 3a 74 fa				ld a, (store_tmp2) 
0e32 fe 00				cp 0 
0e34 ca 96 0d				jp z, .mloop 
0e37 3d					dec a 
0e38 32 74 fa				ld (store_tmp2), a 
0e3b c3 96 0d				jp .mloop 
0e3e			 
0e3e				; move down one 
0e3e			.mgod: 
0e3e 3a 74 fa				ld a, (store_tmp2) 
0e41 3c					inc a 
0e42 32 74 fa				ld (store_tmp2), a 
0e45 c3 96 0d				jp .mloop 
0e48			 
0e48			 
0e48			.goend: 
0e48					; get selected item number 
0e48			 
0e48 3a 74 fa				ld a, (store_tmp2) 
0e4b 3c					inc a 
0e4c			 
0e4c			.goend2: 
0e4c f5					push af 
0e4d			 
0e4d					; restore active fb 
0e4d					; TODO BUG assumes fb1 
0e4d			 
0e4d 21 13 fd				ld hl, display_fb1 
0e50 22 cf fb				ld (display_fb_active), hl 
0e53			 
0e53					; restore main regs 
0e53			 
0e53			 
0e53 cd 75 0d				call update_display 
0e56			 
0e56 f1					pop af 
0e57			 
0e57 c9				ret 
0e58			 
0e58 .. 00		.msel:   db ">",0 
0e5a .. 00		.mup:   db "^",0 
0e5c .. 00		.mdown:   db "v",0 
0e5e			 
0e5e			 
0e5e			; eof 
0e5e			 
# End of file firmware_display.asm
0e5e			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e5e			; random number generators 
0e5e			 
0e5e			 
0e5e			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e5e			 
0e5e			 
0e5e			;-----> Generate a random number 
0e5e			; output a=answer 0<=a<=255 
0e5e			; all registers are preserved except: af 
0e5e			random: 
0e5e e5			        push    hl 
0e5f d5			        push    de 
0e60 2a ae fb		        ld      hl,(randData) 
0e63 ed 5f		        ld      a,r 
0e65 57			        ld      d,a 
0e66 5e			        ld      e,(hl) 
0e67 19			        add     hl,de 
0e68 85			        add     a,l 
0e69 ac			        xor     h 
0e6a 22 ae fb		        ld      (randData),hl 
0e6d d1			        pop     de 
0e6e e1			        pop     hl 
0e6f c9			        ret 
0e70			 
0e70			 
0e70			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e70			 
0e70			 
0e70			 
0e70			;------LFSR------ 
0e70			;James Montelongo 
0e70			;optimized by Spencer Putt 
0e70			;out: 
0e70			; a = 8 bit random number 
0e70			RandLFSR: 
0e70 21 b4 fb		        ld hl,LFSRSeed+4 
0e73 5e			        ld e,(hl) 
0e74 23			        inc hl 
0e75 56			        ld d,(hl) 
0e76 23			        inc hl 
0e77 4e			        ld c,(hl) 
0e78 23			        inc hl 
0e79 7e			        ld a,(hl) 
0e7a 47			        ld b,a 
0e7b cb 13		        rl e  
0e7d cb 12			rl d 
0e7f cb 11		        rl c  
0e81 17				rla 
0e82 cb 13		        rl e  
0e84 cb 12			rl d 
0e86 cb 11		        rl c  
0e88 17				rla 
0e89 cb 13		        rl e  
0e8b cb 12			rl d 
0e8d cb 11		        rl c  
0e8f 17				rla 
0e90 67			        ld h,a 
0e91 cb 13		        rl e  
0e93 cb 12			rl d 
0e95 cb 11		        rl c  
0e97 17				rla 
0e98 a8			        xor b 
0e99 cb 13		        rl e  
0e9b cb 12			rl d 
0e9d ac			        xor h 
0e9e a9			        xor c 
0e9f aa			        xor d 
0ea0 21 b6 fb		        ld hl,LFSRSeed+6 
0ea3 11 b7 fb		        ld de,LFSRSeed+7 
0ea6 01 07 00		        ld bc,7 
0ea9 ed b8		        lddr 
0eab 12			        ld (de),a 
0eac c9			        ret 
0ead			 
0ead			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ead			 
0ead			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ead			 
0ead			 
0ead			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ead			 
0ead			prng16: 
0ead			;Inputs: 
0ead			;   (seed1) contains a 16-bit seed value 
0ead			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ead			;Outputs: 
0ead			;   HL is the result 
0ead			;   BC is the result of the LCG, so not that great of quality 
0ead			;   DE is preserved 
0ead			;Destroys: 
0ead			;   AF 
0ead			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ead			;160cc 
0ead			;26 bytes 
0ead 2a a8 fb		    ld hl,(seed1) 
0eb0 44			    ld b,h 
0eb1 4d			    ld c,l 
0eb2 29			    add hl,hl 
0eb3 29			    add hl,hl 
0eb4 2c			    inc l 
0eb5 09			    add hl,bc 
0eb6 22 a8 fb		    ld (seed1),hl 
0eb9 2a a6 fb		    ld hl,(seed2) 
0ebc 29			    add hl,hl 
0ebd 9f			    sbc a,a 
0ebe e6 2d		    and %00101101 
0ec0 ad			    xor l 
0ec1 6f			    ld l,a 
0ec2 22 a6 fb		    ld (seed2),hl 
0ec5 09			    add hl,bc 
0ec6 c9			    ret 
0ec7			 
0ec7			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0ec7			 
0ec7			rand32: 
0ec7			;Inputs: 
0ec7			;   (seed1_0) holds the lower 16 bits of the first seed 
0ec7			;   (seed1_1) holds the upper 16 bits of the first seed 
0ec7			;   (seed2_0) holds the lower 16 bits of the second seed 
0ec7			;   (seed2_1) holds the upper 16 bits of the second seed 
0ec7			;   **NOTE: seed2 must be non-zero 
0ec7			;Outputs: 
0ec7			;   HL is the result 
0ec7			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0ec7			;Destroys: 
0ec7			;   AF 
0ec7			;Tested and passes all CAcert tests 
0ec7			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0ec7			;it has a period of 18,446,744,069,414,584,320 
0ec7			;roughly 18.4 quintillion. 
0ec7			;LFSR taps: 0,2,6,7  = 11000101 
0ec7			;291cc 
0ec7			;seed1_0=$+1 
0ec7			;    ld hl,12345 
0ec7			;seed1_1=$+1 
0ec7			;    ld de,6789 
0ec7			;    ld b,h 
0ec7			;    ld c,l 
0ec7			;    add hl,hl \ rl e \ rl d 
0ec7			;    add hl,hl \ rl e \ rl d 
0ec7			;    inc l 
0ec7			;    add hl,bc 
0ec7			;    ld (seed1_0),hl 
0ec7			;    ld hl,(seed1_1) 
0ec7			;    adc hl,de 
0ec7			;    ld (seed1_1),hl 
0ec7			;    ex de,hl 
0ec7			;seed2_0=$+1 
0ec7			;    ld hl,9876 
0ec7			;seed2_1=$+1 
0ec7			;    ld bc,54321 
0ec7			;    add hl,hl \ rl c \ rl b 
0ec7			;    ld (seed2_1),bc 
0ec7			;    sbc a,a 
0ec7			;    and %11000101 
0ec7			;    xor l 
0ec7			;    ld l,a 
0ec7			;    ld (seed2_0),hl 
0ec7			;    ex de,hl 
0ec7			;    add hl,bc 
0ec7			;    ret 
0ec7			; 
0ec7			 
0ec7			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0ec7			; 20 bytes, 86 cycles (excluding ret) 
0ec7			 
0ec7			; returns   hl = pseudorandom number 
0ec7			; corrupts   a 
0ec7			 
0ec7			; generates 16-bit pseudorandom numbers with a period of 65535 
0ec7			; using the xorshift method: 
0ec7			 
0ec7			; hl ^= hl << 7 
0ec7			; hl ^= hl >> 9 
0ec7			; hl ^= hl << 8 
0ec7			 
0ec7			; some alternative shift triplets which also perform well are: 
0ec7			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0ec7			 
0ec7			;  org 32768 
0ec7			 
0ec7			xrnd: 
0ec7 2a ac fb		  ld hl,(xrandc)       ; seed must not be 0 
0eca 3e 00		  ld a,0 
0ecc bd			  cp l 
0ecd 20 02		  jr nz, .xrnd1 
0ecf 2e 01		  ld l, 1 
0ed1			.xrnd1: 
0ed1			 
0ed1 7c			  ld a,h 
0ed2 1f			  rra 
0ed3 7d			  ld a,l 
0ed4 1f			  rra 
0ed5 ac			  xor h 
0ed6 67			  ld h,a 
0ed7 7d			  ld a,l 
0ed8 1f			  rra 
0ed9 7c			  ld a,h 
0eda 1f			  rra 
0edb ad			  xor l 
0edc 6f			  ld l,a 
0edd ac			  xor h 
0ede 67			  ld h,a 
0edf			 
0edf 22 ac fb		  ld (xrandc),hl 
0ee2			 
0ee2 c9			  ret 
0ee3			;  
0ee3			 
0ee3			 
0ee3			;;;; int maths 
0ee3			 
0ee3			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ee3			; Divide 16-bit values (with 16-bit result) 
0ee3			; In: Divide BC by divider DE 
0ee3			; Out: BC = result, HL = rest 
0ee3			; 
0ee3			Div16: 
0ee3 21 00 00		    ld hl,0 
0ee6 78			    ld a,b 
0ee7 06 08		    ld b,8 
0ee9			Div16_Loop1: 
0ee9 17			    rla 
0eea ed 6a		    adc hl,hl 
0eec ed 52		    sbc hl,de 
0eee 30 01		    jr nc,Div16_NoAdd1 
0ef0 19			    add hl,de 
0ef1			Div16_NoAdd1: 
0ef1 10 f6		    djnz Div16_Loop1 
0ef3 17			    rla 
0ef4 2f			    cpl 
0ef5 47			    ld b,a 
0ef6 79			    ld a,c 
0ef7 48			    ld c,b 
0ef8 06 08		    ld b,8 
0efa			Div16_Loop2: 
0efa 17			    rla 
0efb ed 6a		    adc hl,hl 
0efd ed 52		    sbc hl,de 
0eff 30 01		    jr nc,Div16_NoAdd2 
0f01 19			    add hl,de 
0f02			Div16_NoAdd2: 
0f02 10 f6		    djnz Div16_Loop2 
0f04 17			    rla 
0f05 2f			    cpl 
0f06 41			    ld b,c 
0f07 4f			    ld c,a 
0f08 c9			ret 
0f09			 
0f09			 
0f09			;http://z80-heaven.wikidot.com/math 
0f09			; 
0f09			;Inputs: 
0f09			;     DE and A are factors 
0f09			;Outputs: 
0f09			;     A is not changed 
0f09			;     B is 0 
0f09			;     C is not changed 
0f09			;     DE is not changed 
0f09			;     HL is the product 
0f09			;Time: 
0f09			;     342+6x 
0f09			; 
0f09			Mult16: 
0f09			 
0f09 06 08		     ld b,8          ;7           7 
0f0b 21 00 00		     ld hl,0         ;10         10 
0f0e 29			       add hl,hl     ;11*8       88 
0f0f 07			       rlca          ;4*8        32 
0f10 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f12 19			         add hl,de   ;--         -- 
0f13 10 f9		       djnz $-5      ;13*7+8     99 
0f15 c9			ret 
0f16			 
0f16			; 
0f16			; Square root of 16-bit value 
0f16			; In:  HL = value 
0f16			; Out:  D = result (rounded down) 
0f16			; 
0f16			;Sqr16: 
0f16			;    ld de,#0040 
0f16			;    ld a,l 
0f16			;    ld l,h 
0f16			;    ld h,d 
0f16			;    or a 
0f16			;    ld b,8 
0f16			;Sqr16_Loop: 
0f16			;    sbc hl,de 
0f16			;    jr nc,Sqr16_Skip 
0f16			;    add hl,de 
0f16			;Sqr16_Skip: 
0f16			;    ccf 
0f16			;    rl d 
0f16			;    add a,a 
0f16			;    adc hl,hl 
0f16			;    add a,a 
0f16			;    adc hl,hl 
0f16			;    djnz Sqr16_Loop 
0f16			;    ret 
0f16			; 
0f16			; 
0f16			; Divide 8-bit values 
0f16			; In: Divide E by divider C 
0f16			; Out: A = result, B = rest 
0f16			; 
0f16			Div8: 
0f16 af			    xor a 
0f17 06 08		    ld b,8 
0f19			Div8_Loop: 
0f19 cb 13		    rl e 
0f1b 17			    rla 
0f1c 91			    sub c 
0f1d 30 01		    jr nc,Div8_NoAdd 
0f1f 81			    add a,c 
0f20			Div8_NoAdd: 
0f20 10 f7		    djnz Div8_Loop 
0f22 47			    ld b,a 
0f23 7b			    ld a,e 
0f24 17			    rla 
0f25 2f			    cpl 
0f26 c9			    ret 
0f27			 
0f27			; 
0f27			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f27			; In: Multiply A with DE 
0f27			; Out: HL = result 
0f27			; 
0f27			Mult12U: 
0f27 2e 00		    ld l,0 
0f29 87			    add a,a 
0f2a 30 01		    jr nc,Mult12U_NoAdd0 
0f2c 19			    add hl,de 
0f2d			Mult12U_NoAdd0: 
0f2d 29			    add hl,hl 
0f2e 87			    add a,a 
0f2f 30 01		    jr nc,Mult12U_NoAdd1 
0f31 19			    add hl,de 
0f32			Mult12U_NoAdd1: 
0f32 29			    add hl,hl 
0f33 87			    add a,a 
0f34 30 01		    jr nc,Mult12U_NoAdd2 
0f36 19			    add hl,de 
0f37			Mult12U_NoAdd2: 
0f37 29			    add hl,hl 
0f38 87			    add a,a 
0f39 30 01		    jr nc,Mult12U_NoAdd3 
0f3b 19			    add hl,de 
0f3c			Mult12U_NoAdd3: 
0f3c 29			    add hl,hl 
0f3d 87			    add a,a 
0f3e 30 01		    jr nc,Mult12U_NoAdd4 
0f40 19			    add hl,de 
0f41			Mult12U_NoAdd4: 
0f41 29			    add hl,hl 
0f42 87			    add a,a 
0f43 30 01		    jr nc,Mult12U_NoAdd5 
0f45 19			    add hl,de 
0f46			Mult12U_NoAdd5: 
0f46 29			    add hl,hl 
0f47 87			    add a,a 
0f48 30 01		    jr nc,Mult12U_NoAdd6 
0f4a 19			    add hl,de 
0f4b			Mult12U_NoAdd6: 
0f4b 29			    add hl,hl 
0f4c 87			    add a,a 
0f4d d0			    ret nc 
0f4e 19			    add hl,de 
0f4f c9			    ret 
0f50			 
0f50			; 
0f50			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f50			; In: Multiply A with DE 
0f50			;      Put lowest value in A for most efficient calculation 
0f50			; Out: HL = result 
0f50			; 
0f50			Mult12R: 
0f50 21 00 00		    ld hl,0 
0f53			Mult12R_Loop: 
0f53 cb 3f		    srl a 
0f55 30 01		    jr nc,Mult12R_NoAdd 
0f57 19			    add hl,de 
0f58			Mult12R_NoAdd: 
0f58 cb 23		    sla e 
0f5a cb 12		    rl d 
0f5c b7			    or a 
0f5d c2 53 0f		    jp nz,Mult12R_Loop 
0f60 c9			    ret 
0f61			 
0f61			; 
0f61			; Multiply 16-bit values (with 32-bit result) 
0f61			; In: Multiply BC with DE 
0f61			; Out: BCHL = result 
0f61			; 
0f61			Mult32: 
0f61 79			    ld a,c 
0f62 48			    ld c,b 
0f63 21 00 00		    ld hl,0 
0f66 06 10		    ld b,16 
0f68			Mult32_Loop: 
0f68 29			    add hl,hl 
0f69 17			    rla 
0f6a cb 11		    rl c 
0f6c 30 07		    jr nc,Mult32_NoAdd 
0f6e 19			    add hl,de 
0f6f ce 00		    adc a,0 
0f71 d2 75 0f		    jp nc,Mult32_NoAdd 
0f74 0c			    inc c 
0f75			Mult32_NoAdd: 
0f75 10 f1		    djnz Mult32_Loop 
0f77 41			    ld b,c 
0f78 4f			    ld c,a 
0f79 c9			    ret 
0f7a			 
0f7a			 
0f7a			 
0f7a			; 
0f7a			; Multiply 8-bit values 
0f7a			; In:  Multiply H with E 
0f7a			; Out: HL = result 
0f7a			; 
0f7a			Mult8: 
0f7a 16 00		    ld d,0 
0f7c 6a			    ld l,d 
0f7d 06 08		    ld b,8 
0f7f			Mult8_Loop: 
0f7f 29			    add hl,hl 
0f80 30 01		    jr nc,Mult8_NoAdd 
0f82 19			    add hl,de 
0f83			Mult8_NoAdd: 
0f83 10 fa		    djnz Mult8_Loop 
0f85 c9			    ret 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			;;http://z80-heaven.wikidot.com/math 
0f86			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f86			; 
0f86			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f86			;     ld a,16        ;7 
0f86			;     ld hl,0        ;10 
0f86			;     jp $+5         ;10 
0f86			;.DivLoop: 
0f86			;       add hl,bc    ;-- 
0f86			;       dec a        ;64 
0f86			;       jr z,.DivLoopEnd        ;86 
0f86			; 
0f86			;       sla e        ;128 
0f86			;       rl d         ;128 
0f86			;       adc hl,hl    ;240 
0f86			;       sbc hl,bc    ;240 
0f86			;       jr nc,.DivLoop ;23|21 
0f86			;       inc e        ;-- 
0f86			;       jp .DivLoop+1 
0f86			; 
0f86			;.DivLoopEnd: 
0f86			 
0f86			;HL_Div_C: 
0f86			;Inputs: 
0f86			;     HL is the numerator 
0f86			;     C is the denominator 
0f86			;Outputs: 
0f86			;     A is the remainder 
0f86			;     B is 0 
0f86			;     C is not changed 
0f86			;     DE is not changed 
0f86			;     HL is the quotient 
0f86			; 
0f86			;       ld b,16 
0f86			;       xor a 
0f86			;         add hl,hl 
0f86			;         rla 
0f86			;         cp c 
0f86			;         jr c,$+4 
0f86			;           inc l 
0f86			;           sub c 
0f86			;         djnz $-7 
0f86			 
0f86			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f86			 
0f86			addatohl: 
0f86 85			    add   a, l    ; A = A+L 
0f87 6f			    ld    l, a    ; L = A+L 
0f88 8c			    adc   a, h    ; A = A+L+H+carry 
0f89 95			    sub   l       ; A = H+carry 
0f8a 67			    ld    h, a    ; H = H+carry 
0f8b c9			ret 
0f8c			 
0f8c			addatode: 
0f8c 83			    add   a, e    ; A = A+L 
0f8d 5f			    ld    e, a    ; L = A+L 
0f8e 8a			    adc   a, d    ; A = A+L+H+carry 
0f8f 93			    sub   e       ; A = H+carry 
0f90 57			    ld    d, a    ; H = H+carry 
0f91 c9			ret 
0f92			 
0f92			 
0f92			addatobc: 
0f92 81			    add   a, c    ; A = A+L 
0f93 4f			    ld    c, a    ; L = A+L 
0f94 88			    adc   a, b    ; A = A+L+H+carry 
0f95 91			    sub   c       ; A = H+carry 
0f96 47			    ld    b, a    ; H = H+carry 
0f97 c9			ret 
0f98			 
0f98			subafromhl: 
0f98			   ; If A=0 do nothing 
0f98			    ; Otherwise flip A's sign. Since 
0f98			    ; the upper byte becomes -1, also 
0f98			    ; substract 1 from H. 
0f98 ed 44		    neg 
0f9a ca a3 0f		    jp    z, Skip 
0f9d 25			    dec   h 
0f9e			     
0f9e			    ; Now add the low byte as usual 
0f9e			    ; Two's complement takes care of 
0f9e			    ; ensuring the result is correct 
0f9e 85			    add   a, l 
0f9f 6f			    ld    l, a 
0fa0 8c			    adc   a, h 
0fa1 95			    sub   l 
0fa2 67			    ld    h, a 
0fa3			Skip: 
0fa3 c9				ret 
0fa4			 
0fa4			 
0fa4			; compare hl and de 
0fa4			; returns:  
0fa4			; if hl = de, z=1, s=0, c0=0 
0fa4			; if hl > de, z=0, s=0, c=0 
0fa4			; if hl < de, z=0, s=1, c=1 
0fa4			cmp16:	 
0fa4 b7				or a 
0fa5 ed 52			sbc hl,de 
0fa7 e0				ret po 
0fa8 7c				ld a,h 
0fa9 1f				rra 
0faa ee 40			xor 01000000B 
0fac 37				scf 
0fad 8f				adc a,a 
0fae c9				ret 
0faf			 
0faf			 
0faf			; test if hl contains zero   - A is destroyed 
0faf			 
0faf			ishlzero:    
0faf b7				or a     ; reset flags 
0fb0 7c				ld a, h 
0fb1 b5				or l        	 
0fb2			 
0fb2 c9				ret 
0fb3			 
0fb3			 
0fb3			 
0fb3			 
0fb3			if FORTH_ENABLE_FLOATMATH 
0fb3			;include "float/bbcmath.z80" 
0fb3			include "float/lpfpcalc.asm" 
0fb3			endif 
0fb3			 
0fb3			 
0fb3			; eof 
0fb3			 
# End of file firmware_maths.asm
0fb3			include "firmware_strings.asm"   ; string handling  
0fb3			 
0fb3			 
0fb3			; TODO string len 
0fb3			; input text string, end on cr with zero term 
0fb3			; a offset into frame buffer to start prompt 
0fb3			; d is max length 
0fb3			; e is display size TODO 
0fb3			; c is current cursor position 
0fb3			; hl is ptr to where string will be stored 
0fb3			 
0fb3			 
0fb3			; TODO check limit of buffer for new inserts 
0fb3			; TODO check insert does not push beyond buffer 
0fb3			; TODO scroll in a limited display area 
0fb3			; TODO scroll whole screen on page wrap 
0fb3			 
0fb3			 
0fb3			; TODO handle KEY_PREVWORD 
0fb3			; TODO handle KEY_NEXTWORD 
0fb3			; TODO handle KEY_HOME 
0fb3			; TODO handle KEY_END 
0fb3			; TODO use LCD cursor? 
0fb3			 
0fb3 32 67 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0fb6 81					add c 
0fb7 32 65 fe				ld (input_at_cursor),a	; save draw pos of cursor 
0fba 22 6a fe				ld (input_start), hl     ; save ptr to buffer 
0fbd 79					ld a, c 
0fbe cd 86 0f				call addatohl 
0fc1 22 6c fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0fc4 7a					ld a,d 
0fc5 32 69 fe			        ld (input_size), a       ; save length of input area 
0fc8 79					ld a, c 
0fc9 32 58 fe				ld (input_cursor),a      ; init cursor start position  
0fcc 7b					ld a,e 
0fcd 32 68 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0fd0					 
0fd0					 
0fd0			 
0fd0			;		ld a,(input_ptr) 
0fd0			;		ld (input_under_cursor),a 	; save what is under the cursor 
0fd0			 
0fd0			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0fd0					; init cursor shape if not set by the cin routines 
0fd0 21 c4 fb				ld hl, cursor_shape 
0fd3 3e ff				ld a, 255 
0fd5 77					ld (hl), a 
0fd6 23					inc hl 
0fd7 3e 00				ld a, 0 
0fd9 77					ld (hl), a 
0fda			 
0fda 3e 0f				ld a, CUR_BLINK_RATE 
0fdc 32 63 fe				ld (input_cur_flash), a 
0fdf 3e 01				ld a, 1 
0fe1 32 62 fe				ld (input_cur_onoff),a 
0fe4			 
0fe4			;	if DEBUG_INPUT 
0fe4			;		push af 
0fe4			;		ld a, 'I' 
0fe4			;		ld (debug_mark),a 
0fe4			;		pop af 
0fe4			;		CALLMONITOR 
0fe4			;	endif 
0fe4			.is1:		; main entry loop 
0fe4			 
0fe4			 
0fe4			 
0fe4					; pause 1ms 
0fe4			 
0fe4 3e 01				ld a, 1 
0fe6 cd 7a 0c				call aDelayInMS 
0fe9			 
0fe9					; dec flash counter 
0fe9 3a 63 fe				ld a, (input_cur_flash) 
0fec 3d					dec a 
0fed 32 63 fe				ld (input_cur_flash), a 
0ff0 fe 00				cp 0 
0ff2 20 0d				jr nz, .nochgstate 
0ff4			 
0ff4			 
0ff4					; change state 
0ff4 3a 62 fe				ld a,(input_cur_onoff) 
0ff7 ed 44				neg 
0ff9 32 62 fe				ld (input_cur_onoff),a 
0ffc			 
0ffc			 
0ffc					; reset on change of state 
0ffc 3e 0f				ld a, CUR_BLINK_RATE 
0ffe 32 63 fe				ld (input_cur_flash), a 
1001			 
1001			.nochgstate: 
1001					 
1001					 
1001			 
1001					; display cursor  
1001			 
1001			;		ld hl, (input_start) 
1001			;		ld a, (input_cursor) 
1001			;		call addatohl 
1001			 
1001					; get char under cursor and replace with cursor 
1001 2a 6c fe		ld hl, (input_ptr) 
1004			;		ld a, (hl) 
1004			;		ld (input_under_cursor),a 
1004			;		ld a, '_' 
1004			;		ld (hl), a 
1004			 
1004					; display string 
1004			 
1004 ed 5b 6a fe			ld de, (input_start) 
1008 3a 67 fe				ld a, (input_at_pos) 
100b cd 65 0d				call str_at_display 
100e			;	        call update_display 
100e			 
100e					; find place to put the cursor 
100e			;		add h 
100e			;		ld l, display_row_1 
100e			;		sub l 
100e			; (input_at_pos) 
100e					;ld c, a 
100e			;		ld a, (input_cursor) 
100e			;		ld l, (input_at_pos) 
100e			;		;ld b, h 
100e			;		add l 
100e			;		ld (input_at_cursor),a 
100e					;ld l,h 
100e			 
100e			;		ld h, 0 
100e			;		ld l,(input_at_pos) 
100e			;		ld a, (input_cursor) 
100e			;		call addatohl 
100e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
100e			;		call subafromhl 
100e			;		ld a,l 
100e			;		ld (input_at_cursor), a 
100e			 
100e				if DEBUG_INPUT 
100e					ld a, (hardware_diag) 
100e					cp 0 
100e					jr z, .skip_input_diag 
100e			 
100e					ld a,(input_at_pos) 
100e					ld hl, LFSRSeed 
100e					call hexout 
100e					ld a, (input_cursor) 
100e					ld hl, LFSRSeed+2 
100e					call hexout 
100e					ld a,(input_at_cursor) 
100e					ld hl, LFSRSeed+4 
100e					call hexout 
100e			 
100e					ld a,(input_cur_onoff) 
100e					ld hl, LFSRSeed+6 
100e					call hexout 
100e			 
100e					ld a,(input_cur_flash) 
100e					ld hl, LFSRSeed+8 
100e					call hexout 
100e			 
100e					ld a,(input_len) 
100e					ld hl, LFSRSeed+10 
100e					call hexout 
100e					ld hl, LFSRSeed+12 
100e					ld a, 0 
100e					ld (hl),a 
100e					ld a, display_row_4 
100e					ld de, LFSRSeed 
100e					call str_at_display 
100e					.skip_input_diag: 
100e				endif 
100e			 
100e					; decide on if we are showing the cursor this time round 
100e			 
100e 3a 62 fe				ld a, (input_cur_onoff) 
1011 fe ff				cp 255 
1013 28 13				jr z, .skipcur 
1015			 
1015			 
1015 3a 65 fe				ld a,(input_at_cursor) 
1018 11 c4 fb				ld de, cursor_shape 
101b cd 65 0d				call str_at_display 
101e			 
101e					; save length of current input string 
101e 2a 6a fe				ld hl, (input_start) 
1021 cd e4 13				call strlenz 
1024 7d					ld a,l 
1025 32 5d fe				ld (input_len),a 
1028			 
1028			.skipcur: 
1028			 
1028 cd 75 0d			        call update_display 
102b					 
102b			 
102b			 
102b					; wait 
102b				 
102b					; TODO loop without wait to flash the cursor and char under cursor	 
102b cd aa 78				call cin    ; _wait 
102e			 
102e fe 00				cp 0 
1030 ca e4 0f				jp z, .is1 
1033			 
1033					; get ptr to char to input into 
1033			 
1033 4f					ld c,a 
1034 2a 6a fe				ld hl, (input_start) 
1037 3a 58 fe				ld a, (input_cursor) 
103a cd 86 0f				call addatohl 
103d 22 6c fe				ld (input_ptr), hl 
1040 79					ld a,c 
1041			 
1041					; replace char under cursor 
1041			 
1041			;		ld hl, (input_ptr) 
1041			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1041			;		ld (hl), a 
1041			 
1041			;	if DEBUG_INPUT 
1041			;		push af 
1041			;		ld a, 'i' 
1041			;		ld (debug_mark),a 
1041			;		pop af 
1041			;		CALLMONITOR 
1041			;	endif 
1041 fe 0e				cp KEY_HOME 
1043 20 0e				jr nz, .iske 
1045			 
1045 3a 67 fe				ld a, (input_at_pos) 
1048 32 65 fe				ld (input_at_cursor),a 
104b 3e 00				ld a, 0 
104d 32 58 fe				ld (input_cursor), a 
1050 c3 e4 0f				jp .is1 
1053					 
1053 fe 0f		.iske:		cp KEY_END 
1055 20 03				jr nz, .isknw 
1057 c3 e4 0f				jp .is1 
105a			 
105a fe 06		.isknw:		cp KEY_NEXTWORD 
105c 20 1b				jr nz, .iskpw 
105e			 
105e 2a 6c fe		.isknwm:	ld hl, (input_ptr) 
1061 7e					ld a,(hl)	 
1062 fe 00				cp 0 
1064 ca e4 0f				jp z, .is1    ; end of string 
1067 fe 20				cp ' ' 
1069 ca e4 0f				jp z, .is1    ; end of word 
106c 23					inc hl 
106d 22 6c fe				ld (input_ptr), hl 
1070 3a 65 fe				ld a, (input_at_cursor) 
1073 3c					inc a 
1074 32 65 fe				ld (input_at_cursor), a 
1077 18 e5				jr .isknwm 
1079			 
1079 fe 07		.iskpw:		cp KEY_PREVWORD 
107b 20 1b				jr nz, .iskl 
107d			.iskpwm:	 
107d 2a 6c fe				ld hl, (input_ptr) 
1080 7e					ld a,(hl)	 
1081 fe 00				cp 0  
1083 ca e4 0f				jp z, .is1    ; end of string 
1086 fe 20				cp ' ' 
1088 ca e4 0f				jp z, .is1    ; end of word 
108b 2b					dec hl 
108c 22 6c fe				ld (input_ptr), hl 
108f 3a 65 fe				ld a, (input_at_cursor) 
1092 3d					dec a 
1093 32 65 fe				ld (input_at_cursor), a 
1096 18 e5				jr .iskpwm 
1098			 
1098			 
1098 fe 0b		.iskl:		cp KEY_LEFT 
109a 20 27				jr nz, .isk1 
109c			 
109c 3a 58 fe				ld a, (input_cursor) 
109f			 
109f fe 00				cp 0 
10a1 ca e4 0f				jp z, .is1 		; at start of line to ignore  
10a4			 
10a4 3d					dec  a 		; TODO check underflow 
10a5 32 58 fe				ld (input_cursor), a 
10a8			 
10a8 2a 6c fe				ld hl, (input_ptr) 
10ab 2b					dec hl 
10ac 22 6c fe				ld (input_ptr), hl 
10af					 
10af 3a 65 fe				ld a, (input_at_cursor) 
10b2 3d					dec a 
10b3 32 65 fe				ld (input_at_cursor), a 
10b6			 
10b6 3e 01				ld a, 1		; show cursor moving 
10b8 32 62 fe				ld (input_cur_onoff),a 
10bb 3e 0f				ld a, CUR_BLINK_RATE 
10bd 32 63 fe				ld (input_cur_flash), a 
10c0			 
10c0 c3 e4 0f				jp .is1 
10c3			 
10c3 fe 0c		.isk1:		cp KEY_RIGHT 
10c5 20 2a				jr nz, .isk2 
10c7			 
10c7 3a 5d fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
10ca 5f					ld e,a 
10cb 3a 58 fe				ld a, (input_cursor) 
10ce bb					cp e 
10cf ca e4 0f				jp z, .is1		; at the end of string so dont go right 
10d2			 
10d2 3c					inc  a 		; TODO check overflow 
10d3 32 58 fe				ld (input_cursor), a 
10d6			 
10d6 3a 65 fe				ld a, (input_at_cursor) 
10d9 3c					inc a 
10da 32 65 fe				ld (input_at_cursor), a 
10dd			 
10dd 2a 6c fe				ld hl, (input_ptr) 
10e0 23					inc hl 
10e1 22 6c fe				ld (input_ptr), hl 
10e4			 
10e4 3e 01				ld a, 1		; show cursor moving 
10e6 32 62 fe				ld (input_cur_onoff),a 
10e9 3e 0f				ld a, CUR_BLINK_RATE 
10eb 32 63 fe				ld (input_cur_flash), a 
10ee			 
10ee c3 e4 0f				jp .is1 
10f1			 
10f1 fe 05		.isk2:		cp KEY_UP 
10f3			 
10f3 20 26				jr nz, .isk3 
10f5			 
10f5					; swap last command with the current on 
10f5			 
10f5					; move cursor to start of string 
10f5 2a 6a fe				ld hl, (input_start) 
10f8 22 6c fe				ld (input_ptr), hl 
10fb			 
10fb 3a 67 fe				ld a, (input_at_pos) 
10fe 32 65 fe				ld (input_at_cursor), a 
1101			 
1101 3e 00				ld a, 0 
1103 32 58 fe				ld (input_cursor), a 
1106					 
1106					; swap input and last command buffers 
1106			 
1106 21 eb f4				ld hl, os_cli_cmd 
1109 11 ea f5				ld de, os_last_cmd 
110c 06 ff				ld b, 255 
110e 7e			.swap1:		ld a, (hl) 
110f 4f					ld c,a 
1110 1a					ld a, (de) 
1111 77					ld (hl), a 
1112 79					ld a,c 
1113 12					ld (de),a 
1114 23					inc hl 
1115 13					inc de 
1116 10 f6				djnz .swap1 
1118			 
1118			 
1118			 
1118			 
1118			 
1118 c3 e4 0f				jp .is1 
111b			 
111b fe 08		.isk3:		cp KEY_BS 
111d 20 3c				jr nz, .isk4 
111f			 
111f 3a 58 fe				ld a, (input_cursor) 
1122			 
1122 fe 00				cp 0 
1124 ca e4 0f				jp z, .is1 		; at start of line to ignore  
1127			 
1127 3d					dec  a 		; TODO check underflow 
1128 32 58 fe				ld (input_cursor), a 
112b			 
112b					; hl is source 
112b					; de needs to be source - 1 
112b			 
112b			;		ld a, 0 
112b			;		dec hl 
112b			;		ld (hl), a 
112b			 
112b 2a 6c fe				ld hl, (input_ptr) 
112e 2b					dec hl 
112f 22 6c fe				ld (input_ptr), hl 
1132			 
1132					; shift all data 
1132			 
1132 e5					push hl 
1133 23					inc hl 
1134 d1					pop de 
1135 3a 5d fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
1138 4f					ld c,a 
1139 06 00				ld b,0 
113b ed b0				ldir  
113d			 
113d			 
113d			 
113d			 
113d 3a 65 fe				ld a, (input_at_cursor) 
1140 3d					dec a 
1141 32 65 fe				ld (input_at_cursor), a 
1144			 
1144			 
1144 3e 01				ld a, 1		; show cursor moving 
1146 32 62 fe				ld (input_cur_onoff),a 
1149 3e 0f				ld a, CUR_BLINK_RATE 
114b 32 63 fe				ld (input_cur_flash), a 
114e			 
114e					; remove char 
114e 3a 65 fe				ld a, (input_at_cursor) 
1151 3c					inc a 
1152 11 dc 11				ld de,.iblank 
1155 cd 65 0d				call str_at_display 
1158			 
1158 c3 e4 0f				jp .is1 
115b			 
115b fe 0d		.isk4:		cp KEY_CR 
115d 28 6c				jr z, .endinput 
115f			 
115f					; else add the key press to the end 
115f			 
115f 4f					ld c, a			; save key pressed 
1160			 
1160 7e					ld a,(hl)		; get what is currently under char 
1161			 
1161 fe 00				cp 0			; we are at the end of the string 
1163 20 2f				jr nz, .onchar 
1165					 
1165					; add a char to the end of the string 
1165				 
1165 71					ld (hl),c 
1166 23					inc hl 
1167			;		ld a,' ' 
1167			;		ld (hl),a 
1167			;		inc hl 
1167 3e 00				ld a,0 
1169 77					ld (hl),a 
116a 2b					dec hl 
116b			 
116b 3a 58 fe				ld a, (input_cursor) 
116e 3c					inc a				; TODO check max string length and scroll  
116f 32 58 fe				ld (input_cursor), a		; inc cursor pos 
1172							 
1172 3a 65 fe				ld a, (input_at_cursor) 
1175 3c					inc a 
1176 32 65 fe				ld (input_at_cursor), a 
1179			 
1179 2a 6c fe				ld hl, (input_ptr) 
117c 23					inc hl 
117d 22 6c fe				ld (input_ptr), hl 
1180			 
1180 2a 6c fe				ld hl, (input_ptr) 
1183 23					inc hl 
1184 22 6c fe				ld (input_ptr), hl 
1187			;	if DEBUG_INPUT 
1187			;		push af 
1187			;		ld a, '+' 
1187			;		ld (debug_mark),a 
1187			;		pop af 
1187			;		CALLMONITOR 
1187			;	endif 
1187 3e 01				ld a, 1		; show cursor moving 
1189 32 62 fe				ld (input_cur_onoff),a 
118c 3e 0f				ld a, CUR_BLINK_RATE 
118e 32 63 fe				ld (input_cur_flash), a 
1191 c3 e4 0f				jp .is1 
1194					 
1194			 
1194			 
1194					; if on a char then insert 
1194			.onchar: 
1194			 
1194					; TODO over flow check: make sure insert does not blow out buffer 
1194			 
1194					; need to do some maths to use lddr 
1194			 
1194 e5					push hl   ; save char pos 
1195 c5					push bc 
1196			 
1196 2a 6a fe				ld hl, (input_start) 
1199 3a 5d fe				ld a, (input_len) 
119c cd 86 0f				call addatohl  		; end of string 
119f 23					inc hl 
11a0 23					inc hl		; past zero term 
11a1 e5					push hl 
11a2 23					inc hl 
11a3 e5					push hl  
11a4			 
11a4								; start and end of lddr set, now how much to move? 
11a4			 
11a4							 
11a4 3a 58 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11a7 47					ld b,a 
11a8 3a 5d fe				ld a,(input_len) 
11ab 5f					ld e,a 
11ac 90					sub b 
11ad 3c					inc a		;?? 
11ae 3c					inc a		;?? 
11af 3c					inc a		;?? 
11b0			 
11b0 06 00				ld b,0 
11b2 4f					ld c,a 
11b3			 
11b3				if DEBUG_INPUT 
11b3					push af 
11b3					ld a, 'i' 
11b3					ld (debug_mark),a 
11b3					pop af 
11b3			;		CALLMONITOR 
11b3				endif 
11b3 d1					pop de 
11b4 e1					pop hl 
11b5				if DEBUG_INPUT 
11b5					push af 
11b5					ld a, 'I' 
11b5					ld (debug_mark),a 
11b5					pop af 
11b5			;		CALLMONITOR 
11b5				endif 
11b5 ed b8				lddr 
11b7				 
11b7			 
11b7			 
11b7					; TODO have a key for insert/overwrite mode???? 
11b7 c1					pop bc 
11b8 e1					pop hl 
11b9 71					ld (hl), c		; otherwise overwrite current char 
11ba					 
11ba			 
11ba			 
11ba			 
11ba 3a 58 fe				ld a, (input_cursor) 
11bd 3c					inc  a 		; TODO check overflow 
11be 32 58 fe				ld (input_cursor), a 
11c1			 
11c1 3a 65 fe				ld a, (input_at_cursor) 
11c4 3c					inc a 
11c5 32 65 fe				ld (input_at_cursor), a 
11c8			 
11c8 c3 e4 0f				jp .is1 
11cb			 
11cb			.endinput:	; TODO look for end of string 
11cb			 
11cb					; add trailing space for end of token 
11cb			 
11cb 2a 6a fe				ld hl, (input_start) 
11ce 3a 5d fe				ld a,(input_len) 
11d1 cd 86 0f				call addatohl 
11d4 3e 20				ld a, ' ' 
11d6 77					ld (hl),a 
11d7					; TODO eof of parse marker 
11d7			 
11d7 23					inc hl 
11d8 3e 00				ld a, 0 
11da 77					ld (hl),a 
11db			 
11db			 
11db c9					ret 
11dc			 
11dc .. 00		.iblank: db " ",0 
11de			 
11de			 
11de 32 67 fe		input_str_prev:	ld (input_at_pos), a 
11e1 22 6a fe				ld (input_start), hl 
11e4 3e 01				ld a,1			; add cursor 
11e6 77					ld (hl),a 
11e7 23					inc hl 
11e8 3e 00				ld a,0 
11ea 77					ld (hl),a 
11eb 22 6c fe				ld (input_ptr), hl 
11ee 7a					ld a,d 
11ef 32 69 fe				ld (input_size), a 
11f2 3e 00				ld a,0 
11f4 32 58 fe				ld (input_cursor),a 
11f7			.instr1:	 
11f7			 
11f7					; TODO do block cursor 
11f7					; TODO switch cursor depending on the modifer key 
11f7			 
11f7					; update cursor shape change on key hold 
11f7			 
11f7 2a 6c fe				ld hl, (input_ptr) 
11fa 2b					dec hl 
11fb 3a c4 fb				ld a,(cursor_shape) 
11fe 77					ld (hl), a 
11ff			 
11ff					; display entered text 
11ff 3a 67 fe				ld a,(input_at_pos) 
1202 cd 6e 76		            	CALL fLCD_Pos       ;Position cursor to location in A 
1205 ed 5b 6a fe	            	LD   de, (input_start) 
1209 cd 90 76		            	CALL fLCD_Str       ;Display string pointed to by DE 
120c			 
120c cd aa 78				call cin 
120f fe 00				cp 0 
1211 28 e4				jr z, .instr1 
1213			 
1213					; proecess keyboard controls first 
1213			 
1213 2a 6c fe				ld hl,(input_ptr) 
1216			 
1216 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1218 28 5a				jr z, .instrcr 
121a			 
121a fe 08				cp KEY_BS 	; back space 
121c 20 0f				jr nz, .instr2 
121e					; process back space 
121e			 
121e					; TODO stop back space if at start of string 
121e 2b					dec hl 
121f 2b					dec hl ; to over write cursor 
1220 3a c4 fb				ld a,(cursor_shape) 
1223					;ld a,0 
1223 77					ld (hl),a 
1224 23					inc hl 
1225 3e 20				ld a," " 
1227 77					ld (hl),a 
1228 22 6c fe				ld (input_ptr),hl 
122b					 
122b			 
122b 18 ca				jr .instr1 
122d			 
122d fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
122f 20 06				jr nz, .instr3 
1231 2b					dec hl 
1232 22 6c fe				ld (input_ptr),hl 
1235 18 c0				jr .instr1 
1237				 
1237 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1239 20 06				jr nz, .instr4 
123b 23					inc hl 
123c 22 6c fe				ld (input_ptr),hl 
123f 18 b6				jr .instr1 
1241			 
1241 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1243 20 06				jr nz, .instr5 
1245 2b					dec hl 
1246 22 6c fe				ld (input_ptr),hl 
1249 18 ac				jr .instr1 
124b			 
124b fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
124d 20 06				jr nz, .instr6 
124f 2b					dec hl 
1250 22 6c fe				ld (input_ptr),hl 
1253 18 a2				jr .instr1 
1255 fe 05		.instr6:        cp KEY_UP      ; recall last command 
1257 20 0b				jr nz, .instrnew 
1259			 
1259 21 c4 f1			ld hl, scratch 
125c 11 ea f5			ld de, os_last_cmd 
125f cd 7d 12			call strcpy 
1262 18 93				jr .instr1 
1264			 
1264			 
1264			.instrnew:	; no special key pressed to see if we have room to store it 
1264			 
1264					; TODO do string size test 
1264			 
1264 2b					dec hl ; to over write cursor 
1265 77					ld (hl),a 
1266 23					inc hl 
1267 3a c4 fb				ld a,(cursor_shape) 
126a 77					ld (hl),a 
126b 23					inc hl 
126c 3e 00				ld a,0 
126e 77					ld (hl),a 
126f			 
126f 22 6c fe				ld (input_ptr),hl 
1272					 
1272 18 83				jr .instr1 
1274 2b			.instrcr:	dec hl		; remove cursor 
1275 3e 20				ld a,' '	; TODO add a trailing space for safety 
1277 77					ld (hl),a 
1278 23					inc hl 
1279 3e 00				ld a,0 
127b 77					ld (hl),a 
127c			 
127c			 
127c					; if at end of line scroll up    
127c					; TODO detecting only end of line 4 for scroll up  
127c			 
127c					;ld   
127c			 
127c c9					ret 
127d			 
127d			 
127d			; strcpy hl = dest, de source 
127d			 
127d 1a			strcpy:   LD   A, (DE)        ;Get character from string 
127e b7			            OR   A              ;Null terminator? 
127f c8			            RET  Z              ;Yes, so finished 
1280 1a					ld a,(de) 
1281 77					ld (hl),a 
1282 13			            INC  DE             ;Point to next character 
1283 23					inc hl 
1284 18 f7		            JR   strcpy       ;Repeat 
1286 c9					ret 
1287			 
1287			 
1287			; TODO string_at  
1287			; pass string which starts with lcd offset address and then null term string 
1287			 
1287			; TODO string to dec 
1287			; TODO string to hex 
1287			; TODO byte to string hex 
1287			; TODO byte to string dec 
1287			 
1287			 
1287			 
1287			; from z80uartmonitor 
1287			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1287			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1287			; pass hl for where to put the text 
1287			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1287 c5			hexout:	PUSH BC 
1288 f5					PUSH AF 
1289 47					LD B, A 
128a					; Upper nybble 
128a cb 3f				SRL A 
128c cb 3f				SRL A 
128e cb 3f				SRL A 
1290 cb 3f				SRL A 
1292 cd a2 12				CALL tohex 
1295 77					ld (hl),a 
1296 23					inc hl	 
1297					 
1297					; Lower nybble 
1297 78					LD A, B 
1298 e6 0f				AND 0FH 
129a cd a2 12				CALL tohex 
129d 77					ld (hl),a 
129e 23					inc hl	 
129f					 
129f f1					POP AF 
12a0 c1					POP BC 
12a1 c9					RET 
12a2					 
12a2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12a2			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
12a2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12a2			tohex: 
12a2 e5					PUSH HL 
12a3 d5					PUSH DE 
12a4 16 00				LD D, 0 
12a6 5f					LD E, A 
12a7 21 af 12				LD HL, .DATA 
12aa 19					ADD HL, DE 
12ab 7e					LD A, (HL) 
12ac d1					POP DE 
12ad e1					POP HL 
12ae c9					RET 
12af			 
12af			.DATA: 
12af 30					DEFB	30h	; 0 
12b0 31					DEFB	31h	; 1 
12b1 32					DEFB	32h	; 2 
12b2 33					DEFB	33h	; 3 
12b3 34					DEFB	34h	; 4 
12b4 35					DEFB	35h	; 5 
12b5 36					DEFB	36h	; 6 
12b6 37					DEFB	37h	; 7 
12b7 38					DEFB	38h	; 8 
12b8 39					DEFB	39h	; 9 
12b9 41					DEFB	41h	; A 
12ba 42					DEFB	42h	; B 
12bb 43					DEFB	43h	; C 
12bc 44					DEFB	44h	; D 
12bd 45					DEFB	45h	; E 
12be 46					DEFB	46h	; F 
12bf			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
12bf			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
12bf			;;    subtract $30, if result > 9 then subtract $7 more 
12bf			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
12bf			atohex: 
12bf d6 30				SUB $30 
12c1 fe 0a				CP 10 
12c3 f8					RET M		; If result negative it was 0-9 so we're done 
12c4 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
12c6 c9					RET		 
12c7			 
12c7			 
12c7			 
12c7			 
12c7			; Get 2 ASCII characters as hex byte from pointer in hl 
12c7			 
12c7			BYTERD: 
12c7 16 00			LD	D,00h		;Set up 
12c9 cd d1 12			CALL	HEXCON		;Get byte and convert to hex 
12cc 87				ADD	A,A		;First nibble so 
12cd 87				ADD	A,A		;multiply by 16 
12ce 87				ADD	A,A		; 
12cf 87				ADD	A,A		; 
12d0 57				LD	D,A		;Save hi nibble in D 
12d1			HEXCON: 
12d1 7e				ld a, (hl)		;Get next chr 
12d2 23				inc hl 
12d3 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
12d5 fe 0a			CP	00Ah		;Is it 0-9 ? 
12d7 38 02			JR	C,NALPHA	;If so miss next bit 
12d9 d6 07			SUB	007h		;Else convert alpha 
12db			NALPHA: 
12db b2				OR	D		;Add hi nibble back 
12dc c9				RET			; 
12dd			 
12dd			 
12dd			; 
12dd			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
12dd			; Since the routines get_byte and therefore get_nibble are called, only valid 
12dd			; characters (0-9a-f) are accepted. 
12dd			; 
12dd			;get_word        push    af 
12dd			;                call    get_byte        ; Get the upper byte 
12dd			;                ld      h, a 
12dd			;                call    get_byte        ; Get the lower byte 
12dd			;                ld      l, a 
12dd			;                pop     af 
12dd			;                ret 
12dd			; 
12dd			; Get a byte in hexadecimal notation. The result is returned in A. Since 
12dd			; the routine get_nibble is used only valid characters are accepted - the  
12dd			; input routine only accepts characters 0-9a-f. 
12dd			; 
12dd c5			get_byte:        push    bc              ; Save contents of B (and C) 
12de 7e					ld a,(hl) 
12df 23					inc hl 
12e0 cd 05 13		                call    nibble2val      ; Get upper nibble 
12e3 cb 07		                rlc     a 
12e5 cb 07		                rlc     a 
12e7 cb 07		                rlc     a 
12e9 cb 07		                rlc     a 
12eb 47			                ld      b, a            ; Save upper four bits 
12ec 7e					ld a,(hl) 
12ed cd 05 13		                call    nibble2val      ; Get lower nibble 
12f0 b0			                or      b               ; Combine both nibbles 
12f1 c1			                pop     bc              ; Restore B (and C) 
12f2 c9			                ret 
12f3			; 
12f3			; Get a hexadecimal digit from the serial line. This routine blocks until 
12f3			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12f3			; to the serial line interface. The lower 4 bits of A contain the value of  
12f3			; that particular digit. 
12f3			; 
12f3			;get_nibble      ld a,(hl)           ; Read a character 
12f3			;                call    to_upper        ; Convert to upper case 
12f3			;                call    is_hex          ; Was it a hex digit? 
12f3			;                jr      nc, get_nibble  ; No, get another character 
12f3			 ;               call    nibble2val      ; Convert nibble to value 
12f3			 ;               call    print_nibble 
12f3			 ;               ret 
12f3			; 
12f3			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12f3			; A valid hexadecimal digit is denoted by a set C flag. 
12f3			; 
12f3			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12f3			;                ret     nc              ; Yes 
12f3			;                cp      '0'             ; Less than '0'? 
12f3			;                jr      nc, is_hex_1    ; No, continue 
12f3			;                ccf                     ; Complement carry (i.e. clear it) 
12f3			;                ret 
12f3			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12f3			;                ret     c               ; Yes 
12f3			;                cp      'A'             ; Less than 'A'? 
12f3			;                jr      nc, is_hex_2    ; No, continue 
12f3			;                ccf                     ; Yes - clear carry and return 
12f3			;                ret 
12f3			;is_hex_2        scf                     ; Set carry 
12f3			;                ret 
12f3			; 
12f3			; Convert a single character contained in A to upper case: 
12f3			; 
12f3 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12f5 d8			                ret     c 
12f6 fe 7b		                cp      'z' + 1         ; > 'z'? 
12f8 d0			                ret     nc              ; Nothing to do, either 
12f9 e6 5f		                and     $5f             ; Convert to upper case 
12fb c9			                ret 
12fc			 
12fc			 
12fc			to_lower: 
12fc			 
12fc			   ; if char is in [A-Z] make it lower case 
12fc			 
12fc			   ; enter : a = char 
12fc			   ; exit  : a = lower case char 
12fc			   ; uses  : af 
12fc			 
12fc fe 41		   cp 'A' 
12fe d8			   ret c 
12ff			    
12ff fe 5b		   cp 'Z'+1 
1301 d0			   ret nc 
1302			    
1302 f6 20		   or $20 
1304 c9			   ret 
1305			 
1305			; 
1305			; Expects a hexadecimal digit (upper case!) in A and returns the 
1305			; corresponding value in A. 
1305			; 
1305 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1307 38 02		                jr      c, nibble2val_1 ; Yes 
1309 d6 07		                sub     7               ; Adjust for A-F 
130b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
130d e6 0f		                and     $f              ; Only return lower 4 bits 
130f c9			                ret 
1310			; 
1310			; Print_nibble prints a single hex nibble which is contained in the lower  
1310			; four bits of A: 
1310			; 
1310			;print_nibble    push    af              ; We won't destroy the contents of A 
1310			;                and     $f              ; Just in case... 
1310			;                add     a, '0'             ; If we have a digit we are done here. 
1310			;                cp      '9' + 1         ; Is the result > 9? 
1310			;                jr      c, print_nibble_1 
1310			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1310			;print_nibble_1  call    putc            ; Print the nibble and 
1310			;                pop     af              ; restore the original value of A 
1310			;                ret 
1310			;; 
1310			;; Send a CR/LF pair: 
1310			; 
1310			;crlf            push    af 
1310			;                ld      a, cr 
1310			;                call    putc 
1310			;                ld      a, lf 
1310			;                call    putc 
1310			;                pop     af 
1310			;                ret 
1310			; 
1310			; Print_word prints the four hex digits of a word to the serial line. The  
1310			; word is expected to be in HL. 
1310			; 
1310			;print_word      push    hl 
1310			;                push    af 
1310			;                ld      a, h 
1310			;                call    print_byte 
1310			;                ld      a, l 
1310			;                call    print_byte 
1310			;                pop     af 
1310			;                pop     hl 
1310			;                ret 
1310			; 
1310			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1310			; The byte to be printed is expected to be in A. 
1310			; 
1310			;print_byte      push    af              ; Save the contents of the registers 
1310			;                push    bc 
1310			;                ld      b, a 
1310			;                rrca 
1310			;                rrca 
1310			;                rrca 
1310			;                rrca 
1310			;                call    print_nibble    ; Print high nibble 
1310			;                ld      a, b 
1310			;                call    print_nibble    ; Print low nibble 
1310			;                pop     bc              ; Restore original register contents 
1310			;                pop     af 
1310			;                ret 
1310			 
1310			 
1310			 
1310			 
1310			 
1310			fourehexhl:  
1310 7e				ld a,(hl) 
1311 cd bf 12			call atohex 
1314 cb 3f				SRL A 
1316 cb 3f				SRL A 
1318 cb 3f				SRL A 
131a cb 3f				SRL A 
131c 47				ld b, a 
131d 23				inc hl 
131e 7e				ld a,(hl) 
131f 23				inc hl 
1320 cd bf 12			call atohex 
1323 80				add b 
1324 57				ld d,a 
1325 7e				ld a,(hl) 
1326 cd bf 12			call atohex 
1329 cb 3f				SRL A 
132b cb 3f				SRL A 
132d cb 3f				SRL A 
132f cb 3f				SRL A 
1331 47				ld b, a 
1332 23				inc hl 
1333 7e				ld a,(hl) 
1334 23				inc hl 
1335 cd bf 12			call atohex 
1338 80				add b 
1339 5f				ld e, a 
133a d5				push de 
133b e1				pop hl 
133c c9				ret 
133d			 
133d			; pass hl. returns z set if the byte at hl is a digit 
133d			;isdigithl:  
133d			;	push bc 
133d			;	ld a,(hl) 
133d			;	cp ':' 
133d			;	jr nc, .isdf 		; > 
133d			;	cp '0' 
133d			;	jr c, .isdf		; < 
133d			; 
133d			;	; TODO find a better way to set z 
133d			; 
133d			;	ld b,a 
133d			;	cp b 
133d			;	pop bc 
133d			;	ret 
133d			; 
133d			;.isdf:	; not digit so clear z 
133d			; 
133d			;	; TODO find a better way to unset z 
133d			; 
133d			;	ld b,a 
133d			;	inc b 
133d			;	cp b 
133d			; 
133d			;	pop bc 
133d			;	ret 
133d				 
133d				 
133d			 
133d			 
133d			; pass hl as the four byte address to load 
133d			 
133d			get_word_hl:  
133d e5				push hl 
133e cd dd 12			call get_byte 
1341				 
1341 47				ld b, a 
1342			 
1342 e1				pop hl 
1343 23				inc hl 
1344 23				inc hl 
1345			 
1345			; TODO not able to handle a-f  
1345 7e				ld a,(hl) 
1346			;	;cp ':' 
1346			;	cp 'g' 
1346			;	jr nc, .single_byte_hl 		; > 
1346			;	cp 'G' 
1346			;	jr nc, .single_byte_hl 		; > 
1346			;	cp '0' 
1346			;	jr c, .single_byte_hl		; < 
1346			 
1346				;call isdigithl 
1346 fe 00			cp 0 
1348 28 06			jr z, .single_byte_hl 
134a			 
134a			.getwhln:   ; hex word so get next byte 
134a			 
134a cd dd 12			call get_byte 
134d 6f				ld l, a 
134e 60				ld h,b 
134f c9				ret 
1350 68			.single_byte_hl:   ld l,b 
1351 26 00				ld h,0 
1353 c9					ret 
1354			 
1354			 
1354			 
1354			 
1354 21 e2 1d			ld hl,asc+1 
1357			;	ld a, (hl) 
1357			;	call nibble2val 
1357 cd dd 12			call get_byte 
135a			 
135a			;	call fourehexhl 
135a 32 f8 f1			ld (scratch+52),a 
135d				 
135d 21 f6 f1			ld hl,scratch+50 
1360 22 e7 f4			ld (os_cur_ptr),hl 
1363			 
1363 c9				ret 
1364			 
1364			 
1364			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1364			 
1364			; Decimal Unsigned Version 
1364			 
1364			;Number in a to decimal ASCII 
1364			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1364			;Example: display a=56 as "056" 
1364			;input: a = number 
1364			;Output: a=0,value of a in the screen 
1364			;destroys af,bc (don't know about hl and de) 
1364			DispAToASCII: 
1364 0e 9c			ld	c,-100 
1366 cd 70 13			call	.Na1 
1369 0e f6			ld	c,-10 
136b cd 70 13			call	.Na1 
136e 0e ff			ld	c,-1 
1370 06 2f		.Na1:	ld	b,'0'-1 
1372 04			.Na2:	inc	b 
1373 81				add	a,c 
1374 38 fc			jr	c,.Na2 
1376 91				sub	c		;works as add 100/10/1 
1377 f5				push af		;safer than ld c,a 
1378 78				ld	a,b		;char is in b 
1379			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1379 f1				pop af		;safer than ld a,c 
137a c9				ret 
137b			 
137b			; Decimal Signed Version 
137b			 
137b			; DispA 
137b			; -------------------------------------------------------------- 
137b			; Converts a signed integer value to a zero-terminated ASCII 
137b			; string representative of that value (using radix 10). 
137b			; -------------------------------------------------------------- 
137b			; INPUTS: 
137b			;     HL     Value to convert (two's complement integer). 
137b			;     DE     Base address of string destination. (pointer). 
137b			; -------------------------------------------------------------- 
137b			; OUTPUTS: 
137b			;     None 
137b			; -------------------------------------------------------------- 
137b			; REGISTERS/MEMORY DESTROYED 
137b			; AF HL 
137b			; -------------------------------------------------------------- 
137b			 
137b			;DispHLToASCII: 
137b			;   push    de 
137b			;   push    bc 
137b			; 
137b			;; Detect sign of HL. 
137b			;    bit    7, h 
137b			;    jr     z, ._DoConvert 
137b			; 
137b			;; HL is negative. Output '-' to string and negate HL. 
137b			;    ld     a, '-' 
137b			;    ld     (de), a 
137b			;    inc    de 
137b			; 
137b			;; Negate HL (using two's complement) 
137b			;    xor    a 
137b			;    sub    l 
137b			;    ld     l, a 
137b			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
137b			;    sbc    a, h 
137b			;    ld     h, a 
137b			; 
137b			;; Convert HL to digit characters 
137b			;._DoConvert: 
137b			;    ld     b, 0     ; B will count character length of number 
137b			;-   ld     a, 10 
137b			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
137b			;    push   af 
137b			;    inc    b 
137b			;    ld     a, h 
137b			;    or     l 
137b			;    jr     nz, - 
137b			; 
137b			;; Retrieve digits from stack 
137b			;-   pop    af 
137b			;    or     $30 
137b			;    ld     (de), a 
137b			;    inc    de 
137b			;    djnz   - 
137b			; 
137b			;; Terminate string with NULL 
137b			;    xor    a 
137b			;    ld     (de), a 
137b			; 
137b			;    pop    bc 
137b			;    pop    de 
137b			;    ret 
137b			 
137b			;Comments 
137b			; 
137b			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
137b			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
137b			;    Note that the output string will not be fixed-width. 
137b			; 
137b			;Example Usage 
137b			; 
137b			;    ld    hl, -1004 
137b			;    ld    de, OP1 
137b			;    call  DispA 
137b			;    ld    hl, OP1 
137b			;    syscall  PutS 
137b			 
137b			 
137b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
137b			 
137b			 
137b			;Converts an ASCII string to an unsigned 16-bit integer 
137b			;Quits when it reaches a non-decimal digit 
137b			 
137b			string_to_uint16: 
137b			atoui_16: 
137b			;Input: 
137b			;     DE points to the string 
137b			;Outputs: 
137b			;     HL is the result 
137b			;     A is the 8-bit value of the number 
137b			;     DE points to the byte after the number 
137b			;Destroys: 
137b			;     BC 
137b			;       if the string is non-empty, BC is HL/10 
137b			;Size:  24 bytes 
137b			;Speed: 42+d(104+{0,9}) 
137b			;       d is the number of digits in the number 
137b			;       max is 640 cycles for a 5 digit number 
137b			;Assuming no leading zeros: 
137b			;1 digit:  146cc 
137b			;2 digit:  250cc 
137b			;3 digit:  354cc or 363cc (avg: 354.126cc) 
137b			;4 digit:  458cc or 467cc (avg: 458.27cc) 
137b			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
137b			;avg: 544.81158447265625cc (544+13297/16384) 
137b			;=============================================================== 
137b 21 00 00		  ld hl,0 
137e			.u16a: 
137e 1a			  ld a,(de) 
137f d6 30		  sub 30h 
1381 fe 0a		  cp 10 
1383 d0			  ret nc 
1384 13			  inc de 
1385 44			  ld b,h 
1386 4d			  ld c,l 
1387 29			  add hl,hl 
1388 29			  add hl,hl 
1389 09			  add hl,bc 
138a 29			  add hl,hl 
138b 85			  add a,l 
138c 6f			  ld l,a 
138d 30 ef		  jr nc,.u16a 
138f 24			  inc h 
1390 c3 7e 13		  jp .u16a 
1393			 
1393			 
1393			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1393			 
1393			;written by Zeda 
1393			;Converts a 16-bit unsigned integer to an ASCII string. 
1393			 
1393			uitoa_16: 
1393			;Input: 
1393			;   DE is the number to convert 
1393			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1393			;Output: 
1393			;   HL points to the null-terminated ASCII string 
1393			;      NOTE: This isn't necessarily the same as the input HL. 
1393 d5			  push de 
1394 c5			  push bc 
1395 f5			  push af 
1396 eb			  ex de,hl 
1397			 
1397 01 f0 d8		  ld bc,-10000 
139a 3e 2f		  ld a,'0'-1 
139c 3c			  inc a 
139d 09			  add hl,bc  
139e 38 fc		   jr c,$-2 
13a0 12			  ld (de),a 
13a1 13			  inc de 
13a2			 
13a2 01 e8 03		  ld bc,1000 
13a5 3e 3a		  ld a,'9'+1 
13a7 3d			  dec a  
13a8 09			  add hl,bc  
13a9 30 fc		   jr nc,$-2 
13ab 12			  ld (de),a 
13ac 13			  inc de 
13ad			 
13ad 01 9c ff		  ld bc,-100 
13b0 3e 2f		  ld a,'0'-1 
13b2 3c			  inc a  
13b3 09			  add hl,bc  
13b4 38 fc		   jr c,$-2 
13b6 12			  ld (de),a 
13b7 13			  inc de 
13b8			 
13b8 7d			  ld a,l 
13b9 26 3a		  ld h,'9'+1 
13bb 25			  dec h  
13bc c6 0a		  add a,10  
13be 30 fb		   jr nc,$-3 
13c0 c6 30		  add a,'0' 
13c2 eb			  ex de,hl 
13c3 72			  ld (hl),d 
13c4 23			  inc hl 
13c5 77			  ld (hl),a 
13c6 23			  inc hl 
13c7 36 00		  ld (hl),0 
13c9			 
13c9			;Now strip the leading zeros 
13c9 0e fa		  ld c,-6 
13cb 09			  add hl,bc 
13cc 3e 30		  ld a,'0' 
13ce 23			  inc hl  
13cf be			  cp (hl)  
13d0 28 fc		  jr z,$-2 
13d2			 
13d2			;Make sure that the string is non-empty! 
13d2 7e			  ld a,(hl) 
13d3 b7			  or a 
13d4 20 01		  jr nz,.atoub 
13d6 2b			  dec hl 
13d7			.atoub: 
13d7			 
13d7 f1			  pop af 
13d8 c1			  pop bc 
13d9 d1			  pop de 
13da c9			  ret 
13db			 
13db			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
13db			 
13db			toUpper: 
13db			;A is the char. 
13db			;If A is a lowercase letter, this sets it to the matching uppercase 
13db			;18cc or 30cc or 41cc 
13db			;avg: 26.75cc 
13db fe 61		  cp 'a' 
13dd d8			  ret c 
13de fe 7b		  cp 'z'+1 
13e0 d0			  ret nc 
13e1 d6 20		  sub 'a'-'A' 
13e3 c9			  ret 
13e4			 
13e4			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13e4			 
13e4			; String Length 
13e4			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13e4			 
13e4			; Get the length of the null-terminated string starting at $8000 hl 
13e4			;    LD     HL, $8000 
13e4			 
13e4			strlenz: 
13e4			 
13e4 af			    XOR    A               ; Zero is the value we are looking for. 
13e5 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13e6 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13e7			                           ; 65, 536 bytes (the entire addressable memory space). 
13e7 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13e9			 
13e9			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13e9 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13ea 6f			    LD     L, A             ; number of bytes 
13eb ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13ed 2b			    DEC    HL              ; Compensate for null. 
13ee c9				ret 
13ef			 
13ef			; Get the length of the A terminated string starting at $8000 hl 
13ef			;    LD     HL, $8000 
13ef			 
13ef			strlent: 
13ef			 
13ef			                  ; A is the value we are looking for. 
13ef 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13f1 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13f3			                           ; 65, 536 bytes (the entire addressable memory space). 
13f3 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13f5			 
13f5			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13f5 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13f7 2e 00		    LD     L, 0             ; number of bytes 
13f9 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13fb 2b			    DEC    HL              ; Compensate for null. 
13fc c9				ret 
13fd			 
13fd			 
13fd			;Comparing Strings 
13fd			 
13fd			;IN    HL     Address of string1. 
13fd			;      DE     Address of string2. 
13fd			 
13fd			; doc given but wrong??? 
13fd			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13fd			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13fd			; tested 
13fd			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13fd			 
13fd			strcmp_old: 
13fd e5			    PUSH   HL 
13fe d5			    PUSH   DE 
13ff			 
13ff 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1400 be			    CP     (HL)            ; (want to minimize work). 
1401 38 01		    JR     C, Str1IsBigger 
1403 7e			    LD     A, (HL) 
1404			 
1404			Str1IsBigger: 
1404 4f			    LD     C, A             ; Put length in BC 
1405 06 00		    LD     B, 0 
1407 13			    INC    DE              ; Increment pointers to meat of string. 
1408 23			    INC    HL 
1409			 
1409			CmpLoop: 
1409 1a			    LD     A, (DE)          ; Compare bytes. 
140a ed a1		    CPI 
140c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
140e 13			    INC    DE              ; Update pointer. 
140f ea 09 14		    JP     PE, CmpLoop 
1412			 
1412 d1			    POP    DE 
1413 e1			    POP    HL 
1414 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1415 be			    CP     (HL) 
1416 c9			    RET 
1417			 
1417			NoMatch: 
1417 2b			    DEC    HL 
1418 be			    CP     (HL)            ; Compare again to affect carry. 
1419 d1			    POP    DE 
141a e1			    POP    HL 
141b c9			    RET 
141c			 
141c			;; test strmp 
141c			; 
141c			;ld de, .str1 
141c			;ld hl, .str2 
141c			;call strcmp 
141c			;jr z, .z1 
141c			;;this 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "NZ1" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;.z1: 
141c			; 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "ZZ1" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			; 
141c			;ld de, .str1 
141c			;ld hl, .str1 
141c			;call strcmp 
141c			;jr z, .z2 
141c			;;this 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "NZ2" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;.z2: 
141c			; 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "ZZ2" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			; 
141c			;ld de, .str1 
141c			;ld hl, .str2 
141c			;call strcmp 
141c			;jr c, .c1 
141c			; 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "Nc1" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;.c1: 
141c			;;this 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "cc1" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			; 
141c			;ld de, .str1 
141c			;ld hl, .str1 
141c			;call strcmp 
141c			;jr c, .c2 
141c			;;this 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "Nc2" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;.c2: 
141c			; 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "cc2" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;	NEXTW 
141c			;.str1:   db "string1",0 
141c			;.str2:   db "string2",0 
141c			 
141c			; only care about direct match or not 
141c			; hl and de strings 
141c			; zero set if the same 
141c			 
141c			strcmp: 
141c 1a				ld a, (de) 
141d be				cp (hl) 
141e 28 02			jr z, .ssame 
1420 b7				or a 
1421 c9				ret 
1422			 
1422			.ssame:  
1422 fe 00			cp 0 
1424 c8				ret z 
1425			 
1425 23				inc hl 
1426 13				inc de 
1427 18 f3			jr strcmp 
1429				 
1429				 
1429			 
1429			 
1429			 
1429			 
1429			; eof 
1429			 
1429			 
1429			 
1429			 
1429			 
1429			 
# End of file firmware_strings.asm
1429			include "firmware_memory.asm"   ; malloc and free  
1429			 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429			.mallocsize: db "Wants malloc >256",0 
1429			.mallocasize: db "MALLOC gives >256",0 
1429			.malloczero: db "MALLOC gives zero",0 
1429			 
1429			malloc_guard_zerolen: 
1429				push hl 
1429				push de 
1429				push af 
1429			 
1429				ld de, 0 
1429			        call cmp16 
1429				jr nz, .lowalloz 
1429			 
1429				push hl 
1429				push de 
1429					ld hl, display_fb0 
1429					ld (display_fb_active), hl 
1429				call clear_display 
1429				ld a, 0 
1429				ld de, .malloczero 
1429				call str_at_display 
1429				call update_display 
1429				call delay1s 
1429				call delay1s 
1429				ld a, 0 
1429				ld (os_view_disable), a 
1429			 
1429				pop de 
1429				pop hl 
1429			 
1429				 
1429			 
1429				CALLMONITOR 
1429			.lowalloz: 
1429			 
1429			 
1429				pop af 
1429				pop de 
1429				pop hl 
1429			ret 
1429			 
1429			malloc_guard_entry: 
1429				push hl 
1429				push de 
1429				push af 
1429			 
1429			 	or a      ;clear carry flag 
1429				push hl 
1429				ld de, 255 
1429				sbc hl, de 
1429				jr c, .lowalloc 
1429			 
1429				push de 
1429					ld hl, display_fb0 
1429					ld (display_fb_active), hl 
1429				call clear_display 
1429				ld a, 0 
1429				ld de, .mallocsize 
1429				call str_at_display 
1429				call update_display 
1429				call delay1s 
1429				call delay1s 
1429				ld a, 0 
1429				ld (os_view_disable), a 
1429			 
1429				pop de 
1429				pop hl 
1429			 
1429				 
1429			 
1429				CALLMONITOR 
1429				jr .lowdone 
1429			.lowalloc: 
1429			 
1429			 
1429				pop hl 
1429			.lowdone:	pop af 
1429				pop de 
1429				pop hl 
1429			ret 
1429			 
1429			malloc_guard_exit: 
1429				push hl 
1429				push de 
1429				push af 
1429			 
1429			 	or a      ;clear carry flag 
1429				push hl 
1429				ld de, 255 
1429				sbc hl, de 
1429				jr c, .lowallocx 
1429			 
1429				push de 
1429					ld hl, display_fb0 
1429					ld (display_fb_active), hl 
1429				call clear_display 
1429				ld a, 0 
1429				ld de, .mallocasize 
1429				call str_at_display 
1429				call update_display 
1429				call delay1s 
1429				call delay1s 
1429				ld a, 0 
1429				ld (os_view_disable), a 
1429				pop de 
1429				pop hl 
1429			 
1429				CALLMONITOR 
1429				jr .lowdonex 
1429			.lowallocx: 
1429			 
1429				pop hl 
1429			.lowdonex:	pop af 
1429				pop de 
1429				pop hl 
1429			ret 
1429			endif 
1429			 
1429			if MALLOC_2 
1429			; Z80 Malloc and Free Functions 
1429			 
1429			; Malloc Function: 
1429			; Input: 
1429			;   HL: Size of block to allocate 
1429			; Output: 
1429			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1429			 
1429			malloc: 
1429				 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429			call malloc_guard_entry 
1429			endif 
1429			 
1429			 
1429			 
1429			 
1429					if DEBUG_FORTH_MALLOC 
1429						DMARK "mal" 
1429						CALLMONITOR 
1429					endif 
1429			    push af            ; Save AF register 
1429			    ld a, l            ; Load low byte of size into A 
1429			    or h               ; Check if size is zero 
1429			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1429			 
1429			    ; Allocate memory 
1429			    ld hl, (heap_start) ; Load start of heap into HL 
1429					if DEBUG_FORTH_MALLOC 
1429						DMARK "ma1" 
1429						CALLMONITOR 
1429					endif 
1429			    call malloc_internal ; Call internal malloc function 
1429			    pop af             ; Restore AF register 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429			call malloc_guard_exit 
1429			call malloc_guard_zerolen 
1429			endif 
1429			    ret                ; Return 
1429			 
1429			; Free Function: 
1429			; Input: 
1429			;   HL: Pointer to memory block to free 
1429			; Output: 
1429			;   None 
1429			 
1429			free: 
1429			    push af            ; Save AF register 
1429			    ld a, l            ; Load low byte of pointer into A 
1429			    or h               ; Check if pointer is NULL 
1429			    jp z, free_exit    ; If pointer is NULL, exit 
1429			 
1429			    ; Free memory 
1429			    ld hl, (heap_start) ; Load start of heap into HL 
1429			    call free_internal  ; Call internal free function 
1429			    pop af             ; Restore AF register 
1429			    ret                ; Return 
1429			 
1429			; Internal Malloc Function: 
1429			; Input: 
1429			;   HL: Size of block to allocate 
1429			; Output: 
1429			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1429			 
1429			malloc_internal: 
1429			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1429			    add hl, bc         ; Add management overhead to requested size 
1429			    ex de, hl          ; Save total size in DE, and keep it in HL 
1429					if DEBUG_FORTH_MALLOC 
1429						DMARK "ma2" 
1429						CALLMONITOR 
1429					endif 
1429			 
1429			    ; Search for free memory block 
1429			    ld de, (heap_end)  ; Load end of heap into DE 
1429			    ld bc, 0           ; Initialize counter 
1429			 
1429					if DEBUG_FORTH_MALLOC 
1429						DMARK "ma2" 
1429						CALLMONITOR 
1429					endif 
1429			malloc_search_loop: 
1429			    ; Check if current block is free 
1429			    ld a, (hl)         ; Load current block's status (free or used) 
1429			    cp 0               ; Compare with zero (free) 
1429			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1429			 
1429			    ; Check if current block is large enough 
1429			    ld a, (hl+1)       ; Load high byte of block size 
1429			    cp l               ; Compare with low byte of requested size 
1429			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1429			 
1429			    ld a, (hl+2)       ; Load low byte of block size 
1429			    cp h               ; Compare with high byte of requested size 
1429			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1429			 
1429			    ; Mark block as used 
1429			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1429			 
1429			    ; Calculate remaining space in block 
1429			    ld bc, 0           ; Clear BC 
1429			    add hl, bc         ; Increment HL to point to start of data block 
1429			    add hl, de         ; HL = HL + DE (total size) 
1429			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1429			    add hl, bc         ; Add management overhead to start of data block 
1429			 
1429			    ; Save pointer to allocated block in HL 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429						DMARK "ma5" 
1429			call malloc_guard_exit 
1429			call malloc_guard_zerolen 
1429			endif 
1429			    ret 
1429			 
1429			malloc_skip_block_check: 
1429			    ; Move to the next block 
1429			    ld bc, 3           ; Size of management overhead 
1429			    add hl, bc         ; Move to the next block 
1429			    inc de             ; Increment counter 
1429			 
1429			    ; Check if we have reached the end of heap 
1429			    ld a, e            ; Load low byte of heap end address 
1429			    cp (hl)            ; Compare with low byte of current address 
1429			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1429			    ld a, d            ; Load high byte of heap end address 
1429			    cp 0               ; Check if it's zero (end of memory) 
1429			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1429			 
1429			    ; If we reached here, allocation failed 
1429			    xor a              ; Set result to NULL 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429						DMARK "ma6" 
1429			call malloc_guard_exit 
1429			call malloc_guard_zerolen 
1429			endif 
1429			    ret 
1429			malloc_exit: 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429						DMARK "ma7" 
1429			call malloc_guard_exit 
1429			call malloc_guard_zerolen 
1429			endif 
1429			    ret 
1429			 
1429			; Internal Free Function: 
1429			; Input: 
1429			;   HL: Pointer to memory block to free 
1429			; Output: 
1429			;   None 
1429			 
1429			free_internal: 
1429			    ld de, (heap_start) ; Load start of heap into DE 
1429			    ld bc, 0            ; Initialize counter 
1429			 
1429			free_search_loop: 
1429			    ; Check if current block contains the pointer 
1429			    ld a, l             ; Load low byte of pointer 
1429			    cp (hl+1)           ; Compare with high byte of current block's address 
1429			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1429			    ld a, h             ; Load high byte of pointer 
1429			    cp (hl+2)           ; Compare with low byte of current block's address 
1429			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1429			 
1429			    ; Mark block as free 
1429			    ld (hl), 0          ; Set status byte to indicate free block 
1429			    ret                 ; Return 
1429			 
1429			free_skip_block_check: 
1429			    ; Move to the next block 
1429			    ld bc, 3            ; Size of management overhead 
1429			    add hl, bc          ; Move to the next block 
1429			    inc de              ; Increment counter 
1429			 
1429			    ; Check if we have reached the end of heap 
1429			    ld a, e             ; Load low byte of heap end address 
1429			    cp (hl)             ; Compare with low byte of current address 
1429			    jr nz, free_search_loop  ; If not equal, continue searching 
1429			    ld a, d             ; Load high byte of heap end address 
1429			    cp 0                ; Check if it's zero (end of memory) 
1429			    jr nz, free_search_loop  ; If not zero, continue searching 
1429			 
1429			    ; If we reached here, pointer is not found in heap 
1429			    ret 
1429			 
1429			free_exit: 
1429			    ret                 ; Return 
1429			 
1429			; Define heap start and end addresses 
1429			;heap_start:    .dw 0xC000   ; Start of heap 
1429			;heap_end:      .dw 0xE000   ; End of heap 
1429			 
1429			endif 
1429			 
1429			 
1429			if MALLOC_1 
1429			 
1429			 
1429			 
1429			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1429			 
1429			;moved to firmware.asm 
1429			;heap_start        .equ  0x9000      ; Starting address of heap 
1429			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1429			 
1429			;      .org 0 
1429			;      jp    main 
1429			 
1429			 
1429			;      .org  0x100 
1429			;main: 
1429			;      ld    HL, 0x8100 
1429			;      ld    SP, HL 
1429			; 
1429			;      call  heap_init 
1429			; 
1429			;      ; Make some allocations 
1429			;      ld    HL, 12 
1429			;      call  malloc            ; Allocates 0x9004 
1429			; 
1429			;      ld    HL, 12 
1429			;      call  malloc            ; Allocates 0x9014 
1429			; 
1429			;      ld    HL, 12 
1429			;      call  malloc            ; Allocates 0x9024 
1429			; 
1429			;      ; Free some allocations 
1429			;      ld    HL, 0x9014 
1429			;      call  free 
1429			; 
1429			;      ld    HL, 0x9004 
1429			;      call  free 
1429			; 
1429			;      ld    HL, 0x9024 
1429			;      call  free 
1429			; 
1429			; 
1429			;      halt 
1429			 
1429			 
1429			;------------------------------------------------------------------------------ 
1429			;     heap_init                                                               : 
1429			;                                                                             : 
1429			; Description                                                                 : 
1429			;     Initialise the heap and make it ready for malloc and free operations.   : 
1429			;                                                                             : 
1429			;     The heap is maintained as a linked list, starting with an initial       : 
1429			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1429			;     the first free block in the heap. Each block then points to the next    : 
1429			;     free block within the heap, and the free list ends at the first block   : 
1429			;     with a null pointer to the next free block.                             : 
1429			;                                                                             : 
1429			; Parameters                                                                  : 
1429			;     Inputs are compile-time only. Two defines which specify the starting    : 
1429			;     address of the heap and its size are required, along with a memory      : 
1429			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1429			;     principally stores a pointer to the first free block in the heap.       : 
1429			;                                                                             : 
1429			; Returns                                                                     : 
1429			;     Nothing                                                                 : 
1429			;------------------------------------------------------------------------------ 
1429			heap_init: 
1429 e5			      push  HL 
142a			 
142a			      ; Initialise free list struct 
142a 21 0e 80		      ld    HL, heap_start 
142d 22 0a 80		      ld    (free_list), HL 
1430 21 00 00		      ld    HL, 0 
1433 22 0c 80		      ld    (free_list+2), HL 
1436			 
1436			      ; Insert first free block at bottom of heap, consumes entire heap 
1436 21 a6 f1		      ld    HL, heap_start+heap_size-4 
1439 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
143c 21 98 71		      ld    HL, heap_size-4 
143f 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1442			 
1442			      ; Insert end of free list block at top of heap - two null words will 
1442			      ; terminate the free list 
1442 21 00 00		      ld    HL, 0 
1445 22 a8 f1		      ld    (heap_start+heap_size-2), HL 
1448 22 a6 f1		      ld    (heap_start+heap_size-4), HL 
144b			 
144b e1			      pop   HL 
144c			 
144c c9			      ret 
144d			 
144d			 
144d			;------------------------------------------------------------------------------ 
144d			;     malloc                                                                  : 
144d			;                                                                             : 
144d			; Description                                                                 : 
144d			;     Allocates the wanted space from the heap and returns the address of the : 
144d			;     first useable byte of the allocation.                                   : 
144d			;                                                                             : 
144d			;     Allocations can happen in one of two ways:                              : 
144d			;                                                                             : 
144d			;     1. A free block may be found which is the exact size wanted. In this    : 
144d			;        case the block is removed from the free list and retuedn to the      : 
144d			;        caller.                                                              : 
144d			;     2. A free block may be found which is larger than the size wanted. In   : 
144d			;        this case, the larger block is split into two. The first portion of  : 
144d			;        this block will become the requested space by the malloc call and    : 
144d			;        is returned to the caller. The second portion becomes a new free     : 
144d			;        block, and the free list is adjusted to maintain continuity via this : 
144d			;        newly created block.                                                 : 
144d			;                                                                             : 
144d			;     malloc does not set any initial value in the allocated space, the       : 
144d			;     caller is required to do this as required.                              : 
144d			;                                                                             : 
144d			;     This implementation of malloc uses the stack exclusively, and is        : 
144d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
144d			;     advisable to disable interrupts before calling malloc, and recommended  : 
144d			;     to avoid the use of malloc inside ISRs in general.                      : 
144d			;                                                                             : 
144d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
144d			;                                                                             : 
144d			; Parameters                                                                  : 
144d			;     HL  Number of bytes wanted                                              : 
144d			;                                                                             : 
144d			; Returns                                                                     : 
144d			;     HL  Address of the first useable byte of the allocation                 : 
144d			;                                                                             : 
144d			; Flags                                                                       : 
144d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
144d			;                                                                             : 
144d			; Stack frame                                                                 : 
144d			;       |             |                                                       : 
144d			;       +-------------+                                                       : 
144d			;       |     BC      |                                                       : 
144d			;       +-------------+                                                       : 
144d			;       |     DE      |                                                       : 
144d			;       +-------------+                                                       : 
144d			;       |     IX      |                                                       : 
144d			;       +-------------+                                                       : 
144d			;       |  prev_free  |                                                       : 
144d			;   +4  +-------------+                                                       : 
144d			;       |  this_free  |                                                       : 
144d			;   +2  +-------------+                                                       : 
144d			;       |  next_free  |                                                       : 
144d			;   +0  +-------------+                                                       : 
144d			;       |             |                                                       : 
144d			;                                                                             : 
144d			;------------------------------------------------------------------------------ 
144d			 
144d			 
144d			;malloc: 
144d			; 
144d			;	SAVESP ON 1 
144d			; 
144d			;	call malloc_code 
144d			; 
144d			;	CHECKSP ON 1 
144d			;	ret 
144d			 
144d			 
144d			malloc: 
144d c5			      push  BC 
144e d5			      push  DE 
144f dd e5		      push  IX 
1451			if DEBUG_FORTH_MALLOC_HIGH 
1451			call malloc_guard_entry 
1451			endif 
1451			 
1451					if DEBUG_FORTH_MALLOC 
1451						DMARK "mal" 
1451						CALLMONITOR 
1451					endif 
1451 7c			      ld    A, H                    ; Exit if no space requested 
1452 b5			      or    L 
1453 ca 12 15		      jp    Z, malloc_early_exit 
1456			 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			; 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			 
1456			 
1456			 
1456			 
1456					if DEBUG_FORTH_MALLOC 
1456						DMARK "maA" 
1456						CALLMONITOR 
1456					endif 
1456			      ; Set up stack frame 
1456 eb			      ex    DE, HL 
1457 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
145a 39			      add   HL, SP 
145b f9			      ld    SP, HL 
145c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1460 dd 39		      add   IX, SP 
1462			 
1462			      ; Setup initial state 
1462 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1465 19			      add   HL, DE 
1466			 
1466 44			      ld    B, H                    ; Move want to BC 
1467 4d			      ld    C, L 
1468			 
1468 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
146b dd 75 04		      ld    (IX+4), L 
146e dd 74 05		      ld    (IX+5), H 
1471			 
1471 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1472 23			      inc   HL 
1473 56			      ld    D, (HL) 
1474 dd 73 02		      ld    (IX+2), E 
1477 dd 72 03		      ld    (IX+3), D 
147a eb			      ex    DE, HL                  ; this_free ptr into HL 
147b			 
147b					if DEBUG_FORTH_MALLOC 
147b						DMARK "maB" 
147b						CALLMONITOR 
147b					endif 
147b			      ; Loop through free block list to find some space 
147b			malloc_find_space: 
147b 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
147c 23			      inc   HL 
147d 56			      ld    D, (HL) 
147e			 
147e 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
147f b3			      or    E 
1480 ca 0c 15		      jp    Z, malloc_no_space 
1483			 
1483 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1486 dd 72 01		      ld    (IX+1), D 
1489			 
1489			      ; Does this block have enough space to make the allocation? 
1489 23			      inc   HL                      ; Load free block size into DE 
148a 5e			      ld    E, (HL) 
148b 23			      inc   HL 
148c 56			      ld    D, (HL) 
148d			 
148d eb			      ex    DE, HL                  ; Check size of block against want 
148e b7			      or    A                       ; Ensure carry flag clear 
148f ed 42		      sbc   HL, BC 
1491 e5			      push  HL                      ; Store the result for later (new block size) 
1492			 
1492 ca e1 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1495 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1497			 
1497			      ; this_free block is not big enough, setup ptrs to test next free block 
1497 e1			      pop   HL                      ; Discard previous result 
1498			 
1498 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
149b dd 66 03		      ld    H, (IX+3) 
149e dd 75 04		      ld    (IX+4), L 
14a1 dd 74 05		      ld    (IX+5), H 
14a4			 
14a4 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
14a7 dd 66 01		      ld    H, (IX+1) 
14aa dd 75 02		      ld    (IX+2), L 
14ad dd 74 03		      ld    (IX+3), H 
14b0			 
14b0					if DEBUG_FORTH_MALLOC 
14b0						DMARK "MA>" 
14b0						CALLMONITOR 
14b0					endif 
14b0 18 c9		      jr    malloc_find_space 
14b2			 
14b2			      ; split a bigger block into two - requested size and remaining size 
14b2			malloc_alloc_split: 
14b2					if DEBUG_FORTH_MALLOC 
14b2						DMARK "MAs" 
14b2						CALLMONITOR 
14b2					endif 
14b2 eb			      ex    DE, HL                  ; Calculate address of new free block 
14b3 2b			      dec   HL 
14b4 2b			      dec   HL 
14b5 2b			      dec   HL 
14b6 09			      add   HL, BC 
14b7			 
14b7			      ; Create a new block and point it at next_free 
14b7 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
14ba dd 56 01		      ld    D, (IX+1) 
14bd			 
14bd 73			      ld    (HL), E                 ; Store next_free ptr into new block 
14be 23			      inc   HL 
14bf 72			      ld    (HL), D 
14c0			 
14c0 d1			      pop   DE                      ; Store size of new block into new block 
14c1 23			      inc   HL 
14c2 73			      ld    (HL), E 
14c3 23			      inc   HL 
14c4 72			      ld    (HL), D 
14c5			 
14c5			      ; Update this_free ptr to point to new block 
14c5 2b			      dec   HL 
14c6 2b			      dec   HL 
14c7 2b			      dec   HL 
14c8			 
14c8 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
14cb dd 56 03		      ld    D, (IX+3) 
14ce			 
14ce dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
14d1 dd 74 03		      ld    (IX+3), H 
14d4			 
14d4			      ; Modify this_free block to be allocation 
14d4 eb			      ex    DE, HL 
14d5 af			      xor   A                       ; Null the next block ptr of allocated block 
14d6 77			      ld    (HL), A 
14d7 23			      inc   HL 
14d8 77			      ld    (HL), A 
14d9			 
14d9 23			      inc   HL                      ; Store want size into allocated block 
14da 71			      ld    (HL), C 
14db 23			      inc   HL 
14dc 70			      ld    (HL), B 
14dd 23			      inc   HL 
14de e5			      push  HL                      ; Address of allocation to return 
14df			 
14df 18 19		      jr    malloc_update_links 
14e1			 
14e1			malloc_alloc_fit: 
14e1 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14e2			 
14e2					if DEBUG_FORTH_MALLOC 
14e2						DMARK "MAf" 
14e2						CALLMONITOR 
14e2					endif 
14e2			      ; Modify this_free block to be allocation 
14e2 eb			      ex    DE, HL 
14e3 2b			      dec   HL 
14e4 2b			      dec   HL 
14e5 2b			      dec   HL 
14e6			 
14e6 af			      xor   A                       ; Null the next block ptr of allocated block 
14e7 77			      ld    (HL), A 
14e8 23			      inc   HL 
14e9 77			      ld    (HL), A 
14ea			 
14ea 23			      inc   HL                      ; Store address of allocation to return 
14eb 23			      inc   HL 
14ec 23			      inc   HL 
14ed e5			      push  HL 
14ee			 
14ee			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14ee dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14f1 dd 66 01		      ld    H, (IX+1) 
14f4			 
14f4 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14f7 dd 74 03		      ld    (IX+3), H 
14fa			 
14fa			 
14fa			malloc_update_links: 
14fa			      ; Update prev_free ptr to point to this_free 
14fa dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14fd dd 66 05		      ld    H, (IX+5) 
1500			 
1500 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1503 dd 56 03		      ld    D, (IX+3) 
1506			 
1506 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1507 23			      inc   HL 
1508 72			      ld    (HL), D 
1509			 
1509					if DEBUG_FORTH_MALLOC 
1509						DMARK "Mul" 
1509						CALLMONITOR 
1509					endif 
1509			      ; Clear the Z flag to indicate successful allocation 
1509 7a			      ld    A, D 
150a b3			      or    E 
150b			 
150b d1			      pop   DE                      ; Address of allocation 
150c					if DEBUG_FORTH_MALLOC 
150c						DMARK "MAu" 
150c						CALLMONITOR 
150c					endif 
150c			 
150c			malloc_no_space: 
150c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
150f 39			      add   HL, SP 
1510 f9			      ld    SP, HL 
1511			 
1511 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1512					if DEBUG_FORTH_MALLOC 
1512						DMARK "MAN" 
1512						CALLMONITOR 
1512					endif 
1512			 
1512			malloc_early_exit: 
1512					if DEBUG_FORTH_MALLOC 
1512						DMARK "MAx" 
1512						CALLMONITOR 
1512					endif 
1512 dd e1		      pop   IX 
1514 d1			      pop   DE 
1515 c1			      pop   BC 
1516			 
1516			if DEBUG_FORTH_MALLOC_HIGH 
1516			call malloc_guard_exit 
1516			call malloc_guard_zerolen 
1516			endif 
1516 c9			      ret 
1517			 
1517			 
1517			;------------------------------------------------------------------------------ 
1517			;     free                                                                    : 
1517			;                                                                             : 
1517			; Description                                                                 : 
1517			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1517			;     returned by malloc, otherwise the behaviour is undefined.               : 
1517			;                                                                             : 
1517			;     Where possible, directly adjacent free blocks will be merged together   : 
1517			;     into larger blocks to help ensure that the heap does not become         : 
1517			;     excessively fragmented.                                                 : 
1517			;                                                                             : 
1517			;     free does not clear or set any other value into the freed space, and    : 
1517			;     therefore its contents may be visible through subsequent malloc's. The  : 
1517			;     caller should clear the freed space as required.                        : 
1517			;                                                                             : 
1517			;     This implementation of free uses the stack exclusively, and is          : 
1517			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1517			;     advisable to disable interrupts before calling free, and recommended    : 
1517			;     to avoid the use of free inside ISRs in general.                        : 
1517			;                                                                             : 
1517			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1517			;                                                                             : 
1517			; Parameters                                                                  : 
1517			;     HL  Pointer to address of first byte of allocation to be freed          : 
1517			;                                                                             : 
1517			; Returns                                                                     : 
1517			;     Nothing                                                                 : 
1517			;                                                                             : 
1517			; Stack frame                                                                 : 
1517			;       |             |                                                       : 
1517			;       +-------------+                                                       : 
1517			;       |     BC      |                                                       : 
1517			;       +-------------+                                                       : 
1517			;       |     DE      |                                                       : 
1517			;       +-------------+                                                       : 
1517			;       |     IX      |                                                       : 
1517			;       +-------------+                                                       : 
1517			;       |  prev_free  |                                                       : 
1517			;   +2  +-------------+                                                       : 
1517			;       |  next_free  |                                                       : 
1517			;   +0  +-------------+                                                       : 
1517			;       |             |                                                       : 
1517			;                                                                             : 
1517			;------------------------------------------------------------------------------ 
1517			free: 
1517 c5			      push  BC 
1518 d5			      push  DE 
1519 dd e5		      push  IX 
151b			 
151b 7c			      ld    A, H                    ; Exit if ptr is null 
151c b5			      or    L 
151d ca e1 15		      jp    Z, free_early_exit 
1520			 
1520			      ; Set up stack frame 
1520 eb			      ex    DE, HL 
1521 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1524 39			      add   HL, SP 
1525 f9			      ld    SP, HL 
1526 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
152a dd 39		      add   IX, SP 
152c			 
152c			      ; The address in HL points to the start of the useable allocated space, 
152c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
152c			      ; address of the block itself. 
152c eb			      ex    DE, HL 
152d 11 fc ff		      ld    DE, -4 
1530 19			      add   HL, DE 
1531			 
1531			      ; An allocated block must have a null next block pointer in it 
1531 7e			      ld    A, (HL) 
1532 23			      inc   HL 
1533 b6			      or    (HL) 
1534 c2 dc 15		      jp    NZ, free_done 
1537			 
1537 2b			      dec   HL 
1538			 
1538 44			      ld    B, H                    ; Copy HL to BC 
1539 4d			      ld    C, L 
153a			 
153a			      ; Loop through the free list to find the first block with an address 
153a			      ; higher than the block being freed 
153a 21 0a 80		      ld    HL, free_list 
153d			 
153d			free_find_higher_block: 
153d 5e			      ld    E, (HL)                 ; Load next ptr from free block 
153e 23			      inc   HL 
153f 56			      ld    D, (HL) 
1540 2b			      dec   HL 
1541			 
1541 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1544 dd 72 01		      ld    (IX+1), D 
1547 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
154a dd 74 03		      ld    (IX+3), H 
154d			 
154d 78			      ld    A, B                    ; Check if DE is greater than BC 
154e ba			      cp    D                       ; Compare MSB first 
154f 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1551 30 04		      jr    NC, free_find_higher_block_skip 
1553 79			      ld    A, C 
1554 bb			      cp    E                       ; Then compare LSB 
1555 38 08		      jr    C, free_found_higher_block 
1557			 
1557			free_find_higher_block_skip: 
1557 7a			      ld    A, D                    ; Reached the end of the free list? 
1558 b3			      or    E 
1559 ca dc 15		      jp    Z, free_done 
155c			 
155c eb			      ex    DE, HL 
155d			 
155d 18 de		      jr    free_find_higher_block 
155f			 
155f			free_found_higher_block: 
155f			      ; Insert freed block between prev and next free blocks 
155f 71			      ld    (HL), C                 ; Point prev free block to freed block 
1560 23			      inc   HL 
1561 70			      ld    (HL), B 
1562			 
1562 60			      ld    H, B                    ; Point freed block at next free block 
1563 69			      ld    L, C 
1564 73			      ld    (HL), E 
1565 23			      inc   HL 
1566 72			      ld    (HL), D 
1567			 
1567			      ; Check if the freed block is adjacent to the next free block 
1567 23			      inc   HL                      ; Load size of freed block into HL 
1568 5e			      ld    E, (HL) 
1569 23			      inc   HL 
156a 56			      ld    D, (HL) 
156b eb			      ex    DE, HL 
156c			 
156c 09			      add   HL, BC                  ; Add addr of freed block and its size 
156d			 
156d dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1570 dd 56 01		      ld    D, (IX+1) 
1573			 
1573 b7			      or    A                       ; Clear the carry flag 
1574 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1576 20 22		      jr    NZ, free_check_adjacent_to_prev 
1578			 
1578			      ; Freed block is adjacent to next, merge into one bigger block 
1578 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1579 5e			      ld    E, (HL) 
157a 23			      inc   HL 
157b 56			      ld    D, (HL) 
157c e5			      push  HL                      ; Save ptr to next block for later 
157d			 
157d 60			      ld    H, B                    ; Store ptr from next block into freed block 
157e 69			      ld    L, C 
157f 73			      ld    (HL), E 
1580 23			      inc   HL 
1581 72			      ld    (HL), D 
1582			 
1582 e1			      pop   HL                      ; Restore ptr to next block 
1583 23			      inc   HL                      ; Load size of next block into DE 
1584 5e			      ld    E, (HL) 
1585 23			      inc   HL 
1586 56			      ld    D, (HL) 
1587 d5			      push  DE                      ; Save next block size for later 
1588			 
1588 60			      ld    H, B                    ; Load size of freed block into HL 
1589 69			      ld    L, C 
158a 23			      inc   HL 
158b 23			      inc   HL 
158c 5e			      ld    E, (HL) 
158d 23			      inc   HL 
158e 56			      ld    D, (HL) 
158f eb			      ex    DE, HL 
1590			 
1590 d1			      pop   DE                      ; Restore size of next block 
1591 19			      add   HL, DE                  ; Add sizes of both blocks 
1592 eb			      ex    DE, HL 
1593			 
1593 60			      ld    H, B                    ; Store new bigger size into freed block 
1594 69			      ld    L, C 
1595 23			      inc   HL 
1596 23			      inc   HL 
1597 73			      ld    (HL), E 
1598 23			      inc   HL 
1599 72			      ld    (HL), D 
159a			 
159a			free_check_adjacent_to_prev: 
159a			      ; Check if the freed block is adjacent to the prev free block 
159a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
159d dd 66 03		      ld    H, (IX+3) 
15a0			 
15a0 23			      inc   HL                      ; Size of prev free block into DE 
15a1 23			      inc   HL 
15a2 5e			      ld    E, (HL) 
15a3 23			      inc   HL 
15a4 56			      ld    D, (HL) 
15a5 2b			      dec   HL 
15a6 2b			      dec   HL 
15a7 2b			      dec   HL 
15a8			 
15a8 19			      add   HL, DE                  ; Add prev block addr and size 
15a9			 
15a9 b7			      or    A                       ; Clear the carry flag 
15aa ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15ac 20 2e		      jr    NZ, free_done 
15ae			 
15ae			      ; Freed block is adjacent to prev, merge into one bigger block 
15ae 60			      ld    H, B                    ; Load next ptr from freed block into DE 
15af 69			      ld    L, C 
15b0 5e			      ld    E, (HL) 
15b1 23			      inc   HL 
15b2 56			      ld    D, (HL) 
15b3 e5			      push  HL                      ; Save freed block ptr for later 
15b4			 
15b4 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15b7 dd 66 03		      ld    H, (IX+3) 
15ba 73			      ld    (HL), E 
15bb 23			      inc   HL 
15bc 72			      ld    (HL), D 
15bd			 
15bd e1			      pop   HL                      ; Restore freed block ptr 
15be 23			      inc   HL                      ; Load size of freed block into DE 
15bf 5e			      ld    E, (HL) 
15c0 23			      inc   HL 
15c1 56			      ld    D, (HL) 
15c2 d5			      push  DE                      ; Save freed block size for later 
15c3			 
15c3 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
15c6 dd 66 03		      ld    H, (IX+3) 
15c9 23			      inc   HL 
15ca 23			      inc   HL 
15cb 5e			      ld    E, (HL) 
15cc 23			      inc   HL 
15cd 56			      ld    D, (HL) 
15ce			 
15ce e1			      pop   HL                      ; Add sizes of both blocks 
15cf 19			      add   HL, DE 
15d0 eb			      ex    DE, HL 
15d1			 
15d1 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
15d4 dd 66 03		      ld    H, (IX+3) 
15d7 23			      inc   HL 
15d8 23			      inc   HL 
15d9 73			      ld    (HL), E 
15da 23			      inc   HL 
15db 72			      ld    (HL), D 
15dc			 
15dc			free_done: 
15dc 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15df 39			      add   HL, SP 
15e0 f9			      ld    SP, HL 
15e1			 
15e1			free_early_exit: 
15e1 dd e1		      pop   IX 
15e3 d1			      pop   DE 
15e4 c1			      pop   BC 
15e5			 
15e5 c9			      ret 
15e6			 
15e6			; moved to firmware.asm 
15e6			; 
15e6			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15e6			;                  .dw   0 
15e6			 
15e6			 
15e6			endif 
15e6			 
15e6			 
15e6			if MALLOC_3 
15e6			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15e6			;heap_start        .equ  0x9000      ; Starting address of heap 
15e6			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15e6			; 
15e6			 ;     .org 0 
15e6			  ;    jp    main 
15e6			; 
15e6			; 
15e6			 ;     .org  0x100 
15e6			;main: 
15e6			 ;     ld    HL, 0x8100 
15e6			  ;    ld    SP, HL 
15e6			; 
15e6			;      call  heap_init 
15e6			 
15e6			      ; Make some allocations 
15e6			;      ld    HL, 12 
15e6			;      call  malloc            ; Allocates 0x9004 
15e6			; 
15e6			 ;     ld    HL, 12 
15e6			;      call  malloc            ; Allocates 0x9014 
15e6			 
15e6			;      ld    HL, 12 
15e6			;      call  malloc            ; Allocates 0x9024 
15e6			 
15e6			      ; Free some allocations 
15e6			;      ld    HL, 0x9014 
15e6			;      call  free 
15e6			 
15e6			;      ld    HL, 0x9004 
15e6			;      call  free 
15e6			; 
15e6			;      ld    HL, 0x9024 
15e6			;      call  free 
15e6			 
15e6			 
15e6			 ;     halt 
15e6			 
15e6			 
15e6			;------------------------------------------------------------------------------ 
15e6			;     heap_init                                                               : 
15e6			;                                                                             : 
15e6			; Description                                                                 : 
15e6			;     Initialise the heap and make it ready for malloc and free operations.   : 
15e6			;                                                                             : 
15e6			;     The heap is maintained as a linked list, starting with an initial       : 
15e6			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15e6			;     the first free block in the heap. Each block then points to the next    : 
15e6			;     free block within the heap, and the free list ends at the first block   : 
15e6			;     with a null pointer to the next free block.                             : 
15e6			;                                                                             : 
15e6			; Parameters                                                                  : 
15e6			;     Inputs are compile-time only. Two defines which specify the starting    : 
15e6			;     address of the heap and its size are required, along with a memory      : 
15e6			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15e6			;     principally stores a pointer to the first free block in the heap.       : 
15e6			;                                                                             : 
15e6			; Returns                                                                     : 
15e6			;     Nothing                                                                 : 
15e6			;------------------------------------------------------------------------------ 
15e6			heap_init: 
15e6			      push  HL 
15e6			 
15e6			      ; Initialise free list struct 
15e6			      ld    HL, heap_start 
15e6			      ld    (free_list), HL 
15e6			      ld    HL, 0 
15e6			      ld    (free_list+2), HL 
15e6			 
15e6			      ; Insert first free block at bottom of heap, consumes entire heap 
15e6			      ld    HL, heap_start+heap_size-4 
15e6			      ld    (heap_start), HL        ; Next block (end of free list) 
15e6			      ld    HL, heap_size-4 
15e6			      ld    (heap_start+2), HL      ; Block size 
15e6			 
15e6			      ; Insert end of free list block at top of heap - two null words will 
15e6			      ; terminate the free list 
15e6			      ld    HL, 0 
15e6			      ld    (heap_start+heap_size-2), HL 
15e6			      ld    (heap_start+heap_size-4), HL 
15e6			 
15e6			      pop   HL 
15e6			 
15e6			      ret 
15e6			 
15e6			 
15e6			;------------------------------------------------------------------------------ 
15e6			;     malloc                                                                  : 
15e6			;                                                                             : 
15e6			; Description                                                                 : 
15e6			;     Allocates the wanted space from the heap and returns the address of the : 
15e6			;     first useable byte of the allocation.                                   : 
15e6			;                                                                             : 
15e6			;     Allocations can happen in one of two ways:                              : 
15e6			;                                                                             : 
15e6			;     1. A free block may be found which is the exact size wanted. In this    : 
15e6			;        case the block is removed from the free list and retuedn to the      : 
15e6			;        caller.                                                              : 
15e6			;     2. A free block may be found which is larger than the size wanted. In   : 
15e6			;        this case, the larger block is split into two. The first portion of  : 
15e6			;        this block will become the requested space by the malloc call and    : 
15e6			;        is returned to the caller. The second portion becomes a new free     : 
15e6			;        block, and the free list is adjusted to maintain continuity via this : 
15e6			;        newly created block.                                                 : 
15e6			;                                                                             : 
15e6			;     malloc does not set any initial value in the allocated space, the       : 
15e6			;     caller is required to do this as required.                              : 
15e6			;                                                                             : 
15e6			;     This implementation of malloc uses the stack exclusively, and is        : 
15e6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15e6			;     advisable to disable interrupts before calling malloc, and recommended  : 
15e6			;     to avoid the use of malloc inside ISRs in general.                      : 
15e6			;                                                                             : 
15e6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15e6			;                                                                             : 
15e6			; Parameters                                                                  : 
15e6			;     HL  Number of bytes wanted                                              : 
15e6			;                                                                             : 
15e6			; Returns                                                                     : 
15e6			;     HL  Address of the first useable byte of the allocation                 : 
15e6			;                                                                             : 
15e6			; Flags                                                                       : 
15e6			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15e6			;                                                                             : 
15e6			; Stack frame                                                                 : 
15e6			;       |             |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     BC      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     DE      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     IX      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |  prev_free  |                                                       : 
15e6			;   +4  +-------------+                                                       : 
15e6			;       |  this_free  |                                                       : 
15e6			;   +2  +-------------+                                                       : 
15e6			;       |  next_free  |                                                       : 
15e6			;   +0  +-------------+                                                       : 
15e6			;       |             |                                                       : 
15e6			;                                                                             : 
15e6			;------------------------------------------------------------------------------ 
15e6			malloc: 
15e6			      push  BC 
15e6			      push  DE 
15e6			      push  IX 
15e6			 
15e6			      ld    A, H                    ; Exit if no space requested 
15e6			      or    L 
15e6			      jp    Z, malloc_early_exit 
15e6			 
15e6			      ; Set up stack frame 
15e6			      ex    DE, HL 
15e6			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15e6			      add   HL, SP 
15e6			      ld    SP, HL 
15e6			      ld    IX, 0                   ; Use IX as a frame pointer 
15e6			      add   IX, SP 
15e6			 
15e6			      ; Setup initial state 
15e6			      ld    HL, 4                   ; want must also include space used by block struct 
15e6			      add   HL, DE 
15e6			 
15e6			      ld    B, H                    ; Move want to BC 
15e6			      ld    C, L 
15e6			 
15e6			      ld    HL, free_list           ; Store prev_free ptr to stack 
15e6			      ld    (IX+4), L 
15e6			      ld    (IX+5), H 
15e6			 
15e6			      ld    E, (HL)                 ; Store this_free ptr to stack 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      ld    (IX+2), E 
15e6			      ld    (IX+3), D 
15e6			      ex    DE, HL                  ; this_free ptr into HL 
15e6			 
15e6			      ; Loop through free block list to find some space 
15e6			malloc_find_space: 
15e6			      ld    E, (HL)                 ; Load next_free ptr into DE 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			 
15e6			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15e6			      or    E 
15e6			      jp    Z, malloc_no_space 
15e6			 
15e6			      ld    (IX+0), E               ; Store next_free ptr to stack 
15e6			      ld    (IX+1), D 
15e6			 
15e6			      ; Does this block have enough space to make the allocation? 
15e6			      inc   HL                      ; Load free block size into DE 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			 
15e6			      ex    DE, HL                  ; Check size of block against want 
15e6			      or    A                       ; Ensure carry flag clear 
15e6			      sbc   HL, BC 
15e6			      push  HL                      ; Store the result for later (new block size) 
15e6			 
15e6			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15e6			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15e6			 
15e6			      ; this_free block is not big enough, setup ptrs to test next free block 
15e6			      pop   HL                      ; Discard previous result 
15e6			 
15e6			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15e6			      ld    H, (IX+3) 
15e6			      ld    (IX+4), L 
15e6			      ld    (IX+5), H 
15e6			 
15e6			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15e6			      ld    H, (IX+1) 
15e6			      ld    (IX+2), L 
15e6			      ld    (IX+3), H 
15e6			 
15e6			      jr    malloc_find_space 
15e6			 
15e6			      ; split a bigger block into two - requested size and remaining size 
15e6			malloc_alloc_split: 
15e6			      ex    DE, HL                  ; Calculate address of new free block 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      add   HL, BC 
15e6			 
15e6			      ; Create a new block and point it at next_free 
15e6			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15e6			      ld    D, (IX+1) 
15e6			 
15e6			      ld    (HL), E                 ; Store next_free ptr into new block 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      pop   DE                      ; Store size of new block into new block 
15e6			      inc   HL 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      ; Update this_free ptr to point to new block 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			 
15e6			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15e6			      ld    D, (IX+3) 
15e6			 
15e6			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15e6			      ld    (IX+3), H 
15e6			 
15e6			      ; Modify this_free block to be allocation 
15e6			      ex    DE, HL 
15e6			      xor   A                       ; Null the next block ptr of allocated block 
15e6			      ld    (HL), A 
15e6			      inc   HL 
15e6			      ld    (HL), A 
15e6			 
15e6			      inc   HL                      ; Store want size into allocated block 
15e6			      ld    (HL), C 
15e6			      inc   HL 
15e6			      ld    (HL), B 
15e6			      inc   HL 
15e6			      push  HL                      ; Address of allocation to return 
15e6			 
15e6			      jr    malloc_update_links 
15e6			 
15e6			malloc_alloc_fit: 
15e6			      pop   HL                      ; Dont need new block size, want is exact fit 
15e6			 
15e6			      ; Modify this_free block to be allocation 
15e6			      ex    DE, HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			 
15e6			      xor   A                       ; Null the next block ptr of allocated block 
15e6			      ld    (HL), A 
15e6			      inc   HL 
15e6			      ld    (HL), A 
15e6			 
15e6			      inc   HL                      ; Store address of allocation to return 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      push  HL 
15e6			 
15e6			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15e6			      ld    L, (IX+0)               ; next_free to HL 
15e6			      ld    H, (IX+1) 
15e6			 
15e6			      ld    (IX+2), L               ; HL to this_free 
15e6			      ld    (IX+3), H 
15e6			 
15e6			 
15e6			malloc_update_links: 
15e6			      ; Update prev_free ptr to point to this_free 
15e6			      ld    L, (IX+4)               ; prev_free ptr to HL 
15e6			      ld    H, (IX+5) 
15e6			 
15e6			      ld    E, (IX+2)               ; this_free ptr to DE 
15e6			      ld    D, (IX+3) 
15e6			 
15e6			      ld    (HL), E                 ; this_free ptr into prev_free 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      ; Clear the Z flag to indicate successful allocation 
15e6			      ld    A, D 
15e6			      or    E 
15e6			 
15e6			      pop   DE                      ; Address of allocation 
15e6			 
15e6			malloc_no_space: 
15e6			      ld    HL, 6                   ; Clean up stack frame 
15e6			      add   HL, SP 
15e6			      ld    SP, HL 
15e6			 
15e6			      ex    DE, HL                  ; Alloc addr into HL for return 
15e6			 
15e6			malloc_early_exit: 
15e6			      pop   IX 
15e6			      pop   DE 
15e6			      pop   BC 
15e6			 
15e6			      ret 
15e6			 
15e6			 
15e6			;------------------------------------------------------------------------------ 
15e6			;     free                                                                    : 
15e6			;                                                                             : 
15e6			; Description                                                                 : 
15e6			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15e6			;     returned by malloc, otherwise the behaviour is undefined.               : 
15e6			;                                                                             : 
15e6			;     Where possible, directly adjacent free blocks will be merged together   : 
15e6			;     into larger blocks to help ensure that the heap does not become         : 
15e6			;     excessively fragmented.                                                 : 
15e6			;                                                                             : 
15e6			;     free does not clear or set any other value into the freed space, and    : 
15e6			;     therefore its contents may be visible through subsequent malloc's. The  : 
15e6			;     caller should clear the freed space as required.                        : 
15e6			;                                                                             : 
15e6			;     This implementation of free uses the stack exclusively, and is          : 
15e6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15e6			;     advisable to disable interrupts before calling free, and recommended    : 
15e6			;     to avoid the use of free inside ISRs in general.                        : 
15e6			;                                                                             : 
15e6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15e6			;                                                                             : 
15e6			; Parameters                                                                  : 
15e6			;     HL  Pointer to address of first byte of allocation to be freed          : 
15e6			;                                                                             : 
15e6			; Returns                                                                     : 
15e6			;     Nothing                                                                 : 
15e6			;                                                                             : 
15e6			; Stack frame                                                                 : 
15e6			;       |             |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     BC      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     DE      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     IX      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |  prev_free  |                                                       : 
15e6			;   +2  +-------------+                                                       : 
15e6			;       |  next_free  |                                                       : 
15e6			;   +0  +-------------+                                                       : 
15e6			;       |             |                                                       : 
15e6			;                                                                             : 
15e6			;------------------------------------------------------------------------------ 
15e6			free: 
15e6			      push  BC 
15e6			      push  DE 
15e6			      push  IX 
15e6			 
15e6			      ld    A, H                    ; Exit if ptr is null 
15e6			      or    L 
15e6			      jp    Z, free_early_exit 
15e6			 
15e6			      ; Set up stack frame 
15e6			      ex    DE, HL 
15e6			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15e6			      add   HL, SP 
15e6			      ld    SP, HL 
15e6			      ld    IX, 0                   ; Use IX as a frame pointer 
15e6			      add   IX, SP 
15e6			 
15e6			      ; The address in HL points to the start of the useable allocated space, 
15e6			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15e6			      ; address of the block itself. 
15e6			      ex    DE, HL 
15e6			      ld    DE, -4 
15e6			      add   HL, DE 
15e6			 
15e6			      ; An allocated block must have a null next block pointer in it 
15e6			      ld    A, (HL) 
15e6			      inc   HL 
15e6			      or    (HL) 
15e6			      jp    NZ, free_done 
15e6			 
15e6			      dec   HL 
15e6			 
15e6			      ld    B, H                    ; Copy HL to BC 
15e6			      ld    C, L 
15e6			 
15e6			      ; Loop through the free list to find the first block with an address 
15e6			      ; higher than the block being freed 
15e6			      ld    HL, free_list 
15e6			 
15e6			free_find_higher_block: 
15e6			      ld    E, (HL)                 ; Load next ptr from free block 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      dec   HL 
15e6			 
15e6			      ld    (IX+0), E               ; Save ptr to next free block 
15e6			      ld    (IX+1), D 
15e6			      ld    (IX+2), L               ; Save ptr to prev free block 
15e6			      ld    (IX+3), H 
15e6			 
15e6			      ld    A, B                    ; Check if DE is greater than BC 
15e6			      cp    D                       ; Compare MSB first 
15e6			      jr    Z, $+4                  ; MSB the same, compare LSB 
15e6			      jr    NC, free_find_higher_block_skip 
15e6			      ld    A, C 
15e6			      cp    E                       ; Then compare LSB 
15e6			      jr    C, free_found_higher_block 
15e6			 
15e6			free_find_higher_block_skip: 
15e6			      ld    A, D                    ; Reached the end of the free list? 
15e6			      or    E 
15e6			      jp    Z, free_done 
15e6			 
15e6			      ex    DE, HL 
15e6			 
15e6			      jr    free_find_higher_block 
15e6			 
15e6			free_found_higher_block: 
15e6			      ; Insert freed block between prev and next free blocks 
15e6			      ld    (HL), C                 ; Point prev free block to freed block 
15e6			      inc   HL 
15e6			      ld    (HL), B 
15e6			 
15e6			      ld    H, B                    ; Point freed block at next free block 
15e6			      ld    L, C 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      ; Check if the freed block is adjacent to the next free block 
15e6			      inc   HL                      ; Load size of freed block into HL 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      ex    DE, HL 
15e6			 
15e6			      add   HL, BC                  ; Add addr of freed block and its size 
15e6			 
15e6			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15e6			      ld    D, (IX+1) 
15e6			 
15e6			      or    A                       ; Clear the carry flag 
15e6			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15e6			      jr    NZ, free_check_adjacent_to_prev 
15e6			 
15e6			      ; Freed block is adjacent to next, merge into one bigger block 
15e6			      ex    DE, HL                  ; Load next ptr from next block into DE 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      push  HL                      ; Save ptr to next block for later 
15e6			 
15e6			      ld    H, B                    ; Store ptr from next block into freed block 
15e6			      ld    L, C 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      pop   HL                      ; Restore ptr to next block 
15e6			      inc   HL                      ; Load size of next block into DE 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      push  DE                      ; Save next block size for later 
15e6			 
15e6			      ld    H, B                    ; Load size of freed block into HL 
15e6			      ld    L, C 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      ex    DE, HL 
15e6			 
15e6			      pop   DE                      ; Restore size of next block 
15e6			      add   HL, DE                  ; Add sizes of both blocks 
15e6			      ex    DE, HL 
15e6			 
15e6			      ld    H, B                    ; Store new bigger size into freed block 
15e6			      ld    L, C 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			free_check_adjacent_to_prev: 
15e6			      ; Check if the freed block is adjacent to the prev free block 
15e6			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15e6			      ld    H, (IX+3) 
15e6			 
15e6			      inc   HL                      ; Size of prev free block into DE 
15e6			      inc   HL 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			 
15e6			      add   HL, DE                  ; Add prev block addr and size 
15e6			 
15e6			      or    A                       ; Clear the carry flag 
15e6			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15e6			      jr    NZ, free_done 
15e6			 
15e6			      ; Freed block is adjacent to prev, merge into one bigger block 
15e6			      ld    H, B                    ; Load next ptr from freed block into DE 
15e6			      ld    L, C 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      push  HL                      ; Save freed block ptr for later 
15e6			 
15e6			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15e6			      ld    H, (IX+3) 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      pop   HL                      ; Restore freed block ptr 
15e6			      inc   HL                      ; Load size of freed block into DE 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      push  DE                      ; Save freed block size for later 
15e6			 
15e6			      ld    L, (IX+2)               ; Load size of prev block into DE 
15e6			      ld    H, (IX+3) 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			 
15e6			      pop   HL                      ; Add sizes of both blocks 
15e6			      add   HL, DE 
15e6			      ex    DE, HL 
15e6			 
15e6			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15e6			      ld    H, (IX+3) 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			free_done: 
15e6			      ld    HL, 4                   ; Clean up stack frame 
15e6			      add   HL, SP 
15e6			      ld    SP, HL 
15e6			 
15e6			free_early_exit: 
15e6			      pop   IX 
15e6			      pop   DE 
15e6			      pop   BC 
15e6			 
15e6			      ret 
15e6			 
15e6			 
15e6			;      .org 0x8000 
15e6			; 
15e6			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15e6			 ;                 .dw   0 
15e6			 
15e6			endif 
15e6			 
15e6			 
15e6			if MALLOC_4 
15e6			 
15e6			; My memory allocation code. Very very simple.... 
15e6			; allocate space under 250 chars 
15e6			 
15e6			heap_init: 
15e6				; init start of heap as zero 
15e6				;  
15e6			 
15e6				ld hl, heap_start 
15e6				ld a, 0 
15e6				ld (hl), a      ; empty block 
15e6				inc hl 
15e6				ld a, 0 
15e6				ld (hl), a      ; length of block 
15e6				; write end of list 
15e6				inc hl 
15e6				ld a,(hl) 
15e6				inc hl 
15e6				ld a,(hl) 
15e6				 
15e6			 
15e6				; init some malloc vars 
15e6			 
15e6				ld hl, 0 
15e6				ld (free_list), hl       ; store last malloc location 
15e6			 
15e6				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15e6				ld a, 0 
15e6				ld (hl), a 
15e6			 
15e6			 
15e6				ld hl, heap_start 
15e6				;  
15e6				  
15e6				ret 
15e6			 
15e6			 
15e6			;    free block marker 
15e6			;    requested size  
15e6			;    pointer to next block 
15e6			;    .... 
15e6			;    next block marker 
15e6			 
15e6			 
15e6			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15e6			; 
15e6			 
15e6			 
15e6			malloc:  
15e6				push de 
15e6				push bc 
15e6				push af 
15e6			 
15e6				; hl space required 
15e6				 
15e6				ld c, l    ; hold space   (TODO only a max of 255) 
15e6			 
15e6			;	inc c     ; TODO BUG need to fix memory leak on push str 
15e6			;	inc c 
15e6			;	inc c 
15e6			;	inc c 
15e6			;	inc c 
15e6			;	inc c 
15e6			;	inc c 
15e6			 
15e6			 
15e6			 
15e6				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15e6			 
15e6				ld a, (free_list+3) 
15e6				cp 0 
15e6				jr z, .contheap 
15e6			 
15e6				ld hl, (free_list)     ; get last alloc 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mrs" 
15e6						CALLMONITOR 
15e6					endif 
15e6				jr .startalloc 
15e6			 
15e6			.contheap: 
15e6				ld hl, heap_start 
15e6			 
15e6			.startalloc: 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mym" 
15e6						CALLMONITOR 
15e6					endif 
15e6			.findblock: 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mmf" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6				ld a,(hl)  
15e6				; if byte is zero then clear to use 
15e6			 
15e6				cp 0 
15e6				jr z, .foundemptyblock 
15e6			 
15e6				; if byte is not clear 
15e6				;     then byte is offset to next block 
15e6			 
15e6				inc hl 
15e6				ld a, (hl) ; get size 
15e6			.nextblock:	inc hl 
15e6					ld e, (hl) 
15e6					inc hl 
15e6					ld d, (hl) 
15e6					ex de, hl 
15e6			;	inc hl  ; move past the store space 
15e6			;	inc hl  ; move past zero index  
15e6			 
15e6				; TODO detect no more space 
15e6			 
15e6				push hl 
15e6				ld de, heap_end 
15e6				call cmp16 
15e6				pop hl 
15e6				jr nc, .nospace 
15e6			 
15e6				jr .findblock 
15e6			 
15e6			.nospace: ld hl, 0 
15e6				jp .exit 
15e6			 
15e6			 
15e6			.foundemptyblock:	 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mme" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6			; TODO has block enough space if reusing??? 
15e6			 
15e6				;  
15e6			 
15e6			; see if this block has been previously used 
15e6				inc hl 
15e6				ld a, (hl) 
15e6				dec hl 
15e6				cp 0 
15e6				jr z, .newblock 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "meR" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6			; no reusing previously allocated block 
15e6			 
15e6			; is it smaller than previously used? 
15e6				 
15e6				inc hl    ; move to size 
15e6				ld a, c 
15e6				sub (hl)        ; we want c < (hl) 
15e6				dec hl    ; move back to marker 
15e6			        jr z, .findblock 
15e6			 
15e6				; update with the new size which should be lower 
15e6			 
15e6			        ;inc  hl   ; negate next move. move back to size  
15e6			 
15e6			.newblock: 
15e6				; need to be at marker here 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "meN" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6			 
15e6				ld a, c 
15e6			 
15e6				ld (free_list+3), a	 ; flag resume from last malloc  
15e6				ld (free_list), hl    ; save out last location 
15e6			 
15e6			 
15e6				;inc a     ; space for length byte 
15e6				ld (hl), a     ; save block in use marker 
15e6			 
15e6				inc hl   ; move to space marker 
15e6				ld (hl), a    ; save new space 
15e6			 
15e6				inc hl   ; move to start of allocated area 
15e6				 
15e6			;	push hl     ; save where we are - 1  
15e6			 
15e6			;	inc hl  ; move past zero index  
15e6				; skip space to set down new marker 
15e6			 
15e6				; provide some extra space for now 
15e6			 
15e6				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15e6				inc a 
15e6				inc a 
15e6			 
15e6				push hl   ; save where we are in the node block 
15e6			 
15e6				call addatohl 
15e6			 
15e6				; write linked list point 
15e6			 
15e6				pop de     ; get our node position 
15e6				ex de, hl 
15e6			 
15e6				ld (hl), e 
15e6				inc hl 
15e6				ld (hl), d 
15e6			 
15e6				inc hl 
15e6			 
15e6				; now at start of allocated data so save pointer 
15e6			 
15e6				push hl 
15e6			 
15e6				; jump to position of next node and setup empty header in DE 
15e6			 
15e6				ex de, hl 
15e6			 
15e6			;	inc hl ; move past end of block 
15e6			 
15e6				ld a, 0 
15e6				ld (hl), a   ; empty marker 
15e6				inc hl 
15e6				ld (hl), a   ; size 
15e6				inc hl  
15e6				ld (hl), a   ; ptr 
15e6				inc hl 
15e6				ld (hl), a   ; ptr 
15e6			 
15e6			 
15e6				pop hl 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mmr" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6			.exit: 
15e6				pop af 
15e6				pop bc 
15e6				pop de  
15e6				ret 
15e6			 
15e6			 
15e6			 
15e6			 
15e6			free:  
15e6				push hl 
15e6				push af 
15e6				; get address in hl 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "fre" 
15e6						CALLMONITOR 
15e6					endif 
15e6				; data is at hl - move to block count 
15e6				dec hl 
15e6				dec hl    ; get past pointer 
15e6				dec hl 
15e6			 
15e6				ld a, (hl)    ; need this for a validation check 
15e6			 
15e6				dec hl    ; move to block marker 
15e6			 
15e6				; now check that the block count and block marker are the same  
15e6			        ; this checks that we are on a malloc node and not random memory 
15e6			        ; OK a faint chance this could be a problem but rare - famous last words! 
15e6			 
15e6				ld c, a 
15e6				ld a, (hl)    
15e6			 
15e6				cp c 
15e6				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15e6			 
15e6				; yes good chance we are on a malloc node 
15e6			 
15e6				ld a, 0      
15e6				ld (hl), a   ; mark as free 
15e6			 
15e6				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15e6			 
15e6			.freeignore:  
15e6			 
15e6				pop af 
15e6				pop hl 
15e6			 
15e6				ret 
15e6			 
15e6			 
15e6			 
15e6			endif 
15e6			 
15e6			; eof 
# End of file firmware_memory.asm
15e6			  
15e6			; device C  
15e6			if SOUND_ENABLE  
15e6				include "firmware_sound.asm"  
15e6			; Sound abstraction layer 
15e6			 
15e6			; support different sound chips through common interface 
15e6			 
15e6			SOUND_DEVICE_AY: equ 0 
15e6			 
15e6			SOUND_DEVICE: equ Device_A 
15e6			 
15e6			 
15e6			 
15e6			if SOUND_DEVICE_AY 
15e6				include "firmware_sound_ay38910.asm" 
15e6			else 
15e6				include "firmware_sound_sn76489an.asm" 
15e6			 
15e6			; Device support for SN76489AN sound chip 
15e6			 
15e6			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
15e6			; http://danceswithferrets.org/geekblog/?p=93 
15e6			; https://www.smspower.org/Development/SN76489 
15e6			 
15e6			; D0 [ 3] 
15e6			; D1 [ 2] 
15e6			; D2 [ 1] 
15e6			; D3 [15] 
15e6			; D4 [13] 
15e6			; D5 [12] 
15e6			; D6 [11] 
15e6			; D7 [10] 
15e6			; /WE [ 5] 
15e6			; CLK [14] 
15e6			; /OE [ 6] 
15e6			; AUDIO [ 7] 
15e6			; GND 8 
15e6			; +5 16 
15e6			; 
15e6			 
15e6			; Write sequence: 
15e6			; CE low 
15e6			; Data bus 
15e6			; WE low then high 
15e6			; 32 clock cycles / 8ns write time at 4mhz 
15e6			; 
15e6			; https://github.com/jblang/SN76489 
15e6			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
15e6			; Tried: 
15e6			; 
15e6			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
15e6			; 
15e6			; Connected WE to OR too 
15e6			;  
15e6			; That enabled the clock when required 
15e6			; However still random bus corruption. Need further investigation 
15e6			 
15e6			 
15e6			SOUND_LATCH: equ 10000000B 
15e6			SOUND_DATA: equ 0B 
15e6			SOUND_CH0:  equ 0B    ; Tone 
15e6			SOUND_CH1: equ 0100000B        ; Tone 
15e6			SOUND_CH2: equ 1000000B   ; Tone 
15e6			SOUND_CH3: equ 1100000B    ; Noise 
15e6			SOUND_VOL: equ 10000B 
15e6			SOUND_TONE: equ 0B 
15e6			 
15e6			 
15e6			sound_init: 
15e6 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
15e8 cd fd 15			call note_send_byte 
15eb 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
15ed cd fd 15			call note_send_byte 
15f0 cd 89 0c			call delay250ms 
15f3 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
15f5 cd fd 15			call note_send_byte 
15f8 cd 89 0c			call delay250ms 
15fb c9				ret 
15fc			 
15fc			; Play a note 
15fc			; h = note 
15fc			; l = duration 
15fc			; a = channel 
15fc			 
15fc			 
15fc			;  frequ = clock / ( 2 x reg valu x 32 )  
15fc			 
15fc			note:  
15fc				 
15fc			 
15fc c9				ret 
15fd			 
15fd			note_send_byte: 
15fd				; byte in a 
15fd			 
15fd				; we high 
15fd d3 40			out (Device_B), a 
15ff			;	ld a, 1 
15ff			;	call aDelayInMS 
15ff 00				nop  
1600 00				nop  
1601 00				nop  
1602 00				nop  
1603				; we low 
1603 d3 40			out (Device_B), a 
1605			;	ld a, 1 
1605			;	call aDelayInMS 
1605 00				nop  
1606 00				nop  
1607 00				nop  
1608 00				nop  
1609				; we high 
1609 d3 40			out (Device_B), a 
160b			;	ld a, 1 
160b			;	call aDelayInMS 
160b 00				nop  
160c 00				nop  
160d 00				nop  
160e 00				nop  
160f			 
160f			 
160f c9				ret 
1610			 
1610			;void SilenceAllChannels() 
1610			;{ 
1610			;  SendByte(0x9f); 
1610			;  SendByte(0xbf); 
1610			;  SendByte(0xdf); 
1610			;  SendByte(0xff); 
1610			;} 
1610			 
1610			 
1610			; eof 
1610			 
# End of file firmware_sound_sn76489an.asm
1610			endif 
1610			 
1610			 
1610			; Abstraction entry points 
1610			 
1610			; init  
1610			 
1610			; sound_init in specific hardware files 
1610			 
1610			; Play a note 
1610			; h = note 
1610			; l = duration 
1610			; a = channel 
1610			 
1610			;note:     
1610			;	ret 
1610			 
1610			 
1610			 
1610			 
1610			; eof 
1610			 
# End of file firmware_sound.asm
1610			endif  
1610			  
1610			include "firmware_diags.asm"  
1610			; Hardware diags menu 
1610			 
1610			 
1610			config: 
1610			 
1610 3e 00			ld a, 0 
1612 21 45 16			ld hl, .configmn 
1615 cd 83 0d			call menu 
1618			 
1618 fe 00			cp 0 
161a c8				ret z 
161b			 
161b fe 01			cp 1 
161d cc 87 16			call z, .savetostore 
1620			 
1620 fe 02			cp 2 
1622			if STARTUP_V1 
1622				call z, .selautoload 
1622			endif 
1622			 
1622			if STARTUP_V2 
1622 cc 57 16			call z, .enautoload 
1625			endif 
1625 fe 03			cp 3 
1627 cc 6e 16			call z, .disautoload 
162a fe 04			cp 4 
162c cc 85 16			call z, .selbank 
162f fe 05			cp 5 
1631 cc c2 18			call z, .debug_tog 
1634 fe 06			cp 6 
1636 cc 05 1a			call z, .bpsgo 
1639 fe 07			cp 7 
163b cc e8 18			call z, hardware_diags 
163e			if STARTUP_V2 
163e fe 08			cp 8 
1640 cc 99 16			call z, create_startup 
1643			endif 
1643 18 cb			jr config 
1645			 
1645			.configmn: 
1645 f6 1b			dw prom_c3 
1647 0d 1c			dw prom_c2 
1649 23 1c			dw prom_c2a 
164b 7d 1c			dw prom_c2b 
164d			;	dw prom_c4 
164d 9a 1c			dw prom_m4 
164f b5 1c			dw prom_m4b 
1651 bd 1c			dw prom_c1 
1653			if STARTUP_V2 
1653 cc 1c			dw prom_c9 
1655			endif 
1655 00 00			dw 0 
1657				 
1657			 
1657			if STARTUP_V2 
1657			.enautoload: 
1657				if STORAGE_SE 
1657 3e fe			ld a, $fe      ; bit 0 clear 
1659 32 63 fa			ld (spi_device), a 
165c			 
165c cd cd 04			call storage_get_block_0 
165f			 
165f 3e 01			ld a, 1 
1661 32 9e fa			ld (store_page+STORE_0_AUTOFILE), a 
1664			 
1664 21 00 00				ld hl, 0 
1667 11 7d fa				ld de, store_page 
166a cd 81 04			call storage_write_block	 ; save update 
166d				else 
166d			 
166d				ld hl, prom_notav 
166d				ld de, prom_empty 
166d				call info_panel 
166d				endif 
166d			 
166d			 
166d c9				ret 
166e			endif 
166e			 
166e			.disautoload: 
166e				if STORAGE_SE 
166e 3e fe			ld a, $fe      ; bit 0 clear 
1670 32 63 fa			ld (spi_device), a 
1673			 
1673 cd cd 04			call storage_get_block_0 
1676			 
1676 3e 00			ld a, 0 
1678 32 9e fa			ld (store_page+STORE_0_AUTOFILE), a 
167b			 
167b 21 00 00				ld hl, 0 
167e 11 7d fa				ld de, store_page 
1681 cd 81 04			call storage_write_block	 ; save update 
1684				else 
1684			 
1684				ld hl, prom_notav 
1684				ld de, prom_empty 
1684				call info_panel 
1684				endif 
1684			 
1684			 
1684 c9				ret 
1685			 
1685			if STARTUP_V1 
1685			 
1685			; Select auto start 
1685			 
1685			.selautoload: 
1685			 
1685				 
1685				if STORAGE_SE 
1685			 
1685					call config_dir 
1685				        ld hl, scratch 
1685					ld a, 0 
1685					call menu 
1685			 
1685					cp 0 
1685					ret z 
1685			 
1685					dec a 
1685			 
1685			 
1685					; locate menu option 
1685			 
1685					ld hl, scratch 
1685					call table_lookup 
1685			 
1685					if DEBUG_FORTH_WORDS 
1685						DMARK "ALl" 
1685						CALLMONITOR 
1685					endif 
1685					; with the pointer to the menu it, the byte following the zero term is the file id 
1685			 
1685					ld a, 0 
1685					ld bc, 50   ; max of bytes to look at 
1685					cpir  
1685			 
1685					if DEBUG_FORTH_WORDS 
1685						DMARK "ALb" 
1685						CALLMONITOR 
1685					endif 
1685					;inc hl 
1685			 
1685					ld a, (hl)   ; file id 
1685					 
1685				        ; save bank and file ids 
1685			 
1685					push af 
1685			 
1685			; TODO need to save to block 0 on bank 1	 
1685			 
1685					call storage_get_block_0 
1685			 
1685					if DEBUG_FORTH_WORDS 
1685						DMARK "AL0" 
1685						CALLMONITOR 
1685					endif 
1685					pop af 
1685			 
1685					ld (store_page+STORE_0_FILERUN),a 
1685					 
1685					; save bank id 
1685			 
1685					ld a,(spi_device) 
1685					ld (store_page+STORE_0_BANKRUN),a 
1685			 
1685					; enable auto run of store file 
1685			 
1685					ld a, 1 
1685					ld (store_page+STORE_0_AUTOFILE),a 
1685			 
1685					; save buffer 
1685			 
1685					ld hl, 0 
1685					ld de, store_page 
1685					if DEBUG_FORTH_WORDS 
1685						DMARK "ALw" 
1685						CALLMONITOR 
1685					endif 
1685				call storage_write_block	 ; save update 
1685			  
1685			 
1685			 
1685			 
1685					ld hl, scratch 
1685					call config_fdir 
1685			 
1685				else 
1685			 
1685				ld hl, prom_notav 
1685				ld de, prom_empty 
1685				call info_panel 
1685			 
1685				endif 
1685				ret 
1685			endif 
1685			 
1685			 
1685			; Select storage bank 
1685			 
1685			.selbank: 
1685			 
1685				if STORAGE_SE 
1685				else 
1685			 
1685				ld hl, prom_notav 
1685				ld de, prom_empty 
1685				call info_panel 
1685				endif 
1685				 
1685 c9				ret 
1686			 
1686			if STORAGE_SE 
1686			 
1686			.config_ldir:   
1686				; Load storage bank labels into menu array 
1686			 
1686				 
1686			 
1686			 
1686 c9				ret 
1687			 
1687			 
1687			endif 
1687			 
1687			 
1687			; Save user words to storage 
1687			 
1687			.savetostore: 
1687			 
1687				if STORAGE_SE 
1687			 
1687 cd 0c 18				call config_dir 
168a 21 c4 f1			        ld hl, scratch 
168d 3e 00				ld a, 0 
168f cd 83 0d				call menu 
1692					 
1692 21 c4 f1				ld hl, scratch 
1695 cd f9 17				call config_fdir 
1698			 
1698				else 
1698			 
1698				ld hl, prom_notav 
1698				ld de, prom_empty 
1698				call info_panel 
1698			 
1698				endif 
1698			 
1698 c9				ret 
1699			 
1699			if STARTUP_V2 
1699			 
1699			create_startup: 
1699			 
1699 3e 00			ld a, 0 
169b 21 eb 17			ld hl, .crstart 
169e cd 83 0d			call menu 
16a1			 
16a1 fe 00			cp 0 
16a3 c8				ret z 
16a4			 
16a4 fe 01			cp 1 
16a6 cc c4 16			call z, .genlsword 
16a9 fe 02			cp 2 
16ab cc ce 16			call z, .genedword 
16ae			 
16ae fe 03			cp 3 
16b0 cc d8 16			call z, .gendemword 
16b3			 
16b3 fe 04			cp 4 
16b5 cc e2 16			call z, .genutlword 
16b8 fe 05			cp 5 
16ba cc ec 16			call z, .genspiword 
16bd fe 06			cp 6 
16bf cc f6 16			call z, .genkeyword 
16c2 18 d5			jr create_startup 
16c4			 
16c4			.genlsword: 
16c4 21 3a 1c			ld hl, crs_s1 
16c7 11 57 17			ld de, .lsworddef 
16ca cd 00 17			call .genfile 
16cd c9				ret 
16ce			 
16ce			.genedword: 
16ce 11 5b 17			ld de, .edworddef 
16d1 21 43 1c			ld hl, crs_s2 
16d4 cd 00 17			call .genfile 
16d7 c9				ret 
16d8			 
16d8			.gendemword: 
16d8 11 63 17			ld de, .demoworddef 
16db 21 4c 1c			ld hl, crs_s3 
16de cd 00 17			call .genfile 
16e1 c9				ret 
16e2			 
16e2			.genutlword: 
16e2 21 5b 1c			ld hl, crs_s4 
16e5 11 43 17			ld de, .utilwordef 
16e8 cd 00 17			call .genfile 
16eb c9				ret 
16ec			.genspiword: 
16ec 21 62 1c			ld hl, crs_s5 
16ef 11 a9 17			ld de, .spiworddef 
16f2 cd 00 17			call .genfile 
16f5 c9				ret 
16f6			.genkeyword: 
16f6 21 6e 1c			ld hl, crs_s6 
16f9 11 bf 17			ld de, .keyworddef 
16fc cd 00 17			call .genfile 
16ff c9				ret 
1700			 
1700			; hl - points to file name 
1700			; de - points to strings to add to file 
1700			 
1700			.genfile: 
1700 e5				push hl 
1701 d5				push de 
1702			 
1702 cd 52 0d			call clear_display 
1705 3e 00			ld a, display_row_1 
1707 11 32 17			ld de, .genfiletxt 
170a cd 65 0d			call str_at_display 
170d cd 75 0d			call update_display 
1710			 
1710 d1				pop de 
1711 e1				pop hl 
1712			 
1712			 
1712 d5				push de 
1713 cd 1f 08			call storage_create 
1716				; id in hl 
1716 d1				pop de   ; table of strings to add 
1717			 
1717			.genloop: 
1717			 
1717 e5				push hl ; save id for next time around 
1718 d5				push de ; save de for next time around 
1719			 
1719 eb				ex de, hl 
171a cd fa 23			call loadwordinhl 
171d eb				ex de, hl 
171e			 
171e				; need hl to be the id 
171e				; need de to be the string ptr 
171e				 
171e cd 0c 0b			call storage_append 
1721			 
1721 d1				pop de 
1722 e1				pop hl 
1723			 
1723 13				inc de 
1724 13				inc de 
1725			 
1725 1a				ld a,(de) 
1726 fe 00			cp 0 
1728 20 ed			jr nz, .genloop 
172a 13				inc de 
172b 1a				ld a, (de) 
172c 1b				dec de 
172d fe 00			cp 0 
172f 20 e6			jr nz, .genloop	 
1731			 
1731 c9				ret 
1732			 
1732 .. 00		.genfiletxt:  db "Creating file...",0 
1743			 
1743			.utilwordef: 
1743 28 63			dw strncpy 
1745 04 63			dw type 
1747 d1 62			dw clrstack 
1749 8a 62			dw longread 
174b 89 63			dw start1 
174d 99 63			dw start2 
174f aa 63			dw start3b 
1751 25 64			dw start3c 
1753 85 64			dw list 
1755 00 00			dw 0 
1757			 
1757			.lsworddef: 
1757 aa 63			dw start3b 
1759 00 00			dw 0 
175b			 
175b			.edworddef: 
175b 18 5f			dw edit1 
175d 39 5f			dw edit2 
175f 6e 5f			dw edit3 
1761 00 00			dw 0 
1763			 
1763			.demoworddef: 
1763 cd 68			dw test5 
1765 05 69			dw test6 
1767 3d 69			dw test7 
1769 51 69			dw test8 
176b 7d 69			dw test9 
176d 93 69			dw test10 
176f d7 69			dw game1 
1771 e8 69			dw game1a 
1773 4a 6a			dw game1b 
1775 7f 6a			dw game1c 
1777 b5 6a			dw game1d 
1779 e6 6a			dw game1s 
177b fa 6a			dw game1t 
177d 0f 6b			dw game1f 
177f 43 6b			dw game1z 
1781 87 6b			dw game1zz 
1783 f0 6b			dw ssv2 
1785 26 6c			dw ssv3 
1787 42 6c			dw ssv4 
1789 5e 6c			dw ssv5 
178b 77 6c			dw ssv1 
178d bf 6c			dw ssv1cpm	 
178f 16 6d			dw game2b 
1791 84 6d			dw game2bf 
1793 ce 6d			dw game2mba 
1795 64 6e			dw game2mbas	 
1797 89 6e			dw game2mbht 
1799 98 6e			dw game2mbms 
179b a6 6e			dw game2mb 
179d 23 6f			dw game3w 
179f 51 6f			dw game3p 
17a1 6f 6f			dw game3sc 
17a3 a0 6f			dw game3vsi 
17a5 cc 6f			dw game3vs 
17a7 00 00			dw 0 
17a9			 
17a9			 
17a9			.spiworddef: 
17a9			 
17a9 a6 5f		    dw spi1 
17ab ff 5f		    dw spi2 
17ad 8d 60		    dw spi3 
17af 35 60		    dw spi4 
17b1 60 60		    dw spi5 
17b3 f3 60		    dw spi6 
17b5 48 61		    dw spi7 
17b7			 
17b7 a0 61		    dw spi8 
17b9 bf 61		    dw spi9 
17bb 17 62		    dw spi10 
17bd 00 00		    dw 0 
17bf			 
17bf			.keyworddef: 
17bf			 
17bf 0b 70			dw keyup 
17c1 19 70			dw keydown 
17c3 29 70			dw keyleft 
17c5 39 70			dw keyright 
17c7 4a 70			dw 	keyf1 
17c9 58 70			dw keyf2 
17cb 66 70			dw keyf3 
17cd 74 70			dw keyf4 
17cf 82 70			dw keyf5 
17d1 90 70			dw keyf6 
17d3 9e 70			dw keyf7 
17d5 ac 70			dw keyf8 
17d7 ba 70			dw keyf9 
17d9 c8 70			dw keyf10 
17db d7 70			dw keyf11 
17dd e6 70			dw keyf12 
17df f5 70			dw keytab 
17e1 04 71			dw keycr 
17e3 12 71			dw keyhome 
17e5 22 71			dw keyend 
17e7 31 71			dw keybs 
17e9 00 00			dw 0 
17eb			 
17eb			.crstart: 
17eb 3a 1c			dw crs_s1 
17ed 43 1c			dw crs_s2 
17ef 4c 1c			dw crs_s3 
17f1 5b 1c			dw crs_s4 
17f3 62 1c			dw crs_s5 
17f5 6e 1c			dw crs_s6 
17f7 00 00			dw 0 
17f9			 
17f9			endif 
17f9			 
17f9			 
17f9			if STORAGE_SE 
17f9			 
17f9			config_fdir: 
17f9				; using the scratch dir go through and release the memory allocated for each string 
17f9				 
17f9 21 c4 f1			ld hl, scratch 
17fc 5e			.cfdir:	ld e,(hl) 
17fd 23				inc hl 
17fe 56				ld d,(hl) 
17ff 23				inc hl 
1800			 
1800 eb				ex de, hl 
1801 cd af 0f			call ishlzero 
1804 c8				ret z     ; return on null pointer 
1805 cd 17 15			call free 
1808 eb				ex de, hl 
1809 18 f1			jr .cfdir 
180b			 
180b			 
180b c9				ret 
180c			 
180c			 
180c			config_dir: 
180c			 
180c				; for the config menus that need to build a directory of storage call this routine 
180c				; it will construct a menu in scratch to pass to menu 
180c			 
180c				; open storage device 
180c			 
180c				; execute DIR to build a list of files and their ids into scratch in menu format 
180c				; once the menu has finished then will need to call config_fdir to release the strings 
180c				 
180c				; c = number items 
180c			 
180c				 
180c cd cd 04			call storage_get_block_0 
180f			 
180f 21 7d fa			ld hl, store_page     ; get current id count 
1812 46				ld b, (hl) 
1813 0e 00			ld c, 0    ; count of files   
1815			 
1815			 
1815 21 c4 f1			ld hl, scratch 
1818 22 74 fa			ld (store_tmp2), hl    ; location to poke strings 
181b			 
181b				; check for empty drive 
181b			 
181b 3e 00			ld a, 0 
181d b8				cp b 
181e ca b8 18			jp z, .dirdone 
1821			 
1821				 
1821					if DEBUG_FORTH_WORDS 
1821						DMARK "Cdc" 
1821 f5				push af  
1822 3a 36 18			ld a, (.dmark)  
1825 32 6e fe			ld (debug_mark),a  
1828 3a 37 18			ld a, (.dmark+1)  
182b 32 6f fe			ld (debug_mark+1),a  
182e 3a 38 18			ld a, (.dmark+2)  
1831 32 70 fe			ld (debug_mark+2),a  
1834 18 03			jr .pastdmark  
1836 ..			.dmark: db "Cdc"  
1839 f1			.pastdmark: pop af  
183a			endm  
# End of macro DMARK
183a						CALLMONITOR 
183a cd fb 19			call break_point_state  
183d				endm  
# End of macro CALLMONITOR
183d					endif 
183d			 
183d			 
183d			.diritem:	 
183d c5				push bc 
183e				; for each of the current ids do a search for them and if found push to stack 
183e			 
183e 21 40 00				ld hl, STORE_BLOCK_PHY 
1841 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1843 58					ld e,b 
1844			 
1844 cd 4f 07				call storage_findnextid 
1847			 
1847			 
1847					; if found hl will be non zero 
1847			 
1847 cd af 0f				call ishlzero 
184a 28 69				jr z, .dirnotfound 
184c			 
184c					; increase count 
184c			 
184c c1					pop bc	 
184d 0c					inc c 
184e c5					push bc 
184f					 
184f			 
184f					; get file header and push the file name 
184f			 
184f 11 7d fa				ld de, store_page 
1852 cd 1c 04				call storage_read_block 
1855			 
1855					; push file id to stack 
1855				 
1855 3a 7d fa				ld a, (store_page) 
1858 26 00				ld h, 0 
185a 6f					ld l, a 
185b			 
185b					;call forth_push_numhl 
185b					; TODO store id 
185b			 
185b e5					push hl 
185c			 
185c					; push extent count to stack  
185c				 
185c 21 80 fa				ld hl, store_page+3 
185f			 
185f					; get file name length 
185f			 
185f cd e4 13				call strlenz   
1862			 
1862 23					inc hl   ; cover zero term 
1863 23					inc hl  ; stick the id at the end of the area 
1864			 
1864 e5					push hl 
1865 c1					pop bc    ; move length to bc 
1866			 
1866 cd 4d 14				call malloc 
1869			 
1869					; TODO save malloc area to scratch 
1869			 
1869 eb					ex de, hl 
186a 2a 74 fa				ld hl, (store_tmp2) 
186d 73					ld (hl), e 
186e 23					inc hl 
186f 72					ld (hl), d 
1870 23					inc hl 
1871 22 74 fa				ld (store_tmp2), hl 
1874			 
1874					 
1874			 
1874					;pop hl   ; get source 
1874			;		ex de, hl    ; swap aronund	 
1874			 
1874 21 80 fa				ld hl, store_page+3 
1877					if DEBUG_FORTH_WORDS 
1877						DMARK "CFd" 
1877 f5				push af  
1878 3a 8c 18			ld a, (.dmark)  
187b 32 6e fe			ld (debug_mark),a  
187e 3a 8d 18			ld a, (.dmark+1)  
1881 32 6f fe			ld (debug_mark+1),a  
1884 3a 8e 18			ld a, (.dmark+2)  
1887 32 70 fe			ld (debug_mark+2),a  
188a 18 03			jr .pastdmark  
188c ..			.dmark: db "CFd"  
188f f1			.pastdmark: pop af  
1890			endm  
# End of macro DMARK
1890						CALLMONITOR 
1890 cd fb 19			call break_point_state  
1893				endm  
# End of macro CALLMONITOR
1893					endif 
1893 ed b0				ldir 
1895			 
1895					; de is past string, move back one and store id 
1895					 
1895 1b					dec de 
1896			 
1896					; store file id 
1896			 
1896 e1					pop hl 
1897 eb					ex de,hl 
1898 73					ld (hl), e 
1899			 
1899					if DEBUG_FORTH_WORDS 
1899						DMARK "Cdi" 
1899 f5				push af  
189a 3a ae 18			ld a, (.dmark)  
189d 32 6e fe			ld (debug_mark),a  
18a0 3a af 18			ld a, (.dmark+1)  
18a3 32 6f fe			ld (debug_mark+1),a  
18a6 3a b0 18			ld a, (.dmark+2)  
18a9 32 70 fe			ld (debug_mark+2),a  
18ac 18 03			jr .pastdmark  
18ae ..			.dmark: db "Cdi"  
18b1 f1			.pastdmark: pop af  
18b2			endm  
# End of macro DMARK
18b2						CALLMONITOR 
18b2 cd fb 19			call break_point_state  
18b5				endm  
# End of macro CALLMONITOR
18b5					endif 
18b5					 
18b5			.dirnotfound: 
18b5 c1					pop bc     
18b6 10 85				djnz .diritem 
18b8				 
18b8			.dirdone:	 
18b8			 
18b8 3e 00				ld a, 0 
18ba 2a 74 fa				ld hl, (store_tmp2) 
18bd 77					ld (hl), a 
18be 23					inc hl 
18bf 77					ld (hl), a 
18c0 23					inc hl 
18c1					; push a count of the dir items found 
18c1			 
18c1			;		ld h, 0 
18c1			;		ld l, c 
18c1			 
18c1 c9				ret 
18c2			 
18c2			endif 
18c2			 
18c2			 
18c2			; Settings 
18c2			; Run  
18c2			 
18c2			 
18c2			 
18c2			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
18c2			;;hd_menu2:   db "        2: Editor",0   
18c2			;hd_menu2:   db "        2: Editor       6: Menu",0   
18c2			;hd_menu3:   db "        3: Storage",0 
18c2			;hd_menu4:   db "0=quit  4: Debug",0 
18c2			;hd_don:     db "ON",0 
18c2			;hd_doff:     db "OFF",0 
18c2			; 
18c2			; 
18c2			; 
18c2			;hardware_diags_old:       
18c2			; 
18c2			;.diagmenu: 
18c2			;	call clear_display 
18c2			;	ld a, display_row_1 
18c2			;	ld de, hd_menu1 
18c2			;	call str_at_display 
18c2			; 
18c2			;	ld a, display_row_2 
18c2			;	ld de, hd_menu2 
18c2			;	call str_at_display 
18c2			; 
18c2			;	ld a, display_row_3 
18c2			;	ld de, hd_menu3 
18c2			;	call str_at_display 
18c2			; 
18c2			;	ld a,  display_row_4 
18c2			;	ld de, hd_menu4 
18c2			;	call str_at_display 
18c2			; 
18c2			;	; display debug state 
18c2			; 
18c2			;	ld de, hd_don 
18c2			;	ld a, (os_view_disable) 
18c2			;	cp 0 
18c2			;	jr z, .distog 
18c2			;	ld de, hd_doff 
18c2			;.distog: ld a, display_row_4+17 
18c2			;	call str_at_display 
18c2			; 
18c2			;	call update_display 
18c2			; 
18c2			;	call cin_wait 
18c2			; 
18c2			; 
18c2			; 
18c2			;	cp '4' 
18c2			;	jr nz, .diagn1 
18c2			; 
18c2			;	; debug toggle 
18c2			; 
18c2			;	ld a, (os_view_disable) 
18c2			;	ld b, '*' 
18c2			;	cp 0 
18c2			;	jr z, .debtog 
18c2			;	ld b, 0 
18c2			;.debtog:	 
18c2			;	ld a,b 
18c2			;	ld (os_view_disable),a 
18c2			; 
18c2			;.diagn1: cp '0' 
18c2			;	 ret z 
18c2			; 
18c2			;;	cp '1' 
18c2			;;       jp z, matrix	 
18c2			;;   TODO keyboard matrix test 
18c2			; 
18c2			;	cp '2' 
18c2			;	jp z, .diagedit 
18c2			; 
18c2			;;	cp '6' 
18c2			;;	jp z, .menutest 
18c2			;;if ENABLE_BASIC 
18c2			;;	cp '6' 
18c2			;;	jp z, basic 
18c2			;;endif 
18c2			 ; 
18c2			;	jp .diagmenu 
18c2			; 
18c2			; 
18c2			;	ret 
18c2			 
18c2			 
18c2			.debug_tog: 
18c2 21 09 19			ld hl, .menudebug 
18c5				 
18c5 3a b5 f1			ld a, (os_view_disable) 
18c8 fe 2a			cp '*' 
18ca 20 04			jr nz,.tdon  
18cc 3e 01			ld a, 1 
18ce 18 02			jr .tog1 
18d0 3e 00		.tdon: ld a, 0 
18d2			 
18d2			.tog1: 
18d2 cd 83 0d			call menu 
18d5 fe 00			cp 0 
18d7 c8				ret z 
18d8 fe 01			cp 1    ; disable debug 
18da 28 04			jr z, .dtog0 
18dc 3e 2a			ld a, '*' 
18de 18 02			jr .dtogset 
18e0 3e 00		.dtog0: ld a, 0 
18e2 32 b5 f1		.dtogset:  ld (os_view_disable), a 
18e5 c3 c2 18			jp .debug_tog 
18e8			 
18e8			 
18e8			hardware_diags:       
18e8			 
18e8			.diagm: 
18e8 21 fb 18			ld hl, .menuitems 
18eb 3e 00			ld a, 0 
18ed cd 83 0d			call menu 
18f0			 
18f0 fe 00		         cp 0 
18f2 c8				 ret z 
18f3			 
18f3 fe 02			cp 2 
18f5 ca 54 19			jp z, .diagedit 
18f8			 
18f8			;	cp '6' 
18f8			;	jp z, .menutest 
18f8			;if ENABLE_BASIC 
18f8			;	cp '6' 
18f8			;	jp z, basic 
18f8			;endif 
18f8			  
18f8 c3 e8 18			jp .diagm 
18fb			 
18fb				 
18fb 0f 19		.menuitems:   	dw .m1 
18fd 1a 19				dw .m2 
18ff 21 19				dw .m3 
1901 29 19				dw .m5 
1903 2f 19				dw .m5a 
1905 38 19				dw .m5b 
1907 00 00				dw 0 
1909			 
1909			.menudebug: 
1909 41 19				dw .m6 
190b 4a 19				dw .m7 
190d 00 00				dw 0 
190f			 
190f .. 00		.m1:   db "Key Matrix",0 
191a .. 00		.m2:   db "Editor",0 
1921 .. 00		.m3:   db "Storage",0 
1929 .. 00		.m5:   db "Sound",0 
192f .. 00		.m5a:  db "RAM Test",0 
1938 .. 00		.m5b:  db "LCD Test",0 
1941			 
1941 .. 00		.m6:   db "Debug ON",0 
194a .. 00		.m7:   db "Debug OFF",0 
1954			 
1954			; debug editor 
1954			 
1954			.diagedit: 
1954			 
1954 21 c4 f1			ld hl, scratch 
1957			;	ld bc, 250 
1957			;	ldir 
1957				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1957 3e 00			ld a, 0 
1959 77				ld (hl), a 
195a 23				inc hl 
195b 77				ld (hl), a 
195c 23				inc hl 
195d 77				ld (hl), a 
195e			 
195e cd 52 0d		        call clear_display 
1961 cd 75 0d			call update_display 
1964				;ld a, 1 
1964				;ld (hardware_diag), a 
1964			.diloop: 
1964 3e 00			ld a, display_row_1 
1966 0e 00			ld c, 0 
1968 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
196a 1e 28			ld e, 40 
196c			 
196c 21 c4 f1			ld hl, scratch	 
196f cd b3 0f			call input_str 
1972			 
1972 3e 28			ld a, display_row_2 
1974 11 c4 f1			ld de, scratch 
1977 cd 65 0d			call str_at_display 
197a cd 75 0d			call update_display 
197d			 
197d c3 64 19			jp .diloop 
1980			 
1980			 
1980			; pass word in hl 
1980			; a has display location 
1980			display_word_at: 
1980 f5				push af 
1981 e5				push hl 
1982 7c				ld a,h 
1983 21 c9 f4			ld hl, os_word_scratch 
1986 cd 87 12			call hexout 
1989 e1				pop hl 
198a 7d				ld a,l 
198b 21 cb f4			ld hl, os_word_scratch+2 
198e cd 87 12			call hexout 
1991 21 cd f4			ld hl, os_word_scratch+4 
1994 3e 00			ld a,0 
1996 77				ld (hl),a 
1997 11 c9 f4			ld de,os_word_scratch 
199a f1				pop af 
199b cd 65 0d				call str_at_display 
199e c9				ret 
199f			 
199f			display_ptr_state: 
199f			 
199f				; to restore afterwards 
199f			 
199f d5				push de 
19a0 c5				push bc 
19a1 e5				push hl 
19a2 f5				push af 
19a3			 
19a3				; for use in here 
19a3			 
19a3			;	push bc 
19a3			;	push de 
19a3			;	push hl 
19a3			;	push af 
19a3			 
19a3 cd 52 0d			call clear_display 
19a6			 
19a6 11 79 1b			ld de, .ptrstate 
19a9 3e 00			ld a, display_row_1 
19ab cd 65 0d			call str_at_display 
19ae			 
19ae				; display debug step 
19ae			 
19ae			 
19ae 11 6e fe			ld de, debug_mark 
19b1 3e 26			ld a, display_row_1+display_cols-2 
19b3 cd 65 0d			call str_at_display 
19b6			 
19b6				; display a 
19b6 11 83 1b			ld de, .ptrcliptr 
19b9 3e 28			ld a, display_row_2 
19bb cd 65 0d			call str_at_display 
19be			 
19be f1				pop af 
19bf 2a 43 fa			ld hl,(cli_ptr) 
19c2 3e 30			ld a, display_row_2+8 
19c4 cd 80 19			call display_word_at 
19c7			 
19c7			 
19c7				; display hl 
19c7			 
19c7			 
19c7 11 8b 1b			ld de, .ptrclioptr 
19ca 3e 32			ld a, display_row_2+10 
19cc cd 65 0d			call str_at_display 
19cf			; 
19cf			;	pop hl 
19cf 3e 35			ld a, display_row_2+13 
19d1 2a 41 fa			ld hl,(cli_origptr) 
19d4 cd 80 19			call display_word_at 
19d7			; 
19d7			;	 
19d7			;	; display de 
19d7			 
19d7			;	ld de, .regstatede 
19d7			;	ld a, display_row_3 
19d7			;	call str_at_display 
19d7			 
19d7			;	pop de 
19d7			;	ld h,d 
19d7			;	ld l, e 
19d7			;	ld a, display_row_3+3 
19d7			;	call display_word_at 
19d7			 
19d7			 
19d7				; display bc 
19d7			 
19d7			;	ld de, .regstatebc 
19d7			;	ld a, display_row_3+10 
19d7			;	call str_at_display 
19d7			 
19d7			;	pop bc 
19d7			;	ld h,b 
19d7			;	ld l, c 
19d7			;	ld a, display_row_3+13 
19d7			;	call display_word_at 
19d7			 
19d7			 
19d7				; display dsp 
19d7			 
19d7			;	ld de, .regstatedsp 
19d7			;	ld a, display_row_4 
19d7			;	call str_at_display 
19d7			 
19d7				 
19d7			;	ld hl,(cli_data_sp) 
19d7			;	ld a, display_row_4+4 
19d7			;	call display_word_at 
19d7			 
19d7				; display rsp 
19d7			 
19d7 11 ba 1b			ld de, .regstatersp 
19da 3e 82			ld a, display_row_4+10 
19dc cd 65 0d			call str_at_display 
19df			 
19df				 
19df 2a f5 f9			ld hl,(cli_ret_sp) 
19e2 3e 86			ld a, display_row_4+14 
19e4 cd 80 19			call display_word_at 
19e7			 
19e7 cd 75 0d			call update_display 
19ea			 
19ea cd 95 0c			call delay1s 
19ed cd 95 0c			call delay1s 
19f0 cd 95 0c			call delay1s 
19f3			 
19f3			 
19f3 cd 43 20			call next_page_prompt 
19f6			 
19f6				; restore  
19f6			 
19f6 f1				pop af 
19f7 e1				pop hl 
19f8 c1				pop bc 
19f9 d1				pop de 
19fa c9				ret 
19fb			 
19fb			break_point_state: 
19fb f5				push af 
19fc			 
19fc				; see if disabled 
19fc			 
19fc 3a b5 f1			ld a, (os_view_disable) 
19ff fe 2a			cp '*' 
1a01 20 02			jr nz, .bpsgo 
1a03 f1				pop af 
1a04 c9				ret 
1a05			 
1a05			.bpsgo: 
1a05 f1				pop af 
1a06 f5				push af 
1a07 22 b1 f1			ld (os_view_hl), hl 
1a0a ed 53 af f1		ld (os_view_de), de 
1a0e ed 43 ad f1		ld (os_view_bc), bc 
1a12 e5				push hl 
1a13 6f				ld l, a 
1a14 26 00			ld h, 0 
1a16 22 b3 f1			ld (os_view_af),hl 
1a19			 
1a19 21 b4 fd				ld hl, display_fb0 
1a1c 22 cf fb				ld (display_fb_active), hl 
1a1f e1				pop hl	 
1a20			 
1a20 3e 31			ld a, '1' 
1a22 fe 2a		.bps1:  cp '*' 
1a24 20 03			jr nz, .bps1b 
1a26 32 b5 f1			ld (os_view_disable),a 
1a29 fe 31		.bps1b:  cp '1' 
1a2b 20 14			jr nz, .bps2 
1a2d			 
1a2d				; display reg 
1a2d			 
1a2d				 
1a2d			 
1a2d 3a b3 f1			ld a, (os_view_af) 
1a30 2a b1 f1			ld hl, (os_view_hl) 
1a33 ed 5b af f1		ld de, (os_view_de) 
1a37 ed 4b ad f1		ld bc, (os_view_bc) 
1a3b cd d5 1a			call display_reg_state 
1a3e c3 c1 1a			jp .bpschk 
1a41			 
1a41 fe 32		.bps2:  cp '2' 
1a43 20 08			jr nz, .bps3 
1a45				 
1a45				; display hl 
1a45 2a b1 f1			ld hl, (os_view_hl) 
1a48 cd bf 1b			call display_dump_at_hl 
1a4b			 
1a4b 18 74			jr .bpschk 
1a4d			 
1a4d fe 33		.bps3:  cp '3' 
1a4f 20 08			jr nz, .bps4 
1a51			 
1a51			        ; display de 
1a51 2a af f1			ld hl, (os_view_de) 
1a54 cd bf 1b			call display_dump_at_hl 
1a57			 
1a57 18 68			jr .bpschk 
1a59 fe 34		.bps4:  cp '4' 
1a5b 20 08			jr nz, .bps5 
1a5d			 
1a5d			        ; display bc 
1a5d 2a ad f1			ld hl, (os_view_bc) 
1a60 cd bf 1b			call display_dump_at_hl 
1a63			 
1a63 18 5c			jr .bpschk 
1a65 fe 35		.bps5:  cp '5' 
1a67 20 08		        jr nz, .bps7 
1a69			 
1a69				; display cur ptr 
1a69 2a 43 fa			ld hl, (cli_ptr) 
1a6c cd bf 1b			call display_dump_at_hl 
1a6f			 
1a6f 18 50			jr .bpschk 
1a71 fe 36		.bps7:  cp '6' 
1a73 20 08			jr nz, .bps8b 
1a75				 
1a75				; display cur orig ptr 
1a75 2a 41 fa			ld hl, (cli_origptr) 
1a78 cd bf 1b			call display_dump_at_hl 
1a7b 18 44			jr .bpschk 
1a7d fe 37		.bps8b:  cp '7' 
1a7f 20 08			jr nz, .bps9 
1a81				 
1a81				; display dsp 
1a81 2a f1 f9			ld hl, (cli_data_sp) 
1a84 cd bf 1b			call display_dump_at_hl 
1a87			 
1a87 18 38			jr .bpschk 
1a89 fe 39		.bps9:  cp '9' 
1a8b 20 05			jr nz, .bps8c 
1a8d				 
1a8d				; display SP 
1a8d			;	ld hl, sp 
1a8d cd bf 1b			call display_dump_at_hl 
1a90			 
1a90 18 2f			jr .bpschk 
1a92 fe 38		.bps8c:  cp '8' 
1a94 20 08			jr nz, .bps8d 
1a96				 
1a96				; display rsp 
1a96 2a f5 f9			ld hl, (cli_ret_sp) 
1a99 cd bf 1b			call display_dump_at_hl 
1a9c			 
1a9c 18 23			jr .bpschk 
1a9e fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1aa0 20 05			jr nz, .bps8 
1aa2 cd 39 1e			call monitor 
1aa5			 
1aa5 18 1a			jr .bpschk 
1aa7 fe 30		.bps8:  cp '0' 
1aa9 20 16			jr nz, .bpschk 
1aab			 
1aab 21 13 fd				ld hl, display_fb1 
1aae 22 cf fb				ld (display_fb_active), hl 
1ab1 cd 75 0d				call update_display 
1ab4			 
1ab4				;ld a, (os_view_af) 
1ab4 2a b1 f1			ld hl, (os_view_hl) 
1ab7 ed 5b af f1		ld de, (os_view_de) 
1abb ed 4b ad f1		ld bc, (os_view_bc) 
1abf f1				pop af 
1ac0 c9				ret 
1ac1			 
1ac1			.bpschk:   
1ac1 cd 95 0c			call delay1s 
1ac4 3e 9f		ld a,display_row_4 + display_cols - 1 
1ac6 11 41 20		        ld de, endprg 
1ac9 cd 65 0d			call str_at_display 
1acc cd 75 0d			call update_display 
1acf cd 99 78			call cin_wait 
1ad2			 
1ad2 c3 22 1a			jp .bps1 
1ad5			 
1ad5			 
1ad5			display_reg_state: 
1ad5			 
1ad5				; to restore afterwards 
1ad5			 
1ad5 d5				push de 
1ad6 c5				push bc 
1ad7 e5				push hl 
1ad8 f5				push af 
1ad9			 
1ad9				; for use in here 
1ad9			 
1ad9 c5				push bc 
1ada d5				push de 
1adb e5				push hl 
1adc f5				push af 
1add			 
1add cd 52 0d			call clear_display 
1ae0			 
1ae0 11 95 1b			ld de, .regstate 
1ae3 3e 00			ld a, display_row_1 
1ae5 cd 65 0d			call str_at_display 
1ae8			 
1ae8				; display debug step 
1ae8			 
1ae8			 
1ae8 11 6e fe			ld de, debug_mark 
1aeb 3e 25			ld a, display_row_1+display_cols-3 
1aed cd 65 0d			call str_at_display 
1af0			 
1af0				; display a 
1af0 11 b1 1b			ld de, .regstatea 
1af3 3e 28			ld a, display_row_2 
1af5 cd 65 0d			call str_at_display 
1af8			 
1af8 e1				pop hl 
1af9			;	ld h,0 
1af9			;	ld l, a 
1af9 3e 2b			ld a, display_row_2+3 
1afb cd 80 19			call display_word_at 
1afe			 
1afe			 
1afe				; display hl 
1afe			 
1afe			 
1afe 11 a5 1b			ld de, .regstatehl 
1b01 3e 32			ld a, display_row_2+10 
1b03 cd 65 0d			call str_at_display 
1b06			 
1b06 e1				pop hl 
1b07 3e 35			ld a, display_row_2+13 
1b09 cd 80 19			call display_word_at 
1b0c			 
1b0c				 
1b0c				; display de 
1b0c			 
1b0c 11 a9 1b			ld de, .regstatede 
1b0f 3e 50			ld a, display_row_3 
1b11 cd 65 0d			call str_at_display 
1b14			 
1b14 e1				pop hl 
1b15			;	ld h,d 
1b15			;	ld l, e 
1b15 3e 53			ld a, display_row_3+3 
1b17 cd 80 19			call display_word_at 
1b1a			 
1b1a			 
1b1a				; display bc 
1b1a			 
1b1a 11 ad 1b			ld de, .regstatebc 
1b1d 3e 5a			ld a, display_row_3+10 
1b1f cd 65 0d			call str_at_display 
1b22			 
1b22 e1				pop hl 
1b23			;	ld h,b 
1b23			;	ld l, c 
1b23 3e 5d			ld a, display_row_3+13 
1b25 cd 80 19			call display_word_at 
1b28			 
1b28			 
1b28				; display dsp 
1b28			 
1b28 11 b5 1b			ld de, .regstatedsp 
1b2b 3e 78			ld a, display_row_4 
1b2d cd 65 0d			call str_at_display 
1b30			 
1b30				 
1b30 2a f1 f9			ld hl,(cli_data_sp) 
1b33 3e 7c			ld a, display_row_4+4 
1b35 cd 80 19			call display_word_at 
1b38			 
1b38				; display rsp 
1b38			 
1b38 11 ba 1b			ld de, .regstatersp 
1b3b 3e 82			ld a, display_row_4+10 
1b3d cd 65 0d			call str_at_display 
1b40			 
1b40				 
1b40 2a f5 f9			ld hl,(cli_ret_sp) 
1b43 3e 86			ld a, display_row_4+14 
1b45 cd 80 19			call display_word_at 
1b48			 
1b48 cd 75 0d			call update_display 
1b4b			 
1b4b			;	call delay1s 
1b4b			;	call delay1s 
1b4b			;	call delay1s 
1b4b			 
1b4b			 
1b4b			;	call next_page_prompt 
1b4b			 
1b4b				; restore  
1b4b			 
1b4b f1				pop af 
1b4c e1				pop hl 
1b4d c1				pop bc 
1b4e d1				pop de 
1b4f c9				ret 
1b50			 
1b50 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1b64 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1b79 .. 00		.ptrstate:	db "Ptr State",0 
1b83 .. 00		.ptrcliptr:     db "cli_ptr",0 
1b8b .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1b95 .. 00		.regstate:	db "Reg State (1/0)",0 
1ba5 .. 00		.regstatehl:	db "HL:",0 
1ba9 .. 00		.regstatede:	db "DE:",0 
1bad .. 00		.regstatebc:	db "BC:",0 
1bb1 .. 00		.regstatea:	db "A :",0 
1bb5 .. 00		.regstatedsp:	db "DSP:",0 
1bba .. 00		.regstatersp:	db "RSP:",0 
1bbf			 
1bbf			display_dump_at_hl: 
1bbf e5				push hl 
1bc0 d5				push de 
1bc1 c5				push bc 
1bc2 f5				push af 
1bc3			 
1bc3 22 e7 f4			ld (os_cur_ptr),hl	 
1bc6 cd 52 0d			call clear_display 
1bc9 cd 4b 1f			call dumpcont 
1bcc			;	call delay1s 
1bcc			;	call next_page_prompt 
1bcc			 
1bcc			 
1bcc f1				pop af 
1bcd c1				pop bc 
1bce d1				pop de 
1bcf e1				pop hl 
1bd0 c9				ret 
1bd1			 
1bd1			;if ENABLE_BASIC 
1bd1			;	include "nascombasic.asm" 
1bd1			;	basic: 
1bd1			;	include "forth/FORTH.ASM" 
1bd1			;endif 
1bd1			 
1bd1			; eof 
1bd1			 
1bd1			 
# End of file firmware_diags.asm
1bd1			  
1bd1			include "firmware_prompts.asm"  
1bd1			; Prompts  
1bd1			 
1bd1			; boot messages 
1bd1			 
1bd1 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1be6 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1bf6			 
1bf6			 
1bf6			; config menus 
1bf6			 
1bf6 .. 00		prom_c3: db "Add Dictionary To File",0 
1c0d			 
1c0d			if STARTUP_V1 
1c0d			prom_c2: db "Select Autoload File",0 
1c0d			prom_c2a: db "Disable Autoload File", 0 
1c0d			endif 
1c0d			 
1c0d			if STARTUP_V2 
1c0d .. 00		prom_c2: db "Enable Autoload Files",0 
1c23 .. 00		prom_c2a: db "Disable Autoload Files", 0 
1c3a			 
1c3a .. 00		crs_s1: db "*ls-word", 0 
1c43 .. 00		crs_s2: db "*ed-word", 0 
1c4c .. 00		crs_s3: db "*Demo-Programs", 0 
1c5b .. 00		crs_s4: db "*Utils", 0 
1c62 .. 00		crs_s5: db "*SPI-Addons", 0 
1c6e .. 00		crs_s6: db "*Key-constants", 0 
1c7d			 
1c7d			 
1c7d			 
1c7d			endif 
1c7d .. 00		prom_c2b: db "Select Storage Bank",0 
1c91 .. 00		prom_c4: db "Settings",0 
1c9a .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1cb5 .. 00		prom_m4b:   db "Monitor",0 
1cbd .. 00		prom_c1: db "Hardware Diags",0 
1ccc			 
1ccc			 
1ccc			if STARTUP_V2 
1ccc .. 00		prom_c9: db "Create Startup Files",0 
1ce1			endif 
1ce1			 
1ce1 .. 00		prom_notav:    db "Feature not available",0 
1cf7 .. 00		prom_empty:    db "",0 
1cf8			 
1cf8			; eof 
1cf8			 
# End of file firmware_prompts.asm
1cf8			  
1cf8			  
1cf8			; eof  
1cf8			  
# End of file firmware.asm
1cf8			 
1cf8			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1cf8			;if BASE_KEV  
1cf8			;baseram: equ 08000h 
1cf8			;endif 
1cf8			 
1cf8			;if BASE_SC114 
1cf8			;baseram:     equ    endofcode 
1cf8			;endif 
1cf8			 
1cf8			 
1cf8			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1cf8			 
1cf8			; start system 
1cf8			 
1cf8			coldstart: 
1cf8				; set sp 
1cf8				; di/ei 
1cf8			 
1cf8 f3				di 
1cf9 31 fd ff			ld sp, tos 
1cfc			;	ei 
1cfc			 
1cfc				; init spinner 
1cfc 3e 00			ld a,0 
1cfe 32 c9 fb			ld (display_active), a 
1d01			 
1d01				; disable breakpoint by default 
1d01			 
1d01 3e 2a			ld a,'*' 
1d03 32 b5 f1			ld (os_view_disable),a 
1d06			 
1d06				; init hardware 
1d06			 
1d06				; init keyboard and screen hardware 
1d06			 
1d06 cd 1c 00			call hardware_init 
1d09			 
1d09			 
1d09 cd 95 0c			call delay1s 
1d0c 3e 58			ld a, display_row_3+8 
1d0e 11 03 00			ld de, buildtime 
1d11 cd 65 0d			call str_at_display 
1d14 cd 75 0d			call update_display 
1d17			 
1d17 cd 95 0c			call delay1s 
1d1a cd 95 0c			call delay1s 
1d1d cd 95 0c			call delay1s 
1d20			 
1d20				; detect if any keys are held down to enable breakpoints at start up 
1d20			 
1d20 cd aa 78			call cin  
1d23 fe 00			cp 0 
1d25 28 03			jr z, .nokeys 
1d27			 
1d27				;call hardware_diags 
1d27 cd 10 16			call config 
1d2a			 
1d2a			;	ld de, .bpen 
1d2a			;	ld a, display_row_4 
1d2a			;	call str_at_display 
1d2a			;	call update_display 
1d2a			; 
1d2a			;	ld a,0 
1d2a			;	ld (os_view_disable),a 
1d2a			; 
1d2a			;.bpwait: 
1d2a			;	call cin 
1d2a			;	cp 0 
1d2a			;	jr z, .bpwait 
1d2a			;	jr .nokeys 
1d2a			; 
1d2a			; 
1d2a			;.bpen:  db "Break points enabled!",0 
1d2a			 
1d2a			 
1d2a			 
1d2a			 
1d2a			 
1d2a			 
1d2a			.nokeys: 
1d2a			 
1d2a			 
1d2a				 
1d2a			 
1d2a			;jp  testkey 
1d2a			 
1d2a			;call storage_get_block_0 
1d2a			; 
1d2a			;ld hl, 0 
1d2a			;ld de, store_page 
1d2a			;call storage_read_block 
1d2a			 
1d2a				 
1d2a			;ld hl, 10 
1d2a			;ld de, store_page 
1d2a			;call storage_read_block 
1d2a			 
1d2a			 
1d2a			 
1d2a			 
1d2a			 
1d2a			;stop:	nop 
1d2a			;	jp stop 
1d2a			 
1d2a			 
1d2a			 
1d2a			main: 
1d2a cd 52 0d			call clear_display 
1d2d cd 75 0d			call update_display 
1d30			 
1d30			 
1d30			 
1d30			;	call testlcd 
1d30			 
1d30			 
1d30			 
1d30 cd 48 24			call forth_init 
1d33			 
1d33			 
1d33			warmstart: 
1d33 cd 1e 24			call forth_warmstart 
1d36			 
1d36				; run startup word load 
1d36			        ; TODO prevent this running at warmstart after crash  
1d36			 
1d36				if STARTUP_ENABLE 
1d36			 
1d36					if STARTUP_V1 
1d36			 
1d36						if STORAGE_SE 
1d36							call forth_autoload 
1d36						endif 
1d36						call forth_startup 
1d36					endif 
1d36			 
1d36					if STARTUP_V2 
1d36			 
1d36						if STORAGE_SE 
1d36 cd 61 73						call forth_autoload 
1d39						else 
1d39							call forth_startup 
1d39						endif 
1d39			 
1d39			 
1d39					endif 
1d39			 
1d39				endif 
1d39			 
1d39				; show free memory after boot 
1d39 11 d3 1d			ld de, freeram 
1d3c 3e 00			ld a, display_row_1 
1d3e cd 65 0d			call str_at_display 
1d41			 
1d41			; Or use heap_size word???? 
1d41 21 aa f1			ld hl, heap_end 
1d44 11 0e 80			ld de, heap_start 
1d47 ed 52			sbc hl, de 
1d49 e5				push hl 
1d4a 7c				ld a,h	         	 
1d4b 21 c9 f4			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1d4e cd 87 12			call hexout 
1d51 e1			   	pop hl 
1d52			 
1d52 7d				ld a,l 
1d53 21 cb f4			ld hl, os_word_scratch+2 
1d56 cd 87 12			call hexout 
1d59 21 cd f4			ld hl, os_word_scratch+4 
1d5c 3e 00			ld a, 0 
1d5e 77				ld (hl),a 
1d5f 11 c9 f4			ld de, os_word_scratch 
1d62 3e 0d			ld a, display_row_1 + 13 
1d64 cd 65 0d			call str_at_display 
1d67 cd 75 0d			call update_display 
1d6a			 
1d6a			 
1d6a				;call demo 
1d6a			 
1d6a			 
1d6a				; init scratch input area for cli commands 
1d6a			 
1d6a 21 eb f4			ld hl, os_cli_cmd 
1d6d 3e 00			ld a,0 
1d6f 77				ld (hl),a 
1d70 23				inc hl 
1d71 77				ld (hl),a 
1d72			 
1d72 3e 00			ld a,0 
1d74 32 ea f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1d77			 
1d77 32 e7 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1d7a 32 e8 f4			ld (os_cur_ptr+1),a	 
1d7d			 
1d7d 32 c9 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1d80 32 ca f4			ld (os_word_scratch+1),a	 
1d83				 
1d83			 
1d83				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d83 21 eb f4			ld hl, os_cli_cmd 
1d86			 
1d86 3e 00			ld a, 0		 ; init cli input 
1d88 77				ld (hl), a 
1d89 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d8b			cli: 
1d8b				; show cli prompt 
1d8b				;push af 
1d8b				;ld a, 0 
1d8b				;ld de, prompt 
1d8b				;call str_at_display 
1d8b			 
1d8b				;call update_display 
1d8b				;pop af 
1d8b				;inc a 
1d8b				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d8b 0e 00			ld c, 0 
1d8d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1d8f 1e 28			ld e, 40 
1d91			 
1d91 21 eb f4			ld hl, os_cli_cmd 
1d94			 
1d94				STACKFRAME OFF $fefe $9f9f 
1d94				if DEBUG_STACK_IMB 
1d94					if OFF 
1d94						exx 
1d94						ld de, $fefe 
1d94						ld a, d 
1d94						ld hl, curframe 
1d94						call hexout 
1d94						ld a, e 
1d94						ld hl, curframe+2 
1d94						call hexout 
1d94						ld hl, $fefe 
1d94						push hl 
1d94						ld hl, $9f9f 
1d94						push hl 
1d94						exx 
1d94					endif 
1d94				endif 
1d94			endm 
# End of macro STACKFRAME
1d94			 
1d94 cd b3 0f			call input_str 
1d97			 
1d97				STACKFRAMECHK OFF $fefe $9f9f 
1d97				if DEBUG_STACK_IMB 
1d97					if OFF 
1d97						exx 
1d97						ld hl, $9f9f 
1d97						pop de   ; $9f9f 
1d97						call cmp16 
1d97						jr nz, .spnosame 
1d97						ld hl, $fefe 
1d97						pop de   ; $fefe 
1d97						call cmp16 
1d97						jr z, .spfrsame 
1d97						.spnosame: call showsperror 
1d97						.spfrsame: nop 
1d97						exx 
1d97					endif 
1d97				endif 
1d97			endm 
# End of macro STACKFRAMECHK
1d97			 
1d97				; copy input to last command 
1d97			 
1d97 21 eb f4			ld hl, os_cli_cmd 
1d9a 11 ea f5			ld de, os_last_cmd 
1d9d 01 ff 00			ld bc, 255 
1da0 ed b0			ldir 
1da2			 
1da2				; wipe current buffer 
1da2			 
1da2			;	ld a, 0 
1da2			;	ld hl, os_cli_cmd 
1da2			;	ld de, os_cli_cmd+1 
1da2			;	ld bc, 254 
1da2			;	ldir 
1da2				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1da2			;	call strcpy 
1da2			;	ld a, 0 
1da2			;	ld (hl), a 
1da2			;	inc hl 
1da2			;	ld (hl), a 
1da2			;	inc hl 
1da2			;	ld (hl), a 
1da2			 
1da2				; switch frame buffer to program  
1da2			 
1da2 21 13 fd				ld hl, display_fb1 
1da5 22 cf fb				ld (display_fb_active), hl 
1da8			 
1da8			;	nop 
1da8				STACKFRAME ON $fbfe $8f9f 
1da8				if DEBUG_STACK_IMB 
1da8					if ON 
1da8						exx 
1da8						ld de, $fbfe 
1da8						ld a, d 
1da8						ld hl, curframe 
1da8						call hexout 
1da8						ld a, e 
1da8						ld hl, curframe+2 
1da8						call hexout 
1da8						ld hl, $fbfe 
1da8						push hl 
1da8						ld hl, $8f9f 
1da8						push hl 
1da8						exx 
1da8					endif 
1da8				endif 
1da8			endm 
# End of macro STACKFRAME
1da8				; first time into the parser so pass over the current scratch pad 
1da8 21 eb f4			ld hl,os_cli_cmd 
1dab				; tokenise the entered statement(s) in HL 
1dab cd c6 24			call forthparse 
1dae			        ; exec forth statements in top of return stack 
1dae cd 06 25			call forthexec 
1db1				;call forthexec_cleanup 
1db1			;	call parsenext 
1db1			 
1db1				STACKFRAMECHK ON $fbfe $8f9f 
1db1				if DEBUG_STACK_IMB 
1db1					if ON 
1db1						exx 
1db1						ld hl, $8f9f 
1db1						pop de   ; $8f9f 
1db1						call cmp16 
1db1						jr nz, .spnosame 
1db1						ld hl, $fbfe 
1db1						pop de   ; $fbfe 
1db1						call cmp16 
1db1						jr z, .spfrsame 
1db1						.spnosame: call showsperror 
1db1						.spfrsame: nop 
1db1						exx 
1db1					endif 
1db1				endif 
1db1			endm 
# End of macro STACKFRAMECHK
1db1				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1db1			 
1db1 3e 78			ld a, display_row_4 
1db3 11 e5 1d			ld de, endprog 
1db6			 
1db6 cd 75 0d			call update_display		 
1db9			 
1db9 cd 43 20			call next_page_prompt 
1dbc			 
1dbc				; switch frame buffer to cli 
1dbc			 
1dbc 21 b4 fd				ld hl, display_fb0 
1dbf 22 cf fb				ld (display_fb_active), hl 
1dc2			 
1dc2			 
1dc2 cd 52 0d		        call clear_display 
1dc5 cd 75 0d			call update_display		 
1dc8			 
1dc8 21 eb f4			ld hl, os_cli_cmd 
1dcb			 
1dcb 3e 00			ld a, 0		 ; init cli input 
1dcd 77				ld (hl), a 
1dce			 
1dce				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1dce			 
1dce				; now on last line 
1dce			 
1dce				; TODO scroll screen up 
1dce			 
1dce				; TODO instead just clear screen and place at top of screen 
1dce			 
1dce			;	ld a, 0 
1dce			;	ld (f_cursor_ptr),a 
1dce			 
1dce				;call clear_display 
1dce				;call update_display 
1dce			 
1dce				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1dce 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1dd0 c3 8b 1d			jp cli 
1dd3			 
1dd3 .. 00		freeram: db "Free bytes: $",0 
1de1 ..			asc: db "1A2F" 
1de5 .. 00		endprog: db "End prog...",0 
1df1			 
1df1			testenter2:   
1df1 21 f6 f1			ld hl,scratch+50 
1df4 22 e7 f4			ld (os_cur_ptr),hl 
1df7 c3 8b 1d			jp cli 
1dfa			 
1dfa			testenter:  
1dfa			 
1dfa 21 e1 1d			ld hl,asc 
1dfd			;	ld a,(hl) 
1dfd			;	call nibble2val 
1dfd cd dd 12			call get_byte 
1e00			 
1e00			 
1e00			;	ld a,(hl) 
1e00			;	call atohex 
1e00			 
1e00			;	call fourehexhl 
1e00 32 f6 f1			ld (scratch+50),a 
1e03			 
1e03			 
1e03			 
1e03 21 e3 1d			ld hl,asc+2 
1e06			;	ld a, (hl) 
1e06			;	call nibble2val 
1e06 cd dd 12			call get_byte 
1e09			 
1e09			;	call fourehexhl 
1e09 32 f8 f1			ld (scratch+52),a 
1e0c				 
1e0c 21 f6 f1			ld hl,scratch+50 
1e0f 22 e7 f4			ld (os_cur_ptr),hl 
1e12 c3 8b 1d			jp cli 
1e15			 
1e15			enter:	 
1e15 3a c8 f1			ld a,(scratch+4) 
1e18 fe 00			cp 0 
1e1a 28 0c			jr z, .entercont 
1e1c				; no, not a null term line so has an address to work out.... 
1e1c			 
1e1c 21 c6 f1			ld hl,scratch+2 
1e1f cd 3d 13			call get_word_hl 
1e22			 
1e22 22 e7 f4			ld (os_cur_ptr),hl	 
1e25 c3 8b 1d			jp cli 
1e28			 
1e28			 
1e28			.entercont:  
1e28			 
1e28 21 c6 f1			ld hl, scratch+2 
1e2b cd dd 12			call get_byte 
1e2e			 
1e2e 2a e7 f4		   	ld hl,(os_cur_ptr) 
1e31 77					ld (hl),a 
1e32 23					inc hl 
1e33 22 e7 f4				ld (os_cur_ptr),hl 
1e36				 
1e36			; get byte  
1e36			 
1e36			 
1e36 c3 8b 1d			jp cli 
1e39			 
1e39			 
1e39			; basic monitor support 
1e39			 
1e39			monitor: 
1e39				;  
1e39 cd 52 0d			call clear_display 
1e3c 3e 00			ld a, 0 
1e3e 11 86 1e			ld de, .monprompt 
1e41 cd 65 0d			call str_at_display 
1e44 cd 75 0d			call update_display 
1e47			 
1e47				; get a monitor command 
1e47			 
1e47 0e 00			ld c, 0     ; entry at top left 
1e49 16 64			ld d, 100   ; max buffer size 
1e4b 1e 0f			ld e, 15    ; input scroll area 
1e4d 3e 00			ld a, 0     ; init string 
1e4f 21 c2 f3			ld hl, os_input 
1e52 77				ld (hl), a 
1e53 23				inc hl 
1e54 77				ld (hl), a 
1e55 21 c2 f3			ld hl, os_input 
1e58 3e 01			ld a, 1     ; init string 
1e5a cd b3 0f			call input_str 
1e5d			 
1e5d cd 52 0d		        call clear_display 
1e60 cd 75 0d			call update_display		 
1e63			 
1e63 3a c2 f3			ld a, (os_input) 
1e66 cd db 13			call toUpper 
1e69 fe 48		        cp 'H' 
1e6b 28 6f		        jr z, .monhelp 
1e6d fe 44			cp 'D'		; dump 
1e6f ca fd 1e			jp z, .mondump	 
1e72 fe 43			cp 'C'		; dump 
1e74 ca 17 1f			jp z, .moncdump	 
1e77 fe 4d			cp 'M'		; dump 
1e79 ca 88 1e			jp z, .moneditstart 
1e7c fe 55			cp 'U'		; dump 
1e7e 28 14			jr z, .monedit	 
1e80 fe 51			cp 'Q'		; dump 
1e82 c8				ret z	 
1e83			 
1e83			 
1e83				; TODO "S" to access symbol by name and not need the address 
1e83				; TODO "F" to find a string in memory 
1e83			 
1e83 c3 39 1e			jp monitor 
1e86			 
1e86 .. 00		.monprompt: db ">", 0 
1e88			 
1e88			.moneditstart: 
1e88				; get starting address 
1e88			 
1e88 21 c4 f3			ld hl,os_input+2 
1e8b cd 3d 13			call get_word_hl 
1e8e			 
1e8e 22 e7 f4			ld (os_cur_ptr),hl	 
1e91			 
1e91 c3 39 1e			jp monitor 
1e94			 
1e94			.monedit: 
1e94				; get byte to load 
1e94			 
1e94 21 c4 f3			ld hl,os_input+2 
1e97 cd dd 12			call get_byte 
1e9a			 
1e9a				; get address to update 
1e9a 2a e7 f4			ld hl, (os_cur_ptr) 
1e9d			 
1e9d				; update byte 
1e9d			 
1e9d 77				ld (hl), a 
1e9e			 
1e9e				; move to next address and save it 
1e9e			 
1e9e 23				inc hl 
1e9f 22 e7 f4			ld (os_cur_ptr),hl	 
1ea2			 
1ea2 c3 39 1e			jp monitor 
1ea5			 
1ea5			 
1ea5 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1eb9 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1ed5 .. 00		.monhelptext3:  db "Q-Quit",0 
1edc			        
1edc			.monhelp: 
1edc 3e 00			ld a, display_row_1 
1ede 11 a5 1e		        ld de, .monhelptext1 
1ee1			 
1ee1 cd 65 0d			call str_at_display 
1ee4 3e 28			ld a, display_row_2 
1ee6 11 b9 1e		        ld de, .monhelptext2 
1ee9					 
1ee9 cd 65 0d			call str_at_display 
1eec 3e 50			ld a, display_row_3 
1eee 11 d5 1e		        ld de, .monhelptext3 
1ef1					 
1ef1 cd 65 0d			call str_at_display 
1ef4 cd 75 0d			call update_display		 
1ef7			 
1ef7 cd 43 20			call next_page_prompt 
1efa c3 39 1e			jp monitor 
1efd			 
1efd			.mondump:    
1efd 21 c4 f3			ld hl,os_input+2 
1f00 cd 3d 13			call get_word_hl 
1f03			 
1f03 22 e7 f4			ld (os_cur_ptr),hl	 
1f06 cd 4b 1f			call dumpcont 
1f09 3e 78			ld a, display_row_4 
1f0b 11 e5 1d			ld de, endprog 
1f0e			 
1f0e cd 75 0d			call update_display		 
1f11			 
1f11 cd 43 20			call next_page_prompt 
1f14 c3 39 1e			jp monitor 
1f17			.moncdump: 
1f17 cd 4b 1f			call dumpcont 
1f1a 3e 78			ld a, display_row_4 
1f1c 11 e5 1d			ld de, endprog 
1f1f			 
1f1f cd 75 0d			call update_display		 
1f22			 
1f22 cd 43 20			call next_page_prompt 
1f25 c3 39 1e			jp monitor 
1f28			 
1f28			 
1f28			; TODO symbol access  
1f28			 
1f28			.symbols:     ;; A list of symbols that can be called up  
1f28 b4 fd			dw display_fb0 
1f2a .. 00			db "fb0",0  
1f2e 7d fa		     	dw store_page 
1f30 .. 00			db "store_page",0 
1f3b			 
1f3b			 
1f3b			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1f3b			 
1f3b 3a c5 f1			ld a,(scratch+1) 
1f3e fe 00			cp 0 
1f40 28 09			jr z, dumpcont 
1f42			 
1f42				; no, not a null term line so has an address to work out.... 
1f42			 
1f42 21 c6 f1			ld hl,scratch+2 
1f45 cd 3d 13			call get_word_hl 
1f48			 
1f48 22 e7 f4			ld (os_cur_ptr),hl	 
1f4b			 
1f4b			 
1f4b			 
1f4b			dumpcont: 
1f4b			 
1f4b				; dump bytes at ptr 
1f4b			 
1f4b			 
1f4b 3e 00			ld a, display_row_1 
1f4d 2a cf fb			ld hl, (display_fb_active) 
1f50 cd 86 0f			call addatohl 
1f53 cd 7b 1f			call .dumpbyterow 
1f56			 
1f56 3e 28			ld a, display_row_2 
1f58 2a cf fb			ld hl, (display_fb_active) 
1f5b cd 86 0f			call addatohl 
1f5e cd 7b 1f			call .dumpbyterow 
1f61			 
1f61			 
1f61 3e 50			ld a, display_row_3 
1f63 2a cf fb			ld hl, (display_fb_active) 
1f66 cd 86 0f			call addatohl 
1f69 cd 7b 1f			call .dumpbyterow 
1f6c			 
1f6c 3e 78			ld a, display_row_4 
1f6e 2a cf fb			ld hl, (display_fb_active) 
1f71 cd 86 0f			call addatohl 
1f74 cd 7b 1f			call .dumpbyterow 
1f77			 
1f77 cd 75 0d			call update_display 
1f7a			;		jp cli 
1f7a c9				ret 
1f7b			 
1f7b			.dumpbyterow: 
1f7b			 
1f7b				;push af 
1f7b			 
1f7b e5				push hl 
1f7c			 
1f7c				; calc where to poke the ascii 
1f7c			if display_cols == 20 
1f7c				ld a, 16 
1f7c			else 
1f7c 3e 1f			ld a, 31 
1f7e			endif 
1f7e			 
1f7e cd 86 0f			call addatohl 
1f81 22 c9 f4			ld (os_word_scratch),hl  		; save pos for later 
1f84			 
1f84			 
1f84			; display decoding address 
1f84 2a e7 f4		   	ld hl,(os_cur_ptr) 
1f87			 
1f87 7c				ld a,h 
1f88 e1				pop hl 
1f89 e5				push hl 
1f8a			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1f8a cd 87 12			call hexout 
1f8d 2a e7 f4		   	ld hl,(os_cur_ptr) 
1f90			 
1f90 7d				ld a,l 
1f91 e1				pop hl 
1f92 23				inc hl 
1f93 23				inc hl 
1f94 e5				push hl 
1f95			;	ld hl, os_word_scratch+2 
1f95 cd 87 12			call hexout 
1f98 e1				pop hl 
1f99 23				inc hl 
1f9a 23				inc hl 
1f9b				;ld hl, os_word_scratch+4 
1f9b 3e 3a			ld a, ':' 
1f9d 77				ld (hl),a 
1f9e 23				inc hl 
1f9f				;ld a, 0 
1f9f				;ld (hl),a 
1f9f				;ld de, os_word_scratch 
1f9f				;pop af 
1f9f				;push af 
1f9f			;		ld a, display_row_2 
1f9f			;		call str_at_display 
1f9f			;		call update_display 
1f9f			 
1f9f			 
1f9f			;pop af 
1f9f			;	add 5 
1f9f			 
1f9f			if display_cols == 20 
1f9f				ld b, 4 
1f9f			else 
1f9f 06 08			ld b, 8 
1fa1			endif	 
1fa1			 
1fa1			.dumpbyte: 
1fa1 c5				push bc 
1fa2 e5				push hl 
1fa3			 
1fa3			 
1fa3 2a e7 f4		   	ld hl,(os_cur_ptr) 
1fa6 7e					ld a,(hl) 
1fa7			 
1fa7					; poke the ascii to display 
1fa7 2a c9 f4				ld hl,(os_word_scratch) 
1faa 77					ld (hl),a 
1fab 23					inc hl 
1fac 22 c9 f4				ld (os_word_scratch),hl 
1faf			 
1faf					 
1faf			 
1faf			 
1faf e1					pop hl 
1fb0 e5					push hl 
1fb1			 
1fb1 cd 87 12				call hexout 
1fb4			 
1fb4					 
1fb4 2a e7 f4		   	ld hl,(os_cur_ptr) 
1fb7 23				inc hl 
1fb8 22 e7 f4		   	ld (os_cur_ptr),hl 
1fbb			 
1fbb e1					pop hl 
1fbc 23					inc hl 
1fbd 23					inc hl 
1fbe 23					inc hl 
1fbf			 
1fbf			 
1fbf			 
1fbf					;ld a,0 
1fbf					;ld (os_word_scratch+2),a 
1fbf					;pop af 
1fbf					;push af 
1fbf			 
1fbf					;ld de, os_word_scratch 
1fbf					;call str_at_display 
1fbf			;		call update_display 
1fbf			;		pop af 
1fbf c1					pop bc 
1fc0 c6 03				add 3 
1fc2 10 dd			djnz .dumpbyte 
1fc4			 
1fc4				 
1fc4			 
1fc4 c9				ret 
1fc5			 
1fc5			jump:	 
1fc5			 
1fc5 21 c6 f1			ld hl,scratch+2 
1fc8 cd 3d 13			call get_word_hl 
1fcb				;ld hl,(scratch+2) 
1fcb				;call fourehexhl 
1fcb			 
1fcb 22 e7 f4			ld (os_cur_ptr),hl	 
1fce			 
1fce e9				jp (hl) 
1fcf			 
1fcf			 
1fcf			 
1fcf			; TODO implement a basic monitor mode to start with 
1fcf			 
1fcf			 
1fcf			 
1fcf			 
1fcf			 
1fcf			 
1fcf			 
1fcf			 
1fcf			 
1fcf			; testing and demo code during development 
1fcf			 
1fcf			 
1fcf .. 00		str1: db "Enter some text...",0 
1fe2 .. 00		clear: db "                    ",0 
1ff7			 
1ff7			demo: 
1ff7			 
1ff7			 
1ff7			 
1ff7			;	call update_display 
1ff7			 
1ff7				; init scratch input area for testing 
1ff7 21 c4 f1			ld hl, scratch	 
1ffa 3e 00			ld a,0 
1ffc 77				ld (hl),a 
1ffd			 
1ffd			 
1ffd 3e 28		            LD   A, display_row_2 
1fff			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fff 11 cf 1f		            LD   DE, str1 
2002 cd 65 0d			call str_at_display 
2005			 
2005			;            CALL fLCD_Str       ;Display string pointed to by DE 
2005			cloop:	 
2005 3e 50		            LD   A, display_row_3 
2007			;            CALL fLCD_Pos       ;Position cursor to location in A 
2007 11 e2 1f		            LD   DE, clear 
200a			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
200a cd 65 0d				call str_at_display 
200d 3e 78			ld a, display_row_4 
200f 11 3f 20			ld de, prompt 
2012			 
2012 cd 65 0d				call str_at_display 
2015 cd 75 0d			call update_display 
2018			 
2018 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
201a 16 0a			ld d, 10 
201c 21 c4 f1			ld hl, scratch	 
201f cd b3 0f			call input_str 
2022			 
2022			;	call clear_display 
2022			;'	call update_display 
2022			 
2022 3e 00		            LD   A, display_row_1 
2024			;            CALL fLCD_Pos       ;Position cursor to location in A 
2024 11 e2 1f		            LD   DE, clear 
2027 cd 65 0d				call str_at_display 
202a			;            CALL fLCD_Str       ;Display string pointed to by DE 
202a 3e 00		            LD   A, display_row_1 
202c			;            CALL fLCD_Pos       ;Position cursor to location in A 
202c 11 c4 f1		            LD   DE, scratch 
202f			;            CALL fLCD_Str       ;Display string pointed to by DE 
202f cd 65 0d				call str_at_display 
2032 cd 75 0d			call update_display 
2035			 
2035 3e 00				ld a,0 
2037 21 c4 f1			ld hl, scratch 
203a 77				ld (hl),a 
203b			 
203b 00				nop 
203c c3 05 20			jp cloop 
203f			 
203f			 
203f			 
203f			; OS Prompt 
203f			 
203f .. 00		prompt: db ">",0 
2041 .. 00		endprg: db "?",0 
2043			 
2043			 
2043			; handy next page prompt 
2043			next_page_prompt: 
2043 e5				push hl 
2044 d5				push de 
2045 f5				push af 
2046 c5				push bc 
2047			 
2047 3e 9f			ld a,display_row_4 + display_cols - 1 
2049 11 41 20		        ld de, endprg 
204c cd 65 0d			call str_at_display 
204f cd 75 0d			call update_display 
2052 cd 99 78			call cin_wait 
2055 c1				pop bc 
2056 f1				pop af 
2057 d1				pop de 
2058 e1				pop hl 
2059			 
2059			 
2059 c9				ret 
205a			 
205a			 
205a			; forth parser 
205a			 
205a			; My forth kernel 
205a			include "forth_kernel.asm" 
205a			; 
205a			; kernel to the forth OS 
205a			 
205a			DS_TYPE_STR: equ 1     ; string type 
205a			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
205a			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
205a			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
205a			 
205a			FORTH_PARSEV1: equ 0 
205a			FORTH_PARSEV2: equ 0 
205a			FORTH_PARSEV3: equ 0 
205a			FORTH_PARSEV4: equ 0 
205a			FORTH_PARSEV5: equ 1 
205a			 
205a			;if FORTH_PARSEV5 
205a			;	FORTH_END_BUFFER: equ 0 
205a			;else 
205a			FORTH_END_BUFFER: equ 127 
205a			;endif 
205a			 
205a			FORTH_TRUE: equ 1 
205a			FORTH_FALSE: equ 0 
205a			 
205a			if FORTH_PARSEV4 
205a			include "forth_stackops.asm" 
205a			endif 
205a			 
205a			if FORTH_PARSEV5 
205a			include "forth_stackopsv5.asm" 
205a			 
205a			; Stack operations for v5 parser on wards 
205a			; * DATA stack 
205a			; * LOOP stack 
205a			; * RETURN stack 
205a			 
205a			 
205a			 
205a			FORTH_CHK_DSP_UNDER: macro 
205a				push hl 
205a				push de 
205a				ld hl,(cli_data_sp) 
205a				ld de, cli_data_stack 
205a				call cmp16 
205a				jp c, fault_dsp_under 
205a				pop de 
205a				pop hl 
205a				endm 
205a			 
205a			 
205a			FORTH_CHK_RSP_UNDER: macro 
205a				push hl 
205a				push de 
205a				ld hl,(cli_ret_sp) 
205a				ld de, cli_ret_stack 
205a				call cmp16 
205a				jp c, fault_rsp_under 
205a				pop de 
205a				pop hl 
205a				endm 
205a			 
205a			FORTH_CHK_LOOP_UNDER: macro 
205a				push hl 
205a				push de 
205a				ld hl,(cli_loop_sp) 
205a				ld de, cli_loop_stack 
205a				call cmp16 
205a				jp c, fault_loop_under 
205a				pop de 
205a				pop hl 
205a				endm 
205a			 
205a			FORTH_ERR_TOS_NOTSTR: macro 
205a				; TOSO might need more for checks when used 
205a				push af 
205a				ld a,(hl) 
205a				cp DS_TYPE_STR 
205a				jp nz, type_faultn   
205a				pop af 
205a				endm 
205a			 
205a			FORTH_ERR_TOS_NOTNUM: macro 
205a				push af 
205a				ld a,(hl) 
205a				cp DS_TYPE_INUM 
205a				jp nz, type_faultn   
205a				pop af 
205a				endm 
205a			 
205a			 
205a			; increase data stack pointer and save hl to it 
205a				 
205a			FORTH_DSP_NEXT: macro 
205a				call macro_forth_dsp_next 
205a				endm 
205a			 
205a			 
205a			macro_forth_dsp_next: 
205a				if DEBUG_FORTH_STACK_GUARD 
205a cd 59 71				call check_stacks 
205d				endif 
205d e5				push hl 
205e d5				push de 
205f eb				ex de,hl 
2060 2a f1 f9			ld hl,(cli_data_sp) 
2063 23				inc hl 
2064 23				inc hl 
2065			 
2065			; PARSEV5 
2065 23				inc hl 
2066 22 f1 f9			ld (cli_data_sp),hl 
2069 73				ld (hl), e 
206a 23				inc hl 
206b 72				ld (hl), d 
206c d1				pop de 
206d e1				pop hl 
206e				if DEBUG_FORTH_STACK_GUARD 
206e cd 59 71				call check_stacks 
2071				endif 
2071 c9				ret 
2072			 
2072			 
2072			; increase ret stack pointer and save hl to it 
2072				 
2072			FORTH_RSP_NEXT: macro 
2072				call macro_forth_rsp_next 
2072				endm 
2072			 
2072			macro_forth_rsp_next: 
2072				if DEBUG_FORTH_STACK_GUARD 
2072 cd 59 71				call check_stacks 
2075				endif 
2075 e5				push hl 
2076 d5				push de 
2077 eb				ex de,hl 
2078 2a f5 f9			ld hl,(cli_ret_sp) 
207b 23				inc hl 
207c 23				inc hl 
207d 22 f5 f9			ld (cli_ret_sp),hl 
2080 73				ld (hl), e 
2081 23				inc hl 
2082 72				ld (hl), d 
2083 d1				pop de 
2084 e1				pop hl 
2085				if DEBUG_FORTH_STACK_GUARD 
2085 cd 59 71				call check_stacks 
2088				endif 
2088 c9				ret 
2089			 
2089			; get current ret stack pointer and save to hl  
2089				 
2089			FORTH_RSP_TOS: macro 
2089				call macro_forth_rsp_tos 
2089				endm 
2089			 
2089			macro_forth_rsp_tos: 
2089				;push de 
2089 2a f5 f9			ld hl,(cli_ret_sp) 
208c cd c4 20			call loadhlptrtohl 
208f				;ld e, (hl) 
208f				;inc hl 
208f				;ld d, (hl) 
208f				;ex de, hl 
208f					if DEBUG_FORTH_WORDS 
208f			;			DMARK "RST" 
208f						CALLMONITOR 
208f cd fb 19			call break_point_state  
2092				endm  
# End of macro CALLMONITOR
2092					endif 
2092				;pop de 
2092 c9				ret 
2093			 
2093			; pop ret stack pointer 
2093				 
2093			FORTH_RSP_POP: macro 
2093				call macro_forth_rsp_pop 
2093				endm 
2093			 
2093			 
2093			macro_forth_rsp_pop: 
2093				if DEBUG_FORTH_STACK_GUARD 
2093			;		DMARK "RPP" 
2093 cd 59 71				call check_stacks 
2096					FORTH_CHK_RSP_UNDER 
2096 e5				push hl 
2097 d5				push de 
2098 2a f5 f9			ld hl,(cli_ret_sp) 
209b 11 af f9			ld de, cli_ret_stack 
209e cd a4 0f			call cmp16 
20a1 da 6d 72			jp c, fault_rsp_under 
20a4 d1				pop de 
20a5 e1				pop hl 
20a6				endm 
# End of macro FORTH_CHK_RSP_UNDER
20a6				endif 
20a6 e5				push hl 
20a7 2a f5 f9			ld hl,(cli_ret_sp) 
20aa			 
20aa			 
20aa				if FORTH_ENABLE_FREE 
20aa			 
20aa					; get pointer 
20aa			 
20aa					push de 
20aa					push hl 
20aa			 
20aa					ld e, (hl) 
20aa					inc hl 
20aa					ld d, (hl) 
20aa			 
20aa					ex de, hl 
20aa					call free 
20aa			 
20aa					pop hl 
20aa					pop de 
20aa			 
20aa			 
20aa				endif 
20aa			 
20aa			 
20aa 2b				dec hl 
20ab 2b				dec hl 
20ac 22 f5 f9			ld (cli_ret_sp), hl 
20af				; do stack underflow checks 
20af e1				pop hl 
20b0				if DEBUG_FORTH_STACK_GUARD 
20b0 cd 59 71				call check_stacks 
20b3					FORTH_CHK_RSP_UNDER 
20b3 e5				push hl 
20b4 d5				push de 
20b5 2a f5 f9			ld hl,(cli_ret_sp) 
20b8 11 af f9			ld de, cli_ret_stack 
20bb cd a4 0f			call cmp16 
20be da 6d 72			jp c, fault_rsp_under 
20c1 d1				pop de 
20c2 e1				pop hl 
20c3				endm 
# End of macro FORTH_CHK_RSP_UNDER
20c3				endif 
20c3 c9				ret 
20c4			 
20c4			 
20c4			 
20c4			; routine to load word pointed to by hl into hl 
20c4			 
20c4			loadhlptrtohl: 
20c4			 
20c4 d5				push de 
20c5 5e				ld e, (hl) 
20c6 23				inc hl 
20c7 56				ld d, (hl) 
20c8 eb				ex de, hl 
20c9 d1				pop de 
20ca			 
20ca c9				ret 
20cb			 
20cb			 
20cb			 
20cb			 
20cb			 
20cb			; push a number held in HL onto the data stack 
20cb			; entry point for pushing a value when already in hl used in function above 
20cb			 
20cb			forth_push_numhl: 
20cb			 
20cb e5				push hl    ; save value to push 
20cc			 
20cc			if DEBUG_FORTH_PUSH 
20cc				; see if disabled 
20cc			 
20cc			 
20cc f5				push af 
20cd 3a b5 f1			ld a, (os_view_disable) 
20d0 fe 2a			cp '*' 
20d2 28 34			jr z, .pskip2 
20d4 e5				push hl 
20d5 e5			push hl 
20d6 cd 52 0d			call clear_display 
20d9 e1			pop hl 
20da 7c				ld a,h 
20db 21 c9 f4			ld hl, os_word_scratch 
20de cd 87 12			call hexout 
20e1 e1				pop hl 
20e2 7d				ld a,l 
20e3 21 cb f4			ld hl, os_word_scratch+2 
20e6 cd 87 12			call hexout 
20e9			 
20e9 21 cd f4			ld hl, os_word_scratch+4 
20ec 3e 00			ld a,0 
20ee 77				ld (hl),a 
20ef 11 c9 f4			ld de,os_word_scratch 
20f2 3e 28				ld a, display_row_2 
20f4 cd 65 0d				call str_at_display 
20f7 11 3e 5d			ld de, .push_num 
20fa 3e 00			ld a, display_row_1 
20fc			 
20fc cd 65 0d				call str_at_display 
20ff			 
20ff			 
20ff cd 75 0d			call update_display 
2102 cd 95 0c			call delay1s 
2105 cd 95 0c			call delay1s 
2108			.pskip2:  
2108			 
2108 f1				pop af 
2109			endif	 
2109			 
2109			 
2109				FORTH_DSP_NEXT 
2109 cd 5a 20			call macro_forth_dsp_next 
210c				endm 
# End of macro FORTH_DSP_NEXT
210c			 
210c 2a f1 f9			ld hl, (cli_data_sp) 
210f			 
210f				; save item type 
210f 3e 02			ld a,  DS_TYPE_INUM 
2111 77				ld (hl), a 
2112 23				inc hl 
2113			 
2113				; get word off stack 
2113 d1				pop de 
2114 7b				ld a,e 
2115 77				ld (hl), a 
2116 23				inc hl 
2117 7a				ld a,d 
2118 77				ld (hl), a 
2119			 
2119			if DEBUG_FORTH_PUSH 
2119 2b				dec hl 
211a 2b				dec hl 
211b 2b				dec hl 
211c						DMARK "PH5" 
211c f5				push af  
211d 3a 31 21			ld a, (.dmark)  
2120 32 6e fe			ld (debug_mark),a  
2123 3a 32 21			ld a, (.dmark+1)  
2126 32 6f fe			ld (debug_mark+1),a  
2129 3a 33 21			ld a, (.dmark+2)  
212c 32 70 fe			ld (debug_mark+2),a  
212f 18 03			jr .pastdmark  
2131 ..			.dmark: db "PH5"  
2134 f1			.pastdmark: pop af  
2135			endm  
# End of macro DMARK
2135				CALLMONITOR 
2135 cd fb 19			call break_point_state  
2138				endm  
# End of macro CALLMONITOR
2138			endif	 
2138			 
2138 c9				ret 
2139			 
2139			 
2139			; Push a string to stack pointed to by hl 
2139			 
2139			forth_push_str: 
2139			 
2139			if DEBUG_FORTH_PUSH 
2139						DMARK "PSQ" 
2139 f5				push af  
213a 3a 4e 21			ld a, (.dmark)  
213d 32 6e fe			ld (debug_mark),a  
2140 3a 4f 21			ld a, (.dmark+1)  
2143 32 6f fe			ld (debug_mark+1),a  
2146 3a 50 21			ld a, (.dmark+2)  
2149 32 70 fe			ld (debug_mark+2),a  
214c 18 03			jr .pastdmark  
214e ..			.dmark: db "PSQ"  
2151 f1			.pastdmark: pop af  
2152			endm  
# End of macro DMARK
2152				CALLMONITOR 
2152 cd fb 19			call break_point_state  
2155				endm  
# End of macro CALLMONITOR
2155			endif	 
2155			    
2155 e5				push hl 
2156 e5				push hl 
2157			 
2157			;	ld a, 0   ; find end of string 
2157 cd e4 13			call strlenz 
215a			if DEBUG_FORTH_PUSH 
215a						DMARK "PQ2" 
215a f5				push af  
215b 3a 6f 21			ld a, (.dmark)  
215e 32 6e fe			ld (debug_mark),a  
2161 3a 70 21			ld a, (.dmark+1)  
2164 32 6f fe			ld (debug_mark+1),a  
2167 3a 71 21			ld a, (.dmark+2)  
216a 32 70 fe			ld (debug_mark+2),a  
216d 18 03			jr .pastdmark  
216f ..			.dmark: db "PQ2"  
2172 f1			.pastdmark: pop af  
2173			endm  
# End of macro DMARK
2173				CALLMONITOR 
2173 cd fb 19			call break_point_state  
2176				endm  
# End of macro CALLMONITOR
2176			endif	 
2176 eb				ex de, hl 
2177 e1				pop hl   ; get ptr to start of string 
2178			if DEBUG_FORTH_PUSH 
2178						DMARK "PQ3" 
2178 f5				push af  
2179 3a 8d 21			ld a, (.dmark)  
217c 32 6e fe			ld (debug_mark),a  
217f 3a 8e 21			ld a, (.dmark+1)  
2182 32 6f fe			ld (debug_mark+1),a  
2185 3a 8f 21			ld a, (.dmark+2)  
2188 32 70 fe			ld (debug_mark+2),a  
218b 18 03			jr .pastdmark  
218d ..			.dmark: db "PQ3"  
2190 f1			.pastdmark: pop af  
2191			endm  
# End of macro DMARK
2191				CALLMONITOR 
2191 cd fb 19			call break_point_state  
2194				endm  
# End of macro CALLMONITOR
2194			endif	 
2194 19				add hl,de 
2195			if DEBUG_FORTH_PUSH 
2195						DMARK "PQE" 
2195 f5				push af  
2196 3a aa 21			ld a, (.dmark)  
2199 32 6e fe			ld (debug_mark),a  
219c 3a ab 21			ld a, (.dmark+1)  
219f 32 6f fe			ld (debug_mark+1),a  
21a2 3a ac 21			ld a, (.dmark+2)  
21a5 32 70 fe			ld (debug_mark+2),a  
21a8 18 03			jr .pastdmark  
21aa ..			.dmark: db "PQE"  
21ad f1			.pastdmark: pop af  
21ae			endm  
# End of macro DMARK
21ae				CALLMONITOR 
21ae cd fb 19			call break_point_state  
21b1				endm  
# End of macro CALLMONITOR
21b1			endif	 
21b1			 
21b1 2b				dec hl    ; see if there is an optional trailing double quote 
21b2 7e				ld a,(hl) 
21b3 fe 22			cp '"' 
21b5 20 03			jr nz, .strnoq 
21b7 3e 00			ld a, 0      ; get rid of double quote 
21b9 77				ld (hl), a 
21ba 23			.strnoq: inc hl 
21bb			 
21bb 3e 00			ld a, 0 
21bd 77				ld (hl), a     ; add null term and get rid of trailing double quote 
21be			 
21be 13				inc de ; add one for the type string 
21bf 13				inc de ; add one for null term??? 
21c0			 
21c0				; tos is get string pointer again 
21c0				; de contains space to allocate 
21c0				 
21c0 d5				push de 
21c1			 
21c1 eb				ex de, hl 
21c2			 
21c2				;push af 
21c2			 
21c2			if DEBUG_FORTH_PUSH 
21c2						DMARK "PHm" 
21c2 f5				push af  
21c3 3a d7 21			ld a, (.dmark)  
21c6 32 6e fe			ld (debug_mark),a  
21c9 3a d8 21			ld a, (.dmark+1)  
21cc 32 6f fe			ld (debug_mark+1),a  
21cf 3a d9 21			ld a, (.dmark+2)  
21d2 32 70 fe			ld (debug_mark+2),a  
21d5 18 03			jr .pastdmark  
21d7 ..			.dmark: db "PHm"  
21da f1			.pastdmark: pop af  
21db			endm  
# End of macro DMARK
21db				CALLMONITOR 
21db cd fb 19			call break_point_state  
21de				endm  
# End of macro CALLMONITOR
21de			endif	 
21de cd 4d 14			call malloc	; on ret hl now contains allocated memory 
21e1				if DEBUG_FORTH_MALLOC_GUARD 
21e1 cc 96 5d				call z,malloc_error 
21e4				endif 
21e4			 
21e4				 
21e4 c1				pop bc    ; get length 
21e5 d1				pop de   ;  get string start    
21e6			 
21e6				; hl has destination from malloc 
21e6			 
21e6 eb				ex de, hl    ; prep for ldir 
21e7			 
21e7 d5				push de   ; save malloc area for DSP later 
21e8				;push hl   ; save malloc area for DSP later 
21e8			 
21e8			if DEBUG_FORTH_PUSH 
21e8						DMARK "PHc" 
21e8 f5				push af  
21e9 3a fd 21			ld a, (.dmark)  
21ec 32 6e fe			ld (debug_mark),a  
21ef 3a fe 21			ld a, (.dmark+1)  
21f2 32 6f fe			ld (debug_mark+1),a  
21f5 3a ff 21			ld a, (.dmark+2)  
21f8 32 70 fe			ld (debug_mark+2),a  
21fb 18 03			jr .pastdmark  
21fd ..			.dmark: db "PHc"  
2200 f1			.pastdmark: pop af  
2201			endm  
# End of macro DMARK
2201				CALLMONITOR 
2201 cd fb 19			call break_point_state  
2204				endm  
# End of macro CALLMONITOR
2204			endif	 
2204			 
2204			 
2204 ed b0			ldir 
2206			 
2206			 
2206				; push malloc to data stack     macro?????  
2206			 
2206				FORTH_DSP_NEXT 
2206 cd 5a 20			call macro_forth_dsp_next 
2209				endm 
# End of macro FORTH_DSP_NEXT
2209			 
2209				; save value and type 
2209			 
2209 2a f1 f9			ld hl, (cli_data_sp) 
220c			 
220c				; save item type 
220c 3e 01			ld a,  DS_TYPE_STR 
220e 77				ld (hl), a 
220f 23				inc hl 
2210			 
2210				; get malloc word off stack 
2210 d1				pop de 
2211 73				ld (hl), e 
2212 23				inc hl 
2213 72				ld (hl), d 
2214			 
2214			 
2214			 
2214			if DEBUG_FORTH_PUSH 
2214 2a f1 f9			ld hl, (cli_data_sp) 
2217						DMARK "PHS" 
2217 f5				push af  
2218 3a 2c 22			ld a, (.dmark)  
221b 32 6e fe			ld (debug_mark),a  
221e 3a 2d 22			ld a, (.dmark+1)  
2221 32 6f fe			ld (debug_mark+1),a  
2224 3a 2e 22			ld a, (.dmark+2)  
2227 32 70 fe			ld (debug_mark+2),a  
222a 18 03			jr .pastdmark  
222c ..			.dmark: db "PHS"  
222f f1			.pastdmark: pop af  
2230			endm  
# End of macro DMARK
2230				CALLMONITOR 
2230 cd fb 19			call break_point_state  
2233				endm  
# End of macro CALLMONITOR
2233			;	ex de,hl 
2233			endif	 
2233				; in case of spaces, skip the ptr past the copied string 
2233				;pop af 
2233				;ld (cli_origptr),hl 
2233			 
2233 c9				ret 
2234			 
2234			 
2234			 
2234			; TODO ascii push input onto stack given hl to start of input 
2234			 
2234			; identify type 
2234			; if starts with a " then a string 
2234			; otherwise it is a number 
2234			;  
2234			; if a string 
2234			;     scan for ending " to get length of string to malloc for + 1 
2234			;     malloc 
2234			;     put pointer to string on stack first byte flags as string 
2234			; 
2234			; else a number 
2234			;    look for number format identifier 
2234			;    $xx hex 
2234			;    %xxxxx bin 
2234			;    xxxxx decimal 
2234			;    convert number to 16bit word.  
2234			;    malloc word + 1 with flag to identiy as num 
2234			;    put pointer to number on stack 
2234			;   
2234			;  
2234			  
2234			forth_apush: 
2234				; kernel push 
2234			 
2234			if DEBUG_FORTH_PUSH 
2234						DMARK "PSH" 
2234 f5				push af  
2235 3a 49 22			ld a, (.dmark)  
2238 32 6e fe			ld (debug_mark),a  
223b 3a 4a 22			ld a, (.dmark+1)  
223e 32 6f fe			ld (debug_mark+1),a  
2241 3a 4b 22			ld a, (.dmark+2)  
2244 32 70 fe			ld (debug_mark+2),a  
2247 18 03			jr .pastdmark  
2249 ..			.dmark: db "PSH"  
224c f1			.pastdmark: pop af  
224d			endm  
# End of macro DMARK
224d				CALLMONITOR 
224d cd fb 19			call break_point_state  
2250				endm  
# End of macro CALLMONITOR
2250			endif	 
2250				; identify input type 
2250			 
2250 7e				ld a,(hl) 
2251 fe 22			cp '"' 
2253 28 0a			jr z, .fapstr 
2255 fe 24			cp '$' 
2257 ca 7f 22			jp z, .faphex 
225a fe 25			cp '%' 
225c ca 67 22			jp z, .fapbin 
225f			;	cp 'b' 
225f			;	jp z, .fabin 
225f				; else decimal 
225f			 
225f				; TODO do decimal conversion 
225f				; decimal is stored as a 16bit word 
225f			 
225f				; by default everything is a string if type is not detected 
225f			.fapstr: ; 
225f fe 22			cp '"' 
2261 20 01			jr nz, .strnoqu 
2263 23				inc hl 
2264			.strnoqu: 
2264 c3 39 21			jp forth_push_str 
2267			 
2267			 
2267			 
2267			.fapbin:    ; push a binary string.  
2267 11 00 00			ld de, 0   ; hold a 16bit value 
226a			 
226a 23			.fapbinshift:	inc hl  
226b 7e				ld a,(hl) 
226c fe 00			cp 0     ; done scanning  
226e 28 0b			jr z, .fapbdone  	; got it in HL so push  
2270			 
2270				; left shift de 
2270 eb				ex de, hl	 
2271 29				add hl, hl 
2272			 
2272				; is 1 
2272 fe 31			cp '1' 
2274 20 02			jr nz, .binzero 
2276 cb 4d			bit 1, l 
2278			.binzero: 
2278 eb				ex de, hl	 ; save current de 
2279 18 ef			jr .fapbinshift 
227b			 
227b			.fapbdone: 
227b eb				ex de, hl 
227c c3 cb 20			jp forth_push_numhl 
227f			 
227f			 
227f			.faphex:   ; hex is always stored as a 16bit word 
227f				; skip number prefix 
227f 23				inc hl 
2280				; turn ascii into number 
2280 cd 3d 13			call get_word_hl	; ret 16bit word in hl 
2283			 
2283 c3 cb 20			jp forth_push_numhl 
2286			 
2286 00				 nop 
2287			 
2287			.fabin:   ; TODO bin conversion 
2287			 
2287			 
2287 c9				ret 
2288			 
2288			 
2288			; get either a string ptr or a 16bit word from the data stack 
2288			 
2288			FORTH_DSP: macro 
2288				call macro_forth_dsp 
2288				endm 
2288			 
2288			macro_forth_dsp: 
2288				; data stack pointer points to current word on tos 
2288			 
2288 2a f1 f9			ld hl,(cli_data_sp) 
228b			 
228b				if DEBUG_FORTH_PUSH 
228b						DMARK "DSP" 
228b f5				push af  
228c 3a a0 22			ld a, (.dmark)  
228f 32 6e fe			ld (debug_mark),a  
2292 3a a1 22			ld a, (.dmark+1)  
2295 32 6f fe			ld (debug_mark+1),a  
2298 3a a2 22			ld a, (.dmark+2)  
229b 32 70 fe			ld (debug_mark+2),a  
229e 18 03			jr .pastdmark  
22a0 ..			.dmark: db "DSP"  
22a3 f1			.pastdmark: pop af  
22a4			endm  
# End of macro DMARK
22a4			 
22a4 cd cb 5d				call display_data_sp 
22a7				;call break_point_state 
22a7				;rst 030h 
22a7				CALLMONITOR 
22a7 cd fb 19			call break_point_state  
22aa				endm  
# End of macro CALLMONITOR
22aa				endif 
22aa			 
22aa c9				ret 
22ab			 
22ab			; return hl to start of value on stack 
22ab			 
22ab			FORTH_DSP_VALUE: macro 
22ab				call macro_forth_dsp_value 
22ab				endm 
22ab			 
22ab			macro_forth_dsp_value: 
22ab			 
22ab				FORTH_DSP 
22ab cd 88 22			call macro_forth_dsp 
22ae				endm 
# End of macro FORTH_DSP
22ae			 
22ae d5				push de 
22af			 
22af 23				inc hl ; skip type 
22b0			 
22b0 5e				ld e, (hl) 
22b1 23				inc hl 
22b2 56				ld d, (hl) 
22b3 eb				ex de,hl  
22b4			 
22b4 d1				pop de 
22b5			 
22b5 c9				ret 
22b6			 
22b6			; return hl to start of value to second item on stack 
22b6			 
22b6			FORTH_DSP_VALUEM1: macro 
22b6				call macro_forth_dsp_value_m1 
22b6				endm 
22b6			 
22b6			macro_forth_dsp_value_m1: 
22b6			 
22b6				FORTH_DSP 
22b6 cd 88 22			call macro_forth_dsp 
22b9				endm 
# End of macro FORTH_DSP
22b9			 
22b9 2b				dec hl 
22ba 2b				dec hl 
22bb			;	dec hl 
22bb			 
22bb d5				push de 
22bc			 
22bc 5e				ld e, (hl) 
22bd 23				inc hl 
22be 56				ld d, (hl) 
22bf eb				ex de,hl  
22c0			 
22c0 d1				pop de 
22c1			 
22c1 c9				ret 
22c2			 
22c2				 
22c2			 
22c2			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
22c2			 
22c2			FORTH_DSP_POP: macro 
22c2				call macro_forth_dsp_pop 
22c2				endm 
22c2			 
22c2			 
22c2			; get the tos data type 
22c2			 
22c2			FORTH_DSP_TYPE:   macro 
22c2			 
22c2				;FORTH_DSP_VALUE 
22c2				FORTH_DSP 
22c2				 
22c2				; hl points to value 
22c2				; check type 
22c2			 
22c2				ld a,(hl) 
22c2			 
22c2				endm 
22c2			 
22c2			; load the tos value into hl 
22c2			 
22c2			 
22c2			FORTH_DSP_VALUEHL:  macro 
22c2				call macro_dsp_valuehl 
22c2				endm 
22c2			 
22c2			 
22c2			 
22c2			macro_dsp_valuehl: 
22c2				FORTH_DSP_VALUE 
22c2 cd ab 22			call macro_forth_dsp_value 
22c5				endm 
# End of macro FORTH_DSP_VALUE
22c5			 
22c5				;FORTH_ERR_TOS_NOTNUM 
22c5			 
22c5				;inc hl   ; skip type id 
22c5			 
22c5			;	push de 
22c5			; 
22c5			;	ld e, (hl) 
22c5			;	inc hl 
22c5			;	ld d, (hl) 
22c5			;	ex de,hl  
22c5			 
22c5			;	pop de 
22c5			 
22c5				if DEBUG_FORTH_PUSH 
22c5						DMARK "DVL" 
22c5 f5				push af  
22c6 3a da 22			ld a, (.dmark)  
22c9 32 6e fe			ld (debug_mark),a  
22cc 3a db 22			ld a, (.dmark+1)  
22cf 32 6f fe			ld (debug_mark+1),a  
22d2 3a dc 22			ld a, (.dmark+2)  
22d5 32 70 fe			ld (debug_mark+2),a  
22d8 18 03			jr .pastdmark  
22da ..			.dmark: db "DVL"  
22dd f1			.pastdmark: pop af  
22de			endm  
# End of macro DMARK
22de				CALLMONITOR 
22de cd fb 19			call break_point_state  
22e1				endm  
# End of macro CALLMONITOR
22e1				endif 
22e1 c9				ret 
22e2			 
22e2			forth_apushstrhl:      
22e2				; push of string requires use of cli_origptr 
22e2				; bodge use 
22e2			 
22e2				; get current cli_origptr, save, update with temp pointer  
22e2 ed 5b 41 fa		ld de, (cli_origptr) 
22e6 22 41 fa			ld (cli_origptr), hl 
22e9 d5				push de 
22ea cd 34 22			call forth_apush 
22ed d1				pop de 
22ee ed 53 41 fa		ld (cli_origptr), de 
22f2 c9			        ret	 
22f3			 
22f3			 
22f3			; increase loop stack pointer and save hl to it 
22f3				 
22f3			FORTH_LOOP_NEXT: macro 
22f3				call macro_forth_loop_next 
22f3				;nop 
22f3				endm 
22f3			 
22f3			macro_forth_loop_next: 
22f3				if DEBUG_FORTH_STACK_GUARD 
22f3 cd 59 71				call check_stacks 
22f6				endif 
22f6 e5				push hl 
22f7 d5				push de 
22f8 eb				ex de,hl 
22f9 2a f3 f9			ld hl,(cli_loop_sp) 
22fc 23				inc hl 
22fd 23				inc hl 
22fe					if DEBUG_FORTH_WORDS 
22fe						DMARK "LNX" 
22fe f5				push af  
22ff 3a 13 23			ld a, (.dmark)  
2302 32 6e fe			ld (debug_mark),a  
2305 3a 14 23			ld a, (.dmark+1)  
2308 32 6f fe			ld (debug_mark+1),a  
230b 3a 15 23			ld a, (.dmark+2)  
230e 32 70 fe			ld (debug_mark+2),a  
2311 18 03			jr .pastdmark  
2313 ..			.dmark: db "LNX"  
2316 f1			.pastdmark: pop af  
2317			endm  
# End of macro DMARK
2317						CALLMONITOR 
2317 cd fb 19			call break_point_state  
231a				endm  
# End of macro CALLMONITOR
231a					endif 
231a 22 f3 f9			ld (cli_loop_sp),hl 
231d 73				ld (hl), e 
231e 23				inc hl 
231f 72				ld (hl), d 
2320 d1				pop de    ; been reversed so save a swap on restore 
2321 e1				pop hl 
2322				if DEBUG_FORTH_STACK_GUARD 
2322 cd 59 71				call check_stacks 
2325				endif 
2325 c9				ret 
2326			 
2326			; get current ret stack pointer and save to hl  
2326				 
2326			FORTH_LOOP_TOS: macro 
2326				call macro_forth_loop_tos 
2326				endm 
2326			 
2326			macro_forth_loop_tos: 
2326 d5				push de 
2327 2a f3 f9			ld hl,(cli_loop_sp) 
232a 5e				ld e, (hl) 
232b 23				inc hl 
232c 56				ld d, (hl) 
232d eb				ex de, hl 
232e d1				pop de 
232f c9				ret 
2330			 
2330			; pop loop stack pointer 
2330				 
2330			FORTH_LOOP_POP: macro 
2330				call macro_forth_loop_pop 
2330				endm 
2330			 
2330			 
2330			macro_forth_loop_pop: 
2330				if DEBUG_FORTH_STACK_GUARD 
2330					DMARK "LPP" 
2330 f5				push af  
2331 3a 45 23			ld a, (.dmark)  
2334 32 6e fe			ld (debug_mark),a  
2337 3a 46 23			ld a, (.dmark+1)  
233a 32 6f fe			ld (debug_mark+1),a  
233d 3a 47 23			ld a, (.dmark+2)  
2340 32 70 fe			ld (debug_mark+2),a  
2343 18 03			jr .pastdmark  
2345 ..			.dmark: db "LPP"  
2348 f1			.pastdmark: pop af  
2349			endm  
# End of macro DMARK
2349 cd 59 71				call check_stacks 
234c					FORTH_CHK_LOOP_UNDER 
234c e5				push hl 
234d d5				push de 
234e 2a f3 f9			ld hl,(cli_loop_sp) 
2351 11 2d f9			ld de, cli_loop_stack 
2354 cd a4 0f			call cmp16 
2357 da 73 72			jp c, fault_loop_under 
235a d1				pop de 
235b e1				pop hl 
235c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
235c				endif 
235c e5				push hl 
235d 2a f3 f9			ld hl,(cli_loop_sp) 
2360 2b				dec hl 
2361 2b				dec hl 
2362 22 f3 f9			ld (cli_loop_sp), hl 
2365				; TODO do stack underflow checks 
2365 e1				pop hl 
2366				if DEBUG_FORTH_STACK_GUARD 
2366 cd 59 71				call check_stacks 
2369					FORTH_CHK_LOOP_UNDER 
2369 e5				push hl 
236a d5				push de 
236b 2a f3 f9			ld hl,(cli_loop_sp) 
236e 11 2d f9			ld de, cli_loop_stack 
2371 cd a4 0f			call cmp16 
2374 da 73 72			jp c, fault_loop_under 
2377 d1				pop de 
2378 e1				pop hl 
2379				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2379				endif 
2379 c9				ret 
237a			 
237a			macro_forth_dsp_pop: 
237a			 
237a e5				push hl 
237b			 
237b				; release malloc data 
237b			 
237b				if DEBUG_FORTH_STACK_GUARD 
237b cd 59 71				call check_stacks 
237e					FORTH_CHK_DSP_UNDER 
237e e5				push hl 
237f d5				push de 
2380 2a f1 f9			ld hl,(cli_data_sp) 
2383 11 2b f7			ld de, cli_data_stack 
2386 cd a4 0f			call cmp16 
2389 da 67 72			jp c, fault_dsp_under 
238c d1				pop de 
238d e1				pop hl 
238e				endm 
# End of macro FORTH_CHK_DSP_UNDER
238e				endif 
238e				;ld hl,(cli_data_sp) 
238e			if DEBUG_FORTH_DOT 
238e				DMARK "DPP" 
238e f5				push af  
238f 3a a3 23			ld a, (.dmark)  
2392 32 6e fe			ld (debug_mark),a  
2395 3a a4 23			ld a, (.dmark+1)  
2398 32 6f fe			ld (debug_mark+1),a  
239b 3a a5 23			ld a, (.dmark+2)  
239e 32 70 fe			ld (debug_mark+2),a  
23a1 18 03			jr .pastdmark  
23a3 ..			.dmark: db "DPP"  
23a6 f1			.pastdmark: pop af  
23a7			endm  
# End of macro DMARK
23a7				CALLMONITOR 
23a7 cd fb 19			call break_point_state  
23aa				endm  
# End of macro CALLMONITOR
23aa			endif	 
23aa			 
23aa			 
23aa			if FORTH_ENABLE_DSPPOPFREE 
23aa			 
23aa				FORTH_DSP 
23aa cd 88 22			call macro_forth_dsp 
23ad				endm 
# End of macro FORTH_DSP
23ad			 
23ad 7e				ld a, (hl) 
23ae fe 01			cp DS_TYPE_STR 
23b0 20 23			jr nz, .skippopfree 
23b2			 
23b2				FORTH_DSP_VALUEHL 
23b2 cd c2 22			call macro_dsp_valuehl 
23b5				endm 
# End of macro FORTH_DSP_VALUEHL
23b5 00				nop 
23b6			if DEBUG_FORTH_DOT 
23b6				DMARK "DPf" 
23b6 f5				push af  
23b7 3a cb 23			ld a, (.dmark)  
23ba 32 6e fe			ld (debug_mark),a  
23bd 3a cc 23			ld a, (.dmark+1)  
23c0 32 6f fe			ld (debug_mark+1),a  
23c3 3a cd 23			ld a, (.dmark+2)  
23c6 32 70 fe			ld (debug_mark+2),a  
23c9 18 03			jr .pastdmark  
23cb ..			.dmark: db "DPf"  
23ce f1			.pastdmark: pop af  
23cf			endm  
# End of macro DMARK
23cf				CALLMONITOR 
23cf cd fb 19			call break_point_state  
23d2				endm  
# End of macro CALLMONITOR
23d2			endif	 
23d2 cd 17 15			call free 
23d5			.skippopfree: 
23d5				 
23d5			 
23d5			endif 
23d5			 
23d5			if DEBUG_FORTH_DOT_KEY 
23d5				DMARK "DP2" 
23d5				CALLMONITOR 
23d5			endif	 
23d5			 
23d5				; move pointer down 
23d5			 
23d5 2a f1 f9			ld hl,(cli_data_sp) 
23d8 2b				dec hl 
23d9 2b				dec hl 
23da			; PARSEV5 
23da 2b				dec hl 
23db 22 f1 f9			ld (cli_data_sp), hl 
23de			 
23de				if DEBUG_FORTH_STACK_GUARD 
23de cd 59 71				call check_stacks 
23e1					FORTH_CHK_DSP_UNDER 
23e1 e5				push hl 
23e2 d5				push de 
23e3 2a f1 f9			ld hl,(cli_data_sp) 
23e6 11 2b f7			ld de, cli_data_stack 
23e9 cd a4 0f			call cmp16 
23ec da 67 72			jp c, fault_dsp_under 
23ef d1				pop de 
23f0 e1				pop hl 
23f1				endm 
# End of macro FORTH_CHK_DSP_UNDER
23f1				endif 
23f1			 
23f1 e1				pop hl 
23f2			 
23f2 c9				ret 
23f3			 
23f3			getwordathl: 
23f3				; hl points to an address 
23f3				; load hl with the word at that address 
23f3			 
23f3 d5				push de 
23f4			 
23f4 5e				ld e, (hl) 
23f5 23				inc hl 
23f6 56				ld d, (hl) 
23f7 eb				ex de, hl 
23f8			 
23f8 d1				pop de 
23f9 c9				ret 
23fa			 
23fa			 
23fa			 
23fa			 
23fa			 
23fa			; eof 
23fa			 
# End of file forth_stackopsv5.asm
23fa			endif 
23fa			 
23fa			loadwordinhl:	 
23fa			 
23fa d5				push de 
23fb			 
23fb 5e				ld e, (hl) 
23fc 23				inc hl 
23fd 56				ld d, (hl) 
23fe eb				ex de,hl  
23ff			 
23ff d1				pop de 
2400			 
2400 c9				ret 
2401			 
2401			user_word_eol:  
2401				; hl contains the pointer to where to create a linked list item from the end 
2401				; of the user dict to continue on at the system word dict 
2401				 
2401				; poke the stub of the word list linked list to repoint to rom words 
2401			 
2401				; stub format 
2401				; db   word id 
2401				; dw    link to next word 
2401			        ; db char length of token 
2401				; db string + 0 term 
2401				; db exec code....  
2401			 
2401 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2403 77				ld (hl), a		; word id 
2404 23				inc hl 
2405			 
2405 11 d0 25			ld de, sysdict 
2408 73				ld (hl), e		; next word link ie system dict 
2409 23				inc hl 
240a 72				ld (hl), d		; next word link ie system dict 
240b 23				inc hl	 
240c			 
240c			;	ld (hl), sysdict		; next word link ie system dict 
240c			;	inc hl 
240c			;	inc hl 
240c			 
240c			;	inc hl 
240c			;	inc hl 
240c			 
240c 3e 02			ld a, 2			; word length is 0 
240e 77				ld (hl), a	 
240f 23				inc hl 
2410			 
2410 3e 7e			ld a, '~'			; word length is 0 
2412 77				ld (hl), a	 
2413 23				inc hl 
2414 3e 00			ld a, 0			; save empty word 
2416 77				ld (hl), a 
2417			 
2417 c9				ret 
2418			 
2418				 
2418			 
2418			forthexec_cleanup: 
2418				FORTH_RSP_POP 
2418 cd 93 20			call macro_forth_rsp_pop 
241b				endm 
# End of macro FORTH_RSP_POP
241b c9				ret 
241c			 
241c			forth_call_hl: 
241c				; taking hl 
241c e5				push hl 
241d c9				ret 
241e			 
241e			; this is called to reset Forth system but keep existing uwords etc 
241e			 
241e			forth_warmstart: 
241e				; setup stack over/under flow checks 
241e				if DEBUG_FORTH_STACK_GUARD 
241e cd 3f 71				call chk_stk_init 
2421				endif 
2421			 
2421				; init stack pointers  - * these stacks go upwards *  
2421 21 af f9			ld hl, cli_ret_stack 
2424 22 f5 f9			ld (cli_ret_sp), hl	 
2427				; set bottom of stack 
2427 3e 00			ld a,0 
2429 77				ld (hl),a 
242a 23				inc hl 
242b 77				ld (hl),a 
242c			 
242c 21 2b f7			ld hl, cli_data_stack 
242f 22 f1 f9			ld (cli_data_sp), hl	 
2432				; set bottom of stack 
2432 3e 00			ld a,0 
2434 77				ld (hl),a 
2435 23				inc hl 
2436 77				ld (hl),a 
2437			 
2437 21 2d f9			ld hl, cli_loop_stack 
243a 22 f3 f9			ld (cli_loop_sp), hl	 
243d				; set bottom of stack 
243d 3e 00			ld a,0 
243f 77				ld (hl),a 
2440 23				inc hl 
2441 77				ld (hl),a 
2442			 
2442				; init extent of current open file 
2442			 
2442 3e 00			ld a, 0 
2444 32 6d fa			ld (store_openext), a 
2447			 
2447 c9				ret 
2448			 
2448			 
2448			; Cold Start - this is called to setup the whole Forth system 
2448			 
2448			forth_init: 
2448			 
2448				; setup stack over/under flow checks 
2448			 
2448			;	if DEBUG_FORTH_STACK_GUARD 
2448			;		call chk_stk_init 
2448			;	endif 
2448			 
2448				; enable auto display updates (slow.....) 
2448			 
2448 3e 01			ld a, 1 
244a 32 3f fa			ld (cli_autodisplay), a 
244d			 
244d				; if storage is in use disable long reads for now 
244d 3e 00			ld a, 0 
244f 32 78 fa			ld (store_longread), a 
2452			 
2452			 
2452				; show start up screen 
2452			 
2452 cd 52 0d			call clear_display 
2455			 
2455 3e 00			ld a,0 
2457 32 61 fa			ld (f_cursor_ptr), a 
245a			 
245a				; set start of word list in start of ram - for use when creating user words 
245a			 
245a 21 00 80			ld hl, baseram 
245d 22 c1 f4			ld (os_last_new_uword), hl 
2460 cd 01 24			call user_word_eol 
2463				 
2463			;		call display_data_sp 
2463			;		call next_page_prompt 
2463			 
2463			 
2463			 
2463			 
2463 c9				ret 
2464			 
2464 .. 00		.bootforth: db " Forth Kernel Init ",0 
2478			 
2478			; TODO push to stack 
2478			 
2478			;  
2478			 
2478			if FORTH_PARSEV2 
2478			 
2478			 
2478				include "forth_parserv2.asm" 
2478			 
2478			endif 
2478			 
2478			 
2478			; parse cli version 1 
2478			 
2478			if FORTH_PARSEV1 
2478			 
2478			 
2478			 
2478			      include "forth_parserv1.asm" 
2478			endif 
2478				 
2478			if FORTH_PARSEV3 
2478			 
2478			 
2478			 
2478			      include "forth_parserv3.asm" 
2478				include "forth_wordsv3.asm" 
2478			endif 
2478			 
2478			if FORTH_PARSEV4 
2478			 
2478			 
2478			 
2478			      include "forth_parserv4.asm" 
2478				include "forth_wordsv4.asm" 
2478			endif 
2478			 
2478			if FORTH_PARSEV5 
2478			 
2478			 
2478			 
2478			      include "forth_parserv5.asm" 
2478			 
2478			 
2478			; A better parser without using malloc and string copies all over the place.  
2478			; Exec in situ should be faster 
2478			 
2478			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2478			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2478			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2478			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2478			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2478			WORD_SYS_END: equ 0   ; Opcode for all user words 
2478			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2478			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2478			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2478			 
2478			; Core word preamble macro 
2478			 
2478			CWHEAD:   macro nxtword opcode lit len opflags 
2478				db WORD_SYS_CORE+opcode             
2478				; internal op code number 
2478				dw nxtword            
2478				; link to next dict word block 
2478				db len + 1 
2478				; literal length of dict word inc zero term 
2478				db lit,0              
2478				; literal dict word 
2478			        ; TODO db opflags        
2478				endm 
2478			 
2478			 
2478			NEXTW: macro  
2478				jp macro_next 
2478				endm 
2478			 
2478			macro_next: 
2478			if DEBUG_FORTH_PARSE_KEY 
2478				DMARK "NXT" 
2478				CALLMONITOR 
2478			endif	 
2478			;	inc hl  ; skip token null term  
2478 ed 4b 43 fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
247c ed 5b 41 fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2480 2a c5 f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2483			if DEBUG_FORTH_PARSE_KEY 
2483				DMARK "}AA" 
2483				CALLMONITOR 
2483			endif	 
2483 c3 86 25			jp execnext 
2486				;jp exec1 
2486			       
2486			 
2486			 
2486			; Another go at the parser to compile  
2486			 
2486			 
2486			; TODO rework parser to change all of the string words to byte tokens 
2486			; TODO do a search for  
2486			 
2486			; TODO first run normal parser to zero term sections 
2486			; TODO for each word do a token look up to get the op code 
2486			; TODO need some means to flag to the exec that this is a byte code form    
2486			 
2486			 
2486			forthcompile: 
2486			 
2486			; 
2486			; line parse: 
2486			;       parse raw input buffer 
2486			;       tokenise the words 
2486			;       malloc new copy (for looping etc) 
2486			;       copy to malloc + current pc in line to start of string and add line term 
2486			;       save on new rsp 
2486			; 
2486			 
2486			; hl to point to the line to tokenise 
2486			 
2486			;	push hl 
2486 22 c5 f4			ld (os_tok_ptr), hl  ; save ptr to string 
2489			 
2489			;	ld a,0		; string term on input 
2489			;	call strlent 
2489			 
2489			;	ld (os_tok_len), hl	 ; save string length 
2489			 
2489			;if DEBUG_FORTH_TOK 
2489			;	ex de,hl		 
2489			;endif 
2489			 
2489			;	pop hl 		; get back string pointer 
2489			 
2489			if DEBUG_FORTH_TOK 
2489						DMARK "TOc" 
2489				CALLMONITOR 
2489			endif 
2489 7e			.cptoken2:    ld a,(hl) 
248a 23				inc hl 
248b fe 7f			cp FORTH_END_BUFFER 
248d 28 29			jr z, .cptokendone2 
248f fe 00			cp 0 
2491 28 25			jr z, .cptokendone2 
2493 fe 22			cp '"' 
2495 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2497 fe 20			cp ' ' 
2499 20 ee			jr nz,  .cptoken2 
249b			 
249b			; TODO consume comments held between ( and ) 
249b			 
249b				; we have a space so change to zero term for dict match later 
249b 2b				dec hl 
249c 3e 00			ld a,0 
249e 77				ld (hl), a 
249f 23				inc hl 
24a0 18 e7			jr .cptoken2 
24a2				 
24a2			 
24a2			.cptokenstr2: 
24a2				; skip all white space until either eol (because forgot to term) or end double quote 
24a2			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24a2				;inc hl ; skip current double quote 
24a2 7e				ld a,(hl) 
24a3 23				inc hl 
24a4 fe 22			cp '"' 
24a6 28 e1			jr z, .cptoken2 
24a8 fe 7f			cp FORTH_END_BUFFER 
24aa 28 0c			jr z, .cptokendone2 
24ac fe 00			cp 0 
24ae 28 08			jr z, .cptokendone2 
24b0 fe 20			cp ' ' 
24b2 28 02			jr z, .cptmp2 
24b4 18 ec			jr .cptokenstr2 
24b6			 
24b6			.cptmp2:	; we have a space so change to zero term for dict match later 
24b6				;dec hl 
24b6				;ld a,"-"	; TODO remove this when working 
24b6				;ld (hl), a 
24b6				;inc hl 
24b6 18 ea			jr .cptokenstr2 
24b8			 
24b8			.cptokendone2: 
24b8				;inc hl 
24b8 3e 7f			ld a, FORTH_END_BUFFER 
24ba 77				ld (hl),a 
24bb 23				inc hl 
24bc 3e 21			ld a, '!' 
24be 77				ld (hl),a 
24bf			 
24bf 2a c5 f4			ld hl,(os_tok_ptr) 
24c2			         
24c2			if DEBUG_FORTH_TOK 
24c2						DMARK "Tc1" 
24c2				CALLMONITOR 
24c2			endif 
24c2			 
24c2				; push exec string to top of return stack 
24c2				FORTH_RSP_NEXT 
24c2 cd 72 20			call macro_forth_rsp_next 
24c5				endm 
# End of macro FORTH_RSP_NEXT
24c5 c9				ret 
24c6			 
24c6			; Another go at the parser need to simplify the process 
24c6			 
24c6			forthparse: 
24c6			 
24c6			; 
24c6			; line parse: 
24c6			;       parse raw input buffer 
24c6			;       tokenise the words 
24c6			;       malloc new copy (for looping etc) 
24c6			;       copy to malloc + current pc in line to start of string and add line term 
24c6			;       save on new rsp 
24c6			; 
24c6			 
24c6			; hl to point to the line to tokenise 
24c6			 
24c6			;	push hl 
24c6 22 c5 f4			ld (os_tok_ptr), hl  ; save ptr to string 
24c9			 
24c9			;	ld a,0		; string term on input 
24c9			;	call strlent 
24c9			 
24c9			;	ld (os_tok_len), hl	 ; save string length 
24c9			 
24c9			;if DEBUG_FORTH_TOK 
24c9			;	ex de,hl		 
24c9			;endif 
24c9			 
24c9			;	pop hl 		; get back string pointer 
24c9			 
24c9			if DEBUG_FORTH_TOK 
24c9						DMARK "TOK" 
24c9				CALLMONITOR 
24c9			endif 
24c9 7e			.ptoken2:    ld a,(hl) 
24ca 23				inc hl 
24cb fe 7f			cp FORTH_END_BUFFER 
24cd 28 29			jr z, .ptokendone2 
24cf fe 00			cp 0 
24d1 28 25			jr z, .ptokendone2 
24d3 fe 22			cp '"' 
24d5 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
24d7 fe 20			cp ' ' 
24d9 20 ee			jr nz,  .ptoken2 
24db			 
24db			; TODO consume comments held between ( and ) 
24db			 
24db				; we have a space so change to zero term for dict match later 
24db 2b				dec hl 
24dc 3e 00			ld a,0 
24de 77				ld (hl), a 
24df 23				inc hl 
24e0 18 e7			jr .ptoken2 
24e2				 
24e2			 
24e2			.ptokenstr2: 
24e2				; skip all white space until either eol (because forgot to term) or end double quote 
24e2			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24e2				;inc hl ; skip current double quote 
24e2 7e				ld a,(hl) 
24e3 23				inc hl 
24e4 fe 22			cp '"' 
24e6 28 e1			jr z, .ptoken2 
24e8 fe 7f			cp FORTH_END_BUFFER 
24ea 28 0c			jr z, .ptokendone2 
24ec fe 00			cp 0 
24ee 28 08			jr z, .ptokendone2 
24f0 fe 20			cp ' ' 
24f2 28 02			jr z, .ptmp2 
24f4 18 ec			jr .ptokenstr2 
24f6			 
24f6			.ptmp2:	; we have a space so change to zero term for dict match later 
24f6				;dec hl 
24f6				;ld a,"-"	; TODO remove this when working 
24f6				;ld (hl), a 
24f6				;inc hl 
24f6 18 ea			jr .ptokenstr2 
24f8			 
24f8			.ptokendone2: 
24f8				;inc hl 
24f8 3e 7f			ld a, FORTH_END_BUFFER 
24fa 77				ld (hl),a 
24fb 23				inc hl 
24fc 3e 21			ld a, '!' 
24fe 77				ld (hl),a 
24ff			 
24ff 2a c5 f4			ld hl,(os_tok_ptr) 
2502			         
2502			if DEBUG_FORTH_TOK 
2502						DMARK "TK1" 
2502				CALLMONITOR 
2502			endif 
2502			 
2502				; push exec string to top of return stack 
2502				FORTH_RSP_NEXT 
2502 cd 72 20			call macro_forth_rsp_next 
2505				endm 
# End of macro FORTH_RSP_NEXT
2505 c9				ret 
2506			 
2506			; 
2506			;	; malloc size + buffer pointer + if is loop flag 
2506			;	ld hl,(os_tok_len) 		 ; get string length 
2506			; 
2506			;	ld a,l 
2506			; 
2506			;	cp 0			; we dont want to use a null string 
2506			;	ret z 
2506			; 
2506			;;	add 3    ; prefix malloc with buffer for current word ptr 
2506			; 
2506			;	add 5     ; TODO when certain not over writing memory remove 
2506			; 
2506			;		 
2506			; 
2506			;if DEBUG_FORTH_TOK 
2506			;			DMARK "TKE" 
2506			;	CALLMONITOR 
2506			;endif 
2506			; 
2506			;	ld l,a 
2506			;	ld h,0 
2506			;;	push hl   ; save required space for the copy later 
2506			;	call malloc 
2506			;if DEBUG_FORTH_TOK 
2506			;			DMARK "TKM" 
2506			;	CALLMONITOR 
2506			;endif 
2506			;	if DEBUG_FORTH_MALLOC_GUARD 
2506			;		push af 
2506			;		call ishlzero 
2506			;;		ld a, l 
2506			;;		add h 
2506			;;		cp 0 
2506			;		pop af 
2506			;		 
2506			;		call z,malloc_error 
2506			;	endif 
2506			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2506			; 
2506			; 
2506			;if DEBUG_FORTH_TOK 
2506			;			DMARK "TKR" 
2506			;	CALLMONITOR 
2506			;endif 
2506			; 
2506			;	FORTH_RSP_NEXT 
2506			; 
2506			;	;inc hl	 ; go past current buffer pointer 
2506			;	;inc hl 
2506			;	;inc hl   ; and past if loop flag 
2506			;		; TODO Need to set flag  
2506			; 
2506			;	 
2506			;	 
2506			;	ex de,hl	; malloc is dest 
2506			;	ld hl, (os_tok_len) 
2506			;;	pop bc 
2506			;	ld c, l                
2506			;	ld b,0 
2506			;	ld hl, (os_tok_ptr) 
2506			; 
2506			;if DEBUG_FORTH_TOK 
2506			;			DMARK "TKT" 
2506			;	CALLMONITOR 
2506			;endif 
2506			; 
2506			;	; do str cpy 
2506			; 
2506			;	ldir      ; copy byte in hl to de 
2506			; 
2506			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2506			; 
2506			;if DEBUG_FORTH_TOK 
2506			; 
2506			;			DMARK "TKY" 
2506			;	CALLMONITOR 
2506			;endif 
2506			;	;ld a,0 
2506			;	;ld a,FORTH_END_BUFFER 
2506			;	ex de, hl 
2506			;	;dec hl			 ; go back over the space delim at the end of word 
2506			;	;ld (hl),a 
2506			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2506			;	ld a,FORTH_END_BUFFER 
2506			;	ld (hl),a 
2506			;	inc hl 
2506			;	ld a,FORTH_END_BUFFER 
2506			;	ld (hl),a 
2506			; 
2506			;	; init the malloc area data 
2506			;	; set pc for in current area 
2506			;	;ld hl, (os_tok_malloc) 
2506			;	;inc hl 
2506			;	;inc hl 
2506			;	;inc hl 
2506			;	;ex de,hl 
2506			;	;ld hl, (os_tok_malloc) 
2506			;	;ld (hl),e 
2506			;	;inc hl 
2506			;	;ld (hl),d 
2506			; 
2506			; 
2506			;	ld hl,(os_tok_malloc) 
2506			;if DEBUG_FORTH_PARSE_KEY 
2506			;			DMARK "TKU" 
2506			;	CALLMONITOR 
2506			;endif 
2506			; 
2506			;	ret 
2506			 
2506			forthexec: 
2506			 
2506			; line exec: 
2506			; forth parser 
2506			 
2506			; 
2506			;       get current exec line on rsp 
2506			 
2506				FORTH_RSP_TOS 
2506 cd 89 20			call macro_forth_rsp_tos 
2509				endm 
# End of macro FORTH_RSP_TOS
2509			 
2509			;       restore current pc - hl points to malloc of data 
2509			 
2509				;ld e, (hl) 
2509				;inc hl 
2509				;ld d, (hl) 
2509				;ex de,hl 
2509			 
2509			 
2509			exec1: 
2509 22 c5 f4			ld (os_tok_ptr), hl 
250c			 
250c				; copy our PC to working vars  
250c 22 43 fa			ld (cli_ptr), hl 
250f 22 41 fa			ld (cli_origptr), hl 
2512			 
2512 7e				ld a,(hl) 
2513 fe 7f			cp FORTH_END_BUFFER 
2515 c8				ret z 
2516			 
2516				; skip any nulls 
2516			 
2516 fe 00			cp 0 
2518 20 03			jr nz, .execword 
251a 23				inc hl 
251b 18 ec			jr exec1 
251d			 
251d			 
251d			.execword: 
251d			 
251d			 
251d			 
251d			if DEBUG_FORTH_PARSE_KEY 
251d						DMARK "KYQ" 
251d				CALLMONITOR 
251d			endif 
251d			;       while at start of word: 
251d			; get start of dict (in user area first) 
251d			 
251d 21 00 80		ld hl, baseram 
2520			;ld hl, sysdict 
2520 22 45 fa		ld (cli_nextword),hl 
2523			;           match word at pc 
2523			;           exec word 
2523			;           or push to dsp 
2523			;           forward to next token 
2523			;           if line term pop rsp and exit 
2523			;        
2523			 
2523			if DEBUG_FORTH_PARSE_KEY 
2523						DMARK "KYq" 
2523				CALLMONITOR 
2523			endif 
2523			 
2523			; 
2523			; word comp 
2523			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2523			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2523			;    move to start of word  
2523			;    compare word to cli_token 
2523			 
2523			.execpnword:	; HL at start of a word in the dictionary to check 
2523			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2523			;	ld (cli_ptr), hl 
2523			 
2523 2a 45 fa			ld hl,(cli_nextword) 
2526			 
2526 cd c9 25			call forth_tok_next 
2529			; tok next start here 
2529			;	; TODO skip compiled symbol for now 
2529			;	inc hl 
2529			; 
2529			;	; save pointer to next word 
2529			; 
2529			;	; hl now points to the address of the next word pointer  
2529			;	ld e, (hl) 
2529			;	inc hl 
2529			;	ld d, (hl) 
2529			;	inc l 
2529			; 
2529			;	ex de,hl 
2529			;if DEBUG_FORTH_PARSE_NEXTWORD 
2529			;	push bc 
2529			;	ld bc, (cli_nextword) 
2529			;			DMARK "NXW" 
2529			;	CALLMONITOR 
2529			;	pop bc 
2529			;endif 
2529			; tok next end here 
2529 22 45 fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
252c eb				ex de, hl 
252d			 
252d			 
252d				; save the pointer of the current token - 1 to check against 
252d				 
252d 22 49 fa			ld (cli_token), hl   
2530				; TODO maybe remove below save if no debug 
2530				; save token string ptr for any debug later 
2530 23				inc hl  
2531 22 4b fa			ld (cli_origtoken), hl 
2534 2b				dec hl 
2535				; save pointer to the start of the next dictionay word 
2535 7e				ld a,(hl)   ; get string length 
2536 47				ld b,a 
2537			.execpnwordinc:  
2537 23				inc hl 
2538 10 fd			djnz .execpnwordinc 
253a 22 47 fa			ld (cli_execword), hl      ; save start of this words code 
253d			 
253d				; now check the word token against the string being parsed 
253d			 
253d 2a 49 fa			ld hl,(cli_token) 
2540 23				inc hl     ; skip string length (use zero term instead to end) 
2541 22 49 fa			ld (cli_token), hl 
2544			 
2544			if DEBUG_FORTH_PARSE_KEY 
2544						DMARK "KY2" 
2544			endif 
2544			if DEBUG_FORTH_PARSE_EXEC 
2544				; see if disabled 
2544			 
2544				ld a, (os_view_disable) 
2544				cp '*' 
2544				jr z, .skip 
2544			 
2544				push hl 
2544				push hl 
2544				call clear_display 
2544				ld de, .compword 
2544				ld a, display_row_1 
2544				call str_at_display 
2544				pop de 
2544				ld a, display_row_2 
2544				call str_at_display 
2544				ld hl,(cli_ptr) 
2544				ld a,(hl) 
2544			        ld hl, os_word_scratch 
2544				ld (hl),a 
2544				ld a,0 
2544				inc hl 
2544				ld (hl),a 	 
2544				ld de, os_word_scratch 
2544				ld a, display_row_2+10 
2544				call str_at_display 
2544				call update_display 
2544				ld a, 100 
2544				call aDelayInMS 
2544				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2544				call delay250ms 
2544				endif 
2544				pop hl 
2544			.skip:  
2544			endif	 
2544			.execpnchar:    ; compare char between token and string to parse 
2544			 
2544			if DEBUG_FORTH_PARSE_KEY 
2544						DMARK "Ky3" 
2544			endif 
2544			if DEBUG_FORTH_PARSE_EXEC 
2544				; see if disabled 
2544			 
2544				ld a, (os_view_disable) 
2544				cp '*' 
2544				jr z, .skip2 
2544			 
2544			;	call clear_display 
2544			ld hl,(cli_token) 
2544			ld a,(hl) 
2544			ld (os_word_scratch),a 
2544				ld hl,(cli_ptr) 
2544			ld a,(hl) 
2544				ld (os_word_scratch+1),a 
2544				ld a,0 
2544				ld (os_word_scratch+2),a 
2544				ld de,os_word_scratch 
2544				ld a,display_row_4 
2544				call str_at_display 
2544				call update_display 
2544			.skip2:  
2544			endif 
2544 2a 49 fa			ld hl,(cli_token) 
2547 7e				ld a, (hl)	 ; char in word token 
2548 23				inc hl 		; move to next char 
2549 22 49 fa			ld (cli_token), hl ; and save it 
254c 47				ld b,a 
254d			 
254d 2a 43 fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
2550 7e				ld a,(hl) 
2551 23				inc hl 
2552 22 43 fa			ld (cli_ptr), hl		; move to next char 
2555 cd db 13			call toUpper 		; make sure the input string matches case 
2558			 
2558			if DEBUG_FORTH_PARSE 
2558			endif 
2558			 
2558				; input stream end of token is a space so get rid of it 
2558			 
2558			;	cp ' ' 
2558			;	jr nz, .pnskipspace 
2558			; 
2558			;	ld a, 0		; make same term as word token term 
2558			; 
2558			;.pnskipspace: 
2558			 
2558			if DEBUG_FORTH_PARSE_KEY 
2558						DMARK "KY7" 
2558			endif 
2558 b8				cp b 
2559 c2 6f 25			jp nz, .execpnskipword	 ; no match so move to next word 
255c				 
255c			;    if same 
255c			;       scan for string terms 0 for token and 32 for input 
255c			 
255c				 
255c			if DEBUG_FORTH_PARSE_KEY 
255c						DMARK "KY8" 
255c			endif 
255c			 
255c 80				add b			 
255d fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
255f							; TODO need to make sure last word in zero term string is accounted for 
255f 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2561			 
2561			 
2561				; at end of both strings so both are exact match 
2561			 
2561			;       skip ptr for next word 
2561			 
2561 2a 43 fa			ld hl,(cli_ptr) 	; at input string term 
2564 23				inc hl			 ; at next char 
2565 22 43 fa			ld (cli_ptr), hl     ; save for next round of the parser 
2568 22 41 fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
256b				 
256b				 
256b			if DEBUG_FORTH_PARSE_KEY 
256b						DMARK "KY3" 
256b			endif 
256b			 
256b			 
256b			 
256b			;       exec code block 
256b			if DEBUG_FORTH_JP 
256b				call clear_display 
256b				call update_display 
256b				call delay1s 
256b				ld hl, (cli_execword)     ; save for next check if no match on this word 
256b				ld a,h 
256b				ld hl, os_word_scratch 
256b				call hexout 
256b				ld hl, (cli_execword)     ; save for next check if no match on this word 
256b				ld a,l 
256b				ld hl, os_word_scratch+2 
256b				call hexout 
256b				ld hl, os_word_scratch+4 
256b				ld a,0 
256b				ld (hl),a 
256b				ld de,os_word_scratch 
256b				call str_at_display 
256b					ld a, display_row_2 
256b					call str_at_display 
256b				ld de, (cli_origtoken) 
256b				ld a, display_row_1+10 
256b					call str_at_display 
256b			 
256b				ld a,display_row_1 
256b				ld de, .foundword 
256b				ld a, display_row_3 
256b				call str_at_display 
256b				call update_display 
256b				call delay1s 
256b				call delay1s 
256b				call delay1s 
256b			endif 
256b			 
256b			if DEBUG_FORTH_PARSE_KEY 
256b						DMARK "KYj" 
256b			endif 
256b				; TODO save the word pointer in this exec 
256b			 
256b 2a 47 fa			ld hl,(cli_execword) 
256e e9				jp (hl) 
256f			 
256f			 
256f			;    if not same 
256f			;	scan for zero term 
256f			;	get ptr for next word 
256f			;	goto word comp 
256f			 
256f			.execpnskipword:	; get pointer to next word 
256f 2a 45 fa			ld hl,(cli_nextword) 
2572			 
2572 7e				ld a,(hl) 
2573 fe 00			cp WORD_SYS_END 
2575			;	cp 0 
2575 28 09			jr z, .execendofdict			 ; at end of words 
2577			 
2577			if DEBUG_FORTH_PARSE_KEY 
2577						DMARK "KY4" 
2577			endif 
2577			if DEBUG_FORTH_PARSE_EXEC 
2577			 
2577				; see if disabled 
2577			 
2577				ld a, (os_view_disable) 
2577				cp '*' 
2577				jr z, .noskip 
2577			 
2577			 
2577				ld de, .nowordfound 
2577				ld a, display_row_3 
2577				call str_at_display 
2577				call update_display 
2577				ld a, 100 
2577				call aDelayInMS 
2577				 
2577				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2577					call delay250ms 
2577				endif 
2577			.noskip:  
2577			 
2577			endif	 
2577			 
2577 2a 41 fa			ld hl,(cli_origptr) 
257a 22 43 fa			ld (cli_ptr),hl 
257d			 
257d			if DEBUG_FORTH_PARSE_KEY 
257d						DMARK "KY5" 
257d			endif 
257d c3 23 25			jp .execpnword			; else go to next word 
2580			 
2580			.execendofdict:  
2580			 
2580			if DEBUG_FORTH_PARSE_KEY 
2580						DMARK "KYe" 
2580			endif 
2580			if DEBUG_FORTH_PARSE_EXEC 
2580				; see if disabled 
2580			 
2580				ld a, (os_view_disable) 
2580				cp '*' 
2580				jr z, .ispskip 
2580			 
2580				call clear_display 
2580				call update_display 
2580				call delay1s 
2580				ld de, (cli_origptr) 
2580				ld a, display_row_1 
2580				call str_at_display 
2580				 
2580				ld de, .enddict 
2580				ld a, display_row_3 
2580				call str_at_display 
2580				call update_display 
2580				ld a, 100 
2580				call aDelayInMS 
2580				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2580				call delay1s 
2580				call delay1s 
2580				call delay1s 
2580				endif 
2580			.ispskip:  
2580				 
2580			endif	 
2580			 
2580			 
2580			 
2580				; if the word is not a keyword then must be a literal so push it to stack 
2580			 
2580			; push token to stack to end of word 
2580			 
2580				STACKFRAME ON $1efe $2f9f 
2580				if DEBUG_STACK_IMB 
2580					if ON 
2580						exx 
2580						ld de, $1efe 
2580						ld a, d 
2580						ld hl, curframe 
2580						call hexout 
2580						ld a, e 
2580						ld hl, curframe+2 
2580						call hexout 
2580						ld hl, $1efe 
2580						push hl 
2580						ld hl, $2f9f 
2580						push hl 
2580						exx 
2580					endif 
2580				endif 
2580			endm 
# End of macro STACKFRAME
2580			 
2580 2a c5 f4		ld hl,(os_tok_ptr) 
2583 cd 34 22		call forth_apush 
2586			 
2586				STACKFRAMECHK ON $1efe $2f9f 
2586				if DEBUG_STACK_IMB 
2586					if ON 
2586						exx 
2586						ld hl, $2f9f 
2586						pop de   ; $2f9f 
2586						call cmp16 
2586						jr nz, .spnosame 
2586						ld hl, $1efe 
2586						pop de   ; $1efe 
2586						call cmp16 
2586						jr z, .spfrsame 
2586						.spnosame: call showsperror 
2586						.spfrsame: nop 
2586						exx 
2586					endif 
2586				endif 
2586			endm 
# End of macro STACKFRAMECHK
2586			 
2586			execnext: 
2586			 
2586			if DEBUG_FORTH_PARSE_KEY 
2586						DMARK "KY>" 
2586			endif 
2586			; move past token to next word 
2586			 
2586 2a c5 f4		ld hl, (os_tok_ptr) 
2589 3e 00		ld a, 0 
258b 01 ff 00		ld bc, 255     ; input buffer size 
258e ed b1		cpir 
2590			 
2590			if DEBUG_FORTH_PARSE_KEY 
2590						DMARK "KY!" 
2590				CALLMONITOR 
2590			endif	 
2590			; TODO this might place hl on the null, so will need to forward on??? 
2590			;inc hl   ; see if this gets onto the next item 
2590			 
2590			 
2590			; TODO pass a pointer to the buffer to push 
2590			; TODO call function to push 
2590			 
2590			; look for end of input 
2590			 
2590			;inc hl 
2590			;ld a,(hl) 
2590			;cp FORTH_END_BUFFER 
2590			;ret z 
2590			 
2590			 
2590 c3 09 25		jp exec1 
2593			 
2593			 
2593			 
2593			 
2593			 
2593			 
2593			 
2593			 
2593			 
2593			findnexttok: 
2593			 
2593				; hl is pointer to move 
2593				; de is the token to locate 
2593			 
2593					if DEBUG_FORTH 
2593						DMARK "NTK" 
2593						CALLMONITOR 
2593					endif 
2593 d5				push de 
2594			 
2594			.fnt1:	 
2594				; find first char of token to locate 
2594			 
2594 1a				ld a, (de) 
2595 4f				ld c,a 
2596 7e				ld a,(hl) 
2597 cd db 13			call toUpper 
259a					if DEBUG_FORTH 
259a						DMARK "NT1" 
259a						CALLMONITOR 
259a					endif 
259a b9				cp c 
259b			 
259b 28 03			jr z, .fnt2cmpmorefirst	 
259d			 
259d				; first char not found move to next char 
259d			 
259d 23				inc hl 
259e 18 f4			jr .fnt1 
25a0			 
25a0			.fnt2cmpmorefirst:	 
25a0				; first char of token found.  
25a0			 
25a0 e5				push hl     ; save start of token just in case it is the right one 
25a1 d9				exx 
25a2 e1				pop hl        ; save it to hl' 
25a3 d9				exx 
25a4			 
25a4			 
25a4			.fnt2cmpmore:	 
25a4				; compare the rest 
25a4				 
25a4 23				inc hl 
25a5 13				inc de 
25a6				 
25a6 1a				ld a, (de) 
25a7 4f				ld c,a 
25a8 7e				ld a,(hl) 
25a9 cd db 13			call toUpper 
25ac			 
25ac					if DEBUG_FORTH 
25ac						DMARK "NT2" 
25ac						CALLMONITOR 
25ac					endif 
25ac				; c has the token to find char 
25ac				; a has the mem to scan char 
25ac			 
25ac b9				cp c 
25ad 28 04			jr z,.fntmatch1 
25af			 
25af				; they are not the same 
25af			 
25af					if DEBUG_FORTH 
25af						DMARK "NT3" 
25af						CALLMONITOR 
25af					endif 
25af d1				pop de	; reset de token to look for 
25b0 d5				push de 
25b1 18 e1			jr .fnt1 
25b3				 
25b3			.fntmatch1: 
25b3			 
25b3				; is the same char a null which means we might have a full hit? 
25b3					if DEBUG_FORTH 
25b3						DMARK "NT4" 
25b3						CALLMONITOR 
25b3					endif 
25b3			 
25b3 fe 00			cp 0 
25b5 28 0b			jr z, .fntmatchyes 
25b7			 
25b7				; are we at the end of the token to find? 
25b7			 
25b7					if DEBUG_FORTH 
25b7						DMARK "NT5" 
25b7						CALLMONITOR 
25b7					endif 
25b7 3e 00			ld a, 0 
25b9 b9				cp c 
25ba			 
25ba c2 a4 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
25bd			 
25bd					if DEBUG_FORTH 
25bd						DMARK "NT6" 
25bd						CALLMONITOR 
25bd					endif 
25bd				; token to find is exhusted but no match to stream 
25bd			 
25bd				; restore tok pointer and continue on 
25bd d1				pop de 
25be d5				push de 
25bf c3 94 25			jp .fnt1 
25c2			 
25c2			 
25c2			.fntmatchyes: 
25c2			 
25c2				; hl now contains the end of the found token 
25c2			 
25c2				; get rid of saved token pointer to find 
25c2			 
25c2 d1				pop de 
25c3			 
25c3					if DEBUG_FORTH 
25c3						DMARK "NT9" 
25c3						CALLMONITOR 
25c3					endif 
25c3			 
25c3				; hl will be on the null term so forward on 
25c3			 
25c3				; get back the saved start of the token 
25c3			 
25c3 d9				exx 
25c4 e5				push hl     ; save start of token just in case it is the right one 
25c5 d9				exx 
25c6 e1				pop hl        ; save it to hl 
25c7			 
25c7 c9				ret 
25c8			 
25c8			 
25c8			; LIST needs to find a specific token   
25c8			; FORGET needs to find a spefici token 
25c8			 
25c8			; SAVE needs to find all tokens by flag 
25c8			; WORDS just needs to scan through all  by flag 
25c8			; UWORDS needs to scan through all by flag 
25c8			 
25c8			 
25c8			; given hl as pointer to start of dict look up string 
25c8			; return hl as pointer to start of word block 
25c8			; or 0 if not found 
25c8			 
25c8			forth_find_tok: 
25c8 c9				ret 
25c9			 
25c9			; given hl as pointer to dict structure 
25c9			; move to the next dict block structure 
25c9			 
25c9			forth_tok_next: 
25c9				; hl now points to the address of the next word pointer  
25c9				; TODO skip compiled symbol for now 
25c9			;	push de 
25c9 23				inc hl 
25ca 5e				ld e, (hl) 
25cb 23				inc hl 
25cc 56				ld d, (hl) 
25cd 23				inc hl 
25ce			 
25ce eb				ex de,hl 
25cf			if DEBUG_FORTH_PARSE_NEXTWORD 
25cf				push bc 
25cf				ld bc, (cli_nextword) 
25cf						DMARK "NXW" 
25cf				CALLMONITOR 
25cf				pop bc 
25cf			endif 
25cf			;	pop de	 
25cf c9				ret 
25d0			 
25d0			 
25d0			 
25d0			; eof 
# End of file forth_parserv5.asm
25d0				include "forth_wordsv4.asm" 
25d0			 
25d0			; the core word dictionary v4 
25d0			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
25d0			 
25d0			; this is a linked list for each of the system words used 
25d0			; user defined words will follow the same format but will be in ram 
25d0			 
25d0			 
25d0			; 
25d0			; 
25d0			; define linked list: 
25d0			; 
25d0			; 1. compiled byte op code 
25d0			; 2. len of text word 
25d0			; 3. text word 
25d0			; 4. ptr to next dictionary word 
25d0			; 5. asm, calls etc for the word 
25d0			; 
25d0			;  if 1 == 0 then last word in dict  
25d0			;   
25d0			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
25d0			;  
25d0			;  
25d0			; create basic standard set of words 
25d0			; 
25d0			;  
25d0			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
25d0			; 2DUP 2DROP 2SWAP  
25d0			; @ C@ - get byte  
25d0			; ! C! - store byte 
25d0			; 0< true if less than zero 
25d0			; 0= true if zero 
25d0			; < >  
25d0			; = true if same 
25d0			; variables 
25d0			 
25d0			 
25d0			; Hardware specific words I may need 
25d0			; 
25d0			; IN OUT  
25d0			; calls to key util functions 
25d0			; calls to hardward abstraction stuff 
25d0			; easy control of frame buffers and lcd i/o 
25d0			; keyboard  
25d0			 
25d0			 
25d0			;DICT: macro 
25d0			; op_code, len, word, next 
25d0			;    word: 
25d0			;    db op_code 
25d0			;    ds word zero term 
25d0			;    dw next 
25d0			;    endm 
25d0			 
25d0			 
25d0			 
25d0			 
25d0			; op code 1 is a flag for user define words which are to be handled differently 
25d0			 
25d0			 
25d0			; 
25d0			; 
25d0			;    TODO on entry to a word this should be the expected environment 
25d0			;    hl - tos value if number then held, if string this is the ptr 
25d0			;    de -  
25d0			 
25d0			 
25d0			; opcode ranges 
25d0			; 0 - end of word dict 
25d0			; 255 - user define words 
25d0			 
25d0			sysdict: 
25d0			include "forth_opcodes.asm" 
25d0			; op codes for forth keywords 
25d0			; free to use code 0  
25d0				OPCODE_HEAP: equ  1 
25d0				OPCODE_EXEC: equ 2 
25d0				OPCODE_DUP: equ 3 
25d0				OPCODE_SWAP: equ 4 
25d0				OPCODE_COLN: equ 5 
25d0				OPCODE_SCOLN: equ 6 
25d0				OPCODE_DROP: equ 7 
25d0				OPCODE_DUP2: equ 8 
25d0				OPCODE_DROP2: equ 9 
25d0				OPCODE_SWAP2: equ 10 
25d0				OPCODE_AT: equ 11 
25d0				OPCODE_CAT: equ 12 
25d0				OPCODE_BANG: equ 13 
25d0				OPCODE_CBANG: equ 14 
25d0				OPCODE_SCALL: equ 15 
25d0				OPCODE_DEPTH: equ 16 
25d0				OPCODE_OVER: equ 17 
25d0				OPCODE_PAUSE: equ 18 
25d0				OPCODE_PAUSES: equ 19 
25d0				OPCODE_ROT: equ 20 
25d0			;free to reuse	OPCODE_WORDS: equ 21 
25d0			        OPCODE_NOT: equ 21 
25d0				OPCODE_UWORDS: equ 22 
25d0				OPCODE_BP: equ 23 
25d0				OPCODE_MONITOR: equ 24  
25d0				OPCODE_MALLOC: equ 25 
25d0				OPCODE_FREE: equ 26 
25d0				OPCODE_LIST: equ 27 
25d0				OPCODE_FORGET: equ 28 
25d0				OPCODE_NOP: equ 29 
25d0				OPCODE_COMO: equ 30 
25d0				OPCODE_COMC: equ 31 
25d0			;free to reuse	OPCODE_ENDCORE: equ 32 
25d0				OPCODE_AFTERSOUND: equ 33 
25d0				OPCODE_GP2: equ 34 
25d0				OPCODE_GP3: equ 35 
25d0				OPCODE_GP4: equ 36 
25d0				OPCODE_SIN: equ 37 
25d0				OPCODE_SOUT: equ 38 
25d0				OPCODE_SPIO: equ 39 
25d0				OPCODE_SPICEH: equ 40 
25d0				OPCODE_SPIOb: equ 41 
25d0				OPCODE_SPII: equ 42 
25d0				OPCODE_SESEL: equ 43 
25d0				OPCODE_CARTDEV: equ 44 
25d0			; free to reuse	OPCODE_ENDDEVICE: equ 45 
25d0				OPCODE_FB: equ 46 
25d0				OPCODE_EMIT: equ 47 
25d0				OPCODE_DOTH: equ 48 
25d0				OPCODE_DOTF: equ 49 
25d0				OPCODE_DOT: equ 50 
25d0				OPCODE_CLS: equ 51 
25d0				OPCODE_DRAW: equ 52 
25d0				OPCODE_DUMP: equ 53 
25d0				OPCODE_CDUMP: equ 54 
25d0				OPCODE_DAT: equ 55 
25d0				OPCODE_HOME: equ 56 
25d0				OPCODE_SPACE: equ 57 
25d0				OPCODE_SPACES: equ 58 
25d0				OPCODE_SCROLL: equ 59 
25d0				OPCODE_ATQ: equ 60 
25d0				OPCODE_AUTODSP: equ 61 
25d0				OPCODE_MENU: equ 62 
25d0			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
25d0				OPCODE_THEN: equ 64 
25d0				OPCODE_ELSE: equ 65 
25d0				OPCODE_DO: equ 66 
25d0				OPCODE_LOOP: equ 67 
25d0				OPCODE_I: equ 68 
25d0				OPCODE_DLOOP: equ 69  
25d0				OPCODE_REPEAT: equ 70  
25d0				OPCODE_UNTIL: equ 71 
25d0				OPCODE_ENDFLOW: equ 72 
25d0				OPCODE_WAITK: equ 73 
25d0				OPCODE_ACCEPT: equ 74 
25d0				OPCODE_EDIT: equ 75 
25d0			;free to reuse	OPCODE_ENDKEY: equ 76 
25d0				OPCODE_LZERO: equ 77 
25d0				OPCODE_TZERO: equ 78 
25d0				OPCODE_LESS: equ 79 
25d0				OPCODE_GT: equ 80 
25d0				OPCODE_EQUAL: equ 81  
25d0			;free to reuse	OPCODE_ENDLOGIC: equ 82 
25d0				OPCODE_NEG: equ 83 
25d0				OPCODE_DIV: equ 84 
25d0				OPCODE_MUL: equ 85 
25d0				OPCODE_MIN: equ 86 
25d0				OPCODE_MAX: equ 87 
25d0				OPCODE_RND16: equ 88 
25d0				OPCODE_RND8: equ 89 
25d0				OPCODE_RND: equ 90 
25d0			;free to reuse	OPCODE_ENDMATHS: equ 91  
25d0				OPCODE_BYNAME: equ 92 
25d0				OPCODE_DIR: equ 93 
25d0				OPCODE_SAVE: equ 94 
25d0				OPCODE_LOAD: equ 95 
25d0				OPCODE_BSAVE: equ 96 
25d0				OPCODE_BLOAD: equ 97 
25d0				OPCODE_SEO: equ 98  
25d0				OPCODE_SEI: equ 99 
25d0				OPCODE_SFREE: equ 100 
25d0				OPCODE_SIZE: equ 101 
25d0				OPCODE_CREATE: equ 102 
25d0				OPCODE_APPEND: equ 103 
25d0				OPCODE_SDEL: equ 104 
25d0				OPCODE_OPEN: equ 105 
25d0				OPCODE_READ: equ 106 
25d0				OPCODE_EOF: equ 106 
25d0				OPCODE_FORMAT: equ 107 
25d0				OPCODE_LABEL: equ 108 
25d0				OPCODE_LABELS: equ 109 
25d0			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
25d0				OPCODE_UPPER: equ 111 
25d0				OPCODE_LOWER: equ 112 
25d0				OPCODE_SUBSTR: equ 113 
25d0				OPCODE_LEFT: equ 114 
25d0				OPCODE_RIGHT: equ 115 
25d0				OPCODE_STR2NUM: equ 116 
25d0				OPCODE_NUM2STR: equ 117 
25d0				OPCODE_CONCAT: equ 118 
25d0				OPCODE_FIND: equ 119 
25d0				OPCODE_LEN: equ 120 
25d0				OPCODE_CHAR: equ 121 
25d0			; free to reuse	OPCODE_STRLEN: equ 122 
25d0			; free to reuse	OPCODE_ENDSTR: equ 123 
25d0				OPCODE_V0S: equ 124 
25d0				OPCODE_V0Q: equ 125 
25d0				OPCODE_V1S: equ 126 
25d0				OPCODE_V1Q: equ 127 
25d0				OPCODE_V2S: equ 128 
25d0				OPCODE_V2Q: equ 129 
25d0				OPCODE_V3S: equ 130 
25d0				OPCODE_V3Q: equ 131 
25d0			;free to reuse	OPCODE_END: equ 132 
25d0				OPCODE_ZDUP: equ 133 
25d0			 
25d0			; eof 
# End of file forth_opcodes.asm
25d0			 
25d0			include "forth_words_core.asm" 
25d0			 
25d0			; | ## Core Words 
25d0			 
25d0			;if MALLOC_4 
25d0			 
25d0			.HEAP: 
25d0				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
25d0 15				db WORD_SYS_CORE+OPCODE_HEAP             
25d1 0f 26			dw .EXEC            
25d3 05				db 4 + 1 
25d4 .. 00			db "HEAP",0              
25d9				endm 
# End of macro CWHEAD
25d9			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
25d9			; | | u1 - Current number of bytes in the heap 
25d9			; | | u2 - Remaining bytes left on the heap 
25d9			; | |  
25d9			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
25d9			 
25d9			 
25d9					if DEBUG_FORTH_WORDS_KEY 
25d9						DMARK "HEP" 
25d9 f5				push af  
25da 3a ee 25			ld a, (.dmark)  
25dd 32 6e fe			ld (debug_mark),a  
25e0 3a ef 25			ld a, (.dmark+1)  
25e3 32 6f fe			ld (debug_mark+1),a  
25e6 3a f0 25			ld a, (.dmark+2)  
25e9 32 70 fe			ld (debug_mark+2),a  
25ec 18 03			jr .pastdmark  
25ee ..			.dmark: db "HEP"  
25f1 f1			.pastdmark: pop af  
25f2			endm  
# End of macro DMARK
25f2						CALLMONITOR 
25f2 cd fb 19			call break_point_state  
25f5				endm  
# End of macro CALLMONITOR
25f5					endif 
25f5 2a 0a 80				ld hl, (free_list )      
25f8 11 0e 80				ld de, heap_start 
25fb			 
25fb ed 52				sbc hl, de  
25fd			 
25fd cd cb 20				call forth_push_numhl 
2600			 
2600			 
2600 ed 5b 0a 80			ld de, (free_list )      
2604 21 aa f1				ld hl, heap_end 
2607			 
2607 ed 52				sbc hl, de 
2609			 
2609 cd cb 20				call forth_push_numhl 
260c					 
260c			 
260c					 
260c			 
260c			 
260c			 
260c					NEXTW 
260c c3 78 24			jp macro_next 
260f				endm 
# End of macro NEXTW
260f			;endif 
260f			 
260f			.EXEC: 
260f			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
260f			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
260f			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
260f			;; > > 
260f			;; > >   
260f			;	STACKFRAME OFF $5efe $5f9f 
260f			; 
260f			;		if DEBUG_FORTH_WORDS_KEY 
260f			;			DMARK "EXE" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			; 
260f			;	FORTH_DSP_VALUEHL 
260f			; 
260f			;	FORTH_DSP_POP 
260f			; 
260f			;		if DEBUG_FORTH_WORDS 
260f			;			DMARK "EX1" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			;;	ld e,(hl) 
260f			;;	inc hl 
260f			;;	ld d,(hl) 
260f			;;	ex de,hl 
260f			; 
260f			;;		if DEBUG_FORTH_WORDS 
260f			;;			DMARK "EX2" 
260f			;;			CALLMONITOR 
260f			;;		endif 
260f			;	push hl 
260f			; 
260f			;	;ld a, 0 
260f			;	;ld a, FORTH_END_BUFFER 
260f			;	call strlenz 
260f			;	inc hl   ; include zero term to copy 
260f			;	inc hl   ; include term 
260f			;	inc hl   ; include term 
260f			;	ld b,0 
260f			;	ld c,l 
260f			;	pop hl 
260f			;	ld de, execscratch 
260f			;		if DEBUG_FORTH_WORDS 
260f			;			DMARK "EX3" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			;	ldir 
260f			; 
260f			; 
260f			;	ld hl, execscratch 
260f			; 
260f			;		if DEBUG_FORTH_WORDS 
260f			;			DMARK "EXe" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			; 
260f			;	call forthparse 
260f			;	call forthexec 
260f			;;	call forthexec_cleanup 
260f			;;	call forthparse 
260f			;;	call forthexec 
260f			; 
260f			;	STACKFRAMECHK OFF $5efe $5f9f 
260f			; 
260f			;	; an immediate word so no need to process any more words 
260f			;	ret 
260f			;	NEXTW 
260f			 
260f			; dead code - old version  
260f			;	FORTH_RSP_NEXT 
260f			 
260f			;  
260f			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
260f			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
260f			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
260f			;	push hl 
260f			;	push de 
260f			;	push bc 
260f			; 
260f			; 
260f			;		if DEBUG_FORTH_WORDS_KEY 
260f			;			DMARK "EXR" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			; 
260f			; 
260f			; 
260f			;	;v5 FORTH_DSP_VALUE 
260f			;	FORTH_DSP_VALUEHL 
260f			; 
260f			;	; TODO do string type checks 
260f			; 
260f			;;v5	inc hl   ; skip type 
260f			; 
260f			;	push hl  ; source code  
260f			;		if DEBUG_FORTH_WORDS 
260f			;			DMARK "EX1" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			;	ld a, 0 
260f			;	call strlent 
260f			; 
260f			;	inc hl 
260f			;	inc hl 
260f			;	inc hl 
260f			;	inc hl 
260f			; 
260f			;	push hl    ; size 
260f			; 
260f			;		if DEBUG_FORTH_WORDS 
260f			;			DMARK "EX2" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			;	call malloc 
260f			; 
260f			;	ex de, hl    ; de now contains malloc area 
260f			;	pop bc   	; get byte count 
260f			;	pop hl      ; get string to copy 
260f			; 
260f			;	push de     ; save malloc for free later 
260f			; 
260f			;		if DEBUG_FORTH_WORDS 
260f			;			DMARK "EX3" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			;	ldir       ; duplicate string 
260f			; 
260f			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
260f			;	 
260f			;	; TODO fix the parse would be better than this...  
260f			;	ex de, hl 
260f			;	dec hl 
260f			;	ld a, 0 
260f			;	ld (hl), a 
260f			;	dec hl 
260f			;	ld a, ' ' 
260f			;	ld (hl), a 
260f			;	dec hl 
260f			;	ld (hl), a 
260f			; 
260f			;	dec hl 
260f			;	ld (hl), a 
260f			; 
260f			; 
260f			;	FORTH_DSP_POP  
260f			; 
260f			;	pop hl     
260f			;	push hl    ; save malloc area 
260f			; 
260f			;		if DEBUG_FORTH_WORDS 
260f			;			DMARK "EX4" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			; 
260f			;	call forthparse 
260f			;	call forthexec 
260f			;	 
260f			;	pop hl 
260f			;	if DEBUG_FORTH_WORDS 
260f			;		DMARK "EX5" 
260f			;		CALLMONITOR 
260f			;	endif 
260f			; 
260f			;	if FORTH_ENABLE_FREE 
260f			;	call free 
260f			;	endif 
260f			; 
260f			;	if DEBUG_FORTH_WORDS 
260f			;		DMARK "EX6" 
260f			;		CALLMONITOR 
260f			;	endif 
260f			; 
260f			;	pop bc 
260f			;	pop de 
260f			;	pop hl 
260f			;;	FORTH_RSP_POP	  
260f			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
260f			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
260f			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
260f			; 
260f			;	if DEBUG_FORTH_WORDS 
260f			;		DMARK "EX7" 
260f			;		CALLMONITOR 
260f			;	endif 
260f			;	NEXTW 
260f			 
260f			;.STKEXEC: 
260f			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
260f			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
260f			; 
260f			; 
260f			;		if DEBUG_FORTH_WORDS_KEY 
260f			;			DMARK "STX" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			; 
260f			;	FORTH_DSP_VALUEHL 
260f			; 
260f			;	ld (store_tmp1), hl    ; count 
260f			; 
260f			;	FORTH_DSP_POP 
260f			;.stkexec1: 
260f			;	ld hl, (store_tmp1)   ; count 
260f			;	ld a, 0 
260f			;	cp l 
260f			;	ret z 
260f			; 
260f			;	dec hl 
260f			;	ld (store_tmp1), hl    ; count 
260f			;	 
260f			;	FORTH_DSP_VALUEHL 
260f			;	push hl 
260f			;	 
260f			;		if DEBUG_FORTH_WORDS 
260f			;			DMARK "EXp" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			;	FORTH_DSP_POP 
260f			; 
260f			;	call strlenz 
260f			;	inc hl   ; include zero term to copy 
260f			;	inc hl   ; include zero term to copy 
260f			;	inc hl   ; include zero term to copy 
260f			;	ld b,0 
260f			;	ld c,l 
260f			;	pop hl 
260f			;	ld de, execscratch 
260f			;		if DEBUG_FORTH_WORDS 
260f			;			DMARK "EX3" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			;	ldir 
260f			; 
260f			; 
260f			;	ld hl, execscratch 
260f			; 
260f			;		if DEBUG_FORTH_WORDS 
260f			;			DMARK "EXP" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			; 
260f			;	call forthparse 
260f			;	ld hl, execscratch 
260f			;		if DEBUG_FORTH_WORDS 
260f			;			DMARK "EXx" 
260f			;			CALLMONITOR 
260f			;		endif 
260f			;	call forthexec 
260f			; 
260f			;	jp .stkexec1 
260f			; 
260f			;	ret 
260f			 
260f			 
260f			.DUP: 
260f				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
260f 17				db WORD_SYS_CORE+OPCODE_DUP             
2610 85 26			dw .ZDUP            
2612 04				db 3 + 1 
2613 .. 00			db "DUP",0              
2617				endm 
# End of macro CWHEAD
2617			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2617			 
2617					if DEBUG_FORTH_WORDS_KEY 
2617						DMARK "DUP" 
2617 f5				push af  
2618 3a 2c 26			ld a, (.dmark)  
261b 32 6e fe			ld (debug_mark),a  
261e 3a 2d 26			ld a, (.dmark+1)  
2621 32 6f fe			ld (debug_mark+1),a  
2624 3a 2e 26			ld a, (.dmark+2)  
2627 32 70 fe			ld (debug_mark+2),a  
262a 18 03			jr .pastdmark  
262c ..			.dmark: db "DUP"  
262f f1			.pastdmark: pop af  
2630			endm  
# End of macro DMARK
2630						CALLMONITOR 
2630 cd fb 19			call break_point_state  
2633				endm  
# End of macro CALLMONITOR
2633					endif 
2633			 
2633					FORTH_DSP 
2633 cd 88 22			call macro_forth_dsp 
2636				endm 
# End of macro FORTH_DSP
2636			 
2636 7e					ld a, (HL) 
2637 fe 01				cp DS_TYPE_STR 
2639 20 25				jr nz, .dupinum 
263b			 
263b					; push another string 
263b			 
263b					FORTH_DSP_VALUEHL     		 
263b cd c2 22			call macro_dsp_valuehl 
263e				endm 
# End of macro FORTH_DSP_VALUEHL
263e			 
263e				if DEBUG_FORTH_WORDS 
263e					DMARK "DUs" 
263e f5				push af  
263f 3a 53 26			ld a, (.dmark)  
2642 32 6e fe			ld (debug_mark),a  
2645 3a 54 26			ld a, (.dmark+1)  
2648 32 6f fe			ld (debug_mark+1),a  
264b 3a 55 26			ld a, (.dmark+2)  
264e 32 70 fe			ld (debug_mark+2),a  
2651 18 03			jr .pastdmark  
2653 ..			.dmark: db "DUs"  
2656 f1			.pastdmark: pop af  
2657			endm  
# End of macro DMARK
2657					CALLMONITOR 
2657 cd fb 19			call break_point_state  
265a				endm  
# End of macro CALLMONITOR
265a				endif 
265a cd 39 21				call forth_push_str 
265d			 
265d					NEXTW 
265d c3 78 24			jp macro_next 
2660				endm 
# End of macro NEXTW
2660			 
2660			 
2660			.dupinum: 
2660					 
2660			 
2660			 
2660					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2660 cd c2 22			call macro_dsp_valuehl 
2663				endm 
# End of macro FORTH_DSP_VALUEHL
2663			 
2663				; TODO add floating point number detection 
2663			 
2663				if DEBUG_FORTH_WORDS 
2663					DMARK "DUi" 
2663 f5				push af  
2664 3a 78 26			ld a, (.dmark)  
2667 32 6e fe			ld (debug_mark),a  
266a 3a 79 26			ld a, (.dmark+1)  
266d 32 6f fe			ld (debug_mark+1),a  
2670 3a 7a 26			ld a, (.dmark+2)  
2673 32 70 fe			ld (debug_mark+2),a  
2676 18 03			jr .pastdmark  
2678 ..			.dmark: db "DUi"  
267b f1			.pastdmark: pop af  
267c			endm  
# End of macro DMARK
267c					CALLMONITOR 
267c cd fb 19			call break_point_state  
267f				endm  
# End of macro CALLMONITOR
267f				endif 
267f			 
267f cd cb 20				call forth_push_numhl 
2682					NEXTW 
2682 c3 78 24			jp macro_next 
2685				endm 
# End of macro NEXTW
2685			.ZDUP: 
2685				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2685 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2686 bd 26			dw .SWAP            
2688 05				db 4 + 1 
2689 .. 00			db "?DUP",0              
268e				endm 
# End of macro CWHEAD
268e			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
268e			 
268e					if DEBUG_FORTH_WORDS_KEY 
268e						DMARK "qDU" 
268e f5				push af  
268f 3a a3 26			ld a, (.dmark)  
2692 32 6e fe			ld (debug_mark),a  
2695 3a a4 26			ld a, (.dmark+1)  
2698 32 6f fe			ld (debug_mark+1),a  
269b 3a a5 26			ld a, (.dmark+2)  
269e 32 70 fe			ld (debug_mark+2),a  
26a1 18 03			jr .pastdmark  
26a3 ..			.dmark: db "qDU"  
26a6 f1			.pastdmark: pop af  
26a7			endm  
# End of macro DMARK
26a7						CALLMONITOR 
26a7 cd fb 19			call break_point_state  
26aa				endm  
# End of macro CALLMONITOR
26aa					endif 
26aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26aa cd c2 22			call macro_dsp_valuehl 
26ad				endm 
# End of macro FORTH_DSP_VALUEHL
26ad			 
26ad e5					push hl 
26ae			 
26ae					; is it a zero? 
26ae			 
26ae 3e 00				ld a, 0 
26b0 84					add h 
26b1 85					add l 
26b2			 
26b2 e1					pop hl 
26b3			 
26b3 fe 00				cp 0 
26b5 28 03				jr z, .dup2orig 
26b7			 
26b7			 
26b7 cd cb 20				call forth_push_numhl 
26ba			 
26ba			 
26ba				; TODO add floating point number detection 
26ba			 
26ba			.dup2orig: 
26ba			 
26ba					NEXTW 
26ba c3 78 24			jp macro_next 
26bd				endm 
# End of macro NEXTW
26bd			.SWAP: 
26bd				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
26bd 18				db WORD_SYS_CORE+OPCODE_SWAP             
26be fc 26			dw .COLN            
26c0 05				db 4 + 1 
26c1 .. 00			db "SWAP",0              
26c6				endm 
# End of macro CWHEAD
26c6			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
26c6					if DEBUG_FORTH_WORDS_KEY 
26c6						DMARK "SWP" 
26c6 f5				push af  
26c7 3a db 26			ld a, (.dmark)  
26ca 32 6e fe			ld (debug_mark),a  
26cd 3a dc 26			ld a, (.dmark+1)  
26d0 32 6f fe			ld (debug_mark+1),a  
26d3 3a dd 26			ld a, (.dmark+2)  
26d6 32 70 fe			ld (debug_mark+2),a  
26d9 18 03			jr .pastdmark  
26db ..			.dmark: db "SWP"  
26de f1			.pastdmark: pop af  
26df			endm  
# End of macro DMARK
26df						CALLMONITOR 
26df cd fb 19			call break_point_state  
26e2				endm  
# End of macro CALLMONITOR
26e2					endif 
26e2			 
26e2					FORTH_DSP_VALUEHL 
26e2 cd c2 22			call macro_dsp_valuehl 
26e5				endm 
# End of macro FORTH_DSP_VALUEHL
26e5 e5					push hl     ; w2 
26e6			 
26e6					FORTH_DSP_POP 
26e6 cd 7a 23			call macro_forth_dsp_pop 
26e9				endm 
# End of macro FORTH_DSP_POP
26e9			 
26e9					FORTH_DSP_VALUEHL 
26e9 cd c2 22			call macro_dsp_valuehl 
26ec				endm 
# End of macro FORTH_DSP_VALUEHL
26ec			 
26ec					FORTH_DSP_POP 
26ec cd 7a 23			call macro_forth_dsp_pop 
26ef				endm 
# End of macro FORTH_DSP_POP
26ef			 
26ef d1					pop de     ; w2	, hl = w1 
26f0			 
26f0 eb					ex de, hl 
26f1 d5					push de 
26f2			 
26f2 cd cb 20				call forth_push_numhl 
26f5			 
26f5 e1					pop hl 
26f6			 
26f6 cd cb 20				call forth_push_numhl 
26f9					 
26f9			 
26f9					NEXTW 
26f9 c3 78 24			jp macro_next 
26fc				endm 
# End of macro NEXTW
26fc			.COLN: 
26fc				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
26fc 19				db WORD_SYS_CORE+OPCODE_COLN             
26fd 88 28			dw .SCOLN            
26ff 02				db 1 + 1 
2700 .. 00			db ":",0              
2702				endm 
# End of macro CWHEAD
2702			; | : ( -- )         Create new word | DONE 
2702			 
2702					if DEBUG_FORTH_WORDS_KEY 
2702						DMARK "CLN" 
2702 f5				push af  
2703 3a 17 27			ld a, (.dmark)  
2706 32 6e fe			ld (debug_mark),a  
2709 3a 18 27			ld a, (.dmark+1)  
270c 32 6f fe			ld (debug_mark+1),a  
270f 3a 19 27			ld a, (.dmark+2)  
2712 32 70 fe			ld (debug_mark+2),a  
2715 18 03			jr .pastdmark  
2717 ..			.dmark: db "CLN"  
271a f1			.pastdmark: pop af  
271b			endm  
# End of macro DMARK
271b						CALLMONITOR 
271b cd fb 19			call break_point_state  
271e				endm  
# End of macro CALLMONITOR
271e					endif 
271e				STACKFRAME OFF $8efe $989f 
271e				if DEBUG_STACK_IMB 
271e					if OFF 
271e						exx 
271e						ld de, $8efe 
271e						ld a, d 
271e						ld hl, curframe 
271e						call hexout 
271e						ld a, e 
271e						ld hl, curframe+2 
271e						call hexout 
271e						ld hl, $8efe 
271e						push hl 
271e						ld hl, $989f 
271e						push hl 
271e						exx 
271e					endif 
271e				endif 
271e			endm 
# End of macro STACKFRAME
271e				; get parser buffer length  of new word 
271e			 
271e				 
271e			 
271e					; move tok past this to start of name defintition 
271e					; TODO get word to define 
271e					; TODO Move past word token 
271e					; TODO get length of string up to the ';' 
271e			 
271e 2a c5 f4			ld hl, (os_tok_ptr) 
2721 23				inc hl 
2722 23				inc hl 
2723			 
2723 3e 3b			ld a, ';' 
2725 cd ef 13			call strlent 
2728			 
2728 7d				ld a,l 
2729 32 c0 f1			ld (os_new_parse_len), a 
272c			 
272c			 
272c			if DEBUG_FORTH_UWORD 
272c ed 5b c5 f4		ld de, (os_tok_ptr) 
2730						DMARK ":01" 
2730 f5				push af  
2731 3a 45 27			ld a, (.dmark)  
2734 32 6e fe			ld (debug_mark),a  
2737 3a 46 27			ld a, (.dmark+1)  
273a 32 6f fe			ld (debug_mark+1),a  
273d 3a 47 27			ld a, (.dmark+2)  
2740 32 70 fe			ld (debug_mark+2),a  
2743 18 03			jr .pastdmark  
2745 ..			.dmark: db ":01"  
2748 f1			.pastdmark: pop af  
2749			endm  
# End of macro DMARK
2749				CALLMONITOR 
2749 cd fb 19			call break_point_state  
274c				endm  
# End of macro CALLMONITOR
274c			endif 
274c			 
274c			; 
274c			;  new word memory layout: 
274c			;  
274c			;    : adg 6666 ;  
274c			; 
274c			;    db   1     ; user defined word  
274c 23				inc hl    
274d			;    dw   sysdict 
274d 23				inc hl 
274e 23				inc hl 
274f			;    db <word len>+1 (for null) 
274f 23				inc hl 
2750			;    db .... <word> 
2750			; 
2750			 
2750 23				inc hl    ; some extras for the word preamble before the above 
2751 23				inc hl 
2752 23				inc hl 
2753 23				inc hl 
2754 23				inc hl 
2755 23				inc hl 
2756 23				inc hl  
2757 23				inc hl 
2758 23				inc hl 
2759 23				inc hl 
275a 23				inc hl 
275b 23				inc hl 
275c 23				inc hl 
275d 23				inc hl     ; TODO how many do we really need?     maybe only 6 
275e			;       exec word buffer 
275e			;	<ptr word>   
275e 23				inc hl 
275f 23				inc hl 
2760			;       <word list><null term> 7F final term 
2760			 
2760			 
2760			if DEBUG_FORTH_UWORD 
2760						DMARK ":02" 
2760 f5				push af  
2761 3a 75 27			ld a, (.dmark)  
2764 32 6e fe			ld (debug_mark),a  
2767 3a 76 27			ld a, (.dmark+1)  
276a 32 6f fe			ld (debug_mark+1),a  
276d 3a 77 27			ld a, (.dmark+2)  
2770 32 70 fe			ld (debug_mark+2),a  
2773 18 03			jr .pastdmark  
2775 ..			.dmark: db ":02"  
2778 f1			.pastdmark: pop af  
2779			endm  
# End of macro DMARK
2779				CALLMONITOR 
2779 cd fb 19			call break_point_state  
277c				endm  
# End of macro CALLMONITOR
277c			endif 
277c			 
277c				 
277c					; malloc the size 
277c			 
277c cd 4d 14				call malloc 
277f 22 c2 f1				ld (os_new_malloc), hl     ; save malloc start 
2782			 
2782			;    db   1     ; user defined word  
2782 3e 01				ld a, WORD_SYS_UWORD  
2784 77					ld (hl), a 
2785				 
2785 23				inc hl    
2786			;    dw   sysdict 
2786 11 d0 25			ld de, sysdict       ; continue on with the scan to the system dict 
2789 73				ld (hl), e 
278a 23				inc hl 
278b 72				ld (hl), d 
278c 23				inc hl 
278d			 
278d			 
278d			;    Setup dict word 
278d			 
278d 23				inc hl 
278e 22 bc f1			ld (os_new_work_ptr), hl     ; save start of dict word  
2791			 
2791				; 1. get length of dict word 
2791			 
2791			 
2791 2a c5 f4			ld hl, (os_tok_ptr) 
2794 23				inc hl 
2795 23				inc hl    ; position to start of dict word 
2796 3e 00			ld a, 0 
2798 cd ef 13			call strlent 
279b			 
279b			 
279b 23				inc hl    ; to include null??? 
279c			 
279c				; write length of dict word 
279c			 
279c ed 5b bc f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27a0 1b				dec de 
27a1 eb				ex de, hl 
27a2 73				ld (hl), e 
27a3 eb				ex de, hl 
27a4			 
27a4				 
27a4			 
27a4				; copy  
27a4 4d				ld c, l 
27a5 06 00			ld b, 0 
27a7 ed 5b bc f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27ab 2a c5 f4			ld hl, (os_tok_ptr) 
27ae 23				inc hl 
27af 23				inc hl    ; position to start of dict word 
27b0				 
27b0			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27b0				 
27b0				; TODO need to convert word to upper case 
27b0			 
27b0			ucasetok:	 
27b0 7e				ld a,(hl) 
27b1 cd db 13			call toUpper 
27b4 77				ld (hl),a 
27b5 ed a0			ldi 
27b7 f2 b0 27		 	jp p, ucasetok 
27ba			 
27ba			 
27ba			 
27ba				; de now points to start of where the word body code should be placed 
27ba ed 53 bc f1		ld (os_new_work_ptr), de 
27be				; hl now points to the words to throw at forthexec which needs to be copied 
27be 22 ba f1			ld (os_new_src_ptr), hl 
27c1			 
27c1				; TODO add 'call to forthexec' 
27c1			 
27c1			if DEBUG_FORTH_UWORD 
27c1 c5				push bc 
27c2 ed 4b c2 f1		ld bc, (os_new_malloc) 
27c6						DMARK ":0x" 
27c6 f5				push af  
27c7 3a db 27			ld a, (.dmark)  
27ca 32 6e fe			ld (debug_mark),a  
27cd 3a dc 27			ld a, (.dmark+1)  
27d0 32 6f fe			ld (debug_mark+1),a  
27d3 3a dd 27			ld a, (.dmark+2)  
27d6 32 70 fe			ld (debug_mark+2),a  
27d9 18 03			jr .pastdmark  
27db ..			.dmark: db ":0x"  
27de f1			.pastdmark: pop af  
27df			endm  
# End of macro DMARK
27df				CALLMONITOR 
27df cd fb 19			call break_point_state  
27e2				endm  
# End of macro CALLMONITOR
27e2 c1				pop bc 
27e3			endif 
27e3			 
27e3			 
27e3				; create word preamble which should be: 
27e3			 
27e3			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
27e3			 
27e3				;    ld hl, <word code> 
27e3				;    jp user_exec 
27e3			        ;    <word code bytes> 
27e3			 
27e3			 
27e3			;	inc de     ; TODO ??? or are we already past the word's null 
27e3 eb				ex de, hl 
27e4			 
27e4 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
27e6			 
27e6 23				inc hl 
27e7 22 b6 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
27ea 23				inc hl 
27eb			 
27eb 23				inc hl 
27ec 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
27ee			 
27ee 01 c4 5c			ld bc, user_exec 
27f1 23				inc hl 
27f2 71				ld (hl), c     ; poke address of user_exec 
27f3 23				inc hl 
27f4 70				ld (hl), b     
27f5			 ; 
27f5			;	inc hl 
27f5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27f5			; 
27f5			; 
27f5			;	ld bc, macro_forth_rsp_next 
27f5			;	inc hl 
27f5			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
27f5			;	inc hl 
27f5			;	ld (hl), b     
27f5			 ; 
27f5			;	inc hl 
27f5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27f5			; 
27f5			; 
27f5			;	inc hl 
27f5			;	ld bc, forthexec 
27f5			;	ld (hl), c     ; poke address of forthexec 
27f5			;	inc hl 
27f5			;	ld (hl), b      
27f5			; 
27f5			;	inc hl 
27f5			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
27f5			; 
27f5			;	ld bc, user_dict_next 
27f5			;	inc hl 
27f5			;	ld (hl), c     ; poke address of forthexec 
27f5			;	inc hl 
27f5			;	ld (hl), b      
27f5			 
27f5				; hl is now where we need to copy the word byte data to save this 
27f5			 
27f5 23				inc hl 
27f6 22 b8 f1			ld (os_new_exec), hl 
27f9				 
27f9				; copy definition 
27f9			 
27f9 eb				ex de, hl 
27fa			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
27fa			;	inc de    ; skip the PC for this parse 
27fa 3a c0 f1			ld a, (os_new_parse_len) 
27fd 4f				ld c, a 
27fe 06 00			ld b, 0 
2800 ed b0			ldir		 ; copy defintion 
2802			 
2802			 
2802				; poke the address of where the new word bytes live for forthexec 
2802			 
2802 2a b6 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2805			 
2805 ed 5b b8 f1		ld de, (os_new_exec)      
2809				 
2809 73				ld (hl), e 
280a 23				inc hl 
280b 72				ld (hl), d 
280c			 
280c					; TODO copy last user dict word next link to this word 
280c					; TODO update last user dict word to point to this word 
280c			; 
280c			; hl f923 de 812a ; bc 811a 
280c			 
280c			if DEBUG_FORTH_UWORD 
280c c5				push bc 
280d ed 4b c2 f1		ld bc, (os_new_malloc) 
2811						DMARK ":0A" 
2811 f5				push af  
2812 3a 26 28			ld a, (.dmark)  
2815 32 6e fe			ld (debug_mark),a  
2818 3a 27 28			ld a, (.dmark+1)  
281b 32 6f fe			ld (debug_mark+1),a  
281e 3a 28 28			ld a, (.dmark+2)  
2821 32 70 fe			ld (debug_mark+2),a  
2824 18 03			jr .pastdmark  
2826 ..			.dmark: db ":0A"  
2829 f1			.pastdmark: pop af  
282a			endm  
# End of macro DMARK
282a				CALLMONITOR 
282a cd fb 19			call break_point_state  
282d				endm  
# End of macro CALLMONITOR
282d c1				pop bc 
282e			endif 
282e			if DEBUG_FORTH_UWORD 
282e c5				push bc 
282f ed 4b c2 f1		ld bc, (os_new_malloc) 
2833 03				inc bc 
2834 03				inc bc 
2835 03				inc bc 
2836 03				inc bc 
2837 03				inc bc 
2838 03				inc bc 
2839 03				inc bc 
283a 03				inc bc 
283b			 
283b						DMARK ":0B" 
283b f5				push af  
283c 3a 50 28			ld a, (.dmark)  
283f 32 6e fe			ld (debug_mark),a  
2842 3a 51 28			ld a, (.dmark+1)  
2845 32 6f fe			ld (debug_mark+1),a  
2848 3a 52 28			ld a, (.dmark+2)  
284b 32 70 fe			ld (debug_mark+2),a  
284e 18 03			jr .pastdmark  
2850 ..			.dmark: db ":0B"  
2853 f1			.pastdmark: pop af  
2854			endm  
# End of macro DMARK
2854				CALLMONITOR 
2854 cd fb 19			call break_point_state  
2857				endm  
# End of macro CALLMONITOR
2857 c1				pop bc 
2858			endif 
2858			 
2858			; update word dict linked list for new word 
2858			 
2858			 
2858 2a c1 f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
285b 23			inc hl     ; move to next work linked list ptr 
285c			 
285c ed 5b c2 f1	ld de, (os_new_malloc)		 ; new next word 
2860 73			ld (hl), e 
2861 23			inc hl 
2862 72			ld (hl), d 
2863			 
2863			if DEBUG_FORTH_UWORD 
2863 ed 4b c1 f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2867			endif 
2867			 
2867 ed 53 c1 f4	ld (os_last_new_uword), de      ; update last new uword ptr 
286b			 
286b			 
286b			if DEBUG_FORTH_UWORD 
286b						DMARK ":0+" 
286b f5				push af  
286c 3a 80 28			ld a, (.dmark)  
286f 32 6e fe			ld (debug_mark),a  
2872 3a 81 28			ld a, (.dmark+1)  
2875 32 6f fe			ld (debug_mark+1),a  
2878 3a 82 28			ld a, (.dmark+2)  
287b 32 70 fe			ld (debug_mark+2),a  
287e 18 03			jr .pastdmark  
2880 ..			.dmark: db ":0+"  
2883 f1			.pastdmark: pop af  
2884			endm  
# End of macro DMARK
2884				CALLMONITOR 
2884 cd fb 19			call break_point_state  
2887				endm  
# End of macro CALLMONITOR
2887			endif 
2887			 
2887				STACKFRAMECHK OFF $8efe $989f 
2887				if DEBUG_STACK_IMB 
2887					if OFF 
2887						exx 
2887						ld hl, $989f 
2887						pop de   ; $989f 
2887						call cmp16 
2887						jr nz, .spnosame 
2887						ld hl, $8efe 
2887						pop de   ; $8efe 
2887						call cmp16 
2887						jr z, .spfrsame 
2887						.spnosame: call showsperror 
2887						.spfrsame: nop 
2887						exx 
2887					endif 
2887				endif 
2887			endm 
# End of macro STACKFRAMECHK
2887			 
2887 c9			ret    ; dont process any remaining parser tokens as they form new word 
2888			 
2888			 
2888			 
2888			 
2888			;		NEXT 
2888			.SCOLN: 
2888			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2888 06				db OPCODE_SCOLN 
2889 d4 28			dw .DROP 
288b 02				db 2 
288c .. 00			db ";",0           
288e			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
288e					if DEBUG_FORTH_WORDS_KEY 
288e						DMARK "SCN" 
288e f5				push af  
288f 3a a3 28			ld a, (.dmark)  
2892 32 6e fe			ld (debug_mark),a  
2895 3a a4 28			ld a, (.dmark+1)  
2898 32 6f fe			ld (debug_mark+1),a  
289b 3a a5 28			ld a, (.dmark+2)  
289e 32 70 fe			ld (debug_mark+2),a  
28a1 18 03			jr .pastdmark  
28a3 ..			.dmark: db "SCN"  
28a6 f1			.pastdmark: pop af  
28a7			endm  
# End of macro DMARK
28a7						CALLMONITOR 
28a7 cd fb 19			call break_point_state  
28aa				endm  
# End of macro CALLMONITOR
28aa					endif 
28aa					FORTH_RSP_TOS 
28aa cd 89 20			call macro_forth_rsp_tos 
28ad				endm 
# End of macro FORTH_RSP_TOS
28ad e5					push hl 
28ae					FORTH_RSP_POP 
28ae cd 93 20			call macro_forth_rsp_pop 
28b1				endm 
# End of macro FORTH_RSP_POP
28b1 e1					pop hl 
28b2			;		ex de,hl 
28b2 22 c5 f4				ld (os_tok_ptr),hl 
28b5			 
28b5			if DEBUG_FORTH_UWORD 
28b5						DMARK "SCL" 
28b5 f5				push af  
28b6 3a ca 28			ld a, (.dmark)  
28b9 32 6e fe			ld (debug_mark),a  
28bc 3a cb 28			ld a, (.dmark+1)  
28bf 32 6f fe			ld (debug_mark+1),a  
28c2 3a cc 28			ld a, (.dmark+2)  
28c5 32 70 fe			ld (debug_mark+2),a  
28c8 18 03			jr .pastdmark  
28ca ..			.dmark: db "SCL"  
28cd f1			.pastdmark: pop af  
28ce			endm  
# End of macro DMARK
28ce				CALLMONITOR 
28ce cd fb 19			call break_point_state  
28d1				endm  
# End of macro CALLMONITOR
28d1			endif 
28d1					NEXTW 
28d1 c3 78 24			jp macro_next 
28d4				endm 
# End of macro NEXTW
28d4			 
28d4			.DROP: 
28d4				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
28d4 1b				db WORD_SYS_CORE+OPCODE_DROP             
28d5 ff 28			dw .DUP2            
28d7 05				db 4 + 1 
28d8 .. 00			db "DROP",0              
28dd				endm 
# End of macro CWHEAD
28dd			; | DROP ( w -- )   drop the TOS item   | DONE 
28dd					if DEBUG_FORTH_WORDS_KEY 
28dd						DMARK "DRP" 
28dd f5				push af  
28de 3a f2 28			ld a, (.dmark)  
28e1 32 6e fe			ld (debug_mark),a  
28e4 3a f3 28			ld a, (.dmark+1)  
28e7 32 6f fe			ld (debug_mark+1),a  
28ea 3a f4 28			ld a, (.dmark+2)  
28ed 32 70 fe			ld (debug_mark+2),a  
28f0 18 03			jr .pastdmark  
28f2 ..			.dmark: db "DRP"  
28f5 f1			.pastdmark: pop af  
28f6			endm  
# End of macro DMARK
28f6						CALLMONITOR 
28f6 cd fb 19			call break_point_state  
28f9				endm  
# End of macro CALLMONITOR
28f9					endif 
28f9					FORTH_DSP_POP 
28f9 cd 7a 23			call macro_forth_dsp_pop 
28fc				endm 
# End of macro FORTH_DSP_POP
28fc					NEXTW 
28fc c3 78 24			jp macro_next 
28ff				endm 
# End of macro NEXTW
28ff			.DUP2: 
28ff				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
28ff 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2900 44 29			dw .DROP2            
2902 05				db 4 + 1 
2903 .. 00			db "2DUP",0              
2908				endm 
# End of macro CWHEAD
2908			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2908					if DEBUG_FORTH_WORDS_KEY 
2908						DMARK "2DU" 
2908 f5				push af  
2909 3a 1d 29			ld a, (.dmark)  
290c 32 6e fe			ld (debug_mark),a  
290f 3a 1e 29			ld a, (.dmark+1)  
2912 32 6f fe			ld (debug_mark+1),a  
2915 3a 1f 29			ld a, (.dmark+2)  
2918 32 70 fe			ld (debug_mark+2),a  
291b 18 03			jr .pastdmark  
291d ..			.dmark: db "2DU"  
2920 f1			.pastdmark: pop af  
2921			endm  
# End of macro DMARK
2921						CALLMONITOR 
2921 cd fb 19			call break_point_state  
2924				endm  
# End of macro CALLMONITOR
2924					endif 
2924					FORTH_DSP_VALUEHL 
2924 cd c2 22			call macro_dsp_valuehl 
2927				endm 
# End of macro FORTH_DSP_VALUEHL
2927 e5					push hl      ; 2 
2928			 
2928					FORTH_DSP_POP 
2928 cd 7a 23			call macro_forth_dsp_pop 
292b				endm 
# End of macro FORTH_DSP_POP
292b					 
292b					FORTH_DSP_VALUEHL 
292b cd c2 22			call macro_dsp_valuehl 
292e				endm 
# End of macro FORTH_DSP_VALUEHL
292e			;		push hl      ; 1 
292e			 
292e					FORTH_DSP_POP 
292e cd 7a 23			call macro_forth_dsp_pop 
2931				endm 
# End of macro FORTH_DSP_POP
2931			 
2931			;		pop hl       ; 1 
2931 d1					pop de       ; 2 
2932			 
2932 cd cb 20				call forth_push_numhl 
2935 eb					ex de, hl 
2936 cd cb 20				call forth_push_numhl 
2939			 
2939					 
2939 eb					ex de, hl 
293a			 
293a cd cb 20				call forth_push_numhl 
293d eb					ex de, hl 
293e cd cb 20				call forth_push_numhl 
2941			 
2941			 
2941					NEXTW 
2941 c3 78 24			jp macro_next 
2944				endm 
# End of macro NEXTW
2944			.DROP2: 
2944				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2944 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2945 73 29			dw .SWAP2            
2947 06				db 5 + 1 
2948 .. 00			db "2DROP",0              
294e				endm 
# End of macro CWHEAD
294e			; | 2DROP ( w w -- )    Double drop | DONE 
294e					if DEBUG_FORTH_WORDS_KEY 
294e						DMARK "2DR" 
294e f5				push af  
294f 3a 63 29			ld a, (.dmark)  
2952 32 6e fe			ld (debug_mark),a  
2955 3a 64 29			ld a, (.dmark+1)  
2958 32 6f fe			ld (debug_mark+1),a  
295b 3a 65 29			ld a, (.dmark+2)  
295e 32 70 fe			ld (debug_mark+2),a  
2961 18 03			jr .pastdmark  
2963 ..			.dmark: db "2DR"  
2966 f1			.pastdmark: pop af  
2967			endm  
# End of macro DMARK
2967						CALLMONITOR 
2967 cd fb 19			call break_point_state  
296a				endm  
# End of macro CALLMONITOR
296a					endif 
296a					FORTH_DSP_POP 
296a cd 7a 23			call macro_forth_dsp_pop 
296d				endm 
# End of macro FORTH_DSP_POP
296d					FORTH_DSP_POP 
296d cd 7a 23			call macro_forth_dsp_pop 
2970				endm 
# End of macro FORTH_DSP_POP
2970					NEXTW 
2970 c3 78 24			jp macro_next 
2973				endm 
# End of macro NEXTW
2973			.SWAP2: 
2973				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2973 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2974 9c 29			dw .AT            
2976 06				db 5 + 1 
2977 .. 00			db "2SWAP",0              
297d				endm 
# End of macro CWHEAD
297d			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
297d					if DEBUG_FORTH_WORDS_KEY 
297d						DMARK "2SW" 
297d f5				push af  
297e 3a 92 29			ld a, (.dmark)  
2981 32 6e fe			ld (debug_mark),a  
2984 3a 93 29			ld a, (.dmark+1)  
2987 32 6f fe			ld (debug_mark+1),a  
298a 3a 94 29			ld a, (.dmark+2)  
298d 32 70 fe			ld (debug_mark+2),a  
2990 18 03			jr .pastdmark  
2992 ..			.dmark: db "2SW"  
2995 f1			.pastdmark: pop af  
2996			endm  
# End of macro DMARK
2996						CALLMONITOR 
2996 cd fb 19			call break_point_state  
2999				endm  
# End of macro CALLMONITOR
2999					endif 
2999					NEXTW 
2999 c3 78 24			jp macro_next 
299c				endm 
# End of macro NEXTW
299c			.AT: 
299c				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
299c 1f				db WORD_SYS_CORE+OPCODE_AT             
299d ce 29			dw .CAT            
299f 02				db 1 + 1 
29a0 .. 00			db "@",0              
29a2				endm 
# End of macro CWHEAD
29a2			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
29a2			 
29a2					if DEBUG_FORTH_WORDS_KEY 
29a2						DMARK "AT." 
29a2 f5				push af  
29a3 3a b7 29			ld a, (.dmark)  
29a6 32 6e fe			ld (debug_mark),a  
29a9 3a b8 29			ld a, (.dmark+1)  
29ac 32 6f fe			ld (debug_mark+1),a  
29af 3a b9 29			ld a, (.dmark+2)  
29b2 32 70 fe			ld (debug_mark+2),a  
29b5 18 03			jr .pastdmark  
29b7 ..			.dmark: db "AT."  
29ba f1			.pastdmark: pop af  
29bb			endm  
# End of macro DMARK
29bb						CALLMONITOR 
29bb cd fb 19			call break_point_state  
29be				endm  
# End of macro CALLMONITOR
29be					endif 
29be			.getbyteat:	 
29be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29be cd c2 22			call macro_dsp_valuehl 
29c1				endm 
# End of macro FORTH_DSP_VALUEHL
29c1					 
29c1			;		push hl 
29c1				 
29c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29c1 cd 7a 23			call macro_forth_dsp_pop 
29c4				endm 
# End of macro FORTH_DSP_POP
29c4			 
29c4			;		pop hl 
29c4			 
29c4 7e					ld a, (hl) 
29c5			 
29c5 6f					ld l, a 
29c6 26 00				ld h, 0 
29c8 cd cb 20				call forth_push_numhl 
29cb			 
29cb					NEXTW 
29cb c3 78 24			jp macro_next 
29ce				endm 
# End of macro NEXTW
29ce			.CAT: 
29ce				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
29ce 20				db WORD_SYS_CORE+OPCODE_CAT             
29cf f7 29			dw .BANG            
29d1 03				db 2 + 1 
29d2 .. 00			db "C@",0              
29d5				endm 
# End of macro CWHEAD
29d5			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
29d5					if DEBUG_FORTH_WORDS_KEY 
29d5						DMARK "CAA" 
29d5 f5				push af  
29d6 3a ea 29			ld a, (.dmark)  
29d9 32 6e fe			ld (debug_mark),a  
29dc 3a eb 29			ld a, (.dmark+1)  
29df 32 6f fe			ld (debug_mark+1),a  
29e2 3a ec 29			ld a, (.dmark+2)  
29e5 32 70 fe			ld (debug_mark+2),a  
29e8 18 03			jr .pastdmark  
29ea ..			.dmark: db "CAA"  
29ed f1			.pastdmark: pop af  
29ee			endm  
# End of macro DMARK
29ee						CALLMONITOR 
29ee cd fb 19			call break_point_state  
29f1				endm  
# End of macro CALLMONITOR
29f1					endif 
29f1 c3 be 29				jp .getbyteat 
29f4					NEXTW 
29f4 c3 78 24			jp macro_next 
29f7				endm 
# End of macro NEXTW
29f7			.BANG: 
29f7				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
29f7 21				db WORD_SYS_CORE+OPCODE_BANG             
29f8 2d 2a			dw .CBANG            
29fa 02				db 1 + 1 
29fb .. 00			db "!",0              
29fd				endm 
# End of macro CWHEAD
29fd			; | ! ( x w -- ) Store x at address w      | DONE 
29fd					if DEBUG_FORTH_WORDS_KEY 
29fd						DMARK "BNG" 
29fd f5				push af  
29fe 3a 12 2a			ld a, (.dmark)  
2a01 32 6e fe			ld (debug_mark),a  
2a04 3a 13 2a			ld a, (.dmark+1)  
2a07 32 6f fe			ld (debug_mark+1),a  
2a0a 3a 14 2a			ld a, (.dmark+2)  
2a0d 32 70 fe			ld (debug_mark+2),a  
2a10 18 03			jr .pastdmark  
2a12 ..			.dmark: db "BNG"  
2a15 f1			.pastdmark: pop af  
2a16			endm  
# End of macro DMARK
2a16						CALLMONITOR 
2a16 cd fb 19			call break_point_state  
2a19				endm  
# End of macro CALLMONITOR
2a19					endif 
2a19			 
2a19			.storebyteat:		 
2a19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a19 cd c2 22			call macro_dsp_valuehl 
2a1c				endm 
# End of macro FORTH_DSP_VALUEHL
2a1c					 
2a1c e5					push hl 
2a1d				 
2a1d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a1d cd 7a 23			call macro_forth_dsp_pop 
2a20				endm 
# End of macro FORTH_DSP_POP
2a20			 
2a20					; get byte to poke 
2a20			 
2a20					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a20 cd c2 22			call macro_dsp_valuehl 
2a23				endm 
# End of macro FORTH_DSP_VALUEHL
2a23 e5					push hl 
2a24			 
2a24			 
2a24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a24 cd 7a 23			call macro_forth_dsp_pop 
2a27				endm 
# End of macro FORTH_DSP_POP
2a27			 
2a27			 
2a27 d1					pop de 
2a28 e1					pop hl 
2a29			 
2a29 73					ld (hl),e 
2a2a			 
2a2a			 
2a2a					NEXTW 
2a2a c3 78 24			jp macro_next 
2a2d				endm 
# End of macro NEXTW
2a2d			.CBANG: 
2a2d				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2a2d 22				db WORD_SYS_CORE+OPCODE_CBANG             
2a2e 56 2a			dw .SCALL            
2a30 03				db 2 + 1 
2a31 .. 00			db "C!",0              
2a34				endm 
# End of macro CWHEAD
2a34			; | C!  ( x w -- ) Store x at address w  | DONE 
2a34					if DEBUG_FORTH_WORDS_KEY 
2a34						DMARK "CBA" 
2a34 f5				push af  
2a35 3a 49 2a			ld a, (.dmark)  
2a38 32 6e fe			ld (debug_mark),a  
2a3b 3a 4a 2a			ld a, (.dmark+1)  
2a3e 32 6f fe			ld (debug_mark+1),a  
2a41 3a 4b 2a			ld a, (.dmark+2)  
2a44 32 70 fe			ld (debug_mark+2),a  
2a47 18 03			jr .pastdmark  
2a49 ..			.dmark: db "CBA"  
2a4c f1			.pastdmark: pop af  
2a4d			endm  
# End of macro DMARK
2a4d						CALLMONITOR 
2a4d cd fb 19			call break_point_state  
2a50				endm  
# End of macro CALLMONITOR
2a50					endif 
2a50 c3 19 2a				jp .storebyteat 
2a53					NEXTW 
2a53 c3 78 24			jp macro_next 
2a56				endm 
# End of macro NEXTW
2a56			.SCALL: 
2a56				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2a56 23				db WORD_SYS_CORE+OPCODE_SCALL             
2a57 8a 2a			dw .DEPTH            
2a59 05				db 4 + 1 
2a5a .. 00			db "CALL",0              
2a5f				endm 
# End of macro CWHEAD
2a5f			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2a5f					if DEBUG_FORTH_WORDS_KEY 
2a5f						DMARK "CLL" 
2a5f f5				push af  
2a60 3a 74 2a			ld a, (.dmark)  
2a63 32 6e fe			ld (debug_mark),a  
2a66 3a 75 2a			ld a, (.dmark+1)  
2a69 32 6f fe			ld (debug_mark+1),a  
2a6c 3a 76 2a			ld a, (.dmark+2)  
2a6f 32 70 fe			ld (debug_mark+2),a  
2a72 18 03			jr .pastdmark  
2a74 ..			.dmark: db "CLL"  
2a77 f1			.pastdmark: pop af  
2a78			endm  
# End of macro DMARK
2a78						CALLMONITOR 
2a78 cd fb 19			call break_point_state  
2a7b				endm  
# End of macro CALLMONITOR
2a7b					endif 
2a7b			 
2a7b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a7b cd c2 22			call macro_dsp_valuehl 
2a7e				endm 
# End of macro FORTH_DSP_VALUEHL
2a7e			 
2a7e			;		push hl 
2a7e			 
2a7e					; destroy value TOS 
2a7e			 
2a7e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a7e cd 7a 23			call macro_forth_dsp_pop 
2a81				endm 
# End of macro FORTH_DSP_POP
2a81			 
2a81						 
2a81			;		pop hl 
2a81			 
2a81					; how to do a call with hl???? save SP? 
2a81 cd 1c 24				call forth_call_hl 
2a84			 
2a84			 
2a84					; TODO push value back onto stack for another op etc 
2a84			 
2a84 cd cb 20				call forth_push_numhl 
2a87					NEXTW 
2a87 c3 78 24			jp macro_next 
2a8a				endm 
# End of macro NEXTW
2a8a			.DEPTH: 
2a8a				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2a8a 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2a8b c7 2a			dw .OVER            
2a8d 06				db 5 + 1 
2a8e .. 00			db "DEPTH",0              
2a94				endm 
# End of macro CWHEAD
2a94			; | DEPTH ( -- u ) Push count of stack | DONE 
2a94					; take current TOS and remove from base value div by two to get count 
2a94					if DEBUG_FORTH_WORDS_KEY 
2a94						DMARK "DEP" 
2a94 f5				push af  
2a95 3a a9 2a			ld a, (.dmark)  
2a98 32 6e fe			ld (debug_mark),a  
2a9b 3a aa 2a			ld a, (.dmark+1)  
2a9e 32 6f fe			ld (debug_mark+1),a  
2aa1 3a ab 2a			ld a, (.dmark+2)  
2aa4 32 70 fe			ld (debug_mark+2),a  
2aa7 18 03			jr .pastdmark  
2aa9 ..			.dmark: db "DEP"  
2aac f1			.pastdmark: pop af  
2aad			endm  
# End of macro DMARK
2aad						CALLMONITOR 
2aad cd fb 19			call break_point_state  
2ab0				endm  
# End of macro CALLMONITOR
2ab0					endif 
2ab0			 
2ab0			 
2ab0 2a f1 f9			ld hl, (cli_data_sp) 
2ab3 11 2b f7			ld de, cli_data_stack 
2ab6 ed 52			sbc hl,de 
2ab8				 
2ab8				; div by size of stack item 
2ab8			 
2ab8 5d				ld e,l 
2ab9 0e 03			ld c, 3 
2abb cd 16 0f			call Div8 
2abe			 
2abe 6f				ld l,a 
2abf 26 00			ld h,0 
2ac1			 
2ac1				;srl h 
2ac1				;rr l 
2ac1			 
2ac1 cd cb 20				call forth_push_numhl 
2ac4					NEXTW 
2ac4 c3 78 24			jp macro_next 
2ac7				endm 
# End of macro NEXTW
2ac7			.OVER: 
2ac7				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2ac7 42				db WORD_SYS_CORE+46             
2ac8 0e 2b			dw .PAUSE            
2aca 05				db 4 + 1 
2acb .. 00			db "OVER",0              
2ad0				endm 
# End of macro CWHEAD
2ad0			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2ad0					if DEBUG_FORTH_WORDS_KEY 
2ad0						DMARK "OVR" 
2ad0 f5				push af  
2ad1 3a e5 2a			ld a, (.dmark)  
2ad4 32 6e fe			ld (debug_mark),a  
2ad7 3a e6 2a			ld a, (.dmark+1)  
2ada 32 6f fe			ld (debug_mark+1),a  
2add 3a e7 2a			ld a, (.dmark+2)  
2ae0 32 70 fe			ld (debug_mark+2),a  
2ae3 18 03			jr .pastdmark  
2ae5 ..			.dmark: db "OVR"  
2ae8 f1			.pastdmark: pop af  
2ae9			endm  
# End of macro DMARK
2ae9						CALLMONITOR 
2ae9 cd fb 19			call break_point_state  
2aec				endm  
# End of macro CALLMONITOR
2aec					endif 
2aec			 
2aec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2aec cd c2 22			call macro_dsp_valuehl 
2aef				endm 
# End of macro FORTH_DSP_VALUEHL
2aef e5					push hl    ; n2 
2af0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2af0 cd 7a 23			call macro_forth_dsp_pop 
2af3				endm 
# End of macro FORTH_DSP_POP
2af3			 
2af3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2af3 cd c2 22			call macro_dsp_valuehl 
2af6				endm 
# End of macro FORTH_DSP_VALUEHL
2af6 e5					push hl    ; n1 
2af7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2af7 cd 7a 23			call macro_forth_dsp_pop 
2afa				endm 
# End of macro FORTH_DSP_POP
2afa			 
2afa d1					pop de     ; n1 
2afb e1					pop hl     ; n2 
2afc			 
2afc d5					push de 
2afd e5					push hl 
2afe d5					push de 
2aff			 
2aff					; push back  
2aff			 
2aff e1					pop hl 
2b00 cd cb 20				call forth_push_numhl 
2b03 e1					pop hl 
2b04 cd cb 20				call forth_push_numhl 
2b07 e1					pop hl 
2b08 cd cb 20				call forth_push_numhl 
2b0b					NEXTW 
2b0b c3 78 24			jp macro_next 
2b0e				endm 
# End of macro NEXTW
2b0e			 
2b0e			.PAUSE: 
2b0e				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2b0e 43				db WORD_SYS_CORE+47             
2b0f 43 2b			dw .PAUSES            
2b11 08				db 7 + 1 
2b12 .. 00			db "PAUSEMS",0              
2b1a				endm 
# End of macro CWHEAD
2b1a			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2b1a					if DEBUG_FORTH_WORDS_KEY 
2b1a						DMARK "PMS" 
2b1a f5				push af  
2b1b 3a 2f 2b			ld a, (.dmark)  
2b1e 32 6e fe			ld (debug_mark),a  
2b21 3a 30 2b			ld a, (.dmark+1)  
2b24 32 6f fe			ld (debug_mark+1),a  
2b27 3a 31 2b			ld a, (.dmark+2)  
2b2a 32 70 fe			ld (debug_mark+2),a  
2b2d 18 03			jr .pastdmark  
2b2f ..			.dmark: db "PMS"  
2b32 f1			.pastdmark: pop af  
2b33			endm  
# End of macro DMARK
2b33						CALLMONITOR 
2b33 cd fb 19			call break_point_state  
2b36				endm  
# End of macro CALLMONITOR
2b36					endif 
2b36					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b36 cd c2 22			call macro_dsp_valuehl 
2b39				endm 
# End of macro FORTH_DSP_VALUEHL
2b39			;		push hl    ; n2 
2b39					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b39 cd 7a 23			call macro_forth_dsp_pop 
2b3c				endm 
# End of macro FORTH_DSP_POP
2b3c			;		pop hl 
2b3c			 
2b3c 7d					ld a, l 
2b3d cd 7a 0c				call aDelayInMS 
2b40				       NEXTW 
2b40 c3 78 24			jp macro_next 
2b43				endm 
# End of macro NEXTW
2b43			.PAUSES:  
2b43				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b43 44				db WORD_SYS_CORE+48             
2b44 b2 2b			dw .ROT            
2b46 06				db 5 + 1 
2b47 .. 00			db "PAUSE",0              
2b4d				endm 
# End of macro CWHEAD
2b4d			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b4d					if DEBUG_FORTH_WORDS_KEY 
2b4d						DMARK "PAU" 
2b4d f5				push af  
2b4e 3a 62 2b			ld a, (.dmark)  
2b51 32 6e fe			ld (debug_mark),a  
2b54 3a 63 2b			ld a, (.dmark+1)  
2b57 32 6f fe			ld (debug_mark+1),a  
2b5a 3a 64 2b			ld a, (.dmark+2)  
2b5d 32 70 fe			ld (debug_mark+2),a  
2b60 18 03			jr .pastdmark  
2b62 ..			.dmark: db "PAU"  
2b65 f1			.pastdmark: pop af  
2b66			endm  
# End of macro DMARK
2b66						CALLMONITOR 
2b66 cd fb 19			call break_point_state  
2b69				endm  
# End of macro CALLMONITOR
2b69					endif 
2b69					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b69 cd c2 22			call macro_dsp_valuehl 
2b6c				endm 
# End of macro FORTH_DSP_VALUEHL
2b6c			;		push hl    ; n2 
2b6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b6c cd 7a 23			call macro_forth_dsp_pop 
2b6f				endm 
# End of macro FORTH_DSP_POP
2b6f			;		pop hl 
2b6f 45					ld b, l 
2b70					if DEBUG_FORTH_WORDS 
2b70						DMARK "PAU" 
2b70 f5				push af  
2b71 3a 85 2b			ld a, (.dmark)  
2b74 32 6e fe			ld (debug_mark),a  
2b77 3a 86 2b			ld a, (.dmark+1)  
2b7a 32 6f fe			ld (debug_mark+1),a  
2b7d 3a 87 2b			ld a, (.dmark+2)  
2b80 32 70 fe			ld (debug_mark+2),a  
2b83 18 03			jr .pastdmark  
2b85 ..			.dmark: db "PAU"  
2b88 f1			.pastdmark: pop af  
2b89			endm  
# End of macro DMARK
2b89						CALLMONITOR 
2b89 cd fb 19			call break_point_state  
2b8c				endm  
# End of macro CALLMONITOR
2b8c					endif 
2b8c c5			.pauses1:	push bc 
2b8d cd 95 0c				call delay1s 
2b90 c1					pop bc 
2b91					if DEBUG_FORTH_WORDS 
2b91						DMARK "PA1" 
2b91 f5				push af  
2b92 3a a6 2b			ld a, (.dmark)  
2b95 32 6e fe			ld (debug_mark),a  
2b98 3a a7 2b			ld a, (.dmark+1)  
2b9b 32 6f fe			ld (debug_mark+1),a  
2b9e 3a a8 2b			ld a, (.dmark+2)  
2ba1 32 70 fe			ld (debug_mark+2),a  
2ba4 18 03			jr .pastdmark  
2ba6 ..			.dmark: db "PA1"  
2ba9 f1			.pastdmark: pop af  
2baa			endm  
# End of macro DMARK
2baa						CALLMONITOR 
2baa cd fb 19			call break_point_state  
2bad				endm  
# End of macro CALLMONITOR
2bad					endif 
2bad 10 dd				djnz .pauses1 
2baf			 
2baf				       NEXTW 
2baf c3 78 24			jp macro_next 
2bb2				endm 
# End of macro NEXTW
2bb2			.ROT: 
2bb2				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2bb2 45				db WORD_SYS_CORE+49             
2bb3 00 2c			dw .UWORDS            
2bb5 04				db 3 + 1 
2bb6 .. 00			db "ROT",0              
2bba				endm 
# End of macro CWHEAD
2bba			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2bba					if DEBUG_FORTH_WORDS_KEY 
2bba						DMARK "ROT" 
2bba f5				push af  
2bbb 3a cf 2b			ld a, (.dmark)  
2bbe 32 6e fe			ld (debug_mark),a  
2bc1 3a d0 2b			ld a, (.dmark+1)  
2bc4 32 6f fe			ld (debug_mark+1),a  
2bc7 3a d1 2b			ld a, (.dmark+2)  
2bca 32 70 fe			ld (debug_mark+2),a  
2bcd 18 03			jr .pastdmark  
2bcf ..			.dmark: db "ROT"  
2bd2 f1			.pastdmark: pop af  
2bd3			endm  
# End of macro DMARK
2bd3						CALLMONITOR 
2bd3 cd fb 19			call break_point_state  
2bd6				endm  
# End of macro CALLMONITOR
2bd6					endif 
2bd6			 
2bd6					FORTH_DSP_VALUEHL 
2bd6 cd c2 22			call macro_dsp_valuehl 
2bd9				endm 
# End of macro FORTH_DSP_VALUEHL
2bd9 e5					push hl    ; u3  
2bda			 
2bda					FORTH_DSP_POP 
2bda cd 7a 23			call macro_forth_dsp_pop 
2bdd				endm 
# End of macro FORTH_DSP_POP
2bdd			   
2bdd					FORTH_DSP_VALUEHL 
2bdd cd c2 22			call macro_dsp_valuehl 
2be0				endm 
# End of macro FORTH_DSP_VALUEHL
2be0 e5					push hl     ; u2 
2be1			 
2be1					FORTH_DSP_POP 
2be1 cd 7a 23			call macro_forth_dsp_pop 
2be4				endm 
# End of macro FORTH_DSP_POP
2be4			 
2be4					FORTH_DSP_VALUEHL 
2be4 cd c2 22			call macro_dsp_valuehl 
2be7				endm 
# End of macro FORTH_DSP_VALUEHL
2be7 e5					push hl     ; u1 
2be8			 
2be8					FORTH_DSP_POP 
2be8 cd 7a 23			call macro_forth_dsp_pop 
2beb				endm 
# End of macro FORTH_DSP_POP
2beb			 
2beb c1					pop bc      ; u1 
2bec e1					pop hl      ; u2 
2bed d1					pop de      ; u3 
2bee			 
2bee			 
2bee c5					push bc 
2bef d5					push de 
2bf0 e5					push hl 
2bf1			 
2bf1			 
2bf1 e1					pop hl 
2bf2 cd cb 20				call forth_push_numhl 
2bf5			 
2bf5 e1					pop hl 
2bf6 cd cb 20				call forth_push_numhl 
2bf9			 
2bf9 e1					pop hl 
2bfa cd cb 20				call forth_push_numhl 
2bfd					 
2bfd			 
2bfd			 
2bfd			 
2bfd			 
2bfd			 
2bfd				       NEXTW 
2bfd c3 78 24			jp macro_next 
2c00				endm 
# End of macro NEXTW
2c00			 
2c00			.UWORDS: 
2c00				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2c00 50				db WORD_SYS_CORE+60             
2c01 c2 2c			dw .BP            
2c03 07				db 6 + 1 
2c04 .. 00			db "UWORDS",0              
2c0b				endm 
# End of macro CWHEAD
2c0b			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2c0b			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2c0b			; | | Following the count are the individual words. 
2c0b			; | | 
2c0b			; | | e.g. UWORDS 
2c0b			; | | BOX DIRLIST 2 
2c0b			; | |  
2c0b			; | | Can be used to save the words to storage via: 
2c0b			; | | UWORDS $01 DO $01 APPEND LOOP 
2c0b				if DEBUG_FORTH_WORDS_KEY 
2c0b					DMARK "UWR" 
2c0b f5				push af  
2c0c 3a 20 2c			ld a, (.dmark)  
2c0f 32 6e fe			ld (debug_mark),a  
2c12 3a 21 2c			ld a, (.dmark+1)  
2c15 32 6f fe			ld (debug_mark+1),a  
2c18 3a 22 2c			ld a, (.dmark+2)  
2c1b 32 70 fe			ld (debug_mark+2),a  
2c1e 18 03			jr .pastdmark  
2c20 ..			.dmark: db "UWR"  
2c23 f1			.pastdmark: pop af  
2c24			endm  
# End of macro DMARK
2c24					CALLMONITOR 
2c24 cd fb 19			call break_point_state  
2c27				endm  
# End of macro CALLMONITOR
2c27				endif 
2c27 21 00 80				ld hl, baseram 
2c2a					;ld hl, baseusermem 
2c2a 01 00 00				ld bc, 0    ; start a counter 
2c2d			 
2c2d				; skip dict stub 
2c2d			 
2c2d cd c9 25				call forth_tok_next 
2c30			 
2c30			 
2c30			; while we have words to look for 
2c30			 
2c30 7e			.douscan:	ld a, (hl)      
2c31				if DEBUG_FORTH_WORDS 
2c31					DMARK "UWs" 
2c31 f5				push af  
2c32 3a 46 2c			ld a, (.dmark)  
2c35 32 6e fe			ld (debug_mark),a  
2c38 3a 47 2c			ld a, (.dmark+1)  
2c3b 32 6f fe			ld (debug_mark+1),a  
2c3e 3a 48 2c			ld a, (.dmark+2)  
2c41 32 70 fe			ld (debug_mark+2),a  
2c44 18 03			jr .pastdmark  
2c46 ..			.dmark: db "UWs"  
2c49 f1			.pastdmark: pop af  
2c4a			endm  
# End of macro DMARK
2c4a					CALLMONITOR 
2c4a cd fb 19			call break_point_state  
2c4d				endm  
# End of macro CALLMONITOR
2c4d				endif 
2c4d fe 00				cp WORD_SYS_END 
2c4f 28 4d				jr z, .udone 
2c51 fe 01				cp WORD_SYS_UWORD 
2c53 20 44				jr nz, .nuword 
2c55			 
2c55				if DEBUG_FORTH_WORDS 
2c55					DMARK "UWu" 
2c55 f5				push af  
2c56 3a 6a 2c			ld a, (.dmark)  
2c59 32 6e fe			ld (debug_mark),a  
2c5c 3a 6b 2c			ld a, (.dmark+1)  
2c5f 32 6f fe			ld (debug_mark+1),a  
2c62 3a 6c 2c			ld a, (.dmark+2)  
2c65 32 70 fe			ld (debug_mark+2),a  
2c68 18 03			jr .pastdmark  
2c6a ..			.dmark: db "UWu"  
2c6d f1			.pastdmark: pop af  
2c6e			endm  
# End of macro DMARK
2c6e					CALLMONITOR 
2c6e cd fb 19			call break_point_state  
2c71				endm  
# End of macro CALLMONITOR
2c71				endif 
2c71					; we have a uword so push its name to the stack 
2c71			 
2c71 e5				   	push hl  ; save so we can move to next dict block 
2c72			 
2c72					; skip opcode 
2c72 23					inc hl  
2c73					; skip next ptr 
2c73 23					inc hl  
2c74 23					inc hl 
2c75					; skip len 
2c75 23					inc hl 
2c76				if DEBUG_FORTH_WORDS 
2c76					DMARK "UWt" 
2c76 f5				push af  
2c77 3a 8b 2c			ld a, (.dmark)  
2c7a 32 6e fe			ld (debug_mark),a  
2c7d 3a 8c 2c			ld a, (.dmark+1)  
2c80 32 6f fe			ld (debug_mark+1),a  
2c83 3a 8d 2c			ld a, (.dmark+2)  
2c86 32 70 fe			ld (debug_mark+2),a  
2c89 18 03			jr .pastdmark  
2c8b ..			.dmark: db "UWt"  
2c8e f1			.pastdmark: pop af  
2c8f			endm  
# End of macro DMARK
2c8f					CALLMONITOR 
2c8f cd fb 19			call break_point_state  
2c92				endm  
# End of macro CALLMONITOR
2c92				endif 
2c92 03					inc bc 
2c93			 
2c93 c5					push bc 
2c94 cd 39 21				call forth_push_str 
2c97 c1					pop bc 
2c98			 
2c98 e1					pop hl 	 
2c99			 
2c99 cd c9 25		.nuword:	call forth_tok_next 
2c9c 18 92				jr .douscan  
2c9e			 
2c9e			.udone:		 ; push count of uwords found 
2c9e c5					push bc 
2c9f e1					pop hl 
2ca0			 
2ca0				if DEBUG_FORTH_WORDS 
2ca0					DMARK "UWc" 
2ca0 f5				push af  
2ca1 3a b5 2c			ld a, (.dmark)  
2ca4 32 6e fe			ld (debug_mark),a  
2ca7 3a b6 2c			ld a, (.dmark+1)  
2caa 32 6f fe			ld (debug_mark+1),a  
2cad 3a b7 2c			ld a, (.dmark+2)  
2cb0 32 70 fe			ld (debug_mark+2),a  
2cb3 18 03			jr .pastdmark  
2cb5 ..			.dmark: db "UWc"  
2cb8 f1			.pastdmark: pop af  
2cb9			endm  
# End of macro DMARK
2cb9					CALLMONITOR 
2cb9 cd fb 19			call break_point_state  
2cbc				endm  
# End of macro CALLMONITOR
2cbc				endif 
2cbc cd cb 20				call forth_push_numhl 
2cbf			 
2cbf			 
2cbf				       NEXTW 
2cbf c3 78 24			jp macro_next 
2cc2				endm 
# End of macro NEXTW
2cc2			 
2cc2			.BP: 
2cc2				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2cc2 54				db WORD_SYS_CORE+64             
2cc3 f8 2c			dw .MONITOR            
2cc5 03				db 2 + 1 
2cc6 .. 00			db "BP",0              
2cc9				endm 
# End of macro CWHEAD
2cc9			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2cc9			; | | $00 Will enable the break points within specific code paths 
2cc9			; | | $01 Will disable break points 
2cc9			; | |  
2cc9			; | | By default break points are off. Either the above can be used to enable them 
2cc9			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2cc9			; | | and on release of the pressed key a message will be disaplayed to notify 
2cc9			; | | that break points are enabled. Pressing any key will then continue boot process. 
2cc9					; get byte count 
2cc9					if DEBUG_FORTH_WORDS_KEY 
2cc9						DMARK "BP." 
2cc9 f5				push af  
2cca 3a de 2c			ld a, (.dmark)  
2ccd 32 6e fe			ld (debug_mark),a  
2cd0 3a df 2c			ld a, (.dmark+1)  
2cd3 32 6f fe			ld (debug_mark+1),a  
2cd6 3a e0 2c			ld a, (.dmark+2)  
2cd9 32 70 fe			ld (debug_mark+2),a  
2cdc 18 03			jr .pastdmark  
2cde ..			.dmark: db "BP."  
2ce1 f1			.pastdmark: pop af  
2ce2			endm  
# End of macro DMARK
2ce2						CALLMONITOR 
2ce2 cd fb 19			call break_point_state  
2ce5				endm  
# End of macro CALLMONITOR
2ce5					endif 
2ce5			 
2ce5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ce5 cd c2 22			call macro_dsp_valuehl 
2ce8				endm 
# End of macro FORTH_DSP_VALUEHL
2ce8			 
2ce8			;		push hl 
2ce8			 
2ce8					; destroy value TOS 
2ce8			 
2ce8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ce8 cd 7a 23			call macro_forth_dsp_pop 
2ceb				endm 
# End of macro FORTH_DSP_POP
2ceb			 
2ceb			;		pop hl 
2ceb			 
2ceb 3e 00				ld a,0 
2ced bd					cp l 
2cee 28 02				jr z, .bpset 
2cf0 3e 2a				ld a, '*' 
2cf2			 
2cf2 32 b5 f1		.bpset:		ld (os_view_disable), a 
2cf5			 
2cf5			 
2cf5					NEXTW 
2cf5 c3 78 24			jp macro_next 
2cf8				endm 
# End of macro NEXTW
2cf8			 
2cf8			 
2cf8			.MONITOR: 
2cf8				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2cf8 55				db WORD_SYS_CORE+65             
2cf9 2b 2d			dw .MALLOC            
2cfb 08				db 7 + 1 
2cfc .. 00			db "MONITOR",0              
2d04				endm 
# End of macro CWHEAD
2d04			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2d04			; | | At start the current various registers will be displayed with contents. 
2d04			; | | Top right corner will show the most recent debug marker seen. 
2d04			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2d04			; | | and the return stack pointer (RSP). 
2d04			; | | Pressing: 
2d04			; | |    1 - Initial screen 
2d04			; | |    2 - Display a data dump of HL 
2d04			; | |    3 - Display a data dump of DE 
2d04			; | |    4 - Display a data dump of BC 
2d04			; | |    5 - Display a data dump of HL 
2d04			; | |    6 - Display a data dump of DSP 
2d04			; | |    7 - Display a data dump of RSP 
2d04			; | |    8 - Display a data dump of what is at DSP 
2d04			; | |    9 - Display a data dump of what is at RSP 
2d04			; | |    0 - Exit monitor and continue running. This will also enable break points 
2d04			; | |    * - Disable break points 
2d04			; | |    # - Enter traditional monitor mode 
2d04			; | | 
2d04			; | | Monitor Mode 
2d04			; | | ------------ 
2d04			; | | A prompt of '>' will be shown for various commands: 
2d04			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2d04			; | |    C - Continue display a data dump from the last set address 
2d04			; | |    M xxxx - Set start of memory edit at address xx 
2d04			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2d04			; | |    Q - Return to previous 
2d04					if DEBUG_FORTH_WORDS_KEY 
2d04						DMARK "MON" 
2d04 f5				push af  
2d05 3a 19 2d			ld a, (.dmark)  
2d08 32 6e fe			ld (debug_mark),a  
2d0b 3a 1a 2d			ld a, (.dmark+1)  
2d0e 32 6f fe			ld (debug_mark+1),a  
2d11 3a 1b 2d			ld a, (.dmark+2)  
2d14 32 70 fe			ld (debug_mark+2),a  
2d17 18 03			jr .pastdmark  
2d19 ..			.dmark: db "MON"  
2d1c f1			.pastdmark: pop af  
2d1d			endm  
# End of macro DMARK
2d1d						CALLMONITOR 
2d1d cd fb 19			call break_point_state  
2d20				endm  
# End of macro CALLMONITOR
2d20					endif 
2d20 3e 00				ld a, 0 
2d22 32 b5 f1				ld (os_view_disable), a 
2d25			 
2d25					CALLMONITOR 
2d25 cd fb 19			call break_point_state  
2d28				endm  
# End of macro CALLMONITOR
2d28			 
2d28			;	call monitor 
2d28			 
2d28					NEXTW 
2d28 c3 78 24			jp macro_next 
2d2b				endm 
# End of macro NEXTW
2d2b			 
2d2b			 
2d2b			.MALLOC: 
2d2b				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2d2b 56				db WORD_SYS_CORE+66             
2d2c 54 2d			dw .MALLOC2            
2d2e 06				db 5 + 1 
2d2f .. 00			db "ALLOT",0              
2d35				endm 
# End of macro CWHEAD
2d35			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d35					if DEBUG_FORTH_WORDS_KEY 
2d35						DMARK "ALL" 
2d35 f5				push af  
2d36 3a 4a 2d			ld a, (.dmark)  
2d39 32 6e fe			ld (debug_mark),a  
2d3c 3a 4b 2d			ld a, (.dmark+1)  
2d3f 32 6f fe			ld (debug_mark+1),a  
2d42 3a 4c 2d			ld a, (.dmark+2)  
2d45 32 70 fe			ld (debug_mark+2),a  
2d48 18 03			jr .pastdmark  
2d4a ..			.dmark: db "ALL"  
2d4d f1			.pastdmark: pop af  
2d4e			endm  
# End of macro DMARK
2d4e						CALLMONITOR 
2d4e cd fb 19			call break_point_state  
2d51				endm  
# End of macro CALLMONITOR
2d51					endif 
2d51 c3 7b 2d				jp .mallocc 
2d54			.MALLOC2: 
2d54				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2d54 56				db WORD_SYS_CORE+66             
2d55 92 2d			dw .FREE            
2d57 07				db 6 + 1 
2d58 .. 00			db "MALLOC",0              
2d5f				endm 
# End of macro CWHEAD
2d5f			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d5f					; get byte count 
2d5f					if DEBUG_FORTH_WORDS_KEY 
2d5f						DMARK "MAL" 
2d5f f5				push af  
2d60 3a 74 2d			ld a, (.dmark)  
2d63 32 6e fe			ld (debug_mark),a  
2d66 3a 75 2d			ld a, (.dmark+1)  
2d69 32 6f fe			ld (debug_mark+1),a  
2d6c 3a 76 2d			ld a, (.dmark+2)  
2d6f 32 70 fe			ld (debug_mark+2),a  
2d72 18 03			jr .pastdmark  
2d74 ..			.dmark: db "MAL"  
2d77 f1			.pastdmark: pop af  
2d78			endm  
# End of macro DMARK
2d78						CALLMONITOR 
2d78 cd fb 19			call break_point_state  
2d7b				endm  
# End of macro CALLMONITOR
2d7b					endif 
2d7b			.mallocc: 
2d7b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d7b cd c2 22			call macro_dsp_valuehl 
2d7e				endm 
# End of macro FORTH_DSP_VALUEHL
2d7e			 
2d7e			;		push hl 
2d7e			 
2d7e					; destroy value TOS 
2d7e			 
2d7e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d7e cd 7a 23			call macro_forth_dsp_pop 
2d81				endm 
# End of macro FORTH_DSP_POP
2d81			 
2d81			;		pop hl 
2d81 cd 4d 14				call malloc 
2d84				if DEBUG_FORTH_MALLOC_GUARD 
2d84 f5					push af 
2d85 cd af 0f				call ishlzero 
2d88			;		ld a, l 
2d88			;		add h 
2d88			;		cp 0 
2d88 f1					pop af 
2d89					 
2d89 cc 96 5d				call z,malloc_error 
2d8c				endif 
2d8c			 
2d8c cd cb 20				call forth_push_numhl 
2d8f					NEXTW 
2d8f c3 78 24			jp macro_next 
2d92				endm 
# End of macro NEXTW
2d92			 
2d92			.FREE: 
2d92				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2d92 57				db WORD_SYS_CORE+67             
2d93 c3 2d			dw .LIST            
2d95 05				db 4 + 1 
2d96 .. 00			db "FREE",0              
2d9b				endm 
# End of macro CWHEAD
2d9b			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2d9b					if DEBUG_FORTH_WORDS_KEY 
2d9b						DMARK "FRE" 
2d9b f5				push af  
2d9c 3a b0 2d			ld a, (.dmark)  
2d9f 32 6e fe			ld (debug_mark),a  
2da2 3a b1 2d			ld a, (.dmark+1)  
2da5 32 6f fe			ld (debug_mark+1),a  
2da8 3a b2 2d			ld a, (.dmark+2)  
2dab 32 70 fe			ld (debug_mark+2),a  
2dae 18 03			jr .pastdmark  
2db0 ..			.dmark: db "FRE"  
2db3 f1			.pastdmark: pop af  
2db4			endm  
# End of macro DMARK
2db4						CALLMONITOR 
2db4 cd fb 19			call break_point_state  
2db7				endm  
# End of macro CALLMONITOR
2db7					endif 
2db7					; get address 
2db7			 
2db7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2db7 cd c2 22			call macro_dsp_valuehl 
2dba				endm 
# End of macro FORTH_DSP_VALUEHL
2dba			 
2dba			;		push hl 
2dba			 
2dba					; destroy value TOS 
2dba			 
2dba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2dba cd 7a 23			call macro_forth_dsp_pop 
2dbd				endm 
# End of macro FORTH_DSP_POP
2dbd			 
2dbd			;		pop hl 
2dbd			if FORTH_ENABLE_MALLOCFREE 
2dbd cd 17 15				call free 
2dc0			endif 
2dc0					NEXTW 
2dc0 c3 78 24			jp macro_next 
2dc3				endm 
# End of macro NEXTW
2dc3			.LIST: 
2dc3				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2dc3 5c				db WORD_SYS_CORE+72             
2dc4 b1 2f			dw .FORGET            
2dc6 05				db 4 + 1 
2dc7 .. 00			db "LIST",0              
2dcc				endm 
# End of macro CWHEAD
2dcc			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2dcc			; | | The quoted word must be in upper case. 
2dcc				if DEBUG_FORTH_WORDS_KEY 
2dcc					DMARK "LST" 
2dcc f5				push af  
2dcd 3a e1 2d			ld a, (.dmark)  
2dd0 32 6e fe			ld (debug_mark),a  
2dd3 3a e2 2d			ld a, (.dmark+1)  
2dd6 32 6f fe			ld (debug_mark+1),a  
2dd9 3a e3 2d			ld a, (.dmark+2)  
2ddc 32 70 fe			ld (debug_mark+2),a  
2ddf 18 03			jr .pastdmark  
2de1 ..			.dmark: db "LST"  
2de4 f1			.pastdmark: pop af  
2de5			endm  
# End of macro DMARK
2de5					CALLMONITOR 
2de5 cd fb 19			call break_point_state  
2de8				endm  
# End of macro CALLMONITOR
2de8				endif 
2de8			 
2de8					FORTH_DSP_VALUEHL 
2de8 cd c2 22			call macro_dsp_valuehl 
2deb				endm 
# End of macro FORTH_DSP_VALUEHL
2deb			 
2deb e5					push hl 
2dec					FORTH_DSP_POP 
2dec cd 7a 23			call macro_forth_dsp_pop 
2def				endm 
# End of macro FORTH_DSP_POP
2def c1					pop bc 
2df0			 
2df0			; Start format of scratch string 
2df0			 
2df0 21 c4 f1				ld hl, scratch 
2df3			 
2df3 3e 3a				ld a, ':' 
2df5 77					ld (hl),a 
2df6 23					inc hl 
2df7 3e 20				ld a, ' ' 
2df9 77					ld (hl), a 
2dfa			 
2dfa					; Get ptr to the word we need to look up 
2dfa			 
2dfa			;		FORTH_DSP_VALUEHL 
2dfa					;v5 FORTH_DSP_VALUE 
2dfa				; TODO type check 
2dfa			;		inc hl    ; Skip type check  
2dfa			;		push hl 
2dfa			;		ex de, hl    ; put into DE 
2dfa			 
2dfa			 
2dfa 21 00 80				ld hl, baseram 
2dfd					;ld hl, baseusermem 
2dfd			 
2dfd e5			push hl   ; sacreifical push 
2dfe			 
2dfe			.ldouscanm: 
2dfe e1				pop hl 
2dff			.ldouscan: 
2dff				if DEBUG_FORTH_WORDS 
2dff					DMARK "LSs" 
2dff f5				push af  
2e00 3a 14 2e			ld a, (.dmark)  
2e03 32 6e fe			ld (debug_mark),a  
2e06 3a 15 2e			ld a, (.dmark+1)  
2e09 32 6f fe			ld (debug_mark+1),a  
2e0c 3a 16 2e			ld a, (.dmark+2)  
2e0f 32 70 fe			ld (debug_mark+2),a  
2e12 18 03			jr .pastdmark  
2e14 ..			.dmark: db "LSs"  
2e17 f1			.pastdmark: pop af  
2e18			endm  
# End of macro DMARK
2e18					CALLMONITOR 
2e18 cd fb 19			call break_point_state  
2e1b				endm  
# End of macro CALLMONITOR
2e1b				endif 
2e1b				; skip dict stub 
2e1b cd c9 25				call forth_tok_next 
2e1e			 
2e1e			 
2e1e			; while we have words to look for 
2e1e			 
2e1e 7e				ld a, (hl)      
2e1f				if DEBUG_FORTH_WORDS 
2e1f					DMARK "LSk" 
2e1f f5				push af  
2e20 3a 34 2e			ld a, (.dmark)  
2e23 32 6e fe			ld (debug_mark),a  
2e26 3a 35 2e			ld a, (.dmark+1)  
2e29 32 6f fe			ld (debug_mark+1),a  
2e2c 3a 36 2e			ld a, (.dmark+2)  
2e2f 32 70 fe			ld (debug_mark+2),a  
2e32 18 03			jr .pastdmark  
2e34 ..			.dmark: db "LSk"  
2e37 f1			.pastdmark: pop af  
2e38			endm  
# End of macro DMARK
2e38					CALLMONITOR 
2e38 cd fb 19			call break_point_state  
2e3b				endm  
# End of macro CALLMONITOR
2e3b				endif 
2e3b					;cp WORD_SYS_END 
2e3b					;jp z, .lunotfound 
2e3b			 
2e3b					; if we hit non uwords then gone too far 
2e3b fe 01				cp WORD_SYS_UWORD 
2e3d c2 6d 2f				jp nz, .lunotfound 
2e40			 
2e40				if DEBUG_FORTH_WORDS 
2e40					DMARK "LSu" 
2e40 f5				push af  
2e41 3a 55 2e			ld a, (.dmark)  
2e44 32 6e fe			ld (debug_mark),a  
2e47 3a 56 2e			ld a, (.dmark+1)  
2e4a 32 6f fe			ld (debug_mark+1),a  
2e4d 3a 57 2e			ld a, (.dmark+2)  
2e50 32 70 fe			ld (debug_mark+2),a  
2e53 18 03			jr .pastdmark  
2e55 ..			.dmark: db "LSu"  
2e58 f1			.pastdmark: pop af  
2e59			endm  
# End of macro DMARK
2e59					CALLMONITOR 
2e59 cd fb 19			call break_point_state  
2e5c				endm  
# End of macro CALLMONITOR
2e5c				endif 
2e5c			 
2e5c					; found a uword but is it the one we want... 
2e5c			 
2e5c c5					push bc     ; uword to find is on bc 
2e5d d1					pop de 
2e5e			 
2e5e e5					push hl  ; to save the ptr 
2e5f			 
2e5f					; skip opcode 
2e5f 23					inc hl  
2e60					; skip next ptr 
2e60 23					inc hl  
2e61 23					inc hl 
2e62					; skip len 
2e62 23					inc hl 
2e63			 
2e63				if DEBUG_FORTH_WORDS 
2e63					DMARK "LSc" 
2e63 f5				push af  
2e64 3a 78 2e			ld a, (.dmark)  
2e67 32 6e fe			ld (debug_mark),a  
2e6a 3a 79 2e			ld a, (.dmark+1)  
2e6d 32 6f fe			ld (debug_mark+1),a  
2e70 3a 7a 2e			ld a, (.dmark+2)  
2e73 32 70 fe			ld (debug_mark+2),a  
2e76 18 03			jr .pastdmark  
2e78 ..			.dmark: db "LSc"  
2e7b f1			.pastdmark: pop af  
2e7c			endm  
# End of macro DMARK
2e7c					CALLMONITOR 
2e7c cd fb 19			call break_point_state  
2e7f				endm  
# End of macro CALLMONITOR
2e7f				endif 
2e7f cd 1c 14				call strcmp 
2e82 c2 fe 2d				jp nz, .ldouscanm 
2e85				 
2e85			 
2e85			 
2e85					; we have a uword so push its name to the stack 
2e85			 
2e85			;	   	push hl  ; save so we can move to next dict block 
2e85 e1			pop hl 
2e86			 
2e86				if DEBUG_FORTH_WORDS 
2e86					DMARK "LSm" 
2e86 f5				push af  
2e87 3a 9b 2e			ld a, (.dmark)  
2e8a 32 6e fe			ld (debug_mark),a  
2e8d 3a 9c 2e			ld a, (.dmark+1)  
2e90 32 6f fe			ld (debug_mark+1),a  
2e93 3a 9d 2e			ld a, (.dmark+2)  
2e96 32 70 fe			ld (debug_mark+2),a  
2e99 18 03			jr .pastdmark  
2e9b ..			.dmark: db "LSm"  
2e9e f1			.pastdmark: pop af  
2e9f			endm  
# End of macro DMARK
2e9f					CALLMONITOR 
2e9f cd fb 19			call break_point_state  
2ea2				endm  
# End of macro CALLMONITOR
2ea2				endif 
2ea2			 
2ea2					; skip opcode 
2ea2 23					inc hl  
2ea3					; skip next ptr 
2ea3 23					inc hl  
2ea4 23					inc hl 
2ea5					; skip len 
2ea5 7e					ld a, (hl)   ; save length to add 
2ea6				if DEBUG_FORTH_WORDS 
2ea6					DMARK "LS2" 
2ea6 f5				push af  
2ea7 3a bb 2e			ld a, (.dmark)  
2eaa 32 6e fe			ld (debug_mark),a  
2ead 3a bc 2e			ld a, (.dmark+1)  
2eb0 32 6f fe			ld (debug_mark+1),a  
2eb3 3a bd 2e			ld a, (.dmark+2)  
2eb6 32 70 fe			ld (debug_mark+2),a  
2eb9 18 03			jr .pastdmark  
2ebb ..			.dmark: db "LS2"  
2ebe f1			.pastdmark: pop af  
2ebf			endm  
# End of macro DMARK
2ebf					CALLMONITOR 
2ebf cd fb 19			call break_point_state  
2ec2				endm  
# End of macro CALLMONITOR
2ec2				endif 
2ec2			 
2ec2					; save this location 
2ec2				 
2ec2 e5					push hl 
2ec3			 
2ec3 23					inc hl 
2ec4 11 c6 f1				ld de, scratch+2 
2ec7 4f					ld c, a 
2ec8 06 00				ld b, 0 
2eca			 
2eca				if DEBUG_FORTH_WORDS 
2eca					DMARK "LSn" 
2eca f5				push af  
2ecb 3a df 2e			ld a, (.dmark)  
2ece 32 6e fe			ld (debug_mark),a  
2ed1 3a e0 2e			ld a, (.dmark+1)  
2ed4 32 6f fe			ld (debug_mark+1),a  
2ed7 3a e1 2e			ld a, (.dmark+2)  
2eda 32 70 fe			ld (debug_mark+2),a  
2edd 18 03			jr .pastdmark  
2edf ..			.dmark: db "LSn"  
2ee2 f1			.pastdmark: pop af  
2ee3			endm  
# End of macro DMARK
2ee3					CALLMONITOR 
2ee3 cd fb 19			call break_point_state  
2ee6				endm  
# End of macro CALLMONITOR
2ee6				endif 
2ee6			 
2ee6					; copy uword name to scratch 
2ee6			 
2ee6 ed b0				ldir 
2ee8			 
2ee8 1b					dec de 
2ee9 3e 20				ld a, ' '    ; change null to space 
2eeb 12					ld (de), a 
2eec			 
2eec 13					inc de 
2eed			 
2eed d5					push de 
2eee c1					pop bc     ; move scratch pointer to end of word name and save it 
2eef			 
2eef e1					pop hl 
2ef0 7e					ld a, (hl) 
2ef1					;inc hl 
2ef1					; skip word string 
2ef1 cd 86 0f				call addatohl 
2ef4			 
2ef4 23					inc hl 
2ef5			 
2ef5				if DEBUG_FORTH_WORDS 
2ef5					DMARK "LS3" 
2ef5 f5				push af  
2ef6 3a 0a 2f			ld a, (.dmark)  
2ef9 32 6e fe			ld (debug_mark),a  
2efc 3a 0b 2f			ld a, (.dmark+1)  
2eff 32 6f fe			ld (debug_mark+1),a  
2f02 3a 0c 2f			ld a, (.dmark+2)  
2f05 32 70 fe			ld (debug_mark+2),a  
2f08 18 03			jr .pastdmark  
2f0a ..			.dmark: db "LS3"  
2f0d f1			.pastdmark: pop af  
2f0e			endm  
# End of macro DMARK
2f0e					CALLMONITOR 
2f0e cd fb 19			call break_point_state  
2f11				endm  
# End of macro CALLMONITOR
2f11				endif 
2f11					; should now be at the start of the machine code to setup the eval of the uword 
2f11					; now locate the ptr to the string defintion 
2f11			 
2f11					; skip ld hl, 
2f11					; then load the ptr 
2f11			; TODO use get from hl ptr 
2f11 23					inc hl 
2f12 5e					ld e, (hl) 
2f13 23					inc hl 
2f14 56					ld d, (hl) 
2f15 eb					ex de, hl 
2f16			 
2f16			 
2f16				if DEBUG_FORTH_WORDS 
2f16					DMARK "LSt" 
2f16 f5				push af  
2f17 3a 2b 2f			ld a, (.dmark)  
2f1a 32 6e fe			ld (debug_mark),a  
2f1d 3a 2c 2f			ld a, (.dmark+1)  
2f20 32 6f fe			ld (debug_mark+1),a  
2f23 3a 2d 2f			ld a, (.dmark+2)  
2f26 32 70 fe			ld (debug_mark+2),a  
2f29 18 03			jr .pastdmark  
2f2b ..			.dmark: db "LSt"  
2f2e f1			.pastdmark: pop af  
2f2f			endm  
# End of macro DMARK
2f2f					CALLMONITOR 
2f2f cd fb 19			call break_point_state  
2f32				endm  
# End of macro CALLMONITOR
2f32				endif 
2f32			 
2f32			; cant push right now due to tokenised strings  
2f32			 
2f32			; get the destination of where to copy this definition to. 
2f32			 
2f32 c5					push bc 
2f33 d1					pop de 
2f34			 
2f34 7e			.listl:         ld a,(hl) 
2f35 fe 00				cp 0 
2f37 28 09				jr z, .lreplsp     ; replace zero with space 
2f39					;cp FORTH_END_BUFFER 
2f39 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2f3b 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2f3d				 
2f3d					; just copy this char as is then 
2f3d			 
2f3d 12					ld (de), a 
2f3e			 
2f3e 23			.listnxt:	inc hl 
2f3f 13					inc de 
2f40 18 f2				jr .listl 
2f42			 
2f42 3e 20		.lreplsp:	ld a,' ' 
2f44 12					ld (de), a 
2f45 18 f7				jr .listnxt 
2f47			 
2f47			; close up uword def 
2f47			 
2f47			.listdone: 
2f47 12					ld (de), a 
2f48 13					inc de 
2f49 3e 00				ld a, 0 
2f4b 12					ld (de), a 
2f4c			 
2f4c			; now have def so clean up and push to stack 
2f4c			 
2f4c 21 c4 f1				ld hl, scratch 
2f4f				if DEBUG_FORTH_WORDS 
2f4f					DMARK "Ltp" 
2f4f f5				push af  
2f50 3a 64 2f			ld a, (.dmark)  
2f53 32 6e fe			ld (debug_mark),a  
2f56 3a 65 2f			ld a, (.dmark+1)  
2f59 32 6f fe			ld (debug_mark+1),a  
2f5c 3a 66 2f			ld a, (.dmark+2)  
2f5f 32 70 fe			ld (debug_mark+2),a  
2f62 18 03			jr .pastdmark  
2f64 ..			.dmark: db "Ltp"  
2f67 f1			.pastdmark: pop af  
2f68			endm  
# End of macro DMARK
2f68					CALLMONITOR 
2f68 cd fb 19			call break_point_state  
2f6b				endm  
# End of macro CALLMONITOR
2f6b				endif 
2f6b			 
2f6b 18 1f			jr .listpush 
2f6d			 
2f6d			;.lnuword:	pop hl 
2f6d			;		call forth_tok_next 
2f6d			;		jp .ldouscan  
2f6d			 
2f6d			.lunotfound:		  
2f6d			 
2f6d				if DEBUG_FORTH_WORDS 
2f6d					DMARK "LSn" 
2f6d f5				push af  
2f6e 3a 82 2f			ld a, (.dmark)  
2f71 32 6e fe			ld (debug_mark),a  
2f74 3a 83 2f			ld a, (.dmark+1)  
2f77 32 6f fe			ld (debug_mark+1),a  
2f7a 3a 84 2f			ld a, (.dmark+2)  
2f7d 32 70 fe			ld (debug_mark+2),a  
2f80 18 03			jr .pastdmark  
2f82 ..			.dmark: db "LSn"  
2f85 f1			.pastdmark: pop af  
2f86			endm  
# End of macro DMARK
2f86					CALLMONITOR 
2f86 cd fb 19			call break_point_state  
2f89				endm  
# End of macro CALLMONITOR
2f89				endif 
2f89			 
2f89					 
2f89			;		FORTH_DSP_POP 
2f89			;		ld hl, .luno 
2f89			 
2f89					NEXTW			 
2f89 c3 78 24			jp macro_next 
2f8c				endm 
# End of macro NEXTW
2f8c			 
2f8c			.listpush: 
2f8c				if DEBUG_FORTH_WORDS 
2f8c					DMARK "LS>" 
2f8c f5				push af  
2f8d 3a a1 2f			ld a, (.dmark)  
2f90 32 6e fe			ld (debug_mark),a  
2f93 3a a2 2f			ld a, (.dmark+1)  
2f96 32 6f fe			ld (debug_mark+1),a  
2f99 3a a3 2f			ld a, (.dmark+2)  
2f9c 32 70 fe			ld (debug_mark+2),a  
2f9f 18 03			jr .pastdmark  
2fa1 ..			.dmark: db "LS>"  
2fa4 f1			.pastdmark: pop af  
2fa5			endm  
# End of macro DMARK
2fa5					CALLMONITOR 
2fa5 cd fb 19			call break_point_state  
2fa8				endm  
# End of macro CALLMONITOR
2fa8				endif 
2fa8 cd 39 21				call forth_push_str 
2fab			 
2fab			 
2fab			 
2fab					NEXTW 
2fab c3 78 24			jp macro_next 
2fae				endm 
# End of macro NEXTW
2fae			 
2fae			;.luno:    db "Word not found",0 
2fae			 
2fae			 
2fae			 
2fae			 
2fae			 
2fae			;		push hl   ; save pointer to start of uword def string 
2fae			; 
2fae			;; look for FORTH_EOL_LINE 
2fae			;		ld a, FORTH_END_BUFFER 
2fae			;		call strlent 
2fae			; 
2fae			;		inc hl		 ; space for coln def 
2fae			;		inc hl 
2fae			;		inc hl          ; space for terms 
2fae			;		inc hl 
2fae			; 
2fae			;		ld a, 20   ; TODO get actual length 
2fae			;		call addatohl    ; include a random amount of room for the uword name 
2fae			; 
2fae			;		 
2fae			;	if DEBUG_FORTH_WORDS 
2fae			;		DMARK "Lt1" 
2fae			;		CALLMONITOR 
2fae			;	endif 
2fae			;		 
2fae			; 
2fae			;; malloc space for the string because we cant change it 
2fae			; 
2fae			;		call malloc 
2fae			;	if DEBUG_FORTH_MALLOC_GUARD 
2fae			;		push af 
2fae			;		call ishlzero 
2fae			;		pop af 
2fae			;		 
2fae			;		call z,malloc_error 
2fae			;	endif 
2fae			; 
2fae			;	if DEBUG_FORTH_WORDS 
2fae			;		DMARK "Lt2" 
2fae			;		CALLMONITOR 
2fae			;	endif 
2fae			;		pop de 
2fae			;		push hl    ; push the malloc to release later 
2fae			;		push hl   ;  push back a copy for the later stack push 
2fae			;		 
2fae			;; copy the string swapping out the zero terms for spaces 
2fae			; 
2fae			;		; de has our source 
2fae			;		; hl has our dest 
2fae			; 
2fae			;; add the coln def 
2fae			; 
2fae			;		ld a, ':' 
2fae			;		ld (hl), a 
2fae			;		inc hl 
2fae			;		ld a, ' ' 
2fae			;		ld (hl), a 
2fae			;		inc hl 
2fae			; 
2fae			;; add the uname word 
2fae			;		push de   ; save our string for now 
2fae			;		ex de, hl 
2fae			; 
2fae			;		FORTH_DSP_VALUE 
2fae			;		;v5 FORTH_DSP_VALUE 
2fae			; 
2fae			;		inc hl   ; skip type but we know by now this is OK 
2fae			; 
2fae			;.luword:	ld a,(hl) 
2fae			;		cp 0 
2fae			;		jr z, .luword2 
2fae			;		ld (de), a 
2fae			;		inc de 
2fae			;		inc hl 
2fae			;		jr .luword 
2fae			; 
2fae			;.luword2:	ld a, ' ' 
2fae			;		ld (de), a 
2fae			;;		inc hl 
2fae			;;		inc de 
2fae			;;		ld (de), a 
2fae			;;		inc hl 
2fae			;		inc de 
2fae			; 
2fae			;		ex de, hl 
2fae			;		pop de 
2fae			;		 
2fae			;		 
2fae			; 
2fae			;; detoken that string and copy it 
2fae			; 
2fae			;	if DEBUG_FORTH_WORDS 
2fae			;		DMARK "Lt2" 
2fae			;		CALLMONITOR 
2fae			;	endif 
2fae			;.ldetok:	ld a, (de) 
2fae			;		cp FORTH_END_BUFFER 
2fae			;		jr z, .ldetokend 
2fae			;		; swap out any zero term for space 
2fae			;		cp 0 
2fae			;		jr nz, .ldetoknext 
2fae			;		ld a, ' ' 
2fae			; 
2fae			;	if DEBUG_FORTH_WORDS 
2fae			;		DMARK "LtS" 
2fae			;		CALLMONITOR 
2fae			;	endif 
2fae			;.ldetoknext:	ld (hl), a 
2fae			;		inc de 
2fae			;		inc hl 
2fae			;		jr .ldetok 
2fae			; 
2fae			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2fae			;		ld (hl), a  
2fae			; 
2fae			;; free that temp malloc 
2fae			; 
2fae			;		pop hl    
2fae			; 
2fae			;	if DEBUG_FORTH_WORDS 
2fae			;		DMARK "Lt4" 
2fae			;		CALLMONITOR 
2fae			;	endif 
2fae			;		call forth_apushstrhl 
2fae			; 
2fae			;		; get rid of temp malloc area 
2fae			; 
2fae			;		pop hl 
2fae			;		call free 
2fae			; 
2fae			;		jr .ludone 
2fae			; 
2fae			;.lnuword:	pop hl 
2fae			;		call forth_tok_next 
2fae			;		jp .ldouscan  
2fae			; 
2fae			;.ludone:		 pop hl 
2fae			; 
2fae					NEXTW 
2fae c3 78 24			jp macro_next 
2fb1				endm 
# End of macro NEXTW
2fb1			 
2fb1			.FORGET: 
2fb1				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2fb1 5d				db WORD_SYS_CORE+73             
2fb2 2a 30			dw .NOP            
2fb4 07				db 6 + 1 
2fb5 .. 00			db "FORGET",0              
2fbc				endm 
# End of macro CWHEAD
2fbc			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2fbc			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2fbc			; | |  
2fbc			; | | e.g. "MORE" forget 
2fbc					if DEBUG_FORTH_WORDS_KEY 
2fbc						DMARK "FRG" 
2fbc f5				push af  
2fbd 3a d1 2f			ld a, (.dmark)  
2fc0 32 6e fe			ld (debug_mark),a  
2fc3 3a d2 2f			ld a, (.dmark+1)  
2fc6 32 6f fe			ld (debug_mark+1),a  
2fc9 3a d3 2f			ld a, (.dmark+2)  
2fcc 32 70 fe			ld (debug_mark+2),a  
2fcf 18 03			jr .pastdmark  
2fd1 ..			.dmark: db "FRG"  
2fd4 f1			.pastdmark: pop af  
2fd5			endm  
# End of macro DMARK
2fd5						CALLMONITOR 
2fd5 cd fb 19			call break_point_state  
2fd8				endm  
# End of macro CALLMONITOR
2fd8					endif 
2fd8			 
2fd8				; find uword 
2fd8			        ; update start of word with "_" 
2fd8				; replace uword with deleted flag 
2fd8			 
2fd8			 
2fd8			;	if DEBUG_FORTH_WORDS 
2fd8			;		DMARK "FOG" 
2fd8			;		CALLMONITOR 
2fd8			;	endif 
2fd8			 
2fd8			 
2fd8					; Get ptr to the word we need to look up 
2fd8			 
2fd8					FORTH_DSP_VALUEHL 
2fd8 cd c2 22			call macro_dsp_valuehl 
2fdb				endm 
# End of macro FORTH_DSP_VALUEHL
2fdb					;v5 FORTH_DSP_VALUE 
2fdb				; TODO type check 
2fdb			;		inc hl    ; Skip type check  
2fdb e5					push hl 
2fdc c1					pop bc 
2fdd			;		ex de, hl    ; put into DE 
2fdd			 
2fdd			 
2fdd 21 00 80				ld hl, baseram 
2fe0					;ld hl, baseusermem 
2fe0			 
2fe0				; skip dict stub 
2fe0			;	call forth_tok_next 
2fe0 e5			push hl   ; sacreifical push 
2fe1			 
2fe1			.fldouscanm: 
2fe1 e1				pop hl 
2fe2			.fldouscan: 
2fe2			;	if DEBUG_FORTH_WORDS 
2fe2			;		DMARK "LSs" 
2fe2			;		CALLMONITOR 
2fe2			;	endif 
2fe2				; skip dict stub 
2fe2 cd c9 25				call forth_tok_next 
2fe5			 
2fe5			 
2fe5			; while we have words to look for 
2fe5			 
2fe5 7e				ld a, (hl)      
2fe6			;	if DEBUG_FORTH_WORDS 
2fe6			;		DMARK "LSk" 
2fe6			;		CALLMONITOR 
2fe6			;	endif 
2fe6 fe 00				cp WORD_SYS_END 
2fe8 ca 24 30				jp z, .flunotfound 
2feb fe 01				cp WORD_SYS_UWORD 
2fed c2 e2 2f				jp nz, .fldouscan 
2ff0			 
2ff0			;	if DEBUG_FORTH_WORDS 
2ff0			;		DMARK "LSu" 
2ff0			;		CALLMONITOR 
2ff0			;	endif 
2ff0			 
2ff0					; found a uword but is it the one we want... 
2ff0			 
2ff0 c5					push bc     ; uword to find is on bc 
2ff1 d1					pop de 
2ff2			 
2ff2 e5					push hl  ; to save the ptr 
2ff3			 
2ff3					; skip opcode 
2ff3 23					inc hl  
2ff4					; skip next ptr 
2ff4 23					inc hl  
2ff5 23					inc hl 
2ff6					; skip len 
2ff6 23					inc hl 
2ff7			 
2ff7			;	if DEBUG_FORTH_WORDS 
2ff7			;		DMARK "LSc" 
2ff7			;		CALLMONITOR 
2ff7			;	endif 
2ff7 cd 1c 14				call strcmp 
2ffa c2 e1 2f				jp nz, .fldouscanm 
2ffd			; 
2ffd			; 
2ffd			;; while we have words to look for 
2ffd			; 
2ffd			;.fdouscan:	ld a, (hl)      
2ffd			;	if DEBUG_FORTH_WORDS 
2ffd			;		DMARK "LSs" 
2ffd			;		CALLMONITOR 
2ffd			;	endif 
2ffd			;		cp WORD_SYS_END 
2ffd			;		jp z, .fudone 
2ffd			;		cp WORD_SYS_UWORD 
2ffd			;		jp nz, .fnuword 
2ffd			; 
2ffd			;	if DEBUG_FORTH_WORDS 
2ffd			;		DMARK "FGu" 
2ffd			;		CALLMONITOR 
2ffd			;	endif 
2ffd			; 
2ffd			;		; found a uword but is it the one we want... 
2ffd			; 
2ffd			; 
2ffd			;	        pop de   ; get back the dsp name 
2ffd			;		push de 
2ffd			; 
2ffd			;		push hl  ; to save the ptr 
2ffd			; 
2ffd			;		; skip opcode 
2ffd			;		inc hl  
2ffd			;		; skip next ptr 
2ffd			;		inc hl  
2ffd			;		inc hl 
2ffd			;		; skip len 
2ffd			;		inc hl 
2ffd			; 
2ffd			;	if DEBUG_FORTH_WORDS 
2ffd			;		DMARK "FGc" 
2ffd			;		CALLMONITOR 
2ffd			;	endif 
2ffd			;		call strcmp 
2ffd			;		jp nz, .fnuword 
2ffd			 
2ffd			 
2ffd e1			pop hl 
2ffe			 
2ffe				 
2ffe				if DEBUG_FORTH_WORDS 
2ffe					DMARK "FGm" 
2ffe f5				push af  
2fff 3a 13 30			ld a, (.dmark)  
3002 32 6e fe			ld (debug_mark),a  
3005 3a 14 30			ld a, (.dmark+1)  
3008 32 6f fe			ld (debug_mark+1),a  
300b 3a 15 30			ld a, (.dmark+2)  
300e 32 70 fe			ld (debug_mark+2),a  
3011 18 03			jr .pastdmark  
3013 ..			.dmark: db "FGm"  
3016 f1			.pastdmark: pop af  
3017			endm  
# End of macro DMARK
3017					CALLMONITOR 
3017 cd fb 19			call break_point_state  
301a				endm  
# End of macro CALLMONITOR
301a				endif 
301a			 
301a			 
301a			 
301a					; we have a uword so push its name to the stack 
301a			 
301a			;	   	push hl  ; save so we can move to next dict block 
301a			;pop hl 
301a			 
301a					; update opcode to deleted 
301a 3e 03				ld a, WORD_SYS_DELETED 
301c 77					ld (hl), a 
301d			 
301d 23					inc hl  
301e					; skip next ptr 
301e 23					inc hl  
301f 23					inc hl 
3020					; skip len 
3020 23					inc hl 
3021			 
3021					; TODO change parser to skip deleted words but for now mark it out 
3021 3e 5f				ld a, "_" 
3023 77					ld  (hl),a 
3024			 
3024			;		jr .fudone 
3024			; 
3024			;.fnuword:	pop hl 
3024			;		call forth_tok_next 
3024			;		jp .fdouscan  
3024			 
3024			.flunotfound:		  
3024			 
3024			 
3024					 
3024					FORTH_DSP_POP 
3024 cd 7a 23			call macro_forth_dsp_pop 
3027				endm 
# End of macro FORTH_DSP_POP
3027			;		ld hl, .luno 
3027			;.fudone:		 pop hl 
3027					NEXTW 
3027 c3 78 24			jp macro_next 
302a				endm 
# End of macro NEXTW
302a			.NOP: 
302a				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
302a 61				db WORD_SYS_CORE+77             
302b 51 30			dw .COMO            
302d 04				db 3 + 1 
302e .. 00			db "NOP",0              
3032				endm 
# End of macro CWHEAD
3032			; | NOP (  --  ) Do nothing | DONE 
3032					if DEBUG_FORTH_WORDS_KEY 
3032						DMARK "NOP" 
3032 f5				push af  
3033 3a 47 30			ld a, (.dmark)  
3036 32 6e fe			ld (debug_mark),a  
3039 3a 48 30			ld a, (.dmark+1)  
303c 32 6f fe			ld (debug_mark+1),a  
303f 3a 49 30			ld a, (.dmark+2)  
3042 32 70 fe			ld (debug_mark+2),a  
3045 18 03			jr .pastdmark  
3047 ..			.dmark: db "NOP"  
304a f1			.pastdmark: pop af  
304b			endm  
# End of macro DMARK
304b						CALLMONITOR 
304b cd fb 19			call break_point_state  
304e				endm  
# End of macro CALLMONITOR
304e					endif 
304e				       NEXTW 
304e c3 78 24			jp macro_next 
3051				endm 
# End of macro NEXTW
3051			.COMO: 
3051				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
3051 6e				db WORD_SYS_CORE+90             
3052 a3 30			dw .COMC            
3054 02				db 1 + 1 
3055 .. 00			db "(",0              
3057				endm 
# End of macro CWHEAD
3057			; | ( ( -- )  Start of comment | DONE 
3057			 
3057			 
3057 2a c5 f4				ld hl, ( os_tok_ptr) 
305a 11 9e 30			ld de, .closepar 
305d					 
305d					if DEBUG_FORTH_WORDS 
305d						DMARK ").." 
305d f5				push af  
305e 3a 72 30			ld a, (.dmark)  
3061 32 6e fe			ld (debug_mark),a  
3064 3a 73 30			ld a, (.dmark+1)  
3067 32 6f fe			ld (debug_mark+1),a  
306a 3a 74 30			ld a, (.dmark+2)  
306d 32 70 fe			ld (debug_mark+2),a  
3070 18 03			jr .pastdmark  
3072 ..			.dmark: db ").."  
3075 f1			.pastdmark: pop af  
3076			endm  
# End of macro DMARK
3076						CALLMONITOR 
3076 cd fb 19			call break_point_state  
3079				endm  
# End of macro CALLMONITOR
3079					endif 
3079 cd 93 25			call findnexttok  
307c			 
307c					if DEBUG_FORTH_WORDS 
307c						DMARK "IF5" 
307c f5				push af  
307d 3a 91 30			ld a, (.dmark)  
3080 32 6e fe			ld (debug_mark),a  
3083 3a 92 30			ld a, (.dmark+1)  
3086 32 6f fe			ld (debug_mark+1),a  
3089 3a 93 30			ld a, (.dmark+2)  
308c 32 70 fe			ld (debug_mark+2),a  
308f 18 03			jr .pastdmark  
3091 ..			.dmark: db "IF5"  
3094 f1			.pastdmark: pop af  
3095			endm  
# End of macro DMARK
3095						CALLMONITOR 
3095 cd fb 19			call break_point_state  
3098				endm  
# End of macro CALLMONITOR
3098					endif 
3098				; replace below with ) exec using tok_ptr 
3098 22 c5 f4			ld (os_tok_ptr), hl 
309b c3 09 25			jp exec1 
309e			 
309e .. 00			.closepar:   db ")",0 
30a0			 
30a0				       NEXTW 
30a0 c3 78 24			jp macro_next 
30a3				endm 
# End of macro NEXTW
30a3			.COMC: 
30a3				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
30a3 6f				db WORD_SYS_CORE+91             
30a4 ac 30			dw .SCRATCH            
30a6 02				db 1 + 1 
30a7 .. 00			db ")",0              
30a9				endm 
# End of macro CWHEAD
30a9			; | ) ( -- )  End of comment |  DONE  
30a9				       NEXTW 
30a9 c3 78 24			jp macro_next 
30ac				endm 
# End of macro NEXTW
30ac			 
30ac			.SCRATCH: 
30ac				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
30ac 6f				db WORD_SYS_CORE+91             
30ad e7 30			dw .INC            
30af 08				db 7 + 1 
30b0 .. 00			db "SCRATCH",0              
30b8				endm 
# End of macro CWHEAD
30b8			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
30b8			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
30b8			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
30b8			; | |  
30b8			; | | e.g.    : score $00 scratch ; 
30b8			; | |  
30b8			; | | $00 score ! 
30b8			; | | $01 score +! 
30b8			; | |  
30b8			; | | e.g.   : varword $0a scratch ;  
30b8			; | | 
30b8			; | | $8000 varword ! 
30b8					if DEBUG_FORTH_WORDS_KEY 
30b8						DMARK "SCR" 
30b8 f5				push af  
30b9 3a cd 30			ld a, (.dmark)  
30bc 32 6e fe			ld (debug_mark),a  
30bf 3a ce 30			ld a, (.dmark+1)  
30c2 32 6f fe			ld (debug_mark+1),a  
30c5 3a cf 30			ld a, (.dmark+2)  
30c8 32 70 fe			ld (debug_mark+2),a  
30cb 18 03			jr .pastdmark  
30cd ..			.dmark: db "SCR"  
30d0 f1			.pastdmark: pop af  
30d1			endm  
# End of macro DMARK
30d1						CALLMONITOR 
30d1 cd fb 19			call break_point_state  
30d4				endm  
# End of macro CALLMONITOR
30d4					endif 
30d4			 
30d4					FORTH_DSP_VALUEHL 
30d4 cd c2 22			call macro_dsp_valuehl 
30d7				endm 
# End of macro FORTH_DSP_VALUEHL
30d7				 
30d7					FORTH_DSP_POP 
30d7 cd 7a 23			call macro_forth_dsp_pop 
30da				endm 
# End of macro FORTH_DSP_POP
30da			 
30da 7d					ld a, l 
30db 21 e9 f6				ld hl, os_var_array 
30de cd 86 0f				call addatohl 
30e1			 
30e1 cd cb 20				call forth_push_numhl 
30e4			 
30e4				       NEXTW 
30e4 c3 78 24			jp macro_next 
30e7				endm 
# End of macro NEXTW
30e7			 
30e7			.INC: 
30e7				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
30e7 6f				db WORD_SYS_CORE+91             
30e8 3b 31			dw .DEC            
30ea 03				db 2 + 1 
30eb .. 00			db "+!",0              
30ee				endm 
# End of macro CWHEAD
30ee			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
30ee					if DEBUG_FORTH_WORDS_KEY 
30ee						DMARK "+s_" 
30ee f5				push af  
30ef 3a 03 31			ld a, (.dmark)  
30f2 32 6e fe			ld (debug_mark),a  
30f5 3a 04 31			ld a, (.dmark+1)  
30f8 32 6f fe			ld (debug_mark+1),a  
30fb 3a 05 31			ld a, (.dmark+2)  
30fe 32 70 fe			ld (debug_mark+2),a  
3101 18 03			jr .pastdmark  
3103 ..			.dmark: db "+s_"  
3106 f1			.pastdmark: pop af  
3107			endm  
# End of macro DMARK
3107						CALLMONITOR 
3107 cd fb 19			call break_point_state  
310a				endm  
# End of macro CALLMONITOR
310a					endif 
310a			 
310a					FORTH_DSP_VALUEHL 
310a cd c2 22			call macro_dsp_valuehl 
310d				endm 
# End of macro FORTH_DSP_VALUEHL
310d			 
310d e5					push hl   ; save address 
310e			 
310e					FORTH_DSP_POP 
310e cd 7a 23			call macro_forth_dsp_pop 
3111				endm 
# End of macro FORTH_DSP_POP
3111			 
3111					FORTH_DSP_VALUEHL 
3111 cd c2 22			call macro_dsp_valuehl 
3114				endm 
# End of macro FORTH_DSP_VALUEHL
3114			 
3114					FORTH_DSP_POP 
3114 cd 7a 23			call macro_forth_dsp_pop 
3117				endm 
# End of macro FORTH_DSP_POP
3117			 
3117					; hl contains value to add to byte at a 
3117				 
3117 eb					ex de, hl 
3118			 
3118 e1					pop hl 
3119			 
3119					if DEBUG_FORTH_WORDS 
3119						DMARK "INC" 
3119 f5				push af  
311a 3a 2e 31			ld a, (.dmark)  
311d 32 6e fe			ld (debug_mark),a  
3120 3a 2f 31			ld a, (.dmark+1)  
3123 32 6f fe			ld (debug_mark+1),a  
3126 3a 30 31			ld a, (.dmark+2)  
3129 32 70 fe			ld (debug_mark+2),a  
312c 18 03			jr .pastdmark  
312e ..			.dmark: db "INC"  
3131 f1			.pastdmark: pop af  
3132			endm  
# End of macro DMARK
3132						CALLMONITOR 
3132 cd fb 19			call break_point_state  
3135				endm  
# End of macro CALLMONITOR
3135					endif 
3135			 
3135 7e					ld a,(hl) 
3136 83					add e 
3137 77					ld (hl),a 
3138			 
3138			 
3138			 
3138				       NEXTW 
3138 c3 78 24			jp macro_next 
313b				endm 
# End of macro NEXTW
313b			 
313b			.DEC: 
313b				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
313b 6f				db WORD_SYS_CORE+91             
313c 8c 31			dw .INC2            
313e 03				db 2 + 1 
313f .. 00			db "-!",0              
3142				endm 
# End of macro CWHEAD
3142			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
3142					if DEBUG_FORTH_WORDS_KEY 
3142						DMARK "-s_" 
3142 f5				push af  
3143 3a 57 31			ld a, (.dmark)  
3146 32 6e fe			ld (debug_mark),a  
3149 3a 58 31			ld a, (.dmark+1)  
314c 32 6f fe			ld (debug_mark+1),a  
314f 3a 59 31			ld a, (.dmark+2)  
3152 32 70 fe			ld (debug_mark+2),a  
3155 18 03			jr .pastdmark  
3157 ..			.dmark: db "-s_"  
315a f1			.pastdmark: pop af  
315b			endm  
# End of macro DMARK
315b						CALLMONITOR 
315b cd fb 19			call break_point_state  
315e				endm  
# End of macro CALLMONITOR
315e					endif 
315e			 
315e					FORTH_DSP_VALUEHL 
315e cd c2 22			call macro_dsp_valuehl 
3161				endm 
# End of macro FORTH_DSP_VALUEHL
3161			 
3161 e5					push hl   ; save address 
3162			 
3162					FORTH_DSP_POP 
3162 cd 7a 23			call macro_forth_dsp_pop 
3165				endm 
# End of macro FORTH_DSP_POP
3165			 
3165					FORTH_DSP_VALUEHL 
3165 cd c2 22			call macro_dsp_valuehl 
3168				endm 
# End of macro FORTH_DSP_VALUEHL
3168			 
3168					; hl contains value to add to byte at a 
3168				 
3168 eb					ex de, hl 
3169			 
3169 e1					pop hl 
316a			 
316a					if DEBUG_FORTH_WORDS 
316a						DMARK "DEC" 
316a f5				push af  
316b 3a 7f 31			ld a, (.dmark)  
316e 32 6e fe			ld (debug_mark),a  
3171 3a 80 31			ld a, (.dmark+1)  
3174 32 6f fe			ld (debug_mark+1),a  
3177 3a 81 31			ld a, (.dmark+2)  
317a 32 70 fe			ld (debug_mark+2),a  
317d 18 03			jr .pastdmark  
317f ..			.dmark: db "DEC"  
3182 f1			.pastdmark: pop af  
3183			endm  
# End of macro DMARK
3183						CALLMONITOR 
3183 cd fb 19			call break_point_state  
3186				endm  
# End of macro CALLMONITOR
3186					endif 
3186			 
3186 7e					ld a,(hl) 
3187 93					sub e 
3188 77					ld (hl),a 
3189			 
3189			 
3189			 
3189				       NEXTW 
3189 c3 78 24			jp macro_next 
318c				endm 
# End of macro NEXTW
318c			 
318c			.INC2: 
318c				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
318c 6f				db WORD_SYS_CORE+91             
318d 36 32			dw .DEC2            
318f 04				db 3 + 1 
3190 .. 00			db "+2!",0              
3194				endm 
# End of macro CWHEAD
3194			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3194			 
3194					if DEBUG_FORTH_WORDS_KEY 
3194						DMARK "+2s" 
3194 f5				push af  
3195 3a a9 31			ld a, (.dmark)  
3198 32 6e fe			ld (debug_mark),a  
319b 3a aa 31			ld a, (.dmark+1)  
319e 32 6f fe			ld (debug_mark+1),a  
31a1 3a ab 31			ld a, (.dmark+2)  
31a4 32 70 fe			ld (debug_mark+2),a  
31a7 18 03			jr .pastdmark  
31a9 ..			.dmark: db "+2s"  
31ac f1			.pastdmark: pop af  
31ad			endm  
# End of macro DMARK
31ad						CALLMONITOR 
31ad cd fb 19			call break_point_state  
31b0				endm  
# End of macro CALLMONITOR
31b0					endif 
31b0			 
31b0					; Address 
31b0			 
31b0					FORTH_DSP_VALUEHL 
31b0 cd c2 22			call macro_dsp_valuehl 
31b3				endm 
# End of macro FORTH_DSP_VALUEHL
31b3			 
31b3 e5					push hl    ; save address 
31b4			 
31b4					; load content into de 
31b4			 
31b4 5e					ld e,(hl) 
31b5 23					inc hl 
31b6 56					ld d, (hl) 
31b7			 
31b7					if DEBUG_FORTH_WORDS 
31b7						DMARK "+2a" 
31b7 f5				push af  
31b8 3a cc 31			ld a, (.dmark)  
31bb 32 6e fe			ld (debug_mark),a  
31be 3a cd 31			ld a, (.dmark+1)  
31c1 32 6f fe			ld (debug_mark+1),a  
31c4 3a ce 31			ld a, (.dmark+2)  
31c7 32 70 fe			ld (debug_mark+2),a  
31ca 18 03			jr .pastdmark  
31cc ..			.dmark: db "+2a"  
31cf f1			.pastdmark: pop af  
31d0			endm  
# End of macro DMARK
31d0						CALLMONITOR 
31d0 cd fb 19			call break_point_state  
31d3				endm  
# End of macro CALLMONITOR
31d3					endif 
31d3			 
31d3					FORTH_DSP_POP 
31d3 cd 7a 23			call macro_forth_dsp_pop 
31d6				endm 
# End of macro FORTH_DSP_POP
31d6			 
31d6					; Get value to add 
31d6			 
31d6					FORTH_DSP_VALUE 
31d6 cd ab 22			call macro_forth_dsp_value 
31d9				endm 
# End of macro FORTH_DSP_VALUE
31d9			 
31d9					if DEBUG_FORTH_WORDS 
31d9						DMARK "+2v" 
31d9 f5				push af  
31da 3a ee 31			ld a, (.dmark)  
31dd 32 6e fe			ld (debug_mark),a  
31e0 3a ef 31			ld a, (.dmark+1)  
31e3 32 6f fe			ld (debug_mark+1),a  
31e6 3a f0 31			ld a, (.dmark+2)  
31e9 32 70 fe			ld (debug_mark+2),a  
31ec 18 03			jr .pastdmark  
31ee ..			.dmark: db "+2v"  
31f1 f1			.pastdmark: pop af  
31f2			endm  
# End of macro DMARK
31f2						CALLMONITOR 
31f2 cd fb 19			call break_point_state  
31f5				endm  
# End of macro CALLMONITOR
31f5					endif 
31f5			 
31f5 19					add hl, de 
31f6			 
31f6					if DEBUG_FORTH_WORDS 
31f6						DMARK "+2+" 
31f6 f5				push af  
31f7 3a 0b 32			ld a, (.dmark)  
31fa 32 6e fe			ld (debug_mark),a  
31fd 3a 0c 32			ld a, (.dmark+1)  
3200 32 6f fe			ld (debug_mark+1),a  
3203 3a 0d 32			ld a, (.dmark+2)  
3206 32 70 fe			ld (debug_mark+2),a  
3209 18 03			jr .pastdmark  
320b ..			.dmark: db "+2+"  
320e f1			.pastdmark: pop af  
320f			endm  
# End of macro DMARK
320f						CALLMONITOR 
320f cd fb 19			call break_point_state  
3212				endm  
# End of macro CALLMONITOR
3212					endif 
3212			 
3212					; move result to de 
3212			 
3212 eb					ex de, hl 
3213			 
3213					; Address 
3213			 
3213 e1					pop hl 
3214			 
3214					; save it back 
3214			 
3214 73					ld (hl), e 
3215 23					inc hl 
3216 72					ld (hl), d 
3217			 
3217					if DEBUG_FORTH_WORDS 
3217						DMARK "+2e" 
3217 f5				push af  
3218 3a 2c 32			ld a, (.dmark)  
321b 32 6e fe			ld (debug_mark),a  
321e 3a 2d 32			ld a, (.dmark+1)  
3221 32 6f fe			ld (debug_mark+1),a  
3224 3a 2e 32			ld a, (.dmark+2)  
3227 32 70 fe			ld (debug_mark+2),a  
322a 18 03			jr .pastdmark  
322c ..			.dmark: db "+2e"  
322f f1			.pastdmark: pop af  
3230			endm  
# End of macro DMARK
3230						CALLMONITOR 
3230 cd fb 19			call break_point_state  
3233				endm  
# End of macro CALLMONITOR
3233					endif 
3233			 
3233			 
3233			 
3233			 
3233			 
3233				       NEXTW 
3233 c3 78 24			jp macro_next 
3236				endm 
# End of macro NEXTW
3236			 
3236			.DEC2: 
3236				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3236 6f				db WORD_SYS_CORE+91             
3237 e2 32			dw .GET2            
3239 04				db 3 + 1 
323a .. 00			db "-2!",0              
323e				endm 
# End of macro CWHEAD
323e			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
323e			 
323e			 
323e					if DEBUG_FORTH_WORDS_KEY 
323e						DMARK "-2s" 
323e f5				push af  
323f 3a 53 32			ld a, (.dmark)  
3242 32 6e fe			ld (debug_mark),a  
3245 3a 54 32			ld a, (.dmark+1)  
3248 32 6f fe			ld (debug_mark+1),a  
324b 3a 55 32			ld a, (.dmark+2)  
324e 32 70 fe			ld (debug_mark+2),a  
3251 18 03			jr .pastdmark  
3253 ..			.dmark: db "-2s"  
3256 f1			.pastdmark: pop af  
3257			endm  
# End of macro DMARK
3257						CALLMONITOR 
3257 cd fb 19			call break_point_state  
325a				endm  
# End of macro CALLMONITOR
325a					endif 
325a			 
325a					; Address 
325a			 
325a					FORTH_DSP_VALUEHL 
325a cd c2 22			call macro_dsp_valuehl 
325d				endm 
# End of macro FORTH_DSP_VALUEHL
325d			 
325d e5					push hl    ; save address 
325e			 
325e					; load content into de 
325e			 
325e 5e					ld e,(hl) 
325f 23					inc hl 
3260 56					ld d, (hl) 
3261			 
3261					if DEBUG_FORTH_WORDS 
3261						DMARK "-2a" 
3261 f5				push af  
3262 3a 76 32			ld a, (.dmark)  
3265 32 6e fe			ld (debug_mark),a  
3268 3a 77 32			ld a, (.dmark+1)  
326b 32 6f fe			ld (debug_mark+1),a  
326e 3a 78 32			ld a, (.dmark+2)  
3271 32 70 fe			ld (debug_mark+2),a  
3274 18 03			jr .pastdmark  
3276 ..			.dmark: db "-2a"  
3279 f1			.pastdmark: pop af  
327a			endm  
# End of macro DMARK
327a						CALLMONITOR 
327a cd fb 19			call break_point_state  
327d				endm  
# End of macro CALLMONITOR
327d					endif 
327d			 
327d					FORTH_DSP_POP 
327d cd 7a 23			call macro_forth_dsp_pop 
3280				endm 
# End of macro FORTH_DSP_POP
3280			 
3280					; Get value to remove 
3280			 
3280					FORTH_DSP_VALUE 
3280 cd ab 22			call macro_forth_dsp_value 
3283				endm 
# End of macro FORTH_DSP_VALUE
3283			 
3283					if DEBUG_FORTH_WORDS 
3283						DMARK "-2v" 
3283 f5				push af  
3284 3a 98 32			ld a, (.dmark)  
3287 32 6e fe			ld (debug_mark),a  
328a 3a 99 32			ld a, (.dmark+1)  
328d 32 6f fe			ld (debug_mark+1),a  
3290 3a 9a 32			ld a, (.dmark+2)  
3293 32 70 fe			ld (debug_mark+2),a  
3296 18 03			jr .pastdmark  
3298 ..			.dmark: db "-2v"  
329b f1			.pastdmark: pop af  
329c			endm  
# End of macro DMARK
329c						CALLMONITOR 
329c cd fb 19			call break_point_state  
329f				endm  
# End of macro CALLMONITOR
329f					endif 
329f			 
329f eb					ex de, hl 
32a0 ed 52				sbc hl, de 
32a2			 
32a2					if DEBUG_FORTH_WORDS 
32a2						DMARK "-2d" 
32a2 f5				push af  
32a3 3a b7 32			ld a, (.dmark)  
32a6 32 6e fe			ld (debug_mark),a  
32a9 3a b8 32			ld a, (.dmark+1)  
32ac 32 6f fe			ld (debug_mark+1),a  
32af 3a b9 32			ld a, (.dmark+2)  
32b2 32 70 fe			ld (debug_mark+2),a  
32b5 18 03			jr .pastdmark  
32b7 ..			.dmark: db "-2d"  
32ba f1			.pastdmark: pop af  
32bb			endm  
# End of macro DMARK
32bb						CALLMONITOR 
32bb cd fb 19			call break_point_state  
32be				endm  
# End of macro CALLMONITOR
32be					endif 
32be			 
32be					; move result to de 
32be			 
32be eb					ex de, hl 
32bf			 
32bf					; Address 
32bf			 
32bf e1					pop hl 
32c0			 
32c0					; save it back 
32c0			 
32c0 73					ld (hl), e 
32c1 23					inc hl 
32c2 72					ld (hl), d 
32c3			 
32c3					if DEBUG_FORTH_WORDS 
32c3						DMARK "-2e" 
32c3 f5				push af  
32c4 3a d8 32			ld a, (.dmark)  
32c7 32 6e fe			ld (debug_mark),a  
32ca 3a d9 32			ld a, (.dmark+1)  
32cd 32 6f fe			ld (debug_mark+1),a  
32d0 3a da 32			ld a, (.dmark+2)  
32d3 32 70 fe			ld (debug_mark+2),a  
32d6 18 03			jr .pastdmark  
32d8 ..			.dmark: db "-2e"  
32db f1			.pastdmark: pop af  
32dc			endm  
# End of macro DMARK
32dc						CALLMONITOR 
32dc cd fb 19			call break_point_state  
32df				endm  
# End of macro CALLMONITOR
32df					endif 
32df			 
32df			 
32df			 
32df			 
32df			 
32df				       NEXTW 
32df c3 78 24			jp macro_next 
32e2				endm 
# End of macro NEXTW
32e2			.GET2: 
32e2				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
32e2 6f				db WORD_SYS_CORE+91             
32e3 12 33			dw .BANG2            
32e5 03				db 2 + 1 
32e6 .. 00			db "2@",0              
32e9				endm 
# End of macro CWHEAD
32e9			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
32e9					if DEBUG_FORTH_WORDS_KEY 
32e9						DMARK "2A_" 
32e9 f5				push af  
32ea 3a fe 32			ld a, (.dmark)  
32ed 32 6e fe			ld (debug_mark),a  
32f0 3a ff 32			ld a, (.dmark+1)  
32f3 32 6f fe			ld (debug_mark+1),a  
32f6 3a 00 33			ld a, (.dmark+2)  
32f9 32 70 fe			ld (debug_mark+2),a  
32fc 18 03			jr .pastdmark  
32fe ..			.dmark: db "2A_"  
3301 f1			.pastdmark: pop af  
3302			endm  
# End of macro DMARK
3302						CALLMONITOR 
3302 cd fb 19			call break_point_state  
3305				endm  
# End of macro CALLMONITOR
3305					endif 
3305			 
3305					FORTH_DSP_VALUEHL 
3305 cd c2 22			call macro_dsp_valuehl 
3308				endm 
# End of macro FORTH_DSP_VALUEHL
3308			 
3308 5e					ld e, (hl) 
3309 23					inc hl 
330a 56					ld d, (hl) 
330b			 
330b eb					ex de, hl 
330c			 
330c cd cb 20				call forth_push_numhl 
330f			 
330f				       NEXTW 
330f c3 78 24			jp macro_next 
3312				endm 
# End of macro NEXTW
3312			.BANG2: 
3312				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
3312 6f				db WORD_SYS_CORE+91             
3313 4a 33			dw .CONFIG            
3315 03				db 2 + 1 
3316 .. 00			db "2!",0              
3319				endm 
# End of macro CWHEAD
3319			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3319					if DEBUG_FORTH_WORDS_KEY 
3319						DMARK "2S_" 
3319 f5				push af  
331a 3a 2e 33			ld a, (.dmark)  
331d 32 6e fe			ld (debug_mark),a  
3320 3a 2f 33			ld a, (.dmark+1)  
3323 32 6f fe			ld (debug_mark+1),a  
3326 3a 30 33			ld a, (.dmark+2)  
3329 32 70 fe			ld (debug_mark+2),a  
332c 18 03			jr .pastdmark  
332e ..			.dmark: db "2S_"  
3331 f1			.pastdmark: pop af  
3332			endm  
# End of macro DMARK
3332						CALLMONITOR 
3332 cd fb 19			call break_point_state  
3335				endm  
# End of macro CALLMONITOR
3335					endif 
3335			 
3335					FORTH_DSP_VALUEHL 
3335 cd c2 22			call macro_dsp_valuehl 
3338				endm 
# End of macro FORTH_DSP_VALUEHL
3338			 
3338 e5					push hl   ; save address 
3339			 
3339			 
3339					FORTH_DSP_POP 
3339 cd 7a 23			call macro_forth_dsp_pop 
333c				endm 
# End of macro FORTH_DSP_POP
333c			 
333c					 
333c					FORTH_DSP_VALUEHL 
333c cd c2 22			call macro_dsp_valuehl 
333f				endm 
# End of macro FORTH_DSP_VALUEHL
333f			 
333f					FORTH_DSP_POP 
333f cd 7a 23			call macro_forth_dsp_pop 
3342				endm 
# End of macro FORTH_DSP_POP
3342			 
3342 eb					ex de, hl    ; value now in de 
3343			 
3343 e1					pop hl 
3344			 
3344 73					ld (hl), e 
3345			 
3345 23					inc hl 
3346			 
3346 72					ld (hl), d 
3347			 
3347			 
3347				       NEXTW 
3347 c3 78 24			jp macro_next 
334a				endm 
# End of macro NEXTW
334a			.CONFIG: 
334a				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
334a 6f				db WORD_SYS_CORE+91             
334b 5b 33			dw .ENDCORE            
334d 07				db 6 + 1 
334e .. 00			db "CONFIG",0              
3355				endm 
# End of macro CWHEAD
3355			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3355			 
3355 cd 10 16				call config 
3358					NEXTW 
3358 c3 78 24			jp macro_next 
335b				endm 
# End of macro NEXTW
335b			.ENDCORE: 
335b			 
335b			; eof 
335b			 
335b			 
# End of file forth_words_core.asm
335b			include "forth_words_flow.asm" 
335b			 
335b			; | ## Program Flow Words 
335b			 
335b			.IF: 
335b				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
335b 1e				db WORD_SYS_CORE+10             
335c 50 34			dw .THEN            
335e 03				db 2 + 1 
335f .. 00			db "IF",0              
3362				endm 
# End of macro CWHEAD
3362			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3362			; 
3362					if DEBUG_FORTH_WORDS_KEY 
3362						DMARK "IF." 
3362 f5				push af  
3363 3a 77 33			ld a, (.dmark)  
3366 32 6e fe			ld (debug_mark),a  
3369 3a 78 33			ld a, (.dmark+1)  
336c 32 6f fe			ld (debug_mark+1),a  
336f 3a 79 33			ld a, (.dmark+2)  
3372 32 70 fe			ld (debug_mark+2),a  
3375 18 03			jr .pastdmark  
3377 ..			.dmark: db "IF."  
337a f1			.pastdmark: pop af  
337b			endm  
# End of macro DMARK
337b						CALLMONITOR 
337b cd fb 19			call break_point_state  
337e				endm  
# End of macro CALLMONITOR
337e					endif 
337e			; eval TOS 
337e			 
337e				FORTH_DSP_VALUEHL 
337e cd c2 22			call macro_dsp_valuehl 
3381				endm 
# End of macro FORTH_DSP_VALUEHL
3381			 
3381			;	push hl 
3381				FORTH_DSP_POP 
3381 cd 7a 23			call macro_forth_dsp_pop 
3384				endm 
# End of macro FORTH_DSP_POP
3384			;	pop hl 
3384			 
3384					if DEBUG_FORTH_WORDS 
3384						DMARK "IF1" 
3384 f5				push af  
3385 3a 99 33			ld a, (.dmark)  
3388 32 6e fe			ld (debug_mark),a  
338b 3a 9a 33			ld a, (.dmark+1)  
338e 32 6f fe			ld (debug_mark+1),a  
3391 3a 9b 33			ld a, (.dmark+2)  
3394 32 70 fe			ld (debug_mark+2),a  
3397 18 03			jr .pastdmark  
3399 ..			.dmark: db "IF1"  
339c f1			.pastdmark: pop af  
339d			endm  
# End of macro DMARK
339d						CALLMONITOR 
339d cd fb 19			call break_point_state  
33a0				endm  
# End of macro CALLMONITOR
33a0					endif 
33a0 b7				or a        ; clear carry flag 
33a1 11 00 00			ld de, 0 
33a4 eb				ex de,hl 
33a5 ed 52			sbc hl, de 
33a7 c2 31 34			jp nz, .iftrue 
33aa			 
33aa					if DEBUG_FORTH_WORDS 
33aa						DMARK "IF2" 
33aa f5				push af  
33ab 3a bf 33			ld a, (.dmark)  
33ae 32 6e fe			ld (debug_mark),a  
33b1 3a c0 33			ld a, (.dmark+1)  
33b4 32 6f fe			ld (debug_mark+1),a  
33b7 3a c1 33			ld a, (.dmark+2)  
33ba 32 70 fe			ld (debug_mark+2),a  
33bd 18 03			jr .pastdmark  
33bf ..			.dmark: db "IF2"  
33c2 f1			.pastdmark: pop af  
33c3			endm  
# End of macro DMARK
33c3						CALLMONITOR 
33c3 cd fb 19			call break_point_state  
33c6				endm  
# End of macro CALLMONITOR
33c6					endif 
33c6			 
33c6			; if not true then skip to THEN 
33c6			 
33c6				; TODO get tok_ptr 
33c6				; TODO consume toks until we get to THEN 
33c6			 
33c6 2a c5 f4			ld hl, (os_tok_ptr) 
33c9					if DEBUG_FORTH_WORDS 
33c9						DMARK "IF3" 
33c9 f5				push af  
33ca 3a de 33			ld a, (.dmark)  
33cd 32 6e fe			ld (debug_mark),a  
33d0 3a df 33			ld a, (.dmark+1)  
33d3 32 6f fe			ld (debug_mark+1),a  
33d6 3a e0 33			ld a, (.dmark+2)  
33d9 32 70 fe			ld (debug_mark+2),a  
33dc 18 03			jr .pastdmark  
33de ..			.dmark: db "IF3"  
33e1 f1			.pastdmark: pop af  
33e2			endm  
# End of macro DMARK
33e2						CALLMONITOR 
33e2 cd fb 19			call break_point_state  
33e5				endm  
# End of macro CALLMONITOR
33e5						 
33e5					endif 
33e5 11 2c 34			ld de, .ifthen 
33e8					if DEBUG_FORTH_WORDS 
33e8						DMARK "IF4" 
33e8 f5				push af  
33e9 3a fd 33			ld a, (.dmark)  
33ec 32 6e fe			ld (debug_mark),a  
33ef 3a fe 33			ld a, (.dmark+1)  
33f2 32 6f fe			ld (debug_mark+1),a  
33f5 3a ff 33			ld a, (.dmark+2)  
33f8 32 70 fe			ld (debug_mark+2),a  
33fb 18 03			jr .pastdmark  
33fd ..			.dmark: db "IF4"  
3400 f1			.pastdmark: pop af  
3401			endm  
# End of macro DMARK
3401						CALLMONITOR 
3401 cd fb 19			call break_point_state  
3404				endm  
# End of macro CALLMONITOR
3404					endif 
3404 cd 93 25			call findnexttok  
3407			 
3407					if DEBUG_FORTH_WORDS 
3407						DMARK "IF5" 
3407 f5				push af  
3408 3a 1c 34			ld a, (.dmark)  
340b 32 6e fe			ld (debug_mark),a  
340e 3a 1d 34			ld a, (.dmark+1)  
3411 32 6f fe			ld (debug_mark+1),a  
3414 3a 1e 34			ld a, (.dmark+2)  
3417 32 70 fe			ld (debug_mark+2),a  
341a 18 03			jr .pastdmark  
341c ..			.dmark: db "IF5"  
341f f1			.pastdmark: pop af  
3420			endm  
# End of macro DMARK
3420						CALLMONITOR 
3420 cd fb 19			call break_point_state  
3423				endm  
# End of macro CALLMONITOR
3423					endif 
3423				; TODO replace below with ; exec using tok_ptr 
3423 22 c5 f4			ld (os_tok_ptr), hl 
3426 c3 09 25			jp exec1 
3429				NEXTW 
3429 c3 78 24			jp macro_next 
342c				endm 
# End of macro NEXTW
342c			 
342c .. 00		.ifthen:  db "THEN",0 
3431			 
3431			.iftrue:		 
3431				; Exec next words normally 
3431			 
3431				; if true then exec following IF as normal 
3431					if DEBUG_FORTH_WORDS 
3431						DMARK "IFT" 
3431 f5				push af  
3432 3a 46 34			ld a, (.dmark)  
3435 32 6e fe			ld (debug_mark),a  
3438 3a 47 34			ld a, (.dmark+1)  
343b 32 6f fe			ld (debug_mark+1),a  
343e 3a 48 34			ld a, (.dmark+2)  
3441 32 70 fe			ld (debug_mark+2),a  
3444 18 03			jr .pastdmark  
3446 ..			.dmark: db "IFT"  
3449 f1			.pastdmark: pop af  
344a			endm  
# End of macro DMARK
344a						CALLMONITOR 
344a cd fb 19			call break_point_state  
344d				endm  
# End of macro CALLMONITOR
344d					endif 
344d			 
344d					NEXTW 
344d c3 78 24			jp macro_next 
3450				endm 
# End of macro NEXTW
3450			.THEN: 
3450				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3450 1f				db WORD_SYS_CORE+11             
3451 78 34			dw .ELSE            
3453 05				db 4 + 1 
3454 .. 00			db "THEN",0              
3459				endm 
# End of macro CWHEAD
3459			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3459					if DEBUG_FORTH_WORDS_KEY 
3459						DMARK "THN" 
3459 f5				push af  
345a 3a 6e 34			ld a, (.dmark)  
345d 32 6e fe			ld (debug_mark),a  
3460 3a 6f 34			ld a, (.dmark+1)  
3463 32 6f fe			ld (debug_mark+1),a  
3466 3a 70 34			ld a, (.dmark+2)  
3469 32 70 fe			ld (debug_mark+2),a  
346c 18 03			jr .pastdmark  
346e ..			.dmark: db "THN"  
3471 f1			.pastdmark: pop af  
3472			endm  
# End of macro DMARK
3472						CALLMONITOR 
3472 cd fb 19			call break_point_state  
3475				endm  
# End of macro CALLMONITOR
3475					endif 
3475					NEXTW 
3475 c3 78 24			jp macro_next 
3478				endm 
# End of macro NEXTW
3478			.ELSE: 
3478				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3478 20				db WORD_SYS_CORE+12             
3479 a0 34			dw .DO            
347b 03				db 2 + 1 
347c .. 00			db "ELSE",0              
3481				endm 
# End of macro CWHEAD
3481			; | ELSE ( -- ) Not supported - does nothing | TODO 
3481			 
3481					if DEBUG_FORTH_WORDS_KEY 
3481						DMARK "ELS" 
3481 f5				push af  
3482 3a 96 34			ld a, (.dmark)  
3485 32 6e fe			ld (debug_mark),a  
3488 3a 97 34			ld a, (.dmark+1)  
348b 32 6f fe			ld (debug_mark+1),a  
348e 3a 98 34			ld a, (.dmark+2)  
3491 32 70 fe			ld (debug_mark+2),a  
3494 18 03			jr .pastdmark  
3496 ..			.dmark: db "ELS"  
3499 f1			.pastdmark: pop af  
349a			endm  
# End of macro DMARK
349a						CALLMONITOR 
349a cd fb 19			call break_point_state  
349d				endm  
# End of macro CALLMONITOR
349d					endif 
349d			 
349d			 
349d					NEXTW 
349d c3 78 24			jp macro_next 
34a0				endm 
# End of macro NEXTW
34a0			.DO: 
34a0				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
34a0 21				db WORD_SYS_CORE+13             
34a1 c7 35			dw .LOOP            
34a3 03				db 2 + 1 
34a4 .. 00			db "DO",0              
34a7				endm 
# End of macro CWHEAD
34a7			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
34a7			 
34a7					if DEBUG_FORTH_WORDS_KEY 
34a7						DMARK "DO." 
34a7 f5				push af  
34a8 3a bc 34			ld a, (.dmark)  
34ab 32 6e fe			ld (debug_mark),a  
34ae 3a bd 34			ld a, (.dmark+1)  
34b1 32 6f fe			ld (debug_mark+1),a  
34b4 3a be 34			ld a, (.dmark+2)  
34b7 32 70 fe			ld (debug_mark+2),a  
34ba 18 03			jr .pastdmark  
34bc ..			.dmark: db "DO."  
34bf f1			.pastdmark: pop af  
34c0			endm  
# End of macro DMARK
34c0						CALLMONITOR 
34c0 cd fb 19			call break_point_state  
34c3				endm  
# End of macro CALLMONITOR
34c3					endif 
34c3			;  push pc to rsp stack past the DO 
34c3			 
34c3 2a c5 f4				ld hl, (os_tok_ptr) 
34c6 23					inc hl   ; D 
34c7 23					inc hl  ; O 
34c8 23					inc hl   ; null 
34c9					if DEBUG_FORTH_WORDS 
34c9						DMARK "DO2" 
34c9 f5				push af  
34ca 3a de 34			ld a, (.dmark)  
34cd 32 6e fe			ld (debug_mark),a  
34d0 3a df 34			ld a, (.dmark+1)  
34d3 32 6f fe			ld (debug_mark+1),a  
34d6 3a e0 34			ld a, (.dmark+2)  
34d9 32 70 fe			ld (debug_mark+2),a  
34dc 18 03			jr .pastdmark  
34de ..			.dmark: db "DO2"  
34e1 f1			.pastdmark: pop af  
34e2			endm  
# End of macro DMARK
34e2						CALLMONITOR 
34e2 cd fb 19			call break_point_state  
34e5				endm  
# End of macro CALLMONITOR
34e5					endif 
34e5					FORTH_RSP_NEXT 
34e5 cd 72 20			call macro_forth_rsp_next 
34e8				endm 
# End of macro FORTH_RSP_NEXT
34e8					if DEBUG_FORTH_WORDS 
34e8						DMARK "DO3" 
34e8 f5				push af  
34e9 3a fd 34			ld a, (.dmark)  
34ec 32 6e fe			ld (debug_mark),a  
34ef 3a fe 34			ld a, (.dmark+1)  
34f2 32 6f fe			ld (debug_mark+1),a  
34f5 3a ff 34			ld a, (.dmark+2)  
34f8 32 70 fe			ld (debug_mark+2),a  
34fb 18 03			jr .pastdmark  
34fd ..			.dmark: db "DO3"  
3500 f1			.pastdmark: pop af  
3501			endm  
# End of macro DMARK
3501						CALLMONITOR 
3501 cd fb 19			call break_point_state  
3504				endm  
# End of macro CALLMONITOR
3504					endif 
3504			 
3504					;if DEBUG_FORTH_WORDS 
3504				;		push hl 
3504			;		endif  
3504			 
3504			; get counters from data stack 
3504			 
3504			 
3504					FORTH_DSP_VALUEHL 
3504 cd c2 22			call macro_dsp_valuehl 
3507				endm 
# End of macro FORTH_DSP_VALUEHL
3507 e5					push hl		 ; hl now has starting counter which needs to be tos 
3508			 
3508					if DEBUG_FORTH_WORDS 
3508						DMARK "DO4" 
3508 f5				push af  
3509 3a 1d 35			ld a, (.dmark)  
350c 32 6e fe			ld (debug_mark),a  
350f 3a 1e 35			ld a, (.dmark+1)  
3512 32 6f fe			ld (debug_mark+1),a  
3515 3a 1f 35			ld a, (.dmark+2)  
3518 32 70 fe			ld (debug_mark+2),a  
351b 18 03			jr .pastdmark  
351d ..			.dmark: db "DO4"  
3520 f1			.pastdmark: pop af  
3521			endm  
# End of macro DMARK
3521						CALLMONITOR 
3521 cd fb 19			call break_point_state  
3524				endm  
# End of macro CALLMONITOR
3524					endif 
3524					FORTH_DSP_POP 
3524 cd 7a 23			call macro_forth_dsp_pop 
3527				endm 
# End of macro FORTH_DSP_POP
3527			 
3527					if DEBUG_FORTH_WORDS 
3527						DMARK "DO5" 
3527 f5				push af  
3528 3a 3c 35			ld a, (.dmark)  
352b 32 6e fe			ld (debug_mark),a  
352e 3a 3d 35			ld a, (.dmark+1)  
3531 32 6f fe			ld (debug_mark+1),a  
3534 3a 3e 35			ld a, (.dmark+2)  
3537 32 70 fe			ld (debug_mark+2),a  
353a 18 03			jr .pastdmark  
353c ..			.dmark: db "DO5"  
353f f1			.pastdmark: pop af  
3540			endm  
# End of macro DMARK
3540						CALLMONITOR 
3540 cd fb 19			call break_point_state  
3543				endm  
# End of macro CALLMONITOR
3543					endif 
3543			 
3543					FORTH_DSP_VALUEHL 
3543 cd c2 22			call macro_dsp_valuehl 
3546				endm 
# End of macro FORTH_DSP_VALUEHL
3546			;		push hl		 ; hl now has starting limit counter 
3546			 
3546					if DEBUG_FORTH_WORDS 
3546						DMARK "DO6" 
3546 f5				push af  
3547 3a 5b 35			ld a, (.dmark)  
354a 32 6e fe			ld (debug_mark),a  
354d 3a 5c 35			ld a, (.dmark+1)  
3550 32 6f fe			ld (debug_mark+1),a  
3553 3a 5d 35			ld a, (.dmark+2)  
3556 32 70 fe			ld (debug_mark+2),a  
3559 18 03			jr .pastdmark  
355b ..			.dmark: db "DO6"  
355e f1			.pastdmark: pop af  
355f			endm  
# End of macro DMARK
355f						CALLMONITOR 
355f cd fb 19			call break_point_state  
3562				endm  
# End of macro CALLMONITOR
3562					endif 
3562					FORTH_DSP_POP 
3562 cd 7a 23			call macro_forth_dsp_pop 
3565				endm 
# End of macro FORTH_DSP_POP
3565			 
3565			; put counters on the loop stack 
3565			 
3565			;		pop hl			 ; limit counter 
3565 d1					pop de			; start counter 
3566			 
3566					; push limit counter 
3566			 
3566					if DEBUG_FORTH_WORDS 
3566						DMARK "DO7" 
3566 f5				push af  
3567 3a 7b 35			ld a, (.dmark)  
356a 32 6e fe			ld (debug_mark),a  
356d 3a 7c 35			ld a, (.dmark+1)  
3570 32 6f fe			ld (debug_mark+1),a  
3573 3a 7d 35			ld a, (.dmark+2)  
3576 32 70 fe			ld (debug_mark+2),a  
3579 18 03			jr .pastdmark  
357b ..			.dmark: db "DO7"  
357e f1			.pastdmark: pop af  
357f			endm  
# End of macro DMARK
357f						CALLMONITOR 
357f cd fb 19			call break_point_state  
3582				endm  
# End of macro CALLMONITOR
3582					endif 
3582					FORTH_LOOP_NEXT 
3582 cd f3 22			call macro_forth_loop_next 
3585				endm 
# End of macro FORTH_LOOP_NEXT
3585			 
3585					; push start counter 
3585			 
3585 eb					ex de, hl 
3586					if DEBUG_FORTH_WORDS 
3586						DMARK "DO7" 
3586 f5				push af  
3587 3a 9b 35			ld a, (.dmark)  
358a 32 6e fe			ld (debug_mark),a  
358d 3a 9c 35			ld a, (.dmark+1)  
3590 32 6f fe			ld (debug_mark+1),a  
3593 3a 9d 35			ld a, (.dmark+2)  
3596 32 70 fe			ld (debug_mark+2),a  
3599 18 03			jr .pastdmark  
359b ..			.dmark: db "DO7"  
359e f1			.pastdmark: pop af  
359f			endm  
# End of macro DMARK
359f						CALLMONITOR 
359f cd fb 19			call break_point_state  
35a2				endm  
# End of macro CALLMONITOR
35a2					endif 
35a2					FORTH_LOOP_NEXT 
35a2 cd f3 22			call macro_forth_loop_next 
35a5				endm 
# End of macro FORTH_LOOP_NEXT
35a5			 
35a5			 
35a5					; init first round of I counter 
35a5			 
35a5 22 e9 f4				ld (os_current_i), hl 
35a8			 
35a8					if DEBUG_FORTH_WORDS 
35a8						DMARK "DO8" 
35a8 f5				push af  
35a9 3a bd 35			ld a, (.dmark)  
35ac 32 6e fe			ld (debug_mark),a  
35af 3a be 35			ld a, (.dmark+1)  
35b2 32 6f fe			ld (debug_mark+1),a  
35b5 3a bf 35			ld a, (.dmark+2)  
35b8 32 70 fe			ld (debug_mark+2),a  
35bb 18 03			jr .pastdmark  
35bd ..			.dmark: db "DO8"  
35c0 f1			.pastdmark: pop af  
35c1			endm  
# End of macro DMARK
35c1						CALLMONITOR 
35c1 cd fb 19			call break_point_state  
35c4				endm  
# End of macro CALLMONITOR
35c4					endif 
35c4			 
35c4					NEXTW 
35c4 c3 78 24			jp macro_next 
35c7				endm 
# End of macro NEXTW
35c7			.LOOP: 
35c7				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
35c7 22				db WORD_SYS_CORE+14             
35c8 df 36			dw .I            
35ca 05				db 4 + 1 
35cb .. 00			db "LOOP",0              
35d0				endm 
# End of macro CWHEAD
35d0			; | LOOP ( -- ) Increment and test loop counter  | DONE 
35d0			 
35d0				; pop tos as current loop count to hl 
35d0			 
35d0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35d0			 
35d0				FORTH_LOOP_TOS 
35d0 cd 26 23			call macro_forth_loop_tos 
35d3				endm 
# End of macro FORTH_LOOP_TOS
35d3 e5				push hl 
35d4			 
35d4					if DEBUG_FORTH_WORDS_KEY 
35d4						DMARK "LOP" 
35d4 f5				push af  
35d5 3a e9 35			ld a, (.dmark)  
35d8 32 6e fe			ld (debug_mark),a  
35db 3a ea 35			ld a, (.dmark+1)  
35de 32 6f fe			ld (debug_mark+1),a  
35e1 3a eb 35			ld a, (.dmark+2)  
35e4 32 70 fe			ld (debug_mark+2),a  
35e7 18 03			jr .pastdmark  
35e9 ..			.dmark: db "LOP"  
35ec f1			.pastdmark: pop af  
35ed			endm  
# End of macro DMARK
35ed						CALLMONITOR 
35ed cd fb 19			call break_point_state  
35f0				endm  
# End of macro CALLMONITOR
35f0					endif 
35f0				; next item on the stack is the limit. get it 
35f0			 
35f0			 
35f0				FORTH_LOOP_POP 
35f0 cd 30 23			call macro_forth_loop_pop 
35f3				endm 
# End of macro FORTH_LOOP_POP
35f3			 
35f3				FORTH_LOOP_TOS 
35f3 cd 26 23			call macro_forth_loop_tos 
35f6				endm 
# End of macro FORTH_LOOP_TOS
35f6			 
35f6 d1				pop de		 ; de = i, hl = limit 
35f7			 
35f7					if DEBUG_FORTH_WORDS 
35f7						DMARK "LP1" 
35f7 f5				push af  
35f8 3a 0c 36			ld a, (.dmark)  
35fb 32 6e fe			ld (debug_mark),a  
35fe 3a 0d 36			ld a, (.dmark+1)  
3601 32 6f fe			ld (debug_mark+1),a  
3604 3a 0e 36			ld a, (.dmark+2)  
3607 32 70 fe			ld (debug_mark+2),a  
360a 18 03			jr .pastdmark  
360c ..			.dmark: db "LP1"  
360f f1			.pastdmark: pop af  
3610			endm  
# End of macro DMARK
3610						CALLMONITOR 
3610 cd fb 19			call break_point_state  
3613				endm  
# End of macro CALLMONITOR
3613					endif 
3613			 
3613				; go back to previous word 
3613			 
3613 d5				push de    ; save I for inc later 
3614			 
3614			 
3614				; get limit 
3614				;  is I at limit? 
3614			 
3614			 
3614					if DEBUG_FORTH_WORDS 
3614						DMARK "LP1" 
3614 f5				push af  
3615 3a 29 36			ld a, (.dmark)  
3618 32 6e fe			ld (debug_mark),a  
361b 3a 2a 36			ld a, (.dmark+1)  
361e 32 6f fe			ld (debug_mark+1),a  
3621 3a 2b 36			ld a, (.dmark+2)  
3624 32 70 fe			ld (debug_mark+2),a  
3627 18 03			jr .pastdmark  
3629 ..			.dmark: db "LP1"  
362c f1			.pastdmark: pop af  
362d			endm  
# End of macro DMARK
362d						CALLMONITOR 
362d cd fb 19			call break_point_state  
3630				endm  
# End of macro CALLMONITOR
3630					endif 
3630			 
3630 ed 52			sbc hl, de 
3632			 
3632			 
3632				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3632			 
3632 20 26				jr nz, .loopnotdone 
3634			 
3634 e1				pop hl   ; get rid of saved I 
3635				FORTH_LOOP_POP     ; get rid of limit 
3635 cd 30 23			call macro_forth_loop_pop 
3638				endm 
# End of macro FORTH_LOOP_POP
3638			 
3638				FORTH_RSP_POP     ; get rid of DO ptr 
3638 cd 93 20			call macro_forth_rsp_pop 
363b				endm 
# End of macro FORTH_RSP_POP
363b			 
363b			if DEBUG_FORTH_WORDS 
363b						DMARK "LP>" 
363b f5				push af  
363c 3a 50 36			ld a, (.dmark)  
363f 32 6e fe			ld (debug_mark),a  
3642 3a 51 36			ld a, (.dmark+1)  
3645 32 6f fe			ld (debug_mark+1),a  
3648 3a 52 36			ld a, (.dmark+2)  
364b 32 70 fe			ld (debug_mark+2),a  
364e 18 03			jr .pastdmark  
3650 ..			.dmark: db "LP>"  
3653 f1			.pastdmark: pop af  
3654			endm  
# End of macro DMARK
3654				CALLMONITOR 
3654 cd fb 19			call break_point_state  
3657				endm  
# End of macro CALLMONITOR
3657			endif 
3657			 
3657					NEXTW 
3657 c3 78 24			jp macro_next 
365a				endm 
# End of macro NEXTW
365a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
365a			 
365a			.loopnotdone: 
365a			 
365a e1				pop hl    ; get I 
365b 23				inc hl 
365c			 
365c			   	; save new I 
365c			 
365c			 
365c					; set I counter 
365c			 
365c 22 e9 f4				ld (os_current_i), hl 
365f			 
365f					if DEBUG_FORTH_WORDS 
365f						DMARK "LPN" 
365f f5				push af  
3660 3a 74 36			ld a, (.dmark)  
3663 32 6e fe			ld (debug_mark),a  
3666 3a 75 36			ld a, (.dmark+1)  
3669 32 6f fe			ld (debug_mark+1),a  
366c 3a 76 36			ld a, (.dmark+2)  
366f 32 70 fe			ld (debug_mark+2),a  
3672 18 03			jr .pastdmark  
3674 ..			.dmark: db "LPN"  
3677 f1			.pastdmark: pop af  
3678			endm  
# End of macro DMARK
3678					CALLMONITOR 
3678 cd fb 19			call break_point_state  
367b				endm  
# End of macro CALLMONITOR
367b					endif 
367b					 
367b				FORTH_LOOP_NEXT 
367b cd f3 22			call macro_forth_loop_next 
367e				endm 
# End of macro FORTH_LOOP_NEXT
367e			 
367e			 
367e					if DEBUG_FORTH_WORDS 
367e eb						ex de,hl 
367f					endif 
367f			 
367f			;	; get DO ptr 
367f			; 
367f					if DEBUG_FORTH_WORDS 
367f						DMARK "LP7" 
367f f5				push af  
3680 3a 94 36			ld a, (.dmark)  
3683 32 6e fe			ld (debug_mark),a  
3686 3a 95 36			ld a, (.dmark+1)  
3689 32 6f fe			ld (debug_mark+1),a  
368c 3a 96 36			ld a, (.dmark+2)  
368f 32 70 fe			ld (debug_mark+2),a  
3692 18 03			jr .pastdmark  
3694 ..			.dmark: db "LP7"  
3697 f1			.pastdmark: pop af  
3698			endm  
# End of macro DMARK
3698					CALLMONITOR 
3698 cd fb 19			call break_point_state  
369b				endm  
# End of macro CALLMONITOR
369b					endif 
369b				FORTH_RSP_TOS 
369b cd 89 20			call macro_forth_rsp_tos 
369e				endm 
# End of macro FORTH_RSP_TOS
369e			 
369e					if DEBUG_FORTH_WORDS 
369e						DMARK "LP8" 
369e f5				push af  
369f 3a b3 36			ld a, (.dmark)  
36a2 32 6e fe			ld (debug_mark),a  
36a5 3a b4 36			ld a, (.dmark+1)  
36a8 32 6f fe			ld (debug_mark+1),a  
36ab 3a b5 36			ld a, (.dmark+2)  
36ae 32 70 fe			ld (debug_mark+2),a  
36b1 18 03			jr .pastdmark  
36b3 ..			.dmark: db "LP8"  
36b6 f1			.pastdmark: pop af  
36b7			endm  
# End of macro DMARK
36b7					CALLMONITOR 
36b7 cd fb 19			call break_point_state  
36ba				endm  
# End of macro CALLMONITOR
36ba					endif 
36ba				;push hl 
36ba			 
36ba				; not going to DO any more 
36ba				; get rid of the RSP pointer as DO will add it back in 
36ba				;FORTH_RSP_POP 
36ba				;pop hl 
36ba			 
36ba				;ld hl,(cli_ret_sp) 
36ba				;ld e, (hl) 
36ba				;inc hl 
36ba				;ld d, (hl) 
36ba				;ex de,hl 
36ba 22 c5 f4			ld (os_tok_ptr), hl 
36bd					if DEBUG_FORTH_WORDS 
36bd						DMARK "LP<" 
36bd f5				push af  
36be 3a d2 36			ld a, (.dmark)  
36c1 32 6e fe			ld (debug_mark),a  
36c4 3a d3 36			ld a, (.dmark+1)  
36c7 32 6f fe			ld (debug_mark+1),a  
36ca 3a d4 36			ld a, (.dmark+2)  
36cd 32 70 fe			ld (debug_mark+2),a  
36d0 18 03			jr .pastdmark  
36d2 ..			.dmark: db "LP<"  
36d5 f1			.pastdmark: pop af  
36d6			endm  
# End of macro DMARK
36d6					CALLMONITOR 
36d6 cd fb 19			call break_point_state  
36d9				endm  
# End of macro CALLMONITOR
36d9				endif 
36d9 c3 09 25			jp exec1 
36dc			 
36dc					 
36dc			 
36dc			 
36dc					NEXTW 
36dc c3 78 24			jp macro_next 
36df				endm 
# End of macro NEXTW
36df			.I:  
36df			 
36df				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
36df 5e				db WORD_SYS_CORE+74             
36e0 0a 37			dw .DLOOP            
36e2 02				db 1 + 1 
36e3 .. 00			db "I",0              
36e5				endm 
# End of macro CWHEAD
36e5			; | I ( -- ) Current loop counter | DONE 
36e5					if DEBUG_FORTH_WORDS_KEY 
36e5						DMARK "I.." 
36e5 f5				push af  
36e6 3a fa 36			ld a, (.dmark)  
36e9 32 6e fe			ld (debug_mark),a  
36ec 3a fb 36			ld a, (.dmark+1)  
36ef 32 6f fe			ld (debug_mark+1),a  
36f2 3a fc 36			ld a, (.dmark+2)  
36f5 32 70 fe			ld (debug_mark+2),a  
36f8 18 03			jr .pastdmark  
36fa ..			.dmark: db "I.."  
36fd f1			.pastdmark: pop af  
36fe			endm  
# End of macro DMARK
36fe						CALLMONITOR 
36fe cd fb 19			call break_point_state  
3701				endm  
# End of macro CALLMONITOR
3701					endif 
3701			 
3701 2a e9 f4				ld hl,(os_current_i) 
3704 cd cb 20				call forth_push_numhl 
3707			 
3707					NEXTW 
3707 c3 78 24			jp macro_next 
370a				endm 
# End of macro NEXTW
370a			.DLOOP: 
370a				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
370a 5f				db WORD_SYS_CORE+75             
370b eb 37			dw .REPEAT            
370d 06				db 5 + 1 
370e .. 00			db "-LOOP",0              
3714				endm 
# End of macro CWHEAD
3714			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3714				; pop tos as current loop count to hl 
3714					if DEBUG_FORTH_WORDS_KEY 
3714						DMARK "-LP" 
3714 f5				push af  
3715 3a 29 37			ld a, (.dmark)  
3718 32 6e fe			ld (debug_mark),a  
371b 3a 2a 37			ld a, (.dmark+1)  
371e 32 6f fe			ld (debug_mark+1),a  
3721 3a 2b 37			ld a, (.dmark+2)  
3724 32 70 fe			ld (debug_mark+2),a  
3727 18 03			jr .pastdmark  
3729 ..			.dmark: db "-LP"  
372c f1			.pastdmark: pop af  
372d			endm  
# End of macro DMARK
372d						CALLMONITOR 
372d cd fb 19			call break_point_state  
3730				endm  
# End of macro CALLMONITOR
3730					endif 
3730			 
3730				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3730			 
3730				FORTH_LOOP_TOS 
3730 cd 26 23			call macro_forth_loop_tos 
3733				endm 
# End of macro FORTH_LOOP_TOS
3733 e5				push hl 
3734			 
3734					if DEBUG_FORTH_WORDS 
3734						DMARK "-LP" 
3734 f5				push af  
3735 3a 49 37			ld a, (.dmark)  
3738 32 6e fe			ld (debug_mark),a  
373b 3a 4a 37			ld a, (.dmark+1)  
373e 32 6f fe			ld (debug_mark+1),a  
3741 3a 4b 37			ld a, (.dmark+2)  
3744 32 70 fe			ld (debug_mark+2),a  
3747 18 03			jr .pastdmark  
3749 ..			.dmark: db "-LP"  
374c f1			.pastdmark: pop af  
374d			endm  
# End of macro DMARK
374d						CALLMONITOR 
374d cd fb 19			call break_point_state  
3750				endm  
# End of macro CALLMONITOR
3750					endif 
3750				; next item on the stack is the limit. get it 
3750			 
3750			 
3750				FORTH_LOOP_POP 
3750 cd 30 23			call macro_forth_loop_pop 
3753				endm 
# End of macro FORTH_LOOP_POP
3753			 
3753				FORTH_LOOP_TOS 
3753 cd 26 23			call macro_forth_loop_tos 
3756				endm 
# End of macro FORTH_LOOP_TOS
3756			 
3756 d1				pop de		 ; de = i, hl = limit 
3757			 
3757					if DEBUG_FORTH_WORDS 
3757						DMARK "-L1" 
3757 f5				push af  
3758 3a 6c 37			ld a, (.dmark)  
375b 32 6e fe			ld (debug_mark),a  
375e 3a 6d 37			ld a, (.dmark+1)  
3761 32 6f fe			ld (debug_mark+1),a  
3764 3a 6e 37			ld a, (.dmark+2)  
3767 32 70 fe			ld (debug_mark+2),a  
376a 18 03			jr .pastdmark  
376c ..			.dmark: db "-L1"  
376f f1			.pastdmark: pop af  
3770			endm  
# End of macro DMARK
3770						CALLMONITOR 
3770 cd fb 19			call break_point_state  
3773				endm  
# End of macro CALLMONITOR
3773					endif 
3773			 
3773				; go back to previous word 
3773			 
3773 d5				push de    ; save I for inc later 
3774			 
3774			 
3774				; get limit 
3774				;  is I at limit? 
3774			 
3774			 
3774					if DEBUG_FORTH_WORDS 
3774						DMARK "-L1" 
3774 f5				push af  
3775 3a 89 37			ld a, (.dmark)  
3778 32 6e fe			ld (debug_mark),a  
377b 3a 8a 37			ld a, (.dmark+1)  
377e 32 6f fe			ld (debug_mark+1),a  
3781 3a 8b 37			ld a, (.dmark+2)  
3784 32 70 fe			ld (debug_mark+2),a  
3787 18 03			jr .pastdmark  
3789 ..			.dmark: db "-L1"  
378c f1			.pastdmark: pop af  
378d			endm  
# End of macro DMARK
378d						CALLMONITOR 
378d cd fb 19			call break_point_state  
3790				endm  
# End of macro CALLMONITOR
3790					endif 
3790			 
3790 ed 52			sbc hl, de 
3792			 
3792			 
3792				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3792			 
3792 20 26				jr nz, .mloopnotdone 
3794			 
3794 e1				pop hl   ; get rid of saved I 
3795				FORTH_LOOP_POP     ; get rid of limit 
3795 cd 30 23			call macro_forth_loop_pop 
3798				endm 
# End of macro FORTH_LOOP_POP
3798			 
3798				FORTH_RSP_POP     ; get rid of DO ptr 
3798 cd 93 20			call macro_forth_rsp_pop 
379b				endm 
# End of macro FORTH_RSP_POP
379b			 
379b			if DEBUG_FORTH_WORDS 
379b						DMARK "-L>" 
379b f5				push af  
379c 3a b0 37			ld a, (.dmark)  
379f 32 6e fe			ld (debug_mark),a  
37a2 3a b1 37			ld a, (.dmark+1)  
37a5 32 6f fe			ld (debug_mark+1),a  
37a8 3a b2 37			ld a, (.dmark+2)  
37ab 32 70 fe			ld (debug_mark+2),a  
37ae 18 03			jr .pastdmark  
37b0 ..			.dmark: db "-L>"  
37b3 f1			.pastdmark: pop af  
37b4			endm  
# End of macro DMARK
37b4				CALLMONITOR 
37b4 cd fb 19			call break_point_state  
37b7				endm  
# End of macro CALLMONITOR
37b7			endif 
37b7			 
37b7					NEXTW 
37b7 c3 78 24			jp macro_next 
37ba				endm 
# End of macro NEXTW
37ba				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
37ba			 
37ba			.mloopnotdone: 
37ba			 
37ba e1				pop hl    ; get I 
37bb 2b				dec hl 
37bc			 
37bc			   	; save new I 
37bc			 
37bc			 
37bc					; set I counter 
37bc			 
37bc 22 e9 f4				ld (os_current_i), hl 
37bf			 
37bf					 
37bf				FORTH_LOOP_NEXT 
37bf cd f3 22			call macro_forth_loop_next 
37c2				endm 
# End of macro FORTH_LOOP_NEXT
37c2			 
37c2			 
37c2					if DEBUG_FORTH_WORDS 
37c2 eb						ex de,hl 
37c3					endif 
37c3			 
37c3			;	; get DO ptr 
37c3			; 
37c3				FORTH_RSP_TOS 
37c3 cd 89 20			call macro_forth_rsp_tos 
37c6				endm 
# End of macro FORTH_RSP_TOS
37c6			 
37c6				;push hl 
37c6			 
37c6				; not going to DO any more 
37c6				; get rid of the RSP pointer as DO will add it back in 
37c6				;FORTH_RSP_POP 
37c6				;pop hl 
37c6			 
37c6			 
37c6 22 c5 f4			ld (os_tok_ptr), hl 
37c9					if DEBUG_FORTH_WORDS 
37c9						DMARK "-L<" 
37c9 f5				push af  
37ca 3a de 37			ld a, (.dmark)  
37cd 32 6e fe			ld (debug_mark),a  
37d0 3a df 37			ld a, (.dmark+1)  
37d3 32 6f fe			ld (debug_mark+1),a  
37d6 3a e0 37			ld a, (.dmark+2)  
37d9 32 70 fe			ld (debug_mark+2),a  
37dc 18 03			jr .pastdmark  
37de ..			.dmark: db "-L<"  
37e1 f1			.pastdmark: pop af  
37e2			endm  
# End of macro DMARK
37e2					CALLMONITOR 
37e2 cd fb 19			call break_point_state  
37e5				endm  
# End of macro CALLMONITOR
37e5				endif 
37e5 c3 09 25			jp exec1 
37e8			 
37e8					 
37e8			 
37e8			 
37e8			 
37e8				NEXTW 
37e8 c3 78 24			jp macro_next 
37eb				endm 
# End of macro NEXTW
37eb			 
37eb			 
37eb			 
37eb			 
37eb			.REPEAT: 
37eb				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
37eb 71				db WORD_SYS_CORE+93             
37ec 3e 38			dw .UNTIL            
37ee 06				db 5 + 1 
37ef .. 00			db "REPEAT",0              
37f6				endm 
# End of macro CWHEAD
37f6			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
37f6			;  push pc to rsp stack past the REPEAT 
37f6					if DEBUG_FORTH_WORDS_KEY 
37f6						DMARK "REP" 
37f6 f5				push af  
37f7 3a 0b 38			ld a, (.dmark)  
37fa 32 6e fe			ld (debug_mark),a  
37fd 3a 0c 38			ld a, (.dmark+1)  
3800 32 6f fe			ld (debug_mark+1),a  
3803 3a 0d 38			ld a, (.dmark+2)  
3806 32 70 fe			ld (debug_mark+2),a  
3809 18 03			jr .pastdmark  
380b ..			.dmark: db "REP"  
380e f1			.pastdmark: pop af  
380f			endm  
# End of macro DMARK
380f						CALLMONITOR 
380f cd fb 19			call break_point_state  
3812				endm  
# End of macro CALLMONITOR
3812					endif 
3812			 
3812 2a c5 f4				ld hl, (os_tok_ptr) 
3815 23					inc hl   ; R 
3816 23					inc hl  ; E 
3817 23					inc hl   ; P 
3818 23					inc hl   ; E 
3819 23					inc hl   ; A 
381a 23					inc hl   ; T 
381b 23					inc hl   ; zero 
381c					FORTH_RSP_NEXT 
381c cd 72 20			call macro_forth_rsp_next 
381f				endm 
# End of macro FORTH_RSP_NEXT
381f			 
381f			 
381f					if DEBUG_FORTH_WORDS 
381f						DMARK "REP" 
381f f5				push af  
3820 3a 34 38			ld a, (.dmark)  
3823 32 6e fe			ld (debug_mark),a  
3826 3a 35 38			ld a, (.dmark+1)  
3829 32 6f fe			ld (debug_mark+1),a  
382c 3a 36 38			ld a, (.dmark+2)  
382f 32 70 fe			ld (debug_mark+2),a  
3832 18 03			jr .pastdmark  
3834 ..			.dmark: db "REP"  
3837 f1			.pastdmark: pop af  
3838			endm  
# End of macro DMARK
3838						;pop bc    ; TODO BUG ?????? what is this for???? 
3838						CALLMONITOR 
3838 cd fb 19			call break_point_state  
383b				endm  
# End of macro CALLMONITOR
383b					endif 
383b			 
383b					NEXTW 
383b c3 78 24			jp macro_next 
383e				endm 
# End of macro NEXTW
383e			;	       NEXTW 
383e			 
383e			.UNTIL: 
383e				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
383e 72				db WORD_SYS_CORE+94             
383f d5 38			dw .ENDFLOW            
3841 06				db 5 + 1 
3842 .. 00			db "UNTIL",0              
3848				endm 
# End of macro CWHEAD
3848			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3848			 
3848				; pop tos as check 
3848			 
3848				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3848			 
3848				FORTH_DSP_VALUEHL 
3848 cd c2 22			call macro_dsp_valuehl 
384b				endm 
# End of macro FORTH_DSP_VALUEHL
384b			 
384b					if DEBUG_FORTH_WORDS_KEY 
384b						DMARK "UNT" 
384b f5				push af  
384c 3a 60 38			ld a, (.dmark)  
384f 32 6e fe			ld (debug_mark),a  
3852 3a 61 38			ld a, (.dmark+1)  
3855 32 6f fe			ld (debug_mark+1),a  
3858 3a 62 38			ld a, (.dmark+2)  
385b 32 70 fe			ld (debug_mark+2),a  
385e 18 03			jr .pastdmark  
3860 ..			.dmark: db "UNT"  
3863 f1			.pastdmark: pop af  
3864			endm  
# End of macro DMARK
3864						CALLMONITOR 
3864 cd fb 19			call break_point_state  
3867				endm  
# End of macro CALLMONITOR
3867					endif 
3867			 
3867			;	push hl 
3867				FORTH_DSP_POP 
3867 cd 7a 23			call macro_forth_dsp_pop 
386a				endm 
# End of macro FORTH_DSP_POP
386a			 
386a			;	pop hl 
386a			 
386a				; test if true 
386a			 
386a cd af 0f			call ishlzero 
386d			;	ld a,l 
386d			;	add h 
386d			; 
386d			;	cp 0 
386d			 
386d 20 3e			jr nz, .untilnotdone 
386f			 
386f					if DEBUG_FORTH_WORDS 
386f						DMARK "UNf" 
386f f5				push af  
3870 3a 84 38			ld a, (.dmark)  
3873 32 6e fe			ld (debug_mark),a  
3876 3a 85 38			ld a, (.dmark+1)  
3879 32 6f fe			ld (debug_mark+1),a  
387c 3a 86 38			ld a, (.dmark+2)  
387f 32 70 fe			ld (debug_mark+2),a  
3882 18 03			jr .pastdmark  
3884 ..			.dmark: db "UNf"  
3887 f1			.pastdmark: pop af  
3888			endm  
# End of macro DMARK
3888						CALLMONITOR 
3888 cd fb 19			call break_point_state  
388b				endm  
# End of macro CALLMONITOR
388b					endif 
388b			 
388b			 
388b			 
388b				FORTH_RSP_POP     ; get rid of DO ptr 
388b cd 93 20			call macro_forth_rsp_pop 
388e				endm 
# End of macro FORTH_RSP_POP
388e			 
388e			if DEBUG_FORTH_WORDS 
388e						DMARK "UN>" 
388e f5				push af  
388f 3a a3 38			ld a, (.dmark)  
3892 32 6e fe			ld (debug_mark),a  
3895 3a a4 38			ld a, (.dmark+1)  
3898 32 6f fe			ld (debug_mark+1),a  
389b 3a a5 38			ld a, (.dmark+2)  
389e 32 70 fe			ld (debug_mark+2),a  
38a1 18 03			jr .pastdmark  
38a3 ..			.dmark: db "UN>"  
38a6 f1			.pastdmark: pop af  
38a7			endm  
# End of macro DMARK
38a7				CALLMONITOR 
38a7 cd fb 19			call break_point_state  
38aa				endm  
# End of macro CALLMONITOR
38aa			endif 
38aa			 
38aa					NEXTW 
38aa c3 78 24			jp macro_next 
38ad				endm 
# End of macro NEXTW
38ad				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
38ad			 
38ad			.untilnotdone: 
38ad			 
38ad			 
38ad			;	; get DO ptr 
38ad			; 
38ad				FORTH_RSP_TOS 
38ad cd 89 20			call macro_forth_rsp_tos 
38b0				endm 
# End of macro FORTH_RSP_TOS
38b0			 
38b0				;push hl 
38b0			 
38b0				; not going to DO any more 
38b0				; get rid of the RSP pointer as DO will add it back in 
38b0				;FORTH_RSP_POP 
38b0				;pop hl 
38b0			 
38b0			 
38b0 22 c5 f4			ld (os_tok_ptr), hl 
38b3					if DEBUG_FORTH_WORDS 
38b3						DMARK "UN<" 
38b3 f5				push af  
38b4 3a c8 38			ld a, (.dmark)  
38b7 32 6e fe			ld (debug_mark),a  
38ba 3a c9 38			ld a, (.dmark+1)  
38bd 32 6f fe			ld (debug_mark+1),a  
38c0 3a ca 38			ld a, (.dmark+2)  
38c3 32 70 fe			ld (debug_mark+2),a  
38c6 18 03			jr .pastdmark  
38c8 ..			.dmark: db "UN<"  
38cb f1			.pastdmark: pop af  
38cc			endm  
# End of macro DMARK
38cc					CALLMONITOR 
38cc cd fb 19			call break_point_state  
38cf				endm  
# End of macro CALLMONITOR
38cf				endif 
38cf c3 09 25			jp exec1 
38d2			 
38d2					 
38d2			 
38d2			 
38d2					NEXTW 
38d2 c3 78 24			jp macro_next 
38d5				endm 
# End of macro NEXTW
38d5			 
38d5			 
38d5			.ENDFLOW: 
38d5			 
38d5			; eof 
38d5			 
# End of file forth_words_flow.asm
38d5			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
38d5			include "forth_words_logic.asm" 
38d5			 
38d5			; | ## Logic Words 
38d5			 
38d5			.NOT: 
38d5				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
38d5 2d				db WORD_SYS_CORE+25             
38d6 1d 39			dw .IS            
38d8 04				db 3 + 1 
38d9 .. 00			db "NOT",0              
38dd				endm 
# End of macro CWHEAD
38dd			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
38dd					if DEBUG_FORTH_WORDS_KEY 
38dd						DMARK "NOT" 
38dd f5				push af  
38de 3a f2 38			ld a, (.dmark)  
38e1 32 6e fe			ld (debug_mark),a  
38e4 3a f3 38			ld a, (.dmark+1)  
38e7 32 6f fe			ld (debug_mark+1),a  
38ea 3a f4 38			ld a, (.dmark+2)  
38ed 32 70 fe			ld (debug_mark+2),a  
38f0 18 03			jr .pastdmark  
38f2 ..			.dmark: db "NOT"  
38f5 f1			.pastdmark: pop af  
38f6			endm  
# End of macro DMARK
38f6						CALLMONITOR 
38f6 cd fb 19			call break_point_state  
38f9				endm  
# End of macro CALLMONITOR
38f9					endif 
38f9					FORTH_DSP 
38f9 cd 88 22			call macro_forth_dsp 
38fc				endm 
# End of macro FORTH_DSP
38fc 7e					ld a,(hl)	; get type of value on TOS 
38fd fe 02				cp DS_TYPE_INUM  
38ff 28 03				jr z, .noti 
3901					NEXTW 
3901 c3 78 24			jp macro_next 
3904				endm 
# End of macro NEXTW
3904			.noti:          FORTH_DSP_VALUEHL 
3904 cd c2 22			call macro_dsp_valuehl 
3907				endm 
# End of macro FORTH_DSP_VALUEHL
3907			;		push hl 
3907					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3907 cd 7a 23			call macro_forth_dsp_pop 
390a				endm 
# End of macro FORTH_DSP_POP
390a			;		pop hl 
390a 3e 00				ld a,0 
390c bd					cp l 
390d 28 04				jr z, .not2t 
390f 2e 00				ld l, 0 
3911 18 02				jr .notip 
3913			 
3913 2e ff		.not2t:		ld l, 255 
3915			 
3915 26 00		.notip:		ld h, 0	 
3917			 
3917 cd cb 20				call forth_push_numhl 
391a					NEXTW 
391a c3 78 24			jp macro_next 
391d				endm 
# End of macro NEXTW
391d			 
391d			.IS: 
391d				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
391d 2d				db WORD_SYS_CORE+25             
391e 43 39			dw .LZERO            
3920 03				db 2 + 1 
3921 .. 00			db "IS",0              
3924				endm 
# End of macro CWHEAD
3924			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3924					if DEBUG_FORTH_WORDS_KEY 
3924						DMARK "IS." 
3924 f5				push af  
3925 3a 39 39			ld a, (.dmark)  
3928 32 6e fe			ld (debug_mark),a  
392b 3a 3a 39			ld a, (.dmark+1)  
392e 32 6f fe			ld (debug_mark+1),a  
3931 3a 3b 39			ld a, (.dmark+2)  
3934 32 70 fe			ld (debug_mark+2),a  
3937 18 03			jr .pastdmark  
3939 ..			.dmark: db "IS."  
393c f1			.pastdmark: pop af  
393d			endm  
# End of macro DMARK
393d						CALLMONITOR 
393d cd fb 19			call break_point_state  
3940				endm  
# End of macro CALLMONITOR
3940					endif 
3940					NEXTW 
3940 c3 78 24			jp macro_next 
3943				endm 
# End of macro NEXTW
3943			.LZERO: 
3943				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3943 2d				db WORD_SYS_CORE+25             
3944 4d 39			dw .TZERO            
3946 03				db 2 + 1 
3947 .. 00			db "0<",0              
394a				endm 
# End of macro CWHEAD
394a			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
394a					NEXTW 
394a c3 78 24			jp macro_next 
394d				endm 
# End of macro NEXTW
394d			.TZERO: 
394d				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
394d 2e				db WORD_SYS_CORE+26             
394e 94 39			dw .LESS            
3950 03				db 2 + 1 
3951 .. 00			db "0=",0              
3954				endm 
# End of macro CWHEAD
3954			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3954				; TODO add floating point number detection 
3954					;v5 FORTH_DSP_VALUE 
3954					if DEBUG_FORTH_WORDS_KEY 
3954						DMARK "0=." 
3954 f5				push af  
3955 3a 69 39			ld a, (.dmark)  
3958 32 6e fe			ld (debug_mark),a  
395b 3a 6a 39			ld a, (.dmark+1)  
395e 32 6f fe			ld (debug_mark+1),a  
3961 3a 6b 39			ld a, (.dmark+2)  
3964 32 70 fe			ld (debug_mark+2),a  
3967 18 03			jr .pastdmark  
3969 ..			.dmark: db "0=."  
396c f1			.pastdmark: pop af  
396d			endm  
# End of macro DMARK
396d						CALLMONITOR 
396d cd fb 19			call break_point_state  
3970				endm  
# End of macro CALLMONITOR
3970					endif 
3970					FORTH_DSP 
3970 cd 88 22			call macro_forth_dsp 
3973				endm 
# End of macro FORTH_DSP
3973 7e					ld a,(hl)	; get type of value on TOS 
3974 fe 02				cp DS_TYPE_INUM  
3976 28 00				jr z, .tz_inum 
3978			 
3978				if FORTH_ENABLE_FLOATMATH 
3978					jr .tz_done 
3978			 
3978				endif 
3978					 
3978			 
3978			.tz_inum: 
3978					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3978 cd c2 22			call macro_dsp_valuehl 
397b				endm 
# End of macro FORTH_DSP_VALUEHL
397b			 
397b			;		push hl 
397b			 
397b					; destroy value TOS 
397b			 
397b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
397b cd 7a 23			call macro_forth_dsp_pop 
397e				endm 
# End of macro FORTH_DSP_POP
397e			 
397e			;		pop hl 
397e			 
397e 3e 00				ld a,0 
3980			 
3980 bd					cp l 
3981 20 08				jr nz, .tz_notzero 
3983			 
3983 bc					cp h 
3984			 
3984 20 05				jr nz, .tz_notzero 
3986			 
3986			 
3986 21 01 00				ld hl, FORTH_TRUE 
3989 18 03				jr .tz_done 
398b			 
398b 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
398e			 
398e					; push value back onto stack for another op etc 
398e			 
398e			.tz_done: 
398e cd cb 20				call forth_push_numhl 
3991			 
3991					NEXTW 
3991 c3 78 24			jp macro_next 
3994				endm 
# End of macro NEXTW
3994			.LESS: 
3994				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3994 2f				db WORD_SYS_CORE+27             
3995 fd 39			dw .GT            
3997 02				db 1 + 1 
3998 .. 00			db "<",0              
399a				endm 
# End of macro CWHEAD
399a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
399a				; TODO add floating point number detection 
399a					if DEBUG_FORTH_WORDS_KEY 
399a						DMARK "LES" 
399a f5				push af  
399b 3a af 39			ld a, (.dmark)  
399e 32 6e fe			ld (debug_mark),a  
39a1 3a b0 39			ld a, (.dmark+1)  
39a4 32 6f fe			ld (debug_mark+1),a  
39a7 3a b1 39			ld a, (.dmark+2)  
39aa 32 70 fe			ld (debug_mark+2),a  
39ad 18 03			jr .pastdmark  
39af ..			.dmark: db "LES"  
39b2 f1			.pastdmark: pop af  
39b3			endm  
# End of macro DMARK
39b3						CALLMONITOR 
39b3 cd fb 19			call break_point_state  
39b6				endm  
# End of macro CALLMONITOR
39b6					endif 
39b6					FORTH_DSP 
39b6 cd 88 22			call macro_forth_dsp 
39b9				endm 
# End of macro FORTH_DSP
39b9					;v5 FORTH_DSP_VALUE 
39b9 7e					ld a,(hl)	; get type of value on TOS 
39ba fe 02				cp DS_TYPE_INUM  
39bc 28 00				jr z, .less_inum 
39be			 
39be				if FORTH_ENABLE_FLOATMATH 
39be					jr .less_done 
39be			 
39be				endif 
39be					 
39be			 
39be			.less_inum: 
39be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39be cd c2 22			call macro_dsp_valuehl 
39c1				endm 
# End of macro FORTH_DSP_VALUEHL
39c1			 
39c1 e5					push hl  ; u2 
39c2			 
39c2					; destroy value TOS 
39c2			 
39c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c2 cd 7a 23			call macro_forth_dsp_pop 
39c5				endm 
# End of macro FORTH_DSP_POP
39c5			 
39c5			 
39c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39c5 cd c2 22			call macro_dsp_valuehl 
39c8				endm 
# End of macro FORTH_DSP_VALUEHL
39c8			 
39c8 e5					push hl    ; u1 
39c9			 
39c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c9 cd 7a 23			call macro_forth_dsp_pop 
39cc				endm 
# End of macro FORTH_DSP_POP
39cc			 
39cc			 
39cc b7			 or a      ;clear carry flag 
39cd 01 00 00		 ld bc, FORTH_FALSE 
39d0 e1			  pop hl    ; u1 
39d1 d1			  pop de    ; u2 
39d2 ed 52		  sbc hl,de 
39d4 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
39d6			 
39d6 01 01 00		 ld bc, FORTH_TRUE 
39d9			.lscont:  
39d9 c5					push bc 
39da e1					pop hl 
39db			 
39db					if DEBUG_FORTH_WORDS 
39db						DMARK "LT1" 
39db f5				push af  
39dc 3a f0 39			ld a, (.dmark)  
39df 32 6e fe			ld (debug_mark),a  
39e2 3a f1 39			ld a, (.dmark+1)  
39e5 32 6f fe			ld (debug_mark+1),a  
39e8 3a f2 39			ld a, (.dmark+2)  
39eb 32 70 fe			ld (debug_mark+2),a  
39ee 18 03			jr .pastdmark  
39f0 ..			.dmark: db "LT1"  
39f3 f1			.pastdmark: pop af  
39f4			endm  
# End of macro DMARK
39f4						CALLMONITOR 
39f4 cd fb 19			call break_point_state  
39f7				endm  
# End of macro CALLMONITOR
39f7					endif 
39f7 cd cb 20				call forth_push_numhl 
39fa			 
39fa					NEXTW 
39fa c3 78 24			jp macro_next 
39fd				endm 
# End of macro NEXTW
39fd			.GT: 
39fd				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
39fd 30				db WORD_SYS_CORE+28             
39fe 66 3a			dw .EQUAL            
3a00 02				db 1 + 1 
3a01 .. 00			db ">",0              
3a03				endm 
# End of macro CWHEAD
3a03			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3a03				; TODO add floating point number detection 
3a03					if DEBUG_FORTH_WORDS_KEY 
3a03						DMARK "GRT" 
3a03 f5				push af  
3a04 3a 18 3a			ld a, (.dmark)  
3a07 32 6e fe			ld (debug_mark),a  
3a0a 3a 19 3a			ld a, (.dmark+1)  
3a0d 32 6f fe			ld (debug_mark+1),a  
3a10 3a 1a 3a			ld a, (.dmark+2)  
3a13 32 70 fe			ld (debug_mark+2),a  
3a16 18 03			jr .pastdmark  
3a18 ..			.dmark: db "GRT"  
3a1b f1			.pastdmark: pop af  
3a1c			endm  
# End of macro DMARK
3a1c						CALLMONITOR 
3a1c cd fb 19			call break_point_state  
3a1f				endm  
# End of macro CALLMONITOR
3a1f					endif 
3a1f					FORTH_DSP 
3a1f cd 88 22			call macro_forth_dsp 
3a22				endm 
# End of macro FORTH_DSP
3a22					;FORTH_DSP_VALUE 
3a22 7e					ld a,(hl)	; get type of value on TOS 
3a23 fe 02				cp DS_TYPE_INUM  
3a25 28 00				jr z, .gt_inum 
3a27			 
3a27				if FORTH_ENABLE_FLOATMATH 
3a27					jr .gt_done 
3a27			 
3a27				endif 
3a27					 
3a27			 
3a27			.gt_inum: 
3a27					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a27 cd c2 22			call macro_dsp_valuehl 
3a2a				endm 
# End of macro FORTH_DSP_VALUEHL
3a2a			 
3a2a e5					push hl  ; u2 
3a2b			 
3a2b					; destroy value TOS 
3a2b			 
3a2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a2b cd 7a 23			call macro_forth_dsp_pop 
3a2e				endm 
# End of macro FORTH_DSP_POP
3a2e			 
3a2e			 
3a2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a2e cd c2 22			call macro_dsp_valuehl 
3a31				endm 
# End of macro FORTH_DSP_VALUEHL
3a31			 
3a31 e5					push hl    ; u1 
3a32			 
3a32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a32 cd 7a 23			call macro_forth_dsp_pop 
3a35				endm 
# End of macro FORTH_DSP_POP
3a35			 
3a35			 
3a35 b7			 or a      ;clear carry flag 
3a36 01 00 00		 ld bc, FORTH_FALSE 
3a39 e1			  pop hl    ; u1 
3a3a d1			  pop de    ; u2 
3a3b ed 52		  sbc hl,de 
3a3d 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3a3f			 
3a3f 01 01 00		 ld bc, FORTH_TRUE 
3a42			.gtcont:  
3a42 c5					push bc 
3a43 e1					pop hl 
3a44			 
3a44					if DEBUG_FORTH_WORDS 
3a44						DMARK "GT1" 
3a44 f5				push af  
3a45 3a 59 3a			ld a, (.dmark)  
3a48 32 6e fe			ld (debug_mark),a  
3a4b 3a 5a 3a			ld a, (.dmark+1)  
3a4e 32 6f fe			ld (debug_mark+1),a  
3a51 3a 5b 3a			ld a, (.dmark+2)  
3a54 32 70 fe			ld (debug_mark+2),a  
3a57 18 03			jr .pastdmark  
3a59 ..			.dmark: db "GT1"  
3a5c f1			.pastdmark: pop af  
3a5d			endm  
# End of macro DMARK
3a5d						CALLMONITOR 
3a5d cd fb 19			call break_point_state  
3a60				endm  
# End of macro CALLMONITOR
3a60					endif 
3a60 cd cb 20				call forth_push_numhl 
3a63			 
3a63					NEXTW 
3a63 c3 78 24			jp macro_next 
3a66				endm 
# End of macro NEXTW
3a66			.EQUAL: 
3a66				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3a66 31				db WORD_SYS_CORE+29             
3a67 d1 3a			dw .ENDLOGIC            
3a69 02				db 1 + 1 
3a6a .. 00			db "=",0              
3a6c				endm 
# End of macro CWHEAD
3a6c			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3a6c				; TODO add floating point number detection 
3a6c					if DEBUG_FORTH_WORDS_KEY 
3a6c						DMARK "EQ." 
3a6c f5				push af  
3a6d 3a 81 3a			ld a, (.dmark)  
3a70 32 6e fe			ld (debug_mark),a  
3a73 3a 82 3a			ld a, (.dmark+1)  
3a76 32 6f fe			ld (debug_mark+1),a  
3a79 3a 83 3a			ld a, (.dmark+2)  
3a7c 32 70 fe			ld (debug_mark+2),a  
3a7f 18 03			jr .pastdmark  
3a81 ..			.dmark: db "EQ."  
3a84 f1			.pastdmark: pop af  
3a85			endm  
# End of macro DMARK
3a85						CALLMONITOR 
3a85 cd fb 19			call break_point_state  
3a88				endm  
# End of macro CALLMONITOR
3a88					endif 
3a88					FORTH_DSP 
3a88 cd 88 22			call macro_forth_dsp 
3a8b				endm 
# End of macro FORTH_DSP
3a8b					;v5 FORTH_DSP_VALUE 
3a8b 7e					ld a,(hl)	; get type of value on TOS 
3a8c fe 02				cp DS_TYPE_INUM  
3a8e 28 00				jr z, .eq_inum 
3a90			 
3a90				if FORTH_ENABLE_FLOATMATH 
3a90					jr .eq_done 
3a90			 
3a90				endif 
3a90					 
3a90			 
3a90			.eq_inum: 
3a90					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a90 cd c2 22			call macro_dsp_valuehl 
3a93				endm 
# End of macro FORTH_DSP_VALUEHL
3a93			 
3a93 e5					push hl 
3a94			 
3a94					; destroy value TOS 
3a94			 
3a94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a94 cd 7a 23			call macro_forth_dsp_pop 
3a97				endm 
# End of macro FORTH_DSP_POP
3a97			 
3a97			 
3a97					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a97 cd c2 22			call macro_dsp_valuehl 
3a9a				endm 
# End of macro FORTH_DSP_VALUEHL
3a9a			 
3a9a					; one value on hl get other one back 
3a9a			 
3a9a e5					push hl 
3a9b			 
3a9b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a9b cd 7a 23			call macro_forth_dsp_pop 
3a9e				endm 
# End of macro FORTH_DSP_POP
3a9e			 
3a9e 0e 00				ld c, FORTH_FALSE 
3aa0			 
3aa0 e1					pop hl 
3aa1 d1					pop de 
3aa2			 
3aa2 7b					ld a, e 
3aa3 bd					cp l 
3aa4			 
3aa4 20 06				jr nz, .eq_done 
3aa6			 
3aa6 7a					ld a, d 
3aa7 bc					cp h 
3aa8			 
3aa8 20 02				jr nz, .eq_done 
3aaa			 
3aaa 0e 01				ld c, FORTH_TRUE 
3aac					 
3aac			 
3aac			 
3aac			.eq_done: 
3aac			 
3aac					; TODO push value back onto stack for another op etc 
3aac			 
3aac 26 00				ld h, 0 
3aae 69					ld l, c 
3aaf					if DEBUG_FORTH_WORDS 
3aaf						DMARK "EQ1" 
3aaf f5				push af  
3ab0 3a c4 3a			ld a, (.dmark)  
3ab3 32 6e fe			ld (debug_mark),a  
3ab6 3a c5 3a			ld a, (.dmark+1)  
3ab9 32 6f fe			ld (debug_mark+1),a  
3abc 3a c6 3a			ld a, (.dmark+2)  
3abf 32 70 fe			ld (debug_mark+2),a  
3ac2 18 03			jr .pastdmark  
3ac4 ..			.dmark: db "EQ1"  
3ac7 f1			.pastdmark: pop af  
3ac8			endm  
# End of macro DMARK
3ac8						CALLMONITOR 
3ac8 cd fb 19			call break_point_state  
3acb				endm  
# End of macro CALLMONITOR
3acb					endif 
3acb cd cb 20				call forth_push_numhl 
3ace			 
3ace					NEXTW 
3ace c3 78 24			jp macro_next 
3ad1				endm 
# End of macro NEXTW
3ad1			 
3ad1			 
3ad1			.ENDLOGIC: 
3ad1			; eof 
3ad1			 
3ad1			 
# End of file forth_words_logic.asm
3ad1			include "forth_words_maths.asm" 
3ad1			 
3ad1			; | ## Maths Words 
3ad1			 
3ad1			.PLUS:	 
3ad1				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3ad1 15				db WORD_SYS_CORE+1             
3ad2 2f 3b			dw .NEG            
3ad4 02				db 1 + 1 
3ad5 .. 00			db "+",0              
3ad7				endm 
# End of macro CWHEAD
3ad7			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3ad7					if DEBUG_FORTH_WORDS_KEY 
3ad7						DMARK "PLU" 
3ad7 f5				push af  
3ad8 3a ec 3a			ld a, (.dmark)  
3adb 32 6e fe			ld (debug_mark),a  
3ade 3a ed 3a			ld a, (.dmark+1)  
3ae1 32 6f fe			ld (debug_mark+1),a  
3ae4 3a ee 3a			ld a, (.dmark+2)  
3ae7 32 70 fe			ld (debug_mark+2),a  
3aea 18 03			jr .pastdmark  
3aec ..			.dmark: db "PLU"  
3aef f1			.pastdmark: pop af  
3af0			endm  
# End of macro DMARK
3af0						CALLMONITOR 
3af0 cd fb 19			call break_point_state  
3af3				endm  
# End of macro CALLMONITOR
3af3					endif 
3af3					; add top two values and push back result 
3af3			 
3af3					;for v5 FORTH_DSP_VALUE 
3af3					FORTH_DSP 
3af3 cd 88 22			call macro_forth_dsp 
3af6				endm 
# End of macro FORTH_DSP
3af6 7e					ld a,(hl)	; get type of value on TOS 
3af7 fe 02				cp DS_TYPE_INUM  
3af9 28 03				jr z, .dot_inum 
3afb			 
3afb					NEXTW 
3afb c3 78 24			jp macro_next 
3afe				endm 
# End of macro NEXTW
3afe			 
3afe			; float maths 
3afe			 
3afe				if FORTH_ENABLE_FLOATMATH 
3afe						inc hl      ; now at start of numeric as string 
3afe			 
3afe					if DEBUG_FORTH_MATHS 
3afe						DMARK "ADD" 
3afe				CALLMONITOR 
3afe					endif 
3afe			 
3afe					;ld ix, hl 
3afe					call CON 
3afe			 
3afe			 
3afe					push hl 
3afe					 
3afe					 
3afe			 
3afe						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3afe			 
3afe					; get next number 
3afe			 
3afe						FORTH_DSP_VALUE 
3afe			 
3afe						inc hl      ; now at start of numeric as string 
3afe			 
3afe					;ld ix, hl 
3afe					call CON 
3afe			 
3afe					push hl 
3afe			 
3afe			 
3afe						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3afe			 
3afe						; TODO do add 
3afe			 
3afe						call IADD 
3afe			 
3afe						; TODO get result back as ascii 
3afe			 
3afe						; TODO push result  
3afe			 
3afe			 
3afe			 
3afe						jr .dot_done 
3afe				endif 
3afe			 
3afe			.dot_inum: 
3afe			 
3afe			 
3afe					if DEBUG_FORTH_DOT 
3afe						DMARK "+IT" 
3afe f5				push af  
3aff 3a 13 3b			ld a, (.dmark)  
3b02 32 6e fe			ld (debug_mark),a  
3b05 3a 14 3b			ld a, (.dmark+1)  
3b08 32 6f fe			ld (debug_mark+1),a  
3b0b 3a 15 3b			ld a, (.dmark+2)  
3b0e 32 70 fe			ld (debug_mark+2),a  
3b11 18 03			jr .pastdmark  
3b13 ..			.dmark: db "+IT"  
3b16 f1			.pastdmark: pop af  
3b17			endm  
# End of macro DMARK
3b17				CALLMONITOR 
3b17 cd fb 19			call break_point_state  
3b1a				endm  
# End of macro CALLMONITOR
3b1a					endif 
3b1a			 
3b1a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b1a cd c2 22			call macro_dsp_valuehl 
3b1d				endm 
# End of macro FORTH_DSP_VALUEHL
3b1d			 
3b1d				; TODO add floating point number detection 
3b1d			 
3b1d e5					push hl 
3b1e			 
3b1e					; destroy value TOS 
3b1e			 
3b1e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b1e cd 7a 23			call macro_forth_dsp_pop 
3b21				endm 
# End of macro FORTH_DSP_POP
3b21			 
3b21			 
3b21					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b21 cd c2 22			call macro_dsp_valuehl 
3b24				endm 
# End of macro FORTH_DSP_VALUEHL
3b24			 
3b24					; one value on hl get other one back 
3b24			 
3b24 d1					pop de 
3b25			 
3b25					; do the add 
3b25			 
3b25 19					add hl,de 
3b26			 
3b26					; save it 
3b26			 
3b26			;		push hl	 
3b26			 
3b26					; 
3b26			 
3b26					; destroy value TOS 
3b26			 
3b26					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b26 cd 7a 23			call macro_forth_dsp_pop 
3b29				endm 
# End of macro FORTH_DSP_POP
3b29			 
3b29					; TODO push value back onto stack for another op etc 
3b29			 
3b29			;		pop hl 
3b29			 
3b29			.dot_done: 
3b29 cd cb 20				call forth_push_numhl 
3b2c			 
3b2c					NEXTW 
3b2c c3 78 24			jp macro_next 
3b2f				endm 
# End of macro NEXTW
3b2f			.NEG: 
3b2f			 
3b2f				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3b2f 17				db WORD_SYS_CORE+3             
3b30 72 3b			dw .DIV            
3b32 02				db 1 + 1 
3b33 .. 00			db "-",0              
3b35				endm 
# End of macro CWHEAD
3b35			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3b35					if DEBUG_FORTH_WORDS_KEY 
3b35						DMARK "SUB" 
3b35 f5				push af  
3b36 3a 4a 3b			ld a, (.dmark)  
3b39 32 6e fe			ld (debug_mark),a  
3b3c 3a 4b 3b			ld a, (.dmark+1)  
3b3f 32 6f fe			ld (debug_mark+1),a  
3b42 3a 4c 3b			ld a, (.dmark+2)  
3b45 32 70 fe			ld (debug_mark+2),a  
3b48 18 03			jr .pastdmark  
3b4a ..			.dmark: db "SUB"  
3b4d f1			.pastdmark: pop af  
3b4e			endm  
# End of macro DMARK
3b4e						CALLMONITOR 
3b4e cd fb 19			call break_point_state  
3b51				endm  
# End of macro CALLMONITOR
3b51					endif 
3b51			 
3b51			 
3b51				; TODO add floating point number detection 
3b51					; v5 FORTH_DSP_VALUE 
3b51					FORTH_DSP 
3b51 cd 88 22			call macro_forth_dsp 
3b54				endm 
# End of macro FORTH_DSP
3b54 7e					ld a,(hl)	; get type of value on TOS 
3b55 fe 02				cp DS_TYPE_INUM  
3b57 28 03				jr z, .neg_inum 
3b59			 
3b59					NEXTW 
3b59 c3 78 24			jp macro_next 
3b5c				endm 
# End of macro NEXTW
3b5c			 
3b5c			; float maths 
3b5c			 
3b5c				if FORTH_ENABLE_FLOATMATH 
3b5c					jr .neg_done 
3b5c			 
3b5c				endif 
3b5c					 
3b5c			 
3b5c			.neg_inum: 
3b5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b5c cd c2 22			call macro_dsp_valuehl 
3b5f				endm 
# End of macro FORTH_DSP_VALUEHL
3b5f			 
3b5f e5					push hl 
3b60			 
3b60					; destroy value TOS 
3b60			 
3b60					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b60 cd 7a 23			call macro_forth_dsp_pop 
3b63				endm 
# End of macro FORTH_DSP_POP
3b63			 
3b63			 
3b63					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b63 cd c2 22			call macro_dsp_valuehl 
3b66				endm 
# End of macro FORTH_DSP_VALUEHL
3b66			 
3b66					; one value on hl get other one back 
3b66			 
3b66 d1					pop de 
3b67			 
3b67					; do the sub 
3b67			;		ex de, hl 
3b67			 
3b67 ed 52				sbc hl,de 
3b69			 
3b69					; save it 
3b69			 
3b69			;		push hl	 
3b69			 
3b69					; 
3b69			 
3b69					; destroy value TOS 
3b69			 
3b69					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b69 cd 7a 23			call macro_forth_dsp_pop 
3b6c				endm 
# End of macro FORTH_DSP_POP
3b6c			 
3b6c					; TODO push value back onto stack for another op etc 
3b6c			 
3b6c			;		pop hl 
3b6c			 
3b6c cd cb 20				call forth_push_numhl 
3b6f			.neg_done: 
3b6f			 
3b6f					NEXTW 
3b6f c3 78 24			jp macro_next 
3b72				endm 
# End of macro NEXTW
3b72			.DIV: 
3b72				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3b72 18				db WORD_SYS_CORE+4             
3b73 bf 3b			dw .MUL            
3b75 02				db 1 + 1 
3b76 .. 00			db "/",0              
3b78				endm 
# End of macro CWHEAD
3b78			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3b78					if DEBUG_FORTH_WORDS_KEY 
3b78						DMARK "DIV" 
3b78 f5				push af  
3b79 3a 8d 3b			ld a, (.dmark)  
3b7c 32 6e fe			ld (debug_mark),a  
3b7f 3a 8e 3b			ld a, (.dmark+1)  
3b82 32 6f fe			ld (debug_mark+1),a  
3b85 3a 8f 3b			ld a, (.dmark+2)  
3b88 32 70 fe			ld (debug_mark+2),a  
3b8b 18 03			jr .pastdmark  
3b8d ..			.dmark: db "DIV"  
3b90 f1			.pastdmark: pop af  
3b91			endm  
# End of macro DMARK
3b91						CALLMONITOR 
3b91 cd fb 19			call break_point_state  
3b94				endm  
# End of macro CALLMONITOR
3b94					endif 
3b94				; TODO add floating point number detection 
3b94					; v5 FORTH_DSP_VALUE 
3b94					FORTH_DSP 
3b94 cd 88 22			call macro_forth_dsp 
3b97				endm 
# End of macro FORTH_DSP
3b97 7e					ld a,(hl)	; get type of value on TOS 
3b98 fe 02				cp DS_TYPE_INUM  
3b9a 28 03				jr z, .div_inum 
3b9c			 
3b9c				if FORTH_ENABLE_FLOATMATH 
3b9c					jr .div_done 
3b9c			 
3b9c				endif 
3b9c					NEXTW 
3b9c c3 78 24			jp macro_next 
3b9f				endm 
# End of macro NEXTW
3b9f			.div_inum: 
3b9f			 
3b9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b9f cd c2 22			call macro_dsp_valuehl 
3ba2				endm 
# End of macro FORTH_DSP_VALUEHL
3ba2			 
3ba2 e5					push hl    ; to go to bc 
3ba3			 
3ba3					; destroy value TOS 
3ba3			 
3ba3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ba3 cd 7a 23			call macro_forth_dsp_pop 
3ba6				endm 
# End of macro FORTH_DSP_POP
3ba6			 
3ba6			 
3ba6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ba6 cd c2 22			call macro_dsp_valuehl 
3ba9				endm 
# End of macro FORTH_DSP_VALUEHL
3ba9			 
3ba9					; hl to go to de 
3ba9			 
3ba9 e5					push hl 
3baa			 
3baa c1					pop bc 
3bab d1					pop de		 
3bac			 
3bac			 
3bac					if DEBUG_FORTH_MATHS 
3bac						DMARK "DIV" 
3bac				CALLMONITOR 
3bac					endif 
3bac					; one value on hl but move to a get other one back 
3bac			 
3bac			        
3bac cd e3 0e			call Div16 
3baf			 
3baf			;	push af	 
3baf e5				push hl 
3bb0 c5				push bc 
3bb1			 
3bb1					if DEBUG_FORTH_MATHS 
3bb1						DMARK "DI1" 
3bb1				CALLMONITOR 
3bb1					endif 
3bb1			 
3bb1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bb1 cd 7a 23			call macro_forth_dsp_pop 
3bb4				endm 
# End of macro FORTH_DSP_POP
3bb4			 
3bb4			 
3bb4			 
3bb4 e1					pop hl    ; result 
3bb5			 
3bb5 cd cb 20				call forth_push_numhl 
3bb8			 
3bb8 e1					pop hl    ; reminder 
3bb9			;		ld h,0 
3bb9			;		ld l,d 
3bb9			 
3bb9 cd cb 20				call forth_push_numhl 
3bbc			.div_done: 
3bbc					NEXTW 
3bbc c3 78 24			jp macro_next 
3bbf				endm 
# End of macro NEXTW
3bbf			.MUL: 
3bbf				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3bbf 19				db WORD_SYS_CORE+5             
3bc0 04 3c			dw .MIN            
3bc2 02				db 1 + 1 
3bc3 .. 00			db "*",0              
3bc5				endm 
# End of macro CWHEAD
3bc5			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3bc5				; TODO add floating point number detection 
3bc5					if DEBUG_FORTH_WORDS_KEY 
3bc5						DMARK "MUL" 
3bc5 f5				push af  
3bc6 3a da 3b			ld a, (.dmark)  
3bc9 32 6e fe			ld (debug_mark),a  
3bcc 3a db 3b			ld a, (.dmark+1)  
3bcf 32 6f fe			ld (debug_mark+1),a  
3bd2 3a dc 3b			ld a, (.dmark+2)  
3bd5 32 70 fe			ld (debug_mark+2),a  
3bd8 18 03			jr .pastdmark  
3bda ..			.dmark: db "MUL"  
3bdd f1			.pastdmark: pop af  
3bde			endm  
# End of macro DMARK
3bde						CALLMONITOR 
3bde cd fb 19			call break_point_state  
3be1				endm  
# End of macro CALLMONITOR
3be1					endif 
3be1					FORTH_DSP 
3be1 cd 88 22			call macro_forth_dsp 
3be4				endm 
# End of macro FORTH_DSP
3be4					; v5 FORTH_DSP_VALUE 
3be4 7e					ld a,(hl)	; get type of value on TOS 
3be5 fe 02				cp DS_TYPE_INUM  
3be7 28 03				jr z, .mul_inum 
3be9			 
3be9				if FORTH_ENABLE_FLOATMATH 
3be9					jr .mul_done 
3be9			 
3be9				endif 
3be9			 
3be9					NEXTW 
3be9 c3 78 24			jp macro_next 
3bec				endm 
# End of macro NEXTW
3bec			.mul_inum:	 
3bec			 
3bec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bec cd c2 22			call macro_dsp_valuehl 
3bef				endm 
# End of macro FORTH_DSP_VALUEHL
3bef			 
3bef e5					push hl 
3bf0			 
3bf0					; destroy value TOS 
3bf0			 
3bf0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bf0 cd 7a 23			call macro_forth_dsp_pop 
3bf3				endm 
# End of macro FORTH_DSP_POP
3bf3			 
3bf3			 
3bf3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bf3 cd c2 22			call macro_dsp_valuehl 
3bf6				endm 
# End of macro FORTH_DSP_VALUEHL
3bf6			 
3bf6					; one value on hl but move to a get other one back 
3bf6			 
3bf6 7d					ld a, l 
3bf7			 
3bf7 d1					pop de 
3bf8			 
3bf8					; do the mull 
3bf8			;		ex de, hl 
3bf8			 
3bf8 cd 09 0f				call Mult16 
3bfb					; save it 
3bfb			 
3bfb			;		push hl	 
3bfb			 
3bfb					; 
3bfb			 
3bfb					; destroy value TOS 
3bfb			 
3bfb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bfb cd 7a 23			call macro_forth_dsp_pop 
3bfe				endm 
# End of macro FORTH_DSP_POP
3bfe			 
3bfe					; TODO push value back onto stack for another op etc 
3bfe			 
3bfe			;		pop hl 
3bfe			 
3bfe cd cb 20				call forth_push_numhl 
3c01			 
3c01			.mul_done: 
3c01					NEXTW 
3c01 c3 78 24			jp macro_next 
3c04				endm 
# End of macro NEXTW
3c04			 
3c04			 
3c04			 
3c04			 
3c04			.MIN: 
3c04				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3c04 49				db WORD_SYS_CORE+53             
3c05 85 3c			dw .MAX            
3c07 04				db 3 + 1 
3c08 .. 00			db "MIN",0              
3c0c				endm 
# End of macro CWHEAD
3c0c			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3c0c					if DEBUG_FORTH_WORDS_KEY 
3c0c						DMARK "MIN" 
3c0c f5				push af  
3c0d 3a 21 3c			ld a, (.dmark)  
3c10 32 6e fe			ld (debug_mark),a  
3c13 3a 22 3c			ld a, (.dmark+1)  
3c16 32 6f fe			ld (debug_mark+1),a  
3c19 3a 23 3c			ld a, (.dmark+2)  
3c1c 32 70 fe			ld (debug_mark+2),a  
3c1f 18 03			jr .pastdmark  
3c21 ..			.dmark: db "MIN"  
3c24 f1			.pastdmark: pop af  
3c25			endm  
# End of macro DMARK
3c25						CALLMONITOR 
3c25 cd fb 19			call break_point_state  
3c28				endm  
# End of macro CALLMONITOR
3c28					endif 
3c28					; get u2 
3c28			 
3c28					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c28 cd c2 22			call macro_dsp_valuehl 
3c2b				endm 
# End of macro FORTH_DSP_VALUEHL
3c2b			 
3c2b e5					push hl   ; u2 
3c2c			 
3c2c					; destroy value TOS 
3c2c			 
3c2c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c2c cd 7a 23			call macro_forth_dsp_pop 
3c2f				endm 
# End of macro FORTH_DSP_POP
3c2f			 
3c2f					; get u1 
3c2f			 
3c2f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c2f cd c2 22			call macro_dsp_valuehl 
3c32				endm 
# End of macro FORTH_DSP_VALUEHL
3c32			 
3c32 e5					push hl  ; u1 
3c33			 
3c33					; destroy value TOS 
3c33			 
3c33					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c33 cd 7a 23			call macro_forth_dsp_pop 
3c36				endm 
# End of macro FORTH_DSP_POP
3c36			 
3c36 b7			 or a      ;clear carry flag 
3c37 e1			  pop hl    ; u1 
3c38 d1			  pop de    ; u2 
3c39 e5				push hl   ; saved in case hl is lowest 
3c3a ed 52		  sbc hl,de 
3c3c 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3c3e			 
3c3e e1				pop hl 
3c3f					if DEBUG_FORTH_WORDS 
3c3f						DMARK "MIN" 
3c3f f5				push af  
3c40 3a 54 3c			ld a, (.dmark)  
3c43 32 6e fe			ld (debug_mark),a  
3c46 3a 55 3c			ld a, (.dmark+1)  
3c49 32 6f fe			ld (debug_mark+1),a  
3c4c 3a 56 3c			ld a, (.dmark+2)  
3c4f 32 70 fe			ld (debug_mark+2),a  
3c52 18 03			jr .pastdmark  
3c54 ..			.dmark: db "MIN"  
3c57 f1			.pastdmark: pop af  
3c58			endm  
# End of macro DMARK
3c58						CALLMONITOR 
3c58 cd fb 19			call break_point_state  
3c5b				endm  
# End of macro CALLMONITOR
3c5b					endif 
3c5b cd cb 20				call forth_push_numhl 
3c5e			 
3c5e				       NEXTW 
3c5e c3 78 24			jp macro_next 
3c61				endm 
# End of macro NEXTW
3c61			 
3c61			.mincont:  
3c61 c1				pop bc   ; tidy up 
3c62 eb				ex de , hl  
3c63					if DEBUG_FORTH_WORDS 
3c63						DMARK "MI1" 
3c63 f5				push af  
3c64 3a 78 3c			ld a, (.dmark)  
3c67 32 6e fe			ld (debug_mark),a  
3c6a 3a 79 3c			ld a, (.dmark+1)  
3c6d 32 6f fe			ld (debug_mark+1),a  
3c70 3a 7a 3c			ld a, (.dmark+2)  
3c73 32 70 fe			ld (debug_mark+2),a  
3c76 18 03			jr .pastdmark  
3c78 ..			.dmark: db "MI1"  
3c7b f1			.pastdmark: pop af  
3c7c			endm  
# End of macro DMARK
3c7c						CALLMONITOR 
3c7c cd fb 19			call break_point_state  
3c7f				endm  
# End of macro CALLMONITOR
3c7f					endif 
3c7f cd cb 20				call forth_push_numhl 
3c82			 
3c82				       NEXTW 
3c82 c3 78 24			jp macro_next 
3c85				endm 
# End of macro NEXTW
3c85			.MAX: 
3c85				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3c85 4a				db WORD_SYS_CORE+54             
3c86 06 3d			dw .RND16            
3c88 04				db 3 + 1 
3c89 .. 00			db "MAX",0              
3c8d				endm 
# End of macro CWHEAD
3c8d			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3c8d					if DEBUG_FORTH_WORDS_KEY 
3c8d						DMARK "MAX" 
3c8d f5				push af  
3c8e 3a a2 3c			ld a, (.dmark)  
3c91 32 6e fe			ld (debug_mark),a  
3c94 3a a3 3c			ld a, (.dmark+1)  
3c97 32 6f fe			ld (debug_mark+1),a  
3c9a 3a a4 3c			ld a, (.dmark+2)  
3c9d 32 70 fe			ld (debug_mark+2),a  
3ca0 18 03			jr .pastdmark  
3ca2 ..			.dmark: db "MAX"  
3ca5 f1			.pastdmark: pop af  
3ca6			endm  
# End of macro DMARK
3ca6						CALLMONITOR 
3ca6 cd fb 19			call break_point_state  
3ca9				endm  
# End of macro CALLMONITOR
3ca9					endif 
3ca9					; get u2 
3ca9			 
3ca9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ca9 cd c2 22			call macro_dsp_valuehl 
3cac				endm 
# End of macro FORTH_DSP_VALUEHL
3cac			 
3cac e5					push hl   ; u2 
3cad			 
3cad					; destroy value TOS 
3cad			 
3cad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cad cd 7a 23			call macro_forth_dsp_pop 
3cb0				endm 
# End of macro FORTH_DSP_POP
3cb0			 
3cb0					; get u1 
3cb0			 
3cb0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cb0 cd c2 22			call macro_dsp_valuehl 
3cb3				endm 
# End of macro FORTH_DSP_VALUEHL
3cb3			 
3cb3 e5					push hl  ; u1 
3cb4			 
3cb4					; destroy value TOS 
3cb4			 
3cb4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cb4 cd 7a 23			call macro_forth_dsp_pop 
3cb7				endm 
# End of macro FORTH_DSP_POP
3cb7			 
3cb7 b7			 or a      ;clear carry flag 
3cb8 e1			  pop hl    ; u1 
3cb9 d1			  pop de    ; u2 
3cba e5				push hl   ; saved in case hl is lowest 
3cbb ed 52		  sbc hl,de 
3cbd 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3cbf			 
3cbf e1				pop hl 
3cc0					if DEBUG_FORTH_WORDS 
3cc0						DMARK "MAX" 
3cc0 f5				push af  
3cc1 3a d5 3c			ld a, (.dmark)  
3cc4 32 6e fe			ld (debug_mark),a  
3cc7 3a d6 3c			ld a, (.dmark+1)  
3cca 32 6f fe			ld (debug_mark+1),a  
3ccd 3a d7 3c			ld a, (.dmark+2)  
3cd0 32 70 fe			ld (debug_mark+2),a  
3cd3 18 03			jr .pastdmark  
3cd5 ..			.dmark: db "MAX"  
3cd8 f1			.pastdmark: pop af  
3cd9			endm  
# End of macro DMARK
3cd9						CALLMONITOR 
3cd9 cd fb 19			call break_point_state  
3cdc				endm  
# End of macro CALLMONITOR
3cdc					endif 
3cdc cd cb 20				call forth_push_numhl 
3cdf			 
3cdf				       NEXTW 
3cdf c3 78 24			jp macro_next 
3ce2				endm 
# End of macro NEXTW
3ce2			 
3ce2			.maxcont:  
3ce2 c1				pop bc   ; tidy up 
3ce3 eb				ex de , hl  
3ce4					if DEBUG_FORTH_WORDS 
3ce4						DMARK "MA1" 
3ce4 f5				push af  
3ce5 3a f9 3c			ld a, (.dmark)  
3ce8 32 6e fe			ld (debug_mark),a  
3ceb 3a fa 3c			ld a, (.dmark+1)  
3cee 32 6f fe			ld (debug_mark+1),a  
3cf1 3a fb 3c			ld a, (.dmark+2)  
3cf4 32 70 fe			ld (debug_mark+2),a  
3cf7 18 03			jr .pastdmark  
3cf9 ..			.dmark: db "MA1"  
3cfc f1			.pastdmark: pop af  
3cfd			endm  
# End of macro DMARK
3cfd						CALLMONITOR 
3cfd cd fb 19			call break_point_state  
3d00				endm  
# End of macro CALLMONITOR
3d00					endif 
3d00 cd cb 20				call forth_push_numhl 
3d03				       NEXTW 
3d03 c3 78 24			jp macro_next 
3d06				endm 
# End of macro NEXTW
3d06			 
3d06			.RND16: 
3d06				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3d06 4e				db WORD_SYS_CORE+58             
3d07 35 3d			dw .RND8            
3d09 06				db 5 + 1 
3d0a .. 00			db "RND16",0              
3d10				endm 
# End of macro CWHEAD
3d10			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3d10					if DEBUG_FORTH_WORDS_KEY 
3d10						DMARK "R16" 
3d10 f5				push af  
3d11 3a 25 3d			ld a, (.dmark)  
3d14 32 6e fe			ld (debug_mark),a  
3d17 3a 26 3d			ld a, (.dmark+1)  
3d1a 32 6f fe			ld (debug_mark+1),a  
3d1d 3a 27 3d			ld a, (.dmark+2)  
3d20 32 70 fe			ld (debug_mark+2),a  
3d23 18 03			jr .pastdmark  
3d25 ..			.dmark: db "R16"  
3d28 f1			.pastdmark: pop af  
3d29			endm  
# End of macro DMARK
3d29						CALLMONITOR 
3d29 cd fb 19			call break_point_state  
3d2c				endm  
# End of macro CALLMONITOR
3d2c					endif 
3d2c cd ad 0e				call prng16  
3d2f cd cb 20				call forth_push_numhl 
3d32				       NEXTW 
3d32 c3 78 24			jp macro_next 
3d35				endm 
# End of macro NEXTW
3d35			.RND8: 
3d35				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3d35 60				db WORD_SYS_CORE+76             
3d36 6a 3d			dw .RND            
3d38 05				db 4 + 1 
3d39 .. 00			db "RND8",0              
3d3e				endm 
# End of macro CWHEAD
3d3e			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3d3e					if DEBUG_FORTH_WORDS_KEY 
3d3e						DMARK "RN8" 
3d3e f5				push af  
3d3f 3a 53 3d			ld a, (.dmark)  
3d42 32 6e fe			ld (debug_mark),a  
3d45 3a 54 3d			ld a, (.dmark+1)  
3d48 32 6f fe			ld (debug_mark+1),a  
3d4b 3a 55 3d			ld a, (.dmark+2)  
3d4e 32 70 fe			ld (debug_mark+2),a  
3d51 18 03			jr .pastdmark  
3d53 ..			.dmark: db "RN8"  
3d56 f1			.pastdmark: pop af  
3d57			endm  
# End of macro DMARK
3d57						CALLMONITOR 
3d57 cd fb 19			call break_point_state  
3d5a				endm  
# End of macro CALLMONITOR
3d5a					endif 
3d5a 2a ac fb				ld hl,(xrandc) 
3d5d 23					inc hl 
3d5e cd c7 0e				call xrnd 
3d61 6f					ld l,a	 
3d62 26 00				ld h,0 
3d64 cd cb 20				call forth_push_numhl 
3d67				       NEXTW 
3d67 c3 78 24			jp macro_next 
3d6a				endm 
# End of macro NEXTW
3d6a			.RND: 
3d6a				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3d6a 60				db WORD_SYS_CORE+76             
3d6b 70 3e			dw .ENDMATHS            
3d6d 04				db 3 + 1 
3d6e .. 00			db "RND",0              
3d72				endm 
# End of macro CWHEAD
3d72			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3d72			 
3d72					if DEBUG_FORTH_WORDS_KEY 
3d72						DMARK "RND" 
3d72 f5				push af  
3d73 3a 87 3d			ld a, (.dmark)  
3d76 32 6e fe			ld (debug_mark),a  
3d79 3a 88 3d			ld a, (.dmark+1)  
3d7c 32 6f fe			ld (debug_mark+1),a  
3d7f 3a 89 3d			ld a, (.dmark+2)  
3d82 32 70 fe			ld (debug_mark+2),a  
3d85 18 03			jr .pastdmark  
3d87 ..			.dmark: db "RND"  
3d8a f1			.pastdmark: pop af  
3d8b			endm  
# End of macro DMARK
3d8b						CALLMONITOR 
3d8b cd fb 19			call break_point_state  
3d8e				endm  
# End of macro CALLMONITOR
3d8e					endif 
3d8e					 
3d8e					FORTH_DSP_VALUEHL    ; upper range 
3d8e cd c2 22			call macro_dsp_valuehl 
3d91				endm 
# End of macro FORTH_DSP_VALUEHL
3d91			 
3d91 22 b0 fb				ld (LFSRSeed), hl	 
3d94			 
3d94					if DEBUG_FORTH_WORDS 
3d94						DMARK "RN1" 
3d94 f5				push af  
3d95 3a a9 3d			ld a, (.dmark)  
3d98 32 6e fe			ld (debug_mark),a  
3d9b 3a aa 3d			ld a, (.dmark+1)  
3d9e 32 6f fe			ld (debug_mark+1),a  
3da1 3a ab 3d			ld a, (.dmark+2)  
3da4 32 70 fe			ld (debug_mark+2),a  
3da7 18 03			jr .pastdmark  
3da9 ..			.dmark: db "RN1"  
3dac f1			.pastdmark: pop af  
3dad			endm  
# End of macro DMARK
3dad						CALLMONITOR 
3dad cd fb 19			call break_point_state  
3db0				endm  
# End of macro CALLMONITOR
3db0					endif 
3db0					FORTH_DSP_POP 
3db0 cd 7a 23			call macro_forth_dsp_pop 
3db3				endm 
# End of macro FORTH_DSP_POP
3db3			 
3db3					FORTH_DSP_VALUEHL    ; low range 
3db3 cd c2 22			call macro_dsp_valuehl 
3db6				endm 
# End of macro FORTH_DSP_VALUEHL
3db6			 
3db6					if DEBUG_FORTH_WORDS 
3db6						DMARK "RN2" 
3db6 f5				push af  
3db7 3a cb 3d			ld a, (.dmark)  
3dba 32 6e fe			ld (debug_mark),a  
3dbd 3a cc 3d			ld a, (.dmark+1)  
3dc0 32 6f fe			ld (debug_mark+1),a  
3dc3 3a cd 3d			ld a, (.dmark+2)  
3dc6 32 70 fe			ld (debug_mark+2),a  
3dc9 18 03			jr .pastdmark  
3dcb ..			.dmark: db "RN2"  
3dce f1			.pastdmark: pop af  
3dcf			endm  
# End of macro DMARK
3dcf						CALLMONITOR 
3dcf cd fb 19			call break_point_state  
3dd2				endm  
# End of macro CALLMONITOR
3dd2					endif 
3dd2 22 b2 fb				ld (LFSRSeed+2), hl 
3dd5			 
3dd5					FORTH_DSP_POP 
3dd5 cd 7a 23			call macro_forth_dsp_pop 
3dd8				endm 
# End of macro FORTH_DSP_POP
3dd8			 
3dd8 e5					push hl 
3dd9			 
3dd9 e1			.inrange:	pop hl 
3dda cd ad 0e				call prng16  
3ddd					if DEBUG_FORTH_WORDS 
3ddd						DMARK "RN3" 
3ddd f5				push af  
3dde 3a f2 3d			ld a, (.dmark)  
3de1 32 6e fe			ld (debug_mark),a  
3de4 3a f3 3d			ld a, (.dmark+1)  
3de7 32 6f fe			ld (debug_mark+1),a  
3dea 3a f4 3d			ld a, (.dmark+2)  
3ded 32 70 fe			ld (debug_mark+2),a  
3df0 18 03			jr .pastdmark  
3df2 ..			.dmark: db "RN3"  
3df5 f1			.pastdmark: pop af  
3df6			endm  
# End of macro DMARK
3df6						CALLMONITOR 
3df6 cd fb 19			call break_point_state  
3df9				endm  
# End of macro CALLMONITOR
3df9					endif 
3df9					 
3df9					; if the range is 8bit knock out the high byte 
3df9			 
3df9 ed 5b b0 fb			ld de, (LFSRSeed)     ; check high level 
3dfd			 
3dfd 3e 00				ld a, 0 
3dff ba					cp d  
3e00 20 1e				jr nz, .hirange 
3e02 26 00				ld h, 0   ; knock it down to 8bit 
3e04			 
3e04					if DEBUG_FORTH_WORDS 
3e04						DMARK "RNk" 
3e04 f5				push af  
3e05 3a 19 3e			ld a, (.dmark)  
3e08 32 6e fe			ld (debug_mark),a  
3e0b 3a 1a 3e			ld a, (.dmark+1)  
3e0e 32 6f fe			ld (debug_mark+1),a  
3e11 3a 1b 3e			ld a, (.dmark+2)  
3e14 32 70 fe			ld (debug_mark+2),a  
3e17 18 03			jr .pastdmark  
3e19 ..			.dmark: db "RNk"  
3e1c f1			.pastdmark: pop af  
3e1d			endm  
# End of macro DMARK
3e1d						CALLMONITOR 
3e1d cd fb 19			call break_point_state  
3e20				endm  
# End of macro CALLMONITOR
3e20					endif 
3e20			.hirange:   
3e20 e5					push hl  
3e21 b7					or a  
3e22 ed 52		                sbc hl, de 
3e24			 
3e24					;call cmp16 
3e24			 
3e24 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3e26 e1					pop hl 
3e27 e5					push hl 
3e28			 
3e28					if DEBUG_FORTH_WORDS 
3e28						DMARK "RN4" 
3e28 f5				push af  
3e29 3a 3d 3e			ld a, (.dmark)  
3e2c 32 6e fe			ld (debug_mark),a  
3e2f 3a 3e 3e			ld a, (.dmark+1)  
3e32 32 6f fe			ld (debug_mark+1),a  
3e35 3a 3f 3e			ld a, (.dmark+2)  
3e38 32 70 fe			ld (debug_mark+2),a  
3e3b 18 03			jr .pastdmark  
3e3d ..			.dmark: db "RN4"  
3e40 f1			.pastdmark: pop af  
3e41			endm  
# End of macro DMARK
3e41						CALLMONITOR 
3e41 cd fb 19			call break_point_state  
3e44				endm  
# End of macro CALLMONITOR
3e44					endif 
3e44 ed 5b b2 fb			ld de, (LFSRSeed+2)   ; check low range 
3e48					;call cmp16 
3e48				 
3e48 b7					or a  
3e49 ed 52		                sbc hl, de 
3e4b 38 8c				jr c, .inrange 
3e4d			 
3e4d e1					pop hl 
3e4e					 
3e4e					if DEBUG_FORTH_WORDS 
3e4e						DMARK "RNd" 
3e4e f5				push af  
3e4f 3a 63 3e			ld a, (.dmark)  
3e52 32 6e fe			ld (debug_mark),a  
3e55 3a 64 3e			ld a, (.dmark+1)  
3e58 32 6f fe			ld (debug_mark+1),a  
3e5b 3a 65 3e			ld a, (.dmark+2)  
3e5e 32 70 fe			ld (debug_mark+2),a  
3e61 18 03			jr .pastdmark  
3e63 ..			.dmark: db "RNd"  
3e66 f1			.pastdmark: pop af  
3e67			endm  
# End of macro DMARK
3e67						CALLMONITOR 
3e67 cd fb 19			call break_point_state  
3e6a				endm  
# End of macro CALLMONITOR
3e6a					endif 
3e6a			 
3e6a			 
3e6a cd cb 20				call forth_push_numhl 
3e6d				       NEXTW 
3e6d c3 78 24			jp macro_next 
3e70				endm 
# End of macro NEXTW
3e70			 
3e70			.ENDMATHS: 
3e70			 
3e70			; eof 
3e70			 
# End of file forth_words_maths.asm
3e70			include "forth_words_display.asm" 
3e70			 
3e70			; | ## Display Words 
3e70			 
3e70			.ACT: 
3e70			 
3e70				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3e70 62				db WORD_SYS_CORE+78             
3e71 bc 3e			dw .INFO            
3e73 07				db 6 + 1 
3e74 .. 00			db "ACTIVE",0              
3e7b				endm 
# End of macro CWHEAD
3e7b			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3e7b			;  
3e7b			; | | e.g. $ff $00 do active . $01 pause loop 
3e7b			 
3e7b					if DEBUG_FORTH_WORDS_KEY 
3e7b						DMARK "ACT" 
3e7b f5				push af  
3e7c 3a 90 3e			ld a, (.dmark)  
3e7f 32 6e fe			ld (debug_mark),a  
3e82 3a 91 3e			ld a, (.dmark+1)  
3e85 32 6f fe			ld (debug_mark+1),a  
3e88 3a 92 3e			ld a, (.dmark+2)  
3e8b 32 70 fe			ld (debug_mark+2),a  
3e8e 18 03			jr .pastdmark  
3e90 ..			.dmark: db "ACT"  
3e93 f1			.pastdmark: pop af  
3e94			endm  
# End of macro DMARK
3e94						CALLMONITOR 
3e94 cd fb 19			call break_point_state  
3e97				endm  
# End of macro CALLMONITOR
3e97					endif 
3e97 cd a9 0c				call active 
3e9a					if DEBUG_FORTH_WORDS 
3e9a						DMARK "ACp" 
3e9a f5				push af  
3e9b 3a af 3e			ld a, (.dmark)  
3e9e 32 6e fe			ld (debug_mark),a  
3ea1 3a b0 3e			ld a, (.dmark+1)  
3ea4 32 6f fe			ld (debug_mark+1),a  
3ea7 3a b1 3e			ld a, (.dmark+2)  
3eaa 32 70 fe			ld (debug_mark+2),a  
3ead 18 03			jr .pastdmark  
3eaf ..			.dmark: db "ACp"  
3eb2 f1			.pastdmark: pop af  
3eb3			endm  
# End of macro DMARK
3eb3						CALLMONITOR 
3eb3 cd fb 19			call break_point_state  
3eb6				endm  
# End of macro CALLMONITOR
3eb6					endif 
3eb6 cd 39 21				call forth_push_str 
3eb9			 
3eb9					NEXTW 
3eb9 c3 78 24			jp macro_next 
3ebc				endm 
# End of macro NEXTW
3ebc			.INFO: 
3ebc			 
3ebc				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3ebc 62				db WORD_SYS_CORE+78             
3ebd d9 3e			dw .ATP            
3ebf 05				db 4 + 1 
3ec0 .. 00			db "INFO",0              
3ec5				endm 
# End of macro CWHEAD
3ec5			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3ec5					FORTH_DSP_VALUEHL 
3ec5 cd c2 22			call macro_dsp_valuehl 
3ec8				endm 
# End of macro FORTH_DSP_VALUEHL
3ec8			 
3ec8					FORTH_DSP_POP 
3ec8 cd 7a 23			call macro_forth_dsp_pop 
3ecb				endm 
# End of macro FORTH_DSP_POP
3ecb			 
3ecb e5					push hl 
3ecc			 
3ecc					FORTH_DSP_VALUEHL 
3ecc cd c2 22			call macro_dsp_valuehl 
3ecf				endm 
# End of macro FORTH_DSP_VALUEHL
3ecf			 
3ecf					FORTH_DSP_POP 
3ecf cd 7a 23			call macro_forth_dsp_pop 
3ed2				endm 
# End of macro FORTH_DSP_POP
3ed2			 
3ed2 d1					pop de 
3ed3			 
3ed3 cd e3 0c				call info_panel 
3ed6			 
3ed6			 
3ed6					NEXTW 
3ed6 c3 78 24			jp macro_next 
3ed9				endm 
# End of macro NEXTW
3ed9			.ATP: 
3ed9				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3ed9 62				db WORD_SYS_CORE+78             
3eda 50 3f			dw .FB            
3edc 04				db 3 + 1 
3edd .. 00			db "AT?",0              
3ee1				endm 
# End of macro CWHEAD
3ee1			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3ee1					if DEBUG_FORTH_WORDS_KEY 
3ee1						DMARK "AT?" 
3ee1 f5				push af  
3ee2 3a f6 3e			ld a, (.dmark)  
3ee5 32 6e fe			ld (debug_mark),a  
3ee8 3a f7 3e			ld a, (.dmark+1)  
3eeb 32 6f fe			ld (debug_mark+1),a  
3eee 3a f8 3e			ld a, (.dmark+2)  
3ef1 32 70 fe			ld (debug_mark+2),a  
3ef4 18 03			jr .pastdmark  
3ef6 ..			.dmark: db "AT?"  
3ef9 f1			.pastdmark: pop af  
3efa			endm  
# End of macro DMARK
3efa						CALLMONITOR 
3efa cd fb 19			call break_point_state  
3efd				endm  
# End of macro CALLMONITOR
3efd					endif 
3efd 3a 61 fa				ld a, (f_cursor_ptr) 
3f00			 
3f00			if DEBUG_FORTH_WORDS 
3f00				DMARK "AT?" 
3f00 f5				push af  
3f01 3a 15 3f			ld a, (.dmark)  
3f04 32 6e fe			ld (debug_mark),a  
3f07 3a 16 3f			ld a, (.dmark+1)  
3f0a 32 6f fe			ld (debug_mark+1),a  
3f0d 3a 17 3f			ld a, (.dmark+2)  
3f10 32 70 fe			ld (debug_mark+2),a  
3f13 18 03			jr .pastdmark  
3f15 ..			.dmark: db "AT?"  
3f18 f1			.pastdmark: pop af  
3f19			endm  
# End of macro DMARK
3f19				CALLMONITOR 
3f19 cd fb 19			call break_point_state  
3f1c				endm  
# End of macro CALLMONITOR
3f1c			endif	 
3f1c					; count the number of rows 
3f1c			 
3f1c 06 00				ld b, 0 
3f1e 4f			.atpr:		ld c, a    ; save in case we go below zero 
3f1f d6 28				sub display_cols 
3f21 f2 27 3f				jp p, .atprunder 
3f24 04					inc b 
3f25 18 f7				jr .atpr 
3f27			.atprunder:	 
3f27			if DEBUG_FORTH_WORDS 
3f27				DMARK "A?2" 
3f27 f5				push af  
3f28 3a 3c 3f			ld a, (.dmark)  
3f2b 32 6e fe			ld (debug_mark),a  
3f2e 3a 3d 3f			ld a, (.dmark+1)  
3f31 32 6f fe			ld (debug_mark+1),a  
3f34 3a 3e 3f			ld a, (.dmark+2)  
3f37 32 70 fe			ld (debug_mark+2),a  
3f3a 18 03			jr .pastdmark  
3f3c ..			.dmark: db "A?2"  
3f3f f1			.pastdmark: pop af  
3f40			endm  
# End of macro DMARK
3f40				CALLMONITOR 
3f40 cd fb 19			call break_point_state  
3f43				endm  
# End of macro CALLMONITOR
3f43			endif	 
3f43 26 00				ld h, 0 
3f45 69					ld l, c 
3f46 cd cb 20				call forth_push_numhl 
3f49 68					ld l, b  
3f4a cd cb 20				call forth_push_numhl 
3f4d			 
3f4d			 
3f4d				NEXTW 
3f4d c3 78 24			jp macro_next 
3f50				endm 
# End of macro NEXTW
3f50			 
3f50			.FB: 
3f50				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3f50 1b				db WORD_SYS_CORE+7             
3f51 9e 3f			dw .EMIT            
3f53 03				db 2 + 1 
3f54 .. 00			db "FB",0              
3f57				endm 
# End of macro CWHEAD
3f57			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3f57			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3f57			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3f57			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3f57					if DEBUG_FORTH_WORDS_KEY 
3f57						DMARK "FB." 
3f57 f5				push af  
3f58 3a 6c 3f			ld a, (.dmark)  
3f5b 32 6e fe			ld (debug_mark),a  
3f5e 3a 6d 3f			ld a, (.dmark+1)  
3f61 32 6f fe			ld (debug_mark+1),a  
3f64 3a 6e 3f			ld a, (.dmark+2)  
3f67 32 70 fe			ld (debug_mark+2),a  
3f6a 18 03			jr .pastdmark  
3f6c ..			.dmark: db "FB."  
3f6f f1			.pastdmark: pop af  
3f70			endm  
# End of macro DMARK
3f70						CALLMONITOR 
3f70 cd fb 19			call break_point_state  
3f73				endm  
# End of macro CALLMONITOR
3f73					endif 
3f73			 
3f73					FORTH_DSP_VALUEHL 
3f73 cd c2 22			call macro_dsp_valuehl 
3f76				endm 
# End of macro FORTH_DSP_VALUEHL
3f76			 
3f76 7d					ld a, l 
3f77 fe 01				cp 1 
3f79 20 05				jr nz, .fbn1 
3f7b 21 13 fd				ld hl, display_fb1 
3f7e 18 15				jr .fbset 
3f80 fe 02		.fbn1:		cp 2 
3f82 20 05				jr nz, .fbn2 
3f84 21 d1 fb				ld hl, display_fb2 
3f87 18 0c				jr .fbset 
3f89 fe 03		.fbn2:		cp 3 
3f8b 20 05				jr nz, .fbn3 
3f8d 21 72 fc				ld hl, display_fb3 
3f90 18 03				jr .fbset 
3f92			.fbn3:		 ; if invalid number select first 
3f92 21 13 fd				ld hl, display_fb1 
3f95 22 cf fb		.fbset:		ld (display_fb_active), hl 
3f98			 
3f98					FORTH_DSP_POP 
3f98 cd 7a 23			call macro_forth_dsp_pop 
3f9b				endm 
# End of macro FORTH_DSP_POP
3f9b			 
3f9b					NEXTW 
3f9b c3 78 24			jp macro_next 
3f9e				endm 
# End of macro NEXTW
3f9e			 
3f9e			 
3f9e			.EMIT: 
3f9e				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3f9e 1b				db WORD_SYS_CORE+7             
3f9f ef 3f			dw .DOTH            
3fa1 05				db 4 + 1 
3fa2 .. 00			db "EMIT",0              
3fa7				endm 
# End of macro CWHEAD
3fa7			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3fa7					; get value off TOS and display it 
3fa7			 
3fa7					if DEBUG_FORTH_WORDS_KEY 
3fa7						DMARK "EMT" 
3fa7 f5				push af  
3fa8 3a bc 3f			ld a, (.dmark)  
3fab 32 6e fe			ld (debug_mark),a  
3fae 3a bd 3f			ld a, (.dmark+1)  
3fb1 32 6f fe			ld (debug_mark+1),a  
3fb4 3a be 3f			ld a, (.dmark+2)  
3fb7 32 70 fe			ld (debug_mark+2),a  
3fba 18 03			jr .pastdmark  
3fbc ..			.dmark: db "EMT"  
3fbf f1			.pastdmark: pop af  
3fc0			endm  
# End of macro DMARK
3fc0						CALLMONITOR 
3fc0 cd fb 19			call break_point_state  
3fc3				endm  
# End of macro CALLMONITOR
3fc3					endif 
3fc3			 
3fc3					FORTH_DSP_VALUEHL 
3fc3 cd c2 22			call macro_dsp_valuehl 
3fc6				endm 
# End of macro FORTH_DSP_VALUEHL
3fc6			 
3fc6 7d					ld a,l 
3fc7			 
3fc7					; TODO write to display 
3fc7			 
3fc7 32 c2 f3				ld (os_input), a 
3fca 3e 00				ld a, 0 
3fcc 32 c3 f3				ld (os_input+1), a 
3fcf					 
3fcf 3a 61 fa				ld a, (f_cursor_ptr) 
3fd2 11 c2 f3				ld de, os_input 
3fd5 cd 65 0d				call str_at_display 
3fd8			 
3fd8			 
3fd8 3a 3f fa				ld a,(cli_autodisplay) 
3fdb fe 00				cp 0 
3fdd 28 03				jr z, .enoupdate 
3fdf cd 75 0d						call update_display 
3fe2					.enoupdate: 
3fe2			 
3fe2 3a 61 fa				ld a, (f_cursor_ptr) 
3fe5 3c					inc a 
3fe6 32 61 fa				ld (f_cursor_ptr), a   ; save new pos 
3fe9			 
3fe9			 
3fe9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fe9 cd 7a 23			call macro_forth_dsp_pop 
3fec				endm 
# End of macro FORTH_DSP_POP
3fec			  
3fec			 
3fec					NEXTW 
3fec c3 78 24			jp macro_next 
3fef				endm 
# End of macro NEXTW
3fef			.DOTH: 
3fef				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3fef 1c				db WORD_SYS_CORE+8             
3ff0 1f 40			dw .DOTF            
3ff2 03				db 2 + 1 
3ff3 .. 00			db ".-",0              
3ff6				endm 
# End of macro CWHEAD
3ff6			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3ff6					; get value off TOS and display it 
3ff6					if DEBUG_FORTH_WORDS_KEY 
3ff6						DMARK "DTD" 
3ff6 f5				push af  
3ff7 3a 0b 40			ld a, (.dmark)  
3ffa 32 6e fe			ld (debug_mark),a  
3ffd 3a 0c 40			ld a, (.dmark+1)  
4000 32 6f fe			ld (debug_mark+1),a  
4003 3a 0d 40			ld a, (.dmark+2)  
4006 32 70 fe			ld (debug_mark+2),a  
4009 18 03			jr .pastdmark  
400b ..			.dmark: db "DTD"  
400e f1			.pastdmark: pop af  
400f			endm  
# End of macro DMARK
400f						CALLMONITOR 
400f cd fb 19			call break_point_state  
4012				endm  
# End of macro CALLMONITOR
4012					endif 
4012 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
4014 3e 00			ld a, 0 
4016 32 40 fa			ld (cli_mvdot), a 
4019 c3 76 40			jp .dotgo 
401c				NEXTW 
401c c3 78 24			jp macro_next 
401f				endm 
# End of macro NEXTW
401f			.DOTF: 
401f				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
401f 1c				db WORD_SYS_CORE+8             
4020 4d 40			dw .DOT            
4022 03				db 2 + 1 
4023 .. 00			db ".>",0              
4026				endm 
# End of macro CWHEAD
4026			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
4026					; get value off TOS and display it 
4026			        ; TODO BUG adds extra spaces 
4026			        ; TODO BUG handle numerics? 
4026					if DEBUG_FORTH_WORDS_KEY 
4026						DMARK "DTC" 
4026 f5				push af  
4027 3a 3b 40			ld a, (.dmark)  
402a 32 6e fe			ld (debug_mark),a  
402d 3a 3c 40			ld a, (.dmark+1)  
4030 32 6f fe			ld (debug_mark+1),a  
4033 3a 3d 40			ld a, (.dmark+2)  
4036 32 70 fe			ld (debug_mark+2),a  
4039 18 03			jr .pastdmark  
403b ..			.dmark: db "DTC"  
403e f1			.pastdmark: pop af  
403f			endm  
# End of macro DMARK
403f						CALLMONITOR 
403f cd fb 19			call break_point_state  
4042				endm  
# End of macro CALLMONITOR
4042					endif 
4042 3e 01			ld a, 1 
4044 32 40 fa			ld (cli_mvdot), a 
4047 c3 76 40			jp .dotgo 
404a				NEXTW 
404a c3 78 24			jp macro_next 
404d				endm 
# End of macro NEXTW
404d			 
404d			.DOT: 
404d				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
404d 1c				db WORD_SYS_CORE+8             
404e 29 42			dw .CLS            
4050 02				db 1 + 1 
4051 .. 00			db ".",0              
4053				endm 
# End of macro CWHEAD
4053			        ; | . ( u -- ) Display TOS | DONE 
4053					; get value off TOS and display it 
4053			 
4053					if DEBUG_FORTH_WORDS_KEY 
4053						DMARK "DOT" 
4053 f5				push af  
4054 3a 68 40			ld a, (.dmark)  
4057 32 6e fe			ld (debug_mark),a  
405a 3a 69 40			ld a, (.dmark+1)  
405d 32 6f fe			ld (debug_mark+1),a  
4060 3a 6a 40			ld a, (.dmark+2)  
4063 32 70 fe			ld (debug_mark+2),a  
4066 18 03			jr .pastdmark  
4068 ..			.dmark: db "DOT"  
406b f1			.pastdmark: pop af  
406c			endm  
# End of macro DMARK
406c						CALLMONITOR 
406c cd fb 19			call break_point_state  
406f				endm  
# End of macro CALLMONITOR
406f					endif 
406f 3e 00			ld a, 0 
4071 32 40 fa			ld (cli_mvdot), a 
4074 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4076				 
4076			 
4076			.dotgo: 
4076			 
4076			; move up type to on stack for parserv5 
4076					FORTH_DSP 
4076 cd 88 22			call macro_forth_dsp 
4079				endm 
# End of macro FORTH_DSP
4079				;FORTH_DSP_VALUE  
4079			 
4079			if DEBUG_FORTH_DOT 
4079				DMARK "DOT" 
4079 f5				push af  
407a 3a 8e 40			ld a, (.dmark)  
407d 32 6e fe			ld (debug_mark),a  
4080 3a 8f 40			ld a, (.dmark+1)  
4083 32 6f fe			ld (debug_mark+1),a  
4086 3a 90 40			ld a, (.dmark+2)  
4089 32 70 fe			ld (debug_mark+2),a  
408c 18 03			jr .pastdmark  
408e ..			.dmark: db "DOT"  
4091 f1			.pastdmark: pop af  
4092			endm  
# End of macro DMARK
4092				CALLMONITOR 
4092 cd fb 19			call break_point_state  
4095				endm  
# End of macro CALLMONITOR
4095			endif	 
4095			;		.print: 
4095			 
4095 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4096 23				inc hl   ; position to the actual value 
4097 fe 01			cp DS_TYPE_STR 
4099 20 06			jr nz, .dotnum1  
409b			 
409b			; display string 
409b				FORTH_DSP_VALUE  
409b cd ab 22			call macro_forth_dsp_value 
409e				endm 
# End of macro FORTH_DSP_VALUE
409e eb				ex de,hl 
409f 18 49			jr .dotwrite 
40a1			 
40a1			.dotnum1: 
40a1 fe 02			cp DS_TYPE_INUM 
40a3 20 44			jr nz, .dotflot 
40a5			 
40a5			 
40a5			; display number 
40a5			 
40a5			;	push hl 
40a5			;	call clear_display 
40a5			;	pop hl 
40a5			 
40a5 5e				ld e, (hl) 
40a6 23				inc hl 
40a7 56				ld d, (hl) 
40a8 21 c4 f1			ld hl, scratch 
40ab			if DEBUG_FORTH_DOT 
40ab				DMARK "DT1" 
40ab f5				push af  
40ac 3a c0 40			ld a, (.dmark)  
40af 32 6e fe			ld (debug_mark),a  
40b2 3a c1 40			ld a, (.dmark+1)  
40b5 32 6f fe			ld (debug_mark+1),a  
40b8 3a c2 40			ld a, (.dmark+2)  
40bb 32 70 fe			ld (debug_mark+2),a  
40be 18 03			jr .pastdmark  
40c0 ..			.dmark: db "DT1"  
40c3 f1			.pastdmark: pop af  
40c4			endm  
# End of macro DMARK
40c4				CALLMONITOR 
40c4 cd fb 19			call break_point_state  
40c7				endm  
# End of macro CALLMONITOR
40c7			endif	 
40c7			 
40c7 cd 93 13			call uitoa_16 
40ca eb				ex de,hl 
40cb			 
40cb			if DEBUG_FORTH_DOT 
40cb				DMARK "DT2" 
40cb f5				push af  
40cc 3a e0 40			ld a, (.dmark)  
40cf 32 6e fe			ld (debug_mark),a  
40d2 3a e1 40			ld a, (.dmark+1)  
40d5 32 6f fe			ld (debug_mark+1),a  
40d8 3a e2 40			ld a, (.dmark+2)  
40db 32 70 fe			ld (debug_mark+2),a  
40de 18 03			jr .pastdmark  
40e0 ..			.dmark: db "DT2"  
40e3 f1			.pastdmark: pop af  
40e4			endm  
# End of macro DMARK
40e4				CALLMONITOR 
40e4 cd fb 19			call break_point_state  
40e7				endm  
# End of macro CALLMONITOR
40e7			endif	 
40e7			 
40e7			;	ld de, os_word_scratch 
40e7 18 01			jr .dotwrite 
40e9			 
40e9 00			.dotflot:   nop 
40ea			; TODO print floating point number 
40ea			 
40ea			.dotwrite:		 
40ea			 
40ea					; if c is set then set all '-' to spaces 
40ea					; need to also take into account .>  
40ea			 
40ea 3e 01				ld a, 1 
40ec b9					cp c 
40ed 20 67				jr nz, .nodashswap 
40ef			 
40ef					; DE has the string to write, working with HL 
40ef			 
40ef 06 ff				ld b, 255 
40f1 d5					push de 
40f2 e1					pop hl 
40f3			 
40f3			if DEBUG_FORTH_DOT 
40f3				DMARK "DT-" 
40f3 f5				push af  
40f4 3a 08 41			ld a, (.dmark)  
40f7 32 6e fe			ld (debug_mark),a  
40fa 3a 09 41			ld a, (.dmark+1)  
40fd 32 6f fe			ld (debug_mark+1),a  
4100 3a 0a 41			ld a, (.dmark+2)  
4103 32 70 fe			ld (debug_mark+2),a  
4106 18 03			jr .pastdmark  
4108 ..			.dmark: db "DT-"  
410b f1			.pastdmark: pop af  
410c			endm  
# End of macro DMARK
410c				CALLMONITOR 
410c cd fb 19			call break_point_state  
410f				endm  
# End of macro CALLMONITOR
410f			endif	 
410f 7e			.dashscan:	ld a, (hl) 
4110 fe 00				cp 0 
4112 28 42				jr z, .nodashswap 
4114 fe 2d				cp '-' 
4116 20 03				jr nz, .dashskip 
4118 3e 20				ld a, ' ' 
411a 77					ld (hl), a 
411b 23			.dashskip:	inc hl 
411c			if DEBUG_FORTH_DOT 
411c				DMARK "D-2" 
411c f5				push af  
411d 3a 31 41			ld a, (.dmark)  
4120 32 6e fe			ld (debug_mark),a  
4123 3a 32 41			ld a, (.dmark+1)  
4126 32 6f fe			ld (debug_mark+1),a  
4129 3a 33 41			ld a, (.dmark+2)  
412c 32 70 fe			ld (debug_mark+2),a  
412f 18 03			jr .pastdmark  
4131 ..			.dmark: db "D-2"  
4134 f1			.pastdmark: pop af  
4135			endm  
# End of macro DMARK
4135				CALLMONITOR 
4135 cd fb 19			call break_point_state  
4138				endm  
# End of macro CALLMONITOR
4138			endif	 
4138 10 d5				djnz .dashscan 
413a			 
413a			if DEBUG_FORTH_DOT 
413a				DMARK "D-1" 
413a f5				push af  
413b 3a 4f 41			ld a, (.dmark)  
413e 32 6e fe			ld (debug_mark),a  
4141 3a 50 41			ld a, (.dmark+1)  
4144 32 6f fe			ld (debug_mark+1),a  
4147 3a 51 41			ld a, (.dmark+2)  
414a 32 70 fe			ld (debug_mark+2),a  
414d 18 03			jr .pastdmark  
414f ..			.dmark: db "D-1"  
4152 f1			.pastdmark: pop af  
4153			endm  
# End of macro DMARK
4153				CALLMONITOR 
4153 cd fb 19			call break_point_state  
4156				endm  
# End of macro CALLMONITOR
4156			endif	 
4156			 
4156			.nodashswap: 
4156			 
4156			if DEBUG_FORTH_DOT 
4156				DMARK "D-o" 
4156 f5				push af  
4157 3a 6b 41			ld a, (.dmark)  
415a 32 6e fe			ld (debug_mark),a  
415d 3a 6c 41			ld a, (.dmark+1)  
4160 32 6f fe			ld (debug_mark+1),a  
4163 3a 6d 41			ld a, (.dmark+2)  
4166 32 70 fe			ld (debug_mark+2),a  
4169 18 03			jr .pastdmark  
416b ..			.dmark: db "D-o"  
416e f1			.pastdmark: pop af  
416f			endm  
# End of macro DMARK
416f				CALLMONITOR 
416f cd fb 19			call break_point_state  
4172				endm  
# End of macro CALLMONITOR
4172			endif	 
4172			 
4172 d5					push de   ; save string start in case we need to advance print 
4173			 
4173 3a 61 fa				ld a, (f_cursor_ptr) 
4176 cd 65 0d				call str_at_display 
4179 3a 3f fa				ld a,(cli_autodisplay) 
417c fe 00				cp 0 
417e 28 03				jr z, .noupdate 
4180 cd 75 0d						call update_display 
4183					.noupdate: 
4183			 
4183			 
4183					; see if we need to advance the print position 
4183			 
4183 e1					pop hl   ; get back string 
4184			;		ex de,hl 
4184			 
4184 3a 40 fa				ld a, (cli_mvdot) 
4187			if DEBUG_FORTH_DOT 
4187			;		ld e,a 
4187				DMARK "D>1" 
4187 f5				push af  
4188 3a 9c 41			ld a, (.dmark)  
418b 32 6e fe			ld (debug_mark),a  
418e 3a 9d 41			ld a, (.dmark+1)  
4191 32 6f fe			ld (debug_mark+1),a  
4194 3a 9e 41			ld a, (.dmark+2)  
4197 32 70 fe			ld (debug_mark+2),a  
419a 18 03			jr .pastdmark  
419c ..			.dmark: db "D>1"  
419f f1			.pastdmark: pop af  
41a0			endm  
# End of macro DMARK
41a0				CALLMONITOR 
41a0 cd fb 19			call break_point_state  
41a3				endm  
# End of macro CALLMONITOR
41a3			endif	 
41a3 fe 00				cp 0 
41a5 28 44				jr z, .noadv 
41a7					; yes, lets advance the print position 
41a7 3e 00				ld a, 0 
41a9 cd ef 13				call strlent 
41ac			if DEBUG_FORTH_DOT 
41ac				DMARK "D-?" 
41ac f5				push af  
41ad 3a c1 41			ld a, (.dmark)  
41b0 32 6e fe			ld (debug_mark),a  
41b3 3a c2 41			ld a, (.dmark+1)  
41b6 32 6f fe			ld (debug_mark+1),a  
41b9 3a c3 41			ld a, (.dmark+2)  
41bc 32 70 fe			ld (debug_mark+2),a  
41bf 18 03			jr .pastdmark  
41c1 ..			.dmark: db "D-?"  
41c4 f1			.pastdmark: pop af  
41c5			endm  
# End of macro DMARK
41c5				CALLMONITOR 
41c5 cd fb 19			call break_point_state  
41c8				endm  
# End of macro CALLMONITOR
41c8			endif	 
41c8 3a 61 fa				ld a, (f_cursor_ptr) 
41cb 85					add a,l 
41cc					;call addatohl 
41cc					;ld a, l 
41cc 32 61 fa				ld (f_cursor_ptr), a   ; save new pos 
41cf			 
41cf			if DEBUG_FORTH_DOT 
41cf				DMARK "D->" 
41cf f5				push af  
41d0 3a e4 41			ld a, (.dmark)  
41d3 32 6e fe			ld (debug_mark),a  
41d6 3a e5 41			ld a, (.dmark+1)  
41d9 32 6f fe			ld (debug_mark+1),a  
41dc 3a e6 41			ld a, (.dmark+2)  
41df 32 70 fe			ld (debug_mark+2),a  
41e2 18 03			jr .pastdmark  
41e4 ..			.dmark: db "D->"  
41e7 f1			.pastdmark: pop af  
41e8			endm  
# End of macro DMARK
41e8				CALLMONITOR 
41e8 cd fb 19			call break_point_state  
41eb				endm  
# End of macro CALLMONITOR
41eb			endif	 
41eb			 
41eb			.noadv:	 
41eb			 
41eb					if DEBUG_FORTH_DOT_WAIT 
41eb							call next_page_prompt 
41eb					endif	 
41eb			; TODO this pop off the stack causes a crash. i dont know why 
41eb			 
41eb			 
41eb			if DEBUG_FORTH_DOT 
41eb				DMARK "DTh" 
41eb f5				push af  
41ec 3a 00 42			ld a, (.dmark)  
41ef 32 6e fe			ld (debug_mark),a  
41f2 3a 01 42			ld a, (.dmark+1)  
41f5 32 6f fe			ld (debug_mark+1),a  
41f8 3a 02 42			ld a, (.dmark+2)  
41fb 32 70 fe			ld (debug_mark+2),a  
41fe 18 03			jr .pastdmark  
4200 ..			.dmark: db "DTh"  
4203 f1			.pastdmark: pop af  
4204			endm  
# End of macro DMARK
4204				CALLMONITOR 
4204 cd fb 19			call break_point_state  
4207				endm  
# End of macro CALLMONITOR
4207			endif	 
4207			 
4207					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4207 cd 7a 23			call macro_forth_dsp_pop 
420a				endm 
# End of macro FORTH_DSP_POP
420a			 
420a			if DEBUG_FORTH_DOT 
420a				DMARK "DTi" 
420a f5				push af  
420b 3a 1f 42			ld a, (.dmark)  
420e 32 6e fe			ld (debug_mark),a  
4211 3a 20 42			ld a, (.dmark+1)  
4214 32 6f fe			ld (debug_mark+1),a  
4217 3a 21 42			ld a, (.dmark+2)  
421a 32 70 fe			ld (debug_mark+2),a  
421d 18 03			jr .pastdmark  
421f ..			.dmark: db "DTi"  
4222 f1			.pastdmark: pop af  
4223			endm  
# End of macro DMARK
4223				CALLMONITOR 
4223 cd fb 19			call break_point_state  
4226				endm  
# End of macro CALLMONITOR
4226			endif	 
4226			 
4226			 
4226					NEXTW 
4226 c3 78 24			jp macro_next 
4229				endm 
# End of macro NEXTW
4229			 
4229			.CLS: 
4229				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4229 35				db WORD_SYS_CORE+33             
422a 56 42			dw .DRAW            
422c 04				db 3 + 1 
422d .. 00			db "CLS",0              
4231				endm 
# End of macro CWHEAD
4231			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4231					if DEBUG_FORTH_WORDS_KEY 
4231						DMARK "CLS" 
4231 f5				push af  
4232 3a 46 42			ld a, (.dmark)  
4235 32 6e fe			ld (debug_mark),a  
4238 3a 47 42			ld a, (.dmark+1)  
423b 32 6f fe			ld (debug_mark+1),a  
423e 3a 48 42			ld a, (.dmark+2)  
4241 32 70 fe			ld (debug_mark+2),a  
4244 18 03			jr .pastdmark  
4246 ..			.dmark: db "CLS"  
4249 f1			.pastdmark: pop af  
424a			endm  
# End of macro DMARK
424a						CALLMONITOR 
424a cd fb 19			call break_point_state  
424d				endm  
# End of macro CALLMONITOR
424d					endif 
424d cd 52 0d				call clear_display 
4250 c3 64 43				jp .home		; and home cursor 
4253					NEXTW 
4253 c3 78 24			jp macro_next 
4256				endm 
# End of macro NEXTW
4256			 
4256			.DRAW: 
4256				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4256 36				db WORD_SYS_CORE+34             
4257 81 42			dw .DUMP            
4259 05				db 4 + 1 
425a .. 00			db "DRAW",0              
425f				endm 
# End of macro CWHEAD
425f			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
425f					if DEBUG_FORTH_WORDS_KEY 
425f						DMARK "DRW" 
425f f5				push af  
4260 3a 74 42			ld a, (.dmark)  
4263 32 6e fe			ld (debug_mark),a  
4266 3a 75 42			ld a, (.dmark+1)  
4269 32 6f fe			ld (debug_mark+1),a  
426c 3a 76 42			ld a, (.dmark+2)  
426f 32 70 fe			ld (debug_mark+2),a  
4272 18 03			jr .pastdmark  
4274 ..			.dmark: db "DRW"  
4277 f1			.pastdmark: pop af  
4278			endm  
# End of macro DMARK
4278						CALLMONITOR 
4278 cd fb 19			call break_point_state  
427b				endm  
# End of macro CALLMONITOR
427b					endif 
427b cd 75 0d				call update_display 
427e					NEXTW 
427e c3 78 24			jp macro_next 
4281				endm 
# End of macro NEXTW
4281			 
4281			.DUMP: 
4281				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4281 37				db WORD_SYS_CORE+35             
4282 b9 42			dw .CDUMP            
4284 05				db 4 + 1 
4285 .. 00			db "DUMP",0              
428a				endm 
# End of macro CWHEAD
428a			; | DUMP ( x -- ) With address x display dump   | DONE 
428a			; TODO pop address to use off of the stack 
428a					if DEBUG_FORTH_WORDS_KEY 
428a						DMARK "DUM" 
428a f5				push af  
428b 3a 9f 42			ld a, (.dmark)  
428e 32 6e fe			ld (debug_mark),a  
4291 3a a0 42			ld a, (.dmark+1)  
4294 32 6f fe			ld (debug_mark+1),a  
4297 3a a1 42			ld a, (.dmark+2)  
429a 32 70 fe			ld (debug_mark+2),a  
429d 18 03			jr .pastdmark  
429f ..			.dmark: db "DUM"  
42a2 f1			.pastdmark: pop af  
42a3			endm  
# End of macro DMARK
42a3						CALLMONITOR 
42a3 cd fb 19			call break_point_state  
42a6				endm  
# End of macro CALLMONITOR
42a6					endif 
42a6 cd 52 0d				call clear_display 
42a9			 
42a9					; get address 
42a9			 
42a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42a9 cd c2 22			call macro_dsp_valuehl 
42ac				endm 
# End of macro FORTH_DSP_VALUEHL
42ac				 
42ac					; save it for cdump 
42ac			 
42ac 22 e7 f4				ld (os_cur_ptr),hl 
42af			 
42af					; destroy value TOS 
42af			 
42af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42af cd 7a 23			call macro_forth_dsp_pop 
42b2				endm 
# End of macro FORTH_DSP_POP
42b2			 
42b2 cd 4b 1f				call dumpcont	; skip old style of param parsing	 
42b5 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
42b6					NEXTW 
42b6 c3 78 24			jp macro_next 
42b9				endm 
# End of macro NEXTW
42b9			.CDUMP: 
42b9				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
42b9 38				db WORD_SYS_CORE+36             
42ba e9 42			dw .DAT            
42bc 06				db 5 + 1 
42bd .. 00			db "CDUMP",0              
42c3				endm 
# End of macro CWHEAD
42c3			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
42c3					if DEBUG_FORTH_WORDS_KEY 
42c3						DMARK "CDP" 
42c3 f5				push af  
42c4 3a d8 42			ld a, (.dmark)  
42c7 32 6e fe			ld (debug_mark),a  
42ca 3a d9 42			ld a, (.dmark+1)  
42cd 32 6f fe			ld (debug_mark+1),a  
42d0 3a da 42			ld a, (.dmark+2)  
42d3 32 70 fe			ld (debug_mark+2),a  
42d6 18 03			jr .pastdmark  
42d8 ..			.dmark: db "CDP"  
42db f1			.pastdmark: pop af  
42dc			endm  
# End of macro DMARK
42dc						CALLMONITOR 
42dc cd fb 19			call break_point_state  
42df				endm  
# End of macro CALLMONITOR
42df					endif 
42df cd 52 0d				call clear_display 
42e2 cd 4b 1f				call dumpcont	 
42e5 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
42e6					NEXTW 
42e6 c3 78 24			jp macro_next 
42e9				endm 
# End of macro NEXTW
42e9			 
42e9			 
42e9			 
42e9			 
42e9			.DAT: 
42e9				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
42e9 3d				db WORD_SYS_CORE+41             
42ea 3f 43			dw .HOME            
42ec 03				db 2 + 1 
42ed .. 00			db "AT",0              
42f0				endm 
# End of macro CWHEAD
42f0			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
42f0					if DEBUG_FORTH_WORDS_KEY 
42f0						DMARK "AT." 
42f0 f5				push af  
42f1 3a 05 43			ld a, (.dmark)  
42f4 32 6e fe			ld (debug_mark),a  
42f7 3a 06 43			ld a, (.dmark+1)  
42fa 32 6f fe			ld (debug_mark+1),a  
42fd 3a 07 43			ld a, (.dmark+2)  
4300 32 70 fe			ld (debug_mark+2),a  
4303 18 03			jr .pastdmark  
4305 ..			.dmark: db "AT."  
4308 f1			.pastdmark: pop af  
4309			endm  
# End of macro DMARK
4309						CALLMONITOR 
4309 cd fb 19			call break_point_state  
430c				endm  
# End of macro CALLMONITOR
430c					endif 
430c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
430c cd c2 22			call macro_dsp_valuehl 
430f				endm 
# End of macro FORTH_DSP_VALUEHL
430f			 
430f			 
430f					; TODO save cursor row 
430f 7d					ld a,l 
4310 fe 02				cp 2 
4312 20 04				jr nz, .crow3 
4314 3e 28				ld a, display_row_2 
4316 18 12				jr .ccol1 
4318 fe 03		.crow3:		cp 3 
431a 20 04				jr nz, .crow4 
431c 3e 50				ld a, display_row_3 
431e 18 0a				jr .ccol1 
4320 fe 04		.crow4:		cp 4 
4322 20 04				jr nz, .crow1 
4324 3e 78				ld a, display_row_4 
4326 18 02				jr .ccol1 
4328 3e 00		.crow1:		ld a,display_row_1 
432a f5			.ccol1:		push af			; got row offset 
432b 6f					ld l,a 
432c 26 00				ld h,0 
432e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
432e cd 7a 23			call macro_forth_dsp_pop 
4331				endm 
# End of macro FORTH_DSP_POP
4331					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4331 cd c2 22			call macro_dsp_valuehl 
4334				endm 
# End of macro FORTH_DSP_VALUEHL
4334					; TODO save cursor col 
4334 f1					pop af 
4335 85					add l		; add col offset 
4336 32 61 fa				ld (f_cursor_ptr), a 
4339					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4339 cd 7a 23			call macro_forth_dsp_pop 
433c				endm 
# End of macro FORTH_DSP_POP
433c			 
433c					; calculate  
433c			 
433c					NEXTW 
433c c3 78 24			jp macro_next 
433f				endm 
# End of macro NEXTW
433f			 
433f			 
433f			.HOME: 
433f				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
433f 41				db WORD_SYS_CORE+45             
4340 6c 43			dw .SPACE            
4342 05				db 4 + 1 
4343 .. 00			db "HOME",0              
4348				endm 
# End of macro CWHEAD
4348			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4348					if DEBUG_FORTH_WORDS_KEY 
4348						DMARK "HOM" 
4348 f5				push af  
4349 3a 5d 43			ld a, (.dmark)  
434c 32 6e fe			ld (debug_mark),a  
434f 3a 5e 43			ld a, (.dmark+1)  
4352 32 6f fe			ld (debug_mark+1),a  
4355 3a 5f 43			ld a, (.dmark+2)  
4358 32 70 fe			ld (debug_mark+2),a  
435b 18 03			jr .pastdmark  
435d ..			.dmark: db "HOM"  
4360 f1			.pastdmark: pop af  
4361			endm  
# End of macro DMARK
4361						CALLMONITOR 
4361 cd fb 19			call break_point_state  
4364				endm  
# End of macro CALLMONITOR
4364					endif 
4364 3e 00		.home:		ld a, 0		; and home cursor 
4366 32 61 fa				ld (f_cursor_ptr), a 
4369					NEXTW 
4369 c3 78 24			jp macro_next 
436c				endm 
# End of macro NEXTW
436c			 
436c			 
436c			.SPACE: 
436c				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
436c 46				db WORD_SYS_CORE+50             
436d a2 43			dw .SPACES            
436f 03				db 2 + 1 
4370 .. 00			db "BL",0              
4373				endm 
# End of macro CWHEAD
4373			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
4373					if DEBUG_FORTH_WORDS_KEY 
4373						DMARK "BL." 
4373 f5				push af  
4374 3a 88 43			ld a, (.dmark)  
4377 32 6e fe			ld (debug_mark),a  
437a 3a 89 43			ld a, (.dmark+1)  
437d 32 6f fe			ld (debug_mark+1),a  
4380 3a 8a 43			ld a, (.dmark+2)  
4383 32 70 fe			ld (debug_mark+2),a  
4386 18 03			jr .pastdmark  
4388 ..			.dmark: db "BL."  
438b f1			.pastdmark: pop af  
438c			endm  
# End of macro DMARK
438c						CALLMONITOR 
438c cd fb 19			call break_point_state  
438f				endm  
# End of macro CALLMONITOR
438f					endif 
438f 3e 20				ld a, " " 
4391 32 c4 f1				ld (scratch),a 
4394 3e 00				ld a, 0 
4396 32 c5 f1				ld (scratch+1),a 
4399 21 c4 f1				ld hl, scratch 
439c cd 39 21				call forth_push_str 
439f					 
439f				       NEXTW 
439f c3 78 24			jp macro_next 
43a2				endm 
# End of macro NEXTW
43a2			 
43a2			;.blstr: db " ", 0 
43a2			 
43a2			.SPACES: 
43a2				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
43a2 47				db WORD_SYS_CORE+51             
43a3 3d 44			dw .SCROLL            
43a5 07				db 6 + 1 
43a6 .. 00			db "SPACES",0              
43ad				endm 
# End of macro CWHEAD
43ad			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
43ad					if DEBUG_FORTH_WORDS_KEY 
43ad						DMARK "SPS" 
43ad f5				push af  
43ae 3a c2 43			ld a, (.dmark)  
43b1 32 6e fe			ld (debug_mark),a  
43b4 3a c3 43			ld a, (.dmark+1)  
43b7 32 6f fe			ld (debug_mark+1),a  
43ba 3a c4 43			ld a, (.dmark+2)  
43bd 32 70 fe			ld (debug_mark+2),a  
43c0 18 03			jr .pastdmark  
43c2 ..			.dmark: db "SPS"  
43c5 f1			.pastdmark: pop af  
43c6			endm  
# End of macro DMARK
43c6						CALLMONITOR 
43c6 cd fb 19			call break_point_state  
43c9				endm  
# End of macro CALLMONITOR
43c9					endif 
43c9			 
43c9			 
43c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43c9 cd c2 22			call macro_dsp_valuehl 
43cc				endm 
# End of macro FORTH_DSP_VALUEHL
43cc			 
43cc e5					push hl    ; u 
43cd					if DEBUG_FORTH_WORDS 
43cd						DMARK "SPA" 
43cd f5				push af  
43ce 3a e2 43			ld a, (.dmark)  
43d1 32 6e fe			ld (debug_mark),a  
43d4 3a e3 43			ld a, (.dmark+1)  
43d7 32 6f fe			ld (debug_mark+1),a  
43da 3a e4 43			ld a, (.dmark+2)  
43dd 32 70 fe			ld (debug_mark+2),a  
43e0 18 03			jr .pastdmark  
43e2 ..			.dmark: db "SPA"  
43e5 f1			.pastdmark: pop af  
43e6			endm  
# End of macro DMARK
43e6						CALLMONITOR 
43e6 cd fb 19			call break_point_state  
43e9				endm  
# End of macro CALLMONITOR
43e9					endif 
43e9			 
43e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43e9 cd 7a 23			call macro_forth_dsp_pop 
43ec				endm 
# End of macro FORTH_DSP_POP
43ec e1					pop hl 
43ed 0e 00				ld c, 0 
43ef 45					ld b, l 
43f0 21 c4 f1				ld hl, scratch  
43f3			 
43f3					if DEBUG_FORTH_WORDS 
43f3						DMARK "SP2" 
43f3 f5				push af  
43f4 3a 08 44			ld a, (.dmark)  
43f7 32 6e fe			ld (debug_mark),a  
43fa 3a 09 44			ld a, (.dmark+1)  
43fd 32 6f fe			ld (debug_mark+1),a  
4400 3a 0a 44			ld a, (.dmark+2)  
4403 32 70 fe			ld (debug_mark+2),a  
4406 18 03			jr .pastdmark  
4408 ..			.dmark: db "SP2"  
440b f1			.pastdmark: pop af  
440c			endm  
# End of macro DMARK
440c						CALLMONITOR 
440c cd fb 19			call break_point_state  
440f				endm  
# End of macro CALLMONITOR
440f					endif 
440f 3e 20				ld a, ' ' 
4411			.spaces1:	 
4411 77					ld (hl),a 
4412 23					inc hl 
4413					 
4413 10 fc				djnz .spaces1 
4415 3e 00				ld a,0 
4417 77					ld (hl),a 
4418 21 c4 f1				ld hl, scratch 
441b					if DEBUG_FORTH_WORDS 
441b						DMARK "SP3" 
441b f5				push af  
441c 3a 30 44			ld a, (.dmark)  
441f 32 6e fe			ld (debug_mark),a  
4422 3a 31 44			ld a, (.dmark+1)  
4425 32 6f fe			ld (debug_mark+1),a  
4428 3a 32 44			ld a, (.dmark+2)  
442b 32 70 fe			ld (debug_mark+2),a  
442e 18 03			jr .pastdmark  
4430 ..			.dmark: db "SP3"  
4433 f1			.pastdmark: pop af  
4434			endm  
# End of macro DMARK
4434						CALLMONITOR 
4434 cd fb 19			call break_point_state  
4437				endm  
# End of macro CALLMONITOR
4437					endif 
4437 cd 39 21				call forth_push_str 
443a			 
443a				       NEXTW 
443a c3 78 24			jp macro_next 
443d				endm 
# End of macro NEXTW
443d			 
443d			 
443d			 
443d			.SCROLL: 
443d				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
443d 53				db WORD_SYS_CORE+63             
443e 6a 44			dw .SCROLLD            
4440 07				db 6 + 1 
4441 .. 00			db "SCROLL",0              
4448				endm 
# End of macro CWHEAD
4448			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4448					if DEBUG_FORTH_WORDS_KEY 
4448						DMARK "SCR" 
4448 f5				push af  
4449 3a 5d 44			ld a, (.dmark)  
444c 32 6e fe			ld (debug_mark),a  
444f 3a 5e 44			ld a, (.dmark+1)  
4452 32 6f fe			ld (debug_mark+1),a  
4455 3a 5f 44			ld a, (.dmark+2)  
4458 32 70 fe			ld (debug_mark+2),a  
445b 18 03			jr .pastdmark  
445d ..			.dmark: db "SCR"  
4460 f1			.pastdmark: pop af  
4461			endm  
# End of macro DMARK
4461						CALLMONITOR 
4461 cd fb 19			call break_point_state  
4464				endm  
# End of macro CALLMONITOR
4464					endif 
4464			 
4464 cd 14 0d			call scroll_up 
4467			;	call update_display 
4467			 
4467					NEXTW 
4467 c3 78 24			jp macro_next 
446a				endm 
# End of macro NEXTW
446a			 
446a			 
446a			 
446a			;		; get dir 
446a			; 
446a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
446a			; 
446a			;		push hl 
446a			; 
446a			;		; destroy value TOS 
446a			; 
446a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
446a			; 
446a			;		; get count 
446a			; 
446a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
446a			; 
446a			;		push hl 
446a			; 
446a			;		; destroy value TOS 
446a			; 
446a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
446a			; 
446a			;		; one value on hl get other one back 
446a			; 
446a			;		pop bc    ; count 
446a			; 
446a			;		pop de   ; dir 
446a			; 
446a			; 
446a			;		ld b, c 
446a			; 
446a			;.scrolldir:     push bc 
446a			;		push de 
446a			; 
446a			;		ld a, 0 
446a			;		cp e 
446a			;		jr z, .scrollup  
446a			;		call scroll_down 
446a			;		jr .scrollnext 
446a			;.scrollup:	call scroll_up 
446a			; 
446a			;		 
446a			;.scrollnext: 
446a			;		pop de 
446a			;		pop bc 
446a			;		djnz .scrolldir 
446a			; 
446a			; 
446a			; 
446a			; 
446a			; 
446a			;		NEXTW 
446a			 
446a			.SCROLLD: 
446a				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
446a 53				db WORD_SYS_CORE+63             
446b 98 44			dw .ATQ            
446d 08				db 7 + 1 
446e .. 00			db "SCROLLD",0              
4476				endm 
# End of macro CWHEAD
4476			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4476					if DEBUG_FORTH_WORDS_KEY 
4476						DMARK "SCD" 
4476 f5				push af  
4477 3a 8b 44			ld a, (.dmark)  
447a 32 6e fe			ld (debug_mark),a  
447d 3a 8c 44			ld a, (.dmark+1)  
4480 32 6f fe			ld (debug_mark+1),a  
4483 3a 8d 44			ld a, (.dmark+2)  
4486 32 70 fe			ld (debug_mark+2),a  
4489 18 03			jr .pastdmark  
448b ..			.dmark: db "SCD"  
448e f1			.pastdmark: pop af  
448f			endm  
# End of macro DMARK
448f						CALLMONITOR 
448f cd fb 19			call break_point_state  
4492				endm  
# End of macro CALLMONITOR
4492					endif 
4492			 
4492 cd 38 0d			call scroll_down 
4495			;	call update_display 
4495			 
4495					NEXTW 
4495 c3 78 24			jp macro_next 
4498				endm 
# End of macro NEXTW
4498			 
4498			 
4498			.ATQ: 
4498				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4498 62				db WORD_SYS_CORE+78             
4499 f6 44			dw .AUTODSP            
449b 04				db 3 + 1 
449c .. 00			db "AT@",0              
44a0				endm 
# End of macro CWHEAD
44a0			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
44a0					if DEBUG_FORTH_WORDS_KEY 
44a0						DMARK "ATA" 
44a0 f5				push af  
44a1 3a b5 44			ld a, (.dmark)  
44a4 32 6e fe			ld (debug_mark),a  
44a7 3a b6 44			ld a, (.dmark+1)  
44aa 32 6f fe			ld (debug_mark+1),a  
44ad 3a b7 44			ld a, (.dmark+2)  
44b0 32 70 fe			ld (debug_mark+2),a  
44b3 18 03			jr .pastdmark  
44b5 ..			.dmark: db "ATA"  
44b8 f1			.pastdmark: pop af  
44b9			endm  
# End of macro DMARK
44b9						CALLMONITOR 
44b9 cd fb 19			call break_point_state  
44bc				endm  
# End of macro CALLMONITOR
44bc					endif 
44bc			 
44bc			 
44bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44bc cd c2 22			call macro_dsp_valuehl 
44bf				endm 
# End of macro FORTH_DSP_VALUEHL
44bf			 
44bf					; TODO save cursor row 
44bf 7d					ld a,l 
44c0 fe 02				cp 2 
44c2 20 04				jr nz, .crow3aq 
44c4 3e 28				ld a, display_row_2 
44c6 18 12				jr .ccol1aq 
44c8 fe 03		.crow3aq:		cp 3 
44ca 20 04				jr nz, .crow4aq 
44cc 3e 50				ld a, display_row_3 
44ce 18 0a				jr .ccol1aq 
44d0 fe 04		.crow4aq:		cp 4 
44d2 20 04				jr nz, .crow1aq 
44d4 3e 78				ld a, display_row_4 
44d6 18 02				jr .ccol1aq 
44d8 3e 00		.crow1aq:		ld a,display_row_1 
44da f5			.ccol1aq:		push af			; got row offset 
44db 6f					ld l,a 
44dc 26 00				ld h,0 
44de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44de cd 7a 23			call macro_forth_dsp_pop 
44e1				endm 
# End of macro FORTH_DSP_POP
44e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44e1 cd c2 22			call macro_dsp_valuehl 
44e4				endm 
# End of macro FORTH_DSP_VALUEHL
44e4					; TODO save cursor col 
44e4 f1					pop af 
44e5 85					add l		; add col offset 
44e6			 
44e6					; add current frame buffer address 
44e6 2a cf fb				ld hl, (display_fb_active) 
44e9 cd 86 0f				call addatohl 
44ec			 
44ec			 
44ec			 
44ec			 
44ec					; get char frame buffer location offset in hl 
44ec			 
44ec 7e					ld a,(hl) 
44ed 26 00				ld h, 0 
44ef 6f					ld l, a 
44f0			 
44f0 cd cb 20				call forth_push_numhl 
44f3			 
44f3			 
44f3					NEXTW 
44f3 c3 78 24			jp macro_next 
44f6				endm 
# End of macro NEXTW
44f6			 
44f6			.AUTODSP: 
44f6				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
44f6 63				db WORD_SYS_CORE+79             
44f7 0c 45			dw .MENU            
44f9 05				db 4 + 1 
44fa .. 00			db "ADSP",0              
44ff				endm 
# End of macro CWHEAD
44ff			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
44ff			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
44ff			 
44ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44ff cd c2 22			call macro_dsp_valuehl 
4502				endm 
# End of macro FORTH_DSP_VALUEHL
4502			 
4502			;		push hl 
4502			 
4502					; destroy value TOS 
4502			 
4502					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4502 cd 7a 23			call macro_forth_dsp_pop 
4505				endm 
# End of macro FORTH_DSP_POP
4505			 
4505			;		pop hl 
4505			 
4505 7d					ld a,l 
4506 32 3f fa				ld (cli_autodisplay), a 
4509				       NEXTW 
4509 c3 78 24			jp macro_next 
450c				endm 
# End of macro NEXTW
450c			 
450c			.MENU: 
450c				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
450c 70				db WORD_SYS_CORE+92             
450d b5 45			dw .ENDDISPLAY            
450f 05				db 4 + 1 
4510 .. 00			db "MENU",0              
4515				endm 
# End of macro CWHEAD
4515			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4515			 
4515			;		; get number of items on the stack 
4515			; 
4515				 
4515					FORTH_DSP_VALUEHL 
4515 cd c2 22			call macro_dsp_valuehl 
4518				endm 
# End of macro FORTH_DSP_VALUEHL
4518				 
4518					if DEBUG_FORTH_WORDS_KEY 
4518						DMARK "MNU" 
4518 f5				push af  
4519 3a 2d 45			ld a, (.dmark)  
451c 32 6e fe			ld (debug_mark),a  
451f 3a 2e 45			ld a, (.dmark+1)  
4522 32 6f fe			ld (debug_mark+1),a  
4525 3a 2f 45			ld a, (.dmark+2)  
4528 32 70 fe			ld (debug_mark+2),a  
452b 18 03			jr .pastdmark  
452d ..			.dmark: db "MNU"  
4530 f1			.pastdmark: pop af  
4531			endm  
# End of macro DMARK
4531						CALLMONITOR 
4531 cd fb 19			call break_point_state  
4534				endm  
# End of macro CALLMONITOR
4534					endif 
4534			 
4534 45					ld b, l	 
4535 05					dec b 
4536			 
4536					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4536 cd 7a 23			call macro_forth_dsp_pop 
4539				endm 
# End of macro FORTH_DSP_POP
4539			 
4539			 
4539					; go directly through the stack to pluck out the string pointers and build an array 
4539			 
4539			;		FORTH_DSP 
4539			 
4539					; hl contains top most stack item 
4539				 
4539 11 c4 f1				ld de, scratch 
453c			 
453c			.mbuild: 
453c			 
453c					FORTH_DSP_VALUEHL 
453c cd c2 22			call macro_dsp_valuehl 
453f				endm 
# End of macro FORTH_DSP_VALUEHL
453f			 
453f					if DEBUG_FORTH_WORDS 
453f						DMARK "MN3" 
453f f5				push af  
4540 3a 54 45			ld a, (.dmark)  
4543 32 6e fe			ld (debug_mark),a  
4546 3a 55 45			ld a, (.dmark+1)  
4549 32 6f fe			ld (debug_mark+1),a  
454c 3a 56 45			ld a, (.dmark+2)  
454f 32 70 fe			ld (debug_mark+2),a  
4552 18 03			jr .pastdmark  
4554 ..			.dmark: db "MN3"  
4557 f1			.pastdmark: pop af  
4558			endm  
# End of macro DMARK
4558						CALLMONITOR 
4558 cd fb 19			call break_point_state  
455b				endm  
# End of macro CALLMONITOR
455b					endif 
455b eb					ex de, hl 
455c 73					ld (hl), e 
455d 23					inc hl 
455e 72					ld (hl), d 
455f 23					inc hl 
4560 eb					ex de, hl 
4561			 
4561					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4561 cd 7a 23			call macro_forth_dsp_pop 
4564				endm 
# End of macro FORTH_DSP_POP
4564			 
4564 10 d6				djnz .mbuild 
4566			 
4566					; done add term 
4566			 
4566 eb					ex de, hl 
4567 36 00				ld (hl), 0 
4569 23					inc hl 
456a 36 00				ld (hl), 0 
456c			 
456c				 
456c					 
456c 21 c4 f1				ld hl, scratch 
456f			 
456f					if DEBUG_FORTH_WORDS 
456f						DMARK "MNx" 
456f f5				push af  
4570 3a 84 45			ld a, (.dmark)  
4573 32 6e fe			ld (debug_mark),a  
4576 3a 85 45			ld a, (.dmark+1)  
4579 32 6f fe			ld (debug_mark+1),a  
457c 3a 86 45			ld a, (.dmark+2)  
457f 32 70 fe			ld (debug_mark+2),a  
4582 18 03			jr .pastdmark  
4584 ..			.dmark: db "MNx"  
4587 f1			.pastdmark: pop af  
4588			endm  
# End of macro DMARK
4588						CALLMONITOR 
4588 cd fb 19			call break_point_state  
458b				endm  
# End of macro CALLMONITOR
458b					endif 
458b			 
458b			 
458b			 
458b 3e 00				ld a, 0 
458d cd 83 0d				call menu 
4590			 
4590			 
4590 6f					ld l, a 
4591 26 00				ld h, 0 
4593			 
4593					if DEBUG_FORTH_WORDS 
4593						DMARK "MNr" 
4593 f5				push af  
4594 3a a8 45			ld a, (.dmark)  
4597 32 6e fe			ld (debug_mark),a  
459a 3a a9 45			ld a, (.dmark+1)  
459d 32 6f fe			ld (debug_mark+1),a  
45a0 3a aa 45			ld a, (.dmark+2)  
45a3 32 70 fe			ld (debug_mark+2),a  
45a6 18 03			jr .pastdmark  
45a8 ..			.dmark: db "MNr"  
45ab f1			.pastdmark: pop af  
45ac			endm  
# End of macro DMARK
45ac						CALLMONITOR 
45ac cd fb 19			call break_point_state  
45af				endm  
# End of macro CALLMONITOR
45af					endif 
45af			 
45af cd cb 20				call forth_push_numhl 
45b2			 
45b2			 
45b2			 
45b2			 
45b2				       NEXTW 
45b2 c3 78 24			jp macro_next 
45b5				endm 
# End of macro NEXTW
45b5			 
45b5			 
45b5			.ENDDISPLAY: 
45b5			 
45b5			; eof 
# End of file forth_words_display.asm
45b5			include "forth_words_str.asm" 
45b5			 
45b5			; | ## String Words 
45b5			 
45b5			.PTR:   
45b5			 
45b5				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
45b5 48				db WORD_SYS_CORE+52             
45b6 e2 45			dw .STYPE            
45b8 04				db 3 + 1 
45b9 .. 00			db "PTR",0              
45bd				endm 
# End of macro CWHEAD
45bd			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
45bd			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
45bd			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
45bd			 
45bd					if DEBUG_FORTH_WORDS_KEY 
45bd						DMARK "PTR" 
45bd f5				push af  
45be 3a d2 45			ld a, (.dmark)  
45c1 32 6e fe			ld (debug_mark),a  
45c4 3a d3 45			ld a, (.dmark+1)  
45c7 32 6f fe			ld (debug_mark+1),a  
45ca 3a d4 45			ld a, (.dmark+2)  
45cd 32 70 fe			ld (debug_mark+2),a  
45d0 18 03			jr .pastdmark  
45d2 ..			.dmark: db "PTR"  
45d5 f1			.pastdmark: pop af  
45d6			endm  
# End of macro DMARK
45d6						CALLMONITOR 
45d6 cd fb 19			call break_point_state  
45d9				endm  
# End of macro CALLMONITOR
45d9					endif 
45d9					FORTH_DSP_VALUEHL 
45d9 cd c2 22			call macro_dsp_valuehl 
45dc				endm 
# End of macro FORTH_DSP_VALUEHL
45dc cd cb 20				call forth_push_numhl 
45df			 
45df			 
45df					NEXTW 
45df c3 78 24			jp macro_next 
45e2				endm 
# End of macro NEXTW
45e2			.STYPE: 
45e2				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
45e2 48				db WORD_SYS_CORE+52             
45e3 31 46			dw .UPPER            
45e5 06				db 5 + 1 
45e6 .. 00			db "STYPE",0              
45ec				endm 
# End of macro CWHEAD
45ec			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
45ec					if DEBUG_FORTH_WORDS_KEY 
45ec						DMARK "STY" 
45ec f5				push af  
45ed 3a 01 46			ld a, (.dmark)  
45f0 32 6e fe			ld (debug_mark),a  
45f3 3a 02 46			ld a, (.dmark+1)  
45f6 32 6f fe			ld (debug_mark+1),a  
45f9 3a 03 46			ld a, (.dmark+2)  
45fc 32 70 fe			ld (debug_mark+2),a  
45ff 18 03			jr .pastdmark  
4601 ..			.dmark: db "STY"  
4604 f1			.pastdmark: pop af  
4605			endm  
# End of macro DMARK
4605						CALLMONITOR 
4605 cd fb 19			call break_point_state  
4608				endm  
# End of macro CALLMONITOR
4608					endif 
4608					FORTH_DSP 
4608 cd 88 22			call macro_forth_dsp 
460b				endm 
# End of macro FORTH_DSP
460b					;v5 FORTH_DSP_VALUE 
460b			 
460b 7e					ld a, (hl) 
460c			 
460c f5					push af 
460d			 
460d			; Dont destroy TOS		FORTH_DSP_POP 
460d			 
460d f1					pop af 
460e			 
460e fe 01				cp DS_TYPE_STR 
4610 28 09				jr z, .typestr 
4612			 
4612 fe 02				cp DS_TYPE_INUM 
4614 28 0a				jr z, .typeinum 
4616			 
4616 21 2f 46				ld hl, .tna 
4619 18 0a				jr .tpush 
461b			 
461b 21 2b 46		.typestr:	ld hl, .tstr 
461e 18 05				jr .tpush 
4620 21 2d 46		.typeinum:	ld hl, .tinum 
4623 18 00				jr .tpush 
4625			 
4625			.tpush: 
4625			 
4625 cd 39 21				call forth_push_str 
4628			 
4628					NEXTW 
4628 c3 78 24			jp macro_next 
462b				endm 
# End of macro NEXTW
462b .. 00		.tstr:	db "s",0 
462d .. 00		.tinum:  db "i",0 
462f .. 00		.tna:   db "?", 0 
4631			 
4631			 
4631			.UPPER: 
4631				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4631 48				db WORD_SYS_CORE+52             
4632 6c 46			dw .LOWER            
4634 06				db 5 + 1 
4635 .. 00			db "UPPER",0              
463b				endm 
# End of macro CWHEAD
463b			; | UPPER ( s -- s ) Upper case string s  | DONE 
463b					if DEBUG_FORTH_WORDS_KEY 
463b						DMARK "UPR" 
463b f5				push af  
463c 3a 50 46			ld a, (.dmark)  
463f 32 6e fe			ld (debug_mark),a  
4642 3a 51 46			ld a, (.dmark+1)  
4645 32 6f fe			ld (debug_mark+1),a  
4648 3a 52 46			ld a, (.dmark+2)  
464b 32 70 fe			ld (debug_mark+2),a  
464e 18 03			jr .pastdmark  
4650 ..			.dmark: db "UPR"  
4653 f1			.pastdmark: pop af  
4654			endm  
# End of macro DMARK
4654						CALLMONITOR 
4654 cd fb 19			call break_point_state  
4657				endm  
# End of macro CALLMONITOR
4657					endif 
4657			 
4657					FORTH_DSP 
4657 cd 88 22			call macro_forth_dsp 
465a				endm 
# End of macro FORTH_DSP
465a					 
465a			; TODO check is string type 
465a			 
465a					FORTH_DSP_VALUEHL 
465a cd c2 22			call macro_dsp_valuehl 
465d				endm 
# End of macro FORTH_DSP_VALUEHL
465d			; get pointer to string in hl 
465d			 
465d 7e			.toup:		ld a, (hl) 
465e fe 00				cp 0 
4660 28 07				jr z, .toupdone 
4662			 
4662 cd f3 12				call to_upper 
4665			 
4665 77					ld (hl), a 
4666 23					inc hl 
4667 18 f4				jr .toup 
4669			 
4669					 
4669			 
4669			 
4669			; for each char convert to upper 
4669					 
4669			.toupdone: 
4669			 
4669			 
4669					NEXTW 
4669 c3 78 24			jp macro_next 
466c				endm 
# End of macro NEXTW
466c			.LOWER: 
466c				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
466c 48				db WORD_SYS_CORE+52             
466d a7 46			dw .TCASE            
466f 06				db 5 + 1 
4670 .. 00			db "LOWER",0              
4676				endm 
# End of macro CWHEAD
4676			; | LOWER ( s -- s ) Lower case string s  | DONE 
4676					if DEBUG_FORTH_WORDS_KEY 
4676						DMARK "LWR" 
4676 f5				push af  
4677 3a 8b 46			ld a, (.dmark)  
467a 32 6e fe			ld (debug_mark),a  
467d 3a 8c 46			ld a, (.dmark+1)  
4680 32 6f fe			ld (debug_mark+1),a  
4683 3a 8d 46			ld a, (.dmark+2)  
4686 32 70 fe			ld (debug_mark+2),a  
4689 18 03			jr .pastdmark  
468b ..			.dmark: db "LWR"  
468e f1			.pastdmark: pop af  
468f			endm  
# End of macro DMARK
468f						CALLMONITOR 
468f cd fb 19			call break_point_state  
4692				endm  
# End of macro CALLMONITOR
4692					endif 
4692			 
4692					FORTH_DSP 
4692 cd 88 22			call macro_forth_dsp 
4695				endm 
# End of macro FORTH_DSP
4695					 
4695			; TODO check is string type 
4695			 
4695					FORTH_DSP_VALUEHL 
4695 cd c2 22			call macro_dsp_valuehl 
4698				endm 
# End of macro FORTH_DSP_VALUEHL
4698			; get pointer to string in hl 
4698			 
4698 7e			.tolow:		ld a, (hl) 
4699 fe 00				cp 0 
469b 28 07				jr z, .tolowdone 
469d			 
469d cd fc 12				call to_lower 
46a0			 
46a0 77					ld (hl), a 
46a1 23					inc hl 
46a2 18 f4				jr .tolow 
46a4			 
46a4					 
46a4			 
46a4			 
46a4			; for each char convert to low 
46a4					 
46a4			.tolowdone: 
46a4					NEXTW 
46a4 c3 78 24			jp macro_next 
46a7				endm 
# End of macro NEXTW
46a7			.TCASE: 
46a7				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
46a7 48				db WORD_SYS_CORE+52             
46a8 dd 47			dw .SUBSTR            
46aa 06				db 5 + 1 
46ab .. 00			db "TCASE",0              
46b1				endm 
# End of macro CWHEAD
46b1			; | TCASE ( s -- s ) Title case string s  | DONE 
46b1					if DEBUG_FORTH_WORDS_KEY 
46b1						DMARK "TCS" 
46b1 f5				push af  
46b2 3a c6 46			ld a, (.dmark)  
46b5 32 6e fe			ld (debug_mark),a  
46b8 3a c7 46			ld a, (.dmark+1)  
46bb 32 6f fe			ld (debug_mark+1),a  
46be 3a c8 46			ld a, (.dmark+2)  
46c1 32 70 fe			ld (debug_mark+2),a  
46c4 18 03			jr .pastdmark  
46c6 ..			.dmark: db "TCS"  
46c9 f1			.pastdmark: pop af  
46ca			endm  
# End of macro DMARK
46ca						CALLMONITOR 
46ca cd fb 19			call break_point_state  
46cd				endm  
# End of macro CALLMONITOR
46cd					endif 
46cd			 
46cd					FORTH_DSP 
46cd cd 88 22			call macro_forth_dsp 
46d0				endm 
# End of macro FORTH_DSP
46d0					 
46d0			; TODO check is string type 
46d0			 
46d0					FORTH_DSP_VALUEHL 
46d0 cd c2 22			call macro_dsp_valuehl 
46d3				endm 
# End of macro FORTH_DSP_VALUEHL
46d3			; get pointer to string in hl 
46d3			 
46d3					if DEBUG_FORTH_WORDS 
46d3						DMARK "TC1" 
46d3 f5				push af  
46d4 3a e8 46			ld a, (.dmark)  
46d7 32 6e fe			ld (debug_mark),a  
46da 3a e9 46			ld a, (.dmark+1)  
46dd 32 6f fe			ld (debug_mark+1),a  
46e0 3a ea 46			ld a, (.dmark+2)  
46e3 32 70 fe			ld (debug_mark+2),a  
46e6 18 03			jr .pastdmark  
46e8 ..			.dmark: db "TC1"  
46eb f1			.pastdmark: pop af  
46ec			endm  
# End of macro DMARK
46ec						CALLMONITOR 
46ec cd fb 19			call break_point_state  
46ef				endm  
# End of macro CALLMONITOR
46ef					endif 
46ef			 
46ef					; first time in turn to upper case first char 
46ef			 
46ef 7e					ld a, (hl) 
46f0 c3 7a 47				jp .totsiptou 
46f3			 
46f3			 
46f3 7e			.tot:		ld a, (hl) 
46f4 fe 00				cp 0 
46f6 ca be 47				jp z, .totdone 
46f9			 
46f9					if DEBUG_FORTH_WORDS 
46f9						DMARK "TC2" 
46f9 f5				push af  
46fa 3a 0e 47			ld a, (.dmark)  
46fd 32 6e fe			ld (debug_mark),a  
4700 3a 0f 47			ld a, (.dmark+1)  
4703 32 6f fe			ld (debug_mark+1),a  
4706 3a 10 47			ld a, (.dmark+2)  
4709 32 70 fe			ld (debug_mark+2),a  
470c 18 03			jr .pastdmark  
470e ..			.dmark: db "TC2"  
4711 f1			.pastdmark: pop af  
4712			endm  
# End of macro DMARK
4712						CALLMONITOR 
4712 cd fb 19			call break_point_state  
4715				endm  
# End of macro CALLMONITOR
4715					endif 
4715					; check to see if current char is a space 
4715			 
4715 fe 20				cp ' ' 
4717 28 21				jr z, .totsp 
4719 cd fc 12				call to_lower 
471c					if DEBUG_FORTH_WORDS 
471c						DMARK "TC3" 
471c f5				push af  
471d 3a 31 47			ld a, (.dmark)  
4720 32 6e fe			ld (debug_mark),a  
4723 3a 32 47			ld a, (.dmark+1)  
4726 32 6f fe			ld (debug_mark+1),a  
4729 3a 33 47			ld a, (.dmark+2)  
472c 32 70 fe			ld (debug_mark+2),a  
472f 18 03			jr .pastdmark  
4731 ..			.dmark: db "TC3"  
4734 f1			.pastdmark: pop af  
4735			endm  
# End of macro DMARK
4735						CALLMONITOR 
4735 cd fb 19			call break_point_state  
4738				endm  
# End of macro CALLMONITOR
4738					endif 
4738 18 63				jr .totnxt 
473a			 
473a			.totsp:         ; on a space, find next char which should be upper 
473a			 
473a					if DEBUG_FORTH_WORDS 
473a						DMARK "TC4" 
473a f5				push af  
473b 3a 4f 47			ld a, (.dmark)  
473e 32 6e fe			ld (debug_mark),a  
4741 3a 50 47			ld a, (.dmark+1)  
4744 32 6f fe			ld (debug_mark+1),a  
4747 3a 51 47			ld a, (.dmark+2)  
474a 32 70 fe			ld (debug_mark+2),a  
474d 18 03			jr .pastdmark  
474f ..			.dmark: db "TC4"  
4752 f1			.pastdmark: pop af  
4753			endm  
# End of macro DMARK
4753						CALLMONITOR 
4753 cd fb 19			call break_point_state  
4756				endm  
# End of macro CALLMONITOR
4756					endif 
4756					;; 
4756			 
4756 fe 20				cp ' ' 
4758 20 20				jr nz, .totsiptou 
475a 23					inc hl 
475b 7e					ld a, (hl) 
475c					if DEBUG_FORTH_WORDS 
475c						DMARK "TC5" 
475c f5				push af  
475d 3a 71 47			ld a, (.dmark)  
4760 32 6e fe			ld (debug_mark),a  
4763 3a 72 47			ld a, (.dmark+1)  
4766 32 6f fe			ld (debug_mark+1),a  
4769 3a 73 47			ld a, (.dmark+2)  
476c 32 70 fe			ld (debug_mark+2),a  
476f 18 03			jr .pastdmark  
4771 ..			.dmark: db "TC5"  
4774 f1			.pastdmark: pop af  
4775			endm  
# End of macro DMARK
4775						CALLMONITOR 
4775 cd fb 19			call break_point_state  
4778				endm  
# End of macro CALLMONITOR
4778					endif 
4778 18 c0				jr .totsp 
477a fe 00		.totsiptou:    cp 0 
477c 28 40				jr z, .totdone 
477e					; not space and not zero term so upper case it 
477e cd f3 12				call to_upper 
4781			 
4781					if DEBUG_FORTH_WORDS 
4781						DMARK "TC6" 
4781 f5				push af  
4782 3a 96 47			ld a, (.dmark)  
4785 32 6e fe			ld (debug_mark),a  
4788 3a 97 47			ld a, (.dmark+1)  
478b 32 6f fe			ld (debug_mark+1),a  
478e 3a 98 47			ld a, (.dmark+2)  
4791 32 70 fe			ld (debug_mark+2),a  
4794 18 03			jr .pastdmark  
4796 ..			.dmark: db "TC6"  
4799 f1			.pastdmark: pop af  
479a			endm  
# End of macro DMARK
479a						CALLMONITOR 
479a cd fb 19			call break_point_state  
479d				endm  
# End of macro CALLMONITOR
479d					endif 
479d			 
479d			 
479d			.totnxt: 
479d			 
479d 77					ld (hl), a 
479e 23					inc hl 
479f					if DEBUG_FORTH_WORDS 
479f						DMARK "TC7" 
479f f5				push af  
47a0 3a b4 47			ld a, (.dmark)  
47a3 32 6e fe			ld (debug_mark),a  
47a6 3a b5 47			ld a, (.dmark+1)  
47a9 32 6f fe			ld (debug_mark+1),a  
47ac 3a b6 47			ld a, (.dmark+2)  
47af 32 70 fe			ld (debug_mark+2),a  
47b2 18 03			jr .pastdmark  
47b4 ..			.dmark: db "TC7"  
47b7 f1			.pastdmark: pop af  
47b8			endm  
# End of macro DMARK
47b8						CALLMONITOR 
47b8 cd fb 19			call break_point_state  
47bb				endm  
# End of macro CALLMONITOR
47bb					endif 
47bb c3 f3 46				jp .tot 
47be			 
47be					 
47be			 
47be			 
47be			; for each char convert to low 
47be					 
47be			.totdone: 
47be					if DEBUG_FORTH_WORDS 
47be						DMARK "TCd" 
47be f5				push af  
47bf 3a d3 47			ld a, (.dmark)  
47c2 32 6e fe			ld (debug_mark),a  
47c5 3a d4 47			ld a, (.dmark+1)  
47c8 32 6f fe			ld (debug_mark+1),a  
47cb 3a d5 47			ld a, (.dmark+2)  
47ce 32 70 fe			ld (debug_mark+2),a  
47d1 18 03			jr .pastdmark  
47d3 ..			.dmark: db "TCd"  
47d6 f1			.pastdmark: pop af  
47d7			endm  
# End of macro DMARK
47d7						CALLMONITOR 
47d7 cd fb 19			call break_point_state  
47da				endm  
# End of macro CALLMONITOR
47da					endif 
47da					NEXTW 
47da c3 78 24			jp macro_next 
47dd				endm 
# End of macro NEXTW
47dd			 
47dd			.SUBSTR: 
47dd				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
47dd 48				db WORD_SYS_CORE+52             
47de 3b 48			dw .LEFT            
47e0 07				db 6 + 1 
47e1 .. 00			db "SUBSTR",0              
47e8				endm 
# End of macro CWHEAD
47e8			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
47e8			 
47e8					if DEBUG_FORTH_WORDS_KEY 
47e8						DMARK "SST" 
47e8 f5				push af  
47e9 3a fd 47			ld a, (.dmark)  
47ec 32 6e fe			ld (debug_mark),a  
47ef 3a fe 47			ld a, (.dmark+1)  
47f2 32 6f fe			ld (debug_mark+1),a  
47f5 3a ff 47			ld a, (.dmark+2)  
47f8 32 70 fe			ld (debug_mark+2),a  
47fb 18 03			jr .pastdmark  
47fd ..			.dmark: db "SST"  
4800 f1			.pastdmark: pop af  
4801			endm  
# End of macro DMARK
4801						CALLMONITOR 
4801 cd fb 19			call break_point_state  
4804				endm  
# End of macro CALLMONITOR
4804					endif 
4804			; TODO check string type 
4804					FORTH_DSP_VALUEHL 
4804 cd c2 22			call macro_dsp_valuehl 
4807				endm 
# End of macro FORTH_DSP_VALUEHL
4807			 
4807 e5					push hl      ; string length 
4808			 
4808					FORTH_DSP_POP 
4808 cd 7a 23			call macro_forth_dsp_pop 
480b				endm 
# End of macro FORTH_DSP_POP
480b			 
480b					FORTH_DSP_VALUEHL 
480b cd c2 22			call macro_dsp_valuehl 
480e				endm 
# End of macro FORTH_DSP_VALUEHL
480e			 
480e e5					push hl     ; start char 
480f			 
480f					FORTH_DSP_POP 
480f cd 7a 23			call macro_forth_dsp_pop 
4812				endm 
# End of macro FORTH_DSP_POP
4812			 
4812			 
4812					FORTH_DSP_VALUE 
4812 cd ab 22			call macro_forth_dsp_value 
4815				endm 
# End of macro FORTH_DSP_VALUE
4815			 
4815 d1					pop de    ; get start post offset 
4816			 
4816 19					add hl, de    ; starting offset 
4817			 
4817 c1					pop bc 
4818 c5					push bc      ; grab size of string 
4819			 
4819 e5					push hl    ; save string start  
481a			 
481a 26 00				ld h, 0 
481c 69					ld l, c 
481d 23					inc hl 
481e 23					inc hl 
481f			 
481f cd 4d 14				call malloc 
4822				if DEBUG_FORTH_MALLOC_GUARD 
4822 cc 96 5d				call z,malloc_error 
4825				endif 
4825			 
4825 eb					ex de, hl      ; save malloc area for string copy 
4826 e1					pop hl    ; get back source 
4827 c1					pop bc    ; get length of string back 
4828			 
4828 d5					push de    ; save malloc area for after we push 
4829 ed b0				ldir     ; copy substr 
482b			 
482b			 
482b eb					ex de, hl 
482c 3e 00				ld a, 0 
482e 77					ld (hl), a   ; term substr 
482f			 
482f					 
482f e1					pop hl    ; get malloc so we can push it 
4830 e5					push hl   ; save so we can free it afterwards 
4831			 
4831 cd 39 21				call forth_push_str 
4834			 
4834 e1					pop hl 
4835 cd 17 15				call free 
4838			 
4838					 
4838					 
4838			 
4838			 
4838					NEXTW 
4838 c3 78 24			jp macro_next 
483b				endm 
# End of macro NEXTW
483b			 
483b			.LEFT: 
483b				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
483b 48				db WORD_SYS_CORE+52             
483c 63 48			dw .RIGHT            
483e 05				db 4 + 1 
483f .. 00			db "LEFT",0              
4844				endm 
# End of macro CWHEAD
4844			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4844					if DEBUG_FORTH_WORDS_KEY 
4844						DMARK "LEF" 
4844 f5				push af  
4845 3a 59 48			ld a, (.dmark)  
4848 32 6e fe			ld (debug_mark),a  
484b 3a 5a 48			ld a, (.dmark+1)  
484e 32 6f fe			ld (debug_mark+1),a  
4851 3a 5b 48			ld a, (.dmark+2)  
4854 32 70 fe			ld (debug_mark+2),a  
4857 18 03			jr .pastdmark  
4859 ..			.dmark: db "LEF"  
485c f1			.pastdmark: pop af  
485d			endm  
# End of macro DMARK
485d						CALLMONITOR 
485d cd fb 19			call break_point_state  
4860				endm  
# End of macro CALLMONITOR
4860					endif 
4860			 
4860					NEXTW 
4860 c3 78 24			jp macro_next 
4863				endm 
# End of macro NEXTW
4863			.RIGHT: 
4863				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4863 48				db WORD_SYS_CORE+52             
4864 8c 48			dw .STR2NUM            
4866 06				db 5 + 1 
4867 .. 00			db "RIGHT",0              
486d				endm 
# End of macro CWHEAD
486d			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
486d					if DEBUG_FORTH_WORDS_KEY 
486d						DMARK "RIG" 
486d f5				push af  
486e 3a 82 48			ld a, (.dmark)  
4871 32 6e fe			ld (debug_mark),a  
4874 3a 83 48			ld a, (.dmark+1)  
4877 32 6f fe			ld (debug_mark+1),a  
487a 3a 84 48			ld a, (.dmark+2)  
487d 32 70 fe			ld (debug_mark+2),a  
4880 18 03			jr .pastdmark  
4882 ..			.dmark: db "RIG"  
4885 f1			.pastdmark: pop af  
4886			endm  
# End of macro DMARK
4886						CALLMONITOR 
4886 cd fb 19			call break_point_state  
4889				endm  
# End of macro CALLMONITOR
4889					endif 
4889			 
4889					NEXTW 
4889 c3 78 24			jp macro_next 
488c				endm 
# End of macro NEXTW
488c			 
488c			 
488c			.STR2NUM: 
488c				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
488c 48				db WORD_SYS_CORE+52             
488d 18 49			dw .NUM2STR            
488f 08				db 7 + 1 
4890 .. 00			db "STR2NUM",0              
4898				endm 
# End of macro CWHEAD
4898			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4898			 
4898			 
4898			; TODO STR type check to do 
4898					if DEBUG_FORTH_WORDS_KEY 
4898						DMARK "S2N" 
4898 f5				push af  
4899 3a ad 48			ld a, (.dmark)  
489c 32 6e fe			ld (debug_mark),a  
489f 3a ae 48			ld a, (.dmark+1)  
48a2 32 6f fe			ld (debug_mark+1),a  
48a5 3a af 48			ld a, (.dmark+2)  
48a8 32 70 fe			ld (debug_mark+2),a  
48ab 18 03			jr .pastdmark  
48ad ..			.dmark: db "S2N"  
48b0 f1			.pastdmark: pop af  
48b1			endm  
# End of macro DMARK
48b1						CALLMONITOR 
48b1 cd fb 19			call break_point_state  
48b4				endm  
# End of macro CALLMONITOR
48b4					endif 
48b4			 
48b4					;FORTH_DSP 
48b4					FORTH_DSP_VALUE 
48b4 cd ab 22			call macro_forth_dsp_value 
48b7				endm 
# End of macro FORTH_DSP_VALUE
48b7					;inc hl 
48b7			 
48b7 eb					ex de, hl 
48b8					if DEBUG_FORTH_WORDS 
48b8						DMARK "S2a" 
48b8 f5				push af  
48b9 3a cd 48			ld a, (.dmark)  
48bc 32 6e fe			ld (debug_mark),a  
48bf 3a ce 48			ld a, (.dmark+1)  
48c2 32 6f fe			ld (debug_mark+1),a  
48c5 3a cf 48			ld a, (.dmark+2)  
48c8 32 70 fe			ld (debug_mark+2),a  
48cb 18 03			jr .pastdmark  
48cd ..			.dmark: db "S2a"  
48d0 f1			.pastdmark: pop af  
48d1			endm  
# End of macro DMARK
48d1						CALLMONITOR 
48d1 cd fb 19			call break_point_state  
48d4				endm  
# End of macro CALLMONITOR
48d4					endif 
48d4 cd 7b 13				call string_to_uint16 
48d7			 
48d7					if DEBUG_FORTH_WORDS 
48d7						DMARK "S2b" 
48d7 f5				push af  
48d8 3a ec 48			ld a, (.dmark)  
48db 32 6e fe			ld (debug_mark),a  
48de 3a ed 48			ld a, (.dmark+1)  
48e1 32 6f fe			ld (debug_mark+1),a  
48e4 3a ee 48			ld a, (.dmark+2)  
48e7 32 70 fe			ld (debug_mark+2),a  
48ea 18 03			jr .pastdmark  
48ec ..			.dmark: db "S2b"  
48ef f1			.pastdmark: pop af  
48f0			endm  
# End of macro DMARK
48f0						CALLMONITOR 
48f0 cd fb 19			call break_point_state  
48f3				endm  
# End of macro CALLMONITOR
48f3					endif 
48f3			;		push hl 
48f3					FORTH_DSP_POP 
48f3 cd 7a 23			call macro_forth_dsp_pop 
48f6				endm 
# End of macro FORTH_DSP_POP
48f6			;		pop hl 
48f6					 
48f6					if DEBUG_FORTH_WORDS 
48f6						DMARK "S2b" 
48f6 f5				push af  
48f7 3a 0b 49			ld a, (.dmark)  
48fa 32 6e fe			ld (debug_mark),a  
48fd 3a 0c 49			ld a, (.dmark+1)  
4900 32 6f fe			ld (debug_mark+1),a  
4903 3a 0d 49			ld a, (.dmark+2)  
4906 32 70 fe			ld (debug_mark+2),a  
4909 18 03			jr .pastdmark  
490b ..			.dmark: db "S2b"  
490e f1			.pastdmark: pop af  
490f			endm  
# End of macro DMARK
490f						CALLMONITOR 
490f cd fb 19			call break_point_state  
4912				endm  
# End of macro CALLMONITOR
4912					endif 
4912 cd cb 20				call forth_push_numhl	 
4915			 
4915				 
4915				       NEXTW 
4915 c3 78 24			jp macro_next 
4918				endm 
# End of macro NEXTW
4918			.NUM2STR: 
4918				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4918 48				db WORD_SYS_CORE+52             
4919 27 49			dw .CONCAT            
491b 08				db 7 + 1 
491c .. 00			db "NUM2STR",0              
4924				endm 
# End of macro CWHEAD
4924			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4924			 
4924			;		; malloc a string to target 
4924			;		ld hl, 10     ; TODO max string size should be fine 
4924			;		call malloc 
4924			;		push hl    ; save malloc location 
4924			; 
4924			; 
4924			;; TODO check int type 
4924			;		FORTH_DSP_VALUEHL 
4924			;		ld a, l 
4924			;		call DispAToASCII   
4924			;;TODO need to chage above call to dump into string 
4924			; 
4924			; 
4924			 
4924				       NEXTW 
4924 c3 78 24			jp macro_next 
4927				endm 
# End of macro NEXTW
4927			 
4927			.CONCAT: 
4927				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4927 48				db WORD_SYS_CORE+52             
4928 da 49			dw .FIND            
492a 07				db 6 + 1 
492b .. 00			db "CONCAT",0              
4932				endm 
# End of macro CWHEAD
4932			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4932			 
4932			; TODO check string type 
4932			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4932			 
4932					if DEBUG_FORTH_WORDS_KEY 
4932						DMARK "CON" 
4932 f5				push af  
4933 3a 47 49			ld a, (.dmark)  
4936 32 6e fe			ld (debug_mark),a  
4939 3a 48 49			ld a, (.dmark+1)  
493c 32 6f fe			ld (debug_mark+1),a  
493f 3a 49 49			ld a, (.dmark+2)  
4942 32 70 fe			ld (debug_mark+2),a  
4945 18 03			jr .pastdmark  
4947 ..			.dmark: db "CON"  
494a f1			.pastdmark: pop af  
494b			endm  
# End of macro DMARK
494b						CALLMONITOR 
494b cd fb 19			call break_point_state  
494e				endm  
# End of macro CALLMONITOR
494e					endif 
494e			 
494e			 
494e					FORTH_DSP_VALUE 
494e cd ab 22			call macro_forth_dsp_value 
4951				endm 
# End of macro FORTH_DSP_VALUE
4951 e5					push hl   ; s2 
4952			 
4952					FORTH_DSP_POP 
4952 cd 7a 23			call macro_forth_dsp_pop 
4955				endm 
# End of macro FORTH_DSP_POP
4955			 
4955					FORTH_DSP_VALUE 
4955 cd ab 22			call macro_forth_dsp_value 
4958				endm 
# End of macro FORTH_DSP_VALUE
4958			 
4958 e5					push hl   ; s1 
4959			 
4959					FORTH_DSP_POP 
4959 cd 7a 23			call macro_forth_dsp_pop 
495c				endm 
# End of macro FORTH_DSP_POP
495c					 
495c			 
495c					; copy s1 
495c			 
495c				 
495c					; save ptr 
495c e1					pop hl  
495d e5					push hl 
495e 3e 00				ld a, 0 
4960 cd ef 13				call strlent 
4963					;inc hl    ; zer0 
4963 06 00				ld b, 0 
4965 4d					ld c, l 
4966 e1					pop hl		 
4967 11 c4 f1				ld de, scratch	 
496a					if DEBUG_FORTH_WORDS 
496a						DMARK "CO1" 
496a f5				push af  
496b 3a 7f 49			ld a, (.dmark)  
496e 32 6e fe			ld (debug_mark),a  
4971 3a 80 49			ld a, (.dmark+1)  
4974 32 6f fe			ld (debug_mark+1),a  
4977 3a 81 49			ld a, (.dmark+2)  
497a 32 70 fe			ld (debug_mark+2),a  
497d 18 03			jr .pastdmark  
497f ..			.dmark: db "CO1"  
4982 f1			.pastdmark: pop af  
4983			endm  
# End of macro DMARK
4983						CALLMONITOR 
4983 cd fb 19			call break_point_state  
4986				endm  
# End of macro CALLMONITOR
4986					endif 
4986 ed b0				ldir 
4988			 
4988 e1					pop hl 
4989 e5					push hl 
498a d5					push de 
498b			 
498b			 
498b 3e 00				ld a, 0 
498d cd ef 13				call strlent 
4990 23					inc hl    ; zer0 
4991 23					inc hl 
4992 06 00				ld b, 0 
4994 4d					ld c, l 
4995 d1					pop de 
4996 e1					pop hl		 
4997					if DEBUG_FORTH_WORDS 
4997						DMARK "CO2" 
4997 f5				push af  
4998 3a ac 49			ld a, (.dmark)  
499b 32 6e fe			ld (debug_mark),a  
499e 3a ad 49			ld a, (.dmark+1)  
49a1 32 6f fe			ld (debug_mark+1),a  
49a4 3a ae 49			ld a, (.dmark+2)  
49a7 32 70 fe			ld (debug_mark+2),a  
49aa 18 03			jr .pastdmark  
49ac ..			.dmark: db "CO2"  
49af f1			.pastdmark: pop af  
49b0			endm  
# End of macro DMARK
49b0						CALLMONITOR 
49b0 cd fb 19			call break_point_state  
49b3				endm  
# End of macro CALLMONITOR
49b3					endif 
49b3 ed b0				ldir 
49b5			 
49b5			 
49b5			 
49b5 21 c4 f1				ld hl, scratch 
49b8					if DEBUG_FORTH_WORDS 
49b8						DMARK "CO5" 
49b8 f5				push af  
49b9 3a cd 49			ld a, (.dmark)  
49bc 32 6e fe			ld (debug_mark),a  
49bf 3a ce 49			ld a, (.dmark+1)  
49c2 32 6f fe			ld (debug_mark+1),a  
49c5 3a cf 49			ld a, (.dmark+2)  
49c8 32 70 fe			ld (debug_mark+2),a  
49cb 18 03			jr .pastdmark  
49cd ..			.dmark: db "CO5"  
49d0 f1			.pastdmark: pop af  
49d1			endm  
# End of macro DMARK
49d1						CALLMONITOR 
49d1 cd fb 19			call break_point_state  
49d4				endm  
# End of macro CALLMONITOR
49d4					endif 
49d4			 
49d4 cd 39 21				call forth_push_str 
49d7			 
49d7			 
49d7			 
49d7			 
49d7				       NEXTW 
49d7 c3 78 24			jp macro_next 
49da				endm 
# End of macro NEXTW
49da			 
49da			 
49da			.FIND: 
49da				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
49da 4b				db WORD_SYS_CORE+55             
49db 98 4a			dw .LEN            
49dd 05				db 4 + 1 
49de .. 00			db "FIND",0              
49e3				endm 
# End of macro CWHEAD
49e3			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
49e3			 
49e3					if DEBUG_FORTH_WORDS_KEY 
49e3						DMARK "FND" 
49e3 f5				push af  
49e4 3a f8 49			ld a, (.dmark)  
49e7 32 6e fe			ld (debug_mark),a  
49ea 3a f9 49			ld a, (.dmark+1)  
49ed 32 6f fe			ld (debug_mark+1),a  
49f0 3a fa 49			ld a, (.dmark+2)  
49f3 32 70 fe			ld (debug_mark+2),a  
49f6 18 03			jr .pastdmark  
49f8 ..			.dmark: db "FND"  
49fb f1			.pastdmark: pop af  
49fc			endm  
# End of macro DMARK
49fc						CALLMONITOR 
49fc cd fb 19			call break_point_state  
49ff				endm  
# End of macro CALLMONITOR
49ff					endif 
49ff			 
49ff			; TODO check string type 
49ff					FORTH_DSP_VALUE 
49ff cd ab 22			call macro_forth_dsp_value 
4a02				endm 
# End of macro FORTH_DSP_VALUE
4a02			 
4a02 e5					push hl    
4a03 7e					ld a,(hl)    ; char to find   
4a04			; TODO change char to substr 
4a04			 
4a04 f5					push af 
4a05					 
4a05			 
4a05			 
4a05					if DEBUG_FORTH_WORDS 
4a05						DMARK "FN1" 
4a05 f5				push af  
4a06 3a 1a 4a			ld a, (.dmark)  
4a09 32 6e fe			ld (debug_mark),a  
4a0c 3a 1b 4a			ld a, (.dmark+1)  
4a0f 32 6f fe			ld (debug_mark+1),a  
4a12 3a 1c 4a			ld a, (.dmark+2)  
4a15 32 70 fe			ld (debug_mark+2),a  
4a18 18 03			jr .pastdmark  
4a1a ..			.dmark: db "FN1"  
4a1d f1			.pastdmark: pop af  
4a1e			endm  
# End of macro DMARK
4a1e						CALLMONITOR 
4a1e cd fb 19			call break_point_state  
4a21				endm  
# End of macro CALLMONITOR
4a21					endif 
4a21			 
4a21					FORTH_DSP_POP 
4a21 cd 7a 23			call macro_forth_dsp_pop 
4a24				endm 
# End of macro FORTH_DSP_POP
4a24			 
4a24					; string to search 
4a24			 
4a24					FORTH_DSP_VALUE 
4a24 cd ab 22			call macro_forth_dsp_value 
4a27				endm 
# End of macro FORTH_DSP_VALUE
4a27			 
4a27 d1					pop de  ; d is char to find  
4a28			 
4a28					if DEBUG_FORTH_WORDS 
4a28						DMARK "FN2" 
4a28 f5				push af  
4a29 3a 3d 4a			ld a, (.dmark)  
4a2c 32 6e fe			ld (debug_mark),a  
4a2f 3a 3e 4a			ld a, (.dmark+1)  
4a32 32 6f fe			ld (debug_mark+1),a  
4a35 3a 3f 4a			ld a, (.dmark+2)  
4a38 32 70 fe			ld (debug_mark+2),a  
4a3b 18 03			jr .pastdmark  
4a3d ..			.dmark: db "FN2"  
4a40 f1			.pastdmark: pop af  
4a41			endm  
# End of macro DMARK
4a41						CALLMONITOR 
4a41 cd fb 19			call break_point_state  
4a44				endm  
# End of macro CALLMONITOR
4a44					endif 
4a44					 
4a44 01 00 00				ld bc, 0 
4a47 7e			.findchar:      ld a,(hl) 
4a48 fe 00				cp 0   		 
4a4a 28 27				jr z, .finddone     
4a4c ba					cp d 
4a4d 28 20				jr z, .foundchar 
4a4f 03					inc bc 
4a50 23					inc hl 
4a51					if DEBUG_FORTH_WORDS 
4a51						DMARK "FN3" 
4a51 f5				push af  
4a52 3a 66 4a			ld a, (.dmark)  
4a55 32 6e fe			ld (debug_mark),a  
4a58 3a 67 4a			ld a, (.dmark+1)  
4a5b 32 6f fe			ld (debug_mark+1),a  
4a5e 3a 68 4a			ld a, (.dmark+2)  
4a61 32 70 fe			ld (debug_mark+2),a  
4a64 18 03			jr .pastdmark  
4a66 ..			.dmark: db "FN3"  
4a69 f1			.pastdmark: pop af  
4a6a			endm  
# End of macro DMARK
4a6a						CALLMONITOR 
4a6a cd fb 19			call break_point_state  
4a6d				endm  
# End of macro CALLMONITOR
4a6d					endif 
4a6d 18 d8				jr .findchar 
4a6f			 
4a6f			 
4a6f c5			.foundchar:	push bc 
4a70 e1					pop hl 
4a71 18 03				jr .findexit 
4a73			 
4a73			 
4a73							 
4a73			 
4a73			.finddone:     ; got to end of string with no find 
4a73 21 00 00				ld hl, 0 
4a76			.findexit: 
4a76			 
4a76					if DEBUG_FORTH_WORDS 
4a76						DMARK "FNd" 
4a76 f5				push af  
4a77 3a 8b 4a			ld a, (.dmark)  
4a7a 32 6e fe			ld (debug_mark),a  
4a7d 3a 8c 4a			ld a, (.dmark+1)  
4a80 32 6f fe			ld (debug_mark+1),a  
4a83 3a 8d 4a			ld a, (.dmark+2)  
4a86 32 70 fe			ld (debug_mark+2),a  
4a89 18 03			jr .pastdmark  
4a8b ..			.dmark: db "FNd"  
4a8e f1			.pastdmark: pop af  
4a8f			endm  
# End of macro DMARK
4a8f						CALLMONITOR 
4a8f cd fb 19			call break_point_state  
4a92				endm  
# End of macro CALLMONITOR
4a92					endif 
4a92 cd cb 20			call forth_push_numhl 
4a95			 
4a95				       NEXTW 
4a95 c3 78 24			jp macro_next 
4a98				endm 
# End of macro NEXTW
4a98			 
4a98			.LEN: 
4a98				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4a98 4c				db WORD_SYS_CORE+56             
4a99 02 4b			dw .ASC            
4a9b 06				db 5 + 1 
4a9c .. 00			db "COUNT",0              
4aa2				endm 
# End of macro CWHEAD
4aa2			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4aa2			 
4aa2					if DEBUG_FORTH_WORDS_KEY 
4aa2						DMARK "CNT" 
4aa2 f5				push af  
4aa3 3a b7 4a			ld a, (.dmark)  
4aa6 32 6e fe			ld (debug_mark),a  
4aa9 3a b8 4a			ld a, (.dmark+1)  
4aac 32 6f fe			ld (debug_mark+1),a  
4aaf 3a b9 4a			ld a, (.dmark+2)  
4ab2 32 70 fe			ld (debug_mark+2),a  
4ab5 18 03			jr .pastdmark  
4ab7 ..			.dmark: db "CNT"  
4aba f1			.pastdmark: pop af  
4abb			endm  
# End of macro DMARK
4abb						CALLMONITOR 
4abb cd fb 19			call break_point_state  
4abe				endm  
# End of macro CALLMONITOR
4abe					endif 
4abe			; TODO check string type 
4abe					FORTH_DSP_VALUE 
4abe cd ab 22			call macro_forth_dsp_value 
4ac1				endm 
# End of macro FORTH_DSP_VALUE
4ac1			 
4ac1			 
4ac1					if DEBUG_FORTH_WORDS 
4ac1						DMARK "CN?" 
4ac1 f5				push af  
4ac2 3a d6 4a			ld a, (.dmark)  
4ac5 32 6e fe			ld (debug_mark),a  
4ac8 3a d7 4a			ld a, (.dmark+1)  
4acb 32 6f fe			ld (debug_mark+1),a  
4ace 3a d8 4a			ld a, (.dmark+2)  
4ad1 32 70 fe			ld (debug_mark+2),a  
4ad4 18 03			jr .pastdmark  
4ad6 ..			.dmark: db "CN?"  
4ad9 f1			.pastdmark: pop af  
4ada			endm  
# End of macro DMARK
4ada						CALLMONITOR 
4ada cd fb 19			call break_point_state  
4add				endm  
# End of macro CALLMONITOR
4add					endif 
4add cd e4 13				call strlenz 
4ae0					if DEBUG_FORTH_WORDS 
4ae0						DMARK "CNl" 
4ae0 f5				push af  
4ae1 3a f5 4a			ld a, (.dmark)  
4ae4 32 6e fe			ld (debug_mark),a  
4ae7 3a f6 4a			ld a, (.dmark+1)  
4aea 32 6f fe			ld (debug_mark+1),a  
4aed 3a f7 4a			ld a, (.dmark+2)  
4af0 32 70 fe			ld (debug_mark+2),a  
4af3 18 03			jr .pastdmark  
4af5 ..			.dmark: db "CNl"  
4af8 f1			.pastdmark: pop af  
4af9			endm  
# End of macro DMARK
4af9						CALLMONITOR 
4af9 cd fb 19			call break_point_state  
4afc				endm  
# End of macro CALLMONITOR
4afc					endif 
4afc			 
4afc cd cb 20				call forth_push_numhl 
4aff			 
4aff			 
4aff			 
4aff				       NEXTW 
4aff c3 78 24			jp macro_next 
4b02				endm 
# End of macro NEXTW
4b02			.ASC: 
4b02				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4b02 4d				db WORD_SYS_CORE+57             
4b03 70 4b			dw .CHR            
4b05 04				db 3 + 1 
4b06 .. 00			db "ASC",0              
4b0a				endm 
# End of macro CWHEAD
4b0a			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4b0a					if DEBUG_FORTH_WORDS_KEY 
4b0a						DMARK "ASC" 
4b0a f5				push af  
4b0b 3a 1f 4b			ld a, (.dmark)  
4b0e 32 6e fe			ld (debug_mark),a  
4b11 3a 20 4b			ld a, (.dmark+1)  
4b14 32 6f fe			ld (debug_mark+1),a  
4b17 3a 21 4b			ld a, (.dmark+2)  
4b1a 32 70 fe			ld (debug_mark+2),a  
4b1d 18 03			jr .pastdmark  
4b1f ..			.dmark: db "ASC"  
4b22 f1			.pastdmark: pop af  
4b23			endm  
# End of macro DMARK
4b23						CALLMONITOR 
4b23 cd fb 19			call break_point_state  
4b26				endm  
# End of macro CALLMONITOR
4b26					endif 
4b26					FORTH_DSP_VALUE 
4b26 cd ab 22			call macro_forth_dsp_value 
4b29				endm 
# End of macro FORTH_DSP_VALUE
4b29					;v5 FORTH_DSP_VALUE 
4b29			;		inc hl      ; now at start of numeric as string 
4b29			 
4b29 e5					push hl 
4b2a			 
4b2a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b2a cd 7a 23			call macro_forth_dsp_pop 
4b2d				endm 
# End of macro FORTH_DSP_POP
4b2d			 
4b2d e1					pop hl 
4b2e			 
4b2e					if DEBUG_FORTH_WORDS 
4b2e						DMARK "AS1" 
4b2e f5				push af  
4b2f 3a 43 4b			ld a, (.dmark)  
4b32 32 6e fe			ld (debug_mark),a  
4b35 3a 44 4b			ld a, (.dmark+1)  
4b38 32 6f fe			ld (debug_mark+1),a  
4b3b 3a 45 4b			ld a, (.dmark+2)  
4b3e 32 70 fe			ld (debug_mark+2),a  
4b41 18 03			jr .pastdmark  
4b43 ..			.dmark: db "AS1"  
4b46 f1			.pastdmark: pop af  
4b47			endm  
# End of macro DMARK
4b47						CALLMONITOR 
4b47 cd fb 19			call break_point_state  
4b4a				endm  
# End of macro CALLMONITOR
4b4a					endif 
4b4a					; push the content of a onto the stack as a value 
4b4a			 
4b4a 7e					ld a,(hl)   ; get char 
4b4b 26 00				ld h,0 
4b4d 6f					ld l,a 
4b4e					if DEBUG_FORTH_WORDS 
4b4e						DMARK "AS2" 
4b4e f5				push af  
4b4f 3a 63 4b			ld a, (.dmark)  
4b52 32 6e fe			ld (debug_mark),a  
4b55 3a 64 4b			ld a, (.dmark+1)  
4b58 32 6f fe			ld (debug_mark+1),a  
4b5b 3a 65 4b			ld a, (.dmark+2)  
4b5e 32 70 fe			ld (debug_mark+2),a  
4b61 18 03			jr .pastdmark  
4b63 ..			.dmark: db "AS2"  
4b66 f1			.pastdmark: pop af  
4b67			endm  
# End of macro DMARK
4b67						CALLMONITOR 
4b67 cd fb 19			call break_point_state  
4b6a				endm  
# End of macro CALLMONITOR
4b6a					endif 
4b6a cd cb 20				call forth_push_numhl 
4b6d			 
4b6d				       NEXTW 
4b6d c3 78 24			jp macro_next 
4b70				endm 
# End of macro NEXTW
4b70			 
4b70			.CHR: 
4b70				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4b70 4d				db WORD_SYS_CORE+57             
4b71 ac 4b			dw .ENDSTR            
4b73 04				db 3 + 1 
4b74 .. 00			db "CHR",0              
4b78				endm 
# End of macro CWHEAD
4b78			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4b78					if DEBUG_FORTH_WORDS_KEY 
4b78						DMARK "CHR" 
4b78 f5				push af  
4b79 3a 8d 4b			ld a, (.dmark)  
4b7c 32 6e fe			ld (debug_mark),a  
4b7f 3a 8e 4b			ld a, (.dmark+1)  
4b82 32 6f fe			ld (debug_mark+1),a  
4b85 3a 8f 4b			ld a, (.dmark+2)  
4b88 32 70 fe			ld (debug_mark+2),a  
4b8b 18 03			jr .pastdmark  
4b8d ..			.dmark: db "CHR"  
4b90 f1			.pastdmark: pop af  
4b91			endm  
# End of macro DMARK
4b91						CALLMONITOR 
4b91 cd fb 19			call break_point_state  
4b94				endm  
# End of macro CALLMONITOR
4b94					endif 
4b94					FORTH_DSP_VALUEHL 
4b94 cd c2 22			call macro_dsp_valuehl 
4b97				endm 
# End of macro FORTH_DSP_VALUEHL
4b97			 
4b97					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b97 cd 7a 23			call macro_forth_dsp_pop 
4b9a				endm 
# End of macro FORTH_DSP_POP
4b9a			 
4b9a					; save asci byte as a zero term string and push string 
4b9a			 
4b9a 7d					ld a,l 
4b9b 32 c4 f1				ld (scratch), a 
4b9e			 
4b9e 3e 00				ld a, 0 
4ba0 32 c5 f1				ld (scratch+1), a 
4ba3			 
4ba3 21 c4 f1				ld hl, scratch 
4ba6 cd 39 21				call forth_push_str 
4ba9			 
4ba9			 
4ba9				       NEXTW 
4ba9 c3 78 24			jp macro_next 
4bac				endm 
# End of macro NEXTW
4bac			 
4bac			 
4bac			 
4bac			 
4bac			.ENDSTR: 
4bac			; eof 
4bac			 
# End of file forth_words_str.asm
4bac			include "forth_words_key.asm" 
4bac			 
4bac			; | ## Keyboard Words 
4bac			 
4bac			.KEY: 
4bac				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4bac 3e				db WORD_SYS_CORE+42             
4bad dc 4b			dw .WAITK            
4baf 04				db 3 + 1 
4bb0 .. 00			db "KEY",0              
4bb4				endm 
# End of macro CWHEAD
4bb4			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4bb4			 
4bb4					if DEBUG_FORTH_WORDS_KEY 
4bb4						DMARK "KEY" 
4bb4 f5				push af  
4bb5 3a c9 4b			ld a, (.dmark)  
4bb8 32 6e fe			ld (debug_mark),a  
4bbb 3a ca 4b			ld a, (.dmark+1)  
4bbe 32 6f fe			ld (debug_mark+1),a  
4bc1 3a cb 4b			ld a, (.dmark+2)  
4bc4 32 70 fe			ld (debug_mark+2),a  
4bc7 18 03			jr .pastdmark  
4bc9 ..			.dmark: db "KEY"  
4bcc f1			.pastdmark: pop af  
4bcd			endm  
# End of macro DMARK
4bcd						CALLMONITOR 
4bcd cd fb 19			call break_point_state  
4bd0				endm  
# End of macro CALLMONITOR
4bd0					endif 
4bd0			; TODO currently waits 
4bd0 cd aa 78				call cin 
4bd3					;call cin_wait 
4bd3 6f					ld l, a 
4bd4 26 00				ld h, 0 
4bd6 cd cb 20				call forth_push_numhl 
4bd9					NEXTW 
4bd9 c3 78 24			jp macro_next 
4bdc				endm 
# End of macro NEXTW
4bdc			.WAITK: 
4bdc				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4bdc 3f				db WORD_SYS_CORE+43             
4bdd 0e 4c			dw .ACCEPT            
4bdf 06				db 5 + 1 
4be0 .. 00			db "WAITK",0              
4be6				endm 
# End of macro CWHEAD
4be6			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4be6					if DEBUG_FORTH_WORDS_KEY 
4be6						DMARK "WAI" 
4be6 f5				push af  
4be7 3a fb 4b			ld a, (.dmark)  
4bea 32 6e fe			ld (debug_mark),a  
4bed 3a fc 4b			ld a, (.dmark+1)  
4bf0 32 6f fe			ld (debug_mark+1),a  
4bf3 3a fd 4b			ld a, (.dmark+2)  
4bf6 32 70 fe			ld (debug_mark+2),a  
4bf9 18 03			jr .pastdmark  
4bfb ..			.dmark: db "WAI"  
4bfe f1			.pastdmark: pop af  
4bff			endm  
# End of macro DMARK
4bff						CALLMONITOR 
4bff cd fb 19			call break_point_state  
4c02				endm  
# End of macro CALLMONITOR
4c02					endif 
4c02 cd 99 78				call cin_wait 
4c05 6f					ld l, a 
4c06 26 00				ld h, 0 
4c08 cd cb 20				call forth_push_numhl 
4c0b					NEXTW 
4c0b c3 78 24			jp macro_next 
4c0e				endm 
# End of macro NEXTW
4c0e			.ACCEPT: 
4c0e				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4c0e 40				db WORD_SYS_CORE+44             
4c0f 6c 4c			dw .EDIT            
4c11 07				db 6 + 1 
4c12 .. 00			db "ACCEPT",0              
4c19				endm 
# End of macro CWHEAD
4c19			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4c19					; TODO crashes on push 
4c19					if DEBUG_FORTH_WORDS_KEY 
4c19						DMARK "ACC" 
4c19 f5				push af  
4c1a 3a 2e 4c			ld a, (.dmark)  
4c1d 32 6e fe			ld (debug_mark),a  
4c20 3a 2f 4c			ld a, (.dmark+1)  
4c23 32 6f fe			ld (debug_mark+1),a  
4c26 3a 30 4c			ld a, (.dmark+2)  
4c29 32 70 fe			ld (debug_mark+2),a  
4c2c 18 03			jr .pastdmark  
4c2e ..			.dmark: db "ACC"  
4c31 f1			.pastdmark: pop af  
4c32			endm  
# End of macro DMARK
4c32						CALLMONITOR 
4c32 cd fb 19			call break_point_state  
4c35				endm  
# End of macro CALLMONITOR
4c35					endif 
4c35 21 c2 f3				ld hl, os_input 
4c38 3e 00				ld a, 0 
4c3a 77					ld (hl),a 
4c3b 3a 61 fa				ld a,(f_cursor_ptr) 
4c3e 16 64				ld d, 100 
4c40 0e 00				ld c, 0 
4c42 1e 28				ld e, 40 
4c44 cd b3 0f				call input_str 
4c47					; TODO perhaps do a type check and wrap in quotes if not a number 
4c47 21 c2 f3				ld hl, os_input 
4c4a					if DEBUG_FORTH_WORDS 
4c4a						DMARK "AC1" 
4c4a f5				push af  
4c4b 3a 5f 4c			ld a, (.dmark)  
4c4e 32 6e fe			ld (debug_mark),a  
4c51 3a 60 4c			ld a, (.dmark+1)  
4c54 32 6f fe			ld (debug_mark+1),a  
4c57 3a 61 4c			ld a, (.dmark+2)  
4c5a 32 70 fe			ld (debug_mark+2),a  
4c5d 18 03			jr .pastdmark  
4c5f ..			.dmark: db "AC1"  
4c62 f1			.pastdmark: pop af  
4c63			endm  
# End of macro DMARK
4c63						CALLMONITOR 
4c63 cd fb 19			call break_point_state  
4c66				endm  
# End of macro CALLMONITOR
4c66					endif 
4c66 cd 39 21				call forth_push_str 
4c69					NEXTW 
4c69 c3 78 24			jp macro_next 
4c6c				endm 
# End of macro NEXTW
4c6c			 
4c6c			.EDIT: 
4c6c				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4c6c 40				db WORD_SYS_CORE+44             
4c6d 0e 4d			dw .DEDIT            
4c6f 05				db 4 + 1 
4c70 .. 00			db "EDIT",0              
4c75				endm 
# End of macro CWHEAD
4c75			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4c75			 
4c75					; TODO does not copy from stack 
4c75					if DEBUG_FORTH_WORDS_KEY 
4c75						DMARK "EDT" 
4c75 f5				push af  
4c76 3a 8a 4c			ld a, (.dmark)  
4c79 32 6e fe			ld (debug_mark),a  
4c7c 3a 8b 4c			ld a, (.dmark+1)  
4c7f 32 6f fe			ld (debug_mark+1),a  
4c82 3a 8c 4c			ld a, (.dmark+2)  
4c85 32 70 fe			ld (debug_mark+2),a  
4c88 18 03			jr .pastdmark  
4c8a ..			.dmark: db "EDT"  
4c8d f1			.pastdmark: pop af  
4c8e			endm  
# End of macro DMARK
4c8e						CALLMONITOR 
4c8e cd fb 19			call break_point_state  
4c91				endm  
# End of macro CALLMONITOR
4c91					endif 
4c91			 
4c91					;FORTH_DSP 
4c91					FORTH_DSP_VALUEHL 
4c91 cd c2 22			call macro_dsp_valuehl 
4c94				endm 
# End of macro FORTH_DSP_VALUEHL
4c94			;		inc hl    ; TODO do type check 
4c94			 
4c94			;		call get_word_hl 
4c94 e5					push hl 
4c95					if DEBUG_FORTH_WORDS 
4c95						DMARK "EDp" 
4c95 f5				push af  
4c96 3a aa 4c			ld a, (.dmark)  
4c99 32 6e fe			ld (debug_mark),a  
4c9c 3a ab 4c			ld a, (.dmark+1)  
4c9f 32 6f fe			ld (debug_mark+1),a  
4ca2 3a ac 4c			ld a, (.dmark+2)  
4ca5 32 70 fe			ld (debug_mark+2),a  
4ca8 18 03			jr .pastdmark  
4caa ..			.dmark: db "EDp"  
4cad f1			.pastdmark: pop af  
4cae			endm  
# End of macro DMARK
4cae						CALLMONITOR 
4cae cd fb 19			call break_point_state  
4cb1				endm  
# End of macro CALLMONITOR
4cb1					endif 
4cb1				;	ld a, 0 
4cb1 cd e4 13				call strlenz 
4cb4 23					inc hl 
4cb5			 
4cb5 06 00				ld b, 0 
4cb7 4d					ld c, l 
4cb8			 
4cb8 e1					pop hl 
4cb9 11 c2 f3				ld de, os_input 
4cbc					if DEBUG_FORTH_WORDS_KEY 
4cbc						DMARK "EDc" 
4cbc f5				push af  
4cbd 3a d1 4c			ld a, (.dmark)  
4cc0 32 6e fe			ld (debug_mark),a  
4cc3 3a d2 4c			ld a, (.dmark+1)  
4cc6 32 6f fe			ld (debug_mark+1),a  
4cc9 3a d3 4c			ld a, (.dmark+2)  
4ccc 32 70 fe			ld (debug_mark+2),a  
4ccf 18 03			jr .pastdmark  
4cd1 ..			.dmark: db "EDc"  
4cd4 f1			.pastdmark: pop af  
4cd5			endm  
# End of macro DMARK
4cd5						CALLMONITOR 
4cd5 cd fb 19			call break_point_state  
4cd8				endm  
# End of macro CALLMONITOR
4cd8					endif 
4cd8 ed b0				ldir 
4cda			 
4cda			 
4cda 21 c2 f3				ld hl, os_input 
4cdd					;ld a, 0 
4cdd					;ld (hl),a 
4cdd 3a 61 fa				ld a,(f_cursor_ptr) 
4ce0 16 64				ld d, 100 
4ce2 0e 00				ld c, 0 
4ce4 1e 28				ld e, 40 
4ce6 cd b3 0f				call input_str 
4ce9					; TODO perhaps do a type check and wrap in quotes if not a number 
4ce9 21 c2 f3				ld hl, os_input 
4cec					if DEBUG_FORTH_WORDS 
4cec						DMARK "ED1" 
4cec f5				push af  
4ced 3a 01 4d			ld a, (.dmark)  
4cf0 32 6e fe			ld (debug_mark),a  
4cf3 3a 02 4d			ld a, (.dmark+1)  
4cf6 32 6f fe			ld (debug_mark+1),a  
4cf9 3a 03 4d			ld a, (.dmark+2)  
4cfc 32 70 fe			ld (debug_mark+2),a  
4cff 18 03			jr .pastdmark  
4d01 ..			.dmark: db "ED1"  
4d04 f1			.pastdmark: pop af  
4d05			endm  
# End of macro DMARK
4d05						CALLMONITOR 
4d05 cd fb 19			call break_point_state  
4d08				endm  
# End of macro CALLMONITOR
4d08					endif 
4d08 cd 39 21				call forth_push_str 
4d0b					NEXTW 
4d0b c3 78 24			jp macro_next 
4d0e				endm 
# End of macro NEXTW
4d0e			 
4d0e			.DEDIT: 
4d0e				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4d0e 40				db WORD_SYS_CORE+44             
4d0f 70 4d			dw .ENDKEY            
4d11 06				db 5 + 1 
4d12 .. 00			db "DEDIT",0              
4d18				endm 
# End of macro CWHEAD
4d18			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4d18			 
4d18					; TODO does not copy from stack 
4d18					if DEBUG_FORTH_WORDS_KEY 
4d18						DMARK "DED" 
4d18 f5				push af  
4d19 3a 2d 4d			ld a, (.dmark)  
4d1c 32 6e fe			ld (debug_mark),a  
4d1f 3a 2e 4d			ld a, (.dmark+1)  
4d22 32 6f fe			ld (debug_mark+1),a  
4d25 3a 2f 4d			ld a, (.dmark+2)  
4d28 32 70 fe			ld (debug_mark+2),a  
4d2b 18 03			jr .pastdmark  
4d2d ..			.dmark: db "DED"  
4d30 f1			.pastdmark: pop af  
4d31			endm  
# End of macro DMARK
4d31						CALLMONITOR 
4d31 cd fb 19			call break_point_state  
4d34				endm  
# End of macro CALLMONITOR
4d34					endif 
4d34			 
4d34					;FORTH_DSP 
4d34					FORTH_DSP_VALUEHL 
4d34 cd c2 22			call macro_dsp_valuehl 
4d37				endm 
# End of macro FORTH_DSP_VALUEHL
4d37			;		inc hl    ; TODO do type check 
4d37			 
4d37			;		call get_word_hl 
4d37 e5					push hl 
4d38 e5					push hl 
4d39					FORTH_DSP_POP 
4d39 cd 7a 23			call macro_forth_dsp_pop 
4d3c				endm 
# End of macro FORTH_DSP_POP
4d3c e1					pop hl 
4d3d					if DEBUG_FORTH_WORDS 
4d3d						DMARK "EDp" 
4d3d f5				push af  
4d3e 3a 52 4d			ld a, (.dmark)  
4d41 32 6e fe			ld (debug_mark),a  
4d44 3a 53 4d			ld a, (.dmark+1)  
4d47 32 6f fe			ld (debug_mark+1),a  
4d4a 3a 54 4d			ld a, (.dmark+2)  
4d4d 32 70 fe			ld (debug_mark+2),a  
4d50 18 03			jr .pastdmark  
4d52 ..			.dmark: db "EDp"  
4d55 f1			.pastdmark: pop af  
4d56			endm  
# End of macro DMARK
4d56						CALLMONITOR 
4d56 cd fb 19			call break_point_state  
4d59				endm  
# End of macro CALLMONITOR
4d59					endif 
4d59				;	ld a, 0 
4d59 cd e4 13				call strlenz 
4d5c 23					inc hl 
4d5d			 
4d5d 06 00				ld b, 0 
4d5f 4d					ld c, l 
4d60			 
4d60 e1					pop hl 
4d61			 
4d61					;ld a, 0 
4d61					;ld (hl),a 
4d61 3a 61 fa				ld a,(f_cursor_ptr) 
4d64 16 64				ld d, 100 
4d66 0e 00				ld c, 0 
4d68 1e 28				ld e, 40 
4d6a cd b3 0f				call input_str 
4d6d					; TODO perhaps do a type check and wrap in quotes if not a number 
4d6d					NEXTW 
4d6d c3 78 24			jp macro_next 
4d70				endm 
# End of macro NEXTW
4d70			 
4d70			 
4d70			.ENDKEY: 
4d70			; eof 
4d70			 
# End of file forth_words_key.asm
4d70			include "forth_words_const.asm" 
4d70			 
4d70			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4d70			 
4d70			 
4d70			.SPITIME: 
4d70				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4d70 77				db WORD_SYS_CORE+99             
4d71 85 4d			dw .VA            
4d73 08				db 7 + 1 
4d74 .. 00			db "SPITIME",0              
4d7c				endm 
# End of macro CWHEAD
4d7c			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4d7c			; 
4d7c			; | If using BANK devices then leave as is. 
4d7c			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4d7c			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4d7c			 
4d7c 21 67 fa				ld hl, spi_clktime  
4d7f cd cb 20				call forth_push_numhl 
4d82			 
4d82					NEXTW 
4d82 c3 78 24			jp macro_next 
4d85				endm 
# End of macro NEXTW
4d85			 
4d85			 
4d85			.VA: 
4d85				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4d85 77				db WORD_SYS_CORE+99             
4d86 95 4d			dw .SYMBOL            
4d88 03				db 2 + 1 
4d89 .. 00			db "VA",0              
4d8c				endm 
# End of macro CWHEAD
4d8c			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4d8c 21 2b fa				ld hl, cli_var_array 
4d8f cd cb 20				call forth_push_numhl 
4d92			 
4d92					NEXTW 
4d92 c3 78 24			jp macro_next 
4d95				endm 
# End of macro NEXTW
4d95			 
4d95			.SYMBOL: 
4d95				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4d95 77				db WORD_SYS_CORE+99             
4d96 cd 4e			dw .ENDCONST            
4d98 07				db 6 + 1 
4d99 .. 00			db "SYMBOL",0              
4da0				endm 
# End of macro CWHEAD
4da0			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4da0			; | 
4da0			; | The value is the number reference and the final address is pushed to stack 
4da0			 
4da0					if DEBUG_FORTH_WORDS_KEY 
4da0						DMARK "SYM" 
4da0 f5				push af  
4da1 3a b5 4d			ld a, (.dmark)  
4da4 32 6e fe			ld (debug_mark),a  
4da7 3a b6 4d			ld a, (.dmark+1)  
4daa 32 6f fe			ld (debug_mark+1),a  
4dad 3a b7 4d			ld a, (.dmark+2)  
4db0 32 70 fe			ld (debug_mark+2),a  
4db3 18 03			jr .pastdmark  
4db5 ..			.dmark: db "SYM"  
4db8 f1			.pastdmark: pop af  
4db9			endm  
# End of macro DMARK
4db9						CALLMONITOR 
4db9 cd fb 19			call break_point_state  
4dbc				endm  
# End of macro CALLMONITOR
4dbc					endif 
4dbc			 
4dbc					FORTH_DSP_VALUEHL 
4dbc cd c2 22			call macro_dsp_valuehl 
4dbf				endm 
# End of macro FORTH_DSP_VALUEHL
4dbf			 
4dbf 7d					ld a, l     
4dc0			 
4dc0			 
4dc0					if DEBUG_FORTH_WORDS 
4dc0						DMARK "SY1" 
4dc0 f5				push af  
4dc1 3a d5 4d			ld a, (.dmark)  
4dc4 32 6e fe			ld (debug_mark),a  
4dc7 3a d6 4d			ld a, (.dmark+1)  
4dca 32 6f fe			ld (debug_mark+1),a  
4dcd 3a d7 4d			ld a, (.dmark+2)  
4dd0 32 70 fe			ld (debug_mark+2),a  
4dd3 18 03			jr .pastdmark  
4dd5 ..			.dmark: db "SY1"  
4dd8 f1			.pastdmark: pop af  
4dd9			endm  
# End of macro DMARK
4dd9						CALLMONITOR 
4dd9 cd fb 19			call break_point_state  
4ddc				endm  
# End of macro CALLMONITOR
4ddc					endif 
4ddc					 
4ddc f5					push af	 
4ddd					FORTH_DSP_POP 
4ddd cd 7a 23			call macro_forth_dsp_pop 
4de0				endm 
# End of macro FORTH_DSP_POP
4de0 f1					pop af 
4de1			 
4de1 cb 27				sla a  
4de3				 
4de3					 
4de3					if DEBUG_FORTH_WORDS 
4de3						DMARK "SY" 
4de3 f5				push af  
4de4 3a f8 4d			ld a, (.dmark)  
4de7 32 6e fe			ld (debug_mark),a  
4dea 3a f9 4d			ld a, (.dmark+1)  
4ded 32 6f fe			ld (debug_mark+1),a  
4df0 3a fa 4d			ld a, (.dmark+2)  
4df3 32 70 fe			ld (debug_mark+2),a  
4df6 18 02			jr .pastdmark  
4df8 ..			.dmark: db "SY"  
4dfa f1			.pastdmark: pop af  
4dfb			endm  
# End of macro DMARK
4dfb						CALLMONITOR 
4dfb cd fb 19			call break_point_state  
4dfe				endm  
# End of macro CALLMONITOR
4dfe					endif 
4dfe			 
4dfe 21 0d 4e				ld hl, sym_table 
4e01 cd 86 0f				call addatohl 
4e04 cd fa 23				call loadwordinhl 
4e07 cd cb 20				call forth_push_numhl 
4e0a			 
4e0a			 
4e0a				       NEXTW 
4e0a c3 78 24			jp macro_next 
4e0d				endm 
# End of macro NEXTW
4e0d			 
4e0d			sym_table: 
4e0d			 
4e0d			; 0 
4e0d 3f fa		dw cli_autodisplay 
4e0f 4d fa		dw cli_buffer 
4e11 f1 f9		dw cli_data_sp 
4e13 2b f7		dw cli_data_stack 
4e15 47 fa		dw cli_execword 
4e17 f3 f9		dw cli_loop_sp 
4e19 2d f9		dw cli_loop_stack 
4e1b 40 fa		dw cli_mvdot 
4e1d 45 fa		dw cli_nextword 
4e1f 41 fa		dw cli_origptr 
4e21 4b fa		dw cli_origtoken 
4e23			; 11 
4e23 43 fa		dw cli_ptr 
4e25 f5 f9		dw cli_ret_sp 
4e27 af f9		dw cli_ret_stack 
4e29 49 fa		dw cli_token 
4e2b 2b fa		dw cli_var_array 
4e2d c8 fb		dw cursor_col 
4e2f c6 fb		dw cursor_ptr 
4e31 c7 fb		dw cursor_row 
4e33 c4 fb		dw cursor_shape 
4e35 6e fe		dw debug_mark 
4e37			; 21 
4e37 b4 fd		dw display_fb0 
4e39 13 fd		dw display_fb1 
4e3b d1 fb		dw display_fb2 
4e3d 72 fc		dw display_fb3 
4e3f cf fb		dw display_fb_active 
4e41 c3 f2		dw execscratch 
4e43 61 fa		dw f_cursor_ptr 
4e45 72 fe		dw hardware_word 
4e47 65 fe		dw input_at_cursor 
4e49 67 fe		dw input_at_pos 
4e4b			; 31 
4e4b 63 fe		dw input_cur_flash 
4e4d 62 fe		dw input_cur_onoff 
4e4f 58 fe		dw input_cursor 
4e51 68 fe		dw input_display_size 
4e53 5d fe		dw input_len 
4e55 6c fe		dw input_ptr 
4e57 69 fe		dw input_size 
4e59 6a fe		dw input_start 
4e5b b3 0f		dw input_str 
4e5d 66 fe		dw input_under_cursor 
4e5f			; 41 
4e5f 57 fe		dw key_actual_pressed 
4e61 82 fe		dw key_fa 
4e63 7e fe		dw key_face_held 
4e65 81 fe		dw key_fb 
4e67 80 fe		dw key_fc 
4e69 7f fe		dw key_fd 
4e6b 88 fe		dw key_held 
4e6d 87 fe		dw key_held_prev 
4e6f ca 77		dw key_init 
4e71 83 fe		dw key_repeat_ct 
4e73			; 51 
4e73 05 00		dw key_rows 
4e75 55 fe		dw key_shift 
4e77 56 fe		dw key_symbol 
4e79 89 fe		dw keyscan_scancol 
4e7b 93 fe		dw keyscan_table 
4e7d f2 fe		dw keyscan_table_row1 
4e7f e7 fe		dw keyscan_table_row2 
4e81 dc fe		dw keyscan_table_row3 
4e83 d1 fe		dw keyscan_table_row4 
4e85 c6 fe		dw keyscan_table_row5 
4e87			; 61 
4e87 eb f4		dw os_cli_cmd 
4e89 e7 f4		dw os_cur_ptr 
4e8b e9 f4		dw os_current_i 
4e8d c2 f3		dw os_input 
4e8f ea f5		dw os_last_cmd 
4e91 c1 f4		dw os_last_new_uword 
4e93 b5 f1		dw os_view_disable 
4e95 b1 f1		dw os_view_hl 
4e97 c9 f4		dw os_word_scratch 
4e99 c3 00		dw portbctl 
4e9b			; 71 
4e9b c1 00		dw portbdata 
4e9d 66 fa		dw spi_cartdev 
4e9f 65 fa		dw spi_cartdev2 
4ea1 67 fa		dw spi_clktime 
4ea3 63 fa		dw spi_device 
4ea5 62 fa		dw spi_device_id 
4ea7 64 fa		dw spi_portbyte 
4ea9 aa fb		dw stackstore 
4eab			if STORAGE_SE 
4eab 82 00		dw storage_actl 
4ead 80 00		dw storage_adata 
4eaf			else 
4eaf			dw 0 
4eaf			dw 0 
4eaf			endif 
4eaf			; 81 
4eaf 0c 0b		dw storage_append 
4eb1			if STORAGE_SE 
4eb1 83 00		dw storage_bctl 
4eb3			else 
4eb3			dw 0 
4eb3			endif 
4eb3 96 fb		dw store_bank_active 
4eb5 6a fa		dw store_filecache 
4eb7 78 fa		dw store_longread 
4eb9 6e fa		dw store_openaddr 
4ebb 6d fa		dw store_openext 
4ebd 6c fa		dw store_openmaxext 
4ebf 7d fa		dw store_page 
4ec1 79 fa		dw store_readbuf 
4ec3			; 91 
4ec3 70 fa		dw store_readcont 
4ec5 7b fa		dw store_readptr 
4ec7 70 fa		dw store_tmpext 
4ec9 71 fa		dw store_tmpid 
4ecb 68 fa		dw store_tmppageid 
4ecd			 
4ecd			 
4ecd			.ENDCONST: 
4ecd			 
4ecd			; eof 
4ecd			 
4ecd			 
# End of file forth_words_const.asm
4ecd			 
4ecd			if STORAGE_SE 
4ecd			   	include "forth_words_storage.asm" 
4ecd			 
4ecd			; | ## Fixed Storage Words 
4ecd			 
4ecd			.RENAME: 
4ecd			  
4ecd				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4ecd 3a				db WORD_SYS_CORE+38             
4ece c3 4f			dw .RECORD            
4ed0 07				db 6 + 1 
4ed1 .. 00			db "RENAME",0              
4ed8				endm 
# End of macro CWHEAD
4ed8			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4ed8			; | | Compatible with PicoSPINet  
4ed8					if DEBUG_FORTH_WORDS_KEY 
4ed8						DMARK "REN" 
4ed8 f5				push af  
4ed9 3a ed 4e			ld a, (.dmark)  
4edc 32 6e fe			ld (debug_mark),a  
4edf 3a ee 4e			ld a, (.dmark+1)  
4ee2 32 6f fe			ld (debug_mark+1),a  
4ee5 3a ef 4e			ld a, (.dmark+2)  
4ee8 32 70 fe			ld (debug_mark+2),a  
4eeb 18 03			jr .pastdmark  
4eed ..			.dmark: db "REN"  
4ef0 f1			.pastdmark: pop af  
4ef1			endm  
# End of macro DMARK
4ef1						CALLMONITOR 
4ef1 cd fb 19			call break_point_state  
4ef4				endm  
# End of macro CALLMONITOR
4ef4					endif 
4ef4			 
4ef4			 
4ef4					; preserve some internal vars used by other file handing routines 
4ef4			 
4ef4 2a 6e fa				ld hl, (store_openaddr) 
4ef7 e5					push hl 
4ef8 3a 70 fa				ld a, (store_readcont) 
4efb f5					push af 
4efc			 
4efc					FORTH_DSP_VALUEHL 
4efc cd c2 22			call macro_dsp_valuehl 
4eff				endm 
# End of macro FORTH_DSP_VALUEHL
4eff			 
4eff					; move ext and id around for the file header 
4eff			 
4eff 65					ld h, l 
4f00 2e 00				ld l, 0 
4f02			 
4f02 e5					push hl    ; id 
4f03			 
4f03					FORTH_DSP_POP 
4f03 cd 7a 23			call macro_forth_dsp_pop 
4f06				endm 
# End of macro FORTH_DSP_POP
4f06			 
4f06					; Locate the file header 
4f06			 
4f06 e1					pop hl 
4f07 e5					push hl 
4f08 11 7d fa				ld de, store_page      ; get block zero of file 
4f0b					if DEBUG_FORTH_WORDS 
4f0b						DMARK "REr" 
4f0b f5				push af  
4f0c 3a 20 4f			ld a, (.dmark)  
4f0f 32 6e fe			ld (debug_mark),a  
4f12 3a 21 4f			ld a, (.dmark+1)  
4f15 32 6f fe			ld (debug_mark+1),a  
4f18 3a 22 4f			ld a, (.dmark+2)  
4f1b 32 70 fe			ld (debug_mark+2),a  
4f1e 18 03			jr .pastdmark  
4f20 ..			.dmark: db "REr"  
4f23 f1			.pastdmark: pop af  
4f24			endm  
# End of macro DMARK
4f24						CALLMONITOR 
4f24 cd fb 19			call break_point_state  
4f27				endm  
# End of macro CALLMONITOR
4f27					endif 
4f27 cd 75 09				call storage_read 
4f2a			 
4f2a cd af 0f			call ishlzero 
4f2d 20 05			jr nz, .rnfound 
4f2f			 
4f2f				; file does not exist so indicate with 255 extents in use 
4f2f			 
4f2f 3e ff			ld a, 255 
4f31 e1				pop hl ; clear dup hl 
4f32 18 7b			jr .skiprneof 
4f34			 
4f34			 
4f34			.rnfound: 
4f34					; file found so rename 
4f34			 
4f34					FORTH_DSP_VALUEHL 
4f34 cd c2 22			call macro_dsp_valuehl 
4f37				endm 
# End of macro FORTH_DSP_VALUEHL
4f37			 
4f37 e5				push hl 
4f38 3e 00			ld a, 0 
4f3a cd ef 13			call strlent 
4f3d 23				inc hl   ; cover zero term 
4f3e 06 00			ld b,0 
4f40 4d				ld c,l 
4f41 e1				pop hl 
4f42 11 80 fa				ld de, store_page + 3 
4f45 ed b0				ldir 
4f47			 
4f47 11 7d fa				ld de, store_page 
4f4a					if DEBUG_FORTH_WORDS 
4f4a						DMARK "RER" 
4f4a f5				push af  
4f4b 3a 5f 4f			ld a, (.dmark)  
4f4e 32 6e fe			ld (debug_mark),a  
4f51 3a 60 4f			ld a, (.dmark+1)  
4f54 32 6f fe			ld (debug_mark+1),a  
4f57 3a 61 4f			ld a, (.dmark+2)  
4f5a 32 70 fe			ld (debug_mark+2),a  
4f5d 18 03			jr .pastdmark  
4f5f ..			.dmark: db "RER"  
4f62 f1			.pastdmark: pop af  
4f63			endm  
# End of macro DMARK
4f63						CALLMONITOR 
4f63 cd fb 19			call break_point_state  
4f66				endm  
# End of macro CALLMONITOR
4f66					endif 
4f66			 
4f66 e1					pop hl    ; get orig file id and mangle it for find id 
4f67 55					ld d, l 
4f68 5c					ld e, h 
4f69			 
4f69 21 00 00				ld hl, 0 
4f6c					if DEBUG_FORTH_WORDS 
4f6c						DMARK "REf" 
4f6c f5				push af  
4f6d 3a 81 4f			ld a, (.dmark)  
4f70 32 6e fe			ld (debug_mark),a  
4f73 3a 82 4f			ld a, (.dmark+1)  
4f76 32 6f fe			ld (debug_mark+1),a  
4f79 3a 83 4f			ld a, (.dmark+2)  
4f7c 32 70 fe			ld (debug_mark+2),a  
4f7f 18 03			jr .pastdmark  
4f81 ..			.dmark: db "REf"  
4f84 f1			.pastdmark: pop af  
4f85			endm  
# End of macro DMARK
4f85						CALLMONITOR 
4f85 cd fb 19			call break_point_state  
4f88				endm  
# End of macro CALLMONITOR
4f88					endif 
4f88 cd 4f 07				call storage_findnextid 
4f8b 11 7d fa				ld de, store_page 
4f8e					if DEBUG_FORTH_WORDS 
4f8e						DMARK "REw" 
4f8e f5				push af  
4f8f 3a a3 4f			ld a, (.dmark)  
4f92 32 6e fe			ld (debug_mark),a  
4f95 3a a4 4f			ld a, (.dmark+1)  
4f98 32 6f fe			ld (debug_mark+1),a  
4f9b 3a a5 4f			ld a, (.dmark+2)  
4f9e 32 70 fe			ld (debug_mark+2),a  
4fa1 18 03			jr .pastdmark  
4fa3 ..			.dmark: db "REw"  
4fa6 f1			.pastdmark: pop af  
4fa7			endm  
# End of macro DMARK
4fa7						CALLMONITOR 
4fa7 cd fb 19			call break_point_state  
4faa				endm  
# End of macro CALLMONITOR
4faa					endif 
4faa cd 81 04				call storage_write_block 
4fad			 
4fad 3e 00				ld a, 0 
4faf			.skiprneof: 
4faf					; drop file name 
4faf					FORTH_DSP_POP 
4faf cd 7a 23			call macro_forth_dsp_pop 
4fb2				endm 
# End of macro FORTH_DSP_POP
4fb2			 
4fb2 6f					ld l, a 
4fb3 26 00				ld h, 0 
4fb5 cd cb 20				call forth_push_numhl 
4fb8			 
4fb8			 
4fb8 f1					pop af 
4fb9 32 70 fa				ld (store_readcont),a 
4fbc e1					pop hl 
4fbd 22 6e fa				ld (store_openaddr), hl 
4fc0						 
4fc0				NEXTW 
4fc0 c3 78 24			jp macro_next 
4fc3				endm 
# End of macro NEXTW
4fc3			.RECORD: 
4fc3			  
4fc3				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4fc3 3a				db WORD_SYS_CORE+38             
4fc4 67 50			dw .BREAD            
4fc6 07				db 6 + 1 
4fc7 .. 00			db "RECORD",0              
4fce				endm 
# End of macro CWHEAD
4fce			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4fce			; | | Compatible with PicoSPINet  
4fce			 
4fce					if DEBUG_FORTH_WORDS_KEY 
4fce						DMARK "REC" 
4fce f5				push af  
4fcf 3a e3 4f			ld a, (.dmark)  
4fd2 32 6e fe			ld (debug_mark),a  
4fd5 3a e4 4f			ld a, (.dmark+1)  
4fd8 32 6f fe			ld (debug_mark+1),a  
4fdb 3a e5 4f			ld a, (.dmark+2)  
4fde 32 70 fe			ld (debug_mark+2),a  
4fe1 18 03			jr .pastdmark  
4fe3 ..			.dmark: db "REC"  
4fe6 f1			.pastdmark: pop af  
4fe7			endm  
# End of macro DMARK
4fe7						CALLMONITOR 
4fe7 cd fb 19			call break_point_state  
4fea				endm  
# End of macro CALLMONITOR
4fea					endif 
4fea			 
4fea					FORTH_DSP_VALUEHL 
4fea cd c2 22			call macro_dsp_valuehl 
4fed				endm 
# End of macro FORTH_DSP_VALUEHL
4fed			 
4fed e5					push hl    ; id 
4fee			 
4fee					FORTH_DSP_POP 
4fee cd 7a 23			call macro_forth_dsp_pop 
4ff1				endm 
# End of macro FORTH_DSP_POP
4ff1			 
4ff1					FORTH_DSP_VALUEHL 
4ff1 cd c2 22			call macro_dsp_valuehl 
4ff4				endm 
# End of macro FORTH_DSP_VALUEHL
4ff4			 
4ff4					FORTH_DSP_POP 
4ff4 cd 7a 23			call macro_forth_dsp_pop 
4ff7				endm 
# End of macro FORTH_DSP_POP
4ff7			 
4ff7 d1					pop de     ; get file id 
4ff8			 
4ff8					; e = file id 
4ff8					; l = file extent 
4ff8			 
4ff8			 
4ff8					; construct request to access file extent 
4ff8			 
4ff8			;		ld a, e 
4ff8 63					ld h, e 
4ff9					 
4ff9					 
4ff9					 
4ff9			 
4ff9					; e has id 
4ff9			 
4ff9 11 7d fa			ld de, store_page 
4ffc					if DEBUG_FORTH_WORDS 
4ffc						DMARK "REr" 
4ffc f5				push af  
4ffd 3a 11 50			ld a, (.dmark)  
5000 32 6e fe			ld (debug_mark),a  
5003 3a 12 50			ld a, (.dmark+1)  
5006 32 6f fe			ld (debug_mark+1),a  
5009 3a 13 50			ld a, (.dmark+2)  
500c 32 70 fe			ld (debug_mark+2),a  
500f 18 03			jr .pastdmark  
5011 ..			.dmark: db "REr"  
5014 f1			.pastdmark: pop af  
5015			endm  
# End of macro DMARK
5015						CALLMONITOR 
5015 cd fb 19			call break_point_state  
5018				endm  
# End of macro CALLMONITOR
5018					endif 
5018 cd 75 09				call storage_read 
501b cd af 0f			call ishlzero 
501e 28 22			jr z, .recnotfound 
5020			 
5020			 
5020					if DEBUG_FORTH_WORDS 
5020						DMARK "REe" 
5020 f5				push af  
5021 3a 35 50			ld a, (.dmark)  
5024 32 6e fe			ld (debug_mark),a  
5027 3a 36 50			ld a, (.dmark+1)  
502a 32 6f fe			ld (debug_mark+1),a  
502d 3a 37 50			ld a, (.dmark+2)  
5030 32 70 fe			ld (debug_mark+2),a  
5033 18 03			jr .pastdmark  
5035 ..			.dmark: db "REe"  
5038 f1			.pastdmark: pop af  
5039			endm  
# End of macro DMARK
5039						CALLMONITOR 
5039 cd fb 19			call break_point_state  
503c				endm  
# End of macro CALLMONITOR
503c					endif 
503c cd 39 21			call forth_push_str 
503f			 
503f					NEXTW 
503f c3 78 24			jp macro_next 
5042				endm 
# End of macro NEXTW
5042			 
5042			.recnotfound: 
5042					if DEBUG_FORTH_WORDS 
5042						DMARK "REf" 
5042 f5				push af  
5043 3a 57 50			ld a, (.dmark)  
5046 32 6e fe			ld (debug_mark),a  
5049 3a 58 50			ld a, (.dmark+1)  
504c 32 6f fe			ld (debug_mark+1),a  
504f 3a 59 50			ld a, (.dmark+2)  
5052 32 70 fe			ld (debug_mark+2),a  
5055 18 03			jr .pastdmark  
5057 ..			.dmark: db "REf"  
505a f1			.pastdmark: pop af  
505b			endm  
# End of macro DMARK
505b						CALLMONITOR 
505b cd fb 19			call break_point_state  
505e				endm  
# End of macro CALLMONITOR
505e					endif 
505e 21 ff 00			ld hl, 255 
5061 cd cb 20			call forth_push_numhl 
5064				NEXTW 
5064 c3 78 24			jp macro_next 
5067				endm 
# End of macro NEXTW
5067			 
5067			 
5067			.BREAD: 
5067			  
5067				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
5067 3a				db WORD_SYS_CORE+38             
5068 ea 50			dw .BWRITE            
506a 06				db 5 + 1 
506b .. 00			db "BREAD",0              
5071				endm 
# End of macro CWHEAD
5071			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
5071			; | | Compatible with PicoSPINet  
5071				 
5071					if DEBUG_FORTH_WORDS_KEY 
5071						DMARK "BRD" 
5071 f5				push af  
5072 3a 86 50			ld a, (.dmark)  
5075 32 6e fe			ld (debug_mark),a  
5078 3a 87 50			ld a, (.dmark+1)  
507b 32 6f fe			ld (debug_mark+1),a  
507e 3a 88 50			ld a, (.dmark+2)  
5081 32 70 fe			ld (debug_mark+2),a  
5084 18 03			jr .pastdmark  
5086 ..			.dmark: db "BRD"  
5089 f1			.pastdmark: pop af  
508a			endm  
# End of macro DMARK
508a						CALLMONITOR 
508a cd fb 19			call break_point_state  
508d				endm  
# End of macro CALLMONITOR
508d					endif 
508d			 
508d				FORTH_DSP_VALUEHL 
508d cd c2 22			call macro_dsp_valuehl 
5090				endm 
# End of macro FORTH_DSP_VALUEHL
5090			 
5090				FORTH_DSP_POP 
5090 cd 7a 23			call macro_forth_dsp_pop 
5093				endm 
# End of macro FORTH_DSP_POP
5093			 
5093				; calc block address 
5093			 
5093 eb				ex de, hl 
5094 3e 40			ld a, STORE_BLOCK_PHY 
5096 cd 09 0f			call Mult16 
5099			 
5099			 
5099 11 7d fa			ld de, store_page 
509c			 
509c					if DEBUG_FORTH_WORDS 
509c						DMARK "BR1" 
509c f5				push af  
509d 3a b1 50			ld a, (.dmark)  
50a0 32 6e fe			ld (debug_mark),a  
50a3 3a b2 50			ld a, (.dmark+1)  
50a6 32 6f fe			ld (debug_mark+1),a  
50a9 3a b3 50			ld a, (.dmark+2)  
50ac 32 70 fe			ld (debug_mark+2),a  
50af 18 03			jr .pastdmark  
50b1 ..			.dmark: db "BR1"  
50b4 f1			.pastdmark: pop af  
50b5			endm  
# End of macro DMARK
50b5						CALLMONITOR 
50b5 cd fb 19			call break_point_state  
50b8				endm  
# End of macro CALLMONITOR
50b8					endif 
50b8			 
50b8 cd 1c 04			call storage_read_block 
50bb			 
50bb cd af 0f			call ishlzero 
50be 20 05			jr nz, .brfound 
50c0			 
50c0 cd cb 20			call forth_push_numhl 
50c3 18 22			jr .brdone 
50c5			 
50c5			 
50c5			.brfound: 
50c5 21 7f fa		        ld hl, store_page+2 
50c8			 
50c8					if DEBUG_FORTH_WORDS 
50c8						DMARK "BR2" 
50c8 f5				push af  
50c9 3a dd 50			ld a, (.dmark)  
50cc 32 6e fe			ld (debug_mark),a  
50cf 3a de 50			ld a, (.dmark+1)  
50d2 32 6f fe			ld (debug_mark+1),a  
50d5 3a df 50			ld a, (.dmark+2)  
50d8 32 70 fe			ld (debug_mark+2),a  
50db 18 03			jr .pastdmark  
50dd ..			.dmark: db "BR2"  
50e0 f1			.pastdmark: pop af  
50e1			endm  
# End of macro DMARK
50e1						CALLMONITOR 
50e1 cd fb 19			call break_point_state  
50e4				endm  
# End of macro CALLMONITOR
50e4					endif 
50e4			 
50e4 cd 39 21			call forth_push_str 
50e7			 
50e7			 
50e7			.brdone: 
50e7			 
50e7					NEXTW 
50e7 c3 78 24			jp macro_next 
50ea				endm 
# End of macro NEXTW
50ea			.BWRITE: 
50ea				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
50ea 3a				db WORD_SYS_CORE+38             
50eb 7f 51			dw .BUPD            
50ed 07				db 6 + 1 
50ee .. 00			db "BWRITE",0              
50f5				endm 
# End of macro CWHEAD
50f5			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
50f5			; | | Compatible with PicoSPINet  
50f5			 
50f5					if DEBUG_FORTH_WORDS_KEY 
50f5						DMARK "BWR" 
50f5 f5				push af  
50f6 3a 0a 51			ld a, (.dmark)  
50f9 32 6e fe			ld (debug_mark),a  
50fc 3a 0b 51			ld a, (.dmark+1)  
50ff 32 6f fe			ld (debug_mark+1),a  
5102 3a 0c 51			ld a, (.dmark+2)  
5105 32 70 fe			ld (debug_mark+2),a  
5108 18 03			jr .pastdmark  
510a ..			.dmark: db "BWR"  
510d f1			.pastdmark: pop af  
510e			endm  
# End of macro DMARK
510e						CALLMONITOR 
510e cd fb 19			call break_point_state  
5111				endm  
# End of macro CALLMONITOR
5111					endif 
5111			 
5111				FORTH_DSP_VALUEHL 
5111 cd c2 22			call macro_dsp_valuehl 
5114				endm 
# End of macro FORTH_DSP_VALUEHL
5114			 
5114				; calc block address 
5114			 
5114 eb				ex de, hl 
5115 3e 40			ld a, STORE_BLOCK_PHY 
5117 cd 09 0f			call Mult16 
511a			 
511a e5				push hl         ; address 
511b			 
511b				FORTH_DSP_POP 
511b cd 7a 23			call macro_forth_dsp_pop 
511e				endm 
# End of macro FORTH_DSP_POP
511e			 
511e				FORTH_DSP_VALUEHL 
511e cd c2 22			call macro_dsp_valuehl 
5121				endm 
# End of macro FORTH_DSP_VALUEHL
5121			 
5121				FORTH_DSP_POP 
5121 cd 7a 23			call macro_forth_dsp_pop 
5124				endm 
# End of macro FORTH_DSP_POP
5124			 
5124 cd 58 0c			call storage_clear_page 
5127			 
5127				; copy string to store page 
5127			 
5127 e5				push hl     ; save string address 
5128			 
5128 3e 00			ld a, 0 
512a cd ef 13			call strlent 
512d			 
512d 23				inc hl 
512e			 
512e 4d				ld c, l 
512f 06 00			ld b, 0 
5131			 
5131 e1				pop hl 
5132 11 7f fa			ld de, store_page + 2 
5135					if DEBUG_FORTH_WORDS 
5135						DMARK "BW1" 
5135 f5				push af  
5136 3a 4a 51			ld a, (.dmark)  
5139 32 6e fe			ld (debug_mark),a  
513c 3a 4b 51			ld a, (.dmark+1)  
513f 32 6f fe			ld (debug_mark+1),a  
5142 3a 4c 51			ld a, (.dmark+2)  
5145 32 70 fe			ld (debug_mark+2),a  
5148 18 03			jr .pastdmark  
514a ..			.dmark: db "BW1"  
514d f1			.pastdmark: pop af  
514e			endm  
# End of macro DMARK
514e						CALLMONITOR 
514e cd fb 19			call break_point_state  
5151				endm  
# End of macro CALLMONITOR
5151					endif 
5151 ed b0			ldir 
5153			 
5153			 
5153				; poke the start of the block with flags to prevent high level file ops hitting the block 
5153			 
5153 21 ff ff			ld hl, $ffff 
5156			 
5156 22 7d fa			ld (store_page), hl	 
5159				 
5159 e1				pop hl    ; get address 
515a 11 7d fa			ld de, store_page 
515d			 
515d					if DEBUG_FORTH_WORDS 
515d						DMARK "BW2" 
515d f5				push af  
515e 3a 72 51			ld a, (.dmark)  
5161 32 6e fe			ld (debug_mark),a  
5164 3a 73 51			ld a, (.dmark+1)  
5167 32 6f fe			ld (debug_mark+1),a  
516a 3a 74 51			ld a, (.dmark+2)  
516d 32 70 fe			ld (debug_mark+2),a  
5170 18 03			jr .pastdmark  
5172 ..			.dmark: db "BW2"  
5175 f1			.pastdmark: pop af  
5176			endm  
# End of macro DMARK
5176						CALLMONITOR 
5176 cd fb 19			call break_point_state  
5179				endm  
# End of macro CALLMONITOR
5179					endif 
5179			 
5179 cd 81 04			call storage_write_block 
517c			 
517c					NEXTW 
517c c3 78 24			jp macro_next 
517f				endm 
# End of macro NEXTW
517f			 
517f			.BUPD: 
517f				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
517f 3a				db WORD_SYS_CORE+38             
5180 d5 51			dw .BYID            
5182 05				db 4 + 1 
5183 .. 00			db "BUPD",0              
5188				endm 
# End of macro CWHEAD
5188			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
5188			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
5188			; | | or completely different file system structure. 
5188			; | | Compatible with PicoSPINet  
5188			 
5188					if DEBUG_FORTH_WORDS_KEY 
5188						DMARK "BUD" 
5188 f5				push af  
5189 3a 9d 51			ld a, (.dmark)  
518c 32 6e fe			ld (debug_mark),a  
518f 3a 9e 51			ld a, (.dmark+1)  
5192 32 6f fe			ld (debug_mark+1),a  
5195 3a 9f 51			ld a, (.dmark+2)  
5198 32 70 fe			ld (debug_mark+2),a  
519b 18 03			jr .pastdmark  
519d ..			.dmark: db "BUD"  
51a0 f1			.pastdmark: pop af  
51a1			endm  
# End of macro DMARK
51a1						CALLMONITOR 
51a1 cd fb 19			call break_point_state  
51a4				endm  
# End of macro CALLMONITOR
51a4					endif 
51a4			 
51a4				FORTH_DSP_VALUEHL 
51a4 cd c2 22			call macro_dsp_valuehl 
51a7				endm 
# End of macro FORTH_DSP_VALUEHL
51a7			 
51a7				; calc block address 
51a7			 
51a7 eb				ex de, hl 
51a8 3e 40			ld a, STORE_BLOCK_PHY 
51aa cd 09 0f			call Mult16 
51ad			 
51ad				FORTH_DSP_POP 
51ad cd 7a 23			call macro_forth_dsp_pop 
51b0				endm 
# End of macro FORTH_DSP_POP
51b0			 
51b0			 
51b0 11 7d fa			ld de, store_page 
51b3			 
51b3					if DEBUG_FORTH_WORDS 
51b3						DMARK "BUe" 
51b3 f5				push af  
51b4 3a c8 51			ld a, (.dmark)  
51b7 32 6e fe			ld (debug_mark),a  
51ba 3a c9 51			ld a, (.dmark+1)  
51bd 32 6f fe			ld (debug_mark+1),a  
51c0 3a ca 51			ld a, (.dmark+2)  
51c3 32 70 fe			ld (debug_mark+2),a  
51c6 18 03			jr .pastdmark  
51c8 ..			.dmark: db "BUe"  
51cb f1			.pastdmark: pop af  
51cc			endm  
# End of macro DMARK
51cc						CALLMONITOR 
51cc cd fb 19			call break_point_state  
51cf				endm  
# End of macro CALLMONITOR
51cf					endif 
51cf			 
51cf cd 81 04			call storage_write_block 
51d2			 
51d2					NEXTW 
51d2 c3 78 24			jp macro_next 
51d5				endm 
# End of macro NEXTW
51d5			 
51d5			.BYID: 
51d5			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
51d5			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
51d5			; 
51d5			;		 
51d5			;		if DEBUG_FORTH_WORDS_KEY 
51d5			;			DMARK "BYID" 
51d5			;			CALLMONITOR 
51d5			;		endif 
51d5			; 
51d5			;		; get direct address 
51d5			; 
51d5			;		FORTH_DSP_VALUEHL 
51d5			; 
51d5			;		FORTH_DSP_POP 
51d5			; 
51d5			;	; calc block address 
51d5			; 
51d5			;	ex de, hl 
51d5			;	ld a, STORE_BLOCK_PHY 
51d5			;	call Mult16 
51d5			;	;	do BREAD with number as param 
51d5			;	; push the file name	 
51d5			;	ld de, store_page 
51d5			;	call storage_read_block 
51d5			 ;       ld hl, store_page+2 
51d5			; 
51d5			; 
51d5			;		NEXTW 
51d5			;.BYNAME: 
51d5				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
51d5 3a				db WORD_SYS_CORE+38             
51d6 ee 51			dw .DIR            
51d8 06				db 5 + 1 
51d9 .. 00			db "GETID",0              
51df				endm 
# End of macro CWHEAD
51df			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
51df			; | | Compatible with PicoSPINet  
51df			 
51df					; get pointer to file name to seek 
51df			 
51df					FORTH_DSP_VALUEHL 
51df cd c2 22			call macro_dsp_valuehl 
51e2				endm 
# End of macro FORTH_DSP_VALUEHL
51e2			 
51e2			 
51e2 cd 43 03				call storage_getid  
51e5			 
51e5					FORTH_DSP_POP 
51e5 cd 7a 23			call macro_forth_dsp_pop 
51e8				endm 
# End of macro FORTH_DSP_POP
51e8			 
51e8 cd cb 20				call forth_push_numhl 
51eb			 
51eb					NEXTW 
51eb c3 78 24			jp macro_next 
51ee				endm 
# End of macro NEXTW
51ee			; 
51ee			.DIR: 
51ee				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
51ee 3a				db WORD_SYS_CORE+38             
51ef f2 52			dw .SAVE            
51f1 04				db 3 + 1 
51f2 .. 00			db "DIR",0              
51f6				endm 
# End of macro CWHEAD
51f6			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
51f6			; | | Compatible with PicoSPINet  
51f6			 
51f6					if DEBUG_FORTH_WORDS_KEY 
51f6						DMARK "DIR" 
51f6 f5				push af  
51f7 3a 0b 52			ld a, (.dmark)  
51fa 32 6e fe			ld (debug_mark),a  
51fd 3a 0c 52			ld a, (.dmark+1)  
5200 32 6f fe			ld (debug_mark+1),a  
5203 3a 0d 52			ld a, (.dmark+2)  
5206 32 70 fe			ld (debug_mark+2),a  
5209 18 03			jr .pastdmark  
520b ..			.dmark: db "DIR"  
520e f1			.pastdmark: pop af  
520f			endm  
# End of macro DMARK
520f						CALLMONITOR 
520f cd fb 19			call break_point_state  
5212				endm  
# End of macro CALLMONITOR
5212					endif 
5212 cd cd 04			call storage_get_block_0 
5215			 
5215 21 7d fa			ld hl, store_page     ; get current id count 
5218 46				ld b, (hl) 
5219 0e 00			ld c, 0    ; count of files   
521b					if DEBUG_FORTH_WORDS 
521b						DMARK "DI1" 
521b f5				push af  
521c 3a 30 52			ld a, (.dmark)  
521f 32 6e fe			ld (debug_mark),a  
5222 3a 31 52			ld a, (.dmark+1)  
5225 32 6f fe			ld (debug_mark+1),a  
5228 3a 32 52			ld a, (.dmark+2)  
522b 32 70 fe			ld (debug_mark+2),a  
522e 18 03			jr .pastdmark  
5230 ..			.dmark: db "DI1"  
5233 f1			.pastdmark: pop af  
5234			endm  
# End of macro DMARK
5234						CALLMONITOR 
5234 cd fb 19			call break_point_state  
5237				endm  
# End of macro CALLMONITOR
5237					endif 
5237			 
5237				; check for empty drive 
5237			 
5237 3e 00			ld a, 0 
5239 b8				cp b 
523a ca a8 52			jp z, .dirdone 
523d			 
523d				; for each of the current ids do a search for them and if found push to stack 
523d			 
523d c5			.diritem:	push bc 
523e 21 40 00				ld hl, STORE_BLOCK_PHY 
5241 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5243 58					ld e,b 
5244			 
5244			;		if DEBUG_FORTH_WORDS 
5244			;			DMARK "DI2" 
5244			;			CALLMONITOR 
5244			;		endif 
5244			 
5244 cd 4f 07				call storage_findnextid 
5247			 
5247			;		if DEBUG_FORTH_WORDS 
5247			;			DMARK "DI3" 
5247			;			CALLMONITOR 
5247			;		endif 
5247			 
5247					; if found hl will be non zero 
5247			 
5247 cd af 0f				call ishlzero 
524a			;		ld a, l 
524a			;		add h 
524a			; 
524a			;		cp 0 
524a 28 59				jr z, .dirnotfound 
524c			 
524c					; increase count 
524c			 
524c c1					pop bc	 
524d 0c					inc c 
524e c5					push bc 
524f					 
524f			 
524f					; get file header and push the file name 
524f			 
524f 11 7d fa				ld de, store_page 
5252 cd 1c 04				call storage_read_block 
5255			 
5255					; push file id to stack 
5255				 
5255 3a 7d fa				ld a, (store_page) 
5258 26 00				ld h, 0 
525a 6f					ld l, a 
525b cd cb 20				call forth_push_numhl 
525e			 
525e					; push extent count to stack  
525e				 
525e 3a 7f fa				ld a, (store_page+2) 
5261 26 00				ld h, 0 
5263 6f					ld l, a 
5264 cd cb 20				call forth_push_numhl 
5267			 
5267					; push file name 
5267			 
5267 21 80 fa				ld hl, store_page+3 
526a					if DEBUG_FORTH_WORDS 
526a						DMARK "DI5" 
526a f5				push af  
526b 3a 7f 52			ld a, (.dmark)  
526e 32 6e fe			ld (debug_mark),a  
5271 3a 80 52			ld a, (.dmark+1)  
5274 32 6f fe			ld (debug_mark+1),a  
5277 3a 81 52			ld a, (.dmark+2)  
527a 32 70 fe			ld (debug_mark+2),a  
527d 18 03			jr .pastdmark  
527f ..			.dmark: db "DI5"  
5282 f1			.pastdmark: pop af  
5283			endm  
# End of macro DMARK
5283						CALLMONITOR 
5283 cd fb 19			call break_point_state  
5286				endm  
# End of macro CALLMONITOR
5286					endif 
5286 cd 39 21				call forth_push_str 
5289					if DEBUG_FORTH_WORDS 
5289						DMARK "DI6" 
5289 f5				push af  
528a 3a 9e 52			ld a, (.dmark)  
528d 32 6e fe			ld (debug_mark),a  
5290 3a 9f 52			ld a, (.dmark+1)  
5293 32 6f fe			ld (debug_mark+1),a  
5296 3a a0 52			ld a, (.dmark+2)  
5299 32 70 fe			ld (debug_mark+2),a  
529c 18 03			jr .pastdmark  
529e ..			.dmark: db "DI6"  
52a1 f1			.pastdmark: pop af  
52a2			endm  
# End of macro DMARK
52a2						CALLMONITOR 
52a2 cd fb 19			call break_point_state  
52a5				endm  
# End of macro CALLMONITOR
52a5					endif 
52a5			.dirnotfound: 
52a5 c1					pop bc     
52a6 10 95				djnz .diritem 
52a8				 
52a8			.dirdone:	 
52a8					if DEBUG_FORTH_WORDS 
52a8						DMARK "DI7" 
52a8 f5				push af  
52a9 3a bd 52			ld a, (.dmark)  
52ac 32 6e fe			ld (debug_mark),a  
52af 3a be 52			ld a, (.dmark+1)  
52b2 32 6f fe			ld (debug_mark+1),a  
52b5 3a bf 52			ld a, (.dmark+2)  
52b8 32 70 fe			ld (debug_mark+2),a  
52bb 18 03			jr .pastdmark  
52bd ..			.dmark: db "DI7"  
52c0 f1			.pastdmark: pop af  
52c1			endm  
# End of macro DMARK
52c1						CALLMONITOR 
52c1 cd fb 19			call break_point_state  
52c4				endm  
# End of macro CALLMONITOR
52c4					endif 
52c4			 
52c4					; push a count of the dir items found 
52c4			 
52c4 26 00				ld h, 0 
52c6 69					ld l, c 
52c7 cd cb 20				call forth_push_numhl 
52ca			 
52ca					; push the bank label 
52ca			 
52ca cd cd 04				call storage_get_block_0 
52cd			 
52cd				 
52cd 21 80 fa		 		ld hl, store_page+3 
52d0			 
52d0					if DEBUG_FORTH_WORDS 
52d0						DMARK "DI8" 
52d0 f5				push af  
52d1 3a e5 52			ld a, (.dmark)  
52d4 32 6e fe			ld (debug_mark),a  
52d7 3a e6 52			ld a, (.dmark+1)  
52da 32 6f fe			ld (debug_mark+1),a  
52dd 3a e7 52			ld a, (.dmark+2)  
52e0 32 70 fe			ld (debug_mark+2),a  
52e3 18 03			jr .pastdmark  
52e5 ..			.dmark: db "DI8"  
52e8 f1			.pastdmark: pop af  
52e9			endm  
# End of macro DMARK
52e9						CALLMONITOR 
52e9 cd fb 19			call break_point_state  
52ec				endm  
# End of macro CALLMONITOR
52ec					endif 
52ec cd 39 21				call forth_push_str 
52ef			 
52ef			 
52ef				 
52ef					NEXTW 
52ef c3 78 24			jp macro_next 
52f2				endm 
# End of macro NEXTW
52f2			.SAVE: 
52f2			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
52f2			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
52f2			;		NEXTW 
52f2			;.LOAD: 
52f2			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
52f2			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
52f2			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
52f2			;; > > The LOAD command can not be used in any user words or compound lines. 
52f2			; 
52f2			;		; store_openext use it. If zero it is EOF 
52f2			; 
52f2			;		; read block from current stream id 
52f2			;		; if the block does not contain zero term keep reading blocks until zero found 
52f2			;		; push the block to stack 
52f2			;		; save the block id to stream 
52f2			; 
52f2			; 
52f2			;		FORTH_DSP_VALUEHL 
52f2			; 
52f2			;;		push hl 
52f2			; 
52f2			;	if DEBUG_STORESE 
52f2			;		DMARK "LOA" 
52f2			;		CALLMONITOR 
52f2			;	endif 
52f2			;		FORTH_DSP_POP 
52f2			; 
52f2			;;		pop hl 
52f2			; 
52f2			;		ld h, l 
52f2			;		ld l, 0 
52f2			; 
52f2			;		push hl     ; stack holds current file id and extent to work with 
52f2			; 
52f2			; 
52f2			;		ld de, store_page      ; get block zero of file 
52f2			;	if DEBUG_STORESE 
52f2			;		DMARK "LO0" 
52f2			;		CALLMONITOR 
52f2			;	endif 
52f2			;		call storage_read 
52f2			; 
52f2			;		ld a, (store_page+2)    ; max extents for this file 
52f2			;		ld  (store_openmaxext),a   ; get our limit 
52f2			; 
52f2			;	if DEBUG_STORESE 
52f2			;		DMARK "LOE" 
52f2			;		CALLMONITOR 
52f2			;	endif 
52f2			; 
52f2			;; TODO dont know why max extents are not present 
52f2			;;		cp 0 
52f2			;;		jp z, .loadeof     ; dont read past eof 
52f2			; 
52f2			;;		ld a, 1   ; start from the head of the file 
52f2			; 
52f2			;.loadline:	pop hl 
52f2			;		inc hl 
52f2			;		ld  a, (store_openmaxext)   ; get our limit 
52f2			;	if DEBUG_STORESE 
52f2			;		DMARK "LOx" 
52f2			;		CALLMONITOR 
52f2			;	endif 
52f2			;		inc a 
52f2			;		cp l 
52f2			;		jp z, .loadeof 
52f2			;		push hl    ; save current extent 
52f2			; 
52f2			;		ld de, store_page 
52f2			; 
52f2			;	if DEBUG_STORESE 
52f2			;		DMARK "LO1" 
52f2			;		CALLMONITOR 
52f2			;	endif 
52f2			;		call storage_read 
52f2			; 
52f2			;	if DEBUG_STORESE 
52f2			;		DMARK "LO2" 
52f2			;		CALLMONITOR 
52f2			;	endif 
52f2			;	call ishlzero 
52f2			;	ld a, l 
52f2			;	add h 
52f2			;	cp 0 
52f2			;	jr z, .loadeof 
52f2			; 
52f2			;	; not eof so hl should point to data to exec 
52f2			; 
52f2			;	; will need to add the FORTH_END_BUFFER flag 
52f2			 ; 
52f2			;	ld hl, store_page+2 
52f2			;	ld bc, 255 
52f2			;	ld a, 0 
52f2			;	cpir 
52f2			;	if DEBUG_STORESE 
52f2			;		DMARK "LOt" 
52f2			;		CALLMONITOR 
52f2			;	endif 
52f2			;	dec hl 
52f2			;	ld a, ' ' 
52f2			;	ld (hl), a 
52f2			;	inc hl 
52f2			;	ld (hl), a 
52f2			;	inc hl 
52f2			;	ld (hl), a 
52f2			;	inc hl 
52f2			;	ld a, FORTH_END_BUFFER 
52f2			;	ld (hl), a 
52f2			; 
52f2			;	; TODO handle more than a single block read 
52f2			; 
52f2			; 
52f2			;	ld hl, store_page+2 
52f2			; 
52f2			;	ld (os_tok_ptr), hl 
52f2			; 
52f2			;	if DEBUG_STORESE 
52f2			;		DMARK "LO3" 
52f2			;		CALLMONITOR 
52f2			;	endif 
52f2			; 
52f2			;	call forthparse 
52f2			;	call forthexec 
52f2			;	call forthexec_cleanup 
52f2			; 
52f2			;	; go to next extent 
52f2			; 
52f2			;	; get next block  or mark as eof 
52f2			;	jp .loadline 
52f2			; 
52f2			; 
52f2			; 
52f2			;	       NEXTW 
52f2			;.loadeof:	ld a, 0 
52f2			;		ld (store_openext), a 
52f2			; 
52f2			;	if DEBUG_STORESE 
52f2			;		DMARK "LOF" 
52f2			;		CALLMONITOR 
52f2			;	endif 
52f2			;		ret 
52f2			;		;NEXTW 
52f2			;.BSAVE:   
52f2			; 
52f2			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
52f2			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
52f2			;		NEXTW 
52f2			;.BLOAD: 
52f2			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
52f2			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
52f2			;		NEXTW 
52f2			;;;; counter gap 
52f2			 
52f2			 
52f2			.SEO: 
52f2				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
52f2 64				db WORD_SYS_CORE+80             
52f3 11 53			dw .SEI            
52f5 04				db 3 + 1 
52f6 .. 00			db "SEO",0              
52fa				endm 
# End of macro CWHEAD
52fa			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
52fa			 
52fa					; get port 
52fa			 
52fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52fa cd c2 22			call macro_dsp_valuehl 
52fd				endm 
# End of macro FORTH_DSP_VALUEHL
52fd			 
52fd e5					push hl    ; u2 - byte 
52fe			 
52fe					; destroy value TOS 
52fe			 
52fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52fe cd 7a 23			call macro_forth_dsp_pop 
5301				endm 
# End of macro FORTH_DSP_POP
5301			 
5301					; get byte to send 
5301			 
5301					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5301 cd c2 22			call macro_dsp_valuehl 
5304				endm 
# End of macro FORTH_DSP_VALUEHL
5304			 
5304 e5					push hl    ; u1 - addr 
5305			 
5305					; destroy value TOS 
5305			 
5305					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5305 cd 7a 23			call macro_forth_dsp_pop 
5308				endm 
# End of macro FORTH_DSP_POP
5308			 
5308					; one value on hl get other one back 
5308			 
5308 d1					pop de   ; u1 - byte 
5309			 
5309 e1					pop hl   ; u2 - addr 
530a			 
530a					; TODO Send SPI byte 
530a			 
530a			 
530a 7b					ld a, e 
530b cd 21 02				call se_writebyte 
530e			 
530e					 
530e			 
530e					NEXTW 
530e c3 78 24			jp macro_next 
5311				endm 
# End of macro NEXTW
5311			 
5311			.SEI: 
5311				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5311 65				db WORD_SYS_CORE+81             
5312 2b 53			dw .SFREE            
5314 04				db 3 + 1 
5315 .. 00			db "SEI",0              
5319				endm 
# End of macro CWHEAD
5319			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5319			 
5319					; get port 
5319			 
5319					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5319 cd c2 22			call macro_dsp_valuehl 
531c				endm 
# End of macro FORTH_DSP_VALUEHL
531c			 
531c			;		push hl 
531c			 
531c					; destroy value TOS 
531c			 
531c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
531c cd 7a 23			call macro_forth_dsp_pop 
531f				endm 
# End of macro FORTH_DSP_POP
531f			 
531f					; one value on hl get other one back 
531f			 
531f			;		pop hl 
531f			 
531f			 
531f					; TODO Get SPI byte 
531f			 
531f cd c3 02				call se_readbyte 
5322			 
5322 26 00				ld h, 0 
5324 6f					ld l, a 
5325 cd cb 20				call forth_push_numhl 
5328			 
5328					NEXTW 
5328 c3 78 24			jp macro_next 
532b				endm 
# End of macro NEXTW
532b			 
532b			.SFREE: 
532b				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
532b 67				db WORD_SYS_CORE+83             
532c 5a 53			dw .SIZE            
532e 06				db 5 + 1 
532f .. 00			db "FFREE",0              
5335				endm 
# End of macro CWHEAD
5335			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5335			; | | Compatible with PicoSPINet  
5335					if DEBUG_FORTH_WORDS_KEY 
5335						DMARK "FFR" 
5335 f5				push af  
5336 3a 4a 53			ld a, (.dmark)  
5339 32 6e fe			ld (debug_mark),a  
533c 3a 4b 53			ld a, (.dmark+1)  
533f 32 6f fe			ld (debug_mark+1),a  
5342 3a 4c 53			ld a, (.dmark+2)  
5345 32 70 fe			ld (debug_mark+2),a  
5348 18 03			jr .pastdmark  
534a ..			.dmark: db "FFR"  
534d f1			.pastdmark: pop af  
534e			endm  
# End of macro DMARK
534e						CALLMONITOR 
534e cd fb 19			call break_point_state  
5351				endm  
# End of macro CALLMONITOR
5351					endif 
5351			 
5351 cd e9 07				call storage_freeblocks 
5354			 
5354 cd cb 20				call forth_push_numhl 
5357			 
5357				       NEXTW 
5357 c3 78 24			jp macro_next 
535a				endm 
# End of macro NEXTW
535a			.SIZE: 
535a				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
535a 67				db WORD_SYS_CORE+83             
535b 8e 53			dw .CREATE            
535d 05				db 4 + 1 
535e .. 00			db "SIZE",0              
5363				endm 
# End of macro CWHEAD
5363			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5363			; | | Compatible with PicoSPINet  
5363					if DEBUG_FORTH_WORDS_KEY 
5363						DMARK "SIZ" 
5363 f5				push af  
5364 3a 78 53			ld a, (.dmark)  
5367 32 6e fe			ld (debug_mark),a  
536a 3a 79 53			ld a, (.dmark+1)  
536d 32 6f fe			ld (debug_mark+1),a  
5370 3a 7a 53			ld a, (.dmark+2)  
5373 32 70 fe			ld (debug_mark+2),a  
5376 18 03			jr .pastdmark  
5378 ..			.dmark: db "SIZ"  
537b f1			.pastdmark: pop af  
537c			endm  
# End of macro DMARK
537c						CALLMONITOR 
537c cd fb 19			call break_point_state  
537f				endm  
# End of macro CALLMONITOR
537f					endif 
537f			 
537f					FORTH_DSP_VALUEHL 
537f cd c2 22			call macro_dsp_valuehl 
5382				endm 
# End of macro FORTH_DSP_VALUEHL
5382			;		push hl 
5382					FORTH_DSP_POP 
5382 cd 7a 23			call macro_forth_dsp_pop 
5385				endm 
# End of macro FORTH_DSP_POP
5385			;		pop hl 
5385 cd 4b 04				call storage_file_size 
5388			 
5388 cd cb 20				call forth_push_numhl 
538b			  
538b			 
538b				       NEXTW 
538b c3 78 24			jp macro_next 
538e				endm 
# End of macro NEXTW
538e			 
538e			.CREATE: 
538e				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
538e 68				db WORD_SYS_CORE+84             
538f fc 53			dw .APPEND            
5391 07				db 6 + 1 
5392 .. 00			db "CREATE",0              
5399				endm 
# End of macro CWHEAD
5399			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5399			; | | e.g.  
5399			; | | TestProgram CREATE 
5399			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5399			; | |  
5399			; | | Max file IDs are 255. 
5399			; | |  
5399			; | | Compatible with PicoSPINet  
5399					 
5399					if DEBUG_FORTH_WORDS_KEY 
5399						DMARK "CRT" 
5399 f5				push af  
539a 3a ae 53			ld a, (.dmark)  
539d 32 6e fe			ld (debug_mark),a  
53a0 3a af 53			ld a, (.dmark+1)  
53a3 32 6f fe			ld (debug_mark+1),a  
53a6 3a b0 53			ld a, (.dmark+2)  
53a9 32 70 fe			ld (debug_mark+2),a  
53ac 18 03			jr .pastdmark  
53ae ..			.dmark: db "CRT"  
53b1 f1			.pastdmark: pop af  
53b2			endm  
# End of macro DMARK
53b2						CALLMONITOR 
53b2 cd fb 19			call break_point_state  
53b5				endm  
# End of macro CALLMONITOR
53b5					endif 
53b5			;		call storage_get_block_0 
53b5			 
53b5					; TODO pop hl 
53b5			 
53b5					;v5 FORTH_DSP_VALUE 
53b5					FORTH_DSP_VALUE 
53b5 cd ab 22			call macro_forth_dsp_value 
53b8				endm 
# End of macro FORTH_DSP_VALUE
53b8			 
53b8				if DEBUG_STORESE 
53b8					DMARK "CR1" 
53b8 f5				push af  
53b9 3a cd 53			ld a, (.dmark)  
53bc 32 6e fe			ld (debug_mark),a  
53bf 3a ce 53			ld a, (.dmark+1)  
53c2 32 6f fe			ld (debug_mark+1),a  
53c5 3a cf 53			ld a, (.dmark+2)  
53c8 32 70 fe			ld (debug_mark+2),a  
53cb 18 03			jr .pastdmark  
53cd ..			.dmark: db "CR1"  
53d0 f1			.pastdmark: pop af  
53d1			endm  
# End of macro DMARK
53d1					CALLMONITOR 
53d1 cd fb 19			call break_point_state  
53d4				endm  
# End of macro CALLMONITOR
53d4				endif 
53d4			;		push hl 
53d4			;		FORTH_DSP_POP 
53d4			;		pop hl 
53d4			 
53d4			;		inc hl   ; move past the type marker 
53d4			 
53d4 cd 1f 08				call storage_create 
53d7			 
53d7				if DEBUG_STORESE 
53d7					DMARK "CT1" 
53d7 f5				push af  
53d8 3a ec 53			ld a, (.dmark)  
53db 32 6e fe			ld (debug_mark),a  
53de 3a ed 53			ld a, (.dmark+1)  
53e1 32 6f fe			ld (debug_mark+1),a  
53e4 3a ee 53			ld a, (.dmark+2)  
53e7 32 70 fe			ld (debug_mark+2),a  
53ea 18 03			jr .pastdmark  
53ec ..			.dmark: db "CT1"  
53ef f1			.pastdmark: pop af  
53f0			endm  
# End of macro DMARK
53f0					CALLMONITOR 
53f0 cd fb 19			call break_point_state  
53f3				endm  
# End of macro CALLMONITOR
53f3				endif 
53f3			;		push hl 
53f3					FORTH_DSP_POP 
53f3 cd 7a 23			call macro_forth_dsp_pop 
53f6				endm 
# End of macro FORTH_DSP_POP
53f6			;		pop hl 
53f6					; push file id to stack 
53f6 cd cb 20				call forth_push_numhl 
53f9			 
53f9			 
53f9			 
53f9				       NEXTW 
53f9 c3 78 24			jp macro_next 
53fc				endm 
# End of macro NEXTW
53fc			 
53fc			.APPEND: 
53fc				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
53fc 69				db WORD_SYS_CORE+85             
53fd 8d 54			dw .SDEL            
53ff 07				db 6 + 1 
5400 .. 00			db "APPEND",0              
5407				endm 
# End of macro CWHEAD
5407			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5407			; | | e.g. 
5407			; | | Test CREATE      -> $01 
5407			; | | "A string to add to file" $01 APPEND 
5407			; | |  
5407			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5407			; | | Compatible with PicoSPINet  
5407					if DEBUG_FORTH_WORDS_KEY 
5407						DMARK "APP" 
5407 f5				push af  
5408 3a 1c 54			ld a, (.dmark)  
540b 32 6e fe			ld (debug_mark),a  
540e 3a 1d 54			ld a, (.dmark+1)  
5411 32 6f fe			ld (debug_mark+1),a  
5414 3a 1e 54			ld a, (.dmark+2)  
5417 32 70 fe			ld (debug_mark+2),a  
541a 18 03			jr .pastdmark  
541c ..			.dmark: db "APP"  
541f f1			.pastdmark: pop af  
5420			endm  
# End of macro DMARK
5420						CALLMONITOR 
5420 cd fb 19			call break_point_state  
5423				endm  
# End of macro CALLMONITOR
5423					endif 
5423			 
5423					FORTH_DSP_VALUEHL 
5423 cd c2 22			call macro_dsp_valuehl 
5426				endm 
# End of macro FORTH_DSP_VALUEHL
5426 e5					push hl 	; save file id 
5427			 
5427				if DEBUG_STORESE 
5427					DMARK "AP1" 
5427 f5				push af  
5428 3a 3c 54			ld a, (.dmark)  
542b 32 6e fe			ld (debug_mark),a  
542e 3a 3d 54			ld a, (.dmark+1)  
5431 32 6f fe			ld (debug_mark+1),a  
5434 3a 3e 54			ld a, (.dmark+2)  
5437 32 70 fe			ld (debug_mark+2),a  
543a 18 03			jr .pastdmark  
543c ..			.dmark: db "AP1"  
543f f1			.pastdmark: pop af  
5440			endm  
# End of macro DMARK
5440					CALLMONITOR 
5440 cd fb 19			call break_point_state  
5443				endm  
# End of macro CALLMONITOR
5443				endif 
5443					FORTH_DSP_POP 
5443 cd 7a 23			call macro_forth_dsp_pop 
5446				endm 
# End of macro FORTH_DSP_POP
5446			 
5446					FORTH_DSP_VALUEHL 
5446 cd c2 22			call macro_dsp_valuehl 
5449				endm 
# End of macro FORTH_DSP_VALUEHL
5449					;v5 FORTH_DSP_VALUE 
5449 e5					push hl 	; save ptr to string to save 
544a			 
544a				if DEBUG_STORESE 
544a					DMARK "AP1" 
544a f5				push af  
544b 3a 5f 54			ld a, (.dmark)  
544e 32 6e fe			ld (debug_mark),a  
5451 3a 60 54			ld a, (.dmark+1)  
5454 32 6f fe			ld (debug_mark+1),a  
5457 3a 61 54			ld a, (.dmark+2)  
545a 32 70 fe			ld (debug_mark+2),a  
545d 18 03			jr .pastdmark  
545f ..			.dmark: db "AP1"  
5462 f1			.pastdmark: pop af  
5463			endm  
# End of macro DMARK
5463					CALLMONITOR 
5463 cd fb 19			call break_point_state  
5466				endm  
# End of macro CALLMONITOR
5466				endif 
5466					FORTH_DSP_POP 
5466 cd 7a 23			call macro_forth_dsp_pop 
5469				endm 
# End of macro FORTH_DSP_POP
5469			 
5469 d1					pop de 
546a e1					pop hl 
546b				if DEBUG_STORESE 
546b					DMARK "AP2" 
546b f5				push af  
546c 3a 80 54			ld a, (.dmark)  
546f 32 6e fe			ld (debug_mark),a  
5472 3a 81 54			ld a, (.dmark+1)  
5475 32 6f fe			ld (debug_mark+1),a  
5478 3a 82 54			ld a, (.dmark+2)  
547b 32 70 fe			ld (debug_mark+2),a  
547e 18 03			jr .pastdmark  
5480 ..			.dmark: db "AP2"  
5483 f1			.pastdmark: pop af  
5484			endm  
# End of macro DMARK
5484					CALLMONITOR 
5484 cd fb 19			call break_point_state  
5487				endm  
# End of macro CALLMONITOR
5487				endif 
5487					;inc de ; skip var type indicator 
5487			 
5487					; TODO how to append numerics???? 
5487			 
5487 cd 0c 0b				call storage_append		 
548a			 
548a				       NEXTW 
548a c3 78 24			jp macro_next 
548d				endm 
# End of macro NEXTW
548d			.SDEL: 
548d				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
548d 6a				db WORD_SYS_CORE+86             
548e d9 54			dw .OPEN            
5490 05				db 4 + 1 
5491 .. 00			db "ERA",0              
5495				endm 
# End of macro CWHEAD
5495			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5495			; | | Compatible with PicoSPINet  
5495					FORTH_DSP_VALUEHL 
5495 cd c2 22			call macro_dsp_valuehl 
5498				endm 
# End of macro FORTH_DSP_VALUEHL
5498			;		push hl 	; save file id 
5498			 
5498					if DEBUG_FORTH_WORDS_KEY 
5498						DMARK "ERA" 
5498 f5				push af  
5499 3a ad 54			ld a, (.dmark)  
549c 32 6e fe			ld (debug_mark),a  
549f 3a ae 54			ld a, (.dmark+1)  
54a2 32 6f fe			ld (debug_mark+1),a  
54a5 3a af 54			ld a, (.dmark+2)  
54a8 32 70 fe			ld (debug_mark+2),a  
54ab 18 03			jr .pastdmark  
54ad ..			.dmark: db "ERA"  
54b0 f1			.pastdmark: pop af  
54b1			endm  
# End of macro DMARK
54b1						CALLMONITOR 
54b1 cd fb 19			call break_point_state  
54b4				endm  
# End of macro CALLMONITOR
54b4					endif 
54b4				if DEBUG_STORESE 
54b4					DMARK "ER1" 
54b4 f5				push af  
54b5 3a c9 54			ld a, (.dmark)  
54b8 32 6e fe			ld (debug_mark),a  
54bb 3a ca 54			ld a, (.dmark+1)  
54be 32 6f fe			ld (debug_mark+1),a  
54c1 3a cb 54			ld a, (.dmark+2)  
54c4 32 70 fe			ld (debug_mark+2),a  
54c7 18 03			jr .pastdmark  
54c9 ..			.dmark: db "ER1"  
54cc f1			.pastdmark: pop af  
54cd			endm  
# End of macro DMARK
54cd					CALLMONITOR 
54cd cd fb 19			call break_point_state  
54d0				endm  
# End of macro CALLMONITOR
54d0				endif 
54d0					FORTH_DSP_POP 
54d0 cd 7a 23			call macro_forth_dsp_pop 
54d3				endm 
# End of macro FORTH_DSP_POP
54d3			 
54d3			;		pop hl 
54d3			 
54d3 cd 5e 06				call storage_erase 
54d6				       NEXTW 
54d6 c3 78 24			jp macro_next 
54d9				endm 
# End of macro NEXTW
54d9			 
54d9			.OPEN: 
54d9				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
54d9 6b				db WORD_SYS_CORE+87             
54da 6d 55			dw .READ            
54dc 05				db 4 + 1 
54dd .. 00			db "OPEN",0              
54e2				endm 
# End of macro CWHEAD
54e2			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
54e2			; | | e.g. 
54e2			; | | $01 OPEN $01 DO $01 READ . LOOP 
54e2			; | | 
54e2			; | | Will return with 255 blocks if the file does not exist 
54e2			; | | Compatible with PicoSPINet  
54e2			 
54e2					if DEBUG_FORTH_WORDS_KEY 
54e2						DMARK "OPN" 
54e2 f5				push af  
54e3 3a f7 54			ld a, (.dmark)  
54e6 32 6e fe			ld (debug_mark),a  
54e9 3a f8 54			ld a, (.dmark+1)  
54ec 32 6f fe			ld (debug_mark+1),a  
54ef 3a f9 54			ld a, (.dmark+2)  
54f2 32 70 fe			ld (debug_mark+2),a  
54f5 18 03			jr .pastdmark  
54f7 ..			.dmark: db "OPN"  
54fa f1			.pastdmark: pop af  
54fb			endm  
# End of macro DMARK
54fb						CALLMONITOR 
54fb cd fb 19			call break_point_state  
54fe				endm  
# End of macro CALLMONITOR
54fe					endif 
54fe					; TODO handle multiple file opens 
54fe			 
54fe 3e 01			       	ld a, 1 
5500 32 6d fa				ld (store_openext), a 
5503			 
5503					; get max extents for this file 
5503				 
5503								 
5503					FORTH_DSP_VALUEHL 
5503 cd c2 22			call macro_dsp_valuehl 
5506				endm 
# End of macro FORTH_DSP_VALUEHL
5506			 
5506 65					ld h, l 
5507 2e 00				ld l, 0 
5509			 
5509					; store file id 
5509			 
5509 7c					ld a, h 
550a 32 6a fa				ld (store_filecache), a 
550d			 
550d				if DEBUG_STORESE 
550d					DMARK "OPN" 
550d f5				push af  
550e 3a 22 55			ld a, (.dmark)  
5511 32 6e fe			ld (debug_mark),a  
5514 3a 23 55			ld a, (.dmark+1)  
5517 32 6f fe			ld (debug_mark+1),a  
551a 3a 24 55			ld a, (.dmark+2)  
551d 32 70 fe			ld (debug_mark+2),a  
5520 18 03			jr .pastdmark  
5522 ..			.dmark: db "OPN"  
5525 f1			.pastdmark: pop af  
5526			endm  
# End of macro DMARK
5526					CALLMONITOR 
5526 cd fb 19			call break_point_state  
5529				endm  
# End of macro CALLMONITOR
5529				endif 
5529			;		push hl 
5529					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5529 cd 7a 23			call macro_forth_dsp_pop 
552c				endm 
# End of macro FORTH_DSP_POP
552c			;		pop hl 
552c						 
552c 11 7d fa				ld de, store_page      ; get block zero of file 
552f cd 75 09				call storage_read 
5532 cd af 0f			call ishlzero 
5535 20 04			jr nz, .opfound 
5537			 
5537				; file does not exist so indicate with 255 extents in use 
5537			 
5537 3e ff			ld a, 255 
5539 18 29			jr .skipopeneof 
553b			 
553b			 
553b			.opfound: 
553b			 
553b			 
553b 3a 7f fa				ld a, (store_page+2)    ; max extents for this file 
553e 32 6c fa				ld  (store_openmaxext), a   ; get our limit and push 
5541					 
5541				if DEBUG_STORESE 
5541					DMARK "OPx" 
5541 f5				push af  
5542 3a 56 55			ld a, (.dmark)  
5545 32 6e fe			ld (debug_mark),a  
5548 3a 57 55			ld a, (.dmark+1)  
554b 32 6f fe			ld (debug_mark+1),a  
554e 3a 58 55			ld a, (.dmark+2)  
5551 32 70 fe			ld (debug_mark+2),a  
5554 18 03			jr .pastdmark  
5556 ..			.dmark: db "OPx"  
5559 f1			.pastdmark: pop af  
555a			endm  
# End of macro DMARK
555a					CALLMONITOR 
555a cd fb 19			call break_point_state  
555d				endm  
# End of macro CALLMONITOR
555d				endif 
555d fe 00				cp 0 
555f 20 03				jr nz, .skipopeneof 
5561					; have opened an empty file 
5561					 
5561 32 6d fa				ld (store_openext), a 
5564			 
5564			.skipopeneof: 
5564			 
5564 6f					ld l, a 
5565 26 00				ld h, 0 
5567 cd cb 20				call forth_push_numhl 
556a			 
556a			 
556a				       NEXTW 
556a c3 78 24			jp macro_next 
556d				endm 
# End of macro NEXTW
556d			.READ: 
556d				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
556d 6c				db WORD_SYS_CORE+88             
556e 97 56			dw .EOF            
5570 05				db 4 + 1 
5571 .. 00			db "READ",0              
5576				endm 
# End of macro CWHEAD
5576			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5576			; | | e.g. 
5576			; | | $01 OPEN $01 DO READ . LOOP 
5576			; | | 
5576			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5576			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5576			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5576			; | | two bytes contain the file id and extent. 
5576			; | |  
5576			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5576			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5576			; | | Compatible with PicoSPINet  
5576			 
5576					if DEBUG_FORTH_WORDS_KEY 
5576						DMARK "REA" 
5576 f5				push af  
5577 3a 8b 55			ld a, (.dmark)  
557a 32 6e fe			ld (debug_mark),a  
557d 3a 8c 55			ld a, (.dmark+1)  
5580 32 6f fe			ld (debug_mark+1),a  
5583 3a 8d 55			ld a, (.dmark+2)  
5586 32 70 fe			ld (debug_mark+2),a  
5589 18 03			jr .pastdmark  
558b ..			.dmark: db "REA"  
558e f1			.pastdmark: pop af  
558f			endm  
# End of macro DMARK
558f						CALLMONITOR 
558f cd fb 19			call break_point_state  
5592				endm  
# End of macro CALLMONITOR
5592					endif 
5592					; store_openext use it. If zero it is EOF 
5592			 
5592					; read block from current stream id 
5592					; if the block does not contain zero term keep reading blocks until zero found 
5592					; push the block to stack 
5592					; save the block id to stream 
5592			 
5592			 
5592 cd c4 56				call .testeof 
5595 3e 01				ld a, 1 
5597 bd					cp l 
5598 ca 73 56				jp z, .ateof 
559b			 
559b			 
559b			;		FORTH_DSP_VALUEHL 
559b			 
559b			;		push hl 
559b			 
559b			;	if DEBUG_STORESE 
559b			;		DMARK "REA" 
559b			;		CALLMONITOR 
559b			;	endif 
559b			;		FORTH_DSP_POP 
559b			 
559b			;		pop hl 
559b				 
559b 3a 6a fa				ld a, (store_filecache) 
559e 67					ld h,a 
559f			 
559f 3a 6d fa				ld a, (store_openext) 
55a2 6f					ld l, a 
55a3					 
55a3 fe 00				cp 0 
55a5 ca 73 56				jp z, .ateof     ; dont read past eof 
55a8			 
55a8 cd 58 0c				call storage_clear_page 
55ab			 
55ab 11 7d fa				ld de, store_page 
55ae				if DEBUG_STORESE 
55ae					DMARK "RE1" 
55ae f5				push af  
55af 3a c3 55			ld a, (.dmark)  
55b2 32 6e fe			ld (debug_mark),a  
55b5 3a c4 55			ld a, (.dmark+1)  
55b8 32 6f fe			ld (debug_mark+1),a  
55bb 3a c5 55			ld a, (.dmark+2)  
55be 32 70 fe			ld (debug_mark+2),a  
55c1 18 03			jr .pastdmark  
55c3 ..			.dmark: db "RE1"  
55c6 f1			.pastdmark: pop af  
55c7			endm  
# End of macro DMARK
55c7					CALLMONITOR 
55c7 cd fb 19			call break_point_state  
55ca				endm  
# End of macro CALLMONITOR
55ca				endif 
55ca cd 75 09				call storage_read 
55cd			 
55cd				if DEBUG_STORESE 
55cd					DMARK "RE2" 
55cd f5				push af  
55ce 3a e2 55			ld a, (.dmark)  
55d1 32 6e fe			ld (debug_mark),a  
55d4 3a e3 55			ld a, (.dmark+1)  
55d7 32 6f fe			ld (debug_mark+1),a  
55da 3a e4 55			ld a, (.dmark+2)  
55dd 32 70 fe			ld (debug_mark+2),a  
55e0 18 03			jr .pastdmark  
55e2 ..			.dmark: db "RE2"  
55e5 f1			.pastdmark: pop af  
55e6			endm  
# End of macro DMARK
55e6					CALLMONITOR 
55e6 cd fb 19			call break_point_state  
55e9				endm  
# End of macro CALLMONITOR
55e9				endif 
55e9 cd af 0f			call ishlzero 
55ec			;	ld a, l 
55ec			;	add h 
55ec			;	cp 0 
55ec ca 73 56			jp z, .readeof 
55ef			 
55ef				; not eof so hl should point to data to push to stack 
55ef			 
55ef				if DEBUG_STORESE 
55ef					DMARK "RE3" 
55ef f5				push af  
55f0 3a 04 56			ld a, (.dmark)  
55f3 32 6e fe			ld (debug_mark),a  
55f6 3a 05 56			ld a, (.dmark+1)  
55f9 32 6f fe			ld (debug_mark+1),a  
55fc 3a 06 56			ld a, (.dmark+2)  
55ff 32 70 fe			ld (debug_mark+2),a  
5602 18 03			jr .pastdmark  
5604 ..			.dmark: db "RE3"  
5607 f1			.pastdmark: pop af  
5608			endm  
# End of macro DMARK
5608					CALLMONITOR 
5608 cd fb 19			call break_point_state  
560b				endm  
# End of macro CALLMONITOR
560b				endif 
560b cd 39 21			call forth_push_str 
560e			 
560e				if DEBUG_STORESE 
560e					DMARK "RE4" 
560e f5				push af  
560f 3a 23 56			ld a, (.dmark)  
5612 32 6e fe			ld (debug_mark),a  
5615 3a 24 56			ld a, (.dmark+1)  
5618 32 6f fe			ld (debug_mark+1),a  
561b 3a 25 56			ld a, (.dmark+2)  
561e 32 70 fe			ld (debug_mark+2),a  
5621 18 03			jr .pastdmark  
5623 ..			.dmark: db "RE4"  
5626 f1			.pastdmark: pop af  
5627			endm  
# End of macro DMARK
5627					CALLMONITOR 
5627 cd fb 19			call break_point_state  
562a				endm  
# End of macro CALLMONITOR
562a				endif 
562a				; get next block  or mark as eof 
562a			 
562a 3a 6c fa			ld a, (store_openmaxext)   ; get our limit 
562d 4f				ld c, a	 
562e 3a 6d fa			ld a, (store_openext) 
5631			 
5631				if DEBUG_STORESE 
5631					DMARK "RE5" 
5631 f5				push af  
5632 3a 46 56			ld a, (.dmark)  
5635 32 6e fe			ld (debug_mark),a  
5638 3a 47 56			ld a, (.dmark+1)  
563b 32 6f fe			ld (debug_mark+1),a  
563e 3a 48 56			ld a, (.dmark+2)  
5641 32 70 fe			ld (debug_mark+2),a  
5644 18 03			jr .pastdmark  
5646 ..			.dmark: db "RE5"  
5649 f1			.pastdmark: pop af  
564a			endm  
# End of macro DMARK
564a					CALLMONITOR 
564a cd fb 19			call break_point_state  
564d				endm  
# End of macro CALLMONITOR
564d				endif 
564d b9				cp c 
564e 28 23			jr z, .readeof     ; at last extent 
5650			 
5650 3c					inc a 
5651 32 6d fa				ld (store_openext), a 
5654			 
5654				if DEBUG_STORESE 
5654					DMARK "RE6" 
5654 f5				push af  
5655 3a 69 56			ld a, (.dmark)  
5658 32 6e fe			ld (debug_mark),a  
565b 3a 6a 56			ld a, (.dmark+1)  
565e 32 6f fe			ld (debug_mark+1),a  
5661 3a 6b 56			ld a, (.dmark+2)  
5664 32 70 fe			ld (debug_mark+2),a  
5667 18 03			jr .pastdmark  
5669 ..			.dmark: db "RE6"  
566c f1			.pastdmark: pop af  
566d			endm  
# End of macro DMARK
566d					CALLMONITOR 
566d cd fb 19			call break_point_state  
5670				endm  
# End of macro CALLMONITOR
5670				endif 
5670			 
5670			 
5670				       NEXTW 
5670 c3 78 24			jp macro_next 
5673				endm 
# End of macro NEXTW
5673			.ateof: 
5673				;	ld hl, .showeof 
5673				;	call forth_push_str 
5673 3e 00		.readeof:	ld a, 0 
5675 32 6d fa				ld (store_openext), a 
5678			 
5678					 
5678				if DEBUG_STORESE 
5678					DMARK "REF" 
5678 f5				push af  
5679 3a 8d 56			ld a, (.dmark)  
567c 32 6e fe			ld (debug_mark),a  
567f 3a 8e 56			ld a, (.dmark+1)  
5682 32 6f fe			ld (debug_mark+1),a  
5685 3a 8f 56			ld a, (.dmark+2)  
5688 32 70 fe			ld (debug_mark+2),a  
568b 18 03			jr .pastdmark  
568d ..			.dmark: db "REF"  
5690 f1			.pastdmark: pop af  
5691			endm  
# End of macro DMARK
5691					CALLMONITOR 
5691 cd fb 19			call break_point_state  
5694				endm  
# End of macro CALLMONITOR
5694				endif 
5694				       NEXTW 
5694 c3 78 24			jp macro_next 
5697				endm 
# End of macro NEXTW
5697			 
5697			;.showeof:   db "eof", 0 
5697			 
5697			 
5697			.EOF: 
5697				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5697 6d				db WORD_SYS_CORE+89             
5698 d9 56			dw .FORMAT            
569a 04				db 3 + 1 
569b .. 00			db "EOF",0              
569f				endm 
# End of macro CWHEAD
569f			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
569f			; | | e.g. 
569f			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
569f			; | | Compatible with PicoSPINet  
569f					; TODO if current block id for stream is zero then push true else false 
569f			 
569f					if DEBUG_FORTH_WORDS_KEY 
569f						DMARK "EOF" 
569f f5				push af  
56a0 3a b4 56			ld a, (.dmark)  
56a3 32 6e fe			ld (debug_mark),a  
56a6 3a b5 56			ld a, (.dmark+1)  
56a9 32 6f fe			ld (debug_mark+1),a  
56ac 3a b6 56			ld a, (.dmark+2)  
56af 32 70 fe			ld (debug_mark+2),a  
56b2 18 03			jr .pastdmark  
56b4 ..			.dmark: db "EOF"  
56b7 f1			.pastdmark: pop af  
56b8			endm  
# End of macro DMARK
56b8						CALLMONITOR 
56b8 cd fb 19			call break_point_state  
56bb				endm  
# End of macro CALLMONITOR
56bb					endif 
56bb			 
56bb					; TODO handlue multiple file streams 
56bb			 
56bb			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
56bb cd c4 56				call .testeof 
56be cd cb 20				call forth_push_numhl 
56c1			 
56c1			 
56c1				       NEXTW 
56c1 c3 78 24			jp macro_next 
56c4				endm 
# End of macro NEXTW
56c4			 
56c4			.testeof: 
56c4 2e 01				ld l, 1 
56c6 3a 6c fa				ld a, (store_openmaxext) 
56c9 fe 00				cp 0 
56cb 28 09				jr  z, .eofdone   ; empty file 
56cd 3a 6d fa				ld a, (store_openext) 
56d0 fe 00				cp 0 
56d2 28 02				jr  z, .eofdone 
56d4 2e 00				ld l, 0 
56d6 26 00		.eofdone:	ld h, 0 
56d8 c9					ret 
56d9			 
56d9			 
56d9			 
56d9			 
56d9			.FORMAT: 
56d9				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
56d9 6d				db WORD_SYS_CORE+89             
56da 2a 57			dw .LABEL            
56dc 07				db 6 + 1 
56dd .. 00			db "FORMAT",0              
56e4				endm 
# End of macro CWHEAD
56e4			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
56e4			; | | Compatible with PicoSPINet  
56e4					; TODO if current block id for stream is zero then push true else false 
56e4				 
56e4				if DEBUG_STORESE 
56e4					DMARK "FOR" 
56e4 f5				push af  
56e5 3a f9 56			ld a, (.dmark)  
56e8 32 6e fe			ld (debug_mark),a  
56eb 3a fa 56			ld a, (.dmark+1)  
56ee 32 6f fe			ld (debug_mark+1),a  
56f1 3a fb 56			ld a, (.dmark+2)  
56f4 32 70 fe			ld (debug_mark+2),a  
56f7 18 03			jr .pastdmark  
56f9 ..			.dmark: db "FOR"  
56fc f1			.pastdmark: pop af  
56fd			endm  
# End of macro DMARK
56fd					CALLMONITOR 
56fd cd fb 19			call break_point_state  
5700				endm  
# End of macro CALLMONITOR
5700				endif 
5700					; Wipes the bank check flags to cause a reformat on next block 0 read 
5700			 
5700 21 01 00				ld hl, 1 
5703 3e 00				ld a, 0 
5705 cd 21 02				call se_writebyte 
5708			 
5708				if DEBUG_STORESE 
5708					DMARK "FO0" 
5708 f5				push af  
5709 3a 1d 57			ld a, (.dmark)  
570c 32 6e fe			ld (debug_mark),a  
570f 3a 1e 57			ld a, (.dmark+1)  
5712 32 6f fe			ld (debug_mark+1),a  
5715 3a 1f 57			ld a, (.dmark+2)  
5718 32 70 fe			ld (debug_mark+2),a  
571b 18 03			jr .pastdmark  
571d ..			.dmark: db "FO0"  
5720 f1			.pastdmark: pop af  
5721			endm  
# End of macro DMARK
5721					CALLMONITOR 
5721 cd fb 19			call break_point_state  
5724				endm  
# End of macro CALLMONITOR
5724				endif 
5724					; force bank init 
5724			 
5724 cd cd 04				call storage_get_block_0 
5727					 
5727				       NEXTW 
5727 c3 78 24			jp macro_next 
572a				endm 
# End of macro NEXTW
572a			.LABEL: 
572a				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
572a 6d				db WORD_SYS_CORE+89             
572b 78 57			dw .STOREPAGE            
572d 06				db 5 + 1 
572e .. 00			db "LABEL",0              
5734				endm 
# End of macro CWHEAD
5734			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5734			; | | Compatible with PicoSPINet  
5734					; TODO test to see if bank is selected 
5734				 
5734					if DEBUG_FORTH_WORDS_KEY 
5734						DMARK "LBL" 
5734 f5				push af  
5735 3a 49 57			ld a, (.dmark)  
5738 32 6e fe			ld (debug_mark),a  
573b 3a 4a 57			ld a, (.dmark+1)  
573e 32 6f fe			ld (debug_mark+1),a  
5741 3a 4b 57			ld a, (.dmark+2)  
5744 32 70 fe			ld (debug_mark+2),a  
5747 18 03			jr .pastdmark  
5749 ..			.dmark: db "LBL"  
574c f1			.pastdmark: pop af  
574d			endm  
# End of macro DMARK
574d						CALLMONITOR 
574d cd fb 19			call break_point_state  
5750				endm  
# End of macro CALLMONITOR
5750					endif 
5750			;	if DEBUG_STORESE 
5750			;		DMARK "LBL" 
5750			;		CALLMONITOR 
5750			;	endif 
5750					FORTH_DSP_VALUEHL 
5750 cd c2 22			call macro_dsp_valuehl 
5753				endm 
# End of macro FORTH_DSP_VALUEHL
5753					;v5FORTH_DSP_VALUE 
5753					 
5753			;		push hl 
5753					FORTH_DSP_POP 
5753 cd 7a 23			call macro_forth_dsp_pop 
5756				endm 
# End of macro FORTH_DSP_POP
5756			;		pop hl 
5756			 
5756			;v5		inc hl   ; move past the type marker 
5756			 
5756				if DEBUG_STORESE 
5756					DMARK "LBl" 
5756 f5				push af  
5757 3a 6b 57			ld a, (.dmark)  
575a 32 6e fe			ld (debug_mark),a  
575d 3a 6c 57			ld a, (.dmark+1)  
5760 32 6f fe			ld (debug_mark+1),a  
5763 3a 6d 57			ld a, (.dmark+2)  
5766 32 70 fe			ld (debug_mark+2),a  
5769 18 03			jr .pastdmark  
576b ..			.dmark: db "LBl"  
576e f1			.pastdmark: pop af  
576f			endm  
# End of macro DMARK
576f					CALLMONITOR 
576f cd fb 19			call break_point_state  
5772				endm  
# End of macro CALLMONITOR
5772				endif 
5772 cd f1 05				call storage_label 
5775			 
5775				       NEXTW 
5775 c3 78 24			jp macro_next 
5778				endm 
# End of macro NEXTW
5778			.STOREPAGE: 
5778				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5778 6d				db WORD_SYS_CORE+89             
5779 ab 57			dw .LABELS            
577b 0a				db 9 + 1 
577c .. 00			db "STOREPAGE",0              
5786				endm 
# End of macro CWHEAD
5786			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5786			; | | Compatible with PicoSPINet  
5786					; TODO test to see if bank is selected 
5786				 
5786					if DEBUG_FORTH_WORDS_KEY 
5786						DMARK "STP" 
5786 f5				push af  
5787 3a 9b 57			ld a, (.dmark)  
578a 32 6e fe			ld (debug_mark),a  
578d 3a 9c 57			ld a, (.dmark+1)  
5790 32 6f fe			ld (debug_mark+1),a  
5793 3a 9d 57			ld a, (.dmark+2)  
5796 32 70 fe			ld (debug_mark+2),a  
5799 18 03			jr .pastdmark  
579b ..			.dmark: db "STP"  
579e f1			.pastdmark: pop af  
579f			endm  
# End of macro DMARK
579f						CALLMONITOR 
579f cd fb 19			call break_point_state  
57a2				endm  
# End of macro CALLMONITOR
57a2					endif 
57a2			;	if DEBUG_STORESE 
57a2			;		DMARK "STP" 
57a2			;		CALLMONITOR 
57a2			;	endif 
57a2			 
57a2 21 7d fa			ld hl, store_page 
57a5 cd cb 20			call forth_push_numhl 
57a8			 
57a8			 
57a8				       NEXTW 
57a8 c3 78 24			jp macro_next 
57ab				endm 
# End of macro NEXTW
57ab			.LABELS: 
57ab				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
57ab 6d				db WORD_SYS_CORE+89             
57ac 35 58			dw .SCONST1            
57ae 07				db 6 + 1 
57af .. 00			db "LABELS",0              
57b6				endm 
# End of macro CWHEAD
57b6			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
57b6			; | | *NOT* Compatible with PicoSPINet  
57b6					;  
57b6			 
57b6					; save the current device selected to restore afterwards 
57b6				 
57b6 3a 63 fa				ld a, (spi_device) 
57b9 f5					push af 
57ba			 
57ba			 
57ba					; run through each of the banks 
57ba			 
57ba 21 01 00				ld hl, 1 
57bd cd cb 20				call forth_push_numhl 
57c0 3e ff				ld a, SPI_CE_HIGH 
57c2 cb 87				res SPI_CE0, a 
57c4 32 63 fa				ld (spi_device), a 
57c7 cd cd 04				call storage_get_block_0 
57ca 21 80 fa				ld hl, store_page+3 
57cd cd 39 21				call forth_push_str 
57d0			 
57d0					 
57d0 21 02 00				ld hl, 2 
57d3 cd cb 20				call forth_push_numhl 
57d6 3e ff				ld a, SPI_CE_HIGH 
57d8 cb 8f				res SPI_CE1, a 
57da 32 63 fa				ld (spi_device), a 
57dd cd cd 04				call storage_get_block_0 
57e0 21 80 fa				ld hl, store_page+3 
57e3 cd 39 21				call forth_push_str 
57e6			 
57e6					 
57e6 21 03 00				ld hl, 3 
57e9 cd cb 20				call forth_push_numhl 
57ec 3e ff				ld a, SPI_CE_HIGH 
57ee cb 97				res SPI_CE2, a 
57f0 32 63 fa				ld (spi_device), a 
57f3 cd cd 04				call storage_get_block_0 
57f6 21 80 fa				ld hl, store_page+3 
57f9 cd 39 21				call forth_push_str 
57fc			 
57fc			 
57fc 21 04 00				ld hl, 4 
57ff cd cb 20				call forth_push_numhl 
5802 3e ff				ld a, SPI_CE_HIGH 
5804 cb 9f				res SPI_CE3, a 
5806 32 63 fa				ld (spi_device), a 
5809 cd cd 04				call storage_get_block_0 
580c 21 80 fa				ld hl, store_page+3 
580f cd 39 21				call forth_push_str 
5812			 
5812					 
5812			 
5812 21 05 00				ld hl, 5 
5815 cd cb 20				call forth_push_numhl 
5818 3e ff				ld a, SPI_CE_HIGH 
581a cb a7				res SPI_CE4, a 
581c 32 63 fa				ld (spi_device), a 
581f cd cd 04				call storage_get_block_0 
5822 21 80 fa				ld hl, store_page+3 
5825 cd 39 21				call forth_push_str 
5828			 
5828					 
5828					; push fixed count of storage devices (on board) for now 
5828			 
5828 21 05 00				ld hl, 5 
582b cd cb 20				call forth_push_numhl 
582e			 
582e					; restore selected device  
582e				 
582e f1					pop af 
582f 32 63 fa				ld (spi_device), a 
5832			 
5832				       NEXTW 
5832 c3 78 24			jp macro_next 
5835				endm 
# End of macro NEXTW
5835			 
5835			.SCONST1: 
5835				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5835 6d				db WORD_SYS_CORE+89             
5836 4c 58			dw .SCONST2            
5838 07				db 6 + 1 
5839 .. 00			db "FILEID",0              
5840				endm 
# End of macro CWHEAD
5840			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5840			; | | Compatible with PicoSPINet  
5840 3a 6a fa				ld a, (store_filecache) 
5843 26 00				ld h, 0 
5845 6f					ld l, a 
5846 cd cb 20				call forth_push_numhl 
5849					NEXTW 
5849 c3 78 24			jp macro_next 
584c				endm 
# End of macro NEXTW
584c			.SCONST2: 
584c				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
584c 6d				db WORD_SYS_CORE+89             
584d 64 58			dw .SCONST3            
584f 08				db 7 + 1 
5850 .. 00			db "FILEEXT",0              
5858				endm 
# End of macro CWHEAD
5858			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5858			; | | Compatible with PicoSPINet  
5858 3a 6d fa				ld a, (store_openext) 
585b 26 00				ld h, 0 
585d 6f					ld l, a 
585e cd cb 20				call forth_push_numhl 
5861					NEXTW 
5861 c3 78 24			jp macro_next 
5864				endm 
# End of macro NEXTW
5864			.SCONST3: 
5864				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5864 6d				db WORD_SYS_CORE+89             
5865 7c 58			dw .SCONST4            
5867 08				db 7 + 1 
5868 .. 00			db "FILEMAX",0              
5870				endm 
# End of macro CWHEAD
5870			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5870			; | | Compatible with PicoSPINet  
5870 3a 6c fa				ld a, (store_openmaxext) 
5873 26 00				ld h, 0 
5875 6f					ld l, a 
5876 cd cb 20				call forth_push_numhl 
5879					NEXTW 
5879 c3 78 24			jp macro_next 
587c				endm 
# End of macro NEXTW
587c			.SCONST4: 
587c				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
587c 6d				db WORD_SYS_CORE+89             
587d 92 58			dw .SCONST5            
587f 09				db 8 + 1 
5880 .. 00			db "FILEADDR",0              
5889				endm 
# End of macro CWHEAD
5889			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
5889			; | | Compatible with PicoSPINet  
5889 2a 6e fa				ld hl, (store_openaddr) 
588c cd cb 20				call forth_push_numhl 
588f					NEXTW 
588f c3 78 24			jp macro_next 
5892				endm 
# End of macro NEXTW
5892			.SCONST5: 
5892				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5892 6d				db WORD_SYS_CORE+89             
5893 b3 58			dw .SCONST6            
5895 09				db 8 + 1 
5896 .. 00			db "FILEPAGE",0              
589f				endm 
# End of macro CWHEAD
589f			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
589f			; | | Compatible with PicoSPINet  
589f 2a 6e fa				ld hl, (store_openaddr) 
58a2 e5					push hl 
58a3 c1					pop bc 
58a4 16 00				ld d, 0 
58a6 1e 40				ld e, STORE_BLOCK_PHY 
58a8 cd e3 0e				call Div16 
58ab c5					push bc 
58ac e1					pop hl 
58ad cd cb 20				call forth_push_numhl 
58b0					NEXTW 
58b0 c3 78 24			jp macro_next 
58b3				endm 
# End of macro NEXTW
58b3			.SCONST6: 
58b3				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
58b3 6d				db WORD_SYS_CORE+89             
58b4 cc 58			dw .ENDSTORAGE            
58b6 09				db 8 + 1 
58b7 .. 00			db "READCONT",0              
58c0				endm 
# End of macro CWHEAD
58c0			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
58c0			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
58c0			; | | a further read should, if applicable, be CONCAT to the previous read. 
58c0			; | | Compatible with PicoSPINet  
58c0 3a 70 fa				ld a, (store_readcont) 
58c3 26 00				ld h, 0 
58c5 6f					ld l, a 
58c6 cd cb 20				call forth_push_numhl 
58c9					NEXTW 
58c9 c3 78 24			jp macro_next 
58cc				endm 
# End of macro NEXTW
58cc			.ENDSTORAGE: 
58cc			; eof 
# End of file forth_words_storage.asm
58cc			endif 
58cc				include "forth_words_device.asm" 
58cc			; Device related words 
58cc			 
58cc			; | ## Device Words 
58cc			 
58cc			;if SOUND_ENABLE 
58cc			;.NOTE: 
58cc			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
58cc			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
58cc			;		if DEBUG_FORTH_WORDS_KEY 
58cc			;			DMARK "NTE" 
58cc			;			CALLMONITOR 
58cc			;		endif 
58cc			; 
58cc			;	 
58cc			; 
58cc			;		NEXTW 
58cc			;.AFTERSOUND: 
58cc			;endif 
58cc			 
58cc			 
58cc			USE_GPIO: equ 0 
58cc			 
58cc			if USE_GPIO 
58cc			.GP1: 
58cc				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
58cc			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
58cc					NEXTW 
58cc			.GP2: 
58cc				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
58cc			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
58cc			 
58cc					NEXTW 
58cc			 
58cc			.GP3: 
58cc				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
58cc			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
58cc			 
58cc					NEXTW 
58cc			 
58cc			.GP4: 
58cc				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
58cc			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
58cc			 
58cc					NEXTW 
58cc			.SIN: 
58cc			 
58cc			 
58cc			endif 
58cc			 
58cc			 
58cc				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
58cc 33				db WORD_SYS_CORE+31             
58cd 01 59			dw .SOUT            
58cf 03				db 2 + 1 
58d0 .. 00			db "IN",0              
58d3				endm 
# End of macro CWHEAD
58d3			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
58d3					if DEBUG_FORTH_WORDS_KEY 
58d3						DMARK "IN." 
58d3 f5				push af  
58d4 3a e8 58			ld a, (.dmark)  
58d7 32 6e fe			ld (debug_mark),a  
58da 3a e9 58			ld a, (.dmark+1)  
58dd 32 6f fe			ld (debug_mark+1),a  
58e0 3a ea 58			ld a, (.dmark+2)  
58e3 32 70 fe			ld (debug_mark+2),a  
58e6 18 03			jr .pastdmark  
58e8 ..			.dmark: db "IN."  
58eb f1			.pastdmark: pop af  
58ec			endm  
# End of macro DMARK
58ec						CALLMONITOR 
58ec cd fb 19			call break_point_state  
58ef				endm  
# End of macro CALLMONITOR
58ef					endif 
58ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
58ef cd c2 22			call macro_dsp_valuehl 
58f2				endm 
# End of macro FORTH_DSP_VALUEHL
58f2			 
58f2 e5					push hl 
58f3			 
58f3					; destroy value TOS 
58f3			 
58f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
58f3 cd 7a 23			call macro_forth_dsp_pop 
58f6				endm 
# End of macro FORTH_DSP_POP
58f6			 
58f6					; one value on hl get other one back 
58f6			 
58f6 c1					pop bc 
58f7			 
58f7					; do the sub 
58f7			;		ex de, hl 
58f7			 
58f7 ed 68				in l,(c) 
58f9			 
58f9					; save it 
58f9			 
58f9 26 00				ld h,0 
58fb			 
58fb					; TODO push value back onto stack for another op etc 
58fb			 
58fb cd cb 20				call forth_push_numhl 
58fe					NEXTW 
58fe c3 78 24			jp macro_next 
5901				endm 
# End of macro NEXTW
5901			.SOUT: 
5901				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5901 34				db WORD_SYS_CORE+32             
5902 54 59			dw .SPIO            
5904 04				db 3 + 1 
5905 .. 00			db "OUT",0              
5909				endm 
# End of macro CWHEAD
5909			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5909					if DEBUG_FORTH_WORDS_KEY 
5909						DMARK "OUT" 
5909 f5				push af  
590a 3a 1e 59			ld a, (.dmark)  
590d 32 6e fe			ld (debug_mark),a  
5910 3a 1f 59			ld a, (.dmark+1)  
5913 32 6f fe			ld (debug_mark+1),a  
5916 3a 20 59			ld a, (.dmark+2)  
5919 32 70 fe			ld (debug_mark+2),a  
591c 18 03			jr .pastdmark  
591e ..			.dmark: db "OUT"  
5921 f1			.pastdmark: pop af  
5922			endm  
# End of macro DMARK
5922						CALLMONITOR 
5922 cd fb 19			call break_point_state  
5925				endm  
# End of macro CALLMONITOR
5925					endif 
5925			 
5925					; get port 
5925			 
5925					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5925 cd c2 22			call macro_dsp_valuehl 
5928				endm 
# End of macro FORTH_DSP_VALUEHL
5928			 
5928 e5					push hl 
5929			 
5929					; destroy value TOS 
5929			 
5929					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5929 cd 7a 23			call macro_forth_dsp_pop 
592c				endm 
# End of macro FORTH_DSP_POP
592c			 
592c					; get byte to send 
592c			 
592c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
592c cd c2 22			call macro_dsp_valuehl 
592f				endm 
# End of macro FORTH_DSP_VALUEHL
592f			 
592f			;		push hl 
592f			 
592f					; destroy value TOS 
592f			 
592f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
592f cd 7a 23			call macro_forth_dsp_pop 
5932				endm 
# End of macro FORTH_DSP_POP
5932			 
5932					; one value on hl get other one back 
5932			 
5932			;		pop hl 
5932			 
5932 c1					pop bc 
5933			 
5933					if DEBUG_FORTH_WORDS 
5933						DMARK "OUT" 
5933 f5				push af  
5934 3a 48 59			ld a, (.dmark)  
5937 32 6e fe			ld (debug_mark),a  
593a 3a 49 59			ld a, (.dmark+1)  
593d 32 6f fe			ld (debug_mark+1),a  
5940 3a 4a 59			ld a, (.dmark+2)  
5943 32 70 fe			ld (debug_mark+2),a  
5946 18 03			jr .pastdmark  
5948 ..			.dmark: db "OUT"  
594b f1			.pastdmark: pop af  
594c			endm  
# End of macro DMARK
594c						CALLMONITOR 
594c cd fb 19			call break_point_state  
594f				endm  
# End of macro CALLMONITOR
594f					endif 
594f			 
594f ed 69				out (c), l 
5951			 
5951					NEXTW 
5951 c3 78 24			jp macro_next 
5954				endm 
# End of macro NEXTW
5954			 
5954			 
5954			.SPIO: 
5954			 
5954			if STORAGE_SE 
5954				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5954 51				db WORD_SYS_CORE+61             
5955 65 59			dw .SPICEH            
5957 07				db 6 + 1 
5958 .. 00			db "SPICEL",0              
595f				endm 
# End of macro CWHEAD
595f			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
595f			 
595f cd ca 01				call spi_ce_low 
5962			    NEXTW 
5962 c3 78 24			jp macro_next 
5965				endm 
# End of macro NEXTW
5965			 
5965			.SPICEH: 
5965				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5965 51				db WORD_SYS_CORE+61             
5966 76 59			dw .SPIOb            
5968 07				db 6 + 1 
5969 .. 00			db "SPICEH",0              
5970				endm 
# End of macro CWHEAD
5970			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5970			 
5970 cd b9 01				call spi_ce_high 
5973			    NEXTW 
5973 c3 78 24			jp macro_next 
5976				endm 
# End of macro NEXTW
5976			 
5976			 
5976			.SPIOb: 
5976			 
5976				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5976 51				db WORD_SYS_CORE+61             
5977 a8 59			dw .SPII            
5979 05				db 4 + 1 
597a .. 00			db "SPIO",0              
597f				endm 
# End of macro CWHEAD
597f			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
597f			 
597f					if DEBUG_FORTH_WORDS_KEY 
597f						DMARK "SPo" 
597f f5				push af  
5980 3a 94 59			ld a, (.dmark)  
5983 32 6e fe			ld (debug_mark),a  
5986 3a 95 59			ld a, (.dmark+1)  
5989 32 6f fe			ld (debug_mark+1),a  
598c 3a 96 59			ld a, (.dmark+2)  
598f 32 70 fe			ld (debug_mark+2),a  
5992 18 03			jr .pastdmark  
5994 ..			.dmark: db "SPo"  
5997 f1			.pastdmark: pop af  
5998			endm  
# End of macro DMARK
5998						CALLMONITOR 
5998 cd fb 19			call break_point_state  
599b				endm  
# End of macro CALLMONITOR
599b					endif 
599b					; get port 
599b			 
599b			 
599b					; get byte to send 
599b			 
599b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
599b cd c2 22			call macro_dsp_valuehl 
599e				endm 
# End of macro FORTH_DSP_VALUEHL
599e			 
599e			;		push hl    ; u1  
599e			 
599e					; destroy value TOS 
599e			 
599e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
599e cd 7a 23			call macro_forth_dsp_pop 
59a1				endm 
# End of macro FORTH_DSP_POP
59a1			 
59a1					; one value on hl get other one back 
59a1			 
59a1			;		pop hl   ; u2 - addr 
59a1			 
59a1					; TODO Send SPI byte 
59a1			 
59a1			;		push hl 
59a1			;		call spi_ce_low 
59a1			;		pop hl 
59a1 7d					ld a, l 
59a2 cd b8 00				call spi_send_byte 
59a5			;		call spi_ce_high 
59a5			 
59a5					NEXTW 
59a5 c3 78 24			jp macro_next 
59a8				endm 
# End of macro NEXTW
59a8			 
59a8			.SPII: 
59a8				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
59a8 52				db WORD_SYS_CORE+62             
59a9 11 5a			dw .SESEL            
59ab 06				db 5 + 1 
59ac .. 00			db "SPII",0              
59b1				endm 
# End of macro CWHEAD
59b1			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
59b1					if DEBUG_FORTH_WORDS_KEY 
59b1						DMARK "SPi" 
59b1 f5				push af  
59b2 3a c6 59			ld a, (.dmark)  
59b5 32 6e fe			ld (debug_mark),a  
59b8 3a c7 59			ld a, (.dmark+1)  
59bb 32 6f fe			ld (debug_mark+1),a  
59be 3a c8 59			ld a, (.dmark+2)  
59c1 32 70 fe			ld (debug_mark+2),a  
59c4 18 03			jr .pastdmark  
59c6 ..			.dmark: db "SPi"  
59c9 f1			.pastdmark: pop af  
59ca			endm  
# End of macro DMARK
59ca						CALLMONITOR 
59ca cd fb 19			call break_point_state  
59cd				endm  
# End of macro CALLMONITOR
59cd					endif 
59cd			 
59cd					; TODO Get SPI byte 
59cd			 
59cd cd df 00				call spi_read_byte 
59d0			 
59d0					if DEBUG_FORTH_WORDS 
59d0						DMARK "Si2" 
59d0 f5				push af  
59d1 3a e5 59			ld a, (.dmark)  
59d4 32 6e fe			ld (debug_mark),a  
59d7 3a e6 59			ld a, (.dmark+1)  
59da 32 6f fe			ld (debug_mark+1),a  
59dd 3a e7 59			ld a, (.dmark+2)  
59e0 32 70 fe			ld (debug_mark+2),a  
59e3 18 03			jr .pastdmark  
59e5 ..			.dmark: db "Si2"  
59e8 f1			.pastdmark: pop af  
59e9			endm  
# End of macro DMARK
59e9						CALLMONITOR 
59e9 cd fb 19			call break_point_state  
59ec				endm  
# End of macro CALLMONITOR
59ec					endif 
59ec 26 00				ld h, 0 
59ee 6f					ld l, a 
59ef					if DEBUG_FORTH_WORDS 
59ef						DMARK "Si3" 
59ef f5				push af  
59f0 3a 04 5a			ld a, (.dmark)  
59f3 32 6e fe			ld (debug_mark),a  
59f6 3a 05 5a			ld a, (.dmark+1)  
59f9 32 6f fe			ld (debug_mark+1),a  
59fc 3a 06 5a			ld a, (.dmark+2)  
59ff 32 70 fe			ld (debug_mark+2),a  
5a02 18 03			jr .pastdmark  
5a04 ..			.dmark: db "Si3"  
5a07 f1			.pastdmark: pop af  
5a08			endm  
# End of macro DMARK
5a08						CALLMONITOR 
5a08 cd fb 19			call break_point_state  
5a0b				endm  
# End of macro CALLMONITOR
5a0b					endif 
5a0b cd cb 20				call forth_push_numhl 
5a0e			 
5a0e					NEXTW 
5a0e c3 78 24			jp macro_next 
5a11				endm 
# End of macro NEXTW
5a11			 
5a11			 
5a11			 
5a11			.SESEL: 
5a11				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a11 66				db WORD_SYS_CORE+82             
5a12 ba 5a			dw .CARTDEV            
5a14 05				db 4 + 1 
5a15 .. 00			db "BANK",0              
5a1a				endm 
# End of macro CWHEAD
5a1a			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a1a					if DEBUG_FORTH_WORDS_KEY 
5a1a						DMARK "BNK" 
5a1a f5				push af  
5a1b 3a 2f 5a			ld a, (.dmark)  
5a1e 32 6e fe			ld (debug_mark),a  
5a21 3a 30 5a			ld a, (.dmark+1)  
5a24 32 6f fe			ld (debug_mark+1),a  
5a27 3a 31 5a			ld a, (.dmark+2)  
5a2a 32 70 fe			ld (debug_mark+2),a  
5a2d 18 03			jr .pastdmark  
5a2f ..			.dmark: db "BNK"  
5a32 f1			.pastdmark: pop af  
5a33			endm  
# End of macro DMARK
5a33						CALLMONITOR 
5a33 cd fb 19			call break_point_state  
5a36				endm  
# End of macro CALLMONITOR
5a36					endif 
5a36			 
5a36 3e ff				ld a, 255 
5a38 32 66 fa				ld (spi_cartdev), a 
5a3b			 
5a3b					; get bank 
5a3b			 
5a3b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a3b cd c2 22			call macro_dsp_valuehl 
5a3e				endm 
# End of macro FORTH_DSP_VALUEHL
5a3e			 
5a3e			;		push hl 
5a3e			 
5a3e					; destroy value TOS 
5a3e			 
5a3e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a3e cd 7a 23			call macro_forth_dsp_pop 
5a41				endm 
# End of macro FORTH_DSP_POP
5a41			 
5a41					; one value on hl get other one back 
5a41			 
5a41			;		pop hl 
5a41			 
5a41			 
5a41 0e ff				ld c, SPI_CE_HIGH 
5a43 06 30				ld b, '0'    ; human readable bank number 
5a45			 
5a45 7d					ld a, l 
5a46			 
5a46					if DEBUG_FORTH_WORDS 
5a46						DMARK "BNK" 
5a46 f5				push af  
5a47 3a 5b 5a			ld a, (.dmark)  
5a4a 32 6e fe			ld (debug_mark),a  
5a4d 3a 5c 5a			ld a, (.dmark+1)  
5a50 32 6f fe			ld (debug_mark+1),a  
5a53 3a 5d 5a			ld a, (.dmark+2)  
5a56 32 70 fe			ld (debug_mark+2),a  
5a59 18 03			jr .pastdmark  
5a5b ..			.dmark: db "BNK"  
5a5e f1			.pastdmark: pop af  
5a5f			endm  
# End of macro DMARK
5a5f						CALLMONITOR 
5a5f cd fb 19			call break_point_state  
5a62				endm  
# End of macro CALLMONITOR
5a62					endif 
5a62			 
5a62					; active low 
5a62			 
5a62 fe 00				cp 0 
5a64 28 28				jr z, .bset 
5a66 fe 01				cp 1 
5a68 20 04				jr nz, .b2 
5a6a cb 81				res 0, c 
5a6c 06 31				ld b, '1'    ; human readable bank number 
5a6e fe 02		.b2:		cp 2 
5a70 20 04				jr nz, .b3 
5a72 cb 89				res 1, c 
5a74 06 32				ld b, '2'    ; human readable bank number 
5a76 fe 03		.b3:		cp 3 
5a78 20 04				jr nz, .b4 
5a7a cb 91				res 2, c 
5a7c 06 33				ld b, '3'    ; human readable bank number 
5a7e fe 04		.b4:		cp 4 
5a80 20 04				jr nz, .b5 
5a82 cb 99				res 3, c 
5a84 06 34				ld b, '4'    ; human readable bank number 
5a86 fe 05		.b5:		cp 5 
5a88 20 04				jr nz, .bset 
5a8a cb a1				res 4, c 
5a8c 06 35				ld b, '5'    ; human readable bank number 
5a8e			 
5a8e			.bset: 
5a8e 79					ld a, c 
5a8f 32 63 fa				ld (spi_device),a 
5a92 78					ld a, b 
5a93 32 62 fa				ld (spi_device_id),a 
5a96					if DEBUG_FORTH_WORDS 
5a96						DMARK "BN2" 
5a96 f5				push af  
5a97 3a ab 5a			ld a, (.dmark)  
5a9a 32 6e fe			ld (debug_mark),a  
5a9d 3a ac 5a			ld a, (.dmark+1)  
5aa0 32 6f fe			ld (debug_mark+1),a  
5aa3 3a ad 5a			ld a, (.dmark+2)  
5aa6 32 70 fe			ld (debug_mark+2),a  
5aa9 18 03			jr .pastdmark  
5aab ..			.dmark: db "BN2"  
5aae f1			.pastdmark: pop af  
5aaf			endm  
# End of macro DMARK
5aaf						CALLMONITOR 
5aaf cd fb 19			call break_point_state  
5ab2				endm  
# End of macro CALLMONITOR
5ab2					endif 
5ab2			 
5ab2					; set default SPI clk pulse time as disabled for BANK use 
5ab2			 
5ab2 3e 00				ld a, 0 
5ab4 32 67 fa				ld (spi_clktime), a 
5ab7			 
5ab7					NEXTW 
5ab7 c3 78 24			jp macro_next 
5aba				endm 
# End of macro NEXTW
5aba			 
5aba			.CARTDEV: 
5aba				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5aba 66				db WORD_SYS_CORE+82             
5abb 68 5b			dw .ENDDEVICE            
5abd 08				db 7 + 1 
5abe .. 00			db "CARTDEV",0              
5ac6				endm 
# End of macro CWHEAD
5ac6			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5ac6					if DEBUG_FORTH_WORDS_KEY 
5ac6						DMARK "CDV" 
5ac6 f5				push af  
5ac7 3a db 5a			ld a, (.dmark)  
5aca 32 6e fe			ld (debug_mark),a  
5acd 3a dc 5a			ld a, (.dmark+1)  
5ad0 32 6f fe			ld (debug_mark+1),a  
5ad3 3a dd 5a			ld a, (.dmark+2)  
5ad6 32 70 fe			ld (debug_mark+2),a  
5ad9 18 03			jr .pastdmark  
5adb ..			.dmark: db "CDV"  
5ade f1			.pastdmark: pop af  
5adf			endm  
# End of macro DMARK
5adf						CALLMONITOR 
5adf cd fb 19			call break_point_state  
5ae2				endm  
# End of macro CALLMONITOR
5ae2					endif 
5ae2			 
5ae2					; disable se storage bank selection 
5ae2			 
5ae2 3e ff				ld a, SPI_CE_HIGH		; ce high 
5ae4 32 63 fa				ld (spi_device), a 
5ae7			 
5ae7					; get bank 
5ae7			 
5ae7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ae7 cd c2 22			call macro_dsp_valuehl 
5aea				endm 
# End of macro FORTH_DSP_VALUEHL
5aea			 
5aea			;		push hl 
5aea			 
5aea					; destroy value TOS 
5aea			 
5aea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5aea cd 7a 23			call macro_forth_dsp_pop 
5aed				endm 
# End of macro FORTH_DSP_POP
5aed			 
5aed					; one value on hl get other one back 
5aed			 
5aed			;		pop hl 
5aed			 
5aed					; active low 
5aed			 
5aed 0e ff				ld c, 255 
5aef			 
5aef 7d					ld a, l 
5af0					if DEBUG_FORTH_WORDS 
5af0						DMARK "CDV" 
5af0 f5				push af  
5af1 3a 05 5b			ld a, (.dmark)  
5af4 32 6e fe			ld (debug_mark),a  
5af7 3a 06 5b			ld a, (.dmark+1)  
5afa 32 6f fe			ld (debug_mark+1),a  
5afd 3a 07 5b			ld a, (.dmark+2)  
5b00 32 70 fe			ld (debug_mark+2),a  
5b03 18 03			jr .pastdmark  
5b05 ..			.dmark: db "CDV"  
5b08 f1			.pastdmark: pop af  
5b09			endm  
# End of macro DMARK
5b09						CALLMONITOR 
5b09 cd fb 19			call break_point_state  
5b0c				endm  
# End of macro CALLMONITOR
5b0c					endif 
5b0c fe 00				cp 0 
5b0e 28 30				jr z, .cset 
5b10 fe 01				cp 1 
5b12 20 02				jr nz, .c2 
5b14 cb 81				res 0, c 
5b16 fe 02		.c2:		cp 2 
5b18 20 02				jr nz, .c3 
5b1a cb 89				res 1, c 
5b1c fe 03		.c3:		cp 3 
5b1e 20 02				jr nz, .c4 
5b20 cb 91				res 2, c 
5b22 fe 04		.c4:		cp 4 
5b24 20 02				jr nz, .c5 
5b26 cb 99				res 3, c 
5b28 fe 05		.c5:		cp 5 
5b2a 20 02				jr nz, .c6 
5b2c cb a1				res 4, c 
5b2e fe 06		.c6:		cp 6 
5b30 20 02				jr nz, .c7 
5b32 cb a9				res 5, c 
5b34 fe 07		.c7:		cp 7 
5b36 20 02				jr nz, .c8 
5b38 cb b1				res 6, c 
5b3a fe 08		.c8:		cp 8 
5b3c 20 02				jr nz, .cset 
5b3e cb b9				res 7, c 
5b40 79			.cset:		ld a, c 
5b41 32 66 fa				ld (spi_cartdev),a 
5b44			 
5b44					if DEBUG_FORTH_WORDS 
5b44						DMARK "CD2" 
5b44 f5				push af  
5b45 3a 59 5b			ld a, (.dmark)  
5b48 32 6e fe			ld (debug_mark),a  
5b4b 3a 5a 5b			ld a, (.dmark+1)  
5b4e 32 6f fe			ld (debug_mark+1),a  
5b51 3a 5b 5b			ld a, (.dmark+2)  
5b54 32 70 fe			ld (debug_mark+2),a  
5b57 18 03			jr .pastdmark  
5b59 ..			.dmark: db "CD2"  
5b5c f1			.pastdmark: pop af  
5b5d			endm  
# End of macro DMARK
5b5d						CALLMONITOR 
5b5d cd fb 19			call break_point_state  
5b60				endm  
# End of macro CALLMONITOR
5b60					endif 
5b60			 
5b60					; set default SPI clk pulse time as 10ms for CARTDEV use 
5b60			 
5b60 3e 0a				ld a, $0a 
5b62 32 67 fa				ld (spi_clktime), a 
5b65					NEXTW 
5b65 c3 78 24			jp macro_next 
5b68				endm 
# End of macro NEXTW
5b68			endif 
5b68			 
5b68			.ENDDEVICE: 
5b68			; eof 
5b68			 
# End of file forth_words_device.asm
5b68			 
5b68			; var handler 
5b68			 
5b68			 
5b68			.VARS: 
5b68				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5b68 77				db WORD_SYS_CORE+99             
5b69 19 5c			dw .V0            
5b6b 04				db 3 + 1 
5b6c .. 00			db "VAR",0              
5b70				endm 
# End of macro CWHEAD
5b70			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5b70			;| 
5b70			;| The variable name should consist of a single letter. e.g. "a" 
5b70			;! If a full string is passed then only the first char is looked at 
5b70			;| Any other char could exceed bounds checks!  
5b70			 
5b70					if DEBUG_FORTH_WORDS_KEY 
5b70						DMARK "VAR" 
5b70 f5				push af  
5b71 3a 85 5b			ld a, (.dmark)  
5b74 32 6e fe			ld (debug_mark),a  
5b77 3a 86 5b			ld a, (.dmark+1)  
5b7a 32 6f fe			ld (debug_mark+1),a  
5b7d 3a 87 5b			ld a, (.dmark+2)  
5b80 32 70 fe			ld (debug_mark+2),a  
5b83 18 03			jr .pastdmark  
5b85 ..			.dmark: db "VAR"  
5b88 f1			.pastdmark: pop af  
5b89			endm  
# End of macro DMARK
5b89						CALLMONITOR 
5b89 cd fb 19			call break_point_state  
5b8c				endm  
# End of macro CALLMONITOR
5b8c					endif 
5b8c			 
5b8c					FORTH_DSP_VALUEHL 
5b8c cd c2 22			call macro_dsp_valuehl 
5b8f				endm 
# End of macro FORTH_DSP_VALUEHL
5b8f			 
5b8f 7e					ld a, (hl)    ; get first char on of the string 
5b90			 
5b90			 
5b90					if DEBUG_FORTH_WORDS 
5b90						DMARK "VR1" 
5b90 f5				push af  
5b91 3a a5 5b			ld a, (.dmark)  
5b94 32 6e fe			ld (debug_mark),a  
5b97 3a a6 5b			ld a, (.dmark+1)  
5b9a 32 6f fe			ld (debug_mark+1),a  
5b9d 3a a7 5b			ld a, (.dmark+2)  
5ba0 32 70 fe			ld (debug_mark+2),a  
5ba3 18 03			jr .pastdmark  
5ba5 ..			.dmark: db "VR1"  
5ba8 f1			.pastdmark: pop af  
5ba9			endm  
# End of macro DMARK
5ba9						CALLMONITOR 
5ba9 cd fb 19			call break_point_state  
5bac				endm  
# End of macro CALLMONITOR
5bac					endif 
5bac					 
5bac f5					push af	 
5bad					FORTH_DSP_POP 
5bad cd 7a 23			call macro_forth_dsp_pop 
5bb0				endm 
# End of macro FORTH_DSP_POP
5bb0 f1					pop af 
5bb1			 
5bb1					; convert to upper 
5bb1			 
5bb1 cd f3 12				call to_upper 
5bb4					if DEBUG_FORTH_WORDS 
5bb4						DMARK "Vaa" 
5bb4 f5				push af  
5bb5 3a c9 5b			ld a, (.dmark)  
5bb8 32 6e fe			ld (debug_mark),a  
5bbb 3a ca 5b			ld a, (.dmark+1)  
5bbe 32 6f fe			ld (debug_mark+1),a  
5bc1 3a cb 5b			ld a, (.dmark+2)  
5bc4 32 70 fe			ld (debug_mark+2),a  
5bc7 18 03			jr .pastdmark  
5bc9 ..			.dmark: db "Vaa"  
5bcc f1			.pastdmark: pop af  
5bcd			endm  
# End of macro DMARK
5bcd						CALLMONITOR 
5bcd cd fb 19			call break_point_state  
5bd0				endm  
# End of macro CALLMONITOR
5bd0					endif 
5bd0 06 41				ld b, 'A' 
5bd2 90					sub b			; set offset 
5bd3					if DEBUG_FORTH_WORDS 
5bd3						DMARK "Vbb" 
5bd3 f5				push af  
5bd4 3a e8 5b			ld a, (.dmark)  
5bd7 32 6e fe			ld (debug_mark),a  
5bda 3a e9 5b			ld a, (.dmark+1)  
5bdd 32 6f fe			ld (debug_mark+1),a  
5be0 3a ea 5b			ld a, (.dmark+2)  
5be3 32 70 fe			ld (debug_mark+2),a  
5be6 18 03			jr .pastdmark  
5be8 ..			.dmark: db "Vbb"  
5beb f1			.pastdmark: pop af  
5bec			endm  
# End of macro DMARK
5bec						CALLMONITOR 
5bec cd fb 19			call break_point_state  
5bef				endm  
# End of macro CALLMONITOR
5bef					endif 
5bef cb 27				sla a  
5bf1				 
5bf1					 
5bf1					if DEBUG_FORTH_WORDS 
5bf1						DMARK "VR2" 
5bf1 f5				push af  
5bf2 3a 06 5c			ld a, (.dmark)  
5bf5 32 6e fe			ld (debug_mark),a  
5bf8 3a 07 5c			ld a, (.dmark+1)  
5bfb 32 6f fe			ld (debug_mark+1),a  
5bfe 3a 08 5c			ld a, (.dmark+2)  
5c01 32 70 fe			ld (debug_mark+2),a  
5c04 18 03			jr .pastdmark  
5c06 ..			.dmark: db "VR2"  
5c09 f1			.pastdmark: pop af  
5c0a			endm  
# End of macro DMARK
5c0a						CALLMONITOR 
5c0a cd fb 19			call break_point_state  
5c0d				endm  
# End of macro CALLMONITOR
5c0d					endif 
5c0d			 
5c0d 21 f7 f9				ld hl, cli_var_array2 
5c10 cd 86 0f				call addatohl 
5c13 cd cb 20				call forth_push_numhl 
5c16			 
5c16			 
5c16				       NEXTW 
5c16 c3 78 24			jp macro_next 
5c19				endm 
# End of macro NEXTW
5c19			.V0: 
5c19				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c19 78				db WORD_SYS_CORE+100             
5c1a 31 5c			dw .V0Q            
5c1c 04				db 3 + 1 
5c1d .. 00			db "V0!",0              
5c21				endm 
# End of macro CWHEAD
5c21			;| V0! ( u1 -- )  Store value to v0  | DONE 
5c21			 
5c21					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c21 cd c2 22			call macro_dsp_valuehl 
5c24				endm 
# End of macro FORTH_DSP_VALUEHL
5c24			 
5c24 11 2b fa				ld de, cli_var_array 
5c27			 
5c27 eb					ex de, hl 
5c28 73					ld (hl), e 
5c29 23					inc hl 
5c2a 72					ld (hl), d 
5c2b			 
5c2b					; destroy value TOS 
5c2b			 
5c2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c2b cd 7a 23			call macro_forth_dsp_pop 
5c2e				endm 
# End of macro FORTH_DSP_POP
5c2e			 
5c2e				       NEXTW 
5c2e c3 78 24			jp macro_next 
5c31				endm 
# End of macro NEXTW
5c31			.V0Q: 
5c31				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5c31 79				db WORD_SYS_CORE+101             
5c32 42 5c			dw .V1S            
5c34 04				db 3 + 1 
5c35 .. 00			db "V0@",0              
5c39				endm 
# End of macro CWHEAD
5c39			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5c39 2a 2b fa				ld hl, (cli_var_array) 
5c3c cd cb 20				call forth_push_numhl 
5c3f			 
5c3f				       NEXTW 
5c3f c3 78 24			jp macro_next 
5c42				endm 
# End of macro NEXTW
5c42			.V1S: 
5c42				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5c42 7a				db WORD_SYS_CORE+102             
5c43 5a 5c			dw .V1Q            
5c45 04				db 3 + 1 
5c46 .. 00			db "V1!",0              
5c4a				endm 
# End of macro CWHEAD
5c4a			;| V1! ( u1 -- )  Store value to v1 | DONE 
5c4a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c4a cd c2 22			call macro_dsp_valuehl 
5c4d				endm 
# End of macro FORTH_DSP_VALUEHL
5c4d			 
5c4d 11 2d fa				ld de, cli_var_array+2 
5c50				 
5c50 eb					ex de, hl 
5c51 73					ld (hl), e 
5c52 23					inc hl 
5c53 72					ld (hl), d 
5c54			 
5c54					; destroy value TOS 
5c54			 
5c54					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c54 cd 7a 23			call macro_forth_dsp_pop 
5c57				endm 
# End of macro FORTH_DSP_POP
5c57				       NEXTW 
5c57 c3 78 24			jp macro_next 
5c5a				endm 
# End of macro NEXTW
5c5a			.V1Q: 
5c5a				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5c5a 7b				db WORD_SYS_CORE+103             
5c5b 6b 5c			dw .V2S            
5c5d 04				db 3 + 1 
5c5e .. 00			db "V1@",0              
5c62				endm 
# End of macro CWHEAD
5c62			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5c62 2a 2d fa				ld hl, (cli_var_array+2) 
5c65 cd cb 20				call forth_push_numhl 
5c68				       NEXTW 
5c68 c3 78 24			jp macro_next 
5c6b				endm 
# End of macro NEXTW
5c6b			.V2S: 
5c6b				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5c6b 7c				db WORD_SYS_CORE+104             
5c6c 83 5c			dw .V2Q            
5c6e 04				db 3 + 1 
5c6f .. 00			db "V2!",0              
5c73				endm 
# End of macro CWHEAD
5c73			;| V2! ( u1 -- )  Store value to v2 | DONE 
5c73					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c73 cd c2 22			call macro_dsp_valuehl 
5c76				endm 
# End of macro FORTH_DSP_VALUEHL
5c76			 
5c76 11 2f fa				ld de, cli_var_array+4 
5c79				 
5c79 eb					ex de, hl 
5c7a 73					ld (hl), e 
5c7b 23					inc hl 
5c7c 72					ld (hl), d 
5c7d			 
5c7d					; destroy value TOS 
5c7d			 
5c7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c7d cd 7a 23			call macro_forth_dsp_pop 
5c80				endm 
# End of macro FORTH_DSP_POP
5c80				       NEXTW 
5c80 c3 78 24			jp macro_next 
5c83				endm 
# End of macro NEXTW
5c83			.V2Q: 
5c83				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5c83 7d				db WORD_SYS_CORE+105             
5c84 94 5c			dw .V3S            
5c86 04				db 3 + 1 
5c87 .. 00			db "V2@",0              
5c8b				endm 
# End of macro CWHEAD
5c8b			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5c8b 2a 2f fa				ld hl, (cli_var_array+4) 
5c8e cd cb 20				call forth_push_numhl 
5c91				       NEXTW 
5c91 c3 78 24			jp macro_next 
5c94				endm 
# End of macro NEXTW
5c94			.V3S: 
5c94				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5c94 7c				db WORD_SYS_CORE+104             
5c95 ac 5c			dw .V3Q            
5c97 04				db 3 + 1 
5c98 .. 00			db "V3!",0              
5c9c				endm 
# End of macro CWHEAD
5c9c			;| V3! ( u1 -- )  Store value to v3 | DONE 
5c9c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c9c cd c2 22			call macro_dsp_valuehl 
5c9f				endm 
# End of macro FORTH_DSP_VALUEHL
5c9f			 
5c9f 11 31 fa				ld de, cli_var_array+6 
5ca2				 
5ca2 eb					ex de, hl 
5ca3 73					ld (hl), e 
5ca4 23					inc hl 
5ca5 72					ld (hl), d 
5ca6			 
5ca6					; destroy value TOS 
5ca6			 
5ca6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ca6 cd 7a 23			call macro_forth_dsp_pop 
5ca9				endm 
# End of macro FORTH_DSP_POP
5ca9				       NEXTW 
5ca9 c3 78 24			jp macro_next 
5cac				endm 
# End of macro NEXTW
5cac			.V3Q: 
5cac				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5cac 7d				db WORD_SYS_CORE+105             
5cad bd 5c			dw .END            
5caf 04				db 3 + 1 
5cb0 .. 00			db "V3@",0              
5cb4				endm 
# End of macro CWHEAD
5cb4			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5cb4 2a 31 fa				ld hl, (cli_var_array+6) 
5cb7 cd cb 20				call forth_push_numhl 
5cba				       NEXTW 
5cba c3 78 24			jp macro_next 
5cbd				endm 
# End of macro NEXTW
5cbd			 
5cbd			 
5cbd			 
5cbd			 
5cbd			 
5cbd			; end of dict marker 
5cbd			 
5cbd 00			.END:    db WORD_SYS_END 
5cbe 00 00			dw 0 
5cc0 00				db 0 
5cc1			 
5cc1			; use to jp here for user dict words to save on macro expansion  
5cc1			 
5cc1			user_dict_next: 
5cc1				NEXTW 
5cc1 c3 78 24			jp macro_next 
5cc4				endm 
# End of macro NEXTW
5cc4			 
5cc4			 
5cc4			user_exec: 
5cc4				;    ld hl, <word code> 
5cc4				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5cc4				;    call forthexec 
5cc4				;    jp user_dict_next   (NEXT) 
5cc4			        ;    <word code bytes> 
5cc4 eb				ex de, hl 
5cc5 2a c5 f4			ld hl,(os_tok_ptr) 
5cc8				 
5cc8				FORTH_RSP_NEXT 
5cc8 cd 72 20			call macro_forth_rsp_next 
5ccb				endm 
# End of macro FORTH_RSP_NEXT
5ccb			 
5ccb			if DEBUG_FORTH_UWORD 
5ccb						DMARK "UEX" 
5ccb f5				push af  
5ccc 3a e0 5c			ld a, (.dmark)  
5ccf 32 6e fe			ld (debug_mark),a  
5cd2 3a e1 5c			ld a, (.dmark+1)  
5cd5 32 6f fe			ld (debug_mark+1),a  
5cd8 3a e2 5c			ld a, (.dmark+2)  
5cdb 32 70 fe			ld (debug_mark+2),a  
5cde 18 03			jr .pastdmark  
5ce0 ..			.dmark: db "UEX"  
5ce3 f1			.pastdmark: pop af  
5ce4			endm  
# End of macro DMARK
5ce4				CALLMONITOR 
5ce4 cd fb 19			call break_point_state  
5ce7				endm  
# End of macro CALLMONITOR
5ce7			endif 
5ce7			 
5ce7			 
5ce7			 
5ce7 eb				ex de, hl 
5ce8 22 c5 f4			ld (os_tok_ptr), hl 
5ceb				 
5ceb				; Don't use next - Skips the first word in uword. 
5ceb			 
5ceb c3 09 25			jp exec1 
5cee			;	NEXT 
5cee			 
5cee			 
5cee			; eof 
# End of file forth_wordsv4.asm
5cee			endif 
5cee			;;;;;;;;;;;;;; Debug code 
5cee			 
5cee			 
5cee			;if DEBUG_FORTH_PARSE 
5cee .. 00		.nowordfound: db "No match",0 
5cf7 .. 00		.compword:	db "Comparing word ",0 
5d07 .. 00		.nextwordat:	db "Next word at",0 
5d14 .. 00		.charmatch:	db "Char match",0 
5d1f			;endif 
5d1f			if DEBUG_FORTH_JP 
5d1f			.foundword:	db "Word match. Exec..",0 
5d1f			endif 
5d1f			;if DEBUG_FORTH_PUSH 
5d1f .. 00		.enddict:	db "Dict end. Push.",0 
5d2f .. 00		.push_str:	db "Pushing string",0 
5d3e .. 00		.push_num:	db "Pushing number",0 
5d4d .. 00		.data_sp:	db "SP:",0 
5d51 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5d63 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5d75 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5d87			;endif 
5d87			;if DEBUG_FORTH_MALLOC 
5d87 .. 00		.push_malloc:	db "Malloc address",0 
5d96			;endif 
5d96			 
5d96			 
5d96			 
5d96			; display malloc address and current data stack pointer  
5d96			 
5d96			malloc_error: 
5d96 d5				push de 
5d97 f5				push af 
5d98 e5				push hl 
5d99 cd 52 0d			call clear_display 
5d9c 11 be 5d			ld de, .mallocerr 
5d9f 3e 00			ld a,0 
5da1			;	ld de,os_word_scratch 
5da1 cd 65 0d			call str_at_display 
5da4 3e 11			ld a, display_row_1+17 
5da6 11 6e fe			ld de, debug_mark 
5da9 cd 65 0d			call str_at_display 
5dac cd 75 0d			call update_display 
5daf				;call break_point_state 
5daf cd 99 78			call cin_wait 
5db2			 
5db2 3e 20			ld a, ' ' 
5db4 32 b5 f1			ld (os_view_disable), a 
5db7 e1				pop hl 
5db8 f1				pop af 
5db9 d1				pop de	 
5dba				CALLMONITOR 
5dba cd fb 19			call break_point_state  
5dbd				endm  
# End of macro CALLMONITOR
5dbd c9				ret 
5dbe			 
5dbe .. 00		.mallocerr: 	db "Malloc Error",0 
5dcb			;if DEBUG_FORTH_PUSH 
5dcb			display_data_sp: 
5dcb f5				push af 
5dcc			 
5dcc				; see if disabled 
5dcc			 
5dcc 3a b5 f1			ld a, (os_view_disable) 
5dcf fe 2a			cp '*' 
5dd1 28 67			jr z, .skipdsp 
5dd3			 
5dd3 e5				push hl 
5dd4 e5				push hl 
5dd5 e5			push hl 
5dd6 cd 52 0d			call clear_display 
5dd9 e1			pop hl 
5dda 7c				ld a,h 
5ddb 21 c9 f4			ld hl, os_word_scratch 
5dde cd 87 12			call hexout 
5de1 e1				pop hl 
5de2 7d				ld a,l 
5de3 21 cb f4			ld hl, os_word_scratch+2 
5de6 cd 87 12			call hexout 
5de9 21 cd f4			ld hl, os_word_scratch+4 
5dec 3e 00			ld a,0 
5dee 77				ld (hl),a 
5def 11 c9 f4			ld de,os_word_scratch 
5df2 3e 28				ld a, display_row_2 
5df4 cd 65 0d				call str_at_display 
5df7 11 51 5d			ld de, .wordinhl 
5dfa 3e 00			ld a, display_row_1 
5dfc			 
5dfc cd 65 0d				call str_at_display 
5dff 11 6e fe			ld de, debug_mark 
5e02 3e 11			ld a, display_row_1+17 
5e04			 
5e04 cd 65 0d				call str_at_display 
5e07			 
5e07				; display current data stack pointer 
5e07 11 4d 5d			ld de,.data_sp 
5e0a 3e 30				ld a, display_row_2 + 8 
5e0c cd 65 0d				call str_at_display 
5e0f			 
5e0f 2a f1 f9			ld hl,(cli_data_sp) 
5e12 e5				push hl 
5e13 7c				ld a,h 
5e14 21 c9 f4			ld hl, os_word_scratch 
5e17 cd 87 12			call hexout 
5e1a e1				pop hl 
5e1b 7d				ld a,l 
5e1c 21 cb f4			ld hl, os_word_scratch+2 
5e1f cd 87 12			call hexout 
5e22 21 cd f4			ld hl, os_word_scratch+4 
5e25 3e 00			ld a,0 
5e27 77				ld (hl),a 
5e28 11 c9 f4			ld de,os_word_scratch 
5e2b 3e 33				ld a, display_row_2 + 11 
5e2d cd 65 0d				call str_at_display 
5e30			 
5e30			 
5e30 cd 75 0d			call update_display 
5e33 cd 95 0c			call delay1s 
5e36 cd 95 0c			call delay1s 
5e39 e1				pop hl 
5e3a			.skipdsp: 
5e3a f1				pop af 
5e3b c9				ret 
5e3c			 
5e3c			display_data_malloc: 
5e3c			 
5e3c f5				push af 
5e3d e5				push hl 
5e3e e5				push hl 
5e3f e5			push hl 
5e40 cd 52 0d			call clear_display 
5e43 e1			pop hl 
5e44 7c				ld a,h 
5e45 21 c9 f4			ld hl, os_word_scratch 
5e48 cd 87 12			call hexout 
5e4b e1				pop hl 
5e4c 7d				ld a,l 
5e4d 21 cb f4			ld hl, os_word_scratch+2 
5e50 cd 87 12			call hexout 
5e53 21 cd f4			ld hl, os_word_scratch+4 
5e56 3e 00			ld a,0 
5e58 77				ld (hl),a 
5e59 11 c9 f4			ld de,os_word_scratch 
5e5c 3e 28				ld a, display_row_2 
5e5e cd 65 0d				call str_at_display 
5e61 11 87 5d			ld de, .push_malloc 
5e64 3e 00			ld a, display_row_1 
5e66			 
5e66 cd 65 0d				call str_at_display 
5e69			 
5e69				; display current data stack pointer 
5e69 11 4d 5d			ld de,.data_sp 
5e6c 3e 30				ld a, display_row_2 + 8 
5e6e cd 65 0d				call str_at_display 
5e71			 
5e71 2a f1 f9			ld hl,(cli_data_sp) 
5e74 e5				push hl 
5e75 7c				ld a,h 
5e76 21 c9 f4			ld hl, os_word_scratch 
5e79 cd 87 12			call hexout 
5e7c e1				pop hl 
5e7d 7d				ld a,l 
5e7e 21 cb f4			ld hl, os_word_scratch+2 
5e81 cd 87 12			call hexout 
5e84 21 cd f4			ld hl, os_word_scratch+4 
5e87 3e 00			ld a,0 
5e89 77				ld (hl),a 
5e8a 11 c9 f4			ld de,os_word_scratch 
5e8d 3e 33				ld a, display_row_2 + 11 
5e8f cd 65 0d				call str_at_display 
5e92			 
5e92 cd 75 0d			call update_display 
5e95 cd 95 0c			call delay1s 
5e98 cd 95 0c			call delay1s 
5e9b e1				pop hl 
5e9c f1				pop af 
5e9d c9				ret 
5e9e			;endif 
5e9e			 
5e9e			include "forth_autostart.asm" 
5e9e			; list of commands to perform at system start up 
5e9e			 
5e9e			startcmds: 
5e9e			;	dw test11 
5e9e			;	dw test12 
5e9e			;	dw test13 
5e9e			;	dw test14 
5e9e			;	dw test15 
5e9e			;	dw test16 
5e9e			;	dw test17 
5e9e			;	dw ifthtest1 
5e9e			;	dw ifthtest2 
5e9e			;	dw ifthtest3 
5e9e			;	dw mmtest1 
5e9e			;	dw mmtest2 
5e9e			;	dw mmtest3 
5e9e			;	dw mmtest4 
5e9e			;	dw mmtest5 
5e9e			;	dw mmtest6 
5e9e			;	dw iftest1 
5e9e			;	dw iftest2 
5e9e			;	dw iftest3 
5e9e			;	dw looptest1 
5e9e			;	dw looptest2 
5e9e			;	dw test1 
5e9e			;	dw test2 
5e9e			;	dw test3 
5e9e			;	dw test4 
5e9e			;	dw game2r 
5e9e			;	dw game2b1 
5e9e			;	dw game2b2 
5e9e			 
5e9e				; start up words that are actually useful 
5e9e			 
5e9e a6 5f		    dw spi1 
5ea0 ff 5f		    dw spi2 
5ea2 8d 60		    dw spi3 
5ea4 35 60		    dw spi4 
5ea6 60 60		    dw spi5 
5ea8 f3 60		    dw spi6 
5eaa 48 61		    dw spi7 
5eac			 
5eac a0 61		    dw spi8 
5eae bf 61		    dw spi9 
5eb0 17 62		    dw spi10 
5eb2			 
5eb2			; file editor 
5eb2 18 5f			dw edit1 
5eb4 39 5f			dw edit2 
5eb6 6e 5f			dw edit3 
5eb8			 
5eb8 8a 62			dw longread 
5eba d1 62			dw clrstack 
5ebc 04 63			dw type 
5ebe ef 64			dw stest 
5ec0 28 63			dw strncpy 
5ec2 85 64			dw list 
5ec4 89 63			dw start1 
5ec6 99 63			dw start2 
5ec8			;	dw start3 
5ec8 aa 63			dw start3b 
5eca 25 64			dw start3c 
5ecc			 
5ecc				; (unit) testing words 
5ecc			 
5ecc 66 65			dw mtesta 
5ece 1b 66			dw mtestb 
5ed0 be 66			dw mtestc 
5ed2 73 67			dw mtestd 
5ed4 17 68			dw mteste 
5ed6			 
5ed6				; demo/game words 
5ed6			 
5ed6 23 6f		        dw game3w 
5ed8 51 6f		        dw game3p 
5eda 6f 6f		        dw game3sc 
5edc a0 6f		        dw game3vsi 
5ede cc 6f		        dw game3vs 
5ee0				 
5ee0 16 6d			dw game2b 
5ee2 84 6d			dw game2bf 
5ee4 ce 6d			dw game2mba 
5ee6 64 6e			dw game2mbas 
5ee8 a6 6e			dw game2mb 
5eea			 
5eea d7 69			dw game1 
5eec e8 69			dw game1a 
5eee 4a 6a			dw game1b 
5ef0 7f 6a			dw game1c 
5ef2 b5 6a			dw game1d 
5ef4 e6 6a			dw game1s 
5ef6 fa 6a			dw game1t 
5ef8 0f 6b			dw game1f 
5efa 43 6b			dw game1z 
5efc 87 6b			dw game1zz 
5efe			 
5efe cd 68			dw test5 
5f00 05 69			dw test6 
5f02 3d 69			dw test7 
5f04 51 69			dw test8 
5f06 7d 69			dw test9 
5f08 93 69			dw test10 
5f0a				 
5f0a 5e 6c		        dw ssv5 
5f0c 42 6c		        dw ssv4 
5f0e 26 6c		        dw ssv3 
5f10 f0 6b		        dw ssv2 
5f12 77 6c		        dw ssv1 
5f14 bf 6c		        dw ssv1cpm 
5f16			;	dw keyup 
5f16			;	dw keydown 
5f16			;	dw keyleft 
5f16			;	dw keyright 
5f16			;	dw 	keyf1 
5f16			;	dw keyf2 
5f16			;	dw keyf3 
5f16			;	dw keyf4 
5f16			;	dw keyf5 
5f16			;	dw keyf6 
5f16			;	dw keyf7 
5f16			;	dw keyf8 
5f16			;	dw keyf9 
5f16			;	dw keyf10 
5f16			;	dw keyf11 
5f16			;	dw keyf12 
5f16			;	dw keytab 
5f16			;	dw keycr 
5f16			;	dw keyhome 
5f16			;	dw keyend 
5f16			;	dw keybs 
5f16 00 00			db 0, 0	 
5f18			 
5f18			 
5f18			; File Editor 
5f18			 
5f18			; ( id - ) use 'e' to edit the displayed line 
5f18 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f39 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f6e			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f6e .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5fa6			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5fa6			 
5fa6			; SPI Net support words 
5fa6			 
5fa6			; v0! = node to send to 
5fa6			; ( str count - ) 
5fa6 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
5fff			 
5fff			; spiputchr ( char node - ) 
5fff .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
6035			 
6035			; spigetchr ( - n ) 
6035 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
6060			 
6060			; getnode ( - n ) 
6060 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
608d			 
608d			; ( str node - )  
608d .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
60f3			; store string ( str i - ) 
60f3			 
60f3			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
60f3 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
6148			 
6148			; get string ( addr i -  )    TO FIX 
6148			 
6148 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
61a0			 
61a0			 
61a0			; NETCHAT (TODO) 
61a0			; Program to allow two nodes to chat with eachother 
61a0			; 
61a0			; v0 - target node 
61a0			;  
61a0			; accept input at 0,0 
61a0			; if input is string send spitype to target node 
61a0			; starting at row 2,0 , while spigetchr is not zero ->  
61a0			; 
61a0			; 
61a0			; TODO add paging of get request 
61a0			 
61a0			; ( node - ) 
61a0 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
61bf .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
6217 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
628a			 
628a			 
628a			; Long read of currently open file 
628a .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
62d1			 
62d1			; clear stack  
62d1			 
62d1 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
6304			 
6304			; type ( addr count - ) 
6304 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
6328			 
6328			; some direct memory words 
6328			; strncpy ( len t f -- t ) 
6328			 
6328 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6389			 
6389 .. 00		start1:     	db ": bpon $00 bp ;",0 
6399 .. 00		start2:     	db ": bpoff $01 bp ;",0 
63aa .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6425 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
6485			 
6485			 
6485			; a handy word to list items on the stack 
6485			 
6485 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
64ef			 
64ef			 
64ef			; test stack  
64ef			; rnd8 stest 
64ef			 
64ef .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
6566			 
6566			; random malloc and free cycles 
6566			 
6566 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
661b			 
661b			; fixed malloc and free cycles 
661b			 
661b .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
66be			 
66be			; fixed double string push and drop cycle  
66be			 
66be .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
6773			 
6773			; consistent fixed string push and drop cycle  
6773			 
6773 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6817			 
6817 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
68cd			 
68cd			;test1:		db ": aa 1 2 3 ;", 0 
68cd			;test2:     	db "111 aa 888 999",0 
68cd			;test3:     	db ": bb 77 ;",0 
68cd			;test4:     	db "$02 $01 do i . loop bb",0 
68cd			 
68cd .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6905 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
693d .. 00		test7:     	db ": box hline vline ;",0 
6951 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
697d .. 00		test9:     	db ": sw $01 adsp world ;",0 
6993 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
69b8 .. 00		test11:     	db "hello create .",0 
69c7 .. 00		test12:     	db "hello2 create .",0 
69d7			 
69d7			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
69d7			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
69d7			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
69d7			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
69d7			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
69d7			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
69d7			 
69d7			;iftest1:     	db "$0001 IF cls .",0 
69d7			;iftest2:     	db "$0000 IF cls .",0 
69d7			;iftest3:     	db "$0002 $0003 - IF cls .",0 
69d7			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
69d7			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
69d7			 
69d7			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69d7			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69d7			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69d7			 
69d7			 
69d7			 
69d7			; a small guess the number game 
69d7			 
69d7 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
69e8 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6a4a			 
6a4a .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6a7f .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6ab5 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6ae6 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6afa .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6b0f .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6b43 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6b87			 
6b87			; Using 'ga' save a high score across multiple runs using external storage 
6b87			 
6b87 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6bf0			 
6bf0			 
6bf0			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6bf0			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6bf0			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6bf0			 
6bf0			; simple screen saver to test code memory reuse to destruction 
6bf0			 
6bf0 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6c26 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6c42 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6c5e .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6c77 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6cbf .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6d16			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6d16			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6d16			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6d16			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6d16			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6d16			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6d16			 
6d16			 
6d16			 
6d16			; minesweeper/battleship finding game 
6d16			; draws a game board of random ship/mine positions 
6d16			; user enters coords to see if it hits on 
6d16			; game ends when all are hit 
6d16			; when hit or miss says how many may be in the area 
6d16			 
6d16			; setup the game board and then hide it 
6d16 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6d84 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6dce			; prompt for where to target 
6dce .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6e64 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6e89			; TODO see if the entered coords hits or misses pushes char hit of miss 
6e89 .. 00		game2mbht:      db ": mbckht nop ;",0 
6e98 .. 00		game2mbms:      db ": mbcms nop ;",0 
6ea6			; TODO how many might be near by 
6ea6 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6f23			 
6f23			; Game 3 
6f23			 
6f23			; Vert scroller ski game - avoid the trees! 
6f23			 
6f23			; v0 score (ie turns) 
6f23			; v1 player pos 
6f23			; v2 left wall 
6f23			; v3 right wall 
6f23			 
6f23			; Draw side walls randomly 
6f23			 
6f23 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6f51			 
6f51			; Draw player 
6f51 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6f6f			 
6f6f			; TODO Get Key 
6f6f			 
6f6f			; TODO Move left right 
6f6f			 
6f6f			; scroll and move walls a bit 
6f6f			 
6f6f .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6fa0			 
6fa0			; main game loop 
6fa0			 
6fa0 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6fcc .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
700b			 
700b			; key board defs 
700b			 
700b .. 00		keyup:       db ": keyup $05 ;",0 
7019 .. 00		keydown:       db ": keydown $0a ;",0 
7029 .. 00		keyleft:       db ": keyleft $0b ;",0 
7039 .. 00		keyright:       db ": keyright $0c ;",0 
704a .. 00		keyf1:       db ": keyf1 $10 ;",0 
7058 .. 00		keyf2:       db ": keyf2 $11 ;",0 
7066 .. 00		keyf3:       db ": keyf3 $12 ;",0 
7074 .. 00		keyf4:       db ": keyf4 $13 ;",0 
7082 .. 00		keyf5:       db ": keyf5 $14 ;",0 
7090 .. 00		keyf6:       db ": keyf6 $15 ;",0 
709e .. 00		keyf7:       db ": keyf7 $16 ;",0 
70ac .. 00		keyf8:       db ": keyf8 $17 ;",0 
70ba .. 00		keyf9:       db ": keyf9 $18 ;",0 
70c8 .. 00		keyf10:       db ": keyf10 $19 ;",0 
70d7 .. 00		keyf11:       db ": keyf11 $1a ;",0 
70e6 .. 00		keyf12:       db ": keyf12 $1b ;",0 
70f5			 
70f5 .. 00		keytab:       db ": keytab $09 ;",0 
7104 .. 00		keycr:       db ": keycr $0d ;",0 
7112 .. 00		keyhome:       db ": keyhome $0e ;",0 
7122 .. 00		keyend:       db ": keyend $0f ;",0 
7131 .. 00		keybs:       db ": keybs $08 ;",0 
713f			 
713f			   
713f			 
713f			 
713f			 
713f			; eof 
# End of file forth_autostart.asm
713f			 
713f			 
713f			 
713f			; stack over and underflow checks 
713f			 
713f			; init the words to detect the under/overflow 
713f			 
713f			chk_stk_init: 
713f				; a vague random number to check so we dont get any "lucky" hits 
713f 3e 2d			ld a, 45 
7141 6f				ld l, a 
7142 00				nop 
7143 3e 17			ld a, 23 
7145 67				ld h, a 
7146			 
7146 22 ab f1			ld (chk_word), hl     ; the word we need to check against 
7149			 
7149			;	ld (chk_stund), hl	; stack points.... 
7149 22 fd fe			ld (chk_stovr), hl 
714c 22 ef f9			ld (chk_ret_und), hl 
714f 22 ad f9			ld (chk_ret_ovr), hl 
7152 22 2b f9			ld (chk_loop_ovr), hl 
7155 22 29 f7			ld (chk_data_ovr), hl 
7158 c9				ret 
7159				 
7159			check_stacks: 
7159				; check all stack words 
7159			 
7159 e5				push hl 
715a d5				push de 
715b			 
715b			;	ld de,(chk_word) 
715b			;	ld hl, (chk_stund)	; stack points.... 
715b			;	if DEBUG_STK_FAULT 
715b			;		DMARK "FAa" 
715b			;		CALLMONITOR 
715b			;	endif 
715b			;	call cmp16 
715b			;	jp z, .chk_faulta 
715b			; 
715b			;	ld de, sfaultsu 
715b			;	jp .chk_fault 
715b			 
715b 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
715e ed 5b ab f1		ld de,(chk_word) 
7162				if DEBUG_STK_FAULT 
7162					DMARK "FAb" 
7162					CALLMONITOR 
7162				endif 
7162 cd a4 0f			call cmp16 
7165 28 06			jr z, .chk_fault1 
7167 11 08 72			ld de, sfaultso 
716a c3 bc 71			jp .chk_fault 
716d			.chk_fault1:  
716d 2a ef f9			ld hl, (chk_ret_und) 
7170 ed 5b ab f1		ld de,(chk_word) 
7174				if DEBUG_STK_FAULT 
7174					DMARK "FAU" 
7174					CALLMONITOR 
7174				endif 
7174 cd a4 0f			call cmp16 
7177 ca 80 71			jp z, .chk_fault2 
717a 11 18 72			ld de, sfaultru 
717d c3 bc 71			jp .chk_fault 
7180			.chk_fault2:  
7180 2a ad f9			ld hl, (chk_ret_ovr) 
7183 ed 5b ab f1		ld de,(chk_word) 
7187				if DEBUG_STK_FAULT 
7187					DMARK "FA1" 
7187					CALLMONITOR 
7187				endif 
7187 cd a4 0f			call cmp16 
718a ca 93 71			jp z, .chk_fault3 
718d 11 26 72			ld de, sfaultro 
7190 c3 bc 71			jp .chk_fault 
7193			.chk_fault3:  
7193 2a 2b f9			ld hl, (chk_loop_ovr) 
7196 ed 5b ab f1		ld de,(chk_word) 
719a				if DEBUG_STK_FAULT 
719a					DMARK "FA2" 
719a					CALLMONITOR 
719a				endif 
719a cd a4 0f			call cmp16 
719d ca a6 71			jp z, .chk_fault4 
71a0 11 40 72			ld de, sfaultlo 
71a3 c3 bc 71			jp .chk_fault 
71a6			.chk_fault4:  
71a6 2a 29 f7			ld hl, (chk_data_ovr) 
71a9 ed 5b ab f1		ld de,(chk_word) 
71ad				if DEBUG_STK_FAULT 
71ad					DMARK "FA3" 
71ad					CALLMONITOR 
71ad				endif 
71ad cd a4 0f			call cmp16 
71b0 ca b9 71			jp z, .chk_fault5 
71b3 11 5a 72			ld de, sfaultdo 
71b6 c3 bc 71			jp .chk_fault 
71b9			 
71b9			 
71b9			.chk_fault5:  
71b9 d1				pop de 
71ba e1				pop hl 
71bb			 
71bb c9				ret 
71bc			 
71bc cd 52 0d		.chk_fault: 	call clear_display 
71bf 3e 28				ld a, display_row_2 
71c1 cd 65 0d				call str_at_display 
71c4 11 ea 71				   ld de, .stackfault 
71c7 3e 00				ld a, display_row_1 
71c9 cd 65 0d				call str_at_display 
71cc 11 6e fe				    ld de, debug_mark 
71cf 3e 11				ld a, display_row_1+17 
71d1 cd 65 0d				call str_at_display 
71d4 cd 75 0d				call update_display 
71d7			 
71d7				; prompt before entering montior for investigating issue 
71d7			 
71d7 3e 78			ld a, display_row_4 
71d9 11 e5 1d			ld de, endprog 
71dc			 
71dc cd 75 0d			call update_display		 
71df			 
71df cd 43 20			call next_page_prompt 
71e2			 
71e2 d1				pop de 
71e3 e1				pop hl 
71e4 cd 39 1e				call monitor 
71e7 c3 33 1d				jp warmstart 
71ea					;jp 0 
71ea					;halt 
71ea			 
71ea			 
71ea			 
71ea .. 00		.stackfault: 	db "Stack fault:",0 
71f7			 
71f7 .. 00		sfaultsu: 	db	"Stack under flow",0 
7208 .. 00		sfaultso: 	db	"Stack over flow",0 
7218 .. 00		sfaultru:	db "RTS underflow",0 
7226 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7240 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
725a .. 00		sfaultdo:	db "DTS overflow", 0 
7267			 
7267			 
7267			fault_dsp_under: 
7267 11 79 72			ld de, .dsp_under 
726a c3 29 73			jp .show_fault 
726d			 
726d			fault_rsp_under: 
726d 11 87 72			ld de, .rsp_under 
7270 c3 29 73			jp .show_fault 
7273			fault_loop_under: 
7273 11 95 72			ld de, .loop_under 
7276 c3 29 73			jp .show_fault 
7279			 
7279 .. 00		.dsp_under: db "DSP Underflow",0 
7287 .. 00		.rsp_under: db "RSP Underflow",0 
7295 .. 00		.loop_under: db "LOOP Underflow",0 
72a4			 
72a4			 
72a4 d5			type_faultn: 	push de 
72a5 e5					push hl 
72a6 cd 52 0d				call clear_display 
72a9 11 d0 72				   ld de, .typefaultn 
72ac 3e 00				ld a, display_row_1 
72ae cd 65 0d				call str_at_display 
72b1 11 6e fe				    ld de, debug_mark 
72b4 3e 11				ld a, display_row_1+17 
72b6 cd 65 0d				call str_at_display 
72b9 cd 75 0d				call update_display 
72bc			 
72bc				; prompt before entering montior for investigating issue 
72bc			 
72bc 3e 78			ld a, display_row_4 
72be 11 e5 1d			ld de, endprog 
72c1			 
72c1 cd 75 0d			call update_display		 
72c4			 
72c4 cd 43 20			call next_page_prompt 
72c7			 
72c7 e5					push hl 
72c8 d5					push de 
72c9 cd 39 1e				call monitor 
72cc c3 33 1d				jp warmstart 
72cf 76					halt 
72d0			 
72d0			 
72d0 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
72e7			 
72e7 d5			type_faults: 	push de 
72e8 e5					push hl 
72e9 cd 52 0d				call clear_display 
72ec 11 12 73				   ld de, .typefaults 
72ef 3e 00				ld a, display_row_1 
72f1 cd 65 0d				call str_at_display 
72f4 11 6e fe				    ld de, debug_mark 
72f7 3e 11				ld a, display_row_1+17 
72f9 cd 65 0d				call str_at_display 
72fc cd 75 0d				call update_display 
72ff			 
72ff				; prompt before entering montior for investigating issue 
72ff			 
72ff 3e 78			ld a, display_row_4 
7301 11 e5 1d			ld de, endprog 
7304			 
7304 cd 75 0d			call update_display		 
7307			 
7307 cd 43 20			call next_page_prompt 
730a			 
730a e1					pop hl 
730b d1					pop de 
730c cd 39 1e				call monitor 
730f c3 33 1d				jp warmstart 
7312			 
7312			 
7312 .. 00		.typefaults: db "STR Type Expected TOS!",0 
7329			 
7329			.show_fault: 	 
7329 d5					push de 
732a cd 52 0d				call clear_display 
732d d1					pop de 
732e 3e 00				ld a, display_row_1 
7330 cd 65 0d				call str_at_display 
7333 11 6e fe				    ld de, debug_mark 
7336 3e 11				ld a, display_row_1+17 
7338 cd 65 0d				call str_at_display 
733b cd 75 0d				call update_display 
733e			 
733e				; prompt before entering montior for investigating issue 
733e			 
733e 3e 78			ld a, display_row_4 
7340 11 e5 1d			ld de, endprog 
7343			 
7343 cd 75 0d			call update_display		 
7346			 
7346 cd 43 20			call next_page_prompt 
7349			 
7349 e1					pop hl 
734a d1					pop de 
734b cd 39 1e				call monitor 
734e			; do a dump to cli and not warmstart so we preserve all of the uwords.  
734e			; TODO Make optional fault restart to cli or warm boot? 
734e					;jp warmstart 
734e c3 8b 1d				jp cli 
7351 76					halt 
7352			 
7352			; handle the auto run of code from files in storage 
7352			 
7352			 
7352			include "forth_startup.asm" 
7352			; Which startup method to use? 
7352			; 
7352			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
7352			; followed by loading of a list of scripts in eeprom 
7352			 
7352			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
7352			; from eeprom 
7352			 
7352			; Select with define in main stubs 
7352			 
7352			if STARTUP_V1 
7352				include "forth_startupv1.asm" 
7352			endif 
7352			if STARTUP_V2 
7352				include "forth_startupv2.asm" 
7352			; Version 2 of the startup  
7352			;  
7352			; Auto load any files in bank 1 that start with a '*' 
7352			; If no se storage then revert to using eprom 
7352			 
7352			 
7352			if STORAGE_SE = 0 
7352			 
7352			sprompt1: db "Startup load...",0 
7352			sprompt2: db "Run? 1=No *=End #=All",0 
7352			 
7352			 
7352			 
7352			 
7352			forth_startup: 
7352				ld hl, startcmds 
7352				ld a, 0 
7352				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
7352			 
7352			.start1:	push hl 
7352				call clear_display 
7352				ld de, sprompt1 
7352			        ld a, display_row_1 
7352				call str_at_display 
7352				ld de, sprompt2 
7352			        ld a, display_row_2 
7352				call str_at_display 
7352				pop hl 
7352				push hl 
7352				ld e,(hl) 
7352				inc hl 
7352				ld d,(hl) 
7352			        ld a, display_row_3 
7352				call str_at_display 
7352				call update_display 
7352			 
7352			 
7352				ld a, (os_last_cmd) 
7352				cp 0 
7352				jr z, .startprompt 
7352				call delay250ms 
7352				jr .startdo 
7352				 
7352				 
7352			 
7352			.startprompt: 
7352			 
7352				ld a,display_row_4 + display_cols - 1 
7352			        ld de, endprg 
7352				call str_at_display 
7352				call update_display 
7352				call delay1s 
7352				call cin_wait 
7352						 
7352				cp '*' 
7352				jr z, .startupend1 
7352				cp '#' 
7352				jr nz, .startno 
7352				ld a, 1 
7352				ld (os_last_cmd),a 
7352				jr .startdo 
7352			.startno:	cp '1' 
7352				jr z,.startnxt  
7352			 
7352				; exec startup line 
7352			.startdo:	 
7352				pop hl 
7352				push hl 
7352				 
7352				ld e,(hl) 
7352				inc hl 
7352				ld d,(hl) 
7352				ex de,hl 
7352			 
7352				push hl 
7352			 
7352				ld a, 0 
7352				;ld a, FORTH_END_BUFFER 
7352				call strlent 
7352				inc hl   ; include zero term to copy 
7352				ld b,0 
7352				ld c,l 
7352				pop hl 
7352				ld de, scratch 
7352				ldir 
7352			 
7352			 
7352				ld hl, scratch 
7352				call forthparse 
7352				call forthexec 
7352				call forthexec_cleanup 
7352			 
7352				ld a, display_row_4 
7352				ld de, endprog 
7352			 
7352				call update_display		 
7352			 
7352				ld a, (os_last_cmd) 
7352				cp 0 
7352				jr nz, .startnxt 
7352				call next_page_prompt 
7352			        call clear_display 
7352				call update_display		 
7352			 
7352				; move onto next startup line? 
7352			.startnxt: 
7352			 
7352				call delay250ms 
7352				pop hl 
7352			 
7352				inc hl 
7352				inc hl 
7352			 
7352				push hl 
7352				ld e, (hl) 
7352				inc hl 
7352				ld d, (hl) 
7352				pop hl 
7352				; TODO replace 0 test 
7352			 
7352				ex de, hl 
7352				call ishlzero 
7352			;	ld a,e 
7352			;	add d 
7352			;	cp 0    ; any left to do? 
7352				ex de, hl 
7352				jp nz, .start1 
7352				jr .startupend 
7352			 
7352			.startupend1: pop hl 
7352			.startupend: 
7352			 
7352				call clear_display 
7352				call update_display 
7352				ret 
7352			endif 
7352			 
7352			 
7352			if STORAGE_SE 
7352			 
7352			;sprompt3: db "Loading from start-up file:",0 
7352 .. 00		sprompt3: db "  Searching...",0 
7361			;sprompt4: db "(Any key to stop)",0 
7361			 
7361			 
7361			forth_autoload: 
7361			 
7361				; load block 0 of store 1 
7361				 
7361 3e fe			ld a, $fe      ; bit 0 clear 
7363 32 63 fa			ld (spi_device), a 
7366			 
7366 cd cd 04			call storage_get_block_0 
7369			 
7369 3a 9e fa			ld a, (store_page+STORE_0_AUTOFILE) 
736c			 
736c fe 00			cp 0 
736e c8				ret z     ; auto start not enabled 
736f			 
736f cd 52 0d			call clear_display 
7372			 
7372				; set bank 
7372			 
7372 3a a0 fa				ld a, (store_page+STORE_0_BANKRUN) 
7375 32 63 fa				ld (spi_device), a 
7378			 
7378			 
7378				; generate a directory of bank 1 and search for flagged files 
7378			 
7378					if DEBUG_FORTH_WORDS_KEY 
7378						DMARK "DIR" 
7378 f5				push af  
7379 3a 8d 73			ld a, (.dmark)  
737c 32 6e fe			ld (debug_mark),a  
737f 3a 8e 73			ld a, (.dmark+1)  
7382 32 6f fe			ld (debug_mark+1),a  
7385 3a 8f 73			ld a, (.dmark+2)  
7388 32 70 fe			ld (debug_mark+2),a  
738b 18 03			jr .pastdmark  
738d ..			.dmark: db "DIR"  
7390 f1			.pastdmark: pop af  
7391			endm  
# End of macro DMARK
7391						CALLMONITOR 
7391 cd fb 19			call break_point_state  
7394				endm  
# End of macro CALLMONITOR
7394					endif 
7394			 
7394 cd cd 04			call storage_get_block_0 
7397			 
7397 21 7d fa			ld hl, store_page     ; get current id count 
739a 46				ld b, (hl) 
739b 0e 00			ld c, 0    ; count of files   
739d					if DEBUG_FORTH_WORDS 
739d						DMARK "DI1" 
739d f5				push af  
739e 3a b2 73			ld a, (.dmark)  
73a1 32 6e fe			ld (debug_mark),a  
73a4 3a b3 73			ld a, (.dmark+1)  
73a7 32 6f fe			ld (debug_mark+1),a  
73aa 3a b4 73			ld a, (.dmark+2)  
73ad 32 70 fe			ld (debug_mark+2),a  
73b0 18 03			jr .pastdmark  
73b2 ..			.dmark: db "DI1"  
73b5 f1			.pastdmark: pop af  
73b6			endm  
# End of macro DMARK
73b6						CALLMONITOR 
73b6 cd fb 19			call break_point_state  
73b9				endm  
# End of macro CALLMONITOR
73b9					endif 
73b9			 
73b9				; check for empty drive 
73b9			 
73b9 3e 00			ld a, 0 
73bb b8				cp b 
73bc ca 09 74			jp z, .dirdone 
73bf			 
73bf				; for each of the current ids do a search for them and if found push to stack 
73bf			 
73bf c5			.diritem:	push bc 
73c0 21 40 00				ld hl, STORE_BLOCK_PHY 
73c3 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
73c5 58					ld e,b 
73c6			 
73c6 d5					push de 
73c7 e5					push hl 
73c8 cd 52 0d			call clear_display 
73cb 3e 32			ld a, display_row_2 + 10 
73cd 11 52 73			ld de, sprompt3 
73d0 cd 65 0d			call str_at_display 
73d3 cd a9 0c			call active 
73d6 eb				ex de, hl 
73d7 3e 2f			ld a, display_row_2 + 7 
73d9 cd 65 0d			call str_at_display 
73dc cd 75 0d			call update_display 
73df e1				pop hl 
73e0 d1				pop de 
73e1			 
73e1			;		if DEBUG_FORTH_WORDS 
73e1			;			DMARK "DI2" 
73e1			;			CALLMONITOR 
73e1			;		endif 
73e1			 
73e1 cd 4f 07				call storage_findnextid 
73e4			 
73e4			;		if DEBUG_FORTH_WORDS 
73e4			;			DMARK "DI3" 
73e4			;			CALLMONITOR 
73e4			;		endif 
73e4			 
73e4					; if found hl will be non zero 
73e4			 
73e4 cd af 0f				call ishlzero 
73e7			;		ld a, l 
73e7			;		add h 
73e7			; 
73e7			;		cp 0 
73e7 28 1d				jr z, .dirnotfound 
73e9			 
73e9					; increase count 
73e9			 
73e9 c1					pop bc	 
73ea 0c					inc c 
73eb c5					push bc 
73ec					 
73ec			 
73ec					; get file header and push the file name 
73ec			 
73ec 11 7d fa				ld de, store_page 
73ef cd 1c 04				call storage_read_block 
73f2			 
73f2					; push file id to stack 
73f2				 
73f2			 
73f2					; is this a file we want to run? 
73f2			 
73f2 21 80 fa				ld hl, store_page+3 
73f5 7e					ld a,(hl) 
73f6 fe 2a				cp '*' 
73f8 20 0c				jr nz,  .dirnotfound 
73fa					 
73fa			 
73fa			 
73fa 3a 7d fa				ld a, (store_page) 
73fd d5					push de 
73fe e5					push hl 
73ff c5					push bc 
7400 cd 2c 74				call .autorunf 
7403 c1					pop bc 
7404 e1					pop hl 
7405 d1					pop de 
7406			 
7406			 
7406			 
7406				; save this extent 
7406			 
7406					; push file name 
7406			;display file name to run 
7406			 
7406			;		ld hl, store_page+3 
7406			;		if DEBUG_FORTH_WORDS 
7406			;			DMARK "DI5" 
7406			;			CALLMONITOR 
7406			;		endif 
7406			; 
7406			;		 
7406			; 
7406			;		call forth_push_str 
7406			;		if DEBUG_FORTH_WORDS 
7406			;			DMARK "DI6" 
7406			;			CALLMONITOR 
7406			;		endif 
7406			.dirnotfound: 
7406 c1					pop bc     
7407 10 b6				djnz .diritem 
7409				 
7409			.dirdone:	 
7409					if DEBUG_FORTH_WORDS 
7409						DMARK "DI7" 
7409 f5				push af  
740a 3a 1e 74			ld a, (.dmark)  
740d 32 6e fe			ld (debug_mark),a  
7410 3a 1f 74			ld a, (.dmark+1)  
7413 32 6f fe			ld (debug_mark+1),a  
7416 3a 20 74			ld a, (.dmark+2)  
7419 32 70 fe			ld (debug_mark+2),a  
741c 18 03			jr .pastdmark  
741e ..			.dmark: db "DI7"  
7421 f1			.pastdmark: pop af  
7422			endm  
# End of macro DMARK
7422						CALLMONITOR 
7422 cd fb 19			call break_point_state  
7425				endm  
# End of macro CALLMONITOR
7425					endif 
7425			 
7425 cd 52 0d				call clear_display 
7428 cd 75 0d				call update_display 
742b			 
742b c9					ret 
742c			 
742c			 
742c			 
742c			 
742c			 
742c			.autorunf: 
742c			 
742c			 
742c				; get file id to load from and get the file name to display 
742c			 
742c			;		ld a, (store_page+STORE_0_FILERUN) 
742c			 
742c 2e 00				ld l, 0 
742e 67					ld h, a 
742f 11 7d fa				ld de, store_page 
7432			 
7432					if DEBUG_FORTH_WORDS 
7432						DMARK "ASp" 
7432 f5				push af  
7433 3a 47 74			ld a, (.dmark)  
7436 32 6e fe			ld (debug_mark),a  
7439 3a 48 74			ld a, (.dmark+1)  
743c 32 6f fe			ld (debug_mark+1),a  
743f 3a 49 74			ld a, (.dmark+2)  
7442 32 70 fe			ld (debug_mark+2),a  
7445 18 03			jr .pastdmark  
7447 ..			.dmark: db "ASp"  
744a f1			.pastdmark: pop af  
744b			endm  
# End of macro DMARK
744b						CALLMONITOR 
744b cd fb 19			call break_point_state  
744e				endm  
# End of macro CALLMONITOR
744e					endif 
744e cd 75 09				call storage_read 
7451			 
7451					if DEBUG_FORTH_WORDS 
7451						DMARK "ASr" 
7451 f5				push af  
7452 3a 66 74			ld a, (.dmark)  
7455 32 6e fe			ld (debug_mark),a  
7458 3a 67 74			ld a, (.dmark+1)  
745b 32 6f fe			ld (debug_mark+1),a  
745e 3a 68 74			ld a, (.dmark+2)  
7461 32 70 fe			ld (debug_mark+2),a  
7464 18 03			jr .pastdmark  
7466 ..			.dmark: db "ASr"  
7469 f1			.pastdmark: pop af  
746a			endm  
# End of macro DMARK
746a						CALLMONITOR 
746a cd fb 19			call break_point_state  
746d				endm  
# End of macro CALLMONITOR
746d					endif 
746d			 
746d cd af 0f				call ishlzero 
7470 c8					ret z             ; file not found 
7471			 
7471					; display file name we are loading 
7471			 
7471 cd 52 0d				call clear_display 
7474			 
7474 3e 32				ld a, display_row_2 + 10 
7476 11 80 fa				ld de, store_page+3 
7479 cd 65 0d				call str_at_display 
747c				 
747c			; 
747c			 
747c			;	ld a, display_row_1+5 
747c			;	ld de, sprompt3 
747c			;	call str_at_display 
747c			;	ld a, display_row_2+7 
747c			;	call active 
747c			;	ex de, hl 
747c			;;	ld de, sprompt4 
747c			;	call str_at_display 
747c			; 
747c cd 75 0d			call update_display 
747f			 
747f			;	call cin_wait 
747f			;	cp 'n' 
747f			;	ret z 
747f			;	cp 'N' 
747f			;	ret z 
747f			 
747f			;	call delay1s 
747f			 
747f 3a 7f fa			ld a, (store_page+2) 
7482 32 6c fa			ld (store_openmaxext), a    ; save count of ext 
7485 3e 01			ld a, 1  
7487 32 6d fa			ld (store_openext), a    ; save count of ext 
748a			 
748a			.autof: 
748a				; begin to read a line from file 
748a			 
748a 21 eb f4			ld hl, os_cli_cmd 
748d 22 e9 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
7490			  
7490			.readext: 
7490 3a 6d fa			ld a, (store_openext) 
7493 6f				ld l , a 
7494				 
7494 3a 7d fa			ld a, (store_page) 
7497 67				ld h, a	 
7498 11 7d fa			ld de, store_page 
749b					if DEBUG_FORTH_WORDS 
749b						DMARK "ASl" 
749b f5				push af  
749c 3a b0 74			ld a, (.dmark)  
749f 32 6e fe			ld (debug_mark),a  
74a2 3a b1 74			ld a, (.dmark+1)  
74a5 32 6f fe			ld (debug_mark+1),a  
74a8 3a b2 74			ld a, (.dmark+2)  
74ab 32 70 fe			ld (debug_mark+2),a  
74ae 18 03			jr .pastdmark  
74b0 ..			.dmark: db "ASl"  
74b3 f1			.pastdmark: pop af  
74b4			endm  
# End of macro DMARK
74b4						CALLMONITOR 
74b4 cd fb 19			call break_point_state  
74b7				endm  
# End of macro CALLMONITOR
74b7					endif 
74b7 cd 75 09				call storage_read 
74ba cd af 0f			call ishlzero 
74bd c8				ret z 
74be			 
74be			; TODO copy to exec buffer 
74be			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
74be			 
74be				; copy the record buffer to the cli buffer 
74be			 
74be ed 5b e9 f6		ld de, (os_var_array) 
74c2 21 7f fa			ld hl, store_page+2 
74c5			;	ex de, hl 
74c5 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
74c8 ed b0			ldir 
74ca ed 53 e9 f6		ld (os_var_array), de 
74ce				 
74ce 3a 6d fa			ld a, (store_openext) 
74d1 3c				inc a 
74d2 32 6d fa			ld (store_openext), a    ; save count of ext 
74d5			 
74d5			 
74d5			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
74d5				 
74d5 3a 70 fa			ld a, (store_readcont) 
74d8 fe 00			cp 0 
74da 20 b4			jr nz, .readext 
74dc			 
74dc			;	jr z, .autoend 
74dc			 
74dc					if DEBUG_FORTH_WORDS 
74dc						DMARK "ASc" 
74dc f5				push af  
74dd 3a f1 74			ld a, (.dmark)  
74e0 32 6e fe			ld (debug_mark),a  
74e3 3a f2 74			ld a, (.dmark+1)  
74e6 32 6f fe			ld (debug_mark+1),a  
74e9 3a f3 74			ld a, (.dmark+2)  
74ec 32 70 fe			ld (debug_mark+2),a  
74ef 18 03			jr .pastdmark  
74f1 ..			.dmark: db "ASc"  
74f4 f1			.pastdmark: pop af  
74f5			endm  
# End of macro DMARK
74f5						CALLMONITOR 
74f5 cd fb 19			call break_point_state  
74f8				endm  
# End of macro CALLMONITOR
74f8					endif 
74f8 e5				push hl	 
74f9 d5				push de 
74fa cd a9 0c			call active 
74fd eb				ex de, hl 
74fe 3e 2f			ld a, display_row_2 + 7 
7500 cd 65 0d			call str_at_display 
7503			 
7503 cd 75 0d			call update_display 
7506 d1				pop de  
7507 e1				pop hl 
7508			;	call delay250ms 
7508			 
7508			 
7508			 
7508			 
7508			.autoexec: 
7508			 
7508			 
7508 21 eb f4			ld hl, os_cli_cmd 
750b					if DEBUG_FORTH_WORDS 
750b						DMARK "ASx" 
750b f5				push af  
750c 3a 20 75			ld a, (.dmark)  
750f 32 6e fe			ld (debug_mark),a  
7512 3a 21 75			ld a, (.dmark+1)  
7515 32 6f fe			ld (debug_mark+1),a  
7518 3a 22 75			ld a, (.dmark+2)  
751b 32 70 fe			ld (debug_mark+2),a  
751e 18 03			jr .pastdmark  
7520 ..			.dmark: db "ASx"  
7523 f1			.pastdmark: pop af  
7524			endm  
# End of macro DMARK
7524						CALLMONITOR 
7524 cd fb 19			call break_point_state  
7527				endm  
# End of macro CALLMONITOR
7527					endif 
7527 cd c6 24			call forthparse 
752a cd 06 25			call forthexec 
752d cd 18 24			call forthexec_cleanup 
7530			 
7530			 
7530			 
7530 c3 8a 74			jp .autof 
7533			;.autofdone: 
7533			; 
7533			;		if DEBUG_FORTH_WORDS 
7533			;			DMARK "ASx" 
7533			;			CALLMONITOR 
7533			;		endif 
7533			;;	call clear_display 
7533			;	ret 
7533			 
7533			 
7533			 
7533			endif 
# End of file forth_startupv2.asm
7533			endif 
7533			 
# End of file forth_startup.asm
7533			 
7533			; eof 
# End of file forth_kernel.asm
7533			;include "nascombasic.asm" 
7533			 
7533			 
7533			; find out where the code ends if loaded into RAM (for SC114) 
7533			;endofcode:  
7533			;	nop 
7533			 
7533			 
7533			; eof 
7533			 
# End of file main.asm
7533			include "firmware_lcd_4x40.asm" 
7533			; **********************************************************************  
7533			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
7533			; **********************************************************************  
7533			;  
7533			; **  Written as a Small Computer Monitor App  
7533			; **  www.scc.me.uk  
7533			;  
7533			; History  
7533			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
7533			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
7533			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
7533			;  
7533			; **********************************************************************  
7533			;  
7533			; This program is an example of one of the methods of interfacing an   
7533			; alphanumeric LCD module.   
7533			;  
7533			; In this example the display is connected to either a Z80 PIO or a   
7533			; simple 8-bit output port.   
7533			;  
7533			; This interfacing method uses 4-bit data mode and uses time delays  
7533			; rather than polling the display's ready status. As a result the   
7533			; interface only requires 6 simple output lines:  
7533			;   Output bit 0 = not used  
7533			;   Output bit 1 = not used  
7533			;   Output bit 2 = RS         High = data, Low = instruction  
7533			;   Output bit 3 = E          Active high  
7533			;   Output bit 4 = DB4  
7533			;   Output bit 5 = DB5  
7533			;   Output bit 6 = DB6  
7533			;   Output bit 7 = DB7  
7533			; Display's R/W is connected to 0v so it is always in write mode  
7533			;  
7533			; This set up should work with any system supporting the RC2014 bus  
7533			  
7533			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
7533			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
7533			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
7533			;  
7533			; **********************************************************************  
7533			  
7533			; Additonal for 4x40. E1 and E2 instead of just E   
7533			; TODO swipe vidout signal on port a to activate E2  
7533			  
7533			; **********************************************************************  
7533			; **  Constants  
7533			; **********************************************************************  
7533			; LCD constants required by LCD support module  
7533			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
7533			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
7533			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
7533			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
7533			; TODO Decide which E is being set  
7533			kLCDWidth:  EQU display_cols             ;Width in characters  
7533			  
7533			; **********************************************************************  
7533			; **  Code library usage  
7533			; **********************************************************************  
7533			  
7533			; send character to current cursor position  
7533			; wraps and/or scrolls screen automatically  
7533			  
7533			  
7533			  
7533			lcd_init:  
7533			  
7533			; SCMonAPI functions used  
7533			  
7533			; Alphanumeric LCD functions used  
7533			; no need to specify specific functions for this module  
7533			  
7533 3e cf		            LD   A, 11001111b  
7535 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7537 3e 00		            LD   A, 00000000b  
7539 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
753b			  
753b			; Initialise alphanumeric LCD module  
753b 3e 00				ld a, 0  
753d 32 ce fb				ld (display_lcde1e2), a  
7540 cd c1 75		            CALL fLCD_Init      ;Initialise LCD module  
7543 3e 01				ld a, 1  
7545 32 ce fb				ld (display_lcde1e2), a  
7548 cd c1 75		            CALL fLCD_Init      ;Initialise LCD module  
754b			  
754b c9				ret  
754c			  
754c			;  
754c			;;  
754c			; lcd functions  
754c			;  
754c			;  
754c			  
754c			; what is at cursor position   
754c			  
754c			;get_cursor:	ld de, (cursor_row)   ;  row + col  
754c			;		call curptr  
754c			;		ret  
754c			  
754c			  
754c			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
754c			  
754c			curptr:  
754c c5				push bc  
754d 21 b4 fd			ld hl, display_fb0  
7550			cpr:	  
7550				; loop for cursor whole row  
7550 0e 28			ld c, display_cols  
7552 23			cpr1:	inc hl  
7553 0d				dec c  
7554 20 fc			jr nz, cpr1  
7556 05				dec b  
7557 20 f7			jr nz, cpr  
7559			  
7559				; add col	  
7559			  
7559 23			cpr2:	inc hl  
755a 1d				dec e  
755b 20 fc			jr nz, cpr2  
755d			  
755d c1				pop bc  
755e c9				ret  
755f				  
755f			  
755f			  
755f			  
755f			  
755f			; write the frame buffer given in hl to hardware   
755f 22 cc fb		write_display: ld (display_write_tmp), hl 	   
7562 3e 00			ld a, kLCD_Line1  
7564 cd 6e 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7567 06 28			ld b, display_cols  
7569 ed 5b cc fb		ld de, (display_write_tmp)  
756d cd b9 75			call write_len_string  
7570				  
7570				  
7570 2a cc fb			ld hl, (display_write_tmp)  
7573 11 28 00			ld de, display_cols  
7576 19				add hl,de  
7577 22 cc fb			ld (display_write_tmp),hl  
757a			  
757a				  
757a 3e 28			ld a, kLCD_Line2  
757c cd 6e 76		            CALL fLCD_Pos       ;Position cursor to location in A  
757f 06 28			ld b, display_cols  
7581 ed 5b cc fb		ld de, (display_write_tmp)  
7585 cd b9 75			call write_len_string  
7588				  
7588 2a cc fb			ld hl, (display_write_tmp)  
758b 11 28 00			ld de, display_cols  
758e 19				add hl,de  
758f 22 cc fb			ld (display_write_tmp),hl  
7592			  
7592				  
7592 3e 50			ld a, kLCD_Line3  
7594 cd 6e 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7597 06 28			ld b, display_cols  
7599 ed 5b cc fb		ld de, (display_write_tmp)  
759d cd b9 75			call write_len_string  
75a0				  
75a0 2a cc fb			ld hl, (display_write_tmp)  
75a3 11 28 00			ld de, display_cols  
75a6 19				add hl,de  
75a7 22 cc fb			ld (display_write_tmp),hl  
75aa			  
75aa				  
75aa 3e 78			ld a, kLCD_Line4  
75ac cd 6e 76		            CALL fLCD_Pos       ;Position cursor to location in A  
75af 06 28			ld b, display_cols  
75b1 ed 5b cc fb		ld de, (display_write_tmp)  
75b5 cd b9 75			call write_len_string  
75b8 c9					ret  
75b9				  
75b9				; write out a fixed length string given in b from de  
75b9			  
75b9 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
75ba cd 26 76		            CALL fLCD_Data      ;Write character to display  
75bd 13				inc de  
75be 10 f9			djnz write_len_string  
75c0 c9				ret  
75c1			  
75c1			; Some other things to do  
75c1			;            LD   A, kLCD_Clear ;Display clear  
75c1			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
75c1			;            LD   A, kLCD_Under ;Display on with underscore cursor  
75c1			;            LD   A, kLCD_On     ;Display on with no cursor  
75c1			;            ;LD   A, kLCD_Off   ;Display off  
75c1			;            CALL fLCD_Inst      ;Send instruction to display  
75c1			;  
75c1			;  
75c1			;            halt  
75c1			;  
75c1			;  
75c1			;MsgHello:   DB  "Hello World!",0  
75c1			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
75c1			  
75c1			; Custom characters 5 pixels wide by 8 pixels high  
75c1			; Up to 8 custom characters can be defined  
75c1			;BitMaps:      
75c1			;; Character 0x00 = Battery icon  
75c1			;            DB  01110b  
75c1			;            DB  11011b  
75c1			;            DB  10001b  
75c1			;            DB  10001b  
75c1			;            DB  11111b  
75c1			;            DB  11111b  
75c1			;            DB  11111b  
75c1			;            DB  11111b  
75c1			;; Character 0x01 = Bluetooth icon  
75c1			;            DB  01100b  
75c1			;            DB  01010b  
75c1			;            DB  11100b  
75c1			;            DB  01000b  
75c1			;            DB  11100b  
75c1			;            DB  01010b  
75c1			;            DB  01100b  
75c1			;            DB  00000b  
75c1			;  
75c1			  
75c1			  
75c1			; **********************************************************************  
75c1			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
75c1			; **********************************************************************  
75c1			;  
75c1			; **  Written as a Small Computer Monitor App   
75c1			; **  Version 0.1 SCC 2018-05-16  
75c1			; **  www.scc.me.uk  
75c1			;  
75c1			; **********************************************************************  
75c1			;  
75c1			; This module provides support for alphanumeric LCD modules using with  
75c1			; *  HD44780 (or compatible) controller  
75c1			; *  5 x 7 pixel fonts  
75c1			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
75c1			; *  Interface via six digital outputs to the display (see below)  
75c1			;  
75c1			; LCD module pinout:  
75c1			;   1  Vss   0v supply  
75c1			;   2  Vdd   5v supply  
75c1			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
75c1			;   4  RS    High = data, Low = instruction  
75c1			;   5  R/W   High = Read, Low = Write  
75c1			;   6  E     Enable signal (active high)  
75c1			;   7  DB0   Data bit 0  
75c1			;   8  DB1   Data bit 1  
75c1			;   9  DB2   Data bit 2  
75c1			;  10  DB3   Data bit 3  
75c1			;  11  DB4   Data bit 4  
75c1			;  12  DB5   Data bit 5  
75c1			;  13  DB6   Data bit 6  
75c1			;  14  DB7   Data bit 7  
75c1			;  15  A     Backlight anode (+)  
75c1			;  16  K     Backlight cathode (-)  
75c1			;  
75c1			; This interfacing method uses 4-bit data mode and uses time delays  
75c1			; rather than polling the display's ready status. As a result the   
75c1			; interface only requires 6 simple output lines:  
75c1			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
75c1			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
75c1			;   LCD DB4 = Microcomputer output port bit 4  
75c1			;   LCD DB5 = Microcomputer output port bit 5  
75c1			;   LCD DB6 = Microcomputer output port bit 6  
75c1			;   LCD DB7 = Microcomputer output port bit 7  
75c1			; Display's R/W is connected to 0v so it is always in write mode  
75c1			; All 6 connections must be on the same port address <kLCDPrt>  
75c1			; This method also allows a decent length of cable from micro to LCD  
75c1			;  
75c1			; **********************************************************************  
75c1			;  
75c1			; To include the code for any given function provided by this module,   
75c1			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
75c1			; the parent source file.  
75c1			; For example:  #REQUIRES   uHexPrefix  
75c1			;  
75c1			; Also #INCLUDE this file at some point after the #REQUIRES statements  
75c1			; in the parent source file.  
75c1			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
75c1			;  
75c1			; These are the function names provided by this module:  
75c1			; fLCD_Init                     ;Initialise LCD  
75c1			; fLCD_Inst                     ;Send instruction to LCD  
75c1			; fLCD_Data                     ;Send data byte to LCD  
75c1			; fLCD_Pos                      ;Position cursor  
75c1			; fLCD_Str                      ;Display string  
75c1			; fLCD_Def                      ;Define custom character  
75c1			;  
75c1			; **********************************************************************  
75c1			;  
75c1			; Requires SCMonAPI.asm to also be included in the project  
75c1			;  
75c1			  
75c1			  
75c1			; **********************************************************************  
75c1			; **  Constants  
75c1			; **********************************************************************  
75c1			  
75c1			; Constants that must be defined externally  
75c1			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
75c1			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
75c1			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
75c1			;kLCDWidth: EQU 20             ;Width in characters  
75c1			  
75c1			; general line offsets in any frame buffer  
75c1			  
75c1			  
75c1			display_row_1: equ 0  
75c1			display_row_2: equ display_row_1+display_cols  
75c1			display_row_3: equ display_row_2 + display_cols  
75c1			display_row_4: equ display_row_3 + display_cols  
75c1			;display_row_4_eol:   
75c1			  
75c1			  
75c1			; Cursor position values for the start of each line  
75c1			  
75c1			; E  
75c1			kLCD_Line1: EQU 0x00   
75c1			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
75c1			; E1  
75c1			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
75c1			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
75c1			  
75c1			; Instructions to send as A register to fLCD_Inst  
75c1			kLCD_Clear: EQU 00000001b     ;LCD clear  
75c1			kLCD_Off:   EQU 00001000b     ;LCD off  
75c1			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
75c1			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
75c1			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
75c1			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
75c1			  
75c1			; Constants used by this code module  
75c1			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
75c1			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
75c1			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
75c1			  
75c1			  
75c1			  
75c1			; **********************************************************************  
75c1			; **  LCD support functions  
75c1			; **********************************************************************  
75c1			  
75c1			; Initialise alphanumeric LCD module  
75c1			; LCD control register codes:  
75c1			;   DL   0 = 4-bit mode        1 = 8-bit mode  
75c1			;   N    0 = 1-line mode       1 = 2-line mode  
75c1			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
75c1			;   D    0 = Display off       1 = Display on  
75c1			;   C    0 = Cursor off        1 = Cursor on  
75c1			;   B    0 = Blinking off      1 = Blinking on  
75c1			;   ID   0 = Decrement mode    1 = Increment mode  
75c1			;   SH   0 = Entire shift off  1 = Entire shift on  
75c1 3e 28		fLCD_Init:  LD   A, 40  
75c3 cd e8 76		            CALL LCDDelay       ;Delay 40ms after power up  
75c6			; For reliable reset set 8-bit mode - 3 times  
75c6 cd b8 76		            CALL WrFn8bit       ;Function = 8-bit mode  
75c9 cd b8 76		            CALL WrFn8bit       ;Function = 8-bit mode  
75cc cd b8 76		            CALL WrFn8bit       ;Function = 8-bit mode  
75cf			; Set 4-bit mode  
75cf cd b4 76		            CALL WrFn4bit       ;Function = 4-bit mode  
75d2 cd e6 76		            CALL LCDDelay1      ;Delay 37 us or more  
75d5			; Function set  
75d5 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
75d7 cd ea 75		            CALL fLCD_Inst      ;2 line, display on  
75da			; Display On/Off control  
75da 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
75dc cd ea 75		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
75df			; Display Clear  
75df 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
75e1 cd ea 75		            CALL fLCD_Inst      ;Clear display  
75e4			; Entry mode  
75e4 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
75e6 cd ea 75		            CALL fLCD_Inst      ;Increment mode, shift off  
75e9			; Display module now initialised  
75e9 c9			            RET  
75ea			; ok to here  
75ea			  
75ea			; Write instruction to LCD  
75ea			;   On entry: A = Instruction byte to be written  
75ea			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
75ea f5			fLCD_Inst:  PUSH AF  
75eb f5			            PUSH AF  
75ec cd fe 75		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
75ef f1			            POP  AF  
75f0 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
75f1 17			            RLA  
75f2 17			            RLA  
75f3 17			            RLA  
75f4 cd fe 75		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
75f7 3e 02		            LD   A, 2  
75f9 cd e8 76		            CALL LCDDelay       ;Delay 2 ms to complete   
75fc f1			            POP  AF  
75fd c9			            RET  
75fe			Wr4bits:   
75fe f5					push af  
75ff 3a ce fb				ld a, (display_lcde1e2)  
7602 fe 00				cp 0     ; e  
7604 20 10				jr nz, .wea2	  
7606 f1					pop af  
7607 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7609 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
760b cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
760d cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
760f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7611 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
7613 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7615 c9			            RET  
7616 f1			.wea2:		pop af  
7617 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7619 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
761b cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
761d cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
761f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7621 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7623 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7625 c9			            RET  
7626			  
7626			  
7626			; Write data to LCD  
7626			;   On entry: A = Data byte to be written  
7626			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7626 f5			fLCD_Data:  PUSH AF  
7627 f5			            PUSH AF  
7628 cd 3a 76		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
762b f1			            POP  AF  
762c 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
762d 17			            RLA  
762e 17			            RLA  
762f 17			            RLA  
7630 cd 3a 76		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7633 3e 96		            LD   A, 150  
7635 3d			Wait:      DEC  A              ;Wait a while to allow data   
7636 20 fd		            JR   NZ, Wait      ;  write to complete  
7638 f1			            POP  AF  
7639 c9			            RET  
763a			Wr4bitsa:     
763a f5					push af  
763b 3a ce fb				ld a, (display_lcde1e2)  
763e fe 00				cp 0     ; e1  
7640 20 16				jr nz, .we2	  
7642 f1					pop af  
7643 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7645 cb d7		            SET  kLCDBitRS, A  
7647 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7649 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
764b cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
764d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
764f cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7651 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7653 cb 97		            RES  kLCDBitRS, A  
7655 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7657 c9			            RET  
7658 f1			.we2:		pop af  
7659 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
765b cb d7		            SET  kLCDBitRS, A  
765d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
765f cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7661 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
7663 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7665 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
7667 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7669 cb 97		            RES  kLCDBitRS, A  
766b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
766d c9			            RET  
766e			  
766e			  
766e			; Position cursor to specified location  
766e			;   On entry: A = Cursor position  
766e			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
766e f5			fLCD_Pos:   PUSH AF  
766f					; at this point set the E1 or E2 flag depending on position  
766f			  
766f c5					push bc  
7670			;		push af  
7670 06 00				ld b, 0  
7672 4f					ld c, a  
7673 3e 4f				ld a, kLCD_Line3-1  
7675 b7			 		or a      ;clear carry flag  
7676 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
7677 38 04				jr c, .pe1  
7679			  
7679					; E selection  
7679 cb 80				res 0, b         ; bit 0 unset e  
767b			;		pop af    ; before line 3 so recover orig pos  
767b			;		ld c, a    ; save for poking back  
767b 18 06				jr .peset	          
767d			.pe1:          	; E2 selection  
767d cb c0				set 0, b         ; bit 0 set e1  
767f 79					ld a, c  
7680 de 4f				sbc a, kLCD_Line3-1  
7682 4f					ld c, a	         ; save caculated offset  
7683			;		pop af     ; bin this original value now we have calculated form  
7683			  
7683			.peset:		; set bit  
7683 78					ld a, b  
7684 32 ce fb				ld (display_lcde1e2), a 	  
7687 79					ld a, c  
7688 c1					pop bc  
7689			  
7689 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
768b cd ea 75		            CALL fLCD_Inst      ;Write instruction to LCD  
768e f1			            POP  AF  
768f c9			            RET  
7690			  
7690			  
7690			; Output text string to LCD  
7690			;   On entry: DE = Pointer to null terminated text string  
7690			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7690 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7691 b7			            OR   A              ;Null terminator?  
7692 c8			            RET  Z              ;Yes, so finished  
7693 cd 26 76		            CALL fLCD_Data      ;Write character to display  
7696 13			            INC  DE             ;Point to next character  
7697 18 f7		            JR   fLCD_Str       ;Repeat  
7699 c9					ret  
769a			  
769a			; Define custom character  
769a			;   On entry: A = Character number (0 to 7)  
769a			;             DE = Pointer to character bitmap data  
769a			;   On exit:  A = Next character number  
769a			;             DE = Next location following bitmap  
769a			;             BC HL IX IY I AF' BC' DE' HL' preserved  
769a			; Character is   
769a c5			fLCD_Def:   PUSH BC  
769b f5			            PUSH AF  
769c 07			            RLCA                ;Calculate location  
769d 07			            RLCA                ;  for bitmap data  
769e 07			            RLCA                ;  = 8 x CharacterNumber  
769f f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
76a1 cd ea 75		            CALL fLCD_Inst      ;Write instruction to LCD  
76a4 06 00		            LD   B, 0  
76a6 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
76a7 cd 26 76		            CALL fLCD_Data      ;Write byte to display  
76aa 13			            INC  DE             ;Point to next byte  
76ab 04			            INC  B              ;Count bytes  
76ac cb 58		            BIT  3, B           ;Finish all 8 bytes?  
76ae 28 f6		            JR   Z, Loop       ;No, so repeat  
76b0 f1			            POP  AF  
76b1 3c			            INC  A              ;Increment character number  
76b2 c1			            POP  BC  
76b3 c9			            RET  
76b4			  
76b4			  
76b4			; **********************************************************************  
76b4			; **  Private functions  
76b4			; **********************************************************************  
76b4			  
76b4			; Write function to LCD  
76b4			;   On entry: A = Function byte to be written  
76b4			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
76b4 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
76b6 18 02		            JR   WrFunc  
76b8 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
76ba f5			WrFunc:     PUSH AF  
76bb f5					push af  
76bc 3a ce fb				ld a, (display_lcde1e2)  
76bf fe 00				cp 0     ; e1  
76c1 20 0f				jr nz, .wfea2	  
76c3 f1					pop af  
76c4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76c6 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
76c8 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
76ca d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
76cc cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
76ce d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76d0 18 0d			jr .wfskip  
76d2 f1			.wfea2:		pop af  
76d3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76d5 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
76d7 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
76d9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
76db cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
76dd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76df 3e 05		.wfskip:            LD  A, 5  
76e1 cd e8 76		            CALL LCDDelay       ;Delay 5 ms to complete  
76e4 f1			            POP  AF  
76e5 c9			            RET  
76e6			  
76e6			  
76e6			; Delay in milliseconds  
76e6			;   On entry: A = Number of milliseconds delay  
76e6			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
76e6 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
76e8 d5			LCDDelay:   PUSH DE  
76e9 5f			            LD   E, A           ;Delay by 'A' ms  
76ea 16 00		            LD   D, 0  
76ec cd 7a 0c		            CALL aDelayInMS  
76ef d1			            POP  DE  
76f0 c9			            RET  
76f1			  
76f1			  
76f1			testlcd:  
76f1 3e 00			ld a, kLCD_Line1  
76f3 cd 6e 76			call fLCD_Pos  
76f6 06 28			ld b, 40  
76f8 11 26 77			ld de, .ttext1  
76fb cd b9 75			call write_len_string  
76fe			  
76fe 3e 28			ld a, kLCD_Line2  
7700 cd 6e 76			call fLCD_Pos  
7703 06 28			ld b, 40  
7705 11 4f 77			ld de, .ttext2  
7708 cd b9 75			call write_len_string  
770b 3e 50			ld a, kLCD_Line3  
770d cd 6e 76			call fLCD_Pos  
7710 06 28			ld b, 40  
7712 11 78 77			ld de, .ttext3  
7715 cd b9 75			call write_len_string  
7718 3e 78			ld a, kLCD_Line4  
771a cd 6e 76			call fLCD_Pos  
771d 06 28			ld b, 40  
771f 11 a1 77			ld de, .ttext4  
7722 cd b9 75			call write_len_string  
7725			  
7725 76				halt  
7726			  
7726			  
7726 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
774f .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
7778 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
77a1 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
77ca			   
77ca			  
77ca			  
77ca			; eof  
77ca			  
# End of file firmware_lcd_4x40.asm
77ca			;include "firmware_lcd_4x20.asm" 
77ca			include "firmware_key_5x10.asm" 
77ca			; 5 x 10 decade counter scanner  
77ca			  
77ca			  
77ca			; TODO do cursor shape change for shift keys  
77ca			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
77ca			  
77ca			  
77ca			; bit mask for each scan column and row for teing the matrix  
77ca			  
77ca			  
77ca			key_init:  
77ca			  
77ca			; SCMonAPI functions used  
77ca			  
77ca			; Alphanumeric LCD functions used  
77ca			; no need to specify specific functions for this module  
77ca			  
77ca			  
77ca 3e cf		            LD   A, 11001111b  
77cc d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
77ce			;            LD   A, 00000000b  
77ce 3e 1f		            LD   A, 00011111b  
77d0 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
77d2			  
77d2			  
77d2				; TODO Configure cursor shapes  
77d2			  
77d2				; Load cursor shapes   
77d2 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
77d4 11 e4 77		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
77d7 06 02		            LD   B, 2           ;Number of characters to define  
77d9 cd 9a 76		.DefLoop:   CALL fLCD_Def       ;Define custom character  
77dc 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
77de			  
77de 3e 01				ld a, 1  
77e0 32 c4 fb			ld (cursor_shape),a  
77e3 c9				ret  
77e4			  
77e4			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
77e4			; Up to 8 custom characters can be defined  
77e4			.cursor_shapes:      
77e4			;; Character 0x00 = Normal  
77e4 1f			            DB  11111b  
77e5 1f			            DB  11111b  
77e6 1f			            DB  11111b  
77e7 1f			            DB  11111b  
77e8 1f			            DB  11111b  
77e9 1f			            DB  11111b  
77ea 1f			            DB  11111b  
77eb 1f			            DB  11111b  
77ec			;; Character 0x01 = Modifier  
77ec 1f			            DB  11111b  
77ed 1b			            DB  11011b  
77ee 1b			            DB  11011b  
77ef 1b			            DB  11011b  
77f0 1b			            DB  11011b  
77f1 1f			            DB  11111b  
77f2 1b			            DB  11011b  
77f3 1f			            DB  11111b  
77f4			  
77f4			  
77f4			  
77f4			  
77f4			; Display custom character 0  
77f4			;            LD   A, kLCD_Line1+14  
77f4			;            CALL fLCD_Pos       ;Position cursor to location in A  
77f4			;            LD   A, 0  
77f4			;            CALL fLCD_Data      ;Write character in A at cursor  
77f4			  
77f4			; Display custom character 1  
77f4			;            LD   A, kLCD_Line2+14  
77f4			;            CALL fLCD_Pos      ;Position cursor to location in A  
77f4			;            LD   A, 1  
77f4			;            CALL fLCD_Data     ;Write character in A at cursor  
77f4			  
77f4			; keyboard scanning   
77f4			  
77f4			; character in from keyboard  
77f4			  
77f4			; mapping for the pcb layout  
77f4			  
77f4			.matrix_to_char:  
77f4 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
77ff .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
780a 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7815 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7820 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
782b			.matrix_to_shift:  
782b			  
782b .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7836 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7841 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
784c 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7857 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7862			  
7862			.matrix_to_symbolshift:  
7862			  
7862 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
786d .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7878 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
7883			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
7883 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
788e .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7899			  
7899			  
7899			  
7899			; mapping for a simple straight through breadboard layout  
7899			  
7899			;.matrix_to_char:  
7899			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7899			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7899			;		db "asdfghjkl",KEY_CR,0  
7899			;		db "qwertyuiop",0  
7899			;		 db "1234567890",0  
7899			;.matrix_to_shift:  
7899			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7899			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7899			;		db "ASDFGHJKL",KEY_CR,0  
7899			;		db "QWERTYUIOP",0  
7899			;		 db "!",'"',"#$%^&*()",0  
7899			;.matrix_to_symbolshift:  
7899			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7899			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7899			;		db "_?*fghjk=",KEY_CR,0  
7899			;		db "-/+*[]{}@#",0  
7899			;		 db "1234567890",0  
7899			  
7899			;.matrix_to_char: db "D#0*C987B654A321"  
7899			  
7899			  
7899				  
7899			  
7899			; add cin and cin_wait  
7899			  
7899 cd aa 78		cin_wait: 	call cin  
789c						if DEBUG_KEYCINWAIT  
789c							push af  
789c							  
789c							ld hl,key_repeat_ct  
789c							ld (hl),a  
789c							inc hl  
789c							call hexout  
789c							ld hl,key_repeat_ct+3  
789c							ld a,0  
789c							ld (hl),a  
789c			  
789c							    LD   A, kLCD_Line1+11  
789c							    CALL fLCD_Pos       ;Position cursor to location in A  
789c							    LD   DE, key_repeat_ct  
789c							    ;LD   DE, MsgHello  
789c							    CALL fLCD_Str       ;Display string pointed to by DE  
789c			  
789c			  
789c			  
789c							pop af  
789c						endif  
789c fe 00			cp 0  
789e 28 f9			jr z, cin_wait   ; block until key press  
78a0			  
78a0							if DEBUG_KEYCINWAIT  
78a0								push af  
78a0			  
78a0								ld a, 'A'	  
78a0								ld hl,key_repeat_ct  
78a0								ld (hl),a  
78a0								inc hl  
78a0								ld a,0  
78a0								ld (hl),a  
78a0			  
78a0								    LD   A, kLCD_Line2+11  
78a0								    CALL fLCD_Pos       ;Position cursor to location in A  
78a0								    LD   DE, key_repeat_ct  
78a0								    ;LD   DE, MsgHello  
78a0								    CALL fLCD_Str       ;Display string pointed to by DE  
78a0			  
78a0							call delay500ms  
78a0			  
78a0								pop af  
78a0							endif  
78a0 f5				push af   ; save key pressed  
78a1			  
78a1			.cin_wait1:	  
78a1							if DEBUG_KEYCINWAIT  
78a1								push af  
78a1			  
78a1								ld a, 'b'	  
78a1								ld hl,key_repeat_ct  
78a1								ld (hl),a  
78a1								inc hl  
78a1								ld a,0  
78a1								ld (hl),a  
78a1			  
78a1								    LD   A, kLCD_Line2+11  
78a1								    CALL fLCD_Pos       ;Position cursor to location in A  
78a1								    LD   DE, key_repeat_ct  
78a1								    ;LD   DE, MsgHello  
78a1								    CALL fLCD_Str       ;Display string pointed to by DE  
78a1			  
78a1			  
78a1							call delay500ms  
78a1			  
78a1								pop af  
78a1							endif  
78a1			  
78a1 cd aa 78		call cin  
78a4 fe 00			cp 0  
78a6 20 f9			jr nz, .cin_wait1  	; wait for key release  
78a8			if DEBUG_KEYCINWAIT  
78a8				push af  
78a8			  
78a8				ld a, '3'	  
78a8				ld hl,key_repeat_ct  
78a8				ld (hl),a  
78a8				inc hl  
78a8				ld a,0  
78a8				ld (hl),a  
78a8			  
78a8			            LD   A, kLCD_Line2+11  
78a8			            CALL fLCD_Pos       ;Position cursor to location in A  
78a8			            LD   DE, key_repeat_ct  
78a8			            ;LD   DE, MsgHello  
78a8			            CALL fLCD_Str       ;Display string pointed to by DE  
78a8			  
78a8			  
78a8			call delay500ms  
78a8			  
78a8				pop af  
78a8			endif  
78a8			  
78a8 f1				pop af   ; get key  
78a9 c9				ret  
78aa			  
78aa			  
78aa cd be 78		cin: 	call .mtoc  
78ad			  
78ad			if DEBUG_KEYCIN  
78ad				push af  
78ad				  
78ad				ld hl,key_repeat_ct  
78ad				ld (hl),a  
78ad				inc hl  
78ad				call hexout  
78ad				ld hl,key_repeat_ct+3  
78ad				ld a,0  
78ad				ld (hl),a  
78ad			  
78ad			            LD   A, kLCD_Line3+15  
78ad			            CALL fLCD_Pos       ;Position cursor to location in A  
78ad			            LD   DE, key_repeat_ct  
78ad			            ;LD   DE, MsgHello  
78ad			            CALL fLCD_Str       ;Display string pointed to by DE  
78ad			  
78ad			  
78ad			call delay500ms  
78ad			  
78ad				pop af  
78ad			endif  
78ad			  
78ad			  
78ad				; no key held  
78ad fe 00			cp 0  
78af c8				ret z  
78b0			  
78b0			if DEBUG_KEYCIN  
78b0				push af  
78b0			  
78b0				ld a, '1'	  
78b0				ld hl,key_repeat_ct  
78b0				ld (hl),a  
78b0				inc hl  
78b0				ld a,0  
78b0				ld (hl),a  
78b0			  
78b0			            LD   A, kLCD_Line4+15  
78b0			            CALL fLCD_Pos       ;Position cursor to location in A  
78b0			            LD   DE, key_repeat_ct  
78b0			            ;LD   DE, MsgHello  
78b0			            CALL fLCD_Str       ;Display string pointed to by DE  
78b0			  
78b0			  
78b0			call delay500ms  
78b0			  
78b0				pop af  
78b0			endif  
78b0			  
78b0				; stop key bounce  
78b0			  
78b0 32 88 fe			ld (key_held),a		 ; save it  
78b3 47				ld b, a  
78b4			  
78b4 c5			.cina1:	push bc  
78b5			if DEBUG_KEYCIN  
78b5				push af  
78b5			  
78b5				ld hl,key_repeat_ct  
78b5				inc hl  
78b5				call hexout  
78b5				ld hl,key_repeat_ct+3  
78b5				ld a,0  
78b5				ld (hl),a  
78b5				ld hl,key_repeat_ct  
78b5				ld a, '2'	  
78b5				ld (hl),a  
78b5			  
78b5			            LD   A, kLCD_Line4+15  
78b5			            CALL fLCD_Pos       ;Position cursor to location in A  
78b5			            LD   DE, key_repeat_ct  
78b5			            ;LD   DE, MsgHello  
78b5			            CALL fLCD_Str       ;Display string pointed to by DE  
78b5			  
78b5				pop af  
78b5			endif  
78b5 cd be 78			call .mtoc  
78b8 c1				pop bc  
78b9 b8				cp b  
78ba 28 f8			jr z, .cina1  
78bc 78				ld a,b		  
78bd			if DEBUG_KEYCIN  
78bd				push af  
78bd			  
78bd				ld hl,key_repeat_ct  
78bd				inc hl  
78bd				call hexout  
78bd				ld hl,key_repeat_ct+3  
78bd				ld a,0  
78bd				ld (hl),a  
78bd				ld hl,key_repeat_ct  
78bd				ld a, '3'	  
78bd				ld (hl),a  
78bd			  
78bd			            LD   A, kLCD_Line4+15  
78bd			            CALL fLCD_Pos       ;Position cursor to location in A  
78bd			            LD   DE, key_repeat_ct  
78bd			            ;LD   DE, MsgHello  
78bd			            CALL fLCD_Str       ;Display string pointed to by DE  
78bd			  
78bd				pop af  
78bd			endif  
78bd c9				ret  
78be			  
78be			; detect keyboard modifier key press and apply new overlay to the face key held  
78be			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
78be			  
78be			;.cin_map_modifier:   
78be			;	ld a, (hl)  
78be			;	and 255  
78be			;	ret NZ		; modifier key not flagged  
78be			;  
78be			;	; get key face  
78be			;  
78be			;	ld b,(key_face_held)  
78be			;  
78be			;	ld b, key_cols * key_rows  
78be			;  
78be			;	push de  
78be			;	pop hl  
78be			;  
78be			;.mmod1: ld a,(hl)   ; get map test  
78be			;	cp b  
78be			;	jr z, .mmod2  
78be			;  
78be			;  
78be			;  
78be			;.mmod2: inc hl    ;   
78be			;  
78be			;	  
78be			;  
78be			;	  
78be			;  
78be			;	ld hl,key_actual_pressed  
78be			;	ld (hl),a,  
78be			;	ret  
78be			  
78be			; map matrix key held to char on face of key  
78be			  
78be			.mtoc:  
78be			  
78be			; test decade counter strobes  
78be			  
78be			;.decadetest1:  
78be			  
78be			; reset counter  
78be			;ld a, 128  
78be			;out (portbdata),a  
78be			  
78be			  
78be			;ld b, 5  
78be			;.dec1:  
78be			;ld a, 0  
78be			;out (portbdata),a  
78be			;call delay1s  
78be			  
78be			;ld a, 32  
78be			;out (portbdata),a  
78be			;call delay1s  
78be			;call delay1s  
78be			;call delay1s  
78be			;  
78be			;ld a, 64+32  
78be			;out (portbdata),a  
78be			;call delay1s  
78be			;;djnz .dec1  
78be			;  
78be			;jp .decadetest1  
78be			  
78be			  
78be			  
78be			  
78be			  
78be			  
78be			  
78be			  
78be			  
78be			  
78be				; scan keyboard matrix and generate raw scan map  
78be cd 51 79			call matrix  
78c1			  
78c1				; reuse c bit 0 left modifer button - ie shift  
78c1			        ; reuse c bit 1 for right modifer button - ie symbol shift  
78c1				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
78c1			  
78c1 0e 00			ld c, 0  
78c3			  
78c3				; TODO set flags for modifer key presses   
78c3				; TODO do a search for modifer key...  
78c3			  
78c3				;ld hl,keyscan_table_row4  
78c3 21 e7 fe			ld hl,keyscan_table_row2  
78c6			  
78c6 7e				ld a, (hl)  
78c7 fe 23			cp '#'  
78c9 20 07			jr nz, .nextmodcheck  
78cb cb c1			set 0, c  
78cd 21 2b 78			ld hl, .matrix_to_shift  
78d0 18 21			jr .dokeymap  
78d2				; TODO for now igonre  
78d2			.nextmodcheck:  
78d2 21 dc fe			ld hl,keyscan_table_row3  
78d5			  
78d5 7e				ld a, (hl)  
78d6 fe 23			cp '#'  
78d8 20 07			jr nz, .nextmodcheck2  
78da cb c9			set 1, c   
78dc 21 62 78			ld hl, .matrix_to_symbolshift  
78df 18 12			jr .dokeymap  
78e1			.nextmodcheck2:  
78e1 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
78e4			  
78e4 7e				ld a, (hl)  
78e5 fe 23			cp '#'  
78e7 20 07			jr nz, .donemodcheck  
78e9 cb c9			set 1, c   
78eb 21 2b 78			ld hl, .matrix_to_shift  
78ee 18 03			jr .dokeymap  
78f0			  
78f0				; no modifer found so just map to normal keys  
78f0				; get mtoc map matrix to respective keys  
78f0			;	ld hl, .matrix_to_char  
78f0			;	ld hl, .matrix_to_char  
78f0			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
78f0			;	ld a, KEY_SHIFT  
78f0			;	call findchar  
78f0			;  
78f0			;	; got offset to key modifer in b  
78f0			;  
78f0			;	ld hl,keyscan_table_row5  
78f0			;  
78f0			;	ld a,b  
78f0			;	call addatohl  
78f0			;	ld a,(hl)  
78f0			;  
78f0			;	cp '#'  
78f0			;	jr nz, .nextmodcheck  
78f0			;	set 0, c  
78f0			;	ld hl, .matrix_to_char  
78f0			;	jr .dokeymap  
78f0			;	; TODO for now igonre  
78f0			;.nextmodcheck:  
78f0			;	ld hl, .matrix_to_symbolshift  
78f0			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
78f0			;	ld a, KEY_SYMBOLSHIFT  
78f0			;	call findchar  
78f0			;  
78f0			;  
78f0			;	; got offset to key modifer in b  
78f0			;  
78f0			;	ld hl,keyscan_table_row5  
78f0			;  
78f0			;	ld a,b  
78f0			;	call addatohl  
78f0			;	ld a,(hl)  
78f0			;  
78f0			;	cp '#'  
78f0			;	jr nz, .donemodcheck  
78f0			;	set 1, c   
78f0			;	ld hl, .matrix_to_symbolshift  
78f0			;	jr .dokeymap  
78f0			  
78f0			  
78f0			  
78f0			.donemodcheck:  
78f0				; no modifer found so just map to normal keys  
78f0				; get mtoc map matrix to respective keys  
78f0 21 f4 77			ld hl, .matrix_to_char  
78f3			  
78f3			.dokeymap:  
78f3				;ld (key_fa), c   
78f3 cd 0c 79			call .mapkeys  
78f6			  
78f6			  
78f6			if DEBUG_KEY  
78f6			  
78f6			; Display text on first line  
78f6			            LD   A, kLCD_Line1  
78f6			            CALL fLCD_Pos       ;Position cursor to location in A  
78f6			            LD   DE, keyscan_table_row1  
78f6			            ;LD   DE, MsgHello  
78f6			            CALL fLCD_Str       ;Display string pointed to by DE  
78f6			  
78f6			; Display text on second line  
78f6			            LD   A, kLCD_Line2  
78f6			            CALL fLCD_Pos       ;Position cursor to location in A  
78f6			            LD   DE, keyscan_table_row2  
78f6			            CALL fLCD_Str       ;Display string pointed to by DE  
78f6			            LD   A, kLCD_Line3  
78f6			            CALL fLCD_Pos       ;Position cursor to location in A  
78f6			            LD   DE, keyscan_table_row3  
78f6			            CALL fLCD_Str       ;Display string pointed to by DE  
78f6			            LD   A, kLCD_Line4  
78f6			            CALL fLCD_Pos       ;Position cursor to location in A  
78f6			            LD   DE, keyscan_table_row4  
78f6			            CALL fLCD_Str       ;Display string pointed to by DE  
78f6			            LD   A, kLCD_Line1+10  
78f6			            CALL fLCD_Pos       ;Position cursor to location in A  
78f6			            LD   DE, keyscan_table_row5  
78f6			            CALL fLCD_Str       ;Display string pointed to by DE  
78f6			  
78f6				;call delay250ms  
78f6			endif  
78f6			;	jp testkey  
78f6			  
78f6			; get first char reported  
78f6			  
78f6 21 c6 fe			ld hl,keyscan_table_row5  
78f9			  
78f9				;ld b, 46   ; 30 keys to remap + 8 nulls   
78f9 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
78fb			.findkey:  
78fb 7e				ld a,(hl)  
78fc fe 00			cp 0  
78fe 28 04			jr z, .nextkey  
7900 fe 7e			cp KEY_MATRIX_NO_PRESS  
7902 20 06			jr nz, .foundkey  
7904			.nextkey:  
7904 23				inc hl  
7905 10 f4			djnz .findkey  
7907 3e 00			ld a,0  
7909 c9				ret  
790a			.foundkey:  
790a 7e				ld a,(hl)  
790b c9				ret  
790c				  
790c			  
790c			; convert the raw key map given hl for destination key  
790c			.mapkeys:  
790c 11 c6 fe			ld de,keyscan_table_row5  
790f			  
790f 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7911			.remap:  
7911 1a				ld a,(de)  
7912 fe 23			cp '#'  
7914 20 02			jr nz, .remapnext  
7916				;CALLMONITOR  
7916 7e				ld a,(hl)  
7917 12				ld (de),a  
7918			  
7918			  
7918			  
7918			.remapnext:  
7918 23				inc hl  
7919 13				inc de  
791a 10 f5			djnz .remap  
791c				  
791c c9				ret  
791d			  
791d			  
791d			  
791d			.mtocold2:  
791d			  
791d			;	; flag if key D is held down and remove from reporting  
791d			;	ld bc, .key_map_fd    
791d			;	ld hl, keyscan_table  
791d			;	ld de, key_fd  
791d			;	call .key_shift_hold  
791d			;	cp 255  
791d			;	jr z, .cinmap  
791d			;	; flag if key C is held down and remove from reporting  
791d			;	ld bc, .key_map_fc    
791d			;	ld hl, keyscan_table+key_cols  
791d			;	ld de, key_fc  
791d			;	call .key_shift_hold  
791d			;	cp 255  
791d			;	jr z, .cinmap  
791d			;	; flag if key B is held down and remove from reporting  
791d			;	ld bc, .key_map_fb    
791d			;	ld hl, keyscan_table+(key_cols*2)  
791d			;	ld de, key_fb  
791d			;	call .key_shift_hold  
791d			;	cp 255  
791d			;	jr z, .cinmap  
791d			;	; flag if key A is held down and remove from reporting  
791d			;	ld bc, .key_map_fa    
791d			;	ld hl, keyscan_table+(key_cols*3)  
791d			;	ld de, key_fa  
791d			;	call .key_shift_hold  
791d			;	cp 255  
791d			;	jr z, .cinmap  
791d			  
791d 11 f4 77			ld de, .matrix_to_char  
7920			  
7920			  
7920			.cinmap1:   
7920				if DEBUG_KEY  
7920			            LD   A, kLCD_Line4  
7920			            CALL fLCD_Pos       ;Position cursor to location in A  
7920					push de  
7920			            LD   DE, keyscan_table  
7920			            CALL fLCD_Str       ;Display string pointed to by DE  
7920					pop de  
7920				endif  
7920			  
7920				; scan key matrix table for any held key  
7920			  
7920				; de holds either the default matrix or one selected above  
7920			  
7920 21 93 fe			ld hl, keyscan_table  
7923 06 32			ld b,key_cols*key_rows  
7925			  
7925 7e			.cin11:	ld a,(hl)  
7926 fe 23			cp '#'  
7928 28 08			jr z, .cinhit1  
792a 23				inc hl  
792b 13				inc de  
792c 05				dec b  
792d 20 f6			jr nz, .cin11  
792f				; no key found held  
792f 3e 00			ld a,0  
7931 c9				ret  
7932 d5			.cinhit1: push de  
7933 e1				pop hl  
7934 7e				ld a,(hl)  
7935 c9				ret  
7936			  
7936			; flag a control key is held   
7936			; hl is key pin, de is flag indicator  
7936			  
7936			.key_shift_hold1:  
7936 c5				push bc  
7937 3e 01			ld a, 1  
7939 32 c4 fb			ld (cursor_shape),a  
793c 06 00			ld b, 0  
793e 7e				ld a, (hl)  
793f fe 2e			cp '.'  
7941 28 0a			jr z, .key_shift11  
7943 06 ff			ld b, 255  
7945 3e 2b			ld a, '+'    ; hide key from later scans  
7947 77				ld (hl),a  
7948 3e 02			ld a, 2  
794a 32 c4 fb			ld (cursor_shape),a  
794d			.key_shift11:  
794d				; write flag indicator  
794d 78				ld a,b  
794e 12				ld (de),a  
794f			  
794f d1				pop de    ; de now holds the key map ptr  
7950 c9				ret  
7951			  
7951				  
7951			  
7951			; scans keyboard matrix and flags key press in memory array	  
7951				  
7951			matrix:  
7951				;call matrix  
7951				; TODO optimise the code....  
7951			  
7951			  
7951			;ld hl, keyscan_table_row1  
7951			;ld de, keyscan_table_row1+1  
7951			;ld bc,46  
7951			;ld a,KEY_MATRIX_NO_PRESS  
7951			;ldir  
7951			  
7951			  
7951			  
7951			; reset counter  
7951 3e 80		ld a, 128  
7953 d3 c1		out (portbdata),a  
7955			  
7955 06 0a		ld b, 10  
7957 0e 00		ld c, 0       ; current clock toggle  
7959			  
7959			.colscan:  
7959			  
7959			; set current column  
7959			; disable clock enable and set clock low  
7959			  
7959			;ld a, 0  
7959			;out (portbdata),a  
7959			  
7959			; For each column scan for switches  
7959			  
7959 c5			push bc  
795a 21 89 fe		ld hl, keyscan_scancol  
795d cd 66 7a		call .rowscan  
7960 c1			pop bc  
7961			  
7961			  
7961			; get back current column  
7961			  
7961			; translate the row scan  
7961			  
7961			;   
7961			; row 1  
7961			  
7961 78			ld a,b  
7962			  
7962 21 fc fe		LD   hl, keyscan_table_row1+10  
7965			  
7965 cd 98 0f		call subafromhl  
7968			;call addatohl  
7968			  
7968 11 89 fe		ld de, keyscan_scancol  
796b			  
796b 1a			ld a,(de)  
796c 77			ld (hl),a  
796d			  
796d			  
796d			  
796d			  
796d			; row 2  
796d			  
796d 78			ld a,b  
796e			  
796e 21 f1 fe		LD   hl, keyscan_table_row2+10  
7971			  
7971			;call addatohl  
7971 cd 98 0f		call subafromhl  
7974			  
7974			  
7974 11 8a fe		ld de, keyscan_scancol+1  
7977			  
7977 1a			ld a,(de)  
7978 77			ld (hl),a  
7979			  
7979			  
7979			; row 3  
7979			  
7979 78			ld a,b  
797a			  
797a 21 e6 fe		LD   hl, keyscan_table_row3+10  
797d			  
797d			;call addatohl  
797d cd 98 0f		call subafromhl  
7980			  
7980 11 8b fe		ld de, keyscan_scancol+2  
7983			  
7983 1a			ld a,(de)  
7984 77			ld (hl),a  
7985			  
7985			  
7985			  
7985			; row 4  
7985			  
7985 78			ld a,b  
7986			  
7986 21 db fe		LD   hl, keyscan_table_row4+10  
7989			  
7989			;call addatohl  
7989 cd 98 0f		call subafromhl  
798c			  
798c 11 8c fe		ld de, keyscan_scancol+3  
798f			  
798f 1a			ld a,(de)  
7990 77			ld (hl),a  
7991			  
7991			; row 5  
7991			  
7991 78			ld a,b  
7992			  
7992 21 d0 fe		LD   hl, keyscan_table_row5+10  
7995			  
7995			;call addatohl  
7995 cd 98 0f		call subafromhl  
7998			  
7998 11 8d fe		ld de, keyscan_scancol+4  
799b			  
799b 1a			ld a,(de)  
799c 77			ld (hl),a  
799d			  
799d			; handshake next column  
799d			  
799d			  
799d 3e 40		ld a, 64  
799f d3 c1		out (portbdata),a  
79a1			  
79a1 3e 00		ld a, 0  
79a3 d3 c1		out (portbdata),a  
79a5			  
79a5			; toggle clk and move to next column  
79a5			;ld a, 64  
79a5			;cp c  
79a5			;  
79a5			;jr z, .coltoglow  
79a5			;ld c, a  
79a5			;jr .coltog  
79a5			;.coltoglow:  
79a5			;ld c, 0  
79a5			;.coltog:  
79a5			;ld a, c  
79a5			;out (portbdata),a  
79a5			  
79a5 10 b2		djnz .colscan  
79a7			  
79a7 3e 0a		ld a,10  
79a9 21 f2 fe		LD   hl, keyscan_table_row1  
79ac cd 86 0f		call addatohl  
79af 3e 00		ld a, 0  
79b1 77			ld (hl), a  
79b2			  
79b2			  
79b2 3e 0a		ld a,10  
79b4 21 e7 fe		LD   hl, keyscan_table_row2  
79b7 cd 86 0f		call addatohl  
79ba 3e 00		ld a, 0  
79bc 77			ld (hl), a  
79bd			  
79bd 3e 0a		ld a,10  
79bf 21 dc fe		LD   hl, keyscan_table_row3  
79c2 cd 86 0f		call addatohl  
79c5 3e 00		ld a, 0  
79c7 77			ld (hl), a  
79c8			  
79c8 3e 0a		ld a,10  
79ca 21 d1 fe		LD   hl, keyscan_table_row4  
79cd cd 86 0f		call addatohl  
79d0 3e 00		ld a, 0  
79d2 77			ld (hl), a  
79d3			  
79d3 3e 0a		ld a,10  
79d5 21 c6 fe		LD   hl, keyscan_table_row5  
79d8 cd 86 0f		call addatohl  
79db 3e 00		ld a, 0  
79dd 77			ld (hl), a  
79de			  
79de			if DEBUG_KEY_MATRIX  
79de			  
79de			; Display text on first line  
79de			            LD   A, kLCD_Line1  
79de			            CALL fLCD_Pos       ;Position cursor to location in A  
79de			            LD   DE, keyscan_table_row1  
79de			            ;LD   DE, MsgHello  
79de			            CALL fLCD_Str       ;Display string pointed to by DE  
79de			  
79de			; Display text on second line  
79de			            LD   A, kLCD_Line2  
79de			            CALL fLCD_Pos       ;Position cursor to location in A  
79de			            LD   DE, keyscan_table_row2  
79de			            CALL fLCD_Str       ;Display string pointed to by DE  
79de			            LD   A, kLCD_Line3  
79de			            CALL fLCD_Pos       ;Position cursor to location in A  
79de			            LD   DE, keyscan_table_row3  
79de			            CALL fLCD_Str       ;Display string pointed to by DE  
79de			            LD   A, kLCD_Line4  
79de			            CALL fLCD_Pos       ;Position cursor to location in A  
79de			            LD   DE, keyscan_table_row4  
79de			            CALL fLCD_Str       ;Display string pointed to by DE  
79de			            LD   A, kLCD_Line4+10  
79de			            CALL fLCD_Pos       ;Position cursor to location in A  
79de			            LD   DE, keyscan_table_row5  
79de			            CALL fLCD_Str       ;Display string pointed to by DE  
79de			  
79de			;call delay250ms  
79de				jp matrix  
79de			endif  
79de c9			ret  
79df			  
79df			; using decade counter....  
79df			  
79df			  
79df			; TODO reset decade counter to start of scan  
79df			  
79df			; reset 15  
79df			; clock 14  
79df			; ce 13  
79df			  
79df			; 1 - q5  
79df			; 2 - q1  
79df			; 3 - q0  
79df			; 4 - q2  
79df			; 5 - q6  
79df			; 6 - q7  
79df			; 7 - q3  
79df			; 8 - vss  
79df			; 9 - q8  
79df			; 10 - q4  
79df			; 11 - q9  
79df			; 12 - cout  
79df			; 16 - vdd  
79df			  
79df			; clock      ce       reset     output  
79df			; 0          x        0         n  
79df			; x          1        0         n  
79df			; x          x        1         q0  
79df			; rising     0        0         n+1  
79df			; falling    x        0         n  
79df			; x          rising   0         n  
79df			; 1          falling  0         x+1  
79df			;  
79df			; x = dont care, if n < 5 carry = 1 otherwise 0  
79df			  
79df			;   
79df			; reset   
79df			; 13=0, 14=0, 15=1 .. 15=0  
79df			;  
79df			; handshake line  
79df			; 14=1.... read line 14=0  
79df			  
79df			  
79df			  
79df			  
79df			  
79df			; TODO hand shake clock for next column scan  
79df			; TODO detect each row  
79df			  
79df			  
79df			  
79df			  
79df			; reset 128  
79df			; clock 64  
79df			; ce 32  
79df			  
79df			  
79df			.cyclestart:  
79df			  
79df			; reset counter  
79df 3e 80		ld a, 128  
79e1 d3 c1		out (portbdata),a  
79e3			  
79e3			; loop leds  
79e3 06 0a		ld b,10  
79e5			  
79e5			.cycle1:  
79e5 c5			push bc  
79e6 3e 00		ld a, 0  
79e8 d3 c1		out (portbdata),a  
79ea cd 89 0c		call delay250ms  
79ed			  
79ed 3e 40		ld a, 64  
79ef d3 c1		out (portbdata),a  
79f1 cd 89 0c		call delay250ms  
79f4			  
79f4 3e 00		ld a, 0  
79f6 d3 c1		out (portbdata),a  
79f8 cd 89 0c		call delay250ms  
79fb			  
79fb c1			pop bc  
79fc 10 e7		djnz .cycle1  
79fe			  
79fe			  
79fe 18 df		jr .cyclestart  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			; map matrix key held to char on face of key  
7a00			  
7a00			;.mtocold:  
7a00			;  
7a00			;  
7a00			;; reset counter  
7a00			;ld a, 128  
7a00			;out (portbdata),a  
7a00			;  
7a00			;  
7a00			;; scan keyboard row 1  
7a00			;ld a, 0  
7a00			;out (portbdata),a  
7a00			;;ld a, 64  
7a00			;;out (portbdata),a  
7a00			;  
7a00			;  
7a00			;	ld a, 128  
7a00			;	ld hl, keyscan_table  
7a00			;	call .rowscan  
7a00			;  
7a00			;;ld a, 0  
7a00			;;out (portbdata),a  
7a00			;ld a, 64  
7a00			;out (portbdata),a  
7a00			;  
7a00			;	ld a, 64  
7a00			;	ld hl, keyscan_table+key_cols  
7a00			;	call .rowscan  
7a00			;  
7a00			;ld a, 0  
7a00			;out (portbdata),a  
7a00			;;ld a, 64  
7a00			;;out (portbdata),a  
7a00			;	ld a, 32  
7a00			;	ld hl, keyscan_table+(key_cols*2)  
7a00			;	call .rowscan  
7a00			;  
7a00			;  
7a00			;;ld a, 0  
7a00			;;out (portbdata),a  
7a00			;ld a, 64  
7a00			;out (portbdata),a  
7a00			;  
7a00			;	ld a, 16  
7a00			;	ld hl, keyscan_table+(key_cols*3)  
7a00			;	call .rowscan  
7a00			;  
7a00			;  
7a00			;	; flag if key D is held down and remove from reporting  
7a00			;	ld bc, .key_map_fd    
7a00			;	ld hl, keyscan_table  
7a00			;	ld de, key_fd  
7a00			;	call .key_shift_hold  
7a00			;	cp 255  
7a00			;	jr z, .cinmap  
7a00			;	; flag if key C is held down and remove from reporting  
7a00			;	ld bc, .key_map_fc    
7a00			;	ld hl, keyscan_table+key_cols  
7a00			;	ld de, key_fc  
7a00			;	call .key_shift_hold  
7a00			;	cp 255  
7a00			;	jr z, .cinmap  
7a00			;	; flag if key B is held down and remove from reporting  
7a00			;	ld bc, .key_map_fb    
7a00			;	ld hl, keyscan_table+(key_cols*2)  
7a00			;	ld de, key_fb  
7a00			;	call .key_shift_hold  
7a00			;	cp 255  
7a00			;	jr z, .cinmap  
7a00			;	; flag if key A is held down and remove from reporting  
7a00			;	ld bc, .key_map_fa    
7a00			;	ld hl, keyscan_table+(key_cols*3)  
7a00			;	ld de, key_fa  
7a00			;	call .key_shift_hold  
7a00			;	cp 255  
7a00			;	jr z, .cinmap  
7a00			;  
7a00			;	ld de, .matrix_to_char  
7a00			;  
7a00			;  
7a00			;.cinmap:   
7a00			;	if DEBUG_KEY  
7a00			;            LD   A, kLCD_Line4  
7a00			;            CALL fLCD_Pos       ;Position cursor to location in A  
7a00			;		push de  
7a00			;            LD   DE, keyscan_table  
7a00			;            CALL fLCD_Str       ;Display string pointed to by DE  
7a00			;		pop de  
7a00			;	endif  
7a00			  
7a00				; scan key matrix table for any held key  
7a00			  
7a00				; de holds either the default matrix or one selected above  
7a00			  
7a00			;	ld hl, keyscan_table  
7a00			;	ld b,key_cols*key_rows  
7a00			;  
7a00			;.cin1:	ld a,(hl)  
7a00			;	cp '#'  
7a00			;	jr z, .cinhit  
7a00			;	inc hl  
7a00			;	inc de  
7a00			;	dec b  
7a00			;	jr nz, .cin1  
7a00			;	; no key found held  
7a00			;	ld a,0  
7a00			;	ret  
7a00			;.cinhit: push de  
7a00			;	pop hl  
7a00			;	ld a,(hl)  
7a00			;	ret  
7a00			  
7a00			; flag a control key is held   
7a00			; hl is key pin, de is flag indicator  
7a00			  
7a00			;.key_shift_hold:  
7a00			;	push bc  
7a00			;	ld a, 1  
7a00			;	ld (cursor_shape),a  
7a00			;	ld b, 0  
7a00			;	ld a, (hl)  
7a00			;	cp '.'  
7a00			;	jr z, .key_shift1  
7a00			;	ld b, 255  
7a00			;	ld a, '+'    ; hide key from later scans  
7a00			;	ld (hl),a  
7a00			;	ld a, 2  
7a00			;	ld (cursor_shape),a  
7a00			;.key_shift1:  
7a00			;	; write flag indicator  
7a00			;	ld a,b  
7a00			;	ld (de),a  
7a00			;  
7a00			;	pop de    ; de now holds the key map ptr  
7a00			;	ret  
7a00			  
7a00				  
7a00				  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			;	push hl  
7a00			;	push de  
7a00			;	push bc  
7a00			;	call keyscan  
7a00			;	; map key matrix to ascii value of key face  
7a00			;  
7a00			;	ld hl, key_face_map  
7a00			;	ld de, keyscan_table  
7a00			;  
7a00			;	; get how many keys to look at  
7a00			;	ld b, keyscan_table_len  
7a00			;	  
7a00			;  
7a00			;	; at this stage fall out on first key hit  
7a00			;	; TODO handle multiple key press  
7a00			;  
7a00			;map1:	ld a,(hl)  
7a00			;	cp '#'  
7a00			;	jr z, keyhit  
7a00			;	inc hl  
7a00			;	inc de  
7a00			;	dec b  
7a00			;	jr nz, map1  
7a00			;nohit:	ld a, 0  
7a00			;	jr keydone  
7a00			;keyhit: push de  
7a00			;	pop hl  
7a00			;	ld a,(hl)  
7a00			;keydone:  
7a00			;	push bc  
7a00			;	push de  
7a00			; 	push hl  
7a00			;	ret   
7a00			;  
7a00			  
7a00			  
7a00			  
7a00			  
7a00			; scan physical key matrix  
7a00			  
7a00			  
7a00			;keyscan:  
7a00			;  
7a00			;; for each key_row use keyscanr bit mask for out  
7a00			;; then read in for keyscanc bitmask  
7a00			;; save result of row scan to keyscantable  
7a00			;  
7a00			;; scan keyboard row 1  
7a00			;  
7a00			;	ld b, key_rows  
7a00			;	ld hl, key_scanr  
7a00			;	ld de, keyscan_table  
7a00			;  
7a00			;rowloop:  
7a00			;  
7a00			;	ld a,(hl)		; out bit mask to energise keyboard row  
7a00			;	call rowscan  
7a00			;	inc hl  
7a00			;	dec b  
7a00			;	jr nz, rowloop  
7a00			;  
7a00			;	ret  
7a00			;  
7a00			;  
7a00			;; pass a out bitmask, b row number  
7a00			;arowscan:   
7a00			;	push bc  
7a00			;  
7a00			;	ld d, b  
7a00			;  
7a00			;	; calculate buffer location for this row  
7a00			;  
7a00			;	ld hl, keyscan_table	  
7a00			;kbufr:  ld e, key_cols  
7a00			;kbufc:	inc hl  
7a00			;	dec e  
7a00			;	jr nz, kbufc  
7a00			;	dec d  
7a00			;	jr nz, kbufr  
7a00			;  
7a00			;	; energise row and read columns  
7a00			;  
7a00			;	out (portbdata),a  
7a00			;	in a,(portbdata)  
7a00			;	ld c,a  
7a00			;  
7a00			;  
7a00			;	; save buffer loc  
7a00			;  
7a00			;	ld (keybufptr), hl  
7a00			;  
7a00			;	ld hl, key_scanc  
7a00			;	ld d, key_cols  
7a00			;  
7a00			;	; for each column check each bit mask  
7a00			;  
7a00			;colloop:  
7a00			;	  
7a00			;  
7a00			;	; reset flags for the row   
7a00			;  
7a00			;	ld b,'.'  
7a00			;	and (hl)  
7a00			;	jr z, maskskip  
7a00			;	ld b,'#'  
7a00			;maskskip:  
7a00			;	; save  key state  
7a00			;	push hl  
7a00			;	ld hl, (keybufptr)  
7a00			;	ld (hl), b  
7a00			;	inc hl  
7a00			;	ld (keybufptr), hl  
7a00			;  
7a00			;	; move to next bit mask  
7a00			;	pop hl  
7a00			;	inc hl  
7a00			;  
7a00			;	dec d  
7a00			;	jr nz, colloop  
7a00			;  
7a00			;	ret  
7a00			;  
7a00			;  
7a00			;;  
7a00			; lcd functions  
7a00			;  
7a00			;  
7a00			  
7a00			;if DEBUG_KEY_MATRIX  
7a00			  
7a00			; test function to display hardware view of matrix state  
7a00			  
7a00			matrixold:  
7a00			  
7a00			  
7a00			  
7a00			; reset counter  
7a00 3e 80		ld a, 128  
7a02 d3 c1		out (portbdata),a  
7a04			; scan keyboard row 1  
7a04 3e 00		ld a, 0  
7a06 d3 c1		out (portbdata),a  
7a08			;ld a, 64  
7a08			;out (portbdata),a  
7a08 3e 80			ld a, 128  
7a0a 21 f2 fe			ld hl, keyscan_table_row1  
7a0d cd 66 7a			call .rowscan  
7a10			  
7a10			;ld a, 0  
7a10			;out (portbdata),a  
7a10 3e 40		ld a, 64  
7a12 d3 c1		out (portbdata),a  
7a14 3e 40			ld a, 64  
7a16 21 e7 fe			ld hl, keyscan_table_row2  
7a19 cd 66 7a			call .rowscan  
7a1c			  
7a1c 3e 00		ld a, 0  
7a1e d3 c1		out (portbdata),a  
7a20			;ld a, 64  
7a20			;out (portbdata),a  
7a20 3e 20			ld a, 32  
7a22 21 dc fe			ld hl, keyscan_table_row3  
7a25 cd 66 7a			call .rowscan  
7a28			  
7a28			;ld a, 0  
7a28			;out (portbdata),a  
7a28 3e 40		ld a, 64  
7a2a d3 c1		out (portbdata),a  
7a2c 3e 10			ld a, 16  
7a2e 21 d1 fe			ld hl, keyscan_table_row4  
7a31 cd 66 7a			call .rowscan  
7a34			  
7a34			; Display text on first line  
7a34 3e 00		            LD   A, kLCD_Line1  
7a36 cd 6e 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a39 11 f2 fe		            LD   DE, keyscan_table_row1  
7a3c			            ;LD   DE, MsgHello  
7a3c cd 90 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a3f			  
7a3f			; Display text on second line  
7a3f 3e 28		            LD   A, kLCD_Line2  
7a41 cd 6e 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a44 11 e7 fe		            LD   DE, keyscan_table_row2  
7a47 cd 90 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a4a 3e 50		            LD   A, kLCD_Line3  
7a4c cd 6e 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a4f 11 dc fe		            LD   DE, keyscan_table_row3  
7a52 cd 90 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a55 3e 78		            LD   A, kLCD_Line4  
7a57 cd 6e 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a5a 11 d1 fe		            LD   DE, keyscan_table_row4  
7a5d cd 90 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a60			  
7a60 cd 89 0c			call delay250ms  
7a63 c3 51 79			jp matrix  
7a66			  
7a66			; pass de as row display flags  
7a66			.rowscan:   
7a66			;	out (portbdata),a  
7a66 db c1			in a,(portbdata)  
7a68 4f				ld c,a  
7a69				; reset flags for the row   
7a69 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a6b e6 01			and 1  
7a6d 28 02			jr z, .p1on  
7a6f 06 23			ld b,'#'  
7a71			.p1on:  
7a71 70				ld (hl), b  
7a72 23				inc hl  
7a73			  
7a73 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a75 79				ld a,c  
7a76 e6 02			and 2  
7a78			;	bit 0,a  
7a78 28 02			jr z, .p2on  
7a7a 06 23			ld b,'#'  
7a7c			.p2on:  
7a7c 70				ld (hl), b  
7a7d 23				inc hl  
7a7e			;  
7a7e 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a80 79				ld a,c  
7a81 e6 04			and 4  
7a83			;;	bit 0,a  
7a83 28 02			jr z, .p3on  
7a85 06 23			ld b,'#'  
7a87			.p3on:  
7a87 70				ld (hl), b  
7a88 23				inc hl  
7a89			;;  
7a89 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a8b			;;	bit 0,a  
7a8b 79				ld a,c  
7a8c e6 08			and 8  
7a8e 28 02			jr z, .p4on  
7a90 06 23			ld b,'#'  
7a92			.p4on:  
7a92 70				ld (hl), b  
7a93 23				inc hl  
7a94			  
7a94 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a96			;;	bit 0,a  
7a96 79				ld a,c  
7a97 e6 10			and 16  
7a99 28 02			jr z, .p5on  
7a9b 06 23			ld b,'#'  
7a9d			.p5on:  
7a9d 70				ld (hl), b  
7a9e 23				inc hl  
7a9f			; zero term  
7a9f 06 00			ld b,0  
7aa1 70				ld (hl), b  
7aa2			  
7aa2 c9			.rscandone: ret  
7aa3			  
7aa3			;addatohl:  
7aa3			;  
7aa3			 ;add   a, l    ; A = A+L  
7aa3			  ;  ld    l, a    ; L = A+L  
7aa3			   ; adc   a, h    ; A = A+L+H+carry  
7aa3			   ; sub   l       ; A = H+carry  
7aa3			   ; ld    h, a    ; H = H+carry  
7aa3			  
7aa3			;ret  
7aa3			; eof  
# End of file firmware_key_5x10.asm
7aa3			;include "firmware_key_4x10.asm" 
7aa3			 
7aa3			heap_size:    equ heap_end - heap_start 
7aa3			;eof 
# End of file os_mega.asm
7aa3
