# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 e4 15			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 1   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0103			  
0103			STORE_0_AUTOFILE: equ $21  
0103			STORE_0_BANKRUN: equ $23  
0103			STORE_0_FILERUN: equ $24  
0103			  
0103			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0103			  
0103			STORE_0_AUTORUN: equ $20  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diags   
0103			  
0103			hardware_diag: equ key_face_held - 1  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_diag - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			spi_device_id: equ spi_device - 1    ; human readable bank number  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ scratch-2  
0103			os_new_parse_len: equ os_new_malloc - 2  
0103			os_new_word_len: equ os_new_parse_len - 2  
0103			os_new_work_ptr: equ os_new_word_len - 2  
0103			os_new_src_ptr: equ os_new_work_ptr - 2  
0103			os_new_exec: equ os_new_src_ptr - 2  
0103			os_new_exec_ptr: equ os_new_exec - 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ os_new_exec_ptr - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103 3e 00				ld a, 0  
0105 32 80 ee				ld (hardware_diag), a  
0108			  
0108					; clear all the buffers  
0108			  
0108 21 1f ed				ld hl, display_fb1  
010b 22 db eb				ld (display_fb_active), hl  
010e			  
010e cd 85 09				call clear_display  
0111			  
0111 21 dd eb				ld hl, display_fb2  
0114 22 db eb				ld (display_fb_active), hl  
0117			  
0117 cd 85 09				call clear_display  
011a			  
011a					; init primary frame buffer area  
011a 21 c0 ed				ld hl, display_fb0  
011d 22 db eb				ld (display_fb_active), hl  
0120			  
0120 cd 85 09				call clear_display  
0123			  
0123			  
0123 cd d6 58				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0126			  
0126 cd c4 59			call key_init  
0129 cd b0 01			call storage_init  
012c			  
012c				; setup malloc functions  
012c			  
012c				if MALLOC_1  
012c cd 55 10				call  heap_init  
012f				endif  
012f				if MALLOC_4  
012f					call  heap_init  
012f				endif  
012f			  
012f				; init sound hardware if present  
012f			  
012f				if SOUND_ENABLE  
012f					call sound_init  
012f				endif  
012f			  
012f				; lcd test sequence  
012f					  
012f cd a8 09			call update_display  
0132 cd fa 08			call delay1s  
0135 3e 2b			ld a,'+'  
0137 cd 8a 09			call fill_display  
013a cd a8 09			call update_display  
013d cd fa 08			call delay1s  
0140 3e 2a			ld a,'*'  
0142 cd 8a 09			call fill_display  
0145 cd a8 09			call update_display  
0148 cd fa 08			call delay1s  
014b 3e 2d			ld a,'-'  
014d cd 8a 09			call fill_display  
0150 cd a8 09			call update_display  
0153 cd fa 08			call delay1s  
0156			  
0156			; boot splash screen  
0156			if display_cols == 20	  
0156			        ld a, display_row_1    
0156			else  
0156 3e 0a		        ld a, display_row_1 +10   
0158			endif  
0158 11 89 01			ld de, bootmsg  
015b cd 98 09			call str_at_display  
015e cd a8 09			call update_display  
0161			  
0161			  
0161 cd fa 08			call delay1s  
0164 cd fa 08			call delay1s  
0167			if display_cols == 20	  
0167			            LD   A, display_row_3+2  
0167			else  
0167 3e 5c		            LD   A, display_row_3+12  
0169			endif  
0169 11 9e 01			ld de, bootmsg1  
016c cd 98 09			call str_at_display  
016f cd a8 09			call update_display  
0172 cd fa 08			call delay1s  
0175 cd fa 08			call delay1s  
0178			  
0178			;	ld a, display_row_4+3  
0178			;	ld de, bootmsg2  
0178			;	call str_at_display  
0178			;	call update_display  
0178			;	call delay1s  
0178			;	call delay1s  
0178			  
0178			; debug mark setup  
0178			  
0178 3e 5f		ld a, '_'  
017a 32 7a ee		ld (debug_mark),a  
017d 32 7b ee		ld (debug_mark+1),a  
0180 32 7c ee		ld (debug_mark+2),a  
0183 3e 00		ld a,0  
0185 32 7d ee		ld (debug_mark+3),a  
0188			  
0188 c9					ret  
0189			  
0189			  
0189 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
019e .. 00		bootmsg1:	db "by Kevin Groves",0  
01ae			;bootmsg2:	db "Firmware v0.1",0  
01ae			  
01ae			; a 4x20 lcd  
01ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ae			  
01ae			;if display_cols == 20  
01ae			;	include "firmware_lcd_4x20.asm"  
01ae			;endif  
01ae			  
01ae			;if display_cols == 40  
01ae			;	include "firmware_lcd_4x40.asm"  
01ae			;endif  
01ae			  
01ae			;  
01ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ae			; TODO abstract the bit bang video out interface for dual display  
01ae			; TODO wire video out to tx pin on rc2014 bus  
01ae			  
01ae			; must supply cin, and cin_wait for low level hardware abstraction   
01ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ae			; test scancode  
01ae			  
01ae			;;;;;  
01ae			;;;  
01ae			; Moved out to mini and maxi versions  
01ae			;  
01ae			; include "firmware_key_4x4.asm"  
01ae			; using existing 4 wire x 4 resistor array for input  
01ae			;include "firmware_key_4x10.asm"  
01ae			; need to mod the board for 5 rows due to resistor array  
01ae			;include "firmware_key_5x10.asm"  
01ae			  
01ae			; storage hardware interface  
01ae			  
01ae			; use microchip serial eeprom for storage  
01ae			  
01ae			  
01ae			if STORAGE_SE  
01ae				include "firmware_spi.asm"  
01ae				include "firmware_seeprom.asm"  
01ae			else  
01ae			   ; create some stubs for the labels  
01ae c9			se_readbyte: ret  
01af c9			se_writebyte: ret  
01b0 c9			storage_init: ret  
01b1			  
01b1			endif  
01b1			  
01b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01b1			;include "firmware_cf.asm"  
01b1			  
01b1			; load up high level storage hardward abstractions  
01b1			include "firmware_storage.asm"  
01b1			 
01b1			; persisent storage hardware abstraction layer  
01b1			 
01b1			 
01b1			 
01b1			; Block 0 on storage is a config state 
01b1			 
01b1			 
01b1			 
01b1			; TODO add read phy block and write phy block functions 
01b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01b1			 
01b1			; Abstraction layer  
01b1			 
01b1			; Logocial block size is same size as physical size - using tape concept 
01b1			 
01b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01b1			 
01b1			 
01b1			 
01b1			; Filesystem layout (Logical layout) 
01b1			; 
01b1			; Block 0 - Bank config  
01b1			; 
01b1			;      Byte - 0 file id counter 
01b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01b1			;      Byte - 3-20 zero terminated bank label 
01b1			; 
01b1			; Block 1 > File storage 
01b1			; 
01b1			;      Byte 0 file id    - block 0 file details 
01b1			;      Byte 1 block id - block 0 is file  
01b1			;            Byte 2-15 - File name 
01b1			; 
01b1			;       - to end of block data 
01b1			; 
01b1			 
01b1			 
01b1			; Read Block 
01b1			; ---------- 
01b1			; 
01b1			; With current bank 
01b1			;  
01b1			; Get block number to read 
01b1			; Load physical blocks starting at start block into buffer 
01b1			 
01b1			; de points to buffer to use 
01b1			; hl holds logical block number  
01b1			 
01b1			storage_read_block: 
01b1			 
01b1				; TODO bank selection 
01b1			 
01b1				; for each of the physical blocks read it into the buffer 
01b1 06 40			ld b, STORE_BLOCK_PHY 
01b3			 
01b3				if DEBUG_STORESE 
01b3 d5					push de 
01b4				endif 
01b4				 
01b4			.rl1:    
01b4			 
01b4				; read physical block at hl into de 
01b4			        ; increment hl and de to next read position on exit 
01b4			 
01b4 e5				push hl 
01b5 d5				push de	 
01b6 c5				push bc 
01b7			;	if DEBUG_STORESE 
01b7			;		push af 
01b7			;		ld a, 'R' 
01b7			;		ld (debug_mark),a 
01b7			;		pop af 
01b7			;		CALLMONITOR 
01b7			;	endif 
01b7 cd ae 01			call se_readbyte 
01ba			;	if DEBUG_STORESE 
01ba			;		ld a,(spi_portbyte) 
01ba			;		ld l, a 
01ba			;		push af 
01ba			;		ld a, '1' 
01ba			;		ld (debug_mark),a 
01ba			;		pop af 
01ba			;		CALLMONITOR 
01ba			;	endif 
01ba c1				pop bc 
01bb d1				pop de 
01bc e1				pop hl 
01bd 12				ld (de),a 
01be 23				inc hl 
01bf 13				inc de 
01c0			 
01c0			;	if DEBUG_STORESE 
01c0			;		push af 
01c0			;		ld a, 'r' 
01c0			;		ld (debug_mark),a 
01c0			;		pop af 
01c0			;		CALLMONITOR 
01c0			;	endif 
01c0			 
01c0 10 f2			djnz .rl1 
01c2			 
01c2				if DEBUG_STORESE 
01c2					DMARK "SRB" 
01c2 f5				push af  
01c3 3a d7 01			ld a, (.dmark)  
01c6 32 7a ee			ld (debug_mark),a  
01c9 3a d8 01			ld a, (.dmark+1)  
01cc 32 7b ee			ld (debug_mark+1),a  
01cf 3a d9 01			ld a, (.dmark+2)  
01d2 32 7c ee			ld (debug_mark+2),a  
01d5 18 03			jr .pastdmark  
01d7 ..			.dmark: db "SRB"  
01da f1			.pastdmark: pop af  
01db			endm  
# End of macro DMARK
01db d1					pop de 
01dc			; 
01dc			;		push af 
01dc			;		ld a, 'R' 
01dc			;		ld (debug_mark),a 
01dc			;		pop af 
01dc					CALLMONITOR 
01dc cd 0e 14			call break_point_state  
01df				endm  
# End of macro CALLMONITOR
01df				endif 
01df c9				ret	 
01e0				 
01e0			 
01e0			; File Size 
01e0			; --------- 
01e0			; 
01e0			;   hl file id 
01e0			; 
01e0			;  returns in hl the number of blocks 
01e0			 
01e0			storage_file_size: 
01e0 5d				ld e, l 
01e1 16 00			ld d, 0 
01e3 21 40 00			ld hl, STORE_BLOCK_PHY 
01e6					if DEBUG_FORTH_WORDS 
01e6						DMARK "SIZ" 
01e6 f5				push af  
01e7 3a fb 01			ld a, (.dmark)  
01ea 32 7a ee			ld (debug_mark),a  
01ed 3a fc 01			ld a, (.dmark+1)  
01f0 32 7b ee			ld (debug_mark+1),a  
01f3 3a fd 01			ld a, (.dmark+2)  
01f6 32 7c ee			ld (debug_mark+2),a  
01f9 18 03			jr .pastdmark  
01fb ..			.dmark: db "SIZ"  
01fe f1			.pastdmark: pop af  
01ff			endm  
# End of macro DMARK
01ff						CALLMONITOR 
01ff cd 0e 14			call break_point_state  
0202				endm  
# End of macro CALLMONITOR
0202					endif 
0202 cd d2 04			call storage_findnextid 
0205			 
0205 cd db 0b			call ishlzero 
0208			;	ld a, l 
0208			;	add h 
0208			;	cp 0 
0208 c8				ret z			; block not found so EOF 
0209			 
0209 11 65 eb			ld de, store_page 
020c cd b1 01			call storage_read_block 
020f			 
020f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
0212 6f				ld l, a 
0213 26 00			ld h, 0 
0215 c9			 	ret 
0216			 
0216			 
0216			; Write Block 
0216			; ----------- 
0216			; 
0216			; With current bank 
0216			;  
0216			; Get block number to write 
0216			; Write physical blocks starting at start block from buffer 
0216			  
0216			storage_write_block: 
0216				; TODO bank selection 
0216			 
0216				; for each of the physical blocks read it into the buffer 
0216 06 40			ld b, STORE_BLOCK_PHY 
0218			 
0218				if DEBUG_STORESE 
0218					DMARK "SWB" 
0218 f5				push af  
0219 3a 2d 02			ld a, (.dmark)  
021c 32 7a ee			ld (debug_mark),a  
021f 3a 2e 02			ld a, (.dmark+1)  
0222 32 7b ee			ld (debug_mark+1),a  
0225 3a 2f 02			ld a, (.dmark+2)  
0228 32 7c ee			ld (debug_mark+2),a  
022b 18 03			jr .pastdmark  
022d ..			.dmark: db "SWB"  
0230 f1			.pastdmark: pop af  
0231			endm  
# End of macro DMARK
0231			 
0231					;push af 
0231					;ld a, 'W' 
0231					;ld (debug_mark),a 
0231					;pop af 
0231					CALLMONITOR 
0231 cd 0e 14			call break_point_state  
0234				endm  
# End of macro CALLMONITOR
0234				endif 
0234			 
0234			; might not be working 
0234			;	call se_writepage 
0234			 
0234			;	ret 
0234			; 
0234			 
0234			 
0234			 
0234			.wl1:    
0234			 
0234				; read physical block at hl into de 
0234			        ; increment hl and de to next read position on exit 
0234			 
0234 e5				push hl 
0235 d5				push de	 
0236 c5				push bc 
0237 1a				ld a,(de) 
0238				;if DEBUG_STORESE 
0238			;		push af 
0238			;		ld a, 'W' 
0238			;		ld (debug_mark),a 
0238			;		pop af 
0238			;		CALLMONITOR 
0238			;	endif 
0238 cd af 01			call se_writebyte 
023b			;	call delay250ms 
023b 00				nop 
023c 00				nop 
023d 00				nop 
023e			;	if DEBUG_STORESE 
023e			;		push af 
023e			;		ld a, 'w' 
023e			;		ld (debug_mark),a 
023e			;		pop af 
023e			;		CALLMONITOR 
023e			;	endif 
023e c1				pop bc 
023f d1				pop de 
0240 e1				pop hl 
0241 23				inc hl 
0242 13				inc de 
0243			 
0243			 
0243 10 ef			djnz .wl1 
0245			 
0245				if DEBUG_STORESE 
0245					DMARK "SW2" 
0245 f5				push af  
0246 3a 5a 02			ld a, (.dmark)  
0249 32 7a ee			ld (debug_mark),a  
024c 3a 5b 02			ld a, (.dmark+1)  
024f 32 7b ee			ld (debug_mark+1),a  
0252 3a 5c 02			ld a, (.dmark+2)  
0255 32 7c ee			ld (debug_mark+2),a  
0258 18 03			jr .pastdmark  
025a ..			.dmark: db "SW2"  
025d f1			.pastdmark: pop af  
025e			endm  
# End of macro DMARK
025e			 
025e					;push af 
025e					;ld a, 'W' 
025e					;ld (debug_mark),a 
025e					;pop af 
025e					CALLMONITOR 
025e cd 0e 14			call break_point_state  
0261				endm  
# End of macro CALLMONITOR
0261				endif 
0261 c9				ret	 
0262			 
0262			; Init bank 
0262			; --------- 
0262			; 
0262			; With current bank 
0262			; 
0262			; Setup block 0 config 
0262			;     Set 0 file id counter 
0262			;     Set formatted byte pattern 
0262			;     Zero out bank label 
0262			;      
0262			; For every logical block write 0-1 byte as null 
0262			 
0262			storage_get_block_0: 
0262			 
0262				; TODO check presence 
0262			 
0262				; get block 0 config 
0262			 
0262 21 00 00			ld hl, 0 
0265 11 65 eb			ld de, store_page 
0268 cd b1 01			call storage_read_block 
026b			 
026b				if DEBUG_STORESE 
026b					DMARK "SB0" 
026b f5				push af  
026c 3a 80 02			ld a, (.dmark)  
026f 32 7a ee			ld (debug_mark),a  
0272 3a 81 02			ld a, (.dmark+1)  
0275 32 7b ee			ld (debug_mark+1),a  
0278 3a 82 02			ld a, (.dmark+2)  
027b 32 7c ee			ld (debug_mark+2),a  
027e 18 03			jr .pastdmark  
0280 ..			.dmark: db "SB0"  
0283 f1			.pastdmark: pop af  
0284			endm  
# End of macro DMARK
0284 11 65 eb				ld de, store_page 
0287			;		push af 
0287			;		ld a, 'i' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287					CALLMONITOR 
0287 cd 0e 14			call break_point_state  
028a				endm  
# End of macro CALLMONITOR
028a				endif 
028a			 
028a				; is this area formatted? 
028a			 
028a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
028a 2a 66 eb			ld hl, (store_page+1) 
028d 3e 80			ld a,0x80 
028f bd				cp l 
0290 20 22			jr nz, .ininotformatted 
0292				; do a double check 
0292 3e 27			ld a, 0x27 
0294 bc				cp h 
0295 20 1d			jr nz, .ininotformatted 
0297			 
0297				; formatted then 
0297			 
0297				if DEBUG_STORESE 
0297					DMARK "SB1" 
0297 f5				push af  
0298 3a ac 02			ld a, (.dmark)  
029b 32 7a ee			ld (debug_mark),a  
029e 3a ad 02			ld a, (.dmark+1)  
02a1 32 7b ee			ld (debug_mark+1),a  
02a4 3a ae 02			ld a, (.dmark+2)  
02a7 32 7c ee			ld (debug_mark+2),a  
02aa 18 03			jr .pastdmark  
02ac ..			.dmark: db "SB1"  
02af f1			.pastdmark: pop af  
02b0			endm  
# End of macro DMARK
02b0					;push af 
02b0					;ld a, 'I' 
02b0					;ld (debug_mark),a 
02b0					;pop af 
02b0					CALLMONITOR 
02b0 cd 0e 14			call break_point_state  
02b3				endm  
# End of macro CALLMONITOR
02b3				endif 
02b3 c9				ret 
02b4			 
02b4			.ininotformatted: 
02b4				; bank not formatted so poke various bits to make sure 
02b4			 
02b4				if DEBUG_STORESE 
02b4					DMARK "SB2" 
02b4 f5				push af  
02b5 3a c9 02			ld a, (.dmark)  
02b8 32 7a ee			ld (debug_mark),a  
02bb 3a ca 02			ld a, (.dmark+1)  
02be 32 7b ee			ld (debug_mark+1),a  
02c1 3a cb 02			ld a, (.dmark+2)  
02c4 32 7c ee			ld (debug_mark+2),a  
02c7 18 03			jr .pastdmark  
02c9 ..			.dmark: db "SB2"  
02cc f1			.pastdmark: pop af  
02cd			endm  
# End of macro DMARK
02cd					;push af 
02cd					;ld a, 'f' 
02cd					;ld (debug_mark),a 
02cd					;pop af 
02cd					CALLMONITOR 
02cd cd 0e 14			call break_point_state  
02d0				endm  
# End of macro CALLMONITOR
02d0				endif 
02d0			 
02d0 cd bd 08			call storage_clear_page 
02d3			 
02d3 21 65 eb			ld hl, store_page 
02d6 3e 00			ld a, 0 
02d8				 
02d8 77				ld (hl),a   ; reset file counter 
02d9			 
02d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02dc 22 66 eb		 	ld (store_page+1), hl	 
02df			 
02df				; set default label 
02df			 
02df 21 7b 03			ld hl, .defaultbanklabl 
02e2 11 68 eb		 	ld de, store_page+3 
02e5 01 0f 00			ld bc, 15 
02e8 ed b0			ldir 
02ea			 
02ea				; Append the current bank id 
02ea 21 71 eb			ld hl, store_page+3+9 
02ed 3a 4a eb			ld a, (spi_device_id) 
02f0 77				ld (hl), a 
02f1			 
02f1				; save default page 0 
02f1			 
02f1 21 00 00			ld hl, 0 
02f4 11 65 eb			ld de, store_page 
02f7				if DEBUG_STORESE 
02f7					DMARK "SB3" 
02f7 f5				push af  
02f8 3a 0c 03			ld a, (.dmark)  
02fb 32 7a ee			ld (debug_mark),a  
02fe 3a 0d 03			ld a, (.dmark+1)  
0301 32 7b ee			ld (debug_mark+1),a  
0304 3a 0e 03			ld a, (.dmark+2)  
0307 32 7c ee			ld (debug_mark+2),a  
030a 18 03			jr .pastdmark  
030c ..			.dmark: db "SB3"  
030f f1			.pastdmark: pop af  
0310			endm  
# End of macro DMARK
0310			;		push af 
0310			;		ld a, 'F' 
0310			;		ld (debug_mark),a 
0310			;		pop af 
0310					CALLMONITOR 
0310 cd 0e 14			call break_point_state  
0313				endm  
# End of macro CALLMONITOR
0313				endif 
0313 cd 16 02			call storage_write_block 
0316				if DEBUG_STORESE 
0316					DMARK "SB4" 
0316 f5				push af  
0317 3a 2b 03			ld a, (.dmark)  
031a 32 7a ee			ld (debug_mark),a  
031d 3a 2c 03			ld a, (.dmark+1)  
0320 32 7b ee			ld (debug_mark+1),a  
0323 3a 2d 03			ld a, (.dmark+2)  
0326 32 7c ee			ld (debug_mark+2),a  
0329 18 03			jr .pastdmark  
032b ..			.dmark: db "SB4"  
032e f1			.pastdmark: pop af  
032f			endm  
# End of macro DMARK
032f			;		push af 
032f			;		ld a, '>' 
032f			;		ld (debug_mark),a 
032f			;		pop af 
032f					CALLMONITOR 
032f cd 0e 14			call break_point_state  
0332				endm  
# End of macro CALLMONITOR
0332				endif 
0332			 
0332 00				nop 
0333 00				nop 
0334 00				nop 
0335			 
0335				; now set 0 in every page to mark as a free block 
0335			 
0335 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0337 21 40 00			ld hl, STORE_BLOCK_PHY 
033a			 
033a 3e 00		.setmark1:   	ld a,0 
033c e5					push hl 
033d c5					push bc 
033e cd af 01				call se_writebyte 
0341 3e 0a			ld a, 10 
0343 cd df 08			call aDelayInMS 
0346 23				inc hl 
0347 cd af 01				call se_writebyte 
034a 3e 0a			ld a, 10 
034c cd df 08			call aDelayInMS 
034f 2b				dec hl 
0350 c1					pop bc 
0351 e1					pop hl 
0352 3e 40				ld a, STORE_BLOCK_PHY 
0354 cd b2 0b				call addatohl 
0357 10 e1				djnz .setmark1 
0359			 
0359 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
035b 3e 00		.setmark2:   	ld a,0 
035d e5					push hl 
035e c5					push bc 
035f cd af 01				call se_writebyte 
0362 3e 0a			ld a, 10 
0364 cd df 08			call aDelayInMS 
0367 23				inc hl 
0368 cd af 01				call se_writebyte 
036b 3e 0a			ld a, 10 
036d cd df 08			call aDelayInMS 
0370 2b				dec hl 
0371 c1					pop bc 
0372 e1					pop hl 
0373 3e 40				ld a, STORE_BLOCK_PHY 
0375 cd b2 0b				call addatohl 
0378 10 e1				djnz .setmark2 
037a			 
037a					 
037a			 
037a			 
037a c9				ret 
037b			 
037b			 
037b			 
037b			 
037b .. 00		.defaultbanklabl:   db "BankLabel_",0 
0386			 
0386			 
0386			 
0386			; Label Bank 
0386			; ---------- 
0386			; 
0386			; With current bank 
0386			; Read block 0 
0386			; Set label 
0386			; Write block 0 
0386			 
0386			; label str pointer in hl 
0386			 
0386			storage_label:     
0386			 
0386				if DEBUG_STORESE 
0386					DMARK "LBL" 
0386 f5				push af  
0387 3a 9b 03			ld a, (.dmark)  
038a 32 7a ee			ld (debug_mark),a  
038d 3a 9c 03			ld a, (.dmark+1)  
0390 32 7b ee			ld (debug_mark+1),a  
0393 3a 9d 03			ld a, (.dmark+2)  
0396 32 7c ee			ld (debug_mark+2),a  
0399 18 03			jr .pastdmark  
039b ..			.dmark: db "LBL"  
039e f1			.pastdmark: pop af  
039f			endm  
# End of macro DMARK
039f					CALLMONITOR 
039f cd 0e 14			call break_point_state  
03a2				endm  
# End of macro CALLMONITOR
03a2				endif 
03a2			 
03a2 e5				push hl 
03a3			 
03a3 cd 62 02			call storage_get_block_0 
03a6			 
03a6				; set default label 
03a6			 
03a6 e1				pop hl 
03a7			 
03a7 11 68 eb		 	ld de, store_page+3 
03aa 01 0f 00			ld bc, 15 
03ad				if DEBUG_STORESE 
03ad					DMARK "LB3" 
03ad f5				push af  
03ae 3a c2 03			ld a, (.dmark)  
03b1 32 7a ee			ld (debug_mark),a  
03b4 3a c3 03			ld a, (.dmark+1)  
03b7 32 7b ee			ld (debug_mark+1),a  
03ba 3a c4 03			ld a, (.dmark+2)  
03bd 32 7c ee			ld (debug_mark+2),a  
03c0 18 03			jr .pastdmark  
03c2 ..			.dmark: db "LB3"  
03c5 f1			.pastdmark: pop af  
03c6			endm  
# End of macro DMARK
03c6					CALLMONITOR 
03c6 cd 0e 14			call break_point_state  
03c9				endm  
# End of macro CALLMONITOR
03c9				endif 
03c9 ed b0			ldir 
03cb				; save default page 0 
03cb			 
03cb 21 00 00			ld hl, 0 
03ce 11 65 eb			ld de, store_page 
03d1				if DEBUG_STORESE 
03d1					DMARK "LBW" 
03d1 f5				push af  
03d2 3a e6 03			ld a, (.dmark)  
03d5 32 7a ee			ld (debug_mark),a  
03d8 3a e7 03			ld a, (.dmark+1)  
03db 32 7b ee			ld (debug_mark+1),a  
03de 3a e8 03			ld a, (.dmark+2)  
03e1 32 7c ee			ld (debug_mark+2),a  
03e4 18 03			jr .pastdmark  
03e6 ..			.dmark: db "LBW"  
03e9 f1			.pastdmark: pop af  
03ea			endm  
# End of macro DMARK
03ea					CALLMONITOR 
03ea cd 0e 14			call break_point_state  
03ed				endm  
# End of macro CALLMONITOR
03ed				endif 
03ed cd 16 02			call storage_write_block 
03f0			 
03f0 c9				ret 
03f1			 
03f1			 
03f1			 
03f1			; Read Block 0 - Config 
03f1			; --------------------- 
03f1			; 
03f1			; With current bank 
03f1			; Call presence test 
03f1			;    If not present format/init bank  
03f1			; Read block 0  
03f1			;  
03f1			 
03f1			 
03f1			; Dir 
03f1			; --- 
03f1			; 
03f1			; With current bank 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block read byte 2 
03f1			;      if first block of file 
03f1			;         Display file name 
03f1			;         Display type flags for file 
03f1			;        
03f1			 
03f1			; moving to words as this requires stack control 
03f1			 
03f1			 
03f1			; Delete File 
03f1			; ----------- 
03f1			; 
03f1			; With current bank 
03f1			; 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block file id 
03f1			;      If first block of file and dont have file id 
03f1			;         if file to delete 
03f1			;         Save file id 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			;      If file id is one saved 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			 
03f1			storage_erase: 
03f1			 
03f1				; hl contains the file id 
03f1			 
03f1 5d				ld e, l 
03f2 16 00			ld d, 0 
03f4 21 40 00			ld hl, STORE_BLOCK_PHY 
03f7					if DEBUG_FORTH_WORDS 
03f7						DMARK "ERA" 
03f7 f5				push af  
03f8 3a 0c 04			ld a, (.dmark)  
03fb 32 7a ee			ld (debug_mark),a  
03fe 3a 0d 04			ld a, (.dmark+1)  
0401 32 7b ee			ld (debug_mark+1),a  
0404 3a 0e 04			ld a, (.dmark+2)  
0407 32 7c ee			ld (debug_mark+2),a  
040a 18 03			jr .pastdmark  
040c ..			.dmark: db "ERA"  
040f f1			.pastdmark: pop af  
0410			endm  
# End of macro DMARK
0410						CALLMONITOR 
0410 cd 0e 14			call break_point_state  
0413				endm  
# End of macro CALLMONITOR
0413					endif 
0413 cd d2 04			call storage_findnextid 
0416			 
0416 e5				push hl 
0417			 
0417				; TODO check file not found 
0417			 
0417 11 65 eb			ld de, store_page 
041a cd b1 01			call storage_read_block 
041d			 
041d					if DEBUG_FORTH_WORDS 
041d						DMARK "ER1" 
041d f5				push af  
041e 3a 32 04			ld a, (.dmark)  
0421 32 7a ee			ld (debug_mark),a  
0424 3a 33 04			ld a, (.dmark+1)  
0427 32 7b ee			ld (debug_mark+1),a  
042a 3a 34 04			ld a, (.dmark+2)  
042d 32 7c ee			ld (debug_mark+2),a  
0430 18 03			jr .pastdmark  
0432 ..			.dmark: db "ER1"  
0435 f1			.pastdmark: pop af  
0436			endm  
# End of macro DMARK
0436						CALLMONITOR 
0436 cd 0e 14			call break_point_state  
0439				endm  
# End of macro CALLMONITOR
0439					endif 
0439 3a 65 eb			ld a, (store_page)	; get file id 
043c 32 5e eb			ld (store_tmpid), a 
043f			 
043f 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
0442 32 5d eb			ld (store_tmpext), a 
0445			 
0445				; wipe file header 
0445			 
0445 e1				pop hl 
0446 3e 00			ld a, 0 
0448 32 65 eb			ld (store_page), a 
044b 32 66 eb			ld (store_page+1),a 
044e 11 65 eb			ld de, store_page 
0451					if DEBUG_FORTH_WORDS 
0451						DMARK "ER2" 
0451 f5				push af  
0452 3a 66 04			ld a, (.dmark)  
0455 32 7a ee			ld (debug_mark),a  
0458 3a 67 04			ld a, (.dmark+1)  
045b 32 7b ee			ld (debug_mark+1),a  
045e 3a 68 04			ld a, (.dmark+2)  
0461 32 7c ee			ld (debug_mark+2),a  
0464 18 03			jr .pastdmark  
0466 ..			.dmark: db "ER2"  
0469 f1			.pastdmark: pop af  
046a			endm  
# End of macro DMARK
046a						CALLMONITOR 
046a cd 0e 14			call break_point_state  
046d				endm  
# End of macro CALLMONITOR
046d					endif 
046d cd 16 02			call storage_write_block 
0470			 
0470			 
0470				; wipe file extents 
0470			 
0470 3a 5d eb			ld a, (store_tmpext) 
0473 47				ld b, a 
0474			 
0474			.eraext:	  
0474 c5				push bc 
0475			 
0475 21 40 00			ld hl, STORE_BLOCK_PHY 
0478 3a 5e eb			ld a,(store_tmpid) 
047b 5f				ld e, a 
047c 50				ld d, b	 
047d					if DEBUG_FORTH_WORDS 
047d						DMARK "ER3" 
047d f5				push af  
047e 3a 92 04			ld a, (.dmark)  
0481 32 7a ee			ld (debug_mark),a  
0484 3a 93 04			ld a, (.dmark+1)  
0487 32 7b ee			ld (debug_mark+1),a  
048a 3a 94 04			ld a, (.dmark+2)  
048d 32 7c ee			ld (debug_mark+2),a  
0490 18 03			jr .pastdmark  
0492 ..			.dmark: db "ER3"  
0495 f1			.pastdmark: pop af  
0496			endm  
# End of macro DMARK
0496						CALLMONITOR 
0496 cd 0e 14			call break_point_state  
0499				endm  
# End of macro CALLMONITOR
0499					endif 
0499 cd d2 04			call storage_findnextid 
049c			 
049c e5				push hl 
049d 11 65 eb			ld de, store_page 
04a0 cd b1 01			call storage_read_block 
04a3			 
04a3				; free block	 
04a3			 
04a3 3e 00			ld a, 0 
04a5 32 65 eb			ld (store_page), a 
04a8 32 66 eb			ld (store_page+1),a 
04ab 11 65 eb			ld de, store_page 
04ae e1				pop hl 
04af					if DEBUG_FORTH_WORDS 
04af						DMARK "ER4" 
04af f5				push af  
04b0 3a c4 04			ld a, (.dmark)  
04b3 32 7a ee			ld (debug_mark),a  
04b6 3a c5 04			ld a, (.dmark+1)  
04b9 32 7b ee			ld (debug_mark+1),a  
04bc 3a c6 04			ld a, (.dmark+2)  
04bf 32 7c ee			ld (debug_mark+2),a  
04c2 18 03			jr .pastdmark  
04c4 ..			.dmark: db "ER4"  
04c7 f1			.pastdmark: pop af  
04c8			endm  
# End of macro DMARK
04c8						CALLMONITOR 
04c8 cd 0e 14			call break_point_state  
04cb				endm  
# End of macro CALLMONITOR
04cb					endif 
04cb cd 16 02			call storage_write_block 
04ce			 
04ce c1				pop bc 
04cf 10 a3			djnz .eraext 
04d1			 
04d1 c9				ret 
04d2			 
04d2			 
04d2			; Find Free Block 
04d2			; --------------- 
04d2			; 
04d2			; With current bank 
04d2			;  
04d2			; From given starting logical block 
04d2			;    Read block  
04d2			;    If no file id 
04d2			;         Return block id 
04d2			 
04d2			 
04d2			; hl starting page number 
04d2			; hl contains free page number or zero if no pages free 
04d2			; e contains the file id to locate 
04d2			; d contains the block number 
04d2			 
04d2			; TODO change to find file id and use zero for free block 
04d2			 
04d2			storage_findnextid: 
04d2			 
04d2				; now locate first 0 page to mark as a free block 
04d2			 
04d2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04d4			;	ld hl, STORE_BLOCK_PHY 
04d4			 
04d4					if DEBUG_FORTH_WORDS 
04d4					DMARK "FNI" 
04d4 f5				push af  
04d5 3a e9 04			ld a, (.dmark)  
04d8 32 7a ee			ld (debug_mark),a  
04db 3a ea 04			ld a, (.dmark+1)  
04de 32 7b ee			ld (debug_mark+1),a  
04e1 3a eb 04			ld a, (.dmark+2)  
04e4 32 7c ee			ld (debug_mark+2),a  
04e7 18 03			jr .pastdmark  
04e9 ..			.dmark: db "FNI"  
04ec f1			.pastdmark: pop af  
04ed			endm  
# End of macro DMARK
04ed						CALLMONITOR 
04ed cd 0e 14			call break_point_state  
04f0				endm  
# End of macro CALLMONITOR
04f0					endif 
04f0			.ff1:   	 
04f0 e5					push hl 
04f1 c5					push bc 
04f2 d5					push de 
04f3 cd ae 01				call se_readbyte 
04f6 5f					ld e,a 
04f7 23					inc hl 
04f8 cd ae 01				call se_readbyte 
04fb 57					ld d, a 
04fc e1					pop hl 
04fd e5					push hl 
04fe cd d0 0b				call cmp16 
0501 28 49				jr z, .fffound 
0503			 
0503 d1					pop de 
0504 c1					pop bc 
0505 e1					pop hl 
0506			 
0506					; is found? 
0506					;cp e 
0506					;ret z 
0506			 
0506 3e 40				ld a, STORE_BLOCK_PHY 
0508 cd b2 0b				call addatohl 
050b 10 e3				djnz .ff1 
050d			 
050d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
050f			.ff2:   	 
050f			 
050f e5					push hl 
0510 c5					push bc 
0511 d5					push de 
0512 cd ae 01				call se_readbyte 
0515 5f					ld e,a 
0516 23					inc hl 
0517 cd ae 01				call se_readbyte 
051a 57					ld d, a 
051b			 
051b e1					pop hl 
051c e5					push hl 
051d cd d0 0b				call cmp16 
0520 28 2a				jr z, .fffound 
0522			 
0522 d1					pop de 
0523 c1					pop bc 
0524 e1					pop hl 
0525					; is found? 
0525					;cp e 
0525					;ret z 
0525			 
0525 3e 40				ld a, STORE_BLOCK_PHY 
0527 cd b2 0b				call addatohl 
052a 10 e3				djnz .ff2 
052c			 
052c			 
052c					if DEBUG_FORTH_WORDS 
052c					DMARK "FN-" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 7a ee			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 7b ee			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 7c ee			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "FN-"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545					;	push af 
0545					;	ld a, 'n' 
0545					;	ld (debug_mark),a 
0545					;	pop af 
0545						CALLMONITOR 
0545 cd 0e 14			call break_point_state  
0548				endm  
# End of macro CALLMONITOR
0548					endif 
0548				; no free marks! 
0548 21 00 00				ld hl, 0 
054b c9				ret 
054c			.fffound: 
054c				 
054c			 
054c d1					pop de 
054d c1					pop bc 
054e e1					pop hl 
054f					if DEBUG_FORTH_WORDS 
054f					DMARK "FNF" 
054f f5				push af  
0550 3a 64 05			ld a, (.dmark)  
0553 32 7a ee			ld (debug_mark),a  
0556 3a 65 05			ld a, (.dmark+1)  
0559 32 7b ee			ld (debug_mark+1),a  
055c 3a 66 05			ld a, (.dmark+2)  
055f 32 7c ee			ld (debug_mark+2),a  
0562 18 03			jr .pastdmark  
0564 ..			.dmark: db "FNF"  
0567 f1			.pastdmark: pop af  
0568			endm  
# End of macro DMARK
0568					;	push af 
0568					;	ld a, 'n' 
0568					;	ld (debug_mark),a 
0568					;	pop af 
0568						CALLMONITOR 
0568 cd 0e 14			call break_point_state  
056b				endm  
# End of macro CALLMONITOR
056b					endif 
056b c9				ret 
056c			 
056c			 
056c			 
056c			; Free Space 
056c			; ---------- 
056c			; 
056c			; With current bank 
056c			; 
056c			; Set block count to zero 
056c			; Starting with first logical block 
056c			;      Find free block  
056c			;      If block id given, increment block count 
056c			; 
056c			;  
056c			 
056c			 
056c			; hl contains count of free blocks 
056c			 
056c			storage_freeblocks: 
056c			 
056c				; now locate first 0 page to mark as a free block 
056c			 
056c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
056e 21 40 00			ld hl, STORE_BLOCK_PHY 
0571 11 00 00			ld de, 0 
0574			 
0574			.fb1:   	 
0574 e5					push hl 
0575 c5					push bc 
0576 d5					push de 
0577 cd ae 01				call se_readbyte 
057a d1					pop de 
057b c1					pop bc 
057c e1					pop hl 
057d			 
057d					; is free? 
057d fe 00				cp 0 
057f 20 01				jr nz, .ff1cont 
0581 13					inc de 
0582			 
0582			.ff1cont: 
0582			 
0582			 
0582 3e 40				ld a, STORE_BLOCK_PHY 
0584 cd b2 0b				call addatohl 
0587 10 eb				djnz .fb1 
0589			 
0589 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
058b			.fb2:   	 
058b e5					push hl 
058c c5					push bc 
058d d5					push de 
058e cd ae 01				call se_readbyte 
0591 d1					pop de 
0592 c1					pop bc 
0593 e1					pop hl 
0594			 
0594					; is free? 
0594 fe 00				cp 0 
0596 20 01				jr nz, .ff2cont 
0598 13					inc de 
0599			 
0599			.ff2cont: 
0599			 
0599 3e 40				ld a, STORE_BLOCK_PHY 
059b cd b2 0b				call addatohl 
059e 10 eb				djnz .fb2 
05a0			 
05a0 eb				ex de, hl 
05a1 c9				ret 
05a2			 
05a2			; Get File ID 
05a2			; ----------- 
05a2			; 
05a2			; With current bank 
05a2			;  
05a2			; Load Block 0 Config 
05a2			; Get max file id number 
05a2			; For each logical block 
05a2			;    Read block file id 
05a2			;      If first block of file and dont have file id 
05a2			;         if file get id and exit 
05a2			 
05a2			 
05a2			 
05a2			 
05a2			; Create File 
05a2			; ----------- 
05a2			; 
05a2			; With current bank  
05a2			; Load Block 0 Config 
05a2			; Get max file id number 
05a2			; Increment file id number 
05a2			; Save Config 
05a2			; Find free block 
05a2			; Set buffer with file name and file id 
05a2			; Write buffer to free block  
05a2			 
05a2			 
05a2			; hl point to file name 
05a2			; hl returns file id 
05a2			 
05a2			; file format: 
05a2			; byte 0 - file id 
05a2			; byte 1 - extent number 
05a2			; byte 2-> data 
05a2			 
05a2			; format for extent number 0: 
05a2			; 
05a2			; byte 0 - file id 
05a2			; byte 1 - extent 0 
05a2			; byte 2 - extent count 
05a2			; byte 3 -> file name and meta data 
05a2			 
05a2			 
05a2			storage_create: 
05a2				if DEBUG_STORESE 
05a2					DMARK "SCR" 
05a2 f5				push af  
05a3 3a b7 05			ld a, (.dmark)  
05a6 32 7a ee			ld (debug_mark),a  
05a9 3a b8 05			ld a, (.dmark+1)  
05ac 32 7b ee			ld (debug_mark+1),a  
05af 3a b9 05			ld a, (.dmark+2)  
05b2 32 7c ee			ld (debug_mark+2),a  
05b5 18 03			jr .pastdmark  
05b7 ..			.dmark: db "SCR"  
05ba f1			.pastdmark: pop af  
05bb			endm  
# End of macro DMARK
05bb					CALLMONITOR 
05bb cd 0e 14			call break_point_state  
05be				endm  
# End of macro CALLMONITOR
05be				endif 
05be			 
05be e5				push hl		; save file name pointer 
05bf			 
05bf cd 62 02			call storage_get_block_0 
05c2			 
05c2 3a 65 eb			ld a,(store_page)	; get current file id 
05c5 3c				inc a 
05c6 32 65 eb			ld (store_page),a 
05c9				 
05c9 32 5e eb			ld (store_tmpid),a			; save id 
05cc			 
05cc 21 00 00			ld hl, 0 
05cf 11 65 eb			ld de, store_page 
05d2				if DEBUG_STORESE 
05d2					DMARK "SCw" 
05d2 f5				push af  
05d3 3a e7 05			ld a, (.dmark)  
05d6 32 7a ee			ld (debug_mark),a  
05d9 3a e8 05			ld a, (.dmark+1)  
05dc 32 7b ee			ld (debug_mark+1),a  
05df 3a e9 05			ld a, (.dmark+2)  
05e2 32 7c ee			ld (debug_mark+2),a  
05e5 18 03			jr .pastdmark  
05e7 ..			.dmark: db "SCw"  
05ea f1			.pastdmark: pop af  
05eb			endm  
# End of macro DMARK
05eb					CALLMONITOR 
05eb cd 0e 14			call break_point_state  
05ee				endm  
# End of macro CALLMONITOR
05ee				endif 
05ee cd 16 02			call storage_write_block	 ; save update 
05f1			 
05f1				if DEBUG_STORESE 
05f1 11 65 eb				ld de, store_page 
05f4					DMARK "SCC" 
05f4 f5				push af  
05f5 3a 09 06			ld a, (.dmark)  
05f8 32 7a ee			ld (debug_mark),a  
05fb 3a 0a 06			ld a, (.dmark+1)  
05fe 32 7b ee			ld (debug_mark+1),a  
0601 3a 0b 06			ld a, (.dmark+2)  
0604 32 7c ee			ld (debug_mark+2),a  
0607 18 03			jr .pastdmark  
0609 ..			.dmark: db "SCC"  
060c f1			.pastdmark: pop af  
060d			endm  
# End of macro DMARK
060d					CALLMONITOR 
060d cd 0e 14			call break_point_state  
0610				endm  
# End of macro CALLMONITOR
0610				endif 
0610				;  
0610				 
0610 21 40 00			ld hl, STORE_BLOCK_PHY 
0613 11 00 00			ld de, 0 
0616 cd d2 04			call storage_findnextid 
0619			 
0619 22 4f eb			ld (store_tmppageid), hl    ; save page to use  
061c			 
061c				; TODO detect 0 = no spare blocks 
061c			 
061c				; hl now contains the free page to use for the file header page 
061c			 
061c				if DEBUG_STORESE 
061c				DMARK "SCF" 
061c f5				push af  
061d 3a 31 06			ld a, (.dmark)  
0620 32 7a ee			ld (debug_mark),a  
0623 3a 32 06			ld a, (.dmark+1)  
0626 32 7b ee			ld (debug_mark+1),a  
0629 3a 33 06			ld a, (.dmark+2)  
062c 32 7c ee			ld (debug_mark+2),a  
062f 18 03			jr .pastdmark  
0631 ..			.dmark: db "SCF"  
0634 f1			.pastdmark: pop af  
0635			endm  
# End of macro DMARK
0635					CALLMONITOR 
0635 cd 0e 14			call break_point_state  
0638				endm  
# End of macro CALLMONITOR
0638				endif 
0638			 
0638 22 4f eb			ld (store_tmppageid), hl 
063b				 
063b 3a 5e eb			ld a,(store_tmpid)    ; get file id 
063e			;	ld a, (store_filecache)			; save to cache 
063e			 
063e 32 65 eb			ld (store_page),a    ; set page id 
0641 3e 00			ld a, 0			 ; extent 0 is file header 
0643 32 66 eb			ld (store_page+1), a   ; set file extent 
0646			 
0646 32 67 eb			ld (store_page+2), a   ; extent count for the file 
0649			 
0649			;	inc hl 		; init block 0 of file 
0649			;	inc hl   		; skip file and extent id 
0649			 ;       ld a, 0 
0649			;	ld (hl),a 
0649			;	ld a, (store_filecache+1)  	; save to cache 
0649			 
0649			;	inc hl    ; file name 
0649				 
0649				 
0649 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
064c				if DEBUG_STORESE 
064c					DMARK "SCc" 
064c f5				push af  
064d 3a 61 06			ld a, (.dmark)  
0650 32 7a ee			ld (debug_mark),a  
0653 3a 62 06			ld a, (.dmark+1)  
0656 32 7b ee			ld (debug_mark+1),a  
0659 3a 63 06			ld a, (.dmark+2)  
065c 32 7c ee			ld (debug_mark+2),a  
065f 18 03			jr .pastdmark  
0661 ..			.dmark: db "SCc"  
0664 f1			.pastdmark: pop af  
0665			endm  
# End of macro DMARK
0665					CALLMONITOR 
0665 cd 0e 14			call break_point_state  
0668				endm  
# End of macro CALLMONITOR
0668				endif 
0668 e1				pop hl    ; get zero term string 
0669 e5				push hl 
066a 3e 00			ld a, 0 
066c cd 1b 10			call strlent 
066f 23				inc hl   ; cover zero term 
0670 06 00			ld b,0 
0672 4d				ld c,l 
0673 e1				pop hl 
0674				;ex de, hl 
0674				if DEBUG_STORESE 
0674					DMARK "SCa" 
0674 f5				push af  
0675 3a 89 06			ld a, (.dmark)  
0678 32 7a ee			ld (debug_mark),a  
067b 3a 8a 06			ld a, (.dmark+1)  
067e 32 7b ee			ld (debug_mark+1),a  
0681 3a 8b 06			ld a, (.dmark+2)  
0684 32 7c ee			ld (debug_mark+2),a  
0687 18 03			jr .pastdmark  
0689 ..			.dmark: db "SCa"  
068c f1			.pastdmark: pop af  
068d			endm  
# End of macro DMARK
068d					;push af 
068d					;ld a, 'a' 
068d					;ld (debug_mark),a 
068d					;pop af 
068d					CALLMONITOR 
068d cd 0e 14			call break_point_state  
0690				endm  
# End of macro CALLMONITOR
0690				endif 
0690 ed b0			ldir    ; copy zero term string 
0692				if DEBUG_STORESE 
0692					DMARK "SCA" 
0692 f5				push af  
0693 3a a7 06			ld a, (.dmark)  
0696 32 7a ee			ld (debug_mark),a  
0699 3a a8 06			ld a, (.dmark+1)  
069c 32 7b ee			ld (debug_mark+1),a  
069f 3a a9 06			ld a, (.dmark+2)  
06a2 32 7c ee			ld (debug_mark+2),a  
06a5 18 03			jr .pastdmark  
06a7 ..			.dmark: db "SCA"  
06aa f1			.pastdmark: pop af  
06ab			endm  
# End of macro DMARK
06ab					CALLMONITOR 
06ab cd 0e 14			call break_point_state  
06ae				endm  
# End of macro CALLMONITOR
06ae				endif 
06ae			 
06ae				; write file header page 
06ae			 
06ae 2a 4f eb			ld hl,(store_tmppageid) 
06b1 11 65 eb			ld de, store_page 
06b4				if DEBUG_STORESE 
06b4					DMARK "SCb" 
06b4 f5				push af  
06b5 3a c9 06			ld a, (.dmark)  
06b8 32 7a ee			ld (debug_mark),a  
06bb 3a ca 06			ld a, (.dmark+1)  
06be 32 7b ee			ld (debug_mark+1),a  
06c1 3a cb 06			ld a, (.dmark+2)  
06c4 32 7c ee			ld (debug_mark+2),a  
06c7 18 03			jr .pastdmark  
06c9 ..			.dmark: db "SCb"  
06cc f1			.pastdmark: pop af  
06cd			endm  
# End of macro DMARK
06cd					;push af 
06cd					;ld a, 'b' 
06cd					;ld (debug_mark),a 
06cd					;pop af 
06cd					CALLMONITOR 
06cd cd 0e 14			call break_point_state  
06d0				endm  
# End of macro CALLMONITOR
06d0				endif 
06d0 cd 16 02			call storage_write_block 
06d3			 
06d3 3a 5e eb			ld a, (store_tmpid) 
06d6 6f				ld l, a 
06d7 26 00			ld h,0 
06d9				if DEBUG_STORESE 
06d9					DMARK "SCz" 
06d9 f5				push af  
06da 3a ee 06			ld a, (.dmark)  
06dd 32 7a ee			ld (debug_mark),a  
06e0 3a ef 06			ld a, (.dmark+1)  
06e3 32 7b ee			ld (debug_mark+1),a  
06e6 3a f0 06			ld a, (.dmark+2)  
06e9 32 7c ee			ld (debug_mark+2),a  
06ec 18 03			jr .pastdmark  
06ee ..			.dmark: db "SCz"  
06f1 f1			.pastdmark: pop af  
06f2			endm  
# End of macro DMARK
06f2					CALLMONITOR 
06f2 cd 0e 14			call break_point_state  
06f5				endm  
# End of macro CALLMONITOR
06f5				endif 
06f5 c9				ret 
06f6				 
06f6			 
06f6			 
06f6			; 
06f6			; Read File 
06f6			; 
06f6			; h - file id to locate 
06f6			; l - extent to locate 
06f6			; de - pointer to string to read into 
06f6			; 
06f6			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
06f6			storage_read: 
06f6 d5				push de 
06f7			 
06f7			; TODO BUG the above push is it popped before the RET Z? 
06f7			 
06f7			; TODO how to handle multiple part blocks 
06f7			 
06f7				; locate file extent to read 
06f7			 
06f7 5c				ld e, h 
06f8 55				ld d, l 
06f9 21 40 00			ld hl, STORE_BLOCK_PHY 
06fc				if DEBUG_STORESE 
06fc					DMARK "SRE" 
06fc f5				push af  
06fd 3a 11 07			ld a, (.dmark)  
0700 32 7a ee			ld (debug_mark),a  
0703 3a 12 07			ld a, (.dmark+1)  
0706 32 7b ee			ld (debug_mark+1),a  
0709 3a 13 07			ld a, (.dmark+2)  
070c 32 7c ee			ld (debug_mark+2),a  
070f 18 03			jr .pastdmark  
0711 ..			.dmark: db "SRE"  
0714 f1			.pastdmark: pop af  
0715			endm  
# End of macro DMARK
0715					CALLMONITOR 
0715 cd 0e 14			call break_point_state  
0718				endm  
# End of macro CALLMONITOR
0718				endif 
0718 cd d2 04			call storage_findnextid 
071b			 
071b				if DEBUG_STORESE 
071b					DMARK "SRf" 
071b f5				push af  
071c 3a 30 07			ld a, (.dmark)  
071f 32 7a ee			ld (debug_mark),a  
0722 3a 31 07			ld a, (.dmark+1)  
0725 32 7b ee			ld (debug_mark+1),a  
0728 3a 32 07			ld a, (.dmark+2)  
072b 32 7c ee			ld (debug_mark+2),a  
072e 18 03			jr .pastdmark  
0730 ..			.dmark: db "SRf"  
0733 f1			.pastdmark: pop af  
0734			endm  
# End of macro DMARK
0734					CALLMONITOR 
0734 cd 0e 14			call break_point_state  
0737				endm  
# End of macro CALLMONITOR
0737				endif 
0737 cd db 0b			call ishlzero 
073a			;	ld a, l 
073a			;	add h 
073a			;	cp 0 
073a c8				ret z			; block not found so EOF 
073b			 
073b				; hl contains page number to load 
073b d1				pop de   ; get storage 
073c d5				push de 
073d				if DEBUG_STORESE 
073d					DMARK "SRg" 
073d f5				push af  
073e 3a 52 07			ld a, (.dmark)  
0741 32 7a ee			ld (debug_mark),a  
0744 3a 53 07			ld a, (.dmark+1)  
0747 32 7b ee			ld (debug_mark+1),a  
074a 3a 54 07			ld a, (.dmark+2)  
074d 32 7c ee			ld (debug_mark+2),a  
0750 18 03			jr .pastdmark  
0752 ..			.dmark: db "SRg"  
0755 f1			.pastdmark: pop af  
0756			endm  
# End of macro DMARK
0756					CALLMONITOR 
0756 cd 0e 14			call break_point_state  
0759				endm  
# End of macro CALLMONITOR
0759				endif 
0759 cd b1 01			call storage_read_block 
075c			 
075c			 
075c			; TODO if block has no zeros then need to read next block  
075c			 
075c			 
075c					 
075c e1				pop hl 		 ; return start of data to show as not EOF 
075d 23				inc hl   ; past file id 
075e 23				inc hl   ; past ext 
075f				if DEBUG_STORESE 
075f					DMARK "SRe" 
075f f5				push af  
0760 3a 74 07			ld a, (.dmark)  
0763 32 7a ee			ld (debug_mark),a  
0766 3a 75 07			ld a, (.dmark+1)  
0769 32 7b ee			ld (debug_mark+1),a  
076c 3a 76 07			ld a, (.dmark+2)  
076f 32 7c ee			ld (debug_mark+2),a  
0772 18 03			jr .pastdmark  
0774 ..			.dmark: db "SRe"  
0777 f1			.pastdmark: pop af  
0778			endm  
# End of macro DMARK
0778					CALLMONITOR 
0778 cd 0e 14			call break_point_state  
077b				endm  
# End of macro CALLMONITOR
077b				endif 
077b c9					ret 
077c			 
077c			 
077c			 
077c			; 
077c			; Append File 
077c			; 
077c			; hl - file id to locate 
077c			; de - pointer to (multi block) string to write 
077c			 
077c			 
077c			storage_append: 
077c				; hl -  file id to append to 
077c				; de - string to append 
077c			 
077c d5				push de 
077d				 
077d				if DEBUG_STORESE 
077d					DMARK "AP1" 
077d f5				push af  
077e 3a 92 07			ld a, (.dmark)  
0781 32 7a ee			ld (debug_mark),a  
0784 3a 93 07			ld a, (.dmark+1)  
0787 32 7b ee			ld (debug_mark+1),a  
078a 3a 94 07			ld a, (.dmark+2)  
078d 32 7c ee			ld (debug_mark+2),a  
0790 18 03			jr .pastdmark  
0792 ..			.dmark: db "AP1"  
0795 f1			.pastdmark: pop af  
0796			endm  
# End of macro DMARK
0796					CALLMONITOR 
0796 cd 0e 14			call break_point_state  
0799				endm  
# End of macro CALLMONITOR
0799				endif 
0799			 
0799 7d				ld a, l 
079a 32 5e eb			ld (store_tmpid), a 
079d			 
079d				; get file header  
079d			 
079d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
079f 3a 5e eb			ld a, (store_tmpid) 
07a2 5f				ld e, a 
07a3			 
07a3 21 40 00				ld hl, STORE_BLOCK_PHY 
07a6 cd d2 04				call storage_findnextid 
07a9			 
07a9 22 4f eb			ld (store_tmppageid), hl 
07ac			 
07ac				; TODO handle file id not found 
07ac			 
07ac				if DEBUG_STORESE 
07ac					DMARK "AP2" 
07ac f5				push af  
07ad 3a c1 07			ld a, (.dmark)  
07b0 32 7a ee			ld (debug_mark),a  
07b3 3a c2 07			ld a, (.dmark+1)  
07b6 32 7b ee			ld (debug_mark+1),a  
07b9 3a c3 07			ld a, (.dmark+2)  
07bc 32 7c ee			ld (debug_mark+2),a  
07bf 18 03			jr .pastdmark  
07c1 ..			.dmark: db "AP2"  
07c4 f1			.pastdmark: pop af  
07c5			endm  
# End of macro DMARK
07c5					CALLMONITOR 
07c5 cd 0e 14			call break_point_state  
07c8				endm  
# End of macro CALLMONITOR
07c8				endif 
07c8			 
07c8				; update file extent count 
07c8			 
07c8 11 65 eb			ld de, store_page 
07cb			 
07cb cd b1 01			call storage_read_block 
07ce			 
07ce				if DEBUG_STORESE 
07ce					DMARK "AP3" 
07ce f5				push af  
07cf 3a e3 07			ld a, (.dmark)  
07d2 32 7a ee			ld (debug_mark),a  
07d5 3a e4 07			ld a, (.dmark+1)  
07d8 32 7b ee			ld (debug_mark+1),a  
07db 3a e5 07			ld a, (.dmark+2)  
07de 32 7c ee			ld (debug_mark+2),a  
07e1 18 03			jr .pastdmark  
07e3 ..			.dmark: db "AP3"  
07e6 f1			.pastdmark: pop af  
07e7			endm  
# End of macro DMARK
07e7					CALLMONITOR 
07e7 cd 0e 14			call break_point_state  
07ea				endm  
# End of macro CALLMONITOR
07ea				endif 
07ea			;	ld (store_tmppageid), hl 
07ea			 
07ea 3a 67 eb			ld a, (store_page+2) 
07ed 3c				inc a 
07ee 32 67 eb			ld (store_page+2), a 
07f1 32 5d eb			ld (store_tmpext), a 
07f4				 
07f4				if DEBUG_STORESE 
07f4					DMARK "AP3" 
07f4 f5				push af  
07f5 3a 09 08			ld a, (.dmark)  
07f8 32 7a ee			ld (debug_mark),a  
07fb 3a 0a 08			ld a, (.dmark+1)  
07fe 32 7b ee			ld (debug_mark+1),a  
0801 3a 0b 08			ld a, (.dmark+2)  
0804 32 7c ee			ld (debug_mark+2),a  
0807 18 03			jr .pastdmark  
0809 ..			.dmark: db "AP3"  
080c f1			.pastdmark: pop af  
080d			endm  
# End of macro DMARK
080d					CALLMONITOR 
080d cd 0e 14			call break_point_state  
0810				endm  
# End of macro CALLMONITOR
0810				endif 
0810 2a 4f eb			ld hl, (store_tmppageid) 
0813 11 65 eb			ld de, store_page 
0816 cd 16 02			call storage_write_block 
0819			 
0819				; find free block 
0819			 
0819 11 00 00			ld de, 0			 ; file extent to locate 
081c			 
081c 21 40 00				ld hl, STORE_BLOCK_PHY 
081f cd d2 04				call storage_findnextid 
0822			 
0822					; TODO handle no space left 
0822					 
0822 22 4f eb				ld (store_tmppageid), hl 
0825			 
0825				if DEBUG_STORESE 
0825					DMARK "AP4" 
0825 f5				push af  
0826 3a 3a 08			ld a, (.dmark)  
0829 32 7a ee			ld (debug_mark),a  
082c 3a 3b 08			ld a, (.dmark+1)  
082f 32 7b ee			ld (debug_mark+1),a  
0832 3a 3c 08			ld a, (.dmark+2)  
0835 32 7c ee			ld (debug_mark+2),a  
0838 18 03			jr .pastdmark  
083a ..			.dmark: db "AP4"  
083d f1			.pastdmark: pop af  
083e			endm  
# End of macro DMARK
083e					CALLMONITOR 
083e cd 0e 14			call break_point_state  
0841				endm  
# End of macro CALLMONITOR
0841				endif 
0841					; init the buffer with zeros so we can id if the buffer is full or not 
0841			 
0841 e5					push hl 
0842 c5					push bc 
0843			 
0843 21 65 eb				ld hl, store_page 
0846 06 40				ld b, STORE_BLOCK_PHY 
0848 3e 00				ld a, 0 
084a 77			.zeroblock:	ld (hl), a 
084b 23					inc hl 
084c 10 fc				djnz .zeroblock 
084e			 
084e c1					pop bc 
084f e1					pop hl 
0850			 
0850					; construct block 
0850			 
0850 3a 5e eb				ld a, (store_tmpid) 
0853 32 65 eb				ld (store_page), a   ; file id 
0856 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
0859 32 66 eb				ld (store_page+1), a 
085c			 
085c e1					pop hl    ; get string to write 
085d 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
085f 11 67 eb				ld de, store_page+2 
0862			 
0862				if DEBUG_STORESE 
0862					DMARK "AP5" 
0862 f5				push af  
0863 3a 77 08			ld a, (.dmark)  
0866 32 7a ee			ld (debug_mark),a  
0869 3a 78 08			ld a, (.dmark+1)  
086c 32 7b ee			ld (debug_mark+1),a  
086f 3a 79 08			ld a, (.dmark+2)  
0872 32 7c ee			ld (debug_mark+2),a  
0875 18 03			jr .pastdmark  
0877 ..			.dmark: db "AP5"  
087a f1			.pastdmark: pop af  
087b			endm  
# End of macro DMARK
087b					CALLMONITOR 
087b cd 0e 14			call break_point_state  
087e				endm  
# End of macro CALLMONITOR
087e				endif 
087e			 
087e			 
087e			 
087e					; fill buffer with data until end of string or full block 
087e			 
087e 7e			.appd:		ld a, (hl) 
087f 12					ld (de), a 
0880 fe 00				cp 0 
0882 28 04				jr z, .appdone 
0884 23					inc hl 
0885 13					inc de 
0886 10 f6				djnz .appd 
0888			 
0888 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0889 f5					push af   		; save last byte dumped 
088a			 
088a			 
088a 2a 4f eb			ld hl, (store_tmppageid) 
088d 11 65 eb			ld de, store_page 
0890				if DEBUG_STORESE 
0890					DMARK "AP6" 
0890 f5				push af  
0891 3a a5 08			ld a, (.dmark)  
0894 32 7a ee			ld (debug_mark),a  
0897 3a a6 08			ld a, (.dmark+1)  
089a 32 7b ee			ld (debug_mark+1),a  
089d 3a a7 08			ld a, (.dmark+2)  
08a0 32 7c ee			ld (debug_mark+2),a  
08a3 18 03			jr .pastdmark  
08a5 ..			.dmark: db "AP6"  
08a8 f1			.pastdmark: pop af  
08a9			endm  
# End of macro DMARK
08a9					CALLMONITOR 
08a9 cd 0e 14			call break_point_state  
08ac				endm  
# End of macro CALLMONITOR
08ac				endif 
08ac cd 16 02				call storage_write_block 
08af			 
08af			 
08af				; was that a full block of data written? 
08af				; any more to write out? 
08af			 
08af				; if yes then set vars and jump to start of function again 
08af			 
08af f1					pop af 
08b0 d1					pop de 
08b1			 
08b1 fe 00				cp 0		 ; no, string was fully written 
08b3 c8					ret z 
08b4			 
08b4					; setup vars for next cycle 
08b4			 
08b4 3a 5e eb				ld a, (store_tmpid) 
08b7 6f					ld l, a 
08b8 26 00				ld h, 0 
08ba			 
08ba c3 7c 07			 	jp storage_append	 ; yes, need to write out some more 
08bd			 
08bd			 
08bd			 
08bd			 
08bd			 
08bd			 
08bd			 
08bd			if DEBUG_STORECF 
08bd			storageput:	 
08bd					ret 
08bd			storageread: 
08bd					ld hl, store_page 
08bd					ld b, 200 
08bd					ld a,0 
08bd			.src:		ld (hl),a 
08bd					inc hl 
08bd					djnz .src 
08bd					 
08bd			 
08bd					ld de, 0 
08bd					ld bc, 1 
08bd					ld hl, store_page 
08bd					call cfRead 
08bd			 
08bd				call cfGetError 
08bd				ld hl,scratch 
08bd				call hexout 
08bd				ld hl, scratch+2 
08bd				ld a, 0 
08bd				ld (hl),a 
08bd				ld de, scratch 
08bd				ld a,display_row_1 
08bd				call str_at_display 
08bd				call update_display 
08bd			 
08bd					ld hl, store_page 
08bd					ld (os_cur_ptr),hl 
08bd			 
08bd					ret 
08bd			endif 
08bd			 
08bd			 
08bd			; Clear out the main buffer store (used to remove junk before writing a new block) 
08bd			 
08bd			storage_clear_page: 
08bd e5				push hl 
08be d5				push de 
08bf c5				push bc 
08c0 21 65 eb			ld hl, store_page 
08c3 3e 00			ld a, 0 
08c5 77				ld (hl), a 
08c6			 
08c6 11 66 eb			ld de, store_page+1 
08c9 01 40 00			ld bc, STORE_BLOCK_PHY 
08cc			 
08cc ed b0			ldir 
08ce				 
08ce c1				pop bc 
08cf d1				pop de 
08d0 e1				pop hl 
08d1 c9				ret 
08d2			 
08d2			; eof 
# End of file firmware_storage.asm
08d2			  
08d2			; support routines for above hardware abstraction layer  
08d2			  
08d2			include "firmware_general.asm"        ; general support functions  
08d2			 
08d2			; word look up 
08d2			 
08d2			; in 
08d2			; a is the index 
08d2			; hl is pointer start of array 
08d2			; 
08d2			; returns 
08d2			; hl to the word 
08d2			; 
08d2			 
08d2			table_lookup:  
08d2 d5					push de 
08d3 eb					ex de, hl 
08d4			 
08d4 6f					ld l, a 
08d5 26 00				ld h, 0 
08d7 29					add hl, hl 
08d8 19					add hl, de 
08d9 7e					ld a, (hl) 
08da 23					inc hl 
08db 66					ld h,(hl) 
08dc 6f					ld l, a 
08dd			 
08dd d1					pop de 
08de c9					ret 
08df			 
08df			; Delay loops 
08df			 
08df			 
08df			 
08df			aDelayInMS: 
08df c5				push bc 
08e0 47				ld b,a 
08e1			msdelay: 
08e1 c5				push bc 
08e2				 
08e2			 
08e2 01 41 00			ld bc,041h 
08e5 cd fd 08			call delayloop 
08e8 c1				pop bc 
08e9 05				dec b 
08ea 20 f5			jr nz,msdelay 
08ec			 
08ec			;if CPU_CLOCK_8MHZ 
08ec			;msdelay8: 
08ec			;	push bc 
08ec			;	 
08ec			; 
08ec			;	ld bc,041h 
08ec			;	call delayloop 
08ec			;	pop bc 
08ec			;	dec b 
08ec			;	jr nz,msdelay8 
08ec			;endif 
08ec			 
08ec			 
08ec c1				pop bc 
08ed c9				ret 
08ee			 
08ee			 
08ee			delay250ms: 
08ee				;push de 
08ee 01 00 40			ld bc, 04000h 
08f1 c3 fd 08			jp delayloop 
08f4			delay500ms: 
08f4				;push de 
08f4 01 00 80			ld bc, 08000h 
08f7 c3 fd 08			jp delayloop 
08fa			delay1s: 
08fa				;push bc 
08fa			   ; Clobbers A, d and e 
08fa 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
08fd			delayloop: 
08fd c5			    push bc 
08fe			 
08fe			if BASE_CPM 
08fe 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0901			.cpmloop: 
0901 c5				push bc 
0902			 
0902			endif 
0902			 
0902			 
0902			 
0902			delayloopi: 
0902			;	push bc 
0902			;.dl: 
0902 cb 47		    bit     0,a    	; 8 
0904 cb 47		    bit     0,a    	; 8 
0906 cb 47		    bit     0,a    	; 8 
0908 e6 ff		    and     255  	; 7 
090a 0b			    dec     bc      	; 6 
090b 79			    ld      a,c     	; 4 
090c b0			    or      b     	; 4 
090d c2 02 09		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0910			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0910				;pop de 
0910			;pop bc 
0910			 
0910			if BASE_CPM 
0910 c1				pop bc 
0911				 
0911 0b			    dec     bc      	; 6 
0912 79			    ld      a,c     	; 4 
0913 b0			    or      b     	; 4 
0914 c2 01 09		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0917				 
0917			 
0917			endif 
0917			;if CPU_CLOCK_8MHZ 
0917			;    pop bc 
0917			;    push bc 
0917			;.dl8: 
0917			;    bit     0,a    	; 8 
0917			;    bit     0,a    	; 8 
0917			;    bit     0,a    	; 8 
0917			;    and     255  	; 7 
0917			;    dec     bc      	; 6 
0917			;    ld      a,c     	; 4 
0917			;    or      b     	; 4 
0917			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0917			;endif 
0917			 
0917			;if CPU_CLOCK_10MHZ 
0917			;    pop bc 
0917			;    push bc 
0917			;.dl8: 
0917			;    bit     0,a    	; 8 
0917			;    bit     0,a    	; 8 
0917			;    bit     0,a    	; 8 
0917			;    and     255  	; 7 
0917			;    dec     bc      	; 6 
0917			;    ld      a,c     	; 4 
0917			;    or      b     	; 4 
0917			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0917			;endif 
0917 c1			    pop bc 
0918			 
0918 c9				ret 
0919			 
0919			 
0919			 
0919			; eof 
# End of file firmware_general.asm
0919			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0919			; display routines that use the physical hardware abstraction layer 
0919			 
0919			 
0919			; information window 
0919			 
0919			; pass hl with 1st string to display 
0919			; pass de with 2nd string to display 
0919			 
0919			info_panel: 
0919 e5				push hl 
091a			 
091a 2a db eb			ld hl, (display_fb_active) 
091d e5				push hl    ; future de destination 
091e 21 c0 ed				ld hl, display_fb0 
0921 22 db eb				ld (display_fb_active), hl 
0924			 
0924 cd 85 09			call clear_display 
0927			 
0927			 
0927 3e 55			ld a, display_row_3 + 5 
0929 cd 98 09			call str_at_display 
092c			 
092c e1				pop hl 
092d d1				pop de 
092e			 
092e e5				push hl 
092f			 
092f			 
092f 3e 2d			ld a, display_row_2 + 5 
0931 cd 98 09			call str_at_display 
0934			 
0934			 
0934 cd a8 09			call update_display 
0937 cd 13 19			call next_page_prompt 
093a cd 85 09			call clear_display 
093d			 
093d				 
093d 21 1f ed				ld hl, display_fb1 
0940 22 db eb				ld (display_fb_active), hl 
0943 cd a8 09			call update_display 
0946			 
0946			 
0946 c9				ret 
0947			 
0947			 
0947			 
0947			 
0947			; TODO windowing? 
0947			 
0947			; TODO scroll line up 
0947			 
0947			scroll_up: 
0947			 
0947 e5				push hl 
0948 d5				push de 
0949 c5				push bc 
094a			 
094a				; get frame buffer  
094a			 
094a 2a db eb			ld hl, (display_fb_active) 
094d e5				push hl    ; future de destination 
094e			 
094e 11 28 00			ld  de, display_cols 
0951 19				add hl, de 
0952			 
0952 d1				pop de 
0953			 
0953				;ex de, hl 
0953 01 9f 00			ld bc, display_fb_len -1  
0956			;if DEBUG_FORTH_WORDS 
0956			;	DMARK "SCL" 
0956			;	CALLMONITOR 
0956			;endif	 
0956 ed b0			ldir 
0958			 
0958				; wipe bottom row 
0958			 
0958			 
0958 2a db eb			ld hl, (display_fb_active) 
095b 11 a0 00			ld de, display_cols*display_rows 
095e 19				add hl, de 
095f 06 28			ld b, display_cols 
0961 3e 20			ld a, ' ' 
0963			.scwipe: 
0963 77				ld (hl), a 
0964 2b				dec hl 
0965 10 fc			djnz .scwipe 
0967			 
0967				;pop hl 
0967			 
0967 c1				pop bc 
0968 d1				pop de 
0969 e1				pop hl 
096a			 
096a c9				ret 
096b			 
096b			 
096b			;scroll_upo: 
096b			;	ld de, display_row_1 
096b			 ;	ld hl, display_row_2 
096b			;	ld bc, display_cols 
096b			;	ldir 
096b			;	ld de, display_row_2 
096b			 ;	ld hl, display_row_3 
096b			;	ld bc, display_cols 
096b			;	ldir 
096b			;	ld de, display_row_3 
096b			 ;	ld hl, display_row_4 
096b			;	ld bc, display_cols 
096b			;	ldir 
096b			 
096b			; TODO clear row 4 
096b			 
096b			;	ret 
096b			 
096b				 
096b			scroll_down: 
096b			 
096b e5				push hl 
096c d5				push de 
096d c5				push bc 
096e			 
096e				; get frame buffer  
096e			 
096e 2a db eb			ld hl, (display_fb_active) 
0971			 
0971 11 9f 00			ld de, display_fb_len - 1 
0974 19				add hl, de 
0975			 
0975 e5			push hl    ; future de destination 
0976			 
0976 11 28 00			ld  de, display_cols 
0979 ed 52			sbc hl, de 
097b			 
097b			 
097b d1				pop de 
097c			 
097c			;	ex de, hl 
097c 01 9f 00			ld bc, display_fb_len -1  
097f			 
097f			 
097f				 
097f			 
097f ed b0			ldir 
0981			 
0981				; wipe bottom row 
0981			 
0981			 
0981			;	ld hl, (display_fb_active) 
0981			;;	ld de, display_cols*display_rows 
0981			;;	add hl, de 
0981			;	ld b, display_cols 
0981			;	ld a, ' ' 
0981			;.scwiped: 
0981			;	ld (hl), a 
0981			;	dec hl 
0981			;	djnz .scwiped 
0981			 
0981				;pop hl 
0981			 
0981 c1				pop bc 
0982 d1				pop de 
0983 e1				pop hl 
0984			 
0984 c9				ret 
0985			;scroll_down: 
0985			;	ld de, display_row_4 
0985			;	ld hl, display_row_3 
0985			;	ld bc, display_cols 
0985			;	ldir 
0985			;	ld de, display_row_3 
0985			; 	ld hl, display_row_2 
0985			;	ld bc, display_cols 
0985			;	ldir 
0985			;	ld de, display_row_2 
0985			;	ld hl, display_row_1 
0985			;	ld bc, display_cols 
0985			;	ldir 
0985			;;; TODO clear row 1 
0985			;	ret 
0985			 
0985			 
0985			 
0985			 
0985			 
0985			; clear active frame buffer 
0985			 
0985			clear_display: 
0985 3e 20			ld a, ' ' 
0987 c3 8a 09			jp fill_display 
098a			 
098a			; fill active frame buffer with a char in A 
098a			 
098a			fill_display: 
098a 06 a0			ld b,display_fb_len 
098c 2a db eb			ld hl, (display_fb_active) 
098f 77			.fd1:	ld (hl),a 
0990 23				inc hl 
0991 10 fc			djnz .fd1 
0993 23				inc hl 
0994 3e 00			ld a,0 
0996 77				ld (hl),a 
0997			 
0997			 
0997 c9				ret 
0998			; Write string (DE) at pos (A) to active frame buffer 
0998			 
0998 2a db eb		str_at_display:    ld hl,(display_fb_active) 
099b 06 00					ld b,0 
099d 4f					ld c,a 
099e 09					add hl,bc 
099f 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
09a0 b7			            OR   A              ;Null terminator? 
09a1 c8			            RET  Z              ;Yes, so finished 
09a2 77					ld (hl),a 
09a3 23				inc hl 
09a4 13			            INC  DE             ;Point to next character 
09a5 18 f8		            JR   .sad1     ;Repeat 
09a7 c9					ret 
09a8			 
09a8			; using current frame buffer write to physical display 
09a8			 
09a8			update_display: 
09a8 e5				push hl 
09a9 2a db eb			ld hl, (display_fb_active) 
09ac cd 13 59			call write_display 
09af e1				pop hl 
09b0 c9				ret 
09b1			 
09b1			; TODO scrolling 
09b1			 
09b1			 
09b1			; move cursor right one char 
09b1			cursor_right: 
09b1			 
09b1				; TODO shift right 
09b1				; TODO if beyond max col 
09b1				; TODO       cursor_next_line 
09b1			 
09b1 c9				ret 
09b2			 
09b2			 
09b2			cursor_next_line: 
09b2				; TODO first char 
09b2				; TODO line down 
09b2				; TODO if past last row 
09b2				; TODO    scroll up 
09b2			 
09b2 c9				ret 
09b3			 
09b3			cursor_left: 
09b3				; TODO shift left 
09b3				; TODO if beyond left  
09b3				; TODO     cursor prev line 
09b3				 
09b3 c9				ret 
09b4			 
09b4			cursor_prev_line: 
09b4				; TODO last char 
09b4				; TODO line up 
09b4				; TODO if past first row 
09b4				; TODO   scroll down 
09b4			 
09b4 c9				ret 
09b5			 
09b5			 
09b5			cout: 
09b5				; A - char 
09b5 c9				ret 
09b6			 
09b6			 
09b6			; Display a menu and allow item selection (optional toggle items) 
09b6			; 
09b6			; format: 
09b6			; hl pointer to word array with zero term for items 
09b6			; e.g.    db item1 
09b6			;         db .... 
09b6			;         db 0 
09b6			; 
09b6			; a = starting menu item  
09b6			; 
09b6			; de = pointer item toggle array   (todo) 
09b6			; 
09b6			; returns item selected in a 1-... 
09b6			; returns 0 if back button pressed 
09b6			; 
09b6			; NOTE: Uses system frame buffer to display 
09b6			; 
09b6			; LEFT, Q = go back 
09b6			; RIGHT, SPACE, CR = select 
09b6			; UP, A - Up 
09b6			; DOWN, Z - Down 
09b6			 
09b6			 
09b6			 
09b6			 
09b6			 
09b6			menu: 
09b6			 
09b6					; keep array pointer 
09b6			 
09b6 22 63 eb				ld (store_tmp1), hl 
09b9 32 61 eb				ld (store_tmp2), a 
09bc			 
09bc					; check for key bounce 
09bc			 
09bc			if BASE_KEV 
09bc			 
09bc			.mbounce:	call cin 
09bc					cp 0 
09bc					jr nz, .mbounce 
09bc			endif 
09bc					; for ease use ex 
09bc			 
09bc					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
09bc 21 c0 ed				ld hl, display_fb0 
09bf 22 db eb				ld (display_fb_active), hl 
09c2			 
09c2 cd 85 09		.mloop:		call clear_display 
09c5 cd a8 09				call update_display 
09c8			 
09c8					; draw selection id '>' at 1 
09c8			 
09c8					; init start of list display 
09c8			 
09c8 3e 05				ld a, 5 
09ca 32 5f eb				ld (store_tmp3), a   ; display row count 
09cd 3a 61 eb				ld a,( store_tmp2) 
09d0 32 62 eb				ld (store_tmp2+1), a   ; display item count 
09d3			 
09d3					 
09d3			.mitem:	 
09d3			 
09d3			 
09d3 3a 62 eb				ld a,(store_tmp2+1) 
09d6 6f					ld l, a 
09d7 26 00				ld h, 0 
09d9 29					add hl, hl 
09da ed 5b 63 eb			ld de, (store_tmp1) 
09de 19					add hl, de 
09df 7e					ld a, (hl) 
09e0 23					inc hl 
09e1 66					ld h,(hl) 
09e2 6f					ld l, a 
09e3			 
09e3 cd db 0b				call ishlzero 
09e6 28 1a				jr z, .mdone 
09e8			 
09e8 eb					ex de, hl 
09e9 3a 5f eb				ld a, (store_tmp3) 
09ec cd 98 09				call str_at_display 
09ef					 
09ef			 
09ef					; next item 
09ef 3a 62 eb				ld a, (store_tmp2+1) 
09f2 3c					inc a 
09f3 32 62 eb				ld (store_tmp2+1), a   ; display item count 
09f6			 
09f6			 		; next row 
09f6			 
09f6 3a 5f eb				ld a, (store_tmp3) 
09f9 c6 28				add display_cols 
09fb 32 5f eb				ld (store_tmp3), a 
09fe			 
09fe					; at end of screen? 
09fe			 
09fe fe 10				cp display_rows*4 
0a00 20 d1				jr nz, .mitem 
0a02			 
0a02			 
0a02			.mdone: 
0a02 cd db 0b				call ishlzero 
0a05 28 08				jr z, .nodn 
0a07			 
0a07 3e 78				ld a, display_row_4 
0a09 11 88 0a				ld de, .mdown 
0a0c cd 98 09				call str_at_display 
0a0f			 
0a0f					; draw options to fill the screens with active item on line 1 
0a0f					; if current option is 2 or more then display ^ in top 
0a0f			 
0a0f 3a 61 eb		.nodn:		ld a, (store_tmp2) 
0a12 fe 00				cp 0 
0a14 28 08				jr z, .noup 
0a16			 
0a16 3e 00				ld a, 0 
0a18 11 86 0a				ld de, .mup 
0a1b cd 98 09				call str_at_display 
0a1e			 
0a1e 3e 02		.noup:		ld a, 2 
0a20 11 84 0a				ld de, .msel 
0a23 cd 98 09				call str_at_display 
0a26			 
0a26					; if current option + 1 is not null then display V in bottom 
0a26					; get key 
0a26 cd a8 09				call update_display 
0a29			 
0a29			 
0a29					; handle key 
0a29			 
0a29 cd c5 59				call cin_wait 
0a2c			 
0a2c fe 05				cp KEY_UP 
0a2e 28 2b				jr z, .mgoup 
0a30 fe 61				cp 'a' 
0a32 28 27				jr z, .mgoup 
0a34 fe 0a				cp KEY_DOWN 
0a36 28 32				jr z, .mgod 
0a38 fe 7a				cp 'z' 
0a3a 28 2e				jr z, .mgod 
0a3c fe 20				cp ' ' 
0a3e 28 34				jr z, .goend 
0a40 fe 0c				cp KEY_RIGHT 
0a42 28 30				jr z, .goend 
0a44 fe 0d				cp KEY_CR 
0a46 28 2c				jr z, .goend 
0a48 fe 71				cp 'q' 
0a4a 28 0b				jr z, .goback 
0a4c			 
0a4c fe 0b				cp KEY_LEFT 
0a4e 28 07				jr z, .goback 
0a50 fe 08				cp KEY_BS 
0a52 28 03				jr z, .goback 
0a54 c3 c2 09				jp .mloop 
0a57			 
0a57			.goback: 
0a57 3e 00			ld a, 0 
0a59 18 1d			jr .goend2 
0a5b			 
0a5b				; move up one 
0a5b			.mgoup: 
0a5b 3a 61 eb				ld a, (store_tmp2) 
0a5e fe 00				cp 0 
0a60 ca c2 09				jp z, .mloop 
0a63 3d					dec a 
0a64 32 61 eb				ld (store_tmp2), a 
0a67 c3 c2 09				jp .mloop 
0a6a			 
0a6a				; move down one 
0a6a			.mgod: 
0a6a 3a 61 eb				ld a, (store_tmp2) 
0a6d 3c					inc a 
0a6e 32 61 eb				ld (store_tmp2), a 
0a71 c3 c2 09				jp .mloop 
0a74			 
0a74			 
0a74			.goend: 
0a74					; get selected item number 
0a74			 
0a74 3a 61 eb				ld a, (store_tmp2) 
0a77 3c					inc a 
0a78			 
0a78			.goend2: 
0a78 f5					push af 
0a79			 
0a79					; restore active fb 
0a79					; TODO BUG assumes fb1 
0a79			 
0a79 21 1f ed				ld hl, display_fb1 
0a7c 22 db eb				ld (display_fb_active), hl 
0a7f			 
0a7f					; restore main regs 
0a7f			 
0a7f			 
0a7f cd a8 09				call update_display 
0a82			 
0a82 f1					pop af 
0a83			 
0a83 c9				ret 
0a84			 
0a84 .. 00		.msel:   db ">",0 
0a86 .. 00		.mup:   db "^",0 
0a88 .. 00		.mdown:   db "v",0 
0a8a			 
0a8a			 
0a8a			; eof 
0a8a			 
# End of file firmware_display.asm
0a8a			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0a8a			; random number generators 
0a8a			 
0a8a			 
0a8a			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0a8a			 
0a8a			 
0a8a			;-----> Generate a random number 
0a8a			; output a=answer 0<=a<=255 
0a8a			; all registers are preserved except: af 
0a8a			random: 
0a8a e5			        push    hl 
0a8b d5			        push    de 
0a8c 2a bd eb		        ld      hl,(randData) 
0a8f ed 5f		        ld      a,r 
0a91 57			        ld      d,a 
0a92 5e			        ld      e,(hl) 
0a93 19			        add     hl,de 
0a94 85			        add     a,l 
0a95 ac			        xor     h 
0a96 22 bd eb		        ld      (randData),hl 
0a99 d1			        pop     de 
0a9a e1			        pop     hl 
0a9b c9			        ret 
0a9c			 
0a9c			 
0a9c			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0a9c			 
0a9c			 
0a9c			 
0a9c			;------LFSR------ 
0a9c			;James Montelongo 
0a9c			;optimized by Spencer Putt 
0a9c			;out: 
0a9c			; a = 8 bit random number 
0a9c			RandLFSR: 
0a9c 21 c3 eb		        ld hl,LFSRSeed+4 
0a9f 5e			        ld e,(hl) 
0aa0 23			        inc hl 
0aa1 56			        ld d,(hl) 
0aa2 23			        inc hl 
0aa3 4e			        ld c,(hl) 
0aa4 23			        inc hl 
0aa5 7e			        ld a,(hl) 
0aa6 47			        ld b,a 
0aa7 cb 13		        rl e  
0aa9 cb 12			rl d 
0aab cb 11		        rl c  
0aad 17				rla 
0aae cb 13		        rl e  
0ab0 cb 12			rl d 
0ab2 cb 11		        rl c  
0ab4 17				rla 
0ab5 cb 13		        rl e  
0ab7 cb 12			rl d 
0ab9 cb 11		        rl c  
0abb 17				rla 
0abc 67			        ld h,a 
0abd cb 13		        rl e  
0abf cb 12			rl d 
0ac1 cb 11		        rl c  
0ac3 17				rla 
0ac4 a8			        xor b 
0ac5 cb 13		        rl e  
0ac7 cb 12			rl d 
0ac9 ac			        xor h 
0aca a9			        xor c 
0acb aa			        xor d 
0acc 21 c5 eb		        ld hl,LFSRSeed+6 
0acf 11 c6 eb		        ld de,LFSRSeed+7 
0ad2 01 07 00		        ld bc,7 
0ad5 ed b8		        lddr 
0ad7 12			        ld (de),a 
0ad8 c9			        ret 
0ad9			 
0ad9			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ad9			 
0ad9			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ad9			 
0ad9			 
0ad9			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ad9			 
0ad9			prng16: 
0ad9			;Inputs: 
0ad9			;   (seed1) contains a 16-bit seed value 
0ad9			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ad9			;Outputs: 
0ad9			;   HL is the result 
0ad9			;   BC is the result of the LCG, so not that great of quality 
0ad9			;   DE is preserved 
0ad9			;Destroys: 
0ad9			;   AF 
0ad9			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ad9			;160cc 
0ad9			;26 bytes 
0ad9 2a b7 eb		    ld hl,(seed1) 
0adc 44			    ld b,h 
0add 4d			    ld c,l 
0ade 29			    add hl,hl 
0adf 29			    add hl,hl 
0ae0 2c			    inc l 
0ae1 09			    add hl,bc 
0ae2 22 b7 eb		    ld (seed1),hl 
0ae5 2a b5 eb		    ld hl,(seed2) 
0ae8 29			    add hl,hl 
0ae9 9f			    sbc a,a 
0aea e6 2d		    and %00101101 
0aec ad			    xor l 
0aed 6f			    ld l,a 
0aee 22 b5 eb		    ld (seed2),hl 
0af1 09			    add hl,bc 
0af2 c9			    ret 
0af3			 
0af3			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0af3			 
0af3			rand32: 
0af3			;Inputs: 
0af3			;   (seed1_0) holds the lower 16 bits of the first seed 
0af3			;   (seed1_1) holds the upper 16 bits of the first seed 
0af3			;   (seed2_0) holds the lower 16 bits of the second seed 
0af3			;   (seed2_1) holds the upper 16 bits of the second seed 
0af3			;   **NOTE: seed2 must be non-zero 
0af3			;Outputs: 
0af3			;   HL is the result 
0af3			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0af3			;Destroys: 
0af3			;   AF 
0af3			;Tested and passes all CAcert tests 
0af3			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0af3			;it has a period of 18,446,744,069,414,584,320 
0af3			;roughly 18.4 quintillion. 
0af3			;LFSR taps: 0,2,6,7  = 11000101 
0af3			;291cc 
0af3			;seed1_0=$+1 
0af3			;    ld hl,12345 
0af3			;seed1_1=$+1 
0af3			;    ld de,6789 
0af3			;    ld b,h 
0af3			;    ld c,l 
0af3			;    add hl,hl \ rl e \ rl d 
0af3			;    add hl,hl \ rl e \ rl d 
0af3			;    inc l 
0af3			;    add hl,bc 
0af3			;    ld (seed1_0),hl 
0af3			;    ld hl,(seed1_1) 
0af3			;    adc hl,de 
0af3			;    ld (seed1_1),hl 
0af3			;    ex de,hl 
0af3			;seed2_0=$+1 
0af3			;    ld hl,9876 
0af3			;seed2_1=$+1 
0af3			;    ld bc,54321 
0af3			;    add hl,hl \ rl c \ rl b 
0af3			;    ld (seed2_1),bc 
0af3			;    sbc a,a 
0af3			;    and %11000101 
0af3			;    xor l 
0af3			;    ld l,a 
0af3			;    ld (seed2_0),hl 
0af3			;    ex de,hl 
0af3			;    add hl,bc 
0af3			;    ret 
0af3			; 
0af3			 
0af3			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0af3			; 20 bytes, 86 cycles (excluding ret) 
0af3			 
0af3			; returns   hl = pseudorandom number 
0af3			; corrupts   a 
0af3			 
0af3			; generates 16-bit pseudorandom numbers with a period of 65535 
0af3			; using the xorshift method: 
0af3			 
0af3			; hl ^= hl << 7 
0af3			; hl ^= hl >> 9 
0af3			; hl ^= hl << 8 
0af3			 
0af3			; some alternative shift triplets which also perform well are: 
0af3			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0af3			 
0af3			;  org 32768 
0af3			 
0af3			xrnd: 
0af3 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
0af6 3e 00		  ld a,0 
0af8 bd			  cp l 
0af9 20 02		  jr nz, .xrnd1 
0afb 2e 01		  ld l, 1 
0afd			.xrnd1: 
0afd			 
0afd 7c			  ld a,h 
0afe 1f			  rra 
0aff 7d			  ld a,l 
0b00 1f			  rra 
0b01 ac			  xor h 
0b02 67			  ld h,a 
0b03 7d			  ld a,l 
0b04 1f			  rra 
0b05 7c			  ld a,h 
0b06 1f			  rra 
0b07 ad			  xor l 
0b08 6f			  ld l,a 
0b09 ac			  xor h 
0b0a 67			  ld h,a 
0b0b			 
0b0b 22 bb eb		  ld (xrandc),hl 
0b0e			 
0b0e c9			  ret 
0b0f			;  
0b0f			 
0b0f			 
0b0f			;;;; int maths 
0b0f			 
0b0f			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b0f			; Divide 16-bit values (with 16-bit result) 
0b0f			; In: Divide BC by divider DE 
0b0f			; Out: BC = result, HL = rest 
0b0f			; 
0b0f			Div16: 
0b0f 21 00 00		    ld hl,0 
0b12 78			    ld a,b 
0b13 06 08		    ld b,8 
0b15			Div16_Loop1: 
0b15 17			    rla 
0b16 ed 6a		    adc hl,hl 
0b18 ed 52		    sbc hl,de 
0b1a 30 01		    jr nc,Div16_NoAdd1 
0b1c 19			    add hl,de 
0b1d			Div16_NoAdd1: 
0b1d 10 f6		    djnz Div16_Loop1 
0b1f 17			    rla 
0b20 2f			    cpl 
0b21 47			    ld b,a 
0b22 79			    ld a,c 
0b23 48			    ld c,b 
0b24 06 08		    ld b,8 
0b26			Div16_Loop2: 
0b26 17			    rla 
0b27 ed 6a		    adc hl,hl 
0b29 ed 52		    sbc hl,de 
0b2b 30 01		    jr nc,Div16_NoAdd2 
0b2d 19			    add hl,de 
0b2e			Div16_NoAdd2: 
0b2e 10 f6		    djnz Div16_Loop2 
0b30 17			    rla 
0b31 2f			    cpl 
0b32 41			    ld b,c 
0b33 4f			    ld c,a 
0b34 c9			ret 
0b35			 
0b35			 
0b35			;http://z80-heaven.wikidot.com/math 
0b35			; 
0b35			;Inputs: 
0b35			;     DE and A are factors 
0b35			;Outputs: 
0b35			;     A is not changed 
0b35			;     B is 0 
0b35			;     C is not changed 
0b35			;     DE is not changed 
0b35			;     HL is the product 
0b35			;Time: 
0b35			;     342+6x 
0b35			; 
0b35			Mult16: 
0b35			 
0b35 06 08		     ld b,8          ;7           7 
0b37 21 00 00		     ld hl,0         ;10         10 
0b3a 29			       add hl,hl     ;11*8       88 
0b3b 07			       rlca          ;4*8        32 
0b3c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b3e 19			         add hl,de   ;--         -- 
0b3f 10 f9		       djnz $-5      ;13*7+8     99 
0b41 c9			ret 
0b42			 
0b42			; 
0b42			; Square root of 16-bit value 
0b42			; In:  HL = value 
0b42			; Out:  D = result (rounded down) 
0b42			; 
0b42			;Sqr16: 
0b42			;    ld de,#0040 
0b42			;    ld a,l 
0b42			;    ld l,h 
0b42			;    ld h,d 
0b42			;    or a 
0b42			;    ld b,8 
0b42			;Sqr16_Loop: 
0b42			;    sbc hl,de 
0b42			;    jr nc,Sqr16_Skip 
0b42			;    add hl,de 
0b42			;Sqr16_Skip: 
0b42			;    ccf 
0b42			;    rl d 
0b42			;    add a,a 
0b42			;    adc hl,hl 
0b42			;    add a,a 
0b42			;    adc hl,hl 
0b42			;    djnz Sqr16_Loop 
0b42			;    ret 
0b42			; 
0b42			; 
0b42			; Divide 8-bit values 
0b42			; In: Divide E by divider C 
0b42			; Out: A = result, B = rest 
0b42			; 
0b42			Div8: 
0b42 af			    xor a 
0b43 06 08		    ld b,8 
0b45			Div8_Loop: 
0b45 cb 13		    rl e 
0b47 17			    rla 
0b48 91			    sub c 
0b49 30 01		    jr nc,Div8_NoAdd 
0b4b 81			    add a,c 
0b4c			Div8_NoAdd: 
0b4c 10 f7		    djnz Div8_Loop 
0b4e 47			    ld b,a 
0b4f 7b			    ld a,e 
0b50 17			    rla 
0b51 2f			    cpl 
0b52 c9			    ret 
0b53			 
0b53			; 
0b53			; Multiply 8-bit value with a 16-bit value (unrolled) 
0b53			; In: Multiply A with DE 
0b53			; Out: HL = result 
0b53			; 
0b53			Mult12U: 
0b53 2e 00		    ld l,0 
0b55 87			    add a,a 
0b56 30 01		    jr nc,Mult12U_NoAdd0 
0b58 19			    add hl,de 
0b59			Mult12U_NoAdd0: 
0b59 29			    add hl,hl 
0b5a 87			    add a,a 
0b5b 30 01		    jr nc,Mult12U_NoAdd1 
0b5d 19			    add hl,de 
0b5e			Mult12U_NoAdd1: 
0b5e 29			    add hl,hl 
0b5f 87			    add a,a 
0b60 30 01		    jr nc,Mult12U_NoAdd2 
0b62 19			    add hl,de 
0b63			Mult12U_NoAdd2: 
0b63 29			    add hl,hl 
0b64 87			    add a,a 
0b65 30 01		    jr nc,Mult12U_NoAdd3 
0b67 19			    add hl,de 
0b68			Mult12U_NoAdd3: 
0b68 29			    add hl,hl 
0b69 87			    add a,a 
0b6a 30 01		    jr nc,Mult12U_NoAdd4 
0b6c 19			    add hl,de 
0b6d			Mult12U_NoAdd4: 
0b6d 29			    add hl,hl 
0b6e 87			    add a,a 
0b6f 30 01		    jr nc,Mult12U_NoAdd5 
0b71 19			    add hl,de 
0b72			Mult12U_NoAdd5: 
0b72 29			    add hl,hl 
0b73 87			    add a,a 
0b74 30 01		    jr nc,Mult12U_NoAdd6 
0b76 19			    add hl,de 
0b77			Mult12U_NoAdd6: 
0b77 29			    add hl,hl 
0b78 87			    add a,a 
0b79 d0			    ret nc 
0b7a 19			    add hl,de 
0b7b c9			    ret 
0b7c			 
0b7c			; 
0b7c			; Multiply 8-bit value with a 16-bit value (right rotating) 
0b7c			; In: Multiply A with DE 
0b7c			;      Put lowest value in A for most efficient calculation 
0b7c			; Out: HL = result 
0b7c			; 
0b7c			Mult12R: 
0b7c 21 00 00		    ld hl,0 
0b7f			Mult12R_Loop: 
0b7f cb 3f		    srl a 
0b81 30 01		    jr nc,Mult12R_NoAdd 
0b83 19			    add hl,de 
0b84			Mult12R_NoAdd: 
0b84 cb 23		    sla e 
0b86 cb 12		    rl d 
0b88 b7			    or a 
0b89 c2 7f 0b		    jp nz,Mult12R_Loop 
0b8c c9			    ret 
0b8d			 
0b8d			; 
0b8d			; Multiply 16-bit values (with 32-bit result) 
0b8d			; In: Multiply BC with DE 
0b8d			; Out: BCHL = result 
0b8d			; 
0b8d			Mult32: 
0b8d 79			    ld a,c 
0b8e 48			    ld c,b 
0b8f 21 00 00		    ld hl,0 
0b92 06 10		    ld b,16 
0b94			Mult32_Loop: 
0b94 29			    add hl,hl 
0b95 17			    rla 
0b96 cb 11		    rl c 
0b98 30 07		    jr nc,Mult32_NoAdd 
0b9a 19			    add hl,de 
0b9b ce 00		    adc a,0 
0b9d d2 a1 0b		    jp nc,Mult32_NoAdd 
0ba0 0c			    inc c 
0ba1			Mult32_NoAdd: 
0ba1 10 f1		    djnz Mult32_Loop 
0ba3 41			    ld b,c 
0ba4 4f			    ld c,a 
0ba5 c9			    ret 
0ba6			 
0ba6			 
0ba6			 
0ba6			; 
0ba6			; Multiply 8-bit values 
0ba6			; In:  Multiply H with E 
0ba6			; Out: HL = result 
0ba6			; 
0ba6			Mult8: 
0ba6 16 00		    ld d,0 
0ba8 6a			    ld l,d 
0ba9 06 08		    ld b,8 
0bab			Mult8_Loop: 
0bab 29			    add hl,hl 
0bac 30 01		    jr nc,Mult8_NoAdd 
0bae 19			    add hl,de 
0baf			Mult8_NoAdd: 
0baf 10 fa		    djnz Mult8_Loop 
0bb1 c9			    ret 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			;;http://z80-heaven.wikidot.com/math 
0bb2			;;This divides DE by BC, storing the result in DE, remainder in HL 
0bb2			; 
0bb2			;DE_Div_BC:          ;1281-2x, x is at most 16 
0bb2			;     ld a,16        ;7 
0bb2			;     ld hl,0        ;10 
0bb2			;     jp $+5         ;10 
0bb2			;.DivLoop: 
0bb2			;       add hl,bc    ;-- 
0bb2			;       dec a        ;64 
0bb2			;       jr z,.DivLoopEnd        ;86 
0bb2			; 
0bb2			;       sla e        ;128 
0bb2			;       rl d         ;128 
0bb2			;       adc hl,hl    ;240 
0bb2			;       sbc hl,bc    ;240 
0bb2			;       jr nc,.DivLoop ;23|21 
0bb2			;       inc e        ;-- 
0bb2			;       jp .DivLoop+1 
0bb2			; 
0bb2			;.DivLoopEnd: 
0bb2			 
0bb2			;HL_Div_C: 
0bb2			;Inputs: 
0bb2			;     HL is the numerator 
0bb2			;     C is the denominator 
0bb2			;Outputs: 
0bb2			;     A is the remainder 
0bb2			;     B is 0 
0bb2			;     C is not changed 
0bb2			;     DE is not changed 
0bb2			;     HL is the quotient 
0bb2			; 
0bb2			;       ld b,16 
0bb2			;       xor a 
0bb2			;         add hl,hl 
0bb2			;         rla 
0bb2			;         cp c 
0bb2			;         jr c,$+4 
0bb2			;           inc l 
0bb2			;           sub c 
0bb2			;         djnz $-7 
0bb2			 
0bb2			; https://plutiedev.com/z80-add-8bit-to-16bit 
0bb2			 
0bb2			addatohl: 
0bb2 85			    add   a, l    ; A = A+L 
0bb3 6f			    ld    l, a    ; L = A+L 
0bb4 8c			    adc   a, h    ; A = A+L+H+carry 
0bb5 95			    sub   l       ; A = H+carry 
0bb6 67			    ld    h, a    ; H = H+carry 
0bb7 c9			ret 
0bb8			 
0bb8			addatode: 
0bb8 83			    add   a, e    ; A = A+L 
0bb9 5f			    ld    e, a    ; L = A+L 
0bba 8a			    adc   a, d    ; A = A+L+H+carry 
0bbb 93			    sub   e       ; A = H+carry 
0bbc 57			    ld    d, a    ; H = H+carry 
0bbd c9			ret 
0bbe			 
0bbe			 
0bbe			addatobc: 
0bbe 81			    add   a, c    ; A = A+L 
0bbf 4f			    ld    c, a    ; L = A+L 
0bc0 88			    adc   a, b    ; A = A+L+H+carry 
0bc1 91			    sub   c       ; A = H+carry 
0bc2 47			    ld    b, a    ; H = H+carry 
0bc3 c9			ret 
0bc4			 
0bc4			subafromhl: 
0bc4			   ; If A=0 do nothing 
0bc4			    ; Otherwise flip A's sign. Since 
0bc4			    ; the upper byte becomes -1, also 
0bc4			    ; substract 1 from H. 
0bc4 ed 44		    neg 
0bc6 ca cf 0b		    jp    z, Skip 
0bc9 25			    dec   h 
0bca			     
0bca			    ; Now add the low byte as usual 
0bca			    ; Two's complement takes care of 
0bca			    ; ensuring the result is correct 
0bca 85			    add   a, l 
0bcb 6f			    ld    l, a 
0bcc 8c			    adc   a, h 
0bcd 95			    sub   l 
0bce 67			    ld    h, a 
0bcf			Skip: 
0bcf c9				ret 
0bd0			 
0bd0			 
0bd0			; compare hl and de 
0bd0			; returns:  
0bd0			; if hl = de, z=1, s=0, c0=0 
0bd0			; if hl > de, z=0, s=0, c=0 
0bd0			; if hl < de, z=0, s=1, c=1 
0bd0			cmp16:	 
0bd0 b7				or a 
0bd1 ed 52			sbc hl,de 
0bd3 e0				ret po 
0bd4 7c				ld a,h 
0bd5 1f				rra 
0bd6 ee 40			xor 01000000B 
0bd8 37				scf 
0bd9 8f				adc a,a 
0bda c9				ret 
0bdb			 
0bdb			 
0bdb			; test if hl contains zero   - A is destroyed 
0bdb			 
0bdb			ishlzero:    
0bdb b7				or a     ; reset flags 
0bdc 7c				ld a, h 
0bdd b5				or l        	 
0bde			 
0bde c9				ret 
0bdf			 
0bdf			 
0bdf			 
0bdf			 
0bdf			if FORTH_ENABLE_FLOATMATH 
0bdf			;include "float/bbcmath.z80" 
0bdf			include "float/lpfpcalc.asm" 
0bdf			endif 
0bdf			 
0bdf			 
0bdf			; eof 
0bdf			 
# End of file firmware_maths.asm
0bdf			include "firmware_strings.asm"   ; string handling  
0bdf			 
0bdf			 
0bdf			; TODO string len 
0bdf			; input text string, end on cr with zero term 
0bdf			; a offset into frame buffer to start prompt 
0bdf			; d is max length 
0bdf			; e is display size TODO 
0bdf			; c is current cursor position 
0bdf			; hl is ptr to where string will be stored 
0bdf			 
0bdf			 
0bdf			; TODO check limit of buffer for new inserts 
0bdf			; TODO check insert does not push beyond buffer 
0bdf			; TODO scroll in a limited display area 
0bdf			; TODO scroll whole screen on page wrap 
0bdf			 
0bdf			 
0bdf			; TODO handle KEY_PREVWORD 
0bdf			; TODO handle KEY_NEXTWORD 
0bdf			; TODO handle KEY_HOME 
0bdf			; TODO handle KEY_END 
0bdf			; TODO use LCD cursor? 
0bdf			 
0bdf 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0be2 81					add c 
0be3 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0be6 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
0be9 79					ld a, c 
0bea cd b2 0b				call addatohl 
0bed 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0bf0 7a					ld a,d 
0bf1 32 75 ee			        ld (input_size), a       ; save length of input area 
0bf4 79					ld a, c 
0bf5 32 64 ee				ld (input_cursor),a      ; init cursor start position  
0bf8 7b					ld a,e 
0bf9 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0bfc					 
0bfc					 
0bfc			 
0bfc			;		ld a,(input_ptr) 
0bfc			;		ld (input_under_cursor),a 	; save what is under the cursor 
0bfc			 
0bfc			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0bfc					; init cursor shape if not set by the cin routines 
0bfc 21 d3 eb				ld hl, cursor_shape 
0bff 3e ff				ld a, 255 
0c01 77					ld (hl), a 
0c02 23					inc hl 
0c03 3e 00				ld a, 0 
0c05 77					ld (hl), a 
0c06			 
0c06 3e 0f				ld a, CUR_BLINK_RATE 
0c08 32 6f ee				ld (input_cur_flash), a 
0c0b 3e 01				ld a, 1 
0c0d 32 6e ee				ld (input_cur_onoff),a 
0c10			 
0c10			;	if DEBUG_INPUT 
0c10			;		push af 
0c10			;		ld a, 'I' 
0c10			;		ld (debug_mark),a 
0c10			;		pop af 
0c10			;		CALLMONITOR 
0c10			;	endif 
0c10			.is1:		; main entry loop 
0c10			 
0c10			 
0c10			 
0c10					; pause 1ms 
0c10			 
0c10 3e 01				ld a, 1 
0c12 cd df 08				call aDelayInMS 
0c15			 
0c15					; dec flash counter 
0c15 3a 6f ee				ld a, (input_cur_flash) 
0c18 3d					dec a 
0c19 32 6f ee				ld (input_cur_flash), a 
0c1c fe 00				cp 0 
0c1e 20 0d				jr nz, .nochgstate 
0c20			 
0c20			 
0c20					; change state 
0c20 3a 6e ee				ld a,(input_cur_onoff) 
0c23 ed 44				neg 
0c25 32 6e ee				ld (input_cur_onoff),a 
0c28			 
0c28			 
0c28					; reset on change of state 
0c28 3e 0f				ld a, CUR_BLINK_RATE 
0c2a 32 6f ee				ld (input_cur_flash), a 
0c2d			 
0c2d			.nochgstate: 
0c2d					 
0c2d					 
0c2d			 
0c2d					; display cursor  
0c2d			 
0c2d			;		ld hl, (input_start) 
0c2d			;		ld a, (input_cursor) 
0c2d			;		call addatohl 
0c2d			 
0c2d					; get char under cursor and replace with cursor 
0c2d 2a 78 ee		ld hl, (input_ptr) 
0c30			;		ld a, (hl) 
0c30			;		ld (input_under_cursor),a 
0c30			;		ld a, '_' 
0c30			;		ld (hl), a 
0c30			 
0c30					; display string 
0c30			 
0c30 ed 5b 76 ee			ld de, (input_start) 
0c34 3a 73 ee				ld a, (input_at_pos) 
0c37 cd 98 09				call str_at_display 
0c3a			;	        call update_display 
0c3a			 
0c3a					; find place to put the cursor 
0c3a			;		add h 
0c3a			;		ld l, display_row_1 
0c3a			;		sub l 
0c3a			; (input_at_pos) 
0c3a					;ld c, a 
0c3a			;		ld a, (input_cursor) 
0c3a			;		ld l, (input_at_pos) 
0c3a			;		;ld b, h 
0c3a			;		add l 
0c3a			;		ld (input_at_cursor),a 
0c3a					;ld l,h 
0c3a			 
0c3a			;		ld h, 0 
0c3a			;		ld l,(input_at_pos) 
0c3a			;		ld a, (input_cursor) 
0c3a			;		call addatohl 
0c3a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c3a			;		call subafromhl 
0c3a			;		ld a,l 
0c3a			;		ld (input_at_cursor), a 
0c3a			 
0c3a				if DEBUG_INPUT 
0c3a					ld a, (hardware_diag) 
0c3a					cp 0 
0c3a					jr z, .skip_input_diag 
0c3a			 
0c3a					ld a,(input_at_pos) 
0c3a					ld hl, LFSRSeed 
0c3a					call hexout 
0c3a					ld a, (input_cursor) 
0c3a					ld hl, LFSRSeed+2 
0c3a					call hexout 
0c3a					ld a,(input_at_cursor) 
0c3a					ld hl, LFSRSeed+4 
0c3a					call hexout 
0c3a			 
0c3a					ld a,(input_cur_onoff) 
0c3a					ld hl, LFSRSeed+6 
0c3a					call hexout 
0c3a			 
0c3a					ld a,(input_cur_flash) 
0c3a					ld hl, LFSRSeed+8 
0c3a					call hexout 
0c3a			 
0c3a					ld a,(input_len) 
0c3a					ld hl, LFSRSeed+10 
0c3a					call hexout 
0c3a					ld hl, LFSRSeed+12 
0c3a					ld a, 0 
0c3a					ld (hl),a 
0c3a					ld a, display_row_4 
0c3a					ld de, LFSRSeed 
0c3a					call str_at_display 
0c3a					.skip_input_diag: 
0c3a				endif 
0c3a			 
0c3a					; decide on if we are showing the cursor this time round 
0c3a			 
0c3a 3a 6e ee				ld a, (input_cur_onoff) 
0c3d fe ff				cp 255 
0c3f 28 13				jr z, .skipcur 
0c41			 
0c41			 
0c41 3a 71 ee				ld a,(input_at_cursor) 
0c44 11 d3 eb				ld de, cursor_shape 
0c47 cd 98 09				call str_at_display 
0c4a			 
0c4a					; save length of current input string 
0c4a 2a 76 ee				ld hl, (input_start) 
0c4d cd 10 10				call strlenz 
0c50 7d					ld a,l 
0c51 32 69 ee				ld (input_len),a 
0c54			 
0c54			.skipcur: 
0c54			 
0c54 cd a8 09			        call update_display 
0c57					 
0c57			 
0c57			 
0c57					; wait 
0c57				 
0c57					; TODO loop without wait to flash the cursor and char under cursor	 
0c57 cd cd 59				call cin    ; _wait 
0c5a			 
0c5a fe 00				cp 0 
0c5c ca 10 0c				jp z, .is1 
0c5f			 
0c5f					; get ptr to char to input into 
0c5f			 
0c5f 4f					ld c,a 
0c60 2a 76 ee				ld hl, (input_start) 
0c63 3a 64 ee				ld a, (input_cursor) 
0c66 cd b2 0b				call addatohl 
0c69 22 78 ee				ld (input_ptr), hl 
0c6c 79					ld a,c 
0c6d			 
0c6d					; replace char under cursor 
0c6d			 
0c6d			;		ld hl, (input_ptr) 
0c6d			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0c6d			;		ld (hl), a 
0c6d			 
0c6d			;	if DEBUG_INPUT 
0c6d			;		push af 
0c6d			;		ld a, 'i' 
0c6d			;		ld (debug_mark),a 
0c6d			;		pop af 
0c6d			;		CALLMONITOR 
0c6d			;	endif 
0c6d fe 0e				cp KEY_HOME 
0c6f 20 0e				jr nz, .iske 
0c71			 
0c71 3a 73 ee				ld a, (input_at_pos) 
0c74 32 71 ee				ld (input_at_cursor),a 
0c77 3e 00				ld a, 0 
0c79 32 64 ee				ld (input_cursor), a 
0c7c c3 10 0c				jp .is1 
0c7f					 
0c7f fe 0f		.iske:		cp KEY_END 
0c81 20 03				jr nz, .isknw 
0c83 c3 10 0c				jp .is1 
0c86			 
0c86 fe 06		.isknw:		cp KEY_NEXTWORD 
0c88 20 1b				jr nz, .iskpw 
0c8a			 
0c8a 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
0c8d 7e					ld a,(hl)	 
0c8e fe 00				cp 0 
0c90 ca 10 0c				jp z, .is1    ; end of string 
0c93 fe 20				cp ' ' 
0c95 ca 10 0c				jp z, .is1    ; end of word 
0c98 23					inc hl 
0c99 22 78 ee				ld (input_ptr), hl 
0c9c 3a 71 ee				ld a, (input_at_cursor) 
0c9f 3c					inc a 
0ca0 32 71 ee				ld (input_at_cursor), a 
0ca3 18 e5				jr .isknwm 
0ca5			 
0ca5 fe 07		.iskpw:		cp KEY_PREVWORD 
0ca7 20 1b				jr nz, .iskl 
0ca9			.iskpwm:	 
0ca9 2a 78 ee				ld hl, (input_ptr) 
0cac 7e					ld a,(hl)	 
0cad fe 00				cp 0  
0caf ca 10 0c				jp z, .is1    ; end of string 
0cb2 fe 20				cp ' ' 
0cb4 ca 10 0c				jp z, .is1    ; end of word 
0cb7 2b					dec hl 
0cb8 22 78 ee				ld (input_ptr), hl 
0cbb 3a 71 ee				ld a, (input_at_cursor) 
0cbe 3d					dec a 
0cbf 32 71 ee				ld (input_at_cursor), a 
0cc2 18 e5				jr .iskpwm 
0cc4			 
0cc4			 
0cc4 fe 0b		.iskl:		cp KEY_LEFT 
0cc6 20 27				jr nz, .isk1 
0cc8			 
0cc8 3a 64 ee				ld a, (input_cursor) 
0ccb			 
0ccb fe 00				cp 0 
0ccd ca 10 0c				jp z, .is1 		; at start of line to ignore  
0cd0			 
0cd0 3d					dec  a 		; TODO check underflow 
0cd1 32 64 ee				ld (input_cursor), a 
0cd4			 
0cd4 2a 78 ee				ld hl, (input_ptr) 
0cd7 2b					dec hl 
0cd8 22 78 ee				ld (input_ptr), hl 
0cdb					 
0cdb 3a 71 ee				ld a, (input_at_cursor) 
0cde 3d					dec a 
0cdf 32 71 ee				ld (input_at_cursor), a 
0ce2			 
0ce2 3e 01				ld a, 1		; show cursor moving 
0ce4 32 6e ee				ld (input_cur_onoff),a 
0ce7 3e 0f				ld a, CUR_BLINK_RATE 
0ce9 32 6f ee				ld (input_cur_flash), a 
0cec			 
0cec c3 10 0c				jp .is1 
0cef			 
0cef fe 0c		.isk1:		cp KEY_RIGHT 
0cf1 20 2a				jr nz, .isk2 
0cf3			 
0cf3 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0cf6 5f					ld e,a 
0cf7 3a 64 ee				ld a, (input_cursor) 
0cfa bb					cp e 
0cfb ca 10 0c				jp z, .is1		; at the end of string so dont go right 
0cfe			 
0cfe 3c					inc  a 		; TODO check overflow 
0cff 32 64 ee				ld (input_cursor), a 
0d02			 
0d02 3a 71 ee				ld a, (input_at_cursor) 
0d05 3c					inc a 
0d06 32 71 ee				ld (input_at_cursor), a 
0d09			 
0d09 2a 78 ee				ld hl, (input_ptr) 
0d0c 23					inc hl 
0d0d 22 78 ee				ld (input_ptr), hl 
0d10			 
0d10 3e 01				ld a, 1		; show cursor moving 
0d12 32 6e ee				ld (input_cur_onoff),a 
0d15 3e 0f				ld a, CUR_BLINK_RATE 
0d17 32 6f ee				ld (input_cur_flash), a 
0d1a			 
0d1a c3 10 0c				jp .is1 
0d1d			 
0d1d fe 05		.isk2:		cp KEY_UP 
0d1f			 
0d1f 20 26				jr nz, .isk3 
0d21			 
0d21					; swap last command with the current on 
0d21			 
0d21					; move cursor to start of string 
0d21 2a 76 ee				ld hl, (input_start) 
0d24 22 78 ee				ld (input_ptr), hl 
0d27			 
0d27 3a 73 ee				ld a, (input_at_pos) 
0d2a 32 71 ee				ld (input_at_cursor), a 
0d2d			 
0d2d 3e 00				ld a, 0 
0d2f 32 64 ee				ld (input_cursor), a 
0d32					 
0d32					; swap input and last command buffers 
0d32			 
0d32 21 87 e6				ld hl, os_cli_cmd 
0d35 11 86 e7				ld de, os_last_cmd 
0d38 06 ff				ld b, 255 
0d3a 7e			.swap1:		ld a, (hl) 
0d3b 4f					ld c,a 
0d3c 1a					ld a, (de) 
0d3d 77					ld (hl), a 
0d3e 79					ld a,c 
0d3f 12					ld (de),a 
0d40 23					inc hl 
0d41 13					inc de 
0d42 10 f6				djnz .swap1 
0d44			 
0d44			 
0d44			 
0d44			 
0d44			 
0d44 c3 10 0c				jp .is1 
0d47			 
0d47 fe 08		.isk3:		cp KEY_BS 
0d49 20 3c				jr nz, .isk4 
0d4b			 
0d4b 3a 64 ee				ld a, (input_cursor) 
0d4e			 
0d4e fe 00				cp 0 
0d50 ca 10 0c				jp z, .is1 		; at start of line to ignore  
0d53			 
0d53 3d					dec  a 		; TODO check underflow 
0d54 32 64 ee				ld (input_cursor), a 
0d57			 
0d57					; hl is source 
0d57					; de needs to be source - 1 
0d57			 
0d57			;		ld a, 0 
0d57			;		dec hl 
0d57			;		ld (hl), a 
0d57			 
0d57 2a 78 ee				ld hl, (input_ptr) 
0d5a 2b					dec hl 
0d5b 22 78 ee				ld (input_ptr), hl 
0d5e			 
0d5e					; shift all data 
0d5e			 
0d5e e5					push hl 
0d5f 23					inc hl 
0d60 d1					pop de 
0d61 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0d64 4f					ld c,a 
0d65 06 00				ld b,0 
0d67 ed b0				ldir  
0d69			 
0d69			 
0d69			 
0d69			 
0d69 3a 71 ee				ld a, (input_at_cursor) 
0d6c 3d					dec a 
0d6d 32 71 ee				ld (input_at_cursor), a 
0d70			 
0d70			 
0d70 3e 01				ld a, 1		; show cursor moving 
0d72 32 6e ee				ld (input_cur_onoff),a 
0d75 3e 0f				ld a, CUR_BLINK_RATE 
0d77 32 6f ee				ld (input_cur_flash), a 
0d7a			 
0d7a					; remove char 
0d7a 3a 71 ee				ld a, (input_at_cursor) 
0d7d 3c					inc a 
0d7e 11 08 0e				ld de,.iblank 
0d81 cd 98 09				call str_at_display 
0d84			 
0d84 c3 10 0c				jp .is1 
0d87			 
0d87 fe 0d		.isk4:		cp KEY_CR 
0d89 28 6c				jr z, .endinput 
0d8b			 
0d8b					; else add the key press to the end 
0d8b			 
0d8b 4f					ld c, a			; save key pressed 
0d8c			 
0d8c 7e					ld a,(hl)		; get what is currently under char 
0d8d			 
0d8d fe 00				cp 0			; we are at the end of the string 
0d8f 20 2f				jr nz, .onchar 
0d91					 
0d91					; add a char to the end of the string 
0d91				 
0d91 71					ld (hl),c 
0d92 23					inc hl 
0d93			;		ld a,' ' 
0d93			;		ld (hl),a 
0d93			;		inc hl 
0d93 3e 00				ld a,0 
0d95 77					ld (hl),a 
0d96 2b					dec hl 
0d97			 
0d97 3a 64 ee				ld a, (input_cursor) 
0d9a 3c					inc a				; TODO check max string length and scroll  
0d9b 32 64 ee				ld (input_cursor), a		; inc cursor pos 
0d9e							 
0d9e 3a 71 ee				ld a, (input_at_cursor) 
0da1 3c					inc a 
0da2 32 71 ee				ld (input_at_cursor), a 
0da5			 
0da5 2a 78 ee				ld hl, (input_ptr) 
0da8 23					inc hl 
0da9 22 78 ee				ld (input_ptr), hl 
0dac			 
0dac 2a 78 ee				ld hl, (input_ptr) 
0daf 23					inc hl 
0db0 22 78 ee				ld (input_ptr), hl 
0db3			;	if DEBUG_INPUT 
0db3			;		push af 
0db3			;		ld a, '+' 
0db3			;		ld (debug_mark),a 
0db3			;		pop af 
0db3			;		CALLMONITOR 
0db3			;	endif 
0db3 3e 01				ld a, 1		; show cursor moving 
0db5 32 6e ee				ld (input_cur_onoff),a 
0db8 3e 0f				ld a, CUR_BLINK_RATE 
0dba 32 6f ee				ld (input_cur_flash), a 
0dbd c3 10 0c				jp .is1 
0dc0					 
0dc0			 
0dc0			 
0dc0					; if on a char then insert 
0dc0			.onchar: 
0dc0			 
0dc0					; TODO over flow check: make sure insert does not blow out buffer 
0dc0			 
0dc0					; need to do some maths to use lddr 
0dc0			 
0dc0 e5					push hl   ; save char pos 
0dc1 c5					push bc 
0dc2			 
0dc2 2a 76 ee				ld hl, (input_start) 
0dc5 3a 69 ee				ld a, (input_len) 
0dc8 cd b2 0b				call addatohl  		; end of string 
0dcb 23					inc hl 
0dcc 23					inc hl		; past zero term 
0dcd e5					push hl 
0dce 23					inc hl 
0dcf e5					push hl  
0dd0			 
0dd0								; start and end of lddr set, now how much to move? 
0dd0			 
0dd0							 
0dd0 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0dd3 47					ld b,a 
0dd4 3a 69 ee				ld a,(input_len) 
0dd7 5f					ld e,a 
0dd8 90					sub b 
0dd9 3c					inc a		;?? 
0dda 3c					inc a		;?? 
0ddb 3c					inc a		;?? 
0ddc			 
0ddc 06 00				ld b,0 
0dde 4f					ld c,a 
0ddf			 
0ddf				if DEBUG_INPUT 
0ddf					push af 
0ddf					ld a, 'i' 
0ddf					ld (debug_mark),a 
0ddf					pop af 
0ddf			;		CALLMONITOR 
0ddf				endif 
0ddf d1					pop de 
0de0 e1					pop hl 
0de1				if DEBUG_INPUT 
0de1					push af 
0de1					ld a, 'I' 
0de1					ld (debug_mark),a 
0de1					pop af 
0de1			;		CALLMONITOR 
0de1				endif 
0de1 ed b8				lddr 
0de3				 
0de3			 
0de3			 
0de3					; TODO have a key for insert/overwrite mode???? 
0de3 c1					pop bc 
0de4 e1					pop hl 
0de5 71					ld (hl), c		; otherwise overwrite current char 
0de6					 
0de6			 
0de6			 
0de6			 
0de6 3a 64 ee				ld a, (input_cursor) 
0de9 3c					inc  a 		; TODO check overflow 
0dea 32 64 ee				ld (input_cursor), a 
0ded			 
0ded 3a 71 ee				ld a, (input_at_cursor) 
0df0 3c					inc a 
0df1 32 71 ee				ld (input_at_cursor), a 
0df4			 
0df4 c3 10 0c				jp .is1 
0df7			 
0df7			.endinput:	; TODO look for end of string 
0df7			 
0df7					; add trailing space for end of token 
0df7			 
0df7 2a 76 ee				ld hl, (input_start) 
0dfa 3a 69 ee				ld a,(input_len) 
0dfd cd b2 0b				call addatohl 
0e00 3e 20				ld a, ' ' 
0e02 77					ld (hl),a 
0e03					; TODO eof of parse marker 
0e03			 
0e03 23					inc hl 
0e04 3e 00				ld a, 0 
0e06 77					ld (hl),a 
0e07			 
0e07			 
0e07 c9					ret 
0e08			 
0e08 .. 00		.iblank: db " ",0 
0e0a			 
0e0a			 
0e0a 32 73 ee		input_str_prev:	ld (input_at_pos), a 
0e0d 22 76 ee				ld (input_start), hl 
0e10 3e 01				ld a,1			; add cursor 
0e12 77					ld (hl),a 
0e13 23					inc hl 
0e14 3e 00				ld a,0 
0e16 77					ld (hl),a 
0e17 22 78 ee				ld (input_ptr), hl 
0e1a 7a					ld a,d 
0e1b 32 75 ee				ld (input_size), a 
0e1e 3e 00				ld a,0 
0e20 32 64 ee				ld (input_cursor),a 
0e23			.instr1:	 
0e23			 
0e23					; TODO do block cursor 
0e23					; TODO switch cursor depending on the modifer key 
0e23			 
0e23					; update cursor shape change on key hold 
0e23			 
0e23 2a 78 ee				ld hl, (input_ptr) 
0e26 2b					dec hl 
0e27 3a d3 eb				ld a,(cursor_shape) 
0e2a 77					ld (hl), a 
0e2b			 
0e2b					; display entered text 
0e2b 3a 73 ee				ld a,(input_at_pos) 
0e2e cd e2 58		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e31 ed 5b 76 ee	            	LD   de, (input_start) 
0e35 cd d7 58		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e38			 
0e38 cd cd 59				call cin 
0e3b fe 00				cp 0 
0e3d 28 e4				jr z, .instr1 
0e3f			 
0e3f					; proecess keyboard controls first 
0e3f			 
0e3f 2a 78 ee				ld hl,(input_ptr) 
0e42			 
0e42 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0e44 28 5a				jr z, .instrcr 
0e46			 
0e46 fe 08				cp KEY_BS 	; back space 
0e48 20 0f				jr nz, .instr2 
0e4a					; process back space 
0e4a			 
0e4a					; TODO stop back space if at start of string 
0e4a 2b					dec hl 
0e4b 2b					dec hl ; to over write cursor 
0e4c 3a d3 eb				ld a,(cursor_shape) 
0e4f					;ld a,0 
0e4f 77					ld (hl),a 
0e50 23					inc hl 
0e51 3e 20				ld a," " 
0e53 77					ld (hl),a 
0e54 22 78 ee				ld (input_ptr),hl 
0e57					 
0e57			 
0e57 18 ca				jr .instr1 
0e59			 
0e59 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0e5b 20 06				jr nz, .instr3 
0e5d 2b					dec hl 
0e5e 22 78 ee				ld (input_ptr),hl 
0e61 18 c0				jr .instr1 
0e63				 
0e63 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0e65 20 06				jr nz, .instr4 
0e67 23					inc hl 
0e68 22 78 ee				ld (input_ptr),hl 
0e6b 18 b6				jr .instr1 
0e6d			 
0e6d fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0e6f 20 06				jr nz, .instr5 
0e71 2b					dec hl 
0e72 22 78 ee				ld (input_ptr),hl 
0e75 18 ac				jr .instr1 
0e77			 
0e77 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0e79 20 06				jr nz, .instr6 
0e7b 2b					dec hl 
0e7c 22 78 ee				ld (input_ptr),hl 
0e7f 18 a2				jr .instr1 
0e81 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0e83 20 0b				jr nz, .instrnew 
0e85			 
0e85 21 60 e3			ld hl, scratch 
0e88 11 86 e7			ld de, os_last_cmd 
0e8b cd a9 0e			call strcpy 
0e8e 18 93				jr .instr1 
0e90			 
0e90			 
0e90			.instrnew:	; no special key pressed to see if we have room to store it 
0e90			 
0e90					; TODO do string size test 
0e90			 
0e90 2b					dec hl ; to over write cursor 
0e91 77					ld (hl),a 
0e92 23					inc hl 
0e93 3a d3 eb				ld a,(cursor_shape) 
0e96 77					ld (hl),a 
0e97 23					inc hl 
0e98 3e 00				ld a,0 
0e9a 77					ld (hl),a 
0e9b			 
0e9b 22 78 ee				ld (input_ptr),hl 
0e9e					 
0e9e 18 83				jr .instr1 
0ea0 2b			.instrcr:	dec hl		; remove cursor 
0ea1 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ea3 77					ld (hl),a 
0ea4 23					inc hl 
0ea5 3e 00				ld a,0 
0ea7 77					ld (hl),a 
0ea8			 
0ea8			 
0ea8					; if at end of line scroll up    
0ea8					; TODO detecting only end of line 4 for scroll up  
0ea8			 
0ea8					;ld   
0ea8			 
0ea8 c9					ret 
0ea9			 
0ea9			 
0ea9			; strcpy hl = dest, de source 
0ea9			 
0ea9 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0eaa b7			            OR   A              ;Null terminator? 
0eab c8			            RET  Z              ;Yes, so finished 
0eac 1a					ld a,(de) 
0ead 77					ld (hl),a 
0eae 13			            INC  DE             ;Point to next character 
0eaf 23					inc hl 
0eb0 18 f7		            JR   strcpy       ;Repeat 
0eb2 c9					ret 
0eb3			 
0eb3			 
0eb3			; TODO string_at  
0eb3			; pass string which starts with lcd offset address and then null term string 
0eb3			 
0eb3			; TODO string to dec 
0eb3			; TODO string to hex 
0eb3			; TODO byte to string hex 
0eb3			; TODO byte to string dec 
0eb3			 
0eb3			 
0eb3			 
0eb3			; from z80uartmonitor 
0eb3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0eb3			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0eb3			; pass hl for where to put the text 
0eb3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0eb3 c5			hexout:	PUSH BC 
0eb4 f5					PUSH AF 
0eb5 47					LD B, A 
0eb6					; Upper nybble 
0eb6 cb 3f				SRL A 
0eb8 cb 3f				SRL A 
0eba cb 3f				SRL A 
0ebc cb 3f				SRL A 
0ebe cd ce 0e				CALL tohex 
0ec1 77					ld (hl),a 
0ec2 23					inc hl	 
0ec3					 
0ec3					; Lower nybble 
0ec3 78					LD A, B 
0ec4 e6 0f				AND 0FH 
0ec6 cd ce 0e				CALL tohex 
0ec9 77					ld (hl),a 
0eca 23					inc hl	 
0ecb					 
0ecb f1					POP AF 
0ecc c1					POP BC 
0ecd c9					RET 
0ece					 
0ece			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ece			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0ece			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ece			tohex: 
0ece e5					PUSH HL 
0ecf d5					PUSH DE 
0ed0 16 00				LD D, 0 
0ed2 5f					LD E, A 
0ed3 21 db 0e				LD HL, .DATA 
0ed6 19					ADD HL, DE 
0ed7 7e					LD A, (HL) 
0ed8 d1					POP DE 
0ed9 e1					POP HL 
0eda c9					RET 
0edb			 
0edb			.DATA: 
0edb 30					DEFB	30h	; 0 
0edc 31					DEFB	31h	; 1 
0edd 32					DEFB	32h	; 2 
0ede 33					DEFB	33h	; 3 
0edf 34					DEFB	34h	; 4 
0ee0 35					DEFB	35h	; 5 
0ee1 36					DEFB	36h	; 6 
0ee2 37					DEFB	37h	; 7 
0ee3 38					DEFB	38h	; 8 
0ee4 39					DEFB	39h	; 9 
0ee5 41					DEFB	41h	; A 
0ee6 42					DEFB	42h	; B 
0ee7 43					DEFB	43h	; C 
0ee8 44					DEFB	44h	; D 
0ee9 45					DEFB	45h	; E 
0eea 46					DEFB	46h	; F 
0eeb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0eeb			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0eeb			;;    subtract $30, if result > 9 then subtract $7 more 
0eeb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0eeb			atohex: 
0eeb d6 30				SUB $30 
0eed fe 0a				CP 10 
0eef f8					RET M		; If result negative it was 0-9 so we're done 
0ef0 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0ef2 c9					RET		 
0ef3			 
0ef3			 
0ef3			 
0ef3			 
0ef3			; Get 2 ASCII characters as hex byte from pointer in hl 
0ef3			 
0ef3			BYTERD: 
0ef3 16 00			LD	D,00h		;Set up 
0ef5 cd fd 0e			CALL	HEXCON		;Get byte and convert to hex 
0ef8 87				ADD	A,A		;First nibble so 
0ef9 87				ADD	A,A		;multiply by 16 
0efa 87				ADD	A,A		; 
0efb 87				ADD	A,A		; 
0efc 57				LD	D,A		;Save hi nibble in D 
0efd			HEXCON: 
0efd 7e				ld a, (hl)		;Get next chr 
0efe 23				inc hl 
0eff d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0f01 fe 0a			CP	00Ah		;Is it 0-9 ? 
0f03 38 02			JR	C,NALPHA	;If so miss next bit 
0f05 d6 07			SUB	007h		;Else convert alpha 
0f07			NALPHA: 
0f07 b2				OR	D		;Add hi nibble back 
0f08 c9				RET			; 
0f09			 
0f09			 
0f09			; 
0f09			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f09			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f09			; characters (0-9a-f) are accepted. 
0f09			; 
0f09			;get_word        push    af 
0f09			;                call    get_byte        ; Get the upper byte 
0f09			;                ld      h, a 
0f09			;                call    get_byte        ; Get the lower byte 
0f09			;                ld      l, a 
0f09			;                pop     af 
0f09			;                ret 
0f09			; 
0f09			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f09			; the routine get_nibble is used only valid characters are accepted - the  
0f09			; input routine only accepts characters 0-9a-f. 
0f09			; 
0f09 c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f0a 7e					ld a,(hl) 
0f0b 23					inc hl 
0f0c cd 31 0f		                call    nibble2val      ; Get upper nibble 
0f0f cb 07		                rlc     a 
0f11 cb 07		                rlc     a 
0f13 cb 07		                rlc     a 
0f15 cb 07		                rlc     a 
0f17 47			                ld      b, a            ; Save upper four bits 
0f18 7e					ld a,(hl) 
0f19 cd 31 0f		                call    nibble2val      ; Get lower nibble 
0f1c b0			                or      b               ; Combine both nibbles 
0f1d c1			                pop     bc              ; Restore B (and C) 
0f1e c9			                ret 
0f1f			; 
0f1f			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f1f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f1f			; to the serial line interface. The lower 4 bits of A contain the value of  
0f1f			; that particular digit. 
0f1f			; 
0f1f			;get_nibble      ld a,(hl)           ; Read a character 
0f1f			;                call    to_upper        ; Convert to upper case 
0f1f			;                call    is_hex          ; Was it a hex digit? 
0f1f			;                jr      nc, get_nibble  ; No, get another character 
0f1f			 ;               call    nibble2val      ; Convert nibble to value 
0f1f			 ;               call    print_nibble 
0f1f			 ;               ret 
0f1f			; 
0f1f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f1f			; A valid hexadecimal digit is denoted by a set C flag. 
0f1f			; 
0f1f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f1f			;                ret     nc              ; Yes 
0f1f			;                cp      '0'             ; Less than '0'? 
0f1f			;                jr      nc, is_hex_1    ; No, continue 
0f1f			;                ccf                     ; Complement carry (i.e. clear it) 
0f1f			;                ret 
0f1f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f1f			;                ret     c               ; Yes 
0f1f			;                cp      'A'             ; Less than 'A'? 
0f1f			;                jr      nc, is_hex_2    ; No, continue 
0f1f			;                ccf                     ; Yes - clear carry and return 
0f1f			;                ret 
0f1f			;is_hex_2        scf                     ; Set carry 
0f1f			;                ret 
0f1f			; 
0f1f			; Convert a single character contained in A to upper case: 
0f1f			; 
0f1f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f21 d8			                ret     c 
0f22 fe 7b		                cp      'z' + 1         ; > 'z'? 
0f24 d0			                ret     nc              ; Nothing to do, either 
0f25 e6 5f		                and     $5f             ; Convert to upper case 
0f27 c9			                ret 
0f28			 
0f28			 
0f28			to_lower: 
0f28			 
0f28			   ; if char is in [A-Z] make it lower case 
0f28			 
0f28			   ; enter : a = char 
0f28			   ; exit  : a = lower case char 
0f28			   ; uses  : af 
0f28			 
0f28 fe 41		   cp 'A' 
0f2a d8			   ret c 
0f2b			    
0f2b fe 5b		   cp 'Z'+1 
0f2d d0			   ret nc 
0f2e			    
0f2e f6 20		   or $20 
0f30 c9			   ret 
0f31			 
0f31			; 
0f31			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f31			; corresponding value in A. 
0f31			; 
0f31 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f33 38 02		                jr      c, nibble2val_1 ; Yes 
0f35 d6 07		                sub     7               ; Adjust for A-F 
0f37 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f39 e6 0f		                and     $f              ; Only return lower 4 bits 
0f3b c9			                ret 
0f3c			; 
0f3c			; Print_nibble prints a single hex nibble which is contained in the lower  
0f3c			; four bits of A: 
0f3c			; 
0f3c			;print_nibble    push    af              ; We won't destroy the contents of A 
0f3c			;                and     $f              ; Just in case... 
0f3c			;                add     a, '0'             ; If we have a digit we are done here. 
0f3c			;                cp      '9' + 1         ; Is the result > 9? 
0f3c			;                jr      c, print_nibble_1 
0f3c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f3c			;print_nibble_1  call    putc            ; Print the nibble and 
0f3c			;                pop     af              ; restore the original value of A 
0f3c			;                ret 
0f3c			;; 
0f3c			;; Send a CR/LF pair: 
0f3c			; 
0f3c			;crlf            push    af 
0f3c			;                ld      a, cr 
0f3c			;                call    putc 
0f3c			;                ld      a, lf 
0f3c			;                call    putc 
0f3c			;                pop     af 
0f3c			;                ret 
0f3c			; 
0f3c			; Print_word prints the four hex digits of a word to the serial line. The  
0f3c			; word is expected to be in HL. 
0f3c			; 
0f3c			;print_word      push    hl 
0f3c			;                push    af 
0f3c			;                ld      a, h 
0f3c			;                call    print_byte 
0f3c			;                ld      a, l 
0f3c			;                call    print_byte 
0f3c			;                pop     af 
0f3c			;                pop     hl 
0f3c			;                ret 
0f3c			; 
0f3c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f3c			; The byte to be printed is expected to be in A. 
0f3c			; 
0f3c			;print_byte      push    af              ; Save the contents of the registers 
0f3c			;                push    bc 
0f3c			;                ld      b, a 
0f3c			;                rrca 
0f3c			;                rrca 
0f3c			;                rrca 
0f3c			;                rrca 
0f3c			;                call    print_nibble    ; Print high nibble 
0f3c			;                ld      a, b 
0f3c			;                call    print_nibble    ; Print low nibble 
0f3c			;                pop     bc              ; Restore original register contents 
0f3c			;                pop     af 
0f3c			;                ret 
0f3c			 
0f3c			 
0f3c			 
0f3c			 
0f3c			 
0f3c			fourehexhl:  
0f3c 7e				ld a,(hl) 
0f3d cd eb 0e			call atohex 
0f40 cb 3f				SRL A 
0f42 cb 3f				SRL A 
0f44 cb 3f				SRL A 
0f46 cb 3f				SRL A 
0f48 47				ld b, a 
0f49 23				inc hl 
0f4a 7e				ld a,(hl) 
0f4b 23				inc hl 
0f4c cd eb 0e			call atohex 
0f4f 80				add b 
0f50 57				ld d,a 
0f51 7e				ld a,(hl) 
0f52 cd eb 0e			call atohex 
0f55 cb 3f				SRL A 
0f57 cb 3f				SRL A 
0f59 cb 3f				SRL A 
0f5b cb 3f				SRL A 
0f5d 47				ld b, a 
0f5e 23				inc hl 
0f5f 7e				ld a,(hl) 
0f60 23				inc hl 
0f61 cd eb 0e			call atohex 
0f64 80				add b 
0f65 5f				ld e, a 
0f66 d5				push de 
0f67 e1				pop hl 
0f68 c9				ret 
0f69			 
0f69			; pass hl. returns z set if the byte at hl is a digit 
0f69			;isdigithl:  
0f69			;	push bc 
0f69			;	ld a,(hl) 
0f69			;	cp ':' 
0f69			;	jr nc, .isdf 		; > 
0f69			;	cp '0' 
0f69			;	jr c, .isdf		; < 
0f69			; 
0f69			;	; TODO find a better way to set z 
0f69			; 
0f69			;	ld b,a 
0f69			;	cp b 
0f69			;	pop bc 
0f69			;	ret 
0f69			; 
0f69			;.isdf:	; not digit so clear z 
0f69			; 
0f69			;	; TODO find a better way to unset z 
0f69			; 
0f69			;	ld b,a 
0f69			;	inc b 
0f69			;	cp b 
0f69			; 
0f69			;	pop bc 
0f69			;	ret 
0f69				 
0f69				 
0f69			 
0f69			 
0f69			; pass hl as the four byte address to load 
0f69			 
0f69			get_word_hl:  
0f69 e5				push hl 
0f6a cd 09 0f			call get_byte 
0f6d				 
0f6d 47				ld b, a 
0f6e			 
0f6e e1				pop hl 
0f6f 23				inc hl 
0f70 23				inc hl 
0f71			 
0f71			; TODO not able to handle a-f  
0f71 7e				ld a,(hl) 
0f72			;	;cp ':' 
0f72			;	cp 'g' 
0f72			;	jr nc, .single_byte_hl 		; > 
0f72			;	cp 'G' 
0f72			;	jr nc, .single_byte_hl 		; > 
0f72			;	cp '0' 
0f72			;	jr c, .single_byte_hl		; < 
0f72			 
0f72				;call isdigithl 
0f72 fe 00			cp 0 
0f74 28 06			jr z, .single_byte_hl 
0f76			 
0f76			.getwhln:   ; hex word so get next byte 
0f76			 
0f76 cd 09 0f			call get_byte 
0f79 6f				ld l, a 
0f7a 60				ld h,b 
0f7b c9				ret 
0f7c 68			.single_byte_hl:   ld l,b 
0f7d 26 00				ld h,0 
0f7f c9					ret 
0f80			 
0f80			 
0f80			 
0f80			 
0f80 21 b2 16			ld hl,asc+1 
0f83			;	ld a, (hl) 
0f83			;	call nibble2val 
0f83 cd 09 0f			call get_byte 
0f86			 
0f86			;	call fourehexhl 
0f86 32 94 e3			ld (scratch+52),a 
0f89				 
0f89 21 92 e3			ld hl,scratch+50 
0f8c 22 83 e6			ld (os_cur_ptr),hl 
0f8f			 
0f8f c9				ret 
0f90			 
0f90			 
0f90			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0f90			 
0f90			; Decimal Unsigned Version 
0f90			 
0f90			;Number in a to decimal ASCII 
0f90			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0f90			;Example: display a=56 as "056" 
0f90			;input: a = number 
0f90			;Output: a=0,value of a in the screen 
0f90			;destroys af,bc (don't know about hl and de) 
0f90			DispAToASCII: 
0f90 0e 9c			ld	c,-100 
0f92 cd 9c 0f			call	.Na1 
0f95 0e f6			ld	c,-10 
0f97 cd 9c 0f			call	.Na1 
0f9a 0e ff			ld	c,-1 
0f9c 06 2f		.Na1:	ld	b,'0'-1 
0f9e 04			.Na2:	inc	b 
0f9f 81				add	a,c 
0fa0 38 fc			jr	c,.Na2 
0fa2 91				sub	c		;works as add 100/10/1 
0fa3 f5				push af		;safer than ld c,a 
0fa4 78				ld	a,b		;char is in b 
0fa5			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0fa5 f1				pop af		;safer than ld a,c 
0fa6 c9				ret 
0fa7			 
0fa7			; Decimal Signed Version 
0fa7			 
0fa7			; DispA 
0fa7			; -------------------------------------------------------------- 
0fa7			; Converts a signed integer value to a zero-terminated ASCII 
0fa7			; string representative of that value (using radix 10). 
0fa7			; -------------------------------------------------------------- 
0fa7			; INPUTS: 
0fa7			;     HL     Value to convert (two's complement integer). 
0fa7			;     DE     Base address of string destination. (pointer). 
0fa7			; -------------------------------------------------------------- 
0fa7			; OUTPUTS: 
0fa7			;     None 
0fa7			; -------------------------------------------------------------- 
0fa7			; REGISTERS/MEMORY DESTROYED 
0fa7			; AF HL 
0fa7			; -------------------------------------------------------------- 
0fa7			 
0fa7			;DispHLToASCII: 
0fa7			;   push    de 
0fa7			;   push    bc 
0fa7			; 
0fa7			;; Detect sign of HL. 
0fa7			;    bit    7, h 
0fa7			;    jr     z, ._DoConvert 
0fa7			; 
0fa7			;; HL is negative. Output '-' to string and negate HL. 
0fa7			;    ld     a, '-' 
0fa7			;    ld     (de), a 
0fa7			;    inc    de 
0fa7			; 
0fa7			;; Negate HL (using two's complement) 
0fa7			;    xor    a 
0fa7			;    sub    l 
0fa7			;    ld     l, a 
0fa7			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0fa7			;    sbc    a, h 
0fa7			;    ld     h, a 
0fa7			; 
0fa7			;; Convert HL to digit characters 
0fa7			;._DoConvert: 
0fa7			;    ld     b, 0     ; B will count character length of number 
0fa7			;-   ld     a, 10 
0fa7			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0fa7			;    push   af 
0fa7			;    inc    b 
0fa7			;    ld     a, h 
0fa7			;    or     l 
0fa7			;    jr     nz, - 
0fa7			; 
0fa7			;; Retrieve digits from stack 
0fa7			;-   pop    af 
0fa7			;    or     $30 
0fa7			;    ld     (de), a 
0fa7			;    inc    de 
0fa7			;    djnz   - 
0fa7			; 
0fa7			;; Terminate string with NULL 
0fa7			;    xor    a 
0fa7			;    ld     (de), a 
0fa7			; 
0fa7			;    pop    bc 
0fa7			;    pop    de 
0fa7			;    ret 
0fa7			 
0fa7			;Comments 
0fa7			; 
0fa7			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0fa7			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0fa7			;    Note that the output string will not be fixed-width. 
0fa7			; 
0fa7			;Example Usage 
0fa7			; 
0fa7			;    ld    hl, -1004 
0fa7			;    ld    de, OP1 
0fa7			;    call  DispA 
0fa7			;    ld    hl, OP1 
0fa7			;    syscall  PutS 
0fa7			 
0fa7			 
0fa7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fa7			 
0fa7			 
0fa7			;Converts an ASCII string to an unsigned 16-bit integer 
0fa7			;Quits when it reaches a non-decimal digit 
0fa7			 
0fa7			string_to_uint16: 
0fa7			atoui_16: 
0fa7			;Input: 
0fa7			;     DE points to the string 
0fa7			;Outputs: 
0fa7			;     HL is the result 
0fa7			;     A is the 8-bit value of the number 
0fa7			;     DE points to the byte after the number 
0fa7			;Destroys: 
0fa7			;     BC 
0fa7			;       if the string is non-empty, BC is HL/10 
0fa7			;Size:  24 bytes 
0fa7			;Speed: 42+d(104+{0,9}) 
0fa7			;       d is the number of digits in the number 
0fa7			;       max is 640 cycles for a 5 digit number 
0fa7			;Assuming no leading zeros: 
0fa7			;1 digit:  146cc 
0fa7			;2 digit:  250cc 
0fa7			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0fa7			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0fa7			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0fa7			;avg: 544.81158447265625cc (544+13297/16384) 
0fa7			;=============================================================== 
0fa7 21 00 00		  ld hl,0 
0faa			.u16a: 
0faa 1a			  ld a,(de) 
0fab d6 30		  sub 30h 
0fad fe 0a		  cp 10 
0faf d0			  ret nc 
0fb0 13			  inc de 
0fb1 44			  ld b,h 
0fb2 4d			  ld c,l 
0fb3 29			  add hl,hl 
0fb4 29			  add hl,hl 
0fb5 09			  add hl,bc 
0fb6 29			  add hl,hl 
0fb7 85			  add a,l 
0fb8 6f			  ld l,a 
0fb9 30 ef		  jr nc,.u16a 
0fbb 24			  inc h 
0fbc c3 aa 0f		  jp .u16a 
0fbf			 
0fbf			 
0fbf			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fbf			 
0fbf			;written by Zeda 
0fbf			;Converts a 16-bit unsigned integer to an ASCII string. 
0fbf			 
0fbf			uitoa_16: 
0fbf			;Input: 
0fbf			;   DE is the number to convert 
0fbf			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0fbf			;Output: 
0fbf			;   HL points to the null-terminated ASCII string 
0fbf			;      NOTE: This isn't necessarily the same as the input HL. 
0fbf d5			  push de 
0fc0 c5			  push bc 
0fc1 f5			  push af 
0fc2 eb			  ex de,hl 
0fc3			 
0fc3 01 f0 d8		  ld bc,-10000 
0fc6 3e 2f		  ld a,'0'-1 
0fc8 3c			  inc a 
0fc9 09			  add hl,bc  
0fca 38 fc		   jr c,$-2 
0fcc 12			  ld (de),a 
0fcd 13			  inc de 
0fce			 
0fce 01 e8 03		  ld bc,1000 
0fd1 3e 3a		  ld a,'9'+1 
0fd3 3d			  dec a  
0fd4 09			  add hl,bc  
0fd5 30 fc		   jr nc,$-2 
0fd7 12			  ld (de),a 
0fd8 13			  inc de 
0fd9			 
0fd9 01 9c ff		  ld bc,-100 
0fdc 3e 2f		  ld a,'0'-1 
0fde 3c			  inc a  
0fdf 09			  add hl,bc  
0fe0 38 fc		   jr c,$-2 
0fe2 12			  ld (de),a 
0fe3 13			  inc de 
0fe4			 
0fe4 7d			  ld a,l 
0fe5 26 3a		  ld h,'9'+1 
0fe7 25			  dec h  
0fe8 c6 0a		  add a,10  
0fea 30 fb		   jr nc,$-3 
0fec c6 30		  add a,'0' 
0fee eb			  ex de,hl 
0fef 72			  ld (hl),d 
0ff0 23			  inc hl 
0ff1 77			  ld (hl),a 
0ff2 23			  inc hl 
0ff3 36 00		  ld (hl),0 
0ff5			 
0ff5			;Now strip the leading zeros 
0ff5 0e fa		  ld c,-6 
0ff7 09			  add hl,bc 
0ff8 3e 30		  ld a,'0' 
0ffa 23			  inc hl  
0ffb be			  cp (hl)  
0ffc 28 fc		  jr z,$-2 
0ffe			 
0ffe			;Make sure that the string is non-empty! 
0ffe 7e			  ld a,(hl) 
0fff b7			  or a 
1000 20 01		  jr nz,.atoub 
1002 2b			  dec hl 
1003			.atoub: 
1003			 
1003 f1			  pop af 
1004 c1			  pop bc 
1005 d1			  pop de 
1006 c9			  ret 
1007			 
1007			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1007			 
1007			toUpper: 
1007			;A is the char. 
1007			;If A is a lowercase letter, this sets it to the matching uppercase 
1007			;18cc or 30cc or 41cc 
1007			;avg: 26.75cc 
1007 fe 61		  cp 'a' 
1009 d8			  ret c 
100a fe 7b		  cp 'z'+1 
100c d0			  ret nc 
100d d6 20		  sub 'a'-'A' 
100f c9			  ret 
1010			 
1010			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1010			 
1010			; String Length 
1010			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1010			 
1010			; Get the length of the null-terminated string starting at $8000 hl 
1010			;    LD     HL, $8000 
1010			 
1010			strlenz: 
1010			 
1010 af			    XOR    A               ; Zero is the value we are looking for. 
1011 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1012 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1013			                           ; 65, 536 bytes (the entire addressable memory space). 
1013 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1015			 
1015			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1015 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1016 6f			    LD     L, A             ; number of bytes 
1017 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1019 2b			    DEC    HL              ; Compensate for null. 
101a c9				ret 
101b			 
101b			; Get the length of the A terminated string starting at $8000 hl 
101b			;    LD     HL, $8000 
101b			 
101b			strlent: 
101b			 
101b			                  ; A is the value we are looking for. 
101b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
101d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
101f			                           ; 65, 536 bytes (the entire addressable memory space). 
101f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1021			 
1021			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1021 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1023 2e 00		    LD     L, 0             ; number of bytes 
1025 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1027 2b			    DEC    HL              ; Compensate for null. 
1028 c9				ret 
1029			 
1029			 
1029			;Comparing Strings 
1029			 
1029			;IN    HL     Address of string1. 
1029			;      DE     Address of string2. 
1029			 
1029			; doc given but wrong??? 
1029			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1029			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1029			; tested 
1029			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1029			 
1029			strcmp_old: 
1029 e5			    PUSH   HL 
102a d5			    PUSH   DE 
102b			 
102b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
102c be			    CP     (HL)            ; (want to minimize work). 
102d 38 01		    JR     C, Str1IsBigger 
102f 7e			    LD     A, (HL) 
1030			 
1030			Str1IsBigger: 
1030 4f			    LD     C, A             ; Put length in BC 
1031 06 00		    LD     B, 0 
1033 13			    INC    DE              ; Increment pointers to meat of string. 
1034 23			    INC    HL 
1035			 
1035			CmpLoop: 
1035 1a			    LD     A, (DE)          ; Compare bytes. 
1036 ed a1		    CPI 
1038 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
103a 13			    INC    DE              ; Update pointer. 
103b ea 35 10		    JP     PE, CmpLoop 
103e			 
103e d1			    POP    DE 
103f e1			    POP    HL 
1040 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1041 be			    CP     (HL) 
1042 c9			    RET 
1043			 
1043			NoMatch: 
1043 2b			    DEC    HL 
1044 be			    CP     (HL)            ; Compare again to affect carry. 
1045 d1			    POP    DE 
1046 e1			    POP    HL 
1047 c9			    RET 
1048			 
1048			;; test strmp 
1048			; 
1048			;ld de, .str1 
1048			;ld hl, .str2 
1048			;call strcmp 
1048			;jr z, .z1 
1048			;;this 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "NZ1" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;.z1: 
1048			; 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "ZZ1" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			; 
1048			;ld de, .str1 
1048			;ld hl, .str1 
1048			;call strcmp 
1048			;jr z, .z2 
1048			;;this 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "NZ2" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;.z2: 
1048			; 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "ZZ2" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			; 
1048			;ld de, .str1 
1048			;ld hl, .str2 
1048			;call strcmp 
1048			;jr c, .c1 
1048			; 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "Nc1" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;.c1: 
1048			;;this 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "cc1" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			; 
1048			;ld de, .str1 
1048			;ld hl, .str1 
1048			;call strcmp 
1048			;jr c, .c2 
1048			;;this 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "Nc2" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;.c2: 
1048			; 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "cc2" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;	NEXTW 
1048			;.str1:   db "string1",0 
1048			;.str2:   db "string2",0 
1048			 
1048			; only care about direct match or not 
1048			; hl and de strings 
1048			; zero set if the same 
1048			 
1048			strcmp: 
1048 1a				ld a, (de) 
1049 be				cp (hl) 
104a 28 02			jr z, .ssame 
104c b7				or a 
104d c9				ret 
104e			 
104e			.ssame:  
104e fe 00			cp 0 
1050 c8				ret z 
1051			 
1051 23				inc hl 
1052 13				inc de 
1053 18 f3			jr strcmp 
1055				 
1055				 
1055			 
1055			 
1055			 
1055			 
1055			; eof 
1055			 
1055			 
1055			 
1055			 
1055			 
1055			 
# End of file firmware_strings.asm
1055			include "firmware_memory.asm"   ; malloc and free  
1055			 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055			.mallocsize: db "Wants malloc >256",0 
1055			.mallocasize: db "MALLOC gives >256",0 
1055			.malloczero: db "MALLOC gives zero",0 
1055			 
1055			malloc_guard_zerolen: 
1055				push hl 
1055				push de 
1055				push af 
1055			 
1055				ld de, 0 
1055			        call cmp16 
1055				jr nz, .lowalloz 
1055			 
1055				push hl 
1055				push de 
1055					ld hl, display_fb0 
1055					ld (display_fb_active), hl 
1055				call clear_display 
1055				ld a, 0 
1055				ld de, .malloczero 
1055				call str_at_display 
1055				call update_display 
1055				call delay1s 
1055				call delay1s 
1055				ld a, 0 
1055				ld (os_view_disable), a 
1055			 
1055				pop de 
1055				pop hl 
1055			 
1055				 
1055			 
1055				CALLMONITOR 
1055			.lowalloz: 
1055			 
1055			 
1055				pop af 
1055				pop de 
1055				pop hl 
1055			ret 
1055			 
1055			malloc_guard_entry: 
1055				push hl 
1055				push de 
1055				push af 
1055			 
1055			 	or a      ;clear carry flag 
1055				push hl 
1055				ld de, 255 
1055				sbc hl, de 
1055				jr c, .lowalloc 
1055			 
1055				push de 
1055					ld hl, display_fb0 
1055					ld (display_fb_active), hl 
1055				call clear_display 
1055				ld a, 0 
1055				ld de, .mallocsize 
1055				call str_at_display 
1055				call update_display 
1055				call delay1s 
1055				call delay1s 
1055				ld a, 0 
1055				ld (os_view_disable), a 
1055			 
1055				pop de 
1055				pop hl 
1055			 
1055				 
1055			 
1055				CALLMONITOR 
1055				jr .lowdone 
1055			.lowalloc: 
1055			 
1055			 
1055				pop hl 
1055			.lowdone:	pop af 
1055				pop de 
1055				pop hl 
1055			ret 
1055			 
1055			malloc_guard_exit: 
1055				push hl 
1055				push de 
1055				push af 
1055			 
1055			 	or a      ;clear carry flag 
1055				push hl 
1055				ld de, 255 
1055				sbc hl, de 
1055				jr c, .lowallocx 
1055			 
1055				push de 
1055					ld hl, display_fb0 
1055					ld (display_fb_active), hl 
1055				call clear_display 
1055				ld a, 0 
1055				ld de, .mallocasize 
1055				call str_at_display 
1055				call update_display 
1055				call delay1s 
1055				call delay1s 
1055				ld a, 0 
1055				ld (os_view_disable), a 
1055				pop de 
1055				pop hl 
1055			 
1055				CALLMONITOR 
1055				jr .lowdonex 
1055			.lowallocx: 
1055			 
1055				pop hl 
1055			.lowdonex:	pop af 
1055				pop de 
1055				pop hl 
1055			ret 
1055			endif 
1055			 
1055			if MALLOC_2 
1055			; Z80 Malloc and Free Functions 
1055			 
1055			; Malloc Function: 
1055			; Input: 
1055			;   HL: Size of block to allocate 
1055			; Output: 
1055			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1055			 
1055			malloc: 
1055				 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055			call malloc_guard_entry 
1055			endif 
1055			 
1055			 
1055			 
1055			 
1055					if DEBUG_FORTH_MALLOC 
1055						DMARK "mal" 
1055						CALLMONITOR 
1055					endif 
1055			    push af            ; Save AF register 
1055			    ld a, l            ; Load low byte of size into A 
1055			    or h               ; Check if size is zero 
1055			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1055			 
1055			    ; Allocate memory 
1055			    ld hl, (heap_start) ; Load start of heap into HL 
1055					if DEBUG_FORTH_MALLOC 
1055						DMARK "ma1" 
1055						CALLMONITOR 
1055					endif 
1055			    call malloc_internal ; Call internal malloc function 
1055			    pop af             ; Restore AF register 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055			call malloc_guard_exit 
1055			call malloc_guard_zerolen 
1055			endif 
1055			    ret                ; Return 
1055			 
1055			; Free Function: 
1055			; Input: 
1055			;   HL: Pointer to memory block to free 
1055			; Output: 
1055			;   None 
1055			 
1055			free: 
1055			    push af            ; Save AF register 
1055			    ld a, l            ; Load low byte of pointer into A 
1055			    or h               ; Check if pointer is NULL 
1055			    jp z, free_exit    ; If pointer is NULL, exit 
1055			 
1055			    ; Free memory 
1055			    ld hl, (heap_start) ; Load start of heap into HL 
1055			    call free_internal  ; Call internal free function 
1055			    pop af             ; Restore AF register 
1055			    ret                ; Return 
1055			 
1055			; Internal Malloc Function: 
1055			; Input: 
1055			;   HL: Size of block to allocate 
1055			; Output: 
1055			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1055			 
1055			malloc_internal: 
1055			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1055			    add hl, bc         ; Add management overhead to requested size 
1055			    ex de, hl          ; Save total size in DE, and keep it in HL 
1055					if DEBUG_FORTH_MALLOC 
1055						DMARK "ma2" 
1055						CALLMONITOR 
1055					endif 
1055			 
1055			    ; Search for free memory block 
1055			    ld de, (heap_end)  ; Load end of heap into DE 
1055			    ld bc, 0           ; Initialize counter 
1055			 
1055					if DEBUG_FORTH_MALLOC 
1055						DMARK "ma2" 
1055						CALLMONITOR 
1055					endif 
1055			malloc_search_loop: 
1055			    ; Check if current block is free 
1055			    ld a, (hl)         ; Load current block's status (free or used) 
1055			    cp 0               ; Compare with zero (free) 
1055			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1055			 
1055			    ; Check if current block is large enough 
1055			    ld a, (hl+1)       ; Load high byte of block size 
1055			    cp l               ; Compare with low byte of requested size 
1055			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1055			 
1055			    ld a, (hl+2)       ; Load low byte of block size 
1055			    cp h               ; Compare with high byte of requested size 
1055			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1055			 
1055			    ; Mark block as used 
1055			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1055			 
1055			    ; Calculate remaining space in block 
1055			    ld bc, 0           ; Clear BC 
1055			    add hl, bc         ; Increment HL to point to start of data block 
1055			    add hl, de         ; HL = HL + DE (total size) 
1055			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1055			    add hl, bc         ; Add management overhead to start of data block 
1055			 
1055			    ; Save pointer to allocated block in HL 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055						DMARK "ma5" 
1055			call malloc_guard_exit 
1055			call malloc_guard_zerolen 
1055			endif 
1055			    ret 
1055			 
1055			malloc_skip_block_check: 
1055			    ; Move to the next block 
1055			    ld bc, 3           ; Size of management overhead 
1055			    add hl, bc         ; Move to the next block 
1055			    inc de             ; Increment counter 
1055			 
1055			    ; Check if we have reached the end of heap 
1055			    ld a, e            ; Load low byte of heap end address 
1055			    cp (hl)            ; Compare with low byte of current address 
1055			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1055			    ld a, d            ; Load high byte of heap end address 
1055			    cp 0               ; Check if it's zero (end of memory) 
1055			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1055			 
1055			    ; If we reached here, allocation failed 
1055			    xor a              ; Set result to NULL 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055						DMARK "ma6" 
1055			call malloc_guard_exit 
1055			call malloc_guard_zerolen 
1055			endif 
1055			    ret 
1055			malloc_exit: 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055						DMARK "ma7" 
1055			call malloc_guard_exit 
1055			call malloc_guard_zerolen 
1055			endif 
1055			    ret 
1055			 
1055			; Internal Free Function: 
1055			; Input: 
1055			;   HL: Pointer to memory block to free 
1055			; Output: 
1055			;   None 
1055			 
1055			free_internal: 
1055			    ld de, (heap_start) ; Load start of heap into DE 
1055			    ld bc, 0            ; Initialize counter 
1055			 
1055			free_search_loop: 
1055			    ; Check if current block contains the pointer 
1055			    ld a, l             ; Load low byte of pointer 
1055			    cp (hl+1)           ; Compare with high byte of current block's address 
1055			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1055			    ld a, h             ; Load high byte of pointer 
1055			    cp (hl+2)           ; Compare with low byte of current block's address 
1055			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1055			 
1055			    ; Mark block as free 
1055			    ld (hl), 0          ; Set status byte to indicate free block 
1055			    ret                 ; Return 
1055			 
1055			free_skip_block_check: 
1055			    ; Move to the next block 
1055			    ld bc, 3            ; Size of management overhead 
1055			    add hl, bc          ; Move to the next block 
1055			    inc de              ; Increment counter 
1055			 
1055			    ; Check if we have reached the end of heap 
1055			    ld a, e             ; Load low byte of heap end address 
1055			    cp (hl)             ; Compare with low byte of current address 
1055			    jr nz, free_search_loop  ; If not equal, continue searching 
1055			    ld a, d             ; Load high byte of heap end address 
1055			    cp 0                ; Check if it's zero (end of memory) 
1055			    jr nz, free_search_loop  ; If not zero, continue searching 
1055			 
1055			    ; If we reached here, pointer is not found in heap 
1055			    ret 
1055			 
1055			free_exit: 
1055			    ret                 ; Return 
1055			 
1055			; Define heap start and end addresses 
1055			;heap_start:    .dw 0xC000   ; Start of heap 
1055			;heap_end:      .dw 0xE000   ; End of heap 
1055			 
1055			endif 
1055			 
1055			 
1055			if MALLOC_1 
1055			 
1055			 
1055			 
1055			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1055			 
1055			;moved to firmware.asm 
1055			;heap_start        .equ  0x9000      ; Starting address of heap 
1055			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1055			 
1055			;      .org 0 
1055			;      jp    main 
1055			 
1055			 
1055			;      .org  0x100 
1055			;main: 
1055			;      ld    HL, 0x8100 
1055			;      ld    SP, HL 
1055			; 
1055			;      call  heap_init 
1055			; 
1055			;      ; Make some allocations 
1055			;      ld    HL, 12 
1055			;      call  malloc            ; Allocates 0x9004 
1055			; 
1055			;      ld    HL, 12 
1055			;      call  malloc            ; Allocates 0x9014 
1055			; 
1055			;      ld    HL, 12 
1055			;      call  malloc            ; Allocates 0x9024 
1055			; 
1055			;      ; Free some allocations 
1055			;      ld    HL, 0x9014 
1055			;      call  free 
1055			; 
1055			;      ld    HL, 0x9004 
1055			;      call  free 
1055			; 
1055			;      ld    HL, 0x9024 
1055			;      call  free 
1055			; 
1055			; 
1055			;      halt 
1055			 
1055			 
1055			;------------------------------------------------------------------------------ 
1055			;     heap_init                                                               : 
1055			;                                                                             : 
1055			; Description                                                                 : 
1055			;     Initialise the heap and make it ready for malloc and free operations.   : 
1055			;                                                                             : 
1055			;     The heap is maintained as a linked list, starting with an initial       : 
1055			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1055			;     the first free block in the heap. Each block then points to the next    : 
1055			;     free block within the heap, and the free list ends at the first block   : 
1055			;     with a null pointer to the next free block.                             : 
1055			;                                                                             : 
1055			; Parameters                                                                  : 
1055			;     Inputs are compile-time only. Two defines which specify the starting    : 
1055			;     address of the heap and its size are required, along with a memory      : 
1055			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1055			;     principally stores a pointer to the first free block in the heap.       : 
1055			;                                                                             : 
1055			; Returns                                                                     : 
1055			;     Nothing                                                                 : 
1055			;------------------------------------------------------------------------------ 
1055			heap_init: 
1055 e5			      push  HL 
1056			 
1056			      ; Initialise free list struct 
1056 21 f5 59		      ld    HL, heap_start 
1059 22 f0 59		      ld    (free_list), HL 
105c 21 00 00		      ld    HL, 0 
105f 22 f2 59		      ld    (free_list+2), HL 
1062			 
1062			      ; Insert first free block at bottom of heap, consumes entire heap 
1062 21 42 e3		      ld    HL, heap_start+heap_size-4 
1065 22 f5 59		      ld    (heap_start), HL        ; Next block (end of free list) 
1068 21 4d 89		      ld    HL, heap_size-4 
106b 22 f7 59		      ld    (heap_start+2), HL      ; Block size 
106e			 
106e			      ; Insert end of free list block at top of heap - two null words will 
106e			      ; terminate the free list 
106e 21 00 00		      ld    HL, 0 
1071 22 44 e3		      ld    (heap_start+heap_size-2), HL 
1074 22 42 e3		      ld    (heap_start+heap_size-4), HL 
1077			 
1077 e1			      pop   HL 
1078			 
1078 c9			      ret 
1079			 
1079			 
1079			;------------------------------------------------------------------------------ 
1079			;     malloc                                                                  : 
1079			;                                                                             : 
1079			; Description                                                                 : 
1079			;     Allocates the wanted space from the heap and returns the address of the : 
1079			;     first useable byte of the allocation.                                   : 
1079			;                                                                             : 
1079			;     Allocations can happen in one of two ways:                              : 
1079			;                                                                             : 
1079			;     1. A free block may be found which is the exact size wanted. In this    : 
1079			;        case the block is removed from the free list and retuedn to the      : 
1079			;        caller.                                                              : 
1079			;     2. A free block may be found which is larger than the size wanted. In   : 
1079			;        this case, the larger block is split into two. The first portion of  : 
1079			;        this block will become the requested space by the malloc call and    : 
1079			;        is returned to the caller. The second portion becomes a new free     : 
1079			;        block, and the free list is adjusted to maintain continuity via this : 
1079			;        newly created block.                                                 : 
1079			;                                                                             : 
1079			;     malloc does not set any initial value in the allocated space, the       : 
1079			;     caller is required to do this as required.                              : 
1079			;                                                                             : 
1079			;     This implementation of malloc uses the stack exclusively, and is        : 
1079			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1079			;     advisable to disable interrupts before calling malloc, and recommended  : 
1079			;     to avoid the use of malloc inside ISRs in general.                      : 
1079			;                                                                             : 
1079			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1079			;                                                                             : 
1079			; Parameters                                                                  : 
1079			;     HL  Number of bytes wanted                                              : 
1079			;                                                                             : 
1079			; Returns                                                                     : 
1079			;     HL  Address of the first useable byte of the allocation                 : 
1079			;                                                                             : 
1079			; Flags                                                                       : 
1079			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1079			;                                                                             : 
1079			; Stack frame                                                                 : 
1079			;       |             |                                                       : 
1079			;       +-------------+                                                       : 
1079			;       |     BC      |                                                       : 
1079			;       +-------------+                                                       : 
1079			;       |     DE      |                                                       : 
1079			;       +-------------+                                                       : 
1079			;       |     IX      |                                                       : 
1079			;       +-------------+                                                       : 
1079			;       |  prev_free  |                                                       : 
1079			;   +4  +-------------+                                                       : 
1079			;       |  this_free  |                                                       : 
1079			;   +2  +-------------+                                                       : 
1079			;       |  next_free  |                                                       : 
1079			;   +0  +-------------+                                                       : 
1079			;       |             |                                                       : 
1079			;                                                                             : 
1079			;------------------------------------------------------------------------------ 
1079			 
1079			 
1079			;malloc: 
1079			; 
1079			;	SAVESP ON 1 
1079			; 
1079			;	call malloc_code 
1079			; 
1079			;	CHECKSP ON 1 
1079			;	ret 
1079			 
1079			 
1079			malloc: 
1079 c5			      push  BC 
107a d5			      push  DE 
107b dd e5		      push  IX 
107d			if DEBUG_FORTH_MALLOC_HIGH 
107d			call malloc_guard_entry 
107d			endif 
107d			 
107d					if DEBUG_FORTH_MALLOC 
107d						DMARK "mal" 
107d						CALLMONITOR 
107d					endif 
107d 7c			      ld    A, H                    ; Exit if no space requested 
107e b5			      or    L 
107f ca 3e 11		      jp    Z, malloc_early_exit 
1082			 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			; 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			 
1082			 
1082			 
1082			 
1082					if DEBUG_FORTH_MALLOC 
1082						DMARK "maA" 
1082						CALLMONITOR 
1082					endif 
1082			      ; Set up stack frame 
1082 eb			      ex    DE, HL 
1083 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1086 39			      add   HL, SP 
1087 f9			      ld    SP, HL 
1088 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
108c dd 39		      add   IX, SP 
108e			 
108e			      ; Setup initial state 
108e 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1091 19			      add   HL, DE 
1092			 
1092 44			      ld    B, H                    ; Move want to BC 
1093 4d			      ld    C, L 
1094			 
1094 21 f0 59		      ld    HL, free_list           ; Store prev_free ptr to stack 
1097 dd 75 04		      ld    (IX+4), L 
109a dd 74 05		      ld    (IX+5), H 
109d			 
109d 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
109e 23			      inc   HL 
109f 56			      ld    D, (HL) 
10a0 dd 73 02		      ld    (IX+2), E 
10a3 dd 72 03		      ld    (IX+3), D 
10a6 eb			      ex    DE, HL                  ; this_free ptr into HL 
10a7			 
10a7					if DEBUG_FORTH_MALLOC 
10a7						DMARK "maB" 
10a7						CALLMONITOR 
10a7					endif 
10a7			      ; Loop through free block list to find some space 
10a7			malloc_find_space: 
10a7 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
10a8 23			      inc   HL 
10a9 56			      ld    D, (HL) 
10aa			 
10aa 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
10ab b3			      or    E 
10ac ca 38 11		      jp    Z, malloc_no_space 
10af			 
10af dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
10b2 dd 72 01		      ld    (IX+1), D 
10b5			 
10b5			      ; Does this block have enough space to make the allocation? 
10b5 23			      inc   HL                      ; Load free block size into DE 
10b6 5e			      ld    E, (HL) 
10b7 23			      inc   HL 
10b8 56			      ld    D, (HL) 
10b9			 
10b9 eb			      ex    DE, HL                  ; Check size of block against want 
10ba b7			      or    A                       ; Ensure carry flag clear 
10bb ed 42		      sbc   HL, BC 
10bd e5			      push  HL                      ; Store the result for later (new block size) 
10be			 
10be ca 0d 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
10c1 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
10c3			 
10c3			      ; this_free block is not big enough, setup ptrs to test next free block 
10c3 e1			      pop   HL                      ; Discard previous result 
10c4			 
10c4 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
10c7 dd 66 03		      ld    H, (IX+3) 
10ca dd 75 04		      ld    (IX+4), L 
10cd dd 74 05		      ld    (IX+5), H 
10d0			 
10d0 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
10d3 dd 66 01		      ld    H, (IX+1) 
10d6 dd 75 02		      ld    (IX+2), L 
10d9 dd 74 03		      ld    (IX+3), H 
10dc			 
10dc					if DEBUG_FORTH_MALLOC 
10dc						DMARK "MA>" 
10dc						CALLMONITOR 
10dc					endif 
10dc 18 c9		      jr    malloc_find_space 
10de			 
10de			      ; split a bigger block into two - requested size and remaining size 
10de			malloc_alloc_split: 
10de					if DEBUG_FORTH_MALLOC 
10de						DMARK "MAs" 
10de						CALLMONITOR 
10de					endif 
10de eb			      ex    DE, HL                  ; Calculate address of new free block 
10df 2b			      dec   HL 
10e0 2b			      dec   HL 
10e1 2b			      dec   HL 
10e2 09			      add   HL, BC 
10e3			 
10e3			      ; Create a new block and point it at next_free 
10e3 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
10e6 dd 56 01		      ld    D, (IX+1) 
10e9			 
10e9 73			      ld    (HL), E                 ; Store next_free ptr into new block 
10ea 23			      inc   HL 
10eb 72			      ld    (HL), D 
10ec			 
10ec d1			      pop   DE                      ; Store size of new block into new block 
10ed 23			      inc   HL 
10ee 73			      ld    (HL), E 
10ef 23			      inc   HL 
10f0 72			      ld    (HL), D 
10f1			 
10f1			      ; Update this_free ptr to point to new block 
10f1 2b			      dec   HL 
10f2 2b			      dec   HL 
10f3 2b			      dec   HL 
10f4			 
10f4 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
10f7 dd 56 03		      ld    D, (IX+3) 
10fa			 
10fa dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
10fd dd 74 03		      ld    (IX+3), H 
1100			 
1100			      ; Modify this_free block to be allocation 
1100 eb			      ex    DE, HL 
1101 af			      xor   A                       ; Null the next block ptr of allocated block 
1102 77			      ld    (HL), A 
1103 23			      inc   HL 
1104 77			      ld    (HL), A 
1105			 
1105 23			      inc   HL                      ; Store want size into allocated block 
1106 71			      ld    (HL), C 
1107 23			      inc   HL 
1108 70			      ld    (HL), B 
1109 23			      inc   HL 
110a e5			      push  HL                      ; Address of allocation to return 
110b			 
110b 18 19		      jr    malloc_update_links 
110d			 
110d			malloc_alloc_fit: 
110d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
110e			 
110e					if DEBUG_FORTH_MALLOC 
110e						DMARK "MAf" 
110e						CALLMONITOR 
110e					endif 
110e			      ; Modify this_free block to be allocation 
110e eb			      ex    DE, HL 
110f 2b			      dec   HL 
1110 2b			      dec   HL 
1111 2b			      dec   HL 
1112			 
1112 af			      xor   A                       ; Null the next block ptr of allocated block 
1113 77			      ld    (HL), A 
1114 23			      inc   HL 
1115 77			      ld    (HL), A 
1116			 
1116 23			      inc   HL                      ; Store address of allocation to return 
1117 23			      inc   HL 
1118 23			      inc   HL 
1119 e5			      push  HL 
111a			 
111a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
111a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
111d dd 66 01		      ld    H, (IX+1) 
1120			 
1120 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1123 dd 74 03		      ld    (IX+3), H 
1126			 
1126			 
1126			malloc_update_links: 
1126			      ; Update prev_free ptr to point to this_free 
1126 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1129 dd 66 05		      ld    H, (IX+5) 
112c			 
112c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
112f dd 56 03		      ld    D, (IX+3) 
1132			 
1132 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1133 23			      inc   HL 
1134 72			      ld    (HL), D 
1135			 
1135					if DEBUG_FORTH_MALLOC 
1135						DMARK "Mul" 
1135						CALLMONITOR 
1135					endif 
1135			      ; Clear the Z flag to indicate successful allocation 
1135 7a			      ld    A, D 
1136 b3			      or    E 
1137			 
1137 d1			      pop   DE                      ; Address of allocation 
1138					if DEBUG_FORTH_MALLOC 
1138						DMARK "MAu" 
1138						CALLMONITOR 
1138					endif 
1138			 
1138			malloc_no_space: 
1138 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
113b 39			      add   HL, SP 
113c f9			      ld    SP, HL 
113d			 
113d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
113e					if DEBUG_FORTH_MALLOC 
113e						DMARK "MAN" 
113e						CALLMONITOR 
113e					endif 
113e			 
113e			malloc_early_exit: 
113e					if DEBUG_FORTH_MALLOC 
113e						DMARK "MAx" 
113e						CALLMONITOR 
113e					endif 
113e dd e1		      pop   IX 
1140 d1			      pop   DE 
1141 c1			      pop   BC 
1142			 
1142			if DEBUG_FORTH_MALLOC_HIGH 
1142			call malloc_guard_exit 
1142			call malloc_guard_zerolen 
1142			endif 
1142 c9			      ret 
1143			 
1143			 
1143			;------------------------------------------------------------------------------ 
1143			;     free                                                                    : 
1143			;                                                                             : 
1143			; Description                                                                 : 
1143			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1143			;     returned by malloc, otherwise the behaviour is undefined.               : 
1143			;                                                                             : 
1143			;     Where possible, directly adjacent free blocks will be merged together   : 
1143			;     into larger blocks to help ensure that the heap does not become         : 
1143			;     excessively fragmented.                                                 : 
1143			;                                                                             : 
1143			;     free does not clear or set any other value into the freed space, and    : 
1143			;     therefore its contents may be visible through subsequent malloc's. The  : 
1143			;     caller should clear the freed space as required.                        : 
1143			;                                                                             : 
1143			;     This implementation of free uses the stack exclusively, and is          : 
1143			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1143			;     advisable to disable interrupts before calling free, and recommended    : 
1143			;     to avoid the use of free inside ISRs in general.                        : 
1143			;                                                                             : 
1143			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1143			;                                                                             : 
1143			; Parameters                                                                  : 
1143			;     HL  Pointer to address of first byte of allocation to be freed          : 
1143			;                                                                             : 
1143			; Returns                                                                     : 
1143			;     Nothing                                                                 : 
1143			;                                                                             : 
1143			; Stack frame                                                                 : 
1143			;       |             |                                                       : 
1143			;       +-------------+                                                       : 
1143			;       |     BC      |                                                       : 
1143			;       +-------------+                                                       : 
1143			;       |     DE      |                                                       : 
1143			;       +-------------+                                                       : 
1143			;       |     IX      |                                                       : 
1143			;       +-------------+                                                       : 
1143			;       |  prev_free  |                                                       : 
1143			;   +2  +-------------+                                                       : 
1143			;       |  next_free  |                                                       : 
1143			;   +0  +-------------+                                                       : 
1143			;       |             |                                                       : 
1143			;                                                                             : 
1143			;------------------------------------------------------------------------------ 
1143			free: 
1143 c5			      push  BC 
1144 d5			      push  DE 
1145 dd e5		      push  IX 
1147			 
1147 7c			      ld    A, H                    ; Exit if ptr is null 
1148 b5			      or    L 
1149 ca 0d 12		      jp    Z, free_early_exit 
114c			 
114c			      ; Set up stack frame 
114c eb			      ex    DE, HL 
114d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1150 39			      add   HL, SP 
1151 f9			      ld    SP, HL 
1152 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1156 dd 39		      add   IX, SP 
1158			 
1158			      ; The address in HL points to the start of the useable allocated space, 
1158			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1158			      ; address of the block itself. 
1158 eb			      ex    DE, HL 
1159 11 fc ff		      ld    DE, -4 
115c 19			      add   HL, DE 
115d			 
115d			      ; An allocated block must have a null next block pointer in it 
115d 7e			      ld    A, (HL) 
115e 23			      inc   HL 
115f b6			      or    (HL) 
1160 c2 08 12		      jp    NZ, free_done 
1163			 
1163 2b			      dec   HL 
1164			 
1164 44			      ld    B, H                    ; Copy HL to BC 
1165 4d			      ld    C, L 
1166			 
1166			      ; Loop through the free list to find the first block with an address 
1166			      ; higher than the block being freed 
1166 21 f0 59		      ld    HL, free_list 
1169			 
1169			free_find_higher_block: 
1169 5e			      ld    E, (HL)                 ; Load next ptr from free block 
116a 23			      inc   HL 
116b 56			      ld    D, (HL) 
116c 2b			      dec   HL 
116d			 
116d dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1170 dd 72 01		      ld    (IX+1), D 
1173 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1176 dd 74 03		      ld    (IX+3), H 
1179			 
1179 78			      ld    A, B                    ; Check if DE is greater than BC 
117a ba			      cp    D                       ; Compare MSB first 
117b 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
117d 30 04		      jr    NC, free_find_higher_block_skip 
117f 79			      ld    A, C 
1180 bb			      cp    E                       ; Then compare LSB 
1181 38 08		      jr    C, free_found_higher_block 
1183			 
1183			free_find_higher_block_skip: 
1183 7a			      ld    A, D                    ; Reached the end of the free list? 
1184 b3			      or    E 
1185 ca 08 12		      jp    Z, free_done 
1188			 
1188 eb			      ex    DE, HL 
1189			 
1189 18 de		      jr    free_find_higher_block 
118b			 
118b			free_found_higher_block: 
118b			      ; Insert freed block between prev and next free blocks 
118b 71			      ld    (HL), C                 ; Point prev free block to freed block 
118c 23			      inc   HL 
118d 70			      ld    (HL), B 
118e			 
118e 60			      ld    H, B                    ; Point freed block at next free block 
118f 69			      ld    L, C 
1190 73			      ld    (HL), E 
1191 23			      inc   HL 
1192 72			      ld    (HL), D 
1193			 
1193			      ; Check if the freed block is adjacent to the next free block 
1193 23			      inc   HL                      ; Load size of freed block into HL 
1194 5e			      ld    E, (HL) 
1195 23			      inc   HL 
1196 56			      ld    D, (HL) 
1197 eb			      ex    DE, HL 
1198			 
1198 09			      add   HL, BC                  ; Add addr of freed block and its size 
1199			 
1199 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
119c dd 56 01		      ld    D, (IX+1) 
119f			 
119f b7			      or    A                       ; Clear the carry flag 
11a0 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
11a2 20 22		      jr    NZ, free_check_adjacent_to_prev 
11a4			 
11a4			      ; Freed block is adjacent to next, merge into one bigger block 
11a4 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
11a5 5e			      ld    E, (HL) 
11a6 23			      inc   HL 
11a7 56			      ld    D, (HL) 
11a8 e5			      push  HL                      ; Save ptr to next block for later 
11a9			 
11a9 60			      ld    H, B                    ; Store ptr from next block into freed block 
11aa 69			      ld    L, C 
11ab 73			      ld    (HL), E 
11ac 23			      inc   HL 
11ad 72			      ld    (HL), D 
11ae			 
11ae e1			      pop   HL                      ; Restore ptr to next block 
11af 23			      inc   HL                      ; Load size of next block into DE 
11b0 5e			      ld    E, (HL) 
11b1 23			      inc   HL 
11b2 56			      ld    D, (HL) 
11b3 d5			      push  DE                      ; Save next block size for later 
11b4			 
11b4 60			      ld    H, B                    ; Load size of freed block into HL 
11b5 69			      ld    L, C 
11b6 23			      inc   HL 
11b7 23			      inc   HL 
11b8 5e			      ld    E, (HL) 
11b9 23			      inc   HL 
11ba 56			      ld    D, (HL) 
11bb eb			      ex    DE, HL 
11bc			 
11bc d1			      pop   DE                      ; Restore size of next block 
11bd 19			      add   HL, DE                  ; Add sizes of both blocks 
11be eb			      ex    DE, HL 
11bf			 
11bf 60			      ld    H, B                    ; Store new bigger size into freed block 
11c0 69			      ld    L, C 
11c1 23			      inc   HL 
11c2 23			      inc   HL 
11c3 73			      ld    (HL), E 
11c4 23			      inc   HL 
11c5 72			      ld    (HL), D 
11c6			 
11c6			free_check_adjacent_to_prev: 
11c6			      ; Check if the freed block is adjacent to the prev free block 
11c6 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
11c9 dd 66 03		      ld    H, (IX+3) 
11cc			 
11cc 23			      inc   HL                      ; Size of prev free block into DE 
11cd 23			      inc   HL 
11ce 5e			      ld    E, (HL) 
11cf 23			      inc   HL 
11d0 56			      ld    D, (HL) 
11d1 2b			      dec   HL 
11d2 2b			      dec   HL 
11d3 2b			      dec   HL 
11d4			 
11d4 19			      add   HL, DE                  ; Add prev block addr and size 
11d5			 
11d5 b7			      or    A                       ; Clear the carry flag 
11d6 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
11d8 20 2e		      jr    NZ, free_done 
11da			 
11da			      ; Freed block is adjacent to prev, merge into one bigger block 
11da 60			      ld    H, B                    ; Load next ptr from freed block into DE 
11db 69			      ld    L, C 
11dc 5e			      ld    E, (HL) 
11dd 23			      inc   HL 
11de 56			      ld    D, (HL) 
11df e5			      push  HL                      ; Save freed block ptr for later 
11e0			 
11e0 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
11e3 dd 66 03		      ld    H, (IX+3) 
11e6 73			      ld    (HL), E 
11e7 23			      inc   HL 
11e8 72			      ld    (HL), D 
11e9			 
11e9 e1			      pop   HL                      ; Restore freed block ptr 
11ea 23			      inc   HL                      ; Load size of freed block into DE 
11eb 5e			      ld    E, (HL) 
11ec 23			      inc   HL 
11ed 56			      ld    D, (HL) 
11ee d5			      push  DE                      ; Save freed block size for later 
11ef			 
11ef dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
11f2 dd 66 03		      ld    H, (IX+3) 
11f5 23			      inc   HL 
11f6 23			      inc   HL 
11f7 5e			      ld    E, (HL) 
11f8 23			      inc   HL 
11f9 56			      ld    D, (HL) 
11fa			 
11fa e1			      pop   HL                      ; Add sizes of both blocks 
11fb 19			      add   HL, DE 
11fc eb			      ex    DE, HL 
11fd			 
11fd dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1200 dd 66 03		      ld    H, (IX+3) 
1203 23			      inc   HL 
1204 23			      inc   HL 
1205 73			      ld    (HL), E 
1206 23			      inc   HL 
1207 72			      ld    (HL), D 
1208			 
1208			free_done: 
1208 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
120b 39			      add   HL, SP 
120c f9			      ld    SP, HL 
120d			 
120d			free_early_exit: 
120d dd e1		      pop   IX 
120f d1			      pop   DE 
1210 c1			      pop   BC 
1211			 
1211 c9			      ret 
1212			 
1212			; moved to firmware.asm 
1212			; 
1212			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1212			;                  .dw   0 
1212			 
1212			 
1212			endif 
1212			 
1212			 
1212			if MALLOC_3 
1212			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1212			;heap_start        .equ  0x9000      ; Starting address of heap 
1212			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1212			; 
1212			 ;     .org 0 
1212			  ;    jp    main 
1212			; 
1212			; 
1212			 ;     .org  0x100 
1212			;main: 
1212			 ;     ld    HL, 0x8100 
1212			  ;    ld    SP, HL 
1212			; 
1212			;      call  heap_init 
1212			 
1212			      ; Make some allocations 
1212			;      ld    HL, 12 
1212			;      call  malloc            ; Allocates 0x9004 
1212			; 
1212			 ;     ld    HL, 12 
1212			;      call  malloc            ; Allocates 0x9014 
1212			 
1212			;      ld    HL, 12 
1212			;      call  malloc            ; Allocates 0x9024 
1212			 
1212			      ; Free some allocations 
1212			;      ld    HL, 0x9014 
1212			;      call  free 
1212			 
1212			;      ld    HL, 0x9004 
1212			;      call  free 
1212			; 
1212			;      ld    HL, 0x9024 
1212			;      call  free 
1212			 
1212			 
1212			 ;     halt 
1212			 
1212			 
1212			;------------------------------------------------------------------------------ 
1212			;     heap_init                                                               : 
1212			;                                                                             : 
1212			; Description                                                                 : 
1212			;     Initialise the heap and make it ready for malloc and free operations.   : 
1212			;                                                                             : 
1212			;     The heap is maintained as a linked list, starting with an initial       : 
1212			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1212			;     the first free block in the heap. Each block then points to the next    : 
1212			;     free block within the heap, and the free list ends at the first block   : 
1212			;     with a null pointer to the next free block.                             : 
1212			;                                                                             : 
1212			; Parameters                                                                  : 
1212			;     Inputs are compile-time only. Two defines which specify the starting    : 
1212			;     address of the heap and its size are required, along with a memory      : 
1212			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1212			;     principally stores a pointer to the first free block in the heap.       : 
1212			;                                                                             : 
1212			; Returns                                                                     : 
1212			;     Nothing                                                                 : 
1212			;------------------------------------------------------------------------------ 
1212			heap_init: 
1212			      push  HL 
1212			 
1212			      ; Initialise free list struct 
1212			      ld    HL, heap_start 
1212			      ld    (free_list), HL 
1212			      ld    HL, 0 
1212			      ld    (free_list+2), HL 
1212			 
1212			      ; Insert first free block at bottom of heap, consumes entire heap 
1212			      ld    HL, heap_start+heap_size-4 
1212			      ld    (heap_start), HL        ; Next block (end of free list) 
1212			      ld    HL, heap_size-4 
1212			      ld    (heap_start+2), HL      ; Block size 
1212			 
1212			      ; Insert end of free list block at top of heap - two null words will 
1212			      ; terminate the free list 
1212			      ld    HL, 0 
1212			      ld    (heap_start+heap_size-2), HL 
1212			      ld    (heap_start+heap_size-4), HL 
1212			 
1212			      pop   HL 
1212			 
1212			      ret 
1212			 
1212			 
1212			;------------------------------------------------------------------------------ 
1212			;     malloc                                                                  : 
1212			;                                                                             : 
1212			; Description                                                                 : 
1212			;     Allocates the wanted space from the heap and returns the address of the : 
1212			;     first useable byte of the allocation.                                   : 
1212			;                                                                             : 
1212			;     Allocations can happen in one of two ways:                              : 
1212			;                                                                             : 
1212			;     1. A free block may be found which is the exact size wanted. In this    : 
1212			;        case the block is removed from the free list and retuedn to the      : 
1212			;        caller.                                                              : 
1212			;     2. A free block may be found which is larger than the size wanted. In   : 
1212			;        this case, the larger block is split into two. The first portion of  : 
1212			;        this block will become the requested space by the malloc call and    : 
1212			;        is returned to the caller. The second portion becomes a new free     : 
1212			;        block, and the free list is adjusted to maintain continuity via this : 
1212			;        newly created block.                                                 : 
1212			;                                                                             : 
1212			;     malloc does not set any initial value in the allocated space, the       : 
1212			;     caller is required to do this as required.                              : 
1212			;                                                                             : 
1212			;     This implementation of malloc uses the stack exclusively, and is        : 
1212			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1212			;     advisable to disable interrupts before calling malloc, and recommended  : 
1212			;     to avoid the use of malloc inside ISRs in general.                      : 
1212			;                                                                             : 
1212			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1212			;                                                                             : 
1212			; Parameters                                                                  : 
1212			;     HL  Number of bytes wanted                                              : 
1212			;                                                                             : 
1212			; Returns                                                                     : 
1212			;     HL  Address of the first useable byte of the allocation                 : 
1212			;                                                                             : 
1212			; Flags                                                                       : 
1212			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1212			;                                                                             : 
1212			; Stack frame                                                                 : 
1212			;       |             |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     BC      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     DE      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     IX      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |  prev_free  |                                                       : 
1212			;   +4  +-------------+                                                       : 
1212			;       |  this_free  |                                                       : 
1212			;   +2  +-------------+                                                       : 
1212			;       |  next_free  |                                                       : 
1212			;   +0  +-------------+                                                       : 
1212			;       |             |                                                       : 
1212			;                                                                             : 
1212			;------------------------------------------------------------------------------ 
1212			malloc: 
1212			      push  BC 
1212			      push  DE 
1212			      push  IX 
1212			 
1212			      ld    A, H                    ; Exit if no space requested 
1212			      or    L 
1212			      jp    Z, malloc_early_exit 
1212			 
1212			      ; Set up stack frame 
1212			      ex    DE, HL 
1212			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1212			      add   HL, SP 
1212			      ld    SP, HL 
1212			      ld    IX, 0                   ; Use IX as a frame pointer 
1212			      add   IX, SP 
1212			 
1212			      ; Setup initial state 
1212			      ld    HL, 4                   ; want must also include space used by block struct 
1212			      add   HL, DE 
1212			 
1212			      ld    B, H                    ; Move want to BC 
1212			      ld    C, L 
1212			 
1212			      ld    HL, free_list           ; Store prev_free ptr to stack 
1212			      ld    (IX+4), L 
1212			      ld    (IX+5), H 
1212			 
1212			      ld    E, (HL)                 ; Store this_free ptr to stack 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      ld    (IX+2), E 
1212			      ld    (IX+3), D 
1212			      ex    DE, HL                  ; this_free ptr into HL 
1212			 
1212			      ; Loop through free block list to find some space 
1212			malloc_find_space: 
1212			      ld    E, (HL)                 ; Load next_free ptr into DE 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			 
1212			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1212			      or    E 
1212			      jp    Z, malloc_no_space 
1212			 
1212			      ld    (IX+0), E               ; Store next_free ptr to stack 
1212			      ld    (IX+1), D 
1212			 
1212			      ; Does this block have enough space to make the allocation? 
1212			      inc   HL                      ; Load free block size into DE 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			 
1212			      ex    DE, HL                  ; Check size of block against want 
1212			      or    A                       ; Ensure carry flag clear 
1212			      sbc   HL, BC 
1212			      push  HL                      ; Store the result for later (new block size) 
1212			 
1212			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1212			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1212			 
1212			      ; this_free block is not big enough, setup ptrs to test next free block 
1212			      pop   HL                      ; Discard previous result 
1212			 
1212			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1212			      ld    H, (IX+3) 
1212			      ld    (IX+4), L 
1212			      ld    (IX+5), H 
1212			 
1212			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1212			      ld    H, (IX+1) 
1212			      ld    (IX+2), L 
1212			      ld    (IX+3), H 
1212			 
1212			      jr    malloc_find_space 
1212			 
1212			      ; split a bigger block into two - requested size and remaining size 
1212			malloc_alloc_split: 
1212			      ex    DE, HL                  ; Calculate address of new free block 
1212			      dec   HL 
1212			      dec   HL 
1212			      dec   HL 
1212			      add   HL, BC 
1212			 
1212			      ; Create a new block and point it at next_free 
1212			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1212			      ld    D, (IX+1) 
1212			 
1212			      ld    (HL), E                 ; Store next_free ptr into new block 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      pop   DE                      ; Store size of new block into new block 
1212			      inc   HL 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      ; Update this_free ptr to point to new block 
1212			      dec   HL 
1212			      dec   HL 
1212			      dec   HL 
1212			 
1212			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1212			      ld    D, (IX+3) 
1212			 
1212			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1212			      ld    (IX+3), H 
1212			 
1212			      ; Modify this_free block to be allocation 
1212			      ex    DE, HL 
1212			      xor   A                       ; Null the next block ptr of allocated block 
1212			      ld    (HL), A 
1212			      inc   HL 
1212			      ld    (HL), A 
1212			 
1212			      inc   HL                      ; Store want size into allocated block 
1212			      ld    (HL), C 
1212			      inc   HL 
1212			      ld    (HL), B 
1212			      inc   HL 
1212			      push  HL                      ; Address of allocation to return 
1212			 
1212			      jr    malloc_update_links 
1212			 
1212			malloc_alloc_fit: 
1212			      pop   HL                      ; Dont need new block size, want is exact fit 
1212			 
1212			      ; Modify this_free block to be allocation 
1212			      ex    DE, HL 
1212			      dec   HL 
1212			      dec   HL 
1212			      dec   HL 
1212			 
1212			      xor   A                       ; Null the next block ptr of allocated block 
1212			      ld    (HL), A 
1212			      inc   HL 
1212			      ld    (HL), A 
1212			 
1212			      inc   HL                      ; Store address of allocation to return 
1212			      inc   HL 
1212			      inc   HL 
1212			      push  HL 
1212			 
1212			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1212			      ld    L, (IX+0)               ; next_free to HL 
1212			      ld    H, (IX+1) 
1212			 
1212			      ld    (IX+2), L               ; HL to this_free 
1212			      ld    (IX+3), H 
1212			 
1212			 
1212			malloc_update_links: 
1212			      ; Update prev_free ptr to point to this_free 
1212			      ld    L, (IX+4)               ; prev_free ptr to HL 
1212			      ld    H, (IX+5) 
1212			 
1212			      ld    E, (IX+2)               ; this_free ptr to DE 
1212			      ld    D, (IX+3) 
1212			 
1212			      ld    (HL), E                 ; this_free ptr into prev_free 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      ; Clear the Z flag to indicate successful allocation 
1212			      ld    A, D 
1212			      or    E 
1212			 
1212			      pop   DE                      ; Address of allocation 
1212			 
1212			malloc_no_space: 
1212			      ld    HL, 6                   ; Clean up stack frame 
1212			      add   HL, SP 
1212			      ld    SP, HL 
1212			 
1212			      ex    DE, HL                  ; Alloc addr into HL for return 
1212			 
1212			malloc_early_exit: 
1212			      pop   IX 
1212			      pop   DE 
1212			      pop   BC 
1212			 
1212			      ret 
1212			 
1212			 
1212			;------------------------------------------------------------------------------ 
1212			;     free                                                                    : 
1212			;                                                                             : 
1212			; Description                                                                 : 
1212			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1212			;     returned by malloc, otherwise the behaviour is undefined.               : 
1212			;                                                                             : 
1212			;     Where possible, directly adjacent free blocks will be merged together   : 
1212			;     into larger blocks to help ensure that the heap does not become         : 
1212			;     excessively fragmented.                                                 : 
1212			;                                                                             : 
1212			;     free does not clear or set any other value into the freed space, and    : 
1212			;     therefore its contents may be visible through subsequent malloc's. The  : 
1212			;     caller should clear the freed space as required.                        : 
1212			;                                                                             : 
1212			;     This implementation of free uses the stack exclusively, and is          : 
1212			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1212			;     advisable to disable interrupts before calling free, and recommended    : 
1212			;     to avoid the use of free inside ISRs in general.                        : 
1212			;                                                                             : 
1212			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1212			;                                                                             : 
1212			; Parameters                                                                  : 
1212			;     HL  Pointer to address of first byte of allocation to be freed          : 
1212			;                                                                             : 
1212			; Returns                                                                     : 
1212			;     Nothing                                                                 : 
1212			;                                                                             : 
1212			; Stack frame                                                                 : 
1212			;       |             |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     BC      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     DE      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     IX      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |  prev_free  |                                                       : 
1212			;   +2  +-------------+                                                       : 
1212			;       |  next_free  |                                                       : 
1212			;   +0  +-------------+                                                       : 
1212			;       |             |                                                       : 
1212			;                                                                             : 
1212			;------------------------------------------------------------------------------ 
1212			free: 
1212			      push  BC 
1212			      push  DE 
1212			      push  IX 
1212			 
1212			      ld    A, H                    ; Exit if ptr is null 
1212			      or    L 
1212			      jp    Z, free_early_exit 
1212			 
1212			      ; Set up stack frame 
1212			      ex    DE, HL 
1212			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1212			      add   HL, SP 
1212			      ld    SP, HL 
1212			      ld    IX, 0                   ; Use IX as a frame pointer 
1212			      add   IX, SP 
1212			 
1212			      ; The address in HL points to the start of the useable allocated space, 
1212			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1212			      ; address of the block itself. 
1212			      ex    DE, HL 
1212			      ld    DE, -4 
1212			      add   HL, DE 
1212			 
1212			      ; An allocated block must have a null next block pointer in it 
1212			      ld    A, (HL) 
1212			      inc   HL 
1212			      or    (HL) 
1212			      jp    NZ, free_done 
1212			 
1212			      dec   HL 
1212			 
1212			      ld    B, H                    ; Copy HL to BC 
1212			      ld    C, L 
1212			 
1212			      ; Loop through the free list to find the first block with an address 
1212			      ; higher than the block being freed 
1212			      ld    HL, free_list 
1212			 
1212			free_find_higher_block: 
1212			      ld    E, (HL)                 ; Load next ptr from free block 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      dec   HL 
1212			 
1212			      ld    (IX+0), E               ; Save ptr to next free block 
1212			      ld    (IX+1), D 
1212			      ld    (IX+2), L               ; Save ptr to prev free block 
1212			      ld    (IX+3), H 
1212			 
1212			      ld    A, B                    ; Check if DE is greater than BC 
1212			      cp    D                       ; Compare MSB first 
1212			      jr    Z, $+4                  ; MSB the same, compare LSB 
1212			      jr    NC, free_find_higher_block_skip 
1212			      ld    A, C 
1212			      cp    E                       ; Then compare LSB 
1212			      jr    C, free_found_higher_block 
1212			 
1212			free_find_higher_block_skip: 
1212			      ld    A, D                    ; Reached the end of the free list? 
1212			      or    E 
1212			      jp    Z, free_done 
1212			 
1212			      ex    DE, HL 
1212			 
1212			      jr    free_find_higher_block 
1212			 
1212			free_found_higher_block: 
1212			      ; Insert freed block between prev and next free blocks 
1212			      ld    (HL), C                 ; Point prev free block to freed block 
1212			      inc   HL 
1212			      ld    (HL), B 
1212			 
1212			      ld    H, B                    ; Point freed block at next free block 
1212			      ld    L, C 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      ; Check if the freed block is adjacent to the next free block 
1212			      inc   HL                      ; Load size of freed block into HL 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      ex    DE, HL 
1212			 
1212			      add   HL, BC                  ; Add addr of freed block and its size 
1212			 
1212			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1212			      ld    D, (IX+1) 
1212			 
1212			      or    A                       ; Clear the carry flag 
1212			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1212			      jr    NZ, free_check_adjacent_to_prev 
1212			 
1212			      ; Freed block is adjacent to next, merge into one bigger block 
1212			      ex    DE, HL                  ; Load next ptr from next block into DE 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      push  HL                      ; Save ptr to next block for later 
1212			 
1212			      ld    H, B                    ; Store ptr from next block into freed block 
1212			      ld    L, C 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      pop   HL                      ; Restore ptr to next block 
1212			      inc   HL                      ; Load size of next block into DE 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      push  DE                      ; Save next block size for later 
1212			 
1212			      ld    H, B                    ; Load size of freed block into HL 
1212			      ld    L, C 
1212			      inc   HL 
1212			      inc   HL 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      ex    DE, HL 
1212			 
1212			      pop   DE                      ; Restore size of next block 
1212			      add   HL, DE                  ; Add sizes of both blocks 
1212			      ex    DE, HL 
1212			 
1212			      ld    H, B                    ; Store new bigger size into freed block 
1212			      ld    L, C 
1212			      inc   HL 
1212			      inc   HL 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			free_check_adjacent_to_prev: 
1212			      ; Check if the freed block is adjacent to the prev free block 
1212			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1212			      ld    H, (IX+3) 
1212			 
1212			      inc   HL                      ; Size of prev free block into DE 
1212			      inc   HL 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      dec   HL 
1212			      dec   HL 
1212			      dec   HL 
1212			 
1212			      add   HL, DE                  ; Add prev block addr and size 
1212			 
1212			      or    A                       ; Clear the carry flag 
1212			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1212			      jr    NZ, free_done 
1212			 
1212			      ; Freed block is adjacent to prev, merge into one bigger block 
1212			      ld    H, B                    ; Load next ptr from freed block into DE 
1212			      ld    L, C 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      push  HL                      ; Save freed block ptr for later 
1212			 
1212			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1212			      ld    H, (IX+3) 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      pop   HL                      ; Restore freed block ptr 
1212			      inc   HL                      ; Load size of freed block into DE 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      push  DE                      ; Save freed block size for later 
1212			 
1212			      ld    L, (IX+2)               ; Load size of prev block into DE 
1212			      ld    H, (IX+3) 
1212			      inc   HL 
1212			      inc   HL 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			 
1212			      pop   HL                      ; Add sizes of both blocks 
1212			      add   HL, DE 
1212			      ex    DE, HL 
1212			 
1212			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1212			      ld    H, (IX+3) 
1212			      inc   HL 
1212			      inc   HL 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			free_done: 
1212			      ld    HL, 4                   ; Clean up stack frame 
1212			      add   HL, SP 
1212			      ld    SP, HL 
1212			 
1212			free_early_exit: 
1212			      pop   IX 
1212			      pop   DE 
1212			      pop   BC 
1212			 
1212			      ret 
1212			 
1212			 
1212			;      .org 0x8000 
1212			; 
1212			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1212			 ;                 .dw   0 
1212			 
1212			endif 
1212			 
1212			 
1212			if MALLOC_4 
1212			 
1212			; My memory allocation code. Very very simple.... 
1212			; allocate space under 250 chars 
1212			 
1212			heap_init: 
1212				; init start of heap as zero 
1212				;  
1212			 
1212				ld hl, heap_start 
1212				ld a, 0 
1212				ld (hl), a      ; empty block 
1212				inc hl 
1212				ld a, 0 
1212				ld (hl), a      ; length of block 
1212				; write end of list 
1212				inc hl 
1212				ld a,(hl) 
1212				inc hl 
1212				ld a,(hl) 
1212				 
1212			 
1212				; init some malloc vars 
1212			 
1212				ld hl, 0 
1212				ld (free_list), hl       ; store last malloc location 
1212			 
1212				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1212				ld a, 0 
1212				ld (hl), a 
1212			 
1212			 
1212				ld hl, heap_start 
1212				;  
1212				  
1212				ret 
1212			 
1212			 
1212			;    free block marker 
1212			;    requested size  
1212			;    pointer to next block 
1212			;    .... 
1212			;    next block marker 
1212			 
1212			 
1212			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1212			; 
1212			 
1212			 
1212			malloc:  
1212				push de 
1212				push bc 
1212				push af 
1212			 
1212				; hl space required 
1212				 
1212				ld c, l    ; hold space   (TODO only a max of 255) 
1212			 
1212			;	inc c     ; TODO BUG need to fix memory leak on push str 
1212			;	inc c 
1212			;	inc c 
1212			;	inc c 
1212			;	inc c 
1212			;	inc c 
1212			;	inc c 
1212			 
1212			 
1212			 
1212				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1212			 
1212				ld a, (free_list+3) 
1212				cp 0 
1212				jr z, .contheap 
1212			 
1212				ld hl, (free_list)     ; get last alloc 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mrs" 
1212						CALLMONITOR 
1212					endif 
1212				jr .startalloc 
1212			 
1212			.contheap: 
1212				ld hl, heap_start 
1212			 
1212			.startalloc: 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mym" 
1212						CALLMONITOR 
1212					endif 
1212			.findblock: 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mmf" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212				ld a,(hl)  
1212				; if byte is zero then clear to use 
1212			 
1212				cp 0 
1212				jr z, .foundemptyblock 
1212			 
1212				; if byte is not clear 
1212				;     then byte is offset to next block 
1212			 
1212				inc hl 
1212				ld a, (hl) ; get size 
1212			.nextblock:	inc hl 
1212					ld e, (hl) 
1212					inc hl 
1212					ld d, (hl) 
1212					ex de, hl 
1212			;	inc hl  ; move past the store space 
1212			;	inc hl  ; move past zero index  
1212			 
1212				; TODO detect no more space 
1212			 
1212				push hl 
1212				ld de, heap_end 
1212				call cmp16 
1212				pop hl 
1212				jr nc, .nospace 
1212			 
1212				jr .findblock 
1212			 
1212			.nospace: ld hl, 0 
1212				jp .exit 
1212			 
1212			 
1212			.foundemptyblock:	 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mme" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212			; TODO has block enough space if reusing??? 
1212			 
1212				;  
1212			 
1212			; see if this block has been previously used 
1212				inc hl 
1212				ld a, (hl) 
1212				dec hl 
1212				cp 0 
1212				jr z, .newblock 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "meR" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212			; no reusing previously allocated block 
1212			 
1212			; is it smaller than previously used? 
1212				 
1212				inc hl    ; move to size 
1212				ld a, c 
1212				sub (hl)        ; we want c < (hl) 
1212				dec hl    ; move back to marker 
1212			        jr z, .findblock 
1212			 
1212				; update with the new size which should be lower 
1212			 
1212			        ;inc  hl   ; negate next move. move back to size  
1212			 
1212			.newblock: 
1212				; need to be at marker here 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "meN" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212			 
1212				ld a, c 
1212			 
1212				ld (free_list+3), a	 ; flag resume from last malloc  
1212				ld (free_list), hl    ; save out last location 
1212			 
1212			 
1212				;inc a     ; space for length byte 
1212				ld (hl), a     ; save block in use marker 
1212			 
1212				inc hl   ; move to space marker 
1212				ld (hl), a    ; save new space 
1212			 
1212				inc hl   ; move to start of allocated area 
1212				 
1212			;	push hl     ; save where we are - 1  
1212			 
1212			;	inc hl  ; move past zero index  
1212				; skip space to set down new marker 
1212			 
1212				; provide some extra space for now 
1212			 
1212				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1212				inc a 
1212				inc a 
1212			 
1212				push hl   ; save where we are in the node block 
1212			 
1212				call addatohl 
1212			 
1212				; write linked list point 
1212			 
1212				pop de     ; get our node position 
1212				ex de, hl 
1212			 
1212				ld (hl), e 
1212				inc hl 
1212				ld (hl), d 
1212			 
1212				inc hl 
1212			 
1212				; now at start of allocated data so save pointer 
1212			 
1212				push hl 
1212			 
1212				; jump to position of next node and setup empty header in DE 
1212			 
1212				ex de, hl 
1212			 
1212			;	inc hl ; move past end of block 
1212			 
1212				ld a, 0 
1212				ld (hl), a   ; empty marker 
1212				inc hl 
1212				ld (hl), a   ; size 
1212				inc hl  
1212				ld (hl), a   ; ptr 
1212				inc hl 
1212				ld (hl), a   ; ptr 
1212			 
1212			 
1212				pop hl 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mmr" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212			.exit: 
1212				pop af 
1212				pop bc 
1212				pop de  
1212				ret 
1212			 
1212			 
1212			 
1212			 
1212			free:  
1212				push hl 
1212				push af 
1212				; get address in hl 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "fre" 
1212						CALLMONITOR 
1212					endif 
1212				; data is at hl - move to block count 
1212				dec hl 
1212				dec hl    ; get past pointer 
1212				dec hl 
1212			 
1212				ld a, (hl)    ; need this for a validation check 
1212			 
1212				dec hl    ; move to block marker 
1212			 
1212				; now check that the block count and block marker are the same  
1212			        ; this checks that we are on a malloc node and not random memory 
1212			        ; OK a faint chance this could be a problem but rare - famous last words! 
1212			 
1212				ld c, a 
1212				ld a, (hl)    
1212			 
1212				cp c 
1212				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1212			 
1212				; yes good chance we are on a malloc node 
1212			 
1212				ld a, 0      
1212				ld (hl), a   ; mark as free 
1212			 
1212				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1212			 
1212			.freeignore:  
1212			 
1212				pop af 
1212				pop hl 
1212			 
1212				ret 
1212			 
1212			 
1212			 
1212			endif 
1212			 
1212			; eof 
# End of file firmware_memory.asm
1212			  
1212			; device C  
1212			if SOUND_ENABLE  
1212				include "firmware_sound.asm"  
1212			endif  
1212			  
1212			include "firmware_diags.asm"  
1212			; Hardware diags menu 
1212			 
1212			 
1212			config: 
1212			 
1212 3e 00			ld a, 0 
1214 21 3d 12			ld hl, .configmn 
1217 cd b6 09			call menu 
121a			 
121a fe 00			cp 0 
121c c8				ret z 
121d			 
121d fe 01			cp 1 
121f cc cf 12			call z, .savetostore 
1222			 
1222 fe 02			cp 2 
1224 cc cd 12			call z, .selautoload 
1227 fe 03			cp 3 
1229 cc ce 12			call z, .selbank 
122c fe 05			cp 5 
122e cc d0 12			call z, .debug_tog 
1231 fe 06			cp 6 
1233 cc 18 14			call z, .bpsgo 
1236 fe 07			cp 7 
1238 cc f6 12			call z, hardware_diags 
123b			 
123b 18 d5			jr config 
123d			 
123d			.configmn: 
123d 4d 12			dw .c3 
123f 69 12			dw .c2 
1241 7e 12			dw .c2b 
1243 92 12			dw .c4 
1245 9b 12			dw .m4 
1247 b6 12			dw .m4b 
1249 be 12			dw .c1 
124b 00 00			dw 0 
124d				 
124d			 
124d .. 00		.c3: db "Add User Dictionary To File",0 
1269 .. 00		.c2: db "Select Autoload File",0 
127e .. 00		.c2b: db "Select Storage Bank",0 
1292 .. 00		.c4: db "Settings",0 
129b .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
12b6 .. 00		.m4b:   db "Monitor",0 
12be .. 00		.c1: db "Hardware Diags",0 
12cd			 
12cd			 
12cd			 
12cd			; Select auto start 
12cd			 
12cd			.selautoload: 
12cd			 
12cd				 
12cd				if STORAGE_SE 
12cd			 
12cd					call config_dir 
12cd				        ld hl, scratch 
12cd					ld a, 0 
12cd					call menu 
12cd			 
12cd					cp 0 
12cd					ret z 
12cd			 
12cd					dec a 
12cd			 
12cd			 
12cd					; locate menu option 
12cd			 
12cd					ld hl, scratch 
12cd					call table_lookup 
12cd			 
12cd					if DEBUG_FORTH_WORDS 
12cd						DMARK "ALl" 
12cd						CALLMONITOR 
12cd					endif 
12cd					; with the pointer to the menu it, the byte following the zero term is the file id 
12cd			 
12cd					ld a, 0 
12cd					ld bc, 50   ; max of bytes to look at 
12cd					cpir  
12cd			 
12cd					if DEBUG_FORTH_WORDS 
12cd						DMARK "ALb" 
12cd						CALLMONITOR 
12cd					endif 
12cd					;inc hl 
12cd			 
12cd					ld a, (hl)   ; file id 
12cd					 
12cd				        ; save bank and file ids 
12cd			 
12cd					push af 
12cd			 
12cd			; TODO need to save to block 0 on bank 1	 
12cd			 
12cd					call storage_get_block_0 
12cd			 
12cd					if DEBUG_FORTH_WORDS 
12cd						DMARK "AL0" 
12cd						CALLMONITOR 
12cd					endif 
12cd					pop af 
12cd			 
12cd					ld (store_page+STORE_0_FILERUN),a 
12cd					 
12cd					; save bank id 
12cd			 
12cd					ld a,(spi_device) 
12cd					ld (store_page+STORE_0_BANKRUN),a 
12cd			 
12cd					; enable auto run of store file 
12cd			 
12cd					ld a, 1 
12cd					ld (store_page+STORE_0_AUTOFILE),a 
12cd			 
12cd					; save buffer 
12cd			 
12cd					ld hl, 0 
12cd					ld de, store_page 
12cd					if DEBUG_FORTH_WORDS 
12cd						DMARK "ALw" 
12cd						CALLMONITOR 
12cd					endif 
12cd				call storage_write_block	 ; save update 
12cd			  
12cd			 
12cd			 
12cd			 
12cd					ld hl, scratch 
12cd					call config_fdir 
12cd			 
12cd			 
12cd				endif 
12cd c9				ret 
12ce			 
12ce			 
12ce			 
12ce			; Select storage bank 
12ce			 
12ce			.selbank: 
12ce			 
12ce				if STORAGE_SE 
12ce				endif 
12ce				 
12ce c9				ret 
12cf			 
12cf			if STORAGE_SE 
12cf			 
12cf			.config_ldir:   
12cf				; Load storage bank labels into menu array 
12cf			 
12cf				 
12cf			 
12cf			 
12cf				ret 
12cf			 
12cf			 
12cf			endif 
12cf			 
12cf			 
12cf			; Save user words to storage 
12cf			 
12cf			.savetostore: 
12cf			 
12cf				if STORAGE_SE 
12cf			 
12cf					call config_dir 
12cf				        ld hl, scratch 
12cf					ld a, 0 
12cf					call menu 
12cf					 
12cf					ld hl, scratch 
12cf					call config_fdir 
12cf			 
12cf			 
12cf				endif 
12cf			 
12cf c9				ret 
12d0			 
12d0			 
12d0			 
12d0			if STORAGE_SE 
12d0			 
12d0			config_fdir: 
12d0				; using the scratch dir go through and release the memory allocated for each string 
12d0				 
12d0				ld hl, scratch 
12d0			.cfdir:	ld e,(hl) 
12d0				inc hl 
12d0				ld d,(hl) 
12d0				inc hl 
12d0			 
12d0				ex de, hl 
12d0				call ishlzero 
12d0				ret z     ; return on null pointer 
12d0				call free 
12d0				ex de, hl 
12d0				jr .cfdir 
12d0			 
12d0			 
12d0				ret 
12d0			 
12d0			 
12d0			config_dir: 
12d0			 
12d0				; for the config menus that need to build a directory of storage call this routine 
12d0				; it will construct a menu in scratch to pass to menu 
12d0			 
12d0				; open storage device 
12d0			 
12d0				; execute DIR to build a list of files and their ids into scratch in menu format 
12d0				; once the menu has finished then will need to call config_fdir to release the strings 
12d0				 
12d0				; c = number items 
12d0			 
12d0				 
12d0				call storage_get_block_0 
12d0			 
12d0				ld hl, store_page     ; get current id count 
12d0				ld b, (hl) 
12d0				ld c, 0    ; count of files   
12d0			 
12d0			 
12d0				ld hl, scratch 
12d0				ld (store_tmp2), hl    ; location to poke strings 
12d0			 
12d0				; check for empty drive 
12d0			 
12d0				ld a, 0 
12d0				cp b 
12d0				jp z, .dirdone 
12d0			 
12d0				 
12d0					if DEBUG_FORTH_WORDS 
12d0						DMARK "Cdc" 
12d0						CALLMONITOR 
12d0					endif 
12d0			 
12d0			 
12d0			.diritem:	 
12d0				push bc 
12d0				; for each of the current ids do a search for them and if found push to stack 
12d0			 
12d0					ld hl, STORE_BLOCK_PHY 
12d0					ld d, 0		 ; look for extent 0 of block id as this contains file name 
12d0					ld e,b 
12d0			 
12d0					call storage_findnextid 
12d0			 
12d0			 
12d0					; if found hl will be non zero 
12d0			 
12d0					call ishlzero 
12d0					jr z, .dirnotfound 
12d0			 
12d0					; increase count 
12d0			 
12d0					pop bc	 
12d0					inc c 
12d0					push bc 
12d0					 
12d0			 
12d0					; get file header and push the file name 
12d0			 
12d0					ld de, store_page 
12d0					call storage_read_block 
12d0			 
12d0					; push file id to stack 
12d0				 
12d0					ld a, (store_page) 
12d0					ld h, 0 
12d0					ld l, a 
12d0			 
12d0					;call forth_push_numhl 
12d0					; TODO store id 
12d0			 
12d0					push hl 
12d0			 
12d0					; push extent count to stack  
12d0				 
12d0					ld hl, store_page+3 
12d0			 
12d0					; get file name length 
12d0			 
12d0					call strlenz   
12d0			 
12d0					inc hl   ; cover zero term 
12d0					inc hl  ; stick the id at the end of the area 
12d0			 
12d0					push hl 
12d0					pop bc    ; move length to bc 
12d0			 
12d0					call malloc 
12d0			 
12d0					; TODO save malloc area to scratch 
12d0			 
12d0					ex de, hl 
12d0					ld hl, (store_tmp2) 
12d0					ld (hl), e 
12d0					inc hl 
12d0					ld (hl), d 
12d0					inc hl 
12d0					ld (store_tmp2), hl 
12d0			 
12d0					 
12d0			 
12d0					;pop hl   ; get source 
12d0			;		ex de, hl    ; swap aronund	 
12d0			 
12d0					ld hl, store_page+3 
12d0					if DEBUG_FORTH_WORDS 
12d0						DMARK "CFd" 
12d0						CALLMONITOR 
12d0					endif 
12d0					ldir 
12d0			 
12d0					; de is past string, move back one and store id 
12d0					 
12d0					dec de 
12d0			 
12d0					; store file id 
12d0			 
12d0					pop hl 
12d0					ex de,hl 
12d0					ld (hl), e 
12d0			 
12d0					if DEBUG_FORTH_WORDS 
12d0						DMARK "Cdi" 
12d0						CALLMONITOR 
12d0					endif 
12d0					 
12d0			.dirnotfound: 
12d0					pop bc     
12d0					djnz .diritem 
12d0				 
12d0			.dirdone:	 
12d0			 
12d0					ld a, 0 
12d0					ld hl, (store_tmp2) 
12d0					ld (hl), a 
12d0					inc hl 
12d0					ld (hl), a 
12d0					inc hl 
12d0					; push a count of the dir items found 
12d0			 
12d0			;		ld h, 0 
12d0			;		ld l, c 
12d0			 
12d0				ret 
12d0			 
12d0			endif 
12d0			 
12d0			 
12d0			; Settings 
12d0			; Run  
12d0			 
12d0			 
12d0			 
12d0			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
12d0			;;hd_menu2:   db "        2: Editor",0   
12d0			;hd_menu2:   db "        2: Editor       6: Menu",0   
12d0			;hd_menu3:   db "        3: Storage",0 
12d0			;hd_menu4:   db "0=quit  4: Debug",0 
12d0			;hd_don:     db "ON",0 
12d0			;hd_doff:     db "OFF",0 
12d0			; 
12d0			; 
12d0			; 
12d0			;hardware_diags_old:       
12d0			; 
12d0			;.diagmenu: 
12d0			;	call clear_display 
12d0			;	ld a, display_row_1 
12d0			;	ld de, hd_menu1 
12d0			;	call str_at_display 
12d0			; 
12d0			;	ld a, display_row_2 
12d0			;	ld de, hd_menu2 
12d0			;	call str_at_display 
12d0			; 
12d0			;	ld a, display_row_3 
12d0			;	ld de, hd_menu3 
12d0			;	call str_at_display 
12d0			; 
12d0			;	ld a,  display_row_4 
12d0			;	ld de, hd_menu4 
12d0			;	call str_at_display 
12d0			; 
12d0			;	; display debug state 
12d0			; 
12d0			;	ld de, hd_don 
12d0			;	ld a, (os_view_disable) 
12d0			;	cp 0 
12d0			;	jr z, .distog 
12d0			;	ld de, hd_doff 
12d0			;.distog: ld a, display_row_4+17 
12d0			;	call str_at_display 
12d0			; 
12d0			;	call update_display 
12d0			; 
12d0			;	call cin_wait 
12d0			; 
12d0			; 
12d0			; 
12d0			;	cp '4' 
12d0			;	jr nz, .diagn1 
12d0			; 
12d0			;	; debug toggle 
12d0			; 
12d0			;	ld a, (os_view_disable) 
12d0			;	ld b, '*' 
12d0			;	cp 0 
12d0			;	jr z, .debtog 
12d0			;	ld b, 0 
12d0			;.debtog:	 
12d0			;	ld a,b 
12d0			;	ld (os_view_disable),a 
12d0			; 
12d0			;.diagn1: cp '0' 
12d0			;	 ret z 
12d0			; 
12d0			;;	cp '1' 
12d0			;;       jp z, matrix	 
12d0			;;   TODO keyboard matrix test 
12d0			; 
12d0			;	cp '2' 
12d0			;	jp z, .diagedit 
12d0			; 
12d0			;;	cp '6' 
12d0			;;	jp z, .menutest 
12d0			;;if ENABLE_BASIC 
12d0			;;	cp '6' 
12d0			;;	jp z, basic 
12d0			;;endif 
12d0			 ; 
12d0			;	jp .diagmenu 
12d0			; 
12d0			; 
12d0			;	ret 
12d0			 
12d0			 
12d0			.debug_tog: 
12d0 21 17 13			ld hl, .menudebug 
12d3				 
12d3 3a 51 e3			ld a, (os_view_disable) 
12d6 fe 2a			cp '*' 
12d8 20 04			jr nz,.tdon  
12da 3e 01			ld a, 1 
12dc 18 02			jr .tog1 
12de 3e 00		.tdon: ld a, 0 
12e0			 
12e0			.tog1: 
12e0 cd b6 09			call menu 
12e3 fe 00			cp 0 
12e5 c8				ret z 
12e6 fe 01			cp 1    ; disable debug 
12e8 28 04			jr z, .dtog0 
12ea 3e 2a			ld a, '*' 
12ec 18 02			jr .dtogset 
12ee 3e 00		.dtog0: ld a, 0 
12f0 32 51 e3		.dtogset:  ld (os_view_disable), a 
12f3 c3 d0 12			jp .debug_tog 
12f6			 
12f6			 
12f6			hardware_diags:       
12f6			 
12f6			.diagm: 
12f6 21 09 13			ld hl, .menuitems 
12f9 3e 00			ld a, 0 
12fb cd b6 09			call menu 
12fe			 
12fe fe 00		         cp 0 
1300 c8				 ret z 
1301			 
1301 fe 02			cp 2 
1303 ca 62 13			jp z, .diagedit 
1306			 
1306			;	cp '6' 
1306			;	jp z, .menutest 
1306			;if ENABLE_BASIC 
1306			;	cp '6' 
1306			;	jp z, basic 
1306			;endif 
1306			  
1306 c3 f6 12			jp .diagm 
1309			 
1309				 
1309 1d 13		.menuitems:   	dw .m1 
130b 28 13				dw .m2 
130d 2f 13				dw .m3 
130f 37 13				dw .m5 
1311 3d 13				dw .m5a 
1313 46 13				dw .m5b 
1315 00 00				dw 0 
1317			 
1317			.menudebug: 
1317 4f 13				dw .m6 
1319 58 13				dw .m7 
131b 00 00				dw 0 
131d			 
131d .. 00		.m1:   db "Key Matrix",0 
1328 .. 00		.m2:   db "Editor",0 
132f .. 00		.m3:   db "Storage",0 
1337 .. 00		.m5:   db "Sound",0 
133d .. 00		.m5a:  db "RAM Test",0 
1346 .. 00		.m5b:  db "LCD Test",0 
134f			 
134f .. 00		.m6:   db "Debug ON",0 
1358 .. 00		.m7:   db "Debug OFF",0 
1362			 
1362			; debug editor 
1362			 
1362			.diagedit: 
1362			 
1362 21 60 e3			ld hl, scratch 
1365			;	ld bc, 250 
1365			;	ldir 
1365				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1365 3e 00			ld a, 0 
1367 77				ld (hl), a 
1368 23				inc hl 
1369 77				ld (hl), a 
136a 23				inc hl 
136b 77				ld (hl), a 
136c			 
136c cd 85 09		        call clear_display 
136f cd a8 09			call update_display 
1372 3e 01			ld a, 1 
1374 32 80 ee			ld (hardware_diag), a 
1377			.diloop: 
1377 3e 00			ld a, display_row_1 
1379 0e 00			ld c, 0 
137b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
137d 1e 28			ld e, 40 
137f			 
137f 21 60 e3			ld hl, scratch	 
1382 cd df 0b			call input_str 
1385			 
1385 3e 28			ld a, display_row_2 
1387 11 60 e3			ld de, scratch 
138a cd 98 09			call str_at_display 
138d cd a8 09			call update_display 
1390			 
1390 c3 77 13			jp .diloop 
1393			 
1393			 
1393			; pass word in hl 
1393			; a has display location 
1393			display_word_at: 
1393 f5				push af 
1394 e5				push hl 
1395 7c				ld a,h 
1396 21 65 e6			ld hl, os_word_scratch 
1399 cd b3 0e			call hexout 
139c e1				pop hl 
139d 7d				ld a,l 
139e 21 67 e6			ld hl, os_word_scratch+2 
13a1 cd b3 0e			call hexout 
13a4 21 69 e6			ld hl, os_word_scratch+4 
13a7 3e 00			ld a,0 
13a9 77				ld (hl),a 
13aa 11 65 e6			ld de,os_word_scratch 
13ad f1				pop af 
13ae cd 98 09				call str_at_display 
13b1 c9				ret 
13b2			 
13b2			display_ptr_state: 
13b2			 
13b2				; to restore afterwards 
13b2			 
13b2 d5				push de 
13b3 c5				push bc 
13b4 e5				push hl 
13b5 f5				push af 
13b6			 
13b6				; for use in here 
13b6			 
13b6			;	push bc 
13b6			;	push de 
13b6			;	push hl 
13b6			;	push af 
13b6			 
13b6 cd 85 09			call clear_display 
13b9			 
13b9 11 8c 15			ld de, .ptrstate 
13bc 3e 00			ld a, display_row_1 
13be cd 98 09			call str_at_display 
13c1			 
13c1				; display debug step 
13c1			 
13c1			 
13c1 11 7a ee			ld de, debug_mark 
13c4 3e 26			ld a, display_row_1+display_cols-2 
13c6 cd 98 09			call str_at_display 
13c9			 
13c9				; display a 
13c9 11 96 15			ld de, .ptrcliptr 
13cc 3e 28			ld a, display_row_2 
13ce cd 98 09			call str_at_display 
13d1			 
13d1 f1				pop af 
13d2 2a 2b eb			ld hl,(cli_ptr) 
13d5 3e 30			ld a, display_row_2+8 
13d7 cd 93 13			call display_word_at 
13da			 
13da			 
13da				; display hl 
13da			 
13da			 
13da 11 9e 15			ld de, .ptrclioptr 
13dd 3e 32			ld a, display_row_2+10 
13df cd 98 09			call str_at_display 
13e2			; 
13e2			;	pop hl 
13e2 3e 35			ld a, display_row_2+13 
13e4 2a 29 eb			ld hl,(cli_origptr) 
13e7 cd 93 13			call display_word_at 
13ea			; 
13ea			;	 
13ea			;	; display de 
13ea			 
13ea			;	ld de, .regstatede 
13ea			;	ld a, display_row_3 
13ea			;	call str_at_display 
13ea			 
13ea			;	pop de 
13ea			;	ld h,d 
13ea			;	ld l, e 
13ea			;	ld a, display_row_3+3 
13ea			;	call display_word_at 
13ea			 
13ea			 
13ea				; display bc 
13ea			 
13ea			;	ld de, .regstatebc 
13ea			;	ld a, display_row_3+10 
13ea			;	call str_at_display 
13ea			 
13ea			;	pop bc 
13ea			;	ld h,b 
13ea			;	ld l, c 
13ea			;	ld a, display_row_3+13 
13ea			;	call display_word_at 
13ea			 
13ea			 
13ea				; display dsp 
13ea			 
13ea			;	ld de, .regstatedsp 
13ea			;	ld a, display_row_4 
13ea			;	call str_at_display 
13ea			 
13ea				 
13ea			;	ld hl,(cli_data_sp) 
13ea			;	ld a, display_row_4+4 
13ea			;	call display_word_at 
13ea			 
13ea				; display rsp 
13ea			 
13ea 11 cd 15			ld de, .regstatersp 
13ed 3e 82			ld a, display_row_4+10 
13ef cd 98 09			call str_at_display 
13f2			 
13f2				 
13f2 2a 11 eb			ld hl,(cli_ret_sp) 
13f5 3e 86			ld a, display_row_4+14 
13f7 cd 93 13			call display_word_at 
13fa			 
13fa cd a8 09			call update_display 
13fd			 
13fd cd fa 08			call delay1s 
1400 cd fa 08			call delay1s 
1403 cd fa 08			call delay1s 
1406			 
1406			 
1406 cd 13 19			call next_page_prompt 
1409			 
1409				; restore  
1409			 
1409 f1				pop af 
140a e1				pop hl 
140b c1				pop bc 
140c d1				pop de 
140d c9				ret 
140e			 
140e			break_point_state: 
140e f5				push af 
140f			 
140f				; see if disabled 
140f			 
140f 3a 51 e3			ld a, (os_view_disable) 
1412 fe 2a			cp '*' 
1414 20 02			jr nz, .bpsgo 
1416 f1				pop af 
1417 c9				ret 
1418			 
1418			.bpsgo: 
1418 f1				pop af 
1419 f5				push af 
141a 22 4d e3			ld (os_view_hl), hl 
141d ed 53 4b e3		ld (os_view_de), de 
1421 ed 43 49 e3		ld (os_view_bc), bc 
1425 e5				push hl 
1426 6f				ld l, a 
1427 26 00			ld h, 0 
1429 22 4f e3			ld (os_view_af),hl 
142c			 
142c 21 c0 ed				ld hl, display_fb0 
142f 22 db eb				ld (display_fb_active), hl 
1432 e1				pop hl	 
1433			 
1433 3e 31			ld a, '1' 
1435 fe 2a		.bps1:  cp '*' 
1437 20 03			jr nz, .bps1b 
1439 32 51 e3			ld (os_view_disable),a 
143c fe 31		.bps1b:  cp '1' 
143e 20 14			jr nz, .bps2 
1440			 
1440				; display reg 
1440			 
1440				 
1440			 
1440 3a 4f e3			ld a, (os_view_af) 
1443 2a 4d e3			ld hl, (os_view_hl) 
1446 ed 5b 4b e3		ld de, (os_view_de) 
144a ed 4b 49 e3		ld bc, (os_view_bc) 
144e cd e8 14			call display_reg_state 
1451 c3 d4 14			jp .bpschk 
1454			 
1454 fe 32		.bps2:  cp '2' 
1456 20 08			jr nz, .bps3 
1458				 
1458				; display hl 
1458 2a 4d e3			ld hl, (os_view_hl) 
145b cd d2 15			call display_dump_at_hl 
145e			 
145e 18 74			jr .bpschk 
1460			 
1460 fe 33		.bps3:  cp '3' 
1462 20 08			jr nz, .bps4 
1464			 
1464			        ; display de 
1464 2a 4b e3			ld hl, (os_view_de) 
1467 cd d2 15			call display_dump_at_hl 
146a			 
146a 18 68			jr .bpschk 
146c fe 34		.bps4:  cp '4' 
146e 20 08			jr nz, .bps5 
1470			 
1470			        ; display bc 
1470 2a 49 e3			ld hl, (os_view_bc) 
1473 cd d2 15			call display_dump_at_hl 
1476			 
1476 18 5c			jr .bpschk 
1478 fe 35		.bps5:  cp '5' 
147a 20 08		        jr nz, .bps7 
147c			 
147c				; display cur ptr 
147c 2a 2b eb			ld hl, (cli_ptr) 
147f cd d2 15			call display_dump_at_hl 
1482			 
1482 18 50			jr .bpschk 
1484 fe 36		.bps7:  cp '6' 
1486 20 08			jr nz, .bps8b 
1488				 
1488				; display cur orig ptr 
1488 2a 29 eb			ld hl, (cli_origptr) 
148b cd d2 15			call display_dump_at_hl 
148e 18 44			jr .bpschk 
1490 fe 37		.bps8b:  cp '7' 
1492 20 08			jr nz, .bps9 
1494				 
1494				; display dsp 
1494 2a 0d eb			ld hl, (cli_data_sp) 
1497 cd d2 15			call display_dump_at_hl 
149a			 
149a 18 38			jr .bpschk 
149c fe 39		.bps9:  cp '9' 
149e 20 05			jr nz, .bps8c 
14a0				 
14a0				; display SP 
14a0			;	ld hl, sp 
14a0 cd d2 15			call display_dump_at_hl 
14a3			 
14a3 18 2f			jr .bpschk 
14a5 fe 38		.bps8c:  cp '8' 
14a7 20 08			jr nz, .bps8d 
14a9				 
14a9				; display rsp 
14a9 2a 11 eb			ld hl, (cli_ret_sp) 
14ac cd d2 15			call display_dump_at_hl 
14af			 
14af 18 23			jr .bpschk 
14b1 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
14b3 20 05			jr nz, .bps8 
14b5 cd 09 17			call monitor 
14b8			 
14b8 18 1a			jr .bpschk 
14ba fe 30		.bps8:  cp '0' 
14bc 20 16			jr nz, .bpschk 
14be			 
14be 21 1f ed				ld hl, display_fb1 
14c1 22 db eb				ld (display_fb_active), hl 
14c4 cd a8 09				call update_display 
14c7			 
14c7				;ld a, (os_view_af) 
14c7 2a 4d e3			ld hl, (os_view_hl) 
14ca ed 5b 4b e3		ld de, (os_view_de) 
14ce ed 4b 49 e3		ld bc, (os_view_bc) 
14d2 f1				pop af 
14d3 c9				ret 
14d4			 
14d4			.bpschk:   
14d4 cd fa 08			call delay1s 
14d7 3e 9f		ld a,display_row_4 + display_cols - 1 
14d9 11 11 19		        ld de, endprg 
14dc cd 98 09			call str_at_display 
14df cd a8 09			call update_display 
14e2 cd c5 59			call cin_wait 
14e5			 
14e5 c3 35 14			jp .bps1 
14e8			 
14e8			 
14e8			display_reg_state: 
14e8			 
14e8				; to restore afterwards 
14e8			 
14e8 d5				push de 
14e9 c5				push bc 
14ea e5				push hl 
14eb f5				push af 
14ec			 
14ec				; for use in here 
14ec			 
14ec c5				push bc 
14ed d5				push de 
14ee e5				push hl 
14ef f5				push af 
14f0			 
14f0 cd 85 09			call clear_display 
14f3			 
14f3 11 a8 15			ld de, .regstate 
14f6 3e 00			ld a, display_row_1 
14f8 cd 98 09			call str_at_display 
14fb			 
14fb				; display debug step 
14fb			 
14fb			 
14fb 11 7a ee			ld de, debug_mark 
14fe 3e 25			ld a, display_row_1+display_cols-3 
1500 cd 98 09			call str_at_display 
1503			 
1503				; display a 
1503 11 c4 15			ld de, .regstatea 
1506 3e 28			ld a, display_row_2 
1508 cd 98 09			call str_at_display 
150b			 
150b e1				pop hl 
150c			;	ld h,0 
150c			;	ld l, a 
150c 3e 2b			ld a, display_row_2+3 
150e cd 93 13			call display_word_at 
1511			 
1511			 
1511				; display hl 
1511			 
1511			 
1511 11 b8 15			ld de, .regstatehl 
1514 3e 32			ld a, display_row_2+10 
1516 cd 98 09			call str_at_display 
1519			 
1519 e1				pop hl 
151a 3e 35			ld a, display_row_2+13 
151c cd 93 13			call display_word_at 
151f			 
151f				 
151f				; display de 
151f			 
151f 11 bc 15			ld de, .regstatede 
1522 3e 50			ld a, display_row_3 
1524 cd 98 09			call str_at_display 
1527			 
1527 e1				pop hl 
1528			;	ld h,d 
1528			;	ld l, e 
1528 3e 53			ld a, display_row_3+3 
152a cd 93 13			call display_word_at 
152d			 
152d			 
152d				; display bc 
152d			 
152d 11 c0 15			ld de, .regstatebc 
1530 3e 5a			ld a, display_row_3+10 
1532 cd 98 09			call str_at_display 
1535			 
1535 e1				pop hl 
1536			;	ld h,b 
1536			;	ld l, c 
1536 3e 5d			ld a, display_row_3+13 
1538 cd 93 13			call display_word_at 
153b			 
153b			 
153b				; display dsp 
153b			 
153b 11 c8 15			ld de, .regstatedsp 
153e 3e 78			ld a, display_row_4 
1540 cd 98 09			call str_at_display 
1543			 
1543				 
1543 2a 0d eb			ld hl,(cli_data_sp) 
1546 3e 7c			ld a, display_row_4+4 
1548 cd 93 13			call display_word_at 
154b			 
154b				; display rsp 
154b			 
154b 11 cd 15			ld de, .regstatersp 
154e 3e 82			ld a, display_row_4+10 
1550 cd 98 09			call str_at_display 
1553			 
1553				 
1553 2a 11 eb			ld hl,(cli_ret_sp) 
1556 3e 86			ld a, display_row_4+14 
1558 cd 93 13			call display_word_at 
155b			 
155b cd a8 09			call update_display 
155e			 
155e			;	call delay1s 
155e			;	call delay1s 
155e			;	call delay1s 
155e			 
155e			 
155e			;	call next_page_prompt 
155e			 
155e				; restore  
155e			 
155e f1				pop af 
155f e1				pop hl 
1560 c1				pop bc 
1561 d1				pop de 
1562 c9				ret 
1563			 
1563 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1577 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
158c .. 00		.ptrstate:	db "Ptr State",0 
1596 .. 00		.ptrcliptr:     db "cli_ptr",0 
159e .. 00		.ptrclioptr:     db "cli_o_ptr",0 
15a8 .. 00		.regstate:	db "Reg State (1/0)",0 
15b8 .. 00		.regstatehl:	db "HL:",0 
15bc .. 00		.regstatede:	db "DE:",0 
15c0 .. 00		.regstatebc:	db "BC:",0 
15c4 .. 00		.regstatea:	db "A :",0 
15c8 .. 00		.regstatedsp:	db "DSP:",0 
15cd .. 00		.regstatersp:	db "RSP:",0 
15d2			 
15d2			display_dump_at_hl: 
15d2 e5				push hl 
15d3 d5				push de 
15d4 c5				push bc 
15d5 f5				push af 
15d6			 
15d6 22 83 e6			ld (os_cur_ptr),hl	 
15d9 cd 85 09			call clear_display 
15dc cd 1b 18			call dumpcont 
15df			;	call delay1s 
15df			;	call next_page_prompt 
15df			 
15df			 
15df f1				pop af 
15e0 c1				pop bc 
15e1 d1				pop de 
15e2 e1				pop hl 
15e3 c9				ret 
15e4			 
15e4			;if ENABLE_BASIC 
15e4			;	include "nascombasic.asm" 
15e4			;	basic: 
15e4			;	include "forth/FORTH.ASM" 
15e4			;endif 
15e4			 
15e4			; eof 
15e4			 
15e4			 
# End of file firmware_diags.asm
15e4			  
15e4			  
15e4			  
15e4			  
15e4			; eof  
15e4			  
# End of file firmware.asm
15e4			 
15e4			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
15e4			;if BASE_KEV  
15e4			;baseram: equ 08000h 
15e4			;endif 
15e4			 
15e4			;if BASE_SC114 
15e4			;baseram:     equ    endofcode 
15e4			;endif 
15e4			 
15e4			 
15e4			; start system 
15e4			 
15e4			coldstart: 
15e4				; set sp 
15e4				; di/ei 
15e4			 
15e4 f3				di 
15e5 31 00 f0			ld sp, tos 
15e8			;	ei 
15e8			 
15e8			 
15e8				; disable breakpoint by default 
15e8			 
15e8 3e 2a			ld a,'*' 
15ea 32 51 e3			ld (os_view_disable),a 
15ed			 
15ed				; init hardware 
15ed			 
15ed				; init keyboard and screen hardware 
15ed			 
15ed cd 03 01			call hardware_init 
15f0			 
15f0			 
15f0				; detect if any keys are held down to enable breakpoints at start up 
15f0			 
15f0 cd cd 59			call cin  
15f3 fe 00			cp 0 
15f5 28 03			jr z, .nokeys 
15f7			 
15f7				;call hardware_diags 
15f7 cd 12 12			call config 
15fa			 
15fa			;	ld de, .bpen 
15fa			;	ld a, display_row_4 
15fa			;	call str_at_display 
15fa			;	call update_display 
15fa			; 
15fa			;	ld a,0 
15fa			;	ld (os_view_disable),a 
15fa			; 
15fa			;.bpwait: 
15fa			;	call cin 
15fa			;	cp 0 
15fa			;	jr z, .bpwait 
15fa			;	jr .nokeys 
15fa			; 
15fa			; 
15fa			;.bpen:  db "Break points enabled!",0 
15fa			 
15fa			 
15fa			 
15fa			 
15fa			 
15fa			 
15fa			.nokeys: 
15fa			 
15fa			 
15fa				 
15fa			 
15fa			;jp  testkey 
15fa			 
15fa			;call storage_get_block_0 
15fa			; 
15fa			;ld hl, 0 
15fa			;ld de, store_page 
15fa			;call storage_read_block 
15fa			 
15fa				 
15fa			;ld hl, 10 
15fa			;ld de, store_page 
15fa			;call storage_read_block 
15fa			 
15fa			 
15fa			 
15fa			 
15fa			 
15fa			;stop:	nop 
15fa			;	jp stop 
15fa			 
15fa			 
15fa			 
15fa			main: 
15fa cd 85 09			call clear_display 
15fd cd a8 09			call update_display 
1600			 
1600			 
1600			 
1600			;	call testlcd 
1600			 
1600			 
1600			 
1600 cd d9 1c			call forth_init 
1603			 
1603			 
1603			warmstart: 
1603 cd af 1c			call forth_warmstart 
1606			 
1606				; run startup word load 
1606			        ; TODO prevent this running at warmstart after crash  
1606			 
1606				if STARTUP_ENABLE 
1606 cd 13 56				call forth_startup 
1609			 
1609					if STORAGE_SE 
1609						call forth_autoload 
1609					endif 
1609			 
1609				endif 
1609			 
1609				; show free memory after boot 
1609 11 a3 16			ld de, freeram 
160c 3e 00			ld a, display_row_1 
160e cd 98 09			call str_at_display 
1611			 
1611			; Or use heap_size word???? 
1611 21 46 e3			ld hl, heap_end 
1614 11 f5 59			ld de, heap_start 
1617 ed 52			sbc hl, de 
1619 e5				push hl 
161a 7c				ld a,h	         	 
161b 21 65 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
161e cd b3 0e			call hexout 
1621 e1			   	pop hl 
1622			 
1622 7d				ld a,l 
1623 21 67 e6			ld hl, os_word_scratch+2 
1626 cd b3 0e			call hexout 
1629 21 69 e6			ld hl, os_word_scratch+4 
162c 3e 00			ld a, 0 
162e 77				ld (hl),a 
162f 11 65 e6			ld de, os_word_scratch 
1632 3e 0d			ld a, display_row_1 + 13 
1634 cd 98 09			call str_at_display 
1637 cd a8 09			call update_display 
163a			 
163a			 
163a				;call demo 
163a			 
163a			 
163a				; init scratch input area for cli commands 
163a			 
163a 21 87 e6			ld hl, os_cli_cmd 
163d 3e 00			ld a,0 
163f 77				ld (hl),a 
1640 23				inc hl 
1641 77				ld (hl),a 
1642			 
1642 3e 00			ld a,0 
1644 32 86 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1647			 
1647 32 83 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
164a 32 84 e6			ld (os_cur_ptr+1),a	 
164d			 
164d 32 65 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1650 32 66 e6			ld (os_word_scratch+1),a	 
1653				 
1653			 
1653				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1653 21 87 e6			ld hl, os_cli_cmd 
1656			 
1656 3e 00			ld a, 0		 ; init cli input 
1658 77				ld (hl), a 
1659 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
165b			cli: 
165b				; show cli prompt 
165b				;push af 
165b				;ld a, 0 
165b				;ld de, prompt 
165b				;call str_at_display 
165b			 
165b				;call update_display 
165b				;pop af 
165b				;inc a 
165b				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
165b 0e 00			ld c, 0 
165d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
165f 1e 28			ld e, 40 
1661			 
1661 21 87 e6			ld hl, os_cli_cmd 
1664			 
1664				STACKFRAME OFF $fefe $9f9f 
1664				if DEBUG_STACK_IMB 
1664					if OFF 
1664						exx 
1664						ld de, $fefe 
1664						ld a, d 
1664						ld hl, curframe 
1664						call hexout 
1664						ld a, e 
1664						ld hl, curframe+2 
1664						call hexout 
1664						ld hl, $fefe 
1664						push hl 
1664						ld hl, $9f9f 
1664						push hl 
1664						exx 
1664					endif 
1664				endif 
1664			endm 
# End of macro STACKFRAME
1664			 
1664 cd df 0b			call input_str 
1667			 
1667				STACKFRAMECHK OFF $fefe $9f9f 
1667				if DEBUG_STACK_IMB 
1667					if OFF 
1667						exx 
1667						ld hl, $9f9f 
1667						pop de   ; $9f9f 
1667						call cmp16 
1667						jr nz, .spnosame 
1667						ld hl, $fefe 
1667						pop de   ; $fefe 
1667						call cmp16 
1667						jr z, .spfrsame 
1667						.spnosame: call showsperror 
1667						.spfrsame: nop 
1667						exx 
1667					endif 
1667				endif 
1667			endm 
# End of macro STACKFRAMECHK
1667			 
1667				; copy input to last command 
1667			 
1667 21 87 e6			ld hl, os_cli_cmd 
166a 11 86 e7			ld de, os_last_cmd 
166d 01 ff 00			ld bc, 255 
1670 ed b0			ldir 
1672			 
1672				; wipe current buffer 
1672			 
1672			;	ld a, 0 
1672			;	ld hl, os_cli_cmd 
1672			;	ld de, os_cli_cmd+1 
1672			;	ld bc, 254 
1672			;	ldir 
1672				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1672			;	call strcpy 
1672			;	ld a, 0 
1672			;	ld (hl), a 
1672			;	inc hl 
1672			;	ld (hl), a 
1672			;	inc hl 
1672			;	ld (hl), a 
1672			 
1672				; switch frame buffer to program  
1672			 
1672 21 1f ed				ld hl, display_fb1 
1675 22 db eb				ld (display_fb_active), hl 
1678			 
1678			;	nop 
1678				STACKFRAME ON $fbfe $8f9f 
1678				if DEBUG_STACK_IMB 
1678					if ON 
1678						exx 
1678						ld de, $fbfe 
1678						ld a, d 
1678						ld hl, curframe 
1678						call hexout 
1678						ld a, e 
1678						ld hl, curframe+2 
1678						call hexout 
1678						ld hl, $fbfe 
1678						push hl 
1678						ld hl, $8f9f 
1678						push hl 
1678						exx 
1678					endif 
1678				endif 
1678			endm 
# End of macro STACKFRAME
1678				; first time into the parser so pass over the current scratch pad 
1678 21 87 e6			ld hl,os_cli_cmd 
167b				; tokenise the entered statement(s) in HL 
167b cd 52 1d			call forthparse 
167e			        ; exec forth statements in top of return stack 
167e cd 92 1d			call forthexec 
1681				;call forthexec_cleanup 
1681			;	call parsenext 
1681			 
1681				STACKFRAMECHK ON $fbfe $8f9f 
1681				if DEBUG_STACK_IMB 
1681					if ON 
1681						exx 
1681						ld hl, $8f9f 
1681						pop de   ; $8f9f 
1681						call cmp16 
1681						jr nz, .spnosame 
1681						ld hl, $fbfe 
1681						pop de   ; $fbfe 
1681						call cmp16 
1681						jr z, .spfrsame 
1681						.spnosame: call showsperror 
1681						.spfrsame: nop 
1681						exx 
1681					endif 
1681				endif 
1681			endm 
# End of macro STACKFRAMECHK
1681				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1681			 
1681 3e 78			ld a, display_row_4 
1683 11 b5 16			ld de, endprog 
1686			 
1686 cd a8 09			call update_display		 
1689			 
1689 cd 13 19			call next_page_prompt 
168c			 
168c				; switch frame buffer to cli 
168c			 
168c 21 c0 ed				ld hl, display_fb0 
168f 22 db eb				ld (display_fb_active), hl 
1692			 
1692			 
1692 cd 85 09		        call clear_display 
1695 cd a8 09			call update_display		 
1698			 
1698 21 87 e6			ld hl, os_cli_cmd 
169b			 
169b 3e 00			ld a, 0		 ; init cli input 
169d 77				ld (hl), a 
169e			 
169e				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
169e			 
169e				; now on last line 
169e			 
169e				; TODO scroll screen up 
169e			 
169e				; TODO instead just clear screen and place at top of screen 
169e			 
169e			;	ld a, 0 
169e			;	ld (f_cursor_ptr),a 
169e			 
169e				;call clear_display 
169e				;call update_display 
169e			 
169e				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
169e 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16a0 c3 5b 16			jp cli 
16a3			 
16a3 .. 00		freeram: db "Free bytes: $",0 
16b1 ..			asc: db "1A2F" 
16b5 .. 00		endprog: db "End prog...",0 
16c1			 
16c1			testenter2:   
16c1 21 92 e3			ld hl,scratch+50 
16c4 22 83 e6			ld (os_cur_ptr),hl 
16c7 c3 5b 16			jp cli 
16ca			 
16ca			testenter:  
16ca			 
16ca 21 b1 16			ld hl,asc 
16cd			;	ld a,(hl) 
16cd			;	call nibble2val 
16cd cd 09 0f			call get_byte 
16d0			 
16d0			 
16d0			;	ld a,(hl) 
16d0			;	call atohex 
16d0			 
16d0			;	call fourehexhl 
16d0 32 92 e3			ld (scratch+50),a 
16d3			 
16d3			 
16d3			 
16d3 21 b3 16			ld hl,asc+2 
16d6			;	ld a, (hl) 
16d6			;	call nibble2val 
16d6 cd 09 0f			call get_byte 
16d9			 
16d9			;	call fourehexhl 
16d9 32 94 e3			ld (scratch+52),a 
16dc				 
16dc 21 92 e3			ld hl,scratch+50 
16df 22 83 e6			ld (os_cur_ptr),hl 
16e2 c3 5b 16			jp cli 
16e5			 
16e5			enter:	 
16e5 3a 64 e3			ld a,(scratch+4) 
16e8 fe 00			cp 0 
16ea 28 0c			jr z, .entercont 
16ec				; no, not a null term line so has an address to work out.... 
16ec			 
16ec 21 62 e3			ld hl,scratch+2 
16ef cd 69 0f			call get_word_hl 
16f2			 
16f2 22 83 e6			ld (os_cur_ptr),hl	 
16f5 c3 5b 16			jp cli 
16f8			 
16f8			 
16f8			.entercont:  
16f8			 
16f8 21 62 e3			ld hl, scratch+2 
16fb cd 09 0f			call get_byte 
16fe			 
16fe 2a 83 e6		   	ld hl,(os_cur_ptr) 
1701 77					ld (hl),a 
1702 23					inc hl 
1703 22 83 e6				ld (os_cur_ptr),hl 
1706				 
1706			; get byte  
1706			 
1706			 
1706 c3 5b 16			jp cli 
1709			 
1709			 
1709			; basic monitor support 
1709			 
1709			monitor: 
1709				;  
1709 cd 85 09			call clear_display 
170c 3e 00			ld a, 0 
170e 11 56 17			ld de, .monprompt 
1711 cd 98 09			call str_at_display 
1714 cd a8 09			call update_display 
1717			 
1717				; get a monitor command 
1717			 
1717 0e 00			ld c, 0     ; entry at top left 
1719 16 64			ld d, 100   ; max buffer size 
171b 1e 0f			ld e, 15    ; input scroll area 
171d 3e 00			ld a, 0     ; init string 
171f 21 5e e5			ld hl, os_input 
1722 77				ld (hl), a 
1723 23				inc hl 
1724 77				ld (hl), a 
1725 21 5e e5			ld hl, os_input 
1728 3e 01			ld a, 1     ; init string 
172a cd df 0b			call input_str 
172d			 
172d cd 85 09		        call clear_display 
1730 cd a8 09			call update_display		 
1733			 
1733 3a 5e e5			ld a, (os_input) 
1736 cd 07 10			call toUpper 
1739 fe 48		        cp 'H' 
173b 28 6f		        jr z, .monhelp 
173d fe 44			cp 'D'		; dump 
173f ca cd 17			jp z, .mondump	 
1742 fe 43			cp 'C'		; dump 
1744 ca e7 17			jp z, .moncdump	 
1747 fe 4d			cp 'M'		; dump 
1749 ca 58 17			jp z, .moneditstart 
174c fe 55			cp 'U'		; dump 
174e 28 14			jr z, .monedit	 
1750 fe 51			cp 'Q'		; dump 
1752 c8				ret z	 
1753			 
1753			 
1753				; TODO "S" to access symbol by name and not need the address 
1753				; TODO "F" to find a string in memory 
1753			 
1753 c3 09 17			jp monitor 
1756			 
1756 .. 00		.monprompt: db ">", 0 
1758			 
1758			.moneditstart: 
1758				; get starting address 
1758			 
1758 21 60 e5			ld hl,os_input+2 
175b cd 69 0f			call get_word_hl 
175e			 
175e 22 83 e6			ld (os_cur_ptr),hl	 
1761			 
1761 c3 09 17			jp monitor 
1764			 
1764			.monedit: 
1764				; get byte to load 
1764			 
1764 21 60 e5			ld hl,os_input+2 
1767 cd 09 0f			call get_byte 
176a			 
176a				; get address to update 
176a 2a 83 e6			ld hl, (os_cur_ptr) 
176d			 
176d				; update byte 
176d			 
176d 77				ld (hl), a 
176e			 
176e				; move to next address and save it 
176e			 
176e 23				inc hl 
176f 22 83 e6			ld (os_cur_ptr),hl	 
1772			 
1772 c3 09 17			jp monitor 
1775			 
1775			 
1775 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1789 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
17a5 .. 00		.monhelptext3:  db "Q-Quit",0 
17ac			        
17ac			.monhelp: 
17ac 3e 00			ld a, display_row_1 
17ae 11 75 17		        ld de, .monhelptext1 
17b1			 
17b1 cd 98 09			call str_at_display 
17b4 3e 28			ld a, display_row_2 
17b6 11 89 17		        ld de, .monhelptext2 
17b9					 
17b9 cd 98 09			call str_at_display 
17bc 3e 50			ld a, display_row_3 
17be 11 a5 17		        ld de, .monhelptext3 
17c1					 
17c1 cd 98 09			call str_at_display 
17c4 cd a8 09			call update_display		 
17c7			 
17c7 cd 13 19			call next_page_prompt 
17ca c3 09 17			jp monitor 
17cd			 
17cd			.mondump:    
17cd 21 60 e5			ld hl,os_input+2 
17d0 cd 69 0f			call get_word_hl 
17d3			 
17d3 22 83 e6			ld (os_cur_ptr),hl	 
17d6 cd 1b 18			call dumpcont 
17d9 3e 78			ld a, display_row_4 
17db 11 b5 16			ld de, endprog 
17de			 
17de cd a8 09			call update_display		 
17e1			 
17e1 cd 13 19			call next_page_prompt 
17e4 c3 09 17			jp monitor 
17e7			.moncdump: 
17e7 cd 1b 18			call dumpcont 
17ea 3e 78			ld a, display_row_4 
17ec 11 b5 16			ld de, endprog 
17ef			 
17ef cd a8 09			call update_display		 
17f2			 
17f2 cd 13 19			call next_page_prompt 
17f5 c3 09 17			jp monitor 
17f8			 
17f8			 
17f8			; TODO symbol access  
17f8			 
17f8			.symbols:     ;; A list of symbols that can be called up  
17f8 c0 ed			dw display_fb0 
17fa .. 00			db "fb0",0  
17fe 65 eb		     	dw store_page 
1800 .. 00			db "store_page",0 
180b			 
180b			 
180b			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
180b			 
180b 3a 61 e3			ld a,(scratch+1) 
180e fe 00			cp 0 
1810 28 09			jr z, dumpcont 
1812			 
1812				; no, not a null term line so has an address to work out.... 
1812			 
1812 21 62 e3			ld hl,scratch+2 
1815 cd 69 0f			call get_word_hl 
1818			 
1818 22 83 e6			ld (os_cur_ptr),hl	 
181b			 
181b			 
181b			 
181b			dumpcont: 
181b			 
181b				; dump bytes at ptr 
181b			 
181b			 
181b 3e 00			ld a, display_row_1 
181d 2a db eb			ld hl, (display_fb_active) 
1820 cd b2 0b			call addatohl 
1823 cd 4b 18			call .dumpbyterow 
1826			 
1826 3e 28			ld a, display_row_2 
1828 2a db eb			ld hl, (display_fb_active) 
182b cd b2 0b			call addatohl 
182e cd 4b 18			call .dumpbyterow 
1831			 
1831			 
1831 3e 50			ld a, display_row_3 
1833 2a db eb			ld hl, (display_fb_active) 
1836 cd b2 0b			call addatohl 
1839 cd 4b 18			call .dumpbyterow 
183c			 
183c 3e 78			ld a, display_row_4 
183e 2a db eb			ld hl, (display_fb_active) 
1841 cd b2 0b			call addatohl 
1844 cd 4b 18			call .dumpbyterow 
1847			 
1847 cd a8 09			call update_display 
184a			;		jp cli 
184a c9				ret 
184b			 
184b			.dumpbyterow: 
184b			 
184b				;push af 
184b			 
184b e5				push hl 
184c			 
184c				; calc where to poke the ascii 
184c			if display_cols == 20 
184c				ld a, 16 
184c			else 
184c 3e 1f			ld a, 31 
184e			endif 
184e			 
184e cd b2 0b			call addatohl 
1851 22 65 e6			ld (os_word_scratch),hl  		; save pos for later 
1854			 
1854			 
1854			; display decoding address 
1854 2a 83 e6		   	ld hl,(os_cur_ptr) 
1857			 
1857 7c				ld a,h 
1858 e1				pop hl 
1859 e5				push hl 
185a			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
185a cd b3 0e			call hexout 
185d 2a 83 e6		   	ld hl,(os_cur_ptr) 
1860			 
1860 7d				ld a,l 
1861 e1				pop hl 
1862 23				inc hl 
1863 23				inc hl 
1864 e5				push hl 
1865			;	ld hl, os_word_scratch+2 
1865 cd b3 0e			call hexout 
1868 e1				pop hl 
1869 23				inc hl 
186a 23				inc hl 
186b				;ld hl, os_word_scratch+4 
186b 3e 3a			ld a, ':' 
186d 77				ld (hl),a 
186e 23				inc hl 
186f				;ld a, 0 
186f				;ld (hl),a 
186f				;ld de, os_word_scratch 
186f				;pop af 
186f				;push af 
186f			;		ld a, display_row_2 
186f			;		call str_at_display 
186f			;		call update_display 
186f			 
186f			 
186f			;pop af 
186f			;	add 5 
186f			 
186f			if display_cols == 20 
186f				ld b, 4 
186f			else 
186f 06 08			ld b, 8 
1871			endif	 
1871			 
1871			.dumpbyte: 
1871 c5				push bc 
1872 e5				push hl 
1873			 
1873			 
1873 2a 83 e6		   	ld hl,(os_cur_ptr) 
1876 7e					ld a,(hl) 
1877			 
1877					; poke the ascii to display 
1877 2a 65 e6				ld hl,(os_word_scratch) 
187a 77					ld (hl),a 
187b 23					inc hl 
187c 22 65 e6				ld (os_word_scratch),hl 
187f			 
187f					 
187f			 
187f			 
187f e1					pop hl 
1880 e5					push hl 
1881			 
1881 cd b3 0e				call hexout 
1884			 
1884					 
1884 2a 83 e6		   	ld hl,(os_cur_ptr) 
1887 23				inc hl 
1888 22 83 e6		   	ld (os_cur_ptr),hl 
188b			 
188b e1					pop hl 
188c 23					inc hl 
188d 23					inc hl 
188e 23					inc hl 
188f			 
188f			 
188f			 
188f					;ld a,0 
188f					;ld (os_word_scratch+2),a 
188f					;pop af 
188f					;push af 
188f			 
188f					;ld de, os_word_scratch 
188f					;call str_at_display 
188f			;		call update_display 
188f			;		pop af 
188f c1					pop bc 
1890 c6 03				add 3 
1892 10 dd			djnz .dumpbyte 
1894			 
1894				 
1894			 
1894 c9				ret 
1895			 
1895			jump:	 
1895			 
1895 21 62 e3			ld hl,scratch+2 
1898 cd 69 0f			call get_word_hl 
189b				;ld hl,(scratch+2) 
189b				;call fourehexhl 
189b			 
189b 22 83 e6			ld (os_cur_ptr),hl	 
189e			 
189e e9				jp (hl) 
189f			 
189f			 
189f			 
189f			; TODO implement a basic monitor mode to start with 
189f			 
189f			 
189f			 
189f			 
189f			 
189f			 
189f			 
189f			 
189f			 
189f			; testing and demo code during development 
189f			 
189f			 
189f .. 00		str1: db "Enter some text...",0 
18b2 .. 00		clear: db "                    ",0 
18c7			 
18c7			demo: 
18c7			 
18c7			 
18c7			 
18c7			;	call update_display 
18c7			 
18c7				; init scratch input area for testing 
18c7 21 60 e3			ld hl, scratch	 
18ca 3e 00			ld a,0 
18cc 77				ld (hl),a 
18cd			 
18cd			 
18cd 3e 28		            LD   A, display_row_2 
18cf			;            CALL fLCD_Pos       ;Position cursor to location in A 
18cf 11 9f 18		            LD   DE, str1 
18d2 cd 98 09			call str_at_display 
18d5			 
18d5			;            CALL fLCD_Str       ;Display string pointed to by DE 
18d5			cloop:	 
18d5 3e 50		            LD   A, display_row_3 
18d7			;            CALL fLCD_Pos       ;Position cursor to location in A 
18d7 11 b2 18		            LD   DE, clear 
18da			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
18da cd 98 09				call str_at_display 
18dd 3e 78			ld a, display_row_4 
18df 11 0f 19			ld de, prompt 
18e2			 
18e2 cd 98 09				call str_at_display 
18e5 cd a8 09			call update_display 
18e8			 
18e8 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18ea 16 0a			ld d, 10 
18ec 21 60 e3			ld hl, scratch	 
18ef cd df 0b			call input_str 
18f2			 
18f2			;	call clear_display 
18f2			;'	call update_display 
18f2			 
18f2 3e 00		            LD   A, display_row_1 
18f4			;            CALL fLCD_Pos       ;Position cursor to location in A 
18f4 11 b2 18		            LD   DE, clear 
18f7 cd 98 09				call str_at_display 
18fa			;            CALL fLCD_Str       ;Display string pointed to by DE 
18fa 3e 00		            LD   A, display_row_1 
18fc			;            CALL fLCD_Pos       ;Position cursor to location in A 
18fc 11 60 e3		            LD   DE, scratch 
18ff			;            CALL fLCD_Str       ;Display string pointed to by DE 
18ff cd 98 09				call str_at_display 
1902 cd a8 09			call update_display 
1905			 
1905 3e 00				ld a,0 
1907 21 60 e3			ld hl, scratch 
190a 77				ld (hl),a 
190b			 
190b 00				nop 
190c c3 d5 18			jp cloop 
190f			 
190f			 
190f			 
190f			; OS Prompt 
190f			 
190f .. 00		prompt: db ">",0 
1911 .. 00		endprg: db "?",0 
1913			 
1913			 
1913			; handy next page prompt 
1913			next_page_prompt: 
1913 e5				push hl 
1914 d5				push de 
1915 f5				push af 
1916 c5				push bc 
1917			 
1917 3e 9f			ld a,display_row_4 + display_cols - 1 
1919 11 11 19		        ld de, endprg 
191c cd 98 09			call str_at_display 
191f cd a8 09			call update_display 
1922 cd c5 59			call cin_wait 
1925 c1				pop bc 
1926 f1				pop af 
1927 d1				pop de 
1928 e1				pop hl 
1929			 
1929			 
1929 c9				ret 
192a			 
192a			 
192a			; forth parser 
192a			 
192a			; My forth kernel 
192a			include "forth_kernel.asm" 
192a			; 
192a			; kernel to the forth OS 
192a			 
192a			DS_TYPE_STR: equ 1     ; string type 
192a			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
192a			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
192a			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
192a			 
192a			FORTH_PARSEV1: equ 0 
192a			FORTH_PARSEV2: equ 0 
192a			FORTH_PARSEV3: equ 0 
192a			FORTH_PARSEV4: equ 0 
192a			FORTH_PARSEV5: equ 1 
192a			 
192a			;if FORTH_PARSEV5 
192a			;	FORTH_END_BUFFER: equ 0 
192a			;else 
192a			FORTH_END_BUFFER: equ 127 
192a			;endif 
192a			 
192a			FORTH_TRUE: equ 1 
192a			FORTH_FALSE: equ 0 
192a			 
192a			if FORTH_PARSEV4 
192a			include "forth_stackops.asm" 
192a			endif 
192a			 
192a			if FORTH_PARSEV5 
192a			include "forth_stackopsv5.asm" 
192a			 
192a			; Stack operations for v5 parser on wards 
192a			; * DATA stack 
192a			; * LOOP stack 
192a			; * RETURN stack 
192a			 
192a			 
192a			 
192a			FORTH_CHK_DSP_UNDER: macro 
192a				push hl 
192a				push de 
192a				ld hl,(cli_data_sp) 
192a				ld de, cli_data_stack 
192a				call cmp16 
192a				jp c, fault_dsp_under 
192a				pop de 
192a				pop hl 
192a				endm 
192a			 
192a			 
192a			FORTH_CHK_RSP_UNDER: macro 
192a				push hl 
192a				push de 
192a				ld hl,(cli_ret_sp) 
192a				ld de, cli_ret_stack 
192a				call cmp16 
192a				jp c, fault_rsp_under 
192a				pop de 
192a				pop hl 
192a				endm 
192a			 
192a			FORTH_CHK_LOOP_UNDER: macro 
192a				push hl 
192a				push de 
192a				ld hl,(cli_loop_sp) 
192a				ld de, cli_loop_stack 
192a				call cmp16 
192a				jp c, fault_loop_under 
192a				pop de 
192a				pop hl 
192a				endm 
192a			 
192a			FORTH_ERR_TOS_NOTSTR: macro 
192a				; TOSO might need more for checks when used 
192a				push af 
192a				ld a,(hl) 
192a				cp DS_TYPE_STR 
192a				jp nz, type_faultn   
192a				pop af 
192a				endm 
192a			 
192a			FORTH_ERR_TOS_NOTNUM: macro 
192a				push af 
192a				ld a,(hl) 
192a				cp DS_TYPE_INUM 
192a				jp nz, type_faultn   
192a				pop af 
192a				endm 
192a			 
192a			 
192a			; increase data stack pointer and save hl to it 
192a				 
192a			FORTH_DSP_NEXT: macro 
192a				call macro_forth_dsp_next 
192a				endm 
192a			 
192a			 
192a			macro_forth_dsp_next: 
192a				if DEBUG_FORTH_STACK_GUARD 
192a cd dd 56				call check_stacks 
192d				endif 
192d e5				push hl 
192e d5				push de 
192f eb				ex de,hl 
1930 2a 0d eb			ld hl,(cli_data_sp) 
1933 23				inc hl 
1934 23				inc hl 
1935			 
1935			; PARSEV5 
1935 23				inc hl 
1936 22 0d eb			ld (cli_data_sp),hl 
1939 73				ld (hl), e 
193a 23				inc hl 
193b 72				ld (hl), d 
193c d1				pop de 
193d e1				pop hl 
193e				if DEBUG_FORTH_STACK_GUARD 
193e cd dd 56				call check_stacks 
1941				endif 
1941 c9				ret 
1942			 
1942			 
1942			; increase ret stack pointer and save hl to it 
1942				 
1942			FORTH_RSP_NEXT: macro 
1942				call macro_forth_rsp_next 
1942				endm 
1942			 
1942			macro_forth_rsp_next: 
1942				if DEBUG_FORTH_STACK_GUARD 
1942 cd dd 56				call check_stacks 
1945				endif 
1945 e5				push hl 
1946 d5				push de 
1947 eb				ex de,hl 
1948 2a 11 eb			ld hl,(cli_ret_sp) 
194b 23				inc hl 
194c 23				inc hl 
194d 22 11 eb			ld (cli_ret_sp),hl 
1950 73				ld (hl), e 
1951 23				inc hl 
1952 72				ld (hl), d 
1953 d1				pop de 
1954 e1				pop hl 
1955				if DEBUG_FORTH_STACK_GUARD 
1955 cd dd 56				call check_stacks 
1958				endif 
1958 c9				ret 
1959			 
1959			; get current ret stack pointer and save to hl  
1959				 
1959			FORTH_RSP_TOS: macro 
1959				call macro_forth_rsp_tos 
1959				endm 
1959			 
1959			macro_forth_rsp_tos: 
1959				;push de 
1959 2a 11 eb			ld hl,(cli_ret_sp) 
195c cd 94 19			call loadhlptrtohl 
195f				;ld e, (hl) 
195f				;inc hl 
195f				;ld d, (hl) 
195f				;ex de, hl 
195f					if DEBUG_FORTH_WORDS 
195f			;			DMARK "RST" 
195f						CALLMONITOR 
195f cd 0e 14			call break_point_state  
1962				endm  
# End of macro CALLMONITOR
1962					endif 
1962				;pop de 
1962 c9				ret 
1963			 
1963			; pop ret stack pointer 
1963				 
1963			FORTH_RSP_POP: macro 
1963				call macro_forth_rsp_pop 
1963				endm 
1963			 
1963			 
1963			macro_forth_rsp_pop: 
1963				if DEBUG_FORTH_STACK_GUARD 
1963			;		DMARK "RPP" 
1963 cd dd 56				call check_stacks 
1966					FORTH_CHK_RSP_UNDER 
1966 e5				push hl 
1967 d5				push de 
1968 2a 11 eb			ld hl,(cli_ret_sp) 
196b 11 cb ea			ld de, cli_ret_stack 
196e cd d0 0b			call cmp16 
1971 da f1 57			jp c, fault_rsp_under 
1974 d1				pop de 
1975 e1				pop hl 
1976				endm 
# End of macro FORTH_CHK_RSP_UNDER
1976				endif 
1976 e5				push hl 
1977 2a 11 eb			ld hl,(cli_ret_sp) 
197a			 
197a			 
197a				if FORTH_ENABLE_FREE 
197a			 
197a					; get pointer 
197a			 
197a					push de 
197a					push hl 
197a			 
197a					ld e, (hl) 
197a					inc hl 
197a					ld d, (hl) 
197a			 
197a					ex de, hl 
197a					call free 
197a			 
197a					pop hl 
197a					pop de 
197a			 
197a			 
197a				endif 
197a			 
197a			 
197a 2b				dec hl 
197b 2b				dec hl 
197c 22 11 eb			ld (cli_ret_sp), hl 
197f				; do stack underflow checks 
197f e1				pop hl 
1980				if DEBUG_FORTH_STACK_GUARD 
1980 cd dd 56				call check_stacks 
1983					FORTH_CHK_RSP_UNDER 
1983 e5				push hl 
1984 d5				push de 
1985 2a 11 eb			ld hl,(cli_ret_sp) 
1988 11 cb ea			ld de, cli_ret_stack 
198b cd d0 0b			call cmp16 
198e da f1 57			jp c, fault_rsp_under 
1991 d1				pop de 
1992 e1				pop hl 
1993				endm 
# End of macro FORTH_CHK_RSP_UNDER
1993				endif 
1993 c9				ret 
1994			 
1994			 
1994			 
1994			; routine to load word pointed to by hl into hl 
1994			 
1994			loadhlptrtohl: 
1994			 
1994 d5				push de 
1995 5e				ld e, (hl) 
1996 23				inc hl 
1997 56				ld d, (hl) 
1998 eb				ex de, hl 
1999 d1				pop de 
199a			 
199a c9				ret 
199b			 
199b			 
199b			 
199b			 
199b			 
199b			; push a number held in HL onto the data stack 
199b			; entry point for pushing a value when already in hl used in function above 
199b			 
199b			forth_push_numhl: 
199b			 
199b e5				push hl    ; save value to push 
199c			 
199c			if DEBUG_FORTH_PUSH 
199c				; see if disabled 
199c			 
199c			 
199c f5				push af 
199d 3a 51 e3			ld a, (os_view_disable) 
19a0 fe 2a			cp '*' 
19a2 28 34			jr z, .pskip2 
19a4 e5				push hl 
19a5 e5			push hl 
19a6 cd 85 09			call clear_display 
19a9 e1			pop hl 
19aa 7c				ld a,h 
19ab 21 65 e6			ld hl, os_word_scratch 
19ae cd b3 0e			call hexout 
19b1 e1				pop hl 
19b2 7d				ld a,l 
19b3 21 67 e6			ld hl, os_word_scratch+2 
19b6 cd b3 0e			call hexout 
19b9			 
19b9 21 69 e6			ld hl, os_word_scratch+4 
19bc 3e 00			ld a,0 
19be 77				ld (hl),a 
19bf 11 65 e6			ld de,os_word_scratch 
19c2 3e 28				ld a, display_row_2 
19c4 cd 98 09				call str_at_display 
19c7 11 eb 45			ld de, .push_num 
19ca 3e 00			ld a, display_row_1 
19cc			 
19cc cd 98 09				call str_at_display 
19cf			 
19cf			 
19cf cd a8 09			call update_display 
19d2 cd fa 08			call delay1s 
19d5 cd fa 08			call delay1s 
19d8			.pskip2:  
19d8			 
19d8 f1				pop af 
19d9			endif	 
19d9			 
19d9			 
19d9				FORTH_DSP_NEXT 
19d9 cd 2a 19			call macro_forth_dsp_next 
19dc				endm 
# End of macro FORTH_DSP_NEXT
19dc			 
19dc 2a 0d eb			ld hl, (cli_data_sp) 
19df			 
19df				; save item type 
19df 3e 02			ld a,  DS_TYPE_INUM 
19e1 77				ld (hl), a 
19e2 23				inc hl 
19e3			 
19e3				; get word off stack 
19e3 d1				pop de 
19e4 7b				ld a,e 
19e5 77				ld (hl), a 
19e6 23				inc hl 
19e7 7a				ld a,d 
19e8 77				ld (hl), a 
19e9			 
19e9			if DEBUG_FORTH_PUSH 
19e9 2b				dec hl 
19ea 2b				dec hl 
19eb 2b				dec hl 
19ec						DMARK "PH5" 
19ec f5				push af  
19ed 3a 01 1a			ld a, (.dmark)  
19f0 32 7a ee			ld (debug_mark),a  
19f3 3a 02 1a			ld a, (.dmark+1)  
19f6 32 7b ee			ld (debug_mark+1),a  
19f9 3a 03 1a			ld a, (.dmark+2)  
19fc 32 7c ee			ld (debug_mark+2),a  
19ff 18 03			jr .pastdmark  
1a01 ..			.dmark: db "PH5"  
1a04 f1			.pastdmark: pop af  
1a05			endm  
# End of macro DMARK
1a05				CALLMONITOR 
1a05 cd 0e 14			call break_point_state  
1a08				endm  
# End of macro CALLMONITOR
1a08			endif	 
1a08			 
1a08 c9				ret 
1a09			 
1a09			 
1a09			; Push a string to stack pointed to by hl 
1a09			 
1a09			forth_push_str: 
1a09			 
1a09			if DEBUG_FORTH_PUSH 
1a09						DMARK "PSQ" 
1a09 f5				push af  
1a0a 3a 1e 1a			ld a, (.dmark)  
1a0d 32 7a ee			ld (debug_mark),a  
1a10 3a 1f 1a			ld a, (.dmark+1)  
1a13 32 7b ee			ld (debug_mark+1),a  
1a16 3a 20 1a			ld a, (.dmark+2)  
1a19 32 7c ee			ld (debug_mark+2),a  
1a1c 18 03			jr .pastdmark  
1a1e ..			.dmark: db "PSQ"  
1a21 f1			.pastdmark: pop af  
1a22			endm  
# End of macro DMARK
1a22				CALLMONITOR 
1a22 cd 0e 14			call break_point_state  
1a25				endm  
# End of macro CALLMONITOR
1a25			endif	 
1a25			    
1a25 e5				push hl 
1a26 e5				push hl 
1a27			 
1a27			;	ld a, 0   ; find end of string 
1a27 cd 10 10			call strlenz 
1a2a			if DEBUG_FORTH_PUSH 
1a2a						DMARK "PQ2" 
1a2a f5				push af  
1a2b 3a 3f 1a			ld a, (.dmark)  
1a2e 32 7a ee			ld (debug_mark),a  
1a31 3a 40 1a			ld a, (.dmark+1)  
1a34 32 7b ee			ld (debug_mark+1),a  
1a37 3a 41 1a			ld a, (.dmark+2)  
1a3a 32 7c ee			ld (debug_mark+2),a  
1a3d 18 03			jr .pastdmark  
1a3f ..			.dmark: db "PQ2"  
1a42 f1			.pastdmark: pop af  
1a43			endm  
# End of macro DMARK
1a43				CALLMONITOR 
1a43 cd 0e 14			call break_point_state  
1a46				endm  
# End of macro CALLMONITOR
1a46			endif	 
1a46 eb				ex de, hl 
1a47 e1				pop hl   ; get ptr to start of string 
1a48			if DEBUG_FORTH_PUSH 
1a48						DMARK "PQ3" 
1a48 f5				push af  
1a49 3a 5d 1a			ld a, (.dmark)  
1a4c 32 7a ee			ld (debug_mark),a  
1a4f 3a 5e 1a			ld a, (.dmark+1)  
1a52 32 7b ee			ld (debug_mark+1),a  
1a55 3a 5f 1a			ld a, (.dmark+2)  
1a58 32 7c ee			ld (debug_mark+2),a  
1a5b 18 03			jr .pastdmark  
1a5d ..			.dmark: db "PQ3"  
1a60 f1			.pastdmark: pop af  
1a61			endm  
# End of macro DMARK
1a61				CALLMONITOR 
1a61 cd 0e 14			call break_point_state  
1a64				endm  
# End of macro CALLMONITOR
1a64			endif	 
1a64 19				add hl,de 
1a65			if DEBUG_FORTH_PUSH 
1a65						DMARK "PQE" 
1a65 f5				push af  
1a66 3a 7a 1a			ld a, (.dmark)  
1a69 32 7a ee			ld (debug_mark),a  
1a6c 3a 7b 1a			ld a, (.dmark+1)  
1a6f 32 7b ee			ld (debug_mark+1),a  
1a72 3a 7c 1a			ld a, (.dmark+2)  
1a75 32 7c ee			ld (debug_mark+2),a  
1a78 18 03			jr .pastdmark  
1a7a ..			.dmark: db "PQE"  
1a7d f1			.pastdmark: pop af  
1a7e			endm  
# End of macro DMARK
1a7e				CALLMONITOR 
1a7e cd 0e 14			call break_point_state  
1a81				endm  
# End of macro CALLMONITOR
1a81			endif	 
1a81			 
1a81 2b				dec hl    ; see if there is an optional trailing double quote 
1a82 7e				ld a,(hl) 
1a83 fe 22			cp '"' 
1a85 20 03			jr nz, .strnoq 
1a87 3e 00			ld a, 0      ; get rid of double quote 
1a89 77				ld (hl), a 
1a8a 23			.strnoq: inc hl 
1a8b			 
1a8b 3e 00			ld a, 0 
1a8d 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1a8e			 
1a8e 13				inc de ; add one for the type string 
1a8f 13				inc de ; add one for null term??? 
1a90			 
1a90				; tos is get string pointer again 
1a90				; de contains space to allocate 
1a90				 
1a90 d5				push de 
1a91			 
1a91 eb				ex de, hl 
1a92			 
1a92				;push af 
1a92			 
1a92			if DEBUG_FORTH_PUSH 
1a92						DMARK "PHm" 
1a92 f5				push af  
1a93 3a a7 1a			ld a, (.dmark)  
1a96 32 7a ee			ld (debug_mark),a  
1a99 3a a8 1a			ld a, (.dmark+1)  
1a9c 32 7b ee			ld (debug_mark+1),a  
1a9f 3a a9 1a			ld a, (.dmark+2)  
1aa2 32 7c ee			ld (debug_mark+2),a  
1aa5 18 03			jr .pastdmark  
1aa7 ..			.dmark: db "PHm"  
1aaa f1			.pastdmark: pop af  
1aab			endm  
# End of macro DMARK
1aab				CALLMONITOR 
1aab cd 0e 14			call break_point_state  
1aae				endm  
# End of macro CALLMONITOR
1aae			endif	 
1aae cd 79 10			call malloc	; on ret hl now contains allocated memory 
1ab1				if DEBUG_FORTH_MALLOC_GUARD 
1ab1 cc 43 46				call z,malloc_error 
1ab4				endif 
1ab4			 
1ab4				 
1ab4 c1				pop bc    ; get length 
1ab5 d1				pop de   ;  get string start    
1ab6			 
1ab6				; hl has destination from malloc 
1ab6			 
1ab6 eb				ex de, hl    ; prep for ldir 
1ab7			 
1ab7 d5				push de   ; save malloc area for DSP later 
1ab8				;push hl   ; save malloc area for DSP later 
1ab8			 
1ab8			if DEBUG_FORTH_PUSH 
1ab8						DMARK "PHc" 
1ab8 f5				push af  
1ab9 3a cd 1a			ld a, (.dmark)  
1abc 32 7a ee			ld (debug_mark),a  
1abf 3a ce 1a			ld a, (.dmark+1)  
1ac2 32 7b ee			ld (debug_mark+1),a  
1ac5 3a cf 1a			ld a, (.dmark+2)  
1ac8 32 7c ee			ld (debug_mark+2),a  
1acb 18 03			jr .pastdmark  
1acd ..			.dmark: db "PHc"  
1ad0 f1			.pastdmark: pop af  
1ad1			endm  
# End of macro DMARK
1ad1				CALLMONITOR 
1ad1 cd 0e 14			call break_point_state  
1ad4				endm  
# End of macro CALLMONITOR
1ad4			endif	 
1ad4			 
1ad4			 
1ad4 ed b0			ldir 
1ad6			 
1ad6			 
1ad6				; push malloc to data stack     macro?????  
1ad6			 
1ad6				FORTH_DSP_NEXT 
1ad6 cd 2a 19			call macro_forth_dsp_next 
1ad9				endm 
# End of macro FORTH_DSP_NEXT
1ad9			 
1ad9				; save value and type 
1ad9			 
1ad9 2a 0d eb			ld hl, (cli_data_sp) 
1adc			 
1adc				; save item type 
1adc 3e 01			ld a,  DS_TYPE_STR 
1ade 77				ld (hl), a 
1adf 23				inc hl 
1ae0			 
1ae0				; get malloc word off stack 
1ae0 d1				pop de 
1ae1 73				ld (hl), e 
1ae2 23				inc hl 
1ae3 72				ld (hl), d 
1ae4			 
1ae4			 
1ae4			 
1ae4			if DEBUG_FORTH_PUSH 
1ae4 2a 0d eb			ld hl, (cli_data_sp) 
1ae7						DMARK "PHS" 
1ae7 f5				push af  
1ae8 3a fc 1a			ld a, (.dmark)  
1aeb 32 7a ee			ld (debug_mark),a  
1aee 3a fd 1a			ld a, (.dmark+1)  
1af1 32 7b ee			ld (debug_mark+1),a  
1af4 3a fe 1a			ld a, (.dmark+2)  
1af7 32 7c ee			ld (debug_mark+2),a  
1afa 18 03			jr .pastdmark  
1afc ..			.dmark: db "PHS"  
1aff f1			.pastdmark: pop af  
1b00			endm  
# End of macro DMARK
1b00				CALLMONITOR 
1b00 cd 0e 14			call break_point_state  
1b03				endm  
# End of macro CALLMONITOR
1b03			;	ex de,hl 
1b03			endif	 
1b03				; in case of spaces, skip the ptr past the copied string 
1b03				;pop af 
1b03				;ld (cli_origptr),hl 
1b03			 
1b03 c9				ret 
1b04			 
1b04			 
1b04			 
1b04			; TODO ascii push input onto stack given hl to start of input 
1b04			 
1b04			; identify type 
1b04			; if starts with a " then a string 
1b04			; otherwise it is a number 
1b04			;  
1b04			; if a string 
1b04			;     scan for ending " to get length of string to malloc for + 1 
1b04			;     malloc 
1b04			;     put pointer to string on stack first byte flags as string 
1b04			; 
1b04			; else a number 
1b04			;    look for number format identifier 
1b04			;    $xx hex 
1b04			;    %xxxxx bin 
1b04			;    xxxxx decimal 
1b04			;    convert number to 16bit word.  
1b04			;    malloc word + 1 with flag to identiy as num 
1b04			;    put pointer to number on stack 
1b04			;   
1b04			;  
1b04			  
1b04			forth_apush: 
1b04				; kernel push 
1b04			 
1b04			if DEBUG_FORTH_PUSH 
1b04						DMARK "PSH" 
1b04 f5				push af  
1b05 3a 19 1b			ld a, (.dmark)  
1b08 32 7a ee			ld (debug_mark),a  
1b0b 3a 1a 1b			ld a, (.dmark+1)  
1b0e 32 7b ee			ld (debug_mark+1),a  
1b11 3a 1b 1b			ld a, (.dmark+2)  
1b14 32 7c ee			ld (debug_mark+2),a  
1b17 18 03			jr .pastdmark  
1b19 ..			.dmark: db "PSH"  
1b1c f1			.pastdmark: pop af  
1b1d			endm  
# End of macro DMARK
1b1d				CALLMONITOR 
1b1d cd 0e 14			call break_point_state  
1b20				endm  
# End of macro CALLMONITOR
1b20			endif	 
1b20				; identify input type 
1b20			 
1b20 7e				ld a,(hl) 
1b21 fe 22			cp '"' 
1b23 28 0a			jr z, .fapstr 
1b25 fe 24			cp '$' 
1b27 ca 4f 1b			jp z, .faphex 
1b2a fe 25			cp '%' 
1b2c ca 37 1b			jp z, .fapbin 
1b2f			;	cp 'b' 
1b2f			;	jp z, .fabin 
1b2f				; else decimal 
1b2f			 
1b2f				; TODO do decimal conversion 
1b2f				; decimal is stored as a 16bit word 
1b2f			 
1b2f				; by default everything is a string if type is not detected 
1b2f			.fapstr: ; 
1b2f fe 22			cp '"' 
1b31 20 01			jr nz, .strnoqu 
1b33 23				inc hl 
1b34			.strnoqu: 
1b34 c3 09 1a			jp forth_push_str 
1b37			 
1b37			 
1b37			 
1b37			.fapbin:    ; push a binary string.  
1b37 11 00 00			ld de, 0   ; hold a 16bit value 
1b3a			 
1b3a 23			.fapbinshift:	inc hl  
1b3b 7e				ld a,(hl) 
1b3c fe 00			cp 0     ; done scanning  
1b3e 28 0b			jr z, .fapbdone  	; got it in HL so push  
1b40			 
1b40				; left shift de 
1b40 eb				ex de, hl	 
1b41 29				add hl, hl 
1b42			 
1b42				; is 1 
1b42 fe 31			cp '1' 
1b44 20 02			jr nz, .binzero 
1b46 cb 4d			bit 1, l 
1b48			.binzero: 
1b48 eb				ex de, hl	 ; save current de 
1b49 18 ef			jr .fapbinshift 
1b4b			 
1b4b			.fapbdone: 
1b4b eb				ex de, hl 
1b4c c3 9b 19			jp forth_push_numhl 
1b4f			 
1b4f			 
1b4f			.faphex:   ; hex is always stored as a 16bit word 
1b4f				; skip number prefix 
1b4f 23				inc hl 
1b50				; turn ascii into number 
1b50 cd 69 0f			call get_word_hl	; ret 16bit word in hl 
1b53			 
1b53 c3 9b 19			jp forth_push_numhl 
1b56			 
1b56 00				 nop 
1b57			 
1b57			.fabin:   ; TODO bin conversion 
1b57			 
1b57			 
1b57 c9				ret 
1b58			 
1b58			 
1b58			; get either a string ptr or a 16bit word from the data stack 
1b58			 
1b58			FORTH_DSP: macro 
1b58				call macro_forth_dsp 
1b58				endm 
1b58			 
1b58			macro_forth_dsp: 
1b58				; data stack pointer points to current word on tos 
1b58			 
1b58 2a 0d eb			ld hl,(cli_data_sp) 
1b5b			 
1b5b				if DEBUG_FORTH_PUSH 
1b5b						DMARK "DSP" 
1b5b f5				push af  
1b5c 3a 70 1b			ld a, (.dmark)  
1b5f 32 7a ee			ld (debug_mark),a  
1b62 3a 71 1b			ld a, (.dmark+1)  
1b65 32 7b ee			ld (debug_mark+1),a  
1b68 3a 72 1b			ld a, (.dmark+2)  
1b6b 32 7c ee			ld (debug_mark+2),a  
1b6e 18 03			jr .pastdmark  
1b70 ..			.dmark: db "DSP"  
1b73 f1			.pastdmark: pop af  
1b74			endm  
# End of macro DMARK
1b74			 
1b74 cd 78 46				call display_data_sp 
1b77				;call break_point_state 
1b77				;rst 030h 
1b77				CALLMONITOR 
1b77 cd 0e 14			call break_point_state  
1b7a				endm  
# End of macro CALLMONITOR
1b7a				endif 
1b7a			 
1b7a c9				ret 
1b7b			 
1b7b			; return hl to start of value on stack 
1b7b			 
1b7b			FORTH_DSP_VALUE: macro 
1b7b				call macro_forth_dsp_value 
1b7b				endm 
1b7b			 
1b7b			macro_forth_dsp_value: 
1b7b			 
1b7b				FORTH_DSP 
1b7b cd 58 1b			call macro_forth_dsp 
1b7e				endm 
# End of macro FORTH_DSP
1b7e			 
1b7e d5				push de 
1b7f			 
1b7f 23				inc hl ; skip type 
1b80			 
1b80 5e				ld e, (hl) 
1b81 23				inc hl 
1b82 56				ld d, (hl) 
1b83 eb				ex de,hl  
1b84			 
1b84 d1				pop de 
1b85			 
1b85 c9				ret 
1b86			 
1b86			; return hl to start of value to second item on stack 
1b86			 
1b86			FORTH_DSP_VALUEM1: macro 
1b86				call macro_forth_dsp_value_m1 
1b86				endm 
1b86			 
1b86			macro_forth_dsp_value_m1: 
1b86			 
1b86				FORTH_DSP 
1b86 cd 58 1b			call macro_forth_dsp 
1b89				endm 
# End of macro FORTH_DSP
1b89			 
1b89 2b				dec hl 
1b8a 2b				dec hl 
1b8b			;	dec hl 
1b8b			 
1b8b d5				push de 
1b8c			 
1b8c 5e				ld e, (hl) 
1b8d 23				inc hl 
1b8e 56				ld d, (hl) 
1b8f eb				ex de,hl  
1b90			 
1b90 d1				pop de 
1b91			 
1b91 c9				ret 
1b92			 
1b92				 
1b92			 
1b92			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1b92			 
1b92			FORTH_DSP_POP: macro 
1b92				call macro_forth_dsp_pop 
1b92				endm 
1b92			 
1b92			 
1b92			; get the tos data type 
1b92			 
1b92			FORTH_DSP_TYPE:   macro 
1b92			 
1b92				;FORTH_DSP_VALUE 
1b92				FORTH_DSP 
1b92				 
1b92				; hl points to value 
1b92				; check type 
1b92			 
1b92				ld a,(hl) 
1b92			 
1b92				endm 
1b92			 
1b92			; load the tos value into hl 
1b92			 
1b92			 
1b92			FORTH_DSP_VALUEHL:  macro 
1b92				call macro_dsp_valuehl 
1b92				endm 
1b92			 
1b92			 
1b92			 
1b92			macro_dsp_valuehl: 
1b92				FORTH_DSP_VALUE 
1b92 cd 7b 1b			call macro_forth_dsp_value 
1b95				endm 
# End of macro FORTH_DSP_VALUE
1b95			 
1b95				;FORTH_ERR_TOS_NOTNUM 
1b95			 
1b95				;inc hl   ; skip type id 
1b95			 
1b95			;	push de 
1b95			; 
1b95			;	ld e, (hl) 
1b95			;	inc hl 
1b95			;	ld d, (hl) 
1b95			;	ex de,hl  
1b95			 
1b95			;	pop de 
1b95			 
1b95				if DEBUG_FORTH_PUSH 
1b95						DMARK "DVL" 
1b95 f5				push af  
1b96 3a aa 1b			ld a, (.dmark)  
1b99 32 7a ee			ld (debug_mark),a  
1b9c 3a ab 1b			ld a, (.dmark+1)  
1b9f 32 7b ee			ld (debug_mark+1),a  
1ba2 3a ac 1b			ld a, (.dmark+2)  
1ba5 32 7c ee			ld (debug_mark+2),a  
1ba8 18 03			jr .pastdmark  
1baa ..			.dmark: db "DVL"  
1bad f1			.pastdmark: pop af  
1bae			endm  
# End of macro DMARK
1bae				CALLMONITOR 
1bae cd 0e 14			call break_point_state  
1bb1				endm  
# End of macro CALLMONITOR
1bb1				endif 
1bb1 c9				ret 
1bb2			 
1bb2			forth_apushstrhl:      
1bb2				; push of string requires use of cli_origptr 
1bb2				; bodge use 
1bb2			 
1bb2				; get current cli_origptr, save, update with temp pointer  
1bb2 ed 5b 29 eb		ld de, (cli_origptr) 
1bb6 22 29 eb			ld (cli_origptr), hl 
1bb9 d5				push de 
1bba cd 04 1b			call forth_apush 
1bbd d1				pop de 
1bbe ed 53 29 eb		ld (cli_origptr), de 
1bc2 c9			        ret	 
1bc3			 
1bc3			 
1bc3			; increase loop stack pointer and save hl to it 
1bc3				 
1bc3			FORTH_LOOP_NEXT: macro 
1bc3				call macro_forth_loop_next 
1bc3				;nop 
1bc3				endm 
1bc3			 
1bc3			macro_forth_loop_next: 
1bc3				if DEBUG_FORTH_STACK_GUARD 
1bc3 cd dd 56				call check_stacks 
1bc6				endif 
1bc6 e5				push hl 
1bc7 d5				push de 
1bc8 eb				ex de,hl 
1bc9 2a 0f eb			ld hl,(cli_loop_sp) 
1bcc 23				inc hl 
1bcd 23				inc hl 
1bce					if DEBUG_FORTH_WORDS 
1bce						DMARK "LNX" 
1bce f5				push af  
1bcf 3a e3 1b			ld a, (.dmark)  
1bd2 32 7a ee			ld (debug_mark),a  
1bd5 3a e4 1b			ld a, (.dmark+1)  
1bd8 32 7b ee			ld (debug_mark+1),a  
1bdb 3a e5 1b			ld a, (.dmark+2)  
1bde 32 7c ee			ld (debug_mark+2),a  
1be1 18 03			jr .pastdmark  
1be3 ..			.dmark: db "LNX"  
1be6 f1			.pastdmark: pop af  
1be7			endm  
# End of macro DMARK
1be7						CALLMONITOR 
1be7 cd 0e 14			call break_point_state  
1bea				endm  
# End of macro CALLMONITOR
1bea					endif 
1bea 22 0f eb			ld (cli_loop_sp),hl 
1bed 73				ld (hl), e 
1bee 23				inc hl 
1bef 72				ld (hl), d 
1bf0 d1				pop de    ; been reversed so save a swap on restore 
1bf1 e1				pop hl 
1bf2				if DEBUG_FORTH_STACK_GUARD 
1bf2 cd dd 56				call check_stacks 
1bf5				endif 
1bf5 c9				ret 
1bf6			 
1bf6			; get current ret stack pointer and save to hl  
1bf6				 
1bf6			FORTH_LOOP_TOS: macro 
1bf6				call macro_forth_loop_tos 
1bf6				endm 
1bf6			 
1bf6			macro_forth_loop_tos: 
1bf6 d5				push de 
1bf7 2a 0f eb			ld hl,(cli_loop_sp) 
1bfa 5e				ld e, (hl) 
1bfb 23				inc hl 
1bfc 56				ld d, (hl) 
1bfd eb				ex de, hl 
1bfe d1				pop de 
1bff c9				ret 
1c00			 
1c00			; pop loop stack pointer 
1c00				 
1c00			FORTH_LOOP_POP: macro 
1c00				call macro_forth_loop_pop 
1c00				endm 
1c00			 
1c00			 
1c00			macro_forth_loop_pop: 
1c00				if DEBUG_FORTH_STACK_GUARD 
1c00					DMARK "LPP" 
1c00 f5				push af  
1c01 3a 15 1c			ld a, (.dmark)  
1c04 32 7a ee			ld (debug_mark),a  
1c07 3a 16 1c			ld a, (.dmark+1)  
1c0a 32 7b ee			ld (debug_mark+1),a  
1c0d 3a 17 1c			ld a, (.dmark+2)  
1c10 32 7c ee			ld (debug_mark+2),a  
1c13 18 03			jr .pastdmark  
1c15 ..			.dmark: db "LPP"  
1c18 f1			.pastdmark: pop af  
1c19			endm  
# End of macro DMARK
1c19 cd dd 56				call check_stacks 
1c1c					FORTH_CHK_LOOP_UNDER 
1c1c e5				push hl 
1c1d d5				push de 
1c1e 2a 0f eb			ld hl,(cli_loop_sp) 
1c21 11 c9 e9			ld de, cli_loop_stack 
1c24 cd d0 0b			call cmp16 
1c27 da f7 57			jp c, fault_loop_under 
1c2a d1				pop de 
1c2b e1				pop hl 
1c2c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c2c				endif 
1c2c e5				push hl 
1c2d 2a 0f eb			ld hl,(cli_loop_sp) 
1c30 2b				dec hl 
1c31 2b				dec hl 
1c32 22 0f eb			ld (cli_loop_sp), hl 
1c35				; TODO do stack underflow checks 
1c35 e1				pop hl 
1c36				if DEBUG_FORTH_STACK_GUARD 
1c36 cd dd 56				call check_stacks 
1c39					FORTH_CHK_LOOP_UNDER 
1c39 e5				push hl 
1c3a d5				push de 
1c3b 2a 0f eb			ld hl,(cli_loop_sp) 
1c3e 11 c9 e9			ld de, cli_loop_stack 
1c41 cd d0 0b			call cmp16 
1c44 da f7 57			jp c, fault_loop_under 
1c47 d1				pop de 
1c48 e1				pop hl 
1c49				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c49				endif 
1c49 c9				ret 
1c4a			 
1c4a			macro_forth_dsp_pop: 
1c4a			 
1c4a e5				push hl 
1c4b			 
1c4b				; release malloc data 
1c4b			 
1c4b				if DEBUG_FORTH_STACK_GUARD 
1c4b cd dd 56				call check_stacks 
1c4e					FORTH_CHK_DSP_UNDER 
1c4e e5				push hl 
1c4f d5				push de 
1c50 2a 0d eb			ld hl,(cli_data_sp) 
1c53 11 c7 e8			ld de, cli_data_stack 
1c56 cd d0 0b			call cmp16 
1c59 da eb 57			jp c, fault_dsp_under 
1c5c d1				pop de 
1c5d e1				pop hl 
1c5e				endm 
# End of macro FORTH_CHK_DSP_UNDER
1c5e				endif 
1c5e				;ld hl,(cli_data_sp) 
1c5e			if DEBUG_FORTH_DOT 
1c5e				DMARK "DPP" 
1c5e				CALLMONITOR 
1c5e			endif	 
1c5e			 
1c5e			 
1c5e			if FORTH_ENABLE_DSPPOPFREE 
1c5e			 
1c5e				FORTH_DSP 
1c5e cd 58 1b			call macro_forth_dsp 
1c61				endm 
# End of macro FORTH_DSP
1c61			 
1c61 7e				ld a, (hl) 
1c62 fe 01			cp DS_TYPE_STR 
1c64 20 07			jr nz, .skippopfree 
1c66			 
1c66				FORTH_DSP_VALUEHL 
1c66 cd 92 1b			call macro_dsp_valuehl 
1c69				endm 
# End of macro FORTH_DSP_VALUEHL
1c69 00				nop 
1c6a			if DEBUG_FORTH_DOT 
1c6a				DMARK "DPf" 
1c6a				CALLMONITOR 
1c6a			endif	 
1c6a cd 43 11			call free 
1c6d			.skippopfree: 
1c6d				 
1c6d			 
1c6d			endif 
1c6d			 
1c6d			if DEBUG_FORTH_DOT_KEY 
1c6d				DMARK "DP2" 
1c6d				CALLMONITOR 
1c6d			endif	 
1c6d			 
1c6d				; move pointer down 
1c6d			 
1c6d 2a 0d eb			ld hl,(cli_data_sp) 
1c70 2b				dec hl 
1c71 2b				dec hl 
1c72			; PARSEV5 
1c72 2b				dec hl 
1c73 22 0d eb			ld (cli_data_sp), hl 
1c76			 
1c76				if DEBUG_FORTH_STACK_GUARD 
1c76 cd dd 56				call check_stacks 
1c79					FORTH_CHK_DSP_UNDER 
1c79 e5				push hl 
1c7a d5				push de 
1c7b 2a 0d eb			ld hl,(cli_data_sp) 
1c7e 11 c7 e8			ld de, cli_data_stack 
1c81 cd d0 0b			call cmp16 
1c84 da eb 57			jp c, fault_dsp_under 
1c87 d1				pop de 
1c88 e1				pop hl 
1c89				endm 
# End of macro FORTH_CHK_DSP_UNDER
1c89				endif 
1c89			 
1c89 e1				pop hl 
1c8a			 
1c8a c9				ret 
1c8b			 
1c8b			getwordathl: 
1c8b				; hl points to an address 
1c8b				; load hl with the word at that address 
1c8b			 
1c8b d5				push de 
1c8c			 
1c8c 5e				ld e, (hl) 
1c8d 23				inc hl 
1c8e 56				ld d, (hl) 
1c8f eb				ex de, hl 
1c90			 
1c90 d1				pop de 
1c91 c9				ret 
1c92			 
1c92			 
1c92			 
1c92			 
1c92			 
1c92			; eof 
1c92			 
# End of file forth_stackopsv5.asm
1c92			endif 
1c92			 
1c92			user_word_eol:  
1c92				; hl contains the pointer to where to create a linked list item from the end 
1c92				; of the user dict to continue on at the system word dict 
1c92				 
1c92				; poke the stub of the word list linked list to repoint to rom words 
1c92			 
1c92				; stub format 
1c92				; db   word id 
1c92				; dw    link to next word 
1c92			        ; db char length of token 
1c92				; db string + 0 term 
1c92				; db exec code....  
1c92			 
1c92 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1c94 77				ld (hl), a		; word id 
1c95 23				inc hl 
1c96			 
1c96 11 5c 1e			ld de, sysdict 
1c99 73				ld (hl), e		; next word link ie system dict 
1c9a 23				inc hl 
1c9b 72				ld (hl), d		; next word link ie system dict 
1c9c 23				inc hl	 
1c9d			 
1c9d			;	ld (hl), sysdict		; next word link ie system dict 
1c9d			;	inc hl 
1c9d			;	inc hl 
1c9d			 
1c9d			;	inc hl 
1c9d			;	inc hl 
1c9d			 
1c9d 3e 02			ld a, 2			; word length is 0 
1c9f 77				ld (hl), a	 
1ca0 23				inc hl 
1ca1			 
1ca1 3e 7e			ld a, '~'			; word length is 0 
1ca3 77				ld (hl), a	 
1ca4 23				inc hl 
1ca5 3e 00			ld a, 0			; save empty word 
1ca7 77				ld (hl), a 
1ca8			 
1ca8 c9				ret 
1ca9			 
1ca9				 
1ca9			 
1ca9			forthexec_cleanup: 
1ca9				FORTH_RSP_POP 
1ca9 cd 63 19			call macro_forth_rsp_pop 
1cac				endm 
# End of macro FORTH_RSP_POP
1cac c9				ret 
1cad			 
1cad			forth_call_hl: 
1cad				; taking hl 
1cad e5				push hl 
1cae c9				ret 
1caf			 
1caf			; this is called to reset Forth system but keep existing uwords etc 
1caf			 
1caf			forth_warmstart: 
1caf				; setup stack over/under flow checks 
1caf				if DEBUG_FORTH_STACK_GUARD 
1caf cd c3 56				call chk_stk_init 
1cb2				endif 
1cb2			 
1cb2				; init stack pointers  - * these stacks go upwards *  
1cb2 21 cb ea			ld hl, cli_ret_stack 
1cb5 22 11 eb			ld (cli_ret_sp), hl	 
1cb8				; set bottom of stack 
1cb8 3e 00			ld a,0 
1cba 77				ld (hl),a 
1cbb 23				inc hl 
1cbc 77				ld (hl),a 
1cbd			 
1cbd 21 c7 e8			ld hl, cli_data_stack 
1cc0 22 0d eb			ld (cli_data_sp), hl	 
1cc3				; set bottom of stack 
1cc3 3e 00			ld a,0 
1cc5 77				ld (hl),a 
1cc6 23				inc hl 
1cc7 77				ld (hl),a 
1cc8			 
1cc8 21 c9 e9			ld hl, cli_loop_stack 
1ccb 22 0f eb			ld (cli_loop_sp), hl	 
1cce				; set bottom of stack 
1cce 3e 00			ld a,0 
1cd0 77				ld (hl),a 
1cd1 23				inc hl 
1cd2 77				ld (hl),a 
1cd3			 
1cd3				; init extent of current open file 
1cd3			 
1cd3 3e 00			ld a, 0 
1cd5 32 5c eb			ld (store_openext), a 
1cd8			 
1cd8 c9				ret 
1cd9			 
1cd9			 
1cd9			; Cold Start - this is called to setup the whole Forth system 
1cd9			 
1cd9			forth_init: 
1cd9			 
1cd9				; setup stack over/under flow checks 
1cd9			 
1cd9			;	if DEBUG_FORTH_STACK_GUARD 
1cd9			;		call chk_stk_init 
1cd9			;	endif 
1cd9			 
1cd9				; enable auto display updates (slow.....) 
1cd9			 
1cd9 3e 01			ld a, 1 
1cdb 32 27 eb			ld (cli_autodisplay), a 
1cde			 
1cde			 
1cde			 
1cde				; show start up screen 
1cde			 
1cde cd 85 09			call clear_display 
1ce1			 
1ce1 3e 00			ld a,0 
1ce3 32 49 eb			ld (f_cursor_ptr), a 
1ce6			 
1ce6				; set start of word list in start of ram - for use when creating user words 
1ce6			 
1ce6 21 e6 59			ld hl, baseram 
1ce9 22 5d e6			ld (os_last_new_uword), hl 
1cec cd 92 1c			call user_word_eol 
1cef				 
1cef			;		call display_data_sp 
1cef			;		call next_page_prompt 
1cef			 
1cef			 
1cef			 
1cef			 
1cef c9				ret 
1cf0			 
1cf0 .. 00		.bootforth: db " Forth Kernel Init ",0 
1d04			 
1d04			; TODO push to stack 
1d04			 
1d04			;  
1d04			 
1d04			if FORTH_PARSEV2 
1d04			 
1d04			 
1d04				include "forth_parserv2.asm" 
1d04			 
1d04			endif 
1d04			 
1d04			 
1d04			; parse cli version 1 
1d04			 
1d04			if FORTH_PARSEV1 
1d04			 
1d04			 
1d04			 
1d04			      include "forth_parserv1.asm" 
1d04			endif 
1d04				 
1d04			if FORTH_PARSEV3 
1d04			 
1d04			 
1d04			 
1d04			      include "forth_parserv3.asm" 
1d04				include "forth_wordsv3.asm" 
1d04			endif 
1d04			 
1d04			if FORTH_PARSEV4 
1d04			 
1d04			 
1d04			 
1d04			      include "forth_parserv4.asm" 
1d04				include "forth_wordsv4.asm" 
1d04			endif 
1d04			 
1d04			if FORTH_PARSEV5 
1d04			 
1d04			 
1d04			 
1d04			      include "forth_parserv5.asm" 
1d04			 
1d04			 
1d04			; A better parser without using malloc and string copies all over the place.  
1d04			; Exec in situ should be faster 
1d04			 
1d04			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1d04			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1d04			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1d04			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1d04			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1d04			WORD_SYS_END: equ 0   ; Opcode for all user words 
1d04			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1d04			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1d04			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1d04			 
1d04			; Core word preamble macro 
1d04			 
1d04			CWHEAD:   macro nxtword opcode lit len opflags 
1d04				db WORD_SYS_CORE+opcode             
1d04				; internal op code number 
1d04				dw nxtword            
1d04				; link to next dict word block 
1d04				db len + 1 
1d04				; literal length of dict word inc zero term 
1d04				db lit,0              
1d04				; literal dict word 
1d04			        ; TODO db opflags        
1d04				endm 
1d04			 
1d04			 
1d04			NEXTW: macro  
1d04				jp macro_next 
1d04				endm 
1d04			 
1d04			macro_next: 
1d04			if DEBUG_FORTH_PARSE_KEY 
1d04				DMARK "NXT" 
1d04				CALLMONITOR 
1d04			endif	 
1d04			;	inc hl  ; skip token null term  
1d04 ed 4b 2b eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1d08 ed 5b 29 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1d0c 2a 61 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1d0f			if DEBUG_FORTH_PARSE_KEY 
1d0f				DMARK "}AA" 
1d0f				CALLMONITOR 
1d0f			endif	 
1d0f c3 12 1e			jp execnext 
1d12				;jp exec1 
1d12			       
1d12			 
1d12			 
1d12			; Another go at the parser to compile  
1d12			 
1d12			 
1d12			; TODO rework parser to change all of the string words to byte tokens 
1d12			; TODO do a search for  
1d12			 
1d12			; TODO first run normal parser to zero term sections 
1d12			; TODO for each word do a token look up to get the op code 
1d12			; TODO need some means to flag to the exec that this is a byte code form    
1d12			 
1d12			 
1d12			forthcompile: 
1d12			 
1d12			; 
1d12			; line parse: 
1d12			;       parse raw input buffer 
1d12			;       tokenise the words 
1d12			;       malloc new copy (for looping etc) 
1d12			;       copy to malloc + current pc in line to start of string and add line term 
1d12			;       save on new rsp 
1d12			; 
1d12			 
1d12			; hl to point to the line to tokenise 
1d12			 
1d12			;	push hl 
1d12 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d15			 
1d15			;	ld a,0		; string term on input 
1d15			;	call strlent 
1d15			 
1d15			;	ld (os_tok_len), hl	 ; save string length 
1d15			 
1d15			;if DEBUG_FORTH_TOK 
1d15			;	ex de,hl		 
1d15			;endif 
1d15			 
1d15			;	pop hl 		; get back string pointer 
1d15			 
1d15			if DEBUG_FORTH_TOK 
1d15						DMARK "TOc" 
1d15				CALLMONITOR 
1d15			endif 
1d15 7e			.cptoken2:    ld a,(hl) 
1d16 23				inc hl 
1d17 fe 7f			cp FORTH_END_BUFFER 
1d19 28 29			jr z, .cptokendone2 
1d1b fe 00			cp 0 
1d1d 28 25			jr z, .cptokendone2 
1d1f fe 22			cp '"' 
1d21 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1d23 fe 20			cp ' ' 
1d25 20 ee			jr nz,  .cptoken2 
1d27			 
1d27			; TODO consume comments held between ( and ) 
1d27			 
1d27				; we have a space so change to zero term for dict match later 
1d27 2b				dec hl 
1d28 3e 00			ld a,0 
1d2a 77				ld (hl), a 
1d2b 23				inc hl 
1d2c 18 e7			jr .cptoken2 
1d2e				 
1d2e			 
1d2e			.cptokenstr2: 
1d2e				; skip all white space until either eol (because forgot to term) or end double quote 
1d2e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d2e				;inc hl ; skip current double quote 
1d2e 7e				ld a,(hl) 
1d2f 23				inc hl 
1d30 fe 22			cp '"' 
1d32 28 e1			jr z, .cptoken2 
1d34 fe 7f			cp FORTH_END_BUFFER 
1d36 28 0c			jr z, .cptokendone2 
1d38 fe 00			cp 0 
1d3a 28 08			jr z, .cptokendone2 
1d3c fe 20			cp ' ' 
1d3e 28 02			jr z, .cptmp2 
1d40 18 ec			jr .cptokenstr2 
1d42			 
1d42			.cptmp2:	; we have a space so change to zero term for dict match later 
1d42				;dec hl 
1d42				;ld a,"-"	; TODO remove this when working 
1d42				;ld (hl), a 
1d42				;inc hl 
1d42 18 ea			jr .cptokenstr2 
1d44			 
1d44			.cptokendone2: 
1d44				;inc hl 
1d44 3e 7f			ld a, FORTH_END_BUFFER 
1d46 77				ld (hl),a 
1d47 23				inc hl 
1d48 3e 21			ld a, '!' 
1d4a 77				ld (hl),a 
1d4b			 
1d4b 2a 61 e6			ld hl,(os_tok_ptr) 
1d4e			         
1d4e			if DEBUG_FORTH_TOK 
1d4e						DMARK "Tc1" 
1d4e				CALLMONITOR 
1d4e			endif 
1d4e			 
1d4e				; push exec string to top of return stack 
1d4e				FORTH_RSP_NEXT 
1d4e cd 42 19			call macro_forth_rsp_next 
1d51				endm 
# End of macro FORTH_RSP_NEXT
1d51 c9				ret 
1d52			 
1d52			; Another go at the parser need to simplify the process 
1d52			 
1d52			forthparse: 
1d52			 
1d52			; 
1d52			; line parse: 
1d52			;       parse raw input buffer 
1d52			;       tokenise the words 
1d52			;       malloc new copy (for looping etc) 
1d52			;       copy to malloc + current pc in line to start of string and add line term 
1d52			;       save on new rsp 
1d52			; 
1d52			 
1d52			; hl to point to the line to tokenise 
1d52			 
1d52			;	push hl 
1d52 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d55			 
1d55			;	ld a,0		; string term on input 
1d55			;	call strlent 
1d55			 
1d55			;	ld (os_tok_len), hl	 ; save string length 
1d55			 
1d55			;if DEBUG_FORTH_TOK 
1d55			;	ex de,hl		 
1d55			;endif 
1d55			 
1d55			;	pop hl 		; get back string pointer 
1d55			 
1d55			if DEBUG_FORTH_TOK 
1d55						DMARK "TOK" 
1d55				CALLMONITOR 
1d55			endif 
1d55 7e			.ptoken2:    ld a,(hl) 
1d56 23				inc hl 
1d57 fe 7f			cp FORTH_END_BUFFER 
1d59 28 29			jr z, .ptokendone2 
1d5b fe 00			cp 0 
1d5d 28 25			jr z, .ptokendone2 
1d5f fe 22			cp '"' 
1d61 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1d63 fe 20			cp ' ' 
1d65 20 ee			jr nz,  .ptoken2 
1d67			 
1d67			; TODO consume comments held between ( and ) 
1d67			 
1d67				; we have a space so change to zero term for dict match later 
1d67 2b				dec hl 
1d68 3e 00			ld a,0 
1d6a 77				ld (hl), a 
1d6b 23				inc hl 
1d6c 18 e7			jr .ptoken2 
1d6e				 
1d6e			 
1d6e			.ptokenstr2: 
1d6e				; skip all white space until either eol (because forgot to term) or end double quote 
1d6e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d6e				;inc hl ; skip current double quote 
1d6e 7e				ld a,(hl) 
1d6f 23				inc hl 
1d70 fe 22			cp '"' 
1d72 28 e1			jr z, .ptoken2 
1d74 fe 7f			cp FORTH_END_BUFFER 
1d76 28 0c			jr z, .ptokendone2 
1d78 fe 00			cp 0 
1d7a 28 08			jr z, .ptokendone2 
1d7c fe 20			cp ' ' 
1d7e 28 02			jr z, .ptmp2 
1d80 18 ec			jr .ptokenstr2 
1d82			 
1d82			.ptmp2:	; we have a space so change to zero term for dict match later 
1d82				;dec hl 
1d82				;ld a,"-"	; TODO remove this when working 
1d82				;ld (hl), a 
1d82				;inc hl 
1d82 18 ea			jr .ptokenstr2 
1d84			 
1d84			.ptokendone2: 
1d84				;inc hl 
1d84 3e 7f			ld a, FORTH_END_BUFFER 
1d86 77				ld (hl),a 
1d87 23				inc hl 
1d88 3e 21			ld a, '!' 
1d8a 77				ld (hl),a 
1d8b			 
1d8b 2a 61 e6			ld hl,(os_tok_ptr) 
1d8e			         
1d8e			if DEBUG_FORTH_TOK 
1d8e						DMARK "TK1" 
1d8e				CALLMONITOR 
1d8e			endif 
1d8e			 
1d8e				; push exec string to top of return stack 
1d8e				FORTH_RSP_NEXT 
1d8e cd 42 19			call macro_forth_rsp_next 
1d91				endm 
# End of macro FORTH_RSP_NEXT
1d91 c9				ret 
1d92			 
1d92			; 
1d92			;	; malloc size + buffer pointer + if is loop flag 
1d92			;	ld hl,(os_tok_len) 		 ; get string length 
1d92			; 
1d92			;	ld a,l 
1d92			; 
1d92			;	cp 0			; we dont want to use a null string 
1d92			;	ret z 
1d92			; 
1d92			;;	add 3    ; prefix malloc with buffer for current word ptr 
1d92			; 
1d92			;	add 5     ; TODO when certain not over writing memory remove 
1d92			; 
1d92			;		 
1d92			; 
1d92			;if DEBUG_FORTH_TOK 
1d92			;			DMARK "TKE" 
1d92			;	CALLMONITOR 
1d92			;endif 
1d92			; 
1d92			;	ld l,a 
1d92			;	ld h,0 
1d92			;;	push hl   ; save required space for the copy later 
1d92			;	call malloc 
1d92			;if DEBUG_FORTH_TOK 
1d92			;			DMARK "TKM" 
1d92			;	CALLMONITOR 
1d92			;endif 
1d92			;	if DEBUG_FORTH_MALLOC_GUARD 
1d92			;		push af 
1d92			;		call ishlzero 
1d92			;;		ld a, l 
1d92			;;		add h 
1d92			;;		cp 0 
1d92			;		pop af 
1d92			;		 
1d92			;		call z,malloc_error 
1d92			;	endif 
1d92			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1d92			; 
1d92			; 
1d92			;if DEBUG_FORTH_TOK 
1d92			;			DMARK "TKR" 
1d92			;	CALLMONITOR 
1d92			;endif 
1d92			; 
1d92			;	FORTH_RSP_NEXT 
1d92			; 
1d92			;	;inc hl	 ; go past current buffer pointer 
1d92			;	;inc hl 
1d92			;	;inc hl   ; and past if loop flag 
1d92			;		; TODO Need to set flag  
1d92			; 
1d92			;	 
1d92			;	 
1d92			;	ex de,hl	; malloc is dest 
1d92			;	ld hl, (os_tok_len) 
1d92			;;	pop bc 
1d92			;	ld c, l                
1d92			;	ld b,0 
1d92			;	ld hl, (os_tok_ptr) 
1d92			; 
1d92			;if DEBUG_FORTH_TOK 
1d92			;			DMARK "TKT" 
1d92			;	CALLMONITOR 
1d92			;endif 
1d92			; 
1d92			;	; do str cpy 
1d92			; 
1d92			;	ldir      ; copy byte in hl to de 
1d92			; 
1d92			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1d92			; 
1d92			;if DEBUG_FORTH_TOK 
1d92			; 
1d92			;			DMARK "TKY" 
1d92			;	CALLMONITOR 
1d92			;endif 
1d92			;	;ld a,0 
1d92			;	;ld a,FORTH_END_BUFFER 
1d92			;	ex de, hl 
1d92			;	;dec hl			 ; go back over the space delim at the end of word 
1d92			;	;ld (hl),a 
1d92			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1d92			;	ld a,FORTH_END_BUFFER 
1d92			;	ld (hl),a 
1d92			;	inc hl 
1d92			;	ld a,FORTH_END_BUFFER 
1d92			;	ld (hl),a 
1d92			; 
1d92			;	; init the malloc area data 
1d92			;	; set pc for in current area 
1d92			;	;ld hl, (os_tok_malloc) 
1d92			;	;inc hl 
1d92			;	;inc hl 
1d92			;	;inc hl 
1d92			;	;ex de,hl 
1d92			;	;ld hl, (os_tok_malloc) 
1d92			;	;ld (hl),e 
1d92			;	;inc hl 
1d92			;	;ld (hl),d 
1d92			; 
1d92			; 
1d92			;	ld hl,(os_tok_malloc) 
1d92			;if DEBUG_FORTH_PARSE_KEY 
1d92			;			DMARK "TKU" 
1d92			;	CALLMONITOR 
1d92			;endif 
1d92			; 
1d92			;	ret 
1d92			 
1d92			forthexec: 
1d92			 
1d92			; line exec: 
1d92			; forth parser 
1d92			 
1d92			; 
1d92			;       get current exec line on rsp 
1d92			 
1d92				FORTH_RSP_TOS 
1d92 cd 59 19			call macro_forth_rsp_tos 
1d95				endm 
# End of macro FORTH_RSP_TOS
1d95			 
1d95			;       restore current pc - hl points to malloc of data 
1d95			 
1d95				;ld e, (hl) 
1d95				;inc hl 
1d95				;ld d, (hl) 
1d95				;ex de,hl 
1d95			 
1d95			 
1d95			exec1: 
1d95 22 61 e6			ld (os_tok_ptr), hl 
1d98			 
1d98				; copy our PC to working vars  
1d98 22 2b eb			ld (cli_ptr), hl 
1d9b 22 29 eb			ld (cli_origptr), hl 
1d9e			 
1d9e 7e				ld a,(hl) 
1d9f fe 7f			cp FORTH_END_BUFFER 
1da1 c8				ret z 
1da2			 
1da2				; skip any nulls 
1da2			 
1da2 fe 00			cp 0 
1da4 20 03			jr nz, .execword 
1da6 23				inc hl 
1da7 18 ec			jr exec1 
1da9			 
1da9			 
1da9			.execword: 
1da9			 
1da9			 
1da9			 
1da9			if DEBUG_FORTH_PARSE_KEY 
1da9						DMARK "KYQ" 
1da9				CALLMONITOR 
1da9			endif 
1da9			;       while at start of word: 
1da9			; get start of dict (in user area first) 
1da9			 
1da9 21 e6 59		ld hl, baseram 
1dac			;ld hl, sysdict 
1dac 22 2d eb		ld (cli_nextword),hl 
1daf			;           match word at pc 
1daf			;           exec word 
1daf			;           or push to dsp 
1daf			;           forward to next token 
1daf			;           if line term pop rsp and exit 
1daf			;        
1daf			 
1daf			if DEBUG_FORTH_PARSE_KEY 
1daf						DMARK "KYq" 
1daf				CALLMONITOR 
1daf			endif 
1daf			 
1daf			; 
1daf			; word comp 
1daf			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1daf			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1daf			;    move to start of word  
1daf			;    compare word to cli_token 
1daf			 
1daf			.execpnword:	; HL at start of a word in the dictionary to check 
1daf			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1daf			;	ld (cli_ptr), hl 
1daf			 
1daf 2a 2d eb			ld hl,(cli_nextword) 
1db2			 
1db2 cd 55 1e			call forth_tok_next 
1db5			; tok next start here 
1db5			;	; TODO skip compiled symbol for now 
1db5			;	inc hl 
1db5			; 
1db5			;	; save pointer to next word 
1db5			; 
1db5			;	; hl now points to the address of the next word pointer  
1db5			;	ld e, (hl) 
1db5			;	inc hl 
1db5			;	ld d, (hl) 
1db5			;	inc l 
1db5			; 
1db5			;	ex de,hl 
1db5			;if DEBUG_FORTH_PARSE_NEXTWORD 
1db5			;	push bc 
1db5			;	ld bc, (cli_nextword) 
1db5			;			DMARK "NXW" 
1db5			;	CALLMONITOR 
1db5			;	pop bc 
1db5			;endif 
1db5			; tok next end here 
1db5 22 2d eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1db8 eb				ex de, hl 
1db9			 
1db9			 
1db9				; save the pointer of the current token - 1 to check against 
1db9				 
1db9 22 31 eb			ld (cli_token), hl   
1dbc				; TODO maybe remove below save if no debug 
1dbc				; save token string ptr for any debug later 
1dbc 23				inc hl  
1dbd 22 33 eb			ld (cli_origtoken), hl 
1dc0 2b				dec hl 
1dc1				; save pointer to the start of the next dictionay word 
1dc1 7e				ld a,(hl)   ; get string length 
1dc2 47				ld b,a 
1dc3			.execpnwordinc:  
1dc3 23				inc hl 
1dc4 10 fd			djnz .execpnwordinc 
1dc6 22 2f eb			ld (cli_execword), hl      ; save start of this words code 
1dc9			 
1dc9				; now check the word token against the string being parsed 
1dc9			 
1dc9 2a 31 eb			ld hl,(cli_token) 
1dcc 23				inc hl     ; skip string length (use zero term instead to end) 
1dcd 22 31 eb			ld (cli_token), hl 
1dd0			 
1dd0			if DEBUG_FORTH_PARSE_KEY 
1dd0						DMARK "KY2" 
1dd0			endif 
1dd0			if DEBUG_FORTH_PARSE_EXEC 
1dd0				; see if disabled 
1dd0			 
1dd0				ld a, (os_view_disable) 
1dd0				cp '*' 
1dd0				jr z, .skip 
1dd0			 
1dd0				push hl 
1dd0				push hl 
1dd0				call clear_display 
1dd0				ld de, .compword 
1dd0				ld a, display_row_1 
1dd0				call str_at_display 
1dd0				pop de 
1dd0				ld a, display_row_2 
1dd0				call str_at_display 
1dd0				ld hl,(cli_ptr) 
1dd0				ld a,(hl) 
1dd0			        ld hl, os_word_scratch 
1dd0				ld (hl),a 
1dd0				ld a,0 
1dd0				inc hl 
1dd0				ld (hl),a 	 
1dd0				ld de, os_word_scratch 
1dd0				ld a, display_row_2+10 
1dd0				call str_at_display 
1dd0				call update_display 
1dd0				ld a, 100 
1dd0				call aDelayInMS 
1dd0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1dd0				call delay250ms 
1dd0				endif 
1dd0				pop hl 
1dd0			.skip:  
1dd0			endif	 
1dd0			.execpnchar:    ; compare char between token and string to parse 
1dd0			 
1dd0			if DEBUG_FORTH_PARSE_KEY 
1dd0						DMARK "Ky3" 
1dd0			endif 
1dd0			if DEBUG_FORTH_PARSE_EXEC 
1dd0				; see if disabled 
1dd0			 
1dd0				ld a, (os_view_disable) 
1dd0				cp '*' 
1dd0				jr z, .skip2 
1dd0			 
1dd0			;	call clear_display 
1dd0			ld hl,(cli_token) 
1dd0			ld a,(hl) 
1dd0			ld (os_word_scratch),a 
1dd0				ld hl,(cli_ptr) 
1dd0			ld a,(hl) 
1dd0				ld (os_word_scratch+1),a 
1dd0				ld a,0 
1dd0				ld (os_word_scratch+2),a 
1dd0				ld de,os_word_scratch 
1dd0				ld a,display_row_4 
1dd0				call str_at_display 
1dd0				call update_display 
1dd0			.skip2:  
1dd0			endif 
1dd0 2a 31 eb			ld hl,(cli_token) 
1dd3 7e				ld a, (hl)	 ; char in word token 
1dd4 23				inc hl 		; move to next char 
1dd5 22 31 eb			ld (cli_token), hl ; and save it 
1dd8 47				ld b,a 
1dd9			 
1dd9 2a 2b eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1ddc 7e				ld a,(hl) 
1ddd 23				inc hl 
1dde 22 2b eb			ld (cli_ptr), hl		; move to next char 
1de1 cd 07 10			call toUpper 		; make sure the input string matches case 
1de4			 
1de4			if DEBUG_FORTH_PARSE 
1de4			endif 
1de4			 
1de4				; input stream end of token is a space so get rid of it 
1de4			 
1de4			;	cp ' ' 
1de4			;	jr nz, .pnskipspace 
1de4			; 
1de4			;	ld a, 0		; make same term as word token term 
1de4			; 
1de4			;.pnskipspace: 
1de4			 
1de4			if DEBUG_FORTH_PARSE_KEY 
1de4						DMARK "KY7" 
1de4			endif 
1de4 b8				cp b 
1de5 c2 fb 1d			jp nz, .execpnskipword	 ; no match so move to next word 
1de8				 
1de8			;    if same 
1de8			;       scan for string terms 0 for token and 32 for input 
1de8			 
1de8				 
1de8			if DEBUG_FORTH_PARSE_KEY 
1de8						DMARK "KY8" 
1de8			endif 
1de8			 
1de8 80				add b			 
1de9 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1deb							; TODO need to make sure last word in zero term string is accounted for 
1deb 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1ded			 
1ded			 
1ded				; at end of both strings so both are exact match 
1ded			 
1ded			;       skip ptr for next word 
1ded			 
1ded 2a 2b eb			ld hl,(cli_ptr) 	; at input string term 
1df0 23				inc hl			 ; at next char 
1df1 22 2b eb			ld (cli_ptr), hl     ; save for next round of the parser 
1df4 22 29 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1df7				 
1df7				 
1df7			if DEBUG_FORTH_PARSE_KEY 
1df7						DMARK "KY3" 
1df7			endif 
1df7			 
1df7			 
1df7			 
1df7			;       exec code block 
1df7			if DEBUG_FORTH_JP 
1df7				call clear_display 
1df7				call update_display 
1df7				call delay1s 
1df7				ld hl, (cli_execword)     ; save for next check if no match on this word 
1df7				ld a,h 
1df7				ld hl, os_word_scratch 
1df7				call hexout 
1df7				ld hl, (cli_execword)     ; save for next check if no match on this word 
1df7				ld a,l 
1df7				ld hl, os_word_scratch+2 
1df7				call hexout 
1df7				ld hl, os_word_scratch+4 
1df7				ld a,0 
1df7				ld (hl),a 
1df7				ld de,os_word_scratch 
1df7				call str_at_display 
1df7					ld a, display_row_2 
1df7					call str_at_display 
1df7				ld de, (cli_origtoken) 
1df7				ld a, display_row_1+10 
1df7					call str_at_display 
1df7			 
1df7				ld a,display_row_1 
1df7				ld de, .foundword 
1df7				ld a, display_row_3 
1df7				call str_at_display 
1df7				call update_display 
1df7				call delay1s 
1df7				call delay1s 
1df7				call delay1s 
1df7			endif 
1df7			 
1df7			if DEBUG_FORTH_PARSE_KEY 
1df7						DMARK "KYj" 
1df7			endif 
1df7				; TODO save the word pointer in this exec 
1df7			 
1df7 2a 2f eb			ld hl,(cli_execword) 
1dfa e9				jp (hl) 
1dfb			 
1dfb			 
1dfb			;    if not same 
1dfb			;	scan for zero term 
1dfb			;	get ptr for next word 
1dfb			;	goto word comp 
1dfb			 
1dfb			.execpnskipword:	; get pointer to next word 
1dfb 2a 2d eb			ld hl,(cli_nextword) 
1dfe			 
1dfe 7e				ld a,(hl) 
1dff fe 00			cp WORD_SYS_END 
1e01			;	cp 0 
1e01 28 09			jr z, .execendofdict			 ; at end of words 
1e03			 
1e03			if DEBUG_FORTH_PARSE_KEY 
1e03						DMARK "KY4" 
1e03			endif 
1e03			if DEBUG_FORTH_PARSE_EXEC 
1e03			 
1e03				; see if disabled 
1e03			 
1e03				ld a, (os_view_disable) 
1e03				cp '*' 
1e03				jr z, .noskip 
1e03			 
1e03			 
1e03				ld de, .nowordfound 
1e03				ld a, display_row_3 
1e03				call str_at_display 
1e03				call update_display 
1e03				ld a, 100 
1e03				call aDelayInMS 
1e03				 
1e03				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e03					call delay250ms 
1e03				endif 
1e03			.noskip:  
1e03			 
1e03			endif	 
1e03			 
1e03 2a 29 eb			ld hl,(cli_origptr) 
1e06 22 2b eb			ld (cli_ptr),hl 
1e09			 
1e09			if DEBUG_FORTH_PARSE_KEY 
1e09						DMARK "KY5" 
1e09			endif 
1e09 c3 af 1d			jp .execpnword			; else go to next word 
1e0c			 
1e0c			.execendofdict:  
1e0c			 
1e0c			if DEBUG_FORTH_PARSE_KEY 
1e0c						DMARK "KYe" 
1e0c			endif 
1e0c			if DEBUG_FORTH_PARSE_EXEC 
1e0c				; see if disabled 
1e0c			 
1e0c				ld a, (os_view_disable) 
1e0c				cp '*' 
1e0c				jr z, .ispskip 
1e0c			 
1e0c				call clear_display 
1e0c				call update_display 
1e0c				call delay1s 
1e0c				ld de, (cli_origptr) 
1e0c				ld a, display_row_1 
1e0c				call str_at_display 
1e0c				 
1e0c				ld de, .enddict 
1e0c				ld a, display_row_3 
1e0c				call str_at_display 
1e0c				call update_display 
1e0c				ld a, 100 
1e0c				call aDelayInMS 
1e0c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e0c				call delay1s 
1e0c				call delay1s 
1e0c				call delay1s 
1e0c				endif 
1e0c			.ispskip:  
1e0c				 
1e0c			endif	 
1e0c			 
1e0c			 
1e0c			 
1e0c				; if the word is not a keyword then must be a literal so push it to stack 
1e0c			 
1e0c			; push token to stack to end of word 
1e0c			 
1e0c				STACKFRAME ON $1efe $2f9f 
1e0c				if DEBUG_STACK_IMB 
1e0c					if ON 
1e0c						exx 
1e0c						ld de, $1efe 
1e0c						ld a, d 
1e0c						ld hl, curframe 
1e0c						call hexout 
1e0c						ld a, e 
1e0c						ld hl, curframe+2 
1e0c						call hexout 
1e0c						ld hl, $1efe 
1e0c						push hl 
1e0c						ld hl, $2f9f 
1e0c						push hl 
1e0c						exx 
1e0c					endif 
1e0c				endif 
1e0c			endm 
# End of macro STACKFRAME
1e0c			 
1e0c 2a 61 e6		ld hl,(os_tok_ptr) 
1e0f cd 04 1b		call forth_apush 
1e12			 
1e12				STACKFRAMECHK ON $1efe $2f9f 
1e12				if DEBUG_STACK_IMB 
1e12					if ON 
1e12						exx 
1e12						ld hl, $2f9f 
1e12						pop de   ; $2f9f 
1e12						call cmp16 
1e12						jr nz, .spnosame 
1e12						ld hl, $1efe 
1e12						pop de   ; $1efe 
1e12						call cmp16 
1e12						jr z, .spfrsame 
1e12						.spnosame: call showsperror 
1e12						.spfrsame: nop 
1e12						exx 
1e12					endif 
1e12				endif 
1e12			endm 
# End of macro STACKFRAMECHK
1e12			 
1e12			execnext: 
1e12			 
1e12			if DEBUG_FORTH_PARSE_KEY 
1e12						DMARK "KY>" 
1e12			endif 
1e12			; move past token to next word 
1e12			 
1e12 2a 61 e6		ld hl, (os_tok_ptr) 
1e15 3e 00		ld a, 0 
1e17 01 ff 00		ld bc, 255     ; input buffer size 
1e1a ed b1		cpir 
1e1c			 
1e1c			if DEBUG_FORTH_PARSE_KEY 
1e1c						DMARK "KY!" 
1e1c				CALLMONITOR 
1e1c			endif	 
1e1c			; TODO this might place hl on the null, so will need to forward on??? 
1e1c			;inc hl   ; see if this gets onto the next item 
1e1c			 
1e1c			 
1e1c			; TODO pass a pointer to the buffer to push 
1e1c			; TODO call function to push 
1e1c			 
1e1c			; look for end of input 
1e1c			 
1e1c			;inc hl 
1e1c			;ld a,(hl) 
1e1c			;cp FORTH_END_BUFFER 
1e1c			;ret z 
1e1c			 
1e1c			 
1e1c c3 95 1d		jp exec1 
1e1f			 
1e1f			 
1e1f			 
1e1f			 
1e1f			 
1e1f			 
1e1f			 
1e1f			 
1e1f			 
1e1f			findnexttok: 
1e1f			 
1e1f				; hl is pointer to move 
1e1f				; de is the token to locate 
1e1f			 
1e1f					if DEBUG_FORTH 
1e1f						DMARK "NTK" 
1e1f						CALLMONITOR 
1e1f					endif 
1e1f d5				push de 
1e20			 
1e20			.fnt1:	 
1e20				; find first char of token to locate 
1e20			 
1e20 1a				ld a, (de) 
1e21 4f				ld c,a 
1e22 7e				ld a,(hl) 
1e23 cd 07 10			call toUpper 
1e26					if DEBUG_FORTH 
1e26						DMARK "NT1" 
1e26						CALLMONITOR 
1e26					endif 
1e26 b9				cp c 
1e27			 
1e27 28 03			jr z, .fnt2cmpmorefirst	 
1e29			 
1e29				; first char not found move to next char 
1e29			 
1e29 23				inc hl 
1e2a 18 f4			jr .fnt1 
1e2c			 
1e2c			.fnt2cmpmorefirst:	 
1e2c				; first char of token found.  
1e2c			 
1e2c e5				push hl     ; save start of token just in case it is the right one 
1e2d d9				exx 
1e2e e1				pop hl        ; save it to hl' 
1e2f d9				exx 
1e30			 
1e30			 
1e30			.fnt2cmpmore:	 
1e30				; compare the rest 
1e30				 
1e30 23				inc hl 
1e31 13				inc de 
1e32				 
1e32 1a				ld a, (de) 
1e33 4f				ld c,a 
1e34 7e				ld a,(hl) 
1e35 cd 07 10			call toUpper 
1e38			 
1e38					if DEBUG_FORTH 
1e38						DMARK "NT2" 
1e38						CALLMONITOR 
1e38					endif 
1e38				; c has the token to find char 
1e38				; a has the mem to scan char 
1e38			 
1e38 b9				cp c 
1e39 28 04			jr z,.fntmatch1 
1e3b			 
1e3b				; they are not the same 
1e3b			 
1e3b					if DEBUG_FORTH 
1e3b						DMARK "NT3" 
1e3b						CALLMONITOR 
1e3b					endif 
1e3b d1				pop de	; reset de token to look for 
1e3c d5				push de 
1e3d 18 e1			jr .fnt1 
1e3f				 
1e3f			.fntmatch1: 
1e3f			 
1e3f				; is the same char a null which means we might have a full hit? 
1e3f					if DEBUG_FORTH 
1e3f						DMARK "NT4" 
1e3f						CALLMONITOR 
1e3f					endif 
1e3f			 
1e3f fe 00			cp 0 
1e41 28 0b			jr z, .fntmatchyes 
1e43			 
1e43				; are we at the end of the token to find? 
1e43			 
1e43					if DEBUG_FORTH 
1e43						DMARK "NT5" 
1e43						CALLMONITOR 
1e43					endif 
1e43 3e 00			ld a, 0 
1e45 b9				cp c 
1e46			 
1e46 c2 30 1e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1e49			 
1e49					if DEBUG_FORTH 
1e49						DMARK "NT6" 
1e49						CALLMONITOR 
1e49					endif 
1e49				; token to find is exhusted but no match to stream 
1e49			 
1e49				; restore tok pointer and continue on 
1e49 d1				pop de 
1e4a d5				push de 
1e4b c3 20 1e			jp .fnt1 
1e4e			 
1e4e			 
1e4e			.fntmatchyes: 
1e4e			 
1e4e				; hl now contains the end of the found token 
1e4e			 
1e4e				; get rid of saved token pointer to find 
1e4e			 
1e4e d1				pop de 
1e4f			 
1e4f					if DEBUG_FORTH 
1e4f						DMARK "NT9" 
1e4f						CALLMONITOR 
1e4f					endif 
1e4f			 
1e4f				; hl will be on the null term so forward on 
1e4f			 
1e4f				; get back the saved start of the token 
1e4f			 
1e4f d9				exx 
1e50 e5				push hl     ; save start of token just in case it is the right one 
1e51 d9				exx 
1e52 e1				pop hl        ; save it to hl 
1e53			 
1e53 c9				ret 
1e54			 
1e54			 
1e54			; LIST needs to find a specific token   
1e54			; FORGET needs to find a spefici token 
1e54			 
1e54			; SAVE needs to find all tokens by flag 
1e54			; WORDS just needs to scan through all  by flag 
1e54			; UWORDS needs to scan through all by flag 
1e54			 
1e54			 
1e54			; given hl as pointer to start of dict look up string 
1e54			; return hl as pointer to start of word block 
1e54			; or 0 if not found 
1e54			 
1e54			forth_find_tok: 
1e54 c9				ret 
1e55			 
1e55			; given hl as pointer to dict structure 
1e55			; move to the next dict block structure 
1e55			 
1e55			forth_tok_next: 
1e55				; hl now points to the address of the next word pointer  
1e55				; TODO skip compiled symbol for now 
1e55			;	push de 
1e55 23				inc hl 
1e56 5e				ld e, (hl) 
1e57 23				inc hl 
1e58 56				ld d, (hl) 
1e59 23				inc hl 
1e5a			 
1e5a eb				ex de,hl 
1e5b			if DEBUG_FORTH_PARSE_NEXTWORD 
1e5b				push bc 
1e5b				ld bc, (cli_nextword) 
1e5b						DMARK "NXW" 
1e5b				CALLMONITOR 
1e5b				pop bc 
1e5b			endif 
1e5b			;	pop de	 
1e5b c9				ret 
1e5c			 
1e5c			 
1e5c			 
1e5c			; eof 
# End of file forth_parserv5.asm
1e5c				include "forth_wordsv4.asm" 
1e5c			 
1e5c			; the core word dictionary v4 
1e5c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1e5c			 
1e5c			; this is a linked list for each of the system words used 
1e5c			; user defined words will follow the same format but will be in ram 
1e5c			 
1e5c			 
1e5c			; 
1e5c			; 
1e5c			; define linked list: 
1e5c			; 
1e5c			; 1. compiled byte op code 
1e5c			; 2. len of text word 
1e5c			; 3. text word 
1e5c			; 4. ptr to next dictionary word 
1e5c			; 5. asm, calls etc for the word 
1e5c			; 
1e5c			;  if 1 == 0 then last word in dict  
1e5c			;   
1e5c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1e5c			;  
1e5c			;  
1e5c			; create basic standard set of words 
1e5c			; 
1e5c			;  
1e5c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1e5c			; 2DUP 2DROP 2SWAP  
1e5c			; @ C@ - get byte  
1e5c			; ! C! - store byte 
1e5c			; 0< true if less than zero 
1e5c			; 0= true if zero 
1e5c			; < >  
1e5c			; = true if same 
1e5c			; variables 
1e5c			 
1e5c			 
1e5c			; Hardware specific words I may need 
1e5c			; 
1e5c			; IN OUT  
1e5c			; calls to key util functions 
1e5c			; calls to hardward abstraction stuff 
1e5c			; easy control of frame buffers and lcd i/o 
1e5c			; keyboard  
1e5c			 
1e5c			 
1e5c			;DICT: macro 
1e5c			; op_code, len, word, next 
1e5c			;    word: 
1e5c			;    db op_code 
1e5c			;    ds word zero term 
1e5c			;    dw next 
1e5c			;    endm 
1e5c			 
1e5c			 
1e5c			 
1e5c			 
1e5c			; op code 1 is a flag for user define words which are to be handled differently 
1e5c			 
1e5c			 
1e5c			; 
1e5c			; 
1e5c			;    TODO on entry to a word this should be the expected environment 
1e5c			;    hl - tos value if number then held, if string this is the ptr 
1e5c			;    de -  
1e5c			 
1e5c			 
1e5c			; opcode ranges 
1e5c			; 0 - end of word dict 
1e5c			; 255 - user define words 
1e5c			 
1e5c			sysdict: 
1e5c			include "forth_opcodes.asm" 
1e5c			; op codes for forth keywords 
1e5c			; free to use code 0  
1e5c				OPCODE_HEAP: equ  1 
1e5c				OPCODE_EXEC: equ 2 
1e5c				OPCODE_DUP: equ 3 
1e5c				OPCODE_SWAP: equ 4 
1e5c				OPCODE_COLN: equ 5 
1e5c				OPCODE_SCOLN: equ 6 
1e5c				OPCODE_DROP: equ 7 
1e5c				OPCODE_DUP2: equ 8 
1e5c				OPCODE_DROP2: equ 9 
1e5c				OPCODE_SWAP2: equ 10 
1e5c				OPCODE_AT: equ 11 
1e5c				OPCODE_CAT: equ 12 
1e5c				OPCODE_BANG: equ 13 
1e5c				OPCODE_CBANG: equ 14 
1e5c				OPCODE_SCALL: equ 15 
1e5c				OPCODE_DEPTH: equ 16 
1e5c				OPCODE_OVER: equ 17 
1e5c				OPCODE_PAUSE: equ 18 
1e5c				OPCODE_PAUSES: equ 19 
1e5c				OPCODE_ROT: equ 20 
1e5c			;free to reuse	OPCODE_WORDS: equ 21 
1e5c			        OPCODE_NOT: equ 21 
1e5c				OPCODE_UWORDS: equ 22 
1e5c				OPCODE_BP: equ 23 
1e5c				OPCODE_MONITOR: equ 24  
1e5c				OPCODE_MALLOC: equ 25 
1e5c				OPCODE_FREE: equ 26 
1e5c				OPCODE_LIST: equ 27 
1e5c				OPCODE_FORGET: equ 28 
1e5c				OPCODE_NOP: equ 29 
1e5c				OPCODE_COMO: equ 30 
1e5c				OPCODE_COMC: equ 31 
1e5c			;free to reuse	OPCODE_ENDCORE: equ 32 
1e5c				OPCODE_AFTERSOUND: equ 33 
1e5c				OPCODE_GP2: equ 34 
1e5c				OPCODE_GP3: equ 35 
1e5c				OPCODE_GP4: equ 36 
1e5c				OPCODE_SIN: equ 37 
1e5c				OPCODE_SOUT: equ 38 
1e5c				OPCODE_SPIO: equ 39 
1e5c				OPCODE_SPICEH: equ 40 
1e5c				OPCODE_SPIOb: equ 41 
1e5c				OPCODE_SPII: equ 42 
1e5c				OPCODE_SESEL: equ 43 
1e5c				OPCODE_CARTDEV: equ 44 
1e5c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1e5c				OPCODE_FB: equ 46 
1e5c				OPCODE_EMIT: equ 47 
1e5c				OPCODE_DOTH: equ 48 
1e5c				OPCODE_DOTF: equ 49 
1e5c				OPCODE_DOT: equ 50 
1e5c				OPCODE_CLS: equ 51 
1e5c				OPCODE_DRAW: equ 52 
1e5c				OPCODE_DUMP: equ 53 
1e5c				OPCODE_CDUMP: equ 54 
1e5c				OPCODE_DAT: equ 55 
1e5c				OPCODE_HOME: equ 56 
1e5c				OPCODE_SPACE: equ 57 
1e5c				OPCODE_SPACES: equ 58 
1e5c				OPCODE_SCROLL: equ 59 
1e5c				OPCODE_ATQ: equ 60 
1e5c				OPCODE_AUTODSP: equ 61 
1e5c				OPCODE_MENU: equ 62 
1e5c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1e5c				OPCODE_THEN: equ 64 
1e5c				OPCODE_ELSE: equ 65 
1e5c				OPCODE_DO: equ 66 
1e5c				OPCODE_LOOP: equ 67 
1e5c				OPCODE_I: equ 68 
1e5c				OPCODE_DLOOP: equ 69  
1e5c				OPCODE_REPEAT: equ 70  
1e5c				OPCODE_UNTIL: equ 71 
1e5c				OPCODE_ENDFLOW: equ 72 
1e5c				OPCODE_WAITK: equ 73 
1e5c				OPCODE_ACCEPT: equ 74 
1e5c				OPCODE_EDIT: equ 75 
1e5c			;free to reuse	OPCODE_ENDKEY: equ 76 
1e5c				OPCODE_LZERO: equ 77 
1e5c				OPCODE_TZERO: equ 78 
1e5c				OPCODE_LESS: equ 79 
1e5c				OPCODE_GT: equ 80 
1e5c				OPCODE_EQUAL: equ 81  
1e5c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1e5c				OPCODE_NEG: equ 83 
1e5c				OPCODE_DIV: equ 84 
1e5c				OPCODE_MUL: equ 85 
1e5c				OPCODE_MIN: equ 86 
1e5c				OPCODE_MAX: equ 87 
1e5c				OPCODE_RND16: equ 88 
1e5c				OPCODE_RND8: equ 89 
1e5c				OPCODE_RND: equ 90 
1e5c			;free to reuse	OPCODE_ENDMATHS: equ 91  
1e5c				OPCODE_BYNAME: equ 92 
1e5c				OPCODE_DIR: equ 93 
1e5c				OPCODE_SAVE: equ 94 
1e5c				OPCODE_LOAD: equ 95 
1e5c				OPCODE_BSAVE: equ 96 
1e5c				OPCODE_BLOAD: equ 97 
1e5c				OPCODE_SEO: equ 98  
1e5c				OPCODE_SEI: equ 99 
1e5c				OPCODE_SFREE: equ 100 
1e5c				OPCODE_SIZE: equ 101 
1e5c				OPCODE_CREATE: equ 102 
1e5c				OPCODE_APPEND: equ 103 
1e5c				OPCODE_SDEL: equ 104 
1e5c				OPCODE_OPEN: equ 105 
1e5c				OPCODE_READ: equ 106 
1e5c				OPCODE_EOF: equ 106 
1e5c				OPCODE_FORMAT: equ 107 
1e5c				OPCODE_LABEL: equ 108 
1e5c				OPCODE_LABELS: equ 109 
1e5c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1e5c				OPCODE_UPPER: equ 111 
1e5c				OPCODE_LOWER: equ 112 
1e5c				OPCODE_SUBSTR: equ 113 
1e5c				OPCODE_LEFT: equ 114 
1e5c				OPCODE_RIGHT: equ 115 
1e5c				OPCODE_STR2NUM: equ 116 
1e5c				OPCODE_NUM2STR: equ 117 
1e5c				OPCODE_CONCAT: equ 118 
1e5c				OPCODE_FIND: equ 119 
1e5c				OPCODE_LEN: equ 120 
1e5c				OPCODE_CHAR: equ 121 
1e5c			; free to reuse	OPCODE_STRLEN: equ 122 
1e5c			; free to reuse	OPCODE_ENDSTR: equ 123 
1e5c				OPCODE_V0S: equ 124 
1e5c				OPCODE_V0Q: equ 125 
1e5c				OPCODE_V1S: equ 126 
1e5c				OPCODE_V1Q: equ 127 
1e5c				OPCODE_V2S: equ 128 
1e5c				OPCODE_V2Q: equ 129 
1e5c				OPCODE_V3S: equ 130 
1e5c				OPCODE_V3Q: equ 131 
1e5c			;free to reuse	OPCODE_END: equ 132 
1e5c				OPCODE_ZDUP: equ 133 
1e5c			 
1e5c			; eof 
# End of file forth_opcodes.asm
1e5c			 
1e5c			include "forth_words_core.asm" 
1e5c			 
1e5c			; | ## Core Words 
1e5c			 
1e5c			;if MALLOC_4 
1e5c			 
1e5c			.HEAP: 
1e5c				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1e5c 15				db WORD_SYS_CORE+OPCODE_HEAP             
1e5d 9b 1e			dw .EXEC            
1e5f 05				db 4 + 1 
1e60 .. 00			db "HEAP",0              
1e65				endm 
# End of macro CWHEAD
1e65			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1e65			; | | u1 - Current number of bytes in the heap 
1e65			; | | u2 - Remaining bytes left on the heap 
1e65			; | |  
1e65			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1e65			 
1e65			 
1e65					if DEBUG_FORTH_WORDS_KEY 
1e65						DMARK "HEP" 
1e65 f5				push af  
1e66 3a 7a 1e			ld a, (.dmark)  
1e69 32 7a ee			ld (debug_mark),a  
1e6c 3a 7b 1e			ld a, (.dmark+1)  
1e6f 32 7b ee			ld (debug_mark+1),a  
1e72 3a 7c 1e			ld a, (.dmark+2)  
1e75 32 7c ee			ld (debug_mark+2),a  
1e78 18 03			jr .pastdmark  
1e7a ..			.dmark: db "HEP"  
1e7d f1			.pastdmark: pop af  
1e7e			endm  
# End of macro DMARK
1e7e						CALLMONITOR 
1e7e cd 0e 14			call break_point_state  
1e81				endm  
# End of macro CALLMONITOR
1e81					endif 
1e81 2a f0 59				ld hl, (free_list )      
1e84 11 f5 59				ld de, heap_start 
1e87			 
1e87 ed 52				sbc hl, de  
1e89			 
1e89 cd 9b 19				call forth_push_numhl 
1e8c			 
1e8c			 
1e8c ed 5b f0 59			ld de, (free_list )      
1e90 21 46 e3				ld hl, heap_end 
1e93			 
1e93 ed 52				sbc hl, de 
1e95			 
1e95 cd 9b 19				call forth_push_numhl 
1e98					 
1e98			 
1e98					 
1e98			 
1e98			 
1e98			 
1e98					NEXTW 
1e98 c3 04 1d			jp macro_next 
1e9b				endm 
# End of macro NEXTW
1e9b			;endif 
1e9b			 
1e9b			.EXEC: 
1e9b				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1e9b 16				db WORD_SYS_CORE+OPCODE_EXEC             
1e9c 37 1f			dw .STKEXEC            
1e9e 05				db 4 + 1 
1e9f .. 00			db "EXEC",0              
1ea4				endm 
# End of macro CWHEAD
1ea4			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1ea4			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1ea4			; | | 
1ea4			; | |   
1ea4				STACKFRAME OFF $5efe $5f9f 
1ea4				if DEBUG_STACK_IMB 
1ea4					if OFF 
1ea4						exx 
1ea4						ld de, $5efe 
1ea4						ld a, d 
1ea4						ld hl, curframe 
1ea4						call hexout 
1ea4						ld a, e 
1ea4						ld hl, curframe+2 
1ea4						call hexout 
1ea4						ld hl, $5efe 
1ea4						push hl 
1ea4						ld hl, $5f9f 
1ea4						push hl 
1ea4						exx 
1ea4					endif 
1ea4				endif 
1ea4			endm 
# End of macro STACKFRAME
1ea4			 
1ea4					if DEBUG_FORTH_WORDS_KEY 
1ea4						DMARK "EXE" 
1ea4 f5				push af  
1ea5 3a b9 1e			ld a, (.dmark)  
1ea8 32 7a ee			ld (debug_mark),a  
1eab 3a ba 1e			ld a, (.dmark+1)  
1eae 32 7b ee			ld (debug_mark+1),a  
1eb1 3a bb 1e			ld a, (.dmark+2)  
1eb4 32 7c ee			ld (debug_mark+2),a  
1eb7 18 03			jr .pastdmark  
1eb9 ..			.dmark: db "EXE"  
1ebc f1			.pastdmark: pop af  
1ebd			endm  
# End of macro DMARK
1ebd						CALLMONITOR 
1ebd cd 0e 14			call break_point_state  
1ec0				endm  
# End of macro CALLMONITOR
1ec0					endif 
1ec0			 
1ec0				FORTH_DSP_VALUEHL 
1ec0 cd 92 1b			call macro_dsp_valuehl 
1ec3				endm 
# End of macro FORTH_DSP_VALUEHL
1ec3			 
1ec3				FORTH_DSP_POP 
1ec3 cd 4a 1c			call macro_forth_dsp_pop 
1ec6				endm 
# End of macro FORTH_DSP_POP
1ec6			 
1ec6					if DEBUG_FORTH_WORDS 
1ec6						DMARK "EX1" 
1ec6 f5				push af  
1ec7 3a db 1e			ld a, (.dmark)  
1eca 32 7a ee			ld (debug_mark),a  
1ecd 3a dc 1e			ld a, (.dmark+1)  
1ed0 32 7b ee			ld (debug_mark+1),a  
1ed3 3a dd 1e			ld a, (.dmark+2)  
1ed6 32 7c ee			ld (debug_mark+2),a  
1ed9 18 03			jr .pastdmark  
1edb ..			.dmark: db "EX1"  
1ede f1			.pastdmark: pop af  
1edf			endm  
# End of macro DMARK
1edf						CALLMONITOR 
1edf cd 0e 14			call break_point_state  
1ee2				endm  
# End of macro CALLMONITOR
1ee2					endif 
1ee2			;	ld e,(hl) 
1ee2			;	inc hl 
1ee2			;	ld d,(hl) 
1ee2			;	ex de,hl 
1ee2			 
1ee2			;		if DEBUG_FORTH_WORDS 
1ee2			;			DMARK "EX2" 
1ee2			;			CALLMONITOR 
1ee2			;		endif 
1ee2 e5				push hl 
1ee3			 
1ee3				;ld a, 0 
1ee3				;ld a, FORTH_END_BUFFER 
1ee3 cd 10 10			call strlenz 
1ee6 23				inc hl   ; include zero term to copy 
1ee7 23				inc hl   ; include term 
1ee8 23				inc hl   ; include term 
1ee9 06 00			ld b,0 
1eeb 4d				ld c,l 
1eec e1				pop hl 
1eed 11 5f e4			ld de, execscratch 
1ef0					if DEBUG_FORTH_WORDS 
1ef0						DMARK "EX3" 
1ef0 f5				push af  
1ef1 3a 05 1f			ld a, (.dmark)  
1ef4 32 7a ee			ld (debug_mark),a  
1ef7 3a 06 1f			ld a, (.dmark+1)  
1efa 32 7b ee			ld (debug_mark+1),a  
1efd 3a 07 1f			ld a, (.dmark+2)  
1f00 32 7c ee			ld (debug_mark+2),a  
1f03 18 03			jr .pastdmark  
1f05 ..			.dmark: db "EX3"  
1f08 f1			.pastdmark: pop af  
1f09			endm  
# End of macro DMARK
1f09						CALLMONITOR 
1f09 cd 0e 14			call break_point_state  
1f0c				endm  
# End of macro CALLMONITOR
1f0c					endif 
1f0c ed b0			ldir 
1f0e			 
1f0e			 
1f0e 21 5f e4			ld hl, execscratch 
1f11			 
1f11					if DEBUG_FORTH_WORDS 
1f11						DMARK "EXe" 
1f11 f5				push af  
1f12 3a 26 1f			ld a, (.dmark)  
1f15 32 7a ee			ld (debug_mark),a  
1f18 3a 27 1f			ld a, (.dmark+1)  
1f1b 32 7b ee			ld (debug_mark+1),a  
1f1e 3a 28 1f			ld a, (.dmark+2)  
1f21 32 7c ee			ld (debug_mark+2),a  
1f24 18 03			jr .pastdmark  
1f26 ..			.dmark: db "EXe"  
1f29 f1			.pastdmark: pop af  
1f2a			endm  
# End of macro DMARK
1f2a						CALLMONITOR 
1f2a cd 0e 14			call break_point_state  
1f2d				endm  
# End of macro CALLMONITOR
1f2d					endif 
1f2d			 
1f2d cd 52 1d			call forthparse 
1f30 cd 92 1d			call forthexec 
1f33			;	call forthexec_cleanup 
1f33			;	call forthparse 
1f33			;	call forthexec 
1f33			 
1f33				STACKFRAMECHK OFF $5efe $5f9f 
1f33				if DEBUG_STACK_IMB 
1f33					if OFF 
1f33						exx 
1f33						ld hl, $5f9f 
1f33						pop de   ; $5f9f 
1f33						call cmp16 
1f33						jr nz, .spnosame 
1f33						ld hl, $5efe 
1f33						pop de   ; $5efe 
1f33						call cmp16 
1f33						jr z, .spfrsame 
1f33						.spnosame: call showsperror 
1f33						.spfrsame: nop 
1f33						exx 
1f33					endif 
1f33				endif 
1f33			endm 
# End of macro STACKFRAMECHK
1f33			 
1f33				; an immediate word so no need to process any more words 
1f33 c9				ret 
1f34				NEXTW 
1f34 c3 04 1d			jp macro_next 
1f37				endm 
# End of macro NEXTW
1f37			 
1f37			; dead code - old version  
1f37			;	FORTH_RSP_NEXT 
1f37			 
1f37			;  
1f37			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f37			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f37			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f37			;	push hl 
1f37			;	push de 
1f37			;	push bc 
1f37			; 
1f37			; 
1f37			;		if DEBUG_FORTH_WORDS_KEY 
1f37			;			DMARK "EXR" 
1f37			;			CALLMONITOR 
1f37			;		endif 
1f37			; 
1f37			; 
1f37			; 
1f37			;	;v5 FORTH_DSP_VALUE 
1f37			;	FORTH_DSP_VALUEHL 
1f37			; 
1f37			;	; TODO do string type checks 
1f37			; 
1f37			;;v5	inc hl   ; skip type 
1f37			; 
1f37			;	push hl  ; source code  
1f37			;		if DEBUG_FORTH_WORDS 
1f37			;			DMARK "EX1" 
1f37			;			CALLMONITOR 
1f37			;		endif 
1f37			;	ld a, 0 
1f37			;	call strlent 
1f37			; 
1f37			;	inc hl 
1f37			;	inc hl 
1f37			;	inc hl 
1f37			;	inc hl 
1f37			; 
1f37			;	push hl    ; size 
1f37			; 
1f37			;		if DEBUG_FORTH_WORDS 
1f37			;			DMARK "EX2" 
1f37			;			CALLMONITOR 
1f37			;		endif 
1f37			;	call malloc 
1f37			; 
1f37			;	ex de, hl    ; de now contains malloc area 
1f37			;	pop bc   	; get byte count 
1f37			;	pop hl      ; get string to copy 
1f37			; 
1f37			;	push de     ; save malloc for free later 
1f37			; 
1f37			;		if DEBUG_FORTH_WORDS 
1f37			;			DMARK "EX3" 
1f37			;			CALLMONITOR 
1f37			;		endif 
1f37			;	ldir       ; duplicate string 
1f37			; 
1f37			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1f37			;	 
1f37			;	; TODO fix the parse would be better than this...  
1f37			;	ex de, hl 
1f37			;	dec hl 
1f37			;	ld a, 0 
1f37			;	ld (hl), a 
1f37			;	dec hl 
1f37			;	ld a, ' ' 
1f37			;	ld (hl), a 
1f37			;	dec hl 
1f37			;	ld (hl), a 
1f37			; 
1f37			;	dec hl 
1f37			;	ld (hl), a 
1f37			; 
1f37			; 
1f37			;	FORTH_DSP_POP  
1f37			; 
1f37			;	pop hl     
1f37			;	push hl    ; save malloc area 
1f37			; 
1f37			;		if DEBUG_FORTH_WORDS 
1f37			;			DMARK "EX4" 
1f37			;			CALLMONITOR 
1f37			;		endif 
1f37			; 
1f37			;	call forthparse 
1f37			;	call forthexec 
1f37			;	 
1f37			;	pop hl 
1f37			;	if DEBUG_FORTH_WORDS 
1f37			;		DMARK "EX5" 
1f37			;		CALLMONITOR 
1f37			;	endif 
1f37			; 
1f37			;	if FORTH_ENABLE_FREE 
1f37			;	call free 
1f37			;	endif 
1f37			; 
1f37			;	if DEBUG_FORTH_WORDS 
1f37			;		DMARK "EX6" 
1f37			;		CALLMONITOR 
1f37			;	endif 
1f37			; 
1f37			;	pop bc 
1f37			;	pop de 
1f37			;	pop hl 
1f37			;;	FORTH_RSP_POP	  
1f37			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1f37			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1f37			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1f37			; 
1f37			;	if DEBUG_FORTH_WORDS 
1f37			;		DMARK "EX7" 
1f37			;		CALLMONITOR 
1f37			;	endif 
1f37			;	NEXTW 
1f37			 
1f37			.STKEXEC: 
1f37				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1f37 3f				db WORD_SYS_CORE+43             
1f38 7f 20			dw .ZDUP            
1f3a 08				db 7 + 1 
1f3b .. 00			db "STKEXEC",0              
1f43				endm 
# End of macro CWHEAD
1f43			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1f43			 
1f43			 
1f43					if DEBUG_FORTH_WORDS_KEY 
1f43						DMARK "STX" 
1f43 f5				push af  
1f44 3a 58 1f			ld a, (.dmark)  
1f47 32 7a ee			ld (debug_mark),a  
1f4a 3a 59 1f			ld a, (.dmark+1)  
1f4d 32 7b ee			ld (debug_mark+1),a  
1f50 3a 5a 1f			ld a, (.dmark+2)  
1f53 32 7c ee			ld (debug_mark+2),a  
1f56 18 03			jr .pastdmark  
1f58 ..			.dmark: db "STX"  
1f5b f1			.pastdmark: pop af  
1f5c			endm  
# End of macro DMARK
1f5c						CALLMONITOR 
1f5c cd 0e 14			call break_point_state  
1f5f				endm  
# End of macro CALLMONITOR
1f5f					endif 
1f5f			 
1f5f				FORTH_DSP_VALUEHL 
1f5f cd 92 1b			call macro_dsp_valuehl 
1f62				endm 
# End of macro FORTH_DSP_VALUEHL
1f62			 
1f62 22 63 eb			ld (store_tmp1), hl    ; count 
1f65			 
1f65				FORTH_DSP_POP 
1f65 cd 4a 1c			call macro_forth_dsp_pop 
1f68				endm 
# End of macro FORTH_DSP_POP
1f68			.stkexec1: 
1f68 2a 63 eb			ld hl, (store_tmp1)   ; count 
1f6b 3e 00			ld a, 0 
1f6d bd				cp l 
1f6e c8				ret z 
1f6f			 
1f6f 2b				dec hl 
1f70 22 63 eb			ld (store_tmp1), hl    ; count 
1f73				 
1f73				FORTH_DSP_VALUEHL 
1f73 cd 92 1b			call macro_dsp_valuehl 
1f76				endm 
# End of macro FORTH_DSP_VALUEHL
1f76 e5				push hl 
1f77				 
1f77					if DEBUG_FORTH_WORDS 
1f77						DMARK "EXp" 
1f77 f5				push af  
1f78 3a 8c 1f			ld a, (.dmark)  
1f7b 32 7a ee			ld (debug_mark),a  
1f7e 3a 8d 1f			ld a, (.dmark+1)  
1f81 32 7b ee			ld (debug_mark+1),a  
1f84 3a 8e 1f			ld a, (.dmark+2)  
1f87 32 7c ee			ld (debug_mark+2),a  
1f8a 18 03			jr .pastdmark  
1f8c ..			.dmark: db "EXp"  
1f8f f1			.pastdmark: pop af  
1f90			endm  
# End of macro DMARK
1f90						CALLMONITOR 
1f90 cd 0e 14			call break_point_state  
1f93				endm  
# End of macro CALLMONITOR
1f93					endif 
1f93				FORTH_DSP_POP 
1f93 cd 4a 1c			call macro_forth_dsp_pop 
1f96				endm 
# End of macro FORTH_DSP_POP
1f96			 
1f96 cd 10 10			call strlenz 
1f99 23				inc hl   ; include zero term to copy 
1f9a 23				inc hl   ; include zero term to copy 
1f9b 23				inc hl   ; include zero term to copy 
1f9c 06 00			ld b,0 
1f9e 4d				ld c,l 
1f9f e1				pop hl 
1fa0 11 5f e4			ld de, execscratch 
1fa3					if DEBUG_FORTH_WORDS 
1fa3						DMARK "EX3" 
1fa3 f5				push af  
1fa4 3a b8 1f			ld a, (.dmark)  
1fa7 32 7a ee			ld (debug_mark),a  
1faa 3a b9 1f			ld a, (.dmark+1)  
1fad 32 7b ee			ld (debug_mark+1),a  
1fb0 3a ba 1f			ld a, (.dmark+2)  
1fb3 32 7c ee			ld (debug_mark+2),a  
1fb6 18 03			jr .pastdmark  
1fb8 ..			.dmark: db "EX3"  
1fbb f1			.pastdmark: pop af  
1fbc			endm  
# End of macro DMARK
1fbc						CALLMONITOR 
1fbc cd 0e 14			call break_point_state  
1fbf				endm  
# End of macro CALLMONITOR
1fbf					endif 
1fbf ed b0			ldir 
1fc1			 
1fc1			 
1fc1 21 5f e4			ld hl, execscratch 
1fc4			 
1fc4					if DEBUG_FORTH_WORDS 
1fc4						DMARK "EXP" 
1fc4 f5				push af  
1fc5 3a d9 1f			ld a, (.dmark)  
1fc8 32 7a ee			ld (debug_mark),a  
1fcb 3a da 1f			ld a, (.dmark+1)  
1fce 32 7b ee			ld (debug_mark+1),a  
1fd1 3a db 1f			ld a, (.dmark+2)  
1fd4 32 7c ee			ld (debug_mark+2),a  
1fd7 18 03			jr .pastdmark  
1fd9 ..			.dmark: db "EXP"  
1fdc f1			.pastdmark: pop af  
1fdd			endm  
# End of macro DMARK
1fdd						CALLMONITOR 
1fdd cd 0e 14			call break_point_state  
1fe0				endm  
# End of macro CALLMONITOR
1fe0					endif 
1fe0			 
1fe0 cd 52 1d			call forthparse 
1fe3 21 5f e4			ld hl, execscratch 
1fe6					if DEBUG_FORTH_WORDS 
1fe6						DMARK "EXx" 
1fe6 f5				push af  
1fe7 3a fb 1f			ld a, (.dmark)  
1fea 32 7a ee			ld (debug_mark),a  
1fed 3a fc 1f			ld a, (.dmark+1)  
1ff0 32 7b ee			ld (debug_mark+1),a  
1ff3 3a fd 1f			ld a, (.dmark+2)  
1ff6 32 7c ee			ld (debug_mark+2),a  
1ff9 18 03			jr .pastdmark  
1ffb ..			.dmark: db "EXx"  
1ffe f1			.pastdmark: pop af  
1fff			endm  
# End of macro DMARK
1fff						CALLMONITOR 
1fff cd 0e 14			call break_point_state  
2002				endm  
# End of macro CALLMONITOR
2002					endif 
2002 cd 92 1d			call forthexec 
2005			 
2005 c3 68 1f			jp .stkexec1 
2008			 
2008 c9				ret 
2009			 
2009			 
2009			.DUP: 
2009				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2009 17				db WORD_SYS_CORE+OPCODE_DUP             
200a 7f 20			dw .ZDUP            
200c 04				db 3 + 1 
200d .. 00			db "DUP",0              
2011				endm 
# End of macro CWHEAD
2011			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2011			 
2011					if DEBUG_FORTH_WORDS_KEY 
2011						DMARK "DUP" 
2011 f5				push af  
2012 3a 26 20			ld a, (.dmark)  
2015 32 7a ee			ld (debug_mark),a  
2018 3a 27 20			ld a, (.dmark+1)  
201b 32 7b ee			ld (debug_mark+1),a  
201e 3a 28 20			ld a, (.dmark+2)  
2021 32 7c ee			ld (debug_mark+2),a  
2024 18 03			jr .pastdmark  
2026 ..			.dmark: db "DUP"  
2029 f1			.pastdmark: pop af  
202a			endm  
# End of macro DMARK
202a						CALLMONITOR 
202a cd 0e 14			call break_point_state  
202d				endm  
# End of macro CALLMONITOR
202d					endif 
202d			 
202d					FORTH_DSP 
202d cd 58 1b			call macro_forth_dsp 
2030				endm 
# End of macro FORTH_DSP
2030			 
2030 7e					ld a, (HL) 
2031 fe 01				cp DS_TYPE_STR 
2033 20 25				jr nz, .dupinum 
2035			 
2035					; push another string 
2035			 
2035					FORTH_DSP_VALUEHL     		 
2035 cd 92 1b			call macro_dsp_valuehl 
2038				endm 
# End of macro FORTH_DSP_VALUEHL
2038			 
2038				if DEBUG_FORTH_WORDS 
2038					DMARK "DUs" 
2038 f5				push af  
2039 3a 4d 20			ld a, (.dmark)  
203c 32 7a ee			ld (debug_mark),a  
203f 3a 4e 20			ld a, (.dmark+1)  
2042 32 7b ee			ld (debug_mark+1),a  
2045 3a 4f 20			ld a, (.dmark+2)  
2048 32 7c ee			ld (debug_mark+2),a  
204b 18 03			jr .pastdmark  
204d ..			.dmark: db "DUs"  
2050 f1			.pastdmark: pop af  
2051			endm  
# End of macro DMARK
2051					CALLMONITOR 
2051 cd 0e 14			call break_point_state  
2054				endm  
# End of macro CALLMONITOR
2054				endif 
2054 cd 09 1a				call forth_push_str 
2057			 
2057					NEXTW 
2057 c3 04 1d			jp macro_next 
205a				endm 
# End of macro NEXTW
205a			 
205a			 
205a			.dupinum: 
205a					 
205a			 
205a			 
205a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
205a cd 92 1b			call macro_dsp_valuehl 
205d				endm 
# End of macro FORTH_DSP_VALUEHL
205d			 
205d				; TODO add floating point number detection 
205d			 
205d				if DEBUG_FORTH_WORDS 
205d					DMARK "DUi" 
205d f5				push af  
205e 3a 72 20			ld a, (.dmark)  
2061 32 7a ee			ld (debug_mark),a  
2064 3a 73 20			ld a, (.dmark+1)  
2067 32 7b ee			ld (debug_mark+1),a  
206a 3a 74 20			ld a, (.dmark+2)  
206d 32 7c ee			ld (debug_mark+2),a  
2070 18 03			jr .pastdmark  
2072 ..			.dmark: db "DUi"  
2075 f1			.pastdmark: pop af  
2076			endm  
# End of macro DMARK
2076					CALLMONITOR 
2076 cd 0e 14			call break_point_state  
2079				endm  
# End of macro CALLMONITOR
2079				endif 
2079			 
2079 cd 9b 19				call forth_push_numhl 
207c					NEXTW 
207c c3 04 1d			jp macro_next 
207f				endm 
# End of macro NEXTW
207f			.ZDUP: 
207f				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
207f 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2080 b7 20			dw .SWAP            
2082 05				db 4 + 1 
2083 .. 00			db "?DUP",0              
2088				endm 
# End of macro CWHEAD
2088			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2088			 
2088					if DEBUG_FORTH_WORDS_KEY 
2088						DMARK "qDU" 
2088 f5				push af  
2089 3a 9d 20			ld a, (.dmark)  
208c 32 7a ee			ld (debug_mark),a  
208f 3a 9e 20			ld a, (.dmark+1)  
2092 32 7b ee			ld (debug_mark+1),a  
2095 3a 9f 20			ld a, (.dmark+2)  
2098 32 7c ee			ld (debug_mark+2),a  
209b 18 03			jr .pastdmark  
209d ..			.dmark: db "qDU"  
20a0 f1			.pastdmark: pop af  
20a1			endm  
# End of macro DMARK
20a1						CALLMONITOR 
20a1 cd 0e 14			call break_point_state  
20a4				endm  
# End of macro CALLMONITOR
20a4					endif 
20a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
20a4 cd 92 1b			call macro_dsp_valuehl 
20a7				endm 
# End of macro FORTH_DSP_VALUEHL
20a7			 
20a7 e5					push hl 
20a8			 
20a8					; is it a zero? 
20a8			 
20a8 3e 00				ld a, 0 
20aa 84					add h 
20ab 85					add l 
20ac			 
20ac e1					pop hl 
20ad			 
20ad fe 00				cp 0 
20af 28 03				jr z, .dup2orig 
20b1			 
20b1			 
20b1 cd 9b 19				call forth_push_numhl 
20b4			 
20b4			 
20b4				; TODO add floating point number detection 
20b4			 
20b4			.dup2orig: 
20b4			 
20b4					NEXTW 
20b4 c3 04 1d			jp macro_next 
20b7				endm 
# End of macro NEXTW
20b7			.SWAP: 
20b7				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
20b7 18				db WORD_SYS_CORE+OPCODE_SWAP             
20b8 f6 20			dw .COLN            
20ba 05				db 4 + 1 
20bb .. 00			db "SWAP",0              
20c0				endm 
# End of macro CWHEAD
20c0			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
20c0					if DEBUG_FORTH_WORDS_KEY 
20c0						DMARK "SWP" 
20c0 f5				push af  
20c1 3a d5 20			ld a, (.dmark)  
20c4 32 7a ee			ld (debug_mark),a  
20c7 3a d6 20			ld a, (.dmark+1)  
20ca 32 7b ee			ld (debug_mark+1),a  
20cd 3a d7 20			ld a, (.dmark+2)  
20d0 32 7c ee			ld (debug_mark+2),a  
20d3 18 03			jr .pastdmark  
20d5 ..			.dmark: db "SWP"  
20d8 f1			.pastdmark: pop af  
20d9			endm  
# End of macro DMARK
20d9						CALLMONITOR 
20d9 cd 0e 14			call break_point_state  
20dc				endm  
# End of macro CALLMONITOR
20dc					endif 
20dc			 
20dc					FORTH_DSP_VALUEHL 
20dc cd 92 1b			call macro_dsp_valuehl 
20df				endm 
# End of macro FORTH_DSP_VALUEHL
20df e5					push hl     ; w2 
20e0			 
20e0					FORTH_DSP_POP 
20e0 cd 4a 1c			call macro_forth_dsp_pop 
20e3				endm 
# End of macro FORTH_DSP_POP
20e3			 
20e3					FORTH_DSP_VALUEHL 
20e3 cd 92 1b			call macro_dsp_valuehl 
20e6				endm 
# End of macro FORTH_DSP_VALUEHL
20e6			 
20e6					FORTH_DSP_POP 
20e6 cd 4a 1c			call macro_forth_dsp_pop 
20e9				endm 
# End of macro FORTH_DSP_POP
20e9			 
20e9 d1					pop de     ; w2	, hl = w1 
20ea			 
20ea eb					ex de, hl 
20eb d5					push de 
20ec			 
20ec cd 9b 19				call forth_push_numhl 
20ef			 
20ef e1					pop hl 
20f0			 
20f0 cd 9b 19				call forth_push_numhl 
20f3					 
20f3			 
20f3					NEXTW 
20f3 c3 04 1d			jp macro_next 
20f6				endm 
# End of macro NEXTW
20f6			.COLN: 
20f6				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
20f6 19				db WORD_SYS_CORE+OPCODE_COLN             
20f7 82 22			dw .SCOLN            
20f9 02				db 1 + 1 
20fa .. 00			db ":",0              
20fc				endm 
# End of macro CWHEAD
20fc			; | : ( -- )         Create new word | DONE 
20fc			 
20fc					if DEBUG_FORTH_WORDS_KEY 
20fc						DMARK "CLN" 
20fc f5				push af  
20fd 3a 11 21			ld a, (.dmark)  
2100 32 7a ee			ld (debug_mark),a  
2103 3a 12 21			ld a, (.dmark+1)  
2106 32 7b ee			ld (debug_mark+1),a  
2109 3a 13 21			ld a, (.dmark+2)  
210c 32 7c ee			ld (debug_mark+2),a  
210f 18 03			jr .pastdmark  
2111 ..			.dmark: db "CLN"  
2114 f1			.pastdmark: pop af  
2115			endm  
# End of macro DMARK
2115						CALLMONITOR 
2115 cd 0e 14			call break_point_state  
2118				endm  
# End of macro CALLMONITOR
2118					endif 
2118				STACKFRAME OFF $8efe $989f 
2118				if DEBUG_STACK_IMB 
2118					if OFF 
2118						exx 
2118						ld de, $8efe 
2118						ld a, d 
2118						ld hl, curframe 
2118						call hexout 
2118						ld a, e 
2118						ld hl, curframe+2 
2118						call hexout 
2118						ld hl, $8efe 
2118						push hl 
2118						ld hl, $989f 
2118						push hl 
2118						exx 
2118					endif 
2118				endif 
2118			endm 
# End of macro STACKFRAME
2118				; get parser buffer length  of new word 
2118			 
2118				 
2118			 
2118					; move tok past this to start of name defintition 
2118					; TODO get word to define 
2118					; TODO Move past word token 
2118					; TODO get length of string up to the ';' 
2118			 
2118 2a 61 e6			ld hl, (os_tok_ptr) 
211b 23				inc hl 
211c 23				inc hl 
211d			 
211d 3e 3b			ld a, ';' 
211f cd 1b 10			call strlent 
2122			 
2122 7d				ld a,l 
2123 32 5c e3			ld (os_new_parse_len), a 
2126			 
2126			 
2126			if DEBUG_FORTH_UWORD 
2126 ed 5b 61 e6		ld de, (os_tok_ptr) 
212a						DMARK ":01" 
212a f5				push af  
212b 3a 3f 21			ld a, (.dmark)  
212e 32 7a ee			ld (debug_mark),a  
2131 3a 40 21			ld a, (.dmark+1)  
2134 32 7b ee			ld (debug_mark+1),a  
2137 3a 41 21			ld a, (.dmark+2)  
213a 32 7c ee			ld (debug_mark+2),a  
213d 18 03			jr .pastdmark  
213f ..			.dmark: db ":01"  
2142 f1			.pastdmark: pop af  
2143			endm  
# End of macro DMARK
2143				CALLMONITOR 
2143 cd 0e 14			call break_point_state  
2146				endm  
# End of macro CALLMONITOR
2146			endif 
2146			 
2146			; 
2146			;  new word memory layout: 
2146			;  
2146			;    : adg 6666 ;  
2146			; 
2146			;    db   1     ; user defined word  
2146 23				inc hl    
2147			;    dw   sysdict 
2147 23				inc hl 
2148 23				inc hl 
2149			;    db <word len>+1 (for null) 
2149 23				inc hl 
214a			;    db .... <word> 
214a			; 
214a			 
214a 23				inc hl    ; some extras for the word preamble before the above 
214b 23				inc hl 
214c 23				inc hl 
214d 23				inc hl 
214e 23				inc hl 
214f 23				inc hl 
2150 23				inc hl  
2151 23				inc hl 
2152 23				inc hl 
2153 23				inc hl 
2154 23				inc hl 
2155 23				inc hl 
2156 23				inc hl 
2157 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2158			;       exec word buffer 
2158			;	<ptr word>   
2158 23				inc hl 
2159 23				inc hl 
215a			;       <word list><null term> 7F final term 
215a			 
215a			 
215a			if DEBUG_FORTH_UWORD 
215a						DMARK ":02" 
215a f5				push af  
215b 3a 6f 21			ld a, (.dmark)  
215e 32 7a ee			ld (debug_mark),a  
2161 3a 70 21			ld a, (.dmark+1)  
2164 32 7b ee			ld (debug_mark+1),a  
2167 3a 71 21			ld a, (.dmark+2)  
216a 32 7c ee			ld (debug_mark+2),a  
216d 18 03			jr .pastdmark  
216f ..			.dmark: db ":02"  
2172 f1			.pastdmark: pop af  
2173			endm  
# End of macro DMARK
2173				CALLMONITOR 
2173 cd 0e 14			call break_point_state  
2176				endm  
# End of macro CALLMONITOR
2176			endif 
2176			 
2176				 
2176					; malloc the size 
2176			 
2176 cd 79 10				call malloc 
2179 22 5e e3				ld (os_new_malloc), hl     ; save malloc start 
217c			 
217c			;    db   1     ; user defined word  
217c 3e 01				ld a, WORD_SYS_UWORD  
217e 77					ld (hl), a 
217f				 
217f 23				inc hl    
2180			;    dw   sysdict 
2180 11 5c 1e			ld de, sysdict       ; continue on with the scan to the system dict 
2183 73				ld (hl), e 
2184 23				inc hl 
2185 72				ld (hl), d 
2186 23				inc hl 
2187			 
2187			 
2187			;    Setup dict word 
2187			 
2187 23				inc hl 
2188 22 58 e3			ld (os_new_work_ptr), hl     ; save start of dict word  
218b			 
218b				; 1. get length of dict word 
218b			 
218b			 
218b 2a 61 e6			ld hl, (os_tok_ptr) 
218e 23				inc hl 
218f 23				inc hl    ; position to start of dict word 
2190 3e 00			ld a, 0 
2192 cd 1b 10			call strlent 
2195			 
2195			 
2195 23				inc hl    ; to include null??? 
2196			 
2196				; write length of dict word 
2196			 
2196 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
219a 1b				dec de 
219b eb				ex de, hl 
219c 73				ld (hl), e 
219d eb				ex de, hl 
219e			 
219e				 
219e			 
219e				; copy  
219e 4d				ld c, l 
219f 06 00			ld b, 0 
21a1 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
21a5 2a 61 e6			ld hl, (os_tok_ptr) 
21a8 23				inc hl 
21a9 23				inc hl    ; position to start of dict word 
21aa				 
21aa			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
21aa				 
21aa				; TODO need to convert word to upper case 
21aa			 
21aa			ucasetok:	 
21aa 7e				ld a,(hl) 
21ab cd 07 10			call toUpper 
21ae 77				ld (hl),a 
21af ed a0			ldi 
21b1 f2 aa 21		 	jp p, ucasetok 
21b4			 
21b4			 
21b4			 
21b4				; de now points to start of where the word body code should be placed 
21b4 ed 53 58 e3		ld (os_new_work_ptr), de 
21b8				; hl now points to the words to throw at forthexec which needs to be copied 
21b8 22 56 e3			ld (os_new_src_ptr), hl 
21bb			 
21bb				; TODO add 'call to forthexec' 
21bb			 
21bb			if DEBUG_FORTH_UWORD 
21bb c5				push bc 
21bc ed 4b 5e e3		ld bc, (os_new_malloc) 
21c0						DMARK ":0x" 
21c0 f5				push af  
21c1 3a d5 21			ld a, (.dmark)  
21c4 32 7a ee			ld (debug_mark),a  
21c7 3a d6 21			ld a, (.dmark+1)  
21ca 32 7b ee			ld (debug_mark+1),a  
21cd 3a d7 21			ld a, (.dmark+2)  
21d0 32 7c ee			ld (debug_mark+2),a  
21d3 18 03			jr .pastdmark  
21d5 ..			.dmark: db ":0x"  
21d8 f1			.pastdmark: pop af  
21d9			endm  
# End of macro DMARK
21d9				CALLMONITOR 
21d9 cd 0e 14			call break_point_state  
21dc				endm  
# End of macro CALLMONITOR
21dc c1				pop bc 
21dd			endif 
21dd			 
21dd			 
21dd				; create word preamble which should be: 
21dd			 
21dd			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
21dd			 
21dd				;    ld hl, <word code> 
21dd				;    jp user_exec 
21dd			        ;    <word code bytes> 
21dd			 
21dd			 
21dd			;	inc de     ; TODO ??? or are we already past the word's null 
21dd eb				ex de, hl 
21de			 
21de 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
21e0			 
21e0 23				inc hl 
21e1 22 52 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
21e4 23				inc hl 
21e5			 
21e5 23				inc hl 
21e6 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
21e8			 
21e8 01 71 45			ld bc, user_exec 
21eb 23				inc hl 
21ec 71				ld (hl), c     ; poke address of user_exec 
21ed 23				inc hl 
21ee 70				ld (hl), b     
21ef			 ; 
21ef			;	inc hl 
21ef			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
21ef			; 
21ef			; 
21ef			;	ld bc, macro_forth_rsp_next 
21ef			;	inc hl 
21ef			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
21ef			;	inc hl 
21ef			;	ld (hl), b     
21ef			 ; 
21ef			;	inc hl 
21ef			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
21ef			; 
21ef			; 
21ef			;	inc hl 
21ef			;	ld bc, forthexec 
21ef			;	ld (hl), c     ; poke address of forthexec 
21ef			;	inc hl 
21ef			;	ld (hl), b      
21ef			; 
21ef			;	inc hl 
21ef			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
21ef			; 
21ef			;	ld bc, user_dict_next 
21ef			;	inc hl 
21ef			;	ld (hl), c     ; poke address of forthexec 
21ef			;	inc hl 
21ef			;	ld (hl), b      
21ef			 
21ef				; hl is now where we need to copy the word byte data to save this 
21ef			 
21ef 23				inc hl 
21f0 22 54 e3			ld (os_new_exec), hl 
21f3				 
21f3				; copy definition 
21f3			 
21f3 eb				ex de, hl 
21f4			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
21f4			;	inc de    ; skip the PC for this parse 
21f4 3a 5c e3			ld a, (os_new_parse_len) 
21f7 4f				ld c, a 
21f8 06 00			ld b, 0 
21fa ed b0			ldir		 ; copy defintion 
21fc			 
21fc			 
21fc				; poke the address of where the new word bytes live for forthexec 
21fc			 
21fc 2a 52 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
21ff			 
21ff ed 5b 54 e3		ld de, (os_new_exec)      
2203				 
2203 73				ld (hl), e 
2204 23				inc hl 
2205 72				ld (hl), d 
2206			 
2206					; TODO copy last user dict word next link to this word 
2206					; TODO update last user dict word to point to this word 
2206			; 
2206			; hl f923 de 812a ; bc 811a 
2206			 
2206			if DEBUG_FORTH_UWORD 
2206 c5				push bc 
2207 ed 4b 5e e3		ld bc, (os_new_malloc) 
220b						DMARK ":0A" 
220b f5				push af  
220c 3a 20 22			ld a, (.dmark)  
220f 32 7a ee			ld (debug_mark),a  
2212 3a 21 22			ld a, (.dmark+1)  
2215 32 7b ee			ld (debug_mark+1),a  
2218 3a 22 22			ld a, (.dmark+2)  
221b 32 7c ee			ld (debug_mark+2),a  
221e 18 03			jr .pastdmark  
2220 ..			.dmark: db ":0A"  
2223 f1			.pastdmark: pop af  
2224			endm  
# End of macro DMARK
2224				CALLMONITOR 
2224 cd 0e 14			call break_point_state  
2227				endm  
# End of macro CALLMONITOR
2227 c1				pop bc 
2228			endif 
2228			if DEBUG_FORTH_UWORD 
2228 c5				push bc 
2229 ed 4b 5e e3		ld bc, (os_new_malloc) 
222d 03				inc bc 
222e 03				inc bc 
222f 03				inc bc 
2230 03				inc bc 
2231 03				inc bc 
2232 03				inc bc 
2233 03				inc bc 
2234 03				inc bc 
2235			 
2235						DMARK ":0B" 
2235 f5				push af  
2236 3a 4a 22			ld a, (.dmark)  
2239 32 7a ee			ld (debug_mark),a  
223c 3a 4b 22			ld a, (.dmark+1)  
223f 32 7b ee			ld (debug_mark+1),a  
2242 3a 4c 22			ld a, (.dmark+2)  
2245 32 7c ee			ld (debug_mark+2),a  
2248 18 03			jr .pastdmark  
224a ..			.dmark: db ":0B"  
224d f1			.pastdmark: pop af  
224e			endm  
# End of macro DMARK
224e				CALLMONITOR 
224e cd 0e 14			call break_point_state  
2251				endm  
# End of macro CALLMONITOR
2251 c1				pop bc 
2252			endif 
2252			 
2252			; update word dict linked list for new word 
2252			 
2252			 
2252 2a 5d e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2255 23			inc hl     ; move to next work linked list ptr 
2256			 
2256 ed 5b 5e e3	ld de, (os_new_malloc)		 ; new next word 
225a 73			ld (hl), e 
225b 23			inc hl 
225c 72			ld (hl), d 
225d			 
225d			if DEBUG_FORTH_UWORD 
225d ed 4b 5d e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2261			endif 
2261			 
2261 ed 53 5d e6	ld (os_last_new_uword), de      ; update last new uword ptr 
2265			 
2265			 
2265			if DEBUG_FORTH_UWORD 
2265						DMARK ":0+" 
2265 f5				push af  
2266 3a 7a 22			ld a, (.dmark)  
2269 32 7a ee			ld (debug_mark),a  
226c 3a 7b 22			ld a, (.dmark+1)  
226f 32 7b ee			ld (debug_mark+1),a  
2272 3a 7c 22			ld a, (.dmark+2)  
2275 32 7c ee			ld (debug_mark+2),a  
2278 18 03			jr .pastdmark  
227a ..			.dmark: db ":0+"  
227d f1			.pastdmark: pop af  
227e			endm  
# End of macro DMARK
227e				CALLMONITOR 
227e cd 0e 14			call break_point_state  
2281				endm  
# End of macro CALLMONITOR
2281			endif 
2281			 
2281				STACKFRAMECHK OFF $8efe $989f 
2281				if DEBUG_STACK_IMB 
2281					if OFF 
2281						exx 
2281						ld hl, $989f 
2281						pop de   ; $989f 
2281						call cmp16 
2281						jr nz, .spnosame 
2281						ld hl, $8efe 
2281						pop de   ; $8efe 
2281						call cmp16 
2281						jr z, .spfrsame 
2281						.spnosame: call showsperror 
2281						.spfrsame: nop 
2281						exx 
2281					endif 
2281				endif 
2281			endm 
# End of macro STACKFRAMECHK
2281			 
2281 c9			ret    ; dont process any remaining parser tokens as they form new word 
2282			 
2282			 
2282			 
2282			 
2282			;		NEXT 
2282			.SCOLN: 
2282			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2282 06				db OPCODE_SCOLN 
2283 ce 22			dw .DROP 
2285 02				db 2 
2286 .. 00			db ";",0           
2288			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2288					if DEBUG_FORTH_WORDS_KEY 
2288						DMARK "SCN" 
2288 f5				push af  
2289 3a 9d 22			ld a, (.dmark)  
228c 32 7a ee			ld (debug_mark),a  
228f 3a 9e 22			ld a, (.dmark+1)  
2292 32 7b ee			ld (debug_mark+1),a  
2295 3a 9f 22			ld a, (.dmark+2)  
2298 32 7c ee			ld (debug_mark+2),a  
229b 18 03			jr .pastdmark  
229d ..			.dmark: db "SCN"  
22a0 f1			.pastdmark: pop af  
22a1			endm  
# End of macro DMARK
22a1						CALLMONITOR 
22a1 cd 0e 14			call break_point_state  
22a4				endm  
# End of macro CALLMONITOR
22a4					endif 
22a4					FORTH_RSP_TOS 
22a4 cd 59 19			call macro_forth_rsp_tos 
22a7				endm 
# End of macro FORTH_RSP_TOS
22a7 e5					push hl 
22a8					FORTH_RSP_POP 
22a8 cd 63 19			call macro_forth_rsp_pop 
22ab				endm 
# End of macro FORTH_RSP_POP
22ab e1					pop hl 
22ac			;		ex de,hl 
22ac 22 61 e6				ld (os_tok_ptr),hl 
22af			 
22af			if DEBUG_FORTH_UWORD 
22af						DMARK "SCL" 
22af f5				push af  
22b0 3a c4 22			ld a, (.dmark)  
22b3 32 7a ee			ld (debug_mark),a  
22b6 3a c5 22			ld a, (.dmark+1)  
22b9 32 7b ee			ld (debug_mark+1),a  
22bc 3a c6 22			ld a, (.dmark+2)  
22bf 32 7c ee			ld (debug_mark+2),a  
22c2 18 03			jr .pastdmark  
22c4 ..			.dmark: db "SCL"  
22c7 f1			.pastdmark: pop af  
22c8			endm  
# End of macro DMARK
22c8				CALLMONITOR 
22c8 cd 0e 14			call break_point_state  
22cb				endm  
# End of macro CALLMONITOR
22cb			endif 
22cb					NEXTW 
22cb c3 04 1d			jp macro_next 
22ce				endm 
# End of macro NEXTW
22ce			 
22ce			.DROP: 
22ce				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
22ce 1b				db WORD_SYS_CORE+OPCODE_DROP             
22cf f9 22			dw .DUP2            
22d1 05				db 4 + 1 
22d2 .. 00			db "DROP",0              
22d7				endm 
# End of macro CWHEAD
22d7			; | DROP ( w -- )   drop the TOS item   | DONE 
22d7					if DEBUG_FORTH_WORDS_KEY 
22d7						DMARK "DRP" 
22d7 f5				push af  
22d8 3a ec 22			ld a, (.dmark)  
22db 32 7a ee			ld (debug_mark),a  
22de 3a ed 22			ld a, (.dmark+1)  
22e1 32 7b ee			ld (debug_mark+1),a  
22e4 3a ee 22			ld a, (.dmark+2)  
22e7 32 7c ee			ld (debug_mark+2),a  
22ea 18 03			jr .pastdmark  
22ec ..			.dmark: db "DRP"  
22ef f1			.pastdmark: pop af  
22f0			endm  
# End of macro DMARK
22f0						CALLMONITOR 
22f0 cd 0e 14			call break_point_state  
22f3				endm  
# End of macro CALLMONITOR
22f3					endif 
22f3					FORTH_DSP_POP 
22f3 cd 4a 1c			call macro_forth_dsp_pop 
22f6				endm 
# End of macro FORTH_DSP_POP
22f6					NEXTW 
22f6 c3 04 1d			jp macro_next 
22f9				endm 
# End of macro NEXTW
22f9			.DUP2: 
22f9				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
22f9 1c				db WORD_SYS_CORE+OPCODE_DUP2             
22fa 3e 23			dw .DROP2            
22fc 05				db 4 + 1 
22fd .. 00			db "2DUP",0              
2302				endm 
# End of macro CWHEAD
2302			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2302					if DEBUG_FORTH_WORDS_KEY 
2302						DMARK "2DU" 
2302 f5				push af  
2303 3a 17 23			ld a, (.dmark)  
2306 32 7a ee			ld (debug_mark),a  
2309 3a 18 23			ld a, (.dmark+1)  
230c 32 7b ee			ld (debug_mark+1),a  
230f 3a 19 23			ld a, (.dmark+2)  
2312 32 7c ee			ld (debug_mark+2),a  
2315 18 03			jr .pastdmark  
2317 ..			.dmark: db "2DU"  
231a f1			.pastdmark: pop af  
231b			endm  
# End of macro DMARK
231b						CALLMONITOR 
231b cd 0e 14			call break_point_state  
231e				endm  
# End of macro CALLMONITOR
231e					endif 
231e					FORTH_DSP_VALUEHL 
231e cd 92 1b			call macro_dsp_valuehl 
2321				endm 
# End of macro FORTH_DSP_VALUEHL
2321 e5					push hl      ; 2 
2322			 
2322					FORTH_DSP_POP 
2322 cd 4a 1c			call macro_forth_dsp_pop 
2325				endm 
# End of macro FORTH_DSP_POP
2325					 
2325					FORTH_DSP_VALUEHL 
2325 cd 92 1b			call macro_dsp_valuehl 
2328				endm 
# End of macro FORTH_DSP_VALUEHL
2328			;		push hl      ; 1 
2328			 
2328					FORTH_DSP_POP 
2328 cd 4a 1c			call macro_forth_dsp_pop 
232b				endm 
# End of macro FORTH_DSP_POP
232b			 
232b			;		pop hl       ; 1 
232b d1					pop de       ; 2 
232c			 
232c cd 9b 19				call forth_push_numhl 
232f eb					ex de, hl 
2330 cd 9b 19				call forth_push_numhl 
2333			 
2333					 
2333 eb					ex de, hl 
2334			 
2334 cd 9b 19				call forth_push_numhl 
2337 eb					ex de, hl 
2338 cd 9b 19				call forth_push_numhl 
233b			 
233b			 
233b					NEXTW 
233b c3 04 1d			jp macro_next 
233e				endm 
# End of macro NEXTW
233e			.DROP2: 
233e				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
233e 1d				db WORD_SYS_CORE+OPCODE_DROP2             
233f 6d 23			dw .SWAP2            
2341 06				db 5 + 1 
2342 .. 00			db "2DROP",0              
2348				endm 
# End of macro CWHEAD
2348			; | 2DROP ( w w -- )    Double drop | DONE 
2348					if DEBUG_FORTH_WORDS_KEY 
2348						DMARK "2DR" 
2348 f5				push af  
2349 3a 5d 23			ld a, (.dmark)  
234c 32 7a ee			ld (debug_mark),a  
234f 3a 5e 23			ld a, (.dmark+1)  
2352 32 7b ee			ld (debug_mark+1),a  
2355 3a 5f 23			ld a, (.dmark+2)  
2358 32 7c ee			ld (debug_mark+2),a  
235b 18 03			jr .pastdmark  
235d ..			.dmark: db "2DR"  
2360 f1			.pastdmark: pop af  
2361			endm  
# End of macro DMARK
2361						CALLMONITOR 
2361 cd 0e 14			call break_point_state  
2364				endm  
# End of macro CALLMONITOR
2364					endif 
2364					FORTH_DSP_POP 
2364 cd 4a 1c			call macro_forth_dsp_pop 
2367				endm 
# End of macro FORTH_DSP_POP
2367					FORTH_DSP_POP 
2367 cd 4a 1c			call macro_forth_dsp_pop 
236a				endm 
# End of macro FORTH_DSP_POP
236a					NEXTW 
236a c3 04 1d			jp macro_next 
236d				endm 
# End of macro NEXTW
236d			.SWAP2: 
236d				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
236d 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
236e 96 23			dw .AT            
2370 06				db 5 + 1 
2371 .. 00			db "2SWAP",0              
2377				endm 
# End of macro CWHEAD
2377			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2377					if DEBUG_FORTH_WORDS_KEY 
2377						DMARK "2SW" 
2377 f5				push af  
2378 3a 8c 23			ld a, (.dmark)  
237b 32 7a ee			ld (debug_mark),a  
237e 3a 8d 23			ld a, (.dmark+1)  
2381 32 7b ee			ld (debug_mark+1),a  
2384 3a 8e 23			ld a, (.dmark+2)  
2387 32 7c ee			ld (debug_mark+2),a  
238a 18 03			jr .pastdmark  
238c ..			.dmark: db "2SW"  
238f f1			.pastdmark: pop af  
2390			endm  
# End of macro DMARK
2390						CALLMONITOR 
2390 cd 0e 14			call break_point_state  
2393				endm  
# End of macro CALLMONITOR
2393					endif 
2393					NEXTW 
2393 c3 04 1d			jp macro_next 
2396				endm 
# End of macro NEXTW
2396			.AT: 
2396				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2396 1f				db WORD_SYS_CORE+OPCODE_AT             
2397 c8 23			dw .CAT            
2399 02				db 1 + 1 
239a .. 00			db "@",0              
239c				endm 
# End of macro CWHEAD
239c			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
239c			 
239c					if DEBUG_FORTH_WORDS_KEY 
239c						DMARK "AT." 
239c f5				push af  
239d 3a b1 23			ld a, (.dmark)  
23a0 32 7a ee			ld (debug_mark),a  
23a3 3a b2 23			ld a, (.dmark+1)  
23a6 32 7b ee			ld (debug_mark+1),a  
23a9 3a b3 23			ld a, (.dmark+2)  
23ac 32 7c ee			ld (debug_mark+2),a  
23af 18 03			jr .pastdmark  
23b1 ..			.dmark: db "AT."  
23b4 f1			.pastdmark: pop af  
23b5			endm  
# End of macro DMARK
23b5						CALLMONITOR 
23b5 cd 0e 14			call break_point_state  
23b8				endm  
# End of macro CALLMONITOR
23b8					endif 
23b8			.getbyteat:	 
23b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23b8 cd 92 1b			call macro_dsp_valuehl 
23bb				endm 
# End of macro FORTH_DSP_VALUEHL
23bb					 
23bb			;		push hl 
23bb				 
23bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23bb cd 4a 1c			call macro_forth_dsp_pop 
23be				endm 
# End of macro FORTH_DSP_POP
23be			 
23be			;		pop hl 
23be			 
23be 7e					ld a, (hl) 
23bf			 
23bf 6f					ld l, a 
23c0 26 00				ld h, 0 
23c2 cd 9b 19				call forth_push_numhl 
23c5			 
23c5					NEXTW 
23c5 c3 04 1d			jp macro_next 
23c8				endm 
# End of macro NEXTW
23c8			.CAT: 
23c8				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
23c8 20				db WORD_SYS_CORE+OPCODE_CAT             
23c9 f1 23			dw .BANG            
23cb 03				db 2 + 1 
23cc .. 00			db "C@",0              
23cf				endm 
# End of macro CWHEAD
23cf			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
23cf					if DEBUG_FORTH_WORDS_KEY 
23cf						DMARK "CAA" 
23cf f5				push af  
23d0 3a e4 23			ld a, (.dmark)  
23d3 32 7a ee			ld (debug_mark),a  
23d6 3a e5 23			ld a, (.dmark+1)  
23d9 32 7b ee			ld (debug_mark+1),a  
23dc 3a e6 23			ld a, (.dmark+2)  
23df 32 7c ee			ld (debug_mark+2),a  
23e2 18 03			jr .pastdmark  
23e4 ..			.dmark: db "CAA"  
23e7 f1			.pastdmark: pop af  
23e8			endm  
# End of macro DMARK
23e8						CALLMONITOR 
23e8 cd 0e 14			call break_point_state  
23eb				endm  
# End of macro CALLMONITOR
23eb					endif 
23eb c3 b8 23				jp .getbyteat 
23ee					NEXTW 
23ee c3 04 1d			jp macro_next 
23f1				endm 
# End of macro NEXTW
23f1			.BANG: 
23f1				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
23f1 21				db WORD_SYS_CORE+OPCODE_BANG             
23f2 27 24			dw .CBANG            
23f4 02				db 1 + 1 
23f5 .. 00			db "!",0              
23f7				endm 
# End of macro CWHEAD
23f7			; | ! ( x w -- ) Store x at address w      | DONE 
23f7					if DEBUG_FORTH_WORDS_KEY 
23f7						DMARK "BNG" 
23f7 f5				push af  
23f8 3a 0c 24			ld a, (.dmark)  
23fb 32 7a ee			ld (debug_mark),a  
23fe 3a 0d 24			ld a, (.dmark+1)  
2401 32 7b ee			ld (debug_mark+1),a  
2404 3a 0e 24			ld a, (.dmark+2)  
2407 32 7c ee			ld (debug_mark+2),a  
240a 18 03			jr .pastdmark  
240c ..			.dmark: db "BNG"  
240f f1			.pastdmark: pop af  
2410			endm  
# End of macro DMARK
2410						CALLMONITOR 
2410 cd 0e 14			call break_point_state  
2413				endm  
# End of macro CALLMONITOR
2413					endif 
2413			 
2413			.storebyteat:		 
2413					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2413 cd 92 1b			call macro_dsp_valuehl 
2416				endm 
# End of macro FORTH_DSP_VALUEHL
2416					 
2416 e5					push hl 
2417				 
2417					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2417 cd 4a 1c			call macro_forth_dsp_pop 
241a				endm 
# End of macro FORTH_DSP_POP
241a			 
241a					; get byte to poke 
241a			 
241a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
241a cd 92 1b			call macro_dsp_valuehl 
241d				endm 
# End of macro FORTH_DSP_VALUEHL
241d e5					push hl 
241e			 
241e			 
241e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
241e cd 4a 1c			call macro_forth_dsp_pop 
2421				endm 
# End of macro FORTH_DSP_POP
2421			 
2421			 
2421 d1					pop de 
2422 e1					pop hl 
2423			 
2423 73					ld (hl),e 
2424			 
2424			 
2424					NEXTW 
2424 c3 04 1d			jp macro_next 
2427				endm 
# End of macro NEXTW
2427			.CBANG: 
2427				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2427 22				db WORD_SYS_CORE+OPCODE_CBANG             
2428 50 24			dw .SCALL            
242a 03				db 2 + 1 
242b .. 00			db "C!",0              
242e				endm 
# End of macro CWHEAD
242e			; | C!  ( x w -- ) Store x at address w  | DONE 
242e					if DEBUG_FORTH_WORDS_KEY 
242e						DMARK "CBA" 
242e f5				push af  
242f 3a 43 24			ld a, (.dmark)  
2432 32 7a ee			ld (debug_mark),a  
2435 3a 44 24			ld a, (.dmark+1)  
2438 32 7b ee			ld (debug_mark+1),a  
243b 3a 45 24			ld a, (.dmark+2)  
243e 32 7c ee			ld (debug_mark+2),a  
2441 18 03			jr .pastdmark  
2443 ..			.dmark: db "CBA"  
2446 f1			.pastdmark: pop af  
2447			endm  
# End of macro DMARK
2447						CALLMONITOR 
2447 cd 0e 14			call break_point_state  
244a				endm  
# End of macro CALLMONITOR
244a					endif 
244a c3 13 24				jp .storebyteat 
244d					NEXTW 
244d c3 04 1d			jp macro_next 
2450				endm 
# End of macro NEXTW
2450			.SCALL: 
2450				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2450 23				db WORD_SYS_CORE+OPCODE_SCALL             
2451 84 24			dw .DEPTH            
2453 05				db 4 + 1 
2454 .. 00			db "CALL",0              
2459				endm 
# End of macro CWHEAD
2459			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2459					if DEBUG_FORTH_WORDS_KEY 
2459						DMARK "CLL" 
2459 f5				push af  
245a 3a 6e 24			ld a, (.dmark)  
245d 32 7a ee			ld (debug_mark),a  
2460 3a 6f 24			ld a, (.dmark+1)  
2463 32 7b ee			ld (debug_mark+1),a  
2466 3a 70 24			ld a, (.dmark+2)  
2469 32 7c ee			ld (debug_mark+2),a  
246c 18 03			jr .pastdmark  
246e ..			.dmark: db "CLL"  
2471 f1			.pastdmark: pop af  
2472			endm  
# End of macro DMARK
2472						CALLMONITOR 
2472 cd 0e 14			call break_point_state  
2475				endm  
# End of macro CALLMONITOR
2475					endif 
2475			 
2475					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2475 cd 92 1b			call macro_dsp_valuehl 
2478				endm 
# End of macro FORTH_DSP_VALUEHL
2478			 
2478			;		push hl 
2478			 
2478					; destroy value TOS 
2478			 
2478					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2478 cd 4a 1c			call macro_forth_dsp_pop 
247b				endm 
# End of macro FORTH_DSP_POP
247b			 
247b						 
247b			;		pop hl 
247b			 
247b					; how to do a call with hl???? save SP? 
247b cd ad 1c				call forth_call_hl 
247e			 
247e			 
247e					; TODO push value back onto stack for another op etc 
247e			 
247e cd 9b 19				call forth_push_numhl 
2481					NEXTW 
2481 c3 04 1d			jp macro_next 
2484				endm 
# End of macro NEXTW
2484			.DEPTH: 
2484				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2484 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2485 c1 24			dw .OVER            
2487 06				db 5 + 1 
2488 .. 00			db "DEPTH",0              
248e				endm 
# End of macro CWHEAD
248e			; | DEPTH ( -- u ) Push count of stack | DONE 
248e					; take current TOS and remove from base value div by two to get count 
248e					if DEBUG_FORTH_WORDS_KEY 
248e						DMARK "DEP" 
248e f5				push af  
248f 3a a3 24			ld a, (.dmark)  
2492 32 7a ee			ld (debug_mark),a  
2495 3a a4 24			ld a, (.dmark+1)  
2498 32 7b ee			ld (debug_mark+1),a  
249b 3a a5 24			ld a, (.dmark+2)  
249e 32 7c ee			ld (debug_mark+2),a  
24a1 18 03			jr .pastdmark  
24a3 ..			.dmark: db "DEP"  
24a6 f1			.pastdmark: pop af  
24a7			endm  
# End of macro DMARK
24a7						CALLMONITOR 
24a7 cd 0e 14			call break_point_state  
24aa				endm  
# End of macro CALLMONITOR
24aa					endif 
24aa			 
24aa			 
24aa 2a 0d eb			ld hl, (cli_data_sp) 
24ad 11 c7 e8			ld de, cli_data_stack 
24b0 ed 52			sbc hl,de 
24b2				 
24b2				; div by size of stack item 
24b2			 
24b2 5d				ld e,l 
24b3 0e 03			ld c, 3 
24b5 cd 42 0b			call Div8 
24b8			 
24b8 6f				ld l,a 
24b9 26 00			ld h,0 
24bb			 
24bb				;srl h 
24bb				;rr l 
24bb			 
24bb cd 9b 19				call forth_push_numhl 
24be					NEXTW 
24be c3 04 1d			jp macro_next 
24c1				endm 
# End of macro NEXTW
24c1			.OVER: 
24c1				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
24c1 42				db WORD_SYS_CORE+46             
24c2 08 25			dw .PAUSE            
24c4 05				db 4 + 1 
24c5 .. 00			db "OVER",0              
24ca				endm 
# End of macro CWHEAD
24ca			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
24ca					if DEBUG_FORTH_WORDS_KEY 
24ca						DMARK "OVR" 
24ca f5				push af  
24cb 3a df 24			ld a, (.dmark)  
24ce 32 7a ee			ld (debug_mark),a  
24d1 3a e0 24			ld a, (.dmark+1)  
24d4 32 7b ee			ld (debug_mark+1),a  
24d7 3a e1 24			ld a, (.dmark+2)  
24da 32 7c ee			ld (debug_mark+2),a  
24dd 18 03			jr .pastdmark  
24df ..			.dmark: db "OVR"  
24e2 f1			.pastdmark: pop af  
24e3			endm  
# End of macro DMARK
24e3						CALLMONITOR 
24e3 cd 0e 14			call break_point_state  
24e6				endm  
# End of macro CALLMONITOR
24e6					endif 
24e6			 
24e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24e6 cd 92 1b			call macro_dsp_valuehl 
24e9				endm 
# End of macro FORTH_DSP_VALUEHL
24e9 e5					push hl    ; n2 
24ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24ea cd 4a 1c			call macro_forth_dsp_pop 
24ed				endm 
# End of macro FORTH_DSP_POP
24ed			 
24ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24ed cd 92 1b			call macro_dsp_valuehl 
24f0				endm 
# End of macro FORTH_DSP_VALUEHL
24f0 e5					push hl    ; n1 
24f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24f1 cd 4a 1c			call macro_forth_dsp_pop 
24f4				endm 
# End of macro FORTH_DSP_POP
24f4			 
24f4 d1					pop de     ; n1 
24f5 e1					pop hl     ; n2 
24f6			 
24f6 d5					push de 
24f7 e5					push hl 
24f8 d5					push de 
24f9			 
24f9					; push back  
24f9			 
24f9 e1					pop hl 
24fa cd 9b 19				call forth_push_numhl 
24fd e1					pop hl 
24fe cd 9b 19				call forth_push_numhl 
2501 e1					pop hl 
2502 cd 9b 19				call forth_push_numhl 
2505					NEXTW 
2505 c3 04 1d			jp macro_next 
2508				endm 
# End of macro NEXTW
2508			 
2508			.PAUSE: 
2508				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2508 43				db WORD_SYS_CORE+47             
2509 3d 25			dw .PAUSES            
250b 08				db 7 + 1 
250c .. 00			db "PAUSEMS",0              
2514				endm 
# End of macro CWHEAD
2514			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2514					if DEBUG_FORTH_WORDS_KEY 
2514						DMARK "PMS" 
2514 f5				push af  
2515 3a 29 25			ld a, (.dmark)  
2518 32 7a ee			ld (debug_mark),a  
251b 3a 2a 25			ld a, (.dmark+1)  
251e 32 7b ee			ld (debug_mark+1),a  
2521 3a 2b 25			ld a, (.dmark+2)  
2524 32 7c ee			ld (debug_mark+2),a  
2527 18 03			jr .pastdmark  
2529 ..			.dmark: db "PMS"  
252c f1			.pastdmark: pop af  
252d			endm  
# End of macro DMARK
252d						CALLMONITOR 
252d cd 0e 14			call break_point_state  
2530				endm  
# End of macro CALLMONITOR
2530					endif 
2530					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2530 cd 92 1b			call macro_dsp_valuehl 
2533				endm 
# End of macro FORTH_DSP_VALUEHL
2533			;		push hl    ; n2 
2533					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2533 cd 4a 1c			call macro_forth_dsp_pop 
2536				endm 
# End of macro FORTH_DSP_POP
2536			;		pop hl 
2536			 
2536 7d					ld a, l 
2537 cd df 08				call aDelayInMS 
253a				       NEXTW 
253a c3 04 1d			jp macro_next 
253d				endm 
# End of macro NEXTW
253d			.PAUSES:  
253d				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
253d 44				db WORD_SYS_CORE+48             
253e ac 25			dw .ROT            
2540 06				db 5 + 1 
2541 .. 00			db "PAUSE",0              
2547				endm 
# End of macro CWHEAD
2547			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2547					if DEBUG_FORTH_WORDS_KEY 
2547						DMARK "PAU" 
2547 f5				push af  
2548 3a 5c 25			ld a, (.dmark)  
254b 32 7a ee			ld (debug_mark),a  
254e 3a 5d 25			ld a, (.dmark+1)  
2551 32 7b ee			ld (debug_mark+1),a  
2554 3a 5e 25			ld a, (.dmark+2)  
2557 32 7c ee			ld (debug_mark+2),a  
255a 18 03			jr .pastdmark  
255c ..			.dmark: db "PAU"  
255f f1			.pastdmark: pop af  
2560			endm  
# End of macro DMARK
2560						CALLMONITOR 
2560 cd 0e 14			call break_point_state  
2563				endm  
# End of macro CALLMONITOR
2563					endif 
2563					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2563 cd 92 1b			call macro_dsp_valuehl 
2566				endm 
# End of macro FORTH_DSP_VALUEHL
2566			;		push hl    ; n2 
2566					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2566 cd 4a 1c			call macro_forth_dsp_pop 
2569				endm 
# End of macro FORTH_DSP_POP
2569			;		pop hl 
2569 45					ld b, l 
256a					if DEBUG_FORTH_WORDS 
256a						DMARK "PAU" 
256a f5				push af  
256b 3a 7f 25			ld a, (.dmark)  
256e 32 7a ee			ld (debug_mark),a  
2571 3a 80 25			ld a, (.dmark+1)  
2574 32 7b ee			ld (debug_mark+1),a  
2577 3a 81 25			ld a, (.dmark+2)  
257a 32 7c ee			ld (debug_mark+2),a  
257d 18 03			jr .pastdmark  
257f ..			.dmark: db "PAU"  
2582 f1			.pastdmark: pop af  
2583			endm  
# End of macro DMARK
2583						CALLMONITOR 
2583 cd 0e 14			call break_point_state  
2586				endm  
# End of macro CALLMONITOR
2586					endif 
2586 c5			.pauses1:	push bc 
2587 cd fa 08				call delay1s 
258a c1					pop bc 
258b					if DEBUG_FORTH_WORDS 
258b						DMARK "PA1" 
258b f5				push af  
258c 3a a0 25			ld a, (.dmark)  
258f 32 7a ee			ld (debug_mark),a  
2592 3a a1 25			ld a, (.dmark+1)  
2595 32 7b ee			ld (debug_mark+1),a  
2598 3a a2 25			ld a, (.dmark+2)  
259b 32 7c ee			ld (debug_mark+2),a  
259e 18 03			jr .pastdmark  
25a0 ..			.dmark: db "PA1"  
25a3 f1			.pastdmark: pop af  
25a4			endm  
# End of macro DMARK
25a4						CALLMONITOR 
25a4 cd 0e 14			call break_point_state  
25a7				endm  
# End of macro CALLMONITOR
25a7					endif 
25a7 10 dd				djnz .pauses1 
25a9			 
25a9				       NEXTW 
25a9 c3 04 1d			jp macro_next 
25ac				endm 
# End of macro NEXTW
25ac			.ROT: 
25ac				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
25ac 45				db WORD_SYS_CORE+49             
25ad fa 25			dw .UWORDS            
25af 04				db 3 + 1 
25b0 .. 00			db "ROT",0              
25b4				endm 
# End of macro CWHEAD
25b4			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
25b4					if DEBUG_FORTH_WORDS_KEY 
25b4						DMARK "ROT" 
25b4 f5				push af  
25b5 3a c9 25			ld a, (.dmark)  
25b8 32 7a ee			ld (debug_mark),a  
25bb 3a ca 25			ld a, (.dmark+1)  
25be 32 7b ee			ld (debug_mark+1),a  
25c1 3a cb 25			ld a, (.dmark+2)  
25c4 32 7c ee			ld (debug_mark+2),a  
25c7 18 03			jr .pastdmark  
25c9 ..			.dmark: db "ROT"  
25cc f1			.pastdmark: pop af  
25cd			endm  
# End of macro DMARK
25cd						CALLMONITOR 
25cd cd 0e 14			call break_point_state  
25d0				endm  
# End of macro CALLMONITOR
25d0					endif 
25d0			 
25d0					FORTH_DSP_VALUEHL 
25d0 cd 92 1b			call macro_dsp_valuehl 
25d3				endm 
# End of macro FORTH_DSP_VALUEHL
25d3 e5					push hl    ; u3  
25d4			 
25d4					FORTH_DSP_POP 
25d4 cd 4a 1c			call macro_forth_dsp_pop 
25d7				endm 
# End of macro FORTH_DSP_POP
25d7			   
25d7					FORTH_DSP_VALUEHL 
25d7 cd 92 1b			call macro_dsp_valuehl 
25da				endm 
# End of macro FORTH_DSP_VALUEHL
25da e5					push hl     ; u2 
25db			 
25db					FORTH_DSP_POP 
25db cd 4a 1c			call macro_forth_dsp_pop 
25de				endm 
# End of macro FORTH_DSP_POP
25de			 
25de					FORTH_DSP_VALUEHL 
25de cd 92 1b			call macro_dsp_valuehl 
25e1				endm 
# End of macro FORTH_DSP_VALUEHL
25e1 e5					push hl     ; u1 
25e2			 
25e2					FORTH_DSP_POP 
25e2 cd 4a 1c			call macro_forth_dsp_pop 
25e5				endm 
# End of macro FORTH_DSP_POP
25e5			 
25e5 c1					pop bc      ; u1 
25e6 e1					pop hl      ; u2 
25e7 d1					pop de      ; u3 
25e8			 
25e8			 
25e8 c5					push bc 
25e9 d5					push de 
25ea e5					push hl 
25eb			 
25eb			 
25eb e1					pop hl 
25ec cd 9b 19				call forth_push_numhl 
25ef			 
25ef e1					pop hl 
25f0 cd 9b 19				call forth_push_numhl 
25f3			 
25f3 e1					pop hl 
25f4 cd 9b 19				call forth_push_numhl 
25f7					 
25f7			 
25f7			 
25f7			 
25f7			 
25f7			 
25f7				       NEXTW 
25f7 c3 04 1d			jp macro_next 
25fa				endm 
# End of macro NEXTW
25fa			 
25fa			.UWORDS: 
25fa				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
25fa 50				db WORD_SYS_CORE+60             
25fb bc 26			dw .BP            
25fd 07				db 6 + 1 
25fe .. 00			db "UWORDS",0              
2605				endm 
# End of macro CWHEAD
2605			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2605			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2605			; | | Following the count are the individual words. 
2605			; | | 
2605			; | | e.g. UWORDS 
2605			; | | BOX DIRLIST 2 
2605			; | |  
2605			; | | Can be used to save the words to storage via: 
2605			; | | UWORDS $01 DO $01 APPEND LOOP 
2605				if DEBUG_FORTH_WORDS_KEY 
2605					DMARK "UWR" 
2605 f5				push af  
2606 3a 1a 26			ld a, (.dmark)  
2609 32 7a ee			ld (debug_mark),a  
260c 3a 1b 26			ld a, (.dmark+1)  
260f 32 7b ee			ld (debug_mark+1),a  
2612 3a 1c 26			ld a, (.dmark+2)  
2615 32 7c ee			ld (debug_mark+2),a  
2618 18 03			jr .pastdmark  
261a ..			.dmark: db "UWR"  
261d f1			.pastdmark: pop af  
261e			endm  
# End of macro DMARK
261e					CALLMONITOR 
261e cd 0e 14			call break_point_state  
2621				endm  
# End of macro CALLMONITOR
2621				endif 
2621 21 e6 59				ld hl, baseram 
2624					;ld hl, baseusermem 
2624 01 00 00				ld bc, 0    ; start a counter 
2627			 
2627				; skip dict stub 
2627			 
2627 cd 55 1e				call forth_tok_next 
262a			 
262a			 
262a			; while we have words to look for 
262a			 
262a 7e			.douscan:	ld a, (hl)      
262b				if DEBUG_FORTH_WORDS 
262b					DMARK "UWs" 
262b f5				push af  
262c 3a 40 26			ld a, (.dmark)  
262f 32 7a ee			ld (debug_mark),a  
2632 3a 41 26			ld a, (.dmark+1)  
2635 32 7b ee			ld (debug_mark+1),a  
2638 3a 42 26			ld a, (.dmark+2)  
263b 32 7c ee			ld (debug_mark+2),a  
263e 18 03			jr .pastdmark  
2640 ..			.dmark: db "UWs"  
2643 f1			.pastdmark: pop af  
2644			endm  
# End of macro DMARK
2644					CALLMONITOR 
2644 cd 0e 14			call break_point_state  
2647				endm  
# End of macro CALLMONITOR
2647				endif 
2647 fe 00				cp WORD_SYS_END 
2649 28 4d				jr z, .udone 
264b fe 01				cp WORD_SYS_UWORD 
264d 20 44				jr nz, .nuword 
264f			 
264f				if DEBUG_FORTH_WORDS 
264f					DMARK "UWu" 
264f f5				push af  
2650 3a 64 26			ld a, (.dmark)  
2653 32 7a ee			ld (debug_mark),a  
2656 3a 65 26			ld a, (.dmark+1)  
2659 32 7b ee			ld (debug_mark+1),a  
265c 3a 66 26			ld a, (.dmark+2)  
265f 32 7c ee			ld (debug_mark+2),a  
2662 18 03			jr .pastdmark  
2664 ..			.dmark: db "UWu"  
2667 f1			.pastdmark: pop af  
2668			endm  
# End of macro DMARK
2668					CALLMONITOR 
2668 cd 0e 14			call break_point_state  
266b				endm  
# End of macro CALLMONITOR
266b				endif 
266b					; we have a uword so push its name to the stack 
266b			 
266b e5				   	push hl  ; save so we can move to next dict block 
266c			 
266c					; skip opcode 
266c 23					inc hl  
266d					; skip next ptr 
266d 23					inc hl  
266e 23					inc hl 
266f					; skip len 
266f 23					inc hl 
2670				if DEBUG_FORTH_WORDS 
2670					DMARK "UWt" 
2670 f5				push af  
2671 3a 85 26			ld a, (.dmark)  
2674 32 7a ee			ld (debug_mark),a  
2677 3a 86 26			ld a, (.dmark+1)  
267a 32 7b ee			ld (debug_mark+1),a  
267d 3a 87 26			ld a, (.dmark+2)  
2680 32 7c ee			ld (debug_mark+2),a  
2683 18 03			jr .pastdmark  
2685 ..			.dmark: db "UWt"  
2688 f1			.pastdmark: pop af  
2689			endm  
# End of macro DMARK
2689					CALLMONITOR 
2689 cd 0e 14			call break_point_state  
268c				endm  
# End of macro CALLMONITOR
268c				endif 
268c 03					inc bc 
268d			 
268d c5					push bc 
268e cd 09 1a				call forth_push_str 
2691 c1					pop bc 
2692			 
2692 e1					pop hl 	 
2693			 
2693 cd 55 1e		.nuword:	call forth_tok_next 
2696 18 92				jr .douscan  
2698			 
2698			.udone:		 ; push count of uwords found 
2698 c5					push bc 
2699 e1					pop hl 
269a			 
269a				if DEBUG_FORTH_WORDS 
269a					DMARK "UWc" 
269a f5				push af  
269b 3a af 26			ld a, (.dmark)  
269e 32 7a ee			ld (debug_mark),a  
26a1 3a b0 26			ld a, (.dmark+1)  
26a4 32 7b ee			ld (debug_mark+1),a  
26a7 3a b1 26			ld a, (.dmark+2)  
26aa 32 7c ee			ld (debug_mark+2),a  
26ad 18 03			jr .pastdmark  
26af ..			.dmark: db "UWc"  
26b2 f1			.pastdmark: pop af  
26b3			endm  
# End of macro DMARK
26b3					CALLMONITOR 
26b3 cd 0e 14			call break_point_state  
26b6				endm  
# End of macro CALLMONITOR
26b6				endif 
26b6 cd 9b 19				call forth_push_numhl 
26b9			 
26b9			 
26b9				       NEXTW 
26b9 c3 04 1d			jp macro_next 
26bc				endm 
# End of macro NEXTW
26bc			 
26bc			.BP: 
26bc				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
26bc 54				db WORD_SYS_CORE+64             
26bd f2 26			dw .MONITOR            
26bf 03				db 2 + 1 
26c0 .. 00			db "BP",0              
26c3				endm 
# End of macro CWHEAD
26c3			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
26c3			; | | $00 Will enable the break points within specific code paths 
26c3			; | | $01 Will disable break points 
26c3			; | |  
26c3			; | | By default break points are off. Either the above can be used to enable them 
26c3			; | | or if a key is held down during start up the spashscreen will appear to freeze 
26c3			; | | and on release of the pressed key a message will be disaplayed to notify 
26c3			; | | that break points are enabled. Pressing any key will then continue boot process. 
26c3					; get byte count 
26c3					if DEBUG_FORTH_WORDS_KEY 
26c3						DMARK "BP." 
26c3 f5				push af  
26c4 3a d8 26			ld a, (.dmark)  
26c7 32 7a ee			ld (debug_mark),a  
26ca 3a d9 26			ld a, (.dmark+1)  
26cd 32 7b ee			ld (debug_mark+1),a  
26d0 3a da 26			ld a, (.dmark+2)  
26d3 32 7c ee			ld (debug_mark+2),a  
26d6 18 03			jr .pastdmark  
26d8 ..			.dmark: db "BP."  
26db f1			.pastdmark: pop af  
26dc			endm  
# End of macro DMARK
26dc						CALLMONITOR 
26dc cd 0e 14			call break_point_state  
26df				endm  
# End of macro CALLMONITOR
26df					endif 
26df			 
26df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26df cd 92 1b			call macro_dsp_valuehl 
26e2				endm 
# End of macro FORTH_DSP_VALUEHL
26e2			 
26e2			;		push hl 
26e2			 
26e2					; destroy value TOS 
26e2			 
26e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26e2 cd 4a 1c			call macro_forth_dsp_pop 
26e5				endm 
# End of macro FORTH_DSP_POP
26e5			 
26e5			;		pop hl 
26e5			 
26e5 3e 00				ld a,0 
26e7 bd					cp l 
26e8 28 02				jr z, .bpset 
26ea 3e 2a				ld a, '*' 
26ec			 
26ec 32 51 e3		.bpset:		ld (os_view_disable), a 
26ef			 
26ef			 
26ef					NEXTW 
26ef c3 04 1d			jp macro_next 
26f2				endm 
# End of macro NEXTW
26f2			 
26f2			 
26f2			.MONITOR: 
26f2				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
26f2 55				db WORD_SYS_CORE+65             
26f3 25 27			dw .MALLOC            
26f5 08				db 7 + 1 
26f6 .. 00			db "MONITOR",0              
26fe				endm 
# End of macro CWHEAD
26fe			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
26fe			; | | At start the current various registers will be displayed with contents. 
26fe			; | | Top right corner will show the most recent debug marker seen. 
26fe			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
26fe			; | | and the return stack pointer (RSP). 
26fe			; | | Pressing: 
26fe			; | |    1 - Initial screen 
26fe			; | |    2 - Display a data dump of HL 
26fe			; | |    3 - Display a data dump of DE 
26fe			; | |    4 - Display a data dump of BC 
26fe			; | |    5 - Display a data dump of HL 
26fe			; | |    6 - Display a data dump of DSP 
26fe			; | |    7 - Display a data dump of RSP 
26fe			; | |    8 - Display a data dump of what is at DSP 
26fe			; | |    9 - Display a data dump of what is at RSP 
26fe			; | |    0 - Exit monitor and continue running. This will also enable break points 
26fe			; | |    * - Disable break points 
26fe			; | |    # - Enter traditional monitor mode 
26fe			; | | 
26fe			; | | Monitor Mode 
26fe			; | | ------------ 
26fe			; | | A prompt of '>' will be shown for various commands: 
26fe			; | |    D xxxx - Display a data dump starting from hex address xxxx 
26fe			; | |    C - Continue display a data dump from the last set address 
26fe			; | |    M xxxx - Set start of memory edit at address xx 
26fe			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
26fe			; | |    Q - Return to previous 
26fe					if DEBUG_FORTH_WORDS_KEY 
26fe						DMARK "MON" 
26fe f5				push af  
26ff 3a 13 27			ld a, (.dmark)  
2702 32 7a ee			ld (debug_mark),a  
2705 3a 14 27			ld a, (.dmark+1)  
2708 32 7b ee			ld (debug_mark+1),a  
270b 3a 15 27			ld a, (.dmark+2)  
270e 32 7c ee			ld (debug_mark+2),a  
2711 18 03			jr .pastdmark  
2713 ..			.dmark: db "MON"  
2716 f1			.pastdmark: pop af  
2717			endm  
# End of macro DMARK
2717						CALLMONITOR 
2717 cd 0e 14			call break_point_state  
271a				endm  
# End of macro CALLMONITOR
271a					endif 
271a 3e 00				ld a, 0 
271c 32 51 e3				ld (os_view_disable), a 
271f			 
271f					CALLMONITOR 
271f cd 0e 14			call break_point_state  
2722				endm  
# End of macro CALLMONITOR
2722			 
2722			;	call monitor 
2722			 
2722					NEXTW 
2722 c3 04 1d			jp macro_next 
2725				endm 
# End of macro NEXTW
2725			 
2725			 
2725			.MALLOC: 
2725				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2725 56				db WORD_SYS_CORE+66             
2726 4e 27			dw .MALLOC2            
2728 06				db 5 + 1 
2729 .. 00			db "ALLOT",0              
272f				endm 
# End of macro CWHEAD
272f			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
272f					if DEBUG_FORTH_WORDS_KEY 
272f						DMARK "ALL" 
272f f5				push af  
2730 3a 44 27			ld a, (.dmark)  
2733 32 7a ee			ld (debug_mark),a  
2736 3a 45 27			ld a, (.dmark+1)  
2739 32 7b ee			ld (debug_mark+1),a  
273c 3a 46 27			ld a, (.dmark+2)  
273f 32 7c ee			ld (debug_mark+2),a  
2742 18 03			jr .pastdmark  
2744 ..			.dmark: db "ALL"  
2747 f1			.pastdmark: pop af  
2748			endm  
# End of macro DMARK
2748						CALLMONITOR 
2748 cd 0e 14			call break_point_state  
274b				endm  
# End of macro CALLMONITOR
274b					endif 
274b c3 75 27				jp .mallocc 
274e			.MALLOC2: 
274e				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
274e 56				db WORD_SYS_CORE+66             
274f 8c 27			dw .FREE            
2751 07				db 6 + 1 
2752 .. 00			db "MALLOC",0              
2759				endm 
# End of macro CWHEAD
2759			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2759					; get byte count 
2759					if DEBUG_FORTH_WORDS_KEY 
2759						DMARK "MAL" 
2759 f5				push af  
275a 3a 6e 27			ld a, (.dmark)  
275d 32 7a ee			ld (debug_mark),a  
2760 3a 6f 27			ld a, (.dmark+1)  
2763 32 7b ee			ld (debug_mark+1),a  
2766 3a 70 27			ld a, (.dmark+2)  
2769 32 7c ee			ld (debug_mark+2),a  
276c 18 03			jr .pastdmark  
276e ..			.dmark: db "MAL"  
2771 f1			.pastdmark: pop af  
2772			endm  
# End of macro DMARK
2772						CALLMONITOR 
2772 cd 0e 14			call break_point_state  
2775				endm  
# End of macro CALLMONITOR
2775					endif 
2775			.mallocc: 
2775					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2775 cd 92 1b			call macro_dsp_valuehl 
2778				endm 
# End of macro FORTH_DSP_VALUEHL
2778			 
2778			;		push hl 
2778			 
2778					; destroy value TOS 
2778			 
2778					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2778 cd 4a 1c			call macro_forth_dsp_pop 
277b				endm 
# End of macro FORTH_DSP_POP
277b			 
277b			;		pop hl 
277b cd 79 10				call malloc 
277e				if DEBUG_FORTH_MALLOC_GUARD 
277e f5					push af 
277f cd db 0b				call ishlzero 
2782			;		ld a, l 
2782			;		add h 
2782			;		cp 0 
2782 f1					pop af 
2783					 
2783 cc 43 46				call z,malloc_error 
2786				endif 
2786			 
2786 cd 9b 19				call forth_push_numhl 
2789					NEXTW 
2789 c3 04 1d			jp macro_next 
278c				endm 
# End of macro NEXTW
278c			 
278c			.FREE: 
278c				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
278c 57				db WORD_SYS_CORE+67             
278d bd 27			dw .LIST            
278f 05				db 4 + 1 
2790 .. 00			db "FREE",0              
2795				endm 
# End of macro CWHEAD
2795			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2795					if DEBUG_FORTH_WORDS_KEY 
2795						DMARK "FRE" 
2795 f5				push af  
2796 3a aa 27			ld a, (.dmark)  
2799 32 7a ee			ld (debug_mark),a  
279c 3a ab 27			ld a, (.dmark+1)  
279f 32 7b ee			ld (debug_mark+1),a  
27a2 3a ac 27			ld a, (.dmark+2)  
27a5 32 7c ee			ld (debug_mark+2),a  
27a8 18 03			jr .pastdmark  
27aa ..			.dmark: db "FRE"  
27ad f1			.pastdmark: pop af  
27ae			endm  
# End of macro DMARK
27ae						CALLMONITOR 
27ae cd 0e 14			call break_point_state  
27b1				endm  
# End of macro CALLMONITOR
27b1					endif 
27b1					; get address 
27b1			 
27b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27b1 cd 92 1b			call macro_dsp_valuehl 
27b4				endm 
# End of macro FORTH_DSP_VALUEHL
27b4			 
27b4			;		push hl 
27b4			 
27b4					; destroy value TOS 
27b4			 
27b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27b4 cd 4a 1c			call macro_forth_dsp_pop 
27b7				endm 
# End of macro FORTH_DSP_POP
27b7			 
27b7			;		pop hl 
27b7			if FORTH_ENABLE_MALLOCFREE 
27b7 cd 43 11				call free 
27ba			endif 
27ba					NEXTW 
27ba c3 04 1d			jp macro_next 
27bd				endm 
# End of macro NEXTW
27bd			.LIST: 
27bd				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
27bd 5c				db WORD_SYS_CORE+72             
27be 80 29			dw .FORGET            
27c0 05				db 4 + 1 
27c1 .. 00			db "LIST",0              
27c6				endm 
# End of macro CWHEAD
27c6			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
27c6			; | | The quoted word must be in upper case. 
27c6				if DEBUG_FORTH_WORDS_KEY 
27c6					DMARK "LST" 
27c6 f5				push af  
27c7 3a db 27			ld a, (.dmark)  
27ca 32 7a ee			ld (debug_mark),a  
27cd 3a dc 27			ld a, (.dmark+1)  
27d0 32 7b ee			ld (debug_mark+1),a  
27d3 3a dd 27			ld a, (.dmark+2)  
27d6 32 7c ee			ld (debug_mark+2),a  
27d9 18 03			jr .pastdmark  
27db ..			.dmark: db "LST"  
27de f1			.pastdmark: pop af  
27df			endm  
# End of macro DMARK
27df					CALLMONITOR 
27df cd 0e 14			call break_point_state  
27e2				endm  
# End of macro CALLMONITOR
27e2				endif 
27e2			 
27e2					FORTH_DSP_VALUEHL 
27e2 cd 92 1b			call macro_dsp_valuehl 
27e5				endm 
# End of macro FORTH_DSP_VALUEHL
27e5			 
27e5 e5					push hl 
27e6 c1					pop bc 
27e7			 
27e7			; Start format of scratch string 
27e7			 
27e7 21 60 e3				ld hl, scratch 
27ea			 
27ea 3e 3a				ld a, ':' 
27ec 77					ld (hl),a 
27ed 23					inc hl 
27ee 3e 20				ld a, ' ' 
27f0 77					ld (hl), a 
27f1			 
27f1					; Get ptr to the word we need to look up 
27f1			 
27f1			;		FORTH_DSP_VALUEHL 
27f1					;v5 FORTH_DSP_VALUE 
27f1				; TODO type check 
27f1			;		inc hl    ; Skip type check  
27f1			;		push hl 
27f1			;		ex de, hl    ; put into DE 
27f1			 
27f1			 
27f1 21 e6 59				ld hl, baseram 
27f4					;ld hl, baseusermem 
27f4			 
27f4 e5			push hl   ; sacreifical push 
27f5			 
27f5			.ldouscanm: 
27f5 e1				pop hl 
27f6			.ldouscan: 
27f6				if DEBUG_FORTH_WORDS 
27f6					DMARK "LSs" 
27f6 f5				push af  
27f7 3a 0b 28			ld a, (.dmark)  
27fa 32 7a ee			ld (debug_mark),a  
27fd 3a 0c 28			ld a, (.dmark+1)  
2800 32 7b ee			ld (debug_mark+1),a  
2803 3a 0d 28			ld a, (.dmark+2)  
2806 32 7c ee			ld (debug_mark+2),a  
2809 18 03			jr .pastdmark  
280b ..			.dmark: db "LSs"  
280e f1			.pastdmark: pop af  
280f			endm  
# End of macro DMARK
280f					CALLMONITOR 
280f cd 0e 14			call break_point_state  
2812				endm  
# End of macro CALLMONITOR
2812				endif 
2812				; skip dict stub 
2812 cd 55 1e				call forth_tok_next 
2815			 
2815			 
2815			; while we have words to look for 
2815			 
2815 7e				ld a, (hl)      
2816				if DEBUG_FORTH_WORDS 
2816					DMARK "LSk" 
2816 f5				push af  
2817 3a 2b 28			ld a, (.dmark)  
281a 32 7a ee			ld (debug_mark),a  
281d 3a 2c 28			ld a, (.dmark+1)  
2820 32 7b ee			ld (debug_mark+1),a  
2823 3a 2d 28			ld a, (.dmark+2)  
2826 32 7c ee			ld (debug_mark+2),a  
2829 18 03			jr .pastdmark  
282b ..			.dmark: db "LSk"  
282e f1			.pastdmark: pop af  
282f			endm  
# End of macro DMARK
282f					CALLMONITOR 
282f cd 0e 14			call break_point_state  
2832				endm  
# End of macro CALLMONITOR
2832				endif 
2832 fe 00				cp WORD_SYS_END 
2834 ca 67 29				jp z, .lunotfound 
2837 fe 01				cp WORD_SYS_UWORD 
2839 c2 f6 27				jp nz, .ldouscan 
283c			 
283c				if DEBUG_FORTH_WORDS 
283c					DMARK "LSu" 
283c f5				push af  
283d 3a 51 28			ld a, (.dmark)  
2840 32 7a ee			ld (debug_mark),a  
2843 3a 52 28			ld a, (.dmark+1)  
2846 32 7b ee			ld (debug_mark+1),a  
2849 3a 53 28			ld a, (.dmark+2)  
284c 32 7c ee			ld (debug_mark+2),a  
284f 18 03			jr .pastdmark  
2851 ..			.dmark: db "LSu"  
2854 f1			.pastdmark: pop af  
2855			endm  
# End of macro DMARK
2855					CALLMONITOR 
2855 cd 0e 14			call break_point_state  
2858				endm  
# End of macro CALLMONITOR
2858				endif 
2858			 
2858					; found a uword but is it the one we want... 
2858			 
2858 c5					push bc     ; uword to find is on bc 
2859 d1					pop de 
285a			 
285a e5					push hl  ; to save the ptr 
285b			 
285b					; skip opcode 
285b 23					inc hl  
285c					; skip next ptr 
285c 23					inc hl  
285d 23					inc hl 
285e					; skip len 
285e 23					inc hl 
285f			 
285f				if DEBUG_FORTH_WORDS 
285f					DMARK "LSc" 
285f f5				push af  
2860 3a 74 28			ld a, (.dmark)  
2863 32 7a ee			ld (debug_mark),a  
2866 3a 75 28			ld a, (.dmark+1)  
2869 32 7b ee			ld (debug_mark+1),a  
286c 3a 76 28			ld a, (.dmark+2)  
286f 32 7c ee			ld (debug_mark+2),a  
2872 18 03			jr .pastdmark  
2874 ..			.dmark: db "LSc"  
2877 f1			.pastdmark: pop af  
2878			endm  
# End of macro DMARK
2878					CALLMONITOR 
2878 cd 0e 14			call break_point_state  
287b				endm  
# End of macro CALLMONITOR
287b				endif 
287b cd 48 10				call strcmp 
287e c2 f5 27				jp nz, .ldouscanm 
2881				 
2881			 
2881			 
2881					; we have a uword so push its name to the stack 
2881			 
2881			;	   	push hl  ; save so we can move to next dict block 
2881 e1			pop hl 
2882			 
2882				if DEBUG_FORTH_WORDS 
2882					DMARK "LSm" 
2882 f5				push af  
2883 3a 97 28			ld a, (.dmark)  
2886 32 7a ee			ld (debug_mark),a  
2889 3a 98 28			ld a, (.dmark+1)  
288c 32 7b ee			ld (debug_mark+1),a  
288f 3a 99 28			ld a, (.dmark+2)  
2892 32 7c ee			ld (debug_mark+2),a  
2895 18 03			jr .pastdmark  
2897 ..			.dmark: db "LSm"  
289a f1			.pastdmark: pop af  
289b			endm  
# End of macro DMARK
289b					CALLMONITOR 
289b cd 0e 14			call break_point_state  
289e				endm  
# End of macro CALLMONITOR
289e				endif 
289e			 
289e					; skip opcode 
289e 23					inc hl  
289f					; skip next ptr 
289f 23					inc hl  
28a0 23					inc hl 
28a1					; skip len 
28a1 7e					ld a, (hl)   ; save length to add 
28a2				if DEBUG_FORTH_WORDS 
28a2					DMARK "LS2" 
28a2 f5				push af  
28a3 3a b7 28			ld a, (.dmark)  
28a6 32 7a ee			ld (debug_mark),a  
28a9 3a b8 28			ld a, (.dmark+1)  
28ac 32 7b ee			ld (debug_mark+1),a  
28af 3a b9 28			ld a, (.dmark+2)  
28b2 32 7c ee			ld (debug_mark+2),a  
28b5 18 03			jr .pastdmark  
28b7 ..			.dmark: db "LS2"  
28ba f1			.pastdmark: pop af  
28bb			endm  
# End of macro DMARK
28bb					CALLMONITOR 
28bb cd 0e 14			call break_point_state  
28be				endm  
# End of macro CALLMONITOR
28be				endif 
28be			 
28be					; save this location 
28be				 
28be e5					push hl 
28bf			 
28bf 23					inc hl 
28c0 11 62 e3				ld de, scratch+2 
28c3 4f					ld c, a 
28c4 06 00				ld b, 0 
28c6			 
28c6				if DEBUG_FORTH_WORDS 
28c6					DMARK "LSn" 
28c6 f5				push af  
28c7 3a db 28			ld a, (.dmark)  
28ca 32 7a ee			ld (debug_mark),a  
28cd 3a dc 28			ld a, (.dmark+1)  
28d0 32 7b ee			ld (debug_mark+1),a  
28d3 3a dd 28			ld a, (.dmark+2)  
28d6 32 7c ee			ld (debug_mark+2),a  
28d9 18 03			jr .pastdmark  
28db ..			.dmark: db "LSn"  
28de f1			.pastdmark: pop af  
28df			endm  
# End of macro DMARK
28df					CALLMONITOR 
28df cd 0e 14			call break_point_state  
28e2				endm  
# End of macro CALLMONITOR
28e2				endif 
28e2			 
28e2					; copy uword name to scratch 
28e2			 
28e2 ed b0				ldir 
28e4			 
28e4 1b					dec de 
28e5 3e 20				ld a, ' '    ; change null to space 
28e7 12					ld (de), a 
28e8			 
28e8 13					inc de 
28e9			 
28e9 d5					push de 
28ea c1					pop bc     ; move scratch pointer to end of word name and save it 
28eb			 
28eb e1					pop hl 
28ec 7e					ld a, (hl) 
28ed					;inc hl 
28ed					; skip word string 
28ed cd b2 0b				call addatohl 
28f0			 
28f0 23					inc hl 
28f1			 
28f1				if DEBUG_FORTH_WORDS 
28f1					DMARK "LS3" 
28f1 f5				push af  
28f2 3a 06 29			ld a, (.dmark)  
28f5 32 7a ee			ld (debug_mark),a  
28f8 3a 07 29			ld a, (.dmark+1)  
28fb 32 7b ee			ld (debug_mark+1),a  
28fe 3a 08 29			ld a, (.dmark+2)  
2901 32 7c ee			ld (debug_mark+2),a  
2904 18 03			jr .pastdmark  
2906 ..			.dmark: db "LS3"  
2909 f1			.pastdmark: pop af  
290a			endm  
# End of macro DMARK
290a					CALLMONITOR 
290a cd 0e 14			call break_point_state  
290d				endm  
# End of macro CALLMONITOR
290d				endif 
290d					; should now be at the start of the machine code to setup the eval of the uword 
290d					; now locate the ptr to the string defintion 
290d			 
290d					; skip ld hl, 
290d					; then load the ptr 
290d			 
290d 23					inc hl 
290e 5e					ld e, (hl) 
290f 23					inc hl 
2910 56					ld d, (hl) 
2911 eb					ex de, hl 
2912			 
2912			 
2912				if DEBUG_FORTH_WORDS 
2912					DMARK "LSt" 
2912 f5				push af  
2913 3a 27 29			ld a, (.dmark)  
2916 32 7a ee			ld (debug_mark),a  
2919 3a 28 29			ld a, (.dmark+1)  
291c 32 7b ee			ld (debug_mark+1),a  
291f 3a 29 29			ld a, (.dmark+2)  
2922 32 7c ee			ld (debug_mark+2),a  
2925 18 03			jr .pastdmark  
2927 ..			.dmark: db "LSt"  
292a f1			.pastdmark: pop af  
292b			endm  
# End of macro DMARK
292b					CALLMONITOR 
292b cd 0e 14			call break_point_state  
292e				endm  
# End of macro CALLMONITOR
292e				endif 
292e			 
292e			; cant push right now due to tokenised strings  
292e			 
292e			; get the destination of where to copy this definition to. 
292e			 
292e c5					push bc 
292f d1					pop de 
2930			 
2930 7e			.listl:         ld a,(hl) 
2931 fe 00				cp 0 
2933 28 09				jr z, .lreplsp     ; replace zero with space 
2935 fe 7f				cp FORTH_END_BUFFER 
2937 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2939				 
2939					; just copy this char as is then 
2939			 
2939 12					ld (de), a 
293a			 
293a 23			.listnxt:	inc hl 
293b 13					inc de 
293c 18 f2				jr .listl 
293e			 
293e 3e 20		.lreplsp:	ld a,' ' 
2940 12					ld (de), a 
2941 18 f7				jr .listnxt 
2943			 
2943			; close up uword def 
2943			 
2943			.listdone: 
2943 3e 00				ld a, 0 
2945 12					ld (de), a 
2946			 
2946			; now have def so clean up and push to stack 
2946			 
2946 21 60 e3				ld hl, scratch 
2949				if DEBUG_FORTH_WORDS 
2949					DMARK "Ltp" 
2949 f5				push af  
294a 3a 5e 29			ld a, (.dmark)  
294d 32 7a ee			ld (debug_mark),a  
2950 3a 5f 29			ld a, (.dmark+1)  
2953 32 7b ee			ld (debug_mark+1),a  
2956 3a 60 29			ld a, (.dmark+2)  
2959 32 7c ee			ld (debug_mark+2),a  
295c 18 03			jr .pastdmark  
295e ..			.dmark: db "Ltp"  
2961 f1			.pastdmark: pop af  
2962			endm  
# End of macro DMARK
2962					CALLMONITOR 
2962 cd 0e 14			call break_point_state  
2965				endm  
# End of macro CALLMONITOR
2965				endif 
2965			 
2965 18 06			jr .listpush 
2967			 
2967			;.lnuword:	pop hl 
2967			;		call forth_tok_next 
2967			;		jp .ldouscan  
2967			 
2967			.lunotfound:		  
2967			 
2967			 
2967					 
2967					FORTH_DSP_POP 
2967 cd 4a 1c			call macro_forth_dsp_pop 
296a				endm 
# End of macro FORTH_DSP_POP
296a 21 73 29				ld hl, .luno 
296d						 
296d			 
296d			.listpush: 
296d cd 09 1a				call forth_push_str 
2970			 
2970			 
2970			 
2970					NEXTW 
2970 c3 04 1d			jp macro_next 
2973				endm 
# End of macro NEXTW
2973			 
2973 .. 00		.luno:    db "Not found",0 
297d			 
297d			 
297d			 
297d			 
297d			 
297d			;		push hl   ; save pointer to start of uword def string 
297d			; 
297d			;; look for FORTH_EOL_LINE 
297d			;		ld a, FORTH_END_BUFFER 
297d			;		call strlent 
297d			; 
297d			;		inc hl		 ; space for coln def 
297d			;		inc hl 
297d			;		inc hl          ; space for terms 
297d			;		inc hl 
297d			; 
297d			;		ld a, 20   ; TODO get actual length 
297d			;		call addatohl    ; include a random amount of room for the uword name 
297d			; 
297d			;		 
297d			;	if DEBUG_FORTH_WORDS 
297d			;		DMARK "Lt1" 
297d			;		CALLMONITOR 
297d			;	endif 
297d			;		 
297d			; 
297d			;; malloc space for the string because we cant change it 
297d			; 
297d			;		call malloc 
297d			;	if DEBUG_FORTH_MALLOC_GUARD 
297d			;		push af 
297d			;		call ishlzero 
297d			;		pop af 
297d			;		 
297d			;		call z,malloc_error 
297d			;	endif 
297d			; 
297d			;	if DEBUG_FORTH_WORDS 
297d			;		DMARK "Lt2" 
297d			;		CALLMONITOR 
297d			;	endif 
297d			;		pop de 
297d			;		push hl    ; push the malloc to release later 
297d			;		push hl   ;  push back a copy for the later stack push 
297d			;		 
297d			;; copy the string swapping out the zero terms for spaces 
297d			; 
297d			;		; de has our source 
297d			;		; hl has our dest 
297d			; 
297d			;; add the coln def 
297d			; 
297d			;		ld a, ':' 
297d			;		ld (hl), a 
297d			;		inc hl 
297d			;		ld a, ' ' 
297d			;		ld (hl), a 
297d			;		inc hl 
297d			; 
297d			;; add the uname word 
297d			;		push de   ; save our string for now 
297d			;		ex de, hl 
297d			; 
297d			;		FORTH_DSP_VALUE 
297d			;		;v5 FORTH_DSP_VALUE 
297d			; 
297d			;		inc hl   ; skip type but we know by now this is OK 
297d			; 
297d			;.luword:	ld a,(hl) 
297d			;		cp 0 
297d			;		jr z, .luword2 
297d			;		ld (de), a 
297d			;		inc de 
297d			;		inc hl 
297d			;		jr .luword 
297d			; 
297d			;.luword2:	ld a, ' ' 
297d			;		ld (de), a 
297d			;;		inc hl 
297d			;;		inc de 
297d			;;		ld (de), a 
297d			;;		inc hl 
297d			;		inc de 
297d			; 
297d			;		ex de, hl 
297d			;		pop de 
297d			;		 
297d			;		 
297d			; 
297d			;; detoken that string and copy it 
297d			; 
297d			;	if DEBUG_FORTH_WORDS 
297d			;		DMARK "Lt2" 
297d			;		CALLMONITOR 
297d			;	endif 
297d			;.ldetok:	ld a, (de) 
297d			;		cp FORTH_END_BUFFER 
297d			;		jr z, .ldetokend 
297d			;		; swap out any zero term for space 
297d			;		cp 0 
297d			;		jr nz, .ldetoknext 
297d			;		ld a, ' ' 
297d			; 
297d			;	if DEBUG_FORTH_WORDS 
297d			;		DMARK "LtS" 
297d			;		CALLMONITOR 
297d			;	endif 
297d			;.ldetoknext:	ld (hl), a 
297d			;		inc de 
297d			;		inc hl 
297d			;		jr .ldetok 
297d			; 
297d			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
297d			;		ld (hl), a  
297d			; 
297d			;; free that temp malloc 
297d			; 
297d			;		pop hl    
297d			; 
297d			;	if DEBUG_FORTH_WORDS 
297d			;		DMARK "Lt4" 
297d			;		CALLMONITOR 
297d			;	endif 
297d			;		call forth_apushstrhl 
297d			; 
297d			;		; get rid of temp malloc area 
297d			; 
297d			;		pop hl 
297d			;		call free 
297d			; 
297d			;		jr .ludone 
297d			; 
297d			;.lnuword:	pop hl 
297d			;		call forth_tok_next 
297d			;		jp .ldouscan  
297d			; 
297d			;.ludone:		 pop hl 
297d			; 
297d					NEXTW 
297d c3 04 1d			jp macro_next 
2980				endm 
# End of macro NEXTW
2980			 
2980			.FORGET: 
2980				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2980 5d				db WORD_SYS_CORE+73             
2981 f9 29			dw .NOP            
2983 07				db 6 + 1 
2984 .. 00			db "FORGET",0              
298b				endm 
# End of macro CWHEAD
298b			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
298b			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
298b			; | |  
298b			; | | e.g. "MORE" forget 
298b					if DEBUG_FORTH_WORDS_KEY 
298b						DMARK "FRG" 
298b f5				push af  
298c 3a a0 29			ld a, (.dmark)  
298f 32 7a ee			ld (debug_mark),a  
2992 3a a1 29			ld a, (.dmark+1)  
2995 32 7b ee			ld (debug_mark+1),a  
2998 3a a2 29			ld a, (.dmark+2)  
299b 32 7c ee			ld (debug_mark+2),a  
299e 18 03			jr .pastdmark  
29a0 ..			.dmark: db "FRG"  
29a3 f1			.pastdmark: pop af  
29a4			endm  
# End of macro DMARK
29a4						CALLMONITOR 
29a4 cd 0e 14			call break_point_state  
29a7				endm  
# End of macro CALLMONITOR
29a7					endif 
29a7			 
29a7				; find uword 
29a7			        ; update start of word with "_" 
29a7				; replace uword with deleted flag 
29a7			 
29a7			 
29a7			;	if DEBUG_FORTH_WORDS 
29a7			;		DMARK "FOG" 
29a7			;		CALLMONITOR 
29a7			;	endif 
29a7			 
29a7			 
29a7					; Get ptr to the word we need to look up 
29a7			 
29a7					FORTH_DSP_VALUEHL 
29a7 cd 92 1b			call macro_dsp_valuehl 
29aa				endm 
# End of macro FORTH_DSP_VALUEHL
29aa					;v5 FORTH_DSP_VALUE 
29aa				; TODO type check 
29aa			;		inc hl    ; Skip type check  
29aa e5					push hl 
29ab c1					pop bc 
29ac			;		ex de, hl    ; put into DE 
29ac			 
29ac			 
29ac 21 e6 59				ld hl, baseram 
29af					;ld hl, baseusermem 
29af			 
29af				; skip dict stub 
29af			;	call forth_tok_next 
29af e5			push hl   ; sacreifical push 
29b0			 
29b0			.fldouscanm: 
29b0 e1				pop hl 
29b1			.fldouscan: 
29b1			;	if DEBUG_FORTH_WORDS 
29b1			;		DMARK "LSs" 
29b1			;		CALLMONITOR 
29b1			;	endif 
29b1				; skip dict stub 
29b1 cd 55 1e				call forth_tok_next 
29b4			 
29b4			 
29b4			; while we have words to look for 
29b4			 
29b4 7e				ld a, (hl)      
29b5			;	if DEBUG_FORTH_WORDS 
29b5			;		DMARK "LSk" 
29b5			;		CALLMONITOR 
29b5			;	endif 
29b5 fe 00				cp WORD_SYS_END 
29b7 ca f3 29				jp z, .flunotfound 
29ba fe 01				cp WORD_SYS_UWORD 
29bc c2 b1 29				jp nz, .fldouscan 
29bf			 
29bf			;	if DEBUG_FORTH_WORDS 
29bf			;		DMARK "LSu" 
29bf			;		CALLMONITOR 
29bf			;	endif 
29bf			 
29bf					; found a uword but is it the one we want... 
29bf			 
29bf c5					push bc     ; uword to find is on bc 
29c0 d1					pop de 
29c1			 
29c1 e5					push hl  ; to save the ptr 
29c2			 
29c2					; skip opcode 
29c2 23					inc hl  
29c3					; skip next ptr 
29c3 23					inc hl  
29c4 23					inc hl 
29c5					; skip len 
29c5 23					inc hl 
29c6			 
29c6			;	if DEBUG_FORTH_WORDS 
29c6			;		DMARK "LSc" 
29c6			;		CALLMONITOR 
29c6			;	endif 
29c6 cd 48 10				call strcmp 
29c9 c2 b0 29				jp nz, .fldouscanm 
29cc			; 
29cc			; 
29cc			;; while we have words to look for 
29cc			; 
29cc			;.fdouscan:	ld a, (hl)      
29cc			;	if DEBUG_FORTH_WORDS 
29cc			;		DMARK "LSs" 
29cc			;		CALLMONITOR 
29cc			;	endif 
29cc			;		cp WORD_SYS_END 
29cc			;		jp z, .fudone 
29cc			;		cp WORD_SYS_UWORD 
29cc			;		jp nz, .fnuword 
29cc			; 
29cc			;	if DEBUG_FORTH_WORDS 
29cc			;		DMARK "FGu" 
29cc			;		CALLMONITOR 
29cc			;	endif 
29cc			; 
29cc			;		; found a uword but is it the one we want... 
29cc			; 
29cc			; 
29cc			;	        pop de   ; get back the dsp name 
29cc			;		push de 
29cc			; 
29cc			;		push hl  ; to save the ptr 
29cc			; 
29cc			;		; skip opcode 
29cc			;		inc hl  
29cc			;		; skip next ptr 
29cc			;		inc hl  
29cc			;		inc hl 
29cc			;		; skip len 
29cc			;		inc hl 
29cc			; 
29cc			;	if DEBUG_FORTH_WORDS 
29cc			;		DMARK "FGc" 
29cc			;		CALLMONITOR 
29cc			;	endif 
29cc			;		call strcmp 
29cc			;		jp nz, .fnuword 
29cc			 
29cc			 
29cc e1			pop hl 
29cd			 
29cd				 
29cd				if DEBUG_FORTH_WORDS 
29cd					DMARK "FGm" 
29cd f5				push af  
29ce 3a e2 29			ld a, (.dmark)  
29d1 32 7a ee			ld (debug_mark),a  
29d4 3a e3 29			ld a, (.dmark+1)  
29d7 32 7b ee			ld (debug_mark+1),a  
29da 3a e4 29			ld a, (.dmark+2)  
29dd 32 7c ee			ld (debug_mark+2),a  
29e0 18 03			jr .pastdmark  
29e2 ..			.dmark: db "FGm"  
29e5 f1			.pastdmark: pop af  
29e6			endm  
# End of macro DMARK
29e6					CALLMONITOR 
29e6 cd 0e 14			call break_point_state  
29e9				endm  
# End of macro CALLMONITOR
29e9				endif 
29e9			 
29e9			 
29e9			 
29e9					; we have a uword so push its name to the stack 
29e9			 
29e9			;	   	push hl  ; save so we can move to next dict block 
29e9			;pop hl 
29e9			 
29e9					; update opcode to deleted 
29e9 3e 03				ld a, WORD_SYS_DELETED 
29eb 77					ld (hl), a 
29ec			 
29ec 23					inc hl  
29ed					; skip next ptr 
29ed 23					inc hl  
29ee 23					inc hl 
29ef					; skip len 
29ef 23					inc hl 
29f0			 
29f0					; TODO change parser to skip deleted words but for now mark it out 
29f0 3e 5f				ld a, "_" 
29f2 77					ld  (hl),a 
29f3			 
29f3			;		jr .fudone 
29f3			; 
29f3			;.fnuword:	pop hl 
29f3			;		call forth_tok_next 
29f3			;		jp .fdouscan  
29f3			 
29f3			.flunotfound:		  
29f3			 
29f3			 
29f3					 
29f3					FORTH_DSP_POP 
29f3 cd 4a 1c			call macro_forth_dsp_pop 
29f6				endm 
# End of macro FORTH_DSP_POP
29f6			;		ld hl, .luno 
29f6			;.fudone:		 pop hl 
29f6					NEXTW 
29f6 c3 04 1d			jp macro_next 
29f9				endm 
# End of macro NEXTW
29f9			.NOP: 
29f9				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
29f9 61				db WORD_SYS_CORE+77             
29fa 20 2a			dw .COMO            
29fc 04				db 3 + 1 
29fd .. 00			db "NOP",0              
2a01				endm 
# End of macro CWHEAD
2a01			; | NOP (  --  ) Do nothing | DONE 
2a01					if DEBUG_FORTH_WORDS_KEY 
2a01						DMARK "NOP" 
2a01 f5				push af  
2a02 3a 16 2a			ld a, (.dmark)  
2a05 32 7a ee			ld (debug_mark),a  
2a08 3a 17 2a			ld a, (.dmark+1)  
2a0b 32 7b ee			ld (debug_mark+1),a  
2a0e 3a 18 2a			ld a, (.dmark+2)  
2a11 32 7c ee			ld (debug_mark+2),a  
2a14 18 03			jr .pastdmark  
2a16 ..			.dmark: db "NOP"  
2a19 f1			.pastdmark: pop af  
2a1a			endm  
# End of macro DMARK
2a1a						CALLMONITOR 
2a1a cd 0e 14			call break_point_state  
2a1d				endm  
# End of macro CALLMONITOR
2a1d					endif 
2a1d				       NEXTW 
2a1d c3 04 1d			jp macro_next 
2a20				endm 
# End of macro NEXTW
2a20			.COMO: 
2a20				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2a20 6e				db WORD_SYS_CORE+90             
2a21 72 2a			dw .COMC            
2a23 02				db 1 + 1 
2a24 .. 00			db "(",0              
2a26				endm 
# End of macro CWHEAD
2a26			; | ( ( -- )  Start of comment | DONE 
2a26			 
2a26			 
2a26 2a 61 e6				ld hl, ( os_tok_ptr) 
2a29 11 6d 2a			ld de, .closepar 
2a2c					 
2a2c					if DEBUG_FORTH_WORDS 
2a2c						DMARK ").." 
2a2c f5				push af  
2a2d 3a 41 2a			ld a, (.dmark)  
2a30 32 7a ee			ld (debug_mark),a  
2a33 3a 42 2a			ld a, (.dmark+1)  
2a36 32 7b ee			ld (debug_mark+1),a  
2a39 3a 43 2a			ld a, (.dmark+2)  
2a3c 32 7c ee			ld (debug_mark+2),a  
2a3f 18 03			jr .pastdmark  
2a41 ..			.dmark: db ").."  
2a44 f1			.pastdmark: pop af  
2a45			endm  
# End of macro DMARK
2a45						CALLMONITOR 
2a45 cd 0e 14			call break_point_state  
2a48				endm  
# End of macro CALLMONITOR
2a48					endif 
2a48 cd 1f 1e			call findnexttok  
2a4b			 
2a4b					if DEBUG_FORTH_WORDS 
2a4b						DMARK "IF5" 
2a4b f5				push af  
2a4c 3a 60 2a			ld a, (.dmark)  
2a4f 32 7a ee			ld (debug_mark),a  
2a52 3a 61 2a			ld a, (.dmark+1)  
2a55 32 7b ee			ld (debug_mark+1),a  
2a58 3a 62 2a			ld a, (.dmark+2)  
2a5b 32 7c ee			ld (debug_mark+2),a  
2a5e 18 03			jr .pastdmark  
2a60 ..			.dmark: db "IF5"  
2a63 f1			.pastdmark: pop af  
2a64			endm  
# End of macro DMARK
2a64						CALLMONITOR 
2a64 cd 0e 14			call break_point_state  
2a67				endm  
# End of macro CALLMONITOR
2a67					endif 
2a67				; replace below with ) exec using tok_ptr 
2a67 22 61 e6			ld (os_tok_ptr), hl 
2a6a c3 95 1d			jp exec1 
2a6d			 
2a6d .. 00			.closepar:   db ")",0 
2a6f			 
2a6f				       NEXTW 
2a6f c3 04 1d			jp macro_next 
2a72				endm 
# End of macro NEXTW
2a72			.COMC: 
2a72				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2a72 6f				db WORD_SYS_CORE+91             
2a73 7b 2a			dw .SCRATCH            
2a75 02				db 1 + 1 
2a76 .. 00			db ")",0              
2a78				endm 
# End of macro CWHEAD
2a78			; | ) ( -- )  End of comment |  DONE  
2a78				       NEXTW 
2a78 c3 04 1d			jp macro_next 
2a7b				endm 
# End of macro NEXTW
2a7b			 
2a7b			.SCRATCH: 
2a7b				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2a7b 6f				db WORD_SYS_CORE+91             
2a7c b6 2a			dw .INC            
2a7e 08				db 7 + 1 
2a7f .. 00			db "SCRATCH",0              
2a87				endm 
# End of macro CWHEAD
2a87			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2a87			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2a87			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2a87			; | |  
2a87			; | | e.g.    : score $00 scratch ; 
2a87			; | |  
2a87			; | | $00 score ! 
2a87			; | | $01 score +! 
2a87			; | |  
2a87			; | | e.g.   : varword $0a scratch ;  
2a87			; | | 
2a87			; | | $8000 varword ! 
2a87					if DEBUG_FORTH_WORDS_KEY 
2a87						DMARK "SCR" 
2a87 f5				push af  
2a88 3a 9c 2a			ld a, (.dmark)  
2a8b 32 7a ee			ld (debug_mark),a  
2a8e 3a 9d 2a			ld a, (.dmark+1)  
2a91 32 7b ee			ld (debug_mark+1),a  
2a94 3a 9e 2a			ld a, (.dmark+2)  
2a97 32 7c ee			ld (debug_mark+2),a  
2a9a 18 03			jr .pastdmark  
2a9c ..			.dmark: db "SCR"  
2a9f f1			.pastdmark: pop af  
2aa0			endm  
# End of macro DMARK
2aa0						CALLMONITOR 
2aa0 cd 0e 14			call break_point_state  
2aa3				endm  
# End of macro CALLMONITOR
2aa3					endif 
2aa3			 
2aa3					FORTH_DSP_VALUEHL 
2aa3 cd 92 1b			call macro_dsp_valuehl 
2aa6				endm 
# End of macro FORTH_DSP_VALUEHL
2aa6				 
2aa6					FORTH_DSP_POP 
2aa6 cd 4a 1c			call macro_forth_dsp_pop 
2aa9				endm 
# End of macro FORTH_DSP_POP
2aa9			 
2aa9 7d					ld a, l 
2aaa 21 85 e8				ld hl, os_var_array 
2aad cd b2 0b				call addatohl 
2ab0			 
2ab0 cd 9b 19				call forth_push_numhl 
2ab3			 
2ab3				       NEXTW 
2ab3 c3 04 1d			jp macro_next 
2ab6				endm 
# End of macro NEXTW
2ab6			 
2ab6			.INC: 
2ab6				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2ab6 6f				db WORD_SYS_CORE+91             
2ab7 0a 2b			dw .DEC            
2ab9 03				db 2 + 1 
2aba .. 00			db "+!",0              
2abd				endm 
# End of macro CWHEAD
2abd			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2abd					if DEBUG_FORTH_WORDS_KEY 
2abd						DMARK "+s_" 
2abd f5				push af  
2abe 3a d2 2a			ld a, (.dmark)  
2ac1 32 7a ee			ld (debug_mark),a  
2ac4 3a d3 2a			ld a, (.dmark+1)  
2ac7 32 7b ee			ld (debug_mark+1),a  
2aca 3a d4 2a			ld a, (.dmark+2)  
2acd 32 7c ee			ld (debug_mark+2),a  
2ad0 18 03			jr .pastdmark  
2ad2 ..			.dmark: db "+s_"  
2ad5 f1			.pastdmark: pop af  
2ad6			endm  
# End of macro DMARK
2ad6						CALLMONITOR 
2ad6 cd 0e 14			call break_point_state  
2ad9				endm  
# End of macro CALLMONITOR
2ad9					endif 
2ad9			 
2ad9					FORTH_DSP_VALUEHL 
2ad9 cd 92 1b			call macro_dsp_valuehl 
2adc				endm 
# End of macro FORTH_DSP_VALUEHL
2adc			 
2adc e5					push hl   ; save address 
2add			 
2add					FORTH_DSP_POP 
2add cd 4a 1c			call macro_forth_dsp_pop 
2ae0				endm 
# End of macro FORTH_DSP_POP
2ae0			 
2ae0					FORTH_DSP_VALUEHL 
2ae0 cd 92 1b			call macro_dsp_valuehl 
2ae3				endm 
# End of macro FORTH_DSP_VALUEHL
2ae3			 
2ae3					FORTH_DSP_POP 
2ae3 cd 4a 1c			call macro_forth_dsp_pop 
2ae6				endm 
# End of macro FORTH_DSP_POP
2ae6			 
2ae6					; hl contains value to add to byte at a 
2ae6				 
2ae6 eb					ex de, hl 
2ae7			 
2ae7 e1					pop hl 
2ae8			 
2ae8					if DEBUG_FORTH_WORDS 
2ae8						DMARK "INC" 
2ae8 f5				push af  
2ae9 3a fd 2a			ld a, (.dmark)  
2aec 32 7a ee			ld (debug_mark),a  
2aef 3a fe 2a			ld a, (.dmark+1)  
2af2 32 7b ee			ld (debug_mark+1),a  
2af5 3a ff 2a			ld a, (.dmark+2)  
2af8 32 7c ee			ld (debug_mark+2),a  
2afb 18 03			jr .pastdmark  
2afd ..			.dmark: db "INC"  
2b00 f1			.pastdmark: pop af  
2b01			endm  
# End of macro DMARK
2b01						CALLMONITOR 
2b01 cd 0e 14			call break_point_state  
2b04				endm  
# End of macro CALLMONITOR
2b04					endif 
2b04			 
2b04 7e					ld a,(hl) 
2b05 83					add e 
2b06 77					ld (hl),a 
2b07			 
2b07			 
2b07			 
2b07				       NEXTW 
2b07 c3 04 1d			jp macro_next 
2b0a				endm 
# End of macro NEXTW
2b0a			 
2b0a			.DEC: 
2b0a				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2b0a 6f				db WORD_SYS_CORE+91             
2b0b 5b 2b			dw .INC2            
2b0d 03				db 2 + 1 
2b0e .. 00			db "-!",0              
2b11				endm 
# End of macro CWHEAD
2b11			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2b11					if DEBUG_FORTH_WORDS_KEY 
2b11						DMARK "-s_" 
2b11 f5				push af  
2b12 3a 26 2b			ld a, (.dmark)  
2b15 32 7a ee			ld (debug_mark),a  
2b18 3a 27 2b			ld a, (.dmark+1)  
2b1b 32 7b ee			ld (debug_mark+1),a  
2b1e 3a 28 2b			ld a, (.dmark+2)  
2b21 32 7c ee			ld (debug_mark+2),a  
2b24 18 03			jr .pastdmark  
2b26 ..			.dmark: db "-s_"  
2b29 f1			.pastdmark: pop af  
2b2a			endm  
# End of macro DMARK
2b2a						CALLMONITOR 
2b2a cd 0e 14			call break_point_state  
2b2d				endm  
# End of macro CALLMONITOR
2b2d					endif 
2b2d			 
2b2d					FORTH_DSP_VALUEHL 
2b2d cd 92 1b			call macro_dsp_valuehl 
2b30				endm 
# End of macro FORTH_DSP_VALUEHL
2b30			 
2b30 e5					push hl   ; save address 
2b31			 
2b31					FORTH_DSP_POP 
2b31 cd 4a 1c			call macro_forth_dsp_pop 
2b34				endm 
# End of macro FORTH_DSP_POP
2b34			 
2b34					FORTH_DSP_VALUEHL 
2b34 cd 92 1b			call macro_dsp_valuehl 
2b37				endm 
# End of macro FORTH_DSP_VALUEHL
2b37			 
2b37					; hl contains value to add to byte at a 
2b37				 
2b37 eb					ex de, hl 
2b38			 
2b38 e1					pop hl 
2b39			 
2b39					if DEBUG_FORTH_WORDS 
2b39						DMARK "DEC" 
2b39 f5				push af  
2b3a 3a 4e 2b			ld a, (.dmark)  
2b3d 32 7a ee			ld (debug_mark),a  
2b40 3a 4f 2b			ld a, (.dmark+1)  
2b43 32 7b ee			ld (debug_mark+1),a  
2b46 3a 50 2b			ld a, (.dmark+2)  
2b49 32 7c ee			ld (debug_mark+2),a  
2b4c 18 03			jr .pastdmark  
2b4e ..			.dmark: db "DEC"  
2b51 f1			.pastdmark: pop af  
2b52			endm  
# End of macro DMARK
2b52						CALLMONITOR 
2b52 cd 0e 14			call break_point_state  
2b55				endm  
# End of macro CALLMONITOR
2b55					endif 
2b55			 
2b55 7e					ld a,(hl) 
2b56 93					sub e 
2b57 77					ld (hl),a 
2b58			 
2b58			 
2b58			 
2b58				       NEXTW 
2b58 c3 04 1d			jp macro_next 
2b5b				endm 
# End of macro NEXTW
2b5b			 
2b5b			.INC2: 
2b5b				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2b5b 6f				db WORD_SYS_CORE+91             
2b5c 05 2c			dw .DEC2            
2b5e 04				db 3 + 1 
2b5f .. 00			db "+2!",0              
2b63				endm 
# End of macro CWHEAD
2b63			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2b63			 
2b63					if DEBUG_FORTH_WORDS_KEY 
2b63						DMARK "+2s" 
2b63 f5				push af  
2b64 3a 78 2b			ld a, (.dmark)  
2b67 32 7a ee			ld (debug_mark),a  
2b6a 3a 79 2b			ld a, (.dmark+1)  
2b6d 32 7b ee			ld (debug_mark+1),a  
2b70 3a 7a 2b			ld a, (.dmark+2)  
2b73 32 7c ee			ld (debug_mark+2),a  
2b76 18 03			jr .pastdmark  
2b78 ..			.dmark: db "+2s"  
2b7b f1			.pastdmark: pop af  
2b7c			endm  
# End of macro DMARK
2b7c						CALLMONITOR 
2b7c cd 0e 14			call break_point_state  
2b7f				endm  
# End of macro CALLMONITOR
2b7f					endif 
2b7f			 
2b7f					; Address 
2b7f			 
2b7f					FORTH_DSP_VALUEHL 
2b7f cd 92 1b			call macro_dsp_valuehl 
2b82				endm 
# End of macro FORTH_DSP_VALUEHL
2b82			 
2b82 e5					push hl    ; save address 
2b83			 
2b83					; load content into de 
2b83			 
2b83 5e					ld e,(hl) 
2b84 23					inc hl 
2b85 56					ld d, (hl) 
2b86			 
2b86					if DEBUG_FORTH_WORDS 
2b86						DMARK "+2a" 
2b86 f5				push af  
2b87 3a 9b 2b			ld a, (.dmark)  
2b8a 32 7a ee			ld (debug_mark),a  
2b8d 3a 9c 2b			ld a, (.dmark+1)  
2b90 32 7b ee			ld (debug_mark+1),a  
2b93 3a 9d 2b			ld a, (.dmark+2)  
2b96 32 7c ee			ld (debug_mark+2),a  
2b99 18 03			jr .pastdmark  
2b9b ..			.dmark: db "+2a"  
2b9e f1			.pastdmark: pop af  
2b9f			endm  
# End of macro DMARK
2b9f						CALLMONITOR 
2b9f cd 0e 14			call break_point_state  
2ba2				endm  
# End of macro CALLMONITOR
2ba2					endif 
2ba2			 
2ba2					FORTH_DSP_POP 
2ba2 cd 4a 1c			call macro_forth_dsp_pop 
2ba5				endm 
# End of macro FORTH_DSP_POP
2ba5			 
2ba5					; Get value to add 
2ba5			 
2ba5					FORTH_DSP_VALUE 
2ba5 cd 7b 1b			call macro_forth_dsp_value 
2ba8				endm 
# End of macro FORTH_DSP_VALUE
2ba8			 
2ba8					if DEBUG_FORTH_WORDS 
2ba8						DMARK "+2v" 
2ba8 f5				push af  
2ba9 3a bd 2b			ld a, (.dmark)  
2bac 32 7a ee			ld (debug_mark),a  
2baf 3a be 2b			ld a, (.dmark+1)  
2bb2 32 7b ee			ld (debug_mark+1),a  
2bb5 3a bf 2b			ld a, (.dmark+2)  
2bb8 32 7c ee			ld (debug_mark+2),a  
2bbb 18 03			jr .pastdmark  
2bbd ..			.dmark: db "+2v"  
2bc0 f1			.pastdmark: pop af  
2bc1			endm  
# End of macro DMARK
2bc1						CALLMONITOR 
2bc1 cd 0e 14			call break_point_state  
2bc4				endm  
# End of macro CALLMONITOR
2bc4					endif 
2bc4			 
2bc4 19					add hl, de 
2bc5			 
2bc5					if DEBUG_FORTH_WORDS 
2bc5						DMARK "+2+" 
2bc5 f5				push af  
2bc6 3a da 2b			ld a, (.dmark)  
2bc9 32 7a ee			ld (debug_mark),a  
2bcc 3a db 2b			ld a, (.dmark+1)  
2bcf 32 7b ee			ld (debug_mark+1),a  
2bd2 3a dc 2b			ld a, (.dmark+2)  
2bd5 32 7c ee			ld (debug_mark+2),a  
2bd8 18 03			jr .pastdmark  
2bda ..			.dmark: db "+2+"  
2bdd f1			.pastdmark: pop af  
2bde			endm  
# End of macro DMARK
2bde						CALLMONITOR 
2bde cd 0e 14			call break_point_state  
2be1				endm  
# End of macro CALLMONITOR
2be1					endif 
2be1			 
2be1					; move result to de 
2be1			 
2be1 eb					ex de, hl 
2be2			 
2be2					; Address 
2be2			 
2be2 e1					pop hl 
2be3			 
2be3					; save it back 
2be3			 
2be3 73					ld (hl), e 
2be4 23					inc hl 
2be5 72					ld (hl), d 
2be6			 
2be6					if DEBUG_FORTH_WORDS 
2be6						DMARK "+2e" 
2be6 f5				push af  
2be7 3a fb 2b			ld a, (.dmark)  
2bea 32 7a ee			ld (debug_mark),a  
2bed 3a fc 2b			ld a, (.dmark+1)  
2bf0 32 7b ee			ld (debug_mark+1),a  
2bf3 3a fd 2b			ld a, (.dmark+2)  
2bf6 32 7c ee			ld (debug_mark+2),a  
2bf9 18 03			jr .pastdmark  
2bfb ..			.dmark: db "+2e"  
2bfe f1			.pastdmark: pop af  
2bff			endm  
# End of macro DMARK
2bff						CALLMONITOR 
2bff cd 0e 14			call break_point_state  
2c02				endm  
# End of macro CALLMONITOR
2c02					endif 
2c02			 
2c02			 
2c02			 
2c02			 
2c02			 
2c02				       NEXTW 
2c02 c3 04 1d			jp macro_next 
2c05				endm 
# End of macro NEXTW
2c05			 
2c05			.DEC2: 
2c05				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2c05 6f				db WORD_SYS_CORE+91             
2c06 b1 2c			dw .GET2            
2c08 04				db 3 + 1 
2c09 .. 00			db "-2!",0              
2c0d				endm 
# End of macro CWHEAD
2c0d			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2c0d			 
2c0d			 
2c0d					if DEBUG_FORTH_WORDS_KEY 
2c0d						DMARK "-2s" 
2c0d f5				push af  
2c0e 3a 22 2c			ld a, (.dmark)  
2c11 32 7a ee			ld (debug_mark),a  
2c14 3a 23 2c			ld a, (.dmark+1)  
2c17 32 7b ee			ld (debug_mark+1),a  
2c1a 3a 24 2c			ld a, (.dmark+2)  
2c1d 32 7c ee			ld (debug_mark+2),a  
2c20 18 03			jr .pastdmark  
2c22 ..			.dmark: db "-2s"  
2c25 f1			.pastdmark: pop af  
2c26			endm  
# End of macro DMARK
2c26						CALLMONITOR 
2c26 cd 0e 14			call break_point_state  
2c29				endm  
# End of macro CALLMONITOR
2c29					endif 
2c29			 
2c29					; Address 
2c29			 
2c29					FORTH_DSP_VALUEHL 
2c29 cd 92 1b			call macro_dsp_valuehl 
2c2c				endm 
# End of macro FORTH_DSP_VALUEHL
2c2c			 
2c2c e5					push hl    ; save address 
2c2d			 
2c2d					; load content into de 
2c2d			 
2c2d 5e					ld e,(hl) 
2c2e 23					inc hl 
2c2f 56					ld d, (hl) 
2c30			 
2c30					if DEBUG_FORTH_WORDS 
2c30						DMARK "-2a" 
2c30 f5				push af  
2c31 3a 45 2c			ld a, (.dmark)  
2c34 32 7a ee			ld (debug_mark),a  
2c37 3a 46 2c			ld a, (.dmark+1)  
2c3a 32 7b ee			ld (debug_mark+1),a  
2c3d 3a 47 2c			ld a, (.dmark+2)  
2c40 32 7c ee			ld (debug_mark+2),a  
2c43 18 03			jr .pastdmark  
2c45 ..			.dmark: db "-2a"  
2c48 f1			.pastdmark: pop af  
2c49			endm  
# End of macro DMARK
2c49						CALLMONITOR 
2c49 cd 0e 14			call break_point_state  
2c4c				endm  
# End of macro CALLMONITOR
2c4c					endif 
2c4c			 
2c4c					FORTH_DSP_POP 
2c4c cd 4a 1c			call macro_forth_dsp_pop 
2c4f				endm 
# End of macro FORTH_DSP_POP
2c4f			 
2c4f					; Get value to remove 
2c4f			 
2c4f					FORTH_DSP_VALUE 
2c4f cd 7b 1b			call macro_forth_dsp_value 
2c52				endm 
# End of macro FORTH_DSP_VALUE
2c52			 
2c52					if DEBUG_FORTH_WORDS 
2c52						DMARK "-2v" 
2c52 f5				push af  
2c53 3a 67 2c			ld a, (.dmark)  
2c56 32 7a ee			ld (debug_mark),a  
2c59 3a 68 2c			ld a, (.dmark+1)  
2c5c 32 7b ee			ld (debug_mark+1),a  
2c5f 3a 69 2c			ld a, (.dmark+2)  
2c62 32 7c ee			ld (debug_mark+2),a  
2c65 18 03			jr .pastdmark  
2c67 ..			.dmark: db "-2v"  
2c6a f1			.pastdmark: pop af  
2c6b			endm  
# End of macro DMARK
2c6b						CALLMONITOR 
2c6b cd 0e 14			call break_point_state  
2c6e				endm  
# End of macro CALLMONITOR
2c6e					endif 
2c6e			 
2c6e eb					ex de, hl 
2c6f ed 52				sbc hl, de 
2c71			 
2c71					if DEBUG_FORTH_WORDS 
2c71						DMARK "-2d" 
2c71 f5				push af  
2c72 3a 86 2c			ld a, (.dmark)  
2c75 32 7a ee			ld (debug_mark),a  
2c78 3a 87 2c			ld a, (.dmark+1)  
2c7b 32 7b ee			ld (debug_mark+1),a  
2c7e 3a 88 2c			ld a, (.dmark+2)  
2c81 32 7c ee			ld (debug_mark+2),a  
2c84 18 03			jr .pastdmark  
2c86 ..			.dmark: db "-2d"  
2c89 f1			.pastdmark: pop af  
2c8a			endm  
# End of macro DMARK
2c8a						CALLMONITOR 
2c8a cd 0e 14			call break_point_state  
2c8d				endm  
# End of macro CALLMONITOR
2c8d					endif 
2c8d			 
2c8d					; move result to de 
2c8d			 
2c8d eb					ex de, hl 
2c8e			 
2c8e					; Address 
2c8e			 
2c8e e1					pop hl 
2c8f			 
2c8f					; save it back 
2c8f			 
2c8f 73					ld (hl), e 
2c90 23					inc hl 
2c91 72					ld (hl), d 
2c92			 
2c92					if DEBUG_FORTH_WORDS 
2c92						DMARK "-2e" 
2c92 f5				push af  
2c93 3a a7 2c			ld a, (.dmark)  
2c96 32 7a ee			ld (debug_mark),a  
2c99 3a a8 2c			ld a, (.dmark+1)  
2c9c 32 7b ee			ld (debug_mark+1),a  
2c9f 3a a9 2c			ld a, (.dmark+2)  
2ca2 32 7c ee			ld (debug_mark+2),a  
2ca5 18 03			jr .pastdmark  
2ca7 ..			.dmark: db "-2e"  
2caa f1			.pastdmark: pop af  
2cab			endm  
# End of macro DMARK
2cab						CALLMONITOR 
2cab cd 0e 14			call break_point_state  
2cae				endm  
# End of macro CALLMONITOR
2cae					endif 
2cae			 
2cae			 
2cae			 
2cae			 
2cae			 
2cae				       NEXTW 
2cae c3 04 1d			jp macro_next 
2cb1				endm 
# End of macro NEXTW
2cb1			.GET2: 
2cb1				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2cb1 6f				db WORD_SYS_CORE+91             
2cb2 e1 2c			dw .BANG2            
2cb4 03				db 2 + 1 
2cb5 .. 00			db "2@",0              
2cb8				endm 
# End of macro CWHEAD
2cb8			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2cb8					if DEBUG_FORTH_WORDS_KEY 
2cb8						DMARK "2A_" 
2cb8 f5				push af  
2cb9 3a cd 2c			ld a, (.dmark)  
2cbc 32 7a ee			ld (debug_mark),a  
2cbf 3a ce 2c			ld a, (.dmark+1)  
2cc2 32 7b ee			ld (debug_mark+1),a  
2cc5 3a cf 2c			ld a, (.dmark+2)  
2cc8 32 7c ee			ld (debug_mark+2),a  
2ccb 18 03			jr .pastdmark  
2ccd ..			.dmark: db "2A_"  
2cd0 f1			.pastdmark: pop af  
2cd1			endm  
# End of macro DMARK
2cd1						CALLMONITOR 
2cd1 cd 0e 14			call break_point_state  
2cd4				endm  
# End of macro CALLMONITOR
2cd4					endif 
2cd4			 
2cd4					FORTH_DSP_VALUEHL 
2cd4 cd 92 1b			call macro_dsp_valuehl 
2cd7				endm 
# End of macro FORTH_DSP_VALUEHL
2cd7			 
2cd7 5e					ld e, (hl) 
2cd8 23					inc hl 
2cd9 56					ld d, (hl) 
2cda			 
2cda eb					ex de, hl 
2cdb			 
2cdb cd 9b 19				call forth_push_numhl 
2cde			 
2cde				       NEXTW 
2cde c3 04 1d			jp macro_next 
2ce1				endm 
# End of macro NEXTW
2ce1			.BANG2: 
2ce1				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2ce1 6f				db WORD_SYS_CORE+91             
2ce2 19 2d			dw .CONFIG            
2ce4 03				db 2 + 1 
2ce5 .. 00			db "2!",0              
2ce8				endm 
# End of macro CWHEAD
2ce8			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ce8					if DEBUG_FORTH_WORDS_KEY 
2ce8						DMARK "2S_" 
2ce8 f5				push af  
2ce9 3a fd 2c			ld a, (.dmark)  
2cec 32 7a ee			ld (debug_mark),a  
2cef 3a fe 2c			ld a, (.dmark+1)  
2cf2 32 7b ee			ld (debug_mark+1),a  
2cf5 3a ff 2c			ld a, (.dmark+2)  
2cf8 32 7c ee			ld (debug_mark+2),a  
2cfb 18 03			jr .pastdmark  
2cfd ..			.dmark: db "2S_"  
2d00 f1			.pastdmark: pop af  
2d01			endm  
# End of macro DMARK
2d01						CALLMONITOR 
2d01 cd 0e 14			call break_point_state  
2d04				endm  
# End of macro CALLMONITOR
2d04					endif 
2d04			 
2d04					FORTH_DSP_VALUEHL 
2d04 cd 92 1b			call macro_dsp_valuehl 
2d07				endm 
# End of macro FORTH_DSP_VALUEHL
2d07			 
2d07 e5					push hl   ; save address 
2d08			 
2d08			 
2d08					FORTH_DSP_POP 
2d08 cd 4a 1c			call macro_forth_dsp_pop 
2d0b				endm 
# End of macro FORTH_DSP_POP
2d0b			 
2d0b					 
2d0b					FORTH_DSP_VALUEHL 
2d0b cd 92 1b			call macro_dsp_valuehl 
2d0e				endm 
# End of macro FORTH_DSP_VALUEHL
2d0e			 
2d0e					FORTH_DSP_POP 
2d0e cd 4a 1c			call macro_forth_dsp_pop 
2d11				endm 
# End of macro FORTH_DSP_POP
2d11			 
2d11 eb					ex de, hl    ; value now in de 
2d12			 
2d12 e1					pop hl 
2d13			 
2d13 73					ld (hl), e 
2d14			 
2d14 23					inc hl 
2d15			 
2d15 72					ld (hl), d 
2d16			 
2d16			 
2d16				       NEXTW 
2d16 c3 04 1d			jp macro_next 
2d19				endm 
# End of macro NEXTW
2d19			.CONFIG: 
2d19				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2d19 6f				db WORD_SYS_CORE+91             
2d1a 2a 2d			dw .ENDCORE            
2d1c 07				db 6 + 1 
2d1d .. 00			db "CONFIG",0              
2d24				endm 
# End of macro CWHEAD
2d24			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2d24			 
2d24 cd 12 12				call config 
2d27					NEXTW 
2d27 c3 04 1d			jp macro_next 
2d2a				endm 
# End of macro NEXTW
2d2a			.ENDCORE: 
2d2a			 
2d2a			; eof 
2d2a			 
2d2a			 
# End of file forth_words_core.asm
2d2a			include "forth_words_flow.asm" 
2d2a			 
2d2a			; | ## Program Flow Words 
2d2a			 
2d2a			.IF: 
2d2a				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2d2a 1e				db WORD_SYS_CORE+10             
2d2b 1f 2e			dw .THEN            
2d2d 03				db 2 + 1 
2d2e .. 00			db "IF",0              
2d31				endm 
# End of macro CWHEAD
2d31			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2d31			; 
2d31					if DEBUG_FORTH_WORDS_KEY 
2d31						DMARK "IF." 
2d31 f5				push af  
2d32 3a 46 2d			ld a, (.dmark)  
2d35 32 7a ee			ld (debug_mark),a  
2d38 3a 47 2d			ld a, (.dmark+1)  
2d3b 32 7b ee			ld (debug_mark+1),a  
2d3e 3a 48 2d			ld a, (.dmark+2)  
2d41 32 7c ee			ld (debug_mark+2),a  
2d44 18 03			jr .pastdmark  
2d46 ..			.dmark: db "IF."  
2d49 f1			.pastdmark: pop af  
2d4a			endm  
# End of macro DMARK
2d4a						CALLMONITOR 
2d4a cd 0e 14			call break_point_state  
2d4d				endm  
# End of macro CALLMONITOR
2d4d					endif 
2d4d			; eval TOS 
2d4d			 
2d4d				FORTH_DSP_VALUEHL 
2d4d cd 92 1b			call macro_dsp_valuehl 
2d50				endm 
# End of macro FORTH_DSP_VALUEHL
2d50			 
2d50			;	push hl 
2d50				FORTH_DSP_POP 
2d50 cd 4a 1c			call macro_forth_dsp_pop 
2d53				endm 
# End of macro FORTH_DSP_POP
2d53			;	pop hl 
2d53			 
2d53					if DEBUG_FORTH_WORDS 
2d53						DMARK "IF1" 
2d53 f5				push af  
2d54 3a 68 2d			ld a, (.dmark)  
2d57 32 7a ee			ld (debug_mark),a  
2d5a 3a 69 2d			ld a, (.dmark+1)  
2d5d 32 7b ee			ld (debug_mark+1),a  
2d60 3a 6a 2d			ld a, (.dmark+2)  
2d63 32 7c ee			ld (debug_mark+2),a  
2d66 18 03			jr .pastdmark  
2d68 ..			.dmark: db "IF1"  
2d6b f1			.pastdmark: pop af  
2d6c			endm  
# End of macro DMARK
2d6c						CALLMONITOR 
2d6c cd 0e 14			call break_point_state  
2d6f				endm  
# End of macro CALLMONITOR
2d6f					endif 
2d6f b7				or a        ; clear carry flag 
2d70 11 00 00			ld de, 0 
2d73 eb				ex de,hl 
2d74 ed 52			sbc hl, de 
2d76 c2 00 2e			jp nz, .iftrue 
2d79			 
2d79					if DEBUG_FORTH_WORDS 
2d79						DMARK "IF2" 
2d79 f5				push af  
2d7a 3a 8e 2d			ld a, (.dmark)  
2d7d 32 7a ee			ld (debug_mark),a  
2d80 3a 8f 2d			ld a, (.dmark+1)  
2d83 32 7b ee			ld (debug_mark+1),a  
2d86 3a 90 2d			ld a, (.dmark+2)  
2d89 32 7c ee			ld (debug_mark+2),a  
2d8c 18 03			jr .pastdmark  
2d8e ..			.dmark: db "IF2"  
2d91 f1			.pastdmark: pop af  
2d92			endm  
# End of macro DMARK
2d92						CALLMONITOR 
2d92 cd 0e 14			call break_point_state  
2d95				endm  
# End of macro CALLMONITOR
2d95					endif 
2d95			 
2d95			; if not true then skip to THEN 
2d95			 
2d95				; TODO get tok_ptr 
2d95				; TODO consume toks until we get to THEN 
2d95			 
2d95 2a 61 e6			ld hl, (os_tok_ptr) 
2d98					if DEBUG_FORTH_WORDS 
2d98						DMARK "IF3" 
2d98 f5				push af  
2d99 3a ad 2d			ld a, (.dmark)  
2d9c 32 7a ee			ld (debug_mark),a  
2d9f 3a ae 2d			ld a, (.dmark+1)  
2da2 32 7b ee			ld (debug_mark+1),a  
2da5 3a af 2d			ld a, (.dmark+2)  
2da8 32 7c ee			ld (debug_mark+2),a  
2dab 18 03			jr .pastdmark  
2dad ..			.dmark: db "IF3"  
2db0 f1			.pastdmark: pop af  
2db1			endm  
# End of macro DMARK
2db1						CALLMONITOR 
2db1 cd 0e 14			call break_point_state  
2db4				endm  
# End of macro CALLMONITOR
2db4						 
2db4					endif 
2db4 11 fb 2d			ld de, .ifthen 
2db7					if DEBUG_FORTH_WORDS 
2db7						DMARK "IF4" 
2db7 f5				push af  
2db8 3a cc 2d			ld a, (.dmark)  
2dbb 32 7a ee			ld (debug_mark),a  
2dbe 3a cd 2d			ld a, (.dmark+1)  
2dc1 32 7b ee			ld (debug_mark+1),a  
2dc4 3a ce 2d			ld a, (.dmark+2)  
2dc7 32 7c ee			ld (debug_mark+2),a  
2dca 18 03			jr .pastdmark  
2dcc ..			.dmark: db "IF4"  
2dcf f1			.pastdmark: pop af  
2dd0			endm  
# End of macro DMARK
2dd0						CALLMONITOR 
2dd0 cd 0e 14			call break_point_state  
2dd3				endm  
# End of macro CALLMONITOR
2dd3					endif 
2dd3 cd 1f 1e			call findnexttok  
2dd6			 
2dd6					if DEBUG_FORTH_WORDS 
2dd6						DMARK "IF5" 
2dd6 f5				push af  
2dd7 3a eb 2d			ld a, (.dmark)  
2dda 32 7a ee			ld (debug_mark),a  
2ddd 3a ec 2d			ld a, (.dmark+1)  
2de0 32 7b ee			ld (debug_mark+1),a  
2de3 3a ed 2d			ld a, (.dmark+2)  
2de6 32 7c ee			ld (debug_mark+2),a  
2de9 18 03			jr .pastdmark  
2deb ..			.dmark: db "IF5"  
2dee f1			.pastdmark: pop af  
2def			endm  
# End of macro DMARK
2def						CALLMONITOR 
2def cd 0e 14			call break_point_state  
2df2				endm  
# End of macro CALLMONITOR
2df2					endif 
2df2				; TODO replace below with ; exec using tok_ptr 
2df2 22 61 e6			ld (os_tok_ptr), hl 
2df5 c3 95 1d			jp exec1 
2df8				NEXTW 
2df8 c3 04 1d			jp macro_next 
2dfb				endm 
# End of macro NEXTW
2dfb			 
2dfb .. 00		.ifthen:  db "THEN",0 
2e00			 
2e00			.iftrue:		 
2e00				; Exec next words normally 
2e00			 
2e00				; if true then exec following IF as normal 
2e00					if DEBUG_FORTH_WORDS 
2e00						DMARK "IFT" 
2e00 f5				push af  
2e01 3a 15 2e			ld a, (.dmark)  
2e04 32 7a ee			ld (debug_mark),a  
2e07 3a 16 2e			ld a, (.dmark+1)  
2e0a 32 7b ee			ld (debug_mark+1),a  
2e0d 3a 17 2e			ld a, (.dmark+2)  
2e10 32 7c ee			ld (debug_mark+2),a  
2e13 18 03			jr .pastdmark  
2e15 ..			.dmark: db "IFT"  
2e18 f1			.pastdmark: pop af  
2e19			endm  
# End of macro DMARK
2e19						CALLMONITOR 
2e19 cd 0e 14			call break_point_state  
2e1c				endm  
# End of macro CALLMONITOR
2e1c					endif 
2e1c			 
2e1c					NEXTW 
2e1c c3 04 1d			jp macro_next 
2e1f				endm 
# End of macro NEXTW
2e1f			.THEN: 
2e1f				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2e1f 1f				db WORD_SYS_CORE+11             
2e20 47 2e			dw .ELSE            
2e22 05				db 4 + 1 
2e23 .. 00			db "THEN",0              
2e28				endm 
# End of macro CWHEAD
2e28			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2e28					if DEBUG_FORTH_WORDS_KEY 
2e28						DMARK "THN" 
2e28 f5				push af  
2e29 3a 3d 2e			ld a, (.dmark)  
2e2c 32 7a ee			ld (debug_mark),a  
2e2f 3a 3e 2e			ld a, (.dmark+1)  
2e32 32 7b ee			ld (debug_mark+1),a  
2e35 3a 3f 2e			ld a, (.dmark+2)  
2e38 32 7c ee			ld (debug_mark+2),a  
2e3b 18 03			jr .pastdmark  
2e3d ..			.dmark: db "THN"  
2e40 f1			.pastdmark: pop af  
2e41			endm  
# End of macro DMARK
2e41						CALLMONITOR 
2e41 cd 0e 14			call break_point_state  
2e44				endm  
# End of macro CALLMONITOR
2e44					endif 
2e44					NEXTW 
2e44 c3 04 1d			jp macro_next 
2e47				endm 
# End of macro NEXTW
2e47			.ELSE: 
2e47				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2e47 20				db WORD_SYS_CORE+12             
2e48 6f 2e			dw .DO            
2e4a 03				db 2 + 1 
2e4b .. 00			db "ELSE",0              
2e50				endm 
# End of macro CWHEAD
2e50			; | ELSE ( -- ) Not supported - does nothing | TODO 
2e50			 
2e50					if DEBUG_FORTH_WORDS_KEY 
2e50						DMARK "ELS" 
2e50 f5				push af  
2e51 3a 65 2e			ld a, (.dmark)  
2e54 32 7a ee			ld (debug_mark),a  
2e57 3a 66 2e			ld a, (.dmark+1)  
2e5a 32 7b ee			ld (debug_mark+1),a  
2e5d 3a 67 2e			ld a, (.dmark+2)  
2e60 32 7c ee			ld (debug_mark+2),a  
2e63 18 03			jr .pastdmark  
2e65 ..			.dmark: db "ELS"  
2e68 f1			.pastdmark: pop af  
2e69			endm  
# End of macro DMARK
2e69						CALLMONITOR 
2e69 cd 0e 14			call break_point_state  
2e6c				endm  
# End of macro CALLMONITOR
2e6c					endif 
2e6c			 
2e6c			 
2e6c					NEXTW 
2e6c c3 04 1d			jp macro_next 
2e6f				endm 
# End of macro NEXTW
2e6f			.DO: 
2e6f				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2e6f 21				db WORD_SYS_CORE+13             
2e70 96 2f			dw .LOOP            
2e72 03				db 2 + 1 
2e73 .. 00			db "DO",0              
2e76				endm 
# End of macro CWHEAD
2e76			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2e76			 
2e76					if DEBUG_FORTH_WORDS_KEY 
2e76						DMARK "DO." 
2e76 f5				push af  
2e77 3a 8b 2e			ld a, (.dmark)  
2e7a 32 7a ee			ld (debug_mark),a  
2e7d 3a 8c 2e			ld a, (.dmark+1)  
2e80 32 7b ee			ld (debug_mark+1),a  
2e83 3a 8d 2e			ld a, (.dmark+2)  
2e86 32 7c ee			ld (debug_mark+2),a  
2e89 18 03			jr .pastdmark  
2e8b ..			.dmark: db "DO."  
2e8e f1			.pastdmark: pop af  
2e8f			endm  
# End of macro DMARK
2e8f						CALLMONITOR 
2e8f cd 0e 14			call break_point_state  
2e92				endm  
# End of macro CALLMONITOR
2e92					endif 
2e92			;  push pc to rsp stack past the DO 
2e92			 
2e92 2a 61 e6				ld hl, (os_tok_ptr) 
2e95 23					inc hl   ; D 
2e96 23					inc hl  ; O 
2e97 23					inc hl   ; null 
2e98					if DEBUG_FORTH_WORDS 
2e98						DMARK "DO2" 
2e98 f5				push af  
2e99 3a ad 2e			ld a, (.dmark)  
2e9c 32 7a ee			ld (debug_mark),a  
2e9f 3a ae 2e			ld a, (.dmark+1)  
2ea2 32 7b ee			ld (debug_mark+1),a  
2ea5 3a af 2e			ld a, (.dmark+2)  
2ea8 32 7c ee			ld (debug_mark+2),a  
2eab 18 03			jr .pastdmark  
2ead ..			.dmark: db "DO2"  
2eb0 f1			.pastdmark: pop af  
2eb1			endm  
# End of macro DMARK
2eb1						CALLMONITOR 
2eb1 cd 0e 14			call break_point_state  
2eb4				endm  
# End of macro CALLMONITOR
2eb4					endif 
2eb4					FORTH_RSP_NEXT 
2eb4 cd 42 19			call macro_forth_rsp_next 
2eb7				endm 
# End of macro FORTH_RSP_NEXT
2eb7					if DEBUG_FORTH_WORDS 
2eb7						DMARK "DO3" 
2eb7 f5				push af  
2eb8 3a cc 2e			ld a, (.dmark)  
2ebb 32 7a ee			ld (debug_mark),a  
2ebe 3a cd 2e			ld a, (.dmark+1)  
2ec1 32 7b ee			ld (debug_mark+1),a  
2ec4 3a ce 2e			ld a, (.dmark+2)  
2ec7 32 7c ee			ld (debug_mark+2),a  
2eca 18 03			jr .pastdmark  
2ecc ..			.dmark: db "DO3"  
2ecf f1			.pastdmark: pop af  
2ed0			endm  
# End of macro DMARK
2ed0						CALLMONITOR 
2ed0 cd 0e 14			call break_point_state  
2ed3				endm  
# End of macro CALLMONITOR
2ed3					endif 
2ed3			 
2ed3					;if DEBUG_FORTH_WORDS 
2ed3				;		push hl 
2ed3			;		endif  
2ed3			 
2ed3			; get counters from data stack 
2ed3			 
2ed3			 
2ed3					FORTH_DSP_VALUEHL 
2ed3 cd 92 1b			call macro_dsp_valuehl 
2ed6				endm 
# End of macro FORTH_DSP_VALUEHL
2ed6 e5					push hl		 ; hl now has starting counter which needs to be tos 
2ed7			 
2ed7					if DEBUG_FORTH_WORDS 
2ed7						DMARK "DO4" 
2ed7 f5				push af  
2ed8 3a ec 2e			ld a, (.dmark)  
2edb 32 7a ee			ld (debug_mark),a  
2ede 3a ed 2e			ld a, (.dmark+1)  
2ee1 32 7b ee			ld (debug_mark+1),a  
2ee4 3a ee 2e			ld a, (.dmark+2)  
2ee7 32 7c ee			ld (debug_mark+2),a  
2eea 18 03			jr .pastdmark  
2eec ..			.dmark: db "DO4"  
2eef f1			.pastdmark: pop af  
2ef0			endm  
# End of macro DMARK
2ef0						CALLMONITOR 
2ef0 cd 0e 14			call break_point_state  
2ef3				endm  
# End of macro CALLMONITOR
2ef3					endif 
2ef3					FORTH_DSP_POP 
2ef3 cd 4a 1c			call macro_forth_dsp_pop 
2ef6				endm 
# End of macro FORTH_DSP_POP
2ef6			 
2ef6					if DEBUG_FORTH_WORDS 
2ef6						DMARK "DO5" 
2ef6 f5				push af  
2ef7 3a 0b 2f			ld a, (.dmark)  
2efa 32 7a ee			ld (debug_mark),a  
2efd 3a 0c 2f			ld a, (.dmark+1)  
2f00 32 7b ee			ld (debug_mark+1),a  
2f03 3a 0d 2f			ld a, (.dmark+2)  
2f06 32 7c ee			ld (debug_mark+2),a  
2f09 18 03			jr .pastdmark  
2f0b ..			.dmark: db "DO5"  
2f0e f1			.pastdmark: pop af  
2f0f			endm  
# End of macro DMARK
2f0f						CALLMONITOR 
2f0f cd 0e 14			call break_point_state  
2f12				endm  
# End of macro CALLMONITOR
2f12					endif 
2f12			 
2f12					FORTH_DSP_VALUEHL 
2f12 cd 92 1b			call macro_dsp_valuehl 
2f15				endm 
# End of macro FORTH_DSP_VALUEHL
2f15			;		push hl		 ; hl now has starting limit counter 
2f15			 
2f15					if DEBUG_FORTH_WORDS 
2f15						DMARK "DO6" 
2f15 f5				push af  
2f16 3a 2a 2f			ld a, (.dmark)  
2f19 32 7a ee			ld (debug_mark),a  
2f1c 3a 2b 2f			ld a, (.dmark+1)  
2f1f 32 7b ee			ld (debug_mark+1),a  
2f22 3a 2c 2f			ld a, (.dmark+2)  
2f25 32 7c ee			ld (debug_mark+2),a  
2f28 18 03			jr .pastdmark  
2f2a ..			.dmark: db "DO6"  
2f2d f1			.pastdmark: pop af  
2f2e			endm  
# End of macro DMARK
2f2e						CALLMONITOR 
2f2e cd 0e 14			call break_point_state  
2f31				endm  
# End of macro CALLMONITOR
2f31					endif 
2f31					FORTH_DSP_POP 
2f31 cd 4a 1c			call macro_forth_dsp_pop 
2f34				endm 
# End of macro FORTH_DSP_POP
2f34			 
2f34			; put counters on the loop stack 
2f34			 
2f34			;		pop hl			 ; limit counter 
2f34 d1					pop de			; start counter 
2f35			 
2f35					; push limit counter 
2f35			 
2f35					if DEBUG_FORTH_WORDS 
2f35						DMARK "DO7" 
2f35 f5				push af  
2f36 3a 4a 2f			ld a, (.dmark)  
2f39 32 7a ee			ld (debug_mark),a  
2f3c 3a 4b 2f			ld a, (.dmark+1)  
2f3f 32 7b ee			ld (debug_mark+1),a  
2f42 3a 4c 2f			ld a, (.dmark+2)  
2f45 32 7c ee			ld (debug_mark+2),a  
2f48 18 03			jr .pastdmark  
2f4a ..			.dmark: db "DO7"  
2f4d f1			.pastdmark: pop af  
2f4e			endm  
# End of macro DMARK
2f4e						CALLMONITOR 
2f4e cd 0e 14			call break_point_state  
2f51				endm  
# End of macro CALLMONITOR
2f51					endif 
2f51					FORTH_LOOP_NEXT 
2f51 cd c3 1b			call macro_forth_loop_next 
2f54				endm 
# End of macro FORTH_LOOP_NEXT
2f54			 
2f54					; push start counter 
2f54			 
2f54 eb					ex de, hl 
2f55					if DEBUG_FORTH_WORDS 
2f55						DMARK "DO7" 
2f55 f5				push af  
2f56 3a 6a 2f			ld a, (.dmark)  
2f59 32 7a ee			ld (debug_mark),a  
2f5c 3a 6b 2f			ld a, (.dmark+1)  
2f5f 32 7b ee			ld (debug_mark+1),a  
2f62 3a 6c 2f			ld a, (.dmark+2)  
2f65 32 7c ee			ld (debug_mark+2),a  
2f68 18 03			jr .pastdmark  
2f6a ..			.dmark: db "DO7"  
2f6d f1			.pastdmark: pop af  
2f6e			endm  
# End of macro DMARK
2f6e						CALLMONITOR 
2f6e cd 0e 14			call break_point_state  
2f71				endm  
# End of macro CALLMONITOR
2f71					endif 
2f71					FORTH_LOOP_NEXT 
2f71 cd c3 1b			call macro_forth_loop_next 
2f74				endm 
# End of macro FORTH_LOOP_NEXT
2f74			 
2f74			 
2f74					; init first round of I counter 
2f74			 
2f74 22 85 e6				ld (os_current_i), hl 
2f77			 
2f77					if DEBUG_FORTH_WORDS 
2f77						DMARK "DO8" 
2f77 f5				push af  
2f78 3a 8c 2f			ld a, (.dmark)  
2f7b 32 7a ee			ld (debug_mark),a  
2f7e 3a 8d 2f			ld a, (.dmark+1)  
2f81 32 7b ee			ld (debug_mark+1),a  
2f84 3a 8e 2f			ld a, (.dmark+2)  
2f87 32 7c ee			ld (debug_mark+2),a  
2f8a 18 03			jr .pastdmark  
2f8c ..			.dmark: db "DO8"  
2f8f f1			.pastdmark: pop af  
2f90			endm  
# End of macro DMARK
2f90						CALLMONITOR 
2f90 cd 0e 14			call break_point_state  
2f93				endm  
# End of macro CALLMONITOR
2f93					endif 
2f93			 
2f93					NEXTW 
2f93 c3 04 1d			jp macro_next 
2f96				endm 
# End of macro NEXTW
2f96			.LOOP: 
2f96				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2f96 22				db WORD_SYS_CORE+14             
2f97 ae 30			dw .I            
2f99 05				db 4 + 1 
2f9a .. 00			db "LOOP",0              
2f9f				endm 
# End of macro CWHEAD
2f9f			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2f9f			 
2f9f				; pop tos as current loop count to hl 
2f9f			 
2f9f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2f9f			 
2f9f				FORTH_LOOP_TOS 
2f9f cd f6 1b			call macro_forth_loop_tos 
2fa2				endm 
# End of macro FORTH_LOOP_TOS
2fa2 e5				push hl 
2fa3			 
2fa3					if DEBUG_FORTH_WORDS_KEY 
2fa3						DMARK "LOP" 
2fa3 f5				push af  
2fa4 3a b8 2f			ld a, (.dmark)  
2fa7 32 7a ee			ld (debug_mark),a  
2faa 3a b9 2f			ld a, (.dmark+1)  
2fad 32 7b ee			ld (debug_mark+1),a  
2fb0 3a ba 2f			ld a, (.dmark+2)  
2fb3 32 7c ee			ld (debug_mark+2),a  
2fb6 18 03			jr .pastdmark  
2fb8 ..			.dmark: db "LOP"  
2fbb f1			.pastdmark: pop af  
2fbc			endm  
# End of macro DMARK
2fbc						CALLMONITOR 
2fbc cd 0e 14			call break_point_state  
2fbf				endm  
# End of macro CALLMONITOR
2fbf					endif 
2fbf				; next item on the stack is the limit. get it 
2fbf			 
2fbf			 
2fbf				FORTH_LOOP_POP 
2fbf cd 00 1c			call macro_forth_loop_pop 
2fc2				endm 
# End of macro FORTH_LOOP_POP
2fc2			 
2fc2				FORTH_LOOP_TOS 
2fc2 cd f6 1b			call macro_forth_loop_tos 
2fc5				endm 
# End of macro FORTH_LOOP_TOS
2fc5			 
2fc5 d1				pop de		 ; de = i, hl = limit 
2fc6			 
2fc6					if DEBUG_FORTH_WORDS 
2fc6						DMARK "LP1" 
2fc6 f5				push af  
2fc7 3a db 2f			ld a, (.dmark)  
2fca 32 7a ee			ld (debug_mark),a  
2fcd 3a dc 2f			ld a, (.dmark+1)  
2fd0 32 7b ee			ld (debug_mark+1),a  
2fd3 3a dd 2f			ld a, (.dmark+2)  
2fd6 32 7c ee			ld (debug_mark+2),a  
2fd9 18 03			jr .pastdmark  
2fdb ..			.dmark: db "LP1"  
2fde f1			.pastdmark: pop af  
2fdf			endm  
# End of macro DMARK
2fdf						CALLMONITOR 
2fdf cd 0e 14			call break_point_state  
2fe2				endm  
# End of macro CALLMONITOR
2fe2					endif 
2fe2			 
2fe2				; go back to previous word 
2fe2			 
2fe2 d5				push de    ; save I for inc later 
2fe3			 
2fe3			 
2fe3				; get limit 
2fe3				;  is I at limit? 
2fe3			 
2fe3			 
2fe3					if DEBUG_FORTH_WORDS 
2fe3						DMARK "LP1" 
2fe3 f5				push af  
2fe4 3a f8 2f			ld a, (.dmark)  
2fe7 32 7a ee			ld (debug_mark),a  
2fea 3a f9 2f			ld a, (.dmark+1)  
2fed 32 7b ee			ld (debug_mark+1),a  
2ff0 3a fa 2f			ld a, (.dmark+2)  
2ff3 32 7c ee			ld (debug_mark+2),a  
2ff6 18 03			jr .pastdmark  
2ff8 ..			.dmark: db "LP1"  
2ffb f1			.pastdmark: pop af  
2ffc			endm  
# End of macro DMARK
2ffc						CALLMONITOR 
2ffc cd 0e 14			call break_point_state  
2fff				endm  
# End of macro CALLMONITOR
2fff					endif 
2fff			 
2fff ed 52			sbc hl, de 
3001			 
3001			 
3001				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3001			 
3001 20 26				jr nz, .loopnotdone 
3003			 
3003 e1				pop hl   ; get rid of saved I 
3004				FORTH_LOOP_POP     ; get rid of limit 
3004 cd 00 1c			call macro_forth_loop_pop 
3007				endm 
# End of macro FORTH_LOOP_POP
3007			 
3007				FORTH_RSP_POP     ; get rid of DO ptr 
3007 cd 63 19			call macro_forth_rsp_pop 
300a				endm 
# End of macro FORTH_RSP_POP
300a			 
300a			if DEBUG_FORTH_WORDS 
300a						DMARK "LP>" 
300a f5				push af  
300b 3a 1f 30			ld a, (.dmark)  
300e 32 7a ee			ld (debug_mark),a  
3011 3a 20 30			ld a, (.dmark+1)  
3014 32 7b ee			ld (debug_mark+1),a  
3017 3a 21 30			ld a, (.dmark+2)  
301a 32 7c ee			ld (debug_mark+2),a  
301d 18 03			jr .pastdmark  
301f ..			.dmark: db "LP>"  
3022 f1			.pastdmark: pop af  
3023			endm  
# End of macro DMARK
3023				CALLMONITOR 
3023 cd 0e 14			call break_point_state  
3026				endm  
# End of macro CALLMONITOR
3026			endif 
3026			 
3026					NEXTW 
3026 c3 04 1d			jp macro_next 
3029				endm 
# End of macro NEXTW
3029				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3029			 
3029			.loopnotdone: 
3029			 
3029 e1				pop hl    ; get I 
302a 23				inc hl 
302b			 
302b			   	; save new I 
302b			 
302b			 
302b					; set I counter 
302b			 
302b 22 85 e6				ld (os_current_i), hl 
302e			 
302e					if DEBUG_FORTH_WORDS 
302e						DMARK "LPN" 
302e f5				push af  
302f 3a 43 30			ld a, (.dmark)  
3032 32 7a ee			ld (debug_mark),a  
3035 3a 44 30			ld a, (.dmark+1)  
3038 32 7b ee			ld (debug_mark+1),a  
303b 3a 45 30			ld a, (.dmark+2)  
303e 32 7c ee			ld (debug_mark+2),a  
3041 18 03			jr .pastdmark  
3043 ..			.dmark: db "LPN"  
3046 f1			.pastdmark: pop af  
3047			endm  
# End of macro DMARK
3047					CALLMONITOR 
3047 cd 0e 14			call break_point_state  
304a				endm  
# End of macro CALLMONITOR
304a					endif 
304a					 
304a				FORTH_LOOP_NEXT 
304a cd c3 1b			call macro_forth_loop_next 
304d				endm 
# End of macro FORTH_LOOP_NEXT
304d			 
304d			 
304d					if DEBUG_FORTH_WORDS 
304d eb						ex de,hl 
304e					endif 
304e			 
304e			;	; get DO ptr 
304e			; 
304e					if DEBUG_FORTH_WORDS 
304e						DMARK "LP7" 
304e f5				push af  
304f 3a 63 30			ld a, (.dmark)  
3052 32 7a ee			ld (debug_mark),a  
3055 3a 64 30			ld a, (.dmark+1)  
3058 32 7b ee			ld (debug_mark+1),a  
305b 3a 65 30			ld a, (.dmark+2)  
305e 32 7c ee			ld (debug_mark+2),a  
3061 18 03			jr .pastdmark  
3063 ..			.dmark: db "LP7"  
3066 f1			.pastdmark: pop af  
3067			endm  
# End of macro DMARK
3067					CALLMONITOR 
3067 cd 0e 14			call break_point_state  
306a				endm  
# End of macro CALLMONITOR
306a					endif 
306a				FORTH_RSP_TOS 
306a cd 59 19			call macro_forth_rsp_tos 
306d				endm 
# End of macro FORTH_RSP_TOS
306d			 
306d					if DEBUG_FORTH_WORDS 
306d						DMARK "LP8" 
306d f5				push af  
306e 3a 82 30			ld a, (.dmark)  
3071 32 7a ee			ld (debug_mark),a  
3074 3a 83 30			ld a, (.dmark+1)  
3077 32 7b ee			ld (debug_mark+1),a  
307a 3a 84 30			ld a, (.dmark+2)  
307d 32 7c ee			ld (debug_mark+2),a  
3080 18 03			jr .pastdmark  
3082 ..			.dmark: db "LP8"  
3085 f1			.pastdmark: pop af  
3086			endm  
# End of macro DMARK
3086					CALLMONITOR 
3086 cd 0e 14			call break_point_state  
3089				endm  
# End of macro CALLMONITOR
3089					endif 
3089				;push hl 
3089			 
3089				; not going to DO any more 
3089				; get rid of the RSP pointer as DO will add it back in 
3089				;FORTH_RSP_POP 
3089				;pop hl 
3089			 
3089				;ld hl,(cli_ret_sp) 
3089				;ld e, (hl) 
3089				;inc hl 
3089				;ld d, (hl) 
3089				;ex de,hl 
3089 22 61 e6			ld (os_tok_ptr), hl 
308c					if DEBUG_FORTH_WORDS 
308c						DMARK "LP<" 
308c f5				push af  
308d 3a a1 30			ld a, (.dmark)  
3090 32 7a ee			ld (debug_mark),a  
3093 3a a2 30			ld a, (.dmark+1)  
3096 32 7b ee			ld (debug_mark+1),a  
3099 3a a3 30			ld a, (.dmark+2)  
309c 32 7c ee			ld (debug_mark+2),a  
309f 18 03			jr .pastdmark  
30a1 ..			.dmark: db "LP<"  
30a4 f1			.pastdmark: pop af  
30a5			endm  
# End of macro DMARK
30a5					CALLMONITOR 
30a5 cd 0e 14			call break_point_state  
30a8				endm  
# End of macro CALLMONITOR
30a8				endif 
30a8 c3 95 1d			jp exec1 
30ab			 
30ab					 
30ab			 
30ab			 
30ab					NEXTW 
30ab c3 04 1d			jp macro_next 
30ae				endm 
# End of macro NEXTW
30ae			.I:  
30ae			 
30ae				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
30ae 5e				db WORD_SYS_CORE+74             
30af d9 30			dw .DLOOP            
30b1 02				db 1 + 1 
30b2 .. 00			db "I",0              
30b4				endm 
# End of macro CWHEAD
30b4			; | I ( -- ) Current loop counter | DONE 
30b4					if DEBUG_FORTH_WORDS_KEY 
30b4						DMARK "I.." 
30b4 f5				push af  
30b5 3a c9 30			ld a, (.dmark)  
30b8 32 7a ee			ld (debug_mark),a  
30bb 3a ca 30			ld a, (.dmark+1)  
30be 32 7b ee			ld (debug_mark+1),a  
30c1 3a cb 30			ld a, (.dmark+2)  
30c4 32 7c ee			ld (debug_mark+2),a  
30c7 18 03			jr .pastdmark  
30c9 ..			.dmark: db "I.."  
30cc f1			.pastdmark: pop af  
30cd			endm  
# End of macro DMARK
30cd						CALLMONITOR 
30cd cd 0e 14			call break_point_state  
30d0				endm  
# End of macro CALLMONITOR
30d0					endif 
30d0			 
30d0 2a 85 e6				ld hl,(os_current_i) 
30d3 cd 9b 19				call forth_push_numhl 
30d6			 
30d6					NEXTW 
30d6 c3 04 1d			jp macro_next 
30d9				endm 
# End of macro NEXTW
30d9			.DLOOP: 
30d9				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
30d9 5f				db WORD_SYS_CORE+75             
30da ba 31			dw .REPEAT            
30dc 06				db 5 + 1 
30dd .. 00			db "-LOOP",0              
30e3				endm 
# End of macro CWHEAD
30e3			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
30e3				; pop tos as current loop count to hl 
30e3					if DEBUG_FORTH_WORDS_KEY 
30e3						DMARK "-LP" 
30e3 f5				push af  
30e4 3a f8 30			ld a, (.dmark)  
30e7 32 7a ee			ld (debug_mark),a  
30ea 3a f9 30			ld a, (.dmark+1)  
30ed 32 7b ee			ld (debug_mark+1),a  
30f0 3a fa 30			ld a, (.dmark+2)  
30f3 32 7c ee			ld (debug_mark+2),a  
30f6 18 03			jr .pastdmark  
30f8 ..			.dmark: db "-LP"  
30fb f1			.pastdmark: pop af  
30fc			endm  
# End of macro DMARK
30fc						CALLMONITOR 
30fc cd 0e 14			call break_point_state  
30ff				endm  
# End of macro CALLMONITOR
30ff					endif 
30ff			 
30ff				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
30ff			 
30ff				FORTH_LOOP_TOS 
30ff cd f6 1b			call macro_forth_loop_tos 
3102				endm 
# End of macro FORTH_LOOP_TOS
3102 e5				push hl 
3103			 
3103					if DEBUG_FORTH_WORDS 
3103						DMARK "-LP" 
3103 f5				push af  
3104 3a 18 31			ld a, (.dmark)  
3107 32 7a ee			ld (debug_mark),a  
310a 3a 19 31			ld a, (.dmark+1)  
310d 32 7b ee			ld (debug_mark+1),a  
3110 3a 1a 31			ld a, (.dmark+2)  
3113 32 7c ee			ld (debug_mark+2),a  
3116 18 03			jr .pastdmark  
3118 ..			.dmark: db "-LP"  
311b f1			.pastdmark: pop af  
311c			endm  
# End of macro DMARK
311c						CALLMONITOR 
311c cd 0e 14			call break_point_state  
311f				endm  
# End of macro CALLMONITOR
311f					endif 
311f				; next item on the stack is the limit. get it 
311f			 
311f			 
311f				FORTH_LOOP_POP 
311f cd 00 1c			call macro_forth_loop_pop 
3122				endm 
# End of macro FORTH_LOOP_POP
3122			 
3122				FORTH_LOOP_TOS 
3122 cd f6 1b			call macro_forth_loop_tos 
3125				endm 
# End of macro FORTH_LOOP_TOS
3125			 
3125 d1				pop de		 ; de = i, hl = limit 
3126			 
3126					if DEBUG_FORTH_WORDS 
3126						DMARK "-L1" 
3126 f5				push af  
3127 3a 3b 31			ld a, (.dmark)  
312a 32 7a ee			ld (debug_mark),a  
312d 3a 3c 31			ld a, (.dmark+1)  
3130 32 7b ee			ld (debug_mark+1),a  
3133 3a 3d 31			ld a, (.dmark+2)  
3136 32 7c ee			ld (debug_mark+2),a  
3139 18 03			jr .pastdmark  
313b ..			.dmark: db "-L1"  
313e f1			.pastdmark: pop af  
313f			endm  
# End of macro DMARK
313f						CALLMONITOR 
313f cd 0e 14			call break_point_state  
3142				endm  
# End of macro CALLMONITOR
3142					endif 
3142			 
3142				; go back to previous word 
3142			 
3142 d5				push de    ; save I for inc later 
3143			 
3143			 
3143				; get limit 
3143				;  is I at limit? 
3143			 
3143			 
3143					if DEBUG_FORTH_WORDS 
3143						DMARK "-L1" 
3143 f5				push af  
3144 3a 58 31			ld a, (.dmark)  
3147 32 7a ee			ld (debug_mark),a  
314a 3a 59 31			ld a, (.dmark+1)  
314d 32 7b ee			ld (debug_mark+1),a  
3150 3a 5a 31			ld a, (.dmark+2)  
3153 32 7c ee			ld (debug_mark+2),a  
3156 18 03			jr .pastdmark  
3158 ..			.dmark: db "-L1"  
315b f1			.pastdmark: pop af  
315c			endm  
# End of macro DMARK
315c						CALLMONITOR 
315c cd 0e 14			call break_point_state  
315f				endm  
# End of macro CALLMONITOR
315f					endif 
315f			 
315f ed 52			sbc hl, de 
3161			 
3161			 
3161				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3161			 
3161 20 26				jr nz, .mloopnotdone 
3163			 
3163 e1				pop hl   ; get rid of saved I 
3164				FORTH_LOOP_POP     ; get rid of limit 
3164 cd 00 1c			call macro_forth_loop_pop 
3167				endm 
# End of macro FORTH_LOOP_POP
3167			 
3167				FORTH_RSP_POP     ; get rid of DO ptr 
3167 cd 63 19			call macro_forth_rsp_pop 
316a				endm 
# End of macro FORTH_RSP_POP
316a			 
316a			if DEBUG_FORTH_WORDS 
316a						DMARK "-L>" 
316a f5				push af  
316b 3a 7f 31			ld a, (.dmark)  
316e 32 7a ee			ld (debug_mark),a  
3171 3a 80 31			ld a, (.dmark+1)  
3174 32 7b ee			ld (debug_mark+1),a  
3177 3a 81 31			ld a, (.dmark+2)  
317a 32 7c ee			ld (debug_mark+2),a  
317d 18 03			jr .pastdmark  
317f ..			.dmark: db "-L>"  
3182 f1			.pastdmark: pop af  
3183			endm  
# End of macro DMARK
3183				CALLMONITOR 
3183 cd 0e 14			call break_point_state  
3186				endm  
# End of macro CALLMONITOR
3186			endif 
3186			 
3186					NEXTW 
3186 c3 04 1d			jp macro_next 
3189				endm 
# End of macro NEXTW
3189				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3189			 
3189			.mloopnotdone: 
3189			 
3189 e1				pop hl    ; get I 
318a 2b				dec hl 
318b			 
318b			   	; save new I 
318b			 
318b			 
318b					; set I counter 
318b			 
318b 22 85 e6				ld (os_current_i), hl 
318e			 
318e					 
318e				FORTH_LOOP_NEXT 
318e cd c3 1b			call macro_forth_loop_next 
3191				endm 
# End of macro FORTH_LOOP_NEXT
3191			 
3191			 
3191					if DEBUG_FORTH_WORDS 
3191 eb						ex de,hl 
3192					endif 
3192			 
3192			;	; get DO ptr 
3192			; 
3192				FORTH_RSP_TOS 
3192 cd 59 19			call macro_forth_rsp_tos 
3195				endm 
# End of macro FORTH_RSP_TOS
3195			 
3195				;push hl 
3195			 
3195				; not going to DO any more 
3195				; get rid of the RSP pointer as DO will add it back in 
3195				;FORTH_RSP_POP 
3195				;pop hl 
3195			 
3195			 
3195 22 61 e6			ld (os_tok_ptr), hl 
3198					if DEBUG_FORTH_WORDS 
3198						DMARK "-L<" 
3198 f5				push af  
3199 3a ad 31			ld a, (.dmark)  
319c 32 7a ee			ld (debug_mark),a  
319f 3a ae 31			ld a, (.dmark+1)  
31a2 32 7b ee			ld (debug_mark+1),a  
31a5 3a af 31			ld a, (.dmark+2)  
31a8 32 7c ee			ld (debug_mark+2),a  
31ab 18 03			jr .pastdmark  
31ad ..			.dmark: db "-L<"  
31b0 f1			.pastdmark: pop af  
31b1			endm  
# End of macro DMARK
31b1					CALLMONITOR 
31b1 cd 0e 14			call break_point_state  
31b4				endm  
# End of macro CALLMONITOR
31b4				endif 
31b4 c3 95 1d			jp exec1 
31b7			 
31b7					 
31b7			 
31b7			 
31b7			 
31b7				NEXTW 
31b7 c3 04 1d			jp macro_next 
31ba				endm 
# End of macro NEXTW
31ba			 
31ba			 
31ba			 
31ba			 
31ba			.REPEAT: 
31ba				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
31ba 71				db WORD_SYS_CORE+93             
31bb 0d 32			dw .UNTIL            
31bd 06				db 5 + 1 
31be .. 00			db "REPEAT",0              
31c5				endm 
# End of macro CWHEAD
31c5			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
31c5			;  push pc to rsp stack past the REPEAT 
31c5					if DEBUG_FORTH_WORDS_KEY 
31c5						DMARK "REP" 
31c5 f5				push af  
31c6 3a da 31			ld a, (.dmark)  
31c9 32 7a ee			ld (debug_mark),a  
31cc 3a db 31			ld a, (.dmark+1)  
31cf 32 7b ee			ld (debug_mark+1),a  
31d2 3a dc 31			ld a, (.dmark+2)  
31d5 32 7c ee			ld (debug_mark+2),a  
31d8 18 03			jr .pastdmark  
31da ..			.dmark: db "REP"  
31dd f1			.pastdmark: pop af  
31de			endm  
# End of macro DMARK
31de						CALLMONITOR 
31de cd 0e 14			call break_point_state  
31e1				endm  
# End of macro CALLMONITOR
31e1					endif 
31e1			 
31e1 2a 61 e6				ld hl, (os_tok_ptr) 
31e4 23					inc hl   ; R 
31e5 23					inc hl  ; E 
31e6 23					inc hl   ; P 
31e7 23					inc hl   ; E 
31e8 23					inc hl   ; A 
31e9 23					inc hl   ; T 
31ea 23					inc hl   ; zero 
31eb					FORTH_RSP_NEXT 
31eb cd 42 19			call macro_forth_rsp_next 
31ee				endm 
# End of macro FORTH_RSP_NEXT
31ee			 
31ee			 
31ee					if DEBUG_FORTH_WORDS 
31ee						DMARK "REP" 
31ee f5				push af  
31ef 3a 03 32			ld a, (.dmark)  
31f2 32 7a ee			ld (debug_mark),a  
31f5 3a 04 32			ld a, (.dmark+1)  
31f8 32 7b ee			ld (debug_mark+1),a  
31fb 3a 05 32			ld a, (.dmark+2)  
31fe 32 7c ee			ld (debug_mark+2),a  
3201 18 03			jr .pastdmark  
3203 ..			.dmark: db "REP"  
3206 f1			.pastdmark: pop af  
3207			endm  
# End of macro DMARK
3207						;pop bc    ; TODO BUG ?????? what is this for???? 
3207						CALLMONITOR 
3207 cd 0e 14			call break_point_state  
320a				endm  
# End of macro CALLMONITOR
320a					endif 
320a			 
320a					NEXTW 
320a c3 04 1d			jp macro_next 
320d				endm 
# End of macro NEXTW
320d			;	       NEXTW 
320d			 
320d			.UNTIL: 
320d				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
320d 72				db WORD_SYS_CORE+94             
320e a4 32			dw .ENDFLOW            
3210 06				db 5 + 1 
3211 .. 00			db "UNTIL",0              
3217				endm 
# End of macro CWHEAD
3217			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3217			 
3217				; pop tos as check 
3217			 
3217				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3217			 
3217				FORTH_DSP_VALUEHL 
3217 cd 92 1b			call macro_dsp_valuehl 
321a				endm 
# End of macro FORTH_DSP_VALUEHL
321a			 
321a					if DEBUG_FORTH_WORDS_KEY 
321a						DMARK "UNT" 
321a f5				push af  
321b 3a 2f 32			ld a, (.dmark)  
321e 32 7a ee			ld (debug_mark),a  
3221 3a 30 32			ld a, (.dmark+1)  
3224 32 7b ee			ld (debug_mark+1),a  
3227 3a 31 32			ld a, (.dmark+2)  
322a 32 7c ee			ld (debug_mark+2),a  
322d 18 03			jr .pastdmark  
322f ..			.dmark: db "UNT"  
3232 f1			.pastdmark: pop af  
3233			endm  
# End of macro DMARK
3233						CALLMONITOR 
3233 cd 0e 14			call break_point_state  
3236				endm  
# End of macro CALLMONITOR
3236					endif 
3236			 
3236			;	push hl 
3236				FORTH_DSP_POP 
3236 cd 4a 1c			call macro_forth_dsp_pop 
3239				endm 
# End of macro FORTH_DSP_POP
3239			 
3239			;	pop hl 
3239			 
3239				; test if true 
3239			 
3239 cd db 0b			call ishlzero 
323c			;	ld a,l 
323c			;	add h 
323c			; 
323c			;	cp 0 
323c			 
323c 20 3e			jr nz, .untilnotdone 
323e			 
323e					if DEBUG_FORTH_WORDS 
323e						DMARK "UNf" 
323e f5				push af  
323f 3a 53 32			ld a, (.dmark)  
3242 32 7a ee			ld (debug_mark),a  
3245 3a 54 32			ld a, (.dmark+1)  
3248 32 7b ee			ld (debug_mark+1),a  
324b 3a 55 32			ld a, (.dmark+2)  
324e 32 7c ee			ld (debug_mark+2),a  
3251 18 03			jr .pastdmark  
3253 ..			.dmark: db "UNf"  
3256 f1			.pastdmark: pop af  
3257			endm  
# End of macro DMARK
3257						CALLMONITOR 
3257 cd 0e 14			call break_point_state  
325a				endm  
# End of macro CALLMONITOR
325a					endif 
325a			 
325a			 
325a			 
325a				FORTH_RSP_POP     ; get rid of DO ptr 
325a cd 63 19			call macro_forth_rsp_pop 
325d				endm 
# End of macro FORTH_RSP_POP
325d			 
325d			if DEBUG_FORTH_WORDS 
325d						DMARK "UN>" 
325d f5				push af  
325e 3a 72 32			ld a, (.dmark)  
3261 32 7a ee			ld (debug_mark),a  
3264 3a 73 32			ld a, (.dmark+1)  
3267 32 7b ee			ld (debug_mark+1),a  
326a 3a 74 32			ld a, (.dmark+2)  
326d 32 7c ee			ld (debug_mark+2),a  
3270 18 03			jr .pastdmark  
3272 ..			.dmark: db "UN>"  
3275 f1			.pastdmark: pop af  
3276			endm  
# End of macro DMARK
3276				CALLMONITOR 
3276 cd 0e 14			call break_point_state  
3279				endm  
# End of macro CALLMONITOR
3279			endif 
3279			 
3279					NEXTW 
3279 c3 04 1d			jp macro_next 
327c				endm 
# End of macro NEXTW
327c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
327c			 
327c			.untilnotdone: 
327c			 
327c			 
327c			;	; get DO ptr 
327c			; 
327c				FORTH_RSP_TOS 
327c cd 59 19			call macro_forth_rsp_tos 
327f				endm 
# End of macro FORTH_RSP_TOS
327f			 
327f				;push hl 
327f			 
327f				; not going to DO any more 
327f				; get rid of the RSP pointer as DO will add it back in 
327f				;FORTH_RSP_POP 
327f				;pop hl 
327f			 
327f			 
327f 22 61 e6			ld (os_tok_ptr), hl 
3282					if DEBUG_FORTH_WORDS 
3282						DMARK "UN<" 
3282 f5				push af  
3283 3a 97 32			ld a, (.dmark)  
3286 32 7a ee			ld (debug_mark),a  
3289 3a 98 32			ld a, (.dmark+1)  
328c 32 7b ee			ld (debug_mark+1),a  
328f 3a 99 32			ld a, (.dmark+2)  
3292 32 7c ee			ld (debug_mark+2),a  
3295 18 03			jr .pastdmark  
3297 ..			.dmark: db "UN<"  
329a f1			.pastdmark: pop af  
329b			endm  
# End of macro DMARK
329b					CALLMONITOR 
329b cd 0e 14			call break_point_state  
329e				endm  
# End of macro CALLMONITOR
329e				endif 
329e c3 95 1d			jp exec1 
32a1			 
32a1					 
32a1			 
32a1			 
32a1					NEXTW 
32a1 c3 04 1d			jp macro_next 
32a4				endm 
# End of macro NEXTW
32a4			 
32a4			 
32a4			.ENDFLOW: 
32a4			 
32a4			; eof 
32a4			 
# End of file forth_words_flow.asm
32a4			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
32a4			include "forth_words_logic.asm" 
32a4			 
32a4			; | ## Logic Words 
32a4			 
32a4			.NOT: 
32a4				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
32a4 2d				db WORD_SYS_CORE+25             
32a5 ec 32			dw .IS            
32a7 04				db 3 + 1 
32a8 .. 00			db "NOT",0              
32ac				endm 
# End of macro CWHEAD
32ac			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
32ac					if DEBUG_FORTH_WORDS_KEY 
32ac						DMARK "NOT" 
32ac f5				push af  
32ad 3a c1 32			ld a, (.dmark)  
32b0 32 7a ee			ld (debug_mark),a  
32b3 3a c2 32			ld a, (.dmark+1)  
32b6 32 7b ee			ld (debug_mark+1),a  
32b9 3a c3 32			ld a, (.dmark+2)  
32bc 32 7c ee			ld (debug_mark+2),a  
32bf 18 03			jr .pastdmark  
32c1 ..			.dmark: db "NOT"  
32c4 f1			.pastdmark: pop af  
32c5			endm  
# End of macro DMARK
32c5						CALLMONITOR 
32c5 cd 0e 14			call break_point_state  
32c8				endm  
# End of macro CALLMONITOR
32c8					endif 
32c8					FORTH_DSP 
32c8 cd 58 1b			call macro_forth_dsp 
32cb				endm 
# End of macro FORTH_DSP
32cb 7e					ld a,(hl)	; get type of value on TOS 
32cc fe 02				cp DS_TYPE_INUM  
32ce 28 03				jr z, .noti 
32d0					NEXTW 
32d0 c3 04 1d			jp macro_next 
32d3				endm 
# End of macro NEXTW
32d3			.noti:          FORTH_DSP_VALUEHL 
32d3 cd 92 1b			call macro_dsp_valuehl 
32d6				endm 
# End of macro FORTH_DSP_VALUEHL
32d6			;		push hl 
32d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32d6 cd 4a 1c			call macro_forth_dsp_pop 
32d9				endm 
# End of macro FORTH_DSP_POP
32d9			;		pop hl 
32d9 3e 00				ld a,0 
32db bd					cp l 
32dc 28 04				jr z, .not2t 
32de 2e 00				ld l, 0 
32e0 18 02				jr .notip 
32e2			 
32e2 2e ff		.not2t:		ld l, 255 
32e4			 
32e4 26 00		.notip:		ld h, 0	 
32e6			 
32e6 cd 9b 19				call forth_push_numhl 
32e9					NEXTW 
32e9 c3 04 1d			jp macro_next 
32ec				endm 
# End of macro NEXTW
32ec			 
32ec			.IS: 
32ec				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
32ec 2d				db WORD_SYS_CORE+25             
32ed 12 33			dw .LZERO            
32ef 03				db 2 + 1 
32f0 .. 00			db "IS",0              
32f3				endm 
# End of macro CWHEAD
32f3			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
32f3					if DEBUG_FORTH_WORDS_KEY 
32f3						DMARK "IS." 
32f3 f5				push af  
32f4 3a 08 33			ld a, (.dmark)  
32f7 32 7a ee			ld (debug_mark),a  
32fa 3a 09 33			ld a, (.dmark+1)  
32fd 32 7b ee			ld (debug_mark+1),a  
3300 3a 0a 33			ld a, (.dmark+2)  
3303 32 7c ee			ld (debug_mark+2),a  
3306 18 03			jr .pastdmark  
3308 ..			.dmark: db "IS."  
330b f1			.pastdmark: pop af  
330c			endm  
# End of macro DMARK
330c						CALLMONITOR 
330c cd 0e 14			call break_point_state  
330f				endm  
# End of macro CALLMONITOR
330f					endif 
330f					NEXTW 
330f c3 04 1d			jp macro_next 
3312				endm 
# End of macro NEXTW
3312			.LZERO: 
3312				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3312 2d				db WORD_SYS_CORE+25             
3313 1c 33			dw .TZERO            
3315 03				db 2 + 1 
3316 .. 00			db "0<",0              
3319				endm 
# End of macro CWHEAD
3319			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3319					NEXTW 
3319 c3 04 1d			jp macro_next 
331c				endm 
# End of macro NEXTW
331c			.TZERO: 
331c				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
331c 2e				db WORD_SYS_CORE+26             
331d 63 33			dw .LESS            
331f 03				db 2 + 1 
3320 .. 00			db "0=",0              
3323				endm 
# End of macro CWHEAD
3323			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3323				; TODO add floating point number detection 
3323					;v5 FORTH_DSP_VALUE 
3323					if DEBUG_FORTH_WORDS_KEY 
3323						DMARK "0=." 
3323 f5				push af  
3324 3a 38 33			ld a, (.dmark)  
3327 32 7a ee			ld (debug_mark),a  
332a 3a 39 33			ld a, (.dmark+1)  
332d 32 7b ee			ld (debug_mark+1),a  
3330 3a 3a 33			ld a, (.dmark+2)  
3333 32 7c ee			ld (debug_mark+2),a  
3336 18 03			jr .pastdmark  
3338 ..			.dmark: db "0=."  
333b f1			.pastdmark: pop af  
333c			endm  
# End of macro DMARK
333c						CALLMONITOR 
333c cd 0e 14			call break_point_state  
333f				endm  
# End of macro CALLMONITOR
333f					endif 
333f					FORTH_DSP 
333f cd 58 1b			call macro_forth_dsp 
3342				endm 
# End of macro FORTH_DSP
3342 7e					ld a,(hl)	; get type of value on TOS 
3343 fe 02				cp DS_TYPE_INUM  
3345 28 00				jr z, .tz_inum 
3347			 
3347				if FORTH_ENABLE_FLOATMATH 
3347					jr .tz_done 
3347			 
3347				endif 
3347					 
3347			 
3347			.tz_inum: 
3347					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3347 cd 92 1b			call macro_dsp_valuehl 
334a				endm 
# End of macro FORTH_DSP_VALUEHL
334a			 
334a			;		push hl 
334a			 
334a					; destroy value TOS 
334a			 
334a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
334a cd 4a 1c			call macro_forth_dsp_pop 
334d				endm 
# End of macro FORTH_DSP_POP
334d			 
334d			;		pop hl 
334d			 
334d 3e 00				ld a,0 
334f			 
334f bd					cp l 
3350 20 08				jr nz, .tz_notzero 
3352			 
3352 bc					cp h 
3353			 
3353 20 05				jr nz, .tz_notzero 
3355			 
3355			 
3355 21 01 00				ld hl, FORTH_TRUE 
3358 18 03				jr .tz_done 
335a			 
335a 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
335d			 
335d					; push value back onto stack for another op etc 
335d			 
335d			.tz_done: 
335d cd 9b 19				call forth_push_numhl 
3360			 
3360					NEXTW 
3360 c3 04 1d			jp macro_next 
3363				endm 
# End of macro NEXTW
3363			.LESS: 
3363				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3363 2f				db WORD_SYS_CORE+27             
3364 cc 33			dw .GT            
3366 02				db 1 + 1 
3367 .. 00			db "<",0              
3369				endm 
# End of macro CWHEAD
3369			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3369				; TODO add floating point number detection 
3369					if DEBUG_FORTH_WORDS_KEY 
3369						DMARK "LES" 
3369 f5				push af  
336a 3a 7e 33			ld a, (.dmark)  
336d 32 7a ee			ld (debug_mark),a  
3370 3a 7f 33			ld a, (.dmark+1)  
3373 32 7b ee			ld (debug_mark+1),a  
3376 3a 80 33			ld a, (.dmark+2)  
3379 32 7c ee			ld (debug_mark+2),a  
337c 18 03			jr .pastdmark  
337e ..			.dmark: db "LES"  
3381 f1			.pastdmark: pop af  
3382			endm  
# End of macro DMARK
3382						CALLMONITOR 
3382 cd 0e 14			call break_point_state  
3385				endm  
# End of macro CALLMONITOR
3385					endif 
3385					FORTH_DSP 
3385 cd 58 1b			call macro_forth_dsp 
3388				endm 
# End of macro FORTH_DSP
3388					;v5 FORTH_DSP_VALUE 
3388 7e					ld a,(hl)	; get type of value on TOS 
3389 fe 02				cp DS_TYPE_INUM  
338b 28 00				jr z, .less_inum 
338d			 
338d				if FORTH_ENABLE_FLOATMATH 
338d					jr .less_done 
338d			 
338d				endif 
338d					 
338d			 
338d			.less_inum: 
338d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
338d cd 92 1b			call macro_dsp_valuehl 
3390				endm 
# End of macro FORTH_DSP_VALUEHL
3390			 
3390 e5					push hl  ; u2 
3391			 
3391					; destroy value TOS 
3391			 
3391					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3391 cd 4a 1c			call macro_forth_dsp_pop 
3394				endm 
# End of macro FORTH_DSP_POP
3394			 
3394			 
3394					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3394 cd 92 1b			call macro_dsp_valuehl 
3397				endm 
# End of macro FORTH_DSP_VALUEHL
3397			 
3397 e5					push hl    ; u1 
3398			 
3398					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3398 cd 4a 1c			call macro_forth_dsp_pop 
339b				endm 
# End of macro FORTH_DSP_POP
339b			 
339b			 
339b b7			 or a      ;clear carry flag 
339c 01 00 00		 ld bc, FORTH_FALSE 
339f e1			  pop hl    ; u1 
33a0 d1			  pop de    ; u2 
33a1 ed 52		  sbc hl,de 
33a3 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
33a5			 
33a5 01 01 00		 ld bc, FORTH_TRUE 
33a8			.lscont:  
33a8 c5					push bc 
33a9 e1					pop hl 
33aa			 
33aa					if DEBUG_FORTH_WORDS 
33aa						DMARK "LT1" 
33aa f5				push af  
33ab 3a bf 33			ld a, (.dmark)  
33ae 32 7a ee			ld (debug_mark),a  
33b1 3a c0 33			ld a, (.dmark+1)  
33b4 32 7b ee			ld (debug_mark+1),a  
33b7 3a c1 33			ld a, (.dmark+2)  
33ba 32 7c ee			ld (debug_mark+2),a  
33bd 18 03			jr .pastdmark  
33bf ..			.dmark: db "LT1"  
33c2 f1			.pastdmark: pop af  
33c3			endm  
# End of macro DMARK
33c3						CALLMONITOR 
33c3 cd 0e 14			call break_point_state  
33c6				endm  
# End of macro CALLMONITOR
33c6					endif 
33c6 cd 9b 19				call forth_push_numhl 
33c9			 
33c9					NEXTW 
33c9 c3 04 1d			jp macro_next 
33cc				endm 
# End of macro NEXTW
33cc			.GT: 
33cc				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
33cc 30				db WORD_SYS_CORE+28             
33cd 35 34			dw .EQUAL            
33cf 02				db 1 + 1 
33d0 .. 00			db ">",0              
33d2				endm 
# End of macro CWHEAD
33d2			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
33d2				; TODO add floating point number detection 
33d2					if DEBUG_FORTH_WORDS_KEY 
33d2						DMARK "GRT" 
33d2 f5				push af  
33d3 3a e7 33			ld a, (.dmark)  
33d6 32 7a ee			ld (debug_mark),a  
33d9 3a e8 33			ld a, (.dmark+1)  
33dc 32 7b ee			ld (debug_mark+1),a  
33df 3a e9 33			ld a, (.dmark+2)  
33e2 32 7c ee			ld (debug_mark+2),a  
33e5 18 03			jr .pastdmark  
33e7 ..			.dmark: db "GRT"  
33ea f1			.pastdmark: pop af  
33eb			endm  
# End of macro DMARK
33eb						CALLMONITOR 
33eb cd 0e 14			call break_point_state  
33ee				endm  
# End of macro CALLMONITOR
33ee					endif 
33ee					FORTH_DSP 
33ee cd 58 1b			call macro_forth_dsp 
33f1				endm 
# End of macro FORTH_DSP
33f1					;FORTH_DSP_VALUE 
33f1 7e					ld a,(hl)	; get type of value on TOS 
33f2 fe 02				cp DS_TYPE_INUM  
33f4 28 00				jr z, .gt_inum 
33f6			 
33f6				if FORTH_ENABLE_FLOATMATH 
33f6					jr .gt_done 
33f6			 
33f6				endif 
33f6					 
33f6			 
33f6			.gt_inum: 
33f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33f6 cd 92 1b			call macro_dsp_valuehl 
33f9				endm 
# End of macro FORTH_DSP_VALUEHL
33f9			 
33f9 e5					push hl  ; u2 
33fa			 
33fa					; destroy value TOS 
33fa			 
33fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33fa cd 4a 1c			call macro_forth_dsp_pop 
33fd				endm 
# End of macro FORTH_DSP_POP
33fd			 
33fd			 
33fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33fd cd 92 1b			call macro_dsp_valuehl 
3400				endm 
# End of macro FORTH_DSP_VALUEHL
3400			 
3400 e5					push hl    ; u1 
3401			 
3401					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3401 cd 4a 1c			call macro_forth_dsp_pop 
3404				endm 
# End of macro FORTH_DSP_POP
3404			 
3404			 
3404 b7			 or a      ;clear carry flag 
3405 01 00 00		 ld bc, FORTH_FALSE 
3408 e1			  pop hl    ; u1 
3409 d1			  pop de    ; u2 
340a ed 52		  sbc hl,de 
340c 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
340e			 
340e 01 01 00		 ld bc, FORTH_TRUE 
3411			.gtcont:  
3411 c5					push bc 
3412 e1					pop hl 
3413			 
3413					if DEBUG_FORTH_WORDS 
3413						DMARK "GT1" 
3413 f5				push af  
3414 3a 28 34			ld a, (.dmark)  
3417 32 7a ee			ld (debug_mark),a  
341a 3a 29 34			ld a, (.dmark+1)  
341d 32 7b ee			ld (debug_mark+1),a  
3420 3a 2a 34			ld a, (.dmark+2)  
3423 32 7c ee			ld (debug_mark+2),a  
3426 18 03			jr .pastdmark  
3428 ..			.dmark: db "GT1"  
342b f1			.pastdmark: pop af  
342c			endm  
# End of macro DMARK
342c						CALLMONITOR 
342c cd 0e 14			call break_point_state  
342f				endm  
# End of macro CALLMONITOR
342f					endif 
342f cd 9b 19				call forth_push_numhl 
3432			 
3432					NEXTW 
3432 c3 04 1d			jp macro_next 
3435				endm 
# End of macro NEXTW
3435			.EQUAL: 
3435				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3435 31				db WORD_SYS_CORE+29             
3436 a0 34			dw .ENDLOGIC            
3438 02				db 1 + 1 
3439 .. 00			db "=",0              
343b				endm 
# End of macro CWHEAD
343b			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
343b				; TODO add floating point number detection 
343b					if DEBUG_FORTH_WORDS_KEY 
343b						DMARK "EQ." 
343b f5				push af  
343c 3a 50 34			ld a, (.dmark)  
343f 32 7a ee			ld (debug_mark),a  
3442 3a 51 34			ld a, (.dmark+1)  
3445 32 7b ee			ld (debug_mark+1),a  
3448 3a 52 34			ld a, (.dmark+2)  
344b 32 7c ee			ld (debug_mark+2),a  
344e 18 03			jr .pastdmark  
3450 ..			.dmark: db "EQ."  
3453 f1			.pastdmark: pop af  
3454			endm  
# End of macro DMARK
3454						CALLMONITOR 
3454 cd 0e 14			call break_point_state  
3457				endm  
# End of macro CALLMONITOR
3457					endif 
3457					FORTH_DSP 
3457 cd 58 1b			call macro_forth_dsp 
345a				endm 
# End of macro FORTH_DSP
345a					;v5 FORTH_DSP_VALUE 
345a 7e					ld a,(hl)	; get type of value on TOS 
345b fe 02				cp DS_TYPE_INUM  
345d 28 00				jr z, .eq_inum 
345f			 
345f				if FORTH_ENABLE_FLOATMATH 
345f					jr .eq_done 
345f			 
345f				endif 
345f					 
345f			 
345f			.eq_inum: 
345f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
345f cd 92 1b			call macro_dsp_valuehl 
3462				endm 
# End of macro FORTH_DSP_VALUEHL
3462			 
3462 e5					push hl 
3463			 
3463					; destroy value TOS 
3463			 
3463					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3463 cd 4a 1c			call macro_forth_dsp_pop 
3466				endm 
# End of macro FORTH_DSP_POP
3466			 
3466			 
3466					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3466 cd 92 1b			call macro_dsp_valuehl 
3469				endm 
# End of macro FORTH_DSP_VALUEHL
3469			 
3469					; one value on hl get other one back 
3469			 
3469 e5					push hl 
346a			 
346a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
346a cd 4a 1c			call macro_forth_dsp_pop 
346d				endm 
# End of macro FORTH_DSP_POP
346d			 
346d 0e 00				ld c, FORTH_FALSE 
346f			 
346f e1					pop hl 
3470 d1					pop de 
3471			 
3471 7b					ld a, e 
3472 bd					cp l 
3473			 
3473 20 06				jr nz, .eq_done 
3475			 
3475 7a					ld a, d 
3476 bc					cp h 
3477			 
3477 20 02				jr nz, .eq_done 
3479			 
3479 0e 01				ld c, FORTH_TRUE 
347b					 
347b			 
347b			 
347b			.eq_done: 
347b			 
347b					; TODO push value back onto stack for another op etc 
347b			 
347b 26 00				ld h, 0 
347d 69					ld l, c 
347e					if DEBUG_FORTH_WORDS 
347e						DMARK "EQ1" 
347e f5				push af  
347f 3a 93 34			ld a, (.dmark)  
3482 32 7a ee			ld (debug_mark),a  
3485 3a 94 34			ld a, (.dmark+1)  
3488 32 7b ee			ld (debug_mark+1),a  
348b 3a 95 34			ld a, (.dmark+2)  
348e 32 7c ee			ld (debug_mark+2),a  
3491 18 03			jr .pastdmark  
3493 ..			.dmark: db "EQ1"  
3496 f1			.pastdmark: pop af  
3497			endm  
# End of macro DMARK
3497						CALLMONITOR 
3497 cd 0e 14			call break_point_state  
349a				endm  
# End of macro CALLMONITOR
349a					endif 
349a cd 9b 19				call forth_push_numhl 
349d			 
349d					NEXTW 
349d c3 04 1d			jp macro_next 
34a0				endm 
# End of macro NEXTW
34a0			 
34a0			 
34a0			.ENDLOGIC: 
34a0			; eof 
34a0			 
34a0			 
# End of file forth_words_logic.asm
34a0			include "forth_words_maths.asm" 
34a0			 
34a0			; | ## Maths Words 
34a0			 
34a0			.PLUS:	 
34a0				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
34a0 15				db WORD_SYS_CORE+1             
34a1 e2 34			dw .NEG            
34a3 02				db 1 + 1 
34a4 .. 00			db "+",0              
34a6				endm 
# End of macro CWHEAD
34a6			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
34a6					if DEBUG_FORTH_WORDS_KEY 
34a6						DMARK "PLU" 
34a6 f5				push af  
34a7 3a bb 34			ld a, (.dmark)  
34aa 32 7a ee			ld (debug_mark),a  
34ad 3a bc 34			ld a, (.dmark+1)  
34b0 32 7b ee			ld (debug_mark+1),a  
34b3 3a bd 34			ld a, (.dmark+2)  
34b6 32 7c ee			ld (debug_mark+2),a  
34b9 18 03			jr .pastdmark  
34bb ..			.dmark: db "PLU"  
34be f1			.pastdmark: pop af  
34bf			endm  
# End of macro DMARK
34bf						CALLMONITOR 
34bf cd 0e 14			call break_point_state  
34c2				endm  
# End of macro CALLMONITOR
34c2					endif 
34c2					; add top two values and push back result 
34c2			 
34c2					;for v5 FORTH_DSP_VALUE 
34c2					FORTH_DSP 
34c2 cd 58 1b			call macro_forth_dsp 
34c5				endm 
# End of macro FORTH_DSP
34c5 7e					ld a,(hl)	; get type of value on TOS 
34c6 fe 02				cp DS_TYPE_INUM  
34c8 28 03				jr z, .dot_inum 
34ca			 
34ca					NEXTW 
34ca c3 04 1d			jp macro_next 
34cd				endm 
# End of macro NEXTW
34cd			 
34cd			; float maths 
34cd			 
34cd				if FORTH_ENABLE_FLOATMATH 
34cd						inc hl      ; now at start of numeric as string 
34cd			 
34cd					if DEBUG_FORTH_MATHS 
34cd						DMARK "ADD" 
34cd				CALLMONITOR 
34cd					endif 
34cd			 
34cd					;ld ix, hl 
34cd					call CON 
34cd			 
34cd			 
34cd					push hl 
34cd					 
34cd					 
34cd			 
34cd						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
34cd			 
34cd					; get next number 
34cd			 
34cd						FORTH_DSP_VALUE 
34cd			 
34cd						inc hl      ; now at start of numeric as string 
34cd			 
34cd					;ld ix, hl 
34cd					call CON 
34cd			 
34cd					push hl 
34cd			 
34cd			 
34cd						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34cd			 
34cd						; TODO do add 
34cd			 
34cd						call IADD 
34cd			 
34cd						; TODO get result back as ascii 
34cd			 
34cd						; TODO push result  
34cd			 
34cd			 
34cd			 
34cd						jr .dot_done 
34cd				endif 
34cd			 
34cd			.dot_inum: 
34cd			 
34cd			 
34cd					if DEBUG_FORTH_DOT 
34cd						DMARK "+IT" 
34cd				CALLMONITOR 
34cd					endif 
34cd			 
34cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34cd cd 92 1b			call macro_dsp_valuehl 
34d0				endm 
# End of macro FORTH_DSP_VALUEHL
34d0			 
34d0				; TODO add floating point number detection 
34d0			 
34d0 e5					push hl 
34d1			 
34d1					; destroy value TOS 
34d1			 
34d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d1 cd 4a 1c			call macro_forth_dsp_pop 
34d4				endm 
# End of macro FORTH_DSP_POP
34d4			 
34d4			 
34d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34d4 cd 92 1b			call macro_dsp_valuehl 
34d7				endm 
# End of macro FORTH_DSP_VALUEHL
34d7			 
34d7					; one value on hl get other one back 
34d7			 
34d7 d1					pop de 
34d8			 
34d8					; do the add 
34d8			 
34d8 19					add hl,de 
34d9			 
34d9					; save it 
34d9			 
34d9			;		push hl	 
34d9			 
34d9					; 
34d9			 
34d9					; destroy value TOS 
34d9			 
34d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d9 cd 4a 1c			call macro_forth_dsp_pop 
34dc				endm 
# End of macro FORTH_DSP_POP
34dc			 
34dc					; TODO push value back onto stack for another op etc 
34dc			 
34dc			;		pop hl 
34dc			 
34dc			.dot_done: 
34dc cd 9b 19				call forth_push_numhl 
34df			 
34df					NEXTW 
34df c3 04 1d			jp macro_next 
34e2				endm 
# End of macro NEXTW
34e2			.NEG: 
34e2			 
34e2				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
34e2 17				db WORD_SYS_CORE+3             
34e3 25 35			dw .DIV            
34e5 02				db 1 + 1 
34e6 .. 00			db "-",0              
34e8				endm 
# End of macro CWHEAD
34e8			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
34e8					if DEBUG_FORTH_WORDS_KEY 
34e8						DMARK "SUB" 
34e8 f5				push af  
34e9 3a fd 34			ld a, (.dmark)  
34ec 32 7a ee			ld (debug_mark),a  
34ef 3a fe 34			ld a, (.dmark+1)  
34f2 32 7b ee			ld (debug_mark+1),a  
34f5 3a ff 34			ld a, (.dmark+2)  
34f8 32 7c ee			ld (debug_mark+2),a  
34fb 18 03			jr .pastdmark  
34fd ..			.dmark: db "SUB"  
3500 f1			.pastdmark: pop af  
3501			endm  
# End of macro DMARK
3501						CALLMONITOR 
3501 cd 0e 14			call break_point_state  
3504				endm  
# End of macro CALLMONITOR
3504					endif 
3504			 
3504			 
3504				; TODO add floating point number detection 
3504					; v5 FORTH_DSP_VALUE 
3504					FORTH_DSP 
3504 cd 58 1b			call macro_forth_dsp 
3507				endm 
# End of macro FORTH_DSP
3507 7e					ld a,(hl)	; get type of value on TOS 
3508 fe 02				cp DS_TYPE_INUM  
350a 28 03				jr z, .neg_inum 
350c			 
350c					NEXTW 
350c c3 04 1d			jp macro_next 
350f				endm 
# End of macro NEXTW
350f			 
350f			; float maths 
350f			 
350f				if FORTH_ENABLE_FLOATMATH 
350f					jr .neg_done 
350f			 
350f				endif 
350f					 
350f			 
350f			.neg_inum: 
350f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
350f cd 92 1b			call macro_dsp_valuehl 
3512				endm 
# End of macro FORTH_DSP_VALUEHL
3512			 
3512 e5					push hl 
3513			 
3513					; destroy value TOS 
3513			 
3513					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3513 cd 4a 1c			call macro_forth_dsp_pop 
3516				endm 
# End of macro FORTH_DSP_POP
3516			 
3516			 
3516					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3516 cd 92 1b			call macro_dsp_valuehl 
3519				endm 
# End of macro FORTH_DSP_VALUEHL
3519			 
3519					; one value on hl get other one back 
3519			 
3519 d1					pop de 
351a			 
351a					; do the sub 
351a			;		ex de, hl 
351a			 
351a ed 52				sbc hl,de 
351c			 
351c					; save it 
351c			 
351c			;		push hl	 
351c			 
351c					; 
351c			 
351c					; destroy value TOS 
351c			 
351c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
351c cd 4a 1c			call macro_forth_dsp_pop 
351f				endm 
# End of macro FORTH_DSP_POP
351f			 
351f					; TODO push value back onto stack for another op etc 
351f			 
351f			;		pop hl 
351f			 
351f cd 9b 19				call forth_push_numhl 
3522			.neg_done: 
3522			 
3522					NEXTW 
3522 c3 04 1d			jp macro_next 
3525				endm 
# End of macro NEXTW
3525			.DIV: 
3525				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3525 18				db WORD_SYS_CORE+4             
3526 72 35			dw .MUL            
3528 02				db 1 + 1 
3529 .. 00			db "/",0              
352b				endm 
# End of macro CWHEAD
352b			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
352b					if DEBUG_FORTH_WORDS_KEY 
352b						DMARK "DIV" 
352b f5				push af  
352c 3a 40 35			ld a, (.dmark)  
352f 32 7a ee			ld (debug_mark),a  
3532 3a 41 35			ld a, (.dmark+1)  
3535 32 7b ee			ld (debug_mark+1),a  
3538 3a 42 35			ld a, (.dmark+2)  
353b 32 7c ee			ld (debug_mark+2),a  
353e 18 03			jr .pastdmark  
3540 ..			.dmark: db "DIV"  
3543 f1			.pastdmark: pop af  
3544			endm  
# End of macro DMARK
3544						CALLMONITOR 
3544 cd 0e 14			call break_point_state  
3547				endm  
# End of macro CALLMONITOR
3547					endif 
3547				; TODO add floating point number detection 
3547					; v5 FORTH_DSP_VALUE 
3547					FORTH_DSP 
3547 cd 58 1b			call macro_forth_dsp 
354a				endm 
# End of macro FORTH_DSP
354a 7e					ld a,(hl)	; get type of value on TOS 
354b fe 02				cp DS_TYPE_INUM  
354d 28 03				jr z, .div_inum 
354f			 
354f				if FORTH_ENABLE_FLOATMATH 
354f					jr .div_done 
354f			 
354f				endif 
354f					NEXTW 
354f c3 04 1d			jp macro_next 
3552				endm 
# End of macro NEXTW
3552			.div_inum: 
3552			 
3552					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3552 cd 92 1b			call macro_dsp_valuehl 
3555				endm 
# End of macro FORTH_DSP_VALUEHL
3555			 
3555 e5					push hl    ; to go to bc 
3556			 
3556					; destroy value TOS 
3556			 
3556					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3556 cd 4a 1c			call macro_forth_dsp_pop 
3559				endm 
# End of macro FORTH_DSP_POP
3559			 
3559			 
3559					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3559 cd 92 1b			call macro_dsp_valuehl 
355c				endm 
# End of macro FORTH_DSP_VALUEHL
355c			 
355c					; hl to go to de 
355c			 
355c e5					push hl 
355d			 
355d c1					pop bc 
355e d1					pop de		 
355f			 
355f			 
355f					if DEBUG_FORTH_MATHS 
355f						DMARK "DIV" 
355f				CALLMONITOR 
355f					endif 
355f					; one value on hl but move to a get other one back 
355f			 
355f			        
355f cd 0f 0b			call Div16 
3562			 
3562			;	push af	 
3562 e5				push hl 
3563 c5				push bc 
3564			 
3564					if DEBUG_FORTH_MATHS 
3564						DMARK "DI1" 
3564				CALLMONITOR 
3564					endif 
3564			 
3564					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3564 cd 4a 1c			call macro_forth_dsp_pop 
3567				endm 
# End of macro FORTH_DSP_POP
3567			 
3567			 
3567			 
3567 e1					pop hl    ; result 
3568			 
3568 cd 9b 19				call forth_push_numhl 
356b			 
356b e1					pop hl    ; reminder 
356c			;		ld h,0 
356c			;		ld l,d 
356c			 
356c cd 9b 19				call forth_push_numhl 
356f			.div_done: 
356f					NEXTW 
356f c3 04 1d			jp macro_next 
3572				endm 
# End of macro NEXTW
3572			.MUL: 
3572				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3572 19				db WORD_SYS_CORE+5             
3573 b7 35			dw .MIN            
3575 02				db 1 + 1 
3576 .. 00			db "*",0              
3578				endm 
# End of macro CWHEAD
3578			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3578				; TODO add floating point number detection 
3578					if DEBUG_FORTH_WORDS_KEY 
3578						DMARK "MUL" 
3578 f5				push af  
3579 3a 8d 35			ld a, (.dmark)  
357c 32 7a ee			ld (debug_mark),a  
357f 3a 8e 35			ld a, (.dmark+1)  
3582 32 7b ee			ld (debug_mark+1),a  
3585 3a 8f 35			ld a, (.dmark+2)  
3588 32 7c ee			ld (debug_mark+2),a  
358b 18 03			jr .pastdmark  
358d ..			.dmark: db "MUL"  
3590 f1			.pastdmark: pop af  
3591			endm  
# End of macro DMARK
3591						CALLMONITOR 
3591 cd 0e 14			call break_point_state  
3594				endm  
# End of macro CALLMONITOR
3594					endif 
3594					FORTH_DSP 
3594 cd 58 1b			call macro_forth_dsp 
3597				endm 
# End of macro FORTH_DSP
3597					; v5 FORTH_DSP_VALUE 
3597 7e					ld a,(hl)	; get type of value on TOS 
3598 fe 02				cp DS_TYPE_INUM  
359a 28 03				jr z, .mul_inum 
359c			 
359c				if FORTH_ENABLE_FLOATMATH 
359c					jr .mul_done 
359c			 
359c				endif 
359c			 
359c					NEXTW 
359c c3 04 1d			jp macro_next 
359f				endm 
# End of macro NEXTW
359f			.mul_inum:	 
359f			 
359f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
359f cd 92 1b			call macro_dsp_valuehl 
35a2				endm 
# End of macro FORTH_DSP_VALUEHL
35a2			 
35a2 e5					push hl 
35a3			 
35a3					; destroy value TOS 
35a3			 
35a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a3 cd 4a 1c			call macro_forth_dsp_pop 
35a6				endm 
# End of macro FORTH_DSP_POP
35a6			 
35a6			 
35a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a6 cd 92 1b			call macro_dsp_valuehl 
35a9				endm 
# End of macro FORTH_DSP_VALUEHL
35a9			 
35a9					; one value on hl but move to a get other one back 
35a9			 
35a9 7d					ld a, l 
35aa			 
35aa d1					pop de 
35ab			 
35ab					; do the mull 
35ab			;		ex de, hl 
35ab			 
35ab cd 35 0b				call Mult16 
35ae					; save it 
35ae			 
35ae			;		push hl	 
35ae			 
35ae					; 
35ae			 
35ae					; destroy value TOS 
35ae			 
35ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ae cd 4a 1c			call macro_forth_dsp_pop 
35b1				endm 
# End of macro FORTH_DSP_POP
35b1			 
35b1					; TODO push value back onto stack for another op etc 
35b1			 
35b1			;		pop hl 
35b1			 
35b1 cd 9b 19				call forth_push_numhl 
35b4			 
35b4			.mul_done: 
35b4					NEXTW 
35b4 c3 04 1d			jp macro_next 
35b7				endm 
# End of macro NEXTW
35b7			 
35b7			 
35b7			 
35b7			 
35b7			.MIN: 
35b7				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
35b7 49				db WORD_SYS_CORE+53             
35b8 38 36			dw .MAX            
35ba 04				db 3 + 1 
35bb .. 00			db "MIN",0              
35bf				endm 
# End of macro CWHEAD
35bf			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
35bf					if DEBUG_FORTH_WORDS_KEY 
35bf						DMARK "MIN" 
35bf f5				push af  
35c0 3a d4 35			ld a, (.dmark)  
35c3 32 7a ee			ld (debug_mark),a  
35c6 3a d5 35			ld a, (.dmark+1)  
35c9 32 7b ee			ld (debug_mark+1),a  
35cc 3a d6 35			ld a, (.dmark+2)  
35cf 32 7c ee			ld (debug_mark+2),a  
35d2 18 03			jr .pastdmark  
35d4 ..			.dmark: db "MIN"  
35d7 f1			.pastdmark: pop af  
35d8			endm  
# End of macro DMARK
35d8						CALLMONITOR 
35d8 cd 0e 14			call break_point_state  
35db				endm  
# End of macro CALLMONITOR
35db					endif 
35db					; get u2 
35db			 
35db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35db cd 92 1b			call macro_dsp_valuehl 
35de				endm 
# End of macro FORTH_DSP_VALUEHL
35de			 
35de e5					push hl   ; u2 
35df			 
35df					; destroy value TOS 
35df			 
35df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35df cd 4a 1c			call macro_forth_dsp_pop 
35e2				endm 
# End of macro FORTH_DSP_POP
35e2			 
35e2					; get u1 
35e2			 
35e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e2 cd 92 1b			call macro_dsp_valuehl 
35e5				endm 
# End of macro FORTH_DSP_VALUEHL
35e5			 
35e5 e5					push hl  ; u1 
35e6			 
35e6					; destroy value TOS 
35e6			 
35e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e6 cd 4a 1c			call macro_forth_dsp_pop 
35e9				endm 
# End of macro FORTH_DSP_POP
35e9			 
35e9 b7			 or a      ;clear carry flag 
35ea e1			  pop hl    ; u1 
35eb d1			  pop de    ; u2 
35ec e5				push hl   ; saved in case hl is lowest 
35ed ed 52		  sbc hl,de 
35ef 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
35f1			 
35f1 e1				pop hl 
35f2					if DEBUG_FORTH_WORDS 
35f2						DMARK "MIN" 
35f2 f5				push af  
35f3 3a 07 36			ld a, (.dmark)  
35f6 32 7a ee			ld (debug_mark),a  
35f9 3a 08 36			ld a, (.dmark+1)  
35fc 32 7b ee			ld (debug_mark+1),a  
35ff 3a 09 36			ld a, (.dmark+2)  
3602 32 7c ee			ld (debug_mark+2),a  
3605 18 03			jr .pastdmark  
3607 ..			.dmark: db "MIN"  
360a f1			.pastdmark: pop af  
360b			endm  
# End of macro DMARK
360b						CALLMONITOR 
360b cd 0e 14			call break_point_state  
360e				endm  
# End of macro CALLMONITOR
360e					endif 
360e cd 9b 19				call forth_push_numhl 
3611			 
3611				       NEXTW 
3611 c3 04 1d			jp macro_next 
3614				endm 
# End of macro NEXTW
3614			 
3614			.mincont:  
3614 c1				pop bc   ; tidy up 
3615 eb				ex de , hl  
3616					if DEBUG_FORTH_WORDS 
3616						DMARK "MI1" 
3616 f5				push af  
3617 3a 2b 36			ld a, (.dmark)  
361a 32 7a ee			ld (debug_mark),a  
361d 3a 2c 36			ld a, (.dmark+1)  
3620 32 7b ee			ld (debug_mark+1),a  
3623 3a 2d 36			ld a, (.dmark+2)  
3626 32 7c ee			ld (debug_mark+2),a  
3629 18 03			jr .pastdmark  
362b ..			.dmark: db "MI1"  
362e f1			.pastdmark: pop af  
362f			endm  
# End of macro DMARK
362f						CALLMONITOR 
362f cd 0e 14			call break_point_state  
3632				endm  
# End of macro CALLMONITOR
3632					endif 
3632 cd 9b 19				call forth_push_numhl 
3635			 
3635				       NEXTW 
3635 c3 04 1d			jp macro_next 
3638				endm 
# End of macro NEXTW
3638			.MAX: 
3638				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3638 4a				db WORD_SYS_CORE+54             
3639 b9 36			dw .RND16            
363b 04				db 3 + 1 
363c .. 00			db "MAX",0              
3640				endm 
# End of macro CWHEAD
3640			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3640					if DEBUG_FORTH_WORDS_KEY 
3640						DMARK "MAX" 
3640 f5				push af  
3641 3a 55 36			ld a, (.dmark)  
3644 32 7a ee			ld (debug_mark),a  
3647 3a 56 36			ld a, (.dmark+1)  
364a 32 7b ee			ld (debug_mark+1),a  
364d 3a 57 36			ld a, (.dmark+2)  
3650 32 7c ee			ld (debug_mark+2),a  
3653 18 03			jr .pastdmark  
3655 ..			.dmark: db "MAX"  
3658 f1			.pastdmark: pop af  
3659			endm  
# End of macro DMARK
3659						CALLMONITOR 
3659 cd 0e 14			call break_point_state  
365c				endm  
# End of macro CALLMONITOR
365c					endif 
365c					; get u2 
365c			 
365c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
365c cd 92 1b			call macro_dsp_valuehl 
365f				endm 
# End of macro FORTH_DSP_VALUEHL
365f			 
365f e5					push hl   ; u2 
3660			 
3660					; destroy value TOS 
3660			 
3660					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3660 cd 4a 1c			call macro_forth_dsp_pop 
3663				endm 
# End of macro FORTH_DSP_POP
3663			 
3663					; get u1 
3663			 
3663					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3663 cd 92 1b			call macro_dsp_valuehl 
3666				endm 
# End of macro FORTH_DSP_VALUEHL
3666			 
3666 e5					push hl  ; u1 
3667			 
3667					; destroy value TOS 
3667			 
3667					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3667 cd 4a 1c			call macro_forth_dsp_pop 
366a				endm 
# End of macro FORTH_DSP_POP
366a			 
366a b7			 or a      ;clear carry flag 
366b e1			  pop hl    ; u1 
366c d1			  pop de    ; u2 
366d e5				push hl   ; saved in case hl is lowest 
366e ed 52		  sbc hl,de 
3670 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3672			 
3672 e1				pop hl 
3673					if DEBUG_FORTH_WORDS 
3673						DMARK "MAX" 
3673 f5				push af  
3674 3a 88 36			ld a, (.dmark)  
3677 32 7a ee			ld (debug_mark),a  
367a 3a 89 36			ld a, (.dmark+1)  
367d 32 7b ee			ld (debug_mark+1),a  
3680 3a 8a 36			ld a, (.dmark+2)  
3683 32 7c ee			ld (debug_mark+2),a  
3686 18 03			jr .pastdmark  
3688 ..			.dmark: db "MAX"  
368b f1			.pastdmark: pop af  
368c			endm  
# End of macro DMARK
368c						CALLMONITOR 
368c cd 0e 14			call break_point_state  
368f				endm  
# End of macro CALLMONITOR
368f					endif 
368f cd 9b 19				call forth_push_numhl 
3692			 
3692				       NEXTW 
3692 c3 04 1d			jp macro_next 
3695				endm 
# End of macro NEXTW
3695			 
3695			.maxcont:  
3695 c1				pop bc   ; tidy up 
3696 eb				ex de , hl  
3697					if DEBUG_FORTH_WORDS 
3697						DMARK "MA1" 
3697 f5				push af  
3698 3a ac 36			ld a, (.dmark)  
369b 32 7a ee			ld (debug_mark),a  
369e 3a ad 36			ld a, (.dmark+1)  
36a1 32 7b ee			ld (debug_mark+1),a  
36a4 3a ae 36			ld a, (.dmark+2)  
36a7 32 7c ee			ld (debug_mark+2),a  
36aa 18 03			jr .pastdmark  
36ac ..			.dmark: db "MA1"  
36af f1			.pastdmark: pop af  
36b0			endm  
# End of macro DMARK
36b0						CALLMONITOR 
36b0 cd 0e 14			call break_point_state  
36b3				endm  
# End of macro CALLMONITOR
36b3					endif 
36b3 cd 9b 19				call forth_push_numhl 
36b6				       NEXTW 
36b6 c3 04 1d			jp macro_next 
36b9				endm 
# End of macro NEXTW
36b9			 
36b9			.RND16: 
36b9				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
36b9 4e				db WORD_SYS_CORE+58             
36ba e8 36			dw .RND8            
36bc 06				db 5 + 1 
36bd .. 00			db "RND16",0              
36c3				endm 
# End of macro CWHEAD
36c3			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
36c3					if DEBUG_FORTH_WORDS_KEY 
36c3						DMARK "R16" 
36c3 f5				push af  
36c4 3a d8 36			ld a, (.dmark)  
36c7 32 7a ee			ld (debug_mark),a  
36ca 3a d9 36			ld a, (.dmark+1)  
36cd 32 7b ee			ld (debug_mark+1),a  
36d0 3a da 36			ld a, (.dmark+2)  
36d3 32 7c ee			ld (debug_mark+2),a  
36d6 18 03			jr .pastdmark  
36d8 ..			.dmark: db "R16"  
36db f1			.pastdmark: pop af  
36dc			endm  
# End of macro DMARK
36dc						CALLMONITOR 
36dc cd 0e 14			call break_point_state  
36df				endm  
# End of macro CALLMONITOR
36df					endif 
36df cd d9 0a				call prng16  
36e2 cd 9b 19				call forth_push_numhl 
36e5				       NEXTW 
36e5 c3 04 1d			jp macro_next 
36e8				endm 
# End of macro NEXTW
36e8			.RND8: 
36e8				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
36e8 60				db WORD_SYS_CORE+76             
36e9 1d 37			dw .RND            
36eb 05				db 4 + 1 
36ec .. 00			db "RND8",0              
36f1				endm 
# End of macro CWHEAD
36f1			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
36f1					if DEBUG_FORTH_WORDS_KEY 
36f1						DMARK "RN8" 
36f1 f5				push af  
36f2 3a 06 37			ld a, (.dmark)  
36f5 32 7a ee			ld (debug_mark),a  
36f8 3a 07 37			ld a, (.dmark+1)  
36fb 32 7b ee			ld (debug_mark+1),a  
36fe 3a 08 37			ld a, (.dmark+2)  
3701 32 7c ee			ld (debug_mark+2),a  
3704 18 03			jr .pastdmark  
3706 ..			.dmark: db "RN8"  
3709 f1			.pastdmark: pop af  
370a			endm  
# End of macro DMARK
370a						CALLMONITOR 
370a cd 0e 14			call break_point_state  
370d				endm  
# End of macro CALLMONITOR
370d					endif 
370d 2a bb eb				ld hl,(xrandc) 
3710 23					inc hl 
3711 cd f3 0a				call xrnd 
3714 6f					ld l,a	 
3715 26 00				ld h,0 
3717 cd 9b 19				call forth_push_numhl 
371a				       NEXTW 
371a c3 04 1d			jp macro_next 
371d				endm 
# End of macro NEXTW
371d			.RND: 
371d				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
371d 60				db WORD_SYS_CORE+76             
371e 23 38			dw .ENDMATHS            
3720 04				db 3 + 1 
3721 .. 00			db "RND",0              
3725				endm 
# End of macro CWHEAD
3725			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3725			 
3725					if DEBUG_FORTH_WORDS_KEY 
3725						DMARK "RND" 
3725 f5				push af  
3726 3a 3a 37			ld a, (.dmark)  
3729 32 7a ee			ld (debug_mark),a  
372c 3a 3b 37			ld a, (.dmark+1)  
372f 32 7b ee			ld (debug_mark+1),a  
3732 3a 3c 37			ld a, (.dmark+2)  
3735 32 7c ee			ld (debug_mark+2),a  
3738 18 03			jr .pastdmark  
373a ..			.dmark: db "RND"  
373d f1			.pastdmark: pop af  
373e			endm  
# End of macro DMARK
373e						CALLMONITOR 
373e cd 0e 14			call break_point_state  
3741				endm  
# End of macro CALLMONITOR
3741					endif 
3741					 
3741					FORTH_DSP_VALUEHL    ; upper range 
3741 cd 92 1b			call macro_dsp_valuehl 
3744				endm 
# End of macro FORTH_DSP_VALUEHL
3744			 
3744 22 bf eb				ld (LFSRSeed), hl	 
3747			 
3747					if DEBUG_FORTH_WORDS 
3747						DMARK "RN1" 
3747 f5				push af  
3748 3a 5c 37			ld a, (.dmark)  
374b 32 7a ee			ld (debug_mark),a  
374e 3a 5d 37			ld a, (.dmark+1)  
3751 32 7b ee			ld (debug_mark+1),a  
3754 3a 5e 37			ld a, (.dmark+2)  
3757 32 7c ee			ld (debug_mark+2),a  
375a 18 03			jr .pastdmark  
375c ..			.dmark: db "RN1"  
375f f1			.pastdmark: pop af  
3760			endm  
# End of macro DMARK
3760						CALLMONITOR 
3760 cd 0e 14			call break_point_state  
3763				endm  
# End of macro CALLMONITOR
3763					endif 
3763					FORTH_DSP_POP 
3763 cd 4a 1c			call macro_forth_dsp_pop 
3766				endm 
# End of macro FORTH_DSP_POP
3766			 
3766					FORTH_DSP_VALUEHL    ; low range 
3766 cd 92 1b			call macro_dsp_valuehl 
3769				endm 
# End of macro FORTH_DSP_VALUEHL
3769			 
3769					if DEBUG_FORTH_WORDS 
3769						DMARK "RN2" 
3769 f5				push af  
376a 3a 7e 37			ld a, (.dmark)  
376d 32 7a ee			ld (debug_mark),a  
3770 3a 7f 37			ld a, (.dmark+1)  
3773 32 7b ee			ld (debug_mark+1),a  
3776 3a 80 37			ld a, (.dmark+2)  
3779 32 7c ee			ld (debug_mark+2),a  
377c 18 03			jr .pastdmark  
377e ..			.dmark: db "RN2"  
3781 f1			.pastdmark: pop af  
3782			endm  
# End of macro DMARK
3782						CALLMONITOR 
3782 cd 0e 14			call break_point_state  
3785				endm  
# End of macro CALLMONITOR
3785					endif 
3785 22 c1 eb				ld (LFSRSeed+2), hl 
3788			 
3788					FORTH_DSP_POP 
3788 cd 4a 1c			call macro_forth_dsp_pop 
378b				endm 
# End of macro FORTH_DSP_POP
378b			 
378b e5					push hl 
378c			 
378c e1			.inrange:	pop hl 
378d cd d9 0a				call prng16  
3790					if DEBUG_FORTH_WORDS 
3790						DMARK "RN3" 
3790 f5				push af  
3791 3a a5 37			ld a, (.dmark)  
3794 32 7a ee			ld (debug_mark),a  
3797 3a a6 37			ld a, (.dmark+1)  
379a 32 7b ee			ld (debug_mark+1),a  
379d 3a a7 37			ld a, (.dmark+2)  
37a0 32 7c ee			ld (debug_mark+2),a  
37a3 18 03			jr .pastdmark  
37a5 ..			.dmark: db "RN3"  
37a8 f1			.pastdmark: pop af  
37a9			endm  
# End of macro DMARK
37a9						CALLMONITOR 
37a9 cd 0e 14			call break_point_state  
37ac				endm  
# End of macro CALLMONITOR
37ac					endif 
37ac					 
37ac					; if the range is 8bit knock out the high byte 
37ac			 
37ac ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
37b0			 
37b0 3e 00				ld a, 0 
37b2 ba					cp d  
37b3 20 1e				jr nz, .hirange 
37b5 26 00				ld h, 0   ; knock it down to 8bit 
37b7			 
37b7					if DEBUG_FORTH_WORDS 
37b7						DMARK "RNk" 
37b7 f5				push af  
37b8 3a cc 37			ld a, (.dmark)  
37bb 32 7a ee			ld (debug_mark),a  
37be 3a cd 37			ld a, (.dmark+1)  
37c1 32 7b ee			ld (debug_mark+1),a  
37c4 3a ce 37			ld a, (.dmark+2)  
37c7 32 7c ee			ld (debug_mark+2),a  
37ca 18 03			jr .pastdmark  
37cc ..			.dmark: db "RNk"  
37cf f1			.pastdmark: pop af  
37d0			endm  
# End of macro DMARK
37d0						CALLMONITOR 
37d0 cd 0e 14			call break_point_state  
37d3				endm  
# End of macro CALLMONITOR
37d3					endif 
37d3			.hirange:   
37d3 e5					push hl  
37d4 b7					or a  
37d5 ed 52		                sbc hl, de 
37d7			 
37d7					;call cmp16 
37d7			 
37d7 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
37d9 e1					pop hl 
37da e5					push hl 
37db			 
37db					if DEBUG_FORTH_WORDS 
37db						DMARK "RN4" 
37db f5				push af  
37dc 3a f0 37			ld a, (.dmark)  
37df 32 7a ee			ld (debug_mark),a  
37e2 3a f1 37			ld a, (.dmark+1)  
37e5 32 7b ee			ld (debug_mark+1),a  
37e8 3a f2 37			ld a, (.dmark+2)  
37eb 32 7c ee			ld (debug_mark+2),a  
37ee 18 03			jr .pastdmark  
37f0 ..			.dmark: db "RN4"  
37f3 f1			.pastdmark: pop af  
37f4			endm  
# End of macro DMARK
37f4						CALLMONITOR 
37f4 cd 0e 14			call break_point_state  
37f7				endm  
# End of macro CALLMONITOR
37f7					endif 
37f7 ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
37fb					;call cmp16 
37fb				 
37fb b7					or a  
37fc ed 52		                sbc hl, de 
37fe 38 8c				jr c, .inrange 
3800			 
3800 e1					pop hl 
3801					 
3801					if DEBUG_FORTH_WORDS 
3801						DMARK "RNd" 
3801 f5				push af  
3802 3a 16 38			ld a, (.dmark)  
3805 32 7a ee			ld (debug_mark),a  
3808 3a 17 38			ld a, (.dmark+1)  
380b 32 7b ee			ld (debug_mark+1),a  
380e 3a 18 38			ld a, (.dmark+2)  
3811 32 7c ee			ld (debug_mark+2),a  
3814 18 03			jr .pastdmark  
3816 ..			.dmark: db "RNd"  
3819 f1			.pastdmark: pop af  
381a			endm  
# End of macro DMARK
381a						CALLMONITOR 
381a cd 0e 14			call break_point_state  
381d				endm  
# End of macro CALLMONITOR
381d					endif 
381d			 
381d			 
381d cd 9b 19				call forth_push_numhl 
3820				       NEXTW 
3820 c3 04 1d			jp macro_next 
3823				endm 
# End of macro NEXTW
3823			 
3823			.ENDMATHS: 
3823			 
3823			; eof 
3823			 
# End of file forth_words_maths.asm
3823			include "forth_words_display.asm" 
3823			 
3823			; | ## Display Words 
3823			 
3823			.ATP: 
3823				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3823 62				db WORD_SYS_CORE+78             
3824 9a 38			dw .FB            
3826 04				db 3 + 1 
3827 .. 00			db "AT?",0              
382b				endm 
# End of macro CWHEAD
382b			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
382b					if DEBUG_FORTH_WORDS_KEY 
382b						DMARK "AT?" 
382b f5				push af  
382c 3a 40 38			ld a, (.dmark)  
382f 32 7a ee			ld (debug_mark),a  
3832 3a 41 38			ld a, (.dmark+1)  
3835 32 7b ee			ld (debug_mark+1),a  
3838 3a 42 38			ld a, (.dmark+2)  
383b 32 7c ee			ld (debug_mark+2),a  
383e 18 03			jr .pastdmark  
3840 ..			.dmark: db "AT?"  
3843 f1			.pastdmark: pop af  
3844			endm  
# End of macro DMARK
3844						CALLMONITOR 
3844 cd 0e 14			call break_point_state  
3847				endm  
# End of macro CALLMONITOR
3847					endif 
3847 3a 49 eb				ld a, (f_cursor_ptr) 
384a			 
384a			if DEBUG_FORTH_WORDS 
384a				DMARK "AT?" 
384a f5				push af  
384b 3a 5f 38			ld a, (.dmark)  
384e 32 7a ee			ld (debug_mark),a  
3851 3a 60 38			ld a, (.dmark+1)  
3854 32 7b ee			ld (debug_mark+1),a  
3857 3a 61 38			ld a, (.dmark+2)  
385a 32 7c ee			ld (debug_mark+2),a  
385d 18 03			jr .pastdmark  
385f ..			.dmark: db "AT?"  
3862 f1			.pastdmark: pop af  
3863			endm  
# End of macro DMARK
3863				CALLMONITOR 
3863 cd 0e 14			call break_point_state  
3866				endm  
# End of macro CALLMONITOR
3866			endif	 
3866					; count the number of rows 
3866			 
3866 06 00				ld b, 0 
3868 4f			.atpr:		ld c, a    ; save in case we go below zero 
3869 d6 28				sub display_cols 
386b f2 71 38				jp p, .atprunder 
386e 04					inc b 
386f 18 f7				jr .atpr 
3871			.atprunder:	 
3871			if DEBUG_FORTH_WORDS 
3871				DMARK "A?2" 
3871 f5				push af  
3872 3a 86 38			ld a, (.dmark)  
3875 32 7a ee			ld (debug_mark),a  
3878 3a 87 38			ld a, (.dmark+1)  
387b 32 7b ee			ld (debug_mark+1),a  
387e 3a 88 38			ld a, (.dmark+2)  
3881 32 7c ee			ld (debug_mark+2),a  
3884 18 03			jr .pastdmark  
3886 ..			.dmark: db "A?2"  
3889 f1			.pastdmark: pop af  
388a			endm  
# End of macro DMARK
388a				CALLMONITOR 
388a cd 0e 14			call break_point_state  
388d				endm  
# End of macro CALLMONITOR
388d			endif	 
388d 26 00				ld h, 0 
388f 69					ld l, c 
3890 cd 9b 19				call forth_push_numhl 
3893 68					ld l, b  
3894 cd 9b 19				call forth_push_numhl 
3897			 
3897			 
3897				NEXTW 
3897 c3 04 1d			jp macro_next 
389a				endm 
# End of macro NEXTW
389a			 
389a			.FB: 
389a				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
389a 1b				db WORD_SYS_CORE+7             
389b e8 38			dw .EMIT            
389d 03				db 2 + 1 
389e .. 00			db "FB",0              
38a1				endm 
# End of macro CWHEAD
38a1			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
38a1			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
38a1			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
38a1			; | | If automatic display is off then updates will not be shown until DRAW is used. 
38a1					if DEBUG_FORTH_WORDS_KEY 
38a1						DMARK "FB." 
38a1 f5				push af  
38a2 3a b6 38			ld a, (.dmark)  
38a5 32 7a ee			ld (debug_mark),a  
38a8 3a b7 38			ld a, (.dmark+1)  
38ab 32 7b ee			ld (debug_mark+1),a  
38ae 3a b8 38			ld a, (.dmark+2)  
38b1 32 7c ee			ld (debug_mark+2),a  
38b4 18 03			jr .pastdmark  
38b6 ..			.dmark: db "FB."  
38b9 f1			.pastdmark: pop af  
38ba			endm  
# End of macro DMARK
38ba						CALLMONITOR 
38ba cd 0e 14			call break_point_state  
38bd				endm  
# End of macro CALLMONITOR
38bd					endif 
38bd			 
38bd					FORTH_DSP_VALUEHL 
38bd cd 92 1b			call macro_dsp_valuehl 
38c0				endm 
# End of macro FORTH_DSP_VALUEHL
38c0			 
38c0 7d					ld a, l 
38c1 fe 01				cp 1 
38c3 20 05				jr nz, .fbn1 
38c5 21 1f ed				ld hl, display_fb1 
38c8 18 15				jr .fbset 
38ca fe 02		.fbn1:		cp 2 
38cc 20 05				jr nz, .fbn2 
38ce 21 dd eb				ld hl, display_fb2 
38d1 18 0c				jr .fbset 
38d3 fe 03		.fbn2:		cp 3 
38d5 20 05				jr nz, .fbn3 
38d7 21 7e ec				ld hl, display_fb3 
38da 18 03				jr .fbset 
38dc			.fbn3:		 ; if invalid number select first 
38dc 21 1f ed				ld hl, display_fb1 
38df 22 db eb		.fbset:		ld (display_fb_active), hl 
38e2			 
38e2					FORTH_DSP_POP 
38e2 cd 4a 1c			call macro_forth_dsp_pop 
38e5				endm 
# End of macro FORTH_DSP_POP
38e5			 
38e5					NEXTW 
38e5 c3 04 1d			jp macro_next 
38e8				endm 
# End of macro NEXTW
38e8			 
38e8			 
38e8			.EMIT: 
38e8				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
38e8 1b				db WORD_SYS_CORE+7             
38e9 39 39			dw .DOTH            
38eb 05				db 4 + 1 
38ec .. 00			db "EMIT",0              
38f1				endm 
# End of macro CWHEAD
38f1			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
38f1					; get value off TOS and display it 
38f1			 
38f1					if DEBUG_FORTH_WORDS_KEY 
38f1						DMARK "EMT" 
38f1 f5				push af  
38f2 3a 06 39			ld a, (.dmark)  
38f5 32 7a ee			ld (debug_mark),a  
38f8 3a 07 39			ld a, (.dmark+1)  
38fb 32 7b ee			ld (debug_mark+1),a  
38fe 3a 08 39			ld a, (.dmark+2)  
3901 32 7c ee			ld (debug_mark+2),a  
3904 18 03			jr .pastdmark  
3906 ..			.dmark: db "EMT"  
3909 f1			.pastdmark: pop af  
390a			endm  
# End of macro DMARK
390a						CALLMONITOR 
390a cd 0e 14			call break_point_state  
390d				endm  
# End of macro CALLMONITOR
390d					endif 
390d			 
390d					FORTH_DSP_VALUEHL 
390d cd 92 1b			call macro_dsp_valuehl 
3910				endm 
# End of macro FORTH_DSP_VALUEHL
3910			 
3910 7d					ld a,l 
3911			 
3911					; TODO write to display 
3911			 
3911 32 5e e5				ld (os_input), a 
3914 3e 00				ld a, 0 
3916 32 5f e5				ld (os_input+1), a 
3919					 
3919 3a 49 eb				ld a, (f_cursor_ptr) 
391c 11 5e e5				ld de, os_input 
391f cd 98 09				call str_at_display 
3922			 
3922			 
3922 3a 27 eb				ld a,(cli_autodisplay) 
3925 fe 00				cp 0 
3927 28 03				jr z, .enoupdate 
3929 cd a8 09						call update_display 
392c					.enoupdate: 
392c			 
392c 3a 49 eb				ld a, (f_cursor_ptr) 
392f 3c					inc a 
3930 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
3933			 
3933			 
3933					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3933 cd 4a 1c			call macro_forth_dsp_pop 
3936				endm 
# End of macro FORTH_DSP_POP
3936			  
3936			 
3936					NEXTW 
3936 c3 04 1d			jp macro_next 
3939				endm 
# End of macro NEXTW
3939			.DOTH: 
3939				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3939 1c				db WORD_SYS_CORE+8             
393a 69 39			dw .DOTF            
393c 03				db 2 + 1 
393d .. 00			db ".-",0              
3940				endm 
# End of macro CWHEAD
3940			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3940					; get value off TOS and display it 
3940					if DEBUG_FORTH_WORDS_KEY 
3940						DMARK "DTD" 
3940 f5				push af  
3941 3a 55 39			ld a, (.dmark)  
3944 32 7a ee			ld (debug_mark),a  
3947 3a 56 39			ld a, (.dmark+1)  
394a 32 7b ee			ld (debug_mark+1),a  
394d 3a 57 39			ld a, (.dmark+2)  
3950 32 7c ee			ld (debug_mark+2),a  
3953 18 03			jr .pastdmark  
3955 ..			.dmark: db "DTD"  
3958 f1			.pastdmark: pop af  
3959			endm  
# End of macro DMARK
3959						CALLMONITOR 
3959 cd 0e 14			call break_point_state  
395c				endm  
# End of macro CALLMONITOR
395c					endif 
395c 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
395e 3e 00			ld a, 0 
3960 32 28 eb			ld (cli_mvdot), a 
3963 c3 c0 39			jp .dotgo 
3966				NEXTW 
3966 c3 04 1d			jp macro_next 
3969				endm 
# End of macro NEXTW
3969			.DOTF: 
3969				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3969 1c				db WORD_SYS_CORE+8             
396a 97 39			dw .DOT            
396c 03				db 2 + 1 
396d .. 00			db ".>",0              
3970				endm 
# End of macro CWHEAD
3970			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3970					; get value off TOS and display it 
3970			        ; TODO BUG adds extra spaces 
3970			        ; TODO BUG handle numerics? 
3970					if DEBUG_FORTH_WORDS_KEY 
3970						DMARK "DTC" 
3970 f5				push af  
3971 3a 85 39			ld a, (.dmark)  
3974 32 7a ee			ld (debug_mark),a  
3977 3a 86 39			ld a, (.dmark+1)  
397a 32 7b ee			ld (debug_mark+1),a  
397d 3a 87 39			ld a, (.dmark+2)  
3980 32 7c ee			ld (debug_mark+2),a  
3983 18 03			jr .pastdmark  
3985 ..			.dmark: db "DTC"  
3988 f1			.pastdmark: pop af  
3989			endm  
# End of macro DMARK
3989						CALLMONITOR 
3989 cd 0e 14			call break_point_state  
398c				endm  
# End of macro CALLMONITOR
398c					endif 
398c 3e 01			ld a, 1 
398e 32 28 eb			ld (cli_mvdot), a 
3991 c3 c0 39			jp .dotgo 
3994				NEXTW 
3994 c3 04 1d			jp macro_next 
3997				endm 
# End of macro NEXTW
3997			 
3997			.DOT: 
3997				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3997 1c				db WORD_SYS_CORE+8             
3998 23 3a			dw .CLS            
399a 02				db 1 + 1 
399b .. 00			db ".",0              
399d				endm 
# End of macro CWHEAD
399d			        ; | . ( u -- ) Display TOS | DONE 
399d					; get value off TOS and display it 
399d			 
399d					if DEBUG_FORTH_WORDS_KEY 
399d						DMARK "DOT" 
399d f5				push af  
399e 3a b2 39			ld a, (.dmark)  
39a1 32 7a ee			ld (debug_mark),a  
39a4 3a b3 39			ld a, (.dmark+1)  
39a7 32 7b ee			ld (debug_mark+1),a  
39aa 3a b4 39			ld a, (.dmark+2)  
39ad 32 7c ee			ld (debug_mark+2),a  
39b0 18 03			jr .pastdmark  
39b2 ..			.dmark: db "DOT"  
39b5 f1			.pastdmark: pop af  
39b6			endm  
# End of macro DMARK
39b6						CALLMONITOR 
39b6 cd 0e 14			call break_point_state  
39b9				endm  
# End of macro CALLMONITOR
39b9					endif 
39b9 3e 00			ld a, 0 
39bb 32 28 eb			ld (cli_mvdot), a 
39be 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
39c0				 
39c0			 
39c0			.dotgo: 
39c0			 
39c0			; move up type to on stack for parserv5 
39c0					FORTH_DSP 
39c0 cd 58 1b			call macro_forth_dsp 
39c3				endm 
# End of macro FORTH_DSP
39c3				;FORTH_DSP_VALUE  
39c3			 
39c3			if DEBUG_FORTH_DOT 
39c3				DMARK "DOT" 
39c3				CALLMONITOR 
39c3			endif	 
39c3			;		.print: 
39c3			 
39c3 7e				ld a,(hl)  ; work out what type of value is on the TOS 
39c4 23				inc hl   ; position to the actual value 
39c5 fe 01			cp DS_TYPE_STR 
39c7 20 06			jr nz, .dotnum1  
39c9			 
39c9			; display string 
39c9				FORTH_DSP_VALUE  
39c9 cd 7b 1b			call macro_forth_dsp_value 
39cc				endm 
# End of macro FORTH_DSP_VALUE
39cc eb				ex de,hl 
39cd 18 11			jr .dotwrite 
39cf			 
39cf			.dotnum1: 
39cf fe 02			cp DS_TYPE_INUM 
39d1 20 0c			jr nz, .dotflot 
39d3			 
39d3			 
39d3			; display number 
39d3			 
39d3			;	push hl 
39d3			;	call clear_display 
39d3			;	pop hl 
39d3			 
39d3 5e				ld e, (hl) 
39d4 23				inc hl 
39d5 56				ld d, (hl) 
39d6 21 60 e3			ld hl, scratch 
39d9			if DEBUG_FORTH_DOT 
39d9				DMARK "DT1" 
39d9				CALLMONITOR 
39d9			endif	 
39d9			 
39d9 cd bf 0f			call uitoa_16 
39dc eb				ex de,hl 
39dd			 
39dd			if DEBUG_FORTH_DOT 
39dd				DMARK "DT2" 
39dd				CALLMONITOR 
39dd			endif	 
39dd			 
39dd			;	ld de, os_word_scratch 
39dd 18 01			jr .dotwrite 
39df			 
39df 00			.dotflot:   nop 
39e0			; TODO print floating point number 
39e0			 
39e0			.dotwrite:		 
39e0			 
39e0					; if c is set then set all '-' to spaces 
39e0					; need to also take into account .>  
39e0			 
39e0 3e 01				ld a, 1 
39e2 b9					cp c 
39e3 20 13				jr nz, .nodashswap 
39e5			 
39e5					; DE has the string to write, working with HL 
39e5			 
39e5 06 ff				ld b, 255 
39e7 d5					push de 
39e8 e1					pop hl 
39e9			 
39e9			if DEBUG_FORTH_DOT 
39e9				DMARK "DT-" 
39e9				CALLMONITOR 
39e9			endif	 
39e9 7e			.dashscan:	ld a, (hl) 
39ea fe 00				cp 0 
39ec 28 0a				jr z, .nodashswap 
39ee fe 2d				cp '-' 
39f0 20 03				jr nz, .dashskip 
39f2 3e 20				ld a, ' ' 
39f4 77					ld (hl), a 
39f5 23			.dashskip:	inc hl 
39f6			if DEBUG_FORTH_DOT 
39f6				DMARK "D-2" 
39f6				CALLMONITOR 
39f6			endif	 
39f6 10 f1				djnz .dashscan 
39f8			 
39f8			if DEBUG_FORTH_DOT 
39f8				DMARK "D-1" 
39f8				CALLMONITOR 
39f8			endif	 
39f8			 
39f8			.nodashswap: 
39f8			 
39f8 e5					push hl   ; save string start in case we need to advance print 
39f9			 
39f9 3a 49 eb				ld a, (f_cursor_ptr) 
39fc cd 98 09				call str_at_display 
39ff 3a 27 eb				ld a,(cli_autodisplay) 
3a02 fe 00				cp 0 
3a04 28 03				jr z, .noupdate 
3a06 cd a8 09						call update_display 
3a09					.noupdate: 
3a09			 
3a09			 
3a09					; see if we need to advance the print position 
3a09			 
3a09 e1					pop hl   ; get back string 
3a0a			 
3a0a 3a 28 eb				ld a, (cli_mvdot) 
3a0d			if DEBUG_FORTH_DOT 
3a0d					ld e,a 
3a0d				DMARK "D>1" 
3a0d				CALLMONITOR 
3a0d			endif	 
3a0d fe 00				cp 0 
3a0f 28 0c				jr z, .noadv 
3a11					; yes, lets advance the print position 
3a11 3e 00				ld a, 0 
3a13 cd 1b 10				call strlent 
3a16 3a 49 eb				ld a, (f_cursor_ptr) 
3a19 85					add a,l 
3a1a					;call addatohl 
3a1a					;ld a, l 
3a1a 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
3a1d			 
3a1d			if DEBUG_FORTH_DOT 
3a1d				DMARK "D->" 
3a1d				CALLMONITOR 
3a1d			endif	 
3a1d			 
3a1d			.noadv:	 
3a1d			 
3a1d					if DEBUG_FORTH_DOT_WAIT 
3a1d							call next_page_prompt 
3a1d					endif	 
3a1d			; TODO this pop off the stack causes a crash. i dont know why 
3a1d			 
3a1d			 
3a1d			if DEBUG_FORTH_DOT 
3a1d				DMARK "DTh" 
3a1d				CALLMONITOR 
3a1d			endif	 
3a1d			 
3a1d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a1d cd 4a 1c			call macro_forth_dsp_pop 
3a20				endm 
# End of macro FORTH_DSP_POP
3a20			 
3a20			if DEBUG_FORTH_DOT 
3a20				DMARK "DTi" 
3a20				CALLMONITOR 
3a20			endif	 
3a20			 
3a20			 
3a20					NEXTW 
3a20 c3 04 1d			jp macro_next 
3a23				endm 
# End of macro NEXTW
3a23			 
3a23			.CLS: 
3a23				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3a23 35				db WORD_SYS_CORE+33             
3a24 50 3a			dw .DRAW            
3a26 04				db 3 + 1 
3a27 .. 00			db "CLS",0              
3a2b				endm 
# End of macro CWHEAD
3a2b			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3a2b					if DEBUG_FORTH_WORDS_KEY 
3a2b						DMARK "CLS" 
3a2b f5				push af  
3a2c 3a 40 3a			ld a, (.dmark)  
3a2f 32 7a ee			ld (debug_mark),a  
3a32 3a 41 3a			ld a, (.dmark+1)  
3a35 32 7b ee			ld (debug_mark+1),a  
3a38 3a 42 3a			ld a, (.dmark+2)  
3a3b 32 7c ee			ld (debug_mark+2),a  
3a3e 18 03			jr .pastdmark  
3a40 ..			.dmark: db "CLS"  
3a43 f1			.pastdmark: pop af  
3a44			endm  
# End of macro DMARK
3a44						CALLMONITOR 
3a44 cd 0e 14			call break_point_state  
3a47				endm  
# End of macro CALLMONITOR
3a47					endif 
3a47 cd 85 09				call clear_display 
3a4a c3 5e 3b				jp .home		; and home cursor 
3a4d					NEXTW 
3a4d c3 04 1d			jp macro_next 
3a50				endm 
# End of macro NEXTW
3a50			 
3a50			.DRAW: 
3a50				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3a50 36				db WORD_SYS_CORE+34             
3a51 7b 3a			dw .DUMP            
3a53 05				db 4 + 1 
3a54 .. 00			db "DRAW",0              
3a59				endm 
# End of macro CWHEAD
3a59			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3a59					if DEBUG_FORTH_WORDS_KEY 
3a59						DMARK "DRW" 
3a59 f5				push af  
3a5a 3a 6e 3a			ld a, (.dmark)  
3a5d 32 7a ee			ld (debug_mark),a  
3a60 3a 6f 3a			ld a, (.dmark+1)  
3a63 32 7b ee			ld (debug_mark+1),a  
3a66 3a 70 3a			ld a, (.dmark+2)  
3a69 32 7c ee			ld (debug_mark+2),a  
3a6c 18 03			jr .pastdmark  
3a6e ..			.dmark: db "DRW"  
3a71 f1			.pastdmark: pop af  
3a72			endm  
# End of macro DMARK
3a72						CALLMONITOR 
3a72 cd 0e 14			call break_point_state  
3a75				endm  
# End of macro CALLMONITOR
3a75					endif 
3a75 cd a8 09				call update_display 
3a78					NEXTW 
3a78 c3 04 1d			jp macro_next 
3a7b				endm 
# End of macro NEXTW
3a7b			 
3a7b			.DUMP: 
3a7b				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3a7b 37				db WORD_SYS_CORE+35             
3a7c b3 3a			dw .CDUMP            
3a7e 05				db 4 + 1 
3a7f .. 00			db "DUMP",0              
3a84				endm 
# End of macro CWHEAD
3a84			; | DUMP ( x -- ) With address x display dump   | DONE 
3a84			; TODO pop address to use off of the stack 
3a84					if DEBUG_FORTH_WORDS_KEY 
3a84						DMARK "DUM" 
3a84 f5				push af  
3a85 3a 99 3a			ld a, (.dmark)  
3a88 32 7a ee			ld (debug_mark),a  
3a8b 3a 9a 3a			ld a, (.dmark+1)  
3a8e 32 7b ee			ld (debug_mark+1),a  
3a91 3a 9b 3a			ld a, (.dmark+2)  
3a94 32 7c ee			ld (debug_mark+2),a  
3a97 18 03			jr .pastdmark  
3a99 ..			.dmark: db "DUM"  
3a9c f1			.pastdmark: pop af  
3a9d			endm  
# End of macro DMARK
3a9d						CALLMONITOR 
3a9d cd 0e 14			call break_point_state  
3aa0				endm  
# End of macro CALLMONITOR
3aa0					endif 
3aa0 cd 85 09				call clear_display 
3aa3			 
3aa3					; get address 
3aa3			 
3aa3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa3 cd 92 1b			call macro_dsp_valuehl 
3aa6				endm 
# End of macro FORTH_DSP_VALUEHL
3aa6				 
3aa6					; save it for cdump 
3aa6			 
3aa6 22 83 e6				ld (os_cur_ptr),hl 
3aa9			 
3aa9					; destroy value TOS 
3aa9			 
3aa9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa9 cd 4a 1c			call macro_forth_dsp_pop 
3aac				endm 
# End of macro FORTH_DSP_POP
3aac			 
3aac cd 1b 18				call dumpcont	; skip old style of param parsing	 
3aaf c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3ab0					NEXTW 
3ab0 c3 04 1d			jp macro_next 
3ab3				endm 
# End of macro NEXTW
3ab3			.CDUMP: 
3ab3				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3ab3 38				db WORD_SYS_CORE+36             
3ab4 e3 3a			dw .DAT            
3ab6 06				db 5 + 1 
3ab7 .. 00			db "CDUMP",0              
3abd				endm 
# End of macro CWHEAD
3abd			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3abd					if DEBUG_FORTH_WORDS_KEY 
3abd						DMARK "CDP" 
3abd f5				push af  
3abe 3a d2 3a			ld a, (.dmark)  
3ac1 32 7a ee			ld (debug_mark),a  
3ac4 3a d3 3a			ld a, (.dmark+1)  
3ac7 32 7b ee			ld (debug_mark+1),a  
3aca 3a d4 3a			ld a, (.dmark+2)  
3acd 32 7c ee			ld (debug_mark+2),a  
3ad0 18 03			jr .pastdmark  
3ad2 ..			.dmark: db "CDP"  
3ad5 f1			.pastdmark: pop af  
3ad6			endm  
# End of macro DMARK
3ad6						CALLMONITOR 
3ad6 cd 0e 14			call break_point_state  
3ad9				endm  
# End of macro CALLMONITOR
3ad9					endif 
3ad9 cd 85 09				call clear_display 
3adc cd 1b 18				call dumpcont	 
3adf c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3ae0					NEXTW 
3ae0 c3 04 1d			jp macro_next 
3ae3				endm 
# End of macro NEXTW
3ae3			 
3ae3			 
3ae3			 
3ae3			 
3ae3			.DAT: 
3ae3				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3ae3 3d				db WORD_SYS_CORE+41             
3ae4 39 3b			dw .HOME            
3ae6 03				db 2 + 1 
3ae7 .. 00			db "AT",0              
3aea				endm 
# End of macro CWHEAD
3aea			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3aea					if DEBUG_FORTH_WORDS_KEY 
3aea						DMARK "AT." 
3aea f5				push af  
3aeb 3a ff 3a			ld a, (.dmark)  
3aee 32 7a ee			ld (debug_mark),a  
3af1 3a 00 3b			ld a, (.dmark+1)  
3af4 32 7b ee			ld (debug_mark+1),a  
3af7 3a 01 3b			ld a, (.dmark+2)  
3afa 32 7c ee			ld (debug_mark+2),a  
3afd 18 03			jr .pastdmark  
3aff ..			.dmark: db "AT."  
3b02 f1			.pastdmark: pop af  
3b03			endm  
# End of macro DMARK
3b03						CALLMONITOR 
3b03 cd 0e 14			call break_point_state  
3b06				endm  
# End of macro CALLMONITOR
3b06					endif 
3b06					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b06 cd 92 1b			call macro_dsp_valuehl 
3b09				endm 
# End of macro FORTH_DSP_VALUEHL
3b09			 
3b09			 
3b09					; TODO save cursor row 
3b09 7d					ld a,l 
3b0a fe 02				cp 2 
3b0c 20 04				jr nz, .crow3 
3b0e 3e 28				ld a, display_row_2 
3b10 18 12				jr .ccol1 
3b12 fe 03		.crow3:		cp 3 
3b14 20 04				jr nz, .crow4 
3b16 3e 50				ld a, display_row_3 
3b18 18 0a				jr .ccol1 
3b1a fe 04		.crow4:		cp 4 
3b1c 20 04				jr nz, .crow1 
3b1e 3e 78				ld a, display_row_4 
3b20 18 02				jr .ccol1 
3b22 3e 00		.crow1:		ld a,display_row_1 
3b24 f5			.ccol1:		push af			; got row offset 
3b25 6f					ld l,a 
3b26 26 00				ld h,0 
3b28					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b28 cd 4a 1c			call macro_forth_dsp_pop 
3b2b				endm 
# End of macro FORTH_DSP_POP
3b2b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b2b cd 92 1b			call macro_dsp_valuehl 
3b2e				endm 
# End of macro FORTH_DSP_VALUEHL
3b2e					; TODO save cursor col 
3b2e f1					pop af 
3b2f 85					add l		; add col offset 
3b30 32 49 eb				ld (f_cursor_ptr), a 
3b33					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b33 cd 4a 1c			call macro_forth_dsp_pop 
3b36				endm 
# End of macro FORTH_DSP_POP
3b36			 
3b36					; calculate  
3b36			 
3b36					NEXTW 
3b36 c3 04 1d			jp macro_next 
3b39				endm 
# End of macro NEXTW
3b39			 
3b39			 
3b39			.HOME: 
3b39				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3b39 41				db WORD_SYS_CORE+45             
3b3a 66 3b			dw .SPACE            
3b3c 05				db 4 + 1 
3b3d .. 00			db "HOME",0              
3b42				endm 
# End of macro CWHEAD
3b42			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3b42					if DEBUG_FORTH_WORDS_KEY 
3b42						DMARK "HOM" 
3b42 f5				push af  
3b43 3a 57 3b			ld a, (.dmark)  
3b46 32 7a ee			ld (debug_mark),a  
3b49 3a 58 3b			ld a, (.dmark+1)  
3b4c 32 7b ee			ld (debug_mark+1),a  
3b4f 3a 59 3b			ld a, (.dmark+2)  
3b52 32 7c ee			ld (debug_mark+2),a  
3b55 18 03			jr .pastdmark  
3b57 ..			.dmark: db "HOM"  
3b5a f1			.pastdmark: pop af  
3b5b			endm  
# End of macro DMARK
3b5b						CALLMONITOR 
3b5b cd 0e 14			call break_point_state  
3b5e				endm  
# End of macro CALLMONITOR
3b5e					endif 
3b5e 3e 00		.home:		ld a, 0		; and home cursor 
3b60 32 49 eb				ld (f_cursor_ptr), a 
3b63					NEXTW 
3b63 c3 04 1d			jp macro_next 
3b66				endm 
# End of macro NEXTW
3b66			 
3b66			 
3b66			.SPACE: 
3b66				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3b66 46				db WORD_SYS_CORE+50             
3b67 94 3b			dw .SPACES            
3b69 03				db 2 + 1 
3b6a .. 00			db "BL",0              
3b6d				endm 
# End of macro CWHEAD
3b6d			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3b6d					if DEBUG_FORTH_WORDS_KEY 
3b6d						DMARK "BL." 
3b6d f5				push af  
3b6e 3a 82 3b			ld a, (.dmark)  
3b71 32 7a ee			ld (debug_mark),a  
3b74 3a 83 3b			ld a, (.dmark+1)  
3b77 32 7b ee			ld (debug_mark+1),a  
3b7a 3a 84 3b			ld a, (.dmark+2)  
3b7d 32 7c ee			ld (debug_mark+2),a  
3b80 18 03			jr .pastdmark  
3b82 ..			.dmark: db "BL."  
3b85 f1			.pastdmark: pop af  
3b86			endm  
# End of macro DMARK
3b86						CALLMONITOR 
3b86 cd 0e 14			call break_point_state  
3b89				endm  
# End of macro CALLMONITOR
3b89					endif 
3b89 21 92 3b				ld hl, .blstr 
3b8c cd 09 1a				call forth_push_str 
3b8f					 
3b8f				       NEXTW 
3b8f c3 04 1d			jp macro_next 
3b92				endm 
# End of macro NEXTW
3b92			 
3b92 .. 00		.blstr: db " ", 0 
3b94			 
3b94			.SPACES: 
3b94				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3b94 47				db WORD_SYS_CORE+51             
3b95 2f 3c			dw .SCROLL            
3b97 07				db 6 + 1 
3b98 .. 00			db "SPACES",0              
3b9f				endm 
# End of macro CWHEAD
3b9f			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3b9f					if DEBUG_FORTH_WORDS_KEY 
3b9f						DMARK "SPS" 
3b9f f5				push af  
3ba0 3a b4 3b			ld a, (.dmark)  
3ba3 32 7a ee			ld (debug_mark),a  
3ba6 3a b5 3b			ld a, (.dmark+1)  
3ba9 32 7b ee			ld (debug_mark+1),a  
3bac 3a b6 3b			ld a, (.dmark+2)  
3baf 32 7c ee			ld (debug_mark+2),a  
3bb2 18 03			jr .pastdmark  
3bb4 ..			.dmark: db "SPS"  
3bb7 f1			.pastdmark: pop af  
3bb8			endm  
# End of macro DMARK
3bb8						CALLMONITOR 
3bb8 cd 0e 14			call break_point_state  
3bbb				endm  
# End of macro CALLMONITOR
3bbb					endif 
3bbb			 
3bbb			 
3bbb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bbb cd 92 1b			call macro_dsp_valuehl 
3bbe				endm 
# End of macro FORTH_DSP_VALUEHL
3bbe			 
3bbe			;		push hl    ; u 
3bbe					if DEBUG_FORTH_WORDS 
3bbe						DMARK "SPA" 
3bbe f5				push af  
3bbf 3a d3 3b			ld a, (.dmark)  
3bc2 32 7a ee			ld (debug_mark),a  
3bc5 3a d4 3b			ld a, (.dmark+1)  
3bc8 32 7b ee			ld (debug_mark+1),a  
3bcb 3a d5 3b			ld a, (.dmark+2)  
3bce 32 7c ee			ld (debug_mark+2),a  
3bd1 18 03			jr .pastdmark  
3bd3 ..			.dmark: db "SPA"  
3bd6 f1			.pastdmark: pop af  
3bd7			endm  
# End of macro DMARK
3bd7						CALLMONITOR 
3bd7 cd 0e 14			call break_point_state  
3bda				endm  
# End of macro CALLMONITOR
3bda					endif 
3bda			 
3bda					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bda cd 4a 1c			call macro_forth_dsp_pop 
3bdd				endm 
# End of macro FORTH_DSP_POP
3bdd			;		pop hl 
3bdd 4d					ld c, l 
3bde 06 00				ld b, 0 
3be0 21 60 e3				ld hl, scratch  
3be3			 
3be3					if DEBUG_FORTH_WORDS 
3be3						DMARK "SP2" 
3be3 f5				push af  
3be4 3a f8 3b			ld a, (.dmark)  
3be7 32 7a ee			ld (debug_mark),a  
3bea 3a f9 3b			ld a, (.dmark+1)  
3bed 32 7b ee			ld (debug_mark+1),a  
3bf0 3a fa 3b			ld a, (.dmark+2)  
3bf3 32 7c ee			ld (debug_mark+2),a  
3bf6 18 03			jr .pastdmark  
3bf8 ..			.dmark: db "SP2"  
3bfb f1			.pastdmark: pop af  
3bfc			endm  
# End of macro DMARK
3bfc						CALLMONITOR 
3bfc cd 0e 14			call break_point_state  
3bff				endm  
# End of macro CALLMONITOR
3bff					endif 
3bff 3e 20				ld a, ' ' 
3c01 c5			.spaces1:	push bc 
3c02 77					ld (hl),a 
3c03 23					inc hl 
3c04 c1					pop bc 
3c05 10 fa				djnz .spaces1 
3c07 3e 00				ld a,0 
3c09 77					ld (hl),a 
3c0a 21 60 e3				ld hl, scratch 
3c0d					if DEBUG_FORTH_WORDS 
3c0d						DMARK "SP3" 
3c0d f5				push af  
3c0e 3a 22 3c			ld a, (.dmark)  
3c11 32 7a ee			ld (debug_mark),a  
3c14 3a 23 3c			ld a, (.dmark+1)  
3c17 32 7b ee			ld (debug_mark+1),a  
3c1a 3a 24 3c			ld a, (.dmark+2)  
3c1d 32 7c ee			ld (debug_mark+2),a  
3c20 18 03			jr .pastdmark  
3c22 ..			.dmark: db "SP3"  
3c25 f1			.pastdmark: pop af  
3c26			endm  
# End of macro DMARK
3c26						CALLMONITOR 
3c26 cd 0e 14			call break_point_state  
3c29				endm  
# End of macro CALLMONITOR
3c29					endif 
3c29 cd 04 1b				call forth_apush 
3c2c			 
3c2c				       NEXTW 
3c2c c3 04 1d			jp macro_next 
3c2f				endm 
# End of macro NEXTW
3c2f			 
3c2f			 
3c2f			 
3c2f			.SCROLL: 
3c2f				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3c2f 53				db WORD_SYS_CORE+63             
3c30 5c 3c			dw .SCROLLD            
3c32 07				db 6 + 1 
3c33 .. 00			db "SCROLL",0              
3c3a				endm 
# End of macro CWHEAD
3c3a			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3c3a					if DEBUG_FORTH_WORDS_KEY 
3c3a						DMARK "SCR" 
3c3a f5				push af  
3c3b 3a 4f 3c			ld a, (.dmark)  
3c3e 32 7a ee			ld (debug_mark),a  
3c41 3a 50 3c			ld a, (.dmark+1)  
3c44 32 7b ee			ld (debug_mark+1),a  
3c47 3a 51 3c			ld a, (.dmark+2)  
3c4a 32 7c ee			ld (debug_mark+2),a  
3c4d 18 03			jr .pastdmark  
3c4f ..			.dmark: db "SCR"  
3c52 f1			.pastdmark: pop af  
3c53			endm  
# End of macro DMARK
3c53						CALLMONITOR 
3c53 cd 0e 14			call break_point_state  
3c56				endm  
# End of macro CALLMONITOR
3c56					endif 
3c56			 
3c56 cd 47 09			call scroll_up 
3c59			;	call update_display 
3c59			 
3c59					NEXTW 
3c59 c3 04 1d			jp macro_next 
3c5c				endm 
# End of macro NEXTW
3c5c			 
3c5c			 
3c5c			 
3c5c			;		; get dir 
3c5c			; 
3c5c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c5c			; 
3c5c			;		push hl 
3c5c			; 
3c5c			;		; destroy value TOS 
3c5c			; 
3c5c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c5c			; 
3c5c			;		; get count 
3c5c			; 
3c5c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c5c			; 
3c5c			;		push hl 
3c5c			; 
3c5c			;		; destroy value TOS 
3c5c			; 
3c5c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c5c			; 
3c5c			;		; one value on hl get other one back 
3c5c			; 
3c5c			;		pop bc    ; count 
3c5c			; 
3c5c			;		pop de   ; dir 
3c5c			; 
3c5c			; 
3c5c			;		ld b, c 
3c5c			; 
3c5c			;.scrolldir:     push bc 
3c5c			;		push de 
3c5c			; 
3c5c			;		ld a, 0 
3c5c			;		cp e 
3c5c			;		jr z, .scrollup  
3c5c			;		call scroll_down 
3c5c			;		jr .scrollnext 
3c5c			;.scrollup:	call scroll_up 
3c5c			; 
3c5c			;		 
3c5c			;.scrollnext: 
3c5c			;		pop de 
3c5c			;		pop bc 
3c5c			;		djnz .scrolldir 
3c5c			; 
3c5c			; 
3c5c			; 
3c5c			; 
3c5c			; 
3c5c			;		NEXTW 
3c5c			 
3c5c			.SCROLLD: 
3c5c				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3c5c 53				db WORD_SYS_CORE+63             
3c5d 8a 3c			dw .ATQ            
3c5f 08				db 7 + 1 
3c60 .. 00			db "SCROLLD",0              
3c68				endm 
# End of macro CWHEAD
3c68			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3c68					if DEBUG_FORTH_WORDS_KEY 
3c68						DMARK "SCD" 
3c68 f5				push af  
3c69 3a 7d 3c			ld a, (.dmark)  
3c6c 32 7a ee			ld (debug_mark),a  
3c6f 3a 7e 3c			ld a, (.dmark+1)  
3c72 32 7b ee			ld (debug_mark+1),a  
3c75 3a 7f 3c			ld a, (.dmark+2)  
3c78 32 7c ee			ld (debug_mark+2),a  
3c7b 18 03			jr .pastdmark  
3c7d ..			.dmark: db "SCD"  
3c80 f1			.pastdmark: pop af  
3c81			endm  
# End of macro DMARK
3c81						CALLMONITOR 
3c81 cd 0e 14			call break_point_state  
3c84				endm  
# End of macro CALLMONITOR
3c84					endif 
3c84			 
3c84 cd 6b 09			call scroll_down 
3c87			;	call update_display 
3c87			 
3c87					NEXTW 
3c87 c3 04 1d			jp macro_next 
3c8a				endm 
# End of macro NEXTW
3c8a			 
3c8a			 
3c8a			.ATQ: 
3c8a				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3c8a 62				db WORD_SYS_CORE+78             
3c8b e8 3c			dw .AUTODSP            
3c8d 04				db 3 + 1 
3c8e .. 00			db "AT@",0              
3c92				endm 
# End of macro CWHEAD
3c92			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3c92					if DEBUG_FORTH_WORDS_KEY 
3c92						DMARK "ATA" 
3c92 f5				push af  
3c93 3a a7 3c			ld a, (.dmark)  
3c96 32 7a ee			ld (debug_mark),a  
3c99 3a a8 3c			ld a, (.dmark+1)  
3c9c 32 7b ee			ld (debug_mark+1),a  
3c9f 3a a9 3c			ld a, (.dmark+2)  
3ca2 32 7c ee			ld (debug_mark+2),a  
3ca5 18 03			jr .pastdmark  
3ca7 ..			.dmark: db "ATA"  
3caa f1			.pastdmark: pop af  
3cab			endm  
# End of macro DMARK
3cab						CALLMONITOR 
3cab cd 0e 14			call break_point_state  
3cae				endm  
# End of macro CALLMONITOR
3cae					endif 
3cae			 
3cae			 
3cae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cae cd 92 1b			call macro_dsp_valuehl 
3cb1				endm 
# End of macro FORTH_DSP_VALUEHL
3cb1			 
3cb1					; TODO save cursor row 
3cb1 7d					ld a,l 
3cb2 fe 02				cp 2 
3cb4 20 04				jr nz, .crow3aq 
3cb6 3e 28				ld a, display_row_2 
3cb8 18 12				jr .ccol1aq 
3cba fe 03		.crow3aq:		cp 3 
3cbc 20 04				jr nz, .crow4aq 
3cbe 3e 50				ld a, display_row_3 
3cc0 18 0a				jr .ccol1aq 
3cc2 fe 04		.crow4aq:		cp 4 
3cc4 20 04				jr nz, .crow1aq 
3cc6 3e 78				ld a, display_row_4 
3cc8 18 02				jr .ccol1aq 
3cca 3e 00		.crow1aq:		ld a,display_row_1 
3ccc f5			.ccol1aq:		push af			; got row offset 
3ccd 6f					ld l,a 
3cce 26 00				ld h,0 
3cd0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cd0 cd 4a 1c			call macro_forth_dsp_pop 
3cd3				endm 
# End of macro FORTH_DSP_POP
3cd3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cd3 cd 92 1b			call macro_dsp_valuehl 
3cd6				endm 
# End of macro FORTH_DSP_VALUEHL
3cd6					; TODO save cursor col 
3cd6 f1					pop af 
3cd7 85					add l		; add col offset 
3cd8			 
3cd8					; add current frame buffer address 
3cd8 2a db eb				ld hl, (display_fb_active) 
3cdb cd b2 0b				call addatohl 
3cde			 
3cde			 
3cde			 
3cde			 
3cde					; get char frame buffer location offset in hl 
3cde			 
3cde 7e					ld a,(hl) 
3cdf 26 00				ld h, 0 
3ce1 6f					ld l, a 
3ce2			 
3ce2 cd 9b 19				call forth_push_numhl 
3ce5			 
3ce5			 
3ce5					NEXTW 
3ce5 c3 04 1d			jp macro_next 
3ce8				endm 
# End of macro NEXTW
3ce8			 
3ce8			.AUTODSP: 
3ce8				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3ce8 63				db WORD_SYS_CORE+79             
3ce9 fe 3c			dw .MENU            
3ceb 05				db 4 + 1 
3cec .. 00			db "ADSP",0              
3cf1				endm 
# End of macro CWHEAD
3cf1			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3cf1			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3cf1			 
3cf1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cf1 cd 92 1b			call macro_dsp_valuehl 
3cf4				endm 
# End of macro FORTH_DSP_VALUEHL
3cf4			 
3cf4			;		push hl 
3cf4			 
3cf4					; destroy value TOS 
3cf4			 
3cf4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cf4 cd 4a 1c			call macro_forth_dsp_pop 
3cf7				endm 
# End of macro FORTH_DSP_POP
3cf7			 
3cf7			;		pop hl 
3cf7			 
3cf7 7d					ld a,l 
3cf8 32 27 eb				ld (cli_autodisplay), a 
3cfb				       NEXTW 
3cfb c3 04 1d			jp macro_next 
3cfe				endm 
# End of macro NEXTW
3cfe			 
3cfe			.MENU: 
3cfe				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3cfe 70				db WORD_SYS_CORE+92             
3cff a7 3d			dw .ENDDISPLAY            
3d01 05				db 4 + 1 
3d02 .. 00			db "MENU",0              
3d07				endm 
# End of macro CWHEAD
3d07			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3d07			 
3d07			;		; get number of items on the stack 
3d07			; 
3d07				 
3d07					FORTH_DSP_VALUEHL 
3d07 cd 92 1b			call macro_dsp_valuehl 
3d0a				endm 
# End of macro FORTH_DSP_VALUEHL
3d0a				 
3d0a					if DEBUG_FORTH_WORDS_KEY 
3d0a						DMARK "MNU" 
3d0a f5				push af  
3d0b 3a 1f 3d			ld a, (.dmark)  
3d0e 32 7a ee			ld (debug_mark),a  
3d11 3a 20 3d			ld a, (.dmark+1)  
3d14 32 7b ee			ld (debug_mark+1),a  
3d17 3a 21 3d			ld a, (.dmark+2)  
3d1a 32 7c ee			ld (debug_mark+2),a  
3d1d 18 03			jr .pastdmark  
3d1f ..			.dmark: db "MNU"  
3d22 f1			.pastdmark: pop af  
3d23			endm  
# End of macro DMARK
3d23						CALLMONITOR 
3d23 cd 0e 14			call break_point_state  
3d26				endm  
# End of macro CALLMONITOR
3d26					endif 
3d26			 
3d26 45					ld b, l	 
3d27 05					dec b 
3d28			 
3d28					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d28 cd 4a 1c			call macro_forth_dsp_pop 
3d2b				endm 
# End of macro FORTH_DSP_POP
3d2b			 
3d2b			 
3d2b					; go directly through the stack to pluck out the string pointers and build an array 
3d2b			 
3d2b			;		FORTH_DSP 
3d2b			 
3d2b					; hl contains top most stack item 
3d2b				 
3d2b 11 60 e3				ld de, scratch 
3d2e			 
3d2e			.mbuild: 
3d2e			 
3d2e					FORTH_DSP_VALUEHL 
3d2e cd 92 1b			call macro_dsp_valuehl 
3d31				endm 
# End of macro FORTH_DSP_VALUEHL
3d31			 
3d31					if DEBUG_FORTH_WORDS 
3d31						DMARK "MN3" 
3d31 f5				push af  
3d32 3a 46 3d			ld a, (.dmark)  
3d35 32 7a ee			ld (debug_mark),a  
3d38 3a 47 3d			ld a, (.dmark+1)  
3d3b 32 7b ee			ld (debug_mark+1),a  
3d3e 3a 48 3d			ld a, (.dmark+2)  
3d41 32 7c ee			ld (debug_mark+2),a  
3d44 18 03			jr .pastdmark  
3d46 ..			.dmark: db "MN3"  
3d49 f1			.pastdmark: pop af  
3d4a			endm  
# End of macro DMARK
3d4a						CALLMONITOR 
3d4a cd 0e 14			call break_point_state  
3d4d				endm  
# End of macro CALLMONITOR
3d4d					endif 
3d4d eb					ex de, hl 
3d4e 73					ld (hl), e 
3d4f 23					inc hl 
3d50 72					ld (hl), d 
3d51 23					inc hl 
3d52 eb					ex de, hl 
3d53			 
3d53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d53 cd 4a 1c			call macro_forth_dsp_pop 
3d56				endm 
# End of macro FORTH_DSP_POP
3d56			 
3d56 10 d6				djnz .mbuild 
3d58			 
3d58					; done add term 
3d58			 
3d58 eb					ex de, hl 
3d59 36 00				ld (hl), 0 
3d5b 23					inc hl 
3d5c 36 00				ld (hl), 0 
3d5e			 
3d5e				 
3d5e					 
3d5e 21 60 e3				ld hl, scratch 
3d61			 
3d61					if DEBUG_FORTH_WORDS 
3d61						DMARK "MNx" 
3d61 f5				push af  
3d62 3a 76 3d			ld a, (.dmark)  
3d65 32 7a ee			ld (debug_mark),a  
3d68 3a 77 3d			ld a, (.dmark+1)  
3d6b 32 7b ee			ld (debug_mark+1),a  
3d6e 3a 78 3d			ld a, (.dmark+2)  
3d71 32 7c ee			ld (debug_mark+2),a  
3d74 18 03			jr .pastdmark  
3d76 ..			.dmark: db "MNx"  
3d79 f1			.pastdmark: pop af  
3d7a			endm  
# End of macro DMARK
3d7a						CALLMONITOR 
3d7a cd 0e 14			call break_point_state  
3d7d				endm  
# End of macro CALLMONITOR
3d7d					endif 
3d7d			 
3d7d			 
3d7d			 
3d7d 3e 00				ld a, 0 
3d7f cd b6 09				call menu 
3d82			 
3d82			 
3d82 6f					ld l, a 
3d83 26 00				ld h, 0 
3d85			 
3d85					if DEBUG_FORTH_WORDS 
3d85						DMARK "MNr" 
3d85 f5				push af  
3d86 3a 9a 3d			ld a, (.dmark)  
3d89 32 7a ee			ld (debug_mark),a  
3d8c 3a 9b 3d			ld a, (.dmark+1)  
3d8f 32 7b ee			ld (debug_mark+1),a  
3d92 3a 9c 3d			ld a, (.dmark+2)  
3d95 32 7c ee			ld (debug_mark+2),a  
3d98 18 03			jr .pastdmark  
3d9a ..			.dmark: db "MNr"  
3d9d f1			.pastdmark: pop af  
3d9e			endm  
# End of macro DMARK
3d9e						CALLMONITOR 
3d9e cd 0e 14			call break_point_state  
3da1				endm  
# End of macro CALLMONITOR
3da1					endif 
3da1			 
3da1 cd 9b 19				call forth_push_numhl 
3da4			 
3da4			 
3da4			 
3da4			 
3da4				       NEXTW 
3da4 c3 04 1d			jp macro_next 
3da7				endm 
# End of macro NEXTW
3da7			 
3da7			 
3da7			.ENDDISPLAY: 
3da7			 
3da7			; eof 
# End of file forth_words_display.asm
3da7			include "forth_words_str.asm" 
3da7			 
3da7			; | ## String Words 
3da7			 
3da7			.PTR:   
3da7			 
3da7				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3da7 48				db WORD_SYS_CORE+52             
3da8 d4 3d			dw .STYPE            
3daa 04				db 3 + 1 
3dab .. 00			db "PTR",0              
3daf				endm 
# End of macro CWHEAD
3daf			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3daf			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3daf			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3daf			 
3daf					if DEBUG_FORTH_WORDS_KEY 
3daf						DMARK "PTR" 
3daf f5				push af  
3db0 3a c4 3d			ld a, (.dmark)  
3db3 32 7a ee			ld (debug_mark),a  
3db6 3a c5 3d			ld a, (.dmark+1)  
3db9 32 7b ee			ld (debug_mark+1),a  
3dbc 3a c6 3d			ld a, (.dmark+2)  
3dbf 32 7c ee			ld (debug_mark+2),a  
3dc2 18 03			jr .pastdmark  
3dc4 ..			.dmark: db "PTR"  
3dc7 f1			.pastdmark: pop af  
3dc8			endm  
# End of macro DMARK
3dc8						CALLMONITOR 
3dc8 cd 0e 14			call break_point_state  
3dcb				endm  
# End of macro CALLMONITOR
3dcb					endif 
3dcb					FORTH_DSP_VALUEHL 
3dcb cd 92 1b			call macro_dsp_valuehl 
3dce				endm 
# End of macro FORTH_DSP_VALUEHL
3dce cd 9b 19				call forth_push_numhl 
3dd1			 
3dd1			 
3dd1					NEXTW 
3dd1 c3 04 1d			jp macro_next 
3dd4				endm 
# End of macro NEXTW
3dd4			.STYPE: 
3dd4				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3dd4 48				db WORD_SYS_CORE+52             
3dd5 23 3e			dw .UPPER            
3dd7 06				db 5 + 1 
3dd8 .. 00			db "STYPE",0              
3dde				endm 
# End of macro CWHEAD
3dde			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3dde					if DEBUG_FORTH_WORDS_KEY 
3dde						DMARK "STY" 
3dde f5				push af  
3ddf 3a f3 3d			ld a, (.dmark)  
3de2 32 7a ee			ld (debug_mark),a  
3de5 3a f4 3d			ld a, (.dmark+1)  
3de8 32 7b ee			ld (debug_mark+1),a  
3deb 3a f5 3d			ld a, (.dmark+2)  
3dee 32 7c ee			ld (debug_mark+2),a  
3df1 18 03			jr .pastdmark  
3df3 ..			.dmark: db "STY"  
3df6 f1			.pastdmark: pop af  
3df7			endm  
# End of macro DMARK
3df7						CALLMONITOR 
3df7 cd 0e 14			call break_point_state  
3dfa				endm  
# End of macro CALLMONITOR
3dfa					endif 
3dfa					FORTH_DSP 
3dfa cd 58 1b			call macro_forth_dsp 
3dfd				endm 
# End of macro FORTH_DSP
3dfd					;v5 FORTH_DSP_VALUE 
3dfd			 
3dfd 7e					ld a, (hl) 
3dfe			 
3dfe f5					push af 
3dff			 
3dff			; Dont destroy TOS		FORTH_DSP_POP 
3dff			 
3dff f1					pop af 
3e00			 
3e00 fe 01				cp DS_TYPE_STR 
3e02 28 09				jr z, .typestr 
3e04			 
3e04 fe 02				cp DS_TYPE_INUM 
3e06 28 0a				jr z, .typeinum 
3e08			 
3e08 21 21 3e				ld hl, .tna 
3e0b 18 0a				jr .tpush 
3e0d			 
3e0d 21 1d 3e		.typestr:	ld hl, .tstr 
3e10 18 05				jr .tpush 
3e12 21 1f 3e		.typeinum:	ld hl, .tinum 
3e15 18 00				jr .tpush 
3e17			 
3e17			.tpush: 
3e17			 
3e17 cd 09 1a				call forth_push_str 
3e1a			 
3e1a					NEXTW 
3e1a c3 04 1d			jp macro_next 
3e1d				endm 
# End of macro NEXTW
3e1d .. 00		.tstr:	db "s",0 
3e1f .. 00		.tinum:  db "i",0 
3e21 .. 00		.tna:   db "?", 0 
3e23			 
3e23			 
3e23			.UPPER: 
3e23				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3e23 48				db WORD_SYS_CORE+52             
3e24 5e 3e			dw .LOWER            
3e26 06				db 5 + 1 
3e27 .. 00			db "UPPER",0              
3e2d				endm 
# End of macro CWHEAD
3e2d			; | UPPER ( s -- s ) Upper case string s  | DONE 
3e2d					if DEBUG_FORTH_WORDS_KEY 
3e2d						DMARK "UPR" 
3e2d f5				push af  
3e2e 3a 42 3e			ld a, (.dmark)  
3e31 32 7a ee			ld (debug_mark),a  
3e34 3a 43 3e			ld a, (.dmark+1)  
3e37 32 7b ee			ld (debug_mark+1),a  
3e3a 3a 44 3e			ld a, (.dmark+2)  
3e3d 32 7c ee			ld (debug_mark+2),a  
3e40 18 03			jr .pastdmark  
3e42 ..			.dmark: db "UPR"  
3e45 f1			.pastdmark: pop af  
3e46			endm  
# End of macro DMARK
3e46						CALLMONITOR 
3e46 cd 0e 14			call break_point_state  
3e49				endm  
# End of macro CALLMONITOR
3e49					endif 
3e49			 
3e49					FORTH_DSP 
3e49 cd 58 1b			call macro_forth_dsp 
3e4c				endm 
# End of macro FORTH_DSP
3e4c					 
3e4c			; TODO check is string type 
3e4c			 
3e4c					FORTH_DSP_VALUEHL 
3e4c cd 92 1b			call macro_dsp_valuehl 
3e4f				endm 
# End of macro FORTH_DSP_VALUEHL
3e4f			; get pointer to string in hl 
3e4f			 
3e4f 7e			.toup:		ld a, (hl) 
3e50 fe 00				cp 0 
3e52 28 07				jr z, .toupdone 
3e54			 
3e54 cd 1f 0f				call to_upper 
3e57			 
3e57 77					ld (hl), a 
3e58 23					inc hl 
3e59 18 f4				jr .toup 
3e5b			 
3e5b					 
3e5b			 
3e5b			 
3e5b			; for each char convert to upper 
3e5b					 
3e5b			.toupdone: 
3e5b			 
3e5b			 
3e5b					NEXTW 
3e5b c3 04 1d			jp macro_next 
3e5e				endm 
# End of macro NEXTW
3e5e			.LOWER: 
3e5e				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3e5e 48				db WORD_SYS_CORE+52             
3e5f 99 3e			dw .TCASE            
3e61 06				db 5 + 1 
3e62 .. 00			db "LOWER",0              
3e68				endm 
# End of macro CWHEAD
3e68			; | LOWER ( s -- s ) Lower case string s  | DONE 
3e68					if DEBUG_FORTH_WORDS_KEY 
3e68						DMARK "LWR" 
3e68 f5				push af  
3e69 3a 7d 3e			ld a, (.dmark)  
3e6c 32 7a ee			ld (debug_mark),a  
3e6f 3a 7e 3e			ld a, (.dmark+1)  
3e72 32 7b ee			ld (debug_mark+1),a  
3e75 3a 7f 3e			ld a, (.dmark+2)  
3e78 32 7c ee			ld (debug_mark+2),a  
3e7b 18 03			jr .pastdmark  
3e7d ..			.dmark: db "LWR"  
3e80 f1			.pastdmark: pop af  
3e81			endm  
# End of macro DMARK
3e81						CALLMONITOR 
3e81 cd 0e 14			call break_point_state  
3e84				endm  
# End of macro CALLMONITOR
3e84					endif 
3e84			 
3e84					FORTH_DSP 
3e84 cd 58 1b			call macro_forth_dsp 
3e87				endm 
# End of macro FORTH_DSP
3e87					 
3e87			; TODO check is string type 
3e87			 
3e87					FORTH_DSP_VALUEHL 
3e87 cd 92 1b			call macro_dsp_valuehl 
3e8a				endm 
# End of macro FORTH_DSP_VALUEHL
3e8a			; get pointer to string in hl 
3e8a			 
3e8a 7e			.tolow:		ld a, (hl) 
3e8b fe 00				cp 0 
3e8d 28 07				jr z, .tolowdone 
3e8f			 
3e8f cd 28 0f				call to_lower 
3e92			 
3e92 77					ld (hl), a 
3e93 23					inc hl 
3e94 18 f4				jr .tolow 
3e96			 
3e96					 
3e96			 
3e96			 
3e96			; for each char convert to low 
3e96					 
3e96			.tolowdone: 
3e96					NEXTW 
3e96 c3 04 1d			jp macro_next 
3e99				endm 
# End of macro NEXTW
3e99			.TCASE: 
3e99				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3e99 48				db WORD_SYS_CORE+52             
3e9a cf 3f			dw .SUBSTR            
3e9c 06				db 5 + 1 
3e9d .. 00			db "TCASE",0              
3ea3				endm 
# End of macro CWHEAD
3ea3			; | TCASE ( s -- s ) Title case string s  | DONE 
3ea3					if DEBUG_FORTH_WORDS_KEY 
3ea3						DMARK "TCS" 
3ea3 f5				push af  
3ea4 3a b8 3e			ld a, (.dmark)  
3ea7 32 7a ee			ld (debug_mark),a  
3eaa 3a b9 3e			ld a, (.dmark+1)  
3ead 32 7b ee			ld (debug_mark+1),a  
3eb0 3a ba 3e			ld a, (.dmark+2)  
3eb3 32 7c ee			ld (debug_mark+2),a  
3eb6 18 03			jr .pastdmark  
3eb8 ..			.dmark: db "TCS"  
3ebb f1			.pastdmark: pop af  
3ebc			endm  
# End of macro DMARK
3ebc						CALLMONITOR 
3ebc cd 0e 14			call break_point_state  
3ebf				endm  
# End of macro CALLMONITOR
3ebf					endif 
3ebf			 
3ebf					FORTH_DSP 
3ebf cd 58 1b			call macro_forth_dsp 
3ec2				endm 
# End of macro FORTH_DSP
3ec2					 
3ec2			; TODO check is string type 
3ec2			 
3ec2					FORTH_DSP_VALUEHL 
3ec2 cd 92 1b			call macro_dsp_valuehl 
3ec5				endm 
# End of macro FORTH_DSP_VALUEHL
3ec5			; get pointer to string in hl 
3ec5			 
3ec5					if DEBUG_FORTH_WORDS 
3ec5						DMARK "TC1" 
3ec5 f5				push af  
3ec6 3a da 3e			ld a, (.dmark)  
3ec9 32 7a ee			ld (debug_mark),a  
3ecc 3a db 3e			ld a, (.dmark+1)  
3ecf 32 7b ee			ld (debug_mark+1),a  
3ed2 3a dc 3e			ld a, (.dmark+2)  
3ed5 32 7c ee			ld (debug_mark+2),a  
3ed8 18 03			jr .pastdmark  
3eda ..			.dmark: db "TC1"  
3edd f1			.pastdmark: pop af  
3ede			endm  
# End of macro DMARK
3ede						CALLMONITOR 
3ede cd 0e 14			call break_point_state  
3ee1				endm  
# End of macro CALLMONITOR
3ee1					endif 
3ee1			 
3ee1					; first time in turn to upper case first char 
3ee1			 
3ee1 7e					ld a, (hl) 
3ee2 c3 6c 3f				jp .totsiptou 
3ee5			 
3ee5			 
3ee5 7e			.tot:		ld a, (hl) 
3ee6 fe 00				cp 0 
3ee8 ca b0 3f				jp z, .totdone 
3eeb			 
3eeb					if DEBUG_FORTH_WORDS 
3eeb						DMARK "TC2" 
3eeb f5				push af  
3eec 3a 00 3f			ld a, (.dmark)  
3eef 32 7a ee			ld (debug_mark),a  
3ef2 3a 01 3f			ld a, (.dmark+1)  
3ef5 32 7b ee			ld (debug_mark+1),a  
3ef8 3a 02 3f			ld a, (.dmark+2)  
3efb 32 7c ee			ld (debug_mark+2),a  
3efe 18 03			jr .pastdmark  
3f00 ..			.dmark: db "TC2"  
3f03 f1			.pastdmark: pop af  
3f04			endm  
# End of macro DMARK
3f04						CALLMONITOR 
3f04 cd 0e 14			call break_point_state  
3f07				endm  
# End of macro CALLMONITOR
3f07					endif 
3f07					; check to see if current char is a space 
3f07			 
3f07 fe 20				cp ' ' 
3f09 28 21				jr z, .totsp 
3f0b cd 28 0f				call to_lower 
3f0e					if DEBUG_FORTH_WORDS 
3f0e						DMARK "TC3" 
3f0e f5				push af  
3f0f 3a 23 3f			ld a, (.dmark)  
3f12 32 7a ee			ld (debug_mark),a  
3f15 3a 24 3f			ld a, (.dmark+1)  
3f18 32 7b ee			ld (debug_mark+1),a  
3f1b 3a 25 3f			ld a, (.dmark+2)  
3f1e 32 7c ee			ld (debug_mark+2),a  
3f21 18 03			jr .pastdmark  
3f23 ..			.dmark: db "TC3"  
3f26 f1			.pastdmark: pop af  
3f27			endm  
# End of macro DMARK
3f27						CALLMONITOR 
3f27 cd 0e 14			call break_point_state  
3f2a				endm  
# End of macro CALLMONITOR
3f2a					endif 
3f2a 18 63				jr .totnxt 
3f2c			 
3f2c			.totsp:         ; on a space, find next char which should be upper 
3f2c			 
3f2c					if DEBUG_FORTH_WORDS 
3f2c						DMARK "TC4" 
3f2c f5				push af  
3f2d 3a 41 3f			ld a, (.dmark)  
3f30 32 7a ee			ld (debug_mark),a  
3f33 3a 42 3f			ld a, (.dmark+1)  
3f36 32 7b ee			ld (debug_mark+1),a  
3f39 3a 43 3f			ld a, (.dmark+2)  
3f3c 32 7c ee			ld (debug_mark+2),a  
3f3f 18 03			jr .pastdmark  
3f41 ..			.dmark: db "TC4"  
3f44 f1			.pastdmark: pop af  
3f45			endm  
# End of macro DMARK
3f45						CALLMONITOR 
3f45 cd 0e 14			call break_point_state  
3f48				endm  
# End of macro CALLMONITOR
3f48					endif 
3f48					;; 
3f48			 
3f48 fe 20				cp ' ' 
3f4a 20 20				jr nz, .totsiptou 
3f4c 23					inc hl 
3f4d 7e					ld a, (hl) 
3f4e					if DEBUG_FORTH_WORDS 
3f4e						DMARK "TC5" 
3f4e f5				push af  
3f4f 3a 63 3f			ld a, (.dmark)  
3f52 32 7a ee			ld (debug_mark),a  
3f55 3a 64 3f			ld a, (.dmark+1)  
3f58 32 7b ee			ld (debug_mark+1),a  
3f5b 3a 65 3f			ld a, (.dmark+2)  
3f5e 32 7c ee			ld (debug_mark+2),a  
3f61 18 03			jr .pastdmark  
3f63 ..			.dmark: db "TC5"  
3f66 f1			.pastdmark: pop af  
3f67			endm  
# End of macro DMARK
3f67						CALLMONITOR 
3f67 cd 0e 14			call break_point_state  
3f6a				endm  
# End of macro CALLMONITOR
3f6a					endif 
3f6a 18 c0				jr .totsp 
3f6c fe 00		.totsiptou:    cp 0 
3f6e 28 40				jr z, .totdone 
3f70					; not space and not zero term so upper case it 
3f70 cd 1f 0f				call to_upper 
3f73			 
3f73					if DEBUG_FORTH_WORDS 
3f73						DMARK "TC6" 
3f73 f5				push af  
3f74 3a 88 3f			ld a, (.dmark)  
3f77 32 7a ee			ld (debug_mark),a  
3f7a 3a 89 3f			ld a, (.dmark+1)  
3f7d 32 7b ee			ld (debug_mark+1),a  
3f80 3a 8a 3f			ld a, (.dmark+2)  
3f83 32 7c ee			ld (debug_mark+2),a  
3f86 18 03			jr .pastdmark  
3f88 ..			.dmark: db "TC6"  
3f8b f1			.pastdmark: pop af  
3f8c			endm  
# End of macro DMARK
3f8c						CALLMONITOR 
3f8c cd 0e 14			call break_point_state  
3f8f				endm  
# End of macro CALLMONITOR
3f8f					endif 
3f8f			 
3f8f			 
3f8f			.totnxt: 
3f8f			 
3f8f 77					ld (hl), a 
3f90 23					inc hl 
3f91					if DEBUG_FORTH_WORDS 
3f91						DMARK "TC7" 
3f91 f5				push af  
3f92 3a a6 3f			ld a, (.dmark)  
3f95 32 7a ee			ld (debug_mark),a  
3f98 3a a7 3f			ld a, (.dmark+1)  
3f9b 32 7b ee			ld (debug_mark+1),a  
3f9e 3a a8 3f			ld a, (.dmark+2)  
3fa1 32 7c ee			ld (debug_mark+2),a  
3fa4 18 03			jr .pastdmark  
3fa6 ..			.dmark: db "TC7"  
3fa9 f1			.pastdmark: pop af  
3faa			endm  
# End of macro DMARK
3faa						CALLMONITOR 
3faa cd 0e 14			call break_point_state  
3fad				endm  
# End of macro CALLMONITOR
3fad					endif 
3fad c3 e5 3e				jp .tot 
3fb0			 
3fb0					 
3fb0			 
3fb0			 
3fb0			; for each char convert to low 
3fb0					 
3fb0			.totdone: 
3fb0					if DEBUG_FORTH_WORDS 
3fb0						DMARK "TCd" 
3fb0 f5				push af  
3fb1 3a c5 3f			ld a, (.dmark)  
3fb4 32 7a ee			ld (debug_mark),a  
3fb7 3a c6 3f			ld a, (.dmark+1)  
3fba 32 7b ee			ld (debug_mark+1),a  
3fbd 3a c7 3f			ld a, (.dmark+2)  
3fc0 32 7c ee			ld (debug_mark+2),a  
3fc3 18 03			jr .pastdmark  
3fc5 ..			.dmark: db "TCd"  
3fc8 f1			.pastdmark: pop af  
3fc9			endm  
# End of macro DMARK
3fc9						CALLMONITOR 
3fc9 cd 0e 14			call break_point_state  
3fcc				endm  
# End of macro CALLMONITOR
3fcc					endif 
3fcc					NEXTW 
3fcc c3 04 1d			jp macro_next 
3fcf				endm 
# End of macro NEXTW
3fcf			 
3fcf			.SUBSTR: 
3fcf				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3fcf 48				db WORD_SYS_CORE+52             
3fd0 2d 40			dw .LEFT            
3fd2 07				db 6 + 1 
3fd3 .. 00			db "SUBSTR",0              
3fda				endm 
# End of macro CWHEAD
3fda			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3fda			 
3fda					if DEBUG_FORTH_WORDS_KEY 
3fda						DMARK "SST" 
3fda f5				push af  
3fdb 3a ef 3f			ld a, (.dmark)  
3fde 32 7a ee			ld (debug_mark),a  
3fe1 3a f0 3f			ld a, (.dmark+1)  
3fe4 32 7b ee			ld (debug_mark+1),a  
3fe7 3a f1 3f			ld a, (.dmark+2)  
3fea 32 7c ee			ld (debug_mark+2),a  
3fed 18 03			jr .pastdmark  
3fef ..			.dmark: db "SST"  
3ff2 f1			.pastdmark: pop af  
3ff3			endm  
# End of macro DMARK
3ff3						CALLMONITOR 
3ff3 cd 0e 14			call break_point_state  
3ff6				endm  
# End of macro CALLMONITOR
3ff6					endif 
3ff6			; TODO check string type 
3ff6					FORTH_DSP_VALUEHL 
3ff6 cd 92 1b			call macro_dsp_valuehl 
3ff9				endm 
# End of macro FORTH_DSP_VALUEHL
3ff9			 
3ff9 e5					push hl      ; string length 
3ffa			 
3ffa					FORTH_DSP_POP 
3ffa cd 4a 1c			call macro_forth_dsp_pop 
3ffd				endm 
# End of macro FORTH_DSP_POP
3ffd			 
3ffd					FORTH_DSP_VALUEHL 
3ffd cd 92 1b			call macro_dsp_valuehl 
4000				endm 
# End of macro FORTH_DSP_VALUEHL
4000			 
4000 e5					push hl     ; start char 
4001			 
4001					FORTH_DSP_POP 
4001 cd 4a 1c			call macro_forth_dsp_pop 
4004				endm 
# End of macro FORTH_DSP_POP
4004			 
4004			 
4004					FORTH_DSP_VALUE 
4004 cd 7b 1b			call macro_forth_dsp_value 
4007				endm 
# End of macro FORTH_DSP_VALUE
4007			 
4007 d1					pop de    ; get start post offset 
4008			 
4008 19					add hl, de    ; starting offset 
4009			 
4009 c1					pop bc 
400a c5					push bc      ; grab size of string 
400b			 
400b e5					push hl    ; save string start  
400c			 
400c 26 00				ld h, 0 
400e 69					ld l, c 
400f 23					inc hl 
4010 23					inc hl 
4011			 
4011 cd 79 10				call malloc 
4014				if DEBUG_FORTH_MALLOC_GUARD 
4014 cc 43 46				call z,malloc_error 
4017				endif 
4017			 
4017 eb					ex de, hl      ; save malloc area for string copy 
4018 e1					pop hl    ; get back source 
4019 c1					pop bc    ; get length of string back 
401a			 
401a d5					push de    ; save malloc area for after we push 
401b ed b0				ldir     ; copy substr 
401d			 
401d			 
401d eb					ex de, hl 
401e 3e 00				ld a, 0 
4020 77					ld (hl), a   ; term substr 
4021			 
4021					 
4021 e1					pop hl    ; get malloc so we can push it 
4022 e5					push hl   ; save so we can free it afterwards 
4023			 
4023 cd 09 1a				call forth_push_str 
4026			 
4026 e1					pop hl 
4027 cd 43 11				call free 
402a			 
402a					 
402a					 
402a			 
402a			 
402a					NEXTW 
402a c3 04 1d			jp macro_next 
402d				endm 
# End of macro NEXTW
402d			 
402d			.LEFT: 
402d				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
402d 48				db WORD_SYS_CORE+52             
402e 55 40			dw .RIGHT            
4030 05				db 4 + 1 
4031 .. 00			db "LEFT",0              
4036				endm 
# End of macro CWHEAD
4036			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4036					if DEBUG_FORTH_WORDS_KEY 
4036						DMARK "LEF" 
4036 f5				push af  
4037 3a 4b 40			ld a, (.dmark)  
403a 32 7a ee			ld (debug_mark),a  
403d 3a 4c 40			ld a, (.dmark+1)  
4040 32 7b ee			ld (debug_mark+1),a  
4043 3a 4d 40			ld a, (.dmark+2)  
4046 32 7c ee			ld (debug_mark+2),a  
4049 18 03			jr .pastdmark  
404b ..			.dmark: db "LEF"  
404e f1			.pastdmark: pop af  
404f			endm  
# End of macro DMARK
404f						CALLMONITOR 
404f cd 0e 14			call break_point_state  
4052				endm  
# End of macro CALLMONITOR
4052					endif 
4052			 
4052					NEXTW 
4052 c3 04 1d			jp macro_next 
4055				endm 
# End of macro NEXTW
4055			.RIGHT: 
4055				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4055 48				db WORD_SYS_CORE+52             
4056 7e 40			dw .STR2NUM            
4058 06				db 5 + 1 
4059 .. 00			db "RIGHT",0              
405f				endm 
# End of macro CWHEAD
405f			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
405f					if DEBUG_FORTH_WORDS_KEY 
405f						DMARK "RIG" 
405f f5				push af  
4060 3a 74 40			ld a, (.dmark)  
4063 32 7a ee			ld (debug_mark),a  
4066 3a 75 40			ld a, (.dmark+1)  
4069 32 7b ee			ld (debug_mark+1),a  
406c 3a 76 40			ld a, (.dmark+2)  
406f 32 7c ee			ld (debug_mark+2),a  
4072 18 03			jr .pastdmark  
4074 ..			.dmark: db "RIG"  
4077 f1			.pastdmark: pop af  
4078			endm  
# End of macro DMARK
4078						CALLMONITOR 
4078 cd 0e 14			call break_point_state  
407b				endm  
# End of macro CALLMONITOR
407b					endif 
407b			 
407b					NEXTW 
407b c3 04 1d			jp macro_next 
407e				endm 
# End of macro NEXTW
407e			 
407e			 
407e			.STR2NUM: 
407e				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
407e 48				db WORD_SYS_CORE+52             
407f 0a 41			dw .NUM2STR            
4081 08				db 7 + 1 
4082 .. 00			db "STR2NUM",0              
408a				endm 
# End of macro CWHEAD
408a			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
408a			 
408a			 
408a			; TODO STR type check to do 
408a					if DEBUG_FORTH_WORDS_KEY 
408a						DMARK "S2N" 
408a f5				push af  
408b 3a 9f 40			ld a, (.dmark)  
408e 32 7a ee			ld (debug_mark),a  
4091 3a a0 40			ld a, (.dmark+1)  
4094 32 7b ee			ld (debug_mark+1),a  
4097 3a a1 40			ld a, (.dmark+2)  
409a 32 7c ee			ld (debug_mark+2),a  
409d 18 03			jr .pastdmark  
409f ..			.dmark: db "S2N"  
40a2 f1			.pastdmark: pop af  
40a3			endm  
# End of macro DMARK
40a3						CALLMONITOR 
40a3 cd 0e 14			call break_point_state  
40a6				endm  
# End of macro CALLMONITOR
40a6					endif 
40a6			 
40a6					;FORTH_DSP 
40a6					FORTH_DSP_VALUE 
40a6 cd 7b 1b			call macro_forth_dsp_value 
40a9				endm 
# End of macro FORTH_DSP_VALUE
40a9					;inc hl 
40a9			 
40a9 eb					ex de, hl 
40aa					if DEBUG_FORTH_WORDS 
40aa						DMARK "S2a" 
40aa f5				push af  
40ab 3a bf 40			ld a, (.dmark)  
40ae 32 7a ee			ld (debug_mark),a  
40b1 3a c0 40			ld a, (.dmark+1)  
40b4 32 7b ee			ld (debug_mark+1),a  
40b7 3a c1 40			ld a, (.dmark+2)  
40ba 32 7c ee			ld (debug_mark+2),a  
40bd 18 03			jr .pastdmark  
40bf ..			.dmark: db "S2a"  
40c2 f1			.pastdmark: pop af  
40c3			endm  
# End of macro DMARK
40c3						CALLMONITOR 
40c3 cd 0e 14			call break_point_state  
40c6				endm  
# End of macro CALLMONITOR
40c6					endif 
40c6 cd a7 0f				call string_to_uint16 
40c9			 
40c9					if DEBUG_FORTH_WORDS 
40c9						DMARK "S2b" 
40c9 f5				push af  
40ca 3a de 40			ld a, (.dmark)  
40cd 32 7a ee			ld (debug_mark),a  
40d0 3a df 40			ld a, (.dmark+1)  
40d3 32 7b ee			ld (debug_mark+1),a  
40d6 3a e0 40			ld a, (.dmark+2)  
40d9 32 7c ee			ld (debug_mark+2),a  
40dc 18 03			jr .pastdmark  
40de ..			.dmark: db "S2b"  
40e1 f1			.pastdmark: pop af  
40e2			endm  
# End of macro DMARK
40e2						CALLMONITOR 
40e2 cd 0e 14			call break_point_state  
40e5				endm  
# End of macro CALLMONITOR
40e5					endif 
40e5			;		push hl 
40e5					FORTH_DSP_POP 
40e5 cd 4a 1c			call macro_forth_dsp_pop 
40e8				endm 
# End of macro FORTH_DSP_POP
40e8			;		pop hl 
40e8					 
40e8					if DEBUG_FORTH_WORDS 
40e8						DMARK "S2b" 
40e8 f5				push af  
40e9 3a fd 40			ld a, (.dmark)  
40ec 32 7a ee			ld (debug_mark),a  
40ef 3a fe 40			ld a, (.dmark+1)  
40f2 32 7b ee			ld (debug_mark+1),a  
40f5 3a ff 40			ld a, (.dmark+2)  
40f8 32 7c ee			ld (debug_mark+2),a  
40fb 18 03			jr .pastdmark  
40fd ..			.dmark: db "S2b"  
4100 f1			.pastdmark: pop af  
4101			endm  
# End of macro DMARK
4101						CALLMONITOR 
4101 cd 0e 14			call break_point_state  
4104				endm  
# End of macro CALLMONITOR
4104					endif 
4104 cd 9b 19				call forth_push_numhl	 
4107			 
4107				 
4107				       NEXTW 
4107 c3 04 1d			jp macro_next 
410a				endm 
# End of macro NEXTW
410a			.NUM2STR: 
410a				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
410a 48				db WORD_SYS_CORE+52             
410b 19 41			dw .CONCAT            
410d 08				db 7 + 1 
410e .. 00			db "NUM2STR",0              
4116				endm 
# End of macro CWHEAD
4116			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4116			 
4116			;		; malloc a string to target 
4116			;		ld hl, 10     ; TODO max string size should be fine 
4116			;		call malloc 
4116			;		push hl    ; save malloc location 
4116			; 
4116			; 
4116			;; TODO check int type 
4116			;		FORTH_DSP_VALUEHL 
4116			;		ld a, l 
4116			;		call DispAToASCII   
4116			;;TODO need to chage above call to dump into string 
4116			; 
4116			; 
4116			 
4116				       NEXTW 
4116 c3 04 1d			jp macro_next 
4119				endm 
# End of macro NEXTW
4119			 
4119			.CONCAT: 
4119				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4119 48				db WORD_SYS_CORE+52             
411a cc 41			dw .FIND            
411c 07				db 6 + 1 
411d .. 00			db "CONCAT",0              
4124				endm 
# End of macro CWHEAD
4124			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4124			 
4124			; TODO check string type 
4124			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4124			 
4124					if DEBUG_FORTH_WORDS_KEY 
4124						DMARK "CON" 
4124 f5				push af  
4125 3a 39 41			ld a, (.dmark)  
4128 32 7a ee			ld (debug_mark),a  
412b 3a 3a 41			ld a, (.dmark+1)  
412e 32 7b ee			ld (debug_mark+1),a  
4131 3a 3b 41			ld a, (.dmark+2)  
4134 32 7c ee			ld (debug_mark+2),a  
4137 18 03			jr .pastdmark  
4139 ..			.dmark: db "CON"  
413c f1			.pastdmark: pop af  
413d			endm  
# End of macro DMARK
413d						CALLMONITOR 
413d cd 0e 14			call break_point_state  
4140				endm  
# End of macro CALLMONITOR
4140					endif 
4140			 
4140			 
4140					FORTH_DSP_VALUE 
4140 cd 7b 1b			call macro_forth_dsp_value 
4143				endm 
# End of macro FORTH_DSP_VALUE
4143 e5					push hl   ; s2 
4144			 
4144					FORTH_DSP_POP 
4144 cd 4a 1c			call macro_forth_dsp_pop 
4147				endm 
# End of macro FORTH_DSP_POP
4147			 
4147					FORTH_DSP_VALUE 
4147 cd 7b 1b			call macro_forth_dsp_value 
414a				endm 
# End of macro FORTH_DSP_VALUE
414a			 
414a e5					push hl   ; s1 
414b			 
414b					FORTH_DSP_POP 
414b cd 4a 1c			call macro_forth_dsp_pop 
414e				endm 
# End of macro FORTH_DSP_POP
414e					 
414e			 
414e					; copy s1 
414e			 
414e				 
414e					; save ptr 
414e e1					pop hl  
414f e5					push hl 
4150 3e 00				ld a, 0 
4152 cd 1b 10				call strlent 
4155					;inc hl    ; zer0 
4155 06 00				ld b, 0 
4157 4d					ld c, l 
4158 e1					pop hl		 
4159 11 60 e3				ld de, scratch	 
415c					if DEBUG_FORTH_WORDS 
415c						DMARK "CO1" 
415c f5				push af  
415d 3a 71 41			ld a, (.dmark)  
4160 32 7a ee			ld (debug_mark),a  
4163 3a 72 41			ld a, (.dmark+1)  
4166 32 7b ee			ld (debug_mark+1),a  
4169 3a 73 41			ld a, (.dmark+2)  
416c 32 7c ee			ld (debug_mark+2),a  
416f 18 03			jr .pastdmark  
4171 ..			.dmark: db "CO1"  
4174 f1			.pastdmark: pop af  
4175			endm  
# End of macro DMARK
4175						CALLMONITOR 
4175 cd 0e 14			call break_point_state  
4178				endm  
# End of macro CALLMONITOR
4178					endif 
4178 ed b0				ldir 
417a			 
417a e1					pop hl 
417b e5					push hl 
417c d5					push de 
417d			 
417d			 
417d 3e 00				ld a, 0 
417f cd 1b 10				call strlent 
4182 23					inc hl    ; zer0 
4183 23					inc hl 
4184 06 00				ld b, 0 
4186 4d					ld c, l 
4187 d1					pop de 
4188 e1					pop hl		 
4189					if DEBUG_FORTH_WORDS 
4189						DMARK "CO2" 
4189 f5				push af  
418a 3a 9e 41			ld a, (.dmark)  
418d 32 7a ee			ld (debug_mark),a  
4190 3a 9f 41			ld a, (.dmark+1)  
4193 32 7b ee			ld (debug_mark+1),a  
4196 3a a0 41			ld a, (.dmark+2)  
4199 32 7c ee			ld (debug_mark+2),a  
419c 18 03			jr .pastdmark  
419e ..			.dmark: db "CO2"  
41a1 f1			.pastdmark: pop af  
41a2			endm  
# End of macro DMARK
41a2						CALLMONITOR 
41a2 cd 0e 14			call break_point_state  
41a5				endm  
# End of macro CALLMONITOR
41a5					endif 
41a5 ed b0				ldir 
41a7			 
41a7			 
41a7			 
41a7 21 60 e3				ld hl, scratch 
41aa					if DEBUG_FORTH_WORDS 
41aa						DMARK "CO5" 
41aa f5				push af  
41ab 3a bf 41			ld a, (.dmark)  
41ae 32 7a ee			ld (debug_mark),a  
41b1 3a c0 41			ld a, (.dmark+1)  
41b4 32 7b ee			ld (debug_mark+1),a  
41b7 3a c1 41			ld a, (.dmark+2)  
41ba 32 7c ee			ld (debug_mark+2),a  
41bd 18 03			jr .pastdmark  
41bf ..			.dmark: db "CO5"  
41c2 f1			.pastdmark: pop af  
41c3			endm  
# End of macro DMARK
41c3						CALLMONITOR 
41c3 cd 0e 14			call break_point_state  
41c6				endm  
# End of macro CALLMONITOR
41c6					endif 
41c6			 
41c6 cd 09 1a				call forth_push_str 
41c9			 
41c9			 
41c9			 
41c9			 
41c9				       NEXTW 
41c9 c3 04 1d			jp macro_next 
41cc				endm 
# End of macro NEXTW
41cc			 
41cc			 
41cc			.FIND: 
41cc				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
41cc 4b				db WORD_SYS_CORE+55             
41cd 8a 42			dw .LEN            
41cf 05				db 4 + 1 
41d0 .. 00			db "FIND",0              
41d5				endm 
# End of macro CWHEAD
41d5			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
41d5			 
41d5					if DEBUG_FORTH_WORDS_KEY 
41d5						DMARK "FND" 
41d5 f5				push af  
41d6 3a ea 41			ld a, (.dmark)  
41d9 32 7a ee			ld (debug_mark),a  
41dc 3a eb 41			ld a, (.dmark+1)  
41df 32 7b ee			ld (debug_mark+1),a  
41e2 3a ec 41			ld a, (.dmark+2)  
41e5 32 7c ee			ld (debug_mark+2),a  
41e8 18 03			jr .pastdmark  
41ea ..			.dmark: db "FND"  
41ed f1			.pastdmark: pop af  
41ee			endm  
# End of macro DMARK
41ee						CALLMONITOR 
41ee cd 0e 14			call break_point_state  
41f1				endm  
# End of macro CALLMONITOR
41f1					endif 
41f1			 
41f1			; TODO check string type 
41f1					FORTH_DSP_VALUE 
41f1 cd 7b 1b			call macro_forth_dsp_value 
41f4				endm 
# End of macro FORTH_DSP_VALUE
41f4			 
41f4 e5					push hl    
41f5 7e					ld a,(hl)    ; char to find   
41f6			; TODO change char to substr 
41f6			 
41f6 f5					push af 
41f7					 
41f7			 
41f7			 
41f7					if DEBUG_FORTH_WORDS 
41f7						DMARK "FN1" 
41f7 f5				push af  
41f8 3a 0c 42			ld a, (.dmark)  
41fb 32 7a ee			ld (debug_mark),a  
41fe 3a 0d 42			ld a, (.dmark+1)  
4201 32 7b ee			ld (debug_mark+1),a  
4204 3a 0e 42			ld a, (.dmark+2)  
4207 32 7c ee			ld (debug_mark+2),a  
420a 18 03			jr .pastdmark  
420c ..			.dmark: db "FN1"  
420f f1			.pastdmark: pop af  
4210			endm  
# End of macro DMARK
4210						CALLMONITOR 
4210 cd 0e 14			call break_point_state  
4213				endm  
# End of macro CALLMONITOR
4213					endif 
4213			 
4213					FORTH_DSP_POP 
4213 cd 4a 1c			call macro_forth_dsp_pop 
4216				endm 
# End of macro FORTH_DSP_POP
4216			 
4216					; string to search 
4216			 
4216					FORTH_DSP_VALUE 
4216 cd 7b 1b			call macro_forth_dsp_value 
4219				endm 
# End of macro FORTH_DSP_VALUE
4219			 
4219 d1					pop de  ; d is char to find  
421a			 
421a					if DEBUG_FORTH_WORDS 
421a						DMARK "FN2" 
421a f5				push af  
421b 3a 2f 42			ld a, (.dmark)  
421e 32 7a ee			ld (debug_mark),a  
4221 3a 30 42			ld a, (.dmark+1)  
4224 32 7b ee			ld (debug_mark+1),a  
4227 3a 31 42			ld a, (.dmark+2)  
422a 32 7c ee			ld (debug_mark+2),a  
422d 18 03			jr .pastdmark  
422f ..			.dmark: db "FN2"  
4232 f1			.pastdmark: pop af  
4233			endm  
# End of macro DMARK
4233						CALLMONITOR 
4233 cd 0e 14			call break_point_state  
4236				endm  
# End of macro CALLMONITOR
4236					endif 
4236					 
4236 01 00 00				ld bc, 0 
4239 7e			.findchar:      ld a,(hl) 
423a fe 00				cp 0   		 
423c 28 27				jr z, .finddone     
423e ba					cp d 
423f 28 20				jr z, .foundchar 
4241 03					inc bc 
4242 23					inc hl 
4243					if DEBUG_FORTH_WORDS 
4243						DMARK "FN3" 
4243 f5				push af  
4244 3a 58 42			ld a, (.dmark)  
4247 32 7a ee			ld (debug_mark),a  
424a 3a 59 42			ld a, (.dmark+1)  
424d 32 7b ee			ld (debug_mark+1),a  
4250 3a 5a 42			ld a, (.dmark+2)  
4253 32 7c ee			ld (debug_mark+2),a  
4256 18 03			jr .pastdmark  
4258 ..			.dmark: db "FN3"  
425b f1			.pastdmark: pop af  
425c			endm  
# End of macro DMARK
425c						CALLMONITOR 
425c cd 0e 14			call break_point_state  
425f				endm  
# End of macro CALLMONITOR
425f					endif 
425f 18 d8				jr .findchar 
4261			 
4261			 
4261 c5			.foundchar:	push bc 
4262 e1					pop hl 
4263 18 03				jr .findexit 
4265			 
4265			 
4265							 
4265			 
4265			.finddone:     ; got to end of string with no find 
4265 21 00 00				ld hl, 0 
4268			.findexit: 
4268			 
4268					if DEBUG_FORTH_WORDS 
4268						DMARK "FNd" 
4268 f5				push af  
4269 3a 7d 42			ld a, (.dmark)  
426c 32 7a ee			ld (debug_mark),a  
426f 3a 7e 42			ld a, (.dmark+1)  
4272 32 7b ee			ld (debug_mark+1),a  
4275 3a 7f 42			ld a, (.dmark+2)  
4278 32 7c ee			ld (debug_mark+2),a  
427b 18 03			jr .pastdmark  
427d ..			.dmark: db "FNd"  
4280 f1			.pastdmark: pop af  
4281			endm  
# End of macro DMARK
4281						CALLMONITOR 
4281 cd 0e 14			call break_point_state  
4284				endm  
# End of macro CALLMONITOR
4284					endif 
4284 cd 9b 19			call forth_push_numhl 
4287			 
4287				       NEXTW 
4287 c3 04 1d			jp macro_next 
428a				endm 
# End of macro NEXTW
428a			 
428a			.LEN: 
428a				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
428a 4c				db WORD_SYS_CORE+56             
428b bf 42			dw .CHAR            
428d 06				db 5 + 1 
428e .. 00			db "COUNT",0              
4294				endm 
# End of macro CWHEAD
4294			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4294			 
4294					if DEBUG_FORTH_WORDS_KEY 
4294						DMARK "CNT" 
4294 f5				push af  
4295 3a a9 42			ld a, (.dmark)  
4298 32 7a ee			ld (debug_mark),a  
429b 3a aa 42			ld a, (.dmark+1)  
429e 32 7b ee			ld (debug_mark+1),a  
42a1 3a ab 42			ld a, (.dmark+2)  
42a4 32 7c ee			ld (debug_mark+2),a  
42a7 18 03			jr .pastdmark  
42a9 ..			.dmark: db "CNT"  
42ac f1			.pastdmark: pop af  
42ad			endm  
# End of macro DMARK
42ad						CALLMONITOR 
42ad cd 0e 14			call break_point_state  
42b0				endm  
# End of macro CALLMONITOR
42b0					endif 
42b0			; TODO check string type 
42b0					FORTH_DSP 
42b0 cd 58 1b			call macro_forth_dsp 
42b3				endm 
# End of macro FORTH_DSP
42b3					;v5FORTH_DSP_VALUE 
42b3			 
42b3 23					inc hl 
42b4			 
42b4 3e 00				ld a, 0 
42b6 cd 1b 10				call strlent 
42b9			 
42b9 cd 9b 19				call forth_push_numhl 
42bc			 
42bc			 
42bc			 
42bc				       NEXTW 
42bc c3 04 1d			jp macro_next 
42bf				endm 
# End of macro NEXTW
42bf			.CHAR: 
42bf				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
42bf 4d				db WORD_SYS_CORE+57             
42c0 f5 42			dw .ENDSTR            
42c2 05				db 4 + 1 
42c3 .. 00			db "CHAR",0              
42c8				endm 
# End of macro CWHEAD
42c8			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
42c8					if DEBUG_FORTH_WORDS_KEY 
42c8						DMARK "CHR" 
42c8 f5				push af  
42c9 3a dd 42			ld a, (.dmark)  
42cc 32 7a ee			ld (debug_mark),a  
42cf 3a de 42			ld a, (.dmark+1)  
42d2 32 7b ee			ld (debug_mark+1),a  
42d5 3a df 42			ld a, (.dmark+2)  
42d8 32 7c ee			ld (debug_mark+2),a  
42db 18 03			jr .pastdmark  
42dd ..			.dmark: db "CHR"  
42e0 f1			.pastdmark: pop af  
42e1			endm  
# End of macro DMARK
42e1						CALLMONITOR 
42e1 cd 0e 14			call break_point_state  
42e4				endm  
# End of macro CALLMONITOR
42e4					endif 
42e4					FORTH_DSP 
42e4 cd 58 1b			call macro_forth_dsp 
42e7				endm 
# End of macro FORTH_DSP
42e7					;v5 FORTH_DSP_VALUE 
42e7 23					inc hl      ; now at start of numeric as string 
42e8			 
42e8			;		push hl 
42e8			 
42e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42e8 cd 4a 1c			call macro_forth_dsp_pop 
42eb				endm 
# End of macro FORTH_DSP_POP
42eb			 
42eb			;		pop hl 
42eb			 
42eb					; push the content of a onto the stack as a value 
42eb			 
42eb 7e					ld a,(hl)   ; get char 
42ec 26 00				ld h,0 
42ee 6f					ld l,a 
42ef cd 9b 19				call forth_push_numhl 
42f2			 
42f2				       NEXTW 
42f2 c3 04 1d			jp macro_next 
42f5				endm 
# End of macro NEXTW
42f5			 
42f5			 
42f5			 
42f5			 
42f5			.ENDSTR: 
42f5			; eof 
42f5			 
# End of file forth_words_str.asm
42f5			include "forth_words_key.asm" 
42f5			 
42f5			; | ## Keyboard Words 
42f5			 
42f5			.KEY: 
42f5				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
42f5 3e				db WORD_SYS_CORE+42             
42f6 25 43			dw .WAITK            
42f8 04				db 3 + 1 
42f9 .. 00			db "KEY",0              
42fd				endm 
# End of macro CWHEAD
42fd			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
42fd			 
42fd					if DEBUG_FORTH_WORDS_KEY 
42fd						DMARK "KEY" 
42fd f5				push af  
42fe 3a 12 43			ld a, (.dmark)  
4301 32 7a ee			ld (debug_mark),a  
4304 3a 13 43			ld a, (.dmark+1)  
4307 32 7b ee			ld (debug_mark+1),a  
430a 3a 14 43			ld a, (.dmark+2)  
430d 32 7c ee			ld (debug_mark+2),a  
4310 18 03			jr .pastdmark  
4312 ..			.dmark: db "KEY"  
4315 f1			.pastdmark: pop af  
4316			endm  
# End of macro DMARK
4316						CALLMONITOR 
4316 cd 0e 14			call break_point_state  
4319				endm  
# End of macro CALLMONITOR
4319					endif 
4319			; TODO currently waits 
4319 cd cd 59				call cin 
431c					;call cin_wait 
431c 6f					ld l, a 
431d 26 00				ld h, 0 
431f cd 9b 19				call forth_push_numhl 
4322					NEXTW 
4322 c3 04 1d			jp macro_next 
4325				endm 
# End of macro NEXTW
4325			.WAITK: 
4325				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4325 3f				db WORD_SYS_CORE+43             
4326 57 43			dw .ACCEPT            
4328 06				db 5 + 1 
4329 .. 00			db "WAITK",0              
432f				endm 
# End of macro CWHEAD
432f			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
432f					if DEBUG_FORTH_WORDS_KEY 
432f						DMARK "WAI" 
432f f5				push af  
4330 3a 44 43			ld a, (.dmark)  
4333 32 7a ee			ld (debug_mark),a  
4336 3a 45 43			ld a, (.dmark+1)  
4339 32 7b ee			ld (debug_mark+1),a  
433c 3a 46 43			ld a, (.dmark+2)  
433f 32 7c ee			ld (debug_mark+2),a  
4342 18 03			jr .pastdmark  
4344 ..			.dmark: db "WAI"  
4347 f1			.pastdmark: pop af  
4348			endm  
# End of macro DMARK
4348						CALLMONITOR 
4348 cd 0e 14			call break_point_state  
434b				endm  
# End of macro CALLMONITOR
434b					endif 
434b cd c5 59				call cin_wait 
434e 6f					ld l, a 
434f 26 00				ld h, 0 
4351 cd 9b 19				call forth_push_numhl 
4354					NEXTW 
4354 c3 04 1d			jp macro_next 
4357				endm 
# End of macro NEXTW
4357			.ACCEPT: 
4357				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4357 40				db WORD_SYS_CORE+44             
4358 b5 43			dw .EDIT            
435a 07				db 6 + 1 
435b .. 00			db "ACCEPT",0              
4362				endm 
# End of macro CWHEAD
4362			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4362					; TODO crashes on push 
4362					if DEBUG_FORTH_WORDS_KEY 
4362						DMARK "ACC" 
4362 f5				push af  
4363 3a 77 43			ld a, (.dmark)  
4366 32 7a ee			ld (debug_mark),a  
4369 3a 78 43			ld a, (.dmark+1)  
436c 32 7b ee			ld (debug_mark+1),a  
436f 3a 79 43			ld a, (.dmark+2)  
4372 32 7c ee			ld (debug_mark+2),a  
4375 18 03			jr .pastdmark  
4377 ..			.dmark: db "ACC"  
437a f1			.pastdmark: pop af  
437b			endm  
# End of macro DMARK
437b						CALLMONITOR 
437b cd 0e 14			call break_point_state  
437e				endm  
# End of macro CALLMONITOR
437e					endif 
437e 21 5e e5				ld hl, os_input 
4381 3e 00				ld a, 0 
4383 77					ld (hl),a 
4384 3a 49 eb				ld a,(f_cursor_ptr) 
4387 16 64				ld d, 100 
4389 0e 00				ld c, 0 
438b 1e 28				ld e, 40 
438d cd df 0b				call input_str 
4390					; TODO perhaps do a type check and wrap in quotes if not a number 
4390 21 5e e5				ld hl, os_input 
4393					if DEBUG_FORTH_WORDS 
4393						DMARK "AC1" 
4393 f5				push af  
4394 3a a8 43			ld a, (.dmark)  
4397 32 7a ee			ld (debug_mark),a  
439a 3a a9 43			ld a, (.dmark+1)  
439d 32 7b ee			ld (debug_mark+1),a  
43a0 3a aa 43			ld a, (.dmark+2)  
43a3 32 7c ee			ld (debug_mark+2),a  
43a6 18 03			jr .pastdmark  
43a8 ..			.dmark: db "AC1"  
43ab f1			.pastdmark: pop af  
43ac			endm  
# End of macro DMARK
43ac						CALLMONITOR 
43ac cd 0e 14			call break_point_state  
43af				endm  
# End of macro CALLMONITOR
43af					endif 
43af cd 09 1a				call forth_push_str 
43b2					NEXTW 
43b2 c3 04 1d			jp macro_next 
43b5				endm 
# End of macro NEXTW
43b5			 
43b5			.EDIT: 
43b5				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
43b5 40				db WORD_SYS_CORE+44             
43b6 3e 44			dw .ENDKEY            
43b8 05				db 4 + 1 
43b9 .. 00			db "EDIT",0              
43be				endm 
# End of macro CWHEAD
43be			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
43be			 
43be					; TODO does not copy from stack 
43be					if DEBUG_FORTH_WORDS_KEY 
43be						DMARK "EDT" 
43be f5				push af  
43bf 3a d3 43			ld a, (.dmark)  
43c2 32 7a ee			ld (debug_mark),a  
43c5 3a d4 43			ld a, (.dmark+1)  
43c8 32 7b ee			ld (debug_mark+1),a  
43cb 3a d5 43			ld a, (.dmark+2)  
43ce 32 7c ee			ld (debug_mark+2),a  
43d1 18 03			jr .pastdmark  
43d3 ..			.dmark: db "EDT"  
43d6 f1			.pastdmark: pop af  
43d7			endm  
# End of macro DMARK
43d7						CALLMONITOR 
43d7 cd 0e 14			call break_point_state  
43da				endm  
# End of macro CALLMONITOR
43da					endif 
43da			 
43da					FORTH_DSP 
43da cd 58 1b			call macro_forth_dsp 
43dd				endm 
# End of macro FORTH_DSP
43dd					;v5 FORTH_DSP_VALUE 
43dd 23					inc hl    ; TODO do type check 
43de			 
43de e5					push hl 
43df 3e 00				ld a, 0 
43e1 cd 1b 10				call strlent 
43e4 23					inc hl 
43e5			 
43e5 06 00				ld b, 0 
43e7 4d					ld c, l 
43e8			 
43e8 e1					pop hl 
43e9 11 5e e5				ld de, os_input 
43ec					if DEBUG_FORTH_WORDS_KEY 
43ec						DMARK "EDc" 
43ec f5				push af  
43ed 3a 01 44			ld a, (.dmark)  
43f0 32 7a ee			ld (debug_mark),a  
43f3 3a 02 44			ld a, (.dmark+1)  
43f6 32 7b ee			ld (debug_mark+1),a  
43f9 3a 03 44			ld a, (.dmark+2)  
43fc 32 7c ee			ld (debug_mark+2),a  
43ff 18 03			jr .pastdmark  
4401 ..			.dmark: db "EDc"  
4404 f1			.pastdmark: pop af  
4405			endm  
# End of macro DMARK
4405						CALLMONITOR 
4405 cd 0e 14			call break_point_state  
4408				endm  
# End of macro CALLMONITOR
4408					endif 
4408 ed b0				ldir 
440a			 
440a			 
440a 21 5e e5				ld hl, os_input 
440d					;ld a, 0 
440d					;ld (hl),a 
440d 3a 49 eb				ld a,(f_cursor_ptr) 
4410 16 64				ld d, 100 
4412 0e 00				ld c, 0 
4414 1e 28				ld e, 40 
4416 cd df 0b				call input_str 
4419					; TODO perhaps do a type check and wrap in quotes if not a number 
4419 21 5e e5				ld hl, os_input 
441c					if DEBUG_FORTH_WORDS 
441c						DMARK "ED1" 
441c f5				push af  
441d 3a 31 44			ld a, (.dmark)  
4420 32 7a ee			ld (debug_mark),a  
4423 3a 32 44			ld a, (.dmark+1)  
4426 32 7b ee			ld (debug_mark+1),a  
4429 3a 33 44			ld a, (.dmark+2)  
442c 32 7c ee			ld (debug_mark+2),a  
442f 18 03			jr .pastdmark  
4431 ..			.dmark: db "ED1"  
4434 f1			.pastdmark: pop af  
4435			endm  
# End of macro DMARK
4435						CALLMONITOR 
4435 cd 0e 14			call break_point_state  
4438				endm  
# End of macro CALLMONITOR
4438					endif 
4438 cd 09 1a				call forth_push_str 
443b					NEXTW 
443b c3 04 1d			jp macro_next 
443e				endm 
# End of macro NEXTW
443e			 
443e			 
443e			 
443e			.ENDKEY: 
443e			; eof 
443e			 
# End of file forth_words_key.asm
443e			 
443e			if STORAGE_SE 
443e			   	include "forth_words_storage.asm" 
443e			endif 
443e				include "forth_words_device.asm" 
443e			; Device related words 
443e			 
443e			; | ## Device Words 
443e			 
443e			if SOUND_ENABLE 
443e			.NOTE: 
443e				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
443e			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
443e					if DEBUG_FORTH_WORDS_KEY 
443e						DMARK "NTE" 
443e						CALLMONITOR 
443e					endif 
443e			 
443e				 
443e			 
443e					NEXTW 
443e			.AFTERSOUND: 
443e			endif 
443e			 
443e			 
443e			USE_GPIO: equ 0 
443e			 
443e			if USE_GPIO 
443e			.GP1: 
443e				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
443e			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
443e					NEXTW 
443e			.GP2: 
443e				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
443e			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
443e			 
443e					NEXTW 
443e			 
443e			.GP3: 
443e				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
443e			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
443e			 
443e					NEXTW 
443e			 
443e			.GP4: 
443e				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
443e			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
443e			 
443e					NEXTW 
443e			.SIN: 
443e			 
443e			 
443e			endif 
443e			 
443e			 
443e				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
443e 33				db WORD_SYS_CORE+31             
443f 73 44			dw .SOUT            
4441 03				db 2 + 1 
4442 .. 00			db "IN",0              
4445				endm 
# End of macro CWHEAD
4445			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4445					if DEBUG_FORTH_WORDS_KEY 
4445						DMARK "IN." 
4445 f5				push af  
4446 3a 5a 44			ld a, (.dmark)  
4449 32 7a ee			ld (debug_mark),a  
444c 3a 5b 44			ld a, (.dmark+1)  
444f 32 7b ee			ld (debug_mark+1),a  
4452 3a 5c 44			ld a, (.dmark+2)  
4455 32 7c ee			ld (debug_mark+2),a  
4458 18 03			jr .pastdmark  
445a ..			.dmark: db "IN."  
445d f1			.pastdmark: pop af  
445e			endm  
# End of macro DMARK
445e						CALLMONITOR 
445e cd 0e 14			call break_point_state  
4461				endm  
# End of macro CALLMONITOR
4461					endif 
4461					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4461 cd 92 1b			call macro_dsp_valuehl 
4464				endm 
# End of macro FORTH_DSP_VALUEHL
4464			 
4464 e5					push hl 
4465			 
4465					; destroy value TOS 
4465			 
4465					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4465 cd 4a 1c			call macro_forth_dsp_pop 
4468				endm 
# End of macro FORTH_DSP_POP
4468			 
4468					; one value on hl get other one back 
4468			 
4468 c1					pop bc 
4469			 
4469					; do the sub 
4469			;		ex de, hl 
4469			 
4469 ed 68				in l,(c) 
446b			 
446b					; save it 
446b			 
446b 26 00				ld h,0 
446d			 
446d					; TODO push value back onto stack for another op etc 
446d			 
446d cd 9b 19				call forth_push_numhl 
4470					NEXTW 
4470 c3 04 1d			jp macro_next 
4473				endm 
# End of macro NEXTW
4473			.SOUT: 
4473				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4473 34				db WORD_SYS_CORE+32             
4474 c6 44			dw .SPIO            
4476 04				db 3 + 1 
4477 .. 00			db "OUT",0              
447b				endm 
# End of macro CWHEAD
447b			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
447b					if DEBUG_FORTH_WORDS_KEY 
447b						DMARK "OUT" 
447b f5				push af  
447c 3a 90 44			ld a, (.dmark)  
447f 32 7a ee			ld (debug_mark),a  
4482 3a 91 44			ld a, (.dmark+1)  
4485 32 7b ee			ld (debug_mark+1),a  
4488 3a 92 44			ld a, (.dmark+2)  
448b 32 7c ee			ld (debug_mark+2),a  
448e 18 03			jr .pastdmark  
4490 ..			.dmark: db "OUT"  
4493 f1			.pastdmark: pop af  
4494			endm  
# End of macro DMARK
4494						CALLMONITOR 
4494 cd 0e 14			call break_point_state  
4497				endm  
# End of macro CALLMONITOR
4497					endif 
4497			 
4497					; get port 
4497			 
4497					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4497 cd 92 1b			call macro_dsp_valuehl 
449a				endm 
# End of macro FORTH_DSP_VALUEHL
449a			 
449a e5					push hl 
449b			 
449b					; destroy value TOS 
449b			 
449b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
449b cd 4a 1c			call macro_forth_dsp_pop 
449e				endm 
# End of macro FORTH_DSP_POP
449e			 
449e					; get byte to send 
449e			 
449e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
449e cd 92 1b			call macro_dsp_valuehl 
44a1				endm 
# End of macro FORTH_DSP_VALUEHL
44a1			 
44a1			;		push hl 
44a1			 
44a1					; destroy value TOS 
44a1			 
44a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44a1 cd 4a 1c			call macro_forth_dsp_pop 
44a4				endm 
# End of macro FORTH_DSP_POP
44a4			 
44a4					; one value on hl get other one back 
44a4			 
44a4			;		pop hl 
44a4			 
44a4 c1					pop bc 
44a5			 
44a5					if DEBUG_FORTH_WORDS 
44a5						DMARK "OUT" 
44a5 f5				push af  
44a6 3a ba 44			ld a, (.dmark)  
44a9 32 7a ee			ld (debug_mark),a  
44ac 3a bb 44			ld a, (.dmark+1)  
44af 32 7b ee			ld (debug_mark+1),a  
44b2 3a bc 44			ld a, (.dmark+2)  
44b5 32 7c ee			ld (debug_mark+2),a  
44b8 18 03			jr .pastdmark  
44ba ..			.dmark: db "OUT"  
44bd f1			.pastdmark: pop af  
44be			endm  
# End of macro DMARK
44be						CALLMONITOR 
44be cd 0e 14			call break_point_state  
44c1				endm  
# End of macro CALLMONITOR
44c1					endif 
44c1			 
44c1 ed 69				out (c), l 
44c3			 
44c3					NEXTW 
44c3 c3 04 1d			jp macro_next 
44c6				endm 
# End of macro NEXTW
44c6			 
44c6			 
44c6			.SPIO: 
44c6			 
44c6			if STORAGE_SE 
44c6				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
44c6			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
44c6			 
44c6					call spi_ce_low 
44c6			    NEXTW 
44c6			 
44c6			.SPICEH: 
44c6				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
44c6			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
44c6			 
44c6					call spi_ce_high 
44c6			    NEXTW 
44c6			 
44c6			 
44c6			.SPIOb: 
44c6			 
44c6				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
44c6			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
44c6			 
44c6					; get port 
44c6			 
44c6			 
44c6					; get byte to send 
44c6			 
44c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44c6			 
44c6			;		push hl    ; u1  
44c6			 
44c6					; destroy value TOS 
44c6			 
44c6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44c6			 
44c6					; one value on hl get other one back 
44c6			 
44c6			;		pop hl   ; u2 - addr 
44c6			 
44c6					; TODO Send SPI byte 
44c6			 
44c6					ld a, l 
44c6					call spi_send_byte 
44c6			 
44c6					NEXTW 
44c6			 
44c6			.SPII: 
44c6				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
44c6			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
44c6			 
44c6					; TODO Get SPI byte 
44c6			 
44c6					call spi_read_byte 
44c6			 
44c6					ld h, 0 
44c6					ld l, a 
44c6					call forth_push_numhl 
44c6			 
44c6					NEXTW 
44c6			 
44c6			 
44c6			 
44c6			.SESEL: 
44c6				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
44c6			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
44c6					if DEBUG_FORTH_WORDS_KEY 
44c6						DMARK "BNK" 
44c6						CALLMONITOR 
44c6					endif 
44c6			 
44c6					ld a, 255 
44c6					ld (spi_cartdev), a 
44c6			 
44c6					; get bank 
44c6			 
44c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44c6			 
44c6			;		push hl 
44c6			 
44c6					; destroy value TOS 
44c6			 
44c6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44c6			 
44c6					; one value on hl get other one back 
44c6			 
44c6			;		pop hl 
44c6			 
44c6			 
44c6					ld c, SPI_CE_HIGH 
44c6					ld b, '0'    ; human readable bank number 
44c6			 
44c6					ld a, l 
44c6			 
44c6					if DEBUG_FORTH_WORDS 
44c6						DMARK "BNK" 
44c6						CALLMONITOR 
44c6					endif 
44c6			 
44c6					; active low 
44c6			 
44c6					cp 0 
44c6					jr z, .bset 
44c6					cp 1 
44c6					jr nz, .b2 
44c6					res 0, c 
44c6					ld b, '1'    ; human readable bank number 
44c6			.b2:		cp 2 
44c6					jr nz, .b3 
44c6					res 1, c 
44c6					ld b, '2'    ; human readable bank number 
44c6			.b3:		cp 3 
44c6					jr nz, .b4 
44c6					res 2, c 
44c6					ld b, '3'    ; human readable bank number 
44c6			.b4:		cp 4 
44c6					jr nz, .b5 
44c6					res 3, c 
44c6					ld b, '4'    ; human readable bank number 
44c6			.b5:		cp 5 
44c6					jr nz, .bset 
44c6					res 4, c 
44c6					ld b, '5'    ; human readable bank number 
44c6			 
44c6			.bset: 
44c6					ld a, c 
44c6					ld (spi_device),a 
44c6					ld a, b 
44c6					ld (spi_device_id),a 
44c6					if DEBUG_FORTH_WORDS 
44c6						DMARK "BN2" 
44c6						CALLMONITOR 
44c6					endif 
44c6			 
44c6					NEXTW 
44c6			 
44c6			.CARTDEV: 
44c6				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
44c6			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
44c6					if DEBUG_FORTH_WORDS_KEY 
44c6						DMARK "CDV" 
44c6						CALLMONITOR 
44c6					endif 
44c6			 
44c6					; disable se storage bank selection 
44c6			 
44c6					ld a, SPI_CE_HIGH		; ce high 
44c6					ld (spi_device), a 
44c6			 
44c6					; get bank 
44c6			 
44c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44c6			 
44c6			;		push hl 
44c6			 
44c6					; destroy value TOS 
44c6			 
44c6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44c6			 
44c6					; one value on hl get other one back 
44c6			 
44c6			;		pop hl 
44c6			 
44c6					; active low 
44c6			 
44c6					ld c, 255 
44c6			 
44c6					ld a, l 
44c6					if DEBUG_FORTH_WORDS 
44c6						DMARK "CDV" 
44c6						CALLMONITOR 
44c6					endif 
44c6					cp 0 
44c6					jr z, .cset 
44c6					cp 1 
44c6					jr nz, .c2 
44c6					res 0, c 
44c6			.c2:		cp 2 
44c6					jr nz, .c3 
44c6					res 1, c 
44c6			.c3:		cp 3 
44c6					jr nz, .c4 
44c6					res 2, c 
44c6			.c4:		cp 4 
44c6					jr nz, .c5 
44c6					res 3, c 
44c6			.c5:		cp 5 
44c6					jr nz, .c6 
44c6					res 4, c 
44c6			.c6:		cp 6 
44c6					jr nz, .c7 
44c6					res 5, c 
44c6			.c7:		cp 7 
44c6					jr nz, .c8 
44c6					res 6, c 
44c6			.c8:		cp 8 
44c6					jr nz, .cset 
44c6					res 7, c 
44c6			.cset:		ld a, c 
44c6					ld (spi_cartdev),a 
44c6			 
44c6					if DEBUG_FORTH_WORDS 
44c6						DMARK "CD2" 
44c6						CALLMONITOR 
44c6					endif 
44c6					NEXTW 
44c6			endif 
44c6			 
44c6			.ENDDEVICE: 
44c6			; eof 
44c6			 
# End of file forth_words_device.asm
44c6			 
44c6			; var handler 
44c6			 
44c6			 
44c6			.VARS: 
44c6				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
44c6 78				db WORD_SYS_CORE+100             
44c7 de 44			dw .V0Q            
44c9 04				db 3 + 1 
44ca .. 00			db "V0!",0              
44ce				endm 
# End of macro CWHEAD
44ce			;| V0! ( u1 -- )  Store value to v0  | DONE 
44ce			 
44ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44ce cd 92 1b			call macro_dsp_valuehl 
44d1				endm 
# End of macro FORTH_DSP_VALUEHL
44d1			 
44d1 11 13 eb				ld de, cli_var_array 
44d4			 
44d4 eb					ex de, hl 
44d5 73					ld (hl), e 
44d6 23					inc hl 
44d7 72					ld (hl), d 
44d8			 
44d8					; destroy value TOS 
44d8			 
44d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44d8 cd 4a 1c			call macro_forth_dsp_pop 
44db				endm 
# End of macro FORTH_DSP_POP
44db			 
44db				       NEXTW 
44db c3 04 1d			jp macro_next 
44de				endm 
# End of macro NEXTW
44de			.V0Q: 
44de				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
44de 79				db WORD_SYS_CORE+101             
44df ef 44			dw .V1S            
44e1 04				db 3 + 1 
44e2 .. 00			db "V0@",0              
44e6				endm 
# End of macro CWHEAD
44e6			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
44e6 2a 13 eb				ld hl, (cli_var_array) 
44e9 cd 9b 19				call forth_push_numhl 
44ec			 
44ec				       NEXTW 
44ec c3 04 1d			jp macro_next 
44ef				endm 
# End of macro NEXTW
44ef			.V1S: 
44ef				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
44ef 7a				db WORD_SYS_CORE+102             
44f0 07 45			dw .V1Q            
44f2 04				db 3 + 1 
44f3 .. 00			db "V1!",0              
44f7				endm 
# End of macro CWHEAD
44f7			;| V1! ( u1 -- )  Store value to v1 | DONE 
44f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44f7 cd 92 1b			call macro_dsp_valuehl 
44fa				endm 
# End of macro FORTH_DSP_VALUEHL
44fa			 
44fa 11 15 eb				ld de, cli_var_array+2 
44fd				 
44fd eb					ex de, hl 
44fe 73					ld (hl), e 
44ff 23					inc hl 
4500 72					ld (hl), d 
4501			 
4501					; destroy value TOS 
4501			 
4501					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4501 cd 4a 1c			call macro_forth_dsp_pop 
4504				endm 
# End of macro FORTH_DSP_POP
4504				       NEXTW 
4504 c3 04 1d			jp macro_next 
4507				endm 
# End of macro NEXTW
4507			.V1Q: 
4507				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4507 7b				db WORD_SYS_CORE+103             
4508 18 45			dw .V2S            
450a 04				db 3 + 1 
450b .. 00			db "V1@",0              
450f				endm 
# End of macro CWHEAD
450f			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
450f 2a 15 eb				ld hl, (cli_var_array+2) 
4512 cd 9b 19				call forth_push_numhl 
4515				       NEXTW 
4515 c3 04 1d			jp macro_next 
4518				endm 
# End of macro NEXTW
4518			.V2S: 
4518				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4518 7c				db WORD_SYS_CORE+104             
4519 30 45			dw .V2Q            
451b 04				db 3 + 1 
451c .. 00			db "V2!",0              
4520				endm 
# End of macro CWHEAD
4520			;| V2! ( u1 -- )  Store value to v2 | DONE 
4520					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4520 cd 92 1b			call macro_dsp_valuehl 
4523				endm 
# End of macro FORTH_DSP_VALUEHL
4523			 
4523 11 17 eb				ld de, cli_var_array+4 
4526				 
4526 eb					ex de, hl 
4527 73					ld (hl), e 
4528 23					inc hl 
4529 72					ld (hl), d 
452a			 
452a					; destroy value TOS 
452a			 
452a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
452a cd 4a 1c			call macro_forth_dsp_pop 
452d				endm 
# End of macro FORTH_DSP_POP
452d				       NEXTW 
452d c3 04 1d			jp macro_next 
4530				endm 
# End of macro NEXTW
4530			.V2Q: 
4530				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4530 7d				db WORD_SYS_CORE+105             
4531 41 45			dw .V3S            
4533 04				db 3 + 1 
4534 .. 00			db "V2@",0              
4538				endm 
# End of macro CWHEAD
4538			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4538 2a 17 eb				ld hl, (cli_var_array+4) 
453b cd 9b 19				call forth_push_numhl 
453e				       NEXTW 
453e c3 04 1d			jp macro_next 
4541				endm 
# End of macro NEXTW
4541			.V3S: 
4541				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4541 7c				db WORD_SYS_CORE+104             
4542 59 45			dw .V3Q            
4544 04				db 3 + 1 
4545 .. 00			db "V3!",0              
4549				endm 
# End of macro CWHEAD
4549			;| V3! ( u1 -- )  Store value to v3 | DONE 
4549					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4549 cd 92 1b			call macro_dsp_valuehl 
454c				endm 
# End of macro FORTH_DSP_VALUEHL
454c			 
454c 11 19 eb				ld de, cli_var_array+6 
454f				 
454f eb					ex de, hl 
4550 73					ld (hl), e 
4551 23					inc hl 
4552 72					ld (hl), d 
4553			 
4553					; destroy value TOS 
4553			 
4553					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4553 cd 4a 1c			call macro_forth_dsp_pop 
4556				endm 
# End of macro FORTH_DSP_POP
4556				       NEXTW 
4556 c3 04 1d			jp macro_next 
4559				endm 
# End of macro NEXTW
4559			.V3Q: 
4559				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4559 7d				db WORD_SYS_CORE+105             
455a 6a 45			dw .END            
455c 04				db 3 + 1 
455d .. 00			db "V3@",0              
4561				endm 
# End of macro CWHEAD
4561			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4561 2a 19 eb				ld hl, (cli_var_array+6) 
4564 cd 9b 19				call forth_push_numhl 
4567				       NEXTW 
4567 c3 04 1d			jp macro_next 
456a				endm 
# End of macro NEXTW
456a			 
456a			 
456a			 
456a			 
456a			 
456a			; end of dict marker 
456a			 
456a 00			.END:    db WORD_SYS_END 
456b 00 00			dw 0 
456d 00				db 0 
456e			 
456e			; use to jp here for user dict words to save on macro expansion  
456e			 
456e			user_dict_next: 
456e				NEXTW 
456e c3 04 1d			jp macro_next 
4571				endm 
# End of macro NEXTW
4571			 
4571			 
4571			user_exec: 
4571				;    ld hl, <word code> 
4571				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4571				;    call forthexec 
4571				;    jp user_dict_next   (NEXT) 
4571			        ;    <word code bytes> 
4571 eb				ex de, hl 
4572 2a 61 e6			ld hl,(os_tok_ptr) 
4575				 
4575				FORTH_RSP_NEXT 
4575 cd 42 19			call macro_forth_rsp_next 
4578				endm 
# End of macro FORTH_RSP_NEXT
4578			 
4578			if DEBUG_FORTH_UWORD 
4578						DMARK "UEX" 
4578 f5				push af  
4579 3a 8d 45			ld a, (.dmark)  
457c 32 7a ee			ld (debug_mark),a  
457f 3a 8e 45			ld a, (.dmark+1)  
4582 32 7b ee			ld (debug_mark+1),a  
4585 3a 8f 45			ld a, (.dmark+2)  
4588 32 7c ee			ld (debug_mark+2),a  
458b 18 03			jr .pastdmark  
458d ..			.dmark: db "UEX"  
4590 f1			.pastdmark: pop af  
4591			endm  
# End of macro DMARK
4591				CALLMONITOR 
4591 cd 0e 14			call break_point_state  
4594				endm  
# End of macro CALLMONITOR
4594			endif 
4594			 
4594			 
4594			 
4594 eb				ex de, hl 
4595 22 61 e6			ld (os_tok_ptr), hl 
4598				 
4598				; Don't use next - Skips the first word in uword. 
4598			 
4598 c3 95 1d			jp exec1 
459b			;	NEXT 
459b			 
459b			 
459b			; eof 
# End of file forth_wordsv4.asm
459b			endif 
459b			;;;;;;;;;;;;;; Debug code 
459b			 
459b			 
459b			;if DEBUG_FORTH_PARSE 
459b .. 00		.nowordfound: db "No match",0 
45a4 .. 00		.compword:	db "Comparing word ",0 
45b4 .. 00		.nextwordat:	db "Next word at",0 
45c1 .. 00		.charmatch:	db "Char match",0 
45cc			;endif 
45cc			if DEBUG_FORTH_JP 
45cc			.foundword:	db "Word match. Exec..",0 
45cc			endif 
45cc			;if DEBUG_FORTH_PUSH 
45cc .. 00		.enddict:	db "Dict end. Push.",0 
45dc .. 00		.push_str:	db "Pushing string",0 
45eb .. 00		.push_num:	db "Pushing number",0 
45fa .. 00		.data_sp:	db "SP:",0 
45fe .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4610 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4622 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4634			;endif 
4634			;if DEBUG_FORTH_MALLOC 
4634 .. 00		.push_malloc:	db "Malloc address",0 
4643			;endif 
4643			 
4643			 
4643			 
4643			; display malloc address and current data stack pointer  
4643			 
4643			malloc_error: 
4643 d5				push de 
4644 f5				push af 
4645 e5				push hl 
4646 cd 85 09			call clear_display 
4649 11 6b 46			ld de, .mallocerr 
464c 3e 00			ld a,0 
464e			;	ld de,os_word_scratch 
464e cd 98 09			call str_at_display 
4651 3e 11			ld a, display_row_1+17 
4653 11 7a ee			ld de, debug_mark 
4656 cd 98 09			call str_at_display 
4659 cd a8 09			call update_display 
465c				;call break_point_state 
465c cd c5 59			call cin_wait 
465f			 
465f 3e 20			ld a, ' ' 
4661 32 51 e3			ld (os_view_disable), a 
4664 e1				pop hl 
4665 f1				pop af 
4666 d1				pop de	 
4667				CALLMONITOR 
4667 cd 0e 14			call break_point_state  
466a				endm  
# End of macro CALLMONITOR
466a c9				ret 
466b			 
466b .. 00		.mallocerr: 	db "Malloc Error",0 
4678			;if DEBUG_FORTH_PUSH 
4678			display_data_sp: 
4678 f5				push af 
4679			 
4679				; see if disabled 
4679			 
4679 3a 51 e3			ld a, (os_view_disable) 
467c fe 2a			cp '*' 
467e 28 67			jr z, .skipdsp 
4680			 
4680 e5				push hl 
4681 e5				push hl 
4682 e5			push hl 
4683 cd 85 09			call clear_display 
4686 e1			pop hl 
4687 7c				ld a,h 
4688 21 65 e6			ld hl, os_word_scratch 
468b cd b3 0e			call hexout 
468e e1				pop hl 
468f 7d				ld a,l 
4690 21 67 e6			ld hl, os_word_scratch+2 
4693 cd b3 0e			call hexout 
4696 21 69 e6			ld hl, os_word_scratch+4 
4699 3e 00			ld a,0 
469b 77				ld (hl),a 
469c 11 65 e6			ld de,os_word_scratch 
469f 3e 28				ld a, display_row_2 
46a1 cd 98 09				call str_at_display 
46a4 11 fe 45			ld de, .wordinhl 
46a7 3e 00			ld a, display_row_1 
46a9			 
46a9 cd 98 09				call str_at_display 
46ac 11 7a ee			ld de, debug_mark 
46af 3e 11			ld a, display_row_1+17 
46b1			 
46b1 cd 98 09				call str_at_display 
46b4			 
46b4				; display current data stack pointer 
46b4 11 fa 45			ld de,.data_sp 
46b7 3e 30				ld a, display_row_2 + 8 
46b9 cd 98 09				call str_at_display 
46bc			 
46bc 2a 0d eb			ld hl,(cli_data_sp) 
46bf e5				push hl 
46c0 7c				ld a,h 
46c1 21 65 e6			ld hl, os_word_scratch 
46c4 cd b3 0e			call hexout 
46c7 e1				pop hl 
46c8 7d				ld a,l 
46c9 21 67 e6			ld hl, os_word_scratch+2 
46cc cd b3 0e			call hexout 
46cf 21 69 e6			ld hl, os_word_scratch+4 
46d2 3e 00			ld a,0 
46d4 77				ld (hl),a 
46d5 11 65 e6			ld de,os_word_scratch 
46d8 3e 33				ld a, display_row_2 + 11 
46da cd 98 09				call str_at_display 
46dd			 
46dd			 
46dd cd a8 09			call update_display 
46e0 cd fa 08			call delay1s 
46e3 cd fa 08			call delay1s 
46e6 e1				pop hl 
46e7			.skipdsp: 
46e7 f1				pop af 
46e8 c9				ret 
46e9			 
46e9			display_data_malloc: 
46e9			 
46e9 f5				push af 
46ea e5				push hl 
46eb e5				push hl 
46ec e5			push hl 
46ed cd 85 09			call clear_display 
46f0 e1			pop hl 
46f1 7c				ld a,h 
46f2 21 65 e6			ld hl, os_word_scratch 
46f5 cd b3 0e			call hexout 
46f8 e1				pop hl 
46f9 7d				ld a,l 
46fa 21 67 e6			ld hl, os_word_scratch+2 
46fd cd b3 0e			call hexout 
4700 21 69 e6			ld hl, os_word_scratch+4 
4703 3e 00			ld a,0 
4705 77				ld (hl),a 
4706 11 65 e6			ld de,os_word_scratch 
4709 3e 28				ld a, display_row_2 
470b cd 98 09				call str_at_display 
470e 11 34 46			ld de, .push_malloc 
4711 3e 00			ld a, display_row_1 
4713			 
4713 cd 98 09				call str_at_display 
4716			 
4716				; display current data stack pointer 
4716 11 fa 45			ld de,.data_sp 
4719 3e 30				ld a, display_row_2 + 8 
471b cd 98 09				call str_at_display 
471e			 
471e 2a 0d eb			ld hl,(cli_data_sp) 
4721 e5				push hl 
4722 7c				ld a,h 
4723 21 65 e6			ld hl, os_word_scratch 
4726 cd b3 0e			call hexout 
4729 e1				pop hl 
472a 7d				ld a,l 
472b 21 67 e6			ld hl, os_word_scratch+2 
472e cd b3 0e			call hexout 
4731 21 69 e6			ld hl, os_word_scratch+4 
4734 3e 00			ld a,0 
4736 77				ld (hl),a 
4737 11 65 e6			ld de,os_word_scratch 
473a 3e 33				ld a, display_row_2 + 11 
473c cd 98 09				call str_at_display 
473f			 
473f cd a8 09			call update_display 
4742 cd fa 08			call delay1s 
4745 cd fa 08			call delay1s 
4748 e1				pop hl 
4749 f1				pop af 
474a c9				ret 
474b			;endif 
474b			 
474b			include "forth_autostart.asm" 
474b			; list of commands to perform at system start up 
474b			 
474b			startcmds: 
474b			;	dw test11 
474b			;	dw test12 
474b			;	dw test13 
474b			;	dw test14 
474b			;	dw test15 
474b			;	dw test16 
474b			;	dw test17 
474b			;	dw ifthtest1 
474b			;	dw ifthtest2 
474b			;	dw ifthtest3 
474b			;	dw mmtest1 
474b			;	dw mmtest2 
474b			;	dw mmtest3 
474b			;	dw mmtest4 
474b			;	dw mmtest5 
474b			;	dw mmtest6 
474b			;	dw iftest1 
474b			;	dw iftest2 
474b			;	dw iftest3 
474b			;	dw looptest1 
474b			;	dw looptest2 
474b			;	dw test1 
474b			;	dw test2 
474b			;	dw test3 
474b			;	dw test4 
474b			;	dw game2r 
474b			;	dw game2b1 
474b			;	dw game2b2 
474b			 
474b				; start up words that are actually useful 
474b			 
474b a9 47			dw clrstack 
474d dc 47			dw type 
474f 9d 49			dw stest 
4751 00 48			dw strncpy 
4753 3e 49			dw list 
4755 61 48			dw start1 
4757 73 48			dw start2 
4759			;	dw start3 
4759 86 48			dw start3b 
475b de 48			dw start3c 
475d			 
475d				; (unit) testing words 
475d			 
475d 14 4a			dw mtesta 
475f c9 4a			dw mtestb 
4761 6c 4b			dw mtestc 
4763 21 4c			dw mtestd 
4765 c5 4c			dw mteste 
4767			 
4767				; demo/game words 
4767			 
4767 d1 53		        dw game3w 
4769 ff 53		        dw game3p 
476b 1d 54		        dw game3sc 
476d 4e 54		        dw game3vsi 
476f 7a 54		        dw game3vs 
4771				 
4771 c4 51			dw game2b 
4773 32 52			dw game2bf 
4775 7c 52			dw game2mba 
4777 12 53			dw game2mbas 
4779 54 53			dw game2mb 
477b			 
477b 85 4e			dw game1 
477d 96 4e			dw game1a 
477f f8 4e			dw game1b 
4781 2d 4f			dw game1c 
4783 63 4f			dw game1d 
4785 94 4f			dw game1s 
4787 a8 4f			dw game1t 
4789 bd 4f			dw game1f 
478b f1 4f			dw game1z 
478d 35 50			dw game1zz 
478f			 
478f 7b 4d			dw test5 
4791 b3 4d			dw test6 
4793 eb 4d			dw test7 
4795 ff 4d			dw test8 
4797 2b 4e			dw test9 
4799 41 4e			dw test10 
479b				 
479b 0c 51		        dw ssv5 
479d f0 50		        dw ssv4 
479f d4 50		        dw ssv3 
47a1 9e 50		        dw ssv2 
47a3 25 51		        dw ssv1 
47a5 6d 51		        dw ssv1cpm 
47a7			;	dw keyup 
47a7			;	dw keydown 
47a7			;	dw keyleft 
47a7			;	dw keyright 
47a7			;	dw 	keyf1 
47a7			;	dw keyf2 
47a7			;	dw keyf3 
47a7			;	dw keyf4 
47a7			;	dw keyf5 
47a7			;	dw keyf6 
47a7			;	dw keyf7 
47a7			;	dw keyf8 
47a7			;	dw keyf9 
47a7			;	dw keyf10 
47a7			;	dw keyf11 
47a7			;	dw keyf12 
47a7			;	dw keytab 
47a7			;	dw keycr 
47a7			;	dw keyhome 
47a7			;	dw keyend 
47a7			;	dw keybs 
47a7 00 00			db 0, 0	 
47a9			 
47a9			 
47a9			; clear stack  
47a9			 
47a9 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
47dc			 
47dc			; type ( addr count - ) 
47dc .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
4800			 
4800			; some direct memory words 
4800			; strncpy ( len t f -- t ) 
4800			 
4800 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
4861			 
4861 .. 00		start1:     	db ": bpon $0000 bp ;",0 
4873 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
4886			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
4886 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
48de .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
493e			 
493e			 
493e			; a handy word to list items on the stack 
493e			 
493e .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
499d			 
499d			 
499d			; test stack  
499d			; rnd8 stest 
499d			 
499d .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4a14			 
4a14			; random malloc and free cycles 
4a14			 
4a14 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4ac9			 
4ac9			; fixed malloc and free cycles 
4ac9			 
4ac9 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4b6c			 
4b6c			; fixed double string push and drop cycle  
4b6c			 
4b6c .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4c21			 
4c21			; consistent fixed string push and drop cycle  
4c21			 
4c21 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4cc5			 
4cc5 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4d7b			 
4d7b			;test1:		db ": aa 1 2 3 ;", 0 
4d7b			;test2:     	db "111 aa 888 999",0 
4d7b			;test3:     	db ": bb 77 ;",0 
4d7b			;test4:     	db "$02 $01 do i . loop bb",0 
4d7b			 
4d7b .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4db3 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4deb .. 00		test7:     	db ": box hline vline ;",0 
4dff .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4e2b .. 00		test9:     	db ": sw $01 adsp world ;",0 
4e41 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4e66 .. 00		test11:     	db "hello create .",0 
4e75 .. 00		test12:     	db "hello2 create .",0 
4e85			 
4e85			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4e85			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4e85			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4e85			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4e85			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4e85			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4e85			 
4e85			;iftest1:     	db "$0001 IF cls .",0 
4e85			;iftest2:     	db "$0000 IF cls .",0 
4e85			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4e85			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4e85			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4e85			 
4e85			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4e85			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4e85			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4e85			 
4e85			 
4e85			 
4e85			; a small guess the number game 
4e85			 
4e85 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4e96 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4ef8			 
4ef8 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4f2d .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4f63 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4f94 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
4fa8 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4fbd .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4ff1 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5035			 
5035			; Using 'ga' save a high score across multiple runs using external storage 
5035			 
5035 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
509e			 
509e			 
509e			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
509e			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
509e			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
509e			 
509e			; simple screen saver to test code memory reuse to destruction 
509e			 
509e .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
50d4 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
50f0 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
510c .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5125 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
516d .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
51c4			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
51c4			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
51c4			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
51c4			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
51c4			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
51c4			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
51c4			 
51c4			 
51c4			 
51c4			; minesweeper/battleship finding game 
51c4			; draws a game board of random ship/mine positions 
51c4			; user enters coords to see if it hits on 
51c4			; game ends when all are hit 
51c4			; when hit or miss says how many may be in the area 
51c4			 
51c4			; setup the game board and then hide it 
51c4 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5232 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
527c			; prompt for where to target 
527c .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5312 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5337			; TODO see if the entered coords hits or misses pushes char hit of miss 
5337 .. 00		game2mbht:      db ": mbckht nop ;",0 
5346 .. 00		game2mbms:      db ": mbcms nop ;",0 
5354			; TODO how many might be near by 
5354 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
53d1			 
53d1			; Game 3 
53d1			 
53d1			; Vert scroller ski game - avoid the trees! 
53d1			 
53d1			; v0 score (ie turns) 
53d1			; v1 player pos 
53d1			; v2 left wall 
53d1			; v3 right wall 
53d1			 
53d1			; Draw side walls randomly 
53d1			 
53d1 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
53ff			 
53ff			; Draw player 
53ff .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
541d			 
541d			; TODO Get Key 
541d			 
541d			; TODO Move left right 
541d			 
541d			; scroll and move walls a bit 
541d			 
541d .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
544e			 
544e			; main game loop 
544e			 
544e .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
547a .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
54b9			 
54b9			; key board defs 
54b9			 
54b9 .. 00		keyup:       db ": keyup $05 ;",0 
54c7 .. 00		keydown:       db ": keydown $0a ;",0 
54d7 .. 00		keyleft:       db ": keyleft $0b ;",0 
54e7 .. 00		keyright:       db ": keyright $0c ;",0 
54f8 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5506 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5514 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5522 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5530 .. 00		keyf5:       db ": keyf5 $14 ;",0 
553e .. 00		keyf6:       db ": keyf6 $15 ;",0 
554c .. 00		keyf7:       db ": keyf7 $16 ;",0 
555a .. 00		keyf8:       db ": keyf8 $17 ;",0 
5568 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5576 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5585 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5594 .. 00		keyf12:       db ": keyf12 $1b ;",0 
55a3			 
55a3 .. 00		keytab:       db ": keytab $09 ;",0 
55b2 .. 00		keycr:       db ": keycr $0d ;",0 
55c0 .. 00		keyhome:       db ": keyhome $0e ;",0 
55d0 .. 00		keyend:       db ": keyend $0f ;",0 
55df .. 00		keybs:       db ": keybs $08 ;",0 
55ed			 
55ed			   
55ed			 
55ed			 
55ed			 
55ed			; eof 
# End of file forth_autostart.asm
55ed			 
55ed .. 00		sprompt1: db "Startup load...",0 
55fd .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5613			 
5613			 
5613			 
5613			 
5613			forth_startup: 
5613 21 4b 47			ld hl, startcmds 
5616 3e 00			ld a, 0 
5618 32 86 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
561b			 
561b e5			.start1:	push hl 
561c cd 85 09			call clear_display 
561f 11 ed 55			ld de, sprompt1 
5622 3e 00		        ld a, display_row_1 
5624 cd 98 09			call str_at_display 
5627 11 fd 55			ld de, sprompt2 
562a 3e 28		        ld a, display_row_2 
562c cd 98 09			call str_at_display 
562f e1				pop hl 
5630 e5				push hl 
5631 5e				ld e,(hl) 
5632 23				inc hl 
5633 56				ld d,(hl) 
5634 3e 50		        ld a, display_row_3 
5636 cd 98 09			call str_at_display 
5639 cd a8 09			call update_display 
563c			 
563c			 
563c 3a 86 e7			ld a, (os_last_cmd) 
563f fe 00			cp 0 
5641 28 05			jr z, .startprompt 
5643 cd ee 08			call delay250ms 
5646 18 24			jr .startdo 
5648				 
5648				 
5648			 
5648			.startprompt: 
5648			 
5648 3e 9f			ld a,display_row_4 + display_cols - 1 
564a 11 11 19		        ld de, endprg 
564d cd 98 09			call str_at_display 
5650 cd a8 09			call update_display 
5653 cd fa 08			call delay1s 
5656 cd c5 59			call cin_wait 
5659						 
5659 fe 2a			cp '*' 
565b 28 5e			jr z, .startupend1 
565d fe 23			cp '#' 
565f 20 07			jr nz, .startno 
5661 3e 01			ld a, 1 
5663 32 86 e7			ld (os_last_cmd),a 
5666 18 04			jr .startdo 
5668 fe 31		.startno:	cp '1' 
566a 28 3a			jr z,.startnxt  
566c			 
566c				; exec startup line 
566c			.startdo:	 
566c e1				pop hl 
566d e5				push hl 
566e				 
566e 5e				ld e,(hl) 
566f 23				inc hl 
5670 56				ld d,(hl) 
5671 eb				ex de,hl 
5672			 
5672 e5				push hl 
5673			 
5673 3e 00			ld a, 0 
5675				;ld a, FORTH_END_BUFFER 
5675 cd 1b 10			call strlent 
5678 23				inc hl   ; include zero term to copy 
5679 06 00			ld b,0 
567b 4d				ld c,l 
567c e1				pop hl 
567d 11 60 e3			ld de, scratch 
5680 ed b0			ldir 
5682			 
5682			 
5682 21 60 e3			ld hl, scratch 
5685 cd 52 1d			call forthparse 
5688 cd 92 1d			call forthexec 
568b cd a9 1c			call forthexec_cleanup 
568e			 
568e 3e 78			ld a, display_row_4 
5690 11 b5 16			ld de, endprog 
5693			 
5693 cd a8 09			call update_display		 
5696			 
5696 3a 86 e7			ld a, (os_last_cmd) 
5699 fe 00			cp 0 
569b 20 09			jr nz, .startnxt 
569d cd 13 19			call next_page_prompt 
56a0 cd 85 09		        call clear_display 
56a3 cd a8 09			call update_display		 
56a6			 
56a6				; move onto next startup line? 
56a6			.startnxt: 
56a6			 
56a6 cd ee 08			call delay250ms 
56a9 e1				pop hl 
56aa			 
56aa 23				inc hl 
56ab 23				inc hl 
56ac			 
56ac e5				push hl 
56ad 5e				ld e, (hl) 
56ae 23				inc hl 
56af 56				ld d, (hl) 
56b0 e1				pop hl 
56b1				; TODO replace 0 test 
56b1			 
56b1 eb				ex de, hl 
56b2 cd db 0b			call ishlzero 
56b5			;	ld a,e 
56b5			;	add d 
56b5			;	cp 0    ; any left to do? 
56b5 eb				ex de, hl 
56b6 c2 1b 56			jp nz, .start1 
56b9 18 01			jr .startupend 
56bb			 
56bb e1			.startupend1: pop hl 
56bc			.startupend: 
56bc			 
56bc cd 85 09			call clear_display 
56bf cd a8 09			call update_display 
56c2 c9				ret 
56c3			 
56c3			 
56c3			; stack over and underflow checks 
56c3			 
56c3			; init the words to detect the under/overflow 
56c3			 
56c3			chk_stk_init: 
56c3				; a vague random number to check so we dont get any "lucky" hits 
56c3 3e 2d			ld a, 45 
56c5 6f				ld l, a 
56c6 00				nop 
56c7 3e 17			ld a, 23 
56c9 67				ld h, a 
56ca			 
56ca 22 47 e3			ld (chk_word), hl     ; the word we need to check against 
56cd			 
56cd			;	ld (chk_stund), hl	; stack points.... 
56cd 22 00 ef			ld (chk_stovr), hl 
56d0 22 0b eb			ld (chk_ret_und), hl 
56d3 22 c9 ea			ld (chk_ret_ovr), hl 
56d6 22 c7 e9			ld (chk_loop_ovr), hl 
56d9 22 c5 e8			ld (chk_data_ovr), hl 
56dc c9				ret 
56dd				 
56dd			check_stacks: 
56dd				; check all stack words 
56dd			 
56dd e5				push hl 
56de d5				push de 
56df			 
56df			;	ld de,(chk_word) 
56df			;	ld hl, (chk_stund)	; stack points.... 
56df			;	if DEBUG_STK_FAULT 
56df			;		DMARK "FAa" 
56df			;		CALLMONITOR 
56df			;	endif 
56df			;	call cmp16 
56df			;	jp z, .chk_faulta 
56df			; 
56df			;	ld de, sfaultsu 
56df			;	jp .chk_fault 
56df			 
56df 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
56e2 ed 5b 47 e3		ld de,(chk_word) 
56e6				if DEBUG_STK_FAULT 
56e6					DMARK "FAb" 
56e6					CALLMONITOR 
56e6				endif 
56e6 cd d0 0b			call cmp16 
56e9 28 06			jr z, .chk_fault1 
56eb 11 8c 57			ld de, sfaultso 
56ee c3 40 57			jp .chk_fault 
56f1			.chk_fault1:  
56f1 2a 0b eb			ld hl, (chk_ret_und) 
56f4 ed 5b 47 e3		ld de,(chk_word) 
56f8				if DEBUG_STK_FAULT 
56f8					DMARK "FAU" 
56f8					CALLMONITOR 
56f8				endif 
56f8 cd d0 0b			call cmp16 
56fb ca 04 57			jp z, .chk_fault2 
56fe 11 9c 57			ld de, sfaultru 
5701 c3 40 57			jp .chk_fault 
5704			.chk_fault2:  
5704 2a c9 ea			ld hl, (chk_ret_ovr) 
5707 ed 5b 47 e3		ld de,(chk_word) 
570b				if DEBUG_STK_FAULT 
570b					DMARK "FA1" 
570b					CALLMONITOR 
570b				endif 
570b cd d0 0b			call cmp16 
570e ca 17 57			jp z, .chk_fault3 
5711 11 aa 57			ld de, sfaultro 
5714 c3 40 57			jp .chk_fault 
5717			.chk_fault3:  
5717 2a c7 e9			ld hl, (chk_loop_ovr) 
571a ed 5b 47 e3		ld de,(chk_word) 
571e				if DEBUG_STK_FAULT 
571e					DMARK "FA2" 
571e					CALLMONITOR 
571e				endif 
571e cd d0 0b			call cmp16 
5721 ca 2a 57			jp z, .chk_fault4 
5724 11 c4 57			ld de, sfaultlo 
5727 c3 40 57			jp .chk_fault 
572a			.chk_fault4:  
572a 2a c5 e8			ld hl, (chk_data_ovr) 
572d ed 5b 47 e3		ld de,(chk_word) 
5731				if DEBUG_STK_FAULT 
5731					DMARK "FA3" 
5731					CALLMONITOR 
5731				endif 
5731 cd d0 0b			call cmp16 
5734 ca 3d 57			jp z, .chk_fault5 
5737 11 de 57			ld de, sfaultdo 
573a c3 40 57			jp .chk_fault 
573d			 
573d			 
573d			.chk_fault5:  
573d d1				pop de 
573e e1				pop hl 
573f			 
573f c9				ret 
5740			 
5740 cd 85 09		.chk_fault: 	call clear_display 
5743 3e 28				ld a, display_row_2 
5745 cd 98 09				call str_at_display 
5748 11 6e 57				   ld de, .stackfault 
574b 3e 00				ld a, display_row_1 
574d cd 98 09				call str_at_display 
5750 11 7a ee				    ld de, debug_mark 
5753 3e 11				ld a, display_row_1+17 
5755 cd 98 09				call str_at_display 
5758 cd a8 09				call update_display 
575b			 
575b				; prompt before entering montior for investigating issue 
575b			 
575b 3e 78			ld a, display_row_4 
575d 11 b5 16			ld de, endprog 
5760			 
5760 cd a8 09			call update_display		 
5763			 
5763 cd 13 19			call next_page_prompt 
5766			 
5766 d1				pop de 
5767 e1				pop hl 
5768 cd 09 17				call monitor 
576b c3 03 16				jp warmstart 
576e					;jp 0 
576e					;halt 
576e			 
576e			 
576e			 
576e .. 00		.stackfault: 	db "Stack fault:",0 
577b			 
577b .. 00		sfaultsu: 	db	"Stack under flow",0 
578c .. 00		sfaultso: 	db	"Stack over flow",0 
579c .. 00		sfaultru:	db "RTS underflow",0 
57aa .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
57c4 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
57de .. 00		sfaultdo:	db "DTS overflow", 0 
57eb			 
57eb			 
57eb			fault_dsp_under: 
57eb 11 fd 57			ld de, .dsp_under 
57ee c3 ad 58			jp .show_fault 
57f1			 
57f1			fault_rsp_under: 
57f1 11 0b 58			ld de, .rsp_under 
57f4 c3 ad 58			jp .show_fault 
57f7			fault_loop_under: 
57f7 11 19 58			ld de, .loop_under 
57fa c3 ad 58			jp .show_fault 
57fd			 
57fd .. 00		.dsp_under: db "DSP Underflow",0 
580b .. 00		.rsp_under: db "RSP Underflow",0 
5819 .. 00		.loop_under: db "LOOP Underflow",0 
5828			 
5828			 
5828 d5			type_faultn: 	push de 
5829 e5					push hl 
582a cd 85 09				call clear_display 
582d 11 54 58				   ld de, .typefaultn 
5830 3e 00				ld a, display_row_1 
5832 cd 98 09				call str_at_display 
5835 11 7a ee				    ld de, debug_mark 
5838 3e 11				ld a, display_row_1+17 
583a cd 98 09				call str_at_display 
583d cd a8 09				call update_display 
5840			 
5840				; prompt before entering montior for investigating issue 
5840			 
5840 3e 78			ld a, display_row_4 
5842 11 b5 16			ld de, endprog 
5845			 
5845 cd a8 09			call update_display		 
5848			 
5848 cd 13 19			call next_page_prompt 
584b			 
584b e5					push hl 
584c d5					push de 
584d cd 09 17				call monitor 
5850 c3 03 16				jp warmstart 
5853 76					halt 
5854			 
5854			 
5854 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
586b			 
586b d5			type_faults: 	push de 
586c e5					push hl 
586d cd 85 09				call clear_display 
5870 11 96 58				   ld de, .typefaults 
5873 3e 00				ld a, display_row_1 
5875 cd 98 09				call str_at_display 
5878 11 7a ee				    ld de, debug_mark 
587b 3e 11				ld a, display_row_1+17 
587d cd 98 09				call str_at_display 
5880 cd a8 09				call update_display 
5883			 
5883				; prompt before entering montior for investigating issue 
5883			 
5883 3e 78			ld a, display_row_4 
5885 11 b5 16			ld de, endprog 
5888			 
5888 cd a8 09			call update_display		 
588b			 
588b cd 13 19			call next_page_prompt 
588e			 
588e e1					pop hl 
588f d1					pop de 
5890 cd 09 17				call monitor 
5893 c3 03 16				jp warmstart 
5896			 
5896			 
5896 .. 00		.typefaults: db "STR Type Expected TOS!",0 
58ad			 
58ad			.show_fault: 	 
58ad d5					push de 
58ae cd 85 09				call clear_display 
58b1 d1					pop de 
58b2 3e 00				ld a, display_row_1 
58b4 cd 98 09				call str_at_display 
58b7 11 7a ee				    ld de, debug_mark 
58ba 3e 11				ld a, display_row_1+17 
58bc cd 98 09				call str_at_display 
58bf cd a8 09				call update_display 
58c2			 
58c2				; prompt before entering montior for investigating issue 
58c2			 
58c2 3e 78			ld a, display_row_4 
58c4 11 b5 16			ld de, endprog 
58c7			 
58c7 cd a8 09			call update_display		 
58ca			 
58ca cd 13 19			call next_page_prompt 
58cd			 
58cd e1					pop hl 
58ce d1					pop de 
58cf cd 09 17				call monitor 
58d2			; do a dump to cli and not warmstart so we preserve all of the uwords.  
58d2			; TODO Make optional fault restart to cli or warm boot? 
58d2					;jp warmstart 
58d2 c3 5b 16				jp cli 
58d5 76					halt 
58d6			 
58d6			; handle the auto run of code from files in storage 
58d6			 
58d6			 
58d6			if STORAGE_SE 
58d6			 
58d6			sprompt3: db "Loading from start-up file?:",0 
58d6			sprompt4: db "(Y=Any key/N=No)",0 
58d6			 
58d6			 
58d6			forth_autoload: 
58d6			 
58d6				; load block 0 of store 1 
58d6				 
58d6				ld a, $fe      ; bit 0 clear 
58d6				ld (spi_device), a 
58d6			 
58d6				call storage_get_block_0 
58d6			 
58d6				ld a, (store_page+STORE_0_AUTOFILE) 
58d6			 
58d6				cp 0 
58d6				ret z     ; auto start not enabled 
58d6			 
58d6				call clear_display 
58d6			 
58d6				; set bank 
58d6			 
58d6					ld a, (store_page+STORE_0_BANKRUN) 
58d6					ld (spi_device), a 
58d6			 
58d6				; get file id to load from and get the file name to display 
58d6			 
58d6					ld a, (store_page+STORE_0_FILERUN) 
58d6			 
58d6					ld l, 0 
58d6					ld h, a 
58d6					ld de, store_page 
58d6			 
58d6					if DEBUG_FORTH_WORDS 
58d6						DMARK "ASp" 
58d6						CALLMONITOR 
58d6					endif 
58d6					call storage_read 
58d6			 
58d6					if DEBUG_FORTH_WORDS 
58d6						DMARK "ASr" 
58d6						CALLMONITOR 
58d6					endif 
58d6			 
58d6					call ishlzero 
58d6					ret z             ; file not found 
58d6			 
58d6					ld a, display_row_2 + 10 
58d6					ld de, store_page+3 
58d6					call str_at_display 
58d6				 
58d6			; 
58d6			 
58d6				ld a, display_row_1+5 
58d6				ld de, sprompt3 
58d6				call str_at_display 
58d6				ld a, display_row_3+15 
58d6				ld de, sprompt4 
58d6				call str_at_display 
58d6			 
58d6				call update_display 
58d6			 
58d6				call cin_wait 
58d6				cp 'n' 
58d6				ret z 
58d6				cp 'N' 
58d6				ret z 
58d6			 
58d6				call delay1s 
58d6			 
58d6				ld a, (store_page+2) 
58d6				ld (store_openmaxext), a    ; save count of ext 
58d6				ld a, 1  
58d6				ld (store_openext), a    ; save count of ext 
58d6			 
58d6			.autof:  
58d6				ld l , a 
58d6				 
58d6				ld a, (store_page) 
58d6				ld h, a	 
58d6				ld de, store_page 
58d6					if DEBUG_FORTH_WORDS 
58d6						DMARK "ASl" 
58d6						CALLMONITOR 
58d6					endif 
58d6					call storage_read 
58d6				call ishlzero 
58d6				ret z 
58d6			 
58d6					if DEBUG_FORTH_WORDS 
58d6						DMARK "ASc" 
58d6						CALLMONITOR 
58d6					endif 
58d6				ld de, store_page+2 
58d6				ld a, display_row_4 
58d6				call str_at_display 
58d6			 
58d6				call update_display 
58d6				call delay250ms 
58d6			 
58d6			 
58d6			 
58d6				ld hl, store_page+2 
58d6				call forthparse 
58d6				call forthexec 
58d6				call forthexec_cleanup 
58d6			 
58d6				 
58d6				ld a, (store_openext) 
58d6				inc a 
58d6				ld (store_openext), a    ; save count of ext 
58d6			 
58d6				jr .autof 
58d6			 
58d6			;.autofdone: 
58d6			; 
58d6			;		if DEBUG_FORTH_WORDS 
58d6			;			DMARK "ASx" 
58d6			;			CALLMONITOR 
58d6			;		endif 
58d6			;;	call clear_display 
58d6			;	ret 
58d6			 
58d6			 
58d6			 
58d6			endif 
58d6			 
58d6			 
58d6			; eof 
# End of file forth_kernel.asm
58d6			;include "nascombasic.asm" 
58d6			 
58d6			 
58d6			; find out where the code ends if loaded into RAM (for SC114) 
58d6			;endofcode:  
58d6			;	nop 
58d6			 
58d6			 
58d6			; eof 
58d6			 
# End of file main.asm
58d6			;include "firmware_lcd_4x40.asm" 
58d6			;;include "firmware_lcd_4x20.asm" 
58d6			include "firmware_cpm_display.asm" 
58d6			 
58d6			; Serial display interface for SC114 
58d6			 
58d6			 
58d6			display_row_1: equ 0 
58d6			display_row_2: equ display_row_1+display_cols 
58d6			display_row_3: equ display_row_2 + display_cols 
58d6			display_row_4: equ display_row_3 + display_cols 
58d6			 
58d6			kLCDWidth:  EQU display_cols             ;Width in characters 
58d6			kLCD_Line1: EQU 0x00  
58d6			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
58d6			; E1 
58d6			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
58d6			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
58d6			 
58d6			lcd_init: 
58d6				; no init as handled by the SCM bios 
58d6 c9				ret 
58d7			 
58d7			 
58d7			; low level functions for direct screen writes 
58d7			 
58d7			; output char at pos? 
58d7			fLCD_Str: 
58d7			        ;out (SC114_SIO_1_OUT),a 
58d7 c5				push bc 
58d8 d5				push de 
58d9 5f				ld e, a 
58da			; TODO Replace with CP/M BIOS call 
58da 0e 02			ld c, $02 
58dc cd 05 00			call 5 
58df d1				pop de 
58e0 c1				pop bc 
58e1 c9				ret 
58e2			 
58e2			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
58e2			fLCD_Pos: 
58e2				; use ASCII escape to position 
58e2			        ;out (SC114_SIO_1_OUT),a 
58e2 c5				push bc 
58e3 d5				push de 
58e4 5f				ld e, a 
58e5 0e 02			ld c, $02 
58e7			; TODO Replace with CP/M BIOS call 
58e7 cd 05 00			call 5 
58ea d1				pop de 
58eb c1				pop bc 
58ec			 
58ec c9				ret 
58ed			 
58ed			; output char at pos 
58ed			fLCD_Data: 
58ed			      ;  out (SC114_SIO_1_OUT),a 
58ed c5				push bc 
58ee d5				push de 
58ef 0e 02			ld c, $02 
58f1 5f				ld e, a 
58f2			; TODO Replace with CP/M BIOS call 
58f2 cd 05 00			call 5 
58f5 d1				pop de 
58f6 c1				pop bc 
58f7			 
58f7 c9				ret 
58f8			 
58f8			; ascii cls  
58f8			 
58f8 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
58fc			 
58fc 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5913			;.clscpm: db 3, $3c,"$" 
5913			 
5913			; write the frame buffer given in hl to hardware  
5913			write_display: 
5913			 
5913			API: equ 0 
5913			 
5913			if API 
5913				push bc 
5913				ld b, 4 
5913			 
5913			        ld (display_write_tmp), hl 	  
5913			 
5913				; clear and home cursor 
5913			 
5913				ld c, 9 
5913				ld de, .cls 
5913			; TODO Replace with CP/M BIOS call 
5913				call 5 
5913			 
5913			 
5913			.writeln: 
5913			 
5913				ld de, (display_write_tmp) 
5913				ld c, 6 
5913			; TODO Replace with CP/M BIOS call 
5913				rst $30 
5913				ld c, 7 
5913				rst $30 
5913			 
5913				ld hl, (display_write_tmp) 
5913				ld de, display_cols 
5913				add hl,de 
5913				ld (display_write_tmp),hl 
5913			 
5913				djnz  .writeln 
5913			 
5913				pop bc 
5913			 
5913			 
5913				ret 
5913			endif 
5913 e5				push hl 
5914 c5				push bc 
5915 d5				push de 
5916			 
5916			;	ld c, 2 
5916			;	;ld de, .cls 
5916			;	ld a, 27 
5916			;	rst $30 
5916			;	ld c, 2 
5916			;	;ld de, .cls 
5916			;	ld a, '[' 
5916			;	rst $30 
5916			; 
5916			;	ld c, 2 
5916			;	;ld de, .cls 
5916			;	ld a, 'H' 
5916			;	rst $30 
5916			; 
5916			 
5916			 
5916			; lots of CR/LF 
5916			;	ld c, 9 
5916			;	ld de, .clscpm 
5916			;	call 5 
5916			 
5916			; xterm cls 
5916 0e 02			ld c, 2 
5918 1e 1b			ld e, 27 
591a cd 05 00			call 5 
591d			; cls causes too much flicker 
591d			;	ld c, 2 
591d			;	ld e, 'c' 
591d			;	call 5 
591d			 
591d			; use xterm home instead 
591d 0e 02			ld c, 2 
591f 1e 5b			ld e, '[' 
5921 cd 05 00			call 5 
5924 0e 02			ld c, 2 
5926 1e 48			ld e, 'H' 
5928 cd 05 00			call 5 
592b			LLL: equ 0 
592b			 
592b			if LLL 
592b			 
592b				ld c, 2 
592b				;ld de, .cls 
592b				ld e, 27 
592b			; TODO Replace with CP/M BIOS call 
592b				call 5 
592b			 
592b			 
592b				ld c, 2 
592b				;ld de, .cls 
592b				ld e, '[' 
592b			; TODO Replace with CP/M BIOS call 
592b				call 5 
592b				ld c, 2 
592b				;ld de, .cls 
592b				ld e, '2' 
592b			; TODO Replace with CP/M BIOS call 
592b				call 5 
592b				ld c, 2 
592b				;ld de, .cls 
592b				ld e, 'J' 
592b			; TODO Replace with CP/M BIOS call 
592b				call 5 
592b			 
592b			endif 
592b			 
592b d1				pop de 
592c c1				pop bc 
592d e1				pop hl 
592e			 
592e			 
592e 22 d8 eb		        ld (display_write_tmp), hl 	  
5931 3e 00			ld a, kLCD_Line1 
5933			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5933 06 28			ld b, display_cols 
5935 ed 5b d8 eb		ld de, (display_write_tmp) 
5939 cd bc 59			call write_len_string 
593c				 
593c			 
593c e5			push hl 
593d d5			push de 
593e c5			push bc 
593f 0e 02			ld c, 2 
5941 1e 0a			ld e, 10 
5943 cd 05 00			call 5 
5946 0e 02			ld c, 2 
5948 1e 0d			ld e, 13 
594a cd 05 00			call 5 
594d			; TODO Replace with CP/M BIOS call 
594d				;rst $30 
594d c1			pop bc 
594e d1			pop de 
594f e1			pop hl 
5950			 
5950				 
5950 2a d8 eb			ld hl, (display_write_tmp) 
5953 11 28 00			ld de, display_cols 
5956 19				add hl,de 
5957 22 d8 eb			ld (display_write_tmp),hl 
595a			 
595a				 
595a 3e 28			ld a, kLCD_Line2 
595c			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
595c 06 28			ld b, display_cols 
595e ed 5b d8 eb		ld de, (display_write_tmp) 
5962 cd bc 59			call write_len_string 
5965				 
5965 2a d8 eb			ld hl, (display_write_tmp) 
5968 11 28 00			ld de, display_cols 
596b 19				add hl,de 
596c 22 d8 eb			ld (display_write_tmp),hl 
596f			 
596f e5			push hl 
5970 d5			push de 
5971 c5			push bc 
5972 0e 07			ld c, 7 
5974			; TODO Replace with CP/M BIOS call 
5974				;rst $30 
5974 0e 02			ld c, 2 
5976 1e 0a			ld e, 10 
5978 cd 05 00			call 5 
597b 0e 02			ld c, 2 
597d 1e 0d			ld e, 13 
597f cd 05 00			call 5 
5982 c1			pop bc 
5983 d1			pop de 
5984 e1			pop hl 
5985			 
5985				 
5985 3e 50			ld a, kLCD_Line3 
5987			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5987 06 28			ld b, display_cols 
5989 ed 5b d8 eb		ld de, (display_write_tmp) 
598d cd bc 59			call write_len_string 
5990				 
5990 2a d8 eb			ld hl, (display_write_tmp) 
5993 11 28 00			ld de, display_cols 
5996 19				add hl,de 
5997 22 d8 eb			ld (display_write_tmp),hl 
599a			 
599a e5			push hl 
599b d5			push de 
599c c5			push bc 
599d 0e 07			ld c, 7 
599f			; TODO Replace with CP/M BIOS call 
599f				;rst $30 
599f 0e 02			ld c, 2 
59a1 1e 0a			ld e, 10 
59a3 cd 05 00			call 5 
59a6 0e 02			ld c, 2 
59a8 1e 0d			ld e, 13 
59aa cd 05 00			call 5 
59ad c1			pop bc 
59ae d1			pop de 
59af e1			pop hl 
59b0			 
59b0				 
59b0 3e 78			ld a, kLCD_Line4 
59b2			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
59b2 06 28			ld b, display_cols 
59b4 ed 5b d8 eb		ld de, (display_write_tmp) 
59b8 cd bc 59			call write_len_string 
59bb c9					ret 
59bc			 
59bc			 
59bc				; write out a fixed length string given in b from de 
59bc			 
59bc 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
59bd cd ed 58		            CALL fLCD_Data      ;Write character to display 
59c0 13				inc de 
59c1 10 f9			djnz write_len_string 
59c3 c9				ret 
59c4			 
59c4			 
59c4			; eof 
# End of file firmware_cpm_display.asm
59c4			;include "firmware_key_5x10.asm" 
59c4			;;include "firmware_key_4x10.asm" 
59c4			include "firmware_key_cpm.asm" 
59c4			; Serial keyboard interface for SC114 
59c4			 
59c4			 
59c4			key_init: 
59c4				; no init as handled by the SCM bios 
59c4 c9				ret 
59c5			 
59c5			 
59c5			cin_wait: 
59c5			;	ld a, 0 
59c5			;	ret 
59c5			 
59c5				;in a,(SC114_SIO_1_IN) 
59c5			        ; Use SCM API to get from whatever console device we are using 
59c5			 
59c5			; TODO Replace with CP/M BIOS call 
59c5 c5				push bc 
59c6 0e 01			ld c, $01 
59c8 cd 05 00			call 5 
59cb c1				pop bc 
59cc c9				ret 
59cd			 
59cd			cin: 
59cd			 
59cd			 
59cd c5				push bc 
59ce			 
59ce				; any key waiting to process? 
59ce			; TODO Replace with CP/M BIOS call 
59ce 0e 06			ld c, $06 
59d0 cd 05 00			call 5 
59d3 28 0d			jr z, .cin_skip 
59d5			 
59d5				; yep, get it 
59d5			 
59d5 0e 01			ld c, $01 
59d7			; TODO Replace with CP/M BIOS call 
59d7 cd 05 00			call 5 
59da			 
59da fe 7f			cp $7f     ; back space 
59dc 20 02			jr nz, .skipbs 
59de 3e 08			ld a, KEY_BS 
59e0			.skipbs: 
59e0			 
59e0 c1				pop bc 
59e1 c9				ret 
59e2			.cin_skip: 
59e2 3e 00			ld a, 0 
59e4 c1				pop bc 
59e5 c9				ret 
59e6			 
59e6			 
59e6			 
59e6			 
# End of file firmware_key_cpm.asm
59e6			endofcode:  
59e6			baseram:  
59e6 00				nop 
59e7			 
59e7			heap_start: equ baseram+15  ; Starting address of heap 
59e7			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
59e7			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
59e7			;VDU:  EQU     endofcode           ; BASIC Work space 
59e7			; eof 
59e7			 
# End of file os_mega_cpm.asm
59e7
