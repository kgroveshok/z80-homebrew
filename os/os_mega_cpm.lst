# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 5c 14			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 0   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diags   
0103			  
0103			hardware_diag: equ key_face_held - 1  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_diag - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ os_input  
0103			os_new_parse_len: equ os_new_malloc + 2  
0103			os_new_word_len: equ os_new_parse_len + 2  
0103			os_new_work_ptr: equ os_new_word_len + 2  
0103			os_new_src_ptr: equ os_new_work_ptr + 2  
0103			os_new_exec: equ os_new_src_ptr + 2  
0103			os_new_exec_ptr: equ os_new_exec + 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ scratch - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103 3e 00				ld a, 0  
0105 32 80 ee				ld (hardware_diag), a  
0108			  
0108					; clear all the buffers  
0108			  
0108 21 1f ed				ld hl, display_fb1  
010b 22 db eb				ld (display_fb_active), hl  
010e			  
010e cd 69 09				call clear_display  
0111			  
0111 21 dd eb				ld hl, display_fb2  
0114 22 db eb				ld (display_fb_active), hl  
0117			  
0117 cd 69 09				call clear_display  
011a			  
011a					; init primary frame buffer area  
011a 21 c0 ed				ld hl, display_fb0  
011d 22 db eb				ld (display_fb_active), hl  
0120			  
0120 cd 69 09				call clear_display  
0123			  
0123			  
0123 cd fa 54				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0126			  
0126 cd e8 55			call key_init  
0129 cd b0 01			call storage_init  
012c			  
012c				; setup malloc functions  
012c			  
012c				if MALLOC_1  
012c cd 65 0f				call  heap_init  
012f				endif  
012f				if MALLOC_4  
012f					call  heap_init  
012f				endif  
012f			  
012f				; init sound hardware if present  
012f			  
012f				if SOUND_ENABLE  
012f					call sound_init  
012f				endif  
012f			  
012f				; lcd test sequence  
012f					  
012f cd 8c 09			call update_display  
0132 cd e2 08			call delay1s  
0135 3e 2b			ld a,'+'  
0137 cd 6e 09			call fill_display  
013a cd 8c 09			call update_display  
013d cd e2 08			call delay1s  
0140 3e 2a			ld a,'*'  
0142 cd 6e 09			call fill_display  
0145 cd 8c 09			call update_display  
0148 cd e2 08			call delay1s  
014b 3e 2d			ld a,'-'  
014d cd 6e 09			call fill_display  
0150 cd 8c 09			call update_display  
0153 cd e2 08			call delay1s  
0156			  
0156			; boot splash screen  
0156			if display_cols == 20	  
0156			        ld a, display_row_1    
0156			else  
0156 3e 0a		        ld a, display_row_1 +10   
0158			endif  
0158 11 89 01			ld de, bootmsg  
015b cd 7c 09			call str_at_display  
015e cd 8c 09			call update_display  
0161			  
0161			  
0161 cd e2 08			call delay1s  
0164 cd e2 08			call delay1s  
0167			if display_cols == 20	  
0167			            LD   A, display_row_3+2  
0167			else  
0167 3e 5c		            LD   A, display_row_3+12  
0169			endif  
0169 11 9e 01			ld de, bootmsg1  
016c cd 7c 09			call str_at_display  
016f cd 8c 09			call update_display  
0172 cd e2 08			call delay1s  
0175 cd e2 08			call delay1s  
0178			  
0178			;	ld a, display_row_4+3  
0178			;	ld de, bootmsg2  
0178			;	call str_at_display  
0178			;	call update_display  
0178			;	call delay1s  
0178			;	call delay1s  
0178			  
0178			; debug mark setup  
0178			  
0178 3e 5f		ld a, '_'  
017a 32 7a ee		ld (debug_mark),a  
017d 32 7b ee		ld (debug_mark+1),a  
0180 32 7c ee		ld (debug_mark+2),a  
0183 3e 00		ld a,0  
0185 32 7d ee		ld (debug_mark+3),a  
0188			  
0188 c9					ret  
0189			  
0189			  
0189 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
019e .. 00		bootmsg1:	db "by Kevin Groves",0  
01ae			;bootmsg2:	db "Firmware v0.1",0  
01ae			  
01ae			; a 4x20 lcd  
01ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ae			  
01ae			;if display_cols == 20  
01ae			;	include "firmware_lcd_4x20.asm"  
01ae			;endif  
01ae			  
01ae			;if display_cols == 40  
01ae			;	include "firmware_lcd_4x40.asm"  
01ae			;endif  
01ae			  
01ae			;  
01ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ae			; TODO abstract the bit bang video out interface for dual display  
01ae			; TODO wire video out to tx pin on rc2014 bus  
01ae			  
01ae			; must supply cin, and cin_wait for low level hardware abstraction   
01ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ae			; test scancode  
01ae			  
01ae			;;;;;  
01ae			;;;  
01ae			; Moved out to mini and maxi versions  
01ae			;  
01ae			; include "firmware_key_4x4.asm"  
01ae			; using existing 4 wire x 4 resistor array for input  
01ae			;include "firmware_key_4x10.asm"  
01ae			; need to mod the board for 5 rows due to resistor array  
01ae			;include "firmware_key_5x10.asm"  
01ae			  
01ae			; storage hardware interface  
01ae			  
01ae			; use microchip serial eeprom for storage  
01ae			  
01ae			  
01ae			if STORAGE_SE  
01ae				include "firmware_spi.asm"  
01ae				include "firmware_seeprom.asm"  
01ae			else  
01ae			   ; create some stubs for the labels  
01ae c9			se_readbyte: ret  
01af c9			se_writebyte: ret  
01b0 c9			storage_init: ret  
01b1			  
01b1			endif  
01b1			  
01b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01b1			;include "firmware_cf.asm"  
01b1			  
01b1			; load up high level storage hardward abstractions  
01b1			include "firmware_storage.asm"  
01b1			 
01b1			; persisent storage hardware abstraction layer  
01b1			 
01b1			 
01b1			 
01b1			; Block 0 on storage is a config state 
01b1			 
01b1			 
01b1			 
01b1			; TODO add read phy block and write phy block functions 
01b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01b1			 
01b1			; Abstraction layer  
01b1			 
01b1			; Logocial block size is same size as physical size - using tape concept 
01b1			 
01b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01b1			 
01b1			 
01b1			 
01b1			; Filesystem layout (Logical layout) 
01b1			; 
01b1			; Block 0 - Bank config  
01b1			; 
01b1			;      Byte - 0 file id counter 
01b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01b1			;      Byte - 3-20 zero terminated bank label 
01b1			; 
01b1			; Block 1 > File storage 
01b1			; 
01b1			;      Byte 0 file id    - block 0 file details 
01b1			;      Byte 1 block id - block 0 is file  
01b1			;            Byte 2-15 - File name 
01b1			; 
01b1			;       - to end of block data 
01b1			; 
01b1			 
01b1			 
01b1			; Read Block 
01b1			; ---------- 
01b1			; 
01b1			; With current bank 
01b1			;  
01b1			; Get block number to read 
01b1			; Load physical blocks starting at start block into buffer 
01b1			 
01b1			; de points to buffer to use 
01b1			; hl holds logical block number  
01b1			 
01b1			storage_read_block: 
01b1			 
01b1				; TODO bank selection 
01b1			 
01b1				; for each of the physical blocks read it into the buffer 
01b1 06 40			ld b, STORE_BLOCK_PHY 
01b3			 
01b3				if DEBUG_STORESE 
01b3 d5					push de 
01b4				endif 
01b4				 
01b4			.rl1:    
01b4			 
01b4				; read physical block at hl into de 
01b4			        ; increment hl and de to next read position on exit 
01b4			 
01b4 e5				push hl 
01b5 d5				push de	 
01b6 c5				push bc 
01b7			;	if DEBUG_STORESE 
01b7			;		push af 
01b7			;		ld a, 'R' 
01b7			;		ld (debug_mark),a 
01b7			;		pop af 
01b7			;		CALLMONITOR 
01b7			;	endif 
01b7 cd ae 01			call se_readbyte 
01ba			;	if DEBUG_STORESE 
01ba			;		ld a,(spi_portbyte) 
01ba			;		ld l, a 
01ba			;		push af 
01ba			;		ld a, '1' 
01ba			;		ld (debug_mark),a 
01ba			;		pop af 
01ba			;		CALLMONITOR 
01ba			;	endif 
01ba c1				pop bc 
01bb d1				pop de 
01bc e1				pop hl 
01bd 12				ld (de),a 
01be 23				inc hl 
01bf 13				inc de 
01c0			 
01c0			;	if DEBUG_STORESE 
01c0			;		push af 
01c0			;		ld a, 'r' 
01c0			;		ld (debug_mark),a 
01c0			;		pop af 
01c0			;		CALLMONITOR 
01c0			;	endif 
01c0			 
01c0 10 f2			djnz .rl1 
01c2			 
01c2				if DEBUG_STORESE 
01c2					DMARK "SRB" 
01c2 f5				push af  
01c3 3a d7 01			ld a, (.dmark)  
01c6 32 7a ee			ld (debug_mark),a  
01c9 3a d8 01			ld a, (.dmark+1)  
01cc 32 7b ee			ld (debug_mark+1),a  
01cf 3a d9 01			ld a, (.dmark+2)  
01d2 32 7c ee			ld (debug_mark+2),a  
01d5 18 03			jr .pastdmark  
01d7 ..			.dmark: db "SRB"  
01da f1			.pastdmark: pop af  
01db			endm  
# End of macro DMARK
01db d1					pop de 
01dc			; 
01dc			;		push af 
01dc			;		ld a, 'R' 
01dc			;		ld (debug_mark),a 
01dc			;		pop af 
01dc					CALLMONITOR 
01dc cd 86 12			call break_point_state  
01df				endm  
# End of macro CALLMONITOR
01df				endif 
01df c9				ret	 
01e0				 
01e0			 
01e0			; File Size 
01e0			; --------- 
01e0			; 
01e0			;   hl file id 
01e0			; 
01e0			;  returns in hl the number of blocks 
01e0			 
01e0			storage_file_size: 
01e0 5d				ld e, l 
01e1 16 00			ld d, 0 
01e3 21 40 00			ld hl, STORE_BLOCK_PHY 
01e6					if DEBUG_FORTH_WORDS 
01e6						DMARK "SIZ" 
01e6 f5				push af  
01e7 3a fb 01			ld a, (.dmark)  
01ea 32 7a ee			ld (debug_mark),a  
01ed 3a fc 01			ld a, (.dmark+1)  
01f0 32 7b ee			ld (debug_mark+1),a  
01f3 3a fd 01			ld a, (.dmark+2)  
01f6 32 7c ee			ld (debug_mark+2),a  
01f9 18 03			jr .pastdmark  
01fb ..			.dmark: db "SIZ"  
01fe f1			.pastdmark: pop af  
01ff			endm  
# End of macro DMARK
01ff						CALLMONITOR 
01ff cd 86 12			call break_point_state  
0202				endm  
# End of macro CALLMONITOR
0202					endif 
0202 cd c7 04			call storage_findnextid 
0205			 
0205 cd eb 0a			call ishlzero 
0208			;	ld a, l 
0208			;	add h 
0208			;	cp 0 
0208 c8				ret z			; block not found so EOF 
0209			 
0209 11 65 eb			ld de, store_page 
020c cd b1 01			call storage_read_block 
020f			 
020f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
0212 6f				ld l, a 
0213 26 00			ld h, 0 
0215 c9			 	ret 
0216			 
0216			 
0216			; Write Block 
0216			; ----------- 
0216			; 
0216			; With current bank 
0216			;  
0216			; Get block number to write 
0216			; Write physical blocks starting at start block from buffer 
0216			  
0216			storage_write_block: 
0216				; TODO bank selection 
0216			 
0216				; for each of the physical blocks read it into the buffer 
0216 06 40			ld b, STORE_BLOCK_PHY 
0218			 
0218				if DEBUG_STORESE 
0218					DMARK "SWB" 
0218 f5				push af  
0219 3a 2d 02			ld a, (.dmark)  
021c 32 7a ee			ld (debug_mark),a  
021f 3a 2e 02			ld a, (.dmark+1)  
0222 32 7b ee			ld (debug_mark+1),a  
0225 3a 2f 02			ld a, (.dmark+2)  
0228 32 7c ee			ld (debug_mark+2),a  
022b 18 03			jr .pastdmark  
022d ..			.dmark: db "SWB"  
0230 f1			.pastdmark: pop af  
0231			endm  
# End of macro DMARK
0231			 
0231					;push af 
0231					;ld a, 'W' 
0231					;ld (debug_mark),a 
0231					;pop af 
0231					CALLMONITOR 
0231 cd 86 12			call break_point_state  
0234				endm  
# End of macro CALLMONITOR
0234				endif 
0234			 
0234			; might not be working 
0234			;	call se_writepage 
0234			 
0234			;	ret 
0234			; 
0234			 
0234			 
0234			 
0234			.wl1:    
0234			 
0234				; read physical block at hl into de 
0234			        ; increment hl and de to next read position on exit 
0234			 
0234 e5				push hl 
0235 d5				push de	 
0236 c5				push bc 
0237 1a				ld a,(de) 
0238				;if DEBUG_STORESE 
0238			;		push af 
0238			;		ld a, 'W' 
0238			;		ld (debug_mark),a 
0238			;		pop af 
0238			;		CALLMONITOR 
0238			;	endif 
0238 cd af 01			call se_writebyte 
023b			;	call delay250ms 
023b 00				nop 
023c 00				nop 
023d 00				nop 
023e			;	if DEBUG_STORESE 
023e			;		push af 
023e			;		ld a, 'w' 
023e			;		ld (debug_mark),a 
023e			;		pop af 
023e			;		CALLMONITOR 
023e			;	endif 
023e c1				pop bc 
023f d1				pop de 
0240 e1				pop hl 
0241 23				inc hl 
0242 13				inc de 
0243			 
0243			 
0243 10 ef			djnz .wl1 
0245			 
0245				if DEBUG_STORESE 
0245					DMARK "SW2" 
0245 f5				push af  
0246 3a 5a 02			ld a, (.dmark)  
0249 32 7a ee			ld (debug_mark),a  
024c 3a 5b 02			ld a, (.dmark+1)  
024f 32 7b ee			ld (debug_mark+1),a  
0252 3a 5c 02			ld a, (.dmark+2)  
0255 32 7c ee			ld (debug_mark+2),a  
0258 18 03			jr .pastdmark  
025a ..			.dmark: db "SW2"  
025d f1			.pastdmark: pop af  
025e			endm  
# End of macro DMARK
025e			 
025e					;push af 
025e					;ld a, 'W' 
025e					;ld (debug_mark),a 
025e					;pop af 
025e					CALLMONITOR 
025e cd 86 12			call break_point_state  
0261				endm  
# End of macro CALLMONITOR
0261				endif 
0261 c9				ret	 
0262			 
0262			; Init bank 
0262			; --------- 
0262			; 
0262			; With current bank 
0262			; 
0262			; Setup block 0 config 
0262			;     Set 0 file id counter 
0262			;     Set formatted byte pattern 
0262			;     Zero out bank label 
0262			;      
0262			; For every logical block write 0-1 byte as null 
0262			 
0262			storage_get_block_0: 
0262			 
0262				; TODO check presence 
0262			 
0262				; get block 0 config 
0262			 
0262 21 00 00			ld hl, 0 
0265 11 65 eb			ld de, store_page 
0268 cd b1 01			call storage_read_block 
026b			 
026b				if DEBUG_STORESE 
026b					DMARK "SB0" 
026b f5				push af  
026c 3a 80 02			ld a, (.dmark)  
026f 32 7a ee			ld (debug_mark),a  
0272 3a 81 02			ld a, (.dmark+1)  
0275 32 7b ee			ld (debug_mark+1),a  
0278 3a 82 02			ld a, (.dmark+2)  
027b 32 7c ee			ld (debug_mark+2),a  
027e 18 03			jr .pastdmark  
0280 ..			.dmark: db "SB0"  
0283 f1			.pastdmark: pop af  
0284			endm  
# End of macro DMARK
0284 11 65 eb				ld de, store_page 
0287			;		push af 
0287			;		ld a, 'i' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287					CALLMONITOR 
0287 cd 86 12			call break_point_state  
028a				endm  
# End of macro CALLMONITOR
028a				endif 
028a			 
028a				; is this area formatted? 
028a			 
028a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
028a 2a 66 eb			ld hl, (store_page+1) 
028d 3e 80			ld a,0x80 
028f bd				cp l 
0290 20 22			jr nz, .ininotformatted 
0292				; do a double check 
0292 3e 27			ld a, 0x27 
0294 bc				cp h 
0295 20 1d			jr nz, .ininotformatted 
0297			 
0297				; formatted then 
0297			 
0297				if DEBUG_STORESE 
0297					DMARK "SB1" 
0297 f5				push af  
0298 3a ac 02			ld a, (.dmark)  
029b 32 7a ee			ld (debug_mark),a  
029e 3a ad 02			ld a, (.dmark+1)  
02a1 32 7b ee			ld (debug_mark+1),a  
02a4 3a ae 02			ld a, (.dmark+2)  
02a7 32 7c ee			ld (debug_mark+2),a  
02aa 18 03			jr .pastdmark  
02ac ..			.dmark: db "SB1"  
02af f1			.pastdmark: pop af  
02b0			endm  
# End of macro DMARK
02b0					;push af 
02b0					;ld a, 'I' 
02b0					;ld (debug_mark),a 
02b0					;pop af 
02b0					CALLMONITOR 
02b0 cd 86 12			call break_point_state  
02b3				endm  
# End of macro CALLMONITOR
02b3				endif 
02b3 c9				ret 
02b4			 
02b4			.ininotformatted: 
02b4				; bank not formatted so poke various bits to make sure 
02b4			 
02b4				if DEBUG_STORESE 
02b4					DMARK "SB2" 
02b4 f5				push af  
02b5 3a c9 02			ld a, (.dmark)  
02b8 32 7a ee			ld (debug_mark),a  
02bb 3a ca 02			ld a, (.dmark+1)  
02be 32 7b ee			ld (debug_mark+1),a  
02c1 3a cb 02			ld a, (.dmark+2)  
02c4 32 7c ee			ld (debug_mark+2),a  
02c7 18 03			jr .pastdmark  
02c9 ..			.dmark: db "SB2"  
02cc f1			.pastdmark: pop af  
02cd			endm  
# End of macro DMARK
02cd					;push af 
02cd					;ld a, 'f' 
02cd					;ld (debug_mark),a 
02cd					;pop af 
02cd					CALLMONITOR 
02cd cd 86 12			call break_point_state  
02d0				endm  
# End of macro CALLMONITOR
02d0				endif 
02d0			 
02d0 21 65 eb			ld hl, store_page 
02d3 3e 00			ld a, 0 
02d5				 
02d5 77				ld (hl),a   ; reset file counter 
02d6			 
02d6 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02d9 22 66 eb		 	ld (store_page+1), hl	 
02dc			 
02dc				; set default label 
02dc			 
02dc 21 71 03			ld hl, .defaultbanklabl 
02df 11 68 eb		 	ld de, store_page+3 
02e2 01 0f 00			ld bc, 15 
02e5 ed b0			ldir 
02e7			 
02e7				; save default page 0 
02e7			 
02e7 21 00 00			ld hl, 0 
02ea 11 65 eb			ld de, store_page 
02ed				if DEBUG_STORESE 
02ed					DMARK "SB3" 
02ed f5				push af  
02ee 3a 02 03			ld a, (.dmark)  
02f1 32 7a ee			ld (debug_mark),a  
02f4 3a 03 03			ld a, (.dmark+1)  
02f7 32 7b ee			ld (debug_mark+1),a  
02fa 3a 04 03			ld a, (.dmark+2)  
02fd 32 7c ee			ld (debug_mark+2),a  
0300 18 03			jr .pastdmark  
0302 ..			.dmark: db "SB3"  
0305 f1			.pastdmark: pop af  
0306			endm  
# End of macro DMARK
0306			;		push af 
0306			;		ld a, 'F' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306					CALLMONITOR 
0306 cd 86 12			call break_point_state  
0309				endm  
# End of macro CALLMONITOR
0309				endif 
0309 cd 16 02			call storage_write_block 
030c				if DEBUG_STORESE 
030c					DMARK "SB4" 
030c f5				push af  
030d 3a 21 03			ld a, (.dmark)  
0310 32 7a ee			ld (debug_mark),a  
0313 3a 22 03			ld a, (.dmark+1)  
0316 32 7b ee			ld (debug_mark+1),a  
0319 3a 23 03			ld a, (.dmark+2)  
031c 32 7c ee			ld (debug_mark+2),a  
031f 18 03			jr .pastdmark  
0321 ..			.dmark: db "SB4"  
0324 f1			.pastdmark: pop af  
0325			endm  
# End of macro DMARK
0325			;		push af 
0325			;		ld a, '>' 
0325			;		ld (debug_mark),a 
0325			;		pop af 
0325					CALLMONITOR 
0325 cd 86 12			call break_point_state  
0328				endm  
# End of macro CALLMONITOR
0328				endif 
0328			 
0328 00				nop 
0329 00				nop 
032a 00				nop 
032b			 
032b				; now set 0 in every page to mark as a free block 
032b			 
032b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
032d 21 40 00			ld hl, STORE_BLOCK_PHY 
0330			 
0330 3e 00		.setmark1:   	ld a,0 
0332 e5					push hl 
0333 c5					push bc 
0334 cd af 01				call se_writebyte 
0337 3e 0a			ld a, 10 
0339 cd c7 08			call aDelayInMS 
033c 23				inc hl 
033d cd af 01				call se_writebyte 
0340 3e 0a			ld a, 10 
0342 cd c7 08			call aDelayInMS 
0345 2b				dec hl 
0346 c1					pop bc 
0347 e1					pop hl 
0348 3e 40				ld a, STORE_BLOCK_PHY 
034a cd c2 0a				call addatohl 
034d 10 e1				djnz .setmark1 
034f			 
034f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0351 3e 00		.setmark2:   	ld a,0 
0353 e5					push hl 
0354 c5					push bc 
0355 cd af 01				call se_writebyte 
0358 3e 0a			ld a, 10 
035a cd c7 08			call aDelayInMS 
035d 23				inc hl 
035e cd af 01				call se_writebyte 
0361 3e 0a			ld a, 10 
0363 cd c7 08			call aDelayInMS 
0366 2b				dec hl 
0367 c1					pop bc 
0368 e1					pop hl 
0369 3e 40				ld a, STORE_BLOCK_PHY 
036b cd c2 0a				call addatohl 
036e 10 e1				djnz .setmark2 
0370			 
0370					 
0370			 
0370			 
0370 c9				ret 
0371			 
0371			 
0371			 
0371			 
0371 .. 00		.defaultbanklabl:   db "BankLabel",0 
037b			 
037b			 
037b			 
037b			; Label Bank 
037b			; ---------- 
037b			; 
037b			; With current bank 
037b			; Read block 0 
037b			; Set label 
037b			; Write block 0 
037b			 
037b			; label str pointer in hl 
037b			 
037b			storage_label:     
037b			 
037b				if DEBUG_STORESE 
037b					DMARK "LBL" 
037b f5				push af  
037c 3a 90 03			ld a, (.dmark)  
037f 32 7a ee			ld (debug_mark),a  
0382 3a 91 03			ld a, (.dmark+1)  
0385 32 7b ee			ld (debug_mark+1),a  
0388 3a 92 03			ld a, (.dmark+2)  
038b 32 7c ee			ld (debug_mark+2),a  
038e 18 03			jr .pastdmark  
0390 ..			.dmark: db "LBL"  
0393 f1			.pastdmark: pop af  
0394			endm  
# End of macro DMARK
0394					CALLMONITOR 
0394 cd 86 12			call break_point_state  
0397				endm  
# End of macro CALLMONITOR
0397				endif 
0397			 
0397 e5				push hl 
0398			 
0398 cd 62 02			call storage_get_block_0 
039b			 
039b				; set default label 
039b			 
039b e1				pop hl 
039c			 
039c 11 68 eb		 	ld de, store_page+3 
039f 01 0f 00			ld bc, 15 
03a2				if DEBUG_STORESE 
03a2					DMARK "LB3" 
03a2 f5				push af  
03a3 3a b7 03			ld a, (.dmark)  
03a6 32 7a ee			ld (debug_mark),a  
03a9 3a b8 03			ld a, (.dmark+1)  
03ac 32 7b ee			ld (debug_mark+1),a  
03af 3a b9 03			ld a, (.dmark+2)  
03b2 32 7c ee			ld (debug_mark+2),a  
03b5 18 03			jr .pastdmark  
03b7 ..			.dmark: db "LB3"  
03ba f1			.pastdmark: pop af  
03bb			endm  
# End of macro DMARK
03bb					CALLMONITOR 
03bb cd 86 12			call break_point_state  
03be				endm  
# End of macro CALLMONITOR
03be				endif 
03be ed b0			ldir 
03c0				; save default page 0 
03c0			 
03c0 21 00 00			ld hl, 0 
03c3 11 65 eb			ld de, store_page 
03c6				if DEBUG_STORESE 
03c6					DMARK "LBW" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 7a ee			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 7b ee			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 7c ee			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "LBW"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df					CALLMONITOR 
03df cd 86 12			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2 cd 16 02			call storage_write_block 
03e5			 
03e5 c9				ret 
03e6			 
03e6			 
03e6			 
03e6			; Read Block 0 - Config 
03e6			; --------------------- 
03e6			; 
03e6			; With current bank 
03e6			; Call presence test 
03e6			;    If not present format/init bank  
03e6			; Read block 0  
03e6			;  
03e6			 
03e6			 
03e6			; Dir 
03e6			; --- 
03e6			; 
03e6			; With current bank 
03e6			; Load Block 0 Config 
03e6			; Get max file id number 
03e6			; For each logical block 
03e6			;    Read block read byte 2 
03e6			;      if first block of file 
03e6			;         Display file name 
03e6			;         Display type flags for file 
03e6			;        
03e6			 
03e6			; moving to words as this requires stack control 
03e6			 
03e6			 
03e6			; Delete File 
03e6			; ----------- 
03e6			; 
03e6			; With current bank 
03e6			; 
03e6			; Load Block 0 Config 
03e6			; Get max file id number 
03e6			; For each logical block 
03e6			;    Read block file id 
03e6			;      If first block of file and dont have file id 
03e6			;         if file to delete 
03e6			;         Save file id 
03e6			;         Null file id 
03e6			;         Write this block back 
03e6			;      If file id is one saved 
03e6			;         Null file id 
03e6			;         Write this block back 
03e6			 
03e6			storage_erase: 
03e6			 
03e6				; hl contains the file id 
03e6			 
03e6 5d				ld e, l 
03e7 16 00			ld d, 0 
03e9 21 40 00			ld hl, STORE_BLOCK_PHY 
03ec					if DEBUG_FORTH_WORDS 
03ec						DMARK "ERA" 
03ec f5				push af  
03ed 3a 01 04			ld a, (.dmark)  
03f0 32 7a ee			ld (debug_mark),a  
03f3 3a 02 04			ld a, (.dmark+1)  
03f6 32 7b ee			ld (debug_mark+1),a  
03f9 3a 03 04			ld a, (.dmark+2)  
03fc 32 7c ee			ld (debug_mark+2),a  
03ff 18 03			jr .pastdmark  
0401 ..			.dmark: db "ERA"  
0404 f1			.pastdmark: pop af  
0405			endm  
# End of macro DMARK
0405						CALLMONITOR 
0405 cd 86 12			call break_point_state  
0408				endm  
# End of macro CALLMONITOR
0408					endif 
0408 cd c7 04			call storage_findnextid 
040b			 
040b e5				push hl 
040c			 
040c				; TODO check file not found 
040c			 
040c 11 65 eb			ld de, store_page 
040f cd b1 01			call storage_read_block 
0412			 
0412					if DEBUG_FORTH_WORDS 
0412						DMARK "ER1" 
0412 f5				push af  
0413 3a 27 04			ld a, (.dmark)  
0416 32 7a ee			ld (debug_mark),a  
0419 3a 28 04			ld a, (.dmark+1)  
041c 32 7b ee			ld (debug_mark+1),a  
041f 3a 29 04			ld a, (.dmark+2)  
0422 32 7c ee			ld (debug_mark+2),a  
0425 18 03			jr .pastdmark  
0427 ..			.dmark: db "ER1"  
042a f1			.pastdmark: pop af  
042b			endm  
# End of macro DMARK
042b						CALLMONITOR 
042b cd 86 12			call break_point_state  
042e				endm  
# End of macro CALLMONITOR
042e					endif 
042e 3a 65 eb			ld a, (store_page)	; get file id 
0431 32 5e eb			ld (store_tmpid), a 
0434			 
0434 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
0437 32 5d eb			ld (store_tmpext), a 
043a			 
043a				; wipe file header 
043a			 
043a e1				pop hl 
043b 3e 00			ld a, 0 
043d 32 65 eb			ld (store_page), a 
0440 32 66 eb			ld (store_page+1),a 
0443 11 65 eb			ld de, store_page 
0446					if DEBUG_FORTH_WORDS 
0446						DMARK "ER2" 
0446 f5				push af  
0447 3a 5b 04			ld a, (.dmark)  
044a 32 7a ee			ld (debug_mark),a  
044d 3a 5c 04			ld a, (.dmark+1)  
0450 32 7b ee			ld (debug_mark+1),a  
0453 3a 5d 04			ld a, (.dmark+2)  
0456 32 7c ee			ld (debug_mark+2),a  
0459 18 03			jr .pastdmark  
045b ..			.dmark: db "ER2"  
045e f1			.pastdmark: pop af  
045f			endm  
# End of macro DMARK
045f						CALLMONITOR 
045f cd 86 12			call break_point_state  
0462				endm  
# End of macro CALLMONITOR
0462					endif 
0462 cd 16 02			call storage_write_block 
0465			 
0465			 
0465				; wipe file extents 
0465			 
0465 3a 5d eb			ld a, (store_tmpext) 
0468 47				ld b, a 
0469			 
0469			.eraext:	  
0469 c5				push bc 
046a			 
046a 21 40 00			ld hl, STORE_BLOCK_PHY 
046d 3a 5e eb			ld a,(store_tmpid) 
0470 5f				ld e, a 
0471 50				ld d, b	 
0472					if DEBUG_FORTH_WORDS 
0472						DMARK "ER3" 
0472 f5				push af  
0473 3a 87 04			ld a, (.dmark)  
0476 32 7a ee			ld (debug_mark),a  
0479 3a 88 04			ld a, (.dmark+1)  
047c 32 7b ee			ld (debug_mark+1),a  
047f 3a 89 04			ld a, (.dmark+2)  
0482 32 7c ee			ld (debug_mark+2),a  
0485 18 03			jr .pastdmark  
0487 ..			.dmark: db "ER3"  
048a f1			.pastdmark: pop af  
048b			endm  
# End of macro DMARK
048b						CALLMONITOR 
048b cd 86 12			call break_point_state  
048e				endm  
# End of macro CALLMONITOR
048e					endif 
048e cd c7 04			call storage_findnextid 
0491			 
0491 e5				push hl 
0492 11 65 eb			ld de, store_page 
0495 cd b1 01			call storage_read_block 
0498			 
0498				; free block	 
0498			 
0498 3e 00			ld a, 0 
049a 32 65 eb			ld (store_page), a 
049d 32 66 eb			ld (store_page+1),a 
04a0 11 65 eb			ld de, store_page 
04a3 e1				pop hl 
04a4					if DEBUG_FORTH_WORDS 
04a4						DMARK "ER4" 
04a4 f5				push af  
04a5 3a b9 04			ld a, (.dmark)  
04a8 32 7a ee			ld (debug_mark),a  
04ab 3a ba 04			ld a, (.dmark+1)  
04ae 32 7b ee			ld (debug_mark+1),a  
04b1 3a bb 04			ld a, (.dmark+2)  
04b4 32 7c ee			ld (debug_mark+2),a  
04b7 18 03			jr .pastdmark  
04b9 ..			.dmark: db "ER4"  
04bc f1			.pastdmark: pop af  
04bd			endm  
# End of macro DMARK
04bd						CALLMONITOR 
04bd cd 86 12			call break_point_state  
04c0				endm  
# End of macro CALLMONITOR
04c0					endif 
04c0 cd 16 02			call storage_write_block 
04c3			 
04c3 c1				pop bc 
04c4 10 a3			djnz .eraext 
04c6			 
04c6 c9				ret 
04c7			 
04c7			 
04c7			; Find Free Block 
04c7			; --------------- 
04c7			; 
04c7			; With current bank 
04c7			;  
04c7			; From given starting logical block 
04c7			;    Read block  
04c7			;    If no file id 
04c7			;         Return block id 
04c7			 
04c7			 
04c7			; hl starting page number 
04c7			; hl contains free page number or zero if no pages free 
04c7			; e contains the file id to locate 
04c7			; d contains the block number 
04c7			 
04c7			; TODO change to find file id and use zero for free block 
04c7			 
04c7			storage_findnextid: 
04c7			 
04c7				; now locate first 0 page to mark as a free block 
04c7			 
04c7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04c9			;	ld hl, STORE_BLOCK_PHY 
04c9			 
04c9					if DEBUG_FORTH_WORDS 
04c9					DMARK "FNI" 
04c9 f5				push af  
04ca 3a de 04			ld a, (.dmark)  
04cd 32 7a ee			ld (debug_mark),a  
04d0 3a df 04			ld a, (.dmark+1)  
04d3 32 7b ee			ld (debug_mark+1),a  
04d6 3a e0 04			ld a, (.dmark+2)  
04d9 32 7c ee			ld (debug_mark+2),a  
04dc 18 03			jr .pastdmark  
04de ..			.dmark: db "FNI"  
04e1 f1			.pastdmark: pop af  
04e2			endm  
# End of macro DMARK
04e2						CALLMONITOR 
04e2 cd 86 12			call break_point_state  
04e5				endm  
# End of macro CALLMONITOR
04e5					endif 
04e5			.ff1:   	 
04e5 e5					push hl 
04e6 c5					push bc 
04e7 d5					push de 
04e8 cd ae 01				call se_readbyte 
04eb 5f					ld e,a 
04ec 23					inc hl 
04ed cd ae 01				call se_readbyte 
04f0 57					ld d, a 
04f1 e1					pop hl 
04f2 e5					push hl 
04f3 cd e0 0a				call cmp16 
04f6 28 49				jr z, .fffound 
04f8			 
04f8 d1					pop de 
04f9 c1					pop bc 
04fa e1					pop hl 
04fb			 
04fb					; is found? 
04fb					;cp e 
04fb					;ret z 
04fb			 
04fb 3e 40				ld a, STORE_BLOCK_PHY 
04fd cd c2 0a				call addatohl 
0500 10 e3				djnz .ff1 
0502			 
0502 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0504			.ff2:   	 
0504			 
0504 e5					push hl 
0505 c5					push bc 
0506 d5					push de 
0507 cd ae 01				call se_readbyte 
050a 5f					ld e,a 
050b 23					inc hl 
050c cd ae 01				call se_readbyte 
050f 57					ld d, a 
0510			 
0510 e1					pop hl 
0511 e5					push hl 
0512 cd e0 0a				call cmp16 
0515 28 2a				jr z, .fffound 
0517			 
0517 d1					pop de 
0518 c1					pop bc 
0519 e1					pop hl 
051a					; is found? 
051a					;cp e 
051a					;ret z 
051a			 
051a 3e 40				ld a, STORE_BLOCK_PHY 
051c cd c2 0a				call addatohl 
051f 10 e3				djnz .ff2 
0521			 
0521			 
0521					if DEBUG_FORTH_WORDS 
0521					DMARK "FN-" 
0521 f5				push af  
0522 3a 36 05			ld a, (.dmark)  
0525 32 7a ee			ld (debug_mark),a  
0528 3a 37 05			ld a, (.dmark+1)  
052b 32 7b ee			ld (debug_mark+1),a  
052e 3a 38 05			ld a, (.dmark+2)  
0531 32 7c ee			ld (debug_mark+2),a  
0534 18 03			jr .pastdmark  
0536 ..			.dmark: db "FN-"  
0539 f1			.pastdmark: pop af  
053a			endm  
# End of macro DMARK
053a					;	push af 
053a					;	ld a, 'n' 
053a					;	ld (debug_mark),a 
053a					;	pop af 
053a						CALLMONITOR 
053a cd 86 12			call break_point_state  
053d				endm  
# End of macro CALLMONITOR
053d					endif 
053d				; no free marks! 
053d 21 00 00				ld hl, 0 
0540 c9				ret 
0541			.fffound: 
0541				 
0541			 
0541 d1					pop de 
0542 c1					pop bc 
0543 e1					pop hl 
0544					if DEBUG_FORTH_WORDS 
0544					DMARK "FNF" 
0544 f5				push af  
0545 3a 59 05			ld a, (.dmark)  
0548 32 7a ee			ld (debug_mark),a  
054b 3a 5a 05			ld a, (.dmark+1)  
054e 32 7b ee			ld (debug_mark+1),a  
0551 3a 5b 05			ld a, (.dmark+2)  
0554 32 7c ee			ld (debug_mark+2),a  
0557 18 03			jr .pastdmark  
0559 ..			.dmark: db "FNF"  
055c f1			.pastdmark: pop af  
055d			endm  
# End of macro DMARK
055d					;	push af 
055d					;	ld a, 'n' 
055d					;	ld (debug_mark),a 
055d					;	pop af 
055d						CALLMONITOR 
055d cd 86 12			call break_point_state  
0560				endm  
# End of macro CALLMONITOR
0560					endif 
0560 c9				ret 
0561			 
0561			 
0561			 
0561			; Free Space 
0561			; ---------- 
0561			; 
0561			; With current bank 
0561			; 
0561			; Set block count to zero 
0561			; Starting with first logical block 
0561			;      Find free block  
0561			;      If block id given, increment block count 
0561			; 
0561			;  
0561			 
0561			 
0561			; hl contains count of free blocks 
0561			 
0561			storage_freeblocks: 
0561			 
0561				; now locate first 0 page to mark as a free block 
0561			 
0561 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0563 21 40 00			ld hl, STORE_BLOCK_PHY 
0566 11 00 00			ld de, 0 
0569			 
0569			.fb1:   	 
0569 e5					push hl 
056a c5					push bc 
056b d5					push de 
056c cd ae 01				call se_readbyte 
056f d1					pop de 
0570 c1					pop bc 
0571 e1					pop hl 
0572			 
0572					; is free? 
0572 fe 00				cp 0 
0574 20 01				jr nz, .ff1cont 
0576 13					inc de 
0577			 
0577			.ff1cont: 
0577			 
0577			 
0577 3e 40				ld a, STORE_BLOCK_PHY 
0579 cd c2 0a				call addatohl 
057c 10 eb				djnz .fb1 
057e			 
057e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0580			.fb2:   	 
0580 e5					push hl 
0581 c5					push bc 
0582 d5					push de 
0583 cd ae 01				call se_readbyte 
0586 d1					pop de 
0587 c1					pop bc 
0588 e1					pop hl 
0589			 
0589					; is free? 
0589 fe 00				cp 0 
058b 20 01				jr nz, .ff2cont 
058d 13					inc de 
058e			 
058e			.ff2cont: 
058e			 
058e 3e 40				ld a, STORE_BLOCK_PHY 
0590 cd c2 0a				call addatohl 
0593 10 eb				djnz .fb2 
0595			 
0595 eb				ex de, hl 
0596 c9				ret 
0597			 
0597			; Get File ID 
0597			; ----------- 
0597			; 
0597			; With current bank 
0597			;  
0597			; Load Block 0 Config 
0597			; Get max file id number 
0597			; For each logical block 
0597			;    Read block file id 
0597			;      If first block of file and dont have file id 
0597			;         if file get id and exit 
0597			 
0597			 
0597			 
0597			 
0597			; Create File 
0597			; ----------- 
0597			; 
0597			; With current bank  
0597			; Load Block 0 Config 
0597			; Get max file id number 
0597			; Increment file id number 
0597			; Save Config 
0597			; Find free block 
0597			; Set buffer with file name and file id 
0597			; Write buffer to free block  
0597			 
0597			 
0597			; hl point to file name 
0597			; hl returns file id 
0597			 
0597			; file format: 
0597			; byte 0 - file id 
0597			; byte 1 - extent number 
0597			; byte 2-> data 
0597			 
0597			; format for extent number 0: 
0597			; 
0597			; byte 0 - file id 
0597			; byte 1 - extent 0 
0597			; byte 2 - extent count 
0597			; byte 3 -> file name and meta data 
0597			 
0597			 
0597			storage_create: 
0597				if DEBUG_STORESE 
0597					DMARK "SCR" 
0597 f5				push af  
0598 3a ac 05			ld a, (.dmark)  
059b 32 7a ee			ld (debug_mark),a  
059e 3a ad 05			ld a, (.dmark+1)  
05a1 32 7b ee			ld (debug_mark+1),a  
05a4 3a ae 05			ld a, (.dmark+2)  
05a7 32 7c ee			ld (debug_mark+2),a  
05aa 18 03			jr .pastdmark  
05ac ..			.dmark: db "SCR"  
05af f1			.pastdmark: pop af  
05b0			endm  
# End of macro DMARK
05b0					CALLMONITOR 
05b0 cd 86 12			call break_point_state  
05b3				endm  
# End of macro CALLMONITOR
05b3				endif 
05b3			 
05b3 e5				push hl		; save file name pointer 
05b4			 
05b4 cd 62 02			call storage_get_block_0 
05b7			 
05b7 3a 65 eb			ld a,(store_page)	; get current file id 
05ba 3c				inc a 
05bb 32 65 eb			ld (store_page),a 
05be				 
05be 32 5e eb			ld (store_tmpid),a			; save id 
05c1			 
05c1 21 00 00			ld hl, 0 
05c4 11 65 eb			ld de, store_page 
05c7				if DEBUG_STORESE 
05c7					DMARK "SCw" 
05c7 f5				push af  
05c8 3a dc 05			ld a, (.dmark)  
05cb 32 7a ee			ld (debug_mark),a  
05ce 3a dd 05			ld a, (.dmark+1)  
05d1 32 7b ee			ld (debug_mark+1),a  
05d4 3a de 05			ld a, (.dmark+2)  
05d7 32 7c ee			ld (debug_mark+2),a  
05da 18 03			jr .pastdmark  
05dc ..			.dmark: db "SCw"  
05df f1			.pastdmark: pop af  
05e0			endm  
# End of macro DMARK
05e0					CALLMONITOR 
05e0 cd 86 12			call break_point_state  
05e3				endm  
# End of macro CALLMONITOR
05e3				endif 
05e3 cd 16 02			call storage_write_block	 ; save update 
05e6			 
05e6				if DEBUG_STORESE 
05e6 11 65 eb				ld de, store_page 
05e9					DMARK "SCC" 
05e9 f5				push af  
05ea 3a fe 05			ld a, (.dmark)  
05ed 32 7a ee			ld (debug_mark),a  
05f0 3a ff 05			ld a, (.dmark+1)  
05f3 32 7b ee			ld (debug_mark+1),a  
05f6 3a 00 06			ld a, (.dmark+2)  
05f9 32 7c ee			ld (debug_mark+2),a  
05fc 18 03			jr .pastdmark  
05fe ..			.dmark: db "SCC"  
0601 f1			.pastdmark: pop af  
0602			endm  
# End of macro DMARK
0602					CALLMONITOR 
0602 cd 86 12			call break_point_state  
0605				endm  
# End of macro CALLMONITOR
0605				endif 
0605				;  
0605				 
0605 21 40 00			ld hl, STORE_BLOCK_PHY 
0608 11 00 00			ld de, 0 
060b cd c7 04			call storage_findnextid 
060e			 
060e 22 63 eb			ld (store_tmppageid), hl    ; save page to use  
0611			 
0611				; TODO detect 0 = no spare blocks 
0611			 
0611				; hl now contains the free page to use for the file header page 
0611			 
0611				if DEBUG_STORESE 
0611				DMARK "SCF" 
0611 f5				push af  
0612 3a 26 06			ld a, (.dmark)  
0615 32 7a ee			ld (debug_mark),a  
0618 3a 27 06			ld a, (.dmark+1)  
061b 32 7b ee			ld (debug_mark+1),a  
061e 3a 28 06			ld a, (.dmark+2)  
0621 32 7c ee			ld (debug_mark+2),a  
0624 18 03			jr .pastdmark  
0626 ..			.dmark: db "SCF"  
0629 f1			.pastdmark: pop af  
062a			endm  
# End of macro DMARK
062a					CALLMONITOR 
062a cd 86 12			call break_point_state  
062d				endm  
# End of macro CALLMONITOR
062d				endif 
062d			 
062d 22 63 eb			ld (store_tmppageid), hl 
0630				 
0630 3a 5e eb			ld a,(store_tmpid)    ; get file id 
0633			;	ld a, (store_filecache)			; save to cache 
0633			 
0633 32 65 eb			ld (store_page),a    ; set page id 
0636 3e 00			ld a, 0			 ; extent 0 is file header 
0638 32 66 eb			ld (store_page+1), a   ; set file extent 
063b			 
063b 32 67 eb			ld (store_page+2), a   ; extent count for the file 
063e			 
063e			;	inc hl 		; init block 0 of file 
063e			;	inc hl   		; skip file and extent id 
063e			 ;       ld a, 0 
063e			;	ld (hl),a 
063e			;	ld a, (store_filecache+1)  	; save to cache 
063e			 
063e			;	inc hl    ; file name 
063e				 
063e				 
063e 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
0641				if DEBUG_STORESE 
0641					DMARK "SCc" 
0641 f5				push af  
0642 3a 56 06			ld a, (.dmark)  
0645 32 7a ee			ld (debug_mark),a  
0648 3a 57 06			ld a, (.dmark+1)  
064b 32 7b ee			ld (debug_mark+1),a  
064e 3a 58 06			ld a, (.dmark+2)  
0651 32 7c ee			ld (debug_mark+2),a  
0654 18 03			jr .pastdmark  
0656 ..			.dmark: db "SCc"  
0659 f1			.pastdmark: pop af  
065a			endm  
# End of macro DMARK
065a					CALLMONITOR 
065a cd 86 12			call break_point_state  
065d				endm  
# End of macro CALLMONITOR
065d				endif 
065d e1				pop hl    ; get zero term string 
065e e5				push hl 
065f 3e 00			ld a, 0 
0661 cd 2b 0f			call strlent 
0664 23				inc hl   ; cover zero term 
0665 06 00			ld b,0 
0667 4d				ld c,l 
0668 e1				pop hl 
0669				;ex de, hl 
0669				if DEBUG_STORESE 
0669					DMARK "SCa" 
0669 f5				push af  
066a 3a 7e 06			ld a, (.dmark)  
066d 32 7a ee			ld (debug_mark),a  
0670 3a 7f 06			ld a, (.dmark+1)  
0673 32 7b ee			ld (debug_mark+1),a  
0676 3a 80 06			ld a, (.dmark+2)  
0679 32 7c ee			ld (debug_mark+2),a  
067c 18 03			jr .pastdmark  
067e ..			.dmark: db "SCa"  
0681 f1			.pastdmark: pop af  
0682			endm  
# End of macro DMARK
0682					;push af 
0682					;ld a, 'a' 
0682					;ld (debug_mark),a 
0682					;pop af 
0682					CALLMONITOR 
0682 cd 86 12			call break_point_state  
0685				endm  
# End of macro CALLMONITOR
0685				endif 
0685 ed b0			ldir    ; copy zero term string 
0687				if DEBUG_STORESE 
0687					DMARK "SCA" 
0687 f5				push af  
0688 3a 9c 06			ld a, (.dmark)  
068b 32 7a ee			ld (debug_mark),a  
068e 3a 9d 06			ld a, (.dmark+1)  
0691 32 7b ee			ld (debug_mark+1),a  
0694 3a 9e 06			ld a, (.dmark+2)  
0697 32 7c ee			ld (debug_mark+2),a  
069a 18 03			jr .pastdmark  
069c ..			.dmark: db "SCA"  
069f f1			.pastdmark: pop af  
06a0			endm  
# End of macro DMARK
06a0					CALLMONITOR 
06a0 cd 86 12			call break_point_state  
06a3				endm  
# End of macro CALLMONITOR
06a3				endif 
06a3			 
06a3				; write file header page 
06a3			 
06a3 2a 63 eb			ld hl,(store_tmppageid) 
06a6 11 65 eb			ld de, store_page 
06a9				if DEBUG_STORESE 
06a9					DMARK "SCb" 
06a9 f5				push af  
06aa 3a be 06			ld a, (.dmark)  
06ad 32 7a ee			ld (debug_mark),a  
06b0 3a bf 06			ld a, (.dmark+1)  
06b3 32 7b ee			ld (debug_mark+1),a  
06b6 3a c0 06			ld a, (.dmark+2)  
06b9 32 7c ee			ld (debug_mark+2),a  
06bc 18 03			jr .pastdmark  
06be ..			.dmark: db "SCb"  
06c1 f1			.pastdmark: pop af  
06c2			endm  
# End of macro DMARK
06c2					;push af 
06c2					;ld a, 'b' 
06c2					;ld (debug_mark),a 
06c2					;pop af 
06c2					CALLMONITOR 
06c2 cd 86 12			call break_point_state  
06c5				endm  
# End of macro CALLMONITOR
06c5				endif 
06c5 cd 16 02			call storage_write_block 
06c8			 
06c8 3a 5e eb			ld a, (store_tmpid) 
06cb 6f				ld l, a 
06cc 26 00			ld h,0 
06ce				if DEBUG_STORESE 
06ce					DMARK "SCz" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 7a ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 7b ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 7c ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCz"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd 86 12			call break_point_state  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea c9				ret 
06eb				 
06eb			 
06eb			 
06eb			; 
06eb			; Read File 
06eb			; 
06eb			; h - file id to locate 
06eb			; l - extent to locate 
06eb			; de - pointer to string to read into 
06eb			; 
06eb			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
06eb			storage_read: 
06eb d5				push de 
06ec			 
06ec			; TODO BUG the above push is it popped before the RET Z? 
06ec			 
06ec			; TODO how to handle multiple part blocks 
06ec			 
06ec				; locate file extent to read 
06ec			 
06ec 5c				ld e, h 
06ed 55				ld d, l 
06ee 21 40 00			ld hl, STORE_BLOCK_PHY 
06f1				if DEBUG_STORESE 
06f1					DMARK "SRE" 
06f1 f5				push af  
06f2 3a 06 07			ld a, (.dmark)  
06f5 32 7a ee			ld (debug_mark),a  
06f8 3a 07 07			ld a, (.dmark+1)  
06fb 32 7b ee			ld (debug_mark+1),a  
06fe 3a 08 07			ld a, (.dmark+2)  
0701 32 7c ee			ld (debug_mark+2),a  
0704 18 03			jr .pastdmark  
0706 ..			.dmark: db "SRE"  
0709 f1			.pastdmark: pop af  
070a			endm  
# End of macro DMARK
070a					CALLMONITOR 
070a cd 86 12			call break_point_state  
070d				endm  
# End of macro CALLMONITOR
070d				endif 
070d cd c7 04			call storage_findnextid 
0710			 
0710				if DEBUG_STORESE 
0710					DMARK "SRf" 
0710 f5				push af  
0711 3a 25 07			ld a, (.dmark)  
0714 32 7a ee			ld (debug_mark),a  
0717 3a 26 07			ld a, (.dmark+1)  
071a 32 7b ee			ld (debug_mark+1),a  
071d 3a 27 07			ld a, (.dmark+2)  
0720 32 7c ee			ld (debug_mark+2),a  
0723 18 03			jr .pastdmark  
0725 ..			.dmark: db "SRf"  
0728 f1			.pastdmark: pop af  
0729			endm  
# End of macro DMARK
0729					CALLMONITOR 
0729 cd 86 12			call break_point_state  
072c				endm  
# End of macro CALLMONITOR
072c				endif 
072c cd eb 0a			call ishlzero 
072f			;	ld a, l 
072f			;	add h 
072f			;	cp 0 
072f c8				ret z			; block not found so EOF 
0730			 
0730				; hl contains page number to load 
0730 d1				pop de   ; get storage 
0731 d5				push de 
0732				if DEBUG_STORESE 
0732					DMARK "SRg" 
0732 f5				push af  
0733 3a 47 07			ld a, (.dmark)  
0736 32 7a ee			ld (debug_mark),a  
0739 3a 48 07			ld a, (.dmark+1)  
073c 32 7b ee			ld (debug_mark+1),a  
073f 3a 49 07			ld a, (.dmark+2)  
0742 32 7c ee			ld (debug_mark+2),a  
0745 18 03			jr .pastdmark  
0747 ..			.dmark: db "SRg"  
074a f1			.pastdmark: pop af  
074b			endm  
# End of macro DMARK
074b					CALLMONITOR 
074b cd 86 12			call break_point_state  
074e				endm  
# End of macro CALLMONITOR
074e				endif 
074e cd b1 01			call storage_read_block 
0751			 
0751			 
0751			; TODO if block has no zeros then need to read next block  
0751			 
0751			 
0751					 
0751 e1				pop hl 		 ; return start of data to show as not EOF 
0752 23				inc hl   ; past file id 
0753 23				inc hl   ; past ext 
0754				if DEBUG_STORESE 
0754					DMARK "SRe" 
0754 f5				push af  
0755 3a 69 07			ld a, (.dmark)  
0758 32 7a ee			ld (debug_mark),a  
075b 3a 6a 07			ld a, (.dmark+1)  
075e 32 7b ee			ld (debug_mark+1),a  
0761 3a 6b 07			ld a, (.dmark+2)  
0764 32 7c ee			ld (debug_mark+2),a  
0767 18 03			jr .pastdmark  
0769 ..			.dmark: db "SRe"  
076c f1			.pastdmark: pop af  
076d			endm  
# End of macro DMARK
076d					CALLMONITOR 
076d cd 86 12			call break_point_state  
0770				endm  
# End of macro CALLMONITOR
0770				endif 
0770 c9					ret 
0771			 
0771			 
0771			 
0771			; 
0771			; Append File 
0771			; 
0771			; hl - file id to locate 
0771			; de - pointer to (multi block) string to write 
0771			 
0771			 
0771			storage_append: 
0771				; hl -  file id to append to 
0771				; de - string to append 
0771			 
0771 d5				push de 
0772				 
0772				if DEBUG_STORESE 
0772					DMARK "AP1" 
0772 f5				push af  
0773 3a 87 07			ld a, (.dmark)  
0776 32 7a ee			ld (debug_mark),a  
0779 3a 88 07			ld a, (.dmark+1)  
077c 32 7b ee			ld (debug_mark+1),a  
077f 3a 89 07			ld a, (.dmark+2)  
0782 32 7c ee			ld (debug_mark+2),a  
0785 18 03			jr .pastdmark  
0787 ..			.dmark: db "AP1"  
078a f1			.pastdmark: pop af  
078b			endm  
# End of macro DMARK
078b					CALLMONITOR 
078b cd 86 12			call break_point_state  
078e				endm  
# End of macro CALLMONITOR
078e				endif 
078e			 
078e 7d				ld a, l 
078f 32 5e eb			ld (store_tmpid), a 
0792			 
0792				; get file header  
0792			 
0792 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0794 3a 5e eb			ld a, (store_tmpid) 
0797 5f				ld e, a 
0798			 
0798 21 40 00				ld hl, STORE_BLOCK_PHY 
079b cd c7 04				call storage_findnextid 
079e			 
079e 22 63 eb			ld (store_tmppageid), hl 
07a1			 
07a1				; TODO handle file id not found 
07a1			 
07a1				if DEBUG_STORESE 
07a1					DMARK "AP2" 
07a1 f5				push af  
07a2 3a b6 07			ld a, (.dmark)  
07a5 32 7a ee			ld (debug_mark),a  
07a8 3a b7 07			ld a, (.dmark+1)  
07ab 32 7b ee			ld (debug_mark+1),a  
07ae 3a b8 07			ld a, (.dmark+2)  
07b1 32 7c ee			ld (debug_mark+2),a  
07b4 18 03			jr .pastdmark  
07b6 ..			.dmark: db "AP2"  
07b9 f1			.pastdmark: pop af  
07ba			endm  
# End of macro DMARK
07ba					CALLMONITOR 
07ba cd 86 12			call break_point_state  
07bd				endm  
# End of macro CALLMONITOR
07bd				endif 
07bd			 
07bd				; update file extent count 
07bd			 
07bd 11 65 eb			ld de, store_page 
07c0			 
07c0 cd b1 01			call storage_read_block 
07c3			 
07c3				if DEBUG_STORESE 
07c3					DMARK "AP3" 
07c3 f5				push af  
07c4 3a d8 07			ld a, (.dmark)  
07c7 32 7a ee			ld (debug_mark),a  
07ca 3a d9 07			ld a, (.dmark+1)  
07cd 32 7b ee			ld (debug_mark+1),a  
07d0 3a da 07			ld a, (.dmark+2)  
07d3 32 7c ee			ld (debug_mark+2),a  
07d6 18 03			jr .pastdmark  
07d8 ..			.dmark: db "AP3"  
07db f1			.pastdmark: pop af  
07dc			endm  
# End of macro DMARK
07dc					CALLMONITOR 
07dc cd 86 12			call break_point_state  
07df				endm  
# End of macro CALLMONITOR
07df				endif 
07df			;	ld (store_tmppageid), hl 
07df			 
07df 3a 67 eb			ld a, (store_page+2) 
07e2 3c				inc a 
07e3 32 67 eb			ld (store_page+2), a 
07e6 32 5d eb			ld (store_tmpext), a 
07e9				 
07e9				if DEBUG_STORESE 
07e9					DMARK "AP3" 
07e9 f5				push af  
07ea 3a fe 07			ld a, (.dmark)  
07ed 32 7a ee			ld (debug_mark),a  
07f0 3a ff 07			ld a, (.dmark+1)  
07f3 32 7b ee			ld (debug_mark+1),a  
07f6 3a 00 08			ld a, (.dmark+2)  
07f9 32 7c ee			ld (debug_mark+2),a  
07fc 18 03			jr .pastdmark  
07fe ..			.dmark: db "AP3"  
0801 f1			.pastdmark: pop af  
0802			endm  
# End of macro DMARK
0802					CALLMONITOR 
0802 cd 86 12			call break_point_state  
0805				endm  
# End of macro CALLMONITOR
0805				endif 
0805 2a 63 eb			ld hl, (store_tmppageid) 
0808 11 65 eb			ld de, store_page 
080b cd 16 02			call storage_write_block 
080e			 
080e				; find free block 
080e			 
080e 11 00 00			ld de, 0			 ; file extent to locate 
0811			 
0811 21 40 00				ld hl, STORE_BLOCK_PHY 
0814 cd c7 04				call storage_findnextid 
0817			 
0817					; TODO handle no space left 
0817					 
0817 22 63 eb				ld (store_tmppageid), hl 
081a			 
081a				if DEBUG_STORESE 
081a					DMARK "AP4" 
081a f5				push af  
081b 3a 2f 08			ld a, (.dmark)  
081e 32 7a ee			ld (debug_mark),a  
0821 3a 30 08			ld a, (.dmark+1)  
0824 32 7b ee			ld (debug_mark+1),a  
0827 3a 31 08			ld a, (.dmark+2)  
082a 32 7c ee			ld (debug_mark+2),a  
082d 18 03			jr .pastdmark  
082f ..			.dmark: db "AP4"  
0832 f1			.pastdmark: pop af  
0833			endm  
# End of macro DMARK
0833					CALLMONITOR 
0833 cd 86 12			call break_point_state  
0836				endm  
# End of macro CALLMONITOR
0836				endif 
0836					; init the buffer with zeros so we can id if the buffer is full or not 
0836			 
0836 e5					push hl 
0837 c5					push bc 
0838			 
0838 21 65 eb				ld hl, store_page 
083b 06 40				ld b, STORE_BLOCK_PHY 
083d 3e 00				ld a, 0 
083f 77			.zeroblock:	ld (hl), a 
0840 23					inc hl 
0841 10 fc				djnz .zeroblock 
0843			 
0843 c1					pop bc 
0844 e1					pop hl 
0845			 
0845					; construct block 
0845			 
0845 3a 5e eb				ld a, (store_tmpid) 
0848 32 65 eb				ld (store_page), a   ; file id 
084b 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
084e 32 66 eb				ld (store_page+1), a 
0851			 
0851 e1					pop hl    ; get string to write 
0852 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0854 11 67 eb				ld de, store_page+2 
0857			 
0857				if DEBUG_STORESE 
0857					DMARK "AP5" 
0857 f5				push af  
0858 3a 6c 08			ld a, (.dmark)  
085b 32 7a ee			ld (debug_mark),a  
085e 3a 6d 08			ld a, (.dmark+1)  
0861 32 7b ee			ld (debug_mark+1),a  
0864 3a 6e 08			ld a, (.dmark+2)  
0867 32 7c ee			ld (debug_mark+2),a  
086a 18 03			jr .pastdmark  
086c ..			.dmark: db "AP5"  
086f f1			.pastdmark: pop af  
0870			endm  
# End of macro DMARK
0870					CALLMONITOR 
0870 cd 86 12			call break_point_state  
0873				endm  
# End of macro CALLMONITOR
0873				endif 
0873			 
0873			 
0873			 
0873					; fill buffer with data until end of string or full block 
0873			 
0873 7e			.appd:		ld a, (hl) 
0874 12					ld (de), a 
0875 fe 00				cp 0 
0877 28 04				jr z, .appdone 
0879 23					inc hl 
087a 13					inc de 
087b 10 f6				djnz .appd 
087d			 
087d e5			.appdone:	push hl		 	; save current source in case we need to go around again 
087e f5					push af   		; save last byte dumped 
087f			 
087f			 
087f 2a 63 eb			ld hl, (store_tmppageid) 
0882 11 65 eb			ld de, store_page 
0885				if DEBUG_STORESE 
0885					DMARK "AP6" 
0885 f5				push af  
0886 3a 9a 08			ld a, (.dmark)  
0889 32 7a ee			ld (debug_mark),a  
088c 3a 9b 08			ld a, (.dmark+1)  
088f 32 7b ee			ld (debug_mark+1),a  
0892 3a 9c 08			ld a, (.dmark+2)  
0895 32 7c ee			ld (debug_mark+2),a  
0898 18 03			jr .pastdmark  
089a ..			.dmark: db "AP6"  
089d f1			.pastdmark: pop af  
089e			endm  
# End of macro DMARK
089e					CALLMONITOR 
089e cd 86 12			call break_point_state  
08a1				endm  
# End of macro CALLMONITOR
08a1				endif 
08a1 cd 16 02				call storage_write_block 
08a4			 
08a4			 
08a4				; was that a full block of data written? 
08a4				; any more to write out? 
08a4			 
08a4				; if yes then set vars and jump to start of function again 
08a4			 
08a4 f1					pop af 
08a5 d1					pop de 
08a6			 
08a6 fe 00				cp 0		 ; no, string was fully written 
08a8 c8					ret z 
08a9			 
08a9					; setup vars for next cycle 
08a9			 
08a9 3a 5e eb				ld a, (store_tmpid) 
08ac 6f					ld l, a 
08ad 26 00				ld h, 0 
08af			 
08af c3 71 07			 	jp storage_append	 ; yes, need to write out some more 
08b2			 
08b2			 
08b2			 
08b2			 
08b2			 
08b2			 
08b2			 
08b2			if DEBUG_STORECF 
08b2			storageput:	 
08b2					ret 
08b2			storageread: 
08b2					ld hl, store_page 
08b2					ld b, 200 
08b2					ld a,0 
08b2			.src:		ld (hl),a 
08b2					inc hl 
08b2					djnz .src 
08b2					 
08b2			 
08b2					ld de, 0 
08b2					ld bc, 1 
08b2					ld hl, store_page 
08b2					call cfRead 
08b2			 
08b2				call cfGetError 
08b2				ld hl,scratch 
08b2				call hexout 
08b2				ld hl, scratch+2 
08b2				ld a, 0 
08b2				ld (hl),a 
08b2				ld de, scratch 
08b2				ld a,display_row_1 
08b2				call str_at_display 
08b2				call update_display 
08b2			 
08b2					ld hl, store_page 
08b2					ld (os_cur_ptr),hl 
08b2			 
08b2					ret 
08b2			endif 
08b2			 
08b2			 
08b2			; Clear out the main buffer store (used to remove junk before writing a new block) 
08b2			 
08b2			storage_clear_page: 
08b2 e5				push hl 
08b3 d5				push de 
08b4 c5				push bc 
08b5 21 65 eb			ld hl, store_page 
08b8 3e 00			ld a, 0 
08ba 77				ld (hl), a 
08bb			 
08bb 11 66 eb			ld de, store_page+1 
08be 01 40 00			ld bc, STORE_BLOCK_PHY 
08c1			 
08c1 ed b0			ldir 
08c3				 
08c3 c1				pop bc 
08c4 d1				pop de 
08c5 e1				pop hl 
08c6 c9				ret 
08c7			 
08c7			; eof 
# End of file firmware_storage.asm
08c7			  
08c7			; support routines for above hardware abstraction layer  
08c7			  
08c7			include "firmware_general.asm"        ; general support functions  
08c7			 
08c7			 
08c7			 
08c7			; Delay loops 
08c7			 
08c7			 
08c7			 
08c7			aDelayInMS: 
08c7 c5				push bc 
08c8 47				ld b,a 
08c9			msdelay: 
08c9 c5				push bc 
08ca				 
08ca			 
08ca 01 41 00			ld bc,041h 
08cd cd e5 08			call delayloop 
08d0 c1				pop bc 
08d1 05				dec b 
08d2 20 f5			jr nz,msdelay 
08d4			 
08d4			;if CPU_CLOCK_8MHZ 
08d4			;msdelay8: 
08d4			;	push bc 
08d4			;	 
08d4			; 
08d4			;	ld bc,041h 
08d4			;	call delayloop 
08d4			;	pop bc 
08d4			;	dec b 
08d4			;	jr nz,msdelay8 
08d4			;endif 
08d4			 
08d4			 
08d4 c1				pop bc 
08d5 c9				ret 
08d6			 
08d6			 
08d6			delay250ms: 
08d6				;push de 
08d6 01 00 40			ld bc, 04000h 
08d9 c3 e5 08			jp delayloop 
08dc			delay500ms: 
08dc				;push de 
08dc 01 00 80			ld bc, 08000h 
08df c3 e5 08			jp delayloop 
08e2			delay1s: 
08e2				;push bc 
08e2			   ; Clobbers A, d and e 
08e2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
08e5			delayloop: 
08e5 c5			    push bc 
08e6			 
08e6			if BASE_CPM 
08e6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
08e9			.cpmloop: 
08e9 c5				push bc 
08ea			 
08ea			endif 
08ea			 
08ea			 
08ea			 
08ea			delayloopi: 
08ea			;	push bc 
08ea			;.dl: 
08ea cb 47		    bit     0,a    	; 8 
08ec cb 47		    bit     0,a    	; 8 
08ee cb 47		    bit     0,a    	; 8 
08f0 e6 ff		    and     255  	; 7 
08f2 0b			    dec     bc      	; 6 
08f3 79			    ld      a,c     	; 4 
08f4 b0			    or      b     	; 4 
08f5 c2 ea 08		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
08f8			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
08f8				;pop de 
08f8			;pop bc 
08f8			 
08f8			if BASE_CPM 
08f8 c1				pop bc 
08f9				 
08f9 0b			    dec     bc      	; 6 
08fa 79			    ld      a,c     	; 4 
08fb b0			    or      b     	; 4 
08fc c2 e9 08		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
08ff				 
08ff			 
08ff			endif 
08ff			;if CPU_CLOCK_8MHZ 
08ff			;    pop bc 
08ff			;    push bc 
08ff			;.dl8: 
08ff			;    bit     0,a    	; 8 
08ff			;    bit     0,a    	; 8 
08ff			;    bit     0,a    	; 8 
08ff			;    and     255  	; 7 
08ff			;    dec     bc      	; 6 
08ff			;    ld      a,c     	; 4 
08ff			;    or      b     	; 4 
08ff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
08ff			;endif 
08ff			 
08ff			;if CPU_CLOCK_10MHZ 
08ff			;    pop bc 
08ff			;    push bc 
08ff			;.dl8: 
08ff			;    bit     0,a    	; 8 
08ff			;    bit     0,a    	; 8 
08ff			;    bit     0,a    	; 8 
08ff			;    and     255  	; 7 
08ff			;    dec     bc      	; 6 
08ff			;    ld      a,c     	; 4 
08ff			;    or      b     	; 4 
08ff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
08ff			;endif 
08ff c1			    pop bc 
0900			 
0900 c9				ret 
0901			 
0901			 
0901			 
0901			; eof 
# End of file firmware_general.asm
0901			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0901			; display routines that use the physical hardware abstraction layer 
0901			 
0901			 
0901			; TODO windowing? 
0901			 
0901			; TODO scroll line up 
0901			 
0901			scroll_up: 
0901			 
0901 e5				push hl 
0902 d5				push de 
0903 c5				push bc 
0904			 
0904				; get frame buffer  
0904			 
0904 2a db eb			ld hl, (display_fb_active) 
0907 e5				push hl    ; future de destination 
0908			 
0908 11 28 00			ld  de, display_cols 
090b 19				add hl, de 
090c			 
090c d1				pop de 
090d			 
090d				;ex de, hl 
090d 01 9f 00			ld bc, display_fb_len -1  
0910			;if DEBUG_FORTH_WORDS 
0910			;	DMARK "SCL" 
0910			;	CALLMONITOR 
0910			;endif	 
0910 ed b0			ldir 
0912			 
0912				; wipe bottom row 
0912			 
0912			 
0912 2a db eb			ld hl, (display_fb_active) 
0915 11 a0 00			ld de, display_cols*display_rows 
0918 19				add hl, de 
0919 06 28			ld b, display_cols 
091b 3e 20			ld a, ' ' 
091d			.scwipe: 
091d 77				ld (hl), a 
091e 2b				dec hl 
091f 10 fc			djnz .scwipe 
0921			 
0921				;pop hl 
0921			 
0921 c1				pop bc 
0922 d1				pop de 
0923 e1				pop hl 
0924			 
0924 c9				ret 
0925			 
0925			 
0925			scroll_upo: 
0925 11 00 00			ld de, display_row_1 
0928 21 28 00		 	ld hl, display_row_2 
092b 01 28 00			ld bc, display_cols 
092e ed b0			ldir 
0930 11 28 00			ld de, display_row_2 
0933 21 50 00		 	ld hl, display_row_3 
0936 01 28 00			ld bc, display_cols 
0939 ed b0			ldir 
093b 11 50 00			ld de, display_row_3 
093e 21 78 00		 	ld hl, display_row_4 
0941 01 28 00			ld bc, display_cols 
0944 ed b0			ldir 
0946			 
0946			; TODO clear row 4 
0946			 
0946 c9				ret 
0947				 
0947			scroll_down: 
0947 11 78 00			ld de, display_row_4 
094a 21 50 00		 	ld hl, display_row_3 
094d 01 28 00			ld bc, display_cols 
0950 ed b0			ldir 
0952 11 50 00			ld de, display_row_3 
0955 21 28 00		 	ld hl, display_row_2 
0958 01 28 00			ld bc, display_cols 
095b ed b0			ldir 
095d 11 28 00			ld de, display_row_2 
0960 21 00 00		 	ld hl, display_row_1 
0963 01 28 00			ld bc, display_cols 
0966 ed b0			ldir 
0968			; TODO clear row 1 
0968 c9				ret 
0969			 
0969			 
0969			 
0969			 
0969			 
0969			; clear active frame buffer 
0969			 
0969			clear_display: 
0969 3e 20			ld a, ' ' 
096b c3 6e 09			jp fill_display 
096e			 
096e			; fill active frame buffer with a char in A 
096e			 
096e			fill_display: 
096e 06 a0			ld b,display_fb_len 
0970 2a db eb			ld hl, (display_fb_active) 
0973 77			.fd1:	ld (hl),a 
0974 23				inc hl 
0975 10 fc			djnz .fd1 
0977 23				inc hl 
0978 3e 00			ld a,0 
097a 77				ld (hl),a 
097b			 
097b			 
097b c9				ret 
097c			; Write string (DE) at pos (A) to active frame buffer 
097c			 
097c 2a db eb		str_at_display:    ld hl,(display_fb_active) 
097f 06 00					ld b,0 
0981 4f					ld c,a 
0982 09					add hl,bc 
0983 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0984 b7			            OR   A              ;Null terminator? 
0985 c8			            RET  Z              ;Yes, so finished 
0986 77					ld (hl),a 
0987 23				inc hl 
0988 13			            INC  DE             ;Point to next character 
0989 18 f8		            JR   .sad1     ;Repeat 
098b c9					ret 
098c			 
098c			; using current frame buffer write to physical display 
098c			 
098c			update_display: 
098c e5				push hl 
098d 2a db eb			ld hl, (display_fb_active) 
0990 cd 37 55			call write_display 
0993 e1				pop hl 
0994 c9				ret 
0995			 
0995			; TODO scrolling 
0995			 
0995			 
0995			; move cursor right one char 
0995			cursor_right: 
0995			 
0995				; TODO shift right 
0995				; TODO if beyond max col 
0995				; TODO       cursor_next_line 
0995			 
0995 c9				ret 
0996			 
0996			 
0996			cursor_next_line: 
0996				; TODO first char 
0996				; TODO line down 
0996				; TODO if past last row 
0996				; TODO    scroll up 
0996			 
0996 c9				ret 
0997			 
0997			cursor_left: 
0997				; TODO shift left 
0997				; TODO if beyond left  
0997				; TODO     cursor prev line 
0997				 
0997 c9				ret 
0998			 
0998			cursor_prev_line: 
0998				; TODO last char 
0998				; TODO line up 
0998				; TODO if past first row 
0998				; TODO   scroll down 
0998			 
0998 c9				ret 
0999			 
0999			 
0999			cout: 
0999				; A - char 
0999 c9				ret 
099a			 
099a			; eof 
099a			 
# End of file firmware_display.asm
099a			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
099a			; random number generators 
099a			 
099a			 
099a			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
099a			 
099a			 
099a			;-----> Generate a random number 
099a			; output a=answer 0<=a<=255 
099a			; all registers are preserved except: af 
099a			random: 
099a e5			        push    hl 
099b d5			        push    de 
099c 2a bd eb		        ld      hl,(randData) 
099f ed 5f		        ld      a,r 
09a1 57			        ld      d,a 
09a2 5e			        ld      e,(hl) 
09a3 19			        add     hl,de 
09a4 85			        add     a,l 
09a5 ac			        xor     h 
09a6 22 bd eb		        ld      (randData),hl 
09a9 d1			        pop     de 
09aa e1			        pop     hl 
09ab c9			        ret 
09ac			 
09ac			 
09ac			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
09ac			 
09ac			 
09ac			 
09ac			;------LFSR------ 
09ac			;James Montelongo 
09ac			;optimized by Spencer Putt 
09ac			;out: 
09ac			; a = 8 bit random number 
09ac			RandLFSR: 
09ac 21 c3 eb		        ld hl,LFSRSeed+4 
09af 5e			        ld e,(hl) 
09b0 23			        inc hl 
09b1 56			        ld d,(hl) 
09b2 23			        inc hl 
09b3 4e			        ld c,(hl) 
09b4 23			        inc hl 
09b5 7e			        ld a,(hl) 
09b6 47			        ld b,a 
09b7 cb 13		        rl e  
09b9 cb 12			rl d 
09bb cb 11		        rl c  
09bd 17				rla 
09be cb 13		        rl e  
09c0 cb 12			rl d 
09c2 cb 11		        rl c  
09c4 17				rla 
09c5 cb 13		        rl e  
09c7 cb 12			rl d 
09c9 cb 11		        rl c  
09cb 17				rla 
09cc 67			        ld h,a 
09cd cb 13		        rl e  
09cf cb 12			rl d 
09d1 cb 11		        rl c  
09d3 17				rla 
09d4 a8			        xor b 
09d5 cb 13		        rl e  
09d7 cb 12			rl d 
09d9 ac			        xor h 
09da a9			        xor c 
09db aa			        xor d 
09dc 21 c5 eb		        ld hl,LFSRSeed+6 
09df 11 c6 eb		        ld de,LFSRSeed+7 
09e2 01 07 00		        ld bc,7 
09e5 ed b8		        lddr 
09e7 12			        ld (de),a 
09e8 c9			        ret 
09e9			 
09e9			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
09e9			 
09e9			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
09e9			 
09e9			 
09e9			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
09e9			 
09e9			prng16: 
09e9			;Inputs: 
09e9			;   (seed1) contains a 16-bit seed value 
09e9			;   (seed2) contains a NON-ZERO 16-bit seed value 
09e9			;Outputs: 
09e9			;   HL is the result 
09e9			;   BC is the result of the LCG, so not that great of quality 
09e9			;   DE is preserved 
09e9			;Destroys: 
09e9			;   AF 
09e9			;cycle: 4,294,901,760 (almost 4.3 billion) 
09e9			;160cc 
09e9			;26 bytes 
09e9 2a b7 eb		    ld hl,(seed1) 
09ec 44			    ld b,h 
09ed 4d			    ld c,l 
09ee 29			    add hl,hl 
09ef 29			    add hl,hl 
09f0 2c			    inc l 
09f1 09			    add hl,bc 
09f2 22 b7 eb		    ld (seed1),hl 
09f5 2a b5 eb		    ld hl,(seed2) 
09f8 29			    add hl,hl 
09f9 9f			    sbc a,a 
09fa e6 2d		    and %00101101 
09fc ad			    xor l 
09fd 6f			    ld l,a 
09fe 22 b5 eb		    ld (seed2),hl 
0a01 09			    add hl,bc 
0a02 c9			    ret 
0a03			 
0a03			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0a03			 
0a03			rand32: 
0a03			;Inputs: 
0a03			;   (seed1_0) holds the lower 16 bits of the first seed 
0a03			;   (seed1_1) holds the upper 16 bits of the first seed 
0a03			;   (seed2_0) holds the lower 16 bits of the second seed 
0a03			;   (seed2_1) holds the upper 16 bits of the second seed 
0a03			;   **NOTE: seed2 must be non-zero 
0a03			;Outputs: 
0a03			;   HL is the result 
0a03			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0a03			;Destroys: 
0a03			;   AF 
0a03			;Tested and passes all CAcert tests 
0a03			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0a03			;it has a period of 18,446,744,069,414,584,320 
0a03			;roughly 18.4 quintillion. 
0a03			;LFSR taps: 0,2,6,7  = 11000101 
0a03			;291cc 
0a03			;seed1_0=$+1 
0a03			;    ld hl,12345 
0a03			;seed1_1=$+1 
0a03			;    ld de,6789 
0a03			;    ld b,h 
0a03			;    ld c,l 
0a03			;    add hl,hl \ rl e \ rl d 
0a03			;    add hl,hl \ rl e \ rl d 
0a03			;    inc l 
0a03			;    add hl,bc 
0a03			;    ld (seed1_0),hl 
0a03			;    ld hl,(seed1_1) 
0a03			;    adc hl,de 
0a03			;    ld (seed1_1),hl 
0a03			;    ex de,hl 
0a03			;seed2_0=$+1 
0a03			;    ld hl,9876 
0a03			;seed2_1=$+1 
0a03			;    ld bc,54321 
0a03			;    add hl,hl \ rl c \ rl b 
0a03			;    ld (seed2_1),bc 
0a03			;    sbc a,a 
0a03			;    and %11000101 
0a03			;    xor l 
0a03			;    ld l,a 
0a03			;    ld (seed2_0),hl 
0a03			;    ex de,hl 
0a03			;    add hl,bc 
0a03			;    ret 
0a03			; 
0a03			 
0a03			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0a03			; 20 bytes, 86 cycles (excluding ret) 
0a03			 
0a03			; returns   hl = pseudorandom number 
0a03			; corrupts   a 
0a03			 
0a03			; generates 16-bit pseudorandom numbers with a period of 65535 
0a03			; using the xorshift method: 
0a03			 
0a03			; hl ^= hl << 7 
0a03			; hl ^= hl >> 9 
0a03			; hl ^= hl << 8 
0a03			 
0a03			; some alternative shift triplets which also perform well are: 
0a03			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0a03			 
0a03			;  org 32768 
0a03			 
0a03			xrnd: 
0a03 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
0a06 3e 00		  ld a,0 
0a08 bd			  cp l 
0a09 20 02		  jr nz, .xrnd1 
0a0b 2e 01		  ld l, 1 
0a0d			.xrnd1: 
0a0d			 
0a0d 7c			  ld a,h 
0a0e 1f			  rra 
0a0f 7d			  ld a,l 
0a10 1f			  rra 
0a11 ac			  xor h 
0a12 67			  ld h,a 
0a13 7d			  ld a,l 
0a14 1f			  rra 
0a15 7c			  ld a,h 
0a16 1f			  rra 
0a17 ad			  xor l 
0a18 6f			  ld l,a 
0a19 ac			  xor h 
0a1a 67			  ld h,a 
0a1b			 
0a1b 22 bb eb		  ld (xrandc),hl 
0a1e			 
0a1e c9			  ret 
0a1f			;  
0a1f			 
0a1f			 
0a1f			;;;; int maths 
0a1f			 
0a1f			; https://map.grauw.nl/articles/mult_div_shifts.php 
0a1f			; Divide 16-bit values (with 16-bit result) 
0a1f			; In: Divide BC by divider DE 
0a1f			; Out: BC = result, HL = rest 
0a1f			; 
0a1f			Div16: 
0a1f 21 00 00		    ld hl,0 
0a22 78			    ld a,b 
0a23 06 08		    ld b,8 
0a25			Div16_Loop1: 
0a25 17			    rla 
0a26 ed 6a		    adc hl,hl 
0a28 ed 52		    sbc hl,de 
0a2a 30 01		    jr nc,Div16_NoAdd1 
0a2c 19			    add hl,de 
0a2d			Div16_NoAdd1: 
0a2d 10 f6		    djnz Div16_Loop1 
0a2f 17			    rla 
0a30 2f			    cpl 
0a31 47			    ld b,a 
0a32 79			    ld a,c 
0a33 48			    ld c,b 
0a34 06 08		    ld b,8 
0a36			Div16_Loop2: 
0a36 17			    rla 
0a37 ed 6a		    adc hl,hl 
0a39 ed 52		    sbc hl,de 
0a3b 30 01		    jr nc,Div16_NoAdd2 
0a3d 19			    add hl,de 
0a3e			Div16_NoAdd2: 
0a3e 10 f6		    djnz Div16_Loop2 
0a40 17			    rla 
0a41 2f			    cpl 
0a42 41			    ld b,c 
0a43 4f			    ld c,a 
0a44 c9			ret 
0a45			 
0a45			 
0a45			;http://z80-heaven.wikidot.com/math 
0a45			; 
0a45			;Inputs: 
0a45			;     DE and A are factors 
0a45			;Outputs: 
0a45			;     A is not changed 
0a45			;     B is 0 
0a45			;     C is not changed 
0a45			;     DE is not changed 
0a45			;     HL is the product 
0a45			;Time: 
0a45			;     342+6x 
0a45			; 
0a45			Mult16: 
0a45			 
0a45 06 08		     ld b,8          ;7           7 
0a47 21 00 00		     ld hl,0         ;10         10 
0a4a 29			       add hl,hl     ;11*8       88 
0a4b 07			       rlca          ;4*8        32 
0a4c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0a4e 19			         add hl,de   ;--         -- 
0a4f 10 f9		       djnz $-5      ;13*7+8     99 
0a51 c9			ret 
0a52			 
0a52			; 
0a52			; Square root of 16-bit value 
0a52			; In:  HL = value 
0a52			; Out:  D = result (rounded down) 
0a52			; 
0a52			;Sqr16: 
0a52			;    ld de,#0040 
0a52			;    ld a,l 
0a52			;    ld l,h 
0a52			;    ld h,d 
0a52			;    or a 
0a52			;    ld b,8 
0a52			;Sqr16_Loop: 
0a52			;    sbc hl,de 
0a52			;    jr nc,Sqr16_Skip 
0a52			;    add hl,de 
0a52			;Sqr16_Skip: 
0a52			;    ccf 
0a52			;    rl d 
0a52			;    add a,a 
0a52			;    adc hl,hl 
0a52			;    add a,a 
0a52			;    adc hl,hl 
0a52			;    djnz Sqr16_Loop 
0a52			;    ret 
0a52			; 
0a52			; 
0a52			; Divide 8-bit values 
0a52			; In: Divide E by divider C 
0a52			; Out: A = result, B = rest 
0a52			; 
0a52			Div8: 
0a52 af			    xor a 
0a53 06 08		    ld b,8 
0a55			Div8_Loop: 
0a55 cb 13		    rl e 
0a57 17			    rla 
0a58 91			    sub c 
0a59 30 01		    jr nc,Div8_NoAdd 
0a5b 81			    add a,c 
0a5c			Div8_NoAdd: 
0a5c 10 f7		    djnz Div8_Loop 
0a5e 47			    ld b,a 
0a5f 7b			    ld a,e 
0a60 17			    rla 
0a61 2f			    cpl 
0a62 c9			    ret 
0a63			 
0a63			; 
0a63			; Multiply 8-bit value with a 16-bit value (unrolled) 
0a63			; In: Multiply A with DE 
0a63			; Out: HL = result 
0a63			; 
0a63			Mult12U: 
0a63 2e 00		    ld l,0 
0a65 87			    add a,a 
0a66 30 01		    jr nc,Mult12U_NoAdd0 
0a68 19			    add hl,de 
0a69			Mult12U_NoAdd0: 
0a69 29			    add hl,hl 
0a6a 87			    add a,a 
0a6b 30 01		    jr nc,Mult12U_NoAdd1 
0a6d 19			    add hl,de 
0a6e			Mult12U_NoAdd1: 
0a6e 29			    add hl,hl 
0a6f 87			    add a,a 
0a70 30 01		    jr nc,Mult12U_NoAdd2 
0a72 19			    add hl,de 
0a73			Mult12U_NoAdd2: 
0a73 29			    add hl,hl 
0a74 87			    add a,a 
0a75 30 01		    jr nc,Mult12U_NoAdd3 
0a77 19			    add hl,de 
0a78			Mult12U_NoAdd3: 
0a78 29			    add hl,hl 
0a79 87			    add a,a 
0a7a 30 01		    jr nc,Mult12U_NoAdd4 
0a7c 19			    add hl,de 
0a7d			Mult12U_NoAdd4: 
0a7d 29			    add hl,hl 
0a7e 87			    add a,a 
0a7f 30 01		    jr nc,Mult12U_NoAdd5 
0a81 19			    add hl,de 
0a82			Mult12U_NoAdd5: 
0a82 29			    add hl,hl 
0a83 87			    add a,a 
0a84 30 01		    jr nc,Mult12U_NoAdd6 
0a86 19			    add hl,de 
0a87			Mult12U_NoAdd6: 
0a87 29			    add hl,hl 
0a88 87			    add a,a 
0a89 d0			    ret nc 
0a8a 19			    add hl,de 
0a8b c9			    ret 
0a8c			 
0a8c			; 
0a8c			; Multiply 8-bit value with a 16-bit value (right rotating) 
0a8c			; In: Multiply A with DE 
0a8c			;      Put lowest value in A for most efficient calculation 
0a8c			; Out: HL = result 
0a8c			; 
0a8c			Mult12R: 
0a8c 21 00 00		    ld hl,0 
0a8f			Mult12R_Loop: 
0a8f cb 3f		    srl a 
0a91 30 01		    jr nc,Mult12R_NoAdd 
0a93 19			    add hl,de 
0a94			Mult12R_NoAdd: 
0a94 cb 23		    sla e 
0a96 cb 12		    rl d 
0a98 b7			    or a 
0a99 c2 8f 0a		    jp nz,Mult12R_Loop 
0a9c c9			    ret 
0a9d			 
0a9d			; 
0a9d			; Multiply 16-bit values (with 32-bit result) 
0a9d			; In: Multiply BC with DE 
0a9d			; Out: BCHL = result 
0a9d			; 
0a9d			Mult32: 
0a9d 79			    ld a,c 
0a9e 48			    ld c,b 
0a9f 21 00 00		    ld hl,0 
0aa2 06 10		    ld b,16 
0aa4			Mult32_Loop: 
0aa4 29			    add hl,hl 
0aa5 17			    rla 
0aa6 cb 11		    rl c 
0aa8 30 07		    jr nc,Mult32_NoAdd 
0aaa 19			    add hl,de 
0aab ce 00		    adc a,0 
0aad d2 b1 0a		    jp nc,Mult32_NoAdd 
0ab0 0c			    inc c 
0ab1			Mult32_NoAdd: 
0ab1 10 f1		    djnz Mult32_Loop 
0ab3 41			    ld b,c 
0ab4 4f			    ld c,a 
0ab5 c9			    ret 
0ab6			 
0ab6			 
0ab6			 
0ab6			; 
0ab6			; Multiply 8-bit values 
0ab6			; In:  Multiply H with E 
0ab6			; Out: HL = result 
0ab6			; 
0ab6			Mult8: 
0ab6 16 00		    ld d,0 
0ab8 6a			    ld l,d 
0ab9 06 08		    ld b,8 
0abb			Mult8_Loop: 
0abb 29			    add hl,hl 
0abc 30 01		    jr nc,Mult8_NoAdd 
0abe 19			    add hl,de 
0abf			Mult8_NoAdd: 
0abf 10 fa		    djnz Mult8_Loop 
0ac1 c9			    ret 
0ac2			 
0ac2			 
0ac2			 
0ac2			 
0ac2			 
0ac2			 
0ac2			 
0ac2			 
0ac2			;;http://z80-heaven.wikidot.com/math 
0ac2			;;This divides DE by BC, storing the result in DE, remainder in HL 
0ac2			; 
0ac2			;DE_Div_BC:          ;1281-2x, x is at most 16 
0ac2			;     ld a,16        ;7 
0ac2			;     ld hl,0        ;10 
0ac2			;     jp $+5         ;10 
0ac2			;.DivLoop: 
0ac2			;       add hl,bc    ;-- 
0ac2			;       dec a        ;64 
0ac2			;       jr z,.DivLoopEnd        ;86 
0ac2			; 
0ac2			;       sla e        ;128 
0ac2			;       rl d         ;128 
0ac2			;       adc hl,hl    ;240 
0ac2			;       sbc hl,bc    ;240 
0ac2			;       jr nc,.DivLoop ;23|21 
0ac2			;       inc e        ;-- 
0ac2			;       jp .DivLoop+1 
0ac2			; 
0ac2			;.DivLoopEnd: 
0ac2			 
0ac2			;HL_Div_C: 
0ac2			;Inputs: 
0ac2			;     HL is the numerator 
0ac2			;     C is the denominator 
0ac2			;Outputs: 
0ac2			;     A is the remainder 
0ac2			;     B is 0 
0ac2			;     C is not changed 
0ac2			;     DE is not changed 
0ac2			;     HL is the quotient 
0ac2			; 
0ac2			;       ld b,16 
0ac2			;       xor a 
0ac2			;         add hl,hl 
0ac2			;         rla 
0ac2			;         cp c 
0ac2			;         jr c,$+4 
0ac2			;           inc l 
0ac2			;           sub c 
0ac2			;         djnz $-7 
0ac2			 
0ac2			; https://plutiedev.com/z80-add-8bit-to-16bit 
0ac2			 
0ac2			addatohl: 
0ac2 85			    add   a, l    ; A = A+L 
0ac3 6f			    ld    l, a    ; L = A+L 
0ac4 8c			    adc   a, h    ; A = A+L+H+carry 
0ac5 95			    sub   l       ; A = H+carry 
0ac6 67			    ld    h, a    ; H = H+carry 
0ac7 c9			ret 
0ac8			 
0ac8			addatode: 
0ac8 83			    add   a, e    ; A = A+L 
0ac9 5f			    ld    e, a    ; L = A+L 
0aca 8a			    adc   a, d    ; A = A+L+H+carry 
0acb 93			    sub   e       ; A = H+carry 
0acc 57			    ld    d, a    ; H = H+carry 
0acd c9			ret 
0ace			 
0ace			 
0ace			addatobc: 
0ace 81			    add   a, c    ; A = A+L 
0acf 4f			    ld    c, a    ; L = A+L 
0ad0 88			    adc   a, b    ; A = A+L+H+carry 
0ad1 91			    sub   c       ; A = H+carry 
0ad2 47			    ld    b, a    ; H = H+carry 
0ad3 c9			ret 
0ad4			 
0ad4			subafromhl: 
0ad4			   ; If A=0 do nothing 
0ad4			    ; Otherwise flip A's sign. Since 
0ad4			    ; the upper byte becomes -1, also 
0ad4			    ; substract 1 from H. 
0ad4 ed 44		    neg 
0ad6 ca df 0a		    jp    z, Skip 
0ad9 25			    dec   h 
0ada			     
0ada			    ; Now add the low byte as usual 
0ada			    ; Two's complement takes care of 
0ada			    ; ensuring the result is correct 
0ada 85			    add   a, l 
0adb 6f			    ld    l, a 
0adc 8c			    adc   a, h 
0add 95			    sub   l 
0ade 67			    ld    h, a 
0adf			Skip: 
0adf c9				ret 
0ae0			 
0ae0			 
0ae0			; compare hl and de 
0ae0			; returns:  
0ae0			; if hl = de, z=1, s=0, c0=0 
0ae0			; if hl > de, z=0, s=0, c=0 
0ae0			; if hl < de, z=0, s=1, c=1 
0ae0			cmp16:	 
0ae0 b7				or a 
0ae1 ed 52			sbc hl,de 
0ae3 e0				ret po 
0ae4 7c				ld a,h 
0ae5 1f				rra 
0ae6 ee 40			xor 01000000B 
0ae8 37				scf 
0ae9 8f				adc a,a 
0aea c9				ret 
0aeb			 
0aeb			 
0aeb			; test if hl contains zero   - A is destroyed 
0aeb			 
0aeb			ishlzero:    
0aeb b7				or a     ; reset flags 
0aec 7c				ld a, h 
0aed b5				or l        	 
0aee			 
0aee c9				ret 
0aef			 
0aef			 
0aef			 
0aef			 
0aef			if FORTH_ENABLE_FLOATMATH 
0aef			;include "float/bbcmath.z80" 
0aef			include "float/lpfpcalc.asm" 
0aef			endif 
0aef			 
0aef			 
0aef			; eof 
0aef			 
# End of file firmware_maths.asm
0aef			include "firmware_strings.asm"   ; string handling  
0aef			 
0aef			 
0aef			; TODO string len 
0aef			; input text string, end on cr with zero term 
0aef			; a offset into frame buffer to start prompt 
0aef			; d is max length 
0aef			; e is display size TODO 
0aef			; c is current cursor position 
0aef			; hl is ptr to where string will be stored 
0aef			 
0aef			 
0aef			; TODO check limit of buffer for new inserts 
0aef			; TODO check insert does not push beyond buffer 
0aef			; TODO scroll in a limited display area 
0aef			; TODO scroll whole screen on page wrap 
0aef			 
0aef			 
0aef			; TODO handle KEY_PREVWORD 
0aef			; TODO handle KEY_NEXTWORD 
0aef			; TODO handle KEY_HOME 
0aef			; TODO handle KEY_END 
0aef			; TODO use LCD cursor? 
0aef			 
0aef 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0af2 81					add c 
0af3 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0af6 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
0af9 79					ld a, c 
0afa cd c2 0a				call addatohl 
0afd 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0b00 7a					ld a,d 
0b01 32 75 ee			        ld (input_size), a       ; save length of input area 
0b04 79					ld a, c 
0b05 32 64 ee				ld (input_cursor),a      ; init cursor start position  
0b08 7b					ld a,e 
0b09 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0b0c					 
0b0c					 
0b0c			 
0b0c			;		ld a,(input_ptr) 
0b0c			;		ld (input_under_cursor),a 	; save what is under the cursor 
0b0c			 
0b0c			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0b0c					; init cursor shape if not set by the cin routines 
0b0c 21 d3 eb				ld hl, cursor_shape 
0b0f 3e ff				ld a, 255 
0b11 77					ld (hl), a 
0b12 23					inc hl 
0b13 3e 00				ld a, 0 
0b15 77					ld (hl), a 
0b16			 
0b16 3e 0f				ld a, CUR_BLINK_RATE 
0b18 32 6f ee				ld (input_cur_flash), a 
0b1b 3e 01				ld a, 1 
0b1d 32 6e ee				ld (input_cur_onoff),a 
0b20			 
0b20			;	if DEBUG_INPUT 
0b20			;		push af 
0b20			;		ld a, 'I' 
0b20			;		ld (debug_mark),a 
0b20			;		pop af 
0b20			;		CALLMONITOR 
0b20			;	endif 
0b20			.is1:		; main entry loop 
0b20			 
0b20			 
0b20			 
0b20					; pause 1ms 
0b20			 
0b20 3e 01				ld a, 1 
0b22 cd c7 08				call aDelayInMS 
0b25			 
0b25					; dec flash counter 
0b25 3a 6f ee				ld a, (input_cur_flash) 
0b28 3d					dec a 
0b29 32 6f ee				ld (input_cur_flash), a 
0b2c fe 00				cp 0 
0b2e 20 0d				jr nz, .nochgstate 
0b30			 
0b30			 
0b30					; change state 
0b30 3a 6e ee				ld a,(input_cur_onoff) 
0b33 ed 44				neg 
0b35 32 6e ee				ld (input_cur_onoff),a 
0b38			 
0b38			 
0b38					; reset on change of state 
0b38 3e 0f				ld a, CUR_BLINK_RATE 
0b3a 32 6f ee				ld (input_cur_flash), a 
0b3d			 
0b3d			.nochgstate: 
0b3d					 
0b3d					 
0b3d			 
0b3d					; display cursor  
0b3d			 
0b3d			;		ld hl, (input_start) 
0b3d			;		ld a, (input_cursor) 
0b3d			;		call addatohl 
0b3d			 
0b3d					; get char under cursor and replace with cursor 
0b3d 2a 78 ee		ld hl, (input_ptr) 
0b40			;		ld a, (hl) 
0b40			;		ld (input_under_cursor),a 
0b40			;		ld a, '_' 
0b40			;		ld (hl), a 
0b40			 
0b40					; display string 
0b40			 
0b40 ed 5b 76 ee			ld de, (input_start) 
0b44 3a 73 ee				ld a, (input_at_pos) 
0b47 cd 7c 09				call str_at_display 
0b4a			;	        call update_display 
0b4a			 
0b4a					; find place to put the cursor 
0b4a			;		add h 
0b4a			;		ld l, display_row_1 
0b4a			;		sub l 
0b4a			; (input_at_pos) 
0b4a					;ld c, a 
0b4a			;		ld a, (input_cursor) 
0b4a			;		ld l, (input_at_pos) 
0b4a			;		;ld b, h 
0b4a			;		add l 
0b4a			;		ld (input_at_cursor),a 
0b4a					;ld l,h 
0b4a			 
0b4a			;		ld h, 0 
0b4a			;		ld l,(input_at_pos) 
0b4a			;		ld a, (input_cursor) 
0b4a			;		call addatohl 
0b4a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0b4a			;		call subafromhl 
0b4a			;		ld a,l 
0b4a			;		ld (input_at_cursor), a 
0b4a			 
0b4a				if DEBUG_INPUT 
0b4a					ld a, (hardware_diag) 
0b4a					cp 0 
0b4a					jr z, .skip_input_diag 
0b4a			 
0b4a					ld a,(input_at_pos) 
0b4a					ld hl, LFSRSeed 
0b4a					call hexout 
0b4a					ld a, (input_cursor) 
0b4a					ld hl, LFSRSeed+2 
0b4a					call hexout 
0b4a					ld a,(input_at_cursor) 
0b4a					ld hl, LFSRSeed+4 
0b4a					call hexout 
0b4a			 
0b4a					ld a,(input_cur_onoff) 
0b4a					ld hl, LFSRSeed+6 
0b4a					call hexout 
0b4a			 
0b4a					ld a,(input_cur_flash) 
0b4a					ld hl, LFSRSeed+8 
0b4a					call hexout 
0b4a			 
0b4a					ld a,(input_len) 
0b4a					ld hl, LFSRSeed+10 
0b4a					call hexout 
0b4a					ld hl, LFSRSeed+12 
0b4a					ld a, 0 
0b4a					ld (hl),a 
0b4a					ld a, display_row_4 
0b4a					ld de, LFSRSeed 
0b4a					call str_at_display 
0b4a					.skip_input_diag: 
0b4a				endif 
0b4a			 
0b4a					; decide on if we are showing the cursor this time round 
0b4a			 
0b4a 3a 6e ee				ld a, (input_cur_onoff) 
0b4d fe ff				cp 255 
0b4f 28 13				jr z, .skipcur 
0b51			 
0b51			 
0b51 3a 71 ee				ld a,(input_at_cursor) 
0b54 11 d3 eb				ld de, cursor_shape 
0b57 cd 7c 09				call str_at_display 
0b5a			 
0b5a					; save length of current input string 
0b5a 2a 76 ee				ld hl, (input_start) 
0b5d cd 20 0f				call strlenz 
0b60 7d					ld a,l 
0b61 32 69 ee				ld (input_len),a 
0b64			 
0b64			.skipcur: 
0b64			 
0b64 cd 8c 09			        call update_display 
0b67					 
0b67			 
0b67			 
0b67					; wait 
0b67				 
0b67					; TODO loop without wait to flash the cursor and char under cursor	 
0b67 cd f1 55				call cin    ; _wait 
0b6a			 
0b6a fe 00				cp 0 
0b6c ca 20 0b				jp z, .is1 
0b6f			 
0b6f					; get ptr to char to input into 
0b6f			 
0b6f 4f					ld c,a 
0b70 2a 76 ee				ld hl, (input_start) 
0b73 3a 64 ee				ld a, (input_cursor) 
0b76 cd c2 0a				call addatohl 
0b79 22 78 ee				ld (input_ptr), hl 
0b7c 79					ld a,c 
0b7d			 
0b7d					; replace char under cursor 
0b7d			 
0b7d			;		ld hl, (input_ptr) 
0b7d			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0b7d			;		ld (hl), a 
0b7d			 
0b7d			;	if DEBUG_INPUT 
0b7d			;		push af 
0b7d			;		ld a, 'i' 
0b7d			;		ld (debug_mark),a 
0b7d			;		pop af 
0b7d			;		CALLMONITOR 
0b7d			;	endif 
0b7d fe 0e				cp KEY_HOME 
0b7f 20 0e				jr nz, .iske 
0b81			 
0b81 3a 73 ee				ld a, (input_at_pos) 
0b84 32 71 ee				ld (input_at_cursor),a 
0b87 3e 00				ld a, 0 
0b89 32 64 ee				ld (input_cursor), a 
0b8c c3 20 0b				jp .is1 
0b8f					 
0b8f fe 0f		.iske:		cp KEY_END 
0b91 20 03				jr nz, .isknw 
0b93 c3 20 0b				jp .is1 
0b96			 
0b96 fe 06		.isknw:		cp KEY_NEXTWORD 
0b98 20 1b				jr nz, .iskpw 
0b9a			 
0b9a 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
0b9d 7e					ld a,(hl)	 
0b9e fe 00				cp 0 
0ba0 ca 20 0b				jp z, .is1    ; end of string 
0ba3 fe 20				cp ' ' 
0ba5 ca 20 0b				jp z, .is1    ; end of word 
0ba8 23					inc hl 
0ba9 22 78 ee				ld (input_ptr), hl 
0bac 3a 71 ee				ld a, (input_at_cursor) 
0baf 3c					inc a 
0bb0 32 71 ee				ld (input_at_cursor), a 
0bb3 18 e5				jr .isknwm 
0bb5			 
0bb5 fe 07		.iskpw:		cp KEY_PREVWORD 
0bb7 20 1b				jr nz, .iskl 
0bb9			.iskpwm:	 
0bb9 2a 78 ee				ld hl, (input_ptr) 
0bbc 7e					ld a,(hl)	 
0bbd fe 00				cp 0  
0bbf ca 20 0b				jp z, .is1    ; end of string 
0bc2 fe 20				cp ' ' 
0bc4 ca 20 0b				jp z, .is1    ; end of word 
0bc7 2b					dec hl 
0bc8 22 78 ee				ld (input_ptr), hl 
0bcb 3a 71 ee				ld a, (input_at_cursor) 
0bce 3d					dec a 
0bcf 32 71 ee				ld (input_at_cursor), a 
0bd2 18 e5				jr .iskpwm 
0bd4			 
0bd4			 
0bd4 fe 0b		.iskl:		cp KEY_LEFT 
0bd6 20 27				jr nz, .isk1 
0bd8			 
0bd8 3a 64 ee				ld a, (input_cursor) 
0bdb			 
0bdb fe 00				cp 0 
0bdd ca 20 0b				jp z, .is1 		; at start of line to ignore  
0be0			 
0be0 3d					dec  a 		; TODO check underflow 
0be1 32 64 ee				ld (input_cursor), a 
0be4			 
0be4 2a 78 ee				ld hl, (input_ptr) 
0be7 2b					dec hl 
0be8 22 78 ee				ld (input_ptr), hl 
0beb					 
0beb 3a 71 ee				ld a, (input_at_cursor) 
0bee 3d					dec a 
0bef 32 71 ee				ld (input_at_cursor), a 
0bf2			 
0bf2 3e 01				ld a, 1		; show cursor moving 
0bf4 32 6e ee				ld (input_cur_onoff),a 
0bf7 3e 0f				ld a, CUR_BLINK_RATE 
0bf9 32 6f ee				ld (input_cur_flash), a 
0bfc			 
0bfc c3 20 0b				jp .is1 
0bff			 
0bff fe 0c		.isk1:		cp KEY_RIGHT 
0c01 20 2a				jr nz, .isk2 
0c03			 
0c03 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0c06 5f					ld e,a 
0c07 3a 64 ee				ld a, (input_cursor) 
0c0a bb					cp e 
0c0b ca 20 0b				jp z, .is1		; at the end of string so dont go right 
0c0e			 
0c0e 3c					inc  a 		; TODO check overflow 
0c0f 32 64 ee				ld (input_cursor), a 
0c12			 
0c12 3a 71 ee				ld a, (input_at_cursor) 
0c15 3c					inc a 
0c16 32 71 ee				ld (input_at_cursor), a 
0c19			 
0c19 2a 78 ee				ld hl, (input_ptr) 
0c1c 23					inc hl 
0c1d 22 78 ee				ld (input_ptr), hl 
0c20			 
0c20 3e 01				ld a, 1		; show cursor moving 
0c22 32 6e ee				ld (input_cur_onoff),a 
0c25 3e 0f				ld a, CUR_BLINK_RATE 
0c27 32 6f ee				ld (input_cur_flash), a 
0c2a			 
0c2a c3 20 0b				jp .is1 
0c2d			 
0c2d fe 05		.isk2:		cp KEY_UP 
0c2f			 
0c2f 20 26				jr nz, .isk3 
0c31			 
0c31					; swap last command with the current on 
0c31			 
0c31					; move cursor to start of string 
0c31 2a 76 ee				ld hl, (input_start) 
0c34 22 78 ee				ld (input_ptr), hl 
0c37			 
0c37 3a 73 ee				ld a, (input_at_pos) 
0c3a 32 71 ee				ld (input_at_cursor), a 
0c3d			 
0c3d 3e 00				ld a, 0 
0c3f 32 64 ee				ld (input_cursor), a 
0c42					 
0c42					; swap input and last command buffers 
0c42			 
0c42 21 9c e6				ld hl, os_cli_cmd 
0c45 11 9b e7				ld de, os_last_cmd 
0c48 06 ff				ld b, 255 
0c4a 7e			.swap1:		ld a, (hl) 
0c4b 4f					ld c,a 
0c4c 1a					ld a, (de) 
0c4d 77					ld (hl), a 
0c4e 79					ld a,c 
0c4f 12					ld (de),a 
0c50 23					inc hl 
0c51 13					inc de 
0c52 10 f6				djnz .swap1 
0c54			 
0c54			 
0c54			 
0c54			 
0c54			 
0c54 c3 20 0b				jp .is1 
0c57			 
0c57 fe 08		.isk3:		cp KEY_BS 
0c59 20 3c				jr nz, .isk4 
0c5b			 
0c5b 3a 64 ee				ld a, (input_cursor) 
0c5e			 
0c5e fe 00				cp 0 
0c60 ca 20 0b				jp z, .is1 		; at start of line to ignore  
0c63			 
0c63 3d					dec  a 		; TODO check underflow 
0c64 32 64 ee				ld (input_cursor), a 
0c67			 
0c67					; hl is source 
0c67					; de needs to be source - 1 
0c67			 
0c67			;		ld a, 0 
0c67			;		dec hl 
0c67			;		ld (hl), a 
0c67			 
0c67 2a 78 ee				ld hl, (input_ptr) 
0c6a 2b					dec hl 
0c6b 22 78 ee				ld (input_ptr), hl 
0c6e			 
0c6e					; shift all data 
0c6e			 
0c6e e5					push hl 
0c6f 23					inc hl 
0c70 d1					pop de 
0c71 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0c74 4f					ld c,a 
0c75 06 00				ld b,0 
0c77 ed b0				ldir  
0c79			 
0c79			 
0c79			 
0c79			 
0c79 3a 71 ee				ld a, (input_at_cursor) 
0c7c 3d					dec a 
0c7d 32 71 ee				ld (input_at_cursor), a 
0c80			 
0c80			 
0c80 3e 01				ld a, 1		; show cursor moving 
0c82 32 6e ee				ld (input_cur_onoff),a 
0c85 3e 0f				ld a, CUR_BLINK_RATE 
0c87 32 6f ee				ld (input_cur_flash), a 
0c8a			 
0c8a					; remove char 
0c8a 3a 71 ee				ld a, (input_at_cursor) 
0c8d 3c					inc a 
0c8e 11 18 0d				ld de,.iblank 
0c91 cd 7c 09				call str_at_display 
0c94			 
0c94 c3 20 0b				jp .is1 
0c97			 
0c97 fe 0d		.isk4:		cp KEY_CR 
0c99 28 6c				jr z, .endinput 
0c9b			 
0c9b					; else add the key press to the end 
0c9b			 
0c9b 4f					ld c, a			; save key pressed 
0c9c			 
0c9c 7e					ld a,(hl)		; get what is currently under char 
0c9d			 
0c9d fe 00				cp 0			; we are at the end of the string 
0c9f 20 2f				jr nz, .onchar 
0ca1					 
0ca1					; add a char to the end of the string 
0ca1				 
0ca1 71					ld (hl),c 
0ca2 23					inc hl 
0ca3			;		ld a,' ' 
0ca3			;		ld (hl),a 
0ca3			;		inc hl 
0ca3 3e 00				ld a,0 
0ca5 77					ld (hl),a 
0ca6 2b					dec hl 
0ca7			 
0ca7 3a 64 ee				ld a, (input_cursor) 
0caa 3c					inc a				; TODO check max string length and scroll  
0cab 32 64 ee				ld (input_cursor), a		; inc cursor pos 
0cae							 
0cae 3a 71 ee				ld a, (input_at_cursor) 
0cb1 3c					inc a 
0cb2 32 71 ee				ld (input_at_cursor), a 
0cb5			 
0cb5 2a 78 ee				ld hl, (input_ptr) 
0cb8 23					inc hl 
0cb9 22 78 ee				ld (input_ptr), hl 
0cbc			 
0cbc 2a 78 ee				ld hl, (input_ptr) 
0cbf 23					inc hl 
0cc0 22 78 ee				ld (input_ptr), hl 
0cc3			;	if DEBUG_INPUT 
0cc3			;		push af 
0cc3			;		ld a, '+' 
0cc3			;		ld (debug_mark),a 
0cc3			;		pop af 
0cc3			;		CALLMONITOR 
0cc3			;	endif 
0cc3 3e 01				ld a, 1		; show cursor moving 
0cc5 32 6e ee				ld (input_cur_onoff),a 
0cc8 3e 0f				ld a, CUR_BLINK_RATE 
0cca 32 6f ee				ld (input_cur_flash), a 
0ccd c3 20 0b				jp .is1 
0cd0					 
0cd0			 
0cd0			 
0cd0					; if on a char then insert 
0cd0			.onchar: 
0cd0			 
0cd0					; TODO over flow check: make sure insert does not blow out buffer 
0cd0			 
0cd0					; need to do some maths to use lddr 
0cd0			 
0cd0 e5					push hl   ; save char pos 
0cd1 c5					push bc 
0cd2			 
0cd2 2a 76 ee				ld hl, (input_start) 
0cd5 3a 69 ee				ld a, (input_len) 
0cd8 cd c2 0a				call addatohl  		; end of string 
0cdb 23					inc hl 
0cdc 23					inc hl		; past zero term 
0cdd e5					push hl 
0cde 23					inc hl 
0cdf e5					push hl  
0ce0			 
0ce0								; start and end of lddr set, now how much to move? 
0ce0			 
0ce0							 
0ce0 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ce3 47					ld b,a 
0ce4 3a 69 ee				ld a,(input_len) 
0ce7 5f					ld e,a 
0ce8 90					sub b 
0ce9 3c					inc a		;?? 
0cea 3c					inc a		;?? 
0ceb 3c					inc a		;?? 
0cec			 
0cec 06 00				ld b,0 
0cee 4f					ld c,a 
0cef			 
0cef				if DEBUG_INPUT 
0cef					push af 
0cef					ld a, 'i' 
0cef					ld (debug_mark),a 
0cef					pop af 
0cef			;		CALLMONITOR 
0cef				endif 
0cef d1					pop de 
0cf0 e1					pop hl 
0cf1				if DEBUG_INPUT 
0cf1					push af 
0cf1					ld a, 'I' 
0cf1					ld (debug_mark),a 
0cf1					pop af 
0cf1			;		CALLMONITOR 
0cf1				endif 
0cf1 ed b8				lddr 
0cf3				 
0cf3			 
0cf3			 
0cf3					; TODO have a key for insert/overwrite mode???? 
0cf3 c1					pop bc 
0cf4 e1					pop hl 
0cf5 71					ld (hl), c		; otherwise overwrite current char 
0cf6					 
0cf6			 
0cf6			 
0cf6			 
0cf6 3a 64 ee				ld a, (input_cursor) 
0cf9 3c					inc  a 		; TODO check overflow 
0cfa 32 64 ee				ld (input_cursor), a 
0cfd			 
0cfd 3a 71 ee				ld a, (input_at_cursor) 
0d00 3c					inc a 
0d01 32 71 ee				ld (input_at_cursor), a 
0d04			 
0d04 c3 20 0b				jp .is1 
0d07			 
0d07			.endinput:	; TODO look for end of string 
0d07			 
0d07					; add trailing space for end of token 
0d07			 
0d07 2a 76 ee				ld hl, (input_start) 
0d0a 3a 69 ee				ld a,(input_len) 
0d0d cd c2 0a				call addatohl 
0d10 3e 20				ld a, ' ' 
0d12 77					ld (hl),a 
0d13					; TODO eof of parse marker 
0d13			 
0d13 23					inc hl 
0d14 3e 00				ld a, 0 
0d16 77					ld (hl),a 
0d17			 
0d17			 
0d17 c9					ret 
0d18			 
0d18 .. 00		.iblank: db " ",0 
0d1a			 
0d1a			 
0d1a 32 73 ee		input_str_prev:	ld (input_at_pos), a 
0d1d 22 76 ee				ld (input_start), hl 
0d20 3e 01				ld a,1			; add cursor 
0d22 77					ld (hl),a 
0d23 23					inc hl 
0d24 3e 00				ld a,0 
0d26 77					ld (hl),a 
0d27 22 78 ee				ld (input_ptr), hl 
0d2a 7a					ld a,d 
0d2b 32 75 ee				ld (input_size), a 
0d2e 3e 00				ld a,0 
0d30 32 64 ee				ld (input_cursor),a 
0d33			.instr1:	 
0d33			 
0d33					; TODO do block cursor 
0d33					; TODO switch cursor depending on the modifer key 
0d33			 
0d33					; update cursor shape change on key hold 
0d33			 
0d33 2a 78 ee				ld hl, (input_ptr) 
0d36 2b					dec hl 
0d37 3a d3 eb				ld a,(cursor_shape) 
0d3a 77					ld (hl), a 
0d3b			 
0d3b					; display entered text 
0d3b 3a 73 ee				ld a,(input_at_pos) 
0d3e cd 06 55		            	CALL fLCD_Pos       ;Position cursor to location in A 
0d41 ed 5b 76 ee	            	LD   de, (input_start) 
0d45 cd fb 54		            	CALL fLCD_Str       ;Display string pointed to by DE 
0d48			 
0d48 cd f1 55				call cin 
0d4b fe 00				cp 0 
0d4d 28 e4				jr z, .instr1 
0d4f			 
0d4f					; proecess keyboard controls first 
0d4f			 
0d4f 2a 78 ee				ld hl,(input_ptr) 
0d52			 
0d52 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0d54 28 5a				jr z, .instrcr 
0d56			 
0d56 fe 08				cp KEY_BS 	; back space 
0d58 20 0f				jr nz, .instr2 
0d5a					; process back space 
0d5a			 
0d5a					; TODO stop back space if at start of string 
0d5a 2b					dec hl 
0d5b 2b					dec hl ; to over write cursor 
0d5c 3a d3 eb				ld a,(cursor_shape) 
0d5f					;ld a,0 
0d5f 77					ld (hl),a 
0d60 23					inc hl 
0d61 3e 20				ld a," " 
0d63 77					ld (hl),a 
0d64 22 78 ee				ld (input_ptr),hl 
0d67					 
0d67			 
0d67 18 ca				jr .instr1 
0d69			 
0d69 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0d6b 20 06				jr nz, .instr3 
0d6d 2b					dec hl 
0d6e 22 78 ee				ld (input_ptr),hl 
0d71 18 c0				jr .instr1 
0d73				 
0d73 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0d75 20 06				jr nz, .instr4 
0d77 23					inc hl 
0d78 22 78 ee				ld (input_ptr),hl 
0d7b 18 b6				jr .instr1 
0d7d			 
0d7d fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0d7f 20 06				jr nz, .instr5 
0d81 2b					dec hl 
0d82 22 78 ee				ld (input_ptr),hl 
0d85 18 ac				jr .instr1 
0d87			 
0d87 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0d89 20 06				jr nz, .instr6 
0d8b 2b					dec hl 
0d8c 22 78 ee				ld (input_ptr),hl 
0d8f 18 a2				jr .instr1 
0d91 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0d93 20 0b				jr nz, .instrnew 
0d95			 
0d95 21 75 e3			ld hl, scratch 
0d98 11 9b e7			ld de, os_last_cmd 
0d9b cd b9 0d			call strcpy 
0d9e 18 93				jr .instr1 
0da0			 
0da0			 
0da0			.instrnew:	; no special key pressed to see if we have room to store it 
0da0			 
0da0					; TODO do string size test 
0da0			 
0da0 2b					dec hl ; to over write cursor 
0da1 77					ld (hl),a 
0da2 23					inc hl 
0da3 3a d3 eb				ld a,(cursor_shape) 
0da6 77					ld (hl),a 
0da7 23					inc hl 
0da8 3e 00				ld a,0 
0daa 77					ld (hl),a 
0dab			 
0dab 22 78 ee				ld (input_ptr),hl 
0dae					 
0dae 18 83				jr .instr1 
0db0 2b			.instrcr:	dec hl		; remove cursor 
0db1 3e 20				ld a,' '	; TODO add a trailing space for safety 
0db3 77					ld (hl),a 
0db4 23					inc hl 
0db5 3e 00				ld a,0 
0db7 77					ld (hl),a 
0db8			 
0db8			 
0db8					; if at end of line scroll up    
0db8					; TODO detecting only end of line 4 for scroll up  
0db8			 
0db8					;ld   
0db8			 
0db8 c9					ret 
0db9			 
0db9			 
0db9			; strcpy hl = dest, de source 
0db9			 
0db9 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0dba b7			            OR   A              ;Null terminator? 
0dbb c8			            RET  Z              ;Yes, so finished 
0dbc 1a					ld a,(de) 
0dbd 77					ld (hl),a 
0dbe 13			            INC  DE             ;Point to next character 
0dbf 23					inc hl 
0dc0 18 f7		            JR   strcpy       ;Repeat 
0dc2 c9					ret 
0dc3			 
0dc3			 
0dc3			; TODO string_at  
0dc3			; pass string which starts with lcd offset address and then null term string 
0dc3			 
0dc3			; TODO string to dec 
0dc3			; TODO string to hex 
0dc3			; TODO byte to string hex 
0dc3			; TODO byte to string dec 
0dc3			 
0dc3			 
0dc3			 
0dc3			; from z80uartmonitor 
0dc3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0dc3			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0dc3			; pass hl for where to put the text 
0dc3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0dc3 c5			hexout:	PUSH BC 
0dc4 f5					PUSH AF 
0dc5 47					LD B, A 
0dc6					; Upper nybble 
0dc6 cb 3f				SRL A 
0dc8 cb 3f				SRL A 
0dca cb 3f				SRL A 
0dcc cb 3f				SRL A 
0dce cd de 0d				CALL tohex 
0dd1 77					ld (hl),a 
0dd2 23					inc hl	 
0dd3					 
0dd3					; Lower nybble 
0dd3 78					LD A, B 
0dd4 e6 0f				AND 0FH 
0dd6 cd de 0d				CALL tohex 
0dd9 77					ld (hl),a 
0dda 23					inc hl	 
0ddb					 
0ddb f1					POP AF 
0ddc c1					POP BC 
0ddd c9					RET 
0dde					 
0dde			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0dde			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0dde			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0dde			tohex: 
0dde e5					PUSH HL 
0ddf d5					PUSH DE 
0de0 16 00				LD D, 0 
0de2 5f					LD E, A 
0de3 21 eb 0d				LD HL, .DATA 
0de6 19					ADD HL, DE 
0de7 7e					LD A, (HL) 
0de8 d1					POP DE 
0de9 e1					POP HL 
0dea c9					RET 
0deb			 
0deb			.DATA: 
0deb 30					DEFB	30h	; 0 
0dec 31					DEFB	31h	; 1 
0ded 32					DEFB	32h	; 2 
0dee 33					DEFB	33h	; 3 
0def 34					DEFB	34h	; 4 
0df0 35					DEFB	35h	; 5 
0df1 36					DEFB	36h	; 6 
0df2 37					DEFB	37h	; 7 
0df3 38					DEFB	38h	; 8 
0df4 39					DEFB	39h	; 9 
0df5 41					DEFB	41h	; A 
0df6 42					DEFB	42h	; B 
0df7 43					DEFB	43h	; C 
0df8 44					DEFB	44h	; D 
0df9 45					DEFB	45h	; E 
0dfa 46					DEFB	46h	; F 
0dfb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0dfb			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0dfb			;;    subtract $30, if result > 9 then subtract $7 more 
0dfb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0dfb			atohex: 
0dfb d6 30				SUB $30 
0dfd fe 0a				CP 10 
0dff f8					RET M		; If result negative it was 0-9 so we're done 
0e00 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0e02 c9					RET		 
0e03			 
0e03			 
0e03			 
0e03			 
0e03			; Get 2 ASCII characters as hex byte from pointer in hl 
0e03			 
0e03			BYTERD: 
0e03 16 00			LD	D,00h		;Set up 
0e05 cd 0d 0e			CALL	HEXCON		;Get byte and convert to hex 
0e08 87				ADD	A,A		;First nibble so 
0e09 87				ADD	A,A		;multiply by 16 
0e0a 87				ADD	A,A		; 
0e0b 87				ADD	A,A		; 
0e0c 57				LD	D,A		;Save hi nibble in D 
0e0d			HEXCON: 
0e0d 7e				ld a, (hl)		;Get next chr 
0e0e 23				inc hl 
0e0f d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0e11 fe 0a			CP	00Ah		;Is it 0-9 ? 
0e13 38 02			JR	C,NALPHA	;If so miss next bit 
0e15 d6 07			SUB	007h		;Else convert alpha 
0e17			NALPHA: 
0e17 b2				OR	D		;Add hi nibble back 
0e18 c9				RET			; 
0e19			 
0e19			 
0e19			; 
0e19			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0e19			; Since the routines get_byte and therefore get_nibble are called, only valid 
0e19			; characters (0-9a-f) are accepted. 
0e19			; 
0e19			;get_word        push    af 
0e19			;                call    get_byte        ; Get the upper byte 
0e19			;                ld      h, a 
0e19			;                call    get_byte        ; Get the lower byte 
0e19			;                ld      l, a 
0e19			;                pop     af 
0e19			;                ret 
0e19			; 
0e19			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0e19			; the routine get_nibble is used only valid characters are accepted - the  
0e19			; input routine only accepts characters 0-9a-f. 
0e19			; 
0e19 c5			get_byte:        push    bc              ; Save contents of B (and C) 
0e1a 7e					ld a,(hl) 
0e1b 23					inc hl 
0e1c cd 41 0e		                call    nibble2val      ; Get upper nibble 
0e1f cb 07		                rlc     a 
0e21 cb 07		                rlc     a 
0e23 cb 07		                rlc     a 
0e25 cb 07		                rlc     a 
0e27 47			                ld      b, a            ; Save upper four bits 
0e28 7e					ld a,(hl) 
0e29 cd 41 0e		                call    nibble2val      ; Get lower nibble 
0e2c b0			                or      b               ; Combine both nibbles 
0e2d c1			                pop     bc              ; Restore B (and C) 
0e2e c9			                ret 
0e2f			; 
0e2f			; Get a hexadecimal digit from the serial line. This routine blocks until 
0e2f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0e2f			; to the serial line interface. The lower 4 bits of A contain the value of  
0e2f			; that particular digit. 
0e2f			; 
0e2f			;get_nibble      ld a,(hl)           ; Read a character 
0e2f			;                call    to_upper        ; Convert to upper case 
0e2f			;                call    is_hex          ; Was it a hex digit? 
0e2f			;                jr      nc, get_nibble  ; No, get another character 
0e2f			 ;               call    nibble2val      ; Convert nibble to value 
0e2f			 ;               call    print_nibble 
0e2f			 ;               ret 
0e2f			; 
0e2f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0e2f			; A valid hexadecimal digit is denoted by a set C flag. 
0e2f			; 
0e2f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0e2f			;                ret     nc              ; Yes 
0e2f			;                cp      '0'             ; Less than '0'? 
0e2f			;                jr      nc, is_hex_1    ; No, continue 
0e2f			;                ccf                     ; Complement carry (i.e. clear it) 
0e2f			;                ret 
0e2f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0e2f			;                ret     c               ; Yes 
0e2f			;                cp      'A'             ; Less than 'A'? 
0e2f			;                jr      nc, is_hex_2    ; No, continue 
0e2f			;                ccf                     ; Yes - clear carry and return 
0e2f			;                ret 
0e2f			;is_hex_2        scf                     ; Set carry 
0e2f			;                ret 
0e2f			; 
0e2f			; Convert a single character contained in A to upper case: 
0e2f			; 
0e2f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0e31 d8			                ret     c 
0e32 fe 7b		                cp      'z' + 1         ; > 'z'? 
0e34 d0			                ret     nc              ; Nothing to do, either 
0e35 e6 5f		                and     $5f             ; Convert to upper case 
0e37 c9			                ret 
0e38			 
0e38			 
0e38			to_lower: 
0e38			 
0e38			   ; if char is in [A-Z] make it lower case 
0e38			 
0e38			   ; enter : a = char 
0e38			   ; exit  : a = lower case char 
0e38			   ; uses  : af 
0e38			 
0e38 fe 41		   cp 'A' 
0e3a d8			   ret c 
0e3b			    
0e3b fe 5b		   cp 'Z'+1 
0e3d d0			   ret nc 
0e3e			    
0e3e f6 20		   or $20 
0e40 c9			   ret 
0e41			 
0e41			; 
0e41			; Expects a hexadecimal digit (upper case!) in A and returns the 
0e41			; corresponding value in A. 
0e41			; 
0e41 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0e43 38 02		                jr      c, nibble2val_1 ; Yes 
0e45 d6 07		                sub     7               ; Adjust for A-F 
0e47 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0e49 e6 0f		                and     $f              ; Only return lower 4 bits 
0e4b c9			                ret 
0e4c			; 
0e4c			; Print_nibble prints a single hex nibble which is contained in the lower  
0e4c			; four bits of A: 
0e4c			; 
0e4c			;print_nibble    push    af              ; We won't destroy the contents of A 
0e4c			;                and     $f              ; Just in case... 
0e4c			;                add     a, '0'             ; If we have a digit we are done here. 
0e4c			;                cp      '9' + 1         ; Is the result > 9? 
0e4c			;                jr      c, print_nibble_1 
0e4c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0e4c			;print_nibble_1  call    putc            ; Print the nibble and 
0e4c			;                pop     af              ; restore the original value of A 
0e4c			;                ret 
0e4c			;; 
0e4c			;; Send a CR/LF pair: 
0e4c			; 
0e4c			;crlf            push    af 
0e4c			;                ld      a, cr 
0e4c			;                call    putc 
0e4c			;                ld      a, lf 
0e4c			;                call    putc 
0e4c			;                pop     af 
0e4c			;                ret 
0e4c			; 
0e4c			; Print_word prints the four hex digits of a word to the serial line. The  
0e4c			; word is expected to be in HL. 
0e4c			; 
0e4c			;print_word      push    hl 
0e4c			;                push    af 
0e4c			;                ld      a, h 
0e4c			;                call    print_byte 
0e4c			;                ld      a, l 
0e4c			;                call    print_byte 
0e4c			;                pop     af 
0e4c			;                pop     hl 
0e4c			;                ret 
0e4c			; 
0e4c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0e4c			; The byte to be printed is expected to be in A. 
0e4c			; 
0e4c			;print_byte      push    af              ; Save the contents of the registers 
0e4c			;                push    bc 
0e4c			;                ld      b, a 
0e4c			;                rrca 
0e4c			;                rrca 
0e4c			;                rrca 
0e4c			;                rrca 
0e4c			;                call    print_nibble    ; Print high nibble 
0e4c			;                ld      a, b 
0e4c			;                call    print_nibble    ; Print low nibble 
0e4c			;                pop     bc              ; Restore original register contents 
0e4c			;                pop     af 
0e4c			;                ret 
0e4c			 
0e4c			 
0e4c			 
0e4c			 
0e4c			 
0e4c			fourehexhl:  
0e4c 7e				ld a,(hl) 
0e4d cd fb 0d			call atohex 
0e50 cb 3f				SRL A 
0e52 cb 3f				SRL A 
0e54 cb 3f				SRL A 
0e56 cb 3f				SRL A 
0e58 47				ld b, a 
0e59 23				inc hl 
0e5a 7e				ld a,(hl) 
0e5b 23				inc hl 
0e5c cd fb 0d			call atohex 
0e5f 80				add b 
0e60 57				ld d,a 
0e61 7e				ld a,(hl) 
0e62 cd fb 0d			call atohex 
0e65 cb 3f				SRL A 
0e67 cb 3f				SRL A 
0e69 cb 3f				SRL A 
0e6b cb 3f				SRL A 
0e6d 47				ld b, a 
0e6e 23				inc hl 
0e6f 7e				ld a,(hl) 
0e70 23				inc hl 
0e71 cd fb 0d			call atohex 
0e74 80				add b 
0e75 5f				ld e, a 
0e76 d5				push de 
0e77 e1				pop hl 
0e78 c9				ret 
0e79			 
0e79			; pass hl. returns z set if the byte at hl is a digit 
0e79			;isdigithl:  
0e79			;	push bc 
0e79			;	ld a,(hl) 
0e79			;	cp ':' 
0e79			;	jr nc, .isdf 		; > 
0e79			;	cp '0' 
0e79			;	jr c, .isdf		; < 
0e79			; 
0e79			;	; TODO find a better way to set z 
0e79			; 
0e79			;	ld b,a 
0e79			;	cp b 
0e79			;	pop bc 
0e79			;	ret 
0e79			; 
0e79			;.isdf:	; not digit so clear z 
0e79			; 
0e79			;	; TODO find a better way to unset z 
0e79			; 
0e79			;	ld b,a 
0e79			;	inc b 
0e79			;	cp b 
0e79			; 
0e79			;	pop bc 
0e79			;	ret 
0e79				 
0e79				 
0e79			 
0e79			 
0e79			; pass hl as the four byte address to load 
0e79			 
0e79			get_word_hl:  
0e79 e5				push hl 
0e7a cd 19 0e			call get_byte 
0e7d				 
0e7d 47				ld b, a 
0e7e			 
0e7e e1				pop hl 
0e7f 23				inc hl 
0e80 23				inc hl 
0e81			 
0e81			; TODO not able to handle a-f  
0e81 7e				ld a,(hl) 
0e82			;	;cp ':' 
0e82			;	cp 'g' 
0e82			;	jr nc, .single_byte_hl 		; > 
0e82			;	cp 'G' 
0e82			;	jr nc, .single_byte_hl 		; > 
0e82			;	cp '0' 
0e82			;	jr c, .single_byte_hl		; < 
0e82			 
0e82				;call isdigithl 
0e82 fe 00			cp 0 
0e84 28 06			jr z, .single_byte_hl 
0e86			 
0e86			.getwhln:   ; hex word so get next byte 
0e86			 
0e86 cd 19 0e			call get_byte 
0e89 6f				ld l, a 
0e8a 60				ld h,b 
0e8b c9				ret 
0e8c 68			.single_byte_hl:   ld l,b 
0e8d 26 00				ld h,0 
0e8f c9					ret 
0e90			 
0e90			 
0e90			 
0e90			 
0e90 21 2a 15			ld hl,asc+1 
0e93			;	ld a, (hl) 
0e93			;	call nibble2val 
0e93 cd 19 0e			call get_byte 
0e96			 
0e96			;	call fourehexhl 
0e96 32 a9 e3			ld (scratch+52),a 
0e99				 
0e99 21 a7 e3			ld hl,scratch+50 
0e9c 22 98 e6			ld (os_cur_ptr),hl 
0e9f			 
0e9f c9				ret 
0ea0			 
0ea0			 
0ea0			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0ea0			 
0ea0			; Decimal Unsigned Version 
0ea0			 
0ea0			;Number in a to decimal ASCII 
0ea0			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0ea0			;Example: display a=56 as "056" 
0ea0			;input: a = number 
0ea0			;Output: a=0,value of a in the screen 
0ea0			;destroys af,bc (don't know about hl and de) 
0ea0			DispAToASCII: 
0ea0 0e 9c			ld	c,-100 
0ea2 cd ac 0e			call	.Na1 
0ea5 0e f6			ld	c,-10 
0ea7 cd ac 0e			call	.Na1 
0eaa 0e ff			ld	c,-1 
0eac 06 2f		.Na1:	ld	b,'0'-1 
0eae 04			.Na2:	inc	b 
0eaf 81				add	a,c 
0eb0 38 fc			jr	c,.Na2 
0eb2 91				sub	c		;works as add 100/10/1 
0eb3 f5				push af		;safer than ld c,a 
0eb4 78				ld	a,b		;char is in b 
0eb5			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0eb5 f1				pop af		;safer than ld a,c 
0eb6 c9				ret 
0eb7			 
0eb7			; Decimal Signed Version 
0eb7			 
0eb7			; DispA 
0eb7			; -------------------------------------------------------------- 
0eb7			; Converts a signed integer value to a zero-terminated ASCII 
0eb7			; string representative of that value (using radix 10). 
0eb7			; -------------------------------------------------------------- 
0eb7			; INPUTS: 
0eb7			;     HL     Value to convert (two's complement integer). 
0eb7			;     DE     Base address of string destination. (pointer). 
0eb7			; -------------------------------------------------------------- 
0eb7			; OUTPUTS: 
0eb7			;     None 
0eb7			; -------------------------------------------------------------- 
0eb7			; REGISTERS/MEMORY DESTROYED 
0eb7			; AF HL 
0eb7			; -------------------------------------------------------------- 
0eb7			 
0eb7			;DispHLToASCII: 
0eb7			;   push    de 
0eb7			;   push    bc 
0eb7			; 
0eb7			;; Detect sign of HL. 
0eb7			;    bit    7, h 
0eb7			;    jr     z, ._DoConvert 
0eb7			; 
0eb7			;; HL is negative. Output '-' to string and negate HL. 
0eb7			;    ld     a, '-' 
0eb7			;    ld     (de), a 
0eb7			;    inc    de 
0eb7			; 
0eb7			;; Negate HL (using two's complement) 
0eb7			;    xor    a 
0eb7			;    sub    l 
0eb7			;    ld     l, a 
0eb7			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0eb7			;    sbc    a, h 
0eb7			;    ld     h, a 
0eb7			; 
0eb7			;; Convert HL to digit characters 
0eb7			;._DoConvert: 
0eb7			;    ld     b, 0     ; B will count character length of number 
0eb7			;-   ld     a, 10 
0eb7			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0eb7			;    push   af 
0eb7			;    inc    b 
0eb7			;    ld     a, h 
0eb7			;    or     l 
0eb7			;    jr     nz, - 
0eb7			; 
0eb7			;; Retrieve digits from stack 
0eb7			;-   pop    af 
0eb7			;    or     $30 
0eb7			;    ld     (de), a 
0eb7			;    inc    de 
0eb7			;    djnz   - 
0eb7			; 
0eb7			;; Terminate string with NULL 
0eb7			;    xor    a 
0eb7			;    ld     (de), a 
0eb7			; 
0eb7			;    pop    bc 
0eb7			;    pop    de 
0eb7			;    ret 
0eb7			 
0eb7			;Comments 
0eb7			; 
0eb7			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0eb7			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0eb7			;    Note that the output string will not be fixed-width. 
0eb7			; 
0eb7			;Example Usage 
0eb7			; 
0eb7			;    ld    hl, -1004 
0eb7			;    ld    de, OP1 
0eb7			;    call  DispA 
0eb7			;    ld    hl, OP1 
0eb7			;    syscall  PutS 
0eb7			 
0eb7			 
0eb7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0eb7			 
0eb7			 
0eb7			;Converts an ASCII string to an unsigned 16-bit integer 
0eb7			;Quits when it reaches a non-decimal digit 
0eb7			 
0eb7			string_to_uint16: 
0eb7			atoui_16: 
0eb7			;Input: 
0eb7			;     DE points to the string 
0eb7			;Outputs: 
0eb7			;     HL is the result 
0eb7			;     A is the 8-bit value of the number 
0eb7			;     DE points to the byte after the number 
0eb7			;Destroys: 
0eb7			;     BC 
0eb7			;       if the string is non-empty, BC is HL/10 
0eb7			;Size:  24 bytes 
0eb7			;Speed: 42+d(104+{0,9}) 
0eb7			;       d is the number of digits in the number 
0eb7			;       max is 640 cycles for a 5 digit number 
0eb7			;Assuming no leading zeros: 
0eb7			;1 digit:  146cc 
0eb7			;2 digit:  250cc 
0eb7			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0eb7			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0eb7			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0eb7			;avg: 544.81158447265625cc (544+13297/16384) 
0eb7			;=============================================================== 
0eb7 21 00 00		  ld hl,0 
0eba			.u16a: 
0eba 1a			  ld a,(de) 
0ebb d6 30		  sub 30h 
0ebd fe 0a		  cp 10 
0ebf d0			  ret nc 
0ec0 13			  inc de 
0ec1 44			  ld b,h 
0ec2 4d			  ld c,l 
0ec3 29			  add hl,hl 
0ec4 29			  add hl,hl 
0ec5 09			  add hl,bc 
0ec6 29			  add hl,hl 
0ec7 85			  add a,l 
0ec8 6f			  ld l,a 
0ec9 30 ef		  jr nc,.u16a 
0ecb 24			  inc h 
0ecc c3 ba 0e		  jp .u16a 
0ecf			 
0ecf			 
0ecf			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0ecf			 
0ecf			;written by Zeda 
0ecf			;Converts a 16-bit unsigned integer to an ASCII string. 
0ecf			 
0ecf			uitoa_16: 
0ecf			;Input: 
0ecf			;   DE is the number to convert 
0ecf			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0ecf			;Output: 
0ecf			;   HL points to the null-terminated ASCII string 
0ecf			;      NOTE: This isn't necessarily the same as the input HL. 
0ecf d5			  push de 
0ed0 c5			  push bc 
0ed1 f5			  push af 
0ed2 eb			  ex de,hl 
0ed3			 
0ed3 01 f0 d8		  ld bc,-10000 
0ed6 3e 2f		  ld a,'0'-1 
0ed8 3c			  inc a 
0ed9 09			  add hl,bc  
0eda 38 fc		   jr c,$-2 
0edc 12			  ld (de),a 
0edd 13			  inc de 
0ede			 
0ede 01 e8 03		  ld bc,1000 
0ee1 3e 3a		  ld a,'9'+1 
0ee3 3d			  dec a  
0ee4 09			  add hl,bc  
0ee5 30 fc		   jr nc,$-2 
0ee7 12			  ld (de),a 
0ee8 13			  inc de 
0ee9			 
0ee9 01 9c ff		  ld bc,-100 
0eec 3e 2f		  ld a,'0'-1 
0eee 3c			  inc a  
0eef 09			  add hl,bc  
0ef0 38 fc		   jr c,$-2 
0ef2 12			  ld (de),a 
0ef3 13			  inc de 
0ef4			 
0ef4 7d			  ld a,l 
0ef5 26 3a		  ld h,'9'+1 
0ef7 25			  dec h  
0ef8 c6 0a		  add a,10  
0efa 30 fb		   jr nc,$-3 
0efc c6 30		  add a,'0' 
0efe eb			  ex de,hl 
0eff 72			  ld (hl),d 
0f00 23			  inc hl 
0f01 77			  ld (hl),a 
0f02 23			  inc hl 
0f03 36 00		  ld (hl),0 
0f05			 
0f05			;Now strip the leading zeros 
0f05 0e fa		  ld c,-6 
0f07 09			  add hl,bc 
0f08 3e 30		  ld a,'0' 
0f0a 23			  inc hl  
0f0b be			  cp (hl)  
0f0c 28 fc		  jr z,$-2 
0f0e			 
0f0e			;Make sure that the string is non-empty! 
0f0e 7e			  ld a,(hl) 
0f0f b7			  or a 
0f10 20 01		  jr nz,.atoub 
0f12 2b			  dec hl 
0f13			.atoub: 
0f13			 
0f13 f1			  pop af 
0f14 c1			  pop bc 
0f15 d1			  pop de 
0f16 c9			  ret 
0f17			 
0f17			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
0f17			 
0f17			toUpper: 
0f17			;A is the char. 
0f17			;If A is a lowercase letter, this sets it to the matching uppercase 
0f17			;18cc or 30cc or 41cc 
0f17			;avg: 26.75cc 
0f17 fe 61		  cp 'a' 
0f19 d8			  ret c 
0f1a fe 7b		  cp 'z'+1 
0f1c d0			  ret nc 
0f1d d6 20		  sub 'a'-'A' 
0f1f c9			  ret 
0f20			 
0f20			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
0f20			 
0f20			; String Length 
0f20			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
0f20			 
0f20			; Get the length of the null-terminated string starting at $8000 hl 
0f20			;    LD     HL, $8000 
0f20			 
0f20			strlenz: 
0f20			 
0f20 af			    XOR    A               ; Zero is the value we are looking for. 
0f21 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
0f22 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
0f23			                           ; 65, 536 bytes (the entire addressable memory space). 
0f23 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0f25			 
0f25			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0f25 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
0f26 6f			    LD     L, A             ; number of bytes 
0f27 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0f29 2b			    DEC    HL              ; Compensate for null. 
0f2a c9				ret 
0f2b			 
0f2b			; Get the length of the A terminated string starting at $8000 hl 
0f2b			;    LD     HL, $8000 
0f2b			 
0f2b			strlent: 
0f2b			 
0f2b			                  ; A is the value we are looking for. 
0f2b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
0f2d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
0f2f			                           ; 65, 536 bytes (the entire addressable memory space). 
0f2f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0f31			 
0f31			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0f31 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
0f33 2e 00		    LD     L, 0             ; number of bytes 
0f35 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0f37 2b			    DEC    HL              ; Compensate for null. 
0f38 c9				ret 
0f39			 
0f39			 
0f39			;Comparing Strings 
0f39			 
0f39			;IN    HL     Address of string1. 
0f39			;      DE     Address of string2. 
0f39			 
0f39			; doc given but wrong??? 
0f39			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
0f39			;      carry  Set if string1 > string2, reset if string1 <= string2. 
0f39			; tested 
0f39			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
0f39			 
0f39			strcmp_old: 
0f39 e5			    PUSH   HL 
0f3a d5			    PUSH   DE 
0f3b			 
0f3b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
0f3c be			    CP     (HL)            ; (want to minimize work). 
0f3d 38 01		    JR     C, Str1IsBigger 
0f3f 7e			    LD     A, (HL) 
0f40			 
0f40			Str1IsBigger: 
0f40 4f			    LD     C, A             ; Put length in BC 
0f41 06 00		    LD     B, 0 
0f43 13			    INC    DE              ; Increment pointers to meat of string. 
0f44 23			    INC    HL 
0f45			 
0f45			CmpLoop: 
0f45 1a			    LD     A, (DE)          ; Compare bytes. 
0f46 ed a1		    CPI 
0f48 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
0f4a 13			    INC    DE              ; Update pointer. 
0f4b ea 45 0f		    JP     PE, CmpLoop 
0f4e			 
0f4e d1			    POP    DE 
0f4f e1			    POP    HL 
0f50 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
0f51 be			    CP     (HL) 
0f52 c9			    RET 
0f53			 
0f53			NoMatch: 
0f53 2b			    DEC    HL 
0f54 be			    CP     (HL)            ; Compare again to affect carry. 
0f55 d1			    POP    DE 
0f56 e1			    POP    HL 
0f57 c9			    RET 
0f58			 
0f58			;; test strmp 
0f58			; 
0f58			;ld de, .str1 
0f58			;ld hl, .str2 
0f58			;call strcmp 
0f58			;jr z, .z1 
0f58			;;this 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "NZ1" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			;.z1: 
0f58			; 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "ZZ1" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			; 
0f58			;ld de, .str1 
0f58			;ld hl, .str1 
0f58			;call strcmp 
0f58			;jr z, .z2 
0f58			;;this 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "NZ2" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			;.z2: 
0f58			; 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "ZZ2" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			; 
0f58			;ld de, .str1 
0f58			;ld hl, .str2 
0f58			;call strcmp 
0f58			;jr c, .c1 
0f58			; 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "Nc1" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			;.c1: 
0f58			;;this 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "cc1" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			; 
0f58			;ld de, .str1 
0f58			;ld hl, .str1 
0f58			;call strcmp 
0f58			;jr c, .c2 
0f58			;;this 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "Nc2" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			;.c2: 
0f58			; 
0f58			;	if DEBUG_FORTH_WORDS 
0f58			;		DMARK "cc2" 
0f58			;		CALLMONITOR 
0f58			;	endif 
0f58			;	NEXTW 
0f58			;.str1:   db "string1",0 
0f58			;.str2:   db "string2",0 
0f58			 
0f58			; only care about direct match or not 
0f58			; hl and de strings 
0f58			; zero set if the same 
0f58			 
0f58			strcmp: 
0f58 1a				ld a, (de) 
0f59 be				cp (hl) 
0f5a 28 02			jr z, .ssame 
0f5c b7				or a 
0f5d c9				ret 
0f5e			 
0f5e			.ssame:  
0f5e fe 00			cp 0 
0f60 c8				ret z 
0f61			 
0f61 23				inc hl 
0f62 13				inc de 
0f63 18 f3			jr strcmp 
0f65				 
0f65				 
0f65			 
0f65			 
0f65			 
0f65			 
0f65			; eof 
0f65			 
0f65			 
0f65			 
0f65			 
0f65			 
0f65			 
# End of file firmware_strings.asm
0f65			include "firmware_memory.asm"   ; malloc and free  
0f65			 
0f65			if DEBUG_FORTH_MALLOC_HIGH 
0f65			.mallocsize: db "Wants malloc >256",0 
0f65			.mallocasize: db "MALLOC gives >256",0 
0f65			.malloczero: db "MALLOC gives zero",0 
0f65			 
0f65			malloc_guard_zerolen: 
0f65				push hl 
0f65				push de 
0f65				push af 
0f65			 
0f65				ld de, 0 
0f65			        call cmp16 
0f65				jr nz, .lowalloz 
0f65			 
0f65				push hl 
0f65				push de 
0f65					ld hl, display_fb0 
0f65					ld (display_fb_active), hl 
0f65				call clear_display 
0f65				ld a, 0 
0f65				ld de, .malloczero 
0f65				call str_at_display 
0f65				call update_display 
0f65				call delay1s 
0f65				call delay1s 
0f65				ld a, 0 
0f65				ld (os_view_disable), a 
0f65			 
0f65				pop de 
0f65				pop hl 
0f65			 
0f65				 
0f65			 
0f65				CALLMONITOR 
0f65			.lowalloz: 
0f65			 
0f65			 
0f65				pop af 
0f65				pop de 
0f65				pop hl 
0f65			ret 
0f65			 
0f65			malloc_guard_entry: 
0f65				push hl 
0f65				push de 
0f65				push af 
0f65			 
0f65			 	or a      ;clear carry flag 
0f65				push hl 
0f65				ld de, 255 
0f65				sbc hl, de 
0f65				jr c, .lowalloc 
0f65			 
0f65				push de 
0f65					ld hl, display_fb0 
0f65					ld (display_fb_active), hl 
0f65				call clear_display 
0f65				ld a, 0 
0f65				ld de, .mallocsize 
0f65				call str_at_display 
0f65				call update_display 
0f65				call delay1s 
0f65				call delay1s 
0f65				ld a, 0 
0f65				ld (os_view_disable), a 
0f65			 
0f65				pop de 
0f65				pop hl 
0f65			 
0f65				 
0f65			 
0f65				CALLMONITOR 
0f65				jr .lowdone 
0f65			.lowalloc: 
0f65			 
0f65			 
0f65				pop hl 
0f65			.lowdone:	pop af 
0f65				pop de 
0f65				pop hl 
0f65			ret 
0f65			 
0f65			malloc_guard_exit: 
0f65				push hl 
0f65				push de 
0f65				push af 
0f65			 
0f65			 	or a      ;clear carry flag 
0f65				push hl 
0f65				ld de, 255 
0f65				sbc hl, de 
0f65				jr c, .lowallocx 
0f65			 
0f65				push de 
0f65					ld hl, display_fb0 
0f65					ld (display_fb_active), hl 
0f65				call clear_display 
0f65				ld a, 0 
0f65				ld de, .mallocasize 
0f65				call str_at_display 
0f65				call update_display 
0f65				call delay1s 
0f65				call delay1s 
0f65				ld a, 0 
0f65				ld (os_view_disable), a 
0f65				pop de 
0f65				pop hl 
0f65			 
0f65				CALLMONITOR 
0f65				jr .lowdonex 
0f65			.lowallocx: 
0f65			 
0f65				pop hl 
0f65			.lowdonex:	pop af 
0f65				pop de 
0f65				pop hl 
0f65			ret 
0f65			endif 
0f65			 
0f65			if MALLOC_2 
0f65			; Z80 Malloc and Free Functions 
0f65			 
0f65			; Malloc Function: 
0f65			; Input: 
0f65			;   HL: Size of block to allocate 
0f65			; Output: 
0f65			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
0f65			 
0f65			malloc: 
0f65				 
0f65			if DEBUG_FORTH_MALLOC_HIGH 
0f65			call malloc_guard_entry 
0f65			endif 
0f65			 
0f65			 
0f65			 
0f65			 
0f65					if DEBUG_FORTH_MALLOC 
0f65						DMARK "mal" 
0f65						CALLMONITOR 
0f65					endif 
0f65			    push af            ; Save AF register 
0f65			    ld a, l            ; Load low byte of size into A 
0f65			    or h               ; Check if size is zero 
0f65			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
0f65			 
0f65			    ; Allocate memory 
0f65			    ld hl, (heap_start) ; Load start of heap into HL 
0f65					if DEBUG_FORTH_MALLOC 
0f65						DMARK "ma1" 
0f65						CALLMONITOR 
0f65					endif 
0f65			    call malloc_internal ; Call internal malloc function 
0f65			    pop af             ; Restore AF register 
0f65			if DEBUG_FORTH_MALLOC_HIGH 
0f65			call malloc_guard_exit 
0f65			call malloc_guard_zerolen 
0f65			endif 
0f65			    ret                ; Return 
0f65			 
0f65			; Free Function: 
0f65			; Input: 
0f65			;   HL: Pointer to memory block to free 
0f65			; Output: 
0f65			;   None 
0f65			 
0f65			free: 
0f65			    push af            ; Save AF register 
0f65			    ld a, l            ; Load low byte of pointer into A 
0f65			    or h               ; Check if pointer is NULL 
0f65			    jp z, free_exit    ; If pointer is NULL, exit 
0f65			 
0f65			    ; Free memory 
0f65			    ld hl, (heap_start) ; Load start of heap into HL 
0f65			    call free_internal  ; Call internal free function 
0f65			    pop af             ; Restore AF register 
0f65			    ret                ; Return 
0f65			 
0f65			; Internal Malloc Function: 
0f65			; Input: 
0f65			;   HL: Size of block to allocate 
0f65			; Output: 
0f65			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
0f65			 
0f65			malloc_internal: 
0f65			    ld bc, 2           ; Number of bytes to allocate for management overhead 
0f65			    add hl, bc         ; Add management overhead to requested size 
0f65			    ex de, hl          ; Save total size in DE, and keep it in HL 
0f65					if DEBUG_FORTH_MALLOC 
0f65						DMARK "ma2" 
0f65						CALLMONITOR 
0f65					endif 
0f65			 
0f65			    ; Search for free memory block 
0f65			    ld de, (heap_end)  ; Load end of heap into DE 
0f65			    ld bc, 0           ; Initialize counter 
0f65			 
0f65					if DEBUG_FORTH_MALLOC 
0f65						DMARK "ma2" 
0f65						CALLMONITOR 
0f65					endif 
0f65			malloc_search_loop: 
0f65			    ; Check if current block is free 
0f65			    ld a, (hl)         ; Load current block's status (free or used) 
0f65			    cp 0               ; Compare with zero (free) 
0f65			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
0f65			 
0f65			    ; Check if current block is large enough 
0f65			    ld a, (hl+1)       ; Load high byte of block size 
0f65			    cp l               ; Compare with low byte of requested size 
0f65			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
0f65			 
0f65			    ld a, (hl+2)       ; Load low byte of block size 
0f65			    cp h               ; Compare with high byte of requested size 
0f65			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
0f65			 
0f65			    ; Mark block as used 
0f65			    ld (hl), 0xFF      ; Set status byte to indicate used block 
0f65			 
0f65			    ; Calculate remaining space in block 
0f65			    ld bc, 0           ; Clear BC 
0f65			    add hl, bc         ; Increment HL to point to start of data block 
0f65			    add hl, de         ; HL = HL + DE (total size) 
0f65			    ld bc, 1           ; Number of bytes to allocate for management overhead 
0f65			    add hl, bc         ; Add management overhead to start of data block 
0f65			 
0f65			    ; Save pointer to allocated block in HL 
0f65			if DEBUG_FORTH_MALLOC_HIGH 
0f65						DMARK "ma5" 
0f65			call malloc_guard_exit 
0f65			call malloc_guard_zerolen 
0f65			endif 
0f65			    ret 
0f65			 
0f65			malloc_skip_block_check: 
0f65			    ; Move to the next block 
0f65			    ld bc, 3           ; Size of management overhead 
0f65			    add hl, bc         ; Move to the next block 
0f65			    inc de             ; Increment counter 
0f65			 
0f65			    ; Check if we have reached the end of heap 
0f65			    ld a, e            ; Load low byte of heap end address 
0f65			    cp (hl)            ; Compare with low byte of current address 
0f65			    jr nz, malloc_search_loop  ; If not equal, continue searching 
0f65			    ld a, d            ; Load high byte of heap end address 
0f65			    cp 0               ; Check if it's zero (end of memory) 
0f65			    jr nz, malloc_search_loop  ; If not zero, continue searching 
0f65			 
0f65			    ; If we reached here, allocation failed 
0f65			    xor a              ; Set result to NULL 
0f65			if DEBUG_FORTH_MALLOC_HIGH 
0f65						DMARK "ma6" 
0f65			call malloc_guard_exit 
0f65			call malloc_guard_zerolen 
0f65			endif 
0f65			    ret 
0f65			malloc_exit: 
0f65			if DEBUG_FORTH_MALLOC_HIGH 
0f65						DMARK "ma7" 
0f65			call malloc_guard_exit 
0f65			call malloc_guard_zerolen 
0f65			endif 
0f65			    ret 
0f65			 
0f65			; Internal Free Function: 
0f65			; Input: 
0f65			;   HL: Pointer to memory block to free 
0f65			; Output: 
0f65			;   None 
0f65			 
0f65			free_internal: 
0f65			    ld de, (heap_start) ; Load start of heap into DE 
0f65			    ld bc, 0            ; Initialize counter 
0f65			 
0f65			free_search_loop: 
0f65			    ; Check if current block contains the pointer 
0f65			    ld a, l             ; Load low byte of pointer 
0f65			    cp (hl+1)           ; Compare with high byte of current block's address 
0f65			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
0f65			    ld a, h             ; Load high byte of pointer 
0f65			    cp (hl+2)           ; Compare with low byte of current block's address 
0f65			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
0f65			 
0f65			    ; Mark block as free 
0f65			    ld (hl), 0          ; Set status byte to indicate free block 
0f65			    ret                 ; Return 
0f65			 
0f65			free_skip_block_check: 
0f65			    ; Move to the next block 
0f65			    ld bc, 3            ; Size of management overhead 
0f65			    add hl, bc          ; Move to the next block 
0f65			    inc de              ; Increment counter 
0f65			 
0f65			    ; Check if we have reached the end of heap 
0f65			    ld a, e             ; Load low byte of heap end address 
0f65			    cp (hl)             ; Compare with low byte of current address 
0f65			    jr nz, free_search_loop  ; If not equal, continue searching 
0f65			    ld a, d             ; Load high byte of heap end address 
0f65			    cp 0                ; Check if it's zero (end of memory) 
0f65			    jr nz, free_search_loop  ; If not zero, continue searching 
0f65			 
0f65			    ; If we reached here, pointer is not found in heap 
0f65			    ret 
0f65			 
0f65			free_exit: 
0f65			    ret                 ; Return 
0f65			 
0f65			; Define heap start and end addresses 
0f65			;heap_start:    .dw 0xC000   ; Start of heap 
0f65			;heap_end:      .dw 0xE000   ; End of heap 
0f65			 
0f65			endif 
0f65			 
0f65			 
0f65			if MALLOC_1 
0f65			 
0f65			 
0f65			 
0f65			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
0f65			 
0f65			;moved to firmware.asm 
0f65			;heap_start        .equ  0x9000      ; Starting address of heap 
0f65			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
0f65			 
0f65			;      .org 0 
0f65			;      jp    main 
0f65			 
0f65			 
0f65			;      .org  0x100 
0f65			;main: 
0f65			;      ld    HL, 0x8100 
0f65			;      ld    SP, HL 
0f65			; 
0f65			;      call  heap_init 
0f65			; 
0f65			;      ; Make some allocations 
0f65			;      ld    HL, 12 
0f65			;      call  malloc            ; Allocates 0x9004 
0f65			; 
0f65			;      ld    HL, 12 
0f65			;      call  malloc            ; Allocates 0x9014 
0f65			; 
0f65			;      ld    HL, 12 
0f65			;      call  malloc            ; Allocates 0x9024 
0f65			; 
0f65			;      ; Free some allocations 
0f65			;      ld    HL, 0x9014 
0f65			;      call  free 
0f65			; 
0f65			;      ld    HL, 0x9004 
0f65			;      call  free 
0f65			; 
0f65			;      ld    HL, 0x9024 
0f65			;      call  free 
0f65			; 
0f65			; 
0f65			;      halt 
0f65			 
0f65			 
0f65			;------------------------------------------------------------------------------ 
0f65			;     heap_init                                                               : 
0f65			;                                                                             : 
0f65			; Description                                                                 : 
0f65			;     Initialise the heap and make it ready for malloc and free operations.   : 
0f65			;                                                                             : 
0f65			;     The heap is maintained as a linked list, starting with an initial       : 
0f65			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
0f65			;     the first free block in the heap. Each block then points to the next    : 
0f65			;     free block within the heap, and the free list ends at the first block   : 
0f65			;     with a null pointer to the next free block.                             : 
0f65			;                                                                             : 
0f65			; Parameters                                                                  : 
0f65			;     Inputs are compile-time only. Two defines which specify the starting    : 
0f65			;     address of the heap and its size are required, along with a memory      : 
0f65			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
0f65			;     principally stores a pointer to the first free block in the heap.       : 
0f65			;                                                                             : 
0f65			; Returns                                                                     : 
0f65			;     Nothing                                                                 : 
0f65			;------------------------------------------------------------------------------ 
0f65			heap_init: 
0f65 e5			      push  HL 
0f66			 
0f66			      ; Initialise free list struct 
0f66 21 19 56		      ld    HL, heap_start 
0f69 22 14 56		      ld    (free_list), HL 
0f6c 21 00 00		      ld    HL, 0 
0f6f 22 16 56		      ld    (free_list+2), HL 
0f72			 
0f72			      ; Insert first free block at bottom of heap, consumes entire heap 
0f72 21 65 e3		      ld    HL, heap_start+heap_size-4 
0f75 22 19 56		      ld    (heap_start), HL        ; Next block (end of free list) 
0f78 21 4c 8d		      ld    HL, heap_size-4 
0f7b 22 1b 56		      ld    (heap_start+2), HL      ; Block size 
0f7e			 
0f7e			      ; Insert end of free list block at top of heap - two null words will 
0f7e			      ; terminate the free list 
0f7e 21 00 00		      ld    HL, 0 
0f81 22 67 e3		      ld    (heap_start+heap_size-2), HL 
0f84 22 65 e3		      ld    (heap_start+heap_size-4), HL 
0f87			 
0f87 e1			      pop   HL 
0f88			 
0f88 c9			      ret 
0f89			 
0f89			 
0f89			;------------------------------------------------------------------------------ 
0f89			;     malloc                                                                  : 
0f89			;                                                                             : 
0f89			; Description                                                                 : 
0f89			;     Allocates the wanted space from the heap and returns the address of the : 
0f89			;     first useable byte of the allocation.                                   : 
0f89			;                                                                             : 
0f89			;     Allocations can happen in one of two ways:                              : 
0f89			;                                                                             : 
0f89			;     1. A free block may be found which is the exact size wanted. In this    : 
0f89			;        case the block is removed from the free list and retuedn to the      : 
0f89			;        caller.                                                              : 
0f89			;     2. A free block may be found which is larger than the size wanted. In   : 
0f89			;        this case, the larger block is split into two. The first portion of  : 
0f89			;        this block will become the requested space by the malloc call and    : 
0f89			;        is returned to the caller. The second portion becomes a new free     : 
0f89			;        block, and the free list is adjusted to maintain continuity via this : 
0f89			;        newly created block.                                                 : 
0f89			;                                                                             : 
0f89			;     malloc does not set any initial value in the allocated space, the       : 
0f89			;     caller is required to do this as required.                              : 
0f89			;                                                                             : 
0f89			;     This implementation of malloc uses the stack exclusively, and is        : 
0f89			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
0f89			;     advisable to disable interrupts before calling malloc, and recommended  : 
0f89			;     to avoid the use of malloc inside ISRs in general.                      : 
0f89			;                                                                             : 
0f89			;     NOTE: heap_init must be called before malloc and free can be used.      : 
0f89			;                                                                             : 
0f89			; Parameters                                                                  : 
0f89			;     HL  Number of bytes wanted                                              : 
0f89			;                                                                             : 
0f89			; Returns                                                                     : 
0f89			;     HL  Address of the first useable byte of the allocation                 : 
0f89			;                                                                             : 
0f89			; Flags                                                                       : 
0f89			;     Z   Set if the allocation did not succeed, clear otherwise              : 
0f89			;                                                                             : 
0f89			; Stack frame                                                                 : 
0f89			;       |             |                                                       : 
0f89			;       +-------------+                                                       : 
0f89			;       |     BC      |                                                       : 
0f89			;       +-------------+                                                       : 
0f89			;       |     DE      |                                                       : 
0f89			;       +-------------+                                                       : 
0f89			;       |     IX      |                                                       : 
0f89			;       +-------------+                                                       : 
0f89			;       |  prev_free  |                                                       : 
0f89			;   +4  +-------------+                                                       : 
0f89			;       |  this_free  |                                                       : 
0f89			;   +2  +-------------+                                                       : 
0f89			;       |  next_free  |                                                       : 
0f89			;   +0  +-------------+                                                       : 
0f89			;       |             |                                                       : 
0f89			;                                                                             : 
0f89			;------------------------------------------------------------------------------ 
0f89			 
0f89			 
0f89			;malloc: 
0f89			; 
0f89			;	SAVESP ON 1 
0f89			; 
0f89			;	call malloc_code 
0f89			; 
0f89			;	CHECKSP ON 1 
0f89			;	ret 
0f89			 
0f89			 
0f89			malloc: 
0f89 c5			      push  BC 
0f8a d5			      push  DE 
0f8b dd e5		      push  IX 
0f8d			if DEBUG_FORTH_MALLOC_HIGH 
0f8d			call malloc_guard_entry 
0f8d			endif 
0f8d			 
0f8d					if DEBUG_FORTH_MALLOC 
0f8d						DMARK "mal" 
0f8d						CALLMONITOR 
0f8d					endif 
0f8d 7c			      ld    A, H                    ; Exit if no space requested 
0f8e b5			      or    L 
0f8f ca 4e 10		      jp    Z, malloc_early_exit 
0f92			 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			; 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			;inc hl 
0f92			 
0f92			 
0f92			 
0f92			 
0f92					if DEBUG_FORTH_MALLOC 
0f92						DMARK "maA" 
0f92						CALLMONITOR 
0f92					endif 
0f92			      ; Set up stack frame 
0f92 eb			      ex    DE, HL 
0f93 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
0f96 39			      add   HL, SP 
0f97 f9			      ld    SP, HL 
0f98 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
0f9c dd 39		      add   IX, SP 
0f9e			 
0f9e			      ; Setup initial state 
0f9e 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
0fa1 19			      add   HL, DE 
0fa2			 
0fa2 44			      ld    B, H                    ; Move want to BC 
0fa3 4d			      ld    C, L 
0fa4			 
0fa4 21 14 56		      ld    HL, free_list           ; Store prev_free ptr to stack 
0fa7 dd 75 04		      ld    (IX+4), L 
0faa dd 74 05		      ld    (IX+5), H 
0fad			 
0fad 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
0fae 23			      inc   HL 
0faf 56			      ld    D, (HL) 
0fb0 dd 73 02		      ld    (IX+2), E 
0fb3 dd 72 03		      ld    (IX+3), D 
0fb6 eb			      ex    DE, HL                  ; this_free ptr into HL 
0fb7			 
0fb7					if DEBUG_FORTH_MALLOC 
0fb7						DMARK "maB" 
0fb7						CALLMONITOR 
0fb7					endif 
0fb7			      ; Loop through free block list to find some space 
0fb7			malloc_find_space: 
0fb7 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
0fb8 23			      inc   HL 
0fb9 56			      ld    D, (HL) 
0fba			 
0fba 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
0fbb b3			      or    E 
0fbc ca 48 10		      jp    Z, malloc_no_space 
0fbf			 
0fbf dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
0fc2 dd 72 01		      ld    (IX+1), D 
0fc5			 
0fc5			      ; Does this block have enough space to make the allocation? 
0fc5 23			      inc   HL                      ; Load free block size into DE 
0fc6 5e			      ld    E, (HL) 
0fc7 23			      inc   HL 
0fc8 56			      ld    D, (HL) 
0fc9			 
0fc9 eb			      ex    DE, HL                  ; Check size of block against want 
0fca b7			      or    A                       ; Ensure carry flag clear 
0fcb ed 42		      sbc   HL, BC 
0fcd e5			      push  HL                      ; Store the result for later (new block size) 
0fce			 
0fce ca 1d 10		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
0fd1 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
0fd3			 
0fd3			      ; this_free block is not big enough, setup ptrs to test next free block 
0fd3 e1			      pop   HL                      ; Discard previous result 
0fd4			 
0fd4 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
0fd7 dd 66 03		      ld    H, (IX+3) 
0fda dd 75 04		      ld    (IX+4), L 
0fdd dd 74 05		      ld    (IX+5), H 
0fe0			 
0fe0 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
0fe3 dd 66 01		      ld    H, (IX+1) 
0fe6 dd 75 02		      ld    (IX+2), L 
0fe9 dd 74 03		      ld    (IX+3), H 
0fec			 
0fec					if DEBUG_FORTH_MALLOC 
0fec						DMARK "MA>" 
0fec						CALLMONITOR 
0fec					endif 
0fec 18 c9		      jr    malloc_find_space 
0fee			 
0fee			      ; split a bigger block into two - requested size and remaining size 
0fee			malloc_alloc_split: 
0fee					if DEBUG_FORTH_MALLOC 
0fee						DMARK "MAs" 
0fee						CALLMONITOR 
0fee					endif 
0fee eb			      ex    DE, HL                  ; Calculate address of new free block 
0fef 2b			      dec   HL 
0ff0 2b			      dec   HL 
0ff1 2b			      dec   HL 
0ff2 09			      add   HL, BC 
0ff3			 
0ff3			      ; Create a new block and point it at next_free 
0ff3 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
0ff6 dd 56 01		      ld    D, (IX+1) 
0ff9			 
0ff9 73			      ld    (HL), E                 ; Store next_free ptr into new block 
0ffa 23			      inc   HL 
0ffb 72			      ld    (HL), D 
0ffc			 
0ffc d1			      pop   DE                      ; Store size of new block into new block 
0ffd 23			      inc   HL 
0ffe 73			      ld    (HL), E 
0fff 23			      inc   HL 
1000 72			      ld    (HL), D 
1001			 
1001			      ; Update this_free ptr to point to new block 
1001 2b			      dec   HL 
1002 2b			      dec   HL 
1003 2b			      dec   HL 
1004			 
1004 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1007 dd 56 03		      ld    D, (IX+3) 
100a			 
100a dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
100d dd 74 03		      ld    (IX+3), H 
1010			 
1010			      ; Modify this_free block to be allocation 
1010 eb			      ex    DE, HL 
1011 af			      xor   A                       ; Null the next block ptr of allocated block 
1012 77			      ld    (HL), A 
1013 23			      inc   HL 
1014 77			      ld    (HL), A 
1015			 
1015 23			      inc   HL                      ; Store want size into allocated block 
1016 71			      ld    (HL), C 
1017 23			      inc   HL 
1018 70			      ld    (HL), B 
1019 23			      inc   HL 
101a e5			      push  HL                      ; Address of allocation to return 
101b			 
101b 18 19		      jr    malloc_update_links 
101d			 
101d			malloc_alloc_fit: 
101d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
101e			 
101e					if DEBUG_FORTH_MALLOC 
101e						DMARK "MAf" 
101e						CALLMONITOR 
101e					endif 
101e			      ; Modify this_free block to be allocation 
101e eb			      ex    DE, HL 
101f 2b			      dec   HL 
1020 2b			      dec   HL 
1021 2b			      dec   HL 
1022			 
1022 af			      xor   A                       ; Null the next block ptr of allocated block 
1023 77			      ld    (HL), A 
1024 23			      inc   HL 
1025 77			      ld    (HL), A 
1026			 
1026 23			      inc   HL                      ; Store address of allocation to return 
1027 23			      inc   HL 
1028 23			      inc   HL 
1029 e5			      push  HL 
102a			 
102a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
102a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
102d dd 66 01		      ld    H, (IX+1) 
1030			 
1030 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1033 dd 74 03		      ld    (IX+3), H 
1036			 
1036			 
1036			malloc_update_links: 
1036			      ; Update prev_free ptr to point to this_free 
1036 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1039 dd 66 05		      ld    H, (IX+5) 
103c			 
103c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
103f dd 56 03		      ld    D, (IX+3) 
1042			 
1042 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1043 23			      inc   HL 
1044 72			      ld    (HL), D 
1045			 
1045					if DEBUG_FORTH_MALLOC 
1045						DMARK "Mul" 
1045						CALLMONITOR 
1045					endif 
1045			      ; Clear the Z flag to indicate successful allocation 
1045 7a			      ld    A, D 
1046 b3			      or    E 
1047			 
1047 d1			      pop   DE                      ; Address of allocation 
1048					if DEBUG_FORTH_MALLOC 
1048						DMARK "MAu" 
1048						CALLMONITOR 
1048					endif 
1048			 
1048			malloc_no_space: 
1048 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
104b 39			      add   HL, SP 
104c f9			      ld    SP, HL 
104d			 
104d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
104e					if DEBUG_FORTH_MALLOC 
104e						DMARK "MAN" 
104e						CALLMONITOR 
104e					endif 
104e			 
104e			malloc_early_exit: 
104e					if DEBUG_FORTH_MALLOC 
104e						DMARK "MAx" 
104e						CALLMONITOR 
104e					endif 
104e dd e1		      pop   IX 
1050 d1			      pop   DE 
1051 c1			      pop   BC 
1052			 
1052			if DEBUG_FORTH_MALLOC_HIGH 
1052			call malloc_guard_exit 
1052			call malloc_guard_zerolen 
1052			endif 
1052 c9			      ret 
1053			 
1053			 
1053			;------------------------------------------------------------------------------ 
1053			;     free                                                                    : 
1053			;                                                                             : 
1053			; Description                                                                 : 
1053			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1053			;     returned by malloc, otherwise the behaviour is undefined.               : 
1053			;                                                                             : 
1053			;     Where possible, directly adjacent free blocks will be merged together   : 
1053			;     into larger blocks to help ensure that the heap does not become         : 
1053			;     excessively fragmented.                                                 : 
1053			;                                                                             : 
1053			;     free does not clear or set any other value into the freed space, and    : 
1053			;     therefore its contents may be visible through subsequent malloc's. The  : 
1053			;     caller should clear the freed space as required.                        : 
1053			;                                                                             : 
1053			;     This implementation of free uses the stack exclusively, and is          : 
1053			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1053			;     advisable to disable interrupts before calling free, and recommended    : 
1053			;     to avoid the use of free inside ISRs in general.                        : 
1053			;                                                                             : 
1053			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1053			;                                                                             : 
1053			; Parameters                                                                  : 
1053			;     HL  Pointer to address of first byte of allocation to be freed          : 
1053			;                                                                             : 
1053			; Returns                                                                     : 
1053			;     Nothing                                                                 : 
1053			;                                                                             : 
1053			; Stack frame                                                                 : 
1053			;       |             |                                                       : 
1053			;       +-------------+                                                       : 
1053			;       |     BC      |                                                       : 
1053			;       +-------------+                                                       : 
1053			;       |     DE      |                                                       : 
1053			;       +-------------+                                                       : 
1053			;       |     IX      |                                                       : 
1053			;       +-------------+                                                       : 
1053			;       |  prev_free  |                                                       : 
1053			;   +2  +-------------+                                                       : 
1053			;       |  next_free  |                                                       : 
1053			;   +0  +-------------+                                                       : 
1053			;       |             |                                                       : 
1053			;                                                                             : 
1053			;------------------------------------------------------------------------------ 
1053			free: 
1053 c5			      push  BC 
1054 d5			      push  DE 
1055 dd e5		      push  IX 
1057			 
1057 7c			      ld    A, H                    ; Exit if ptr is null 
1058 b5			      or    L 
1059 ca 1d 11		      jp    Z, free_early_exit 
105c			 
105c			      ; Set up stack frame 
105c eb			      ex    DE, HL 
105d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1060 39			      add   HL, SP 
1061 f9			      ld    SP, HL 
1062 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1066 dd 39		      add   IX, SP 
1068			 
1068			      ; The address in HL points to the start of the useable allocated space, 
1068			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1068			      ; address of the block itself. 
1068 eb			      ex    DE, HL 
1069 11 fc ff		      ld    DE, -4 
106c 19			      add   HL, DE 
106d			 
106d			      ; An allocated block must have a null next block pointer in it 
106d 7e			      ld    A, (HL) 
106e 23			      inc   HL 
106f b6			      or    (HL) 
1070 c2 18 11		      jp    NZ, free_done 
1073			 
1073 2b			      dec   HL 
1074			 
1074 44			      ld    B, H                    ; Copy HL to BC 
1075 4d			      ld    C, L 
1076			 
1076			      ; Loop through the free list to find the first block with an address 
1076			      ; higher than the block being freed 
1076 21 14 56		      ld    HL, free_list 
1079			 
1079			free_find_higher_block: 
1079 5e			      ld    E, (HL)                 ; Load next ptr from free block 
107a 23			      inc   HL 
107b 56			      ld    D, (HL) 
107c 2b			      dec   HL 
107d			 
107d dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1080 dd 72 01		      ld    (IX+1), D 
1083 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1086 dd 74 03		      ld    (IX+3), H 
1089			 
1089 78			      ld    A, B                    ; Check if DE is greater than BC 
108a ba			      cp    D                       ; Compare MSB first 
108b 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
108d 30 04		      jr    NC, free_find_higher_block_skip 
108f 79			      ld    A, C 
1090 bb			      cp    E                       ; Then compare LSB 
1091 38 08		      jr    C, free_found_higher_block 
1093			 
1093			free_find_higher_block_skip: 
1093 7a			      ld    A, D                    ; Reached the end of the free list? 
1094 b3			      or    E 
1095 ca 18 11		      jp    Z, free_done 
1098			 
1098 eb			      ex    DE, HL 
1099			 
1099 18 de		      jr    free_find_higher_block 
109b			 
109b			free_found_higher_block: 
109b			      ; Insert freed block between prev and next free blocks 
109b 71			      ld    (HL), C                 ; Point prev free block to freed block 
109c 23			      inc   HL 
109d 70			      ld    (HL), B 
109e			 
109e 60			      ld    H, B                    ; Point freed block at next free block 
109f 69			      ld    L, C 
10a0 73			      ld    (HL), E 
10a1 23			      inc   HL 
10a2 72			      ld    (HL), D 
10a3			 
10a3			      ; Check if the freed block is adjacent to the next free block 
10a3 23			      inc   HL                      ; Load size of freed block into HL 
10a4 5e			      ld    E, (HL) 
10a5 23			      inc   HL 
10a6 56			      ld    D, (HL) 
10a7 eb			      ex    DE, HL 
10a8			 
10a8 09			      add   HL, BC                  ; Add addr of freed block and its size 
10a9			 
10a9 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
10ac dd 56 01		      ld    D, (IX+1) 
10af			 
10af b7			      or    A                       ; Clear the carry flag 
10b0 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
10b2 20 22		      jr    NZ, free_check_adjacent_to_prev 
10b4			 
10b4			      ; Freed block is adjacent to next, merge into one bigger block 
10b4 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
10b5 5e			      ld    E, (HL) 
10b6 23			      inc   HL 
10b7 56			      ld    D, (HL) 
10b8 e5			      push  HL                      ; Save ptr to next block for later 
10b9			 
10b9 60			      ld    H, B                    ; Store ptr from next block into freed block 
10ba 69			      ld    L, C 
10bb 73			      ld    (HL), E 
10bc 23			      inc   HL 
10bd 72			      ld    (HL), D 
10be			 
10be e1			      pop   HL                      ; Restore ptr to next block 
10bf 23			      inc   HL                      ; Load size of next block into DE 
10c0 5e			      ld    E, (HL) 
10c1 23			      inc   HL 
10c2 56			      ld    D, (HL) 
10c3 d5			      push  DE                      ; Save next block size for later 
10c4			 
10c4 60			      ld    H, B                    ; Load size of freed block into HL 
10c5 69			      ld    L, C 
10c6 23			      inc   HL 
10c7 23			      inc   HL 
10c8 5e			      ld    E, (HL) 
10c9 23			      inc   HL 
10ca 56			      ld    D, (HL) 
10cb eb			      ex    DE, HL 
10cc			 
10cc d1			      pop   DE                      ; Restore size of next block 
10cd 19			      add   HL, DE                  ; Add sizes of both blocks 
10ce eb			      ex    DE, HL 
10cf			 
10cf 60			      ld    H, B                    ; Store new bigger size into freed block 
10d0 69			      ld    L, C 
10d1 23			      inc   HL 
10d2 23			      inc   HL 
10d3 73			      ld    (HL), E 
10d4 23			      inc   HL 
10d5 72			      ld    (HL), D 
10d6			 
10d6			free_check_adjacent_to_prev: 
10d6			      ; Check if the freed block is adjacent to the prev free block 
10d6 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
10d9 dd 66 03		      ld    H, (IX+3) 
10dc			 
10dc 23			      inc   HL                      ; Size of prev free block into DE 
10dd 23			      inc   HL 
10de 5e			      ld    E, (HL) 
10df 23			      inc   HL 
10e0 56			      ld    D, (HL) 
10e1 2b			      dec   HL 
10e2 2b			      dec   HL 
10e3 2b			      dec   HL 
10e4			 
10e4 19			      add   HL, DE                  ; Add prev block addr and size 
10e5			 
10e5 b7			      or    A                       ; Clear the carry flag 
10e6 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
10e8 20 2e		      jr    NZ, free_done 
10ea			 
10ea			      ; Freed block is adjacent to prev, merge into one bigger block 
10ea 60			      ld    H, B                    ; Load next ptr from freed block into DE 
10eb 69			      ld    L, C 
10ec 5e			      ld    E, (HL) 
10ed 23			      inc   HL 
10ee 56			      ld    D, (HL) 
10ef e5			      push  HL                      ; Save freed block ptr for later 
10f0			 
10f0 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
10f3 dd 66 03		      ld    H, (IX+3) 
10f6 73			      ld    (HL), E 
10f7 23			      inc   HL 
10f8 72			      ld    (HL), D 
10f9			 
10f9 e1			      pop   HL                      ; Restore freed block ptr 
10fa 23			      inc   HL                      ; Load size of freed block into DE 
10fb 5e			      ld    E, (HL) 
10fc 23			      inc   HL 
10fd 56			      ld    D, (HL) 
10fe d5			      push  DE                      ; Save freed block size for later 
10ff			 
10ff dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1102 dd 66 03		      ld    H, (IX+3) 
1105 23			      inc   HL 
1106 23			      inc   HL 
1107 5e			      ld    E, (HL) 
1108 23			      inc   HL 
1109 56			      ld    D, (HL) 
110a			 
110a e1			      pop   HL                      ; Add sizes of both blocks 
110b 19			      add   HL, DE 
110c eb			      ex    DE, HL 
110d			 
110d dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1110 dd 66 03		      ld    H, (IX+3) 
1113 23			      inc   HL 
1114 23			      inc   HL 
1115 73			      ld    (HL), E 
1116 23			      inc   HL 
1117 72			      ld    (HL), D 
1118			 
1118			free_done: 
1118 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
111b 39			      add   HL, SP 
111c f9			      ld    SP, HL 
111d			 
111d			free_early_exit: 
111d dd e1		      pop   IX 
111f d1			      pop   DE 
1120 c1			      pop   BC 
1121			 
1121 c9			      ret 
1122			 
1122			; moved to firmware.asm 
1122			; 
1122			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1122			;                  .dw   0 
1122			 
1122			 
1122			endif 
1122			 
1122			 
1122			if MALLOC_3 
1122			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1122			;heap_start        .equ  0x9000      ; Starting address of heap 
1122			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1122			; 
1122			 ;     .org 0 
1122			  ;    jp    main 
1122			; 
1122			; 
1122			 ;     .org  0x100 
1122			;main: 
1122			 ;     ld    HL, 0x8100 
1122			  ;    ld    SP, HL 
1122			; 
1122			;      call  heap_init 
1122			 
1122			      ; Make some allocations 
1122			;      ld    HL, 12 
1122			;      call  malloc            ; Allocates 0x9004 
1122			; 
1122			 ;     ld    HL, 12 
1122			;      call  malloc            ; Allocates 0x9014 
1122			 
1122			;      ld    HL, 12 
1122			;      call  malloc            ; Allocates 0x9024 
1122			 
1122			      ; Free some allocations 
1122			;      ld    HL, 0x9014 
1122			;      call  free 
1122			 
1122			;      ld    HL, 0x9004 
1122			;      call  free 
1122			; 
1122			;      ld    HL, 0x9024 
1122			;      call  free 
1122			 
1122			 
1122			 ;     halt 
1122			 
1122			 
1122			;------------------------------------------------------------------------------ 
1122			;     heap_init                                                               : 
1122			;                                                                             : 
1122			; Description                                                                 : 
1122			;     Initialise the heap and make it ready for malloc and free operations.   : 
1122			;                                                                             : 
1122			;     The heap is maintained as a linked list, starting with an initial       : 
1122			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1122			;     the first free block in the heap. Each block then points to the next    : 
1122			;     free block within the heap, and the free list ends at the first block   : 
1122			;     with a null pointer to the next free block.                             : 
1122			;                                                                             : 
1122			; Parameters                                                                  : 
1122			;     Inputs are compile-time only. Two defines which specify the starting    : 
1122			;     address of the heap and its size are required, along with a memory      : 
1122			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1122			;     principally stores a pointer to the first free block in the heap.       : 
1122			;                                                                             : 
1122			; Returns                                                                     : 
1122			;     Nothing                                                                 : 
1122			;------------------------------------------------------------------------------ 
1122			heap_init: 
1122			      push  HL 
1122			 
1122			      ; Initialise free list struct 
1122			      ld    HL, heap_start 
1122			      ld    (free_list), HL 
1122			      ld    HL, 0 
1122			      ld    (free_list+2), HL 
1122			 
1122			      ; Insert first free block at bottom of heap, consumes entire heap 
1122			      ld    HL, heap_start+heap_size-4 
1122			      ld    (heap_start), HL        ; Next block (end of free list) 
1122			      ld    HL, heap_size-4 
1122			      ld    (heap_start+2), HL      ; Block size 
1122			 
1122			      ; Insert end of free list block at top of heap - two null words will 
1122			      ; terminate the free list 
1122			      ld    HL, 0 
1122			      ld    (heap_start+heap_size-2), HL 
1122			      ld    (heap_start+heap_size-4), HL 
1122			 
1122			      pop   HL 
1122			 
1122			      ret 
1122			 
1122			 
1122			;------------------------------------------------------------------------------ 
1122			;     malloc                                                                  : 
1122			;                                                                             : 
1122			; Description                                                                 : 
1122			;     Allocates the wanted space from the heap and returns the address of the : 
1122			;     first useable byte of the allocation.                                   : 
1122			;                                                                             : 
1122			;     Allocations can happen in one of two ways:                              : 
1122			;                                                                             : 
1122			;     1. A free block may be found which is the exact size wanted. In this    : 
1122			;        case the block is removed from the free list and retuedn to the      : 
1122			;        caller.                                                              : 
1122			;     2. A free block may be found which is larger than the size wanted. In   : 
1122			;        this case, the larger block is split into two. The first portion of  : 
1122			;        this block will become the requested space by the malloc call and    : 
1122			;        is returned to the caller. The second portion becomes a new free     : 
1122			;        block, and the free list is adjusted to maintain continuity via this : 
1122			;        newly created block.                                                 : 
1122			;                                                                             : 
1122			;     malloc does not set any initial value in the allocated space, the       : 
1122			;     caller is required to do this as required.                              : 
1122			;                                                                             : 
1122			;     This implementation of malloc uses the stack exclusively, and is        : 
1122			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1122			;     advisable to disable interrupts before calling malloc, and recommended  : 
1122			;     to avoid the use of malloc inside ISRs in general.                      : 
1122			;                                                                             : 
1122			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1122			;                                                                             : 
1122			; Parameters                                                                  : 
1122			;     HL  Number of bytes wanted                                              : 
1122			;                                                                             : 
1122			; Returns                                                                     : 
1122			;     HL  Address of the first useable byte of the allocation                 : 
1122			;                                                                             : 
1122			; Flags                                                                       : 
1122			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1122			;                                                                             : 
1122			; Stack frame                                                                 : 
1122			;       |             |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |     BC      |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |     DE      |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |     IX      |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |  prev_free  |                                                       : 
1122			;   +4  +-------------+                                                       : 
1122			;       |  this_free  |                                                       : 
1122			;   +2  +-------------+                                                       : 
1122			;       |  next_free  |                                                       : 
1122			;   +0  +-------------+                                                       : 
1122			;       |             |                                                       : 
1122			;                                                                             : 
1122			;------------------------------------------------------------------------------ 
1122			malloc: 
1122			      push  BC 
1122			      push  DE 
1122			      push  IX 
1122			 
1122			      ld    A, H                    ; Exit if no space requested 
1122			      or    L 
1122			      jp    Z, malloc_early_exit 
1122			 
1122			      ; Set up stack frame 
1122			      ex    DE, HL 
1122			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1122			      add   HL, SP 
1122			      ld    SP, HL 
1122			      ld    IX, 0                   ; Use IX as a frame pointer 
1122			      add   IX, SP 
1122			 
1122			      ; Setup initial state 
1122			      ld    HL, 4                   ; want must also include space used by block struct 
1122			      add   HL, DE 
1122			 
1122			      ld    B, H                    ; Move want to BC 
1122			      ld    C, L 
1122			 
1122			      ld    HL, free_list           ; Store prev_free ptr to stack 
1122			      ld    (IX+4), L 
1122			      ld    (IX+5), H 
1122			 
1122			      ld    E, (HL)                 ; Store this_free ptr to stack 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      ld    (IX+2), E 
1122			      ld    (IX+3), D 
1122			      ex    DE, HL                  ; this_free ptr into HL 
1122			 
1122			      ; Loop through free block list to find some space 
1122			malloc_find_space: 
1122			      ld    E, (HL)                 ; Load next_free ptr into DE 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			 
1122			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1122			      or    E 
1122			      jp    Z, malloc_no_space 
1122			 
1122			      ld    (IX+0), E               ; Store next_free ptr to stack 
1122			      ld    (IX+1), D 
1122			 
1122			      ; Does this block have enough space to make the allocation? 
1122			      inc   HL                      ; Load free block size into DE 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			 
1122			      ex    DE, HL                  ; Check size of block against want 
1122			      or    A                       ; Ensure carry flag clear 
1122			      sbc   HL, BC 
1122			      push  HL                      ; Store the result for later (new block size) 
1122			 
1122			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1122			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1122			 
1122			      ; this_free block is not big enough, setup ptrs to test next free block 
1122			      pop   HL                      ; Discard previous result 
1122			 
1122			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1122			      ld    H, (IX+3) 
1122			      ld    (IX+4), L 
1122			      ld    (IX+5), H 
1122			 
1122			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1122			      ld    H, (IX+1) 
1122			      ld    (IX+2), L 
1122			      ld    (IX+3), H 
1122			 
1122			      jr    malloc_find_space 
1122			 
1122			      ; split a bigger block into two - requested size and remaining size 
1122			malloc_alloc_split: 
1122			      ex    DE, HL                  ; Calculate address of new free block 
1122			      dec   HL 
1122			      dec   HL 
1122			      dec   HL 
1122			      add   HL, BC 
1122			 
1122			      ; Create a new block and point it at next_free 
1122			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1122			      ld    D, (IX+1) 
1122			 
1122			      ld    (HL), E                 ; Store next_free ptr into new block 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			      pop   DE                      ; Store size of new block into new block 
1122			      inc   HL 
1122			      ld    (HL), E 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			      ; Update this_free ptr to point to new block 
1122			      dec   HL 
1122			      dec   HL 
1122			      dec   HL 
1122			 
1122			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1122			      ld    D, (IX+3) 
1122			 
1122			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1122			      ld    (IX+3), H 
1122			 
1122			      ; Modify this_free block to be allocation 
1122			      ex    DE, HL 
1122			      xor   A                       ; Null the next block ptr of allocated block 
1122			      ld    (HL), A 
1122			      inc   HL 
1122			      ld    (HL), A 
1122			 
1122			      inc   HL                      ; Store want size into allocated block 
1122			      ld    (HL), C 
1122			      inc   HL 
1122			      ld    (HL), B 
1122			      inc   HL 
1122			      push  HL                      ; Address of allocation to return 
1122			 
1122			      jr    malloc_update_links 
1122			 
1122			malloc_alloc_fit: 
1122			      pop   HL                      ; Dont need new block size, want is exact fit 
1122			 
1122			      ; Modify this_free block to be allocation 
1122			      ex    DE, HL 
1122			      dec   HL 
1122			      dec   HL 
1122			      dec   HL 
1122			 
1122			      xor   A                       ; Null the next block ptr of allocated block 
1122			      ld    (HL), A 
1122			      inc   HL 
1122			      ld    (HL), A 
1122			 
1122			      inc   HL                      ; Store address of allocation to return 
1122			      inc   HL 
1122			      inc   HL 
1122			      push  HL 
1122			 
1122			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1122			      ld    L, (IX+0)               ; next_free to HL 
1122			      ld    H, (IX+1) 
1122			 
1122			      ld    (IX+2), L               ; HL to this_free 
1122			      ld    (IX+3), H 
1122			 
1122			 
1122			malloc_update_links: 
1122			      ; Update prev_free ptr to point to this_free 
1122			      ld    L, (IX+4)               ; prev_free ptr to HL 
1122			      ld    H, (IX+5) 
1122			 
1122			      ld    E, (IX+2)               ; this_free ptr to DE 
1122			      ld    D, (IX+3) 
1122			 
1122			      ld    (HL), E                 ; this_free ptr into prev_free 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			      ; Clear the Z flag to indicate successful allocation 
1122			      ld    A, D 
1122			      or    E 
1122			 
1122			      pop   DE                      ; Address of allocation 
1122			 
1122			malloc_no_space: 
1122			      ld    HL, 6                   ; Clean up stack frame 
1122			      add   HL, SP 
1122			      ld    SP, HL 
1122			 
1122			      ex    DE, HL                  ; Alloc addr into HL for return 
1122			 
1122			malloc_early_exit: 
1122			      pop   IX 
1122			      pop   DE 
1122			      pop   BC 
1122			 
1122			      ret 
1122			 
1122			 
1122			;------------------------------------------------------------------------------ 
1122			;     free                                                                    : 
1122			;                                                                             : 
1122			; Description                                                                 : 
1122			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1122			;     returned by malloc, otherwise the behaviour is undefined.               : 
1122			;                                                                             : 
1122			;     Where possible, directly adjacent free blocks will be merged together   : 
1122			;     into larger blocks to help ensure that the heap does not become         : 
1122			;     excessively fragmented.                                                 : 
1122			;                                                                             : 
1122			;     free does not clear or set any other value into the freed space, and    : 
1122			;     therefore its contents may be visible through subsequent malloc's. The  : 
1122			;     caller should clear the freed space as required.                        : 
1122			;                                                                             : 
1122			;     This implementation of free uses the stack exclusively, and is          : 
1122			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1122			;     advisable to disable interrupts before calling free, and recommended    : 
1122			;     to avoid the use of free inside ISRs in general.                        : 
1122			;                                                                             : 
1122			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1122			;                                                                             : 
1122			; Parameters                                                                  : 
1122			;     HL  Pointer to address of first byte of allocation to be freed          : 
1122			;                                                                             : 
1122			; Returns                                                                     : 
1122			;     Nothing                                                                 : 
1122			;                                                                             : 
1122			; Stack frame                                                                 : 
1122			;       |             |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |     BC      |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |     DE      |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |     IX      |                                                       : 
1122			;       +-------------+                                                       : 
1122			;       |  prev_free  |                                                       : 
1122			;   +2  +-------------+                                                       : 
1122			;       |  next_free  |                                                       : 
1122			;   +0  +-------------+                                                       : 
1122			;       |             |                                                       : 
1122			;                                                                             : 
1122			;------------------------------------------------------------------------------ 
1122			free: 
1122			      push  BC 
1122			      push  DE 
1122			      push  IX 
1122			 
1122			      ld    A, H                    ; Exit if ptr is null 
1122			      or    L 
1122			      jp    Z, free_early_exit 
1122			 
1122			      ; Set up stack frame 
1122			      ex    DE, HL 
1122			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1122			      add   HL, SP 
1122			      ld    SP, HL 
1122			      ld    IX, 0                   ; Use IX as a frame pointer 
1122			      add   IX, SP 
1122			 
1122			      ; The address in HL points to the start of the useable allocated space, 
1122			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1122			      ; address of the block itself. 
1122			      ex    DE, HL 
1122			      ld    DE, -4 
1122			      add   HL, DE 
1122			 
1122			      ; An allocated block must have a null next block pointer in it 
1122			      ld    A, (HL) 
1122			      inc   HL 
1122			      or    (HL) 
1122			      jp    NZ, free_done 
1122			 
1122			      dec   HL 
1122			 
1122			      ld    B, H                    ; Copy HL to BC 
1122			      ld    C, L 
1122			 
1122			      ; Loop through the free list to find the first block with an address 
1122			      ; higher than the block being freed 
1122			      ld    HL, free_list 
1122			 
1122			free_find_higher_block: 
1122			      ld    E, (HL)                 ; Load next ptr from free block 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      dec   HL 
1122			 
1122			      ld    (IX+0), E               ; Save ptr to next free block 
1122			      ld    (IX+1), D 
1122			      ld    (IX+2), L               ; Save ptr to prev free block 
1122			      ld    (IX+3), H 
1122			 
1122			      ld    A, B                    ; Check if DE is greater than BC 
1122			      cp    D                       ; Compare MSB first 
1122			      jr    Z, $+4                  ; MSB the same, compare LSB 
1122			      jr    NC, free_find_higher_block_skip 
1122			      ld    A, C 
1122			      cp    E                       ; Then compare LSB 
1122			      jr    C, free_found_higher_block 
1122			 
1122			free_find_higher_block_skip: 
1122			      ld    A, D                    ; Reached the end of the free list? 
1122			      or    E 
1122			      jp    Z, free_done 
1122			 
1122			      ex    DE, HL 
1122			 
1122			      jr    free_find_higher_block 
1122			 
1122			free_found_higher_block: 
1122			      ; Insert freed block between prev and next free blocks 
1122			      ld    (HL), C                 ; Point prev free block to freed block 
1122			      inc   HL 
1122			      ld    (HL), B 
1122			 
1122			      ld    H, B                    ; Point freed block at next free block 
1122			      ld    L, C 
1122			      ld    (HL), E 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			      ; Check if the freed block is adjacent to the next free block 
1122			      inc   HL                      ; Load size of freed block into HL 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      ex    DE, HL 
1122			 
1122			      add   HL, BC                  ; Add addr of freed block and its size 
1122			 
1122			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1122			      ld    D, (IX+1) 
1122			 
1122			      or    A                       ; Clear the carry flag 
1122			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1122			      jr    NZ, free_check_adjacent_to_prev 
1122			 
1122			      ; Freed block is adjacent to next, merge into one bigger block 
1122			      ex    DE, HL                  ; Load next ptr from next block into DE 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      push  HL                      ; Save ptr to next block for later 
1122			 
1122			      ld    H, B                    ; Store ptr from next block into freed block 
1122			      ld    L, C 
1122			      ld    (HL), E 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			      pop   HL                      ; Restore ptr to next block 
1122			      inc   HL                      ; Load size of next block into DE 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      push  DE                      ; Save next block size for later 
1122			 
1122			      ld    H, B                    ; Load size of freed block into HL 
1122			      ld    L, C 
1122			      inc   HL 
1122			      inc   HL 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      ex    DE, HL 
1122			 
1122			      pop   DE                      ; Restore size of next block 
1122			      add   HL, DE                  ; Add sizes of both blocks 
1122			      ex    DE, HL 
1122			 
1122			      ld    H, B                    ; Store new bigger size into freed block 
1122			      ld    L, C 
1122			      inc   HL 
1122			      inc   HL 
1122			      ld    (HL), E 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			free_check_adjacent_to_prev: 
1122			      ; Check if the freed block is adjacent to the prev free block 
1122			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1122			      ld    H, (IX+3) 
1122			 
1122			      inc   HL                      ; Size of prev free block into DE 
1122			      inc   HL 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      dec   HL 
1122			      dec   HL 
1122			      dec   HL 
1122			 
1122			      add   HL, DE                  ; Add prev block addr and size 
1122			 
1122			      or    A                       ; Clear the carry flag 
1122			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1122			      jr    NZ, free_done 
1122			 
1122			      ; Freed block is adjacent to prev, merge into one bigger block 
1122			      ld    H, B                    ; Load next ptr from freed block into DE 
1122			      ld    L, C 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      push  HL                      ; Save freed block ptr for later 
1122			 
1122			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1122			      ld    H, (IX+3) 
1122			      ld    (HL), E 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			      pop   HL                      ; Restore freed block ptr 
1122			      inc   HL                      ; Load size of freed block into DE 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			      push  DE                      ; Save freed block size for later 
1122			 
1122			      ld    L, (IX+2)               ; Load size of prev block into DE 
1122			      ld    H, (IX+3) 
1122			      inc   HL 
1122			      inc   HL 
1122			      ld    E, (HL) 
1122			      inc   HL 
1122			      ld    D, (HL) 
1122			 
1122			      pop   HL                      ; Add sizes of both blocks 
1122			      add   HL, DE 
1122			      ex    DE, HL 
1122			 
1122			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1122			      ld    H, (IX+3) 
1122			      inc   HL 
1122			      inc   HL 
1122			      ld    (HL), E 
1122			      inc   HL 
1122			      ld    (HL), D 
1122			 
1122			free_done: 
1122			      ld    HL, 4                   ; Clean up stack frame 
1122			      add   HL, SP 
1122			      ld    SP, HL 
1122			 
1122			free_early_exit: 
1122			      pop   IX 
1122			      pop   DE 
1122			      pop   BC 
1122			 
1122			      ret 
1122			 
1122			 
1122			;      .org 0x8000 
1122			; 
1122			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1122			 ;                 .dw   0 
1122			 
1122			endif 
1122			 
1122			 
1122			if MALLOC_4 
1122			 
1122			; My memory allocation code. Very very simple.... 
1122			; allocate space under 250 chars 
1122			 
1122			heap_init: 
1122				; init start of heap as zero 
1122				;  
1122			 
1122				ld hl, heap_start 
1122				ld a, 0 
1122				ld (hl), a      ; empty block 
1122				inc hl 
1122				ld a, 0 
1122				ld (hl), a      ; length of block 
1122				; write end of list 
1122				inc hl 
1122				ld a,(hl) 
1122				inc hl 
1122				ld a,(hl) 
1122				 
1122			 
1122				; init some malloc vars 
1122			 
1122				ld hl, 0 
1122				ld (free_list), hl       ; store last malloc location 
1122			 
1122				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1122				ld a, 0 
1122				ld (hl), a 
1122			 
1122			 
1122				ld hl, heap_start 
1122				;  
1122				  
1122				ret 
1122			 
1122			 
1122			;    free block marker 
1122			;    requested size  
1122			;    pointer to next block 
1122			;    .... 
1122			;    next block marker 
1122			 
1122			 
1122			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1122			; 
1122			 
1122			 
1122			malloc:  
1122				push de 
1122				push bc 
1122				push af 
1122			 
1122				; hl space required 
1122				 
1122				ld c, l    ; hold space   (TODO only a max of 255) 
1122			 
1122			;	inc c     ; TODO BUG need to fix memory leak on push str 
1122			;	inc c 
1122			;	inc c 
1122			;	inc c 
1122			;	inc c 
1122			;	inc c 
1122			;	inc c 
1122			 
1122			 
1122			 
1122				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1122			 
1122				ld a, (free_list+3) 
1122				cp 0 
1122				jr z, .contheap 
1122			 
1122				ld hl, (free_list)     ; get last alloc 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "mrs" 
1122						CALLMONITOR 
1122					endif 
1122				jr .startalloc 
1122			 
1122			.contheap: 
1122				ld hl, heap_start 
1122			 
1122			.startalloc: 
1122			 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "mym" 
1122						CALLMONITOR 
1122					endif 
1122			.findblock: 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "mmf" 
1122						CALLMONITOR 
1122					endif 
1122			 
1122				ld a,(hl)  
1122				; if byte is zero then clear to use 
1122			 
1122				cp 0 
1122				jr z, .foundemptyblock 
1122			 
1122				; if byte is not clear 
1122				;     then byte is offset to next block 
1122			 
1122				inc hl 
1122				ld a, (hl) ; get size 
1122			.nextblock:	inc hl 
1122					ld e, (hl) 
1122					inc hl 
1122					ld d, (hl) 
1122					ex de, hl 
1122			;	inc hl  ; move past the store space 
1122			;	inc hl  ; move past zero index  
1122			 
1122				; TODO detect no more space 
1122			 
1122				push hl 
1122				ld de, heap_end 
1122				call cmp16 
1122				pop hl 
1122				jr nc, .nospace 
1122			 
1122				jr .findblock 
1122			 
1122			.nospace: ld hl, 0 
1122				jp .exit 
1122			 
1122			 
1122			.foundemptyblock:	 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "mme" 
1122						CALLMONITOR 
1122					endif 
1122			 
1122			; TODO has block enough space if reusing??? 
1122			 
1122				;  
1122			 
1122			; see if this block has been previously used 
1122				inc hl 
1122				ld a, (hl) 
1122				dec hl 
1122				cp 0 
1122				jr z, .newblock 
1122			 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "meR" 
1122						CALLMONITOR 
1122					endif 
1122			 
1122			; no reusing previously allocated block 
1122			 
1122			; is it smaller than previously used? 
1122				 
1122				inc hl    ; move to size 
1122				ld a, c 
1122				sub (hl)        ; we want c < (hl) 
1122				dec hl    ; move back to marker 
1122			        jr z, .findblock 
1122			 
1122				; update with the new size which should be lower 
1122			 
1122			        ;inc  hl   ; negate next move. move back to size  
1122			 
1122			.newblock: 
1122				; need to be at marker here 
1122			 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "meN" 
1122						CALLMONITOR 
1122					endif 
1122			 
1122			 
1122				ld a, c 
1122			 
1122				ld (free_list+3), a	 ; flag resume from last malloc  
1122				ld (free_list), hl    ; save out last location 
1122			 
1122			 
1122				;inc a     ; space for length byte 
1122				ld (hl), a     ; save block in use marker 
1122			 
1122				inc hl   ; move to space marker 
1122				ld (hl), a    ; save new space 
1122			 
1122				inc hl   ; move to start of allocated area 
1122				 
1122			;	push hl     ; save where we are - 1  
1122			 
1122			;	inc hl  ; move past zero index  
1122				; skip space to set down new marker 
1122			 
1122				; provide some extra space for now 
1122			 
1122				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1122				inc a 
1122				inc a 
1122			 
1122				push hl   ; save where we are in the node block 
1122			 
1122				call addatohl 
1122			 
1122				; write linked list point 
1122			 
1122				pop de     ; get our node position 
1122				ex de, hl 
1122			 
1122				ld (hl), e 
1122				inc hl 
1122				ld (hl), d 
1122			 
1122				inc hl 
1122			 
1122				; now at start of allocated data so save pointer 
1122			 
1122				push hl 
1122			 
1122				; jump to position of next node and setup empty header in DE 
1122			 
1122				ex de, hl 
1122			 
1122			;	inc hl ; move past end of block 
1122			 
1122				ld a, 0 
1122				ld (hl), a   ; empty marker 
1122				inc hl 
1122				ld (hl), a   ; size 
1122				inc hl  
1122				ld (hl), a   ; ptr 
1122				inc hl 
1122				ld (hl), a   ; ptr 
1122			 
1122			 
1122				pop hl 
1122			 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "mmr" 
1122						CALLMONITOR 
1122					endif 
1122			 
1122			.exit: 
1122				pop af 
1122				pop bc 
1122				pop de  
1122				ret 
1122			 
1122			 
1122			 
1122			 
1122			free:  
1122				push hl 
1122				push af 
1122				; get address in hl 
1122			 
1122					if DEBUG_FORTH_MALLOC_INT 
1122						DMARK "fre" 
1122						CALLMONITOR 
1122					endif 
1122				; data is at hl - move to block count 
1122				dec hl 
1122				dec hl    ; get past pointer 
1122				dec hl 
1122			 
1122				ld a, (hl)    ; need this for a validation check 
1122			 
1122				dec hl    ; move to block marker 
1122			 
1122				; now check that the block count and block marker are the same  
1122			        ; this checks that we are on a malloc node and not random memory 
1122			        ; OK a faint chance this could be a problem but rare - famous last words! 
1122			 
1122				ld c, a 
1122				ld a, (hl)    
1122			 
1122				cp c 
1122				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1122			 
1122				; yes good chance we are on a malloc node 
1122			 
1122				ld a, 0      
1122				ld (hl), a   ; mark as free 
1122			 
1122				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1122			 
1122			.freeignore:  
1122			 
1122				pop af 
1122				pop hl 
1122			 
1122				ret 
1122			 
1122			 
1122			 
1122			endif 
1122			 
1122			; eof 
# End of file firmware_memory.asm
1122			  
1122			; device C  
1122			if SOUND_ENABLE  
1122				include "firmware_sound.asm"  
1122			endif  
1122			  
1122			include "firmware_diags.asm"  
1122			; Hardware diags menu 
1122			 
1122			 
1122 .. 00		hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1143 .. 00		hd_menu2:   db "        2: Editor",0   
1155			;hd_menu2:   db "        2: Editor       6: BASIC",0   
1155 .. 00		hd_menu3:   db "        3: Storage",0 
1168 .. 00		hd_menu4:   db "0=quit  4: Debug",0 
1179 .. 00		hd_don:     db "ON",0 
117c .. 00		hd_doff:     db "OFF",0 
1180			 
1180			 
1180			 
1180			hardware_diags:       
1180			 
1180			.diagmenu: 
1180 cd 69 09			call clear_display 
1183 3e 00			ld a, display_row_1 
1185 11 22 11			ld de, hd_menu1 
1188 cd 7c 09			call str_at_display 
118b			 
118b 3e 28			ld a, display_row_2 
118d 11 43 11			ld de, hd_menu2 
1190 cd 7c 09			call str_at_display 
1193			 
1193 3e 50			ld a, display_row_3 
1195 11 55 11			ld de, hd_menu3 
1198 cd 7c 09			call str_at_display 
119b			 
119b 3e 78			ld a,  display_row_4 
119d 11 68 11			ld de, hd_menu4 
11a0 cd 7c 09			call str_at_display 
11a3			 
11a3				; display debug state 
11a3			 
11a3 11 79 11			ld de, hd_don 
11a6 3a 74 e3			ld a, (os_view_disable) 
11a9 fe 00			cp 0 
11ab 28 03			jr z, .distog 
11ad 11 7c 11			ld de, hd_doff 
11b0 3e 89		.distog: ld a, display_row_4+17 
11b2 cd 7c 09			call str_at_display 
11b5			 
11b5 cd 8c 09			call update_display 
11b8			 
11b8 cd e9 55			call cin_wait 
11bb			 
11bb			 
11bb			 
11bb fe 34			cp '4' 
11bd 20 0f			jr nz, .diagn1 
11bf			 
11bf				; debug toggle 
11bf			 
11bf 3a 74 e3			ld a, (os_view_disable) 
11c2 06 2a			ld b, '*' 
11c4 fe 00			cp 0 
11c6 28 02			jr z, .debtog 
11c8 06 00			ld b, 0 
11ca			.debtog:	 
11ca 78				ld a,b 
11cb 32 74 e3			ld (os_view_disable),a 
11ce			 
11ce fe 30		.diagn1: cp '0' 
11d0 c8				 ret z 
11d1			 
11d1			;	cp '1' 
11d1			;       jp z, matrix	 
11d1			;   TODO keyboard matrix test 
11d1			 
11d1 fe 32			cp '2' 
11d3 ca da 11			jp z, .diagedit 
11d6			 
11d6			;if ENABLE_BASIC 
11d6			;	cp '6' 
11d6			;	jp z, basic 
11d6			;endif 
11d6			  
11d6 c3 80 11			jp .diagmenu 
11d9			 
11d9			 
11d9 c9				ret 
11da			 
11da			; debug editor 
11da			 
11da			.diagedit: 
11da			 
11da 21 75 e3			ld hl, scratch 
11dd			;	ld bc, 250 
11dd			;	ldir 
11dd				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
11dd 3e 00			ld a, 0 
11df 77				ld (hl), a 
11e0 23				inc hl 
11e1 77				ld (hl), a 
11e2 23				inc hl 
11e3 77				ld (hl), a 
11e4			 
11e4 cd 69 09		        call clear_display 
11e7 cd 8c 09			call update_display 
11ea 3e 01			ld a, 1 
11ec 32 80 ee			ld (hardware_diag), a 
11ef			.diloop: 
11ef 3e 00			ld a, display_row_1 
11f1 0e 00			ld c, 0 
11f3 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
11f5 1e 28			ld e, 40 
11f7			 
11f7 21 75 e3			ld hl, scratch	 
11fa cd ef 0a			call input_str 
11fd			 
11fd 3e 28			ld a, display_row_2 
11ff 11 75 e3			ld de, scratch 
1202 cd 7c 09			call str_at_display 
1205 cd 8c 09			call update_display 
1208			 
1208 c3 ef 11			jp .diloop 
120b			 
120b			 
120b			; pass word in hl 
120b			; a has display location 
120b			display_word_at: 
120b f5				push af 
120c e5				push hl 
120d 7c				ld a,h 
120e 21 7a e6			ld hl, os_word_scratch 
1211 cd c3 0d			call hexout 
1214 e1				pop hl 
1215 7d				ld a,l 
1216 21 7c e6			ld hl, os_word_scratch+2 
1219 cd c3 0d			call hexout 
121c 21 7e e6			ld hl, os_word_scratch+4 
121f 3e 00			ld a,0 
1221 77				ld (hl),a 
1222 11 7a e6			ld de,os_word_scratch 
1225 f1				pop af 
1226 cd 7c 09				call str_at_display 
1229 c9				ret 
122a			 
122a			display_ptr_state: 
122a			 
122a				; to restore afterwards 
122a			 
122a d5				push de 
122b c5				push bc 
122c e5				push hl 
122d f5				push af 
122e			 
122e				; for use in here 
122e			 
122e			;	push bc 
122e			;	push de 
122e			;	push hl 
122e			;	push af 
122e			 
122e cd 69 09			call clear_display 
1231			 
1231 11 04 14			ld de, .ptrstate 
1234 3e 00			ld a, display_row_1 
1236 cd 7c 09			call str_at_display 
1239			 
1239				; display debug step 
1239			 
1239			 
1239 11 7a ee			ld de, debug_mark 
123c 3e 26			ld a, display_row_1+display_cols-2 
123e cd 7c 09			call str_at_display 
1241			 
1241				; display a 
1241 11 0e 14			ld de, .ptrcliptr 
1244 3e 28			ld a, display_row_2 
1246 cd 7c 09			call str_at_display 
1249			 
1249 f1				pop af 
124a 2a 40 eb			ld hl,(cli_ptr) 
124d 3e 30			ld a, display_row_2+8 
124f cd 0b 12			call display_word_at 
1252			 
1252			 
1252				; display hl 
1252			 
1252			 
1252 11 16 14			ld de, .ptrclioptr 
1255 3e 32			ld a, display_row_2+10 
1257 cd 7c 09			call str_at_display 
125a			; 
125a			;	pop hl 
125a 3e 35			ld a, display_row_2+13 
125c 2a 3e eb			ld hl,(cli_origptr) 
125f cd 0b 12			call display_word_at 
1262			; 
1262			;	 
1262			;	; display de 
1262			 
1262			;	ld de, .regstatede 
1262			;	ld a, display_row_3 
1262			;	call str_at_display 
1262			 
1262			;	pop de 
1262			;	ld h,d 
1262			;	ld l, e 
1262			;	ld a, display_row_3+3 
1262			;	call display_word_at 
1262			 
1262			 
1262				; display bc 
1262			 
1262			;	ld de, .regstatebc 
1262			;	ld a, display_row_3+10 
1262			;	call str_at_display 
1262			 
1262			;	pop bc 
1262			;	ld h,b 
1262			;	ld l, c 
1262			;	ld a, display_row_3+13 
1262			;	call display_word_at 
1262			 
1262			 
1262				; display dsp 
1262			 
1262			;	ld de, .regstatedsp 
1262			;	ld a, display_row_4 
1262			;	call str_at_display 
1262			 
1262				 
1262			;	ld hl,(cli_data_sp) 
1262			;	ld a, display_row_4+4 
1262			;	call display_word_at 
1262			 
1262				; display rsp 
1262			 
1262 11 45 14			ld de, .regstatersp 
1265 3e 82			ld a, display_row_4+10 
1267 cd 7c 09			call str_at_display 
126a			 
126a				 
126a 2a 26 eb			ld hl,(cli_ret_sp) 
126d 3e 86			ld a, display_row_4+14 
126f cd 0b 12			call display_word_at 
1272			 
1272 cd 8c 09			call update_display 
1275			 
1275 cd e2 08			call delay1s 
1278 cd e2 08			call delay1s 
127b cd e2 08			call delay1s 
127e			 
127e			 
127e cd 8b 17			call next_page_prompt 
1281			 
1281				; restore  
1281			 
1281 f1				pop af 
1282 e1				pop hl 
1283 c1				pop bc 
1284 d1				pop de 
1285 c9				ret 
1286			 
1286			break_point_state: 
1286 f5				push af 
1287			 
1287				; see if disabled 
1287			 
1287 3a 74 e3			ld a, (os_view_disable) 
128a fe 2a			cp '*' 
128c 20 02			jr nz, .bpsgo 
128e f1				pop af 
128f c9				ret 
1290			 
1290			.bpsgo: 
1290 f1				pop af 
1291 f5				push af 
1292 22 70 e3			ld (os_view_hl), hl 
1295 ed 53 6e e3		ld (os_view_de), de 
1299 ed 43 6c e3		ld (os_view_bc), bc 
129d e5				push hl 
129e 6f				ld l, a 
129f 26 00			ld h, 0 
12a1 22 72 e3			ld (os_view_af),hl 
12a4			 
12a4 21 c0 ed				ld hl, display_fb0 
12a7 22 db eb				ld (display_fb_active), hl 
12aa e1				pop hl	 
12ab			 
12ab 3e 31			ld a, '1' 
12ad fe 2a		.bps1:  cp '*' 
12af 20 03			jr nz, .bps1b 
12b1 32 74 e3			ld (os_view_disable),a 
12b4 fe 31		.bps1b:  cp '1' 
12b6 20 14			jr nz, .bps2 
12b8			 
12b8				; display reg 
12b8			 
12b8				 
12b8			 
12b8 3a 72 e3			ld a, (os_view_af) 
12bb 2a 70 e3			ld hl, (os_view_hl) 
12be ed 5b 6e e3		ld de, (os_view_de) 
12c2 ed 4b 6c e3		ld bc, (os_view_bc) 
12c6 cd 60 13			call display_reg_state 
12c9 c3 4c 13			jp .bpschk 
12cc			 
12cc fe 32		.bps2:  cp '2' 
12ce 20 08			jr nz, .bps3 
12d0				 
12d0				; display hl 
12d0 2a 70 e3			ld hl, (os_view_hl) 
12d3 cd 4a 14			call display_dump_at_hl 
12d6			 
12d6 18 74			jr .bpschk 
12d8			 
12d8 fe 33		.bps3:  cp '3' 
12da 20 08			jr nz, .bps4 
12dc			 
12dc			        ; display de 
12dc 2a 6e e3			ld hl, (os_view_de) 
12df cd 4a 14			call display_dump_at_hl 
12e2			 
12e2 18 68			jr .bpschk 
12e4 fe 34		.bps4:  cp '4' 
12e6 20 08			jr nz, .bps5 
12e8			 
12e8			        ; display bc 
12e8 2a 6c e3			ld hl, (os_view_bc) 
12eb cd 4a 14			call display_dump_at_hl 
12ee			 
12ee 18 5c			jr .bpschk 
12f0 fe 35		.bps5:  cp '5' 
12f2 20 08		        jr nz, .bps7 
12f4			 
12f4				; display cur ptr 
12f4 2a 40 eb			ld hl, (cli_ptr) 
12f7 cd 4a 14			call display_dump_at_hl 
12fa			 
12fa 18 50			jr .bpschk 
12fc fe 36		.bps7:  cp '6' 
12fe 20 08			jr nz, .bps8b 
1300				 
1300				; display cur orig ptr 
1300 2a 3e eb			ld hl, (cli_origptr) 
1303 cd 4a 14			call display_dump_at_hl 
1306 18 44			jr .bpschk 
1308 fe 37		.bps8b:  cp '7' 
130a 20 08			jr nz, .bps9 
130c				 
130c				; display dsp 
130c 2a 22 eb			ld hl, (cli_data_sp) 
130f cd 4a 14			call display_dump_at_hl 
1312			 
1312 18 38			jr .bpschk 
1314 fe 39		.bps9:  cp '9' 
1316 20 05			jr nz, .bps8c 
1318				 
1318				; display SP 
1318			;	ld hl, sp 
1318 cd 4a 14			call display_dump_at_hl 
131b			 
131b 18 2f			jr .bpschk 
131d fe 38		.bps8c:  cp '8' 
131f 20 08			jr nz, .bps8d 
1321				 
1321				; display rsp 
1321 2a 26 eb			ld hl, (cli_ret_sp) 
1324 cd 4a 14			call display_dump_at_hl 
1327			 
1327 18 23			jr .bpschk 
1329 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
132b 20 05			jr nz, .bps8 
132d cd 81 15			call monitor 
1330			 
1330 18 1a			jr .bpschk 
1332 fe 30		.bps8:  cp '0' 
1334 20 16			jr nz, .bpschk 
1336			 
1336 21 1f ed				ld hl, display_fb1 
1339 22 db eb				ld (display_fb_active), hl 
133c cd 8c 09				call update_display 
133f			 
133f				;ld a, (os_view_af) 
133f 2a 70 e3			ld hl, (os_view_hl) 
1342 ed 5b 6e e3		ld de, (os_view_de) 
1346 ed 4b 6c e3		ld bc, (os_view_bc) 
134a f1				pop af 
134b c9				ret 
134c			 
134c			.bpschk:   
134c cd e2 08			call delay1s 
134f 3e 9f		ld a,display_row_4 + display_cols - 1 
1351 11 89 17		        ld de, endprg 
1354 cd 7c 09			call str_at_display 
1357 cd 8c 09			call update_display 
135a cd e9 55			call cin_wait 
135d			 
135d c3 ad 12			jp .bps1 
1360			 
1360			 
1360			display_reg_state: 
1360			 
1360				; to restore afterwards 
1360			 
1360 d5				push de 
1361 c5				push bc 
1362 e5				push hl 
1363 f5				push af 
1364			 
1364				; for use in here 
1364			 
1364 c5				push bc 
1365 d5				push de 
1366 e5				push hl 
1367 f5				push af 
1368			 
1368 cd 69 09			call clear_display 
136b			 
136b 11 20 14			ld de, .regstate 
136e 3e 00			ld a, display_row_1 
1370 cd 7c 09			call str_at_display 
1373			 
1373				; display debug step 
1373			 
1373			 
1373 11 7a ee			ld de, debug_mark 
1376 3e 25			ld a, display_row_1+display_cols-3 
1378 cd 7c 09			call str_at_display 
137b			 
137b				; display a 
137b 11 3c 14			ld de, .regstatea 
137e 3e 28			ld a, display_row_2 
1380 cd 7c 09			call str_at_display 
1383			 
1383 e1				pop hl 
1384			;	ld h,0 
1384			;	ld l, a 
1384 3e 2b			ld a, display_row_2+3 
1386 cd 0b 12			call display_word_at 
1389			 
1389			 
1389				; display hl 
1389			 
1389			 
1389 11 30 14			ld de, .regstatehl 
138c 3e 32			ld a, display_row_2+10 
138e cd 7c 09			call str_at_display 
1391			 
1391 e1				pop hl 
1392 3e 35			ld a, display_row_2+13 
1394 cd 0b 12			call display_word_at 
1397			 
1397				 
1397				; display de 
1397			 
1397 11 34 14			ld de, .regstatede 
139a 3e 50			ld a, display_row_3 
139c cd 7c 09			call str_at_display 
139f			 
139f e1				pop hl 
13a0			;	ld h,d 
13a0			;	ld l, e 
13a0 3e 53			ld a, display_row_3+3 
13a2 cd 0b 12			call display_word_at 
13a5			 
13a5			 
13a5				; display bc 
13a5			 
13a5 11 38 14			ld de, .regstatebc 
13a8 3e 5a			ld a, display_row_3+10 
13aa cd 7c 09			call str_at_display 
13ad			 
13ad e1				pop hl 
13ae			;	ld h,b 
13ae			;	ld l, c 
13ae 3e 5d			ld a, display_row_3+13 
13b0 cd 0b 12			call display_word_at 
13b3			 
13b3			 
13b3				; display dsp 
13b3			 
13b3 11 40 14			ld de, .regstatedsp 
13b6 3e 78			ld a, display_row_4 
13b8 cd 7c 09			call str_at_display 
13bb			 
13bb				 
13bb 2a 22 eb			ld hl,(cli_data_sp) 
13be 3e 7c			ld a, display_row_4+4 
13c0 cd 0b 12			call display_word_at 
13c3			 
13c3				; display rsp 
13c3			 
13c3 11 45 14			ld de, .regstatersp 
13c6 3e 82			ld a, display_row_4+10 
13c8 cd 7c 09			call str_at_display 
13cb			 
13cb				 
13cb 2a 26 eb			ld hl,(cli_ret_sp) 
13ce 3e 86			ld a, display_row_4+14 
13d0 cd 0b 12			call display_word_at 
13d3			 
13d3 cd 8c 09			call update_display 
13d6			 
13d6			;	call delay1s 
13d6			;	call delay1s 
13d6			;	call delay1s 
13d6			 
13d6			 
13d6			;	call next_page_prompt 
13d6			 
13d6				; restore  
13d6			 
13d6 f1				pop af 
13d7 e1				pop hl 
13d8 c1				pop bc 
13d9 d1				pop de 
13da c9				ret 
13db			 
13db .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
13ef .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1404 .. 00		.ptrstate:	db "Ptr State",0 
140e .. 00		.ptrcliptr:     db "cli_ptr",0 
1416 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1420 .. 00		.regstate:	db "Reg State (1/0)",0 
1430 .. 00		.regstatehl:	db "HL:",0 
1434 .. 00		.regstatede:	db "DE:",0 
1438 .. 00		.regstatebc:	db "BC:",0 
143c .. 00		.regstatea:	db "A :",0 
1440 .. 00		.regstatedsp:	db "DSP:",0 
1445 .. 00		.regstatersp:	db "RSP:",0 
144a			 
144a			display_dump_at_hl: 
144a e5				push hl 
144b d5				push de 
144c c5				push bc 
144d f5				push af 
144e			 
144e 22 98 e6			ld (os_cur_ptr),hl	 
1451 cd 69 09			call clear_display 
1454 cd 93 16			call dumpcont 
1457			;	call delay1s 
1457			;	call next_page_prompt 
1457			 
1457			 
1457 f1				pop af 
1458 c1				pop bc 
1459 d1				pop de 
145a e1				pop hl 
145b c9				ret 
145c			 
145c			;if ENABLE_BASIC 
145c			;	include "nascombasic.asm" 
145c			;	basic: 
145c			;	include "forth/FORTH.ASM" 
145c			;endif 
145c			 
145c			; eof 
145c			 
145c			 
# End of file firmware_diags.asm
145c			  
145c			  
145c			  
145c			  
145c			; eof  
145c			  
# End of file firmware.asm
145c			 
145c			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
145c			;if BASE_KEV  
145c			;baseram: equ 08000h 
145c			;endif 
145c			 
145c			;if BASE_SC114 
145c			;baseram:     equ    endofcode 
145c			;endif 
145c			 
145c			 
145c			; start system 
145c			 
145c			coldstart: 
145c				; set sp 
145c				; di/ei 
145c			 
145c f3				di 
145d 31 00 f0			ld sp, tos 
1460			;	ei 
1460			 
1460			 
1460				; disable breakpoint by default 
1460			 
1460 3e 2a			ld a,'*' 
1462 32 74 e3			ld (os_view_disable),a 
1465			 
1465				; init hardware 
1465			 
1465				; init keyboard and screen hardware 
1465			 
1465 cd 03 01			call hardware_init 
1468			 
1468			 
1468				; detect if any keys are held down to enable breakpoints at start up 
1468			 
1468 cd f1 55			call cin  
146b fe 00			cp 0 
146d 28 03			jr z, .nokeys 
146f			 
146f cd 80 11			call hardware_diags 
1472			 
1472			;	ld de, .bpen 
1472			;	ld a, display_row_4 
1472			;	call str_at_display 
1472			;	call update_display 
1472			; 
1472			;	ld a,0 
1472			;	ld (os_view_disable),a 
1472			; 
1472			;.bpwait: 
1472			;	call cin 
1472			;	cp 0 
1472			;	jr z, .bpwait 
1472			;	jr .nokeys 
1472			; 
1472			; 
1472			;.bpen:  db "Break points enabled!",0 
1472			 
1472			 
1472			 
1472			 
1472			 
1472			 
1472			.nokeys: 
1472			 
1472			 
1472				 
1472			 
1472			;jp  testkey 
1472			 
1472			;call storage_get_block_0 
1472			; 
1472			;ld hl, 0 
1472			;ld de, store_page 
1472			;call storage_read_block 
1472			 
1472				 
1472			;ld hl, 10 
1472			;ld de, store_page 
1472			;call storage_read_block 
1472			 
1472			 
1472			 
1472			 
1472			 
1472			;stop:	nop 
1472			;	jp stop 
1472			 
1472			 
1472			 
1472			main: 
1472 cd 69 09			call clear_display 
1475 cd 8c 09			call update_display 
1478			 
1478			 
1478			 
1478			;	call testlcd 
1478			 
1478			 
1478			 
1478 cd d9 19			call forth_init 
147b			 
147b			 
147b			warmstart: 
147b cd af 19			call forth_warmstart 
147e			 
147e				; run startup word load 
147e			        ; TODO prevent this running at warmstart after crash  
147e			 
147e				if STARTUP_ENABLE 
147e cd 37 52				call forth_startup 
1481				endif 
1481			 
1481				; show free memory after boot 
1481 11 1b 15			ld de, freeram 
1484 3e 00			ld a, display_row_1 
1486 cd 7c 09			call str_at_display 
1489			 
1489			; Or use heap_size word???? 
1489 21 69 e3			ld hl, heap_end 
148c 11 19 56			ld de, heap_start 
148f ed 52			sbc hl, de 
1491 e5				push hl 
1492 7c				ld a,h	         	 
1493 21 7a e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1496 cd c3 0d			call hexout 
1499 e1			   	pop hl 
149a			 
149a 7d				ld a,l 
149b 21 7c e6			ld hl, os_word_scratch+2 
149e cd c3 0d			call hexout 
14a1 21 7e e6			ld hl, os_word_scratch+4 
14a4 3e 00			ld a, 0 
14a6 77				ld (hl),a 
14a7 11 7a e6			ld de, os_word_scratch 
14aa 3e 0d			ld a, display_row_1 + 13 
14ac cd 7c 09			call str_at_display 
14af cd 8c 09			call update_display 
14b2			 
14b2			 
14b2				;call demo 
14b2			 
14b2			 
14b2				; init scratch input area for cli commands 
14b2			 
14b2 21 9c e6			ld hl, os_cli_cmd 
14b5 3e 00			ld a,0 
14b7 77				ld (hl),a 
14b8 23				inc hl 
14b9 77				ld (hl),a 
14ba			 
14ba 3e 00			ld a,0 
14bc 32 9b e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
14bf			 
14bf 32 98 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
14c2 32 99 e6			ld (os_cur_ptr+1),a	 
14c5			 
14c5 32 7a e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
14c8 32 7b e6			ld (os_word_scratch+1),a	 
14cb				 
14cb			 
14cb				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
14cb 21 9c e6			ld hl, os_cli_cmd 
14ce			 
14ce 3e 00			ld a, 0		 ; init cli input 
14d0 77				ld (hl), a 
14d1 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
14d3			cli: 
14d3				; show cli prompt 
14d3				;push af 
14d3				;ld a, 0 
14d3				;ld de, prompt 
14d3				;call str_at_display 
14d3			 
14d3				;call update_display 
14d3				;pop af 
14d3				;inc a 
14d3				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
14d3 0e 00			ld c, 0 
14d5 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
14d7 1e 28			ld e, 40 
14d9			 
14d9 21 9c e6			ld hl, os_cli_cmd 
14dc			 
14dc				STACKFRAME OFF $fefe $9f9f 
14dc				if DEBUG_STACK_IMB 
14dc					if OFF 
14dc						exx 
14dc						ld de, $fefe 
14dc						ld a, d 
14dc						ld hl, curframe 
14dc						call hexout 
14dc						ld a, e 
14dc						ld hl, curframe+2 
14dc						call hexout 
14dc						ld hl, $fefe 
14dc						push hl 
14dc						ld hl, $9f9f 
14dc						push hl 
14dc						exx 
14dc					endif 
14dc				endif 
14dc			endm 
# End of macro STACKFRAME
14dc			 
14dc cd ef 0a			call input_str 
14df			 
14df				STACKFRAMECHK OFF $fefe $9f9f 
14df				if DEBUG_STACK_IMB 
14df					if OFF 
14df						exx 
14df						ld hl, $9f9f 
14df						pop de   ; $9f9f 
14df						call cmp16 
14df						jr nz, .spnosame 
14df						ld hl, $fefe 
14df						pop de   ; $fefe 
14df						call cmp16 
14df						jr z, .spfrsame 
14df						.spnosame: call showsperror 
14df						.spfrsame: nop 
14df						exx 
14df					endif 
14df				endif 
14df			endm 
# End of macro STACKFRAMECHK
14df			 
14df				; copy input to last command 
14df			 
14df 21 9c e6			ld hl, os_cli_cmd 
14e2 11 9b e7			ld de, os_last_cmd 
14e5 01 ff 00			ld bc, 255 
14e8 ed b0			ldir 
14ea				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
14ea			;	call strcpy 
14ea			;	ld a, 0 
14ea			;	ld (hl), a 
14ea			;	inc hl 
14ea			;	ld (hl), a 
14ea			;	inc hl 
14ea			;	ld (hl), a 
14ea			 
14ea				; switch frame buffer to program  
14ea			 
14ea 21 1f ed				ld hl, display_fb1 
14ed 22 db eb				ld (display_fb_active), hl 
14f0			 
14f0			;	nop 
14f0				STACKFRAME ON $fbfe $8f9f 
14f0				if DEBUG_STACK_IMB 
14f0					if ON 
14f0						exx 
14f0						ld de, $fbfe 
14f0						ld a, d 
14f0						ld hl, curframe 
14f0						call hexout 
14f0						ld a, e 
14f0						ld hl, curframe+2 
14f0						call hexout 
14f0						ld hl, $fbfe 
14f0						push hl 
14f0						ld hl, $8f9f 
14f0						push hl 
14f0						exx 
14f0					endif 
14f0				endif 
14f0			endm 
# End of macro STACKFRAME
14f0				; first time into the parser so pass over the current scratch pad 
14f0 21 9c e6			ld hl,os_cli_cmd 
14f3				; tokenise the entered statement(s) in HL 
14f3 cd 52 1a			call forthparse 
14f6			        ; exec forth statements in top of return stack 
14f6 cd 92 1a			call forthexec 
14f9				;call forthexec_cleanup 
14f9			;	call parsenext 
14f9			 
14f9				STACKFRAMECHK ON $fbfe $8f9f 
14f9				if DEBUG_STACK_IMB 
14f9					if ON 
14f9						exx 
14f9						ld hl, $8f9f 
14f9						pop de   ; $8f9f 
14f9						call cmp16 
14f9						jr nz, .spnosame 
14f9						ld hl, $fbfe 
14f9						pop de   ; $fbfe 
14f9						call cmp16 
14f9						jr z, .spfrsame 
14f9						.spnosame: call showsperror 
14f9						.spfrsame: nop 
14f9						exx 
14f9					endif 
14f9				endif 
14f9			endm 
# End of macro STACKFRAMECHK
14f9				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
14f9			 
14f9 3e 78			ld a, display_row_4 
14fb 11 2d 15			ld de, endprog 
14fe			 
14fe cd 8c 09			call update_display		 
1501			 
1501 cd 8b 17			call next_page_prompt 
1504			 
1504				; switch frame buffer to cli 
1504			 
1504 21 c0 ed				ld hl, display_fb0 
1507 22 db eb				ld (display_fb_active), hl 
150a			 
150a			 
150a cd 69 09		        call clear_display 
150d cd 8c 09			call update_display		 
1510			 
1510 21 9c e6			ld hl, os_cli_cmd 
1513			 
1513 3e 00			ld a, 0		 ; init cli input 
1515 77				ld (hl), a 
1516			 
1516				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1516			 
1516				; now on last line 
1516			 
1516				; TODO scroll screen up 
1516			 
1516				; TODO instead just clear screen and place at top of screen 
1516			 
1516			;	ld a, 0 
1516			;	ld (f_cursor_ptr),a 
1516			 
1516				;call clear_display 
1516				;call update_display 
1516			 
1516				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1516 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1518 c3 d3 14			jp cli 
151b			 
151b .. 00		freeram: db "Free bytes: $",0 
1529 ..			asc: db "1A2F" 
152d .. 00		endprog: db "End prog...",0 
1539			 
1539			testenter2:   
1539 21 a7 e3			ld hl,scratch+50 
153c 22 98 e6			ld (os_cur_ptr),hl 
153f c3 d3 14			jp cli 
1542			 
1542			testenter:  
1542			 
1542 21 29 15			ld hl,asc 
1545			;	ld a,(hl) 
1545			;	call nibble2val 
1545 cd 19 0e			call get_byte 
1548			 
1548			 
1548			;	ld a,(hl) 
1548			;	call atohex 
1548			 
1548			;	call fourehexhl 
1548 32 a7 e3			ld (scratch+50),a 
154b			 
154b			 
154b			 
154b 21 2b 15			ld hl,asc+2 
154e			;	ld a, (hl) 
154e			;	call nibble2val 
154e cd 19 0e			call get_byte 
1551			 
1551			;	call fourehexhl 
1551 32 a9 e3			ld (scratch+52),a 
1554				 
1554 21 a7 e3			ld hl,scratch+50 
1557 22 98 e6			ld (os_cur_ptr),hl 
155a c3 d3 14			jp cli 
155d			 
155d			enter:	 
155d 3a 79 e3			ld a,(scratch+4) 
1560 fe 00			cp 0 
1562 28 0c			jr z, .entercont 
1564				; no, not a null term line so has an address to work out.... 
1564			 
1564 21 77 e3			ld hl,scratch+2 
1567 cd 79 0e			call get_word_hl 
156a			 
156a 22 98 e6			ld (os_cur_ptr),hl	 
156d c3 d3 14			jp cli 
1570			 
1570			 
1570			.entercont:  
1570			 
1570 21 77 e3			ld hl, scratch+2 
1573 cd 19 0e			call get_byte 
1576			 
1576 2a 98 e6		   	ld hl,(os_cur_ptr) 
1579 77					ld (hl),a 
157a 23					inc hl 
157b 22 98 e6				ld (os_cur_ptr),hl 
157e				 
157e			; get byte  
157e			 
157e			 
157e c3 d3 14			jp cli 
1581			 
1581			 
1581			; basic monitor support 
1581			 
1581			monitor: 
1581				;  
1581 cd 69 09			call clear_display 
1584 3e 00			ld a, 0 
1586 11 ce 15			ld de, .monprompt 
1589 cd 7c 09			call str_at_display 
158c cd 8c 09			call update_display 
158f			 
158f				; get a monitor command 
158f			 
158f 0e 00			ld c, 0     ; entry at top left 
1591 16 64			ld d, 100   ; max buffer size 
1593 1e 0f			ld e, 15    ; input scroll area 
1595 3e 00			ld a, 0     ; init string 
1597 21 73 e5			ld hl, os_input 
159a 77				ld (hl), a 
159b 23				inc hl 
159c 77				ld (hl), a 
159d 21 73 e5			ld hl, os_input 
15a0 3e 01			ld a, 1     ; init string 
15a2 cd ef 0a			call input_str 
15a5			 
15a5 cd 69 09		        call clear_display 
15a8 cd 8c 09			call update_display		 
15ab			 
15ab 3a 73 e5			ld a, (os_input) 
15ae cd 17 0f			call toUpper 
15b1 fe 48		        cp 'H' 
15b3 28 6f		        jr z, .monhelp 
15b5 fe 44			cp 'D'		; dump 
15b7 ca 45 16			jp z, .mondump	 
15ba fe 43			cp 'C'		; dump 
15bc ca 5f 16			jp z, .moncdump	 
15bf fe 4d			cp 'M'		; dump 
15c1 ca d0 15			jp z, .moneditstart 
15c4 fe 55			cp 'U'		; dump 
15c6 28 14			jr z, .monedit	 
15c8 fe 51			cp 'Q'		; dump 
15ca c8				ret z	 
15cb			 
15cb			 
15cb				; TODO "S" to access symbol by name and not need the address 
15cb				; TODO "F" to find a string in memory 
15cb			 
15cb c3 81 15			jp monitor 
15ce			 
15ce .. 00		.monprompt: db ">", 0 
15d0			 
15d0			.moneditstart: 
15d0				; get starting address 
15d0			 
15d0 21 75 e5			ld hl,os_input+2 
15d3 cd 79 0e			call get_word_hl 
15d6			 
15d6 22 98 e6			ld (os_cur_ptr),hl	 
15d9			 
15d9 c3 81 15			jp monitor 
15dc			 
15dc			.monedit: 
15dc				; get byte to load 
15dc			 
15dc 21 75 e5			ld hl,os_input+2 
15df cd 19 0e			call get_byte 
15e2			 
15e2				; get address to update 
15e2 2a 98 e6			ld hl, (os_cur_ptr) 
15e5			 
15e5				; update byte 
15e5			 
15e5 77				ld (hl), a 
15e6			 
15e6				; move to next address and save it 
15e6			 
15e6 23				inc hl 
15e7 22 98 e6			ld (os_cur_ptr),hl	 
15ea			 
15ea c3 81 15			jp monitor 
15ed			 
15ed			 
15ed .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1601 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
161d .. 00		.monhelptext3:  db "Q-Quit",0 
1624			        
1624			.monhelp: 
1624 3e 00			ld a, display_row_1 
1626 11 ed 15		        ld de, .monhelptext1 
1629			 
1629 cd 7c 09			call str_at_display 
162c 3e 28			ld a, display_row_2 
162e 11 01 16		        ld de, .monhelptext2 
1631					 
1631 cd 7c 09			call str_at_display 
1634 3e 50			ld a, display_row_3 
1636 11 1d 16		        ld de, .monhelptext3 
1639					 
1639 cd 7c 09			call str_at_display 
163c cd 8c 09			call update_display		 
163f			 
163f cd 8b 17			call next_page_prompt 
1642 c3 81 15			jp monitor 
1645			 
1645			.mondump:    
1645 21 75 e5			ld hl,os_input+2 
1648 cd 79 0e			call get_word_hl 
164b			 
164b 22 98 e6			ld (os_cur_ptr),hl	 
164e cd 93 16			call dumpcont 
1651 3e 78			ld a, display_row_4 
1653 11 2d 15			ld de, endprog 
1656			 
1656 cd 8c 09			call update_display		 
1659			 
1659 cd 8b 17			call next_page_prompt 
165c c3 81 15			jp monitor 
165f			.moncdump: 
165f cd 93 16			call dumpcont 
1662 3e 78			ld a, display_row_4 
1664 11 2d 15			ld de, endprog 
1667			 
1667 cd 8c 09			call update_display		 
166a			 
166a cd 8b 17			call next_page_prompt 
166d c3 81 15			jp monitor 
1670			 
1670			 
1670			; TODO symbol access  
1670			 
1670			.symbols:     ;; A list of symbols that can be called up  
1670 c0 ed			dw display_fb0 
1672 .. 00			db "fb0",0  
1676 65 eb		     	dw store_page 
1678 .. 00			db "store_page",0 
1683			 
1683			 
1683			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1683			 
1683 3a 76 e3			ld a,(scratch+1) 
1686 fe 00			cp 0 
1688 28 09			jr z, dumpcont 
168a			 
168a				; no, not a null term line so has an address to work out.... 
168a			 
168a 21 77 e3			ld hl,scratch+2 
168d cd 79 0e			call get_word_hl 
1690			 
1690 22 98 e6			ld (os_cur_ptr),hl	 
1693			 
1693			 
1693			 
1693			dumpcont: 
1693			 
1693				; dump bytes at ptr 
1693			 
1693			 
1693 3e 00			ld a, display_row_1 
1695 2a db eb			ld hl, (display_fb_active) 
1698 cd c2 0a			call addatohl 
169b cd c3 16			call .dumpbyterow 
169e			 
169e 3e 28			ld a, display_row_2 
16a0 2a db eb			ld hl, (display_fb_active) 
16a3 cd c2 0a			call addatohl 
16a6 cd c3 16			call .dumpbyterow 
16a9			 
16a9			 
16a9 3e 50			ld a, display_row_3 
16ab 2a db eb			ld hl, (display_fb_active) 
16ae cd c2 0a			call addatohl 
16b1 cd c3 16			call .dumpbyterow 
16b4			 
16b4 3e 78			ld a, display_row_4 
16b6 2a db eb			ld hl, (display_fb_active) 
16b9 cd c2 0a			call addatohl 
16bc cd c3 16			call .dumpbyterow 
16bf			 
16bf cd 8c 09			call update_display 
16c2			;		jp cli 
16c2 c9				ret 
16c3			 
16c3			.dumpbyterow: 
16c3			 
16c3				;push af 
16c3			 
16c3 e5				push hl 
16c4			 
16c4				; calc where to poke the ascii 
16c4			if display_cols == 20 
16c4				ld a, 16 
16c4			else 
16c4 3e 1f			ld a, 31 
16c6			endif 
16c6			 
16c6 cd c2 0a			call addatohl 
16c9 22 7a e6			ld (os_word_scratch),hl  		; save pos for later 
16cc			 
16cc			 
16cc			; display decoding address 
16cc 2a 98 e6		   	ld hl,(os_cur_ptr) 
16cf			 
16cf 7c				ld a,h 
16d0 e1				pop hl 
16d1 e5				push hl 
16d2			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
16d2 cd c3 0d			call hexout 
16d5 2a 98 e6		   	ld hl,(os_cur_ptr) 
16d8			 
16d8 7d				ld a,l 
16d9 e1				pop hl 
16da 23				inc hl 
16db 23				inc hl 
16dc e5				push hl 
16dd			;	ld hl, os_word_scratch+2 
16dd cd c3 0d			call hexout 
16e0 e1				pop hl 
16e1 23				inc hl 
16e2 23				inc hl 
16e3				;ld hl, os_word_scratch+4 
16e3 3e 3a			ld a, ':' 
16e5 77				ld (hl),a 
16e6 23				inc hl 
16e7				;ld a, 0 
16e7				;ld (hl),a 
16e7				;ld de, os_word_scratch 
16e7				;pop af 
16e7				;push af 
16e7			;		ld a, display_row_2 
16e7			;		call str_at_display 
16e7			;		call update_display 
16e7			 
16e7			 
16e7			;pop af 
16e7			;	add 5 
16e7			 
16e7			if display_cols == 20 
16e7				ld b, 4 
16e7			else 
16e7 06 08			ld b, 8 
16e9			endif	 
16e9			 
16e9			.dumpbyte: 
16e9 c5				push bc 
16ea e5				push hl 
16eb			 
16eb			 
16eb 2a 98 e6		   	ld hl,(os_cur_ptr) 
16ee 7e					ld a,(hl) 
16ef			 
16ef					; poke the ascii to display 
16ef 2a 7a e6				ld hl,(os_word_scratch) 
16f2 77					ld (hl),a 
16f3 23					inc hl 
16f4 22 7a e6				ld (os_word_scratch),hl 
16f7			 
16f7					 
16f7			 
16f7			 
16f7 e1					pop hl 
16f8 e5					push hl 
16f9			 
16f9 cd c3 0d				call hexout 
16fc			 
16fc					 
16fc 2a 98 e6		   	ld hl,(os_cur_ptr) 
16ff 23				inc hl 
1700 22 98 e6		   	ld (os_cur_ptr),hl 
1703			 
1703 e1					pop hl 
1704 23					inc hl 
1705 23					inc hl 
1706 23					inc hl 
1707			 
1707			 
1707			 
1707					;ld a,0 
1707					;ld (os_word_scratch+2),a 
1707					;pop af 
1707					;push af 
1707			 
1707					;ld de, os_word_scratch 
1707					;call str_at_display 
1707			;		call update_display 
1707			;		pop af 
1707 c1					pop bc 
1708 c6 03				add 3 
170a 10 dd			djnz .dumpbyte 
170c			 
170c				 
170c			 
170c c9				ret 
170d			 
170d			jump:	 
170d			 
170d 21 77 e3			ld hl,scratch+2 
1710 cd 79 0e			call get_word_hl 
1713				;ld hl,(scratch+2) 
1713				;call fourehexhl 
1713			 
1713 22 98 e6			ld (os_cur_ptr),hl	 
1716			 
1716 e9				jp (hl) 
1717			 
1717			 
1717			 
1717			; TODO implement a basic monitor mode to start with 
1717			 
1717			 
1717			 
1717			 
1717			 
1717			 
1717			 
1717			 
1717			 
1717			; testing and demo code during development 
1717			 
1717			 
1717 .. 00		str1: db "Enter some text...",0 
172a .. 00		clear: db "                    ",0 
173f			 
173f			demo: 
173f			 
173f			 
173f			 
173f			;	call update_display 
173f			 
173f				; init scratch input area for testing 
173f 21 75 e3			ld hl, scratch	 
1742 3e 00			ld a,0 
1744 77				ld (hl),a 
1745			 
1745			 
1745 3e 28		            LD   A, display_row_2 
1747			;            CALL fLCD_Pos       ;Position cursor to location in A 
1747 11 17 17		            LD   DE, str1 
174a cd 7c 09			call str_at_display 
174d			 
174d			;            CALL fLCD_Str       ;Display string pointed to by DE 
174d			cloop:	 
174d 3e 50		            LD   A, display_row_3 
174f			;            CALL fLCD_Pos       ;Position cursor to location in A 
174f 11 2a 17		            LD   DE, clear 
1752			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1752 cd 7c 09				call str_at_display 
1755 3e 78			ld a, display_row_4 
1757 11 87 17			ld de, prompt 
175a			 
175a cd 7c 09				call str_at_display 
175d cd 8c 09			call update_display 
1760			 
1760 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1762 16 0a			ld d, 10 
1764 21 75 e3			ld hl, scratch	 
1767 cd ef 0a			call input_str 
176a			 
176a			;	call clear_display 
176a			;'	call update_display 
176a			 
176a 3e 00		            LD   A, display_row_1 
176c			;            CALL fLCD_Pos       ;Position cursor to location in A 
176c 11 2a 17		            LD   DE, clear 
176f cd 7c 09				call str_at_display 
1772			;            CALL fLCD_Str       ;Display string pointed to by DE 
1772 3e 00		            LD   A, display_row_1 
1774			;            CALL fLCD_Pos       ;Position cursor to location in A 
1774 11 75 e3		            LD   DE, scratch 
1777			;            CALL fLCD_Str       ;Display string pointed to by DE 
1777 cd 7c 09				call str_at_display 
177a cd 8c 09			call update_display 
177d			 
177d 3e 00				ld a,0 
177f 21 75 e3			ld hl, scratch 
1782 77				ld (hl),a 
1783			 
1783 00				nop 
1784 c3 4d 17			jp cloop 
1787			 
1787			 
1787			 
1787			; OS Prompt 
1787			 
1787 .. 00		prompt: db ">",0 
1789 .. 00		endprg: db "?",0 
178b			 
178b			 
178b			; handy next page prompt 
178b			next_page_prompt: 
178b e5				push hl 
178c d5				push de 
178d f5				push af 
178e c5				push bc 
178f			 
178f 3e 9f			ld a,display_row_4 + display_cols - 1 
1791 11 89 17		        ld de, endprg 
1794 cd 7c 09			call str_at_display 
1797 cd 8c 09			call update_display 
179a cd e9 55			call cin_wait 
179d c1				pop bc 
179e f1				pop af 
179f d1				pop de 
17a0 e1				pop hl 
17a1			 
17a1			 
17a1 c9				ret 
17a2			 
17a2			 
17a2			; forth parser 
17a2			 
17a2			; My forth kernel 
17a2			include "forth_kernel.asm" 
17a2			; 
17a2			; kernel to the forth OS 
17a2			 
17a2			DS_TYPE_STR: equ 1     ; string type 
17a2			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
17a2			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
17a2			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
17a2			 
17a2			FORTH_PARSEV1: equ 0 
17a2			FORTH_PARSEV2: equ 0 
17a2			FORTH_PARSEV3: equ 0 
17a2			FORTH_PARSEV4: equ 0 
17a2			FORTH_PARSEV5: equ 1 
17a2			 
17a2			;if FORTH_PARSEV5 
17a2			;	FORTH_END_BUFFER: equ 0 
17a2			;else 
17a2			FORTH_END_BUFFER: equ 127 
17a2			;endif 
17a2			 
17a2			FORTH_TRUE: equ 1 
17a2			FORTH_FALSE: equ 0 
17a2			 
17a2			if FORTH_PARSEV4 
17a2			include "forth_stackops.asm" 
17a2			endif 
17a2			 
17a2			if FORTH_PARSEV5 
17a2			include "forth_stackopsv5.asm" 
17a2			 
17a2			; Stack operations for v5 parser on wards 
17a2			; * DATA stack 
17a2			; * LOOP stack 
17a2			; * RETURN stack 
17a2			 
17a2			 
17a2			 
17a2			FORTH_CHK_DSP_UNDER: macro 
17a2				push hl 
17a2				push de 
17a2				ld hl,(cli_data_sp) 
17a2				ld de, cli_data_stack 
17a2				call cmp16 
17a2				jp c, fault_dsp_under 
17a2				pop de 
17a2				pop hl 
17a2				endm 
17a2			 
17a2			 
17a2			FORTH_CHK_RSP_UNDER: macro 
17a2				push hl 
17a2				push de 
17a2				ld hl,(cli_ret_sp) 
17a2				ld de, cli_ret_stack 
17a2				call cmp16 
17a2				jp c, fault_rsp_under 
17a2				pop de 
17a2				pop hl 
17a2				endm 
17a2			 
17a2			FORTH_CHK_LOOP_UNDER: macro 
17a2				push hl 
17a2				push de 
17a2				ld hl,(cli_loop_sp) 
17a2				ld de, cli_loop_stack 
17a2				call cmp16 
17a2				jp c, fault_loop_under 
17a2				pop de 
17a2				pop hl 
17a2				endm 
17a2			 
17a2			FORTH_ERR_TOS_NOTSTR: macro 
17a2				; TOSO might need more for checks when used 
17a2				push af 
17a2				ld a,(hl) 
17a2				cp DS_TYPE_STR 
17a2				jp nz, type_faultn   
17a2				pop af 
17a2				endm 
17a2			 
17a2			FORTH_ERR_TOS_NOTNUM: macro 
17a2				push af 
17a2				ld a,(hl) 
17a2				cp DS_TYPE_INUM 
17a2				jp nz, type_faultn   
17a2				pop af 
17a2				endm 
17a2			 
17a2			 
17a2			; increase data stack pointer and save hl to it 
17a2				 
17a2			FORTH_DSP_NEXT: macro 
17a2				call macro_forth_dsp_next 
17a2				endm 
17a2			 
17a2			 
17a2			macro_forth_dsp_next: 
17a2				if DEBUG_FORTH_STACK_GUARD 
17a2 cd 01 53				call check_stacks 
17a5				endif 
17a5 e5				push hl 
17a6 d5				push de 
17a7 eb				ex de,hl 
17a8 2a 22 eb			ld hl,(cli_data_sp) 
17ab 23				inc hl 
17ac 23				inc hl 
17ad			 
17ad			; PARSEV5 
17ad 23				inc hl 
17ae 22 22 eb			ld (cli_data_sp),hl 
17b1 73				ld (hl), e 
17b2 23				inc hl 
17b3 72				ld (hl), d 
17b4 d1				pop de 
17b5 e1				pop hl 
17b6				if DEBUG_FORTH_STACK_GUARD 
17b6 cd 01 53				call check_stacks 
17b9				endif 
17b9 c9				ret 
17ba			 
17ba			 
17ba			; increase ret stack pointer and save hl to it 
17ba				 
17ba			FORTH_RSP_NEXT: macro 
17ba				call macro_forth_rsp_next 
17ba				endm 
17ba			 
17ba			macro_forth_rsp_next: 
17ba				if DEBUG_FORTH_STACK_GUARD 
17ba cd 01 53				call check_stacks 
17bd				endif 
17bd e5				push hl 
17be d5				push de 
17bf eb				ex de,hl 
17c0 2a 26 eb			ld hl,(cli_ret_sp) 
17c3 23				inc hl 
17c4 23				inc hl 
17c5 22 26 eb			ld (cli_ret_sp),hl 
17c8 73				ld (hl), e 
17c9 23				inc hl 
17ca 72				ld (hl), d 
17cb d1				pop de 
17cc e1				pop hl 
17cd				if DEBUG_FORTH_STACK_GUARD 
17cd cd 01 53				call check_stacks 
17d0				endif 
17d0 c9				ret 
17d1			 
17d1			; get current ret stack pointer and save to hl  
17d1				 
17d1			FORTH_RSP_TOS: macro 
17d1				call macro_forth_rsp_tos 
17d1				endm 
17d1			 
17d1			macro_forth_rsp_tos: 
17d1				;push de 
17d1 2a 26 eb			ld hl,(cli_ret_sp) 
17d4 cd 0c 18			call loadhlptrtohl 
17d7				;ld e, (hl) 
17d7				;inc hl 
17d7				;ld d, (hl) 
17d7				;ex de, hl 
17d7					if DEBUG_FORTH_WORDS 
17d7			;			DMARK "RST" 
17d7						CALLMONITOR 
17d7 cd 86 12			call break_point_state  
17da				endm  
# End of macro CALLMONITOR
17da					endif 
17da				;pop de 
17da c9				ret 
17db			 
17db			; pop ret stack pointer 
17db				 
17db			FORTH_RSP_POP: macro 
17db				call macro_forth_rsp_pop 
17db				endm 
17db			 
17db			 
17db			macro_forth_rsp_pop: 
17db				if DEBUG_FORTH_STACK_GUARD 
17db			;		DMARK "RPP" 
17db cd 01 53				call check_stacks 
17de					FORTH_CHK_RSP_UNDER 
17de e5				push hl 
17df d5				push de 
17e0 2a 26 eb			ld hl,(cli_ret_sp) 
17e3 11 e0 ea			ld de, cli_ret_stack 
17e6 cd e0 0a			call cmp16 
17e9 da 15 54			jp c, fault_rsp_under 
17ec d1				pop de 
17ed e1				pop hl 
17ee				endm 
# End of macro FORTH_CHK_RSP_UNDER
17ee				endif 
17ee e5				push hl 
17ef 2a 26 eb			ld hl,(cli_ret_sp) 
17f2			 
17f2			 
17f2				if FORTH_ENABLE_FREE 
17f2			 
17f2					; get pointer 
17f2			 
17f2					push de 
17f2					push hl 
17f2			 
17f2					ld e, (hl) 
17f2					inc hl 
17f2					ld d, (hl) 
17f2			 
17f2					ex de, hl 
17f2					call free 
17f2			 
17f2					pop hl 
17f2					pop de 
17f2			 
17f2			 
17f2				endif 
17f2			 
17f2			 
17f2 2b				dec hl 
17f3 2b				dec hl 
17f4 22 26 eb			ld (cli_ret_sp), hl 
17f7				; do stack underflow checks 
17f7 e1				pop hl 
17f8				if DEBUG_FORTH_STACK_GUARD 
17f8 cd 01 53				call check_stacks 
17fb					FORTH_CHK_RSP_UNDER 
17fb e5				push hl 
17fc d5				push de 
17fd 2a 26 eb			ld hl,(cli_ret_sp) 
1800 11 e0 ea			ld de, cli_ret_stack 
1803 cd e0 0a			call cmp16 
1806 da 15 54			jp c, fault_rsp_under 
1809 d1				pop de 
180a e1				pop hl 
180b				endm 
# End of macro FORTH_CHK_RSP_UNDER
180b				endif 
180b c9				ret 
180c			 
180c			 
180c			 
180c			; routine to load word pointed to by hl into hl 
180c			 
180c			loadhlptrtohl: 
180c			 
180c d5				push de 
180d 5e				ld e, (hl) 
180e 23				inc hl 
180f 56				ld d, (hl) 
1810 eb				ex de, hl 
1811 d1				pop de 
1812			 
1812 c9				ret 
1813			 
1813			 
1813			 
1813			 
1813			 
1813			; push a number held in HL onto the data stack 
1813			; entry point for pushing a value when already in hl used in function above 
1813			 
1813			forth_push_numhl: 
1813			 
1813 e5				push hl    ; save value to push 
1814			 
1814			if DEBUG_FORTH_PUSH 
1814				; see if disabled 
1814			 
1814			 
1814				push af 
1814				ld a, (os_view_disable) 
1814				cp '*' 
1814				jr z, .pskip2 
1814				push hl 
1814			push hl 
1814				call clear_display 
1814			pop hl 
1814				ld a,h 
1814				ld hl, os_word_scratch 
1814				call hexout 
1814				pop hl 
1814				ld a,l 
1814				ld hl, os_word_scratch+2 
1814				call hexout 
1814			 
1814				ld hl, os_word_scratch+4 
1814				ld a,0 
1814				ld (hl),a 
1814				ld de,os_word_scratch 
1814					ld a, display_row_2 
1814					call str_at_display 
1814				ld de, .push_num 
1814				ld a, display_row_1 
1814			 
1814					call str_at_display 
1814			 
1814			 
1814				call update_display 
1814				call delay1s 
1814				call delay1s 
1814			.pskip2:  
1814			 
1814				pop af 
1814			endif	 
1814			 
1814			 
1814				FORTH_DSP_NEXT 
1814 cd a2 17			call macro_forth_dsp_next 
1817				endm 
# End of macro FORTH_DSP_NEXT
1817			 
1817 2a 22 eb			ld hl, (cli_data_sp) 
181a			 
181a				; save item type 
181a 3e 02			ld a,  DS_TYPE_INUM 
181c 77				ld (hl), a 
181d 23				inc hl 
181e			 
181e				; get word off stack 
181e d1				pop de 
181f 7b				ld a,e 
1820 77				ld (hl), a 
1821 23				inc hl 
1822 7a				ld a,d 
1823 77				ld (hl), a 
1824			 
1824			if DEBUG_FORTH_PUSH 
1824				dec hl 
1824				dec hl 
1824				dec hl 
1824						DMARK "PH5" 
1824				CALLMONITOR 
1824			endif	 
1824			 
1824 c9				ret 
1825			 
1825			 
1825			; Push a string to stack pointed to by hl 
1825			 
1825			forth_push_str: 
1825			 
1825			if DEBUG_FORTH_PUSH 
1825						DMARK "PSQ" 
1825				CALLMONITOR 
1825			endif	 
1825			    
1825 e5				push hl 
1826 e5				push hl 
1827			 
1827 3e 00			ld a, 0   ; find end of string 
1829 cd 2b 0f			call strlent       
182c			if DEBUG_FORTH_PUSH 
182c						DMARK "PQ2" 
182c				CALLMONITOR 
182c			endif	 
182c eb				ex de, hl 
182d e1				pop hl   ; get ptr to start of string 
182e			if DEBUG_FORTH_PUSH 
182e						DMARK "PQ3" 
182e				CALLMONITOR 
182e			endif	 
182e 19				add hl,de 
182f			if DEBUG_FORTH_PUSH 
182f						DMARK "PQE" 
182f				CALLMONITOR 
182f			endif	 
182f			 
182f 2b				dec hl    ; see if there is an optional trailing double quote 
1830 7e				ld a,(hl) 
1831 fe 22			cp '"' 
1833 20 03			jr nz, .strnoq 
1835 3e 00			ld a, 0      ; get rid of double quote 
1837 77				ld (hl), a 
1838 23			.strnoq: inc hl 
1839			 
1839 3e 00			ld a, 0 
183b 77				ld (hl), a     ; add null term and get rid of trailing double quote 
183c			 
183c 13				inc de ; add one for the type string 
183d 13				inc de ; add one for null term??? 
183e			 
183e				; tos is get string pointer again 
183e				; de contains space to allocate 
183e				 
183e d5				push de 
183f			 
183f eb				ex de, hl 
1840			 
1840				;push af 
1840			 
1840			if DEBUG_FORTH_PUSH 
1840						DMARK "PHm" 
1840				CALLMONITOR 
1840			endif	 
1840 cd 89 0f			call malloc	; on ret hl now contains allocated memory 
1843				if DEBUG_FORTH_MALLOC_GUARD 
1843 cc 67 42				call z,malloc_error 
1846				endif 
1846			 
1846				 
1846 c1				pop bc    ; get length 
1847 d1				pop de   ;  get string start    
1848			 
1848				; hl has destination from malloc 
1848			 
1848 eb				ex de, hl    ; prep for ldir 
1849			 
1849 e5				push hl   ; save malloc area for DSP later 
184a			 
184a			if DEBUG_FORTH_PUSH 
184a						DMARK "PHc" 
184a				CALLMONITOR 
184a			endif	 
184a			 
184a			 
184a ed b0			ldir 
184c			 
184c			 
184c				; push malloc to data stack     macro?????  
184c			 
184c				FORTH_DSP_NEXT 
184c cd a2 17			call macro_forth_dsp_next 
184f				endm 
# End of macro FORTH_DSP_NEXT
184f			 
184f				; save value and type 
184f			 
184f 2a 22 eb			ld hl, (cli_data_sp) 
1852			 
1852				; save item type 
1852 3e 01			ld a,  DS_TYPE_STR 
1854 77				ld (hl), a 
1855 23				inc hl 
1856			 
1856				; get malloc word off stack 
1856 d1				pop de 
1857 73				ld (hl), e 
1858 23				inc hl 
1859 72				ld (hl), d 
185a			 
185a			 
185a			 
185a			if DEBUG_FORTH_PUSH 
185a				ld hl, (cli_data_sp) 
185a						DMARK "PHS" 
185a				CALLMONITOR 
185a			;	ex de,hl 
185a			endif	 
185a				; in case of spaces, skip the ptr past the copied string 
185a				;pop af 
185a				;ld (cli_origptr),hl 
185a			 
185a c9				ret 
185b			 
185b			 
185b			 
185b			; TODO ascii push input onto stack given hl to start of input 
185b			 
185b			; identify type 
185b			; if starts with a " then a string 
185b			; otherwise it is a number 
185b			;  
185b			; if a string 
185b			;     scan for ending " to get length of string to malloc for + 1 
185b			;     malloc 
185b			;     put pointer to string on stack first byte flags as string 
185b			; 
185b			; else a number 
185b			;    look for number format identifier 
185b			;    $xx hex 
185b			;    %xxxxx bin 
185b			;    xxxxx decimal 
185b			;    convert number to 16bit word.  
185b			;    malloc word + 1 with flag to identiy as num 
185b			;    put pointer to number on stack 
185b			;   
185b			;  
185b			  
185b			forth_apush: 
185b				; kernel push 
185b			 
185b			if DEBUG_FORTH_PUSH 
185b						DMARK "PSH" 
185b				CALLMONITOR 
185b			endif	 
185b				; identify input type 
185b			 
185b 7e				ld a,(hl) 
185c fe 22			cp '"' 
185e 28 0a			jr z, .fapstr 
1860 fe 24			cp '$' 
1862 ca 8a 18			jp z, .faphex 
1865 fe 25			cp '%' 
1867 ca 72 18			jp z, .fapbin 
186a			;	cp 'b' 
186a			;	jp z, .fabin 
186a				; else decimal 
186a			 
186a				; TODO do decimal conversion 
186a				; decimal is stored as a 16bit word 
186a			 
186a				; by default everything is a string if type is not detected 
186a			.fapstr: ; 
186a fe 22			cp '"' 
186c 20 01			jr nz, .strnoqu 
186e 23				inc hl 
186f			.strnoqu: 
186f c3 25 18			jp forth_push_str 
1872			 
1872			 
1872			 
1872			.fapbin:    ; push a binary string.  
1872 11 00 00			ld de, 0   ; hold a 16bit value 
1875			 
1875 23			.fapbinshift:	inc hl  
1876 7e				ld a,(hl) 
1877 fe 00			cp 0     ; done scanning  
1879 28 0b			jr z, .fapbdone  	; got it in HL so push  
187b			 
187b				; left shift de 
187b eb				ex de, hl	 
187c 29				add hl, hl 
187d			 
187d				; is 1 
187d fe 31			cp '1' 
187f 20 02			jr nz, .binzero 
1881 cb 4d			bit 1, l 
1883			.binzero: 
1883 eb				ex de, hl	 ; save current de 
1884 18 ef			jr .fapbinshift 
1886			 
1886			.fapbdone: 
1886 eb				ex de, hl 
1887 c3 13 18			jp forth_push_numhl 
188a			 
188a			 
188a			.faphex:   ; hex is always stored as a 16bit word 
188a				; skip number prefix 
188a 23				inc hl 
188b				; turn ascii into number 
188b cd 79 0e			call get_word_hl	; ret 16bit word in hl 
188e			 
188e c3 13 18			jp forth_push_numhl 
1891			 
1891 00				 nop 
1892			 
1892			.fabin:   ; TODO bin conversion 
1892			 
1892			 
1892 c9				ret 
1893			 
1893			 
1893			; get either a string ptr or a 16bit word from the data stack 
1893			 
1893			FORTH_DSP: macro 
1893				call macro_forth_dsp 
1893				endm 
1893			 
1893			macro_forth_dsp: 
1893				; data stack pointer points to current word on tos 
1893			 
1893 2a 22 eb			ld hl,(cli_data_sp) 
1896			 
1896				if DEBUG_FORTH_PUSH 
1896						DMARK "DSP" 
1896			 
1896					call display_data_sp 
1896				;call break_point_state 
1896				;rst 030h 
1896				CALLMONITOR 
1896				endif 
1896			 
1896 c9				ret 
1897			 
1897			; return hl to start of value on stack 
1897			 
1897			FORTH_DSP_VALUE: macro 
1897				call macro_forth_dsp_value 
1897				endm 
1897			 
1897			macro_forth_dsp_value: 
1897			 
1897				FORTH_DSP 
1897 cd 93 18			call macro_forth_dsp 
189a				endm 
# End of macro FORTH_DSP
189a			 
189a d5				push de 
189b			 
189b 23				inc hl ; skip type 
189c			 
189c 5e				ld e, (hl) 
189d 23				inc hl 
189e 56				ld d, (hl) 
189f eb				ex de,hl  
18a0			 
18a0 d1				pop de 
18a1			 
18a1 c9				ret 
18a2			 
18a2			; return hl to start of value to second item on stack 
18a2			 
18a2			FORTH_DSP_VALUEM1: macro 
18a2				call macro_forth_dsp_value_m1 
18a2				endm 
18a2			 
18a2			macro_forth_dsp_value_m1: 
18a2			 
18a2				FORTH_DSP 
18a2 cd 93 18			call macro_forth_dsp 
18a5				endm 
# End of macro FORTH_DSP
18a5			 
18a5 2b				dec hl 
18a6 2b				dec hl 
18a7			;	dec hl 
18a7			 
18a7 d5				push de 
18a8			 
18a8 5e				ld e, (hl) 
18a9 23				inc hl 
18aa 56				ld d, (hl) 
18ab eb				ex de,hl  
18ac			 
18ac d1				pop de 
18ad			 
18ad c9				ret 
18ae			 
18ae				 
18ae			 
18ae			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
18ae			 
18ae			FORTH_DSP_POP: macro 
18ae				call macro_forth_dsp_pop 
18ae				endm 
18ae			 
18ae			 
18ae			; get the tos data type 
18ae			 
18ae			FORTH_DSP_TYPE:   macro 
18ae			 
18ae				;FORTH_DSP_VALUE 
18ae				FORTH_DSP 
18ae				 
18ae				; hl points to value 
18ae				; check type 
18ae			 
18ae				ld a,(hl) 
18ae			 
18ae				endm 
18ae			 
18ae			; load the tos value into hl 
18ae			 
18ae			 
18ae			FORTH_DSP_VALUEHL:  macro 
18ae				call macro_dsp_valuehl 
18ae				endm 
18ae			 
18ae			 
18ae			 
18ae			macro_dsp_valuehl: 
18ae				FORTH_DSP_VALUE 
18ae cd 97 18			call macro_forth_dsp_value 
18b1				endm 
# End of macro FORTH_DSP_VALUE
18b1			 
18b1				;FORTH_ERR_TOS_NOTNUM 
18b1			 
18b1				;inc hl   ; skip type id 
18b1			 
18b1			;	push de 
18b1			; 
18b1			;	ld e, (hl) 
18b1			;	inc hl 
18b1			;	ld d, (hl) 
18b1			;	ex de,hl  
18b1			 
18b1			;	pop de 
18b1			 
18b1				if DEBUG_FORTH_PUSH 
18b1						DMARK "DVL" 
18b1				CALLMONITOR 
18b1				endif 
18b1 c9				ret 
18b2			 
18b2			forth_apushstrhl:      
18b2				; push of string requires use of cli_origptr 
18b2				; bodge use 
18b2			 
18b2				; get current cli_origptr, save, update with temp pointer  
18b2 ed 5b 3e eb		ld de, (cli_origptr) 
18b6 22 3e eb			ld (cli_origptr), hl 
18b9 d5				push de 
18ba cd 5b 18			call forth_apush 
18bd d1				pop de 
18be ed 53 3e eb		ld (cli_origptr), de 
18c2 c9			        ret	 
18c3			 
18c3			 
18c3			; increase loop stack pointer and save hl to it 
18c3				 
18c3			FORTH_LOOP_NEXT: macro 
18c3				call macro_forth_loop_next 
18c3				;nop 
18c3				endm 
18c3			 
18c3			macro_forth_loop_next: 
18c3				if DEBUG_FORTH_STACK_GUARD 
18c3 cd 01 53				call check_stacks 
18c6				endif 
18c6 e5				push hl 
18c7 d5				push de 
18c8 eb				ex de,hl 
18c9 2a 24 eb			ld hl,(cli_loop_sp) 
18cc 23				inc hl 
18cd 23				inc hl 
18ce					if DEBUG_FORTH_WORDS 
18ce						DMARK "LNX" 
18ce f5				push af  
18cf 3a e3 18			ld a, (.dmark)  
18d2 32 7a ee			ld (debug_mark),a  
18d5 3a e4 18			ld a, (.dmark+1)  
18d8 32 7b ee			ld (debug_mark+1),a  
18db 3a e5 18			ld a, (.dmark+2)  
18de 32 7c ee			ld (debug_mark+2),a  
18e1 18 03			jr .pastdmark  
18e3 ..			.dmark: db "LNX"  
18e6 f1			.pastdmark: pop af  
18e7			endm  
# End of macro DMARK
18e7						CALLMONITOR 
18e7 cd 86 12			call break_point_state  
18ea				endm  
# End of macro CALLMONITOR
18ea					endif 
18ea 22 24 eb			ld (cli_loop_sp),hl 
18ed 73				ld (hl), e 
18ee 23				inc hl 
18ef 72				ld (hl), d 
18f0 d1				pop de    ; been reversed so save a swap on restore 
18f1 e1				pop hl 
18f2				if DEBUG_FORTH_STACK_GUARD 
18f2 cd 01 53				call check_stacks 
18f5				endif 
18f5 c9				ret 
18f6			 
18f6			; get current ret stack pointer and save to hl  
18f6				 
18f6			FORTH_LOOP_TOS: macro 
18f6				call macro_forth_loop_tos 
18f6				endm 
18f6			 
18f6			macro_forth_loop_tos: 
18f6 d5				push de 
18f7 2a 24 eb			ld hl,(cli_loop_sp) 
18fa 5e				ld e, (hl) 
18fb 23				inc hl 
18fc 56				ld d, (hl) 
18fd eb				ex de, hl 
18fe d1				pop de 
18ff c9				ret 
1900			 
1900			; pop loop stack pointer 
1900				 
1900			FORTH_LOOP_POP: macro 
1900				call macro_forth_loop_pop 
1900				endm 
1900			 
1900			 
1900			macro_forth_loop_pop: 
1900				if DEBUG_FORTH_STACK_GUARD 
1900					DMARK "LPP" 
1900 f5				push af  
1901 3a 15 19			ld a, (.dmark)  
1904 32 7a ee			ld (debug_mark),a  
1907 3a 16 19			ld a, (.dmark+1)  
190a 32 7b ee			ld (debug_mark+1),a  
190d 3a 17 19			ld a, (.dmark+2)  
1910 32 7c ee			ld (debug_mark+2),a  
1913 18 03			jr .pastdmark  
1915 ..			.dmark: db "LPP"  
1918 f1			.pastdmark: pop af  
1919			endm  
# End of macro DMARK
1919 cd 01 53				call check_stacks 
191c					FORTH_CHK_LOOP_UNDER 
191c e5				push hl 
191d d5				push de 
191e 2a 24 eb			ld hl,(cli_loop_sp) 
1921 11 de e9			ld de, cli_loop_stack 
1924 cd e0 0a			call cmp16 
1927 da 1b 54			jp c, fault_loop_under 
192a d1				pop de 
192b e1				pop hl 
192c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
192c				endif 
192c e5				push hl 
192d 2a 24 eb			ld hl,(cli_loop_sp) 
1930 2b				dec hl 
1931 2b				dec hl 
1932 22 24 eb			ld (cli_loop_sp), hl 
1935				; TODO do stack underflow checks 
1935 e1				pop hl 
1936				if DEBUG_FORTH_STACK_GUARD 
1936 cd 01 53				call check_stacks 
1939					FORTH_CHK_LOOP_UNDER 
1939 e5				push hl 
193a d5				push de 
193b 2a 24 eb			ld hl,(cli_loop_sp) 
193e 11 de e9			ld de, cli_loop_stack 
1941 cd e0 0a			call cmp16 
1944 da 1b 54			jp c, fault_loop_under 
1947 d1				pop de 
1948 e1				pop hl 
1949				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1949				endif 
1949 c9				ret 
194a			 
194a			macro_forth_dsp_pop: 
194a			 
194a e5				push hl 
194b			 
194b				; release malloc data 
194b			 
194b				if DEBUG_FORTH_STACK_GUARD 
194b cd 01 53				call check_stacks 
194e					FORTH_CHK_DSP_UNDER 
194e e5				push hl 
194f d5				push de 
1950 2a 22 eb			ld hl,(cli_data_sp) 
1953 11 dc e8			ld de, cli_data_stack 
1956 cd e0 0a			call cmp16 
1959 da 0f 54			jp c, fault_dsp_under 
195c d1				pop de 
195d e1				pop hl 
195e				endm 
# End of macro FORTH_CHK_DSP_UNDER
195e				endif 
195e				;ld hl,(cli_data_sp) 
195e			if DEBUG_FORTH_DOT 
195e				DMARK "DPP" 
195e				CALLMONITOR 
195e			endif	 
195e			 
195e			 
195e			if FORTH_ENABLE_DSPPOPFREE 
195e			 
195e				FORTH_DSP 
195e cd 93 18			call macro_forth_dsp 
1961				endm 
# End of macro FORTH_DSP
1961			 
1961 7e				ld a, (hl) 
1962 fe 01			cp DS_TYPE_STR 
1964 20 07			jr nz, .skippopfree 
1966			 
1966				FORTH_DSP_VALUEHL 
1966 cd ae 18			call macro_dsp_valuehl 
1969				endm 
# End of macro FORTH_DSP_VALUEHL
1969 00				nop 
196a			if DEBUG_FORTH_DOT 
196a				DMARK "DPf" 
196a				CALLMONITOR 
196a			endif	 
196a cd 53 10			call free 
196d			.skippopfree: 
196d				 
196d			 
196d			endif 
196d			 
196d			if DEBUG_FORTH_DOT_KEY 
196d				DMARK "DP2" 
196d				CALLMONITOR 
196d			endif	 
196d			 
196d				; move pointer down 
196d			 
196d 2a 22 eb			ld hl,(cli_data_sp) 
1970 2b				dec hl 
1971 2b				dec hl 
1972			; PARSEV5 
1972 2b				dec hl 
1973 22 22 eb			ld (cli_data_sp), hl 
1976			 
1976				if DEBUG_FORTH_STACK_GUARD 
1976 cd 01 53				call check_stacks 
1979					FORTH_CHK_DSP_UNDER 
1979 e5				push hl 
197a d5				push de 
197b 2a 22 eb			ld hl,(cli_data_sp) 
197e 11 dc e8			ld de, cli_data_stack 
1981 cd e0 0a			call cmp16 
1984 da 0f 54			jp c, fault_dsp_under 
1987 d1				pop de 
1988 e1				pop hl 
1989				endm 
# End of macro FORTH_CHK_DSP_UNDER
1989				endif 
1989			 
1989 e1				pop hl 
198a			 
198a c9				ret 
198b			 
198b			getwordathl: 
198b				; hl points to an address 
198b				; load hl with the word at that address 
198b			 
198b d5				push de 
198c			 
198c 5e				ld e, (hl) 
198d 23				inc hl 
198e 56				ld d, (hl) 
198f eb				ex de, hl 
1990			 
1990 d1				pop de 
1991 c9				ret 
1992			 
1992			 
1992			 
1992			 
1992			 
1992			; eof 
1992			 
# End of file forth_stackopsv5.asm
1992			endif 
1992			 
1992			user_word_eol:  
1992				; hl contains the pointer to where to create a linked list item from the end 
1992				; of the user dict to continue on at the system word dict 
1992				 
1992				; poke the stub of the word list linked list to repoint to rom words 
1992			 
1992				; stub format 
1992				; db   word id 
1992				; dw    link to next word 
1992			        ; db char length of token 
1992				; db string + 0 term 
1992				; db exec code....  
1992			 
1992 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1994 77				ld (hl), a		; word id 
1995 23				inc hl 
1996			 
1996 11 5c 1b			ld de, sysdict 
1999 73				ld (hl), e		; next word link ie system dict 
199a 23				inc hl 
199b 72				ld (hl), d		; next word link ie system dict 
199c 23				inc hl	 
199d			 
199d			;	ld (hl), sysdict		; next word link ie system dict 
199d			;	inc hl 
199d			;	inc hl 
199d			 
199d			;	inc hl 
199d			;	inc hl 
199d			 
199d 3e 02			ld a, 2			; word length is 0 
199f 77				ld (hl), a	 
19a0 23				inc hl 
19a1			 
19a1 3e 7e			ld a, '~'			; word length is 0 
19a3 77				ld (hl), a	 
19a4 23				inc hl 
19a5 3e 00			ld a, 0			; save empty word 
19a7 77				ld (hl), a 
19a8			 
19a8 c9				ret 
19a9			 
19a9				 
19a9			 
19a9			forthexec_cleanup: 
19a9				FORTH_RSP_POP 
19a9 cd db 17			call macro_forth_rsp_pop 
19ac				endm 
# End of macro FORTH_RSP_POP
19ac c9				ret 
19ad			 
19ad			forth_call_hl: 
19ad				; taking hl 
19ad e5				push hl 
19ae c9				ret 
19af			 
19af			; this is called to reset Forth system but keep existing uwords etc 
19af			 
19af			forth_warmstart: 
19af				; setup stack over/under flow checks 
19af				if DEBUG_FORTH_STACK_GUARD 
19af cd e7 52				call chk_stk_init 
19b2				endif 
19b2			 
19b2				; init stack pointers  - * these stacks go upwards *  
19b2 21 e0 ea			ld hl, cli_ret_stack 
19b5 22 26 eb			ld (cli_ret_sp), hl	 
19b8				; set bottom of stack 
19b8 3e 00			ld a,0 
19ba 77				ld (hl),a 
19bb 23				inc hl 
19bc 77				ld (hl),a 
19bd			 
19bd 21 dc e8			ld hl, cli_data_stack 
19c0 22 22 eb			ld (cli_data_sp), hl	 
19c3				; set bottom of stack 
19c3 3e 00			ld a,0 
19c5 77				ld (hl),a 
19c6 23				inc hl 
19c7 77				ld (hl),a 
19c8			 
19c8 21 de e9			ld hl, cli_loop_stack 
19cb 22 24 eb			ld (cli_loop_sp), hl	 
19ce				; set bottom of stack 
19ce 3e 00			ld a,0 
19d0 77				ld (hl),a 
19d1 23				inc hl 
19d2 77				ld (hl),a 
19d3			 
19d3				; init extent of current open file 
19d3			 
19d3 3e 00			ld a, 0 
19d5 32 5c eb			ld (store_openext), a 
19d8			 
19d8 c9				ret 
19d9			 
19d9			 
19d9			; Cold Start - this is called to setup the whole Forth system 
19d9			 
19d9			forth_init: 
19d9			 
19d9				; setup stack over/under flow checks 
19d9			 
19d9			;	if DEBUG_FORTH_STACK_GUARD 
19d9			;		call chk_stk_init 
19d9			;	endif 
19d9			 
19d9				; enable auto display updates (slow.....) 
19d9			 
19d9 3e 01			ld a, 1 
19db 32 3c eb			ld (cli_autodisplay), a 
19de			 
19de			 
19de			 
19de				; show start up screen 
19de			 
19de cd 69 09			call clear_display 
19e1			 
19e1 3e 00			ld a,0 
19e3 32 5e eb			ld (f_cursor_ptr), a 
19e6			 
19e6				; set start of word list in start of ram - for use when creating user words 
19e6			 
19e6 21 0a 56			ld hl, baseram 
19e9 22 72 e6			ld (os_last_new_uword), hl 
19ec cd 92 19			call user_word_eol 
19ef				 
19ef			;		call display_data_sp 
19ef			;		call next_page_prompt 
19ef			 
19ef			 
19ef			 
19ef			 
19ef c9				ret 
19f0			 
19f0 .. 00		.bootforth: db " Forth Kernel Init ",0 
1a04			 
1a04			; TODO push to stack 
1a04			 
1a04			;  
1a04			 
1a04			if FORTH_PARSEV2 
1a04			 
1a04			 
1a04				include "forth_parserv2.asm" 
1a04			 
1a04			endif 
1a04			 
1a04			 
1a04			; parse cli version 1 
1a04			 
1a04			if FORTH_PARSEV1 
1a04			 
1a04			 
1a04			 
1a04			      include "forth_parserv1.asm" 
1a04			endif 
1a04				 
1a04			if FORTH_PARSEV3 
1a04			 
1a04			 
1a04			 
1a04			      include "forth_parserv3.asm" 
1a04				include "forth_wordsv3.asm" 
1a04			endif 
1a04			 
1a04			if FORTH_PARSEV4 
1a04			 
1a04			 
1a04			 
1a04			      include "forth_parserv4.asm" 
1a04				include "forth_wordsv4.asm" 
1a04			endif 
1a04			 
1a04			if FORTH_PARSEV5 
1a04			 
1a04			 
1a04			 
1a04			      include "forth_parserv5.asm" 
1a04			 
1a04			 
1a04			; A better parser without using malloc and string copies all over the place.  
1a04			; Exec in situ should be faster 
1a04			 
1a04			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1a04			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1a04			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1a04			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1a04			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1a04			WORD_SYS_END: equ 0   ; Opcode for all user words 
1a04			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1a04			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1a04			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1a04			 
1a04			; Core word preamble macro 
1a04			 
1a04			CWHEAD:   macro nxtword opcode lit len opflags 
1a04				db WORD_SYS_CORE+opcode             
1a04				; internal op code number 
1a04				dw nxtword            
1a04				; link to next dict word block 
1a04				db len + 1 
1a04				; literal length of dict word inc zero term 
1a04				db lit,0              
1a04				; literal dict word 
1a04			        ; TODO db opflags        
1a04				endm 
1a04			 
1a04			 
1a04			NEXTW: macro  
1a04				jp macro_next 
1a04				endm 
1a04			 
1a04			macro_next: 
1a04			if DEBUG_FORTH_PARSE_KEY 
1a04				DMARK "NXT" 
1a04				CALLMONITOR 
1a04			endif	 
1a04			;	inc hl  ; skip token null term  
1a04 ed 4b 40 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1a08 ed 5b 3e eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1a0c 2a 76 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1a0f			if DEBUG_FORTH_PARSE_KEY 
1a0f				DMARK "}AA" 
1a0f				CALLMONITOR 
1a0f			endif	 
1a0f c3 12 1b			jp execnext 
1a12				;jp exec1 
1a12			       
1a12			 
1a12			 
1a12			; Another go at the parser to compile  
1a12			 
1a12			 
1a12			; TODO rework parser to change all of the string words to byte tokens 
1a12			; TODO do a search for  
1a12			 
1a12			; TODO first run normal parser to zero term sections 
1a12			; TODO for each word do a token look up to get the op code 
1a12			; TODO need some means to flag to the exec that this is a byte code form    
1a12			 
1a12			 
1a12			forthcompile: 
1a12			 
1a12			; 
1a12			; line parse: 
1a12			;       parse raw input buffer 
1a12			;       tokenise the words 
1a12			;       malloc new copy (for looping etc) 
1a12			;       copy to malloc + current pc in line to start of string and add line term 
1a12			;       save on new rsp 
1a12			; 
1a12			 
1a12			; hl to point to the line to tokenise 
1a12			 
1a12			;	push hl 
1a12 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1a15			 
1a15			;	ld a,0		; string term on input 
1a15			;	call strlent 
1a15			 
1a15			;	ld (os_tok_len), hl	 ; save string length 
1a15			 
1a15			;if DEBUG_FORTH_TOK 
1a15			;	ex de,hl		 
1a15			;endif 
1a15			 
1a15			;	pop hl 		; get back string pointer 
1a15			 
1a15			if DEBUG_FORTH_TOK 
1a15						DMARK "TOc" 
1a15				CALLMONITOR 
1a15			endif 
1a15 7e			.cptoken2:    ld a,(hl) 
1a16 23				inc hl 
1a17 fe 7f			cp FORTH_END_BUFFER 
1a19 28 29			jr z, .cptokendone2 
1a1b fe 00			cp 0 
1a1d 28 25			jr z, .cptokendone2 
1a1f fe 22			cp '"' 
1a21 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1a23 fe 20			cp ' ' 
1a25 20 ee			jr nz,  .cptoken2 
1a27			 
1a27			; TODO consume comments held between ( and ) 
1a27			 
1a27				; we have a space so change to zero term for dict match later 
1a27 2b				dec hl 
1a28 3e 00			ld a,0 
1a2a 77				ld (hl), a 
1a2b 23				inc hl 
1a2c 18 e7			jr .cptoken2 
1a2e				 
1a2e			 
1a2e			.cptokenstr2: 
1a2e				; skip all white space until either eol (because forgot to term) or end double quote 
1a2e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1a2e				;inc hl ; skip current double quote 
1a2e 7e				ld a,(hl) 
1a2f 23				inc hl 
1a30 fe 22			cp '"' 
1a32 28 e1			jr z, .cptoken2 
1a34 fe 7f			cp FORTH_END_BUFFER 
1a36 28 0c			jr z, .cptokendone2 
1a38 fe 00			cp 0 
1a3a 28 08			jr z, .cptokendone2 
1a3c fe 20			cp ' ' 
1a3e 28 02			jr z, .cptmp2 
1a40 18 ec			jr .cptokenstr2 
1a42			 
1a42			.cptmp2:	; we have a space so change to zero term for dict match later 
1a42				;dec hl 
1a42				;ld a,"-"	; TODO remove this when working 
1a42				;ld (hl), a 
1a42				;inc hl 
1a42 18 ea			jr .cptokenstr2 
1a44			 
1a44			.cptokendone2: 
1a44				;inc hl 
1a44 3e 7f			ld a, FORTH_END_BUFFER 
1a46 77				ld (hl),a 
1a47 23				inc hl 
1a48 3e 21			ld a, '!' 
1a4a 77				ld (hl),a 
1a4b			 
1a4b 2a 76 e6			ld hl,(os_tok_ptr) 
1a4e			         
1a4e			if DEBUG_FORTH_TOK 
1a4e						DMARK "Tc1" 
1a4e				CALLMONITOR 
1a4e			endif 
1a4e			 
1a4e				; push exec string to top of return stack 
1a4e				FORTH_RSP_NEXT 
1a4e cd ba 17			call macro_forth_rsp_next 
1a51				endm 
# End of macro FORTH_RSP_NEXT
1a51 c9				ret 
1a52			 
1a52			; Another go at the parser need to simplify the process 
1a52			 
1a52			forthparse: 
1a52			 
1a52			; 
1a52			; line parse: 
1a52			;       parse raw input buffer 
1a52			;       tokenise the words 
1a52			;       malloc new copy (for looping etc) 
1a52			;       copy to malloc + current pc in line to start of string and add line term 
1a52			;       save on new rsp 
1a52			; 
1a52			 
1a52			; hl to point to the line to tokenise 
1a52			 
1a52			;	push hl 
1a52 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1a55			 
1a55			;	ld a,0		; string term on input 
1a55			;	call strlent 
1a55			 
1a55			;	ld (os_tok_len), hl	 ; save string length 
1a55			 
1a55			;if DEBUG_FORTH_TOK 
1a55			;	ex de,hl		 
1a55			;endif 
1a55			 
1a55			;	pop hl 		; get back string pointer 
1a55			 
1a55			if DEBUG_FORTH_TOK 
1a55						DMARK "TOK" 
1a55				CALLMONITOR 
1a55			endif 
1a55 7e			.ptoken2:    ld a,(hl) 
1a56 23				inc hl 
1a57 fe 7f			cp FORTH_END_BUFFER 
1a59 28 29			jr z, .ptokendone2 
1a5b fe 00			cp 0 
1a5d 28 25			jr z, .ptokendone2 
1a5f fe 22			cp '"' 
1a61 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1a63 fe 20			cp ' ' 
1a65 20 ee			jr nz,  .ptoken2 
1a67			 
1a67			; TODO consume comments held between ( and ) 
1a67			 
1a67				; we have a space so change to zero term for dict match later 
1a67 2b				dec hl 
1a68 3e 00			ld a,0 
1a6a 77				ld (hl), a 
1a6b 23				inc hl 
1a6c 18 e7			jr .ptoken2 
1a6e				 
1a6e			 
1a6e			.ptokenstr2: 
1a6e				; skip all white space until either eol (because forgot to term) or end double quote 
1a6e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1a6e				;inc hl ; skip current double quote 
1a6e 7e				ld a,(hl) 
1a6f 23				inc hl 
1a70 fe 22			cp '"' 
1a72 28 e1			jr z, .ptoken2 
1a74 fe 7f			cp FORTH_END_BUFFER 
1a76 28 0c			jr z, .ptokendone2 
1a78 fe 00			cp 0 
1a7a 28 08			jr z, .ptokendone2 
1a7c fe 20			cp ' ' 
1a7e 28 02			jr z, .ptmp2 
1a80 18 ec			jr .ptokenstr2 
1a82			 
1a82			.ptmp2:	; we have a space so change to zero term for dict match later 
1a82				;dec hl 
1a82				;ld a,"-"	; TODO remove this when working 
1a82				;ld (hl), a 
1a82				;inc hl 
1a82 18 ea			jr .ptokenstr2 
1a84			 
1a84			.ptokendone2: 
1a84				;inc hl 
1a84 3e 7f			ld a, FORTH_END_BUFFER 
1a86 77				ld (hl),a 
1a87 23				inc hl 
1a88 3e 21			ld a, '!' 
1a8a 77				ld (hl),a 
1a8b			 
1a8b 2a 76 e6			ld hl,(os_tok_ptr) 
1a8e			         
1a8e			if DEBUG_FORTH_TOK 
1a8e						DMARK "TK1" 
1a8e				CALLMONITOR 
1a8e			endif 
1a8e			 
1a8e				; push exec string to top of return stack 
1a8e				FORTH_RSP_NEXT 
1a8e cd ba 17			call macro_forth_rsp_next 
1a91				endm 
# End of macro FORTH_RSP_NEXT
1a91 c9				ret 
1a92			 
1a92			; 
1a92			;	; malloc size + buffer pointer + if is loop flag 
1a92			;	ld hl,(os_tok_len) 		 ; get string length 
1a92			; 
1a92			;	ld a,l 
1a92			; 
1a92			;	cp 0			; we dont want to use a null string 
1a92			;	ret z 
1a92			; 
1a92			;;	add 3    ; prefix malloc with buffer for current word ptr 
1a92			; 
1a92			;	add 5     ; TODO when certain not over writing memory remove 
1a92			; 
1a92			;		 
1a92			; 
1a92			;if DEBUG_FORTH_TOK 
1a92			;			DMARK "TKE" 
1a92			;	CALLMONITOR 
1a92			;endif 
1a92			; 
1a92			;	ld l,a 
1a92			;	ld h,0 
1a92			;;	push hl   ; save required space for the copy later 
1a92			;	call malloc 
1a92			;if DEBUG_FORTH_TOK 
1a92			;			DMARK "TKM" 
1a92			;	CALLMONITOR 
1a92			;endif 
1a92			;	if DEBUG_FORTH_MALLOC_GUARD 
1a92			;		push af 
1a92			;		call ishlzero 
1a92			;;		ld a, l 
1a92			;;		add h 
1a92			;;		cp 0 
1a92			;		pop af 
1a92			;		 
1a92			;		call z,malloc_error 
1a92			;	endif 
1a92			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1a92			; 
1a92			; 
1a92			;if DEBUG_FORTH_TOK 
1a92			;			DMARK "TKR" 
1a92			;	CALLMONITOR 
1a92			;endif 
1a92			; 
1a92			;	FORTH_RSP_NEXT 
1a92			; 
1a92			;	;inc hl	 ; go past current buffer pointer 
1a92			;	;inc hl 
1a92			;	;inc hl   ; and past if loop flag 
1a92			;		; TODO Need to set flag  
1a92			; 
1a92			;	 
1a92			;	 
1a92			;	ex de,hl	; malloc is dest 
1a92			;	ld hl, (os_tok_len) 
1a92			;;	pop bc 
1a92			;	ld c, l                
1a92			;	ld b,0 
1a92			;	ld hl, (os_tok_ptr) 
1a92			; 
1a92			;if DEBUG_FORTH_TOK 
1a92			;			DMARK "TKT" 
1a92			;	CALLMONITOR 
1a92			;endif 
1a92			; 
1a92			;	; do str cpy 
1a92			; 
1a92			;	ldir      ; copy byte in hl to de 
1a92			; 
1a92			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1a92			; 
1a92			;if DEBUG_FORTH_TOK 
1a92			; 
1a92			;			DMARK "TKY" 
1a92			;	CALLMONITOR 
1a92			;endif 
1a92			;	;ld a,0 
1a92			;	;ld a,FORTH_END_BUFFER 
1a92			;	ex de, hl 
1a92			;	;dec hl			 ; go back over the space delim at the end of word 
1a92			;	;ld (hl),a 
1a92			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1a92			;	ld a,FORTH_END_BUFFER 
1a92			;	ld (hl),a 
1a92			;	inc hl 
1a92			;	ld a,FORTH_END_BUFFER 
1a92			;	ld (hl),a 
1a92			; 
1a92			;	; init the malloc area data 
1a92			;	; set pc for in current area 
1a92			;	;ld hl, (os_tok_malloc) 
1a92			;	;inc hl 
1a92			;	;inc hl 
1a92			;	;inc hl 
1a92			;	;ex de,hl 
1a92			;	;ld hl, (os_tok_malloc) 
1a92			;	;ld (hl),e 
1a92			;	;inc hl 
1a92			;	;ld (hl),d 
1a92			; 
1a92			; 
1a92			;	ld hl,(os_tok_malloc) 
1a92			;if DEBUG_FORTH_PARSE_KEY 
1a92			;			DMARK "TKU" 
1a92			;	CALLMONITOR 
1a92			;endif 
1a92			; 
1a92			;	ret 
1a92			 
1a92			forthexec: 
1a92			 
1a92			; line exec: 
1a92			; forth parser 
1a92			 
1a92			; 
1a92			;       get current exec line on rsp 
1a92			 
1a92				FORTH_RSP_TOS 
1a92 cd d1 17			call macro_forth_rsp_tos 
1a95				endm 
# End of macro FORTH_RSP_TOS
1a95			 
1a95			;       restore current pc - hl points to malloc of data 
1a95			 
1a95				;ld e, (hl) 
1a95				;inc hl 
1a95				;ld d, (hl) 
1a95				;ex de,hl 
1a95			 
1a95			 
1a95			exec1: 
1a95 22 76 e6			ld (os_tok_ptr), hl 
1a98			 
1a98				; copy our PC to working vars  
1a98 22 40 eb			ld (cli_ptr), hl 
1a9b 22 3e eb			ld (cli_origptr), hl 
1a9e			 
1a9e 7e				ld a,(hl) 
1a9f fe 7f			cp FORTH_END_BUFFER 
1aa1 c8				ret z 
1aa2			 
1aa2				; skip any nulls 
1aa2			 
1aa2 fe 00			cp 0 
1aa4 20 03			jr nz, .execword 
1aa6 23				inc hl 
1aa7 18 ec			jr exec1 
1aa9			 
1aa9			 
1aa9			.execword: 
1aa9			 
1aa9			 
1aa9			 
1aa9			if DEBUG_FORTH_PARSE_KEY 
1aa9						DMARK "KYQ" 
1aa9				CALLMONITOR 
1aa9			endif 
1aa9			;       while at start of word: 
1aa9			; get start of dict (in user area first) 
1aa9			 
1aa9 21 0a 56		ld hl, baseram 
1aac			;ld hl, sysdict 
1aac 22 42 eb		ld (cli_nextword),hl 
1aaf			;           match word at pc 
1aaf			;           exec word 
1aaf			;           or push to dsp 
1aaf			;           forward to next token 
1aaf			;           if line term pop rsp and exit 
1aaf			;        
1aaf			 
1aaf			if DEBUG_FORTH_PARSE_KEY 
1aaf						DMARK "KYq" 
1aaf				CALLMONITOR 
1aaf			endif 
1aaf			 
1aaf			; 
1aaf			; word comp 
1aaf			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1aaf			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1aaf			;    move to start of word  
1aaf			;    compare word to cli_token 
1aaf			 
1aaf			.execpnword:	; HL at start of a word in the dictionary to check 
1aaf			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1aaf			;	ld (cli_ptr), hl 
1aaf			 
1aaf 2a 42 eb			ld hl,(cli_nextword) 
1ab2			 
1ab2 cd 55 1b			call forth_tok_next 
1ab5			; tok next start here 
1ab5			;	; TODO skip compiled symbol for now 
1ab5			;	inc hl 
1ab5			; 
1ab5			;	; save pointer to next word 
1ab5			; 
1ab5			;	; hl now points to the address of the next word pointer  
1ab5			;	ld e, (hl) 
1ab5			;	inc hl 
1ab5			;	ld d, (hl) 
1ab5			;	inc l 
1ab5			; 
1ab5			;	ex de,hl 
1ab5			;if DEBUG_FORTH_PARSE_NEXTWORD 
1ab5			;	push bc 
1ab5			;	ld bc, (cli_nextword) 
1ab5			;			DMARK "NXW" 
1ab5			;	CALLMONITOR 
1ab5			;	pop bc 
1ab5			;endif 
1ab5			; tok next end here 
1ab5 22 42 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1ab8 eb				ex de, hl 
1ab9			 
1ab9			 
1ab9				; save the pointer of the current token - 1 to check against 
1ab9				 
1ab9 22 46 eb			ld (cli_token), hl   
1abc				; TODO maybe remove below save if no debug 
1abc				; save token string ptr for any debug later 
1abc 23				inc hl  
1abd 22 48 eb			ld (cli_origtoken), hl 
1ac0 2b				dec hl 
1ac1				; save pointer to the start of the next dictionay word 
1ac1 7e				ld a,(hl)   ; get string length 
1ac2 47				ld b,a 
1ac3			.execpnwordinc:  
1ac3 23				inc hl 
1ac4 10 fd			djnz .execpnwordinc 
1ac6 22 44 eb			ld (cli_execword), hl      ; save start of this words code 
1ac9			 
1ac9				; now check the word token against the string being parsed 
1ac9			 
1ac9 2a 46 eb			ld hl,(cli_token) 
1acc 23				inc hl     ; skip string length (use zero term instead to end) 
1acd 22 46 eb			ld (cli_token), hl 
1ad0			 
1ad0			if DEBUG_FORTH_PARSE_KEY 
1ad0						DMARK "KY2" 
1ad0			endif 
1ad0			if DEBUG_FORTH_PARSE_EXEC 
1ad0				; see if disabled 
1ad0			 
1ad0				ld a, (os_view_disable) 
1ad0				cp '*' 
1ad0				jr z, .skip 
1ad0			 
1ad0				push hl 
1ad0				push hl 
1ad0				call clear_display 
1ad0				ld de, .compword 
1ad0				ld a, display_row_1 
1ad0				call str_at_display 
1ad0				pop de 
1ad0				ld a, display_row_2 
1ad0				call str_at_display 
1ad0				ld hl,(cli_ptr) 
1ad0				ld a,(hl) 
1ad0			        ld hl, os_word_scratch 
1ad0				ld (hl),a 
1ad0				ld a,0 
1ad0				inc hl 
1ad0				ld (hl),a 	 
1ad0				ld de, os_word_scratch 
1ad0				ld a, display_row_2+10 
1ad0				call str_at_display 
1ad0				call update_display 
1ad0				ld a, 100 
1ad0				call aDelayInMS 
1ad0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1ad0				call delay250ms 
1ad0				endif 
1ad0				pop hl 
1ad0			.skip:  
1ad0			endif	 
1ad0			.execpnchar:    ; compare char between token and string to parse 
1ad0			 
1ad0			if DEBUG_FORTH_PARSE_KEY 
1ad0						DMARK "Ky3" 
1ad0			endif 
1ad0			if DEBUG_FORTH_PARSE_EXEC 
1ad0				; see if disabled 
1ad0			 
1ad0				ld a, (os_view_disable) 
1ad0				cp '*' 
1ad0				jr z, .skip2 
1ad0			 
1ad0			;	call clear_display 
1ad0			ld hl,(cli_token) 
1ad0			ld a,(hl) 
1ad0			ld (os_word_scratch),a 
1ad0				ld hl,(cli_ptr) 
1ad0			ld a,(hl) 
1ad0				ld (os_word_scratch+1),a 
1ad0				ld a,0 
1ad0				ld (os_word_scratch+2),a 
1ad0				ld de,os_word_scratch 
1ad0				ld a,display_row_4 
1ad0				call str_at_display 
1ad0				call update_display 
1ad0			.skip2:  
1ad0			endif 
1ad0 2a 46 eb			ld hl,(cli_token) 
1ad3 7e				ld a, (hl)	 ; char in word token 
1ad4 23				inc hl 		; move to next char 
1ad5 22 46 eb			ld (cli_token), hl ; and save it 
1ad8 47				ld b,a 
1ad9			 
1ad9 2a 40 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1adc 7e				ld a,(hl) 
1add 23				inc hl 
1ade 22 40 eb			ld (cli_ptr), hl		; move to next char 
1ae1 cd 17 0f			call toUpper 		; make sure the input string matches case 
1ae4			 
1ae4			if DEBUG_FORTH_PARSE 
1ae4			endif 
1ae4			 
1ae4				; input stream end of token is a space so get rid of it 
1ae4			 
1ae4			;	cp ' ' 
1ae4			;	jr nz, .pnskipspace 
1ae4			; 
1ae4			;	ld a, 0		; make same term as word token term 
1ae4			; 
1ae4			;.pnskipspace: 
1ae4			 
1ae4			if DEBUG_FORTH_PARSE_KEY 
1ae4						DMARK "KY7" 
1ae4			endif 
1ae4 b8				cp b 
1ae5 c2 fb 1a			jp nz, .execpnskipword	 ; no match so move to next word 
1ae8				 
1ae8			;    if same 
1ae8			;       scan for string terms 0 for token and 32 for input 
1ae8			 
1ae8				 
1ae8			if DEBUG_FORTH_PARSE_KEY 
1ae8						DMARK "KY8" 
1ae8			endif 
1ae8			 
1ae8 80				add b			 
1ae9 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1aeb							; TODO need to make sure last word in zero term string is accounted for 
1aeb 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1aed			 
1aed			 
1aed				; at end of both strings so both are exact match 
1aed			 
1aed			;       skip ptr for next word 
1aed			 
1aed 2a 40 eb			ld hl,(cli_ptr) 	; at input string term 
1af0 23				inc hl			 ; at next char 
1af1 22 40 eb			ld (cli_ptr), hl     ; save for next round of the parser 
1af4 22 3e eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1af7				 
1af7				 
1af7			if DEBUG_FORTH_PARSE_KEY 
1af7						DMARK "KY3" 
1af7			endif 
1af7			 
1af7			 
1af7			 
1af7			;       exec code block 
1af7			if DEBUG_FORTH_JP 
1af7				call clear_display 
1af7				call update_display 
1af7				call delay1s 
1af7				ld hl, (cli_execword)     ; save for next check if no match on this word 
1af7				ld a,h 
1af7				ld hl, os_word_scratch 
1af7				call hexout 
1af7				ld hl, (cli_execword)     ; save for next check if no match on this word 
1af7				ld a,l 
1af7				ld hl, os_word_scratch+2 
1af7				call hexout 
1af7				ld hl, os_word_scratch+4 
1af7				ld a,0 
1af7				ld (hl),a 
1af7				ld de,os_word_scratch 
1af7				call str_at_display 
1af7					ld a, display_row_2 
1af7					call str_at_display 
1af7				ld de, (cli_origtoken) 
1af7				ld a, display_row_1+10 
1af7					call str_at_display 
1af7			 
1af7				ld a,display_row_1 
1af7				ld de, .foundword 
1af7				ld a, display_row_3 
1af7				call str_at_display 
1af7				call update_display 
1af7				call delay1s 
1af7				call delay1s 
1af7				call delay1s 
1af7			endif 
1af7			 
1af7			if DEBUG_FORTH_PARSE_KEY 
1af7						DMARK "KYj" 
1af7			endif 
1af7				; TODO save the word pointer in this exec 
1af7			 
1af7 2a 44 eb			ld hl,(cli_execword) 
1afa e9				jp (hl) 
1afb			 
1afb			 
1afb			;    if not same 
1afb			;	scan for zero term 
1afb			;	get ptr for next word 
1afb			;	goto word comp 
1afb			 
1afb			.execpnskipword:	; get pointer to next word 
1afb 2a 42 eb			ld hl,(cli_nextword) 
1afe			 
1afe 7e				ld a,(hl) 
1aff fe 00			cp WORD_SYS_END 
1b01			;	cp 0 
1b01 28 09			jr z, .execendofdict			 ; at end of words 
1b03			 
1b03			if DEBUG_FORTH_PARSE_KEY 
1b03						DMARK "KY4" 
1b03			endif 
1b03			if DEBUG_FORTH_PARSE_EXEC 
1b03			 
1b03				; see if disabled 
1b03			 
1b03				ld a, (os_view_disable) 
1b03				cp '*' 
1b03				jr z, .noskip 
1b03			 
1b03			 
1b03				ld de, .nowordfound 
1b03				ld a, display_row_3 
1b03				call str_at_display 
1b03				call update_display 
1b03				ld a, 100 
1b03				call aDelayInMS 
1b03				 
1b03				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1b03					call delay250ms 
1b03				endif 
1b03			.noskip:  
1b03			 
1b03			endif	 
1b03			 
1b03 2a 3e eb			ld hl,(cli_origptr) 
1b06 22 40 eb			ld (cli_ptr),hl 
1b09			 
1b09			if DEBUG_FORTH_PARSE_KEY 
1b09						DMARK "KY5" 
1b09			endif 
1b09 c3 af 1a			jp .execpnword			; else go to next word 
1b0c			 
1b0c			.execendofdict:  
1b0c			 
1b0c			if DEBUG_FORTH_PARSE_KEY 
1b0c						DMARK "KYe" 
1b0c			endif 
1b0c			if DEBUG_FORTH_PARSE_EXEC 
1b0c				; see if disabled 
1b0c			 
1b0c				ld a, (os_view_disable) 
1b0c				cp '*' 
1b0c				jr z, .ispskip 
1b0c			 
1b0c				call clear_display 
1b0c				call update_display 
1b0c				call delay1s 
1b0c				ld de, (cli_origptr) 
1b0c				ld a, display_row_1 
1b0c				call str_at_display 
1b0c				 
1b0c				ld de, .enddict 
1b0c				ld a, display_row_3 
1b0c				call str_at_display 
1b0c				call update_display 
1b0c				ld a, 100 
1b0c				call aDelayInMS 
1b0c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1b0c				call delay1s 
1b0c				call delay1s 
1b0c				call delay1s 
1b0c				endif 
1b0c			.ispskip:  
1b0c				 
1b0c			endif	 
1b0c			 
1b0c			 
1b0c			 
1b0c				; if the word is not a keyword then must be a literal so push it to stack 
1b0c			 
1b0c			; push token to stack to end of word 
1b0c			 
1b0c				STACKFRAME ON $1efe $2f9f 
1b0c				if DEBUG_STACK_IMB 
1b0c					if ON 
1b0c						exx 
1b0c						ld de, $1efe 
1b0c						ld a, d 
1b0c						ld hl, curframe 
1b0c						call hexout 
1b0c						ld a, e 
1b0c						ld hl, curframe+2 
1b0c						call hexout 
1b0c						ld hl, $1efe 
1b0c						push hl 
1b0c						ld hl, $2f9f 
1b0c						push hl 
1b0c						exx 
1b0c					endif 
1b0c				endif 
1b0c			endm 
# End of macro STACKFRAME
1b0c			 
1b0c 2a 76 e6		ld hl,(os_tok_ptr) 
1b0f cd 5b 18		call forth_apush 
1b12			 
1b12				STACKFRAMECHK ON $1efe $2f9f 
1b12				if DEBUG_STACK_IMB 
1b12					if ON 
1b12						exx 
1b12						ld hl, $2f9f 
1b12						pop de   ; $2f9f 
1b12						call cmp16 
1b12						jr nz, .spnosame 
1b12						ld hl, $1efe 
1b12						pop de   ; $1efe 
1b12						call cmp16 
1b12						jr z, .spfrsame 
1b12						.spnosame: call showsperror 
1b12						.spfrsame: nop 
1b12						exx 
1b12					endif 
1b12				endif 
1b12			endm 
# End of macro STACKFRAMECHK
1b12			 
1b12			execnext: 
1b12			 
1b12			if DEBUG_FORTH_PARSE_KEY 
1b12						DMARK "KY>" 
1b12			endif 
1b12			; move past token to next word 
1b12			 
1b12 2a 76 e6		ld hl, (os_tok_ptr) 
1b15 3e 00		ld a, 0 
1b17 01 ff 00		ld bc, 255     ; input buffer size 
1b1a ed b1		cpir 
1b1c			 
1b1c			if DEBUG_FORTH_PARSE_KEY 
1b1c						DMARK "KY!" 
1b1c				CALLMONITOR 
1b1c			endif	 
1b1c			; TODO this might place hl on the null, so will need to forward on??? 
1b1c			;inc hl   ; see if this gets onto the next item 
1b1c			 
1b1c			 
1b1c			; TODO pass a pointer to the buffer to push 
1b1c			; TODO call function to push 
1b1c			 
1b1c			; look for end of input 
1b1c			 
1b1c			;inc hl 
1b1c			;ld a,(hl) 
1b1c			;cp FORTH_END_BUFFER 
1b1c			;ret z 
1b1c			 
1b1c			 
1b1c c3 95 1a		jp exec1 
1b1f			 
1b1f			 
1b1f			 
1b1f			 
1b1f			 
1b1f			 
1b1f			 
1b1f			 
1b1f			 
1b1f			findnexttok: 
1b1f			 
1b1f				; hl is pointer to move 
1b1f				; de is the token to locate 
1b1f			 
1b1f					if DEBUG_FORTH 
1b1f						DMARK "NTK" 
1b1f						CALLMONITOR 
1b1f					endif 
1b1f d5				push de 
1b20			 
1b20			.fnt1:	 
1b20				; find first char of token to locate 
1b20			 
1b20 1a				ld a, (de) 
1b21 4f				ld c,a 
1b22 7e				ld a,(hl) 
1b23 cd 17 0f			call toUpper 
1b26					if DEBUG_FORTH 
1b26						DMARK "NT1" 
1b26						CALLMONITOR 
1b26					endif 
1b26 b9				cp c 
1b27			 
1b27 28 03			jr z, .fnt2cmpmorefirst	 
1b29			 
1b29				; first char not found move to next char 
1b29			 
1b29 23				inc hl 
1b2a 18 f4			jr .fnt1 
1b2c			 
1b2c			.fnt2cmpmorefirst:	 
1b2c				; first char of token found.  
1b2c			 
1b2c e5				push hl     ; save start of token just in case it is the right one 
1b2d d9				exx 
1b2e e1				pop hl        ; save it to hl' 
1b2f d9				exx 
1b30			 
1b30			 
1b30			.fnt2cmpmore:	 
1b30				; compare the rest 
1b30				 
1b30 23				inc hl 
1b31 13				inc de 
1b32				 
1b32 1a				ld a, (de) 
1b33 4f				ld c,a 
1b34 7e				ld a,(hl) 
1b35 cd 17 0f			call toUpper 
1b38			 
1b38					if DEBUG_FORTH 
1b38						DMARK "NT2" 
1b38						CALLMONITOR 
1b38					endif 
1b38				; c has the token to find char 
1b38				; a has the mem to scan char 
1b38			 
1b38 b9				cp c 
1b39 28 04			jr z,.fntmatch1 
1b3b			 
1b3b				; they are not the same 
1b3b			 
1b3b					if DEBUG_FORTH 
1b3b						DMARK "NT3" 
1b3b						CALLMONITOR 
1b3b					endif 
1b3b d1				pop de	; reset de token to look for 
1b3c d5				push de 
1b3d 18 e1			jr .fnt1 
1b3f				 
1b3f			.fntmatch1: 
1b3f			 
1b3f				; is the same char a null which means we might have a full hit? 
1b3f					if DEBUG_FORTH 
1b3f						DMARK "NT4" 
1b3f						CALLMONITOR 
1b3f					endif 
1b3f			 
1b3f fe 00			cp 0 
1b41 28 0b			jr z, .fntmatchyes 
1b43			 
1b43				; are we at the end of the token to find? 
1b43			 
1b43					if DEBUG_FORTH 
1b43						DMARK "NT5" 
1b43						CALLMONITOR 
1b43					endif 
1b43 3e 00			ld a, 0 
1b45 b9				cp c 
1b46			 
1b46 c2 30 1b			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1b49			 
1b49					if DEBUG_FORTH 
1b49						DMARK "NT6" 
1b49						CALLMONITOR 
1b49					endif 
1b49				; token to find is exhusted but no match to stream 
1b49			 
1b49				; restore tok pointer and continue on 
1b49 d1				pop de 
1b4a d5				push de 
1b4b c3 20 1b			jp .fnt1 
1b4e			 
1b4e			 
1b4e			.fntmatchyes: 
1b4e			 
1b4e				; hl now contains the end of the found token 
1b4e			 
1b4e				; get rid of saved token pointer to find 
1b4e			 
1b4e d1				pop de 
1b4f			 
1b4f					if DEBUG_FORTH 
1b4f						DMARK "NT9" 
1b4f						CALLMONITOR 
1b4f					endif 
1b4f			 
1b4f				; hl will be on the null term so forward on 
1b4f			 
1b4f				; get back the saved start of the token 
1b4f			 
1b4f d9				exx 
1b50 e5				push hl     ; save start of token just in case it is the right one 
1b51 d9				exx 
1b52 e1				pop hl        ; save it to hl 
1b53			 
1b53 c9				ret 
1b54			 
1b54			 
1b54			; LIST needs to find a specific token   
1b54			; FORGET needs to find a spefici token 
1b54			 
1b54			; SAVE needs to find all tokens by flag 
1b54			; WORDS just needs to scan through all  by flag 
1b54			; UWORDS needs to scan through all by flag 
1b54			 
1b54			 
1b54			; given hl as pointer to start of dict look up string 
1b54			; return hl as pointer to start of word block 
1b54			; or 0 if not found 
1b54			 
1b54			forth_find_tok: 
1b54 c9				ret 
1b55			 
1b55			; given hl as pointer to dict structure 
1b55			; move to the next dict block structure 
1b55			 
1b55			forth_tok_next: 
1b55				; hl now points to the address of the next word pointer  
1b55				; TODO skip compiled symbol for now 
1b55			;	push de 
1b55 23				inc hl 
1b56 5e				ld e, (hl) 
1b57 23				inc hl 
1b58 56				ld d, (hl) 
1b59 23				inc hl 
1b5a			 
1b5a eb				ex de,hl 
1b5b			if DEBUG_FORTH_PARSE_NEXTWORD 
1b5b				push bc 
1b5b				ld bc, (cli_nextword) 
1b5b						DMARK "NXW" 
1b5b				CALLMONITOR 
1b5b				pop bc 
1b5b			endif 
1b5b			;	pop de	 
1b5b c9				ret 
1b5c			 
1b5c			 
1b5c			 
1b5c			; eof 
# End of file forth_parserv5.asm
1b5c				include "forth_wordsv4.asm" 
1b5c			 
1b5c			; the core word dictionary v4 
1b5c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1b5c			 
1b5c			; this is a linked list for each of the system words used 
1b5c			; user defined words will follow the same format but will be in ram 
1b5c			 
1b5c			 
1b5c			; 
1b5c			; 
1b5c			; define linked list: 
1b5c			; 
1b5c			; 1. compiled byte op code 
1b5c			; 2. len of text word 
1b5c			; 3. text word 
1b5c			; 4. ptr to next dictionary word 
1b5c			; 5. asm, calls etc for the word 
1b5c			; 
1b5c			;  if 1 == 0 then last word in dict  
1b5c			;   
1b5c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1b5c			;  
1b5c			;  
1b5c			; create basic standard set of words 
1b5c			; 
1b5c			;  
1b5c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1b5c			; 2DUP 2DROP 2SWAP  
1b5c			; @ C@ - get byte  
1b5c			; ! C! - store byte 
1b5c			; 0< true if less than zero 
1b5c			; 0= true if zero 
1b5c			; < >  
1b5c			; = true if same 
1b5c			; variables 
1b5c			 
1b5c			 
1b5c			; Hardware specific words I may need 
1b5c			; 
1b5c			; IN OUT  
1b5c			; calls to key util functions 
1b5c			; calls to hardward abstraction stuff 
1b5c			; easy control of frame buffers and lcd i/o 
1b5c			; keyboard  
1b5c			 
1b5c			 
1b5c			;DICT: macro 
1b5c			; op_code, len, word, next 
1b5c			;    word: 
1b5c			;    db op_code 
1b5c			;    ds word zero term 
1b5c			;    dw next 
1b5c			;    endm 
1b5c			 
1b5c			 
1b5c			 
1b5c			 
1b5c			; op code 1 is a flag for user define words which are to be handled differently 
1b5c			 
1b5c			 
1b5c			; 
1b5c			; 
1b5c			;    TODO on entry to a word this should be the expected environment 
1b5c			;    hl - tos value if number then held, if string this is the ptr 
1b5c			;    de -  
1b5c			 
1b5c			 
1b5c			; opcode ranges 
1b5c			; 0 - end of word dict 
1b5c			; 255 - user define words 
1b5c			 
1b5c			sysdict: 
1b5c			include "forth_opcodes.asm" 
1b5c			; op codes for forth keywords 
1b5c			; free to use code 0  
1b5c				OPCODE_HEAP: equ  1 
1b5c				OPCODE_EXEC: equ 2 
1b5c				OPCODE_DUP: equ 3 
1b5c				OPCODE_SWAP: equ 4 
1b5c				OPCODE_COLN: equ 5 
1b5c				OPCODE_SCOLN: equ 6 
1b5c				OPCODE_DROP: equ 7 
1b5c				OPCODE_DUP2: equ 8 
1b5c				OPCODE_DROP2: equ 9 
1b5c				OPCODE_SWAP2: equ 10 
1b5c				OPCODE_AT: equ 11 
1b5c				OPCODE_CAT: equ 12 
1b5c				OPCODE_BANG: equ 13 
1b5c				OPCODE_CBANG: equ 14 
1b5c				OPCODE_SCALL: equ 15 
1b5c				OPCODE_DEPTH: equ 16 
1b5c				OPCODE_OVER: equ 17 
1b5c				OPCODE_PAUSE: equ 18 
1b5c				OPCODE_PAUSES: equ 19 
1b5c				OPCODE_ROT: equ 20 
1b5c			;free to reuse	OPCODE_WORDS: equ 21 
1b5c			        OPCODE_NOT: equ 21 
1b5c				OPCODE_UWORDS: equ 22 
1b5c				OPCODE_BP: equ 23 
1b5c				OPCODE_MONITOR: equ 24  
1b5c				OPCODE_MALLOC: equ 25 
1b5c				OPCODE_FREE: equ 26 
1b5c				OPCODE_LIST: equ 27 
1b5c				OPCODE_FORGET: equ 28 
1b5c				OPCODE_NOP: equ 29 
1b5c				OPCODE_COMO: equ 30 
1b5c				OPCODE_COMC: equ 31 
1b5c			;free to reuse	OPCODE_ENDCORE: equ 32 
1b5c				OPCODE_AFTERSOUND: equ 33 
1b5c				OPCODE_GP2: equ 34 
1b5c				OPCODE_GP3: equ 35 
1b5c				OPCODE_GP4: equ 36 
1b5c				OPCODE_SIN: equ 37 
1b5c				OPCODE_SOUT: equ 38 
1b5c				OPCODE_SPIO: equ 39 
1b5c				OPCODE_SPICEH: equ 40 
1b5c				OPCODE_SPIOb: equ 41 
1b5c				OPCODE_SPII: equ 42 
1b5c				OPCODE_SESEL: equ 43 
1b5c				OPCODE_CARTDEV: equ 44 
1b5c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1b5c				OPCODE_FB: equ 46 
1b5c				OPCODE_EMIT: equ 47 
1b5c				OPCODE_DOTH: equ 48 
1b5c				OPCODE_DOTF: equ 49 
1b5c				OPCODE_DOT: equ 50 
1b5c				OPCODE_CLS: equ 51 
1b5c				OPCODE_DRAW: equ 52 
1b5c				OPCODE_DUMP: equ 53 
1b5c				OPCODE_CDUMP: equ 54 
1b5c				OPCODE_DAT: equ 55 
1b5c				OPCODE_HOME: equ 56 
1b5c				OPCODE_SPACE: equ 57 
1b5c				OPCODE_SPACES: equ 58 
1b5c				OPCODE_SCROLL: equ 59 
1b5c				OPCODE_ATQ: equ 60 
1b5c				OPCODE_AUTODSP: equ 61 
1b5c				OPCODE_MENU: equ 62 
1b5c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1b5c				OPCODE_THEN: equ 64 
1b5c				OPCODE_ELSE: equ 65 
1b5c				OPCODE_DO: equ 66 
1b5c				OPCODE_LOOP: equ 67 
1b5c				OPCODE_I: equ 68 
1b5c				OPCODE_DLOOP: equ 69  
1b5c				OPCODE_REPEAT: equ 70  
1b5c				OPCODE_UNTIL: equ 71 
1b5c				OPCODE_ENDFLOW: equ 72 
1b5c				OPCODE_WAITK: equ 73 
1b5c				OPCODE_ACCEPT: equ 74 
1b5c				OPCODE_EDIT: equ 75 
1b5c			;free to reuse	OPCODE_ENDKEY: equ 76 
1b5c				OPCODE_LZERO: equ 77 
1b5c				OPCODE_TZERO: equ 78 
1b5c				OPCODE_LESS: equ 79 
1b5c				OPCODE_GT: equ 80 
1b5c				OPCODE_EQUAL: equ 81  
1b5c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1b5c				OPCODE_NEG: equ 83 
1b5c				OPCODE_DIV: equ 84 
1b5c				OPCODE_MUL: equ 85 
1b5c				OPCODE_MIN: equ 86 
1b5c				OPCODE_MAX: equ 87 
1b5c				OPCODE_RND16: equ 88 
1b5c				OPCODE_RND8: equ 89 
1b5c				OPCODE_RND: equ 90 
1b5c			;free to reuse	OPCODE_ENDMATHS: equ 91  
1b5c				OPCODE_BYNAME: equ 92 
1b5c				OPCODE_DIR: equ 93 
1b5c				OPCODE_SAVE: equ 94 
1b5c				OPCODE_LOAD: equ 95 
1b5c				OPCODE_BSAVE: equ 96 
1b5c				OPCODE_BLOAD: equ 97 
1b5c				OPCODE_SEO: equ 98  
1b5c				OPCODE_SEI: equ 99 
1b5c				OPCODE_SFREE: equ 100 
1b5c				OPCODE_SIZE: equ 101 
1b5c				OPCODE_CREATE: equ 102 
1b5c				OPCODE_APPEND: equ 103 
1b5c				OPCODE_SDEL: equ 104 
1b5c				OPCODE_OPEN: equ 105 
1b5c				OPCODE_READ: equ 106 
1b5c				OPCODE_EOF: equ 106 
1b5c				OPCODE_FORMAT: equ 107 
1b5c				OPCODE_LABEL: equ 108 
1b5c				OPCODE_LABELS: equ 109 
1b5c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1b5c				OPCODE_UPPER: equ 111 
1b5c				OPCODE_LOWER: equ 112 
1b5c				OPCODE_SUBSTR: equ 113 
1b5c				OPCODE_LEFT: equ 114 
1b5c				OPCODE_RIGHT: equ 115 
1b5c				OPCODE_STR2NUM: equ 116 
1b5c				OPCODE_NUM2STR: equ 117 
1b5c				OPCODE_CONCAT: equ 118 
1b5c				OPCODE_FIND: equ 119 
1b5c				OPCODE_LEN: equ 120 
1b5c				OPCODE_CHAR: equ 121 
1b5c			; free to reuse	OPCODE_STRLEN: equ 122 
1b5c			; free to reuse	OPCODE_ENDSTR: equ 123 
1b5c				OPCODE_V0S: equ 124 
1b5c				OPCODE_V0Q: equ 125 
1b5c				OPCODE_V1S: equ 126 
1b5c				OPCODE_V1Q: equ 127 
1b5c				OPCODE_V2S: equ 128 
1b5c				OPCODE_V2Q: equ 129 
1b5c				OPCODE_V3S: equ 130 
1b5c				OPCODE_V3Q: equ 131 
1b5c			;free to reuse	OPCODE_END: equ 132 
1b5c				OPCODE_ZDUP: equ 133 
1b5c			 
1b5c			; eof 
# End of file forth_opcodes.asm
1b5c			 
1b5c			include "forth_words_core.asm" 
1b5c			 
1b5c			; | ## Core Words 
1b5c			 
1b5c			;if MALLOC_4 
1b5c			 
1b5c			.HEAP: 
1b5c				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1b5c 15				db WORD_SYS_CORE+OPCODE_HEAP             
1b5d 9b 1b			dw .EXEC            
1b5f 05				db 4 + 1 
1b60 .. 00			db "HEAP",0              
1b65				endm 
# End of macro CWHEAD
1b65			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1b65			; | | u1 - Current number of bytes in the heap 
1b65			; | | u2 - Remaining bytes left on the heap 
1b65			; | |  
1b65			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1b65			 
1b65			 
1b65					if DEBUG_FORTH_WORDS_KEY 
1b65						DMARK "HEP" 
1b65 f5				push af  
1b66 3a 7a 1b			ld a, (.dmark)  
1b69 32 7a ee			ld (debug_mark),a  
1b6c 3a 7b 1b			ld a, (.dmark+1)  
1b6f 32 7b ee			ld (debug_mark+1),a  
1b72 3a 7c 1b			ld a, (.dmark+2)  
1b75 32 7c ee			ld (debug_mark+2),a  
1b78 18 03			jr .pastdmark  
1b7a ..			.dmark: db "HEP"  
1b7d f1			.pastdmark: pop af  
1b7e			endm  
# End of macro DMARK
1b7e						CALLMONITOR 
1b7e cd 86 12			call break_point_state  
1b81				endm  
# End of macro CALLMONITOR
1b81					endif 
1b81 2a 14 56				ld hl, (free_list )      
1b84 11 19 56				ld de, heap_start 
1b87			 
1b87 ed 52				sbc hl, de  
1b89			 
1b89 cd 13 18				call forth_push_numhl 
1b8c			 
1b8c			 
1b8c ed 5b 14 56			ld de, (free_list )      
1b90 21 69 e3				ld hl, heap_end 
1b93			 
1b93 ed 52				sbc hl, de 
1b95			 
1b95 cd 13 18				call forth_push_numhl 
1b98					 
1b98			 
1b98					 
1b98			 
1b98			 
1b98			 
1b98					NEXTW 
1b98 c3 04 1a			jp macro_next 
1b9b				endm 
# End of macro NEXTW
1b9b			;endif 
1b9b			 
1b9b			.EXEC: 
1b9b				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1b9b 16				db WORD_SYS_CORE+OPCODE_EXEC             
1b9c 37 1c			dw .STKEXEC            
1b9e 05				db 4 + 1 
1b9f .. 00			db "EXEC",0              
1ba4				endm 
# End of macro CWHEAD
1ba4			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1ba4			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1ba4			; | | 
1ba4			; | |   
1ba4				STACKFRAME OFF $5efe $5f9f 
1ba4				if DEBUG_STACK_IMB 
1ba4					if OFF 
1ba4						exx 
1ba4						ld de, $5efe 
1ba4						ld a, d 
1ba4						ld hl, curframe 
1ba4						call hexout 
1ba4						ld a, e 
1ba4						ld hl, curframe+2 
1ba4						call hexout 
1ba4						ld hl, $5efe 
1ba4						push hl 
1ba4						ld hl, $5f9f 
1ba4						push hl 
1ba4						exx 
1ba4					endif 
1ba4				endif 
1ba4			endm 
# End of macro STACKFRAME
1ba4			 
1ba4					if DEBUG_FORTH_WORDS_KEY 
1ba4						DMARK "EXE" 
1ba4 f5				push af  
1ba5 3a b9 1b			ld a, (.dmark)  
1ba8 32 7a ee			ld (debug_mark),a  
1bab 3a ba 1b			ld a, (.dmark+1)  
1bae 32 7b ee			ld (debug_mark+1),a  
1bb1 3a bb 1b			ld a, (.dmark+2)  
1bb4 32 7c ee			ld (debug_mark+2),a  
1bb7 18 03			jr .pastdmark  
1bb9 ..			.dmark: db "EXE"  
1bbc f1			.pastdmark: pop af  
1bbd			endm  
# End of macro DMARK
1bbd						CALLMONITOR 
1bbd cd 86 12			call break_point_state  
1bc0				endm  
# End of macro CALLMONITOR
1bc0					endif 
1bc0			 
1bc0				FORTH_DSP_VALUEHL 
1bc0 cd ae 18			call macro_dsp_valuehl 
1bc3				endm 
# End of macro FORTH_DSP_VALUEHL
1bc3			 
1bc3				FORTH_DSP_POP 
1bc3 cd 4a 19			call macro_forth_dsp_pop 
1bc6				endm 
# End of macro FORTH_DSP_POP
1bc6			 
1bc6					if DEBUG_FORTH_WORDS 
1bc6						DMARK "EX1" 
1bc6 f5				push af  
1bc7 3a db 1b			ld a, (.dmark)  
1bca 32 7a ee			ld (debug_mark),a  
1bcd 3a dc 1b			ld a, (.dmark+1)  
1bd0 32 7b ee			ld (debug_mark+1),a  
1bd3 3a dd 1b			ld a, (.dmark+2)  
1bd6 32 7c ee			ld (debug_mark+2),a  
1bd9 18 03			jr .pastdmark  
1bdb ..			.dmark: db "EX1"  
1bde f1			.pastdmark: pop af  
1bdf			endm  
# End of macro DMARK
1bdf						CALLMONITOR 
1bdf cd 86 12			call break_point_state  
1be2				endm  
# End of macro CALLMONITOR
1be2					endif 
1be2			;	ld e,(hl) 
1be2			;	inc hl 
1be2			;	ld d,(hl) 
1be2			;	ex de,hl 
1be2			 
1be2			;		if DEBUG_FORTH_WORDS 
1be2			;			DMARK "EX2" 
1be2			;			CALLMONITOR 
1be2			;		endif 
1be2 e5				push hl 
1be3			 
1be3				;ld a, 0 
1be3				;ld a, FORTH_END_BUFFER 
1be3 cd 20 0f			call strlenz 
1be6 23				inc hl   ; include zero term to copy 
1be7 23				inc hl   ; include term 
1be8 23				inc hl   ; include term 
1be9 06 00			ld b,0 
1beb 4d				ld c,l 
1bec e1				pop hl 
1bed 11 74 e4			ld de, execscratch 
1bf0					if DEBUG_FORTH_WORDS 
1bf0						DMARK "EX3" 
1bf0 f5				push af  
1bf1 3a 05 1c			ld a, (.dmark)  
1bf4 32 7a ee			ld (debug_mark),a  
1bf7 3a 06 1c			ld a, (.dmark+1)  
1bfa 32 7b ee			ld (debug_mark+1),a  
1bfd 3a 07 1c			ld a, (.dmark+2)  
1c00 32 7c ee			ld (debug_mark+2),a  
1c03 18 03			jr .pastdmark  
1c05 ..			.dmark: db "EX3"  
1c08 f1			.pastdmark: pop af  
1c09			endm  
# End of macro DMARK
1c09						CALLMONITOR 
1c09 cd 86 12			call break_point_state  
1c0c				endm  
# End of macro CALLMONITOR
1c0c					endif 
1c0c ed b0			ldir 
1c0e			 
1c0e			 
1c0e 21 74 e4			ld hl, execscratch 
1c11			 
1c11					if DEBUG_FORTH_WORDS 
1c11						DMARK "EXe" 
1c11 f5				push af  
1c12 3a 26 1c			ld a, (.dmark)  
1c15 32 7a ee			ld (debug_mark),a  
1c18 3a 27 1c			ld a, (.dmark+1)  
1c1b 32 7b ee			ld (debug_mark+1),a  
1c1e 3a 28 1c			ld a, (.dmark+2)  
1c21 32 7c ee			ld (debug_mark+2),a  
1c24 18 03			jr .pastdmark  
1c26 ..			.dmark: db "EXe"  
1c29 f1			.pastdmark: pop af  
1c2a			endm  
# End of macro DMARK
1c2a						CALLMONITOR 
1c2a cd 86 12			call break_point_state  
1c2d				endm  
# End of macro CALLMONITOR
1c2d					endif 
1c2d			 
1c2d cd 52 1a			call forthparse 
1c30 cd 92 1a			call forthexec 
1c33			;	call forthexec_cleanup 
1c33			;	call forthparse 
1c33			;	call forthexec 
1c33			 
1c33				STACKFRAMECHK OFF $5efe $5f9f 
1c33				if DEBUG_STACK_IMB 
1c33					if OFF 
1c33						exx 
1c33						ld hl, $5f9f 
1c33						pop de   ; $5f9f 
1c33						call cmp16 
1c33						jr nz, .spnosame 
1c33						ld hl, $5efe 
1c33						pop de   ; $5efe 
1c33						call cmp16 
1c33						jr z, .spfrsame 
1c33						.spnosame: call showsperror 
1c33						.spfrsame: nop 
1c33						exx 
1c33					endif 
1c33				endif 
1c33			endm 
# End of macro STACKFRAMECHK
1c33			 
1c33				; an immediate word so no need to process any more words 
1c33 c9				ret 
1c34				NEXTW 
1c34 c3 04 1a			jp macro_next 
1c37				endm 
# End of macro NEXTW
1c37			 
1c37			; dead code - old version  
1c37			;	FORTH_RSP_NEXT 
1c37			 
1c37			;  
1c37			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1c37			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1c37			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1c37			;	push hl 
1c37			;	push de 
1c37			;	push bc 
1c37			; 
1c37			; 
1c37			;		if DEBUG_FORTH_WORDS_KEY 
1c37			;			DMARK "EXR" 
1c37			;			CALLMONITOR 
1c37			;		endif 
1c37			; 
1c37			; 
1c37			; 
1c37			;	;v5 FORTH_DSP_VALUE 
1c37			;	FORTH_DSP_VALUEHL 
1c37			; 
1c37			;	; TODO do string type checks 
1c37			; 
1c37			;;v5	inc hl   ; skip type 
1c37			; 
1c37			;	push hl  ; source code  
1c37			;		if DEBUG_FORTH_WORDS 
1c37			;			DMARK "EX1" 
1c37			;			CALLMONITOR 
1c37			;		endif 
1c37			;	ld a, 0 
1c37			;	call strlent 
1c37			; 
1c37			;	inc hl 
1c37			;	inc hl 
1c37			;	inc hl 
1c37			;	inc hl 
1c37			; 
1c37			;	push hl    ; size 
1c37			; 
1c37			;		if DEBUG_FORTH_WORDS 
1c37			;			DMARK "EX2" 
1c37			;			CALLMONITOR 
1c37			;		endif 
1c37			;	call malloc 
1c37			; 
1c37			;	ex de, hl    ; de now contains malloc area 
1c37			;	pop bc   	; get byte count 
1c37			;	pop hl      ; get string to copy 
1c37			; 
1c37			;	push de     ; save malloc for free later 
1c37			; 
1c37			;		if DEBUG_FORTH_WORDS 
1c37			;			DMARK "EX3" 
1c37			;			CALLMONITOR 
1c37			;		endif 
1c37			;	ldir       ; duplicate string 
1c37			; 
1c37			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1c37			;	 
1c37			;	; TODO fix the parse would be better than this...  
1c37			;	ex de, hl 
1c37			;	dec hl 
1c37			;	ld a, 0 
1c37			;	ld (hl), a 
1c37			;	dec hl 
1c37			;	ld a, ' ' 
1c37			;	ld (hl), a 
1c37			;	dec hl 
1c37			;	ld (hl), a 
1c37			; 
1c37			;	dec hl 
1c37			;	ld (hl), a 
1c37			; 
1c37			; 
1c37			;	FORTH_DSP_POP  
1c37			; 
1c37			;	pop hl     
1c37			;	push hl    ; save malloc area 
1c37			; 
1c37			;		if DEBUG_FORTH_WORDS 
1c37			;			DMARK "EX4" 
1c37			;			CALLMONITOR 
1c37			;		endif 
1c37			; 
1c37			;	call forthparse 
1c37			;	call forthexec 
1c37			;	 
1c37			;	pop hl 
1c37			;	if DEBUG_FORTH_WORDS 
1c37			;		DMARK "EX5" 
1c37			;		CALLMONITOR 
1c37			;	endif 
1c37			; 
1c37			;	if FORTH_ENABLE_FREE 
1c37			;	call free 
1c37			;	endif 
1c37			; 
1c37			;	if DEBUG_FORTH_WORDS 
1c37			;		DMARK "EX6" 
1c37			;		CALLMONITOR 
1c37			;	endif 
1c37			; 
1c37			;	pop bc 
1c37			;	pop de 
1c37			;	pop hl 
1c37			;;	FORTH_RSP_POP	  
1c37			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1c37			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1c37			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1c37			; 
1c37			;	if DEBUG_FORTH_WORDS 
1c37			;		DMARK "EX7" 
1c37			;		CALLMONITOR 
1c37			;	endif 
1c37			;	NEXTW 
1c37			 
1c37			.STKEXEC: 
1c37				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1c37 3f				db WORD_SYS_CORE+43             
1c38 7f 1d			dw .ZDUP            
1c3a 08				db 7 + 1 
1c3b .. 00			db "STKEXEC",0              
1c43				endm 
# End of macro CWHEAD
1c43			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1c43			 
1c43			 
1c43					if DEBUG_FORTH_WORDS_KEY 
1c43						DMARK "STX" 
1c43 f5				push af  
1c44 3a 58 1c			ld a, (.dmark)  
1c47 32 7a ee			ld (debug_mark),a  
1c4a 3a 59 1c			ld a, (.dmark+1)  
1c4d 32 7b ee			ld (debug_mark+1),a  
1c50 3a 5a 1c			ld a, (.dmark+2)  
1c53 32 7c ee			ld (debug_mark+2),a  
1c56 18 03			jr .pastdmark  
1c58 ..			.dmark: db "STX"  
1c5b f1			.pastdmark: pop af  
1c5c			endm  
# End of macro DMARK
1c5c						CALLMONITOR 
1c5c cd 86 12			call break_point_state  
1c5f				endm  
# End of macro CALLMONITOR
1c5f					endif 
1c5f			 
1c5f				FORTH_DSP_VALUEHL 
1c5f cd ae 18			call macro_dsp_valuehl 
1c62				endm 
# End of macro FORTH_DSP_VALUEHL
1c62			 
1c62 22 63 eb			ld (store_tmp1), hl    ; count 
1c65			 
1c65				FORTH_DSP_POP 
1c65 cd 4a 19			call macro_forth_dsp_pop 
1c68				endm 
# End of macro FORTH_DSP_POP
1c68			.stkexec1: 
1c68 2a 63 eb			ld hl, (store_tmp1)   ; count 
1c6b 3e 00			ld a, 0 
1c6d bd				cp l 
1c6e c8				ret z 
1c6f			 
1c6f 2b				dec hl 
1c70 22 63 eb			ld (store_tmp1), hl    ; count 
1c73				 
1c73				FORTH_DSP_VALUEHL 
1c73 cd ae 18			call macro_dsp_valuehl 
1c76				endm 
# End of macro FORTH_DSP_VALUEHL
1c76 e5				push hl 
1c77				 
1c77					if DEBUG_FORTH_WORDS 
1c77						DMARK "EXp" 
1c77 f5				push af  
1c78 3a 8c 1c			ld a, (.dmark)  
1c7b 32 7a ee			ld (debug_mark),a  
1c7e 3a 8d 1c			ld a, (.dmark+1)  
1c81 32 7b ee			ld (debug_mark+1),a  
1c84 3a 8e 1c			ld a, (.dmark+2)  
1c87 32 7c ee			ld (debug_mark+2),a  
1c8a 18 03			jr .pastdmark  
1c8c ..			.dmark: db "EXp"  
1c8f f1			.pastdmark: pop af  
1c90			endm  
# End of macro DMARK
1c90						CALLMONITOR 
1c90 cd 86 12			call break_point_state  
1c93				endm  
# End of macro CALLMONITOR
1c93					endif 
1c93				FORTH_DSP_POP 
1c93 cd 4a 19			call macro_forth_dsp_pop 
1c96				endm 
# End of macro FORTH_DSP_POP
1c96			 
1c96 cd 20 0f			call strlenz 
1c99 23				inc hl   ; include zero term to copy 
1c9a 23				inc hl   ; include zero term to copy 
1c9b 23				inc hl   ; include zero term to copy 
1c9c 06 00			ld b,0 
1c9e 4d				ld c,l 
1c9f e1				pop hl 
1ca0 11 74 e4			ld de, execscratch 
1ca3					if DEBUG_FORTH_WORDS 
1ca3						DMARK "EX3" 
1ca3 f5				push af  
1ca4 3a b8 1c			ld a, (.dmark)  
1ca7 32 7a ee			ld (debug_mark),a  
1caa 3a b9 1c			ld a, (.dmark+1)  
1cad 32 7b ee			ld (debug_mark+1),a  
1cb0 3a ba 1c			ld a, (.dmark+2)  
1cb3 32 7c ee			ld (debug_mark+2),a  
1cb6 18 03			jr .pastdmark  
1cb8 ..			.dmark: db "EX3"  
1cbb f1			.pastdmark: pop af  
1cbc			endm  
# End of macro DMARK
1cbc						CALLMONITOR 
1cbc cd 86 12			call break_point_state  
1cbf				endm  
# End of macro CALLMONITOR
1cbf					endif 
1cbf ed b0			ldir 
1cc1			 
1cc1			 
1cc1 21 74 e4			ld hl, execscratch 
1cc4			 
1cc4					if DEBUG_FORTH_WORDS 
1cc4						DMARK "EXP" 
1cc4 f5				push af  
1cc5 3a d9 1c			ld a, (.dmark)  
1cc8 32 7a ee			ld (debug_mark),a  
1ccb 3a da 1c			ld a, (.dmark+1)  
1cce 32 7b ee			ld (debug_mark+1),a  
1cd1 3a db 1c			ld a, (.dmark+2)  
1cd4 32 7c ee			ld (debug_mark+2),a  
1cd7 18 03			jr .pastdmark  
1cd9 ..			.dmark: db "EXP"  
1cdc f1			.pastdmark: pop af  
1cdd			endm  
# End of macro DMARK
1cdd						CALLMONITOR 
1cdd cd 86 12			call break_point_state  
1ce0				endm  
# End of macro CALLMONITOR
1ce0					endif 
1ce0			 
1ce0 cd 52 1a			call forthparse 
1ce3 21 74 e4			ld hl, execscratch 
1ce6					if DEBUG_FORTH_WORDS 
1ce6						DMARK "EXx" 
1ce6 f5				push af  
1ce7 3a fb 1c			ld a, (.dmark)  
1cea 32 7a ee			ld (debug_mark),a  
1ced 3a fc 1c			ld a, (.dmark+1)  
1cf0 32 7b ee			ld (debug_mark+1),a  
1cf3 3a fd 1c			ld a, (.dmark+2)  
1cf6 32 7c ee			ld (debug_mark+2),a  
1cf9 18 03			jr .pastdmark  
1cfb ..			.dmark: db "EXx"  
1cfe f1			.pastdmark: pop af  
1cff			endm  
# End of macro DMARK
1cff						CALLMONITOR 
1cff cd 86 12			call break_point_state  
1d02				endm  
# End of macro CALLMONITOR
1d02					endif 
1d02 cd 92 1a			call forthexec 
1d05			 
1d05 c3 68 1c			jp .stkexec1 
1d08			 
1d08 c9				ret 
1d09			 
1d09			 
1d09			.DUP: 
1d09				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1d09 17				db WORD_SYS_CORE+OPCODE_DUP             
1d0a 7f 1d			dw .ZDUP            
1d0c 04				db 3 + 1 
1d0d .. 00			db "DUP",0              
1d11				endm 
# End of macro CWHEAD
1d11			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1d11			 
1d11					if DEBUG_FORTH_WORDS_KEY 
1d11						DMARK "DUP" 
1d11 f5				push af  
1d12 3a 26 1d			ld a, (.dmark)  
1d15 32 7a ee			ld (debug_mark),a  
1d18 3a 27 1d			ld a, (.dmark+1)  
1d1b 32 7b ee			ld (debug_mark+1),a  
1d1e 3a 28 1d			ld a, (.dmark+2)  
1d21 32 7c ee			ld (debug_mark+2),a  
1d24 18 03			jr .pastdmark  
1d26 ..			.dmark: db "DUP"  
1d29 f1			.pastdmark: pop af  
1d2a			endm  
# End of macro DMARK
1d2a						CALLMONITOR 
1d2a cd 86 12			call break_point_state  
1d2d				endm  
# End of macro CALLMONITOR
1d2d					endif 
1d2d			 
1d2d					FORTH_DSP 
1d2d cd 93 18			call macro_forth_dsp 
1d30				endm 
# End of macro FORTH_DSP
1d30			 
1d30 7e					ld a, (HL) 
1d31 fe 01				cp DS_TYPE_STR 
1d33 20 25				jr nz, .dupinum 
1d35			 
1d35					; push another string 
1d35			 
1d35					FORTH_DSP_VALUEHL     		 
1d35 cd ae 18			call macro_dsp_valuehl 
1d38				endm 
# End of macro FORTH_DSP_VALUEHL
1d38			 
1d38				if DEBUG_FORTH_WORDS 
1d38					DMARK "DUs" 
1d38 f5				push af  
1d39 3a 4d 1d			ld a, (.dmark)  
1d3c 32 7a ee			ld (debug_mark),a  
1d3f 3a 4e 1d			ld a, (.dmark+1)  
1d42 32 7b ee			ld (debug_mark+1),a  
1d45 3a 4f 1d			ld a, (.dmark+2)  
1d48 32 7c ee			ld (debug_mark+2),a  
1d4b 18 03			jr .pastdmark  
1d4d ..			.dmark: db "DUs"  
1d50 f1			.pastdmark: pop af  
1d51			endm  
# End of macro DMARK
1d51					CALLMONITOR 
1d51 cd 86 12			call break_point_state  
1d54				endm  
# End of macro CALLMONITOR
1d54				endif 
1d54 cd 25 18				call forth_push_str 
1d57			 
1d57					NEXTW 
1d57 c3 04 1a			jp macro_next 
1d5a				endm 
# End of macro NEXTW
1d5a			 
1d5a			 
1d5a			.dupinum: 
1d5a					 
1d5a			 
1d5a			 
1d5a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1d5a cd ae 18			call macro_dsp_valuehl 
1d5d				endm 
# End of macro FORTH_DSP_VALUEHL
1d5d			 
1d5d				; TODO add floating point number detection 
1d5d			 
1d5d				if DEBUG_FORTH_WORDS 
1d5d					DMARK "DUi" 
1d5d f5				push af  
1d5e 3a 72 1d			ld a, (.dmark)  
1d61 32 7a ee			ld (debug_mark),a  
1d64 3a 73 1d			ld a, (.dmark+1)  
1d67 32 7b ee			ld (debug_mark+1),a  
1d6a 3a 74 1d			ld a, (.dmark+2)  
1d6d 32 7c ee			ld (debug_mark+2),a  
1d70 18 03			jr .pastdmark  
1d72 ..			.dmark: db "DUi"  
1d75 f1			.pastdmark: pop af  
1d76			endm  
# End of macro DMARK
1d76					CALLMONITOR 
1d76 cd 86 12			call break_point_state  
1d79				endm  
# End of macro CALLMONITOR
1d79				endif 
1d79			 
1d79 cd 13 18				call forth_push_numhl 
1d7c					NEXTW 
1d7c c3 04 1a			jp macro_next 
1d7f				endm 
# End of macro NEXTW
1d7f			.ZDUP: 
1d7f				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1d7f 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1d80 b7 1d			dw .SWAP            
1d82 05				db 4 + 1 
1d83 .. 00			db "?DUP",0              
1d88				endm 
# End of macro CWHEAD
1d88			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1d88			 
1d88					if DEBUG_FORTH_WORDS_KEY 
1d88						DMARK "qDU" 
1d88 f5				push af  
1d89 3a 9d 1d			ld a, (.dmark)  
1d8c 32 7a ee			ld (debug_mark),a  
1d8f 3a 9e 1d			ld a, (.dmark+1)  
1d92 32 7b ee			ld (debug_mark+1),a  
1d95 3a 9f 1d			ld a, (.dmark+2)  
1d98 32 7c ee			ld (debug_mark+2),a  
1d9b 18 03			jr .pastdmark  
1d9d ..			.dmark: db "qDU"  
1da0 f1			.pastdmark: pop af  
1da1			endm  
# End of macro DMARK
1da1						CALLMONITOR 
1da1 cd 86 12			call break_point_state  
1da4				endm  
# End of macro CALLMONITOR
1da4					endif 
1da4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1da4 cd ae 18			call macro_dsp_valuehl 
1da7				endm 
# End of macro FORTH_DSP_VALUEHL
1da7			 
1da7 e5					push hl 
1da8			 
1da8					; is it a zero? 
1da8			 
1da8 3e 00				ld a, 0 
1daa 84					add h 
1dab 85					add l 
1dac			 
1dac e1					pop hl 
1dad			 
1dad fe 00				cp 0 
1daf 28 03				jr z, .dup2orig 
1db1			 
1db1			 
1db1 cd 13 18				call forth_push_numhl 
1db4			 
1db4			 
1db4				; TODO add floating point number detection 
1db4			 
1db4			.dup2orig: 
1db4			 
1db4					NEXTW 
1db4 c3 04 1a			jp macro_next 
1db7				endm 
# End of macro NEXTW
1db7			.SWAP: 
1db7				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1db7 18				db WORD_SYS_CORE+OPCODE_SWAP             
1db8 f6 1d			dw .COLN            
1dba 05				db 4 + 1 
1dbb .. 00			db "SWAP",0              
1dc0				endm 
# End of macro CWHEAD
1dc0			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1dc0					if DEBUG_FORTH_WORDS_KEY 
1dc0						DMARK "SWP" 
1dc0 f5				push af  
1dc1 3a d5 1d			ld a, (.dmark)  
1dc4 32 7a ee			ld (debug_mark),a  
1dc7 3a d6 1d			ld a, (.dmark+1)  
1dca 32 7b ee			ld (debug_mark+1),a  
1dcd 3a d7 1d			ld a, (.dmark+2)  
1dd0 32 7c ee			ld (debug_mark+2),a  
1dd3 18 03			jr .pastdmark  
1dd5 ..			.dmark: db "SWP"  
1dd8 f1			.pastdmark: pop af  
1dd9			endm  
# End of macro DMARK
1dd9						CALLMONITOR 
1dd9 cd 86 12			call break_point_state  
1ddc				endm  
# End of macro CALLMONITOR
1ddc					endif 
1ddc			 
1ddc					FORTH_DSP_VALUEHL 
1ddc cd ae 18			call macro_dsp_valuehl 
1ddf				endm 
# End of macro FORTH_DSP_VALUEHL
1ddf e5					push hl     ; w2 
1de0			 
1de0					FORTH_DSP_POP 
1de0 cd 4a 19			call macro_forth_dsp_pop 
1de3				endm 
# End of macro FORTH_DSP_POP
1de3			 
1de3					FORTH_DSP_VALUEHL 
1de3 cd ae 18			call macro_dsp_valuehl 
1de6				endm 
# End of macro FORTH_DSP_VALUEHL
1de6			 
1de6					FORTH_DSP_POP 
1de6 cd 4a 19			call macro_forth_dsp_pop 
1de9				endm 
# End of macro FORTH_DSP_POP
1de9			 
1de9 d1					pop de     ; w2	, hl = w1 
1dea			 
1dea eb					ex de, hl 
1deb d5					push de 
1dec			 
1dec cd 13 18				call forth_push_numhl 
1def			 
1def e1					pop hl 
1df0			 
1df0 cd 13 18				call forth_push_numhl 
1df3					 
1df3			 
1df3					NEXTW 
1df3 c3 04 1a			jp macro_next 
1df6				endm 
# End of macro NEXTW
1df6			.COLN: 
1df6				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1df6 19				db WORD_SYS_CORE+OPCODE_COLN             
1df7 82 1f			dw .SCOLN            
1df9 02				db 1 + 1 
1dfa .. 00			db ":",0              
1dfc				endm 
# End of macro CWHEAD
1dfc			; | : ( -- )         Create new word | DONE 
1dfc			 
1dfc					if DEBUG_FORTH_WORDS_KEY 
1dfc						DMARK "CLN" 
1dfc f5				push af  
1dfd 3a 11 1e			ld a, (.dmark)  
1e00 32 7a ee			ld (debug_mark),a  
1e03 3a 12 1e			ld a, (.dmark+1)  
1e06 32 7b ee			ld (debug_mark+1),a  
1e09 3a 13 1e			ld a, (.dmark+2)  
1e0c 32 7c ee			ld (debug_mark+2),a  
1e0f 18 03			jr .pastdmark  
1e11 ..			.dmark: db "CLN"  
1e14 f1			.pastdmark: pop af  
1e15			endm  
# End of macro DMARK
1e15						CALLMONITOR 
1e15 cd 86 12			call break_point_state  
1e18				endm  
# End of macro CALLMONITOR
1e18					endif 
1e18				STACKFRAME OFF $8efe $989f 
1e18				if DEBUG_STACK_IMB 
1e18					if OFF 
1e18						exx 
1e18						ld de, $8efe 
1e18						ld a, d 
1e18						ld hl, curframe 
1e18						call hexout 
1e18						ld a, e 
1e18						ld hl, curframe+2 
1e18						call hexout 
1e18						ld hl, $8efe 
1e18						push hl 
1e18						ld hl, $989f 
1e18						push hl 
1e18						exx 
1e18					endif 
1e18				endif 
1e18			endm 
# End of macro STACKFRAME
1e18				; get parser buffer length  of new word 
1e18			 
1e18				 
1e18			 
1e18					; move tok past this to start of name defintition 
1e18					; TODO get word to define 
1e18					; TODO Move past word token 
1e18					; TODO get length of string up to the ';' 
1e18			 
1e18 2a 76 e6			ld hl, (os_tok_ptr) 
1e1b 23				inc hl 
1e1c 23				inc hl 
1e1d			 
1e1d 3e 3b			ld a, ';' 
1e1f cd 2b 0f			call strlent 
1e22			 
1e22 7d				ld a,l 
1e23 32 75 e5			ld (os_new_parse_len), a 
1e26			 
1e26			 
1e26			if DEBUG_FORTH_UWORD 
1e26 ed 5b 76 e6		ld de, (os_tok_ptr) 
1e2a						DMARK ":01" 
1e2a f5				push af  
1e2b 3a 3f 1e			ld a, (.dmark)  
1e2e 32 7a ee			ld (debug_mark),a  
1e31 3a 40 1e			ld a, (.dmark+1)  
1e34 32 7b ee			ld (debug_mark+1),a  
1e37 3a 41 1e			ld a, (.dmark+2)  
1e3a 32 7c ee			ld (debug_mark+2),a  
1e3d 18 03			jr .pastdmark  
1e3f ..			.dmark: db ":01"  
1e42 f1			.pastdmark: pop af  
1e43			endm  
# End of macro DMARK
1e43				CALLMONITOR 
1e43 cd 86 12			call break_point_state  
1e46				endm  
# End of macro CALLMONITOR
1e46			endif 
1e46			 
1e46			; 
1e46			;  new word memory layout: 
1e46			;  
1e46			;    : adg 6666 ;  
1e46			; 
1e46			;    db   1     ; user defined word  
1e46 23				inc hl    
1e47			;    dw   sysdict 
1e47 23				inc hl 
1e48 23				inc hl 
1e49			;    db <word len>+1 (for null) 
1e49 23				inc hl 
1e4a			;    db .... <word> 
1e4a			; 
1e4a			 
1e4a 23				inc hl    ; some extras for the word preamble before the above 
1e4b 23				inc hl 
1e4c 23				inc hl 
1e4d 23				inc hl 
1e4e 23				inc hl 
1e4f 23				inc hl 
1e50 23				inc hl  
1e51 23				inc hl 
1e52 23				inc hl 
1e53 23				inc hl 
1e54 23				inc hl 
1e55 23				inc hl 
1e56 23				inc hl 
1e57 23				inc hl     ; TODO how many do we really need?     maybe only 6 
1e58			;       exec word buffer 
1e58			;	<ptr word>   
1e58 23				inc hl 
1e59 23				inc hl 
1e5a			;       <word list><null term> 7F final term 
1e5a			 
1e5a			 
1e5a			if DEBUG_FORTH_UWORD 
1e5a						DMARK ":02" 
1e5a f5				push af  
1e5b 3a 6f 1e			ld a, (.dmark)  
1e5e 32 7a ee			ld (debug_mark),a  
1e61 3a 70 1e			ld a, (.dmark+1)  
1e64 32 7b ee			ld (debug_mark+1),a  
1e67 3a 71 1e			ld a, (.dmark+2)  
1e6a 32 7c ee			ld (debug_mark+2),a  
1e6d 18 03			jr .pastdmark  
1e6f ..			.dmark: db ":02"  
1e72 f1			.pastdmark: pop af  
1e73			endm  
# End of macro DMARK
1e73				CALLMONITOR 
1e73 cd 86 12			call break_point_state  
1e76				endm  
# End of macro CALLMONITOR
1e76			endif 
1e76			 
1e76				 
1e76					; malloc the size 
1e76			 
1e76 cd 89 0f				call malloc 
1e79 22 73 e5				ld (os_new_malloc), hl     ; save malloc start 
1e7c			 
1e7c			;    db   1     ; user defined word  
1e7c 3e 01				ld a, WORD_SYS_UWORD  
1e7e 77					ld (hl), a 
1e7f				 
1e7f 23				inc hl    
1e80			;    dw   sysdict 
1e80 11 5c 1b			ld de, sysdict       ; continue on with the scan to the system dict 
1e83 73				ld (hl), e 
1e84 23				inc hl 
1e85 72				ld (hl), d 
1e86 23				inc hl 
1e87			 
1e87			 
1e87			;    Setup dict word 
1e87			 
1e87 23				inc hl 
1e88 22 79 e5			ld (os_new_work_ptr), hl     ; save start of dict word  
1e8b			 
1e8b				; 1. get length of dict word 
1e8b			 
1e8b			 
1e8b 2a 76 e6			ld hl, (os_tok_ptr) 
1e8e 23				inc hl 
1e8f 23				inc hl    ; position to start of dict word 
1e90 3e 00			ld a, 0 
1e92 cd 2b 0f			call strlent 
1e95			 
1e95			 
1e95 23				inc hl    ; to include null??? 
1e96			 
1e96				; write length of dict word 
1e96			 
1e96 ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1e9a 1b				dec de 
1e9b eb				ex de, hl 
1e9c 73				ld (hl), e 
1e9d eb				ex de, hl 
1e9e			 
1e9e				 
1e9e			 
1e9e				; copy  
1e9e 4d				ld c, l 
1e9f 06 00			ld b, 0 
1ea1 ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1ea5 2a 76 e6			ld hl, (os_tok_ptr) 
1ea8 23				inc hl 
1ea9 23				inc hl    ; position to start of dict word 
1eaa				 
1eaa			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
1eaa				 
1eaa				; TODO need to convert word to upper case 
1eaa			 
1eaa			ucasetok:	 
1eaa 7e				ld a,(hl) 
1eab cd 17 0f			call toUpper 
1eae 77				ld (hl),a 
1eaf ed a0			ldi 
1eb1 f2 aa 1e		 	jp p, ucasetok 
1eb4			 
1eb4			 
1eb4			 
1eb4				; de now points to start of where the word body code should be placed 
1eb4 ed 53 79 e5		ld (os_new_work_ptr), de 
1eb8				; hl now points to the words to throw at forthexec which needs to be copied 
1eb8 22 7b e5			ld (os_new_src_ptr), hl 
1ebb			 
1ebb				; TODO add 'call to forthexec' 
1ebb			 
1ebb			if DEBUG_FORTH_UWORD 
1ebb c5				push bc 
1ebc ed 4b 73 e5		ld bc, (os_new_malloc) 
1ec0						DMARK ":0x" 
1ec0 f5				push af  
1ec1 3a d5 1e			ld a, (.dmark)  
1ec4 32 7a ee			ld (debug_mark),a  
1ec7 3a d6 1e			ld a, (.dmark+1)  
1eca 32 7b ee			ld (debug_mark+1),a  
1ecd 3a d7 1e			ld a, (.dmark+2)  
1ed0 32 7c ee			ld (debug_mark+2),a  
1ed3 18 03			jr .pastdmark  
1ed5 ..			.dmark: db ":0x"  
1ed8 f1			.pastdmark: pop af  
1ed9			endm  
# End of macro DMARK
1ed9				CALLMONITOR 
1ed9 cd 86 12			call break_point_state  
1edc				endm  
# End of macro CALLMONITOR
1edc c1				pop bc 
1edd			endif 
1edd			 
1edd			 
1edd				; create word preamble which should be: 
1edd			 
1edd			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
1edd			 
1edd				;    ld hl, <word code> 
1edd				;    jp user_exec 
1edd			        ;    <word code bytes> 
1edd			 
1edd			 
1edd			;	inc de     ; TODO ??? or are we already past the word's null 
1edd eb				ex de, hl 
1ede			 
1ede 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
1ee0			 
1ee0 23				inc hl 
1ee1 22 7f e5			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
1ee4 23				inc hl 
1ee5			 
1ee5 23				inc hl 
1ee6 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
1ee8			 
1ee8 01 95 41			ld bc, user_exec 
1eeb 23				inc hl 
1eec 71				ld (hl), c     ; poke address of user_exec 
1eed 23				inc hl 
1eee 70				ld (hl), b     
1eef			 ; 
1eef			;	inc hl 
1eef			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
1eef			; 
1eef			; 
1eef			;	ld bc, macro_forth_rsp_next 
1eef			;	inc hl 
1eef			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
1eef			;	inc hl 
1eef			;	ld (hl), b     
1eef			 ; 
1eef			;	inc hl 
1eef			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
1eef			; 
1eef			; 
1eef			;	inc hl 
1eef			;	ld bc, forthexec 
1eef			;	ld (hl), c     ; poke address of forthexec 
1eef			;	inc hl 
1eef			;	ld (hl), b      
1eef			; 
1eef			;	inc hl 
1eef			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
1eef			; 
1eef			;	ld bc, user_dict_next 
1eef			;	inc hl 
1eef			;	ld (hl), c     ; poke address of forthexec 
1eef			;	inc hl 
1eef			;	ld (hl), b      
1eef			 
1eef				; hl is now where we need to copy the word byte data to save this 
1eef			 
1eef 23				inc hl 
1ef0 22 7d e5			ld (os_new_exec), hl 
1ef3				 
1ef3				; copy definition 
1ef3			 
1ef3 eb				ex de, hl 
1ef4			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
1ef4			;	inc de    ; skip the PC for this parse 
1ef4 3a 75 e5			ld a, (os_new_parse_len) 
1ef7 4f				ld c, a 
1ef8 06 00			ld b, 0 
1efa ed b0			ldir		 ; copy defintion 
1efc			 
1efc			 
1efc				; poke the address of where the new word bytes live for forthexec 
1efc			 
1efc 2a 7f e5			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
1eff			 
1eff ed 5b 7d e5		ld de, (os_new_exec)      
1f03				 
1f03 73				ld (hl), e 
1f04 23				inc hl 
1f05 72				ld (hl), d 
1f06			 
1f06					; TODO copy last user dict word next link to this word 
1f06					; TODO update last user dict word to point to this word 
1f06			; 
1f06			; hl f923 de 812a ; bc 811a 
1f06			 
1f06			if DEBUG_FORTH_UWORD 
1f06 c5				push bc 
1f07 ed 4b 73 e5		ld bc, (os_new_malloc) 
1f0b						DMARK ":0A" 
1f0b f5				push af  
1f0c 3a 20 1f			ld a, (.dmark)  
1f0f 32 7a ee			ld (debug_mark),a  
1f12 3a 21 1f			ld a, (.dmark+1)  
1f15 32 7b ee			ld (debug_mark+1),a  
1f18 3a 22 1f			ld a, (.dmark+2)  
1f1b 32 7c ee			ld (debug_mark+2),a  
1f1e 18 03			jr .pastdmark  
1f20 ..			.dmark: db ":0A"  
1f23 f1			.pastdmark: pop af  
1f24			endm  
# End of macro DMARK
1f24				CALLMONITOR 
1f24 cd 86 12			call break_point_state  
1f27				endm  
# End of macro CALLMONITOR
1f27 c1				pop bc 
1f28			endif 
1f28			if DEBUG_FORTH_UWORD 
1f28 c5				push bc 
1f29 ed 4b 73 e5		ld bc, (os_new_malloc) 
1f2d 03				inc bc 
1f2e 03				inc bc 
1f2f 03				inc bc 
1f30 03				inc bc 
1f31 03				inc bc 
1f32 03				inc bc 
1f33 03				inc bc 
1f34 03				inc bc 
1f35			 
1f35						DMARK ":0B" 
1f35 f5				push af  
1f36 3a 4a 1f			ld a, (.dmark)  
1f39 32 7a ee			ld (debug_mark),a  
1f3c 3a 4b 1f			ld a, (.dmark+1)  
1f3f 32 7b ee			ld (debug_mark+1),a  
1f42 3a 4c 1f			ld a, (.dmark+2)  
1f45 32 7c ee			ld (debug_mark+2),a  
1f48 18 03			jr .pastdmark  
1f4a ..			.dmark: db ":0B"  
1f4d f1			.pastdmark: pop af  
1f4e			endm  
# End of macro DMARK
1f4e				CALLMONITOR 
1f4e cd 86 12			call break_point_state  
1f51				endm  
# End of macro CALLMONITOR
1f51 c1				pop bc 
1f52			endif 
1f52			 
1f52			; update word dict linked list for new word 
1f52			 
1f52			 
1f52 2a 72 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
1f55 23			inc hl     ; move to next work linked list ptr 
1f56			 
1f56 ed 5b 73 e5	ld de, (os_new_malloc)		 ; new next word 
1f5a 73			ld (hl), e 
1f5b 23			inc hl 
1f5c 72			ld (hl), d 
1f5d			 
1f5d			if DEBUG_FORTH_UWORD 
1f5d ed 4b 72 e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
1f61			endif 
1f61			 
1f61 ed 53 72 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
1f65			 
1f65			 
1f65			if DEBUG_FORTH_UWORD 
1f65						DMARK ":0+" 
1f65 f5				push af  
1f66 3a 7a 1f			ld a, (.dmark)  
1f69 32 7a ee			ld (debug_mark),a  
1f6c 3a 7b 1f			ld a, (.dmark+1)  
1f6f 32 7b ee			ld (debug_mark+1),a  
1f72 3a 7c 1f			ld a, (.dmark+2)  
1f75 32 7c ee			ld (debug_mark+2),a  
1f78 18 03			jr .pastdmark  
1f7a ..			.dmark: db ":0+"  
1f7d f1			.pastdmark: pop af  
1f7e			endm  
# End of macro DMARK
1f7e				CALLMONITOR 
1f7e cd 86 12			call break_point_state  
1f81				endm  
# End of macro CALLMONITOR
1f81			endif 
1f81			 
1f81				STACKFRAMECHK OFF $8efe $989f 
1f81				if DEBUG_STACK_IMB 
1f81					if OFF 
1f81						exx 
1f81						ld hl, $989f 
1f81						pop de   ; $989f 
1f81						call cmp16 
1f81						jr nz, .spnosame 
1f81						ld hl, $8efe 
1f81						pop de   ; $8efe 
1f81						call cmp16 
1f81						jr z, .spfrsame 
1f81						.spnosame: call showsperror 
1f81						.spfrsame: nop 
1f81						exx 
1f81					endif 
1f81				endif 
1f81			endm 
# End of macro STACKFRAMECHK
1f81			 
1f81 c9			ret    ; dont process any remaining parser tokens as they form new word 
1f82			 
1f82			 
1f82			 
1f82			 
1f82			;		NEXT 
1f82			.SCOLN: 
1f82			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
1f82 06				db OPCODE_SCOLN 
1f83 ce 1f			dw .DROP 
1f85 02				db 2 
1f86 .. 00			db ";",0           
1f88			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
1f88					if DEBUG_FORTH_WORDS_KEY 
1f88						DMARK "SCN" 
1f88 f5				push af  
1f89 3a 9d 1f			ld a, (.dmark)  
1f8c 32 7a ee			ld (debug_mark),a  
1f8f 3a 9e 1f			ld a, (.dmark+1)  
1f92 32 7b ee			ld (debug_mark+1),a  
1f95 3a 9f 1f			ld a, (.dmark+2)  
1f98 32 7c ee			ld (debug_mark+2),a  
1f9b 18 03			jr .pastdmark  
1f9d ..			.dmark: db "SCN"  
1fa0 f1			.pastdmark: pop af  
1fa1			endm  
# End of macro DMARK
1fa1						CALLMONITOR 
1fa1 cd 86 12			call break_point_state  
1fa4				endm  
# End of macro CALLMONITOR
1fa4					endif 
1fa4					FORTH_RSP_TOS 
1fa4 cd d1 17			call macro_forth_rsp_tos 
1fa7				endm 
# End of macro FORTH_RSP_TOS
1fa7 e5					push hl 
1fa8					FORTH_RSP_POP 
1fa8 cd db 17			call macro_forth_rsp_pop 
1fab				endm 
# End of macro FORTH_RSP_POP
1fab e1					pop hl 
1fac			;		ex de,hl 
1fac 22 76 e6				ld (os_tok_ptr),hl 
1faf			 
1faf			if DEBUG_FORTH_UWORD 
1faf						DMARK "SCL" 
1faf f5				push af  
1fb0 3a c4 1f			ld a, (.dmark)  
1fb3 32 7a ee			ld (debug_mark),a  
1fb6 3a c5 1f			ld a, (.dmark+1)  
1fb9 32 7b ee			ld (debug_mark+1),a  
1fbc 3a c6 1f			ld a, (.dmark+2)  
1fbf 32 7c ee			ld (debug_mark+2),a  
1fc2 18 03			jr .pastdmark  
1fc4 ..			.dmark: db "SCL"  
1fc7 f1			.pastdmark: pop af  
1fc8			endm  
# End of macro DMARK
1fc8				CALLMONITOR 
1fc8 cd 86 12			call break_point_state  
1fcb				endm  
# End of macro CALLMONITOR
1fcb			endif 
1fcb					NEXTW 
1fcb c3 04 1a			jp macro_next 
1fce				endm 
# End of macro NEXTW
1fce			 
1fce			.DROP: 
1fce				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
1fce 1b				db WORD_SYS_CORE+OPCODE_DROP             
1fcf f9 1f			dw .DUP2            
1fd1 05				db 4 + 1 
1fd2 .. 00			db "DROP",0              
1fd7				endm 
# End of macro CWHEAD
1fd7			; | DROP ( w -- )   drop the TOS item   | DONE 
1fd7					if DEBUG_FORTH_WORDS_KEY 
1fd7						DMARK "DRP" 
1fd7 f5				push af  
1fd8 3a ec 1f			ld a, (.dmark)  
1fdb 32 7a ee			ld (debug_mark),a  
1fde 3a ed 1f			ld a, (.dmark+1)  
1fe1 32 7b ee			ld (debug_mark+1),a  
1fe4 3a ee 1f			ld a, (.dmark+2)  
1fe7 32 7c ee			ld (debug_mark+2),a  
1fea 18 03			jr .pastdmark  
1fec ..			.dmark: db "DRP"  
1fef f1			.pastdmark: pop af  
1ff0			endm  
# End of macro DMARK
1ff0						CALLMONITOR 
1ff0 cd 86 12			call break_point_state  
1ff3				endm  
# End of macro CALLMONITOR
1ff3					endif 
1ff3					FORTH_DSP_POP 
1ff3 cd 4a 19			call macro_forth_dsp_pop 
1ff6				endm 
# End of macro FORTH_DSP_POP
1ff6					NEXTW 
1ff6 c3 04 1a			jp macro_next 
1ff9				endm 
# End of macro NEXTW
1ff9			.DUP2: 
1ff9				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
1ff9 1c				db WORD_SYS_CORE+OPCODE_DUP2             
1ffa 3e 20			dw .DROP2            
1ffc 05				db 4 + 1 
1ffd .. 00			db "2DUP",0              
2002				endm 
# End of macro CWHEAD
2002			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2002					if DEBUG_FORTH_WORDS_KEY 
2002						DMARK "2DU" 
2002 f5				push af  
2003 3a 17 20			ld a, (.dmark)  
2006 32 7a ee			ld (debug_mark),a  
2009 3a 18 20			ld a, (.dmark+1)  
200c 32 7b ee			ld (debug_mark+1),a  
200f 3a 19 20			ld a, (.dmark+2)  
2012 32 7c ee			ld (debug_mark+2),a  
2015 18 03			jr .pastdmark  
2017 ..			.dmark: db "2DU"  
201a f1			.pastdmark: pop af  
201b			endm  
# End of macro DMARK
201b						CALLMONITOR 
201b cd 86 12			call break_point_state  
201e				endm  
# End of macro CALLMONITOR
201e					endif 
201e					FORTH_DSP_VALUEHL 
201e cd ae 18			call macro_dsp_valuehl 
2021				endm 
# End of macro FORTH_DSP_VALUEHL
2021 e5					push hl      ; 2 
2022			 
2022					FORTH_DSP_POP 
2022 cd 4a 19			call macro_forth_dsp_pop 
2025				endm 
# End of macro FORTH_DSP_POP
2025					 
2025					FORTH_DSP_VALUEHL 
2025 cd ae 18			call macro_dsp_valuehl 
2028				endm 
# End of macro FORTH_DSP_VALUEHL
2028			;		push hl      ; 1 
2028			 
2028					FORTH_DSP_POP 
2028 cd 4a 19			call macro_forth_dsp_pop 
202b				endm 
# End of macro FORTH_DSP_POP
202b			 
202b			;		pop hl       ; 1 
202b d1					pop de       ; 2 
202c			 
202c cd 13 18				call forth_push_numhl 
202f eb					ex de, hl 
2030 cd 13 18				call forth_push_numhl 
2033			 
2033					 
2033 eb					ex de, hl 
2034			 
2034 cd 13 18				call forth_push_numhl 
2037 eb					ex de, hl 
2038 cd 13 18				call forth_push_numhl 
203b			 
203b			 
203b					NEXTW 
203b c3 04 1a			jp macro_next 
203e				endm 
# End of macro NEXTW
203e			.DROP2: 
203e				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
203e 1d				db WORD_SYS_CORE+OPCODE_DROP2             
203f 6d 20			dw .SWAP2            
2041 06				db 5 + 1 
2042 .. 00			db "2DROP",0              
2048				endm 
# End of macro CWHEAD
2048			; | 2DROP ( w w -- )    Double drop | DONE 
2048					if DEBUG_FORTH_WORDS_KEY 
2048						DMARK "2DR" 
2048 f5				push af  
2049 3a 5d 20			ld a, (.dmark)  
204c 32 7a ee			ld (debug_mark),a  
204f 3a 5e 20			ld a, (.dmark+1)  
2052 32 7b ee			ld (debug_mark+1),a  
2055 3a 5f 20			ld a, (.dmark+2)  
2058 32 7c ee			ld (debug_mark+2),a  
205b 18 03			jr .pastdmark  
205d ..			.dmark: db "2DR"  
2060 f1			.pastdmark: pop af  
2061			endm  
# End of macro DMARK
2061						CALLMONITOR 
2061 cd 86 12			call break_point_state  
2064				endm  
# End of macro CALLMONITOR
2064					endif 
2064					FORTH_DSP_POP 
2064 cd 4a 19			call macro_forth_dsp_pop 
2067				endm 
# End of macro FORTH_DSP_POP
2067					FORTH_DSP_POP 
2067 cd 4a 19			call macro_forth_dsp_pop 
206a				endm 
# End of macro FORTH_DSP_POP
206a					NEXTW 
206a c3 04 1a			jp macro_next 
206d				endm 
# End of macro NEXTW
206d			.SWAP2: 
206d				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
206d 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
206e 96 20			dw .AT            
2070 06				db 5 + 1 
2071 .. 00			db "2SWAP",0              
2077				endm 
# End of macro CWHEAD
2077			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2077					if DEBUG_FORTH_WORDS_KEY 
2077						DMARK "2SW" 
2077 f5				push af  
2078 3a 8c 20			ld a, (.dmark)  
207b 32 7a ee			ld (debug_mark),a  
207e 3a 8d 20			ld a, (.dmark+1)  
2081 32 7b ee			ld (debug_mark+1),a  
2084 3a 8e 20			ld a, (.dmark+2)  
2087 32 7c ee			ld (debug_mark+2),a  
208a 18 03			jr .pastdmark  
208c ..			.dmark: db "2SW"  
208f f1			.pastdmark: pop af  
2090			endm  
# End of macro DMARK
2090						CALLMONITOR 
2090 cd 86 12			call break_point_state  
2093				endm  
# End of macro CALLMONITOR
2093					endif 
2093					NEXTW 
2093 c3 04 1a			jp macro_next 
2096				endm 
# End of macro NEXTW
2096			.AT: 
2096				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2096 1f				db WORD_SYS_CORE+OPCODE_AT             
2097 c8 20			dw .CAT            
2099 02				db 1 + 1 
209a .. 00			db "@",0              
209c				endm 
# End of macro CWHEAD
209c			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
209c			 
209c					if DEBUG_FORTH_WORDS_KEY 
209c						DMARK "AT." 
209c f5				push af  
209d 3a b1 20			ld a, (.dmark)  
20a0 32 7a ee			ld (debug_mark),a  
20a3 3a b2 20			ld a, (.dmark+1)  
20a6 32 7b ee			ld (debug_mark+1),a  
20a9 3a b3 20			ld a, (.dmark+2)  
20ac 32 7c ee			ld (debug_mark+2),a  
20af 18 03			jr .pastdmark  
20b1 ..			.dmark: db "AT."  
20b4 f1			.pastdmark: pop af  
20b5			endm  
# End of macro DMARK
20b5						CALLMONITOR 
20b5 cd 86 12			call break_point_state  
20b8				endm  
# End of macro CALLMONITOR
20b8					endif 
20b8			.getbyteat:	 
20b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
20b8 cd ae 18			call macro_dsp_valuehl 
20bb				endm 
# End of macro FORTH_DSP_VALUEHL
20bb					 
20bb			;		push hl 
20bb				 
20bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
20bb cd 4a 19			call macro_forth_dsp_pop 
20be				endm 
# End of macro FORTH_DSP_POP
20be			 
20be			;		pop hl 
20be			 
20be 7e					ld a, (hl) 
20bf			 
20bf 6f					ld l, a 
20c0 26 00				ld h, 0 
20c2 cd 13 18				call forth_push_numhl 
20c5			 
20c5					NEXTW 
20c5 c3 04 1a			jp macro_next 
20c8				endm 
# End of macro NEXTW
20c8			.CAT: 
20c8				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
20c8 20				db WORD_SYS_CORE+OPCODE_CAT             
20c9 f1 20			dw .BANG            
20cb 03				db 2 + 1 
20cc .. 00			db "C@",0              
20cf				endm 
# End of macro CWHEAD
20cf			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
20cf					if DEBUG_FORTH_WORDS_KEY 
20cf						DMARK "CAA" 
20cf f5				push af  
20d0 3a e4 20			ld a, (.dmark)  
20d3 32 7a ee			ld (debug_mark),a  
20d6 3a e5 20			ld a, (.dmark+1)  
20d9 32 7b ee			ld (debug_mark+1),a  
20dc 3a e6 20			ld a, (.dmark+2)  
20df 32 7c ee			ld (debug_mark+2),a  
20e2 18 03			jr .pastdmark  
20e4 ..			.dmark: db "CAA"  
20e7 f1			.pastdmark: pop af  
20e8			endm  
# End of macro DMARK
20e8						CALLMONITOR 
20e8 cd 86 12			call break_point_state  
20eb				endm  
# End of macro CALLMONITOR
20eb					endif 
20eb c3 b8 20				jp .getbyteat 
20ee					NEXTW 
20ee c3 04 1a			jp macro_next 
20f1				endm 
# End of macro NEXTW
20f1			.BANG: 
20f1				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
20f1 21				db WORD_SYS_CORE+OPCODE_BANG             
20f2 27 21			dw .CBANG            
20f4 02				db 1 + 1 
20f5 .. 00			db "!",0              
20f7				endm 
# End of macro CWHEAD
20f7			; | ! ( x w -- ) Store x at address w      | DONE 
20f7					if DEBUG_FORTH_WORDS_KEY 
20f7						DMARK "BNG" 
20f7 f5				push af  
20f8 3a 0c 21			ld a, (.dmark)  
20fb 32 7a ee			ld (debug_mark),a  
20fe 3a 0d 21			ld a, (.dmark+1)  
2101 32 7b ee			ld (debug_mark+1),a  
2104 3a 0e 21			ld a, (.dmark+2)  
2107 32 7c ee			ld (debug_mark+2),a  
210a 18 03			jr .pastdmark  
210c ..			.dmark: db "BNG"  
210f f1			.pastdmark: pop af  
2110			endm  
# End of macro DMARK
2110						CALLMONITOR 
2110 cd 86 12			call break_point_state  
2113				endm  
# End of macro CALLMONITOR
2113					endif 
2113			 
2113			.storebyteat:		 
2113					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2113 cd ae 18			call macro_dsp_valuehl 
2116				endm 
# End of macro FORTH_DSP_VALUEHL
2116					 
2116 e5					push hl 
2117				 
2117					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2117 cd 4a 19			call macro_forth_dsp_pop 
211a				endm 
# End of macro FORTH_DSP_POP
211a			 
211a					; get byte to poke 
211a			 
211a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
211a cd ae 18			call macro_dsp_valuehl 
211d				endm 
# End of macro FORTH_DSP_VALUEHL
211d e5					push hl 
211e			 
211e			 
211e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
211e cd 4a 19			call macro_forth_dsp_pop 
2121				endm 
# End of macro FORTH_DSP_POP
2121			 
2121			 
2121 d1					pop de 
2122 e1					pop hl 
2123			 
2123 73					ld (hl),e 
2124			 
2124			 
2124					NEXTW 
2124 c3 04 1a			jp macro_next 
2127				endm 
# End of macro NEXTW
2127			.CBANG: 
2127				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2127 22				db WORD_SYS_CORE+OPCODE_CBANG             
2128 50 21			dw .SCALL            
212a 03				db 2 + 1 
212b .. 00			db "C!",0              
212e				endm 
# End of macro CWHEAD
212e			; | C!  ( x w -- ) Store x at address w  | DONE 
212e					if DEBUG_FORTH_WORDS_KEY 
212e						DMARK "CBA" 
212e f5				push af  
212f 3a 43 21			ld a, (.dmark)  
2132 32 7a ee			ld (debug_mark),a  
2135 3a 44 21			ld a, (.dmark+1)  
2138 32 7b ee			ld (debug_mark+1),a  
213b 3a 45 21			ld a, (.dmark+2)  
213e 32 7c ee			ld (debug_mark+2),a  
2141 18 03			jr .pastdmark  
2143 ..			.dmark: db "CBA"  
2146 f1			.pastdmark: pop af  
2147			endm  
# End of macro DMARK
2147						CALLMONITOR 
2147 cd 86 12			call break_point_state  
214a				endm  
# End of macro CALLMONITOR
214a					endif 
214a c3 13 21				jp .storebyteat 
214d					NEXTW 
214d c3 04 1a			jp macro_next 
2150				endm 
# End of macro NEXTW
2150			.SCALL: 
2150				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2150 23				db WORD_SYS_CORE+OPCODE_SCALL             
2151 84 21			dw .DEPTH            
2153 05				db 4 + 1 
2154 .. 00			db "CALL",0              
2159				endm 
# End of macro CWHEAD
2159			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2159					if DEBUG_FORTH_WORDS_KEY 
2159						DMARK "CLL" 
2159 f5				push af  
215a 3a 6e 21			ld a, (.dmark)  
215d 32 7a ee			ld (debug_mark),a  
2160 3a 6f 21			ld a, (.dmark+1)  
2163 32 7b ee			ld (debug_mark+1),a  
2166 3a 70 21			ld a, (.dmark+2)  
2169 32 7c ee			ld (debug_mark+2),a  
216c 18 03			jr .pastdmark  
216e ..			.dmark: db "CLL"  
2171 f1			.pastdmark: pop af  
2172			endm  
# End of macro DMARK
2172						CALLMONITOR 
2172 cd 86 12			call break_point_state  
2175				endm  
# End of macro CALLMONITOR
2175					endif 
2175			 
2175					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2175 cd ae 18			call macro_dsp_valuehl 
2178				endm 
# End of macro FORTH_DSP_VALUEHL
2178			 
2178			;		push hl 
2178			 
2178					; destroy value TOS 
2178			 
2178					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2178 cd 4a 19			call macro_forth_dsp_pop 
217b				endm 
# End of macro FORTH_DSP_POP
217b			 
217b						 
217b			;		pop hl 
217b			 
217b					; how to do a call with hl???? save SP? 
217b cd ad 19				call forth_call_hl 
217e			 
217e			 
217e					; TODO push value back onto stack for another op etc 
217e			 
217e cd 13 18				call forth_push_numhl 
2181					NEXTW 
2181 c3 04 1a			jp macro_next 
2184				endm 
# End of macro NEXTW
2184			.DEPTH: 
2184				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2184 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2185 c1 21			dw .OVER            
2187 06				db 5 + 1 
2188 .. 00			db "DEPTH",0              
218e				endm 
# End of macro CWHEAD
218e			; | DEPTH ( -- u ) Push count of stack | DONE 
218e					; take current TOS and remove from base value div by two to get count 
218e					if DEBUG_FORTH_WORDS_KEY 
218e						DMARK "DEP" 
218e f5				push af  
218f 3a a3 21			ld a, (.dmark)  
2192 32 7a ee			ld (debug_mark),a  
2195 3a a4 21			ld a, (.dmark+1)  
2198 32 7b ee			ld (debug_mark+1),a  
219b 3a a5 21			ld a, (.dmark+2)  
219e 32 7c ee			ld (debug_mark+2),a  
21a1 18 03			jr .pastdmark  
21a3 ..			.dmark: db "DEP"  
21a6 f1			.pastdmark: pop af  
21a7			endm  
# End of macro DMARK
21a7						CALLMONITOR 
21a7 cd 86 12			call break_point_state  
21aa				endm  
# End of macro CALLMONITOR
21aa					endif 
21aa			 
21aa			 
21aa 2a 22 eb			ld hl, (cli_data_sp) 
21ad 11 dc e8			ld de, cli_data_stack 
21b0 ed 52			sbc hl,de 
21b2				 
21b2				; div by size of stack item 
21b2			 
21b2 5d				ld e,l 
21b3 0e 03			ld c, 3 
21b5 cd 52 0a			call Div8 
21b8			 
21b8 6f				ld l,a 
21b9 26 00			ld h,0 
21bb			 
21bb				;srl h 
21bb				;rr l 
21bb			 
21bb cd 13 18				call forth_push_numhl 
21be					NEXTW 
21be c3 04 1a			jp macro_next 
21c1				endm 
# End of macro NEXTW
21c1			.OVER: 
21c1				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
21c1 42				db WORD_SYS_CORE+46             
21c2 08 22			dw .PAUSE            
21c4 05				db 4 + 1 
21c5 .. 00			db "OVER",0              
21ca				endm 
# End of macro CWHEAD
21ca			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
21ca					if DEBUG_FORTH_WORDS_KEY 
21ca						DMARK "OVR" 
21ca f5				push af  
21cb 3a df 21			ld a, (.dmark)  
21ce 32 7a ee			ld (debug_mark),a  
21d1 3a e0 21			ld a, (.dmark+1)  
21d4 32 7b ee			ld (debug_mark+1),a  
21d7 3a e1 21			ld a, (.dmark+2)  
21da 32 7c ee			ld (debug_mark+2),a  
21dd 18 03			jr .pastdmark  
21df ..			.dmark: db "OVR"  
21e2 f1			.pastdmark: pop af  
21e3			endm  
# End of macro DMARK
21e3						CALLMONITOR 
21e3 cd 86 12			call break_point_state  
21e6				endm  
# End of macro CALLMONITOR
21e6					endif 
21e6			 
21e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21e6 cd ae 18			call macro_dsp_valuehl 
21e9				endm 
# End of macro FORTH_DSP_VALUEHL
21e9 e5					push hl    ; n2 
21ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
21ea cd 4a 19			call macro_forth_dsp_pop 
21ed				endm 
# End of macro FORTH_DSP_POP
21ed			 
21ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21ed cd ae 18			call macro_dsp_valuehl 
21f0				endm 
# End of macro FORTH_DSP_VALUEHL
21f0 e5					push hl    ; n1 
21f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
21f1 cd 4a 19			call macro_forth_dsp_pop 
21f4				endm 
# End of macro FORTH_DSP_POP
21f4			 
21f4 d1					pop de     ; n1 
21f5 e1					pop hl     ; n2 
21f6			 
21f6 d5					push de 
21f7 e5					push hl 
21f8 d5					push de 
21f9			 
21f9					; push back  
21f9			 
21f9 e1					pop hl 
21fa cd 13 18				call forth_push_numhl 
21fd e1					pop hl 
21fe cd 13 18				call forth_push_numhl 
2201 e1					pop hl 
2202 cd 13 18				call forth_push_numhl 
2205					NEXTW 
2205 c3 04 1a			jp macro_next 
2208				endm 
# End of macro NEXTW
2208			 
2208			.PAUSE: 
2208				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2208 43				db WORD_SYS_CORE+47             
2209 3d 22			dw .PAUSES            
220b 08				db 7 + 1 
220c .. 00			db "PAUSEMS",0              
2214				endm 
# End of macro CWHEAD
2214			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2214					if DEBUG_FORTH_WORDS_KEY 
2214						DMARK "PMS" 
2214 f5				push af  
2215 3a 29 22			ld a, (.dmark)  
2218 32 7a ee			ld (debug_mark),a  
221b 3a 2a 22			ld a, (.dmark+1)  
221e 32 7b ee			ld (debug_mark+1),a  
2221 3a 2b 22			ld a, (.dmark+2)  
2224 32 7c ee			ld (debug_mark+2),a  
2227 18 03			jr .pastdmark  
2229 ..			.dmark: db "PMS"  
222c f1			.pastdmark: pop af  
222d			endm  
# End of macro DMARK
222d						CALLMONITOR 
222d cd 86 12			call break_point_state  
2230				endm  
# End of macro CALLMONITOR
2230					endif 
2230					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2230 cd ae 18			call macro_dsp_valuehl 
2233				endm 
# End of macro FORTH_DSP_VALUEHL
2233			;		push hl    ; n2 
2233					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2233 cd 4a 19			call macro_forth_dsp_pop 
2236				endm 
# End of macro FORTH_DSP_POP
2236			;		pop hl 
2236			 
2236 7d					ld a, l 
2237 cd c7 08				call aDelayInMS 
223a				       NEXTW 
223a c3 04 1a			jp macro_next 
223d				endm 
# End of macro NEXTW
223d			.PAUSES:  
223d				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
223d 44				db WORD_SYS_CORE+48             
223e ac 22			dw .ROT            
2240 06				db 5 + 1 
2241 .. 00			db "PAUSE",0              
2247				endm 
# End of macro CWHEAD
2247			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2247					if DEBUG_FORTH_WORDS_KEY 
2247						DMARK "PAU" 
2247 f5				push af  
2248 3a 5c 22			ld a, (.dmark)  
224b 32 7a ee			ld (debug_mark),a  
224e 3a 5d 22			ld a, (.dmark+1)  
2251 32 7b ee			ld (debug_mark+1),a  
2254 3a 5e 22			ld a, (.dmark+2)  
2257 32 7c ee			ld (debug_mark+2),a  
225a 18 03			jr .pastdmark  
225c ..			.dmark: db "PAU"  
225f f1			.pastdmark: pop af  
2260			endm  
# End of macro DMARK
2260						CALLMONITOR 
2260 cd 86 12			call break_point_state  
2263				endm  
# End of macro CALLMONITOR
2263					endif 
2263					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2263 cd ae 18			call macro_dsp_valuehl 
2266				endm 
# End of macro FORTH_DSP_VALUEHL
2266			;		push hl    ; n2 
2266					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2266 cd 4a 19			call macro_forth_dsp_pop 
2269				endm 
# End of macro FORTH_DSP_POP
2269			;		pop hl 
2269 45					ld b, l 
226a					if DEBUG_FORTH_WORDS 
226a						DMARK "PAU" 
226a f5				push af  
226b 3a 7f 22			ld a, (.dmark)  
226e 32 7a ee			ld (debug_mark),a  
2271 3a 80 22			ld a, (.dmark+1)  
2274 32 7b ee			ld (debug_mark+1),a  
2277 3a 81 22			ld a, (.dmark+2)  
227a 32 7c ee			ld (debug_mark+2),a  
227d 18 03			jr .pastdmark  
227f ..			.dmark: db "PAU"  
2282 f1			.pastdmark: pop af  
2283			endm  
# End of macro DMARK
2283						CALLMONITOR 
2283 cd 86 12			call break_point_state  
2286				endm  
# End of macro CALLMONITOR
2286					endif 
2286 c5			.pauses1:	push bc 
2287 cd e2 08				call delay1s 
228a c1					pop bc 
228b					if DEBUG_FORTH_WORDS 
228b						DMARK "PA1" 
228b f5				push af  
228c 3a a0 22			ld a, (.dmark)  
228f 32 7a ee			ld (debug_mark),a  
2292 3a a1 22			ld a, (.dmark+1)  
2295 32 7b ee			ld (debug_mark+1),a  
2298 3a a2 22			ld a, (.dmark+2)  
229b 32 7c ee			ld (debug_mark+2),a  
229e 18 03			jr .pastdmark  
22a0 ..			.dmark: db "PA1"  
22a3 f1			.pastdmark: pop af  
22a4			endm  
# End of macro DMARK
22a4						CALLMONITOR 
22a4 cd 86 12			call break_point_state  
22a7				endm  
# End of macro CALLMONITOR
22a7					endif 
22a7 10 dd				djnz .pauses1 
22a9			 
22a9				       NEXTW 
22a9 c3 04 1a			jp macro_next 
22ac				endm 
# End of macro NEXTW
22ac			.ROT: 
22ac				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
22ac 45				db WORD_SYS_CORE+49             
22ad fa 22			dw .UWORDS            
22af 04				db 3 + 1 
22b0 .. 00			db "ROT",0              
22b4				endm 
# End of macro CWHEAD
22b4			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
22b4					if DEBUG_FORTH_WORDS_KEY 
22b4						DMARK "ROT" 
22b4 f5				push af  
22b5 3a c9 22			ld a, (.dmark)  
22b8 32 7a ee			ld (debug_mark),a  
22bb 3a ca 22			ld a, (.dmark+1)  
22be 32 7b ee			ld (debug_mark+1),a  
22c1 3a cb 22			ld a, (.dmark+2)  
22c4 32 7c ee			ld (debug_mark+2),a  
22c7 18 03			jr .pastdmark  
22c9 ..			.dmark: db "ROT"  
22cc f1			.pastdmark: pop af  
22cd			endm  
# End of macro DMARK
22cd						CALLMONITOR 
22cd cd 86 12			call break_point_state  
22d0				endm  
# End of macro CALLMONITOR
22d0					endif 
22d0			 
22d0					FORTH_DSP_VALUEHL 
22d0 cd ae 18			call macro_dsp_valuehl 
22d3				endm 
# End of macro FORTH_DSP_VALUEHL
22d3 e5					push hl    ; u3  
22d4			 
22d4					FORTH_DSP_POP 
22d4 cd 4a 19			call macro_forth_dsp_pop 
22d7				endm 
# End of macro FORTH_DSP_POP
22d7			   
22d7					FORTH_DSP_VALUEHL 
22d7 cd ae 18			call macro_dsp_valuehl 
22da				endm 
# End of macro FORTH_DSP_VALUEHL
22da e5					push hl     ; u2 
22db			 
22db					FORTH_DSP_POP 
22db cd 4a 19			call macro_forth_dsp_pop 
22de				endm 
# End of macro FORTH_DSP_POP
22de			 
22de					FORTH_DSP_VALUEHL 
22de cd ae 18			call macro_dsp_valuehl 
22e1				endm 
# End of macro FORTH_DSP_VALUEHL
22e1 e5					push hl     ; u1 
22e2			 
22e2					FORTH_DSP_POP 
22e2 cd 4a 19			call macro_forth_dsp_pop 
22e5				endm 
# End of macro FORTH_DSP_POP
22e5			 
22e5 c1					pop bc      ; u1 
22e6 e1					pop hl      ; u2 
22e7 d1					pop de      ; u3 
22e8			 
22e8			 
22e8 c5					push bc 
22e9 d5					push de 
22ea e5					push hl 
22eb			 
22eb			 
22eb e1					pop hl 
22ec cd 13 18				call forth_push_numhl 
22ef			 
22ef e1					pop hl 
22f0 cd 13 18				call forth_push_numhl 
22f3			 
22f3 e1					pop hl 
22f4 cd 13 18				call forth_push_numhl 
22f7					 
22f7			 
22f7			 
22f7			 
22f7			 
22f7			 
22f7				       NEXTW 
22f7 c3 04 1a			jp macro_next 
22fa				endm 
# End of macro NEXTW
22fa			 
22fa			.UWORDS: 
22fa				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
22fa 50				db WORD_SYS_CORE+60             
22fb bc 23			dw .BP            
22fd 07				db 6 + 1 
22fe .. 00			db "UWORDS",0              
2305				endm 
# End of macro CWHEAD
2305			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2305			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2305			; | | Following the count are the individual words. 
2305			; | | 
2305			; | | e.g. UWORDS 
2305			; | | BOX DIRLIST 2 
2305			; | |  
2305			; | | Can be used to save the words to storage via: 
2305			; | | UWORDS $01 DO $01 APPEND LOOP 
2305				if DEBUG_FORTH_WORDS_KEY 
2305					DMARK "UWR" 
2305 f5				push af  
2306 3a 1a 23			ld a, (.dmark)  
2309 32 7a ee			ld (debug_mark),a  
230c 3a 1b 23			ld a, (.dmark+1)  
230f 32 7b ee			ld (debug_mark+1),a  
2312 3a 1c 23			ld a, (.dmark+2)  
2315 32 7c ee			ld (debug_mark+2),a  
2318 18 03			jr .pastdmark  
231a ..			.dmark: db "UWR"  
231d f1			.pastdmark: pop af  
231e			endm  
# End of macro DMARK
231e					CALLMONITOR 
231e cd 86 12			call break_point_state  
2321				endm  
# End of macro CALLMONITOR
2321				endif 
2321 21 0a 56				ld hl, baseram 
2324					;ld hl, baseusermem 
2324 01 00 00				ld bc, 0    ; start a counter 
2327			 
2327				; skip dict stub 
2327			 
2327 cd 55 1b				call forth_tok_next 
232a			 
232a			 
232a			; while we have words to look for 
232a			 
232a 7e			.douscan:	ld a, (hl)      
232b				if DEBUG_FORTH_WORDS 
232b					DMARK "UWs" 
232b f5				push af  
232c 3a 40 23			ld a, (.dmark)  
232f 32 7a ee			ld (debug_mark),a  
2332 3a 41 23			ld a, (.dmark+1)  
2335 32 7b ee			ld (debug_mark+1),a  
2338 3a 42 23			ld a, (.dmark+2)  
233b 32 7c ee			ld (debug_mark+2),a  
233e 18 03			jr .pastdmark  
2340 ..			.dmark: db "UWs"  
2343 f1			.pastdmark: pop af  
2344			endm  
# End of macro DMARK
2344					CALLMONITOR 
2344 cd 86 12			call break_point_state  
2347				endm  
# End of macro CALLMONITOR
2347				endif 
2347 fe 00				cp WORD_SYS_END 
2349 28 4d				jr z, .udone 
234b fe 01				cp WORD_SYS_UWORD 
234d 20 44				jr nz, .nuword 
234f			 
234f				if DEBUG_FORTH_WORDS 
234f					DMARK "UWu" 
234f f5				push af  
2350 3a 64 23			ld a, (.dmark)  
2353 32 7a ee			ld (debug_mark),a  
2356 3a 65 23			ld a, (.dmark+1)  
2359 32 7b ee			ld (debug_mark+1),a  
235c 3a 66 23			ld a, (.dmark+2)  
235f 32 7c ee			ld (debug_mark+2),a  
2362 18 03			jr .pastdmark  
2364 ..			.dmark: db "UWu"  
2367 f1			.pastdmark: pop af  
2368			endm  
# End of macro DMARK
2368					CALLMONITOR 
2368 cd 86 12			call break_point_state  
236b				endm  
# End of macro CALLMONITOR
236b				endif 
236b					; we have a uword so push its name to the stack 
236b			 
236b e5				   	push hl  ; save so we can move to next dict block 
236c			 
236c					; skip opcode 
236c 23					inc hl  
236d					; skip next ptr 
236d 23					inc hl  
236e 23					inc hl 
236f					; skip len 
236f 23					inc hl 
2370				if DEBUG_FORTH_WORDS 
2370					DMARK "UWt" 
2370 f5				push af  
2371 3a 85 23			ld a, (.dmark)  
2374 32 7a ee			ld (debug_mark),a  
2377 3a 86 23			ld a, (.dmark+1)  
237a 32 7b ee			ld (debug_mark+1),a  
237d 3a 87 23			ld a, (.dmark+2)  
2380 32 7c ee			ld (debug_mark+2),a  
2383 18 03			jr .pastdmark  
2385 ..			.dmark: db "UWt"  
2388 f1			.pastdmark: pop af  
2389			endm  
# End of macro DMARK
2389					CALLMONITOR 
2389 cd 86 12			call break_point_state  
238c				endm  
# End of macro CALLMONITOR
238c				endif 
238c 03					inc bc 
238d			 
238d c5					push bc 
238e cd 25 18				call forth_push_str 
2391 c1					pop bc 
2392			 
2392 e1					pop hl 	 
2393			 
2393 cd 55 1b		.nuword:	call forth_tok_next 
2396 18 92				jr .douscan  
2398			 
2398			.udone:		 ; push count of uwords found 
2398 c5					push bc 
2399 e1					pop hl 
239a			 
239a				if DEBUG_FORTH_WORDS 
239a					DMARK "UWc" 
239a f5				push af  
239b 3a af 23			ld a, (.dmark)  
239e 32 7a ee			ld (debug_mark),a  
23a1 3a b0 23			ld a, (.dmark+1)  
23a4 32 7b ee			ld (debug_mark+1),a  
23a7 3a b1 23			ld a, (.dmark+2)  
23aa 32 7c ee			ld (debug_mark+2),a  
23ad 18 03			jr .pastdmark  
23af ..			.dmark: db "UWc"  
23b2 f1			.pastdmark: pop af  
23b3			endm  
# End of macro DMARK
23b3					CALLMONITOR 
23b3 cd 86 12			call break_point_state  
23b6				endm  
# End of macro CALLMONITOR
23b6				endif 
23b6 cd 13 18				call forth_push_numhl 
23b9			 
23b9			 
23b9				       NEXTW 
23b9 c3 04 1a			jp macro_next 
23bc				endm 
# End of macro NEXTW
23bc			 
23bc			.BP: 
23bc				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
23bc 54				db WORD_SYS_CORE+64             
23bd f2 23			dw .MONITOR            
23bf 03				db 2 + 1 
23c0 .. 00			db "BP",0              
23c3				endm 
# End of macro CWHEAD
23c3			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
23c3			; | | $00 Will enable the break points within specific code paths 
23c3			; | | $01 Will disable break points 
23c3			; | |  
23c3			; | | By default break points are off. Either the above can be used to enable them 
23c3			; | | or if a key is held down during start up the spashscreen will appear to freeze 
23c3			; | | and on release of the pressed key a message will be disaplayed to notify 
23c3			; | | that break points are enabled. Pressing any key will then continue boot process. 
23c3					; get byte count 
23c3					if DEBUG_FORTH_WORDS_KEY 
23c3						DMARK "BP." 
23c3 f5				push af  
23c4 3a d8 23			ld a, (.dmark)  
23c7 32 7a ee			ld (debug_mark),a  
23ca 3a d9 23			ld a, (.dmark+1)  
23cd 32 7b ee			ld (debug_mark+1),a  
23d0 3a da 23			ld a, (.dmark+2)  
23d3 32 7c ee			ld (debug_mark+2),a  
23d6 18 03			jr .pastdmark  
23d8 ..			.dmark: db "BP."  
23db f1			.pastdmark: pop af  
23dc			endm  
# End of macro DMARK
23dc						CALLMONITOR 
23dc cd 86 12			call break_point_state  
23df				endm  
# End of macro CALLMONITOR
23df					endif 
23df			 
23df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23df cd ae 18			call macro_dsp_valuehl 
23e2				endm 
# End of macro FORTH_DSP_VALUEHL
23e2			 
23e2			;		push hl 
23e2			 
23e2					; destroy value TOS 
23e2			 
23e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23e2 cd 4a 19			call macro_forth_dsp_pop 
23e5				endm 
# End of macro FORTH_DSP_POP
23e5			 
23e5			;		pop hl 
23e5			 
23e5 3e 00				ld a,0 
23e7 bd					cp l 
23e8 28 02				jr z, .bpset 
23ea 3e 2a				ld a, '*' 
23ec			 
23ec 32 74 e3		.bpset:		ld (os_view_disable), a 
23ef			 
23ef			 
23ef					NEXTW 
23ef c3 04 1a			jp macro_next 
23f2				endm 
# End of macro NEXTW
23f2			 
23f2			 
23f2			.MONITOR: 
23f2				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
23f2 55				db WORD_SYS_CORE+65             
23f3 25 24			dw .MALLOC            
23f5 08				db 7 + 1 
23f6 .. 00			db "MONITOR",0              
23fe				endm 
# End of macro CWHEAD
23fe			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
23fe			; | | At start the current various registers will be displayed with contents. 
23fe			; | | Top right corner will show the most recent debug marker seen. 
23fe			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
23fe			; | | and the return stack pointer (RSP). 
23fe			; | | Pressing: 
23fe			; | |    1 - Initial screen 
23fe			; | |    2 - Display a data dump of HL 
23fe			; | |    3 - Display a data dump of DE 
23fe			; | |    4 - Display a data dump of BC 
23fe			; | |    5 - Display a data dump of HL 
23fe			; | |    6 - Display a data dump of DSP 
23fe			; | |    7 - Display a data dump of RSP 
23fe			; | |    8 - Display a data dump of what is at DSP 
23fe			; | |    9 - Display a data dump of what is at RSP 
23fe			; | |    0 - Exit monitor and continue running. This will also enable break points 
23fe			; | |    * - Disable break points 
23fe			; | |    # - Enter traditional monitor mode 
23fe			; | | 
23fe			; | | Monitor Mode 
23fe			; | | ------------ 
23fe			; | | A prompt of '>' will be shown for various commands: 
23fe			; | |    D xxxx - Display a data dump starting from hex address xxxx 
23fe			; | |    C - Continue display a data dump from the last set address 
23fe			; | |    M xxxx - Set start of memory edit at address xx 
23fe			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
23fe			; | |    Q - Return to previous 
23fe					if DEBUG_FORTH_WORDS_KEY 
23fe						DMARK "MON" 
23fe f5				push af  
23ff 3a 13 24			ld a, (.dmark)  
2402 32 7a ee			ld (debug_mark),a  
2405 3a 14 24			ld a, (.dmark+1)  
2408 32 7b ee			ld (debug_mark+1),a  
240b 3a 15 24			ld a, (.dmark+2)  
240e 32 7c ee			ld (debug_mark+2),a  
2411 18 03			jr .pastdmark  
2413 ..			.dmark: db "MON"  
2416 f1			.pastdmark: pop af  
2417			endm  
# End of macro DMARK
2417						CALLMONITOR 
2417 cd 86 12			call break_point_state  
241a				endm  
# End of macro CALLMONITOR
241a					endif 
241a 3e 00				ld a, 0 
241c 32 74 e3				ld (os_view_disable), a 
241f			 
241f					CALLMONITOR 
241f cd 86 12			call break_point_state  
2422				endm  
# End of macro CALLMONITOR
2422			 
2422			;	call monitor 
2422			 
2422					NEXTW 
2422 c3 04 1a			jp macro_next 
2425				endm 
# End of macro NEXTW
2425			 
2425			 
2425			.MALLOC: 
2425				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2425 56				db WORD_SYS_CORE+66             
2426 4e 24			dw .MALLOC2            
2428 06				db 5 + 1 
2429 .. 00			db "ALLOT",0              
242f				endm 
# End of macro CWHEAD
242f			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
242f					if DEBUG_FORTH_WORDS_KEY 
242f						DMARK "ALL" 
242f f5				push af  
2430 3a 44 24			ld a, (.dmark)  
2433 32 7a ee			ld (debug_mark),a  
2436 3a 45 24			ld a, (.dmark+1)  
2439 32 7b ee			ld (debug_mark+1),a  
243c 3a 46 24			ld a, (.dmark+2)  
243f 32 7c ee			ld (debug_mark+2),a  
2442 18 03			jr .pastdmark  
2444 ..			.dmark: db "ALL"  
2447 f1			.pastdmark: pop af  
2448			endm  
# End of macro DMARK
2448						CALLMONITOR 
2448 cd 86 12			call break_point_state  
244b				endm  
# End of macro CALLMONITOR
244b					endif 
244b c3 75 24				jp .mallocc 
244e			.MALLOC2: 
244e				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
244e 56				db WORD_SYS_CORE+66             
244f 8c 24			dw .FREE            
2451 07				db 6 + 1 
2452 .. 00			db "MALLOC",0              
2459				endm 
# End of macro CWHEAD
2459			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2459					; get byte count 
2459					if DEBUG_FORTH_WORDS_KEY 
2459						DMARK "MAL" 
2459 f5				push af  
245a 3a 6e 24			ld a, (.dmark)  
245d 32 7a ee			ld (debug_mark),a  
2460 3a 6f 24			ld a, (.dmark+1)  
2463 32 7b ee			ld (debug_mark+1),a  
2466 3a 70 24			ld a, (.dmark+2)  
2469 32 7c ee			ld (debug_mark+2),a  
246c 18 03			jr .pastdmark  
246e ..			.dmark: db "MAL"  
2471 f1			.pastdmark: pop af  
2472			endm  
# End of macro DMARK
2472						CALLMONITOR 
2472 cd 86 12			call break_point_state  
2475				endm  
# End of macro CALLMONITOR
2475					endif 
2475			.mallocc: 
2475					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2475 cd ae 18			call macro_dsp_valuehl 
2478				endm 
# End of macro FORTH_DSP_VALUEHL
2478			 
2478			;		push hl 
2478			 
2478					; destroy value TOS 
2478			 
2478					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2478 cd 4a 19			call macro_forth_dsp_pop 
247b				endm 
# End of macro FORTH_DSP_POP
247b			 
247b			;		pop hl 
247b cd 89 0f				call malloc 
247e				if DEBUG_FORTH_MALLOC_GUARD 
247e f5					push af 
247f cd eb 0a				call ishlzero 
2482			;		ld a, l 
2482			;		add h 
2482			;		cp 0 
2482 f1					pop af 
2483					 
2483 cc 67 42				call z,malloc_error 
2486				endif 
2486			 
2486 cd 13 18				call forth_push_numhl 
2489					NEXTW 
2489 c3 04 1a			jp macro_next 
248c				endm 
# End of macro NEXTW
248c			 
248c			.FREE: 
248c				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
248c 57				db WORD_SYS_CORE+67             
248d bd 24			dw .LIST            
248f 05				db 4 + 1 
2490 .. 00			db "FREE",0              
2495				endm 
# End of macro CWHEAD
2495			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2495					if DEBUG_FORTH_WORDS_KEY 
2495						DMARK "FRE" 
2495 f5				push af  
2496 3a aa 24			ld a, (.dmark)  
2499 32 7a ee			ld (debug_mark),a  
249c 3a ab 24			ld a, (.dmark+1)  
249f 32 7b ee			ld (debug_mark+1),a  
24a2 3a ac 24			ld a, (.dmark+2)  
24a5 32 7c ee			ld (debug_mark+2),a  
24a8 18 03			jr .pastdmark  
24aa ..			.dmark: db "FRE"  
24ad f1			.pastdmark: pop af  
24ae			endm  
# End of macro DMARK
24ae						CALLMONITOR 
24ae cd 86 12			call break_point_state  
24b1				endm  
# End of macro CALLMONITOR
24b1					endif 
24b1					; get address 
24b1			 
24b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24b1 cd ae 18			call macro_dsp_valuehl 
24b4				endm 
# End of macro FORTH_DSP_VALUEHL
24b4			 
24b4			;		push hl 
24b4			 
24b4					; destroy value TOS 
24b4			 
24b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24b4 cd 4a 19			call macro_forth_dsp_pop 
24b7				endm 
# End of macro FORTH_DSP_POP
24b7			 
24b7			;		pop hl 
24b7			if FORTH_ENABLE_MALLOCFREE 
24b7 cd 53 10				call free 
24ba			endif 
24ba					NEXTW 
24ba c3 04 1a			jp macro_next 
24bd				endm 
# End of macro NEXTW
24bd			.LIST: 
24bd				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
24bd 5c				db WORD_SYS_CORE+72             
24be 80 26			dw .FORGET            
24c0 05				db 4 + 1 
24c1 .. 00			db "LIST",0              
24c6				endm 
# End of macro CWHEAD
24c6			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
24c6			; | | The quoted word must be in upper case. 
24c6				if DEBUG_FORTH_WORDS_KEY 
24c6					DMARK "LST" 
24c6 f5				push af  
24c7 3a db 24			ld a, (.dmark)  
24ca 32 7a ee			ld (debug_mark),a  
24cd 3a dc 24			ld a, (.dmark+1)  
24d0 32 7b ee			ld (debug_mark+1),a  
24d3 3a dd 24			ld a, (.dmark+2)  
24d6 32 7c ee			ld (debug_mark+2),a  
24d9 18 03			jr .pastdmark  
24db ..			.dmark: db "LST"  
24de f1			.pastdmark: pop af  
24df			endm  
# End of macro DMARK
24df					CALLMONITOR 
24df cd 86 12			call break_point_state  
24e2				endm  
# End of macro CALLMONITOR
24e2				endif 
24e2			 
24e2					FORTH_DSP_VALUEHL 
24e2 cd ae 18			call macro_dsp_valuehl 
24e5				endm 
# End of macro FORTH_DSP_VALUEHL
24e5			 
24e5 e5					push hl 
24e6 c1					pop bc 
24e7			 
24e7			; Start format of scratch string 
24e7			 
24e7 21 75 e3				ld hl, scratch 
24ea			 
24ea 3e 3a				ld a, ':' 
24ec 77					ld (hl),a 
24ed 23					inc hl 
24ee 3e 20				ld a, ' ' 
24f0 77					ld (hl), a 
24f1			 
24f1					; Get ptr to the word we need to look up 
24f1			 
24f1			;		FORTH_DSP_VALUEHL 
24f1					;v5 FORTH_DSP_VALUE 
24f1				; TODO type check 
24f1			;		inc hl    ; Skip type check  
24f1			;		push hl 
24f1			;		ex de, hl    ; put into DE 
24f1			 
24f1			 
24f1 21 0a 56				ld hl, baseram 
24f4					;ld hl, baseusermem 
24f4			 
24f4 e5			push hl   ; sacreifical push 
24f5			 
24f5			.ldouscanm: 
24f5 e1				pop hl 
24f6			.ldouscan: 
24f6				if DEBUG_FORTH_WORDS 
24f6					DMARK "LSs" 
24f6 f5				push af  
24f7 3a 0b 25			ld a, (.dmark)  
24fa 32 7a ee			ld (debug_mark),a  
24fd 3a 0c 25			ld a, (.dmark+1)  
2500 32 7b ee			ld (debug_mark+1),a  
2503 3a 0d 25			ld a, (.dmark+2)  
2506 32 7c ee			ld (debug_mark+2),a  
2509 18 03			jr .pastdmark  
250b ..			.dmark: db "LSs"  
250e f1			.pastdmark: pop af  
250f			endm  
# End of macro DMARK
250f					CALLMONITOR 
250f cd 86 12			call break_point_state  
2512				endm  
# End of macro CALLMONITOR
2512				endif 
2512				; skip dict stub 
2512 cd 55 1b				call forth_tok_next 
2515			 
2515			 
2515			; while we have words to look for 
2515			 
2515 7e				ld a, (hl)      
2516				if DEBUG_FORTH_WORDS 
2516					DMARK "LSk" 
2516 f5				push af  
2517 3a 2b 25			ld a, (.dmark)  
251a 32 7a ee			ld (debug_mark),a  
251d 3a 2c 25			ld a, (.dmark+1)  
2520 32 7b ee			ld (debug_mark+1),a  
2523 3a 2d 25			ld a, (.dmark+2)  
2526 32 7c ee			ld (debug_mark+2),a  
2529 18 03			jr .pastdmark  
252b ..			.dmark: db "LSk"  
252e f1			.pastdmark: pop af  
252f			endm  
# End of macro DMARK
252f					CALLMONITOR 
252f cd 86 12			call break_point_state  
2532				endm  
# End of macro CALLMONITOR
2532				endif 
2532 fe 00				cp WORD_SYS_END 
2534 ca 67 26				jp z, .lunotfound 
2537 fe 01				cp WORD_SYS_UWORD 
2539 c2 f6 24				jp nz, .ldouscan 
253c			 
253c				if DEBUG_FORTH_WORDS 
253c					DMARK "LSu" 
253c f5				push af  
253d 3a 51 25			ld a, (.dmark)  
2540 32 7a ee			ld (debug_mark),a  
2543 3a 52 25			ld a, (.dmark+1)  
2546 32 7b ee			ld (debug_mark+1),a  
2549 3a 53 25			ld a, (.dmark+2)  
254c 32 7c ee			ld (debug_mark+2),a  
254f 18 03			jr .pastdmark  
2551 ..			.dmark: db "LSu"  
2554 f1			.pastdmark: pop af  
2555			endm  
# End of macro DMARK
2555					CALLMONITOR 
2555 cd 86 12			call break_point_state  
2558				endm  
# End of macro CALLMONITOR
2558				endif 
2558			 
2558					; found a uword but is it the one we want... 
2558			 
2558 c5					push bc     ; uword to find is on bc 
2559 d1					pop de 
255a			 
255a e5					push hl  ; to save the ptr 
255b			 
255b					; skip opcode 
255b 23					inc hl  
255c					; skip next ptr 
255c 23					inc hl  
255d 23					inc hl 
255e					; skip len 
255e 23					inc hl 
255f			 
255f				if DEBUG_FORTH_WORDS 
255f					DMARK "LSc" 
255f f5				push af  
2560 3a 74 25			ld a, (.dmark)  
2563 32 7a ee			ld (debug_mark),a  
2566 3a 75 25			ld a, (.dmark+1)  
2569 32 7b ee			ld (debug_mark+1),a  
256c 3a 76 25			ld a, (.dmark+2)  
256f 32 7c ee			ld (debug_mark+2),a  
2572 18 03			jr .pastdmark  
2574 ..			.dmark: db "LSc"  
2577 f1			.pastdmark: pop af  
2578			endm  
# End of macro DMARK
2578					CALLMONITOR 
2578 cd 86 12			call break_point_state  
257b				endm  
# End of macro CALLMONITOR
257b				endif 
257b cd 58 0f				call strcmp 
257e c2 f5 24				jp nz, .ldouscanm 
2581				 
2581			 
2581			 
2581					; we have a uword so push its name to the stack 
2581			 
2581			;	   	push hl  ; save so we can move to next dict block 
2581 e1			pop hl 
2582			 
2582				if DEBUG_FORTH_WORDS 
2582					DMARK "LSm" 
2582 f5				push af  
2583 3a 97 25			ld a, (.dmark)  
2586 32 7a ee			ld (debug_mark),a  
2589 3a 98 25			ld a, (.dmark+1)  
258c 32 7b ee			ld (debug_mark+1),a  
258f 3a 99 25			ld a, (.dmark+2)  
2592 32 7c ee			ld (debug_mark+2),a  
2595 18 03			jr .pastdmark  
2597 ..			.dmark: db "LSm"  
259a f1			.pastdmark: pop af  
259b			endm  
# End of macro DMARK
259b					CALLMONITOR 
259b cd 86 12			call break_point_state  
259e				endm  
# End of macro CALLMONITOR
259e				endif 
259e			 
259e					; skip opcode 
259e 23					inc hl  
259f					; skip next ptr 
259f 23					inc hl  
25a0 23					inc hl 
25a1					; skip len 
25a1 7e					ld a, (hl)   ; save length to add 
25a2				if DEBUG_FORTH_WORDS 
25a2					DMARK "LS2" 
25a2 f5				push af  
25a3 3a b7 25			ld a, (.dmark)  
25a6 32 7a ee			ld (debug_mark),a  
25a9 3a b8 25			ld a, (.dmark+1)  
25ac 32 7b ee			ld (debug_mark+1),a  
25af 3a b9 25			ld a, (.dmark+2)  
25b2 32 7c ee			ld (debug_mark+2),a  
25b5 18 03			jr .pastdmark  
25b7 ..			.dmark: db "LS2"  
25ba f1			.pastdmark: pop af  
25bb			endm  
# End of macro DMARK
25bb					CALLMONITOR 
25bb cd 86 12			call break_point_state  
25be				endm  
# End of macro CALLMONITOR
25be				endif 
25be			 
25be					; save this location 
25be				 
25be e5					push hl 
25bf			 
25bf 23					inc hl 
25c0 11 77 e3				ld de, scratch+2 
25c3 4f					ld c, a 
25c4 06 00				ld b, 0 
25c6			 
25c6				if DEBUG_FORTH_WORDS 
25c6					DMARK "LSn" 
25c6 f5				push af  
25c7 3a db 25			ld a, (.dmark)  
25ca 32 7a ee			ld (debug_mark),a  
25cd 3a dc 25			ld a, (.dmark+1)  
25d0 32 7b ee			ld (debug_mark+1),a  
25d3 3a dd 25			ld a, (.dmark+2)  
25d6 32 7c ee			ld (debug_mark+2),a  
25d9 18 03			jr .pastdmark  
25db ..			.dmark: db "LSn"  
25de f1			.pastdmark: pop af  
25df			endm  
# End of macro DMARK
25df					CALLMONITOR 
25df cd 86 12			call break_point_state  
25e2				endm  
# End of macro CALLMONITOR
25e2				endif 
25e2			 
25e2					; copy uword name to scratch 
25e2			 
25e2 ed b0				ldir 
25e4			 
25e4 1b					dec de 
25e5 3e 20				ld a, ' '    ; change null to space 
25e7 12					ld (de), a 
25e8			 
25e8 13					inc de 
25e9			 
25e9 d5					push de 
25ea c1					pop bc     ; move scratch pointer to end of word name and save it 
25eb			 
25eb e1					pop hl 
25ec 7e					ld a, (hl) 
25ed					;inc hl 
25ed					; skip word string 
25ed cd c2 0a				call addatohl 
25f0			 
25f0 23					inc hl 
25f1			 
25f1				if DEBUG_FORTH_WORDS 
25f1					DMARK "LS3" 
25f1 f5				push af  
25f2 3a 06 26			ld a, (.dmark)  
25f5 32 7a ee			ld (debug_mark),a  
25f8 3a 07 26			ld a, (.dmark+1)  
25fb 32 7b ee			ld (debug_mark+1),a  
25fe 3a 08 26			ld a, (.dmark+2)  
2601 32 7c ee			ld (debug_mark+2),a  
2604 18 03			jr .pastdmark  
2606 ..			.dmark: db "LS3"  
2609 f1			.pastdmark: pop af  
260a			endm  
# End of macro DMARK
260a					CALLMONITOR 
260a cd 86 12			call break_point_state  
260d				endm  
# End of macro CALLMONITOR
260d				endif 
260d					; should now be at the start of the machine code to setup the eval of the uword 
260d					; now locate the ptr to the string defintion 
260d			 
260d					; skip ld hl, 
260d					; then load the ptr 
260d			 
260d 23					inc hl 
260e 5e					ld e, (hl) 
260f 23					inc hl 
2610 56					ld d, (hl) 
2611 eb					ex de, hl 
2612			 
2612			 
2612				if DEBUG_FORTH_WORDS 
2612					DMARK "LSt" 
2612 f5				push af  
2613 3a 27 26			ld a, (.dmark)  
2616 32 7a ee			ld (debug_mark),a  
2619 3a 28 26			ld a, (.dmark+1)  
261c 32 7b ee			ld (debug_mark+1),a  
261f 3a 29 26			ld a, (.dmark+2)  
2622 32 7c ee			ld (debug_mark+2),a  
2625 18 03			jr .pastdmark  
2627 ..			.dmark: db "LSt"  
262a f1			.pastdmark: pop af  
262b			endm  
# End of macro DMARK
262b					CALLMONITOR 
262b cd 86 12			call break_point_state  
262e				endm  
# End of macro CALLMONITOR
262e				endif 
262e			 
262e			; cant push right now due to tokenised strings  
262e			 
262e			; get the destination of where to copy this definition to. 
262e			 
262e c5					push bc 
262f d1					pop de 
2630			 
2630 7e			.listl:         ld a,(hl) 
2631 fe 00				cp 0 
2633 28 09				jr z, .lreplsp     ; replace zero with space 
2635 fe 7f				cp FORTH_END_BUFFER 
2637 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2639				 
2639					; just copy this char as is then 
2639			 
2639 12					ld (de), a 
263a			 
263a 23			.listnxt:	inc hl 
263b 13					inc de 
263c 18 f2				jr .listl 
263e			 
263e 3e 20		.lreplsp:	ld a,' ' 
2640 12					ld (de), a 
2641 18 f7				jr .listnxt 
2643			 
2643			; close up uword def 
2643			 
2643			.listdone: 
2643 3e 00				ld a, 0 
2645 12					ld (de), a 
2646			 
2646			; now have def so clean up and push to stack 
2646			 
2646 21 75 e3				ld hl, scratch 
2649				if DEBUG_FORTH_WORDS 
2649					DMARK "Ltp" 
2649 f5				push af  
264a 3a 5e 26			ld a, (.dmark)  
264d 32 7a ee			ld (debug_mark),a  
2650 3a 5f 26			ld a, (.dmark+1)  
2653 32 7b ee			ld (debug_mark+1),a  
2656 3a 60 26			ld a, (.dmark+2)  
2659 32 7c ee			ld (debug_mark+2),a  
265c 18 03			jr .pastdmark  
265e ..			.dmark: db "Ltp"  
2661 f1			.pastdmark: pop af  
2662			endm  
# End of macro DMARK
2662					CALLMONITOR 
2662 cd 86 12			call break_point_state  
2665				endm  
# End of macro CALLMONITOR
2665				endif 
2665			 
2665 18 06			jr .listpush 
2667			 
2667			;.lnuword:	pop hl 
2667			;		call forth_tok_next 
2667			;		jp .ldouscan  
2667			 
2667			.lunotfound:		  
2667			 
2667			 
2667					 
2667					FORTH_DSP_POP 
2667 cd 4a 19			call macro_forth_dsp_pop 
266a				endm 
# End of macro FORTH_DSP_POP
266a 21 73 26				ld hl, .luno 
266d						 
266d			 
266d			.listpush: 
266d cd 25 18				call forth_push_str 
2670			 
2670			 
2670			 
2670					NEXTW 
2670 c3 04 1a			jp macro_next 
2673				endm 
# End of macro NEXTW
2673			 
2673 .. 00		.luno:    db "Not found",0 
267d			 
267d			 
267d			 
267d			 
267d			 
267d			;		push hl   ; save pointer to start of uword def string 
267d			; 
267d			;; look for FORTH_EOL_LINE 
267d			;		ld a, FORTH_END_BUFFER 
267d			;		call strlent 
267d			; 
267d			;		inc hl		 ; space for coln def 
267d			;		inc hl 
267d			;		inc hl          ; space for terms 
267d			;		inc hl 
267d			; 
267d			;		ld a, 20   ; TODO get actual length 
267d			;		call addatohl    ; include a random amount of room for the uword name 
267d			; 
267d			;		 
267d			;	if DEBUG_FORTH_WORDS 
267d			;		DMARK "Lt1" 
267d			;		CALLMONITOR 
267d			;	endif 
267d			;		 
267d			; 
267d			;; malloc space for the string because we cant change it 
267d			; 
267d			;		call malloc 
267d			;	if DEBUG_FORTH_MALLOC_GUARD 
267d			;		push af 
267d			;		call ishlzero 
267d			;		pop af 
267d			;		 
267d			;		call z,malloc_error 
267d			;	endif 
267d			; 
267d			;	if DEBUG_FORTH_WORDS 
267d			;		DMARK "Lt2" 
267d			;		CALLMONITOR 
267d			;	endif 
267d			;		pop de 
267d			;		push hl    ; push the malloc to release later 
267d			;		push hl   ;  push back a copy for the later stack push 
267d			;		 
267d			;; copy the string swapping out the zero terms for spaces 
267d			; 
267d			;		; de has our source 
267d			;		; hl has our dest 
267d			; 
267d			;; add the coln def 
267d			; 
267d			;		ld a, ':' 
267d			;		ld (hl), a 
267d			;		inc hl 
267d			;		ld a, ' ' 
267d			;		ld (hl), a 
267d			;		inc hl 
267d			; 
267d			;; add the uname word 
267d			;		push de   ; save our string for now 
267d			;		ex de, hl 
267d			; 
267d			;		FORTH_DSP_VALUE 
267d			;		;v5 FORTH_DSP_VALUE 
267d			; 
267d			;		inc hl   ; skip type but we know by now this is OK 
267d			; 
267d			;.luword:	ld a,(hl) 
267d			;		cp 0 
267d			;		jr z, .luword2 
267d			;		ld (de), a 
267d			;		inc de 
267d			;		inc hl 
267d			;		jr .luword 
267d			; 
267d			;.luword2:	ld a, ' ' 
267d			;		ld (de), a 
267d			;;		inc hl 
267d			;;		inc de 
267d			;;		ld (de), a 
267d			;;		inc hl 
267d			;		inc de 
267d			; 
267d			;		ex de, hl 
267d			;		pop de 
267d			;		 
267d			;		 
267d			; 
267d			;; detoken that string and copy it 
267d			; 
267d			;	if DEBUG_FORTH_WORDS 
267d			;		DMARK "Lt2" 
267d			;		CALLMONITOR 
267d			;	endif 
267d			;.ldetok:	ld a, (de) 
267d			;		cp FORTH_END_BUFFER 
267d			;		jr z, .ldetokend 
267d			;		; swap out any zero term for space 
267d			;		cp 0 
267d			;		jr nz, .ldetoknext 
267d			;		ld a, ' ' 
267d			; 
267d			;	if DEBUG_FORTH_WORDS 
267d			;		DMARK "LtS" 
267d			;		CALLMONITOR 
267d			;	endif 
267d			;.ldetoknext:	ld (hl), a 
267d			;		inc de 
267d			;		inc hl 
267d			;		jr .ldetok 
267d			; 
267d			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
267d			;		ld (hl), a  
267d			; 
267d			;; free that temp malloc 
267d			; 
267d			;		pop hl    
267d			; 
267d			;	if DEBUG_FORTH_WORDS 
267d			;		DMARK "Lt4" 
267d			;		CALLMONITOR 
267d			;	endif 
267d			;		call forth_apushstrhl 
267d			; 
267d			;		; get rid of temp malloc area 
267d			; 
267d			;		pop hl 
267d			;		call free 
267d			; 
267d			;		jr .ludone 
267d			; 
267d			;.lnuword:	pop hl 
267d			;		call forth_tok_next 
267d			;		jp .ldouscan  
267d			; 
267d			;.ludone:		 pop hl 
267d			; 
267d					NEXTW 
267d c3 04 1a			jp macro_next 
2680				endm 
# End of macro NEXTW
2680			 
2680			.FORGET: 
2680				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2680 5d				db WORD_SYS_CORE+73             
2681 f9 26			dw .NOP            
2683 07				db 6 + 1 
2684 .. 00			db "FORGET",0              
268b				endm 
# End of macro CWHEAD
268b			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
268b			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
268b			; | |  
268b			; | | e.g. "MORE" forget 
268b					if DEBUG_FORTH_WORDS_KEY 
268b						DMARK "FRG" 
268b f5				push af  
268c 3a a0 26			ld a, (.dmark)  
268f 32 7a ee			ld (debug_mark),a  
2692 3a a1 26			ld a, (.dmark+1)  
2695 32 7b ee			ld (debug_mark+1),a  
2698 3a a2 26			ld a, (.dmark+2)  
269b 32 7c ee			ld (debug_mark+2),a  
269e 18 03			jr .pastdmark  
26a0 ..			.dmark: db "FRG"  
26a3 f1			.pastdmark: pop af  
26a4			endm  
# End of macro DMARK
26a4						CALLMONITOR 
26a4 cd 86 12			call break_point_state  
26a7				endm  
# End of macro CALLMONITOR
26a7					endif 
26a7			 
26a7				; find uword 
26a7			        ; update start of word with "_" 
26a7				; replace uword with deleted flag 
26a7			 
26a7			 
26a7			;	if DEBUG_FORTH_WORDS 
26a7			;		DMARK "FOG" 
26a7			;		CALLMONITOR 
26a7			;	endif 
26a7			 
26a7			 
26a7					; Get ptr to the word we need to look up 
26a7			 
26a7					FORTH_DSP_VALUEHL 
26a7 cd ae 18			call macro_dsp_valuehl 
26aa				endm 
# End of macro FORTH_DSP_VALUEHL
26aa					;v5 FORTH_DSP_VALUE 
26aa				; TODO type check 
26aa			;		inc hl    ; Skip type check  
26aa e5					push hl 
26ab c1					pop bc 
26ac			;		ex de, hl    ; put into DE 
26ac			 
26ac			 
26ac 21 0a 56				ld hl, baseram 
26af					;ld hl, baseusermem 
26af			 
26af				; skip dict stub 
26af			;	call forth_tok_next 
26af e5			push hl   ; sacreifical push 
26b0			 
26b0			.fldouscanm: 
26b0 e1				pop hl 
26b1			.fldouscan: 
26b1			;	if DEBUG_FORTH_WORDS 
26b1			;		DMARK "LSs" 
26b1			;		CALLMONITOR 
26b1			;	endif 
26b1				; skip dict stub 
26b1 cd 55 1b				call forth_tok_next 
26b4			 
26b4			 
26b4			; while we have words to look for 
26b4			 
26b4 7e				ld a, (hl)      
26b5			;	if DEBUG_FORTH_WORDS 
26b5			;		DMARK "LSk" 
26b5			;		CALLMONITOR 
26b5			;	endif 
26b5 fe 00				cp WORD_SYS_END 
26b7 ca f3 26				jp z, .flunotfound 
26ba fe 01				cp WORD_SYS_UWORD 
26bc c2 b1 26				jp nz, .fldouscan 
26bf			 
26bf			;	if DEBUG_FORTH_WORDS 
26bf			;		DMARK "LSu" 
26bf			;		CALLMONITOR 
26bf			;	endif 
26bf			 
26bf					; found a uword but is it the one we want... 
26bf			 
26bf c5					push bc     ; uword to find is on bc 
26c0 d1					pop de 
26c1			 
26c1 e5					push hl  ; to save the ptr 
26c2			 
26c2					; skip opcode 
26c2 23					inc hl  
26c3					; skip next ptr 
26c3 23					inc hl  
26c4 23					inc hl 
26c5					; skip len 
26c5 23					inc hl 
26c6			 
26c6			;	if DEBUG_FORTH_WORDS 
26c6			;		DMARK "LSc" 
26c6			;		CALLMONITOR 
26c6			;	endif 
26c6 cd 58 0f				call strcmp 
26c9 c2 b0 26				jp nz, .fldouscanm 
26cc			; 
26cc			; 
26cc			;; while we have words to look for 
26cc			; 
26cc			;.fdouscan:	ld a, (hl)      
26cc			;	if DEBUG_FORTH_WORDS 
26cc			;		DMARK "LSs" 
26cc			;		CALLMONITOR 
26cc			;	endif 
26cc			;		cp WORD_SYS_END 
26cc			;		jp z, .fudone 
26cc			;		cp WORD_SYS_UWORD 
26cc			;		jp nz, .fnuword 
26cc			; 
26cc			;	if DEBUG_FORTH_WORDS 
26cc			;		DMARK "FGu" 
26cc			;		CALLMONITOR 
26cc			;	endif 
26cc			; 
26cc			;		; found a uword but is it the one we want... 
26cc			; 
26cc			; 
26cc			;	        pop de   ; get back the dsp name 
26cc			;		push de 
26cc			; 
26cc			;		push hl  ; to save the ptr 
26cc			; 
26cc			;		; skip opcode 
26cc			;		inc hl  
26cc			;		; skip next ptr 
26cc			;		inc hl  
26cc			;		inc hl 
26cc			;		; skip len 
26cc			;		inc hl 
26cc			; 
26cc			;	if DEBUG_FORTH_WORDS 
26cc			;		DMARK "FGc" 
26cc			;		CALLMONITOR 
26cc			;	endif 
26cc			;		call strcmp 
26cc			;		jp nz, .fnuword 
26cc			 
26cc			 
26cc e1			pop hl 
26cd			 
26cd				 
26cd				if DEBUG_FORTH_WORDS 
26cd					DMARK "FGm" 
26cd f5				push af  
26ce 3a e2 26			ld a, (.dmark)  
26d1 32 7a ee			ld (debug_mark),a  
26d4 3a e3 26			ld a, (.dmark+1)  
26d7 32 7b ee			ld (debug_mark+1),a  
26da 3a e4 26			ld a, (.dmark+2)  
26dd 32 7c ee			ld (debug_mark+2),a  
26e0 18 03			jr .pastdmark  
26e2 ..			.dmark: db "FGm"  
26e5 f1			.pastdmark: pop af  
26e6			endm  
# End of macro DMARK
26e6					CALLMONITOR 
26e6 cd 86 12			call break_point_state  
26e9				endm  
# End of macro CALLMONITOR
26e9				endif 
26e9			 
26e9			 
26e9			 
26e9					; we have a uword so push its name to the stack 
26e9			 
26e9			;	   	push hl  ; save so we can move to next dict block 
26e9			;pop hl 
26e9			 
26e9					; update opcode to deleted 
26e9 3e 03				ld a, WORD_SYS_DELETED 
26eb 77					ld (hl), a 
26ec			 
26ec 23					inc hl  
26ed					; skip next ptr 
26ed 23					inc hl  
26ee 23					inc hl 
26ef					; skip len 
26ef 23					inc hl 
26f0			 
26f0					; TODO change parser to skip deleted words but for now mark it out 
26f0 3e 5f				ld a, "_" 
26f2 77					ld  (hl),a 
26f3			 
26f3			;		jr .fudone 
26f3			; 
26f3			;.fnuword:	pop hl 
26f3			;		call forth_tok_next 
26f3			;		jp .fdouscan  
26f3			 
26f3			.flunotfound:		  
26f3			 
26f3			 
26f3					 
26f3					FORTH_DSP_POP 
26f3 cd 4a 19			call macro_forth_dsp_pop 
26f6				endm 
# End of macro FORTH_DSP_POP
26f6			;		ld hl, .luno 
26f6			;.fudone:		 pop hl 
26f6					NEXTW 
26f6 c3 04 1a			jp macro_next 
26f9				endm 
# End of macro NEXTW
26f9			.NOP: 
26f9				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
26f9 61				db WORD_SYS_CORE+77             
26fa 20 27			dw .COMO            
26fc 04				db 3 + 1 
26fd .. 00			db "NOP",0              
2701				endm 
# End of macro CWHEAD
2701			; | NOP (  --  ) Do nothing | DONE 
2701					if DEBUG_FORTH_WORDS_KEY 
2701						DMARK "NOP" 
2701 f5				push af  
2702 3a 16 27			ld a, (.dmark)  
2705 32 7a ee			ld (debug_mark),a  
2708 3a 17 27			ld a, (.dmark+1)  
270b 32 7b ee			ld (debug_mark+1),a  
270e 3a 18 27			ld a, (.dmark+2)  
2711 32 7c ee			ld (debug_mark+2),a  
2714 18 03			jr .pastdmark  
2716 ..			.dmark: db "NOP"  
2719 f1			.pastdmark: pop af  
271a			endm  
# End of macro DMARK
271a						CALLMONITOR 
271a cd 86 12			call break_point_state  
271d				endm  
# End of macro CALLMONITOR
271d					endif 
271d				       NEXTW 
271d c3 04 1a			jp macro_next 
2720				endm 
# End of macro NEXTW
2720			.COMO: 
2720				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2720 6e				db WORD_SYS_CORE+90             
2721 72 27			dw .COMC            
2723 02				db 1 + 1 
2724 .. 00			db "(",0              
2726				endm 
# End of macro CWHEAD
2726			; | ( ( -- )  Start of comment | DONE 
2726			 
2726			 
2726 2a 76 e6				ld hl, ( os_tok_ptr) 
2729 11 6d 27			ld de, .closepar 
272c					 
272c					if DEBUG_FORTH_WORDS 
272c						DMARK ").." 
272c f5				push af  
272d 3a 41 27			ld a, (.dmark)  
2730 32 7a ee			ld (debug_mark),a  
2733 3a 42 27			ld a, (.dmark+1)  
2736 32 7b ee			ld (debug_mark+1),a  
2739 3a 43 27			ld a, (.dmark+2)  
273c 32 7c ee			ld (debug_mark+2),a  
273f 18 03			jr .pastdmark  
2741 ..			.dmark: db ").."  
2744 f1			.pastdmark: pop af  
2745			endm  
# End of macro DMARK
2745						CALLMONITOR 
2745 cd 86 12			call break_point_state  
2748				endm  
# End of macro CALLMONITOR
2748					endif 
2748 cd 1f 1b			call findnexttok  
274b			 
274b					if DEBUG_FORTH_WORDS 
274b						DMARK "IF5" 
274b f5				push af  
274c 3a 60 27			ld a, (.dmark)  
274f 32 7a ee			ld (debug_mark),a  
2752 3a 61 27			ld a, (.dmark+1)  
2755 32 7b ee			ld (debug_mark+1),a  
2758 3a 62 27			ld a, (.dmark+2)  
275b 32 7c ee			ld (debug_mark+2),a  
275e 18 03			jr .pastdmark  
2760 ..			.dmark: db "IF5"  
2763 f1			.pastdmark: pop af  
2764			endm  
# End of macro DMARK
2764						CALLMONITOR 
2764 cd 86 12			call break_point_state  
2767				endm  
# End of macro CALLMONITOR
2767					endif 
2767				; replace below with ) exec using tok_ptr 
2767 22 76 e6			ld (os_tok_ptr), hl 
276a c3 95 1a			jp exec1 
276d			 
276d .. 00			.closepar:   db ")",0 
276f			 
276f				       NEXTW 
276f c3 04 1a			jp macro_next 
2772				endm 
# End of macro NEXTW
2772			.COMC: 
2772				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2772 6f				db WORD_SYS_CORE+91             
2773 7b 27			dw .SCRATCH            
2775 02				db 1 + 1 
2776 .. 00			db ")",0              
2778				endm 
# End of macro CWHEAD
2778			; | ) ( -- )  End of comment |  DONE  
2778				       NEXTW 
2778 c3 04 1a			jp macro_next 
277b				endm 
# End of macro NEXTW
277b			 
277b			.SCRATCH: 
277b				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
277b 6f				db WORD_SYS_CORE+91             
277c b6 27			dw .INC            
277e 08				db 7 + 1 
277f .. 00			db "SCRATCH",0              
2787				endm 
# End of macro CWHEAD
2787			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2787			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2787			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2787			; | |  
2787			; | | e.g.    : score $00 scratch ; 
2787			; | |  
2787			; | | $00 score ! 
2787			; | | $01 score +! 
2787			; | |  
2787			; | | e.g.   : varword $0a scratch ;  
2787			; | | 
2787			; | | $8000 varword ! 
2787					if DEBUG_FORTH_WORDS_KEY 
2787						DMARK "SCR" 
2787 f5				push af  
2788 3a 9c 27			ld a, (.dmark)  
278b 32 7a ee			ld (debug_mark),a  
278e 3a 9d 27			ld a, (.dmark+1)  
2791 32 7b ee			ld (debug_mark+1),a  
2794 3a 9e 27			ld a, (.dmark+2)  
2797 32 7c ee			ld (debug_mark+2),a  
279a 18 03			jr .pastdmark  
279c ..			.dmark: db "SCR"  
279f f1			.pastdmark: pop af  
27a0			endm  
# End of macro DMARK
27a0						CALLMONITOR 
27a0 cd 86 12			call break_point_state  
27a3				endm  
# End of macro CALLMONITOR
27a3					endif 
27a3			 
27a3					FORTH_DSP_VALUEHL 
27a3 cd ae 18			call macro_dsp_valuehl 
27a6				endm 
# End of macro FORTH_DSP_VALUEHL
27a6				 
27a6					FORTH_DSP_POP 
27a6 cd 4a 19			call macro_forth_dsp_pop 
27a9				endm 
# End of macro FORTH_DSP_POP
27a9			 
27a9 7d					ld a, l 
27aa 21 9a e8				ld hl, os_var_array 
27ad cd c2 0a				call addatohl 
27b0			 
27b0 cd 13 18				call forth_push_numhl 
27b3			 
27b3				       NEXTW 
27b3 c3 04 1a			jp macro_next 
27b6				endm 
# End of macro NEXTW
27b6			 
27b6			.INC: 
27b6				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
27b6 6f				db WORD_SYS_CORE+91             
27b7 0a 28			dw .DEC            
27b9 03				db 2 + 1 
27ba .. 00			db "+!",0              
27bd				endm 
# End of macro CWHEAD
27bd			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
27bd					if DEBUG_FORTH_WORDS_KEY 
27bd						DMARK "+s_" 
27bd f5				push af  
27be 3a d2 27			ld a, (.dmark)  
27c1 32 7a ee			ld (debug_mark),a  
27c4 3a d3 27			ld a, (.dmark+1)  
27c7 32 7b ee			ld (debug_mark+1),a  
27ca 3a d4 27			ld a, (.dmark+2)  
27cd 32 7c ee			ld (debug_mark+2),a  
27d0 18 03			jr .pastdmark  
27d2 ..			.dmark: db "+s_"  
27d5 f1			.pastdmark: pop af  
27d6			endm  
# End of macro DMARK
27d6						CALLMONITOR 
27d6 cd 86 12			call break_point_state  
27d9				endm  
# End of macro CALLMONITOR
27d9					endif 
27d9			 
27d9					FORTH_DSP_VALUEHL 
27d9 cd ae 18			call macro_dsp_valuehl 
27dc				endm 
# End of macro FORTH_DSP_VALUEHL
27dc			 
27dc e5					push hl   ; save address 
27dd			 
27dd					FORTH_DSP_POP 
27dd cd 4a 19			call macro_forth_dsp_pop 
27e0				endm 
# End of macro FORTH_DSP_POP
27e0			 
27e0					FORTH_DSP_VALUEHL 
27e0 cd ae 18			call macro_dsp_valuehl 
27e3				endm 
# End of macro FORTH_DSP_VALUEHL
27e3			 
27e3					FORTH_DSP_POP 
27e3 cd 4a 19			call macro_forth_dsp_pop 
27e6				endm 
# End of macro FORTH_DSP_POP
27e6			 
27e6					; hl contains value to add to byte at a 
27e6				 
27e6 eb					ex de, hl 
27e7			 
27e7 e1					pop hl 
27e8			 
27e8					if DEBUG_FORTH_WORDS 
27e8						DMARK "INC" 
27e8 f5				push af  
27e9 3a fd 27			ld a, (.dmark)  
27ec 32 7a ee			ld (debug_mark),a  
27ef 3a fe 27			ld a, (.dmark+1)  
27f2 32 7b ee			ld (debug_mark+1),a  
27f5 3a ff 27			ld a, (.dmark+2)  
27f8 32 7c ee			ld (debug_mark+2),a  
27fb 18 03			jr .pastdmark  
27fd ..			.dmark: db "INC"  
2800 f1			.pastdmark: pop af  
2801			endm  
# End of macro DMARK
2801						CALLMONITOR 
2801 cd 86 12			call break_point_state  
2804				endm  
# End of macro CALLMONITOR
2804					endif 
2804			 
2804 7e					ld a,(hl) 
2805 83					add e 
2806 77					ld (hl),a 
2807			 
2807			 
2807			 
2807				       NEXTW 
2807 c3 04 1a			jp macro_next 
280a				endm 
# End of macro NEXTW
280a			 
280a			.DEC: 
280a				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
280a 6f				db WORD_SYS_CORE+91             
280b 5b 28			dw .INC2            
280d 03				db 2 + 1 
280e .. 00			db "-!",0              
2811				endm 
# End of macro CWHEAD
2811			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2811					if DEBUG_FORTH_WORDS_KEY 
2811						DMARK "-s_" 
2811 f5				push af  
2812 3a 26 28			ld a, (.dmark)  
2815 32 7a ee			ld (debug_mark),a  
2818 3a 27 28			ld a, (.dmark+1)  
281b 32 7b ee			ld (debug_mark+1),a  
281e 3a 28 28			ld a, (.dmark+2)  
2821 32 7c ee			ld (debug_mark+2),a  
2824 18 03			jr .pastdmark  
2826 ..			.dmark: db "-s_"  
2829 f1			.pastdmark: pop af  
282a			endm  
# End of macro DMARK
282a						CALLMONITOR 
282a cd 86 12			call break_point_state  
282d				endm  
# End of macro CALLMONITOR
282d					endif 
282d			 
282d					FORTH_DSP_VALUEHL 
282d cd ae 18			call macro_dsp_valuehl 
2830				endm 
# End of macro FORTH_DSP_VALUEHL
2830			 
2830 e5					push hl   ; save address 
2831			 
2831					FORTH_DSP_POP 
2831 cd 4a 19			call macro_forth_dsp_pop 
2834				endm 
# End of macro FORTH_DSP_POP
2834			 
2834					FORTH_DSP_VALUEHL 
2834 cd ae 18			call macro_dsp_valuehl 
2837				endm 
# End of macro FORTH_DSP_VALUEHL
2837			 
2837					; hl contains value to add to byte at a 
2837				 
2837 eb					ex de, hl 
2838			 
2838 e1					pop hl 
2839			 
2839					if DEBUG_FORTH_WORDS 
2839						DMARK "DEC" 
2839 f5				push af  
283a 3a 4e 28			ld a, (.dmark)  
283d 32 7a ee			ld (debug_mark),a  
2840 3a 4f 28			ld a, (.dmark+1)  
2843 32 7b ee			ld (debug_mark+1),a  
2846 3a 50 28			ld a, (.dmark+2)  
2849 32 7c ee			ld (debug_mark+2),a  
284c 18 03			jr .pastdmark  
284e ..			.dmark: db "DEC"  
2851 f1			.pastdmark: pop af  
2852			endm  
# End of macro DMARK
2852						CALLMONITOR 
2852 cd 86 12			call break_point_state  
2855				endm  
# End of macro CALLMONITOR
2855					endif 
2855			 
2855 7e					ld a,(hl) 
2856 93					sub e 
2857 77					ld (hl),a 
2858			 
2858			 
2858			 
2858				       NEXTW 
2858 c3 04 1a			jp macro_next 
285b				endm 
# End of macro NEXTW
285b			 
285b			.INC2: 
285b				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
285b 6f				db WORD_SYS_CORE+91             
285c 05 29			dw .DEC2            
285e 04				db 3 + 1 
285f .. 00			db "+2!",0              
2863				endm 
# End of macro CWHEAD
2863			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2863			 
2863					if DEBUG_FORTH_WORDS_KEY 
2863						DMARK "+2s" 
2863 f5				push af  
2864 3a 78 28			ld a, (.dmark)  
2867 32 7a ee			ld (debug_mark),a  
286a 3a 79 28			ld a, (.dmark+1)  
286d 32 7b ee			ld (debug_mark+1),a  
2870 3a 7a 28			ld a, (.dmark+2)  
2873 32 7c ee			ld (debug_mark+2),a  
2876 18 03			jr .pastdmark  
2878 ..			.dmark: db "+2s"  
287b f1			.pastdmark: pop af  
287c			endm  
# End of macro DMARK
287c						CALLMONITOR 
287c cd 86 12			call break_point_state  
287f				endm  
# End of macro CALLMONITOR
287f					endif 
287f			 
287f					; Address 
287f			 
287f					FORTH_DSP_VALUEHL 
287f cd ae 18			call macro_dsp_valuehl 
2882				endm 
# End of macro FORTH_DSP_VALUEHL
2882			 
2882 e5					push hl    ; save address 
2883			 
2883					; load content into de 
2883			 
2883 5e					ld e,(hl) 
2884 23					inc hl 
2885 56					ld d, (hl) 
2886			 
2886					if DEBUG_FORTH_WORDS 
2886						DMARK "+2a" 
2886 f5				push af  
2887 3a 9b 28			ld a, (.dmark)  
288a 32 7a ee			ld (debug_mark),a  
288d 3a 9c 28			ld a, (.dmark+1)  
2890 32 7b ee			ld (debug_mark+1),a  
2893 3a 9d 28			ld a, (.dmark+2)  
2896 32 7c ee			ld (debug_mark+2),a  
2899 18 03			jr .pastdmark  
289b ..			.dmark: db "+2a"  
289e f1			.pastdmark: pop af  
289f			endm  
# End of macro DMARK
289f						CALLMONITOR 
289f cd 86 12			call break_point_state  
28a2				endm  
# End of macro CALLMONITOR
28a2					endif 
28a2			 
28a2					FORTH_DSP_POP 
28a2 cd 4a 19			call macro_forth_dsp_pop 
28a5				endm 
# End of macro FORTH_DSP_POP
28a5			 
28a5					; Get value to add 
28a5			 
28a5					FORTH_DSP_VALUE 
28a5 cd 97 18			call macro_forth_dsp_value 
28a8				endm 
# End of macro FORTH_DSP_VALUE
28a8			 
28a8					if DEBUG_FORTH_WORDS 
28a8						DMARK "+2v" 
28a8 f5				push af  
28a9 3a bd 28			ld a, (.dmark)  
28ac 32 7a ee			ld (debug_mark),a  
28af 3a be 28			ld a, (.dmark+1)  
28b2 32 7b ee			ld (debug_mark+1),a  
28b5 3a bf 28			ld a, (.dmark+2)  
28b8 32 7c ee			ld (debug_mark+2),a  
28bb 18 03			jr .pastdmark  
28bd ..			.dmark: db "+2v"  
28c0 f1			.pastdmark: pop af  
28c1			endm  
# End of macro DMARK
28c1						CALLMONITOR 
28c1 cd 86 12			call break_point_state  
28c4				endm  
# End of macro CALLMONITOR
28c4					endif 
28c4			 
28c4 19					add hl, de 
28c5			 
28c5					if DEBUG_FORTH_WORDS 
28c5						DMARK "+2+" 
28c5 f5				push af  
28c6 3a da 28			ld a, (.dmark)  
28c9 32 7a ee			ld (debug_mark),a  
28cc 3a db 28			ld a, (.dmark+1)  
28cf 32 7b ee			ld (debug_mark+1),a  
28d2 3a dc 28			ld a, (.dmark+2)  
28d5 32 7c ee			ld (debug_mark+2),a  
28d8 18 03			jr .pastdmark  
28da ..			.dmark: db "+2+"  
28dd f1			.pastdmark: pop af  
28de			endm  
# End of macro DMARK
28de						CALLMONITOR 
28de cd 86 12			call break_point_state  
28e1				endm  
# End of macro CALLMONITOR
28e1					endif 
28e1			 
28e1					; move result to de 
28e1			 
28e1 eb					ex de, hl 
28e2			 
28e2					; Address 
28e2			 
28e2 e1					pop hl 
28e3			 
28e3					; save it back 
28e3			 
28e3 73					ld (hl), e 
28e4 23					inc hl 
28e5 72					ld (hl), d 
28e6			 
28e6					if DEBUG_FORTH_WORDS 
28e6						DMARK "+2e" 
28e6 f5				push af  
28e7 3a fb 28			ld a, (.dmark)  
28ea 32 7a ee			ld (debug_mark),a  
28ed 3a fc 28			ld a, (.dmark+1)  
28f0 32 7b ee			ld (debug_mark+1),a  
28f3 3a fd 28			ld a, (.dmark+2)  
28f6 32 7c ee			ld (debug_mark+2),a  
28f9 18 03			jr .pastdmark  
28fb ..			.dmark: db "+2e"  
28fe f1			.pastdmark: pop af  
28ff			endm  
# End of macro DMARK
28ff						CALLMONITOR 
28ff cd 86 12			call break_point_state  
2902				endm  
# End of macro CALLMONITOR
2902					endif 
2902			 
2902			 
2902			 
2902			 
2902			 
2902				       NEXTW 
2902 c3 04 1a			jp macro_next 
2905				endm 
# End of macro NEXTW
2905			 
2905			.DEC2: 
2905				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2905 6f				db WORD_SYS_CORE+91             
2906 b1 29			dw .GET2            
2908 04				db 3 + 1 
2909 .. 00			db "-2!",0              
290d				endm 
# End of macro CWHEAD
290d			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
290d			 
290d			 
290d					if DEBUG_FORTH_WORDS_KEY 
290d						DMARK "-2s" 
290d f5				push af  
290e 3a 22 29			ld a, (.dmark)  
2911 32 7a ee			ld (debug_mark),a  
2914 3a 23 29			ld a, (.dmark+1)  
2917 32 7b ee			ld (debug_mark+1),a  
291a 3a 24 29			ld a, (.dmark+2)  
291d 32 7c ee			ld (debug_mark+2),a  
2920 18 03			jr .pastdmark  
2922 ..			.dmark: db "-2s"  
2925 f1			.pastdmark: pop af  
2926			endm  
# End of macro DMARK
2926						CALLMONITOR 
2926 cd 86 12			call break_point_state  
2929				endm  
# End of macro CALLMONITOR
2929					endif 
2929			 
2929					; Address 
2929			 
2929					FORTH_DSP_VALUEHL 
2929 cd ae 18			call macro_dsp_valuehl 
292c				endm 
# End of macro FORTH_DSP_VALUEHL
292c			 
292c e5					push hl    ; save address 
292d			 
292d					; load content into de 
292d			 
292d 5e					ld e,(hl) 
292e 23					inc hl 
292f 56					ld d, (hl) 
2930			 
2930					if DEBUG_FORTH_WORDS 
2930						DMARK "-2a" 
2930 f5				push af  
2931 3a 45 29			ld a, (.dmark)  
2934 32 7a ee			ld (debug_mark),a  
2937 3a 46 29			ld a, (.dmark+1)  
293a 32 7b ee			ld (debug_mark+1),a  
293d 3a 47 29			ld a, (.dmark+2)  
2940 32 7c ee			ld (debug_mark+2),a  
2943 18 03			jr .pastdmark  
2945 ..			.dmark: db "-2a"  
2948 f1			.pastdmark: pop af  
2949			endm  
# End of macro DMARK
2949						CALLMONITOR 
2949 cd 86 12			call break_point_state  
294c				endm  
# End of macro CALLMONITOR
294c					endif 
294c			 
294c					FORTH_DSP_POP 
294c cd 4a 19			call macro_forth_dsp_pop 
294f				endm 
# End of macro FORTH_DSP_POP
294f			 
294f					; Get value to remove 
294f			 
294f					FORTH_DSP_VALUE 
294f cd 97 18			call macro_forth_dsp_value 
2952				endm 
# End of macro FORTH_DSP_VALUE
2952			 
2952					if DEBUG_FORTH_WORDS 
2952						DMARK "-2v" 
2952 f5				push af  
2953 3a 67 29			ld a, (.dmark)  
2956 32 7a ee			ld (debug_mark),a  
2959 3a 68 29			ld a, (.dmark+1)  
295c 32 7b ee			ld (debug_mark+1),a  
295f 3a 69 29			ld a, (.dmark+2)  
2962 32 7c ee			ld (debug_mark+2),a  
2965 18 03			jr .pastdmark  
2967 ..			.dmark: db "-2v"  
296a f1			.pastdmark: pop af  
296b			endm  
# End of macro DMARK
296b						CALLMONITOR 
296b cd 86 12			call break_point_state  
296e				endm  
# End of macro CALLMONITOR
296e					endif 
296e			 
296e eb					ex de, hl 
296f ed 52				sbc hl, de 
2971			 
2971					if DEBUG_FORTH_WORDS 
2971						DMARK "-2d" 
2971 f5				push af  
2972 3a 86 29			ld a, (.dmark)  
2975 32 7a ee			ld (debug_mark),a  
2978 3a 87 29			ld a, (.dmark+1)  
297b 32 7b ee			ld (debug_mark+1),a  
297e 3a 88 29			ld a, (.dmark+2)  
2981 32 7c ee			ld (debug_mark+2),a  
2984 18 03			jr .pastdmark  
2986 ..			.dmark: db "-2d"  
2989 f1			.pastdmark: pop af  
298a			endm  
# End of macro DMARK
298a						CALLMONITOR 
298a cd 86 12			call break_point_state  
298d				endm  
# End of macro CALLMONITOR
298d					endif 
298d			 
298d					; move result to de 
298d			 
298d eb					ex de, hl 
298e			 
298e					; Address 
298e			 
298e e1					pop hl 
298f			 
298f					; save it back 
298f			 
298f 73					ld (hl), e 
2990 23					inc hl 
2991 72					ld (hl), d 
2992			 
2992					if DEBUG_FORTH_WORDS 
2992						DMARK "-2e" 
2992 f5				push af  
2993 3a a7 29			ld a, (.dmark)  
2996 32 7a ee			ld (debug_mark),a  
2999 3a a8 29			ld a, (.dmark+1)  
299c 32 7b ee			ld (debug_mark+1),a  
299f 3a a9 29			ld a, (.dmark+2)  
29a2 32 7c ee			ld (debug_mark+2),a  
29a5 18 03			jr .pastdmark  
29a7 ..			.dmark: db "-2e"  
29aa f1			.pastdmark: pop af  
29ab			endm  
# End of macro DMARK
29ab						CALLMONITOR 
29ab cd 86 12			call break_point_state  
29ae				endm  
# End of macro CALLMONITOR
29ae					endif 
29ae			 
29ae			 
29ae			 
29ae			 
29ae			 
29ae				       NEXTW 
29ae c3 04 1a			jp macro_next 
29b1				endm 
# End of macro NEXTW
29b1			.GET2: 
29b1				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
29b1 6f				db WORD_SYS_CORE+91             
29b2 e1 29			dw .BANG2            
29b4 03				db 2 + 1 
29b5 .. 00			db "2@",0              
29b8				endm 
# End of macro CWHEAD
29b8			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
29b8					if DEBUG_FORTH_WORDS_KEY 
29b8						DMARK "2A_" 
29b8 f5				push af  
29b9 3a cd 29			ld a, (.dmark)  
29bc 32 7a ee			ld (debug_mark),a  
29bf 3a ce 29			ld a, (.dmark+1)  
29c2 32 7b ee			ld (debug_mark+1),a  
29c5 3a cf 29			ld a, (.dmark+2)  
29c8 32 7c ee			ld (debug_mark+2),a  
29cb 18 03			jr .pastdmark  
29cd ..			.dmark: db "2A_"  
29d0 f1			.pastdmark: pop af  
29d1			endm  
# End of macro DMARK
29d1						CALLMONITOR 
29d1 cd 86 12			call break_point_state  
29d4				endm  
# End of macro CALLMONITOR
29d4					endif 
29d4			 
29d4					FORTH_DSP_VALUEHL 
29d4 cd ae 18			call macro_dsp_valuehl 
29d7				endm 
# End of macro FORTH_DSP_VALUEHL
29d7			 
29d7 5e					ld e, (hl) 
29d8 23					inc hl 
29d9 56					ld d, (hl) 
29da			 
29da eb					ex de, hl 
29db			 
29db cd 13 18				call forth_push_numhl 
29de			 
29de				       NEXTW 
29de c3 04 1a			jp macro_next 
29e1				endm 
# End of macro NEXTW
29e1			.BANG2: 
29e1				CWHEAD .ENDCORE 91 "2!" 2 WORD_FLAG_CODE 
29e1 6f				db WORD_SYS_CORE+91             
29e2 19 2a			dw .ENDCORE            
29e4 03				db 2 + 1 
29e5 .. 00			db "2!",0              
29e8				endm 
# End of macro CWHEAD
29e8			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
29e8					if DEBUG_FORTH_WORDS_KEY 
29e8						DMARK "2S_" 
29e8 f5				push af  
29e9 3a fd 29			ld a, (.dmark)  
29ec 32 7a ee			ld (debug_mark),a  
29ef 3a fe 29			ld a, (.dmark+1)  
29f2 32 7b ee			ld (debug_mark+1),a  
29f5 3a ff 29			ld a, (.dmark+2)  
29f8 32 7c ee			ld (debug_mark+2),a  
29fb 18 03			jr .pastdmark  
29fd ..			.dmark: db "2S_"  
2a00 f1			.pastdmark: pop af  
2a01			endm  
# End of macro DMARK
2a01						CALLMONITOR 
2a01 cd 86 12			call break_point_state  
2a04				endm  
# End of macro CALLMONITOR
2a04					endif 
2a04			 
2a04					FORTH_DSP_VALUEHL 
2a04 cd ae 18			call macro_dsp_valuehl 
2a07				endm 
# End of macro FORTH_DSP_VALUEHL
2a07			 
2a07 e5					push hl   ; save address 
2a08			 
2a08			 
2a08					FORTH_DSP_POP 
2a08 cd 4a 19			call macro_forth_dsp_pop 
2a0b				endm 
# End of macro FORTH_DSP_POP
2a0b			 
2a0b					 
2a0b					FORTH_DSP_VALUEHL 
2a0b cd ae 18			call macro_dsp_valuehl 
2a0e				endm 
# End of macro FORTH_DSP_VALUEHL
2a0e			 
2a0e					FORTH_DSP_POP 
2a0e cd 4a 19			call macro_forth_dsp_pop 
2a11				endm 
# End of macro FORTH_DSP_POP
2a11			 
2a11 eb					ex de, hl    ; value now in de 
2a12			 
2a12 e1					pop hl 
2a13			 
2a13 73					ld (hl), e 
2a14			 
2a14 23					inc hl 
2a15			 
2a15 72					ld (hl), d 
2a16			 
2a16			 
2a16				       NEXTW 
2a16 c3 04 1a			jp macro_next 
2a19				endm 
# End of macro NEXTW
2a19			.ENDCORE: 
2a19			 
2a19			; eof 
2a19			 
2a19			 
# End of file forth_words_core.asm
2a19			include "forth_words_flow.asm" 
2a19			 
2a19			; | ## Program Flow Words 
2a19			 
2a19			.IF: 
2a19				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2a19 1e				db WORD_SYS_CORE+10             
2a1a 0e 2b			dw .THEN            
2a1c 03				db 2 + 1 
2a1d .. 00			db "IF",0              
2a20				endm 
# End of macro CWHEAD
2a20			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2a20			; 
2a20					if DEBUG_FORTH_WORDS_KEY 
2a20						DMARK "IF." 
2a20 f5				push af  
2a21 3a 35 2a			ld a, (.dmark)  
2a24 32 7a ee			ld (debug_mark),a  
2a27 3a 36 2a			ld a, (.dmark+1)  
2a2a 32 7b ee			ld (debug_mark+1),a  
2a2d 3a 37 2a			ld a, (.dmark+2)  
2a30 32 7c ee			ld (debug_mark+2),a  
2a33 18 03			jr .pastdmark  
2a35 ..			.dmark: db "IF."  
2a38 f1			.pastdmark: pop af  
2a39			endm  
# End of macro DMARK
2a39						CALLMONITOR 
2a39 cd 86 12			call break_point_state  
2a3c				endm  
# End of macro CALLMONITOR
2a3c					endif 
2a3c			; eval TOS 
2a3c			 
2a3c				FORTH_DSP_VALUEHL 
2a3c cd ae 18			call macro_dsp_valuehl 
2a3f				endm 
# End of macro FORTH_DSP_VALUEHL
2a3f			 
2a3f			;	push hl 
2a3f				FORTH_DSP_POP 
2a3f cd 4a 19			call macro_forth_dsp_pop 
2a42				endm 
# End of macro FORTH_DSP_POP
2a42			;	pop hl 
2a42			 
2a42					if DEBUG_FORTH_WORDS 
2a42						DMARK "IF1" 
2a42 f5				push af  
2a43 3a 57 2a			ld a, (.dmark)  
2a46 32 7a ee			ld (debug_mark),a  
2a49 3a 58 2a			ld a, (.dmark+1)  
2a4c 32 7b ee			ld (debug_mark+1),a  
2a4f 3a 59 2a			ld a, (.dmark+2)  
2a52 32 7c ee			ld (debug_mark+2),a  
2a55 18 03			jr .pastdmark  
2a57 ..			.dmark: db "IF1"  
2a5a f1			.pastdmark: pop af  
2a5b			endm  
# End of macro DMARK
2a5b						CALLMONITOR 
2a5b cd 86 12			call break_point_state  
2a5e				endm  
# End of macro CALLMONITOR
2a5e					endif 
2a5e b7				or a        ; clear carry flag 
2a5f 11 00 00			ld de, 0 
2a62 eb				ex de,hl 
2a63 ed 52			sbc hl, de 
2a65 c2 ef 2a			jp nz, .iftrue 
2a68			 
2a68					if DEBUG_FORTH_WORDS 
2a68						DMARK "IF2" 
2a68 f5				push af  
2a69 3a 7d 2a			ld a, (.dmark)  
2a6c 32 7a ee			ld (debug_mark),a  
2a6f 3a 7e 2a			ld a, (.dmark+1)  
2a72 32 7b ee			ld (debug_mark+1),a  
2a75 3a 7f 2a			ld a, (.dmark+2)  
2a78 32 7c ee			ld (debug_mark+2),a  
2a7b 18 03			jr .pastdmark  
2a7d ..			.dmark: db "IF2"  
2a80 f1			.pastdmark: pop af  
2a81			endm  
# End of macro DMARK
2a81						CALLMONITOR 
2a81 cd 86 12			call break_point_state  
2a84				endm  
# End of macro CALLMONITOR
2a84					endif 
2a84			 
2a84			; if not true then skip to THEN 
2a84			 
2a84				; TODO get tok_ptr 
2a84				; TODO consume toks until we get to THEN 
2a84			 
2a84 2a 76 e6			ld hl, (os_tok_ptr) 
2a87					if DEBUG_FORTH_WORDS 
2a87						DMARK "IF3" 
2a87 f5				push af  
2a88 3a 9c 2a			ld a, (.dmark)  
2a8b 32 7a ee			ld (debug_mark),a  
2a8e 3a 9d 2a			ld a, (.dmark+1)  
2a91 32 7b ee			ld (debug_mark+1),a  
2a94 3a 9e 2a			ld a, (.dmark+2)  
2a97 32 7c ee			ld (debug_mark+2),a  
2a9a 18 03			jr .pastdmark  
2a9c ..			.dmark: db "IF3"  
2a9f f1			.pastdmark: pop af  
2aa0			endm  
# End of macro DMARK
2aa0						CALLMONITOR 
2aa0 cd 86 12			call break_point_state  
2aa3				endm  
# End of macro CALLMONITOR
2aa3						 
2aa3					endif 
2aa3 11 ea 2a			ld de, .ifthen 
2aa6					if DEBUG_FORTH_WORDS 
2aa6						DMARK "IF4" 
2aa6 f5				push af  
2aa7 3a bb 2a			ld a, (.dmark)  
2aaa 32 7a ee			ld (debug_mark),a  
2aad 3a bc 2a			ld a, (.dmark+1)  
2ab0 32 7b ee			ld (debug_mark+1),a  
2ab3 3a bd 2a			ld a, (.dmark+2)  
2ab6 32 7c ee			ld (debug_mark+2),a  
2ab9 18 03			jr .pastdmark  
2abb ..			.dmark: db "IF4"  
2abe f1			.pastdmark: pop af  
2abf			endm  
# End of macro DMARK
2abf						CALLMONITOR 
2abf cd 86 12			call break_point_state  
2ac2				endm  
# End of macro CALLMONITOR
2ac2					endif 
2ac2 cd 1f 1b			call findnexttok  
2ac5			 
2ac5					if DEBUG_FORTH_WORDS 
2ac5						DMARK "IF5" 
2ac5 f5				push af  
2ac6 3a da 2a			ld a, (.dmark)  
2ac9 32 7a ee			ld (debug_mark),a  
2acc 3a db 2a			ld a, (.dmark+1)  
2acf 32 7b ee			ld (debug_mark+1),a  
2ad2 3a dc 2a			ld a, (.dmark+2)  
2ad5 32 7c ee			ld (debug_mark+2),a  
2ad8 18 03			jr .pastdmark  
2ada ..			.dmark: db "IF5"  
2add f1			.pastdmark: pop af  
2ade			endm  
# End of macro DMARK
2ade						CALLMONITOR 
2ade cd 86 12			call break_point_state  
2ae1				endm  
# End of macro CALLMONITOR
2ae1					endif 
2ae1				; TODO replace below with ; exec using tok_ptr 
2ae1 22 76 e6			ld (os_tok_ptr), hl 
2ae4 c3 95 1a			jp exec1 
2ae7				NEXTW 
2ae7 c3 04 1a			jp macro_next 
2aea				endm 
# End of macro NEXTW
2aea			 
2aea .. 00		.ifthen:  db "THEN",0 
2aef			 
2aef			.iftrue:		 
2aef				; Exec next words normally 
2aef			 
2aef				; if true then exec following IF as normal 
2aef					if DEBUG_FORTH_WORDS 
2aef						DMARK "IFT" 
2aef f5				push af  
2af0 3a 04 2b			ld a, (.dmark)  
2af3 32 7a ee			ld (debug_mark),a  
2af6 3a 05 2b			ld a, (.dmark+1)  
2af9 32 7b ee			ld (debug_mark+1),a  
2afc 3a 06 2b			ld a, (.dmark+2)  
2aff 32 7c ee			ld (debug_mark+2),a  
2b02 18 03			jr .pastdmark  
2b04 ..			.dmark: db "IFT"  
2b07 f1			.pastdmark: pop af  
2b08			endm  
# End of macro DMARK
2b08						CALLMONITOR 
2b08 cd 86 12			call break_point_state  
2b0b				endm  
# End of macro CALLMONITOR
2b0b					endif 
2b0b			 
2b0b					NEXTW 
2b0b c3 04 1a			jp macro_next 
2b0e				endm 
# End of macro NEXTW
2b0e			.THEN: 
2b0e				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2b0e 1f				db WORD_SYS_CORE+11             
2b0f 36 2b			dw .ELSE            
2b11 05				db 4 + 1 
2b12 .. 00			db "THEN",0              
2b17				endm 
# End of macro CWHEAD
2b17			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2b17					if DEBUG_FORTH_WORDS_KEY 
2b17						DMARK "THN" 
2b17 f5				push af  
2b18 3a 2c 2b			ld a, (.dmark)  
2b1b 32 7a ee			ld (debug_mark),a  
2b1e 3a 2d 2b			ld a, (.dmark+1)  
2b21 32 7b ee			ld (debug_mark+1),a  
2b24 3a 2e 2b			ld a, (.dmark+2)  
2b27 32 7c ee			ld (debug_mark+2),a  
2b2a 18 03			jr .pastdmark  
2b2c ..			.dmark: db "THN"  
2b2f f1			.pastdmark: pop af  
2b30			endm  
# End of macro DMARK
2b30						CALLMONITOR 
2b30 cd 86 12			call break_point_state  
2b33				endm  
# End of macro CALLMONITOR
2b33					endif 
2b33					NEXTW 
2b33 c3 04 1a			jp macro_next 
2b36				endm 
# End of macro NEXTW
2b36			.ELSE: 
2b36				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2b36 20				db WORD_SYS_CORE+12             
2b37 5e 2b			dw .DO            
2b39 03				db 2 + 1 
2b3a .. 00			db "ELSE",0              
2b3f				endm 
# End of macro CWHEAD
2b3f			; | ELSE ( -- ) Not supported - does nothing | TODO 
2b3f			 
2b3f					if DEBUG_FORTH_WORDS_KEY 
2b3f						DMARK "ELS" 
2b3f f5				push af  
2b40 3a 54 2b			ld a, (.dmark)  
2b43 32 7a ee			ld (debug_mark),a  
2b46 3a 55 2b			ld a, (.dmark+1)  
2b49 32 7b ee			ld (debug_mark+1),a  
2b4c 3a 56 2b			ld a, (.dmark+2)  
2b4f 32 7c ee			ld (debug_mark+2),a  
2b52 18 03			jr .pastdmark  
2b54 ..			.dmark: db "ELS"  
2b57 f1			.pastdmark: pop af  
2b58			endm  
# End of macro DMARK
2b58						CALLMONITOR 
2b58 cd 86 12			call break_point_state  
2b5b				endm  
# End of macro CALLMONITOR
2b5b					endif 
2b5b			 
2b5b			 
2b5b					NEXTW 
2b5b c3 04 1a			jp macro_next 
2b5e				endm 
# End of macro NEXTW
2b5e			.DO: 
2b5e				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2b5e 21				db WORD_SYS_CORE+13             
2b5f 85 2c			dw .LOOP            
2b61 03				db 2 + 1 
2b62 .. 00			db "DO",0              
2b65				endm 
# End of macro CWHEAD
2b65			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2b65			 
2b65					if DEBUG_FORTH_WORDS_KEY 
2b65						DMARK "DO." 
2b65 f5				push af  
2b66 3a 7a 2b			ld a, (.dmark)  
2b69 32 7a ee			ld (debug_mark),a  
2b6c 3a 7b 2b			ld a, (.dmark+1)  
2b6f 32 7b ee			ld (debug_mark+1),a  
2b72 3a 7c 2b			ld a, (.dmark+2)  
2b75 32 7c ee			ld (debug_mark+2),a  
2b78 18 03			jr .pastdmark  
2b7a ..			.dmark: db "DO."  
2b7d f1			.pastdmark: pop af  
2b7e			endm  
# End of macro DMARK
2b7e						CALLMONITOR 
2b7e cd 86 12			call break_point_state  
2b81				endm  
# End of macro CALLMONITOR
2b81					endif 
2b81			;  push pc to rsp stack past the DO 
2b81			 
2b81 2a 76 e6				ld hl, (os_tok_ptr) 
2b84 23					inc hl   ; D 
2b85 23					inc hl  ; O 
2b86 23					inc hl   ; null 
2b87					if DEBUG_FORTH_WORDS 
2b87						DMARK "DO2" 
2b87 f5				push af  
2b88 3a 9c 2b			ld a, (.dmark)  
2b8b 32 7a ee			ld (debug_mark),a  
2b8e 3a 9d 2b			ld a, (.dmark+1)  
2b91 32 7b ee			ld (debug_mark+1),a  
2b94 3a 9e 2b			ld a, (.dmark+2)  
2b97 32 7c ee			ld (debug_mark+2),a  
2b9a 18 03			jr .pastdmark  
2b9c ..			.dmark: db "DO2"  
2b9f f1			.pastdmark: pop af  
2ba0			endm  
# End of macro DMARK
2ba0						CALLMONITOR 
2ba0 cd 86 12			call break_point_state  
2ba3				endm  
# End of macro CALLMONITOR
2ba3					endif 
2ba3					FORTH_RSP_NEXT 
2ba3 cd ba 17			call macro_forth_rsp_next 
2ba6				endm 
# End of macro FORTH_RSP_NEXT
2ba6					if DEBUG_FORTH_WORDS 
2ba6						DMARK "DO3" 
2ba6 f5				push af  
2ba7 3a bb 2b			ld a, (.dmark)  
2baa 32 7a ee			ld (debug_mark),a  
2bad 3a bc 2b			ld a, (.dmark+1)  
2bb0 32 7b ee			ld (debug_mark+1),a  
2bb3 3a bd 2b			ld a, (.dmark+2)  
2bb6 32 7c ee			ld (debug_mark+2),a  
2bb9 18 03			jr .pastdmark  
2bbb ..			.dmark: db "DO3"  
2bbe f1			.pastdmark: pop af  
2bbf			endm  
# End of macro DMARK
2bbf						CALLMONITOR 
2bbf cd 86 12			call break_point_state  
2bc2				endm  
# End of macro CALLMONITOR
2bc2					endif 
2bc2			 
2bc2					;if DEBUG_FORTH_WORDS 
2bc2				;		push hl 
2bc2			;		endif  
2bc2			 
2bc2			; get counters from data stack 
2bc2			 
2bc2			 
2bc2					FORTH_DSP_VALUEHL 
2bc2 cd ae 18			call macro_dsp_valuehl 
2bc5				endm 
# End of macro FORTH_DSP_VALUEHL
2bc5 e5					push hl		 ; hl now has starting counter which needs to be tos 
2bc6			 
2bc6					if DEBUG_FORTH_WORDS 
2bc6						DMARK "DO4" 
2bc6 f5				push af  
2bc7 3a db 2b			ld a, (.dmark)  
2bca 32 7a ee			ld (debug_mark),a  
2bcd 3a dc 2b			ld a, (.dmark+1)  
2bd0 32 7b ee			ld (debug_mark+1),a  
2bd3 3a dd 2b			ld a, (.dmark+2)  
2bd6 32 7c ee			ld (debug_mark+2),a  
2bd9 18 03			jr .pastdmark  
2bdb ..			.dmark: db "DO4"  
2bde f1			.pastdmark: pop af  
2bdf			endm  
# End of macro DMARK
2bdf						CALLMONITOR 
2bdf cd 86 12			call break_point_state  
2be2				endm  
# End of macro CALLMONITOR
2be2					endif 
2be2					FORTH_DSP_POP 
2be2 cd 4a 19			call macro_forth_dsp_pop 
2be5				endm 
# End of macro FORTH_DSP_POP
2be5			 
2be5					if DEBUG_FORTH_WORDS 
2be5						DMARK "DO5" 
2be5 f5				push af  
2be6 3a fa 2b			ld a, (.dmark)  
2be9 32 7a ee			ld (debug_mark),a  
2bec 3a fb 2b			ld a, (.dmark+1)  
2bef 32 7b ee			ld (debug_mark+1),a  
2bf2 3a fc 2b			ld a, (.dmark+2)  
2bf5 32 7c ee			ld (debug_mark+2),a  
2bf8 18 03			jr .pastdmark  
2bfa ..			.dmark: db "DO5"  
2bfd f1			.pastdmark: pop af  
2bfe			endm  
# End of macro DMARK
2bfe						CALLMONITOR 
2bfe cd 86 12			call break_point_state  
2c01				endm  
# End of macro CALLMONITOR
2c01					endif 
2c01			 
2c01					FORTH_DSP_VALUEHL 
2c01 cd ae 18			call macro_dsp_valuehl 
2c04				endm 
# End of macro FORTH_DSP_VALUEHL
2c04			;		push hl		 ; hl now has starting limit counter 
2c04			 
2c04					if DEBUG_FORTH_WORDS 
2c04						DMARK "DO6" 
2c04 f5				push af  
2c05 3a 19 2c			ld a, (.dmark)  
2c08 32 7a ee			ld (debug_mark),a  
2c0b 3a 1a 2c			ld a, (.dmark+1)  
2c0e 32 7b ee			ld (debug_mark+1),a  
2c11 3a 1b 2c			ld a, (.dmark+2)  
2c14 32 7c ee			ld (debug_mark+2),a  
2c17 18 03			jr .pastdmark  
2c19 ..			.dmark: db "DO6"  
2c1c f1			.pastdmark: pop af  
2c1d			endm  
# End of macro DMARK
2c1d						CALLMONITOR 
2c1d cd 86 12			call break_point_state  
2c20				endm  
# End of macro CALLMONITOR
2c20					endif 
2c20					FORTH_DSP_POP 
2c20 cd 4a 19			call macro_forth_dsp_pop 
2c23				endm 
# End of macro FORTH_DSP_POP
2c23			 
2c23			; put counters on the loop stack 
2c23			 
2c23			;		pop hl			 ; limit counter 
2c23 d1					pop de			; start counter 
2c24			 
2c24					; push limit counter 
2c24			 
2c24					if DEBUG_FORTH_WORDS 
2c24						DMARK "DO7" 
2c24 f5				push af  
2c25 3a 39 2c			ld a, (.dmark)  
2c28 32 7a ee			ld (debug_mark),a  
2c2b 3a 3a 2c			ld a, (.dmark+1)  
2c2e 32 7b ee			ld (debug_mark+1),a  
2c31 3a 3b 2c			ld a, (.dmark+2)  
2c34 32 7c ee			ld (debug_mark+2),a  
2c37 18 03			jr .pastdmark  
2c39 ..			.dmark: db "DO7"  
2c3c f1			.pastdmark: pop af  
2c3d			endm  
# End of macro DMARK
2c3d						CALLMONITOR 
2c3d cd 86 12			call break_point_state  
2c40				endm  
# End of macro CALLMONITOR
2c40					endif 
2c40					FORTH_LOOP_NEXT 
2c40 cd c3 18			call macro_forth_loop_next 
2c43				endm 
# End of macro FORTH_LOOP_NEXT
2c43			 
2c43					; push start counter 
2c43			 
2c43 eb					ex de, hl 
2c44					if DEBUG_FORTH_WORDS 
2c44						DMARK "DO7" 
2c44 f5				push af  
2c45 3a 59 2c			ld a, (.dmark)  
2c48 32 7a ee			ld (debug_mark),a  
2c4b 3a 5a 2c			ld a, (.dmark+1)  
2c4e 32 7b ee			ld (debug_mark+1),a  
2c51 3a 5b 2c			ld a, (.dmark+2)  
2c54 32 7c ee			ld (debug_mark+2),a  
2c57 18 03			jr .pastdmark  
2c59 ..			.dmark: db "DO7"  
2c5c f1			.pastdmark: pop af  
2c5d			endm  
# End of macro DMARK
2c5d						CALLMONITOR 
2c5d cd 86 12			call break_point_state  
2c60				endm  
# End of macro CALLMONITOR
2c60					endif 
2c60					FORTH_LOOP_NEXT 
2c60 cd c3 18			call macro_forth_loop_next 
2c63				endm 
# End of macro FORTH_LOOP_NEXT
2c63			 
2c63			 
2c63					; init first round of I counter 
2c63			 
2c63 22 9a e6				ld (os_current_i), hl 
2c66			 
2c66					if DEBUG_FORTH_WORDS 
2c66						DMARK "DO8" 
2c66 f5				push af  
2c67 3a 7b 2c			ld a, (.dmark)  
2c6a 32 7a ee			ld (debug_mark),a  
2c6d 3a 7c 2c			ld a, (.dmark+1)  
2c70 32 7b ee			ld (debug_mark+1),a  
2c73 3a 7d 2c			ld a, (.dmark+2)  
2c76 32 7c ee			ld (debug_mark+2),a  
2c79 18 03			jr .pastdmark  
2c7b ..			.dmark: db "DO8"  
2c7e f1			.pastdmark: pop af  
2c7f			endm  
# End of macro DMARK
2c7f						CALLMONITOR 
2c7f cd 86 12			call break_point_state  
2c82				endm  
# End of macro CALLMONITOR
2c82					endif 
2c82			 
2c82					NEXTW 
2c82 c3 04 1a			jp macro_next 
2c85				endm 
# End of macro NEXTW
2c85			.LOOP: 
2c85				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2c85 22				db WORD_SYS_CORE+14             
2c86 9d 2d			dw .I            
2c88 05				db 4 + 1 
2c89 .. 00			db "LOOP",0              
2c8e				endm 
# End of macro CWHEAD
2c8e			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2c8e			 
2c8e				; pop tos as current loop count to hl 
2c8e			 
2c8e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2c8e			 
2c8e				FORTH_LOOP_TOS 
2c8e cd f6 18			call macro_forth_loop_tos 
2c91				endm 
# End of macro FORTH_LOOP_TOS
2c91 e5				push hl 
2c92			 
2c92					if DEBUG_FORTH_WORDS_KEY 
2c92						DMARK "LOP" 
2c92 f5				push af  
2c93 3a a7 2c			ld a, (.dmark)  
2c96 32 7a ee			ld (debug_mark),a  
2c99 3a a8 2c			ld a, (.dmark+1)  
2c9c 32 7b ee			ld (debug_mark+1),a  
2c9f 3a a9 2c			ld a, (.dmark+2)  
2ca2 32 7c ee			ld (debug_mark+2),a  
2ca5 18 03			jr .pastdmark  
2ca7 ..			.dmark: db "LOP"  
2caa f1			.pastdmark: pop af  
2cab			endm  
# End of macro DMARK
2cab						CALLMONITOR 
2cab cd 86 12			call break_point_state  
2cae				endm  
# End of macro CALLMONITOR
2cae					endif 
2cae				; next item on the stack is the limit. get it 
2cae			 
2cae			 
2cae				FORTH_LOOP_POP 
2cae cd 00 19			call macro_forth_loop_pop 
2cb1				endm 
# End of macro FORTH_LOOP_POP
2cb1			 
2cb1				FORTH_LOOP_TOS 
2cb1 cd f6 18			call macro_forth_loop_tos 
2cb4				endm 
# End of macro FORTH_LOOP_TOS
2cb4			 
2cb4 d1				pop de		 ; de = i, hl = limit 
2cb5			 
2cb5					if DEBUG_FORTH_WORDS 
2cb5						DMARK "LP1" 
2cb5 f5				push af  
2cb6 3a ca 2c			ld a, (.dmark)  
2cb9 32 7a ee			ld (debug_mark),a  
2cbc 3a cb 2c			ld a, (.dmark+1)  
2cbf 32 7b ee			ld (debug_mark+1),a  
2cc2 3a cc 2c			ld a, (.dmark+2)  
2cc5 32 7c ee			ld (debug_mark+2),a  
2cc8 18 03			jr .pastdmark  
2cca ..			.dmark: db "LP1"  
2ccd f1			.pastdmark: pop af  
2cce			endm  
# End of macro DMARK
2cce						CALLMONITOR 
2cce cd 86 12			call break_point_state  
2cd1				endm  
# End of macro CALLMONITOR
2cd1					endif 
2cd1			 
2cd1				; go back to previous word 
2cd1			 
2cd1 d5				push de    ; save I for inc later 
2cd2			 
2cd2			 
2cd2				; get limit 
2cd2				;  is I at limit? 
2cd2			 
2cd2			 
2cd2					if DEBUG_FORTH_WORDS 
2cd2						DMARK "LP1" 
2cd2 f5				push af  
2cd3 3a e7 2c			ld a, (.dmark)  
2cd6 32 7a ee			ld (debug_mark),a  
2cd9 3a e8 2c			ld a, (.dmark+1)  
2cdc 32 7b ee			ld (debug_mark+1),a  
2cdf 3a e9 2c			ld a, (.dmark+2)  
2ce2 32 7c ee			ld (debug_mark+2),a  
2ce5 18 03			jr .pastdmark  
2ce7 ..			.dmark: db "LP1"  
2cea f1			.pastdmark: pop af  
2ceb			endm  
# End of macro DMARK
2ceb						CALLMONITOR 
2ceb cd 86 12			call break_point_state  
2cee				endm  
# End of macro CALLMONITOR
2cee					endif 
2cee			 
2cee ed 52			sbc hl, de 
2cf0			 
2cf0			 
2cf0				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2cf0			 
2cf0 20 26				jr nz, .loopnotdone 
2cf2			 
2cf2 e1				pop hl   ; get rid of saved I 
2cf3				FORTH_LOOP_POP     ; get rid of limit 
2cf3 cd 00 19			call macro_forth_loop_pop 
2cf6				endm 
# End of macro FORTH_LOOP_POP
2cf6			 
2cf6				FORTH_RSP_POP     ; get rid of DO ptr 
2cf6 cd db 17			call macro_forth_rsp_pop 
2cf9				endm 
# End of macro FORTH_RSP_POP
2cf9			 
2cf9			if DEBUG_FORTH_WORDS 
2cf9						DMARK "LP>" 
2cf9 f5				push af  
2cfa 3a 0e 2d			ld a, (.dmark)  
2cfd 32 7a ee			ld (debug_mark),a  
2d00 3a 0f 2d			ld a, (.dmark+1)  
2d03 32 7b ee			ld (debug_mark+1),a  
2d06 3a 10 2d			ld a, (.dmark+2)  
2d09 32 7c ee			ld (debug_mark+2),a  
2d0c 18 03			jr .pastdmark  
2d0e ..			.dmark: db "LP>"  
2d11 f1			.pastdmark: pop af  
2d12			endm  
# End of macro DMARK
2d12				CALLMONITOR 
2d12 cd 86 12			call break_point_state  
2d15				endm  
# End of macro CALLMONITOR
2d15			endif 
2d15			 
2d15					NEXTW 
2d15 c3 04 1a			jp macro_next 
2d18				endm 
# End of macro NEXTW
2d18				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2d18			 
2d18			.loopnotdone: 
2d18			 
2d18 e1				pop hl    ; get I 
2d19 23				inc hl 
2d1a			 
2d1a			   	; save new I 
2d1a			 
2d1a			 
2d1a					; set I counter 
2d1a			 
2d1a 22 9a e6				ld (os_current_i), hl 
2d1d			 
2d1d					if DEBUG_FORTH_WORDS 
2d1d						DMARK "LPN" 
2d1d f5				push af  
2d1e 3a 32 2d			ld a, (.dmark)  
2d21 32 7a ee			ld (debug_mark),a  
2d24 3a 33 2d			ld a, (.dmark+1)  
2d27 32 7b ee			ld (debug_mark+1),a  
2d2a 3a 34 2d			ld a, (.dmark+2)  
2d2d 32 7c ee			ld (debug_mark+2),a  
2d30 18 03			jr .pastdmark  
2d32 ..			.dmark: db "LPN"  
2d35 f1			.pastdmark: pop af  
2d36			endm  
# End of macro DMARK
2d36					CALLMONITOR 
2d36 cd 86 12			call break_point_state  
2d39				endm  
# End of macro CALLMONITOR
2d39					endif 
2d39					 
2d39				FORTH_LOOP_NEXT 
2d39 cd c3 18			call macro_forth_loop_next 
2d3c				endm 
# End of macro FORTH_LOOP_NEXT
2d3c			 
2d3c			 
2d3c					if DEBUG_FORTH_WORDS 
2d3c eb						ex de,hl 
2d3d					endif 
2d3d			 
2d3d			;	; get DO ptr 
2d3d			; 
2d3d					if DEBUG_FORTH_WORDS 
2d3d						DMARK "LP7" 
2d3d f5				push af  
2d3e 3a 52 2d			ld a, (.dmark)  
2d41 32 7a ee			ld (debug_mark),a  
2d44 3a 53 2d			ld a, (.dmark+1)  
2d47 32 7b ee			ld (debug_mark+1),a  
2d4a 3a 54 2d			ld a, (.dmark+2)  
2d4d 32 7c ee			ld (debug_mark+2),a  
2d50 18 03			jr .pastdmark  
2d52 ..			.dmark: db "LP7"  
2d55 f1			.pastdmark: pop af  
2d56			endm  
# End of macro DMARK
2d56					CALLMONITOR 
2d56 cd 86 12			call break_point_state  
2d59				endm  
# End of macro CALLMONITOR
2d59					endif 
2d59				FORTH_RSP_TOS 
2d59 cd d1 17			call macro_forth_rsp_tos 
2d5c				endm 
# End of macro FORTH_RSP_TOS
2d5c			 
2d5c					if DEBUG_FORTH_WORDS 
2d5c						DMARK "LP8" 
2d5c f5				push af  
2d5d 3a 71 2d			ld a, (.dmark)  
2d60 32 7a ee			ld (debug_mark),a  
2d63 3a 72 2d			ld a, (.dmark+1)  
2d66 32 7b ee			ld (debug_mark+1),a  
2d69 3a 73 2d			ld a, (.dmark+2)  
2d6c 32 7c ee			ld (debug_mark+2),a  
2d6f 18 03			jr .pastdmark  
2d71 ..			.dmark: db "LP8"  
2d74 f1			.pastdmark: pop af  
2d75			endm  
# End of macro DMARK
2d75					CALLMONITOR 
2d75 cd 86 12			call break_point_state  
2d78				endm  
# End of macro CALLMONITOR
2d78					endif 
2d78				;push hl 
2d78			 
2d78				; not going to DO any more 
2d78				; get rid of the RSP pointer as DO will add it back in 
2d78				;FORTH_RSP_POP 
2d78				;pop hl 
2d78			 
2d78				;ld hl,(cli_ret_sp) 
2d78				;ld e, (hl) 
2d78				;inc hl 
2d78				;ld d, (hl) 
2d78				;ex de,hl 
2d78 22 76 e6			ld (os_tok_ptr), hl 
2d7b					if DEBUG_FORTH_WORDS 
2d7b						DMARK "LP<" 
2d7b f5				push af  
2d7c 3a 90 2d			ld a, (.dmark)  
2d7f 32 7a ee			ld (debug_mark),a  
2d82 3a 91 2d			ld a, (.dmark+1)  
2d85 32 7b ee			ld (debug_mark+1),a  
2d88 3a 92 2d			ld a, (.dmark+2)  
2d8b 32 7c ee			ld (debug_mark+2),a  
2d8e 18 03			jr .pastdmark  
2d90 ..			.dmark: db "LP<"  
2d93 f1			.pastdmark: pop af  
2d94			endm  
# End of macro DMARK
2d94					CALLMONITOR 
2d94 cd 86 12			call break_point_state  
2d97				endm  
# End of macro CALLMONITOR
2d97				endif 
2d97 c3 95 1a			jp exec1 
2d9a			 
2d9a					 
2d9a			 
2d9a			 
2d9a					NEXTW 
2d9a c3 04 1a			jp macro_next 
2d9d				endm 
# End of macro NEXTW
2d9d			.I:  
2d9d			 
2d9d				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2d9d 5e				db WORD_SYS_CORE+74             
2d9e c8 2d			dw .DLOOP            
2da0 02				db 1 + 1 
2da1 .. 00			db "I",0              
2da3				endm 
# End of macro CWHEAD
2da3			; | I ( -- ) Current loop counter | DONE 
2da3					if DEBUG_FORTH_WORDS_KEY 
2da3						DMARK "I.." 
2da3 f5				push af  
2da4 3a b8 2d			ld a, (.dmark)  
2da7 32 7a ee			ld (debug_mark),a  
2daa 3a b9 2d			ld a, (.dmark+1)  
2dad 32 7b ee			ld (debug_mark+1),a  
2db0 3a ba 2d			ld a, (.dmark+2)  
2db3 32 7c ee			ld (debug_mark+2),a  
2db6 18 03			jr .pastdmark  
2db8 ..			.dmark: db "I.."  
2dbb f1			.pastdmark: pop af  
2dbc			endm  
# End of macro DMARK
2dbc						CALLMONITOR 
2dbc cd 86 12			call break_point_state  
2dbf				endm  
# End of macro CALLMONITOR
2dbf					endif 
2dbf			 
2dbf 2a 9a e6				ld hl,(os_current_i) 
2dc2 cd 13 18				call forth_push_numhl 
2dc5			 
2dc5					NEXTW 
2dc5 c3 04 1a			jp macro_next 
2dc8				endm 
# End of macro NEXTW
2dc8			.DLOOP: 
2dc8				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2dc8 5f				db WORD_SYS_CORE+75             
2dc9 a9 2e			dw .REPEAT            
2dcb 06				db 5 + 1 
2dcc .. 00			db "-LOOP",0              
2dd2				endm 
# End of macro CWHEAD
2dd2			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2dd2				; pop tos as current loop count to hl 
2dd2					if DEBUG_FORTH_WORDS_KEY 
2dd2						DMARK "-LP" 
2dd2 f5				push af  
2dd3 3a e7 2d			ld a, (.dmark)  
2dd6 32 7a ee			ld (debug_mark),a  
2dd9 3a e8 2d			ld a, (.dmark+1)  
2ddc 32 7b ee			ld (debug_mark+1),a  
2ddf 3a e9 2d			ld a, (.dmark+2)  
2de2 32 7c ee			ld (debug_mark+2),a  
2de5 18 03			jr .pastdmark  
2de7 ..			.dmark: db "-LP"  
2dea f1			.pastdmark: pop af  
2deb			endm  
# End of macro DMARK
2deb						CALLMONITOR 
2deb cd 86 12			call break_point_state  
2dee				endm  
# End of macro CALLMONITOR
2dee					endif 
2dee			 
2dee				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2dee			 
2dee				FORTH_LOOP_TOS 
2dee cd f6 18			call macro_forth_loop_tos 
2df1				endm 
# End of macro FORTH_LOOP_TOS
2df1 e5				push hl 
2df2			 
2df2					if DEBUG_FORTH_WORDS 
2df2						DMARK "-LP" 
2df2 f5				push af  
2df3 3a 07 2e			ld a, (.dmark)  
2df6 32 7a ee			ld (debug_mark),a  
2df9 3a 08 2e			ld a, (.dmark+1)  
2dfc 32 7b ee			ld (debug_mark+1),a  
2dff 3a 09 2e			ld a, (.dmark+2)  
2e02 32 7c ee			ld (debug_mark+2),a  
2e05 18 03			jr .pastdmark  
2e07 ..			.dmark: db "-LP"  
2e0a f1			.pastdmark: pop af  
2e0b			endm  
# End of macro DMARK
2e0b						CALLMONITOR 
2e0b cd 86 12			call break_point_state  
2e0e				endm  
# End of macro CALLMONITOR
2e0e					endif 
2e0e				; next item on the stack is the limit. get it 
2e0e			 
2e0e			 
2e0e				FORTH_LOOP_POP 
2e0e cd 00 19			call macro_forth_loop_pop 
2e11				endm 
# End of macro FORTH_LOOP_POP
2e11			 
2e11				FORTH_LOOP_TOS 
2e11 cd f6 18			call macro_forth_loop_tos 
2e14				endm 
# End of macro FORTH_LOOP_TOS
2e14			 
2e14 d1				pop de		 ; de = i, hl = limit 
2e15			 
2e15					if DEBUG_FORTH_WORDS 
2e15						DMARK "-L1" 
2e15 f5				push af  
2e16 3a 2a 2e			ld a, (.dmark)  
2e19 32 7a ee			ld (debug_mark),a  
2e1c 3a 2b 2e			ld a, (.dmark+1)  
2e1f 32 7b ee			ld (debug_mark+1),a  
2e22 3a 2c 2e			ld a, (.dmark+2)  
2e25 32 7c ee			ld (debug_mark+2),a  
2e28 18 03			jr .pastdmark  
2e2a ..			.dmark: db "-L1"  
2e2d f1			.pastdmark: pop af  
2e2e			endm  
# End of macro DMARK
2e2e						CALLMONITOR 
2e2e cd 86 12			call break_point_state  
2e31				endm  
# End of macro CALLMONITOR
2e31					endif 
2e31			 
2e31				; go back to previous word 
2e31			 
2e31 d5				push de    ; save I for inc later 
2e32			 
2e32			 
2e32				; get limit 
2e32				;  is I at limit? 
2e32			 
2e32			 
2e32					if DEBUG_FORTH_WORDS 
2e32						DMARK "-L1" 
2e32 f5				push af  
2e33 3a 47 2e			ld a, (.dmark)  
2e36 32 7a ee			ld (debug_mark),a  
2e39 3a 48 2e			ld a, (.dmark+1)  
2e3c 32 7b ee			ld (debug_mark+1),a  
2e3f 3a 49 2e			ld a, (.dmark+2)  
2e42 32 7c ee			ld (debug_mark+2),a  
2e45 18 03			jr .pastdmark  
2e47 ..			.dmark: db "-L1"  
2e4a f1			.pastdmark: pop af  
2e4b			endm  
# End of macro DMARK
2e4b						CALLMONITOR 
2e4b cd 86 12			call break_point_state  
2e4e				endm  
# End of macro CALLMONITOR
2e4e					endif 
2e4e			 
2e4e ed 52			sbc hl, de 
2e50			 
2e50			 
2e50				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2e50			 
2e50 20 26				jr nz, .mloopnotdone 
2e52			 
2e52 e1				pop hl   ; get rid of saved I 
2e53				FORTH_LOOP_POP     ; get rid of limit 
2e53 cd 00 19			call macro_forth_loop_pop 
2e56				endm 
# End of macro FORTH_LOOP_POP
2e56			 
2e56				FORTH_RSP_POP     ; get rid of DO ptr 
2e56 cd db 17			call macro_forth_rsp_pop 
2e59				endm 
# End of macro FORTH_RSP_POP
2e59			 
2e59			if DEBUG_FORTH_WORDS 
2e59						DMARK "-L>" 
2e59 f5				push af  
2e5a 3a 6e 2e			ld a, (.dmark)  
2e5d 32 7a ee			ld (debug_mark),a  
2e60 3a 6f 2e			ld a, (.dmark+1)  
2e63 32 7b ee			ld (debug_mark+1),a  
2e66 3a 70 2e			ld a, (.dmark+2)  
2e69 32 7c ee			ld (debug_mark+2),a  
2e6c 18 03			jr .pastdmark  
2e6e ..			.dmark: db "-L>"  
2e71 f1			.pastdmark: pop af  
2e72			endm  
# End of macro DMARK
2e72				CALLMONITOR 
2e72 cd 86 12			call break_point_state  
2e75				endm  
# End of macro CALLMONITOR
2e75			endif 
2e75			 
2e75					NEXTW 
2e75 c3 04 1a			jp macro_next 
2e78				endm 
# End of macro NEXTW
2e78				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2e78			 
2e78			.mloopnotdone: 
2e78			 
2e78 e1				pop hl    ; get I 
2e79 2b				dec hl 
2e7a			 
2e7a			   	; save new I 
2e7a			 
2e7a			 
2e7a					; set I counter 
2e7a			 
2e7a 22 9a e6				ld (os_current_i), hl 
2e7d			 
2e7d					 
2e7d				FORTH_LOOP_NEXT 
2e7d cd c3 18			call macro_forth_loop_next 
2e80				endm 
# End of macro FORTH_LOOP_NEXT
2e80			 
2e80			 
2e80					if DEBUG_FORTH_WORDS 
2e80 eb						ex de,hl 
2e81					endif 
2e81			 
2e81			;	; get DO ptr 
2e81			; 
2e81				FORTH_RSP_TOS 
2e81 cd d1 17			call macro_forth_rsp_tos 
2e84				endm 
# End of macro FORTH_RSP_TOS
2e84			 
2e84				;push hl 
2e84			 
2e84				; not going to DO any more 
2e84				; get rid of the RSP pointer as DO will add it back in 
2e84				;FORTH_RSP_POP 
2e84				;pop hl 
2e84			 
2e84			 
2e84 22 76 e6			ld (os_tok_ptr), hl 
2e87					if DEBUG_FORTH_WORDS 
2e87						DMARK "-L<" 
2e87 f5				push af  
2e88 3a 9c 2e			ld a, (.dmark)  
2e8b 32 7a ee			ld (debug_mark),a  
2e8e 3a 9d 2e			ld a, (.dmark+1)  
2e91 32 7b ee			ld (debug_mark+1),a  
2e94 3a 9e 2e			ld a, (.dmark+2)  
2e97 32 7c ee			ld (debug_mark+2),a  
2e9a 18 03			jr .pastdmark  
2e9c ..			.dmark: db "-L<"  
2e9f f1			.pastdmark: pop af  
2ea0			endm  
# End of macro DMARK
2ea0					CALLMONITOR 
2ea0 cd 86 12			call break_point_state  
2ea3				endm  
# End of macro CALLMONITOR
2ea3				endif 
2ea3 c3 95 1a			jp exec1 
2ea6			 
2ea6					 
2ea6			 
2ea6			 
2ea6			 
2ea6				NEXTW 
2ea6 c3 04 1a			jp macro_next 
2ea9				endm 
# End of macro NEXTW
2ea9			 
2ea9			 
2ea9			 
2ea9			 
2ea9			.REPEAT: 
2ea9				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
2ea9 71				db WORD_SYS_CORE+93             
2eaa fc 2e			dw .UNTIL            
2eac 06				db 5 + 1 
2ead .. 00			db "REPEAT",0              
2eb4				endm 
# End of macro CWHEAD
2eb4			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
2eb4			;  push pc to rsp stack past the REPEAT 
2eb4					if DEBUG_FORTH_WORDS_KEY 
2eb4						DMARK "REP" 
2eb4 f5				push af  
2eb5 3a c9 2e			ld a, (.dmark)  
2eb8 32 7a ee			ld (debug_mark),a  
2ebb 3a ca 2e			ld a, (.dmark+1)  
2ebe 32 7b ee			ld (debug_mark+1),a  
2ec1 3a cb 2e			ld a, (.dmark+2)  
2ec4 32 7c ee			ld (debug_mark+2),a  
2ec7 18 03			jr .pastdmark  
2ec9 ..			.dmark: db "REP"  
2ecc f1			.pastdmark: pop af  
2ecd			endm  
# End of macro DMARK
2ecd						CALLMONITOR 
2ecd cd 86 12			call break_point_state  
2ed0				endm  
# End of macro CALLMONITOR
2ed0					endif 
2ed0			 
2ed0 2a 76 e6				ld hl, (os_tok_ptr) 
2ed3 23					inc hl   ; R 
2ed4 23					inc hl  ; E 
2ed5 23					inc hl   ; P 
2ed6 23					inc hl   ; E 
2ed7 23					inc hl   ; A 
2ed8 23					inc hl   ; T 
2ed9 23					inc hl   ; zero 
2eda					FORTH_RSP_NEXT 
2eda cd ba 17			call macro_forth_rsp_next 
2edd				endm 
# End of macro FORTH_RSP_NEXT
2edd			 
2edd			 
2edd					if DEBUG_FORTH_WORDS 
2edd						DMARK "REP" 
2edd f5				push af  
2ede 3a f2 2e			ld a, (.dmark)  
2ee1 32 7a ee			ld (debug_mark),a  
2ee4 3a f3 2e			ld a, (.dmark+1)  
2ee7 32 7b ee			ld (debug_mark+1),a  
2eea 3a f4 2e			ld a, (.dmark+2)  
2eed 32 7c ee			ld (debug_mark+2),a  
2ef0 18 03			jr .pastdmark  
2ef2 ..			.dmark: db "REP"  
2ef5 f1			.pastdmark: pop af  
2ef6			endm  
# End of macro DMARK
2ef6						;pop bc    ; TODO BUG ?????? what is this for???? 
2ef6						CALLMONITOR 
2ef6 cd 86 12			call break_point_state  
2ef9				endm  
# End of macro CALLMONITOR
2ef9					endif 
2ef9			 
2ef9					NEXTW 
2ef9 c3 04 1a			jp macro_next 
2efc				endm 
# End of macro NEXTW
2efc			;	       NEXTW 
2efc			 
2efc			.UNTIL: 
2efc				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
2efc 72				db WORD_SYS_CORE+94             
2efd 93 2f			dw .ENDFLOW            
2eff 06				db 5 + 1 
2f00 .. 00			db "UNTIL",0              
2f06				endm 
# End of macro CWHEAD
2f06			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
2f06			 
2f06				; pop tos as check 
2f06			 
2f06				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2f06			 
2f06				FORTH_DSP_VALUEHL 
2f06 cd ae 18			call macro_dsp_valuehl 
2f09				endm 
# End of macro FORTH_DSP_VALUEHL
2f09			 
2f09					if DEBUG_FORTH_WORDS_KEY 
2f09						DMARK "UNT" 
2f09 f5				push af  
2f0a 3a 1e 2f			ld a, (.dmark)  
2f0d 32 7a ee			ld (debug_mark),a  
2f10 3a 1f 2f			ld a, (.dmark+1)  
2f13 32 7b ee			ld (debug_mark+1),a  
2f16 3a 20 2f			ld a, (.dmark+2)  
2f19 32 7c ee			ld (debug_mark+2),a  
2f1c 18 03			jr .pastdmark  
2f1e ..			.dmark: db "UNT"  
2f21 f1			.pastdmark: pop af  
2f22			endm  
# End of macro DMARK
2f22						CALLMONITOR 
2f22 cd 86 12			call break_point_state  
2f25				endm  
# End of macro CALLMONITOR
2f25					endif 
2f25			 
2f25			;	push hl 
2f25				FORTH_DSP_POP 
2f25 cd 4a 19			call macro_forth_dsp_pop 
2f28				endm 
# End of macro FORTH_DSP_POP
2f28			 
2f28			;	pop hl 
2f28			 
2f28				; test if true 
2f28			 
2f28 cd eb 0a			call ishlzero 
2f2b			;	ld a,l 
2f2b			;	add h 
2f2b			; 
2f2b			;	cp 0 
2f2b			 
2f2b 20 3e			jr nz, .untilnotdone 
2f2d			 
2f2d					if DEBUG_FORTH_WORDS 
2f2d						DMARK "UNf" 
2f2d f5				push af  
2f2e 3a 42 2f			ld a, (.dmark)  
2f31 32 7a ee			ld (debug_mark),a  
2f34 3a 43 2f			ld a, (.dmark+1)  
2f37 32 7b ee			ld (debug_mark+1),a  
2f3a 3a 44 2f			ld a, (.dmark+2)  
2f3d 32 7c ee			ld (debug_mark+2),a  
2f40 18 03			jr .pastdmark  
2f42 ..			.dmark: db "UNf"  
2f45 f1			.pastdmark: pop af  
2f46			endm  
# End of macro DMARK
2f46						CALLMONITOR 
2f46 cd 86 12			call break_point_state  
2f49				endm  
# End of macro CALLMONITOR
2f49					endif 
2f49			 
2f49			 
2f49			 
2f49				FORTH_RSP_POP     ; get rid of DO ptr 
2f49 cd db 17			call macro_forth_rsp_pop 
2f4c				endm 
# End of macro FORTH_RSP_POP
2f4c			 
2f4c			if DEBUG_FORTH_WORDS 
2f4c						DMARK "UN>" 
2f4c f5				push af  
2f4d 3a 61 2f			ld a, (.dmark)  
2f50 32 7a ee			ld (debug_mark),a  
2f53 3a 62 2f			ld a, (.dmark+1)  
2f56 32 7b ee			ld (debug_mark+1),a  
2f59 3a 63 2f			ld a, (.dmark+2)  
2f5c 32 7c ee			ld (debug_mark+2),a  
2f5f 18 03			jr .pastdmark  
2f61 ..			.dmark: db "UN>"  
2f64 f1			.pastdmark: pop af  
2f65			endm  
# End of macro DMARK
2f65				CALLMONITOR 
2f65 cd 86 12			call break_point_state  
2f68				endm  
# End of macro CALLMONITOR
2f68			endif 
2f68			 
2f68					NEXTW 
2f68 c3 04 1a			jp macro_next 
2f6b				endm 
# End of macro NEXTW
2f6b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2f6b			 
2f6b			.untilnotdone: 
2f6b			 
2f6b			 
2f6b			;	; get DO ptr 
2f6b			; 
2f6b				FORTH_RSP_TOS 
2f6b cd d1 17			call macro_forth_rsp_tos 
2f6e				endm 
# End of macro FORTH_RSP_TOS
2f6e			 
2f6e				;push hl 
2f6e			 
2f6e				; not going to DO any more 
2f6e				; get rid of the RSP pointer as DO will add it back in 
2f6e				;FORTH_RSP_POP 
2f6e				;pop hl 
2f6e			 
2f6e			 
2f6e 22 76 e6			ld (os_tok_ptr), hl 
2f71					if DEBUG_FORTH_WORDS 
2f71						DMARK "UN<" 
2f71 f5				push af  
2f72 3a 86 2f			ld a, (.dmark)  
2f75 32 7a ee			ld (debug_mark),a  
2f78 3a 87 2f			ld a, (.dmark+1)  
2f7b 32 7b ee			ld (debug_mark+1),a  
2f7e 3a 88 2f			ld a, (.dmark+2)  
2f81 32 7c ee			ld (debug_mark+2),a  
2f84 18 03			jr .pastdmark  
2f86 ..			.dmark: db "UN<"  
2f89 f1			.pastdmark: pop af  
2f8a			endm  
# End of macro DMARK
2f8a					CALLMONITOR 
2f8a cd 86 12			call break_point_state  
2f8d				endm  
# End of macro CALLMONITOR
2f8d				endif 
2f8d c3 95 1a			jp exec1 
2f90			 
2f90					 
2f90			 
2f90			 
2f90					NEXTW 
2f90 c3 04 1a			jp macro_next 
2f93				endm 
# End of macro NEXTW
2f93			 
2f93			 
2f93			.ENDFLOW: 
2f93			 
2f93			; eof 
2f93			 
# End of file forth_words_flow.asm
2f93			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
2f93			include "forth_words_logic.asm" 
2f93			 
2f93			; | ## Logic Words 
2f93			 
2f93			.NOT: 
2f93				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
2f93 2d				db WORD_SYS_CORE+25             
2f94 db 2f			dw .IS            
2f96 04				db 3 + 1 
2f97 .. 00			db "NOT",0              
2f9b				endm 
# End of macro CWHEAD
2f9b			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
2f9b					if DEBUG_FORTH_WORDS_KEY 
2f9b						DMARK "NOT" 
2f9b f5				push af  
2f9c 3a b0 2f			ld a, (.dmark)  
2f9f 32 7a ee			ld (debug_mark),a  
2fa2 3a b1 2f			ld a, (.dmark+1)  
2fa5 32 7b ee			ld (debug_mark+1),a  
2fa8 3a b2 2f			ld a, (.dmark+2)  
2fab 32 7c ee			ld (debug_mark+2),a  
2fae 18 03			jr .pastdmark  
2fb0 ..			.dmark: db "NOT"  
2fb3 f1			.pastdmark: pop af  
2fb4			endm  
# End of macro DMARK
2fb4						CALLMONITOR 
2fb4 cd 86 12			call break_point_state  
2fb7				endm  
# End of macro CALLMONITOR
2fb7					endif 
2fb7					FORTH_DSP 
2fb7 cd 93 18			call macro_forth_dsp 
2fba				endm 
# End of macro FORTH_DSP
2fba 7e					ld a,(hl)	; get type of value on TOS 
2fbb fe 02				cp DS_TYPE_INUM  
2fbd 28 03				jr z, .noti 
2fbf					NEXTW 
2fbf c3 04 1a			jp macro_next 
2fc2				endm 
# End of macro NEXTW
2fc2			.noti:          FORTH_DSP_VALUEHL 
2fc2 cd ae 18			call macro_dsp_valuehl 
2fc5				endm 
# End of macro FORTH_DSP_VALUEHL
2fc5			;		push hl 
2fc5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2fc5 cd 4a 19			call macro_forth_dsp_pop 
2fc8				endm 
# End of macro FORTH_DSP_POP
2fc8			;		pop hl 
2fc8 3e 00				ld a,0 
2fca bd					cp l 
2fcb 28 04				jr z, .not2t 
2fcd 2e 00				ld l, 0 
2fcf 18 02				jr .notip 
2fd1			 
2fd1 2e ff		.not2t:		ld l, 255 
2fd3			 
2fd3 26 00		.notip:		ld h, 0	 
2fd5			 
2fd5 cd 13 18				call forth_push_numhl 
2fd8					NEXTW 
2fd8 c3 04 1a			jp macro_next 
2fdb				endm 
# End of macro NEXTW
2fdb			 
2fdb			.IS: 
2fdb				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
2fdb 2d				db WORD_SYS_CORE+25             
2fdc 01 30			dw .LZERO            
2fde 03				db 2 + 1 
2fdf .. 00			db "IS",0              
2fe2				endm 
# End of macro CWHEAD
2fe2			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
2fe2					if DEBUG_FORTH_WORDS_KEY 
2fe2						DMARK "IS." 
2fe2 f5				push af  
2fe3 3a f7 2f			ld a, (.dmark)  
2fe6 32 7a ee			ld (debug_mark),a  
2fe9 3a f8 2f			ld a, (.dmark+1)  
2fec 32 7b ee			ld (debug_mark+1),a  
2fef 3a f9 2f			ld a, (.dmark+2)  
2ff2 32 7c ee			ld (debug_mark+2),a  
2ff5 18 03			jr .pastdmark  
2ff7 ..			.dmark: db "IS."  
2ffa f1			.pastdmark: pop af  
2ffb			endm  
# End of macro DMARK
2ffb						CALLMONITOR 
2ffb cd 86 12			call break_point_state  
2ffe				endm  
# End of macro CALLMONITOR
2ffe					endif 
2ffe					NEXTW 
2ffe c3 04 1a			jp macro_next 
3001				endm 
# End of macro NEXTW
3001			.LZERO: 
3001				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3001 2d				db WORD_SYS_CORE+25             
3002 0b 30			dw .TZERO            
3004 03				db 2 + 1 
3005 .. 00			db "0<",0              
3008				endm 
# End of macro CWHEAD
3008			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3008					NEXTW 
3008 c3 04 1a			jp macro_next 
300b				endm 
# End of macro NEXTW
300b			.TZERO: 
300b				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
300b 2e				db WORD_SYS_CORE+26             
300c 52 30			dw .LESS            
300e 03				db 2 + 1 
300f .. 00			db "0=",0              
3012				endm 
# End of macro CWHEAD
3012			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3012				; TODO add floating point number detection 
3012					;v5 FORTH_DSP_VALUE 
3012					if DEBUG_FORTH_WORDS_KEY 
3012						DMARK "0=." 
3012 f5				push af  
3013 3a 27 30			ld a, (.dmark)  
3016 32 7a ee			ld (debug_mark),a  
3019 3a 28 30			ld a, (.dmark+1)  
301c 32 7b ee			ld (debug_mark+1),a  
301f 3a 29 30			ld a, (.dmark+2)  
3022 32 7c ee			ld (debug_mark+2),a  
3025 18 03			jr .pastdmark  
3027 ..			.dmark: db "0=."  
302a f1			.pastdmark: pop af  
302b			endm  
# End of macro DMARK
302b						CALLMONITOR 
302b cd 86 12			call break_point_state  
302e				endm  
# End of macro CALLMONITOR
302e					endif 
302e					FORTH_DSP 
302e cd 93 18			call macro_forth_dsp 
3031				endm 
# End of macro FORTH_DSP
3031 7e					ld a,(hl)	; get type of value on TOS 
3032 fe 02				cp DS_TYPE_INUM  
3034 28 00				jr z, .tz_inum 
3036			 
3036				if FORTH_ENABLE_FLOATMATH 
3036					jr .tz_done 
3036			 
3036				endif 
3036					 
3036			 
3036			.tz_inum: 
3036					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3036 cd ae 18			call macro_dsp_valuehl 
3039				endm 
# End of macro FORTH_DSP_VALUEHL
3039			 
3039			;		push hl 
3039			 
3039					; destroy value TOS 
3039			 
3039					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3039 cd 4a 19			call macro_forth_dsp_pop 
303c				endm 
# End of macro FORTH_DSP_POP
303c			 
303c			;		pop hl 
303c			 
303c 3e 00				ld a,0 
303e			 
303e bd					cp l 
303f 20 08				jr nz, .tz_notzero 
3041			 
3041 bc					cp h 
3042			 
3042 20 05				jr nz, .tz_notzero 
3044			 
3044			 
3044 21 01 00				ld hl, FORTH_TRUE 
3047 18 03				jr .tz_done 
3049			 
3049 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
304c			 
304c					; push value back onto stack for another op etc 
304c			 
304c			.tz_done: 
304c cd 13 18				call forth_push_numhl 
304f			 
304f					NEXTW 
304f c3 04 1a			jp macro_next 
3052				endm 
# End of macro NEXTW
3052			.LESS: 
3052				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3052 2f				db WORD_SYS_CORE+27             
3053 bb 30			dw .GT            
3055 02				db 1 + 1 
3056 .. 00			db "<",0              
3058				endm 
# End of macro CWHEAD
3058			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3058				; TODO add floating point number detection 
3058					if DEBUG_FORTH_WORDS_KEY 
3058						DMARK "LES" 
3058 f5				push af  
3059 3a 6d 30			ld a, (.dmark)  
305c 32 7a ee			ld (debug_mark),a  
305f 3a 6e 30			ld a, (.dmark+1)  
3062 32 7b ee			ld (debug_mark+1),a  
3065 3a 6f 30			ld a, (.dmark+2)  
3068 32 7c ee			ld (debug_mark+2),a  
306b 18 03			jr .pastdmark  
306d ..			.dmark: db "LES"  
3070 f1			.pastdmark: pop af  
3071			endm  
# End of macro DMARK
3071						CALLMONITOR 
3071 cd 86 12			call break_point_state  
3074				endm  
# End of macro CALLMONITOR
3074					endif 
3074					FORTH_DSP 
3074 cd 93 18			call macro_forth_dsp 
3077				endm 
# End of macro FORTH_DSP
3077					;v5 FORTH_DSP_VALUE 
3077 7e					ld a,(hl)	; get type of value on TOS 
3078 fe 02				cp DS_TYPE_INUM  
307a 28 00				jr z, .less_inum 
307c			 
307c				if FORTH_ENABLE_FLOATMATH 
307c					jr .less_done 
307c			 
307c				endif 
307c					 
307c			 
307c			.less_inum: 
307c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
307c cd ae 18			call macro_dsp_valuehl 
307f				endm 
# End of macro FORTH_DSP_VALUEHL
307f			 
307f e5					push hl  ; u2 
3080			 
3080					; destroy value TOS 
3080			 
3080					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3080 cd 4a 19			call macro_forth_dsp_pop 
3083				endm 
# End of macro FORTH_DSP_POP
3083			 
3083			 
3083					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3083 cd ae 18			call macro_dsp_valuehl 
3086				endm 
# End of macro FORTH_DSP_VALUEHL
3086			 
3086 e5					push hl    ; u1 
3087			 
3087					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3087 cd 4a 19			call macro_forth_dsp_pop 
308a				endm 
# End of macro FORTH_DSP_POP
308a			 
308a			 
308a b7			 or a      ;clear carry flag 
308b 01 00 00		 ld bc, FORTH_FALSE 
308e e1			  pop hl    ; u1 
308f d1			  pop de    ; u2 
3090 ed 52		  sbc hl,de 
3092 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3094			 
3094 01 01 00		 ld bc, FORTH_TRUE 
3097			.lscont:  
3097 c5					push bc 
3098 e1					pop hl 
3099			 
3099					if DEBUG_FORTH_WORDS 
3099						DMARK "LT1" 
3099 f5				push af  
309a 3a ae 30			ld a, (.dmark)  
309d 32 7a ee			ld (debug_mark),a  
30a0 3a af 30			ld a, (.dmark+1)  
30a3 32 7b ee			ld (debug_mark+1),a  
30a6 3a b0 30			ld a, (.dmark+2)  
30a9 32 7c ee			ld (debug_mark+2),a  
30ac 18 03			jr .pastdmark  
30ae ..			.dmark: db "LT1"  
30b1 f1			.pastdmark: pop af  
30b2			endm  
# End of macro DMARK
30b2						CALLMONITOR 
30b2 cd 86 12			call break_point_state  
30b5				endm  
# End of macro CALLMONITOR
30b5					endif 
30b5 cd 13 18				call forth_push_numhl 
30b8			 
30b8					NEXTW 
30b8 c3 04 1a			jp macro_next 
30bb				endm 
# End of macro NEXTW
30bb			.GT: 
30bb				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
30bb 30				db WORD_SYS_CORE+28             
30bc 24 31			dw .EQUAL            
30be 02				db 1 + 1 
30bf .. 00			db ">",0              
30c1				endm 
# End of macro CWHEAD
30c1			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
30c1				; TODO add floating point number detection 
30c1					if DEBUG_FORTH_WORDS_KEY 
30c1						DMARK "GRT" 
30c1 f5				push af  
30c2 3a d6 30			ld a, (.dmark)  
30c5 32 7a ee			ld (debug_mark),a  
30c8 3a d7 30			ld a, (.dmark+1)  
30cb 32 7b ee			ld (debug_mark+1),a  
30ce 3a d8 30			ld a, (.dmark+2)  
30d1 32 7c ee			ld (debug_mark+2),a  
30d4 18 03			jr .pastdmark  
30d6 ..			.dmark: db "GRT"  
30d9 f1			.pastdmark: pop af  
30da			endm  
# End of macro DMARK
30da						CALLMONITOR 
30da cd 86 12			call break_point_state  
30dd				endm  
# End of macro CALLMONITOR
30dd					endif 
30dd					FORTH_DSP 
30dd cd 93 18			call macro_forth_dsp 
30e0				endm 
# End of macro FORTH_DSP
30e0					;FORTH_DSP_VALUE 
30e0 7e					ld a,(hl)	; get type of value on TOS 
30e1 fe 02				cp DS_TYPE_INUM  
30e3 28 00				jr z, .gt_inum 
30e5			 
30e5				if FORTH_ENABLE_FLOATMATH 
30e5					jr .gt_done 
30e5			 
30e5				endif 
30e5					 
30e5			 
30e5			.gt_inum: 
30e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
30e5 cd ae 18			call macro_dsp_valuehl 
30e8				endm 
# End of macro FORTH_DSP_VALUEHL
30e8			 
30e8 e5					push hl  ; u2 
30e9			 
30e9					; destroy value TOS 
30e9			 
30e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
30e9 cd 4a 19			call macro_forth_dsp_pop 
30ec				endm 
# End of macro FORTH_DSP_POP
30ec			 
30ec			 
30ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
30ec cd ae 18			call macro_dsp_valuehl 
30ef				endm 
# End of macro FORTH_DSP_VALUEHL
30ef			 
30ef e5					push hl    ; u1 
30f0			 
30f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
30f0 cd 4a 19			call macro_forth_dsp_pop 
30f3				endm 
# End of macro FORTH_DSP_POP
30f3			 
30f3			 
30f3 b7			 or a      ;clear carry flag 
30f4 01 00 00		 ld bc, FORTH_FALSE 
30f7 e1			  pop hl    ; u1 
30f8 d1			  pop de    ; u2 
30f9 ed 52		  sbc hl,de 
30fb 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
30fd			 
30fd 01 01 00		 ld bc, FORTH_TRUE 
3100			.gtcont:  
3100 c5					push bc 
3101 e1					pop hl 
3102			 
3102					if DEBUG_FORTH_WORDS 
3102						DMARK "GT1" 
3102 f5				push af  
3103 3a 17 31			ld a, (.dmark)  
3106 32 7a ee			ld (debug_mark),a  
3109 3a 18 31			ld a, (.dmark+1)  
310c 32 7b ee			ld (debug_mark+1),a  
310f 3a 19 31			ld a, (.dmark+2)  
3112 32 7c ee			ld (debug_mark+2),a  
3115 18 03			jr .pastdmark  
3117 ..			.dmark: db "GT1"  
311a f1			.pastdmark: pop af  
311b			endm  
# End of macro DMARK
311b						CALLMONITOR 
311b cd 86 12			call break_point_state  
311e				endm  
# End of macro CALLMONITOR
311e					endif 
311e cd 13 18				call forth_push_numhl 
3121			 
3121					NEXTW 
3121 c3 04 1a			jp macro_next 
3124				endm 
# End of macro NEXTW
3124			.EQUAL: 
3124				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3124 31				db WORD_SYS_CORE+29             
3125 8f 31			dw .ENDLOGIC            
3127 02				db 1 + 1 
3128 .. 00			db "=",0              
312a				endm 
# End of macro CWHEAD
312a			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
312a				; TODO add floating point number detection 
312a					if DEBUG_FORTH_WORDS_KEY 
312a						DMARK "EQ." 
312a f5				push af  
312b 3a 3f 31			ld a, (.dmark)  
312e 32 7a ee			ld (debug_mark),a  
3131 3a 40 31			ld a, (.dmark+1)  
3134 32 7b ee			ld (debug_mark+1),a  
3137 3a 41 31			ld a, (.dmark+2)  
313a 32 7c ee			ld (debug_mark+2),a  
313d 18 03			jr .pastdmark  
313f ..			.dmark: db "EQ."  
3142 f1			.pastdmark: pop af  
3143			endm  
# End of macro DMARK
3143						CALLMONITOR 
3143 cd 86 12			call break_point_state  
3146				endm  
# End of macro CALLMONITOR
3146					endif 
3146					FORTH_DSP 
3146 cd 93 18			call macro_forth_dsp 
3149				endm 
# End of macro FORTH_DSP
3149					;v5 FORTH_DSP_VALUE 
3149 7e					ld a,(hl)	; get type of value on TOS 
314a fe 02				cp DS_TYPE_INUM  
314c 28 00				jr z, .eq_inum 
314e			 
314e				if FORTH_ENABLE_FLOATMATH 
314e					jr .eq_done 
314e			 
314e				endif 
314e					 
314e			 
314e			.eq_inum: 
314e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
314e cd ae 18			call macro_dsp_valuehl 
3151				endm 
# End of macro FORTH_DSP_VALUEHL
3151			 
3151 e5					push hl 
3152			 
3152					; destroy value TOS 
3152			 
3152					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3152 cd 4a 19			call macro_forth_dsp_pop 
3155				endm 
# End of macro FORTH_DSP_POP
3155			 
3155			 
3155					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3155 cd ae 18			call macro_dsp_valuehl 
3158				endm 
# End of macro FORTH_DSP_VALUEHL
3158			 
3158					; one value on hl get other one back 
3158			 
3158 e5					push hl 
3159			 
3159					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3159 cd 4a 19			call macro_forth_dsp_pop 
315c				endm 
# End of macro FORTH_DSP_POP
315c			 
315c 0e 00				ld c, FORTH_FALSE 
315e			 
315e e1					pop hl 
315f d1					pop de 
3160			 
3160 7b					ld a, e 
3161 bd					cp l 
3162			 
3162 20 06				jr nz, .eq_done 
3164			 
3164 7a					ld a, d 
3165 bc					cp h 
3166			 
3166 20 02				jr nz, .eq_done 
3168			 
3168 0e 01				ld c, FORTH_TRUE 
316a					 
316a			 
316a			 
316a			.eq_done: 
316a			 
316a					; TODO push value back onto stack for another op etc 
316a			 
316a 26 00				ld h, 0 
316c 69					ld l, c 
316d					if DEBUG_FORTH_WORDS 
316d						DMARK "EQ1" 
316d f5				push af  
316e 3a 82 31			ld a, (.dmark)  
3171 32 7a ee			ld (debug_mark),a  
3174 3a 83 31			ld a, (.dmark+1)  
3177 32 7b ee			ld (debug_mark+1),a  
317a 3a 84 31			ld a, (.dmark+2)  
317d 32 7c ee			ld (debug_mark+2),a  
3180 18 03			jr .pastdmark  
3182 ..			.dmark: db "EQ1"  
3185 f1			.pastdmark: pop af  
3186			endm  
# End of macro DMARK
3186						CALLMONITOR 
3186 cd 86 12			call break_point_state  
3189				endm  
# End of macro CALLMONITOR
3189					endif 
3189 cd 13 18				call forth_push_numhl 
318c			 
318c					NEXTW 
318c c3 04 1a			jp macro_next 
318f				endm 
# End of macro NEXTW
318f			 
318f			 
318f			.ENDLOGIC: 
318f			; eof 
318f			 
318f			 
# End of file forth_words_logic.asm
318f			include "forth_words_maths.asm" 
318f			 
318f			; | ## Maths Words 
318f			 
318f			.PLUS:	 
318f				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
318f 15				db WORD_SYS_CORE+1             
3190 d1 31			dw .NEG            
3192 02				db 1 + 1 
3193 .. 00			db "+",0              
3195				endm 
# End of macro CWHEAD
3195			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3195					if DEBUG_FORTH_WORDS_KEY 
3195						DMARK "PLU" 
3195 f5				push af  
3196 3a aa 31			ld a, (.dmark)  
3199 32 7a ee			ld (debug_mark),a  
319c 3a ab 31			ld a, (.dmark+1)  
319f 32 7b ee			ld (debug_mark+1),a  
31a2 3a ac 31			ld a, (.dmark+2)  
31a5 32 7c ee			ld (debug_mark+2),a  
31a8 18 03			jr .pastdmark  
31aa ..			.dmark: db "PLU"  
31ad f1			.pastdmark: pop af  
31ae			endm  
# End of macro DMARK
31ae						CALLMONITOR 
31ae cd 86 12			call break_point_state  
31b1				endm  
# End of macro CALLMONITOR
31b1					endif 
31b1					; add top two values and push back result 
31b1			 
31b1					;for v5 FORTH_DSP_VALUE 
31b1					FORTH_DSP 
31b1 cd 93 18			call macro_forth_dsp 
31b4				endm 
# End of macro FORTH_DSP
31b4 7e					ld a,(hl)	; get type of value on TOS 
31b5 fe 02				cp DS_TYPE_INUM  
31b7 28 03				jr z, .dot_inum 
31b9			 
31b9					NEXTW 
31b9 c3 04 1a			jp macro_next 
31bc				endm 
# End of macro NEXTW
31bc			 
31bc			; float maths 
31bc			 
31bc				if FORTH_ENABLE_FLOATMATH 
31bc						inc hl      ; now at start of numeric as string 
31bc			 
31bc					if DEBUG_FORTH_MATHS 
31bc						DMARK "ADD" 
31bc				CALLMONITOR 
31bc					endif 
31bc			 
31bc					;ld ix, hl 
31bc					call CON 
31bc			 
31bc			 
31bc					push hl 
31bc					 
31bc					 
31bc			 
31bc						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
31bc			 
31bc					; get next number 
31bc			 
31bc						FORTH_DSP_VALUE 
31bc			 
31bc						inc hl      ; now at start of numeric as string 
31bc			 
31bc					;ld ix, hl 
31bc					call CON 
31bc			 
31bc					push hl 
31bc			 
31bc			 
31bc						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31bc			 
31bc						; TODO do add 
31bc			 
31bc						call IADD 
31bc			 
31bc						; TODO get result back as ascii 
31bc			 
31bc						; TODO push result  
31bc			 
31bc			 
31bc			 
31bc						jr .dot_done 
31bc				endif 
31bc			 
31bc			.dot_inum: 
31bc			 
31bc			 
31bc					if DEBUG_FORTH_DOT 
31bc						DMARK "+IT" 
31bc				CALLMONITOR 
31bc					endif 
31bc			 
31bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31bc cd ae 18			call macro_dsp_valuehl 
31bf				endm 
# End of macro FORTH_DSP_VALUEHL
31bf			 
31bf				; TODO add floating point number detection 
31bf			 
31bf e5					push hl 
31c0			 
31c0					; destroy value TOS 
31c0			 
31c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31c0 cd 4a 19			call macro_forth_dsp_pop 
31c3				endm 
# End of macro FORTH_DSP_POP
31c3			 
31c3			 
31c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31c3 cd ae 18			call macro_dsp_valuehl 
31c6				endm 
# End of macro FORTH_DSP_VALUEHL
31c6			 
31c6					; one value on hl get other one back 
31c6			 
31c6 d1					pop de 
31c7			 
31c7					; do the add 
31c7			 
31c7 19					add hl,de 
31c8			 
31c8					; save it 
31c8			 
31c8			;		push hl	 
31c8			 
31c8					; 
31c8			 
31c8					; destroy value TOS 
31c8			 
31c8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31c8 cd 4a 19			call macro_forth_dsp_pop 
31cb				endm 
# End of macro FORTH_DSP_POP
31cb			 
31cb					; TODO push value back onto stack for another op etc 
31cb			 
31cb			;		pop hl 
31cb			 
31cb			.dot_done: 
31cb cd 13 18				call forth_push_numhl 
31ce			 
31ce					NEXTW 
31ce c3 04 1a			jp macro_next 
31d1				endm 
# End of macro NEXTW
31d1			.NEG: 
31d1			 
31d1				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
31d1 17				db WORD_SYS_CORE+3             
31d2 14 32			dw .DIV            
31d4 02				db 1 + 1 
31d5 .. 00			db "-",0              
31d7				endm 
# End of macro CWHEAD
31d7			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
31d7					if DEBUG_FORTH_WORDS_KEY 
31d7						DMARK "SUB" 
31d7 f5				push af  
31d8 3a ec 31			ld a, (.dmark)  
31db 32 7a ee			ld (debug_mark),a  
31de 3a ed 31			ld a, (.dmark+1)  
31e1 32 7b ee			ld (debug_mark+1),a  
31e4 3a ee 31			ld a, (.dmark+2)  
31e7 32 7c ee			ld (debug_mark+2),a  
31ea 18 03			jr .pastdmark  
31ec ..			.dmark: db "SUB"  
31ef f1			.pastdmark: pop af  
31f0			endm  
# End of macro DMARK
31f0						CALLMONITOR 
31f0 cd 86 12			call break_point_state  
31f3				endm  
# End of macro CALLMONITOR
31f3					endif 
31f3			 
31f3			 
31f3				; TODO add floating point number detection 
31f3					; v5 FORTH_DSP_VALUE 
31f3					FORTH_DSP 
31f3 cd 93 18			call macro_forth_dsp 
31f6				endm 
# End of macro FORTH_DSP
31f6 7e					ld a,(hl)	; get type of value on TOS 
31f7 fe 02				cp DS_TYPE_INUM  
31f9 28 03				jr z, .neg_inum 
31fb			 
31fb					NEXTW 
31fb c3 04 1a			jp macro_next 
31fe				endm 
# End of macro NEXTW
31fe			 
31fe			; float maths 
31fe			 
31fe				if FORTH_ENABLE_FLOATMATH 
31fe					jr .neg_done 
31fe			 
31fe				endif 
31fe					 
31fe			 
31fe			.neg_inum: 
31fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31fe cd ae 18			call macro_dsp_valuehl 
3201				endm 
# End of macro FORTH_DSP_VALUEHL
3201			 
3201 e5					push hl 
3202			 
3202					; destroy value TOS 
3202			 
3202					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3202 cd 4a 19			call macro_forth_dsp_pop 
3205				endm 
# End of macro FORTH_DSP_POP
3205			 
3205			 
3205					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3205 cd ae 18			call macro_dsp_valuehl 
3208				endm 
# End of macro FORTH_DSP_VALUEHL
3208			 
3208					; one value on hl get other one back 
3208			 
3208 d1					pop de 
3209			 
3209					; do the sub 
3209			;		ex de, hl 
3209			 
3209 ed 52				sbc hl,de 
320b			 
320b					; save it 
320b			 
320b			;		push hl	 
320b			 
320b					; 
320b			 
320b					; destroy value TOS 
320b			 
320b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
320b cd 4a 19			call macro_forth_dsp_pop 
320e				endm 
# End of macro FORTH_DSP_POP
320e			 
320e					; TODO push value back onto stack for another op etc 
320e			 
320e			;		pop hl 
320e			 
320e cd 13 18				call forth_push_numhl 
3211			.neg_done: 
3211			 
3211					NEXTW 
3211 c3 04 1a			jp macro_next 
3214				endm 
# End of macro NEXTW
3214			.DIV: 
3214				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3214 18				db WORD_SYS_CORE+4             
3215 61 32			dw .MUL            
3217 02				db 1 + 1 
3218 .. 00			db "/",0              
321a				endm 
# End of macro CWHEAD
321a			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
321a					if DEBUG_FORTH_WORDS_KEY 
321a						DMARK "DIV" 
321a f5				push af  
321b 3a 2f 32			ld a, (.dmark)  
321e 32 7a ee			ld (debug_mark),a  
3221 3a 30 32			ld a, (.dmark+1)  
3224 32 7b ee			ld (debug_mark+1),a  
3227 3a 31 32			ld a, (.dmark+2)  
322a 32 7c ee			ld (debug_mark+2),a  
322d 18 03			jr .pastdmark  
322f ..			.dmark: db "DIV"  
3232 f1			.pastdmark: pop af  
3233			endm  
# End of macro DMARK
3233						CALLMONITOR 
3233 cd 86 12			call break_point_state  
3236				endm  
# End of macro CALLMONITOR
3236					endif 
3236				; TODO add floating point number detection 
3236					; v5 FORTH_DSP_VALUE 
3236					FORTH_DSP 
3236 cd 93 18			call macro_forth_dsp 
3239				endm 
# End of macro FORTH_DSP
3239 7e					ld a,(hl)	; get type of value on TOS 
323a fe 02				cp DS_TYPE_INUM  
323c 28 03				jr z, .div_inum 
323e			 
323e				if FORTH_ENABLE_FLOATMATH 
323e					jr .div_done 
323e			 
323e				endif 
323e					NEXTW 
323e c3 04 1a			jp macro_next 
3241				endm 
# End of macro NEXTW
3241			.div_inum: 
3241			 
3241					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3241 cd ae 18			call macro_dsp_valuehl 
3244				endm 
# End of macro FORTH_DSP_VALUEHL
3244			 
3244 e5					push hl    ; to go to bc 
3245			 
3245					; destroy value TOS 
3245			 
3245					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3245 cd 4a 19			call macro_forth_dsp_pop 
3248				endm 
# End of macro FORTH_DSP_POP
3248			 
3248			 
3248					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3248 cd ae 18			call macro_dsp_valuehl 
324b				endm 
# End of macro FORTH_DSP_VALUEHL
324b			 
324b					; hl to go to de 
324b			 
324b e5					push hl 
324c			 
324c c1					pop bc 
324d d1					pop de		 
324e			 
324e			 
324e					if DEBUG_FORTH_MATHS 
324e						DMARK "DIV" 
324e				CALLMONITOR 
324e					endif 
324e					; one value on hl but move to a get other one back 
324e			 
324e			        
324e cd 1f 0a			call Div16 
3251			 
3251			;	push af	 
3251 e5				push hl 
3252 c5				push bc 
3253			 
3253					if DEBUG_FORTH_MATHS 
3253						DMARK "DI1" 
3253				CALLMONITOR 
3253					endif 
3253			 
3253					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3253 cd 4a 19			call macro_forth_dsp_pop 
3256				endm 
# End of macro FORTH_DSP_POP
3256			 
3256			 
3256			 
3256 e1					pop hl    ; result 
3257			 
3257 cd 13 18				call forth_push_numhl 
325a			 
325a e1					pop hl    ; reminder 
325b			;		ld h,0 
325b			;		ld l,d 
325b			 
325b cd 13 18				call forth_push_numhl 
325e			.div_done: 
325e					NEXTW 
325e c3 04 1a			jp macro_next 
3261				endm 
# End of macro NEXTW
3261			.MUL: 
3261				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3261 19				db WORD_SYS_CORE+5             
3262 a6 32			dw .MIN            
3264 02				db 1 + 1 
3265 .. 00			db "*",0              
3267				endm 
# End of macro CWHEAD
3267			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3267				; TODO add floating point number detection 
3267					if DEBUG_FORTH_WORDS_KEY 
3267						DMARK "MUL" 
3267 f5				push af  
3268 3a 7c 32			ld a, (.dmark)  
326b 32 7a ee			ld (debug_mark),a  
326e 3a 7d 32			ld a, (.dmark+1)  
3271 32 7b ee			ld (debug_mark+1),a  
3274 3a 7e 32			ld a, (.dmark+2)  
3277 32 7c ee			ld (debug_mark+2),a  
327a 18 03			jr .pastdmark  
327c ..			.dmark: db "MUL"  
327f f1			.pastdmark: pop af  
3280			endm  
# End of macro DMARK
3280						CALLMONITOR 
3280 cd 86 12			call break_point_state  
3283				endm  
# End of macro CALLMONITOR
3283					endif 
3283					FORTH_DSP 
3283 cd 93 18			call macro_forth_dsp 
3286				endm 
# End of macro FORTH_DSP
3286					; v5 FORTH_DSP_VALUE 
3286 7e					ld a,(hl)	; get type of value on TOS 
3287 fe 02				cp DS_TYPE_INUM  
3289 28 03				jr z, .mul_inum 
328b			 
328b				if FORTH_ENABLE_FLOATMATH 
328b					jr .mul_done 
328b			 
328b				endif 
328b			 
328b					NEXTW 
328b c3 04 1a			jp macro_next 
328e				endm 
# End of macro NEXTW
328e			.mul_inum:	 
328e			 
328e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
328e cd ae 18			call macro_dsp_valuehl 
3291				endm 
# End of macro FORTH_DSP_VALUEHL
3291			 
3291 e5					push hl 
3292			 
3292					; destroy value TOS 
3292			 
3292					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3292 cd 4a 19			call macro_forth_dsp_pop 
3295				endm 
# End of macro FORTH_DSP_POP
3295			 
3295			 
3295					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3295 cd ae 18			call macro_dsp_valuehl 
3298				endm 
# End of macro FORTH_DSP_VALUEHL
3298			 
3298					; one value on hl but move to a get other one back 
3298			 
3298 7d					ld a, l 
3299			 
3299 d1					pop de 
329a			 
329a					; do the mull 
329a			;		ex de, hl 
329a			 
329a cd 45 0a				call Mult16 
329d					; save it 
329d			 
329d			;		push hl	 
329d			 
329d					; 
329d			 
329d					; destroy value TOS 
329d			 
329d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
329d cd 4a 19			call macro_forth_dsp_pop 
32a0				endm 
# End of macro FORTH_DSP_POP
32a0			 
32a0					; TODO push value back onto stack for another op etc 
32a0			 
32a0			;		pop hl 
32a0			 
32a0 cd 13 18				call forth_push_numhl 
32a3			 
32a3			.mul_done: 
32a3					NEXTW 
32a3 c3 04 1a			jp macro_next 
32a6				endm 
# End of macro NEXTW
32a6			 
32a6			 
32a6			 
32a6			 
32a6			.MIN: 
32a6				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
32a6 49				db WORD_SYS_CORE+53             
32a7 27 33			dw .MAX            
32a9 04				db 3 + 1 
32aa .. 00			db "MIN",0              
32ae				endm 
# End of macro CWHEAD
32ae			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
32ae					if DEBUG_FORTH_WORDS_KEY 
32ae						DMARK "MIN" 
32ae f5				push af  
32af 3a c3 32			ld a, (.dmark)  
32b2 32 7a ee			ld (debug_mark),a  
32b5 3a c4 32			ld a, (.dmark+1)  
32b8 32 7b ee			ld (debug_mark+1),a  
32bb 3a c5 32			ld a, (.dmark+2)  
32be 32 7c ee			ld (debug_mark+2),a  
32c1 18 03			jr .pastdmark  
32c3 ..			.dmark: db "MIN"  
32c6 f1			.pastdmark: pop af  
32c7			endm  
# End of macro DMARK
32c7						CALLMONITOR 
32c7 cd 86 12			call break_point_state  
32ca				endm  
# End of macro CALLMONITOR
32ca					endif 
32ca					; get u2 
32ca			 
32ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32ca cd ae 18			call macro_dsp_valuehl 
32cd				endm 
# End of macro FORTH_DSP_VALUEHL
32cd			 
32cd e5					push hl   ; u2 
32ce			 
32ce					; destroy value TOS 
32ce			 
32ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32ce cd 4a 19			call macro_forth_dsp_pop 
32d1				endm 
# End of macro FORTH_DSP_POP
32d1			 
32d1					; get u1 
32d1			 
32d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32d1 cd ae 18			call macro_dsp_valuehl 
32d4				endm 
# End of macro FORTH_DSP_VALUEHL
32d4			 
32d4 e5					push hl  ; u1 
32d5			 
32d5					; destroy value TOS 
32d5			 
32d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32d5 cd 4a 19			call macro_forth_dsp_pop 
32d8				endm 
# End of macro FORTH_DSP_POP
32d8			 
32d8 b7			 or a      ;clear carry flag 
32d9 e1			  pop hl    ; u1 
32da d1			  pop de    ; u2 
32db e5				push hl   ; saved in case hl is lowest 
32dc ed 52		  sbc hl,de 
32de 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
32e0			 
32e0 e1				pop hl 
32e1					if DEBUG_FORTH_WORDS 
32e1						DMARK "MIN" 
32e1 f5				push af  
32e2 3a f6 32			ld a, (.dmark)  
32e5 32 7a ee			ld (debug_mark),a  
32e8 3a f7 32			ld a, (.dmark+1)  
32eb 32 7b ee			ld (debug_mark+1),a  
32ee 3a f8 32			ld a, (.dmark+2)  
32f1 32 7c ee			ld (debug_mark+2),a  
32f4 18 03			jr .pastdmark  
32f6 ..			.dmark: db "MIN"  
32f9 f1			.pastdmark: pop af  
32fa			endm  
# End of macro DMARK
32fa						CALLMONITOR 
32fa cd 86 12			call break_point_state  
32fd				endm  
# End of macro CALLMONITOR
32fd					endif 
32fd cd 13 18				call forth_push_numhl 
3300			 
3300				       NEXTW 
3300 c3 04 1a			jp macro_next 
3303				endm 
# End of macro NEXTW
3303			 
3303			.mincont:  
3303 c1				pop bc   ; tidy up 
3304 eb				ex de , hl  
3305					if DEBUG_FORTH_WORDS 
3305						DMARK "MI1" 
3305 f5				push af  
3306 3a 1a 33			ld a, (.dmark)  
3309 32 7a ee			ld (debug_mark),a  
330c 3a 1b 33			ld a, (.dmark+1)  
330f 32 7b ee			ld (debug_mark+1),a  
3312 3a 1c 33			ld a, (.dmark+2)  
3315 32 7c ee			ld (debug_mark+2),a  
3318 18 03			jr .pastdmark  
331a ..			.dmark: db "MI1"  
331d f1			.pastdmark: pop af  
331e			endm  
# End of macro DMARK
331e						CALLMONITOR 
331e cd 86 12			call break_point_state  
3321				endm  
# End of macro CALLMONITOR
3321					endif 
3321 cd 13 18				call forth_push_numhl 
3324			 
3324				       NEXTW 
3324 c3 04 1a			jp macro_next 
3327				endm 
# End of macro NEXTW
3327			.MAX: 
3327				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3327 4a				db WORD_SYS_CORE+54             
3328 a8 33			dw .RND16            
332a 04				db 3 + 1 
332b .. 00			db "MAX",0              
332f				endm 
# End of macro CWHEAD
332f			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
332f					if DEBUG_FORTH_WORDS_KEY 
332f						DMARK "MAX" 
332f f5				push af  
3330 3a 44 33			ld a, (.dmark)  
3333 32 7a ee			ld (debug_mark),a  
3336 3a 45 33			ld a, (.dmark+1)  
3339 32 7b ee			ld (debug_mark+1),a  
333c 3a 46 33			ld a, (.dmark+2)  
333f 32 7c ee			ld (debug_mark+2),a  
3342 18 03			jr .pastdmark  
3344 ..			.dmark: db "MAX"  
3347 f1			.pastdmark: pop af  
3348			endm  
# End of macro DMARK
3348						CALLMONITOR 
3348 cd 86 12			call break_point_state  
334b				endm  
# End of macro CALLMONITOR
334b					endif 
334b					; get u2 
334b			 
334b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
334b cd ae 18			call macro_dsp_valuehl 
334e				endm 
# End of macro FORTH_DSP_VALUEHL
334e			 
334e e5					push hl   ; u2 
334f			 
334f					; destroy value TOS 
334f			 
334f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
334f cd 4a 19			call macro_forth_dsp_pop 
3352				endm 
# End of macro FORTH_DSP_POP
3352			 
3352					; get u1 
3352			 
3352					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3352 cd ae 18			call macro_dsp_valuehl 
3355				endm 
# End of macro FORTH_DSP_VALUEHL
3355			 
3355 e5					push hl  ; u1 
3356			 
3356					; destroy value TOS 
3356			 
3356					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3356 cd 4a 19			call macro_forth_dsp_pop 
3359				endm 
# End of macro FORTH_DSP_POP
3359			 
3359 b7			 or a      ;clear carry flag 
335a e1			  pop hl    ; u1 
335b d1			  pop de    ; u2 
335c e5				push hl   ; saved in case hl is lowest 
335d ed 52		  sbc hl,de 
335f 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3361			 
3361 e1				pop hl 
3362					if DEBUG_FORTH_WORDS 
3362						DMARK "MAX" 
3362 f5				push af  
3363 3a 77 33			ld a, (.dmark)  
3366 32 7a ee			ld (debug_mark),a  
3369 3a 78 33			ld a, (.dmark+1)  
336c 32 7b ee			ld (debug_mark+1),a  
336f 3a 79 33			ld a, (.dmark+2)  
3372 32 7c ee			ld (debug_mark+2),a  
3375 18 03			jr .pastdmark  
3377 ..			.dmark: db "MAX"  
337a f1			.pastdmark: pop af  
337b			endm  
# End of macro DMARK
337b						CALLMONITOR 
337b cd 86 12			call break_point_state  
337e				endm  
# End of macro CALLMONITOR
337e					endif 
337e cd 13 18				call forth_push_numhl 
3381			 
3381				       NEXTW 
3381 c3 04 1a			jp macro_next 
3384				endm 
# End of macro NEXTW
3384			 
3384			.maxcont:  
3384 c1				pop bc   ; tidy up 
3385 eb				ex de , hl  
3386					if DEBUG_FORTH_WORDS 
3386						DMARK "MA1" 
3386 f5				push af  
3387 3a 9b 33			ld a, (.dmark)  
338a 32 7a ee			ld (debug_mark),a  
338d 3a 9c 33			ld a, (.dmark+1)  
3390 32 7b ee			ld (debug_mark+1),a  
3393 3a 9d 33			ld a, (.dmark+2)  
3396 32 7c ee			ld (debug_mark+2),a  
3399 18 03			jr .pastdmark  
339b ..			.dmark: db "MA1"  
339e f1			.pastdmark: pop af  
339f			endm  
# End of macro DMARK
339f						CALLMONITOR 
339f cd 86 12			call break_point_state  
33a2				endm  
# End of macro CALLMONITOR
33a2					endif 
33a2 cd 13 18				call forth_push_numhl 
33a5				       NEXTW 
33a5 c3 04 1a			jp macro_next 
33a8				endm 
# End of macro NEXTW
33a8			 
33a8			.RND16: 
33a8				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
33a8 4e				db WORD_SYS_CORE+58             
33a9 d7 33			dw .RND8            
33ab 06				db 5 + 1 
33ac .. 00			db "RND16",0              
33b2				endm 
# End of macro CWHEAD
33b2			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
33b2					if DEBUG_FORTH_WORDS_KEY 
33b2						DMARK "R16" 
33b2 f5				push af  
33b3 3a c7 33			ld a, (.dmark)  
33b6 32 7a ee			ld (debug_mark),a  
33b9 3a c8 33			ld a, (.dmark+1)  
33bc 32 7b ee			ld (debug_mark+1),a  
33bf 3a c9 33			ld a, (.dmark+2)  
33c2 32 7c ee			ld (debug_mark+2),a  
33c5 18 03			jr .pastdmark  
33c7 ..			.dmark: db "R16"  
33ca f1			.pastdmark: pop af  
33cb			endm  
# End of macro DMARK
33cb						CALLMONITOR 
33cb cd 86 12			call break_point_state  
33ce				endm  
# End of macro CALLMONITOR
33ce					endif 
33ce cd e9 09				call prng16  
33d1 cd 13 18				call forth_push_numhl 
33d4				       NEXTW 
33d4 c3 04 1a			jp macro_next 
33d7				endm 
# End of macro NEXTW
33d7			.RND8: 
33d7				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
33d7 60				db WORD_SYS_CORE+76             
33d8 0c 34			dw .RND            
33da 05				db 4 + 1 
33db .. 00			db "RND8",0              
33e0				endm 
# End of macro CWHEAD
33e0			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
33e0					if DEBUG_FORTH_WORDS_KEY 
33e0						DMARK "RN8" 
33e0 f5				push af  
33e1 3a f5 33			ld a, (.dmark)  
33e4 32 7a ee			ld (debug_mark),a  
33e7 3a f6 33			ld a, (.dmark+1)  
33ea 32 7b ee			ld (debug_mark+1),a  
33ed 3a f7 33			ld a, (.dmark+2)  
33f0 32 7c ee			ld (debug_mark+2),a  
33f3 18 03			jr .pastdmark  
33f5 ..			.dmark: db "RN8"  
33f8 f1			.pastdmark: pop af  
33f9			endm  
# End of macro DMARK
33f9						CALLMONITOR 
33f9 cd 86 12			call break_point_state  
33fc				endm  
# End of macro CALLMONITOR
33fc					endif 
33fc 2a bb eb				ld hl,(xrandc) 
33ff 23					inc hl 
3400 cd 03 0a				call xrnd 
3403 6f					ld l,a	 
3404 26 00				ld h,0 
3406 cd 13 18				call forth_push_numhl 
3409				       NEXTW 
3409 c3 04 1a			jp macro_next 
340c				endm 
# End of macro NEXTW
340c			.RND: 
340c				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
340c 60				db WORD_SYS_CORE+76             
340d 12 35			dw .ENDMATHS            
340f 04				db 3 + 1 
3410 .. 00			db "RND",0              
3414				endm 
# End of macro CWHEAD
3414			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3414			 
3414					if DEBUG_FORTH_WORDS_KEY 
3414						DMARK "RND" 
3414 f5				push af  
3415 3a 29 34			ld a, (.dmark)  
3418 32 7a ee			ld (debug_mark),a  
341b 3a 2a 34			ld a, (.dmark+1)  
341e 32 7b ee			ld (debug_mark+1),a  
3421 3a 2b 34			ld a, (.dmark+2)  
3424 32 7c ee			ld (debug_mark+2),a  
3427 18 03			jr .pastdmark  
3429 ..			.dmark: db "RND"  
342c f1			.pastdmark: pop af  
342d			endm  
# End of macro DMARK
342d						CALLMONITOR 
342d cd 86 12			call break_point_state  
3430				endm  
# End of macro CALLMONITOR
3430					endif 
3430					 
3430					FORTH_DSP_VALUEHL    ; upper range 
3430 cd ae 18			call macro_dsp_valuehl 
3433				endm 
# End of macro FORTH_DSP_VALUEHL
3433			 
3433 22 bf eb				ld (LFSRSeed), hl	 
3436			 
3436					if DEBUG_FORTH_WORDS 
3436						DMARK "RN1" 
3436 f5				push af  
3437 3a 4b 34			ld a, (.dmark)  
343a 32 7a ee			ld (debug_mark),a  
343d 3a 4c 34			ld a, (.dmark+1)  
3440 32 7b ee			ld (debug_mark+1),a  
3443 3a 4d 34			ld a, (.dmark+2)  
3446 32 7c ee			ld (debug_mark+2),a  
3449 18 03			jr .pastdmark  
344b ..			.dmark: db "RN1"  
344e f1			.pastdmark: pop af  
344f			endm  
# End of macro DMARK
344f						CALLMONITOR 
344f cd 86 12			call break_point_state  
3452				endm  
# End of macro CALLMONITOR
3452					endif 
3452					FORTH_DSP_POP 
3452 cd 4a 19			call macro_forth_dsp_pop 
3455				endm 
# End of macro FORTH_DSP_POP
3455			 
3455					FORTH_DSP_VALUEHL    ; low range 
3455 cd ae 18			call macro_dsp_valuehl 
3458				endm 
# End of macro FORTH_DSP_VALUEHL
3458			 
3458					if DEBUG_FORTH_WORDS 
3458						DMARK "RN2" 
3458 f5				push af  
3459 3a 6d 34			ld a, (.dmark)  
345c 32 7a ee			ld (debug_mark),a  
345f 3a 6e 34			ld a, (.dmark+1)  
3462 32 7b ee			ld (debug_mark+1),a  
3465 3a 6f 34			ld a, (.dmark+2)  
3468 32 7c ee			ld (debug_mark+2),a  
346b 18 03			jr .pastdmark  
346d ..			.dmark: db "RN2"  
3470 f1			.pastdmark: pop af  
3471			endm  
# End of macro DMARK
3471						CALLMONITOR 
3471 cd 86 12			call break_point_state  
3474				endm  
# End of macro CALLMONITOR
3474					endif 
3474 22 c1 eb				ld (LFSRSeed+2), hl 
3477			 
3477					FORTH_DSP_POP 
3477 cd 4a 19			call macro_forth_dsp_pop 
347a				endm 
# End of macro FORTH_DSP_POP
347a			 
347a e5					push hl 
347b			 
347b e1			.inrange:	pop hl 
347c cd e9 09				call prng16  
347f					if DEBUG_FORTH_WORDS 
347f						DMARK "RN3" 
347f f5				push af  
3480 3a 94 34			ld a, (.dmark)  
3483 32 7a ee			ld (debug_mark),a  
3486 3a 95 34			ld a, (.dmark+1)  
3489 32 7b ee			ld (debug_mark+1),a  
348c 3a 96 34			ld a, (.dmark+2)  
348f 32 7c ee			ld (debug_mark+2),a  
3492 18 03			jr .pastdmark  
3494 ..			.dmark: db "RN3"  
3497 f1			.pastdmark: pop af  
3498			endm  
# End of macro DMARK
3498						CALLMONITOR 
3498 cd 86 12			call break_point_state  
349b				endm  
# End of macro CALLMONITOR
349b					endif 
349b					 
349b					; if the range is 8bit knock out the high byte 
349b			 
349b ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
349f			 
349f 3e 00				ld a, 0 
34a1 ba					cp d  
34a2 20 1e				jr nz, .hirange 
34a4 26 00				ld h, 0   ; knock it down to 8bit 
34a6			 
34a6					if DEBUG_FORTH_WORDS 
34a6						DMARK "RNk" 
34a6 f5				push af  
34a7 3a bb 34			ld a, (.dmark)  
34aa 32 7a ee			ld (debug_mark),a  
34ad 3a bc 34			ld a, (.dmark+1)  
34b0 32 7b ee			ld (debug_mark+1),a  
34b3 3a bd 34			ld a, (.dmark+2)  
34b6 32 7c ee			ld (debug_mark+2),a  
34b9 18 03			jr .pastdmark  
34bb ..			.dmark: db "RNk"  
34be f1			.pastdmark: pop af  
34bf			endm  
# End of macro DMARK
34bf						CALLMONITOR 
34bf cd 86 12			call break_point_state  
34c2				endm  
# End of macro CALLMONITOR
34c2					endif 
34c2			.hirange:   
34c2 e5					push hl  
34c3 b7					or a  
34c4 ed 52		                sbc hl, de 
34c6			 
34c6					;call cmp16 
34c6			 
34c6 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
34c8 e1					pop hl 
34c9 e5					push hl 
34ca			 
34ca					if DEBUG_FORTH_WORDS 
34ca						DMARK "RN4" 
34ca f5				push af  
34cb 3a df 34			ld a, (.dmark)  
34ce 32 7a ee			ld (debug_mark),a  
34d1 3a e0 34			ld a, (.dmark+1)  
34d4 32 7b ee			ld (debug_mark+1),a  
34d7 3a e1 34			ld a, (.dmark+2)  
34da 32 7c ee			ld (debug_mark+2),a  
34dd 18 03			jr .pastdmark  
34df ..			.dmark: db "RN4"  
34e2 f1			.pastdmark: pop af  
34e3			endm  
# End of macro DMARK
34e3						CALLMONITOR 
34e3 cd 86 12			call break_point_state  
34e6				endm  
# End of macro CALLMONITOR
34e6					endif 
34e6 ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
34ea					;call cmp16 
34ea				 
34ea b7					or a  
34eb ed 52		                sbc hl, de 
34ed 38 8c				jr c, .inrange 
34ef			 
34ef e1					pop hl 
34f0					 
34f0					if DEBUG_FORTH_WORDS 
34f0						DMARK "RNd" 
34f0 f5				push af  
34f1 3a 05 35			ld a, (.dmark)  
34f4 32 7a ee			ld (debug_mark),a  
34f7 3a 06 35			ld a, (.dmark+1)  
34fa 32 7b ee			ld (debug_mark+1),a  
34fd 3a 07 35			ld a, (.dmark+2)  
3500 32 7c ee			ld (debug_mark+2),a  
3503 18 03			jr .pastdmark  
3505 ..			.dmark: db "RNd"  
3508 f1			.pastdmark: pop af  
3509			endm  
# End of macro DMARK
3509						CALLMONITOR 
3509 cd 86 12			call break_point_state  
350c				endm  
# End of macro CALLMONITOR
350c					endif 
350c			 
350c			 
350c cd 13 18				call forth_push_numhl 
350f				       NEXTW 
350f c3 04 1a			jp macro_next 
3512				endm 
# End of macro NEXTW
3512			 
3512			.ENDMATHS: 
3512			 
3512			; eof 
3512			 
# End of file forth_words_maths.asm
3512			include "forth_words_display.asm" 
3512			 
3512			; | ## Display Words 
3512			 
3512			.ATP: 
3512				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3512 62				db WORD_SYS_CORE+78             
3513 89 35			dw .FB            
3515 04				db 3 + 1 
3516 .. 00			db "AT?",0              
351a				endm 
# End of macro CWHEAD
351a			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
351a					if DEBUG_FORTH_WORDS_KEY 
351a						DMARK "AT?" 
351a f5				push af  
351b 3a 2f 35			ld a, (.dmark)  
351e 32 7a ee			ld (debug_mark),a  
3521 3a 30 35			ld a, (.dmark+1)  
3524 32 7b ee			ld (debug_mark+1),a  
3527 3a 31 35			ld a, (.dmark+2)  
352a 32 7c ee			ld (debug_mark+2),a  
352d 18 03			jr .pastdmark  
352f ..			.dmark: db "AT?"  
3532 f1			.pastdmark: pop af  
3533			endm  
# End of macro DMARK
3533						CALLMONITOR 
3533 cd 86 12			call break_point_state  
3536				endm  
# End of macro CALLMONITOR
3536					endif 
3536 3a 5e eb				ld a, (f_cursor_ptr) 
3539			 
3539			if DEBUG_FORTH_WORDS 
3539				DMARK "AT?" 
3539 f5				push af  
353a 3a 4e 35			ld a, (.dmark)  
353d 32 7a ee			ld (debug_mark),a  
3540 3a 4f 35			ld a, (.dmark+1)  
3543 32 7b ee			ld (debug_mark+1),a  
3546 3a 50 35			ld a, (.dmark+2)  
3549 32 7c ee			ld (debug_mark+2),a  
354c 18 03			jr .pastdmark  
354e ..			.dmark: db "AT?"  
3551 f1			.pastdmark: pop af  
3552			endm  
# End of macro DMARK
3552				CALLMONITOR 
3552 cd 86 12			call break_point_state  
3555				endm  
# End of macro CALLMONITOR
3555			endif	 
3555					; count the number of rows 
3555			 
3555 06 00				ld b, 0 
3557 4f			.atpr:		ld c, a    ; save in case we go below zero 
3558 d6 28				sub display_cols 
355a f2 60 35				jp p, .atprunder 
355d 04					inc b 
355e 18 f7				jr .atpr 
3560			.atprunder:	 
3560			if DEBUG_FORTH_WORDS 
3560				DMARK "A?2" 
3560 f5				push af  
3561 3a 75 35			ld a, (.dmark)  
3564 32 7a ee			ld (debug_mark),a  
3567 3a 76 35			ld a, (.dmark+1)  
356a 32 7b ee			ld (debug_mark+1),a  
356d 3a 77 35			ld a, (.dmark+2)  
3570 32 7c ee			ld (debug_mark+2),a  
3573 18 03			jr .pastdmark  
3575 ..			.dmark: db "A?2"  
3578 f1			.pastdmark: pop af  
3579			endm  
# End of macro DMARK
3579				CALLMONITOR 
3579 cd 86 12			call break_point_state  
357c				endm  
# End of macro CALLMONITOR
357c			endif	 
357c 26 00				ld h, 0 
357e 69					ld l, c 
357f cd 13 18				call forth_push_numhl 
3582 68					ld l, b  
3583 cd 13 18				call forth_push_numhl 
3586			 
3586			 
3586				NEXTW 
3586 c3 04 1a			jp macro_next 
3589				endm 
# End of macro NEXTW
3589			 
3589			.FB: 
3589				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3589 1b				db WORD_SYS_CORE+7             
358a d7 35			dw .EMIT            
358c 03				db 2 + 1 
358d .. 00			db "FB",0              
3590				endm 
# End of macro CWHEAD
3590			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3590			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3590			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3590			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3590					if DEBUG_FORTH_WORDS_KEY 
3590						DMARK "FB." 
3590 f5				push af  
3591 3a a5 35			ld a, (.dmark)  
3594 32 7a ee			ld (debug_mark),a  
3597 3a a6 35			ld a, (.dmark+1)  
359a 32 7b ee			ld (debug_mark+1),a  
359d 3a a7 35			ld a, (.dmark+2)  
35a0 32 7c ee			ld (debug_mark+2),a  
35a3 18 03			jr .pastdmark  
35a5 ..			.dmark: db "FB."  
35a8 f1			.pastdmark: pop af  
35a9			endm  
# End of macro DMARK
35a9						CALLMONITOR 
35a9 cd 86 12			call break_point_state  
35ac				endm  
# End of macro CALLMONITOR
35ac					endif 
35ac			 
35ac					FORTH_DSP_VALUEHL 
35ac cd ae 18			call macro_dsp_valuehl 
35af				endm 
# End of macro FORTH_DSP_VALUEHL
35af			 
35af 7d					ld a, l 
35b0 fe 01				cp 1 
35b2 20 05				jr nz, .fbn1 
35b4 21 1f ed				ld hl, display_fb1 
35b7 18 15				jr .fbset 
35b9 fe 02		.fbn1:		cp 2 
35bb 20 05				jr nz, .fbn2 
35bd 21 dd eb				ld hl, display_fb2 
35c0 18 0c				jr .fbset 
35c2 fe 03		.fbn2:		cp 3 
35c4 20 05				jr nz, .fbn3 
35c6 21 7e ec				ld hl, display_fb3 
35c9 18 03				jr .fbset 
35cb			.fbn3:		 ; if invalid number select first 
35cb 21 1f ed				ld hl, display_fb1 
35ce 22 db eb		.fbset:		ld (display_fb_active), hl 
35d1			 
35d1					FORTH_DSP_POP 
35d1 cd 4a 19			call macro_forth_dsp_pop 
35d4				endm 
# End of macro FORTH_DSP_POP
35d4			 
35d4					NEXTW 
35d4 c3 04 1a			jp macro_next 
35d7				endm 
# End of macro NEXTW
35d7			 
35d7			 
35d7			.EMIT: 
35d7				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
35d7 1b				db WORD_SYS_CORE+7             
35d8 28 36			dw .DOTH            
35da 05				db 4 + 1 
35db .. 00			db "EMIT",0              
35e0				endm 
# End of macro CWHEAD
35e0			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
35e0					; get value off TOS and display it 
35e0			 
35e0					if DEBUG_FORTH_WORDS_KEY 
35e0						DMARK "EMT" 
35e0 f5				push af  
35e1 3a f5 35			ld a, (.dmark)  
35e4 32 7a ee			ld (debug_mark),a  
35e7 3a f6 35			ld a, (.dmark+1)  
35ea 32 7b ee			ld (debug_mark+1),a  
35ed 3a f7 35			ld a, (.dmark+2)  
35f0 32 7c ee			ld (debug_mark+2),a  
35f3 18 03			jr .pastdmark  
35f5 ..			.dmark: db "EMT"  
35f8 f1			.pastdmark: pop af  
35f9			endm  
# End of macro DMARK
35f9						CALLMONITOR 
35f9 cd 86 12			call break_point_state  
35fc				endm  
# End of macro CALLMONITOR
35fc					endif 
35fc			 
35fc					FORTH_DSP_VALUEHL 
35fc cd ae 18			call macro_dsp_valuehl 
35ff				endm 
# End of macro FORTH_DSP_VALUEHL
35ff			 
35ff 7d					ld a,l 
3600			 
3600					; TODO write to display 
3600			 
3600 32 73 e5				ld (os_input), a 
3603 3e 00				ld a, 0 
3605 32 74 e5				ld (os_input+1), a 
3608					 
3608 3a 5e eb				ld a, (f_cursor_ptr) 
360b 11 73 e5				ld de, os_input 
360e cd 7c 09				call str_at_display 
3611			 
3611			 
3611 3a 3c eb				ld a,(cli_autodisplay) 
3614 fe 00				cp 0 
3616 28 03				jr z, .enoupdate 
3618 cd 8c 09						call update_display 
361b					.enoupdate: 
361b			 
361b 3a 5e eb				ld a, (f_cursor_ptr) 
361e 3c					inc a 
361f 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
3622			 
3622			 
3622					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3622 cd 4a 19			call macro_forth_dsp_pop 
3625				endm 
# End of macro FORTH_DSP_POP
3625			  
3625			 
3625					NEXTW 
3625 c3 04 1a			jp macro_next 
3628				endm 
# End of macro NEXTW
3628			.DOTH: 
3628				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3628 1c				db WORD_SYS_CORE+8             
3629 58 36			dw .DOTF            
362b 03				db 2 + 1 
362c .. 00			db ".-",0              
362f				endm 
# End of macro CWHEAD
362f			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
362f					; get value off TOS and display it 
362f					if DEBUG_FORTH_WORDS_KEY 
362f						DMARK "DTD" 
362f f5				push af  
3630 3a 44 36			ld a, (.dmark)  
3633 32 7a ee			ld (debug_mark),a  
3636 3a 45 36			ld a, (.dmark+1)  
3639 32 7b ee			ld (debug_mark+1),a  
363c 3a 46 36			ld a, (.dmark+2)  
363f 32 7c ee			ld (debug_mark+2),a  
3642 18 03			jr .pastdmark  
3644 ..			.dmark: db "DTD"  
3647 f1			.pastdmark: pop af  
3648			endm  
# End of macro DMARK
3648						CALLMONITOR 
3648 cd 86 12			call break_point_state  
364b				endm  
# End of macro CALLMONITOR
364b					endif 
364b 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
364d 3e 00			ld a, 0 
364f 32 3d eb			ld (cli_mvdot), a 
3652 c3 af 36			jp .dotgo 
3655				NEXTW 
3655 c3 04 1a			jp macro_next 
3658				endm 
# End of macro NEXTW
3658			.DOTF: 
3658				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3658 1c				db WORD_SYS_CORE+8             
3659 86 36			dw .DOT            
365b 03				db 2 + 1 
365c .. 00			db ".>",0              
365f				endm 
# End of macro CWHEAD
365f			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
365f					; get value off TOS and display it 
365f			        ; TODO BUG adds extra spaces 
365f			        ; TODO BUG handle numerics? 
365f					if DEBUG_FORTH_WORDS_KEY 
365f						DMARK "DTC" 
365f f5				push af  
3660 3a 74 36			ld a, (.dmark)  
3663 32 7a ee			ld (debug_mark),a  
3666 3a 75 36			ld a, (.dmark+1)  
3669 32 7b ee			ld (debug_mark+1),a  
366c 3a 76 36			ld a, (.dmark+2)  
366f 32 7c ee			ld (debug_mark+2),a  
3672 18 03			jr .pastdmark  
3674 ..			.dmark: db "DTC"  
3677 f1			.pastdmark: pop af  
3678			endm  
# End of macro DMARK
3678						CALLMONITOR 
3678 cd 86 12			call break_point_state  
367b				endm  
# End of macro CALLMONITOR
367b					endif 
367b 3e 01			ld a, 1 
367d 32 3d eb			ld (cli_mvdot), a 
3680 c3 af 36			jp .dotgo 
3683				NEXTW 
3683 c3 04 1a			jp macro_next 
3686				endm 
# End of macro NEXTW
3686			 
3686			.DOT: 
3686				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3686 1c				db WORD_SYS_CORE+8             
3687 12 37			dw .CLS            
3689 02				db 1 + 1 
368a .. 00			db ".",0              
368c				endm 
# End of macro CWHEAD
368c			        ; | . ( u -- ) Display TOS | DONE 
368c					; get value off TOS and display it 
368c			 
368c					if DEBUG_FORTH_WORDS_KEY 
368c						DMARK "DOT" 
368c f5				push af  
368d 3a a1 36			ld a, (.dmark)  
3690 32 7a ee			ld (debug_mark),a  
3693 3a a2 36			ld a, (.dmark+1)  
3696 32 7b ee			ld (debug_mark+1),a  
3699 3a a3 36			ld a, (.dmark+2)  
369c 32 7c ee			ld (debug_mark+2),a  
369f 18 03			jr .pastdmark  
36a1 ..			.dmark: db "DOT"  
36a4 f1			.pastdmark: pop af  
36a5			endm  
# End of macro DMARK
36a5						CALLMONITOR 
36a5 cd 86 12			call break_point_state  
36a8				endm  
# End of macro CALLMONITOR
36a8					endif 
36a8 3e 00			ld a, 0 
36aa 32 3d eb			ld (cli_mvdot), a 
36ad 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
36af				 
36af			 
36af			.dotgo: 
36af			 
36af			; move up type to on stack for parserv5 
36af					FORTH_DSP 
36af cd 93 18			call macro_forth_dsp 
36b2				endm 
# End of macro FORTH_DSP
36b2				;FORTH_DSP_VALUE  
36b2			 
36b2			if DEBUG_FORTH_DOT 
36b2				DMARK "DOT" 
36b2				CALLMONITOR 
36b2			endif	 
36b2			;		.print: 
36b2			 
36b2 7e				ld a,(hl)  ; work out what type of value is on the TOS 
36b3 23				inc hl   ; position to the actual value 
36b4 fe 01			cp DS_TYPE_STR 
36b6 20 06			jr nz, .dotnum1  
36b8			 
36b8			; display string 
36b8				FORTH_DSP_VALUE  
36b8 cd 97 18			call macro_forth_dsp_value 
36bb				endm 
# End of macro FORTH_DSP_VALUE
36bb eb				ex de,hl 
36bc 18 11			jr .dotwrite 
36be			 
36be			.dotnum1: 
36be fe 02			cp DS_TYPE_INUM 
36c0 20 0c			jr nz, .dotflot 
36c2			 
36c2			 
36c2			; display number 
36c2			 
36c2			;	push hl 
36c2			;	call clear_display 
36c2			;	pop hl 
36c2			 
36c2 5e				ld e, (hl) 
36c3 23				inc hl 
36c4 56				ld d, (hl) 
36c5 21 75 e3			ld hl, scratch 
36c8			if DEBUG_FORTH_DOT 
36c8				DMARK "DT1" 
36c8				CALLMONITOR 
36c8			endif	 
36c8			 
36c8 cd cf 0e			call uitoa_16 
36cb eb				ex de,hl 
36cc			 
36cc			if DEBUG_FORTH_DOT 
36cc				DMARK "DT2" 
36cc				CALLMONITOR 
36cc			endif	 
36cc			 
36cc			;	ld de, os_word_scratch 
36cc 18 01			jr .dotwrite 
36ce			 
36ce 00			.dotflot:   nop 
36cf			; TODO print floating point number 
36cf			 
36cf			.dotwrite:		 
36cf			 
36cf					; if c is set then set all '-' to spaces 
36cf					; need to also take into account .>  
36cf			 
36cf 3e 01				ld a, 1 
36d1 b9					cp c 
36d2 20 13				jr nz, .nodashswap 
36d4			 
36d4					; DE has the string to write, working with HL 
36d4			 
36d4 06 ff				ld b, 255 
36d6 d5					push de 
36d7 e1					pop hl 
36d8			 
36d8			if DEBUG_FORTH_DOT 
36d8				DMARK "DT-" 
36d8				CALLMONITOR 
36d8			endif	 
36d8 7e			.dashscan:	ld a, (hl) 
36d9 fe 00				cp 0 
36db 28 0a				jr z, .nodashswap 
36dd fe 2d				cp '-' 
36df 20 03				jr nz, .dashskip 
36e1 3e 20				ld a, ' ' 
36e3 77					ld (hl), a 
36e4 23			.dashskip:	inc hl 
36e5			if DEBUG_FORTH_DOT 
36e5				DMARK "D-2" 
36e5				CALLMONITOR 
36e5			endif	 
36e5 10 f1				djnz .dashscan 
36e7			 
36e7			if DEBUG_FORTH_DOT 
36e7				DMARK "D-1" 
36e7				CALLMONITOR 
36e7			endif	 
36e7			 
36e7			.nodashswap: 
36e7			 
36e7 e5					push hl   ; save string start in case we need to advance print 
36e8			 
36e8 3a 5e eb				ld a, (f_cursor_ptr) 
36eb cd 7c 09				call str_at_display 
36ee 3a 3c eb				ld a,(cli_autodisplay) 
36f1 fe 00				cp 0 
36f3 28 03				jr z, .noupdate 
36f5 cd 8c 09						call update_display 
36f8					.noupdate: 
36f8			 
36f8			 
36f8					; see if we need to advance the print position 
36f8			 
36f8 e1					pop hl   ; get back string 
36f9			 
36f9 3a 3d eb				ld a, (cli_mvdot) 
36fc			if DEBUG_FORTH_DOT 
36fc					ld e,a 
36fc				DMARK "D>1" 
36fc				CALLMONITOR 
36fc			endif	 
36fc fe 00				cp 0 
36fe 28 0c				jr z, .noadv 
3700					; yes, lets advance the print position 
3700 3e 00				ld a, 0 
3702 cd 2b 0f				call strlent 
3705 3a 5e eb				ld a, (f_cursor_ptr) 
3708 85					add a,l 
3709					;call addatohl 
3709					;ld a, l 
3709 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
370c			 
370c			if DEBUG_FORTH_DOT 
370c				DMARK "D->" 
370c				CALLMONITOR 
370c			endif	 
370c			 
370c			.noadv:	 
370c			 
370c					if DEBUG_FORTH_DOT_WAIT 
370c							call next_page_prompt 
370c					endif	 
370c			; TODO this pop off the stack causes a crash. i dont know why 
370c			 
370c			 
370c			if DEBUG_FORTH_DOT 
370c				DMARK "DTh" 
370c				CALLMONITOR 
370c			endif	 
370c			 
370c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
370c cd 4a 19			call macro_forth_dsp_pop 
370f				endm 
# End of macro FORTH_DSP_POP
370f			 
370f			if DEBUG_FORTH_DOT 
370f				DMARK "DTi" 
370f				CALLMONITOR 
370f			endif	 
370f			 
370f			 
370f					NEXTW 
370f c3 04 1a			jp macro_next 
3712				endm 
# End of macro NEXTW
3712			 
3712			.CLS: 
3712				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3712 35				db WORD_SYS_CORE+33             
3713 3f 37			dw .DRAW            
3715 04				db 3 + 1 
3716 .. 00			db "CLS",0              
371a				endm 
# End of macro CWHEAD
371a			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
371a					if DEBUG_FORTH_WORDS_KEY 
371a						DMARK "CLS" 
371a f5				push af  
371b 3a 2f 37			ld a, (.dmark)  
371e 32 7a ee			ld (debug_mark),a  
3721 3a 30 37			ld a, (.dmark+1)  
3724 32 7b ee			ld (debug_mark+1),a  
3727 3a 31 37			ld a, (.dmark+2)  
372a 32 7c ee			ld (debug_mark+2),a  
372d 18 03			jr .pastdmark  
372f ..			.dmark: db "CLS"  
3732 f1			.pastdmark: pop af  
3733			endm  
# End of macro DMARK
3733						CALLMONITOR 
3733 cd 86 12			call break_point_state  
3736				endm  
# End of macro CALLMONITOR
3736					endif 
3736 cd 69 09				call clear_display 
3739 c3 4d 38				jp .home		; and home cursor 
373c					NEXTW 
373c c3 04 1a			jp macro_next 
373f				endm 
# End of macro NEXTW
373f			 
373f			.DRAW: 
373f				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
373f 36				db WORD_SYS_CORE+34             
3740 6a 37			dw .DUMP            
3742 05				db 4 + 1 
3743 .. 00			db "DRAW",0              
3748				endm 
# End of macro CWHEAD
3748			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3748					if DEBUG_FORTH_WORDS_KEY 
3748						DMARK "DRW" 
3748 f5				push af  
3749 3a 5d 37			ld a, (.dmark)  
374c 32 7a ee			ld (debug_mark),a  
374f 3a 5e 37			ld a, (.dmark+1)  
3752 32 7b ee			ld (debug_mark+1),a  
3755 3a 5f 37			ld a, (.dmark+2)  
3758 32 7c ee			ld (debug_mark+2),a  
375b 18 03			jr .pastdmark  
375d ..			.dmark: db "DRW"  
3760 f1			.pastdmark: pop af  
3761			endm  
# End of macro DMARK
3761						CALLMONITOR 
3761 cd 86 12			call break_point_state  
3764				endm  
# End of macro CALLMONITOR
3764					endif 
3764 cd 8c 09				call update_display 
3767					NEXTW 
3767 c3 04 1a			jp macro_next 
376a				endm 
# End of macro NEXTW
376a			 
376a			.DUMP: 
376a				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
376a 37				db WORD_SYS_CORE+35             
376b a2 37			dw .CDUMP            
376d 05				db 4 + 1 
376e .. 00			db "DUMP",0              
3773				endm 
# End of macro CWHEAD
3773			; | DUMP ( x -- ) With address x display dump   | DONE 
3773			; TODO pop address to use off of the stack 
3773					if DEBUG_FORTH_WORDS_KEY 
3773						DMARK "DUM" 
3773 f5				push af  
3774 3a 88 37			ld a, (.dmark)  
3777 32 7a ee			ld (debug_mark),a  
377a 3a 89 37			ld a, (.dmark+1)  
377d 32 7b ee			ld (debug_mark+1),a  
3780 3a 8a 37			ld a, (.dmark+2)  
3783 32 7c ee			ld (debug_mark+2),a  
3786 18 03			jr .pastdmark  
3788 ..			.dmark: db "DUM"  
378b f1			.pastdmark: pop af  
378c			endm  
# End of macro DMARK
378c						CALLMONITOR 
378c cd 86 12			call break_point_state  
378f				endm  
# End of macro CALLMONITOR
378f					endif 
378f cd 69 09				call clear_display 
3792			 
3792					; get address 
3792			 
3792					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3792 cd ae 18			call macro_dsp_valuehl 
3795				endm 
# End of macro FORTH_DSP_VALUEHL
3795				 
3795					; save it for cdump 
3795			 
3795 22 98 e6				ld (os_cur_ptr),hl 
3798			 
3798					; destroy value TOS 
3798			 
3798					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3798 cd 4a 19			call macro_forth_dsp_pop 
379b				endm 
# End of macro FORTH_DSP_POP
379b			 
379b cd 93 16				call dumpcont	; skip old style of param parsing	 
379e c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
379f					NEXTW 
379f c3 04 1a			jp macro_next 
37a2				endm 
# End of macro NEXTW
37a2			.CDUMP: 
37a2				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
37a2 38				db WORD_SYS_CORE+36             
37a3 d2 37			dw .DAT            
37a5 06				db 5 + 1 
37a6 .. 00			db "CDUMP",0              
37ac				endm 
# End of macro CWHEAD
37ac			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
37ac					if DEBUG_FORTH_WORDS_KEY 
37ac						DMARK "CDP" 
37ac f5				push af  
37ad 3a c1 37			ld a, (.dmark)  
37b0 32 7a ee			ld (debug_mark),a  
37b3 3a c2 37			ld a, (.dmark+1)  
37b6 32 7b ee			ld (debug_mark+1),a  
37b9 3a c3 37			ld a, (.dmark+2)  
37bc 32 7c ee			ld (debug_mark+2),a  
37bf 18 03			jr .pastdmark  
37c1 ..			.dmark: db "CDP"  
37c4 f1			.pastdmark: pop af  
37c5			endm  
# End of macro DMARK
37c5						CALLMONITOR 
37c5 cd 86 12			call break_point_state  
37c8				endm  
# End of macro CALLMONITOR
37c8					endif 
37c8 cd 69 09				call clear_display 
37cb cd 93 16				call dumpcont	 
37ce c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
37cf					NEXTW 
37cf c3 04 1a			jp macro_next 
37d2				endm 
# End of macro NEXTW
37d2			 
37d2			 
37d2			 
37d2			 
37d2			.DAT: 
37d2				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
37d2 3d				db WORD_SYS_CORE+41             
37d3 28 38			dw .HOME            
37d5 03				db 2 + 1 
37d6 .. 00			db "AT",0              
37d9				endm 
# End of macro CWHEAD
37d9			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
37d9					if DEBUG_FORTH_WORDS_KEY 
37d9						DMARK "AT." 
37d9 f5				push af  
37da 3a ee 37			ld a, (.dmark)  
37dd 32 7a ee			ld (debug_mark),a  
37e0 3a ef 37			ld a, (.dmark+1)  
37e3 32 7b ee			ld (debug_mark+1),a  
37e6 3a f0 37			ld a, (.dmark+2)  
37e9 32 7c ee			ld (debug_mark+2),a  
37ec 18 03			jr .pastdmark  
37ee ..			.dmark: db "AT."  
37f1 f1			.pastdmark: pop af  
37f2			endm  
# End of macro DMARK
37f2						CALLMONITOR 
37f2 cd 86 12			call break_point_state  
37f5				endm  
# End of macro CALLMONITOR
37f5					endif 
37f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37f5 cd ae 18			call macro_dsp_valuehl 
37f8				endm 
# End of macro FORTH_DSP_VALUEHL
37f8			 
37f8			 
37f8					; TODO save cursor row 
37f8 7d					ld a,l 
37f9 fe 02				cp 2 
37fb 20 04				jr nz, .crow3 
37fd 3e 28				ld a, display_row_2 
37ff 18 12				jr .ccol1 
3801 fe 03		.crow3:		cp 3 
3803 20 04				jr nz, .crow4 
3805 3e 50				ld a, display_row_3 
3807 18 0a				jr .ccol1 
3809 fe 04		.crow4:		cp 4 
380b 20 04				jr nz, .crow1 
380d 3e 78				ld a, display_row_4 
380f 18 02				jr .ccol1 
3811 3e 00		.crow1:		ld a,display_row_1 
3813 f5			.ccol1:		push af			; got row offset 
3814 6f					ld l,a 
3815 26 00				ld h,0 
3817					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3817 cd 4a 19			call macro_forth_dsp_pop 
381a				endm 
# End of macro FORTH_DSP_POP
381a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
381a cd ae 18			call macro_dsp_valuehl 
381d				endm 
# End of macro FORTH_DSP_VALUEHL
381d					; TODO save cursor col 
381d f1					pop af 
381e 85					add l		; add col offset 
381f 32 5e eb				ld (f_cursor_ptr), a 
3822					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3822 cd 4a 19			call macro_forth_dsp_pop 
3825				endm 
# End of macro FORTH_DSP_POP
3825			 
3825					; calculate  
3825			 
3825					NEXTW 
3825 c3 04 1a			jp macro_next 
3828				endm 
# End of macro NEXTW
3828			 
3828			 
3828			.HOME: 
3828				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3828 41				db WORD_SYS_CORE+45             
3829 55 38			dw .SPACE            
382b 05				db 4 + 1 
382c .. 00			db "HOME",0              
3831				endm 
# End of macro CWHEAD
3831			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3831					if DEBUG_FORTH_WORDS_KEY 
3831						DMARK "HOM" 
3831 f5				push af  
3832 3a 46 38			ld a, (.dmark)  
3835 32 7a ee			ld (debug_mark),a  
3838 3a 47 38			ld a, (.dmark+1)  
383b 32 7b ee			ld (debug_mark+1),a  
383e 3a 48 38			ld a, (.dmark+2)  
3841 32 7c ee			ld (debug_mark+2),a  
3844 18 03			jr .pastdmark  
3846 ..			.dmark: db "HOM"  
3849 f1			.pastdmark: pop af  
384a			endm  
# End of macro DMARK
384a						CALLMONITOR 
384a cd 86 12			call break_point_state  
384d				endm  
# End of macro CALLMONITOR
384d					endif 
384d 3e 00		.home:		ld a, 0		; and home cursor 
384f 32 5e eb				ld (f_cursor_ptr), a 
3852					NEXTW 
3852 c3 04 1a			jp macro_next 
3855				endm 
# End of macro NEXTW
3855			 
3855			 
3855			.SPACE: 
3855				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3855 46				db WORD_SYS_CORE+50             
3856 83 38			dw .SPACES            
3858 03				db 2 + 1 
3859 .. 00			db "BL",0              
385c				endm 
# End of macro CWHEAD
385c			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
385c					if DEBUG_FORTH_WORDS_KEY 
385c						DMARK "BL." 
385c f5				push af  
385d 3a 71 38			ld a, (.dmark)  
3860 32 7a ee			ld (debug_mark),a  
3863 3a 72 38			ld a, (.dmark+1)  
3866 32 7b ee			ld (debug_mark+1),a  
3869 3a 73 38			ld a, (.dmark+2)  
386c 32 7c ee			ld (debug_mark+2),a  
386f 18 03			jr .pastdmark  
3871 ..			.dmark: db "BL."  
3874 f1			.pastdmark: pop af  
3875			endm  
# End of macro DMARK
3875						CALLMONITOR 
3875 cd 86 12			call break_point_state  
3878				endm  
# End of macro CALLMONITOR
3878					endif 
3878 21 81 38				ld hl, .blstr 
387b cd 25 18				call forth_push_str 
387e					 
387e				       NEXTW 
387e c3 04 1a			jp macro_next 
3881				endm 
# End of macro NEXTW
3881			 
3881 .. 00		.blstr: db " ", 0 
3883			 
3883			.SPACES: 
3883				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3883 47				db WORD_SYS_CORE+51             
3884 1e 39			dw .SCROLL            
3886 07				db 6 + 1 
3887 .. 00			db "SPACES",0              
388e				endm 
# End of macro CWHEAD
388e			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
388e					if DEBUG_FORTH_WORDS_KEY 
388e						DMARK "SPS" 
388e f5				push af  
388f 3a a3 38			ld a, (.dmark)  
3892 32 7a ee			ld (debug_mark),a  
3895 3a a4 38			ld a, (.dmark+1)  
3898 32 7b ee			ld (debug_mark+1),a  
389b 3a a5 38			ld a, (.dmark+2)  
389e 32 7c ee			ld (debug_mark+2),a  
38a1 18 03			jr .pastdmark  
38a3 ..			.dmark: db "SPS"  
38a6 f1			.pastdmark: pop af  
38a7			endm  
# End of macro DMARK
38a7						CALLMONITOR 
38a7 cd 86 12			call break_point_state  
38aa				endm  
# End of macro CALLMONITOR
38aa					endif 
38aa			 
38aa			 
38aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38aa cd ae 18			call macro_dsp_valuehl 
38ad				endm 
# End of macro FORTH_DSP_VALUEHL
38ad			 
38ad			;		push hl    ; u 
38ad					if DEBUG_FORTH_WORDS 
38ad						DMARK "SPA" 
38ad f5				push af  
38ae 3a c2 38			ld a, (.dmark)  
38b1 32 7a ee			ld (debug_mark),a  
38b4 3a c3 38			ld a, (.dmark+1)  
38b7 32 7b ee			ld (debug_mark+1),a  
38ba 3a c4 38			ld a, (.dmark+2)  
38bd 32 7c ee			ld (debug_mark+2),a  
38c0 18 03			jr .pastdmark  
38c2 ..			.dmark: db "SPA"  
38c5 f1			.pastdmark: pop af  
38c6			endm  
# End of macro DMARK
38c6						CALLMONITOR 
38c6 cd 86 12			call break_point_state  
38c9				endm  
# End of macro CALLMONITOR
38c9					endif 
38c9			 
38c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c9 cd 4a 19			call macro_forth_dsp_pop 
38cc				endm 
# End of macro FORTH_DSP_POP
38cc			;		pop hl 
38cc 4d					ld c, l 
38cd 06 00				ld b, 0 
38cf 21 75 e3				ld hl, scratch  
38d2			 
38d2					if DEBUG_FORTH_WORDS 
38d2						DMARK "SP2" 
38d2 f5				push af  
38d3 3a e7 38			ld a, (.dmark)  
38d6 32 7a ee			ld (debug_mark),a  
38d9 3a e8 38			ld a, (.dmark+1)  
38dc 32 7b ee			ld (debug_mark+1),a  
38df 3a e9 38			ld a, (.dmark+2)  
38e2 32 7c ee			ld (debug_mark+2),a  
38e5 18 03			jr .pastdmark  
38e7 ..			.dmark: db "SP2"  
38ea f1			.pastdmark: pop af  
38eb			endm  
# End of macro DMARK
38eb						CALLMONITOR 
38eb cd 86 12			call break_point_state  
38ee				endm  
# End of macro CALLMONITOR
38ee					endif 
38ee 3e 20				ld a, ' ' 
38f0 c5			.spaces1:	push bc 
38f1 77					ld (hl),a 
38f2 23					inc hl 
38f3 c1					pop bc 
38f4 10 fa				djnz .spaces1 
38f6 3e 00				ld a,0 
38f8 77					ld (hl),a 
38f9 21 75 e3				ld hl, scratch 
38fc					if DEBUG_FORTH_WORDS 
38fc						DMARK "SP3" 
38fc f5				push af  
38fd 3a 11 39			ld a, (.dmark)  
3900 32 7a ee			ld (debug_mark),a  
3903 3a 12 39			ld a, (.dmark+1)  
3906 32 7b ee			ld (debug_mark+1),a  
3909 3a 13 39			ld a, (.dmark+2)  
390c 32 7c ee			ld (debug_mark+2),a  
390f 18 03			jr .pastdmark  
3911 ..			.dmark: db "SP3"  
3914 f1			.pastdmark: pop af  
3915			endm  
# End of macro DMARK
3915						CALLMONITOR 
3915 cd 86 12			call break_point_state  
3918				endm  
# End of macro CALLMONITOR
3918					endif 
3918 cd 5b 18				call forth_apush 
391b			 
391b				       NEXTW 
391b c3 04 1a			jp macro_next 
391e				endm 
# End of macro NEXTW
391e			 
391e			 
391e			 
391e			.SCROLL: 
391e				CWHEAD .ATQ 63 "SCROLL" 6 WORD_FLAG_CODE 
391e 53				db WORD_SYS_CORE+63             
391f 4b 39			dw .ATQ            
3921 07				db 6 + 1 
3922 .. 00			db "SCROLL",0              
3929				endm 
# End of macro CWHEAD
3929			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3929					if DEBUG_FORTH_WORDS_KEY 
3929						DMARK "SCR" 
3929 f5				push af  
392a 3a 3e 39			ld a, (.dmark)  
392d 32 7a ee			ld (debug_mark),a  
3930 3a 3f 39			ld a, (.dmark+1)  
3933 32 7b ee			ld (debug_mark+1),a  
3936 3a 40 39			ld a, (.dmark+2)  
3939 32 7c ee			ld (debug_mark+2),a  
393c 18 03			jr .pastdmark  
393e ..			.dmark: db "SCR"  
3941 f1			.pastdmark: pop af  
3942			endm  
# End of macro DMARK
3942						CALLMONITOR 
3942 cd 86 12			call break_point_state  
3945				endm  
# End of macro CALLMONITOR
3945					endif 
3945			 
3945 cd 01 09			call scroll_up 
3948			;	call update_display 
3948			 
3948					NEXTW 
3948 c3 04 1a			jp macro_next 
394b				endm 
# End of macro NEXTW
394b			 
394b			 
394b			 
394b			;		; get dir 
394b			; 
394b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
394b			; 
394b			;		push hl 
394b			; 
394b			;		; destroy value TOS 
394b			; 
394b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
394b			; 
394b			;		; get count 
394b			; 
394b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
394b			; 
394b			;		push hl 
394b			; 
394b			;		; destroy value TOS 
394b			; 
394b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
394b			; 
394b			;		; one value on hl get other one back 
394b			; 
394b			;		pop bc    ; count 
394b			; 
394b			;		pop de   ; dir 
394b			; 
394b			; 
394b			;		ld b, c 
394b			; 
394b			;.scrolldir:     push bc 
394b			;		push de 
394b			; 
394b			;		ld a, 0 
394b			;		cp e 
394b			;		jr z, .scrollup  
394b			;		call scroll_down 
394b			;		jr .scrollnext 
394b			;.scrollup:	call scroll_up 
394b			; 
394b			;		 
394b			;.scrollnext: 
394b			;		pop de 
394b			;		pop bc 
394b			;		djnz .scrolldir 
394b			; 
394b			; 
394b			; 
394b			; 
394b			; 
394b			;		NEXTW 
394b			 
394b			 
394b			 
394b			 
394b			.ATQ: 
394b				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
394b 62				db WORD_SYS_CORE+78             
394c a9 39			dw .AUTODSP            
394e 04				db 3 + 1 
394f .. 00			db "AT@",0              
3953				endm 
# End of macro CWHEAD
3953			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3953					if DEBUG_FORTH_WORDS_KEY 
3953						DMARK "ATA" 
3953 f5				push af  
3954 3a 68 39			ld a, (.dmark)  
3957 32 7a ee			ld (debug_mark),a  
395a 3a 69 39			ld a, (.dmark+1)  
395d 32 7b ee			ld (debug_mark+1),a  
3960 3a 6a 39			ld a, (.dmark+2)  
3963 32 7c ee			ld (debug_mark+2),a  
3966 18 03			jr .pastdmark  
3968 ..			.dmark: db "ATA"  
396b f1			.pastdmark: pop af  
396c			endm  
# End of macro DMARK
396c						CALLMONITOR 
396c cd 86 12			call break_point_state  
396f				endm  
# End of macro CALLMONITOR
396f					endif 
396f			 
396f			 
396f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
396f cd ae 18			call macro_dsp_valuehl 
3972				endm 
# End of macro FORTH_DSP_VALUEHL
3972			 
3972					; TODO save cursor row 
3972 7d					ld a,l 
3973 fe 02				cp 2 
3975 20 04				jr nz, .crow3aq 
3977 3e 28				ld a, display_row_2 
3979 18 12				jr .ccol1aq 
397b fe 03		.crow3aq:		cp 3 
397d 20 04				jr nz, .crow4aq 
397f 3e 50				ld a, display_row_3 
3981 18 0a				jr .ccol1aq 
3983 fe 04		.crow4aq:		cp 4 
3985 20 04				jr nz, .crow1aq 
3987 3e 78				ld a, display_row_4 
3989 18 02				jr .ccol1aq 
398b 3e 00		.crow1aq:		ld a,display_row_1 
398d f5			.ccol1aq:		push af			; got row offset 
398e 6f					ld l,a 
398f 26 00				ld h,0 
3991					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3991 cd 4a 19			call macro_forth_dsp_pop 
3994				endm 
# End of macro FORTH_DSP_POP
3994					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3994 cd ae 18			call macro_dsp_valuehl 
3997				endm 
# End of macro FORTH_DSP_VALUEHL
3997					; TODO save cursor col 
3997 f1					pop af 
3998 85					add l		; add col offset 
3999			 
3999					; add current frame buffer address 
3999 2a db eb				ld hl, (display_fb_active) 
399c cd c2 0a				call addatohl 
399f			 
399f			 
399f			 
399f			 
399f					; get char frame buffer location offset in hl 
399f			 
399f 7e					ld a,(hl) 
39a0 26 00				ld h, 0 
39a2 6f					ld l, a 
39a3			 
39a3 cd 13 18				call forth_push_numhl 
39a6			 
39a6			 
39a6					NEXTW 
39a6 c3 04 1a			jp macro_next 
39a9				endm 
# End of macro NEXTW
39a9			 
39a9			.AUTODSP: 
39a9				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
39a9 63				db WORD_SYS_CORE+79             
39aa bf 39			dw .MENU            
39ac 05				db 4 + 1 
39ad .. 00			db "ADSP",0              
39b2				endm 
# End of macro CWHEAD
39b2			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
39b2			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
39b2			 
39b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b2 cd ae 18			call macro_dsp_valuehl 
39b5				endm 
# End of macro FORTH_DSP_VALUEHL
39b5			 
39b5			;		push hl 
39b5			 
39b5					; destroy value TOS 
39b5			 
39b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39b5 cd 4a 19			call macro_forth_dsp_pop 
39b8				endm 
# End of macro FORTH_DSP_POP
39b8			 
39b8			;		pop hl 
39b8			 
39b8 7d					ld a,l 
39b9 32 3c eb				ld (cli_autodisplay), a 
39bc				       NEXTW 
39bc c3 04 1a			jp macro_next 
39bf				endm 
# End of macro NEXTW
39bf			 
39bf			.MENU: 
39bf				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
39bf 70				db WORD_SYS_CORE+92             
39c0 cb 39			dw .ENDDISPLAY            
39c2 05				db 4 + 1 
39c3 .. 00			db "MENU",0              
39c8				endm 
# End of macro CWHEAD
39c8			; | MENU ( u1....ux n ut -- n ) Create a menu. Ut is the title, n is the number of menu items on stack. Push number selection to TOS | TODO 
39c8			 
39c8					; get the title address and save it 
39c8			 
39c8			;		FORTH_DSP_VALUEHL 
39c8			;		push hl 
39c8			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c8			; 
39c8			;		; get number of items on the stack 
39c8			; 
39c8			;	 
39c8			;		FORTH_DSP_VALUEHL 
39c8			;		push hl 
39c8			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c8			 
39c8			 
39c8			 
39c8			 
39c8				       NEXTW 
39c8 c3 04 1a			jp macro_next 
39cb				endm 
# End of macro NEXTW
39cb			 
39cb			 
39cb			.ENDDISPLAY: 
39cb			 
39cb			; eof 
# End of file forth_words_display.asm
39cb			include "forth_words_str.asm" 
39cb			 
39cb			; | ## String Words 
39cb			 
39cb			.PTR:   
39cb			 
39cb				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
39cb 48				db WORD_SYS_CORE+52             
39cc f8 39			dw .STYPE            
39ce 04				db 3 + 1 
39cf .. 00			db "PTR",0              
39d3				endm 
# End of macro CWHEAD
39d3			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
39d3			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
39d3			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
39d3			 
39d3					if DEBUG_FORTH_WORDS_KEY 
39d3						DMARK "PTR" 
39d3 f5				push af  
39d4 3a e8 39			ld a, (.dmark)  
39d7 32 7a ee			ld (debug_mark),a  
39da 3a e9 39			ld a, (.dmark+1)  
39dd 32 7b ee			ld (debug_mark+1),a  
39e0 3a ea 39			ld a, (.dmark+2)  
39e3 32 7c ee			ld (debug_mark+2),a  
39e6 18 03			jr .pastdmark  
39e8 ..			.dmark: db "PTR"  
39eb f1			.pastdmark: pop af  
39ec			endm  
# End of macro DMARK
39ec						CALLMONITOR 
39ec cd 86 12			call break_point_state  
39ef				endm  
# End of macro CALLMONITOR
39ef					endif 
39ef					FORTH_DSP_VALUEHL 
39ef cd ae 18			call macro_dsp_valuehl 
39f2				endm 
# End of macro FORTH_DSP_VALUEHL
39f2 cd 13 18				call forth_push_numhl 
39f5			 
39f5			 
39f5					NEXTW 
39f5 c3 04 1a			jp macro_next 
39f8				endm 
# End of macro NEXTW
39f8			.STYPE: 
39f8				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
39f8 48				db WORD_SYS_CORE+52             
39f9 47 3a			dw .UPPER            
39fb 06				db 5 + 1 
39fc .. 00			db "STYPE",0              
3a02				endm 
# End of macro CWHEAD
3a02			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3a02					if DEBUG_FORTH_WORDS_KEY 
3a02						DMARK "STY" 
3a02 f5				push af  
3a03 3a 17 3a			ld a, (.dmark)  
3a06 32 7a ee			ld (debug_mark),a  
3a09 3a 18 3a			ld a, (.dmark+1)  
3a0c 32 7b ee			ld (debug_mark+1),a  
3a0f 3a 19 3a			ld a, (.dmark+2)  
3a12 32 7c ee			ld (debug_mark+2),a  
3a15 18 03			jr .pastdmark  
3a17 ..			.dmark: db "STY"  
3a1a f1			.pastdmark: pop af  
3a1b			endm  
# End of macro DMARK
3a1b						CALLMONITOR 
3a1b cd 86 12			call break_point_state  
3a1e				endm  
# End of macro CALLMONITOR
3a1e					endif 
3a1e					FORTH_DSP 
3a1e cd 93 18			call macro_forth_dsp 
3a21				endm 
# End of macro FORTH_DSP
3a21					;v5 FORTH_DSP_VALUE 
3a21			 
3a21 7e					ld a, (hl) 
3a22			 
3a22 f5					push af 
3a23			 
3a23			; Dont destroy TOS		FORTH_DSP_POP 
3a23			 
3a23 f1					pop af 
3a24			 
3a24 fe 01				cp DS_TYPE_STR 
3a26 28 09				jr z, .typestr 
3a28			 
3a28 fe 02				cp DS_TYPE_INUM 
3a2a 28 0a				jr z, .typeinum 
3a2c			 
3a2c 21 45 3a				ld hl, .tna 
3a2f 18 0a				jr .tpush 
3a31			 
3a31 21 41 3a		.typestr:	ld hl, .tstr 
3a34 18 05				jr .tpush 
3a36 21 43 3a		.typeinum:	ld hl, .tinum 
3a39 18 00				jr .tpush 
3a3b			 
3a3b			.tpush: 
3a3b			 
3a3b cd 25 18				call forth_push_str 
3a3e			 
3a3e					NEXTW 
3a3e c3 04 1a			jp macro_next 
3a41				endm 
# End of macro NEXTW
3a41 .. 00		.tstr:	db "s",0 
3a43 .. 00		.tinum:  db "i",0 
3a45 .. 00		.tna:   db "?", 0 
3a47			 
3a47			 
3a47			.UPPER: 
3a47				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3a47 48				db WORD_SYS_CORE+52             
3a48 82 3a			dw .LOWER            
3a4a 06				db 5 + 1 
3a4b .. 00			db "UPPER",0              
3a51				endm 
# End of macro CWHEAD
3a51			; | UPPER ( s -- s ) Upper case string s  | DONE 
3a51					if DEBUG_FORTH_WORDS_KEY 
3a51						DMARK "UPR" 
3a51 f5				push af  
3a52 3a 66 3a			ld a, (.dmark)  
3a55 32 7a ee			ld (debug_mark),a  
3a58 3a 67 3a			ld a, (.dmark+1)  
3a5b 32 7b ee			ld (debug_mark+1),a  
3a5e 3a 68 3a			ld a, (.dmark+2)  
3a61 32 7c ee			ld (debug_mark+2),a  
3a64 18 03			jr .pastdmark  
3a66 ..			.dmark: db "UPR"  
3a69 f1			.pastdmark: pop af  
3a6a			endm  
# End of macro DMARK
3a6a						CALLMONITOR 
3a6a cd 86 12			call break_point_state  
3a6d				endm  
# End of macro CALLMONITOR
3a6d					endif 
3a6d			 
3a6d					FORTH_DSP 
3a6d cd 93 18			call macro_forth_dsp 
3a70				endm 
# End of macro FORTH_DSP
3a70					 
3a70			; TODO check is string type 
3a70			 
3a70					FORTH_DSP_VALUEHL 
3a70 cd ae 18			call macro_dsp_valuehl 
3a73				endm 
# End of macro FORTH_DSP_VALUEHL
3a73			; get pointer to string in hl 
3a73			 
3a73 7e			.toup:		ld a, (hl) 
3a74 fe 00				cp 0 
3a76 28 07				jr z, .toupdone 
3a78			 
3a78 cd 2f 0e				call to_upper 
3a7b			 
3a7b 77					ld (hl), a 
3a7c 23					inc hl 
3a7d 18 f4				jr .toup 
3a7f			 
3a7f					 
3a7f			 
3a7f			 
3a7f			; for each char convert to upper 
3a7f					 
3a7f			.toupdone: 
3a7f			 
3a7f			 
3a7f					NEXTW 
3a7f c3 04 1a			jp macro_next 
3a82				endm 
# End of macro NEXTW
3a82			.LOWER: 
3a82				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3a82 48				db WORD_SYS_CORE+52             
3a83 bd 3a			dw .TCASE            
3a85 06				db 5 + 1 
3a86 .. 00			db "LOWER",0              
3a8c				endm 
# End of macro CWHEAD
3a8c			; | LOWER ( s -- s ) Lower case string s  | DONE 
3a8c					if DEBUG_FORTH_WORDS_KEY 
3a8c						DMARK "LWR" 
3a8c f5				push af  
3a8d 3a a1 3a			ld a, (.dmark)  
3a90 32 7a ee			ld (debug_mark),a  
3a93 3a a2 3a			ld a, (.dmark+1)  
3a96 32 7b ee			ld (debug_mark+1),a  
3a99 3a a3 3a			ld a, (.dmark+2)  
3a9c 32 7c ee			ld (debug_mark+2),a  
3a9f 18 03			jr .pastdmark  
3aa1 ..			.dmark: db "LWR"  
3aa4 f1			.pastdmark: pop af  
3aa5			endm  
# End of macro DMARK
3aa5						CALLMONITOR 
3aa5 cd 86 12			call break_point_state  
3aa8				endm  
# End of macro CALLMONITOR
3aa8					endif 
3aa8			 
3aa8					FORTH_DSP 
3aa8 cd 93 18			call macro_forth_dsp 
3aab				endm 
# End of macro FORTH_DSP
3aab					 
3aab			; TODO check is string type 
3aab			 
3aab					FORTH_DSP_VALUEHL 
3aab cd ae 18			call macro_dsp_valuehl 
3aae				endm 
# End of macro FORTH_DSP_VALUEHL
3aae			; get pointer to string in hl 
3aae			 
3aae 7e			.tolow:		ld a, (hl) 
3aaf fe 00				cp 0 
3ab1 28 07				jr z, .tolowdone 
3ab3			 
3ab3 cd 38 0e				call to_lower 
3ab6			 
3ab6 77					ld (hl), a 
3ab7 23					inc hl 
3ab8 18 f4				jr .tolow 
3aba			 
3aba					 
3aba			 
3aba			 
3aba			; for each char convert to low 
3aba					 
3aba			.tolowdone: 
3aba					NEXTW 
3aba c3 04 1a			jp macro_next 
3abd				endm 
# End of macro NEXTW
3abd			.TCASE: 
3abd				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3abd 48				db WORD_SYS_CORE+52             
3abe f3 3b			dw .SUBSTR            
3ac0 06				db 5 + 1 
3ac1 .. 00			db "TCASE",0              
3ac7				endm 
# End of macro CWHEAD
3ac7			; | TCASE ( s -- s ) Title case string s  | DONE 
3ac7					if DEBUG_FORTH_WORDS_KEY 
3ac7						DMARK "TCS" 
3ac7 f5				push af  
3ac8 3a dc 3a			ld a, (.dmark)  
3acb 32 7a ee			ld (debug_mark),a  
3ace 3a dd 3a			ld a, (.dmark+1)  
3ad1 32 7b ee			ld (debug_mark+1),a  
3ad4 3a de 3a			ld a, (.dmark+2)  
3ad7 32 7c ee			ld (debug_mark+2),a  
3ada 18 03			jr .pastdmark  
3adc ..			.dmark: db "TCS"  
3adf f1			.pastdmark: pop af  
3ae0			endm  
# End of macro DMARK
3ae0						CALLMONITOR 
3ae0 cd 86 12			call break_point_state  
3ae3				endm  
# End of macro CALLMONITOR
3ae3					endif 
3ae3			 
3ae3					FORTH_DSP 
3ae3 cd 93 18			call macro_forth_dsp 
3ae6				endm 
# End of macro FORTH_DSP
3ae6					 
3ae6			; TODO check is string type 
3ae6			 
3ae6					FORTH_DSP_VALUEHL 
3ae6 cd ae 18			call macro_dsp_valuehl 
3ae9				endm 
# End of macro FORTH_DSP_VALUEHL
3ae9			; get pointer to string in hl 
3ae9			 
3ae9					if DEBUG_FORTH_WORDS 
3ae9						DMARK "TC1" 
3ae9 f5				push af  
3aea 3a fe 3a			ld a, (.dmark)  
3aed 32 7a ee			ld (debug_mark),a  
3af0 3a ff 3a			ld a, (.dmark+1)  
3af3 32 7b ee			ld (debug_mark+1),a  
3af6 3a 00 3b			ld a, (.dmark+2)  
3af9 32 7c ee			ld (debug_mark+2),a  
3afc 18 03			jr .pastdmark  
3afe ..			.dmark: db "TC1"  
3b01 f1			.pastdmark: pop af  
3b02			endm  
# End of macro DMARK
3b02						CALLMONITOR 
3b02 cd 86 12			call break_point_state  
3b05				endm  
# End of macro CALLMONITOR
3b05					endif 
3b05			 
3b05					; first time in turn to upper case first char 
3b05			 
3b05 7e					ld a, (hl) 
3b06 c3 90 3b				jp .totsiptou 
3b09			 
3b09			 
3b09 7e			.tot:		ld a, (hl) 
3b0a fe 00				cp 0 
3b0c ca d4 3b				jp z, .totdone 
3b0f			 
3b0f					if DEBUG_FORTH_WORDS 
3b0f						DMARK "TC2" 
3b0f f5				push af  
3b10 3a 24 3b			ld a, (.dmark)  
3b13 32 7a ee			ld (debug_mark),a  
3b16 3a 25 3b			ld a, (.dmark+1)  
3b19 32 7b ee			ld (debug_mark+1),a  
3b1c 3a 26 3b			ld a, (.dmark+2)  
3b1f 32 7c ee			ld (debug_mark+2),a  
3b22 18 03			jr .pastdmark  
3b24 ..			.dmark: db "TC2"  
3b27 f1			.pastdmark: pop af  
3b28			endm  
# End of macro DMARK
3b28						CALLMONITOR 
3b28 cd 86 12			call break_point_state  
3b2b				endm  
# End of macro CALLMONITOR
3b2b					endif 
3b2b					; check to see if current char is a space 
3b2b			 
3b2b fe 20				cp ' ' 
3b2d 28 21				jr z, .totsp 
3b2f cd 38 0e				call to_lower 
3b32					if DEBUG_FORTH_WORDS 
3b32						DMARK "TC3" 
3b32 f5				push af  
3b33 3a 47 3b			ld a, (.dmark)  
3b36 32 7a ee			ld (debug_mark),a  
3b39 3a 48 3b			ld a, (.dmark+1)  
3b3c 32 7b ee			ld (debug_mark+1),a  
3b3f 3a 49 3b			ld a, (.dmark+2)  
3b42 32 7c ee			ld (debug_mark+2),a  
3b45 18 03			jr .pastdmark  
3b47 ..			.dmark: db "TC3"  
3b4a f1			.pastdmark: pop af  
3b4b			endm  
# End of macro DMARK
3b4b						CALLMONITOR 
3b4b cd 86 12			call break_point_state  
3b4e				endm  
# End of macro CALLMONITOR
3b4e					endif 
3b4e 18 63				jr .totnxt 
3b50			 
3b50			.totsp:         ; on a space, find next char which should be upper 
3b50			 
3b50					if DEBUG_FORTH_WORDS 
3b50						DMARK "TC4" 
3b50 f5				push af  
3b51 3a 65 3b			ld a, (.dmark)  
3b54 32 7a ee			ld (debug_mark),a  
3b57 3a 66 3b			ld a, (.dmark+1)  
3b5a 32 7b ee			ld (debug_mark+1),a  
3b5d 3a 67 3b			ld a, (.dmark+2)  
3b60 32 7c ee			ld (debug_mark+2),a  
3b63 18 03			jr .pastdmark  
3b65 ..			.dmark: db "TC4"  
3b68 f1			.pastdmark: pop af  
3b69			endm  
# End of macro DMARK
3b69						CALLMONITOR 
3b69 cd 86 12			call break_point_state  
3b6c				endm  
# End of macro CALLMONITOR
3b6c					endif 
3b6c					;; 
3b6c			 
3b6c fe 20				cp ' ' 
3b6e 20 20				jr nz, .totsiptou 
3b70 23					inc hl 
3b71 7e					ld a, (hl) 
3b72					if DEBUG_FORTH_WORDS 
3b72						DMARK "TC5" 
3b72 f5				push af  
3b73 3a 87 3b			ld a, (.dmark)  
3b76 32 7a ee			ld (debug_mark),a  
3b79 3a 88 3b			ld a, (.dmark+1)  
3b7c 32 7b ee			ld (debug_mark+1),a  
3b7f 3a 89 3b			ld a, (.dmark+2)  
3b82 32 7c ee			ld (debug_mark+2),a  
3b85 18 03			jr .pastdmark  
3b87 ..			.dmark: db "TC5"  
3b8a f1			.pastdmark: pop af  
3b8b			endm  
# End of macro DMARK
3b8b						CALLMONITOR 
3b8b cd 86 12			call break_point_state  
3b8e				endm  
# End of macro CALLMONITOR
3b8e					endif 
3b8e 18 c0				jr .totsp 
3b90 fe 00		.totsiptou:    cp 0 
3b92 28 40				jr z, .totdone 
3b94					; not space and not zero term so upper case it 
3b94 cd 2f 0e				call to_upper 
3b97			 
3b97					if DEBUG_FORTH_WORDS 
3b97						DMARK "TC6" 
3b97 f5				push af  
3b98 3a ac 3b			ld a, (.dmark)  
3b9b 32 7a ee			ld (debug_mark),a  
3b9e 3a ad 3b			ld a, (.dmark+1)  
3ba1 32 7b ee			ld (debug_mark+1),a  
3ba4 3a ae 3b			ld a, (.dmark+2)  
3ba7 32 7c ee			ld (debug_mark+2),a  
3baa 18 03			jr .pastdmark  
3bac ..			.dmark: db "TC6"  
3baf f1			.pastdmark: pop af  
3bb0			endm  
# End of macro DMARK
3bb0						CALLMONITOR 
3bb0 cd 86 12			call break_point_state  
3bb3				endm  
# End of macro CALLMONITOR
3bb3					endif 
3bb3			 
3bb3			 
3bb3			.totnxt: 
3bb3			 
3bb3 77					ld (hl), a 
3bb4 23					inc hl 
3bb5					if DEBUG_FORTH_WORDS 
3bb5						DMARK "TC7" 
3bb5 f5				push af  
3bb6 3a ca 3b			ld a, (.dmark)  
3bb9 32 7a ee			ld (debug_mark),a  
3bbc 3a cb 3b			ld a, (.dmark+1)  
3bbf 32 7b ee			ld (debug_mark+1),a  
3bc2 3a cc 3b			ld a, (.dmark+2)  
3bc5 32 7c ee			ld (debug_mark+2),a  
3bc8 18 03			jr .pastdmark  
3bca ..			.dmark: db "TC7"  
3bcd f1			.pastdmark: pop af  
3bce			endm  
# End of macro DMARK
3bce						CALLMONITOR 
3bce cd 86 12			call break_point_state  
3bd1				endm  
# End of macro CALLMONITOR
3bd1					endif 
3bd1 c3 09 3b				jp .tot 
3bd4			 
3bd4					 
3bd4			 
3bd4			 
3bd4			; for each char convert to low 
3bd4					 
3bd4			.totdone: 
3bd4					if DEBUG_FORTH_WORDS 
3bd4						DMARK "TCd" 
3bd4 f5				push af  
3bd5 3a e9 3b			ld a, (.dmark)  
3bd8 32 7a ee			ld (debug_mark),a  
3bdb 3a ea 3b			ld a, (.dmark+1)  
3bde 32 7b ee			ld (debug_mark+1),a  
3be1 3a eb 3b			ld a, (.dmark+2)  
3be4 32 7c ee			ld (debug_mark+2),a  
3be7 18 03			jr .pastdmark  
3be9 ..			.dmark: db "TCd"  
3bec f1			.pastdmark: pop af  
3bed			endm  
# End of macro DMARK
3bed						CALLMONITOR 
3bed cd 86 12			call break_point_state  
3bf0				endm  
# End of macro CALLMONITOR
3bf0					endif 
3bf0					NEXTW 
3bf0 c3 04 1a			jp macro_next 
3bf3				endm 
# End of macro NEXTW
3bf3			 
3bf3			.SUBSTR: 
3bf3				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3bf3 48				db WORD_SYS_CORE+52             
3bf4 51 3c			dw .LEFT            
3bf6 07				db 6 + 1 
3bf7 .. 00			db "SUBSTR",0              
3bfe				endm 
# End of macro CWHEAD
3bfe			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3bfe			 
3bfe					if DEBUG_FORTH_WORDS_KEY 
3bfe						DMARK "SST" 
3bfe f5				push af  
3bff 3a 13 3c			ld a, (.dmark)  
3c02 32 7a ee			ld (debug_mark),a  
3c05 3a 14 3c			ld a, (.dmark+1)  
3c08 32 7b ee			ld (debug_mark+1),a  
3c0b 3a 15 3c			ld a, (.dmark+2)  
3c0e 32 7c ee			ld (debug_mark+2),a  
3c11 18 03			jr .pastdmark  
3c13 ..			.dmark: db "SST"  
3c16 f1			.pastdmark: pop af  
3c17			endm  
# End of macro DMARK
3c17						CALLMONITOR 
3c17 cd 86 12			call break_point_state  
3c1a				endm  
# End of macro CALLMONITOR
3c1a					endif 
3c1a			; TODO check string type 
3c1a					FORTH_DSP_VALUEHL 
3c1a cd ae 18			call macro_dsp_valuehl 
3c1d				endm 
# End of macro FORTH_DSP_VALUEHL
3c1d			 
3c1d e5					push hl      ; string length 
3c1e			 
3c1e					FORTH_DSP_POP 
3c1e cd 4a 19			call macro_forth_dsp_pop 
3c21				endm 
# End of macro FORTH_DSP_POP
3c21			 
3c21					FORTH_DSP_VALUEHL 
3c21 cd ae 18			call macro_dsp_valuehl 
3c24				endm 
# End of macro FORTH_DSP_VALUEHL
3c24			 
3c24 e5					push hl     ; start char 
3c25			 
3c25					FORTH_DSP_POP 
3c25 cd 4a 19			call macro_forth_dsp_pop 
3c28				endm 
# End of macro FORTH_DSP_POP
3c28			 
3c28			 
3c28					FORTH_DSP_VALUE 
3c28 cd 97 18			call macro_forth_dsp_value 
3c2b				endm 
# End of macro FORTH_DSP_VALUE
3c2b			 
3c2b d1					pop de    ; get start post offset 
3c2c			 
3c2c 19					add hl, de    ; starting offset 
3c2d			 
3c2d c1					pop bc 
3c2e c5					push bc      ; grab size of string 
3c2f			 
3c2f e5					push hl    ; save string start  
3c30			 
3c30 26 00				ld h, 0 
3c32 69					ld l, c 
3c33 23					inc hl 
3c34 23					inc hl 
3c35			 
3c35 cd 89 0f				call malloc 
3c38				if DEBUG_FORTH_MALLOC_GUARD 
3c38 cc 67 42				call z,malloc_error 
3c3b				endif 
3c3b			 
3c3b eb					ex de, hl      ; save malloc area for string copy 
3c3c e1					pop hl    ; get back source 
3c3d c1					pop bc    ; get length of string back 
3c3e			 
3c3e d5					push de    ; save malloc area for after we push 
3c3f ed b0				ldir     ; copy substr 
3c41			 
3c41			 
3c41 eb					ex de, hl 
3c42 3e 00				ld a, 0 
3c44 77					ld (hl), a   ; term substr 
3c45			 
3c45					 
3c45 e1					pop hl    ; get malloc so we can push it 
3c46 e5					push hl   ; save so we can free it afterwards 
3c47			 
3c47 cd 25 18				call forth_push_str 
3c4a			 
3c4a e1					pop hl 
3c4b cd 53 10				call free 
3c4e			 
3c4e					 
3c4e					 
3c4e			 
3c4e			 
3c4e					NEXTW 
3c4e c3 04 1a			jp macro_next 
3c51				endm 
# End of macro NEXTW
3c51			 
3c51			.LEFT: 
3c51				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3c51 48				db WORD_SYS_CORE+52             
3c52 79 3c			dw .RIGHT            
3c54 05				db 4 + 1 
3c55 .. 00			db "LEFT",0              
3c5a				endm 
# End of macro CWHEAD
3c5a			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3c5a					if DEBUG_FORTH_WORDS_KEY 
3c5a						DMARK "LEF" 
3c5a f5				push af  
3c5b 3a 6f 3c			ld a, (.dmark)  
3c5e 32 7a ee			ld (debug_mark),a  
3c61 3a 70 3c			ld a, (.dmark+1)  
3c64 32 7b ee			ld (debug_mark+1),a  
3c67 3a 71 3c			ld a, (.dmark+2)  
3c6a 32 7c ee			ld (debug_mark+2),a  
3c6d 18 03			jr .pastdmark  
3c6f ..			.dmark: db "LEF"  
3c72 f1			.pastdmark: pop af  
3c73			endm  
# End of macro DMARK
3c73						CALLMONITOR 
3c73 cd 86 12			call break_point_state  
3c76				endm  
# End of macro CALLMONITOR
3c76					endif 
3c76			 
3c76					NEXTW 
3c76 c3 04 1a			jp macro_next 
3c79				endm 
# End of macro NEXTW
3c79			.RIGHT: 
3c79				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3c79 48				db WORD_SYS_CORE+52             
3c7a a2 3c			dw .STR2NUM            
3c7c 06				db 5 + 1 
3c7d .. 00			db "RIGHT",0              
3c83				endm 
# End of macro CWHEAD
3c83			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3c83					if DEBUG_FORTH_WORDS_KEY 
3c83						DMARK "RIG" 
3c83 f5				push af  
3c84 3a 98 3c			ld a, (.dmark)  
3c87 32 7a ee			ld (debug_mark),a  
3c8a 3a 99 3c			ld a, (.dmark+1)  
3c8d 32 7b ee			ld (debug_mark+1),a  
3c90 3a 9a 3c			ld a, (.dmark+2)  
3c93 32 7c ee			ld (debug_mark+2),a  
3c96 18 03			jr .pastdmark  
3c98 ..			.dmark: db "RIG"  
3c9b f1			.pastdmark: pop af  
3c9c			endm  
# End of macro DMARK
3c9c						CALLMONITOR 
3c9c cd 86 12			call break_point_state  
3c9f				endm  
# End of macro CALLMONITOR
3c9f					endif 
3c9f			 
3c9f					NEXTW 
3c9f c3 04 1a			jp macro_next 
3ca2				endm 
# End of macro NEXTW
3ca2			 
3ca2			 
3ca2			.STR2NUM: 
3ca2				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3ca2 48				db WORD_SYS_CORE+52             
3ca3 2e 3d			dw .NUM2STR            
3ca5 08				db 7 + 1 
3ca6 .. 00			db "STR2NUM",0              
3cae				endm 
# End of macro CWHEAD
3cae			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3cae			 
3cae			 
3cae			; TODO STR type check to do 
3cae					if DEBUG_FORTH_WORDS_KEY 
3cae						DMARK "S2N" 
3cae f5				push af  
3caf 3a c3 3c			ld a, (.dmark)  
3cb2 32 7a ee			ld (debug_mark),a  
3cb5 3a c4 3c			ld a, (.dmark+1)  
3cb8 32 7b ee			ld (debug_mark+1),a  
3cbb 3a c5 3c			ld a, (.dmark+2)  
3cbe 32 7c ee			ld (debug_mark+2),a  
3cc1 18 03			jr .pastdmark  
3cc3 ..			.dmark: db "S2N"  
3cc6 f1			.pastdmark: pop af  
3cc7			endm  
# End of macro DMARK
3cc7						CALLMONITOR 
3cc7 cd 86 12			call break_point_state  
3cca				endm  
# End of macro CALLMONITOR
3cca					endif 
3cca			 
3cca					;FORTH_DSP 
3cca					FORTH_DSP_VALUE 
3cca cd 97 18			call macro_forth_dsp_value 
3ccd				endm 
# End of macro FORTH_DSP_VALUE
3ccd					;inc hl 
3ccd			 
3ccd eb					ex de, hl 
3cce					if DEBUG_FORTH_WORDS 
3cce						DMARK "S2a" 
3cce f5				push af  
3ccf 3a e3 3c			ld a, (.dmark)  
3cd2 32 7a ee			ld (debug_mark),a  
3cd5 3a e4 3c			ld a, (.dmark+1)  
3cd8 32 7b ee			ld (debug_mark+1),a  
3cdb 3a e5 3c			ld a, (.dmark+2)  
3cde 32 7c ee			ld (debug_mark+2),a  
3ce1 18 03			jr .pastdmark  
3ce3 ..			.dmark: db "S2a"  
3ce6 f1			.pastdmark: pop af  
3ce7			endm  
# End of macro DMARK
3ce7						CALLMONITOR 
3ce7 cd 86 12			call break_point_state  
3cea				endm  
# End of macro CALLMONITOR
3cea					endif 
3cea cd b7 0e				call string_to_uint16 
3ced			 
3ced					if DEBUG_FORTH_WORDS 
3ced						DMARK "S2b" 
3ced f5				push af  
3cee 3a 02 3d			ld a, (.dmark)  
3cf1 32 7a ee			ld (debug_mark),a  
3cf4 3a 03 3d			ld a, (.dmark+1)  
3cf7 32 7b ee			ld (debug_mark+1),a  
3cfa 3a 04 3d			ld a, (.dmark+2)  
3cfd 32 7c ee			ld (debug_mark+2),a  
3d00 18 03			jr .pastdmark  
3d02 ..			.dmark: db "S2b"  
3d05 f1			.pastdmark: pop af  
3d06			endm  
# End of macro DMARK
3d06						CALLMONITOR 
3d06 cd 86 12			call break_point_state  
3d09				endm  
# End of macro CALLMONITOR
3d09					endif 
3d09			;		push hl 
3d09					FORTH_DSP_POP 
3d09 cd 4a 19			call macro_forth_dsp_pop 
3d0c				endm 
# End of macro FORTH_DSP_POP
3d0c			;		pop hl 
3d0c					 
3d0c					if DEBUG_FORTH_WORDS 
3d0c						DMARK "S2b" 
3d0c f5				push af  
3d0d 3a 21 3d			ld a, (.dmark)  
3d10 32 7a ee			ld (debug_mark),a  
3d13 3a 22 3d			ld a, (.dmark+1)  
3d16 32 7b ee			ld (debug_mark+1),a  
3d19 3a 23 3d			ld a, (.dmark+2)  
3d1c 32 7c ee			ld (debug_mark+2),a  
3d1f 18 03			jr .pastdmark  
3d21 ..			.dmark: db "S2b"  
3d24 f1			.pastdmark: pop af  
3d25			endm  
# End of macro DMARK
3d25						CALLMONITOR 
3d25 cd 86 12			call break_point_state  
3d28				endm  
# End of macro CALLMONITOR
3d28					endif 
3d28 cd 13 18				call forth_push_numhl	 
3d2b			 
3d2b				 
3d2b				       NEXTW 
3d2b c3 04 1a			jp macro_next 
3d2e				endm 
# End of macro NEXTW
3d2e			.NUM2STR: 
3d2e				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3d2e 48				db WORD_SYS_CORE+52             
3d2f 3d 3d			dw .CONCAT            
3d31 08				db 7 + 1 
3d32 .. 00			db "NUM2STR",0              
3d3a				endm 
# End of macro CWHEAD
3d3a			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
3d3a			 
3d3a			;		; malloc a string to target 
3d3a			;		ld hl, 10     ; TODO max string size should be fine 
3d3a			;		call malloc 
3d3a			;		push hl    ; save malloc location 
3d3a			; 
3d3a			; 
3d3a			;; TODO check int type 
3d3a			;		FORTH_DSP_VALUEHL 
3d3a			;		ld a, l 
3d3a			;		call DispAToASCII   
3d3a			;;TODO need to chage above call to dump into string 
3d3a			; 
3d3a			; 
3d3a			 
3d3a				       NEXTW 
3d3a c3 04 1a			jp macro_next 
3d3d				endm 
# End of macro NEXTW
3d3d			 
3d3d			.CONCAT: 
3d3d				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
3d3d 48				db WORD_SYS_CORE+52             
3d3e f0 3d			dw .FIND            
3d40 07				db 6 + 1 
3d41 .. 00			db "CONCAT",0              
3d48				endm 
# End of macro CWHEAD
3d48			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
3d48			 
3d48			; TODO check string type 
3d48			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
3d48			 
3d48					if DEBUG_FORTH_WORDS_KEY 
3d48						DMARK "CON" 
3d48 f5				push af  
3d49 3a 5d 3d			ld a, (.dmark)  
3d4c 32 7a ee			ld (debug_mark),a  
3d4f 3a 5e 3d			ld a, (.dmark+1)  
3d52 32 7b ee			ld (debug_mark+1),a  
3d55 3a 5f 3d			ld a, (.dmark+2)  
3d58 32 7c ee			ld (debug_mark+2),a  
3d5b 18 03			jr .pastdmark  
3d5d ..			.dmark: db "CON"  
3d60 f1			.pastdmark: pop af  
3d61			endm  
# End of macro DMARK
3d61						CALLMONITOR 
3d61 cd 86 12			call break_point_state  
3d64				endm  
# End of macro CALLMONITOR
3d64					endif 
3d64			 
3d64			 
3d64					FORTH_DSP_VALUE 
3d64 cd 97 18			call macro_forth_dsp_value 
3d67				endm 
# End of macro FORTH_DSP_VALUE
3d67 e5					push hl   ; s2 
3d68			 
3d68					FORTH_DSP_POP 
3d68 cd 4a 19			call macro_forth_dsp_pop 
3d6b				endm 
# End of macro FORTH_DSP_POP
3d6b			 
3d6b					FORTH_DSP_VALUE 
3d6b cd 97 18			call macro_forth_dsp_value 
3d6e				endm 
# End of macro FORTH_DSP_VALUE
3d6e			 
3d6e e5					push hl   ; s1 
3d6f			 
3d6f					FORTH_DSP_POP 
3d6f cd 4a 19			call macro_forth_dsp_pop 
3d72				endm 
# End of macro FORTH_DSP_POP
3d72					 
3d72			 
3d72					; copy s1 
3d72			 
3d72				 
3d72					; save ptr 
3d72 e1					pop hl  
3d73 e5					push hl 
3d74 3e 00				ld a, 0 
3d76 cd 2b 0f				call strlent 
3d79					;inc hl    ; zer0 
3d79 06 00				ld b, 0 
3d7b 4d					ld c, l 
3d7c e1					pop hl		 
3d7d 11 75 e3				ld de, scratch	 
3d80					if DEBUG_FORTH_WORDS 
3d80						DMARK "CO1" 
3d80 f5				push af  
3d81 3a 95 3d			ld a, (.dmark)  
3d84 32 7a ee			ld (debug_mark),a  
3d87 3a 96 3d			ld a, (.dmark+1)  
3d8a 32 7b ee			ld (debug_mark+1),a  
3d8d 3a 97 3d			ld a, (.dmark+2)  
3d90 32 7c ee			ld (debug_mark+2),a  
3d93 18 03			jr .pastdmark  
3d95 ..			.dmark: db "CO1"  
3d98 f1			.pastdmark: pop af  
3d99			endm  
# End of macro DMARK
3d99						CALLMONITOR 
3d99 cd 86 12			call break_point_state  
3d9c				endm  
# End of macro CALLMONITOR
3d9c					endif 
3d9c ed b0				ldir 
3d9e			 
3d9e e1					pop hl 
3d9f e5					push hl 
3da0 d5					push de 
3da1			 
3da1			 
3da1 3e 00				ld a, 0 
3da3 cd 2b 0f				call strlent 
3da6 23					inc hl    ; zer0 
3da7 23					inc hl 
3da8 06 00				ld b, 0 
3daa 4d					ld c, l 
3dab d1					pop de 
3dac e1					pop hl		 
3dad					if DEBUG_FORTH_WORDS 
3dad						DMARK "CO2" 
3dad f5				push af  
3dae 3a c2 3d			ld a, (.dmark)  
3db1 32 7a ee			ld (debug_mark),a  
3db4 3a c3 3d			ld a, (.dmark+1)  
3db7 32 7b ee			ld (debug_mark+1),a  
3dba 3a c4 3d			ld a, (.dmark+2)  
3dbd 32 7c ee			ld (debug_mark+2),a  
3dc0 18 03			jr .pastdmark  
3dc2 ..			.dmark: db "CO2"  
3dc5 f1			.pastdmark: pop af  
3dc6			endm  
# End of macro DMARK
3dc6						CALLMONITOR 
3dc6 cd 86 12			call break_point_state  
3dc9				endm  
# End of macro CALLMONITOR
3dc9					endif 
3dc9 ed b0				ldir 
3dcb			 
3dcb			 
3dcb			 
3dcb 21 75 e3				ld hl, scratch 
3dce					if DEBUG_FORTH_WORDS 
3dce						DMARK "CO5" 
3dce f5				push af  
3dcf 3a e3 3d			ld a, (.dmark)  
3dd2 32 7a ee			ld (debug_mark),a  
3dd5 3a e4 3d			ld a, (.dmark+1)  
3dd8 32 7b ee			ld (debug_mark+1),a  
3ddb 3a e5 3d			ld a, (.dmark+2)  
3dde 32 7c ee			ld (debug_mark+2),a  
3de1 18 03			jr .pastdmark  
3de3 ..			.dmark: db "CO5"  
3de6 f1			.pastdmark: pop af  
3de7			endm  
# End of macro DMARK
3de7						CALLMONITOR 
3de7 cd 86 12			call break_point_state  
3dea				endm  
# End of macro CALLMONITOR
3dea					endif 
3dea			 
3dea cd 25 18				call forth_push_str 
3ded			 
3ded			 
3ded			 
3ded			 
3ded				       NEXTW 
3ded c3 04 1a			jp macro_next 
3df0				endm 
# End of macro NEXTW
3df0			 
3df0			 
3df0			.FIND: 
3df0				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
3df0 4b				db WORD_SYS_CORE+55             
3df1 ae 3e			dw .LEN            
3df3 05				db 4 + 1 
3df4 .. 00			db "FIND",0              
3df9				endm 
# End of macro CWHEAD
3df9			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
3df9			 
3df9					if DEBUG_FORTH_WORDS_KEY 
3df9						DMARK "FND" 
3df9 f5				push af  
3dfa 3a 0e 3e			ld a, (.dmark)  
3dfd 32 7a ee			ld (debug_mark),a  
3e00 3a 0f 3e			ld a, (.dmark+1)  
3e03 32 7b ee			ld (debug_mark+1),a  
3e06 3a 10 3e			ld a, (.dmark+2)  
3e09 32 7c ee			ld (debug_mark+2),a  
3e0c 18 03			jr .pastdmark  
3e0e ..			.dmark: db "FND"  
3e11 f1			.pastdmark: pop af  
3e12			endm  
# End of macro DMARK
3e12						CALLMONITOR 
3e12 cd 86 12			call break_point_state  
3e15				endm  
# End of macro CALLMONITOR
3e15					endif 
3e15			 
3e15			; TODO check string type 
3e15					FORTH_DSP_VALUE 
3e15 cd 97 18			call macro_forth_dsp_value 
3e18				endm 
# End of macro FORTH_DSP_VALUE
3e18			 
3e18 e5					push hl    
3e19 7e					ld a,(hl)    ; char to find   
3e1a			; TODO change char to substr 
3e1a			 
3e1a f5					push af 
3e1b					 
3e1b			 
3e1b			 
3e1b					if DEBUG_FORTH_WORDS 
3e1b						DMARK "FN1" 
3e1b f5				push af  
3e1c 3a 30 3e			ld a, (.dmark)  
3e1f 32 7a ee			ld (debug_mark),a  
3e22 3a 31 3e			ld a, (.dmark+1)  
3e25 32 7b ee			ld (debug_mark+1),a  
3e28 3a 32 3e			ld a, (.dmark+2)  
3e2b 32 7c ee			ld (debug_mark+2),a  
3e2e 18 03			jr .pastdmark  
3e30 ..			.dmark: db "FN1"  
3e33 f1			.pastdmark: pop af  
3e34			endm  
# End of macro DMARK
3e34						CALLMONITOR 
3e34 cd 86 12			call break_point_state  
3e37				endm  
# End of macro CALLMONITOR
3e37					endif 
3e37			 
3e37					FORTH_DSP_POP 
3e37 cd 4a 19			call macro_forth_dsp_pop 
3e3a				endm 
# End of macro FORTH_DSP_POP
3e3a			 
3e3a					; string to search 
3e3a			 
3e3a					FORTH_DSP_VALUE 
3e3a cd 97 18			call macro_forth_dsp_value 
3e3d				endm 
# End of macro FORTH_DSP_VALUE
3e3d			 
3e3d d1					pop de  ; d is char to find  
3e3e			 
3e3e					if DEBUG_FORTH_WORDS 
3e3e						DMARK "FN2" 
3e3e f5				push af  
3e3f 3a 53 3e			ld a, (.dmark)  
3e42 32 7a ee			ld (debug_mark),a  
3e45 3a 54 3e			ld a, (.dmark+1)  
3e48 32 7b ee			ld (debug_mark+1),a  
3e4b 3a 55 3e			ld a, (.dmark+2)  
3e4e 32 7c ee			ld (debug_mark+2),a  
3e51 18 03			jr .pastdmark  
3e53 ..			.dmark: db "FN2"  
3e56 f1			.pastdmark: pop af  
3e57			endm  
# End of macro DMARK
3e57						CALLMONITOR 
3e57 cd 86 12			call break_point_state  
3e5a				endm  
# End of macro CALLMONITOR
3e5a					endif 
3e5a					 
3e5a 01 00 00				ld bc, 0 
3e5d 7e			.findchar:      ld a,(hl) 
3e5e fe 00				cp 0   		 
3e60 28 27				jr z, .finddone     
3e62 ba					cp d 
3e63 28 20				jr z, .foundchar 
3e65 03					inc bc 
3e66 23					inc hl 
3e67					if DEBUG_FORTH_WORDS 
3e67						DMARK "FN3" 
3e67 f5				push af  
3e68 3a 7c 3e			ld a, (.dmark)  
3e6b 32 7a ee			ld (debug_mark),a  
3e6e 3a 7d 3e			ld a, (.dmark+1)  
3e71 32 7b ee			ld (debug_mark+1),a  
3e74 3a 7e 3e			ld a, (.dmark+2)  
3e77 32 7c ee			ld (debug_mark+2),a  
3e7a 18 03			jr .pastdmark  
3e7c ..			.dmark: db "FN3"  
3e7f f1			.pastdmark: pop af  
3e80			endm  
# End of macro DMARK
3e80						CALLMONITOR 
3e80 cd 86 12			call break_point_state  
3e83				endm  
# End of macro CALLMONITOR
3e83					endif 
3e83 18 d8				jr .findchar 
3e85			 
3e85			 
3e85 c5			.foundchar:	push bc 
3e86 e1					pop hl 
3e87 18 03				jr .findexit 
3e89			 
3e89			 
3e89							 
3e89			 
3e89			.finddone:     ; got to end of string with no find 
3e89 21 00 00				ld hl, 0 
3e8c			.findexit: 
3e8c			 
3e8c					if DEBUG_FORTH_WORDS 
3e8c						DMARK "FNd" 
3e8c f5				push af  
3e8d 3a a1 3e			ld a, (.dmark)  
3e90 32 7a ee			ld (debug_mark),a  
3e93 3a a2 3e			ld a, (.dmark+1)  
3e96 32 7b ee			ld (debug_mark+1),a  
3e99 3a a3 3e			ld a, (.dmark+2)  
3e9c 32 7c ee			ld (debug_mark+2),a  
3e9f 18 03			jr .pastdmark  
3ea1 ..			.dmark: db "FNd"  
3ea4 f1			.pastdmark: pop af  
3ea5			endm  
# End of macro DMARK
3ea5						CALLMONITOR 
3ea5 cd 86 12			call break_point_state  
3ea8				endm  
# End of macro CALLMONITOR
3ea8					endif 
3ea8 cd 13 18			call forth_push_numhl 
3eab			 
3eab				       NEXTW 
3eab c3 04 1a			jp macro_next 
3eae				endm 
# End of macro NEXTW
3eae			 
3eae			.LEN: 
3eae				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
3eae 4c				db WORD_SYS_CORE+56             
3eaf e3 3e			dw .CHAR            
3eb1 06				db 5 + 1 
3eb2 .. 00			db "COUNT",0              
3eb8				endm 
# End of macro CWHEAD
3eb8			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
3eb8			 
3eb8					if DEBUG_FORTH_WORDS_KEY 
3eb8						DMARK "CNT" 
3eb8 f5				push af  
3eb9 3a cd 3e			ld a, (.dmark)  
3ebc 32 7a ee			ld (debug_mark),a  
3ebf 3a ce 3e			ld a, (.dmark+1)  
3ec2 32 7b ee			ld (debug_mark+1),a  
3ec5 3a cf 3e			ld a, (.dmark+2)  
3ec8 32 7c ee			ld (debug_mark+2),a  
3ecb 18 03			jr .pastdmark  
3ecd ..			.dmark: db "CNT"  
3ed0 f1			.pastdmark: pop af  
3ed1			endm  
# End of macro DMARK
3ed1						CALLMONITOR 
3ed1 cd 86 12			call break_point_state  
3ed4				endm  
# End of macro CALLMONITOR
3ed4					endif 
3ed4			; TODO check string type 
3ed4					FORTH_DSP 
3ed4 cd 93 18			call macro_forth_dsp 
3ed7				endm 
# End of macro FORTH_DSP
3ed7					;v5FORTH_DSP_VALUE 
3ed7			 
3ed7 23					inc hl 
3ed8			 
3ed8 3e 00				ld a, 0 
3eda cd 2b 0f				call strlent 
3edd			 
3edd cd 13 18				call forth_push_numhl 
3ee0			 
3ee0			 
3ee0			 
3ee0				       NEXTW 
3ee0 c3 04 1a			jp macro_next 
3ee3				endm 
# End of macro NEXTW
3ee3			.CHAR: 
3ee3				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
3ee3 4d				db WORD_SYS_CORE+57             
3ee4 19 3f			dw .ENDSTR            
3ee6 05				db 4 + 1 
3ee7 .. 00			db "CHAR",0              
3eec				endm 
# End of macro CWHEAD
3eec			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
3eec					if DEBUG_FORTH_WORDS_KEY 
3eec						DMARK "CHR" 
3eec f5				push af  
3eed 3a 01 3f			ld a, (.dmark)  
3ef0 32 7a ee			ld (debug_mark),a  
3ef3 3a 02 3f			ld a, (.dmark+1)  
3ef6 32 7b ee			ld (debug_mark+1),a  
3ef9 3a 03 3f			ld a, (.dmark+2)  
3efc 32 7c ee			ld (debug_mark+2),a  
3eff 18 03			jr .pastdmark  
3f01 ..			.dmark: db "CHR"  
3f04 f1			.pastdmark: pop af  
3f05			endm  
# End of macro DMARK
3f05						CALLMONITOR 
3f05 cd 86 12			call break_point_state  
3f08				endm  
# End of macro CALLMONITOR
3f08					endif 
3f08					FORTH_DSP 
3f08 cd 93 18			call macro_forth_dsp 
3f0b				endm 
# End of macro FORTH_DSP
3f0b					;v5 FORTH_DSP_VALUE 
3f0b 23					inc hl      ; now at start of numeric as string 
3f0c			 
3f0c			;		push hl 
3f0c			 
3f0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f0c cd 4a 19			call macro_forth_dsp_pop 
3f0f				endm 
# End of macro FORTH_DSP_POP
3f0f			 
3f0f			;		pop hl 
3f0f			 
3f0f					; push the content of a onto the stack as a value 
3f0f			 
3f0f 7e					ld a,(hl)   ; get char 
3f10 26 00				ld h,0 
3f12 6f					ld l,a 
3f13 cd 13 18				call forth_push_numhl 
3f16			 
3f16				       NEXTW 
3f16 c3 04 1a			jp macro_next 
3f19				endm 
# End of macro NEXTW
3f19			 
3f19			 
3f19			 
3f19			 
3f19			.ENDSTR: 
3f19			; eof 
3f19			 
# End of file forth_words_str.asm
3f19			include "forth_words_key.asm" 
3f19			 
3f19			; | ## Keyboard Words 
3f19			 
3f19			.KEY: 
3f19				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
3f19 3e				db WORD_SYS_CORE+42             
3f1a 49 3f			dw .WAITK            
3f1c 04				db 3 + 1 
3f1d .. 00			db "KEY",0              
3f21				endm 
# End of macro CWHEAD
3f21			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
3f21			 
3f21					if DEBUG_FORTH_WORDS_KEY 
3f21						DMARK "KEY" 
3f21 f5				push af  
3f22 3a 36 3f			ld a, (.dmark)  
3f25 32 7a ee			ld (debug_mark),a  
3f28 3a 37 3f			ld a, (.dmark+1)  
3f2b 32 7b ee			ld (debug_mark+1),a  
3f2e 3a 38 3f			ld a, (.dmark+2)  
3f31 32 7c ee			ld (debug_mark+2),a  
3f34 18 03			jr .pastdmark  
3f36 ..			.dmark: db "KEY"  
3f39 f1			.pastdmark: pop af  
3f3a			endm  
# End of macro DMARK
3f3a						CALLMONITOR 
3f3a cd 86 12			call break_point_state  
3f3d				endm  
# End of macro CALLMONITOR
3f3d					endif 
3f3d			; TODO currently waits 
3f3d cd f1 55				call cin 
3f40					;call cin_wait 
3f40 6f					ld l, a 
3f41 26 00				ld h, 0 
3f43 cd 13 18				call forth_push_numhl 
3f46					NEXTW 
3f46 c3 04 1a			jp macro_next 
3f49				endm 
# End of macro NEXTW
3f49			.WAITK: 
3f49				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
3f49 3f				db WORD_SYS_CORE+43             
3f4a 7b 3f			dw .ACCEPT            
3f4c 06				db 5 + 1 
3f4d .. 00			db "WAITK",0              
3f53				endm 
# End of macro CWHEAD
3f53			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
3f53					if DEBUG_FORTH_WORDS_KEY 
3f53						DMARK "WAI" 
3f53 f5				push af  
3f54 3a 68 3f			ld a, (.dmark)  
3f57 32 7a ee			ld (debug_mark),a  
3f5a 3a 69 3f			ld a, (.dmark+1)  
3f5d 32 7b ee			ld (debug_mark+1),a  
3f60 3a 6a 3f			ld a, (.dmark+2)  
3f63 32 7c ee			ld (debug_mark+2),a  
3f66 18 03			jr .pastdmark  
3f68 ..			.dmark: db "WAI"  
3f6b f1			.pastdmark: pop af  
3f6c			endm  
# End of macro DMARK
3f6c						CALLMONITOR 
3f6c cd 86 12			call break_point_state  
3f6f				endm  
# End of macro CALLMONITOR
3f6f					endif 
3f6f cd e9 55				call cin_wait 
3f72 6f					ld l, a 
3f73 26 00				ld h, 0 
3f75 cd 13 18				call forth_push_numhl 
3f78					NEXTW 
3f78 c3 04 1a			jp macro_next 
3f7b				endm 
# End of macro NEXTW
3f7b			.ACCEPT: 
3f7b				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
3f7b 40				db WORD_SYS_CORE+44             
3f7c d9 3f			dw .EDIT            
3f7e 07				db 6 + 1 
3f7f .. 00			db "ACCEPT",0              
3f86				endm 
# End of macro CWHEAD
3f86			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
3f86					; TODO crashes on push 
3f86					if DEBUG_FORTH_WORDS_KEY 
3f86						DMARK "ACC" 
3f86 f5				push af  
3f87 3a 9b 3f			ld a, (.dmark)  
3f8a 32 7a ee			ld (debug_mark),a  
3f8d 3a 9c 3f			ld a, (.dmark+1)  
3f90 32 7b ee			ld (debug_mark+1),a  
3f93 3a 9d 3f			ld a, (.dmark+2)  
3f96 32 7c ee			ld (debug_mark+2),a  
3f99 18 03			jr .pastdmark  
3f9b ..			.dmark: db "ACC"  
3f9e f1			.pastdmark: pop af  
3f9f			endm  
# End of macro DMARK
3f9f						CALLMONITOR 
3f9f cd 86 12			call break_point_state  
3fa2				endm  
# End of macro CALLMONITOR
3fa2					endif 
3fa2 21 73 e5				ld hl, os_input 
3fa5 3e 00				ld a, 0 
3fa7 77					ld (hl),a 
3fa8 3a 5e eb				ld a,(f_cursor_ptr) 
3fab 16 64				ld d, 100 
3fad 0e 00				ld c, 0 
3faf 1e 28				ld e, 40 
3fb1 cd ef 0a				call input_str 
3fb4					; TODO perhaps do a type check and wrap in quotes if not a number 
3fb4 21 73 e5				ld hl, os_input 
3fb7					if DEBUG_FORTH_WORDS 
3fb7						DMARK "AC1" 
3fb7 f5				push af  
3fb8 3a cc 3f			ld a, (.dmark)  
3fbb 32 7a ee			ld (debug_mark),a  
3fbe 3a cd 3f			ld a, (.dmark+1)  
3fc1 32 7b ee			ld (debug_mark+1),a  
3fc4 3a ce 3f			ld a, (.dmark+2)  
3fc7 32 7c ee			ld (debug_mark+2),a  
3fca 18 03			jr .pastdmark  
3fcc ..			.dmark: db "AC1"  
3fcf f1			.pastdmark: pop af  
3fd0			endm  
# End of macro DMARK
3fd0						CALLMONITOR 
3fd0 cd 86 12			call break_point_state  
3fd3				endm  
# End of macro CALLMONITOR
3fd3					endif 
3fd3 cd 25 18				call forth_push_str 
3fd6					NEXTW 
3fd6 c3 04 1a			jp macro_next 
3fd9				endm 
# End of macro NEXTW
3fd9			 
3fd9			.EDIT: 
3fd9				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
3fd9 40				db WORD_SYS_CORE+44             
3fda 62 40			dw .ENDKEY            
3fdc 05				db 4 + 1 
3fdd .. 00			db "EDIT",0              
3fe2				endm 
# End of macro CWHEAD
3fe2			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
3fe2			 
3fe2					; TODO does not copy from stack 
3fe2					if DEBUG_FORTH_WORDS_KEY 
3fe2						DMARK "EDT" 
3fe2 f5				push af  
3fe3 3a f7 3f			ld a, (.dmark)  
3fe6 32 7a ee			ld (debug_mark),a  
3fe9 3a f8 3f			ld a, (.dmark+1)  
3fec 32 7b ee			ld (debug_mark+1),a  
3fef 3a f9 3f			ld a, (.dmark+2)  
3ff2 32 7c ee			ld (debug_mark+2),a  
3ff5 18 03			jr .pastdmark  
3ff7 ..			.dmark: db "EDT"  
3ffa f1			.pastdmark: pop af  
3ffb			endm  
# End of macro DMARK
3ffb						CALLMONITOR 
3ffb cd 86 12			call break_point_state  
3ffe				endm  
# End of macro CALLMONITOR
3ffe					endif 
3ffe			 
3ffe					FORTH_DSP 
3ffe cd 93 18			call macro_forth_dsp 
4001				endm 
# End of macro FORTH_DSP
4001					;v5 FORTH_DSP_VALUE 
4001 23					inc hl    ; TODO do type check 
4002			 
4002 e5					push hl 
4003 3e 00				ld a, 0 
4005 cd 2b 0f				call strlent 
4008 23					inc hl 
4009			 
4009 06 00				ld b, 0 
400b 4d					ld c, l 
400c			 
400c e1					pop hl 
400d 11 73 e5				ld de, os_input 
4010					if DEBUG_FORTH_WORDS_KEY 
4010						DMARK "EDc" 
4010 f5				push af  
4011 3a 25 40			ld a, (.dmark)  
4014 32 7a ee			ld (debug_mark),a  
4017 3a 26 40			ld a, (.dmark+1)  
401a 32 7b ee			ld (debug_mark+1),a  
401d 3a 27 40			ld a, (.dmark+2)  
4020 32 7c ee			ld (debug_mark+2),a  
4023 18 03			jr .pastdmark  
4025 ..			.dmark: db "EDc"  
4028 f1			.pastdmark: pop af  
4029			endm  
# End of macro DMARK
4029						CALLMONITOR 
4029 cd 86 12			call break_point_state  
402c				endm  
# End of macro CALLMONITOR
402c					endif 
402c ed b0				ldir 
402e			 
402e			 
402e 21 73 e5				ld hl, os_input 
4031					;ld a, 0 
4031					;ld (hl),a 
4031 3a 5e eb				ld a,(f_cursor_ptr) 
4034 16 64				ld d, 100 
4036 0e 00				ld c, 0 
4038 1e 28				ld e, 40 
403a cd ef 0a				call input_str 
403d					; TODO perhaps do a type check and wrap in quotes if not a number 
403d 21 73 e5				ld hl, os_input 
4040					if DEBUG_FORTH_WORDS 
4040						DMARK "ED1" 
4040 f5				push af  
4041 3a 55 40			ld a, (.dmark)  
4044 32 7a ee			ld (debug_mark),a  
4047 3a 56 40			ld a, (.dmark+1)  
404a 32 7b ee			ld (debug_mark+1),a  
404d 3a 57 40			ld a, (.dmark+2)  
4050 32 7c ee			ld (debug_mark+2),a  
4053 18 03			jr .pastdmark  
4055 ..			.dmark: db "ED1"  
4058 f1			.pastdmark: pop af  
4059			endm  
# End of macro DMARK
4059						CALLMONITOR 
4059 cd 86 12			call break_point_state  
405c				endm  
# End of macro CALLMONITOR
405c					endif 
405c cd 25 18				call forth_push_str 
405f					NEXTW 
405f c3 04 1a			jp macro_next 
4062				endm 
# End of macro NEXTW
4062			 
4062			 
4062			 
4062			.ENDKEY: 
4062			; eof 
4062			 
# End of file forth_words_key.asm
4062			 
4062			if STORAGE_SE 
4062			   	include "forth_words_storage.asm" 
4062			endif 
4062				include "forth_words_device.asm" 
4062			; Device related words 
4062			 
4062			; | ## Device Words 
4062			 
4062			if SOUND_ENABLE 
4062			.NOTE: 
4062				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4062			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4062					if DEBUG_FORTH_WORDS_KEY 
4062						DMARK "NTE" 
4062						CALLMONITOR 
4062					endif 
4062			 
4062				 
4062			 
4062					NEXTW 
4062			.AFTERSOUND: 
4062			endif 
4062			 
4062			 
4062			USE_GPIO: equ 0 
4062			 
4062			if USE_GPIO 
4062			.GP1: 
4062				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4062			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4062					NEXTW 
4062			.GP2: 
4062				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4062			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4062			 
4062					NEXTW 
4062			 
4062			.GP3: 
4062				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4062			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4062			 
4062					NEXTW 
4062			 
4062			.GP4: 
4062				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4062			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4062			 
4062					NEXTW 
4062			.SIN: 
4062			 
4062			 
4062			endif 
4062			 
4062			 
4062				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4062 33				db WORD_SYS_CORE+31             
4063 97 40			dw .SOUT            
4065 03				db 2 + 1 
4066 .. 00			db "IN",0              
4069				endm 
# End of macro CWHEAD
4069			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4069					if DEBUG_FORTH_WORDS_KEY 
4069						DMARK "IN." 
4069 f5				push af  
406a 3a 7e 40			ld a, (.dmark)  
406d 32 7a ee			ld (debug_mark),a  
4070 3a 7f 40			ld a, (.dmark+1)  
4073 32 7b ee			ld (debug_mark+1),a  
4076 3a 80 40			ld a, (.dmark+2)  
4079 32 7c ee			ld (debug_mark+2),a  
407c 18 03			jr .pastdmark  
407e ..			.dmark: db "IN."  
4081 f1			.pastdmark: pop af  
4082			endm  
# End of macro DMARK
4082						CALLMONITOR 
4082 cd 86 12			call break_point_state  
4085				endm  
# End of macro CALLMONITOR
4085					endif 
4085					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4085 cd ae 18			call macro_dsp_valuehl 
4088				endm 
# End of macro FORTH_DSP_VALUEHL
4088			 
4088 e5					push hl 
4089			 
4089					; destroy value TOS 
4089			 
4089					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4089 cd 4a 19			call macro_forth_dsp_pop 
408c				endm 
# End of macro FORTH_DSP_POP
408c			 
408c					; one value on hl get other one back 
408c			 
408c c1					pop bc 
408d			 
408d					; do the sub 
408d			;		ex de, hl 
408d			 
408d ed 68				in l,(c) 
408f			 
408f					; save it 
408f			 
408f 26 00				ld h,0 
4091			 
4091					; TODO push value back onto stack for another op etc 
4091			 
4091 cd 13 18				call forth_push_numhl 
4094					NEXTW 
4094 c3 04 1a			jp macro_next 
4097				endm 
# End of macro NEXTW
4097			.SOUT: 
4097				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4097 34				db WORD_SYS_CORE+32             
4098 ea 40			dw .SPIO            
409a 04				db 3 + 1 
409b .. 00			db "OUT",0              
409f				endm 
# End of macro CWHEAD
409f			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
409f					if DEBUG_FORTH_WORDS_KEY 
409f						DMARK "OUT" 
409f f5				push af  
40a0 3a b4 40			ld a, (.dmark)  
40a3 32 7a ee			ld (debug_mark),a  
40a6 3a b5 40			ld a, (.dmark+1)  
40a9 32 7b ee			ld (debug_mark+1),a  
40ac 3a b6 40			ld a, (.dmark+2)  
40af 32 7c ee			ld (debug_mark+2),a  
40b2 18 03			jr .pastdmark  
40b4 ..			.dmark: db "OUT"  
40b7 f1			.pastdmark: pop af  
40b8			endm  
# End of macro DMARK
40b8						CALLMONITOR 
40b8 cd 86 12			call break_point_state  
40bb				endm  
# End of macro CALLMONITOR
40bb					endif 
40bb			 
40bb					; get port 
40bb			 
40bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40bb cd ae 18			call macro_dsp_valuehl 
40be				endm 
# End of macro FORTH_DSP_VALUEHL
40be			 
40be e5					push hl 
40bf			 
40bf					; destroy value TOS 
40bf			 
40bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40bf cd 4a 19			call macro_forth_dsp_pop 
40c2				endm 
# End of macro FORTH_DSP_POP
40c2			 
40c2					; get byte to send 
40c2			 
40c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40c2 cd ae 18			call macro_dsp_valuehl 
40c5				endm 
# End of macro FORTH_DSP_VALUEHL
40c5			 
40c5			;		push hl 
40c5			 
40c5					; destroy value TOS 
40c5			 
40c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40c5 cd 4a 19			call macro_forth_dsp_pop 
40c8				endm 
# End of macro FORTH_DSP_POP
40c8			 
40c8					; one value on hl get other one back 
40c8			 
40c8			;		pop hl 
40c8			 
40c8 c1					pop bc 
40c9			 
40c9					if DEBUG_FORTH_WORDS 
40c9						DMARK "OUT" 
40c9 f5				push af  
40ca 3a de 40			ld a, (.dmark)  
40cd 32 7a ee			ld (debug_mark),a  
40d0 3a df 40			ld a, (.dmark+1)  
40d3 32 7b ee			ld (debug_mark+1),a  
40d6 3a e0 40			ld a, (.dmark+2)  
40d9 32 7c ee			ld (debug_mark+2),a  
40dc 18 03			jr .pastdmark  
40de ..			.dmark: db "OUT"  
40e1 f1			.pastdmark: pop af  
40e2			endm  
# End of macro DMARK
40e2						CALLMONITOR 
40e2 cd 86 12			call break_point_state  
40e5				endm  
# End of macro CALLMONITOR
40e5					endif 
40e5			 
40e5 ed 69				out (c), l 
40e7			 
40e7					NEXTW 
40e7 c3 04 1a			jp macro_next 
40ea				endm 
# End of macro NEXTW
40ea			 
40ea			 
40ea			.SPIO: 
40ea			 
40ea			if STORAGE_SE 
40ea				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
40ea			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
40ea			 
40ea					call spi_ce_low 
40ea			    NEXTW 
40ea			 
40ea			.SPICEH: 
40ea				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
40ea			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
40ea			 
40ea					call spi_ce_high 
40ea			    NEXTW 
40ea			 
40ea			 
40ea			.SPIOb: 
40ea			 
40ea				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
40ea			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
40ea			 
40ea					; get port 
40ea			 
40ea			 
40ea					; get byte to send 
40ea			 
40ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40ea			 
40ea			;		push hl    ; u1  
40ea			 
40ea					; destroy value TOS 
40ea			 
40ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ea			 
40ea					; one value on hl get other one back 
40ea			 
40ea			;		pop hl   ; u2 - addr 
40ea			 
40ea					; TODO Send SPI byte 
40ea			 
40ea					ld a, l 
40ea					call spi_send_byte 
40ea			 
40ea					NEXTW 
40ea			 
40ea			.SPII: 
40ea				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
40ea			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
40ea			 
40ea					; TODO Get SPI byte 
40ea			 
40ea					call spi_read_byte 
40ea			 
40ea					ld h, 0 
40ea					ld l, a 
40ea					call forth_push_numhl 
40ea			 
40ea					NEXTW 
40ea			 
40ea			 
40ea			 
40ea			.SESEL: 
40ea				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
40ea			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
40ea					if DEBUG_FORTH_WORDS_KEY 
40ea						DMARK "BNK" 
40ea						CALLMONITOR 
40ea					endif 
40ea			 
40ea					ld a, 255 
40ea					ld (spi_cartdev), a 
40ea			 
40ea					; get bank 
40ea			 
40ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40ea			 
40ea			;		push hl 
40ea			 
40ea					; destroy value TOS 
40ea			 
40ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ea			 
40ea					; one value on hl get other one back 
40ea			 
40ea			;		pop hl 
40ea			 
40ea			 
40ea					ld c, SPI_CE_HIGH 
40ea			 
40ea					ld a, l 
40ea			 
40ea					if DEBUG_FORTH_WORDS 
40ea						DMARK "BNK" 
40ea						CALLMONITOR 
40ea					endif 
40ea			 
40ea					; active low 
40ea			 
40ea					cp 0 
40ea					jr z, .bset 
40ea					cp 1 
40ea					jr nz, .b2 
40ea					res 0, c 
40ea			.b2:		cp 2 
40ea					jr nz, .b3 
40ea					res 1, c 
40ea			.b3:		cp 3 
40ea					jr nz, .b4 
40ea					res 2, c 
40ea			.b4:		cp 4 
40ea					jr nz, .b5 
40ea					res 3, c 
40ea			.b5:		cp 5 
40ea					jr nz, .bset 
40ea					res 4, c 
40ea			 
40ea			.bset: 
40ea					ld a, c 
40ea					ld (spi_device),a 
40ea					if DEBUG_FORTH_WORDS 
40ea						DMARK "BN2" 
40ea						CALLMONITOR 
40ea					endif 
40ea			 
40ea					NEXTW 
40ea			 
40ea			.CARTDEV: 
40ea				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
40ea			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
40ea					if DEBUG_FORTH_WORDS_KEY 
40ea						DMARK "CDV" 
40ea						CALLMONITOR 
40ea					endif 
40ea			 
40ea					; disable se storage bank selection 
40ea			 
40ea					ld a, SPI_CE_HIGH		; ce high 
40ea					ld (spi_device), a 
40ea			 
40ea					; get bank 
40ea			 
40ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40ea			 
40ea			;		push hl 
40ea			 
40ea					; destroy value TOS 
40ea			 
40ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ea			 
40ea					; one value on hl get other one back 
40ea			 
40ea			;		pop hl 
40ea			 
40ea					; active low 
40ea			 
40ea					ld c, 255 
40ea			 
40ea					ld a, l 
40ea					if DEBUG_FORTH_WORDS 
40ea						DMARK "CDV" 
40ea						CALLMONITOR 
40ea					endif 
40ea					cp 0 
40ea					jr z, .cset 
40ea					cp 1 
40ea					jr nz, .c2 
40ea					res 0, c 
40ea			.c2:		cp 2 
40ea					jr nz, .c3 
40ea					res 1, c 
40ea			.c3:		cp 3 
40ea					jr nz, .c4 
40ea					res 2, c 
40ea			.c4:		cp 4 
40ea					jr nz, .c5 
40ea					res 3, c 
40ea			.c5:		cp 5 
40ea					jr nz, .c6 
40ea					res 4, c 
40ea			.c6:		cp 6 
40ea					jr nz, .c7 
40ea					res 5, c 
40ea			.c7:		cp 7 
40ea					jr nz, .c8 
40ea					res 6, c 
40ea			.c8:		cp 8 
40ea					jr nz, .cset 
40ea					res 7, c 
40ea			.cset:		ld a, c 
40ea					ld (spi_cartdev),a 
40ea			 
40ea					if DEBUG_FORTH_WORDS 
40ea						DMARK "CD2" 
40ea						CALLMONITOR 
40ea					endif 
40ea					NEXTW 
40ea			endif 
40ea			 
40ea			.ENDDEVICE: 
40ea			; eof 
40ea			 
# End of file forth_words_device.asm
40ea			 
40ea			; var handler 
40ea			 
40ea			 
40ea			.VARS: 
40ea				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
40ea 78				db WORD_SYS_CORE+100             
40eb 02 41			dw .V0Q            
40ed 04				db 3 + 1 
40ee .. 00			db "V0!",0              
40f2				endm 
# End of macro CWHEAD
40f2			;| V0! ( u1 -- )  Store value to v0  | DONE 
40f2			 
40f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40f2 cd ae 18			call macro_dsp_valuehl 
40f5				endm 
# End of macro FORTH_DSP_VALUEHL
40f5			 
40f5 11 28 eb				ld de, cli_var_array 
40f8			 
40f8 eb					ex de, hl 
40f9 73					ld (hl), e 
40fa 23					inc hl 
40fb 72					ld (hl), d 
40fc			 
40fc					; destroy value TOS 
40fc			 
40fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40fc cd 4a 19			call macro_forth_dsp_pop 
40ff				endm 
# End of macro FORTH_DSP_POP
40ff			 
40ff				       NEXTW 
40ff c3 04 1a			jp macro_next 
4102				endm 
# End of macro NEXTW
4102			.V0Q: 
4102				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4102 79				db WORD_SYS_CORE+101             
4103 13 41			dw .V1S            
4105 04				db 3 + 1 
4106 .. 00			db "V0@",0              
410a				endm 
# End of macro CWHEAD
410a			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
410a 2a 28 eb				ld hl, (cli_var_array) 
410d cd 13 18				call forth_push_numhl 
4110			 
4110				       NEXTW 
4110 c3 04 1a			jp macro_next 
4113				endm 
# End of macro NEXTW
4113			.V1S: 
4113				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4113 7a				db WORD_SYS_CORE+102             
4114 2b 41			dw .V1Q            
4116 04				db 3 + 1 
4117 .. 00			db "V1!",0              
411b				endm 
# End of macro CWHEAD
411b			;| V1! ( u1 -- )  Store value to v1 | DONE 
411b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
411b cd ae 18			call macro_dsp_valuehl 
411e				endm 
# End of macro FORTH_DSP_VALUEHL
411e			 
411e 11 2a eb				ld de, cli_var_array+2 
4121				 
4121 eb					ex de, hl 
4122 73					ld (hl), e 
4123 23					inc hl 
4124 72					ld (hl), d 
4125			 
4125					; destroy value TOS 
4125			 
4125					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4125 cd 4a 19			call macro_forth_dsp_pop 
4128				endm 
# End of macro FORTH_DSP_POP
4128				       NEXTW 
4128 c3 04 1a			jp macro_next 
412b				endm 
# End of macro NEXTW
412b			.V1Q: 
412b				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
412b 7b				db WORD_SYS_CORE+103             
412c 3c 41			dw .V2S            
412e 04				db 3 + 1 
412f .. 00			db "V1@",0              
4133				endm 
# End of macro CWHEAD
4133			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4133 2a 2a eb				ld hl, (cli_var_array+2) 
4136 cd 13 18				call forth_push_numhl 
4139				       NEXTW 
4139 c3 04 1a			jp macro_next 
413c				endm 
# End of macro NEXTW
413c			.V2S: 
413c				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
413c 7c				db WORD_SYS_CORE+104             
413d 54 41			dw .V2Q            
413f 04				db 3 + 1 
4140 .. 00			db "V2!",0              
4144				endm 
# End of macro CWHEAD
4144			;| V2! ( u1 -- )  Store value to v2 | DONE 
4144					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4144 cd ae 18			call macro_dsp_valuehl 
4147				endm 
# End of macro FORTH_DSP_VALUEHL
4147			 
4147 11 2c eb				ld de, cli_var_array+4 
414a				 
414a eb					ex de, hl 
414b 73					ld (hl), e 
414c 23					inc hl 
414d 72					ld (hl), d 
414e			 
414e					; destroy value TOS 
414e			 
414e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
414e cd 4a 19			call macro_forth_dsp_pop 
4151				endm 
# End of macro FORTH_DSP_POP
4151				       NEXTW 
4151 c3 04 1a			jp macro_next 
4154				endm 
# End of macro NEXTW
4154			.V2Q: 
4154				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4154 7d				db WORD_SYS_CORE+105             
4155 65 41			dw .V3S            
4157 04				db 3 + 1 
4158 .. 00			db "V2@",0              
415c				endm 
# End of macro CWHEAD
415c			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
415c 2a 2c eb				ld hl, (cli_var_array+4) 
415f cd 13 18				call forth_push_numhl 
4162				       NEXTW 
4162 c3 04 1a			jp macro_next 
4165				endm 
# End of macro NEXTW
4165			.V3S: 
4165				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4165 7c				db WORD_SYS_CORE+104             
4166 7d 41			dw .V3Q            
4168 04				db 3 + 1 
4169 .. 00			db "V3!",0              
416d				endm 
# End of macro CWHEAD
416d			;| V3! ( u1 -- )  Store value to v3 | DONE 
416d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
416d cd ae 18			call macro_dsp_valuehl 
4170				endm 
# End of macro FORTH_DSP_VALUEHL
4170			 
4170 11 2e eb				ld de, cli_var_array+6 
4173				 
4173 eb					ex de, hl 
4174 73					ld (hl), e 
4175 23					inc hl 
4176 72					ld (hl), d 
4177			 
4177					; destroy value TOS 
4177			 
4177					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4177 cd 4a 19			call macro_forth_dsp_pop 
417a				endm 
# End of macro FORTH_DSP_POP
417a				       NEXTW 
417a c3 04 1a			jp macro_next 
417d				endm 
# End of macro NEXTW
417d			.V3Q: 
417d				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
417d 7d				db WORD_SYS_CORE+105             
417e 8e 41			dw .END            
4180 04				db 3 + 1 
4181 .. 00			db "V3@",0              
4185				endm 
# End of macro CWHEAD
4185			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4185 2a 2e eb				ld hl, (cli_var_array+6) 
4188 cd 13 18				call forth_push_numhl 
418b				       NEXTW 
418b c3 04 1a			jp macro_next 
418e				endm 
# End of macro NEXTW
418e			 
418e			 
418e			 
418e			 
418e			 
418e			; end of dict marker 
418e			 
418e 00			.END:    db WORD_SYS_END 
418f 00 00			dw 0 
4191 00				db 0 
4192			 
4192			; use to jp here for user dict words to save on macro expansion  
4192			 
4192			user_dict_next: 
4192				NEXTW 
4192 c3 04 1a			jp macro_next 
4195				endm 
# End of macro NEXTW
4195			 
4195			 
4195			user_exec: 
4195				;    ld hl, <word code> 
4195				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4195				;    call forthexec 
4195				;    jp user_dict_next   (NEXT) 
4195			        ;    <word code bytes> 
4195 eb				ex de, hl 
4196 2a 76 e6			ld hl,(os_tok_ptr) 
4199				 
4199				FORTH_RSP_NEXT 
4199 cd ba 17			call macro_forth_rsp_next 
419c				endm 
# End of macro FORTH_RSP_NEXT
419c			 
419c			if DEBUG_FORTH_UWORD 
419c						DMARK "UEX" 
419c f5				push af  
419d 3a b1 41			ld a, (.dmark)  
41a0 32 7a ee			ld (debug_mark),a  
41a3 3a b2 41			ld a, (.dmark+1)  
41a6 32 7b ee			ld (debug_mark+1),a  
41a9 3a b3 41			ld a, (.dmark+2)  
41ac 32 7c ee			ld (debug_mark+2),a  
41af 18 03			jr .pastdmark  
41b1 ..			.dmark: db "UEX"  
41b4 f1			.pastdmark: pop af  
41b5			endm  
# End of macro DMARK
41b5				CALLMONITOR 
41b5 cd 86 12			call break_point_state  
41b8				endm  
# End of macro CALLMONITOR
41b8			endif 
41b8			 
41b8			 
41b8			 
41b8 eb				ex de, hl 
41b9 22 76 e6			ld (os_tok_ptr), hl 
41bc				 
41bc				; Don't use next - Skips the first word in uword. 
41bc			 
41bc c3 95 1a			jp exec1 
41bf			;	NEXT 
41bf			 
41bf			 
41bf			; eof 
# End of file forth_wordsv4.asm
41bf			endif 
41bf			;;;;;;;;;;;;;; Debug code 
41bf			 
41bf			 
41bf			;if DEBUG_FORTH_PARSE 
41bf .. 00		.nowordfound: db "No match",0 
41c8 .. 00		.compword:	db "Comparing word ",0 
41d8 .. 00		.nextwordat:	db "Next word at",0 
41e5 .. 00		.charmatch:	db "Char match",0 
41f0			;endif 
41f0			if DEBUG_FORTH_JP 
41f0			.foundword:	db "Word match. Exec..",0 
41f0			endif 
41f0			;if DEBUG_FORTH_PUSH 
41f0 .. 00		.enddict:	db "Dict end. Push.",0 
4200 .. 00		.push_str:	db "Pushing string",0 
420f .. 00		.push_num:	db "Pushing number",0 
421e .. 00		.data_sp:	db "SP:",0 
4222 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4234 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4246 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4258			;endif 
4258			;if DEBUG_FORTH_MALLOC 
4258 .. 00		.push_malloc:	db "Malloc address",0 
4267			;endif 
4267			 
4267			 
4267			 
4267			; display malloc address and current data stack pointer  
4267			 
4267			malloc_error: 
4267 d5				push de 
4268 f5				push af 
4269 e5				push hl 
426a cd 69 09			call clear_display 
426d 11 8f 42			ld de, .mallocerr 
4270 3e 00			ld a,0 
4272			;	ld de,os_word_scratch 
4272 cd 7c 09			call str_at_display 
4275 3e 11			ld a, display_row_1+17 
4277 11 7a ee			ld de, debug_mark 
427a cd 7c 09			call str_at_display 
427d cd 8c 09			call update_display 
4280				;call break_point_state 
4280 cd e9 55			call cin_wait 
4283			 
4283 3e 20			ld a, ' ' 
4285 32 74 e3			ld (os_view_disable), a 
4288 e1				pop hl 
4289 f1				pop af 
428a d1				pop de	 
428b				CALLMONITOR 
428b cd 86 12			call break_point_state  
428e				endm  
# End of macro CALLMONITOR
428e c9				ret 
428f			 
428f .. 00		.mallocerr: 	db "Malloc Error",0 
429c			;if DEBUG_FORTH_PUSH 
429c			display_data_sp: 
429c f5				push af 
429d			 
429d				; see if disabled 
429d			 
429d 3a 74 e3			ld a, (os_view_disable) 
42a0 fe 2a			cp '*' 
42a2 28 67			jr z, .skipdsp 
42a4			 
42a4 e5				push hl 
42a5 e5				push hl 
42a6 e5			push hl 
42a7 cd 69 09			call clear_display 
42aa e1			pop hl 
42ab 7c				ld a,h 
42ac 21 7a e6			ld hl, os_word_scratch 
42af cd c3 0d			call hexout 
42b2 e1				pop hl 
42b3 7d				ld a,l 
42b4 21 7c e6			ld hl, os_word_scratch+2 
42b7 cd c3 0d			call hexout 
42ba 21 7e e6			ld hl, os_word_scratch+4 
42bd 3e 00			ld a,0 
42bf 77				ld (hl),a 
42c0 11 7a e6			ld de,os_word_scratch 
42c3 3e 28				ld a, display_row_2 
42c5 cd 7c 09				call str_at_display 
42c8 11 22 42			ld de, .wordinhl 
42cb 3e 00			ld a, display_row_1 
42cd			 
42cd cd 7c 09				call str_at_display 
42d0 11 7a ee			ld de, debug_mark 
42d3 3e 11			ld a, display_row_1+17 
42d5			 
42d5 cd 7c 09				call str_at_display 
42d8			 
42d8				; display current data stack pointer 
42d8 11 1e 42			ld de,.data_sp 
42db 3e 30				ld a, display_row_2 + 8 
42dd cd 7c 09				call str_at_display 
42e0			 
42e0 2a 22 eb			ld hl,(cli_data_sp) 
42e3 e5				push hl 
42e4 7c				ld a,h 
42e5 21 7a e6			ld hl, os_word_scratch 
42e8 cd c3 0d			call hexout 
42eb e1				pop hl 
42ec 7d				ld a,l 
42ed 21 7c e6			ld hl, os_word_scratch+2 
42f0 cd c3 0d			call hexout 
42f3 21 7e e6			ld hl, os_word_scratch+4 
42f6 3e 00			ld a,0 
42f8 77				ld (hl),a 
42f9 11 7a e6			ld de,os_word_scratch 
42fc 3e 33				ld a, display_row_2 + 11 
42fe cd 7c 09				call str_at_display 
4301			 
4301			 
4301 cd 8c 09			call update_display 
4304 cd e2 08			call delay1s 
4307 cd e2 08			call delay1s 
430a e1				pop hl 
430b			.skipdsp: 
430b f1				pop af 
430c c9				ret 
430d			 
430d			display_data_malloc: 
430d			 
430d f5				push af 
430e e5				push hl 
430f e5				push hl 
4310 e5			push hl 
4311 cd 69 09			call clear_display 
4314 e1			pop hl 
4315 7c				ld a,h 
4316 21 7a e6			ld hl, os_word_scratch 
4319 cd c3 0d			call hexout 
431c e1				pop hl 
431d 7d				ld a,l 
431e 21 7c e6			ld hl, os_word_scratch+2 
4321 cd c3 0d			call hexout 
4324 21 7e e6			ld hl, os_word_scratch+4 
4327 3e 00			ld a,0 
4329 77				ld (hl),a 
432a 11 7a e6			ld de,os_word_scratch 
432d 3e 28				ld a, display_row_2 
432f cd 7c 09				call str_at_display 
4332 11 58 42			ld de, .push_malloc 
4335 3e 00			ld a, display_row_1 
4337			 
4337 cd 7c 09				call str_at_display 
433a			 
433a				; display current data stack pointer 
433a 11 1e 42			ld de,.data_sp 
433d 3e 30				ld a, display_row_2 + 8 
433f cd 7c 09				call str_at_display 
4342			 
4342 2a 22 eb			ld hl,(cli_data_sp) 
4345 e5				push hl 
4346 7c				ld a,h 
4347 21 7a e6			ld hl, os_word_scratch 
434a cd c3 0d			call hexout 
434d e1				pop hl 
434e 7d				ld a,l 
434f 21 7c e6			ld hl, os_word_scratch+2 
4352 cd c3 0d			call hexout 
4355 21 7e e6			ld hl, os_word_scratch+4 
4358 3e 00			ld a,0 
435a 77				ld (hl),a 
435b 11 7a e6			ld de,os_word_scratch 
435e 3e 33				ld a, display_row_2 + 11 
4360 cd 7c 09				call str_at_display 
4363			 
4363 cd 8c 09			call update_display 
4366 cd e2 08			call delay1s 
4369 cd e2 08			call delay1s 
436c e1				pop hl 
436d f1				pop af 
436e c9				ret 
436f			;endif 
436f			 
436f			include "forth_autostart.asm" 
436f			; list of commands to perform at system start up 
436f			 
436f			startcmds: 
436f			;	dw test11 
436f			;	dw test12 
436f			;	dw test13 
436f			;	dw test14 
436f			;	dw test15 
436f			;	dw test16 
436f			;	dw test17 
436f			;	dw ifthtest1 
436f			;	dw ifthtest2 
436f			;	dw ifthtest3 
436f			;	dw mmtest1 
436f			;	dw mmtest2 
436f			;	dw mmtest3 
436f			;	dw mmtest4 
436f			;	dw mmtest5 
436f			;	dw mmtest6 
436f			;	dw iftest1 
436f			;	dw iftest2 
436f			;	dw iftest3 
436f			;	dw looptest1 
436f			;	dw looptest2 
436f			;	dw test1 
436f			;	dw test2 
436f			;	dw test3 
436f			;	dw test4 
436f			;	dw game2r 
436f			;	dw game2b1 
436f			;	dw game2b2 
436f			 
436f				; start up words that are actually useful 
436f			 
436f cd 43			dw clrstack 
4371 00 44			dw type 
4373 c1 45			dw stest 
4375 24 44			dw strncpy 
4377 62 45			dw list 
4379 85 44			dw start1 
437b 97 44			dw start2 
437d			;	dw start3 
437d aa 44			dw start3b 
437f 02 45			dw start3c 
4381			 
4381				; (unit) testing words 
4381			 
4381 38 46			dw mtesta 
4383 ed 46			dw mtestb 
4385 90 47			dw mtestc 
4387 45 48			dw mtestd 
4389 e9 48			dw mteste 
438b			 
438b				; demo/game words 
438b			 
438b f5 4f		        dw game3w 
438d 23 50		        dw game3p 
438f 41 50		        dw game3sc 
4391 72 50		        dw game3vsi 
4393 9e 50		        dw game3vs 
4395				 
4395 e8 4d			dw game2b 
4397 56 4e			dw game2bf 
4399 a0 4e			dw game2mba 
439b 36 4f			dw game2mbas 
439d 78 4f			dw game2mb 
439f			 
439f a9 4a			dw game1 
43a1 ba 4a			dw game1a 
43a3 1c 4b			dw game1b 
43a5 51 4b			dw game1c 
43a7 87 4b			dw game1d 
43a9 b8 4b			dw game1s 
43ab cc 4b			dw game1t 
43ad e1 4b			dw game1f 
43af 15 4c			dw game1z 
43b1 59 4c			dw game1zz 
43b3			 
43b3 9f 49			dw test5 
43b5 d7 49			dw test6 
43b7 0f 4a			dw test7 
43b9 23 4a			dw test8 
43bb 4f 4a			dw test9 
43bd 65 4a			dw test10 
43bf				 
43bf 30 4d		        dw ssv5 
43c1 14 4d		        dw ssv4 
43c3 f8 4c		        dw ssv3 
43c5 c2 4c		        dw ssv2 
43c7 49 4d		        dw ssv1 
43c9 91 4d		        dw ssv1cpm 
43cb			;	dw keyup 
43cb			;	dw keydown 
43cb			;	dw keyleft 
43cb			;	dw keyright 
43cb			;	dw 	keyf1 
43cb			;	dw keyf2 
43cb			;	dw keyf3 
43cb			;	dw keyf4 
43cb			;	dw keyf5 
43cb			;	dw keyf6 
43cb			;	dw keyf7 
43cb			;	dw keyf8 
43cb			;	dw keyf9 
43cb			;	dw keyf10 
43cb			;	dw keyf11 
43cb			;	dw keyf12 
43cb			;	dw keytab 
43cb			;	dw keycr 
43cb			;	dw keyhome 
43cb			;	dw keyend 
43cb			;	dw keybs 
43cb 00 00			db 0, 0	 
43cd			 
43cd			 
43cd			; clear stack  
43cd			 
43cd .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
4400			 
4400			; type ( addr count - ) 
4400 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
4424			 
4424			; some direct memory words 
4424			; strncpy ( len t f -- t ) 
4424			 
4424 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
4485			 
4485 .. 00		start1:     	db ": bpon $0000 bp ;",0 
4497 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
44aa			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
44aa .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
4502 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
4562			 
4562			 
4562			; a handy word to list items on the stack 
4562			 
4562 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
45c1			 
45c1			 
45c1			; test stack  
45c1			; rnd8 stest 
45c1			 
45c1 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4638			 
4638			; random malloc and free cycles 
4638			 
4638 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
46ed			 
46ed			; fixed malloc and free cycles 
46ed			 
46ed .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4790			 
4790			; fixed double string push and drop cycle  
4790			 
4790 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4845			 
4845			; consistent fixed string push and drop cycle  
4845			 
4845 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
48e9			 
48e9 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
499f			 
499f			;test1:		db ": aa 1 2 3 ;", 0 
499f			;test2:     	db "111 aa 888 999",0 
499f			;test3:     	db ": bb 77 ;",0 
499f			;test4:     	db "$02 $01 do i . loop bb",0 
499f			 
499f .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
49d7 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4a0f .. 00		test7:     	db ": box hline vline ;",0 
4a23 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4a4f .. 00		test9:     	db ": sw $01 adsp world ;",0 
4a65 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4a8a .. 00		test11:     	db "hello create .",0 
4a99 .. 00		test12:     	db "hello2 create .",0 
4aa9			 
4aa9			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4aa9			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4aa9			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4aa9			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4aa9			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4aa9			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4aa9			 
4aa9			;iftest1:     	db "$0001 IF cls .",0 
4aa9			;iftest2:     	db "$0000 IF cls .",0 
4aa9			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4aa9			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4aa9			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4aa9			 
4aa9			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4aa9			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4aa9			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4aa9			 
4aa9			 
4aa9			 
4aa9			; a small guess the number game 
4aa9			 
4aa9 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4aba .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4b1c			 
4b1c .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4b51 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4b87 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4bb8 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
4bcc .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4be1 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4c15 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
4c59			 
4c59			; Using 'ga' save a high score across multiple runs using external storage 
4c59			 
4c59 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
4cc2			 
4cc2			 
4cc2			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
4cc2			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
4cc2			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
4cc2			 
4cc2			; simple screen saver to test code memory reuse to destruction 
4cc2			 
4cc2 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
4cf8 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
4d14 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
4d30 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
4d49 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
4d91 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
4de8			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
4de8			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
4de8			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
4de8			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
4de8			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
4de8			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
4de8			 
4de8			 
4de8			 
4de8			; minesweeper/battleship finding game 
4de8			; draws a game board of random ship/mine positions 
4de8			; user enters coords to see if it hits on 
4de8			; game ends when all are hit 
4de8			; when hit or miss says how many may be in the area 
4de8			 
4de8			; setup the game board and then hide it 
4de8 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
4e56 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
4ea0			; prompt for where to target 
4ea0 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
4f36 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
4f5b			; TODO see if the entered coords hits or misses pushes char hit of miss 
4f5b .. 00		game2mbht:      db ": mbckht nop ;",0 
4f6a .. 00		game2mbms:      db ": mbcms nop ;",0 
4f78			; TODO how many might be near by 
4f78 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
4ff5			 
4ff5			; Game 3 
4ff5			 
4ff5			; Vert scroller ski game - avoid the trees! 
4ff5			 
4ff5			; v0 score (ie turns) 
4ff5			; v1 player pos 
4ff5			; v2 left wall 
4ff5			; v3 right wall 
4ff5			 
4ff5			; Draw side walls randomly 
4ff5			 
4ff5 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5023			 
5023			; Draw player 
5023 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5041			 
5041			; TODO Get Key 
5041			 
5041			; TODO Move left right 
5041			 
5041			; scroll and move walls a bit 
5041			 
5041 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5072			 
5072			; main game loop 
5072			 
5072 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
509e .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
50dd			 
50dd			; key board defs 
50dd			 
50dd .. 00		keyup:       db ": keyup $05 ;",0 
50eb .. 00		keydown:       db ": keydown $0a ;",0 
50fb .. 00		keyleft:       db ": keyleft $0b ;",0 
510b .. 00		keyright:       db ": keyright $0c ;",0 
511c .. 00		keyf1:       db ": keyf1 $10 ;",0 
512a .. 00		keyf2:       db ": keyf2 $11 ;",0 
5138 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5146 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5154 .. 00		keyf5:       db ": keyf5 $14 ;",0 
5162 .. 00		keyf6:       db ": keyf6 $15 ;",0 
5170 .. 00		keyf7:       db ": keyf7 $16 ;",0 
517e .. 00		keyf8:       db ": keyf8 $17 ;",0 
518c .. 00		keyf9:       db ": keyf9 $18 ;",0 
519a .. 00		keyf10:       db ": keyf10 $19 ;",0 
51a9 .. 00		keyf11:       db ": keyf11 $1a ;",0 
51b8 .. 00		keyf12:       db ": keyf12 $1b ;",0 
51c7			 
51c7 .. 00		keytab:       db ": keytab $09 ;",0 
51d6 .. 00		keycr:       db ": keycr $0d ;",0 
51e4 .. 00		keyhome:       db ": keyhome $0e ;",0 
51f4 .. 00		keyend:       db ": keyend $0f ;",0 
5203 .. 00		keybs:       db ": keybs $08 ;",0 
5211			 
5211			   
5211			 
5211			 
5211			 
5211			; eof 
# End of file forth_autostart.asm
5211			 
5211 .. 00		sprompt1: db "Startup load...",0 
5221 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5237			 
5237			forth_startup: 
5237 21 6f 43			ld hl, startcmds 
523a 3e 00			ld a, 0 
523c 32 9b e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
523f			 
523f e5			.start1:	push hl 
5240 cd 69 09			call clear_display 
5243 11 11 52			ld de, sprompt1 
5246 3e 00		        ld a, display_row_1 
5248 cd 7c 09			call str_at_display 
524b 11 21 52			ld de, sprompt2 
524e 3e 28		        ld a, display_row_2 
5250 cd 7c 09			call str_at_display 
5253 e1				pop hl 
5254 e5				push hl 
5255 5e				ld e,(hl) 
5256 23				inc hl 
5257 56				ld d,(hl) 
5258 3e 50		        ld a, display_row_3 
525a cd 7c 09			call str_at_display 
525d cd 8c 09			call update_display 
5260			 
5260			 
5260 3a 9b e7			ld a, (os_last_cmd) 
5263 fe 00			cp 0 
5265 28 05			jr z, .startprompt 
5267 cd d6 08			call delay250ms 
526a 18 24			jr .startdo 
526c				 
526c				 
526c			 
526c			.startprompt: 
526c			 
526c 3e 9f			ld a,display_row_4 + display_cols - 1 
526e 11 89 17		        ld de, endprg 
5271 cd 7c 09			call str_at_display 
5274 cd 8c 09			call update_display 
5277 cd e2 08			call delay1s 
527a cd e9 55			call cin_wait 
527d						 
527d fe 2a			cp '*' 
527f 28 5e			jr z, .startupend1 
5281 fe 23			cp '#' 
5283 20 07			jr nz, .startno 
5285 3e 01			ld a, 1 
5287 32 9b e7			ld (os_last_cmd),a 
528a 18 04			jr .startdo 
528c fe 31		.startno:	cp '1' 
528e 28 3a			jr z,.startnxt  
5290			 
5290				; exec startup line 
5290			.startdo:	 
5290 e1				pop hl 
5291 e5				push hl 
5292				 
5292 5e				ld e,(hl) 
5293 23				inc hl 
5294 56				ld d,(hl) 
5295 eb				ex de,hl 
5296			 
5296 e5				push hl 
5297			 
5297 3e 00			ld a, 0 
5299				;ld a, FORTH_END_BUFFER 
5299 cd 2b 0f			call strlent 
529c 23				inc hl   ; include zero term to copy 
529d 06 00			ld b,0 
529f 4d				ld c,l 
52a0 e1				pop hl 
52a1 11 75 e3			ld de, scratch 
52a4 ed b0			ldir 
52a6			 
52a6			 
52a6 21 75 e3			ld hl, scratch 
52a9 cd 52 1a			call forthparse 
52ac cd 92 1a			call forthexec 
52af cd a9 19			call forthexec_cleanup 
52b2			 
52b2 3e 78			ld a, display_row_4 
52b4 11 2d 15			ld de, endprog 
52b7			 
52b7 cd 8c 09			call update_display		 
52ba			 
52ba 3a 9b e7			ld a, (os_last_cmd) 
52bd fe 00			cp 0 
52bf 20 09			jr nz, .startnxt 
52c1 cd 8b 17			call next_page_prompt 
52c4 cd 69 09		        call clear_display 
52c7 cd 8c 09			call update_display		 
52ca			 
52ca				; move onto next startup line? 
52ca			.startnxt: 
52ca			 
52ca cd d6 08			call delay250ms 
52cd e1				pop hl 
52ce			 
52ce 23				inc hl 
52cf 23				inc hl 
52d0			 
52d0 e5				push hl 
52d1 5e				ld e, (hl) 
52d2 23				inc hl 
52d3 56				ld d, (hl) 
52d4 e1				pop hl 
52d5				; TODO replace 0 test 
52d5			 
52d5 eb				ex de, hl 
52d6 cd eb 0a			call ishlzero 
52d9			;	ld a,e 
52d9			;	add d 
52d9			;	cp 0    ; any left to do? 
52d9 eb				ex de, hl 
52da c2 3f 52			jp nz, .start1 
52dd 18 01			jr .startupend 
52df			 
52df e1			.startupend1: pop hl 
52e0			.startupend: 
52e0			 
52e0 cd 69 09			call clear_display 
52e3 cd 8c 09			call update_display 
52e6 c9				ret 
52e7			 
52e7			 
52e7			; stack over and underflow checks 
52e7			 
52e7			; init the words to detect the under/overflow 
52e7			 
52e7			chk_stk_init: 
52e7				; a vague random number to check so we dont get any "lucky" hits 
52e7 3e 2d			ld a, 45 
52e9 6f				ld l, a 
52ea 00				nop 
52eb 3e 17			ld a, 23 
52ed 67				ld h, a 
52ee			 
52ee 22 6a e3			ld (chk_word), hl     ; the word we need to check against 
52f1			 
52f1			;	ld (chk_stund), hl	; stack points.... 
52f1 22 00 ef			ld (chk_stovr), hl 
52f4 22 20 eb			ld (chk_ret_und), hl 
52f7 22 de ea			ld (chk_ret_ovr), hl 
52fa 22 dc e9			ld (chk_loop_ovr), hl 
52fd 22 da e8			ld (chk_data_ovr), hl 
5300 c9				ret 
5301				 
5301			check_stacks: 
5301				; check all stack words 
5301			 
5301 e5				push hl 
5302 d5				push de 
5303			 
5303			;	ld de,(chk_word) 
5303			;	ld hl, (chk_stund)	; stack points.... 
5303			;	if DEBUG_STK_FAULT 
5303			;		DMARK "FAa" 
5303			;		CALLMONITOR 
5303			;	endif 
5303			;	call cmp16 
5303			;	jp z, .chk_faulta 
5303			; 
5303			;	ld de, sfaultsu 
5303			;	jp .chk_fault 
5303			 
5303 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5306 ed 5b 6a e3		ld de,(chk_word) 
530a				if DEBUG_STK_FAULT 
530a					DMARK "FAb" 
530a					CALLMONITOR 
530a				endif 
530a cd e0 0a			call cmp16 
530d 28 06			jr z, .chk_fault1 
530f 11 b0 53			ld de, sfaultso 
5312 c3 64 53			jp .chk_fault 
5315			.chk_fault1:  
5315 2a 20 eb			ld hl, (chk_ret_und) 
5318 ed 5b 6a e3		ld de,(chk_word) 
531c				if DEBUG_STK_FAULT 
531c					DMARK "FAU" 
531c					CALLMONITOR 
531c				endif 
531c cd e0 0a			call cmp16 
531f ca 28 53			jp z, .chk_fault2 
5322 11 c0 53			ld de, sfaultru 
5325 c3 64 53			jp .chk_fault 
5328			.chk_fault2:  
5328 2a de ea			ld hl, (chk_ret_ovr) 
532b ed 5b 6a e3		ld de,(chk_word) 
532f				if DEBUG_STK_FAULT 
532f					DMARK "FA1" 
532f					CALLMONITOR 
532f				endif 
532f cd e0 0a			call cmp16 
5332 ca 3b 53			jp z, .chk_fault3 
5335 11 ce 53			ld de, sfaultro 
5338 c3 64 53			jp .chk_fault 
533b			.chk_fault3:  
533b 2a dc e9			ld hl, (chk_loop_ovr) 
533e ed 5b 6a e3		ld de,(chk_word) 
5342				if DEBUG_STK_FAULT 
5342					DMARK "FA2" 
5342					CALLMONITOR 
5342				endif 
5342 cd e0 0a			call cmp16 
5345 ca 4e 53			jp z, .chk_fault4 
5348 11 e8 53			ld de, sfaultlo 
534b c3 64 53			jp .chk_fault 
534e			.chk_fault4:  
534e 2a da e8			ld hl, (chk_data_ovr) 
5351 ed 5b 6a e3		ld de,(chk_word) 
5355				if DEBUG_STK_FAULT 
5355					DMARK "FA3" 
5355					CALLMONITOR 
5355				endif 
5355 cd e0 0a			call cmp16 
5358 ca 61 53			jp z, .chk_fault5 
535b 11 02 54			ld de, sfaultdo 
535e c3 64 53			jp .chk_fault 
5361			 
5361			 
5361			.chk_fault5:  
5361 d1				pop de 
5362 e1				pop hl 
5363			 
5363 c9				ret 
5364			 
5364 cd 69 09		.chk_fault: 	call clear_display 
5367 3e 28				ld a, display_row_2 
5369 cd 7c 09				call str_at_display 
536c 11 92 53				   ld de, .stackfault 
536f 3e 00				ld a, display_row_1 
5371 cd 7c 09				call str_at_display 
5374 11 7a ee				    ld de, debug_mark 
5377 3e 11				ld a, display_row_1+17 
5379 cd 7c 09				call str_at_display 
537c cd 8c 09				call update_display 
537f			 
537f				; prompt before entering montior for investigating issue 
537f			 
537f 3e 78			ld a, display_row_4 
5381 11 2d 15			ld de, endprog 
5384			 
5384 cd 8c 09			call update_display		 
5387			 
5387 cd 8b 17			call next_page_prompt 
538a			 
538a d1				pop de 
538b e1				pop hl 
538c cd 81 15				call monitor 
538f c3 7b 14				jp warmstart 
5392					;jp 0 
5392					;halt 
5392			 
5392			 
5392			 
5392 .. 00		.stackfault: 	db "Stack fault:",0 
539f			 
539f .. 00		sfaultsu: 	db	"Stack under flow",0 
53b0 .. 00		sfaultso: 	db	"Stack over flow",0 
53c0 .. 00		sfaultru:	db "RTS underflow",0 
53ce .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
53e8 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5402 .. 00		sfaultdo:	db "DTS overflow", 0 
540f			 
540f			 
540f			fault_dsp_under: 
540f 11 21 54			ld de, .dsp_under 
5412 c3 d1 54			jp .show_fault 
5415			 
5415			fault_rsp_under: 
5415 11 2f 54			ld de, .rsp_under 
5418 c3 d1 54			jp .show_fault 
541b			fault_loop_under: 
541b 11 3d 54			ld de, .loop_under 
541e c3 d1 54			jp .show_fault 
5421			 
5421 .. 00		.dsp_under: db "DSP Underflow",0 
542f .. 00		.rsp_under: db "RSP Underflow",0 
543d .. 00		.loop_under: db "LOOP Underflow",0 
544c			 
544c			 
544c d5			type_faultn: 	push de 
544d e5					push hl 
544e cd 69 09				call clear_display 
5451 11 78 54				   ld de, .typefaultn 
5454 3e 00				ld a, display_row_1 
5456 cd 7c 09				call str_at_display 
5459 11 7a ee				    ld de, debug_mark 
545c 3e 11				ld a, display_row_1+17 
545e cd 7c 09				call str_at_display 
5461 cd 8c 09				call update_display 
5464			 
5464				; prompt before entering montior for investigating issue 
5464			 
5464 3e 78			ld a, display_row_4 
5466 11 2d 15			ld de, endprog 
5469			 
5469 cd 8c 09			call update_display		 
546c			 
546c cd 8b 17			call next_page_prompt 
546f			 
546f e5					push hl 
5470 d5					push de 
5471 cd 81 15				call monitor 
5474 c3 7b 14				jp warmstart 
5477 76					halt 
5478			 
5478			 
5478 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
548f			 
548f d5			type_faults: 	push de 
5490 e5					push hl 
5491 cd 69 09				call clear_display 
5494 11 ba 54				   ld de, .typefaults 
5497 3e 00				ld a, display_row_1 
5499 cd 7c 09				call str_at_display 
549c 11 7a ee				    ld de, debug_mark 
549f 3e 11				ld a, display_row_1+17 
54a1 cd 7c 09				call str_at_display 
54a4 cd 8c 09				call update_display 
54a7			 
54a7				; prompt before entering montior for investigating issue 
54a7			 
54a7 3e 78			ld a, display_row_4 
54a9 11 2d 15			ld de, endprog 
54ac			 
54ac cd 8c 09			call update_display		 
54af			 
54af cd 8b 17			call next_page_prompt 
54b2			 
54b2 e1					pop hl 
54b3 d1					pop de 
54b4 cd 81 15				call monitor 
54b7 c3 7b 14				jp warmstart 
54ba			 
54ba			 
54ba .. 00		.typefaults: db "STR Type Expected TOS!",0 
54d1			 
54d1			.show_fault: 	 
54d1 d5					push de 
54d2 cd 69 09				call clear_display 
54d5 d1					pop de 
54d6 3e 00				ld a, display_row_1 
54d8 cd 7c 09				call str_at_display 
54db 11 7a ee				    ld de, debug_mark 
54de 3e 11				ld a, display_row_1+17 
54e0 cd 7c 09				call str_at_display 
54e3 cd 8c 09				call update_display 
54e6			 
54e6				; prompt before entering montior for investigating issue 
54e6			 
54e6 3e 78			ld a, display_row_4 
54e8 11 2d 15			ld de, endprog 
54eb			 
54eb cd 8c 09			call update_display		 
54ee			 
54ee cd 8b 17			call next_page_prompt 
54f1			 
54f1 e1					pop hl 
54f2 d1					pop de 
54f3 cd 81 15				call monitor 
54f6			; do a dump to cli and not warmstart so we preserve all of the uwords.  
54f6			; TODO Make optional fault restart to cli or warm boot? 
54f6					;jp warmstart 
54f6 c3 d3 14				jp cli 
54f9 76					halt 
54fa			; eof 
# End of file forth_kernel.asm
54fa			;include "nascombasic.asm" 
54fa			 
54fa			 
54fa			; find out where the code ends if loaded into RAM (for SC114) 
54fa			;endofcode:  
54fa			;	nop 
54fa			 
54fa			 
54fa			; eof 
54fa			 
# End of file main.asm
54fa			;include "firmware_lcd_4x40.asm" 
54fa			;;include "firmware_lcd_4x20.asm" 
54fa			include "firmware_cpm_display.asm" 
54fa			 
54fa			; Serial display interface for SC114 
54fa			 
54fa			 
54fa			display_row_1: equ 0 
54fa			display_row_2: equ display_row_1+display_cols 
54fa			display_row_3: equ display_row_2 + display_cols 
54fa			display_row_4: equ display_row_3 + display_cols 
54fa			 
54fa			kLCDWidth:  EQU display_cols             ;Width in characters 
54fa			kLCD_Line1: EQU 0x00  
54fa			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
54fa			; E1 
54fa			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
54fa			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
54fa			 
54fa			lcd_init: 
54fa				; no init as handled by the SCM bios 
54fa c9				ret 
54fb			 
54fb			 
54fb			; low level functions for direct screen writes 
54fb			 
54fb			; output char at pos? 
54fb			fLCD_Str: 
54fb			        ;out (SC114_SIO_1_OUT),a 
54fb c5				push bc 
54fc d5				push de 
54fd 5f				ld e, a 
54fe			; TODO Replace with CP/M BIOS call 
54fe 0e 02			ld c, $02 
5500 cd 05 00			call 5 
5503 d1				pop de 
5504 c1				pop bc 
5505 c9				ret 
5506			 
5506			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5506			fLCD_Pos: 
5506				; use ASCII escape to position 
5506			        ;out (SC114_SIO_1_OUT),a 
5506 c5				push bc 
5507 d5				push de 
5508 5f				ld e, a 
5509 0e 02			ld c, $02 
550b			; TODO Replace with CP/M BIOS call 
550b cd 05 00			call 5 
550e d1				pop de 
550f c1				pop bc 
5510			 
5510 c9				ret 
5511			 
5511			; output char at pos 
5511			fLCD_Data: 
5511			      ;  out (SC114_SIO_1_OUT),a 
5511 c5				push bc 
5512 d5				push de 
5513 0e 02			ld c, $02 
5515 5f				ld e, a 
5516			; TODO Replace with CP/M BIOS call 
5516 cd 05 00			call 5 
5519 d1				pop de 
551a c1				pop bc 
551b			 
551b c9				ret 
551c			 
551c			; ascii cls  
551c			 
551c 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
5520			 
5520 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5537			;.clscpm: db 3, $3c,"$" 
5537			 
5537			; write the frame buffer given in hl to hardware  
5537			write_display: 
5537			 
5537			API: equ 0 
5537			 
5537			if API 
5537				push bc 
5537				ld b, 4 
5537			 
5537			        ld (display_write_tmp), hl 	  
5537			 
5537				; clear and home cursor 
5537			 
5537				ld c, 9 
5537				ld de, .cls 
5537			; TODO Replace with CP/M BIOS call 
5537				call 5 
5537			 
5537			 
5537			.writeln: 
5537			 
5537				ld de, (display_write_tmp) 
5537				ld c, 6 
5537			; TODO Replace with CP/M BIOS call 
5537				rst $30 
5537				ld c, 7 
5537				rst $30 
5537			 
5537				ld hl, (display_write_tmp) 
5537				ld de, display_cols 
5537				add hl,de 
5537				ld (display_write_tmp),hl 
5537			 
5537				djnz  .writeln 
5537			 
5537				pop bc 
5537			 
5537			 
5537				ret 
5537			endif 
5537 e5				push hl 
5538 c5				push bc 
5539 d5				push de 
553a			 
553a			;	ld c, 2 
553a			;	;ld de, .cls 
553a			;	ld a, 27 
553a			;	rst $30 
553a			;	ld c, 2 
553a			;	;ld de, .cls 
553a			;	ld a, '[' 
553a			;	rst $30 
553a			; 
553a			;	ld c, 2 
553a			;	;ld de, .cls 
553a			;	ld a, 'H' 
553a			;	rst $30 
553a			; 
553a			 
553a			 
553a			; lots of CR/LF 
553a			;	ld c, 9 
553a			;	ld de, .clscpm 
553a			;	call 5 
553a			 
553a			; xterm cls 
553a 0e 02			ld c, 2 
553c 1e 1b			ld e, 27 
553e cd 05 00			call 5 
5541			; cls causes too much flicker 
5541			;	ld c, 2 
5541			;	ld e, 'c' 
5541			;	call 5 
5541			 
5541			; use xterm home instead 
5541 0e 02			ld c, 2 
5543 1e 5b			ld e, '[' 
5545 cd 05 00			call 5 
5548 0e 02			ld c, 2 
554a 1e 48			ld e, 'H' 
554c cd 05 00			call 5 
554f			LLL: equ 0 
554f			 
554f			if LLL 
554f			 
554f				ld c, 2 
554f				;ld de, .cls 
554f				ld e, 27 
554f			; TODO Replace with CP/M BIOS call 
554f				call 5 
554f			 
554f			 
554f				ld c, 2 
554f				;ld de, .cls 
554f				ld e, '[' 
554f			; TODO Replace with CP/M BIOS call 
554f				call 5 
554f				ld c, 2 
554f				;ld de, .cls 
554f				ld e, '2' 
554f			; TODO Replace with CP/M BIOS call 
554f				call 5 
554f				ld c, 2 
554f				;ld de, .cls 
554f				ld e, 'J' 
554f			; TODO Replace with CP/M BIOS call 
554f				call 5 
554f			 
554f			endif 
554f			 
554f d1				pop de 
5550 c1				pop bc 
5551 e1				pop hl 
5552			 
5552			 
5552 22 d8 eb		        ld (display_write_tmp), hl 	  
5555 3e 00			ld a, kLCD_Line1 
5557			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5557 06 28			ld b, display_cols 
5559 ed 5b d8 eb		ld de, (display_write_tmp) 
555d cd e0 55			call write_len_string 
5560				 
5560			 
5560 e5			push hl 
5561 d5			push de 
5562 c5			push bc 
5563 0e 02			ld c, 2 
5565 1e 0a			ld e, 10 
5567 cd 05 00			call 5 
556a 0e 02			ld c, 2 
556c 1e 0d			ld e, 13 
556e cd 05 00			call 5 
5571			; TODO Replace with CP/M BIOS call 
5571				;rst $30 
5571 c1			pop bc 
5572 d1			pop de 
5573 e1			pop hl 
5574			 
5574				 
5574 2a d8 eb			ld hl, (display_write_tmp) 
5577 11 28 00			ld de, display_cols 
557a 19				add hl,de 
557b 22 d8 eb			ld (display_write_tmp),hl 
557e			 
557e				 
557e 3e 28			ld a, kLCD_Line2 
5580			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5580 06 28			ld b, display_cols 
5582 ed 5b d8 eb		ld de, (display_write_tmp) 
5586 cd e0 55			call write_len_string 
5589				 
5589 2a d8 eb			ld hl, (display_write_tmp) 
558c 11 28 00			ld de, display_cols 
558f 19				add hl,de 
5590 22 d8 eb			ld (display_write_tmp),hl 
5593			 
5593 e5			push hl 
5594 d5			push de 
5595 c5			push bc 
5596 0e 07			ld c, 7 
5598			; TODO Replace with CP/M BIOS call 
5598				;rst $30 
5598 0e 02			ld c, 2 
559a 1e 0a			ld e, 10 
559c cd 05 00			call 5 
559f 0e 02			ld c, 2 
55a1 1e 0d			ld e, 13 
55a3 cd 05 00			call 5 
55a6 c1			pop bc 
55a7 d1			pop de 
55a8 e1			pop hl 
55a9			 
55a9				 
55a9 3e 50			ld a, kLCD_Line3 
55ab			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
55ab 06 28			ld b, display_cols 
55ad ed 5b d8 eb		ld de, (display_write_tmp) 
55b1 cd e0 55			call write_len_string 
55b4				 
55b4 2a d8 eb			ld hl, (display_write_tmp) 
55b7 11 28 00			ld de, display_cols 
55ba 19				add hl,de 
55bb 22 d8 eb			ld (display_write_tmp),hl 
55be			 
55be e5			push hl 
55bf d5			push de 
55c0 c5			push bc 
55c1 0e 07			ld c, 7 
55c3			; TODO Replace with CP/M BIOS call 
55c3				;rst $30 
55c3 0e 02			ld c, 2 
55c5 1e 0a			ld e, 10 
55c7 cd 05 00			call 5 
55ca 0e 02			ld c, 2 
55cc 1e 0d			ld e, 13 
55ce cd 05 00			call 5 
55d1 c1			pop bc 
55d2 d1			pop de 
55d3 e1			pop hl 
55d4			 
55d4				 
55d4 3e 78			ld a, kLCD_Line4 
55d6			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
55d6 06 28			ld b, display_cols 
55d8 ed 5b d8 eb		ld de, (display_write_tmp) 
55dc cd e0 55			call write_len_string 
55df c9					ret 
55e0			 
55e0			 
55e0				; write out a fixed length string given in b from de 
55e0			 
55e0 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
55e1 cd 11 55		            CALL fLCD_Data      ;Write character to display 
55e4 13				inc de 
55e5 10 f9			djnz write_len_string 
55e7 c9				ret 
55e8			 
55e8			 
55e8			; eof 
# End of file firmware_cpm_display.asm
55e8			;include "firmware_key_5x10.asm" 
55e8			;;include "firmware_key_4x10.asm" 
55e8			include "firmware_key_cpm.asm" 
55e8			; Serial keyboard interface for SC114 
55e8			 
55e8			 
55e8			key_init: 
55e8				; no init as handled by the SCM bios 
55e8 c9				ret 
55e9			 
55e9			 
55e9			cin_wait: 
55e9			;	ld a, 0 
55e9			;	ret 
55e9			 
55e9				;in a,(SC114_SIO_1_IN) 
55e9			        ; Use SCM API to get from whatever console device we are using 
55e9			 
55e9			; TODO Replace with CP/M BIOS call 
55e9 c5				push bc 
55ea 0e 01			ld c, $01 
55ec cd 05 00			call 5 
55ef c1				pop bc 
55f0 c9				ret 
55f1			 
55f1			cin: 
55f1			 
55f1			 
55f1 c5				push bc 
55f2			 
55f2				; any key waiting to process? 
55f2			; TODO Replace with CP/M BIOS call 
55f2 0e 06			ld c, $06 
55f4 cd 05 00			call 5 
55f7 28 0d			jr z, .cin_skip 
55f9			 
55f9				; yep, get it 
55f9			 
55f9 0e 01			ld c, $01 
55fb			; TODO Replace with CP/M BIOS call 
55fb cd 05 00			call 5 
55fe			 
55fe fe 7f			cp $7f     ; back space 
5600 20 02			jr nz, .skipbs 
5602 3e 08			ld a, KEY_BS 
5604			.skipbs: 
5604			 
5604 c1				pop bc 
5605 c9				ret 
5606			.cin_skip: 
5606 3e 00			ld a, 0 
5608 c1				pop bc 
5609 c9				ret 
560a			 
560a			 
560a			 
560a			 
# End of file firmware_key_cpm.asm
560a			endofcode:  
560a			baseram:  
560a 00				nop 
560b			 
560b			heap_start: equ baseram+15  ; Starting address of heap 
560b			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
560b			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
560b			;VDU:  EQU     endofcode           ; BASIC Work space 
560b			; eof 
560b			 
# End of file os_mega_cpm.asm
560b
