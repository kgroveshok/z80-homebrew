# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 32 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-08-11 21:25' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
001f			 
001f			 
001f			 
001f			;        nop  
001f			;        nop 
001f			;;	org 05h		; null out bdos call 
001f			; 
001f			;        nop  
001f			;        nop  
001f			;        nop 
001f			;;	org 08h 
001f			;;; 
001f			;;	jp cin		; rst 8 - char in 
001f			;;; 
001f			; 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;	org 010h 
001f			;; 
001f			;	jp cout		; rest 010h  - char out 
001f			;; 
001f			;	org 01bh   
001f			; 
001f			;	;jp  		; rst 01bh   - write string to display 
001f			;	jp str_at_display 
001f			; 
001f			; 
001f			;	org 020h 
001f			; 
001f			;	; jp		 ; rst 020h - read char at screen location 
001f			; 
001f			;	org 028h 
001f			 
001f				; jp		 ; rst 028h  - storage i/o 
001f			 
001f			; 	org 030h 
001f			;	jp break_point_state 
001f			  
001f			; $30  
001f			; org 038h 
001f			; $38 
001f			 
001f			; TODO any more important entry points to add to jump table for easier coding use? 
001f			 
001f			if BASE_KEV = 1  
001f			 
001f				; need to be at $66 for nmi support 
001f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0025 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0031 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0037 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0043 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0049 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0055 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0061 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0067 00 ff			db 0,255 
0069 c3 07 70			jp nmi 
006c			endif 
006c			 
006c			include "firmware.asm" 
006c			  
006c			; main constants (used here and in firmware)  
006c			  
006c			; TODO have page 0 of storage as bios  
006c			  
006c			Device_A: equ 0h  
006c			Device_B: equ 040h          ; Sound  
006c			  
006c			if BASE_KEV  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_SC114  
006c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			; TODO fixup for CPM  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			Device_D: equ 0c0h             ; Keyboard and LCD  
006c			  
006c			; Odd specific debug points for testing hardware dev  
006c			  
006c			;if DEBUG_LEVEL0  
006c			;	include "debug_level0.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL1  
006c			;	include "debug_level1.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL2  
006c			;	include "debug_level2.asm"  
006c			;endif  
006c			  
006c			  
006c			CALLMONITOR: macro  
006c			;	call break_point_state  
006c			; now use the break point debug vector  
006c				call debug_vector  
006c				endm  
006c			  
006c			MALLOC_1: equ 1        ; from dk88   
006c			MALLOC_2: equ 0           ; broke  
006c			MALLOC_3: equ 0           ; really broke  
006c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
006c			  
006c			if BASE_KEV   
006c			;stacksize: equ 256  
006c			; each stack entry is three bytes (type + word)  
006c			stacksize: equ 3*150  
006c			  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 512  
006c			endif  
006c			if BASE_SC114  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			;if STORAGE_SE == 0  
006c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
006c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
006c			;endif  
006c			  
006c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
006c			  
006c			STORE_0_AUTORUN: equ $20  
006c			  
006c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
006c			  
006c			STORE_0_AUTOFILE: equ $21  
006c			STORE_0_BANKRUN: equ $23  
006c			STORE_0_FILERUN: equ $24  
006c			  
006c			; Block 0 offsets for settings  
006c			  
006c			; if set then skip prompt for start up and accept all  
006c			  
006c			STORE_0_QUICKSTART: equ $25  
006c			  
006c			; Blocks where directory table is held  
006c			  
006c			; Reducing the number of entries increases the max file size  
006c			  
006c			;STORE_DIR_START: equ 1  
006c			;STORE_DIR_END: equ 33  
006c			  
006c			; Blocks from where file data is stored  
006c			  
006c			;STORE_DATA_START: equ STORE_DIR_END + 1  
006c			  
006c			; Block indicators (<32 are data files)  
006c			  
006c			;STORE_BLOCK_CFG: equ $8f       ; config block  
006c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
006c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
006c			;STORE_BLOCK_FREE: equ $85       ; data block free  
006c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
006c			  
006c			  
006c			  
006c			; Directory entry flags  
006c			  
006c			;STORE_DIR_FREE: equ 0  
006c			;STORE_DIR_FILE:  equ 1  
006c			  
006c			; Structure offsets to directory entries  
006c			;STORE_DE_FLAG: equ 0  
006c			;STORE_DE_MAXEXT: equ 1  
006c			;STORE_DE_FILENAME: equ 2  
006c			  
006c			; Structure offsets to block 0  
006c			  
006c			;STORE_BK0_ISFOR: equ 1  
006c			;STORE_BK0_LABEL: equ 3  
006c			  
006c			; memory allocation   
006c			  
006c			chk_stund: equ tos+2           ; underflow check word  
006c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
006c			  
006c			; keyscan table needs rows x cols buffer  
006c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
006c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
006c			  
006c			keyscan_table_row1: equ chk_stovr -key_cols-1  
006c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
006c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
006c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
006c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
006c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
006c			keyscan_scancol: equ keyscan_table-key_cols  
006c			;keyscan_table_len: equ key_rows*key_cols  
006c			;keybufptr: equ keyscan_table - 2  
006c			;keysymbol: equ keybufptr - 1  
006c			key_held: equ keyscan_scancol-1	; currently held  
006c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
006c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
006c			key_fa: equ key_repeat_ct -1 ;  
006c			key_fb: equ key_fa -1 ;  
006c			key_fc: equ key_fb -1 ;  
006c			key_fd: equ key_fc -1 ;  
006c			key_face_held: equ key_fd - 1   
006c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
006c			  
006c			hardware_config: equ key_face_held - 10  
006c			  
006c			; hardware config switches  
006c			; TODO add bitmasks on includes for hardware  
006c			; high byte for expansion ids  
006c			;     0000 0000  no card inserted  
006c			;     0000 0001  storage card inserted  
006c			;     0000 0010  spi sd card active  
006c			  
006c			;       
006c			; low byte:  
006c			;     0000 0001   4x4 keypad  
006c			;     0000 0010   full keyboard  
006c			;     0000 0011   spi/ext keyboard  
006c			;     0000 0100   20x4 lcd  
006c			;     0000 1000   40x4 lcd  
006c			;     0000 1100   spi/ext display  
006c			;     0001 0000   ide interface available  
006c			  
006c			hardware_word: equ hardware_config - 2  
006c			  
006c			; debug marker - optional display of debug point on the debug screens  
006c			  
006c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
006c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
006c			  
006c			debug_umark: equ debug_vector - 6  ; current user mark  
006c			debug_mark: equ debug_umark - 4    ; internal word debug points  
006c			  
006c			; input_str vars  
006c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
006c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
006c			input_size: equ input_start -1  ; number of chars  
006c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
006c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
006c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
006c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
006c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
006c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
006c			input_len: equ input_cur_onoff - 5 ; length of current input  
006c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
006c			  
006c			; cursor blink rate  
006c			CUR_BLINK_RATE: equ $09  
006c			;CUR_BLINK_RATE: equ 15  
006c			  
006c			key_actual_pressed: equ input_cursor - 1   
006c			key_symbol: equ key_actual_pressed - 1   
006c			key_shift: equ key_symbol - 1   
006c			  
006c			; Display allocation  
006c			  
006c			;display_rows: equ 4     ; move out to mini and mega files  
006c			;display_cols: equ 20  
006c			  
006c			display_fb_len: equ display_rows*display_cols  
006c			  
006c			; primary frame buffer     
006c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
006c			; working frame buffers  
006c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
006c			display_fb3: equ  display_fb1-display_fb_len - 1  
006c			display_fb2: equ  display_fb3-display_fb_len - 1  
006c			;  
006c			; pointer to active frame buffer  
006c			display_fb_active: equ display_fb2 - 2  
006c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
006c			display_write_tmp: equ display_lcde1e2 - 2  
006c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
006c			  
006c			;  
006c			  
006c			;; can load into de directory  
006c			cursor_col: equ display_active-1  
006c			cursor_row: equ cursor_col-1  
006c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
006c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
006c			  
006c			; maths vars  
006c			  
006c			LFSRSeed: equ cursor_shape -20   
006c			randData: equ LFSRSeed - 2  
006c			xrandc: equ randData - 2  
006c			stackstore: equ xrandc - 2  
006c			seed1: equ  stackstore -2   
006c			seed2: equ seed1 - 2  
006c			  
006c			; cf storage vars  
006c			  
006c			iErrorNum:  equ seed2-1         ;Error number  
006c			iErrorReg:  equ iErrorNum -1              ;Error register  
006c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
006c			  
006c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
006c			  
006c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
006c			  
006c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
006c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
006c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
006c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
006c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
006c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
006c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
006c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
006c			store_tmpid: equ store_tmp3 - 1		; page temp id  
006c			store_tmpext: equ store_tmpid - 1		; file extent temp  
006c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
006c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
006c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
006c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
006c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
006c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
006c			;  
006c			; spi vars  
006c			  
006c			  
006c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
006c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
006c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
006c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
006c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
006c			spi_device_id: equ spi_device - 1    ; human readable bank number  
006c			  
006c			;;;;; forth cli params  
006c			  
006c			; TODO use a different frame buffer for forth???  
006c			  
006c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
006c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
006c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
006c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
006c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
006c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
006c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
006c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
006c			  
006c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
006c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
006c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
006c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
006c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
006c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
006c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
006c			  
006c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
006c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
006c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
006c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
006c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
006c			  
006c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
006c			  
006c			; os/forth token vars  
006c			  
006c			os_last_cmd: equ os_var_array-255  
006c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
006c			os_current_i: equ os_cli_cmd-2  
006c			os_cur_ptr: equ os_current_i-2  
006c			os_word_scratch: equ os_cur_ptr-30  
006c			os_tok_len: equ os_word_scratch - 2  
006c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
006c			os_tok_malloc: equ os_tok_ptr - 2  
006c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
006c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
006c			execscratch: equ os_input-255        ; exec cmd eval buffer  
006c			scratch: equ execscratch-255  
006c			  
006c			os_stack_1: equ scratch - 3       ; stack holding area 1  
006c			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
006c			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
006c			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
006c			  
006c			  
006c			; temp locations for new word processing to save on adding more   
006c			  
006c			os_new_malloc: equ os_stack_4-2  
006c			os_new_parse_len: equ os_new_malloc - 2  
006c			os_new_word_len: equ os_new_parse_len - 2  
006c			os_new_work_ptr: equ os_new_word_len - 2  
006c			os_new_src_ptr: equ os_new_work_ptr - 2  
006c			os_new_exec: equ os_new_src_ptr - 2  
006c			os_new_exec_ptr: equ os_new_exec - 2  
006c			  
006c			; resume memory alloocations....  
006c			  
006c			;os_view_disable: equ os_new_exec_ptr - 1  
006c			os_view_af: equ os_new_exec_ptr - 2  
006c			os_view_hl: equ os_view_af -2  
006c			os_view_de: equ os_view_hl - 2  
006c			os_view_bc: equ os_view_de - 2  
006c			  
006c			; stack checksum word  
006c			if DEBUG_STACK_IMB  
006c				curframe: equ  os_view_de - 5  
006c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
006c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			else  
006c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			endif  
006c			  
006c			; with data stack could see memory filled with junk. need some memory management   
006c			; malloc and free entry points added  
006c			  
006c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
006c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			;heap_end: equ free_list-1  ; Starting address of heap  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			heap_end: equ chk_word-1  ; Starting address of heap  
006c			  
006c			  
006c			;if BASE_KEV   
006c			;heap_start: equ 0800eh  ; Starting address of heap  
006c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;heap_start: equ baseram+15  ; Starting address of heap  
006c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;endif  
006c			  
006c			  
006c			;;;;  
006c			  
006c			  
006c			; change below to point to last memory alloc above  
006c			topusermem:  equ   heap_start  
006c			  
006c			;if BASE_KEV   
006c			;baseusermem: equ 08000h  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;;aseusermem:     equ    12  
006c			;baseusermem:     equ    prompt  
006c			;;baseusermem:     equ    endofcode  
006c			;endif  
006c			  
006c			  
006c			; **********************************************************************  
006c			; **  Constants  
006c			; **********************************************************************  
006c			  
006c			; Constants used by this code module  
006c			kDataReg:   EQU Device_D           ;PIO port A data register  
006c			kContReg:   EQU Device_D+2           ;PIO port A control register  
006c			  
006c			  
006c			portbdata:  equ Device_D+1    ; port b data  
006c			portbctl:   equ Device_D+3    ; port b control  
006c			  
006c			  
006c			;KEY_SHIFT:   equ 5  
006c			;KEY_SYMBOLSHIFT:  equ 6  
006c			  
006c			KEY_SHIFTLOCK: equ 4  
006c			  
006c			  
006c			KEY_UP: equ 5  
006c			KEY_NEXTWORD: equ 6  
006c			KEY_PREVWORD: equ 7  
006c			KEY_BS: equ 8  
006c			KEY_TAB:  equ 9  
006c			KEY_DOWN: equ 10  
006c			KEY_LEFT: equ 11  
006c			KEY_RIGHT: equ 12  
006c			KEY_CR:   equ 13  
006c			KEY_HOME: equ 14  
006c			KEY_END: equ 15  
006c			  
006c			KEY_F1: equ 16  
006c			KEY_F2: equ 17  
006c			KEY_F3: equ 18  
006c			KEY_F4: equ 19  
006c			  
006c			KEY_F5: equ 20  
006c			KEY_F6: equ 21  
006c			KEY_F7: equ 22  
006c			KEY_F8: equ 23  
006c			  
006c			KEY_F9: equ 24  
006c			KEY_F10: equ 25  
006c			KEY_F11: equ 26  
006c			KEY_F12: equ 27  
006c			  
006c			;if DEBUG_KEY  
006c			;	KEY_MATRIX_NO_PRESS: equ '.'  
006c			;	KEY_SHIFT:   equ '.'  
006c			;	KEY_SYMBOLSHIFT:  equ '.'  
006c			;else  
006c				KEY_SHIFT:   equ '~'  
006c				KEY_SYMBOLSHIFT:  equ '~'  
006c				KEY_MATRIX_NO_PRESS: equ '~'  
006c			;endi  
006c			  
006c			  
006c			  
006c			  
006c			; Macro to make adding debug marks easier  
006c			  
006c			DMARK: macro str  
006c				push af  
006c				ld a, (.dmark)  
006c				ld (debug_mark),a  
006c				ld a, (.dmark+1)  
006c				ld (debug_mark+1),a  
006c				ld a, (.dmark+2)  
006c				ld (debug_mark+2),a  
006c				jr .pastdmark  
006c			.dmark: db str  
006c			.pastdmark: pop af  
006c			  
006c			endm  
006c			  
006c			  
006c			; macro to detect for stack imbalances  
006c			  
006c			include "stackimbal.asm"  
006c			; Macro and code to detect stock imbalances 
006c			 
006c			SPPUSH: equ 0 
006c			 
006c			; Add a stack frame which can be checked before return 
006c			 
006c			STACKFRAME: macro onoff frame1 frame2 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c						exx 
006c			 
006c						ld de, frame1 
006c						ld a, d 
006c						ld hl, curframe 
006c						call hexout 
006c						ld a, e 
006c						ld hl, curframe+2 
006c						call hexout 
006c			  
006c						ld hl, frame1 
006c						push hl 
006c						ld hl, frame2 
006c						push hl 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			endm 
006c			 
006c			STACKFRAMECHK: macro onoff frame1 frame2 
006c			 
006c					 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						exx 
006c						; check stack frame SP 
006c			 
006c						ld hl, frame2 
006c						pop de   ; frame2 
006c			 
006c						call cmp16 
006c						jr nz, .spnosame 
006c						 
006c			 
006c						ld hl, frame1 
006c						pop de   ; frame1 
006c			 
006c						call cmp16 
006c						jr z, .spfrsame 
006c			 
006c						.spnosame: call showsperror 
006c			 
006c						.spfrsame: nop 
006c			 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			 
006c			 
006c			endm 
006c			 
006c			 
006c			; for a sub routine, wrap SP collection and comparisons 
006c			 
006c			; Usage: 
006c			; 
006c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
006c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
006c			 
006c			SAVESP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c			 
006c						ld (store_sp+(storeword*4)), sp 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			CHECKSP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c			 
006c						; save SP after last save 
006c				 
006c						ld (store_sp+(storeword*4)+2), sp 
006c			 
006c						push hl 
006c						ld hl, store_sp+(storeword*4) 
006c						call check_stack_sp  
006c						pop hl 
006c			 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			if DEBUG_STACK_IMB 
006c			 
006c			check_stack_sp: 
006c					push de 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					push de 
006c			 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					pop hl 
006c			 
006c			 
006c					; check to see if the same 
006c			 
006c					call cmp16 
006c					jr z, .spsame 
006c			 
006c					; not same 
006c			 
006c					call showsperror 
006c			.spsame: 
006c			 
006c					pop de 
006c			 
006c					ret 
006c			 
006c			.sperr:  db "Stack imbalance",0 
006c			 
006c			 
006c			showsperror: 
006c			 
006c			 
006c				push hl 
006c				push af 
006c				push de 
006c				call clear_display 
006c				ld de, .sperr 
006c				ld a,0 
006c			;	ld de,os_word_scratch 
006c				call str_at_display 
006c				ld a, display_row_1+17 
006c				ld de, debug_mark 
006c				call str_at_display 
006c				ld a, 0 
006c				ld (curframe+4),a 
006c				ld hl, curframe 
006c				ld de, os_word_scratch 
006c				ld a, display_row_4 
006c				call str_at_display 
006c				call update_display 
006c				;call break_point_state 
006c				call cin_wait 
006c			 
006c			;	ld a, ' ' 
006c			;	ld (os_view_disable), a 
006c				call bp_on 
006c				pop de	 
006c				pop af 
006c				pop hl 
006c				CALLMONITOR 
006c				ret 
006c			 
006c			endif 
006c			 
006c			 
006c			 
006c			; eof 
# End of file stackimbal.asm
006c			  
006c			;TODO macro to calc col and row offset into screen  
006c			  
006c			  
006c			  
006c			hardware_init:  
006c			  
006c				  
006c			  
006c					;ld a, 0  
006c					;ld (hardware_diag), a  
006c			  
006c					; clear all the buffers  
006c			  
006c 21 45 fc				ld hl, display_fb1  
006f 22 01 fb				ld (display_fb_active), hl  
0072			  
0072 cd aa 0d				call clear_display  
0075			  
0075 21 03 fb				ld hl, display_fb2  
0078 22 01 fb				ld (display_fb_active), hl  
007b			  
007b cd aa 0d				call clear_display  
007e			  
007e					; init primary frame buffer area  
007e 21 e6 fc				ld hl, display_fb0  
0081 22 01 fb				ld (display_fb_active), hl  
0084			  
0084 cd aa 0d				call clear_display  
0087			  
0087			  
0087 cd 14 70				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
008a			  
008a cd ab 72			call key_init  
008d cd 56 02			call storage_init  
0090			  
0090				; setup malloc functions  
0090			  
0090				if MALLOC_1  
0090 cd 95 13				call  heap_init  
0093				endif  
0093				if MALLOC_4  
0093					call  heap_init  
0093				endif  
0093			  
0093				; init sound hardware if present  
0093			  
0093				if SOUND_ENABLE  
0093					call sound_init  
0093				endif  
0093			  
0093				; lcd test sequence  
0093					  
0093 cd cd 0d			call update_display  
0096 cd ed 0c			call delay1s  
0099 3e 2b			ld a,'+'  
009b cd af 0d			call fill_display  
009e cd cd 0d			call update_display  
00a1 cd ed 0c			call delay1s  
00a4 3e 2a			ld a,'*'  
00a6 cd af 0d			call fill_display  
00a9 cd cd 0d			call update_display  
00ac cd ed 0c			call delay1s  
00af 3e 2d			ld a,'-'  
00b1 cd af 0d			call fill_display  
00b4 cd cd 0d			call update_display  
00b7 cd ed 0c			call delay1s  
00ba			  
00ba			; boot splash screen  
00ba			if display_cols == 20	  
00ba			        ld a, display_row_1    
00ba			else  
00ba 3e 0a		        ld a, display_row_1 +10   
00bc			endif  
00bc 11 22 1b			ld de, prom_bootmsg  
00bf cd bd 0d			call str_at_display  
00c2 cd cd 0d			call update_display  
00c5			  
00c5			  
00c5 cd ed 0c			call delay1s  
00c8 cd ed 0c			call delay1s  
00cb			if display_cols == 20	  
00cb			            LD   A, display_row_3+2  
00cb			else  
00cb 3e 5c		            LD   A, display_row_3+12  
00cd			endif  
00cd 11 37 1b			ld de, prom_bootmsg1  
00d0 cd bd 0d			call str_at_display  
00d3			; display debug level  
00d3 3e 78		            LD   A, display_row_4  
00d5 11 1b 00			ld de, debuglevel  
00d8 cd bd 0d			call str_at_display  
00db			  
00db cd cd 0d			call update_display  
00de cd ed 0c			call delay1s  
00e1 cd ed 0c			call delay1s  
00e4			  
00e4			;	ld a, display_row_4+3  
00e4			;	ld de, bootmsg2  
00e4			;	call str_at_display  
00e4			;	call update_display  
00e4			;	call delay1s  
00e4			;	call delay1s  
00e4			  
00e4			; debug mark setup  
00e4			  
00e4 3e 5f		ld a, '_'  
00e6 32 a0 fd		ld (debug_mark),a  
00e9 32 a1 fd		ld (debug_mark+1),a  
00ec 32 a2 fd		ld (debug_mark+2),a  
00ef 3e 00		ld a,0  
00f1 32 a3 fd		ld (debug_mark+3),a  
00f4 32 a4 fd		ld (debug_umark),a  
00f7			  
00f7 c9					ret  
00f8			  
00f8			  
00f8			;bootmsg2:	db "Firmware v0.1",0  
00f8			  
00f8			; a 4x20 lcd  
00f8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00f8			  
00f8			;if display_cols == 20  
00f8			;	include "firmware_lcd_4x20.asm"  
00f8			;endif  
00f8			  
00f8			;if display_cols == 40  
00f8			;	include "firmware_lcd_4x40.asm"  
00f8			;endif  
00f8			  
00f8			;  
00f8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00f8			; TODO abstract the bit bang video out interface for dual display  
00f8			; TODO wire video out to tx pin on rc2014 bus  
00f8			  
00f8			; must supply cin, and cin_wait for low level hardware abstraction   
00f8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00f8			; test scancode  
00f8			  
00f8			;;;;;  
00f8			;;;  
00f8			; Moved out to mini and maxi versions  
00f8			;  
00f8			; include "firmware_key_4x4.asm"  
00f8			; using existing 4 wire x 4 resistor array for input  
00f8			;include "firmware_key_4x10.asm"  
00f8			; need to mod the board for 5 rows due to resistor array  
00f8			;include "firmware_key_5x10.asm"  
00f8			  
00f8			; storage hardware interface  
00f8			  
00f8			; use microchip serial eeprom for storage  
00f8			  
00f8			  
00f8			if STORAGE_SE  
00f8				include "firmware_spi.asm"  
00f8			; my spi protocol (used by storage) 
00f8			 
00f8			; SPI pins 
00f8			 
00f8			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00f8			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00f8			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00f8			 
00f8			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00f8			; chip pin 4 gnd 
00f8			 
00f8			 
00f8			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00f8			SPI_CE1: equ 1      ;    port a1 pin 14  
00f8			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00f8			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00f8			SPI_CE4: equ 4      ; port a4     pin 10 
00f8			 
00f8			; active low AND masks 
00f8			 
00f8			;SPI_CE0_MASK: equ    255-1 
00f8			;SPI_CE1_MASK: equ   255-2 
00f8			;SPI_CE2_MASK: equ   255-4 
00f8			;SPI_CE3_MASK: equ   255-8 
00f8			;SPI_CE4_MASK: equ   255-16 
00f8			SPI_CE_HIGH:  equ 255 
00f8			 
00f8			 
00f8			 
00f8			;  Perform SCLK wait pulse 
00f8			 
00f8			spi_clk: 
00f8 f5				push af 
00f9 3a 99 f9			ld a, (spi_clktime) 
00fc fe 00			cp 0 
00fe 28 03			jr z, .scskip 
0100 cd d2 0c			call aDelayInMS 
0103			.scskip: 
0103 f1				pop af 
0104 c9				ret 
0105			 
0105			 
0105			 
0105			; TODO store port id for spi device ie dev c 
0105			; TODO store pin for SO 
0105			; TODO store pin for SI 
0105			; TODO store pin for SCLK 
0105			 
0105			; 
0105			 
0105			; ensure that spi bus is in a stable state with default pins  
0105			 
0105			se_stable_spi:   
0105			 
0105				 ; set DI high, CE high , SCLK low 
0105				;ld a, SPI_DI | SPI_CE0 
0105 3e 07			ld a, SPI_DI  
0107 cd 11 02			call spi_ce_high 
010a d3 80			 out (storage_adata),a 
010c 32 96 f9			ld (spi_portbyte),a 
010f			 
010f				if DEBUG_SPI 
010f					push hl 
010f					ld l, a 
010f					DMARK "SPI" 
010f					CALLMONITOR 
010f					pop hl 
010f				endif 
010f c9				ret 
0110			 
0110			; byte to send in a 
0110			 
0110			spi_send_byte: 
0110				; save byte to send for bit mask shift out 
0110 4f			        ld c,a 
0111 3a 96 f9			ld a,(spi_portbyte) 
0114				  
0114				; clock out	each bit of the byte msb first 
0114			 
0114 06 08			ld b, 8 
0116			.ssb1: 
0116				; clear so bit  
0116 cb bf			res SPI_DI, a 
0118 cb 11			rl c 
011a				; if bit 7 is set then carry is set 
011a 30 02			jr nc, .ssb2 
011c cb ff			set SPI_DI,a 
011e			.ssb2:  ; output bit to ensure it is stable 
011e d3 80			out (storage_adata),a 
0120 00				nop 
0121				; clock bit high 
0121 cb ef			set SPI_SCLK,a 
0123 d3 80			out (storage_adata),a 
0125 00				nop 
0126 cd f8 00			call spi_clk 
0129				; then low 
0129 cb af			res SPI_SCLK,a 
012b d3 80			out (storage_adata),a 
012d 00				nop 
012e cd f8 00			call spi_clk 
0131 10 e3			djnz .ssb1 
0133			 
0133 32 96 f9			ld (spi_portbyte),a 
0136 c9				ret 
0137			 
0137			; TODO low level get byte into A on spi 
0137			 
0137			spi_read_byte:  
0137			 
0137				; save byte to send for bit mask shift out 
0137 0e 00		    ld c,0 
0139 3a 96 f9			ld a,(spi_portbyte) 
013c				  
013c				; clock out	each bit of the byte msb first 
013c			 
013c			 
013c				; clock bit high 
013c cb ef			set SPI_SCLK,a 
013e d3 80			out (storage_adata),a 
0140 00				nop 
0141 cd f8 00			call spi_clk 
0144			 
0144			    ; read DO  
0144			 
0144 cb f9		    set 7,c 
0146 db 80			in a,(storage_adata) 
0148 cb 77		    bit SPI_DO,a 
014a 20 02		    jr nz, .b7 
014c cb b9		    res 7,c 
014e			.b7: 
014e				; then low 
014e cb af			res SPI_SCLK,a 
0150 d3 80			out (storage_adata),a 
0152 00				nop 
0153 cd f8 00			call spi_clk 
0156			     
0156			 
0156				; clock bit high 
0156 cb ef			set SPI_SCLK,a 
0158 d3 80			out (storage_adata),a 
015a 00				nop 
015b cd f8 00			call spi_clk 
015e			 
015e			    ; read DO  
015e			 
015e cb f1		    set 6,c 
0160 db 80			in a,(storage_adata) 
0162 cb 77		    bit SPI_DO,a 
0164 20 02		    jr nz, .b6 
0166 cb b1		    res 6,c 
0168			.b6: 
0168				; then low 
0168 cb af			res SPI_SCLK,a 
016a d3 80			out (storage_adata),a 
016c 00				nop 
016d cd f8 00			call spi_clk 
0170			 
0170				; clock bit high 
0170 cb ef			set SPI_SCLK,a 
0172 d3 80			out (storage_adata),a 
0174 00				nop 
0175 cd f8 00			call spi_clk 
0178			 
0178			 
0178			    ; read DO  
0178			 
0178 cb e9		    set 5,c 
017a db 80			in a,(storage_adata) 
017c cb 77		    bit SPI_DO,a 
017e 20 02		    jr nz, .b5 
0180 cb a9		    res 5,c 
0182			.b5: 
0182				; then low 
0182 cb af			res SPI_SCLK,a 
0184 d3 80			out (storage_adata),a 
0186 00				nop 
0187 cd f8 00			call spi_clk 
018a				; clock bit high 
018a cb ef			set SPI_SCLK,a 
018c d3 80			out (storage_adata),a 
018e 00				nop 
018f cd f8 00			call spi_clk 
0192			 
0192			    ; read DO  
0192			 
0192 cb e1		    set 4,c 
0194 db 80			in a,(storage_adata) 
0196 cb 77		    bit SPI_DO,a 
0198 20 02		    jr nz, .b4 
019a cb a1		    res 4,c 
019c			.b4: 
019c				; then low 
019c cb af			res SPI_SCLK,a 
019e d3 80			out (storage_adata),a 
01a0 00				nop 
01a1 cd f8 00			call spi_clk 
01a4				; clock bit high 
01a4 cb ef			set SPI_SCLK,a 
01a6 d3 80			out (storage_adata),a 
01a8 00				nop 
01a9 cd f8 00			call spi_clk 
01ac			 
01ac			    ; read DO  
01ac			 
01ac cb d9		    set 3,c 
01ae db 80			in a,(storage_adata) 
01b0 cb 77		    bit SPI_DO,a 
01b2 20 02		    jr nz, .b3 
01b4 cb 99		    res 3,c 
01b6			.b3: 
01b6				; then low 
01b6 cb af			res SPI_SCLK,a 
01b8 d3 80			out (storage_adata),a 
01ba 00				nop 
01bb cd f8 00			call spi_clk 
01be				; clock bit high 
01be cb ef			set SPI_SCLK,a 
01c0 d3 80			out (storage_adata),a 
01c2 00				nop 
01c3 cd f8 00			call spi_clk 
01c6			 
01c6			    ; read DO  
01c6			 
01c6 cb d1		    set 2,c 
01c8 db 80			in a,(storage_adata) 
01ca cb 77		    bit SPI_DO,a 
01cc 20 02		    jr nz, .b2 
01ce cb 91		    res 2,c 
01d0			.b2: 
01d0				; then low 
01d0 cb af			res SPI_SCLK,a 
01d2 d3 80			out (storage_adata),a 
01d4 00				nop 
01d5 cd f8 00			call spi_clk 
01d8				; clock bit high 
01d8 cb ef			set SPI_SCLK,a 
01da d3 80			out (storage_adata),a 
01dc 00				nop 
01dd cd f8 00			call spi_clk 
01e0			 
01e0			    ; read DO  
01e0			 
01e0 cb c9		    set 1,c 
01e2 db 80			in a,(storage_adata) 
01e4 cb 77		    bit SPI_DO,a 
01e6 20 02		    jr nz, .b1 
01e8 cb 89		    res 1,c 
01ea			.b1: 
01ea				; then low 
01ea cb af			res SPI_SCLK,a 
01ec d3 80			out (storage_adata),a 
01ee 00				nop 
01ef cd f8 00			call spi_clk 
01f2				; clock bit high 
01f2 cb ef			set SPI_SCLK,a 
01f4 d3 80			out (storage_adata),a 
01f6 00				nop 
01f7 cd f8 00			call spi_clk 
01fa			 
01fa			    ; read DO  
01fa			 
01fa cb c1		    set 0,c 
01fc db 80			in a,(storage_adata) 
01fe cb 77		    bit SPI_DO,a 
0200 20 02		    jr nz, .b0 
0202 cb 81		    res 0,c 
0204			.b0: 
0204				; then low 
0204 cb af			res SPI_SCLK,a 
0206 d3 80			out (storage_adata),a 
0208 00				nop 
0209 cd f8 00			call spi_clk 
020c			 
020c			 
020c 32 96 f9			ld (spi_portbyte),a 
020f			 
020f			    ; return byte 
020f 79			    ld a,c 
0210			 
0210			 
0210 c9				ret 
0211			 
0211			 
0211			 
0211			spi_ce_high: 
0211			 
0211				if DEBUG_SPI_HARD_CE0 
0211			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0211					ret 
0211			 
0211				endif 
0211			 
0211			 
0211 f5				push af 
0212			 
0212				; send direct ce to port b 
0212 3e ff			ld a, 255 
0214 d3 81			out (storage_bdata), a 
0216			 
0216 f1				pop af 
0217			 
0217				; for port a that shares with spi lines AND the mask 
0217			  
0217				if DEBUG_SPI 
0217					push hl 
0217					ld h, a 
0217				endif 
0217			;	ld c, SPI_CE_HIGH 
0217			;	and c 
0217 cb c7			set SPI_CE0, a 
0219 cb cf			set SPI_CE1, a 
021b cb d7			set SPI_CE2, a 
021d cb df			set SPI_CE3, a 
021f cb e7			set SPI_CE4, a 
0221			 
0221				if DEBUG_SPI 
0221					ld l, a 
0221					DMARK "CEh" 
0221					CALLMONITOR 
0221					pop hl 
0221				endif 
0221 c9				ret 
0222			 
0222			 
0222			spi_ce_low: 
0222			 
0222				if DEBUG_SPI_HARD_CE0 
0222			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0222					ret 
0222			 
0222				endif 
0222			 
0222 c5				push bc 
0223 f5				push af 
0224			 
0224				; send direct ce to port b 
0224 3a 98 f9			ld a, (spi_cartdev) 
0227 d3 81			out (storage_bdata), a 
0229			 
0229			 
0229			 
0229				; for port a that shares with spi lines AND the mask 
0229			 
0229 3a 95 f9			ld a, (spi_device)  
022c 4f				ld c, a 
022d			 
022d f1				pop af 
022e			 
022e				; detect CEx 
022e			 
022e				if DEBUG_SPI 
022e					push hl 
022e					ld h, a 
022e				endif 
022e			 
022e cb 41			bit SPI_CE0, c 
0230 20 04			jr nz, .cel1 
0232 cb 87			res SPI_CE0, a 
0234 18 1e			jr .celn 
0236			.cel1: 
0236 cb 49			bit SPI_CE1, c 
0238 20 04			jr nz, .cel2 
023a cb 8f			res SPI_CE1, a 
023c 18 16			jr .celn 
023e			.cel2: 
023e cb 51			bit SPI_CE2, c 
0240 20 04			jr nz, .cel3 
0242 cb 97			res SPI_CE2, a 
0244 18 0e			jr .celn 
0246			.cel3: 
0246 cb 59			bit SPI_CE3, c 
0248 20 04			jr nz, .cel4 
024a cb 9f			res SPI_CE3, a 
024c 18 06			jr .celn 
024e			.cel4: 
024e cb 61			bit SPI_CE4, c 
0250 20 02			jr nz, .celn 
0252 cb a7			res SPI_CE4, a 
0254			.celn: 
0254			 
0254			 
0254			 
0254			;	add c 
0254			 
0254				if DEBUG_SPI 
0254					ld l, a 
0254					DMARK "CEl" 
0254					CALLMONITOR 
0254					pop hl 
0254				endif 
0254 c1				pop bc 
0255 c9				ret 
0256			 
0256			 
0256			 
0256			; eof 
0256			 
0256			 
0256			 
0256			 
0256			 
# End of file firmware_spi.asm
0256				include "firmware_seeprom.asm"  
0256			; 
0256			; persisent storage interface via microchip serial eeprom 
0256			 
0256			; port a pio 2 
0256			; pa 7 - si 
0256			; pa 6 - sclk  
0256			; pa 5 - so 
0256			; pa 4 - cs 
0256			; pa 3 - cs 
0256			; pa 2 - cs 
0256			; pa 1 - cs 
0256			; pa 0 - cs 
0256			; 
0256			; TODO get block 
0256			; TODO save block 
0256			; TODO load file 
0256			; TODO save file 
0256			; TODO get dir  
0256			 
0256			;  
0256			storage_adata: equ Device_C    ; device c port a - onboard storage 
0256			storage_actl: equ Device_C+2     ; device c port a 
0256			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0256			storage_bctl: equ Device_C+3     ; device c port b 
0256			 
0256			 
0256			; TODO move these to hardware driver file 
0256			 
0256			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0256			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0256			; storage bank file system format 
0256			; 
0256			; first page of bank: 
0256			; 	addr 0 - status check 
0256			;       addr 1 - write protect flag 
0256			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0256			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0256			;         TODO see if scanning whole of for available next file id is fast enough 
0256			;	addr 4 > zero term string of bank label 
0256			; 
0256			;        
0256			;  
0256			; first page of any file: 
0256			;      byte 0 - file id  
0256			;      byte 1-17 - fixed file name  
0256			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0256			; 
0256			; other pages of any file: 
0256			;      byte 0 - file id 
0256			;      byte 1> - file data 
0256			; 
0256			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0256			;  
0256			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0256			 
0256			 
0256			;storage_so_bit: 5 
0256			;storage_si_bit: 7 
0256			;storage_sclk_bit: 6 
0256			  
0256			 
0256			; init storage pio 
0256			 
0256			storage_init: 
0256			 
0256			 
0256					; set default SPI clk pulse time as disabled 
0256			 
0256 3e 00				ld a, 0 
0258 32 99 f9				ld (spi_clktime), a 
025b			 
025b					; init hardware 
025b			 
025b 3e cf		            LD   A, 11001111b 
025d d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
025f 3e 00		            LD   A, 00000000b 
0261 cb f7			set SPI_DO,a 
0263			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0263 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0265			 
0265 3e cf		            LD   A, 11001111b 
0267 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0269 3e 00		            LD   A, 00000000b 
026b d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
026d			 
026d				; set all external spi devices off  
026d 3e ff			ld a, 255 
026f 32 95 f9			ld (spi_device), a 
0272 32 98 f9			ld (spi_cartdev), a 
0275			 
0275					; ensure the spi bus is in a default stable state 
0275 cd 05 01				call se_stable_spi 
0278			 
0278			; TODO scan spi bus and gather which storage banks are present 
0278			 
0278			; populate store_bank_active  
0278			; for each ce line activate and attempt to write first byte of bank and read back 
0278			; if zero is returned then bank is empty 
0278			;   
0278			; 
0278			 
0278					; init file extent cache to save on slow reads 
0278			 
0278			;	ld hl, store_filecache 
0278			;	ld de, 0 
0278			;	ld hl,(de)	 
0278			 
0278			 
0278 c9			    ret 
0279			 
0279			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0279			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0279			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0279			 
0279			; INSTRUCTION SET 
0279			; READ 0000 0011 Read data from memory array beginning at selected address 
0279			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0279			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0279			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0279			; RDSR 0000 0101 Read STATUS register 
0279			; WRSR 0000 0001 Write STATUS register 
0279			; PE 0100 0010 Page Erase – erase one page in memory array 
0279			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0279			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0279			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0279			 
0279			; TODO send byte steam for page without setting the address for every single byte 
0279			; TODO read byte  
0279			 
0279			; byte in a 
0279			; address in hl  
0279			se_writebyte: 
0279			        
0279			    ;   ld c, a 
0279 f5			        push af 
027a e5			        push hl 
027b			 
027b			    ; initi write mode 
027b			    ; 
027b			    ;CS low 
027b			 
027b 3a 96 f9		       ld a,(spi_portbyte) 
027e cd 22 02			call spi_ce_low 
0281			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0281 d3 80		       out (storage_adata),a 
0283 32 96 f9		       ld (spi_portbyte), a 
0286			 
0286			    ;clock out wren instruction 
0286			 
0286 3e 06		    ld a, store_wren_ins 
0288 cd 10 01		    call spi_send_byte  
028b			 
028b			    ;cs high to enable write latch 
028b			 
028b 3a 96 f9		       ld a,(spi_portbyte) 
028e cd 11 02			call spi_ce_high 
0291			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0291 d3 80		       out (storage_adata),a 
0293 32 96 f9		       ld (spi_portbyte), a 
0296			 
0296 00				nop 
0297			    ; 
0297			    ; intial write data 
0297			    ; 
0297			    ; cs low 
0297			     
0297 3a 96 f9		       ld a,(spi_portbyte) 
029a cd 22 02			call spi_ce_low 
029d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
029d d3 80		       out (storage_adata),a 
029f 32 96 f9		       ld (spi_portbyte), a 
02a2			 
02a2			    ; clock out write instruction 
02a2			     
02a2 3e 02		    ld a, store_write_ins  
02a4 cd 10 01		    call spi_send_byte  
02a7			 
02a7			    ; clock out address (depending on address size) 
02a7			     
02a7 e1			    pop hl 
02a8 7c			    ld a,h    ; address out msb first 
02a9 cd 10 01		    call spi_send_byte  
02ac 7d			    ld a,l 
02ad cd 10 01		    call spi_send_byte  
02b0			 
02b0			    ; clock out byte(s) for page 
02b0			 
02b0 f1			    pop af 
02b1 cd 10 01		    call spi_send_byte  
02b4			 
02b4			    ; end write with ce high 
02b4 3a 96 f9		       ld a,(spi_portbyte) 
02b7			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b7 cd 11 02			call spi_ce_high 
02ba d3 80		       out (storage_adata),a 
02bc 32 96 f9		       ld (spi_portbyte), a 
02bf			 
02bf				; pause for internal write cycle 
02bf 3e 0a			ld a, 10 
02c1 cd d2 0c			call aDelayInMS 
02c4 c9			    ret 
02c5			 
02c5			; buffer to write in de 
02c5			; address in hl  
02c5			se_writepage: 
02c5			        
02c5			    ;   ld c, a 
02c5 d5				push de 
02c6 e5			        push hl 
02c7			 
02c7			    ; initi write mode 
02c7			    ; 
02c7			    ;CS low 
02c7			 
02c7 3a 96 f9		       ld a,(spi_portbyte) 
02ca cd 22 02			call spi_ce_low 
02cd			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cd d3 80		       out (storage_adata),a 
02cf 32 96 f9		       ld (spi_portbyte), a 
02d2			 
02d2			    ;clock out wren instruction 
02d2			 
02d2 3e 06		    ld a, store_wren_ins 
02d4 cd 10 01		    call spi_send_byte  
02d7			 
02d7			    ;cs high to enable write latch 
02d7			 
02d7 3a 96 f9		       ld a,(spi_portbyte) 
02da cd 11 02			call spi_ce_high 
02dd			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02dd d3 80		       out (storage_adata),a 
02df 32 96 f9		       ld (spi_portbyte), a 
02e2			 
02e2 00				nop 
02e3			    ; 
02e3			    ; intial write data 
02e3			    ; 
02e3			    ; cs low 
02e3			     
02e3 3a 96 f9		       ld a,(spi_portbyte) 
02e6			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02e6 cd 22 02			call spi_ce_low 
02e9 d3 80		       out (storage_adata),a 
02eb 32 96 f9		       ld (spi_portbyte), a 
02ee			 
02ee			    ; clock out write instruction 
02ee			     
02ee 3e 02		    ld a, store_write_ins  
02f0 cd 10 01		    call spi_send_byte  
02f3			 
02f3			    ; clock out address (depending on address size) 
02f3			     
02f3 e1			    pop hl 
02f4 7c			    ld a,h    ; address out msb first 
02f5 cd 10 01		    call spi_send_byte  
02f8 7d			    ld a,l 
02f9 cd 10 01		    call spi_send_byte  
02fc			 
02fc			    ; clock out byte(s) for page 
02fc			 
02fc e1				pop hl 
02fd 06 40			ld b, STORE_BLOCK_PHY 
02ff			.bytewrite: 
02ff			 
02ff 7e				ld a,(hl) 
0300 e5			    push hl 
0301 c5				push bc 
0302 cd 10 01		    call spi_send_byte  
0305 c1				pop bc 
0306 e1				pop hl 
0307			 
0307			    ; end write with ce high 
0307 3a 96 f9		       ld a,(spi_portbyte) 
030a cd 11 02			call spi_ce_high 
030d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
030d d3 80		       out (storage_adata),a 
030f 32 96 f9		       ld (spi_portbyte), a 
0312			 
0312 23				inc hl 
0313 10 ea			djnz .bytewrite 
0315			 
0315				; pause for internal write cycle 
0315 3e 64			ld a, 100 
0317 cd d2 0c			call aDelayInMS 
031a c9			    ret 
031b			; returns byte in a 
031b			; address in hl  
031b			se_readbyte: 
031b d5				push de 
031c c5				push bc 
031d			 
031d			    ;   ld c, a 
031d e5			        push hl 
031e			 
031e			    ; initi write mode 
031e			    ; 
031e			    ;CS low 
031e			 
031e 3a 96 f9		       ld a,(spi_portbyte) 
0321 cd 22 02			call spi_ce_low 
0324			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0324 d3 80		       out (storage_adata),a 
0326 32 96 f9		       ld (spi_portbyte), a 
0329			 
0329			    ;clock out wren instruction 
0329			 
0329 3e 03		    ld a, store_read_ins 
032b cd 10 01		    call spi_send_byte  
032e			 
032e			 
032e			    ; clock out address (depending on address size) 
032e			     
032e e1			    pop hl 
032f 7c			    ld a,h    ; address out msb first 
0330 cd 10 01		    call spi_send_byte  
0333 7d			    ld a,l 
0334 cd 10 01		    call spi_send_byte  
0337			 
0337			    ; clock in byte(s) for page 
0337			 
0337 cd 37 01		    call spi_read_byte  
033a f5				push af 
033b			 
033b			    ; end write with ce high 
033b 3a 96 f9		       ld a,(spi_portbyte) 
033e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
033e cd 11 02			call spi_ce_high 
0341 d3 80		       out (storage_adata),a 
0343 32 96 f9		       ld (spi_portbyte), a 
0346			 
0346 f1				pop af 
0347			 
0347 c1				pop bc 
0348 d1				pop de 
0349			 
0349 c9			    ret 
034a			 
034a			if DEBUG_STORESE 
034a			 
034a			storageput:  
034a			 
034a			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
034a			 
034a 21 f8 f0			ld hl,scratch+2 
034d cd 9d 12			call get_word_hl 
0350			 
0350				; stuff it here for the moment as it will be overwritten later anyway 
0350			 
0350 22 19 f4			ld (os_cur_ptr),hl	 
0353			 
0353			 
0353			; get pointer to start of string 
0353			 
0353 21 fd f0			ld hl, scratch+7 
0356			 
0356			; loop writing char of string to eeprom 
0356			 
0356 7e			.writestr:	ld a,(hl) 
0357 fe 00				cp 0 
0359 28 12				jr z, .wsdone		; done writing 
035b e5					push hl 
035c 2a 19 f4				ld hl,(os_cur_ptr) 
035f cd 79 02				call se_writebyte 
0362			 
0362 2a 19 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0365 23					inc hl 
0366 22 19 f4				ld (os_cur_ptr),hl 
0369			 
0369					; restore string pointer and get next char 
0369			 
0369 e1					pop hl 
036a 23					inc hl 
036b 18 e9				jr .writestr 
036d			 
036d			 
036d			 
036d			.wsdone: 
036d			 
036d			 
036d			; when done load first page into a buffer  
036d			 
036d 21 00 80				ld hl,08000h		; start in ram 
0370 22 19 f4				ld (os_cur_ptr),hl 
0373 21 00 00				ld hl, 0		 ; start of page 
0376 22 1e f1				ld (scratch+40),hl	; hang on to it 
0379			 
0379 06 80				ld b, 128		; actually get more then one page 
037b c5			.wsload:	push bc 
037c 2a 1e f1				ld hl,(scratch+40) 
037f e5					push hl 
0380 cd 1b 03				call se_readbyte 
0383			 
0383					; a now as the byte 
0383			 
0383 2a 19 f4				ld hl,(os_cur_ptr) 
0386 77					ld (hl),a 
0387					; inc next buffer area 
0387 23					inc hl 
0388 22 19 f4				ld (os_cur_ptr),hl 
038b			 
038b					; get eeprom position, inc and save for next round 
038b e1					pop hl		 
038c 23					inc hl 
038d 22 1e f1				ld (scratch+40),hl 
0390 c1					pop bc 
0391 10 e8				djnz .wsload 
0393			 
0393			; set 'd' pointer to start of buffer 
0393			 
0393 21 00 80				ld hl,08000h 
0396 22 19 f4				ld (os_cur_ptr),hl 
0399			 
0399			 
0399 c9			ret 
039a			 
039a			 
039a c9			storageread: ret 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			endif 
039b			 
039b			 
039b			 
# End of file firmware_seeprom.asm
039b			else  
039b			   ; create some stubs for the labels  
039b			se_readbyte: ret  
039b			se_writebyte: ret  
039b			storage_init: ret  
039b			  
039b			endif  
039b			  
039b			; use cf card for storage - throwing timeout errors. Hardware or software?????  
039b			;include "firmware_cf.asm"  
039b			  
039b			; load up high level storage hardward abstractions  
039b			include "firmware_storage.asm"  
039b			 
039b			; persisent storage hardware abstraction layer  
039b			 
039b			 
039b			 
039b			; Block 0 on storage is a config state 
039b			 
039b			 
039b			 
039b			; TODO add read phy block and write phy block functions 
039b			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
039b			 
039b			; Abstraction layer  
039b			 
039b			; Logocial block size is same size as physical size - using tape concept 
039b			 
039b			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
039b			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
039b			 
039b			 
039b			 
039b			; Filesystem layout (Logical layout) 
039b			; 
039b			; Block 0 - Bank config  
039b			; 
039b			;      Byte - 0 file id counter 
039b			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
039b			;      Byte - 3-20 zero terminated bank label 
039b			; 
039b			; Block 1 > File storage 
039b			; 
039b			;      Byte 0 file id    - block 0 file details 
039b			;      Byte 1 block id - block 0 is file  
039b			;            Byte 2-15 - File name 
039b			; 
039b			;       - to end of block data 
039b			; 
039b			 
039b			; Get ID for the file named in pointer held HL 
039b			; Returns ID in HL = 255 if no file found 
039b			 
039b			storage_getid: 
039b			 
039b 22 a8 f9			ld (store_tmp1), hl 
039e			 
039e				if DEBUG_STORESE 
039e					DMARK "SGI" 
039e f5				push af  
039f 3a b3 03			ld a, (.dmark)  
03a2 32 a0 fd			ld (debug_mark),a  
03a5 3a b4 03			ld a, (.dmark+1)  
03a8 32 a1 fd			ld (debug_mark+1),a  
03ab 3a b5 03			ld a, (.dmark+2)  
03ae 32 a2 fd			ld (debug_mark+2),a  
03b1 18 03			jr .pastdmark  
03b3 ..			.dmark: db "SGI"  
03b6 f1			.pastdmark: pop af  
03b7			endm  
# End of macro DMARK
03b7					CALLMONITOR 
03b7 cd aa fd			call debug_vector  
03ba				endm  
# End of macro CALLMONITOR
03ba				endif 
03ba				; get block 0 and set counter for number of files to scan 
03ba			 
03ba cd 25 05			call storage_get_block_0 
03bd			 
03bd 3a af f9			ld a, (store_page) 
03c0 47				ld b, a 
03c1			 
03c1				; get extent 0 of each file id 
03c1			 
03c1				if DEBUG_STORESE 
03c1					DMARK "SGc" 
03c1 f5				push af  
03c2 3a d6 03			ld a, (.dmark)  
03c5 32 a0 fd			ld (debug_mark),a  
03c8 3a d7 03			ld a, (.dmark+1)  
03cb 32 a1 fd			ld (debug_mark+1),a  
03ce 3a d8 03			ld a, (.dmark+2)  
03d1 32 a2 fd			ld (debug_mark+2),a  
03d4 18 03			jr .pastdmark  
03d6 ..			.dmark: db "SGc"  
03d9 f1			.pastdmark: pop af  
03da			endm  
# End of macro DMARK
03da					CALLMONITOR 
03da cd aa fd			call debug_vector  
03dd				endm  
# End of macro CALLMONITOR
03dd				endif 
03dd 60			.getloop:	ld h, b 
03de 2e 00				ld l, 0 
03e0 c5					push bc 
03e1			 
03e1 11 af f9				ld de, store_page 
03e4				if DEBUG_STORESE 
03e4					DMARK "SGr" 
03e4 f5				push af  
03e5 3a f9 03			ld a, (.dmark)  
03e8 32 a0 fd			ld (debug_mark),a  
03eb 3a fa 03			ld a, (.dmark+1)  
03ee 32 a1 fd			ld (debug_mark+1),a  
03f1 3a fb 03			ld a, (.dmark+2)  
03f4 32 a2 fd			ld (debug_mark+2),a  
03f7 18 03			jr .pastdmark  
03f9 ..			.dmark: db "SGr"  
03fc f1			.pastdmark: pop af  
03fd			endm  
# End of macro DMARK
03fd					CALLMONITOR 
03fd cd aa fd			call debug_vector  
0400				endm  
# End of macro CALLMONITOR
0400				endif 
0400 cd cd 09				call storage_read 
0403 cd 07 10				call ishlzero 
0406 28 2d				jr z, .gap 
0408					 
0408					; have a file name read. Is it one we want. 
0408			 
0408 2a a8 f9				ld hl, (store_tmp1) 
040b 11 b2 f9				ld de, store_page+3   ; file name 
040e			 
040e				if DEBUG_STORESE 
040e					DMARK "SGc" 
040e f5				push af  
040f 3a 23 04			ld a, (.dmark)  
0412 32 a0 fd			ld (debug_mark),a  
0415 3a 24 04			ld a, (.dmark+1)  
0418 32 a1 fd			ld (debug_mark+1),a  
041b 3a 25 04			ld a, (.dmark+2)  
041e 32 a2 fd			ld (debug_mark+2),a  
0421 18 03			jr .pastdmark  
0423 ..			.dmark: db "SGc"  
0426 f1			.pastdmark: pop af  
0427			endm  
# End of macro DMARK
0427					CALLMONITOR 
0427 cd aa fd			call debug_vector  
042a				endm  
# End of macro CALLMONITOR
042a				endif 
042a cd 7c 13				call strcmp 
042d 20 06				jr nz, .gap   ; not this one 
042f			 
042f c1				        pop bc 
0430			 
0430 26 00				ld h, 0 
0432 68					ld l, b 
0433 18 22				jr .getdone 
0435						 
0435			 
0435			 
0435			 
0435			.gap: 
0435				if DEBUG_STORESE 
0435					DMARK "SGg" 
0435 f5				push af  
0436 3a 4a 04			ld a, (.dmark)  
0439 32 a0 fd			ld (debug_mark),a  
043c 3a 4b 04			ld a, (.dmark+1)  
043f 32 a1 fd			ld (debug_mark+1),a  
0442 3a 4c 04			ld a, (.dmark+2)  
0445 32 a2 fd			ld (debug_mark+2),a  
0448 18 03			jr .pastdmark  
044a ..			.dmark: db "SGg"  
044d f1			.pastdmark: pop af  
044e			endm  
# End of macro DMARK
044e					CALLMONITOR 
044e cd aa fd			call debug_vector  
0451				endm  
# End of macro CALLMONITOR
0451				endif 
0451			 
0451 c1					pop bc 
0452 10 89				djnz .getloop 
0454 21 ff 00				ld hl, 255 
0457			.getdone: 
0457			 
0457				if DEBUG_STORESE 
0457					DMARK "SGe" 
0457 f5				push af  
0458 3a 6c 04			ld a, (.dmark)  
045b 32 a0 fd			ld (debug_mark),a  
045e 3a 6d 04			ld a, (.dmark+1)  
0461 32 a1 fd			ld (debug_mark+1),a  
0464 3a 6e 04			ld a, (.dmark+2)  
0467 32 a2 fd			ld (debug_mark+2),a  
046a 18 03			jr .pastdmark  
046c ..			.dmark: db "SGe"  
046f f1			.pastdmark: pop af  
0470			endm  
# End of macro DMARK
0470					CALLMONITOR 
0470 cd aa fd			call debug_vector  
0473				endm  
# End of macro CALLMONITOR
0473				endif 
0473			 
0473 c9				ret 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			; Read Block 
0474			; ---------- 
0474			; 
0474			; With current bank 
0474			;  
0474			; Get block number to read 
0474			; Load physical blocks starting at start block into buffer 
0474			 
0474			; de points to buffer to use 
0474			; hl holds logical block number  
0474			 
0474			storage_read_block: 
0474			 
0474				; TODO bank selection 
0474			 
0474				; for each of the physical blocks read it into the buffer 
0474 06 40			ld b, STORE_BLOCK_PHY 
0476			 
0476				if DEBUG_STORESE 
0476 d5					push de 
0477				endif 
0477				 
0477			.rl1:    
0477			 
0477				; read physical block at hl into de 
0477			        ; increment hl and de to next read position on exit 
0477			 
0477 e5				push hl 
0478 d5				push de	 
0479 c5				push bc 
047a			;	if DEBUG_STORESE 
047a			;		push af 
047a			;		ld a, 'R' 
047a			;		ld (debug_mark),a 
047a			;		pop af 
047a			;		CALLMONITOR 
047a			;	endif 
047a cd 1b 03			call se_readbyte 
047d			;	if DEBUG_STORESE 
047d			;		ld a,(spi_portbyte) 
047d			;		ld l, a 
047d			;		push af 
047d			;		ld a, '1' 
047d			;		ld (debug_mark),a 
047d			;		pop af 
047d			;		CALLMONITOR 
047d			;	endif 
047d c1				pop bc 
047e d1				pop de 
047f e1				pop hl 
0480 12				ld (de),a 
0481 23				inc hl 
0482 13				inc de 
0483			 
0483			;	if DEBUG_STORESE 
0483			;		push af 
0483			;		ld a, 'r' 
0483			;		ld (debug_mark),a 
0483			;		pop af 
0483			;		CALLMONITOR 
0483			;	endif 
0483			 
0483 10 f2			djnz .rl1 
0485			 
0485				if DEBUG_STORESE 
0485					DMARK "SRB" 
0485 f5				push af  
0486 3a 9a 04			ld a, (.dmark)  
0489 32 a0 fd			ld (debug_mark),a  
048c 3a 9b 04			ld a, (.dmark+1)  
048f 32 a1 fd			ld (debug_mark+1),a  
0492 3a 9c 04			ld a, (.dmark+2)  
0495 32 a2 fd			ld (debug_mark+2),a  
0498 18 03			jr .pastdmark  
049a ..			.dmark: db "SRB"  
049d f1			.pastdmark: pop af  
049e			endm  
# End of macro DMARK
049e d1					pop de 
049f			; 
049f			;		push af 
049f			;		ld a, 'R' 
049f			;		ld (debug_mark),a 
049f			;		pop af 
049f					CALLMONITOR 
049f cd aa fd			call debug_vector  
04a2				endm  
# End of macro CALLMONITOR
04a2				endif 
04a2 c9				ret	 
04a3				 
04a3			 
04a3			; File Size 
04a3			; --------- 
04a3			; 
04a3			;   hl file id 
04a3			; 
04a3			;  returns in hl the number of blocks 
04a3			 
04a3			storage_file_size: 
04a3 5d				ld e, l 
04a4 16 00			ld d, 0 
04a6 21 40 00			ld hl, STORE_BLOCK_PHY 
04a9					if DEBUG_FORTH_WORDS 
04a9						DMARK "SIZ" 
04a9 f5				push af  
04aa 3a be 04			ld a, (.dmark)  
04ad 32 a0 fd			ld (debug_mark),a  
04b0 3a bf 04			ld a, (.dmark+1)  
04b3 32 a1 fd			ld (debug_mark+1),a  
04b6 3a c0 04			ld a, (.dmark+2)  
04b9 32 a2 fd			ld (debug_mark+2),a  
04bc 18 03			jr .pastdmark  
04be ..			.dmark: db "SIZ"  
04c1 f1			.pastdmark: pop af  
04c2			endm  
# End of macro DMARK
04c2						CALLMONITOR 
04c2 cd aa fd			call debug_vector  
04c5				endm  
# End of macro CALLMONITOR
04c5					endif 
04c5 cd a7 07			call storage_findnextid 
04c8			 
04c8 cd 07 10			call ishlzero 
04cb			;	ld a, l 
04cb			;	add h 
04cb			;	cp 0 
04cb c8				ret z			; block not found so EOF 
04cc			 
04cc 11 af f9			ld de, store_page 
04cf cd 74 04			call storage_read_block 
04d2			 
04d2 3a b1 f9			ld a, (store_page+2)	 ; get extent count 
04d5 6f				ld l, a 
04d6 26 00			ld h, 0 
04d8 c9			 	ret 
04d9			 
04d9			 
04d9			; Write Block 
04d9			; ----------- 
04d9			; 
04d9			; With current bank 
04d9			;  
04d9			; Get block number to write 
04d9			; Write physical blocks starting at start block from buffer 
04d9			  
04d9			storage_write_block: 
04d9				; TODO bank selection 
04d9			 
04d9				; for each of the physical blocks read it into the buffer 
04d9 06 40			ld b, STORE_BLOCK_PHY 
04db			 
04db				if DEBUG_STORESE 
04db					DMARK "SWB" 
04db f5				push af  
04dc 3a f0 04			ld a, (.dmark)  
04df 32 a0 fd			ld (debug_mark),a  
04e2 3a f1 04			ld a, (.dmark+1)  
04e5 32 a1 fd			ld (debug_mark+1),a  
04e8 3a f2 04			ld a, (.dmark+2)  
04eb 32 a2 fd			ld (debug_mark+2),a  
04ee 18 03			jr .pastdmark  
04f0 ..			.dmark: db "SWB"  
04f3 f1			.pastdmark: pop af  
04f4			endm  
# End of macro DMARK
04f4			 
04f4					;push af 
04f4					;ld a, 'W' 
04f4					;ld (debug_mark),a 
04f4					;pop af 
04f4					CALLMONITOR 
04f4 cd aa fd			call debug_vector  
04f7				endm  
# End of macro CALLMONITOR
04f7				endif 
04f7			 
04f7			; might not be working 
04f7			;	call se_writepage 
04f7			 
04f7			;	ret 
04f7			; 
04f7			 
04f7			 
04f7			 
04f7			.wl1:    
04f7			 
04f7				; read physical block at hl into de 
04f7			        ; increment hl and de to next read position on exit 
04f7			 
04f7 e5				push hl 
04f8 d5				push de	 
04f9 c5				push bc 
04fa 1a				ld a,(de) 
04fb				;if DEBUG_STORESE 
04fb			;		push af 
04fb			;		ld a, 'W' 
04fb			;		ld (debug_mark),a 
04fb			;		pop af 
04fb			;		CALLMONITOR 
04fb			;	endif 
04fb cd 79 02			call se_writebyte 
04fe			;	call delay250ms 
04fe 00				nop 
04ff 00				nop 
0500 00				nop 
0501			;	if DEBUG_STORESE 
0501			;		push af 
0501			;		ld a, 'w' 
0501			;		ld (debug_mark),a 
0501			;		pop af 
0501			;		CALLMONITOR 
0501			;	endif 
0501 c1				pop bc 
0502 d1				pop de 
0503 e1				pop hl 
0504 23				inc hl 
0505 13				inc de 
0506			 
0506			 
0506 10 ef			djnz .wl1 
0508			 
0508				if DEBUG_STORESE 
0508					DMARK "SW2" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 a0 fd			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 a1 fd			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 a2 fd			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "SW2"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521			 
0521					;push af 
0521					;ld a, 'W' 
0521					;ld (debug_mark),a 
0521					;pop af 
0521					CALLMONITOR 
0521 cd aa fd			call debug_vector  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 c9				ret	 
0525			 
0525			; Init bank 
0525			; --------- 
0525			; 
0525			; With current bank 
0525			; 
0525			; Setup block 0 config 
0525			;     Set 0 file id counter 
0525			;     Set formatted byte pattern 
0525			;     Zero out bank label 
0525			;      
0525			; For every logical block write 0-1 byte as null 
0525			 
0525			storage_get_block_0: 
0525			 
0525				; TODO check presence 
0525			 
0525				; get block 0 config 
0525			 
0525 21 00 00			ld hl, 0 
0528 11 af f9			ld de, store_page 
052b cd 74 04			call storage_read_block 
052e			 
052e				if DEBUG_STORESE 
052e					DMARK "SB0" 
052e f5				push af  
052f 3a 43 05			ld a, (.dmark)  
0532 32 a0 fd			ld (debug_mark),a  
0535 3a 44 05			ld a, (.dmark+1)  
0538 32 a1 fd			ld (debug_mark+1),a  
053b 3a 45 05			ld a, (.dmark+2)  
053e 32 a2 fd			ld (debug_mark+2),a  
0541 18 03			jr .pastdmark  
0543 ..			.dmark: db "SB0"  
0546 f1			.pastdmark: pop af  
0547			endm  
# End of macro DMARK
0547 11 af f9				ld de, store_page 
054a			;		push af 
054a			;		ld a, 'i' 
054a			;		ld (debug_mark),a 
054a			;		pop af 
054a					CALLMONITOR 
054a cd aa fd			call debug_vector  
054d				endm  
# End of macro CALLMONITOR
054d				endif 
054d			 
054d				; is this area formatted? 
054d			 
054d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
054d 2a b0 f9			ld hl, (store_page+1) 
0550 3e 80			ld a,0x80 
0552 bd				cp l 
0553 20 22			jr nz, .ininotformatted 
0555				; do a double check 
0555 3e 27			ld a, 0x27 
0557 bc				cp h 
0558 20 1d			jr nz, .ininotformatted 
055a			 
055a				; formatted then 
055a			 
055a				if DEBUG_STORESE 
055a					DMARK "SB1" 
055a f5				push af  
055b 3a 6f 05			ld a, (.dmark)  
055e 32 a0 fd			ld (debug_mark),a  
0561 3a 70 05			ld a, (.dmark+1)  
0564 32 a1 fd			ld (debug_mark+1),a  
0567 3a 71 05			ld a, (.dmark+2)  
056a 32 a2 fd			ld (debug_mark+2),a  
056d 18 03			jr .pastdmark  
056f ..			.dmark: db "SB1"  
0572 f1			.pastdmark: pop af  
0573			endm  
# End of macro DMARK
0573					;push af 
0573					;ld a, 'I' 
0573					;ld (debug_mark),a 
0573					;pop af 
0573					CALLMONITOR 
0573 cd aa fd			call debug_vector  
0576				endm  
# End of macro CALLMONITOR
0576				endif 
0576 c9				ret 
0577			 
0577			.ininotformatted: 
0577				; bank not formatted so poke various bits to make sure 
0577			 
0577				if DEBUG_STORESE 
0577					DMARK "SB2" 
0577 f5				push af  
0578 3a 8c 05			ld a, (.dmark)  
057b 32 a0 fd			ld (debug_mark),a  
057e 3a 8d 05			ld a, (.dmark+1)  
0581 32 a1 fd			ld (debug_mark+1),a  
0584 3a 8e 05			ld a, (.dmark+2)  
0587 32 a2 fd			ld (debug_mark+2),a  
058a 18 03			jr .pastdmark  
058c ..			.dmark: db "SB2"  
058f f1			.pastdmark: pop af  
0590			endm  
# End of macro DMARK
0590					;push af 
0590					;ld a, 'f' 
0590					;ld (debug_mark),a 
0590					;pop af 
0590					CALLMONITOR 
0590 cd aa fd			call debug_vector  
0593				endm  
# End of macro CALLMONITOR
0593				endif 
0593			 
0593 cd b0 0c			call storage_clear_page 
0596			 
0596 21 af f9			ld hl, store_page 
0599 3e 00			ld a, 0 
059b				 
059b 77				ld (hl),a   ; reset file counter 
059c			 
059c 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
059f 22 b0 f9		 	ld (store_page+1), hl	 
05a2			 
05a2				; set default label 
05a2			 
05a2 21 3e 06			ld hl, .defaultbanklabl 
05a5 11 b2 f9		 	ld de, store_page+3 
05a8 01 0f 00			ld bc, 15 
05ab ed b0			ldir 
05ad			 
05ad				; Append the current bank id 
05ad 21 bb f9			ld hl, store_page+3+9 
05b0 3a 94 f9			ld a, (spi_device_id) 
05b3 77				ld (hl), a 
05b4			 
05b4				; save default page 0 
05b4			 
05b4 21 00 00			ld hl, 0 
05b7 11 af f9			ld de, store_page 
05ba				if DEBUG_STORESE 
05ba					DMARK "SB3" 
05ba f5				push af  
05bb 3a cf 05			ld a, (.dmark)  
05be 32 a0 fd			ld (debug_mark),a  
05c1 3a d0 05			ld a, (.dmark+1)  
05c4 32 a1 fd			ld (debug_mark+1),a  
05c7 3a d1 05			ld a, (.dmark+2)  
05ca 32 a2 fd			ld (debug_mark+2),a  
05cd 18 03			jr .pastdmark  
05cf ..			.dmark: db "SB3"  
05d2 f1			.pastdmark: pop af  
05d3			endm  
# End of macro DMARK
05d3			;		push af 
05d3			;		ld a, 'F' 
05d3			;		ld (debug_mark),a 
05d3			;		pop af 
05d3					CALLMONITOR 
05d3 cd aa fd			call debug_vector  
05d6				endm  
# End of macro CALLMONITOR
05d6				endif 
05d6 cd d9 04			call storage_write_block 
05d9				if DEBUG_STORESE 
05d9					DMARK "SB4" 
05d9 f5				push af  
05da 3a ee 05			ld a, (.dmark)  
05dd 32 a0 fd			ld (debug_mark),a  
05e0 3a ef 05			ld a, (.dmark+1)  
05e3 32 a1 fd			ld (debug_mark+1),a  
05e6 3a f0 05			ld a, (.dmark+2)  
05e9 32 a2 fd			ld (debug_mark+2),a  
05ec 18 03			jr .pastdmark  
05ee ..			.dmark: db "SB4"  
05f1 f1			.pastdmark: pop af  
05f2			endm  
# End of macro DMARK
05f2			;		push af 
05f2			;		ld a, '>' 
05f2			;		ld (debug_mark),a 
05f2			;		pop af 
05f2					CALLMONITOR 
05f2 cd aa fd			call debug_vector  
05f5				endm  
# End of macro CALLMONITOR
05f5				endif 
05f5			 
05f5 00				nop 
05f6 00				nop 
05f7 00				nop 
05f8			 
05f8				; now set 0 in every page to mark as a free block 
05f8			 
05f8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05fa 21 40 00			ld hl, STORE_BLOCK_PHY 
05fd			 
05fd 3e 00		.setmark1:   	ld a,0 
05ff e5					push hl 
0600 c5					push bc 
0601 cd 79 02				call se_writebyte 
0604 3e 0a			ld a, 10 
0606 cd d2 0c			call aDelayInMS 
0609 23				inc hl 
060a cd 79 02				call se_writebyte 
060d 3e 0a			ld a, 10 
060f cd d2 0c			call aDelayInMS 
0612 2b				dec hl 
0613 c1					pop bc 
0614 e1					pop hl 
0615 3e 40				ld a, STORE_BLOCK_PHY 
0617 cd de 0f				call addatohl 
061a 10 e1				djnz .setmark1 
061c			 
061c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
061e 3e 00		.setmark2:   	ld a,0 
0620 e5					push hl 
0621 c5					push bc 
0622 cd 79 02				call se_writebyte 
0625 3e 0a			ld a, 10 
0627 cd d2 0c			call aDelayInMS 
062a 23				inc hl 
062b cd 79 02				call se_writebyte 
062e 3e 0a			ld a, 10 
0630 cd d2 0c			call aDelayInMS 
0633 2b				dec hl 
0634 c1					pop bc 
0635 e1					pop hl 
0636 3e 40				ld a, STORE_BLOCK_PHY 
0638 cd de 0f				call addatohl 
063b 10 e1				djnz .setmark2 
063d			 
063d					 
063d			 
063d			 
063d c9				ret 
063e			 
063e			 
063e			 
063e			 
063e .. 00		.defaultbanklabl:   db "BankLabel_",0 
0649			 
0649			 
0649			 
0649			; Label Bank 
0649			; ---------- 
0649			; 
0649			; With current bank 
0649			; Read block 0 
0649			; Set label 
0649			; Write block 0 
0649			 
0649			; label str pointer in hl 
0649			 
0649			storage_label:     
0649			 
0649				if DEBUG_STORESE 
0649					DMARK "LBL" 
0649 f5				push af  
064a 3a 5e 06			ld a, (.dmark)  
064d 32 a0 fd			ld (debug_mark),a  
0650 3a 5f 06			ld a, (.dmark+1)  
0653 32 a1 fd			ld (debug_mark+1),a  
0656 3a 60 06			ld a, (.dmark+2)  
0659 32 a2 fd			ld (debug_mark+2),a  
065c 18 03			jr .pastdmark  
065e ..			.dmark: db "LBL"  
0661 f1			.pastdmark: pop af  
0662			endm  
# End of macro DMARK
0662					CALLMONITOR 
0662 cd aa fd			call debug_vector  
0665				endm  
# End of macro CALLMONITOR
0665				endif 
0665			 
0665 e5				push hl 
0666			 
0666 cd 25 05			call storage_get_block_0 
0669			 
0669				; set default label 
0669			 
0669 e1				pop hl 
066a			 
066a 11 b2 f9		 	ld de, store_page+3 
066d 01 0f 00			ld bc, 15 
0670				if DEBUG_STORESE 
0670					DMARK "LB3" 
0670 f5				push af  
0671 3a 85 06			ld a, (.dmark)  
0674 32 a0 fd			ld (debug_mark),a  
0677 3a 86 06			ld a, (.dmark+1)  
067a 32 a1 fd			ld (debug_mark+1),a  
067d 3a 87 06			ld a, (.dmark+2)  
0680 32 a2 fd			ld (debug_mark+2),a  
0683 18 03			jr .pastdmark  
0685 ..			.dmark: db "LB3"  
0688 f1			.pastdmark: pop af  
0689			endm  
# End of macro DMARK
0689					CALLMONITOR 
0689 cd aa fd			call debug_vector  
068c				endm  
# End of macro CALLMONITOR
068c				endif 
068c ed b0			ldir 
068e				; save default page 0 
068e			 
068e 21 00 00			ld hl, 0 
0691 11 af f9			ld de, store_page 
0694				if DEBUG_STORESE 
0694					DMARK "LBW" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 a0 fd			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 a1 fd			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 a2 fd			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "LBW"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad					CALLMONITOR 
06ad cd aa fd			call debug_vector  
06b0				endm  
# End of macro CALLMONITOR
06b0				endif 
06b0 cd d9 04			call storage_write_block 
06b3			 
06b3 c9				ret 
06b4			 
06b4			 
06b4			 
06b4			; Read Block 0 - Config 
06b4			; --------------------- 
06b4			; 
06b4			; With current bank 
06b4			; Call presence test 
06b4			;    If not present format/init bank  
06b4			; Read block 0  
06b4			;  
06b4			 
06b4			 
06b4			; Dir 
06b4			; --- 
06b4			; 
06b4			; With current bank 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block read byte 2 
06b4			;      if first block of file 
06b4			;         Display file name 
06b4			;         Display type flags for file 
06b4			;        
06b4			 
06b4			; moving to words as this requires stack control 
06b4			 
06b4			 
06b4			; Delete File 
06b4			; ----------- 
06b4			; 
06b4			; With current bank 
06b4			; 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block file id 
06b4			;      If first block of file and dont have file id 
06b4			;         if file to delete 
06b4			;         Save file id 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			;      If file id is one saved 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			 
06b4			 
06b4			.se_done: 
06b4 e1				pop hl 
06b5 c9				ret 
06b6			 
06b6			storage_erase: 
06b6			 
06b6				; hl contains the file id 
06b6			 
06b6 5d				ld e, l 
06b7 16 00			ld d, 0 
06b9 21 40 00			ld hl, STORE_BLOCK_PHY 
06bc					if DEBUG_FORTH_WORDS 
06bc						DMARK "ERA" 
06bc f5				push af  
06bd 3a d1 06			ld a, (.dmark)  
06c0 32 a0 fd			ld (debug_mark),a  
06c3 3a d2 06			ld a, (.dmark+1)  
06c6 32 a1 fd			ld (debug_mark+1),a  
06c9 3a d3 06			ld a, (.dmark+2)  
06cc 32 a2 fd			ld (debug_mark+2),a  
06cf 18 03			jr .pastdmark  
06d1 ..			.dmark: db "ERA"  
06d4 f1			.pastdmark: pop af  
06d5			endm  
# End of macro DMARK
06d5						CALLMONITOR 
06d5 cd aa fd			call debug_vector  
06d8				endm  
# End of macro CALLMONITOR
06d8					endif 
06d8 cd a7 07			call storage_findnextid 
06db cd 07 10			call ishlzero 
06de c8				ret z 
06df			 
06df e5				push hl 
06e0			 
06e0				; TODO check file not found 
06e0			 
06e0 11 af f9			ld de, store_page 
06e3 cd 74 04			call storage_read_block 
06e6			 
06e6 cd 07 10			call ishlzero 
06e9 ca b4 06			jp z,.se_done 
06ec			 
06ec					if DEBUG_FORTH_WORDS 
06ec						DMARK "ER1" 
06ec f5				push af  
06ed 3a 01 07			ld a, (.dmark)  
06f0 32 a0 fd			ld (debug_mark),a  
06f3 3a 02 07			ld a, (.dmark+1)  
06f6 32 a1 fd			ld (debug_mark+1),a  
06f9 3a 03 07			ld a, (.dmark+2)  
06fc 32 a2 fd			ld (debug_mark+2),a  
06ff 18 03			jr .pastdmark  
0701 ..			.dmark: db "ER1"  
0704 f1			.pastdmark: pop af  
0705			endm  
# End of macro DMARK
0705						CALLMONITOR 
0705 cd aa fd			call debug_vector  
0708				endm  
# End of macro CALLMONITOR
0708					endif 
0708 3a af f9			ld a, (store_page)	; get file id 
070b 32 a3 f9			ld (store_tmpid), a 
070e			 
070e 3a b1 f9			ld a, (store_page+2)    ; get count of extends 
0711 32 a2 f9			ld (store_tmpext), a 
0714			 
0714				; wipe file header 
0714			 
0714 e1				pop hl 
0715 3e 00			ld a, 0 
0717 32 af f9			ld (store_page), a 
071a 32 b0 f9			ld (store_page+1),a 
071d 11 af f9			ld de, store_page 
0720					if DEBUG_FORTH_WORDS 
0720						DMARK "ER2" 
0720 f5				push af  
0721 3a 35 07			ld a, (.dmark)  
0724 32 a0 fd			ld (debug_mark),a  
0727 3a 36 07			ld a, (.dmark+1)  
072a 32 a1 fd			ld (debug_mark+1),a  
072d 3a 37 07			ld a, (.dmark+2)  
0730 32 a2 fd			ld (debug_mark+2),a  
0733 18 03			jr .pastdmark  
0735 ..			.dmark: db "ER2"  
0738 f1			.pastdmark: pop af  
0739			endm  
# End of macro DMARK
0739						CALLMONITOR 
0739 cd aa fd			call debug_vector  
073c				endm  
# End of macro CALLMONITOR
073c					endif 
073c cd d9 04			call storage_write_block 
073f			 
073f			 
073f				; wipe file extents 
073f			 
073f 3a a2 f9			ld a, (store_tmpext) 
0742 47				ld b, a 
0743			 
0743			.eraext:	  
0743 c5				push bc 
0744			 
0744 21 40 00			ld hl, STORE_BLOCK_PHY 
0747 3a a3 f9			ld a,(store_tmpid) 
074a 5f				ld e, a 
074b 50				ld d, b	 
074c					if DEBUG_FORTH_WORDS 
074c						DMARK "ER3" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 a0 fd			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 a1 fd			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 a2 fd			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "ER3"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765						CALLMONITOR 
0765 cd aa fd			call debug_vector  
0768				endm  
# End of macro CALLMONITOR
0768					endif 
0768 cd a7 07			call storage_findnextid 
076b cd 07 10			call ishlzero 
076e ca b4 06			jp z,.se_done 
0771			 
0771 e5				push hl 
0772 11 af f9			ld de, store_page 
0775 cd 74 04			call storage_read_block 
0778			 
0778				; free block	 
0778			 
0778 3e 00			ld a, 0 
077a 32 af f9			ld (store_page), a 
077d 32 b0 f9			ld (store_page+1),a 
0780 11 af f9			ld de, store_page 
0783 e1				pop hl 
0784					if DEBUG_FORTH_WORDS 
0784						DMARK "ER4" 
0784 f5				push af  
0785 3a 99 07			ld a, (.dmark)  
0788 32 a0 fd			ld (debug_mark),a  
078b 3a 9a 07			ld a, (.dmark+1)  
078e 32 a1 fd			ld (debug_mark+1),a  
0791 3a 9b 07			ld a, (.dmark+2)  
0794 32 a2 fd			ld (debug_mark+2),a  
0797 18 03			jr .pastdmark  
0799 ..			.dmark: db "ER4"  
079c f1			.pastdmark: pop af  
079d			endm  
# End of macro DMARK
079d						CALLMONITOR 
079d cd aa fd			call debug_vector  
07a0				endm  
# End of macro CALLMONITOR
07a0					endif 
07a0 cd d9 04			call storage_write_block 
07a3			 
07a3 c1				pop bc 
07a4 10 9d			djnz .eraext 
07a6			 
07a6 c9				ret 
07a7			 
07a7			 
07a7			; Find Free Block 
07a7			; --------------- 
07a7			; 
07a7			; With current bank 
07a7			;  
07a7			; From given starting logical block 
07a7			;    Read block  
07a7			;    If no file id 
07a7			;         Return block id 
07a7			 
07a7			 
07a7			; hl starting page number 
07a7			; hl contains free page number or zero if no pages free 
07a7			; e contains the file id to locate 
07a7			; d contains the block number 
07a7			 
07a7			; TODO change to find file id and use zero for free block 
07a7			 
07a7			storage_findnextid: 
07a7			 
07a7				; now locate first 0 page to mark as a free block 
07a7			 
07a7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a9			;	ld hl, STORE_BLOCK_PHY 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FNI" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 a0 fd			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 a1 fd			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 a2 fd			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FNI"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2						CALLMONITOR 
07c2 cd aa fd			call debug_vector  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5			.ff1:   	 
07c5 e5					push hl 
07c6 c5					push bc 
07c7 d5					push de 
07c8 cd 1b 03				call se_readbyte 
07cb 5f					ld e,a 
07cc 23					inc hl 
07cd cd 1b 03				call se_readbyte 
07d0 57					ld d, a 
07d1 e1					pop hl 
07d2 e5					push hl 
07d3 cd fc 0f				call cmp16 
07d6 28 49				jr z, .fffound 
07d8			 
07d8 d1					pop de 
07d9 c1					pop bc 
07da e1					pop hl 
07db			 
07db					; is found? 
07db					;cp e 
07db					;ret z 
07db			 
07db 3e 40				ld a, STORE_BLOCK_PHY 
07dd cd de 0f				call addatohl 
07e0 10 e3				djnz .ff1 
07e2			 
07e2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07e4			.ff2:   	 
07e4			 
07e4 e5					push hl 
07e5 c5					push bc 
07e6 d5					push de 
07e7 cd 1b 03				call se_readbyte 
07ea 5f					ld e,a 
07eb 23					inc hl 
07ec cd 1b 03				call se_readbyte 
07ef 57					ld d, a 
07f0			 
07f0 e1					pop hl 
07f1 e5					push hl 
07f2 cd fc 0f				call cmp16 
07f5 28 2a				jr z, .fffound 
07f7			 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa					; is found? 
07fa					;cp e 
07fa					;ret z 
07fa			 
07fa 3e 40				ld a, STORE_BLOCK_PHY 
07fc cd de 0f				call addatohl 
07ff 10 e3				djnz .ff2 
0801			 
0801			 
0801					if DEBUG_FORTH_WORDS 
0801					DMARK "FN-" 
0801 f5				push af  
0802 3a 16 08			ld a, (.dmark)  
0805 32 a0 fd			ld (debug_mark),a  
0808 3a 17 08			ld a, (.dmark+1)  
080b 32 a1 fd			ld (debug_mark+1),a  
080e 3a 18 08			ld a, (.dmark+2)  
0811 32 a2 fd			ld (debug_mark+2),a  
0814 18 03			jr .pastdmark  
0816 ..			.dmark: db "FN-"  
0819 f1			.pastdmark: pop af  
081a			endm  
# End of macro DMARK
081a					;	push af 
081a					;	ld a, 'n' 
081a					;	ld (debug_mark),a 
081a					;	pop af 
081a						CALLMONITOR 
081a cd aa fd			call debug_vector  
081d				endm  
# End of macro CALLMONITOR
081d					endif 
081d				; no free marks! 
081d 21 00 00				ld hl, 0 
0820 c9				ret 
0821			.fffound: 
0821				 
0821			 
0821 d1					pop de 
0822 c1					pop bc 
0823 e1					pop hl 
0824					if DEBUG_FORTH_WORDS 
0824					DMARK "FNF" 
0824 f5				push af  
0825 3a 39 08			ld a, (.dmark)  
0828 32 a0 fd			ld (debug_mark),a  
082b 3a 3a 08			ld a, (.dmark+1)  
082e 32 a1 fd			ld (debug_mark+1),a  
0831 3a 3b 08			ld a, (.dmark+2)  
0834 32 a2 fd			ld (debug_mark+2),a  
0837 18 03			jr .pastdmark  
0839 ..			.dmark: db "FNF"  
083c f1			.pastdmark: pop af  
083d			endm  
# End of macro DMARK
083d					;	push af 
083d					;	ld a, 'n' 
083d					;	ld (debug_mark),a 
083d					;	pop af 
083d						CALLMONITOR 
083d cd aa fd			call debug_vector  
0840				endm  
# End of macro CALLMONITOR
0840					endif 
0840 c9				ret 
0841			 
0841			 
0841			 
0841			; Free Space 
0841			; ---------- 
0841			; 
0841			; With current bank 
0841			; 
0841			; Set block count to zero 
0841			; Starting with first logical block 
0841			;      Find free block  
0841			;      If block id given, increment block count 
0841			; 
0841			;  
0841			 
0841			 
0841			; hl contains count of free blocks 
0841			 
0841			storage_freeblocks: 
0841			 
0841				; now locate first 0 page to mark as a free block 
0841			 
0841 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0843 21 40 00			ld hl, STORE_BLOCK_PHY 
0846 11 00 00			ld de, 0 
0849			 
0849			.fb1:   	 
0849 e5					push hl 
084a c5					push bc 
084b d5					push de 
084c cd 1b 03				call se_readbyte 
084f d1					pop de 
0850 c1					pop bc 
0851 e1					pop hl 
0852			 
0852					; is free? 
0852 fe 00				cp 0 
0854 20 01				jr nz, .ff1cont 
0856 13					inc de 
0857			 
0857			.ff1cont: 
0857			 
0857			 
0857 3e 40				ld a, STORE_BLOCK_PHY 
0859 cd de 0f				call addatohl 
085c 10 eb				djnz .fb1 
085e			 
085e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0860			.fb2:   	 
0860 e5					push hl 
0861 c5					push bc 
0862 d5					push de 
0863 cd 1b 03				call se_readbyte 
0866 d1					pop de 
0867 c1					pop bc 
0868 e1					pop hl 
0869			 
0869					; is free? 
0869 fe 00				cp 0 
086b 20 01				jr nz, .ff2cont 
086d 13					inc de 
086e			 
086e			.ff2cont: 
086e			 
086e 3e 40				ld a, STORE_BLOCK_PHY 
0870 cd de 0f				call addatohl 
0873 10 eb				djnz .fb2 
0875			 
0875 eb				ex de, hl 
0876 c9				ret 
0877			 
0877			; Get File ID 
0877			; ----------- 
0877			; 
0877			; With current bank 
0877			;  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; For each logical block 
0877			;    Read block file id 
0877			;      If first block of file and dont have file id 
0877			;         if file get id and exit 
0877			 
0877			 
0877			 
0877			 
0877			; Create File 
0877			; ----------- 
0877			; 
0877			; With current bank  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; Increment file id number 
0877			; Save Config 
0877			; Find free block 
0877			; Set buffer with file name and file id 
0877			; Write buffer to free block  
0877			 
0877			 
0877			; hl point to file name 
0877			; hl returns file id 
0877			 
0877			; file format: 
0877			; byte 0 - file id 
0877			; byte 1 - extent number 
0877			; byte 2-> data 
0877			 
0877			; format for extent number 0: 
0877			; 
0877			; byte 0 - file id 
0877			; byte 1 - extent 0 
0877			; byte 2 - extent count 
0877			; byte 3 -> file name and meta data 
0877			 
0877			 
0877			storage_create: 
0877				if DEBUG_STORESE 
0877					DMARK "SCR" 
0877 f5				push af  
0878 3a 8c 08			ld a, (.dmark)  
087b 32 a0 fd			ld (debug_mark),a  
087e 3a 8d 08			ld a, (.dmark+1)  
0881 32 a1 fd			ld (debug_mark+1),a  
0884 3a 8e 08			ld a, (.dmark+2)  
0887 32 a2 fd			ld (debug_mark+2),a  
088a 18 03			jr .pastdmark  
088c ..			.dmark: db "SCR"  
088f f1			.pastdmark: pop af  
0890			endm  
# End of macro DMARK
0890					CALLMONITOR 
0890 cd aa fd			call debug_vector  
0893				endm  
# End of macro CALLMONITOR
0893				endif 
0893			 
0893 e5				push hl		; save file name pointer 
0894			 
0894 cd 25 05			call storage_get_block_0 
0897			 
0897 3a af f9			ld a,(store_page)	; get current file id 
089a 3c				inc a 
089b 32 af f9			ld (store_page),a 
089e				 
089e 32 a3 f9			ld (store_tmpid),a			; save id 
08a1			 
08a1 21 00 00			ld hl, 0 
08a4 11 af f9			ld de, store_page 
08a7				if DEBUG_STORESE 
08a7					DMARK "SCw" 
08a7 f5				push af  
08a8 3a bc 08			ld a, (.dmark)  
08ab 32 a0 fd			ld (debug_mark),a  
08ae 3a bd 08			ld a, (.dmark+1)  
08b1 32 a1 fd			ld (debug_mark+1),a  
08b4 3a be 08			ld a, (.dmark+2)  
08b7 32 a2 fd			ld (debug_mark+2),a  
08ba 18 03			jr .pastdmark  
08bc ..			.dmark: db "SCw"  
08bf f1			.pastdmark: pop af  
08c0			endm  
# End of macro DMARK
08c0					CALLMONITOR 
08c0 cd aa fd			call debug_vector  
08c3				endm  
# End of macro CALLMONITOR
08c3				endif 
08c3 cd d9 04			call storage_write_block	 ; save update 
08c6			 
08c6				if DEBUG_STORESE 
08c6 11 af f9				ld de, store_page 
08c9					DMARK "SCC" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 a0 fd			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 a1 fd			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 a2 fd			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCC"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd aa fd			call debug_vector  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5				;  
08e5				 
08e5 21 40 00			ld hl, STORE_BLOCK_PHY 
08e8 11 00 00			ld de, 0 
08eb cd a7 07			call storage_findnextid 
08ee			 
08ee 22 9a f9			ld (store_tmppageid), hl    ; save page to use  
08f1			 
08f1				; TODO detect 0 = no spare blocks 
08f1			 
08f1				; hl now contains the free page to use for the file header page 
08f1			 
08f1				if DEBUG_STORESE 
08f1				DMARK "SCF" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 a0 fd			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 a1 fd			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 a2 fd			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCF"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					CALLMONITOR 
090a cd aa fd			call debug_vector  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d			 
090d 22 9a f9			ld (store_tmppageid), hl 
0910				 
0910 3a a3 f9			ld a,(store_tmpid)    ; get file id 
0913			;	ld a, (store_filecache)			; save to cache 
0913			 
0913 32 af f9			ld (store_page),a    ; set page id 
0916 3e 00			ld a, 0			 ; extent 0 is file header 
0918 32 b0 f9			ld (store_page+1), a   ; set file extent 
091b			 
091b 32 b1 f9			ld (store_page+2), a   ; extent count for the file 
091e			 
091e			;	inc hl 		; init block 0 of file 
091e			;	inc hl   		; skip file and extent id 
091e			 ;       ld a, 0 
091e			;	ld (hl),a 
091e			;	ld a, (store_filecache+1)  	; save to cache 
091e			 
091e			;	inc hl    ; file name 
091e				 
091e				 
091e 11 b2 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0921				if DEBUG_STORESE 
0921					DMARK "SCc" 
0921 f5				push af  
0922 3a 36 09			ld a, (.dmark)  
0925 32 a0 fd			ld (debug_mark),a  
0928 3a 37 09			ld a, (.dmark+1)  
092b 32 a1 fd			ld (debug_mark+1),a  
092e 3a 38 09			ld a, (.dmark+2)  
0931 32 a2 fd			ld (debug_mark+2),a  
0934 18 03			jr .pastdmark  
0936 ..			.dmark: db "SCc"  
0939 f1			.pastdmark: pop af  
093a			endm  
# End of macro DMARK
093a					CALLMONITOR 
093a cd aa fd			call debug_vector  
093d				endm  
# End of macro CALLMONITOR
093d				endif 
093d e1				pop hl    ; get zero term string 
093e e5				push hl 
093f 3e 00			ld a, 0 
0941 cd 4f 13			call strlent 
0944 23				inc hl   ; cover zero term 
0945 06 00			ld b,0 
0947 4d				ld c,l 
0948 e1				pop hl 
0949				;ex de, hl 
0949				if DEBUG_STORESE 
0949					DMARK "SCa" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 a0 fd			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 a1 fd			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 a2 fd			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SCa"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					;push af 
0962					;ld a, 'a' 
0962					;ld (debug_mark),a 
0962					;pop af 
0962					CALLMONITOR 
0962 cd aa fd			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 ed b0			ldir    ; copy zero term string 
0967				if DEBUG_STORESE 
0967					DMARK "SCA" 
0967 f5				push af  
0968 3a 7c 09			ld a, (.dmark)  
096b 32 a0 fd			ld (debug_mark),a  
096e 3a 7d 09			ld a, (.dmark+1)  
0971 32 a1 fd			ld (debug_mark+1),a  
0974 3a 7e 09			ld a, (.dmark+2)  
0977 32 a2 fd			ld (debug_mark+2),a  
097a 18 03			jr .pastdmark  
097c ..			.dmark: db "SCA"  
097f f1			.pastdmark: pop af  
0980			endm  
# End of macro DMARK
0980					CALLMONITOR 
0980 cd aa fd			call debug_vector  
0983				endm  
# End of macro CALLMONITOR
0983				endif 
0983			 
0983				; write file header page 
0983			 
0983 2a 9a f9			ld hl,(store_tmppageid) 
0986 11 af f9			ld de, store_page 
0989				if DEBUG_STORESE 
0989					DMARK "SCb" 
0989 f5				push af  
098a 3a 9e 09			ld a, (.dmark)  
098d 32 a0 fd			ld (debug_mark),a  
0990 3a 9f 09			ld a, (.dmark+1)  
0993 32 a1 fd			ld (debug_mark+1),a  
0996 3a a0 09			ld a, (.dmark+2)  
0999 32 a2 fd			ld (debug_mark+2),a  
099c 18 03			jr .pastdmark  
099e ..			.dmark: db "SCb"  
09a1 f1			.pastdmark: pop af  
09a2			endm  
# End of macro DMARK
09a2					;push af 
09a2					;ld a, 'b' 
09a2					;ld (debug_mark),a 
09a2					;pop af 
09a2					CALLMONITOR 
09a2 cd aa fd			call debug_vector  
09a5				endm  
# End of macro CALLMONITOR
09a5				endif 
09a5 cd d9 04			call storage_write_block 
09a8			 
09a8 3a a3 f9			ld a, (store_tmpid) 
09ab 6f				ld l, a 
09ac 26 00			ld h,0 
09ae				if DEBUG_STORESE 
09ae					DMARK "SCz" 
09ae f5				push af  
09af 3a c3 09			ld a, (.dmark)  
09b2 32 a0 fd			ld (debug_mark),a  
09b5 3a c4 09			ld a, (.dmark+1)  
09b8 32 a1 fd			ld (debug_mark+1),a  
09bb 3a c5 09			ld a, (.dmark+2)  
09be 32 a2 fd			ld (debug_mark+2),a  
09c1 18 03			jr .pastdmark  
09c3 ..			.dmark: db "SCz"  
09c6 f1			.pastdmark: pop af  
09c7			endm  
# End of macro DMARK
09c7					CALLMONITOR 
09c7 cd aa fd			call debug_vector  
09ca				endm  
# End of macro CALLMONITOR
09ca				endif 
09ca c9				ret 
09cb				 
09cb			 
09cb			 
09cb			; 
09cb			; Read File 
09cb			; 
09cb			; h - file id to locate 
09cb			; l - extent to locate 
09cb			; de - pointer to string to read into 
09cb			; 
09cb			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09cb			 
09cb			.sr_fail: 
09cb d1				pop de 
09cc c9				ret 
09cd			 
09cd			storage_read: 
09cd			 
09cd			 
09cd d5				push de 
09ce			 
09ce			; TODO BUG the above push is it popped before the RET Z? 
09ce			 
09ce			; TODO how to handle multiple part blocks 
09ce			 
09ce				; locate file extent to read 
09ce			 
09ce 5c				ld e, h 
09cf 55				ld d, l 
09d0			 
09d0			.srext: 
09d0 22 ad f9			ld (store_readptr), hl     ; save the current extent to load 
09d3 ed 53 ab f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09d7			 
09d7 21 40 00			ld hl, STORE_BLOCK_PHY 
09da				if DEBUG_STORESE 
09da					DMARK "sre" 
09da f5				push af  
09db 3a ef 09			ld a, (.dmark)  
09de 32 a0 fd			ld (debug_mark),a  
09e1 3a f0 09			ld a, (.dmark+1)  
09e4 32 a1 fd			ld (debug_mark+1),a  
09e7 3a f1 09			ld a, (.dmark+2)  
09ea 32 a2 fd			ld (debug_mark+2),a  
09ed 18 03			jr .pastdmark  
09ef ..			.dmark: db "sre"  
09f2 f1			.pastdmark: pop af  
09f3			endm  
# End of macro DMARK
09f3					CALLMONITOR 
09f3 cd aa fd			call debug_vector  
09f6				endm  
# End of macro CALLMONITOR
09f6				endif 
09f6 cd a7 07			call storage_findnextid 
09f9			 
09f9				if DEBUG_STORESE 
09f9					DMARK "srf" 
09f9 f5				push af  
09fa 3a 0e 0a			ld a, (.dmark)  
09fd 32 a0 fd			ld (debug_mark),a  
0a00 3a 0f 0a			ld a, (.dmark+1)  
0a03 32 a1 fd			ld (debug_mark+1),a  
0a06 3a 10 0a			ld a, (.dmark+2)  
0a09 32 a2 fd			ld (debug_mark+2),a  
0a0c 18 03			jr .pastdmark  
0a0e ..			.dmark: db "srf"  
0a11 f1			.pastdmark: pop af  
0a12			endm  
# End of macro DMARK
0a12					CALLMONITOR 
0a12 cd aa fd			call debug_vector  
0a15				endm  
# End of macro CALLMONITOR
0a15				endif 
0a15 cd 07 10			call ishlzero 
0a18			;	ld a, l 
0a18			;	add h 
0a18			;	cp 0 
0a18 28 b1			jr z,.sr_fail			; block not found so EOF 
0a1a			 
0a1a				; save current address for use by higher level words etc 
0a1a			 
0a1a 22 a0 f9			ld (store_openaddr),hl 
0a1d			 
0a1d			 
0a1d				; hl contains page number to load 
0a1d d1				pop de   ; get storage 
0a1e ed 53 ab f9		ld (store_readbuf), de     ; current buffer to load in to 
0a22 d5				push de 
0a23				if DEBUG_STORESE 
0a23					DMARK "srg" 
0a23 f5				push af  
0a24 3a 38 0a			ld a, (.dmark)  
0a27 32 a0 fd			ld (debug_mark),a  
0a2a 3a 39 0a			ld a, (.dmark+1)  
0a2d 32 a1 fd			ld (debug_mark+1),a  
0a30 3a 3a 0a			ld a, (.dmark+2)  
0a33 32 a2 fd			ld (debug_mark+2),a  
0a36 18 03			jr .pastdmark  
0a38 ..			.dmark: db "srg"  
0a3b f1			.pastdmark: pop af  
0a3c			endm  
# End of macro DMARK
0a3c					CALLMONITOR 
0a3c cd aa fd			call debug_vector  
0a3f				endm  
# End of macro CALLMONITOR
0a3f				endif 
0a3f cd 74 04			call storage_read_block 
0a42			 
0a42				; if this a continuation read??? 
0a42			 
0a42 2a ab f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a45			 
0a45 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a47 cd de 0f			call addatohl 
0a4a 7e				ld a,(hl) 
0a4b fe 00			cp 0 
0a4d 28 02			jr z, .markiscont 
0a4f 3e ff			ld a, 255 
0a51			 
0a51			.markiscont: 
0a51 32 a2 f9			ld (store_readcont), a 
0a54			 
0a54				if DEBUG_STORESE 
0a54					DMARK "srC" 
0a54 f5				push af  
0a55 3a 69 0a			ld a, (.dmark)  
0a58 32 a0 fd			ld (debug_mark),a  
0a5b 3a 6a 0a			ld a, (.dmark+1)  
0a5e 32 a1 fd			ld (debug_mark+1),a  
0a61 3a 6b 0a			ld a, (.dmark+2)  
0a64 32 a2 fd			ld (debug_mark+2),a  
0a67 18 03			jr .pastdmark  
0a69 ..			.dmark: db "srC"  
0a6c f1			.pastdmark: pop af  
0a6d			endm  
# End of macro DMARK
0a6d					CALLMONITOR 
0a6d cd aa fd			call debug_vector  
0a70				endm  
# End of macro CALLMONITOR
0a70				endif 
0a70				; only short reads enabled 
0a70			 
0a70 3a aa f9			ld a, (store_longread) 
0a73 fe 00			cp 0 
0a75 ca 42 0b			jp z, .readdone 
0a78			 
0a78			; TODO if block has no zeros then need to read next block  
0a78			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a78			; check last byte of physical block. 
0a78			; if not zero then the next block needs to be loaded 
0a78			 
0a78			 
0a78 2a ab f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a7b			 
0a7b 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a7d cd de 0f			call addatohl 
0a80				;dec hl 
0a80 7e				ld a,(hl) 
0a81				if DEBUG_STORESE 
0a81					DMARK "sr?" 
0a81 f5				push af  
0a82 3a 96 0a			ld a, (.dmark)  
0a85 32 a0 fd			ld (debug_mark),a  
0a88 3a 97 0a			ld a, (.dmark+1)  
0a8b 32 a1 fd			ld (debug_mark+1),a  
0a8e 3a 98 0a			ld a, (.dmark+2)  
0a91 32 a2 fd			ld (debug_mark+2),a  
0a94 18 03			jr .pastdmark  
0a96 ..			.dmark: db "sr?"  
0a99 f1			.pastdmark: pop af  
0a9a			endm  
# End of macro DMARK
0a9a					CALLMONITOR 
0a9a cd aa fd			call debug_vector  
0a9d				endm  
# End of macro CALLMONITOR
0a9d				endif 
0a9d fe 00			cp 0 
0a9f ca 42 0b			jp z, .readdone 
0aa2			 
0aa2				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0aa2			 
0aa2 23				inc hl 
0aa3			 
0aa3 22 ab f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0aa6			 
0aa6 ed 5b ad f9		ld de, (store_readptr)     ; save the current extent to load 
0aaa			 
0aaa eb				ex de, hl 
0aab			 
0aab				; next ext 
0aab			 
0aab 23				inc hl 
0aac 22 ad f9			ld  (store_readptr), hl     ; save the current extent to load 
0aaf			 
0aaf				if DEBUG_STORESE 
0aaf					DMARK "sF2" 
0aaf f5				push af  
0ab0 3a c4 0a			ld a, (.dmark)  
0ab3 32 a0 fd			ld (debug_mark),a  
0ab6 3a c5 0a			ld a, (.dmark+1)  
0ab9 32 a1 fd			ld (debug_mark+1),a  
0abc 3a c6 0a			ld a, (.dmark+2)  
0abf 32 a2 fd			ld (debug_mark+2),a  
0ac2 18 03			jr .pastdmark  
0ac4 ..			.dmark: db "sF2"  
0ac7 f1			.pastdmark: pop af  
0ac8			endm  
# End of macro DMARK
0ac8					CALLMONITOR 
0ac8 cd aa fd			call debug_vector  
0acb				endm  
# End of macro CALLMONITOR
0acb				endif 
0acb			 
0acb				; get and load block 
0acb			 
0acb cd a7 07			call storage_findnextid 
0ace			 
0ace				if DEBUG_STORESE 
0ace					DMARK "sf2" 
0ace f5				push af  
0acf 3a e3 0a			ld a, (.dmark)  
0ad2 32 a0 fd			ld (debug_mark),a  
0ad5 3a e4 0a			ld a, (.dmark+1)  
0ad8 32 a1 fd			ld (debug_mark+1),a  
0adb 3a e5 0a			ld a, (.dmark+2)  
0ade 32 a2 fd			ld (debug_mark+2),a  
0ae1 18 03			jr .pastdmark  
0ae3 ..			.dmark: db "sf2"  
0ae6 f1			.pastdmark: pop af  
0ae7			endm  
# End of macro DMARK
0ae7					CALLMONITOR 
0ae7 cd aa fd			call debug_vector  
0aea				endm  
# End of macro CALLMONITOR
0aea				endif 
0aea cd 07 10			call ishlzero 
0aed			;	ld a, l 
0aed			;	add h 
0aed			;	cp 0 
0aed ca cb 09			jp z,.sr_fail			; block not found so EOF 
0af0				 
0af0				; save current address for use by higher level words etc 
0af0			 
0af0 22 a0 f9			ld (store_openaddr),hl 
0af3			 
0af3 cd 74 04			call storage_read_block 
0af6			 
0af6				; on a continuation block, we now have the file id and ext in the middle of the block 
0af6				; we need to pull everything back  
0af6			 
0af6 ed 5b ab f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0afa 2a ab f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0afd 23				inc hl 
0afe 23				inc hl     ; skip id and ext 
0aff 01 40 00			ld bc, STORE_BLOCK_PHY 
0b02				if DEBUG_STORESE 
0b02					DMARK "SR<" 
0b02 f5				push af  
0b03 3a 17 0b			ld a, (.dmark)  
0b06 32 a0 fd			ld (debug_mark),a  
0b09 3a 18 0b			ld a, (.dmark+1)  
0b0c 32 a1 fd			ld (debug_mark+1),a  
0b0f 3a 19 0b			ld a, (.dmark+2)  
0b12 32 a2 fd			ld (debug_mark+2),a  
0b15 18 03			jr .pastdmark  
0b17 ..			.dmark: db "SR<"  
0b1a f1			.pastdmark: pop af  
0b1b			endm  
# End of macro DMARK
0b1b					CALLMONITOR 
0b1b cd aa fd			call debug_vector  
0b1e				endm  
# End of macro CALLMONITOR
0b1e				endif 
0b1e ed b0			ldir     ; copy data 
0b20			 
0b20				; move the pointer back and pretend we have a full buffer for next recheck 
0b20			 
0b20 1b				dec de 
0b21 1b				dec de 
0b22			 
0b22			; TODO do pop below now short circuit loop????? 
0b22 c1				pop bc     ; get rid of spare de on stack 
0b23				if DEBUG_STORESE 
0b23					DMARK "SR>" 
0b23 f5				push af  
0b24 3a 38 0b			ld a, (.dmark)  
0b27 32 a0 fd			ld (debug_mark),a  
0b2a 3a 39 0b			ld a, (.dmark+1)  
0b2d 32 a1 fd			ld (debug_mark+1),a  
0b30 3a 3a 0b			ld a, (.dmark+2)  
0b33 32 a2 fd			ld (debug_mark+2),a  
0b36 18 03			jr .pastdmark  
0b38 ..			.dmark: db "SR>"  
0b3b f1			.pastdmark: pop af  
0b3c			endm  
# End of macro DMARK
0b3c					CALLMONITOR 
0b3c cd aa fd			call debug_vector  
0b3f				endm  
# End of macro CALLMONITOR
0b3f				endif 
0b3f c3 d0 09			jp .srext 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			.readdone:		 
0b42 e1				pop hl 		 ; return start of data to show as not EOF 
0b43 23				inc hl   ; past file id 
0b44 23				inc hl   ; past ext 
0b45				if DEBUG_STORESE 
0b45					DMARK "SRe" 
0b45 f5				push af  
0b46 3a 5a 0b			ld a, (.dmark)  
0b49 32 a0 fd			ld (debug_mark),a  
0b4c 3a 5b 0b			ld a, (.dmark+1)  
0b4f 32 a1 fd			ld (debug_mark+1),a  
0b52 3a 5c 0b			ld a, (.dmark+2)  
0b55 32 a2 fd			ld (debug_mark+2),a  
0b58 18 03			jr .pastdmark  
0b5a ..			.dmark: db "SRe"  
0b5d f1			.pastdmark: pop af  
0b5e			endm  
# End of macro DMARK
0b5e					CALLMONITOR 
0b5e cd aa fd			call debug_vector  
0b61				endm  
# End of macro CALLMONITOR
0b61				endif 
0b61 c9					ret 
0b62			 
0b62			 
0b62			 
0b62			; 
0b62			; Append File 
0b62			; 
0b62			; hl - file id to locate 
0b62			; de - pointer to (multi block) string to write 
0b62			 
0b62			.sa_notfound: 
0b62 d1				pop de 
0b63 c9				ret 
0b64			 
0b64			 
0b64			storage_append: 
0b64				; hl -  file id to append to 
0b64				; de - string to append 
0b64			 
0b64 d5				push de 
0b65				 
0b65				if DEBUG_STORESE 
0b65					DMARK "AP1" 
0b65 f5				push af  
0b66 3a 7a 0b			ld a, (.dmark)  
0b69 32 a0 fd			ld (debug_mark),a  
0b6c 3a 7b 0b			ld a, (.dmark+1)  
0b6f 32 a1 fd			ld (debug_mark+1),a  
0b72 3a 7c 0b			ld a, (.dmark+2)  
0b75 32 a2 fd			ld (debug_mark+2),a  
0b78 18 03			jr .pastdmark  
0b7a ..			.dmark: db "AP1"  
0b7d f1			.pastdmark: pop af  
0b7e			endm  
# End of macro DMARK
0b7e					CALLMONITOR 
0b7e cd aa fd			call debug_vector  
0b81				endm  
# End of macro CALLMONITOR
0b81				endif 
0b81			 
0b81 7d				ld a, l 
0b82 32 a3 f9			ld (store_tmpid), a 
0b85			 
0b85				; get file header  
0b85			 
0b85 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b87 3a a3 f9			ld a, (store_tmpid) 
0b8a 5f				ld e, a 
0b8b			 
0b8b 21 40 00				ld hl, STORE_BLOCK_PHY 
0b8e cd a7 07				call storage_findnextid 
0b91			 
0b91 cd 07 10			call ishlzero 
0b94 28 cc			jr z, .sa_notfound 
0b96			 
0b96 22 9a f9			ld (store_tmppageid), hl 
0b99			 
0b99				; TODO handle file id not found 
0b99			 
0b99				if DEBUG_STORESE 
0b99					DMARK "AP2" 
0b99 f5				push af  
0b9a 3a ae 0b			ld a, (.dmark)  
0b9d 32 a0 fd			ld (debug_mark),a  
0ba0 3a af 0b			ld a, (.dmark+1)  
0ba3 32 a1 fd			ld (debug_mark+1),a  
0ba6 3a b0 0b			ld a, (.dmark+2)  
0ba9 32 a2 fd			ld (debug_mark+2),a  
0bac 18 03			jr .pastdmark  
0bae ..			.dmark: db "AP2"  
0bb1 f1			.pastdmark: pop af  
0bb2			endm  
# End of macro DMARK
0bb2					CALLMONITOR 
0bb2 cd aa fd			call debug_vector  
0bb5				endm  
# End of macro CALLMONITOR
0bb5				endif 
0bb5			 
0bb5				; update file extent count 
0bb5			 
0bb5 11 af f9			ld de, store_page 
0bb8			 
0bb8 cd 74 04			call storage_read_block 
0bbb			 
0bbb				if DEBUG_STORESE 
0bbb					DMARK "AP3" 
0bbb f5				push af  
0bbc 3a d0 0b			ld a, (.dmark)  
0bbf 32 a0 fd			ld (debug_mark),a  
0bc2 3a d1 0b			ld a, (.dmark+1)  
0bc5 32 a1 fd			ld (debug_mark+1),a  
0bc8 3a d2 0b			ld a, (.dmark+2)  
0bcb 32 a2 fd			ld (debug_mark+2),a  
0bce 18 03			jr .pastdmark  
0bd0 ..			.dmark: db "AP3"  
0bd3 f1			.pastdmark: pop af  
0bd4			endm  
# End of macro DMARK
0bd4					CALLMONITOR 
0bd4 cd aa fd			call debug_vector  
0bd7				endm  
# End of macro CALLMONITOR
0bd7				endif 
0bd7			;	ld (store_tmppageid), hl 
0bd7			 
0bd7 3a b1 f9			ld a, (store_page+2) 
0bda 3c				inc a 
0bdb 32 b1 f9			ld (store_page+2), a 
0bde 32 a2 f9			ld (store_tmpext), a 
0be1				 
0be1				if DEBUG_STORESE 
0be1					DMARK "AP3" 
0be1 f5				push af  
0be2 3a f6 0b			ld a, (.dmark)  
0be5 32 a0 fd			ld (debug_mark),a  
0be8 3a f7 0b			ld a, (.dmark+1)  
0beb 32 a1 fd			ld (debug_mark+1),a  
0bee 3a f8 0b			ld a, (.dmark+2)  
0bf1 32 a2 fd			ld (debug_mark+2),a  
0bf4 18 03			jr .pastdmark  
0bf6 ..			.dmark: db "AP3"  
0bf9 f1			.pastdmark: pop af  
0bfa			endm  
# End of macro DMARK
0bfa					CALLMONITOR 
0bfa cd aa fd			call debug_vector  
0bfd				endm  
# End of macro CALLMONITOR
0bfd				endif 
0bfd 2a 9a f9			ld hl, (store_tmppageid) 
0c00 11 af f9			ld de, store_page 
0c03 cd d9 04			call storage_write_block 
0c06			 
0c06				; find free block 
0c06			 
0c06 11 00 00			ld de, 0			 ; file extent to locate 
0c09			 
0c09 21 40 00				ld hl, STORE_BLOCK_PHY 
0c0c cd a7 07				call storage_findnextid 
0c0f cd 07 10			call ishlzero 
0c12 ca 62 0b			jp z, .sa_notfound 
0c15			 
0c15					; TODO handle no space left 
0c15					 
0c15 22 9a f9				ld (store_tmppageid), hl 
0c18			 
0c18				if DEBUG_STORESE 
0c18					DMARK "AP4" 
0c18 f5				push af  
0c19 3a 2d 0c			ld a, (.dmark)  
0c1c 32 a0 fd			ld (debug_mark),a  
0c1f 3a 2e 0c			ld a, (.dmark+1)  
0c22 32 a1 fd			ld (debug_mark+1),a  
0c25 3a 2f 0c			ld a, (.dmark+2)  
0c28 32 a2 fd			ld (debug_mark+2),a  
0c2b 18 03			jr .pastdmark  
0c2d ..			.dmark: db "AP4"  
0c30 f1			.pastdmark: pop af  
0c31			endm  
# End of macro DMARK
0c31					CALLMONITOR 
0c31 cd aa fd			call debug_vector  
0c34				endm  
# End of macro CALLMONITOR
0c34				endif 
0c34					; init the buffer with zeros so we can id if the buffer is full or not 
0c34			 
0c34 e5					push hl 
0c35 c5					push bc 
0c36			 
0c36 21 af f9				ld hl, store_page 
0c39 06 40				ld b, STORE_BLOCK_PHY 
0c3b 3e 00				ld a, 0 
0c3d 77			.zeroblock:	ld (hl), a 
0c3e 23					inc hl 
0c3f 10 fc				djnz .zeroblock 
0c41			 
0c41 c1					pop bc 
0c42 e1					pop hl 
0c43			 
0c43					; construct block 
0c43			 
0c43 3a a3 f9				ld a, (store_tmpid) 
0c46 32 af f9				ld (store_page), a   ; file id 
0c49 3a a2 f9				ld a, (store_tmpext)   ; extent for this block 
0c4c 32 b0 f9				ld (store_page+1), a 
0c4f			 
0c4f e1					pop hl    ; get string to write 
0c50 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c52 11 b1 f9				ld de, store_page+2 
0c55			 
0c55				if DEBUG_STORESE 
0c55					DMARK "AP5" 
0c55 f5				push af  
0c56 3a 6a 0c			ld a, (.dmark)  
0c59 32 a0 fd			ld (debug_mark),a  
0c5c 3a 6b 0c			ld a, (.dmark+1)  
0c5f 32 a1 fd			ld (debug_mark+1),a  
0c62 3a 6c 0c			ld a, (.dmark+2)  
0c65 32 a2 fd			ld (debug_mark+2),a  
0c68 18 03			jr .pastdmark  
0c6a ..			.dmark: db "AP5"  
0c6d f1			.pastdmark: pop af  
0c6e			endm  
# End of macro DMARK
0c6e					CALLMONITOR 
0c6e cd aa fd			call debug_vector  
0c71				endm  
# End of macro CALLMONITOR
0c71				endif 
0c71			 
0c71			 
0c71			 
0c71					; fill buffer with data until end of string or full block 
0c71			 
0c71 7e			.appd:		ld a, (hl) 
0c72 12					ld (de), a 
0c73 fe 00				cp 0 
0c75 28 04				jr z, .appdone 
0c77 23					inc hl 
0c78 13					inc de 
0c79 10 f6				djnz .appd 
0c7b			 
0c7b e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c7c f5					push af   		; save last byte dumped 
0c7d			 
0c7d			 
0c7d 2a 9a f9			ld hl, (store_tmppageid) 
0c80 11 af f9			ld de, store_page 
0c83				if DEBUG_STORESE 
0c83					DMARK "AP6" 
0c83 f5				push af  
0c84 3a 98 0c			ld a, (.dmark)  
0c87 32 a0 fd			ld (debug_mark),a  
0c8a 3a 99 0c			ld a, (.dmark+1)  
0c8d 32 a1 fd			ld (debug_mark+1),a  
0c90 3a 9a 0c			ld a, (.dmark+2)  
0c93 32 a2 fd			ld (debug_mark+2),a  
0c96 18 03			jr .pastdmark  
0c98 ..			.dmark: db "AP6"  
0c9b f1			.pastdmark: pop af  
0c9c			endm  
# End of macro DMARK
0c9c					CALLMONITOR 
0c9c cd aa fd			call debug_vector  
0c9f				endm  
# End of macro CALLMONITOR
0c9f				endif 
0c9f cd d9 04				call storage_write_block 
0ca2			 
0ca2			 
0ca2				; was that a full block of data written? 
0ca2				; any more to write out? 
0ca2			 
0ca2				; if yes then set vars and jump to start of function again 
0ca2			 
0ca2 f1					pop af 
0ca3 d1					pop de 
0ca4			 
0ca4 fe 00				cp 0		 ; no, string was fully written 
0ca6 c8					ret z 
0ca7			 
0ca7					; setup vars for next cycle 
0ca7			 
0ca7 3a a3 f9				ld a, (store_tmpid) 
0caa 6f					ld l, a 
0cab 26 00				ld h, 0 
0cad			 
0cad c3 64 0b			 	jp storage_append	 ; yes, need to write out some more 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			if DEBUG_STORECF 
0cb0			storageput:	 
0cb0					ret 
0cb0			storageread: 
0cb0					ld hl, store_page 
0cb0					ld b, 200 
0cb0					ld a,0 
0cb0			.src:		ld (hl),a 
0cb0					inc hl 
0cb0					djnz .src 
0cb0					 
0cb0			 
0cb0					ld de, 0 
0cb0					ld bc, 1 
0cb0					ld hl, store_page 
0cb0					call cfRead 
0cb0			 
0cb0				call cfGetError 
0cb0				ld hl,scratch 
0cb0				call hexout 
0cb0				ld hl, scratch+2 
0cb0				ld a, 0 
0cb0				ld (hl),a 
0cb0				ld de, scratch 
0cb0				ld a,display_row_1 
0cb0				call str_at_display 
0cb0				call update_display 
0cb0			 
0cb0					ld hl, store_page 
0cb0					ld (os_cur_ptr),hl 
0cb0			 
0cb0					ret 
0cb0			endif 
0cb0			 
0cb0			 
0cb0			; Clear out the main buffer store (used to remove junk before writing a new block) 
0cb0			 
0cb0			storage_clear_page: 
0cb0 e5				push hl 
0cb1 d5				push de 
0cb2 c5				push bc 
0cb3 21 af f9			ld hl, store_page 
0cb6 3e 00			ld a, 0 
0cb8 77				ld (hl), a 
0cb9			 
0cb9 11 b0 f9			ld de, store_page+1 
0cbc 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cbf			 
0cbf ed b0			ldir 
0cc1				 
0cc1 c1				pop bc 
0cc2 d1				pop de 
0cc3 e1				pop hl 
0cc4 c9				ret 
0cc5			 
0cc5			; eof 
# End of file firmware_storage.asm
0cc5			  
0cc5			; support routines for above hardware abstraction layer  
0cc5			  
0cc5			include "firmware_general.asm"        ; general support functions  
0cc5			 
0cc5			; word look up 
0cc5			 
0cc5			; in 
0cc5			; a is the index 
0cc5			; hl is pointer start of array 
0cc5			; 
0cc5			; returns 
0cc5			; hl to the word 
0cc5			; 
0cc5			 
0cc5			table_lookup:  
0cc5 d5					push de 
0cc6 eb					ex de, hl 
0cc7			 
0cc7 6f					ld l, a 
0cc8 26 00				ld h, 0 
0cca 29					add hl, hl 
0ccb 19					add hl, de 
0ccc 7e					ld a, (hl) 
0ccd 23					inc hl 
0cce 66					ld h,(hl) 
0ccf 6f					ld l, a 
0cd0			 
0cd0 d1					pop de 
0cd1 c9					ret 
0cd2			 
0cd2			; Delay loops 
0cd2			 
0cd2			 
0cd2			 
0cd2			aDelayInMS: 
0cd2 c5				push bc 
0cd3 47				ld b,a 
0cd4			msdelay: 
0cd4 c5				push bc 
0cd5				 
0cd5			 
0cd5 01 41 00			ld bc,041h 
0cd8 cd f0 0c			call delayloop 
0cdb c1				pop bc 
0cdc 05				dec b 
0cdd 20 f5			jr nz,msdelay 
0cdf			 
0cdf			;if CPU_CLOCK_8MHZ 
0cdf			;msdelay8: 
0cdf			;	push bc 
0cdf			;	 
0cdf			; 
0cdf			;	ld bc,041h 
0cdf			;	call delayloop 
0cdf			;	pop bc 
0cdf			;	dec b 
0cdf			;	jr nz,msdelay8 
0cdf			;endif 
0cdf			 
0cdf			 
0cdf c1				pop bc 
0ce0 c9				ret 
0ce1			 
0ce1			 
0ce1			delay250ms: 
0ce1				;push de 
0ce1 01 00 40			ld bc, 04000h 
0ce4 c3 f0 0c			jp delayloop 
0ce7			delay500ms: 
0ce7				;push de 
0ce7 01 00 80			ld bc, 08000h 
0cea c3 f0 0c			jp delayloop 
0ced			delay1s: 
0ced				;push bc 
0ced			   ; Clobbers A, d and e 
0ced 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0cf0			delayloop: 
0cf0 c5			    push bc 
0cf1			 
0cf1			if BASE_CPM 
0cf1				ld bc, CPM_DELAY_TUNE 
0cf1			.cpmloop: 
0cf1				push bc 
0cf1			 
0cf1			endif 
0cf1			 
0cf1			 
0cf1			 
0cf1			delayloopi: 
0cf1			;	push bc 
0cf1			;.dl: 
0cf1 cb 47		    bit     0,a    	; 8 
0cf3 cb 47		    bit     0,a    	; 8 
0cf5 cb 47		    bit     0,a    	; 8 
0cf7 e6 ff		    and     255  	; 7 
0cf9 0b			    dec     bc      	; 6 
0cfa 79			    ld      a,c     	; 4 
0cfb b0			    or      b     	; 4 
0cfc c2 f1 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cff			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cff				;pop de 
0cff			;pop bc 
0cff			 
0cff			if BASE_CPM 
0cff				pop bc 
0cff				 
0cff			    dec     bc      	; 6 
0cff			    ld      a,c     	; 4 
0cff			    or      b     	; 4 
0cff			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cff				 
0cff			 
0cff			endif 
0cff			;if CPU_CLOCK_8MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff			 
0cff			;if CPU_CLOCK_10MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff c1			    pop bc 
0d00			 
0d00 c9				ret 
0d01			 
0d01			 
0d01			 
0d01			; eof 
# End of file firmware_general.asm
0d01			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0d01			; display routines that use the physical hardware abstraction layer 
0d01			 
0d01			 
0d01			; Display an activity indicator 
0d01			; Each call returns the new char pointed to in hl 
0d01			 
0d01			active: 
0d01 3a fb fa			ld a, (display_active) 
0d04 fe 06			cp 6 
0d06			 
0d06 20 02			jr nz, .sne 
0d08				; gone past the last one reset sequence 
0d08 3e ff			ld a, 255 
0d0a			 
0d0a			.sne:   
0d0a				; get the next char in seq 
0d0a 3c				inc a 
0d0b 32 fb fa			ld (display_active), a 
0d0e			 
0d0e				; look up the string in the table 
0d0e 21 25 0d			ld hl, actseq 
0d11 cb 27			sla a 
0d13 cd de 0f			call addatohl 
0d16 cd b9 23			call loadwordinhl 
0d19			 
0d19				; forth will write the to string when pushing so move from rom to ram 
0d19			 
0d19 11 fc fa			ld de, display_active+1 
0d1c 01 02 00			ld bc, 2 
0d1f ed b0			ldir 
0d21			 
0d21 21 fc fa			ld hl, display_active+1 
0d24 c9				ret 
0d25				 
0d25				 
0d25			 
0d25			 
0d25			;db "|/-\|-\" 
0d25			 
0d25			actseq: 
0d25			 
0d25 33 0d		dw spin0 
0d27 35 0d		dw spin1 
0d29 37 0d		dw spin2 
0d2b 39 0d		dw spin3 
0d2d 37 0d		dw spin2 
0d2f 35 0d		dw spin1 
0d31 33 0d		dw spin0 
0d33			 
0d33 .. 00		spin0: db " ", 0 
0d35 .. 00		spin1: db "-", 0 
0d37 .. 00		spin2: db "+", 0 
0d39 .. 00		spin3: db "#", 0 
0d3b			 
0d3b			 
0d3b			; information window 
0d3b			 
0d3b			; pass hl with 1st string to display 
0d3b			; pass de with 2nd string to display 
0d3b			 
0d3b			info_panel: 
0d3b e5				push hl 
0d3c			 
0d3c 2a 01 fb			ld hl, (display_fb_active) 
0d3f e5				push hl    ; future de destination 
0d40 21 e6 fc				ld hl, display_fb0 
0d43 22 01 fb				ld (display_fb_active), hl 
0d46			 
0d46			;	call clear_display 
0d46			 
0d46				if BASE_CPM 
0d46				ld a, '.' 
0d46				else 
0d46 3e a5			ld a, 165 
0d48				endif 
0d48 cd af 0d			call fill_display 
0d4b			 
0d4b			 
0d4b 3e 55			ld a, display_row_3 + 5 
0d4d cd bd 0d			call str_at_display 
0d50			 
0d50 e1				pop hl 
0d51 d1				pop de 
0d52			 
0d52 e5				push hl 
0d53			 
0d53			 
0d53 3e 2d			ld a, display_row_2 + 5 
0d55 cd bd 0d			call str_at_display 
0d58			 
0d58			 
0d58 cd cd 0d			call update_display 
0d5b cd be 1f			call next_page_prompt 
0d5e cd aa 0d			call clear_display 
0d61			 
0d61				 
0d61 21 45 fc				ld hl, display_fb1 
0d64 22 01 fb				ld (display_fb_active), hl 
0d67 cd cd 0d			call update_display 
0d6a			 
0d6a e1				pop hl 
0d6b			 
0d6b c9				ret 
0d6c			 
0d6c			 
0d6c			 
0d6c			 
0d6c			; TODO windowing? 
0d6c			 
0d6c			; TODO scroll line up 
0d6c			 
0d6c			scroll_up: 
0d6c			 
0d6c e5				push hl 
0d6d d5				push de 
0d6e c5				push bc 
0d6f			 
0d6f				; get frame buffer  
0d6f			 
0d6f 2a 01 fb			ld hl, (display_fb_active) 
0d72 e5				push hl    ; future de destination 
0d73			 
0d73 11 28 00			ld  de, display_cols 
0d76 19				add hl, de 
0d77			 
0d77 d1				pop de 
0d78			 
0d78				;ex de, hl 
0d78 01 9f 00			ld bc, display_fb_len -1  
0d7b			;if DEBUG_FORTH_WORDS 
0d7b			;	DMARK "SCL" 
0d7b			;	CALLMONITOR 
0d7b			;endif	 
0d7b ed b0			ldir 
0d7d			 
0d7d				; wipe bottom row 
0d7d			 
0d7d			 
0d7d 2a 01 fb			ld hl, (display_fb_active) 
0d80 11 a0 00			ld de, display_cols*display_rows 
0d83 19				add hl, de 
0d84 06 28			ld b, display_cols 
0d86 3e 20			ld a, ' ' 
0d88			.scwipe: 
0d88 77				ld (hl), a 
0d89 2b				dec hl 
0d8a 10 fc			djnz .scwipe 
0d8c			 
0d8c				;pop hl 
0d8c			 
0d8c c1				pop bc 
0d8d d1				pop de 
0d8e e1				pop hl 
0d8f			 
0d8f c9				ret 
0d90			 
0d90			 
0d90			;scroll_upo: 
0d90			;	ld de, display_row_1 
0d90			 ;	ld hl, display_row_2 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_2 
0d90			 ;	ld hl, display_row_3 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_3 
0d90			 ;	ld hl, display_row_4 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			 
0d90			; TODO clear row 4 
0d90			 
0d90			;	ret 
0d90			 
0d90				 
0d90			scroll_down: 
0d90			 
0d90 e5				push hl 
0d91 d5				push de 
0d92 c5				push bc 
0d93			 
0d93				; get frame buffer  
0d93			 
0d93 2a 01 fb			ld hl, (display_fb_active) 
0d96			 
0d96 11 9f 00			ld de, display_fb_len - 1 
0d99 19				add hl, de 
0d9a			 
0d9a e5			push hl    ; future de destination 
0d9b			 
0d9b 11 28 00			ld  de, display_cols 
0d9e ed 52			sbc hl, de 
0da0			 
0da0			 
0da0 d1				pop de 
0da1			 
0da1			;	ex de, hl 
0da1 01 9f 00			ld bc, display_fb_len -1  
0da4			 
0da4			 
0da4				 
0da4			 
0da4 ed b0			ldir 
0da6			 
0da6				; wipe bottom row 
0da6			 
0da6			 
0da6			;	ld hl, (display_fb_active) 
0da6			;;	ld de, display_cols*display_rows 
0da6			;;	add hl, de 
0da6			;	ld b, display_cols 
0da6			;	ld a, ' ' 
0da6			;.scwiped: 
0da6			;	ld (hl), a 
0da6			;	dec hl 
0da6			;	djnz .scwiped 
0da6			 
0da6				;pop hl 
0da6			 
0da6 c1				pop bc 
0da7 d1				pop de 
0da8 e1				pop hl 
0da9			 
0da9 c9				ret 
0daa			;scroll_down: 
0daa			;	ld de, display_row_4 
0daa			;	ld hl, display_row_3 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_3 
0daa			; 	ld hl, display_row_2 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_2 
0daa			;	ld hl, display_row_1 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;;; TODO clear row 1 
0daa			;	ret 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			; clear active frame buffer 
0daa			 
0daa			clear_display: 
0daa 3e 20			ld a, ' ' 
0dac c3 af 0d			jp fill_display 
0daf			 
0daf			; fill active frame buffer with a char in A 
0daf			 
0daf			fill_display: 
0daf 06 a0			ld b,display_fb_len 
0db1 2a 01 fb			ld hl, (display_fb_active) 
0db4 77			.fd1:	ld (hl),a 
0db5 23				inc hl 
0db6 10 fc			djnz .fd1 
0db8 23				inc hl 
0db9 3e 00			ld a,0 
0dbb 77				ld (hl),a 
0dbc			 
0dbc			 
0dbc c9				ret 
0dbd			; Write string (DE) at pos (A) to active frame buffer 
0dbd			 
0dbd 2a 01 fb		str_at_display:    ld hl,(display_fb_active) 
0dc0 06 00					ld b,0 
0dc2 4f					ld c,a 
0dc3 09					add hl,bc 
0dc4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0dc5 b7			            OR   A              ;Null terminator? 
0dc6 c8			            RET  Z              ;Yes, so finished 
0dc7 77					ld (hl),a 
0dc8 23				inc hl 
0dc9 13			            INC  DE             ;Point to next character 
0dca 18 f8		            JR   .sad1     ;Repeat 
0dcc c9					ret 
0dcd			 
0dcd			; using current frame buffer write to physical display 
0dcd			 
0dcd			update_display: 
0dcd e5				push hl 
0dce 2a 01 fb			ld hl, (display_fb_active) 
0dd1 cd 40 70			call write_display 
0dd4 e1				pop hl 
0dd5 c9				ret 
0dd6			 
0dd6			; TODO scrolling 
0dd6			 
0dd6			 
0dd6			; move cursor right one char 
0dd6			cursor_right: 
0dd6			 
0dd6				; TODO shift right 
0dd6				; TODO if beyond max col 
0dd6				; TODO       cursor_next_line 
0dd6			 
0dd6 c9				ret 
0dd7			 
0dd7			 
0dd7			cursor_next_line: 
0dd7				; TODO first char 
0dd7				; TODO line down 
0dd7				; TODO if past last row 
0dd7				; TODO    scroll up 
0dd7			 
0dd7 c9				ret 
0dd8			 
0dd8			cursor_left: 
0dd8				; TODO shift left 
0dd8				; TODO if beyond left  
0dd8				; TODO     cursor prev line 
0dd8				 
0dd8 c9				ret 
0dd9			 
0dd9			cursor_prev_line: 
0dd9				; TODO last char 
0dd9				; TODO line up 
0dd9				; TODO if past first row 
0dd9				; TODO   scroll down 
0dd9			 
0dd9 c9				ret 
0dda			 
0dda			 
0dda			cout: 
0dda				; A - char 
0dda c9				ret 
0ddb			 
0ddb			 
0ddb			; Display a menu and allow item selection (optional toggle items) 
0ddb			; 
0ddb			; format: 
0ddb			; hl pointer to word array with zero term for items 
0ddb			; e.g.    db item1 
0ddb			;         db .... 
0ddb			;         db 0 
0ddb			; 
0ddb			; a = starting menu item  
0ddb			; 
0ddb			; de = pointer item toggle array   (todo) 
0ddb			; 
0ddb			; returns item selected in a 1-... 
0ddb			; returns 0 if back button pressed 
0ddb			; 
0ddb			; NOTE: Uses system frame buffer to display 
0ddb			; 
0ddb			; LEFT, Q = go back 
0ddb			; RIGHT, SPACE, CR = select 
0ddb			; UP, A - Up 
0ddb			; DOWN, Z - Down 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			menu: 
0ddb			 
0ddb					; keep array pointer 
0ddb			 
0ddb 22 a8 f9				ld (store_tmp1), hl 
0dde 32 a6 f9				ld (store_tmp2), a 
0de1			 
0de1					; check for key bounce 
0de1			 
0de1			if BASE_KEV 
0de1			 
0de1 cd 8b 73		.mbounce:	call cin 
0de4 fe 00				cp 0 
0de6 20 f9				jr nz, .mbounce 
0de8			endif 
0de8					; for ease use ex 
0de8			 
0de8					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0de8 21 e6 fc				ld hl, display_fb0 
0deb 22 01 fb				ld (display_fb_active), hl 
0dee			 
0dee cd aa 0d		.mloop:		call clear_display 
0df1 cd cd 0d				call update_display 
0df4			 
0df4					; draw selection id '>' at 1 
0df4			 
0df4					; init start of list display 
0df4			 
0df4 3e 05				ld a, 5 
0df6 32 a4 f9				ld (store_tmp3), a   ; display row count 
0df9 3a a6 f9				ld a,( store_tmp2) 
0dfc 32 a7 f9				ld (store_tmp2+1), a   ; display item count 
0dff			 
0dff					 
0dff			.mitem:	 
0dff			 
0dff			 
0dff 3a a7 f9				ld a,(store_tmp2+1) 
0e02 6f					ld l, a 
0e03 26 00				ld h, 0 
0e05 29					add hl, hl 
0e06 ed 5b a8 f9			ld de, (store_tmp1) 
0e0a 19					add hl, de 
0e0b 7e					ld a, (hl) 
0e0c 23					inc hl 
0e0d 66					ld h,(hl) 
0e0e 6f					ld l, a 
0e0f			 
0e0f cd 07 10				call ishlzero 
0e12 28 1a				jr z, .mdone 
0e14			 
0e14 eb					ex de, hl 
0e15 3a a4 f9				ld a, (store_tmp3) 
0e18 cd bd 0d				call str_at_display 
0e1b					 
0e1b			 
0e1b					; next item 
0e1b 3a a7 f9				ld a, (store_tmp2+1) 
0e1e 3c					inc a 
0e1f 32 a7 f9				ld (store_tmp2+1), a   ; display item count 
0e22			 
0e22			 		; next row 
0e22			 
0e22 3a a4 f9				ld a, (store_tmp3) 
0e25 c6 28				add display_cols 
0e27 32 a4 f9				ld (store_tmp3), a 
0e2a			 
0e2a					; at end of screen? 
0e2a			 
0e2a fe 10				cp display_rows*4 
0e2c 20 d1				jr nz, .mitem 
0e2e			 
0e2e			 
0e2e			.mdone: 
0e2e cd 07 10				call ishlzero 
0e31 28 08				jr z, .nodn 
0e33			 
0e33 3e 78				ld a, display_row_4 
0e35 11 b4 0e				ld de, .mdown 
0e38 cd bd 0d				call str_at_display 
0e3b			 
0e3b					; draw options to fill the screens with active item on line 1 
0e3b					; if current option is 2 or more then display ^ in top 
0e3b			 
0e3b 3a a6 f9		.nodn:		ld a, (store_tmp2) 
0e3e fe 00				cp 0 
0e40 28 08				jr z, .noup 
0e42			 
0e42 3e 00				ld a, 0 
0e44 11 b2 0e				ld de, .mup 
0e47 cd bd 0d				call str_at_display 
0e4a			 
0e4a 3e 02		.noup:		ld a, 2 
0e4c 11 b0 0e				ld de, .msel 
0e4f cd bd 0d				call str_at_display 
0e52			 
0e52					; if current option + 1 is not null then display V in bottom 
0e52					; get key 
0e52 cd cd 0d				call update_display 
0e55			 
0e55			 
0e55					; handle key 
0e55			 
0e55 cd 7a 73				call cin_wait 
0e58			 
0e58 fe 05				cp KEY_UP 
0e5a 28 2b				jr z, .mgoup 
0e5c fe 61				cp 'a' 
0e5e 28 27				jr z, .mgoup 
0e60 fe 0a				cp KEY_DOWN 
0e62 28 32				jr z, .mgod 
0e64 fe 7a				cp 'z' 
0e66 28 2e				jr z, .mgod 
0e68 fe 20				cp ' ' 
0e6a 28 34				jr z, .goend 
0e6c fe 0c				cp KEY_RIGHT 
0e6e 28 30				jr z, .goend 
0e70 fe 0d				cp KEY_CR 
0e72 28 2c				jr z, .goend 
0e74 fe 71				cp 'q' 
0e76 28 0b				jr z, .goback 
0e78			 
0e78 fe 0b				cp KEY_LEFT 
0e7a 28 07				jr z, .goback 
0e7c fe 08				cp KEY_BS 
0e7e 28 03				jr z, .goback 
0e80 c3 ee 0d				jp .mloop 
0e83			 
0e83			.goback: 
0e83 3e 00			ld a, 0 
0e85 18 1d			jr .goend2 
0e87			 
0e87				; move up one 
0e87			.mgoup: 
0e87 3a a6 f9				ld a, (store_tmp2) 
0e8a fe 00				cp 0 
0e8c ca ee 0d				jp z, .mloop 
0e8f 3d					dec a 
0e90 32 a6 f9				ld (store_tmp2), a 
0e93 c3 ee 0d				jp .mloop 
0e96			 
0e96				; move down one 
0e96			.mgod: 
0e96 3a a6 f9				ld a, (store_tmp2) 
0e99 3c					inc a 
0e9a 32 a6 f9				ld (store_tmp2), a 
0e9d c3 ee 0d				jp .mloop 
0ea0			 
0ea0			 
0ea0			.goend: 
0ea0					; get selected item number 
0ea0			 
0ea0 3a a6 f9				ld a, (store_tmp2) 
0ea3 3c					inc a 
0ea4			 
0ea4			.goend2: 
0ea4 f5					push af 
0ea5			 
0ea5					; restore active fb 
0ea5					; TODO BUG assumes fb1 
0ea5			 
0ea5 21 45 fc				ld hl, display_fb1 
0ea8 22 01 fb				ld (display_fb_active), hl 
0eab			 
0eab					; restore main regs 
0eab			 
0eab			 
0eab cd cd 0d				call update_display 
0eae			 
0eae f1					pop af 
0eaf			 
0eaf c9				ret 
0eb0			 
0eb0 .. 00		.msel:   db ">",0 
0eb2 .. 00		.mup:   db "^",0 
0eb4 .. 00		.mdown:   db "v",0 
0eb6			 
0eb6			 
0eb6			; eof 
0eb6			 
# End of file firmware_display.asm
0eb6			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0eb6			; random number generators 
0eb6			 
0eb6			 
0eb6			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0eb6			 
0eb6			 
0eb6			;-----> Generate a random number 
0eb6			; output a=answer 0<=a<=255 
0eb6			; all registers are preserved except: af 
0eb6			random: 
0eb6 e5			        push    hl 
0eb7 d5			        push    de 
0eb8 2a e0 fa		        ld      hl,(randData) 
0ebb ed 5f		        ld      a,r 
0ebd 57			        ld      d,a 
0ebe 5e			        ld      e,(hl) 
0ebf 19			        add     hl,de 
0ec0 85			        add     a,l 
0ec1 ac			        xor     h 
0ec2 22 e0 fa		        ld      (randData),hl 
0ec5 d1			        pop     de 
0ec6 e1			        pop     hl 
0ec7 c9			        ret 
0ec8			 
0ec8			 
0ec8			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ec8			 
0ec8			 
0ec8			 
0ec8			;------LFSR------ 
0ec8			;James Montelongo 
0ec8			;optimized by Spencer Putt 
0ec8			;out: 
0ec8			; a = 8 bit random number 
0ec8			RandLFSR: 
0ec8 21 e6 fa		        ld hl,LFSRSeed+4 
0ecb 5e			        ld e,(hl) 
0ecc 23			        inc hl 
0ecd 56			        ld d,(hl) 
0ece 23			        inc hl 
0ecf 4e			        ld c,(hl) 
0ed0 23			        inc hl 
0ed1 7e			        ld a,(hl) 
0ed2 47			        ld b,a 
0ed3 cb 13		        rl e  
0ed5 cb 12			rl d 
0ed7 cb 11		        rl c  
0ed9 17				rla 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 cb 13		        rl e  
0ee3 cb 12			rl d 
0ee5 cb 11		        rl c  
0ee7 17				rla 
0ee8 67			        ld h,a 
0ee9 cb 13		        rl e  
0eeb cb 12			rl d 
0eed cb 11		        rl c  
0eef 17				rla 
0ef0 a8			        xor b 
0ef1 cb 13		        rl e  
0ef3 cb 12			rl d 
0ef5 ac			        xor h 
0ef6 a9			        xor c 
0ef7 aa			        xor d 
0ef8 21 e8 fa		        ld hl,LFSRSeed+6 
0efb 11 e9 fa		        ld de,LFSRSeed+7 
0efe 01 07 00		        ld bc,7 
0f01 ed b8		        lddr 
0f03 12			        ld (de),a 
0f04 c9			        ret 
0f05			 
0f05			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0f05			 
0f05			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0f05			 
0f05			 
0f05			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0f05			 
0f05			prng16: 
0f05			;Inputs: 
0f05			;   (seed1) contains a 16-bit seed value 
0f05			;   (seed2) contains a NON-ZERO 16-bit seed value 
0f05			;Outputs: 
0f05			;   HL is the result 
0f05			;   BC is the result of the LCG, so not that great of quality 
0f05			;   DE is preserved 
0f05			;Destroys: 
0f05			;   AF 
0f05			;cycle: 4,294,901,760 (almost 4.3 billion) 
0f05			;160cc 
0f05			;26 bytes 
0f05 2a da fa		    ld hl,(seed1) 
0f08 44			    ld b,h 
0f09 4d			    ld c,l 
0f0a 29			    add hl,hl 
0f0b 29			    add hl,hl 
0f0c 2c			    inc l 
0f0d 09			    add hl,bc 
0f0e 22 da fa		    ld (seed1),hl 
0f11 2a d8 fa		    ld hl,(seed2) 
0f14 29			    add hl,hl 
0f15 9f			    sbc a,a 
0f16 e6 2d		    and %00101101 
0f18 ad			    xor l 
0f19 6f			    ld l,a 
0f1a 22 d8 fa		    ld (seed2),hl 
0f1d 09			    add hl,bc 
0f1e c9			    ret 
0f1f			 
0f1f			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f1f			 
0f1f			rand32: 
0f1f			;Inputs: 
0f1f			;   (seed1_0) holds the lower 16 bits of the first seed 
0f1f			;   (seed1_1) holds the upper 16 bits of the first seed 
0f1f			;   (seed2_0) holds the lower 16 bits of the second seed 
0f1f			;   (seed2_1) holds the upper 16 bits of the second seed 
0f1f			;   **NOTE: seed2 must be non-zero 
0f1f			;Outputs: 
0f1f			;   HL is the result 
0f1f			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f1f			;Destroys: 
0f1f			;   AF 
0f1f			;Tested and passes all CAcert tests 
0f1f			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f1f			;it has a period of 18,446,744,069,414,584,320 
0f1f			;roughly 18.4 quintillion. 
0f1f			;LFSR taps: 0,2,6,7  = 11000101 
0f1f			;291cc 
0f1f			;seed1_0=$+1 
0f1f			;    ld hl,12345 
0f1f			;seed1_1=$+1 
0f1f			;    ld de,6789 
0f1f			;    ld b,h 
0f1f			;    ld c,l 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    inc l 
0f1f			;    add hl,bc 
0f1f			;    ld (seed1_0),hl 
0f1f			;    ld hl,(seed1_1) 
0f1f			;    adc hl,de 
0f1f			;    ld (seed1_1),hl 
0f1f			;    ex de,hl 
0f1f			;seed2_0=$+1 
0f1f			;    ld hl,9876 
0f1f			;seed2_1=$+1 
0f1f			;    ld bc,54321 
0f1f			;    add hl,hl \ rl c \ rl b 
0f1f			;    ld (seed2_1),bc 
0f1f			;    sbc a,a 
0f1f			;    and %11000101 
0f1f			;    xor l 
0f1f			;    ld l,a 
0f1f			;    ld (seed2_0),hl 
0f1f			;    ex de,hl 
0f1f			;    add hl,bc 
0f1f			;    ret 
0f1f			; 
0f1f			 
0f1f			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f1f			; 20 bytes, 86 cycles (excluding ret) 
0f1f			 
0f1f			; returns   hl = pseudorandom number 
0f1f			; corrupts   a 
0f1f			 
0f1f			; generates 16-bit pseudorandom numbers with a period of 65535 
0f1f			; using the xorshift method: 
0f1f			 
0f1f			; hl ^= hl << 7 
0f1f			; hl ^= hl >> 9 
0f1f			; hl ^= hl << 8 
0f1f			 
0f1f			; some alternative shift triplets which also perform well are: 
0f1f			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f1f			 
0f1f			;  org 32768 
0f1f			 
0f1f			xrnd: 
0f1f 2a de fa		  ld hl,(xrandc)       ; seed must not be 0 
0f22 3e 00		  ld a,0 
0f24 bd			  cp l 
0f25 20 02		  jr nz, .xrnd1 
0f27 2e 01		  ld l, 1 
0f29			.xrnd1: 
0f29			 
0f29 7c			  ld a,h 
0f2a 1f			  rra 
0f2b 7d			  ld a,l 
0f2c 1f			  rra 
0f2d ac			  xor h 
0f2e 67			  ld h,a 
0f2f 7d			  ld a,l 
0f30 1f			  rra 
0f31 7c			  ld a,h 
0f32 1f			  rra 
0f33 ad			  xor l 
0f34 6f			  ld l,a 
0f35 ac			  xor h 
0f36 67			  ld h,a 
0f37			 
0f37 22 de fa		  ld (xrandc),hl 
0f3a			 
0f3a c9			  ret 
0f3b			;  
0f3b			 
0f3b			 
0f3b			;;;; int maths 
0f3b			 
0f3b			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f3b			; Divide 16-bit values (with 16-bit result) 
0f3b			; In: Divide BC by divider DE 
0f3b			; Out: BC = result, HL = rest 
0f3b			; 
0f3b			Div16: 
0f3b 21 00 00		    ld hl,0 
0f3e 78			    ld a,b 
0f3f 06 08		    ld b,8 
0f41			Div16_Loop1: 
0f41 17			    rla 
0f42 ed 6a		    adc hl,hl 
0f44 ed 52		    sbc hl,de 
0f46 30 01		    jr nc,Div16_NoAdd1 
0f48 19			    add hl,de 
0f49			Div16_NoAdd1: 
0f49 10 f6		    djnz Div16_Loop1 
0f4b 17			    rla 
0f4c 2f			    cpl 
0f4d 47			    ld b,a 
0f4e 79			    ld a,c 
0f4f 48			    ld c,b 
0f50 06 08		    ld b,8 
0f52			Div16_Loop2: 
0f52 17			    rla 
0f53 ed 6a		    adc hl,hl 
0f55 ed 52		    sbc hl,de 
0f57 30 01		    jr nc,Div16_NoAdd2 
0f59 19			    add hl,de 
0f5a			Div16_NoAdd2: 
0f5a 10 f6		    djnz Div16_Loop2 
0f5c 17			    rla 
0f5d 2f			    cpl 
0f5e 41			    ld b,c 
0f5f 4f			    ld c,a 
0f60 c9			ret 
0f61			 
0f61			 
0f61			;http://z80-heaven.wikidot.com/math 
0f61			; 
0f61			;Inputs: 
0f61			;     DE and A are factors 
0f61			;Outputs: 
0f61			;     A is not changed 
0f61			;     B is 0 
0f61			;     C is not changed 
0f61			;     DE is not changed 
0f61			;     HL is the product 
0f61			;Time: 
0f61			;     342+6x 
0f61			; 
0f61			Mult16: 
0f61			 
0f61 06 08		     ld b,8          ;7           7 
0f63 21 00 00		     ld hl,0         ;10         10 
0f66 29			       add hl,hl     ;11*8       88 
0f67 07			       rlca          ;4*8        32 
0f68 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f6a 19			         add hl,de   ;--         -- 
0f6b 10 f9		       djnz $-5      ;13*7+8     99 
0f6d c9			ret 
0f6e			 
0f6e			; 
0f6e			; Square root of 16-bit value 
0f6e			; In:  HL = value 
0f6e			; Out:  D = result (rounded down) 
0f6e			; 
0f6e			;Sqr16: 
0f6e			;    ld de,#0040 
0f6e			;    ld a,l 
0f6e			;    ld l,h 
0f6e			;    ld h,d 
0f6e			;    or a 
0f6e			;    ld b,8 
0f6e			;Sqr16_Loop: 
0f6e			;    sbc hl,de 
0f6e			;    jr nc,Sqr16_Skip 
0f6e			;    add hl,de 
0f6e			;Sqr16_Skip: 
0f6e			;    ccf 
0f6e			;    rl d 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    djnz Sqr16_Loop 
0f6e			;    ret 
0f6e			; 
0f6e			; 
0f6e			; Divide 8-bit values 
0f6e			; In: Divide E by divider C 
0f6e			; Out: A = result, B = rest 
0f6e			; 
0f6e			Div8: 
0f6e af			    xor a 
0f6f 06 08		    ld b,8 
0f71			Div8_Loop: 
0f71 cb 13		    rl e 
0f73 17			    rla 
0f74 91			    sub c 
0f75 30 01		    jr nc,Div8_NoAdd 
0f77 81			    add a,c 
0f78			Div8_NoAdd: 
0f78 10 f7		    djnz Div8_Loop 
0f7a 47			    ld b,a 
0f7b 7b			    ld a,e 
0f7c 17			    rla 
0f7d 2f			    cpl 
0f7e c9			    ret 
0f7f			 
0f7f			; 
0f7f			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f7f			; In: Multiply A with DE 
0f7f			; Out: HL = result 
0f7f			; 
0f7f			Mult12U: 
0f7f 2e 00		    ld l,0 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd0 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd0: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd1 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd1: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd2 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd2: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd3 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd3: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 30 01		    jr nc,Mult12U_NoAdd4 
0f98 19			    add hl,de 
0f99			Mult12U_NoAdd4: 
0f99 29			    add hl,hl 
0f9a 87			    add a,a 
0f9b 30 01		    jr nc,Mult12U_NoAdd5 
0f9d 19			    add hl,de 
0f9e			Mult12U_NoAdd5: 
0f9e 29			    add hl,hl 
0f9f 87			    add a,a 
0fa0 30 01		    jr nc,Mult12U_NoAdd6 
0fa2 19			    add hl,de 
0fa3			Mult12U_NoAdd6: 
0fa3 29			    add hl,hl 
0fa4 87			    add a,a 
0fa5 d0			    ret nc 
0fa6 19			    add hl,de 
0fa7 c9			    ret 
0fa8			 
0fa8			; 
0fa8			; Multiply 8-bit value with a 16-bit value (right rotating) 
0fa8			; In: Multiply A with DE 
0fa8			;      Put lowest value in A for most efficient calculation 
0fa8			; Out: HL = result 
0fa8			; 
0fa8			Mult12R: 
0fa8 21 00 00		    ld hl,0 
0fab			Mult12R_Loop: 
0fab cb 3f		    srl a 
0fad 30 01		    jr nc,Mult12R_NoAdd 
0faf 19			    add hl,de 
0fb0			Mult12R_NoAdd: 
0fb0 cb 23		    sla e 
0fb2 cb 12		    rl d 
0fb4 b7			    or a 
0fb5 c2 ab 0f		    jp nz,Mult12R_Loop 
0fb8 c9			    ret 
0fb9			 
0fb9			; 
0fb9			; Multiply 16-bit values (with 32-bit result) 
0fb9			; In: Multiply BC with DE 
0fb9			; Out: BCHL = result 
0fb9			; 
0fb9			Mult32: 
0fb9 79			    ld a,c 
0fba 48			    ld c,b 
0fbb 21 00 00		    ld hl,0 
0fbe 06 10		    ld b,16 
0fc0			Mult32_Loop: 
0fc0 29			    add hl,hl 
0fc1 17			    rla 
0fc2 cb 11		    rl c 
0fc4 30 07		    jr nc,Mult32_NoAdd 
0fc6 19			    add hl,de 
0fc7 ce 00		    adc a,0 
0fc9 d2 cd 0f		    jp nc,Mult32_NoAdd 
0fcc 0c			    inc c 
0fcd			Mult32_NoAdd: 
0fcd 10 f1		    djnz Mult32_Loop 
0fcf 41			    ld b,c 
0fd0 4f			    ld c,a 
0fd1 c9			    ret 
0fd2			 
0fd2			 
0fd2			 
0fd2			; 
0fd2			; Multiply 8-bit values 
0fd2			; In:  Multiply H with E 
0fd2			; Out: HL = result 
0fd2			; 
0fd2			Mult8: 
0fd2 16 00		    ld d,0 
0fd4 6a			    ld l,d 
0fd5 06 08		    ld b,8 
0fd7			Mult8_Loop: 
0fd7 29			    add hl,hl 
0fd8 30 01		    jr nc,Mult8_NoAdd 
0fda 19			    add hl,de 
0fdb			Mult8_NoAdd: 
0fdb 10 fa		    djnz Mult8_Loop 
0fdd c9			    ret 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			;;http://z80-heaven.wikidot.com/math 
0fde			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fde			; 
0fde			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fde			;     ld a,16        ;7 
0fde			;     ld hl,0        ;10 
0fde			;     jp $+5         ;10 
0fde			;.DivLoop: 
0fde			;       add hl,bc    ;-- 
0fde			;       dec a        ;64 
0fde			;       jr z,.DivLoopEnd        ;86 
0fde			; 
0fde			;       sla e        ;128 
0fde			;       rl d         ;128 
0fde			;       adc hl,hl    ;240 
0fde			;       sbc hl,bc    ;240 
0fde			;       jr nc,.DivLoop ;23|21 
0fde			;       inc e        ;-- 
0fde			;       jp .DivLoop+1 
0fde			; 
0fde			;.DivLoopEnd: 
0fde			 
0fde			;HL_Div_C: 
0fde			;Inputs: 
0fde			;     HL is the numerator 
0fde			;     C is the denominator 
0fde			;Outputs: 
0fde			;     A is the remainder 
0fde			;     B is 0 
0fde			;     C is not changed 
0fde			;     DE is not changed 
0fde			;     HL is the quotient 
0fde			; 
0fde			;       ld b,16 
0fde			;       xor a 
0fde			;         add hl,hl 
0fde			;         rla 
0fde			;         cp c 
0fde			;         jr c,$+4 
0fde			;           inc l 
0fde			;           sub c 
0fde			;         djnz $-7 
0fde			 
0fde			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fde			 
0fde			addatohl: 
0fde 85			    add   a, l    ; A = A+L 
0fdf 6f			    ld    l, a    ; L = A+L 
0fe0 8c			    adc   a, h    ; A = A+L+H+carry 
0fe1 95			    sub   l       ; A = H+carry 
0fe2 67			    ld    h, a    ; H = H+carry 
0fe3 c9			ret 
0fe4			 
0fe4			addatode: 
0fe4 83			    add   a, e    ; A = A+L 
0fe5 5f			    ld    e, a    ; L = A+L 
0fe6 8a			    adc   a, d    ; A = A+L+H+carry 
0fe7 93			    sub   e       ; A = H+carry 
0fe8 57			    ld    d, a    ; H = H+carry 
0fe9 c9			ret 
0fea			 
0fea			 
0fea			addatobc: 
0fea 81			    add   a, c    ; A = A+L 
0feb 4f			    ld    c, a    ; L = A+L 
0fec 88			    adc   a, b    ; A = A+L+H+carry 
0fed 91			    sub   c       ; A = H+carry 
0fee 47			    ld    b, a    ; H = H+carry 
0fef c9			ret 
0ff0			 
0ff0			subafromhl: 
0ff0			   ; If A=0 do nothing 
0ff0			    ; Otherwise flip A's sign. Since 
0ff0			    ; the upper byte becomes -1, also 
0ff0			    ; substract 1 from H. 
0ff0 ed 44		    neg 
0ff2 ca fb 0f		    jp    z, Skip 
0ff5 25			    dec   h 
0ff6			     
0ff6			    ; Now add the low byte as usual 
0ff6			    ; Two's complement takes care of 
0ff6			    ; ensuring the result is correct 
0ff6 85			    add   a, l 
0ff7 6f			    ld    l, a 
0ff8 8c			    adc   a, h 
0ff9 95			    sub   l 
0ffa 67			    ld    h, a 
0ffb			Skip: 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			; compare hl and de 
0ffc			; returns:  
0ffc			; if hl = de, z=1, s=0, c0=0 
0ffc			; if hl > de, z=0, s=0, c=0 
0ffc			; if hl < de, z=0, s=1, c=1 
0ffc			cmp16:	 
0ffc b7				or a 
0ffd ed 52			sbc hl,de 
0fff e0				ret po 
1000 7c				ld a,h 
1001 1f				rra 
1002 ee 40			xor 01000000B 
1004 37				scf 
1005 8f				adc a,a 
1006 c9				ret 
1007			 
1007			 
1007			; test if hl contains zero   - A is destroyed 
1007			 
1007			ishlzero:    
1007 b7				or a     ; reset flags 
1008 7c				ld a, h 
1009 b5				or l        	 
100a			 
100a c9				ret 
100b			 
100b			 
100b			 
100b			 
100b			if FORTH_ENABLE_FLOATMATH 
100b			;include "float/bbcmath.z80" 
100b			include "float/lpfpcalc.asm" 
100b			endif 
100b			 
100b			 
100b			; eof 
100b			 
# End of file firmware_maths.asm
100b			include "firmware_strings.asm"   ; string handling  
100b			 
100b			 
100b			; TODO string len 
100b			; input text string, end on cr with zero term 
100b			; a offset into frame buffer to start prompt 
100b			; d is max length 
100b			; e is display size TODO 
100b			; c is current cursor position 
100b			; hl is ptr to where string will be stored and edited directly 
100b			 
100b			 
100b			; TODO check limit of buffer for new inserts 
100b			; TODO check insert does not push beyond buffer 
100b			; TODO scroll in a limited display area 
100b			; TODO scroll whole screen on page wrap 
100b			 
100b			 
100b			; TODO use LCD cursor? 
100b			 
100b			EDIT_V1: equ 0 
100b			EDIT_V2: equ 1 
100b			 
100b			 
100b			 
100b			if EDIT_V2 
100b			input_str: 
100b			 
100b 32 99 fd			    	ld (input_at_pos),a      ; save display position to start 
100e			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
100e 22 9c fd				ld (input_start), hl     ; save ptr to buffer 
1011			;		ld a, c 
1011			;		call addatohl 
1011			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
1011 7a					ld a,d 
1012 32 9b fd			        ld (input_size), a       ; save length of input area 
1015 79					ld a, c 
1016 32 8a fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
1019 7b					ld a,e 
101a 32 9a fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
101d			 
101d			 
101d					; add a trailing space to make screen refresh nicer 
101d			 
101d					;ld hl, (input_start) 
101d					;push hl 
101d					;ld a, 0 
101d					;call strlent 
101d					;ld a, l 
101d					;pop hl 
101d					;call addatohl 
101d					;dec hl 
101d					;ld a, ' ' 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld a, 0 
101d					;ld (hl), a 
101d			 
101d			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
101d					; init cursor shape if not set by the cin routines 
101d 21 f6 fa				ld hl, cursor_shape 
1020			if BASE_KEV 
1020 3e ff				ld a, 255 
1022			else 
1022					ld a, '#' 
1022			endif 
1022 77					ld (hl), a 
1023 23					inc hl 
1024 3e 00				ld a, 0 
1026 77					ld (hl), a 
1027			 
1027 3e 09				ld a, CUR_BLINK_RATE 
1029 32 95 fd				ld (input_cur_flash), a 
102c 3e 01				ld a, 1 
102e 32 94 fd				ld (input_cur_onoff),a 
1031			.inmain:	 
1031			 
1031 cd 59 11				call input_disp_ref 
1034			 
1034					; save current length of string 
1034			 
1034 2a 9c fd				ld hl, (input_start) 
1037 3e 00				ld a, 0 
1039 cd 4f 13				call strlent 
103c 7d					ld a,l 
103d 32 8f fd				ld (input_len), a 
1040			 
1040					;call input_disp_oncur 
1040			 
1040					; display current state of input buffer 
1040			 
1040					; clean any backspace chars 
1040			 
1040 3e 20				ld a, " " 
1042 32 f6 f0				ld (scratch),a 
1045 3e 00				ld a, 0 
1047 32 f7 f0				ld (scratch+1),a 
104a 3a 99 fd				ld a,(input_at_pos) 
104d 85					add l 
104e 11 f6 f0				ld de, scratch 
1051 cd bd 0d				call str_at_display 
1054			 
1054					; pause 1ms 
1054			 
1054 3e 01				ld a, 1 
1056 cd d2 0c				call aDelayInMS 
1059			 
1059			; display cursor if visible on this cycle 
1059			 
1059					; dec flash counter 
1059 3a 95 fd				ld a, (input_cur_flash) 
105c 3d					dec a 
105d 32 95 fd				ld (input_cur_flash), a 
1060 fe 00				cp 0 
1062 20 0d				jr nz, .inochgstate 
1064			 
1064			 
1064					; reset on change of state 
1064 3e 09				ld a, CUR_BLINK_RATE 
1066 32 95 fd				ld (input_cur_flash), a 
1069			 
1069					; change state 
1069 3a 94 fd				ld a,(input_cur_onoff) 
106c ed 44				neg 
106e 32 94 fd				ld (input_cur_onoff),a 
1071			 
1071			 
1071			 
1071			 
1071					; TODO is cursor visible? 
1071					; TODO if so then over write the char at curspos pos with the cursor shape 
1071			 
1071								 
1071			 
1071			.inochgstate: 
1071 3a 94 fd				ld a,(input_cur_onoff) 
1074 fe ff				cp 255 
1076 28 0e				jr z, .skipcursor 
1078 3a 99 fd				ld a, (input_at_pos) 
107b 47					ld b, a 
107c 3a 8a fd				ld a, (input_cursor) 
107f 80					add b 
1080 11 f6 fa				ld de, cursor_shape 
1083					 
1083 cd bd 0d				call str_at_display 
1086			 
1086			.skipcursor: 
1086				if DEBUG_INPUTV2 
1086			 
1086					ld a,(input_at_pos) 
1086					ld hl, LFSRSeed 
1086					call hexout 
1086					ld a, (input_cursor) 
1086					ld hl, LFSRSeed+2 
1086					call hexout 
1086					ld a,(input_size) 
1086					ld hl, LFSRSeed+4 
1086					call hexout 
1086			 
1086					ld a,(input_cur_onoff) 
1086					ld hl, LFSRSeed+6 
1086					call hexout 
1086			 
1086					ld a,(input_cur_flash) 
1086					ld hl, LFSRSeed+8 
1086					call hexout 
1086			 
1086					ld a,(input_len) 
1086					ld hl, LFSRSeed+10 
1086					call hexout 
1086					ld hl, LFSRSeed+12 
1086					ld a, 0 
1086					ld (hl),a 
1086					ld a, display_row_4 
1086					ld de, LFSRSeed 
1086					call str_at_display 
1086				endif 
1086 cd cd 0d				call update_display 
1089			 
1089					; TODO keyboard processing 
1089			 
1089			if BASE_CPM 
1089					call cin_wait 
1089			else 
1089 cd 8b 73				call cin    ; _wait 
108c			endif 
108c fe 00				cp 0 
108e ca 31 10				jp z, .inmain 
1091			 
1091 fe 0b				cp KEY_LEFT    ; cursor left 
1093 ca 4b 11				jp z, input_left 
1096				 
1096 fe 0c				cp KEY_RIGHT      ; cursor right 
1098 ca 52 11				jp z, input_right 
109b			 
109b fe 0d				cp KEY_CR 
109d c8					ret z 
109e			 
109e fe 08				cp KEY_BS 
10a0 ca c0 11				jp z, input_delchar 
10a3			 
10a3 fe 06				cp KEY_NEXTWORD 
10a5 ca cc 10				jp z, input_nxtword 
10a8			 
10a8 fe 07				cp KEY_PREVWORD 
10aa ca f3 10				jp z, input_prvword 
10ad			 
10ad fe 0e				cp KEY_HOME    ; jump to start of line 
10af 20 08				jr nz, .ikh 
10b1 3e 00				ld a, 0 
10b3 32 8a fd				ld (input_cursor), a 
10b6 ca 31 10				jp z, .inmain 
10b9			.ikh: 
10b9			 
10b9 fe 0f				cp KEY_END     ; jump to end of line 
10bb 20 09				jr nz, .ike 
10bd 3a 8f fd				ld a, (input_len) 
10c0 32 8a fd				ld (input_cursor),a 
10c3 ca 31 10				jp z, .inmain 
10c6			.ike: 
10c6 fe 05			        cp KEY_UP      ; recall last command 
10c8 c8					ret z 
10c9			;jr nz, .irec 
10c9			; TODO next word 
10c9			; TODO prev word 
10c9			;  
10c9			; 
10c9			;	ld hl, scratch 
10c9			;	ld de, os_last_cmd 
10c9			;	call strcpy 
10c9			;		jp  .inmain 
10c9			.irec: 
10c9			;		jr .instr1 
10c9			 
10c9			 
10c9			 
10c9					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
10c9			 
10c9			; TODO return if any special keys are given 
10c9			;		ld l, a 
10c9			;		ld a, 28 ; KEY_F12   ; 27 
10c9			;		sub l 
10c9			;		ret m 
10c9			;		ld a, l 
10c9					; if no special key then insert as a char 
10c9			 
10c9 c3 92 11				jp input_inschr 
10cc			 
10cc				 
10cc			input_nxtword: 
10cc				; jump to start next word after the cursor 
10cc			 
10cc			.insknwn:	 
10cc cd 88 11				call input_curptr	 
10cf 7e					ld a,(hl)	 
10d0 fe 00				cp 0 
10d2 ca 31 10				jp z, .inmain    ; end of string 
10d5			 
10d5			; if we are on a word, then move off of it 
10d5			 
10d5 fe 20				cp ' ' 
10d7 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10d9 21 8a fd				ld hl, input_cursor 
10dc 34					inc (hl) 
10dd 18 ed				jr .insknwn 
10df			 
10df			.inspace: 
10df			 
10df cd 88 11				call input_curptr	 
10e2 7e					ld a,(hl)	 
10e3 fe 00				cp 0 
10e5 ca 31 10				jp z, .inmain    ; end of string 
10e8			 
10e8			; if we are on a word, then move off of it 
10e8			 
10e8 fe 20				cp ' ' 
10ea c2 31 10				jp nz, .inmain     ; we are on non space so at next word 
10ed 21 8a fd				ld hl, input_cursor 
10f0 34					inc (hl) 
10f1 18 ec				jr .inspace 
10f3			 
10f3			 
10f3			 
10f3			 
10f3			input_prvword: 
10f3				; jump to the start of previous word before the cursor 
10f3			 
10f3			; where are we to start with currently? 
10f3			 
10f3 cd 88 11				call input_curptr	 
10f6 7e					ld a, (hl) 
10f7 fe 20				cp ' ' 
10f9 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10fb			 
10fb			 
10fb			 
10fb			.inskpwn:	 
10fb 3a 8a fd				ld a,(input_cursor) 
10fe fe 00				cp 0 
1100 ca 31 10				jp z, .inmain    ; start of string 
1103			 
1103			;if we are on a word, then move off of it 
1103			 
1103 cd 88 11				call input_curptr	 
1106 7e					ld a, (hl) 
1107 fe 20				cp ' ' 
1109 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
110b					;jp z, .inmain    ; start of string 
110b 21 8a fd				ld hl, input_cursor 
110e 35					dec (hl) 
110f 18 ea				jr .inskpwn 
1111			.iwstart: 
1111 21 8a fd				ld hl, input_cursor 
1114 34					inc (hl) 
1115 c3 31 10				jp .inmain 
1118					 
1118			 
1118			.inspacep: 
1118			 
1118					;jp .inmain    ; start of string 
1118			 
1118			 
1118			 
1118 3a 8a fd				ld a,(input_cursor) 
111b fe 00				cp 0 
111d ca 31 10				jp z, .inmain    ; start of string 
1120			 
1120			; if we are on a word, then move off of it 
1120			 
1120 cd 88 11				call input_curptr	 
1123 7e					ld a, (hl) 
1124 fe 20				cp ' ' 
1126 c2 2f 11				jp nz, .incharp     ; we are on non space so at end of prev word 
1129 21 8a fd				ld hl, input_cursor 
112c 35					dec (hl) 
112d 18 e9				jr .inspacep 
112f			 
112f			 
112f			.incharp:	 
112f					; eat the word to get to the start 
112f 3a 8a fd				ld a,(input_cursor) 
1132 fe 00				cp 0 
1134 ca 31 10				jp z, .inmain    ; start of string 
1137			 
1137			; if we are on a word, then move off of it 
1137			 
1137 cd 88 11				call input_curptr	 
113a 7e					ld a, (hl) 
113b fe 20				cp ' ' 
113d 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
113f 21 8a fd				ld hl, input_cursor 
1142 35					dec (hl) 
1143 18 ea				jr .incharp 
1145			.ipwordst: 
1145					; at space before the prev word so reposition over it 
1145 21 8a fd				ld hl, input_cursor 
1148 34					inc (hl) 
1149 18 b0				jr .inskpwn 
114b					 
114b			 
114b			 
114b			input_left: 
114b				; move cursor left 
114b 21 8a fd			ld hl, input_cursor 
114e 35				dec (hl) 
114f			;	cp 0 
114f			;	jp z, .inmain    ; ignore left as at the start of the string 
114f c3 31 10			jp .inmain 
1152			 
1152			input_right: 
1152				; move cursor right 
1152				 
1152				;ld a, (input_size) 
1152				;ld b, a 
1152 21 8a fd			ld hl, input_cursor 
1155 34				inc (hl) 
1156				;dec b 
1156				;cp 0 
1156				;jp z, .inmain   ; ignore as at end of the string buffer 
1156				;ld a, b 
1156				;inc a 
1156				;ld (input_cursor), a 
1156 c3 31 10			jp .inmain 
1159			 
1159			 
1159			 
1159			input_disp_ref: 
1159				; display the text from start of buffer (ie full refresh) 
1159 3a 99 fd			ld a, (input_at_pos) 
115c 2a 9c fd			ld hl,(input_start) 
115f eb				ex de, hl 
1160 cd bd 0d			call str_at_display  
1163 c9				ret 
1164			input_disp_oncur: 
1164				; display the text from cursor position to end of buffer 
1164				; TODO position start of string at cursor position on screen 
1164				; TODO draw from that point on 
1164 3a 8a fd			ld a, (input_cursor) 
1167 47				ld b, a 
1168 3a 99 fd			ld a, (input_at_pos) 
116b 80				add b 
116c 48				ld c, b     ; save a 
116d 78				ld a, b     ; inc string start for cursor 
116e 2a 9c fd			ld hl,(input_start) 
1171 cd de 0f			call addatohl 
1174 eb				ex de, hl 
1175 79				ld a, c 
1176 cd bd 0d			call str_at_display  
1179 c9				ret 
117a			 
117a			input_nxtw: 
117a				; Find next word 
117a c9				ret 
117b			 
117b			input_prvw: 
117b				; Find previous word 
117b c9				ret 
117c			 
117c			input_lenrem:   
117c				; Calculate the length of string remaining from current cursor 
117c				; position to end of buffer (exc null term) 
117c				 
117c 3a 8a fd			ld a, (input_cursor) 
117f 4f				ld c, a 
1180 3a 9b fd			ld a, (input_size) 
1183 91				sub c 
1184 06 00			ld b, 0 
1186 0d				dec c 
1187 c9				ret	 
1188			 
1188			input_curptr: 
1188				; calc address of the character under the cursor 
1188				 
1188 2a 9c fd			ld hl, (input_start) 
118b 3a 8a fd			ld a, (input_cursor) 
118e cd de 0f			call addatohl 
1191 c9				ret 
1192			 
1192			input_inschr: 
1192				; Insert char at cursor position 
1192 f5				push af   ; save char 
1193				;call input_lenrem    ; get bc length of remaining string 
1193			 
1193				 
1193 cd 88 11			call input_curptr 
1196			;	ld hl, (input_start) 
1196			;	ld a, (input_cursor) 
1196			;	call addatohl 
1196				;push hl   ; save to come back to 
1196			 
1196				; shift everything up one to end of buffer 
1196			 
1196				;push hl 
1196				;dec de 
1196				;inc de 
1196			;	ldir 
1196				 
1196				;pop hl 
1196			 
1196				; are we adding to the end of line? 
1196			 
1196 3a 8a fd			ld a, (input_cursor) 
1199 47				ld b, a 
119a 3a 8f fd			ld a, (input_len) 
119d b8				cp b 
119e 20 09			jr nz, .insmid   ; no, insert in middle of text 
11a0			 
11a0				; tack on the end of the line 
11a0 f1				pop af 
11a1 77				ld (hl), a   ; save new char 
11a2 23				inc hl 
11a3 3e 00			ld a, 0 
11a5 77				ld (hl), a 
11a6 c3 52 11			jp input_right 
11a9				 
11a9			.insmid: 
11a9				; hl has insertion point so move everything up one to allow for insertion 
11a9				;call input_shiftright 
11a9 f1				pop af 
11aa			 
11aa			.shufinsmid: 
11aa 47				ld b, a     ; b contains new char, c prev char at this position  
11ab 7e				ld a, (hl) 
11ac			 
11ac fe 00			cp 0    ; at end of string need to then dump new char and add term 
11ae 28 07			jr z, .endinsmid 
11b0 4f				ld c, a 
11b1 78				ld a, b 
11b2 77				ld (hl), a 
11b3 23				inc hl 
11b4 79				ld a, c 
11b5 18 f3			jr .shufinsmid 
11b7				 
11b7			 
11b7			 
11b7			 
11b7			.endinsmid: 
11b7 78				ld a, b 
11b8 77				ld (hl), a 
11b9 23				inc hl 
11ba 3e 00			ld a, 0 
11bc 77				ld (hl), a 
11bd			 
11bd			 
11bd			;	ld (hl), a   ; save new char 
11bd			 
11bd c3 52 11			jp input_right 
11c0			 
11c0			;input_shiftright: 
11c0			;	; shift text right at cursor, hl has shift start 
11c0			;	push hl 
11c0			;	push de 
11c0			;	push bc 
11c0			; 
11c0			; 
11c0			;	; move to end of string past zero term 
11c0			;	ld hl,(input_start) 
11c0			;	ld a, (input_len) 
11c0			;	call addatohl 
11c0			;	inc hl 
11c0			;;	inc hl 
11c0			;;	inc hl 
11c0			;	ld a, 0 
11c0			;	ld (hl), a 
11c0			;;	dec hl 
11c0			;	 
11c0			;;	ld (hl), a 
11c0			;;	dec hl 
11c0			; 
11c0			;	push hl 
11c0			;	pop de 
11c0			;	inc de 
11c0			;	 
11c0			; 
11c0			;;	ld hl,(input_start) 
11c0			;;	ld a, (input_cursor) 
11c0			;;	call addatohl 
11c0			; 
11c0			; 
11c0			;	; calc how many bytes from cursor pos to end of string we need to shift 
11c0			;	call input_lenrem    ; get bc length of remaining string 
11c0			;	;ld a, (input_cursor) 
11c0			;	;ld c, a 
11c0			;	ld a, (input_len) 
11c0			;	cp 2 
11c0			;	jr z, .iskipzero	 
11c0			;	;sub c 
11c0			;	;inc a 
11c0			;	;ld c, a 
11c0			;	;ld b, 0 
11c0			;	inc c 
11c0			;	inc c 
11c0			;	; move data 
11c0			;	lddr 
11c0			;.iskipzero: 
11c0			; 
11c0			;	pop bc 
11c0			;	pop de 
11c0			;	pop hl 
11c0			;	ret	 
11c0			 
11c0			input_delchar: 
11c0				; Delete char at cursor position 
11c0 cd 7c 11			call input_lenrem    ; get bc length of remaining string 
11c3 2a 9c fd			ld hl, (input_start) 
11c6 3a 8a fd			ld a, (input_cursor) 
11c9 cd de 0f			call addatohl 
11cc			 
11cc e5				push hl 
11cd d1				pop de 
11ce 1b				dec de 
11cf			 
11cf			.dl:	 
11cf ed a0			ldi  
11d1 7e				ld a, (hl) 
11d2 fe 00			cp 0 
11d4 28 02			jr z, .dldone 
11d6 18 f7			jr .dl 
11d8			.dldone: 
11d8 ed a0			ldi 
11da			 
11da c3 4b 11			jp input_left 
11dd			 
11dd			 
11dd			endif 
11dd			 
11dd			 
11dd			 
11dd			if EDIT_V1 
11dd			input_str: 
11dd			 
11dd				    	ld (input_at_pos),a      ; save display position to start 
11dd					add c 
11dd					ld (input_at_cursor),a	; save draw pos of cursor 
11dd					ld (input_start), hl     ; save ptr to buffer 
11dd					ld a, c 
11dd					call addatohl 
11dd					ld (input_ptr), hl     ; save ptr to point under the cursor 
11dd					ld a,d 
11dd				        ld (input_size), a       ; save length of input area 
11dd					ld a, c 
11dd					ld (input_cursor),a      ; init cursor start position  
11dd					ld a,e 
11dd				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
11dd					 
11dd					 
11dd			 
11dd			;		ld a,(input_ptr) 
11dd			;		ld (input_under_cursor),a 	; save what is under the cursor 
11dd			 
11dd			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
11dd					; init cursor shape if not set by the cin routines 
11dd					ld hl, cursor_shape 
11dd			if BASE_KEV 
11dd					ld a, 255 
11dd			else 
11dd					ld a, '#' 
11dd			endif 
11dd					ld (hl), a 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl), a 
11dd			 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					ld a, 1 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'I' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd			.is1:		; main entry loop 
11dd			 
11dd			 
11dd			 
11dd					; pause 1ms 
11dd			 
11dd					ld a, 1 
11dd					call aDelayInMS 
11dd			 
11dd					; dec flash counter 
11dd					ld a, (input_cur_flash) 
11dd					dec a 
11dd					ld (input_cur_flash), a 
11dd					cp 0 
11dd					jr nz, .nochgstate 
11dd			 
11dd			 
11dd					; change state 
11dd					ld a,(input_cur_onoff) 
11dd					neg 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			 
11dd					; reset on change of state 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd			.nochgstate: 
11dd					 
11dd					 
11dd			 
11dd					; display cursor  
11dd			 
11dd			;		ld hl, (input_start) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			 
11dd					; get char under cursor and replace with cursor 
11dd			ld hl, (input_ptr) 
11dd			;		ld a, (hl) 
11dd			;		ld (input_under_cursor),a 
11dd			;		ld a, '_' 
11dd			;		ld (hl), a 
11dd			 
11dd					; display string 
11dd			 
11dd					ld de, (input_start) 
11dd					ld a, (input_at_pos) 
11dd					call str_at_display 
11dd			;	        call update_display 
11dd			 
11dd					; find place to put the cursor 
11dd			;		add h 
11dd			;		ld l, display_row_1 
11dd			;		sub l 
11dd			; (input_at_pos) 
11dd					;ld c, a 
11dd			;		ld a, (input_cursor) 
11dd			;		ld l, (input_at_pos) 
11dd			;		;ld b, h 
11dd			;		add l 
11dd			;		ld (input_at_cursor),a 
11dd					;ld l,h 
11dd			 
11dd			;		ld h, 0 
11dd			;		ld l,(input_at_pos) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
11dd			;		call subafromhl 
11dd			;		ld a,l 
11dd			;		ld (input_at_cursor), a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					ld a, (hardware_diag) 
11dd					cp 0 
11dd					jr z, .skip_input_diag 
11dd			 
11dd					ld a,(input_at_pos) 
11dd					ld hl, LFSRSeed 
11dd					call hexout 
11dd					ld a, (input_cursor) 
11dd					ld hl, LFSRSeed+2 
11dd					call hexout 
11dd					ld a,(input_at_cursor) 
11dd					ld hl, LFSRSeed+4 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_onoff) 
11dd					ld hl, LFSRSeed+6 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_flash) 
11dd					ld hl, LFSRSeed+8 
11dd					call hexout 
11dd			 
11dd					ld a,(input_len) 
11dd					ld hl, LFSRSeed+10 
11dd					call hexout 
11dd					ld hl, LFSRSeed+12 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd					ld a, display_row_4 
11dd					ld de, LFSRSeed 
11dd					call str_at_display 
11dd					.skip_input_diag: 
11dd				endif 
11dd			 
11dd					; decide on if we are showing the cursor this time round 
11dd			 
11dd					ld a, (input_cur_onoff) 
11dd					cp 255 
11dd					jr z, .skipcur 
11dd			 
11dd			 
11dd					ld a,(input_at_cursor) 
11dd					ld de, cursor_shape 
11dd					call str_at_display 
11dd			 
11dd					; save length of current input string 
11dd					ld hl, (input_start) 
11dd					ld a, 0 
11dd					call strlent 
11dd					ld a,l 
11dd					ld (input_len),a 
11dd			 
11dd			.skipcur: 
11dd			 
11dd				        call update_display 
11dd					 
11dd			 
11dd			 
11dd					; wait 
11dd				 
11dd					; TODO loop without wait to flash the cursor and char under cursor	 
11dd					call cin    ; _wait 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 
11dd			 
11dd					; get ptr to char to input into 
11dd			 
11dd					ld c,a 
11dd					ld hl, (input_start) 
11dd					ld a, (input_cursor) 
11dd					call addatohl 
11dd					ld (input_ptr), hl 
11dd					ld a,c 
11dd			 
11dd					; replace char under cursor 
11dd			 
11dd			;		ld hl, (input_ptr) 
11dd			;		ld a, (input_under_cursor) 	; get what is under the cursor 
11dd			;		ld (hl), a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'i' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					cp KEY_HOME 
11dd					jr nz, .iske 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor),a 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					jp .is1 
11dd					 
11dd			.iske:		cp KEY_END 
11dd					jr nz, .isknw 
11dd					jp .is1 
11dd			 
11dd			.isknw:		cp KEY_NEXTWORD 
11dd					jr nz, .iskpw 
11dd			 
11dd			.isknwm:	ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0 
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd					jr .isknwm 
11dd			 
11dd			.iskpw:		cp KEY_PREVWORD 
11dd					jr nz, .iskl 
11dd			.iskpwm:	 
11dd					ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0  
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd					jr .iskpwm 
11dd			 
11dd			 
11dd			.iskl:		cp KEY_LEFT 
11dd					jr nz, .isk1 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk1:		cp KEY_RIGHT 
11dd					jr nz, .isk2 
11dd			 
11dd					ld a,(input_len)		; TODO BUG why cant i load e direct? 
11dd					ld e,a 
11dd					ld a, (input_cursor) 
11dd					cp e 
11dd					jp z, .is1		; at the end of string so dont go right 
11dd			 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk2:		cp KEY_UP 
11dd			 
11dd					jr nz, .isk3 
11dd			 
11dd					; swap last command with the current on 
11dd			 
11dd					; move cursor to start of string 
11dd					ld hl, (input_start) 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					 
11dd					; swap input and last command buffers 
11dd			 
11dd					ld hl, os_cli_cmd 
11dd					ld de, os_last_cmd 
11dd					ld b, 255 
11dd			.swap1:		ld a, (hl) 
11dd					ld c,a 
11dd					ld a, (de) 
11dd					ld (hl), a 
11dd					ld a,c 
11dd					ld (de),a 
11dd					inc hl 
11dd					inc de 
11dd					djnz .swap1 
11dd			 
11dd			 
11dd			 
11dd			 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk3:		cp KEY_BS 
11dd					jr nz, .isk4 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					; hl is source 
11dd					; de needs to be source - 1 
11dd			 
11dd			;		ld a, 0 
11dd			;		dec hl 
11dd			;		ld (hl), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					; shift all data 
11dd			 
11dd					push hl 
11dd					inc hl 
11dd					pop de 
11dd					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
11dd					ld c,a 
11dd					ld b,0 
11dd					ldir  
11dd			 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					; remove char 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld de,.iblank 
11dd					call str_at_display 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk4:		cp KEY_CR 
11dd					jr z, .endinput 
11dd			 
11dd					; else add the key press to the end 
11dd			 
11dd					ld c, a			; save key pressed 
11dd			 
11dd					ld a,(hl)		; get what is currently under char 
11dd			 
11dd					cp 0			; we are at the end of the string 
11dd					jr nz, .onchar 
11dd					 
11dd					; add a char to the end of the string 
11dd				 
11dd					ld (hl),c 
11dd					inc hl 
11dd			;		ld a,' ' 
11dd			;		ld (hl),a 
11dd			;		inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					dec hl 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc a				; TODO check max string length and scroll  
11dd					ld (input_cursor), a		; inc cursor pos 
11dd							 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, '+' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					jp .is1 
11dd					 
11dd			 
11dd			 
11dd					; if on a char then insert 
11dd			.onchar: 
11dd			 
11dd					; TODO over flow check: make sure insert does not blow out buffer 
11dd			 
11dd					; need to do some maths to use lddr 
11dd			 
11dd					push hl   ; save char pos 
11dd					push bc 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a, (input_len) 
11dd					call addatohl  		; end of string 
11dd					inc hl 
11dd					inc hl		; past zero term 
11dd					push hl 
11dd					inc hl 
11dd					push hl  
11dd			 
11dd								; start and end of lddr set, now how much to move? 
11dd			 
11dd							 
11dd					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11dd					ld b,a 
11dd					ld a,(input_len) 
11dd					ld e,a 
11dd					sub b 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd			 
11dd					ld b,0 
11dd					ld c,a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'i' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					pop de 
11dd					pop hl 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'I' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					lddr 
11dd				 
11dd			 
11dd			 
11dd					; TODO have a key for insert/overwrite mode???? 
11dd					pop bc 
11dd					pop hl 
11dd					ld (hl), c		; otherwise overwrite current char 
11dd					 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.endinput:	; TODO look for end of string 
11dd			 
11dd					; add trailing space for end of token 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a,(input_len) 
11dd					call addatohl 
11dd					ld a, ' ' 
11dd					ld (hl),a 
11dd					; TODO eof of parse marker 
11dd			 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					ret 
11dd			 
11dd			.iblank: db " ",0 
11dd			 
11dd			 
11dd			input_str_prev:	ld (input_at_pos), a 
11dd					ld (input_start), hl 
11dd					ld a,1			; add cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					ld (input_ptr), hl 
11dd					ld a,d 
11dd					ld (input_size), a 
11dd					ld a,0 
11dd					ld (input_cursor),a 
11dd			.instr1:	 
11dd			 
11dd					; TODO do block cursor 
11dd					; TODO switch cursor depending on the modifer key 
11dd			 
11dd					; update cursor shape change on key hold 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl), a 
11dd			 
11dd					; display entered text 
11dd					ld a,(input_at_pos) 
11dd			            	CALL fLCD_Pos       ;Position cursor to location in A 
11dd			            	LD   de, (input_start) 
11dd			            	CALL fLCD_Str       ;Display string pointed to by DE 
11dd			 
11dd					call cin 
11dd					cp 0 
11dd					jr z, .instr1 
11dd			 
11dd					; proecess keyboard controls first 
11dd			 
11dd					ld hl,(input_ptr) 
11dd			 
11dd					cp KEY_CR	 ; pressing enter ends input 
11dd					jr z, .instrcr 
11dd			 
11dd					cp KEY_BS 	; back space 
11dd					jr nz, .instr2 
11dd					; process back space 
11dd			 
11dd					; TODO stop back space if at start of string 
11dd					dec hl 
11dd					dec hl ; to over write cursor 
11dd					ld a,(cursor_shape) 
11dd					;ld a,0 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a," " 
11dd					ld (hl),a 
11dd					ld (input_ptr),hl 
11dd					 
11dd			 
11dd					jr .instr1 
11dd			 
11dd			.instr2:	cp KEY_LEFT    ; cursor left 
11dd					jr nz, .instr3 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd				 
11dd			.instr3:	cp KEY_RIGHT      ; cursor right 
11dd					jr nz, .instr4 
11dd					inc hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr4:	cp KEY_HOME    ; jump to start of line 
11dd					jr nz, .instr5 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr5:	cp KEY_END     ; jump to end of line 
11dd					jr nz, .instr6 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			.instr6:        cp KEY_UP      ; recall last command 
11dd					jr nz, .instrnew 
11dd			 
11dd				ld hl, scratch 
11dd				ld de, os_last_cmd 
11dd				call strcpy 
11dd					jr .instr1 
11dd			 
11dd			 
11dd			.instrnew:	; no special key pressed to see if we have room to store it 
11dd			 
11dd					; TODO do string size test 
11dd			 
11dd					dec hl ; to over write cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd					ld (input_ptr),hl 
11dd					 
11dd					jr .instr1 
11dd			.instrcr:	dec hl		; remove cursor 
11dd					ld a,' '	; TODO add a trailing space for safety 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					; if at end of line scroll up    
11dd					; TODO detecting only end of line 4 for scroll up  
11dd			 
11dd					;ld   
11dd			 
11dd					ret 
11dd			 
11dd			 
11dd			endif 
11dd			; strcpy hl = dest, de source 
11dd			 
11dd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11de b7			            OR   A              ;Null terminator? 
11df c8			            RET  Z              ;Yes, so finished 
11e0 1a					ld a,(de) 
11e1 77					ld (hl),a 
11e2 13			            INC  DE             ;Point to next character 
11e3 23					inc hl 
11e4 18 f7		            JR   strcpy       ;Repeat 
11e6 c9					ret 
11e7			 
11e7			 
11e7			; TODO string_at  
11e7			; pass string which starts with lcd offset address and then null term string 
11e7			 
11e7			; TODO string to dec 
11e7			; TODO string to hex 
11e7			; TODO byte to string hex 
11e7			; TODO byte to string dec 
11e7			 
11e7			 
11e7			 
11e7			; from z80uartmonitor 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11e7			; pass hl for where to put the text 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7 c5			hexout:	PUSH BC 
11e8 f5					PUSH AF 
11e9 47					LD B, A 
11ea					; Upper nybble 
11ea cb 3f				SRL A 
11ec cb 3f				SRL A 
11ee cb 3f				SRL A 
11f0 cb 3f				SRL A 
11f2 cd 02 12				CALL tohex 
11f5 77					ld (hl),a 
11f6 23					inc hl	 
11f7					 
11f7					; Lower nybble 
11f7 78					LD A, B 
11f8 e6 0f				AND 0FH 
11fa cd 02 12				CALL tohex 
11fd 77					ld (hl),a 
11fe 23					inc hl	 
11ff					 
11ff f1					POP AF 
1200 c1					POP BC 
1201 c9					RET 
1202					 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			tohex: 
1202 e5					PUSH HL 
1203 d5					PUSH DE 
1204 16 00				LD D, 0 
1206 5f					LD E, A 
1207 21 0f 12				LD HL, .DATA 
120a 19					ADD HL, DE 
120b 7e					LD A, (HL) 
120c d1					POP DE 
120d e1					POP HL 
120e c9					RET 
120f			 
120f			.DATA: 
120f 30					DEFB	30h	; 0 
1210 31					DEFB	31h	; 1 
1211 32					DEFB	32h	; 2 
1212 33					DEFB	33h	; 3 
1213 34					DEFB	34h	; 4 
1214 35					DEFB	35h	; 5 
1215 36					DEFB	36h	; 6 
1216 37					DEFB	37h	; 7 
1217 38					DEFB	38h	; 8 
1218 39					DEFB	39h	; 9 
1219 41					DEFB	41h	; A 
121a 42					DEFB	42h	; B 
121b 43					DEFB	43h	; C 
121c 44					DEFB	44h	; D 
121d 45					DEFB	45h	; E 
121e 46					DEFB	46h	; F 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
121f			;;    subtract $30, if result > 9 then subtract $7 more 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			atohex: 
121f d6 30				SUB $30 
1221 fe 0a				CP 10 
1223 f8					RET M		; If result negative it was 0-9 so we're done 
1224 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1226 c9					RET		 
1227			 
1227			 
1227			 
1227			 
1227			; Get 2 ASCII characters as hex byte from pointer in hl 
1227			 
1227			BYTERD: 
1227 16 00			LD	D,00h		;Set up 
1229 cd 31 12			CALL	HEXCON		;Get byte and convert to hex 
122c 87				ADD	A,A		;First nibble so 
122d 87				ADD	A,A		;multiply by 16 
122e 87				ADD	A,A		; 
122f 87				ADD	A,A		; 
1230 57				LD	D,A		;Save hi nibble in D 
1231			HEXCON: 
1231 7e				ld a, (hl)		;Get next chr 
1232 23				inc hl 
1233 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1235 fe 0a			CP	00Ah		;Is it 0-9 ? 
1237 38 02			JR	C,NALPHA	;If so miss next bit 
1239 d6 07			SUB	007h		;Else convert alpha 
123b			NALPHA: 
123b b2				OR	D		;Add hi nibble back 
123c c9				RET			; 
123d			 
123d			 
123d			; 
123d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
123d			; Since the routines get_byte and therefore get_nibble are called, only valid 
123d			; characters (0-9a-f) are accepted. 
123d			; 
123d			;get_word        push    af 
123d			;                call    get_byte        ; Get the upper byte 
123d			;                ld      h, a 
123d			;                call    get_byte        ; Get the lower byte 
123d			;                ld      l, a 
123d			;                pop     af 
123d			;                ret 
123d			; 
123d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
123d			; the routine get_nibble is used only valid characters are accepted - the  
123d			; input routine only accepts characters 0-9a-f. 
123d			; 
123d c5			get_byte:        push    bc              ; Save contents of B (and C) 
123e 7e					ld a,(hl) 
123f 23					inc hl 
1240 cd 65 12		                call    nibble2val      ; Get upper nibble 
1243 cb 07		                rlc     a 
1245 cb 07		                rlc     a 
1247 cb 07		                rlc     a 
1249 cb 07		                rlc     a 
124b 47			                ld      b, a            ; Save upper four bits 
124c 7e					ld a,(hl) 
124d cd 65 12		                call    nibble2val      ; Get lower nibble 
1250 b0			                or      b               ; Combine both nibbles 
1251 c1			                pop     bc              ; Restore B (and C) 
1252 c9			                ret 
1253			; 
1253			; Get a hexadecimal digit from the serial line. This routine blocks until 
1253			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1253			; to the serial line interface. The lower 4 bits of A contain the value of  
1253			; that particular digit. 
1253			; 
1253			;get_nibble      ld a,(hl)           ; Read a character 
1253			;                call    to_upper        ; Convert to upper case 
1253			;                call    is_hex          ; Was it a hex digit? 
1253			;                jr      nc, get_nibble  ; No, get another character 
1253			 ;               call    nibble2val      ; Convert nibble to value 
1253			 ;               call    print_nibble 
1253			 ;               ret 
1253			; 
1253			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1253			; A valid hexadecimal digit is denoted by a set C flag. 
1253			; 
1253			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1253			;                ret     nc              ; Yes 
1253			;                cp      '0'             ; Less than '0'? 
1253			;                jr      nc, is_hex_1    ; No, continue 
1253			;                ccf                     ; Complement carry (i.e. clear it) 
1253			;                ret 
1253			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1253			;                ret     c               ; Yes 
1253			;                cp      'A'             ; Less than 'A'? 
1253			;                jr      nc, is_hex_2    ; No, continue 
1253			;                ccf                     ; Yes - clear carry and return 
1253			;                ret 
1253			;is_hex_2        scf                     ; Set carry 
1253			;                ret 
1253			; 
1253			; Convert a single character contained in A to upper case: 
1253			; 
1253 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1255 d8			                ret     c 
1256 fe 7b		                cp      'z' + 1         ; > 'z'? 
1258 d0			                ret     nc              ; Nothing to do, either 
1259 e6 5f		                and     $5f             ; Convert to upper case 
125b c9			                ret 
125c			 
125c			 
125c			to_lower: 
125c			 
125c			   ; if char is in [A-Z] make it lower case 
125c			 
125c			   ; enter : a = char 
125c			   ; exit  : a = lower case char 
125c			   ; uses  : af 
125c			 
125c fe 41		   cp 'A' 
125e d8			   ret c 
125f			    
125f fe 5b		   cp 'Z'+1 
1261 d0			   ret nc 
1262			    
1262 f6 20		   or $20 
1264 c9			   ret 
1265			 
1265			; 
1265			; Expects a hexadecimal digit (upper case!) in A and returns the 
1265			; corresponding value in A. 
1265			; 
1265 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1267 38 02		                jr      c, nibble2val_1 ; Yes 
1269 d6 07		                sub     7               ; Adjust for A-F 
126b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
126d e6 0f		                and     $f              ; Only return lower 4 bits 
126f c9			                ret 
1270			; 
1270			; Print_nibble prints a single hex nibble which is contained in the lower  
1270			; four bits of A: 
1270			; 
1270			;print_nibble    push    af              ; We won't destroy the contents of A 
1270			;                and     $f              ; Just in case... 
1270			;                add     a, '0'             ; If we have a digit we are done here. 
1270			;                cp      '9' + 1         ; Is the result > 9? 
1270			;                jr      c, print_nibble_1 
1270			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1270			;print_nibble_1  call    putc            ; Print the nibble and 
1270			;                pop     af              ; restore the original value of A 
1270			;                ret 
1270			;; 
1270			;; Send a CR/LF pair: 
1270			; 
1270			;crlf            push    af 
1270			;                ld      a, cr 
1270			;                call    putc 
1270			;                ld      a, lf 
1270			;                call    putc 
1270			;                pop     af 
1270			;                ret 
1270			; 
1270			; Print_word prints the four hex digits of a word to the serial line. The  
1270			; word is expected to be in HL. 
1270			; 
1270			;print_word      push    hl 
1270			;                push    af 
1270			;                ld      a, h 
1270			;                call    print_byte 
1270			;                ld      a, l 
1270			;                call    print_byte 
1270			;                pop     af 
1270			;                pop     hl 
1270			;                ret 
1270			; 
1270			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1270			; The byte to be printed is expected to be in A. 
1270			; 
1270			;print_byte      push    af              ; Save the contents of the registers 
1270			;                push    bc 
1270			;                ld      b, a 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                call    print_nibble    ; Print high nibble 
1270			;                ld      a, b 
1270			;                call    print_nibble    ; Print low nibble 
1270			;                pop     bc              ; Restore original register contents 
1270			;                pop     af 
1270			;                ret 
1270			 
1270			 
1270			 
1270			 
1270			 
1270			fourehexhl:  
1270 7e				ld a,(hl) 
1271 cd 1f 12			call atohex 
1274 cb 3f				SRL A 
1276 cb 3f				SRL A 
1278 cb 3f				SRL A 
127a cb 3f				SRL A 
127c 47				ld b, a 
127d 23				inc hl 
127e 7e				ld a,(hl) 
127f 23				inc hl 
1280 cd 1f 12			call atohex 
1283 80				add b 
1284 57				ld d,a 
1285 7e				ld a,(hl) 
1286 cd 1f 12			call atohex 
1289 cb 3f				SRL A 
128b cb 3f				SRL A 
128d cb 3f				SRL A 
128f cb 3f				SRL A 
1291 47				ld b, a 
1292 23				inc hl 
1293 7e				ld a,(hl) 
1294 23				inc hl 
1295 cd 1f 12			call atohex 
1298 80				add b 
1299 5f				ld e, a 
129a d5				push de 
129b e1				pop hl 
129c c9				ret 
129d			 
129d			; pass hl. returns z set if the byte at hl is a digit 
129d			;isdigithl:  
129d			;	push bc 
129d			;	ld a,(hl) 
129d			;	cp ':' 
129d			;	jr nc, .isdf 		; > 
129d			;	cp '0' 
129d			;	jr c, .isdf		; < 
129d			; 
129d			;	; TODO find a better way to set z 
129d			; 
129d			;	ld b,a 
129d			;	cp b 
129d			;	pop bc 
129d			;	ret 
129d			; 
129d			;.isdf:	; not digit so clear z 
129d			; 
129d			;	; TODO find a better way to unset z 
129d			; 
129d			;	ld b,a 
129d			;	inc b 
129d			;	cp b 
129d			; 
129d			;	pop bc 
129d			;	ret 
129d				 
129d				 
129d			 
129d			 
129d			; pass hl as the four byte address to load 
129d			 
129d			get_word_hl:  
129d e5				push hl 
129e cd 3d 12			call get_byte 
12a1				 
12a1 47				ld b, a 
12a2			 
12a2 e1				pop hl 
12a3 23				inc hl 
12a4 23				inc hl 
12a5			 
12a5			; TODO not able to handle a-f  
12a5 7e				ld a,(hl) 
12a6			;	;cp ':' 
12a6			;	cp 'g' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp 'G' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp '0' 
12a6			;	jr c, .single_byte_hl		; < 
12a6			 
12a6				;call isdigithl 
12a6 fe 00			cp 0 
12a8 28 06			jr z, .single_byte_hl 
12aa			 
12aa			.getwhln:   ; hex word so get next byte 
12aa			 
12aa cd 3d 12			call get_byte 
12ad 6f				ld l, a 
12ae 60				ld h,b 
12af c9				ret 
12b0 68			.single_byte_hl:   ld l,b 
12b1 26 00				ld h,0 
12b3 c9					ret 
12b4			 
12b4			 
12b4			 
12b4			 
12b4 21 21 1d			ld hl,asc+1 
12b7			;	ld a, (hl) 
12b7			;	call nibble2val 
12b7 cd 3d 12			call get_byte 
12ba			 
12ba			;	call fourehexhl 
12ba 32 2a f1			ld (scratch+52),a 
12bd				 
12bd 21 28 f1			ld hl,scratch+50 
12c0 22 19 f4			ld (os_cur_ptr),hl 
12c3			 
12c3 c9				ret 
12c4			 
12c4			 
12c4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12c4			 
12c4			; Decimal Unsigned Version 
12c4			 
12c4			;Number in a to decimal ASCII 
12c4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12c4			;Example: display a=56 as "056" 
12c4			;input: a = number 
12c4			;Output: a=0,value of a in the screen 
12c4			;destroys af,bc (don't know about hl and de) 
12c4			DispAToASCII: 
12c4 0e 9c			ld	c,-100 
12c6 cd d0 12			call	.Na1 
12c9 0e f6			ld	c,-10 
12cb cd d0 12			call	.Na1 
12ce 0e ff			ld	c,-1 
12d0 06 2f		.Na1:	ld	b,'0'-1 
12d2 04			.Na2:	inc	b 
12d3 81				add	a,c 
12d4 38 fc			jr	c,.Na2 
12d6 91				sub	c		;works as add 100/10/1 
12d7 f5				push af		;safer than ld c,a 
12d8 78				ld	a,b		;char is in b 
12d9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12d9 f1				pop af		;safer than ld a,c 
12da c9				ret 
12db			 
12db			; Decimal Signed Version 
12db			 
12db			; DispA 
12db			; -------------------------------------------------------------- 
12db			; Converts a signed integer value to a zero-terminated ASCII 
12db			; string representative of that value (using radix 10). 
12db			; -------------------------------------------------------------- 
12db			; INPUTS: 
12db			;     HL     Value to convert (two's complement integer). 
12db			;     DE     Base address of string destination. (pointer). 
12db			; -------------------------------------------------------------- 
12db			; OUTPUTS: 
12db			;     None 
12db			; -------------------------------------------------------------- 
12db			; REGISTERS/MEMORY DESTROYED 
12db			; AF HL 
12db			; -------------------------------------------------------------- 
12db			 
12db			;DispHLToASCII: 
12db			;   push    de 
12db			;   push    bc 
12db			; 
12db			;; Detect sign of HL. 
12db			;    bit    7, h 
12db			;    jr     z, ._DoConvert 
12db			; 
12db			;; HL is negative. Output '-' to string and negate HL. 
12db			;    ld     a, '-' 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			; 
12db			;; Negate HL (using two's complement) 
12db			;    xor    a 
12db			;    sub    l 
12db			;    ld     l, a 
12db			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12db			;    sbc    a, h 
12db			;    ld     h, a 
12db			; 
12db			;; Convert HL to digit characters 
12db			;._DoConvert: 
12db			;    ld     b, 0     ; B will count character length of number 
12db			;-   ld     a, 10 
12db			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12db			;    push   af 
12db			;    inc    b 
12db			;    ld     a, h 
12db			;    or     l 
12db			;    jr     nz, - 
12db			; 
12db			;; Retrieve digits from stack 
12db			;-   pop    af 
12db			;    or     $30 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			;    djnz   - 
12db			; 
12db			;; Terminate string with NULL 
12db			;    xor    a 
12db			;    ld     (de), a 
12db			; 
12db			;    pop    bc 
12db			;    pop    de 
12db			;    ret 
12db			 
12db			;Comments 
12db			; 
12db			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12db			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12db			;    Note that the output string will not be fixed-width. 
12db			; 
12db			;Example Usage 
12db			; 
12db			;    ld    hl, -1004 
12db			;    ld    de, OP1 
12db			;    call  DispA 
12db			;    ld    hl, OP1 
12db			;    syscall  PutS 
12db			 
12db			 
12db			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12db			 
12db			 
12db			;Converts an ASCII string to an unsigned 16-bit integer 
12db			;Quits when it reaches a non-decimal digit 
12db			 
12db			string_to_uint16: 
12db			atoui_16: 
12db			;Input: 
12db			;     DE points to the string 
12db			;Outputs: 
12db			;     HL is the result 
12db			;     A is the 8-bit value of the number 
12db			;     DE points to the byte after the number 
12db			;Destroys: 
12db			;     BC 
12db			;       if the string is non-empty, BC is HL/10 
12db			;Size:  24 bytes 
12db			;Speed: 42+d(104+{0,9}) 
12db			;       d is the number of digits in the number 
12db			;       max is 640 cycles for a 5 digit number 
12db			;Assuming no leading zeros: 
12db			;1 digit:  146cc 
12db			;2 digit:  250cc 
12db			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12db			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12db			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12db			;avg: 544.81158447265625cc (544+13297/16384) 
12db			;=============================================================== 
12db 21 00 00		  ld hl,0 
12de			.u16a: 
12de 1a			  ld a,(de) 
12df d6 30		  sub 30h 
12e1 fe 0a		  cp 10 
12e3 d0			  ret nc 
12e4 13			  inc de 
12e5 44			  ld b,h 
12e6 4d			  ld c,l 
12e7 29			  add hl,hl 
12e8 29			  add hl,hl 
12e9 09			  add hl,bc 
12ea 29			  add hl,hl 
12eb 85			  add a,l 
12ec 6f			  ld l,a 
12ed 30 ef		  jr nc,.u16a 
12ef 24			  inc h 
12f0 c3 de 12		  jp .u16a 
12f3			 
12f3			 
12f3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12f3			 
12f3			;written by Zeda 
12f3			;Converts a 16-bit unsigned integer to an ASCII string. 
12f3			 
12f3			uitoa_16: 
12f3			;Input: 
12f3			;   DE is the number to convert 
12f3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12f3			;Output: 
12f3			;   HL points to the null-terminated ASCII string 
12f3			;      NOTE: This isn't necessarily the same as the input HL. 
12f3 d5			  push de 
12f4 c5			  push bc 
12f5 f5			  push af 
12f6 eb			  ex de,hl 
12f7			 
12f7 01 f0 d8		  ld bc,-10000 
12fa 3e 2f		  ld a,'0'-1 
12fc 3c			  inc a 
12fd 09			  add hl,bc  
12fe 38 fc		   jr c,$-2 
1300 12			  ld (de),a 
1301 13			  inc de 
1302			 
1302 01 e8 03		  ld bc,1000 
1305 3e 3a		  ld a,'9'+1 
1307 3d			  dec a  
1308 09			  add hl,bc  
1309 30 fc		   jr nc,$-2 
130b 12			  ld (de),a 
130c 13			  inc de 
130d			 
130d 01 9c ff		  ld bc,-100 
1310 3e 2f		  ld a,'0'-1 
1312 3c			  inc a  
1313 09			  add hl,bc  
1314 38 fc		   jr c,$-2 
1316 12			  ld (de),a 
1317 13			  inc de 
1318			 
1318 7d			  ld a,l 
1319 26 3a		  ld h,'9'+1 
131b 25			  dec h  
131c c6 0a		  add a,10  
131e 30 fb		   jr nc,$-3 
1320 c6 30		  add a,'0' 
1322 eb			  ex de,hl 
1323 72			  ld (hl),d 
1324 23			  inc hl 
1325 77			  ld (hl),a 
1326 23			  inc hl 
1327 36 00		  ld (hl),0 
1329			 
1329			;Now strip the leading zeros 
1329 0e fa		  ld c,-6 
132b 09			  add hl,bc 
132c 3e 30		  ld a,'0' 
132e 23			  inc hl  
132f be			  cp (hl)  
1330 28 fc		  jr z,$-2 
1332			 
1332			;Make sure that the string is non-empty! 
1332 7e			  ld a,(hl) 
1333 b7			  or a 
1334 20 01		  jr nz,.atoub 
1336 2b			  dec hl 
1337			.atoub: 
1337			 
1337 f1			  pop af 
1338 c1			  pop bc 
1339 d1			  pop de 
133a c9			  ret 
133b			 
133b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
133b			 
133b			toUpper: 
133b			;A is the char. 
133b			;If A is a lowercase letter, this sets it to the matching uppercase 
133b			;18cc or 30cc or 41cc 
133b			;avg: 26.75cc 
133b fe 61		  cp 'a' 
133d d8			  ret c 
133e fe 7b		  cp 'z'+1 
1340 d0			  ret nc 
1341 d6 20		  sub 'a'-'A' 
1343 c9			  ret 
1344			 
1344			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1344			 
1344			; String Length 
1344			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1344			 
1344			; Get the length of the null-terminated string starting at $8000 hl 
1344			;    LD     HL, $8000 
1344			 
1344			strlenz: 
1344			 
1344 af			    XOR    A               ; Zero is the value we are looking for. 
1345 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1346 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1347			                           ; 65, 536 bytes (the entire addressable memory space). 
1347 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1349			 
1349			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1349 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
134a 6f			    LD     L, A             ; number of bytes 
134b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
134d 2b			    DEC    HL              ; Compensate for null. 
134e c9				ret 
134f			 
134f			; Get the length of the A terminated string starting at $8000 hl 
134f			;    LD     HL, $8000 
134f			 
134f			strlent: 
134f			 
134f			                  ; A is the value we are looking for. 
134f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1351 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1353			                           ; 65, 536 bytes (the entire addressable memory space). 
1353 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1355			 
1355			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1355 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1357 2e 00		    LD     L, 0             ; number of bytes 
1359 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
135b 2b			    DEC    HL              ; Compensate for null. 
135c c9				ret 
135d			 
135d			 
135d			;Comparing Strings 
135d			 
135d			;IN    HL     Address of string1. 
135d			;      DE     Address of string2. 
135d			 
135d			; doc given but wrong??? 
135d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
135d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
135d			; tested 
135d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
135d			 
135d			strcmp_old: 
135d e5			    PUSH   HL 
135e d5			    PUSH   DE 
135f			 
135f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1360 be			    CP     (HL)            ; (want to minimize work). 
1361 38 01		    JR     C, Str1IsBigger 
1363 7e			    LD     A, (HL) 
1364			 
1364			Str1IsBigger: 
1364 4f			    LD     C, A             ; Put length in BC 
1365 06 00		    LD     B, 0 
1367 13			    INC    DE              ; Increment pointers to meat of string. 
1368 23			    INC    HL 
1369			 
1369			CmpLoop: 
1369 1a			    LD     A, (DE)          ; Compare bytes. 
136a ed a1		    CPI 
136c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
136e 13			    INC    DE              ; Update pointer. 
136f ea 69 13		    JP     PE, CmpLoop 
1372			 
1372 d1			    POP    DE 
1373 e1			    POP    HL 
1374 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1375 be			    CP     (HL) 
1376 c9			    RET 
1377			 
1377			NoMatch: 
1377 2b			    DEC    HL 
1378 be			    CP     (HL)            ; Compare again to affect carry. 
1379 d1			    POP    DE 
137a e1			    POP    HL 
137b c9			    RET 
137c			 
137c			;; test strmp 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr z, .z1 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z1: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr z, .z2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr c, .c1 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c1: 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr c, .c2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;	NEXTW 
137c			;.str1:   db "string1",0 
137c			;.str2:   db "string2",0 
137c			 
137c			; only care about direct match or not 
137c			; hl and de strings 
137c			; zero set if the same 
137c			 
137c			strcmp: 
137c 1a				ld a, (de) 
137d be				cp (hl) 
137e 28 02			jr z, .ssame 
1380 b7				or a 
1381 c9				ret 
1382			 
1382			.ssame:  
1382 fe 00			cp 0 
1384 c8				ret z 
1385			 
1385 23				inc hl 
1386 13				inc de 
1387 18 f3			jr strcmp 
1389				 
1389				 
1389			 
1389			;Copyright (c) 2014, Luke Maurits 
1389			;All rights reserved. 
1389			; 
1389			;Redistribution and use in source and binary forms, with or without 
1389			;modification, are permitted provided that the following conditions are met: 
1389			; 
1389			;* Redistributions of source code must retain the above copyright notice, this 
1389			;  list of conditions and the following disclaimer. 
1389			; 
1389			;* Redistributions in binary form must reproduce the above copyright notice, 
1389			;  this list of conditions and the following disclaimer in the documentation 
1389			;  and/or other materials provided with the distribution. 
1389			; 
1389			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1389			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1389			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1389			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1389			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1389			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1389			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1389			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1389			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1389			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1389			 
1389			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1389			 
1389			StrictStrCmp: 
1389				; Load next chars of each string 
1389 1a				ld a, (de) 
138a 47				ld b, a 
138b 7e				ld a, (hl) 
138c				; Compare 
138c b8				cp b 
138d				; Return non-zero if chars don't match 
138d c0				ret nz 
138e				; Check for end of both strings 
138e fe 00			cp "\0" 
1390				; Return if strings have ended 
1390 c8				ret z 
1391				; Otherwise, advance to next chars 
1391 23				inc hl 
1392 13				inc de 
1393 18 f4			jr StrictStrCmp 
1395			 
1395			;end 
1395			; eof 
1395			 
1395			 
1395			 
1395			 
1395			 
1395			 
# End of file firmware_strings.asm
1395			include "firmware_memory.asm"   ; malloc and free  
1395			 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			.mallocsize: db "Wants malloc >256",0 
1395			.mallocasize: db "MALLOC gives >256",0 
1395			.malloczero: db "MALLOC gives zero",0 
1395			 
1395			malloc_guard_zerolen: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395				ld de, 0 
1395			        call cmp16 
1395				jr nz, .lowalloz 
1395			 
1395				push hl 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .malloczero 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395				call bp_on 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395			.lowalloz: 
1395			 
1395			 
1395				pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_entry: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowalloc 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocsize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395				jr .lowdone 
1395			.lowalloc: 
1395			 
1395			 
1395				pop hl 
1395			.lowdone:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_exit: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowallocx 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocasize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395				pop de 
1395				pop hl 
1395			 
1395				CALLMONITOR 
1395				jr .lowdonex 
1395			.lowallocx: 
1395			 
1395				pop hl 
1395			.lowdonex:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			endif 
1395			 
1395			if MALLOC_2 
1395			; Z80 Malloc and Free Functions 
1395			 
1395			; Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc: 
1395				 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_entry 
1395			endif 
1395			 
1395			 
1395			 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "mal" 
1395						CALLMONITOR 
1395					endif 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of size into A 
1395			    or h               ; Check if size is zero 
1395			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1395			 
1395			    ; Allocate memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma1" 
1395						CALLMONITOR 
1395					endif 
1395			    call malloc_internal ; Call internal malloc function 
1395			    pop af             ; Restore AF register 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret                ; Return 
1395			 
1395			; Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free: 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of pointer into A 
1395			    or h               ; Check if pointer is NULL 
1395			    jp z, free_exit    ; If pointer is NULL, exit 
1395			 
1395			    ; Free memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395			    call free_internal  ; Call internal free function 
1395			    pop af             ; Restore AF register 
1395			    ret                ; Return 
1395			 
1395			; Internal Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc_internal: 
1395			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to requested size 
1395			    ex de, hl          ; Save total size in DE, and keep it in HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			 
1395			    ; Search for free memory block 
1395			    ld de, (heap_end)  ; Load end of heap into DE 
1395			    ld bc, 0           ; Initialize counter 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			malloc_search_loop: 
1395			    ; Check if current block is free 
1395			    ld a, (hl)         ; Load current block's status (free or used) 
1395			    cp 0               ; Compare with zero (free) 
1395			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1395			 
1395			    ; Check if current block is large enough 
1395			    ld a, (hl+1)       ; Load high byte of block size 
1395			    cp l               ; Compare with low byte of requested size 
1395			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1395			 
1395			    ld a, (hl+2)       ; Load low byte of block size 
1395			    cp h               ; Compare with high byte of requested size 
1395			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1395			 
1395			    ; Mark block as used 
1395			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1395			 
1395			    ; Calculate remaining space in block 
1395			    ld bc, 0           ; Clear BC 
1395			    add hl, bc         ; Increment HL to point to start of data block 
1395			    add hl, de         ; HL = HL + DE (total size) 
1395			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to start of data block 
1395			 
1395			    ; Save pointer to allocated block in HL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma5" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			malloc_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3           ; Size of management overhead 
1395			    add hl, bc         ; Move to the next block 
1395			    inc de             ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e            ; Load low byte of heap end address 
1395			    cp (hl)            ; Compare with low byte of current address 
1395			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1395			    ld a, d            ; Load high byte of heap end address 
1395			    cp 0               ; Check if it's zero (end of memory) 
1395			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, allocation failed 
1395			    xor a              ; Set result to NULL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma6" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			malloc_exit: 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma7" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			; Internal Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free_internal: 
1395			    ld de, (heap_start) ; Load start of heap into DE 
1395			    ld bc, 0            ; Initialize counter 
1395			 
1395			free_search_loop: 
1395			    ; Check if current block contains the pointer 
1395			    ld a, l             ; Load low byte of pointer 
1395			    cp (hl+1)           ; Compare with high byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			    ld a, h             ; Load high byte of pointer 
1395			    cp (hl+2)           ; Compare with low byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			 
1395			    ; Mark block as free 
1395			    ld (hl), 0          ; Set status byte to indicate free block 
1395			    ret                 ; Return 
1395			 
1395			free_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3            ; Size of management overhead 
1395			    add hl, bc          ; Move to the next block 
1395			    inc de              ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e             ; Load low byte of heap end address 
1395			    cp (hl)             ; Compare with low byte of current address 
1395			    jr nz, free_search_loop  ; If not equal, continue searching 
1395			    ld a, d             ; Load high byte of heap end address 
1395			    cp 0                ; Check if it's zero (end of memory) 
1395			    jr nz, free_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, pointer is not found in heap 
1395			    ret 
1395			 
1395			free_exit: 
1395			    ret                 ; Return 
1395			 
1395			; Define heap start and end addresses 
1395			;heap_start:    .dw 0xC000   ; Start of heap 
1395			;heap_end:      .dw 0xE000   ; End of heap 
1395			 
1395			endif 
1395			 
1395			 
1395			if MALLOC_1 
1395			 
1395			 
1395			 
1395			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1395			 
1395			;moved to firmware.asm 
1395			;heap_start        .equ  0x9000      ; Starting address of heap 
1395			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1395			 
1395			;      .org 0 
1395			;      jp    main 
1395			 
1395			 
1395			;      .org  0x100 
1395			;main: 
1395			;      ld    HL, 0x8100 
1395			;      ld    SP, HL 
1395			; 
1395			;      call  heap_init 
1395			; 
1395			;      ; Make some allocations 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9004 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9014 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9024 
1395			; 
1395			;      ; Free some allocations 
1395			;      ld    HL, 0x9014 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9004 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9024 
1395			;      call  free 
1395			; 
1395			; 
1395			;      halt 
1395			 
1395			 
1395			;------------------------------------------------------------------------------ 
1395			;     heap_init                                                               : 
1395			;                                                                             : 
1395			; Description                                                                 : 
1395			;     Initialise the heap and make it ready for malloc and free operations.   : 
1395			;                                                                             : 
1395			;     The heap is maintained as a linked list, starting with an initial       : 
1395			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1395			;     the first free block in the heap. Each block then points to the next    : 
1395			;     free block within the heap, and the free list ends at the first block   : 
1395			;     with a null pointer to the next free block.                             : 
1395			;                                                                             : 
1395			; Parameters                                                                  : 
1395			;     Inputs are compile-time only. Two defines which specify the starting    : 
1395			;     address of the heap and its size are required, along with a memory      : 
1395			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1395			;     principally stores a pointer to the first free block in the heap.       : 
1395			;                                                                             : 
1395			; Returns                                                                     : 
1395			;     Nothing                                                                 : 
1395			;------------------------------------------------------------------------------ 
1395			heap_init: 
1395 e5			      push  HL 
1396			 
1396			      ; Initialise free list struct 
1396 21 0e 80		      ld    HL, heap_start 
1399 22 0a 80		      ld    (free_list), HL 
139c 21 00 00		      ld    HL, 0 
139f 22 0c 80		      ld    (free_list+2), HL 
13a2			 
13a2			      ; Insert first free block at bottom of heap, consumes entire heap 
13a2 21 cd f0		      ld    HL, heap_start+heap_size-4 
13a5 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13a8 21 bf 70		      ld    HL, heap_size-4 
13ab 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13ae			 
13ae			      ; Insert end of free list block at top of heap - two null words will 
13ae			      ; terminate the free list 
13ae 21 00 00		      ld    HL, 0 
13b1 22 cf f0		      ld    (heap_start+heap_size-2), HL 
13b4 22 cd f0		      ld    (heap_start+heap_size-4), HL 
13b7			 
13b7 e1			      pop   HL 
13b8			 
13b8 c9			      ret 
13b9			 
13b9			 
13b9			;------------------------------------------------------------------------------ 
13b9			;     malloc                                                                  : 
13b9			;                                                                             : 
13b9			; Description                                                                 : 
13b9			;     Allocates the wanted space from the heap and returns the address of the : 
13b9			;     first useable byte of the allocation.                                   : 
13b9			;                                                                             : 
13b9			;     Allocations can happen in one of two ways:                              : 
13b9			;                                                                             : 
13b9			;     1. A free block may be found which is the exact size wanted. In this    : 
13b9			;        case the block is removed from the free list and retuedn to the      : 
13b9			;        caller.                                                              : 
13b9			;     2. A free block may be found which is larger than the size wanted. In   : 
13b9			;        this case, the larger block is split into two. The first portion of  : 
13b9			;        this block will become the requested space by the malloc call and    : 
13b9			;        is returned to the caller. The second portion becomes a new free     : 
13b9			;        block, and the free list is adjusted to maintain continuity via this : 
13b9			;        newly created block.                                                 : 
13b9			;                                                                             : 
13b9			;     malloc does not set any initial value in the allocated space, the       : 
13b9			;     caller is required to do this as required.                              : 
13b9			;                                                                             : 
13b9			;     This implementation of malloc uses the stack exclusively, and is        : 
13b9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13b9			;     advisable to disable interrupts before calling malloc, and recommended  : 
13b9			;     to avoid the use of malloc inside ISRs in general.                      : 
13b9			;                                                                             : 
13b9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13b9			;                                                                             : 
13b9			; Parameters                                                                  : 
13b9			;     HL  Number of bytes wanted                                              : 
13b9			;                                                                             : 
13b9			; Returns                                                                     : 
13b9			;     HL  Address of the first useable byte of the allocation                 : 
13b9			;                                                                             : 
13b9			; Flags                                                                       : 
13b9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13b9			;                                                                             : 
13b9			; Stack frame                                                                 : 
13b9			;       |             |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     BC      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     DE      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     IX      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |  prev_free  |                                                       : 
13b9			;   +4  +-------------+                                                       : 
13b9			;       |  this_free  |                                                       : 
13b9			;   +2  +-------------+                                                       : 
13b9			;       |  next_free  |                                                       : 
13b9			;   +0  +-------------+                                                       : 
13b9			;       |             |                                                       : 
13b9			;                                                                             : 
13b9			;------------------------------------------------------------------------------ 
13b9			 
13b9			 
13b9			;malloc: 
13b9			; 
13b9			;	SAVESP ON 1 
13b9			; 
13b9			;	call malloc_code 
13b9			; 
13b9			;	CHECKSP ON 1 
13b9			;	ret 
13b9			 
13b9			 
13b9			malloc: 
13b9 c5			      push  BC 
13ba d5			      push  DE 
13bb dd e5		      push  IX 
13bd			if DEBUG_FORTH_MALLOC_HIGH 
13bd			call malloc_guard_entry 
13bd			endif 
13bd			 
13bd					if DEBUG_FORTH_MALLOC 
13bd						DMARK "mal" 
13bd						CALLMONITOR 
13bd					endif 
13bd 7c			      ld    A, H                    ; Exit if no space requested 
13be b5			      or    L 
13bf ca 7e 14		      jp    Z, malloc_early_exit 
13c2			 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			; 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			 
13c2			 
13c2			 
13c2			 
13c2					if DEBUG_FORTH_MALLOC 
13c2						DMARK "maA" 
13c2						CALLMONITOR 
13c2					endif 
13c2			      ; Set up stack frame 
13c2 eb			      ex    DE, HL 
13c3 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13c6 39			      add   HL, SP 
13c7 f9			      ld    SP, HL 
13c8 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13cc dd 39		      add   IX, SP 
13ce			 
13ce			      ; Setup initial state 
13ce 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13d1 19			      add   HL, DE 
13d2			 
13d2 44			      ld    B, H                    ; Move want to BC 
13d3 4d			      ld    C, L 
13d4			 
13d4 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13d7 dd 75 04		      ld    (IX+4), L 
13da dd 74 05		      ld    (IX+5), H 
13dd			 
13dd 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13de 23			      inc   HL 
13df 56			      ld    D, (HL) 
13e0 dd 73 02		      ld    (IX+2), E 
13e3 dd 72 03		      ld    (IX+3), D 
13e6 eb			      ex    DE, HL                  ; this_free ptr into HL 
13e7			 
13e7					if DEBUG_FORTH_MALLOC 
13e7						DMARK "maB" 
13e7						CALLMONITOR 
13e7					endif 
13e7			      ; Loop through free block list to find some space 
13e7			malloc_find_space: 
13e7 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13e8 23			      inc   HL 
13e9 56			      ld    D, (HL) 
13ea			 
13ea 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13eb b3			      or    E 
13ec ca 78 14		      jp    Z, malloc_no_space 
13ef			 
13ef dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13f2 dd 72 01		      ld    (IX+1), D 
13f5			 
13f5			      ; Does this block have enough space to make the allocation? 
13f5 23			      inc   HL                      ; Load free block size into DE 
13f6 5e			      ld    E, (HL) 
13f7 23			      inc   HL 
13f8 56			      ld    D, (HL) 
13f9			 
13f9 eb			      ex    DE, HL                  ; Check size of block against want 
13fa b7			      or    A                       ; Ensure carry flag clear 
13fb ed 42		      sbc   HL, BC 
13fd e5			      push  HL                      ; Store the result for later (new block size) 
13fe			 
13fe ca 4d 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1401 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1403			 
1403			      ; this_free block is not big enough, setup ptrs to test next free block 
1403 e1			      pop   HL                      ; Discard previous result 
1404			 
1404 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1407 dd 66 03		      ld    H, (IX+3) 
140a dd 75 04		      ld    (IX+4), L 
140d dd 74 05		      ld    (IX+5), H 
1410			 
1410 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1413 dd 66 01		      ld    H, (IX+1) 
1416 dd 75 02		      ld    (IX+2), L 
1419 dd 74 03		      ld    (IX+3), H 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "MA>" 
141c						CALLMONITOR 
141c					endif 
141c 18 c9		      jr    malloc_find_space 
141e			 
141e			      ; split a bigger block into two - requested size and remaining size 
141e			malloc_alloc_split: 
141e					if DEBUG_FORTH_MALLOC 
141e						DMARK "MAs" 
141e						CALLMONITOR 
141e					endif 
141e eb			      ex    DE, HL                  ; Calculate address of new free block 
141f 2b			      dec   HL 
1420 2b			      dec   HL 
1421 2b			      dec   HL 
1422 09			      add   HL, BC 
1423			 
1423			      ; Create a new block and point it at next_free 
1423 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1426 dd 56 01		      ld    D, (IX+1) 
1429			 
1429 73			      ld    (HL), E                 ; Store next_free ptr into new block 
142a 23			      inc   HL 
142b 72			      ld    (HL), D 
142c			 
142c d1			      pop   DE                      ; Store size of new block into new block 
142d 23			      inc   HL 
142e 73			      ld    (HL), E 
142f 23			      inc   HL 
1430 72			      ld    (HL), D 
1431			 
1431			      ; Update this_free ptr to point to new block 
1431 2b			      dec   HL 
1432 2b			      dec   HL 
1433 2b			      dec   HL 
1434			 
1434 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1437 dd 56 03		      ld    D, (IX+3) 
143a			 
143a dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
143d dd 74 03		      ld    (IX+3), H 
1440			 
1440			      ; Modify this_free block to be allocation 
1440 eb			      ex    DE, HL 
1441 af			      xor   A                       ; Null the next block ptr of allocated block 
1442 77			      ld    (HL), A 
1443 23			      inc   HL 
1444 77			      ld    (HL), A 
1445			 
1445 23			      inc   HL                      ; Store want size into allocated block 
1446 71			      ld    (HL), C 
1447 23			      inc   HL 
1448 70			      ld    (HL), B 
1449 23			      inc   HL 
144a e5			      push  HL                      ; Address of allocation to return 
144b			 
144b 18 19		      jr    malloc_update_links 
144d			 
144d			malloc_alloc_fit: 
144d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
144e			 
144e					if DEBUG_FORTH_MALLOC 
144e						DMARK "MAf" 
144e						CALLMONITOR 
144e					endif 
144e			      ; Modify this_free block to be allocation 
144e eb			      ex    DE, HL 
144f 2b			      dec   HL 
1450 2b			      dec   HL 
1451 2b			      dec   HL 
1452			 
1452 af			      xor   A                       ; Null the next block ptr of allocated block 
1453 77			      ld    (HL), A 
1454 23			      inc   HL 
1455 77			      ld    (HL), A 
1456			 
1456 23			      inc   HL                      ; Store address of allocation to return 
1457 23			      inc   HL 
1458 23			      inc   HL 
1459 e5			      push  HL 
145a			 
145a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
145a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
145d dd 66 01		      ld    H, (IX+1) 
1460			 
1460 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1463 dd 74 03		      ld    (IX+3), H 
1466			 
1466			 
1466			malloc_update_links: 
1466			      ; Update prev_free ptr to point to this_free 
1466 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1469 dd 66 05		      ld    H, (IX+5) 
146c			 
146c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
146f dd 56 03		      ld    D, (IX+3) 
1472			 
1472 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1473 23			      inc   HL 
1474 72			      ld    (HL), D 
1475			 
1475					if DEBUG_FORTH_MALLOC 
1475						DMARK "Mul" 
1475						CALLMONITOR 
1475					endif 
1475			      ; Clear the Z flag to indicate successful allocation 
1475 7a			      ld    A, D 
1476 b3			      or    E 
1477			 
1477 d1			      pop   DE                      ; Address of allocation 
1478					if DEBUG_FORTH_MALLOC 
1478						DMARK "MAu" 
1478						CALLMONITOR 
1478					endif 
1478			 
1478			malloc_no_space: 
1478 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
147b 39			      add   HL, SP 
147c f9			      ld    SP, HL 
147d			 
147d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAN" 
147e						CALLMONITOR 
147e					endif 
147e			 
147e			malloc_early_exit: 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAx" 
147e						CALLMONITOR 
147e					endif 
147e dd e1		      pop   IX 
1480 d1			      pop   DE 
1481 c1			      pop   BC 
1482			 
1482			if DEBUG_FORTH_MALLOC_HIGH 
1482			call malloc_guard_exit 
1482			call malloc_guard_zerolen 
1482			endif 
1482 c9			      ret 
1483			 
1483			 
1483			;------------------------------------------------------------------------------ 
1483			;     free                                                                    : 
1483			;                                                                             : 
1483			; Description                                                                 : 
1483			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1483			;     returned by malloc, otherwise the behaviour is undefined.               : 
1483			;                                                                             : 
1483			;     Where possible, directly adjacent free blocks will be merged together   : 
1483			;     into larger blocks to help ensure that the heap does not become         : 
1483			;     excessively fragmented.                                                 : 
1483			;                                                                             : 
1483			;     free does not clear or set any other value into the freed space, and    : 
1483			;     therefore its contents may be visible through subsequent malloc's. The  : 
1483			;     caller should clear the freed space as required.                        : 
1483			;                                                                             : 
1483			;     This implementation of free uses the stack exclusively, and is          : 
1483			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1483			;     advisable to disable interrupts before calling free, and recommended    : 
1483			;     to avoid the use of free inside ISRs in general.                        : 
1483			;                                                                             : 
1483			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1483			;                                                                             : 
1483			; Parameters                                                                  : 
1483			;     HL  Pointer to address of first byte of allocation to be freed          : 
1483			;                                                                             : 
1483			; Returns                                                                     : 
1483			;     Nothing                                                                 : 
1483			;                                                                             : 
1483			; Stack frame                                                                 : 
1483			;       |             |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     BC      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     DE      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     IX      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |  prev_free  |                                                       : 
1483			;   +2  +-------------+                                                       : 
1483			;       |  next_free  |                                                       : 
1483			;   +0  +-------------+                                                       : 
1483			;       |             |                                                       : 
1483			;                                                                             : 
1483			;------------------------------------------------------------------------------ 
1483			free: 
1483 c5			      push  BC 
1484 d5			      push  DE 
1485 dd e5		      push  IX 
1487			 
1487 7c			      ld    A, H                    ; Exit if ptr is null 
1488 b5			      or    L 
1489 ca 4d 15		      jp    Z, free_early_exit 
148c			 
148c			      ; Set up stack frame 
148c eb			      ex    DE, HL 
148d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1490 39			      add   HL, SP 
1491 f9			      ld    SP, HL 
1492 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1496 dd 39		      add   IX, SP 
1498			 
1498			      ; The address in HL points to the start of the useable allocated space, 
1498			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1498			      ; address of the block itself. 
1498 eb			      ex    DE, HL 
1499 11 fc ff		      ld    DE, -4 
149c 19			      add   HL, DE 
149d			 
149d			      ; An allocated block must have a null next block pointer in it 
149d 7e			      ld    A, (HL) 
149e 23			      inc   HL 
149f b6			      or    (HL) 
14a0 c2 48 15		      jp    NZ, free_done 
14a3			 
14a3 2b			      dec   HL 
14a4			 
14a4 44			      ld    B, H                    ; Copy HL to BC 
14a5 4d			      ld    C, L 
14a6			 
14a6			      ; Loop through the free list to find the first block with an address 
14a6			      ; higher than the block being freed 
14a6 21 0a 80		      ld    HL, free_list 
14a9			 
14a9			free_find_higher_block: 
14a9 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14aa 23			      inc   HL 
14ab 56			      ld    D, (HL) 
14ac 2b			      dec   HL 
14ad			 
14ad dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14b0 dd 72 01		      ld    (IX+1), D 
14b3 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14b6 dd 74 03		      ld    (IX+3), H 
14b9			 
14b9 78			      ld    A, B                    ; Check if DE is greater than BC 
14ba ba			      cp    D                       ; Compare MSB first 
14bb 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14bd 30 04		      jr    NC, free_find_higher_block_skip 
14bf 79			      ld    A, C 
14c0 bb			      cp    E                       ; Then compare LSB 
14c1 38 08		      jr    C, free_found_higher_block 
14c3			 
14c3			free_find_higher_block_skip: 
14c3 7a			      ld    A, D                    ; Reached the end of the free list? 
14c4 b3			      or    E 
14c5 ca 48 15		      jp    Z, free_done 
14c8			 
14c8 eb			      ex    DE, HL 
14c9			 
14c9 18 de		      jr    free_find_higher_block 
14cb			 
14cb			free_found_higher_block: 
14cb			      ; Insert freed block between prev and next free blocks 
14cb 71			      ld    (HL), C                 ; Point prev free block to freed block 
14cc 23			      inc   HL 
14cd 70			      ld    (HL), B 
14ce			 
14ce 60			      ld    H, B                    ; Point freed block at next free block 
14cf 69			      ld    L, C 
14d0 73			      ld    (HL), E 
14d1 23			      inc   HL 
14d2 72			      ld    (HL), D 
14d3			 
14d3			      ; Check if the freed block is adjacent to the next free block 
14d3 23			      inc   HL                      ; Load size of freed block into HL 
14d4 5e			      ld    E, (HL) 
14d5 23			      inc   HL 
14d6 56			      ld    D, (HL) 
14d7 eb			      ex    DE, HL 
14d8			 
14d8 09			      add   HL, BC                  ; Add addr of freed block and its size 
14d9			 
14d9 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14dc dd 56 01		      ld    D, (IX+1) 
14df			 
14df b7			      or    A                       ; Clear the carry flag 
14e0 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14e2 20 22		      jr    NZ, free_check_adjacent_to_prev 
14e4			 
14e4			      ; Freed block is adjacent to next, merge into one bigger block 
14e4 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14e5 5e			      ld    E, (HL) 
14e6 23			      inc   HL 
14e7 56			      ld    D, (HL) 
14e8 e5			      push  HL                      ; Save ptr to next block for later 
14e9			 
14e9 60			      ld    H, B                    ; Store ptr from next block into freed block 
14ea 69			      ld    L, C 
14eb 73			      ld    (HL), E 
14ec 23			      inc   HL 
14ed 72			      ld    (HL), D 
14ee			 
14ee e1			      pop   HL                      ; Restore ptr to next block 
14ef 23			      inc   HL                      ; Load size of next block into DE 
14f0 5e			      ld    E, (HL) 
14f1 23			      inc   HL 
14f2 56			      ld    D, (HL) 
14f3 d5			      push  DE                      ; Save next block size for later 
14f4			 
14f4 60			      ld    H, B                    ; Load size of freed block into HL 
14f5 69			      ld    L, C 
14f6 23			      inc   HL 
14f7 23			      inc   HL 
14f8 5e			      ld    E, (HL) 
14f9 23			      inc   HL 
14fa 56			      ld    D, (HL) 
14fb eb			      ex    DE, HL 
14fc			 
14fc d1			      pop   DE                      ; Restore size of next block 
14fd 19			      add   HL, DE                  ; Add sizes of both blocks 
14fe eb			      ex    DE, HL 
14ff			 
14ff 60			      ld    H, B                    ; Store new bigger size into freed block 
1500 69			      ld    L, C 
1501 23			      inc   HL 
1502 23			      inc   HL 
1503 73			      ld    (HL), E 
1504 23			      inc   HL 
1505 72			      ld    (HL), D 
1506			 
1506			free_check_adjacent_to_prev: 
1506			      ; Check if the freed block is adjacent to the prev free block 
1506 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1509 dd 66 03		      ld    H, (IX+3) 
150c			 
150c 23			      inc   HL                      ; Size of prev free block into DE 
150d 23			      inc   HL 
150e 5e			      ld    E, (HL) 
150f 23			      inc   HL 
1510 56			      ld    D, (HL) 
1511 2b			      dec   HL 
1512 2b			      dec   HL 
1513 2b			      dec   HL 
1514			 
1514 19			      add   HL, DE                  ; Add prev block addr and size 
1515			 
1515 b7			      or    A                       ; Clear the carry flag 
1516 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1518 20 2e		      jr    NZ, free_done 
151a			 
151a			      ; Freed block is adjacent to prev, merge into one bigger block 
151a 60			      ld    H, B                    ; Load next ptr from freed block into DE 
151b 69			      ld    L, C 
151c 5e			      ld    E, (HL) 
151d 23			      inc   HL 
151e 56			      ld    D, (HL) 
151f e5			      push  HL                      ; Save freed block ptr for later 
1520			 
1520 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1523 dd 66 03		      ld    H, (IX+3) 
1526 73			      ld    (HL), E 
1527 23			      inc   HL 
1528 72			      ld    (HL), D 
1529			 
1529 e1			      pop   HL                      ; Restore freed block ptr 
152a 23			      inc   HL                      ; Load size of freed block into DE 
152b 5e			      ld    E, (HL) 
152c 23			      inc   HL 
152d 56			      ld    D, (HL) 
152e d5			      push  DE                      ; Save freed block size for later 
152f			 
152f dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1532 dd 66 03		      ld    H, (IX+3) 
1535 23			      inc   HL 
1536 23			      inc   HL 
1537 5e			      ld    E, (HL) 
1538 23			      inc   HL 
1539 56			      ld    D, (HL) 
153a			 
153a e1			      pop   HL                      ; Add sizes of both blocks 
153b 19			      add   HL, DE 
153c eb			      ex    DE, HL 
153d			 
153d dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1540 dd 66 03		      ld    H, (IX+3) 
1543 23			      inc   HL 
1544 23			      inc   HL 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548			free_done: 
1548 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
154b 39			      add   HL, SP 
154c f9			      ld    SP, HL 
154d			 
154d			free_early_exit: 
154d dd e1		      pop   IX 
154f d1			      pop   DE 
1550 c1			      pop   BC 
1551			 
1551 c9			      ret 
1552			 
1552			; moved to firmware.asm 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			;                  .dw   0 
1552			 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_3 
1552			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1552			;heap_start        .equ  0x9000      ; Starting address of heap 
1552			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1552			; 
1552			 ;     .org 0 
1552			  ;    jp    main 
1552			; 
1552			; 
1552			 ;     .org  0x100 
1552			;main: 
1552			 ;     ld    HL, 0x8100 
1552			  ;    ld    SP, HL 
1552			; 
1552			;      call  heap_init 
1552			 
1552			      ; Make some allocations 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9004 
1552			; 
1552			 ;     ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9014 
1552			 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9024 
1552			 
1552			      ; Free some allocations 
1552			;      ld    HL, 0x9014 
1552			;      call  free 
1552			 
1552			;      ld    HL, 0x9004 
1552			;      call  free 
1552			; 
1552			;      ld    HL, 0x9024 
1552			;      call  free 
1552			 
1552			 
1552			 ;     halt 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     heap_init                                                               : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Initialise the heap and make it ready for malloc and free operations.   : 
1552			;                                                                             : 
1552			;     The heap is maintained as a linked list, starting with an initial       : 
1552			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1552			;     the first free block in the heap. Each block then points to the next    : 
1552			;     free block within the heap, and the free list ends at the first block   : 
1552			;     with a null pointer to the next free block.                             : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     Inputs are compile-time only. Two defines which specify the starting    : 
1552			;     address of the heap and its size are required, along with a memory      : 
1552			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1552			;     principally stores a pointer to the first free block in the heap.       : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;------------------------------------------------------------------------------ 
1552			heap_init: 
1552			      push  HL 
1552			 
1552			      ; Initialise free list struct 
1552			      ld    HL, heap_start 
1552			      ld    (free_list), HL 
1552			      ld    HL, 0 
1552			      ld    (free_list+2), HL 
1552			 
1552			      ; Insert first free block at bottom of heap, consumes entire heap 
1552			      ld    HL, heap_start+heap_size-4 
1552			      ld    (heap_start), HL        ; Next block (end of free list) 
1552			      ld    HL, heap_size-4 
1552			      ld    (heap_start+2), HL      ; Block size 
1552			 
1552			      ; Insert end of free list block at top of heap - two null words will 
1552			      ; terminate the free list 
1552			      ld    HL, 0 
1552			      ld    (heap_start+heap_size-2), HL 
1552			      ld    (heap_start+heap_size-4), HL 
1552			 
1552			      pop   HL 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     malloc                                                                  : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Allocates the wanted space from the heap and returns the address of the : 
1552			;     first useable byte of the allocation.                                   : 
1552			;                                                                             : 
1552			;     Allocations can happen in one of two ways:                              : 
1552			;                                                                             : 
1552			;     1. A free block may be found which is the exact size wanted. In this    : 
1552			;        case the block is removed from the free list and retuedn to the      : 
1552			;        caller.                                                              : 
1552			;     2. A free block may be found which is larger than the size wanted. In   : 
1552			;        this case, the larger block is split into two. The first portion of  : 
1552			;        this block will become the requested space by the malloc call and    : 
1552			;        is returned to the caller. The second portion becomes a new free     : 
1552			;        block, and the free list is adjusted to maintain continuity via this : 
1552			;        newly created block.                                                 : 
1552			;                                                                             : 
1552			;     malloc does not set any initial value in the allocated space, the       : 
1552			;     caller is required to do this as required.                              : 
1552			;                                                                             : 
1552			;     This implementation of malloc uses the stack exclusively, and is        : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling malloc, and recommended  : 
1552			;     to avoid the use of malloc inside ISRs in general.                      : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Number of bytes wanted                                              : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     HL  Address of the first useable byte of the allocation                 : 
1552			;                                                                             : 
1552			; Flags                                                                       : 
1552			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +4  +-------------+                                                       : 
1552			;       |  this_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			malloc: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if no space requested 
1552			      or    L 
1552			      jp    Z, malloc_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; Setup initial state 
1552			      ld    HL, 4                   ; want must also include space used by block struct 
1552			      add   HL, DE 
1552			 
1552			      ld    B, H                    ; Move want to BC 
1552			      ld    C, L 
1552			 
1552			      ld    HL, free_list           ; Store prev_free ptr to stack 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    E, (HL)                 ; Store this_free ptr to stack 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ld    (IX+2), E 
1552			      ld    (IX+3), D 
1552			      ex    DE, HL                  ; this_free ptr into HL 
1552			 
1552			      ; Loop through free block list to find some space 
1552			malloc_find_space: 
1552			      ld    E, (HL)                 ; Load next_free ptr into DE 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1552			      or    E 
1552			      jp    Z, malloc_no_space 
1552			 
1552			      ld    (IX+0), E               ; Store next_free ptr to stack 
1552			      ld    (IX+1), D 
1552			 
1552			      ; Does this block have enough space to make the allocation? 
1552			      inc   HL                      ; Load free block size into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ex    DE, HL                  ; Check size of block against want 
1552			      or    A                       ; Ensure carry flag clear 
1552			      sbc   HL, BC 
1552			      push  HL                      ; Store the result for later (new block size) 
1552			 
1552			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1552			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1552			 
1552			      ; this_free block is not big enough, setup ptrs to test next free block 
1552			      pop   HL                      ; Discard previous result 
1552			 
1552			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1552			      ld    H, (IX+3) 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1552			      ld    H, (IX+1) 
1552			      ld    (IX+2), L 
1552			      ld    (IX+3), H 
1552			 
1552			      jr    malloc_find_space 
1552			 
1552			      ; split a bigger block into two - requested size and remaining size 
1552			malloc_alloc_split: 
1552			      ex    DE, HL                  ; Calculate address of new free block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      add   HL, BC 
1552			 
1552			      ; Create a new block and point it at next_free 
1552			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      ld    (HL), E                 ; Store next_free ptr into new block 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   DE                      ; Store size of new block into new block 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Update this_free ptr to point to new block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1552			      ld    (IX+3), H 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store want size into allocated block 
1552			      ld    (HL), C 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			      inc   HL 
1552			      push  HL                      ; Address of allocation to return 
1552			 
1552			      jr    malloc_update_links 
1552			 
1552			malloc_alloc_fit: 
1552			      pop   HL                      ; Dont need new block size, want is exact fit 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store address of allocation to return 
1552			      inc   HL 
1552			      inc   HL 
1552			      push  HL 
1552			 
1552			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1552			      ld    L, (IX+0)               ; next_free to HL 
1552			      ld    H, (IX+1) 
1552			 
1552			      ld    (IX+2), L               ; HL to this_free 
1552			      ld    (IX+3), H 
1552			 
1552			 
1552			malloc_update_links: 
1552			      ; Update prev_free ptr to point to this_free 
1552			      ld    L, (IX+4)               ; prev_free ptr to HL 
1552			      ld    H, (IX+5) 
1552			 
1552			      ld    E, (IX+2)               ; this_free ptr to DE 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (HL), E                 ; this_free ptr into prev_free 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Clear the Z flag to indicate successful allocation 
1552			      ld    A, D 
1552			      or    E 
1552			 
1552			      pop   DE                      ; Address of allocation 
1552			 
1552			malloc_no_space: 
1552			      ld    HL, 6                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			      ex    DE, HL                  ; Alloc addr into HL for return 
1552			 
1552			malloc_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     free                                                                    : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1552			;     returned by malloc, otherwise the behaviour is undefined.               : 
1552			;                                                                             : 
1552			;     Where possible, directly adjacent free blocks will be merged together   : 
1552			;     into larger blocks to help ensure that the heap does not become         : 
1552			;     excessively fragmented.                                                 : 
1552			;                                                                             : 
1552			;     free does not clear or set any other value into the freed space, and    : 
1552			;     therefore its contents may be visible through subsequent malloc's. The  : 
1552			;     caller should clear the freed space as required.                        : 
1552			;                                                                             : 
1552			;     This implementation of free uses the stack exclusively, and is          : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling free, and recommended    : 
1552			;     to avoid the use of free inside ISRs in general.                        : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Pointer to address of first byte of allocation to be freed          : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			free: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if ptr is null 
1552			      or    L 
1552			      jp    Z, free_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; The address in HL points to the start of the useable allocated space, 
1552			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1552			      ; address of the block itself. 
1552			      ex    DE, HL 
1552			      ld    DE, -4 
1552			      add   HL, DE 
1552			 
1552			      ; An allocated block must have a null next block pointer in it 
1552			      ld    A, (HL) 
1552			      inc   HL 
1552			      or    (HL) 
1552			      jp    NZ, free_done 
1552			 
1552			      dec   HL 
1552			 
1552			      ld    B, H                    ; Copy HL to BC 
1552			      ld    C, L 
1552			 
1552			      ; Loop through the free list to find the first block with an address 
1552			      ; higher than the block being freed 
1552			      ld    HL, free_list 
1552			 
1552			free_find_higher_block: 
1552			      ld    E, (HL)                 ; Load next ptr from free block 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			 
1552			      ld    (IX+0), E               ; Save ptr to next free block 
1552			      ld    (IX+1), D 
1552			      ld    (IX+2), L               ; Save ptr to prev free block 
1552			      ld    (IX+3), H 
1552			 
1552			      ld    A, B                    ; Check if DE is greater than BC 
1552			      cp    D                       ; Compare MSB first 
1552			      jr    Z, $+4                  ; MSB the same, compare LSB 
1552			      jr    NC, free_find_higher_block_skip 
1552			      ld    A, C 
1552			      cp    E                       ; Then compare LSB 
1552			      jr    C, free_found_higher_block 
1552			 
1552			free_find_higher_block_skip: 
1552			      ld    A, D                    ; Reached the end of the free list? 
1552			      or    E 
1552			      jp    Z, free_done 
1552			 
1552			      ex    DE, HL 
1552			 
1552			      jr    free_find_higher_block 
1552			 
1552			free_found_higher_block: 
1552			      ; Insert freed block between prev and next free blocks 
1552			      ld    (HL), C                 ; Point prev free block to freed block 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			 
1552			      ld    H, B                    ; Point freed block at next free block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Check if the freed block is adjacent to the next free block 
1552			      inc   HL                      ; Load size of freed block into HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      add   HL, BC                  ; Add addr of freed block and its size 
1552			 
1552			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_check_adjacent_to_prev 
1552			 
1552			      ; Freed block is adjacent to next, merge into one bigger block 
1552			      ex    DE, HL                  ; Load next ptr from next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save ptr to next block for later 
1552			 
1552			      ld    H, B                    ; Store ptr from next block into freed block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore ptr to next block 
1552			      inc   HL                      ; Load size of next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save next block size for later 
1552			 
1552			      ld    H, B                    ; Load size of freed block into HL 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      pop   DE                      ; Restore size of next block 
1552			      add   HL, DE                  ; Add sizes of both blocks 
1552			      ex    DE, HL 
1552			 
1552			      ld    H, B                    ; Store new bigger size into freed block 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_check_adjacent_to_prev: 
1552			      ; Check if the freed block is adjacent to the prev free block 
1552			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1552			      ld    H, (IX+3) 
1552			 
1552			      inc   HL                      ; Size of prev free block into DE 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      add   HL, DE                  ; Add prev block addr and size 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_done 
1552			 
1552			      ; Freed block is adjacent to prev, merge into one bigger block 
1552			      ld    H, B                    ; Load next ptr from freed block into DE 
1552			      ld    L, C 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save freed block ptr for later 
1552			 
1552			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1552			      ld    H, (IX+3) 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore freed block ptr 
1552			      inc   HL                      ; Load size of freed block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save freed block size for later 
1552			 
1552			      ld    L, (IX+2)               ; Load size of prev block into DE 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      pop   HL                      ; Add sizes of both blocks 
1552			      add   HL, DE 
1552			      ex    DE, HL 
1552			 
1552			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_done: 
1552			      ld    HL, 4                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			free_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;      .org 0x8000 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			 ;                 .dw   0 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_4 
1552			 
1552			; My memory allocation code. Very very simple.... 
1552			; allocate space under 250 chars 
1552			 
1552			heap_init: 
1552				; init start of heap as zero 
1552				;  
1552			 
1552				ld hl, heap_start 
1552				ld a, 0 
1552				ld (hl), a      ; empty block 
1552				inc hl 
1552				ld a, 0 
1552				ld (hl), a      ; length of block 
1552				; write end of list 
1552				inc hl 
1552				ld a,(hl) 
1552				inc hl 
1552				ld a,(hl) 
1552				 
1552			 
1552				; init some malloc vars 
1552			 
1552				ld hl, 0 
1552				ld (free_list), hl       ; store last malloc location 
1552			 
1552				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1552				ld a, 0 
1552				ld (hl), a 
1552			 
1552			 
1552				ld hl, heap_start 
1552				;  
1552				  
1552				ret 
1552			 
1552			 
1552			;    free block marker 
1552			;    requested size  
1552			;    pointer to next block 
1552			;    .... 
1552			;    next block marker 
1552			 
1552			 
1552			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1552			; 
1552			 
1552			 
1552			malloc:  
1552				push de 
1552				push bc 
1552				push af 
1552			 
1552				; hl space required 
1552				 
1552				ld c, l    ; hold space   (TODO only a max of 255) 
1552			 
1552			;	inc c     ; TODO BUG need to fix memory leak on push str 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			 
1552			 
1552			 
1552				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1552			 
1552				ld a, (free_list+3) 
1552				cp 0 
1552				jr z, .contheap 
1552			 
1552				ld hl, (free_list)     ; get last alloc 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mrs" 
1552						CALLMONITOR 
1552					endif 
1552				jr .startalloc 
1552			 
1552			.contheap: 
1552				ld hl, heap_start 
1552			 
1552			.startalloc: 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mym" 
1552						CALLMONITOR 
1552					endif 
1552			.findblock: 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmf" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552				ld a,(hl)  
1552				; if byte is zero then clear to use 
1552			 
1552				cp 0 
1552				jr z, .foundemptyblock 
1552			 
1552				; if byte is not clear 
1552				;     then byte is offset to next block 
1552			 
1552				inc hl 
1552				ld a, (hl) ; get size 
1552			.nextblock:	inc hl 
1552					ld e, (hl) 
1552					inc hl 
1552					ld d, (hl) 
1552					ex de, hl 
1552			;	inc hl  ; move past the store space 
1552			;	inc hl  ; move past zero index  
1552			 
1552				; TODO detect no more space 
1552			 
1552				push hl 
1552				ld de, heap_end 
1552				call cmp16 
1552				pop hl 
1552				jr nc, .nospace 
1552			 
1552				jr .findblock 
1552			 
1552			.nospace: ld hl, 0 
1552				jp .exit 
1552			 
1552			 
1552			.foundemptyblock:	 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mme" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; TODO has block enough space if reusing??? 
1552			 
1552				;  
1552			 
1552			; see if this block has been previously used 
1552				inc hl 
1552				ld a, (hl) 
1552				dec hl 
1552				cp 0 
1552				jr z, .newblock 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meR" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; no reusing previously allocated block 
1552			 
1552			; is it smaller than previously used? 
1552				 
1552				inc hl    ; move to size 
1552				ld a, c 
1552				sub (hl)        ; we want c < (hl) 
1552				dec hl    ; move back to marker 
1552			        jr z, .findblock 
1552			 
1552				; update with the new size which should be lower 
1552			 
1552			        ;inc  hl   ; negate next move. move back to size  
1552			 
1552			.newblock: 
1552				; need to be at marker here 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meN" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			 
1552				ld a, c 
1552			 
1552				ld (free_list+3), a	 ; flag resume from last malloc  
1552				ld (free_list), hl    ; save out last location 
1552			 
1552			 
1552				;inc a     ; space for length byte 
1552				ld (hl), a     ; save block in use marker 
1552			 
1552				inc hl   ; move to space marker 
1552				ld (hl), a    ; save new space 
1552			 
1552				inc hl   ; move to start of allocated area 
1552				 
1552			;	push hl     ; save where we are - 1  
1552			 
1552			;	inc hl  ; move past zero index  
1552				; skip space to set down new marker 
1552			 
1552				; provide some extra space for now 
1552			 
1552				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1552				inc a 
1552				inc a 
1552			 
1552				push hl   ; save where we are in the node block 
1552			 
1552				call addatohl 
1552			 
1552				; write linked list point 
1552			 
1552				pop de     ; get our node position 
1552				ex de, hl 
1552			 
1552				ld (hl), e 
1552				inc hl 
1552				ld (hl), d 
1552			 
1552				inc hl 
1552			 
1552				; now at start of allocated data so save pointer 
1552			 
1552				push hl 
1552			 
1552				; jump to position of next node and setup empty header in DE 
1552			 
1552				ex de, hl 
1552			 
1552			;	inc hl ; move past end of block 
1552			 
1552				ld a, 0 
1552				ld (hl), a   ; empty marker 
1552				inc hl 
1552				ld (hl), a   ; size 
1552				inc hl  
1552				ld (hl), a   ; ptr 
1552				inc hl 
1552				ld (hl), a   ; ptr 
1552			 
1552			 
1552				pop hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmr" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			.exit: 
1552				pop af 
1552				pop bc 
1552				pop de  
1552				ret 
1552			 
1552			 
1552			 
1552			 
1552			free:  
1552				push hl 
1552				push af 
1552				; get address in hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "fre" 
1552						CALLMONITOR 
1552					endif 
1552				; data is at hl - move to block count 
1552				dec hl 
1552				dec hl    ; get past pointer 
1552				dec hl 
1552			 
1552				ld a, (hl)    ; need this for a validation check 
1552			 
1552				dec hl    ; move to block marker 
1552			 
1552				; now check that the block count and block marker are the same  
1552			        ; this checks that we are on a malloc node and not random memory 
1552			        ; OK a faint chance this could be a problem but rare - famous last words! 
1552			 
1552				ld c, a 
1552				ld a, (hl)    
1552			 
1552				cp c 
1552				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1552			 
1552				; yes good chance we are on a malloc node 
1552			 
1552				ld a, 0      
1552				ld (hl), a   ; mark as free 
1552			 
1552				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1552			 
1552			.freeignore:  
1552			 
1552				pop af 
1552				pop hl 
1552			 
1552				ret 
1552			 
1552			 
1552			 
1552			endif 
1552			 
1552			; eof 
# End of file firmware_memory.asm
1552			  
1552			; device C  
1552			; Now handled by SPI  
1552			;if SOUND_ENABLE  
1552			;	include "firmware_sound.asm"  
1552			;endif  
1552			  
1552			include "firmware_diags.asm"  
1552			; Hardware diags menu 
1552			 
1552			 
1552			config: 
1552			 
1552 3e 00			ld a, 0 
1554 21 7d 15			ld hl, .configmn 
1557 cd db 0d			call menu 
155a			 
155a fe 00			cp 0 
155c c8				ret z 
155d			 
155d			;	cp 1 
155d			;	call z, .savetostore 
155d			 
155d fe 01			cp 1 
155f			if STARTUP_V1 
155f				call z, .selautoload 
155f			endif 
155f			 
155f			if STARTUP_V2 
155f cc 8b 15			call z, .enautoload 
1562			endif 
1562 fe 02			cp 2 
1564 cc a2 15			call z, .disautoload 
1567			;	cp 3 
1567			;	call z, .selbank 
1567 fe 03			cp 3 
1569 cc 0b 18			call z, .debug_tog 
156c fe 04			cp 4 
156e cc 59 19			call z, .bpsgo 
1571 fe 05			cp 5 
1573 cc 34 18			call z, hardware_diags 
1576			if STARTUP_V2 
1576 fe 06			cp 6 
1578 cc ce 15			call z, create_startup 
157b			endif 
157b 18 d5			jr config 
157d			 
157d			.configmn: 
157d			;	dw prom_c3 
157d 47 1b			dw prom_c2 
157f 5d 1b			dw prom_c2a 
1581			;	dw prom_c2b 
1581			;	dw prom_c4 
1581 d4 1b			dw prom_m4 
1583 ef 1b			dw prom_m4b 
1585 f7 1b			dw prom_c1 
1587			if STARTUP_V2 
1587 06 1c			dw prom_c9 
1589			endif 
1589 00 00			dw 0 
158b				 
158b			 
158b			if STARTUP_V2 
158b			.enautoload: 
158b				if STORAGE_SE 
158b 3e fe			ld a, $fe      ; bit 0 clear 
158d 32 95 f9			ld (spi_device), a 
1590			 
1590 cd 25 05			call storage_get_block_0 
1593			 
1593 3e 01			ld a, 1 
1595 32 d0 f9			ld (store_page+STORE_0_AUTOFILE), a 
1598			 
1598 21 00 00				ld hl, 0 
159b 11 af f9				ld de, store_page 
159e cd d9 04			call storage_write_block	 ; save update 
15a1				else 
15a1			 
15a1				ld hl, prom_notav 
15a1				ld de, prom_empty 
15a1				call info_panel 
15a1				endif 
15a1			 
15a1			 
15a1 c9				ret 
15a2			endif 
15a2			 
15a2			.disautoload: 
15a2				if STORAGE_SE 
15a2 3e fe			ld a, $fe      ; bit 0 clear 
15a4 32 95 f9			ld (spi_device), a 
15a7			 
15a7 cd 25 05			call storage_get_block_0 
15aa			 
15aa 3e 00			ld a, 0 
15ac 32 d0 f9			ld (store_page+STORE_0_AUTOFILE), a 
15af			 
15af 21 00 00				ld hl, 0 
15b2 11 af f9				ld de, store_page 
15b5 cd d9 04			call storage_write_block	 ; save update 
15b8				else 
15b8			 
15b8				ld hl, prom_notav 
15b8				ld de, prom_empty 
15b8				call info_panel 
15b8				endif 
15b8			 
15b8			 
15b8 c9				ret 
15b9			 
15b9			if STARTUP_V1 
15b9			 
15b9			; Select auto start 
15b9			 
15b9			.selautoload: 
15b9			 
15b9				 
15b9				if STORAGE_SE 
15b9			 
15b9					call config_dir 
15b9				        ld hl, scratch 
15b9					ld a, 0 
15b9					call menu 
15b9			 
15b9					cp 0 
15b9					ret z 
15b9			 
15b9					dec a 
15b9			 
15b9			 
15b9					; locate menu option 
15b9			 
15b9					ld hl, scratch 
15b9					call table_lookup 
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALl" 
15b9						CALLMONITOR 
15b9					endif 
15b9					; with the pointer to the menu it, the byte following the zero term is the file id 
15b9			 
15b9					ld a, 0 
15b9					ld bc, 50   ; max of bytes to look at 
15b9					cpir  
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALb" 
15b9						CALLMONITOR 
15b9					endif 
15b9					;inc hl 
15b9			 
15b9					ld a, (hl)   ; file id 
15b9					 
15b9				        ; save bank and file ids 
15b9			 
15b9					push af 
15b9			 
15b9			; TODO need to save to block 0 on bank 1	 
15b9			 
15b9					call storage_get_block_0 
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "AL0" 
15b9						CALLMONITOR 
15b9					endif 
15b9					pop af 
15b9			 
15b9					ld (store_page+STORE_0_FILERUN),a 
15b9					 
15b9					; save bank id 
15b9			 
15b9					ld a,(spi_device) 
15b9					ld (store_page+STORE_0_BANKRUN),a 
15b9			 
15b9					; enable auto run of store file 
15b9			 
15b9					ld a, 1 
15b9					ld (store_page+STORE_0_AUTOFILE),a 
15b9			 
15b9					; save buffer 
15b9			 
15b9					ld hl, 0 
15b9					ld de, store_page 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALw" 
15b9						CALLMONITOR 
15b9					endif 
15b9				call storage_write_block	 ; save update 
15b9			  
15b9			 
15b9			 
15b9			 
15b9					ld hl, scratch 
15b9					call config_fdir 
15b9			 
15b9				else 
15b9			 
15b9				ld hl, prom_notav 
15b9				ld de, prom_empty 
15b9				call info_panel 
15b9			 
15b9				endif 
15b9				ret 
15b9			endif 
15b9			 
15b9			 
15b9			; Select storage bank 
15b9			 
15b9			.selbank: 
15b9			 
15b9			;	if STORAGE_SE 
15b9			;	else 
15b9			 
15b9 21 1b 1c			ld hl, prom_notav 
15bc 11 31 1c			ld de, prom_empty 
15bf cd 3b 0d			call info_panel 
15c2			;	endif 
15c2				 
15c2 c9				ret 
15c3			 
15c3			if STORAGE_SE 
15c3			 
15c3			.config_ldir:   
15c3				; Load storage bank labels into menu array 
15c3			 
15c3				 
15c3			 
15c3			 
15c3 c9				ret 
15c4			 
15c4			 
15c4			endif 
15c4			 
15c4			 
15c4			; Save user words to storage 
15c4			 
15c4			.savetostore: 
15c4			 
15c4			;	if STORAGE_SE 
15c4			; 
15c4			;		call config_dir 
15c4			;	        ld hl, scratch 
15c4			;		ld a, 0 
15c4			;		call menu 
15c4			;		 
15c4			;		ld hl, scratch 
15c4			;		call config_fdir 
15c4			; 
15c4			;	else 
15c4			 
15c4 21 1b 1c			ld hl, prom_notav 
15c7 11 31 1c			ld de, prom_empty 
15ca cd 3b 0d			call info_panel 
15cd			 
15cd			;	endif 
15cd			 
15cd c9				ret 
15ce			 
15ce			if STARTUP_V2 
15ce			 
15ce			create_startup: 
15ce			 
15ce 3e 00			ld a, 0 
15d0 21 30 17			ld hl, .crstart 
15d3 cd db 0d			call menu 
15d6			 
15d6 fe 00			cp 0 
15d8 c8				ret z 
15d9			 
15d9 fe 01			cp 1 
15db cc 17 16			call z, .genlsword 
15de fe 02			cp 2 
15e0 cc 21 16			call z, .genedword 
15e3			 
15e3 fe 03			cp 3 
15e5 cc 2b 16			call z, .gendemword 
15e8			 
15e8 fe 04			cp 4 
15ea cc 35 16			call z, .genutlword 
15ed fe 05			cp 5 
15ef cc 3f 16			call z, .genspiword 
15f2 fe 06			cp 6 
15f4 cc 49 16			call z, .genkeyword 
15f7 fe 07			cp 7 
15f9 cc 0d 16			call z, .gensoundword 
15fc fe 07			cp 7 
15fe cc 03 16			call z, .genhwword 
1601 18 cb			jr create_startup 
1603			 
1603			.genhwword: 
1603 21 be 1b			ld hl, crs_hw 
1606 11 96 16			ld de, .hwworddef 
1609 cd 53 16			call .genfile 
160c c9				ret 
160d			.gensoundword: 
160d 21 b2 1b			ld hl, crs_sound 
1610 11 a4 16			ld de, .soundworddef 
1613 cd 53 16			call .genfile 
1616 c9				ret 
1617			.genlsword: 
1617 21 74 1b			ld hl, crs_s1 
161a 11 c8 16			ld de, .lsworddef 
161d cd 53 16			call .genfile 
1620 c9				ret 
1621			 
1621			.genedword: 
1621 11 cc 16			ld de, .edworddef 
1624 21 7d 1b			ld hl, crs_s2 
1627 cd 53 16			call .genfile 
162a c9				ret 
162b			 
162b			.gendemword: 
162b 11 d4 16			ld de, .demoworddef 
162e 21 86 1b			ld hl, crs_s3 
1631 cd 53 16			call .genfile 
1634 c9				ret 
1635			 
1635			.genutlword: 
1635 21 92 1b			ld hl, crs_s4 
1638 11 b8 16			ld de, .utilwordef 
163b cd 53 16			call .genfile 
163e c9				ret 
163f			.genspiword: 
163f 21 99 1b			ld hl, crs_s5 
1642 11 f6 16			ld de, .spiworddef 
1645 cd 53 16			call .genfile 
1648 c9				ret 
1649			.genkeyword: 
1649 21 a3 1b			ld hl, crs_s6 
164c 11 04 17			ld de, .keyworddef 
164f cd 53 16			call .genfile 
1652 c9				ret 
1653			 
1653			; hl - points to file name 
1653			; de - points to strings to add to file 
1653			 
1653			.genfile: 
1653 e5				push hl 
1654 d5				push de 
1655			 
1655 cd aa 0d			call clear_display 
1658 3e 00			ld a, display_row_1 
165a 11 85 16			ld de, .genfiletxt 
165d cd bd 0d			call str_at_display 
1660 cd cd 0d			call update_display 
1663			 
1663 d1				pop de 
1664 e1				pop hl 
1665			 
1665			 
1665 d5				push de 
1666 cd 77 08			call storage_create 
1669				; id in hl 
1669 d1				pop de   ; table of strings to add 
166a			 
166a			.genloop: 
166a			 
166a e5				push hl ; save id for next time around 
166b d5				push de ; save de for next time around 
166c			 
166c eb				ex de, hl 
166d cd b9 23			call loadwordinhl 
1670 eb				ex de, hl 
1671			 
1671				; need hl to be the id 
1671				; need de to be the string ptr 
1671				 
1671 cd 64 0b			call storage_append 
1674			 
1674 d1				pop de 
1675 e1				pop hl 
1676			 
1676 13				inc de 
1677 13				inc de 
1678			 
1678 1a				ld a,(de) 
1679 fe 00			cp 0 
167b 20 ed			jr nz, .genloop 
167d 13				inc de 
167e 1a				ld a, (de) 
167f 1b				dec de 
1680 fe 00			cp 0 
1682 20 e6			jr nz, .genloop	 
1684			 
1684 c9				ret 
1685			 
1685 .. 00		.genfiletxt:  db "Creating file...",0 
1696			 
1696			.hwworddef: 
1696 ca 65			dw test5 
1698 02 66			dw test6 
169a 3a 66			dw test7 
169c 4e 66			dw test8 
169e 7a 66			dw test9 
16a0 90 66			dw test10 
16a2 00 00			dw 0 
16a4			 
16a4			.soundworddef: 
16a4 b5 66			dw sound1 
16a6 d9 66			dw sound2 
16a8 09 67			dw sound3 
16aa 2e 67			dw sound4 
16ac 3b 67			dw sound5 
16ae 48 67			dw sound6 
16b0 55 67			dw sound7 
16b2 62 67			dw sound8 
16b4 7a 67			dw sound9 
16b6 00 00			dw 0 
16b8			 
16b8			.utilwordef: 
16b8 03 64			dw strncpy 
16ba de 63			dw type 
16bc aa 63			dw clrstack 
16be 63 63			dw longread 
16c0 64 64			dw start1 
16c2 74 64			dw start2 
16c4			; duplicated 
16c4			;	dw start3b 
16c4			;	dw start3c 
16c4 60 65			dw list 
16c6 00 00			dw 0 
16c8			 
16c8			.lsworddef: 
16c8 85 64			dw start3b 
16ca 00 00			dw 0 
16cc			 
16cc			.edworddef: 
16cc c2 5f			dw edit1 
16ce e3 5f			dw edit2 
16d0 18 60			dw edit3 
16d2 00 00			dw 0 
16d4			 
16d4			.demoworddef: 
16d4 91 67			dw game1 
16d6 a2 67			dw game1a 
16d8 04 68			dw game1b 
16da 39 68			dw game1c 
16dc 6f 68			dw game1d 
16de a0 68			dw game1s 
16e0 b4 68			dw game1t 
16e2 c9 68			dw game1f 
16e4 fd 68			dw game1z 
16e6 41 69			dw game1zz 
16e8 aa 69			dw ssv2 
16ea e0 69			dw ssv3 
16ec fc 69			dw ssv4 
16ee 18 6a			dw ssv5 
16f0 31 6a			dw ssv1 
16f2 79 6a			dw ssv1cpm	 
16f4			;	dw game2b 
16f4			;	dw game2bf 
16f4			;	dw game2mba 
16f4			;	dw game2mbas	 
16f4			;	dw game2mbht 
16f4			;	dw game2mbms 
16f4			;	dw game2mb 
16f4			;	dw game3w 
16f4			;	dw game3p 
16f4			;	dw game3sc 
16f4			;	dw game3vsi 
16f4			;	dw game3vs 
16f4 00 00			dw 0 
16f6			 
16f6			 
16f6			.spiworddef: 
16f6			 
16f6 50 60		    dw spi1 
16f8 a9 60		    dw spi2 
16fa dd 60		    dw spi2b 
16fc 61 61		    dw spi3 
16fe 0b 61		    dw spi4 
1700 34 61		    dw spi5 
1702			;    dw spi6 
1702			;    dw spi7 
1702			 
1702			;    dw spi8 
1702			;    dw spi9 
1702			;    dw spi10 
1702 00 00		    dw 0 
1704			 
1704			.keyworddef: 
1704			 
1704 d0 6a			dw keyup 
1706 de 6a			dw keydown 
1708 ee 6a			dw keyleft 
170a fe 6a			dw keyright 
170c 0f 6b			dw 	keyf1 
170e 1d 6b			dw keyf2 
1710 2b 6b			dw keyf3 
1712 39 6b			dw keyf4 
1714 47 6b			dw keyf5 
1716 55 6b			dw keyf6 
1718 63 6b			dw keyf7 
171a 71 6b			dw keyf8 
171c 7f 6b			dw keyf9 
171e 8d 6b			dw keyf10 
1720 9c 6b			dw keyf11 
1722 ab 6b			dw keyf12 
1724 ba 6b			dw keytab 
1726 c9 6b			dw keycr 
1728 d7 6b			dw keyhome 
172a e7 6b			dw keyend 
172c f6 6b			dw keybs 
172e 00 00			dw 0 
1730			 
1730			.crstart: 
1730 74 1b			dw crs_s1 
1732 7d 1b			dw crs_s2 
1734 86 1b			dw crs_s3 
1736 92 1b			dw crs_s4 
1738 99 1b			dw crs_s5 
173a a3 1b			dw crs_s6 
173c b2 1b			dw crs_sound 
173e be 1b			dw crs_hw 
1740 00 00			dw 0 
1742			 
1742			endif 
1742			 
1742			 
1742			if STORAGE_SE 
1742			 
1742			config_fdir: 
1742				; using the scratch dir go through and release the memory allocated for each string 
1742				 
1742 21 f6 f0			ld hl, scratch 
1745 5e			.cfdir:	ld e,(hl) 
1746 23				inc hl 
1747 56				ld d,(hl) 
1748 23				inc hl 
1749			 
1749 eb				ex de, hl 
174a cd 07 10			call ishlzero 
174d c8				ret z     ; return on null pointer 
174e cd 83 14			call free 
1751 eb				ex de, hl 
1752 18 f1			jr .cfdir 
1754			 
1754			 
1754 c9				ret 
1755			 
1755			 
1755			config_dir: 
1755			 
1755				; for the config menus that need to build a directory of storage call this routine 
1755				; it will construct a menu in scratch to pass to menu 
1755			 
1755				; open storage device 
1755			 
1755				; execute DIR to build a list of files and their ids into scratch in menu format 
1755				; once the menu has finished then will need to call config_fdir to release the strings 
1755				 
1755				; c = number items 
1755			 
1755				 
1755 cd 25 05			call storage_get_block_0 
1758			 
1758 21 af f9			ld hl, store_page     ; get current id count 
175b 46				ld b, (hl) 
175c 0e 00			ld c, 0    ; count of files   
175e			 
175e			 
175e 21 f6 f0			ld hl, scratch 
1761 22 a6 f9			ld (store_tmp2), hl    ; location to poke strings 
1764			 
1764				; check for empty drive 
1764			 
1764 3e 00			ld a, 0 
1766 b8				cp b 
1767 ca 01 18			jp z, .dirdone 
176a			 
176a				 
176a					if DEBUG_FORTH_WORDS 
176a						DMARK "Cdc" 
176a f5				push af  
176b 3a 7f 17			ld a, (.dmark)  
176e 32 a0 fd			ld (debug_mark),a  
1771 3a 80 17			ld a, (.dmark+1)  
1774 32 a1 fd			ld (debug_mark+1),a  
1777 3a 81 17			ld a, (.dmark+2)  
177a 32 a2 fd			ld (debug_mark+2),a  
177d 18 03			jr .pastdmark  
177f ..			.dmark: db "Cdc"  
1782 f1			.pastdmark: pop af  
1783			endm  
# End of macro DMARK
1783						CALLMONITOR 
1783 cd aa fd			call debug_vector  
1786				endm  
# End of macro CALLMONITOR
1786					endif 
1786			 
1786			 
1786			.diritem:	 
1786 c5				push bc 
1787				; for each of the current ids do a search for them and if found push to stack 
1787			 
1787 21 40 00				ld hl, STORE_BLOCK_PHY 
178a 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
178c 58					ld e,b 
178d			 
178d cd a7 07				call storage_findnextid 
1790			 
1790			 
1790					; if found hl will be non zero 
1790			 
1790 cd 07 10				call ishlzero 
1793 28 69				jr z, .dirnotfound 
1795			 
1795					; increase count 
1795			 
1795 c1					pop bc	 
1796 0c					inc c 
1797 c5					push bc 
1798					 
1798			 
1798					; get file header and push the file name 
1798			 
1798 11 af f9				ld de, store_page 
179b cd 74 04				call storage_read_block 
179e			 
179e					; push file id to stack 
179e				 
179e 3a af f9				ld a, (store_page) 
17a1 26 00				ld h, 0 
17a3 6f					ld l, a 
17a4			 
17a4					;call forth_push_numhl 
17a4					; TODO store id 
17a4			 
17a4 e5					push hl 
17a5			 
17a5					; push extent count to stack  
17a5				 
17a5 21 b2 f9				ld hl, store_page+3 
17a8			 
17a8					; get file name length 
17a8			 
17a8 cd 44 13				call strlenz   
17ab			 
17ab 23					inc hl   ; cover zero term 
17ac 23					inc hl  ; stick the id at the end of the area 
17ad			 
17ad e5					push hl 
17ae c1					pop bc    ; move length to bc 
17af			 
17af cd b9 13				call malloc 
17b2			 
17b2					; TODO save malloc area to scratch 
17b2			 
17b2 eb					ex de, hl 
17b3 2a a6 f9				ld hl, (store_tmp2) 
17b6 73					ld (hl), e 
17b7 23					inc hl 
17b8 72					ld (hl), d 
17b9 23					inc hl 
17ba 22 a6 f9				ld (store_tmp2), hl 
17bd			 
17bd					 
17bd			 
17bd					;pop hl   ; get source 
17bd			;		ex de, hl    ; swap aronund	 
17bd			 
17bd 21 b2 f9				ld hl, store_page+3 
17c0					if DEBUG_FORTH_WORDS 
17c0						DMARK "CFd" 
17c0 f5				push af  
17c1 3a d5 17			ld a, (.dmark)  
17c4 32 a0 fd			ld (debug_mark),a  
17c7 3a d6 17			ld a, (.dmark+1)  
17ca 32 a1 fd			ld (debug_mark+1),a  
17cd 3a d7 17			ld a, (.dmark+2)  
17d0 32 a2 fd			ld (debug_mark+2),a  
17d3 18 03			jr .pastdmark  
17d5 ..			.dmark: db "CFd"  
17d8 f1			.pastdmark: pop af  
17d9			endm  
# End of macro DMARK
17d9						CALLMONITOR 
17d9 cd aa fd			call debug_vector  
17dc				endm  
# End of macro CALLMONITOR
17dc					endif 
17dc ed b0				ldir 
17de			 
17de					; de is past string, move back one and store id 
17de					 
17de 1b					dec de 
17df			 
17df					; store file id 
17df			 
17df e1					pop hl 
17e0 eb					ex de,hl 
17e1 73					ld (hl), e 
17e2			 
17e2					if DEBUG_FORTH_WORDS 
17e2						DMARK "Cdi" 
17e2 f5				push af  
17e3 3a f7 17			ld a, (.dmark)  
17e6 32 a0 fd			ld (debug_mark),a  
17e9 3a f8 17			ld a, (.dmark+1)  
17ec 32 a1 fd			ld (debug_mark+1),a  
17ef 3a f9 17			ld a, (.dmark+2)  
17f2 32 a2 fd			ld (debug_mark+2),a  
17f5 18 03			jr .pastdmark  
17f7 ..			.dmark: db "Cdi"  
17fa f1			.pastdmark: pop af  
17fb			endm  
# End of macro DMARK
17fb						CALLMONITOR 
17fb cd aa fd			call debug_vector  
17fe				endm  
# End of macro CALLMONITOR
17fe					endif 
17fe					 
17fe			.dirnotfound: 
17fe c1					pop bc     
17ff 10 85				djnz .diritem 
1801				 
1801			.dirdone:	 
1801			 
1801 3e 00				ld a, 0 
1803 2a a6 f9				ld hl, (store_tmp2) 
1806 77					ld (hl), a 
1807 23					inc hl 
1808 77					ld (hl), a 
1809 23					inc hl 
180a					; push a count of the dir items found 
180a			 
180a			;		ld h, 0 
180a			;		ld l, c 
180a			 
180a c9				ret 
180b			 
180b			endif 
180b			 
180b			 
180b			; Settings 
180b			; Run  
180b			 
180b			 
180b			 
180b			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
180b			;;hd_menu2:   db "        2: Editor",0   
180b			;hd_menu2:   db "        2: Editor       6: Menu",0   
180b			;hd_menu3:   db "        3: Storage",0 
180b			;hd_menu4:   db "0=quit  4: Debug",0 
180b			;hd_don:     db "ON",0 
180b			;hd_doff:     db "OFF",0 
180b			; 
180b			; 
180b			; 
180b			;hardware_diags_old:       
180b			; 
180b			;.diagmenu: 
180b			;	call clear_display 
180b			;	ld a, display_row_1 
180b			;	ld de, hd_menu1 
180b			;	call str_at_display 
180b			; 
180b			;	ld a, display_row_2 
180b			;	ld de, hd_menu2 
180b			;	call str_at_display 
180b			; 
180b			;	ld a, display_row_3 
180b			;	ld de, hd_menu3 
180b			;	call str_at_display 
180b			; 
180b			;	ld a,  display_row_4 
180b			;	ld de, hd_menu4 
180b			;	call str_at_display 
180b			; 
180b			;	; display debug state 
180b			; 
180b			;	ld de, hd_don 
180b			;	ld a, (os_view_disable) 
180b			;	cp 0 
180b			;	jr z, .distog 
180b			;	ld de, hd_doff 
180b			;.distog: ld a, display_row_4+17 
180b			;	call str_at_display 
180b			; 
180b			;	call update_display 
180b			; 
180b			;	call cin_wait 
180b			; 
180b			; 
180b			; 
180b			;	cp '4' 
180b			;	jr nz, .diagn1 
180b			; 
180b			;	; debug toggle 
180b			; 
180b			;	ld a, (os_view_disable) 
180b			;	ld b, '*' 
180b			;	cp 0 
180b			;	jr z, .debtog 
180b			;	ld b, 0 
180b			;.debtog:	 
180b			;	ld a,b 
180b			;	ld (os_view_disable),a 
180b			; 
180b			;.diagn1: cp '0' 
180b			;	 ret z 
180b			; 
180b			;;	cp '1' 
180b			;;       jp z, matrix	 
180b			;;   TODO keyboard matrix test 
180b			; 
180b			;	cp '2' 
180b			;	jp z, .diagedit 
180b			; 
180b			;;	cp '6' 
180b			;;	jp z, .menutest 
180b			;;if ENABLE_BASIC 
180b			;;	cp '6' 
180b			;;	jp z, basic 
180b			;;endif 
180b			 ; 
180b			;	jp .diagmenu 
180b			; 
180b			; 
180b			;	ret 
180b			 
180b			 
180b			.debug_tog: 
180b 21 55 18			ld hl, .menudebug 
180e				 
180e			;	ld a, (os_view_disable) 
180e			;	cp '*' 
180e 3a aa fd			ld a,(debug_vector) 
1811 fe c9			cp $C9   ; RET 
1813 20 04			jr nz,.tdon  
1815 3e 01			ld a, 1 
1817 18 02			jr .tog1 
1819 3e 00		.tdon: ld a, 0 
181b			 
181b			.tog1: 
181b cd db 0d			call menu 
181e fe 00			cp 0 
1820 c8				ret z 
1821 fe 01			cp 1    ; disable debug 
1823 28 04			jr z, .dtog0 
1825 3e 2a			ld a, '*' 
1827 18 05			jr .dtogset 
1829			.dtog0:  
1829				;ld a, 0 
1829 cd 47 19			call bp_on 
182c 18 dd			jr .debug_tog 
182e			.dtogset:  
182e				; ld (os_view_disable), a 
182e cd 53 19			call bp_off 
1831 c3 0b 18			jp .debug_tog 
1834			 
1834			 
1834			hardware_diags:       
1834			 
1834			.diagm: 
1834 21 47 18			ld hl, .menuitems 
1837 3e 00			ld a, 0 
1839 cd db 0d			call menu 
183c			 
183c fe 00		         cp 0 
183e c8				 ret z 
183f			 
183f fe 02			cp 2 
1841 ca a0 18			jp z, .diagedit 
1844			 
1844			;	cp '6' 
1844			;	jp z, .menutest 
1844			;if ENABLE_BASIC 
1844			;	cp '6' 
1844			;	jp z, basic 
1844			;endif 
1844			  
1844 c3 34 18			jp .diagm 
1847			 
1847				 
1847 5b 18		.menuitems:   	dw .m1 
1849 66 18				dw .m2 
184b 6d 18				dw .m3 
184d 75 18				dw .m5 
184f 7b 18				dw .m5a 
1851 84 18				dw .m5b 
1853 00 00				dw 0 
1855			 
1855			.menudebug: 
1855 8d 18				dw .m6 
1857 96 18				dw .m7 
1859 00 00				dw 0 
185b			 
185b .. 00		.m1:   db "Key Matrix",0 
1866 .. 00		.m2:   db "Editor",0 
186d .. 00		.m3:   db "Storage",0 
1875 .. 00		.m5:   db "Sound",0 
187b .. 00		.m5a:  db "RAM Test",0 
1884 .. 00		.m5b:  db "LCD Test",0 
188d			 
188d .. 00		.m6:   db "Debug ON",0 
1896 .. 00		.m7:   db "Debug OFF",0 
18a0			 
18a0			; debug editor 
18a0			 
18a0			.diagedit: 
18a0			 
18a0 21 f6 f0			ld hl, scratch 
18a3			;	ld bc, 250 
18a3			;	ldir 
18a3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18a3 3e 00			ld a, 0 
18a5 77				ld (hl), a 
18a6 23				inc hl 
18a7 77				ld (hl), a 
18a8 23				inc hl 
18a9 77				ld (hl), a 
18aa			 
18aa cd aa 0d		        call clear_display 
18ad cd cd 0d			call update_display 
18b0				;ld a, 1 
18b0				;ld (hardware_diag), a 
18b0			.diloop: 
18b0 3e 00			ld a, display_row_1 
18b2 0e 00			ld c, 0 
18b4 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18b6 1e 28			ld e, 40 
18b8			 
18b8 21 f6 f0			ld hl, scratch	 
18bb cd 0b 10			call input_str 
18be			 
18be 3e 28			ld a, display_row_2 
18c0 11 f6 f0			ld de, scratch 
18c3 cd bd 0d			call str_at_display 
18c6 cd cd 0d			call update_display 
18c9			 
18c9 c3 b0 18			jp .diloop 
18cc			 
18cc			 
18cc			; pass word in hl 
18cc			; a has display location 
18cc			display_word_at: 
18cc f5				push af 
18cd e5				push hl 
18ce 7c				ld a,h 
18cf 21 fb f3			ld hl, os_word_scratch 
18d2 cd e7 11			call hexout 
18d5 e1				pop hl 
18d6 7d				ld a,l 
18d7 21 fd f3			ld hl, os_word_scratch+2 
18da cd e7 11			call hexout 
18dd 21 ff f3			ld hl, os_word_scratch+4 
18e0 3e 00			ld a,0 
18e2 77				ld (hl),a 
18e3 11 fb f3			ld de,os_word_scratch 
18e6 f1				pop af 
18e7 cd bd 0d				call str_at_display 
18ea c9				ret 
18eb			 
18eb			display_ptr_state: 
18eb			 
18eb				; to restore afterwards 
18eb			 
18eb d5				push de 
18ec c5				push bc 
18ed e5				push hl 
18ee f5				push af 
18ef			 
18ef				; for use in here 
18ef			 
18ef			;	push bc 
18ef			;	push de 
18ef			;	push hl 
18ef			;	push af 
18ef			 
18ef cd aa 0d			call clear_display 
18f2			 
18f2 11 ca 1a			ld de, .ptrstate 
18f5 3e 00			ld a, display_row_1 
18f7 cd bd 0d			call str_at_display 
18fa			 
18fa				; display debug step 
18fa			 
18fa			 
18fa 11 a0 fd			ld de, debug_mark 
18fd 3e 26			ld a, display_row_1+display_cols-2 
18ff cd bd 0d			call str_at_display 
1902			 
1902				; display a 
1902 11 d4 1a			ld de, .ptrcliptr 
1905 3e 28			ld a, display_row_2 
1907 cd bd 0d			call str_at_display 
190a			 
190a f1				pop af 
190b 2a 75 f9			ld hl,(cli_ptr) 
190e 3e 30			ld a, display_row_2+8 
1910 cd cc 18			call display_word_at 
1913			 
1913			 
1913				; display hl 
1913			 
1913			 
1913 11 dc 1a			ld de, .ptrclioptr 
1916 3e 32			ld a, display_row_2+10 
1918 cd bd 0d			call str_at_display 
191b			; 
191b			;	pop hl 
191b 3e 35			ld a, display_row_2+13 
191d 2a 73 f9			ld hl,(cli_origptr) 
1920 cd cc 18			call display_word_at 
1923			; 
1923			;	 
1923			;	; display de 
1923			 
1923			;	ld de, .regstatede 
1923			;	ld a, display_row_3 
1923			;	call str_at_display 
1923			 
1923			;	pop de 
1923			;	ld h,d 
1923			;	ld l, e 
1923			;	ld a, display_row_3+3 
1923			;	call display_word_at 
1923			 
1923			 
1923				; display bc 
1923			 
1923			;	ld de, .regstatebc 
1923			;	ld a, display_row_3+10 
1923			;	call str_at_display 
1923			 
1923			;	pop bc 
1923			;	ld h,b 
1923			;	ld l, c 
1923			;	ld a, display_row_3+13 
1923			;	call display_word_at 
1923			 
1923			 
1923				; display dsp 
1923			 
1923			;	ld de, .regstatedsp 
1923			;	ld a, display_row_4 
1923			;	call str_at_display 
1923			 
1923				 
1923			;	ld hl,(cli_data_sp) 
1923			;	ld a, display_row_4+4 
1923			;	call display_word_at 
1923			 
1923				; display rsp 
1923			 
1923 11 0b 1b			ld de, .regstatersp 
1926 3e 82			ld a, display_row_4+10 
1928 cd bd 0d			call str_at_display 
192b			 
192b				 
192b 2a 27 f9			ld hl,(cli_ret_sp) 
192e 3e 86			ld a, display_row_4+14 
1930 cd cc 18			call display_word_at 
1933			 
1933 cd cd 0d			call update_display 
1936			 
1936 cd ed 0c			call delay1s 
1939 cd ed 0c			call delay1s 
193c cd ed 0c			call delay1s 
193f			 
193f			 
193f cd be 1f			call next_page_prompt 
1942			 
1942				; restore  
1942			 
1942 f1				pop af 
1943 e1				pop hl 
1944 c1				pop bc 
1945 d1				pop de 
1946 c9				ret 
1947			 
1947			; Update the break point vector so that the user can hook a new routine 
1947			 
1947			bp_on: 
1947 3e c3			ld a, $c3    ; JP 
1949 32 aa fd			ld (debug_vector), a 
194c 21 59 19			ld hl, break_point_state 
194f 22 ab fd			ld (debug_vector+1), hl 
1952 c9				ret 
1953			 
1953			bp_off: 
1953 3e c9			ld a, $c9    ; RET 
1955 32 aa fd			ld (debug_vector), a 
1958 c9				ret 
1959			 
1959			 
1959			break_point_state: 
1959			;	push af 
1959			; 
1959			;	; see if disabled 
1959			; 
1959			;	ld a, (os_view_disable) 
1959			;	cp '*' 
1959			;	jr nz, .bpsgo 
1959			;	pop af 
1959			;	ret 
1959			 
1959			.bpsgo: 
1959			;	pop af 
1959 f5				push af 
195a 22 d8 f0			ld (os_view_hl), hl 
195d ed 53 d6 f0		ld (os_view_de), de 
1961 ed 43 d4 f0		ld (os_view_bc), bc 
1965 e5				push hl 
1966 6f				ld l, a 
1967 26 00			ld h, 0 
1969 22 da f0			ld (os_view_af),hl 
196c			 
196c 21 e6 fc				ld hl, display_fb0 
196f 22 01 fb				ld (display_fb_active), hl 
1972 e1				pop hl	 
1973			 
1973 3e 31			ld a, '1' 
1975 fe 2a		.bps1:  cp '*' 
1977 cc 53 19			call z, bp_off 
197a			;	jr nz, .bps1b 
197a			;	ld (os_view_disable),a 
197a fe 31		.bps1b:  cp '1' 
197c 20 14			jr nz, .bps2 
197e			 
197e				; display reg 
197e			 
197e				 
197e			 
197e 3a da f0			ld a, (os_view_af) 
1981 2a d8 f0			ld hl, (os_view_hl) 
1984 ed 5b d6 f0		ld de, (os_view_de) 
1988 ed 4b d4 f0		ld bc, (os_view_bc) 
198c cd 26 1a			call display_reg_state 
198f c3 12 1a			jp .bpschk 
1992			 
1992 fe 32		.bps2:  cp '2' 
1994 20 08			jr nz, .bps3 
1996				 
1996				; display hl 
1996 2a d8 f0			ld hl, (os_view_hl) 
1999 cd 10 1b			call display_dump_at_hl 
199c			 
199c 18 74			jr .bpschk 
199e			 
199e fe 33		.bps3:  cp '3' 
19a0 20 08			jr nz, .bps4 
19a2			 
19a2			        ; display de 
19a2 2a d6 f0			ld hl, (os_view_de) 
19a5 cd 10 1b			call display_dump_at_hl 
19a8			 
19a8 18 68			jr .bpschk 
19aa fe 34		.bps4:  cp '4' 
19ac 20 08			jr nz, .bps5 
19ae			 
19ae			        ; display bc 
19ae 2a d4 f0			ld hl, (os_view_bc) 
19b1 cd 10 1b			call display_dump_at_hl 
19b4			 
19b4 18 5c			jr .bpschk 
19b6 fe 35		.bps5:  cp '5' 
19b8 20 08		        jr nz, .bps7 
19ba			 
19ba				; display cur ptr 
19ba 2a 75 f9			ld hl, (cli_ptr) 
19bd cd 10 1b			call display_dump_at_hl 
19c0			 
19c0 18 50			jr .bpschk 
19c2 fe 36		.bps7:  cp '6' 
19c4 20 08			jr nz, .bps8b 
19c6				 
19c6				; display cur orig ptr 
19c6 2a 73 f9			ld hl, (cli_origptr) 
19c9 cd 10 1b			call display_dump_at_hl 
19cc 18 44			jr .bpschk 
19ce fe 37		.bps8b:  cp '7' 
19d0 20 08			jr nz, .bps9 
19d2				 
19d2				; display dsp 
19d2 2a 23 f9			ld hl, (cli_data_sp) 
19d5 cd 10 1b			call display_dump_at_hl 
19d8			 
19d8 18 38			jr .bpschk 
19da fe 39		.bps9:  cp '9' 
19dc 20 05			jr nz, .bps8c 
19de				 
19de				; display SP 
19de			;	ld hl, sp 
19de cd 10 1b			call display_dump_at_hl 
19e1			 
19e1 18 2f			jr .bpschk 
19e3 fe 38		.bps8c:  cp '8' 
19e5 20 08			jr nz, .bps8d 
19e7				 
19e7				; display rsp 
19e7 2a 27 f9			ld hl, (cli_ret_sp) 
19ea cd 10 1b			call display_dump_at_hl 
19ed			 
19ed 18 23			jr .bpschk 
19ef fe 23		.bps8d:  cp '#'     ; access monitor sub system 
19f1 20 05			jr nz, .bps8 
19f3 cd 78 1d			call monitor 
19f6			 
19f6 18 1a			jr .bpschk 
19f8 fe 30		.bps8:  cp '0' 
19fa 20 16			jr nz, .bpschk 
19fc			 
19fc 21 45 fc				ld hl, display_fb1 
19ff 22 01 fb				ld (display_fb_active), hl 
1a02 cd cd 0d				call update_display 
1a05			 
1a05				;ld a, (os_view_af) 
1a05 2a d8 f0			ld hl, (os_view_hl) 
1a08 ed 5b d6 f0		ld de, (os_view_de) 
1a0c ed 4b d4 f0		ld bc, (os_view_bc) 
1a10 f1				pop af 
1a11 c9				ret 
1a12			 
1a12			.bpschk:   
1a12 cd ed 0c			call delay1s 
1a15 3e 9f		ld a,display_row_4 + display_cols - 1 
1a17 11 bc 1f		        ld de, endprg 
1a1a cd bd 0d			call str_at_display 
1a1d cd cd 0d			call update_display 
1a20 cd 7a 73			call cin_wait 
1a23			 
1a23 c3 75 19			jp .bps1 
1a26			 
1a26			 
1a26			display_reg_state: 
1a26			 
1a26				; to restore afterwards 
1a26			 
1a26 d5				push de 
1a27 c5				push bc 
1a28 e5				push hl 
1a29 f5				push af 
1a2a			 
1a2a				; for use in here 
1a2a			 
1a2a c5				push bc 
1a2b d5				push de 
1a2c e5				push hl 
1a2d f5				push af 
1a2e			 
1a2e cd aa 0d			call clear_display 
1a31			 
1a31 11 e6 1a			ld de, .regstate 
1a34 3e 00			ld a, display_row_1 
1a36 cd bd 0d			call str_at_display 
1a39			 
1a39				; display debug step 
1a39			 
1a39			 
1a39 11 a0 fd			ld de, debug_mark 
1a3c 3e 25			ld a, display_row_1+display_cols-3 
1a3e cd bd 0d			call str_at_display 
1a41			 
1a41				; display a 
1a41 11 02 1b			ld de, .regstatea 
1a44 3e 28			ld a, display_row_2 
1a46 cd bd 0d			call str_at_display 
1a49			 
1a49 e1				pop hl 
1a4a			;	ld h,0 
1a4a			;	ld l, a 
1a4a 3e 2b			ld a, display_row_2+3 
1a4c cd cc 18			call display_word_at 
1a4f			 
1a4f			 
1a4f				; display hl 
1a4f			 
1a4f			 
1a4f 11 f6 1a			ld de, .regstatehl 
1a52 3e 32			ld a, display_row_2+10 
1a54 cd bd 0d			call str_at_display 
1a57			 
1a57 e1				pop hl 
1a58 3e 35			ld a, display_row_2+13 
1a5a cd cc 18			call display_word_at 
1a5d			 
1a5d				 
1a5d				; display de 
1a5d			 
1a5d 11 fa 1a			ld de, .regstatede 
1a60 3e 50			ld a, display_row_3 
1a62 cd bd 0d			call str_at_display 
1a65			 
1a65 e1				pop hl 
1a66			;	ld h,d 
1a66			;	ld l, e 
1a66 3e 53			ld a, display_row_3+3 
1a68 cd cc 18			call display_word_at 
1a6b			 
1a6b			 
1a6b				; display bc 
1a6b			 
1a6b 11 fe 1a			ld de, .regstatebc 
1a6e 3e 5a			ld a, display_row_3+10 
1a70 cd bd 0d			call str_at_display 
1a73			 
1a73 e1				pop hl 
1a74			;	ld h,b 
1a74			;	ld l, c 
1a74 3e 5d			ld a, display_row_3+13 
1a76 cd cc 18			call display_word_at 
1a79			 
1a79			 
1a79				; display dsp 
1a79			 
1a79 11 06 1b			ld de, .regstatedsp 
1a7c 3e 78			ld a, display_row_4 
1a7e cd bd 0d			call str_at_display 
1a81			 
1a81				 
1a81 2a 23 f9			ld hl,(cli_data_sp) 
1a84 3e 7c			ld a, display_row_4+4 
1a86 cd cc 18			call display_word_at 
1a89			 
1a89				; display rsp 
1a89			 
1a89 11 0b 1b			ld de, .regstatersp 
1a8c 3e 82			ld a, display_row_4+10 
1a8e cd bd 0d			call str_at_display 
1a91			 
1a91				 
1a91 2a 27 f9			ld hl,(cli_ret_sp) 
1a94 3e 86			ld a, display_row_4+14 
1a96 cd cc 18			call display_word_at 
1a99			 
1a99 cd cd 0d			call update_display 
1a9c			 
1a9c			;	call delay1s 
1a9c			;	call delay1s 
1a9c			;	call delay1s 
1a9c			 
1a9c			 
1a9c			;	call next_page_prompt 
1a9c			 
1a9c				; restore  
1a9c			 
1a9c f1				pop af 
1a9d e1				pop hl 
1a9e c1				pop bc 
1a9f d1				pop de 
1aa0 c9				ret 
1aa1			 
1aa1 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ab5 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1aca .. 00		.ptrstate:	db "Ptr State",0 
1ad4 .. 00		.ptrcliptr:     db "cli_ptr",0 
1adc .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1ae6 .. 00		.regstate:	db "Reg State (1/0)",0 
1af6 .. 00		.regstatehl:	db "HL:",0 
1afa .. 00		.regstatede:	db "DE:",0 
1afe .. 00		.regstatebc:	db "BC:",0 
1b02 .. 00		.regstatea:	db "A :",0 
1b06 .. 00		.regstatedsp:	db "DSP:",0 
1b0b .. 00		.regstatersp:	db "RSP:",0 
1b10			 
1b10			display_dump_at_hl: 
1b10 e5				push hl 
1b11 d5				push de 
1b12 c5				push bc 
1b13 f5				push af 
1b14			 
1b14 22 19 f4			ld (os_cur_ptr),hl	 
1b17 cd aa 0d			call clear_display 
1b1a cd c6 1e			call dumpcont 
1b1d			;	call delay1s 
1b1d			;	call next_page_prompt 
1b1d			 
1b1d			 
1b1d f1				pop af 
1b1e c1				pop bc 
1b1f d1				pop de 
1b20 e1				pop hl 
1b21 c9				ret 
1b22			 
1b22			;if ENABLE_BASIC 
1b22			;	include "nascombasic.asm" 
1b22			;	basic: 
1b22			;	include "forth/FORTH.ASM" 
1b22			;endif 
1b22			 
1b22			; eof 
1b22			 
1b22			 
# End of file firmware_diags.asm
1b22			  
1b22			include "firmware_prompts.asm"  
1b22			; Prompts  
1b22			 
1b22			; boot messages 
1b22			 
1b22 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1b37 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1b47			 
1b47			 
1b47			; config menus 
1b47			 
1b47			;prom_c3: db "Add Dictionary To File",0 
1b47			 
1b47			if STARTUP_V1 
1b47			prom_c2: db "Select Autoload File",0 
1b47			prom_c2a: db "Disable Autoload File", 0 
1b47			endif 
1b47			 
1b47			if STARTUP_V2 
1b47 .. 00		prom_c2: db "Enable Autoload Files",0 
1b5d .. 00		prom_c2a: db "Disable Autoload Files", 0 
1b74			 
1b74 .. 00		crs_s1: db "*ls-word", 0 
1b7d .. 00		crs_s2: db "*ed-word", 0 
1b86 .. 00		crs_s3: db "*Demo-Games", 0 
1b92 .. 00		crs_s4: db "*Utils", 0 
1b99 .. 00		crs_s5: db "*SPI-Util", 0 
1ba3 .. 00		crs_s6: db "*Key-Constants", 0 
1bb2 .. 00		crs_sound: db "*Sound-Util", 0 
1bbe .. 00		crs_hw: db "*Hello-World",0 
1bcb			 
1bcb			 
1bcb			 
1bcb			endif 
1bcb			;prom_c2b: db "Select Storage Bank",0 
1bcb .. 00		prom_c4: db "Settings",0 
1bd4 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1bef .. 00		prom_m4b:   db "Monitor",0 
1bf7 .. 00		prom_c1: db "Hardware Diags",0 
1c06			 
1c06			 
1c06			if STARTUP_V2 
1c06 .. 00		prom_c9: db "Create Startup Files",0 
1c1b			endif 
1c1b			 
1c1b .. 00		prom_notav:    db "Feature not available",0 
1c31 .. 00		prom_empty:    db "",0 
1c32			 
1c32			; eof 
1c32			 
# End of file firmware_prompts.asm
1c32			  
1c32			  
1c32			; eof  
1c32			  
# End of file firmware.asm
1c32			 
1c32			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1c32			;if BASE_KEV  
1c32			;baseram: equ 08000h 
1c32			;endif 
1c32			 
1c32			;if BASE_SC114 
1c32			;baseram:     equ    endofcode 
1c32			;endif 
1c32			 
1c32			 
1c32			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1c32			 
1c32			; start system 
1c32			 
1c32			coldstart: 
1c32				; set sp 
1c32				; di/ei 
1c32			 
1c32 f3				di 
1c33 31 fd ff			ld sp, tos 
1c36 cd 01 70			call init_nmi 
1c39			;	ei 
1c39			 
1c39				; init spinner 
1c39 3e 00			ld a,0 
1c3b 32 fb fa			ld (display_active), a 
1c3e			 
1c3e				; disable breakpoint by default 
1c3e			 
1c3e				;ld a,'*' 
1c3e			;	ld a,' ' 
1c3e			;	ld (os_view_disable),a 
1c3e			 
1c3e				; set break point vector as new break point on or off 
1c3e cd 53 19			call bp_off 
1c41			 
1c41				; init hardware 
1c41			 
1c41				; init keyboard and screen hardware 
1c41			 
1c41 cd 6c 00			call hardware_init 
1c44			 
1c44			 
1c44 cd ed 0c			call delay1s 
1c47 3e 58			ld a, display_row_3+8 
1c49 11 03 00			ld de, buildtime 
1c4c cd bd 0d			call str_at_display 
1c4f cd cd 0d			call update_display 
1c52			 
1c52 cd ed 0c			call delay1s 
1c55 cd ed 0c			call delay1s 
1c58 cd ed 0c			call delay1s 
1c5b			 
1c5b				; detect if any keys are held down to enable breakpoints at start up 
1c5b			 
1c5b cd 8b 73			call cin  
1c5e fe 00			cp 0 
1c60 28 03			jr z, .nokeys 
1c62			 
1c62				;call hardware_diags 
1c62 cd 52 15			call config 
1c65			 
1c65			;	ld de, .bpen 
1c65			;	ld a, display_row_4 
1c65			;	call str_at_display 
1c65			;	call update_display 
1c65			; 
1c65			;	ld a,0 
1c65			;	ld (os_view_disable),a 
1c65			; 
1c65			;.bpwait: 
1c65			;	call cin 
1c65			;	cp 0 
1c65			;	jr z, .bpwait 
1c65			;	jr .nokeys 
1c65			; 
1c65			; 
1c65			;.bpen:  db "Break points enabled!",0 
1c65			 
1c65			 
1c65			 
1c65			 
1c65			 
1c65			 
1c65			.nokeys: 
1c65			 
1c65			 
1c65				 
1c65			 
1c65			;jp  testkey 
1c65			 
1c65			;call storage_get_block_0 
1c65			; 
1c65			;ld hl, 0 
1c65			;ld de, store_page 
1c65			;call storage_read_block 
1c65			 
1c65				 
1c65			;ld hl, 10 
1c65			;ld de, store_page 
1c65			;call storage_read_block 
1c65			 
1c65			 
1c65			 
1c65			 
1c65			 
1c65			;stop:	nop 
1c65			;	jp stop 
1c65			 
1c65			 
1c65			 
1c65			main: 
1c65 cd aa 0d			call clear_display 
1c68 cd cd 0d			call update_display 
1c6b			 
1c6b			 
1c6b			 
1c6b			;	call testlcd 
1c6b			 
1c6b			 
1c6b			 
1c6b cd 07 24			call forth_init 
1c6e			 
1c6e			 
1c6e			warmstart: 
1c6e cd dd 23			call forth_warmstart 
1c71			 
1c71				; run startup word load 
1c71			        ; TODO prevent this running at warmstart after crash  
1c71			 
1c71				if STARTUP_ENABLE 
1c71			 
1c71					if STARTUP_V1 
1c71			 
1c71						if STORAGE_SE 
1c71							call forth_autoload 
1c71						endif 
1c71						call forth_startup 
1c71					endif 
1c71			 
1c71					if STARTUP_V2 
1c71			 
1c71						if STORAGE_SE 
1c71 cd 2f 6e						call forth_autoload 
1c74						else 
1c74							call forth_startup 
1c74						endif 
1c74			 
1c74			 
1c74					endif 
1c74			 
1c74				endif 
1c74			 
1c74			warmstart_afterauto: 
1c74			 
1c74				; show free memory after boot 
1c74 11 13 1d			ld de, freeram 
1c77 3e 00			ld a, display_row_1 
1c79 cd bd 0d			call str_at_display 
1c7c			 
1c7c				; get current heap start after loading any uwords 
1c7c			 
1c7c				;ld de, (os_last_new_uword) 
1c7c				;ex de, hl 
1c7c			 
1c7c			; Or use heap_size word???? 
1c7c				;ld hl, heap_end 
1c7c				;ld hl, heap_size 
1c7c				;ld de, topusermem 
1c7c				;ld de, heap_start 
1c7c ed 5b 0a 80			ld de, (free_list )      
1c80 21 d1 f0				ld hl, heap_end 
1c83 ed 52			sbc hl, de 
1c85				;push hl 
1c85				;ld a,h	         	 
1c85				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c85				;call hexout 
1c85			   	;pop hl 
1c85			; 
1c85			;	ld a,l 
1c85			;	ld hl, os_word_scratch+2 
1c85			;	call hexout 
1c85			;	ld hl, os_word_scratch+4 
1c85			;	ld a, 0 
1c85			;	ld (hl),a 
1c85 eb				ex de, hl 
1c86 21 fb f3			ld hl, os_word_scratch 
1c89 cd f3 12			call uitoa_16 
1c8c			 
1c8c			 
1c8c 11 fb f3			ld de, os_word_scratch 
1c8f 3e 0d			ld a, display_row_1 + 13 
1c91 cd bd 0d			call str_at_display 
1c94 cd cd 0d			call update_display 
1c97			 
1c97			 
1c97				;call demo 
1c97			 
1c97			 
1c97				; init scratch input area for cli commands 
1c97			 
1c97 21 1d f4			ld hl, os_cli_cmd 
1c9a 3e 00			ld a,0 
1c9c 77				ld (hl),a 
1c9d 23				inc hl 
1c9e 77				ld (hl),a 
1c9f			 
1c9f 3e 00			ld a,0 
1ca1 32 1c f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1ca4			 
1ca4 32 19 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1ca7 32 1a f4			ld (os_cur_ptr+1),a	 
1caa			 
1caa 32 fb f3			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1cad 32 fc f3			ld (os_word_scratch+1),a	 
1cb0				 
1cb0			 
1cb0				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cb0 21 1d f4			ld hl, os_cli_cmd 
1cb3			 
1cb3 3e 00			ld a, 0		 ; init cli input 
1cb5 77				ld (hl), a 
1cb6 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cb8			cli: 
1cb8				; show cli prompt 
1cb8				;push af 
1cb8				;ld a, 0 
1cb8				;ld de, prompt 
1cb8				;call str_at_display 
1cb8			 
1cb8				;call update_display 
1cb8				;pop af 
1cb8				;inc a 
1cb8				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1cb8			 
1cb8			.lastrecall: 
1cb8			 
1cb8 0e 00			ld c, 0 
1cba 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1cbc 1e 28			ld e, 40 
1cbe			 
1cbe 21 1d f4			ld hl, os_cli_cmd 
1cc1			 
1cc1				STACKFRAME OFF $fefe $9f9f 
1cc1				if DEBUG_STACK_IMB 
1cc1					if OFF 
1cc1						exx 
1cc1						ld de, $fefe 
1cc1						ld a, d 
1cc1						ld hl, curframe 
1cc1						call hexout 
1cc1						ld a, e 
1cc1						ld hl, curframe+2 
1cc1						call hexout 
1cc1						ld hl, $fefe 
1cc1						push hl 
1cc1						ld hl, $9f9f 
1cc1						push hl 
1cc1						exx 
1cc1					endif 
1cc1				endif 
1cc1			endm 
# End of macro STACKFRAME
1cc1			 
1cc1 cd 0b 10			call input_str 
1cc4			 
1cc4				STACKFRAMECHK OFF $fefe $9f9f 
1cc4				if DEBUG_STACK_IMB 
1cc4					if OFF 
1cc4						exx 
1cc4						ld hl, $9f9f 
1cc4						pop de   ; $9f9f 
1cc4						call cmp16 
1cc4						jr nz, .spnosame 
1cc4						ld hl, $fefe 
1cc4						pop de   ; $fefe 
1cc4						call cmp16 
1cc4						jr z, .spfrsame 
1cc4						.spnosame: call showsperror 
1cc4						.spfrsame: nop 
1cc4						exx 
1cc4					endif 
1cc4				endif 
1cc4			endm 
# End of macro STACKFRAMECHK
1cc4			 
1cc4			 
1cc4				; check to see if last line recall has been requested 
1cc4			 
1cc4			if EDIT_V2 
1cc4 fe 05			cp KEY_UP 
1cc6 20 0f			jr nz, .noexecline 
1cc8			 
1cc8 11 1d f4			ld de, os_cli_cmd 
1ccb 21 1c f5			ld hl, os_last_cmd 
1cce 01 ff 00			ld bc, 255 
1cd1 ed b0			ldir 
1cd3 3e 00			ld a, 0 
1cd5 18 e1			jr .lastrecall 
1cd7			endif 
1cd7			 
1cd7			.noexecline: 
1cd7				; no so exec the line		 
1cd7			 
1cd7				; copy input to last command 
1cd7			 
1cd7 21 1d f4			ld hl, os_cli_cmd 
1cda 11 1c f5			ld de, os_last_cmd 
1cdd 01 ff 00			ld bc, 255 
1ce0 ed b0			ldir 
1ce2			 
1ce2				; wipe current buffer 
1ce2			 
1ce2			;	ld a, 0 
1ce2			;	ld hl, os_cli_cmd 
1ce2			;	ld de, os_cli_cmd+1 
1ce2			;	ld bc, 254 
1ce2			;	ldir 
1ce2				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1ce2			;	call strcpy 
1ce2			;	ld a, 0 
1ce2			;	ld (hl), a 
1ce2			;	inc hl 
1ce2			;	ld (hl), a 
1ce2			;	inc hl 
1ce2			;	ld (hl), a 
1ce2			 
1ce2				; switch frame buffer to program  
1ce2			 
1ce2 21 45 fc				ld hl, display_fb1 
1ce5 22 01 fb				ld (display_fb_active), hl 
1ce8			 
1ce8			;	nop 
1ce8				STACKFRAME ON $fbfe $8f9f 
1ce8				if DEBUG_STACK_IMB 
1ce8					if ON 
1ce8						exx 
1ce8						ld de, $fbfe 
1ce8						ld a, d 
1ce8						ld hl, curframe 
1ce8						call hexout 
1ce8						ld a, e 
1ce8						ld hl, curframe+2 
1ce8						call hexout 
1ce8						ld hl, $fbfe 
1ce8						push hl 
1ce8						ld hl, $8f9f 
1ce8						push hl 
1ce8						exx 
1ce8					endif 
1ce8				endif 
1ce8			endm 
# End of macro STACKFRAME
1ce8				; first time into the parser so pass over the current scratch pad 
1ce8 21 1d f4			ld hl,os_cli_cmd 
1ceb				; tokenise the entered statement(s) in HL 
1ceb cd 85 24			call forthparse 
1cee			        ; exec forth statements in top of return stack 
1cee cd c5 24			call forthexec 
1cf1				;call forthexec_cleanup 
1cf1			;	call parsenext 
1cf1			 
1cf1				STACKFRAMECHK ON $fbfe $8f9f 
1cf1				if DEBUG_STACK_IMB 
1cf1					if ON 
1cf1						exx 
1cf1						ld hl, $8f9f 
1cf1						pop de   ; $8f9f 
1cf1						call cmp16 
1cf1						jr nz, .spnosame 
1cf1						ld hl, $fbfe 
1cf1						pop de   ; $fbfe 
1cf1						call cmp16 
1cf1						jr z, .spfrsame 
1cf1						.spnosame: call showsperror 
1cf1						.spfrsame: nop 
1cf1						exx 
1cf1					endif 
1cf1				endif 
1cf1			endm 
# End of macro STACKFRAMECHK
1cf1				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1cf1			 
1cf1 3e 78			ld a, display_row_4 
1cf3 11 24 1d			ld de, endprog 
1cf6			 
1cf6 cd cd 0d			call update_display		 
1cf9			 
1cf9 cd be 1f			call next_page_prompt 
1cfc			 
1cfc				; switch frame buffer to cli 
1cfc			 
1cfc 21 e6 fc				ld hl, display_fb0 
1cff 22 01 fb				ld (display_fb_active), hl 
1d02			 
1d02			 
1d02 cd aa 0d		        call clear_display 
1d05 cd cd 0d			call update_display		 
1d08			 
1d08 21 1d f4			ld hl, os_cli_cmd 
1d0b			 
1d0b 3e 00			ld a, 0		 ; init cli input 
1d0d 77				ld (hl), a 
1d0e			 
1d0e				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1d0e			 
1d0e				; now on last line 
1d0e			 
1d0e				; TODO scroll screen up 
1d0e			 
1d0e				; TODO instead just clear screen and place at top of screen 
1d0e			 
1d0e			;	ld a, 0 
1d0e			;	ld (f_cursor_ptr),a 
1d0e			 
1d0e				;call clear_display 
1d0e				;call update_display 
1d0e			 
1d0e				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d0e 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d10 c3 b8 1c			jp cli 
1d13			 
1d13 .. 00		freeram: db "Free bytes: ",0 
1d20 ..			asc: db "1A2F" 
1d24 .. 00		endprog: db "End prog...",0 
1d30			 
1d30			testenter2:   
1d30 21 28 f1			ld hl,scratch+50 
1d33 22 19 f4			ld (os_cur_ptr),hl 
1d36 c3 b8 1c			jp cli 
1d39			 
1d39			testenter:  
1d39			 
1d39 21 20 1d			ld hl,asc 
1d3c			;	ld a,(hl) 
1d3c			;	call nibble2val 
1d3c cd 3d 12			call get_byte 
1d3f			 
1d3f			 
1d3f			;	ld a,(hl) 
1d3f			;	call atohex 
1d3f			 
1d3f			;	call fourehexhl 
1d3f 32 28 f1			ld (scratch+50),a 
1d42			 
1d42			 
1d42			 
1d42 21 22 1d			ld hl,asc+2 
1d45			;	ld a, (hl) 
1d45			;	call nibble2val 
1d45 cd 3d 12			call get_byte 
1d48			 
1d48			;	call fourehexhl 
1d48 32 2a f1			ld (scratch+52),a 
1d4b				 
1d4b 21 28 f1			ld hl,scratch+50 
1d4e 22 19 f4			ld (os_cur_ptr),hl 
1d51 c3 b8 1c			jp cli 
1d54			 
1d54			enter:	 
1d54 3a fa f0			ld a,(scratch+4) 
1d57 fe 00			cp 0 
1d59 28 0c			jr z, .entercont 
1d5b				; no, not a null term line so has an address to work out.... 
1d5b			 
1d5b 21 f8 f0			ld hl,scratch+2 
1d5e cd 9d 12			call get_word_hl 
1d61			 
1d61 22 19 f4			ld (os_cur_ptr),hl	 
1d64 c3 b8 1c			jp cli 
1d67			 
1d67			 
1d67			.entercont:  
1d67			 
1d67 21 f8 f0			ld hl, scratch+2 
1d6a cd 3d 12			call get_byte 
1d6d			 
1d6d 2a 19 f4		   	ld hl,(os_cur_ptr) 
1d70 77					ld (hl),a 
1d71 23					inc hl 
1d72 22 19 f4				ld (os_cur_ptr),hl 
1d75				 
1d75			; get byte  
1d75			 
1d75			 
1d75 c3 b8 1c			jp cli 
1d78			 
1d78			 
1d78			; basic monitor support 
1d78			 
1d78			monitor: 
1d78				;  
1d78 cd aa 0d			call clear_display 
1d7b 3e 00			ld a, 0 
1d7d 11 d1 1d			ld de, .monprompt 
1d80 cd bd 0d			call str_at_display 
1d83 cd cd 0d			call update_display 
1d86			 
1d86				; get a monitor command 
1d86			 
1d86 0e 00			ld c, 0     ; entry at top left 
1d88 16 64			ld d, 100   ; max buffer size 
1d8a 1e 0f			ld e, 15    ; input scroll area 
1d8c 3e 00			ld a, 0     ; init string 
1d8e 21 f4 f2			ld hl, os_input 
1d91 77				ld (hl), a 
1d92 23				inc hl 
1d93 77				ld (hl), a 
1d94 21 f4 f2			ld hl, os_input 
1d97 3e 01			ld a, 1     ; init string 
1d99 cd 0b 10			call input_str 
1d9c			 
1d9c cd aa 0d		        call clear_display 
1d9f cd cd 0d			call update_display		 
1da2			 
1da2 3a f4 f2			ld a, (os_input) 
1da5 cd 3b 13			call toUpper 
1da8 fe 48		        cp 'H' 
1daa ca 45 1e		        jp z, .monhelp 
1dad fe 44			cp 'D'		; dump 
1daf ca 78 1e			jp z, .mondump	 
1db2 fe 43			cp 'C'		; dump 
1db4 ca 92 1e			jp z, .moncdump	 
1db7 fe 4d			cp 'M'		; dump 
1db9 ca d3 1d			jp z, .moneditstart 
1dbc fe 55			cp 'U'		; dump 
1dbe ca df 1d			jp z, .monedit	 
1dc1 fe 47			cp 'G'		; dump 
1dc3 ca 6e 1e			jp z, .monjump 
1dc6 fe 42			cp 'B'		; forth breakpoint 
1dc8 cc 59 19			call z, break_point_state 
1dcb fe 51			cp 'Q'		; dump 
1dcd c8				ret z	 
1dce			 
1dce			 
1dce				; TODO "S" to access symbol by name and not need the address 
1dce				; TODO "F" to find a string in memory 
1dce			 
1dce c3 78 1d			jp monitor 
1dd1			 
1dd1 .. 00		.monprompt: db ">", 0 
1dd3			 
1dd3			.moneditstart: 
1dd3				; get starting address 
1dd3			 
1dd3 21 f6 f2			ld hl,os_input+2 
1dd6 cd 9d 12			call get_word_hl 
1dd9			 
1dd9 22 19 f4			ld (os_cur_ptr),hl	 
1ddc			 
1ddc c3 78 1d			jp monitor 
1ddf			 
1ddf			.monedit: 
1ddf				; get byte to load 
1ddf			 
1ddf 21 f6 f2			ld hl,os_input+2 
1de2 cd 3d 12			call get_byte 
1de5			 
1de5				; get address to update 
1de5 2a 19 f4			ld hl, (os_cur_ptr) 
1de8			 
1de8				; update byte 
1de8			 
1de8 77				ld (hl), a 
1de9			 
1de9				; move to next address and save it 
1de9			 
1de9 23				inc hl 
1dea 22 19 f4			ld (os_cur_ptr),hl	 
1ded			 
1ded c3 78 1d			jp monitor 
1df0			 
1df0			 
1df0 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1e04 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1e20 .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
1e3e .. 00		.monhelptext4:  db "Q-Quit",0 
1e45			        
1e45			.monhelp: 
1e45 3e 00			ld a, display_row_1 
1e47 11 f0 1d		        ld de, .monhelptext1 
1e4a			 
1e4a cd bd 0d			call str_at_display 
1e4d 3e 28			ld a, display_row_2 
1e4f 11 04 1e		        ld de, .monhelptext2 
1e52					 
1e52 cd bd 0d			call str_at_display 
1e55 3e 50			ld a, display_row_3 
1e57 11 20 1e		        ld de, .monhelptext3 
1e5a					 
1e5a cd bd 0d			call str_at_display 
1e5d 3e 78			ld a, display_row_4 
1e5f 11 3e 1e		        ld de, .monhelptext4 
1e62 cd bd 0d			call str_at_display 
1e65			 
1e65 cd cd 0d			call update_display		 
1e68			 
1e68 cd be 1f			call next_page_prompt 
1e6b c3 78 1d			jp monitor 
1e6e			 
1e6e			.monjump:    
1e6e 21 f6 f2			ld hl,os_input+2 
1e71 cd 9d 12			call get_word_hl 
1e74			 
1e74 e9				jp (hl) 
1e75 c3 78 1d			jp monitor 
1e78			 
1e78			.mondump:    
1e78 21 f6 f2			ld hl,os_input+2 
1e7b cd 9d 12			call get_word_hl 
1e7e			 
1e7e 22 19 f4			ld (os_cur_ptr),hl	 
1e81 cd c6 1e			call dumpcont 
1e84 3e 78			ld a, display_row_4 
1e86 11 24 1d			ld de, endprog 
1e89			 
1e89 cd cd 0d			call update_display		 
1e8c			 
1e8c cd be 1f			call next_page_prompt 
1e8f c3 78 1d			jp monitor 
1e92			.moncdump: 
1e92 cd c6 1e			call dumpcont 
1e95 3e 78			ld a, display_row_4 
1e97 11 24 1d			ld de, endprog 
1e9a			 
1e9a cd cd 0d			call update_display		 
1e9d			 
1e9d cd be 1f			call next_page_prompt 
1ea0 c3 78 1d			jp monitor 
1ea3			 
1ea3			 
1ea3			; TODO symbol access  
1ea3			 
1ea3			.symbols:     ;; A list of symbols that can be called up  
1ea3 e6 fc			dw display_fb0 
1ea5 .. 00			db "fb0",0  
1ea9 af f9		     	dw store_page 
1eab .. 00			db "store_page",0 
1eb6			 
1eb6			 
1eb6			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1eb6			 
1eb6 3a f7 f0			ld a,(scratch+1) 
1eb9 fe 00			cp 0 
1ebb 28 09			jr z, dumpcont 
1ebd			 
1ebd				; no, not a null term line so has an address to work out.... 
1ebd			 
1ebd 21 f8 f0			ld hl,scratch+2 
1ec0 cd 9d 12			call get_word_hl 
1ec3			 
1ec3 22 19 f4			ld (os_cur_ptr),hl	 
1ec6			 
1ec6			 
1ec6			 
1ec6			dumpcont: 
1ec6			 
1ec6				; dump bytes at ptr 
1ec6			 
1ec6			 
1ec6 3e 00			ld a, display_row_1 
1ec8 2a 01 fb			ld hl, (display_fb_active) 
1ecb cd de 0f			call addatohl 
1ece cd f6 1e			call .dumpbyterow 
1ed1			 
1ed1 3e 28			ld a, display_row_2 
1ed3 2a 01 fb			ld hl, (display_fb_active) 
1ed6 cd de 0f			call addatohl 
1ed9 cd f6 1e			call .dumpbyterow 
1edc			 
1edc			 
1edc 3e 50			ld a, display_row_3 
1ede 2a 01 fb			ld hl, (display_fb_active) 
1ee1 cd de 0f			call addatohl 
1ee4 cd f6 1e			call .dumpbyterow 
1ee7			 
1ee7 3e 78			ld a, display_row_4 
1ee9 2a 01 fb			ld hl, (display_fb_active) 
1eec cd de 0f			call addatohl 
1eef cd f6 1e			call .dumpbyterow 
1ef2			 
1ef2 cd cd 0d			call update_display 
1ef5			;		jp cli 
1ef5 c9				ret 
1ef6			 
1ef6			.dumpbyterow: 
1ef6			 
1ef6				;push af 
1ef6			 
1ef6 e5				push hl 
1ef7			 
1ef7				; calc where to poke the ascii 
1ef7			if display_cols == 20 
1ef7				ld a, 16 
1ef7			else 
1ef7 3e 1f			ld a, 31 
1ef9			endif 
1ef9			 
1ef9 cd de 0f			call addatohl 
1efc 22 fb f3			ld (os_word_scratch),hl  		; save pos for later 
1eff			 
1eff			 
1eff			; display decoding address 
1eff 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f02			 
1f02 7c				ld a,h 
1f03 e1				pop hl 
1f04 e5				push hl 
1f05			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1f05 cd e7 11			call hexout 
1f08 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f0b			 
1f0b 7d				ld a,l 
1f0c e1				pop hl 
1f0d 23				inc hl 
1f0e 23				inc hl 
1f0f e5				push hl 
1f10			;	ld hl, os_word_scratch+2 
1f10 cd e7 11			call hexout 
1f13 e1				pop hl 
1f14 23				inc hl 
1f15 23				inc hl 
1f16				;ld hl, os_word_scratch+4 
1f16 3e 3a			ld a, ':' 
1f18 77				ld (hl),a 
1f19 23				inc hl 
1f1a				;ld a, 0 
1f1a				;ld (hl),a 
1f1a				;ld de, os_word_scratch 
1f1a				;pop af 
1f1a				;push af 
1f1a			;		ld a, display_row_2 
1f1a			;		call str_at_display 
1f1a			;		call update_display 
1f1a			 
1f1a			 
1f1a			;pop af 
1f1a			;	add 5 
1f1a			 
1f1a			if display_cols == 20 
1f1a				ld b, 4 
1f1a			else 
1f1a 06 08			ld b, 8 
1f1c			endif	 
1f1c			 
1f1c			.dumpbyte: 
1f1c c5				push bc 
1f1d e5				push hl 
1f1e			 
1f1e			 
1f1e 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f21 7e					ld a,(hl) 
1f22			 
1f22					; poke the ascii to display 
1f22 2a fb f3				ld hl,(os_word_scratch) 
1f25 77					ld (hl),a 
1f26 23					inc hl 
1f27 22 fb f3				ld (os_word_scratch),hl 
1f2a			 
1f2a					 
1f2a			 
1f2a			 
1f2a e1					pop hl 
1f2b e5					push hl 
1f2c			 
1f2c cd e7 11				call hexout 
1f2f			 
1f2f					 
1f2f 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f32 23				inc hl 
1f33 22 19 f4		   	ld (os_cur_ptr),hl 
1f36			 
1f36 e1					pop hl 
1f37 23					inc hl 
1f38 23					inc hl 
1f39 23					inc hl 
1f3a			 
1f3a			 
1f3a			 
1f3a					;ld a,0 
1f3a					;ld (os_word_scratch+2),a 
1f3a					;pop af 
1f3a					;push af 
1f3a			 
1f3a					;ld de, os_word_scratch 
1f3a					;call str_at_display 
1f3a			;		call update_display 
1f3a			;		pop af 
1f3a c1					pop bc 
1f3b c6 03				add 3 
1f3d 10 dd			djnz .dumpbyte 
1f3f			 
1f3f				 
1f3f			 
1f3f c9				ret 
1f40			 
1f40			jump:	 
1f40			 
1f40 21 f8 f0			ld hl,scratch+2 
1f43 cd 9d 12			call get_word_hl 
1f46				;ld hl,(scratch+2) 
1f46				;call fourehexhl 
1f46			 
1f46 22 19 f4			ld (os_cur_ptr),hl	 
1f49			 
1f49 e9				jp (hl) 
1f4a			 
1f4a			 
1f4a			 
1f4a			; TODO implement a basic monitor mode to start with 
1f4a			 
1f4a			 
1f4a			 
1f4a			 
1f4a			 
1f4a			 
1f4a			 
1f4a			 
1f4a			 
1f4a			; testing and demo code during development 
1f4a			 
1f4a			 
1f4a .. 00		str1: db "Enter some text...",0 
1f5d .. 00		clear: db "                    ",0 
1f72			 
1f72			demo: 
1f72			 
1f72			 
1f72			 
1f72			;	call update_display 
1f72			 
1f72				; init scratch input area for testing 
1f72 21 f6 f0			ld hl, scratch	 
1f75 3e 00			ld a,0 
1f77 77				ld (hl),a 
1f78			 
1f78			 
1f78 3e 28		            LD   A, display_row_2 
1f7a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f7a 11 4a 1f		            LD   DE, str1 
1f7d cd bd 0d			call str_at_display 
1f80			 
1f80			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f80			cloop:	 
1f80 3e 50		            LD   A, display_row_3 
1f82			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f82 11 5d 1f		            LD   DE, clear 
1f85			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1f85 cd bd 0d				call str_at_display 
1f88 3e 78			ld a, display_row_4 
1f8a 11 ba 1f			ld de, prompt 
1f8d			 
1f8d cd bd 0d				call str_at_display 
1f90 cd cd 0d			call update_display 
1f93			 
1f93 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1f95 16 0a			ld d, 10 
1f97 21 f6 f0			ld hl, scratch	 
1f9a cd 0b 10			call input_str 
1f9d			 
1f9d			;	call clear_display 
1f9d			;'	call update_display 
1f9d			 
1f9d 3e 00		            LD   A, display_row_1 
1f9f			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f9f 11 5d 1f		            LD   DE, clear 
1fa2 cd bd 0d				call str_at_display 
1fa5			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fa5 3e 00		            LD   A, display_row_1 
1fa7			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fa7 11 f6 f0		            LD   DE, scratch 
1faa			;            CALL fLCD_Str       ;Display string pointed to by DE 
1faa cd bd 0d				call str_at_display 
1fad cd cd 0d			call update_display 
1fb0			 
1fb0 3e 00				ld a,0 
1fb2 21 f6 f0			ld hl, scratch 
1fb5 77				ld (hl),a 
1fb6			 
1fb6 00				nop 
1fb7 c3 80 1f			jp cloop 
1fba			 
1fba			 
1fba			 
1fba			; OS Prompt 
1fba			 
1fba .. 00		prompt: db ">",0 
1fbc .. 00		endprg: db "?",0 
1fbe			 
1fbe			 
1fbe			; handy next page prompt 
1fbe			next_page_prompt: 
1fbe e5				push hl 
1fbf d5				push de 
1fc0 f5				push af 
1fc1 c5				push bc 
1fc2			 
1fc2 3e 9f			ld a,display_row_4 + display_cols - 1 
1fc4 11 bc 1f		        ld de, endprg 
1fc7 cd bd 0d			call str_at_display 
1fca cd cd 0d			call update_display 
1fcd cd 7a 73			call cin_wait 
1fd0 c1				pop bc 
1fd1 f1				pop af 
1fd2 d1				pop de 
1fd3 e1				pop hl 
1fd4			 
1fd4			 
1fd4 c9				ret 
1fd5			 
1fd5			 
1fd5			; forth parser 
1fd5			 
1fd5			; My forth kernel 
1fd5			include "forth_kernel.asm" 
1fd5			; 
1fd5			; kernel to the forth OS 
1fd5			 
1fd5			DS_TYPE_STR: equ 1     ; string type 
1fd5			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1fd5			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1fd5			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1fd5			 
1fd5			FORTH_PARSEV1: equ 0 
1fd5			FORTH_PARSEV2: equ 0 
1fd5			FORTH_PARSEV3: equ 0 
1fd5			FORTH_PARSEV4: equ 0 
1fd5			FORTH_PARSEV5: equ 1 
1fd5			 
1fd5			;if FORTH_PARSEV5 
1fd5			;	FORTH_END_BUFFER: equ 0 
1fd5			;else 
1fd5			FORTH_END_BUFFER: equ 127 
1fd5			;endif 
1fd5			 
1fd5			FORTH_TRUE: equ 1 
1fd5			FORTH_FALSE: equ 0 
1fd5			 
1fd5			if FORTH_PARSEV4 
1fd5			include "forth_stackops.asm" 
1fd5			endif 
1fd5			 
1fd5			if FORTH_PARSEV5 
1fd5			include "forth_stackopsv5.asm" 
1fd5			 
1fd5			; Stack operations for v5 parser on wards 
1fd5			; * DATA stack 
1fd5			; * LOOP stack 
1fd5			; * RETURN stack 
1fd5			 
1fd5			 
1fd5			 
1fd5			FORTH_CHK_DSP_UNDER: macro 
1fd5				push hl 
1fd5				push de 
1fd5				ld hl,(cli_data_sp) 
1fd5				ld de, cli_data_stack 
1fd5				call cmp16 
1fd5				jp c, fault_dsp_under 
1fd5				pop de 
1fd5				pop hl 
1fd5				endm 
1fd5			 
1fd5			 
1fd5			FORTH_CHK_RSP_UNDER: macro 
1fd5				push hl 
1fd5				push de 
1fd5				ld hl,(cli_ret_sp) 
1fd5				ld de, cli_ret_stack 
1fd5				call cmp16 
1fd5				jp c, fault_rsp_under 
1fd5				pop de 
1fd5				pop hl 
1fd5				endm 
1fd5			 
1fd5			FORTH_CHK_LOOP_UNDER: macro 
1fd5				push hl 
1fd5				push de 
1fd5				ld hl,(cli_loop_sp) 
1fd5				ld de, cli_loop_stack 
1fd5				call cmp16 
1fd5				jp c, fault_loop_under 
1fd5				pop de 
1fd5				pop hl 
1fd5				endm 
1fd5			 
1fd5			FORTH_ERR_TOS_NOTSTR: macro 
1fd5				; TOSO might need more for checks when used 
1fd5				push af 
1fd5				ld a,(hl) 
1fd5				cp DS_TYPE_STR 
1fd5				jp nz, type_faultn   
1fd5				pop af 
1fd5				endm 
1fd5			 
1fd5			FORTH_ERR_TOS_NOTNUM: macro 
1fd5				push af 
1fd5				ld a,(hl) 
1fd5				cp DS_TYPE_INUM 
1fd5				jp nz, type_faultn   
1fd5				pop af 
1fd5				endm 
1fd5			 
1fd5			 
1fd5			; increase data stack pointer and save hl to it 
1fd5				 
1fd5			FORTH_DSP_NEXT: macro 
1fd5				call macro_forth_dsp_next 
1fd5				endm 
1fd5			 
1fd5			 
1fd5			macro_forth_dsp_next: 
1fd5				if DEBUG_FORTH_STACK_GUARD 
1fd5 cd 1e 6c				call check_stacks 
1fd8				endif 
1fd8 e5				push hl 
1fd9 d5				push de 
1fda eb				ex de,hl 
1fdb 2a 23 f9			ld hl,(cli_data_sp) 
1fde 23				inc hl 
1fdf 23				inc hl 
1fe0			 
1fe0			; PARSEV5 
1fe0 23				inc hl 
1fe1 22 23 f9			ld (cli_data_sp),hl 
1fe4 73				ld (hl), e 
1fe5 23				inc hl 
1fe6 72				ld (hl), d 
1fe7 d1				pop de 
1fe8 e1				pop hl 
1fe9				if DEBUG_FORTH_STACK_GUARD 
1fe9 cd 1e 6c				call check_stacks 
1fec				endif 
1fec c9				ret 
1fed			 
1fed			 
1fed			; increase ret stack pointer and save hl to it 
1fed				 
1fed			FORTH_RSP_NEXT: macro 
1fed				call macro_forth_rsp_next 
1fed				endm 
1fed			 
1fed			macro_forth_rsp_next: 
1fed				if DEBUG_FORTH_STACK_GUARD 
1fed cd 1e 6c				call check_stacks 
1ff0				endif 
1ff0 e5				push hl 
1ff1 d5				push de 
1ff2 eb				ex de,hl 
1ff3 2a 27 f9			ld hl,(cli_ret_sp) 
1ff6 23				inc hl 
1ff7 23				inc hl 
1ff8 22 27 f9			ld (cli_ret_sp),hl 
1ffb 73				ld (hl), e 
1ffc 23				inc hl 
1ffd 72				ld (hl), d 
1ffe d1				pop de 
1fff e1				pop hl 
2000				if DEBUG_FORTH_STACK_GUARD 
2000 cd 1e 6c				call check_stacks 
2003				endif 
2003 c9				ret 
2004			 
2004			; get current ret stack pointer and save to hl  
2004				 
2004			FORTH_RSP_TOS: macro 
2004				call macro_forth_rsp_tos 
2004				endm 
2004			 
2004			macro_forth_rsp_tos: 
2004				;push de 
2004 2a 27 f9			ld hl,(cli_ret_sp) 
2007 cd 3f 20			call loadhlptrtohl 
200a				;ld e, (hl) 
200a				;inc hl 
200a				;ld d, (hl) 
200a				;ex de, hl 
200a					if DEBUG_FORTH_WORDS 
200a			;			DMARK "RST" 
200a						CALLMONITOR 
200a cd aa fd			call debug_vector  
200d				endm  
# End of macro CALLMONITOR
200d					endif 
200d				;pop de 
200d c9				ret 
200e			 
200e			; pop ret stack pointer 
200e				 
200e			FORTH_RSP_POP: macro 
200e				call macro_forth_rsp_pop 
200e				endm 
200e			 
200e			 
200e			macro_forth_rsp_pop: 
200e				if DEBUG_FORTH_STACK_GUARD 
200e			;		DMARK "RPP" 
200e cd 1e 6c				call check_stacks 
2011					FORTH_CHK_RSP_UNDER 
2011 e5				push hl 
2012 d5				push de 
2013 2a 27 f9			ld hl,(cli_ret_sp) 
2016 11 e1 f8			ld de, cli_ret_stack 
2019 cd fc 0f			call cmp16 
201c da 35 6d			jp c, fault_rsp_under 
201f d1				pop de 
2020 e1				pop hl 
2021				endm 
# End of macro FORTH_CHK_RSP_UNDER
2021				endif 
2021 e5				push hl 
2022 2a 27 f9			ld hl,(cli_ret_sp) 
2025			 
2025			 
2025				if FORTH_ENABLE_FREE 
2025			 
2025					; get pointer 
2025			 
2025					push de 
2025					push hl 
2025			 
2025					ld e, (hl) 
2025					inc hl 
2025					ld d, (hl) 
2025			 
2025					ex de, hl 
2025					call free 
2025			 
2025					pop hl 
2025					pop de 
2025			 
2025			 
2025				endif 
2025			 
2025			 
2025 2b				dec hl 
2026 2b				dec hl 
2027 22 27 f9			ld (cli_ret_sp), hl 
202a				; do stack underflow checks 
202a e1				pop hl 
202b				if DEBUG_FORTH_STACK_GUARD 
202b cd 1e 6c				call check_stacks 
202e					FORTH_CHK_RSP_UNDER 
202e e5				push hl 
202f d5				push de 
2030 2a 27 f9			ld hl,(cli_ret_sp) 
2033 11 e1 f8			ld de, cli_ret_stack 
2036 cd fc 0f			call cmp16 
2039 da 35 6d			jp c, fault_rsp_under 
203c d1				pop de 
203d e1				pop hl 
203e				endm 
# End of macro FORTH_CHK_RSP_UNDER
203e				endif 
203e c9				ret 
203f			 
203f			 
203f			 
203f			; routine to load word pointed to by hl into hl 
203f			 
203f			loadhlptrtohl: 
203f			 
203f d5				push de 
2040 5e				ld e, (hl) 
2041 23				inc hl 
2042 56				ld d, (hl) 
2043 eb				ex de, hl 
2044 d1				pop de 
2045			 
2045 c9				ret 
2046			 
2046			 
2046			 
2046			 
2046			 
2046			; push a number held in HL onto the data stack 
2046			; entry point for pushing a value when already in hl used in function above 
2046			 
2046			forth_push_numhl: 
2046			 
2046 e5				push hl    ; save value to push 
2047			 
2047			if DEBUG_FORTH_PUSH 
2047				; see if disabled 
2047			 
2047			 
2047 f5				push af 
2048 3a aa fd			ld a,(debug_vector) 
204b fe c9			cp $c9   ; ret 
204d			;	ld a, (os_view_disable) 
204d			;	cp '*' 
204d 28 34			jr z, .pskip2 
204f e5				push hl 
2050 e5			push hl 
2051 cd aa 0d			call clear_display 
2054 e1			pop hl 
2055 7c				ld a,h 
2056 21 fb f3			ld hl, os_word_scratch 
2059 cd e7 11			call hexout 
205c e1				pop hl 
205d 7d				ld a,l 
205e 21 fd f3			ld hl, os_word_scratch+2 
2061 cd e7 11			call hexout 
2064			 
2064 21 ff f3			ld hl, os_word_scratch+4 
2067 3e 00			ld a,0 
2069 77				ld (hl),a 
206a 11 fb f3			ld de,os_word_scratch 
206d 3e 28				ld a, display_row_2 
206f cd bd 0d				call str_at_display 
2072 11 2c 5e			ld de, .push_num 
2075 3e 00			ld a, display_row_1 
2077			 
2077 cd bd 0d				call str_at_display 
207a			 
207a			 
207a cd cd 0d			call update_display 
207d cd ed 0c			call delay1s 
2080 cd ed 0c			call delay1s 
2083			.pskip2:  
2083			 
2083 f1				pop af 
2084			endif	 
2084			 
2084			 
2084				FORTH_DSP_NEXT 
2084 cd d5 1f			call macro_forth_dsp_next 
2087				endm 
# End of macro FORTH_DSP_NEXT
2087			 
2087 2a 23 f9			ld hl, (cli_data_sp) 
208a			 
208a				; save item type 
208a 3e 02			ld a,  DS_TYPE_INUM 
208c 77				ld (hl), a 
208d 23				inc hl 
208e			 
208e				; get word off stack 
208e d1				pop de 
208f 7b				ld a,e 
2090 77				ld (hl), a 
2091 23				inc hl 
2092 7a				ld a,d 
2093 77				ld (hl), a 
2094			 
2094			if DEBUG_FORTH_PUSH 
2094 2b				dec hl 
2095 2b				dec hl 
2096 2b				dec hl 
2097						DMARK "PH5" 
2097 f5				push af  
2098 3a ac 20			ld a, (.dmark)  
209b 32 a0 fd			ld (debug_mark),a  
209e 3a ad 20			ld a, (.dmark+1)  
20a1 32 a1 fd			ld (debug_mark+1),a  
20a4 3a ae 20			ld a, (.dmark+2)  
20a7 32 a2 fd			ld (debug_mark+2),a  
20aa 18 03			jr .pastdmark  
20ac ..			.dmark: db "PH5"  
20af f1			.pastdmark: pop af  
20b0			endm  
# End of macro DMARK
20b0				CALLMONITOR 
20b0 cd aa fd			call debug_vector  
20b3				endm  
# End of macro CALLMONITOR
20b3			endif	 
20b3			 
20b3 c9				ret 
20b4			 
20b4			 
20b4			; Push a string to stack pointed to by hl 
20b4			 
20b4			forth_push_str: 
20b4			 
20b4			if DEBUG_FORTH_PUSH 
20b4						DMARK "PSQ" 
20b4 f5				push af  
20b5 3a c9 20			ld a, (.dmark)  
20b8 32 a0 fd			ld (debug_mark),a  
20bb 3a ca 20			ld a, (.dmark+1)  
20be 32 a1 fd			ld (debug_mark+1),a  
20c1 3a cb 20			ld a, (.dmark+2)  
20c4 32 a2 fd			ld (debug_mark+2),a  
20c7 18 03			jr .pastdmark  
20c9 ..			.dmark: db "PSQ"  
20cc f1			.pastdmark: pop af  
20cd			endm  
# End of macro DMARK
20cd				CALLMONITOR 
20cd cd aa fd			call debug_vector  
20d0				endm  
# End of macro CALLMONITOR
20d0			endif	 
20d0			 
20d0			 
20d0			    
20d0 e5				push hl 
20d1 e5				push hl 
20d2			 
20d2			;	ld a, 0   ; find end of string 
20d2 cd 44 13			call strlenz 
20d5			if DEBUG_FORTH_PUSH 
20d5						DMARK "PQ2" 
20d5 f5				push af  
20d6 3a ea 20			ld a, (.dmark)  
20d9 32 a0 fd			ld (debug_mark),a  
20dc 3a eb 20			ld a, (.dmark+1)  
20df 32 a1 fd			ld (debug_mark+1),a  
20e2 3a ec 20			ld a, (.dmark+2)  
20e5 32 a2 fd			ld (debug_mark+2),a  
20e8 18 03			jr .pastdmark  
20ea ..			.dmark: db "PQ2"  
20ed f1			.pastdmark: pop af  
20ee			endm  
# End of macro DMARK
20ee				CALLMONITOR 
20ee cd aa fd			call debug_vector  
20f1				endm  
# End of macro CALLMONITOR
20f1			endif	 
20f1 eb				ex de, hl 
20f2 e1				pop hl   ; get ptr to start of string 
20f3			if DEBUG_FORTH_PUSH 
20f3						DMARK "PQ3" 
20f3 f5				push af  
20f4 3a 08 21			ld a, (.dmark)  
20f7 32 a0 fd			ld (debug_mark),a  
20fa 3a 09 21			ld a, (.dmark+1)  
20fd 32 a1 fd			ld (debug_mark+1),a  
2100 3a 0a 21			ld a, (.dmark+2)  
2103 32 a2 fd			ld (debug_mark+2),a  
2106 18 03			jr .pastdmark  
2108 ..			.dmark: db "PQ3"  
210b f1			.pastdmark: pop af  
210c			endm  
# End of macro DMARK
210c				CALLMONITOR 
210c cd aa fd			call debug_vector  
210f				endm  
# End of macro CALLMONITOR
210f			endif	 
210f 19				add hl,de 
2110			if DEBUG_FORTH_PUSH 
2110						DMARK "PQE" 
2110 f5				push af  
2111 3a 25 21			ld a, (.dmark)  
2114 32 a0 fd			ld (debug_mark),a  
2117 3a 26 21			ld a, (.dmark+1)  
211a 32 a1 fd			ld (debug_mark+1),a  
211d 3a 27 21			ld a, (.dmark+2)  
2120 32 a2 fd			ld (debug_mark+2),a  
2123 18 03			jr .pastdmark  
2125 ..			.dmark: db "PQE"  
2128 f1			.pastdmark: pop af  
2129			endm  
# End of macro DMARK
2129				CALLMONITOR 
2129 cd aa fd			call debug_vector  
212c				endm  
# End of macro CALLMONITOR
212c			endif	 
212c			 
212c 2b				dec hl    ; see if there is an optional trailing double quote 
212d 7e				ld a,(hl) 
212e fe 22			cp '"' 
2130 20 03			jr nz, .strnoq 
2132 3e 00			ld a, 0      ; get rid of double quote 
2134 77				ld (hl), a 
2135 23			.strnoq: inc hl 
2136			 
2136 3e 00			ld a, 0 
2138 77				ld (hl), a     ; add null term and get rid of trailing double quote 
2139			 
2139 13				inc de ; add one for the type string 
213a 13				inc de ; add one for null term??? 
213b			 
213b				; tos is get string pointer again 
213b				; de contains space to allocate 
213b				 
213b d5				push de 
213c			 
213c eb				ex de, hl 
213d			 
213d				;push af 
213d			 
213d			if DEBUG_FORTH_PUSH 
213d						DMARK "PHm" 
213d f5				push af  
213e 3a 52 21			ld a, (.dmark)  
2141 32 a0 fd			ld (debug_mark),a  
2144 3a 53 21			ld a, (.dmark+1)  
2147 32 a1 fd			ld (debug_mark+1),a  
214a 3a 54 21			ld a, (.dmark+2)  
214d 32 a2 fd			ld (debug_mark+2),a  
2150 18 03			jr .pastdmark  
2152 ..			.dmark: db "PHm"  
2155 f1			.pastdmark: pop af  
2156			endm  
# End of macro DMARK
2156				CALLMONITOR 
2156 cd aa fd			call debug_vector  
2159				endm  
# End of macro CALLMONITOR
2159			endif	 
2159 cd b9 13			call malloc	; on ret hl now contains allocated memory 
215c				if DEBUG_FORTH_MALLOC_GUARD 
215c cc 84 5e				call z,malloc_error 
215f				endif 
215f			 
215f				 
215f c1				pop bc    ; get length 
2160 d1				pop de   ;  get string start    
2161			 
2161				; hl has destination from malloc 
2161			 
2161 eb				ex de, hl    ; prep for ldir 
2162			 
2162 d5				push de   ; save malloc area for DSP later 
2163				;push hl   ; save malloc area for DSP later 
2163			 
2163			if DEBUG_FORTH_PUSH 
2163						DMARK "PHc" 
2163 f5				push af  
2164 3a 78 21			ld a, (.dmark)  
2167 32 a0 fd			ld (debug_mark),a  
216a 3a 79 21			ld a, (.dmark+1)  
216d 32 a1 fd			ld (debug_mark+1),a  
2170 3a 7a 21			ld a, (.dmark+2)  
2173 32 a2 fd			ld (debug_mark+2),a  
2176 18 03			jr .pastdmark  
2178 ..			.dmark: db "PHc"  
217b f1			.pastdmark: pop af  
217c			endm  
# End of macro DMARK
217c				CALLMONITOR 
217c cd aa fd			call debug_vector  
217f				endm  
# End of macro CALLMONITOR
217f			endif	 
217f			 
217f			 
217f ed b0			ldir 
2181			 
2181			 
2181				; push malloc to data stack     macro?????  
2181			 
2181				FORTH_DSP_NEXT 
2181 cd d5 1f			call macro_forth_dsp_next 
2184				endm 
# End of macro FORTH_DSP_NEXT
2184			 
2184				; save value and type 
2184			 
2184 2a 23 f9			ld hl, (cli_data_sp) 
2187			 
2187				; save item type 
2187 3e 01			ld a,  DS_TYPE_STR 
2189 77				ld (hl), a 
218a 23				inc hl 
218b			 
218b				; get malloc word off stack 
218b d1				pop de 
218c 73				ld (hl), e 
218d 23				inc hl 
218e 72				ld (hl), d 
218f			 
218f			 
218f			 
218f			if DEBUG_FORTH_PUSH 
218f 2a 23 f9			ld hl, (cli_data_sp) 
2192						DMARK "PHS" 
2192 f5				push af  
2193 3a a7 21			ld a, (.dmark)  
2196 32 a0 fd			ld (debug_mark),a  
2199 3a a8 21			ld a, (.dmark+1)  
219c 32 a1 fd			ld (debug_mark+1),a  
219f 3a a9 21			ld a, (.dmark+2)  
21a2 32 a2 fd			ld (debug_mark+2),a  
21a5 18 03			jr .pastdmark  
21a7 ..			.dmark: db "PHS"  
21aa f1			.pastdmark: pop af  
21ab			endm  
# End of macro DMARK
21ab				CALLMONITOR 
21ab cd aa fd			call debug_vector  
21ae				endm  
# End of macro CALLMONITOR
21ae			;	ex de,hl 
21ae			endif	 
21ae				; in case of spaces, skip the ptr past the copied string 
21ae				;pop af 
21ae				;ld (cli_origptr),hl 
21ae			 
21ae c9				ret 
21af			 
21af			 
21af			 
21af			; TODO ascii push input onto stack given hl to start of input 
21af			 
21af			; identify type 
21af			; if starts with a " then a string 
21af			; otherwise it is a number 
21af			;  
21af			; if a string 
21af			;     scan for ending " to get length of string to malloc for + 1 
21af			;     malloc 
21af			;     put pointer to string on stack first byte flags as string 
21af			; 
21af			; else a number 
21af			;    look for number format identifier 
21af			;    $xx hex 
21af			;    %xxxxx bin 
21af			;    xxxxx decimal 
21af			;    convert number to 16bit word.  
21af			;    malloc word + 1 with flag to identiy as num 
21af			;    put pointer to number on stack 
21af			;   
21af			;  
21af			  
21af			forth_apush: 
21af				; kernel push 
21af			 
21af			if DEBUG_FORTH_PUSH 
21af						DMARK "PSH" 
21af f5				push af  
21b0 3a c4 21			ld a, (.dmark)  
21b3 32 a0 fd			ld (debug_mark),a  
21b6 3a c5 21			ld a, (.dmark+1)  
21b9 32 a1 fd			ld (debug_mark+1),a  
21bc 3a c6 21			ld a, (.dmark+2)  
21bf 32 a2 fd			ld (debug_mark+2),a  
21c2 18 03			jr .pastdmark  
21c4 ..			.dmark: db "PSH"  
21c7 f1			.pastdmark: pop af  
21c8			endm  
# End of macro DMARK
21c8				CALLMONITOR 
21c8 cd aa fd			call debug_vector  
21cb				endm  
# End of macro CALLMONITOR
21cb			endif	 
21cb				; identify input type 
21cb			 
21cb 7e				ld a,(hl) 
21cc			 
21cc fe 23			cp '#' 
21ce ca 08 22			jp z, .fapdec 
21d1			 
21d1			 
21d1 fe 22			cp '"' 
21d3 28 0a			jr z, .fapstr 
21d5 fe 24			cp '$' 
21d7 ca ff 21			jp z, .faphex 
21da fe 25			cp '%' 
21dc ca e7 21			jp z, .fapbin 
21df			;	cp 'b' 
21df			;	jp z, .fabin 
21df				; else decimal 
21df			 
21df				; TODO do decimal conversion 
21df				; decimal is stored as a 16bit word 
21df			 
21df				; by default everything is a string if type is not detected 
21df			.fapstr: ; 
21df fe 22			cp '"' 
21e1 20 01			jr nz, .strnoqu 
21e3 23				inc hl 
21e4			.strnoqu: 
21e4 c3 b4 20			jp forth_push_str 
21e7			 
21e7			 
21e7			 
21e7			.fapbin:    ; push a binary string.  
21e7 11 00 00			ld de, 0   ; hold a 16bit value 
21ea			 
21ea 23			.fapbinshift:	inc hl  
21eb 7e				ld a,(hl) 
21ec fe 00			cp 0     ; done scanning  
21ee 28 0b			jr z, .fapbdone  	; got it in HL so push  
21f0			 
21f0				; left shift de 
21f0 eb				ex de, hl	 
21f1 29				add hl, hl 
21f2			 
21f2				; is 1 
21f2 fe 31			cp '1' 
21f4 20 02			jr nz, .binzero 
21f6 cb 4d			bit 1, l 
21f8			.binzero: 
21f8 eb				ex de, hl	 ; save current de 
21f9 18 ef			jr .fapbinshift 
21fb			 
21fb			.fapbdone: 
21fb eb				ex de, hl 
21fc c3 46 20			jp forth_push_numhl 
21ff			 
21ff			 
21ff			.faphex:   ; hex is always stored as a 16bit word 
21ff				; skip number prefix 
21ff 23				inc hl 
2200				; turn ascii into number 
2200 cd 9d 12			call get_word_hl	; ret 16bit word in hl 
2203			 
2203 c3 46 20			jp forth_push_numhl 
2206			 
2206 00				 nop 
2207			 
2207			.fabin:   ; TODO bin conversion 
2207			 
2207			 
2207 c9				ret 
2208			.fapdec:	 
2208				; string to dec conversion 
2208 23				inc hl 
2209 eb				ex de, hl 
220a cd db 12			call string_to_uint16 
220d c3 46 20			jp forth_push_numhl 
2210 c9				ret 
2211				 
2211			;atoui_16: 
2211			 
2211			; get either a string ptr or a 16bit word from the data stack 
2211			 
2211			FORTH_DSP: macro 
2211				call macro_forth_dsp 
2211				endm 
2211			 
2211			macro_forth_dsp: 
2211				; data stack pointer points to current word on tos 
2211			 
2211 2a 23 f9			ld hl,(cli_data_sp) 
2214			 
2214				if DEBUG_FORTH_PUSH 
2214						DMARK "DSP" 
2214 f5				push af  
2215 3a 29 22			ld a, (.dmark)  
2218 32 a0 fd			ld (debug_mark),a  
221b 3a 2a 22			ld a, (.dmark+1)  
221e 32 a1 fd			ld (debug_mark+1),a  
2221 3a 2b 22			ld a, (.dmark+2)  
2224 32 a2 fd			ld (debug_mark+2),a  
2227 18 03			jr .pastdmark  
2229 ..			.dmark: db "DSP"  
222c f1			.pastdmark: pop af  
222d			endm  
# End of macro DMARK
222d			 
222d cd b7 5e				call display_data_sp 
2230				;call break_point_state 
2230				;rst 030h 
2230				CALLMONITOR 
2230 cd aa fd			call debug_vector  
2233				endm  
# End of macro CALLMONITOR
2233				endif 
2233			 
2233 c9				ret 
2234			 
2234			; return hl to start of value on stack 
2234			 
2234			FORTH_DSP_VALUE: macro 
2234				call macro_forth_dsp_value 
2234				endm 
2234			 
2234			macro_forth_dsp_value: 
2234			 
2234				FORTH_DSP 
2234 cd 11 22			call macro_forth_dsp 
2237				endm 
# End of macro FORTH_DSP
2237			 
2237 d5				push de 
2238			 
2238 23				inc hl ; skip type 
2239			 
2239 5e				ld e, (hl) 
223a 23				inc hl 
223b 56				ld d, (hl) 
223c eb				ex de,hl  
223d			 
223d d1				pop de 
223e			 
223e c9				ret 
223f			 
223f			; return hl to start of value to second item on stack 
223f			 
223f			FORTH_DSP_VALUEM1: macro 
223f				call macro_forth_dsp_value_m1 
223f				endm 
223f			 
223f			macro_forth_dsp_value_m1: 
223f			 
223f				FORTH_DSP 
223f cd 11 22			call macro_forth_dsp 
2242				endm 
# End of macro FORTH_DSP
2242			 
2242 2b				dec hl 
2243 2b				dec hl 
2244			;	dec hl 
2244			 
2244 d5				push de 
2245			 
2245 5e				ld e, (hl) 
2246 23				inc hl 
2247 56				ld d, (hl) 
2248 eb				ex de,hl  
2249			 
2249 d1				pop de 
224a			 
224a c9				ret 
224b			 
224b				 
224b			 
224b			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
224b			 
224b			FORTH_DSP_POP: macro 
224b				call macro_forth_dsp_pop 
224b				endm 
224b			 
224b			 
224b			; get the tos data type 
224b			 
224b			FORTH_DSP_TYPE:   macro 
224b			 
224b				;FORTH_DSP_VALUE 
224b				FORTH_DSP 
224b				 
224b				; hl points to value 
224b				; check type 
224b			 
224b				ld a,(hl) 
224b			 
224b				endm 
224b			 
224b			; load the tos value into hl 
224b			 
224b			 
224b			FORTH_DSP_VALUEHL:  macro 
224b				call macro_dsp_valuehl 
224b				endm 
224b			 
224b			 
224b			 
224b			macro_dsp_valuehl: 
224b				FORTH_DSP_VALUE 
224b cd 34 22			call macro_forth_dsp_value 
224e				endm 
# End of macro FORTH_DSP_VALUE
224e			 
224e				;FORTH_ERR_TOS_NOTNUM 
224e			 
224e				;inc hl   ; skip type id 
224e			 
224e			;	push de 
224e			; 
224e			;	ld e, (hl) 
224e			;	inc hl 
224e			;	ld d, (hl) 
224e			;	ex de,hl  
224e			 
224e			;	pop de 
224e			 
224e				if DEBUG_FORTH_PUSH 
224e						DMARK "DVL" 
224e f5				push af  
224f 3a 63 22			ld a, (.dmark)  
2252 32 a0 fd			ld (debug_mark),a  
2255 3a 64 22			ld a, (.dmark+1)  
2258 32 a1 fd			ld (debug_mark+1),a  
225b 3a 65 22			ld a, (.dmark+2)  
225e 32 a2 fd			ld (debug_mark+2),a  
2261 18 03			jr .pastdmark  
2263 ..			.dmark: db "DVL"  
2266 f1			.pastdmark: pop af  
2267			endm  
# End of macro DMARK
2267				CALLMONITOR 
2267 cd aa fd			call debug_vector  
226a				endm  
# End of macro CALLMONITOR
226a				endif 
226a c9				ret 
226b			 
226b			forth_apushstrhl:      
226b				; push of string requires use of cli_origptr 
226b				; bodge use 
226b			 
226b				; get current cli_origptr, save, update with temp pointer  
226b ed 5b 73 f9		ld de, (cli_origptr) 
226f 22 73 f9			ld (cli_origptr), hl 
2272 d5				push de 
2273 cd af 21			call forth_apush 
2276 d1				pop de 
2277 ed 53 73 f9		ld (cli_origptr), de 
227b c9			        ret	 
227c			 
227c			 
227c			; increase loop stack pointer and save hl to it 
227c				 
227c			FORTH_LOOP_NEXT: macro 
227c				call macro_forth_loop_next 
227c				;nop 
227c				endm 
227c			 
227c			macro_forth_loop_next: 
227c				if DEBUG_FORTH_STACK_GUARD 
227c cd 1e 6c				call check_stacks 
227f				endif 
227f e5				push hl 
2280 d5				push de 
2281 eb				ex de,hl 
2282 2a 25 f9			ld hl,(cli_loop_sp) 
2285 23				inc hl 
2286 23				inc hl 
2287					if DEBUG_FORTH_WORDS 
2287						DMARK "LNX" 
2287 f5				push af  
2288 3a 9c 22			ld a, (.dmark)  
228b 32 a0 fd			ld (debug_mark),a  
228e 3a 9d 22			ld a, (.dmark+1)  
2291 32 a1 fd			ld (debug_mark+1),a  
2294 3a 9e 22			ld a, (.dmark+2)  
2297 32 a2 fd			ld (debug_mark+2),a  
229a 18 03			jr .pastdmark  
229c ..			.dmark: db "LNX"  
229f f1			.pastdmark: pop af  
22a0			endm  
# End of macro DMARK
22a0						CALLMONITOR 
22a0 cd aa fd			call debug_vector  
22a3				endm  
# End of macro CALLMONITOR
22a3					endif 
22a3 22 25 f9			ld (cli_loop_sp),hl 
22a6 73				ld (hl), e 
22a7 23				inc hl 
22a8 72				ld (hl), d 
22a9 d1				pop de    ; been reversed so save a swap on restore 
22aa e1				pop hl 
22ab				if DEBUG_FORTH_STACK_GUARD 
22ab cd 1e 6c				call check_stacks 
22ae				endif 
22ae c9				ret 
22af			 
22af			; get current ret stack pointer and save to hl  
22af				 
22af			FORTH_LOOP_TOS: macro 
22af				call macro_forth_loop_tos 
22af				endm 
22af			 
22af			macro_forth_loop_tos: 
22af d5				push de 
22b0 2a 25 f9			ld hl,(cli_loop_sp) 
22b3 5e				ld e, (hl) 
22b4 23				inc hl 
22b5 56				ld d, (hl) 
22b6 eb				ex de, hl 
22b7 d1				pop de 
22b8 c9				ret 
22b9			 
22b9			; pop loop stack pointer 
22b9				 
22b9			FORTH_LOOP_POP: macro 
22b9				call macro_forth_loop_pop 
22b9				endm 
22b9			 
22b9			 
22b9			macro_forth_loop_pop: 
22b9				if DEBUG_FORTH_STACK_GUARD 
22b9					DMARK "LPP" 
22b9 f5				push af  
22ba 3a ce 22			ld a, (.dmark)  
22bd 32 a0 fd			ld (debug_mark),a  
22c0 3a cf 22			ld a, (.dmark+1)  
22c3 32 a1 fd			ld (debug_mark+1),a  
22c6 3a d0 22			ld a, (.dmark+2)  
22c9 32 a2 fd			ld (debug_mark+2),a  
22cc 18 03			jr .pastdmark  
22ce ..			.dmark: db "LPP"  
22d1 f1			.pastdmark: pop af  
22d2			endm  
# End of macro DMARK
22d2 cd 1e 6c				call check_stacks 
22d5					FORTH_CHK_LOOP_UNDER 
22d5 e5				push hl 
22d6 d5				push de 
22d7 2a 25 f9			ld hl,(cli_loop_sp) 
22da 11 5f f8			ld de, cli_loop_stack 
22dd cd fc 0f			call cmp16 
22e0 da 3b 6d			jp c, fault_loop_under 
22e3 d1				pop de 
22e4 e1				pop hl 
22e5				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22e5				endif 
22e5 e5				push hl 
22e6 2a 25 f9			ld hl,(cli_loop_sp) 
22e9 2b				dec hl 
22ea 2b				dec hl 
22eb 22 25 f9			ld (cli_loop_sp), hl 
22ee				; TODO do stack underflow checks 
22ee e1				pop hl 
22ef				if DEBUG_FORTH_STACK_GUARD 
22ef cd 1e 6c				call check_stacks 
22f2					FORTH_CHK_LOOP_UNDER 
22f2 e5				push hl 
22f3 d5				push de 
22f4 2a 25 f9			ld hl,(cli_loop_sp) 
22f7 11 5f f8			ld de, cli_loop_stack 
22fa cd fc 0f			call cmp16 
22fd da 3b 6d			jp c, fault_loop_under 
2300 d1				pop de 
2301 e1				pop hl 
2302				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2302				endif 
2302 c9				ret 
2303			 
2303			macro_forth_dsp_pop: 
2303			 
2303 e5				push hl 
2304			 
2304				; release malloc data 
2304			 
2304				if DEBUG_FORTH_STACK_GUARD 
2304 cd 1e 6c				call check_stacks 
2307					FORTH_CHK_DSP_UNDER 
2307 e5				push hl 
2308 d5				push de 
2309 2a 23 f9			ld hl,(cli_data_sp) 
230c 11 5d f6			ld de, cli_data_stack 
230f cd fc 0f			call cmp16 
2312 da 2f 6d			jp c, fault_dsp_under 
2315 d1				pop de 
2316 e1				pop hl 
2317				endm 
# End of macro FORTH_CHK_DSP_UNDER
2317				endif 
2317				;ld hl,(cli_data_sp) 
2317			if DEBUG_FORTH_DOT 
2317				DMARK "DPP" 
2317 f5				push af  
2318 3a 2c 23			ld a, (.dmark)  
231b 32 a0 fd			ld (debug_mark),a  
231e 3a 2d 23			ld a, (.dmark+1)  
2321 32 a1 fd			ld (debug_mark+1),a  
2324 3a 2e 23			ld a, (.dmark+2)  
2327 32 a2 fd			ld (debug_mark+2),a  
232a 18 03			jr .pastdmark  
232c ..			.dmark: db "DPP"  
232f f1			.pastdmark: pop af  
2330			endm  
# End of macro DMARK
2330				CALLMONITOR 
2330 cd aa fd			call debug_vector  
2333				endm  
# End of macro CALLMONITOR
2333			endif	 
2333			 
2333			 
2333			if FORTH_ENABLE_DSPPOPFREE 
2333			 
2333				FORTH_DSP 
2333 cd 11 22			call macro_forth_dsp 
2336				endm 
# End of macro FORTH_DSP
2336			 
2336 7e				ld a, (hl) 
2337 fe 01			cp DS_TYPE_STR 
2339 20 23			jr nz, .skippopfree 
233b			 
233b				FORTH_DSP_VALUEHL 
233b cd 4b 22			call macro_dsp_valuehl 
233e				endm 
# End of macro FORTH_DSP_VALUEHL
233e 00				nop 
233f			if DEBUG_FORTH_DOT 
233f				DMARK "DPf" 
233f f5				push af  
2340 3a 54 23			ld a, (.dmark)  
2343 32 a0 fd			ld (debug_mark),a  
2346 3a 55 23			ld a, (.dmark+1)  
2349 32 a1 fd			ld (debug_mark+1),a  
234c 3a 56 23			ld a, (.dmark+2)  
234f 32 a2 fd			ld (debug_mark+2),a  
2352 18 03			jr .pastdmark  
2354 ..			.dmark: db "DPf"  
2357 f1			.pastdmark: pop af  
2358			endm  
# End of macro DMARK
2358				CALLMONITOR 
2358 cd aa fd			call debug_vector  
235b				endm  
# End of macro CALLMONITOR
235b			endif	 
235b cd 83 14			call free 
235e			.skippopfree: 
235e				 
235e			 
235e			endif 
235e			 
235e			if DEBUG_FORTH_DOT_KEY 
235e				DMARK "DP2" 
235e				CALLMONITOR 
235e			endif	 
235e			 
235e				; move pointer down 
235e			 
235e 2a 23 f9			ld hl,(cli_data_sp) 
2361 2b				dec hl 
2362 2b				dec hl 
2363			; PARSEV5 
2363 2b				dec hl 
2364 22 23 f9			ld (cli_data_sp), hl 
2367			 
2367				if DEBUG_FORTH_STACK_GUARD 
2367 cd 1e 6c				call check_stacks 
236a					FORTH_CHK_DSP_UNDER 
236a e5				push hl 
236b d5				push de 
236c 2a 23 f9			ld hl,(cli_data_sp) 
236f 11 5d f6			ld de, cli_data_stack 
2372 cd fc 0f			call cmp16 
2375 da 2f 6d			jp c, fault_dsp_under 
2378 d1				pop de 
2379 e1				pop hl 
237a				endm 
# End of macro FORTH_CHK_DSP_UNDER
237a				endif 
237a			 
237a e1				pop hl 
237b			 
237b c9				ret 
237c			 
237c			getwordathl: 
237c				; hl points to an address 
237c				; load hl with the word at that address 
237c			 
237c d5				push de 
237d			 
237d 5e				ld e, (hl) 
237e 23				inc hl 
237f 56				ld d, (hl) 
2380 eb				ex de, hl 
2381			 
2381 d1				pop de 
2382 c9				ret 
2383			 
2383			 
2383			; functions to manuplite stack pointers 
2383			 
2383			; generate fragment to set hl to be pointer to a stack item 
2383			 
2383			FORTH_DSP_PTR: macro  x 
2383				ld hl,(cli_data_sp) 
2383				ld de, x * 3 
2383				sbc hl, de 
2383				endm 
2383			 
2383			 
2383			 
2383			; copy point in hl to stack tmp storage slots 1-4 
2383			hltostack1: 
2383 11 f3 f0			ld de, os_stack_1  
2386 c3 b1 23			jp hltostackmv 
2389			 
2389			hltostack2:  
2389 11 f0 f0			ld de, os_stack_2 
238c c3 b1 23			jp hltostackmv 
238f			 
238f			hltostack3:  
238f 11 ed f0			ld de, os_stack_3 
2392 c3 b1 23			jp hltostackmv 
2395			 
2395			hltostack4:  
2395 11 ea f0			ld de, os_stack_4  
2398 c3 b1 23			jp hltostackmv 
239b			 
239b			; copy to point in hl from stack tmp storage slots 1-4 
239b			hlfromstack1: 
239b 11 f3 f0			ld de, os_stack_1 
239e c3 b0 23			jp hlfromsttackmv 
23a1			 
23a1			hlfromstack2:  
23a1 11 f0 f0			ld de, os_stack_2 
23a4 c3 b0 23			jp hlfromsttackmv 
23a7			 
23a7			hlfromstack3:  
23a7 11 ed f0			ld de, os_stack_3 
23aa c3 b0 23			jp hlfromsttackmv 
23ad			 
23ad			hlfromstack4:  
23ad 11 ea f0			ld de, os_stack_4 
23b0			 
23b0			hlfromsttackmv: 
23b0 eb				ex de, hl 
23b1			 
23b1			hltostackmv: 
23b1			 
23b1				; do stack move 
23b1 c5				push bc 
23b2 01 03 00			ld bc, 3 
23b5 ed b0			ldir  
23b7 c1				pop bc	 
23b8 c9				ret 
23b9			 
23b9			; eof 
23b9			 
# End of file forth_stackopsv5.asm
23b9			endif 
23b9			 
23b9			loadwordinhl:	 
23b9			 
23b9 d5				push de 
23ba			 
23ba 5e				ld e, (hl) 
23bb 23				inc hl 
23bc 56				ld d, (hl) 
23bd eb				ex de,hl  
23be			 
23be d1				pop de 
23bf			 
23bf c9				ret 
23c0			 
23c0			user_word_eol:  
23c0				; hl contains the pointer to where to create a linked list item from the end 
23c0				; of the user dict to continue on at the system word dict 
23c0				 
23c0				; poke the stub of the word list linked list to repoint to rom words 
23c0			 
23c0				; stub format 
23c0				; db   word id 
23c0				; dw    link to next word 
23c0			        ; db char length of token 
23c0				; db string + 0 term 
23c0				; db exec code....  
23c0			 
23c0 3e 00			ld a, WORD_SYS_ROOT     ; root word 
23c2 77				ld (hl), a		; word id 
23c3 23				inc hl 
23c4			 
23c4 11 8f 25			ld de, sysdict 
23c7 73				ld (hl), e		; next word link ie system dict 
23c8 23				inc hl 
23c9 72				ld (hl), d		; next word link ie system dict 
23ca 23				inc hl	 
23cb			 
23cb			;	ld (hl), sysdict		; next word link ie system dict 
23cb			;	inc hl 
23cb			;	inc hl 
23cb			 
23cb			;	inc hl 
23cb			;	inc hl 
23cb			 
23cb 3e 02			ld a, 2			; word length is 0 
23cd 77				ld (hl), a	 
23ce 23				inc hl 
23cf			 
23cf 3e 7e			ld a, '~'			; word length is 0 
23d1 77				ld (hl), a	 
23d2 23				inc hl 
23d3 3e 00			ld a, 0			; save empty word 
23d5 77				ld (hl), a 
23d6			 
23d6 c9				ret 
23d7			 
23d7				 
23d7			 
23d7			forthexec_cleanup: 
23d7				FORTH_RSP_POP 
23d7 cd 0e 20			call macro_forth_rsp_pop 
23da				endm 
# End of macro FORTH_RSP_POP
23da c9				ret 
23db			 
23db			forth_call_hl: 
23db				; taking hl 
23db e5				push hl 
23dc c9				ret 
23dd			 
23dd			; this is called to reset Forth system but keep existing uwords etc 
23dd			 
23dd			forth_warmstart: 
23dd				; setup stack over/under flow checks 
23dd				if DEBUG_FORTH_STACK_GUARD 
23dd cd 04 6c				call chk_stk_init 
23e0				endif 
23e0			 
23e0				; init stack pointers  - * these stacks go upwards *  
23e0 21 e1 f8			ld hl, cli_ret_stack 
23e3 22 27 f9			ld (cli_ret_sp), hl	 
23e6				; set bottom of stack 
23e6 3e 00			ld a,0 
23e8 77				ld (hl),a 
23e9 23				inc hl 
23ea 77				ld (hl),a 
23eb			 
23eb 21 5d f6			ld hl, cli_data_stack 
23ee 22 23 f9			ld (cli_data_sp), hl	 
23f1				; set bottom of stack 
23f1 3e 00			ld a,0 
23f3 77				ld (hl),a 
23f4 23				inc hl 
23f5 77				ld (hl),a 
23f6			 
23f6 21 5f f8			ld hl, cli_loop_stack 
23f9 22 25 f9			ld (cli_loop_sp), hl	 
23fc				; set bottom of stack 
23fc 3e 00			ld a,0 
23fe 77				ld (hl),a 
23ff 23				inc hl 
2400 77				ld (hl),a 
2401			 
2401				; init extent of current open file 
2401			 
2401 3e 00			ld a, 0 
2403 32 9f f9			ld (store_openext), a 
2406			 
2406 c9				ret 
2407			 
2407			 
2407			 
2407			; Cold Start - this is called to setup the whole Forth system 
2407			 
2407			forth_init: 
2407			 
2407				; setup stack over/under flow checks 
2407			 
2407			;	if DEBUG_FORTH_STACK_GUARD 
2407			;		call chk_stk_init 
2407			;	endif 
2407			 
2407				; enable auto display updates (slow.....) 
2407			 
2407 3e 01			ld a, 1 
2409 32 71 f9			ld (cli_autodisplay), a 
240c			 
240c				; if storage is in use disable long reads for now 
240c 3e 00			ld a, 0 
240e 32 aa f9			ld (store_longread), a 
2411			 
2411			 
2411				; show start up screen 
2411			 
2411 cd aa 0d			call clear_display 
2414			 
2414 3e 00			ld a,0 
2416 32 93 f9			ld (f_cursor_ptr), a 
2419			 
2419				; set start of word list in start of ram - for use when creating user words 
2419			 
2419 21 00 80			ld hl, baseram 
241c 22 f3 f3			ld (os_last_new_uword), hl 
241f cd c0 23			call user_word_eol 
2422				 
2422			;		call display_data_sp 
2422			;		call next_page_prompt 
2422			 
2422			 
2422			 
2422			 
2422 c9				ret 
2423			 
2423 .. 00		.bootforth: db " Forth Kernel Init ",0 
2437			 
2437			; TODO push to stack 
2437			 
2437			;  
2437			 
2437			if FORTH_PARSEV2 
2437			 
2437			 
2437				include "forth_parserv2.asm" 
2437			 
2437			endif 
2437			 
2437			 
2437			; parse cli version 1 
2437			 
2437			if FORTH_PARSEV1 
2437			 
2437			 
2437			 
2437			      include "forth_parserv1.asm" 
2437			endif 
2437				 
2437			if FORTH_PARSEV3 
2437			 
2437			 
2437			 
2437			      include "forth_parserv3.asm" 
2437				include "forth_wordsv3.asm" 
2437			endif 
2437			 
2437			if FORTH_PARSEV4 
2437			 
2437			 
2437			 
2437			      include "forth_parserv4.asm" 
2437				include "forth_wordsv4.asm" 
2437			endif 
2437			 
2437			if FORTH_PARSEV5 
2437			 
2437			 
2437			 
2437			      include "forth_parserv5.asm" 
2437			 
2437			 
2437			; A better parser without using malloc and string copies all over the place.  
2437			; Exec in situ should be faster 
2437			 
2437			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2437			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2437			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2437			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2437			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2437			WORD_SYS_END: equ 0   ; Opcode for all user words 
2437			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2437			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2437			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2437			 
2437			; Core word preamble macro 
2437			 
2437			CWHEAD:   macro nxtword opcode lit len opflags 
2437				db WORD_SYS_CORE+opcode             
2437				; internal op code number 
2437				dw nxtword            
2437				; link to next dict word block 
2437				db len + 1 
2437				; literal length of dict word inc zero term 
2437				db lit,0              
2437				; literal dict word 
2437			        ; TODO db opflags        
2437				endm 
2437			 
2437			 
2437			NEXTW: macro  
2437				jp macro_next 
2437				endm 
2437			 
2437			macro_next: 
2437			if DEBUG_FORTH_PARSE_KEY 
2437				DMARK "NXT" 
2437				CALLMONITOR 
2437			endif	 
2437			;	inc hl  ; skip token null term  
2437 ed 4b 75 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
243b ed 5b 73 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
243f 2a f7 f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2442			if DEBUG_FORTH_PARSE_KEY 
2442				DMARK "}AA" 
2442				CALLMONITOR 
2442			endif	 
2442 c3 45 25			jp execnext 
2445				;jp exec1 
2445			       
2445			 
2445			 
2445			; Another go at the parser to compile  
2445			 
2445			 
2445			; TODO rework parser to change all of the string words to byte tokens 
2445			; TODO do a search for  
2445			 
2445			; TODO first run normal parser to zero term sections 
2445			; TODO for each word do a token look up to get the op code 
2445			; TODO need some means to flag to the exec that this is a byte code form    
2445			 
2445			 
2445			forthcompile: 
2445			 
2445			; 
2445			; line parse: 
2445			;       parse raw input buffer 
2445			;       tokenise the words 
2445			;       malloc new copy (for looping etc) 
2445			;       copy to malloc + current pc in line to start of string and add line term 
2445			;       save on new rsp 
2445			; 
2445			 
2445			; hl to point to the line to tokenise 
2445			 
2445			;	push hl 
2445 22 f7 f3			ld (os_tok_ptr), hl  ; save ptr to string 
2448			 
2448			;	ld a,0		; string term on input 
2448			;	call strlent 
2448			 
2448			;	ld (os_tok_len), hl	 ; save string length 
2448			 
2448			;if DEBUG_FORTH_TOK 
2448			;	ex de,hl		 
2448			;endif 
2448			 
2448			;	pop hl 		; get back string pointer 
2448			 
2448			if DEBUG_FORTH_TOK 
2448						DMARK "TOc" 
2448				CALLMONITOR 
2448			endif 
2448 7e			.cptoken2:    ld a,(hl) 
2449 23				inc hl 
244a fe 7f			cp FORTH_END_BUFFER 
244c 28 29			jr z, .cptokendone2 
244e fe 00			cp 0 
2450 28 25			jr z, .cptokendone2 
2452 fe 22			cp '"' 
2454 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2456 fe 20			cp ' ' 
2458 20 ee			jr nz,  .cptoken2 
245a			 
245a			; TODO consume comments held between ( and ) 
245a			 
245a				; we have a space so change to zero term for dict match later 
245a 2b				dec hl 
245b 3e 00			ld a,0 
245d 77				ld (hl), a 
245e 23				inc hl 
245f 18 e7			jr .cptoken2 
2461				 
2461			 
2461			.cptokenstr2: 
2461				; skip all white space until either eol (because forgot to term) or end double quote 
2461			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2461				;inc hl ; skip current double quote 
2461 7e				ld a,(hl) 
2462 23				inc hl 
2463 fe 22			cp '"' 
2465 28 e1			jr z, .cptoken2 
2467 fe 7f			cp FORTH_END_BUFFER 
2469 28 0c			jr z, .cptokendone2 
246b fe 00			cp 0 
246d 28 08			jr z, .cptokendone2 
246f fe 20			cp ' ' 
2471 28 02			jr z, .cptmp2 
2473 18 ec			jr .cptokenstr2 
2475			 
2475			.cptmp2:	; we have a space so change to zero term for dict match later 
2475				;dec hl 
2475				;ld a,"-"	; TODO remove this when working 
2475				;ld (hl), a 
2475				;inc hl 
2475 18 ea			jr .cptokenstr2 
2477			 
2477			.cptokendone2: 
2477				;inc hl 
2477 3e 7f			ld a, FORTH_END_BUFFER 
2479 77				ld (hl),a 
247a 23				inc hl 
247b 3e 21			ld a, '!' 
247d 77				ld (hl),a 
247e			 
247e 2a f7 f3			ld hl,(os_tok_ptr) 
2481			         
2481			if DEBUG_FORTH_TOK 
2481						DMARK "Tc1" 
2481				CALLMONITOR 
2481			endif 
2481			 
2481				; push exec string to top of return stack 
2481				FORTH_RSP_NEXT 
2481 cd ed 1f			call macro_forth_rsp_next 
2484				endm 
# End of macro FORTH_RSP_NEXT
2484 c9				ret 
2485			 
2485			; Another go at the parser need to simplify the process 
2485			 
2485			forthparse: 
2485			 
2485			; 
2485			; line parse: 
2485			;       parse raw input buffer 
2485			;       tokenise the words 
2485			;       malloc new copy (for looping etc) 
2485			;       copy to malloc + current pc in line to start of string and add line term 
2485			;       save on new rsp 
2485			; 
2485			 
2485			; hl to point to the line to tokenise 
2485			 
2485			;	push hl 
2485 22 f7 f3			ld (os_tok_ptr), hl  ; save ptr to string 
2488			 
2488			;	ld a,0		; string term on input 
2488			;	call strlent 
2488			 
2488			;	ld (os_tok_len), hl	 ; save string length 
2488			 
2488			;if DEBUG_FORTH_TOK 
2488			;	ex de,hl		 
2488			;endif 
2488			 
2488			;	pop hl 		; get back string pointer 
2488			 
2488			if DEBUG_FORTH_TOK 
2488						DMARK "TOK" 
2488				CALLMONITOR 
2488			endif 
2488 7e			.ptoken2:    ld a,(hl) 
2489 23				inc hl 
248a fe 7f			cp FORTH_END_BUFFER 
248c 28 29			jr z, .ptokendone2 
248e fe 00			cp 0 
2490 28 25			jr z, .ptokendone2 
2492 fe 22			cp '"' 
2494 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2496 fe 20			cp ' ' 
2498 20 ee			jr nz,  .ptoken2 
249a			 
249a			; TODO consume comments held between ( and ) 
249a			 
249a				; we have a space so change to zero term for dict match later 
249a 2b				dec hl 
249b 3e 00			ld a,0 
249d 77				ld (hl), a 
249e 23				inc hl 
249f 18 e7			jr .ptoken2 
24a1				 
24a1			 
24a1			.ptokenstr2: 
24a1				; skip all white space until either eol (because forgot to term) or end double quote 
24a1			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24a1				;inc hl ; skip current double quote 
24a1 7e				ld a,(hl) 
24a2 23				inc hl 
24a3 fe 22			cp '"' 
24a5 28 e1			jr z, .ptoken2 
24a7 fe 7f			cp FORTH_END_BUFFER 
24a9 28 0c			jr z, .ptokendone2 
24ab fe 00			cp 0 
24ad 28 08			jr z, .ptokendone2 
24af fe 20			cp ' ' 
24b1 28 02			jr z, .ptmp2 
24b3 18 ec			jr .ptokenstr2 
24b5			 
24b5			.ptmp2:	; we have a space so change to zero term for dict match later 
24b5				;dec hl 
24b5				;ld a,"-"	; TODO remove this when working 
24b5				;ld (hl), a 
24b5				;inc hl 
24b5 18 ea			jr .ptokenstr2 
24b7			 
24b7			.ptokendone2: 
24b7				;inc hl 
24b7 3e 7f			ld a, FORTH_END_BUFFER 
24b9 77				ld (hl),a 
24ba 23				inc hl 
24bb 3e 21			ld a, '!' 
24bd 77				ld (hl),a 
24be			 
24be 2a f7 f3			ld hl,(os_tok_ptr) 
24c1			         
24c1			if DEBUG_FORTH_TOK 
24c1						DMARK "TK1" 
24c1				CALLMONITOR 
24c1			endif 
24c1			 
24c1				; push exec string to top of return stack 
24c1				FORTH_RSP_NEXT 
24c1 cd ed 1f			call macro_forth_rsp_next 
24c4				endm 
# End of macro FORTH_RSP_NEXT
24c4 c9				ret 
24c5			 
24c5			; 
24c5			;	; malloc size + buffer pointer + if is loop flag 
24c5			;	ld hl,(os_tok_len) 		 ; get string length 
24c5			; 
24c5			;	ld a,l 
24c5			; 
24c5			;	cp 0			; we dont want to use a null string 
24c5			;	ret z 
24c5			; 
24c5			;;	add 3    ; prefix malloc with buffer for current word ptr 
24c5			; 
24c5			;	add 5     ; TODO when certain not over writing memory remove 
24c5			; 
24c5			;		 
24c5			; 
24c5			;if DEBUG_FORTH_TOK 
24c5			;			DMARK "TKE" 
24c5			;	CALLMONITOR 
24c5			;endif 
24c5			; 
24c5			;	ld l,a 
24c5			;	ld h,0 
24c5			;;	push hl   ; save required space for the copy later 
24c5			;	call malloc 
24c5			;if DEBUG_FORTH_TOK 
24c5			;			DMARK "TKM" 
24c5			;	CALLMONITOR 
24c5			;endif 
24c5			;	if DEBUG_FORTH_MALLOC_GUARD 
24c5			;		push af 
24c5			;		call ishlzero 
24c5			;;		ld a, l 
24c5			;;		add h 
24c5			;;		cp 0 
24c5			;		pop af 
24c5			;		 
24c5			;		call z,malloc_error 
24c5			;	endif 
24c5			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
24c5			; 
24c5			; 
24c5			;if DEBUG_FORTH_TOK 
24c5			;			DMARK "TKR" 
24c5			;	CALLMONITOR 
24c5			;endif 
24c5			; 
24c5			;	FORTH_RSP_NEXT 
24c5			; 
24c5			;	;inc hl	 ; go past current buffer pointer 
24c5			;	;inc hl 
24c5			;	;inc hl   ; and past if loop flag 
24c5			;		; TODO Need to set flag  
24c5			; 
24c5			;	 
24c5			;	 
24c5			;	ex de,hl	; malloc is dest 
24c5			;	ld hl, (os_tok_len) 
24c5			;;	pop bc 
24c5			;	ld c, l                
24c5			;	ld b,0 
24c5			;	ld hl, (os_tok_ptr) 
24c5			; 
24c5			;if DEBUG_FORTH_TOK 
24c5			;			DMARK "TKT" 
24c5			;	CALLMONITOR 
24c5			;endif 
24c5			; 
24c5			;	; do str cpy 
24c5			; 
24c5			;	ldir      ; copy byte in hl to de 
24c5			; 
24c5			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
24c5			; 
24c5			;if DEBUG_FORTH_TOK 
24c5			; 
24c5			;			DMARK "TKY" 
24c5			;	CALLMONITOR 
24c5			;endif 
24c5			;	;ld a,0 
24c5			;	;ld a,FORTH_END_BUFFER 
24c5			;	ex de, hl 
24c5			;	;dec hl			 ; go back over the space delim at the end of word 
24c5			;	;ld (hl),a 
24c5			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
24c5			;	ld a,FORTH_END_BUFFER 
24c5			;	ld (hl),a 
24c5			;	inc hl 
24c5			;	ld a,FORTH_END_BUFFER 
24c5			;	ld (hl),a 
24c5			; 
24c5			;	; init the malloc area data 
24c5			;	; set pc for in current area 
24c5			;	;ld hl, (os_tok_malloc) 
24c5			;	;inc hl 
24c5			;	;inc hl 
24c5			;	;inc hl 
24c5			;	;ex de,hl 
24c5			;	;ld hl, (os_tok_malloc) 
24c5			;	;ld (hl),e 
24c5			;	;inc hl 
24c5			;	;ld (hl),d 
24c5			; 
24c5			; 
24c5			;	ld hl,(os_tok_malloc) 
24c5			;if DEBUG_FORTH_PARSE_KEY 
24c5			;			DMARK "TKU" 
24c5			;	CALLMONITOR 
24c5			;endif 
24c5			; 
24c5			;	ret 
24c5			 
24c5			forthexec: 
24c5			 
24c5			; line exec: 
24c5			; forth parser 
24c5			 
24c5			; 
24c5			;       get current exec line on rsp 
24c5			 
24c5				FORTH_RSP_TOS 
24c5 cd 04 20			call macro_forth_rsp_tos 
24c8				endm 
# End of macro FORTH_RSP_TOS
24c8			 
24c8			;       restore current pc - hl points to malloc of data 
24c8			 
24c8				;ld e, (hl) 
24c8				;inc hl 
24c8				;ld d, (hl) 
24c8				;ex de,hl 
24c8			 
24c8			 
24c8			exec1: 
24c8 22 f7 f3			ld (os_tok_ptr), hl 
24cb			 
24cb				; copy our PC to working vars  
24cb 22 75 f9			ld (cli_ptr), hl 
24ce 22 73 f9			ld (cli_origptr), hl 
24d1			 
24d1 7e				ld a,(hl) 
24d2 fe 7f			cp FORTH_END_BUFFER 
24d4 c8				ret z 
24d5			 
24d5				; skip any nulls 
24d5			 
24d5 fe 00			cp 0 
24d7 20 03			jr nz, .execword 
24d9 23				inc hl 
24da 18 ec			jr exec1 
24dc			 
24dc			 
24dc			.execword: 
24dc			 
24dc			 
24dc			 
24dc			if DEBUG_FORTH_PARSE_KEY 
24dc						DMARK "KYQ" 
24dc				CALLMONITOR 
24dc			endif 
24dc			;       while at start of word: 
24dc			; get start of dict (in user area first) 
24dc			 
24dc 21 00 80		ld hl, baseram 
24df			;ld hl, sysdict 
24df 22 77 f9		ld (cli_nextword),hl 
24e2			;           match word at pc 
24e2			;           exec word 
24e2			;           or push to dsp 
24e2			;           forward to next token 
24e2			;           if line term pop rsp and exit 
24e2			;        
24e2			 
24e2			if DEBUG_FORTH_PARSE_KEY 
24e2						DMARK "KYq" 
24e2				CALLMONITOR 
24e2			endif 
24e2			 
24e2			; 
24e2			; word comp 
24e2			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
24e2			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
24e2			;    move to start of word  
24e2			;    compare word to cli_token 
24e2			 
24e2			.execpnword:	; HL at start of a word in the dictionary to check 
24e2			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
24e2			;	ld (cli_ptr), hl 
24e2			 
24e2 2a 77 f9			ld hl,(cli_nextword) 
24e5			 
24e5 cd 88 25			call forth_tok_next 
24e8			; tok next start here 
24e8			;	; TODO skip compiled symbol for now 
24e8			;	inc hl 
24e8			; 
24e8			;	; save pointer to next word 
24e8			; 
24e8			;	; hl now points to the address of the next word pointer  
24e8			;	ld e, (hl) 
24e8			;	inc hl 
24e8			;	ld d, (hl) 
24e8			;	inc l 
24e8			; 
24e8			;	ex de,hl 
24e8			;if DEBUG_FORTH_PARSE_NEXTWORD 
24e8			;	push bc 
24e8			;	ld bc, (cli_nextword) 
24e8			;			DMARK "NXW" 
24e8			;	CALLMONITOR 
24e8			;	pop bc 
24e8			;endif 
24e8			; tok next end here 
24e8 22 77 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
24eb eb				ex de, hl 
24ec			 
24ec			 
24ec				; save the pointer of the current token - 1 to check against 
24ec				 
24ec 22 7b f9			ld (cli_token), hl   
24ef				; TODO maybe remove below save if no debug 
24ef				; save token string ptr for any debug later 
24ef 23				inc hl  
24f0 22 7d f9			ld (cli_origtoken), hl 
24f3 2b				dec hl 
24f4				; save pointer to the start of the next dictionay word 
24f4 7e				ld a,(hl)   ; get string length 
24f5 47				ld b,a 
24f6			.execpnwordinc:  
24f6 23				inc hl 
24f7 10 fd			djnz .execpnwordinc 
24f9 22 79 f9			ld (cli_execword), hl      ; save start of this words code 
24fc			 
24fc				; now check the word token against the string being parsed 
24fc			 
24fc 2a 7b f9			ld hl,(cli_token) 
24ff 23				inc hl     ; skip string length (use zero term instead to end) 
2500 22 7b f9			ld (cli_token), hl 
2503			 
2503			if DEBUG_FORTH_PARSE_KEY 
2503						DMARK "KY2" 
2503			endif 
2503			if DEBUG_FORTH_PARSE_EXEC 
2503				; see if disabled 
2503			 
2503			;	ld a, (os_view_disable) 
2503			;	cp '*' 
2503				ld a, (debug_vector) 
2503				cp $c9   ; RET  
2503				jr z, .skip 
2503			 
2503				push hl 
2503				push hl 
2503				call clear_display 
2503				ld de, .compword 
2503				ld a, display_row_1 
2503				call str_at_display 
2503				pop de 
2503				ld a, display_row_2 
2503				call str_at_display 
2503				ld hl,(cli_ptr) 
2503				ld a,(hl) 
2503			        ld hl, os_word_scratch 
2503				ld (hl),a 
2503				ld a,0 
2503				inc hl 
2503				ld (hl),a 	 
2503				ld de, os_word_scratch 
2503				ld a, display_row_2+10 
2503				call str_at_display 
2503				call update_display 
2503				ld a, 100 
2503				call aDelayInMS 
2503				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2503				call delay250ms 
2503				endif 
2503				pop hl 
2503			.skip:  
2503			endif	 
2503			.execpnchar:    ; compare char between token and string to parse 
2503			 
2503			if DEBUG_FORTH_PARSE_KEY 
2503						DMARK "Ky3" 
2503			endif 
2503			if DEBUG_FORTH_PARSE_EXEC 
2503				; see if disabled 
2503			 
2503			;	ld a, (os_view_disable) 
2503			;	cp '*' 
2503				ld a, (debug_vector) 
2503				cp $C9  ; RET 
2503				jr z, .skip2 
2503			 
2503			;	call clear_display 
2503			ld hl,(cli_token) 
2503			ld a,(hl) 
2503			ld (os_word_scratch),a 
2503				ld hl,(cli_ptr) 
2503			ld a,(hl) 
2503				ld (os_word_scratch+1),a 
2503				ld a,0 
2503				ld (os_word_scratch+2),a 
2503				ld de,os_word_scratch 
2503				ld a,display_row_4 
2503				call str_at_display 
2503				call update_display 
2503			.skip2:  
2503			endif 
2503 2a 7b f9			ld hl,(cli_token) 
2506 7e				ld a, (hl)	 ; char in word token 
2507 23				inc hl 		; move to next char 
2508 22 7b f9			ld (cli_token), hl ; and save it 
250b 47				ld b,a 
250c			 
250c 2a 75 f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
250f 7e				ld a,(hl) 
2510 23				inc hl 
2511 22 75 f9			ld (cli_ptr), hl		; move to next char 
2514 cd 3b 13			call toUpper 		; make sure the input string matches case 
2517			 
2517			if DEBUG_FORTH_PARSE 
2517			endif 
2517			 
2517				; input stream end of token is a space so get rid of it 
2517			 
2517			;	cp ' ' 
2517			;	jr nz, .pnskipspace 
2517			; 
2517			;	ld a, 0		; make same term as word token term 
2517			; 
2517			;.pnskipspace: 
2517			 
2517			if DEBUG_FORTH_PARSE_KEY 
2517						DMARK "KY7" 
2517			endif 
2517 b8				cp b 
2518 c2 2e 25			jp nz, .execpnskipword	 ; no match so move to next word 
251b				 
251b			;    if same 
251b			;       scan for string terms 0 for token and 32 for input 
251b			 
251b				 
251b			if DEBUG_FORTH_PARSE_KEY 
251b						DMARK "KY8" 
251b			endif 
251b			 
251b 80				add b			 
251c fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
251e							; TODO need to make sure last word in zero term string is accounted for 
251e 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2520			 
2520			 
2520				; at end of both strings so both are exact match 
2520			 
2520			;       skip ptr for next word 
2520			 
2520 2a 75 f9			ld hl,(cli_ptr) 	; at input string term 
2523 23				inc hl			 ; at next char 
2524 22 75 f9			ld (cli_ptr), hl     ; save for next round of the parser 
2527 22 73 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
252a				 
252a				 
252a			if DEBUG_FORTH_PARSE_KEY 
252a						DMARK "KY3" 
252a			endif 
252a			 
252a			 
252a			 
252a			;       exec code block 
252a			if DEBUG_FORTH_JP 
252a				call clear_display 
252a				call update_display 
252a				call delay1s 
252a				ld hl, (cli_execword)     ; save for next check if no match on this word 
252a				ld a,h 
252a				ld hl, os_word_scratch 
252a				call hexout 
252a				ld hl, (cli_execword)     ; save for next check if no match on this word 
252a				ld a,l 
252a				ld hl, os_word_scratch+2 
252a				call hexout 
252a				ld hl, os_word_scratch+4 
252a				ld a,0 
252a				ld (hl),a 
252a				ld de,os_word_scratch 
252a				call str_at_display 
252a					ld a, display_row_2 
252a					call str_at_display 
252a				ld de, (cli_origtoken) 
252a				ld a, display_row_1+10 
252a					call str_at_display 
252a			 
252a				ld a,display_row_1 
252a				ld de, .foundword 
252a				ld a, display_row_3 
252a				call str_at_display 
252a				call update_display 
252a				call delay1s 
252a				call delay1s 
252a				call delay1s 
252a			endif 
252a			 
252a			if DEBUG_FORTH_PARSE_KEY 
252a						DMARK "KYj" 
252a			endif 
252a				; TODO save the word pointer in this exec 
252a			 
252a 2a 79 f9			ld hl,(cli_execword) 
252d e9				jp (hl) 
252e			 
252e			 
252e			;    if not same 
252e			;	scan for zero term 
252e			;	get ptr for next word 
252e			;	goto word comp 
252e			 
252e			.execpnskipword:	; get pointer to next word 
252e 2a 77 f9			ld hl,(cli_nextword) 
2531			 
2531 7e				ld a,(hl) 
2532 fe 00			cp WORD_SYS_END 
2534			;	cp 0 
2534 28 09			jr z, .execendofdict			 ; at end of words 
2536			 
2536			if DEBUG_FORTH_PARSE_KEY 
2536						DMARK "KY4" 
2536			endif 
2536			if DEBUG_FORTH_PARSE_EXEC 
2536			 
2536				; see if disabled 
2536			 
2536			;	ld a, (os_view_disable) 
2536			;	cp '*' 
2536				ld a,(debug_vector) 
2536				cp $c9   ; RET 
2536				jr z, .noskip 
2536			 
2536			 
2536				ld de, .nowordfound 
2536				ld a, display_row_3 
2536				call str_at_display 
2536				call update_display 
2536				ld a, 100 
2536				call aDelayInMS 
2536				 
2536				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2536					call delay250ms 
2536				endif 
2536			.noskip:  
2536			 
2536			endif	 
2536			 
2536 2a 73 f9			ld hl,(cli_origptr) 
2539 22 75 f9			ld (cli_ptr),hl 
253c			 
253c			if DEBUG_FORTH_PARSE_KEY 
253c						DMARK "KY5" 
253c			endif 
253c c3 e2 24			jp .execpnword			; else go to next word 
253f			 
253f			.execendofdict:  
253f			 
253f			if DEBUG_FORTH_PARSE_KEY 
253f						DMARK "KYe" 
253f			endif 
253f			if DEBUG_FORTH_PARSE_EXEC 
253f				; see if disabled 
253f			 
253f			;	ld a, (os_view_disable) 
253f			;	cp '*' 
253f				ld a,(debug_vector) 
253f				cp $c9   ; ret 
253f				jr z, .ispskip 
253f			 
253f				call clear_display 
253f				call update_display 
253f				call delay1s 
253f				ld de, (cli_origptr) 
253f				ld a, display_row_1 
253f				call str_at_display 
253f				 
253f				ld de, .enddict 
253f				ld a, display_row_3 
253f				call str_at_display 
253f				call update_display 
253f				ld a, 100 
253f				call aDelayInMS 
253f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
253f				call delay1s 
253f				call delay1s 
253f				call delay1s 
253f				endif 
253f			.ispskip:  
253f				 
253f			endif	 
253f			 
253f			 
253f			 
253f				; if the word is not a keyword then must be a literal so push it to stack 
253f			 
253f			; push token to stack to end of word 
253f			 
253f				STACKFRAME ON $1efe $2f9f 
253f				if DEBUG_STACK_IMB 
253f					if ON 
253f						exx 
253f						ld de, $1efe 
253f						ld a, d 
253f						ld hl, curframe 
253f						call hexout 
253f						ld a, e 
253f						ld hl, curframe+2 
253f						call hexout 
253f						ld hl, $1efe 
253f						push hl 
253f						ld hl, $2f9f 
253f						push hl 
253f						exx 
253f					endif 
253f				endif 
253f			endm 
# End of macro STACKFRAME
253f			 
253f 2a f7 f3		ld hl,(os_tok_ptr) 
2542 cd af 21		call forth_apush 
2545			 
2545				STACKFRAMECHK ON $1efe $2f9f 
2545				if DEBUG_STACK_IMB 
2545					if ON 
2545						exx 
2545						ld hl, $2f9f 
2545						pop de   ; $2f9f 
2545						call cmp16 
2545						jr nz, .spnosame 
2545						ld hl, $1efe 
2545						pop de   ; $1efe 
2545						call cmp16 
2545						jr z, .spfrsame 
2545						.spnosame: call showsperror 
2545						.spfrsame: nop 
2545						exx 
2545					endif 
2545				endif 
2545			endm 
# End of macro STACKFRAMECHK
2545			 
2545			execnext: 
2545			 
2545			if DEBUG_FORTH_PARSE_KEY 
2545						DMARK "KY>" 
2545			endif 
2545			; move past token to next word 
2545			 
2545 2a f7 f3		ld hl, (os_tok_ptr) 
2548 3e 00		ld a, 0 
254a 01 ff 00		ld bc, 255     ; input buffer size 
254d ed b1		cpir 
254f			 
254f			if DEBUG_FORTH_PARSE_KEY 
254f						DMARK "KY!" 
254f				CALLMONITOR 
254f			endif	 
254f			; TODO this might place hl on the null, so will need to forward on??? 
254f			;inc hl   ; see if this gets onto the next item 
254f			 
254f			 
254f			; TODO pass a pointer to the buffer to push 
254f			; TODO call function to push 
254f			 
254f			; look for end of input 
254f			 
254f			;inc hl 
254f			;ld a,(hl) 
254f			;cp FORTH_END_BUFFER 
254f			;ret z 
254f			 
254f			 
254f c3 c8 24		jp exec1 
2552			 
2552			 
2552			 
2552			 
2552			 
2552			 
2552			 
2552			 
2552			 
2552			findnexttok: 
2552			 
2552				; hl is pointer to move 
2552				; de is the token to locate 
2552			 
2552					if DEBUG_FORTH 
2552						DMARK "NTK" 
2552						CALLMONITOR 
2552					endif 
2552 d5				push de 
2553			 
2553			.fnt1:	 
2553				; find first char of token to locate 
2553			 
2553 1a				ld a, (de) 
2554 4f				ld c,a 
2555 7e				ld a,(hl) 
2556 cd 3b 13			call toUpper 
2559					if DEBUG_FORTH 
2559						DMARK "NT1" 
2559						CALLMONITOR 
2559					endif 
2559 b9				cp c 
255a			 
255a 28 03			jr z, .fnt2cmpmorefirst	 
255c			 
255c				; first char not found move to next char 
255c			 
255c 23				inc hl 
255d 18 f4			jr .fnt1 
255f			 
255f			.fnt2cmpmorefirst:	 
255f				; first char of token found.  
255f			 
255f e5				push hl     ; save start of token just in case it is the right one 
2560 d9				exx 
2561 e1				pop hl        ; save it to hl' 
2562 d9				exx 
2563			 
2563			 
2563			.fnt2cmpmore:	 
2563				; compare the rest 
2563				 
2563 23				inc hl 
2564 13				inc de 
2565				 
2565 1a				ld a, (de) 
2566 4f				ld c,a 
2567 7e				ld a,(hl) 
2568 cd 3b 13			call toUpper 
256b			 
256b					if DEBUG_FORTH 
256b						DMARK "NT2" 
256b						CALLMONITOR 
256b					endif 
256b				; c has the token to find char 
256b				; a has the mem to scan char 
256b			 
256b b9				cp c 
256c 28 04			jr z,.fntmatch1 
256e			 
256e				; they are not the same 
256e			 
256e					if DEBUG_FORTH 
256e						DMARK "NT3" 
256e						CALLMONITOR 
256e					endif 
256e d1				pop de	; reset de token to look for 
256f d5				push de 
2570 18 e1			jr .fnt1 
2572				 
2572			.fntmatch1: 
2572			 
2572				; is the same char a null which means we might have a full hit? 
2572					if DEBUG_FORTH 
2572						DMARK "NT4" 
2572						CALLMONITOR 
2572					endif 
2572			 
2572 fe 00			cp 0 
2574 28 0b			jr z, .fntmatchyes 
2576			 
2576				; are we at the end of the token to find? 
2576			 
2576					if DEBUG_FORTH 
2576						DMARK "NT5" 
2576						CALLMONITOR 
2576					endif 
2576 3e 00			ld a, 0 
2578 b9				cp c 
2579			 
2579 c2 63 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
257c			 
257c					if DEBUG_FORTH 
257c						DMARK "NT6" 
257c						CALLMONITOR 
257c					endif 
257c				; token to find is exhusted but no match to stream 
257c			 
257c				; restore tok pointer and continue on 
257c d1				pop de 
257d d5				push de 
257e c3 53 25			jp .fnt1 
2581			 
2581			 
2581			.fntmatchyes: 
2581			 
2581				; hl now contains the end of the found token 
2581			 
2581				; get rid of saved token pointer to find 
2581			 
2581 d1				pop de 
2582			 
2582					if DEBUG_FORTH 
2582						DMARK "NT9" 
2582						CALLMONITOR 
2582					endif 
2582			 
2582				; hl will be on the null term so forward on 
2582			 
2582				; get back the saved start of the token 
2582			 
2582 d9				exx 
2583 e5				push hl     ; save start of token just in case it is the right one 
2584 d9				exx 
2585 e1				pop hl        ; save it to hl 
2586			 
2586 c9				ret 
2587			 
2587			 
2587			; LIST needs to find a specific token   
2587			; FORGET needs to find a spefici token 
2587			 
2587			; SAVE needs to find all tokens by flag 
2587			; WORDS just needs to scan through all  by flag 
2587			; UWORDS needs to scan through all by flag 
2587			 
2587			 
2587			; given hl as pointer to start of dict look up string 
2587			; return hl as pointer to start of word block 
2587			; or 0 if not found 
2587			 
2587			forth_find_tok: 
2587 c9				ret 
2588			 
2588			; given hl as pointer to dict structure 
2588			; move to the next dict block structure 
2588			 
2588			forth_tok_next: 
2588				; hl now points to the address of the next word pointer  
2588				; TODO skip compiled symbol for now 
2588			;	push de 
2588 23				inc hl 
2589 5e				ld e, (hl) 
258a 23				inc hl 
258b 56				ld d, (hl) 
258c 23				inc hl 
258d			 
258d eb				ex de,hl 
258e			if DEBUG_FORTH_PARSE_NEXTWORD 
258e				push bc 
258e				ld bc, (cli_nextword) 
258e						DMARK "NXW" 
258e				CALLMONITOR 
258e				pop bc 
258e			endif 
258e			;	pop de	 
258e c9				ret 
258f			 
258f			 
258f			 
258f			; eof 
# End of file forth_parserv5.asm
258f				include "forth_wordsv4.asm" 
258f			 
258f			; the core word dictionary v4 
258f			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
258f			 
258f			; this is a linked list for each of the system words used 
258f			; user defined words will follow the same format but will be in ram 
258f			 
258f			 
258f			; 
258f			; 
258f			; define linked list: 
258f			; 
258f			; 1. compiled byte op code 
258f			; 2. len of text word 
258f			; 3. text word 
258f			; 4. ptr to next dictionary word 
258f			; 5. asm, calls etc for the word 
258f			; 
258f			;  if 1 == 0 then last word in dict  
258f			;   
258f			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
258f			;  
258f			;  
258f			; create basic standard set of words 
258f			; 
258f			;  
258f			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
258f			; 2DUP 2DROP 2SWAP  
258f			; @ C@ - get byte  
258f			; ! C! - store byte 
258f			; 0< true if less than zero 
258f			; 0= true if zero 
258f			; < >  
258f			; = true if same 
258f			; variables 
258f			 
258f			 
258f			; Hardware specific words I may need 
258f			; 
258f			; IN OUT  
258f			; calls to key util functions 
258f			; calls to hardward abstraction stuff 
258f			; easy control of frame buffers and lcd i/o 
258f			; keyboard  
258f			 
258f			 
258f			;DICT: macro 
258f			; op_code, len, word, next 
258f			;    word: 
258f			;    db op_code 
258f			;    ds word zero term 
258f			;    dw next 
258f			;    endm 
258f			 
258f			 
258f			 
258f			 
258f			; op code 1 is a flag for user define words which are to be handled differently 
258f			 
258f			 
258f			; 
258f			; 
258f			;    TODO on entry to a word this should be the expected environment 
258f			;    hl - tos value if number then held, if string this is the ptr 
258f			;    de -  
258f			 
258f			 
258f			; opcode ranges 
258f			; 0 - end of word dict 
258f			; 255 - user define words 
258f			 
258f			sysdict: 
258f			include "forth_opcodes.asm" 
258f			; op codes for forth keywords 
258f			; free to use code 0  
258f				OPCODE_HEAP: equ  1 
258f				OPCODE_EXEC: equ 2 
258f				OPCODE_DUP: equ 3 
258f				OPCODE_SWAP: equ 4 
258f				OPCODE_COLN: equ 5 
258f				OPCODE_SCOLN: equ 6 
258f				OPCODE_DROP: equ 7 
258f				OPCODE_DUP2: equ 8 
258f				OPCODE_DROP2: equ 9 
258f				OPCODE_SWAP2: equ 10 
258f				OPCODE_AT: equ 11 
258f				OPCODE_CAT: equ 12 
258f				OPCODE_BANG: equ 13 
258f				OPCODE_CBANG: equ 14 
258f				OPCODE_SCALL: equ 15 
258f				OPCODE_DEPTH: equ 16 
258f				OPCODE_OVER: equ 17 
258f				OPCODE_PAUSE: equ 18 
258f				OPCODE_PAUSES: equ 19 
258f				OPCODE_ROT: equ 20 
258f			;free to reuse	OPCODE_WORDS: equ 21 
258f			        OPCODE_NOT: equ 21 
258f				OPCODE_UWORDS: equ 22 
258f				OPCODE_BP: equ 23 
258f				OPCODE_MONITOR: equ 24  
258f				OPCODE_MALLOC: equ 25 
258f				OPCODE_FREE: equ 26 
258f				OPCODE_LIST: equ 27 
258f				OPCODE_FORGET: equ 28 
258f				OPCODE_NOP: equ 29 
258f				OPCODE_COMO: equ 30 
258f				OPCODE_COMC: equ 31 
258f			;free to reuse	OPCODE_ENDCORE: equ 32 
258f				OPCODE_AFTERSOUND: equ 33 
258f				OPCODE_GP2: equ 34 
258f				OPCODE_GP3: equ 35 
258f				OPCODE_GP4: equ 36 
258f				OPCODE_SIN: equ 37 
258f				OPCODE_SOUT: equ 38 
258f				OPCODE_SPIO: equ 39 
258f				OPCODE_SPICEH: equ 40 
258f				OPCODE_SPIOb: equ 41 
258f				OPCODE_SPII: equ 42 
258f				OPCODE_SESEL: equ 43 
258f				OPCODE_CARTDEV: equ 44 
258f			; free to reuse	OPCODE_ENDDEVICE: equ 45 
258f				OPCODE_FB: equ 46 
258f				OPCODE_EMIT: equ 47 
258f				OPCODE_DOTH: equ 48 
258f				OPCODE_DOTF: equ 49 
258f				OPCODE_DOT: equ 50 
258f				OPCODE_CLS: equ 51 
258f				OPCODE_DRAW: equ 52 
258f				OPCODE_DUMP: equ 53 
258f				OPCODE_CDUMP: equ 54 
258f				OPCODE_DAT: equ 55 
258f				OPCODE_HOME: equ 56 
258f				OPCODE_SPACE: equ 57 
258f				OPCODE_SPACES: equ 58 
258f				OPCODE_SCROLL: equ 59 
258f				OPCODE_ATQ: equ 60 
258f				OPCODE_AUTODSP: equ 61 
258f				OPCODE_MENU: equ 62 
258f			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
258f				OPCODE_THEN: equ 64 
258f				OPCODE_ELSE: equ 65 
258f				OPCODE_DO: equ 66 
258f				OPCODE_LOOP: equ 67 
258f				OPCODE_I: equ 68 
258f				OPCODE_DLOOP: equ 69  
258f				OPCODE_REPEAT: equ 70  
258f				OPCODE_UNTIL: equ 71 
258f				OPCODE_ENDFLOW: equ 72 
258f				OPCODE_WAITK: equ 73 
258f				OPCODE_ACCEPT: equ 74 
258f				OPCODE_EDIT: equ 75 
258f			;free to reuse	OPCODE_ENDKEY: equ 76 
258f				OPCODE_LZERO: equ 77 
258f				OPCODE_TZERO: equ 78 
258f				OPCODE_LESS: equ 79 
258f				OPCODE_GT: equ 80 
258f				OPCODE_EQUAL: equ 81  
258f			;free to reuse	OPCODE_ENDLOGIC: equ 82 
258f				OPCODE_NEG: equ 83 
258f				OPCODE_DIV: equ 84 
258f				OPCODE_MUL: equ 85 
258f				OPCODE_MIN: equ 86 
258f				OPCODE_MAX: equ 87 
258f				OPCODE_RND16: equ 88 
258f				OPCODE_RND8: equ 89 
258f				OPCODE_RND: equ 90 
258f			;free to reuse	OPCODE_ENDMATHS: equ 91  
258f				OPCODE_BYNAME: equ 92 
258f				OPCODE_DIR: equ 93 
258f				OPCODE_SAVE: equ 94 
258f				OPCODE_LOAD: equ 95 
258f				OPCODE_BSAVE: equ 96 
258f				OPCODE_BLOAD: equ 97 
258f				OPCODE_SEO: equ 98  
258f				OPCODE_SEI: equ 99 
258f				OPCODE_SFREE: equ 100 
258f				OPCODE_SIZE: equ 101 
258f				OPCODE_CREATE: equ 102 
258f				OPCODE_APPEND: equ 103 
258f				OPCODE_SDEL: equ 104 
258f				OPCODE_OPEN: equ 105 
258f				OPCODE_READ: equ 106 
258f				OPCODE_EOF: equ 106 
258f				OPCODE_FORMAT: equ 107 
258f				OPCODE_LABEL: equ 108 
258f				OPCODE_LABELS: equ 109 
258f			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
258f				OPCODE_UPPER: equ 111 
258f				OPCODE_LOWER: equ 112 
258f				OPCODE_SUBSTR: equ 113 
258f				OPCODE_LEFT: equ 114 
258f				OPCODE_RIGHT: equ 115 
258f				OPCODE_STR2NUM: equ 116 
258f				OPCODE_NUM2STR: equ 117 
258f				OPCODE_CONCAT: equ 118 
258f				OPCODE_FIND: equ 119 
258f				OPCODE_LEN: equ 120 
258f				OPCODE_CHAR: equ 121 
258f			; free to reuse	OPCODE_STRLEN: equ 122 
258f			; free to reuse	OPCODE_ENDSTR: equ 123 
258f				OPCODE_V0S: equ 124 
258f				OPCODE_V0Q: equ 125 
258f				OPCODE_V1S: equ 126 
258f				OPCODE_V1Q: equ 127 
258f				OPCODE_V2S: equ 128 
258f				OPCODE_V2Q: equ 129 
258f				OPCODE_V3S: equ 130 
258f				OPCODE_V3Q: equ 131 
258f			;free to reuse	OPCODE_END: equ 132 
258f				OPCODE_ZDUP: equ 133 
258f			 
258f			; eof 
# End of file forth_opcodes.asm
258f			 
258f			include "forth_words_core.asm" 
258f			 
258f			; | ## Core Words 
258f			 
258f			;if MALLOC_4 
258f			 
258f			.HEAP: 
258f			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
258f 15				db WORD_SYS_CORE+OPCODE_HEAP             
2590 ce 25			dw .EXEC            
2592 05				db 4 + 1 
2593 .. 00			db "HEAP",0              
2598				endm 
# End of macro CWHEAD
2598			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2598			; | | u1 - Current number of bytes in the heap 
2598			; | | u2 - Remaining bytes left on the heap 
2598			; | |  
2598			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2598			 
2598			 
2598				if DEBUG_FORTH_WORDS_KEY 
2598					DMARK "HEP" 
2598 f5				push af  
2599 3a ad 25			ld a, (.dmark)  
259c 32 a0 fd			ld (debug_mark),a  
259f 3a ae 25			ld a, (.dmark+1)  
25a2 32 a1 fd			ld (debug_mark+1),a  
25a5 3a af 25			ld a, (.dmark+2)  
25a8 32 a2 fd			ld (debug_mark+2),a  
25ab 18 03			jr .pastdmark  
25ad ..			.dmark: db "HEP"  
25b0 f1			.pastdmark: pop af  
25b1			endm  
# End of macro DMARK
25b1					CALLMONITOR 
25b1 cd aa fd			call debug_vector  
25b4				endm  
# End of macro CALLMONITOR
25b4				endif 
25b4 2a 0a 80			ld hl, (free_list )      
25b7 11 0e 80			ld de, heap_start 
25ba			 
25ba ed 52			sbc hl, de  
25bc			 
25bc cd 46 20			call forth_push_numhl 
25bf			 
25bf			 
25bf ed 5b 0a 80		ld de, (free_list )      
25c3 21 d1 f0			ld hl, heap_end 
25c6			 
25c6 ed 52			sbc hl, de 
25c8			 
25c8 cd 46 20			call forth_push_numhl 
25cb				 
25cb			 
25cb				 
25cb			 
25cb			 
25cb			 
25cb				NEXTW 
25cb c3 37 24			jp macro_next 
25ce				endm 
# End of macro NEXTW
25ce			;endif 
25ce			 
25ce			.EXEC: 
25ce			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
25ce			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
25ce			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
25ce			;; > > 
25ce			;; > >   
25ce			;	STACKFRAME OFF $5efe $5f9f 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS_KEY 
25ce			;			DMARK "EXE" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			; 
25ce			;	FORTH_DSP_VALUEHL 
25ce			; 
25ce			;	FORTH_DSP_POP 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX1" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;;	ld e,(hl) 
25ce			;;	inc hl 
25ce			;;	ld d,(hl) 
25ce			;;	ex de,hl 
25ce			; 
25ce			;;		if DEBUG_FORTH_WORDS 
25ce			;;			DMARK "EX2" 
25ce			;;			CALLMONITOR 
25ce			;;		endif 
25ce			;	push hl 
25ce			; 
25ce			;	;ld a, 0 
25ce			;	;ld a, FORTH_END_BUFFER 
25ce			;	call strlenz 
25ce			;	inc hl   ; include zero term to copy 
25ce			;	inc hl   ; include term 
25ce			;	inc hl   ; include term 
25ce			;	ld b,0 
25ce			;	ld c,l 
25ce			;	pop hl 
25ce			;	ld de, execscratch 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX3" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	ldir 
25ce			; 
25ce			; 
25ce			;	ld hl, execscratch 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EXe" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			; 
25ce			;	call forthparse 
25ce			;	call forthexec 
25ce			;;	call forthexec_cleanup 
25ce			;;	call forthparse 
25ce			;;	call forthexec 
25ce			; 
25ce			;	STACKFRAMECHK OFF $5efe $5f9f 
25ce			; 
25ce			;	; an immediate word so no need to process any more words 
25ce			;	ret 
25ce			;	NEXTW 
25ce			 
25ce			; dead code - old version  
25ce			;	FORTH_RSP_NEXT 
25ce			 
25ce			;  
25ce			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
25ce			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
25ce			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
25ce			;	push hl 
25ce			;	push de 
25ce			;	push bc 
25ce			; 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS_KEY 
25ce			;			DMARK "EXR" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			; 
25ce			; 
25ce			; 
25ce			;	;v5 FORTH_DSP_VALUE 
25ce			;	FORTH_DSP_VALUEHL 
25ce			; 
25ce			;	; TODO do string type checks 
25ce			; 
25ce			;;v5	inc hl   ; skip type 
25ce			; 
25ce			;	push hl  ; source code  
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX1" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	ld a, 0 
25ce			;	call strlent 
25ce			; 
25ce			;	inc hl 
25ce			;	inc hl 
25ce			;	inc hl 
25ce			;	inc hl 
25ce			; 
25ce			;	push hl    ; size 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX2" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	call malloc 
25ce			; 
25ce			;	ex de, hl    ; de now contains malloc area 
25ce			;	pop bc   	; get byte count 
25ce			;	pop hl      ; get string to copy 
25ce			; 
25ce			;	push de     ; save malloc for free later 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX3" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	ldir       ; duplicate string 
25ce			; 
25ce			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
25ce			;	 
25ce			;	; TODO fix the parse would be better than this...  
25ce			;	ex de, hl 
25ce			;	dec hl 
25ce			;	ld a, 0 
25ce			;	ld (hl), a 
25ce			;	dec hl 
25ce			;	ld a, ' ' 
25ce			;	ld (hl), a 
25ce			;	dec hl 
25ce			;	ld (hl), a 
25ce			; 
25ce			;	dec hl 
25ce			;	ld (hl), a 
25ce			; 
25ce			; 
25ce			;	FORTH_DSP_POP  
25ce			; 
25ce			;	pop hl     
25ce			;	push hl    ; save malloc area 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX4" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			; 
25ce			;	call forthparse 
25ce			;	call forthexec 
25ce			;	 
25ce			;	pop hl 
25ce			;	if DEBUG_FORTH_WORDS 
25ce			;		DMARK "EX5" 
25ce			;		CALLMONITOR 
25ce			;	endif 
25ce			; 
25ce			;	if FORTH_ENABLE_FREE 
25ce			;	call free 
25ce			;	endif 
25ce			; 
25ce			;	if DEBUG_FORTH_WORDS 
25ce			;		DMARK "EX6" 
25ce			;		CALLMONITOR 
25ce			;	endif 
25ce			; 
25ce			;	pop bc 
25ce			;	pop de 
25ce			;	pop hl 
25ce			;;	FORTH_RSP_POP	  
25ce			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
25ce			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
25ce			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
25ce			; 
25ce			;	if DEBUG_FORTH_WORDS 
25ce			;		DMARK "EX7" 
25ce			;		CALLMONITOR 
25ce			;	endif 
25ce			;	NEXTW 
25ce			 
25ce			;.STKEXEC: 
25ce			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
25ce			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
25ce			; 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS_KEY 
25ce			;			DMARK "STX" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			; 
25ce			;	FORTH_DSP_VALUEHL 
25ce			; 
25ce			;	ld (store_tmp1), hl    ; count 
25ce			; 
25ce			;	FORTH_DSP_POP 
25ce			;.stkexec1: 
25ce			;	ld hl, (store_tmp1)   ; count 
25ce			;	ld a, 0 
25ce			;	cp l 
25ce			;	ret z 
25ce			; 
25ce			;	dec hl 
25ce			;	ld (store_tmp1), hl    ; count 
25ce			;	 
25ce			;	FORTH_DSP_VALUEHL 
25ce			;	push hl 
25ce			;	 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EXp" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	FORTH_DSP_POP 
25ce			; 
25ce			;	call strlenz 
25ce			;	inc hl   ; include zero term to copy 
25ce			;	inc hl   ; include zero term to copy 
25ce			;	inc hl   ; include zero term to copy 
25ce			;	ld b,0 
25ce			;	ld c,l 
25ce			;	pop hl 
25ce			;	ld de, execscratch 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EX3" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	ldir 
25ce			; 
25ce			; 
25ce			;	ld hl, execscratch 
25ce			; 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EXP" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			; 
25ce			;	call forthparse 
25ce			;	ld hl, execscratch 
25ce			;		if DEBUG_FORTH_WORDS 
25ce			;			DMARK "EXx" 
25ce			;			CALLMONITOR 
25ce			;		endif 
25ce			;	call forthexec 
25ce			; 
25ce			;	jp .stkexec1 
25ce			; 
25ce			;	ret 
25ce			 
25ce			 
25ce			.DUP: 
25ce			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
25ce 17				db WORD_SYS_CORE+OPCODE_DUP             
25cf 44 26			dw .ZDUP            
25d1 04				db 3 + 1 
25d2 .. 00			db "DUP",0              
25d6				endm 
# End of macro CWHEAD
25d6			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
25d6			 
25d6				if DEBUG_FORTH_WORDS_KEY 
25d6					DMARK "DUP" 
25d6 f5				push af  
25d7 3a eb 25			ld a, (.dmark)  
25da 32 a0 fd			ld (debug_mark),a  
25dd 3a ec 25			ld a, (.dmark+1)  
25e0 32 a1 fd			ld (debug_mark+1),a  
25e3 3a ed 25			ld a, (.dmark+2)  
25e6 32 a2 fd			ld (debug_mark+2),a  
25e9 18 03			jr .pastdmark  
25eb ..			.dmark: db "DUP"  
25ee f1			.pastdmark: pop af  
25ef			endm  
# End of macro DMARK
25ef					CALLMONITOR 
25ef cd aa fd			call debug_vector  
25f2				endm  
# End of macro CALLMONITOR
25f2				endif 
25f2			 
25f2				FORTH_DSP 
25f2 cd 11 22			call macro_forth_dsp 
25f5				endm 
# End of macro FORTH_DSP
25f5			 
25f5 7e				ld a, (HL) 
25f6 fe 01			cp DS_TYPE_STR 
25f8 20 25			jr nz, .dupinum 
25fa			 
25fa				; push another string 
25fa			 
25fa				FORTH_DSP_VALUEHL     		 
25fa cd 4b 22			call macro_dsp_valuehl 
25fd				endm 
# End of macro FORTH_DSP_VALUEHL
25fd			 
25fd			if DEBUG_FORTH_WORDS 
25fd				DMARK "DUs" 
25fd f5				push af  
25fe 3a 12 26			ld a, (.dmark)  
2601 32 a0 fd			ld (debug_mark),a  
2604 3a 13 26			ld a, (.dmark+1)  
2607 32 a1 fd			ld (debug_mark+1),a  
260a 3a 14 26			ld a, (.dmark+2)  
260d 32 a2 fd			ld (debug_mark+2),a  
2610 18 03			jr .pastdmark  
2612 ..			.dmark: db "DUs"  
2615 f1			.pastdmark: pop af  
2616			endm  
# End of macro DMARK
2616				CALLMONITOR 
2616 cd aa fd			call debug_vector  
2619				endm  
# End of macro CALLMONITOR
2619			endif 
2619 cd b4 20			call forth_push_str 
261c			 
261c				NEXTW 
261c c3 37 24			jp macro_next 
261f				endm 
# End of macro NEXTW
261f			 
261f			 
261f			.dupinum: 
261f				 
261f			 
261f			 
261f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
261f cd 4b 22			call macro_dsp_valuehl 
2622				endm 
# End of macro FORTH_DSP_VALUEHL
2622			 
2622			; TODO add floating point number detection 
2622			 
2622			if DEBUG_FORTH_WORDS 
2622				DMARK "DUi" 
2622 f5				push af  
2623 3a 37 26			ld a, (.dmark)  
2626 32 a0 fd			ld (debug_mark),a  
2629 3a 38 26			ld a, (.dmark+1)  
262c 32 a1 fd			ld (debug_mark+1),a  
262f 3a 39 26			ld a, (.dmark+2)  
2632 32 a2 fd			ld (debug_mark+2),a  
2635 18 03			jr .pastdmark  
2637 ..			.dmark: db "DUi"  
263a f1			.pastdmark: pop af  
263b			endm  
# End of macro DMARK
263b				CALLMONITOR 
263b cd aa fd			call debug_vector  
263e				endm  
# End of macro CALLMONITOR
263e			endif 
263e			 
263e cd 46 20			call forth_push_numhl 
2641				NEXTW 
2641 c3 37 24			jp macro_next 
2644				endm 
# End of macro NEXTW
2644			.ZDUP: 
2644			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2644 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2645 7c 26			dw .SWAP            
2647 05				db 4 + 1 
2648 .. 00			db "?DUP",0              
264d				endm 
# End of macro CWHEAD
264d			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
264d			 
264d				if DEBUG_FORTH_WORDS_KEY 
264d					DMARK "qDU" 
264d f5				push af  
264e 3a 62 26			ld a, (.dmark)  
2651 32 a0 fd			ld (debug_mark),a  
2654 3a 63 26			ld a, (.dmark+1)  
2657 32 a1 fd			ld (debug_mark+1),a  
265a 3a 64 26			ld a, (.dmark+2)  
265d 32 a2 fd			ld (debug_mark+2),a  
2660 18 03			jr .pastdmark  
2662 ..			.dmark: db "qDU"  
2665 f1			.pastdmark: pop af  
2666			endm  
# End of macro DMARK
2666					CALLMONITOR 
2666 cd aa fd			call debug_vector  
2669				endm  
# End of macro CALLMONITOR
2669				endif 
2669				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2669 cd 4b 22			call macro_dsp_valuehl 
266c				endm 
# End of macro FORTH_DSP_VALUEHL
266c			 
266c e5				push hl 
266d			 
266d				; is it a zero? 
266d			 
266d 3e 00			ld a, 0 
266f 84				add h 
2670 85				add l 
2671			 
2671 e1				pop hl 
2672			 
2672 fe 00			cp 0 
2674 28 03			jr z, .dup2orig 
2676			 
2676			 
2676 cd 46 20			call forth_push_numhl 
2679			 
2679			 
2679			; TODO add floating point number detection 
2679			 
2679			.dup2orig: 
2679			 
2679				NEXTW 
2679 c3 37 24			jp macro_next 
267c				endm 
# End of macro NEXTW
267c			.SWAP: 
267c			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
267c 18				db WORD_SYS_CORE+OPCODE_SWAP             
267d d0 26			dw .COLN            
267f 05				db 4 + 1 
2680 .. 00			db "SWAP",0              
2685				endm 
# End of macro CWHEAD
2685			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2685				if DEBUG_FORTH_WORDS_KEY 
2685					DMARK "SWP" 
2685 f5				push af  
2686 3a 9a 26			ld a, (.dmark)  
2689 32 a0 fd			ld (debug_mark),a  
268c 3a 9b 26			ld a, (.dmark+1)  
268f 32 a1 fd			ld (debug_mark+1),a  
2692 3a 9c 26			ld a, (.dmark+2)  
2695 32 a2 fd			ld (debug_mark+2),a  
2698 18 03			jr .pastdmark  
269a ..			.dmark: db "SWP"  
269d f1			.pastdmark: pop af  
269e			endm  
# End of macro DMARK
269e					CALLMONITOR 
269e cd aa fd			call debug_vector  
26a1				endm  
# End of macro CALLMONITOR
26a1				endif 
26a1			 
26a1			; DONE Use os stack swap memory 
26a1			 
26a1				FORTH_DSP_PTR 0     ; TOS 
26a1 2a 23 f9			ld hl,(cli_data_sp) 
26a4 11 00 00			ld de, 0 * 3 
26a7 ed 52			sbc hl, de 
26a9				endm 
# End of macro FORTH_DSP_PTR
26a9 cd 83 23			call hltostack1 
26ac			  
26ac				FORTH_DSP_PTR 1     ; TOS 
26ac 2a 23 f9			ld hl,(cli_data_sp) 
26af 11 03 00			ld de, 1 * 3 
26b2 ed 52			sbc hl, de 
26b4				endm 
# End of macro FORTH_DSP_PTR
26b4 cd 89 23			call hltostack2 
26b7			 
26b7				FORTH_DSP_PTR 0     ; TOS 
26b7 2a 23 f9			ld hl,(cli_data_sp) 
26ba 11 00 00			ld de, 0 * 3 
26bd ed 52			sbc hl, de 
26bf				endm 
# End of macro FORTH_DSP_PTR
26bf cd a1 23			call hlfromstack2 
26c2			 
26c2				FORTH_DSP_PTR 1     ; TOS 
26c2 2a 23 f9			ld hl,(cli_data_sp) 
26c5 11 03 00			ld de, 1 * 3 
26c8 ed 52			sbc hl, de 
26ca				endm 
# End of macro FORTH_DSP_PTR
26ca cd 9b 23			call hlfromstack1 
26cd			;	FORTH_DSP_VALUEHL 
26cd			;	push hl     ; w2 
26cd			; 
26cd			;	FORTH_DSP_POP 
26cd			; 
26cd			;	FORTH_DSP_VALUEHL 
26cd			; 
26cd			;	FORTH_DSP_POP 
26cd			; 
26cd			;	pop de     ; w2	, hl = w1 
26cd			; 
26cd			;	ex de, hl 
26cd			;	push de 
26cd			; 
26cd			;	call forth_push_numhl 
26cd			; 
26cd			;	pop hl 
26cd			; 
26cd			;	call forth_push_numhl 
26cd				 
26cd			 
26cd				NEXTW 
26cd c3 37 24			jp macro_next 
26d0				endm 
# End of macro NEXTW
26d0			.COLN: 
26d0			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
26d0 19				db WORD_SYS_CORE+OPCODE_COLN             
26d1 5c 28			dw .SCOLN            
26d3 02				db 1 + 1 
26d4 .. 00			db ":",0              
26d6				endm 
# End of macro CWHEAD
26d6			; | : ( -- )         Create new word | DONE 
26d6			 
26d6				if DEBUG_FORTH_WORDS_KEY 
26d6					DMARK "CLN" 
26d6 f5				push af  
26d7 3a eb 26			ld a, (.dmark)  
26da 32 a0 fd			ld (debug_mark),a  
26dd 3a ec 26			ld a, (.dmark+1)  
26e0 32 a1 fd			ld (debug_mark+1),a  
26e3 3a ed 26			ld a, (.dmark+2)  
26e6 32 a2 fd			ld (debug_mark+2),a  
26e9 18 03			jr .pastdmark  
26eb ..			.dmark: db "CLN"  
26ee f1			.pastdmark: pop af  
26ef			endm  
# End of macro DMARK
26ef					CALLMONITOR 
26ef cd aa fd			call debug_vector  
26f2				endm  
# End of macro CALLMONITOR
26f2				endif 
26f2			STACKFRAME OFF $8efe $989f 
26f2				if DEBUG_STACK_IMB 
26f2					if OFF 
26f2						exx 
26f2						ld de, $8efe 
26f2						ld a, d 
26f2						ld hl, curframe 
26f2						call hexout 
26f2						ld a, e 
26f2						ld hl, curframe+2 
26f2						call hexout 
26f2						ld hl, $8efe 
26f2						push hl 
26f2						ld hl, $989f 
26f2						push hl 
26f2						exx 
26f2					endif 
26f2				endif 
26f2			endm 
# End of macro STACKFRAME
26f2			; get parser buffer length  of new word 
26f2			 
26f2			 
26f2			 
26f2				; move tok past this to start of name defintition 
26f2				; TODO get word to define 
26f2				; TODO Move past word token 
26f2				; TODO get length of string up to the ';' 
26f2			 
26f2 2a f7 f3		ld hl, (os_tok_ptr) 
26f5 23			inc hl 
26f6 23			inc hl 
26f7			 
26f7 3e 3b		ld a, ';' 
26f9 cd 4f 13		call strlent 
26fc			 
26fc 7d			ld a,l 
26fd 32 e6 f0		ld (os_new_parse_len), a 
2700			 
2700			 
2700			if DEBUG_FORTH_UWORD 
2700 ed 5b f7 f3	ld de, (os_tok_ptr) 
2704					DMARK ":01" 
2704 f5				push af  
2705 3a 19 27			ld a, (.dmark)  
2708 32 a0 fd			ld (debug_mark),a  
270b 3a 1a 27			ld a, (.dmark+1)  
270e 32 a1 fd			ld (debug_mark+1),a  
2711 3a 1b 27			ld a, (.dmark+2)  
2714 32 a2 fd			ld (debug_mark+2),a  
2717 18 03			jr .pastdmark  
2719 ..			.dmark: db ":01"  
271c f1			.pastdmark: pop af  
271d			endm  
# End of macro DMARK
271d			CALLMONITOR 
271d cd aa fd			call debug_vector  
2720				endm  
# End of macro CALLMONITOR
2720			endif 
2720			 
2720			; 
2720			;  new word memory layout: 
2720			;  
2720			;    : adg 6666 ;  
2720			; 
2720			;    db   1     ; user defined word  
2720 23			inc hl    
2721			;    dw   sysdict 
2721 23			inc hl 
2722 23			inc hl 
2723			;    db <word len>+1 (for null) 
2723 23			inc hl 
2724			;    db .... <word> 
2724			; 
2724			 
2724 23			inc hl    ; some extras for the word preamble before the above 
2725 23			inc hl 
2726 23			inc hl 
2727 23			inc hl 
2728 23			inc hl 
2729 23			inc hl 
272a 23			inc hl  
272b 23			inc hl 
272c 23			inc hl 
272d 23			inc hl 
272e 23			inc hl 
272f 23			inc hl 
2730 23			inc hl 
2731 23			inc hl     ; TODO how many do we really need?     maybe only 6 
2732			;       exec word buffer 
2732			;	<ptr word>   
2732 23			inc hl 
2733 23			inc hl 
2734			;       <word list><null term> 7F final term 
2734			 
2734			 
2734			if DEBUG_FORTH_UWORD 
2734					DMARK ":02" 
2734 f5				push af  
2735 3a 49 27			ld a, (.dmark)  
2738 32 a0 fd			ld (debug_mark),a  
273b 3a 4a 27			ld a, (.dmark+1)  
273e 32 a1 fd			ld (debug_mark+1),a  
2741 3a 4b 27			ld a, (.dmark+2)  
2744 32 a2 fd			ld (debug_mark+2),a  
2747 18 03			jr .pastdmark  
2749 ..			.dmark: db ":02"  
274c f1			.pastdmark: pop af  
274d			endm  
# End of macro DMARK
274d			CALLMONITOR 
274d cd aa fd			call debug_vector  
2750				endm  
# End of macro CALLMONITOR
2750			endif 
2750			 
2750			 
2750				; malloc the size 
2750			 
2750 cd b9 13			call malloc 
2753 22 e8 f0			ld (os_new_malloc), hl     ; save malloc start 
2756			 
2756			;    db   1     ; user defined word  
2756 3e 01			ld a, WORD_SYS_UWORD  
2758 77				ld (hl), a 
2759			 
2759 23			inc hl    
275a			;    dw   sysdict 
275a 11 8f 25		ld de, sysdict       ; continue on with the scan to the system dict 
275d 73			ld (hl), e 
275e 23			inc hl 
275f 72			ld (hl), d 
2760 23			inc hl 
2761			 
2761			 
2761			;    Setup dict word 
2761			 
2761 23			inc hl 
2762 22 e2 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
2765			 
2765			; 1. get length of dict word 
2765			 
2765			 
2765 2a f7 f3		ld hl, (os_tok_ptr) 
2768 23			inc hl 
2769 23			inc hl    ; position to start of dict word 
276a 3e 00		ld a, 0 
276c cd 4f 13		call strlent 
276f			 
276f			 
276f 23			inc hl    ; to include null??? 
2770			 
2770			; write length of dict word 
2770			 
2770 ed 5b e2 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2774 1b			dec de 
2775 eb			ex de, hl 
2776 73			ld (hl), e 
2777 eb			ex de, hl 
2778			 
2778			 
2778			 
2778			; copy  
2778 4d			ld c, l 
2779 06 00		ld b, 0 
277b ed 5b e2 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
277f 2a f7 f3		ld hl, (os_tok_ptr) 
2782 23			inc hl 
2783 23			inc hl    ; position to start of dict word 
2784			 
2784			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2784			 
2784			; TODO need to convert word to upper case 
2784			 
2784			ucasetok:	 
2784 7e			ld a,(hl) 
2785 cd 3b 13		call toUpper 
2788 77			ld (hl),a 
2789 ed a0		ldi 
278b f2 84 27		jp p, ucasetok 
278e			 
278e			 
278e			 
278e			; de now points to start of where the word body code should be placed 
278e ed 53 e2 f0	ld (os_new_work_ptr), de 
2792			; hl now points to the words to throw at forthexec which needs to be copied 
2792 22 e0 f0		ld (os_new_src_ptr), hl 
2795			 
2795			; TODO add 'call to forthexec' 
2795			 
2795			if DEBUG_FORTH_UWORD 
2795 c5			push bc 
2796 ed 4b e8 f0	ld bc, (os_new_malloc) 
279a					DMARK ":0x" 
279a f5				push af  
279b 3a af 27			ld a, (.dmark)  
279e 32 a0 fd			ld (debug_mark),a  
27a1 3a b0 27			ld a, (.dmark+1)  
27a4 32 a1 fd			ld (debug_mark+1),a  
27a7 3a b1 27			ld a, (.dmark+2)  
27aa 32 a2 fd			ld (debug_mark+2),a  
27ad 18 03			jr .pastdmark  
27af ..			.dmark: db ":0x"  
27b2 f1			.pastdmark: pop af  
27b3			endm  
# End of macro DMARK
27b3			CALLMONITOR 
27b3 cd aa fd			call debug_vector  
27b6				endm  
# End of macro CALLMONITOR
27b6 c1			pop bc 
27b7			endif 
27b7			 
27b7			 
27b7			; create word preamble which should be: 
27b7			 
27b7			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
27b7			 
27b7			;    ld hl, <word code> 
27b7			;    jp user_exec 
27b7			;    <word code bytes> 
27b7			 
27b7			 
27b7			;	inc de     ; TODO ??? or are we already past the word's null 
27b7 eb			ex de, hl 
27b8			 
27b8 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
27ba			 
27ba 23			inc hl 
27bb 22 dc f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
27be 23			inc hl 
27bf			 
27bf 23			inc hl 
27c0 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
27c2			 
27c2 01 b2 5d		ld bc, user_exec 
27c5 23			inc hl 
27c6 71			ld (hl), c     ; poke address of user_exec 
27c7 23			inc hl 
27c8 70			ld (hl), b     
27c9			; 
27c9			;	inc hl 
27c9			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27c9			; 
27c9			; 
27c9			;	ld bc, macro_forth_rsp_next 
27c9			;	inc hl 
27c9			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
27c9			;	inc hl 
27c9			;	ld (hl), b     
27c9			; 
27c9			;	inc hl 
27c9			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27c9			; 
27c9			; 
27c9			;	inc hl 
27c9			;	ld bc, forthexec 
27c9			;	ld (hl), c     ; poke address of forthexec 
27c9			;	inc hl 
27c9			;	ld (hl), b      
27c9			; 
27c9			;	inc hl 
27c9			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
27c9			; 
27c9			;	ld bc, user_dict_next 
27c9			;	inc hl 
27c9			;	ld (hl), c     ; poke address of forthexec 
27c9			;	inc hl 
27c9			;	ld (hl), b      
27c9			 
27c9			; hl is now where we need to copy the word byte data to save this 
27c9			 
27c9 23			inc hl 
27ca 22 de f0		ld (os_new_exec), hl 
27cd			 
27cd			; copy definition 
27cd			 
27cd eb			ex de, hl 
27ce			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
27ce			;	inc de    ; skip the PC for this parse 
27ce 3a e6 f0		ld a, (os_new_parse_len) 
27d1 4f			ld c, a 
27d2 06 00		ld b, 0 
27d4 ed b0		ldir		 ; copy defintion 
27d6			 
27d6			 
27d6			; poke the address of where the new word bytes live for forthexec 
27d6			 
27d6 2a dc f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
27d9			 
27d9 ed 5b de f0	ld de, (os_new_exec)      
27dd			 
27dd 73			ld (hl), e 
27de 23			inc hl 
27df 72			ld (hl), d 
27e0			 
27e0				; TODO copy last user dict word next link to this word 
27e0				; TODO update last user dict word to point to this word 
27e0			; 
27e0			; hl f923 de 812a ; bc 811a 
27e0			 
27e0			if DEBUG_FORTH_UWORD 
27e0 c5			push bc 
27e1 ed 4b e8 f0	ld bc, (os_new_malloc) 
27e5					DMARK ":0A" 
27e5 f5				push af  
27e6 3a fa 27			ld a, (.dmark)  
27e9 32 a0 fd			ld (debug_mark),a  
27ec 3a fb 27			ld a, (.dmark+1)  
27ef 32 a1 fd			ld (debug_mark+1),a  
27f2 3a fc 27			ld a, (.dmark+2)  
27f5 32 a2 fd			ld (debug_mark+2),a  
27f8 18 03			jr .pastdmark  
27fa ..			.dmark: db ":0A"  
27fd f1			.pastdmark: pop af  
27fe			endm  
# End of macro DMARK
27fe			CALLMONITOR 
27fe cd aa fd			call debug_vector  
2801				endm  
# End of macro CALLMONITOR
2801 c1			pop bc 
2802			endif 
2802			if DEBUG_FORTH_UWORD 
2802 c5			push bc 
2803 ed 4b e8 f0	ld bc, (os_new_malloc) 
2807 03			inc bc 
2808 03			inc bc 
2809 03			inc bc 
280a 03			inc bc 
280b 03			inc bc 
280c 03			inc bc 
280d 03			inc bc 
280e 03			inc bc 
280f			 
280f					DMARK ":0B" 
280f f5				push af  
2810 3a 24 28			ld a, (.dmark)  
2813 32 a0 fd			ld (debug_mark),a  
2816 3a 25 28			ld a, (.dmark+1)  
2819 32 a1 fd			ld (debug_mark+1),a  
281c 3a 26 28			ld a, (.dmark+2)  
281f 32 a2 fd			ld (debug_mark+2),a  
2822 18 03			jr .pastdmark  
2824 ..			.dmark: db ":0B"  
2827 f1			.pastdmark: pop af  
2828			endm  
# End of macro DMARK
2828			CALLMONITOR 
2828 cd aa fd			call debug_vector  
282b				endm  
# End of macro CALLMONITOR
282b c1			pop bc 
282c			endif 
282c			 
282c			; update word dict linked list for new word 
282c			 
282c			 
282c 2a f3 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
282f 23			inc hl     ; move to next work linked list ptr 
2830			 
2830 ed 5b e8 f0	ld de, (os_new_malloc)		 ; new next word 
2834 73			ld (hl), e 
2835 23			inc hl 
2836 72			ld (hl), d 
2837			 
2837			if DEBUG_FORTH_UWORD 
2837 ed 4b f3 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
283b			endif 
283b			 
283b ed 53 f3 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
283f			 
283f			 
283f			if DEBUG_FORTH_UWORD 
283f					DMARK ":0+" 
283f f5				push af  
2840 3a 54 28			ld a, (.dmark)  
2843 32 a0 fd			ld (debug_mark),a  
2846 3a 55 28			ld a, (.dmark+1)  
2849 32 a1 fd			ld (debug_mark+1),a  
284c 3a 56 28			ld a, (.dmark+2)  
284f 32 a2 fd			ld (debug_mark+2),a  
2852 18 03			jr .pastdmark  
2854 ..			.dmark: db ":0+"  
2857 f1			.pastdmark: pop af  
2858			endm  
# End of macro DMARK
2858			CALLMONITOR 
2858 cd aa fd			call debug_vector  
285b				endm  
# End of macro CALLMONITOR
285b			endif 
285b			 
285b			STACKFRAMECHK OFF $8efe $989f 
285b				if DEBUG_STACK_IMB 
285b					if OFF 
285b						exx 
285b						ld hl, $989f 
285b						pop de   ; $989f 
285b						call cmp16 
285b						jr nz, .spnosame 
285b						ld hl, $8efe 
285b						pop de   ; $8efe 
285b						call cmp16 
285b						jr z, .spfrsame 
285b						.spnosame: call showsperror 
285b						.spfrsame: nop 
285b						exx 
285b					endif 
285b				endif 
285b			endm 
# End of macro STACKFRAMECHK
285b			 
285b c9			ret    ; dont process any remaining parser tokens as they form new word 
285c			 
285c			 
285c			 
285c			 
285c			;		NEXT 
285c			.SCOLN: 
285c			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
285c 06			db OPCODE_SCOLN 
285d a8 28		dw .DROP 
285f 02			db 2 
2860 .. 00		db ";",0           
2862			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2862				if DEBUG_FORTH_WORDS_KEY 
2862					DMARK "SCN" 
2862 f5				push af  
2863 3a 77 28			ld a, (.dmark)  
2866 32 a0 fd			ld (debug_mark),a  
2869 3a 78 28			ld a, (.dmark+1)  
286c 32 a1 fd			ld (debug_mark+1),a  
286f 3a 79 28			ld a, (.dmark+2)  
2872 32 a2 fd			ld (debug_mark+2),a  
2875 18 03			jr .pastdmark  
2877 ..			.dmark: db "SCN"  
287a f1			.pastdmark: pop af  
287b			endm  
# End of macro DMARK
287b					CALLMONITOR 
287b cd aa fd			call debug_vector  
287e				endm  
# End of macro CALLMONITOR
287e				endif 
287e				FORTH_RSP_TOS 
287e cd 04 20			call macro_forth_rsp_tos 
2881				endm 
# End of macro FORTH_RSP_TOS
2881 e5				push hl 
2882				FORTH_RSP_POP 
2882 cd 0e 20			call macro_forth_rsp_pop 
2885				endm 
# End of macro FORTH_RSP_POP
2885 e1				pop hl 
2886			;		ex de,hl 
2886 22 f7 f3			ld (os_tok_ptr),hl 
2889			 
2889			if DEBUG_FORTH_UWORD 
2889					DMARK "SCL" 
2889 f5				push af  
288a 3a 9e 28			ld a, (.dmark)  
288d 32 a0 fd			ld (debug_mark),a  
2890 3a 9f 28			ld a, (.dmark+1)  
2893 32 a1 fd			ld (debug_mark+1),a  
2896 3a a0 28			ld a, (.dmark+2)  
2899 32 a2 fd			ld (debug_mark+2),a  
289c 18 03			jr .pastdmark  
289e ..			.dmark: db "SCL"  
28a1 f1			.pastdmark: pop af  
28a2			endm  
# End of macro DMARK
28a2			CALLMONITOR 
28a2 cd aa fd			call debug_vector  
28a5				endm  
# End of macro CALLMONITOR
28a5			endif 
28a5				NEXTW 
28a5 c3 37 24			jp macro_next 
28a8				endm 
# End of macro NEXTW
28a8			 
28a8			.DROP: 
28a8			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
28a8 1b				db WORD_SYS_CORE+OPCODE_DROP             
28a9 d3 28			dw .DUP2            
28ab 05				db 4 + 1 
28ac .. 00			db "DROP",0              
28b1				endm 
# End of macro CWHEAD
28b1			; | DROP ( w -- )   drop the TOS item   | DONE 
28b1				if DEBUG_FORTH_WORDS_KEY 
28b1					DMARK "DRP" 
28b1 f5				push af  
28b2 3a c6 28			ld a, (.dmark)  
28b5 32 a0 fd			ld (debug_mark),a  
28b8 3a c7 28			ld a, (.dmark+1)  
28bb 32 a1 fd			ld (debug_mark+1),a  
28be 3a c8 28			ld a, (.dmark+2)  
28c1 32 a2 fd			ld (debug_mark+2),a  
28c4 18 03			jr .pastdmark  
28c6 ..			.dmark: db "DRP"  
28c9 f1			.pastdmark: pop af  
28ca			endm  
# End of macro DMARK
28ca					CALLMONITOR 
28ca cd aa fd			call debug_vector  
28cd				endm  
# End of macro CALLMONITOR
28cd				endif 
28cd				FORTH_DSP_POP 
28cd cd 03 23			call macro_forth_dsp_pop 
28d0				endm 
# End of macro FORTH_DSP_POP
28d0				NEXTW 
28d0 c3 37 24			jp macro_next 
28d3				endm 
# End of macro NEXTW
28d3			.DUP2: 
28d3			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
28d3 1c				db WORD_SYS_CORE+OPCODE_DUP2             
28d4 18 29			dw .DROP2            
28d6 05				db 4 + 1 
28d7 .. 00			db "2DUP",0              
28dc				endm 
# End of macro CWHEAD
28dc			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
28dc				if DEBUG_FORTH_WORDS_KEY 
28dc					DMARK "2DU" 
28dc f5				push af  
28dd 3a f1 28			ld a, (.dmark)  
28e0 32 a0 fd			ld (debug_mark),a  
28e3 3a f2 28			ld a, (.dmark+1)  
28e6 32 a1 fd			ld (debug_mark+1),a  
28e9 3a f3 28			ld a, (.dmark+2)  
28ec 32 a2 fd			ld (debug_mark+2),a  
28ef 18 03			jr .pastdmark  
28f1 ..			.dmark: db "2DU"  
28f4 f1			.pastdmark: pop af  
28f5			endm  
# End of macro DMARK
28f5					CALLMONITOR 
28f5 cd aa fd			call debug_vector  
28f8				endm  
# End of macro CALLMONITOR
28f8				endif 
28f8				FORTH_DSP_VALUEHL 
28f8 cd 4b 22			call macro_dsp_valuehl 
28fb				endm 
# End of macro FORTH_DSP_VALUEHL
28fb e5				push hl      ; 2 
28fc			 
28fc				FORTH_DSP_POP 
28fc cd 03 23			call macro_forth_dsp_pop 
28ff				endm 
# End of macro FORTH_DSP_POP
28ff				 
28ff				FORTH_DSP_VALUEHL 
28ff cd 4b 22			call macro_dsp_valuehl 
2902				endm 
# End of macro FORTH_DSP_VALUEHL
2902			;		push hl      ; 1 
2902			 
2902				FORTH_DSP_POP 
2902 cd 03 23			call macro_forth_dsp_pop 
2905				endm 
# End of macro FORTH_DSP_POP
2905			 
2905			;		pop hl       ; 1 
2905 d1				pop de       ; 2 
2906			 
2906 cd 46 20			call forth_push_numhl 
2909 eb				ex de, hl 
290a cd 46 20			call forth_push_numhl 
290d			 
290d				 
290d eb				ex de, hl 
290e			 
290e cd 46 20			call forth_push_numhl 
2911 eb				ex de, hl 
2912 cd 46 20			call forth_push_numhl 
2915			 
2915			 
2915				NEXTW 
2915 c3 37 24			jp macro_next 
2918				endm 
# End of macro NEXTW
2918			.DROP2: 
2918			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2918 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2919 47 29			dw .PICK            
291b 06				db 5 + 1 
291c .. 00			db "2DROP",0              
2922				endm 
# End of macro CWHEAD
2922			; | 2DROP ( w w -- )    Double drop | DONE 
2922				if DEBUG_FORTH_WORDS_KEY 
2922					DMARK "2DR" 
2922 f5				push af  
2923 3a 37 29			ld a, (.dmark)  
2926 32 a0 fd			ld (debug_mark),a  
2929 3a 38 29			ld a, (.dmark+1)  
292c 32 a1 fd			ld (debug_mark+1),a  
292f 3a 39 29			ld a, (.dmark+2)  
2932 32 a2 fd			ld (debug_mark+2),a  
2935 18 03			jr .pastdmark  
2937 ..			.dmark: db "2DR"  
293a f1			.pastdmark: pop af  
293b			endm  
# End of macro DMARK
293b					CALLMONITOR 
293b cd aa fd			call debug_vector  
293e				endm  
# End of macro CALLMONITOR
293e				endif 
293e				FORTH_DSP_POP 
293e cd 03 23			call macro_forth_dsp_pop 
2941				endm 
# End of macro FORTH_DSP_POP
2941				FORTH_DSP_POP 
2941 cd 03 23			call macro_forth_dsp_pop 
2944				endm 
# End of macro FORTH_DSP_POP
2944				NEXTW 
2944 c3 37 24			jp macro_next 
2947				endm 
# End of macro NEXTW
2947			.PICK: 
2947			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
2947 77				db WORD_SYS_CORE+99             
2948 85 29			dw .SWAP2            
294a 05				db 4 + 1 
294b .. 00			db "PICK",0              
2950				endm 
# End of macro CWHEAD
2950			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | TODO 
2950				if DEBUG_FORTH_WORDS_KEY 
2950					DMARK "PIK" 
2950 f5				push af  
2951 3a 65 29			ld a, (.dmark)  
2954 32 a0 fd			ld (debug_mark),a  
2957 3a 66 29			ld a, (.dmark+1)  
295a 32 a1 fd			ld (debug_mark+1),a  
295d 3a 67 29			ld a, (.dmark+2)  
2960 32 a2 fd			ld (debug_mark+2),a  
2963 18 03			jr .pastdmark  
2965 ..			.dmark: db "PIK"  
2968 f1			.pastdmark: pop af  
2969			endm  
# End of macro DMARK
2969					CALLMONITOR 
2969 cd aa fd			call debug_vector  
296c				endm  
# End of macro CALLMONITOR
296c				endif 
296c			 
296c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
296c cd 4b 22			call macro_dsp_valuehl 
296f				endm 
# End of macro FORTH_DSP_VALUEHL
296f				 
296f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
296f cd 03 23			call macro_forth_dsp_pop 
2972				endm 
# End of macro FORTH_DSP_POP
2972			 
2972				; init from TOS 
2972 45				ld b, l 
2973 21 23 f9			ld hl, cli_data_sp 
2976			.pkl: 
2976 2b				dec hl 
2977 2b				dec hl 
2978 2b				dec hl 
2979			 
2979 10 fb			djnz .pkl 
297b			 
297b				 
297b				; TODO do type check with correct push 
297b			 
297b 23				inc hl 
297c cd b9 23			call loadwordinhl 
297f cd 46 20			call forth_push_numhl 
2982			 
2982				NEXTW 
2982 c3 37 24			jp macro_next 
2985				endm 
# End of macro NEXTW
2985			.SWAP2: 
2985			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2985 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2986 ae 29			dw .AT            
2988 06				db 5 + 1 
2989 .. 00			db "2SWAP",0              
298f				endm 
# End of macro CWHEAD
298f			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
298f				if DEBUG_FORTH_WORDS_KEY 
298f					DMARK "2SW" 
298f f5				push af  
2990 3a a4 29			ld a, (.dmark)  
2993 32 a0 fd			ld (debug_mark),a  
2996 3a a5 29			ld a, (.dmark+1)  
2999 32 a1 fd			ld (debug_mark+1),a  
299c 3a a6 29			ld a, (.dmark+2)  
299f 32 a2 fd			ld (debug_mark+2),a  
29a2 18 03			jr .pastdmark  
29a4 ..			.dmark: db "2SW"  
29a7 f1			.pastdmark: pop af  
29a8			endm  
# End of macro DMARK
29a8					CALLMONITOR 
29a8 cd aa fd			call debug_vector  
29ab				endm  
# End of macro CALLMONITOR
29ab				endif 
29ab			; TODO Use os stack swap memory 
29ab				NEXTW 
29ab c3 37 24			jp macro_next 
29ae				endm 
# End of macro NEXTW
29ae			.AT: 
29ae			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
29ae 1f				db WORD_SYS_CORE+OPCODE_AT             
29af e0 29			dw .CAT            
29b1 02				db 1 + 1 
29b2 .. 00			db "@",0              
29b4				endm 
# End of macro CWHEAD
29b4			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
29b4			 
29b4				if DEBUG_FORTH_WORDS_KEY 
29b4					DMARK "AT." 
29b4 f5				push af  
29b5 3a c9 29			ld a, (.dmark)  
29b8 32 a0 fd			ld (debug_mark),a  
29bb 3a ca 29			ld a, (.dmark+1)  
29be 32 a1 fd			ld (debug_mark+1),a  
29c1 3a cb 29			ld a, (.dmark+2)  
29c4 32 a2 fd			ld (debug_mark+2),a  
29c7 18 03			jr .pastdmark  
29c9 ..			.dmark: db "AT."  
29cc f1			.pastdmark: pop af  
29cd			endm  
# End of macro DMARK
29cd					CALLMONITOR 
29cd cd aa fd			call debug_vector  
29d0				endm  
# End of macro CALLMONITOR
29d0				endif 
29d0			.getbyteat:	 
29d0				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29d0 cd 4b 22			call macro_dsp_valuehl 
29d3				endm 
# End of macro FORTH_DSP_VALUEHL
29d3				 
29d3			;		push hl 
29d3			 
29d3				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29d3 cd 03 23			call macro_forth_dsp_pop 
29d6				endm 
# End of macro FORTH_DSP_POP
29d6			 
29d6			;		pop hl 
29d6			 
29d6 7e				ld a, (hl) 
29d7			 
29d7 6f				ld l, a 
29d8 26 00			ld h, 0 
29da cd 46 20			call forth_push_numhl 
29dd			 
29dd				NEXTW 
29dd c3 37 24			jp macro_next 
29e0				endm 
# End of macro NEXTW
29e0			.CAT: 
29e0			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
29e0 20				db WORD_SYS_CORE+OPCODE_CAT             
29e1 09 2a			dw .BANG            
29e3 03				db 2 + 1 
29e4 .. 00			db "C@",0              
29e7				endm 
# End of macro CWHEAD
29e7			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
29e7				if DEBUG_FORTH_WORDS_KEY 
29e7					DMARK "CAA" 
29e7 f5				push af  
29e8 3a fc 29			ld a, (.dmark)  
29eb 32 a0 fd			ld (debug_mark),a  
29ee 3a fd 29			ld a, (.dmark+1)  
29f1 32 a1 fd			ld (debug_mark+1),a  
29f4 3a fe 29			ld a, (.dmark+2)  
29f7 32 a2 fd			ld (debug_mark+2),a  
29fa 18 03			jr .pastdmark  
29fc ..			.dmark: db "CAA"  
29ff f1			.pastdmark: pop af  
2a00			endm  
# End of macro DMARK
2a00					CALLMONITOR 
2a00 cd aa fd			call debug_vector  
2a03				endm  
# End of macro CALLMONITOR
2a03				endif 
2a03 c3 d0 29			jp .getbyteat 
2a06				NEXTW 
2a06 c3 37 24			jp macro_next 
2a09				endm 
# End of macro NEXTW
2a09			.BANG: 
2a09			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2a09 21				db WORD_SYS_CORE+OPCODE_BANG             
2a0a 3f 2a			dw .CBANG            
2a0c 02				db 1 + 1 
2a0d .. 00			db "!",0              
2a0f				endm 
# End of macro CWHEAD
2a0f			; | ! ( x w -- ) Store x at address w      | DONE 
2a0f				if DEBUG_FORTH_WORDS_KEY 
2a0f					DMARK "BNG" 
2a0f f5				push af  
2a10 3a 24 2a			ld a, (.dmark)  
2a13 32 a0 fd			ld (debug_mark),a  
2a16 3a 25 2a			ld a, (.dmark+1)  
2a19 32 a1 fd			ld (debug_mark+1),a  
2a1c 3a 26 2a			ld a, (.dmark+2)  
2a1f 32 a2 fd			ld (debug_mark+2),a  
2a22 18 03			jr .pastdmark  
2a24 ..			.dmark: db "BNG"  
2a27 f1			.pastdmark: pop af  
2a28			endm  
# End of macro DMARK
2a28					CALLMONITOR 
2a28 cd aa fd			call debug_vector  
2a2b				endm  
# End of macro CALLMONITOR
2a2b				endif 
2a2b			 
2a2b			.storebyteat:		 
2a2b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a2b cd 4b 22			call macro_dsp_valuehl 
2a2e				endm 
# End of macro FORTH_DSP_VALUEHL
2a2e				 
2a2e e5				push hl 
2a2f			 
2a2f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a2f cd 03 23			call macro_forth_dsp_pop 
2a32				endm 
# End of macro FORTH_DSP_POP
2a32			 
2a32				; get byte to poke 
2a32			 
2a32				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a32 cd 4b 22			call macro_dsp_valuehl 
2a35				endm 
# End of macro FORTH_DSP_VALUEHL
2a35 e5				push hl 
2a36			 
2a36			 
2a36				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a36 cd 03 23			call macro_forth_dsp_pop 
2a39				endm 
# End of macro FORTH_DSP_POP
2a39			 
2a39			 
2a39 d1				pop de 
2a3a e1				pop hl 
2a3b			 
2a3b 73				ld (hl),e 
2a3c			 
2a3c			 
2a3c				NEXTW 
2a3c c3 37 24			jp macro_next 
2a3f				endm 
# End of macro NEXTW
2a3f			.CBANG: 
2a3f			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2a3f 22				db WORD_SYS_CORE+OPCODE_CBANG             
2a40 68 2a			dw .SCALL            
2a42 03				db 2 + 1 
2a43 .. 00			db "C!",0              
2a46				endm 
# End of macro CWHEAD
2a46			; | C!  ( x w -- ) Store x at address w  | DONE 
2a46				if DEBUG_FORTH_WORDS_KEY 
2a46					DMARK "CBA" 
2a46 f5				push af  
2a47 3a 5b 2a			ld a, (.dmark)  
2a4a 32 a0 fd			ld (debug_mark),a  
2a4d 3a 5c 2a			ld a, (.dmark+1)  
2a50 32 a1 fd			ld (debug_mark+1),a  
2a53 3a 5d 2a			ld a, (.dmark+2)  
2a56 32 a2 fd			ld (debug_mark+2),a  
2a59 18 03			jr .pastdmark  
2a5b ..			.dmark: db "CBA"  
2a5e f1			.pastdmark: pop af  
2a5f			endm  
# End of macro DMARK
2a5f					CALLMONITOR 
2a5f cd aa fd			call debug_vector  
2a62				endm  
# End of macro CALLMONITOR
2a62				endif 
2a62 c3 2b 2a			jp .storebyteat 
2a65				NEXTW 
2a65 c3 37 24			jp macro_next 
2a68				endm 
# End of macro NEXTW
2a68			.SCALL: 
2a68			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2a68 23				db WORD_SYS_CORE+OPCODE_SCALL             
2a69 9c 2a			dw .DEPTH            
2a6b 05				db 4 + 1 
2a6c .. 00			db "CALL",0              
2a71				endm 
# End of macro CWHEAD
2a71			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2a71				if DEBUG_FORTH_WORDS_KEY 
2a71					DMARK "CLL" 
2a71 f5				push af  
2a72 3a 86 2a			ld a, (.dmark)  
2a75 32 a0 fd			ld (debug_mark),a  
2a78 3a 87 2a			ld a, (.dmark+1)  
2a7b 32 a1 fd			ld (debug_mark+1),a  
2a7e 3a 88 2a			ld a, (.dmark+2)  
2a81 32 a2 fd			ld (debug_mark+2),a  
2a84 18 03			jr .pastdmark  
2a86 ..			.dmark: db "CLL"  
2a89 f1			.pastdmark: pop af  
2a8a			endm  
# End of macro DMARK
2a8a					CALLMONITOR 
2a8a cd aa fd			call debug_vector  
2a8d				endm  
# End of macro CALLMONITOR
2a8d				endif 
2a8d			 
2a8d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a8d cd 4b 22			call macro_dsp_valuehl 
2a90				endm 
# End of macro FORTH_DSP_VALUEHL
2a90			 
2a90			;		push hl 
2a90			 
2a90				; destroy value TOS 
2a90			 
2a90				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a90 cd 03 23			call macro_forth_dsp_pop 
2a93				endm 
# End of macro FORTH_DSP_POP
2a93			 
2a93					 
2a93			;		pop hl 
2a93			 
2a93				; how to do a call with hl???? save SP? 
2a93 cd db 23			call forth_call_hl 
2a96			 
2a96			 
2a96				; TODO push value back onto stack for another op etc 
2a96			 
2a96 cd 46 20			call forth_push_numhl 
2a99				NEXTW 
2a99 c3 37 24			jp macro_next 
2a9c				endm 
# End of macro NEXTW
2a9c			.DEPTH: 
2a9c			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2a9c 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2a9d d9 2a			dw .OVER            
2a9f 06				db 5 + 1 
2aa0 .. 00			db "DEPTH",0              
2aa6				endm 
# End of macro CWHEAD
2aa6			; | DEPTH ( -- u ) Push count of stack | DONE 
2aa6				; take current TOS and remove from base value div by two to get count 
2aa6				if DEBUG_FORTH_WORDS_KEY 
2aa6					DMARK "DEP" 
2aa6 f5				push af  
2aa7 3a bb 2a			ld a, (.dmark)  
2aaa 32 a0 fd			ld (debug_mark),a  
2aad 3a bc 2a			ld a, (.dmark+1)  
2ab0 32 a1 fd			ld (debug_mark+1),a  
2ab3 3a bd 2a			ld a, (.dmark+2)  
2ab6 32 a2 fd			ld (debug_mark+2),a  
2ab9 18 03			jr .pastdmark  
2abb ..			.dmark: db "DEP"  
2abe f1			.pastdmark: pop af  
2abf			endm  
# End of macro DMARK
2abf					CALLMONITOR 
2abf cd aa fd			call debug_vector  
2ac2				endm  
# End of macro CALLMONITOR
2ac2				endif 
2ac2			 
2ac2			 
2ac2 2a 23 f9		ld hl, (cli_data_sp) 
2ac5 11 5d f6		ld de, cli_data_stack 
2ac8 ed 52		sbc hl,de 
2aca			 
2aca			; div by size of stack item 
2aca			 
2aca 5d			ld e,l 
2acb 0e 03		ld c, 3 
2acd cd 6e 0f		call Div8 
2ad0			 
2ad0 6f			ld l,a 
2ad1 26 00		ld h,0 
2ad3			 
2ad3			;srl h 
2ad3			;rr l 
2ad3			 
2ad3 cd 46 20			call forth_push_numhl 
2ad6				NEXTW 
2ad6 c3 37 24			jp macro_next 
2ad9				endm 
# End of macro NEXTW
2ad9			.OVER: 
2ad9			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2ad9 42				db WORD_SYS_CORE+46             
2ada 20 2b			dw .PAUSE            
2adc 05				db 4 + 1 
2add .. 00			db "OVER",0              
2ae2				endm 
# End of macro CWHEAD
2ae2			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | TOFIX 
2ae2				if DEBUG_FORTH_WORDS_KEY 
2ae2					DMARK "OVR" 
2ae2 f5				push af  
2ae3 3a f7 2a			ld a, (.dmark)  
2ae6 32 a0 fd			ld (debug_mark),a  
2ae9 3a f8 2a			ld a, (.dmark+1)  
2aec 32 a1 fd			ld (debug_mark+1),a  
2aef 3a f9 2a			ld a, (.dmark+2)  
2af2 32 a2 fd			ld (debug_mark+2),a  
2af5 18 03			jr .pastdmark  
2af7 ..			.dmark: db "OVR"  
2afa f1			.pastdmark: pop af  
2afb			endm  
# End of macro DMARK
2afb					CALLMONITOR 
2afb cd aa fd			call debug_vector  
2afe				endm  
# End of macro CALLMONITOR
2afe				endif 
2afe			 
2afe			; TODO Use os stack swap memory 
2afe			 
2afe				; work out what type we are looking at 
2afe			 
2afe				FORTH_DSP_PTR 1 
2afe 2a 23 f9			ld hl,(cli_data_sp) 
2b01 11 03 00			ld de, 1 * 3 
2b04 ed 52			sbc hl, de 
2b06				endm 
# End of macro FORTH_DSP_PTR
2b06			 
2b06 7e				ld a, (hl) 
2b07				 
2b07 f5				push af 
2b08				; whatever the type lets get the pointer or word 
2b08 23				inc hl 
2b09			;; 
2b09			 
2b09				; type check now to decide on how to push  
2b09			 
2b09 cd b9 23			call loadwordinhl 
2b0c f1				pop af 
2b0d fe 01			cp DS_TYPE_STR 
2b0f 28 06			jr z, .ovstr 
2b11			 
2b11				; we have a numeric so load the word and push 
2b11			;	ld e, (hl) 
2b11			;	inc hl 
2b11			;	ld d, (hl) 
2b11			;	ex de, hl 
2b11 cd 46 20			call forth_push_numhl 
2b14				NEXTW 
2b14 c3 37 24			jp macro_next 
2b17				endm 
# End of macro NEXTW
2b17			 
2b17			.ovstr: 
2b17				; ok, a string so get the pointer and push as a string 
2b17			 
2b17			;	call loadwordinhl 
2b17 cd b4 20			call forth_push_str 
2b1a				NEXTW 
2b1a c3 37 24			jp macro_next 
2b1d				endm 
# End of macro NEXTW
2b1d			 
2b1d			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b1d			;	push hl    ; n2 
2b1d			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b1d			; 
2b1d			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b1d			;	push hl    ; n1 
2b1d			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b1d			; 
2b1d			;	pop de     ; n1 
2b1d			;	pop hl     ; n2 
2b1d			; 
2b1d			;	push de 
2b1d			;	push hl 
2b1d			;	push de 
2b1d			 
2b1d				; push back  
2b1d			 
2b1d			;	pop hl 
2b1d			;	call forth_push_numhl 
2b1d			;	pop hl 
2b1d			;	call forth_push_numhl 
2b1d			;	pop hl 
2b1d			;	call forth_push_numhl 
2b1d				NEXTW 
2b1d c3 37 24			jp macro_next 
2b20				endm 
# End of macro NEXTW
2b20			 
2b20			.PAUSE: 
2b20			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2b20 43				db WORD_SYS_CORE+47             
2b21 55 2b			dw .PAUSES            
2b23 08				db 7 + 1 
2b24 .. 00			db "PAUSEMS",0              
2b2c				endm 
# End of macro CWHEAD
2b2c			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2b2c				if DEBUG_FORTH_WORDS_KEY 
2b2c					DMARK "PMS" 
2b2c f5				push af  
2b2d 3a 41 2b			ld a, (.dmark)  
2b30 32 a0 fd			ld (debug_mark),a  
2b33 3a 42 2b			ld a, (.dmark+1)  
2b36 32 a1 fd			ld (debug_mark+1),a  
2b39 3a 43 2b			ld a, (.dmark+2)  
2b3c 32 a2 fd			ld (debug_mark+2),a  
2b3f 18 03			jr .pastdmark  
2b41 ..			.dmark: db "PMS"  
2b44 f1			.pastdmark: pop af  
2b45			endm  
# End of macro DMARK
2b45					CALLMONITOR 
2b45 cd aa fd			call debug_vector  
2b48				endm  
# End of macro CALLMONITOR
2b48				endif 
2b48				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b48 cd 4b 22			call macro_dsp_valuehl 
2b4b				endm 
# End of macro FORTH_DSP_VALUEHL
2b4b			;		push hl    ; n2 
2b4b				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b4b cd 03 23			call macro_forth_dsp_pop 
2b4e				endm 
# End of macro FORTH_DSP_POP
2b4e			;		pop hl 
2b4e			 
2b4e 7d				ld a, l 
2b4f cd d2 0c			call aDelayInMS 
2b52			       NEXTW 
2b52 c3 37 24			jp macro_next 
2b55				endm 
# End of macro NEXTW
2b55			.PAUSES:  
2b55			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b55 44				db WORD_SYS_CORE+48             
2b56 c4 2b			dw .ROT            
2b58 06				db 5 + 1 
2b59 .. 00			db "PAUSE",0              
2b5f				endm 
# End of macro CWHEAD
2b5f			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b5f				if DEBUG_FORTH_WORDS_KEY 
2b5f					DMARK "PAU" 
2b5f f5				push af  
2b60 3a 74 2b			ld a, (.dmark)  
2b63 32 a0 fd			ld (debug_mark),a  
2b66 3a 75 2b			ld a, (.dmark+1)  
2b69 32 a1 fd			ld (debug_mark+1),a  
2b6c 3a 76 2b			ld a, (.dmark+2)  
2b6f 32 a2 fd			ld (debug_mark+2),a  
2b72 18 03			jr .pastdmark  
2b74 ..			.dmark: db "PAU"  
2b77 f1			.pastdmark: pop af  
2b78			endm  
# End of macro DMARK
2b78					CALLMONITOR 
2b78 cd aa fd			call debug_vector  
2b7b				endm  
# End of macro CALLMONITOR
2b7b				endif 
2b7b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b7b cd 4b 22			call macro_dsp_valuehl 
2b7e				endm 
# End of macro FORTH_DSP_VALUEHL
2b7e			;		push hl    ; n2 
2b7e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b7e cd 03 23			call macro_forth_dsp_pop 
2b81				endm 
# End of macro FORTH_DSP_POP
2b81			;		pop hl 
2b81 45				ld b, l 
2b82				if DEBUG_FORTH_WORDS 
2b82					DMARK "PAU" 
2b82 f5				push af  
2b83 3a 97 2b			ld a, (.dmark)  
2b86 32 a0 fd			ld (debug_mark),a  
2b89 3a 98 2b			ld a, (.dmark+1)  
2b8c 32 a1 fd			ld (debug_mark+1),a  
2b8f 3a 99 2b			ld a, (.dmark+2)  
2b92 32 a2 fd			ld (debug_mark+2),a  
2b95 18 03			jr .pastdmark  
2b97 ..			.dmark: db "PAU"  
2b9a f1			.pastdmark: pop af  
2b9b			endm  
# End of macro DMARK
2b9b					CALLMONITOR 
2b9b cd aa fd			call debug_vector  
2b9e				endm  
# End of macro CALLMONITOR
2b9e				endif 
2b9e c5			.pauses1:	push bc 
2b9f cd ed 0c			call delay1s 
2ba2 c1				pop bc 
2ba3				if DEBUG_FORTH_WORDS 
2ba3					DMARK "PA1" 
2ba3 f5				push af  
2ba4 3a b8 2b			ld a, (.dmark)  
2ba7 32 a0 fd			ld (debug_mark),a  
2baa 3a b9 2b			ld a, (.dmark+1)  
2bad 32 a1 fd			ld (debug_mark+1),a  
2bb0 3a ba 2b			ld a, (.dmark+2)  
2bb3 32 a2 fd			ld (debug_mark+2),a  
2bb6 18 03			jr .pastdmark  
2bb8 ..			.dmark: db "PA1"  
2bbb f1			.pastdmark: pop af  
2bbc			endm  
# End of macro DMARK
2bbc					CALLMONITOR 
2bbc cd aa fd			call debug_vector  
2bbf				endm  
# End of macro CALLMONITOR
2bbf				endif 
2bbf 10 dd			djnz .pauses1 
2bc1			 
2bc1			       NEXTW 
2bc1 c3 37 24			jp macro_next 
2bc4				endm 
# End of macro NEXTW
2bc4			.ROT: 
2bc4			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2bc4 45				db WORD_SYS_CORE+49             
2bc5 2d 2c			dw .UWORDS            
2bc7 04				db 3 + 1 
2bc8 .. 00			db "ROT",0              
2bcc				endm 
# End of macro CWHEAD
2bcc			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | TOFIX 
2bcc				if DEBUG_FORTH_WORDS_KEY 
2bcc					DMARK "ROT" 
2bcc f5				push af  
2bcd 3a e1 2b			ld a, (.dmark)  
2bd0 32 a0 fd			ld (debug_mark),a  
2bd3 3a e2 2b			ld a, (.dmark+1)  
2bd6 32 a1 fd			ld (debug_mark+1),a  
2bd9 3a e3 2b			ld a, (.dmark+2)  
2bdc 32 a2 fd			ld (debug_mark+2),a  
2bdf 18 03			jr .pastdmark  
2be1 ..			.dmark: db "ROT"  
2be4 f1			.pastdmark: pop af  
2be5			endm  
# End of macro DMARK
2be5					CALLMONITOR 
2be5 cd aa fd			call debug_vector  
2be8				endm  
# End of macro CALLMONITOR
2be8				endif 
2be8			 
2be8			; DONE Use os stack swap memory 
2be8			 
2be8				FORTH_DSP_PTR 0     ; u3 
2be8 2a 23 f9			ld hl,(cli_data_sp) 
2beb 11 00 00			ld de, 0 * 3 
2bee ed 52			sbc hl, de 
2bf0				endm 
# End of macro FORTH_DSP_PTR
2bf0 cd 83 23			call hltostack1     
2bf3			  
2bf3				FORTH_DSP_PTR 1     ; u2 
2bf3 2a 23 f9			ld hl,(cli_data_sp) 
2bf6 11 03 00			ld de, 1 * 3 
2bf9 ed 52			sbc hl, de 
2bfb				endm 
# End of macro FORTH_DSP_PTR
2bfb cd 89 23			call hltostack2      
2bfe			 
2bfe				FORTH_DSP_PTR 2     ; u1 
2bfe 2a 23 f9			ld hl,(cli_data_sp) 
2c01 11 06 00			ld de, 2 * 3 
2c04 ed 52			sbc hl, de 
2c06				endm 
# End of macro FORTH_DSP_PTR
2c06 cd 8f 23			call hltostack3 
2c09			 
2c09			 
2c09				FORTH_DSP_PTR 0     ;  
2c09 2a 23 f9			ld hl,(cli_data_sp) 
2c0c 11 00 00			ld de, 0 * 3 
2c0f ed 52			sbc hl, de 
2c11				endm 
# End of macro FORTH_DSP_PTR
2c11 cd a7 23			call hlfromstack3 
2c14			 
2c14				FORTH_DSP_PTR 1     ; TOS 
2c14 2a 23 f9			ld hl,(cli_data_sp) 
2c17 11 03 00			ld de, 1 * 3 
2c1a ed 52			sbc hl, de 
2c1c				endm 
# End of macro FORTH_DSP_PTR
2c1c cd 9b 23			call hlfromstack1 
2c1f			 
2c1f				FORTH_DSP_PTR 2     ; TOS 
2c1f 2a 23 f9			ld hl,(cli_data_sp) 
2c22 11 06 00			ld de, 2 * 3 
2c25 ed 52			sbc hl, de 
2c27				endm 
# End of macro FORTH_DSP_PTR
2c27 cd a1 23			call hlfromstack2 
2c2a			 
2c2a			 
2c2a			;	FORTH_DSP_VALUEHL 
2c2a			;	push hl    ; u3  
2c2a			; 
2c2a			;	FORTH_DSP_POP 
2c2a			; 
2c2a			;	FORTH_DSP_VALUEHL 
2c2a			;	push hl     ; u2 
2c2a			; 
2c2a			;	FORTH_DSP_POP 
2c2a			; 
2c2a			;	FORTH_DSP_VALUEHL 
2c2a			;	push hl     ; u1 
2c2a			; 
2c2a			;	FORTH_DSP_POP 
2c2a			; 
2c2a			;	pop bc      ; u1 
2c2a			;	pop hl      ; u2 
2c2a			;	pop de      ; u3 
2c2a			; 
2c2a			; 
2c2a			;	push bc 
2c2a			;	push de 
2c2a			;	push hl 
2c2a			; 
2c2a			; 
2c2a			;	pop hl 
2c2a			;	call forth_push_numhl 
2c2a			; 
2c2a			;	pop hl 
2c2a			;	call forth_push_numhl 
2c2a			; 
2c2a			;	pop hl 
2c2a			;	call forth_push_numhl 
2c2a				 
2c2a			 
2c2a			 
2c2a			 
2c2a			 
2c2a			 
2c2a			       NEXTW 
2c2a c3 37 24			jp macro_next 
2c2d				endm 
# End of macro NEXTW
2c2d			 
2c2d			.UWORDS: 
2c2d			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2c2d 50				db WORD_SYS_CORE+60             
2c2e ef 2c			dw .BP            
2c30 07				db 6 + 1 
2c31 .. 00			db "UWORDS",0              
2c38				endm 
# End of macro CWHEAD
2c38			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2c38			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2c38			; | | Following the count are the individual words. 
2c38			; | | 
2c38			; | | e.g. UWORDS 
2c38			; | | BOX DIRLIST 2 
2c38			; | |  
2c38			; | | Can be used to save the words to storage via: 
2c38			; | | UWORDS $01 DO $01 APPEND LOOP 
2c38			if DEBUG_FORTH_WORDS_KEY 
2c38				DMARK "UWR" 
2c38 f5				push af  
2c39 3a 4d 2c			ld a, (.dmark)  
2c3c 32 a0 fd			ld (debug_mark),a  
2c3f 3a 4e 2c			ld a, (.dmark+1)  
2c42 32 a1 fd			ld (debug_mark+1),a  
2c45 3a 4f 2c			ld a, (.dmark+2)  
2c48 32 a2 fd			ld (debug_mark+2),a  
2c4b 18 03			jr .pastdmark  
2c4d ..			.dmark: db "UWR"  
2c50 f1			.pastdmark: pop af  
2c51			endm  
# End of macro DMARK
2c51				CALLMONITOR 
2c51 cd aa fd			call debug_vector  
2c54				endm  
# End of macro CALLMONITOR
2c54			endif 
2c54 21 00 80			ld hl, baseram 
2c57				;ld hl, baseusermem 
2c57 01 00 00			ld bc, 0    ; start a counter 
2c5a			 
2c5a			; skip dict stub 
2c5a			 
2c5a cd 88 25			call forth_tok_next 
2c5d			 
2c5d			 
2c5d			; while we have words to look for 
2c5d			 
2c5d 7e			.douscan:	ld a, (hl)      
2c5e			if DEBUG_FORTH_WORDS 
2c5e				DMARK "UWs" 
2c5e f5				push af  
2c5f 3a 73 2c			ld a, (.dmark)  
2c62 32 a0 fd			ld (debug_mark),a  
2c65 3a 74 2c			ld a, (.dmark+1)  
2c68 32 a1 fd			ld (debug_mark+1),a  
2c6b 3a 75 2c			ld a, (.dmark+2)  
2c6e 32 a2 fd			ld (debug_mark+2),a  
2c71 18 03			jr .pastdmark  
2c73 ..			.dmark: db "UWs"  
2c76 f1			.pastdmark: pop af  
2c77			endm  
# End of macro DMARK
2c77				CALLMONITOR 
2c77 cd aa fd			call debug_vector  
2c7a				endm  
# End of macro CALLMONITOR
2c7a			endif 
2c7a fe 00			cp WORD_SYS_END 
2c7c 28 4d			jr z, .udone 
2c7e fe 01			cp WORD_SYS_UWORD 
2c80 20 44			jr nz, .nuword 
2c82			 
2c82			if DEBUG_FORTH_WORDS 
2c82				DMARK "UWu" 
2c82 f5				push af  
2c83 3a 97 2c			ld a, (.dmark)  
2c86 32 a0 fd			ld (debug_mark),a  
2c89 3a 98 2c			ld a, (.dmark+1)  
2c8c 32 a1 fd			ld (debug_mark+1),a  
2c8f 3a 99 2c			ld a, (.dmark+2)  
2c92 32 a2 fd			ld (debug_mark+2),a  
2c95 18 03			jr .pastdmark  
2c97 ..			.dmark: db "UWu"  
2c9a f1			.pastdmark: pop af  
2c9b			endm  
# End of macro DMARK
2c9b				CALLMONITOR 
2c9b cd aa fd			call debug_vector  
2c9e				endm  
# End of macro CALLMONITOR
2c9e			endif 
2c9e				; we have a uword so push its name to the stack 
2c9e			 
2c9e e5				push hl  ; save so we can move to next dict block 
2c9f			 
2c9f				; skip opcode 
2c9f 23				inc hl  
2ca0				; skip next ptr 
2ca0 23				inc hl  
2ca1 23				inc hl 
2ca2				; skip len 
2ca2 23				inc hl 
2ca3			if DEBUG_FORTH_WORDS 
2ca3				DMARK "UWt" 
2ca3 f5				push af  
2ca4 3a b8 2c			ld a, (.dmark)  
2ca7 32 a0 fd			ld (debug_mark),a  
2caa 3a b9 2c			ld a, (.dmark+1)  
2cad 32 a1 fd			ld (debug_mark+1),a  
2cb0 3a ba 2c			ld a, (.dmark+2)  
2cb3 32 a2 fd			ld (debug_mark+2),a  
2cb6 18 03			jr .pastdmark  
2cb8 ..			.dmark: db "UWt"  
2cbb f1			.pastdmark: pop af  
2cbc			endm  
# End of macro DMARK
2cbc				CALLMONITOR 
2cbc cd aa fd			call debug_vector  
2cbf				endm  
# End of macro CALLMONITOR
2cbf			endif 
2cbf 03				inc bc 
2cc0			 
2cc0 c5				push bc 
2cc1 cd b4 20			call forth_push_str 
2cc4 c1				pop bc 
2cc5			 
2cc5 e1				pop hl 	 
2cc6			 
2cc6 cd 88 25		.nuword:	call forth_tok_next 
2cc9 18 92			jr .douscan  
2ccb			 
2ccb			.udone:		 ; push count of uwords found 
2ccb c5				push bc 
2ccc e1				pop hl 
2ccd			 
2ccd			if DEBUG_FORTH_WORDS 
2ccd				DMARK "UWc" 
2ccd f5				push af  
2cce 3a e2 2c			ld a, (.dmark)  
2cd1 32 a0 fd			ld (debug_mark),a  
2cd4 3a e3 2c			ld a, (.dmark+1)  
2cd7 32 a1 fd			ld (debug_mark+1),a  
2cda 3a e4 2c			ld a, (.dmark+2)  
2cdd 32 a2 fd			ld (debug_mark+2),a  
2ce0 18 03			jr .pastdmark  
2ce2 ..			.dmark: db "UWc"  
2ce5 f1			.pastdmark: pop af  
2ce6			endm  
# End of macro DMARK
2ce6				CALLMONITOR 
2ce6 cd aa fd			call debug_vector  
2ce9				endm  
# End of macro CALLMONITOR
2ce9			endif 
2ce9 cd 46 20			call forth_push_numhl 
2cec			 
2cec			 
2cec			       NEXTW 
2cec c3 37 24			jp macro_next 
2cef				endm 
# End of macro NEXTW
2cef			 
2cef			.BP: 
2cef			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2cef 54				db WORD_SYS_CORE+64             
2cf0 29 2d			dw .MONITOR            
2cf2 03				db 2 + 1 
2cf3 .. 00			db "BP",0              
2cf6				endm 
# End of macro CWHEAD
2cf6			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2cf6			; | | $00 Will enable the break points within specific code paths 
2cf6			; | | $01 Will disable break points 
2cf6			; | |  
2cf6			; | | By default break points are off. Either the above can be used to enable them 
2cf6			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2cf6			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2cf6			; | | can disable break points. Exiting will then continue boot process. 
2cf6				; get byte count 
2cf6				if DEBUG_FORTH_WORDS_KEY 
2cf6					DMARK "BP." 
2cf6 f5				push af  
2cf7 3a 0b 2d			ld a, (.dmark)  
2cfa 32 a0 fd			ld (debug_mark),a  
2cfd 3a 0c 2d			ld a, (.dmark+1)  
2d00 32 a1 fd			ld (debug_mark+1),a  
2d03 3a 0d 2d			ld a, (.dmark+2)  
2d06 32 a2 fd			ld (debug_mark+2),a  
2d09 18 03			jr .pastdmark  
2d0b ..			.dmark: db "BP."  
2d0e f1			.pastdmark: pop af  
2d0f			endm  
# End of macro DMARK
2d0f					CALLMONITOR 
2d0f cd aa fd			call debug_vector  
2d12				endm  
# End of macro CALLMONITOR
2d12				endif 
2d12			 
2d12				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d12 cd 4b 22			call macro_dsp_valuehl 
2d15				endm 
# End of macro FORTH_DSP_VALUEHL
2d15			 
2d15			;		push hl 
2d15			 
2d15				; destroy value TOS 
2d15			 
2d15				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d15 cd 03 23			call macro_forth_dsp_pop 
2d18				endm 
# End of macro FORTH_DSP_POP
2d18			 
2d18			;		pop hl 
2d18			 
2d18 3e 00			ld a,0 
2d1a bd				cp l 
2d1b 28 06			jr z, .bpset 
2d1d			;		ld a, '*' 
2d1d cd 53 19			call bp_off 
2d20				NEXTW 
2d20 c3 37 24			jp macro_next 
2d23				endm 
# End of macro NEXTW
2d23			 
2d23			.bpset:	 
2d23				;	ld (os_view_disable), a 
2d23 cd 47 19			call bp_on 
2d26			 
2d26			 
2d26				NEXTW 
2d26 c3 37 24			jp macro_next 
2d29				endm 
# End of macro NEXTW
2d29			 
2d29			 
2d29			.MONITOR: 
2d29			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2d29 55				db WORD_SYS_CORE+65             
2d2a 5a 2d			dw .MALLOC            
2d2c 08				db 7 + 1 
2d2d .. 00			db "MONITOR",0              
2d35				endm 
# End of macro CWHEAD
2d35			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2d35			; | | At start the current various registers will be displayed with contents. 
2d35			; | | Top right corner will show the most recent debug marker seen. 
2d35			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2d35			; | | and the return stack pointer (RSP). 
2d35			; | | Pressing: 
2d35			; | |    1 - Initial screen 
2d35			; | |    2 - Display a data dump of HL 
2d35			; | |    3 - Display a data dump of DE 
2d35			; | |    4 - Display a data dump of BC 
2d35			; | |    5 - Display a data dump of HL 
2d35			; | |    6 - Display a data dump of DSP 
2d35			; | |    7 - Display a data dump of RSP 
2d35			; | |    8 - Display a data dump of what is at DSP 
2d35			; | |    9 - Display a data dump of what is at RSP 
2d35			; | |    0 - Exit monitor and continue running. This will also enable break points 
2d35			; | |    * - Disable break points 
2d35			; | |    # - Enter traditional monitor mode 
2d35			; | | 
2d35			; | | Monitor Mode 
2d35			; | | ------------ 
2d35			; | | A prompt of '>' will be shown for various commands: 
2d35			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2d35			; | |    C - Continue display a data dump from the last set address 
2d35			; | |    M xxxx - Set start of memory edit at address xx 
2d35			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2d35			; | |    G xxxx - Exec code at specific address 
2d35			; | |    Q - Return to previous 
2d35				if DEBUG_FORTH_WORDS_KEY 
2d35					DMARK "MON" 
2d35 f5				push af  
2d36 3a 4a 2d			ld a, (.dmark)  
2d39 32 a0 fd			ld (debug_mark),a  
2d3c 3a 4b 2d			ld a, (.dmark+1)  
2d3f 32 a1 fd			ld (debug_mark+1),a  
2d42 3a 4c 2d			ld a, (.dmark+2)  
2d45 32 a2 fd			ld (debug_mark+2),a  
2d48 18 03			jr .pastdmark  
2d4a ..			.dmark: db "MON"  
2d4d f1			.pastdmark: pop af  
2d4e			endm  
# End of macro DMARK
2d4e					CALLMONITOR 
2d4e cd aa fd			call debug_vector  
2d51				endm  
# End of macro CALLMONITOR
2d51				endif 
2d51			;		ld a, 0 
2d51			;		ld (os_view_disable), a 
2d51 cd 47 19			call bp_on 
2d54			 
2d54				CALLMONITOR 
2d54 cd aa fd			call debug_vector  
2d57				endm  
# End of macro CALLMONITOR
2d57			 
2d57			;	call monitor 
2d57			 
2d57				NEXTW 
2d57 c3 37 24			jp macro_next 
2d5a				endm 
# End of macro NEXTW
2d5a			 
2d5a			 
2d5a			.MALLOC: 
2d5a			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2d5a 56				db WORD_SYS_CORE+66             
2d5b 83 2d			dw .MALLOC2            
2d5d 06				db 5 + 1 
2d5e .. 00			db "ALLOT",0              
2d64				endm 
# End of macro CWHEAD
2d64			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d64				if DEBUG_FORTH_WORDS_KEY 
2d64					DMARK "ALL" 
2d64 f5				push af  
2d65 3a 79 2d			ld a, (.dmark)  
2d68 32 a0 fd			ld (debug_mark),a  
2d6b 3a 7a 2d			ld a, (.dmark+1)  
2d6e 32 a1 fd			ld (debug_mark+1),a  
2d71 3a 7b 2d			ld a, (.dmark+2)  
2d74 32 a2 fd			ld (debug_mark+2),a  
2d77 18 03			jr .pastdmark  
2d79 ..			.dmark: db "ALL"  
2d7c f1			.pastdmark: pop af  
2d7d			endm  
# End of macro DMARK
2d7d					CALLMONITOR 
2d7d cd aa fd			call debug_vector  
2d80				endm  
# End of macro CALLMONITOR
2d80				endif 
2d80 c3 aa 2d			jp .mallocc 
2d83			.MALLOC2: 
2d83			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2d83 56				db WORD_SYS_CORE+66             
2d84 c1 2d			dw .FREE            
2d86 07				db 6 + 1 
2d87 .. 00			db "MALLOC",0              
2d8e				endm 
# End of macro CWHEAD
2d8e			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d8e				; get byte count 
2d8e				if DEBUG_FORTH_WORDS_KEY 
2d8e					DMARK "MAL" 
2d8e f5				push af  
2d8f 3a a3 2d			ld a, (.dmark)  
2d92 32 a0 fd			ld (debug_mark),a  
2d95 3a a4 2d			ld a, (.dmark+1)  
2d98 32 a1 fd			ld (debug_mark+1),a  
2d9b 3a a5 2d			ld a, (.dmark+2)  
2d9e 32 a2 fd			ld (debug_mark+2),a  
2da1 18 03			jr .pastdmark  
2da3 ..			.dmark: db "MAL"  
2da6 f1			.pastdmark: pop af  
2da7			endm  
# End of macro DMARK
2da7					CALLMONITOR 
2da7 cd aa fd			call debug_vector  
2daa				endm  
# End of macro CALLMONITOR
2daa				endif 
2daa			.mallocc: 
2daa				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2daa cd 4b 22			call macro_dsp_valuehl 
2dad				endm 
# End of macro FORTH_DSP_VALUEHL
2dad			 
2dad			;		push hl 
2dad			 
2dad				; destroy value TOS 
2dad			 
2dad				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2dad cd 03 23			call macro_forth_dsp_pop 
2db0				endm 
# End of macro FORTH_DSP_POP
2db0			 
2db0			;		pop hl 
2db0 cd b9 13			call malloc 
2db3			if DEBUG_FORTH_MALLOC_GUARD 
2db3 f5				push af 
2db4 cd 07 10			call ishlzero 
2db7			;		ld a, l 
2db7			;		add h 
2db7			;		cp 0 
2db7 f1				pop af 
2db8				 
2db8 cc 84 5e			call z,malloc_error 
2dbb			endif 
2dbb			 
2dbb cd 46 20			call forth_push_numhl 
2dbe				NEXTW 
2dbe c3 37 24			jp macro_next 
2dc1				endm 
# End of macro NEXTW
2dc1			 
2dc1			.FREE: 
2dc1			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2dc1 57				db WORD_SYS_CORE+67             
2dc2 f2 2d			dw .LIST            
2dc4 05				db 4 + 1 
2dc5 .. 00			db "FREE",0              
2dca				endm 
# End of macro CWHEAD
2dca			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2dca				if DEBUG_FORTH_WORDS_KEY 
2dca					DMARK "FRE" 
2dca f5				push af  
2dcb 3a df 2d			ld a, (.dmark)  
2dce 32 a0 fd			ld (debug_mark),a  
2dd1 3a e0 2d			ld a, (.dmark+1)  
2dd4 32 a1 fd			ld (debug_mark+1),a  
2dd7 3a e1 2d			ld a, (.dmark+2)  
2dda 32 a2 fd			ld (debug_mark+2),a  
2ddd 18 03			jr .pastdmark  
2ddf ..			.dmark: db "FRE"  
2de2 f1			.pastdmark: pop af  
2de3			endm  
# End of macro DMARK
2de3					CALLMONITOR 
2de3 cd aa fd			call debug_vector  
2de6				endm  
# End of macro CALLMONITOR
2de6				endif 
2de6				; get address 
2de6			 
2de6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2de6 cd 4b 22			call macro_dsp_valuehl 
2de9				endm 
# End of macro FORTH_DSP_VALUEHL
2de9			 
2de9			;		push hl 
2de9			 
2de9				; destroy value TOS 
2de9			 
2de9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2de9 cd 03 23			call macro_forth_dsp_pop 
2dec				endm 
# End of macro FORTH_DSP_POP
2dec			 
2dec			;		pop hl 
2dec			if FORTH_ENABLE_MALLOCFREE 
2dec cd 83 14			call free 
2def			endif 
2def				NEXTW 
2def c3 37 24			jp macro_next 
2df2				endm 
# End of macro NEXTW
2df2			.LIST: 
2df2			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2df2 5c				db WORD_SYS_CORE+72             
2df3 ee 2f			dw .FORGET            
2df5 05				db 4 + 1 
2df6 .. 00			db "LIST",0              
2dfb				endm 
# End of macro CWHEAD
2dfb			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2dfb			; | | The quoted word must be in upper case. 
2dfb			if DEBUG_FORTH_WORDS_KEY 
2dfb				DMARK "LST" 
2dfb f5				push af  
2dfc 3a 10 2e			ld a, (.dmark)  
2dff 32 a0 fd			ld (debug_mark),a  
2e02 3a 11 2e			ld a, (.dmark+1)  
2e05 32 a1 fd			ld (debug_mark+1),a  
2e08 3a 12 2e			ld a, (.dmark+2)  
2e0b 32 a2 fd			ld (debug_mark+2),a  
2e0e 18 03			jr .pastdmark  
2e10 ..			.dmark: db "LST"  
2e13 f1			.pastdmark: pop af  
2e14			endm  
# End of macro DMARK
2e14				CALLMONITOR 
2e14 cd aa fd			call debug_vector  
2e17				endm  
# End of macro CALLMONITOR
2e17			endif 
2e17			 
2e17				FORTH_DSP_VALUEHL 
2e17 cd 4b 22			call macro_dsp_valuehl 
2e1a				endm 
# End of macro FORTH_DSP_VALUEHL
2e1a			 
2e1a e5				push hl 
2e1b				FORTH_DSP_POP 
2e1b cd 03 23			call macro_forth_dsp_pop 
2e1e				endm 
# End of macro FORTH_DSP_POP
2e1e c1				pop bc 
2e1f			 
2e1f			; Start format of scratch string 
2e1f			 
2e1f 21 f6 f0			ld hl, scratch 
2e22			 
2e22 3e 3a			ld a, ':' 
2e24 77				ld (hl),a 
2e25 23				inc hl 
2e26 3e 20			ld a, ' ' 
2e28 77				ld (hl), a 
2e29			 
2e29				; Get ptr to the word we need to look up 
2e29			 
2e29			;		FORTH_DSP_VALUEHL 
2e29				;v5 FORTH_DSP_VALUE 
2e29			; TODO type check 
2e29			;		inc hl    ; Skip type check  
2e29			;		push hl 
2e29			;		ex de, hl    ; put into DE 
2e29			 
2e29			 
2e29 21 00 80			ld hl, baseram 
2e2c				;ld hl, baseusermem 
2e2c			 
2e2c e5			push hl   ; sacreifical push 
2e2d			 
2e2d			.ldouscanm: 
2e2d e1			pop hl 
2e2e			.ldouscan: 
2e2e			if DEBUG_FORTH_WORDS 
2e2e				DMARK "LSs" 
2e2e f5				push af  
2e2f 3a 43 2e			ld a, (.dmark)  
2e32 32 a0 fd			ld (debug_mark),a  
2e35 3a 44 2e			ld a, (.dmark+1)  
2e38 32 a1 fd			ld (debug_mark+1),a  
2e3b 3a 45 2e			ld a, (.dmark+2)  
2e3e 32 a2 fd			ld (debug_mark+2),a  
2e41 18 03			jr .pastdmark  
2e43 ..			.dmark: db "LSs"  
2e46 f1			.pastdmark: pop af  
2e47			endm  
# End of macro DMARK
2e47				CALLMONITOR 
2e47 cd aa fd			call debug_vector  
2e4a				endm  
# End of macro CALLMONITOR
2e4a			endif 
2e4a			; skip dict stub 
2e4a cd 88 25			call forth_tok_next 
2e4d			 
2e4d			 
2e4d			; while we have words to look for 
2e4d			 
2e4d 7e			ld a, (hl)      
2e4e			if DEBUG_FORTH_WORDS 
2e4e				DMARK "LSk" 
2e4e f5				push af  
2e4f 3a 63 2e			ld a, (.dmark)  
2e52 32 a0 fd			ld (debug_mark),a  
2e55 3a 64 2e			ld a, (.dmark+1)  
2e58 32 a1 fd			ld (debug_mark+1),a  
2e5b 3a 65 2e			ld a, (.dmark+2)  
2e5e 32 a2 fd			ld (debug_mark+2),a  
2e61 18 03			jr .pastdmark  
2e63 ..			.dmark: db "LSk"  
2e66 f1			.pastdmark: pop af  
2e67			endm  
# End of macro DMARK
2e67				CALLMONITOR 
2e67 cd aa fd			call debug_vector  
2e6a				endm  
# End of macro CALLMONITOR
2e6a			endif 
2e6a				;cp WORD_SYS_END 
2e6a				;jp z, .lunotfound 
2e6a			 
2e6a					; if we hit non uwords then gone too far 
2e6a fe 01				cp WORD_SYS_UWORD 
2e6c c2 aa 2f				jp nz, .lunotfound 
2e6f			 
2e6f				if DEBUG_FORTH_WORDS 
2e6f					DMARK "LSu" 
2e6f f5				push af  
2e70 3a 84 2e			ld a, (.dmark)  
2e73 32 a0 fd			ld (debug_mark),a  
2e76 3a 85 2e			ld a, (.dmark+1)  
2e79 32 a1 fd			ld (debug_mark+1),a  
2e7c 3a 86 2e			ld a, (.dmark+2)  
2e7f 32 a2 fd			ld (debug_mark+2),a  
2e82 18 03			jr .pastdmark  
2e84 ..			.dmark: db "LSu"  
2e87 f1			.pastdmark: pop af  
2e88			endm  
# End of macro DMARK
2e88					CALLMONITOR 
2e88 cd aa fd			call debug_vector  
2e8b				endm  
# End of macro CALLMONITOR
2e8b				endif 
2e8b			 
2e8b					; found a uword but is it the one we want... 
2e8b			 
2e8b c5					push bc     ; uword to find is on bc 
2e8c d1					pop de 
2e8d			 
2e8d e5					push hl  ; to save the ptr 
2e8e			 
2e8e					; skip opcode 
2e8e 23					inc hl  
2e8f					; skip next ptr 
2e8f 23					inc hl  
2e90 23					inc hl 
2e91					; skip len 
2e91 23					inc hl 
2e92			 
2e92				if DEBUG_FORTH_WORDS 
2e92					DMARK "LSc" 
2e92 f5				push af  
2e93 3a a7 2e			ld a, (.dmark)  
2e96 32 a0 fd			ld (debug_mark),a  
2e99 3a a8 2e			ld a, (.dmark+1)  
2e9c 32 a1 fd			ld (debug_mark+1),a  
2e9f 3a a9 2e			ld a, (.dmark+2)  
2ea2 32 a2 fd			ld (debug_mark+2),a  
2ea5 18 03			jr .pastdmark  
2ea7 ..			.dmark: db "LSc"  
2eaa f1			.pastdmark: pop af  
2eab			endm  
# End of macro DMARK
2eab					CALLMONITOR 
2eab cd aa fd			call debug_vector  
2eae				endm  
# End of macro CALLMONITOR
2eae				endif 
2eae			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2eae			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2eae			; Nope that has gone the other way. It needs to be exact not on first zero 
2eae			;		call strcmp 
2eae c5					push bc 
2eaf cd 89 13				call StrictStrCmp 
2eb2 c1					pop bc 
2eb3 c2 2d 2e				jp nz, .ldouscanm 
2eb6				 
2eb6			 
2eb6			 
2eb6					; we have a uword so push its name to the stack 
2eb6			 
2eb6			;	   	push hl  ; save so we can move to next dict block 
2eb6 e1			pop hl 
2eb7			 
2eb7				if DEBUG_FORTH_WORDS 
2eb7					DMARK "LSm" 
2eb7 f5				push af  
2eb8 3a cc 2e			ld a, (.dmark)  
2ebb 32 a0 fd			ld (debug_mark),a  
2ebe 3a cd 2e			ld a, (.dmark+1)  
2ec1 32 a1 fd			ld (debug_mark+1),a  
2ec4 3a ce 2e			ld a, (.dmark+2)  
2ec7 32 a2 fd			ld (debug_mark+2),a  
2eca 18 03			jr .pastdmark  
2ecc ..			.dmark: db "LSm"  
2ecf f1			.pastdmark: pop af  
2ed0			endm  
# End of macro DMARK
2ed0					CALLMONITOR 
2ed0 cd aa fd			call debug_vector  
2ed3				endm  
# End of macro CALLMONITOR
2ed3				endif 
2ed3			 
2ed3					; skip opcode 
2ed3 23					inc hl  
2ed4					; skip next ptr 
2ed4 23					inc hl  
2ed5 23					inc hl 
2ed6					; skip len 
2ed6 7e					ld a, (hl)   ; save length to add 
2ed7				if DEBUG_FORTH_WORDS 
2ed7					DMARK "LS2" 
2ed7 f5				push af  
2ed8 3a ec 2e			ld a, (.dmark)  
2edb 32 a0 fd			ld (debug_mark),a  
2ede 3a ed 2e			ld a, (.dmark+1)  
2ee1 32 a1 fd			ld (debug_mark+1),a  
2ee4 3a ee 2e			ld a, (.dmark+2)  
2ee7 32 a2 fd			ld (debug_mark+2),a  
2eea 18 03			jr .pastdmark  
2eec ..			.dmark: db "LS2"  
2eef f1			.pastdmark: pop af  
2ef0			endm  
# End of macro DMARK
2ef0					CALLMONITOR 
2ef0 cd aa fd			call debug_vector  
2ef3				endm  
# End of macro CALLMONITOR
2ef3				endif 
2ef3			 
2ef3					; save this location 
2ef3				 
2ef3 e5					push hl 
2ef4			 
2ef4 23					inc hl 
2ef5 11 f8 f0				ld de, scratch+2 
2ef8 4f					ld c, a 
2ef9 06 00				ld b, 0 
2efb			 
2efb				if DEBUG_FORTH_WORDS 
2efb					DMARK "LSn" 
2efb f5				push af  
2efc 3a 10 2f			ld a, (.dmark)  
2eff 32 a0 fd			ld (debug_mark),a  
2f02 3a 11 2f			ld a, (.dmark+1)  
2f05 32 a1 fd			ld (debug_mark+1),a  
2f08 3a 12 2f			ld a, (.dmark+2)  
2f0b 32 a2 fd			ld (debug_mark+2),a  
2f0e 18 03			jr .pastdmark  
2f10 ..			.dmark: db "LSn"  
2f13 f1			.pastdmark: pop af  
2f14			endm  
# End of macro DMARK
2f14					CALLMONITOR 
2f14 cd aa fd			call debug_vector  
2f17				endm  
# End of macro CALLMONITOR
2f17				endif 
2f17			 
2f17					; copy uword name to scratch 
2f17			 
2f17			;		ldir 
2f17			.licplw:	; copy uword name to scratch converting to lower case as we go 
2f17 ed a0				ldi 
2f19 1b					dec de 
2f1a 1a					ld a, (de) 
2f1b cd 5c 12				call to_lower 
2f1e 12					ld (de),a 
2f1f 13					inc de 
2f20 3e 00				ld a, 0 
2f22 b9					cp c 
2f23 20 f2				jr nz, .licplw 
2f25			 
2f25			 
2f25			 
2f25 1b					dec de 
2f26 3e 20				ld a, ' '    ; change null to space 
2f28 12					ld (de), a 
2f29			 
2f29 13					inc de 
2f2a			 
2f2a d5					push de 
2f2b c1					pop bc     ; move scratch pointer to end of word name and save it 
2f2c			 
2f2c e1					pop hl 
2f2d 7e					ld a, (hl) 
2f2e					;inc hl 
2f2e					; skip word string 
2f2e cd de 0f				call addatohl 
2f31			 
2f31 23					inc hl 
2f32			 
2f32				if DEBUG_FORTH_WORDS 
2f32					DMARK "LS3" 
2f32 f5				push af  
2f33 3a 47 2f			ld a, (.dmark)  
2f36 32 a0 fd			ld (debug_mark),a  
2f39 3a 48 2f			ld a, (.dmark+1)  
2f3c 32 a1 fd			ld (debug_mark+1),a  
2f3f 3a 49 2f			ld a, (.dmark+2)  
2f42 32 a2 fd			ld (debug_mark+2),a  
2f45 18 03			jr .pastdmark  
2f47 ..			.dmark: db "LS3"  
2f4a f1			.pastdmark: pop af  
2f4b			endm  
# End of macro DMARK
2f4b					CALLMONITOR 
2f4b cd aa fd			call debug_vector  
2f4e				endm  
# End of macro CALLMONITOR
2f4e				endif 
2f4e					; should now be at the start of the machine code to setup the eval of the uword 
2f4e					; now locate the ptr to the string defintion 
2f4e			 
2f4e					; skip ld hl, 
2f4e					; then load the ptr 
2f4e			; TODO use get from hl ptr 
2f4e 23					inc hl 
2f4f 5e					ld e, (hl) 
2f50 23					inc hl 
2f51 56					ld d, (hl) 
2f52 eb					ex de, hl 
2f53			 
2f53			 
2f53				if DEBUG_FORTH_WORDS 
2f53					DMARK "LSt" 
2f53 f5				push af  
2f54 3a 68 2f			ld a, (.dmark)  
2f57 32 a0 fd			ld (debug_mark),a  
2f5a 3a 69 2f			ld a, (.dmark+1)  
2f5d 32 a1 fd			ld (debug_mark+1),a  
2f60 3a 6a 2f			ld a, (.dmark+2)  
2f63 32 a2 fd			ld (debug_mark+2),a  
2f66 18 03			jr .pastdmark  
2f68 ..			.dmark: db "LSt"  
2f6b f1			.pastdmark: pop af  
2f6c			endm  
# End of macro DMARK
2f6c					CALLMONITOR 
2f6c cd aa fd			call debug_vector  
2f6f				endm  
# End of macro CALLMONITOR
2f6f				endif 
2f6f			 
2f6f			; cant push right now due to tokenised strings  
2f6f			 
2f6f			; get the destination of where to copy this definition to. 
2f6f			 
2f6f c5					push bc 
2f70 d1					pop de 
2f71			 
2f71 7e			.listl:         ld a,(hl) 
2f72 fe 00				cp 0 
2f74 28 09				jr z, .lreplsp     ; replace zero with space 
2f76					;cp FORTH_END_BUFFER 
2f76 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2f78 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2f7a				 
2f7a					; just copy this char as is then 
2f7a			 
2f7a 12					ld (de), a 
2f7b			 
2f7b 23			.listnxt:	inc hl 
2f7c 13					inc de 
2f7d 18 f2				jr .listl 
2f7f			 
2f7f 3e 20		.lreplsp:	ld a,' ' 
2f81 12					ld (de), a 
2f82 18 f7				jr .listnxt 
2f84			 
2f84			; close up uword def 
2f84			 
2f84			.listdone: 
2f84 12					ld (de), a 
2f85 13					inc de 
2f86 3e 00				ld a, 0 
2f88 12					ld (de), a 
2f89			 
2f89			; now have def so clean up and push to stack 
2f89			 
2f89 21 f6 f0				ld hl, scratch 
2f8c				if DEBUG_FORTH_WORDS 
2f8c					DMARK "Ltp" 
2f8c f5				push af  
2f8d 3a a1 2f			ld a, (.dmark)  
2f90 32 a0 fd			ld (debug_mark),a  
2f93 3a a2 2f			ld a, (.dmark+1)  
2f96 32 a1 fd			ld (debug_mark+1),a  
2f99 3a a3 2f			ld a, (.dmark+2)  
2f9c 32 a2 fd			ld (debug_mark+2),a  
2f9f 18 03			jr .pastdmark  
2fa1 ..			.dmark: db "Ltp"  
2fa4 f1			.pastdmark: pop af  
2fa5			endm  
# End of macro DMARK
2fa5					CALLMONITOR 
2fa5 cd aa fd			call debug_vector  
2fa8				endm  
# End of macro CALLMONITOR
2fa8				endif 
2fa8			 
2fa8 18 1f			jr .listpush 
2faa			 
2faa			;.lnuword:	pop hl 
2faa			;		call forth_tok_next 
2faa			;		jp .ldouscan  
2faa			 
2faa			.lunotfound:		  
2faa			 
2faa				if DEBUG_FORTH_WORDS 
2faa					DMARK "LSn" 
2faa f5				push af  
2fab 3a bf 2f			ld a, (.dmark)  
2fae 32 a0 fd			ld (debug_mark),a  
2fb1 3a c0 2f			ld a, (.dmark+1)  
2fb4 32 a1 fd			ld (debug_mark+1),a  
2fb7 3a c1 2f			ld a, (.dmark+2)  
2fba 32 a2 fd			ld (debug_mark+2),a  
2fbd 18 03			jr .pastdmark  
2fbf ..			.dmark: db "LSn"  
2fc2 f1			.pastdmark: pop af  
2fc3			endm  
# End of macro DMARK
2fc3					CALLMONITOR 
2fc3 cd aa fd			call debug_vector  
2fc6				endm  
# End of macro CALLMONITOR
2fc6				endif 
2fc6			 
2fc6					 
2fc6			;		FORTH_DSP_POP 
2fc6			;		ld hl, .luno 
2fc6			 
2fc6					NEXTW			 
2fc6 c3 37 24			jp macro_next 
2fc9				endm 
# End of macro NEXTW
2fc9			 
2fc9			.listpush: 
2fc9				if DEBUG_FORTH_WORDS 
2fc9					DMARK "LS>" 
2fc9 f5				push af  
2fca 3a de 2f			ld a, (.dmark)  
2fcd 32 a0 fd			ld (debug_mark),a  
2fd0 3a df 2f			ld a, (.dmark+1)  
2fd3 32 a1 fd			ld (debug_mark+1),a  
2fd6 3a e0 2f			ld a, (.dmark+2)  
2fd9 32 a2 fd			ld (debug_mark+2),a  
2fdc 18 03			jr .pastdmark  
2fde ..			.dmark: db "LS>"  
2fe1 f1			.pastdmark: pop af  
2fe2			endm  
# End of macro DMARK
2fe2					CALLMONITOR 
2fe2 cd aa fd			call debug_vector  
2fe5				endm  
# End of macro CALLMONITOR
2fe5				endif 
2fe5 cd b4 20				call forth_push_str 
2fe8			 
2fe8			 
2fe8			 
2fe8					NEXTW 
2fe8 c3 37 24			jp macro_next 
2feb				endm 
# End of macro NEXTW
2feb			 
2feb			;.luno:    db "Word not found",0 
2feb			 
2feb			 
2feb			 
2feb			 
2feb			 
2feb			;		push hl   ; save pointer to start of uword def string 
2feb			; 
2feb			;; look for FORTH_EOL_LINE 
2feb			;		ld a, FORTH_END_BUFFER 
2feb			;		call strlent 
2feb			; 
2feb			;		inc hl		 ; space for coln def 
2feb			;		inc hl 
2feb			;		inc hl          ; space for terms 
2feb			;		inc hl 
2feb			; 
2feb			;		ld a, 20   ; TODO get actual length 
2feb			;		call addatohl    ; include a random amount of room for the uword name 
2feb			; 
2feb			;		 
2feb			;	if DEBUG_FORTH_WORDS 
2feb			;		DMARK "Lt1" 
2feb			;		CALLMONITOR 
2feb			;	endif 
2feb			;		 
2feb			; 
2feb			;; malloc space for the string because we cant change it 
2feb			; 
2feb			;		call malloc 
2feb			;	if DEBUG_FORTH_MALLOC_GUARD 
2feb			;		push af 
2feb			;		call ishlzero 
2feb			;		pop af 
2feb			;		 
2feb			;		call z,malloc_error 
2feb			;	endif 
2feb			; 
2feb			;	if DEBUG_FORTH_WORDS 
2feb			;		DMARK "Lt2" 
2feb			;		CALLMONITOR 
2feb			;	endif 
2feb			;		pop de 
2feb			;		push hl    ; push the malloc to release later 
2feb			;		push hl   ;  push back a copy for the later stack push 
2feb			;		 
2feb			;; copy the string swapping out the zero terms for spaces 
2feb			; 
2feb			;		; de has our source 
2feb			;		; hl has our dest 
2feb			; 
2feb			;; add the coln def 
2feb			; 
2feb			;		ld a, ':' 
2feb			;		ld (hl), a 
2feb			;		inc hl 
2feb			;		ld a, ' ' 
2feb			;		ld (hl), a 
2feb			;		inc hl 
2feb			; 
2feb			;; add the uname word 
2feb			;		push de   ; save our string for now 
2feb			;		ex de, hl 
2feb			; 
2feb			;		FORTH_DSP_VALUE 
2feb			;		;v5 FORTH_DSP_VALUE 
2feb			; 
2feb			;		inc hl   ; skip type but we know by now this is OK 
2feb			; 
2feb			;.luword:	ld a,(hl) 
2feb			;		cp 0 
2feb			;		jr z, .luword2 
2feb			;		ld (de), a 
2feb			;		inc de 
2feb			;		inc hl 
2feb			;		jr .luword 
2feb			; 
2feb			;.luword2:	ld a, ' ' 
2feb			;		ld (de), a 
2feb			;;		inc hl 
2feb			;;		inc de 
2feb			;;		ld (de), a 
2feb			;;		inc hl 
2feb			;		inc de 
2feb			; 
2feb			;		ex de, hl 
2feb			;		pop de 
2feb			;		 
2feb			;		 
2feb			; 
2feb			;; detoken that string and copy it 
2feb			; 
2feb			;	if DEBUG_FORTH_WORDS 
2feb			;		DMARK "Lt2" 
2feb			;		CALLMONITOR 
2feb			;	endif 
2feb			;.ldetok:	ld a, (de) 
2feb			;		cp FORTH_END_BUFFER 
2feb			;		jr z, .ldetokend 
2feb			;		; swap out any zero term for space 
2feb			;		cp 0 
2feb			;		jr nz, .ldetoknext 
2feb			;		ld a, ' ' 
2feb			; 
2feb			;	if DEBUG_FORTH_WORDS 
2feb			;		DMARK "LtS" 
2feb			;		CALLMONITOR 
2feb			;	endif 
2feb			;.ldetoknext:	ld (hl), a 
2feb			;		inc de 
2feb			;		inc hl 
2feb			;		jr .ldetok 
2feb			; 
2feb			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2feb			;		ld (hl), a  
2feb			; 
2feb			;; free that temp malloc 
2feb			; 
2feb			;		pop hl    
2feb			; 
2feb			;	if DEBUG_FORTH_WORDS 
2feb			;		DMARK "Lt4" 
2feb			;		CALLMONITOR 
2feb			;	endif 
2feb			;		call forth_apushstrhl 
2feb			; 
2feb			;		; get rid of temp malloc area 
2feb			; 
2feb			;		pop hl 
2feb			;		call free 
2feb			; 
2feb			;		jr .ludone 
2feb			; 
2feb			;.lnuword:	pop hl 
2feb			;		call forth_tok_next 
2feb			;		jp .ldouscan  
2feb			; 
2feb			;.ludone:		 pop hl 
2feb			; 
2feb					NEXTW 
2feb c3 37 24			jp macro_next 
2fee				endm 
# End of macro NEXTW
2fee			 
2fee			.FORGET: 
2fee				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2fee 5d				db WORD_SYS_CORE+73             
2fef 67 30			dw .NOP            
2ff1 07				db 6 + 1 
2ff2 .. 00			db "FORGET",0              
2ff9				endm 
# End of macro CWHEAD
2ff9			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2ff9			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2ff9			; | |  
2ff9			; | | e.g. "MORE" forget 
2ff9					if DEBUG_FORTH_WORDS_KEY 
2ff9						DMARK "FRG" 
2ff9 f5				push af  
2ffa 3a 0e 30			ld a, (.dmark)  
2ffd 32 a0 fd			ld (debug_mark),a  
3000 3a 0f 30			ld a, (.dmark+1)  
3003 32 a1 fd			ld (debug_mark+1),a  
3006 3a 10 30			ld a, (.dmark+2)  
3009 32 a2 fd			ld (debug_mark+2),a  
300c 18 03			jr .pastdmark  
300e ..			.dmark: db "FRG"  
3011 f1			.pastdmark: pop af  
3012			endm  
# End of macro DMARK
3012						CALLMONITOR 
3012 cd aa fd			call debug_vector  
3015				endm  
# End of macro CALLMONITOR
3015					endif 
3015			 
3015				; find uword 
3015			        ; update start of word with "_" 
3015				; replace uword with deleted flag 
3015			 
3015			 
3015			;	if DEBUG_FORTH_WORDS 
3015			;		DMARK "FOG" 
3015			;		CALLMONITOR 
3015			;	endif 
3015			 
3015			 
3015					; Get ptr to the word we need to look up 
3015			 
3015					FORTH_DSP_VALUEHL 
3015 cd 4b 22			call macro_dsp_valuehl 
3018				endm 
# End of macro FORTH_DSP_VALUEHL
3018					;v5 FORTH_DSP_VALUE 
3018				; TODO type check 
3018			;		inc hl    ; Skip type check  
3018 e5					push hl 
3019 c1					pop bc 
301a			;		ex de, hl    ; put into DE 
301a			 
301a			 
301a 21 00 80				ld hl, baseram 
301d					;ld hl, baseusermem 
301d			 
301d				; skip dict stub 
301d			;	call forth_tok_next 
301d e5			push hl   ; sacreifical push 
301e			 
301e			.fldouscanm: 
301e e1				pop hl 
301f			.fldouscan: 
301f			;	if DEBUG_FORTH_WORDS 
301f			;		DMARK "LSs" 
301f			;		CALLMONITOR 
301f			;	endif 
301f				; skip dict stub 
301f cd 88 25				call forth_tok_next 
3022			 
3022			 
3022			; while we have words to look for 
3022			 
3022 7e				ld a, (hl)      
3023			;	if DEBUG_FORTH_WORDS 
3023			;		DMARK "LSk" 
3023			;		CALLMONITOR 
3023			;	endif 
3023 fe 00				cp WORD_SYS_END 
3025 ca 61 30				jp z, .flunotfound 
3028 fe 01				cp WORD_SYS_UWORD 
302a c2 1f 30				jp nz, .fldouscan 
302d			 
302d			;	if DEBUG_FORTH_WORDS 
302d			;		DMARK "LSu" 
302d			;		CALLMONITOR 
302d			;	endif 
302d			 
302d					; found a uword but is it the one we want... 
302d			 
302d c5					push bc     ; uword to find is on bc 
302e d1					pop de 
302f			 
302f e5					push hl  ; to save the ptr 
3030			 
3030					; skip opcode 
3030 23					inc hl  
3031					; skip next ptr 
3031 23					inc hl  
3032 23					inc hl 
3033					; skip len 
3033 23					inc hl 
3034			 
3034			;	if DEBUG_FORTH_WORDS 
3034			;		DMARK "LSc" 
3034			;		CALLMONITOR 
3034			;	endif 
3034 cd 7c 13				call strcmp 
3037 c2 1e 30				jp nz, .fldouscanm 
303a			; 
303a			; 
303a			;; while we have words to look for 
303a			; 
303a			;.fdouscan:	ld a, (hl)      
303a			;	if DEBUG_FORTH_WORDS 
303a			;		DMARK "LSs" 
303a			;		CALLMONITOR 
303a			;	endif 
303a			;		cp WORD_SYS_END 
303a			;		jp z, .fudone 
303a			;		cp WORD_SYS_UWORD 
303a			;		jp nz, .fnuword 
303a			; 
303a			;	if DEBUG_FORTH_WORDS 
303a			;		DMARK "FGu" 
303a			;		CALLMONITOR 
303a			;	endif 
303a			; 
303a			;		; found a uword but is it the one we want... 
303a			; 
303a			; 
303a			;	        pop de   ; get back the dsp name 
303a			;		push de 
303a			; 
303a			;		push hl  ; to save the ptr 
303a			; 
303a			;		; skip opcode 
303a			;		inc hl  
303a			;		; skip next ptr 
303a			;		inc hl  
303a			;		inc hl 
303a			;		; skip len 
303a			;		inc hl 
303a			; 
303a			;	if DEBUG_FORTH_WORDS 
303a			;		DMARK "FGc" 
303a			;		CALLMONITOR 
303a			;	endif 
303a			;		call strcmp 
303a			;		jp nz, .fnuword 
303a			 
303a			 
303a e1			pop hl 
303b			 
303b				 
303b				if DEBUG_FORTH_WORDS 
303b					DMARK "FGm" 
303b f5				push af  
303c 3a 50 30			ld a, (.dmark)  
303f 32 a0 fd			ld (debug_mark),a  
3042 3a 51 30			ld a, (.dmark+1)  
3045 32 a1 fd			ld (debug_mark+1),a  
3048 3a 52 30			ld a, (.dmark+2)  
304b 32 a2 fd			ld (debug_mark+2),a  
304e 18 03			jr .pastdmark  
3050 ..			.dmark: db "FGm"  
3053 f1			.pastdmark: pop af  
3054			endm  
# End of macro DMARK
3054					CALLMONITOR 
3054 cd aa fd			call debug_vector  
3057				endm  
# End of macro CALLMONITOR
3057				endif 
3057			 
3057			 
3057			 
3057					; we have a uword so push its name to the stack 
3057			 
3057			;	   	push hl  ; save so we can move to next dict block 
3057			;pop hl 
3057			 
3057					; update opcode to deleted 
3057 3e 03				ld a, WORD_SYS_DELETED 
3059 77					ld (hl), a 
305a			 
305a 23					inc hl  
305b					; skip next ptr 
305b 23					inc hl  
305c 23					inc hl 
305d					; skip len 
305d 23					inc hl 
305e			 
305e					; TODO change parser to skip deleted words but for now mark it out 
305e 3e 5f				ld a, "_" 
3060 77					ld  (hl),a 
3061			 
3061			;		jr .fudone 
3061			; 
3061			;.fnuword:	pop hl 
3061			;		call forth_tok_next 
3061			;		jp .fdouscan  
3061			 
3061			.flunotfound:		  
3061			 
3061			 
3061					 
3061					FORTH_DSP_POP 
3061 cd 03 23			call macro_forth_dsp_pop 
3064				endm 
# End of macro FORTH_DSP_POP
3064			;		ld hl, .luno 
3064			;.fudone:		 pop hl 
3064					NEXTW 
3064 c3 37 24			jp macro_next 
3067				endm 
# End of macro NEXTW
3067			.NOP: 
3067				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
3067 61				db WORD_SYS_CORE+77             
3068 8e 30			dw .COMO            
306a 04				db 3 + 1 
306b .. 00			db "NOP",0              
306f				endm 
# End of macro CWHEAD
306f			; | NOP (  --  ) Do nothing | DONE 
306f					if DEBUG_FORTH_WORDS_KEY 
306f						DMARK "NOP" 
306f f5				push af  
3070 3a 84 30			ld a, (.dmark)  
3073 32 a0 fd			ld (debug_mark),a  
3076 3a 85 30			ld a, (.dmark+1)  
3079 32 a1 fd			ld (debug_mark+1),a  
307c 3a 86 30			ld a, (.dmark+2)  
307f 32 a2 fd			ld (debug_mark+2),a  
3082 18 03			jr .pastdmark  
3084 ..			.dmark: db "NOP"  
3087 f1			.pastdmark: pop af  
3088			endm  
# End of macro DMARK
3088						CALLMONITOR 
3088 cd aa fd			call debug_vector  
308b				endm  
# End of macro CALLMONITOR
308b					endif 
308b				       NEXTW 
308b c3 37 24			jp macro_next 
308e				endm 
# End of macro NEXTW
308e			.COMO: 
308e				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
308e 6e				db WORD_SYS_CORE+90             
308f e0 30			dw .COMC            
3091 02				db 1 + 1 
3092 .. 00			db "(",0              
3094				endm 
# End of macro CWHEAD
3094			; | ( ( -- )  Start of comment | DONE 
3094			 
3094			 
3094 2a f7 f3				ld hl, ( os_tok_ptr) 
3097 11 db 30			ld de, .closepar 
309a					 
309a					if DEBUG_FORTH_WORDS 
309a						DMARK ").." 
309a f5				push af  
309b 3a af 30			ld a, (.dmark)  
309e 32 a0 fd			ld (debug_mark),a  
30a1 3a b0 30			ld a, (.dmark+1)  
30a4 32 a1 fd			ld (debug_mark+1),a  
30a7 3a b1 30			ld a, (.dmark+2)  
30aa 32 a2 fd			ld (debug_mark+2),a  
30ad 18 03			jr .pastdmark  
30af ..			.dmark: db ").."  
30b2 f1			.pastdmark: pop af  
30b3			endm  
# End of macro DMARK
30b3						CALLMONITOR 
30b3 cd aa fd			call debug_vector  
30b6				endm  
# End of macro CALLMONITOR
30b6					endif 
30b6 cd 52 25			call findnexttok  
30b9			 
30b9					if DEBUG_FORTH_WORDS 
30b9						DMARK "IF5" 
30b9 f5				push af  
30ba 3a ce 30			ld a, (.dmark)  
30bd 32 a0 fd			ld (debug_mark),a  
30c0 3a cf 30			ld a, (.dmark+1)  
30c3 32 a1 fd			ld (debug_mark+1),a  
30c6 3a d0 30			ld a, (.dmark+2)  
30c9 32 a2 fd			ld (debug_mark+2),a  
30cc 18 03			jr .pastdmark  
30ce ..			.dmark: db "IF5"  
30d1 f1			.pastdmark: pop af  
30d2			endm  
# End of macro DMARK
30d2						CALLMONITOR 
30d2 cd aa fd			call debug_vector  
30d5				endm  
# End of macro CALLMONITOR
30d5					endif 
30d5				; replace below with ) exec using tok_ptr 
30d5 22 f7 f3			ld (os_tok_ptr), hl 
30d8 c3 c8 24			jp exec1 
30db			 
30db .. 00			.closepar:   db ")",0 
30dd			 
30dd				       NEXTW 
30dd c3 37 24			jp macro_next 
30e0				endm 
# End of macro NEXTW
30e0			.COMC: 
30e0				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
30e0 6f				db WORD_SYS_CORE+91             
30e1 e9 30			dw .SCRATCH            
30e3 02				db 1 + 1 
30e4 .. 00			db ")",0              
30e6				endm 
# End of macro CWHEAD
30e6			; | ) ( -- )  End of comment |  DONE  
30e6				       NEXTW 
30e6 c3 37 24			jp macro_next 
30e9				endm 
# End of macro NEXTW
30e9			 
30e9			.SCRATCH: 
30e9				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
30e9 6f				db WORD_SYS_CORE+91             
30ea 24 31			dw .INC            
30ec 08				db 7 + 1 
30ed .. 00			db "SCRATCH",0              
30f5				endm 
# End of macro CWHEAD
30f5			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
30f5			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
30f5			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
30f5			; | |  
30f5			; | | e.g.    : score $00 scratch ; 
30f5			; | |  
30f5			; | | $00 score ! 
30f5			; | | $01 score +! 
30f5			; | |  
30f5			; | | e.g.   : varword $0a scratch ;  
30f5			; | | 
30f5			; | | $8000 varword ! 
30f5					if DEBUG_FORTH_WORDS_KEY 
30f5						DMARK "SCR" 
30f5 f5				push af  
30f6 3a 0a 31			ld a, (.dmark)  
30f9 32 a0 fd			ld (debug_mark),a  
30fc 3a 0b 31			ld a, (.dmark+1)  
30ff 32 a1 fd			ld (debug_mark+1),a  
3102 3a 0c 31			ld a, (.dmark+2)  
3105 32 a2 fd			ld (debug_mark+2),a  
3108 18 03			jr .pastdmark  
310a ..			.dmark: db "SCR"  
310d f1			.pastdmark: pop af  
310e			endm  
# End of macro DMARK
310e						CALLMONITOR 
310e cd aa fd			call debug_vector  
3111				endm  
# End of macro CALLMONITOR
3111					endif 
3111			 
3111					FORTH_DSP_VALUEHL 
3111 cd 4b 22			call macro_dsp_valuehl 
3114				endm 
# End of macro FORTH_DSP_VALUEHL
3114				 
3114					FORTH_DSP_POP 
3114 cd 03 23			call macro_forth_dsp_pop 
3117				endm 
# End of macro FORTH_DSP_POP
3117			 
3117 7d					ld a, l 
3118 21 1b f6				ld hl, os_var_array 
311b cd de 0f				call addatohl 
311e			 
311e cd 46 20				call forth_push_numhl 
3121			 
3121				       NEXTW 
3121 c3 37 24			jp macro_next 
3124				endm 
# End of macro NEXTW
3124			 
3124			.INC: 
3124				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3124 6f				db WORD_SYS_CORE+91             
3125 7a 31			dw .DEC            
3127 03				db 2 + 1 
3128 .. 00			db "+!",0              
312b				endm 
# End of macro CWHEAD
312b			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
312b					if DEBUG_FORTH_WORDS_KEY 
312b						DMARK "+s_" 
312b f5				push af  
312c 3a 40 31			ld a, (.dmark)  
312f 32 a0 fd			ld (debug_mark),a  
3132 3a 41 31			ld a, (.dmark+1)  
3135 32 a1 fd			ld (debug_mark+1),a  
3138 3a 42 31			ld a, (.dmark+2)  
313b 32 a2 fd			ld (debug_mark+2),a  
313e 18 03			jr .pastdmark  
3140 ..			.dmark: db "+s_"  
3143 f1			.pastdmark: pop af  
3144			endm  
# End of macro DMARK
3144						CALLMONITOR 
3144 cd aa fd			call debug_vector  
3147				endm  
# End of macro CALLMONITOR
3147					endif 
3147			 
3147					FORTH_DSP_VALUEHL 
3147 cd 4b 22			call macro_dsp_valuehl 
314a				endm 
# End of macro FORTH_DSP_VALUEHL
314a			 
314a e5					push hl   ; save address 
314b			 
314b					FORTH_DSP_POP 
314b cd 03 23			call macro_forth_dsp_pop 
314e				endm 
# End of macro FORTH_DSP_POP
314e			 
314e					FORTH_DSP_VALUEHL 
314e cd 4b 22			call macro_dsp_valuehl 
3151				endm 
# End of macro FORTH_DSP_VALUEHL
3151			 
3151 e5					push hl 
3152					FORTH_DSP_POP 
3152 cd 03 23			call macro_forth_dsp_pop 
3155				endm 
# End of macro FORTH_DSP_POP
3155 e1					pop hl 
3156			 
3156					; hl contains value to add to byte at a 
3156				 
3156 eb					ex de, hl 
3157			 
3157 e1					pop hl 
3158			 
3158					if DEBUG_FORTH_WORDS 
3158						DMARK "INC" 
3158 f5				push af  
3159 3a 6d 31			ld a, (.dmark)  
315c 32 a0 fd			ld (debug_mark),a  
315f 3a 6e 31			ld a, (.dmark+1)  
3162 32 a1 fd			ld (debug_mark+1),a  
3165 3a 6f 31			ld a, (.dmark+2)  
3168 32 a2 fd			ld (debug_mark+2),a  
316b 18 03			jr .pastdmark  
316d ..			.dmark: db "INC"  
3170 f1			.pastdmark: pop af  
3171			endm  
# End of macro DMARK
3171						CALLMONITOR 
3171 cd aa fd			call debug_vector  
3174				endm  
# End of macro CALLMONITOR
3174					endif 
3174			 
3174 7e					ld a,(hl) 
3175 83					add e 
3176 77					ld (hl),a 
3177			 
3177			 
3177			 
3177				       NEXTW 
3177 c3 37 24			jp macro_next 
317a				endm 
# End of macro NEXTW
317a			 
317a			.DEC: 
317a				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
317a 6f				db WORD_SYS_CORE+91             
317b ce 31			dw .INC2            
317d 03				db 2 + 1 
317e .. 00			db "-!",0              
3181				endm 
# End of macro CWHEAD
3181			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
3181					if DEBUG_FORTH_WORDS_KEY 
3181						DMARK "-s_" 
3181 f5				push af  
3182 3a 96 31			ld a, (.dmark)  
3185 32 a0 fd			ld (debug_mark),a  
3188 3a 97 31			ld a, (.dmark+1)  
318b 32 a1 fd			ld (debug_mark+1),a  
318e 3a 98 31			ld a, (.dmark+2)  
3191 32 a2 fd			ld (debug_mark+2),a  
3194 18 03			jr .pastdmark  
3196 ..			.dmark: db "-s_"  
3199 f1			.pastdmark: pop af  
319a			endm  
# End of macro DMARK
319a						CALLMONITOR 
319a cd aa fd			call debug_vector  
319d				endm  
# End of macro CALLMONITOR
319d					endif 
319d			 
319d					FORTH_DSP_VALUEHL 
319d cd 4b 22			call macro_dsp_valuehl 
31a0				endm 
# End of macro FORTH_DSP_VALUEHL
31a0			 
31a0 e5					push hl   ; save address 
31a1			 
31a1					FORTH_DSP_POP 
31a1 cd 03 23			call macro_forth_dsp_pop 
31a4				endm 
# End of macro FORTH_DSP_POP
31a4			 
31a4					FORTH_DSP_VALUEHL 
31a4 cd 4b 22			call macro_dsp_valuehl 
31a7				endm 
# End of macro FORTH_DSP_VALUEHL
31a7			 
31a7					; hl contains value to add to byte at a 
31a7				 
31a7 eb					ex de, hl 
31a8			 
31a8 e1					pop hl 
31a9			 
31a9					if DEBUG_FORTH_WORDS 
31a9						DMARK "DEC" 
31a9 f5				push af  
31aa 3a be 31			ld a, (.dmark)  
31ad 32 a0 fd			ld (debug_mark),a  
31b0 3a bf 31			ld a, (.dmark+1)  
31b3 32 a1 fd			ld (debug_mark+1),a  
31b6 3a c0 31			ld a, (.dmark+2)  
31b9 32 a2 fd			ld (debug_mark+2),a  
31bc 18 03			jr .pastdmark  
31be ..			.dmark: db "DEC"  
31c1 f1			.pastdmark: pop af  
31c2			endm  
# End of macro DMARK
31c2						CALLMONITOR 
31c2 cd aa fd			call debug_vector  
31c5				endm  
# End of macro CALLMONITOR
31c5					endif 
31c5			 
31c5 7e					ld a,(hl) 
31c6 93					sub e 
31c7 77					ld (hl),a 
31c8			 
31c8			 
31c8					FORTH_DSP_POP 
31c8 cd 03 23			call macro_forth_dsp_pop 
31cb				endm 
# End of macro FORTH_DSP_POP
31cb			 
31cb				       NEXTW 
31cb c3 37 24			jp macro_next 
31ce				endm 
# End of macro NEXTW
31ce			 
31ce			.INC2: 
31ce				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
31ce 6f				db WORD_SYS_CORE+91             
31cf 7b 32			dw .DEC2            
31d1 04				db 3 + 1 
31d2 .. 00			db "+2!",0              
31d6				endm 
# End of macro CWHEAD
31d6			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
31d6			 
31d6					if DEBUG_FORTH_WORDS_KEY 
31d6						DMARK "+2s" 
31d6 f5				push af  
31d7 3a eb 31			ld a, (.dmark)  
31da 32 a0 fd			ld (debug_mark),a  
31dd 3a ec 31			ld a, (.dmark+1)  
31e0 32 a1 fd			ld (debug_mark+1),a  
31e3 3a ed 31			ld a, (.dmark+2)  
31e6 32 a2 fd			ld (debug_mark+2),a  
31e9 18 03			jr .pastdmark  
31eb ..			.dmark: db "+2s"  
31ee f1			.pastdmark: pop af  
31ef			endm  
# End of macro DMARK
31ef						CALLMONITOR 
31ef cd aa fd			call debug_vector  
31f2				endm  
# End of macro CALLMONITOR
31f2					endif 
31f2			 
31f2					; Address 
31f2			 
31f2					FORTH_DSP_VALUEHL 
31f2 cd 4b 22			call macro_dsp_valuehl 
31f5				endm 
# End of macro FORTH_DSP_VALUEHL
31f5			 
31f5 e5					push hl    ; save address 
31f6			 
31f6					; load content into de 
31f6			 
31f6 5e					ld e,(hl) 
31f7 23					inc hl 
31f8 56					ld d, (hl) 
31f9			 
31f9					if DEBUG_FORTH_WORDS 
31f9						DMARK "+2a" 
31f9 f5				push af  
31fa 3a 0e 32			ld a, (.dmark)  
31fd 32 a0 fd			ld (debug_mark),a  
3200 3a 0f 32			ld a, (.dmark+1)  
3203 32 a1 fd			ld (debug_mark+1),a  
3206 3a 10 32			ld a, (.dmark+2)  
3209 32 a2 fd			ld (debug_mark+2),a  
320c 18 03			jr .pastdmark  
320e ..			.dmark: db "+2a"  
3211 f1			.pastdmark: pop af  
3212			endm  
# End of macro DMARK
3212						CALLMONITOR 
3212 cd aa fd			call debug_vector  
3215				endm  
# End of macro CALLMONITOR
3215					endif 
3215			 
3215					FORTH_DSP_POP 
3215 cd 03 23			call macro_forth_dsp_pop 
3218				endm 
# End of macro FORTH_DSP_POP
3218			 
3218					; Get value to add 
3218			 
3218					FORTH_DSP_VALUE 
3218 cd 34 22			call macro_forth_dsp_value 
321b				endm 
# End of macro FORTH_DSP_VALUE
321b			 
321b					if DEBUG_FORTH_WORDS 
321b						DMARK "+2v" 
321b f5				push af  
321c 3a 30 32			ld a, (.dmark)  
321f 32 a0 fd			ld (debug_mark),a  
3222 3a 31 32			ld a, (.dmark+1)  
3225 32 a1 fd			ld (debug_mark+1),a  
3228 3a 32 32			ld a, (.dmark+2)  
322b 32 a2 fd			ld (debug_mark+2),a  
322e 18 03			jr .pastdmark  
3230 ..			.dmark: db "+2v"  
3233 f1			.pastdmark: pop af  
3234			endm  
# End of macro DMARK
3234						CALLMONITOR 
3234 cd aa fd			call debug_vector  
3237				endm  
# End of macro CALLMONITOR
3237					endif 
3237			 
3237 19					add hl, de 
3238			 
3238					if DEBUG_FORTH_WORDS 
3238						DMARK "+2+" 
3238 f5				push af  
3239 3a 4d 32			ld a, (.dmark)  
323c 32 a0 fd			ld (debug_mark),a  
323f 3a 4e 32			ld a, (.dmark+1)  
3242 32 a1 fd			ld (debug_mark+1),a  
3245 3a 4f 32			ld a, (.dmark+2)  
3248 32 a2 fd			ld (debug_mark+2),a  
324b 18 03			jr .pastdmark  
324d ..			.dmark: db "+2+"  
3250 f1			.pastdmark: pop af  
3251			endm  
# End of macro DMARK
3251						CALLMONITOR 
3251 cd aa fd			call debug_vector  
3254				endm  
# End of macro CALLMONITOR
3254					endif 
3254			 
3254					; move result to de 
3254			 
3254 eb					ex de, hl 
3255			 
3255					; Address 
3255			 
3255 e1					pop hl 
3256			 
3256					; save it back 
3256			 
3256 73					ld (hl), e 
3257 23					inc hl 
3258 72					ld (hl), d 
3259			 
3259					if DEBUG_FORTH_WORDS 
3259						DMARK "+2e" 
3259 f5				push af  
325a 3a 6e 32			ld a, (.dmark)  
325d 32 a0 fd			ld (debug_mark),a  
3260 3a 6f 32			ld a, (.dmark+1)  
3263 32 a1 fd			ld (debug_mark+1),a  
3266 3a 70 32			ld a, (.dmark+2)  
3269 32 a2 fd			ld (debug_mark+2),a  
326c 18 03			jr .pastdmark  
326e ..			.dmark: db "+2e"  
3271 f1			.pastdmark: pop af  
3272			endm  
# End of macro DMARK
3272						CALLMONITOR 
3272 cd aa fd			call debug_vector  
3275				endm  
# End of macro CALLMONITOR
3275					endif 
3275			 
3275			 
3275			 
3275					FORTH_DSP_POP 
3275 cd 03 23			call macro_forth_dsp_pop 
3278				endm 
# End of macro FORTH_DSP_POP
3278			 
3278			 
3278				       NEXTW 
3278 c3 37 24			jp macro_next 
327b				endm 
# End of macro NEXTW
327b			 
327b			.DEC2: 
327b				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
327b 6f				db WORD_SYS_CORE+91             
327c 2a 33			dw .GET2            
327e 04				db 3 + 1 
327f .. 00			db "-2!",0              
3283				endm 
# End of macro CWHEAD
3283			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3283			 
3283			 
3283					if DEBUG_FORTH_WORDS_KEY 
3283						DMARK "-2s" 
3283 f5				push af  
3284 3a 98 32			ld a, (.dmark)  
3287 32 a0 fd			ld (debug_mark),a  
328a 3a 99 32			ld a, (.dmark+1)  
328d 32 a1 fd			ld (debug_mark+1),a  
3290 3a 9a 32			ld a, (.dmark+2)  
3293 32 a2 fd			ld (debug_mark+2),a  
3296 18 03			jr .pastdmark  
3298 ..			.dmark: db "-2s"  
329b f1			.pastdmark: pop af  
329c			endm  
# End of macro DMARK
329c						CALLMONITOR 
329c cd aa fd			call debug_vector  
329f				endm  
# End of macro CALLMONITOR
329f					endif 
329f			 
329f					; Address 
329f			 
329f					FORTH_DSP_VALUEHL 
329f cd 4b 22			call macro_dsp_valuehl 
32a2				endm 
# End of macro FORTH_DSP_VALUEHL
32a2			 
32a2 e5					push hl    ; save address 
32a3			 
32a3					; load content into de 
32a3			 
32a3 5e					ld e,(hl) 
32a4 23					inc hl 
32a5 56					ld d, (hl) 
32a6			 
32a6					if DEBUG_FORTH_WORDS 
32a6						DMARK "-2a" 
32a6 f5				push af  
32a7 3a bb 32			ld a, (.dmark)  
32aa 32 a0 fd			ld (debug_mark),a  
32ad 3a bc 32			ld a, (.dmark+1)  
32b0 32 a1 fd			ld (debug_mark+1),a  
32b3 3a bd 32			ld a, (.dmark+2)  
32b6 32 a2 fd			ld (debug_mark+2),a  
32b9 18 03			jr .pastdmark  
32bb ..			.dmark: db "-2a"  
32be f1			.pastdmark: pop af  
32bf			endm  
# End of macro DMARK
32bf						CALLMONITOR 
32bf cd aa fd			call debug_vector  
32c2				endm  
# End of macro CALLMONITOR
32c2					endif 
32c2			 
32c2					FORTH_DSP_POP 
32c2 cd 03 23			call macro_forth_dsp_pop 
32c5				endm 
# End of macro FORTH_DSP_POP
32c5			 
32c5					; Get value to remove 
32c5			 
32c5					FORTH_DSP_VALUE 
32c5 cd 34 22			call macro_forth_dsp_value 
32c8				endm 
# End of macro FORTH_DSP_VALUE
32c8			 
32c8					if DEBUG_FORTH_WORDS 
32c8						DMARK "-2v" 
32c8 f5				push af  
32c9 3a dd 32			ld a, (.dmark)  
32cc 32 a0 fd			ld (debug_mark),a  
32cf 3a de 32			ld a, (.dmark+1)  
32d2 32 a1 fd			ld (debug_mark+1),a  
32d5 3a df 32			ld a, (.dmark+2)  
32d8 32 a2 fd			ld (debug_mark+2),a  
32db 18 03			jr .pastdmark  
32dd ..			.dmark: db "-2v"  
32e0 f1			.pastdmark: pop af  
32e1			endm  
# End of macro DMARK
32e1						CALLMONITOR 
32e1 cd aa fd			call debug_vector  
32e4				endm  
# End of macro CALLMONITOR
32e4					endif 
32e4			 
32e4 eb					ex de, hl 
32e5 ed 52				sbc hl, de 
32e7			 
32e7					if DEBUG_FORTH_WORDS 
32e7						DMARK "-2d" 
32e7 f5				push af  
32e8 3a fc 32			ld a, (.dmark)  
32eb 32 a0 fd			ld (debug_mark),a  
32ee 3a fd 32			ld a, (.dmark+1)  
32f1 32 a1 fd			ld (debug_mark+1),a  
32f4 3a fe 32			ld a, (.dmark+2)  
32f7 32 a2 fd			ld (debug_mark+2),a  
32fa 18 03			jr .pastdmark  
32fc ..			.dmark: db "-2d"  
32ff f1			.pastdmark: pop af  
3300			endm  
# End of macro DMARK
3300						CALLMONITOR 
3300 cd aa fd			call debug_vector  
3303				endm  
# End of macro CALLMONITOR
3303					endif 
3303			 
3303					; move result to de 
3303			 
3303 eb					ex de, hl 
3304			 
3304					; Address 
3304			 
3304 e1					pop hl 
3305			 
3305					; save it back 
3305			 
3305 73					ld (hl), e 
3306 23					inc hl 
3307 72					ld (hl), d 
3308			 
3308					if DEBUG_FORTH_WORDS 
3308						DMARK "-2e" 
3308 f5				push af  
3309 3a 1d 33			ld a, (.dmark)  
330c 32 a0 fd			ld (debug_mark),a  
330f 3a 1e 33			ld a, (.dmark+1)  
3312 32 a1 fd			ld (debug_mark+1),a  
3315 3a 1f 33			ld a, (.dmark+2)  
3318 32 a2 fd			ld (debug_mark+2),a  
331b 18 03			jr .pastdmark  
331d ..			.dmark: db "-2e"  
3320 f1			.pastdmark: pop af  
3321			endm  
# End of macro DMARK
3321						CALLMONITOR 
3321 cd aa fd			call debug_vector  
3324				endm  
# End of macro CALLMONITOR
3324					endif 
3324			 
3324			 
3324					FORTH_DSP_POP 
3324 cd 03 23			call macro_forth_dsp_pop 
3327				endm 
# End of macro FORTH_DSP_POP
3327			 
3327			 
3327			 
3327				       NEXTW 
3327 c3 37 24			jp macro_next 
332a				endm 
# End of macro NEXTW
332a			.GET2: 
332a				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
332a 6f				db WORD_SYS_CORE+91             
332b 5f 33			dw .BANG2            
332d 03				db 2 + 1 
332e .. 00			db "2@",0              
3331				endm 
# End of macro CWHEAD
3331			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3331					if DEBUG_FORTH_WORDS_KEY 
3331						DMARK "2A_" 
3331 f5				push af  
3332 3a 46 33			ld a, (.dmark)  
3335 32 a0 fd			ld (debug_mark),a  
3338 3a 47 33			ld a, (.dmark+1)  
333b 32 a1 fd			ld (debug_mark+1),a  
333e 3a 48 33			ld a, (.dmark+2)  
3341 32 a2 fd			ld (debug_mark+2),a  
3344 18 03			jr .pastdmark  
3346 ..			.dmark: db "2A_"  
3349 f1			.pastdmark: pop af  
334a			endm  
# End of macro DMARK
334a						CALLMONITOR 
334a cd aa fd			call debug_vector  
334d				endm  
# End of macro CALLMONITOR
334d					endif 
334d			 
334d					FORTH_DSP_VALUEHL 
334d cd 4b 22			call macro_dsp_valuehl 
3350				endm 
# End of macro FORTH_DSP_VALUEHL
3350			 
3350 e5					push hl   ; save address 
3351			 
3351					FORTH_DSP_POP 
3351 cd 03 23			call macro_forth_dsp_pop 
3354				endm 
# End of macro FORTH_DSP_POP
3354			 
3354 e1					pop hl 
3355			 
3355 5e					ld e, (hl) 
3356 23					inc hl 
3357 56					ld d, (hl) 
3358			 
3358 eb					ex de, hl 
3359			 
3359 cd 46 20				call forth_push_numhl 
335c			 
335c				       NEXTW 
335c c3 37 24			jp macro_next 
335f				endm 
# End of macro NEXTW
335f			.BANG2: 
335f				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
335f 6f				db WORD_SYS_CORE+91             
3360 97 33			dw .CONFIG            
3362 03				db 2 + 1 
3363 .. 00			db "2!",0              
3366				endm 
# End of macro CWHEAD
3366			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3366					if DEBUG_FORTH_WORDS_KEY 
3366						DMARK "2S_" 
3366 f5				push af  
3367 3a 7b 33			ld a, (.dmark)  
336a 32 a0 fd			ld (debug_mark),a  
336d 3a 7c 33			ld a, (.dmark+1)  
3370 32 a1 fd			ld (debug_mark+1),a  
3373 3a 7d 33			ld a, (.dmark+2)  
3376 32 a2 fd			ld (debug_mark+2),a  
3379 18 03			jr .pastdmark  
337b ..			.dmark: db "2S_"  
337e f1			.pastdmark: pop af  
337f			endm  
# End of macro DMARK
337f						CALLMONITOR 
337f cd aa fd			call debug_vector  
3382				endm  
# End of macro CALLMONITOR
3382					endif 
3382			 
3382					FORTH_DSP_VALUEHL 
3382 cd 4b 22			call macro_dsp_valuehl 
3385				endm 
# End of macro FORTH_DSP_VALUEHL
3385			 
3385 e5					push hl   ; save address 
3386			 
3386			 
3386					FORTH_DSP_POP 
3386 cd 03 23			call macro_forth_dsp_pop 
3389				endm 
# End of macro FORTH_DSP_POP
3389			 
3389					 
3389					FORTH_DSP_VALUEHL 
3389 cd 4b 22			call macro_dsp_valuehl 
338c				endm 
# End of macro FORTH_DSP_VALUEHL
338c			 
338c					FORTH_DSP_POP 
338c cd 03 23			call macro_forth_dsp_pop 
338f				endm 
# End of macro FORTH_DSP_POP
338f			 
338f eb					ex de, hl    ; value now in de 
3390			 
3390 e1					pop hl 
3391			 
3391 73					ld (hl), e 
3392			 
3392 23					inc hl 
3393			 
3393 72					ld (hl), d 
3394			 
3394			 
3394				       NEXTW 
3394 c3 37 24			jp macro_next 
3397				endm 
# End of macro NEXTW
3397			.CONFIG: 
3397				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
3397 6f				db WORD_SYS_CORE+91             
3398 a8 33			dw .ADTOS            
339a 07				db 6 + 1 
339b .. 00			db "CONFIG",0              
33a2				endm 
# End of macro CWHEAD
33a2			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
33a2			 
33a2 cd 52 15				call config 
33a5					NEXTW 
33a5 c3 37 24			jp macro_next 
33a8				endm 
# End of macro NEXTW
33a8			 
33a8			.ADTOS: 
33a8				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
33a8 6f				db WORD_SYS_CORE+91             
33a9 be 33			dw .SBTOS            
33ab 03				db 2 + 1 
33ac .. 00			db "1+",0              
33af				endm 
# End of macro CWHEAD
33af			; | 1+ ( u -- u )  Increment value on TOS | DONE 
33af			 
33af					FORTH_DSP_VALUEHL 
33af cd 4b 22			call macro_dsp_valuehl 
33b2				endm 
# End of macro FORTH_DSP_VALUEHL
33b2 e5					push hl 
33b3			 
33b3					FORTH_DSP_POP 
33b3 cd 03 23			call macro_forth_dsp_pop 
33b6				endm 
# End of macro FORTH_DSP_POP
33b6 e1					pop hl 
33b7			 
33b7 23					inc hl 
33b8 cd 46 20				call forth_push_numhl 
33bb					 
33bb					NEXTW 
33bb c3 37 24			jp macro_next 
33be				endm 
# End of macro NEXTW
33be			.SBTOS: 
33be				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
33be 6f				db WORD_SYS_CORE+91             
33bf d4 33			dw .ADSTORE            
33c1 03				db 2 + 1 
33c2 .. 00			db "1-",0              
33c5				endm 
# End of macro CWHEAD
33c5			; | 1- ( u -- u )  Decrement value on TOS | DONE 
33c5			 
33c5					FORTH_DSP_VALUEHL 
33c5 cd 4b 22			call macro_dsp_valuehl 
33c8				endm 
# End of macro FORTH_DSP_VALUEHL
33c8 e5					push hl 
33c9			 
33c9					FORTH_DSP_POP 
33c9 cd 03 23			call macro_forth_dsp_pop 
33cc				endm 
# End of macro FORTH_DSP_POP
33cc e1					pop hl 
33cd			 
33cd 2b					dec hl 
33ce cd 46 20				call forth_push_numhl 
33d1					 
33d1					NEXTW 
33d1 c3 37 24			jp macro_next 
33d4				endm 
# End of macro NEXTW
33d4			.ADSTORE: 
33d4				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
33d4 6f				db WORD_SYS_CORE+91             
33d5 ea 33			dw .ADWSTORE            
33d7 04				db 3 + 1 
33d8 .. 00			db "1+!",0              
33dc				endm 
# End of macro CWHEAD
33dc			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
33dc			 
33dc					FORTH_DSP_VALUEHL 
33dc cd 4b 22			call macro_dsp_valuehl 
33df				endm 
# End of macro FORTH_DSP_VALUEHL
33df e5					push hl 
33e0			 
33e0					FORTH_DSP_POP 
33e0 cd 03 23			call macro_forth_dsp_pop 
33e3				endm 
# End of macro FORTH_DSP_POP
33e3 e1					pop hl 
33e4			 
33e4 7e					ld a, (hl) 
33e5 3c					inc a 
33e6 77					ld (hl), a 
33e7					 
33e7					NEXTW 
33e7 c3 37 24			jp macro_next 
33ea				endm 
# End of macro NEXTW
33ea			.ADWSTORE: 
33ea				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
33ea 6f				db WORD_SYS_CORE+91             
33eb 08 34			dw .SBSTORE            
33ed 05				db 4 + 1 
33ee .. 00			db "1+2!",0              
33f3				endm 
# End of macro CWHEAD
33f3			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
33f3			 
33f3					FORTH_DSP_VALUEHL 
33f3 cd 4b 22			call macro_dsp_valuehl 
33f6				endm 
# End of macro FORTH_DSP_VALUEHL
33f6 e5					push hl 
33f7			 
33f7					FORTH_DSP_POP 
33f7 cd 03 23			call macro_forth_dsp_pop 
33fa				endm 
# End of macro FORTH_DSP_POP
33fa e1					pop hl 
33fb			 
33fb e5					push hl 
33fc			 
33fc cd b9 23				call loadwordinhl 
33ff 23					inc hl 
3400			 
3400 d1					pop de 
3401 eb					ex de, hl 
3402 73					ld (hl), e 
3403 23					inc hl 
3404 72					ld (hl), d 
3405					 
3405					NEXTW 
3405 c3 37 24			jp macro_next 
3408				endm 
# End of macro NEXTW
3408			.SBSTORE: 
3408				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
3408 6f				db WORD_SYS_CORE+91             
3409 1e 34			dw .SBWSTORE            
340b 04				db 3 + 1 
340c .. 00			db "1-!",0              
3410				endm 
# End of macro CWHEAD
3410			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3410			 
3410					FORTH_DSP_VALUEHL 
3410 cd 4b 22			call macro_dsp_valuehl 
3413				endm 
# End of macro FORTH_DSP_VALUEHL
3413 e5					push hl 
3414			 
3414					FORTH_DSP_POP 
3414 cd 03 23			call macro_forth_dsp_pop 
3417				endm 
# End of macro FORTH_DSP_POP
3417 e1					pop hl 
3418			 
3418 7e					ld a, (hl) 
3419 3d					dec a 
341a 77					ld (hl), a 
341b					 
341b					NEXTW 
341b c3 37 24			jp macro_next 
341e				endm 
# End of macro NEXTW
341e			.SBWSTORE: 
341e				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
341e 6f				db WORD_SYS_CORE+91             
341f 3c 34			dw .ENDCORE            
3421 05				db 4 + 1 
3422 .. 00			db "1-2!",0              
3427				endm 
# End of macro CWHEAD
3427			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
3427			 
3427					FORTH_DSP_VALUEHL 
3427 cd 4b 22			call macro_dsp_valuehl 
342a				endm 
# End of macro FORTH_DSP_VALUEHL
342a e5					push hl 
342b			 
342b					FORTH_DSP_POP 
342b cd 03 23			call macro_forth_dsp_pop 
342e				endm 
# End of macro FORTH_DSP_POP
342e e1					pop hl 
342f			 
342f e5					push hl 
3430			 
3430 cd b9 23				call loadwordinhl 
3433 2b					dec hl 
3434			 
3434 d1					pop de 
3435 eb					ex de, hl 
3436 73					ld (hl), e 
3437 23					inc hl 
3438 72					ld (hl), d 
3439					 
3439					NEXTW 
3439 c3 37 24			jp macro_next 
343c				endm 
# End of macro NEXTW
343c			.ENDCORE: 
343c			 
343c			; eof 
343c			 
343c			 
# End of file forth_words_core.asm
343c			include "forth_words_flow.asm" 
343c			 
343c			; | ## Program Flow Words 
343c			 
343c			.IF: 
343c				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
343c 1e				db WORD_SYS_CORE+10             
343d 31 35			dw .THEN            
343f 03				db 2 + 1 
3440 .. 00			db "IF",0              
3443				endm 
# End of macro CWHEAD
3443			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3443			; 
3443					if DEBUG_FORTH_WORDS_KEY 
3443						DMARK "IF." 
3443 f5				push af  
3444 3a 58 34			ld a, (.dmark)  
3447 32 a0 fd			ld (debug_mark),a  
344a 3a 59 34			ld a, (.dmark+1)  
344d 32 a1 fd			ld (debug_mark+1),a  
3450 3a 5a 34			ld a, (.dmark+2)  
3453 32 a2 fd			ld (debug_mark+2),a  
3456 18 03			jr .pastdmark  
3458 ..			.dmark: db "IF."  
345b f1			.pastdmark: pop af  
345c			endm  
# End of macro DMARK
345c						CALLMONITOR 
345c cd aa fd			call debug_vector  
345f				endm  
# End of macro CALLMONITOR
345f					endif 
345f			; eval TOS 
345f			 
345f				FORTH_DSP_VALUEHL 
345f cd 4b 22			call macro_dsp_valuehl 
3462				endm 
# End of macro FORTH_DSP_VALUEHL
3462			 
3462			;	push hl 
3462				FORTH_DSP_POP 
3462 cd 03 23			call macro_forth_dsp_pop 
3465				endm 
# End of macro FORTH_DSP_POP
3465			;	pop hl 
3465			 
3465					if DEBUG_FORTH_WORDS 
3465						DMARK "IF1" 
3465 f5				push af  
3466 3a 7a 34			ld a, (.dmark)  
3469 32 a0 fd			ld (debug_mark),a  
346c 3a 7b 34			ld a, (.dmark+1)  
346f 32 a1 fd			ld (debug_mark+1),a  
3472 3a 7c 34			ld a, (.dmark+2)  
3475 32 a2 fd			ld (debug_mark+2),a  
3478 18 03			jr .pastdmark  
347a ..			.dmark: db "IF1"  
347d f1			.pastdmark: pop af  
347e			endm  
# End of macro DMARK
347e						CALLMONITOR 
347e cd aa fd			call debug_vector  
3481				endm  
# End of macro CALLMONITOR
3481					endif 
3481 b7				or a        ; clear carry flag 
3482 11 00 00			ld de, 0 
3485 eb				ex de,hl 
3486 ed 52			sbc hl, de 
3488 c2 12 35			jp nz, .iftrue 
348b			 
348b					if DEBUG_FORTH_WORDS 
348b						DMARK "IF2" 
348b f5				push af  
348c 3a a0 34			ld a, (.dmark)  
348f 32 a0 fd			ld (debug_mark),a  
3492 3a a1 34			ld a, (.dmark+1)  
3495 32 a1 fd			ld (debug_mark+1),a  
3498 3a a2 34			ld a, (.dmark+2)  
349b 32 a2 fd			ld (debug_mark+2),a  
349e 18 03			jr .pastdmark  
34a0 ..			.dmark: db "IF2"  
34a3 f1			.pastdmark: pop af  
34a4			endm  
# End of macro DMARK
34a4						CALLMONITOR 
34a4 cd aa fd			call debug_vector  
34a7				endm  
# End of macro CALLMONITOR
34a7					endif 
34a7			 
34a7			; if not true then skip to THEN 
34a7			 
34a7				; TODO get tok_ptr 
34a7				; TODO consume toks until we get to THEN 
34a7			 
34a7 2a f7 f3			ld hl, (os_tok_ptr) 
34aa					if DEBUG_FORTH_WORDS 
34aa						DMARK "IF3" 
34aa f5				push af  
34ab 3a bf 34			ld a, (.dmark)  
34ae 32 a0 fd			ld (debug_mark),a  
34b1 3a c0 34			ld a, (.dmark+1)  
34b4 32 a1 fd			ld (debug_mark+1),a  
34b7 3a c1 34			ld a, (.dmark+2)  
34ba 32 a2 fd			ld (debug_mark+2),a  
34bd 18 03			jr .pastdmark  
34bf ..			.dmark: db "IF3"  
34c2 f1			.pastdmark: pop af  
34c3			endm  
# End of macro DMARK
34c3						CALLMONITOR 
34c3 cd aa fd			call debug_vector  
34c6				endm  
# End of macro CALLMONITOR
34c6						 
34c6					endif 
34c6 11 0d 35			ld de, .ifthen 
34c9					if DEBUG_FORTH_WORDS 
34c9						DMARK "IF4" 
34c9 f5				push af  
34ca 3a de 34			ld a, (.dmark)  
34cd 32 a0 fd			ld (debug_mark),a  
34d0 3a df 34			ld a, (.dmark+1)  
34d3 32 a1 fd			ld (debug_mark+1),a  
34d6 3a e0 34			ld a, (.dmark+2)  
34d9 32 a2 fd			ld (debug_mark+2),a  
34dc 18 03			jr .pastdmark  
34de ..			.dmark: db "IF4"  
34e1 f1			.pastdmark: pop af  
34e2			endm  
# End of macro DMARK
34e2						CALLMONITOR 
34e2 cd aa fd			call debug_vector  
34e5				endm  
# End of macro CALLMONITOR
34e5					endif 
34e5 cd 52 25			call findnexttok  
34e8			 
34e8					if DEBUG_FORTH_WORDS 
34e8						DMARK "IF5" 
34e8 f5				push af  
34e9 3a fd 34			ld a, (.dmark)  
34ec 32 a0 fd			ld (debug_mark),a  
34ef 3a fe 34			ld a, (.dmark+1)  
34f2 32 a1 fd			ld (debug_mark+1),a  
34f5 3a ff 34			ld a, (.dmark+2)  
34f8 32 a2 fd			ld (debug_mark+2),a  
34fb 18 03			jr .pastdmark  
34fd ..			.dmark: db "IF5"  
3500 f1			.pastdmark: pop af  
3501			endm  
# End of macro DMARK
3501						CALLMONITOR 
3501 cd aa fd			call debug_vector  
3504				endm  
# End of macro CALLMONITOR
3504					endif 
3504				; TODO replace below with ; exec using tok_ptr 
3504 22 f7 f3			ld (os_tok_ptr), hl 
3507 c3 c8 24			jp exec1 
350a				NEXTW 
350a c3 37 24			jp macro_next 
350d				endm 
# End of macro NEXTW
350d			 
350d .. 00		.ifthen:  db "THEN",0 
3512			 
3512			.iftrue:		 
3512				; Exec next words normally 
3512			 
3512				; if true then exec following IF as normal 
3512					if DEBUG_FORTH_WORDS 
3512						DMARK "IFT" 
3512 f5				push af  
3513 3a 27 35			ld a, (.dmark)  
3516 32 a0 fd			ld (debug_mark),a  
3519 3a 28 35			ld a, (.dmark+1)  
351c 32 a1 fd			ld (debug_mark+1),a  
351f 3a 29 35			ld a, (.dmark+2)  
3522 32 a2 fd			ld (debug_mark+2),a  
3525 18 03			jr .pastdmark  
3527 ..			.dmark: db "IFT"  
352a f1			.pastdmark: pop af  
352b			endm  
# End of macro DMARK
352b						CALLMONITOR 
352b cd aa fd			call debug_vector  
352e				endm  
# End of macro CALLMONITOR
352e					endif 
352e			 
352e					NEXTW 
352e c3 37 24			jp macro_next 
3531				endm 
# End of macro NEXTW
3531			.THEN: 
3531				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3531 1f				db WORD_SYS_CORE+11             
3532 59 35			dw .ELSE            
3534 05				db 4 + 1 
3535 .. 00			db "THEN",0              
353a				endm 
# End of macro CWHEAD
353a			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
353a					if DEBUG_FORTH_WORDS_KEY 
353a						DMARK "THN" 
353a f5				push af  
353b 3a 4f 35			ld a, (.dmark)  
353e 32 a0 fd			ld (debug_mark),a  
3541 3a 50 35			ld a, (.dmark+1)  
3544 32 a1 fd			ld (debug_mark+1),a  
3547 3a 51 35			ld a, (.dmark+2)  
354a 32 a2 fd			ld (debug_mark+2),a  
354d 18 03			jr .pastdmark  
354f ..			.dmark: db "THN"  
3552 f1			.pastdmark: pop af  
3553			endm  
# End of macro DMARK
3553						CALLMONITOR 
3553 cd aa fd			call debug_vector  
3556				endm  
# End of macro CALLMONITOR
3556					endif 
3556					NEXTW 
3556 c3 37 24			jp macro_next 
3559				endm 
# End of macro NEXTW
3559			.ELSE: 
3559				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3559 20				db WORD_SYS_CORE+12             
355a 81 35			dw .DO            
355c 03				db 2 + 1 
355d .. 00			db "ELSE",0              
3562				endm 
# End of macro CWHEAD
3562			; | ELSE ( -- ) Not supported - does nothing | TODO 
3562			 
3562					if DEBUG_FORTH_WORDS_KEY 
3562						DMARK "ELS" 
3562 f5				push af  
3563 3a 77 35			ld a, (.dmark)  
3566 32 a0 fd			ld (debug_mark),a  
3569 3a 78 35			ld a, (.dmark+1)  
356c 32 a1 fd			ld (debug_mark+1),a  
356f 3a 79 35			ld a, (.dmark+2)  
3572 32 a2 fd			ld (debug_mark+2),a  
3575 18 03			jr .pastdmark  
3577 ..			.dmark: db "ELS"  
357a f1			.pastdmark: pop af  
357b			endm  
# End of macro DMARK
357b						CALLMONITOR 
357b cd aa fd			call debug_vector  
357e				endm  
# End of macro CALLMONITOR
357e					endif 
357e			 
357e			 
357e					NEXTW 
357e c3 37 24			jp macro_next 
3581				endm 
# End of macro NEXTW
3581			.DO: 
3581				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3581 21				db WORD_SYS_CORE+13             
3582 a8 36			dw .LOOP            
3584 03				db 2 + 1 
3585 .. 00			db "DO",0              
3588				endm 
# End of macro CWHEAD
3588			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3588			 
3588					if DEBUG_FORTH_WORDS_KEY 
3588						DMARK "DO." 
3588 f5				push af  
3589 3a 9d 35			ld a, (.dmark)  
358c 32 a0 fd			ld (debug_mark),a  
358f 3a 9e 35			ld a, (.dmark+1)  
3592 32 a1 fd			ld (debug_mark+1),a  
3595 3a 9f 35			ld a, (.dmark+2)  
3598 32 a2 fd			ld (debug_mark+2),a  
359b 18 03			jr .pastdmark  
359d ..			.dmark: db "DO."  
35a0 f1			.pastdmark: pop af  
35a1			endm  
# End of macro DMARK
35a1						CALLMONITOR 
35a1 cd aa fd			call debug_vector  
35a4				endm  
# End of macro CALLMONITOR
35a4					endif 
35a4			;  push pc to rsp stack past the DO 
35a4			 
35a4 2a f7 f3				ld hl, (os_tok_ptr) 
35a7 23					inc hl   ; D 
35a8 23					inc hl  ; O 
35a9 23					inc hl   ; null 
35aa					if DEBUG_FORTH_WORDS 
35aa						DMARK "DO2" 
35aa f5				push af  
35ab 3a bf 35			ld a, (.dmark)  
35ae 32 a0 fd			ld (debug_mark),a  
35b1 3a c0 35			ld a, (.dmark+1)  
35b4 32 a1 fd			ld (debug_mark+1),a  
35b7 3a c1 35			ld a, (.dmark+2)  
35ba 32 a2 fd			ld (debug_mark+2),a  
35bd 18 03			jr .pastdmark  
35bf ..			.dmark: db "DO2"  
35c2 f1			.pastdmark: pop af  
35c3			endm  
# End of macro DMARK
35c3						CALLMONITOR 
35c3 cd aa fd			call debug_vector  
35c6				endm  
# End of macro CALLMONITOR
35c6					endif 
35c6					FORTH_RSP_NEXT 
35c6 cd ed 1f			call macro_forth_rsp_next 
35c9				endm 
# End of macro FORTH_RSP_NEXT
35c9					if DEBUG_FORTH_WORDS 
35c9						DMARK "DO3" 
35c9 f5				push af  
35ca 3a de 35			ld a, (.dmark)  
35cd 32 a0 fd			ld (debug_mark),a  
35d0 3a df 35			ld a, (.dmark+1)  
35d3 32 a1 fd			ld (debug_mark+1),a  
35d6 3a e0 35			ld a, (.dmark+2)  
35d9 32 a2 fd			ld (debug_mark+2),a  
35dc 18 03			jr .pastdmark  
35de ..			.dmark: db "DO3"  
35e1 f1			.pastdmark: pop af  
35e2			endm  
# End of macro DMARK
35e2						CALLMONITOR 
35e2 cd aa fd			call debug_vector  
35e5				endm  
# End of macro CALLMONITOR
35e5					endif 
35e5			 
35e5					;if DEBUG_FORTH_WORDS 
35e5				;		push hl 
35e5			;		endif  
35e5			 
35e5			; get counters from data stack 
35e5			 
35e5			 
35e5					FORTH_DSP_VALUEHL 
35e5 cd 4b 22			call macro_dsp_valuehl 
35e8				endm 
# End of macro FORTH_DSP_VALUEHL
35e8 e5					push hl		 ; hl now has starting counter which needs to be tos 
35e9			 
35e9					if DEBUG_FORTH_WORDS 
35e9						DMARK "DO4" 
35e9 f5				push af  
35ea 3a fe 35			ld a, (.dmark)  
35ed 32 a0 fd			ld (debug_mark),a  
35f0 3a ff 35			ld a, (.dmark+1)  
35f3 32 a1 fd			ld (debug_mark+1),a  
35f6 3a 00 36			ld a, (.dmark+2)  
35f9 32 a2 fd			ld (debug_mark+2),a  
35fc 18 03			jr .pastdmark  
35fe ..			.dmark: db "DO4"  
3601 f1			.pastdmark: pop af  
3602			endm  
# End of macro DMARK
3602						CALLMONITOR 
3602 cd aa fd			call debug_vector  
3605				endm  
# End of macro CALLMONITOR
3605					endif 
3605					FORTH_DSP_POP 
3605 cd 03 23			call macro_forth_dsp_pop 
3608				endm 
# End of macro FORTH_DSP_POP
3608			 
3608					if DEBUG_FORTH_WORDS 
3608						DMARK "DO5" 
3608 f5				push af  
3609 3a 1d 36			ld a, (.dmark)  
360c 32 a0 fd			ld (debug_mark),a  
360f 3a 1e 36			ld a, (.dmark+1)  
3612 32 a1 fd			ld (debug_mark+1),a  
3615 3a 1f 36			ld a, (.dmark+2)  
3618 32 a2 fd			ld (debug_mark+2),a  
361b 18 03			jr .pastdmark  
361d ..			.dmark: db "DO5"  
3620 f1			.pastdmark: pop af  
3621			endm  
# End of macro DMARK
3621						CALLMONITOR 
3621 cd aa fd			call debug_vector  
3624				endm  
# End of macro CALLMONITOR
3624					endif 
3624			 
3624					FORTH_DSP_VALUEHL 
3624 cd 4b 22			call macro_dsp_valuehl 
3627				endm 
# End of macro FORTH_DSP_VALUEHL
3627			;		push hl		 ; hl now has starting limit counter 
3627			 
3627					if DEBUG_FORTH_WORDS 
3627						DMARK "DO6" 
3627 f5				push af  
3628 3a 3c 36			ld a, (.dmark)  
362b 32 a0 fd			ld (debug_mark),a  
362e 3a 3d 36			ld a, (.dmark+1)  
3631 32 a1 fd			ld (debug_mark+1),a  
3634 3a 3e 36			ld a, (.dmark+2)  
3637 32 a2 fd			ld (debug_mark+2),a  
363a 18 03			jr .pastdmark  
363c ..			.dmark: db "DO6"  
363f f1			.pastdmark: pop af  
3640			endm  
# End of macro DMARK
3640						CALLMONITOR 
3640 cd aa fd			call debug_vector  
3643				endm  
# End of macro CALLMONITOR
3643					endif 
3643					FORTH_DSP_POP 
3643 cd 03 23			call macro_forth_dsp_pop 
3646				endm 
# End of macro FORTH_DSP_POP
3646			 
3646			; put counters on the loop stack 
3646			 
3646			;		pop hl			 ; limit counter 
3646 d1					pop de			; start counter 
3647			 
3647					; push limit counter 
3647			 
3647					if DEBUG_FORTH_WORDS 
3647						DMARK "DO7" 
3647 f5				push af  
3648 3a 5c 36			ld a, (.dmark)  
364b 32 a0 fd			ld (debug_mark),a  
364e 3a 5d 36			ld a, (.dmark+1)  
3651 32 a1 fd			ld (debug_mark+1),a  
3654 3a 5e 36			ld a, (.dmark+2)  
3657 32 a2 fd			ld (debug_mark+2),a  
365a 18 03			jr .pastdmark  
365c ..			.dmark: db "DO7"  
365f f1			.pastdmark: pop af  
3660			endm  
# End of macro DMARK
3660						CALLMONITOR 
3660 cd aa fd			call debug_vector  
3663				endm  
# End of macro CALLMONITOR
3663					endif 
3663					FORTH_LOOP_NEXT 
3663 cd 7c 22			call macro_forth_loop_next 
3666				endm 
# End of macro FORTH_LOOP_NEXT
3666			 
3666					; push start counter 
3666			 
3666 eb					ex de, hl 
3667					if DEBUG_FORTH_WORDS 
3667						DMARK "DO7" 
3667 f5				push af  
3668 3a 7c 36			ld a, (.dmark)  
366b 32 a0 fd			ld (debug_mark),a  
366e 3a 7d 36			ld a, (.dmark+1)  
3671 32 a1 fd			ld (debug_mark+1),a  
3674 3a 7e 36			ld a, (.dmark+2)  
3677 32 a2 fd			ld (debug_mark+2),a  
367a 18 03			jr .pastdmark  
367c ..			.dmark: db "DO7"  
367f f1			.pastdmark: pop af  
3680			endm  
# End of macro DMARK
3680						CALLMONITOR 
3680 cd aa fd			call debug_vector  
3683				endm  
# End of macro CALLMONITOR
3683					endif 
3683					FORTH_LOOP_NEXT 
3683 cd 7c 22			call macro_forth_loop_next 
3686				endm 
# End of macro FORTH_LOOP_NEXT
3686			 
3686			 
3686					; init first round of I counter 
3686			 
3686 22 1b f4				ld (os_current_i), hl 
3689			 
3689					if DEBUG_FORTH_WORDS 
3689						DMARK "DO8" 
3689 f5				push af  
368a 3a 9e 36			ld a, (.dmark)  
368d 32 a0 fd			ld (debug_mark),a  
3690 3a 9f 36			ld a, (.dmark+1)  
3693 32 a1 fd			ld (debug_mark+1),a  
3696 3a a0 36			ld a, (.dmark+2)  
3699 32 a2 fd			ld (debug_mark+2),a  
369c 18 03			jr .pastdmark  
369e ..			.dmark: db "DO8"  
36a1 f1			.pastdmark: pop af  
36a2			endm  
# End of macro DMARK
36a2						CALLMONITOR 
36a2 cd aa fd			call debug_vector  
36a5				endm  
# End of macro CALLMONITOR
36a5					endif 
36a5			 
36a5					NEXTW 
36a5 c3 37 24			jp macro_next 
36a8				endm 
# End of macro NEXTW
36a8			.LOOP: 
36a8				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
36a8 22				db WORD_SYS_CORE+14             
36a9 c0 37			dw .I            
36ab 05				db 4 + 1 
36ac .. 00			db "LOOP",0              
36b1				endm 
# End of macro CWHEAD
36b1			; | LOOP ( -- ) Increment and test loop counter  | DONE 
36b1			 
36b1				; pop tos as current loop count to hl 
36b1			 
36b1				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36b1			 
36b1				FORTH_LOOP_TOS 
36b1 cd af 22			call macro_forth_loop_tos 
36b4				endm 
# End of macro FORTH_LOOP_TOS
36b4 e5				push hl 
36b5			 
36b5					if DEBUG_FORTH_WORDS_KEY 
36b5						DMARK "LOP" 
36b5 f5				push af  
36b6 3a ca 36			ld a, (.dmark)  
36b9 32 a0 fd			ld (debug_mark),a  
36bc 3a cb 36			ld a, (.dmark+1)  
36bf 32 a1 fd			ld (debug_mark+1),a  
36c2 3a cc 36			ld a, (.dmark+2)  
36c5 32 a2 fd			ld (debug_mark+2),a  
36c8 18 03			jr .pastdmark  
36ca ..			.dmark: db "LOP"  
36cd f1			.pastdmark: pop af  
36ce			endm  
# End of macro DMARK
36ce						CALLMONITOR 
36ce cd aa fd			call debug_vector  
36d1				endm  
# End of macro CALLMONITOR
36d1					endif 
36d1				; next item on the stack is the limit. get it 
36d1			 
36d1			 
36d1				FORTH_LOOP_POP 
36d1 cd b9 22			call macro_forth_loop_pop 
36d4				endm 
# End of macro FORTH_LOOP_POP
36d4			 
36d4				FORTH_LOOP_TOS 
36d4 cd af 22			call macro_forth_loop_tos 
36d7				endm 
# End of macro FORTH_LOOP_TOS
36d7			 
36d7 d1				pop de		 ; de = i, hl = limit 
36d8			 
36d8					if DEBUG_FORTH_WORDS 
36d8						DMARK "LP1" 
36d8 f5				push af  
36d9 3a ed 36			ld a, (.dmark)  
36dc 32 a0 fd			ld (debug_mark),a  
36df 3a ee 36			ld a, (.dmark+1)  
36e2 32 a1 fd			ld (debug_mark+1),a  
36e5 3a ef 36			ld a, (.dmark+2)  
36e8 32 a2 fd			ld (debug_mark+2),a  
36eb 18 03			jr .pastdmark  
36ed ..			.dmark: db "LP1"  
36f0 f1			.pastdmark: pop af  
36f1			endm  
# End of macro DMARK
36f1						CALLMONITOR 
36f1 cd aa fd			call debug_vector  
36f4				endm  
# End of macro CALLMONITOR
36f4					endif 
36f4			 
36f4				; go back to previous word 
36f4			 
36f4 d5				push de    ; save I for inc later 
36f5			 
36f5			 
36f5				; get limit 
36f5				;  is I at limit? 
36f5			 
36f5			 
36f5					if DEBUG_FORTH_WORDS 
36f5						DMARK "LP1" 
36f5 f5				push af  
36f6 3a 0a 37			ld a, (.dmark)  
36f9 32 a0 fd			ld (debug_mark),a  
36fc 3a 0b 37			ld a, (.dmark+1)  
36ff 32 a1 fd			ld (debug_mark+1),a  
3702 3a 0c 37			ld a, (.dmark+2)  
3705 32 a2 fd			ld (debug_mark+2),a  
3708 18 03			jr .pastdmark  
370a ..			.dmark: db "LP1"  
370d f1			.pastdmark: pop af  
370e			endm  
# End of macro DMARK
370e						CALLMONITOR 
370e cd aa fd			call debug_vector  
3711				endm  
# End of macro CALLMONITOR
3711					endif 
3711			 
3711 ed 52			sbc hl, de 
3713			 
3713			 
3713				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3713			 
3713 20 26				jr nz, .loopnotdone 
3715			 
3715 e1				pop hl   ; get rid of saved I 
3716				FORTH_LOOP_POP     ; get rid of limit 
3716 cd b9 22			call macro_forth_loop_pop 
3719				endm 
# End of macro FORTH_LOOP_POP
3719			 
3719				FORTH_RSP_POP     ; get rid of DO ptr 
3719 cd 0e 20			call macro_forth_rsp_pop 
371c				endm 
# End of macro FORTH_RSP_POP
371c			 
371c			if DEBUG_FORTH_WORDS 
371c						DMARK "LP>" 
371c f5				push af  
371d 3a 31 37			ld a, (.dmark)  
3720 32 a0 fd			ld (debug_mark),a  
3723 3a 32 37			ld a, (.dmark+1)  
3726 32 a1 fd			ld (debug_mark+1),a  
3729 3a 33 37			ld a, (.dmark+2)  
372c 32 a2 fd			ld (debug_mark+2),a  
372f 18 03			jr .pastdmark  
3731 ..			.dmark: db "LP>"  
3734 f1			.pastdmark: pop af  
3735			endm  
# End of macro DMARK
3735				CALLMONITOR 
3735 cd aa fd			call debug_vector  
3738				endm  
# End of macro CALLMONITOR
3738			endif 
3738			 
3738					NEXTW 
3738 c3 37 24			jp macro_next 
373b				endm 
# End of macro NEXTW
373b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
373b			 
373b			.loopnotdone: 
373b			 
373b e1				pop hl    ; get I 
373c 23				inc hl 
373d			 
373d			   	; save new I 
373d			 
373d			 
373d					; set I counter 
373d			 
373d 22 1b f4				ld (os_current_i), hl 
3740			 
3740					if DEBUG_FORTH_WORDS 
3740						DMARK "LPN" 
3740 f5				push af  
3741 3a 55 37			ld a, (.dmark)  
3744 32 a0 fd			ld (debug_mark),a  
3747 3a 56 37			ld a, (.dmark+1)  
374a 32 a1 fd			ld (debug_mark+1),a  
374d 3a 57 37			ld a, (.dmark+2)  
3750 32 a2 fd			ld (debug_mark+2),a  
3753 18 03			jr .pastdmark  
3755 ..			.dmark: db "LPN"  
3758 f1			.pastdmark: pop af  
3759			endm  
# End of macro DMARK
3759					CALLMONITOR 
3759 cd aa fd			call debug_vector  
375c				endm  
# End of macro CALLMONITOR
375c					endif 
375c					 
375c				FORTH_LOOP_NEXT 
375c cd 7c 22			call macro_forth_loop_next 
375f				endm 
# End of macro FORTH_LOOP_NEXT
375f			 
375f			 
375f					if DEBUG_FORTH_WORDS 
375f eb						ex de,hl 
3760					endif 
3760			 
3760			;	; get DO ptr 
3760			; 
3760					if DEBUG_FORTH_WORDS 
3760						DMARK "LP7" 
3760 f5				push af  
3761 3a 75 37			ld a, (.dmark)  
3764 32 a0 fd			ld (debug_mark),a  
3767 3a 76 37			ld a, (.dmark+1)  
376a 32 a1 fd			ld (debug_mark+1),a  
376d 3a 77 37			ld a, (.dmark+2)  
3770 32 a2 fd			ld (debug_mark+2),a  
3773 18 03			jr .pastdmark  
3775 ..			.dmark: db "LP7"  
3778 f1			.pastdmark: pop af  
3779			endm  
# End of macro DMARK
3779					CALLMONITOR 
3779 cd aa fd			call debug_vector  
377c				endm  
# End of macro CALLMONITOR
377c					endif 
377c				FORTH_RSP_TOS 
377c cd 04 20			call macro_forth_rsp_tos 
377f				endm 
# End of macro FORTH_RSP_TOS
377f			 
377f					if DEBUG_FORTH_WORDS 
377f						DMARK "LP8" 
377f f5				push af  
3780 3a 94 37			ld a, (.dmark)  
3783 32 a0 fd			ld (debug_mark),a  
3786 3a 95 37			ld a, (.dmark+1)  
3789 32 a1 fd			ld (debug_mark+1),a  
378c 3a 96 37			ld a, (.dmark+2)  
378f 32 a2 fd			ld (debug_mark+2),a  
3792 18 03			jr .pastdmark  
3794 ..			.dmark: db "LP8"  
3797 f1			.pastdmark: pop af  
3798			endm  
# End of macro DMARK
3798					CALLMONITOR 
3798 cd aa fd			call debug_vector  
379b				endm  
# End of macro CALLMONITOR
379b					endif 
379b				;push hl 
379b			 
379b				; not going to DO any more 
379b				; get rid of the RSP pointer as DO will add it back in 
379b				;FORTH_RSP_POP 
379b				;pop hl 
379b			 
379b				;ld hl,(cli_ret_sp) 
379b				;ld e, (hl) 
379b				;inc hl 
379b				;ld d, (hl) 
379b				;ex de,hl 
379b 22 f7 f3			ld (os_tok_ptr), hl 
379e					if DEBUG_FORTH_WORDS 
379e						DMARK "LP<" 
379e f5				push af  
379f 3a b3 37			ld a, (.dmark)  
37a2 32 a0 fd			ld (debug_mark),a  
37a5 3a b4 37			ld a, (.dmark+1)  
37a8 32 a1 fd			ld (debug_mark+1),a  
37ab 3a b5 37			ld a, (.dmark+2)  
37ae 32 a2 fd			ld (debug_mark+2),a  
37b1 18 03			jr .pastdmark  
37b3 ..			.dmark: db "LP<"  
37b6 f1			.pastdmark: pop af  
37b7			endm  
# End of macro DMARK
37b7					CALLMONITOR 
37b7 cd aa fd			call debug_vector  
37ba				endm  
# End of macro CALLMONITOR
37ba				endif 
37ba c3 c8 24			jp exec1 
37bd			 
37bd					 
37bd			 
37bd			 
37bd					NEXTW 
37bd c3 37 24			jp macro_next 
37c0				endm 
# End of macro NEXTW
37c0			.I:  
37c0			 
37c0				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
37c0 5e				db WORD_SYS_CORE+74             
37c1 eb 37			dw .DLOOP            
37c3 02				db 1 + 1 
37c4 .. 00			db "I",0              
37c6				endm 
# End of macro CWHEAD
37c6			; | I ( -- ) Current loop counter | DONE 
37c6					if DEBUG_FORTH_WORDS_KEY 
37c6						DMARK "I.." 
37c6 f5				push af  
37c7 3a db 37			ld a, (.dmark)  
37ca 32 a0 fd			ld (debug_mark),a  
37cd 3a dc 37			ld a, (.dmark+1)  
37d0 32 a1 fd			ld (debug_mark+1),a  
37d3 3a dd 37			ld a, (.dmark+2)  
37d6 32 a2 fd			ld (debug_mark+2),a  
37d9 18 03			jr .pastdmark  
37db ..			.dmark: db "I.."  
37de f1			.pastdmark: pop af  
37df			endm  
# End of macro DMARK
37df						CALLMONITOR 
37df cd aa fd			call debug_vector  
37e2				endm  
# End of macro CALLMONITOR
37e2					endif 
37e2			 
37e2 2a 1b f4				ld hl,(os_current_i) 
37e5 cd 46 20				call forth_push_numhl 
37e8			 
37e8					NEXTW 
37e8 c3 37 24			jp macro_next 
37eb				endm 
# End of macro NEXTW
37eb			.DLOOP: 
37eb				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
37eb 5f				db WORD_SYS_CORE+75             
37ec cc 38			dw .REPEAT            
37ee 06				db 5 + 1 
37ef .. 00			db "-LOOP",0              
37f5				endm 
# End of macro CWHEAD
37f5			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
37f5				; pop tos as current loop count to hl 
37f5					if DEBUG_FORTH_WORDS_KEY 
37f5						DMARK "-LP" 
37f5 f5				push af  
37f6 3a 0a 38			ld a, (.dmark)  
37f9 32 a0 fd			ld (debug_mark),a  
37fc 3a 0b 38			ld a, (.dmark+1)  
37ff 32 a1 fd			ld (debug_mark+1),a  
3802 3a 0c 38			ld a, (.dmark+2)  
3805 32 a2 fd			ld (debug_mark+2),a  
3808 18 03			jr .pastdmark  
380a ..			.dmark: db "-LP"  
380d f1			.pastdmark: pop af  
380e			endm  
# End of macro DMARK
380e						CALLMONITOR 
380e cd aa fd			call debug_vector  
3811				endm  
# End of macro CALLMONITOR
3811					endif 
3811			 
3811				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3811			 
3811				FORTH_LOOP_TOS 
3811 cd af 22			call macro_forth_loop_tos 
3814				endm 
# End of macro FORTH_LOOP_TOS
3814 e5				push hl 
3815			 
3815					if DEBUG_FORTH_WORDS 
3815						DMARK "-LP" 
3815 f5				push af  
3816 3a 2a 38			ld a, (.dmark)  
3819 32 a0 fd			ld (debug_mark),a  
381c 3a 2b 38			ld a, (.dmark+1)  
381f 32 a1 fd			ld (debug_mark+1),a  
3822 3a 2c 38			ld a, (.dmark+2)  
3825 32 a2 fd			ld (debug_mark+2),a  
3828 18 03			jr .pastdmark  
382a ..			.dmark: db "-LP"  
382d f1			.pastdmark: pop af  
382e			endm  
# End of macro DMARK
382e						CALLMONITOR 
382e cd aa fd			call debug_vector  
3831				endm  
# End of macro CALLMONITOR
3831					endif 
3831				; next item on the stack is the limit. get it 
3831			 
3831			 
3831				FORTH_LOOP_POP 
3831 cd b9 22			call macro_forth_loop_pop 
3834				endm 
# End of macro FORTH_LOOP_POP
3834			 
3834				FORTH_LOOP_TOS 
3834 cd af 22			call macro_forth_loop_tos 
3837				endm 
# End of macro FORTH_LOOP_TOS
3837			 
3837 d1				pop de		 ; de = i, hl = limit 
3838			 
3838					if DEBUG_FORTH_WORDS 
3838						DMARK "-L1" 
3838 f5				push af  
3839 3a 4d 38			ld a, (.dmark)  
383c 32 a0 fd			ld (debug_mark),a  
383f 3a 4e 38			ld a, (.dmark+1)  
3842 32 a1 fd			ld (debug_mark+1),a  
3845 3a 4f 38			ld a, (.dmark+2)  
3848 32 a2 fd			ld (debug_mark+2),a  
384b 18 03			jr .pastdmark  
384d ..			.dmark: db "-L1"  
3850 f1			.pastdmark: pop af  
3851			endm  
# End of macro DMARK
3851						CALLMONITOR 
3851 cd aa fd			call debug_vector  
3854				endm  
# End of macro CALLMONITOR
3854					endif 
3854			 
3854				; go back to previous word 
3854			 
3854 d5				push de    ; save I for inc later 
3855			 
3855			 
3855				; get limit 
3855				;  is I at limit? 
3855			 
3855			 
3855					if DEBUG_FORTH_WORDS 
3855						DMARK "-L1" 
3855 f5				push af  
3856 3a 6a 38			ld a, (.dmark)  
3859 32 a0 fd			ld (debug_mark),a  
385c 3a 6b 38			ld a, (.dmark+1)  
385f 32 a1 fd			ld (debug_mark+1),a  
3862 3a 6c 38			ld a, (.dmark+2)  
3865 32 a2 fd			ld (debug_mark+2),a  
3868 18 03			jr .pastdmark  
386a ..			.dmark: db "-L1"  
386d f1			.pastdmark: pop af  
386e			endm  
# End of macro DMARK
386e						CALLMONITOR 
386e cd aa fd			call debug_vector  
3871				endm  
# End of macro CALLMONITOR
3871					endif 
3871			 
3871 ed 52			sbc hl, de 
3873			 
3873			 
3873				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3873			 
3873 20 26				jr nz, .mloopnotdone 
3875			 
3875 e1				pop hl   ; get rid of saved I 
3876				FORTH_LOOP_POP     ; get rid of limit 
3876 cd b9 22			call macro_forth_loop_pop 
3879				endm 
# End of macro FORTH_LOOP_POP
3879			 
3879				FORTH_RSP_POP     ; get rid of DO ptr 
3879 cd 0e 20			call macro_forth_rsp_pop 
387c				endm 
# End of macro FORTH_RSP_POP
387c			 
387c			if DEBUG_FORTH_WORDS 
387c						DMARK "-L>" 
387c f5				push af  
387d 3a 91 38			ld a, (.dmark)  
3880 32 a0 fd			ld (debug_mark),a  
3883 3a 92 38			ld a, (.dmark+1)  
3886 32 a1 fd			ld (debug_mark+1),a  
3889 3a 93 38			ld a, (.dmark+2)  
388c 32 a2 fd			ld (debug_mark+2),a  
388f 18 03			jr .pastdmark  
3891 ..			.dmark: db "-L>"  
3894 f1			.pastdmark: pop af  
3895			endm  
# End of macro DMARK
3895				CALLMONITOR 
3895 cd aa fd			call debug_vector  
3898				endm  
# End of macro CALLMONITOR
3898			endif 
3898			 
3898					NEXTW 
3898 c3 37 24			jp macro_next 
389b				endm 
# End of macro NEXTW
389b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
389b			 
389b			.mloopnotdone: 
389b			 
389b e1				pop hl    ; get I 
389c 2b				dec hl 
389d			 
389d			   	; save new I 
389d			 
389d			 
389d					; set I counter 
389d			 
389d 22 1b f4				ld (os_current_i), hl 
38a0			 
38a0					 
38a0				FORTH_LOOP_NEXT 
38a0 cd 7c 22			call macro_forth_loop_next 
38a3				endm 
# End of macro FORTH_LOOP_NEXT
38a3			 
38a3			 
38a3					if DEBUG_FORTH_WORDS 
38a3 eb						ex de,hl 
38a4					endif 
38a4			 
38a4			;	; get DO ptr 
38a4			; 
38a4				FORTH_RSP_TOS 
38a4 cd 04 20			call macro_forth_rsp_tos 
38a7				endm 
# End of macro FORTH_RSP_TOS
38a7			 
38a7				;push hl 
38a7			 
38a7				; not going to DO any more 
38a7				; get rid of the RSP pointer as DO will add it back in 
38a7				;FORTH_RSP_POP 
38a7				;pop hl 
38a7			 
38a7			 
38a7 22 f7 f3			ld (os_tok_ptr), hl 
38aa					if DEBUG_FORTH_WORDS 
38aa						DMARK "-L<" 
38aa f5				push af  
38ab 3a bf 38			ld a, (.dmark)  
38ae 32 a0 fd			ld (debug_mark),a  
38b1 3a c0 38			ld a, (.dmark+1)  
38b4 32 a1 fd			ld (debug_mark+1),a  
38b7 3a c1 38			ld a, (.dmark+2)  
38ba 32 a2 fd			ld (debug_mark+2),a  
38bd 18 03			jr .pastdmark  
38bf ..			.dmark: db "-L<"  
38c2 f1			.pastdmark: pop af  
38c3			endm  
# End of macro DMARK
38c3					CALLMONITOR 
38c3 cd aa fd			call debug_vector  
38c6				endm  
# End of macro CALLMONITOR
38c6				endif 
38c6 c3 c8 24			jp exec1 
38c9			 
38c9					 
38c9			 
38c9			 
38c9			 
38c9				NEXTW 
38c9 c3 37 24			jp macro_next 
38cc				endm 
# End of macro NEXTW
38cc			 
38cc			 
38cc			 
38cc			 
38cc			.REPEAT: 
38cc				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
38cc 71				db WORD_SYS_CORE+93             
38cd 1f 39			dw .UNTIL            
38cf 06				db 5 + 1 
38d0 .. 00			db "REPEAT",0              
38d7				endm 
# End of macro CWHEAD
38d7			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
38d7			;  push pc to rsp stack past the REPEAT 
38d7					if DEBUG_FORTH_WORDS_KEY 
38d7						DMARK "REP" 
38d7 f5				push af  
38d8 3a ec 38			ld a, (.dmark)  
38db 32 a0 fd			ld (debug_mark),a  
38de 3a ed 38			ld a, (.dmark+1)  
38e1 32 a1 fd			ld (debug_mark+1),a  
38e4 3a ee 38			ld a, (.dmark+2)  
38e7 32 a2 fd			ld (debug_mark+2),a  
38ea 18 03			jr .pastdmark  
38ec ..			.dmark: db "REP"  
38ef f1			.pastdmark: pop af  
38f0			endm  
# End of macro DMARK
38f0						CALLMONITOR 
38f0 cd aa fd			call debug_vector  
38f3				endm  
# End of macro CALLMONITOR
38f3					endif 
38f3			 
38f3 2a f7 f3				ld hl, (os_tok_ptr) 
38f6 23					inc hl   ; R 
38f7 23					inc hl  ; E 
38f8 23					inc hl   ; P 
38f9 23					inc hl   ; E 
38fa 23					inc hl   ; A 
38fb 23					inc hl   ; T 
38fc 23					inc hl   ; zero 
38fd					FORTH_RSP_NEXT 
38fd cd ed 1f			call macro_forth_rsp_next 
3900				endm 
# End of macro FORTH_RSP_NEXT
3900			 
3900			 
3900					if DEBUG_FORTH_WORDS 
3900						DMARK "REP" 
3900 f5				push af  
3901 3a 15 39			ld a, (.dmark)  
3904 32 a0 fd			ld (debug_mark),a  
3907 3a 16 39			ld a, (.dmark+1)  
390a 32 a1 fd			ld (debug_mark+1),a  
390d 3a 17 39			ld a, (.dmark+2)  
3910 32 a2 fd			ld (debug_mark+2),a  
3913 18 03			jr .pastdmark  
3915 ..			.dmark: db "REP"  
3918 f1			.pastdmark: pop af  
3919			endm  
# End of macro DMARK
3919						;pop bc    ; TODO BUG ?????? what is this for???? 
3919						CALLMONITOR 
3919 cd aa fd			call debug_vector  
391c				endm  
# End of macro CALLMONITOR
391c					endif 
391c			 
391c					NEXTW 
391c c3 37 24			jp macro_next 
391f				endm 
# End of macro NEXTW
391f			;	       NEXTW 
391f			 
391f			.UNTIL: 
391f				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
391f 72				db WORD_SYS_CORE+94             
3920 b6 39			dw .ENDFLOW            
3922 06				db 5 + 1 
3923 .. 00			db "UNTIL",0              
3929				endm 
# End of macro CWHEAD
3929			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3929			 
3929				; pop tos as check 
3929			 
3929				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3929			 
3929				FORTH_DSP_VALUEHL 
3929 cd 4b 22			call macro_dsp_valuehl 
392c				endm 
# End of macro FORTH_DSP_VALUEHL
392c			 
392c					if DEBUG_FORTH_WORDS_KEY 
392c						DMARK "UNT" 
392c f5				push af  
392d 3a 41 39			ld a, (.dmark)  
3930 32 a0 fd			ld (debug_mark),a  
3933 3a 42 39			ld a, (.dmark+1)  
3936 32 a1 fd			ld (debug_mark+1),a  
3939 3a 43 39			ld a, (.dmark+2)  
393c 32 a2 fd			ld (debug_mark+2),a  
393f 18 03			jr .pastdmark  
3941 ..			.dmark: db "UNT"  
3944 f1			.pastdmark: pop af  
3945			endm  
# End of macro DMARK
3945						CALLMONITOR 
3945 cd aa fd			call debug_vector  
3948				endm  
# End of macro CALLMONITOR
3948					endif 
3948			 
3948			;	push hl 
3948				FORTH_DSP_POP 
3948 cd 03 23			call macro_forth_dsp_pop 
394b				endm 
# End of macro FORTH_DSP_POP
394b			 
394b			;	pop hl 
394b			 
394b				; test if true 
394b			 
394b cd 07 10			call ishlzero 
394e			;	ld a,l 
394e			;	add h 
394e			; 
394e			;	cp 0 
394e			 
394e 20 3e			jr nz, .untilnotdone 
3950			 
3950					if DEBUG_FORTH_WORDS 
3950						DMARK "UNf" 
3950 f5				push af  
3951 3a 65 39			ld a, (.dmark)  
3954 32 a0 fd			ld (debug_mark),a  
3957 3a 66 39			ld a, (.dmark+1)  
395a 32 a1 fd			ld (debug_mark+1),a  
395d 3a 67 39			ld a, (.dmark+2)  
3960 32 a2 fd			ld (debug_mark+2),a  
3963 18 03			jr .pastdmark  
3965 ..			.dmark: db "UNf"  
3968 f1			.pastdmark: pop af  
3969			endm  
# End of macro DMARK
3969						CALLMONITOR 
3969 cd aa fd			call debug_vector  
396c				endm  
# End of macro CALLMONITOR
396c					endif 
396c			 
396c			 
396c			 
396c				FORTH_RSP_POP     ; get rid of DO ptr 
396c cd 0e 20			call macro_forth_rsp_pop 
396f				endm 
# End of macro FORTH_RSP_POP
396f			 
396f			if DEBUG_FORTH_WORDS 
396f						DMARK "UN>" 
396f f5				push af  
3970 3a 84 39			ld a, (.dmark)  
3973 32 a0 fd			ld (debug_mark),a  
3976 3a 85 39			ld a, (.dmark+1)  
3979 32 a1 fd			ld (debug_mark+1),a  
397c 3a 86 39			ld a, (.dmark+2)  
397f 32 a2 fd			ld (debug_mark+2),a  
3982 18 03			jr .pastdmark  
3984 ..			.dmark: db "UN>"  
3987 f1			.pastdmark: pop af  
3988			endm  
# End of macro DMARK
3988				CALLMONITOR 
3988 cd aa fd			call debug_vector  
398b				endm  
# End of macro CALLMONITOR
398b			endif 
398b			 
398b					NEXTW 
398b c3 37 24			jp macro_next 
398e				endm 
# End of macro NEXTW
398e				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
398e			 
398e			.untilnotdone: 
398e			 
398e			 
398e			;	; get DO ptr 
398e			; 
398e				FORTH_RSP_TOS 
398e cd 04 20			call macro_forth_rsp_tos 
3991				endm 
# End of macro FORTH_RSP_TOS
3991			 
3991				;push hl 
3991			 
3991				; not going to DO any more 
3991				; get rid of the RSP pointer as DO will add it back in 
3991				;FORTH_RSP_POP 
3991				;pop hl 
3991			 
3991			 
3991 22 f7 f3			ld (os_tok_ptr), hl 
3994					if DEBUG_FORTH_WORDS 
3994						DMARK "UN<" 
3994 f5				push af  
3995 3a a9 39			ld a, (.dmark)  
3998 32 a0 fd			ld (debug_mark),a  
399b 3a aa 39			ld a, (.dmark+1)  
399e 32 a1 fd			ld (debug_mark+1),a  
39a1 3a ab 39			ld a, (.dmark+2)  
39a4 32 a2 fd			ld (debug_mark+2),a  
39a7 18 03			jr .pastdmark  
39a9 ..			.dmark: db "UN<"  
39ac f1			.pastdmark: pop af  
39ad			endm  
# End of macro DMARK
39ad					CALLMONITOR 
39ad cd aa fd			call debug_vector  
39b0				endm  
# End of macro CALLMONITOR
39b0				endif 
39b0 c3 c8 24			jp exec1 
39b3			 
39b3					 
39b3			 
39b3			 
39b3					NEXTW 
39b3 c3 37 24			jp macro_next 
39b6				endm 
# End of macro NEXTW
39b6			 
39b6			 
39b6			.ENDFLOW: 
39b6			 
39b6			; eof 
39b6			 
# End of file forth_words_flow.asm
39b6			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
39b6			include "forth_words_logic.asm" 
39b6			 
39b6			; | ## Logic Words 
39b6			 
39b6			.NOT: 
39b6				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
39b6 2d				db WORD_SYS_CORE+25             
39b7 fe 39			dw .IS            
39b9 04				db 3 + 1 
39ba .. 00			db "NOT",0              
39be				endm 
# End of macro CWHEAD
39be			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
39be					if DEBUG_FORTH_WORDS_KEY 
39be						DMARK "NOT" 
39be f5				push af  
39bf 3a d3 39			ld a, (.dmark)  
39c2 32 a0 fd			ld (debug_mark),a  
39c5 3a d4 39			ld a, (.dmark+1)  
39c8 32 a1 fd			ld (debug_mark+1),a  
39cb 3a d5 39			ld a, (.dmark+2)  
39ce 32 a2 fd			ld (debug_mark+2),a  
39d1 18 03			jr .pastdmark  
39d3 ..			.dmark: db "NOT"  
39d6 f1			.pastdmark: pop af  
39d7			endm  
# End of macro DMARK
39d7						CALLMONITOR 
39d7 cd aa fd			call debug_vector  
39da				endm  
# End of macro CALLMONITOR
39da					endif 
39da					FORTH_DSP 
39da cd 11 22			call macro_forth_dsp 
39dd				endm 
# End of macro FORTH_DSP
39dd 7e					ld a,(hl)	; get type of value on TOS 
39de fe 02				cp DS_TYPE_INUM  
39e0 28 03				jr z, .noti 
39e2					NEXTW 
39e2 c3 37 24			jp macro_next 
39e5				endm 
# End of macro NEXTW
39e5			.noti:          FORTH_DSP_VALUEHL 
39e5 cd 4b 22			call macro_dsp_valuehl 
39e8				endm 
# End of macro FORTH_DSP_VALUEHL
39e8			;		push hl 
39e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39e8 cd 03 23			call macro_forth_dsp_pop 
39eb				endm 
# End of macro FORTH_DSP_POP
39eb			;		pop hl 
39eb 3e 00				ld a,0 
39ed bd					cp l 
39ee 28 04				jr z, .not2t 
39f0 2e 00				ld l, 0 
39f2 18 02				jr .notip 
39f4			 
39f4 2e ff		.not2t:		ld l, 255 
39f6			 
39f6 26 00		.notip:		ld h, 0	 
39f8			 
39f8 cd 46 20				call forth_push_numhl 
39fb					NEXTW 
39fb c3 37 24			jp macro_next 
39fe				endm 
# End of macro NEXTW
39fe			 
39fe			.IS: 
39fe				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
39fe 2d				db WORD_SYS_CORE+25             
39ff 24 3a			dw .LZERO            
3a01 03				db 2 + 1 
3a02 .. 00			db "IS",0              
3a05				endm 
# End of macro CWHEAD
3a05			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3a05					if DEBUG_FORTH_WORDS_KEY 
3a05						DMARK "IS." 
3a05 f5				push af  
3a06 3a 1a 3a			ld a, (.dmark)  
3a09 32 a0 fd			ld (debug_mark),a  
3a0c 3a 1b 3a			ld a, (.dmark+1)  
3a0f 32 a1 fd			ld (debug_mark+1),a  
3a12 3a 1c 3a			ld a, (.dmark+2)  
3a15 32 a2 fd			ld (debug_mark+2),a  
3a18 18 03			jr .pastdmark  
3a1a ..			.dmark: db "IS."  
3a1d f1			.pastdmark: pop af  
3a1e			endm  
# End of macro DMARK
3a1e						CALLMONITOR 
3a1e cd aa fd			call debug_vector  
3a21				endm  
# End of macro CALLMONITOR
3a21					endif 
3a21					NEXTW 
3a21 c3 37 24			jp macro_next 
3a24				endm 
# End of macro NEXTW
3a24			.LZERO: 
3a24				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3a24 2d				db WORD_SYS_CORE+25             
3a25 2e 3a			dw .TZERO            
3a27 03				db 2 + 1 
3a28 .. 00			db "0<",0              
3a2b				endm 
# End of macro CWHEAD
3a2b			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3a2b					NEXTW 
3a2b c3 37 24			jp macro_next 
3a2e				endm 
# End of macro NEXTW
3a2e			.TZERO: 
3a2e				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3a2e 2e				db WORD_SYS_CORE+26             
3a2f 75 3a			dw .LESS            
3a31 03				db 2 + 1 
3a32 .. 00			db "0=",0              
3a35				endm 
# End of macro CWHEAD
3a35			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3a35				; TODO add floating point number detection 
3a35					;v5 FORTH_DSP_VALUE 
3a35					if DEBUG_FORTH_WORDS_KEY 
3a35						DMARK "0=." 
3a35 f5				push af  
3a36 3a 4a 3a			ld a, (.dmark)  
3a39 32 a0 fd			ld (debug_mark),a  
3a3c 3a 4b 3a			ld a, (.dmark+1)  
3a3f 32 a1 fd			ld (debug_mark+1),a  
3a42 3a 4c 3a			ld a, (.dmark+2)  
3a45 32 a2 fd			ld (debug_mark+2),a  
3a48 18 03			jr .pastdmark  
3a4a ..			.dmark: db "0=."  
3a4d f1			.pastdmark: pop af  
3a4e			endm  
# End of macro DMARK
3a4e						CALLMONITOR 
3a4e cd aa fd			call debug_vector  
3a51				endm  
# End of macro CALLMONITOR
3a51					endif 
3a51					FORTH_DSP 
3a51 cd 11 22			call macro_forth_dsp 
3a54				endm 
# End of macro FORTH_DSP
3a54 7e					ld a,(hl)	; get type of value on TOS 
3a55 fe 02				cp DS_TYPE_INUM  
3a57 28 00				jr z, .tz_inum 
3a59			 
3a59				if FORTH_ENABLE_FLOATMATH 
3a59					jr .tz_done 
3a59			 
3a59				endif 
3a59					 
3a59			 
3a59			.tz_inum: 
3a59					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a59 cd 4b 22			call macro_dsp_valuehl 
3a5c				endm 
# End of macro FORTH_DSP_VALUEHL
3a5c			 
3a5c			;		push hl 
3a5c			 
3a5c					; destroy value TOS 
3a5c			 
3a5c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a5c cd 03 23			call macro_forth_dsp_pop 
3a5f				endm 
# End of macro FORTH_DSP_POP
3a5f			 
3a5f			;		pop hl 
3a5f			 
3a5f 3e 00				ld a,0 
3a61			 
3a61 bd					cp l 
3a62 20 08				jr nz, .tz_notzero 
3a64			 
3a64 bc					cp h 
3a65			 
3a65 20 05				jr nz, .tz_notzero 
3a67			 
3a67			 
3a67 21 01 00				ld hl, FORTH_TRUE 
3a6a 18 03				jr .tz_done 
3a6c			 
3a6c 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3a6f			 
3a6f					; push value back onto stack for another op etc 
3a6f			 
3a6f			.tz_done: 
3a6f cd 46 20				call forth_push_numhl 
3a72			 
3a72					NEXTW 
3a72 c3 37 24			jp macro_next 
3a75				endm 
# End of macro NEXTW
3a75			.LESS: 
3a75				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3a75 2f				db WORD_SYS_CORE+27             
3a76 de 3a			dw .GT            
3a78 02				db 1 + 1 
3a79 .. 00			db "<",0              
3a7b				endm 
# End of macro CWHEAD
3a7b			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3a7b				; TODO add floating point number detection 
3a7b					if DEBUG_FORTH_WORDS_KEY 
3a7b						DMARK "LES" 
3a7b f5				push af  
3a7c 3a 90 3a			ld a, (.dmark)  
3a7f 32 a0 fd			ld (debug_mark),a  
3a82 3a 91 3a			ld a, (.dmark+1)  
3a85 32 a1 fd			ld (debug_mark+1),a  
3a88 3a 92 3a			ld a, (.dmark+2)  
3a8b 32 a2 fd			ld (debug_mark+2),a  
3a8e 18 03			jr .pastdmark  
3a90 ..			.dmark: db "LES"  
3a93 f1			.pastdmark: pop af  
3a94			endm  
# End of macro DMARK
3a94						CALLMONITOR 
3a94 cd aa fd			call debug_vector  
3a97				endm  
# End of macro CALLMONITOR
3a97					endif 
3a97					FORTH_DSP 
3a97 cd 11 22			call macro_forth_dsp 
3a9a				endm 
# End of macro FORTH_DSP
3a9a					;v5 FORTH_DSP_VALUE 
3a9a 7e					ld a,(hl)	; get type of value on TOS 
3a9b fe 02				cp DS_TYPE_INUM  
3a9d 28 00				jr z, .less_inum 
3a9f			 
3a9f				if FORTH_ENABLE_FLOATMATH 
3a9f					jr .less_done 
3a9f			 
3a9f				endif 
3a9f					 
3a9f			 
3a9f			.less_inum: 
3a9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a9f cd 4b 22			call macro_dsp_valuehl 
3aa2				endm 
# End of macro FORTH_DSP_VALUEHL
3aa2			 
3aa2 e5					push hl  ; u2 
3aa3			 
3aa3					; destroy value TOS 
3aa3			 
3aa3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa3 cd 03 23			call macro_forth_dsp_pop 
3aa6				endm 
# End of macro FORTH_DSP_POP
3aa6			 
3aa6			 
3aa6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa6 cd 4b 22			call macro_dsp_valuehl 
3aa9				endm 
# End of macro FORTH_DSP_VALUEHL
3aa9			 
3aa9 e5					push hl    ; u1 
3aaa			 
3aaa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aaa cd 03 23			call macro_forth_dsp_pop 
3aad				endm 
# End of macro FORTH_DSP_POP
3aad			 
3aad			 
3aad b7			 or a      ;clear carry flag 
3aae 01 00 00		 ld bc, FORTH_FALSE 
3ab1 e1			  pop hl    ; u1 
3ab2 d1			  pop de    ; u2 
3ab3 ed 52		  sbc hl,de 
3ab5 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3ab7			 
3ab7 01 01 00		 ld bc, FORTH_TRUE 
3aba			.lscont:  
3aba c5					push bc 
3abb e1					pop hl 
3abc			 
3abc					if DEBUG_FORTH_WORDS 
3abc						DMARK "LT1" 
3abc f5				push af  
3abd 3a d1 3a			ld a, (.dmark)  
3ac0 32 a0 fd			ld (debug_mark),a  
3ac3 3a d2 3a			ld a, (.dmark+1)  
3ac6 32 a1 fd			ld (debug_mark+1),a  
3ac9 3a d3 3a			ld a, (.dmark+2)  
3acc 32 a2 fd			ld (debug_mark+2),a  
3acf 18 03			jr .pastdmark  
3ad1 ..			.dmark: db "LT1"  
3ad4 f1			.pastdmark: pop af  
3ad5			endm  
# End of macro DMARK
3ad5						CALLMONITOR 
3ad5 cd aa fd			call debug_vector  
3ad8				endm  
# End of macro CALLMONITOR
3ad8					endif 
3ad8 cd 46 20				call forth_push_numhl 
3adb			 
3adb					NEXTW 
3adb c3 37 24			jp macro_next 
3ade				endm 
# End of macro NEXTW
3ade			.GT: 
3ade				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3ade 30				db WORD_SYS_CORE+28             
3adf 47 3b			dw .EQUAL            
3ae1 02				db 1 + 1 
3ae2 .. 00			db ">",0              
3ae4				endm 
# End of macro CWHEAD
3ae4			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3ae4				; TODO add floating point number detection 
3ae4					if DEBUG_FORTH_WORDS_KEY 
3ae4						DMARK "GRT" 
3ae4 f5				push af  
3ae5 3a f9 3a			ld a, (.dmark)  
3ae8 32 a0 fd			ld (debug_mark),a  
3aeb 3a fa 3a			ld a, (.dmark+1)  
3aee 32 a1 fd			ld (debug_mark+1),a  
3af1 3a fb 3a			ld a, (.dmark+2)  
3af4 32 a2 fd			ld (debug_mark+2),a  
3af7 18 03			jr .pastdmark  
3af9 ..			.dmark: db "GRT"  
3afc f1			.pastdmark: pop af  
3afd			endm  
# End of macro DMARK
3afd						CALLMONITOR 
3afd cd aa fd			call debug_vector  
3b00				endm  
# End of macro CALLMONITOR
3b00					endif 
3b00					FORTH_DSP 
3b00 cd 11 22			call macro_forth_dsp 
3b03				endm 
# End of macro FORTH_DSP
3b03					;FORTH_DSP_VALUE 
3b03 7e					ld a,(hl)	; get type of value on TOS 
3b04 fe 02				cp DS_TYPE_INUM  
3b06 28 00				jr z, .gt_inum 
3b08			 
3b08				if FORTH_ENABLE_FLOATMATH 
3b08					jr .gt_done 
3b08			 
3b08				endif 
3b08					 
3b08			 
3b08			.gt_inum: 
3b08					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b08 cd 4b 22			call macro_dsp_valuehl 
3b0b				endm 
# End of macro FORTH_DSP_VALUEHL
3b0b			 
3b0b e5					push hl  ; u2 
3b0c			 
3b0c					; destroy value TOS 
3b0c			 
3b0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b0c cd 03 23			call macro_forth_dsp_pop 
3b0f				endm 
# End of macro FORTH_DSP_POP
3b0f			 
3b0f			 
3b0f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b0f cd 4b 22			call macro_dsp_valuehl 
3b12				endm 
# End of macro FORTH_DSP_VALUEHL
3b12			 
3b12 e5					push hl    ; u1 
3b13			 
3b13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b13 cd 03 23			call macro_forth_dsp_pop 
3b16				endm 
# End of macro FORTH_DSP_POP
3b16			 
3b16			 
3b16 b7			 or a      ;clear carry flag 
3b17 01 00 00		 ld bc, FORTH_FALSE 
3b1a e1			  pop hl    ; u1 
3b1b d1			  pop de    ; u2 
3b1c ed 52		  sbc hl,de 
3b1e 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3b20			 
3b20 01 01 00		 ld bc, FORTH_TRUE 
3b23			.gtcont:  
3b23 c5					push bc 
3b24 e1					pop hl 
3b25			 
3b25					if DEBUG_FORTH_WORDS 
3b25						DMARK "GT1" 
3b25 f5				push af  
3b26 3a 3a 3b			ld a, (.dmark)  
3b29 32 a0 fd			ld (debug_mark),a  
3b2c 3a 3b 3b			ld a, (.dmark+1)  
3b2f 32 a1 fd			ld (debug_mark+1),a  
3b32 3a 3c 3b			ld a, (.dmark+2)  
3b35 32 a2 fd			ld (debug_mark+2),a  
3b38 18 03			jr .pastdmark  
3b3a ..			.dmark: db "GT1"  
3b3d f1			.pastdmark: pop af  
3b3e			endm  
# End of macro DMARK
3b3e						CALLMONITOR 
3b3e cd aa fd			call debug_vector  
3b41				endm  
# End of macro CALLMONITOR
3b41					endif 
3b41 cd 46 20				call forth_push_numhl 
3b44			 
3b44					NEXTW 
3b44 c3 37 24			jp macro_next 
3b47				endm 
# End of macro NEXTW
3b47			.EQUAL: 
3b47				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3b47 31				db WORD_SYS_CORE+29             
3b48 b2 3b			dw .ENDLOGIC            
3b4a 02				db 1 + 1 
3b4b .. 00			db "=",0              
3b4d				endm 
# End of macro CWHEAD
3b4d			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3b4d				; TODO add floating point number detection 
3b4d					if DEBUG_FORTH_WORDS_KEY 
3b4d						DMARK "EQ." 
3b4d f5				push af  
3b4e 3a 62 3b			ld a, (.dmark)  
3b51 32 a0 fd			ld (debug_mark),a  
3b54 3a 63 3b			ld a, (.dmark+1)  
3b57 32 a1 fd			ld (debug_mark+1),a  
3b5a 3a 64 3b			ld a, (.dmark+2)  
3b5d 32 a2 fd			ld (debug_mark+2),a  
3b60 18 03			jr .pastdmark  
3b62 ..			.dmark: db "EQ."  
3b65 f1			.pastdmark: pop af  
3b66			endm  
# End of macro DMARK
3b66						CALLMONITOR 
3b66 cd aa fd			call debug_vector  
3b69				endm  
# End of macro CALLMONITOR
3b69					endif 
3b69					FORTH_DSP 
3b69 cd 11 22			call macro_forth_dsp 
3b6c				endm 
# End of macro FORTH_DSP
3b6c					;v5 FORTH_DSP_VALUE 
3b6c 7e					ld a,(hl)	; get type of value on TOS 
3b6d fe 02				cp DS_TYPE_INUM  
3b6f 28 00				jr z, .eq_inum 
3b71			 
3b71				if FORTH_ENABLE_FLOATMATH 
3b71					jr .eq_done 
3b71			 
3b71				endif 
3b71					 
3b71			 
3b71			.eq_inum: 
3b71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b71 cd 4b 22			call macro_dsp_valuehl 
3b74				endm 
# End of macro FORTH_DSP_VALUEHL
3b74			 
3b74 e5					push hl 
3b75			 
3b75					; destroy value TOS 
3b75			 
3b75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b75 cd 03 23			call macro_forth_dsp_pop 
3b78				endm 
# End of macro FORTH_DSP_POP
3b78			 
3b78			 
3b78					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b78 cd 4b 22			call macro_dsp_valuehl 
3b7b				endm 
# End of macro FORTH_DSP_VALUEHL
3b7b			 
3b7b					; one value on hl get other one back 
3b7b			 
3b7b e5					push hl 
3b7c			 
3b7c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b7c cd 03 23			call macro_forth_dsp_pop 
3b7f				endm 
# End of macro FORTH_DSP_POP
3b7f			 
3b7f 0e 00				ld c, FORTH_FALSE 
3b81			 
3b81 e1					pop hl 
3b82 d1					pop de 
3b83			 
3b83 7b					ld a, e 
3b84 bd					cp l 
3b85			 
3b85 20 06				jr nz, .eq_done 
3b87			 
3b87 7a					ld a, d 
3b88 bc					cp h 
3b89			 
3b89 20 02				jr nz, .eq_done 
3b8b			 
3b8b 0e 01				ld c, FORTH_TRUE 
3b8d					 
3b8d			 
3b8d			 
3b8d			.eq_done: 
3b8d			 
3b8d					; TODO push value back onto stack for another op etc 
3b8d			 
3b8d 26 00				ld h, 0 
3b8f 69					ld l, c 
3b90					if DEBUG_FORTH_WORDS 
3b90						DMARK "EQ1" 
3b90 f5				push af  
3b91 3a a5 3b			ld a, (.dmark)  
3b94 32 a0 fd			ld (debug_mark),a  
3b97 3a a6 3b			ld a, (.dmark+1)  
3b9a 32 a1 fd			ld (debug_mark+1),a  
3b9d 3a a7 3b			ld a, (.dmark+2)  
3ba0 32 a2 fd			ld (debug_mark+2),a  
3ba3 18 03			jr .pastdmark  
3ba5 ..			.dmark: db "EQ1"  
3ba8 f1			.pastdmark: pop af  
3ba9			endm  
# End of macro DMARK
3ba9						CALLMONITOR 
3ba9 cd aa fd			call debug_vector  
3bac				endm  
# End of macro CALLMONITOR
3bac					endif 
3bac cd 46 20				call forth_push_numhl 
3baf			 
3baf					NEXTW 
3baf c3 37 24			jp macro_next 
3bb2				endm 
# End of macro NEXTW
3bb2			 
3bb2			 
3bb2			.ENDLOGIC: 
3bb2			; eof 
3bb2			 
3bb2			 
# End of file forth_words_logic.asm
3bb2			include "forth_words_maths.asm" 
3bb2			 
3bb2			; | ## Maths Words 
3bb2			 
3bb2			.PLUS:	 
3bb2				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3bb2 15				db WORD_SYS_CORE+1             
3bb3 10 3c			dw .NEG            
3bb5 02				db 1 + 1 
3bb6 .. 00			db "+",0              
3bb8				endm 
# End of macro CWHEAD
3bb8			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3bb8					if DEBUG_FORTH_WORDS_KEY 
3bb8						DMARK "PLU" 
3bb8 f5				push af  
3bb9 3a cd 3b			ld a, (.dmark)  
3bbc 32 a0 fd			ld (debug_mark),a  
3bbf 3a ce 3b			ld a, (.dmark+1)  
3bc2 32 a1 fd			ld (debug_mark+1),a  
3bc5 3a cf 3b			ld a, (.dmark+2)  
3bc8 32 a2 fd			ld (debug_mark+2),a  
3bcb 18 03			jr .pastdmark  
3bcd ..			.dmark: db "PLU"  
3bd0 f1			.pastdmark: pop af  
3bd1			endm  
# End of macro DMARK
3bd1						CALLMONITOR 
3bd1 cd aa fd			call debug_vector  
3bd4				endm  
# End of macro CALLMONITOR
3bd4					endif 
3bd4					; add top two values and push back result 
3bd4			 
3bd4					;for v5 FORTH_DSP_VALUE 
3bd4					FORTH_DSP 
3bd4 cd 11 22			call macro_forth_dsp 
3bd7				endm 
# End of macro FORTH_DSP
3bd7 7e					ld a,(hl)	; get type of value on TOS 
3bd8 fe 02				cp DS_TYPE_INUM  
3bda 28 03				jr z, .dot_inum 
3bdc			 
3bdc					NEXTW 
3bdc c3 37 24			jp macro_next 
3bdf				endm 
# End of macro NEXTW
3bdf			 
3bdf			; float maths 
3bdf			 
3bdf				if FORTH_ENABLE_FLOATMATH 
3bdf						inc hl      ; now at start of numeric as string 
3bdf			 
3bdf					if DEBUG_FORTH_MATHS 
3bdf						DMARK "ADD" 
3bdf				CALLMONITOR 
3bdf					endif 
3bdf			 
3bdf					;ld ix, hl 
3bdf					call CON 
3bdf			 
3bdf			 
3bdf					push hl 
3bdf					 
3bdf					 
3bdf			 
3bdf						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3bdf			 
3bdf					; get next number 
3bdf			 
3bdf						FORTH_DSP_VALUE 
3bdf			 
3bdf						inc hl      ; now at start of numeric as string 
3bdf			 
3bdf					;ld ix, hl 
3bdf					call CON 
3bdf			 
3bdf					push hl 
3bdf			 
3bdf			 
3bdf						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bdf			 
3bdf						; TODO do add 
3bdf			 
3bdf						call IADD 
3bdf			 
3bdf						; TODO get result back as ascii 
3bdf			 
3bdf						; TODO push result  
3bdf			 
3bdf			 
3bdf			 
3bdf						jr .dot_done 
3bdf				endif 
3bdf			 
3bdf			.dot_inum: 
3bdf			 
3bdf			 
3bdf					if DEBUG_FORTH_DOT 
3bdf						DMARK "+IT" 
3bdf f5				push af  
3be0 3a f4 3b			ld a, (.dmark)  
3be3 32 a0 fd			ld (debug_mark),a  
3be6 3a f5 3b			ld a, (.dmark+1)  
3be9 32 a1 fd			ld (debug_mark+1),a  
3bec 3a f6 3b			ld a, (.dmark+2)  
3bef 32 a2 fd			ld (debug_mark+2),a  
3bf2 18 03			jr .pastdmark  
3bf4 ..			.dmark: db "+IT"  
3bf7 f1			.pastdmark: pop af  
3bf8			endm  
# End of macro DMARK
3bf8				CALLMONITOR 
3bf8 cd aa fd			call debug_vector  
3bfb				endm  
# End of macro CALLMONITOR
3bfb					endif 
3bfb			 
3bfb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bfb cd 4b 22			call macro_dsp_valuehl 
3bfe				endm 
# End of macro FORTH_DSP_VALUEHL
3bfe			 
3bfe				; TODO add floating point number detection 
3bfe			 
3bfe e5					push hl 
3bff			 
3bff					; destroy value TOS 
3bff			 
3bff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bff cd 03 23			call macro_forth_dsp_pop 
3c02				endm 
# End of macro FORTH_DSP_POP
3c02			 
3c02			 
3c02					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c02 cd 4b 22			call macro_dsp_valuehl 
3c05				endm 
# End of macro FORTH_DSP_VALUEHL
3c05			 
3c05					; one value on hl get other one back 
3c05			 
3c05 d1					pop de 
3c06			 
3c06					; do the add 
3c06			 
3c06 19					add hl,de 
3c07			 
3c07					; save it 
3c07			 
3c07			;		push hl	 
3c07			 
3c07					; 
3c07			 
3c07					; destroy value TOS 
3c07			 
3c07					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c07 cd 03 23			call macro_forth_dsp_pop 
3c0a				endm 
# End of macro FORTH_DSP_POP
3c0a			 
3c0a					; TODO push value back onto stack for another op etc 
3c0a			 
3c0a			;		pop hl 
3c0a			 
3c0a			.dot_done: 
3c0a cd 46 20				call forth_push_numhl 
3c0d			 
3c0d					NEXTW 
3c0d c3 37 24			jp macro_next 
3c10				endm 
# End of macro NEXTW
3c10			.NEG: 
3c10			 
3c10				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3c10 17				db WORD_SYS_CORE+3             
3c11 53 3c			dw .DIV            
3c13 02				db 1 + 1 
3c14 .. 00			db "-",0              
3c16				endm 
# End of macro CWHEAD
3c16			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3c16					if DEBUG_FORTH_WORDS_KEY 
3c16						DMARK "SUB" 
3c16 f5				push af  
3c17 3a 2b 3c			ld a, (.dmark)  
3c1a 32 a0 fd			ld (debug_mark),a  
3c1d 3a 2c 3c			ld a, (.dmark+1)  
3c20 32 a1 fd			ld (debug_mark+1),a  
3c23 3a 2d 3c			ld a, (.dmark+2)  
3c26 32 a2 fd			ld (debug_mark+2),a  
3c29 18 03			jr .pastdmark  
3c2b ..			.dmark: db "SUB"  
3c2e f1			.pastdmark: pop af  
3c2f			endm  
# End of macro DMARK
3c2f						CALLMONITOR 
3c2f cd aa fd			call debug_vector  
3c32				endm  
# End of macro CALLMONITOR
3c32					endif 
3c32			 
3c32			 
3c32				; TODO add floating point number detection 
3c32					; v5 FORTH_DSP_VALUE 
3c32					FORTH_DSP 
3c32 cd 11 22			call macro_forth_dsp 
3c35				endm 
# End of macro FORTH_DSP
3c35 7e					ld a,(hl)	; get type of value on TOS 
3c36 fe 02				cp DS_TYPE_INUM  
3c38 28 03				jr z, .neg_inum 
3c3a			 
3c3a					NEXTW 
3c3a c3 37 24			jp macro_next 
3c3d				endm 
# End of macro NEXTW
3c3d			 
3c3d			; float maths 
3c3d			 
3c3d				if FORTH_ENABLE_FLOATMATH 
3c3d					jr .neg_done 
3c3d			 
3c3d				endif 
3c3d					 
3c3d			 
3c3d			.neg_inum: 
3c3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c3d cd 4b 22			call macro_dsp_valuehl 
3c40				endm 
# End of macro FORTH_DSP_VALUEHL
3c40			 
3c40 e5					push hl 
3c41			 
3c41					; destroy value TOS 
3c41			 
3c41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c41 cd 03 23			call macro_forth_dsp_pop 
3c44				endm 
# End of macro FORTH_DSP_POP
3c44			 
3c44			 
3c44					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c44 cd 4b 22			call macro_dsp_valuehl 
3c47				endm 
# End of macro FORTH_DSP_VALUEHL
3c47			 
3c47					; one value on hl get other one back 
3c47			 
3c47 d1					pop de 
3c48			 
3c48					; do the sub 
3c48			;		ex de, hl 
3c48			 
3c48 ed 52				sbc hl,de 
3c4a			 
3c4a					; save it 
3c4a			 
3c4a			;		push hl	 
3c4a			 
3c4a					; 
3c4a			 
3c4a					; destroy value TOS 
3c4a			 
3c4a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c4a cd 03 23			call macro_forth_dsp_pop 
3c4d				endm 
# End of macro FORTH_DSP_POP
3c4d			 
3c4d					; TODO push value back onto stack for another op etc 
3c4d			 
3c4d			;		pop hl 
3c4d			 
3c4d cd 46 20				call forth_push_numhl 
3c50			.neg_done: 
3c50			 
3c50					NEXTW 
3c50 c3 37 24			jp macro_next 
3c53				endm 
# End of macro NEXTW
3c53			.DIV: 
3c53				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3c53 18				db WORD_SYS_CORE+4             
3c54 a0 3c			dw .MUL            
3c56 02				db 1 + 1 
3c57 .. 00			db "/",0              
3c59				endm 
# End of macro CWHEAD
3c59			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3c59					if DEBUG_FORTH_WORDS_KEY 
3c59						DMARK "DIV" 
3c59 f5				push af  
3c5a 3a 6e 3c			ld a, (.dmark)  
3c5d 32 a0 fd			ld (debug_mark),a  
3c60 3a 6f 3c			ld a, (.dmark+1)  
3c63 32 a1 fd			ld (debug_mark+1),a  
3c66 3a 70 3c			ld a, (.dmark+2)  
3c69 32 a2 fd			ld (debug_mark+2),a  
3c6c 18 03			jr .pastdmark  
3c6e ..			.dmark: db "DIV"  
3c71 f1			.pastdmark: pop af  
3c72			endm  
# End of macro DMARK
3c72						CALLMONITOR 
3c72 cd aa fd			call debug_vector  
3c75				endm  
# End of macro CALLMONITOR
3c75					endif 
3c75				; TODO add floating point number detection 
3c75					; v5 FORTH_DSP_VALUE 
3c75					FORTH_DSP 
3c75 cd 11 22			call macro_forth_dsp 
3c78				endm 
# End of macro FORTH_DSP
3c78 7e					ld a,(hl)	; get type of value on TOS 
3c79 fe 02				cp DS_TYPE_INUM  
3c7b 28 03				jr z, .div_inum 
3c7d			 
3c7d				if FORTH_ENABLE_FLOATMATH 
3c7d					jr .div_done 
3c7d			 
3c7d				endif 
3c7d					NEXTW 
3c7d c3 37 24			jp macro_next 
3c80				endm 
# End of macro NEXTW
3c80			.div_inum: 
3c80			 
3c80					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c80 cd 4b 22			call macro_dsp_valuehl 
3c83				endm 
# End of macro FORTH_DSP_VALUEHL
3c83			 
3c83 e5					push hl    ; to go to bc 
3c84			 
3c84					; destroy value TOS 
3c84			 
3c84					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c84 cd 03 23			call macro_forth_dsp_pop 
3c87				endm 
# End of macro FORTH_DSP_POP
3c87			 
3c87			 
3c87					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c87 cd 4b 22			call macro_dsp_valuehl 
3c8a				endm 
# End of macro FORTH_DSP_VALUEHL
3c8a			 
3c8a					; hl to go to de 
3c8a			 
3c8a e5					push hl 
3c8b			 
3c8b c1					pop bc 
3c8c d1					pop de		 
3c8d			 
3c8d			 
3c8d					if DEBUG_FORTH_MATHS 
3c8d						DMARK "DIV" 
3c8d				CALLMONITOR 
3c8d					endif 
3c8d					; one value on hl but move to a get other one back 
3c8d			 
3c8d			        
3c8d cd 3b 0f			call Div16 
3c90			 
3c90			;	push af	 
3c90 e5				push hl 
3c91 c5				push bc 
3c92			 
3c92					if DEBUG_FORTH_MATHS 
3c92						DMARK "DI1" 
3c92				CALLMONITOR 
3c92					endif 
3c92			 
3c92					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c92 cd 03 23			call macro_forth_dsp_pop 
3c95				endm 
# End of macro FORTH_DSP_POP
3c95			 
3c95			 
3c95			 
3c95 e1					pop hl    ; result 
3c96			 
3c96 cd 46 20				call forth_push_numhl 
3c99			 
3c99 e1					pop hl    ; reminder 
3c9a			;		ld h,0 
3c9a			;		ld l,d 
3c9a			 
3c9a cd 46 20				call forth_push_numhl 
3c9d			.div_done: 
3c9d					NEXTW 
3c9d c3 37 24			jp macro_next 
3ca0				endm 
# End of macro NEXTW
3ca0			.MUL: 
3ca0				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3ca0 19				db WORD_SYS_CORE+5             
3ca1 e5 3c			dw .MIN            
3ca3 02				db 1 + 1 
3ca4 .. 00			db "*",0              
3ca6				endm 
# End of macro CWHEAD
3ca6			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3ca6				; TODO add floating point number detection 
3ca6					if DEBUG_FORTH_WORDS_KEY 
3ca6						DMARK "MUL" 
3ca6 f5				push af  
3ca7 3a bb 3c			ld a, (.dmark)  
3caa 32 a0 fd			ld (debug_mark),a  
3cad 3a bc 3c			ld a, (.dmark+1)  
3cb0 32 a1 fd			ld (debug_mark+1),a  
3cb3 3a bd 3c			ld a, (.dmark+2)  
3cb6 32 a2 fd			ld (debug_mark+2),a  
3cb9 18 03			jr .pastdmark  
3cbb ..			.dmark: db "MUL"  
3cbe f1			.pastdmark: pop af  
3cbf			endm  
# End of macro DMARK
3cbf						CALLMONITOR 
3cbf cd aa fd			call debug_vector  
3cc2				endm  
# End of macro CALLMONITOR
3cc2					endif 
3cc2					FORTH_DSP 
3cc2 cd 11 22			call macro_forth_dsp 
3cc5				endm 
# End of macro FORTH_DSP
3cc5					; v5 FORTH_DSP_VALUE 
3cc5 7e					ld a,(hl)	; get type of value on TOS 
3cc6 fe 02				cp DS_TYPE_INUM  
3cc8 28 03				jr z, .mul_inum 
3cca			 
3cca				if FORTH_ENABLE_FLOATMATH 
3cca					jr .mul_done 
3cca			 
3cca				endif 
3cca			 
3cca					NEXTW 
3cca c3 37 24			jp macro_next 
3ccd				endm 
# End of macro NEXTW
3ccd			.mul_inum:	 
3ccd			 
3ccd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ccd cd 4b 22			call macro_dsp_valuehl 
3cd0				endm 
# End of macro FORTH_DSP_VALUEHL
3cd0			 
3cd0 e5					push hl 
3cd1			 
3cd1					; destroy value TOS 
3cd1			 
3cd1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cd1 cd 03 23			call macro_forth_dsp_pop 
3cd4				endm 
# End of macro FORTH_DSP_POP
3cd4			 
3cd4			 
3cd4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cd4 cd 4b 22			call macro_dsp_valuehl 
3cd7				endm 
# End of macro FORTH_DSP_VALUEHL
3cd7			 
3cd7					; one value on hl but move to a get other one back 
3cd7			 
3cd7 7d					ld a, l 
3cd8			 
3cd8 d1					pop de 
3cd9			 
3cd9					; do the mull 
3cd9			;		ex de, hl 
3cd9			 
3cd9 cd 61 0f				call Mult16 
3cdc					; save it 
3cdc			 
3cdc			;		push hl	 
3cdc			 
3cdc					; 
3cdc			 
3cdc					; destroy value TOS 
3cdc			 
3cdc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cdc cd 03 23			call macro_forth_dsp_pop 
3cdf				endm 
# End of macro FORTH_DSP_POP
3cdf			 
3cdf					; TODO push value back onto stack for another op etc 
3cdf			 
3cdf			;		pop hl 
3cdf			 
3cdf cd 46 20				call forth_push_numhl 
3ce2			 
3ce2			.mul_done: 
3ce2					NEXTW 
3ce2 c3 37 24			jp macro_next 
3ce5				endm 
# End of macro NEXTW
3ce5			 
3ce5			 
3ce5			 
3ce5			 
3ce5			.MIN: 
3ce5				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3ce5 49				db WORD_SYS_CORE+53             
3ce6 66 3d			dw .MAX            
3ce8 04				db 3 + 1 
3ce9 .. 00			db "MIN",0              
3ced				endm 
# End of macro CWHEAD
3ced			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3ced					if DEBUG_FORTH_WORDS_KEY 
3ced						DMARK "MIN" 
3ced f5				push af  
3cee 3a 02 3d			ld a, (.dmark)  
3cf1 32 a0 fd			ld (debug_mark),a  
3cf4 3a 03 3d			ld a, (.dmark+1)  
3cf7 32 a1 fd			ld (debug_mark+1),a  
3cfa 3a 04 3d			ld a, (.dmark+2)  
3cfd 32 a2 fd			ld (debug_mark+2),a  
3d00 18 03			jr .pastdmark  
3d02 ..			.dmark: db "MIN"  
3d05 f1			.pastdmark: pop af  
3d06			endm  
# End of macro DMARK
3d06						CALLMONITOR 
3d06 cd aa fd			call debug_vector  
3d09				endm  
# End of macro CALLMONITOR
3d09					endif 
3d09					; get u2 
3d09			 
3d09					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d09 cd 4b 22			call macro_dsp_valuehl 
3d0c				endm 
# End of macro FORTH_DSP_VALUEHL
3d0c			 
3d0c e5					push hl   ; u2 
3d0d			 
3d0d					; destroy value TOS 
3d0d			 
3d0d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d0d cd 03 23			call macro_forth_dsp_pop 
3d10				endm 
# End of macro FORTH_DSP_POP
3d10			 
3d10					; get u1 
3d10			 
3d10					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d10 cd 4b 22			call macro_dsp_valuehl 
3d13				endm 
# End of macro FORTH_DSP_VALUEHL
3d13			 
3d13 e5					push hl  ; u1 
3d14			 
3d14					; destroy value TOS 
3d14			 
3d14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d14 cd 03 23			call macro_forth_dsp_pop 
3d17				endm 
# End of macro FORTH_DSP_POP
3d17			 
3d17 b7			 or a      ;clear carry flag 
3d18 e1			  pop hl    ; u1 
3d19 d1			  pop de    ; u2 
3d1a e5				push hl   ; saved in case hl is lowest 
3d1b ed 52		  sbc hl,de 
3d1d 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3d1f			 
3d1f e1				pop hl 
3d20					if DEBUG_FORTH_WORDS 
3d20						DMARK "MIN" 
3d20 f5				push af  
3d21 3a 35 3d			ld a, (.dmark)  
3d24 32 a0 fd			ld (debug_mark),a  
3d27 3a 36 3d			ld a, (.dmark+1)  
3d2a 32 a1 fd			ld (debug_mark+1),a  
3d2d 3a 37 3d			ld a, (.dmark+2)  
3d30 32 a2 fd			ld (debug_mark+2),a  
3d33 18 03			jr .pastdmark  
3d35 ..			.dmark: db "MIN"  
3d38 f1			.pastdmark: pop af  
3d39			endm  
# End of macro DMARK
3d39						CALLMONITOR 
3d39 cd aa fd			call debug_vector  
3d3c				endm  
# End of macro CALLMONITOR
3d3c					endif 
3d3c cd 46 20				call forth_push_numhl 
3d3f			 
3d3f				       NEXTW 
3d3f c3 37 24			jp macro_next 
3d42				endm 
# End of macro NEXTW
3d42			 
3d42			.mincont:  
3d42 c1				pop bc   ; tidy up 
3d43 eb				ex de , hl  
3d44					if DEBUG_FORTH_WORDS 
3d44						DMARK "MI1" 
3d44 f5				push af  
3d45 3a 59 3d			ld a, (.dmark)  
3d48 32 a0 fd			ld (debug_mark),a  
3d4b 3a 5a 3d			ld a, (.dmark+1)  
3d4e 32 a1 fd			ld (debug_mark+1),a  
3d51 3a 5b 3d			ld a, (.dmark+2)  
3d54 32 a2 fd			ld (debug_mark+2),a  
3d57 18 03			jr .pastdmark  
3d59 ..			.dmark: db "MI1"  
3d5c f1			.pastdmark: pop af  
3d5d			endm  
# End of macro DMARK
3d5d						CALLMONITOR 
3d5d cd aa fd			call debug_vector  
3d60				endm  
# End of macro CALLMONITOR
3d60					endif 
3d60 cd 46 20				call forth_push_numhl 
3d63			 
3d63				       NEXTW 
3d63 c3 37 24			jp macro_next 
3d66				endm 
# End of macro NEXTW
3d66			.MAX: 
3d66				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3d66 4a				db WORD_SYS_CORE+54             
3d67 e7 3d			dw .RND16            
3d69 04				db 3 + 1 
3d6a .. 00			db "MAX",0              
3d6e				endm 
# End of macro CWHEAD
3d6e			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3d6e					if DEBUG_FORTH_WORDS_KEY 
3d6e						DMARK "MAX" 
3d6e f5				push af  
3d6f 3a 83 3d			ld a, (.dmark)  
3d72 32 a0 fd			ld (debug_mark),a  
3d75 3a 84 3d			ld a, (.dmark+1)  
3d78 32 a1 fd			ld (debug_mark+1),a  
3d7b 3a 85 3d			ld a, (.dmark+2)  
3d7e 32 a2 fd			ld (debug_mark+2),a  
3d81 18 03			jr .pastdmark  
3d83 ..			.dmark: db "MAX"  
3d86 f1			.pastdmark: pop af  
3d87			endm  
# End of macro DMARK
3d87						CALLMONITOR 
3d87 cd aa fd			call debug_vector  
3d8a				endm  
# End of macro CALLMONITOR
3d8a					endif 
3d8a					; get u2 
3d8a			 
3d8a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d8a cd 4b 22			call macro_dsp_valuehl 
3d8d				endm 
# End of macro FORTH_DSP_VALUEHL
3d8d			 
3d8d e5					push hl   ; u2 
3d8e			 
3d8e					; destroy value TOS 
3d8e			 
3d8e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d8e cd 03 23			call macro_forth_dsp_pop 
3d91				endm 
# End of macro FORTH_DSP_POP
3d91			 
3d91					; get u1 
3d91			 
3d91					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d91 cd 4b 22			call macro_dsp_valuehl 
3d94				endm 
# End of macro FORTH_DSP_VALUEHL
3d94			 
3d94 e5					push hl  ; u1 
3d95			 
3d95					; destroy value TOS 
3d95			 
3d95					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d95 cd 03 23			call macro_forth_dsp_pop 
3d98				endm 
# End of macro FORTH_DSP_POP
3d98			 
3d98 b7			 or a      ;clear carry flag 
3d99 e1			  pop hl    ; u1 
3d9a d1			  pop de    ; u2 
3d9b e5				push hl   ; saved in case hl is lowest 
3d9c ed 52		  sbc hl,de 
3d9e 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3da0			 
3da0 e1				pop hl 
3da1					if DEBUG_FORTH_WORDS 
3da1						DMARK "MAX" 
3da1 f5				push af  
3da2 3a b6 3d			ld a, (.dmark)  
3da5 32 a0 fd			ld (debug_mark),a  
3da8 3a b7 3d			ld a, (.dmark+1)  
3dab 32 a1 fd			ld (debug_mark+1),a  
3dae 3a b8 3d			ld a, (.dmark+2)  
3db1 32 a2 fd			ld (debug_mark+2),a  
3db4 18 03			jr .pastdmark  
3db6 ..			.dmark: db "MAX"  
3db9 f1			.pastdmark: pop af  
3dba			endm  
# End of macro DMARK
3dba						CALLMONITOR 
3dba cd aa fd			call debug_vector  
3dbd				endm  
# End of macro CALLMONITOR
3dbd					endif 
3dbd cd 46 20				call forth_push_numhl 
3dc0			 
3dc0				       NEXTW 
3dc0 c3 37 24			jp macro_next 
3dc3				endm 
# End of macro NEXTW
3dc3			 
3dc3			.maxcont:  
3dc3 c1				pop bc   ; tidy up 
3dc4 eb				ex de , hl  
3dc5					if DEBUG_FORTH_WORDS 
3dc5						DMARK "MA1" 
3dc5 f5				push af  
3dc6 3a da 3d			ld a, (.dmark)  
3dc9 32 a0 fd			ld (debug_mark),a  
3dcc 3a db 3d			ld a, (.dmark+1)  
3dcf 32 a1 fd			ld (debug_mark+1),a  
3dd2 3a dc 3d			ld a, (.dmark+2)  
3dd5 32 a2 fd			ld (debug_mark+2),a  
3dd8 18 03			jr .pastdmark  
3dda ..			.dmark: db "MA1"  
3ddd f1			.pastdmark: pop af  
3dde			endm  
# End of macro DMARK
3dde						CALLMONITOR 
3dde cd aa fd			call debug_vector  
3de1				endm  
# End of macro CALLMONITOR
3de1					endif 
3de1 cd 46 20				call forth_push_numhl 
3de4				       NEXTW 
3de4 c3 37 24			jp macro_next 
3de7				endm 
# End of macro NEXTW
3de7			 
3de7			.RND16: 
3de7				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3de7 4e				db WORD_SYS_CORE+58             
3de8 16 3e			dw .RND8            
3dea 06				db 5 + 1 
3deb .. 00			db "RND16",0              
3df1				endm 
# End of macro CWHEAD
3df1			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3df1					if DEBUG_FORTH_WORDS_KEY 
3df1						DMARK "R16" 
3df1 f5				push af  
3df2 3a 06 3e			ld a, (.dmark)  
3df5 32 a0 fd			ld (debug_mark),a  
3df8 3a 07 3e			ld a, (.dmark+1)  
3dfb 32 a1 fd			ld (debug_mark+1),a  
3dfe 3a 08 3e			ld a, (.dmark+2)  
3e01 32 a2 fd			ld (debug_mark+2),a  
3e04 18 03			jr .pastdmark  
3e06 ..			.dmark: db "R16"  
3e09 f1			.pastdmark: pop af  
3e0a			endm  
# End of macro DMARK
3e0a						CALLMONITOR 
3e0a cd aa fd			call debug_vector  
3e0d				endm  
# End of macro CALLMONITOR
3e0d					endif 
3e0d cd 05 0f				call prng16  
3e10 cd 46 20				call forth_push_numhl 
3e13				       NEXTW 
3e13 c3 37 24			jp macro_next 
3e16				endm 
# End of macro NEXTW
3e16			.RND8: 
3e16				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3e16 60				db WORD_SYS_CORE+76             
3e17 4b 3e			dw .RND            
3e19 05				db 4 + 1 
3e1a .. 00			db "RND8",0              
3e1f				endm 
# End of macro CWHEAD
3e1f			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3e1f					if DEBUG_FORTH_WORDS_KEY 
3e1f						DMARK "RN8" 
3e1f f5				push af  
3e20 3a 34 3e			ld a, (.dmark)  
3e23 32 a0 fd			ld (debug_mark),a  
3e26 3a 35 3e			ld a, (.dmark+1)  
3e29 32 a1 fd			ld (debug_mark+1),a  
3e2c 3a 36 3e			ld a, (.dmark+2)  
3e2f 32 a2 fd			ld (debug_mark+2),a  
3e32 18 03			jr .pastdmark  
3e34 ..			.dmark: db "RN8"  
3e37 f1			.pastdmark: pop af  
3e38			endm  
# End of macro DMARK
3e38						CALLMONITOR 
3e38 cd aa fd			call debug_vector  
3e3b				endm  
# End of macro CALLMONITOR
3e3b					endif 
3e3b 2a de fa				ld hl,(xrandc) 
3e3e 23					inc hl 
3e3f cd 1f 0f				call xrnd 
3e42 6f					ld l,a	 
3e43 26 00				ld h,0 
3e45 cd 46 20				call forth_push_numhl 
3e48				       NEXTW 
3e48 c3 37 24			jp macro_next 
3e4b				endm 
# End of macro NEXTW
3e4b			.RND: 
3e4b				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3e4b 60				db WORD_SYS_CORE+76             
3e4c 51 3f			dw .ENDMATHS            
3e4e 04				db 3 + 1 
3e4f .. 00			db "RND",0              
3e53				endm 
# End of macro CWHEAD
3e53			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3e53			 
3e53					if DEBUG_FORTH_WORDS_KEY 
3e53						DMARK "RND" 
3e53 f5				push af  
3e54 3a 68 3e			ld a, (.dmark)  
3e57 32 a0 fd			ld (debug_mark),a  
3e5a 3a 69 3e			ld a, (.dmark+1)  
3e5d 32 a1 fd			ld (debug_mark+1),a  
3e60 3a 6a 3e			ld a, (.dmark+2)  
3e63 32 a2 fd			ld (debug_mark+2),a  
3e66 18 03			jr .pastdmark  
3e68 ..			.dmark: db "RND"  
3e6b f1			.pastdmark: pop af  
3e6c			endm  
# End of macro DMARK
3e6c						CALLMONITOR 
3e6c cd aa fd			call debug_vector  
3e6f				endm  
# End of macro CALLMONITOR
3e6f					endif 
3e6f					 
3e6f					FORTH_DSP_VALUEHL    ; upper range 
3e6f cd 4b 22			call macro_dsp_valuehl 
3e72				endm 
# End of macro FORTH_DSP_VALUEHL
3e72			 
3e72 22 e2 fa				ld (LFSRSeed), hl	 
3e75			 
3e75					if DEBUG_FORTH_WORDS 
3e75						DMARK "RN1" 
3e75 f5				push af  
3e76 3a 8a 3e			ld a, (.dmark)  
3e79 32 a0 fd			ld (debug_mark),a  
3e7c 3a 8b 3e			ld a, (.dmark+1)  
3e7f 32 a1 fd			ld (debug_mark+1),a  
3e82 3a 8c 3e			ld a, (.dmark+2)  
3e85 32 a2 fd			ld (debug_mark+2),a  
3e88 18 03			jr .pastdmark  
3e8a ..			.dmark: db "RN1"  
3e8d f1			.pastdmark: pop af  
3e8e			endm  
# End of macro DMARK
3e8e						CALLMONITOR 
3e8e cd aa fd			call debug_vector  
3e91				endm  
# End of macro CALLMONITOR
3e91					endif 
3e91					FORTH_DSP_POP 
3e91 cd 03 23			call macro_forth_dsp_pop 
3e94				endm 
# End of macro FORTH_DSP_POP
3e94			 
3e94					FORTH_DSP_VALUEHL    ; low range 
3e94 cd 4b 22			call macro_dsp_valuehl 
3e97				endm 
# End of macro FORTH_DSP_VALUEHL
3e97			 
3e97					if DEBUG_FORTH_WORDS 
3e97						DMARK "RN2" 
3e97 f5				push af  
3e98 3a ac 3e			ld a, (.dmark)  
3e9b 32 a0 fd			ld (debug_mark),a  
3e9e 3a ad 3e			ld a, (.dmark+1)  
3ea1 32 a1 fd			ld (debug_mark+1),a  
3ea4 3a ae 3e			ld a, (.dmark+2)  
3ea7 32 a2 fd			ld (debug_mark+2),a  
3eaa 18 03			jr .pastdmark  
3eac ..			.dmark: db "RN2"  
3eaf f1			.pastdmark: pop af  
3eb0			endm  
# End of macro DMARK
3eb0						CALLMONITOR 
3eb0 cd aa fd			call debug_vector  
3eb3				endm  
# End of macro CALLMONITOR
3eb3					endif 
3eb3 22 e4 fa				ld (LFSRSeed+2), hl 
3eb6			 
3eb6					FORTH_DSP_POP 
3eb6 cd 03 23			call macro_forth_dsp_pop 
3eb9				endm 
# End of macro FORTH_DSP_POP
3eb9			 
3eb9 e5					push hl 
3eba			 
3eba e1			.inrange:	pop hl 
3ebb cd 05 0f				call prng16  
3ebe					if DEBUG_FORTH_WORDS 
3ebe						DMARK "RN3" 
3ebe f5				push af  
3ebf 3a d3 3e			ld a, (.dmark)  
3ec2 32 a0 fd			ld (debug_mark),a  
3ec5 3a d4 3e			ld a, (.dmark+1)  
3ec8 32 a1 fd			ld (debug_mark+1),a  
3ecb 3a d5 3e			ld a, (.dmark+2)  
3ece 32 a2 fd			ld (debug_mark+2),a  
3ed1 18 03			jr .pastdmark  
3ed3 ..			.dmark: db "RN3"  
3ed6 f1			.pastdmark: pop af  
3ed7			endm  
# End of macro DMARK
3ed7						CALLMONITOR 
3ed7 cd aa fd			call debug_vector  
3eda				endm  
# End of macro CALLMONITOR
3eda					endif 
3eda					 
3eda					; if the range is 8bit knock out the high byte 
3eda			 
3eda ed 5b e2 fa			ld de, (LFSRSeed)     ; check high level 
3ede			 
3ede 3e 00				ld a, 0 
3ee0 ba					cp d  
3ee1 20 1e				jr nz, .hirange 
3ee3 26 00				ld h, 0   ; knock it down to 8bit 
3ee5			 
3ee5					if DEBUG_FORTH_WORDS 
3ee5						DMARK "RNk" 
3ee5 f5				push af  
3ee6 3a fa 3e			ld a, (.dmark)  
3ee9 32 a0 fd			ld (debug_mark),a  
3eec 3a fb 3e			ld a, (.dmark+1)  
3eef 32 a1 fd			ld (debug_mark+1),a  
3ef2 3a fc 3e			ld a, (.dmark+2)  
3ef5 32 a2 fd			ld (debug_mark+2),a  
3ef8 18 03			jr .pastdmark  
3efa ..			.dmark: db "RNk"  
3efd f1			.pastdmark: pop af  
3efe			endm  
# End of macro DMARK
3efe						CALLMONITOR 
3efe cd aa fd			call debug_vector  
3f01				endm  
# End of macro CALLMONITOR
3f01					endif 
3f01			.hirange:   
3f01 e5					push hl  
3f02 b7					or a  
3f03 ed 52		                sbc hl, de 
3f05			 
3f05					;call cmp16 
3f05			 
3f05 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3f07 e1					pop hl 
3f08 e5					push hl 
3f09			 
3f09					if DEBUG_FORTH_WORDS 
3f09						DMARK "RN4" 
3f09 f5				push af  
3f0a 3a 1e 3f			ld a, (.dmark)  
3f0d 32 a0 fd			ld (debug_mark),a  
3f10 3a 1f 3f			ld a, (.dmark+1)  
3f13 32 a1 fd			ld (debug_mark+1),a  
3f16 3a 20 3f			ld a, (.dmark+2)  
3f19 32 a2 fd			ld (debug_mark+2),a  
3f1c 18 03			jr .pastdmark  
3f1e ..			.dmark: db "RN4"  
3f21 f1			.pastdmark: pop af  
3f22			endm  
# End of macro DMARK
3f22						CALLMONITOR 
3f22 cd aa fd			call debug_vector  
3f25				endm  
# End of macro CALLMONITOR
3f25					endif 
3f25 ed 5b e4 fa			ld de, (LFSRSeed+2)   ; check low range 
3f29					;call cmp16 
3f29				 
3f29 b7					or a  
3f2a ed 52		                sbc hl, de 
3f2c 38 8c				jr c, .inrange 
3f2e			 
3f2e e1					pop hl 
3f2f					 
3f2f					if DEBUG_FORTH_WORDS 
3f2f						DMARK "RNd" 
3f2f f5				push af  
3f30 3a 44 3f			ld a, (.dmark)  
3f33 32 a0 fd			ld (debug_mark),a  
3f36 3a 45 3f			ld a, (.dmark+1)  
3f39 32 a1 fd			ld (debug_mark+1),a  
3f3c 3a 46 3f			ld a, (.dmark+2)  
3f3f 32 a2 fd			ld (debug_mark+2),a  
3f42 18 03			jr .pastdmark  
3f44 ..			.dmark: db "RNd"  
3f47 f1			.pastdmark: pop af  
3f48			endm  
# End of macro DMARK
3f48						CALLMONITOR 
3f48 cd aa fd			call debug_vector  
3f4b				endm  
# End of macro CALLMONITOR
3f4b					endif 
3f4b			 
3f4b			 
3f4b cd 46 20				call forth_push_numhl 
3f4e				       NEXTW 
3f4e c3 37 24			jp macro_next 
3f51				endm 
# End of macro NEXTW
3f51			 
3f51			.ENDMATHS: 
3f51			 
3f51			; eof 
3f51			 
# End of file forth_words_maths.asm
3f51			include "forth_words_display.asm" 
3f51			 
3f51			; | ## Display Words 
3f51			 
3f51			.ACT: 
3f51			 
3f51				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3f51 62				db WORD_SYS_CORE+78             
3f52 9d 3f			dw .INFO            
3f54 07				db 6 + 1 
3f55 .. 00			db "ACTIVE",0              
3f5c				endm 
# End of macro CWHEAD
3f5c			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3f5c			;  
3f5c			; | | To display a pulsing activity indicator in a processing loop do this... 
3f5c			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3f5c			 
3f5c					if DEBUG_FORTH_WORDS_KEY 
3f5c						DMARK "ACT" 
3f5c f5				push af  
3f5d 3a 71 3f			ld a, (.dmark)  
3f60 32 a0 fd			ld (debug_mark),a  
3f63 3a 72 3f			ld a, (.dmark+1)  
3f66 32 a1 fd			ld (debug_mark+1),a  
3f69 3a 73 3f			ld a, (.dmark+2)  
3f6c 32 a2 fd			ld (debug_mark+2),a  
3f6f 18 03			jr .pastdmark  
3f71 ..			.dmark: db "ACT"  
3f74 f1			.pastdmark: pop af  
3f75			endm  
# End of macro DMARK
3f75						CALLMONITOR 
3f75 cd aa fd			call debug_vector  
3f78				endm  
# End of macro CALLMONITOR
3f78					endif 
3f78 cd 01 0d				call active 
3f7b					if DEBUG_FORTH_WORDS 
3f7b						DMARK "ACp" 
3f7b f5				push af  
3f7c 3a 90 3f			ld a, (.dmark)  
3f7f 32 a0 fd			ld (debug_mark),a  
3f82 3a 91 3f			ld a, (.dmark+1)  
3f85 32 a1 fd			ld (debug_mark+1),a  
3f88 3a 92 3f			ld a, (.dmark+2)  
3f8b 32 a2 fd			ld (debug_mark+2),a  
3f8e 18 03			jr .pastdmark  
3f90 ..			.dmark: db "ACp"  
3f93 f1			.pastdmark: pop af  
3f94			endm  
# End of macro DMARK
3f94						CALLMONITOR 
3f94 cd aa fd			call debug_vector  
3f97				endm  
# End of macro CALLMONITOR
3f97					endif 
3f97 cd b4 20				call forth_push_str 
3f9a			 
3f9a					NEXTW 
3f9a c3 37 24			jp macro_next 
3f9d				endm 
# End of macro NEXTW
3f9d			.INFO: 
3f9d			 
3f9d				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3f9d 62				db WORD_SYS_CORE+78             
3f9e ba 3f			dw .ATP            
3fa0 05				db 4 + 1 
3fa1 .. 00			db "INFO",0              
3fa6				endm 
# End of macro CWHEAD
3fa6			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3fa6					FORTH_DSP_VALUEHL 
3fa6 cd 4b 22			call macro_dsp_valuehl 
3fa9				endm 
# End of macro FORTH_DSP_VALUEHL
3fa9			 
3fa9					FORTH_DSP_POP 
3fa9 cd 03 23			call macro_forth_dsp_pop 
3fac				endm 
# End of macro FORTH_DSP_POP
3fac			 
3fac e5					push hl 
3fad			 
3fad					FORTH_DSP_VALUEHL 
3fad cd 4b 22			call macro_dsp_valuehl 
3fb0				endm 
# End of macro FORTH_DSP_VALUEHL
3fb0			 
3fb0					FORTH_DSP_POP 
3fb0 cd 03 23			call macro_forth_dsp_pop 
3fb3				endm 
# End of macro FORTH_DSP_POP
3fb3			 
3fb3 d1					pop de 
3fb4			 
3fb4 cd 3b 0d				call info_panel 
3fb7			 
3fb7			 
3fb7					NEXTW 
3fb7 c3 37 24			jp macro_next 
3fba				endm 
# End of macro NEXTW
3fba			.ATP: 
3fba				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3fba 62				db WORD_SYS_CORE+78             
3fbb 31 40			dw .FB            
3fbd 04				db 3 + 1 
3fbe .. 00			db "AT?",0              
3fc2				endm 
# End of macro CWHEAD
3fc2			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3fc2					if DEBUG_FORTH_WORDS_KEY 
3fc2						DMARK "AT?" 
3fc2 f5				push af  
3fc3 3a d7 3f			ld a, (.dmark)  
3fc6 32 a0 fd			ld (debug_mark),a  
3fc9 3a d8 3f			ld a, (.dmark+1)  
3fcc 32 a1 fd			ld (debug_mark+1),a  
3fcf 3a d9 3f			ld a, (.dmark+2)  
3fd2 32 a2 fd			ld (debug_mark+2),a  
3fd5 18 03			jr .pastdmark  
3fd7 ..			.dmark: db "AT?"  
3fda f1			.pastdmark: pop af  
3fdb			endm  
# End of macro DMARK
3fdb						CALLMONITOR 
3fdb cd aa fd			call debug_vector  
3fde				endm  
# End of macro CALLMONITOR
3fde					endif 
3fde 3a 93 f9				ld a, (f_cursor_ptr) 
3fe1			 
3fe1			if DEBUG_FORTH_WORDS 
3fe1				DMARK "AT?" 
3fe1 f5				push af  
3fe2 3a f6 3f			ld a, (.dmark)  
3fe5 32 a0 fd			ld (debug_mark),a  
3fe8 3a f7 3f			ld a, (.dmark+1)  
3feb 32 a1 fd			ld (debug_mark+1),a  
3fee 3a f8 3f			ld a, (.dmark+2)  
3ff1 32 a2 fd			ld (debug_mark+2),a  
3ff4 18 03			jr .pastdmark  
3ff6 ..			.dmark: db "AT?"  
3ff9 f1			.pastdmark: pop af  
3ffa			endm  
# End of macro DMARK
3ffa				CALLMONITOR 
3ffa cd aa fd			call debug_vector  
3ffd				endm  
# End of macro CALLMONITOR
3ffd			endif	 
3ffd					; count the number of rows 
3ffd			 
3ffd 06 00				ld b, 0 
3fff 4f			.atpr:		ld c, a    ; save in case we go below zero 
4000 d6 28				sub display_cols 
4002 f2 08 40				jp p, .atprunder 
4005 04					inc b 
4006 18 f7				jr .atpr 
4008			.atprunder:	 
4008			if DEBUG_FORTH_WORDS 
4008				DMARK "A?2" 
4008 f5				push af  
4009 3a 1d 40			ld a, (.dmark)  
400c 32 a0 fd			ld (debug_mark),a  
400f 3a 1e 40			ld a, (.dmark+1)  
4012 32 a1 fd			ld (debug_mark+1),a  
4015 3a 1f 40			ld a, (.dmark+2)  
4018 32 a2 fd			ld (debug_mark+2),a  
401b 18 03			jr .pastdmark  
401d ..			.dmark: db "A?2"  
4020 f1			.pastdmark: pop af  
4021			endm  
# End of macro DMARK
4021				CALLMONITOR 
4021 cd aa fd			call debug_vector  
4024				endm  
# End of macro CALLMONITOR
4024			endif	 
4024 26 00				ld h, 0 
4026 69					ld l, c 
4027 cd 46 20				call forth_push_numhl 
402a 68					ld l, b  
402b cd 46 20				call forth_push_numhl 
402e			 
402e			 
402e				NEXTW 
402e c3 37 24			jp macro_next 
4031				endm 
# End of macro NEXTW
4031			 
4031			.FB: 
4031				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
4031 1b				db WORD_SYS_CORE+7             
4032 7f 40			dw .EMIT            
4034 03				db 2 + 1 
4035 .. 00			db "FB",0              
4038				endm 
# End of macro CWHEAD
4038			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
4038			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
4038			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
4038			; | | If automatic display is off then updates will not be shown until DRAW is used. 
4038					if DEBUG_FORTH_WORDS_KEY 
4038						DMARK "FB." 
4038 f5				push af  
4039 3a 4d 40			ld a, (.dmark)  
403c 32 a0 fd			ld (debug_mark),a  
403f 3a 4e 40			ld a, (.dmark+1)  
4042 32 a1 fd			ld (debug_mark+1),a  
4045 3a 4f 40			ld a, (.dmark+2)  
4048 32 a2 fd			ld (debug_mark+2),a  
404b 18 03			jr .pastdmark  
404d ..			.dmark: db "FB."  
4050 f1			.pastdmark: pop af  
4051			endm  
# End of macro DMARK
4051						CALLMONITOR 
4051 cd aa fd			call debug_vector  
4054				endm  
# End of macro CALLMONITOR
4054					endif 
4054			 
4054					FORTH_DSP_VALUEHL 
4054 cd 4b 22			call macro_dsp_valuehl 
4057				endm 
# End of macro FORTH_DSP_VALUEHL
4057			 
4057 7d					ld a, l 
4058 fe 01				cp 1 
405a 20 05				jr nz, .fbn1 
405c 21 45 fc				ld hl, display_fb1 
405f 18 15				jr .fbset 
4061 fe 02		.fbn1:		cp 2 
4063 20 05				jr nz, .fbn2 
4065 21 03 fb				ld hl, display_fb2 
4068 18 0c				jr .fbset 
406a fe 03		.fbn2:		cp 3 
406c 20 05				jr nz, .fbn3 
406e 21 a4 fb				ld hl, display_fb3 
4071 18 03				jr .fbset 
4073			.fbn3:		 ; if invalid number select first 
4073 21 45 fc				ld hl, display_fb1 
4076 22 01 fb		.fbset:		ld (display_fb_active), hl 
4079			 
4079					FORTH_DSP_POP 
4079 cd 03 23			call macro_forth_dsp_pop 
407c				endm 
# End of macro FORTH_DSP_POP
407c			 
407c					NEXTW 
407c c3 37 24			jp macro_next 
407f				endm 
# End of macro NEXTW
407f			 
407f			 
407f			.EMIT: 
407f				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
407f 1b				db WORD_SYS_CORE+7             
4080 d0 40			dw .DOTH            
4082 05				db 4 + 1 
4083 .. 00			db "EMIT",0              
4088				endm 
# End of macro CWHEAD
4088			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
4088					; get value off TOS and display it 
4088			 
4088					if DEBUG_FORTH_WORDS_KEY 
4088						DMARK "EMT" 
4088 f5				push af  
4089 3a 9d 40			ld a, (.dmark)  
408c 32 a0 fd			ld (debug_mark),a  
408f 3a 9e 40			ld a, (.dmark+1)  
4092 32 a1 fd			ld (debug_mark+1),a  
4095 3a 9f 40			ld a, (.dmark+2)  
4098 32 a2 fd			ld (debug_mark+2),a  
409b 18 03			jr .pastdmark  
409d ..			.dmark: db "EMT"  
40a0 f1			.pastdmark: pop af  
40a1			endm  
# End of macro DMARK
40a1						CALLMONITOR 
40a1 cd aa fd			call debug_vector  
40a4				endm  
# End of macro CALLMONITOR
40a4					endif 
40a4			 
40a4					FORTH_DSP_VALUEHL 
40a4 cd 4b 22			call macro_dsp_valuehl 
40a7				endm 
# End of macro FORTH_DSP_VALUEHL
40a7			 
40a7 7d					ld a,l 
40a8			 
40a8					; TODO write to display 
40a8			 
40a8 32 f4 f2				ld (os_input), a 
40ab 3e 00				ld a, 0 
40ad 32 f5 f2				ld (os_input+1), a 
40b0					 
40b0 3a 93 f9				ld a, (f_cursor_ptr) 
40b3 11 f4 f2				ld de, os_input 
40b6 cd bd 0d				call str_at_display 
40b9			 
40b9			 
40b9 3a 71 f9				ld a,(cli_autodisplay) 
40bc fe 00				cp 0 
40be 28 03				jr z, .enoupdate 
40c0 cd cd 0d						call update_display 
40c3					.enoupdate: 
40c3			 
40c3 3a 93 f9				ld a, (f_cursor_ptr) 
40c6 3c					inc a 
40c7 32 93 f9				ld (f_cursor_ptr), a   ; save new pos 
40ca			 
40ca			 
40ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ca cd 03 23			call macro_forth_dsp_pop 
40cd				endm 
# End of macro FORTH_DSP_POP
40cd			  
40cd			 
40cd					NEXTW 
40cd c3 37 24			jp macro_next 
40d0				endm 
# End of macro NEXTW
40d0			.DOTH: 
40d0				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
40d0 1c				db WORD_SYS_CORE+8             
40d1 00 41			dw .DOTF            
40d3 03				db 2 + 1 
40d4 .. 00			db ".-",0              
40d7				endm 
# End of macro CWHEAD
40d7			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
40d7					; get value off TOS and display it 
40d7					if DEBUG_FORTH_WORDS_KEY 
40d7						DMARK "DTD" 
40d7 f5				push af  
40d8 3a ec 40			ld a, (.dmark)  
40db 32 a0 fd			ld (debug_mark),a  
40de 3a ed 40			ld a, (.dmark+1)  
40e1 32 a1 fd			ld (debug_mark+1),a  
40e4 3a ee 40			ld a, (.dmark+2)  
40e7 32 a2 fd			ld (debug_mark+2),a  
40ea 18 03			jr .pastdmark  
40ec ..			.dmark: db "DTD"  
40ef f1			.pastdmark: pop af  
40f0			endm  
# End of macro DMARK
40f0						CALLMONITOR 
40f0 cd aa fd			call debug_vector  
40f3				endm  
# End of macro CALLMONITOR
40f3					endif 
40f3 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
40f5 3e 00			ld a, 0 
40f7 32 72 f9			ld (cli_mvdot), a 
40fa c3 57 41			jp .dotgo 
40fd				NEXTW 
40fd c3 37 24			jp macro_next 
4100				endm 
# End of macro NEXTW
4100			.DOTF: 
4100				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
4100 1c				db WORD_SYS_CORE+8             
4101 2e 41			dw .DOT            
4103 03				db 2 + 1 
4104 .. 00			db ".>",0              
4107				endm 
# End of macro CWHEAD
4107			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
4107					; get value off TOS and display it 
4107			        ; TODO BUG adds extra spaces 
4107			        ; TODO BUG handle numerics? 
4107					if DEBUG_FORTH_WORDS_KEY 
4107						DMARK "DTC" 
4107 f5				push af  
4108 3a 1c 41			ld a, (.dmark)  
410b 32 a0 fd			ld (debug_mark),a  
410e 3a 1d 41			ld a, (.dmark+1)  
4111 32 a1 fd			ld (debug_mark+1),a  
4114 3a 1e 41			ld a, (.dmark+2)  
4117 32 a2 fd			ld (debug_mark+2),a  
411a 18 03			jr .pastdmark  
411c ..			.dmark: db "DTC"  
411f f1			.pastdmark: pop af  
4120			endm  
# End of macro DMARK
4120						CALLMONITOR 
4120 cd aa fd			call debug_vector  
4123				endm  
# End of macro CALLMONITOR
4123					endif 
4123 3e 01			ld a, 1 
4125 32 72 f9			ld (cli_mvdot), a 
4128 c3 57 41			jp .dotgo 
412b				NEXTW 
412b c3 37 24			jp macro_next 
412e				endm 
# End of macro NEXTW
412e			 
412e			.DOT: 
412e				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
412e 1c				db WORD_SYS_CORE+8             
412f 0a 43			dw .CLS            
4131 02				db 1 + 1 
4132 .. 00			db ".",0              
4134				endm 
# End of macro CWHEAD
4134			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
4134					; get value off TOS and display it 
4134			 
4134					if DEBUG_FORTH_WORDS_KEY 
4134						DMARK "DOT" 
4134 f5				push af  
4135 3a 49 41			ld a, (.dmark)  
4138 32 a0 fd			ld (debug_mark),a  
413b 3a 4a 41			ld a, (.dmark+1)  
413e 32 a1 fd			ld (debug_mark+1),a  
4141 3a 4b 41			ld a, (.dmark+2)  
4144 32 a2 fd			ld (debug_mark+2),a  
4147 18 03			jr .pastdmark  
4149 ..			.dmark: db "DOT"  
414c f1			.pastdmark: pop af  
414d			endm  
# End of macro DMARK
414d						CALLMONITOR 
414d cd aa fd			call debug_vector  
4150				endm  
# End of macro CALLMONITOR
4150					endif 
4150 3e 00			ld a, 0 
4152 32 72 f9			ld (cli_mvdot), a 
4155 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4157				 
4157			 
4157			.dotgo: 
4157			 
4157			; move up type to on stack for parserv5 
4157					FORTH_DSP 
4157 cd 11 22			call macro_forth_dsp 
415a				endm 
# End of macro FORTH_DSP
415a				;FORTH_DSP_VALUE  
415a			 
415a			if DEBUG_FORTH_DOT 
415a				DMARK "DOT" 
415a f5				push af  
415b 3a 6f 41			ld a, (.dmark)  
415e 32 a0 fd			ld (debug_mark),a  
4161 3a 70 41			ld a, (.dmark+1)  
4164 32 a1 fd			ld (debug_mark+1),a  
4167 3a 71 41			ld a, (.dmark+2)  
416a 32 a2 fd			ld (debug_mark+2),a  
416d 18 03			jr .pastdmark  
416f ..			.dmark: db "DOT"  
4172 f1			.pastdmark: pop af  
4173			endm  
# End of macro DMARK
4173				CALLMONITOR 
4173 cd aa fd			call debug_vector  
4176				endm  
# End of macro CALLMONITOR
4176			endif	 
4176			;		.print: 
4176			 
4176 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4177 23				inc hl   ; position to the actual value 
4178 fe 01			cp DS_TYPE_STR 
417a 20 06			jr nz, .dotnum1  
417c			 
417c			; display string 
417c				FORTH_DSP_VALUE  
417c cd 34 22			call macro_forth_dsp_value 
417f				endm 
# End of macro FORTH_DSP_VALUE
417f eb				ex de,hl 
4180 18 49			jr .dotwrite 
4182			 
4182			.dotnum1: 
4182 fe 02			cp DS_TYPE_INUM 
4184 20 44			jr nz, .dotflot 
4186			 
4186			 
4186			; display number 
4186			 
4186			;	push hl 
4186			;	call clear_display 
4186			;	pop hl 
4186			 
4186 5e				ld e, (hl) 
4187 23				inc hl 
4188 56				ld d, (hl) 
4189 21 f6 f0			ld hl, scratch 
418c			if DEBUG_FORTH_DOT 
418c				DMARK "DT1" 
418c f5				push af  
418d 3a a1 41			ld a, (.dmark)  
4190 32 a0 fd			ld (debug_mark),a  
4193 3a a2 41			ld a, (.dmark+1)  
4196 32 a1 fd			ld (debug_mark+1),a  
4199 3a a3 41			ld a, (.dmark+2)  
419c 32 a2 fd			ld (debug_mark+2),a  
419f 18 03			jr .pastdmark  
41a1 ..			.dmark: db "DT1"  
41a4 f1			.pastdmark: pop af  
41a5			endm  
# End of macro DMARK
41a5				CALLMONITOR 
41a5 cd aa fd			call debug_vector  
41a8				endm  
# End of macro CALLMONITOR
41a8			endif	 
41a8			 
41a8 cd f3 12			call uitoa_16 
41ab eb				ex de,hl 
41ac			 
41ac			if DEBUG_FORTH_DOT 
41ac				DMARK "DT2" 
41ac f5				push af  
41ad 3a c1 41			ld a, (.dmark)  
41b0 32 a0 fd			ld (debug_mark),a  
41b3 3a c2 41			ld a, (.dmark+1)  
41b6 32 a1 fd			ld (debug_mark+1),a  
41b9 3a c3 41			ld a, (.dmark+2)  
41bc 32 a2 fd			ld (debug_mark+2),a  
41bf 18 03			jr .pastdmark  
41c1 ..			.dmark: db "DT2"  
41c4 f1			.pastdmark: pop af  
41c5			endm  
# End of macro DMARK
41c5				CALLMONITOR 
41c5 cd aa fd			call debug_vector  
41c8				endm  
# End of macro CALLMONITOR
41c8			endif	 
41c8			 
41c8			;	ld de, os_word_scratch 
41c8 18 01			jr .dotwrite 
41ca			 
41ca 00			.dotflot:   nop 
41cb			; TODO print floating point number 
41cb			 
41cb			.dotwrite:		 
41cb			 
41cb					; if c is set then set all '-' to spaces 
41cb					; need to also take into account .>  
41cb			 
41cb 3e 01				ld a, 1 
41cd b9					cp c 
41ce 20 67				jr nz, .nodashswap 
41d0			 
41d0					; DE has the string to write, working with HL 
41d0			 
41d0 06 ff				ld b, 255 
41d2 d5					push de 
41d3 e1					pop hl 
41d4			 
41d4			if DEBUG_FORTH_DOT 
41d4				DMARK "DT-" 
41d4 f5				push af  
41d5 3a e9 41			ld a, (.dmark)  
41d8 32 a0 fd			ld (debug_mark),a  
41db 3a ea 41			ld a, (.dmark+1)  
41de 32 a1 fd			ld (debug_mark+1),a  
41e1 3a eb 41			ld a, (.dmark+2)  
41e4 32 a2 fd			ld (debug_mark+2),a  
41e7 18 03			jr .pastdmark  
41e9 ..			.dmark: db "DT-"  
41ec f1			.pastdmark: pop af  
41ed			endm  
# End of macro DMARK
41ed				CALLMONITOR 
41ed cd aa fd			call debug_vector  
41f0				endm  
# End of macro CALLMONITOR
41f0			endif	 
41f0 7e			.dashscan:	ld a, (hl) 
41f1 fe 00				cp 0 
41f3 28 42				jr z, .nodashswap 
41f5 fe 2d				cp '-' 
41f7 20 03				jr nz, .dashskip 
41f9 3e 20				ld a, ' ' 
41fb 77					ld (hl), a 
41fc 23			.dashskip:	inc hl 
41fd			if DEBUG_FORTH_DOT 
41fd				DMARK "D-2" 
41fd f5				push af  
41fe 3a 12 42			ld a, (.dmark)  
4201 32 a0 fd			ld (debug_mark),a  
4204 3a 13 42			ld a, (.dmark+1)  
4207 32 a1 fd			ld (debug_mark+1),a  
420a 3a 14 42			ld a, (.dmark+2)  
420d 32 a2 fd			ld (debug_mark+2),a  
4210 18 03			jr .pastdmark  
4212 ..			.dmark: db "D-2"  
4215 f1			.pastdmark: pop af  
4216			endm  
# End of macro DMARK
4216				CALLMONITOR 
4216 cd aa fd			call debug_vector  
4219				endm  
# End of macro CALLMONITOR
4219			endif	 
4219 10 d5				djnz .dashscan 
421b			 
421b			if DEBUG_FORTH_DOT 
421b				DMARK "D-1" 
421b f5				push af  
421c 3a 30 42			ld a, (.dmark)  
421f 32 a0 fd			ld (debug_mark),a  
4222 3a 31 42			ld a, (.dmark+1)  
4225 32 a1 fd			ld (debug_mark+1),a  
4228 3a 32 42			ld a, (.dmark+2)  
422b 32 a2 fd			ld (debug_mark+2),a  
422e 18 03			jr .pastdmark  
4230 ..			.dmark: db "D-1"  
4233 f1			.pastdmark: pop af  
4234			endm  
# End of macro DMARK
4234				CALLMONITOR 
4234 cd aa fd			call debug_vector  
4237				endm  
# End of macro CALLMONITOR
4237			endif	 
4237			 
4237			.nodashswap: 
4237			 
4237			if DEBUG_FORTH_DOT 
4237				DMARK "D-o" 
4237 f5				push af  
4238 3a 4c 42			ld a, (.dmark)  
423b 32 a0 fd			ld (debug_mark),a  
423e 3a 4d 42			ld a, (.dmark+1)  
4241 32 a1 fd			ld (debug_mark+1),a  
4244 3a 4e 42			ld a, (.dmark+2)  
4247 32 a2 fd			ld (debug_mark+2),a  
424a 18 03			jr .pastdmark  
424c ..			.dmark: db "D-o"  
424f f1			.pastdmark: pop af  
4250			endm  
# End of macro DMARK
4250				CALLMONITOR 
4250 cd aa fd			call debug_vector  
4253				endm  
# End of macro CALLMONITOR
4253			endif	 
4253			 
4253 d5					push de   ; save string start in case we need to advance print 
4254			 
4254 3a 93 f9				ld a, (f_cursor_ptr) 
4257 cd bd 0d				call str_at_display 
425a 3a 71 f9				ld a,(cli_autodisplay) 
425d fe 00				cp 0 
425f 28 03				jr z, .noupdate 
4261 cd cd 0d						call update_display 
4264					.noupdate: 
4264			 
4264			 
4264					; see if we need to advance the print position 
4264			 
4264 e1					pop hl   ; get back string 
4265			;		ex de,hl 
4265			 
4265 3a 72 f9				ld a, (cli_mvdot) 
4268			if DEBUG_FORTH_DOT 
4268			;		ld e,a 
4268				DMARK "D>1" 
4268 f5				push af  
4269 3a 7d 42			ld a, (.dmark)  
426c 32 a0 fd			ld (debug_mark),a  
426f 3a 7e 42			ld a, (.dmark+1)  
4272 32 a1 fd			ld (debug_mark+1),a  
4275 3a 7f 42			ld a, (.dmark+2)  
4278 32 a2 fd			ld (debug_mark+2),a  
427b 18 03			jr .pastdmark  
427d ..			.dmark: db "D>1"  
4280 f1			.pastdmark: pop af  
4281			endm  
# End of macro DMARK
4281				CALLMONITOR 
4281 cd aa fd			call debug_vector  
4284				endm  
# End of macro CALLMONITOR
4284			endif	 
4284 fe 00				cp 0 
4286 28 44				jr z, .noadv 
4288					; yes, lets advance the print position 
4288 3e 00				ld a, 0 
428a cd 4f 13				call strlent 
428d			if DEBUG_FORTH_DOT 
428d				DMARK "D-?" 
428d f5				push af  
428e 3a a2 42			ld a, (.dmark)  
4291 32 a0 fd			ld (debug_mark),a  
4294 3a a3 42			ld a, (.dmark+1)  
4297 32 a1 fd			ld (debug_mark+1),a  
429a 3a a4 42			ld a, (.dmark+2)  
429d 32 a2 fd			ld (debug_mark+2),a  
42a0 18 03			jr .pastdmark  
42a2 ..			.dmark: db "D-?"  
42a5 f1			.pastdmark: pop af  
42a6			endm  
# End of macro DMARK
42a6				CALLMONITOR 
42a6 cd aa fd			call debug_vector  
42a9				endm  
# End of macro CALLMONITOR
42a9			endif	 
42a9 3a 93 f9				ld a, (f_cursor_ptr) 
42ac 85					add a,l 
42ad					;call addatohl 
42ad					;ld a, l 
42ad 32 93 f9				ld (f_cursor_ptr), a   ; save new pos 
42b0			 
42b0			if DEBUG_FORTH_DOT 
42b0				DMARK "D->" 
42b0 f5				push af  
42b1 3a c5 42			ld a, (.dmark)  
42b4 32 a0 fd			ld (debug_mark),a  
42b7 3a c6 42			ld a, (.dmark+1)  
42ba 32 a1 fd			ld (debug_mark+1),a  
42bd 3a c7 42			ld a, (.dmark+2)  
42c0 32 a2 fd			ld (debug_mark+2),a  
42c3 18 03			jr .pastdmark  
42c5 ..			.dmark: db "D->"  
42c8 f1			.pastdmark: pop af  
42c9			endm  
# End of macro DMARK
42c9				CALLMONITOR 
42c9 cd aa fd			call debug_vector  
42cc				endm  
# End of macro CALLMONITOR
42cc			endif	 
42cc			 
42cc			.noadv:	 
42cc			 
42cc					if DEBUG_FORTH_DOT_WAIT 
42cc							call next_page_prompt 
42cc					endif	 
42cc			; TODO this pop off the stack causes a crash. i dont know why 
42cc			 
42cc			 
42cc			if DEBUG_FORTH_DOT 
42cc				DMARK "DTh" 
42cc f5				push af  
42cd 3a e1 42			ld a, (.dmark)  
42d0 32 a0 fd			ld (debug_mark),a  
42d3 3a e2 42			ld a, (.dmark+1)  
42d6 32 a1 fd			ld (debug_mark+1),a  
42d9 3a e3 42			ld a, (.dmark+2)  
42dc 32 a2 fd			ld (debug_mark+2),a  
42df 18 03			jr .pastdmark  
42e1 ..			.dmark: db "DTh"  
42e4 f1			.pastdmark: pop af  
42e5			endm  
# End of macro DMARK
42e5				CALLMONITOR 
42e5 cd aa fd			call debug_vector  
42e8				endm  
# End of macro CALLMONITOR
42e8			endif	 
42e8			 
42e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42e8 cd 03 23			call macro_forth_dsp_pop 
42eb				endm 
# End of macro FORTH_DSP_POP
42eb			 
42eb			if DEBUG_FORTH_DOT 
42eb				DMARK "DTi" 
42eb f5				push af  
42ec 3a 00 43			ld a, (.dmark)  
42ef 32 a0 fd			ld (debug_mark),a  
42f2 3a 01 43			ld a, (.dmark+1)  
42f5 32 a1 fd			ld (debug_mark+1),a  
42f8 3a 02 43			ld a, (.dmark+2)  
42fb 32 a2 fd			ld (debug_mark+2),a  
42fe 18 03			jr .pastdmark  
4300 ..			.dmark: db "DTi"  
4303 f1			.pastdmark: pop af  
4304			endm  
# End of macro DMARK
4304				CALLMONITOR 
4304 cd aa fd			call debug_vector  
4307				endm  
# End of macro CALLMONITOR
4307			endif	 
4307			 
4307			 
4307					NEXTW 
4307 c3 37 24			jp macro_next 
430a				endm 
# End of macro NEXTW
430a			 
430a			.CLS: 
430a				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
430a 35				db WORD_SYS_CORE+33             
430b 37 43			dw .DRAW            
430d 04				db 3 + 1 
430e .. 00			db "CLS",0              
4312				endm 
# End of macro CWHEAD
4312			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4312					if DEBUG_FORTH_WORDS_KEY 
4312						DMARK "CLS" 
4312 f5				push af  
4313 3a 27 43			ld a, (.dmark)  
4316 32 a0 fd			ld (debug_mark),a  
4319 3a 28 43			ld a, (.dmark+1)  
431c 32 a1 fd			ld (debug_mark+1),a  
431f 3a 29 43			ld a, (.dmark+2)  
4322 32 a2 fd			ld (debug_mark+2),a  
4325 18 03			jr .pastdmark  
4327 ..			.dmark: db "CLS"  
432a f1			.pastdmark: pop af  
432b			endm  
# End of macro DMARK
432b						CALLMONITOR 
432b cd aa fd			call debug_vector  
432e				endm  
# End of macro CALLMONITOR
432e					endif 
432e cd aa 0d				call clear_display 
4331 c3 45 44				jp .home		; and home cursor 
4334					NEXTW 
4334 c3 37 24			jp macro_next 
4337				endm 
# End of macro NEXTW
4337			 
4337			.DRAW: 
4337				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4337 36				db WORD_SYS_CORE+34             
4338 62 43			dw .DUMP            
433a 05				db 4 + 1 
433b .. 00			db "DRAW",0              
4340				endm 
# End of macro CWHEAD
4340			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4340					if DEBUG_FORTH_WORDS_KEY 
4340						DMARK "DRW" 
4340 f5				push af  
4341 3a 55 43			ld a, (.dmark)  
4344 32 a0 fd			ld (debug_mark),a  
4347 3a 56 43			ld a, (.dmark+1)  
434a 32 a1 fd			ld (debug_mark+1),a  
434d 3a 57 43			ld a, (.dmark+2)  
4350 32 a2 fd			ld (debug_mark+2),a  
4353 18 03			jr .pastdmark  
4355 ..			.dmark: db "DRW"  
4358 f1			.pastdmark: pop af  
4359			endm  
# End of macro DMARK
4359						CALLMONITOR 
4359 cd aa fd			call debug_vector  
435c				endm  
# End of macro CALLMONITOR
435c					endif 
435c cd cd 0d				call update_display 
435f					NEXTW 
435f c3 37 24			jp macro_next 
4362				endm 
# End of macro NEXTW
4362			 
4362			.DUMP: 
4362				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4362 37				db WORD_SYS_CORE+35             
4363 9a 43			dw .CDUMP            
4365 05				db 4 + 1 
4366 .. 00			db "DUMP",0              
436b				endm 
# End of macro CWHEAD
436b			; | DUMP ( x -- ) With address x display dump   | DONE 
436b			; TODO pop address to use off of the stack 
436b					if DEBUG_FORTH_WORDS_KEY 
436b						DMARK "DUM" 
436b f5				push af  
436c 3a 80 43			ld a, (.dmark)  
436f 32 a0 fd			ld (debug_mark),a  
4372 3a 81 43			ld a, (.dmark+1)  
4375 32 a1 fd			ld (debug_mark+1),a  
4378 3a 82 43			ld a, (.dmark+2)  
437b 32 a2 fd			ld (debug_mark+2),a  
437e 18 03			jr .pastdmark  
4380 ..			.dmark: db "DUM"  
4383 f1			.pastdmark: pop af  
4384			endm  
# End of macro DMARK
4384						CALLMONITOR 
4384 cd aa fd			call debug_vector  
4387				endm  
# End of macro CALLMONITOR
4387					endif 
4387 cd aa 0d				call clear_display 
438a			 
438a					; get address 
438a			 
438a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
438a cd 4b 22			call macro_dsp_valuehl 
438d				endm 
# End of macro FORTH_DSP_VALUEHL
438d				 
438d					; save it for cdump 
438d			 
438d 22 19 f4				ld (os_cur_ptr),hl 
4390			 
4390					; destroy value TOS 
4390			 
4390					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4390 cd 03 23			call macro_forth_dsp_pop 
4393				endm 
# End of macro FORTH_DSP_POP
4393			 
4393 cd c6 1e				call dumpcont	; skip old style of param parsing	 
4396 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4397					NEXTW 
4397 c3 37 24			jp macro_next 
439a				endm 
# End of macro NEXTW
439a			.CDUMP: 
439a				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
439a 38				db WORD_SYS_CORE+36             
439b ca 43			dw .DAT            
439d 06				db 5 + 1 
439e .. 00			db "CDUMP",0              
43a4				endm 
# End of macro CWHEAD
43a4			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
43a4					if DEBUG_FORTH_WORDS_KEY 
43a4						DMARK "CDP" 
43a4 f5				push af  
43a5 3a b9 43			ld a, (.dmark)  
43a8 32 a0 fd			ld (debug_mark),a  
43ab 3a ba 43			ld a, (.dmark+1)  
43ae 32 a1 fd			ld (debug_mark+1),a  
43b1 3a bb 43			ld a, (.dmark+2)  
43b4 32 a2 fd			ld (debug_mark+2),a  
43b7 18 03			jr .pastdmark  
43b9 ..			.dmark: db "CDP"  
43bc f1			.pastdmark: pop af  
43bd			endm  
# End of macro DMARK
43bd						CALLMONITOR 
43bd cd aa fd			call debug_vector  
43c0				endm  
# End of macro CALLMONITOR
43c0					endif 
43c0 cd aa 0d				call clear_display 
43c3 cd c6 1e				call dumpcont	 
43c6 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
43c7					NEXTW 
43c7 c3 37 24			jp macro_next 
43ca				endm 
# End of macro NEXTW
43ca			 
43ca			 
43ca			 
43ca			 
43ca			.DAT: 
43ca				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
43ca 3d				db WORD_SYS_CORE+41             
43cb 20 44			dw .HOME            
43cd 03				db 2 + 1 
43ce .. 00			db "AT",0              
43d1				endm 
# End of macro CWHEAD
43d1			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
43d1					if DEBUG_FORTH_WORDS_KEY 
43d1						DMARK "AT." 
43d1 f5				push af  
43d2 3a e6 43			ld a, (.dmark)  
43d5 32 a0 fd			ld (debug_mark),a  
43d8 3a e7 43			ld a, (.dmark+1)  
43db 32 a1 fd			ld (debug_mark+1),a  
43de 3a e8 43			ld a, (.dmark+2)  
43e1 32 a2 fd			ld (debug_mark+2),a  
43e4 18 03			jr .pastdmark  
43e6 ..			.dmark: db "AT."  
43e9 f1			.pastdmark: pop af  
43ea			endm  
# End of macro DMARK
43ea						CALLMONITOR 
43ea cd aa fd			call debug_vector  
43ed				endm  
# End of macro CALLMONITOR
43ed					endif 
43ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43ed cd 4b 22			call macro_dsp_valuehl 
43f0				endm 
# End of macro FORTH_DSP_VALUEHL
43f0			 
43f0			 
43f0					; TODO save cursor row 
43f0 7d					ld a,l 
43f1 fe 02				cp 2 
43f3 20 04				jr nz, .crow3 
43f5 3e 28				ld a, display_row_2 
43f7 18 12				jr .ccol1 
43f9 fe 03		.crow3:		cp 3 
43fb 20 04				jr nz, .crow4 
43fd 3e 50				ld a, display_row_3 
43ff 18 0a				jr .ccol1 
4401 fe 04		.crow4:		cp 4 
4403 20 04				jr nz, .crow1 
4405 3e 78				ld a, display_row_4 
4407 18 02				jr .ccol1 
4409 3e 00		.crow1:		ld a,display_row_1 
440b f5			.ccol1:		push af			; got row offset 
440c 6f					ld l,a 
440d 26 00				ld h,0 
440f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
440f cd 03 23			call macro_forth_dsp_pop 
4412				endm 
# End of macro FORTH_DSP_POP
4412					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4412 cd 4b 22			call macro_dsp_valuehl 
4415				endm 
# End of macro FORTH_DSP_VALUEHL
4415					; TODO save cursor col 
4415 f1					pop af 
4416 85					add l		; add col offset 
4417 32 93 f9				ld (f_cursor_ptr), a 
441a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
441a cd 03 23			call macro_forth_dsp_pop 
441d				endm 
# End of macro FORTH_DSP_POP
441d			 
441d					; calculate  
441d			 
441d					NEXTW 
441d c3 37 24			jp macro_next 
4420				endm 
# End of macro NEXTW
4420			 
4420			 
4420			.HOME: 
4420				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4420 41				db WORD_SYS_CORE+45             
4421 4d 44			dw .CR            
4423 05				db 4 + 1 
4424 .. 00			db "HOME",0              
4429				endm 
# End of macro CWHEAD
4429			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4429					if DEBUG_FORTH_WORDS_KEY 
4429						DMARK "HOM" 
4429 f5				push af  
442a 3a 3e 44			ld a, (.dmark)  
442d 32 a0 fd			ld (debug_mark),a  
4430 3a 3f 44			ld a, (.dmark+1)  
4433 32 a1 fd			ld (debug_mark+1),a  
4436 3a 40 44			ld a, (.dmark+2)  
4439 32 a2 fd			ld (debug_mark+2),a  
443c 18 03			jr .pastdmark  
443e ..			.dmark: db "HOM"  
4441 f1			.pastdmark: pop af  
4442			endm  
# End of macro DMARK
4442						CALLMONITOR 
4442 cd aa fd			call debug_vector  
4445				endm  
# End of macro CALLMONITOR
4445					endif 
4445 3e 00		.home:		ld a, 0		; and home cursor 
4447 32 93 f9				ld (f_cursor_ptr), a 
444a					NEXTW 
444a c3 37 24			jp macro_next 
444d				endm 
# End of macro NEXTW
444d			 
444d			 
444d			.CR: 
444d				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
444d 46				db WORD_SYS_CORE+50             
444e 88 44			dw .SPACE            
4450 03				db 2 + 1 
4451 .. 00			db "CR",0              
4454				endm 
# End of macro CWHEAD
4454			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
4454					if DEBUG_FORTH_WORDS_KEY 
4454						DMARK "CR." 
4454 f5				push af  
4455 3a 69 44			ld a, (.dmark)  
4458 32 a0 fd			ld (debug_mark),a  
445b 3a 6a 44			ld a, (.dmark+1)  
445e 32 a1 fd			ld (debug_mark+1),a  
4461 3a 6b 44			ld a, (.dmark+2)  
4464 32 a2 fd			ld (debug_mark+2),a  
4467 18 03			jr .pastdmark  
4469 ..			.dmark: db "CR."  
446c f1			.pastdmark: pop af  
446d			endm  
# End of macro DMARK
446d						CALLMONITOR 
446d cd aa fd			call debug_vector  
4470				endm  
# End of macro CALLMONITOR
4470					endif 
4470 3e 0d				ld a, 13 
4472 32 f6 f0				ld (scratch),a 
4475 3e 0a				ld a, 10 
4477 32 f7 f0				ld (scratch+1),a 
447a 3e 00				ld a, 0 
447c 32 f8 f0				ld (scratch+2),a 
447f 21 f6 f0				ld hl, scratch 
4482 cd b4 20				call forth_push_str 
4485					 
4485				       NEXTW 
4485 c3 37 24			jp macro_next 
4488				endm 
# End of macro NEXTW
4488			.SPACE: 
4488				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4488 46				db WORD_SYS_CORE+50             
4489 be 44			dw .SPACES            
448b 03				db 2 + 1 
448c .. 00			db "BL",0              
448f				endm 
# End of macro CWHEAD
448f			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
448f					if DEBUG_FORTH_WORDS_KEY 
448f						DMARK "BL." 
448f f5				push af  
4490 3a a4 44			ld a, (.dmark)  
4493 32 a0 fd			ld (debug_mark),a  
4496 3a a5 44			ld a, (.dmark+1)  
4499 32 a1 fd			ld (debug_mark+1),a  
449c 3a a6 44			ld a, (.dmark+2)  
449f 32 a2 fd			ld (debug_mark+2),a  
44a2 18 03			jr .pastdmark  
44a4 ..			.dmark: db "BL."  
44a7 f1			.pastdmark: pop af  
44a8			endm  
# End of macro DMARK
44a8						CALLMONITOR 
44a8 cd aa fd			call debug_vector  
44ab				endm  
# End of macro CALLMONITOR
44ab					endif 
44ab 3e 20				ld a, " " 
44ad 32 f6 f0				ld (scratch),a 
44b0 3e 00				ld a, 0 
44b2 32 f7 f0				ld (scratch+1),a 
44b5 21 f6 f0				ld hl, scratch 
44b8 cd b4 20				call forth_push_str 
44bb					 
44bb				       NEXTW 
44bb c3 37 24			jp macro_next 
44be				endm 
# End of macro NEXTW
44be			 
44be			;.blstr: db " ", 0 
44be			 
44be			.SPACES: 
44be				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
44be 47				db WORD_SYS_CORE+51             
44bf 59 45			dw .SCROLL            
44c1 07				db 6 + 1 
44c2 .. 00			db "SPACES",0              
44c9				endm 
# End of macro CWHEAD
44c9			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
44c9					if DEBUG_FORTH_WORDS_KEY 
44c9						DMARK "SPS" 
44c9 f5				push af  
44ca 3a de 44			ld a, (.dmark)  
44cd 32 a0 fd			ld (debug_mark),a  
44d0 3a df 44			ld a, (.dmark+1)  
44d3 32 a1 fd			ld (debug_mark+1),a  
44d6 3a e0 44			ld a, (.dmark+2)  
44d9 32 a2 fd			ld (debug_mark+2),a  
44dc 18 03			jr .pastdmark  
44de ..			.dmark: db "SPS"  
44e1 f1			.pastdmark: pop af  
44e2			endm  
# End of macro DMARK
44e2						CALLMONITOR 
44e2 cd aa fd			call debug_vector  
44e5				endm  
# End of macro CALLMONITOR
44e5					endif 
44e5			 
44e5			 
44e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44e5 cd 4b 22			call macro_dsp_valuehl 
44e8				endm 
# End of macro FORTH_DSP_VALUEHL
44e8			 
44e8 e5					push hl    ; u 
44e9					if DEBUG_FORTH_WORDS 
44e9						DMARK "SPA" 
44e9 f5				push af  
44ea 3a fe 44			ld a, (.dmark)  
44ed 32 a0 fd			ld (debug_mark),a  
44f0 3a ff 44			ld a, (.dmark+1)  
44f3 32 a1 fd			ld (debug_mark+1),a  
44f6 3a 00 45			ld a, (.dmark+2)  
44f9 32 a2 fd			ld (debug_mark+2),a  
44fc 18 03			jr .pastdmark  
44fe ..			.dmark: db "SPA"  
4501 f1			.pastdmark: pop af  
4502			endm  
# End of macro DMARK
4502						CALLMONITOR 
4502 cd aa fd			call debug_vector  
4505				endm  
# End of macro CALLMONITOR
4505					endif 
4505			 
4505					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4505 cd 03 23			call macro_forth_dsp_pop 
4508				endm 
# End of macro FORTH_DSP_POP
4508 e1					pop hl 
4509 0e 00				ld c, 0 
450b 45					ld b, l 
450c 21 f6 f0				ld hl, scratch  
450f			 
450f					if DEBUG_FORTH_WORDS 
450f						DMARK "SP2" 
450f f5				push af  
4510 3a 24 45			ld a, (.dmark)  
4513 32 a0 fd			ld (debug_mark),a  
4516 3a 25 45			ld a, (.dmark+1)  
4519 32 a1 fd			ld (debug_mark+1),a  
451c 3a 26 45			ld a, (.dmark+2)  
451f 32 a2 fd			ld (debug_mark+2),a  
4522 18 03			jr .pastdmark  
4524 ..			.dmark: db "SP2"  
4527 f1			.pastdmark: pop af  
4528			endm  
# End of macro DMARK
4528						CALLMONITOR 
4528 cd aa fd			call debug_vector  
452b				endm  
# End of macro CALLMONITOR
452b					endif 
452b 3e 20				ld a, ' ' 
452d			.spaces1:	 
452d 77					ld (hl),a 
452e 23					inc hl 
452f					 
452f 10 fc				djnz .spaces1 
4531 3e 00				ld a,0 
4533 77					ld (hl),a 
4534 21 f6 f0				ld hl, scratch 
4537					if DEBUG_FORTH_WORDS 
4537						DMARK "SP3" 
4537 f5				push af  
4538 3a 4c 45			ld a, (.dmark)  
453b 32 a0 fd			ld (debug_mark),a  
453e 3a 4d 45			ld a, (.dmark+1)  
4541 32 a1 fd			ld (debug_mark+1),a  
4544 3a 4e 45			ld a, (.dmark+2)  
4547 32 a2 fd			ld (debug_mark+2),a  
454a 18 03			jr .pastdmark  
454c ..			.dmark: db "SP3"  
454f f1			.pastdmark: pop af  
4550			endm  
# End of macro DMARK
4550						CALLMONITOR 
4550 cd aa fd			call debug_vector  
4553				endm  
# End of macro CALLMONITOR
4553					endif 
4553 cd b4 20				call forth_push_str 
4556			 
4556				       NEXTW 
4556 c3 37 24			jp macro_next 
4559				endm 
# End of macro NEXTW
4559			 
4559			 
4559			 
4559			.SCROLL: 
4559				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4559 53				db WORD_SYS_CORE+63             
455a 86 45			dw .SCROLLD            
455c 07				db 6 + 1 
455d .. 00			db "SCROLL",0              
4564				endm 
# End of macro CWHEAD
4564			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4564					if DEBUG_FORTH_WORDS_KEY 
4564						DMARK "SCR" 
4564 f5				push af  
4565 3a 79 45			ld a, (.dmark)  
4568 32 a0 fd			ld (debug_mark),a  
456b 3a 7a 45			ld a, (.dmark+1)  
456e 32 a1 fd			ld (debug_mark+1),a  
4571 3a 7b 45			ld a, (.dmark+2)  
4574 32 a2 fd			ld (debug_mark+2),a  
4577 18 03			jr .pastdmark  
4579 ..			.dmark: db "SCR"  
457c f1			.pastdmark: pop af  
457d			endm  
# End of macro DMARK
457d						CALLMONITOR 
457d cd aa fd			call debug_vector  
4580				endm  
# End of macro CALLMONITOR
4580					endif 
4580			 
4580 cd 6c 0d			call scroll_up 
4583			;	call update_display 
4583			 
4583					NEXTW 
4583 c3 37 24			jp macro_next 
4586				endm 
# End of macro NEXTW
4586			 
4586			 
4586			 
4586			;		; get dir 
4586			; 
4586			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4586			; 
4586			;		push hl 
4586			; 
4586			;		; destroy value TOS 
4586			; 
4586			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4586			; 
4586			;		; get count 
4586			; 
4586			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4586			; 
4586			;		push hl 
4586			; 
4586			;		; destroy value TOS 
4586			; 
4586			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4586			; 
4586			;		; one value on hl get other one back 
4586			; 
4586			;		pop bc    ; count 
4586			; 
4586			;		pop de   ; dir 
4586			; 
4586			; 
4586			;		ld b, c 
4586			; 
4586			;.scrolldir:     push bc 
4586			;		push de 
4586			; 
4586			;		ld a, 0 
4586			;		cp e 
4586			;		jr z, .scrollup  
4586			;		call scroll_down 
4586			;		jr .scrollnext 
4586			;.scrollup:	call scroll_up 
4586			; 
4586			;		 
4586			;.scrollnext: 
4586			;		pop de 
4586			;		pop bc 
4586			;		djnz .scrolldir 
4586			; 
4586			; 
4586			; 
4586			; 
4586			; 
4586			;		NEXTW 
4586			 
4586			.SCROLLD: 
4586				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4586 53				db WORD_SYS_CORE+63             
4587 b4 45			dw .ATQ            
4589 08				db 7 + 1 
458a .. 00			db "SCROLLD",0              
4592				endm 
# End of macro CWHEAD
4592			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4592					if DEBUG_FORTH_WORDS_KEY 
4592						DMARK "SCD" 
4592 f5				push af  
4593 3a a7 45			ld a, (.dmark)  
4596 32 a0 fd			ld (debug_mark),a  
4599 3a a8 45			ld a, (.dmark+1)  
459c 32 a1 fd			ld (debug_mark+1),a  
459f 3a a9 45			ld a, (.dmark+2)  
45a2 32 a2 fd			ld (debug_mark+2),a  
45a5 18 03			jr .pastdmark  
45a7 ..			.dmark: db "SCD"  
45aa f1			.pastdmark: pop af  
45ab			endm  
# End of macro DMARK
45ab						CALLMONITOR 
45ab cd aa fd			call debug_vector  
45ae				endm  
# End of macro CALLMONITOR
45ae					endif 
45ae			 
45ae cd 90 0d			call scroll_down 
45b1			;	call update_display 
45b1			 
45b1					NEXTW 
45b1 c3 37 24			jp macro_next 
45b4				endm 
# End of macro NEXTW
45b4			 
45b4			 
45b4			.ATQ: 
45b4				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
45b4 62				db WORD_SYS_CORE+78             
45b5 12 46			dw .AUTODSP            
45b7 04				db 3 + 1 
45b8 .. 00			db "AT@",0              
45bc				endm 
# End of macro CWHEAD
45bc			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
45bc					if DEBUG_FORTH_WORDS_KEY 
45bc						DMARK "ATA" 
45bc f5				push af  
45bd 3a d1 45			ld a, (.dmark)  
45c0 32 a0 fd			ld (debug_mark),a  
45c3 3a d2 45			ld a, (.dmark+1)  
45c6 32 a1 fd			ld (debug_mark+1),a  
45c9 3a d3 45			ld a, (.dmark+2)  
45cc 32 a2 fd			ld (debug_mark+2),a  
45cf 18 03			jr .pastdmark  
45d1 ..			.dmark: db "ATA"  
45d4 f1			.pastdmark: pop af  
45d5			endm  
# End of macro DMARK
45d5						CALLMONITOR 
45d5 cd aa fd			call debug_vector  
45d8				endm  
# End of macro CALLMONITOR
45d8					endif 
45d8			 
45d8			 
45d8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45d8 cd 4b 22			call macro_dsp_valuehl 
45db				endm 
# End of macro FORTH_DSP_VALUEHL
45db			 
45db					; TODO save cursor row 
45db 7d					ld a,l 
45dc fe 02				cp 2 
45de 20 04				jr nz, .crow3aq 
45e0 3e 28				ld a, display_row_2 
45e2 18 12				jr .ccol1aq 
45e4 fe 03		.crow3aq:		cp 3 
45e6 20 04				jr nz, .crow4aq 
45e8 3e 50				ld a, display_row_3 
45ea 18 0a				jr .ccol1aq 
45ec fe 04		.crow4aq:		cp 4 
45ee 20 04				jr nz, .crow1aq 
45f0 3e 78				ld a, display_row_4 
45f2 18 02				jr .ccol1aq 
45f4 3e 00		.crow1aq:		ld a,display_row_1 
45f6 f5			.ccol1aq:		push af			; got row offset 
45f7 6f					ld l,a 
45f8 26 00				ld h,0 
45fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45fa cd 03 23			call macro_forth_dsp_pop 
45fd				endm 
# End of macro FORTH_DSP_POP
45fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45fd cd 4b 22			call macro_dsp_valuehl 
4600				endm 
# End of macro FORTH_DSP_VALUEHL
4600					; TODO save cursor col 
4600 f1					pop af 
4601 85					add l		; add col offset 
4602			 
4602					; add current frame buffer address 
4602 2a 01 fb				ld hl, (display_fb_active) 
4605 cd de 0f				call addatohl 
4608			 
4608			 
4608			 
4608			 
4608					; get char frame buffer location offset in hl 
4608			 
4608 7e					ld a,(hl) 
4609 26 00				ld h, 0 
460b 6f					ld l, a 
460c			 
460c cd 46 20				call forth_push_numhl 
460f			 
460f			 
460f					NEXTW 
460f c3 37 24			jp macro_next 
4612				endm 
# End of macro NEXTW
4612			 
4612			.AUTODSP: 
4612				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4612 63				db WORD_SYS_CORE+79             
4613 28 46			dw .MENU            
4615 05				db 4 + 1 
4616 .. 00			db "ADSP",0              
461b				endm 
# End of macro CWHEAD
461b			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
461b			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
461b			 
461b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
461b cd 4b 22			call macro_dsp_valuehl 
461e				endm 
# End of macro FORTH_DSP_VALUEHL
461e			 
461e			;		push hl 
461e			 
461e					; destroy value TOS 
461e			 
461e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
461e cd 03 23			call macro_forth_dsp_pop 
4621				endm 
# End of macro FORTH_DSP_POP
4621			 
4621			;		pop hl 
4621			 
4621 7d					ld a,l 
4622 32 71 f9				ld (cli_autodisplay), a 
4625				       NEXTW 
4625 c3 37 24			jp macro_next 
4628				endm 
# End of macro NEXTW
4628			 
4628			.MENU: 
4628				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4628 70				db WORD_SYS_CORE+92             
4629 d1 46			dw .ENDDISPLAY            
462b 05				db 4 + 1 
462c .. 00			db "MENU",0              
4631				endm 
# End of macro CWHEAD
4631			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
4631			 
4631			;		; get number of items on the stack 
4631			; 
4631				 
4631					FORTH_DSP_VALUEHL 
4631 cd 4b 22			call macro_dsp_valuehl 
4634				endm 
# End of macro FORTH_DSP_VALUEHL
4634				 
4634					if DEBUG_FORTH_WORDS_KEY 
4634						DMARK "MNU" 
4634 f5				push af  
4635 3a 49 46			ld a, (.dmark)  
4638 32 a0 fd			ld (debug_mark),a  
463b 3a 4a 46			ld a, (.dmark+1)  
463e 32 a1 fd			ld (debug_mark+1),a  
4641 3a 4b 46			ld a, (.dmark+2)  
4644 32 a2 fd			ld (debug_mark+2),a  
4647 18 03			jr .pastdmark  
4649 ..			.dmark: db "MNU"  
464c f1			.pastdmark: pop af  
464d			endm  
# End of macro DMARK
464d						CALLMONITOR 
464d cd aa fd			call debug_vector  
4650				endm  
# End of macro CALLMONITOR
4650					endif 
4650			 
4650 45					ld b, l	 
4651 05					dec b 
4652			 
4652					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4652 cd 03 23			call macro_forth_dsp_pop 
4655				endm 
# End of macro FORTH_DSP_POP
4655			 
4655			 
4655					; go directly through the stack to pluck out the string pointers and build an array 
4655			 
4655			;		FORTH_DSP 
4655			 
4655					; hl contains top most stack item 
4655				 
4655 11 f6 f0				ld de, scratch 
4658			 
4658			.mbuild: 
4658			 
4658					FORTH_DSP_VALUEHL 
4658 cd 4b 22			call macro_dsp_valuehl 
465b				endm 
# End of macro FORTH_DSP_VALUEHL
465b			 
465b					if DEBUG_FORTH_WORDS 
465b						DMARK "MN3" 
465b f5				push af  
465c 3a 70 46			ld a, (.dmark)  
465f 32 a0 fd			ld (debug_mark),a  
4662 3a 71 46			ld a, (.dmark+1)  
4665 32 a1 fd			ld (debug_mark+1),a  
4668 3a 72 46			ld a, (.dmark+2)  
466b 32 a2 fd			ld (debug_mark+2),a  
466e 18 03			jr .pastdmark  
4670 ..			.dmark: db "MN3"  
4673 f1			.pastdmark: pop af  
4674			endm  
# End of macro DMARK
4674						CALLMONITOR 
4674 cd aa fd			call debug_vector  
4677				endm  
# End of macro CALLMONITOR
4677					endif 
4677 eb					ex de, hl 
4678 73					ld (hl), e 
4679 23					inc hl 
467a 72					ld (hl), d 
467b 23					inc hl 
467c eb					ex de, hl 
467d			 
467d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
467d cd 03 23			call macro_forth_dsp_pop 
4680				endm 
# End of macro FORTH_DSP_POP
4680			 
4680 10 d6				djnz .mbuild 
4682			 
4682					; done add term 
4682			 
4682 eb					ex de, hl 
4683 36 00				ld (hl), 0 
4685 23					inc hl 
4686 36 00				ld (hl), 0 
4688			 
4688				 
4688					 
4688 21 f6 f0				ld hl, scratch 
468b			 
468b					if DEBUG_FORTH_WORDS 
468b						DMARK "MNx" 
468b f5				push af  
468c 3a a0 46			ld a, (.dmark)  
468f 32 a0 fd			ld (debug_mark),a  
4692 3a a1 46			ld a, (.dmark+1)  
4695 32 a1 fd			ld (debug_mark+1),a  
4698 3a a2 46			ld a, (.dmark+2)  
469b 32 a2 fd			ld (debug_mark+2),a  
469e 18 03			jr .pastdmark  
46a0 ..			.dmark: db "MNx"  
46a3 f1			.pastdmark: pop af  
46a4			endm  
# End of macro DMARK
46a4						CALLMONITOR 
46a4 cd aa fd			call debug_vector  
46a7				endm  
# End of macro CALLMONITOR
46a7					endif 
46a7			 
46a7			 
46a7			 
46a7 3e 00				ld a, 0 
46a9 cd db 0d				call menu 
46ac			 
46ac			 
46ac 6f					ld l, a 
46ad 26 00				ld h, 0 
46af			 
46af					if DEBUG_FORTH_WORDS 
46af						DMARK "MNr" 
46af f5				push af  
46b0 3a c4 46			ld a, (.dmark)  
46b3 32 a0 fd			ld (debug_mark),a  
46b6 3a c5 46			ld a, (.dmark+1)  
46b9 32 a1 fd			ld (debug_mark+1),a  
46bc 3a c6 46			ld a, (.dmark+2)  
46bf 32 a2 fd			ld (debug_mark+2),a  
46c2 18 03			jr .pastdmark  
46c4 ..			.dmark: db "MNr"  
46c7 f1			.pastdmark: pop af  
46c8			endm  
# End of macro DMARK
46c8						CALLMONITOR 
46c8 cd aa fd			call debug_vector  
46cb				endm  
# End of macro CALLMONITOR
46cb					endif 
46cb			 
46cb cd 46 20				call forth_push_numhl 
46ce			 
46ce			 
46ce			 
46ce			 
46ce				       NEXTW 
46ce c3 37 24			jp macro_next 
46d1				endm 
# End of macro NEXTW
46d1			 
46d1			 
46d1			.ENDDISPLAY: 
46d1			 
46d1			; eof 
# End of file forth_words_display.asm
46d1			include "forth_words_str.asm" 
46d1			 
46d1			; | ## String Words 
46d1			 
46d1			.PTR:   
46d1			 
46d1				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
46d1 48				db WORD_SYS_CORE+52             
46d2 fe 46			dw .STYPE            
46d4 04				db 3 + 1 
46d5 .. 00			db "PTR",0              
46d9				endm 
# End of macro CWHEAD
46d9			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
46d9			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
46d9			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
46d9			 
46d9					if DEBUG_FORTH_WORDS_KEY 
46d9						DMARK "PTR" 
46d9 f5				push af  
46da 3a ee 46			ld a, (.dmark)  
46dd 32 a0 fd			ld (debug_mark),a  
46e0 3a ef 46			ld a, (.dmark+1)  
46e3 32 a1 fd			ld (debug_mark+1),a  
46e6 3a f0 46			ld a, (.dmark+2)  
46e9 32 a2 fd			ld (debug_mark+2),a  
46ec 18 03			jr .pastdmark  
46ee ..			.dmark: db "PTR"  
46f1 f1			.pastdmark: pop af  
46f2			endm  
# End of macro DMARK
46f2						CALLMONITOR 
46f2 cd aa fd			call debug_vector  
46f5				endm  
# End of macro CALLMONITOR
46f5					endif 
46f5					FORTH_DSP_VALUEHL 
46f5 cd 4b 22			call macro_dsp_valuehl 
46f8				endm 
# End of macro FORTH_DSP_VALUEHL
46f8 cd 46 20				call forth_push_numhl 
46fb			 
46fb			 
46fb					NEXTW 
46fb c3 37 24			jp macro_next 
46fe				endm 
# End of macro NEXTW
46fe			.STYPE: 
46fe				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
46fe 48				db WORD_SYS_CORE+52             
46ff 4d 47			dw .UPPER            
4701 06				db 5 + 1 
4702 .. 00			db "STYPE",0              
4708				endm 
# End of macro CWHEAD
4708			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4708					if DEBUG_FORTH_WORDS_KEY 
4708						DMARK "STY" 
4708 f5				push af  
4709 3a 1d 47			ld a, (.dmark)  
470c 32 a0 fd			ld (debug_mark),a  
470f 3a 1e 47			ld a, (.dmark+1)  
4712 32 a1 fd			ld (debug_mark+1),a  
4715 3a 1f 47			ld a, (.dmark+2)  
4718 32 a2 fd			ld (debug_mark+2),a  
471b 18 03			jr .pastdmark  
471d ..			.dmark: db "STY"  
4720 f1			.pastdmark: pop af  
4721			endm  
# End of macro DMARK
4721						CALLMONITOR 
4721 cd aa fd			call debug_vector  
4724				endm  
# End of macro CALLMONITOR
4724					endif 
4724					FORTH_DSP 
4724 cd 11 22			call macro_forth_dsp 
4727				endm 
# End of macro FORTH_DSP
4727					;v5 FORTH_DSP_VALUE 
4727			 
4727 7e					ld a, (hl) 
4728			 
4728 f5					push af 
4729			 
4729			; Dont destroy TOS		FORTH_DSP_POP 
4729			 
4729 f1					pop af 
472a			 
472a fe 01				cp DS_TYPE_STR 
472c 28 09				jr z, .typestr 
472e			 
472e fe 02				cp DS_TYPE_INUM 
4730 28 0a				jr z, .typeinum 
4732			 
4732 21 4b 47				ld hl, .tna 
4735 18 0a				jr .tpush 
4737			 
4737 21 47 47		.typestr:	ld hl, .tstr 
473a 18 05				jr .tpush 
473c 21 49 47		.typeinum:	ld hl, .tinum 
473f 18 00				jr .tpush 
4741			 
4741			.tpush: 
4741			 
4741 cd b4 20				call forth_push_str 
4744			 
4744					NEXTW 
4744 c3 37 24			jp macro_next 
4747				endm 
# End of macro NEXTW
4747 .. 00		.tstr:	db "s",0 
4749 .. 00		.tinum:  db "i",0 
474b .. 00		.tna:   db "?", 0 
474d			 
474d			 
474d			.UPPER: 
474d				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
474d 48				db WORD_SYS_CORE+52             
474e 88 47			dw .LOWER            
4750 06				db 5 + 1 
4751 .. 00			db "UPPER",0              
4757				endm 
# End of macro CWHEAD
4757			; | UPPER ( s -- s ) Upper case string s  | DONE 
4757					if DEBUG_FORTH_WORDS_KEY 
4757						DMARK "UPR" 
4757 f5				push af  
4758 3a 6c 47			ld a, (.dmark)  
475b 32 a0 fd			ld (debug_mark),a  
475e 3a 6d 47			ld a, (.dmark+1)  
4761 32 a1 fd			ld (debug_mark+1),a  
4764 3a 6e 47			ld a, (.dmark+2)  
4767 32 a2 fd			ld (debug_mark+2),a  
476a 18 03			jr .pastdmark  
476c ..			.dmark: db "UPR"  
476f f1			.pastdmark: pop af  
4770			endm  
# End of macro DMARK
4770						CALLMONITOR 
4770 cd aa fd			call debug_vector  
4773				endm  
# End of macro CALLMONITOR
4773					endif 
4773			 
4773					FORTH_DSP 
4773 cd 11 22			call macro_forth_dsp 
4776				endm 
# End of macro FORTH_DSP
4776					 
4776			; TODO check is string type 
4776			 
4776					FORTH_DSP_VALUEHL 
4776 cd 4b 22			call macro_dsp_valuehl 
4779				endm 
# End of macro FORTH_DSP_VALUEHL
4779			; get pointer to string in hl 
4779			 
4779 7e			.toup:		ld a, (hl) 
477a fe 00				cp 0 
477c 28 07				jr z, .toupdone 
477e			 
477e cd 53 12				call to_upper 
4781			 
4781 77					ld (hl), a 
4782 23					inc hl 
4783 18 f4				jr .toup 
4785			 
4785					 
4785			 
4785			 
4785			; for each char convert to upper 
4785					 
4785			.toupdone: 
4785			 
4785			 
4785					NEXTW 
4785 c3 37 24			jp macro_next 
4788				endm 
# End of macro NEXTW
4788			.LOWER: 
4788				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4788 48				db WORD_SYS_CORE+52             
4789 c3 47			dw .TCASE            
478b 06				db 5 + 1 
478c .. 00			db "LOWER",0              
4792				endm 
# End of macro CWHEAD
4792			; | LOWER ( s -- s ) Lower case string s  | DONE 
4792					if DEBUG_FORTH_WORDS_KEY 
4792						DMARK "LWR" 
4792 f5				push af  
4793 3a a7 47			ld a, (.dmark)  
4796 32 a0 fd			ld (debug_mark),a  
4799 3a a8 47			ld a, (.dmark+1)  
479c 32 a1 fd			ld (debug_mark+1),a  
479f 3a a9 47			ld a, (.dmark+2)  
47a2 32 a2 fd			ld (debug_mark+2),a  
47a5 18 03			jr .pastdmark  
47a7 ..			.dmark: db "LWR"  
47aa f1			.pastdmark: pop af  
47ab			endm  
# End of macro DMARK
47ab						CALLMONITOR 
47ab cd aa fd			call debug_vector  
47ae				endm  
# End of macro CALLMONITOR
47ae					endif 
47ae			 
47ae					FORTH_DSP 
47ae cd 11 22			call macro_forth_dsp 
47b1				endm 
# End of macro FORTH_DSP
47b1					 
47b1			; TODO check is string type 
47b1			 
47b1					FORTH_DSP_VALUEHL 
47b1 cd 4b 22			call macro_dsp_valuehl 
47b4				endm 
# End of macro FORTH_DSP_VALUEHL
47b4			; get pointer to string in hl 
47b4			 
47b4 7e			.tolow:		ld a, (hl) 
47b5 fe 00				cp 0 
47b7 28 07				jr z, .tolowdone 
47b9			 
47b9 cd 5c 12				call to_lower 
47bc			 
47bc 77					ld (hl), a 
47bd 23					inc hl 
47be 18 f4				jr .tolow 
47c0			 
47c0					 
47c0			 
47c0			 
47c0			; for each char convert to low 
47c0					 
47c0			.tolowdone: 
47c0					NEXTW 
47c0 c3 37 24			jp macro_next 
47c3				endm 
# End of macro NEXTW
47c3			.TCASE: 
47c3				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
47c3 48				db WORD_SYS_CORE+52             
47c4 f9 48			dw .SUBSTR            
47c6 06				db 5 + 1 
47c7 .. 00			db "TCASE",0              
47cd				endm 
# End of macro CWHEAD
47cd			; | TCASE ( s -- s ) Title case string s  | DONE 
47cd					if DEBUG_FORTH_WORDS_KEY 
47cd						DMARK "TCS" 
47cd f5				push af  
47ce 3a e2 47			ld a, (.dmark)  
47d1 32 a0 fd			ld (debug_mark),a  
47d4 3a e3 47			ld a, (.dmark+1)  
47d7 32 a1 fd			ld (debug_mark+1),a  
47da 3a e4 47			ld a, (.dmark+2)  
47dd 32 a2 fd			ld (debug_mark+2),a  
47e0 18 03			jr .pastdmark  
47e2 ..			.dmark: db "TCS"  
47e5 f1			.pastdmark: pop af  
47e6			endm  
# End of macro DMARK
47e6						CALLMONITOR 
47e6 cd aa fd			call debug_vector  
47e9				endm  
# End of macro CALLMONITOR
47e9					endif 
47e9			 
47e9					FORTH_DSP 
47e9 cd 11 22			call macro_forth_dsp 
47ec				endm 
# End of macro FORTH_DSP
47ec					 
47ec			; TODO check is string type 
47ec			 
47ec					FORTH_DSP_VALUEHL 
47ec cd 4b 22			call macro_dsp_valuehl 
47ef				endm 
# End of macro FORTH_DSP_VALUEHL
47ef			; get pointer to string in hl 
47ef			 
47ef					if DEBUG_FORTH_WORDS 
47ef						DMARK "TC1" 
47ef f5				push af  
47f0 3a 04 48			ld a, (.dmark)  
47f3 32 a0 fd			ld (debug_mark),a  
47f6 3a 05 48			ld a, (.dmark+1)  
47f9 32 a1 fd			ld (debug_mark+1),a  
47fc 3a 06 48			ld a, (.dmark+2)  
47ff 32 a2 fd			ld (debug_mark+2),a  
4802 18 03			jr .pastdmark  
4804 ..			.dmark: db "TC1"  
4807 f1			.pastdmark: pop af  
4808			endm  
# End of macro DMARK
4808						CALLMONITOR 
4808 cd aa fd			call debug_vector  
480b				endm  
# End of macro CALLMONITOR
480b					endif 
480b			 
480b					; first time in turn to upper case first char 
480b			 
480b 7e					ld a, (hl) 
480c c3 96 48				jp .totsiptou 
480f			 
480f			 
480f 7e			.tot:		ld a, (hl) 
4810 fe 00				cp 0 
4812 ca da 48				jp z, .totdone 
4815			 
4815					if DEBUG_FORTH_WORDS 
4815						DMARK "TC2" 
4815 f5				push af  
4816 3a 2a 48			ld a, (.dmark)  
4819 32 a0 fd			ld (debug_mark),a  
481c 3a 2b 48			ld a, (.dmark+1)  
481f 32 a1 fd			ld (debug_mark+1),a  
4822 3a 2c 48			ld a, (.dmark+2)  
4825 32 a2 fd			ld (debug_mark+2),a  
4828 18 03			jr .pastdmark  
482a ..			.dmark: db "TC2"  
482d f1			.pastdmark: pop af  
482e			endm  
# End of macro DMARK
482e						CALLMONITOR 
482e cd aa fd			call debug_vector  
4831				endm  
# End of macro CALLMONITOR
4831					endif 
4831					; check to see if current char is a space 
4831			 
4831 fe 20				cp ' ' 
4833 28 21				jr z, .totsp 
4835 cd 5c 12				call to_lower 
4838					if DEBUG_FORTH_WORDS 
4838						DMARK "TC3" 
4838 f5				push af  
4839 3a 4d 48			ld a, (.dmark)  
483c 32 a0 fd			ld (debug_mark),a  
483f 3a 4e 48			ld a, (.dmark+1)  
4842 32 a1 fd			ld (debug_mark+1),a  
4845 3a 4f 48			ld a, (.dmark+2)  
4848 32 a2 fd			ld (debug_mark+2),a  
484b 18 03			jr .pastdmark  
484d ..			.dmark: db "TC3"  
4850 f1			.pastdmark: pop af  
4851			endm  
# End of macro DMARK
4851						CALLMONITOR 
4851 cd aa fd			call debug_vector  
4854				endm  
# End of macro CALLMONITOR
4854					endif 
4854 18 63				jr .totnxt 
4856			 
4856			.totsp:         ; on a space, find next char which should be upper 
4856			 
4856					if DEBUG_FORTH_WORDS 
4856						DMARK "TC4" 
4856 f5				push af  
4857 3a 6b 48			ld a, (.dmark)  
485a 32 a0 fd			ld (debug_mark),a  
485d 3a 6c 48			ld a, (.dmark+1)  
4860 32 a1 fd			ld (debug_mark+1),a  
4863 3a 6d 48			ld a, (.dmark+2)  
4866 32 a2 fd			ld (debug_mark+2),a  
4869 18 03			jr .pastdmark  
486b ..			.dmark: db "TC4"  
486e f1			.pastdmark: pop af  
486f			endm  
# End of macro DMARK
486f						CALLMONITOR 
486f cd aa fd			call debug_vector  
4872				endm  
# End of macro CALLMONITOR
4872					endif 
4872					;; 
4872			 
4872 fe 20				cp ' ' 
4874 20 20				jr nz, .totsiptou 
4876 23					inc hl 
4877 7e					ld a, (hl) 
4878					if DEBUG_FORTH_WORDS 
4878						DMARK "TC5" 
4878 f5				push af  
4879 3a 8d 48			ld a, (.dmark)  
487c 32 a0 fd			ld (debug_mark),a  
487f 3a 8e 48			ld a, (.dmark+1)  
4882 32 a1 fd			ld (debug_mark+1),a  
4885 3a 8f 48			ld a, (.dmark+2)  
4888 32 a2 fd			ld (debug_mark+2),a  
488b 18 03			jr .pastdmark  
488d ..			.dmark: db "TC5"  
4890 f1			.pastdmark: pop af  
4891			endm  
# End of macro DMARK
4891						CALLMONITOR 
4891 cd aa fd			call debug_vector  
4894				endm  
# End of macro CALLMONITOR
4894					endif 
4894 18 c0				jr .totsp 
4896 fe 00		.totsiptou:    cp 0 
4898 28 40				jr z, .totdone 
489a					; not space and not zero term so upper case it 
489a cd 53 12				call to_upper 
489d			 
489d					if DEBUG_FORTH_WORDS 
489d						DMARK "TC6" 
489d f5				push af  
489e 3a b2 48			ld a, (.dmark)  
48a1 32 a0 fd			ld (debug_mark),a  
48a4 3a b3 48			ld a, (.dmark+1)  
48a7 32 a1 fd			ld (debug_mark+1),a  
48aa 3a b4 48			ld a, (.dmark+2)  
48ad 32 a2 fd			ld (debug_mark+2),a  
48b0 18 03			jr .pastdmark  
48b2 ..			.dmark: db "TC6"  
48b5 f1			.pastdmark: pop af  
48b6			endm  
# End of macro DMARK
48b6						CALLMONITOR 
48b6 cd aa fd			call debug_vector  
48b9				endm  
# End of macro CALLMONITOR
48b9					endif 
48b9			 
48b9			 
48b9			.totnxt: 
48b9			 
48b9 77					ld (hl), a 
48ba 23					inc hl 
48bb					if DEBUG_FORTH_WORDS 
48bb						DMARK "TC7" 
48bb f5				push af  
48bc 3a d0 48			ld a, (.dmark)  
48bf 32 a0 fd			ld (debug_mark),a  
48c2 3a d1 48			ld a, (.dmark+1)  
48c5 32 a1 fd			ld (debug_mark+1),a  
48c8 3a d2 48			ld a, (.dmark+2)  
48cb 32 a2 fd			ld (debug_mark+2),a  
48ce 18 03			jr .pastdmark  
48d0 ..			.dmark: db "TC7"  
48d3 f1			.pastdmark: pop af  
48d4			endm  
# End of macro DMARK
48d4						CALLMONITOR 
48d4 cd aa fd			call debug_vector  
48d7				endm  
# End of macro CALLMONITOR
48d7					endif 
48d7 c3 0f 48				jp .tot 
48da			 
48da					 
48da			 
48da			 
48da			; for each char convert to low 
48da					 
48da			.totdone: 
48da					if DEBUG_FORTH_WORDS 
48da						DMARK "TCd" 
48da f5				push af  
48db 3a ef 48			ld a, (.dmark)  
48de 32 a0 fd			ld (debug_mark),a  
48e1 3a f0 48			ld a, (.dmark+1)  
48e4 32 a1 fd			ld (debug_mark+1),a  
48e7 3a f1 48			ld a, (.dmark+2)  
48ea 32 a2 fd			ld (debug_mark+2),a  
48ed 18 03			jr .pastdmark  
48ef ..			.dmark: db "TCd"  
48f2 f1			.pastdmark: pop af  
48f3			endm  
# End of macro DMARK
48f3						CALLMONITOR 
48f3 cd aa fd			call debug_vector  
48f6				endm  
# End of macro CALLMONITOR
48f6					endif 
48f6					NEXTW 
48f6 c3 37 24			jp macro_next 
48f9				endm 
# End of macro NEXTW
48f9			 
48f9			.SUBSTR: 
48f9				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
48f9 48				db WORD_SYS_CORE+52             
48fa 57 49			dw .LEFT            
48fc 07				db 6 + 1 
48fd .. 00			db "SUBSTR",0              
4904				endm 
# End of macro CWHEAD
4904			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4904			 
4904					if DEBUG_FORTH_WORDS_KEY 
4904						DMARK "SST" 
4904 f5				push af  
4905 3a 19 49			ld a, (.dmark)  
4908 32 a0 fd			ld (debug_mark),a  
490b 3a 1a 49			ld a, (.dmark+1)  
490e 32 a1 fd			ld (debug_mark+1),a  
4911 3a 1b 49			ld a, (.dmark+2)  
4914 32 a2 fd			ld (debug_mark+2),a  
4917 18 03			jr .pastdmark  
4919 ..			.dmark: db "SST"  
491c f1			.pastdmark: pop af  
491d			endm  
# End of macro DMARK
491d						CALLMONITOR 
491d cd aa fd			call debug_vector  
4920				endm  
# End of macro CALLMONITOR
4920					endif 
4920			; TODO check string type 
4920					FORTH_DSP_VALUEHL 
4920 cd 4b 22			call macro_dsp_valuehl 
4923				endm 
# End of macro FORTH_DSP_VALUEHL
4923			 
4923 e5					push hl      ; string length 
4924			 
4924					FORTH_DSP_POP 
4924 cd 03 23			call macro_forth_dsp_pop 
4927				endm 
# End of macro FORTH_DSP_POP
4927			 
4927					FORTH_DSP_VALUEHL 
4927 cd 4b 22			call macro_dsp_valuehl 
492a				endm 
# End of macro FORTH_DSP_VALUEHL
492a			 
492a e5					push hl     ; start char 
492b			 
492b					FORTH_DSP_POP 
492b cd 03 23			call macro_forth_dsp_pop 
492e				endm 
# End of macro FORTH_DSP_POP
492e			 
492e			 
492e					FORTH_DSP_VALUE 
492e cd 34 22			call macro_forth_dsp_value 
4931				endm 
# End of macro FORTH_DSP_VALUE
4931			 
4931 d1					pop de    ; get start post offset 
4932			 
4932 19					add hl, de    ; starting offset 
4933			 
4933 c1					pop bc 
4934 c5					push bc      ; grab size of string 
4935			 
4935 e5					push hl    ; save string start  
4936			 
4936 26 00				ld h, 0 
4938 69					ld l, c 
4939 23					inc hl 
493a 23					inc hl 
493b			 
493b cd b9 13				call malloc 
493e				if DEBUG_FORTH_MALLOC_GUARD 
493e cc 84 5e				call z,malloc_error 
4941				endif 
4941			 
4941 eb					ex de, hl      ; save malloc area for string copy 
4942 e1					pop hl    ; get back source 
4943 c1					pop bc    ; get length of string back 
4944			 
4944 d5					push de    ; save malloc area for after we push 
4945 ed b0				ldir     ; copy substr 
4947			 
4947			 
4947 eb					ex de, hl 
4948 3e 00				ld a, 0 
494a 77					ld (hl), a   ; term substr 
494b			 
494b					 
494b e1					pop hl    ; get malloc so we can push it 
494c e5					push hl   ; save so we can free it afterwards 
494d			 
494d cd b4 20				call forth_push_str 
4950			 
4950 e1					pop hl 
4951 cd 83 14				call free 
4954			 
4954					 
4954					 
4954			 
4954			 
4954					NEXTW 
4954 c3 37 24			jp macro_next 
4957				endm 
# End of macro NEXTW
4957			 
4957			.LEFT: 
4957				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4957 48				db WORD_SYS_CORE+52             
4958 7f 49			dw .RIGHT            
495a 05				db 4 + 1 
495b .. 00			db "LEFT",0              
4960				endm 
# End of macro CWHEAD
4960			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4960					if DEBUG_FORTH_WORDS_KEY 
4960						DMARK "LEF" 
4960 f5				push af  
4961 3a 75 49			ld a, (.dmark)  
4964 32 a0 fd			ld (debug_mark),a  
4967 3a 76 49			ld a, (.dmark+1)  
496a 32 a1 fd			ld (debug_mark+1),a  
496d 3a 77 49			ld a, (.dmark+2)  
4970 32 a2 fd			ld (debug_mark+2),a  
4973 18 03			jr .pastdmark  
4975 ..			.dmark: db "LEF"  
4978 f1			.pastdmark: pop af  
4979			endm  
# End of macro DMARK
4979						CALLMONITOR 
4979 cd aa fd			call debug_vector  
497c				endm  
# End of macro CALLMONITOR
497c					endif 
497c			 
497c					NEXTW 
497c c3 37 24			jp macro_next 
497f				endm 
# End of macro NEXTW
497f			.RIGHT: 
497f				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
497f 48				db WORD_SYS_CORE+52             
4980 a8 49			dw .STR2NUM            
4982 06				db 5 + 1 
4983 .. 00			db "RIGHT",0              
4989				endm 
# End of macro CWHEAD
4989			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4989					if DEBUG_FORTH_WORDS_KEY 
4989						DMARK "RIG" 
4989 f5				push af  
498a 3a 9e 49			ld a, (.dmark)  
498d 32 a0 fd			ld (debug_mark),a  
4990 3a 9f 49			ld a, (.dmark+1)  
4993 32 a1 fd			ld (debug_mark+1),a  
4996 3a a0 49			ld a, (.dmark+2)  
4999 32 a2 fd			ld (debug_mark+2),a  
499c 18 03			jr .pastdmark  
499e ..			.dmark: db "RIG"  
49a1 f1			.pastdmark: pop af  
49a2			endm  
# End of macro DMARK
49a2						CALLMONITOR 
49a2 cd aa fd			call debug_vector  
49a5				endm  
# End of macro CALLMONITOR
49a5					endif 
49a5			 
49a5					NEXTW 
49a5 c3 37 24			jp macro_next 
49a8				endm 
# End of macro NEXTW
49a8			 
49a8			 
49a8			.STR2NUM: 
49a8				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
49a8 48				db WORD_SYS_CORE+52             
49a9 34 4a			dw .NUM2STR            
49ab 08				db 7 + 1 
49ac .. 00			db "STR2NUM",0              
49b4				endm 
# End of macro CWHEAD
49b4			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
49b4			 
49b4			 
49b4			; TODO STR type check to do 
49b4					if DEBUG_FORTH_WORDS_KEY 
49b4						DMARK "S2N" 
49b4 f5				push af  
49b5 3a c9 49			ld a, (.dmark)  
49b8 32 a0 fd			ld (debug_mark),a  
49bb 3a ca 49			ld a, (.dmark+1)  
49be 32 a1 fd			ld (debug_mark+1),a  
49c1 3a cb 49			ld a, (.dmark+2)  
49c4 32 a2 fd			ld (debug_mark+2),a  
49c7 18 03			jr .pastdmark  
49c9 ..			.dmark: db "S2N"  
49cc f1			.pastdmark: pop af  
49cd			endm  
# End of macro DMARK
49cd						CALLMONITOR 
49cd cd aa fd			call debug_vector  
49d0				endm  
# End of macro CALLMONITOR
49d0					endif 
49d0			 
49d0					;FORTH_DSP 
49d0					FORTH_DSP_VALUE 
49d0 cd 34 22			call macro_forth_dsp_value 
49d3				endm 
# End of macro FORTH_DSP_VALUE
49d3					;inc hl 
49d3			 
49d3 eb					ex de, hl 
49d4					if DEBUG_FORTH_WORDS 
49d4						DMARK "S2a" 
49d4 f5				push af  
49d5 3a e9 49			ld a, (.dmark)  
49d8 32 a0 fd			ld (debug_mark),a  
49db 3a ea 49			ld a, (.dmark+1)  
49de 32 a1 fd			ld (debug_mark+1),a  
49e1 3a eb 49			ld a, (.dmark+2)  
49e4 32 a2 fd			ld (debug_mark+2),a  
49e7 18 03			jr .pastdmark  
49e9 ..			.dmark: db "S2a"  
49ec f1			.pastdmark: pop af  
49ed			endm  
# End of macro DMARK
49ed						CALLMONITOR 
49ed cd aa fd			call debug_vector  
49f0				endm  
# End of macro CALLMONITOR
49f0					endif 
49f0 cd db 12				call string_to_uint16 
49f3			 
49f3					if DEBUG_FORTH_WORDS 
49f3						DMARK "S2b" 
49f3 f5				push af  
49f4 3a 08 4a			ld a, (.dmark)  
49f7 32 a0 fd			ld (debug_mark),a  
49fa 3a 09 4a			ld a, (.dmark+1)  
49fd 32 a1 fd			ld (debug_mark+1),a  
4a00 3a 0a 4a			ld a, (.dmark+2)  
4a03 32 a2 fd			ld (debug_mark+2),a  
4a06 18 03			jr .pastdmark  
4a08 ..			.dmark: db "S2b"  
4a0b f1			.pastdmark: pop af  
4a0c			endm  
# End of macro DMARK
4a0c						CALLMONITOR 
4a0c cd aa fd			call debug_vector  
4a0f				endm  
# End of macro CALLMONITOR
4a0f					endif 
4a0f			;		push hl 
4a0f					FORTH_DSP_POP 
4a0f cd 03 23			call macro_forth_dsp_pop 
4a12				endm 
# End of macro FORTH_DSP_POP
4a12			;		pop hl 
4a12					 
4a12					if DEBUG_FORTH_WORDS 
4a12						DMARK "S2b" 
4a12 f5				push af  
4a13 3a 27 4a			ld a, (.dmark)  
4a16 32 a0 fd			ld (debug_mark),a  
4a19 3a 28 4a			ld a, (.dmark+1)  
4a1c 32 a1 fd			ld (debug_mark+1),a  
4a1f 3a 29 4a			ld a, (.dmark+2)  
4a22 32 a2 fd			ld (debug_mark+2),a  
4a25 18 03			jr .pastdmark  
4a27 ..			.dmark: db "S2b"  
4a2a f1			.pastdmark: pop af  
4a2b			endm  
# End of macro DMARK
4a2b						CALLMONITOR 
4a2b cd aa fd			call debug_vector  
4a2e				endm  
# End of macro CALLMONITOR
4a2e					endif 
4a2e cd 46 20				call forth_push_numhl	 
4a31			 
4a31				 
4a31				       NEXTW 
4a31 c3 37 24			jp macro_next 
4a34				endm 
# End of macro NEXTW
4a34			.NUM2STR: 
4a34				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4a34 48				db WORD_SYS_CORE+52             
4a35 43 4a			dw .CONCAT            
4a37 08				db 7 + 1 
4a38 .. 00			db "NUM2STR",0              
4a40				endm 
# End of macro CWHEAD
4a40			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
4a40			 
4a40			;		; malloc a string to target 
4a40			;		ld hl, 10     ; TODO max string size should be fine 
4a40			;		call malloc 
4a40			;		push hl    ; save malloc location 
4a40			; 
4a40			; 
4a40			;; TODO check int type 
4a40			;		FORTH_DSP_VALUEHL 
4a40			;		ld a, l 
4a40			;		call DispAToASCII   
4a40			;;TODO need to chage above call to dump into string 
4a40			; 
4a40			; 
4a40			 
4a40				       NEXTW 
4a40 c3 37 24			jp macro_next 
4a43				endm 
# End of macro NEXTW
4a43			 
4a43			.CONCAT: 
4a43				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4a43 48				db WORD_SYS_CORE+52             
4a44 f6 4a			dw .FIND            
4a46 07				db 6 + 1 
4a47 .. 00			db "CONCAT",0              
4a4e				endm 
# End of macro CWHEAD
4a4e			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4a4e			 
4a4e			; TODO check string type 
4a4e			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4a4e			 
4a4e					if DEBUG_FORTH_WORDS_KEY 
4a4e						DMARK "CON" 
4a4e f5				push af  
4a4f 3a 63 4a			ld a, (.dmark)  
4a52 32 a0 fd			ld (debug_mark),a  
4a55 3a 64 4a			ld a, (.dmark+1)  
4a58 32 a1 fd			ld (debug_mark+1),a  
4a5b 3a 65 4a			ld a, (.dmark+2)  
4a5e 32 a2 fd			ld (debug_mark+2),a  
4a61 18 03			jr .pastdmark  
4a63 ..			.dmark: db "CON"  
4a66 f1			.pastdmark: pop af  
4a67			endm  
# End of macro DMARK
4a67						CALLMONITOR 
4a67 cd aa fd			call debug_vector  
4a6a				endm  
# End of macro CALLMONITOR
4a6a					endif 
4a6a			 
4a6a			 
4a6a					FORTH_DSP_VALUE 
4a6a cd 34 22			call macro_forth_dsp_value 
4a6d				endm 
# End of macro FORTH_DSP_VALUE
4a6d e5					push hl   ; s2 
4a6e			 
4a6e					FORTH_DSP_POP 
4a6e cd 03 23			call macro_forth_dsp_pop 
4a71				endm 
# End of macro FORTH_DSP_POP
4a71			 
4a71					FORTH_DSP_VALUE 
4a71 cd 34 22			call macro_forth_dsp_value 
4a74				endm 
# End of macro FORTH_DSP_VALUE
4a74			 
4a74 e5					push hl   ; s1 
4a75			 
4a75					FORTH_DSP_POP 
4a75 cd 03 23			call macro_forth_dsp_pop 
4a78				endm 
# End of macro FORTH_DSP_POP
4a78					 
4a78			 
4a78					; copy s1 
4a78			 
4a78				 
4a78					; save ptr 
4a78 e1					pop hl  
4a79 e5					push hl 
4a7a 3e 00				ld a, 0 
4a7c cd 4f 13				call strlent 
4a7f					;inc hl    ; zer0 
4a7f 06 00				ld b, 0 
4a81 4d					ld c, l 
4a82 e1					pop hl		 
4a83 11 f6 f0				ld de, scratch	 
4a86					if DEBUG_FORTH_WORDS 
4a86						DMARK "CO1" 
4a86 f5				push af  
4a87 3a 9b 4a			ld a, (.dmark)  
4a8a 32 a0 fd			ld (debug_mark),a  
4a8d 3a 9c 4a			ld a, (.dmark+1)  
4a90 32 a1 fd			ld (debug_mark+1),a  
4a93 3a 9d 4a			ld a, (.dmark+2)  
4a96 32 a2 fd			ld (debug_mark+2),a  
4a99 18 03			jr .pastdmark  
4a9b ..			.dmark: db "CO1"  
4a9e f1			.pastdmark: pop af  
4a9f			endm  
# End of macro DMARK
4a9f						CALLMONITOR 
4a9f cd aa fd			call debug_vector  
4aa2				endm  
# End of macro CALLMONITOR
4aa2					endif 
4aa2 ed b0				ldir 
4aa4			 
4aa4 e1					pop hl 
4aa5 e5					push hl 
4aa6 d5					push de 
4aa7			 
4aa7			 
4aa7 3e 00				ld a, 0 
4aa9 cd 4f 13				call strlent 
4aac 23					inc hl    ; zer0 
4aad 23					inc hl 
4aae 06 00				ld b, 0 
4ab0 4d					ld c, l 
4ab1 d1					pop de 
4ab2 e1					pop hl		 
4ab3					if DEBUG_FORTH_WORDS 
4ab3						DMARK "CO2" 
4ab3 f5				push af  
4ab4 3a c8 4a			ld a, (.dmark)  
4ab7 32 a0 fd			ld (debug_mark),a  
4aba 3a c9 4a			ld a, (.dmark+1)  
4abd 32 a1 fd			ld (debug_mark+1),a  
4ac0 3a ca 4a			ld a, (.dmark+2)  
4ac3 32 a2 fd			ld (debug_mark+2),a  
4ac6 18 03			jr .pastdmark  
4ac8 ..			.dmark: db "CO2"  
4acb f1			.pastdmark: pop af  
4acc			endm  
# End of macro DMARK
4acc						CALLMONITOR 
4acc cd aa fd			call debug_vector  
4acf				endm  
# End of macro CALLMONITOR
4acf					endif 
4acf ed b0				ldir 
4ad1			 
4ad1			 
4ad1			 
4ad1 21 f6 f0				ld hl, scratch 
4ad4					if DEBUG_FORTH_WORDS 
4ad4						DMARK "CO5" 
4ad4 f5				push af  
4ad5 3a e9 4a			ld a, (.dmark)  
4ad8 32 a0 fd			ld (debug_mark),a  
4adb 3a ea 4a			ld a, (.dmark+1)  
4ade 32 a1 fd			ld (debug_mark+1),a  
4ae1 3a eb 4a			ld a, (.dmark+2)  
4ae4 32 a2 fd			ld (debug_mark+2),a  
4ae7 18 03			jr .pastdmark  
4ae9 ..			.dmark: db "CO5"  
4aec f1			.pastdmark: pop af  
4aed			endm  
# End of macro DMARK
4aed						CALLMONITOR 
4aed cd aa fd			call debug_vector  
4af0				endm  
# End of macro CALLMONITOR
4af0					endif 
4af0			 
4af0 cd b4 20				call forth_push_str 
4af3			 
4af3			 
4af3			 
4af3			 
4af3				       NEXTW 
4af3 c3 37 24			jp macro_next 
4af6				endm 
# End of macro NEXTW
4af6			 
4af6			 
4af6			.FIND: 
4af6				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4af6 4b				db WORD_SYS_CORE+55             
4af7 b4 4b			dw .LEN            
4af9 05				db 4 + 1 
4afa .. 00			db "FIND",0              
4aff				endm 
# End of macro CWHEAD
4aff			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4aff			 
4aff					if DEBUG_FORTH_WORDS_KEY 
4aff						DMARK "FND" 
4aff f5				push af  
4b00 3a 14 4b			ld a, (.dmark)  
4b03 32 a0 fd			ld (debug_mark),a  
4b06 3a 15 4b			ld a, (.dmark+1)  
4b09 32 a1 fd			ld (debug_mark+1),a  
4b0c 3a 16 4b			ld a, (.dmark+2)  
4b0f 32 a2 fd			ld (debug_mark+2),a  
4b12 18 03			jr .pastdmark  
4b14 ..			.dmark: db "FND"  
4b17 f1			.pastdmark: pop af  
4b18			endm  
# End of macro DMARK
4b18						CALLMONITOR 
4b18 cd aa fd			call debug_vector  
4b1b				endm  
# End of macro CALLMONITOR
4b1b					endif 
4b1b			 
4b1b			; TODO check string type 
4b1b					FORTH_DSP_VALUE 
4b1b cd 34 22			call macro_forth_dsp_value 
4b1e				endm 
# End of macro FORTH_DSP_VALUE
4b1e			 
4b1e e5					push hl    
4b1f 7e					ld a,(hl)    ; char to find   
4b20			; TODO change char to substr 
4b20			 
4b20 f5					push af 
4b21					 
4b21			 
4b21			 
4b21					if DEBUG_FORTH_WORDS 
4b21						DMARK "FN1" 
4b21 f5				push af  
4b22 3a 36 4b			ld a, (.dmark)  
4b25 32 a0 fd			ld (debug_mark),a  
4b28 3a 37 4b			ld a, (.dmark+1)  
4b2b 32 a1 fd			ld (debug_mark+1),a  
4b2e 3a 38 4b			ld a, (.dmark+2)  
4b31 32 a2 fd			ld (debug_mark+2),a  
4b34 18 03			jr .pastdmark  
4b36 ..			.dmark: db "FN1"  
4b39 f1			.pastdmark: pop af  
4b3a			endm  
# End of macro DMARK
4b3a						CALLMONITOR 
4b3a cd aa fd			call debug_vector  
4b3d				endm  
# End of macro CALLMONITOR
4b3d					endif 
4b3d			 
4b3d					FORTH_DSP_POP 
4b3d cd 03 23			call macro_forth_dsp_pop 
4b40				endm 
# End of macro FORTH_DSP_POP
4b40			 
4b40					; string to search 
4b40			 
4b40					FORTH_DSP_VALUE 
4b40 cd 34 22			call macro_forth_dsp_value 
4b43				endm 
# End of macro FORTH_DSP_VALUE
4b43			 
4b43 d1					pop de  ; d is char to find  
4b44			 
4b44					if DEBUG_FORTH_WORDS 
4b44						DMARK "FN2" 
4b44 f5				push af  
4b45 3a 59 4b			ld a, (.dmark)  
4b48 32 a0 fd			ld (debug_mark),a  
4b4b 3a 5a 4b			ld a, (.dmark+1)  
4b4e 32 a1 fd			ld (debug_mark+1),a  
4b51 3a 5b 4b			ld a, (.dmark+2)  
4b54 32 a2 fd			ld (debug_mark+2),a  
4b57 18 03			jr .pastdmark  
4b59 ..			.dmark: db "FN2"  
4b5c f1			.pastdmark: pop af  
4b5d			endm  
# End of macro DMARK
4b5d						CALLMONITOR 
4b5d cd aa fd			call debug_vector  
4b60				endm  
# End of macro CALLMONITOR
4b60					endif 
4b60					 
4b60 01 00 00				ld bc, 0 
4b63 7e			.findchar:      ld a,(hl) 
4b64 fe 00				cp 0   		 
4b66 28 27				jr z, .finddone     
4b68 ba					cp d 
4b69 28 20				jr z, .foundchar 
4b6b 03					inc bc 
4b6c 23					inc hl 
4b6d					if DEBUG_FORTH_WORDS 
4b6d						DMARK "FN3" 
4b6d f5				push af  
4b6e 3a 82 4b			ld a, (.dmark)  
4b71 32 a0 fd			ld (debug_mark),a  
4b74 3a 83 4b			ld a, (.dmark+1)  
4b77 32 a1 fd			ld (debug_mark+1),a  
4b7a 3a 84 4b			ld a, (.dmark+2)  
4b7d 32 a2 fd			ld (debug_mark+2),a  
4b80 18 03			jr .pastdmark  
4b82 ..			.dmark: db "FN3"  
4b85 f1			.pastdmark: pop af  
4b86			endm  
# End of macro DMARK
4b86						CALLMONITOR 
4b86 cd aa fd			call debug_vector  
4b89				endm  
# End of macro CALLMONITOR
4b89					endif 
4b89 18 d8				jr .findchar 
4b8b			 
4b8b			 
4b8b c5			.foundchar:	push bc 
4b8c e1					pop hl 
4b8d 18 03				jr .findexit 
4b8f			 
4b8f			 
4b8f							 
4b8f			 
4b8f			.finddone:     ; got to end of string with no find 
4b8f 21 00 00				ld hl, 0 
4b92			.findexit: 
4b92			 
4b92					if DEBUG_FORTH_WORDS 
4b92						DMARK "FNd" 
4b92 f5				push af  
4b93 3a a7 4b			ld a, (.dmark)  
4b96 32 a0 fd			ld (debug_mark),a  
4b99 3a a8 4b			ld a, (.dmark+1)  
4b9c 32 a1 fd			ld (debug_mark+1),a  
4b9f 3a a9 4b			ld a, (.dmark+2)  
4ba2 32 a2 fd			ld (debug_mark+2),a  
4ba5 18 03			jr .pastdmark  
4ba7 ..			.dmark: db "FNd"  
4baa f1			.pastdmark: pop af  
4bab			endm  
# End of macro DMARK
4bab						CALLMONITOR 
4bab cd aa fd			call debug_vector  
4bae				endm  
# End of macro CALLMONITOR
4bae					endif 
4bae cd 46 20			call forth_push_numhl 
4bb1			 
4bb1				       NEXTW 
4bb1 c3 37 24			jp macro_next 
4bb4				endm 
# End of macro NEXTW
4bb4			 
4bb4			.LEN: 
4bb4				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4bb4 4c				db WORD_SYS_CORE+56             
4bb5 1e 4c			dw .ASC            
4bb7 06				db 5 + 1 
4bb8 .. 00			db "COUNT",0              
4bbe				endm 
# End of macro CWHEAD
4bbe			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4bbe			 
4bbe					if DEBUG_FORTH_WORDS_KEY 
4bbe						DMARK "CNT" 
4bbe f5				push af  
4bbf 3a d3 4b			ld a, (.dmark)  
4bc2 32 a0 fd			ld (debug_mark),a  
4bc5 3a d4 4b			ld a, (.dmark+1)  
4bc8 32 a1 fd			ld (debug_mark+1),a  
4bcb 3a d5 4b			ld a, (.dmark+2)  
4bce 32 a2 fd			ld (debug_mark+2),a  
4bd1 18 03			jr .pastdmark  
4bd3 ..			.dmark: db "CNT"  
4bd6 f1			.pastdmark: pop af  
4bd7			endm  
# End of macro DMARK
4bd7						CALLMONITOR 
4bd7 cd aa fd			call debug_vector  
4bda				endm  
# End of macro CALLMONITOR
4bda					endif 
4bda			; TODO check string type 
4bda					FORTH_DSP_VALUE 
4bda cd 34 22			call macro_forth_dsp_value 
4bdd				endm 
# End of macro FORTH_DSP_VALUE
4bdd			 
4bdd			 
4bdd					if DEBUG_FORTH_WORDS 
4bdd						DMARK "CN?" 
4bdd f5				push af  
4bde 3a f2 4b			ld a, (.dmark)  
4be1 32 a0 fd			ld (debug_mark),a  
4be4 3a f3 4b			ld a, (.dmark+1)  
4be7 32 a1 fd			ld (debug_mark+1),a  
4bea 3a f4 4b			ld a, (.dmark+2)  
4bed 32 a2 fd			ld (debug_mark+2),a  
4bf0 18 03			jr .pastdmark  
4bf2 ..			.dmark: db "CN?"  
4bf5 f1			.pastdmark: pop af  
4bf6			endm  
# End of macro DMARK
4bf6						CALLMONITOR 
4bf6 cd aa fd			call debug_vector  
4bf9				endm  
# End of macro CALLMONITOR
4bf9					endif 
4bf9 cd 44 13				call strlenz 
4bfc					if DEBUG_FORTH_WORDS 
4bfc						DMARK "CNl" 
4bfc f5				push af  
4bfd 3a 11 4c			ld a, (.dmark)  
4c00 32 a0 fd			ld (debug_mark),a  
4c03 3a 12 4c			ld a, (.dmark+1)  
4c06 32 a1 fd			ld (debug_mark+1),a  
4c09 3a 13 4c			ld a, (.dmark+2)  
4c0c 32 a2 fd			ld (debug_mark+2),a  
4c0f 18 03			jr .pastdmark  
4c11 ..			.dmark: db "CNl"  
4c14 f1			.pastdmark: pop af  
4c15			endm  
# End of macro DMARK
4c15						CALLMONITOR 
4c15 cd aa fd			call debug_vector  
4c18				endm  
# End of macro CALLMONITOR
4c18					endif 
4c18			 
4c18 cd 46 20				call forth_push_numhl 
4c1b			 
4c1b			 
4c1b			 
4c1b				       NEXTW 
4c1b c3 37 24			jp macro_next 
4c1e				endm 
# End of macro NEXTW
4c1e			.ASC: 
4c1e				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4c1e 4d				db WORD_SYS_CORE+57             
4c1f 8c 4c			dw .CHR            
4c21 04				db 3 + 1 
4c22 .. 00			db "ASC",0              
4c26				endm 
# End of macro CWHEAD
4c26			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4c26					if DEBUG_FORTH_WORDS_KEY 
4c26						DMARK "ASC" 
4c26 f5				push af  
4c27 3a 3b 4c			ld a, (.dmark)  
4c2a 32 a0 fd			ld (debug_mark),a  
4c2d 3a 3c 4c			ld a, (.dmark+1)  
4c30 32 a1 fd			ld (debug_mark+1),a  
4c33 3a 3d 4c			ld a, (.dmark+2)  
4c36 32 a2 fd			ld (debug_mark+2),a  
4c39 18 03			jr .pastdmark  
4c3b ..			.dmark: db "ASC"  
4c3e f1			.pastdmark: pop af  
4c3f			endm  
# End of macro DMARK
4c3f						CALLMONITOR 
4c3f cd aa fd			call debug_vector  
4c42				endm  
# End of macro CALLMONITOR
4c42					endif 
4c42					FORTH_DSP_VALUE 
4c42 cd 34 22			call macro_forth_dsp_value 
4c45				endm 
# End of macro FORTH_DSP_VALUE
4c45					;v5 FORTH_DSP_VALUE 
4c45			;		inc hl      ; now at start of numeric as string 
4c45			 
4c45 e5					push hl 
4c46			 
4c46					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c46 cd 03 23			call macro_forth_dsp_pop 
4c49				endm 
# End of macro FORTH_DSP_POP
4c49			 
4c49 e1					pop hl 
4c4a			 
4c4a					if DEBUG_FORTH_WORDS 
4c4a						DMARK "AS1" 
4c4a f5				push af  
4c4b 3a 5f 4c			ld a, (.dmark)  
4c4e 32 a0 fd			ld (debug_mark),a  
4c51 3a 60 4c			ld a, (.dmark+1)  
4c54 32 a1 fd			ld (debug_mark+1),a  
4c57 3a 61 4c			ld a, (.dmark+2)  
4c5a 32 a2 fd			ld (debug_mark+2),a  
4c5d 18 03			jr .pastdmark  
4c5f ..			.dmark: db "AS1"  
4c62 f1			.pastdmark: pop af  
4c63			endm  
# End of macro DMARK
4c63						CALLMONITOR 
4c63 cd aa fd			call debug_vector  
4c66				endm  
# End of macro CALLMONITOR
4c66					endif 
4c66					; push the content of a onto the stack as a value 
4c66			 
4c66 7e					ld a,(hl)   ; get char 
4c67 26 00				ld h,0 
4c69 6f					ld l,a 
4c6a					if DEBUG_FORTH_WORDS 
4c6a						DMARK "AS2" 
4c6a f5				push af  
4c6b 3a 7f 4c			ld a, (.dmark)  
4c6e 32 a0 fd			ld (debug_mark),a  
4c71 3a 80 4c			ld a, (.dmark+1)  
4c74 32 a1 fd			ld (debug_mark+1),a  
4c77 3a 81 4c			ld a, (.dmark+2)  
4c7a 32 a2 fd			ld (debug_mark+2),a  
4c7d 18 03			jr .pastdmark  
4c7f ..			.dmark: db "AS2"  
4c82 f1			.pastdmark: pop af  
4c83			endm  
# End of macro DMARK
4c83						CALLMONITOR 
4c83 cd aa fd			call debug_vector  
4c86				endm  
# End of macro CALLMONITOR
4c86					endif 
4c86 cd 46 20				call forth_push_numhl 
4c89			 
4c89				       NEXTW 
4c89 c3 37 24			jp macro_next 
4c8c				endm 
# End of macro NEXTW
4c8c			 
4c8c			.CHR: 
4c8c				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4c8c 4d				db WORD_SYS_CORE+57             
4c8d c8 4c			dw .ENDSTR            
4c8f 04				db 3 + 1 
4c90 .. 00			db "CHR",0              
4c94				endm 
# End of macro CWHEAD
4c94			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4c94					if DEBUG_FORTH_WORDS_KEY 
4c94						DMARK "CHR" 
4c94 f5				push af  
4c95 3a a9 4c			ld a, (.dmark)  
4c98 32 a0 fd			ld (debug_mark),a  
4c9b 3a aa 4c			ld a, (.dmark+1)  
4c9e 32 a1 fd			ld (debug_mark+1),a  
4ca1 3a ab 4c			ld a, (.dmark+2)  
4ca4 32 a2 fd			ld (debug_mark+2),a  
4ca7 18 03			jr .pastdmark  
4ca9 ..			.dmark: db "CHR"  
4cac f1			.pastdmark: pop af  
4cad			endm  
# End of macro DMARK
4cad						CALLMONITOR 
4cad cd aa fd			call debug_vector  
4cb0				endm  
# End of macro CALLMONITOR
4cb0					endif 
4cb0					FORTH_DSP_VALUEHL 
4cb0 cd 4b 22			call macro_dsp_valuehl 
4cb3				endm 
# End of macro FORTH_DSP_VALUEHL
4cb3			 
4cb3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4cb3 cd 03 23			call macro_forth_dsp_pop 
4cb6				endm 
# End of macro FORTH_DSP_POP
4cb6			 
4cb6					; save asci byte as a zero term string and push string 
4cb6			 
4cb6 7d					ld a,l 
4cb7 32 f6 f0				ld (scratch), a 
4cba			 
4cba 3e 00				ld a, 0 
4cbc 32 f7 f0				ld (scratch+1), a 
4cbf			 
4cbf 21 f6 f0				ld hl, scratch 
4cc2 cd b4 20				call forth_push_str 
4cc5			 
4cc5			 
4cc5				       NEXTW 
4cc5 c3 37 24			jp macro_next 
4cc8				endm 
# End of macro NEXTW
4cc8			 
4cc8			 
4cc8			 
4cc8			 
4cc8			.ENDSTR: 
4cc8			; eof 
4cc8			 
# End of file forth_words_str.asm
4cc8			include "forth_words_key.asm" 
4cc8			 
4cc8			; | ## Keyboard Words 
4cc8			 
4cc8			.KEY: 
4cc8				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4cc8 3e				db WORD_SYS_CORE+42             
4cc9 f8 4c			dw .WAITK            
4ccb 04				db 3 + 1 
4ccc .. 00			db "KEY",0              
4cd0				endm 
# End of macro CWHEAD
4cd0			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
4cd0			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4cd0			; | | Can use something like this to process: 
4cd0			; | | > repeat active . key ?dup if emit then #1 until  
4cd0			 
4cd0					if DEBUG_FORTH_WORDS_KEY 
4cd0						DMARK "KEY" 
4cd0 f5				push af  
4cd1 3a e5 4c			ld a, (.dmark)  
4cd4 32 a0 fd			ld (debug_mark),a  
4cd7 3a e6 4c			ld a, (.dmark+1)  
4cda 32 a1 fd			ld (debug_mark+1),a  
4cdd 3a e7 4c			ld a, (.dmark+2)  
4ce0 32 a2 fd			ld (debug_mark+2),a  
4ce3 18 03			jr .pastdmark  
4ce5 ..			.dmark: db "KEY"  
4ce8 f1			.pastdmark: pop af  
4ce9			endm  
# End of macro DMARK
4ce9						CALLMONITOR 
4ce9 cd aa fd			call debug_vector  
4cec				endm  
# End of macro CALLMONITOR
4cec					endif 
4cec			; TODO currently waits 
4cec cd 8b 73				call cin 
4cef					;call cin_wait 
4cef 6f					ld l, a 
4cf0 26 00				ld h, 0 
4cf2 cd 46 20				call forth_push_numhl 
4cf5					NEXTW 
4cf5 c3 37 24			jp macro_next 
4cf8				endm 
# End of macro NEXTW
4cf8			.WAITK: 
4cf8				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4cf8 3f				db WORD_SYS_CORE+43             
4cf9 2a 4d			dw .ACCEPT            
4cfb 06				db 5 + 1 
4cfc .. 00			db "WAITK",0              
4d02				endm 
# End of macro CWHEAD
4d02			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4d02					if DEBUG_FORTH_WORDS_KEY 
4d02						DMARK "WAI" 
4d02 f5				push af  
4d03 3a 17 4d			ld a, (.dmark)  
4d06 32 a0 fd			ld (debug_mark),a  
4d09 3a 18 4d			ld a, (.dmark+1)  
4d0c 32 a1 fd			ld (debug_mark+1),a  
4d0f 3a 19 4d			ld a, (.dmark+2)  
4d12 32 a2 fd			ld (debug_mark+2),a  
4d15 18 03			jr .pastdmark  
4d17 ..			.dmark: db "WAI"  
4d1a f1			.pastdmark: pop af  
4d1b			endm  
# End of macro DMARK
4d1b						CALLMONITOR 
4d1b cd aa fd			call debug_vector  
4d1e				endm  
# End of macro CALLMONITOR
4d1e					endif 
4d1e cd 7a 73				call cin_wait 
4d21 6f					ld l, a 
4d22 26 00				ld h, 0 
4d24 cd 46 20				call forth_push_numhl 
4d27					NEXTW 
4d27 c3 37 24			jp macro_next 
4d2a				endm 
# End of macro NEXTW
4d2a			.ACCEPT: 
4d2a				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4d2a 40				db WORD_SYS_CORE+44             
4d2b 88 4d			dw .EDIT            
4d2d 07				db 6 + 1 
4d2e .. 00			db "ACCEPT",0              
4d35				endm 
# End of macro CWHEAD
4d35			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4d35					; TODO crashes on push 
4d35					if DEBUG_FORTH_WORDS_KEY 
4d35						DMARK "ACC" 
4d35 f5				push af  
4d36 3a 4a 4d			ld a, (.dmark)  
4d39 32 a0 fd			ld (debug_mark),a  
4d3c 3a 4b 4d			ld a, (.dmark+1)  
4d3f 32 a1 fd			ld (debug_mark+1),a  
4d42 3a 4c 4d			ld a, (.dmark+2)  
4d45 32 a2 fd			ld (debug_mark+2),a  
4d48 18 03			jr .pastdmark  
4d4a ..			.dmark: db "ACC"  
4d4d f1			.pastdmark: pop af  
4d4e			endm  
# End of macro DMARK
4d4e						CALLMONITOR 
4d4e cd aa fd			call debug_vector  
4d51				endm  
# End of macro CALLMONITOR
4d51					endif 
4d51 21 f4 f2				ld hl, os_input 
4d54 3e 00				ld a, 0 
4d56 77					ld (hl),a 
4d57 3a 93 f9				ld a,(f_cursor_ptr) 
4d5a 16 64				ld d, 100 
4d5c 0e 00				ld c, 0 
4d5e 1e 28				ld e, 40 
4d60 cd 0b 10				call input_str 
4d63					; TODO perhaps do a type check and wrap in quotes if not a number 
4d63 21 f4 f2				ld hl, os_input 
4d66					if DEBUG_FORTH_WORDS 
4d66						DMARK "AC1" 
4d66 f5				push af  
4d67 3a 7b 4d			ld a, (.dmark)  
4d6a 32 a0 fd			ld (debug_mark),a  
4d6d 3a 7c 4d			ld a, (.dmark+1)  
4d70 32 a1 fd			ld (debug_mark+1),a  
4d73 3a 7d 4d			ld a, (.dmark+2)  
4d76 32 a2 fd			ld (debug_mark+2),a  
4d79 18 03			jr .pastdmark  
4d7b ..			.dmark: db "AC1"  
4d7e f1			.pastdmark: pop af  
4d7f			endm  
# End of macro DMARK
4d7f						CALLMONITOR 
4d7f cd aa fd			call debug_vector  
4d82				endm  
# End of macro CALLMONITOR
4d82					endif 
4d82 cd b4 20				call forth_push_str 
4d85					NEXTW 
4d85 c3 37 24			jp macro_next 
4d88				endm 
# End of macro NEXTW
4d88			 
4d88			.EDIT: 
4d88				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4d88 40				db WORD_SYS_CORE+44             
4d89 2a 4e			dw .DEDIT            
4d8b 05				db 4 + 1 
4d8c .. 00			db "EDIT",0              
4d91				endm 
# End of macro CWHEAD
4d91			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4d91			 
4d91					; TODO does not copy from stack 
4d91					if DEBUG_FORTH_WORDS_KEY 
4d91						DMARK "EDT" 
4d91 f5				push af  
4d92 3a a6 4d			ld a, (.dmark)  
4d95 32 a0 fd			ld (debug_mark),a  
4d98 3a a7 4d			ld a, (.dmark+1)  
4d9b 32 a1 fd			ld (debug_mark+1),a  
4d9e 3a a8 4d			ld a, (.dmark+2)  
4da1 32 a2 fd			ld (debug_mark+2),a  
4da4 18 03			jr .pastdmark  
4da6 ..			.dmark: db "EDT"  
4da9 f1			.pastdmark: pop af  
4daa			endm  
# End of macro DMARK
4daa						CALLMONITOR 
4daa cd aa fd			call debug_vector  
4dad				endm  
# End of macro CALLMONITOR
4dad					endif 
4dad			 
4dad					;FORTH_DSP 
4dad					FORTH_DSP_VALUEHL 
4dad cd 4b 22			call macro_dsp_valuehl 
4db0				endm 
# End of macro FORTH_DSP_VALUEHL
4db0			;		inc hl    ; TODO do type check 
4db0			 
4db0			;		call get_word_hl 
4db0 e5					push hl 
4db1					if DEBUG_FORTH_WORDS 
4db1						DMARK "EDp" 
4db1 f5				push af  
4db2 3a c6 4d			ld a, (.dmark)  
4db5 32 a0 fd			ld (debug_mark),a  
4db8 3a c7 4d			ld a, (.dmark+1)  
4dbb 32 a1 fd			ld (debug_mark+1),a  
4dbe 3a c8 4d			ld a, (.dmark+2)  
4dc1 32 a2 fd			ld (debug_mark+2),a  
4dc4 18 03			jr .pastdmark  
4dc6 ..			.dmark: db "EDp"  
4dc9 f1			.pastdmark: pop af  
4dca			endm  
# End of macro DMARK
4dca						CALLMONITOR 
4dca cd aa fd			call debug_vector  
4dcd				endm  
# End of macro CALLMONITOR
4dcd					endif 
4dcd				;	ld a, 0 
4dcd cd 44 13				call strlenz 
4dd0 23					inc hl 
4dd1			 
4dd1 06 00				ld b, 0 
4dd3 4d					ld c, l 
4dd4			 
4dd4 e1					pop hl 
4dd5 11 f4 f2				ld de, os_input 
4dd8					if DEBUG_FORTH_WORDS_KEY 
4dd8						DMARK "EDc" 
4dd8 f5				push af  
4dd9 3a ed 4d			ld a, (.dmark)  
4ddc 32 a0 fd			ld (debug_mark),a  
4ddf 3a ee 4d			ld a, (.dmark+1)  
4de2 32 a1 fd			ld (debug_mark+1),a  
4de5 3a ef 4d			ld a, (.dmark+2)  
4de8 32 a2 fd			ld (debug_mark+2),a  
4deb 18 03			jr .pastdmark  
4ded ..			.dmark: db "EDc"  
4df0 f1			.pastdmark: pop af  
4df1			endm  
# End of macro DMARK
4df1						CALLMONITOR 
4df1 cd aa fd			call debug_vector  
4df4				endm  
# End of macro CALLMONITOR
4df4					endif 
4df4 ed b0				ldir 
4df6			 
4df6			 
4df6 21 f4 f2				ld hl, os_input 
4df9					;ld a, 0 
4df9					;ld (hl),a 
4df9 3a 93 f9				ld a,(f_cursor_ptr) 
4dfc 16 64				ld d, 100 
4dfe 0e 00				ld c, 0 
4e00 1e 28				ld e, 40 
4e02 cd 0b 10				call input_str 
4e05					; TODO perhaps do a type check and wrap in quotes if not a number 
4e05 21 f4 f2				ld hl, os_input 
4e08					if DEBUG_FORTH_WORDS 
4e08						DMARK "ED1" 
4e08 f5				push af  
4e09 3a 1d 4e			ld a, (.dmark)  
4e0c 32 a0 fd			ld (debug_mark),a  
4e0f 3a 1e 4e			ld a, (.dmark+1)  
4e12 32 a1 fd			ld (debug_mark+1),a  
4e15 3a 1f 4e			ld a, (.dmark+2)  
4e18 32 a2 fd			ld (debug_mark+2),a  
4e1b 18 03			jr .pastdmark  
4e1d ..			.dmark: db "ED1"  
4e20 f1			.pastdmark: pop af  
4e21			endm  
# End of macro DMARK
4e21						CALLMONITOR 
4e21 cd aa fd			call debug_vector  
4e24				endm  
# End of macro CALLMONITOR
4e24					endif 
4e24 cd b4 20				call forth_push_str 
4e27					NEXTW 
4e27 c3 37 24			jp macro_next 
4e2a				endm 
# End of macro NEXTW
4e2a			 
4e2a			.DEDIT: 
4e2a				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4e2a 40				db WORD_SYS_CORE+44             
4e2b 8c 4e			dw .ENDKEY            
4e2d 06				db 5 + 1 
4e2e .. 00			db "DEDIT",0              
4e34				endm 
# End of macro CWHEAD
4e34			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4e34			 
4e34					; TODO does not copy from stack 
4e34					if DEBUG_FORTH_WORDS_KEY 
4e34						DMARK "DED" 
4e34 f5				push af  
4e35 3a 49 4e			ld a, (.dmark)  
4e38 32 a0 fd			ld (debug_mark),a  
4e3b 3a 4a 4e			ld a, (.dmark+1)  
4e3e 32 a1 fd			ld (debug_mark+1),a  
4e41 3a 4b 4e			ld a, (.dmark+2)  
4e44 32 a2 fd			ld (debug_mark+2),a  
4e47 18 03			jr .pastdmark  
4e49 ..			.dmark: db "DED"  
4e4c f1			.pastdmark: pop af  
4e4d			endm  
# End of macro DMARK
4e4d						CALLMONITOR 
4e4d cd aa fd			call debug_vector  
4e50				endm  
# End of macro CALLMONITOR
4e50					endif 
4e50			 
4e50					;FORTH_DSP 
4e50					FORTH_DSP_VALUEHL 
4e50 cd 4b 22			call macro_dsp_valuehl 
4e53				endm 
# End of macro FORTH_DSP_VALUEHL
4e53			;		inc hl    ; TODO do type check 
4e53			 
4e53			;		call get_word_hl 
4e53 e5					push hl 
4e54 e5					push hl 
4e55					FORTH_DSP_POP 
4e55 cd 03 23			call macro_forth_dsp_pop 
4e58				endm 
# End of macro FORTH_DSP_POP
4e58 e1					pop hl 
4e59					if DEBUG_FORTH_WORDS 
4e59						DMARK "EDp" 
4e59 f5				push af  
4e5a 3a 6e 4e			ld a, (.dmark)  
4e5d 32 a0 fd			ld (debug_mark),a  
4e60 3a 6f 4e			ld a, (.dmark+1)  
4e63 32 a1 fd			ld (debug_mark+1),a  
4e66 3a 70 4e			ld a, (.dmark+2)  
4e69 32 a2 fd			ld (debug_mark+2),a  
4e6c 18 03			jr .pastdmark  
4e6e ..			.dmark: db "EDp"  
4e71 f1			.pastdmark: pop af  
4e72			endm  
# End of macro DMARK
4e72						CALLMONITOR 
4e72 cd aa fd			call debug_vector  
4e75				endm  
# End of macro CALLMONITOR
4e75					endif 
4e75				;	ld a, 0 
4e75 cd 44 13				call strlenz 
4e78 23					inc hl 
4e79			 
4e79 06 00				ld b, 0 
4e7b 4d					ld c, l 
4e7c			 
4e7c e1					pop hl 
4e7d			 
4e7d					;ld a, 0 
4e7d					;ld (hl),a 
4e7d 3a 93 f9				ld a,(f_cursor_ptr) 
4e80 16 64				ld d, 100 
4e82 0e 00				ld c, 0 
4e84 1e 28				ld e, 40 
4e86 cd 0b 10				call input_str 
4e89					; TODO perhaps do a type check and wrap in quotes if not a number 
4e89					NEXTW 
4e89 c3 37 24			jp macro_next 
4e8c				endm 
# End of macro NEXTW
4e8c			 
4e8c			 
4e8c			.ENDKEY: 
4e8c			; eof 
4e8c			 
# End of file forth_words_key.asm
4e8c			include "forth_words_const.asm" 
4e8c			 
4e8c			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4e8c			 
4e8c			 
4e8c			.SPITIME: 
4e8c				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4e8c 77				db WORD_SYS_CORE+99             
4e8d a1 4e			dw .VA            
4e8f 08				db 7 + 1 
4e90 .. 00			db "SPITIME",0              
4e98				endm 
# End of macro CWHEAD
4e98			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4e98			; 
4e98			; | | If using BANK devices then leave as is. 
4e98			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4e98			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4e98			 
4e98 21 99 f9				ld hl, spi_clktime  
4e9b cd 46 20				call forth_push_numhl 
4e9e			 
4e9e					NEXTW 
4e9e c3 37 24			jp macro_next 
4ea1				endm 
# End of macro NEXTW
4ea1			 
4ea1			 
4ea1			.VA: 
4ea1				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4ea1 77				db WORD_SYS_CORE+99             
4ea2 b1 4e			dw .SYMBOL            
4ea4 03				db 2 + 1 
4ea5 .. 00			db "VA",0              
4ea8				endm 
# End of macro CWHEAD
4ea8			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4ea8 21 5d f9				ld hl, cli_var_array 
4eab cd 46 20				call forth_push_numhl 
4eae			 
4eae					NEXTW 
4eae c3 37 24			jp macro_next 
4eb1				endm 
# End of macro NEXTW
4eb1			 
4eb1			.SYMBOL: 
4eb1				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4eb1 77				db WORD_SYS_CORE+99             
4eb2 bb 4f			dw .ENDCONST            
4eb4 07				db 6 + 1 
4eb5 .. 00			db "SYMBOL",0              
4ebc				endm 
# End of macro CWHEAD
4ebc			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4ebc			; | 
4ebc			; | | The value is the number reference and the final address is pushed to stack 
4ebc			 
4ebc			; | | ``` 
4ebc			; | | dw sym_table 
4ebc			; | | dw nmi_vector 
4ebc			; | | dw cli_autodisplay 
4ebc			; | | dw cli_data_sp 
4ebc			; | | dw cli_data_stack 
4ebc			; | | dw cli_loop_sp 
4ebc			; | | dw cli_loop_stack 
4ebc			; | | dw cli_var_array 
4ebc			; | | dw cursor_col 
4ebc			; | | dw cursor_ptr 
4ebc			; | | ; 10 
4ebc			; | | dw cursor_row 
4ebc			; | | dw debug_mark 
4ebc			; | | dw display_fb0 
4ebc			; | | dw display_fb1 
4ebc			; | | dw display_fb2 
4ebc			; | | dw display_fb3 
4ebc			; | | dw display_fb_active 
4ebc			; | | dw execscratch 
4ebc			; | | dw f_cursor_ptr 
4ebc			; | | dw hardware_word 
4ebc			; | | ;20 
4ebc			; | | dw input_at_cursor 
4ebc			; | | dw input_at_pos 
4ebc			; | | dw input_cur_flash 
4ebc			; | | dw input_cur_onoff 
4ebc			; | | dw input_cursor 
4ebc			; | | dw input_display_size 
4ebc			; | | dw input_len 
4ebc			; | | dw input_ptr 
4ebc			; | | dw input_size 
4ebc			; | | dw input_start 
4ebc			; | | ; 30 
4ebc			; | | dw input_str 
4ebc			; | | dw input_under_cursor 
4ebc			; | | dw os_cli_cmd 
4ebc			; | | dw os_cur_ptr 
4ebc			; | | dw os_current_i 
4ebc			; | | dw os_input 
4ebc			; | | dw os_last_cmd 
4ebc			; | | dw os_last_new_uword 
4ebc			; | | dw debug_vector 
4ebc			; | | dw os_view_hl 
4ebc			; | | ;40 
4ebc			; | | dw os_word_scratch 
4ebc			; | | dw portbctl 
4ebc			; | | dw portbdata 
4ebc			; | | dw spi_cartdev 
4ebc			; | | dw spi_cartdev2 
4ebc			; | | dw spi_clktime 
4ebc			; | | dw spi_device 
4ebc			; | | dw spi_device_id 
4ebc			; | | dw spi_portbyte 
4ebc			; | | dw stackstore 
4ebc			; | | ; 50 
4ebc			; | | if STORAGE_SE 
4ebc			; | | dw storage_actl 
4ebc			; | | dw storage_adata 
4ebc			; | | else 
4ebc			; | | dw 0 
4ebc			; | | dw 0 
4ebc			; | | endif 
4ebc			; | | dw storage_append 
4ebc			; | | if STORAGE_SE 
4ebc			; | | dw storage_bctl 
4ebc			; | | else 
4ebc			; | | dw 0 
4ebc			; | | endif 
4ebc			; | | dw store_bank_active 
4ebc			; | | dw store_filecache 
4ebc			; | | dw store_longread 
4ebc			; | | dw store_openaddr 
4ebc			; | | dw store_openext 
4ebc			; | | dw store_openmaxext 
4ebc			; | | ; 60 
4ebc			; | | dw store_page 
4ebc			; | | dw store_readbuf 
4ebc			; | | dw store_readcont 
4ebc			; | | dw store_readptr 
4ebc			; | | dw store_tmpext 
4ebc			; | | dw store_tmpid 
4ebc			; | | dw store_tmppageid 
4ebc			; | | dw malloc 
4ebc			; | | dw free 
4ebc			; | | dw cin 
4ebc			; | | ; 70 
4ebc			; | | dw cin_wait 
4ebc			; | | dw forth_push_numhl 
4ebc			; | | dw forth_push_str 
4ebc			; | | ``` 
4ebc			 
4ebc					if DEBUG_FORTH_WORDS_KEY 
4ebc						DMARK "SYM" 
4ebc f5				push af  
4ebd 3a d1 4e			ld a, (.dmark)  
4ec0 32 a0 fd			ld (debug_mark),a  
4ec3 3a d2 4e			ld a, (.dmark+1)  
4ec6 32 a1 fd			ld (debug_mark+1),a  
4ec9 3a d3 4e			ld a, (.dmark+2)  
4ecc 32 a2 fd			ld (debug_mark+2),a  
4ecf 18 03			jr .pastdmark  
4ed1 ..			.dmark: db "SYM"  
4ed4 f1			.pastdmark: pop af  
4ed5			endm  
# End of macro DMARK
4ed5						CALLMONITOR 
4ed5 cd aa fd			call debug_vector  
4ed8				endm  
# End of macro CALLMONITOR
4ed8					endif 
4ed8			 
4ed8					FORTH_DSP_VALUEHL 
4ed8 cd 4b 22			call macro_dsp_valuehl 
4edb				endm 
# End of macro FORTH_DSP_VALUEHL
4edb			 
4edb 7d					ld a, l     
4edc			 
4edc			 
4edc					if DEBUG_FORTH_WORDS 
4edc						DMARK "SY1" 
4edc f5				push af  
4edd 3a f1 4e			ld a, (.dmark)  
4ee0 32 a0 fd			ld (debug_mark),a  
4ee3 3a f2 4e			ld a, (.dmark+1)  
4ee6 32 a1 fd			ld (debug_mark+1),a  
4ee9 3a f3 4e			ld a, (.dmark+2)  
4eec 32 a2 fd			ld (debug_mark+2),a  
4eef 18 03			jr .pastdmark  
4ef1 ..			.dmark: db "SY1"  
4ef4 f1			.pastdmark: pop af  
4ef5			endm  
# End of macro DMARK
4ef5						CALLMONITOR 
4ef5 cd aa fd			call debug_vector  
4ef8				endm  
# End of macro CALLMONITOR
4ef8					endif 
4ef8					 
4ef8 f5					push af	 
4ef9					FORTH_DSP_POP 
4ef9 cd 03 23			call macro_forth_dsp_pop 
4efc				endm 
# End of macro FORTH_DSP_POP
4efc f1					pop af 
4efd			 
4efd cb 27				sla a  
4eff				 
4eff					 
4eff					if DEBUG_FORTH_WORDS 
4eff						DMARK "SY" 
4eff f5				push af  
4f00 3a 14 4f			ld a, (.dmark)  
4f03 32 a0 fd			ld (debug_mark),a  
4f06 3a 15 4f			ld a, (.dmark+1)  
4f09 32 a1 fd			ld (debug_mark+1),a  
4f0c 3a 16 4f			ld a, (.dmark+2)  
4f0f 32 a2 fd			ld (debug_mark+2),a  
4f12 18 02			jr .pastdmark  
4f14 ..			.dmark: db "SY"  
4f16 f1			.pastdmark: pop af  
4f17			endm  
# End of macro DMARK
4f17						CALLMONITOR 
4f17 cd aa fd			call debug_vector  
4f1a				endm  
# End of macro CALLMONITOR
4f1a					endif 
4f1a			 
4f1a 21 29 4f				ld hl, sym_table 
4f1d cd de 0f				call addatohl 
4f20 cd b9 23				call loadwordinhl 
4f23 cd 46 20				call forth_push_numhl 
4f26			 
4f26			 
4f26				       NEXTW 
4f26 c3 37 24			jp macro_next 
4f29				endm 
# End of macro NEXTW
4f29			 
4f29			sym_table: 
4f29			 
4f29			; 0 
4f29 29 4f		dw sym_table 
4f2b ad fd		dw nmi_vector 
4f2d 71 f9		dw cli_autodisplay 
4f2f 23 f9		dw cli_data_sp 
4f31 5d f6		dw cli_data_stack 
4f33 25 f9		dw cli_loop_sp 
4f35 5f f8		dw cli_loop_stack 
4f37 5d f9		dw cli_var_array 
4f39 fa fa		dw cursor_col 
4f3b f8 fa		dw cursor_ptr 
4f3d			; 10 
4f3d f9 fa		dw cursor_row 
4f3f a0 fd		dw debug_mark 
4f41 e6 fc		dw display_fb0 
4f43 45 fc		dw display_fb1 
4f45 03 fb		dw display_fb2 
4f47 a4 fb		dw display_fb3 
4f49 01 fb		dw display_fb_active 
4f4b f5 f1		dw execscratch 
4f4d 93 f9		dw f_cursor_ptr 
4f4f b0 fd		dw hardware_word 
4f51			;20 
4f51 97 fd		dw input_at_cursor 
4f53 99 fd		dw input_at_pos 
4f55 95 fd		dw input_cur_flash 
4f57 94 fd		dw input_cur_onoff 
4f59 8a fd		dw input_cursor 
4f5b 9a fd		dw input_display_size 
4f5d 8f fd		dw input_len 
4f5f 9e fd		dw input_ptr 
4f61 9b fd		dw input_size 
4f63 9c fd		dw input_start 
4f65			; 30 
4f65 0b 10		dw input_str 
4f67 98 fd		dw input_under_cursor 
4f69 1d f4		dw os_cli_cmd 
4f6b 19 f4		dw os_cur_ptr 
4f6d 1b f4		dw os_current_i 
4f6f f4 f2		dw os_input 
4f71 1c f5		dw os_last_cmd 
4f73 f3 f3		dw os_last_new_uword 
4f75 aa fd		dw debug_vector 
4f77 d8 f0		dw os_view_hl 
4f79			;40 
4f79 fb f3		dw os_word_scratch 
4f7b c3 00		dw portbctl 
4f7d c1 00		dw portbdata 
4f7f 98 f9		dw spi_cartdev 
4f81 97 f9		dw spi_cartdev2 
4f83 99 f9		dw spi_clktime 
4f85 95 f9		dw spi_device 
4f87 94 f9		dw spi_device_id 
4f89 96 f9		dw spi_portbyte 
4f8b dc fa		dw stackstore 
4f8d			; 50 
4f8d			if STORAGE_SE 
4f8d 82 00		dw storage_actl 
4f8f 80 00		dw storage_adata 
4f91			else 
4f91			dw 0 
4f91			dw 0 
4f91			endif 
4f91 64 0b		dw storage_append 
4f93			if STORAGE_SE 
4f93 83 00		dw storage_bctl 
4f95			else 
4f95			dw 0 
4f95			endif 
4f95 c8 fa		dw store_bank_active 
4f97 9c f9		dw store_filecache 
4f99 aa f9		dw store_longread 
4f9b a0 f9		dw store_openaddr 
4f9d 9f f9		dw store_openext 
4f9f 9e f9		dw store_openmaxext 
4fa1			; 60 
4fa1 af f9		dw store_page 
4fa3 ab f9		dw store_readbuf 
4fa5 a2 f9		dw store_readcont 
4fa7 ad f9		dw store_readptr 
4fa9 a2 f9		dw store_tmpext 
4fab a3 f9		dw store_tmpid 
4fad 9a f9		dw store_tmppageid 
4faf b9 13		dw malloc 
4fb1 83 14		dw free 
4fb3 8b 73		dw cin 
4fb5			; 70 
4fb5 7a 73		dw cin_wait 
4fb7 46 20		dw forth_push_numhl 
4fb9 b4 20		dw forth_push_str 
4fbb			 
4fbb			 
4fbb			.ENDCONST: 
4fbb			 
4fbb			; eof 
4fbb			 
4fbb			 
# End of file forth_words_const.asm
4fbb			 
4fbb			if STORAGE_SE 
4fbb			   	include "forth_words_storage.asm" 
4fbb			 
4fbb			; | ## Fixed Storage Words 
4fbb			 
4fbb			.RENAME: 
4fbb			  
4fbb				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4fbb 3a				db WORD_SYS_CORE+38             
4fbc b1 50			dw .RECORD            
4fbe 07				db 6 + 1 
4fbf .. 00			db "RENAME",0              
4fc6				endm 
# End of macro CWHEAD
4fc6			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4fc6			; | | > [!NOTE] 
4fc6			; | | > Compatible with PicoSPINet  
4fc6					if DEBUG_FORTH_WORDS_KEY 
4fc6						DMARK "REN" 
4fc6 f5				push af  
4fc7 3a db 4f			ld a, (.dmark)  
4fca 32 a0 fd			ld (debug_mark),a  
4fcd 3a dc 4f			ld a, (.dmark+1)  
4fd0 32 a1 fd			ld (debug_mark+1),a  
4fd3 3a dd 4f			ld a, (.dmark+2)  
4fd6 32 a2 fd			ld (debug_mark+2),a  
4fd9 18 03			jr .pastdmark  
4fdb ..			.dmark: db "REN"  
4fde f1			.pastdmark: pop af  
4fdf			endm  
# End of macro DMARK
4fdf						CALLMONITOR 
4fdf cd aa fd			call debug_vector  
4fe2				endm  
# End of macro CALLMONITOR
4fe2					endif 
4fe2			 
4fe2			 
4fe2					; preserve some internal vars used by other file handing routines 
4fe2			 
4fe2 2a a0 f9				ld hl, (store_openaddr) 
4fe5 e5					push hl 
4fe6 3a a2 f9				ld a, (store_readcont) 
4fe9 f5					push af 
4fea			 
4fea					FORTH_DSP_VALUEHL 
4fea cd 4b 22			call macro_dsp_valuehl 
4fed				endm 
# End of macro FORTH_DSP_VALUEHL
4fed			 
4fed					; move ext and id around for the file header 
4fed			 
4fed 65					ld h, l 
4fee 2e 00				ld l, 0 
4ff0			 
4ff0 e5					push hl    ; id 
4ff1			 
4ff1					FORTH_DSP_POP 
4ff1 cd 03 23			call macro_forth_dsp_pop 
4ff4				endm 
# End of macro FORTH_DSP_POP
4ff4			 
4ff4					; Locate the file header 
4ff4			 
4ff4 e1					pop hl 
4ff5 e5					push hl 
4ff6 11 af f9				ld de, store_page      ; get block zero of file 
4ff9					if DEBUG_FORTH_WORDS 
4ff9						DMARK "REr" 
4ff9 f5				push af  
4ffa 3a 0e 50			ld a, (.dmark)  
4ffd 32 a0 fd			ld (debug_mark),a  
5000 3a 0f 50			ld a, (.dmark+1)  
5003 32 a1 fd			ld (debug_mark+1),a  
5006 3a 10 50			ld a, (.dmark+2)  
5009 32 a2 fd			ld (debug_mark+2),a  
500c 18 03			jr .pastdmark  
500e ..			.dmark: db "REr"  
5011 f1			.pastdmark: pop af  
5012			endm  
# End of macro DMARK
5012						CALLMONITOR 
5012 cd aa fd			call debug_vector  
5015				endm  
# End of macro CALLMONITOR
5015					endif 
5015 cd cd 09				call storage_read 
5018			 
5018 cd 07 10			call ishlzero 
501b 20 05			jr nz, .rnfound 
501d			 
501d				; file does not exist so indicate with 255 extents in use 
501d			 
501d 3e ff			ld a, 255 
501f e1				pop hl ; clear dup hl 
5020 18 7b			jr .skiprneof 
5022			 
5022			 
5022			.rnfound: 
5022					; file found so rename 
5022			 
5022					FORTH_DSP_VALUEHL 
5022 cd 4b 22			call macro_dsp_valuehl 
5025				endm 
# End of macro FORTH_DSP_VALUEHL
5025			 
5025 e5				push hl 
5026 3e 00			ld a, 0 
5028 cd 4f 13			call strlent 
502b 23				inc hl   ; cover zero term 
502c 06 00			ld b,0 
502e 4d				ld c,l 
502f e1				pop hl 
5030 11 b2 f9				ld de, store_page + 3 
5033 ed b0				ldir 
5035			 
5035 11 af f9				ld de, store_page 
5038					if DEBUG_FORTH_WORDS 
5038						DMARK "RER" 
5038 f5				push af  
5039 3a 4d 50			ld a, (.dmark)  
503c 32 a0 fd			ld (debug_mark),a  
503f 3a 4e 50			ld a, (.dmark+1)  
5042 32 a1 fd			ld (debug_mark+1),a  
5045 3a 4f 50			ld a, (.dmark+2)  
5048 32 a2 fd			ld (debug_mark+2),a  
504b 18 03			jr .pastdmark  
504d ..			.dmark: db "RER"  
5050 f1			.pastdmark: pop af  
5051			endm  
# End of macro DMARK
5051						CALLMONITOR 
5051 cd aa fd			call debug_vector  
5054				endm  
# End of macro CALLMONITOR
5054					endif 
5054			 
5054 e1					pop hl    ; get orig file id and mangle it for find id 
5055 55					ld d, l 
5056 5c					ld e, h 
5057			 
5057 21 00 00				ld hl, 0 
505a					if DEBUG_FORTH_WORDS 
505a						DMARK "REf" 
505a f5				push af  
505b 3a 6f 50			ld a, (.dmark)  
505e 32 a0 fd			ld (debug_mark),a  
5061 3a 70 50			ld a, (.dmark+1)  
5064 32 a1 fd			ld (debug_mark+1),a  
5067 3a 71 50			ld a, (.dmark+2)  
506a 32 a2 fd			ld (debug_mark+2),a  
506d 18 03			jr .pastdmark  
506f ..			.dmark: db "REf"  
5072 f1			.pastdmark: pop af  
5073			endm  
# End of macro DMARK
5073						CALLMONITOR 
5073 cd aa fd			call debug_vector  
5076				endm  
# End of macro CALLMONITOR
5076					endif 
5076 cd a7 07				call storage_findnextid 
5079 11 af f9				ld de, store_page 
507c					if DEBUG_FORTH_WORDS 
507c						DMARK "REw" 
507c f5				push af  
507d 3a 91 50			ld a, (.dmark)  
5080 32 a0 fd			ld (debug_mark),a  
5083 3a 92 50			ld a, (.dmark+1)  
5086 32 a1 fd			ld (debug_mark+1),a  
5089 3a 93 50			ld a, (.dmark+2)  
508c 32 a2 fd			ld (debug_mark+2),a  
508f 18 03			jr .pastdmark  
5091 ..			.dmark: db "REw"  
5094 f1			.pastdmark: pop af  
5095			endm  
# End of macro DMARK
5095						CALLMONITOR 
5095 cd aa fd			call debug_vector  
5098				endm  
# End of macro CALLMONITOR
5098					endif 
5098 cd d9 04				call storage_write_block 
509b			 
509b 3e 00				ld a, 0 
509d			.skiprneof: 
509d					; drop file name 
509d					FORTH_DSP_POP 
509d cd 03 23			call macro_forth_dsp_pop 
50a0				endm 
# End of macro FORTH_DSP_POP
50a0			 
50a0 6f					ld l, a 
50a1 26 00				ld h, 0 
50a3 cd 46 20				call forth_push_numhl 
50a6			 
50a6			 
50a6 f1					pop af 
50a7 32 a2 f9				ld (store_readcont),a 
50aa e1					pop hl 
50ab 22 a0 f9				ld (store_openaddr), hl 
50ae						 
50ae				NEXTW 
50ae c3 37 24			jp macro_next 
50b1				endm 
# End of macro NEXTW
50b1			.RECORD: 
50b1			  
50b1				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
50b1 3a				db WORD_SYS_CORE+38             
50b2 55 51			dw .BREAD            
50b4 07				db 6 + 1 
50b5 .. 00			db "RECORD",0              
50bc				endm 
# End of macro CWHEAD
50bc			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
50bc			; | | > [!NOTE] 
50bc			; | | > Compatible with PicoSPINet  
50bc			 
50bc					if DEBUG_FORTH_WORDS_KEY 
50bc						DMARK "REC" 
50bc f5				push af  
50bd 3a d1 50			ld a, (.dmark)  
50c0 32 a0 fd			ld (debug_mark),a  
50c3 3a d2 50			ld a, (.dmark+1)  
50c6 32 a1 fd			ld (debug_mark+1),a  
50c9 3a d3 50			ld a, (.dmark+2)  
50cc 32 a2 fd			ld (debug_mark+2),a  
50cf 18 03			jr .pastdmark  
50d1 ..			.dmark: db "REC"  
50d4 f1			.pastdmark: pop af  
50d5			endm  
# End of macro DMARK
50d5						CALLMONITOR 
50d5 cd aa fd			call debug_vector  
50d8				endm  
# End of macro CALLMONITOR
50d8					endif 
50d8			 
50d8					FORTH_DSP_VALUEHL 
50d8 cd 4b 22			call macro_dsp_valuehl 
50db				endm 
# End of macro FORTH_DSP_VALUEHL
50db			 
50db e5					push hl    ; id 
50dc			 
50dc					FORTH_DSP_POP 
50dc cd 03 23			call macro_forth_dsp_pop 
50df				endm 
# End of macro FORTH_DSP_POP
50df			 
50df					FORTH_DSP_VALUEHL 
50df cd 4b 22			call macro_dsp_valuehl 
50e2				endm 
# End of macro FORTH_DSP_VALUEHL
50e2			 
50e2					FORTH_DSP_POP 
50e2 cd 03 23			call macro_forth_dsp_pop 
50e5				endm 
# End of macro FORTH_DSP_POP
50e5			 
50e5 d1					pop de     ; get file id 
50e6			 
50e6					; e = file id 
50e6					; l = file extent 
50e6			 
50e6			 
50e6					; construct request to access file extent 
50e6			 
50e6			;		ld a, e 
50e6 63					ld h, e 
50e7					 
50e7					 
50e7					 
50e7			 
50e7					; e has id 
50e7			 
50e7 11 af f9			ld de, store_page 
50ea					if DEBUG_FORTH_WORDS 
50ea						DMARK "REr" 
50ea f5				push af  
50eb 3a ff 50			ld a, (.dmark)  
50ee 32 a0 fd			ld (debug_mark),a  
50f1 3a 00 51			ld a, (.dmark+1)  
50f4 32 a1 fd			ld (debug_mark+1),a  
50f7 3a 01 51			ld a, (.dmark+2)  
50fa 32 a2 fd			ld (debug_mark+2),a  
50fd 18 03			jr .pastdmark  
50ff ..			.dmark: db "REr"  
5102 f1			.pastdmark: pop af  
5103			endm  
# End of macro DMARK
5103						CALLMONITOR 
5103 cd aa fd			call debug_vector  
5106				endm  
# End of macro CALLMONITOR
5106					endif 
5106 cd cd 09				call storage_read 
5109 cd 07 10			call ishlzero 
510c 28 22			jr z, .recnotfound 
510e			 
510e			 
510e					if DEBUG_FORTH_WORDS 
510e						DMARK "REe" 
510e f5				push af  
510f 3a 23 51			ld a, (.dmark)  
5112 32 a0 fd			ld (debug_mark),a  
5115 3a 24 51			ld a, (.dmark+1)  
5118 32 a1 fd			ld (debug_mark+1),a  
511b 3a 25 51			ld a, (.dmark+2)  
511e 32 a2 fd			ld (debug_mark+2),a  
5121 18 03			jr .pastdmark  
5123 ..			.dmark: db "REe"  
5126 f1			.pastdmark: pop af  
5127			endm  
# End of macro DMARK
5127						CALLMONITOR 
5127 cd aa fd			call debug_vector  
512a				endm  
# End of macro CALLMONITOR
512a					endif 
512a cd b4 20			call forth_push_str 
512d			 
512d					NEXTW 
512d c3 37 24			jp macro_next 
5130				endm 
# End of macro NEXTW
5130			 
5130			.recnotfound: 
5130					if DEBUG_FORTH_WORDS 
5130						DMARK "REf" 
5130 f5				push af  
5131 3a 45 51			ld a, (.dmark)  
5134 32 a0 fd			ld (debug_mark),a  
5137 3a 46 51			ld a, (.dmark+1)  
513a 32 a1 fd			ld (debug_mark+1),a  
513d 3a 47 51			ld a, (.dmark+2)  
5140 32 a2 fd			ld (debug_mark+2),a  
5143 18 03			jr .pastdmark  
5145 ..			.dmark: db "REf"  
5148 f1			.pastdmark: pop af  
5149			endm  
# End of macro DMARK
5149						CALLMONITOR 
5149 cd aa fd			call debug_vector  
514c				endm  
# End of macro CALLMONITOR
514c					endif 
514c 21 ff 00			ld hl, 255 
514f cd 46 20			call forth_push_numhl 
5152				NEXTW 
5152 c3 37 24			jp macro_next 
5155				endm 
# End of macro NEXTW
5155			 
5155			 
5155			.BREAD: 
5155			  
5155				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
5155 3a				db WORD_SYS_CORE+38             
5156 d8 51			dw .BWRITE            
5158 06				db 5 + 1 
5159 .. 00			db "BREAD",0              
515f				endm 
# End of macro CWHEAD
515f			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
515f			; | | > [!NOTE] 
515f			; | | > Compatible with PicoSPINet  
515f				 
515f					if DEBUG_FORTH_WORDS_KEY 
515f						DMARK "BRD" 
515f f5				push af  
5160 3a 74 51			ld a, (.dmark)  
5163 32 a0 fd			ld (debug_mark),a  
5166 3a 75 51			ld a, (.dmark+1)  
5169 32 a1 fd			ld (debug_mark+1),a  
516c 3a 76 51			ld a, (.dmark+2)  
516f 32 a2 fd			ld (debug_mark+2),a  
5172 18 03			jr .pastdmark  
5174 ..			.dmark: db "BRD"  
5177 f1			.pastdmark: pop af  
5178			endm  
# End of macro DMARK
5178						CALLMONITOR 
5178 cd aa fd			call debug_vector  
517b				endm  
# End of macro CALLMONITOR
517b					endif 
517b			 
517b				FORTH_DSP_VALUEHL 
517b cd 4b 22			call macro_dsp_valuehl 
517e				endm 
# End of macro FORTH_DSP_VALUEHL
517e			 
517e				FORTH_DSP_POP 
517e cd 03 23			call macro_forth_dsp_pop 
5181				endm 
# End of macro FORTH_DSP_POP
5181			 
5181				; calc block address 
5181			 
5181 eb				ex de, hl 
5182 3e 40			ld a, STORE_BLOCK_PHY 
5184 cd 61 0f			call Mult16 
5187			 
5187			 
5187 11 af f9			ld de, store_page 
518a			 
518a					if DEBUG_FORTH_WORDS 
518a						DMARK "BR1" 
518a f5				push af  
518b 3a 9f 51			ld a, (.dmark)  
518e 32 a0 fd			ld (debug_mark),a  
5191 3a a0 51			ld a, (.dmark+1)  
5194 32 a1 fd			ld (debug_mark+1),a  
5197 3a a1 51			ld a, (.dmark+2)  
519a 32 a2 fd			ld (debug_mark+2),a  
519d 18 03			jr .pastdmark  
519f ..			.dmark: db "BR1"  
51a2 f1			.pastdmark: pop af  
51a3			endm  
# End of macro DMARK
51a3						CALLMONITOR 
51a3 cd aa fd			call debug_vector  
51a6				endm  
# End of macro CALLMONITOR
51a6					endif 
51a6			 
51a6 cd 74 04			call storage_read_block 
51a9			 
51a9 cd 07 10			call ishlzero 
51ac 20 05			jr nz, .brfound 
51ae			 
51ae cd 46 20			call forth_push_numhl 
51b1 18 22			jr .brdone 
51b3			 
51b3			 
51b3			.brfound: 
51b3 21 b1 f9		        ld hl, store_page+2 
51b6			 
51b6					if DEBUG_FORTH_WORDS 
51b6						DMARK "BR2" 
51b6 f5				push af  
51b7 3a cb 51			ld a, (.dmark)  
51ba 32 a0 fd			ld (debug_mark),a  
51bd 3a cc 51			ld a, (.dmark+1)  
51c0 32 a1 fd			ld (debug_mark+1),a  
51c3 3a cd 51			ld a, (.dmark+2)  
51c6 32 a2 fd			ld (debug_mark+2),a  
51c9 18 03			jr .pastdmark  
51cb ..			.dmark: db "BR2"  
51ce f1			.pastdmark: pop af  
51cf			endm  
# End of macro DMARK
51cf						CALLMONITOR 
51cf cd aa fd			call debug_vector  
51d2				endm  
# End of macro CALLMONITOR
51d2					endif 
51d2			 
51d2 cd b4 20			call forth_push_str 
51d5			 
51d5			 
51d5			.brdone: 
51d5			 
51d5					NEXTW 
51d5 c3 37 24			jp macro_next 
51d8				endm 
# End of macro NEXTW
51d8			.BWRITE: 
51d8				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
51d8 3a				db WORD_SYS_CORE+38             
51d9 6d 52			dw .BUPD            
51db 07				db 6 + 1 
51dc .. 00			db "BWRITE",0              
51e3				endm 
# End of macro CWHEAD
51e3			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
51e3			; | | > [!NOTE] 
51e3			; | | > Compatible with PicoSPINet  
51e3			 
51e3					if DEBUG_FORTH_WORDS_KEY 
51e3						DMARK "BWR" 
51e3 f5				push af  
51e4 3a f8 51			ld a, (.dmark)  
51e7 32 a0 fd			ld (debug_mark),a  
51ea 3a f9 51			ld a, (.dmark+1)  
51ed 32 a1 fd			ld (debug_mark+1),a  
51f0 3a fa 51			ld a, (.dmark+2)  
51f3 32 a2 fd			ld (debug_mark+2),a  
51f6 18 03			jr .pastdmark  
51f8 ..			.dmark: db "BWR"  
51fb f1			.pastdmark: pop af  
51fc			endm  
# End of macro DMARK
51fc						CALLMONITOR 
51fc cd aa fd			call debug_vector  
51ff				endm  
# End of macro CALLMONITOR
51ff					endif 
51ff			 
51ff				FORTH_DSP_VALUEHL 
51ff cd 4b 22			call macro_dsp_valuehl 
5202				endm 
# End of macro FORTH_DSP_VALUEHL
5202			 
5202				; calc block address 
5202			 
5202 eb				ex de, hl 
5203 3e 40			ld a, STORE_BLOCK_PHY 
5205 cd 61 0f			call Mult16 
5208			 
5208 e5				push hl         ; address 
5209			 
5209				FORTH_DSP_POP 
5209 cd 03 23			call macro_forth_dsp_pop 
520c				endm 
# End of macro FORTH_DSP_POP
520c			 
520c				FORTH_DSP_VALUEHL 
520c cd 4b 22			call macro_dsp_valuehl 
520f				endm 
# End of macro FORTH_DSP_VALUEHL
520f			 
520f				FORTH_DSP_POP 
520f cd 03 23			call macro_forth_dsp_pop 
5212				endm 
# End of macro FORTH_DSP_POP
5212			 
5212 cd b0 0c			call storage_clear_page 
5215			 
5215				; copy string to store page 
5215			 
5215 e5				push hl     ; save string address 
5216			 
5216 3e 00			ld a, 0 
5218 cd 4f 13			call strlent 
521b			 
521b 23				inc hl 
521c			 
521c 4d				ld c, l 
521d 06 00			ld b, 0 
521f			 
521f e1				pop hl 
5220 11 b1 f9			ld de, store_page + 2 
5223					if DEBUG_FORTH_WORDS 
5223						DMARK "BW1" 
5223 f5				push af  
5224 3a 38 52			ld a, (.dmark)  
5227 32 a0 fd			ld (debug_mark),a  
522a 3a 39 52			ld a, (.dmark+1)  
522d 32 a1 fd			ld (debug_mark+1),a  
5230 3a 3a 52			ld a, (.dmark+2)  
5233 32 a2 fd			ld (debug_mark+2),a  
5236 18 03			jr .pastdmark  
5238 ..			.dmark: db "BW1"  
523b f1			.pastdmark: pop af  
523c			endm  
# End of macro DMARK
523c						CALLMONITOR 
523c cd aa fd			call debug_vector  
523f				endm  
# End of macro CALLMONITOR
523f					endif 
523f ed b0			ldir 
5241			 
5241			 
5241				; poke the start of the block with flags to prevent high level file ops hitting the block 
5241			 
5241 21 ff ff			ld hl, $ffff 
5244			 
5244 22 af f9			ld (store_page), hl	 
5247				 
5247 e1				pop hl    ; get address 
5248 11 af f9			ld de, store_page 
524b			 
524b					if DEBUG_FORTH_WORDS 
524b						DMARK "BW2" 
524b f5				push af  
524c 3a 60 52			ld a, (.dmark)  
524f 32 a0 fd			ld (debug_mark),a  
5252 3a 61 52			ld a, (.dmark+1)  
5255 32 a1 fd			ld (debug_mark+1),a  
5258 3a 62 52			ld a, (.dmark+2)  
525b 32 a2 fd			ld (debug_mark+2),a  
525e 18 03			jr .pastdmark  
5260 ..			.dmark: db "BW2"  
5263 f1			.pastdmark: pop af  
5264			endm  
# End of macro DMARK
5264						CALLMONITOR 
5264 cd aa fd			call debug_vector  
5267				endm  
# End of macro CALLMONITOR
5267					endif 
5267			 
5267 cd d9 04			call storage_write_block 
526a			 
526a					NEXTW 
526a c3 37 24			jp macro_next 
526d				endm 
# End of macro NEXTW
526d			 
526d			.BUPD: 
526d				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
526d 3a				db WORD_SYS_CORE+38             
526e c3 52			dw .BYID            
5270 05				db 4 + 1 
5271 .. 00			db "BUPD",0              
5276				endm 
# End of macro CWHEAD
5276			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
5276			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
5276			; | | or completely different file system structure. 
5276			; | | > [!NOTE] 
5276			; | | > Compatible with PicoSPINet  
5276			 
5276					if DEBUG_FORTH_WORDS_KEY 
5276						DMARK "BUD" 
5276 f5				push af  
5277 3a 8b 52			ld a, (.dmark)  
527a 32 a0 fd			ld (debug_mark),a  
527d 3a 8c 52			ld a, (.dmark+1)  
5280 32 a1 fd			ld (debug_mark+1),a  
5283 3a 8d 52			ld a, (.dmark+2)  
5286 32 a2 fd			ld (debug_mark+2),a  
5289 18 03			jr .pastdmark  
528b ..			.dmark: db "BUD"  
528e f1			.pastdmark: pop af  
528f			endm  
# End of macro DMARK
528f						CALLMONITOR 
528f cd aa fd			call debug_vector  
5292				endm  
# End of macro CALLMONITOR
5292					endif 
5292			 
5292				FORTH_DSP_VALUEHL 
5292 cd 4b 22			call macro_dsp_valuehl 
5295				endm 
# End of macro FORTH_DSP_VALUEHL
5295			 
5295				; calc block address 
5295			 
5295 eb				ex de, hl 
5296 3e 40			ld a, STORE_BLOCK_PHY 
5298 cd 61 0f			call Mult16 
529b			 
529b				FORTH_DSP_POP 
529b cd 03 23			call macro_forth_dsp_pop 
529e				endm 
# End of macro FORTH_DSP_POP
529e			 
529e			 
529e 11 af f9			ld de, store_page 
52a1			 
52a1					if DEBUG_FORTH_WORDS 
52a1						DMARK "BUe" 
52a1 f5				push af  
52a2 3a b6 52			ld a, (.dmark)  
52a5 32 a0 fd			ld (debug_mark),a  
52a8 3a b7 52			ld a, (.dmark+1)  
52ab 32 a1 fd			ld (debug_mark+1),a  
52ae 3a b8 52			ld a, (.dmark+2)  
52b1 32 a2 fd			ld (debug_mark+2),a  
52b4 18 03			jr .pastdmark  
52b6 ..			.dmark: db "BUe"  
52b9 f1			.pastdmark: pop af  
52ba			endm  
# End of macro DMARK
52ba						CALLMONITOR 
52ba cd aa fd			call debug_vector  
52bd				endm  
# End of macro CALLMONITOR
52bd					endif 
52bd			 
52bd cd d9 04			call storage_write_block 
52c0			 
52c0					NEXTW 
52c0 c3 37 24			jp macro_next 
52c3				endm 
# End of macro NEXTW
52c3			 
52c3			.BYID: 
52c3			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
52c3			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
52c3			; 
52c3			;		 
52c3			;		if DEBUG_FORTH_WORDS_KEY 
52c3			;			DMARK "BYID" 
52c3			;			CALLMONITOR 
52c3			;		endif 
52c3			; 
52c3			;		; get direct address 
52c3			; 
52c3			;		FORTH_DSP_VALUEHL 
52c3			; 
52c3			;		FORTH_DSP_POP 
52c3			; 
52c3			;	; calc block address 
52c3			; 
52c3			;	ex de, hl 
52c3			;	ld a, STORE_BLOCK_PHY 
52c3			;	call Mult16 
52c3			;	;	do BREAD with number as param 
52c3			;	; push the file name	 
52c3			;	ld de, store_page 
52c3			;	call storage_read_block 
52c3			 ;       ld hl, store_page+2 
52c3			; 
52c3			; 
52c3			;		NEXTW 
52c3			;.BYNAME: 
52c3				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
52c3 3a				db WORD_SYS_CORE+38             
52c4 dc 52			dw .DIR            
52c6 06				db 5 + 1 
52c7 .. 00			db "GETID",0              
52cd				endm 
# End of macro CWHEAD
52cd			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
52cd			; | | > [!NOTE] 
52cd			; | | > Compatible with PicoSPINet  
52cd			 
52cd					; get pointer to file name to seek 
52cd			 
52cd					FORTH_DSP_VALUEHL 
52cd cd 4b 22			call macro_dsp_valuehl 
52d0				endm 
# End of macro FORTH_DSP_VALUEHL
52d0			 
52d0			 
52d0 cd 9b 03				call storage_getid  
52d3			 
52d3					FORTH_DSP_POP 
52d3 cd 03 23			call macro_forth_dsp_pop 
52d6				endm 
# End of macro FORTH_DSP_POP
52d6			 
52d6 cd 46 20				call forth_push_numhl 
52d9			 
52d9					NEXTW 
52d9 c3 37 24			jp macro_next 
52dc				endm 
# End of macro NEXTW
52dc			; 
52dc			.DIR: 
52dc				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
52dc 3a				db WORD_SYS_CORE+38             
52dd e0 53			dw .SAVE            
52df 04				db 3 + 1 
52e0 .. 00			db "DIR",0              
52e4				endm 
# End of macro CWHEAD
52e4			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
52e4			; | | > [!NOTE] 
52e4			; | | > Compatible with PicoSPINet  
52e4			 
52e4					if DEBUG_FORTH_WORDS_KEY 
52e4						DMARK "DIR" 
52e4 f5				push af  
52e5 3a f9 52			ld a, (.dmark)  
52e8 32 a0 fd			ld (debug_mark),a  
52eb 3a fa 52			ld a, (.dmark+1)  
52ee 32 a1 fd			ld (debug_mark+1),a  
52f1 3a fb 52			ld a, (.dmark+2)  
52f4 32 a2 fd			ld (debug_mark+2),a  
52f7 18 03			jr .pastdmark  
52f9 ..			.dmark: db "DIR"  
52fc f1			.pastdmark: pop af  
52fd			endm  
# End of macro DMARK
52fd						CALLMONITOR 
52fd cd aa fd			call debug_vector  
5300				endm  
# End of macro CALLMONITOR
5300					endif 
5300 cd 25 05			call storage_get_block_0 
5303			 
5303 21 af f9			ld hl, store_page     ; get current id count 
5306 46				ld b, (hl) 
5307 0e 00			ld c, 0    ; count of files   
5309					if DEBUG_FORTH_WORDS 
5309						DMARK "DI1" 
5309 f5				push af  
530a 3a 1e 53			ld a, (.dmark)  
530d 32 a0 fd			ld (debug_mark),a  
5310 3a 1f 53			ld a, (.dmark+1)  
5313 32 a1 fd			ld (debug_mark+1),a  
5316 3a 20 53			ld a, (.dmark+2)  
5319 32 a2 fd			ld (debug_mark+2),a  
531c 18 03			jr .pastdmark  
531e ..			.dmark: db "DI1"  
5321 f1			.pastdmark: pop af  
5322			endm  
# End of macro DMARK
5322						CALLMONITOR 
5322 cd aa fd			call debug_vector  
5325				endm  
# End of macro CALLMONITOR
5325					endif 
5325			 
5325				; check for empty drive 
5325			 
5325 3e 00			ld a, 0 
5327 b8				cp b 
5328 ca 96 53			jp z, .dirdone 
532b			 
532b				; for each of the current ids do a search for them and if found push to stack 
532b			 
532b c5			.diritem:	push bc 
532c 21 40 00				ld hl, STORE_BLOCK_PHY 
532f 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5331 58					ld e,b 
5332			 
5332			;		if DEBUG_FORTH_WORDS 
5332			;			DMARK "DI2" 
5332			;			CALLMONITOR 
5332			;		endif 
5332			 
5332 cd a7 07				call storage_findnextid 
5335			 
5335			;		if DEBUG_FORTH_WORDS 
5335			;			DMARK "DI3" 
5335			;			CALLMONITOR 
5335			;		endif 
5335			 
5335					; if found hl will be non zero 
5335			 
5335 cd 07 10				call ishlzero 
5338			;		ld a, l 
5338			;		add h 
5338			; 
5338			;		cp 0 
5338 28 59				jr z, .dirnotfound 
533a			 
533a					; increase count 
533a			 
533a c1					pop bc	 
533b 0c					inc c 
533c c5					push bc 
533d					 
533d			 
533d					; get file header and push the file name 
533d			 
533d 11 af f9				ld de, store_page 
5340 cd 74 04				call storage_read_block 
5343			 
5343					; push file id to stack 
5343				 
5343 3a af f9				ld a, (store_page) 
5346 26 00				ld h, 0 
5348 6f					ld l, a 
5349 cd 46 20				call forth_push_numhl 
534c			 
534c					; push extent count to stack  
534c				 
534c 3a b1 f9				ld a, (store_page+2) 
534f 26 00				ld h, 0 
5351 6f					ld l, a 
5352 cd 46 20				call forth_push_numhl 
5355			 
5355					; push file name 
5355			 
5355 21 b2 f9				ld hl, store_page+3 
5358					if DEBUG_FORTH_WORDS 
5358						DMARK "DI5" 
5358 f5				push af  
5359 3a 6d 53			ld a, (.dmark)  
535c 32 a0 fd			ld (debug_mark),a  
535f 3a 6e 53			ld a, (.dmark+1)  
5362 32 a1 fd			ld (debug_mark+1),a  
5365 3a 6f 53			ld a, (.dmark+2)  
5368 32 a2 fd			ld (debug_mark+2),a  
536b 18 03			jr .pastdmark  
536d ..			.dmark: db "DI5"  
5370 f1			.pastdmark: pop af  
5371			endm  
# End of macro DMARK
5371						CALLMONITOR 
5371 cd aa fd			call debug_vector  
5374				endm  
# End of macro CALLMONITOR
5374					endif 
5374 cd b4 20				call forth_push_str 
5377					if DEBUG_FORTH_WORDS 
5377						DMARK "DI6" 
5377 f5				push af  
5378 3a 8c 53			ld a, (.dmark)  
537b 32 a0 fd			ld (debug_mark),a  
537e 3a 8d 53			ld a, (.dmark+1)  
5381 32 a1 fd			ld (debug_mark+1),a  
5384 3a 8e 53			ld a, (.dmark+2)  
5387 32 a2 fd			ld (debug_mark+2),a  
538a 18 03			jr .pastdmark  
538c ..			.dmark: db "DI6"  
538f f1			.pastdmark: pop af  
5390			endm  
# End of macro DMARK
5390						CALLMONITOR 
5390 cd aa fd			call debug_vector  
5393				endm  
# End of macro CALLMONITOR
5393					endif 
5393			.dirnotfound: 
5393 c1					pop bc     
5394 10 95				djnz .diritem 
5396				 
5396			.dirdone:	 
5396					if DEBUG_FORTH_WORDS 
5396						DMARK "DI7" 
5396 f5				push af  
5397 3a ab 53			ld a, (.dmark)  
539a 32 a0 fd			ld (debug_mark),a  
539d 3a ac 53			ld a, (.dmark+1)  
53a0 32 a1 fd			ld (debug_mark+1),a  
53a3 3a ad 53			ld a, (.dmark+2)  
53a6 32 a2 fd			ld (debug_mark+2),a  
53a9 18 03			jr .pastdmark  
53ab ..			.dmark: db "DI7"  
53ae f1			.pastdmark: pop af  
53af			endm  
# End of macro DMARK
53af						CALLMONITOR 
53af cd aa fd			call debug_vector  
53b2				endm  
# End of macro CALLMONITOR
53b2					endif 
53b2			 
53b2					; push a count of the dir items found 
53b2			 
53b2 26 00				ld h, 0 
53b4 69					ld l, c 
53b5 cd 46 20				call forth_push_numhl 
53b8			 
53b8					; push the bank label 
53b8			 
53b8 cd 25 05				call storage_get_block_0 
53bb			 
53bb				 
53bb 21 b2 f9		 		ld hl, store_page+3 
53be			 
53be					if DEBUG_FORTH_WORDS 
53be						DMARK "DI8" 
53be f5				push af  
53bf 3a d3 53			ld a, (.dmark)  
53c2 32 a0 fd			ld (debug_mark),a  
53c5 3a d4 53			ld a, (.dmark+1)  
53c8 32 a1 fd			ld (debug_mark+1),a  
53cb 3a d5 53			ld a, (.dmark+2)  
53ce 32 a2 fd			ld (debug_mark+2),a  
53d1 18 03			jr .pastdmark  
53d3 ..			.dmark: db "DI8"  
53d6 f1			.pastdmark: pop af  
53d7			endm  
# End of macro DMARK
53d7						CALLMONITOR 
53d7 cd aa fd			call debug_vector  
53da				endm  
# End of macro CALLMONITOR
53da					endif 
53da cd b4 20				call forth_push_str 
53dd			 
53dd			 
53dd				 
53dd					NEXTW 
53dd c3 37 24			jp macro_next 
53e0				endm 
# End of macro NEXTW
53e0			.SAVE: 
53e0			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
53e0			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
53e0			;		NEXTW 
53e0			;.LOAD: 
53e0			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
53e0			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
53e0			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
53e0			;; > > The LOAD command can not be used in any user words or compound lines. 
53e0			; 
53e0			;		; store_openext use it. If zero it is EOF 
53e0			; 
53e0			;		; read block from current stream id 
53e0			;		; if the block does not contain zero term keep reading blocks until zero found 
53e0			;		; push the block to stack 
53e0			;		; save the block id to stream 
53e0			; 
53e0			; 
53e0			;		FORTH_DSP_VALUEHL 
53e0			; 
53e0			;;		push hl 
53e0			; 
53e0			;	if DEBUG_STORESE 
53e0			;		DMARK "LOA" 
53e0			;		CALLMONITOR 
53e0			;	endif 
53e0			;		FORTH_DSP_POP 
53e0			; 
53e0			;;		pop hl 
53e0			; 
53e0			;		ld h, l 
53e0			;		ld l, 0 
53e0			; 
53e0			;		push hl     ; stack holds current file id and extent to work with 
53e0			; 
53e0			; 
53e0			;		ld de, store_page      ; get block zero of file 
53e0			;	if DEBUG_STORESE 
53e0			;		DMARK "LO0" 
53e0			;		CALLMONITOR 
53e0			;	endif 
53e0			;		call storage_read 
53e0			; 
53e0			;		ld a, (store_page+2)    ; max extents for this file 
53e0			;		ld  (store_openmaxext),a   ; get our limit 
53e0			; 
53e0			;	if DEBUG_STORESE 
53e0			;		DMARK "LOE" 
53e0			;		CALLMONITOR 
53e0			;	endif 
53e0			; 
53e0			;; TODO dont know why max extents are not present 
53e0			;;		cp 0 
53e0			;;		jp z, .loadeof     ; dont read past eof 
53e0			; 
53e0			;;		ld a, 1   ; start from the head of the file 
53e0			; 
53e0			;.loadline:	pop hl 
53e0			;		inc hl 
53e0			;		ld  a, (store_openmaxext)   ; get our limit 
53e0			;	if DEBUG_STORESE 
53e0			;		DMARK "LOx" 
53e0			;		CALLMONITOR 
53e0			;	endif 
53e0			;		inc a 
53e0			;		cp l 
53e0			;		jp z, .loadeof 
53e0			;		push hl    ; save current extent 
53e0			; 
53e0			;		ld de, store_page 
53e0			; 
53e0			;	if DEBUG_STORESE 
53e0			;		DMARK "LO1" 
53e0			;		CALLMONITOR 
53e0			;	endif 
53e0			;		call storage_read 
53e0			; 
53e0			;	if DEBUG_STORESE 
53e0			;		DMARK "LO2" 
53e0			;		CALLMONITOR 
53e0			;	endif 
53e0			;	call ishlzero 
53e0			;	ld a, l 
53e0			;	add h 
53e0			;	cp 0 
53e0			;	jr z, .loadeof 
53e0			; 
53e0			;	; not eof so hl should point to data to exec 
53e0			; 
53e0			;	; will need to add the FORTH_END_BUFFER flag 
53e0			 ; 
53e0			;	ld hl, store_page+2 
53e0			;	ld bc, 255 
53e0			;	ld a, 0 
53e0			;	cpir 
53e0			;	if DEBUG_STORESE 
53e0			;		DMARK "LOt" 
53e0			;		CALLMONITOR 
53e0			;	endif 
53e0			;	dec hl 
53e0			;	ld a, ' ' 
53e0			;	ld (hl), a 
53e0			;	inc hl 
53e0			;	ld (hl), a 
53e0			;	inc hl 
53e0			;	ld (hl), a 
53e0			;	inc hl 
53e0			;	ld a, FORTH_END_BUFFER 
53e0			;	ld (hl), a 
53e0			; 
53e0			;	; TODO handle more than a single block read 
53e0			; 
53e0			; 
53e0			;	ld hl, store_page+2 
53e0			; 
53e0			;	ld (os_tok_ptr), hl 
53e0			; 
53e0			;	if DEBUG_STORESE 
53e0			;		DMARK "LO3" 
53e0			;		CALLMONITOR 
53e0			;	endif 
53e0			; 
53e0			;	call forthparse 
53e0			;	call forthexec 
53e0			;	call forthexec_cleanup 
53e0			; 
53e0			;	; go to next extent 
53e0			; 
53e0			;	; get next block  or mark as eof 
53e0			;	jp .loadline 
53e0			; 
53e0			; 
53e0			; 
53e0			;	       NEXTW 
53e0			;.loadeof:	ld a, 0 
53e0			;		ld (store_openext), a 
53e0			; 
53e0			;	if DEBUG_STORESE 
53e0			;		DMARK "LOF" 
53e0			;		CALLMONITOR 
53e0			;	endif 
53e0			;		ret 
53e0			;		;NEXTW 
53e0			;.BSAVE:   
53e0			; 
53e0			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
53e0			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
53e0			;		NEXTW 
53e0			;.BLOAD: 
53e0			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
53e0			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
53e0			;		NEXTW 
53e0			;;;; counter gap 
53e0			 
53e0			 
53e0			.SEO: 
53e0				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
53e0 64				db WORD_SYS_CORE+80             
53e1 ff 53			dw .SEI            
53e3 04				db 3 + 1 
53e4 .. 00			db "SEO",0              
53e8				endm 
# End of macro CWHEAD
53e8			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
53e8			 
53e8					; get port 
53e8			 
53e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53e8 cd 4b 22			call macro_dsp_valuehl 
53eb				endm 
# End of macro FORTH_DSP_VALUEHL
53eb			 
53eb e5					push hl    ; u2 - byte 
53ec			 
53ec					; destroy value TOS 
53ec			 
53ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53ec cd 03 23			call macro_forth_dsp_pop 
53ef				endm 
# End of macro FORTH_DSP_POP
53ef			 
53ef					; get byte to send 
53ef			 
53ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53ef cd 4b 22			call macro_dsp_valuehl 
53f2				endm 
# End of macro FORTH_DSP_VALUEHL
53f2			 
53f2 e5					push hl    ; u1 - addr 
53f3			 
53f3					; destroy value TOS 
53f3			 
53f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53f3 cd 03 23			call macro_forth_dsp_pop 
53f6				endm 
# End of macro FORTH_DSP_POP
53f6			 
53f6					; one value on hl get other one back 
53f6			 
53f6 d1					pop de   ; u1 - byte 
53f7			 
53f7 e1					pop hl   ; u2 - addr 
53f8			 
53f8					; TODO Send SPI byte 
53f8			 
53f8			 
53f8 7b					ld a, e 
53f9 cd 79 02				call se_writebyte 
53fc			 
53fc					 
53fc			 
53fc					NEXTW 
53fc c3 37 24			jp macro_next 
53ff				endm 
# End of macro NEXTW
53ff			 
53ff			.SEI: 
53ff				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
53ff 65				db WORD_SYS_CORE+81             
5400 19 54			dw .SFREE            
5402 04				db 3 + 1 
5403 .. 00			db "SEI",0              
5407				endm 
# End of macro CWHEAD
5407			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5407			 
5407					; get port 
5407			 
5407					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5407 cd 4b 22			call macro_dsp_valuehl 
540a				endm 
# End of macro FORTH_DSP_VALUEHL
540a			 
540a			;		push hl 
540a			 
540a					; destroy value TOS 
540a			 
540a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
540a cd 03 23			call macro_forth_dsp_pop 
540d				endm 
# End of macro FORTH_DSP_POP
540d			 
540d					; one value on hl get other one back 
540d			 
540d			;		pop hl 
540d			 
540d			 
540d					; TODO Get SPI byte 
540d			 
540d cd 1b 03				call se_readbyte 
5410			 
5410 26 00				ld h, 0 
5412 6f					ld l, a 
5413 cd 46 20				call forth_push_numhl 
5416			 
5416					NEXTW 
5416 c3 37 24			jp macro_next 
5419				endm 
# End of macro NEXTW
5419			 
5419			.SFREE: 
5419				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5419 67				db WORD_SYS_CORE+83             
541a 48 54			dw .SIZE            
541c 06				db 5 + 1 
541d .. 00			db "FFREE",0              
5423				endm 
# End of macro CWHEAD
5423			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5423			; | | > [!NOTE] 
5423			; | | > Compatible with PicoSPINet  
5423					if DEBUG_FORTH_WORDS_KEY 
5423						DMARK "FFR" 
5423 f5				push af  
5424 3a 38 54			ld a, (.dmark)  
5427 32 a0 fd			ld (debug_mark),a  
542a 3a 39 54			ld a, (.dmark+1)  
542d 32 a1 fd			ld (debug_mark+1),a  
5430 3a 3a 54			ld a, (.dmark+2)  
5433 32 a2 fd			ld (debug_mark+2),a  
5436 18 03			jr .pastdmark  
5438 ..			.dmark: db "FFR"  
543b f1			.pastdmark: pop af  
543c			endm  
# End of macro DMARK
543c						CALLMONITOR 
543c cd aa fd			call debug_vector  
543f				endm  
# End of macro CALLMONITOR
543f					endif 
543f			 
543f cd 41 08				call storage_freeblocks 
5442			 
5442 cd 46 20				call forth_push_numhl 
5445			 
5445				       NEXTW 
5445 c3 37 24			jp macro_next 
5448				endm 
# End of macro NEXTW
5448			.SIZE: 
5448				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5448 67				db WORD_SYS_CORE+83             
5449 7c 54			dw .CREATE            
544b 05				db 4 + 1 
544c .. 00			db "SIZE",0              
5451				endm 
# End of macro CWHEAD
5451			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5451			; | | > [!NOTE] 
5451			; | | > Compatible with PicoSPINet  
5451					if DEBUG_FORTH_WORDS_KEY 
5451						DMARK "SIZ" 
5451 f5				push af  
5452 3a 66 54			ld a, (.dmark)  
5455 32 a0 fd			ld (debug_mark),a  
5458 3a 67 54			ld a, (.dmark+1)  
545b 32 a1 fd			ld (debug_mark+1),a  
545e 3a 68 54			ld a, (.dmark+2)  
5461 32 a2 fd			ld (debug_mark+2),a  
5464 18 03			jr .pastdmark  
5466 ..			.dmark: db "SIZ"  
5469 f1			.pastdmark: pop af  
546a			endm  
# End of macro DMARK
546a						CALLMONITOR 
546a cd aa fd			call debug_vector  
546d				endm  
# End of macro CALLMONITOR
546d					endif 
546d			 
546d					FORTH_DSP_VALUEHL 
546d cd 4b 22			call macro_dsp_valuehl 
5470				endm 
# End of macro FORTH_DSP_VALUEHL
5470			;		push hl 
5470					FORTH_DSP_POP 
5470 cd 03 23			call macro_forth_dsp_pop 
5473				endm 
# End of macro FORTH_DSP_POP
5473			;		pop hl 
5473 cd a3 04				call storage_file_size 
5476			 
5476 cd 46 20				call forth_push_numhl 
5479			  
5479			 
5479				       NEXTW 
5479 c3 37 24			jp macro_next 
547c				endm 
# End of macro NEXTW
547c			 
547c			.CREATE: 
547c				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
547c 68				db WORD_SYS_CORE+84             
547d ea 54			dw .APPEND            
547f 07				db 6 + 1 
5480 .. 00			db "CREATE",0              
5487				endm 
# End of macro CWHEAD
5487			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5487			; | | e.g.  
5487			; | | TestProgram CREATE 
5487			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5487			; | |  
5487			; | | Max file IDs are 255. 
5487			; | |  
5487			; | | > [!NOTE] 
5487			; | | > Compatible with PicoSPINet  
5487					 
5487					if DEBUG_FORTH_WORDS_KEY 
5487						DMARK "CRT" 
5487 f5				push af  
5488 3a 9c 54			ld a, (.dmark)  
548b 32 a0 fd			ld (debug_mark),a  
548e 3a 9d 54			ld a, (.dmark+1)  
5491 32 a1 fd			ld (debug_mark+1),a  
5494 3a 9e 54			ld a, (.dmark+2)  
5497 32 a2 fd			ld (debug_mark+2),a  
549a 18 03			jr .pastdmark  
549c ..			.dmark: db "CRT"  
549f f1			.pastdmark: pop af  
54a0			endm  
# End of macro DMARK
54a0						CALLMONITOR 
54a0 cd aa fd			call debug_vector  
54a3				endm  
# End of macro CALLMONITOR
54a3					endif 
54a3			;		call storage_get_block_0 
54a3			 
54a3					; TODO pop hl 
54a3			 
54a3					;v5 FORTH_DSP_VALUE 
54a3					FORTH_DSP_VALUE 
54a3 cd 34 22			call macro_forth_dsp_value 
54a6				endm 
# End of macro FORTH_DSP_VALUE
54a6			 
54a6				if DEBUG_STORESE 
54a6					DMARK "CR1" 
54a6 f5				push af  
54a7 3a bb 54			ld a, (.dmark)  
54aa 32 a0 fd			ld (debug_mark),a  
54ad 3a bc 54			ld a, (.dmark+1)  
54b0 32 a1 fd			ld (debug_mark+1),a  
54b3 3a bd 54			ld a, (.dmark+2)  
54b6 32 a2 fd			ld (debug_mark+2),a  
54b9 18 03			jr .pastdmark  
54bb ..			.dmark: db "CR1"  
54be f1			.pastdmark: pop af  
54bf			endm  
# End of macro DMARK
54bf					CALLMONITOR 
54bf cd aa fd			call debug_vector  
54c2				endm  
# End of macro CALLMONITOR
54c2				endif 
54c2			;		push hl 
54c2			;		FORTH_DSP_POP 
54c2			;		pop hl 
54c2			 
54c2			;		inc hl   ; move past the type marker 
54c2			 
54c2 cd 77 08				call storage_create 
54c5			 
54c5				if DEBUG_STORESE 
54c5					DMARK "CT1" 
54c5 f5				push af  
54c6 3a da 54			ld a, (.dmark)  
54c9 32 a0 fd			ld (debug_mark),a  
54cc 3a db 54			ld a, (.dmark+1)  
54cf 32 a1 fd			ld (debug_mark+1),a  
54d2 3a dc 54			ld a, (.dmark+2)  
54d5 32 a2 fd			ld (debug_mark+2),a  
54d8 18 03			jr .pastdmark  
54da ..			.dmark: db "CT1"  
54dd f1			.pastdmark: pop af  
54de			endm  
# End of macro DMARK
54de					CALLMONITOR 
54de cd aa fd			call debug_vector  
54e1				endm  
# End of macro CALLMONITOR
54e1				endif 
54e1			;		push hl 
54e1					FORTH_DSP_POP 
54e1 cd 03 23			call macro_forth_dsp_pop 
54e4				endm 
# End of macro FORTH_DSP_POP
54e4			;		pop hl 
54e4					; push file id to stack 
54e4 cd 46 20				call forth_push_numhl 
54e7			 
54e7			 
54e7			 
54e7				       NEXTW 
54e7 c3 37 24			jp macro_next 
54ea				endm 
# End of macro NEXTW
54ea			 
54ea			.APPEND: 
54ea				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
54ea 69				db WORD_SYS_CORE+85             
54eb 7b 55			dw .SDEL            
54ed 07				db 6 + 1 
54ee .. 00			db "APPEND",0              
54f5				endm 
# End of macro CWHEAD
54f5			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
54f5			; | | e.g. 
54f5			; | | Test CREATE      -> $01 
54f5			; | | "A string to add to file" $01 APPEND 
54f5			; | |  
54f5			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
54f5			; | | > [!NOTE] 
54f5			; | | > Compatible with PicoSPINet  
54f5					if DEBUG_FORTH_WORDS_KEY 
54f5						DMARK "APP" 
54f5 f5				push af  
54f6 3a 0a 55			ld a, (.dmark)  
54f9 32 a0 fd			ld (debug_mark),a  
54fc 3a 0b 55			ld a, (.dmark+1)  
54ff 32 a1 fd			ld (debug_mark+1),a  
5502 3a 0c 55			ld a, (.dmark+2)  
5505 32 a2 fd			ld (debug_mark+2),a  
5508 18 03			jr .pastdmark  
550a ..			.dmark: db "APP"  
550d f1			.pastdmark: pop af  
550e			endm  
# End of macro DMARK
550e						CALLMONITOR 
550e cd aa fd			call debug_vector  
5511				endm  
# End of macro CALLMONITOR
5511					endif 
5511			 
5511					FORTH_DSP_VALUEHL 
5511 cd 4b 22			call macro_dsp_valuehl 
5514				endm 
# End of macro FORTH_DSP_VALUEHL
5514 e5					push hl 	; save file id 
5515			 
5515				if DEBUG_STORESE 
5515					DMARK "AP1" 
5515 f5				push af  
5516 3a 2a 55			ld a, (.dmark)  
5519 32 a0 fd			ld (debug_mark),a  
551c 3a 2b 55			ld a, (.dmark+1)  
551f 32 a1 fd			ld (debug_mark+1),a  
5522 3a 2c 55			ld a, (.dmark+2)  
5525 32 a2 fd			ld (debug_mark+2),a  
5528 18 03			jr .pastdmark  
552a ..			.dmark: db "AP1"  
552d f1			.pastdmark: pop af  
552e			endm  
# End of macro DMARK
552e					CALLMONITOR 
552e cd aa fd			call debug_vector  
5531				endm  
# End of macro CALLMONITOR
5531				endif 
5531					FORTH_DSP_POP 
5531 cd 03 23			call macro_forth_dsp_pop 
5534				endm 
# End of macro FORTH_DSP_POP
5534			 
5534					FORTH_DSP_VALUEHL 
5534 cd 4b 22			call macro_dsp_valuehl 
5537				endm 
# End of macro FORTH_DSP_VALUEHL
5537					;v5 FORTH_DSP_VALUE 
5537 e5					push hl 	; save ptr to string to save 
5538			 
5538				if DEBUG_STORESE 
5538					DMARK "AP1" 
5538 f5				push af  
5539 3a 4d 55			ld a, (.dmark)  
553c 32 a0 fd			ld (debug_mark),a  
553f 3a 4e 55			ld a, (.dmark+1)  
5542 32 a1 fd			ld (debug_mark+1),a  
5545 3a 4f 55			ld a, (.dmark+2)  
5548 32 a2 fd			ld (debug_mark+2),a  
554b 18 03			jr .pastdmark  
554d ..			.dmark: db "AP1"  
5550 f1			.pastdmark: pop af  
5551			endm  
# End of macro DMARK
5551					CALLMONITOR 
5551 cd aa fd			call debug_vector  
5554				endm  
# End of macro CALLMONITOR
5554				endif 
5554					FORTH_DSP_POP 
5554 cd 03 23			call macro_forth_dsp_pop 
5557				endm 
# End of macro FORTH_DSP_POP
5557			 
5557 d1					pop de 
5558 e1					pop hl 
5559				if DEBUG_STORESE 
5559					DMARK "AP2" 
5559 f5				push af  
555a 3a 6e 55			ld a, (.dmark)  
555d 32 a0 fd			ld (debug_mark),a  
5560 3a 6f 55			ld a, (.dmark+1)  
5563 32 a1 fd			ld (debug_mark+1),a  
5566 3a 70 55			ld a, (.dmark+2)  
5569 32 a2 fd			ld (debug_mark+2),a  
556c 18 03			jr .pastdmark  
556e ..			.dmark: db "AP2"  
5571 f1			.pastdmark: pop af  
5572			endm  
# End of macro DMARK
5572					CALLMONITOR 
5572 cd aa fd			call debug_vector  
5575				endm  
# End of macro CALLMONITOR
5575				endif 
5575					;inc de ; skip var type indicator 
5575			 
5575					; TODO how to append numerics???? 
5575			 
5575 cd 64 0b				call storage_append		 
5578			 
5578				       NEXTW 
5578 c3 37 24			jp macro_next 
557b				endm 
# End of macro NEXTW
557b			.SDEL: 
557b				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
557b 6a				db WORD_SYS_CORE+86             
557c c7 55			dw .OPEN            
557e 05				db 4 + 1 
557f .. 00			db "ERA",0              
5583				endm 
# End of macro CWHEAD
5583			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5583			; | | > [!NOTE] 
5583			; | | > Compatible with PicoSPINet  
5583					FORTH_DSP_VALUEHL 
5583 cd 4b 22			call macro_dsp_valuehl 
5586				endm 
# End of macro FORTH_DSP_VALUEHL
5586			;		push hl 	; save file id 
5586			 
5586					if DEBUG_FORTH_WORDS_KEY 
5586						DMARK "ERA" 
5586 f5				push af  
5587 3a 9b 55			ld a, (.dmark)  
558a 32 a0 fd			ld (debug_mark),a  
558d 3a 9c 55			ld a, (.dmark+1)  
5590 32 a1 fd			ld (debug_mark+1),a  
5593 3a 9d 55			ld a, (.dmark+2)  
5596 32 a2 fd			ld (debug_mark+2),a  
5599 18 03			jr .pastdmark  
559b ..			.dmark: db "ERA"  
559e f1			.pastdmark: pop af  
559f			endm  
# End of macro DMARK
559f						CALLMONITOR 
559f cd aa fd			call debug_vector  
55a2				endm  
# End of macro CALLMONITOR
55a2					endif 
55a2				if DEBUG_STORESE 
55a2					DMARK "ER1" 
55a2 f5				push af  
55a3 3a b7 55			ld a, (.dmark)  
55a6 32 a0 fd			ld (debug_mark),a  
55a9 3a b8 55			ld a, (.dmark+1)  
55ac 32 a1 fd			ld (debug_mark+1),a  
55af 3a b9 55			ld a, (.dmark+2)  
55b2 32 a2 fd			ld (debug_mark+2),a  
55b5 18 03			jr .pastdmark  
55b7 ..			.dmark: db "ER1"  
55ba f1			.pastdmark: pop af  
55bb			endm  
# End of macro DMARK
55bb					CALLMONITOR 
55bb cd aa fd			call debug_vector  
55be				endm  
# End of macro CALLMONITOR
55be				endif 
55be					FORTH_DSP_POP 
55be cd 03 23			call macro_forth_dsp_pop 
55c1				endm 
# End of macro FORTH_DSP_POP
55c1			 
55c1			;		pop hl 
55c1			 
55c1 cd b6 06				call storage_erase 
55c4				       NEXTW 
55c4 c3 37 24			jp macro_next 
55c7				endm 
# End of macro NEXTW
55c7			 
55c7			.OPEN: 
55c7				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
55c7 6b				db WORD_SYS_CORE+87             
55c8 5b 56			dw .READ            
55ca 05				db 4 + 1 
55cb .. 00			db "OPEN",0              
55d0				endm 
# End of macro CWHEAD
55d0			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
55d0			; | | e.g. 
55d0			; | | $01 OPEN $01 DO $01 READ . LOOP 
55d0			; | | 
55d0			; | | Will return with 255 blocks if the file does not exist 
55d0			; | | > [!NOTE] 
55d0			; | | > Compatible with PicoSPINet  
55d0			 
55d0					if DEBUG_FORTH_WORDS_KEY 
55d0						DMARK "OPN" 
55d0 f5				push af  
55d1 3a e5 55			ld a, (.dmark)  
55d4 32 a0 fd			ld (debug_mark),a  
55d7 3a e6 55			ld a, (.dmark+1)  
55da 32 a1 fd			ld (debug_mark+1),a  
55dd 3a e7 55			ld a, (.dmark+2)  
55e0 32 a2 fd			ld (debug_mark+2),a  
55e3 18 03			jr .pastdmark  
55e5 ..			.dmark: db "OPN"  
55e8 f1			.pastdmark: pop af  
55e9			endm  
# End of macro DMARK
55e9						CALLMONITOR 
55e9 cd aa fd			call debug_vector  
55ec				endm  
# End of macro CALLMONITOR
55ec					endif 
55ec					; TODO handle multiple file opens 
55ec			 
55ec 3e 01			       	ld a, 1 
55ee 32 9f f9				ld (store_openext), a 
55f1			 
55f1					; get max extents for this file 
55f1				 
55f1								 
55f1					FORTH_DSP_VALUEHL 
55f1 cd 4b 22			call macro_dsp_valuehl 
55f4				endm 
# End of macro FORTH_DSP_VALUEHL
55f4			 
55f4 65					ld h, l 
55f5 2e 00				ld l, 0 
55f7			 
55f7					; store file id 
55f7			 
55f7 7c					ld a, h 
55f8 32 9c f9				ld (store_filecache), a 
55fb			 
55fb				if DEBUG_STORESE 
55fb					DMARK "OPN" 
55fb f5				push af  
55fc 3a 10 56			ld a, (.dmark)  
55ff 32 a0 fd			ld (debug_mark),a  
5602 3a 11 56			ld a, (.dmark+1)  
5605 32 a1 fd			ld (debug_mark+1),a  
5608 3a 12 56			ld a, (.dmark+2)  
560b 32 a2 fd			ld (debug_mark+2),a  
560e 18 03			jr .pastdmark  
5610 ..			.dmark: db "OPN"  
5613 f1			.pastdmark: pop af  
5614			endm  
# End of macro DMARK
5614					CALLMONITOR 
5614 cd aa fd			call debug_vector  
5617				endm  
# End of macro CALLMONITOR
5617				endif 
5617			;		push hl 
5617					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5617 cd 03 23			call macro_forth_dsp_pop 
561a				endm 
# End of macro FORTH_DSP_POP
561a			;		pop hl 
561a						 
561a 11 af f9				ld de, store_page      ; get block zero of file 
561d cd cd 09				call storage_read 
5620 cd 07 10			call ishlzero 
5623 20 04			jr nz, .opfound 
5625			 
5625				; file does not exist so indicate with 255 extents in use 
5625			 
5625 3e ff			ld a, 255 
5627 18 29			jr .skipopeneof 
5629			 
5629			 
5629			.opfound: 
5629			 
5629			 
5629 3a b1 f9				ld a, (store_page+2)    ; max extents for this file 
562c 32 9e f9				ld  (store_openmaxext), a   ; get our limit and push 
562f					 
562f				if DEBUG_STORESE 
562f					DMARK "OPx" 
562f f5				push af  
5630 3a 44 56			ld a, (.dmark)  
5633 32 a0 fd			ld (debug_mark),a  
5636 3a 45 56			ld a, (.dmark+1)  
5639 32 a1 fd			ld (debug_mark+1),a  
563c 3a 46 56			ld a, (.dmark+2)  
563f 32 a2 fd			ld (debug_mark+2),a  
5642 18 03			jr .pastdmark  
5644 ..			.dmark: db "OPx"  
5647 f1			.pastdmark: pop af  
5648			endm  
# End of macro DMARK
5648					CALLMONITOR 
5648 cd aa fd			call debug_vector  
564b				endm  
# End of macro CALLMONITOR
564b				endif 
564b fe 00				cp 0 
564d 20 03				jr nz, .skipopeneof 
564f					; have opened an empty file 
564f					 
564f 32 9f f9				ld (store_openext), a 
5652			 
5652			.skipopeneof: 
5652			 
5652 6f					ld l, a 
5653 26 00				ld h, 0 
5655 cd 46 20				call forth_push_numhl 
5658			 
5658			 
5658				       NEXTW 
5658 c3 37 24			jp macro_next 
565b				endm 
# End of macro NEXTW
565b			.READ: 
565b				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
565b 6c				db WORD_SYS_CORE+88             
565c 85 57			dw .EOF            
565e 05				db 4 + 1 
565f .. 00			db "READ",0              
5664				endm 
# End of macro CWHEAD
5664			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5664			; | | e.g. 
5664			; | | $01 OPEN $01 DO READ . LOOP 
5664			; | | 
5664			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5664			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5664			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5664			; | | two bytes contain the file id and extent. 
5664			; | |  
5664			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5664			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5664			; | | > [!NOTE] 
5664			; | | > Compatible with PicoSPINet  
5664			 
5664					if DEBUG_FORTH_WORDS_KEY 
5664						DMARK "REA" 
5664 f5				push af  
5665 3a 79 56			ld a, (.dmark)  
5668 32 a0 fd			ld (debug_mark),a  
566b 3a 7a 56			ld a, (.dmark+1)  
566e 32 a1 fd			ld (debug_mark+1),a  
5671 3a 7b 56			ld a, (.dmark+2)  
5674 32 a2 fd			ld (debug_mark+2),a  
5677 18 03			jr .pastdmark  
5679 ..			.dmark: db "REA"  
567c f1			.pastdmark: pop af  
567d			endm  
# End of macro DMARK
567d						CALLMONITOR 
567d cd aa fd			call debug_vector  
5680				endm  
# End of macro CALLMONITOR
5680					endif 
5680					; store_openext use it. If zero it is EOF 
5680			 
5680					; read block from current stream id 
5680					; if the block does not contain zero term keep reading blocks until zero found 
5680					; push the block to stack 
5680					; save the block id to stream 
5680			 
5680			 
5680 cd b2 57				call .testeof 
5683 3e 01				ld a, 1 
5685 bd					cp l 
5686 ca 61 57				jp z, .ateof 
5689			 
5689			 
5689			;		FORTH_DSP_VALUEHL 
5689			 
5689			;		push hl 
5689			 
5689			;	if DEBUG_STORESE 
5689			;		DMARK "REA" 
5689			;		CALLMONITOR 
5689			;	endif 
5689			;		FORTH_DSP_POP 
5689			 
5689			;		pop hl 
5689				 
5689 3a 9c f9				ld a, (store_filecache) 
568c 67					ld h,a 
568d			 
568d 3a 9f f9				ld a, (store_openext) 
5690 6f					ld l, a 
5691					 
5691 fe 00				cp 0 
5693 ca 61 57				jp z, .ateof     ; dont read past eof 
5696			 
5696 cd b0 0c				call storage_clear_page 
5699			 
5699 11 af f9				ld de, store_page 
569c				if DEBUG_STORESE 
569c					DMARK "RE1" 
569c f5				push af  
569d 3a b1 56			ld a, (.dmark)  
56a0 32 a0 fd			ld (debug_mark),a  
56a3 3a b2 56			ld a, (.dmark+1)  
56a6 32 a1 fd			ld (debug_mark+1),a  
56a9 3a b3 56			ld a, (.dmark+2)  
56ac 32 a2 fd			ld (debug_mark+2),a  
56af 18 03			jr .pastdmark  
56b1 ..			.dmark: db "RE1"  
56b4 f1			.pastdmark: pop af  
56b5			endm  
# End of macro DMARK
56b5					CALLMONITOR 
56b5 cd aa fd			call debug_vector  
56b8				endm  
# End of macro CALLMONITOR
56b8				endif 
56b8 cd cd 09				call storage_read 
56bb			 
56bb				if DEBUG_STORESE 
56bb					DMARK "RE2" 
56bb f5				push af  
56bc 3a d0 56			ld a, (.dmark)  
56bf 32 a0 fd			ld (debug_mark),a  
56c2 3a d1 56			ld a, (.dmark+1)  
56c5 32 a1 fd			ld (debug_mark+1),a  
56c8 3a d2 56			ld a, (.dmark+2)  
56cb 32 a2 fd			ld (debug_mark+2),a  
56ce 18 03			jr .pastdmark  
56d0 ..			.dmark: db "RE2"  
56d3 f1			.pastdmark: pop af  
56d4			endm  
# End of macro DMARK
56d4					CALLMONITOR 
56d4 cd aa fd			call debug_vector  
56d7				endm  
# End of macro CALLMONITOR
56d7				endif 
56d7 cd 07 10			call ishlzero 
56da			;	ld a, l 
56da			;	add h 
56da			;	cp 0 
56da ca 61 57			jp z, .readeof 
56dd			 
56dd				; not eof so hl should point to data to push to stack 
56dd			 
56dd				if DEBUG_STORESE 
56dd					DMARK "RE3" 
56dd f5				push af  
56de 3a f2 56			ld a, (.dmark)  
56e1 32 a0 fd			ld (debug_mark),a  
56e4 3a f3 56			ld a, (.dmark+1)  
56e7 32 a1 fd			ld (debug_mark+1),a  
56ea 3a f4 56			ld a, (.dmark+2)  
56ed 32 a2 fd			ld (debug_mark+2),a  
56f0 18 03			jr .pastdmark  
56f2 ..			.dmark: db "RE3"  
56f5 f1			.pastdmark: pop af  
56f6			endm  
# End of macro DMARK
56f6					CALLMONITOR 
56f6 cd aa fd			call debug_vector  
56f9				endm  
# End of macro CALLMONITOR
56f9				endif 
56f9 cd b4 20			call forth_push_str 
56fc			 
56fc				if DEBUG_STORESE 
56fc					DMARK "RE4" 
56fc f5				push af  
56fd 3a 11 57			ld a, (.dmark)  
5700 32 a0 fd			ld (debug_mark),a  
5703 3a 12 57			ld a, (.dmark+1)  
5706 32 a1 fd			ld (debug_mark+1),a  
5709 3a 13 57			ld a, (.dmark+2)  
570c 32 a2 fd			ld (debug_mark+2),a  
570f 18 03			jr .pastdmark  
5711 ..			.dmark: db "RE4"  
5714 f1			.pastdmark: pop af  
5715			endm  
# End of macro DMARK
5715					CALLMONITOR 
5715 cd aa fd			call debug_vector  
5718				endm  
# End of macro CALLMONITOR
5718				endif 
5718				; get next block  or mark as eof 
5718			 
5718 3a 9e f9			ld a, (store_openmaxext)   ; get our limit 
571b 4f				ld c, a	 
571c 3a 9f f9			ld a, (store_openext) 
571f			 
571f				if DEBUG_STORESE 
571f					DMARK "RE5" 
571f f5				push af  
5720 3a 34 57			ld a, (.dmark)  
5723 32 a0 fd			ld (debug_mark),a  
5726 3a 35 57			ld a, (.dmark+1)  
5729 32 a1 fd			ld (debug_mark+1),a  
572c 3a 36 57			ld a, (.dmark+2)  
572f 32 a2 fd			ld (debug_mark+2),a  
5732 18 03			jr .pastdmark  
5734 ..			.dmark: db "RE5"  
5737 f1			.pastdmark: pop af  
5738			endm  
# End of macro DMARK
5738					CALLMONITOR 
5738 cd aa fd			call debug_vector  
573b				endm  
# End of macro CALLMONITOR
573b				endif 
573b b9				cp c 
573c 28 23			jr z, .readeof     ; at last extent 
573e			 
573e 3c					inc a 
573f 32 9f f9				ld (store_openext), a 
5742			 
5742				if DEBUG_STORESE 
5742					DMARK "RE6" 
5742 f5				push af  
5743 3a 57 57			ld a, (.dmark)  
5746 32 a0 fd			ld (debug_mark),a  
5749 3a 58 57			ld a, (.dmark+1)  
574c 32 a1 fd			ld (debug_mark+1),a  
574f 3a 59 57			ld a, (.dmark+2)  
5752 32 a2 fd			ld (debug_mark+2),a  
5755 18 03			jr .pastdmark  
5757 ..			.dmark: db "RE6"  
575a f1			.pastdmark: pop af  
575b			endm  
# End of macro DMARK
575b					CALLMONITOR 
575b cd aa fd			call debug_vector  
575e				endm  
# End of macro CALLMONITOR
575e				endif 
575e			 
575e			 
575e				       NEXTW 
575e c3 37 24			jp macro_next 
5761				endm 
# End of macro NEXTW
5761			.ateof: 
5761				;	ld hl, .showeof 
5761				;	call forth_push_str 
5761 3e 00		.readeof:	ld a, 0 
5763 32 9f f9				ld (store_openext), a 
5766			 
5766					 
5766				if DEBUG_STORESE 
5766					DMARK "REF" 
5766 f5				push af  
5767 3a 7b 57			ld a, (.dmark)  
576a 32 a0 fd			ld (debug_mark),a  
576d 3a 7c 57			ld a, (.dmark+1)  
5770 32 a1 fd			ld (debug_mark+1),a  
5773 3a 7d 57			ld a, (.dmark+2)  
5776 32 a2 fd			ld (debug_mark+2),a  
5779 18 03			jr .pastdmark  
577b ..			.dmark: db "REF"  
577e f1			.pastdmark: pop af  
577f			endm  
# End of macro DMARK
577f					CALLMONITOR 
577f cd aa fd			call debug_vector  
5782				endm  
# End of macro CALLMONITOR
5782				endif 
5782				       NEXTW 
5782 c3 37 24			jp macro_next 
5785				endm 
# End of macro NEXTW
5785			 
5785			;.showeof:   db "eof", 0 
5785			 
5785			 
5785			.EOF: 
5785				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5785 6d				db WORD_SYS_CORE+89             
5786 c7 57			dw .FORMAT            
5788 04				db 3 + 1 
5789 .. 00			db "EOF",0              
578d				endm 
# End of macro CWHEAD
578d			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
578d			; | | e.g. 
578d			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
578d			; | | > [!NOTE] 
578d			; | | > Compatible with PicoSPINet  
578d					; TODO if current block id for stream is zero then push true else false 
578d			 
578d					if DEBUG_FORTH_WORDS_KEY 
578d						DMARK "EOF" 
578d f5				push af  
578e 3a a2 57			ld a, (.dmark)  
5791 32 a0 fd			ld (debug_mark),a  
5794 3a a3 57			ld a, (.dmark+1)  
5797 32 a1 fd			ld (debug_mark+1),a  
579a 3a a4 57			ld a, (.dmark+2)  
579d 32 a2 fd			ld (debug_mark+2),a  
57a0 18 03			jr .pastdmark  
57a2 ..			.dmark: db "EOF"  
57a5 f1			.pastdmark: pop af  
57a6			endm  
# End of macro DMARK
57a6						CALLMONITOR 
57a6 cd aa fd			call debug_vector  
57a9				endm  
# End of macro CALLMONITOR
57a9					endif 
57a9			 
57a9					; TODO handlue multiple file streams 
57a9			 
57a9			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
57a9 cd b2 57				call .testeof 
57ac cd 46 20				call forth_push_numhl 
57af			 
57af			 
57af				       NEXTW 
57af c3 37 24			jp macro_next 
57b2				endm 
# End of macro NEXTW
57b2			 
57b2			.testeof: 
57b2 2e 01				ld l, 1 
57b4 3a 9e f9				ld a, (store_openmaxext) 
57b7 fe 00				cp 0 
57b9 28 09				jr  z, .eofdone   ; empty file 
57bb 3a 9f f9				ld a, (store_openext) 
57be fe 00				cp 0 
57c0 28 02				jr  z, .eofdone 
57c2 2e 00				ld l, 0 
57c4 26 00		.eofdone:	ld h, 0 
57c6 c9					ret 
57c7			 
57c7			 
57c7			 
57c7			 
57c7			.FORMAT: 
57c7				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
57c7 6d				db WORD_SYS_CORE+89             
57c8 18 58			dw .LABEL            
57ca 07				db 6 + 1 
57cb .. 00			db "FORMAT",0              
57d2				endm 
# End of macro CWHEAD
57d2			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
57d2			; | | > [!NOTE] 
57d2			; | | > Compatible with PicoSPINet  
57d2					; TODO if current block id for stream is zero then push true else false 
57d2				 
57d2				if DEBUG_STORESE 
57d2					DMARK "FOR" 
57d2 f5				push af  
57d3 3a e7 57			ld a, (.dmark)  
57d6 32 a0 fd			ld (debug_mark),a  
57d9 3a e8 57			ld a, (.dmark+1)  
57dc 32 a1 fd			ld (debug_mark+1),a  
57df 3a e9 57			ld a, (.dmark+2)  
57e2 32 a2 fd			ld (debug_mark+2),a  
57e5 18 03			jr .pastdmark  
57e7 ..			.dmark: db "FOR"  
57ea f1			.pastdmark: pop af  
57eb			endm  
# End of macro DMARK
57eb					CALLMONITOR 
57eb cd aa fd			call debug_vector  
57ee				endm  
# End of macro CALLMONITOR
57ee				endif 
57ee					; Wipes the bank check flags to cause a reformat on next block 0 read 
57ee			 
57ee 21 01 00				ld hl, 1 
57f1 3e 00				ld a, 0 
57f3 cd 79 02				call se_writebyte 
57f6			 
57f6				if DEBUG_STORESE 
57f6					DMARK "FO0" 
57f6 f5				push af  
57f7 3a 0b 58			ld a, (.dmark)  
57fa 32 a0 fd			ld (debug_mark),a  
57fd 3a 0c 58			ld a, (.dmark+1)  
5800 32 a1 fd			ld (debug_mark+1),a  
5803 3a 0d 58			ld a, (.dmark+2)  
5806 32 a2 fd			ld (debug_mark+2),a  
5809 18 03			jr .pastdmark  
580b ..			.dmark: db "FO0"  
580e f1			.pastdmark: pop af  
580f			endm  
# End of macro DMARK
580f					CALLMONITOR 
580f cd aa fd			call debug_vector  
5812				endm  
# End of macro CALLMONITOR
5812				endif 
5812					; force bank init 
5812			 
5812 cd 25 05				call storage_get_block_0 
5815					 
5815				       NEXTW 
5815 c3 37 24			jp macro_next 
5818				endm 
# End of macro NEXTW
5818			.LABEL: 
5818				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5818 6d				db WORD_SYS_CORE+89             
5819 66 58			dw .STOREPAGE            
581b 06				db 5 + 1 
581c .. 00			db "LABEL",0              
5822				endm 
# End of macro CWHEAD
5822			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5822			; | | > [!NOTE] 
5822			; | | > Compatible with PicoSPINet  
5822					; TODO test to see if bank is selected 
5822				 
5822					if DEBUG_FORTH_WORDS_KEY 
5822						DMARK "LBL" 
5822 f5				push af  
5823 3a 37 58			ld a, (.dmark)  
5826 32 a0 fd			ld (debug_mark),a  
5829 3a 38 58			ld a, (.dmark+1)  
582c 32 a1 fd			ld (debug_mark+1),a  
582f 3a 39 58			ld a, (.dmark+2)  
5832 32 a2 fd			ld (debug_mark+2),a  
5835 18 03			jr .pastdmark  
5837 ..			.dmark: db "LBL"  
583a f1			.pastdmark: pop af  
583b			endm  
# End of macro DMARK
583b						CALLMONITOR 
583b cd aa fd			call debug_vector  
583e				endm  
# End of macro CALLMONITOR
583e					endif 
583e			;	if DEBUG_STORESE 
583e			;		DMARK "LBL" 
583e			;		CALLMONITOR 
583e			;	endif 
583e					FORTH_DSP_VALUEHL 
583e cd 4b 22			call macro_dsp_valuehl 
5841				endm 
# End of macro FORTH_DSP_VALUEHL
5841					;v5FORTH_DSP_VALUE 
5841					 
5841			;		push hl 
5841					FORTH_DSP_POP 
5841 cd 03 23			call macro_forth_dsp_pop 
5844				endm 
# End of macro FORTH_DSP_POP
5844			;		pop hl 
5844			 
5844			;v5		inc hl   ; move past the type marker 
5844			 
5844				if DEBUG_STORESE 
5844					DMARK "LBl" 
5844 f5				push af  
5845 3a 59 58			ld a, (.dmark)  
5848 32 a0 fd			ld (debug_mark),a  
584b 3a 5a 58			ld a, (.dmark+1)  
584e 32 a1 fd			ld (debug_mark+1),a  
5851 3a 5b 58			ld a, (.dmark+2)  
5854 32 a2 fd			ld (debug_mark+2),a  
5857 18 03			jr .pastdmark  
5859 ..			.dmark: db "LBl"  
585c f1			.pastdmark: pop af  
585d			endm  
# End of macro DMARK
585d					CALLMONITOR 
585d cd aa fd			call debug_vector  
5860				endm  
# End of macro CALLMONITOR
5860				endif 
5860 cd 49 06				call storage_label 
5863			 
5863				       NEXTW 
5863 c3 37 24			jp macro_next 
5866				endm 
# End of macro NEXTW
5866			.STOREPAGE: 
5866				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5866 6d				db WORD_SYS_CORE+89             
5867 99 58			dw .LABELS            
5869 0a				db 9 + 1 
586a .. 00			db "STOREPAGE",0              
5874				endm 
# End of macro CWHEAD
5874			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5874			; | | > [!NOTE] 
5874			; | | > Compatible with PicoSPINet  
5874					; TODO test to see if bank is selected 
5874				 
5874					if DEBUG_FORTH_WORDS_KEY 
5874						DMARK "STP" 
5874 f5				push af  
5875 3a 89 58			ld a, (.dmark)  
5878 32 a0 fd			ld (debug_mark),a  
587b 3a 8a 58			ld a, (.dmark+1)  
587e 32 a1 fd			ld (debug_mark+1),a  
5881 3a 8b 58			ld a, (.dmark+2)  
5884 32 a2 fd			ld (debug_mark+2),a  
5887 18 03			jr .pastdmark  
5889 ..			.dmark: db "STP"  
588c f1			.pastdmark: pop af  
588d			endm  
# End of macro DMARK
588d						CALLMONITOR 
588d cd aa fd			call debug_vector  
5890				endm  
# End of macro CALLMONITOR
5890					endif 
5890			;	if DEBUG_STORESE 
5890			;		DMARK "STP" 
5890			;		CALLMONITOR 
5890			;	endif 
5890			 
5890 21 af f9			ld hl, store_page 
5893 cd 46 20			call forth_push_numhl 
5896			 
5896			 
5896				       NEXTW 
5896 c3 37 24			jp macro_next 
5899				endm 
# End of macro NEXTW
5899			.LABELS: 
5899				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5899 6d				db WORD_SYS_CORE+89             
589a 23 59			dw .SCONST1            
589c 07				db 6 + 1 
589d .. 00			db "LABELS",0              
58a4				endm 
# End of macro CWHEAD
58a4			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
58a4			; | | > [!CAUTION] 
58a4			; | | > *NOT* Compatible with PicoSPINet  
58a4					;  
58a4			 
58a4					; save the current device selected to restore afterwards 
58a4				 
58a4 3a 95 f9				ld a, (spi_device) 
58a7 f5					push af 
58a8			 
58a8			 
58a8					; run through each of the banks 
58a8			 
58a8 21 01 00				ld hl, 1 
58ab cd 46 20				call forth_push_numhl 
58ae 3e ff				ld a, SPI_CE_HIGH 
58b0 cb 87				res SPI_CE0, a 
58b2 32 95 f9				ld (spi_device), a 
58b5 cd 25 05				call storage_get_block_0 
58b8 21 b2 f9				ld hl, store_page+3 
58bb cd b4 20				call forth_push_str 
58be			 
58be					 
58be 21 02 00				ld hl, 2 
58c1 cd 46 20				call forth_push_numhl 
58c4 3e ff				ld a, SPI_CE_HIGH 
58c6 cb 8f				res SPI_CE1, a 
58c8 32 95 f9				ld (spi_device), a 
58cb cd 25 05				call storage_get_block_0 
58ce 21 b2 f9				ld hl, store_page+3 
58d1 cd b4 20				call forth_push_str 
58d4			 
58d4					 
58d4 21 03 00				ld hl, 3 
58d7 cd 46 20				call forth_push_numhl 
58da 3e ff				ld a, SPI_CE_HIGH 
58dc cb 97				res SPI_CE2, a 
58de 32 95 f9				ld (spi_device), a 
58e1 cd 25 05				call storage_get_block_0 
58e4 21 b2 f9				ld hl, store_page+3 
58e7 cd b4 20				call forth_push_str 
58ea			 
58ea			 
58ea 21 04 00				ld hl, 4 
58ed cd 46 20				call forth_push_numhl 
58f0 3e ff				ld a, SPI_CE_HIGH 
58f2 cb 9f				res SPI_CE3, a 
58f4 32 95 f9				ld (spi_device), a 
58f7 cd 25 05				call storage_get_block_0 
58fa 21 b2 f9				ld hl, store_page+3 
58fd cd b4 20				call forth_push_str 
5900			 
5900					 
5900			 
5900 21 05 00				ld hl, 5 
5903 cd 46 20				call forth_push_numhl 
5906 3e ff				ld a, SPI_CE_HIGH 
5908 cb a7				res SPI_CE4, a 
590a 32 95 f9				ld (spi_device), a 
590d cd 25 05				call storage_get_block_0 
5910 21 b2 f9				ld hl, store_page+3 
5913 cd b4 20				call forth_push_str 
5916			 
5916					 
5916					; push fixed count of storage devices (on board) for now 
5916			 
5916 21 05 00				ld hl, 5 
5919 cd 46 20				call forth_push_numhl 
591c			 
591c					; restore selected device  
591c				 
591c f1					pop af 
591d 32 95 f9				ld (spi_device), a 
5920			 
5920				       NEXTW 
5920 c3 37 24			jp macro_next 
5923				endm 
# End of macro NEXTW
5923			 
5923			.SCONST1: 
5923				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5923 6d				db WORD_SYS_CORE+89             
5924 3a 59			dw .SCONST2            
5926 07				db 6 + 1 
5927 .. 00			db "FILEID",0              
592e				endm 
# End of macro CWHEAD
592e			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
592e			; | | > [!NOTE] 
592e			; | | > Compatible with PicoSPINet  
592e 3a 9c f9				ld a, (store_filecache) 
5931 26 00				ld h, 0 
5933 6f					ld l, a 
5934 cd 46 20				call forth_push_numhl 
5937					NEXTW 
5937 c3 37 24			jp macro_next 
593a				endm 
# End of macro NEXTW
593a			.SCONST2: 
593a				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
593a 6d				db WORD_SYS_CORE+89             
593b 52 59			dw .SCONST3            
593d 08				db 7 + 1 
593e .. 00			db "FILEEXT",0              
5946				endm 
# End of macro CWHEAD
5946			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5946			; | | > [!NOTE] 
5946			; | | > Compatible with PicoSPINet  
5946 3a 9f f9				ld a, (store_openext) 
5949 26 00				ld h, 0 
594b 6f					ld l, a 
594c cd 46 20				call forth_push_numhl 
594f					NEXTW 
594f c3 37 24			jp macro_next 
5952				endm 
# End of macro NEXTW
5952			.SCONST3: 
5952				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5952 6d				db WORD_SYS_CORE+89             
5953 6a 59			dw .SCONST4            
5955 08				db 7 + 1 
5956 .. 00			db "FILEMAX",0              
595e				endm 
# End of macro CWHEAD
595e			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
595e			; | | > [!NOTE] 
595e			; | | > Compatible with PicoSPINet  
595e 3a 9e f9				ld a, (store_openmaxext) 
5961 26 00				ld h, 0 
5963 6f					ld l, a 
5964 cd 46 20				call forth_push_numhl 
5967					NEXTW 
5967 c3 37 24			jp macro_next 
596a				endm 
# End of macro NEXTW
596a			.SCONST4: 
596a				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
596a 6d				db WORD_SYS_CORE+89             
596b 80 59			dw .SCONST5            
596d 09				db 8 + 1 
596e .. 00			db "FILEADDR",0              
5977				endm 
# End of macro CWHEAD
5977			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
5977			; | | > [!NOTE] 
5977			; | | > Compatible with PicoSPINet  
5977 2a a0 f9				ld hl, (store_openaddr) 
597a cd 46 20				call forth_push_numhl 
597d					NEXTW 
597d c3 37 24			jp macro_next 
5980				endm 
# End of macro NEXTW
5980			.SCONST5: 
5980				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5980 6d				db WORD_SYS_CORE+89             
5981 a1 59			dw .SCONST6            
5983 09				db 8 + 1 
5984 .. 00			db "FILEPAGE",0              
598d				endm 
# End of macro CWHEAD
598d			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
598d			; | | > [!NOTE] 
598d			; | | > Compatible with PicoSPINet  
598d 2a a0 f9				ld hl, (store_openaddr) 
5990 e5					push hl 
5991 c1					pop bc 
5992 16 00				ld d, 0 
5994 1e 40				ld e, STORE_BLOCK_PHY 
5996 cd 3b 0f				call Div16 
5999 c5					push bc 
599a e1					pop hl 
599b cd 46 20				call forth_push_numhl 
599e					NEXTW 
599e c3 37 24			jp macro_next 
59a1				endm 
# End of macro NEXTW
59a1			.SCONST6: 
59a1				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
59a1 6d				db WORD_SYS_CORE+89             
59a2 ba 59			dw .ENDSTORAGE            
59a4 09				db 8 + 1 
59a5 .. 00			db "READCONT",0              
59ae				endm 
# End of macro CWHEAD
59ae			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
59ae			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
59ae			; | | a further read should, if applicable, be CONCAT to the previous read. 
59ae			; | | > [!NOTE] 
59ae			; | | > Compatible with PicoSPINet  
59ae 3a a2 f9				ld a, (store_readcont) 
59b1 26 00				ld h, 0 
59b3 6f					ld l, a 
59b4 cd 46 20				call forth_push_numhl 
59b7					NEXTW 
59b7 c3 37 24			jp macro_next 
59ba				endm 
# End of macro NEXTW
59ba			.ENDSTORAGE: 
59ba			; eof 
# End of file forth_words_storage.asm
59ba			endif 
59ba				include "forth_words_device.asm" 
59ba			; Device related words 
59ba			 
59ba			; | ## Device Words 
59ba			 
59ba			;if SOUND_ENABLE 
59ba			;.NOTE: 
59ba			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
59ba			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
59ba			;		if DEBUG_FORTH_WORDS_KEY 
59ba			;			DMARK "NTE" 
59ba			;			CALLMONITOR 
59ba			;		endif 
59ba			; 
59ba			;	 
59ba			; 
59ba			;		NEXTW 
59ba			;.AFTERSOUND: 
59ba			;endif 
59ba			 
59ba			 
59ba			USE_GPIO: equ 0 
59ba			 
59ba			if USE_GPIO 
59ba			.GP1: 
59ba				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
59ba			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
59ba					NEXTW 
59ba			.GP2: 
59ba				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
59ba			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
59ba			 
59ba					NEXTW 
59ba			 
59ba			.GP3: 
59ba				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
59ba			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
59ba			 
59ba					NEXTW 
59ba			 
59ba			.GP4: 
59ba				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
59ba			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
59ba			 
59ba					NEXTW 
59ba			.SIN: 
59ba			 
59ba			 
59ba			endif 
59ba			 
59ba			 
59ba				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
59ba 33				db WORD_SYS_CORE+31             
59bb ef 59			dw .SOUT            
59bd 03				db 2 + 1 
59be .. 00			db "IN",0              
59c1				endm 
# End of macro CWHEAD
59c1			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
59c1					if DEBUG_FORTH_WORDS_KEY 
59c1						DMARK "IN." 
59c1 f5				push af  
59c2 3a d6 59			ld a, (.dmark)  
59c5 32 a0 fd			ld (debug_mark),a  
59c8 3a d7 59			ld a, (.dmark+1)  
59cb 32 a1 fd			ld (debug_mark+1),a  
59ce 3a d8 59			ld a, (.dmark+2)  
59d1 32 a2 fd			ld (debug_mark+2),a  
59d4 18 03			jr .pastdmark  
59d6 ..			.dmark: db "IN."  
59d9 f1			.pastdmark: pop af  
59da			endm  
# End of macro DMARK
59da						CALLMONITOR 
59da cd aa fd			call debug_vector  
59dd				endm  
# End of macro CALLMONITOR
59dd					endif 
59dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59dd cd 4b 22			call macro_dsp_valuehl 
59e0				endm 
# End of macro FORTH_DSP_VALUEHL
59e0			 
59e0 e5					push hl 
59e1			 
59e1					; destroy value TOS 
59e1			 
59e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59e1 cd 03 23			call macro_forth_dsp_pop 
59e4				endm 
# End of macro FORTH_DSP_POP
59e4			 
59e4					; one value on hl get other one back 
59e4			 
59e4 c1					pop bc 
59e5			 
59e5					; do the sub 
59e5			;		ex de, hl 
59e5			 
59e5 ed 68				in l,(c) 
59e7			 
59e7					; save it 
59e7			 
59e7 26 00				ld h,0 
59e9			 
59e9					; TODO push value back onto stack for another op etc 
59e9			 
59e9 cd 46 20				call forth_push_numhl 
59ec					NEXTW 
59ec c3 37 24			jp macro_next 
59ef				endm 
# End of macro NEXTW
59ef			.SOUT: 
59ef				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
59ef 34				db WORD_SYS_CORE+32             
59f0 42 5a			dw .SPIO            
59f2 04				db 3 + 1 
59f3 .. 00			db "OUT",0              
59f7				endm 
# End of macro CWHEAD
59f7			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
59f7					if DEBUG_FORTH_WORDS_KEY 
59f7						DMARK "OUT" 
59f7 f5				push af  
59f8 3a 0c 5a			ld a, (.dmark)  
59fb 32 a0 fd			ld (debug_mark),a  
59fe 3a 0d 5a			ld a, (.dmark+1)  
5a01 32 a1 fd			ld (debug_mark+1),a  
5a04 3a 0e 5a			ld a, (.dmark+2)  
5a07 32 a2 fd			ld (debug_mark+2),a  
5a0a 18 03			jr .pastdmark  
5a0c ..			.dmark: db "OUT"  
5a0f f1			.pastdmark: pop af  
5a10			endm  
# End of macro DMARK
5a10						CALLMONITOR 
5a10 cd aa fd			call debug_vector  
5a13				endm  
# End of macro CALLMONITOR
5a13					endif 
5a13			 
5a13					; get port 
5a13			 
5a13					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a13 cd 4b 22			call macro_dsp_valuehl 
5a16				endm 
# End of macro FORTH_DSP_VALUEHL
5a16			 
5a16 e5					push hl 
5a17			 
5a17					; destroy value TOS 
5a17			 
5a17					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a17 cd 03 23			call macro_forth_dsp_pop 
5a1a				endm 
# End of macro FORTH_DSP_POP
5a1a			 
5a1a					; get byte to send 
5a1a			 
5a1a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a1a cd 4b 22			call macro_dsp_valuehl 
5a1d				endm 
# End of macro FORTH_DSP_VALUEHL
5a1d			 
5a1d			;		push hl 
5a1d			 
5a1d					; destroy value TOS 
5a1d			 
5a1d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a1d cd 03 23			call macro_forth_dsp_pop 
5a20				endm 
# End of macro FORTH_DSP_POP
5a20			 
5a20					; one value on hl get other one back 
5a20			 
5a20			;		pop hl 
5a20			 
5a20 c1					pop bc 
5a21			 
5a21					if DEBUG_FORTH_WORDS 
5a21						DMARK "OUT" 
5a21 f5				push af  
5a22 3a 36 5a			ld a, (.dmark)  
5a25 32 a0 fd			ld (debug_mark),a  
5a28 3a 37 5a			ld a, (.dmark+1)  
5a2b 32 a1 fd			ld (debug_mark+1),a  
5a2e 3a 38 5a			ld a, (.dmark+2)  
5a31 32 a2 fd			ld (debug_mark+2),a  
5a34 18 03			jr .pastdmark  
5a36 ..			.dmark: db "OUT"  
5a39 f1			.pastdmark: pop af  
5a3a			endm  
# End of macro DMARK
5a3a						CALLMONITOR 
5a3a cd aa fd			call debug_vector  
5a3d				endm  
# End of macro CALLMONITOR
5a3d					endif 
5a3d			 
5a3d ed 69				out (c), l 
5a3f			 
5a3f					NEXTW 
5a3f c3 37 24			jp macro_next 
5a42				endm 
# End of macro NEXTW
5a42			 
5a42			 
5a42			.SPIO: 
5a42			 
5a42			if STORAGE_SE 
5a42				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5a42 51				db WORD_SYS_CORE+61             
5a43 53 5a			dw .SPICEH            
5a45 07				db 6 + 1 
5a46 .. 00			db "SPICEL",0              
5a4d				endm 
# End of macro CWHEAD
5a4d			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5a4d			 
5a4d cd 22 02				call spi_ce_low 
5a50			    NEXTW 
5a50 c3 37 24			jp macro_next 
5a53				endm 
# End of macro NEXTW
5a53			 
5a53			.SPICEH: 
5a53				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5a53 51				db WORD_SYS_CORE+61             
5a54 64 5a			dw .SPIOb            
5a56 07				db 6 + 1 
5a57 .. 00			db "SPICEH",0              
5a5e				endm 
# End of macro CWHEAD
5a5e			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5a5e			 
5a5e cd 11 02				call spi_ce_high 
5a61			    NEXTW 
5a61 c3 37 24			jp macro_next 
5a64				endm 
# End of macro NEXTW
5a64			 
5a64			 
5a64			.SPIOb: 
5a64			 
5a64				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5a64 51				db WORD_SYS_CORE+61             
5a65 96 5a			dw .SPII            
5a67 05				db 4 + 1 
5a68 .. 00			db "SPIO",0              
5a6d				endm 
# End of macro CWHEAD
5a6d			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5a6d			 
5a6d					if DEBUG_FORTH_WORDS_KEY 
5a6d						DMARK "SPo" 
5a6d f5				push af  
5a6e 3a 82 5a			ld a, (.dmark)  
5a71 32 a0 fd			ld (debug_mark),a  
5a74 3a 83 5a			ld a, (.dmark+1)  
5a77 32 a1 fd			ld (debug_mark+1),a  
5a7a 3a 84 5a			ld a, (.dmark+2)  
5a7d 32 a2 fd			ld (debug_mark+2),a  
5a80 18 03			jr .pastdmark  
5a82 ..			.dmark: db "SPo"  
5a85 f1			.pastdmark: pop af  
5a86			endm  
# End of macro DMARK
5a86						CALLMONITOR 
5a86 cd aa fd			call debug_vector  
5a89				endm  
# End of macro CALLMONITOR
5a89					endif 
5a89					; get port 
5a89			 
5a89			 
5a89					; get byte to send 
5a89			 
5a89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a89 cd 4b 22			call macro_dsp_valuehl 
5a8c				endm 
# End of macro FORTH_DSP_VALUEHL
5a8c			 
5a8c			;		push hl    ; u1  
5a8c			 
5a8c					; destroy value TOS 
5a8c			 
5a8c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a8c cd 03 23			call macro_forth_dsp_pop 
5a8f				endm 
# End of macro FORTH_DSP_POP
5a8f			 
5a8f					; one value on hl get other one back 
5a8f			 
5a8f			;		pop hl   ; u2 - addr 
5a8f			 
5a8f					; TODO Send SPI byte 
5a8f			 
5a8f			;		push hl 
5a8f			;		call spi_ce_low 
5a8f			;		pop hl 
5a8f 7d					ld a, l 
5a90 cd 10 01				call spi_send_byte 
5a93			;		call spi_ce_high 
5a93			 
5a93					NEXTW 
5a93 c3 37 24			jp macro_next 
5a96				endm 
# End of macro NEXTW
5a96			 
5a96			.SPII: 
5a96				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5a96 52				db WORD_SYS_CORE+62             
5a97 ff 5a			dw .SESEL            
5a99 06				db 5 + 1 
5a9a .. 00			db "SPII",0              
5a9f				endm 
# End of macro CWHEAD
5a9f			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5a9f					if DEBUG_FORTH_WORDS_KEY 
5a9f						DMARK "SPi" 
5a9f f5				push af  
5aa0 3a b4 5a			ld a, (.dmark)  
5aa3 32 a0 fd			ld (debug_mark),a  
5aa6 3a b5 5a			ld a, (.dmark+1)  
5aa9 32 a1 fd			ld (debug_mark+1),a  
5aac 3a b6 5a			ld a, (.dmark+2)  
5aaf 32 a2 fd			ld (debug_mark+2),a  
5ab2 18 03			jr .pastdmark  
5ab4 ..			.dmark: db "SPi"  
5ab7 f1			.pastdmark: pop af  
5ab8			endm  
# End of macro DMARK
5ab8						CALLMONITOR 
5ab8 cd aa fd			call debug_vector  
5abb				endm  
# End of macro CALLMONITOR
5abb					endif 
5abb			 
5abb					; TODO Get SPI byte 
5abb			 
5abb cd 37 01				call spi_read_byte 
5abe			 
5abe					if DEBUG_FORTH_WORDS 
5abe						DMARK "Si2" 
5abe f5				push af  
5abf 3a d3 5a			ld a, (.dmark)  
5ac2 32 a0 fd			ld (debug_mark),a  
5ac5 3a d4 5a			ld a, (.dmark+1)  
5ac8 32 a1 fd			ld (debug_mark+1),a  
5acb 3a d5 5a			ld a, (.dmark+2)  
5ace 32 a2 fd			ld (debug_mark+2),a  
5ad1 18 03			jr .pastdmark  
5ad3 ..			.dmark: db "Si2"  
5ad6 f1			.pastdmark: pop af  
5ad7			endm  
# End of macro DMARK
5ad7						CALLMONITOR 
5ad7 cd aa fd			call debug_vector  
5ada				endm  
# End of macro CALLMONITOR
5ada					endif 
5ada 26 00				ld h, 0 
5adc 6f					ld l, a 
5add					if DEBUG_FORTH_WORDS 
5add						DMARK "Si3" 
5add f5				push af  
5ade 3a f2 5a			ld a, (.dmark)  
5ae1 32 a0 fd			ld (debug_mark),a  
5ae4 3a f3 5a			ld a, (.dmark+1)  
5ae7 32 a1 fd			ld (debug_mark+1),a  
5aea 3a f4 5a			ld a, (.dmark+2)  
5aed 32 a2 fd			ld (debug_mark+2),a  
5af0 18 03			jr .pastdmark  
5af2 ..			.dmark: db "Si3"  
5af5 f1			.pastdmark: pop af  
5af6			endm  
# End of macro DMARK
5af6						CALLMONITOR 
5af6 cd aa fd			call debug_vector  
5af9				endm  
# End of macro CALLMONITOR
5af9					endif 
5af9 cd 46 20				call forth_push_numhl 
5afc			 
5afc					NEXTW 
5afc c3 37 24			jp macro_next 
5aff				endm 
# End of macro NEXTW
5aff			 
5aff			 
5aff			 
5aff			.SESEL: 
5aff				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5aff 66				db WORD_SYS_CORE+82             
5b00 a8 5b			dw .CARTDEV            
5b02 05				db 4 + 1 
5b03 .. 00			db "BANK",0              
5b08				endm 
# End of macro CWHEAD
5b08			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5b08					if DEBUG_FORTH_WORDS_KEY 
5b08						DMARK "BNK" 
5b08 f5				push af  
5b09 3a 1d 5b			ld a, (.dmark)  
5b0c 32 a0 fd			ld (debug_mark),a  
5b0f 3a 1e 5b			ld a, (.dmark+1)  
5b12 32 a1 fd			ld (debug_mark+1),a  
5b15 3a 1f 5b			ld a, (.dmark+2)  
5b18 32 a2 fd			ld (debug_mark+2),a  
5b1b 18 03			jr .pastdmark  
5b1d ..			.dmark: db "BNK"  
5b20 f1			.pastdmark: pop af  
5b21			endm  
# End of macro DMARK
5b21						CALLMONITOR 
5b21 cd aa fd			call debug_vector  
5b24				endm  
# End of macro CALLMONITOR
5b24					endif 
5b24			 
5b24 3e ff				ld a, 255 
5b26 32 98 f9				ld (spi_cartdev), a 
5b29			 
5b29					; get bank 
5b29			 
5b29					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b29 cd 4b 22			call macro_dsp_valuehl 
5b2c				endm 
# End of macro FORTH_DSP_VALUEHL
5b2c			 
5b2c			;		push hl 
5b2c			 
5b2c					; destroy value TOS 
5b2c			 
5b2c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b2c cd 03 23			call macro_forth_dsp_pop 
5b2f				endm 
# End of macro FORTH_DSP_POP
5b2f			 
5b2f					; one value on hl get other one back 
5b2f			 
5b2f			;		pop hl 
5b2f			 
5b2f			 
5b2f 0e ff				ld c, SPI_CE_HIGH 
5b31 06 30				ld b, '0'    ; human readable bank number 
5b33			 
5b33 7d					ld a, l 
5b34			 
5b34					if DEBUG_FORTH_WORDS 
5b34						DMARK "BNK" 
5b34 f5				push af  
5b35 3a 49 5b			ld a, (.dmark)  
5b38 32 a0 fd			ld (debug_mark),a  
5b3b 3a 4a 5b			ld a, (.dmark+1)  
5b3e 32 a1 fd			ld (debug_mark+1),a  
5b41 3a 4b 5b			ld a, (.dmark+2)  
5b44 32 a2 fd			ld (debug_mark+2),a  
5b47 18 03			jr .pastdmark  
5b49 ..			.dmark: db "BNK"  
5b4c f1			.pastdmark: pop af  
5b4d			endm  
# End of macro DMARK
5b4d						CALLMONITOR 
5b4d cd aa fd			call debug_vector  
5b50				endm  
# End of macro CALLMONITOR
5b50					endif 
5b50			 
5b50					; active low 
5b50			 
5b50 fe 00				cp 0 
5b52 28 28				jr z, .bset 
5b54 fe 01				cp 1 
5b56 20 04				jr nz, .b2 
5b58 cb 81				res 0, c 
5b5a 06 31				ld b, '1'    ; human readable bank number 
5b5c fe 02		.b2:		cp 2 
5b5e 20 04				jr nz, .b3 
5b60 cb 89				res 1, c 
5b62 06 32				ld b, '2'    ; human readable bank number 
5b64 fe 03		.b3:		cp 3 
5b66 20 04				jr nz, .b4 
5b68 cb 91				res 2, c 
5b6a 06 33				ld b, '3'    ; human readable bank number 
5b6c fe 04		.b4:		cp 4 
5b6e 20 04				jr nz, .b5 
5b70 cb 99				res 3, c 
5b72 06 34				ld b, '4'    ; human readable bank number 
5b74 fe 05		.b5:		cp 5 
5b76 20 04				jr nz, .bset 
5b78 cb a1				res 4, c 
5b7a 06 35				ld b, '5'    ; human readable bank number 
5b7c			 
5b7c			.bset: 
5b7c 79					ld a, c 
5b7d 32 95 f9				ld (spi_device),a 
5b80 78					ld a, b 
5b81 32 94 f9				ld (spi_device_id),a 
5b84					if DEBUG_FORTH_WORDS 
5b84						DMARK "BN2" 
5b84 f5				push af  
5b85 3a 99 5b			ld a, (.dmark)  
5b88 32 a0 fd			ld (debug_mark),a  
5b8b 3a 9a 5b			ld a, (.dmark+1)  
5b8e 32 a1 fd			ld (debug_mark+1),a  
5b91 3a 9b 5b			ld a, (.dmark+2)  
5b94 32 a2 fd			ld (debug_mark+2),a  
5b97 18 03			jr .pastdmark  
5b99 ..			.dmark: db "BN2"  
5b9c f1			.pastdmark: pop af  
5b9d			endm  
# End of macro DMARK
5b9d						CALLMONITOR 
5b9d cd aa fd			call debug_vector  
5ba0				endm  
# End of macro CALLMONITOR
5ba0					endif 
5ba0			 
5ba0					; set default SPI clk pulse time as disabled for BANK use 
5ba0			 
5ba0 3e 00				ld a, 0 
5ba2 32 99 f9				ld (spi_clktime), a 
5ba5			 
5ba5					NEXTW 
5ba5 c3 37 24			jp macro_next 
5ba8				endm 
# End of macro NEXTW
5ba8			 
5ba8			.CARTDEV: 
5ba8				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5ba8 66				db WORD_SYS_CORE+82             
5ba9 56 5c			dw .ENDDEVICE            
5bab 08				db 7 + 1 
5bac .. 00			db "CARTDEV",0              
5bb4				endm 
# End of macro CWHEAD
5bb4			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5bb4					if DEBUG_FORTH_WORDS_KEY 
5bb4						DMARK "CDV" 
5bb4 f5				push af  
5bb5 3a c9 5b			ld a, (.dmark)  
5bb8 32 a0 fd			ld (debug_mark),a  
5bbb 3a ca 5b			ld a, (.dmark+1)  
5bbe 32 a1 fd			ld (debug_mark+1),a  
5bc1 3a cb 5b			ld a, (.dmark+2)  
5bc4 32 a2 fd			ld (debug_mark+2),a  
5bc7 18 03			jr .pastdmark  
5bc9 ..			.dmark: db "CDV"  
5bcc f1			.pastdmark: pop af  
5bcd			endm  
# End of macro DMARK
5bcd						CALLMONITOR 
5bcd cd aa fd			call debug_vector  
5bd0				endm  
# End of macro CALLMONITOR
5bd0					endif 
5bd0			 
5bd0					; disable se storage bank selection 
5bd0			 
5bd0 3e ff				ld a, SPI_CE_HIGH		; ce high 
5bd2 32 95 f9				ld (spi_device), a 
5bd5			 
5bd5					; get bank 
5bd5			 
5bd5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5bd5 cd 4b 22			call macro_dsp_valuehl 
5bd8				endm 
# End of macro FORTH_DSP_VALUEHL
5bd8			 
5bd8			;		push hl 
5bd8			 
5bd8					; destroy value TOS 
5bd8			 
5bd8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5bd8 cd 03 23			call macro_forth_dsp_pop 
5bdb				endm 
# End of macro FORTH_DSP_POP
5bdb			 
5bdb					; one value on hl get other one back 
5bdb			 
5bdb			;		pop hl 
5bdb			 
5bdb					; active low 
5bdb			 
5bdb 0e ff				ld c, 255 
5bdd			 
5bdd 7d					ld a, l 
5bde					if DEBUG_FORTH_WORDS 
5bde						DMARK "CDV" 
5bde f5				push af  
5bdf 3a f3 5b			ld a, (.dmark)  
5be2 32 a0 fd			ld (debug_mark),a  
5be5 3a f4 5b			ld a, (.dmark+1)  
5be8 32 a1 fd			ld (debug_mark+1),a  
5beb 3a f5 5b			ld a, (.dmark+2)  
5bee 32 a2 fd			ld (debug_mark+2),a  
5bf1 18 03			jr .pastdmark  
5bf3 ..			.dmark: db "CDV"  
5bf6 f1			.pastdmark: pop af  
5bf7			endm  
# End of macro DMARK
5bf7						CALLMONITOR 
5bf7 cd aa fd			call debug_vector  
5bfa				endm  
# End of macro CALLMONITOR
5bfa					endif 
5bfa fe 00				cp 0 
5bfc 28 30				jr z, .cset 
5bfe fe 01				cp 1 
5c00 20 02				jr nz, .c2 
5c02 cb 81				res 0, c 
5c04 fe 02		.c2:		cp 2 
5c06 20 02				jr nz, .c3 
5c08 cb 89				res 1, c 
5c0a fe 03		.c3:		cp 3 
5c0c 20 02				jr nz, .c4 
5c0e cb 91				res 2, c 
5c10 fe 04		.c4:		cp 4 
5c12 20 02				jr nz, .c5 
5c14 cb 99				res 3, c 
5c16 fe 05		.c5:		cp 5 
5c18 20 02				jr nz, .c6 
5c1a cb a1				res 4, c 
5c1c fe 06		.c6:		cp 6 
5c1e 20 02				jr nz, .c7 
5c20 cb a9				res 5, c 
5c22 fe 07		.c7:		cp 7 
5c24 20 02				jr nz, .c8 
5c26 cb b1				res 6, c 
5c28 fe 08		.c8:		cp 8 
5c2a 20 02				jr nz, .cset 
5c2c cb b9				res 7, c 
5c2e 79			.cset:		ld a, c 
5c2f 32 98 f9				ld (spi_cartdev),a 
5c32			 
5c32					if DEBUG_FORTH_WORDS 
5c32						DMARK "CD2" 
5c32 f5				push af  
5c33 3a 47 5c			ld a, (.dmark)  
5c36 32 a0 fd			ld (debug_mark),a  
5c39 3a 48 5c			ld a, (.dmark+1)  
5c3c 32 a1 fd			ld (debug_mark+1),a  
5c3f 3a 49 5c			ld a, (.dmark+2)  
5c42 32 a2 fd			ld (debug_mark+2),a  
5c45 18 03			jr .pastdmark  
5c47 ..			.dmark: db "CD2"  
5c4a f1			.pastdmark: pop af  
5c4b			endm  
# End of macro DMARK
5c4b						CALLMONITOR 
5c4b cd aa fd			call debug_vector  
5c4e				endm  
# End of macro CALLMONITOR
5c4e					endif 
5c4e			 
5c4e					; set default SPI clk pulse time as 10ms for CARTDEV use 
5c4e			 
5c4e 3e 0a				ld a, $0a 
5c50 32 99 f9				ld (spi_clktime), a 
5c53					NEXTW 
5c53 c3 37 24			jp macro_next 
5c56				endm 
# End of macro NEXTW
5c56			endif 
5c56			 
5c56			.ENDDEVICE: 
5c56			; eof 
5c56			 
# End of file forth_words_device.asm
5c56			 
5c56			; var handler 
5c56			 
5c56			 
5c56			.VARS: 
5c56				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5c56 77				db WORD_SYS_CORE+99             
5c57 07 5d			dw .V0            
5c59 04				db 3 + 1 
5c5a .. 00			db "VAR",0              
5c5e				endm 
# End of macro CWHEAD
5c5e			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5c5e			;| 
5c5e			;| The variable name should consist of a single letter. e.g. "a" 
5c5e			;! If a full string is passed then only the first char is looked at 
5c5e			;| Any other char could exceed bounds checks!  
5c5e			 
5c5e					if DEBUG_FORTH_WORDS_KEY 
5c5e						DMARK "VAR" 
5c5e f5				push af  
5c5f 3a 73 5c			ld a, (.dmark)  
5c62 32 a0 fd			ld (debug_mark),a  
5c65 3a 74 5c			ld a, (.dmark+1)  
5c68 32 a1 fd			ld (debug_mark+1),a  
5c6b 3a 75 5c			ld a, (.dmark+2)  
5c6e 32 a2 fd			ld (debug_mark+2),a  
5c71 18 03			jr .pastdmark  
5c73 ..			.dmark: db "VAR"  
5c76 f1			.pastdmark: pop af  
5c77			endm  
# End of macro DMARK
5c77						CALLMONITOR 
5c77 cd aa fd			call debug_vector  
5c7a				endm  
# End of macro CALLMONITOR
5c7a					endif 
5c7a			 
5c7a					FORTH_DSP_VALUEHL 
5c7a cd 4b 22			call macro_dsp_valuehl 
5c7d				endm 
# End of macro FORTH_DSP_VALUEHL
5c7d			 
5c7d 7e					ld a, (hl)    ; get first char on of the string 
5c7e			 
5c7e			 
5c7e					if DEBUG_FORTH_WORDS 
5c7e						DMARK "VR1" 
5c7e f5				push af  
5c7f 3a 93 5c			ld a, (.dmark)  
5c82 32 a0 fd			ld (debug_mark),a  
5c85 3a 94 5c			ld a, (.dmark+1)  
5c88 32 a1 fd			ld (debug_mark+1),a  
5c8b 3a 95 5c			ld a, (.dmark+2)  
5c8e 32 a2 fd			ld (debug_mark+2),a  
5c91 18 03			jr .pastdmark  
5c93 ..			.dmark: db "VR1"  
5c96 f1			.pastdmark: pop af  
5c97			endm  
# End of macro DMARK
5c97						CALLMONITOR 
5c97 cd aa fd			call debug_vector  
5c9a				endm  
# End of macro CALLMONITOR
5c9a					endif 
5c9a					 
5c9a f5					push af	 
5c9b					FORTH_DSP_POP 
5c9b cd 03 23			call macro_forth_dsp_pop 
5c9e				endm 
# End of macro FORTH_DSP_POP
5c9e f1					pop af 
5c9f			 
5c9f					; convert to upper 
5c9f			 
5c9f cd 53 12				call to_upper 
5ca2					if DEBUG_FORTH_WORDS 
5ca2						DMARK "Vaa" 
5ca2 f5				push af  
5ca3 3a b7 5c			ld a, (.dmark)  
5ca6 32 a0 fd			ld (debug_mark),a  
5ca9 3a b8 5c			ld a, (.dmark+1)  
5cac 32 a1 fd			ld (debug_mark+1),a  
5caf 3a b9 5c			ld a, (.dmark+2)  
5cb2 32 a2 fd			ld (debug_mark+2),a  
5cb5 18 03			jr .pastdmark  
5cb7 ..			.dmark: db "Vaa"  
5cba f1			.pastdmark: pop af  
5cbb			endm  
# End of macro DMARK
5cbb						CALLMONITOR 
5cbb cd aa fd			call debug_vector  
5cbe				endm  
# End of macro CALLMONITOR
5cbe					endif 
5cbe 06 41				ld b, 'A' 
5cc0 90					sub b			; set offset 
5cc1					if DEBUG_FORTH_WORDS 
5cc1						DMARK "Vbb" 
5cc1 f5				push af  
5cc2 3a d6 5c			ld a, (.dmark)  
5cc5 32 a0 fd			ld (debug_mark),a  
5cc8 3a d7 5c			ld a, (.dmark+1)  
5ccb 32 a1 fd			ld (debug_mark+1),a  
5cce 3a d8 5c			ld a, (.dmark+2)  
5cd1 32 a2 fd			ld (debug_mark+2),a  
5cd4 18 03			jr .pastdmark  
5cd6 ..			.dmark: db "Vbb"  
5cd9 f1			.pastdmark: pop af  
5cda			endm  
# End of macro DMARK
5cda						CALLMONITOR 
5cda cd aa fd			call debug_vector  
5cdd				endm  
# End of macro CALLMONITOR
5cdd					endif 
5cdd cb 27				sla a  
5cdf				 
5cdf					 
5cdf					if DEBUG_FORTH_WORDS 
5cdf						DMARK "VR2" 
5cdf f5				push af  
5ce0 3a f4 5c			ld a, (.dmark)  
5ce3 32 a0 fd			ld (debug_mark),a  
5ce6 3a f5 5c			ld a, (.dmark+1)  
5ce9 32 a1 fd			ld (debug_mark+1),a  
5cec 3a f6 5c			ld a, (.dmark+2)  
5cef 32 a2 fd			ld (debug_mark+2),a  
5cf2 18 03			jr .pastdmark  
5cf4 ..			.dmark: db "VR2"  
5cf7 f1			.pastdmark: pop af  
5cf8			endm  
# End of macro DMARK
5cf8						CALLMONITOR 
5cf8 cd aa fd			call debug_vector  
5cfb				endm  
# End of macro CALLMONITOR
5cfb					endif 
5cfb			 
5cfb 21 29 f9				ld hl, cli_var_array2 
5cfe cd de 0f				call addatohl 
5d01 cd 46 20				call forth_push_numhl 
5d04			 
5d04			 
5d04				       NEXTW 
5d04 c3 37 24			jp macro_next 
5d07				endm 
# End of macro NEXTW
5d07			.V0: 
5d07				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5d07 78				db WORD_SYS_CORE+100             
5d08 1f 5d			dw .V0Q            
5d0a 04				db 3 + 1 
5d0b .. 00			db "V0!",0              
5d0f				endm 
# End of macro CWHEAD
5d0f			;| V0! ( u1 -- )  Store value to v0  | DONE 
5d0f			 
5d0f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d0f cd 4b 22			call macro_dsp_valuehl 
5d12				endm 
# End of macro FORTH_DSP_VALUEHL
5d12			 
5d12 11 5d f9				ld de, cli_var_array 
5d15			 
5d15 eb					ex de, hl 
5d16 73					ld (hl), e 
5d17 23					inc hl 
5d18 72					ld (hl), d 
5d19			 
5d19					; destroy value TOS 
5d19			 
5d19					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d19 cd 03 23			call macro_forth_dsp_pop 
5d1c				endm 
# End of macro FORTH_DSP_POP
5d1c			 
5d1c				       NEXTW 
5d1c c3 37 24			jp macro_next 
5d1f				endm 
# End of macro NEXTW
5d1f			.V0Q: 
5d1f				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5d1f 79				db WORD_SYS_CORE+101             
5d20 30 5d			dw .V1S            
5d22 04				db 3 + 1 
5d23 .. 00			db "V0@",0              
5d27				endm 
# End of macro CWHEAD
5d27			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5d27 2a 5d f9				ld hl, (cli_var_array) 
5d2a cd 46 20				call forth_push_numhl 
5d2d			 
5d2d				       NEXTW 
5d2d c3 37 24			jp macro_next 
5d30				endm 
# End of macro NEXTW
5d30			.V1S: 
5d30				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5d30 7a				db WORD_SYS_CORE+102             
5d31 48 5d			dw .V1Q            
5d33 04				db 3 + 1 
5d34 .. 00			db "V1!",0              
5d38				endm 
# End of macro CWHEAD
5d38			;| V1! ( u1 -- )  Store value to v1 | DONE 
5d38					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d38 cd 4b 22			call macro_dsp_valuehl 
5d3b				endm 
# End of macro FORTH_DSP_VALUEHL
5d3b			 
5d3b 11 5f f9				ld de, cli_var_array+2 
5d3e				 
5d3e eb					ex de, hl 
5d3f 73					ld (hl), e 
5d40 23					inc hl 
5d41 72					ld (hl), d 
5d42			 
5d42					; destroy value TOS 
5d42			 
5d42					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d42 cd 03 23			call macro_forth_dsp_pop 
5d45				endm 
# End of macro FORTH_DSP_POP
5d45				       NEXTW 
5d45 c3 37 24			jp macro_next 
5d48				endm 
# End of macro NEXTW
5d48			.V1Q: 
5d48				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5d48 7b				db WORD_SYS_CORE+103             
5d49 59 5d			dw .V2S            
5d4b 04				db 3 + 1 
5d4c .. 00			db "V1@",0              
5d50				endm 
# End of macro CWHEAD
5d50			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5d50 2a 5f f9				ld hl, (cli_var_array+2) 
5d53 cd 46 20				call forth_push_numhl 
5d56				       NEXTW 
5d56 c3 37 24			jp macro_next 
5d59				endm 
# End of macro NEXTW
5d59			.V2S: 
5d59				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5d59 7c				db WORD_SYS_CORE+104             
5d5a 71 5d			dw .V2Q            
5d5c 04				db 3 + 1 
5d5d .. 00			db "V2!",0              
5d61				endm 
# End of macro CWHEAD
5d61			;| V2! ( u1 -- )  Store value to v2 | DONE 
5d61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d61 cd 4b 22			call macro_dsp_valuehl 
5d64				endm 
# End of macro FORTH_DSP_VALUEHL
5d64			 
5d64 11 61 f9				ld de, cli_var_array+4 
5d67				 
5d67 eb					ex de, hl 
5d68 73					ld (hl), e 
5d69 23					inc hl 
5d6a 72					ld (hl), d 
5d6b			 
5d6b					; destroy value TOS 
5d6b			 
5d6b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d6b cd 03 23			call macro_forth_dsp_pop 
5d6e				endm 
# End of macro FORTH_DSP_POP
5d6e				       NEXTW 
5d6e c3 37 24			jp macro_next 
5d71				endm 
# End of macro NEXTW
5d71			.V2Q: 
5d71				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5d71 7d				db WORD_SYS_CORE+105             
5d72 82 5d			dw .V3S            
5d74 04				db 3 + 1 
5d75 .. 00			db "V2@",0              
5d79				endm 
# End of macro CWHEAD
5d79			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5d79 2a 61 f9				ld hl, (cli_var_array+4) 
5d7c cd 46 20				call forth_push_numhl 
5d7f				       NEXTW 
5d7f c3 37 24			jp macro_next 
5d82				endm 
# End of macro NEXTW
5d82			.V3S: 
5d82				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5d82 7c				db WORD_SYS_CORE+104             
5d83 9a 5d			dw .V3Q            
5d85 04				db 3 + 1 
5d86 .. 00			db "V3!",0              
5d8a				endm 
# End of macro CWHEAD
5d8a			;| V3! ( u1 -- )  Store value to v3 | DONE 
5d8a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d8a cd 4b 22			call macro_dsp_valuehl 
5d8d				endm 
# End of macro FORTH_DSP_VALUEHL
5d8d			 
5d8d 11 63 f9				ld de, cli_var_array+6 
5d90				 
5d90 eb					ex de, hl 
5d91 73					ld (hl), e 
5d92 23					inc hl 
5d93 72					ld (hl), d 
5d94			 
5d94					; destroy value TOS 
5d94			 
5d94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d94 cd 03 23			call macro_forth_dsp_pop 
5d97				endm 
# End of macro FORTH_DSP_POP
5d97				       NEXTW 
5d97 c3 37 24			jp macro_next 
5d9a				endm 
# End of macro NEXTW
5d9a			.V3Q: 
5d9a				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5d9a 7d				db WORD_SYS_CORE+105             
5d9b ab 5d			dw .END            
5d9d 04				db 3 + 1 
5d9e .. 00			db "V3@",0              
5da2				endm 
# End of macro CWHEAD
5da2			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5da2 2a 63 f9				ld hl, (cli_var_array+6) 
5da5 cd 46 20				call forth_push_numhl 
5da8				       NEXTW 
5da8 c3 37 24			jp macro_next 
5dab				endm 
# End of macro NEXTW
5dab			 
5dab			 
5dab			 
5dab			 
5dab			 
5dab			; end of dict marker 
5dab			 
5dab 00			.END:    db WORD_SYS_END 
5dac 00 00			dw 0 
5dae 00				db 0 
5daf			 
5daf			; use to jp here for user dict words to save on macro expansion  
5daf			 
5daf			user_dict_next: 
5daf				NEXTW 
5daf c3 37 24			jp macro_next 
5db2				endm 
# End of macro NEXTW
5db2			 
5db2			 
5db2			user_exec: 
5db2				;    ld hl, <word code> 
5db2				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5db2				;    call forthexec 
5db2				;    jp user_dict_next   (NEXT) 
5db2			        ;    <word code bytes> 
5db2 eb				ex de, hl 
5db3 2a f7 f3			ld hl,(os_tok_ptr) 
5db6				 
5db6				FORTH_RSP_NEXT 
5db6 cd ed 1f			call macro_forth_rsp_next 
5db9				endm 
# End of macro FORTH_RSP_NEXT
5db9			 
5db9			if DEBUG_FORTH_UWORD 
5db9						DMARK "UEX" 
5db9 f5				push af  
5dba 3a ce 5d			ld a, (.dmark)  
5dbd 32 a0 fd			ld (debug_mark),a  
5dc0 3a cf 5d			ld a, (.dmark+1)  
5dc3 32 a1 fd			ld (debug_mark+1),a  
5dc6 3a d0 5d			ld a, (.dmark+2)  
5dc9 32 a2 fd			ld (debug_mark+2),a  
5dcc 18 03			jr .pastdmark  
5dce ..			.dmark: db "UEX"  
5dd1 f1			.pastdmark: pop af  
5dd2			endm  
# End of macro DMARK
5dd2				CALLMONITOR 
5dd2 cd aa fd			call debug_vector  
5dd5				endm  
# End of macro CALLMONITOR
5dd5			endif 
5dd5			 
5dd5			 
5dd5			 
5dd5 eb				ex de, hl 
5dd6 22 f7 f3			ld (os_tok_ptr), hl 
5dd9				 
5dd9				; Don't use next - Skips the first word in uword. 
5dd9			 
5dd9 c3 c8 24			jp exec1 
5ddc			;	NEXT 
5ddc			 
5ddc			 
5ddc			; eof 
# End of file forth_wordsv4.asm
5ddc			endif 
5ddc			;;;;;;;;;;;;;; Debug code 
5ddc			 
5ddc			 
5ddc			;if DEBUG_FORTH_PARSE 
5ddc .. 00		.nowordfound: db "No match",0 
5de5 .. 00		.compword:	db "Comparing word ",0 
5df5 .. 00		.nextwordat:	db "Next word at",0 
5e02 .. 00		.charmatch:	db "Char match",0 
5e0d			;endif 
5e0d			if DEBUG_FORTH_JP 
5e0d			.foundword:	db "Word match. Exec..",0 
5e0d			endif 
5e0d			;if DEBUG_FORTH_PUSH 
5e0d .. 00		.enddict:	db "Dict end. Push.",0 
5e1d .. 00		.push_str:	db "Pushing string",0 
5e2c .. 00		.push_num:	db "Pushing number",0 
5e3b .. 00		.data_sp:	db "SP:",0 
5e3f .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5e51 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5e63 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5e75			;endif 
5e75			;if DEBUG_FORTH_MALLOC 
5e75 .. 00		.push_malloc:	db "Malloc address",0 
5e84			;endif 
5e84			 
5e84			 
5e84			 
5e84			; display malloc address and current data stack pointer  
5e84			 
5e84			malloc_error: 
5e84 d5				push de 
5e85 f5				push af 
5e86 e5				push hl 
5e87 cd aa 0d			call clear_display 
5e8a 11 aa 5e			ld de, .mallocerr 
5e8d 3e 00			ld a,0 
5e8f			;	ld de,os_word_scratch 
5e8f cd bd 0d			call str_at_display 
5e92 3e 11			ld a, display_row_1+17 
5e94 11 a0 fd			ld de, debug_mark 
5e97 cd bd 0d			call str_at_display 
5e9a cd cd 0d			call update_display 
5e9d				;call break_point_state 
5e9d cd 7a 73			call cin_wait 
5ea0			 
5ea0			;	ld a, ' ' 
5ea0			;	ld (os_view_disable), a 
5ea0 cd 47 19			call bp_on 
5ea3 e1				pop hl 
5ea4 f1				pop af 
5ea5 d1				pop de	 
5ea6				CALLMONITOR 
5ea6 cd aa fd			call debug_vector  
5ea9				endm  
# End of macro CALLMONITOR
5ea9 c9				ret 
5eaa			 
5eaa .. 00		.mallocerr: 	db "Malloc Error",0 
5eb7			;if DEBUG_FORTH_PUSH 
5eb7			display_data_sp: 
5eb7 f5				push af 
5eb8			 
5eb8				; see if disabled 
5eb8			 
5eb8			 
5eb8 3a aa fd			ld a, (debug_vector) 
5ebb fe c9			cp $C9  ; RET 
5ebd				;ld a, (os_view_disable) 
5ebd				;cp '*' 
5ebd 28 67			jr z, .skipdsp 
5ebf			 
5ebf e5				push hl 
5ec0 e5				push hl 
5ec1 e5			push hl 
5ec2 cd aa 0d			call clear_display 
5ec5 e1			pop hl 
5ec6 7c				ld a,h 
5ec7 21 fb f3			ld hl, os_word_scratch 
5eca cd e7 11			call hexout 
5ecd e1				pop hl 
5ece 7d				ld a,l 
5ecf 21 fd f3			ld hl, os_word_scratch+2 
5ed2 cd e7 11			call hexout 
5ed5 21 ff f3			ld hl, os_word_scratch+4 
5ed8 3e 00			ld a,0 
5eda 77				ld (hl),a 
5edb 11 fb f3			ld de,os_word_scratch 
5ede 3e 28				ld a, display_row_2 
5ee0 cd bd 0d				call str_at_display 
5ee3 11 3f 5e			ld de, .wordinhl 
5ee6 3e 00			ld a, display_row_1 
5ee8			 
5ee8 cd bd 0d				call str_at_display 
5eeb 11 a0 fd			ld de, debug_mark 
5eee 3e 11			ld a, display_row_1+17 
5ef0			 
5ef0 cd bd 0d				call str_at_display 
5ef3			 
5ef3				; display current data stack pointer 
5ef3 11 3b 5e			ld de,.data_sp 
5ef6 3e 30				ld a, display_row_2 + 8 
5ef8 cd bd 0d				call str_at_display 
5efb			 
5efb 2a 23 f9			ld hl,(cli_data_sp) 
5efe e5				push hl 
5eff 7c				ld a,h 
5f00 21 fb f3			ld hl, os_word_scratch 
5f03 cd e7 11			call hexout 
5f06 e1				pop hl 
5f07 7d				ld a,l 
5f08 21 fd f3			ld hl, os_word_scratch+2 
5f0b cd e7 11			call hexout 
5f0e 21 ff f3			ld hl, os_word_scratch+4 
5f11 3e 00			ld a,0 
5f13 77				ld (hl),a 
5f14 11 fb f3			ld de,os_word_scratch 
5f17 3e 33				ld a, display_row_2 + 11 
5f19 cd bd 0d				call str_at_display 
5f1c			 
5f1c			 
5f1c cd cd 0d			call update_display 
5f1f cd ed 0c			call delay1s 
5f22 cd ed 0c			call delay1s 
5f25 e1				pop hl 
5f26			.skipdsp: 
5f26 f1				pop af 
5f27 c9				ret 
5f28			 
5f28			display_data_malloc: 
5f28			 
5f28 f5				push af 
5f29 e5				push hl 
5f2a e5				push hl 
5f2b e5			push hl 
5f2c cd aa 0d			call clear_display 
5f2f e1			pop hl 
5f30 7c				ld a,h 
5f31 21 fb f3			ld hl, os_word_scratch 
5f34 cd e7 11			call hexout 
5f37 e1				pop hl 
5f38 7d				ld a,l 
5f39 21 fd f3			ld hl, os_word_scratch+2 
5f3c cd e7 11			call hexout 
5f3f 21 ff f3			ld hl, os_word_scratch+4 
5f42 3e 00			ld a,0 
5f44 77				ld (hl),a 
5f45 11 fb f3			ld de,os_word_scratch 
5f48 3e 28				ld a, display_row_2 
5f4a cd bd 0d				call str_at_display 
5f4d 11 75 5e			ld de, .push_malloc 
5f50 3e 00			ld a, display_row_1 
5f52			 
5f52 cd bd 0d				call str_at_display 
5f55			 
5f55				; display current data stack pointer 
5f55 11 3b 5e			ld de,.data_sp 
5f58 3e 30				ld a, display_row_2 + 8 
5f5a cd bd 0d				call str_at_display 
5f5d			 
5f5d 2a 23 f9			ld hl,(cli_data_sp) 
5f60 e5				push hl 
5f61 7c				ld a,h 
5f62 21 fb f3			ld hl, os_word_scratch 
5f65 cd e7 11			call hexout 
5f68 e1				pop hl 
5f69 7d				ld a,l 
5f6a 21 fd f3			ld hl, os_word_scratch+2 
5f6d cd e7 11			call hexout 
5f70 21 ff f3			ld hl, os_word_scratch+4 
5f73 3e 00			ld a,0 
5f75 77				ld (hl),a 
5f76 11 fb f3			ld de,os_word_scratch 
5f79 3e 33				ld a, display_row_2 + 11 
5f7b cd bd 0d				call str_at_display 
5f7e			 
5f7e cd cd 0d			call update_display 
5f81 cd ed 0c			call delay1s 
5f84 cd ed 0c			call delay1s 
5f87 e1				pop hl 
5f88 f1				pop af 
5f89 c9				ret 
5f8a			;endif 
5f8a			 
5f8a			include "forth_autostart.asm" 
5f8a			; list of commands to perform at system start up 
5f8a			 
5f8a			startcmds: 
5f8a			;	dw test11 
5f8a			;	dw test12 
5f8a			;	dw test13 
5f8a			;	dw test14 
5f8a			;	dw test15 
5f8a			;	dw test16 
5f8a			;	dw test17 
5f8a			;	dw ifthtest1 
5f8a			;	dw ifthtest2 
5f8a			;	dw ifthtest3 
5f8a			;	dw mmtest1 
5f8a			;	dw mmtest2 
5f8a			;	dw mmtest3 
5f8a			;	dw mmtest4 
5f8a			;	dw mmtest5 
5f8a			;	dw mmtest6 
5f8a			;	dw iftest1 
5f8a			;	dw iftest2 
5f8a			;	dw iftest3 
5f8a			;	dw looptest1 
5f8a			;	dw looptest2 
5f8a			;	dw test1 
5f8a			;	dw test2 
5f8a			;	dw test3 
5f8a			;	dw test4 
5f8a			;	dw game2r 
5f8a			;	dw game2b1 
5f8a			;	dw game2b2 
5f8a			 
5f8a				; start up words that are actually useful 
5f8a			 
5f8a			;    dw spi1 
5f8a			;    dw spi2 
5f8a			;    dw spi3 
5f8a			;    dw spi4 
5f8a			;    dw spi5 
5f8a			;    dw spi6 
5f8a			;    dw spi7 
5f8a			; 
5f8a			;    dw spi8 
5f8a			;    dw spi9 
5f8a			;    dw spi10 
5f8a			 
5f8a			; file editor 
5f8a			;	dw edit1 
5f8a			;	dw edit2 
5f8a			;	dw edit3 
5f8a			 
5f8a			;	dw longread 
5f8a aa 63			dw clrstack 
5f8c de 63			dw type 
5f8e			;	dw stest 
5f8e 03 64			dw strncpy 
5f90			;	dw list 
5f90 64 64			dw start1 
5f92 74 64			dw start2 
5f94			;	dw start3 
5f94			;	dw start3b 
5f94			;	dw start3c 
5f94			 
5f94				; (unit) testing words 
5f94			 
5f94			;	dw mtesta 
5f94			;	dw mtestb 
5f94			;	dw mtestc 
5f94			;	dw mtestd 
5f94			;	dw mteste 
5f94			 
5f94				; demo/game words 
5f94			 
5f94			;        dw game3w 
5f94			;        dw game3p 
5f94			;        dw game3sc 
5f94			;        dw game3vsi 
5f94			;        dw game3vs 
5f94				 
5f94			;	dw game2b 
5f94			;	dw game2bf 
5f94			;	dw game2mba 
5f94			;	dw game2mbas 
5f94			;	dw game2mb 
5f94			 
5f94 91 67			dw game1 
5f96 a2 67			dw game1a 
5f98 04 68			dw game1b 
5f9a 39 68			dw game1c 
5f9c 6f 68			dw game1d 
5f9e a0 68			dw game1s 
5fa0 b4 68			dw game1t 
5fa2 c9 68			dw game1f 
5fa4 fd 68			dw game1z 
5fa6 41 69			dw game1zz 
5fa8			 
5fa8 ca 65			dw test5 
5faa 02 66			dw test6 
5fac 3a 66			dw test7 
5fae 4e 66			dw test8 
5fb0 7a 66			dw test9 
5fb2 90 66			dw test10 
5fb4				 
5fb4 18 6a		        dw ssv5 
5fb6 fc 69		        dw ssv4 
5fb8 e0 69		        dw ssv3 
5fba aa 69		        dw ssv2 
5fbc 31 6a		        dw ssv1 
5fbe 79 6a		        dw ssv1cpm 
5fc0			;	dw keyup 
5fc0			;	dw keydown 
5fc0			;	dw keyleft 
5fc0			;	dw keyright 
5fc0			;	dw 	keyf1 
5fc0			;	dw keyf2 
5fc0			;	dw keyf3 
5fc0			;	dw keyf4 
5fc0			;	dw keyf5 
5fc0			;	dw keyf6 
5fc0			;	dw keyf7 
5fc0			;	dw keyf8 
5fc0			;	dw keyf9 
5fc0			;	dw keyf10 
5fc0			;	dw keyf11 
5fc0			;	dw keyf12 
5fc0			;	dw keytab 
5fc0			;	dw keycr 
5fc0			;	dw keyhome 
5fc0			;	dw keyend 
5fc0			;	dw keybs 
5fc0 00 00			db 0, 0	 
5fc2			 
5fc2			 
5fc2			; File Editor 
5fc2			 
5fc2			; ( id - ) use 'e' to edit the displayed line 
5fc2 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5fe3 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
6018			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
6018 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
6050			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
6050			 
6050			; SPI Net support words 
6050			 
6050			; v0! = node to send to 
6050			; ( str count - ) 
6050 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
60a9			 
60a9			; spiputc ( char node - ) 
60a9 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
60dd			; spiputc ( u node - ) 
60dd .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
610b			 
610b			; spigetc ( - n ) 
610b .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
6134			 
6134			; getnode ( - n ) 
6134 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
6161			 
6161			; ( str node - )  
6161 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
61c7			; store string ( str i - ) 
61c7			 
61c7			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
61c7 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
621c			 
621c			; get string ( addr i -  )    TO FIX 
621c			 
621c .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
6274			 
6274			 
6274			; NETCHAT (TODO) 
6274			; Program to allow two nodes to chat with eachother 
6274			; 
6274			; v0 - target node 
6274			;  
6274			; accept input at 0,0 
6274			; if input is string send spitype to target node 
6274			; starting at row 2,0 , while spigetchr is not zero ->  
6274			; 
6274			; 
6274			; TODO add paging of get request 
6274			 
6274			; ( node - ) 
6274 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
6293 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
62eb .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
6363			 
6363			 
6363			; Long read of currently open file 
6363 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
63aa			 
63aa			; clear stack  
63aa			 
63aa .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
63de			 
63de			; type ( addr count - ) 
63de .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6403			 
6403			; some direct memory words 
6403			; strncpy ( len t f -- t ) 
6403			 
6403 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6464			 
6464 .. 00		start1:     	db ": bpon $00 bp ;",0 
6474 .. 00		start2:     	db ": bpoff $01 bp ;",0 
6485 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6500 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
6560			 
6560			 
6560			; a handy word to list items on the stack 
6560			 
6560 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
65ca			 
65ca			 
65ca			; test stack  
65ca			; rnd8 stest 
65ca			 
65ca			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
65ca			 
65ca			; random malloc and free cycles 
65ca			 
65ca			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
65ca			 
65ca			; fixed malloc and free cycles 
65ca			 
65ca			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
65ca			 
65ca			; fixed double string push and drop cycle  
65ca			 
65ca			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
65ca			 
65ca			; consistent fixed string push and drop cycle  
65ca			 
65ca			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
65ca			 
65ca			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
65ca			 
65ca			;test1:		db ": aa 1 2 3 ;", 0 
65ca			;test2:     	db "111 aa 888 999",0 
65ca			;test3:     	db ": bb 77 ;",0 
65ca			;test4:     	db "$02 $01 do i . loop bb",0 
65ca			 
65ca .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6602 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
663a .. 00		test7:     	db ": box hline vline ;",0 
664e .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
667a .. 00		test9:     	db ": sw $01 adsp world ;",0 
6690 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
66b5			;test11:     	db "hello create .",0 
66b5			;test12:     	db "hello2 create .",0 
66b5			 
66b5			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
66b5			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
66b5			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
66b5			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
66b5			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
66b5			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
66b5			 
66b5			;iftest1:     	db "$0001 IF cls .",0 
66b5			;iftest2:     	db "$0000 IF cls .",0 
66b5			;iftest3:     	db "$0002 $0003 - IF cls .",0 
66b5			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
66b5			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
66b5			 
66b5			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
66b5			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
66b5			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
66b5			 
66b5			 
66b5 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
66d9 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6709 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
672e .. 00		sound4: db ": cha $00 ; ",0 
673b .. 00		sound5: db ": chb $20 ; ",0 
6748 .. 00		sound6: db ": chc $40 ; ",0 
6755 .. 00		sound7: db ": chd $60 ; ",0 
6762 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
677a .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6791			 
6791			 
6791			 
6791			 
6791			; a small guess the number game 
6791			 
6791 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
67a2 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6804			 
6804 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6839 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
686f .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
68a0 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
68b4 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
68c9 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
68fd .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6941			 
6941			; Using 'ga' save a high score across multiple runs using external storage 
6941			 
6941 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
69aa			 
69aa			 
69aa			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
69aa			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
69aa			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
69aa			 
69aa			; simple screen saver to test code memory reuse to destruction 
69aa			 
69aa .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
69e0 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
69fc .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6a18 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6a31 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6a79 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6ad0			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6ad0			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6ad0			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6ad0			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6ad0			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6ad0			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6ad0			 
6ad0			 
6ad0			 
6ad0			; minesweeper/battleship finding game 
6ad0			; draws a game board of random ship/mine positions 
6ad0			; user enters coords to see if it hits on 
6ad0			; game ends when all are hit 
6ad0			; when hit or miss says how many may be in the area 
6ad0			 
6ad0			; setup the game board and then hide it 
6ad0			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6ad0			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6ad0			;; prompt for where to target 
6ad0			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6ad0			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6ad0			;; TODO see if the entered coords hits or misses pushes char hit of miss 
6ad0			;game2mbht:      db ": mbckht nop ;",0 
6ad0			;game2mbms:      db ": mbcms nop ;",0 
6ad0			; TODO how many might be near by 
6ad0			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6ad0			 
6ad0			; Game 3 
6ad0			 
6ad0			; Vert scroller ski game - avoid the trees! 
6ad0			 
6ad0			; v0 score (ie turns) 
6ad0			; v1 player pos 
6ad0			; v2 left wall 
6ad0			; v3 right wall 
6ad0			 
6ad0			; Draw side walls randomly 
6ad0			 
6ad0			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6ad0			 
6ad0			; Draw player 
6ad0			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6ad0			 
6ad0			; TODO Get Key 
6ad0			 
6ad0			; TODO Move left right 
6ad0			 
6ad0			; scroll and move walls a bit 
6ad0			 
6ad0			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6ad0			 
6ad0			; main game loop 
6ad0			 
6ad0			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6ad0			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6ad0			 
6ad0			; key board defs 
6ad0			 
6ad0 .. 00		keyup:       db ": keyup $05 ;",0 
6ade .. 00		keydown:       db ": keydown $0a ;",0 
6aee .. 00		keyleft:       db ": keyleft $0b ;",0 
6afe .. 00		keyright:       db ": keyright $0c ;",0 
6b0f .. 00		keyf1:       db ": keyf1 $10 ;",0 
6b1d .. 00		keyf2:       db ": keyf2 $11 ;",0 
6b2b .. 00		keyf3:       db ": keyf3 $12 ;",0 
6b39 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6b47 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6b55 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6b63 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6b71 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6b7f .. 00		keyf9:       db ": keyf9 $18 ;",0 
6b8d .. 00		keyf10:       db ": keyf10 $19 ;",0 
6b9c .. 00		keyf11:       db ": keyf11 $1a ;",0 
6bab .. 00		keyf12:       db ": keyf12 $1b ;",0 
6bba			 
6bba .. 00		keytab:       db ": keytab $09 ;",0 
6bc9 .. 00		keycr:       db ": keycr $0d ;",0 
6bd7 .. 00		keyhome:       db ": keyhome $0e ;",0 
6be7 .. 00		keyend:       db ": keyend $0f ;",0 
6bf6 .. 00		keybs:       db ": keybs $08 ;",0 
6c04			 
6c04			   
6c04			 
6c04			 
6c04			 
6c04			; eof 
# End of file forth_autostart.asm
6c04			 
6c04			 
6c04			 
6c04			; stack over and underflow checks 
6c04			 
6c04			; init the words to detect the under/overflow 
6c04			 
6c04			chk_stk_init: 
6c04				; a vague random number to check so we dont get any "lucky" hits 
6c04 3e 2d			ld a, 45 
6c06 6f				ld l, a 
6c07 00				nop 
6c08 3e 17			ld a, 23 
6c0a 67				ld h, a 
6c0b			 
6c0b 22 d2 f0			ld (chk_word), hl     ; the word we need to check against 
6c0e			 
6c0e			;	ld (chk_stund), hl	; stack points.... 
6c0e 22 3b fe			ld (chk_stovr), hl 
6c11 22 21 f9			ld (chk_ret_und), hl 
6c14 22 df f8			ld (chk_ret_ovr), hl 
6c17 22 5d f8			ld (chk_loop_ovr), hl 
6c1a 22 5b f6			ld (chk_data_ovr), hl 
6c1d c9				ret 
6c1e				 
6c1e			check_stacks: 
6c1e				; check all stack words 
6c1e			 
6c1e e5				push hl 
6c1f d5				push de 
6c20			 
6c20			;	ld de,(chk_word) 
6c20			;	ld hl, (chk_stund)	; stack points.... 
6c20			;	if DEBUG_STK_FAULT 
6c20			;		DMARK "FAa" 
6c20			;		CALLMONITOR 
6c20			;	endif 
6c20			;	call cmp16 
6c20			;	jp z, .chk_faulta 
6c20			; 
6c20			;	ld de, sfaultsu 
6c20			;	jp .chk_fault 
6c20			 
6c20 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
6c23 ed 5b d2 f0		ld de,(chk_word) 
6c27				if DEBUG_STK_FAULT 
6c27					DMARK "FAb" 
6c27					CALLMONITOR 
6c27				endif 
6c27 cd fc 0f			call cmp16 
6c2a 28 06			jr z, .chk_fault1 
6c2c 11 d0 6c			ld de, sfaultso 
6c2f c3 81 6c			jp .chk_fault 
6c32			.chk_fault1:  
6c32 2a 21 f9			ld hl, (chk_ret_und) 
6c35 ed 5b d2 f0		ld de,(chk_word) 
6c39				if DEBUG_STK_FAULT 
6c39					DMARK "FAU" 
6c39					CALLMONITOR 
6c39				endif 
6c39 cd fc 0f			call cmp16 
6c3c ca 45 6c			jp z, .chk_fault2 
6c3f 11 e0 6c			ld de, sfaultru 
6c42 c3 81 6c			jp .chk_fault 
6c45			.chk_fault2:  
6c45 2a df f8			ld hl, (chk_ret_ovr) 
6c48 ed 5b d2 f0		ld de,(chk_word) 
6c4c				if DEBUG_STK_FAULT 
6c4c					DMARK "FA1" 
6c4c					CALLMONITOR 
6c4c				endif 
6c4c cd fc 0f			call cmp16 
6c4f ca 58 6c			jp z, .chk_fault3 
6c52 11 ee 6c			ld de, sfaultro 
6c55 c3 81 6c			jp .chk_fault 
6c58			.chk_fault3:  
6c58 2a 5d f8			ld hl, (chk_loop_ovr) 
6c5b ed 5b d2 f0		ld de,(chk_word) 
6c5f				if DEBUG_STK_FAULT 
6c5f					DMARK "FA2" 
6c5f					CALLMONITOR 
6c5f				endif 
6c5f cd fc 0f			call cmp16 
6c62 ca 6b 6c			jp z, .chk_fault4 
6c65 11 08 6d			ld de, sfaultlo 
6c68 c3 81 6c			jp .chk_fault 
6c6b			.chk_fault4:  
6c6b 2a 5b f6			ld hl, (chk_data_ovr) 
6c6e ed 5b d2 f0		ld de,(chk_word) 
6c72				if DEBUG_STK_FAULT 
6c72					DMARK "FA3" 
6c72					CALLMONITOR 
6c72				endif 
6c72 cd fc 0f			call cmp16 
6c75 ca 7e 6c			jp z, .chk_fault5 
6c78 11 22 6d			ld de, sfaultdo 
6c7b c3 81 6c			jp .chk_fault 
6c7e			 
6c7e			 
6c7e			.chk_fault5:  
6c7e d1				pop de 
6c7f e1				pop hl 
6c80			 
6c80 c9				ret 
6c81			 
6c81 cd aa 0d		.chk_fault: 	call clear_display 
6c84 3e 28				ld a, display_row_2 
6c86 cd bd 0d				call str_at_display 
6c89 11 b2 6c				   ld de, .stackfault 
6c8c 3e 00				ld a, display_row_1 
6c8e cd bd 0d				call str_at_display 
6c91 11 a0 fd				    ld de, debug_mark 
6c94 3e 11				ld a, display_row_1+17 
6c96 cd bd 0d				call str_at_display 
6c99 cd cd 0d				call update_display 
6c9c			 
6c9c				; prompt before entering montior for investigating issue 
6c9c			 
6c9c 3e 78			ld a, display_row_4 
6c9e 11 24 1d			ld de, endprog 
6ca1			 
6ca1 cd cd 0d			call update_display		 
6ca4			 
6ca4 cd be 1f			call next_page_prompt 
6ca7			 
6ca7 d1				pop de 
6ca8 e1				pop hl 
6ca9 cd 78 1d				call monitor 
6cac cd dd 23				call forth_warmstart 
6caf c3 74 1c				jp warmstart_afterauto 
6cb2					;jp 0 
6cb2					;halt 
6cb2			 
6cb2			 
6cb2			 
6cb2 .. 00		.stackfault: 	db "Stack fault:",0 
6cbf			 
6cbf .. 00		sfaultsu: 	db	"Stack under flow",0 
6cd0 .. 00		sfaultso: 	db	"Stack over flow",0 
6ce0 .. 00		sfaultru:	db "RTS underflow",0 
6cee .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6d08 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6d22 .. 00		sfaultdo:	db "DTS overflow", 0 
6d2f			 
6d2f			 
6d2f			fault_dsp_under: 
6d2f 11 41 6d			ld de, .dsp_under 
6d32 c3 f7 6d			jp .show_fault 
6d35			 
6d35			fault_rsp_under: 
6d35 11 4f 6d			ld de, .rsp_under 
6d38 c3 f7 6d			jp .show_fault 
6d3b			fault_loop_under: 
6d3b 11 5d 6d			ld de, .loop_under 
6d3e c3 f7 6d			jp .show_fault 
6d41			 
6d41 .. 00		.dsp_under: db "DSP Underflow",0 
6d4f .. 00		.rsp_under: db "RSP Underflow",0 
6d5d .. 00		.loop_under: db "LOOP Underflow",0 
6d6c			 
6d6c			 
6d6c d5			type_faultn: 	push de 
6d6d e5					push hl 
6d6e cd aa 0d				call clear_display 
6d71 11 9b 6d				   ld de, .typefaultn 
6d74 3e 00				ld a, display_row_1 
6d76 cd bd 0d				call str_at_display 
6d79 11 a0 fd				    ld de, debug_mark 
6d7c 3e 11				ld a, display_row_1+17 
6d7e cd bd 0d				call str_at_display 
6d81 cd cd 0d				call update_display 
6d84			 
6d84				; prompt before entering montior for investigating issue 
6d84			 
6d84 3e 78			ld a, display_row_4 
6d86 11 24 1d			ld de, endprog 
6d89			 
6d89 cd cd 0d			call update_display		 
6d8c			 
6d8c cd be 1f			call next_page_prompt 
6d8f			 
6d8f e5					push hl 
6d90 d5					push de 
6d91 cd 78 1d				call monitor 
6d94 cd dd 23				call forth_warmstart 
6d97 c3 74 1c				jp warmstart_afterauto 
6d9a 76					halt 
6d9b			 
6d9b			 
6d9b .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6db2			 
6db2 d5			type_faults: 	push de 
6db3 e5					push hl 
6db4 cd aa 0d				call clear_display 
6db7 11 e0 6d				   ld de, .typefaults 
6dba 3e 00				ld a, display_row_1 
6dbc cd bd 0d				call str_at_display 
6dbf 11 a0 fd				    ld de, debug_mark 
6dc2 3e 11				ld a, display_row_1+17 
6dc4 cd bd 0d				call str_at_display 
6dc7 cd cd 0d				call update_display 
6dca			 
6dca				; prompt before entering montior for investigating issue 
6dca			 
6dca 3e 78			ld a, display_row_4 
6dcc 11 24 1d			ld de, endprog 
6dcf			 
6dcf cd cd 0d			call update_display		 
6dd2			 
6dd2 cd be 1f			call next_page_prompt 
6dd5			 
6dd5 e1					pop hl 
6dd6 d1					pop de 
6dd7 cd 78 1d				call monitor 
6dda cd dd 23				call forth_warmstart 
6ddd c3 74 1c				jp warmstart_afterauto 
6de0			 
6de0			 
6de0 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6df7			 
6df7			.show_fault: 	 
6df7 d5					push de 
6df8 cd aa 0d				call clear_display 
6dfb d1					pop de 
6dfc 3e 00				ld a, display_row_1 
6dfe cd bd 0d				call str_at_display 
6e01 11 a0 fd				    ld de, debug_mark 
6e04 3e 11				ld a, display_row_1+17 
6e06 cd bd 0d				call str_at_display 
6e09 cd cd 0d				call update_display 
6e0c			 
6e0c				; prompt before entering montior for investigating issue 
6e0c			 
6e0c 3e 78			ld a, display_row_4 
6e0e 11 24 1d			ld de, endprog 
6e11			 
6e11 cd cd 0d			call update_display		 
6e14			 
6e14 cd be 1f			call next_page_prompt 
6e17			 
6e17 e1					pop hl 
6e18 d1					pop de 
6e19 cd 78 1d				call monitor 
6e1c			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6e1c			; TODO Make optional fault restart to cli or warm boot? 
6e1c					;jp warmstart 
6e1c c3 b8 1c				jp cli 
6e1f 76					halt 
6e20			 
6e20			 
6e20			; handle the auto run of code from files in storage 
6e20			 
6e20			 
6e20			include "forth_startup.asm" 
6e20			; Which startup method to use? 
6e20			; 
6e20			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
6e20			; followed by loading of a list of scripts in eeprom 
6e20			 
6e20			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
6e20			; from eeprom 
6e20			 
6e20			; Select with define in main stubs 
6e20			 
6e20			if STARTUP_V1 
6e20				include "forth_startupv1.asm" 
6e20			endif 
6e20			if STARTUP_V2 
6e20				include "forth_startupv2.asm" 
6e20			; Version 2 of the startup  
6e20			;  
6e20			; Auto load any files in bank 1 that start with a '*' 
6e20			; If no se storage then revert to using eprom 
6e20			 
6e20			 
6e20			if STORAGE_SE = 0 
6e20			 
6e20			sprompt1: db "Startup load...",0 
6e20			sprompt2: db "Run? 1=No *=End #=All",0 
6e20			 
6e20			 
6e20			 
6e20			 
6e20			forth_startup: 
6e20				ld hl, startcmds 
6e20				ld a, 0 
6e20				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6e20			 
6e20			.start1:	push hl 
6e20				call clear_display 
6e20				ld de, sprompt1 
6e20			        ld a, display_row_1 
6e20				call str_at_display 
6e20				ld de, sprompt2 
6e20			        ld a, display_row_2 
6e20				call str_at_display 
6e20				pop hl 
6e20				push hl 
6e20				ld e,(hl) 
6e20				inc hl 
6e20				ld d,(hl) 
6e20			        ld a, display_row_3 
6e20				call str_at_display 
6e20				call update_display 
6e20			 
6e20			 
6e20				ld a, (os_last_cmd) 
6e20				cp 0 
6e20				jr z, .startprompt 
6e20				call delay250ms 
6e20				jr .startdo 
6e20				 
6e20				 
6e20			 
6e20			.startprompt: 
6e20			 
6e20				ld a,display_row_4 + display_cols - 1 
6e20			        ld de, endprg 
6e20				call str_at_display 
6e20				call update_display 
6e20				call delay1s 
6e20				call cin_wait 
6e20						 
6e20				cp '*' 
6e20				jr z, .startupend1 
6e20				cp '#' 
6e20				jr nz, .startno 
6e20				ld a, 1 
6e20				ld (os_last_cmd),a 
6e20				jr .startdo 
6e20			.startno:	cp '1' 
6e20				jr z,.startnxt  
6e20			 
6e20				; exec startup line 
6e20			.startdo:	 
6e20				pop hl 
6e20				push hl 
6e20				 
6e20				ld e,(hl) 
6e20				inc hl 
6e20				ld d,(hl) 
6e20				ex de,hl 
6e20			 
6e20				push hl 
6e20			 
6e20				ld a, 0 
6e20				;ld a, FORTH_END_BUFFER 
6e20				call strlent 
6e20				inc hl   ; include zero term to copy 
6e20				ld b,0 
6e20				ld c,l 
6e20				pop hl 
6e20				ld de, scratch 
6e20				ldir 
6e20			 
6e20			 
6e20				ld hl, scratch 
6e20				call forthparse 
6e20				call forthexec 
6e20				call forthexec_cleanup 
6e20			 
6e20				ld a, display_row_4 
6e20				ld de, endprog 
6e20			 
6e20				call update_display		 
6e20			 
6e20				ld a, (os_last_cmd) 
6e20				cp 0 
6e20				jr nz, .startnxt 
6e20				call next_page_prompt 
6e20			        call clear_display 
6e20				call update_display		 
6e20			 
6e20				; move onto next startup line? 
6e20			.startnxt: 
6e20			 
6e20				call delay250ms 
6e20				pop hl 
6e20			 
6e20				inc hl 
6e20				inc hl 
6e20			 
6e20				push hl 
6e20				ld e, (hl) 
6e20				inc hl 
6e20				ld d, (hl) 
6e20				pop hl 
6e20				; TODO replace 0 test 
6e20			 
6e20				ex de, hl 
6e20				call ishlzero 
6e20			;	ld a,e 
6e20			;	add d 
6e20			;	cp 0    ; any left to do? 
6e20				ex de, hl 
6e20				jp nz, .start1 
6e20				jr .startupend 
6e20			 
6e20			.startupend1: pop hl 
6e20			.startupend: 
6e20			 
6e20				call clear_display 
6e20				call update_display 
6e20				ret 
6e20			endif 
6e20			 
6e20			 
6e20			if STORAGE_SE 
6e20			 
6e20			;sprompt3: db "Loading from start-up file:",0 
6e20 .. 00		sprompt3: db "  Searching...",0 
6e2f			;sprompt4: db "(Any key to stop)",0 
6e2f			 
6e2f			 
6e2f			forth_autoload: 
6e2f			 
6e2f				; load block 0 of store 1 
6e2f				 
6e2f 3e fe			ld a, $fe      ; bit 0 clear 
6e31 32 95 f9			ld (spi_device), a 
6e34			 
6e34 cd 25 05			call storage_get_block_0 
6e37			 
6e37 3a d0 f9			ld a, (store_page+STORE_0_AUTOFILE) 
6e3a			 
6e3a fe 00			cp 0 
6e3c c8				ret z     ; auto start not enabled 
6e3d			 
6e3d cd aa 0d			call clear_display 
6e40			 
6e40				; set bank 
6e40			 
6e40 3a d2 f9				ld a, (store_page+STORE_0_BANKRUN) 
6e43 32 95 f9				ld (spi_device), a 
6e46			 
6e46			 
6e46				; generate a directory of bank 1 and search for flagged files 
6e46			 
6e46					if DEBUG_FORTH_WORDS_KEY 
6e46						DMARK "DIR" 
6e46 f5				push af  
6e47 3a 5b 6e			ld a, (.dmark)  
6e4a 32 a0 fd			ld (debug_mark),a  
6e4d 3a 5c 6e			ld a, (.dmark+1)  
6e50 32 a1 fd			ld (debug_mark+1),a  
6e53 3a 5d 6e			ld a, (.dmark+2)  
6e56 32 a2 fd			ld (debug_mark+2),a  
6e59 18 03			jr .pastdmark  
6e5b ..			.dmark: db "DIR"  
6e5e f1			.pastdmark: pop af  
6e5f			endm  
# End of macro DMARK
6e5f						CALLMONITOR 
6e5f cd aa fd			call debug_vector  
6e62				endm  
# End of macro CALLMONITOR
6e62					endif 
6e62			 
6e62 cd 25 05			call storage_get_block_0 
6e65			 
6e65 21 af f9			ld hl, store_page     ; get current id count 
6e68 46				ld b, (hl) 
6e69 0e 00			ld c, 0    ; count of files   
6e6b					if DEBUG_FORTH_WORDS 
6e6b						DMARK "DI1" 
6e6b f5				push af  
6e6c 3a 80 6e			ld a, (.dmark)  
6e6f 32 a0 fd			ld (debug_mark),a  
6e72 3a 81 6e			ld a, (.dmark+1)  
6e75 32 a1 fd			ld (debug_mark+1),a  
6e78 3a 82 6e			ld a, (.dmark+2)  
6e7b 32 a2 fd			ld (debug_mark+2),a  
6e7e 18 03			jr .pastdmark  
6e80 ..			.dmark: db "DI1"  
6e83 f1			.pastdmark: pop af  
6e84			endm  
# End of macro DMARK
6e84						CALLMONITOR 
6e84 cd aa fd			call debug_vector  
6e87				endm  
# End of macro CALLMONITOR
6e87					endif 
6e87			 
6e87				; check for empty drive 
6e87			 
6e87 3e 00			ld a, 0 
6e89 b8				cp b 
6e8a ca d7 6e			jp z, .dirdone 
6e8d			 
6e8d				; for each of the current ids do a search for them and if found push to stack 
6e8d			 
6e8d c5			.diritem:	push bc 
6e8e 21 40 00				ld hl, STORE_BLOCK_PHY 
6e91 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
6e93 58					ld e,b 
6e94			 
6e94 d5					push de 
6e95 e5					push hl 
6e96 cd aa 0d			call clear_display 
6e99 3e 32			ld a, display_row_2 + 10 
6e9b 11 20 6e			ld de, sprompt3 
6e9e cd bd 0d			call str_at_display 
6ea1 cd 01 0d			call active 
6ea4 eb				ex de, hl 
6ea5 3e 2f			ld a, display_row_2 + 7 
6ea7 cd bd 0d			call str_at_display 
6eaa cd cd 0d			call update_display 
6ead e1				pop hl 
6eae d1				pop de 
6eaf			 
6eaf			;		if DEBUG_FORTH_WORDS 
6eaf			;			DMARK "DI2" 
6eaf			;			CALLMONITOR 
6eaf			;		endif 
6eaf			 
6eaf cd a7 07				call storage_findnextid 
6eb2			 
6eb2			;		if DEBUG_FORTH_WORDS 
6eb2			;			DMARK "DI3" 
6eb2			;			CALLMONITOR 
6eb2			;		endif 
6eb2			 
6eb2					; if found hl will be non zero 
6eb2			 
6eb2 cd 07 10				call ishlzero 
6eb5			;		ld a, l 
6eb5			;		add h 
6eb5			; 
6eb5			;		cp 0 
6eb5 28 1d				jr z, .dirnotfound 
6eb7			 
6eb7					; increase count 
6eb7			 
6eb7 c1					pop bc	 
6eb8 0c					inc c 
6eb9 c5					push bc 
6eba					 
6eba			 
6eba					; get file header and push the file name 
6eba			 
6eba 11 af f9				ld de, store_page 
6ebd cd 74 04				call storage_read_block 
6ec0			 
6ec0					; push file id to stack 
6ec0				 
6ec0			 
6ec0					; is this a file we want to run? 
6ec0			 
6ec0 21 b2 f9				ld hl, store_page+3 
6ec3 7e					ld a,(hl) 
6ec4 fe 2a				cp '*' 
6ec6 20 0c				jr nz,  .dirnotfound 
6ec8					 
6ec8			 
6ec8			 
6ec8 3a af f9				ld a, (store_page) 
6ecb d5					push de 
6ecc e5					push hl 
6ecd c5					push bc 
6ece cd fa 6e				call .autorunf 
6ed1 c1					pop bc 
6ed2 e1					pop hl 
6ed3 d1					pop de 
6ed4			 
6ed4			 
6ed4			 
6ed4				; save this extent 
6ed4			 
6ed4					; push file name 
6ed4			;display file name to run 
6ed4			 
6ed4			;		ld hl, store_page+3 
6ed4			;		if DEBUG_FORTH_WORDS 
6ed4			;			DMARK "DI5" 
6ed4			;			CALLMONITOR 
6ed4			;		endif 
6ed4			; 
6ed4			;		 
6ed4			; 
6ed4			;		call forth_push_str 
6ed4			;		if DEBUG_FORTH_WORDS 
6ed4			;			DMARK "DI6" 
6ed4			;			CALLMONITOR 
6ed4			;		endif 
6ed4			.dirnotfound: 
6ed4 c1					pop bc     
6ed5 10 b6				djnz .diritem 
6ed7				 
6ed7			.dirdone:	 
6ed7					if DEBUG_FORTH_WORDS 
6ed7						DMARK "DI7" 
6ed7 f5				push af  
6ed8 3a ec 6e			ld a, (.dmark)  
6edb 32 a0 fd			ld (debug_mark),a  
6ede 3a ed 6e			ld a, (.dmark+1)  
6ee1 32 a1 fd			ld (debug_mark+1),a  
6ee4 3a ee 6e			ld a, (.dmark+2)  
6ee7 32 a2 fd			ld (debug_mark+2),a  
6eea 18 03			jr .pastdmark  
6eec ..			.dmark: db "DI7"  
6eef f1			.pastdmark: pop af  
6ef0			endm  
# End of macro DMARK
6ef0						CALLMONITOR 
6ef0 cd aa fd			call debug_vector  
6ef3				endm  
# End of macro CALLMONITOR
6ef3					endif 
6ef3			 
6ef3 cd aa 0d				call clear_display 
6ef6 cd cd 0d				call update_display 
6ef9			 
6ef9 c9					ret 
6efa			 
6efa			 
6efa			 
6efa			 
6efa			 
6efa			.autorunf: 
6efa			 
6efa			 
6efa				; get file id to load from and get the file name to display 
6efa			 
6efa			;		ld a, (store_page+STORE_0_FILERUN) 
6efa			 
6efa 2e 00				ld l, 0 
6efc 67					ld h, a 
6efd 11 af f9				ld de, store_page 
6f00			 
6f00					if DEBUG_FORTH_WORDS 
6f00						DMARK "ASp" 
6f00 f5				push af  
6f01 3a 15 6f			ld a, (.dmark)  
6f04 32 a0 fd			ld (debug_mark),a  
6f07 3a 16 6f			ld a, (.dmark+1)  
6f0a 32 a1 fd			ld (debug_mark+1),a  
6f0d 3a 17 6f			ld a, (.dmark+2)  
6f10 32 a2 fd			ld (debug_mark+2),a  
6f13 18 03			jr .pastdmark  
6f15 ..			.dmark: db "ASp"  
6f18 f1			.pastdmark: pop af  
6f19			endm  
# End of macro DMARK
6f19						CALLMONITOR 
6f19 cd aa fd			call debug_vector  
6f1c				endm  
# End of macro CALLMONITOR
6f1c					endif 
6f1c cd cd 09				call storage_read 
6f1f			 
6f1f					if DEBUG_FORTH_WORDS 
6f1f						DMARK "ASr" 
6f1f f5				push af  
6f20 3a 34 6f			ld a, (.dmark)  
6f23 32 a0 fd			ld (debug_mark),a  
6f26 3a 35 6f			ld a, (.dmark+1)  
6f29 32 a1 fd			ld (debug_mark+1),a  
6f2c 3a 36 6f			ld a, (.dmark+2)  
6f2f 32 a2 fd			ld (debug_mark+2),a  
6f32 18 03			jr .pastdmark  
6f34 ..			.dmark: db "ASr"  
6f37 f1			.pastdmark: pop af  
6f38			endm  
# End of macro DMARK
6f38						CALLMONITOR 
6f38 cd aa fd			call debug_vector  
6f3b				endm  
# End of macro CALLMONITOR
6f3b					endif 
6f3b			 
6f3b cd 07 10				call ishlzero 
6f3e c8					ret z             ; file not found 
6f3f			 
6f3f					; display file name we are loading 
6f3f			 
6f3f cd aa 0d				call clear_display 
6f42			 
6f42 3e 32				ld a, display_row_2 + 10 
6f44 11 b2 f9				ld de, store_page+3 
6f47 cd bd 0d				call str_at_display 
6f4a				 
6f4a			; 
6f4a			 
6f4a			;	ld a, display_row_1+5 
6f4a			;	ld de, sprompt3 
6f4a			;	call str_at_display 
6f4a			;	ld a, display_row_2+7 
6f4a			;	call active 
6f4a			;	ex de, hl 
6f4a			;;	ld de, sprompt4 
6f4a			;	call str_at_display 
6f4a			; 
6f4a cd cd 0d			call update_display 
6f4d			 
6f4d			;	call cin_wait 
6f4d			;	cp 'n' 
6f4d			;	ret z 
6f4d			;	cp 'N' 
6f4d			;	ret z 
6f4d			 
6f4d			;	call delay1s 
6f4d			 
6f4d 3a b1 f9			ld a, (store_page+2) 
6f50 32 9e f9			ld (store_openmaxext), a    ; save count of ext 
6f53 3e 01			ld a, 1  
6f55 32 9f f9			ld (store_openext), a    ; save count of ext 
6f58			 
6f58			.autof: 
6f58				; begin to read a line from file 
6f58			 
6f58 21 1d f4			ld hl, os_cli_cmd 
6f5b 22 1b f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
6f5e			  
6f5e			.readext: 
6f5e 3a 9f f9			ld a, (store_openext) 
6f61 6f				ld l , a 
6f62				 
6f62 3a af f9			ld a, (store_page) 
6f65 67				ld h, a	 
6f66 11 af f9			ld de, store_page 
6f69					if DEBUG_FORTH_WORDS 
6f69						DMARK "ASl" 
6f69 f5				push af  
6f6a 3a 7e 6f			ld a, (.dmark)  
6f6d 32 a0 fd			ld (debug_mark),a  
6f70 3a 7f 6f			ld a, (.dmark+1)  
6f73 32 a1 fd			ld (debug_mark+1),a  
6f76 3a 80 6f			ld a, (.dmark+2)  
6f79 32 a2 fd			ld (debug_mark+2),a  
6f7c 18 03			jr .pastdmark  
6f7e ..			.dmark: db "ASl"  
6f81 f1			.pastdmark: pop af  
6f82			endm  
# End of macro DMARK
6f82						CALLMONITOR 
6f82 cd aa fd			call debug_vector  
6f85				endm  
# End of macro CALLMONITOR
6f85					endif 
6f85 cd cd 09				call storage_read 
6f88 cd 07 10			call ishlzero 
6f8b c8				ret z 
6f8c			 
6f8c			; TODO copy to exec buffer 
6f8c			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
6f8c			 
6f8c				; copy the record buffer to the cli buffer 
6f8c			 
6f8c ed 5b 1b f6		ld de, (os_var_array) 
6f90 21 b1 f9			ld hl, store_page+2 
6f93			;	ex de, hl 
6f93 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
6f96 ed b0			ldir 
6f98 ed 53 1b f6		ld (os_var_array), de 
6f9c				 
6f9c 3a 9f f9			ld a, (store_openext) 
6f9f 3c				inc a 
6fa0 32 9f f9			ld (store_openext), a    ; save count of ext 
6fa3			 
6fa3			 
6fa3			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
6fa3				 
6fa3 3a a2 f9			ld a, (store_readcont) 
6fa6 fe 00			cp 0 
6fa8 20 b4			jr nz, .readext 
6faa			 
6faa			;	jr z, .autoend 
6faa			 
6faa					if DEBUG_FORTH_WORDS 
6faa						DMARK "ASc" 
6faa f5				push af  
6fab 3a bf 6f			ld a, (.dmark)  
6fae 32 a0 fd			ld (debug_mark),a  
6fb1 3a c0 6f			ld a, (.dmark+1)  
6fb4 32 a1 fd			ld (debug_mark+1),a  
6fb7 3a c1 6f			ld a, (.dmark+2)  
6fba 32 a2 fd			ld (debug_mark+2),a  
6fbd 18 03			jr .pastdmark  
6fbf ..			.dmark: db "ASc"  
6fc2 f1			.pastdmark: pop af  
6fc3			endm  
# End of macro DMARK
6fc3						CALLMONITOR 
6fc3 cd aa fd			call debug_vector  
6fc6				endm  
# End of macro CALLMONITOR
6fc6					endif 
6fc6 e5				push hl	 
6fc7 d5				push de 
6fc8 cd 01 0d			call active 
6fcb eb				ex de, hl 
6fcc 3e 2f			ld a, display_row_2 + 7 
6fce cd bd 0d			call str_at_display 
6fd1			 
6fd1 cd cd 0d			call update_display 
6fd4 d1				pop de  
6fd5 e1				pop hl 
6fd6			;	call delay250ms 
6fd6			 
6fd6			 
6fd6			 
6fd6			 
6fd6			.autoexec: 
6fd6			 
6fd6			 
6fd6 21 1d f4			ld hl, os_cli_cmd 
6fd9					if DEBUG_FORTH_WORDS 
6fd9						DMARK "ASx" 
6fd9 f5				push af  
6fda 3a ee 6f			ld a, (.dmark)  
6fdd 32 a0 fd			ld (debug_mark),a  
6fe0 3a ef 6f			ld a, (.dmark+1)  
6fe3 32 a1 fd			ld (debug_mark+1),a  
6fe6 3a f0 6f			ld a, (.dmark+2)  
6fe9 32 a2 fd			ld (debug_mark+2),a  
6fec 18 03			jr .pastdmark  
6fee ..			.dmark: db "ASx"  
6ff1 f1			.pastdmark: pop af  
6ff2			endm  
# End of macro DMARK
6ff2						CALLMONITOR 
6ff2 cd aa fd			call debug_vector  
6ff5				endm  
# End of macro CALLMONITOR
6ff5					endif 
6ff5 cd 85 24			call forthparse 
6ff8 cd c5 24			call forthexec 
6ffb cd d7 23			call forthexec_cleanup 
6ffe			 
6ffe			 
6ffe			 
6ffe c3 58 6f			jp .autof 
7001			;.autofdone: 
7001			; 
7001			;		if DEBUG_FORTH_WORDS 
7001			;			DMARK "ASx" 
7001			;			CALLMONITOR 
7001			;		endif 
7001			;;	call clear_display 
7001			;	ret 
7001			 
7001			 
7001			 
7001			endif 
# End of file forth_startupv2.asm
7001			endif 
7001			 
# End of file forth_startup.asm
7001			 
7001			; eof 
# End of file forth_kernel.asm
7001			;include "nascombasic.asm" 
7001			 
7001			 
7001			; find out where the code ends if loaded into RAM (for SC114) 
7001			;endofcode:  
7001			;	nop 
7001			 
7001			 
7001			; jump to nmi vector 
7001			 
7001			init_nmi: 
7001 3e c9			ld a, $c9   ; RET 
7003 32 ad fd			ld (nmi_vector), a 
7006 c9				ret 
7007			nmi: 
7007 e5				push hl 
7008 d5				push de 
7009 c5				push bc 
700a f5				push af 
700b cd ad fd			call nmi_vector 
700e f5				push af 
700f c5				push bc 
7010 d5				push de 
7011 e5				push hl 
7012 ed 4d			reti 
7014			 
7014			 
7014			; eof 
7014			 
# End of file main.asm
7014			include "firmware_lcd_4x40.asm" 
7014			; **********************************************************************  
7014			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
7014			; **********************************************************************  
7014			;  
7014			; **  Written as a Small Computer Monitor App  
7014			; **  www.scc.me.uk  
7014			;  
7014			; History  
7014			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
7014			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
7014			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
7014			;  
7014			; **********************************************************************  
7014			;  
7014			; This program is an example of one of the methods of interfacing an   
7014			; alphanumeric LCD module.   
7014			;  
7014			; In this example the display is connected to either a Z80 PIO or a   
7014			; simple 8-bit output port.   
7014			;  
7014			; This interfacing method uses 4-bit data mode and uses time delays  
7014			; rather than polling the display's ready status. As a result the   
7014			; interface only requires 6 simple output lines:  
7014			;   Output bit 0 = not used  
7014			;   Output bit 1 = not used  
7014			;   Output bit 2 = RS         High = data, Low = instruction  
7014			;   Output bit 3 = E          Active high  
7014			;   Output bit 4 = DB4  
7014			;   Output bit 5 = DB5  
7014			;   Output bit 6 = DB6  
7014			;   Output bit 7 = DB7  
7014			; Display's R/W is connected to 0v so it is always in write mode  
7014			;  
7014			; This set up should work with any system supporting the RC2014 bus  
7014			  
7014			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
7014			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
7014			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
7014			;  
7014			; **********************************************************************  
7014			  
7014			; Additonal for 4x40. E1 and E2 instead of just E   
7014			; TODO swipe vidout signal on port a to activate E2  
7014			  
7014			; **********************************************************************  
7014			; **  Constants  
7014			; **********************************************************************  
7014			; LCD constants required by LCD support module  
7014			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
7014			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
7014			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
7014			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
7014			; TODO Decide which E is being set  
7014			kLCDWidth:  EQU display_cols             ;Width in characters  
7014			  
7014			; **********************************************************************  
7014			; **  Code library usage  
7014			; **********************************************************************  
7014			  
7014			; send character to current cursor position  
7014			; wraps and/or scrolls screen automatically  
7014			  
7014			  
7014			  
7014			lcd_init:  
7014			  
7014			; SCMonAPI functions used  
7014			  
7014			; Alphanumeric LCD functions used  
7014			; no need to specify specific functions for this module  
7014			  
7014 3e cf		            LD   A, 11001111b  
7016 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7018 3e 00		            LD   A, 00000000b  
701a d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
701c			  
701c			; Initialise alphanumeric LCD module  
701c 3e 00				ld a, 0  
701e 32 00 fb				ld (display_lcde1e2), a  
7021 cd a2 70		            CALL fLCD_Init      ;Initialise LCD module  
7024 3e 01				ld a, 1  
7026 32 00 fb				ld (display_lcde1e2), a  
7029 cd a2 70		            CALL fLCD_Init      ;Initialise LCD module  
702c			  
702c c9				ret  
702d			  
702d			;  
702d			;;  
702d			; lcd functions  
702d			;  
702d			;  
702d			  
702d			; what is at cursor position   
702d			  
702d			;get_cursor:	ld de, (cursor_row)   ;  row + col  
702d			;		call curptr  
702d			;		ret  
702d			  
702d			  
702d			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
702d			  
702d			curptr:  
702d c5				push bc  
702e 21 e6 fc			ld hl, display_fb0  
7031			cpr:	  
7031				; loop for cursor whole row  
7031 0e 28			ld c, display_cols  
7033 23			cpr1:	inc hl  
7034 0d				dec c  
7035 20 fc			jr nz, cpr1  
7037 05				dec b  
7038 20 f7			jr nz, cpr  
703a			  
703a				; add col	  
703a			  
703a 23			cpr2:	inc hl  
703b 1d				dec e  
703c 20 fc			jr nz, cpr2  
703e			  
703e c1				pop bc  
703f c9				ret  
7040				  
7040			  
7040			  
7040			  
7040			  
7040			; write the frame buffer given in hl to hardware   
7040 22 fe fa		write_display: ld (display_write_tmp), hl 	   
7043 3e 00			ld a, kLCD_Line1  
7045 cd 4f 71		            CALL fLCD_Pos       ;Position cursor to location in A  
7048 06 28			ld b, display_cols  
704a ed 5b fe fa		ld de, (display_write_tmp)  
704e cd 9a 70			call write_len_string  
7051				  
7051				  
7051 2a fe fa			ld hl, (display_write_tmp)  
7054 11 28 00			ld de, display_cols  
7057 19				add hl,de  
7058 22 fe fa			ld (display_write_tmp),hl  
705b			  
705b				  
705b 3e 28			ld a, kLCD_Line2  
705d cd 4f 71		            CALL fLCD_Pos       ;Position cursor to location in A  
7060 06 28			ld b, display_cols  
7062 ed 5b fe fa		ld de, (display_write_tmp)  
7066 cd 9a 70			call write_len_string  
7069				  
7069 2a fe fa			ld hl, (display_write_tmp)  
706c 11 28 00			ld de, display_cols  
706f 19				add hl,de  
7070 22 fe fa			ld (display_write_tmp),hl  
7073			  
7073				  
7073 3e 50			ld a, kLCD_Line3  
7075 cd 4f 71		            CALL fLCD_Pos       ;Position cursor to location in A  
7078 06 28			ld b, display_cols  
707a ed 5b fe fa		ld de, (display_write_tmp)  
707e cd 9a 70			call write_len_string  
7081				  
7081 2a fe fa			ld hl, (display_write_tmp)  
7084 11 28 00			ld de, display_cols  
7087 19				add hl,de  
7088 22 fe fa			ld (display_write_tmp),hl  
708b			  
708b				  
708b 3e 78			ld a, kLCD_Line4  
708d cd 4f 71		            CALL fLCD_Pos       ;Position cursor to location in A  
7090 06 28			ld b, display_cols  
7092 ed 5b fe fa		ld de, (display_write_tmp)  
7096 cd 9a 70			call write_len_string  
7099 c9					ret  
709a				  
709a				; write out a fixed length string given in b from de  
709a			  
709a 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
709b cd 07 71		            CALL fLCD_Data      ;Write character to display  
709e 13				inc de  
709f 10 f9			djnz write_len_string  
70a1 c9				ret  
70a2			  
70a2			; Some other things to do  
70a2			;            LD   A, kLCD_Clear ;Display clear  
70a2			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
70a2			;            LD   A, kLCD_Under ;Display on with underscore cursor  
70a2			;            LD   A, kLCD_On     ;Display on with no cursor  
70a2			;            ;LD   A, kLCD_Off   ;Display off  
70a2			;            CALL fLCD_Inst      ;Send instruction to display  
70a2			;  
70a2			;  
70a2			;            halt  
70a2			;  
70a2			;  
70a2			;MsgHello:   DB  "Hello World!",0  
70a2			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
70a2			  
70a2			; Custom characters 5 pixels wide by 8 pixels high  
70a2			; Up to 8 custom characters can be defined  
70a2			;BitMaps:      
70a2			;; Character 0x00 = Battery icon  
70a2			;            DB  01110b  
70a2			;            DB  11011b  
70a2			;            DB  10001b  
70a2			;            DB  10001b  
70a2			;            DB  11111b  
70a2			;            DB  11111b  
70a2			;            DB  11111b  
70a2			;            DB  11111b  
70a2			;; Character 0x01 = Bluetooth icon  
70a2			;            DB  01100b  
70a2			;            DB  01010b  
70a2			;            DB  11100b  
70a2			;            DB  01000b  
70a2			;            DB  11100b  
70a2			;            DB  01010b  
70a2			;            DB  01100b  
70a2			;            DB  00000b  
70a2			;  
70a2			  
70a2			  
70a2			; **********************************************************************  
70a2			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
70a2			; **********************************************************************  
70a2			;  
70a2			; **  Written as a Small Computer Monitor App   
70a2			; **  Version 0.1 SCC 2018-05-16  
70a2			; **  www.scc.me.uk  
70a2			;  
70a2			; **********************************************************************  
70a2			;  
70a2			; This module provides support for alphanumeric LCD modules using with  
70a2			; *  HD44780 (or compatible) controller  
70a2			; *  5 x 7 pixel fonts  
70a2			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
70a2			; *  Interface via six digital outputs to the display (see below)  
70a2			;  
70a2			; LCD module pinout:  
70a2			;   1  Vss   0v supply  
70a2			;   2  Vdd   5v supply  
70a2			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
70a2			;   4  RS    High = data, Low = instruction  
70a2			;   5  R/W   High = Read, Low = Write  
70a2			;   6  E     Enable signal (active high)  
70a2			;   7  DB0   Data bit 0  
70a2			;   8  DB1   Data bit 1  
70a2			;   9  DB2   Data bit 2  
70a2			;  10  DB3   Data bit 3  
70a2			;  11  DB4   Data bit 4  
70a2			;  12  DB5   Data bit 5  
70a2			;  13  DB6   Data bit 6  
70a2			;  14  DB7   Data bit 7  
70a2			;  15  A     Backlight anode (+)  
70a2			;  16  K     Backlight cathode (-)  
70a2			;  
70a2			; This interfacing method uses 4-bit data mode and uses time delays  
70a2			; rather than polling the display's ready status. As a result the   
70a2			; interface only requires 6 simple output lines:  
70a2			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
70a2			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
70a2			;   LCD DB4 = Microcomputer output port bit 4  
70a2			;   LCD DB5 = Microcomputer output port bit 5  
70a2			;   LCD DB6 = Microcomputer output port bit 6  
70a2			;   LCD DB7 = Microcomputer output port bit 7  
70a2			; Display's R/W is connected to 0v so it is always in write mode  
70a2			; All 6 connections must be on the same port address <kLCDPrt>  
70a2			; This method also allows a decent length of cable from micro to LCD  
70a2			;  
70a2			; **********************************************************************  
70a2			;  
70a2			; To include the code for any given function provided by this module,   
70a2			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
70a2			; the parent source file.  
70a2			; For example:  #REQUIRES   uHexPrefix  
70a2			;  
70a2			; Also #INCLUDE this file at some point after the #REQUIRES statements  
70a2			; in the parent source file.  
70a2			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
70a2			;  
70a2			; These are the function names provided by this module:  
70a2			; fLCD_Init                     ;Initialise LCD  
70a2			; fLCD_Inst                     ;Send instruction to LCD  
70a2			; fLCD_Data                     ;Send data byte to LCD  
70a2			; fLCD_Pos                      ;Position cursor  
70a2			; fLCD_Str                      ;Display string  
70a2			; fLCD_Def                      ;Define custom character  
70a2			;  
70a2			; **********************************************************************  
70a2			;  
70a2			; Requires SCMonAPI.asm to also be included in the project  
70a2			;  
70a2			  
70a2			  
70a2			; **********************************************************************  
70a2			; **  Constants  
70a2			; **********************************************************************  
70a2			  
70a2			; Constants that must be defined externally  
70a2			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
70a2			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
70a2			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
70a2			;kLCDWidth: EQU 20             ;Width in characters  
70a2			  
70a2			; general line offsets in any frame buffer  
70a2			  
70a2			  
70a2			display_row_1: equ 0  
70a2			display_row_2: equ display_row_1+display_cols  
70a2			display_row_3: equ display_row_2 + display_cols  
70a2			display_row_4: equ display_row_3 + display_cols  
70a2			;display_row_4_eol:   
70a2			  
70a2			  
70a2			; Cursor position values for the start of each line  
70a2			  
70a2			; E  
70a2			kLCD_Line1: EQU 0x00   
70a2			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
70a2			; E1  
70a2			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
70a2			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
70a2			  
70a2			; Instructions to send as A register to fLCD_Inst  
70a2			kLCD_Clear: EQU 00000001b     ;LCD clear  
70a2			kLCD_Off:   EQU 00001000b     ;LCD off  
70a2			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
70a2			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
70a2			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
70a2			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
70a2			  
70a2			; Constants used by this code module  
70a2			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
70a2			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
70a2			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
70a2			  
70a2			  
70a2			  
70a2			; **********************************************************************  
70a2			; **  LCD support functions  
70a2			; **********************************************************************  
70a2			  
70a2			; Initialise alphanumeric LCD module  
70a2			; LCD control register codes:  
70a2			;   DL   0 = 4-bit mode        1 = 8-bit mode  
70a2			;   N    0 = 1-line mode       1 = 2-line mode  
70a2			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
70a2			;   D    0 = Display off       1 = Display on  
70a2			;   C    0 = Cursor off        1 = Cursor on  
70a2			;   B    0 = Blinking off      1 = Blinking on  
70a2			;   ID   0 = Decrement mode    1 = Increment mode  
70a2			;   SH   0 = Entire shift off  1 = Entire shift on  
70a2 3e 28		fLCD_Init:  LD   A, 40  
70a4 cd c9 71		            CALL LCDDelay       ;Delay 40ms after power up  
70a7			; For reliable reset set 8-bit mode - 3 times  
70a7 cd 99 71		            CALL WrFn8bit       ;Function = 8-bit mode  
70aa cd 99 71		            CALL WrFn8bit       ;Function = 8-bit mode  
70ad cd 99 71		            CALL WrFn8bit       ;Function = 8-bit mode  
70b0			; Set 4-bit mode  
70b0 cd 95 71		            CALL WrFn4bit       ;Function = 4-bit mode  
70b3 cd c7 71		            CALL LCDDelay1      ;Delay 37 us or more  
70b6			; Function set  
70b6 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
70b8 cd cb 70		            CALL fLCD_Inst      ;2 line, display on  
70bb			; Display On/Off control  
70bb 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
70bd cd cb 70		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
70c0			; Display Clear  
70c0 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
70c2 cd cb 70		            CALL fLCD_Inst      ;Clear display  
70c5			; Entry mode  
70c5 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
70c7 cd cb 70		            CALL fLCD_Inst      ;Increment mode, shift off  
70ca			; Display module now initialised  
70ca c9			            RET  
70cb			; ok to here  
70cb			  
70cb			; Write instruction to LCD  
70cb			;   On entry: A = Instruction byte to be written  
70cb			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
70cb f5			fLCD_Inst:  PUSH AF  
70cc f5			            PUSH AF  
70cd cd df 70		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
70d0 f1			            POP  AF  
70d1 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
70d2 17			            RLA  
70d3 17			            RLA  
70d4 17			            RLA  
70d5 cd df 70		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
70d8 3e 02		            LD   A, 2  
70da cd c9 71		            CALL LCDDelay       ;Delay 2 ms to complete   
70dd f1			            POP  AF  
70de c9			            RET  
70df			Wr4bits:   
70df f5					push af  
70e0 3a 00 fb				ld a, (display_lcde1e2)  
70e3 fe 00				cp 0     ; e  
70e5 20 10				jr nz, .wea2	  
70e7 f1					pop af  
70e8 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
70ea d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70ec cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
70ee cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
70f0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
70f2 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
70f4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70f6 c9			            RET  
70f7 f1			.wea2:		pop af  
70f8 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
70fa d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70fc cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
70fe cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7100 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7102 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7104 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7106 c9			            RET  
7107			  
7107			  
7107			; Write data to LCD  
7107			;   On entry: A = Data byte to be written  
7107			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7107 f5			fLCD_Data:  PUSH AF  
7108 f5			            PUSH AF  
7109 cd 1b 71		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
710c f1			            POP  AF  
710d 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
710e 17			            RLA  
710f 17			            RLA  
7110 17			            RLA  
7111 cd 1b 71		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7114 3e 96		            LD   A, 150  
7116 3d			Wait:      DEC  A              ;Wait a while to allow data   
7117 20 fd		            JR   NZ, Wait      ;  write to complete  
7119 f1			            POP  AF  
711a c9			            RET  
711b			Wr4bitsa:     
711b f5					push af  
711c 3a 00 fb				ld a, (display_lcde1e2)  
711f fe 00				cp 0     ; e1  
7121 20 16				jr nz, .we2	  
7123 f1					pop af  
7124 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7126 cb d7		            SET  kLCDBitRS, A  
7128 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
712a cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
712c cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
712e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7130 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7132 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7134 cb 97		            RES  kLCDBitRS, A  
7136 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7138 c9			            RET  
7139 f1			.we2:		pop af  
713a e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
713c cb d7		            SET  kLCDBitRS, A  
713e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7140 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7142 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
7144 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7146 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
7148 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
714a cb 97		            RES  kLCDBitRS, A  
714c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
714e c9			            RET  
714f			  
714f			  
714f			; Position cursor to specified location  
714f			;   On entry: A = Cursor position  
714f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
714f f5			fLCD_Pos:   PUSH AF  
7150					; at this point set the E1 or E2 flag depending on position  
7150			  
7150 c5					push bc  
7151			;		push af  
7151 06 00				ld b, 0  
7153 4f					ld c, a  
7154 3e 4f				ld a, kLCD_Line3-1  
7156 b7			 		or a      ;clear carry flag  
7157 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
7158 38 04				jr c, .pe1  
715a			  
715a					; E selection  
715a cb 80				res 0, b         ; bit 0 unset e  
715c			;		pop af    ; before line 3 so recover orig pos  
715c			;		ld c, a    ; save for poking back  
715c 18 06				jr .peset	          
715e			.pe1:          	; E2 selection  
715e cb c0				set 0, b         ; bit 0 set e1  
7160 79					ld a, c  
7161 de 4f				sbc a, kLCD_Line3-1  
7163 4f					ld c, a	         ; save caculated offset  
7164			;		pop af     ; bin this original value now we have calculated form  
7164			  
7164			.peset:		; set bit  
7164 78					ld a, b  
7165 32 00 fb				ld (display_lcde1e2), a 	  
7168 79					ld a, c  
7169 c1					pop bc  
716a			  
716a f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
716c cd cb 70		            CALL fLCD_Inst      ;Write instruction to LCD  
716f f1			            POP  AF  
7170 c9			            RET  
7171			  
7171			  
7171			; Output text string to LCD  
7171			;   On entry: DE = Pointer to null terminated text string  
7171			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7171 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7172 b7			            OR   A              ;Null terminator?  
7173 c8			            RET  Z              ;Yes, so finished  
7174 cd 07 71		            CALL fLCD_Data      ;Write character to display  
7177 13			            INC  DE             ;Point to next character  
7178 18 f7		            JR   fLCD_Str       ;Repeat  
717a c9					ret  
717b			  
717b			; Define custom character  
717b			;   On entry: A = Character number (0 to 7)  
717b			;             DE = Pointer to character bitmap data  
717b			;   On exit:  A = Next character number  
717b			;             DE = Next location following bitmap  
717b			;             BC HL IX IY I AF' BC' DE' HL' preserved  
717b			; Character is   
717b c5			fLCD_Def:   PUSH BC  
717c f5			            PUSH AF  
717d 07			            RLCA                ;Calculate location  
717e 07			            RLCA                ;  for bitmap data  
717f 07			            RLCA                ;  = 8 x CharacterNumber  
7180 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7182 cd cb 70		            CALL fLCD_Inst      ;Write instruction to LCD  
7185 06 00		            LD   B, 0  
7187 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
7188 cd 07 71		            CALL fLCD_Data      ;Write byte to display  
718b 13			            INC  DE             ;Point to next byte  
718c 04			            INC  B              ;Count bytes  
718d cb 58		            BIT  3, B           ;Finish all 8 bytes?  
718f 28 f6		            JR   Z, Loop       ;No, so repeat  
7191 f1			            POP  AF  
7192 3c			            INC  A              ;Increment character number  
7193 c1			            POP  BC  
7194 c9			            RET  
7195			  
7195			  
7195			; **********************************************************************  
7195			; **  Private functions  
7195			; **********************************************************************  
7195			  
7195			; Write function to LCD  
7195			;   On entry: A = Function byte to be written  
7195			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7195 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7197 18 02		            JR   WrFunc  
7199 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
719b f5			WrFunc:     PUSH AF  
719c f5					push af  
719d 3a 00 fb				ld a, (display_lcde1e2)  
71a0 fe 00				cp 0     ; e1  
71a2 20 0f				jr nz, .wfea2	  
71a4 f1					pop af  
71a5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
71a7 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
71a9 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
71ab d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
71ad cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
71af d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
71b1 18 0d			jr .wfskip  
71b3 f1			.wfea2:		pop af  
71b4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
71b6 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
71b8 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
71ba d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
71bc cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
71be d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
71c0 3e 05		.wfskip:            LD  A, 5  
71c2 cd c9 71		            CALL LCDDelay       ;Delay 5 ms to complete  
71c5 f1			            POP  AF  
71c6 c9			            RET  
71c7			  
71c7			  
71c7			; Delay in milliseconds  
71c7			;   On entry: A = Number of milliseconds delay  
71c7			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
71c7 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
71c9 d5			LCDDelay:   PUSH DE  
71ca 5f			            LD   E, A           ;Delay by 'A' ms  
71cb 16 00		            LD   D, 0  
71cd cd d2 0c		            CALL aDelayInMS  
71d0 d1			            POP  DE  
71d1 c9			            RET  
71d2			  
71d2			  
71d2			testlcd:  
71d2 3e 00			ld a, kLCD_Line1  
71d4 cd 4f 71			call fLCD_Pos  
71d7 06 28			ld b, 40  
71d9 11 07 72			ld de, .ttext1  
71dc cd 9a 70			call write_len_string  
71df			  
71df 3e 28			ld a, kLCD_Line2  
71e1 cd 4f 71			call fLCD_Pos  
71e4 06 28			ld b, 40  
71e6 11 30 72			ld de, .ttext2  
71e9 cd 9a 70			call write_len_string  
71ec 3e 50			ld a, kLCD_Line3  
71ee cd 4f 71			call fLCD_Pos  
71f1 06 28			ld b, 40  
71f3 11 59 72			ld de, .ttext3  
71f6 cd 9a 70			call write_len_string  
71f9 3e 78			ld a, kLCD_Line4  
71fb cd 4f 71			call fLCD_Pos  
71fe 06 28			ld b, 40  
7200 11 82 72			ld de, .ttext4  
7203 cd 9a 70			call write_len_string  
7206			  
7206 76				halt  
7207			  
7207			  
7207 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7230 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
7259 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7282 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
72ab			   
72ab			  
72ab			  
72ab			; eof  
72ab			  
# End of file firmware_lcd_4x40.asm
72ab			;include "firmware_lcd_4x20.asm" 
72ab			include "firmware_key_5x10.asm" 
72ab			; 5 x 10 decade counter scanner  
72ab			  
72ab			  
72ab			; TODO do cursor shape change for shift keys  
72ab			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
72ab			  
72ab			  
72ab			; bit mask for each scan column and row for teing the matrix  
72ab			  
72ab			  
72ab			key_init:  
72ab			  
72ab			; SCMonAPI functions used  
72ab			  
72ab			; Alphanumeric LCD functions used  
72ab			; no need to specify specific functions for this module  
72ab			  
72ab			  
72ab 3e cf		            LD   A, 11001111b  
72ad d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
72af			;            LD   A, 00000000b  
72af 3e 1f		            LD   A, 00011111b  
72b1 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
72b3			  
72b3			  
72b3				; TODO Configure cursor shapes  
72b3			  
72b3				; Load cursor shapes   
72b3 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
72b5 11 c5 72		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
72b8 06 02		            LD   B, 2           ;Number of characters to define  
72ba cd 7b 71		.DefLoop:   CALL fLCD_Def       ;Define custom character  
72bd 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
72bf			  
72bf 3e 01				ld a, 1  
72c1 32 f6 fa			ld (cursor_shape),a  
72c4 c9				ret  
72c5			  
72c5			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
72c5			; Up to 8 custom characters can be defined  
72c5			.cursor_shapes:      
72c5			;; Character 0x00 = Normal  
72c5 1f			            DB  11111b  
72c6 1f			            DB  11111b  
72c7 1f			            DB  11111b  
72c8 1f			            DB  11111b  
72c9 1f			            DB  11111b  
72ca 1f			            DB  11111b  
72cb 1f			            DB  11111b  
72cc 1f			            DB  11111b  
72cd			;; Character 0x01 = Modifier  
72cd 1f			            DB  11111b  
72ce 1b			            DB  11011b  
72cf 1b			            DB  11011b  
72d0 1b			            DB  11011b  
72d1 1b			            DB  11011b  
72d2 1f			            DB  11111b  
72d3 1b			            DB  11011b  
72d4 1f			            DB  11111b  
72d5			  
72d5			  
72d5			  
72d5			  
72d5			; Display custom character 0  
72d5			;            LD   A, kLCD_Line1+14  
72d5			;            CALL fLCD_Pos       ;Position cursor to location in A  
72d5			;            LD   A, 0  
72d5			;            CALL fLCD_Data      ;Write character in A at cursor  
72d5			  
72d5			; Display custom character 1  
72d5			;            LD   A, kLCD_Line2+14  
72d5			;            CALL fLCD_Pos      ;Position cursor to location in A  
72d5			;            LD   A, 1  
72d5			;            CALL fLCD_Data     ;Write character in A at cursor  
72d5			  
72d5			; keyboard scanning   
72d5			  
72d5			; character in from keyboard  
72d5			  
72d5			; mapping for the pcb layout  
72d5			  
72d5			.matrix_to_char:  
72d5 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
72e0 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
72eb 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
72f6 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7301 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
730c			.matrix_to_shift:  
730c			  
730c .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7317 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7322 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
732d 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7338 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7343			  
7343			.matrix_to_symbolshift:  
7343			  
7343 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
734e .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7359 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
7364			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
7364 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
736f .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
737a			  
737a			  
737a			  
737a			; mapping for a simple straight through breadboard layout  
737a			  
737a			;.matrix_to_char:  
737a			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
737a			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
737a			;		db "asdfghjkl",KEY_CR,0  
737a			;		db "qwertyuiop",0  
737a			;		 db "1234567890",0  
737a			;.matrix_to_shift:  
737a			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
737a			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
737a			;		db "ASDFGHJKL",KEY_CR,0  
737a			;		db "QWERTYUIOP",0  
737a			;		 db "!",'"',"#$%^&*()",0  
737a			;.matrix_to_symbolshift:  
737a			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
737a			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
737a			;		db "_?*fghjk=",KEY_CR,0  
737a			;		db "-/+*[]{}@#",0  
737a			;		 db "1234567890",0  
737a			  
737a			;.matrix_to_char: db "D#0*C987B654A321"  
737a			  
737a			  
737a				  
737a			  
737a			; add cin and cin_wait  
737a			  
737a cd 8b 73		cin_wait: 	call cin  
737d						if DEBUG_KEYCINWAIT  
737d							push af  
737d							  
737d							ld hl,key_repeat_ct  
737d							ld (hl),a  
737d							inc hl  
737d							call hexout  
737d							ld hl,key_repeat_ct+3  
737d							ld a,0  
737d							ld (hl),a  
737d			  
737d							    LD   A, kLCD_Line1+11  
737d							    CALL fLCD_Pos       ;Position cursor to location in A  
737d							    LD   DE, key_repeat_ct  
737d							    ;LD   DE, MsgHello  
737d							    CALL fLCD_Str       ;Display string pointed to by DE  
737d			  
737d			  
737d			  
737d							pop af  
737d						endif  
737d fe 00			cp 0  
737f 28 f9			jr z, cin_wait   ; block until key press  
7381			  
7381							if DEBUG_KEYCINWAIT  
7381								push af  
7381			  
7381								ld a, 'A'	  
7381								ld hl,key_repeat_ct  
7381								ld (hl),a  
7381								inc hl  
7381								ld a,0  
7381								ld (hl),a  
7381			  
7381								    LD   A, kLCD_Line2+11  
7381								    CALL fLCD_Pos       ;Position cursor to location in A  
7381								    LD   DE, key_repeat_ct  
7381								    ;LD   DE, MsgHello  
7381								    CALL fLCD_Str       ;Display string pointed to by DE  
7381			  
7381							call delay500ms  
7381			  
7381								pop af  
7381							endif  
7381 f5				push af   ; save key pressed  
7382			  
7382			.cin_wait1:	  
7382							if DEBUG_KEYCINWAIT  
7382								push af  
7382			  
7382								ld a, 'b'	  
7382								ld hl,key_repeat_ct  
7382								ld (hl),a  
7382								inc hl  
7382								ld a,0  
7382								ld (hl),a  
7382			  
7382								    LD   A, kLCD_Line2+11  
7382								    CALL fLCD_Pos       ;Position cursor to location in A  
7382								    LD   DE, key_repeat_ct  
7382								    ;LD   DE, MsgHello  
7382								    CALL fLCD_Str       ;Display string pointed to by DE  
7382			  
7382			  
7382							call delay500ms  
7382			  
7382								pop af  
7382							endif  
7382			  
7382 cd 8b 73		call cin  
7385 fe 00			cp 0  
7387 20 f9			jr nz, .cin_wait1  	; wait for key release  
7389			if DEBUG_KEYCINWAIT  
7389				push af  
7389			  
7389				ld a, '3'	  
7389				ld hl,key_repeat_ct  
7389				ld (hl),a  
7389				inc hl  
7389				ld a,0  
7389				ld (hl),a  
7389			  
7389			            LD   A, kLCD_Line2+11  
7389			            CALL fLCD_Pos       ;Position cursor to location in A  
7389			            LD   DE, key_repeat_ct  
7389			            ;LD   DE, MsgHello  
7389			            CALL fLCD_Str       ;Display string pointed to by DE  
7389			  
7389			  
7389			call delay500ms  
7389			  
7389				pop af  
7389			endif  
7389			  
7389 f1				pop af   ; get key  
738a c9				ret  
738b			  
738b			  
738b cd 9f 73		cin: 	call .mtoc  
738e			  
738e			if DEBUG_KEYCIN  
738e				push af  
738e				  
738e				ld hl,key_repeat_ct  
738e				ld (hl),a  
738e				inc hl  
738e				call hexout  
738e				ld hl,key_repeat_ct+3  
738e				ld a,0  
738e				ld (hl),a  
738e			  
738e			            LD   A, kLCD_Line3+15  
738e			            CALL fLCD_Pos       ;Position cursor to location in A  
738e			            LD   DE, key_repeat_ct  
738e			            ;LD   DE, MsgHello  
738e			            CALL fLCD_Str       ;Display string pointed to by DE  
738e			  
738e			  
738e			call delay500ms  
738e			  
738e				pop af  
738e			endif  
738e			  
738e			  
738e				; no key held  
738e fe 00			cp 0  
7390 c8				ret z  
7391			  
7391			if DEBUG_KEYCIN  
7391				push af  
7391			  
7391				ld a, '1'	  
7391				ld hl,key_repeat_ct  
7391				ld (hl),a  
7391				inc hl  
7391				ld a,0  
7391				ld (hl),a  
7391			  
7391			            LD   A, kLCD_Line4+15  
7391			            CALL fLCD_Pos       ;Position cursor to location in A  
7391			            LD   DE, key_repeat_ct  
7391			            ;LD   DE, MsgHello  
7391			            CALL fLCD_Str       ;Display string pointed to by DE  
7391			  
7391			  
7391			call delay500ms  
7391			  
7391				pop af  
7391			endif  
7391			  
7391				; stop key bounce  
7391			  
7391 32 c6 fd			ld (key_held),a		 ; save it  
7394 47				ld b, a  
7395			  
7395 c5			.cina1:	push bc  
7396			if DEBUG_KEYCIN  
7396				push af  
7396			  
7396				ld hl,key_repeat_ct  
7396				inc hl  
7396				call hexout  
7396				ld hl,key_repeat_ct+3  
7396				ld a,0  
7396				ld (hl),a  
7396				ld hl,key_repeat_ct  
7396				ld a, '2'	  
7396				ld (hl),a  
7396			  
7396			            LD   A, kLCD_Line4+15  
7396			            CALL fLCD_Pos       ;Position cursor to location in A  
7396			            LD   DE, key_repeat_ct  
7396			            ;LD   DE, MsgHello  
7396			            CALL fLCD_Str       ;Display string pointed to by DE  
7396			  
7396				pop af  
7396			endif  
7396 cd 9f 73			call .mtoc  
7399 c1				pop bc  
739a b8				cp b  
739b 28 f8			jr z, .cina1  
739d 78				ld a,b		  
739e			if DEBUG_KEYCIN  
739e				push af  
739e			  
739e				ld hl,key_repeat_ct  
739e				inc hl  
739e				call hexout  
739e				ld hl,key_repeat_ct+3  
739e				ld a,0  
739e				ld (hl),a  
739e				ld hl,key_repeat_ct  
739e				ld a, '3'	  
739e				ld (hl),a  
739e			  
739e			            LD   A, kLCD_Line4+15  
739e			            CALL fLCD_Pos       ;Position cursor to location in A  
739e			            LD   DE, key_repeat_ct  
739e			            ;LD   DE, MsgHello  
739e			            CALL fLCD_Str       ;Display string pointed to by DE  
739e			  
739e				pop af  
739e			endif  
739e c9				ret  
739f			  
739f			; detect keyboard modifier key press and apply new overlay to the face key held  
739f			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
739f			  
739f			;.cin_map_modifier:   
739f			;	ld a, (hl)  
739f			;	and 255  
739f			;	ret NZ		; modifier key not flagged  
739f			;  
739f			;	; get key face  
739f			;  
739f			;	ld b,(key_face_held)  
739f			;  
739f			;	ld b, key_cols * key_rows  
739f			;  
739f			;	push de  
739f			;	pop hl  
739f			;  
739f			;.mmod1: ld a,(hl)   ; get map test  
739f			;	cp b  
739f			;	jr z, .mmod2  
739f			;  
739f			;  
739f			;  
739f			;.mmod2: inc hl    ;   
739f			;  
739f			;	  
739f			;  
739f			;	  
739f			;  
739f			;	ld hl,key_actual_pressed  
739f			;	ld (hl),a,  
739f			;	ret  
739f			  
739f			; map matrix key held to char on face of key  
739f			  
739f			.mtoc:  
739f			  
739f			; test decade counter strobes  
739f			  
739f			;.decadetest1:  
739f			  
739f			; reset counter  
739f			;ld a, 128  
739f			;out (portbdata),a  
739f			  
739f			  
739f			;ld b, 5  
739f			;.dec1:  
739f			;ld a, 0  
739f			;out (portbdata),a  
739f			;call delay1s  
739f			  
739f			;ld a, 32  
739f			;out (portbdata),a  
739f			;call delay1s  
739f			;call delay1s  
739f			;call delay1s  
739f			;  
739f			;ld a, 64+32  
739f			;out (portbdata),a  
739f			;call delay1s  
739f			;;djnz .dec1  
739f			;  
739f			;jp .decadetest1  
739f			  
739f			  
739f			  
739f			  
739f			  
739f			  
739f			  
739f			  
739f			  
739f			  
739f				; scan keyboard matrix and generate raw scan map  
739f cd 32 74			call matrix  
73a2			  
73a2				; reuse c bit 0 left modifer button - ie shift  
73a2			        ; reuse c bit 1 for right modifer button - ie symbol shift  
73a2				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
73a2			  
73a2 0e 00			ld c, 0  
73a4			  
73a4				; TODO set flags for modifer key presses   
73a4				; TODO do a search for modifer key...  
73a4			  
73a4				;ld hl,keyscan_table_row4  
73a4 21 25 fe			ld hl,keyscan_table_row2  
73a7			  
73a7 7e				ld a, (hl)  
73a8 fe 23			cp '#'  
73aa 20 07			jr nz, .nextmodcheck  
73ac cb c1			set 0, c  
73ae 21 0c 73			ld hl, .matrix_to_shift  
73b1 18 21			jr .dokeymap  
73b3				; TODO for now igonre  
73b3			.nextmodcheck:  
73b3 21 1a fe			ld hl,keyscan_table_row3  
73b6			  
73b6 7e				ld a, (hl)  
73b7 fe 23			cp '#'  
73b9 20 07			jr nz, .nextmodcheck2  
73bb cb c9			set 1, c   
73bd 21 43 73			ld hl, .matrix_to_symbolshift  
73c0 18 12			jr .dokeymap  
73c2			.nextmodcheck2:  
73c2 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
73c5			  
73c5 7e				ld a, (hl)  
73c6 fe 23			cp '#'  
73c8 20 07			jr nz, .donemodcheck  
73ca cb c9			set 1, c   
73cc 21 0c 73			ld hl, .matrix_to_shift  
73cf 18 03			jr .dokeymap  
73d1			  
73d1				; no modifer found so just map to normal keys  
73d1				; get mtoc map matrix to respective keys  
73d1			;	ld hl, .matrix_to_char  
73d1			;	ld hl, .matrix_to_char  
73d1			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
73d1			;	ld a, KEY_SHIFT  
73d1			;	call findchar  
73d1			;  
73d1			;	; got offset to key modifer in b  
73d1			;  
73d1			;	ld hl,keyscan_table_row5  
73d1			;  
73d1			;	ld a,b  
73d1			;	call addatohl  
73d1			;	ld a,(hl)  
73d1			;  
73d1			;	cp '#'  
73d1			;	jr nz, .nextmodcheck  
73d1			;	set 0, c  
73d1			;	ld hl, .matrix_to_char  
73d1			;	jr .dokeymap  
73d1			;	; TODO for now igonre  
73d1			;.nextmodcheck:  
73d1			;	ld hl, .matrix_to_symbolshift  
73d1			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
73d1			;	ld a, KEY_SYMBOLSHIFT  
73d1			;	call findchar  
73d1			;  
73d1			;  
73d1			;	; got offset to key modifer in b  
73d1			;  
73d1			;	ld hl,keyscan_table_row5  
73d1			;  
73d1			;	ld a,b  
73d1			;	call addatohl  
73d1			;	ld a,(hl)  
73d1			;  
73d1			;	cp '#'  
73d1			;	jr nz, .donemodcheck  
73d1			;	set 1, c   
73d1			;	ld hl, .matrix_to_symbolshift  
73d1			;	jr .dokeymap  
73d1			  
73d1			  
73d1			  
73d1			.donemodcheck:  
73d1				; no modifer found so just map to normal keys  
73d1				; get mtoc map matrix to respective keys  
73d1 21 d5 72			ld hl, .matrix_to_char  
73d4			  
73d4			.dokeymap:  
73d4				;ld (key_fa), c   
73d4 cd ed 73			call .mapkeys  
73d7			  
73d7			  
73d7			if DEBUG_KEY  
73d7			  
73d7			; Display text on first line  
73d7			            LD   A, kLCD_Line1  
73d7			            CALL fLCD_Pos       ;Position cursor to location in A  
73d7			            LD   DE, keyscan_table_row1  
73d7			            ;LD   DE, MsgHello  
73d7			            CALL fLCD_Str       ;Display string pointed to by DE  
73d7			  
73d7			; Display text on second line  
73d7			            LD   A, kLCD_Line2  
73d7			            CALL fLCD_Pos       ;Position cursor to location in A  
73d7			            LD   DE, keyscan_table_row2  
73d7			            CALL fLCD_Str       ;Display string pointed to by DE  
73d7			            LD   A, kLCD_Line3  
73d7			            CALL fLCD_Pos       ;Position cursor to location in A  
73d7			            LD   DE, keyscan_table_row3  
73d7			            CALL fLCD_Str       ;Display string pointed to by DE  
73d7			            LD   A, kLCD_Line4  
73d7			            CALL fLCD_Pos       ;Position cursor to location in A  
73d7			            LD   DE, keyscan_table_row4  
73d7			            CALL fLCD_Str       ;Display string pointed to by DE  
73d7			            LD   A, kLCD_Line1+10  
73d7			            CALL fLCD_Pos       ;Position cursor to location in A  
73d7			            LD   DE, keyscan_table_row5  
73d7			            CALL fLCD_Str       ;Display string pointed to by DE  
73d7			  
73d7				;call delay250ms  
73d7			endif  
73d7			;	jp testkey  
73d7			  
73d7			; get first char reported  
73d7			  
73d7 21 04 fe			ld hl,keyscan_table_row5  
73da			  
73da				;ld b, 46   ; 30 keys to remap + 8 nulls   
73da 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
73dc			.findkey:  
73dc 7e				ld a,(hl)  
73dd fe 00			cp 0  
73df 28 04			jr z, .nextkey  
73e1 fe 7e			cp KEY_MATRIX_NO_PRESS  
73e3 20 06			jr nz, .foundkey  
73e5			.nextkey:  
73e5 23				inc hl  
73e6 10 f4			djnz .findkey  
73e8 3e 00			ld a,0  
73ea c9				ret  
73eb			.foundkey:  
73eb 7e				ld a,(hl)  
73ec c9				ret  
73ed				  
73ed			  
73ed			; convert the raw key map given hl for destination key  
73ed			.mapkeys:  
73ed 11 04 fe			ld de,keyscan_table_row5  
73f0			  
73f0 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
73f2			.remap:  
73f2 1a				ld a,(de)  
73f3 fe 23			cp '#'  
73f5 20 02			jr nz, .remapnext  
73f7				;CALLMONITOR  
73f7 7e				ld a,(hl)  
73f8 12				ld (de),a  
73f9			  
73f9			  
73f9			  
73f9			.remapnext:  
73f9 23				inc hl  
73fa 13				inc de  
73fb 10 f5			djnz .remap  
73fd				  
73fd c9				ret  
73fe			  
73fe			  
73fe			  
73fe			.mtocold2:  
73fe			  
73fe			;	; flag if key D is held down and remove from reporting  
73fe			;	ld bc, .key_map_fd    
73fe			;	ld hl, keyscan_table  
73fe			;	ld de, key_fd  
73fe			;	call .key_shift_hold  
73fe			;	cp 255  
73fe			;	jr z, .cinmap  
73fe			;	; flag if key C is held down and remove from reporting  
73fe			;	ld bc, .key_map_fc    
73fe			;	ld hl, keyscan_table+key_cols  
73fe			;	ld de, key_fc  
73fe			;	call .key_shift_hold  
73fe			;	cp 255  
73fe			;	jr z, .cinmap  
73fe			;	; flag if key B is held down and remove from reporting  
73fe			;	ld bc, .key_map_fb    
73fe			;	ld hl, keyscan_table+(key_cols*2)  
73fe			;	ld de, key_fb  
73fe			;	call .key_shift_hold  
73fe			;	cp 255  
73fe			;	jr z, .cinmap  
73fe			;	; flag if key A is held down and remove from reporting  
73fe			;	ld bc, .key_map_fa    
73fe			;	ld hl, keyscan_table+(key_cols*3)  
73fe			;	ld de, key_fa  
73fe			;	call .key_shift_hold  
73fe			;	cp 255  
73fe			;	jr z, .cinmap  
73fe			  
73fe 11 d5 72			ld de, .matrix_to_char  
7401			  
7401			  
7401			.cinmap1:   
7401				if DEBUG_KEY  
7401			            LD   A, kLCD_Line4  
7401			            CALL fLCD_Pos       ;Position cursor to location in A  
7401					push de  
7401			            LD   DE, keyscan_table  
7401			            CALL fLCD_Str       ;Display string pointed to by DE  
7401					pop de  
7401				endif  
7401			  
7401				; scan key matrix table for any held key  
7401			  
7401				; de holds either the default matrix or one selected above  
7401			  
7401 21 d1 fd			ld hl, keyscan_table  
7404 06 32			ld b,key_cols*key_rows  
7406			  
7406 7e			.cin11:	ld a,(hl)  
7407 fe 23			cp '#'  
7409 28 08			jr z, .cinhit1  
740b 23				inc hl  
740c 13				inc de  
740d 05				dec b  
740e 20 f6			jr nz, .cin11  
7410				; no key found held  
7410 3e 00			ld a,0  
7412 c9				ret  
7413 d5			.cinhit1: push de  
7414 e1				pop hl  
7415 7e				ld a,(hl)  
7416 c9				ret  
7417			  
7417			; flag a control key is held   
7417			; hl is key pin, de is flag indicator  
7417			  
7417			.key_shift_hold1:  
7417 c5				push bc  
7418 3e 01			ld a, 1  
741a 32 f6 fa			ld (cursor_shape),a  
741d 06 00			ld b, 0  
741f 7e				ld a, (hl)  
7420 fe 2e			cp '.'  
7422 28 0a			jr z, .key_shift11  
7424 06 ff			ld b, 255  
7426 3e 2b			ld a, '+'    ; hide key from later scans  
7428 77				ld (hl),a  
7429 3e 02			ld a, 2  
742b 32 f6 fa			ld (cursor_shape),a  
742e			.key_shift11:  
742e				; write flag indicator  
742e 78				ld a,b  
742f 12				ld (de),a  
7430			  
7430 d1				pop de    ; de now holds the key map ptr  
7431 c9				ret  
7432			  
7432				  
7432			  
7432			; scans keyboard matrix and flags key press in memory array	  
7432				  
7432			matrix:  
7432				;call matrix  
7432				; TODO optimise the code....  
7432			  
7432			  
7432			;ld hl, keyscan_table_row1  
7432			;ld de, keyscan_table_row1+1  
7432			;ld bc,46  
7432			;ld a,KEY_MATRIX_NO_PRESS  
7432			;ldir  
7432			  
7432			  
7432			  
7432			; reset counter  
7432 3e 80		ld a, 128  
7434 d3 c1		out (portbdata),a  
7436			  
7436 06 0a		ld b, 10  
7438 0e 00		ld c, 0       ; current clock toggle  
743a			  
743a			.colscan:  
743a			  
743a			; set current column  
743a			; disable clock enable and set clock low  
743a			  
743a			;ld a, 0  
743a			;out (portbdata),a  
743a			  
743a			; For each column scan for switches  
743a			  
743a c5			push bc  
743b 21 c7 fd		ld hl, keyscan_scancol  
743e cd 47 75		call .rowscan  
7441 c1			pop bc  
7442			  
7442			  
7442			; get back current column  
7442			  
7442			; translate the row scan  
7442			  
7442			;   
7442			; row 1  
7442			  
7442 78			ld a,b  
7443			  
7443 21 3a fe		LD   hl, keyscan_table_row1+10  
7446			  
7446 cd f0 0f		call subafromhl  
7449			;call addatohl  
7449			  
7449 11 c7 fd		ld de, keyscan_scancol  
744c			  
744c 1a			ld a,(de)  
744d 77			ld (hl),a  
744e			  
744e			  
744e			  
744e			  
744e			; row 2  
744e			  
744e 78			ld a,b  
744f			  
744f 21 2f fe		LD   hl, keyscan_table_row2+10  
7452			  
7452			;call addatohl  
7452 cd f0 0f		call subafromhl  
7455			  
7455			  
7455 11 c8 fd		ld de, keyscan_scancol+1  
7458			  
7458 1a			ld a,(de)  
7459 77			ld (hl),a  
745a			  
745a			  
745a			; row 3  
745a			  
745a 78			ld a,b  
745b			  
745b 21 24 fe		LD   hl, keyscan_table_row3+10  
745e			  
745e			;call addatohl  
745e cd f0 0f		call subafromhl  
7461			  
7461 11 c9 fd		ld de, keyscan_scancol+2  
7464			  
7464 1a			ld a,(de)  
7465 77			ld (hl),a  
7466			  
7466			  
7466			  
7466			; row 4  
7466			  
7466 78			ld a,b  
7467			  
7467 21 19 fe		LD   hl, keyscan_table_row4+10  
746a			  
746a			;call addatohl  
746a cd f0 0f		call subafromhl  
746d			  
746d 11 ca fd		ld de, keyscan_scancol+3  
7470			  
7470 1a			ld a,(de)  
7471 77			ld (hl),a  
7472			  
7472			; row 5  
7472			  
7472 78			ld a,b  
7473			  
7473 21 0e fe		LD   hl, keyscan_table_row5+10  
7476			  
7476			;call addatohl  
7476 cd f0 0f		call subafromhl  
7479			  
7479 11 cb fd		ld de, keyscan_scancol+4  
747c			  
747c 1a			ld a,(de)  
747d 77			ld (hl),a  
747e			  
747e			; handshake next column  
747e			  
747e			  
747e 3e 40		ld a, 64  
7480 d3 c1		out (portbdata),a  
7482			  
7482 3e 00		ld a, 0  
7484 d3 c1		out (portbdata),a  
7486			  
7486			; toggle clk and move to next column  
7486			;ld a, 64  
7486			;cp c  
7486			;  
7486			;jr z, .coltoglow  
7486			;ld c, a  
7486			;jr .coltog  
7486			;.coltoglow:  
7486			;ld c, 0  
7486			;.coltog:  
7486			;ld a, c  
7486			;out (portbdata),a  
7486			  
7486 10 b2		djnz .colscan  
7488			  
7488 3e 0a		ld a,10  
748a 21 30 fe		LD   hl, keyscan_table_row1  
748d cd de 0f		call addatohl  
7490 3e 00		ld a, 0  
7492 77			ld (hl), a  
7493			  
7493			  
7493 3e 0a		ld a,10  
7495 21 25 fe		LD   hl, keyscan_table_row2  
7498 cd de 0f		call addatohl  
749b 3e 00		ld a, 0  
749d 77			ld (hl), a  
749e			  
749e 3e 0a		ld a,10  
74a0 21 1a fe		LD   hl, keyscan_table_row3  
74a3 cd de 0f		call addatohl  
74a6 3e 00		ld a, 0  
74a8 77			ld (hl), a  
74a9			  
74a9 3e 0a		ld a,10  
74ab 21 0f fe		LD   hl, keyscan_table_row4  
74ae cd de 0f		call addatohl  
74b1 3e 00		ld a, 0  
74b3 77			ld (hl), a  
74b4			  
74b4 3e 0a		ld a,10  
74b6 21 04 fe		LD   hl, keyscan_table_row5  
74b9 cd de 0f		call addatohl  
74bc 3e 00		ld a, 0  
74be 77			ld (hl), a  
74bf			  
74bf			if DEBUG_KEY_MATRIX  
74bf			  
74bf			; Display text on first line  
74bf			            LD   A, kLCD_Line1  
74bf			            CALL fLCD_Pos       ;Position cursor to location in A  
74bf			            LD   DE, keyscan_table_row1  
74bf			            ;LD   DE, MsgHello  
74bf			            CALL fLCD_Str       ;Display string pointed to by DE  
74bf			  
74bf			; Display text on second line  
74bf			            LD   A, kLCD_Line2  
74bf			            CALL fLCD_Pos       ;Position cursor to location in A  
74bf			            LD   DE, keyscan_table_row2  
74bf			            CALL fLCD_Str       ;Display string pointed to by DE  
74bf			            LD   A, kLCD_Line3  
74bf			            CALL fLCD_Pos       ;Position cursor to location in A  
74bf			            LD   DE, keyscan_table_row3  
74bf			            CALL fLCD_Str       ;Display string pointed to by DE  
74bf			            LD   A, kLCD_Line4  
74bf			            CALL fLCD_Pos       ;Position cursor to location in A  
74bf			            LD   DE, keyscan_table_row4  
74bf			            CALL fLCD_Str       ;Display string pointed to by DE  
74bf			            LD   A, kLCD_Line4+10  
74bf			            CALL fLCD_Pos       ;Position cursor to location in A  
74bf			            LD   DE, keyscan_table_row5  
74bf			            CALL fLCD_Str       ;Display string pointed to by DE  
74bf			  
74bf			;call delay250ms  
74bf				jp matrix  
74bf			endif  
74bf c9			ret  
74c0			  
74c0			; using decade counter....  
74c0			  
74c0			  
74c0			; TODO reset decade counter to start of scan  
74c0			  
74c0			; reset 15  
74c0			; clock 14  
74c0			; ce 13  
74c0			  
74c0			; 1 - q5  
74c0			; 2 - q1  
74c0			; 3 - q0  
74c0			; 4 - q2  
74c0			; 5 - q6  
74c0			; 6 - q7  
74c0			; 7 - q3  
74c0			; 8 - vss  
74c0			; 9 - q8  
74c0			; 10 - q4  
74c0			; 11 - q9  
74c0			; 12 - cout  
74c0			; 16 - vdd  
74c0			  
74c0			; clock      ce       reset     output  
74c0			; 0          x        0         n  
74c0			; x          1        0         n  
74c0			; x          x        1         q0  
74c0			; rising     0        0         n+1  
74c0			; falling    x        0         n  
74c0			; x          rising   0         n  
74c0			; 1          falling  0         x+1  
74c0			;  
74c0			; x = dont care, if n < 5 carry = 1 otherwise 0  
74c0			  
74c0			;   
74c0			; reset   
74c0			; 13=0, 14=0, 15=1 .. 15=0  
74c0			;  
74c0			; handshake line  
74c0			; 14=1.... read line 14=0  
74c0			  
74c0			  
74c0			  
74c0			  
74c0			  
74c0			; TODO hand shake clock for next column scan  
74c0			; TODO detect each row  
74c0			  
74c0			  
74c0			  
74c0			  
74c0			; reset 128  
74c0			; clock 64  
74c0			; ce 32  
74c0			  
74c0			  
74c0			.cyclestart:  
74c0			  
74c0			; reset counter  
74c0 3e 80		ld a, 128  
74c2 d3 c1		out (portbdata),a  
74c4			  
74c4			; loop leds  
74c4 06 0a		ld b,10  
74c6			  
74c6			.cycle1:  
74c6 c5			push bc  
74c7 3e 00		ld a, 0  
74c9 d3 c1		out (portbdata),a  
74cb cd e1 0c		call delay250ms  
74ce			  
74ce 3e 40		ld a, 64  
74d0 d3 c1		out (portbdata),a  
74d2 cd e1 0c		call delay250ms  
74d5			  
74d5 3e 00		ld a, 0  
74d7 d3 c1		out (portbdata),a  
74d9 cd e1 0c		call delay250ms  
74dc			  
74dc c1			pop bc  
74dd 10 e7		djnz .cycle1  
74df			  
74df			  
74df 18 df		jr .cyclestart  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			; map matrix key held to char on face of key  
74e1			  
74e1			;.mtocold:  
74e1			;  
74e1			;  
74e1			;; reset counter  
74e1			;ld a, 128  
74e1			;out (portbdata),a  
74e1			;  
74e1			;  
74e1			;; scan keyboard row 1  
74e1			;ld a, 0  
74e1			;out (portbdata),a  
74e1			;;ld a, 64  
74e1			;;out (portbdata),a  
74e1			;  
74e1			;  
74e1			;	ld a, 128  
74e1			;	ld hl, keyscan_table  
74e1			;	call .rowscan  
74e1			;  
74e1			;;ld a, 0  
74e1			;;out (portbdata),a  
74e1			;ld a, 64  
74e1			;out (portbdata),a  
74e1			;  
74e1			;	ld a, 64  
74e1			;	ld hl, keyscan_table+key_cols  
74e1			;	call .rowscan  
74e1			;  
74e1			;ld a, 0  
74e1			;out (portbdata),a  
74e1			;;ld a, 64  
74e1			;;out (portbdata),a  
74e1			;	ld a, 32  
74e1			;	ld hl, keyscan_table+(key_cols*2)  
74e1			;	call .rowscan  
74e1			;  
74e1			;  
74e1			;;ld a, 0  
74e1			;;out (portbdata),a  
74e1			;ld a, 64  
74e1			;out (portbdata),a  
74e1			;  
74e1			;	ld a, 16  
74e1			;	ld hl, keyscan_table+(key_cols*3)  
74e1			;	call .rowscan  
74e1			;  
74e1			;  
74e1			;	; flag if key D is held down and remove from reporting  
74e1			;	ld bc, .key_map_fd    
74e1			;	ld hl, keyscan_table  
74e1			;	ld de, key_fd  
74e1			;	call .key_shift_hold  
74e1			;	cp 255  
74e1			;	jr z, .cinmap  
74e1			;	; flag if key C is held down and remove from reporting  
74e1			;	ld bc, .key_map_fc    
74e1			;	ld hl, keyscan_table+key_cols  
74e1			;	ld de, key_fc  
74e1			;	call .key_shift_hold  
74e1			;	cp 255  
74e1			;	jr z, .cinmap  
74e1			;	; flag if key B is held down and remove from reporting  
74e1			;	ld bc, .key_map_fb    
74e1			;	ld hl, keyscan_table+(key_cols*2)  
74e1			;	ld de, key_fb  
74e1			;	call .key_shift_hold  
74e1			;	cp 255  
74e1			;	jr z, .cinmap  
74e1			;	; flag if key A is held down and remove from reporting  
74e1			;	ld bc, .key_map_fa    
74e1			;	ld hl, keyscan_table+(key_cols*3)  
74e1			;	ld de, key_fa  
74e1			;	call .key_shift_hold  
74e1			;	cp 255  
74e1			;	jr z, .cinmap  
74e1			;  
74e1			;	ld de, .matrix_to_char  
74e1			;  
74e1			;  
74e1			;.cinmap:   
74e1			;	if DEBUG_KEY  
74e1			;            LD   A, kLCD_Line4  
74e1			;            CALL fLCD_Pos       ;Position cursor to location in A  
74e1			;		push de  
74e1			;            LD   DE, keyscan_table  
74e1			;            CALL fLCD_Str       ;Display string pointed to by DE  
74e1			;		pop de  
74e1			;	endif  
74e1			  
74e1				; scan key matrix table for any held key  
74e1			  
74e1				; de holds either the default matrix or one selected above  
74e1			  
74e1			;	ld hl, keyscan_table  
74e1			;	ld b,key_cols*key_rows  
74e1			;  
74e1			;.cin1:	ld a,(hl)  
74e1			;	cp '#'  
74e1			;	jr z, .cinhit  
74e1			;	inc hl  
74e1			;	inc de  
74e1			;	dec b  
74e1			;	jr nz, .cin1  
74e1			;	; no key found held  
74e1			;	ld a,0  
74e1			;	ret  
74e1			;.cinhit: push de  
74e1			;	pop hl  
74e1			;	ld a,(hl)  
74e1			;	ret  
74e1			  
74e1			; flag a control key is held   
74e1			; hl is key pin, de is flag indicator  
74e1			  
74e1			;.key_shift_hold:  
74e1			;	push bc  
74e1			;	ld a, 1  
74e1			;	ld (cursor_shape),a  
74e1			;	ld b, 0  
74e1			;	ld a, (hl)  
74e1			;	cp '.'  
74e1			;	jr z, .key_shift1  
74e1			;	ld b, 255  
74e1			;	ld a, '+'    ; hide key from later scans  
74e1			;	ld (hl),a  
74e1			;	ld a, 2  
74e1			;	ld (cursor_shape),a  
74e1			;.key_shift1:  
74e1			;	; write flag indicator  
74e1			;	ld a,b  
74e1			;	ld (de),a  
74e1			;  
74e1			;	pop de    ; de now holds the key map ptr  
74e1			;	ret  
74e1			  
74e1				  
74e1				  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			;	push hl  
74e1			;	push de  
74e1			;	push bc  
74e1			;	call keyscan  
74e1			;	; map key matrix to ascii value of key face  
74e1			;  
74e1			;	ld hl, key_face_map  
74e1			;	ld de, keyscan_table  
74e1			;  
74e1			;	; get how many keys to look at  
74e1			;	ld b, keyscan_table_len  
74e1			;	  
74e1			;  
74e1			;	; at this stage fall out on first key hit  
74e1			;	; TODO handle multiple key press  
74e1			;  
74e1			;map1:	ld a,(hl)  
74e1			;	cp '#'  
74e1			;	jr z, keyhit  
74e1			;	inc hl  
74e1			;	inc de  
74e1			;	dec b  
74e1			;	jr nz, map1  
74e1			;nohit:	ld a, 0  
74e1			;	jr keydone  
74e1			;keyhit: push de  
74e1			;	pop hl  
74e1			;	ld a,(hl)  
74e1			;keydone:  
74e1			;	push bc  
74e1			;	push de  
74e1			; 	push hl  
74e1			;	ret   
74e1			;  
74e1			  
74e1			  
74e1			  
74e1			  
74e1			; scan physical key matrix  
74e1			  
74e1			  
74e1			;keyscan:  
74e1			;  
74e1			;; for each key_row use keyscanr bit mask for out  
74e1			;; then read in for keyscanc bitmask  
74e1			;; save result of row scan to keyscantable  
74e1			;  
74e1			;; scan keyboard row 1  
74e1			;  
74e1			;	ld b, key_rows  
74e1			;	ld hl, key_scanr  
74e1			;	ld de, keyscan_table  
74e1			;  
74e1			;rowloop:  
74e1			;  
74e1			;	ld a,(hl)		; out bit mask to energise keyboard row  
74e1			;	call rowscan  
74e1			;	inc hl  
74e1			;	dec b  
74e1			;	jr nz, rowloop  
74e1			;  
74e1			;	ret  
74e1			;  
74e1			;  
74e1			;; pass a out bitmask, b row number  
74e1			;arowscan:   
74e1			;	push bc  
74e1			;  
74e1			;	ld d, b  
74e1			;  
74e1			;	; calculate buffer location for this row  
74e1			;  
74e1			;	ld hl, keyscan_table	  
74e1			;kbufr:  ld e, key_cols  
74e1			;kbufc:	inc hl  
74e1			;	dec e  
74e1			;	jr nz, kbufc  
74e1			;	dec d  
74e1			;	jr nz, kbufr  
74e1			;  
74e1			;	; energise row and read columns  
74e1			;  
74e1			;	out (portbdata),a  
74e1			;	in a,(portbdata)  
74e1			;	ld c,a  
74e1			;  
74e1			;  
74e1			;	; save buffer loc  
74e1			;  
74e1			;	ld (keybufptr), hl  
74e1			;  
74e1			;	ld hl, key_scanc  
74e1			;	ld d, key_cols  
74e1			;  
74e1			;	; for each column check each bit mask  
74e1			;  
74e1			;colloop:  
74e1			;	  
74e1			;  
74e1			;	; reset flags for the row   
74e1			;  
74e1			;	ld b,'.'  
74e1			;	and (hl)  
74e1			;	jr z, maskskip  
74e1			;	ld b,'#'  
74e1			;maskskip:  
74e1			;	; save  key state  
74e1			;	push hl  
74e1			;	ld hl, (keybufptr)  
74e1			;	ld (hl), b  
74e1			;	inc hl  
74e1			;	ld (keybufptr), hl  
74e1			;  
74e1			;	; move to next bit mask  
74e1			;	pop hl  
74e1			;	inc hl  
74e1			;  
74e1			;	dec d  
74e1			;	jr nz, colloop  
74e1			;  
74e1			;	ret  
74e1			;  
74e1			;  
74e1			;;  
74e1			; lcd functions  
74e1			;  
74e1			;  
74e1			  
74e1			;if DEBUG_KEY_MATRIX  
74e1			  
74e1			; test function to display hardware view of matrix state  
74e1			  
74e1			matrixold:  
74e1			  
74e1			  
74e1			  
74e1			; reset counter  
74e1 3e 80		ld a, 128  
74e3 d3 c1		out (portbdata),a  
74e5			; scan keyboard row 1  
74e5 3e 00		ld a, 0  
74e7 d3 c1		out (portbdata),a  
74e9			;ld a, 64  
74e9			;out (portbdata),a  
74e9 3e 80			ld a, 128  
74eb 21 30 fe			ld hl, keyscan_table_row1  
74ee cd 47 75			call .rowscan  
74f1			  
74f1			;ld a, 0  
74f1			;out (portbdata),a  
74f1 3e 40		ld a, 64  
74f3 d3 c1		out (portbdata),a  
74f5 3e 40			ld a, 64  
74f7 21 25 fe			ld hl, keyscan_table_row2  
74fa cd 47 75			call .rowscan  
74fd			  
74fd 3e 00		ld a, 0  
74ff d3 c1		out (portbdata),a  
7501			;ld a, 64  
7501			;out (portbdata),a  
7501 3e 20			ld a, 32  
7503 21 1a fe			ld hl, keyscan_table_row3  
7506 cd 47 75			call .rowscan  
7509			  
7509			;ld a, 0  
7509			;out (portbdata),a  
7509 3e 40		ld a, 64  
750b d3 c1		out (portbdata),a  
750d 3e 10			ld a, 16  
750f 21 0f fe			ld hl, keyscan_table_row4  
7512 cd 47 75			call .rowscan  
7515			  
7515			; Display text on first line  
7515 3e 00		            LD   A, kLCD_Line1  
7517 cd 4f 71		            CALL fLCD_Pos       ;Position cursor to location in A  
751a 11 30 fe		            LD   DE, keyscan_table_row1  
751d			            ;LD   DE, MsgHello  
751d cd 71 71		            CALL fLCD_Str       ;Display string pointed to by DE  
7520			  
7520			; Display text on second line  
7520 3e 28		            LD   A, kLCD_Line2  
7522 cd 4f 71		            CALL fLCD_Pos       ;Position cursor to location in A  
7525 11 25 fe		            LD   DE, keyscan_table_row2  
7528 cd 71 71		            CALL fLCD_Str       ;Display string pointed to by DE  
752b 3e 50		            LD   A, kLCD_Line3  
752d cd 4f 71		            CALL fLCD_Pos       ;Position cursor to location in A  
7530 11 1a fe		            LD   DE, keyscan_table_row3  
7533 cd 71 71		            CALL fLCD_Str       ;Display string pointed to by DE  
7536 3e 78		            LD   A, kLCD_Line4  
7538 cd 4f 71		            CALL fLCD_Pos       ;Position cursor to location in A  
753b 11 0f fe		            LD   DE, keyscan_table_row4  
753e cd 71 71		            CALL fLCD_Str       ;Display string pointed to by DE  
7541			  
7541 cd e1 0c			call delay250ms  
7544 c3 32 74			jp matrix  
7547			  
7547			; pass de as row display flags  
7547			.rowscan:   
7547			;	out (portbdata),a  
7547 db c1			in a,(portbdata)  
7549 4f				ld c,a  
754a				; reset flags for the row   
754a 06 7e			ld b,KEY_MATRIX_NO_PRESS  
754c e6 01			and 1  
754e 28 02			jr z, .p1on  
7550 06 23			ld b,'#'  
7552			.p1on:  
7552 70				ld (hl), b  
7553 23				inc hl  
7554			  
7554 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7556 79				ld a,c  
7557 e6 02			and 2  
7559			;	bit 0,a  
7559 28 02			jr z, .p2on  
755b 06 23			ld b,'#'  
755d			.p2on:  
755d 70				ld (hl), b  
755e 23				inc hl  
755f			;  
755f 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7561 79				ld a,c  
7562 e6 04			and 4  
7564			;;	bit 0,a  
7564 28 02			jr z, .p3on  
7566 06 23			ld b,'#'  
7568			.p3on:  
7568 70				ld (hl), b  
7569 23				inc hl  
756a			;;  
756a 06 7e			ld b,KEY_MATRIX_NO_PRESS  
756c			;;	bit 0,a  
756c 79				ld a,c  
756d e6 08			and 8  
756f 28 02			jr z, .p4on  
7571 06 23			ld b,'#'  
7573			.p4on:  
7573 70				ld (hl), b  
7574 23				inc hl  
7575			  
7575 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7577			;;	bit 0,a  
7577 79				ld a,c  
7578 e6 10			and 16  
757a 28 02			jr z, .p5on  
757c 06 23			ld b,'#'  
757e			.p5on:  
757e 70				ld (hl), b  
757f 23				inc hl  
7580			; zero term  
7580 06 00			ld b,0  
7582 70				ld (hl), b  
7583			  
7583 c9			.rscandone: ret  
7584			  
7584			;addatohl:  
7584			;  
7584			 ;add   a, l    ; A = A+L  
7584			  ;  ld    l, a    ; L = A+L  
7584			   ; adc   a, h    ; A = A+L+H+carry  
7584			   ; sub   l       ; A = H+carry  
7584			   ; ld    h, a    ; H = H+carry  
7584			  
7584			;ret  
7584			; eof  
# End of file firmware_key_5x10.asm
7584			;include "firmware_key_4x10.asm" 
7584			 
7584			heap_size:    equ heap_end - heap_start 
7584			;eof 
# End of file os_mega.asm
7584
