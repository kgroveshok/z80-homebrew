# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 5a 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			if BASE_KEV = 1  
011c			 
011c				; need to be at $66 for nmi support 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255 
011c				jp nmi 
011c			endif 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 0       
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 1  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c			;	call break_point_state  
011c			; now use the break point debug vector  
011c				call debug_vector  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011c			  
011c			debug_mark: equ debug_vector - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_active-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ scratch-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			;os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_new_exec_ptr - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c			;	ld a, ' ' 
011c			;	ld (os_view_disable), a 
011c				call bp_on 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 10 ed				ld hl, display_fb1  
011f 22 cc eb				ld (display_fb_active), hl  
0122			  
0122 cd ba 0b				call clear_display  
0125			  
0125 21 ce eb				ld hl, display_fb2  
0128 22 cc eb				ld (display_fb_active), hl  
012b			  
012b cd ba 0b				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b1 ed				ld hl, display_fb0  
0131 22 cc eb				ld (display_fb_active), hl  
0134			  
0134 cd ba 0b				call clear_display  
0137			  
0137			  
0137 cd 30 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd 1e 65			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 8a 12				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd dd 0b			call update_display  
0146 cd f2 0a			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd bf 0b			call fill_display  
014e cd dd 0b			call update_display  
0151 cd f2 0a			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd bf 0b			call fill_display  
0159 cd dd 0b			call update_display  
015c cd f2 0a			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd bf 0b			call fill_display  
0164 cd dd 0b			call update_display  
0167 cd f2 0a			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 b8 17			ld de, prom_bootmsg  
016f cd cd 0b			call str_at_display  
0172 cd dd 0b			call update_display  
0175			  
0175			  
0175 cd f2 0a			call delay1s  
0178 cd f2 0a			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 cd 17			ld de, prom_bootmsg1  
0180 cd cd 0b			call str_at_display  
0183 cd dd 0b			call update_display  
0186 cd f2 0a			call delay1s  
0189 cd f2 0a			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 6b ee		ld (debug_mark),a  
0191 32 6c ee		ld (debug_mark+1),a  
0194 32 6d ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 6e ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 73 ea			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 6b ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 6c ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 6d ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd 6f ee			call debug_vector  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 7a ea			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 6b ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 6c ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 6d ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd 6f ee			call debug_vector  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 7a ea				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 6b ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 6c ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 6d ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd 6f ee			call debug_vector  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd 10 0e				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 73 ea				ld hl, (store_tmp1) 
0210 11 7d ea				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 6b ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 6c ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 6d ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd 6f ee			call debug_vector  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 7d 12				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 6b ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 6c ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 6d ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd 6f ee			call debug_vector  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 6b ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 6c ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 6d ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd 6f ee			call debug_vector  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 6b ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 6c ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 6d ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd 6f ee			call debug_vector  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 6b ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 6c ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 6d ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd 6f ee			call debug_vector  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd 10 0e			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 7a ea			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 6b ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 6c ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 6d ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd 6f ee			call debug_vector  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 6b ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 6c ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 6d ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd 6f ee			call debug_vector  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 7a ea			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 6b ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 6c ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 6d ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 7a ea				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd 6f ee			call debug_vector  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 7b ea			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 6b ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 6c ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 6d ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd 6f ee			call debug_vector  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 6b ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 6c ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 6d ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd 6f ee			call debug_vector  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd b5 0a			call storage_clear_page 
039b			 
039b 21 7a ea			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 7b ea		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 7d ea		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 86 ea			ld hl, store_page+3+9 
03b5 3a 5f ea			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 7a ea			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 6b ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 6c ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 6d ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd 6f ee			call debug_vector  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 6b ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 6c ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 6d ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd 6f ee			call debug_vector  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd d7 0a			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd d7 0a			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd e7 0d				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd d7 0a			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd d7 0a			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd e7 0d				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 6b ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 6c ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 6d ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd 6f ee			call debug_vector  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 7d ea		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 6b ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 6c ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 6d ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd 6f ee			call debug_vector  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 7a ea			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 6b ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 6c ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 6d ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd 6f ee			call debug_vector  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 6b ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 6c ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 6d ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd 6f ee			call debug_vector  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd 10 0e			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 7a ea			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd 10 0e			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 6b ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 6c ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 6d ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd 6f ee			call debug_vector  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 7a ea			ld a, (store_page)	; get file id 
0510 32 6e ea			ld (store_tmpid), a 
0513			 
0513 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0516 32 6d ea			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 7a ea			ld (store_page), a 
051f 32 7b ea			ld (store_page+1),a 
0522 11 7a ea			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 6b ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 6c ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 6d ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd 6f ee			call debug_vector  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 6d ea			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 6e ea			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 6b ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 6c ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 6d ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd 6f ee			call debug_vector  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd 10 0e			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 7a ea			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 7a ea			ld (store_page), a 
0582 32 7b ea			ld (store_page+1),a 
0585 11 7a ea			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 6b ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 6c ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 6d ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd 6f ee			call debug_vector  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 6b ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 6c ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 6d ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd 6f ee			call debug_vector  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd 05 0e				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd e7 0d				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd 05 0e				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd e7 0d				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 6b ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 6c ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 6d ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd 6f ee			call debug_vector  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 6b ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 6c ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 6d ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd 6f ee			call debug_vector  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd e7 0d				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd e7 0d				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 6b ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 6c ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 6d ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd 6f ee			call debug_vector  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 7a ea			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 7a ea			ld (store_page),a 
06a3				 
06a3 32 6e ea			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 7a ea			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 6b ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 6c ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 6d ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd 6f ee			call debug_vector  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 7a ea				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 6b ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 6c ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 6d ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd 6f ee			call debug_vector  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 6b ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 6c ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 6d ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd 6f ee			call debug_vector  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 65 ea			ld (store_tmppageid), hl 
0715				 
0715 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 7a ea			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 7b ea			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 7c ea			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 6b ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 6c ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 6d ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd 6f ee			call debug_vector  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd 50 12			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 6b ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 6c ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 6d ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd 6f ee			call debug_vector  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 6b ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 6c ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 6d ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd 6f ee			call debug_vector  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 65 ea			ld hl,(store_tmppageid) 
078b 11 7a ea			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 6b ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 6c ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 6d ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd 6f ee			call debug_vector  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 6e ea			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 6b ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 6c ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 6d ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd 6f ee			call debug_vector  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2			 
07d2			 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5			 
07d5			.srext: 
07d5 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07d8 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07dc			 
07dc 21 40 00			ld hl, STORE_BLOCK_PHY 
07df				if DEBUG_STORESE 
07df					DMARK "sre" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 6b ee			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 6c ee			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 6d ee			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "sre"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd 6f ee			call debug_vector  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb cd ac 05			call storage_findnextid 
07fe			 
07fe				if DEBUG_STORESE 
07fe					DMARK "srf" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 6b ee			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 6c ee			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 6d ee			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "srf"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					CALLMONITOR 
0817 cd 6f ee			call debug_vector  
081a				endm  
# End of macro CALLMONITOR
081a				endif 
081a cd 10 0e			call ishlzero 
081d			;	ld a, l 
081d			;	add h 
081d			;	cp 0 
081d 28 b1			jr z,.sr_fail			; block not found so EOF 
081f			 
081f				; save current address for use by higher level words etc 
081f			 
081f 22 6b ea			ld (store_openaddr),hl 
0822			 
0822			 
0822				; hl contains page number to load 
0822 d1				pop de   ; get storage 
0823 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0827 d5				push de 
0828				if DEBUG_STORESE 
0828					DMARK "srg" 
0828 f5				push af  
0829 3a 3d 08			ld a, (.dmark)  
082c 32 6b ee			ld (debug_mark),a  
082f 3a 3e 08			ld a, (.dmark+1)  
0832 32 6c ee			ld (debug_mark+1),a  
0835 3a 3f 08			ld a, (.dmark+2)  
0838 32 6d ee			ld (debug_mark+2),a  
083b 18 03			jr .pastdmark  
083d ..			.dmark: db "srg"  
0840 f1			.pastdmark: pop af  
0841			endm  
# End of macro DMARK
0841					CALLMONITOR 
0841 cd 6f ee			call debug_vector  
0844				endm  
# End of macro CALLMONITOR
0844				endif 
0844 cd 79 02			call storage_read_block 
0847			 
0847				; if this a continuation read??? 
0847			 
0847 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084a			 
084a 3e 3f			ld a, STORE_BLOCK_PHY-1 
084c cd e7 0d			call addatohl 
084f 7e				ld a,(hl) 
0850 fe 00			cp 0 
0852 28 02			jr z, .markiscont 
0854 3e ff			ld a, 255 
0856			 
0856			.markiscont: 
0856 32 6d ea			ld (store_readcont), a 
0859			 
0859				if DEBUG_STORESE 
0859					DMARK "srC" 
0859 f5				push af  
085a 3a 6e 08			ld a, (.dmark)  
085d 32 6b ee			ld (debug_mark),a  
0860 3a 6f 08			ld a, (.dmark+1)  
0863 32 6c ee			ld (debug_mark+1),a  
0866 3a 70 08			ld a, (.dmark+2)  
0869 32 6d ee			ld (debug_mark+2),a  
086c 18 03			jr .pastdmark  
086e ..			.dmark: db "srC"  
0871 f1			.pastdmark: pop af  
0872			endm  
# End of macro DMARK
0872					CALLMONITOR 
0872 cd 6f ee			call debug_vector  
0875				endm  
# End of macro CALLMONITOR
0875				endif 
0875				; only short reads enabled 
0875			 
0875 3a 75 ea			ld a, (store_longread) 
0878 fe 00			cp 0 
087a ca 47 09			jp z, .readdone 
087d			 
087d			; TODO if block has no zeros then need to read next block  
087d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087d			; check last byte of physical block. 
087d			; if not zero then the next block needs to be loaded 
087d			 
087d			 
087d 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0880			 
0880 3e 3f			ld a, STORE_BLOCK_PHY-1 
0882 cd e7 0d			call addatohl 
0885				;dec hl 
0885 7e				ld a,(hl) 
0886				if DEBUG_STORESE 
0886					DMARK "sr?" 
0886 f5				push af  
0887 3a 9b 08			ld a, (.dmark)  
088a 32 6b ee			ld (debug_mark),a  
088d 3a 9c 08			ld a, (.dmark+1)  
0890 32 6c ee			ld (debug_mark+1),a  
0893 3a 9d 08			ld a, (.dmark+2)  
0896 32 6d ee			ld (debug_mark+2),a  
0899 18 03			jr .pastdmark  
089b ..			.dmark: db "sr?"  
089e f1			.pastdmark: pop af  
089f			endm  
# End of macro DMARK
089f					CALLMONITOR 
089f cd 6f ee			call debug_vector  
08a2				endm  
# End of macro CALLMONITOR
08a2				endif 
08a2 fe 00			cp 0 
08a4 ca 47 09			jp z, .readdone 
08a7			 
08a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a7			 
08a7 23				inc hl 
08a8			 
08a8 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ab			 
08ab ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08af			 
08af eb				ex de, hl 
08b0			 
08b0				; next ext 
08b0			 
08b0 23				inc hl 
08b1 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b4			 
08b4				if DEBUG_STORESE 
08b4					DMARK "sF2" 
08b4 f5				push af  
08b5 3a c9 08			ld a, (.dmark)  
08b8 32 6b ee			ld (debug_mark),a  
08bb 3a ca 08			ld a, (.dmark+1)  
08be 32 6c ee			ld (debug_mark+1),a  
08c1 3a cb 08			ld a, (.dmark+2)  
08c4 32 6d ee			ld (debug_mark+2),a  
08c7 18 03			jr .pastdmark  
08c9 ..			.dmark: db "sF2"  
08cc f1			.pastdmark: pop af  
08cd			endm  
# End of macro DMARK
08cd					CALLMONITOR 
08cd cd 6f ee			call debug_vector  
08d0				endm  
# End of macro CALLMONITOR
08d0				endif 
08d0			 
08d0				; get and load block 
08d0			 
08d0 cd ac 05			call storage_findnextid 
08d3			 
08d3				if DEBUG_STORESE 
08d3					DMARK "sf2" 
08d3 f5				push af  
08d4 3a e8 08			ld a, (.dmark)  
08d7 32 6b ee			ld (debug_mark),a  
08da 3a e9 08			ld a, (.dmark+1)  
08dd 32 6c ee			ld (debug_mark+1),a  
08e0 3a ea 08			ld a, (.dmark+2)  
08e3 32 6d ee			ld (debug_mark+2),a  
08e6 18 03			jr .pastdmark  
08e8 ..			.dmark: db "sf2"  
08eb f1			.pastdmark: pop af  
08ec			endm  
# End of macro DMARK
08ec					CALLMONITOR 
08ec cd 6f ee			call debug_vector  
08ef				endm  
# End of macro CALLMONITOR
08ef				endif 
08ef cd 10 0e			call ishlzero 
08f2			;	ld a, l 
08f2			;	add h 
08f2			;	cp 0 
08f2 ca d0 07			jp z,.sr_fail			; block not found so EOF 
08f5				 
08f5				; save current address for use by higher level words etc 
08f5			 
08f5 22 6b ea			ld (store_openaddr),hl 
08f8			 
08f8 cd 79 02			call storage_read_block 
08fb			 
08fb				; on a continuation block, we now have the file id and ext in the middle of the block 
08fb				; we need to pull everything back  
08fb			 
08fb ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08ff 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0902 23				inc hl 
0903 23				inc hl     ; skip id and ext 
0904 01 40 00			ld bc, STORE_BLOCK_PHY 
0907				if DEBUG_STORESE 
0907					DMARK "SR<" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 6b ee			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 6c ee			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 6d ee			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "SR<"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd 6f ee			call debug_vector  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923 ed b0			ldir     ; copy data 
0925			 
0925				; move the pointer back and pretend we have a full buffer for next recheck 
0925			 
0925 1b				dec de 
0926 1b				dec de 
0927			 
0927			; TODO do pop below now short circuit loop????? 
0927 c1				pop bc     ; get rid of spare de on stack 
0928				if DEBUG_STORESE 
0928					DMARK "SR>" 
0928 f5				push af  
0929 3a 3d 09			ld a, (.dmark)  
092c 32 6b ee			ld (debug_mark),a  
092f 3a 3e 09			ld a, (.dmark+1)  
0932 32 6c ee			ld (debug_mark+1),a  
0935 3a 3f 09			ld a, (.dmark+2)  
0938 32 6d ee			ld (debug_mark+2),a  
093b 18 03			jr .pastdmark  
093d ..			.dmark: db "SR>"  
0940 f1			.pastdmark: pop af  
0941			endm  
# End of macro DMARK
0941					CALLMONITOR 
0941 cd 6f ee			call debug_vector  
0944				endm  
# End of macro CALLMONITOR
0944				endif 
0944 c3 d5 07			jp .srext 
0947			 
0947			 
0947			 
0947			 
0947			 
0947			.readdone:		 
0947 e1				pop hl 		 ; return start of data to show as not EOF 
0948 23				inc hl   ; past file id 
0949 23				inc hl   ; past ext 
094a				if DEBUG_STORESE 
094a					DMARK "SRe" 
094a f5				push af  
094b 3a 5f 09			ld a, (.dmark)  
094e 32 6b ee			ld (debug_mark),a  
0951 3a 60 09			ld a, (.dmark+1)  
0954 32 6c ee			ld (debug_mark+1),a  
0957 3a 61 09			ld a, (.dmark+2)  
095a 32 6d ee			ld (debug_mark+2),a  
095d 18 03			jr .pastdmark  
095f ..			.dmark: db "SRe"  
0962 f1			.pastdmark: pop af  
0963			endm  
# End of macro DMARK
0963					CALLMONITOR 
0963 cd 6f ee			call debug_vector  
0966				endm  
# End of macro CALLMONITOR
0966				endif 
0966 c9					ret 
0967			 
0967			 
0967			 
0967			; 
0967			; Append File 
0967			; 
0967			; hl - file id to locate 
0967			; de - pointer to (multi block) string to write 
0967			 
0967			.sa_notfound: 
0967 d1				pop de 
0968 c9				ret 
0969			 
0969			 
0969			storage_append: 
0969				; hl -  file id to append to 
0969				; de - string to append 
0969			 
0969 d5				push de 
096a				 
096a				if DEBUG_STORESE 
096a					DMARK "AP1" 
096a f5				push af  
096b 3a 7f 09			ld a, (.dmark)  
096e 32 6b ee			ld (debug_mark),a  
0971 3a 80 09			ld a, (.dmark+1)  
0974 32 6c ee			ld (debug_mark+1),a  
0977 3a 81 09			ld a, (.dmark+2)  
097a 32 6d ee			ld (debug_mark+2),a  
097d 18 03			jr .pastdmark  
097f ..			.dmark: db "AP1"  
0982 f1			.pastdmark: pop af  
0983			endm  
# End of macro DMARK
0983					CALLMONITOR 
0983 cd 6f ee			call debug_vector  
0986				endm  
# End of macro CALLMONITOR
0986				endif 
0986			 
0986 7d				ld a, l 
0987 32 6e ea			ld (store_tmpid), a 
098a			 
098a				; get file header  
098a			 
098a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098c 3a 6e ea			ld a, (store_tmpid) 
098f 5f				ld e, a 
0990			 
0990 21 40 00				ld hl, STORE_BLOCK_PHY 
0993 cd ac 05				call storage_findnextid 
0996			 
0996 cd 10 0e			call ishlzero 
0999 28 cc			jr z, .sa_notfound 
099b			 
099b 22 65 ea			ld (store_tmppageid), hl 
099e			 
099e				; TODO handle file id not found 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "AP2" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 6b ee			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 6c ee			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 6d ee			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "AP2"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd 6f ee			call debug_vector  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba			 
09ba				; update file extent count 
09ba			 
09ba 11 7a ea			ld de, store_page 
09bd			 
09bd cd 79 02			call storage_read_block 
09c0			 
09c0				if DEBUG_STORESE 
09c0					DMARK "AP3" 
09c0 f5				push af  
09c1 3a d5 09			ld a, (.dmark)  
09c4 32 6b ee			ld (debug_mark),a  
09c7 3a d6 09			ld a, (.dmark+1)  
09ca 32 6c ee			ld (debug_mark+1),a  
09cd 3a d7 09			ld a, (.dmark+2)  
09d0 32 6d ee			ld (debug_mark+2),a  
09d3 18 03			jr .pastdmark  
09d5 ..			.dmark: db "AP3"  
09d8 f1			.pastdmark: pop af  
09d9			endm  
# End of macro DMARK
09d9					CALLMONITOR 
09d9 cd 6f ee			call debug_vector  
09dc				endm  
# End of macro CALLMONITOR
09dc				endif 
09dc			;	ld (store_tmppageid), hl 
09dc			 
09dc 3a 7c ea			ld a, (store_page+2) 
09df 3c				inc a 
09e0 32 7c ea			ld (store_page+2), a 
09e3 32 6d ea			ld (store_tmpext), a 
09e6				 
09e6				if DEBUG_STORESE 
09e6					DMARK "AP3" 
09e6 f5				push af  
09e7 3a fb 09			ld a, (.dmark)  
09ea 32 6b ee			ld (debug_mark),a  
09ed 3a fc 09			ld a, (.dmark+1)  
09f0 32 6c ee			ld (debug_mark+1),a  
09f3 3a fd 09			ld a, (.dmark+2)  
09f6 32 6d ee			ld (debug_mark+2),a  
09f9 18 03			jr .pastdmark  
09fb ..			.dmark: db "AP3"  
09fe f1			.pastdmark: pop af  
09ff			endm  
# End of macro DMARK
09ff					CALLMONITOR 
09ff cd 6f ee			call debug_vector  
0a02				endm  
# End of macro CALLMONITOR
0a02				endif 
0a02 2a 65 ea			ld hl, (store_tmppageid) 
0a05 11 7a ea			ld de, store_page 
0a08 cd de 02			call storage_write_block 
0a0b			 
0a0b				; find free block 
0a0b			 
0a0b 11 00 00			ld de, 0			 ; file extent to locate 
0a0e			 
0a0e 21 40 00				ld hl, STORE_BLOCK_PHY 
0a11 cd ac 05				call storage_findnextid 
0a14 cd 10 0e			call ishlzero 
0a17 ca 67 09			jp z, .sa_notfound 
0a1a			 
0a1a					; TODO handle no space left 
0a1a					 
0a1a 22 65 ea				ld (store_tmppageid), hl 
0a1d			 
0a1d				if DEBUG_STORESE 
0a1d					DMARK "AP4" 
0a1d f5				push af  
0a1e 3a 32 0a			ld a, (.dmark)  
0a21 32 6b ee			ld (debug_mark),a  
0a24 3a 33 0a			ld a, (.dmark+1)  
0a27 32 6c ee			ld (debug_mark+1),a  
0a2a 3a 34 0a			ld a, (.dmark+2)  
0a2d 32 6d ee			ld (debug_mark+2),a  
0a30 18 03			jr .pastdmark  
0a32 ..			.dmark: db "AP4"  
0a35 f1			.pastdmark: pop af  
0a36			endm  
# End of macro DMARK
0a36					CALLMONITOR 
0a36 cd 6f ee			call debug_vector  
0a39				endm  
# End of macro CALLMONITOR
0a39				endif 
0a39					; init the buffer with zeros so we can id if the buffer is full or not 
0a39			 
0a39 e5					push hl 
0a3a c5					push bc 
0a3b			 
0a3b 21 7a ea				ld hl, store_page 
0a3e 06 40				ld b, STORE_BLOCK_PHY 
0a40 3e 00				ld a, 0 
0a42 77			.zeroblock:	ld (hl), a 
0a43 23					inc hl 
0a44 10 fc				djnz .zeroblock 
0a46			 
0a46 c1					pop bc 
0a47 e1					pop hl 
0a48			 
0a48					; construct block 
0a48			 
0a48 3a 6e ea				ld a, (store_tmpid) 
0a4b 32 7a ea				ld (store_page), a   ; file id 
0a4e 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a51 32 7b ea				ld (store_page+1), a 
0a54			 
0a54 e1					pop hl    ; get string to write 
0a55 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a57 11 7c ea				ld de, store_page+2 
0a5a			 
0a5a				if DEBUG_STORESE 
0a5a					DMARK "AP5" 
0a5a f5				push af  
0a5b 3a 6f 0a			ld a, (.dmark)  
0a5e 32 6b ee			ld (debug_mark),a  
0a61 3a 70 0a			ld a, (.dmark+1)  
0a64 32 6c ee			ld (debug_mark+1),a  
0a67 3a 71 0a			ld a, (.dmark+2)  
0a6a 32 6d ee			ld (debug_mark+2),a  
0a6d 18 03			jr .pastdmark  
0a6f ..			.dmark: db "AP5"  
0a72 f1			.pastdmark: pop af  
0a73			endm  
# End of macro DMARK
0a73					CALLMONITOR 
0a73 cd 6f ee			call debug_vector  
0a76				endm  
# End of macro CALLMONITOR
0a76				endif 
0a76			 
0a76			 
0a76			 
0a76					; fill buffer with data until end of string or full block 
0a76			 
0a76 7e			.appd:		ld a, (hl) 
0a77 12					ld (de), a 
0a78 fe 00				cp 0 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f6				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 65 ea			ld hl, (store_tmppageid) 
0a85 11 7a ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 6b ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 6c ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 6d ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd 6f ee			call debug_vector  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd de 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9 fe 00				cp 0		 ; no, string was fully written 
0aab c8					ret z 
0aac			 
0aac					; setup vars for next cycle 
0aac			 
0aac 3a 6e ea				ld a, (store_tmpid) 
0aaf 6f					ld l, a 
0ab0 26 00				ld h, 0 
0ab2			 
0ab2 c3 69 09			 	jp storage_append	 ; yes, need to write out some more 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			if DEBUG_STORECF 
0ab5			storageput:	 
0ab5					ret 
0ab5			storageread: 
0ab5					ld hl, store_page 
0ab5					ld b, 200 
0ab5					ld a,0 
0ab5			.src:		ld (hl),a 
0ab5					inc hl 
0ab5					djnz .src 
0ab5					 
0ab5			 
0ab5					ld de, 0 
0ab5					ld bc, 1 
0ab5					ld hl, store_page 
0ab5					call cfRead 
0ab5			 
0ab5				call cfGetError 
0ab5				ld hl,scratch 
0ab5				call hexout 
0ab5				ld hl, scratch+2 
0ab5				ld a, 0 
0ab5				ld (hl),a 
0ab5				ld de, scratch 
0ab5				ld a,display_row_1 
0ab5				call str_at_display 
0ab5				call update_display 
0ab5			 
0ab5					ld hl, store_page 
0ab5					ld (os_cur_ptr),hl 
0ab5			 
0ab5					ret 
0ab5			endif 
0ab5			 
0ab5			 
0ab5			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab5			 
0ab5			storage_clear_page: 
0ab5 e5				push hl 
0ab6 d5				push de 
0ab7 c5				push bc 
0ab8 21 7a ea			ld hl, store_page 
0abb 3e 00			ld a, 0 
0abd 77				ld (hl), a 
0abe			 
0abe 11 7b ea			ld de, store_page+1 
0ac1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac4			 
0ac4 ed b0			ldir 
0ac6				 
0ac6 c1				pop bc 
0ac7 d1				pop de 
0ac8 e1				pop hl 
0ac9 c9				ret 
0aca			 
0aca			; eof 
# End of file firmware_storage.asm
0aca			  
0aca			; support routines for above hardware abstraction layer  
0aca			  
0aca			include "firmware_general.asm"        ; general support functions  
0aca			 
0aca			; word look up 
0aca			 
0aca			; in 
0aca			; a is the index 
0aca			; hl is pointer start of array 
0aca			; 
0aca			; returns 
0aca			; hl to the word 
0aca			; 
0aca			 
0aca			table_lookup:  
0aca d5					push de 
0acb eb					ex de, hl 
0acc			 
0acc 6f					ld l, a 
0acd 26 00				ld h, 0 
0acf 29					add hl, hl 
0ad0 19					add hl, de 
0ad1 7e					ld a, (hl) 
0ad2 23					inc hl 
0ad3 66					ld h,(hl) 
0ad4 6f					ld l, a 
0ad5			 
0ad5 d1					pop de 
0ad6 c9					ret 
0ad7			 
0ad7			; Delay loops 
0ad7			 
0ad7			 
0ad7			 
0ad7			aDelayInMS: 
0ad7 c5				push bc 
0ad8 47				ld b,a 
0ad9			msdelay: 
0ad9 c5				push bc 
0ada				 
0ada			 
0ada 01 41 00			ld bc,041h 
0add cd f5 0a			call delayloop 
0ae0 c1				pop bc 
0ae1 05				dec b 
0ae2 20 f5			jr nz,msdelay 
0ae4			 
0ae4			;if CPU_CLOCK_8MHZ 
0ae4			;msdelay8: 
0ae4			;	push bc 
0ae4			;	 
0ae4			; 
0ae4			;	ld bc,041h 
0ae4			;	call delayloop 
0ae4			;	pop bc 
0ae4			;	dec b 
0ae4			;	jr nz,msdelay8 
0ae4			;endif 
0ae4			 
0ae4			 
0ae4 c1				pop bc 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			delay250ms: 
0ae6				;push de 
0ae6 01 00 40			ld bc, 04000h 
0ae9 c3 f5 0a			jp delayloop 
0aec			delay500ms: 
0aec				;push de 
0aec 01 00 80			ld bc, 08000h 
0aef c3 f5 0a			jp delayloop 
0af2			delay1s: 
0af2				;push bc 
0af2			   ; Clobbers A, d and e 
0af2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af5			delayloop: 
0af5 c5			    push bc 
0af6			 
0af6			if BASE_CPM 
0af6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af9			.cpmloop: 
0af9 c5				push bc 
0afa			 
0afa			endif 
0afa			 
0afa			 
0afa			 
0afa			delayloopi: 
0afa			;	push bc 
0afa			;.dl: 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe cb 47		    bit     0,a    	; 8 
0b00 e6 ff		    and     255  	; 7 
0b02 0b			    dec     bc      	; 6 
0b03 79			    ld      a,c     	; 4 
0b04 b0			    or      b     	; 4 
0b05 c2 fa 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b08			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b08				;pop de 
0b08			;pop bc 
0b08			 
0b08			if BASE_CPM 
0b08 c1				pop bc 
0b09				 
0b09 0b			    dec     bc      	; 6 
0b0a 79			    ld      a,c     	; 4 
0b0b b0			    or      b     	; 4 
0b0c c2 f9 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0f				 
0b0f			 
0b0f			endif 
0b0f			;if CPU_CLOCK_8MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f			 
0b0f			;if CPU_CLOCK_10MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f c1			    pop bc 
0b10			 
0b10 c9				ret 
0b11			 
0b11			 
0b11			 
0b11			; eof 
# End of file firmware_general.asm
0b11			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b11			; display routines that use the physical hardware abstraction layer 
0b11			 
0b11			 
0b11			; Display an activity indicator 
0b11			; Each call returns the new char pointed to in hl 
0b11			 
0b11			active: 
0b11 3a c6 eb			ld a, (display_active) 
0b14 fe 06			cp 6 
0b16			 
0b16 20 02			jr nz, .sne 
0b18				; gone past the last one reset sequence 
0b18 3e ff			ld a, 255 
0b1a			 
0b1a			.sne:   
0b1a				; get the next char in seq 
0b1a 3c				inc a 
0b1b 32 c6 eb			ld (display_active), a 
0b1e			 
0b1e				; look up the string in the table 
0b1e 21 35 0b			ld hl, actseq 
0b21 cb 27			sla a 
0b23 cd e7 0d			call addatohl 
0b26 cd 85 1f			call loadwordinhl 
0b29			 
0b29				; forth will write the to string when pushing so move from rom to ram 
0b29			 
0b29 11 c7 eb			ld de, display_active+1 
0b2c 01 02 00			ld bc, 2 
0b2f ed b0			ldir 
0b31			 
0b31 21 c7 eb			ld hl, display_active+1 
0b34 c9				ret 
0b35				 
0b35				 
0b35			 
0b35			 
0b35			;db "|/-\|-\" 
0b35			 
0b35			actseq: 
0b35			 
0b35 43 0b		dw spin0 
0b37 45 0b		dw spin1 
0b39 47 0b		dw spin2 
0b3b 49 0b		dw spin3 
0b3d 47 0b		dw spin2 
0b3f 45 0b		dw spin1 
0b41 43 0b		dw spin0 
0b43			 
0b43 .. 00		spin0: db " ", 0 
0b45 .. 00		spin1: db "-", 0 
0b47 .. 00		spin2: db "+", 0 
0b49 .. 00		spin3: db "#", 0 
0b4b			 
0b4b			 
0b4b			; information window 
0b4b			 
0b4b			; pass hl with 1st string to display 
0b4b			; pass de with 2nd string to display 
0b4b			 
0b4b			info_panel: 
0b4b e5				push hl 
0b4c			 
0b4c 2a cc eb			ld hl, (display_fb_active) 
0b4f e5				push hl    ; future de destination 
0b50 21 b1 ed				ld hl, display_fb0 
0b53 22 cc eb				ld (display_fb_active), hl 
0b56			 
0b56			;	call clear_display 
0b56			 
0b56				if BASE_CPM 
0b56 3e 2e			ld a, '.' 
0b58				else 
0b58				ld a, 165 
0b58				endif 
0b58 cd bf 0b			call fill_display 
0b5b			 
0b5b			 
0b5b 3e 55			ld a, display_row_3 + 5 
0b5d cd cd 0b			call str_at_display 
0b60			 
0b60 e1				pop hl 
0b61 d1				pop de 
0b62			 
0b62 e5				push hl 
0b63			 
0b63			 
0b63 3e 2d			ld a, display_row_2 + 5 
0b65 cd cd 0b			call str_at_display 
0b68			 
0b68			 
0b68 cd dd 0b			call update_display 
0b6b cd ce 1b			call next_page_prompt 
0b6e cd ba 0b			call clear_display 
0b71			 
0b71				 
0b71 21 10 ed				ld hl, display_fb1 
0b74 22 cc eb				ld (display_fb_active), hl 
0b77 cd dd 0b			call update_display 
0b7a			 
0b7a e1				pop hl 
0b7b			 
0b7b c9				ret 
0b7c			 
0b7c			 
0b7c			 
0b7c			 
0b7c			; TODO windowing? 
0b7c			 
0b7c			; TODO scroll line up 
0b7c			 
0b7c			scroll_up: 
0b7c			 
0b7c e5				push hl 
0b7d d5				push de 
0b7e c5				push bc 
0b7f			 
0b7f				; get frame buffer  
0b7f			 
0b7f 2a cc eb			ld hl, (display_fb_active) 
0b82 e5				push hl    ; future de destination 
0b83			 
0b83 11 28 00			ld  de, display_cols 
0b86 19				add hl, de 
0b87			 
0b87 d1				pop de 
0b88			 
0b88				;ex de, hl 
0b88 01 9f 00			ld bc, display_fb_len -1  
0b8b			;if DEBUG_FORTH_WORDS 
0b8b			;	DMARK "SCL" 
0b8b			;	CALLMONITOR 
0b8b			;endif	 
0b8b ed b0			ldir 
0b8d			 
0b8d				; wipe bottom row 
0b8d			 
0b8d			 
0b8d 2a cc eb			ld hl, (display_fb_active) 
0b90 11 a0 00			ld de, display_cols*display_rows 
0b93 19				add hl, de 
0b94 06 28			ld b, display_cols 
0b96 3e 20			ld a, ' ' 
0b98			.scwipe: 
0b98 77				ld (hl), a 
0b99 2b				dec hl 
0b9a 10 fc			djnz .scwipe 
0b9c			 
0b9c				;pop hl 
0b9c			 
0b9c c1				pop bc 
0b9d d1				pop de 
0b9e e1				pop hl 
0b9f			 
0b9f c9				ret 
0ba0			 
0ba0			 
0ba0			;scroll_upo: 
0ba0			;	ld de, display_row_1 
0ba0			 ;	ld hl, display_row_2 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_2 
0ba0			 ;	ld hl, display_row_3 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_3 
0ba0			 ;	ld hl, display_row_4 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			 
0ba0			; TODO clear row 4 
0ba0			 
0ba0			;	ret 
0ba0			 
0ba0				 
0ba0			scroll_down: 
0ba0			 
0ba0 e5				push hl 
0ba1 d5				push de 
0ba2 c5				push bc 
0ba3			 
0ba3				; get frame buffer  
0ba3			 
0ba3 2a cc eb			ld hl, (display_fb_active) 
0ba6			 
0ba6 11 9f 00			ld de, display_fb_len - 1 
0ba9 19				add hl, de 
0baa			 
0baa e5			push hl    ; future de destination 
0bab			 
0bab 11 28 00			ld  de, display_cols 
0bae ed 52			sbc hl, de 
0bb0			 
0bb0			 
0bb0 d1				pop de 
0bb1			 
0bb1			;	ex de, hl 
0bb1 01 9f 00			ld bc, display_fb_len -1  
0bb4			 
0bb4			 
0bb4				 
0bb4			 
0bb4 ed b0			ldir 
0bb6			 
0bb6				; wipe bottom row 
0bb6			 
0bb6			 
0bb6			;	ld hl, (display_fb_active) 
0bb6			;;	ld de, display_cols*display_rows 
0bb6			;;	add hl, de 
0bb6			;	ld b, display_cols 
0bb6			;	ld a, ' ' 
0bb6			;.scwiped: 
0bb6			;	ld (hl), a 
0bb6			;	dec hl 
0bb6			;	djnz .scwiped 
0bb6			 
0bb6				;pop hl 
0bb6			 
0bb6 c1				pop bc 
0bb7 d1				pop de 
0bb8 e1				pop hl 
0bb9			 
0bb9 c9				ret 
0bba			;scroll_down: 
0bba			;	ld de, display_row_4 
0bba			;	ld hl, display_row_3 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_3 
0bba			; 	ld hl, display_row_2 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_2 
0bba			;	ld hl, display_row_1 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;;; TODO clear row 1 
0bba			;	ret 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			; clear active frame buffer 
0bba			 
0bba			clear_display: 
0bba 3e 20			ld a, ' ' 
0bbc c3 bf 0b			jp fill_display 
0bbf			 
0bbf			; fill active frame buffer with a char in A 
0bbf			 
0bbf			fill_display: 
0bbf 06 a0			ld b,display_fb_len 
0bc1 2a cc eb			ld hl, (display_fb_active) 
0bc4 77			.fd1:	ld (hl),a 
0bc5 23				inc hl 
0bc6 10 fc			djnz .fd1 
0bc8 23				inc hl 
0bc9 3e 00			ld a,0 
0bcb 77				ld (hl),a 
0bcc			 
0bcc			 
0bcc c9				ret 
0bcd			; Write string (DE) at pos (A) to active frame buffer 
0bcd			 
0bcd 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bd0 06 00					ld b,0 
0bd2 4f					ld c,a 
0bd3 09					add hl,bc 
0bd4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd5 b7			            OR   A              ;Null terminator? 
0bd6 c8			            RET  Z              ;Yes, so finished 
0bd7 77					ld (hl),a 
0bd8 23				inc hl 
0bd9 13			            INC  DE             ;Point to next character 
0bda 18 f8		            JR   .sad1     ;Repeat 
0bdc c9					ret 
0bdd			 
0bdd			; using current frame buffer write to physical display 
0bdd			 
0bdd			update_display: 
0bdd e5				push hl 
0bde 2a cc eb			ld hl, (display_fb_active) 
0be1 cd 6d 64			call write_display 
0be4 e1				pop hl 
0be5 c9				ret 
0be6			 
0be6			; TODO scrolling 
0be6			 
0be6			 
0be6			; move cursor right one char 
0be6			cursor_right: 
0be6			 
0be6				; TODO shift right 
0be6				; TODO if beyond max col 
0be6				; TODO       cursor_next_line 
0be6			 
0be6 c9				ret 
0be7			 
0be7			 
0be7			cursor_next_line: 
0be7				; TODO first char 
0be7				; TODO line down 
0be7				; TODO if past last row 
0be7				; TODO    scroll up 
0be7			 
0be7 c9				ret 
0be8			 
0be8			cursor_left: 
0be8				; TODO shift left 
0be8				; TODO if beyond left  
0be8				; TODO     cursor prev line 
0be8				 
0be8 c9				ret 
0be9			 
0be9			cursor_prev_line: 
0be9				; TODO last char 
0be9				; TODO line up 
0be9				; TODO if past first row 
0be9				; TODO   scroll down 
0be9			 
0be9 c9				ret 
0bea			 
0bea			 
0bea			cout: 
0bea				; A - char 
0bea c9				ret 
0beb			 
0beb			 
0beb			; Display a menu and allow item selection (optional toggle items) 
0beb			; 
0beb			; format: 
0beb			; hl pointer to word array with zero term for items 
0beb			; e.g.    db item1 
0beb			;         db .... 
0beb			;         db 0 
0beb			; 
0beb			; a = starting menu item  
0beb			; 
0beb			; de = pointer item toggle array   (todo) 
0beb			; 
0beb			; returns item selected in a 1-... 
0beb			; returns 0 if back button pressed 
0beb			; 
0beb			; NOTE: Uses system frame buffer to display 
0beb			; 
0beb			; LEFT, Q = go back 
0beb			; RIGHT, SPACE, CR = select 
0beb			; UP, A - Up 
0beb			; DOWN, Z - Down 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			menu: 
0beb			 
0beb					; keep array pointer 
0beb			 
0beb 22 73 ea				ld (store_tmp1), hl 
0bee 32 71 ea				ld (store_tmp2), a 
0bf1			 
0bf1					; check for key bounce 
0bf1			 
0bf1			if BASE_KEV 
0bf1			 
0bf1			.mbounce:	call cin 
0bf1					cp 0 
0bf1					jr nz, .mbounce 
0bf1			endif 
0bf1					; for ease use ex 
0bf1			 
0bf1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf1 21 b1 ed				ld hl, display_fb0 
0bf4 22 cc eb				ld (display_fb_active), hl 
0bf7			 
0bf7 cd ba 0b		.mloop:		call clear_display 
0bfa cd dd 0b				call update_display 
0bfd			 
0bfd					; draw selection id '>' at 1 
0bfd			 
0bfd					; init start of list display 
0bfd			 
0bfd 3e 05				ld a, 5 
0bff 32 6f ea				ld (store_tmp3), a   ; display row count 
0c02 3a 71 ea				ld a,( store_tmp2) 
0c05 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c08			 
0c08					 
0c08			.mitem:	 
0c08			 
0c08			 
0c08 3a 72 ea				ld a,(store_tmp2+1) 
0c0b 6f					ld l, a 
0c0c 26 00				ld h, 0 
0c0e 29					add hl, hl 
0c0f ed 5b 73 ea			ld de, (store_tmp1) 
0c13 19					add hl, de 
0c14 7e					ld a, (hl) 
0c15 23					inc hl 
0c16 66					ld h,(hl) 
0c17 6f					ld l, a 
0c18			 
0c18 cd 10 0e				call ishlzero 
0c1b 28 1a				jr z, .mdone 
0c1d			 
0c1d eb					ex de, hl 
0c1e 3a 6f ea				ld a, (store_tmp3) 
0c21 cd cd 0b				call str_at_display 
0c24					 
0c24			 
0c24					; next item 
0c24 3a 72 ea				ld a, (store_tmp2+1) 
0c27 3c					inc a 
0c28 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c2b			 
0c2b			 		; next row 
0c2b			 
0c2b 3a 6f ea				ld a, (store_tmp3) 
0c2e c6 28				add display_cols 
0c30 32 6f ea				ld (store_tmp3), a 
0c33			 
0c33					; at end of screen? 
0c33			 
0c33 fe 10				cp display_rows*4 
0c35 20 d1				jr nz, .mitem 
0c37			 
0c37			 
0c37			.mdone: 
0c37 cd 10 0e				call ishlzero 
0c3a 28 08				jr z, .nodn 
0c3c			 
0c3c 3e 78				ld a, display_row_4 
0c3e 11 bd 0c				ld de, .mdown 
0c41 cd cd 0b				call str_at_display 
0c44			 
0c44					; draw options to fill the screens with active item on line 1 
0c44					; if current option is 2 or more then display ^ in top 
0c44			 
0c44 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c47 fe 00				cp 0 
0c49 28 08				jr z, .noup 
0c4b			 
0c4b 3e 00				ld a, 0 
0c4d 11 bb 0c				ld de, .mup 
0c50 cd cd 0b				call str_at_display 
0c53			 
0c53 3e 02		.noup:		ld a, 2 
0c55 11 b9 0c				ld de, .msel 
0c58 cd cd 0b				call str_at_display 
0c5b			 
0c5b					; if current option + 1 is not null then display V in bottom 
0c5b					; get key 
0c5b cd dd 0b				call update_display 
0c5e			 
0c5e			 
0c5e					; handle key 
0c5e			 
0c5e cd 1f 65				call cin_wait 
0c61			 
0c61 fe 05				cp KEY_UP 
0c63 28 2b				jr z, .mgoup 
0c65 fe 61				cp 'a' 
0c67 28 27				jr z, .mgoup 
0c69 fe 0a				cp KEY_DOWN 
0c6b 28 32				jr z, .mgod 
0c6d fe 7a				cp 'z' 
0c6f 28 2e				jr z, .mgod 
0c71 fe 20				cp ' ' 
0c73 28 34				jr z, .goend 
0c75 fe 0c				cp KEY_RIGHT 
0c77 28 30				jr z, .goend 
0c79 fe 0d				cp KEY_CR 
0c7b 28 2c				jr z, .goend 
0c7d fe 71				cp 'q' 
0c7f 28 0b				jr z, .goback 
0c81			 
0c81 fe 0b				cp KEY_LEFT 
0c83 28 07				jr z, .goback 
0c85 fe 08				cp KEY_BS 
0c87 28 03				jr z, .goback 
0c89 c3 f7 0b				jp .mloop 
0c8c			 
0c8c			.goback: 
0c8c 3e 00			ld a, 0 
0c8e 18 1d			jr .goend2 
0c90			 
0c90				; move up one 
0c90			.mgoup: 
0c90 3a 71 ea				ld a, (store_tmp2) 
0c93 fe 00				cp 0 
0c95 ca f7 0b				jp z, .mloop 
0c98 3d					dec a 
0c99 32 71 ea				ld (store_tmp2), a 
0c9c c3 f7 0b				jp .mloop 
0c9f			 
0c9f				; move down one 
0c9f			.mgod: 
0c9f 3a 71 ea				ld a, (store_tmp2) 
0ca2 3c					inc a 
0ca3 32 71 ea				ld (store_tmp2), a 
0ca6 c3 f7 0b				jp .mloop 
0ca9			 
0ca9			 
0ca9			.goend: 
0ca9					; get selected item number 
0ca9			 
0ca9 3a 71 ea				ld a, (store_tmp2) 
0cac 3c					inc a 
0cad			 
0cad			.goend2: 
0cad f5					push af 
0cae			 
0cae					; restore active fb 
0cae					; TODO BUG assumes fb1 
0cae			 
0cae 21 10 ed				ld hl, display_fb1 
0cb1 22 cc eb				ld (display_fb_active), hl 
0cb4			 
0cb4					; restore main regs 
0cb4			 
0cb4			 
0cb4 cd dd 0b				call update_display 
0cb7			 
0cb7 f1					pop af 
0cb8			 
0cb8 c9				ret 
0cb9			 
0cb9 .. 00		.msel:   db ">",0 
0cbb .. 00		.mup:   db "^",0 
0cbd .. 00		.mdown:   db "v",0 
0cbf			 
0cbf			 
0cbf			; eof 
0cbf			 
# End of file firmware_display.asm
0cbf			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbf			; random number generators 
0cbf			 
0cbf			 
0cbf			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbf			 
0cbf			 
0cbf			;-----> Generate a random number 
0cbf			; output a=answer 0<=a<=255 
0cbf			; all registers are preserved except: af 
0cbf			random: 
0cbf e5			        push    hl 
0cc0 d5			        push    de 
0cc1 2a ab eb		        ld      hl,(randData) 
0cc4 ed 5f		        ld      a,r 
0cc6 57			        ld      d,a 
0cc7 5e			        ld      e,(hl) 
0cc8 19			        add     hl,de 
0cc9 85			        add     a,l 
0cca ac			        xor     h 
0ccb 22 ab eb		        ld      (randData),hl 
0cce d1			        pop     de 
0ccf e1			        pop     hl 
0cd0 c9			        ret 
0cd1			 
0cd1			 
0cd1			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd1			 
0cd1			 
0cd1			 
0cd1			;------LFSR------ 
0cd1			;James Montelongo 
0cd1			;optimized by Spencer Putt 
0cd1			;out: 
0cd1			; a = 8 bit random number 
0cd1			RandLFSR: 
0cd1 21 b1 eb		        ld hl,LFSRSeed+4 
0cd4 5e			        ld e,(hl) 
0cd5 23			        inc hl 
0cd6 56			        ld d,(hl) 
0cd7 23			        inc hl 
0cd8 4e			        ld c,(hl) 
0cd9 23			        inc hl 
0cda 7e			        ld a,(hl) 
0cdb 47			        ld b,a 
0cdc cb 13		        rl e  
0cde cb 12			rl d 
0ce0 cb 11		        rl c  
0ce2 17				rla 
0ce3 cb 13		        rl e  
0ce5 cb 12			rl d 
0ce7 cb 11		        rl c  
0ce9 17				rla 
0cea cb 13		        rl e  
0cec cb 12			rl d 
0cee cb 11		        rl c  
0cf0 17				rla 
0cf1 67			        ld h,a 
0cf2 cb 13		        rl e  
0cf4 cb 12			rl d 
0cf6 cb 11		        rl c  
0cf8 17				rla 
0cf9 a8			        xor b 
0cfa cb 13		        rl e  
0cfc cb 12			rl d 
0cfe ac			        xor h 
0cff a9			        xor c 
0d00 aa			        xor d 
0d01 21 b3 eb		        ld hl,LFSRSeed+6 
0d04 11 b4 eb		        ld de,LFSRSeed+7 
0d07 01 07 00		        ld bc,7 
0d0a ed b8		        lddr 
0d0c 12			        ld (de),a 
0d0d c9			        ret 
0d0e			 
0d0e			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0e			 
0d0e			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0e			 
0d0e			 
0d0e			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0e			 
0d0e			prng16: 
0d0e			;Inputs: 
0d0e			;   (seed1) contains a 16-bit seed value 
0d0e			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0e			;Outputs: 
0d0e			;   HL is the result 
0d0e			;   BC is the result of the LCG, so not that great of quality 
0d0e			;   DE is preserved 
0d0e			;Destroys: 
0d0e			;   AF 
0d0e			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0e			;160cc 
0d0e			;26 bytes 
0d0e 2a a5 eb		    ld hl,(seed1) 
0d11 44			    ld b,h 
0d12 4d			    ld c,l 
0d13 29			    add hl,hl 
0d14 29			    add hl,hl 
0d15 2c			    inc l 
0d16 09			    add hl,bc 
0d17 22 a5 eb		    ld (seed1),hl 
0d1a 2a a3 eb		    ld hl,(seed2) 
0d1d 29			    add hl,hl 
0d1e 9f			    sbc a,a 
0d1f e6 2d		    and %00101101 
0d21 ad			    xor l 
0d22 6f			    ld l,a 
0d23 22 a3 eb		    ld (seed2),hl 
0d26 09			    add hl,bc 
0d27 c9			    ret 
0d28			 
0d28			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d28			 
0d28			rand32: 
0d28			;Inputs: 
0d28			;   (seed1_0) holds the lower 16 bits of the first seed 
0d28			;   (seed1_1) holds the upper 16 bits of the first seed 
0d28			;   (seed2_0) holds the lower 16 bits of the second seed 
0d28			;   (seed2_1) holds the upper 16 bits of the second seed 
0d28			;   **NOTE: seed2 must be non-zero 
0d28			;Outputs: 
0d28			;   HL is the result 
0d28			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d28			;Destroys: 
0d28			;   AF 
0d28			;Tested and passes all CAcert tests 
0d28			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d28			;it has a period of 18,446,744,069,414,584,320 
0d28			;roughly 18.4 quintillion. 
0d28			;LFSR taps: 0,2,6,7  = 11000101 
0d28			;291cc 
0d28			;seed1_0=$+1 
0d28			;    ld hl,12345 
0d28			;seed1_1=$+1 
0d28			;    ld de,6789 
0d28			;    ld b,h 
0d28			;    ld c,l 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    inc l 
0d28			;    add hl,bc 
0d28			;    ld (seed1_0),hl 
0d28			;    ld hl,(seed1_1) 
0d28			;    adc hl,de 
0d28			;    ld (seed1_1),hl 
0d28			;    ex de,hl 
0d28			;seed2_0=$+1 
0d28			;    ld hl,9876 
0d28			;seed2_1=$+1 
0d28			;    ld bc,54321 
0d28			;    add hl,hl \ rl c \ rl b 
0d28			;    ld (seed2_1),bc 
0d28			;    sbc a,a 
0d28			;    and %11000101 
0d28			;    xor l 
0d28			;    ld l,a 
0d28			;    ld (seed2_0),hl 
0d28			;    ex de,hl 
0d28			;    add hl,bc 
0d28			;    ret 
0d28			; 
0d28			 
0d28			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d28			; 20 bytes, 86 cycles (excluding ret) 
0d28			 
0d28			; returns   hl = pseudorandom number 
0d28			; corrupts   a 
0d28			 
0d28			; generates 16-bit pseudorandom numbers with a period of 65535 
0d28			; using the xorshift method: 
0d28			 
0d28			; hl ^= hl << 7 
0d28			; hl ^= hl >> 9 
0d28			; hl ^= hl << 8 
0d28			 
0d28			; some alternative shift triplets which also perform well are: 
0d28			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d28			 
0d28			;  org 32768 
0d28			 
0d28			xrnd: 
0d28 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2b 3e 00		  ld a,0 
0d2d bd			  cp l 
0d2e 20 02		  jr nz, .xrnd1 
0d30 2e 01		  ld l, 1 
0d32			.xrnd1: 
0d32			 
0d32 7c			  ld a,h 
0d33 1f			  rra 
0d34 7d			  ld a,l 
0d35 1f			  rra 
0d36 ac			  xor h 
0d37 67			  ld h,a 
0d38 7d			  ld a,l 
0d39 1f			  rra 
0d3a 7c			  ld a,h 
0d3b 1f			  rra 
0d3c ad			  xor l 
0d3d 6f			  ld l,a 
0d3e ac			  xor h 
0d3f 67			  ld h,a 
0d40			 
0d40 22 a9 eb		  ld (xrandc),hl 
0d43			 
0d43 c9			  ret 
0d44			;  
0d44			 
0d44			 
0d44			;;;; int maths 
0d44			 
0d44			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d44			; Divide 16-bit values (with 16-bit result) 
0d44			; In: Divide BC by divider DE 
0d44			; Out: BC = result, HL = rest 
0d44			; 
0d44			Div16: 
0d44 21 00 00		    ld hl,0 
0d47 78			    ld a,b 
0d48 06 08		    ld b,8 
0d4a			Div16_Loop1: 
0d4a 17			    rla 
0d4b ed 6a		    adc hl,hl 
0d4d ed 52		    sbc hl,de 
0d4f 30 01		    jr nc,Div16_NoAdd1 
0d51 19			    add hl,de 
0d52			Div16_NoAdd1: 
0d52 10 f6		    djnz Div16_Loop1 
0d54 17			    rla 
0d55 2f			    cpl 
0d56 47			    ld b,a 
0d57 79			    ld a,c 
0d58 48			    ld c,b 
0d59 06 08		    ld b,8 
0d5b			Div16_Loop2: 
0d5b 17			    rla 
0d5c ed 6a		    adc hl,hl 
0d5e ed 52		    sbc hl,de 
0d60 30 01		    jr nc,Div16_NoAdd2 
0d62 19			    add hl,de 
0d63			Div16_NoAdd2: 
0d63 10 f6		    djnz Div16_Loop2 
0d65 17			    rla 
0d66 2f			    cpl 
0d67 41			    ld b,c 
0d68 4f			    ld c,a 
0d69 c9			ret 
0d6a			 
0d6a			 
0d6a			;http://z80-heaven.wikidot.com/math 
0d6a			; 
0d6a			;Inputs: 
0d6a			;     DE and A are factors 
0d6a			;Outputs: 
0d6a			;     A is not changed 
0d6a			;     B is 0 
0d6a			;     C is not changed 
0d6a			;     DE is not changed 
0d6a			;     HL is the product 
0d6a			;Time: 
0d6a			;     342+6x 
0d6a			; 
0d6a			Mult16: 
0d6a			 
0d6a 06 08		     ld b,8          ;7           7 
0d6c 21 00 00		     ld hl,0         ;10         10 
0d6f 29			       add hl,hl     ;11*8       88 
0d70 07			       rlca          ;4*8        32 
0d71 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d73 19			         add hl,de   ;--         -- 
0d74 10 f9		       djnz $-5      ;13*7+8     99 
0d76 c9			ret 
0d77			 
0d77			; 
0d77			; Square root of 16-bit value 
0d77			; In:  HL = value 
0d77			; Out:  D = result (rounded down) 
0d77			; 
0d77			;Sqr16: 
0d77			;    ld de,#0040 
0d77			;    ld a,l 
0d77			;    ld l,h 
0d77			;    ld h,d 
0d77			;    or a 
0d77			;    ld b,8 
0d77			;Sqr16_Loop: 
0d77			;    sbc hl,de 
0d77			;    jr nc,Sqr16_Skip 
0d77			;    add hl,de 
0d77			;Sqr16_Skip: 
0d77			;    ccf 
0d77			;    rl d 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    djnz Sqr16_Loop 
0d77			;    ret 
0d77			; 
0d77			; 
0d77			; Divide 8-bit values 
0d77			; In: Divide E by divider C 
0d77			; Out: A = result, B = rest 
0d77			; 
0d77			Div8: 
0d77 af			    xor a 
0d78 06 08		    ld b,8 
0d7a			Div8_Loop: 
0d7a cb 13		    rl e 
0d7c 17			    rla 
0d7d 91			    sub c 
0d7e 30 01		    jr nc,Div8_NoAdd 
0d80 81			    add a,c 
0d81			Div8_NoAdd: 
0d81 10 f7		    djnz Div8_Loop 
0d83 47			    ld b,a 
0d84 7b			    ld a,e 
0d85 17			    rla 
0d86 2f			    cpl 
0d87 c9			    ret 
0d88			 
0d88			; 
0d88			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d88			; In: Multiply A with DE 
0d88			; Out: HL = result 
0d88			; 
0d88			Mult12U: 
0d88 2e 00		    ld l,0 
0d8a 87			    add a,a 
0d8b 30 01		    jr nc,Mult12U_NoAdd0 
0d8d 19			    add hl,de 
0d8e			Mult12U_NoAdd0: 
0d8e 29			    add hl,hl 
0d8f 87			    add a,a 
0d90 30 01		    jr nc,Mult12U_NoAdd1 
0d92 19			    add hl,de 
0d93			Mult12U_NoAdd1: 
0d93 29			    add hl,hl 
0d94 87			    add a,a 
0d95 30 01		    jr nc,Mult12U_NoAdd2 
0d97 19			    add hl,de 
0d98			Mult12U_NoAdd2: 
0d98 29			    add hl,hl 
0d99 87			    add a,a 
0d9a 30 01		    jr nc,Mult12U_NoAdd3 
0d9c 19			    add hl,de 
0d9d			Mult12U_NoAdd3: 
0d9d 29			    add hl,hl 
0d9e 87			    add a,a 
0d9f 30 01		    jr nc,Mult12U_NoAdd4 
0da1 19			    add hl,de 
0da2			Mult12U_NoAdd4: 
0da2 29			    add hl,hl 
0da3 87			    add a,a 
0da4 30 01		    jr nc,Mult12U_NoAdd5 
0da6 19			    add hl,de 
0da7			Mult12U_NoAdd5: 
0da7 29			    add hl,hl 
0da8 87			    add a,a 
0da9 30 01		    jr nc,Mult12U_NoAdd6 
0dab 19			    add hl,de 
0dac			Mult12U_NoAdd6: 
0dac 29			    add hl,hl 
0dad 87			    add a,a 
0dae d0			    ret nc 
0daf 19			    add hl,de 
0db0 c9			    ret 
0db1			 
0db1			; 
0db1			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db1			; In: Multiply A with DE 
0db1			;      Put lowest value in A for most efficient calculation 
0db1			; Out: HL = result 
0db1			; 
0db1			Mult12R: 
0db1 21 00 00		    ld hl,0 
0db4			Mult12R_Loop: 
0db4 cb 3f		    srl a 
0db6 30 01		    jr nc,Mult12R_NoAdd 
0db8 19			    add hl,de 
0db9			Mult12R_NoAdd: 
0db9 cb 23		    sla e 
0dbb cb 12		    rl d 
0dbd b7			    or a 
0dbe c2 b4 0d		    jp nz,Mult12R_Loop 
0dc1 c9			    ret 
0dc2			 
0dc2			; 
0dc2			; Multiply 16-bit values (with 32-bit result) 
0dc2			; In: Multiply BC with DE 
0dc2			; Out: BCHL = result 
0dc2			; 
0dc2			Mult32: 
0dc2 79			    ld a,c 
0dc3 48			    ld c,b 
0dc4 21 00 00		    ld hl,0 
0dc7 06 10		    ld b,16 
0dc9			Mult32_Loop: 
0dc9 29			    add hl,hl 
0dca 17			    rla 
0dcb cb 11		    rl c 
0dcd 30 07		    jr nc,Mult32_NoAdd 
0dcf 19			    add hl,de 
0dd0 ce 00		    adc a,0 
0dd2 d2 d6 0d		    jp nc,Mult32_NoAdd 
0dd5 0c			    inc c 
0dd6			Mult32_NoAdd: 
0dd6 10 f1		    djnz Mult32_Loop 
0dd8 41			    ld b,c 
0dd9 4f			    ld c,a 
0dda c9			    ret 
0ddb			 
0ddb			 
0ddb			 
0ddb			; 
0ddb			; Multiply 8-bit values 
0ddb			; In:  Multiply H with E 
0ddb			; Out: HL = result 
0ddb			; 
0ddb			Mult8: 
0ddb 16 00		    ld d,0 
0ddd 6a			    ld l,d 
0dde 06 08		    ld b,8 
0de0			Mult8_Loop: 
0de0 29			    add hl,hl 
0de1 30 01		    jr nc,Mult8_NoAdd 
0de3 19			    add hl,de 
0de4			Mult8_NoAdd: 
0de4 10 fa		    djnz Mult8_Loop 
0de6 c9			    ret 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			;;http://z80-heaven.wikidot.com/math 
0de7			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de7			; 
0de7			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de7			;     ld a,16        ;7 
0de7			;     ld hl,0        ;10 
0de7			;     jp $+5         ;10 
0de7			;.DivLoop: 
0de7			;       add hl,bc    ;-- 
0de7			;       dec a        ;64 
0de7			;       jr z,.DivLoopEnd        ;86 
0de7			; 
0de7			;       sla e        ;128 
0de7			;       rl d         ;128 
0de7			;       adc hl,hl    ;240 
0de7			;       sbc hl,bc    ;240 
0de7			;       jr nc,.DivLoop ;23|21 
0de7			;       inc e        ;-- 
0de7			;       jp .DivLoop+1 
0de7			; 
0de7			;.DivLoopEnd: 
0de7			 
0de7			;HL_Div_C: 
0de7			;Inputs: 
0de7			;     HL is the numerator 
0de7			;     C is the denominator 
0de7			;Outputs: 
0de7			;     A is the remainder 
0de7			;     B is 0 
0de7			;     C is not changed 
0de7			;     DE is not changed 
0de7			;     HL is the quotient 
0de7			; 
0de7			;       ld b,16 
0de7			;       xor a 
0de7			;         add hl,hl 
0de7			;         rla 
0de7			;         cp c 
0de7			;         jr c,$+4 
0de7			;           inc l 
0de7			;           sub c 
0de7			;         djnz $-7 
0de7			 
0de7			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de7			 
0de7			addatohl: 
0de7 85			    add   a, l    ; A = A+L 
0de8 6f			    ld    l, a    ; L = A+L 
0de9 8c			    adc   a, h    ; A = A+L+H+carry 
0dea 95			    sub   l       ; A = H+carry 
0deb 67			    ld    h, a    ; H = H+carry 
0dec c9			ret 
0ded			 
0ded			addatode: 
0ded 83			    add   a, e    ; A = A+L 
0dee 5f			    ld    e, a    ; L = A+L 
0def 8a			    adc   a, d    ; A = A+L+H+carry 
0df0 93			    sub   e       ; A = H+carry 
0df1 57			    ld    d, a    ; H = H+carry 
0df2 c9			ret 
0df3			 
0df3			 
0df3			addatobc: 
0df3 81			    add   a, c    ; A = A+L 
0df4 4f			    ld    c, a    ; L = A+L 
0df5 88			    adc   a, b    ; A = A+L+H+carry 
0df6 91			    sub   c       ; A = H+carry 
0df7 47			    ld    b, a    ; H = H+carry 
0df8 c9			ret 
0df9			 
0df9			subafromhl: 
0df9			   ; If A=0 do nothing 
0df9			    ; Otherwise flip A's sign. Since 
0df9			    ; the upper byte becomes -1, also 
0df9			    ; substract 1 from H. 
0df9 ed 44		    neg 
0dfb ca 04 0e		    jp    z, Skip 
0dfe 25			    dec   h 
0dff			     
0dff			    ; Now add the low byte as usual 
0dff			    ; Two's complement takes care of 
0dff			    ; ensuring the result is correct 
0dff 85			    add   a, l 
0e00 6f			    ld    l, a 
0e01 8c			    adc   a, h 
0e02 95			    sub   l 
0e03 67			    ld    h, a 
0e04			Skip: 
0e04 c9				ret 
0e05			 
0e05			 
0e05			; compare hl and de 
0e05			; returns:  
0e05			; if hl = de, z=1, s=0, c0=0 
0e05			; if hl > de, z=0, s=0, c=0 
0e05			; if hl < de, z=0, s=1, c=1 
0e05			cmp16:	 
0e05 b7				or a 
0e06 ed 52			sbc hl,de 
0e08 e0				ret po 
0e09 7c				ld a,h 
0e0a 1f				rra 
0e0b ee 40			xor 01000000B 
0e0d 37				scf 
0e0e 8f				adc a,a 
0e0f c9				ret 
0e10			 
0e10			 
0e10			; test if hl contains zero   - A is destroyed 
0e10			 
0e10			ishlzero:    
0e10 b7				or a     ; reset flags 
0e11 7c				ld a, h 
0e12 b5				or l        	 
0e13			 
0e13 c9				ret 
0e14			 
0e14			 
0e14			 
0e14			 
0e14			if FORTH_ENABLE_FLOATMATH 
0e14			;include "float/bbcmath.z80" 
0e14			include "float/lpfpcalc.asm" 
0e14			endif 
0e14			 
0e14			 
0e14			; eof 
0e14			 
# End of file firmware_maths.asm
0e14			include "firmware_strings.asm"   ; string handling  
0e14			 
0e14			 
0e14			; TODO string len 
0e14			; input text string, end on cr with zero term 
0e14			; a offset into frame buffer to start prompt 
0e14			; d is max length 
0e14			; e is display size TODO 
0e14			; c is current cursor position 
0e14			; hl is ptr to where string will be stored 
0e14			 
0e14			 
0e14			; TODO check limit of buffer for new inserts 
0e14			; TODO check insert does not push beyond buffer 
0e14			; TODO scroll in a limited display area 
0e14			; TODO scroll whole screen on page wrap 
0e14			 
0e14			 
0e14			; TODO handle KEY_PREVWORD 
0e14			; TODO handle KEY_NEXTWORD 
0e14			; TODO handle KEY_HOME 
0e14			; TODO handle KEY_END 
0e14			; TODO use LCD cursor? 
0e14			 
0e14 32 64 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e17 81					add c 
0e18 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0e1b 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e1e 79					ld a, c 
0e1f cd e7 0d				call addatohl 
0e22 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e25 7a					ld a,d 
0e26 32 66 ee			        ld (input_size), a       ; save length of input area 
0e29 79					ld a, c 
0e2a 32 55 ee				ld (input_cursor),a      ; init cursor start position  
0e2d 7b					ld a,e 
0e2e 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e31					 
0e31					 
0e31			 
0e31			;		ld a,(input_ptr) 
0e31			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e31			 
0e31			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e31					; init cursor shape if not set by the cin routines 
0e31 21 c1 eb				ld hl, cursor_shape 
0e34 3e ff				ld a, 255 
0e36 77					ld (hl), a 
0e37 23					inc hl 
0e38 3e 00				ld a, 0 
0e3a 77					ld (hl), a 
0e3b			 
0e3b 3e 0f				ld a, CUR_BLINK_RATE 
0e3d 32 60 ee				ld (input_cur_flash), a 
0e40 3e 01				ld a, 1 
0e42 32 5f ee				ld (input_cur_onoff),a 
0e45			 
0e45			;	if DEBUG_INPUT 
0e45			;		push af 
0e45			;		ld a, 'I' 
0e45			;		ld (debug_mark),a 
0e45			;		pop af 
0e45			;		CALLMONITOR 
0e45			;	endif 
0e45			.is1:		; main entry loop 
0e45			 
0e45			 
0e45			 
0e45					; pause 1ms 
0e45			 
0e45 3e 01				ld a, 1 
0e47 cd d7 0a				call aDelayInMS 
0e4a			 
0e4a					; dec flash counter 
0e4a 3a 60 ee				ld a, (input_cur_flash) 
0e4d 3d					dec a 
0e4e 32 60 ee				ld (input_cur_flash), a 
0e51 fe 00				cp 0 
0e53 20 0d				jr nz, .nochgstate 
0e55			 
0e55			 
0e55					; change state 
0e55 3a 5f ee				ld a,(input_cur_onoff) 
0e58 ed 44				neg 
0e5a 32 5f ee				ld (input_cur_onoff),a 
0e5d			 
0e5d			 
0e5d					; reset on change of state 
0e5d 3e 0f				ld a, CUR_BLINK_RATE 
0e5f 32 60 ee				ld (input_cur_flash), a 
0e62			 
0e62			.nochgstate: 
0e62					 
0e62					 
0e62			 
0e62					; display cursor  
0e62			 
0e62			;		ld hl, (input_start) 
0e62			;		ld a, (input_cursor) 
0e62			;		call addatohl 
0e62			 
0e62					; get char under cursor and replace with cursor 
0e62 2a 69 ee		ld hl, (input_ptr) 
0e65			;		ld a, (hl) 
0e65			;		ld (input_under_cursor),a 
0e65			;		ld a, '_' 
0e65			;		ld (hl), a 
0e65			 
0e65					; display string 
0e65			 
0e65 ed 5b 67 ee			ld de, (input_start) 
0e69 3a 64 ee				ld a, (input_at_pos) 
0e6c cd cd 0b				call str_at_display 
0e6f			;	        call update_display 
0e6f			 
0e6f					; find place to put the cursor 
0e6f			;		add h 
0e6f			;		ld l, display_row_1 
0e6f			;		sub l 
0e6f			; (input_at_pos) 
0e6f					;ld c, a 
0e6f			;		ld a, (input_cursor) 
0e6f			;		ld l, (input_at_pos) 
0e6f			;		;ld b, h 
0e6f			;		add l 
0e6f			;		ld (input_at_cursor),a 
0e6f					;ld l,h 
0e6f			 
0e6f			;		ld h, 0 
0e6f			;		ld l,(input_at_pos) 
0e6f			;		ld a, (input_cursor) 
0e6f			;		call addatohl 
0e6f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e6f			;		call subafromhl 
0e6f			;		ld a,l 
0e6f			;		ld (input_at_cursor), a 
0e6f			 
0e6f				if DEBUG_INPUT 
0e6f					ld a, (hardware_diag) 
0e6f					cp 0 
0e6f					jr z, .skip_input_diag 
0e6f			 
0e6f					ld a,(input_at_pos) 
0e6f					ld hl, LFSRSeed 
0e6f					call hexout 
0e6f					ld a, (input_cursor) 
0e6f					ld hl, LFSRSeed+2 
0e6f					call hexout 
0e6f					ld a,(input_at_cursor) 
0e6f					ld hl, LFSRSeed+4 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_onoff) 
0e6f					ld hl, LFSRSeed+6 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_flash) 
0e6f					ld hl, LFSRSeed+8 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_len) 
0e6f					ld hl, LFSRSeed+10 
0e6f					call hexout 
0e6f					ld hl, LFSRSeed+12 
0e6f					ld a, 0 
0e6f					ld (hl),a 
0e6f					ld a, display_row_4 
0e6f					ld de, LFSRSeed 
0e6f					call str_at_display 
0e6f					.skip_input_diag: 
0e6f				endif 
0e6f			 
0e6f					; decide on if we are showing the cursor this time round 
0e6f			 
0e6f 3a 5f ee				ld a, (input_cur_onoff) 
0e72 fe ff				cp 255 
0e74 28 13				jr z, .skipcur 
0e76			 
0e76			 
0e76 3a 62 ee				ld a,(input_at_cursor) 
0e79 11 c1 eb				ld de, cursor_shape 
0e7c cd cd 0b				call str_at_display 
0e7f			 
0e7f					; save length of current input string 
0e7f 2a 67 ee				ld hl, (input_start) 
0e82 cd 45 12				call strlenz 
0e85 7d					ld a,l 
0e86 32 5a ee				ld (input_len),a 
0e89			 
0e89			.skipcur: 
0e89			 
0e89 cd dd 0b			        call update_display 
0e8c					 
0e8c			 
0e8c			 
0e8c					; wait 
0e8c				 
0e8c					; TODO loop without wait to flash the cursor and char under cursor	 
0e8c cd 27 65				call cin    ; _wait 
0e8f			 
0e8f fe 00				cp 0 
0e91 ca 45 0e				jp z, .is1 
0e94			 
0e94					; get ptr to char to input into 
0e94			 
0e94 4f					ld c,a 
0e95 2a 67 ee				ld hl, (input_start) 
0e98 3a 55 ee				ld a, (input_cursor) 
0e9b cd e7 0d				call addatohl 
0e9e 22 69 ee				ld (input_ptr), hl 
0ea1 79					ld a,c 
0ea2			 
0ea2					; replace char under cursor 
0ea2			 
0ea2			;		ld hl, (input_ptr) 
0ea2			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ea2			;		ld (hl), a 
0ea2			 
0ea2			;	if DEBUG_INPUT 
0ea2			;		push af 
0ea2			;		ld a, 'i' 
0ea2			;		ld (debug_mark),a 
0ea2			;		pop af 
0ea2			;		CALLMONITOR 
0ea2			;	endif 
0ea2 fe 0e				cp KEY_HOME 
0ea4 20 0e				jr nz, .iske 
0ea6			 
0ea6 3a 64 ee				ld a, (input_at_pos) 
0ea9 32 62 ee				ld (input_at_cursor),a 
0eac 3e 00				ld a, 0 
0eae 32 55 ee				ld (input_cursor), a 
0eb1 c3 45 0e				jp .is1 
0eb4					 
0eb4 fe 0f		.iske:		cp KEY_END 
0eb6 20 03				jr nz, .isknw 
0eb8 c3 45 0e				jp .is1 
0ebb			 
0ebb fe 06		.isknw:		cp KEY_NEXTWORD 
0ebd 20 1b				jr nz, .iskpw 
0ebf			 
0ebf 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
0ec2 7e					ld a,(hl)	 
0ec3 fe 00				cp 0 
0ec5 ca 45 0e				jp z, .is1    ; end of string 
0ec8 fe 20				cp ' ' 
0eca ca 45 0e				jp z, .is1    ; end of word 
0ecd 23					inc hl 
0ece 22 69 ee				ld (input_ptr), hl 
0ed1 3a 62 ee				ld a, (input_at_cursor) 
0ed4 3c					inc a 
0ed5 32 62 ee				ld (input_at_cursor), a 
0ed8 18 e5				jr .isknwm 
0eda			 
0eda fe 07		.iskpw:		cp KEY_PREVWORD 
0edc 20 1b				jr nz, .iskl 
0ede			.iskpwm:	 
0ede 2a 69 ee				ld hl, (input_ptr) 
0ee1 7e					ld a,(hl)	 
0ee2 fe 00				cp 0  
0ee4 ca 45 0e				jp z, .is1    ; end of string 
0ee7 fe 20				cp ' ' 
0ee9 ca 45 0e				jp z, .is1    ; end of word 
0eec 2b					dec hl 
0eed 22 69 ee				ld (input_ptr), hl 
0ef0 3a 62 ee				ld a, (input_at_cursor) 
0ef3 3d					dec a 
0ef4 32 62 ee				ld (input_at_cursor), a 
0ef7 18 e5				jr .iskpwm 
0ef9			 
0ef9			 
0ef9 fe 0b		.iskl:		cp KEY_LEFT 
0efb 20 27				jr nz, .isk1 
0efd			 
0efd 3a 55 ee				ld a, (input_cursor) 
0f00			 
0f00 fe 00				cp 0 
0f02 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f05			 
0f05 3d					dec  a 		; TODO check underflow 
0f06 32 55 ee				ld (input_cursor), a 
0f09			 
0f09 2a 69 ee				ld hl, (input_ptr) 
0f0c 2b					dec hl 
0f0d 22 69 ee				ld (input_ptr), hl 
0f10					 
0f10 3a 62 ee				ld a, (input_at_cursor) 
0f13 3d					dec a 
0f14 32 62 ee				ld (input_at_cursor), a 
0f17			 
0f17 3e 01				ld a, 1		; show cursor moving 
0f19 32 5f ee				ld (input_cur_onoff),a 
0f1c 3e 0f				ld a, CUR_BLINK_RATE 
0f1e 32 60 ee				ld (input_cur_flash), a 
0f21			 
0f21 c3 45 0e				jp .is1 
0f24			 
0f24 fe 0c		.isk1:		cp KEY_RIGHT 
0f26 20 2a				jr nz, .isk2 
0f28			 
0f28 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f2b 5f					ld e,a 
0f2c 3a 55 ee				ld a, (input_cursor) 
0f2f bb					cp e 
0f30 ca 45 0e				jp z, .is1		; at the end of string so dont go right 
0f33			 
0f33 3c					inc  a 		; TODO check overflow 
0f34 32 55 ee				ld (input_cursor), a 
0f37			 
0f37 3a 62 ee				ld a, (input_at_cursor) 
0f3a 3c					inc a 
0f3b 32 62 ee				ld (input_at_cursor), a 
0f3e			 
0f3e 2a 69 ee				ld hl, (input_ptr) 
0f41 23					inc hl 
0f42 22 69 ee				ld (input_ptr), hl 
0f45			 
0f45 3e 01				ld a, 1		; show cursor moving 
0f47 32 5f ee				ld (input_cur_onoff),a 
0f4a 3e 0f				ld a, CUR_BLINK_RATE 
0f4c 32 60 ee				ld (input_cur_flash), a 
0f4f			 
0f4f c3 45 0e				jp .is1 
0f52			 
0f52 fe 05		.isk2:		cp KEY_UP 
0f54			 
0f54 20 26				jr nz, .isk3 
0f56			 
0f56					; swap last command with the current on 
0f56			 
0f56					; move cursor to start of string 
0f56 2a 67 ee				ld hl, (input_start) 
0f59 22 69 ee				ld (input_ptr), hl 
0f5c			 
0f5c 3a 64 ee				ld a, (input_at_pos) 
0f5f 32 62 ee				ld (input_at_cursor), a 
0f62			 
0f62 3e 00				ld a, 0 
0f64 32 55 ee				ld (input_cursor), a 
0f67					 
0f67					; swap input and last command buffers 
0f67			 
0f67 21 e8 e5				ld hl, os_cli_cmd 
0f6a 11 e7 e6				ld de, os_last_cmd 
0f6d 06 ff				ld b, 255 
0f6f 7e			.swap1:		ld a, (hl) 
0f70 4f					ld c,a 
0f71 1a					ld a, (de) 
0f72 77					ld (hl), a 
0f73 79					ld a,c 
0f74 12					ld (de),a 
0f75 23					inc hl 
0f76 13					inc de 
0f77 10 f6				djnz .swap1 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			 
0f79 c3 45 0e				jp .is1 
0f7c			 
0f7c fe 08		.isk3:		cp KEY_BS 
0f7e 20 3c				jr nz, .isk4 
0f80			 
0f80 3a 55 ee				ld a, (input_cursor) 
0f83			 
0f83 fe 00				cp 0 
0f85 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f88			 
0f88 3d					dec  a 		; TODO check underflow 
0f89 32 55 ee				ld (input_cursor), a 
0f8c			 
0f8c					; hl is source 
0f8c					; de needs to be source - 1 
0f8c			 
0f8c			;		ld a, 0 
0f8c			;		dec hl 
0f8c			;		ld (hl), a 
0f8c			 
0f8c 2a 69 ee				ld hl, (input_ptr) 
0f8f 2b					dec hl 
0f90 22 69 ee				ld (input_ptr), hl 
0f93			 
0f93					; shift all data 
0f93			 
0f93 e5					push hl 
0f94 23					inc hl 
0f95 d1					pop de 
0f96 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f99 4f					ld c,a 
0f9a 06 00				ld b,0 
0f9c ed b0				ldir  
0f9e			 
0f9e			 
0f9e			 
0f9e			 
0f9e 3a 62 ee				ld a, (input_at_cursor) 
0fa1 3d					dec a 
0fa2 32 62 ee				ld (input_at_cursor), a 
0fa5			 
0fa5			 
0fa5 3e 01				ld a, 1		; show cursor moving 
0fa7 32 5f ee				ld (input_cur_onoff),a 
0faa 3e 0f				ld a, CUR_BLINK_RATE 
0fac 32 60 ee				ld (input_cur_flash), a 
0faf			 
0faf					; remove char 
0faf 3a 62 ee				ld a, (input_at_cursor) 
0fb2 3c					inc a 
0fb3 11 3d 10				ld de,.iblank 
0fb6 cd cd 0b				call str_at_display 
0fb9			 
0fb9 c3 45 0e				jp .is1 
0fbc			 
0fbc fe 0d		.isk4:		cp KEY_CR 
0fbe 28 6c				jr z, .endinput 
0fc0			 
0fc0					; else add the key press to the end 
0fc0			 
0fc0 4f					ld c, a			; save key pressed 
0fc1			 
0fc1 7e					ld a,(hl)		; get what is currently under char 
0fc2			 
0fc2 fe 00				cp 0			; we are at the end of the string 
0fc4 20 2f				jr nz, .onchar 
0fc6					 
0fc6					; add a char to the end of the string 
0fc6				 
0fc6 71					ld (hl),c 
0fc7 23					inc hl 
0fc8			;		ld a,' ' 
0fc8			;		ld (hl),a 
0fc8			;		inc hl 
0fc8 3e 00				ld a,0 
0fca 77					ld (hl),a 
0fcb 2b					dec hl 
0fcc			 
0fcc 3a 55 ee				ld a, (input_cursor) 
0fcf 3c					inc a				; TODO check max string length and scroll  
0fd0 32 55 ee				ld (input_cursor), a		; inc cursor pos 
0fd3							 
0fd3 3a 62 ee				ld a, (input_at_cursor) 
0fd6 3c					inc a 
0fd7 32 62 ee				ld (input_at_cursor), a 
0fda			 
0fda 2a 69 ee				ld hl, (input_ptr) 
0fdd 23					inc hl 
0fde 22 69 ee				ld (input_ptr), hl 
0fe1			 
0fe1 2a 69 ee				ld hl, (input_ptr) 
0fe4 23					inc hl 
0fe5 22 69 ee				ld (input_ptr), hl 
0fe8			;	if DEBUG_INPUT 
0fe8			;		push af 
0fe8			;		ld a, '+' 
0fe8			;		ld (debug_mark),a 
0fe8			;		pop af 
0fe8			;		CALLMONITOR 
0fe8			;	endif 
0fe8 3e 01				ld a, 1		; show cursor moving 
0fea 32 5f ee				ld (input_cur_onoff),a 
0fed 3e 0f				ld a, CUR_BLINK_RATE 
0fef 32 60 ee				ld (input_cur_flash), a 
0ff2 c3 45 0e				jp .is1 
0ff5					 
0ff5			 
0ff5			 
0ff5					; if on a char then insert 
0ff5			.onchar: 
0ff5			 
0ff5					; TODO over flow check: make sure insert does not blow out buffer 
0ff5			 
0ff5					; need to do some maths to use lddr 
0ff5			 
0ff5 e5					push hl   ; save char pos 
0ff6 c5					push bc 
0ff7			 
0ff7 2a 67 ee				ld hl, (input_start) 
0ffa 3a 5a ee				ld a, (input_len) 
0ffd cd e7 0d				call addatohl  		; end of string 
1000 23					inc hl 
1001 23					inc hl		; past zero term 
1002 e5					push hl 
1003 23					inc hl 
1004 e5					push hl  
1005			 
1005								; start and end of lddr set, now how much to move? 
1005			 
1005							 
1005 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1008 47					ld b,a 
1009 3a 5a ee				ld a,(input_len) 
100c 5f					ld e,a 
100d 90					sub b 
100e 3c					inc a		;?? 
100f 3c					inc a		;?? 
1010 3c					inc a		;?? 
1011			 
1011 06 00				ld b,0 
1013 4f					ld c,a 
1014			 
1014				if DEBUG_INPUT 
1014					push af 
1014					ld a, 'i' 
1014					ld (debug_mark),a 
1014					pop af 
1014			;		CALLMONITOR 
1014				endif 
1014 d1					pop de 
1015 e1					pop hl 
1016				if DEBUG_INPUT 
1016					push af 
1016					ld a, 'I' 
1016					ld (debug_mark),a 
1016					pop af 
1016			;		CALLMONITOR 
1016				endif 
1016 ed b8				lddr 
1018				 
1018			 
1018			 
1018					; TODO have a key for insert/overwrite mode???? 
1018 c1					pop bc 
1019 e1					pop hl 
101a 71					ld (hl), c		; otherwise overwrite current char 
101b					 
101b			 
101b			 
101b			 
101b 3a 55 ee				ld a, (input_cursor) 
101e 3c					inc  a 		; TODO check overflow 
101f 32 55 ee				ld (input_cursor), a 
1022			 
1022 3a 62 ee				ld a, (input_at_cursor) 
1025 3c					inc a 
1026 32 62 ee				ld (input_at_cursor), a 
1029			 
1029 c3 45 0e				jp .is1 
102c			 
102c			.endinput:	; TODO look for end of string 
102c			 
102c					; add trailing space for end of token 
102c			 
102c 2a 67 ee				ld hl, (input_start) 
102f 3a 5a ee				ld a,(input_len) 
1032 cd e7 0d				call addatohl 
1035 3e 20				ld a, ' ' 
1037 77					ld (hl),a 
1038					; TODO eof of parse marker 
1038			 
1038 23					inc hl 
1039 3e 00				ld a, 0 
103b 77					ld (hl),a 
103c			 
103c			 
103c c9					ret 
103d			 
103d .. 00		.iblank: db " ",0 
103f			 
103f			 
103f 32 64 ee		input_str_prev:	ld (input_at_pos), a 
1042 22 67 ee				ld (input_start), hl 
1045 3e 01				ld a,1			; add cursor 
1047 77					ld (hl),a 
1048 23					inc hl 
1049 3e 00				ld a,0 
104b 77					ld (hl),a 
104c 22 69 ee				ld (input_ptr), hl 
104f 7a					ld a,d 
1050 32 66 ee				ld (input_size), a 
1053 3e 00				ld a,0 
1055 32 55 ee				ld (input_cursor),a 
1058			.instr1:	 
1058			 
1058					; TODO do block cursor 
1058					; TODO switch cursor depending on the modifer key 
1058			 
1058					; update cursor shape change on key hold 
1058			 
1058 2a 69 ee				ld hl, (input_ptr) 
105b 2b					dec hl 
105c 3a c1 eb				ld a,(cursor_shape) 
105f 77					ld (hl), a 
1060			 
1060					; display entered text 
1060 3a 64 ee				ld a,(input_at_pos) 
1063 cd 3c 64		            	CALL fLCD_Pos       ;Position cursor to location in A 
1066 ed 5b 67 ee	            	LD   de, (input_start) 
106a cd 31 64		            	CALL fLCD_Str       ;Display string pointed to by DE 
106d			 
106d cd 27 65				call cin 
1070 fe 00				cp 0 
1072 28 e4				jr z, .instr1 
1074			 
1074					; proecess keyboard controls first 
1074			 
1074 2a 69 ee				ld hl,(input_ptr) 
1077			 
1077 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1079 28 5a				jr z, .instrcr 
107b			 
107b fe 08				cp KEY_BS 	; back space 
107d 20 0f				jr nz, .instr2 
107f					; process back space 
107f			 
107f					; TODO stop back space if at start of string 
107f 2b					dec hl 
1080 2b					dec hl ; to over write cursor 
1081 3a c1 eb				ld a,(cursor_shape) 
1084					;ld a,0 
1084 77					ld (hl),a 
1085 23					inc hl 
1086 3e 20				ld a," " 
1088 77					ld (hl),a 
1089 22 69 ee				ld (input_ptr),hl 
108c					 
108c			 
108c 18 ca				jr .instr1 
108e			 
108e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1090 20 06				jr nz, .instr3 
1092 2b					dec hl 
1093 22 69 ee				ld (input_ptr),hl 
1096 18 c0				jr .instr1 
1098				 
1098 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
109a 20 06				jr nz, .instr4 
109c 23					inc hl 
109d 22 69 ee				ld (input_ptr),hl 
10a0 18 b6				jr .instr1 
10a2			 
10a2 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
10a4 20 06				jr nz, .instr5 
10a6 2b					dec hl 
10a7 22 69 ee				ld (input_ptr),hl 
10aa 18 ac				jr .instr1 
10ac			 
10ac fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10ae 20 06				jr nz, .instr6 
10b0 2b					dec hl 
10b1 22 69 ee				ld (input_ptr),hl 
10b4 18 a2				jr .instr1 
10b6 fe 05		.instr6:        cp KEY_UP      ; recall last command 
10b8 20 0b				jr nz, .instrnew 
10ba			 
10ba 21 c1 e2			ld hl, scratch 
10bd 11 e7 e6			ld de, os_last_cmd 
10c0 cd de 10			call strcpy 
10c3 18 93				jr .instr1 
10c5			 
10c5			 
10c5			.instrnew:	; no special key pressed to see if we have room to store it 
10c5			 
10c5					; TODO do string size test 
10c5			 
10c5 2b					dec hl ; to over write cursor 
10c6 77					ld (hl),a 
10c7 23					inc hl 
10c8 3a c1 eb				ld a,(cursor_shape) 
10cb 77					ld (hl),a 
10cc 23					inc hl 
10cd 3e 00				ld a,0 
10cf 77					ld (hl),a 
10d0			 
10d0 22 69 ee				ld (input_ptr),hl 
10d3					 
10d3 18 83				jr .instr1 
10d5 2b			.instrcr:	dec hl		; remove cursor 
10d6 3e 20				ld a,' '	; TODO add a trailing space for safety 
10d8 77					ld (hl),a 
10d9 23					inc hl 
10da 3e 00				ld a,0 
10dc 77					ld (hl),a 
10dd			 
10dd			 
10dd					; if at end of line scroll up    
10dd					; TODO detecting only end of line 4 for scroll up  
10dd			 
10dd					;ld   
10dd			 
10dd c9					ret 
10de			 
10de			 
10de			; strcpy hl = dest, de source 
10de			 
10de 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10df b7			            OR   A              ;Null terminator? 
10e0 c8			            RET  Z              ;Yes, so finished 
10e1 1a					ld a,(de) 
10e2 77					ld (hl),a 
10e3 13			            INC  DE             ;Point to next character 
10e4 23					inc hl 
10e5 18 f7		            JR   strcpy       ;Repeat 
10e7 c9					ret 
10e8			 
10e8			 
10e8			; TODO string_at  
10e8			; pass string which starts with lcd offset address and then null term string 
10e8			 
10e8			; TODO string to dec 
10e8			; TODO string to hex 
10e8			; TODO byte to string hex 
10e8			; TODO byte to string dec 
10e8			 
10e8			 
10e8			 
10e8			; from z80uartmonitor 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10e8			; pass hl for where to put the text 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8 c5			hexout:	PUSH BC 
10e9 f5					PUSH AF 
10ea 47					LD B, A 
10eb					; Upper nybble 
10eb cb 3f				SRL A 
10ed cb 3f				SRL A 
10ef cb 3f				SRL A 
10f1 cb 3f				SRL A 
10f3 cd 03 11				CALL tohex 
10f6 77					ld (hl),a 
10f7 23					inc hl	 
10f8					 
10f8					; Lower nybble 
10f8 78					LD A, B 
10f9 e6 0f				AND 0FH 
10fb cd 03 11				CALL tohex 
10fe 77					ld (hl),a 
10ff 23					inc hl	 
1100					 
1100 f1					POP AF 
1101 c1					POP BC 
1102 c9					RET 
1103					 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			tohex: 
1103 e5					PUSH HL 
1104 d5					PUSH DE 
1105 16 00				LD D, 0 
1107 5f					LD E, A 
1108 21 10 11				LD HL, .DATA 
110b 19					ADD HL, DE 
110c 7e					LD A, (HL) 
110d d1					POP DE 
110e e1					POP HL 
110f c9					RET 
1110			 
1110			.DATA: 
1110 30					DEFB	30h	; 0 
1111 31					DEFB	31h	; 1 
1112 32					DEFB	32h	; 2 
1113 33					DEFB	33h	; 3 
1114 34					DEFB	34h	; 4 
1115 35					DEFB	35h	; 5 
1116 36					DEFB	36h	; 6 
1117 37					DEFB	37h	; 7 
1118 38					DEFB	38h	; 8 
1119 39					DEFB	39h	; 9 
111a 41					DEFB	41h	; A 
111b 42					DEFB	42h	; B 
111c 43					DEFB	43h	; C 
111d 44					DEFB	44h	; D 
111e 45					DEFB	45h	; E 
111f 46					DEFB	46h	; F 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1120			;;    subtract $30, if result > 9 then subtract $7 more 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			atohex: 
1120 d6 30				SUB $30 
1122 fe 0a				CP 10 
1124 f8					RET M		; If result negative it was 0-9 so we're done 
1125 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1127 c9					RET		 
1128			 
1128			 
1128			 
1128			 
1128			; Get 2 ASCII characters as hex byte from pointer in hl 
1128			 
1128			BYTERD: 
1128 16 00			LD	D,00h		;Set up 
112a cd 32 11			CALL	HEXCON		;Get byte and convert to hex 
112d 87				ADD	A,A		;First nibble so 
112e 87				ADD	A,A		;multiply by 16 
112f 87				ADD	A,A		; 
1130 87				ADD	A,A		; 
1131 57				LD	D,A		;Save hi nibble in D 
1132			HEXCON: 
1132 7e				ld a, (hl)		;Get next chr 
1133 23				inc hl 
1134 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1136 fe 0a			CP	00Ah		;Is it 0-9 ? 
1138 38 02			JR	C,NALPHA	;If so miss next bit 
113a d6 07			SUB	007h		;Else convert alpha 
113c			NALPHA: 
113c b2				OR	D		;Add hi nibble back 
113d c9				RET			; 
113e			 
113e			 
113e			; 
113e			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
113e			; Since the routines get_byte and therefore get_nibble are called, only valid 
113e			; characters (0-9a-f) are accepted. 
113e			; 
113e			;get_word        push    af 
113e			;                call    get_byte        ; Get the upper byte 
113e			;                ld      h, a 
113e			;                call    get_byte        ; Get the lower byte 
113e			;                ld      l, a 
113e			;                pop     af 
113e			;                ret 
113e			; 
113e			; Get a byte in hexadecimal notation. The result is returned in A. Since 
113e			; the routine get_nibble is used only valid characters are accepted - the  
113e			; input routine only accepts characters 0-9a-f. 
113e			; 
113e c5			get_byte:        push    bc              ; Save contents of B (and C) 
113f 7e					ld a,(hl) 
1140 23					inc hl 
1141 cd 66 11		                call    nibble2val      ; Get upper nibble 
1144 cb 07		                rlc     a 
1146 cb 07		                rlc     a 
1148 cb 07		                rlc     a 
114a cb 07		                rlc     a 
114c 47			                ld      b, a            ; Save upper four bits 
114d 7e					ld a,(hl) 
114e cd 66 11		                call    nibble2val      ; Get lower nibble 
1151 b0			                or      b               ; Combine both nibbles 
1152 c1			                pop     bc              ; Restore B (and C) 
1153 c9			                ret 
1154			; 
1154			; Get a hexadecimal digit from the serial line. This routine blocks until 
1154			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1154			; to the serial line interface. The lower 4 bits of A contain the value of  
1154			; that particular digit. 
1154			; 
1154			;get_nibble      ld a,(hl)           ; Read a character 
1154			;                call    to_upper        ; Convert to upper case 
1154			;                call    is_hex          ; Was it a hex digit? 
1154			;                jr      nc, get_nibble  ; No, get another character 
1154			 ;               call    nibble2val      ; Convert nibble to value 
1154			 ;               call    print_nibble 
1154			 ;               ret 
1154			; 
1154			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1154			; A valid hexadecimal digit is denoted by a set C flag. 
1154			; 
1154			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1154			;                ret     nc              ; Yes 
1154			;                cp      '0'             ; Less than '0'? 
1154			;                jr      nc, is_hex_1    ; No, continue 
1154			;                ccf                     ; Complement carry (i.e. clear it) 
1154			;                ret 
1154			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1154			;                ret     c               ; Yes 
1154			;                cp      'A'             ; Less than 'A'? 
1154			;                jr      nc, is_hex_2    ; No, continue 
1154			;                ccf                     ; Yes - clear carry and return 
1154			;                ret 
1154			;is_hex_2        scf                     ; Set carry 
1154			;                ret 
1154			; 
1154			; Convert a single character contained in A to upper case: 
1154			; 
1154 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1156 d8			                ret     c 
1157 fe 7b		                cp      'z' + 1         ; > 'z'? 
1159 d0			                ret     nc              ; Nothing to do, either 
115a e6 5f		                and     $5f             ; Convert to upper case 
115c c9			                ret 
115d			 
115d			 
115d			to_lower: 
115d			 
115d			   ; if char is in [A-Z] make it lower case 
115d			 
115d			   ; enter : a = char 
115d			   ; exit  : a = lower case char 
115d			   ; uses  : af 
115d			 
115d fe 41		   cp 'A' 
115f d8			   ret c 
1160			    
1160 fe 5b		   cp 'Z'+1 
1162 d0			   ret nc 
1163			    
1163 f6 20		   or $20 
1165 c9			   ret 
1166			 
1166			; 
1166			; Expects a hexadecimal digit (upper case!) in A and returns the 
1166			; corresponding value in A. 
1166			; 
1166 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1168 38 02		                jr      c, nibble2val_1 ; Yes 
116a d6 07		                sub     7               ; Adjust for A-F 
116c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
116e e6 0f		                and     $f              ; Only return lower 4 bits 
1170 c9			                ret 
1171			; 
1171			; Print_nibble prints a single hex nibble which is contained in the lower  
1171			; four bits of A: 
1171			; 
1171			;print_nibble    push    af              ; We won't destroy the contents of A 
1171			;                and     $f              ; Just in case... 
1171			;                add     a, '0'             ; If we have a digit we are done here. 
1171			;                cp      '9' + 1         ; Is the result > 9? 
1171			;                jr      c, print_nibble_1 
1171			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1171			;print_nibble_1  call    putc            ; Print the nibble and 
1171			;                pop     af              ; restore the original value of A 
1171			;                ret 
1171			;; 
1171			;; Send a CR/LF pair: 
1171			; 
1171			;crlf            push    af 
1171			;                ld      a, cr 
1171			;                call    putc 
1171			;                ld      a, lf 
1171			;                call    putc 
1171			;                pop     af 
1171			;                ret 
1171			; 
1171			; Print_word prints the four hex digits of a word to the serial line. The  
1171			; word is expected to be in HL. 
1171			; 
1171			;print_word      push    hl 
1171			;                push    af 
1171			;                ld      a, h 
1171			;                call    print_byte 
1171			;                ld      a, l 
1171			;                call    print_byte 
1171			;                pop     af 
1171			;                pop     hl 
1171			;                ret 
1171			; 
1171			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1171			; The byte to be printed is expected to be in A. 
1171			; 
1171			;print_byte      push    af              ; Save the contents of the registers 
1171			;                push    bc 
1171			;                ld      b, a 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                call    print_nibble    ; Print high nibble 
1171			;                ld      a, b 
1171			;                call    print_nibble    ; Print low nibble 
1171			;                pop     bc              ; Restore original register contents 
1171			;                pop     af 
1171			;                ret 
1171			 
1171			 
1171			 
1171			 
1171			 
1171			fourehexhl:  
1171 7e				ld a,(hl) 
1172 cd 20 11			call atohex 
1175 cb 3f				SRL A 
1177 cb 3f				SRL A 
1179 cb 3f				SRL A 
117b cb 3f				SRL A 
117d 47				ld b, a 
117e 23				inc hl 
117f 7e				ld a,(hl) 
1180 23				inc hl 
1181 cd 20 11			call atohex 
1184 80				add b 
1185 57				ld d,a 
1186 7e				ld a,(hl) 
1187 cd 20 11			call atohex 
118a cb 3f				SRL A 
118c cb 3f				SRL A 
118e cb 3f				SRL A 
1190 cb 3f				SRL A 
1192 47				ld b, a 
1193 23				inc hl 
1194 7e				ld a,(hl) 
1195 23				inc hl 
1196 cd 20 11			call atohex 
1199 80				add b 
119a 5f				ld e, a 
119b d5				push de 
119c e1				pop hl 
119d c9				ret 
119e			 
119e			; pass hl. returns z set if the byte at hl is a digit 
119e			;isdigithl:  
119e			;	push bc 
119e			;	ld a,(hl) 
119e			;	cp ':' 
119e			;	jr nc, .isdf 		; > 
119e			;	cp '0' 
119e			;	jr c, .isdf		; < 
119e			; 
119e			;	; TODO find a better way to set z 
119e			; 
119e			;	ld b,a 
119e			;	cp b 
119e			;	pop bc 
119e			;	ret 
119e			; 
119e			;.isdf:	; not digit so clear z 
119e			; 
119e			;	; TODO find a better way to unset z 
119e			; 
119e			;	ld b,a 
119e			;	inc b 
119e			;	cp b 
119e			; 
119e			;	pop bc 
119e			;	ret 
119e				 
119e				 
119e			 
119e			 
119e			; pass hl as the four byte address to load 
119e			 
119e			get_word_hl:  
119e e5				push hl 
119f cd 3e 11			call get_byte 
11a2				 
11a2 47				ld b, a 
11a3			 
11a3 e1				pop hl 
11a4 23				inc hl 
11a5 23				inc hl 
11a6			 
11a6			; TODO not able to handle a-f  
11a6 7e				ld a,(hl) 
11a7			;	;cp ':' 
11a7			;	cp 'g' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp 'G' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp '0' 
11a7			;	jr c, .single_byte_hl		; < 
11a7			 
11a7				;call isdigithl 
11a7 fe 00			cp 0 
11a9 28 06			jr z, .single_byte_hl 
11ab			 
11ab			.getwhln:   ; hex word so get next byte 
11ab			 
11ab cd 3e 11			call get_byte 
11ae 6f				ld l, a 
11af 60				ld h,b 
11b0 c9				ret 
11b1 68			.single_byte_hl:   ld l,b 
11b2 26 00				ld h,0 
11b4 c9					ret 
11b5			 
11b5			 
11b5			 
11b5			 
11b5 21 45 19			ld hl,asc+1 
11b8			;	ld a, (hl) 
11b8			;	call nibble2val 
11b8 cd 3e 11			call get_byte 
11bb			 
11bb			;	call fourehexhl 
11bb 32 f5 e2			ld (scratch+52),a 
11be				 
11be 21 f3 e2			ld hl,scratch+50 
11c1 22 e4 e5			ld (os_cur_ptr),hl 
11c4			 
11c4 c9				ret 
11c5			 
11c5			 
11c5			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11c5			 
11c5			; Decimal Unsigned Version 
11c5			 
11c5			;Number in a to decimal ASCII 
11c5			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11c5			;Example: display a=56 as "056" 
11c5			;input: a = number 
11c5			;Output: a=0,value of a in the screen 
11c5			;destroys af,bc (don't know about hl and de) 
11c5			DispAToASCII: 
11c5 0e 9c			ld	c,-100 
11c7 cd d1 11			call	.Na1 
11ca 0e f6			ld	c,-10 
11cc cd d1 11			call	.Na1 
11cf 0e ff			ld	c,-1 
11d1 06 2f		.Na1:	ld	b,'0'-1 
11d3 04			.Na2:	inc	b 
11d4 81				add	a,c 
11d5 38 fc			jr	c,.Na2 
11d7 91				sub	c		;works as add 100/10/1 
11d8 f5				push af		;safer than ld c,a 
11d9 78				ld	a,b		;char is in b 
11da			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11da f1				pop af		;safer than ld a,c 
11db c9				ret 
11dc			 
11dc			; Decimal Signed Version 
11dc			 
11dc			; DispA 
11dc			; -------------------------------------------------------------- 
11dc			; Converts a signed integer value to a zero-terminated ASCII 
11dc			; string representative of that value (using radix 10). 
11dc			; -------------------------------------------------------------- 
11dc			; INPUTS: 
11dc			;     HL     Value to convert (two's complement integer). 
11dc			;     DE     Base address of string destination. (pointer). 
11dc			; -------------------------------------------------------------- 
11dc			; OUTPUTS: 
11dc			;     None 
11dc			; -------------------------------------------------------------- 
11dc			; REGISTERS/MEMORY DESTROYED 
11dc			; AF HL 
11dc			; -------------------------------------------------------------- 
11dc			 
11dc			;DispHLToASCII: 
11dc			;   push    de 
11dc			;   push    bc 
11dc			; 
11dc			;; Detect sign of HL. 
11dc			;    bit    7, h 
11dc			;    jr     z, ._DoConvert 
11dc			; 
11dc			;; HL is negative. Output '-' to string and negate HL. 
11dc			;    ld     a, '-' 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			; 
11dc			;; Negate HL (using two's complement) 
11dc			;    xor    a 
11dc			;    sub    l 
11dc			;    ld     l, a 
11dc			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11dc			;    sbc    a, h 
11dc			;    ld     h, a 
11dc			; 
11dc			;; Convert HL to digit characters 
11dc			;._DoConvert: 
11dc			;    ld     b, 0     ; B will count character length of number 
11dc			;-   ld     a, 10 
11dc			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11dc			;    push   af 
11dc			;    inc    b 
11dc			;    ld     a, h 
11dc			;    or     l 
11dc			;    jr     nz, - 
11dc			; 
11dc			;; Retrieve digits from stack 
11dc			;-   pop    af 
11dc			;    or     $30 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			;    djnz   - 
11dc			; 
11dc			;; Terminate string with NULL 
11dc			;    xor    a 
11dc			;    ld     (de), a 
11dc			; 
11dc			;    pop    bc 
11dc			;    pop    de 
11dc			;    ret 
11dc			 
11dc			;Comments 
11dc			; 
11dc			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11dc			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11dc			;    Note that the output string will not be fixed-width. 
11dc			; 
11dc			;Example Usage 
11dc			; 
11dc			;    ld    hl, -1004 
11dc			;    ld    de, OP1 
11dc			;    call  DispA 
11dc			;    ld    hl, OP1 
11dc			;    syscall  PutS 
11dc			 
11dc			 
11dc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11dc			 
11dc			 
11dc			;Converts an ASCII string to an unsigned 16-bit integer 
11dc			;Quits when it reaches a non-decimal digit 
11dc			 
11dc			string_to_uint16: 
11dc			atoui_16: 
11dc			;Input: 
11dc			;     DE points to the string 
11dc			;Outputs: 
11dc			;     HL is the result 
11dc			;     A is the 8-bit value of the number 
11dc			;     DE points to the byte after the number 
11dc			;Destroys: 
11dc			;     BC 
11dc			;       if the string is non-empty, BC is HL/10 
11dc			;Size:  24 bytes 
11dc			;Speed: 42+d(104+{0,9}) 
11dc			;       d is the number of digits in the number 
11dc			;       max is 640 cycles for a 5 digit number 
11dc			;Assuming no leading zeros: 
11dc			;1 digit:  146cc 
11dc			;2 digit:  250cc 
11dc			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11dc			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11dc			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11dc			;avg: 544.81158447265625cc (544+13297/16384) 
11dc			;=============================================================== 
11dc 21 00 00		  ld hl,0 
11df			.u16a: 
11df 1a			  ld a,(de) 
11e0 d6 30		  sub 30h 
11e2 fe 0a		  cp 10 
11e4 d0			  ret nc 
11e5 13			  inc de 
11e6 44			  ld b,h 
11e7 4d			  ld c,l 
11e8 29			  add hl,hl 
11e9 29			  add hl,hl 
11ea 09			  add hl,bc 
11eb 29			  add hl,hl 
11ec 85			  add a,l 
11ed 6f			  ld l,a 
11ee 30 ef		  jr nc,.u16a 
11f0 24			  inc h 
11f1 c3 df 11		  jp .u16a 
11f4			 
11f4			 
11f4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11f4			 
11f4			;written by Zeda 
11f4			;Converts a 16-bit unsigned integer to an ASCII string. 
11f4			 
11f4			uitoa_16: 
11f4			;Input: 
11f4			;   DE is the number to convert 
11f4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11f4			;Output: 
11f4			;   HL points to the null-terminated ASCII string 
11f4			;      NOTE: This isn't necessarily the same as the input HL. 
11f4 d5			  push de 
11f5 c5			  push bc 
11f6 f5			  push af 
11f7 eb			  ex de,hl 
11f8			 
11f8 01 f0 d8		  ld bc,-10000 
11fb 3e 2f		  ld a,'0'-1 
11fd 3c			  inc a 
11fe 09			  add hl,bc  
11ff 38 fc		   jr c,$-2 
1201 12			  ld (de),a 
1202 13			  inc de 
1203			 
1203 01 e8 03		  ld bc,1000 
1206 3e 3a		  ld a,'9'+1 
1208 3d			  dec a  
1209 09			  add hl,bc  
120a 30 fc		   jr nc,$-2 
120c 12			  ld (de),a 
120d 13			  inc de 
120e			 
120e 01 9c ff		  ld bc,-100 
1211 3e 2f		  ld a,'0'-1 
1213 3c			  inc a  
1214 09			  add hl,bc  
1215 38 fc		   jr c,$-2 
1217 12			  ld (de),a 
1218 13			  inc de 
1219			 
1219 7d			  ld a,l 
121a 26 3a		  ld h,'9'+1 
121c 25			  dec h  
121d c6 0a		  add a,10  
121f 30 fb		   jr nc,$-3 
1221 c6 30		  add a,'0' 
1223 eb			  ex de,hl 
1224 72			  ld (hl),d 
1225 23			  inc hl 
1226 77			  ld (hl),a 
1227 23			  inc hl 
1228 36 00		  ld (hl),0 
122a			 
122a			;Now strip the leading zeros 
122a 0e fa		  ld c,-6 
122c 09			  add hl,bc 
122d 3e 30		  ld a,'0' 
122f 23			  inc hl  
1230 be			  cp (hl)  
1231 28 fc		  jr z,$-2 
1233			 
1233			;Make sure that the string is non-empty! 
1233 7e			  ld a,(hl) 
1234 b7			  or a 
1235 20 01		  jr nz,.atoub 
1237 2b			  dec hl 
1238			.atoub: 
1238			 
1238 f1			  pop af 
1239 c1			  pop bc 
123a d1			  pop de 
123b c9			  ret 
123c			 
123c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
123c			 
123c			toUpper: 
123c			;A is the char. 
123c			;If A is a lowercase letter, this sets it to the matching uppercase 
123c			;18cc or 30cc or 41cc 
123c			;avg: 26.75cc 
123c fe 61		  cp 'a' 
123e d8			  ret c 
123f fe 7b		  cp 'z'+1 
1241 d0			  ret nc 
1242 d6 20		  sub 'a'-'A' 
1244 c9			  ret 
1245			 
1245			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1245			 
1245			; String Length 
1245			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1245			 
1245			; Get the length of the null-terminated string starting at $8000 hl 
1245			;    LD     HL, $8000 
1245			 
1245			strlenz: 
1245			 
1245 af			    XOR    A               ; Zero is the value we are looking for. 
1246 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1247 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1248			                           ; 65, 536 bytes (the entire addressable memory space). 
1248 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
124a			 
124a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
124a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
124b 6f			    LD     L, A             ; number of bytes 
124c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
124e 2b			    DEC    HL              ; Compensate for null. 
124f c9				ret 
1250			 
1250			; Get the length of the A terminated string starting at $8000 hl 
1250			;    LD     HL, $8000 
1250			 
1250			strlent: 
1250			 
1250			                  ; A is the value we are looking for. 
1250 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1252 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1254			                           ; 65, 536 bytes (the entire addressable memory space). 
1254 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1256			 
1256			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1256 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1258 2e 00		    LD     L, 0             ; number of bytes 
125a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
125c 2b			    DEC    HL              ; Compensate for null. 
125d c9				ret 
125e			 
125e			 
125e			;Comparing Strings 
125e			 
125e			;IN    HL     Address of string1. 
125e			;      DE     Address of string2. 
125e			 
125e			; doc given but wrong??? 
125e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
125e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
125e			; tested 
125e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
125e			 
125e			strcmp_old: 
125e e5			    PUSH   HL 
125f d5			    PUSH   DE 
1260			 
1260 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1261 be			    CP     (HL)            ; (want to minimize work). 
1262 38 01		    JR     C, Str1IsBigger 
1264 7e			    LD     A, (HL) 
1265			 
1265			Str1IsBigger: 
1265 4f			    LD     C, A             ; Put length in BC 
1266 06 00		    LD     B, 0 
1268 13			    INC    DE              ; Increment pointers to meat of string. 
1269 23			    INC    HL 
126a			 
126a			CmpLoop: 
126a 1a			    LD     A, (DE)          ; Compare bytes. 
126b ed a1		    CPI 
126d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
126f 13			    INC    DE              ; Update pointer. 
1270 ea 6a 12		    JP     PE, CmpLoop 
1273			 
1273 d1			    POP    DE 
1274 e1			    POP    HL 
1275 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1276 be			    CP     (HL) 
1277 c9			    RET 
1278			 
1278			NoMatch: 
1278 2b			    DEC    HL 
1279 be			    CP     (HL)            ; Compare again to affect carry. 
127a d1			    POP    DE 
127b e1			    POP    HL 
127c c9			    RET 
127d			 
127d			;; test strmp 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr z, .z1 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z1: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr z, .z2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr c, .c1 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c1: 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr c, .c2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;	NEXTW 
127d			;.str1:   db "string1",0 
127d			;.str2:   db "string2",0 
127d			 
127d			; only care about direct match or not 
127d			; hl and de strings 
127d			; zero set if the same 
127d			 
127d			strcmp: 
127d 1a				ld a, (de) 
127e be				cp (hl) 
127f 28 02			jr z, .ssame 
1281 b7				or a 
1282 c9				ret 
1283			 
1283			.ssame:  
1283 fe 00			cp 0 
1285 c8				ret z 
1286			 
1286 23				inc hl 
1287 13				inc de 
1288 18 f3			jr strcmp 
128a				 
128a				 
128a			 
128a			 
128a			 
128a			 
128a			; eof 
128a			 
128a			 
128a			 
128a			 
128a			 
128a			 
# End of file firmware_strings.asm
128a			include "firmware_memory.asm"   ; malloc and free  
128a			 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			.mallocsize: db "Wants malloc >256",0 
128a			.mallocasize: db "MALLOC gives >256",0 
128a			.malloczero: db "MALLOC gives zero",0 
128a			 
128a			malloc_guard_zerolen: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a				ld de, 0 
128a			        call cmp16 
128a				jr nz, .lowalloz 
128a			 
128a				push hl 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .malloczero 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a				call bp_on 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a			.lowalloz: 
128a			 
128a			 
128a				pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_entry: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowalloc 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocsize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a				call bp_on 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a				jr .lowdone 
128a			.lowalloc: 
128a			 
128a			 
128a				pop hl 
128a			.lowdone:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_exit: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowallocx 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocasize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a				call bp_on 
128a				pop de 
128a				pop hl 
128a			 
128a				CALLMONITOR 
128a				jr .lowdonex 
128a			.lowallocx: 
128a			 
128a				pop hl 
128a			.lowdonex:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			endif 
128a			 
128a			if MALLOC_2 
128a			; Z80 Malloc and Free Functions 
128a			 
128a			; Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc: 
128a				 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_entry 
128a			endif 
128a			 
128a			 
128a			 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "mal" 
128a						CALLMONITOR 
128a					endif 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of size into A 
128a			    or h               ; Check if size is zero 
128a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
128a			 
128a			    ; Allocate memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma1" 
128a						CALLMONITOR 
128a					endif 
128a			    call malloc_internal ; Call internal malloc function 
128a			    pop af             ; Restore AF register 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret                ; Return 
128a			 
128a			; Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free: 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of pointer into A 
128a			    or h               ; Check if pointer is NULL 
128a			    jp z, free_exit    ; If pointer is NULL, exit 
128a			 
128a			    ; Free memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a			    call free_internal  ; Call internal free function 
128a			    pop af             ; Restore AF register 
128a			    ret                ; Return 
128a			 
128a			; Internal Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc_internal: 
128a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to requested size 
128a			    ex de, hl          ; Save total size in DE, and keep it in HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			 
128a			    ; Search for free memory block 
128a			    ld de, (heap_end)  ; Load end of heap into DE 
128a			    ld bc, 0           ; Initialize counter 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			malloc_search_loop: 
128a			    ; Check if current block is free 
128a			    ld a, (hl)         ; Load current block's status (free or used) 
128a			    cp 0               ; Compare with zero (free) 
128a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
128a			 
128a			    ; Check if current block is large enough 
128a			    ld a, (hl+1)       ; Load high byte of block size 
128a			    cp l               ; Compare with low byte of requested size 
128a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
128a			 
128a			    ld a, (hl+2)       ; Load low byte of block size 
128a			    cp h               ; Compare with high byte of requested size 
128a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
128a			 
128a			    ; Mark block as used 
128a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
128a			 
128a			    ; Calculate remaining space in block 
128a			    ld bc, 0           ; Clear BC 
128a			    add hl, bc         ; Increment HL to point to start of data block 
128a			    add hl, de         ; HL = HL + DE (total size) 
128a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to start of data block 
128a			 
128a			    ; Save pointer to allocated block in HL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma5" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			malloc_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3           ; Size of management overhead 
128a			    add hl, bc         ; Move to the next block 
128a			    inc de             ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e            ; Load low byte of heap end address 
128a			    cp (hl)            ; Compare with low byte of current address 
128a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
128a			    ld a, d            ; Load high byte of heap end address 
128a			    cp 0               ; Check if it's zero (end of memory) 
128a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, allocation failed 
128a			    xor a              ; Set result to NULL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma6" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			malloc_exit: 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma7" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			; Internal Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free_internal: 
128a			    ld de, (heap_start) ; Load start of heap into DE 
128a			    ld bc, 0            ; Initialize counter 
128a			 
128a			free_search_loop: 
128a			    ; Check if current block contains the pointer 
128a			    ld a, l             ; Load low byte of pointer 
128a			    cp (hl+1)           ; Compare with high byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			    ld a, h             ; Load high byte of pointer 
128a			    cp (hl+2)           ; Compare with low byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			 
128a			    ; Mark block as free 
128a			    ld (hl), 0          ; Set status byte to indicate free block 
128a			    ret                 ; Return 
128a			 
128a			free_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3            ; Size of management overhead 
128a			    add hl, bc          ; Move to the next block 
128a			    inc de              ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e             ; Load low byte of heap end address 
128a			    cp (hl)             ; Compare with low byte of current address 
128a			    jr nz, free_search_loop  ; If not equal, continue searching 
128a			    ld a, d             ; Load high byte of heap end address 
128a			    cp 0                ; Check if it's zero (end of memory) 
128a			    jr nz, free_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, pointer is not found in heap 
128a			    ret 
128a			 
128a			free_exit: 
128a			    ret                 ; Return 
128a			 
128a			; Define heap start and end addresses 
128a			;heap_start:    .dw 0xC000   ; Start of heap 
128a			;heap_end:      .dw 0xE000   ; End of heap 
128a			 
128a			endif 
128a			 
128a			 
128a			if MALLOC_1 
128a			 
128a			 
128a			 
128a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
128a			 
128a			;moved to firmware.asm 
128a			;heap_start        .equ  0x9000      ; Starting address of heap 
128a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
128a			 
128a			;      .org 0 
128a			;      jp    main 
128a			 
128a			 
128a			;      .org  0x100 
128a			;main: 
128a			;      ld    HL, 0x8100 
128a			;      ld    SP, HL 
128a			; 
128a			;      call  heap_init 
128a			; 
128a			;      ; Make some allocations 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9004 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9014 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9024 
128a			; 
128a			;      ; Free some allocations 
128a			;      ld    HL, 0x9014 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9004 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9024 
128a			;      call  free 
128a			; 
128a			; 
128a			;      halt 
128a			 
128a			 
128a			;------------------------------------------------------------------------------ 
128a			;     heap_init                                                               : 
128a			;                                                                             : 
128a			; Description                                                                 : 
128a			;     Initialise the heap and make it ready for malloc and free operations.   : 
128a			;                                                                             : 
128a			;     The heap is maintained as a linked list, starting with an initial       : 
128a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
128a			;     the first free block in the heap. Each block then points to the next    : 
128a			;     free block within the heap, and the free list ends at the first block   : 
128a			;     with a null pointer to the next free block.                             : 
128a			;                                                                             : 
128a			; Parameters                                                                  : 
128a			;     Inputs are compile-time only. Two defines which specify the starting    : 
128a			;     address of the heap and its size are required, along with a memory      : 
128a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
128a			;     principally stores a pointer to the first free block in the heap.       : 
128a			;                                                                             : 
128a			; Returns                                                                     : 
128a			;     Nothing                                                                 : 
128a			;------------------------------------------------------------------------------ 
128a			heap_init: 
128a e5			      push  HL 
128b			 
128b			      ; Initialise free list struct 
128b 21 4f 65		      ld    HL, heap_start 
128e 22 4a 65		      ld    (free_list), HL 
1291 21 00 00		      ld    HL, 0 
1294 22 4c 65		      ld    (free_list+2), HL 
1297			 
1297			      ; Insert first free block at bottom of heap, consumes entire heap 
1297 21 a4 e2		      ld    HL, heap_start+heap_size-4 
129a 22 4f 65		      ld    (heap_start), HL        ; Next block (end of free list) 
129d 21 55 7d		      ld    HL, heap_size-4 
12a0 22 51 65		      ld    (heap_start+2), HL      ; Block size 
12a3			 
12a3			      ; Insert end of free list block at top of heap - two null words will 
12a3			      ; terminate the free list 
12a3 21 00 00		      ld    HL, 0 
12a6 22 a6 e2		      ld    (heap_start+heap_size-2), HL 
12a9 22 a4 e2		      ld    (heap_start+heap_size-4), HL 
12ac			 
12ac e1			      pop   HL 
12ad			 
12ad c9			      ret 
12ae			 
12ae			 
12ae			;------------------------------------------------------------------------------ 
12ae			;     malloc                                                                  : 
12ae			;                                                                             : 
12ae			; Description                                                                 : 
12ae			;     Allocates the wanted space from the heap and returns the address of the : 
12ae			;     first useable byte of the allocation.                                   : 
12ae			;                                                                             : 
12ae			;     Allocations can happen in one of two ways:                              : 
12ae			;                                                                             : 
12ae			;     1. A free block may be found which is the exact size wanted. In this    : 
12ae			;        case the block is removed from the free list and retuedn to the      : 
12ae			;        caller.                                                              : 
12ae			;     2. A free block may be found which is larger than the size wanted. In   : 
12ae			;        this case, the larger block is split into two. The first portion of  : 
12ae			;        this block will become the requested space by the malloc call and    : 
12ae			;        is returned to the caller. The second portion becomes a new free     : 
12ae			;        block, and the free list is adjusted to maintain continuity via this : 
12ae			;        newly created block.                                                 : 
12ae			;                                                                             : 
12ae			;     malloc does not set any initial value in the allocated space, the       : 
12ae			;     caller is required to do this as required.                              : 
12ae			;                                                                             : 
12ae			;     This implementation of malloc uses the stack exclusively, and is        : 
12ae			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ae			;     advisable to disable interrupts before calling malloc, and recommended  : 
12ae			;     to avoid the use of malloc inside ISRs in general.                      : 
12ae			;                                                                             : 
12ae			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ae			;                                                                             : 
12ae			; Parameters                                                                  : 
12ae			;     HL  Number of bytes wanted                                              : 
12ae			;                                                                             : 
12ae			; Returns                                                                     : 
12ae			;     HL  Address of the first useable byte of the allocation                 : 
12ae			;                                                                             : 
12ae			; Flags                                                                       : 
12ae			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12ae			;                                                                             : 
12ae			; Stack frame                                                                 : 
12ae			;       |             |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     BC      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     DE      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     IX      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |  prev_free  |                                                       : 
12ae			;   +4  +-------------+                                                       : 
12ae			;       |  this_free  |                                                       : 
12ae			;   +2  +-------------+                                                       : 
12ae			;       |  next_free  |                                                       : 
12ae			;   +0  +-------------+                                                       : 
12ae			;       |             |                                                       : 
12ae			;                                                                             : 
12ae			;------------------------------------------------------------------------------ 
12ae			 
12ae			 
12ae			;malloc: 
12ae			; 
12ae			;	SAVESP ON 1 
12ae			; 
12ae			;	call malloc_code 
12ae			; 
12ae			;	CHECKSP ON 1 
12ae			;	ret 
12ae			 
12ae			 
12ae			malloc: 
12ae c5			      push  BC 
12af d5			      push  DE 
12b0 dd e5		      push  IX 
12b2			if DEBUG_FORTH_MALLOC_HIGH 
12b2			call malloc_guard_entry 
12b2			endif 
12b2			 
12b2					if DEBUG_FORTH_MALLOC 
12b2						DMARK "mal" 
12b2						CALLMONITOR 
12b2					endif 
12b2 7c			      ld    A, H                    ; Exit if no space requested 
12b3 b5			      or    L 
12b4 ca 73 13		      jp    Z, malloc_early_exit 
12b7			 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			; 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			 
12b7			 
12b7			 
12b7			 
12b7					if DEBUG_FORTH_MALLOC 
12b7						DMARK "maA" 
12b7						CALLMONITOR 
12b7					endif 
12b7			      ; Set up stack frame 
12b7 eb			      ex    DE, HL 
12b8 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12bb 39			      add   HL, SP 
12bc f9			      ld    SP, HL 
12bd dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12c1 dd 39		      add   IX, SP 
12c3			 
12c3			      ; Setup initial state 
12c3 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12c6 19			      add   HL, DE 
12c7			 
12c7 44			      ld    B, H                    ; Move want to BC 
12c8 4d			      ld    C, L 
12c9			 
12c9 21 4a 65		      ld    HL, free_list           ; Store prev_free ptr to stack 
12cc dd 75 04		      ld    (IX+4), L 
12cf dd 74 05		      ld    (IX+5), H 
12d2			 
12d2 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12d3 23			      inc   HL 
12d4 56			      ld    D, (HL) 
12d5 dd 73 02		      ld    (IX+2), E 
12d8 dd 72 03		      ld    (IX+3), D 
12db eb			      ex    DE, HL                  ; this_free ptr into HL 
12dc			 
12dc					if DEBUG_FORTH_MALLOC 
12dc						DMARK "maB" 
12dc						CALLMONITOR 
12dc					endif 
12dc			      ; Loop through free block list to find some space 
12dc			malloc_find_space: 
12dc 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12dd 23			      inc   HL 
12de 56			      ld    D, (HL) 
12df			 
12df 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12e0 b3			      or    E 
12e1 ca 6d 13		      jp    Z, malloc_no_space 
12e4			 
12e4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12e7 dd 72 01		      ld    (IX+1), D 
12ea			 
12ea			      ; Does this block have enough space to make the allocation? 
12ea 23			      inc   HL                      ; Load free block size into DE 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee			 
12ee eb			      ex    DE, HL                  ; Check size of block against want 
12ef b7			      or    A                       ; Ensure carry flag clear 
12f0 ed 42		      sbc   HL, BC 
12f2 e5			      push  HL                      ; Store the result for later (new block size) 
12f3			 
12f3 ca 42 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12f6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12f8			 
12f8			      ; this_free block is not big enough, setup ptrs to test next free block 
12f8 e1			      pop   HL                      ; Discard previous result 
12f9			 
12f9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12fc dd 66 03		      ld    H, (IX+3) 
12ff dd 75 04		      ld    (IX+4), L 
1302 dd 74 05		      ld    (IX+5), H 
1305			 
1305 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1308 dd 66 01		      ld    H, (IX+1) 
130b dd 75 02		      ld    (IX+2), L 
130e dd 74 03		      ld    (IX+3), H 
1311			 
1311					if DEBUG_FORTH_MALLOC 
1311						DMARK "MA>" 
1311						CALLMONITOR 
1311					endif 
1311 18 c9		      jr    malloc_find_space 
1313			 
1313			      ; split a bigger block into two - requested size and remaining size 
1313			malloc_alloc_split: 
1313					if DEBUG_FORTH_MALLOC 
1313						DMARK "MAs" 
1313						CALLMONITOR 
1313					endif 
1313 eb			      ex    DE, HL                  ; Calculate address of new free block 
1314 2b			      dec   HL 
1315 2b			      dec   HL 
1316 2b			      dec   HL 
1317 09			      add   HL, BC 
1318			 
1318			      ; Create a new block and point it at next_free 
1318 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
131b dd 56 01		      ld    D, (IX+1) 
131e			 
131e 73			      ld    (HL), E                 ; Store next_free ptr into new block 
131f 23			      inc   HL 
1320 72			      ld    (HL), D 
1321			 
1321 d1			      pop   DE                      ; Store size of new block into new block 
1322 23			      inc   HL 
1323 73			      ld    (HL), E 
1324 23			      inc   HL 
1325 72			      ld    (HL), D 
1326			 
1326			      ; Update this_free ptr to point to new block 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328 2b			      dec   HL 
1329			 
1329 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
132c dd 56 03		      ld    D, (IX+3) 
132f			 
132f dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1332 dd 74 03		      ld    (IX+3), H 
1335			 
1335			      ; Modify this_free block to be allocation 
1335 eb			      ex    DE, HL 
1336 af			      xor   A                       ; Null the next block ptr of allocated block 
1337 77			      ld    (HL), A 
1338 23			      inc   HL 
1339 77			      ld    (HL), A 
133a			 
133a 23			      inc   HL                      ; Store want size into allocated block 
133b 71			      ld    (HL), C 
133c 23			      inc   HL 
133d 70			      ld    (HL), B 
133e 23			      inc   HL 
133f e5			      push  HL                      ; Address of allocation to return 
1340			 
1340 18 19		      jr    malloc_update_links 
1342			 
1342			malloc_alloc_fit: 
1342 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1343			 
1343					if DEBUG_FORTH_MALLOC 
1343						DMARK "MAf" 
1343						CALLMONITOR 
1343					endif 
1343			      ; Modify this_free block to be allocation 
1343 eb			      ex    DE, HL 
1344 2b			      dec   HL 
1345 2b			      dec   HL 
1346 2b			      dec   HL 
1347			 
1347 af			      xor   A                       ; Null the next block ptr of allocated block 
1348 77			      ld    (HL), A 
1349 23			      inc   HL 
134a 77			      ld    (HL), A 
134b			 
134b 23			      inc   HL                      ; Store address of allocation to return 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e e5			      push  HL 
134f			 
134f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
134f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1352 dd 66 01		      ld    H, (IX+1) 
1355			 
1355 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1358 dd 74 03		      ld    (IX+3), H 
135b			 
135b			 
135b			malloc_update_links: 
135b			      ; Update prev_free ptr to point to this_free 
135b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
135e dd 66 05		      ld    H, (IX+5) 
1361			 
1361 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1364 dd 56 03		      ld    D, (IX+3) 
1367			 
1367 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1368 23			      inc   HL 
1369 72			      ld    (HL), D 
136a			 
136a					if DEBUG_FORTH_MALLOC 
136a						DMARK "Mul" 
136a						CALLMONITOR 
136a					endif 
136a			      ; Clear the Z flag to indicate successful allocation 
136a 7a			      ld    A, D 
136b b3			      or    E 
136c			 
136c d1			      pop   DE                      ; Address of allocation 
136d					if DEBUG_FORTH_MALLOC 
136d						DMARK "MAu" 
136d						CALLMONITOR 
136d					endif 
136d			 
136d			malloc_no_space: 
136d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1370 39			      add   HL, SP 
1371 f9			      ld    SP, HL 
1372			 
1372 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAN" 
1373						CALLMONITOR 
1373					endif 
1373			 
1373			malloc_early_exit: 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAx" 
1373						CALLMONITOR 
1373					endif 
1373 dd e1		      pop   IX 
1375 d1			      pop   DE 
1376 c1			      pop   BC 
1377			 
1377			if DEBUG_FORTH_MALLOC_HIGH 
1377			call malloc_guard_exit 
1377			call malloc_guard_zerolen 
1377			endif 
1377 c9			      ret 
1378			 
1378			 
1378			;------------------------------------------------------------------------------ 
1378			;     free                                                                    : 
1378			;                                                                             : 
1378			; Description                                                                 : 
1378			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1378			;     returned by malloc, otherwise the behaviour is undefined.               : 
1378			;                                                                             : 
1378			;     Where possible, directly adjacent free blocks will be merged together   : 
1378			;     into larger blocks to help ensure that the heap does not become         : 
1378			;     excessively fragmented.                                                 : 
1378			;                                                                             : 
1378			;     free does not clear or set any other value into the freed space, and    : 
1378			;     therefore its contents may be visible through subsequent malloc's. The  : 
1378			;     caller should clear the freed space as required.                        : 
1378			;                                                                             : 
1378			;     This implementation of free uses the stack exclusively, and is          : 
1378			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1378			;     advisable to disable interrupts before calling free, and recommended    : 
1378			;     to avoid the use of free inside ISRs in general.                        : 
1378			;                                                                             : 
1378			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1378			;                                                                             : 
1378			; Parameters                                                                  : 
1378			;     HL  Pointer to address of first byte of allocation to be freed          : 
1378			;                                                                             : 
1378			; Returns                                                                     : 
1378			;     Nothing                                                                 : 
1378			;                                                                             : 
1378			; Stack frame                                                                 : 
1378			;       |             |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     BC      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     DE      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     IX      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |  prev_free  |                                                       : 
1378			;   +2  +-------------+                                                       : 
1378			;       |  next_free  |                                                       : 
1378			;   +0  +-------------+                                                       : 
1378			;       |             |                                                       : 
1378			;                                                                             : 
1378			;------------------------------------------------------------------------------ 
1378			free: 
1378 c5			      push  BC 
1379 d5			      push  DE 
137a dd e5		      push  IX 
137c			 
137c 7c			      ld    A, H                    ; Exit if ptr is null 
137d b5			      or    L 
137e ca 42 14		      jp    Z, free_early_exit 
1381			 
1381			      ; Set up stack frame 
1381 eb			      ex    DE, HL 
1382 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1385 39			      add   HL, SP 
1386 f9			      ld    SP, HL 
1387 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
138b dd 39		      add   IX, SP 
138d			 
138d			      ; The address in HL points to the start of the useable allocated space, 
138d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
138d			      ; address of the block itself. 
138d eb			      ex    DE, HL 
138e 11 fc ff		      ld    DE, -4 
1391 19			      add   HL, DE 
1392			 
1392			      ; An allocated block must have a null next block pointer in it 
1392 7e			      ld    A, (HL) 
1393 23			      inc   HL 
1394 b6			      or    (HL) 
1395 c2 3d 14		      jp    NZ, free_done 
1398			 
1398 2b			      dec   HL 
1399			 
1399 44			      ld    B, H                    ; Copy HL to BC 
139a 4d			      ld    C, L 
139b			 
139b			      ; Loop through the free list to find the first block with an address 
139b			      ; higher than the block being freed 
139b 21 4a 65		      ld    HL, free_list 
139e			 
139e			free_find_higher_block: 
139e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
139f 23			      inc   HL 
13a0 56			      ld    D, (HL) 
13a1 2b			      dec   HL 
13a2			 
13a2 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
13a5 dd 72 01		      ld    (IX+1), D 
13a8 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
13ab dd 74 03		      ld    (IX+3), H 
13ae			 
13ae 78			      ld    A, B                    ; Check if DE is greater than BC 
13af ba			      cp    D                       ; Compare MSB first 
13b0 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13b2 30 04		      jr    NC, free_find_higher_block_skip 
13b4 79			      ld    A, C 
13b5 bb			      cp    E                       ; Then compare LSB 
13b6 38 08		      jr    C, free_found_higher_block 
13b8			 
13b8			free_find_higher_block_skip: 
13b8 7a			      ld    A, D                    ; Reached the end of the free list? 
13b9 b3			      or    E 
13ba ca 3d 14		      jp    Z, free_done 
13bd			 
13bd eb			      ex    DE, HL 
13be			 
13be 18 de		      jr    free_find_higher_block 
13c0			 
13c0			free_found_higher_block: 
13c0			      ; Insert freed block between prev and next free blocks 
13c0 71			      ld    (HL), C                 ; Point prev free block to freed block 
13c1 23			      inc   HL 
13c2 70			      ld    (HL), B 
13c3			 
13c3 60			      ld    H, B                    ; Point freed block at next free block 
13c4 69			      ld    L, C 
13c5 73			      ld    (HL), E 
13c6 23			      inc   HL 
13c7 72			      ld    (HL), D 
13c8			 
13c8			      ; Check if the freed block is adjacent to the next free block 
13c8 23			      inc   HL                      ; Load size of freed block into HL 
13c9 5e			      ld    E, (HL) 
13ca 23			      inc   HL 
13cb 56			      ld    D, (HL) 
13cc eb			      ex    DE, HL 
13cd			 
13cd 09			      add   HL, BC                  ; Add addr of freed block and its size 
13ce			 
13ce dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13d1 dd 56 01		      ld    D, (IX+1) 
13d4			 
13d4 b7			      or    A                       ; Clear the carry flag 
13d5 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13d7 20 22		      jr    NZ, free_check_adjacent_to_prev 
13d9			 
13d9			      ; Freed block is adjacent to next, merge into one bigger block 
13d9 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13da 5e			      ld    E, (HL) 
13db 23			      inc   HL 
13dc 56			      ld    D, (HL) 
13dd e5			      push  HL                      ; Save ptr to next block for later 
13de			 
13de 60			      ld    H, B                    ; Store ptr from next block into freed block 
13df 69			      ld    L, C 
13e0 73			      ld    (HL), E 
13e1 23			      inc   HL 
13e2 72			      ld    (HL), D 
13e3			 
13e3 e1			      pop   HL                      ; Restore ptr to next block 
13e4 23			      inc   HL                      ; Load size of next block into DE 
13e5 5e			      ld    E, (HL) 
13e6 23			      inc   HL 
13e7 56			      ld    D, (HL) 
13e8 d5			      push  DE                      ; Save next block size for later 
13e9			 
13e9 60			      ld    H, B                    ; Load size of freed block into HL 
13ea 69			      ld    L, C 
13eb 23			      inc   HL 
13ec 23			      inc   HL 
13ed 5e			      ld    E, (HL) 
13ee 23			      inc   HL 
13ef 56			      ld    D, (HL) 
13f0 eb			      ex    DE, HL 
13f1			 
13f1 d1			      pop   DE                      ; Restore size of next block 
13f2 19			      add   HL, DE                  ; Add sizes of both blocks 
13f3 eb			      ex    DE, HL 
13f4			 
13f4 60			      ld    H, B                    ; Store new bigger size into freed block 
13f5 69			      ld    L, C 
13f6 23			      inc   HL 
13f7 23			      inc   HL 
13f8 73			      ld    (HL), E 
13f9 23			      inc   HL 
13fa 72			      ld    (HL), D 
13fb			 
13fb			free_check_adjacent_to_prev: 
13fb			      ; Check if the freed block is adjacent to the prev free block 
13fb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13fe dd 66 03		      ld    H, (IX+3) 
1401			 
1401 23			      inc   HL                      ; Size of prev free block into DE 
1402 23			      inc   HL 
1403 5e			      ld    E, (HL) 
1404 23			      inc   HL 
1405 56			      ld    D, (HL) 
1406 2b			      dec   HL 
1407 2b			      dec   HL 
1408 2b			      dec   HL 
1409			 
1409 19			      add   HL, DE                  ; Add prev block addr and size 
140a			 
140a b7			      or    A                       ; Clear the carry flag 
140b ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
140d 20 2e		      jr    NZ, free_done 
140f			 
140f			      ; Freed block is adjacent to prev, merge into one bigger block 
140f 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1410 69			      ld    L, C 
1411 5e			      ld    E, (HL) 
1412 23			      inc   HL 
1413 56			      ld    D, (HL) 
1414 e5			      push  HL                      ; Save freed block ptr for later 
1415			 
1415 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1418 dd 66 03		      ld    H, (IX+3) 
141b 73			      ld    (HL), E 
141c 23			      inc   HL 
141d 72			      ld    (HL), D 
141e			 
141e e1			      pop   HL                      ; Restore freed block ptr 
141f 23			      inc   HL                      ; Load size of freed block into DE 
1420 5e			      ld    E, (HL) 
1421 23			      inc   HL 
1422 56			      ld    D, (HL) 
1423 d5			      push  DE                      ; Save freed block size for later 
1424			 
1424 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1427 dd 66 03		      ld    H, (IX+3) 
142a 23			      inc   HL 
142b 23			      inc   HL 
142c 5e			      ld    E, (HL) 
142d 23			      inc   HL 
142e 56			      ld    D, (HL) 
142f			 
142f e1			      pop   HL                      ; Add sizes of both blocks 
1430 19			      add   HL, DE 
1431 eb			      ex    DE, HL 
1432			 
1432 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1435 dd 66 03		      ld    H, (IX+3) 
1438 23			      inc   HL 
1439 23			      inc   HL 
143a 73			      ld    (HL), E 
143b 23			      inc   HL 
143c 72			      ld    (HL), D 
143d			 
143d			free_done: 
143d 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1440 39			      add   HL, SP 
1441 f9			      ld    SP, HL 
1442			 
1442			free_early_exit: 
1442 dd e1		      pop   IX 
1444 d1			      pop   DE 
1445 c1			      pop   BC 
1446			 
1446 c9			      ret 
1447			 
1447			; moved to firmware.asm 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			;                  .dw   0 
1447			 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_3 
1447			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1447			;heap_start        .equ  0x9000      ; Starting address of heap 
1447			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1447			; 
1447			 ;     .org 0 
1447			  ;    jp    main 
1447			; 
1447			; 
1447			 ;     .org  0x100 
1447			;main: 
1447			 ;     ld    HL, 0x8100 
1447			  ;    ld    SP, HL 
1447			; 
1447			;      call  heap_init 
1447			 
1447			      ; Make some allocations 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9004 
1447			; 
1447			 ;     ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9014 
1447			 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9024 
1447			 
1447			      ; Free some allocations 
1447			;      ld    HL, 0x9014 
1447			;      call  free 
1447			 
1447			;      ld    HL, 0x9004 
1447			;      call  free 
1447			; 
1447			;      ld    HL, 0x9024 
1447			;      call  free 
1447			 
1447			 
1447			 ;     halt 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     heap_init                                                               : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Initialise the heap and make it ready for malloc and free operations.   : 
1447			;                                                                             : 
1447			;     The heap is maintained as a linked list, starting with an initial       : 
1447			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1447			;     the first free block in the heap. Each block then points to the next    : 
1447			;     free block within the heap, and the free list ends at the first block   : 
1447			;     with a null pointer to the next free block.                             : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     Inputs are compile-time only. Two defines which specify the starting    : 
1447			;     address of the heap and its size are required, along with a memory      : 
1447			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1447			;     principally stores a pointer to the first free block in the heap.       : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;------------------------------------------------------------------------------ 
1447			heap_init: 
1447			      push  HL 
1447			 
1447			      ; Initialise free list struct 
1447			      ld    HL, heap_start 
1447			      ld    (free_list), HL 
1447			      ld    HL, 0 
1447			      ld    (free_list+2), HL 
1447			 
1447			      ; Insert first free block at bottom of heap, consumes entire heap 
1447			      ld    HL, heap_start+heap_size-4 
1447			      ld    (heap_start), HL        ; Next block (end of free list) 
1447			      ld    HL, heap_size-4 
1447			      ld    (heap_start+2), HL      ; Block size 
1447			 
1447			      ; Insert end of free list block at top of heap - two null words will 
1447			      ; terminate the free list 
1447			      ld    HL, 0 
1447			      ld    (heap_start+heap_size-2), HL 
1447			      ld    (heap_start+heap_size-4), HL 
1447			 
1447			      pop   HL 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     malloc                                                                  : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Allocates the wanted space from the heap and returns the address of the : 
1447			;     first useable byte of the allocation.                                   : 
1447			;                                                                             : 
1447			;     Allocations can happen in one of two ways:                              : 
1447			;                                                                             : 
1447			;     1. A free block may be found which is the exact size wanted. In this    : 
1447			;        case the block is removed from the free list and retuedn to the      : 
1447			;        caller.                                                              : 
1447			;     2. A free block may be found which is larger than the size wanted. In   : 
1447			;        this case, the larger block is split into two. The first portion of  : 
1447			;        this block will become the requested space by the malloc call and    : 
1447			;        is returned to the caller. The second portion becomes a new free     : 
1447			;        block, and the free list is adjusted to maintain continuity via this : 
1447			;        newly created block.                                                 : 
1447			;                                                                             : 
1447			;     malloc does not set any initial value in the allocated space, the       : 
1447			;     caller is required to do this as required.                              : 
1447			;                                                                             : 
1447			;     This implementation of malloc uses the stack exclusively, and is        : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling malloc, and recommended  : 
1447			;     to avoid the use of malloc inside ISRs in general.                      : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Number of bytes wanted                                              : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     HL  Address of the first useable byte of the allocation                 : 
1447			;                                                                             : 
1447			; Flags                                                                       : 
1447			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +4  +-------------+                                                       : 
1447			;       |  this_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			malloc: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if no space requested 
1447			      or    L 
1447			      jp    Z, malloc_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; Setup initial state 
1447			      ld    HL, 4                   ; want must also include space used by block struct 
1447			      add   HL, DE 
1447			 
1447			      ld    B, H                    ; Move want to BC 
1447			      ld    C, L 
1447			 
1447			      ld    HL, free_list           ; Store prev_free ptr to stack 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    E, (HL)                 ; Store this_free ptr to stack 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ld    (IX+2), E 
1447			      ld    (IX+3), D 
1447			      ex    DE, HL                  ; this_free ptr into HL 
1447			 
1447			      ; Loop through free block list to find some space 
1447			malloc_find_space: 
1447			      ld    E, (HL)                 ; Load next_free ptr into DE 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1447			      or    E 
1447			      jp    Z, malloc_no_space 
1447			 
1447			      ld    (IX+0), E               ; Store next_free ptr to stack 
1447			      ld    (IX+1), D 
1447			 
1447			      ; Does this block have enough space to make the allocation? 
1447			      inc   HL                      ; Load free block size into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ex    DE, HL                  ; Check size of block against want 
1447			      or    A                       ; Ensure carry flag clear 
1447			      sbc   HL, BC 
1447			      push  HL                      ; Store the result for later (new block size) 
1447			 
1447			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1447			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1447			 
1447			      ; this_free block is not big enough, setup ptrs to test next free block 
1447			      pop   HL                      ; Discard previous result 
1447			 
1447			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1447			      ld    H, (IX+3) 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1447			      ld    H, (IX+1) 
1447			      ld    (IX+2), L 
1447			      ld    (IX+3), H 
1447			 
1447			      jr    malloc_find_space 
1447			 
1447			      ; split a bigger block into two - requested size and remaining size 
1447			malloc_alloc_split: 
1447			      ex    DE, HL                  ; Calculate address of new free block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      add   HL, BC 
1447			 
1447			      ; Create a new block and point it at next_free 
1447			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      ld    (HL), E                 ; Store next_free ptr into new block 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   DE                      ; Store size of new block into new block 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Update this_free ptr to point to new block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1447			      ld    (IX+3), H 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store want size into allocated block 
1447			      ld    (HL), C 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			      inc   HL 
1447			      push  HL                      ; Address of allocation to return 
1447			 
1447			      jr    malloc_update_links 
1447			 
1447			malloc_alloc_fit: 
1447			      pop   HL                      ; Dont need new block size, want is exact fit 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store address of allocation to return 
1447			      inc   HL 
1447			      inc   HL 
1447			      push  HL 
1447			 
1447			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1447			      ld    L, (IX+0)               ; next_free to HL 
1447			      ld    H, (IX+1) 
1447			 
1447			      ld    (IX+2), L               ; HL to this_free 
1447			      ld    (IX+3), H 
1447			 
1447			 
1447			malloc_update_links: 
1447			      ; Update prev_free ptr to point to this_free 
1447			      ld    L, (IX+4)               ; prev_free ptr to HL 
1447			      ld    H, (IX+5) 
1447			 
1447			      ld    E, (IX+2)               ; this_free ptr to DE 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (HL), E                 ; this_free ptr into prev_free 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Clear the Z flag to indicate successful allocation 
1447			      ld    A, D 
1447			      or    E 
1447			 
1447			      pop   DE                      ; Address of allocation 
1447			 
1447			malloc_no_space: 
1447			      ld    HL, 6                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			      ex    DE, HL                  ; Alloc addr into HL for return 
1447			 
1447			malloc_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     free                                                                    : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1447			;     returned by malloc, otherwise the behaviour is undefined.               : 
1447			;                                                                             : 
1447			;     Where possible, directly adjacent free blocks will be merged together   : 
1447			;     into larger blocks to help ensure that the heap does not become         : 
1447			;     excessively fragmented.                                                 : 
1447			;                                                                             : 
1447			;     free does not clear or set any other value into the freed space, and    : 
1447			;     therefore its contents may be visible through subsequent malloc's. The  : 
1447			;     caller should clear the freed space as required.                        : 
1447			;                                                                             : 
1447			;     This implementation of free uses the stack exclusively, and is          : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling free, and recommended    : 
1447			;     to avoid the use of free inside ISRs in general.                        : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Pointer to address of first byte of allocation to be freed          : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			free: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if ptr is null 
1447			      or    L 
1447			      jp    Z, free_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; The address in HL points to the start of the useable allocated space, 
1447			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1447			      ; address of the block itself. 
1447			      ex    DE, HL 
1447			      ld    DE, -4 
1447			      add   HL, DE 
1447			 
1447			      ; An allocated block must have a null next block pointer in it 
1447			      ld    A, (HL) 
1447			      inc   HL 
1447			      or    (HL) 
1447			      jp    NZ, free_done 
1447			 
1447			      dec   HL 
1447			 
1447			      ld    B, H                    ; Copy HL to BC 
1447			      ld    C, L 
1447			 
1447			      ; Loop through the free list to find the first block with an address 
1447			      ; higher than the block being freed 
1447			      ld    HL, free_list 
1447			 
1447			free_find_higher_block: 
1447			      ld    E, (HL)                 ; Load next ptr from free block 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			 
1447			      ld    (IX+0), E               ; Save ptr to next free block 
1447			      ld    (IX+1), D 
1447			      ld    (IX+2), L               ; Save ptr to prev free block 
1447			      ld    (IX+3), H 
1447			 
1447			      ld    A, B                    ; Check if DE is greater than BC 
1447			      cp    D                       ; Compare MSB first 
1447			      jr    Z, $+4                  ; MSB the same, compare LSB 
1447			      jr    NC, free_find_higher_block_skip 
1447			      ld    A, C 
1447			      cp    E                       ; Then compare LSB 
1447			      jr    C, free_found_higher_block 
1447			 
1447			free_find_higher_block_skip: 
1447			      ld    A, D                    ; Reached the end of the free list? 
1447			      or    E 
1447			      jp    Z, free_done 
1447			 
1447			      ex    DE, HL 
1447			 
1447			      jr    free_find_higher_block 
1447			 
1447			free_found_higher_block: 
1447			      ; Insert freed block between prev and next free blocks 
1447			      ld    (HL), C                 ; Point prev free block to freed block 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			 
1447			      ld    H, B                    ; Point freed block at next free block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Check if the freed block is adjacent to the next free block 
1447			      inc   HL                      ; Load size of freed block into HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      add   HL, BC                  ; Add addr of freed block and its size 
1447			 
1447			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_check_adjacent_to_prev 
1447			 
1447			      ; Freed block is adjacent to next, merge into one bigger block 
1447			      ex    DE, HL                  ; Load next ptr from next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save ptr to next block for later 
1447			 
1447			      ld    H, B                    ; Store ptr from next block into freed block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore ptr to next block 
1447			      inc   HL                      ; Load size of next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save next block size for later 
1447			 
1447			      ld    H, B                    ; Load size of freed block into HL 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      pop   DE                      ; Restore size of next block 
1447			      add   HL, DE                  ; Add sizes of both blocks 
1447			      ex    DE, HL 
1447			 
1447			      ld    H, B                    ; Store new bigger size into freed block 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_check_adjacent_to_prev: 
1447			      ; Check if the freed block is adjacent to the prev free block 
1447			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1447			      ld    H, (IX+3) 
1447			 
1447			      inc   HL                      ; Size of prev free block into DE 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      add   HL, DE                  ; Add prev block addr and size 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_done 
1447			 
1447			      ; Freed block is adjacent to prev, merge into one bigger block 
1447			      ld    H, B                    ; Load next ptr from freed block into DE 
1447			      ld    L, C 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save freed block ptr for later 
1447			 
1447			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1447			      ld    H, (IX+3) 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore freed block ptr 
1447			      inc   HL                      ; Load size of freed block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save freed block size for later 
1447			 
1447			      ld    L, (IX+2)               ; Load size of prev block into DE 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      pop   HL                      ; Add sizes of both blocks 
1447			      add   HL, DE 
1447			      ex    DE, HL 
1447			 
1447			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_done: 
1447			      ld    HL, 4                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			free_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;      .org 0x8000 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			 ;                 .dw   0 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_4 
1447			 
1447			; My memory allocation code. Very very simple.... 
1447			; allocate space under 250 chars 
1447			 
1447			heap_init: 
1447				; init start of heap as zero 
1447				;  
1447			 
1447				ld hl, heap_start 
1447				ld a, 0 
1447				ld (hl), a      ; empty block 
1447				inc hl 
1447				ld a, 0 
1447				ld (hl), a      ; length of block 
1447				; write end of list 
1447				inc hl 
1447				ld a,(hl) 
1447				inc hl 
1447				ld a,(hl) 
1447				 
1447			 
1447				; init some malloc vars 
1447			 
1447				ld hl, 0 
1447				ld (free_list), hl       ; store last malloc location 
1447			 
1447				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1447				ld a, 0 
1447				ld (hl), a 
1447			 
1447			 
1447				ld hl, heap_start 
1447				;  
1447				  
1447				ret 
1447			 
1447			 
1447			;    free block marker 
1447			;    requested size  
1447			;    pointer to next block 
1447			;    .... 
1447			;    next block marker 
1447			 
1447			 
1447			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1447			; 
1447			 
1447			 
1447			malloc:  
1447				push de 
1447				push bc 
1447				push af 
1447			 
1447				; hl space required 
1447				 
1447				ld c, l    ; hold space   (TODO only a max of 255) 
1447			 
1447			;	inc c     ; TODO BUG need to fix memory leak on push str 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			 
1447			 
1447			 
1447				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1447			 
1447				ld a, (free_list+3) 
1447				cp 0 
1447				jr z, .contheap 
1447			 
1447				ld hl, (free_list)     ; get last alloc 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mrs" 
1447						CALLMONITOR 
1447					endif 
1447				jr .startalloc 
1447			 
1447			.contheap: 
1447				ld hl, heap_start 
1447			 
1447			.startalloc: 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mym" 
1447						CALLMONITOR 
1447					endif 
1447			.findblock: 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmf" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447				ld a,(hl)  
1447				; if byte is zero then clear to use 
1447			 
1447				cp 0 
1447				jr z, .foundemptyblock 
1447			 
1447				; if byte is not clear 
1447				;     then byte is offset to next block 
1447			 
1447				inc hl 
1447				ld a, (hl) ; get size 
1447			.nextblock:	inc hl 
1447					ld e, (hl) 
1447					inc hl 
1447					ld d, (hl) 
1447					ex de, hl 
1447			;	inc hl  ; move past the store space 
1447			;	inc hl  ; move past zero index  
1447			 
1447				; TODO detect no more space 
1447			 
1447				push hl 
1447				ld de, heap_end 
1447				call cmp16 
1447				pop hl 
1447				jr nc, .nospace 
1447			 
1447				jr .findblock 
1447			 
1447			.nospace: ld hl, 0 
1447				jp .exit 
1447			 
1447			 
1447			.foundemptyblock:	 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mme" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; TODO has block enough space if reusing??? 
1447			 
1447				;  
1447			 
1447			; see if this block has been previously used 
1447				inc hl 
1447				ld a, (hl) 
1447				dec hl 
1447				cp 0 
1447				jr z, .newblock 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meR" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; no reusing previously allocated block 
1447			 
1447			; is it smaller than previously used? 
1447				 
1447				inc hl    ; move to size 
1447				ld a, c 
1447				sub (hl)        ; we want c < (hl) 
1447				dec hl    ; move back to marker 
1447			        jr z, .findblock 
1447			 
1447				; update with the new size which should be lower 
1447			 
1447			        ;inc  hl   ; negate next move. move back to size  
1447			 
1447			.newblock: 
1447				; need to be at marker here 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meN" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			 
1447				ld a, c 
1447			 
1447				ld (free_list+3), a	 ; flag resume from last malloc  
1447				ld (free_list), hl    ; save out last location 
1447			 
1447			 
1447				;inc a     ; space for length byte 
1447				ld (hl), a     ; save block in use marker 
1447			 
1447				inc hl   ; move to space marker 
1447				ld (hl), a    ; save new space 
1447			 
1447				inc hl   ; move to start of allocated area 
1447				 
1447			;	push hl     ; save where we are - 1  
1447			 
1447			;	inc hl  ; move past zero index  
1447				; skip space to set down new marker 
1447			 
1447				; provide some extra space for now 
1447			 
1447				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1447				inc a 
1447				inc a 
1447			 
1447				push hl   ; save where we are in the node block 
1447			 
1447				call addatohl 
1447			 
1447				; write linked list point 
1447			 
1447				pop de     ; get our node position 
1447				ex de, hl 
1447			 
1447				ld (hl), e 
1447				inc hl 
1447				ld (hl), d 
1447			 
1447				inc hl 
1447			 
1447				; now at start of allocated data so save pointer 
1447			 
1447				push hl 
1447			 
1447				; jump to position of next node and setup empty header in DE 
1447			 
1447				ex de, hl 
1447			 
1447			;	inc hl ; move past end of block 
1447			 
1447				ld a, 0 
1447				ld (hl), a   ; empty marker 
1447				inc hl 
1447				ld (hl), a   ; size 
1447				inc hl  
1447				ld (hl), a   ; ptr 
1447				inc hl 
1447				ld (hl), a   ; ptr 
1447			 
1447			 
1447				pop hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmr" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			.exit: 
1447				pop af 
1447				pop bc 
1447				pop de  
1447				ret 
1447			 
1447			 
1447			 
1447			 
1447			free:  
1447				push hl 
1447				push af 
1447				; get address in hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "fre" 
1447						CALLMONITOR 
1447					endif 
1447				; data is at hl - move to block count 
1447				dec hl 
1447				dec hl    ; get past pointer 
1447				dec hl 
1447			 
1447				ld a, (hl)    ; need this for a validation check 
1447			 
1447				dec hl    ; move to block marker 
1447			 
1447				; now check that the block count and block marker are the same  
1447			        ; this checks that we are on a malloc node and not random memory 
1447			        ; OK a faint chance this could be a problem but rare - famous last words! 
1447			 
1447				ld c, a 
1447				ld a, (hl)    
1447			 
1447				cp c 
1447				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1447			 
1447				; yes good chance we are on a malloc node 
1447			 
1447				ld a, 0      
1447				ld (hl), a   ; mark as free 
1447			 
1447				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1447			 
1447			.freeignore:  
1447			 
1447				pop af 
1447				pop hl 
1447			 
1447				ret 
1447			 
1447			 
1447			 
1447			endif 
1447			 
1447			; eof 
# End of file firmware_memory.asm
1447			  
1447			; device C  
1447			; Now handled by SPI  
1447			;if SOUND_ENABLE  
1447			;	include "firmware_sound.asm"  
1447			;endif  
1447			  
1447			include "firmware_diags.asm"  
1447			; Hardware diags menu 
1447			 
1447			 
1447			config: 
1447			 
1447 3e 00			ld a, 0 
1449 21 6d 14			ld hl, .configmn 
144c cd eb 0b			call menu 
144f			 
144f fe 00			cp 0 
1451 c8				ret z 
1452			 
1452			;	cp 1 
1452			;	call z, .savetostore 
1452			 
1452 fe 01			cp 1 
1454			if STARTUP_V1 
1454 cc 83 14			call z, .selautoload 
1457			endif 
1457			 
1457			if STARTUP_V2 
1457				call z, .enautoload 
1457			endif 
1457 fe 02			cp 2 
1459 cc 79 14			call z, .disautoload 
145c			;	cp 3 
145c			;	call z, .selbank 
145c fe 03			cp 3 
145e cc a1 14			call z, .debug_tog 
1461 fe 04			cp 4 
1463 cc ef 15			call z, .bpsgo 
1466 fe 05			cp 5 
1468 cc ca 14			call z, hardware_diags 
146b			if STARTUP_V2 
146b				cp 6 
146b				call z, create_startup 
146b			endif 
146b 18 da			jr config 
146d			 
146d			.configmn: 
146d			;	dw prom_c3 
146d dd 17			dw prom_c2 
146f f2 17			dw prom_c2a 
1471			;	dw prom_c2b 
1471			;	dw prom_c4 
1471 11 18			dw prom_m4 
1473 2c 18			dw prom_m4b 
1475 34 18			dw prom_c1 
1477			if STARTUP_V2 
1477				dw prom_c9 
1477			endif 
1477 00 00			dw 0 
1479				 
1479			 
1479			if STARTUP_V2 
1479			.enautoload: 
1479				if STORAGE_SE 
1479				ld a, $fe      ; bit 0 clear 
1479				ld (spi_device), a 
1479			 
1479				call storage_get_block_0 
1479			 
1479				ld a, 1 
1479				ld (store_page+STORE_0_AUTOFILE), a 
1479			 
1479					ld hl, 0 
1479					ld de, store_page 
1479				call storage_write_block	 ; save update 
1479				else 
1479			 
1479				ld hl, prom_notav 
1479				ld de, prom_empty 
1479				call info_panel 
1479				endif 
1479			 
1479			 
1479				ret 
1479			endif 
1479			 
1479			.disautoload: 
1479				if STORAGE_SE 
1479				ld a, $fe      ; bit 0 clear 
1479				ld (spi_device), a 
1479			 
1479				call storage_get_block_0 
1479			 
1479				ld a, 0 
1479				ld (store_page+STORE_0_AUTOFILE), a 
1479			 
1479					ld hl, 0 
1479					ld de, store_page 
1479				call storage_write_block	 ; save update 
1479				else 
1479			 
1479 21 43 18			ld hl, prom_notav 
147c 11 59 18			ld de, prom_empty 
147f cd 4b 0b			call info_panel 
1482				endif 
1482			 
1482			 
1482 c9				ret 
1483			 
1483			if STARTUP_V1 
1483			 
1483			; Select auto start 
1483			 
1483			.selautoload: 
1483			 
1483				 
1483				if STORAGE_SE 
1483			 
1483					call config_dir 
1483				        ld hl, scratch 
1483					ld a, 0 
1483					call menu 
1483			 
1483					cp 0 
1483					ret z 
1483			 
1483					dec a 
1483			 
1483			 
1483					; locate menu option 
1483			 
1483					ld hl, scratch 
1483					call table_lookup 
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALl" 
1483						CALLMONITOR 
1483					endif 
1483					; with the pointer to the menu it, the byte following the zero term is the file id 
1483			 
1483					ld a, 0 
1483					ld bc, 50   ; max of bytes to look at 
1483					cpir  
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALb" 
1483						CALLMONITOR 
1483					endif 
1483					;inc hl 
1483			 
1483					ld a, (hl)   ; file id 
1483					 
1483				        ; save bank and file ids 
1483			 
1483					push af 
1483			 
1483			; TODO need to save to block 0 on bank 1	 
1483			 
1483					call storage_get_block_0 
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "AL0" 
1483						CALLMONITOR 
1483					endif 
1483					pop af 
1483			 
1483					ld (store_page+STORE_0_FILERUN),a 
1483					 
1483					; save bank id 
1483			 
1483					ld a,(spi_device) 
1483					ld (store_page+STORE_0_BANKRUN),a 
1483			 
1483					; enable auto run of store file 
1483			 
1483					ld a, 1 
1483					ld (store_page+STORE_0_AUTOFILE),a 
1483			 
1483					; save buffer 
1483			 
1483					ld hl, 0 
1483					ld de, store_page 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALw" 
1483						CALLMONITOR 
1483					endif 
1483				call storage_write_block	 ; save update 
1483			  
1483			 
1483			 
1483			 
1483					ld hl, scratch 
1483					call config_fdir 
1483			 
1483				else 
1483			 
1483 21 43 18			ld hl, prom_notav 
1486 11 59 18			ld de, prom_empty 
1489 cd 4b 0b			call info_panel 
148c			 
148c				endif 
148c c9				ret 
148d			endif 
148d			 
148d			 
148d			; Select storage bank 
148d			 
148d			.selbank: 
148d			 
148d			;	if STORAGE_SE 
148d			;	else 
148d			 
148d 21 43 18			ld hl, prom_notav 
1490 11 59 18			ld de, prom_empty 
1493 cd 4b 0b			call info_panel 
1496			;	endif 
1496				 
1496 c9				ret 
1497			 
1497			if STORAGE_SE 
1497			 
1497			.config_ldir:   
1497				; Load storage bank labels into menu array 
1497			 
1497				 
1497			 
1497			 
1497				ret 
1497			 
1497			 
1497			endif 
1497			 
1497			 
1497			; Save user words to storage 
1497			 
1497			.savetostore: 
1497			 
1497			;	if STORAGE_SE 
1497			; 
1497			;		call config_dir 
1497			;	        ld hl, scratch 
1497			;		ld a, 0 
1497			;		call menu 
1497			;		 
1497			;		ld hl, scratch 
1497			;		call config_fdir 
1497			; 
1497			;	else 
1497			 
1497 21 43 18			ld hl, prom_notav 
149a 11 59 18			ld de, prom_empty 
149d cd 4b 0b			call info_panel 
14a0			 
14a0			;	endif 
14a0			 
14a0 c9				ret 
14a1			 
14a1			if STARTUP_V2 
14a1			 
14a1			create_startup: 
14a1			 
14a1				ld a, 0 
14a1				ld hl, .crstart 
14a1				call menu 
14a1			 
14a1				cp 0 
14a1				ret z 
14a1			 
14a1				cp 1 
14a1				call z, .genlsword 
14a1				cp 2 
14a1				call z, .genedword 
14a1			 
14a1				cp 3 
14a1				call z, .gendemword 
14a1			 
14a1				cp 4 
14a1				call z, .genutlword 
14a1				cp 5 
14a1				call z, .genspiword 
14a1				cp 6 
14a1				call z, .genkeyword 
14a1				cp 7 
14a1				call z, .gensoundword 
14a1				jr create_startup 
14a1			 
14a1			.gensoundword: 
14a1				ld hl, crs_sound 
14a1				ld de, .soundworddef 
14a1				call .genfile 
14a1				ret 
14a1			.genlsword: 
14a1				ld hl, crs_s1 
14a1				ld de, .lsworddef 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.genedword: 
14a1				ld de, .edworddef 
14a1				ld hl, crs_s2 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.gendemword: 
14a1				ld de, .demoworddef 
14a1				ld hl, crs_s3 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.genutlword: 
14a1				ld hl, crs_s4 
14a1				ld de, .utilwordef 
14a1				call .genfile 
14a1				ret 
14a1			.genspiword: 
14a1				ld hl, crs_s5 
14a1				ld de, .spiworddef 
14a1				call .genfile 
14a1				ret 
14a1			.genkeyword: 
14a1				ld hl, crs_s6 
14a1				ld de, .keyworddef 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			; hl - points to file name 
14a1			; de - points to strings to add to file 
14a1			 
14a1			.genfile: 
14a1				push hl 
14a1				push de 
14a1			 
14a1				call clear_display 
14a1				ld a, display_row_1 
14a1				ld de, .genfiletxt 
14a1				call str_at_display 
14a1				call update_display 
14a1			 
14a1				pop de 
14a1				pop hl 
14a1			 
14a1			 
14a1				push de 
14a1				call storage_create 
14a1				; id in hl 
14a1				pop de   ; table of strings to add 
14a1			 
14a1			.genloop: 
14a1			 
14a1				push hl ; save id for next time around 
14a1				push de ; save de for next time around 
14a1			 
14a1				ex de, hl 
14a1				call loadwordinhl 
14a1				ex de, hl 
14a1			 
14a1				; need hl to be the id 
14a1				; need de to be the string ptr 
14a1				 
14a1				call storage_append 
14a1			 
14a1				pop de 
14a1				pop hl 
14a1			 
14a1				inc de 
14a1				inc de 
14a1			 
14a1				ld a,(de) 
14a1				cp 0 
14a1				jr nz, .genloop 
14a1				inc de 
14a1				ld a, (de) 
14a1				dec de 
14a1				cp 0 
14a1				jr nz, .genloop	 
14a1			 
14a1				ret 
14a1			 
14a1			.genfiletxt:  db "Creating file...",0 
14a1			 
14a1			.soundworddef: 
14a1				dw sound1 
14a1				dw sound2 
14a1				dw sound3 
14a1				dw sound4 
14a1				dw sound5 
14a1				dw sound6 
14a1				dw sound7 
14a1				dw sound8 
14a1				dw sound9 
14a1				dw 0 
14a1			 
14a1			.utilwordef: 
14a1				dw strncpy 
14a1				dw type 
14a1				dw clrstack 
14a1				dw longread 
14a1				dw start1 
14a1				dw start2 
14a1				dw start3b 
14a1				dw start3c 
14a1				dw list 
14a1				dw 0 
14a1			 
14a1			.lsworddef: 
14a1				dw start3b 
14a1				dw 0 
14a1			 
14a1			.edworddef: 
14a1				dw edit1 
14a1				dw edit2 
14a1				dw edit3 
14a1				dw 0 
14a1			 
14a1			.demoworddef: 
14a1				dw test5 
14a1				dw test6 
14a1				dw test7 
14a1				dw test8 
14a1				dw test9 
14a1				dw test10 
14a1				dw game1 
14a1				dw game1a 
14a1				dw game1b 
14a1				dw game1c 
14a1				dw game1d 
14a1				dw game1s 
14a1				dw game1t 
14a1				dw game1f 
14a1				dw game1z 
14a1				dw game1zz 
14a1				dw ssv2 
14a1				dw ssv3 
14a1				dw ssv4 
14a1				dw ssv5 
14a1				dw ssv1 
14a1				dw ssv1cpm	 
14a1				dw game2b 
14a1				dw game2bf 
14a1				dw game2mba 
14a1				dw game2mbas	 
14a1				dw game2mbht 
14a1				dw game2mbms 
14a1				dw game2mb 
14a1				dw game3w 
14a1				dw game3p 
14a1				dw game3sc 
14a1				dw game3vsi 
14a1				dw game3vs 
14a1				dw 0 
14a1			 
14a1			 
14a1			.spiworddef: 
14a1			 
14a1			    dw spi1 
14a1			    dw spi2 
14a1			    dw spi3 
14a1			    dw spi4 
14a1			    dw spi5 
14a1			    dw spi6 
14a1			    dw spi7 
14a1			 
14a1			    dw spi8 
14a1			    dw spi9 
14a1			    dw spi10 
14a1			    dw 0 
14a1			 
14a1			.keyworddef: 
14a1			 
14a1				dw keyup 
14a1				dw keydown 
14a1				dw keyleft 
14a1				dw keyright 
14a1				dw 	keyf1 
14a1				dw keyf2 
14a1				dw keyf3 
14a1				dw keyf4 
14a1				dw keyf5 
14a1				dw keyf6 
14a1				dw keyf7 
14a1				dw keyf8 
14a1				dw keyf9 
14a1				dw keyf10 
14a1				dw keyf11 
14a1				dw keyf12 
14a1				dw keytab 
14a1				dw keycr 
14a1				dw keyhome 
14a1				dw keyend 
14a1				dw keybs 
14a1				dw 0 
14a1			 
14a1			.crstart: 
14a1				dw crs_s1 
14a1				dw crs_s2 
14a1				dw crs_s3 
14a1				dw crs_s4 
14a1				dw crs_s5 
14a1				dw crs_s6 
14a1				dw 0 
14a1			 
14a1			endif 
14a1			 
14a1			 
14a1			if STORAGE_SE 
14a1			 
14a1			config_fdir: 
14a1				; using the scratch dir go through and release the memory allocated for each string 
14a1				 
14a1				ld hl, scratch 
14a1			.cfdir:	ld e,(hl) 
14a1				inc hl 
14a1				ld d,(hl) 
14a1				inc hl 
14a1			 
14a1				ex de, hl 
14a1				call ishlzero 
14a1				ret z     ; return on null pointer 
14a1				call free 
14a1				ex de, hl 
14a1				jr .cfdir 
14a1			 
14a1			 
14a1				ret 
14a1			 
14a1			 
14a1			config_dir: 
14a1			 
14a1				; for the config menus that need to build a directory of storage call this routine 
14a1				; it will construct a menu in scratch to pass to menu 
14a1			 
14a1				; open storage device 
14a1			 
14a1				; execute DIR to build a list of files and their ids into scratch in menu format 
14a1				; once the menu has finished then will need to call config_fdir to release the strings 
14a1				 
14a1				; c = number items 
14a1			 
14a1				 
14a1				call storage_get_block_0 
14a1			 
14a1				ld hl, store_page     ; get current id count 
14a1				ld b, (hl) 
14a1				ld c, 0    ; count of files   
14a1			 
14a1			 
14a1				ld hl, scratch 
14a1				ld (store_tmp2), hl    ; location to poke strings 
14a1			 
14a1				; check for empty drive 
14a1			 
14a1				ld a, 0 
14a1				cp b 
14a1				jp z, .dirdone 
14a1			 
14a1				 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "Cdc" 
14a1						CALLMONITOR 
14a1					endif 
14a1			 
14a1			 
14a1			.diritem:	 
14a1				push bc 
14a1				; for each of the current ids do a search for them and if found push to stack 
14a1			 
14a1					ld hl, STORE_BLOCK_PHY 
14a1					ld d, 0		 ; look for extent 0 of block id as this contains file name 
14a1					ld e,b 
14a1			 
14a1					call storage_findnextid 
14a1			 
14a1			 
14a1					; if found hl will be non zero 
14a1			 
14a1					call ishlzero 
14a1					jr z, .dirnotfound 
14a1			 
14a1					; increase count 
14a1			 
14a1					pop bc	 
14a1					inc c 
14a1					push bc 
14a1					 
14a1			 
14a1					; get file header and push the file name 
14a1			 
14a1					ld de, store_page 
14a1					call storage_read_block 
14a1			 
14a1					; push file id to stack 
14a1				 
14a1					ld a, (store_page) 
14a1					ld h, 0 
14a1					ld l, a 
14a1			 
14a1					;call forth_push_numhl 
14a1					; TODO store id 
14a1			 
14a1					push hl 
14a1			 
14a1					; push extent count to stack  
14a1				 
14a1					ld hl, store_page+3 
14a1			 
14a1					; get file name length 
14a1			 
14a1					call strlenz   
14a1			 
14a1					inc hl   ; cover zero term 
14a1					inc hl  ; stick the id at the end of the area 
14a1			 
14a1					push hl 
14a1					pop bc    ; move length to bc 
14a1			 
14a1					call malloc 
14a1			 
14a1					; TODO save malloc area to scratch 
14a1			 
14a1					ex de, hl 
14a1					ld hl, (store_tmp2) 
14a1					ld (hl), e 
14a1					inc hl 
14a1					ld (hl), d 
14a1					inc hl 
14a1					ld (store_tmp2), hl 
14a1			 
14a1					 
14a1			 
14a1					;pop hl   ; get source 
14a1			;		ex de, hl    ; swap aronund	 
14a1			 
14a1					ld hl, store_page+3 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "CFd" 
14a1						CALLMONITOR 
14a1					endif 
14a1					ldir 
14a1			 
14a1					; de is past string, move back one and store id 
14a1					 
14a1					dec de 
14a1			 
14a1					; store file id 
14a1			 
14a1					pop hl 
14a1					ex de,hl 
14a1					ld (hl), e 
14a1			 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "Cdi" 
14a1						CALLMONITOR 
14a1					endif 
14a1					 
14a1			.dirnotfound: 
14a1					pop bc     
14a1					djnz .diritem 
14a1				 
14a1			.dirdone:	 
14a1			 
14a1					ld a, 0 
14a1					ld hl, (store_tmp2) 
14a1					ld (hl), a 
14a1					inc hl 
14a1					ld (hl), a 
14a1					inc hl 
14a1					; push a count of the dir items found 
14a1			 
14a1			;		ld h, 0 
14a1			;		ld l, c 
14a1			 
14a1				ret 
14a1			 
14a1			endif 
14a1			 
14a1			 
14a1			; Settings 
14a1			; Run  
14a1			 
14a1			 
14a1			 
14a1			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
14a1			;;hd_menu2:   db "        2: Editor",0   
14a1			;hd_menu2:   db "        2: Editor       6: Menu",0   
14a1			;hd_menu3:   db "        3: Storage",0 
14a1			;hd_menu4:   db "0=quit  4: Debug",0 
14a1			;hd_don:     db "ON",0 
14a1			;hd_doff:     db "OFF",0 
14a1			; 
14a1			; 
14a1			; 
14a1			;hardware_diags_old:       
14a1			; 
14a1			;.diagmenu: 
14a1			;	call clear_display 
14a1			;	ld a, display_row_1 
14a1			;	ld de, hd_menu1 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a, display_row_2 
14a1			;	ld de, hd_menu2 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a, display_row_3 
14a1			;	ld de, hd_menu3 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a,  display_row_4 
14a1			;	ld de, hd_menu4 
14a1			;	call str_at_display 
14a1			; 
14a1			;	; display debug state 
14a1			; 
14a1			;	ld de, hd_don 
14a1			;	ld a, (os_view_disable) 
14a1			;	cp 0 
14a1			;	jr z, .distog 
14a1			;	ld de, hd_doff 
14a1			;.distog: ld a, display_row_4+17 
14a1			;	call str_at_display 
14a1			; 
14a1			;	call update_display 
14a1			; 
14a1			;	call cin_wait 
14a1			; 
14a1			; 
14a1			; 
14a1			;	cp '4' 
14a1			;	jr nz, .diagn1 
14a1			; 
14a1			;	; debug toggle 
14a1			; 
14a1			;	ld a, (os_view_disable) 
14a1			;	ld b, '*' 
14a1			;	cp 0 
14a1			;	jr z, .debtog 
14a1			;	ld b, 0 
14a1			;.debtog:	 
14a1			;	ld a,b 
14a1			;	ld (os_view_disable),a 
14a1			; 
14a1			;.diagn1: cp '0' 
14a1			;	 ret z 
14a1			; 
14a1			;;	cp '1' 
14a1			;;       jp z, matrix	 
14a1			;;   TODO keyboard matrix test 
14a1			; 
14a1			;	cp '2' 
14a1			;	jp z, .diagedit 
14a1			; 
14a1			;;	cp '6' 
14a1			;;	jp z, .menutest 
14a1			;;if ENABLE_BASIC 
14a1			;;	cp '6' 
14a1			;;	jp z, basic 
14a1			;;endif 
14a1			 ; 
14a1			;	jp .diagmenu 
14a1			; 
14a1			; 
14a1			;	ret 
14a1			 
14a1			 
14a1			.debug_tog: 
14a1 21 eb 14			ld hl, .menudebug 
14a4				 
14a4			;	ld a, (os_view_disable) 
14a4			;	cp '*' 
14a4 3a 6f ee			ld a,(debug_vector) 
14a7 fe c9			cp $C9   ; RET 
14a9 20 04			jr nz,.tdon  
14ab 3e 01			ld a, 1 
14ad 18 02			jr .tog1 
14af 3e 00		.tdon: ld a, 0 
14b1			 
14b1			.tog1: 
14b1 cd eb 0b			call menu 
14b4 fe 00			cp 0 
14b6 c8				ret z 
14b7 fe 01			cp 1    ; disable debug 
14b9 28 04			jr z, .dtog0 
14bb 3e 2a			ld a, '*' 
14bd 18 05			jr .dtogset 
14bf			.dtog0:  
14bf				;ld a, 0 
14bf cd dd 15			call bp_on 
14c2 18 dd			jr .debug_tog 
14c4			.dtogset:  
14c4				; ld (os_view_disable), a 
14c4 cd e9 15			call bp_off 
14c7 c3 a1 14			jp .debug_tog 
14ca			 
14ca			 
14ca			hardware_diags:       
14ca			 
14ca			.diagm: 
14ca 21 dd 14			ld hl, .menuitems 
14cd 3e 00			ld a, 0 
14cf cd eb 0b			call menu 
14d2			 
14d2 fe 00		         cp 0 
14d4 c8				 ret z 
14d5			 
14d5 fe 02			cp 2 
14d7 ca 36 15			jp z, .diagedit 
14da			 
14da			;	cp '6' 
14da			;	jp z, .menutest 
14da			;if ENABLE_BASIC 
14da			;	cp '6' 
14da			;	jp z, basic 
14da			;endif 
14da			  
14da c3 ca 14			jp .diagm 
14dd			 
14dd				 
14dd f1 14		.menuitems:   	dw .m1 
14df fc 14				dw .m2 
14e1 03 15				dw .m3 
14e3 0b 15				dw .m5 
14e5 11 15				dw .m5a 
14e7 1a 15				dw .m5b 
14e9 00 00				dw 0 
14eb			 
14eb			.menudebug: 
14eb 23 15				dw .m6 
14ed 2c 15				dw .m7 
14ef 00 00				dw 0 
14f1			 
14f1 .. 00		.m1:   db "Key Matrix",0 
14fc .. 00		.m2:   db "Editor",0 
1503 .. 00		.m3:   db "Storage",0 
150b .. 00		.m5:   db "Sound",0 
1511 .. 00		.m5a:  db "RAM Test",0 
151a .. 00		.m5b:  db "LCD Test",0 
1523			 
1523 .. 00		.m6:   db "Debug ON",0 
152c .. 00		.m7:   db "Debug OFF",0 
1536			 
1536			; debug editor 
1536			 
1536			.diagedit: 
1536			 
1536 21 c1 e2			ld hl, scratch 
1539			;	ld bc, 250 
1539			;	ldir 
1539				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1539 3e 00			ld a, 0 
153b 77				ld (hl), a 
153c 23				inc hl 
153d 77				ld (hl), a 
153e 23				inc hl 
153f 77				ld (hl), a 
1540			 
1540 cd ba 0b		        call clear_display 
1543 cd dd 0b			call update_display 
1546				;ld a, 1 
1546				;ld (hardware_diag), a 
1546			.diloop: 
1546 3e 00			ld a, display_row_1 
1548 0e 00			ld c, 0 
154a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
154c 1e 28			ld e, 40 
154e			 
154e 21 c1 e2			ld hl, scratch	 
1551 cd 14 0e			call input_str 
1554			 
1554 3e 28			ld a, display_row_2 
1556 11 c1 e2			ld de, scratch 
1559 cd cd 0b			call str_at_display 
155c cd dd 0b			call update_display 
155f			 
155f c3 46 15			jp .diloop 
1562			 
1562			 
1562			; pass word in hl 
1562			; a has display location 
1562			display_word_at: 
1562 f5				push af 
1563 e5				push hl 
1564 7c				ld a,h 
1565 21 c6 e5			ld hl, os_word_scratch 
1568 cd e8 10			call hexout 
156b e1				pop hl 
156c 7d				ld a,l 
156d 21 c8 e5			ld hl, os_word_scratch+2 
1570 cd e8 10			call hexout 
1573 21 ca e5			ld hl, os_word_scratch+4 
1576 3e 00			ld a,0 
1578 77				ld (hl),a 
1579 11 c6 e5			ld de,os_word_scratch 
157c f1				pop af 
157d cd cd 0b				call str_at_display 
1580 c9				ret 
1581			 
1581			display_ptr_state: 
1581			 
1581				; to restore afterwards 
1581			 
1581 d5				push de 
1582 c5				push bc 
1583 e5				push hl 
1584 f5				push af 
1585			 
1585				; for use in here 
1585			 
1585			;	push bc 
1585			;	push de 
1585			;	push hl 
1585			;	push af 
1585			 
1585 cd ba 0b			call clear_display 
1588			 
1588 11 60 17			ld de, .ptrstate 
158b 3e 00			ld a, display_row_1 
158d cd cd 0b			call str_at_display 
1590			 
1590				; display debug step 
1590			 
1590			 
1590 11 6b ee			ld de, debug_mark 
1593 3e 26			ld a, display_row_1+display_cols-2 
1595 cd cd 0b			call str_at_display 
1598			 
1598				; display a 
1598 11 6a 17			ld de, .ptrcliptr 
159b 3e 28			ld a, display_row_2 
159d cd cd 0b			call str_at_display 
15a0			 
15a0 f1				pop af 
15a1 2a 40 ea			ld hl,(cli_ptr) 
15a4 3e 30			ld a, display_row_2+8 
15a6 cd 62 15			call display_word_at 
15a9			 
15a9			 
15a9				; display hl 
15a9			 
15a9			 
15a9 11 72 17			ld de, .ptrclioptr 
15ac 3e 32			ld a, display_row_2+10 
15ae cd cd 0b			call str_at_display 
15b1			; 
15b1			;	pop hl 
15b1 3e 35			ld a, display_row_2+13 
15b3 2a 3e ea			ld hl,(cli_origptr) 
15b6 cd 62 15			call display_word_at 
15b9			; 
15b9			;	 
15b9			;	; display de 
15b9			 
15b9			;	ld de, .regstatede 
15b9			;	ld a, display_row_3 
15b9			;	call str_at_display 
15b9			 
15b9			;	pop de 
15b9			;	ld h,d 
15b9			;	ld l, e 
15b9			;	ld a, display_row_3+3 
15b9			;	call display_word_at 
15b9			 
15b9			 
15b9				; display bc 
15b9			 
15b9			;	ld de, .regstatebc 
15b9			;	ld a, display_row_3+10 
15b9			;	call str_at_display 
15b9			 
15b9			;	pop bc 
15b9			;	ld h,b 
15b9			;	ld l, c 
15b9			;	ld a, display_row_3+13 
15b9			;	call display_word_at 
15b9			 
15b9			 
15b9				; display dsp 
15b9			 
15b9			;	ld de, .regstatedsp 
15b9			;	ld a, display_row_4 
15b9			;	call str_at_display 
15b9			 
15b9				 
15b9			;	ld hl,(cli_data_sp) 
15b9			;	ld a, display_row_4+4 
15b9			;	call display_word_at 
15b9			 
15b9				; display rsp 
15b9			 
15b9 11 a1 17			ld de, .regstatersp 
15bc 3e 82			ld a, display_row_4+10 
15be cd cd 0b			call str_at_display 
15c1			 
15c1				 
15c1 2a f2 e9			ld hl,(cli_ret_sp) 
15c4 3e 86			ld a, display_row_4+14 
15c6 cd 62 15			call display_word_at 
15c9			 
15c9 cd dd 0b			call update_display 
15cc			 
15cc cd f2 0a			call delay1s 
15cf cd f2 0a			call delay1s 
15d2 cd f2 0a			call delay1s 
15d5			 
15d5			 
15d5 cd ce 1b			call next_page_prompt 
15d8			 
15d8				; restore  
15d8			 
15d8 f1				pop af 
15d9 e1				pop hl 
15da c1				pop bc 
15db d1				pop de 
15dc c9				ret 
15dd			 
15dd			; Update the break point vector so that the user can hook a new routine 
15dd			 
15dd			bp_on: 
15dd 3e c3			ld a, $c3    ; JP 
15df 32 6f ee			ld (debug_vector), a 
15e2 21 ef 15			ld hl, break_point_state 
15e5 22 70 ee			ld (debug_vector+1), hl 
15e8 c9				ret 
15e9			 
15e9			bp_off: 
15e9 3e c9			ld a, $c9    ; RET 
15eb 32 6f ee			ld (debug_vector), a 
15ee c9				ret 
15ef			 
15ef			 
15ef			break_point_state: 
15ef			;	push af 
15ef			; 
15ef			;	; see if disabled 
15ef			; 
15ef			;	ld a, (os_view_disable) 
15ef			;	cp '*' 
15ef			;	jr nz, .bpsgo 
15ef			;	pop af 
15ef			;	ret 
15ef			 
15ef			.bpsgo: 
15ef			;	pop af 
15ef f5				push af 
15f0 22 af e2			ld (os_view_hl), hl 
15f3 ed 53 ad e2		ld (os_view_de), de 
15f7 ed 43 ab e2		ld (os_view_bc), bc 
15fb e5				push hl 
15fc 6f				ld l, a 
15fd 26 00			ld h, 0 
15ff 22 b1 e2			ld (os_view_af),hl 
1602			 
1602 21 b1 ed				ld hl, display_fb0 
1605 22 cc eb				ld (display_fb_active), hl 
1608 e1				pop hl	 
1609			 
1609 3e 31			ld a, '1' 
160b fe 2a		.bps1:  cp '*' 
160d cc e9 15			call z, bp_off 
1610			;	jr nz, .bps1b 
1610			;	ld (os_view_disable),a 
1610 fe 31		.bps1b:  cp '1' 
1612 20 14			jr nz, .bps2 
1614			 
1614				; display reg 
1614			 
1614				 
1614			 
1614 3a b1 e2			ld a, (os_view_af) 
1617 2a af e2			ld hl, (os_view_hl) 
161a ed 5b ad e2		ld de, (os_view_de) 
161e ed 4b ab e2		ld bc, (os_view_bc) 
1622 cd bc 16			call display_reg_state 
1625 c3 a8 16			jp .bpschk 
1628			 
1628 fe 32		.bps2:  cp '2' 
162a 20 08			jr nz, .bps3 
162c				 
162c				; display hl 
162c 2a af e2			ld hl, (os_view_hl) 
162f cd a6 17			call display_dump_at_hl 
1632			 
1632 18 74			jr .bpschk 
1634			 
1634 fe 33		.bps3:  cp '3' 
1636 20 08			jr nz, .bps4 
1638			 
1638			        ; display de 
1638 2a ad e2			ld hl, (os_view_de) 
163b cd a6 17			call display_dump_at_hl 
163e			 
163e 18 68			jr .bpschk 
1640 fe 34		.bps4:  cp '4' 
1642 20 08			jr nz, .bps5 
1644			 
1644			        ; display bc 
1644 2a ab e2			ld hl, (os_view_bc) 
1647 cd a6 17			call display_dump_at_hl 
164a			 
164a 18 5c			jr .bpschk 
164c fe 35		.bps5:  cp '5' 
164e 20 08		        jr nz, .bps7 
1650			 
1650				; display cur ptr 
1650 2a 40 ea			ld hl, (cli_ptr) 
1653 cd a6 17			call display_dump_at_hl 
1656			 
1656 18 50			jr .bpschk 
1658 fe 36		.bps7:  cp '6' 
165a 20 08			jr nz, .bps8b 
165c				 
165c				; display cur orig ptr 
165c 2a 3e ea			ld hl, (cli_origptr) 
165f cd a6 17			call display_dump_at_hl 
1662 18 44			jr .bpschk 
1664 fe 37		.bps8b:  cp '7' 
1666 20 08			jr nz, .bps9 
1668				 
1668				; display dsp 
1668 2a ee e9			ld hl, (cli_data_sp) 
166b cd a6 17			call display_dump_at_hl 
166e			 
166e 18 38			jr .bpschk 
1670 fe 39		.bps9:  cp '9' 
1672 20 05			jr nz, .bps8c 
1674				 
1674				; display SP 
1674			;	ld hl, sp 
1674 cd a6 17			call display_dump_at_hl 
1677			 
1677 18 2f			jr .bpschk 
1679 fe 38		.bps8c:  cp '8' 
167b 20 08			jr nz, .bps8d 
167d				 
167d				; display rsp 
167d 2a f2 e9			ld hl, (cli_ret_sp) 
1680 cd a6 17			call display_dump_at_hl 
1683			 
1683 18 23			jr .bpschk 
1685 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1687 20 05			jr nz, .bps8 
1689 cd 9c 19			call monitor 
168c			 
168c 18 1a			jr .bpschk 
168e fe 30		.bps8:  cp '0' 
1690 20 16			jr nz, .bpschk 
1692			 
1692 21 10 ed				ld hl, display_fb1 
1695 22 cc eb				ld (display_fb_active), hl 
1698 cd dd 0b				call update_display 
169b			 
169b				;ld a, (os_view_af) 
169b 2a af e2			ld hl, (os_view_hl) 
169e ed 5b ad e2		ld de, (os_view_de) 
16a2 ed 4b ab e2		ld bc, (os_view_bc) 
16a6 f1				pop af 
16a7 c9				ret 
16a8			 
16a8			.bpschk:   
16a8 cd f2 0a			call delay1s 
16ab 3e 9f		ld a,display_row_4 + display_cols - 1 
16ad 11 cc 1b		        ld de, endprg 
16b0 cd cd 0b			call str_at_display 
16b3 cd dd 0b			call update_display 
16b6 cd 1f 65			call cin_wait 
16b9			 
16b9 c3 0b 16			jp .bps1 
16bc			 
16bc			 
16bc			display_reg_state: 
16bc			 
16bc				; to restore afterwards 
16bc			 
16bc d5				push de 
16bd c5				push bc 
16be e5				push hl 
16bf f5				push af 
16c0			 
16c0				; for use in here 
16c0			 
16c0 c5				push bc 
16c1 d5				push de 
16c2 e5				push hl 
16c3 f5				push af 
16c4			 
16c4 cd ba 0b			call clear_display 
16c7			 
16c7 11 7c 17			ld de, .regstate 
16ca 3e 00			ld a, display_row_1 
16cc cd cd 0b			call str_at_display 
16cf			 
16cf				; display debug step 
16cf			 
16cf			 
16cf 11 6b ee			ld de, debug_mark 
16d2 3e 25			ld a, display_row_1+display_cols-3 
16d4 cd cd 0b			call str_at_display 
16d7			 
16d7				; display a 
16d7 11 98 17			ld de, .regstatea 
16da 3e 28			ld a, display_row_2 
16dc cd cd 0b			call str_at_display 
16df			 
16df e1				pop hl 
16e0			;	ld h,0 
16e0			;	ld l, a 
16e0 3e 2b			ld a, display_row_2+3 
16e2 cd 62 15			call display_word_at 
16e5			 
16e5			 
16e5				; display hl 
16e5			 
16e5			 
16e5 11 8c 17			ld de, .regstatehl 
16e8 3e 32			ld a, display_row_2+10 
16ea cd cd 0b			call str_at_display 
16ed			 
16ed e1				pop hl 
16ee 3e 35			ld a, display_row_2+13 
16f0 cd 62 15			call display_word_at 
16f3			 
16f3				 
16f3				; display de 
16f3			 
16f3 11 90 17			ld de, .regstatede 
16f6 3e 50			ld a, display_row_3 
16f8 cd cd 0b			call str_at_display 
16fb			 
16fb e1				pop hl 
16fc			;	ld h,d 
16fc			;	ld l, e 
16fc 3e 53			ld a, display_row_3+3 
16fe cd 62 15			call display_word_at 
1701			 
1701			 
1701				; display bc 
1701			 
1701 11 94 17			ld de, .regstatebc 
1704 3e 5a			ld a, display_row_3+10 
1706 cd cd 0b			call str_at_display 
1709			 
1709 e1				pop hl 
170a			;	ld h,b 
170a			;	ld l, c 
170a 3e 5d			ld a, display_row_3+13 
170c cd 62 15			call display_word_at 
170f			 
170f			 
170f				; display dsp 
170f			 
170f 11 9c 17			ld de, .regstatedsp 
1712 3e 78			ld a, display_row_4 
1714 cd cd 0b			call str_at_display 
1717			 
1717				 
1717 2a ee e9			ld hl,(cli_data_sp) 
171a 3e 7c			ld a, display_row_4+4 
171c cd 62 15			call display_word_at 
171f			 
171f				; display rsp 
171f			 
171f 11 a1 17			ld de, .regstatersp 
1722 3e 82			ld a, display_row_4+10 
1724 cd cd 0b			call str_at_display 
1727			 
1727				 
1727 2a f2 e9			ld hl,(cli_ret_sp) 
172a 3e 86			ld a, display_row_4+14 
172c cd 62 15			call display_word_at 
172f			 
172f cd dd 0b			call update_display 
1732			 
1732			;	call delay1s 
1732			;	call delay1s 
1732			;	call delay1s 
1732			 
1732			 
1732			;	call next_page_prompt 
1732			 
1732				; restore  
1732			 
1732 f1				pop af 
1733 e1				pop hl 
1734 c1				pop bc 
1735 d1				pop de 
1736 c9				ret 
1737			 
1737 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
174b .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1760 .. 00		.ptrstate:	db "Ptr State",0 
176a .. 00		.ptrcliptr:     db "cli_ptr",0 
1772 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
177c .. 00		.regstate:	db "Reg State (1/0)",0 
178c .. 00		.regstatehl:	db "HL:",0 
1790 .. 00		.regstatede:	db "DE:",0 
1794 .. 00		.regstatebc:	db "BC:",0 
1798 .. 00		.regstatea:	db "A :",0 
179c .. 00		.regstatedsp:	db "DSP:",0 
17a1 .. 00		.regstatersp:	db "RSP:",0 
17a6			 
17a6			display_dump_at_hl: 
17a6 e5				push hl 
17a7 d5				push de 
17a8 c5				push bc 
17a9 f5				push af 
17aa			 
17aa 22 e4 e5			ld (os_cur_ptr),hl	 
17ad cd ba 0b			call clear_display 
17b0 cd d6 1a			call dumpcont 
17b3			;	call delay1s 
17b3			;	call next_page_prompt 
17b3			 
17b3			 
17b3 f1				pop af 
17b4 c1				pop bc 
17b5 d1				pop de 
17b6 e1				pop hl 
17b7 c9				ret 
17b8			 
17b8			;if ENABLE_BASIC 
17b8			;	include "nascombasic.asm" 
17b8			;	basic: 
17b8			;	include "forth/FORTH.ASM" 
17b8			;endif 
17b8			 
17b8			; eof 
17b8			 
17b8			 
# End of file firmware_diags.asm
17b8			  
17b8			include "firmware_prompts.asm"  
17b8			; Prompts  
17b8			 
17b8			; boot messages 
17b8			 
17b8 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
17cd .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17dd			 
17dd			 
17dd			; config menus 
17dd			 
17dd			;prom_c3: db "Add Dictionary To File",0 
17dd			 
17dd			if STARTUP_V1 
17dd .. 00		prom_c2: db "Select Autoload File",0 
17f2 .. 00		prom_c2a: db "Disable Autoload File", 0 
1808			endif 
1808			 
1808			if STARTUP_V2 
1808			prom_c2: db "Enable Autoload Files",0 
1808			prom_c2a: db "Disable Autoload Files", 0 
1808			 
1808			crs_s1: db "*ls-word", 0 
1808			crs_s2: db "*ed-word", 0 
1808			crs_s3: db "*Demo-Programs", 0 
1808			crs_s4: db "*Utils", 0 
1808			crs_s5: db "*SPI-Addons", 0 
1808			crs_s6: db "*Key-constants", 0 
1808			crs_sound: db "*Sound-Util", 0 
1808			 
1808			 
1808			 
1808			endif 
1808			;prom_c2b: db "Select Storage Bank",0 
1808 .. 00		prom_c4: db "Settings",0 
1811 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
182c .. 00		prom_m4b:   db "Monitor",0 
1834 .. 00		prom_c1: db "Hardware Diags",0 
1843			 
1843			 
1843			if STARTUP_V2 
1843			prom_c9: db "Create Startup Files",0 
1843			endif 
1843			 
1843 .. 00		prom_notav:    db "Feature not available",0 
1859 .. 00		prom_empty:    db "",0 
185a			 
185a			; eof 
185a			 
# End of file firmware_prompts.asm
185a			  
185a			  
185a			; eof  
185a			  
# End of file firmware.asm
185a			 
185a			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
185a			;if BASE_KEV  
185a			;baseram: equ 08000h 
185a			;endif 
185a			 
185a			;if BASE_SC114 
185a			;baseram:     equ    endofcode 
185a			;endif 
185a			 
185a			 
185a			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
185a			 
185a			; start system 
185a			 
185a			coldstart: 
185a				; set sp 
185a				; di/ei 
185a			 
185a f3				di 
185b 31 00 f0			ld sp, tos 
185e cd 1d 64			call init_nmi 
1861			;	ei 
1861			 
1861				; init spinner 
1861 3e 00			ld a,0 
1863 32 c6 eb			ld (display_active), a 
1866			 
1866				; disable breakpoint by default 
1866			 
1866				;ld a,'*' 
1866			;	ld a,' ' 
1866			;	ld (os_view_disable),a 
1866			 
1866				; set break point vector as new break point on or off 
1866 cd e9 15			call bp_off 
1869			 
1869				; init hardware 
1869			 
1869				; init keyboard and screen hardware 
1869			 
1869 cd 1c 01			call hardware_init 
186c			 
186c			 
186c cd f2 0a			call delay1s 
186f 3e 58			ld a, display_row_3+8 
1871 11 03 01			ld de, buildtime 
1874 cd cd 0b			call str_at_display 
1877 cd dd 0b			call update_display 
187a			 
187a cd f2 0a			call delay1s 
187d cd f2 0a			call delay1s 
1880 cd f2 0a			call delay1s 
1883			 
1883				; detect if any keys are held down to enable breakpoints at start up 
1883			 
1883 cd 27 65			call cin  
1886 fe 00			cp 0 
1888 28 03			jr z, .nokeys 
188a			 
188a				;call hardware_diags 
188a cd 47 14			call config 
188d			 
188d			;	ld de, .bpen 
188d			;	ld a, display_row_4 
188d			;	call str_at_display 
188d			;	call update_display 
188d			; 
188d			;	ld a,0 
188d			;	ld (os_view_disable),a 
188d			; 
188d			;.bpwait: 
188d			;	call cin 
188d			;	cp 0 
188d			;	jr z, .bpwait 
188d			;	jr .nokeys 
188d			; 
188d			; 
188d			;.bpen:  db "Break points enabled!",0 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			.nokeys: 
188d			 
188d			 
188d				 
188d			 
188d			;jp  testkey 
188d			 
188d			;call storage_get_block_0 
188d			; 
188d			;ld hl, 0 
188d			;ld de, store_page 
188d			;call storage_read_block 
188d			 
188d				 
188d			;ld hl, 10 
188d			;ld de, store_page 
188d			;call storage_read_block 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			;stop:	nop 
188d			;	jp stop 
188d			 
188d			 
188d			 
188d			main: 
188d cd ba 0b			call clear_display 
1890 cd dd 0b			call update_display 
1893			 
1893			 
1893			 
1893			;	call testlcd 
1893			 
1893			 
1893			 
1893 cd d3 1f			call forth_init 
1896			 
1896			 
1896			warmstart: 
1896 cd a9 1f			call forth_warmstart 
1899			 
1899				; run startup word load 
1899			        ; TODO prevent this running at warmstart after crash  
1899			 
1899				if STARTUP_ENABLE 
1899			 
1899					if STARTUP_V1 
1899			 
1899						if STORAGE_SE 
1899							call forth_autoload 
1899						endif 
1899 cd 6d 63					call forth_startup 
189c					endif 
189c			 
189c					if STARTUP_V2 
189c			 
189c						if STORAGE_SE 
189c							call forth_autoload 
189c						else 
189c							call forth_startup 
189c						endif 
189c			 
189c			 
189c					endif 
189c			 
189c				endif 
189c			 
189c				; show free memory after boot 
189c 11 36 19			ld de, freeram 
189f 3e 00			ld a, display_row_1 
18a1 cd cd 0b			call str_at_display 
18a4			 
18a4			; Or use heap_size word???? 
18a4 21 a8 e2			ld hl, heap_end 
18a7 11 4f 65			ld de, heap_start 
18aa ed 52			sbc hl, de 
18ac e5				push hl 
18ad 7c				ld a,h	         	 
18ae 21 c6 e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18b1 cd e8 10			call hexout 
18b4 e1			   	pop hl 
18b5			 
18b5 7d				ld a,l 
18b6 21 c8 e5			ld hl, os_word_scratch+2 
18b9 cd e8 10			call hexout 
18bc 21 ca e5			ld hl, os_word_scratch+4 
18bf 3e 00			ld a, 0 
18c1 77				ld (hl),a 
18c2 11 c6 e5			ld de, os_word_scratch 
18c5 3e 0d			ld a, display_row_1 + 13 
18c7 cd cd 0b			call str_at_display 
18ca cd dd 0b			call update_display 
18cd			 
18cd			 
18cd				;call demo 
18cd			 
18cd			 
18cd				; init scratch input area for cli commands 
18cd			 
18cd 21 e8 e5			ld hl, os_cli_cmd 
18d0 3e 00			ld a,0 
18d2 77				ld (hl),a 
18d3 23				inc hl 
18d4 77				ld (hl),a 
18d5			 
18d5 3e 00			ld a,0 
18d7 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18da			 
18da 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18dd 32 e5 e5			ld (os_cur_ptr+1),a	 
18e0			 
18e0 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18e3 32 c7 e5			ld (os_word_scratch+1),a	 
18e6				 
18e6			 
18e6				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18e6 21 e8 e5			ld hl, os_cli_cmd 
18e9			 
18e9 3e 00			ld a, 0		 ; init cli input 
18eb 77				ld (hl), a 
18ec 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18ee			cli: 
18ee				; show cli prompt 
18ee				;push af 
18ee				;ld a, 0 
18ee				;ld de, prompt 
18ee				;call str_at_display 
18ee			 
18ee				;call update_display 
18ee				;pop af 
18ee				;inc a 
18ee				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18ee 0e 00			ld c, 0 
18f0 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18f2 1e 28			ld e, 40 
18f4			 
18f4 21 e8 e5			ld hl, os_cli_cmd 
18f7			 
18f7				STACKFRAME OFF $fefe $9f9f 
18f7				if DEBUG_STACK_IMB 
18f7					if OFF 
18f7						exx 
18f7						ld de, $fefe 
18f7						ld a, d 
18f7						ld hl, curframe 
18f7						call hexout 
18f7						ld a, e 
18f7						ld hl, curframe+2 
18f7						call hexout 
18f7						ld hl, $fefe 
18f7						push hl 
18f7						ld hl, $9f9f 
18f7						push hl 
18f7						exx 
18f7					endif 
18f7				endif 
18f7			endm 
# End of macro STACKFRAME
18f7			 
18f7 cd 14 0e			call input_str 
18fa			 
18fa				STACKFRAMECHK OFF $fefe $9f9f 
18fa				if DEBUG_STACK_IMB 
18fa					if OFF 
18fa						exx 
18fa						ld hl, $9f9f 
18fa						pop de   ; $9f9f 
18fa						call cmp16 
18fa						jr nz, .spnosame 
18fa						ld hl, $fefe 
18fa						pop de   ; $fefe 
18fa						call cmp16 
18fa						jr z, .spfrsame 
18fa						.spnosame: call showsperror 
18fa						.spfrsame: nop 
18fa						exx 
18fa					endif 
18fa				endif 
18fa			endm 
# End of macro STACKFRAMECHK
18fa			 
18fa				; copy input to last command 
18fa			 
18fa 21 e8 e5			ld hl, os_cli_cmd 
18fd 11 e7 e6			ld de, os_last_cmd 
1900 01 ff 00			ld bc, 255 
1903 ed b0			ldir 
1905			 
1905				; wipe current buffer 
1905			 
1905			;	ld a, 0 
1905			;	ld hl, os_cli_cmd 
1905			;	ld de, os_cli_cmd+1 
1905			;	ld bc, 254 
1905			;	ldir 
1905				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1905			;	call strcpy 
1905			;	ld a, 0 
1905			;	ld (hl), a 
1905			;	inc hl 
1905			;	ld (hl), a 
1905			;	inc hl 
1905			;	ld (hl), a 
1905			 
1905				; switch frame buffer to program  
1905			 
1905 21 10 ed				ld hl, display_fb1 
1908 22 cc eb				ld (display_fb_active), hl 
190b			 
190b			;	nop 
190b				STACKFRAME ON $fbfe $8f9f 
190b				if DEBUG_STACK_IMB 
190b					if ON 
190b						exx 
190b						ld de, $fbfe 
190b						ld a, d 
190b						ld hl, curframe 
190b						call hexout 
190b						ld a, e 
190b						ld hl, curframe+2 
190b						call hexout 
190b						ld hl, $fbfe 
190b						push hl 
190b						ld hl, $8f9f 
190b						push hl 
190b						exx 
190b					endif 
190b				endif 
190b			endm 
# End of macro STACKFRAME
190b				; first time into the parser so pass over the current scratch pad 
190b 21 e8 e5			ld hl,os_cli_cmd 
190e				; tokenise the entered statement(s) in HL 
190e cd 51 20			call forthparse 
1911			        ; exec forth statements in top of return stack 
1911 cd 91 20			call forthexec 
1914				;call forthexec_cleanup 
1914			;	call parsenext 
1914			 
1914				STACKFRAMECHK ON $fbfe $8f9f 
1914				if DEBUG_STACK_IMB 
1914					if ON 
1914						exx 
1914						ld hl, $8f9f 
1914						pop de   ; $8f9f 
1914						call cmp16 
1914						jr nz, .spnosame 
1914						ld hl, $fbfe 
1914						pop de   ; $fbfe 
1914						call cmp16 
1914						jr z, .spfrsame 
1914						.spnosame: call showsperror 
1914						.spfrsame: nop 
1914						exx 
1914					endif 
1914				endif 
1914			endm 
# End of macro STACKFRAMECHK
1914				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1914			 
1914 3e 78			ld a, display_row_4 
1916 11 48 19			ld de, endprog 
1919			 
1919 cd dd 0b			call update_display		 
191c			 
191c cd ce 1b			call next_page_prompt 
191f			 
191f				; switch frame buffer to cli 
191f			 
191f 21 b1 ed				ld hl, display_fb0 
1922 22 cc eb				ld (display_fb_active), hl 
1925			 
1925			 
1925 cd ba 0b		        call clear_display 
1928 cd dd 0b			call update_display		 
192b			 
192b 21 e8 e5			ld hl, os_cli_cmd 
192e			 
192e 3e 00			ld a, 0		 ; init cli input 
1930 77				ld (hl), a 
1931			 
1931				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1931			 
1931				; now on last line 
1931			 
1931				; TODO scroll screen up 
1931			 
1931				; TODO instead just clear screen and place at top of screen 
1931			 
1931			;	ld a, 0 
1931			;	ld (f_cursor_ptr),a 
1931			 
1931				;call clear_display 
1931				;call update_display 
1931			 
1931				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1931 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1933 c3 ee 18			jp cli 
1936			 
1936 .. 00		freeram: db "Free bytes: $",0 
1944 ..			asc: db "1A2F" 
1948 .. 00		endprog: db "End prog...",0 
1954			 
1954			testenter2:   
1954 21 f3 e2			ld hl,scratch+50 
1957 22 e4 e5			ld (os_cur_ptr),hl 
195a c3 ee 18			jp cli 
195d			 
195d			testenter:  
195d			 
195d 21 44 19			ld hl,asc 
1960			;	ld a,(hl) 
1960			;	call nibble2val 
1960 cd 3e 11			call get_byte 
1963			 
1963			 
1963			;	ld a,(hl) 
1963			;	call atohex 
1963			 
1963			;	call fourehexhl 
1963 32 f3 e2			ld (scratch+50),a 
1966			 
1966			 
1966			 
1966 21 46 19			ld hl,asc+2 
1969			;	ld a, (hl) 
1969			;	call nibble2val 
1969 cd 3e 11			call get_byte 
196c			 
196c			;	call fourehexhl 
196c 32 f5 e2			ld (scratch+52),a 
196f				 
196f 21 f3 e2			ld hl,scratch+50 
1972 22 e4 e5			ld (os_cur_ptr),hl 
1975 c3 ee 18			jp cli 
1978			 
1978			enter:	 
1978 3a c5 e2			ld a,(scratch+4) 
197b fe 00			cp 0 
197d 28 0c			jr z, .entercont 
197f				; no, not a null term line so has an address to work out.... 
197f			 
197f 21 c3 e2			ld hl,scratch+2 
1982 cd 9e 11			call get_word_hl 
1985			 
1985 22 e4 e5			ld (os_cur_ptr),hl	 
1988 c3 ee 18			jp cli 
198b			 
198b			 
198b			.entercont:  
198b			 
198b 21 c3 e2			ld hl, scratch+2 
198e cd 3e 11			call get_byte 
1991			 
1991 2a e4 e5		   	ld hl,(os_cur_ptr) 
1994 77					ld (hl),a 
1995 23					inc hl 
1996 22 e4 e5				ld (os_cur_ptr),hl 
1999				 
1999			; get byte  
1999			 
1999			 
1999 c3 ee 18			jp cli 
199c			 
199c			 
199c			; basic monitor support 
199c			 
199c			monitor: 
199c				;  
199c cd ba 0b			call clear_display 
199f 3e 00			ld a, 0 
19a1 11 f0 19			ld de, .monprompt 
19a4 cd cd 0b			call str_at_display 
19a7 cd dd 0b			call update_display 
19aa			 
19aa				; get a monitor command 
19aa			 
19aa 0e 00			ld c, 0     ; entry at top left 
19ac 16 64			ld d, 100   ; max buffer size 
19ae 1e 0f			ld e, 15    ; input scroll area 
19b0 3e 00			ld a, 0     ; init string 
19b2 21 bf e4			ld hl, os_input 
19b5 77				ld (hl), a 
19b6 23				inc hl 
19b7 77				ld (hl), a 
19b8 21 bf e4			ld hl, os_input 
19bb 3e 01			ld a, 1     ; init string 
19bd cd 14 0e			call input_str 
19c0			 
19c0 cd ba 0b		        call clear_display 
19c3 cd dd 0b			call update_display		 
19c6			 
19c6 3a bf e4			ld a, (os_input) 
19c9 cd 3c 12			call toUpper 
19cc fe 48		        cp 'H' 
19ce ca 55 1a		        jp z, .monhelp 
19d1 fe 44			cp 'D'		; dump 
19d3 ca 88 1a			jp z, .mondump	 
19d6 fe 43			cp 'C'		; dump 
19d8 ca a2 1a			jp z, .moncdump	 
19db fe 4d			cp 'M'		; dump 
19dd ca f2 19			jp z, .moneditstart 
19e0 fe 55			cp 'U'		; dump 
19e2 ca fe 19			jp z, .monedit	 
19e5 fe 47			cp 'G'		; dump 
19e7 ca 7e 1a			jp z, .monjump 
19ea fe 51			cp 'Q'		; dump 
19ec c8				ret z	 
19ed			 
19ed			 
19ed				; TODO "S" to access symbol by name and not need the address 
19ed				; TODO "F" to find a string in memory 
19ed			 
19ed c3 9c 19			jp monitor 
19f0			 
19f0 .. 00		.monprompt: db ">", 0 
19f2			 
19f2			.moneditstart: 
19f2				; get starting address 
19f2			 
19f2 21 c1 e4			ld hl,os_input+2 
19f5 cd 9e 11			call get_word_hl 
19f8			 
19f8 22 e4 e5			ld (os_cur_ptr),hl	 
19fb			 
19fb c3 9c 19			jp monitor 
19fe			 
19fe			.monedit: 
19fe				; get byte to load 
19fe			 
19fe 21 c1 e4			ld hl,os_input+2 
1a01 cd 3e 11			call get_byte 
1a04			 
1a04				; get address to update 
1a04 2a e4 e5			ld hl, (os_cur_ptr) 
1a07			 
1a07				; update byte 
1a07			 
1a07 77				ld (hl), a 
1a08			 
1a08				; move to next address and save it 
1a08			 
1a08 23				inc hl 
1a09 22 e4 e5			ld (os_cur_ptr),hl	 
1a0c			 
1a0c c3 9c 19			jp monitor 
1a0f			 
1a0f			 
1a0f .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a23 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a3f .. 00		.monhelptext3:  db "G-Call address",0 
1a4e .. 00		.monhelptext4:  db "Q-Quit",0 
1a55			        
1a55			.monhelp: 
1a55 3e 00			ld a, display_row_1 
1a57 11 0f 1a		        ld de, .monhelptext1 
1a5a			 
1a5a cd cd 0b			call str_at_display 
1a5d 3e 28			ld a, display_row_2 
1a5f 11 23 1a		        ld de, .monhelptext2 
1a62					 
1a62 cd cd 0b			call str_at_display 
1a65 3e 50			ld a, display_row_3 
1a67 11 3f 1a		        ld de, .monhelptext3 
1a6a					 
1a6a cd cd 0b			call str_at_display 
1a6d 3e 78			ld a, display_row_4 
1a6f 11 4e 1a		        ld de, .monhelptext4 
1a72 cd cd 0b			call str_at_display 
1a75			 
1a75 cd dd 0b			call update_display		 
1a78			 
1a78 cd ce 1b			call next_page_prompt 
1a7b c3 9c 19			jp monitor 
1a7e			 
1a7e			.monjump:    
1a7e 21 c1 e4			ld hl,os_input+2 
1a81 cd 9e 11			call get_word_hl 
1a84			 
1a84 e9				jp (hl) 
1a85 c3 9c 19			jp monitor 
1a88			 
1a88			.mondump:    
1a88 21 c1 e4			ld hl,os_input+2 
1a8b cd 9e 11			call get_word_hl 
1a8e			 
1a8e 22 e4 e5			ld (os_cur_ptr),hl	 
1a91 cd d6 1a			call dumpcont 
1a94 3e 78			ld a, display_row_4 
1a96 11 48 19			ld de, endprog 
1a99			 
1a99 cd dd 0b			call update_display		 
1a9c			 
1a9c cd ce 1b			call next_page_prompt 
1a9f c3 9c 19			jp monitor 
1aa2			.moncdump: 
1aa2 cd d6 1a			call dumpcont 
1aa5 3e 78			ld a, display_row_4 
1aa7 11 48 19			ld de, endprog 
1aaa			 
1aaa cd dd 0b			call update_display		 
1aad			 
1aad cd ce 1b			call next_page_prompt 
1ab0 c3 9c 19			jp monitor 
1ab3			 
1ab3			 
1ab3			; TODO symbol access  
1ab3			 
1ab3			.symbols:     ;; A list of symbols that can be called up  
1ab3 b1 ed			dw display_fb0 
1ab5 .. 00			db "fb0",0  
1ab9 7a ea		     	dw store_page 
1abb .. 00			db "store_page",0 
1ac6			 
1ac6			 
1ac6			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1ac6			 
1ac6 3a c2 e2			ld a,(scratch+1) 
1ac9 fe 00			cp 0 
1acb 28 09			jr z, dumpcont 
1acd			 
1acd				; no, not a null term line so has an address to work out.... 
1acd			 
1acd 21 c3 e2			ld hl,scratch+2 
1ad0 cd 9e 11			call get_word_hl 
1ad3			 
1ad3 22 e4 e5			ld (os_cur_ptr),hl	 
1ad6			 
1ad6			 
1ad6			 
1ad6			dumpcont: 
1ad6			 
1ad6				; dump bytes at ptr 
1ad6			 
1ad6			 
1ad6 3e 00			ld a, display_row_1 
1ad8 2a cc eb			ld hl, (display_fb_active) 
1adb cd e7 0d			call addatohl 
1ade cd 06 1b			call .dumpbyterow 
1ae1			 
1ae1 3e 28			ld a, display_row_2 
1ae3 2a cc eb			ld hl, (display_fb_active) 
1ae6 cd e7 0d			call addatohl 
1ae9 cd 06 1b			call .dumpbyterow 
1aec			 
1aec			 
1aec 3e 50			ld a, display_row_3 
1aee 2a cc eb			ld hl, (display_fb_active) 
1af1 cd e7 0d			call addatohl 
1af4 cd 06 1b			call .dumpbyterow 
1af7			 
1af7 3e 78			ld a, display_row_4 
1af9 2a cc eb			ld hl, (display_fb_active) 
1afc cd e7 0d			call addatohl 
1aff cd 06 1b			call .dumpbyterow 
1b02			 
1b02 cd dd 0b			call update_display 
1b05			;		jp cli 
1b05 c9				ret 
1b06			 
1b06			.dumpbyterow: 
1b06			 
1b06				;push af 
1b06			 
1b06 e5				push hl 
1b07			 
1b07				; calc where to poke the ascii 
1b07			if display_cols == 20 
1b07				ld a, 16 
1b07			else 
1b07 3e 1f			ld a, 31 
1b09			endif 
1b09			 
1b09 cd e7 0d			call addatohl 
1b0c 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1b0f			 
1b0f			 
1b0f			; display decoding address 
1b0f 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b12			 
1b12 7c				ld a,h 
1b13 e1				pop hl 
1b14 e5				push hl 
1b15			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b15 cd e8 10			call hexout 
1b18 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b1b			 
1b1b 7d				ld a,l 
1b1c e1				pop hl 
1b1d 23				inc hl 
1b1e 23				inc hl 
1b1f e5				push hl 
1b20			;	ld hl, os_word_scratch+2 
1b20 cd e8 10			call hexout 
1b23 e1				pop hl 
1b24 23				inc hl 
1b25 23				inc hl 
1b26				;ld hl, os_word_scratch+4 
1b26 3e 3a			ld a, ':' 
1b28 77				ld (hl),a 
1b29 23				inc hl 
1b2a				;ld a, 0 
1b2a				;ld (hl),a 
1b2a				;ld de, os_word_scratch 
1b2a				;pop af 
1b2a				;push af 
1b2a			;		ld a, display_row_2 
1b2a			;		call str_at_display 
1b2a			;		call update_display 
1b2a			 
1b2a			 
1b2a			;pop af 
1b2a			;	add 5 
1b2a			 
1b2a			if display_cols == 20 
1b2a				ld b, 4 
1b2a			else 
1b2a 06 08			ld b, 8 
1b2c			endif	 
1b2c			 
1b2c			.dumpbyte: 
1b2c c5				push bc 
1b2d e5				push hl 
1b2e			 
1b2e			 
1b2e 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b31 7e					ld a,(hl) 
1b32			 
1b32					; poke the ascii to display 
1b32 2a c6 e5				ld hl,(os_word_scratch) 
1b35 77					ld (hl),a 
1b36 23					inc hl 
1b37 22 c6 e5				ld (os_word_scratch),hl 
1b3a			 
1b3a					 
1b3a			 
1b3a			 
1b3a e1					pop hl 
1b3b e5					push hl 
1b3c			 
1b3c cd e8 10				call hexout 
1b3f			 
1b3f					 
1b3f 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b42 23				inc hl 
1b43 22 e4 e5		   	ld (os_cur_ptr),hl 
1b46			 
1b46 e1					pop hl 
1b47 23					inc hl 
1b48 23					inc hl 
1b49 23					inc hl 
1b4a			 
1b4a			 
1b4a			 
1b4a					;ld a,0 
1b4a					;ld (os_word_scratch+2),a 
1b4a					;pop af 
1b4a					;push af 
1b4a			 
1b4a					;ld de, os_word_scratch 
1b4a					;call str_at_display 
1b4a			;		call update_display 
1b4a			;		pop af 
1b4a c1					pop bc 
1b4b c6 03				add 3 
1b4d 10 dd			djnz .dumpbyte 
1b4f			 
1b4f				 
1b4f			 
1b4f c9				ret 
1b50			 
1b50			jump:	 
1b50			 
1b50 21 c3 e2			ld hl,scratch+2 
1b53 cd 9e 11			call get_word_hl 
1b56				;ld hl,(scratch+2) 
1b56				;call fourehexhl 
1b56			 
1b56 22 e4 e5			ld (os_cur_ptr),hl	 
1b59			 
1b59 e9				jp (hl) 
1b5a			 
1b5a			 
1b5a			 
1b5a			; TODO implement a basic monitor mode to start with 
1b5a			 
1b5a			 
1b5a			 
1b5a			 
1b5a			 
1b5a			 
1b5a			 
1b5a			 
1b5a			 
1b5a			; testing and demo code during development 
1b5a			 
1b5a			 
1b5a .. 00		str1: db "Enter some text...",0 
1b6d .. 00		clear: db "                    ",0 
1b82			 
1b82			demo: 
1b82			 
1b82			 
1b82			 
1b82			;	call update_display 
1b82			 
1b82				; init scratch input area for testing 
1b82 21 c1 e2			ld hl, scratch	 
1b85 3e 00			ld a,0 
1b87 77				ld (hl),a 
1b88			 
1b88			 
1b88 3e 28		            LD   A, display_row_2 
1b8a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b8a 11 5a 1b		            LD   DE, str1 
1b8d cd cd 0b			call str_at_display 
1b90			 
1b90			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b90			cloop:	 
1b90 3e 50		            LD   A, display_row_3 
1b92			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b92 11 6d 1b		            LD   DE, clear 
1b95			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b95 cd cd 0b				call str_at_display 
1b98 3e 78			ld a, display_row_4 
1b9a 11 ca 1b			ld de, prompt 
1b9d			 
1b9d cd cd 0b				call str_at_display 
1ba0 cd dd 0b			call update_display 
1ba3			 
1ba3 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1ba5 16 0a			ld d, 10 
1ba7 21 c1 e2			ld hl, scratch	 
1baa cd 14 0e			call input_str 
1bad			 
1bad			;	call clear_display 
1bad			;'	call update_display 
1bad			 
1bad 3e 00		            LD   A, display_row_1 
1baf			;            CALL fLCD_Pos       ;Position cursor to location in A 
1baf 11 6d 1b		            LD   DE, clear 
1bb2 cd cd 0b				call str_at_display 
1bb5			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bb5 3e 00		            LD   A, display_row_1 
1bb7			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bb7 11 c1 e2		            LD   DE, scratch 
1bba			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bba cd cd 0b				call str_at_display 
1bbd cd dd 0b			call update_display 
1bc0			 
1bc0 3e 00				ld a,0 
1bc2 21 c1 e2			ld hl, scratch 
1bc5 77				ld (hl),a 
1bc6			 
1bc6 00				nop 
1bc7 c3 90 1b			jp cloop 
1bca			 
1bca			 
1bca			 
1bca			; OS Prompt 
1bca			 
1bca .. 00		prompt: db ">",0 
1bcc .. 00		endprg: db "?",0 
1bce			 
1bce			 
1bce			; handy next page prompt 
1bce			next_page_prompt: 
1bce e5				push hl 
1bcf d5				push de 
1bd0 f5				push af 
1bd1 c5				push bc 
1bd2			 
1bd2 3e 9f			ld a,display_row_4 + display_cols - 1 
1bd4 11 cc 1b		        ld de, endprg 
1bd7 cd cd 0b			call str_at_display 
1bda cd dd 0b			call update_display 
1bdd cd 1f 65			call cin_wait 
1be0 c1				pop bc 
1be1 f1				pop af 
1be2 d1				pop de 
1be3 e1				pop hl 
1be4			 
1be4			 
1be4 c9				ret 
1be5			 
1be5			 
1be5			; forth parser 
1be5			 
1be5			; My forth kernel 
1be5			include "forth_kernel.asm" 
1be5			; 
1be5			; kernel to the forth OS 
1be5			 
1be5			DS_TYPE_STR: equ 1     ; string type 
1be5			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1be5			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1be5			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1be5			 
1be5			FORTH_PARSEV1: equ 0 
1be5			FORTH_PARSEV2: equ 0 
1be5			FORTH_PARSEV3: equ 0 
1be5			FORTH_PARSEV4: equ 0 
1be5			FORTH_PARSEV5: equ 1 
1be5			 
1be5			;if FORTH_PARSEV5 
1be5			;	FORTH_END_BUFFER: equ 0 
1be5			;else 
1be5			FORTH_END_BUFFER: equ 127 
1be5			;endif 
1be5			 
1be5			FORTH_TRUE: equ 1 
1be5			FORTH_FALSE: equ 0 
1be5			 
1be5			if FORTH_PARSEV4 
1be5			include "forth_stackops.asm" 
1be5			endif 
1be5			 
1be5			if FORTH_PARSEV5 
1be5			include "forth_stackopsv5.asm" 
1be5			 
1be5			; Stack operations for v5 parser on wards 
1be5			; * DATA stack 
1be5			; * LOOP stack 
1be5			; * RETURN stack 
1be5			 
1be5			 
1be5			 
1be5			FORTH_CHK_DSP_UNDER: macro 
1be5				push hl 
1be5				push de 
1be5				ld hl,(cli_data_sp) 
1be5				ld de, cli_data_stack 
1be5				call cmp16 
1be5				jp c, fault_dsp_under 
1be5				pop de 
1be5				pop hl 
1be5				endm 
1be5			 
1be5			 
1be5			FORTH_CHK_RSP_UNDER: macro 
1be5				push hl 
1be5				push de 
1be5				ld hl,(cli_ret_sp) 
1be5				ld de, cli_ret_stack 
1be5				call cmp16 
1be5				jp c, fault_rsp_under 
1be5				pop de 
1be5				pop hl 
1be5				endm 
1be5			 
1be5			FORTH_CHK_LOOP_UNDER: macro 
1be5				push hl 
1be5				push de 
1be5				ld hl,(cli_loop_sp) 
1be5				ld de, cli_loop_stack 
1be5				call cmp16 
1be5				jp c, fault_loop_under 
1be5				pop de 
1be5				pop hl 
1be5				endm 
1be5			 
1be5			FORTH_ERR_TOS_NOTSTR: macro 
1be5				; TOSO might need more for checks when used 
1be5				push af 
1be5				ld a,(hl) 
1be5				cp DS_TYPE_STR 
1be5				jp nz, type_faultn   
1be5				pop af 
1be5				endm 
1be5			 
1be5			FORTH_ERR_TOS_NOTNUM: macro 
1be5				push af 
1be5				ld a,(hl) 
1be5				cp DS_TYPE_INUM 
1be5				jp nz, type_faultn   
1be5				pop af 
1be5				endm 
1be5			 
1be5			 
1be5			; increase data stack pointer and save hl to it 
1be5				 
1be5			FORTH_DSP_NEXT: macro 
1be5				call macro_forth_dsp_next 
1be5				endm 
1be5			 
1be5			 
1be5			macro_forth_dsp_next: 
1be5				if DEBUG_FORTH_STACK_GUARD 
1be5 cd 4e 61				call check_stacks 
1be8				endif 
1be8 e5				push hl 
1be9 d5				push de 
1bea eb				ex de,hl 
1beb 2a ee e9			ld hl,(cli_data_sp) 
1bee 23				inc hl 
1bef 23				inc hl 
1bf0			 
1bf0			; PARSEV5 
1bf0 23				inc hl 
1bf1 22 ee e9			ld (cli_data_sp),hl 
1bf4 73				ld (hl), e 
1bf5 23				inc hl 
1bf6 72				ld (hl), d 
1bf7 d1				pop de 
1bf8 e1				pop hl 
1bf9				if DEBUG_FORTH_STACK_GUARD 
1bf9 cd 4e 61				call check_stacks 
1bfc				endif 
1bfc c9				ret 
1bfd			 
1bfd			 
1bfd			; increase ret stack pointer and save hl to it 
1bfd				 
1bfd			FORTH_RSP_NEXT: macro 
1bfd				call macro_forth_rsp_next 
1bfd				endm 
1bfd			 
1bfd			macro_forth_rsp_next: 
1bfd				if DEBUG_FORTH_STACK_GUARD 
1bfd cd 4e 61				call check_stacks 
1c00				endif 
1c00 e5				push hl 
1c01 d5				push de 
1c02 eb				ex de,hl 
1c03 2a f2 e9			ld hl,(cli_ret_sp) 
1c06 23				inc hl 
1c07 23				inc hl 
1c08 22 f2 e9			ld (cli_ret_sp),hl 
1c0b 73				ld (hl), e 
1c0c 23				inc hl 
1c0d 72				ld (hl), d 
1c0e d1				pop de 
1c0f e1				pop hl 
1c10				if DEBUG_FORTH_STACK_GUARD 
1c10 cd 4e 61				call check_stacks 
1c13				endif 
1c13 c9				ret 
1c14			 
1c14			; get current ret stack pointer and save to hl  
1c14				 
1c14			FORTH_RSP_TOS: macro 
1c14				call macro_forth_rsp_tos 
1c14				endm 
1c14			 
1c14			macro_forth_rsp_tos: 
1c14				;push de 
1c14 2a f2 e9			ld hl,(cli_ret_sp) 
1c17 cd 4f 1c			call loadhlptrtohl 
1c1a				;ld e, (hl) 
1c1a				;inc hl 
1c1a				;ld d, (hl) 
1c1a				;ex de, hl 
1c1a					if DEBUG_FORTH_WORDS 
1c1a			;			DMARK "RST" 
1c1a						CALLMONITOR 
1c1a cd 6f ee			call debug_vector  
1c1d				endm  
# End of macro CALLMONITOR
1c1d					endif 
1c1d				;pop de 
1c1d c9				ret 
1c1e			 
1c1e			; pop ret stack pointer 
1c1e				 
1c1e			FORTH_RSP_POP: macro 
1c1e				call macro_forth_rsp_pop 
1c1e				endm 
1c1e			 
1c1e			 
1c1e			macro_forth_rsp_pop: 
1c1e				if DEBUG_FORTH_STACK_GUARD 
1c1e			;		DMARK "RPP" 
1c1e cd 4e 61				call check_stacks 
1c21					FORTH_CHK_RSP_UNDER 
1c21 e5				push hl 
1c22 d5				push de 
1c23 2a f2 e9			ld hl,(cli_ret_sp) 
1c26 11 ac e9			ld de, cli_ret_stack 
1c29 cd 05 0e			call cmp16 
1c2c da 62 62			jp c, fault_rsp_under 
1c2f d1				pop de 
1c30 e1				pop hl 
1c31				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c31				endif 
1c31 e5				push hl 
1c32 2a f2 e9			ld hl,(cli_ret_sp) 
1c35			 
1c35			 
1c35				if FORTH_ENABLE_FREE 
1c35			 
1c35					; get pointer 
1c35			 
1c35					push de 
1c35					push hl 
1c35			 
1c35					ld e, (hl) 
1c35					inc hl 
1c35					ld d, (hl) 
1c35			 
1c35					ex de, hl 
1c35					call free 
1c35			 
1c35					pop hl 
1c35					pop de 
1c35			 
1c35			 
1c35				endif 
1c35			 
1c35			 
1c35 2b				dec hl 
1c36 2b				dec hl 
1c37 22 f2 e9			ld (cli_ret_sp), hl 
1c3a				; do stack underflow checks 
1c3a e1				pop hl 
1c3b				if DEBUG_FORTH_STACK_GUARD 
1c3b cd 4e 61				call check_stacks 
1c3e					FORTH_CHK_RSP_UNDER 
1c3e e5				push hl 
1c3f d5				push de 
1c40 2a f2 e9			ld hl,(cli_ret_sp) 
1c43 11 ac e9			ld de, cli_ret_stack 
1c46 cd 05 0e			call cmp16 
1c49 da 62 62			jp c, fault_rsp_under 
1c4c d1				pop de 
1c4d e1				pop hl 
1c4e				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c4e				endif 
1c4e c9				ret 
1c4f			 
1c4f			 
1c4f			 
1c4f			; routine to load word pointed to by hl into hl 
1c4f			 
1c4f			loadhlptrtohl: 
1c4f			 
1c4f d5				push de 
1c50 5e				ld e, (hl) 
1c51 23				inc hl 
1c52 56				ld d, (hl) 
1c53 eb				ex de, hl 
1c54 d1				pop de 
1c55			 
1c55 c9				ret 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			; push a number held in HL onto the data stack 
1c56			; entry point for pushing a value when already in hl used in function above 
1c56			 
1c56			forth_push_numhl: 
1c56			 
1c56 e5				push hl    ; save value to push 
1c57			 
1c57			if DEBUG_FORTH_PUSH 
1c57				; see if disabled 
1c57			 
1c57			 
1c57 f5				push af 
1c58 3a 6f ee			ld a,(debug_vector) 
1c5b fe c9			cp $c9   ; ret 
1c5d			;	ld a, (os_view_disable) 
1c5d			;	cp '*' 
1c5d 28 34			jr z, .pskip2 
1c5f e5				push hl 
1c60 e5			push hl 
1c61 cd ba 0b			call clear_display 
1c64 e1			pop hl 
1c65 7c				ld a,h 
1c66 21 c6 e5			ld hl, os_word_scratch 
1c69 cd e8 10			call hexout 
1c6c e1				pop hl 
1c6d 7d				ld a,l 
1c6e 21 c8 e5			ld hl, os_word_scratch+2 
1c71 cd e8 10			call hexout 
1c74			 
1c74 21 ca e5			ld hl, os_word_scratch+4 
1c77 3e 00			ld a,0 
1c79 77				ld (hl),a 
1c7a 11 c6 e5			ld de,os_word_scratch 
1c7d 3e 28				ld a, display_row_2 
1c7f cd cd 0b				call str_at_display 
1c82 11 8a 4c			ld de, .push_num 
1c85 3e 00			ld a, display_row_1 
1c87			 
1c87 cd cd 0b				call str_at_display 
1c8a			 
1c8a			 
1c8a cd dd 0b			call update_display 
1c8d cd f2 0a			call delay1s 
1c90 cd f2 0a			call delay1s 
1c93			.pskip2:  
1c93			 
1c93 f1				pop af 
1c94			endif	 
1c94			 
1c94			 
1c94				FORTH_DSP_NEXT 
1c94 cd e5 1b			call macro_forth_dsp_next 
1c97				endm 
# End of macro FORTH_DSP_NEXT
1c97			 
1c97 2a ee e9			ld hl, (cli_data_sp) 
1c9a			 
1c9a				; save item type 
1c9a 3e 02			ld a,  DS_TYPE_INUM 
1c9c 77				ld (hl), a 
1c9d 23				inc hl 
1c9e			 
1c9e				; get word off stack 
1c9e d1				pop de 
1c9f 7b				ld a,e 
1ca0 77				ld (hl), a 
1ca1 23				inc hl 
1ca2 7a				ld a,d 
1ca3 77				ld (hl), a 
1ca4			 
1ca4			if DEBUG_FORTH_PUSH 
1ca4 2b				dec hl 
1ca5 2b				dec hl 
1ca6 2b				dec hl 
1ca7						DMARK "PH5" 
1ca7 f5				push af  
1ca8 3a bc 1c			ld a, (.dmark)  
1cab 32 6b ee			ld (debug_mark),a  
1cae 3a bd 1c			ld a, (.dmark+1)  
1cb1 32 6c ee			ld (debug_mark+1),a  
1cb4 3a be 1c			ld a, (.dmark+2)  
1cb7 32 6d ee			ld (debug_mark+2),a  
1cba 18 03			jr .pastdmark  
1cbc ..			.dmark: db "PH5"  
1cbf f1			.pastdmark: pop af  
1cc0			endm  
# End of macro DMARK
1cc0				CALLMONITOR 
1cc0 cd 6f ee			call debug_vector  
1cc3				endm  
# End of macro CALLMONITOR
1cc3			endif	 
1cc3			 
1cc3 c9				ret 
1cc4			 
1cc4			 
1cc4			; Push a string to stack pointed to by hl 
1cc4			 
1cc4			forth_push_str: 
1cc4			 
1cc4			if DEBUG_FORTH_PUSH 
1cc4						DMARK "PSQ" 
1cc4 f5				push af  
1cc5 3a d9 1c			ld a, (.dmark)  
1cc8 32 6b ee			ld (debug_mark),a  
1ccb 3a da 1c			ld a, (.dmark+1)  
1cce 32 6c ee			ld (debug_mark+1),a  
1cd1 3a db 1c			ld a, (.dmark+2)  
1cd4 32 6d ee			ld (debug_mark+2),a  
1cd7 18 03			jr .pastdmark  
1cd9 ..			.dmark: db "PSQ"  
1cdc f1			.pastdmark: pop af  
1cdd			endm  
# End of macro DMARK
1cdd				CALLMONITOR 
1cdd cd 6f ee			call debug_vector  
1ce0				endm  
# End of macro CALLMONITOR
1ce0			endif	 
1ce0			    
1ce0 e5				push hl 
1ce1 e5				push hl 
1ce2			 
1ce2			;	ld a, 0   ; find end of string 
1ce2 cd 45 12			call strlenz 
1ce5			if DEBUG_FORTH_PUSH 
1ce5						DMARK "PQ2" 
1ce5 f5				push af  
1ce6 3a fa 1c			ld a, (.dmark)  
1ce9 32 6b ee			ld (debug_mark),a  
1cec 3a fb 1c			ld a, (.dmark+1)  
1cef 32 6c ee			ld (debug_mark+1),a  
1cf2 3a fc 1c			ld a, (.dmark+2)  
1cf5 32 6d ee			ld (debug_mark+2),a  
1cf8 18 03			jr .pastdmark  
1cfa ..			.dmark: db "PQ2"  
1cfd f1			.pastdmark: pop af  
1cfe			endm  
# End of macro DMARK
1cfe				CALLMONITOR 
1cfe cd 6f ee			call debug_vector  
1d01				endm  
# End of macro CALLMONITOR
1d01			endif	 
1d01 eb				ex de, hl 
1d02 e1				pop hl   ; get ptr to start of string 
1d03			if DEBUG_FORTH_PUSH 
1d03						DMARK "PQ3" 
1d03 f5				push af  
1d04 3a 18 1d			ld a, (.dmark)  
1d07 32 6b ee			ld (debug_mark),a  
1d0a 3a 19 1d			ld a, (.dmark+1)  
1d0d 32 6c ee			ld (debug_mark+1),a  
1d10 3a 1a 1d			ld a, (.dmark+2)  
1d13 32 6d ee			ld (debug_mark+2),a  
1d16 18 03			jr .pastdmark  
1d18 ..			.dmark: db "PQ3"  
1d1b f1			.pastdmark: pop af  
1d1c			endm  
# End of macro DMARK
1d1c				CALLMONITOR 
1d1c cd 6f ee			call debug_vector  
1d1f				endm  
# End of macro CALLMONITOR
1d1f			endif	 
1d1f 19				add hl,de 
1d20			if DEBUG_FORTH_PUSH 
1d20						DMARK "PQE" 
1d20 f5				push af  
1d21 3a 35 1d			ld a, (.dmark)  
1d24 32 6b ee			ld (debug_mark),a  
1d27 3a 36 1d			ld a, (.dmark+1)  
1d2a 32 6c ee			ld (debug_mark+1),a  
1d2d 3a 37 1d			ld a, (.dmark+2)  
1d30 32 6d ee			ld (debug_mark+2),a  
1d33 18 03			jr .pastdmark  
1d35 ..			.dmark: db "PQE"  
1d38 f1			.pastdmark: pop af  
1d39			endm  
# End of macro DMARK
1d39				CALLMONITOR 
1d39 cd 6f ee			call debug_vector  
1d3c				endm  
# End of macro CALLMONITOR
1d3c			endif	 
1d3c			 
1d3c 2b				dec hl    ; see if there is an optional trailing double quote 
1d3d 7e				ld a,(hl) 
1d3e fe 22			cp '"' 
1d40 20 03			jr nz, .strnoq 
1d42 3e 00			ld a, 0      ; get rid of double quote 
1d44 77				ld (hl), a 
1d45 23			.strnoq: inc hl 
1d46			 
1d46 3e 00			ld a, 0 
1d48 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d49			 
1d49 13				inc de ; add one for the type string 
1d4a 13				inc de ; add one for null term??? 
1d4b			 
1d4b				; tos is get string pointer again 
1d4b				; de contains space to allocate 
1d4b				 
1d4b d5				push de 
1d4c			 
1d4c eb				ex de, hl 
1d4d			 
1d4d				;push af 
1d4d			 
1d4d			if DEBUG_FORTH_PUSH 
1d4d						DMARK "PHm" 
1d4d f5				push af  
1d4e 3a 62 1d			ld a, (.dmark)  
1d51 32 6b ee			ld (debug_mark),a  
1d54 3a 63 1d			ld a, (.dmark+1)  
1d57 32 6c ee			ld (debug_mark+1),a  
1d5a 3a 64 1d			ld a, (.dmark+2)  
1d5d 32 6d ee			ld (debug_mark+2),a  
1d60 18 03			jr .pastdmark  
1d62 ..			.dmark: db "PHm"  
1d65 f1			.pastdmark: pop af  
1d66			endm  
# End of macro DMARK
1d66				CALLMONITOR 
1d66 cd 6f ee			call debug_vector  
1d69				endm  
# End of macro CALLMONITOR
1d69			endif	 
1d69 cd ae 12			call malloc	; on ret hl now contains allocated memory 
1d6c				if DEBUG_FORTH_MALLOC_GUARD 
1d6c cc e2 4c				call z,malloc_error 
1d6f				endif 
1d6f			 
1d6f				 
1d6f c1				pop bc    ; get length 
1d70 d1				pop de   ;  get string start    
1d71			 
1d71				; hl has destination from malloc 
1d71			 
1d71 eb				ex de, hl    ; prep for ldir 
1d72			 
1d72 d5				push de   ; save malloc area for DSP later 
1d73				;push hl   ; save malloc area for DSP later 
1d73			 
1d73			if DEBUG_FORTH_PUSH 
1d73						DMARK "PHc" 
1d73 f5				push af  
1d74 3a 88 1d			ld a, (.dmark)  
1d77 32 6b ee			ld (debug_mark),a  
1d7a 3a 89 1d			ld a, (.dmark+1)  
1d7d 32 6c ee			ld (debug_mark+1),a  
1d80 3a 8a 1d			ld a, (.dmark+2)  
1d83 32 6d ee			ld (debug_mark+2),a  
1d86 18 03			jr .pastdmark  
1d88 ..			.dmark: db "PHc"  
1d8b f1			.pastdmark: pop af  
1d8c			endm  
# End of macro DMARK
1d8c				CALLMONITOR 
1d8c cd 6f ee			call debug_vector  
1d8f				endm  
# End of macro CALLMONITOR
1d8f			endif	 
1d8f			 
1d8f			 
1d8f ed b0			ldir 
1d91			 
1d91			 
1d91				; push malloc to data stack     macro?????  
1d91			 
1d91				FORTH_DSP_NEXT 
1d91 cd e5 1b			call macro_forth_dsp_next 
1d94				endm 
# End of macro FORTH_DSP_NEXT
1d94			 
1d94				; save value and type 
1d94			 
1d94 2a ee e9			ld hl, (cli_data_sp) 
1d97			 
1d97				; save item type 
1d97 3e 01			ld a,  DS_TYPE_STR 
1d99 77				ld (hl), a 
1d9a 23				inc hl 
1d9b			 
1d9b				; get malloc word off stack 
1d9b d1				pop de 
1d9c 73				ld (hl), e 
1d9d 23				inc hl 
1d9e 72				ld (hl), d 
1d9f			 
1d9f			 
1d9f			 
1d9f			if DEBUG_FORTH_PUSH 
1d9f 2a ee e9			ld hl, (cli_data_sp) 
1da2						DMARK "PHS" 
1da2 f5				push af  
1da3 3a b7 1d			ld a, (.dmark)  
1da6 32 6b ee			ld (debug_mark),a  
1da9 3a b8 1d			ld a, (.dmark+1)  
1dac 32 6c ee			ld (debug_mark+1),a  
1daf 3a b9 1d			ld a, (.dmark+2)  
1db2 32 6d ee			ld (debug_mark+2),a  
1db5 18 03			jr .pastdmark  
1db7 ..			.dmark: db "PHS"  
1dba f1			.pastdmark: pop af  
1dbb			endm  
# End of macro DMARK
1dbb				CALLMONITOR 
1dbb cd 6f ee			call debug_vector  
1dbe				endm  
# End of macro CALLMONITOR
1dbe			;	ex de,hl 
1dbe			endif	 
1dbe				; in case of spaces, skip the ptr past the copied string 
1dbe				;pop af 
1dbe				;ld (cli_origptr),hl 
1dbe			 
1dbe c9				ret 
1dbf			 
1dbf			 
1dbf			 
1dbf			; TODO ascii push input onto stack given hl to start of input 
1dbf			 
1dbf			; identify type 
1dbf			; if starts with a " then a string 
1dbf			; otherwise it is a number 
1dbf			;  
1dbf			; if a string 
1dbf			;     scan for ending " to get length of string to malloc for + 1 
1dbf			;     malloc 
1dbf			;     put pointer to string on stack first byte flags as string 
1dbf			; 
1dbf			; else a number 
1dbf			;    look for number format identifier 
1dbf			;    $xx hex 
1dbf			;    %xxxxx bin 
1dbf			;    xxxxx decimal 
1dbf			;    convert number to 16bit word.  
1dbf			;    malloc word + 1 with flag to identiy as num 
1dbf			;    put pointer to number on stack 
1dbf			;   
1dbf			;  
1dbf			  
1dbf			forth_apush: 
1dbf				; kernel push 
1dbf			 
1dbf			if DEBUG_FORTH_PUSH 
1dbf						DMARK "PSH" 
1dbf f5				push af  
1dc0 3a d4 1d			ld a, (.dmark)  
1dc3 32 6b ee			ld (debug_mark),a  
1dc6 3a d5 1d			ld a, (.dmark+1)  
1dc9 32 6c ee			ld (debug_mark+1),a  
1dcc 3a d6 1d			ld a, (.dmark+2)  
1dcf 32 6d ee			ld (debug_mark+2),a  
1dd2 18 03			jr .pastdmark  
1dd4 ..			.dmark: db "PSH"  
1dd7 f1			.pastdmark: pop af  
1dd8			endm  
# End of macro DMARK
1dd8				CALLMONITOR 
1dd8 cd 6f ee			call debug_vector  
1ddb				endm  
# End of macro CALLMONITOR
1ddb			endif	 
1ddb				; identify input type 
1ddb			 
1ddb 7e				ld a,(hl) 
1ddc fe 22			cp '"' 
1dde 28 0a			jr z, .fapstr 
1de0 fe 24			cp '$' 
1de2 ca 0a 1e			jp z, .faphex 
1de5 fe 25			cp '%' 
1de7 ca f2 1d			jp z, .fapbin 
1dea			;	cp 'b' 
1dea			;	jp z, .fabin 
1dea				; else decimal 
1dea			 
1dea				; TODO do decimal conversion 
1dea				; decimal is stored as a 16bit word 
1dea			 
1dea				; by default everything is a string if type is not detected 
1dea			.fapstr: ; 
1dea fe 22			cp '"' 
1dec 20 01			jr nz, .strnoqu 
1dee 23				inc hl 
1def			.strnoqu: 
1def c3 c4 1c			jp forth_push_str 
1df2			 
1df2			 
1df2			 
1df2			.fapbin:    ; push a binary string.  
1df2 11 00 00			ld de, 0   ; hold a 16bit value 
1df5			 
1df5 23			.fapbinshift:	inc hl  
1df6 7e				ld a,(hl) 
1df7 fe 00			cp 0     ; done scanning  
1df9 28 0b			jr z, .fapbdone  	; got it in HL so push  
1dfb			 
1dfb				; left shift de 
1dfb eb				ex de, hl	 
1dfc 29				add hl, hl 
1dfd			 
1dfd				; is 1 
1dfd fe 31			cp '1' 
1dff 20 02			jr nz, .binzero 
1e01 cb 4d			bit 1, l 
1e03			.binzero: 
1e03 eb				ex de, hl	 ; save current de 
1e04 18 ef			jr .fapbinshift 
1e06			 
1e06			.fapbdone: 
1e06 eb				ex de, hl 
1e07 c3 56 1c			jp forth_push_numhl 
1e0a			 
1e0a			 
1e0a			.faphex:   ; hex is always stored as a 16bit word 
1e0a				; skip number prefix 
1e0a 23				inc hl 
1e0b				; turn ascii into number 
1e0b cd 9e 11			call get_word_hl	; ret 16bit word in hl 
1e0e			 
1e0e c3 56 1c			jp forth_push_numhl 
1e11			 
1e11 00				 nop 
1e12			 
1e12			.fabin:   ; TODO bin conversion 
1e12			 
1e12			 
1e12 c9				ret 
1e13			 
1e13			 
1e13			; get either a string ptr or a 16bit word from the data stack 
1e13			 
1e13			FORTH_DSP: macro 
1e13				call macro_forth_dsp 
1e13				endm 
1e13			 
1e13			macro_forth_dsp: 
1e13				; data stack pointer points to current word on tos 
1e13			 
1e13 2a ee e9			ld hl,(cli_data_sp) 
1e16			 
1e16				if DEBUG_FORTH_PUSH 
1e16						DMARK "DSP" 
1e16 f5				push af  
1e17 3a 2b 1e			ld a, (.dmark)  
1e1a 32 6b ee			ld (debug_mark),a  
1e1d 3a 2c 1e			ld a, (.dmark+1)  
1e20 32 6c ee			ld (debug_mark+1),a  
1e23 3a 2d 1e			ld a, (.dmark+2)  
1e26 32 6d ee			ld (debug_mark+2),a  
1e29 18 03			jr .pastdmark  
1e2b ..			.dmark: db "DSP"  
1e2e f1			.pastdmark: pop af  
1e2f			endm  
# End of macro DMARK
1e2f			 
1e2f cd 15 4d				call display_data_sp 
1e32				;call break_point_state 
1e32				;rst 030h 
1e32				CALLMONITOR 
1e32 cd 6f ee			call debug_vector  
1e35				endm  
# End of macro CALLMONITOR
1e35				endif 
1e35			 
1e35 c9				ret 
1e36			 
1e36			; return hl to start of value on stack 
1e36			 
1e36			FORTH_DSP_VALUE: macro 
1e36				call macro_forth_dsp_value 
1e36				endm 
1e36			 
1e36			macro_forth_dsp_value: 
1e36			 
1e36				FORTH_DSP 
1e36 cd 13 1e			call macro_forth_dsp 
1e39				endm 
# End of macro FORTH_DSP
1e39			 
1e39 d5				push de 
1e3a			 
1e3a 23				inc hl ; skip type 
1e3b			 
1e3b 5e				ld e, (hl) 
1e3c 23				inc hl 
1e3d 56				ld d, (hl) 
1e3e eb				ex de,hl  
1e3f			 
1e3f d1				pop de 
1e40			 
1e40 c9				ret 
1e41			 
1e41			; return hl to start of value to second item on stack 
1e41			 
1e41			FORTH_DSP_VALUEM1: macro 
1e41				call macro_forth_dsp_value_m1 
1e41				endm 
1e41			 
1e41			macro_forth_dsp_value_m1: 
1e41			 
1e41				FORTH_DSP 
1e41 cd 13 1e			call macro_forth_dsp 
1e44				endm 
# End of macro FORTH_DSP
1e44			 
1e44 2b				dec hl 
1e45 2b				dec hl 
1e46			;	dec hl 
1e46			 
1e46 d5				push de 
1e47			 
1e47 5e				ld e, (hl) 
1e48 23				inc hl 
1e49 56				ld d, (hl) 
1e4a eb				ex de,hl  
1e4b			 
1e4b d1				pop de 
1e4c			 
1e4c c9				ret 
1e4d			 
1e4d				 
1e4d			 
1e4d			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e4d			 
1e4d			FORTH_DSP_POP: macro 
1e4d				call macro_forth_dsp_pop 
1e4d				endm 
1e4d			 
1e4d			 
1e4d			; get the tos data type 
1e4d			 
1e4d			FORTH_DSP_TYPE:   macro 
1e4d			 
1e4d				;FORTH_DSP_VALUE 
1e4d				FORTH_DSP 
1e4d				 
1e4d				; hl points to value 
1e4d				; check type 
1e4d			 
1e4d				ld a,(hl) 
1e4d			 
1e4d				endm 
1e4d			 
1e4d			; load the tos value into hl 
1e4d			 
1e4d			 
1e4d			FORTH_DSP_VALUEHL:  macro 
1e4d				call macro_dsp_valuehl 
1e4d				endm 
1e4d			 
1e4d			 
1e4d			 
1e4d			macro_dsp_valuehl: 
1e4d				FORTH_DSP_VALUE 
1e4d cd 36 1e			call macro_forth_dsp_value 
1e50				endm 
# End of macro FORTH_DSP_VALUE
1e50			 
1e50				;FORTH_ERR_TOS_NOTNUM 
1e50			 
1e50				;inc hl   ; skip type id 
1e50			 
1e50			;	push de 
1e50			; 
1e50			;	ld e, (hl) 
1e50			;	inc hl 
1e50			;	ld d, (hl) 
1e50			;	ex de,hl  
1e50			 
1e50			;	pop de 
1e50			 
1e50				if DEBUG_FORTH_PUSH 
1e50						DMARK "DVL" 
1e50 f5				push af  
1e51 3a 65 1e			ld a, (.dmark)  
1e54 32 6b ee			ld (debug_mark),a  
1e57 3a 66 1e			ld a, (.dmark+1)  
1e5a 32 6c ee			ld (debug_mark+1),a  
1e5d 3a 67 1e			ld a, (.dmark+2)  
1e60 32 6d ee			ld (debug_mark+2),a  
1e63 18 03			jr .pastdmark  
1e65 ..			.dmark: db "DVL"  
1e68 f1			.pastdmark: pop af  
1e69			endm  
# End of macro DMARK
1e69				CALLMONITOR 
1e69 cd 6f ee			call debug_vector  
1e6c				endm  
# End of macro CALLMONITOR
1e6c				endif 
1e6c c9				ret 
1e6d			 
1e6d			forth_apushstrhl:      
1e6d				; push of string requires use of cli_origptr 
1e6d				; bodge use 
1e6d			 
1e6d				; get current cli_origptr, save, update with temp pointer  
1e6d ed 5b 3e ea		ld de, (cli_origptr) 
1e71 22 3e ea			ld (cli_origptr), hl 
1e74 d5				push de 
1e75 cd bf 1d			call forth_apush 
1e78 d1				pop de 
1e79 ed 53 3e ea		ld (cli_origptr), de 
1e7d c9			        ret	 
1e7e			 
1e7e			 
1e7e			; increase loop stack pointer and save hl to it 
1e7e				 
1e7e			FORTH_LOOP_NEXT: macro 
1e7e				call macro_forth_loop_next 
1e7e				;nop 
1e7e				endm 
1e7e			 
1e7e			macro_forth_loop_next: 
1e7e				if DEBUG_FORTH_STACK_GUARD 
1e7e cd 4e 61				call check_stacks 
1e81				endif 
1e81 e5				push hl 
1e82 d5				push de 
1e83 eb				ex de,hl 
1e84 2a f0 e9			ld hl,(cli_loop_sp) 
1e87 23				inc hl 
1e88 23				inc hl 
1e89					if DEBUG_FORTH_WORDS 
1e89						DMARK "LNX" 
1e89 f5				push af  
1e8a 3a 9e 1e			ld a, (.dmark)  
1e8d 32 6b ee			ld (debug_mark),a  
1e90 3a 9f 1e			ld a, (.dmark+1)  
1e93 32 6c ee			ld (debug_mark+1),a  
1e96 3a a0 1e			ld a, (.dmark+2)  
1e99 32 6d ee			ld (debug_mark+2),a  
1e9c 18 03			jr .pastdmark  
1e9e ..			.dmark: db "LNX"  
1ea1 f1			.pastdmark: pop af  
1ea2			endm  
# End of macro DMARK
1ea2						CALLMONITOR 
1ea2 cd 6f ee			call debug_vector  
1ea5				endm  
# End of macro CALLMONITOR
1ea5					endif 
1ea5 22 f0 e9			ld (cli_loop_sp),hl 
1ea8 73				ld (hl), e 
1ea9 23				inc hl 
1eaa 72				ld (hl), d 
1eab d1				pop de    ; been reversed so save a swap on restore 
1eac e1				pop hl 
1ead				if DEBUG_FORTH_STACK_GUARD 
1ead cd 4e 61				call check_stacks 
1eb0				endif 
1eb0 c9				ret 
1eb1			 
1eb1			; get current ret stack pointer and save to hl  
1eb1				 
1eb1			FORTH_LOOP_TOS: macro 
1eb1				call macro_forth_loop_tos 
1eb1				endm 
1eb1			 
1eb1			macro_forth_loop_tos: 
1eb1 d5				push de 
1eb2 2a f0 e9			ld hl,(cli_loop_sp) 
1eb5 5e				ld e, (hl) 
1eb6 23				inc hl 
1eb7 56				ld d, (hl) 
1eb8 eb				ex de, hl 
1eb9 d1				pop de 
1eba c9				ret 
1ebb			 
1ebb			; pop loop stack pointer 
1ebb				 
1ebb			FORTH_LOOP_POP: macro 
1ebb				call macro_forth_loop_pop 
1ebb				endm 
1ebb			 
1ebb			 
1ebb			macro_forth_loop_pop: 
1ebb				if DEBUG_FORTH_STACK_GUARD 
1ebb					DMARK "LPP" 
1ebb f5				push af  
1ebc 3a d0 1e			ld a, (.dmark)  
1ebf 32 6b ee			ld (debug_mark),a  
1ec2 3a d1 1e			ld a, (.dmark+1)  
1ec5 32 6c ee			ld (debug_mark+1),a  
1ec8 3a d2 1e			ld a, (.dmark+2)  
1ecb 32 6d ee			ld (debug_mark+2),a  
1ece 18 03			jr .pastdmark  
1ed0 ..			.dmark: db "LPP"  
1ed3 f1			.pastdmark: pop af  
1ed4			endm  
# End of macro DMARK
1ed4 cd 4e 61				call check_stacks 
1ed7					FORTH_CHK_LOOP_UNDER 
1ed7 e5				push hl 
1ed8 d5				push de 
1ed9 2a f0 e9			ld hl,(cli_loop_sp) 
1edc 11 2a e9			ld de, cli_loop_stack 
1edf cd 05 0e			call cmp16 
1ee2 da 68 62			jp c, fault_loop_under 
1ee5 d1				pop de 
1ee6 e1				pop hl 
1ee7				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ee7				endif 
1ee7 e5				push hl 
1ee8 2a f0 e9			ld hl,(cli_loop_sp) 
1eeb 2b				dec hl 
1eec 2b				dec hl 
1eed 22 f0 e9			ld (cli_loop_sp), hl 
1ef0				; TODO do stack underflow checks 
1ef0 e1				pop hl 
1ef1				if DEBUG_FORTH_STACK_GUARD 
1ef1 cd 4e 61				call check_stacks 
1ef4					FORTH_CHK_LOOP_UNDER 
1ef4 e5				push hl 
1ef5 d5				push de 
1ef6 2a f0 e9			ld hl,(cli_loop_sp) 
1ef9 11 2a e9			ld de, cli_loop_stack 
1efc cd 05 0e			call cmp16 
1eff da 68 62			jp c, fault_loop_under 
1f02 d1				pop de 
1f03 e1				pop hl 
1f04				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f04				endif 
1f04 c9				ret 
1f05			 
1f05			macro_forth_dsp_pop: 
1f05			 
1f05 e5				push hl 
1f06			 
1f06				; release malloc data 
1f06			 
1f06				if DEBUG_FORTH_STACK_GUARD 
1f06 cd 4e 61				call check_stacks 
1f09					FORTH_CHK_DSP_UNDER 
1f09 e5				push hl 
1f0a d5				push de 
1f0b 2a ee e9			ld hl,(cli_data_sp) 
1f0e 11 28 e8			ld de, cli_data_stack 
1f11 cd 05 0e			call cmp16 
1f14 da 5c 62			jp c, fault_dsp_under 
1f17 d1				pop de 
1f18 e1				pop hl 
1f19				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f19				endif 
1f19				;ld hl,(cli_data_sp) 
1f19			if DEBUG_FORTH_DOT 
1f19				DMARK "DPP" 
1f19 f5				push af  
1f1a 3a 2e 1f			ld a, (.dmark)  
1f1d 32 6b ee			ld (debug_mark),a  
1f20 3a 2f 1f			ld a, (.dmark+1)  
1f23 32 6c ee			ld (debug_mark+1),a  
1f26 3a 30 1f			ld a, (.dmark+2)  
1f29 32 6d ee			ld (debug_mark+2),a  
1f2c 18 03			jr .pastdmark  
1f2e ..			.dmark: db "DPP"  
1f31 f1			.pastdmark: pop af  
1f32			endm  
# End of macro DMARK
1f32				CALLMONITOR 
1f32 cd 6f ee			call debug_vector  
1f35				endm  
# End of macro CALLMONITOR
1f35			endif	 
1f35			 
1f35			 
1f35			if FORTH_ENABLE_DSPPOPFREE 
1f35			 
1f35				FORTH_DSP 
1f35 cd 13 1e			call macro_forth_dsp 
1f38				endm 
# End of macro FORTH_DSP
1f38			 
1f38 7e				ld a, (hl) 
1f39 fe 01			cp DS_TYPE_STR 
1f3b 20 23			jr nz, .skippopfree 
1f3d			 
1f3d				FORTH_DSP_VALUEHL 
1f3d cd 4d 1e			call macro_dsp_valuehl 
1f40				endm 
# End of macro FORTH_DSP_VALUEHL
1f40 00				nop 
1f41			if DEBUG_FORTH_DOT 
1f41				DMARK "DPf" 
1f41 f5				push af  
1f42 3a 56 1f			ld a, (.dmark)  
1f45 32 6b ee			ld (debug_mark),a  
1f48 3a 57 1f			ld a, (.dmark+1)  
1f4b 32 6c ee			ld (debug_mark+1),a  
1f4e 3a 58 1f			ld a, (.dmark+2)  
1f51 32 6d ee			ld (debug_mark+2),a  
1f54 18 03			jr .pastdmark  
1f56 ..			.dmark: db "DPf"  
1f59 f1			.pastdmark: pop af  
1f5a			endm  
# End of macro DMARK
1f5a				CALLMONITOR 
1f5a cd 6f ee			call debug_vector  
1f5d				endm  
# End of macro CALLMONITOR
1f5d			endif	 
1f5d cd 78 13			call free 
1f60			.skippopfree: 
1f60				 
1f60			 
1f60			endif 
1f60			 
1f60			if DEBUG_FORTH_DOT_KEY 
1f60				DMARK "DP2" 
1f60				CALLMONITOR 
1f60			endif	 
1f60			 
1f60				; move pointer down 
1f60			 
1f60 2a ee e9			ld hl,(cli_data_sp) 
1f63 2b				dec hl 
1f64 2b				dec hl 
1f65			; PARSEV5 
1f65 2b				dec hl 
1f66 22 ee e9			ld (cli_data_sp), hl 
1f69			 
1f69				if DEBUG_FORTH_STACK_GUARD 
1f69 cd 4e 61				call check_stacks 
1f6c					FORTH_CHK_DSP_UNDER 
1f6c e5				push hl 
1f6d d5				push de 
1f6e 2a ee e9			ld hl,(cli_data_sp) 
1f71 11 28 e8			ld de, cli_data_stack 
1f74 cd 05 0e			call cmp16 
1f77 da 5c 62			jp c, fault_dsp_under 
1f7a d1				pop de 
1f7b e1				pop hl 
1f7c				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f7c				endif 
1f7c			 
1f7c e1				pop hl 
1f7d			 
1f7d c9				ret 
1f7e			 
1f7e			getwordathl: 
1f7e				; hl points to an address 
1f7e				; load hl with the word at that address 
1f7e			 
1f7e d5				push de 
1f7f			 
1f7f 5e				ld e, (hl) 
1f80 23				inc hl 
1f81 56				ld d, (hl) 
1f82 eb				ex de, hl 
1f83			 
1f83 d1				pop de 
1f84 c9				ret 
1f85			 
1f85			 
1f85			 
1f85			 
1f85			 
1f85			; eof 
1f85			 
# End of file forth_stackopsv5.asm
1f85			endif 
1f85			 
1f85			loadwordinhl:	 
1f85			 
1f85 d5				push de 
1f86			 
1f86 5e				ld e, (hl) 
1f87 23				inc hl 
1f88 56				ld d, (hl) 
1f89 eb				ex de,hl  
1f8a			 
1f8a d1				pop de 
1f8b			 
1f8b c9				ret 
1f8c			 
1f8c			user_word_eol:  
1f8c				; hl contains the pointer to where to create a linked list item from the end 
1f8c				; of the user dict to continue on at the system word dict 
1f8c				 
1f8c				; poke the stub of the word list linked list to repoint to rom words 
1f8c			 
1f8c				; stub format 
1f8c				; db   word id 
1f8c				; dw    link to next word 
1f8c			        ; db char length of token 
1f8c				; db string + 0 term 
1f8c				; db exec code....  
1f8c			 
1f8c 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f8e 77				ld (hl), a		; word id 
1f8f 23				inc hl 
1f90			 
1f90 11 5b 21			ld de, sysdict 
1f93 73				ld (hl), e		; next word link ie system dict 
1f94 23				inc hl 
1f95 72				ld (hl), d		; next word link ie system dict 
1f96 23				inc hl	 
1f97			 
1f97			;	ld (hl), sysdict		; next word link ie system dict 
1f97			;	inc hl 
1f97			;	inc hl 
1f97			 
1f97			;	inc hl 
1f97			;	inc hl 
1f97			 
1f97 3e 02			ld a, 2			; word length is 0 
1f99 77				ld (hl), a	 
1f9a 23				inc hl 
1f9b			 
1f9b 3e 7e			ld a, '~'			; word length is 0 
1f9d 77				ld (hl), a	 
1f9e 23				inc hl 
1f9f 3e 00			ld a, 0			; save empty word 
1fa1 77				ld (hl), a 
1fa2			 
1fa2 c9				ret 
1fa3			 
1fa3				 
1fa3			 
1fa3			forthexec_cleanup: 
1fa3				FORTH_RSP_POP 
1fa3 cd 1e 1c			call macro_forth_rsp_pop 
1fa6				endm 
# End of macro FORTH_RSP_POP
1fa6 c9				ret 
1fa7			 
1fa7			forth_call_hl: 
1fa7				; taking hl 
1fa7 e5				push hl 
1fa8 c9				ret 
1fa9			 
1fa9			; this is called to reset Forth system but keep existing uwords etc 
1fa9			 
1fa9			forth_warmstart: 
1fa9				; setup stack over/under flow checks 
1fa9				if DEBUG_FORTH_STACK_GUARD 
1fa9 cd 34 61				call chk_stk_init 
1fac				endif 
1fac			 
1fac				; init stack pointers  - * these stacks go upwards *  
1fac 21 ac e9			ld hl, cli_ret_stack 
1faf 22 f2 e9			ld (cli_ret_sp), hl	 
1fb2				; set bottom of stack 
1fb2 3e 00			ld a,0 
1fb4 77				ld (hl),a 
1fb5 23				inc hl 
1fb6 77				ld (hl),a 
1fb7			 
1fb7 21 28 e8			ld hl, cli_data_stack 
1fba 22 ee e9			ld (cli_data_sp), hl	 
1fbd				; set bottom of stack 
1fbd 3e 00			ld a,0 
1fbf 77				ld (hl),a 
1fc0 23				inc hl 
1fc1 77				ld (hl),a 
1fc2			 
1fc2 21 2a e9			ld hl, cli_loop_stack 
1fc5 22 f0 e9			ld (cli_loop_sp), hl	 
1fc8				; set bottom of stack 
1fc8 3e 00			ld a,0 
1fca 77				ld (hl),a 
1fcb 23				inc hl 
1fcc 77				ld (hl),a 
1fcd			 
1fcd				; init extent of current open file 
1fcd			 
1fcd 3e 00			ld a, 0 
1fcf 32 6a ea			ld (store_openext), a 
1fd2			 
1fd2 c9				ret 
1fd3			 
1fd3			 
1fd3			 
1fd3			; Cold Start - this is called to setup the whole Forth system 
1fd3			 
1fd3			forth_init: 
1fd3			 
1fd3				; setup stack over/under flow checks 
1fd3			 
1fd3			;	if DEBUG_FORTH_STACK_GUARD 
1fd3			;		call chk_stk_init 
1fd3			;	endif 
1fd3			 
1fd3				; enable auto display updates (slow.....) 
1fd3			 
1fd3 3e 01			ld a, 1 
1fd5 32 3c ea			ld (cli_autodisplay), a 
1fd8			 
1fd8				; if storage is in use disable long reads for now 
1fd8 3e 00			ld a, 0 
1fda 32 75 ea			ld (store_longread), a 
1fdd			 
1fdd			 
1fdd				; show start up screen 
1fdd			 
1fdd cd ba 0b			call clear_display 
1fe0			 
1fe0 3e 00			ld a,0 
1fe2 32 5e ea			ld (f_cursor_ptr), a 
1fe5			 
1fe5				; set start of word list in start of ram - for use when creating user words 
1fe5			 
1fe5 21 40 65			ld hl, baseram 
1fe8 22 be e5			ld (os_last_new_uword), hl 
1feb cd 8c 1f			call user_word_eol 
1fee				 
1fee			;		call display_data_sp 
1fee			;		call next_page_prompt 
1fee			 
1fee			 
1fee			 
1fee			 
1fee c9				ret 
1fef			 
1fef .. 00		.bootforth: db " Forth Kernel Init ",0 
2003			 
2003			; TODO push to stack 
2003			 
2003			;  
2003			 
2003			if FORTH_PARSEV2 
2003			 
2003			 
2003				include "forth_parserv2.asm" 
2003			 
2003			endif 
2003			 
2003			 
2003			; parse cli version 1 
2003			 
2003			if FORTH_PARSEV1 
2003			 
2003			 
2003			 
2003			      include "forth_parserv1.asm" 
2003			endif 
2003				 
2003			if FORTH_PARSEV3 
2003			 
2003			 
2003			 
2003			      include "forth_parserv3.asm" 
2003				include "forth_wordsv3.asm" 
2003			endif 
2003			 
2003			if FORTH_PARSEV4 
2003			 
2003			 
2003			 
2003			      include "forth_parserv4.asm" 
2003				include "forth_wordsv4.asm" 
2003			endif 
2003			 
2003			if FORTH_PARSEV5 
2003			 
2003			 
2003			 
2003			      include "forth_parserv5.asm" 
2003			 
2003			 
2003			; A better parser without using malloc and string copies all over the place.  
2003			; Exec in situ should be faster 
2003			 
2003			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2003			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2003			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2003			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2003			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2003			WORD_SYS_END: equ 0   ; Opcode for all user words 
2003			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2003			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2003			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2003			 
2003			; Core word preamble macro 
2003			 
2003			CWHEAD:   macro nxtword opcode lit len opflags 
2003				db WORD_SYS_CORE+opcode             
2003				; internal op code number 
2003				dw nxtword            
2003				; link to next dict word block 
2003				db len + 1 
2003				; literal length of dict word inc zero term 
2003				db lit,0              
2003				; literal dict word 
2003			        ; TODO db opflags        
2003				endm 
2003			 
2003			 
2003			NEXTW: macro  
2003				jp macro_next 
2003				endm 
2003			 
2003			macro_next: 
2003			if DEBUG_FORTH_PARSE_KEY 
2003				DMARK "NXT" 
2003				CALLMONITOR 
2003			endif	 
2003			;	inc hl  ; skip token null term  
2003 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2007 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
200b 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
200e			if DEBUG_FORTH_PARSE_KEY 
200e				DMARK "}AA" 
200e				CALLMONITOR 
200e			endif	 
200e c3 11 21			jp execnext 
2011				;jp exec1 
2011			       
2011			 
2011			 
2011			; Another go at the parser to compile  
2011			 
2011			 
2011			; TODO rework parser to change all of the string words to byte tokens 
2011			; TODO do a search for  
2011			 
2011			; TODO first run normal parser to zero term sections 
2011			; TODO for each word do a token look up to get the op code 
2011			; TODO need some means to flag to the exec that this is a byte code form    
2011			 
2011			 
2011			forthcompile: 
2011			 
2011			; 
2011			; line parse: 
2011			;       parse raw input buffer 
2011			;       tokenise the words 
2011			;       malloc new copy (for looping etc) 
2011			;       copy to malloc + current pc in line to start of string and add line term 
2011			;       save on new rsp 
2011			; 
2011			 
2011			; hl to point to the line to tokenise 
2011			 
2011			;	push hl 
2011 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2014			 
2014			;	ld a,0		; string term on input 
2014			;	call strlent 
2014			 
2014			;	ld (os_tok_len), hl	 ; save string length 
2014			 
2014			;if DEBUG_FORTH_TOK 
2014			;	ex de,hl		 
2014			;endif 
2014			 
2014			;	pop hl 		; get back string pointer 
2014			 
2014			if DEBUG_FORTH_TOK 
2014						DMARK "TOc" 
2014				CALLMONITOR 
2014			endif 
2014 7e			.cptoken2:    ld a,(hl) 
2015 23				inc hl 
2016 fe 7f			cp FORTH_END_BUFFER 
2018 28 29			jr z, .cptokendone2 
201a fe 00			cp 0 
201c 28 25			jr z, .cptokendone2 
201e fe 22			cp '"' 
2020 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2022 fe 20			cp ' ' 
2024 20 ee			jr nz,  .cptoken2 
2026			 
2026			; TODO consume comments held between ( and ) 
2026			 
2026				; we have a space so change to zero term for dict match later 
2026 2b				dec hl 
2027 3e 00			ld a,0 
2029 77				ld (hl), a 
202a 23				inc hl 
202b 18 e7			jr .cptoken2 
202d				 
202d			 
202d			.cptokenstr2: 
202d				; skip all white space until either eol (because forgot to term) or end double quote 
202d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
202d				;inc hl ; skip current double quote 
202d 7e				ld a,(hl) 
202e 23				inc hl 
202f fe 22			cp '"' 
2031 28 e1			jr z, .cptoken2 
2033 fe 7f			cp FORTH_END_BUFFER 
2035 28 0c			jr z, .cptokendone2 
2037 fe 00			cp 0 
2039 28 08			jr z, .cptokendone2 
203b fe 20			cp ' ' 
203d 28 02			jr z, .cptmp2 
203f 18 ec			jr .cptokenstr2 
2041			 
2041			.cptmp2:	; we have a space so change to zero term for dict match later 
2041				;dec hl 
2041				;ld a,"-"	; TODO remove this when working 
2041				;ld (hl), a 
2041				;inc hl 
2041 18 ea			jr .cptokenstr2 
2043			 
2043			.cptokendone2: 
2043				;inc hl 
2043 3e 7f			ld a, FORTH_END_BUFFER 
2045 77				ld (hl),a 
2046 23				inc hl 
2047 3e 21			ld a, '!' 
2049 77				ld (hl),a 
204a			 
204a 2a c2 e5			ld hl,(os_tok_ptr) 
204d			         
204d			if DEBUG_FORTH_TOK 
204d						DMARK "Tc1" 
204d				CALLMONITOR 
204d			endif 
204d			 
204d				; push exec string to top of return stack 
204d				FORTH_RSP_NEXT 
204d cd fd 1b			call macro_forth_rsp_next 
2050				endm 
# End of macro FORTH_RSP_NEXT
2050 c9				ret 
2051			 
2051			; Another go at the parser need to simplify the process 
2051			 
2051			forthparse: 
2051			 
2051			; 
2051			; line parse: 
2051			;       parse raw input buffer 
2051			;       tokenise the words 
2051			;       malloc new copy (for looping etc) 
2051			;       copy to malloc + current pc in line to start of string and add line term 
2051			;       save on new rsp 
2051			; 
2051			 
2051			; hl to point to the line to tokenise 
2051			 
2051			;	push hl 
2051 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2054			 
2054			;	ld a,0		; string term on input 
2054			;	call strlent 
2054			 
2054			;	ld (os_tok_len), hl	 ; save string length 
2054			 
2054			;if DEBUG_FORTH_TOK 
2054			;	ex de,hl		 
2054			;endif 
2054			 
2054			;	pop hl 		; get back string pointer 
2054			 
2054			if DEBUG_FORTH_TOK 
2054						DMARK "TOK" 
2054				CALLMONITOR 
2054			endif 
2054 7e			.ptoken2:    ld a,(hl) 
2055 23				inc hl 
2056 fe 7f			cp FORTH_END_BUFFER 
2058 28 29			jr z, .ptokendone2 
205a fe 00			cp 0 
205c 28 25			jr z, .ptokendone2 
205e fe 22			cp '"' 
2060 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2062 fe 20			cp ' ' 
2064 20 ee			jr nz,  .ptoken2 
2066			 
2066			; TODO consume comments held between ( and ) 
2066			 
2066				; we have a space so change to zero term for dict match later 
2066 2b				dec hl 
2067 3e 00			ld a,0 
2069 77				ld (hl), a 
206a 23				inc hl 
206b 18 e7			jr .ptoken2 
206d				 
206d			 
206d			.ptokenstr2: 
206d				; skip all white space until either eol (because forgot to term) or end double quote 
206d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
206d				;inc hl ; skip current double quote 
206d 7e				ld a,(hl) 
206e 23				inc hl 
206f fe 22			cp '"' 
2071 28 e1			jr z, .ptoken2 
2073 fe 7f			cp FORTH_END_BUFFER 
2075 28 0c			jr z, .ptokendone2 
2077 fe 00			cp 0 
2079 28 08			jr z, .ptokendone2 
207b fe 20			cp ' ' 
207d 28 02			jr z, .ptmp2 
207f 18 ec			jr .ptokenstr2 
2081			 
2081			.ptmp2:	; we have a space so change to zero term for dict match later 
2081				;dec hl 
2081				;ld a,"-"	; TODO remove this when working 
2081				;ld (hl), a 
2081				;inc hl 
2081 18 ea			jr .ptokenstr2 
2083			 
2083			.ptokendone2: 
2083				;inc hl 
2083 3e 7f			ld a, FORTH_END_BUFFER 
2085 77				ld (hl),a 
2086 23				inc hl 
2087 3e 21			ld a, '!' 
2089 77				ld (hl),a 
208a			 
208a 2a c2 e5			ld hl,(os_tok_ptr) 
208d			         
208d			if DEBUG_FORTH_TOK 
208d						DMARK "TK1" 
208d				CALLMONITOR 
208d			endif 
208d			 
208d				; push exec string to top of return stack 
208d				FORTH_RSP_NEXT 
208d cd fd 1b			call macro_forth_rsp_next 
2090				endm 
# End of macro FORTH_RSP_NEXT
2090 c9				ret 
2091			 
2091			; 
2091			;	; malloc size + buffer pointer + if is loop flag 
2091			;	ld hl,(os_tok_len) 		 ; get string length 
2091			; 
2091			;	ld a,l 
2091			; 
2091			;	cp 0			; we dont want to use a null string 
2091			;	ret z 
2091			; 
2091			;;	add 3    ; prefix malloc with buffer for current word ptr 
2091			; 
2091			;	add 5     ; TODO when certain not over writing memory remove 
2091			; 
2091			;		 
2091			; 
2091			;if DEBUG_FORTH_TOK 
2091			;			DMARK "TKE" 
2091			;	CALLMONITOR 
2091			;endif 
2091			; 
2091			;	ld l,a 
2091			;	ld h,0 
2091			;;	push hl   ; save required space for the copy later 
2091			;	call malloc 
2091			;if DEBUG_FORTH_TOK 
2091			;			DMARK "TKM" 
2091			;	CALLMONITOR 
2091			;endif 
2091			;	if DEBUG_FORTH_MALLOC_GUARD 
2091			;		push af 
2091			;		call ishlzero 
2091			;;		ld a, l 
2091			;;		add h 
2091			;;		cp 0 
2091			;		pop af 
2091			;		 
2091			;		call z,malloc_error 
2091			;	endif 
2091			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2091			; 
2091			; 
2091			;if DEBUG_FORTH_TOK 
2091			;			DMARK "TKR" 
2091			;	CALLMONITOR 
2091			;endif 
2091			; 
2091			;	FORTH_RSP_NEXT 
2091			; 
2091			;	;inc hl	 ; go past current buffer pointer 
2091			;	;inc hl 
2091			;	;inc hl   ; and past if loop flag 
2091			;		; TODO Need to set flag  
2091			; 
2091			;	 
2091			;	 
2091			;	ex de,hl	; malloc is dest 
2091			;	ld hl, (os_tok_len) 
2091			;;	pop bc 
2091			;	ld c, l                
2091			;	ld b,0 
2091			;	ld hl, (os_tok_ptr) 
2091			; 
2091			;if DEBUG_FORTH_TOK 
2091			;			DMARK "TKT" 
2091			;	CALLMONITOR 
2091			;endif 
2091			; 
2091			;	; do str cpy 
2091			; 
2091			;	ldir      ; copy byte in hl to de 
2091			; 
2091			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2091			; 
2091			;if DEBUG_FORTH_TOK 
2091			; 
2091			;			DMARK "TKY" 
2091			;	CALLMONITOR 
2091			;endif 
2091			;	;ld a,0 
2091			;	;ld a,FORTH_END_BUFFER 
2091			;	ex de, hl 
2091			;	;dec hl			 ; go back over the space delim at the end of word 
2091			;	;ld (hl),a 
2091			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2091			;	ld a,FORTH_END_BUFFER 
2091			;	ld (hl),a 
2091			;	inc hl 
2091			;	ld a,FORTH_END_BUFFER 
2091			;	ld (hl),a 
2091			; 
2091			;	; init the malloc area data 
2091			;	; set pc for in current area 
2091			;	;ld hl, (os_tok_malloc) 
2091			;	;inc hl 
2091			;	;inc hl 
2091			;	;inc hl 
2091			;	;ex de,hl 
2091			;	;ld hl, (os_tok_malloc) 
2091			;	;ld (hl),e 
2091			;	;inc hl 
2091			;	;ld (hl),d 
2091			; 
2091			; 
2091			;	ld hl,(os_tok_malloc) 
2091			;if DEBUG_FORTH_PARSE_KEY 
2091			;			DMARK "TKU" 
2091			;	CALLMONITOR 
2091			;endif 
2091			; 
2091			;	ret 
2091			 
2091			forthexec: 
2091			 
2091			; line exec: 
2091			; forth parser 
2091			 
2091			; 
2091			;       get current exec line on rsp 
2091			 
2091				FORTH_RSP_TOS 
2091 cd 14 1c			call macro_forth_rsp_tos 
2094				endm 
# End of macro FORTH_RSP_TOS
2094			 
2094			;       restore current pc - hl points to malloc of data 
2094			 
2094				;ld e, (hl) 
2094				;inc hl 
2094				;ld d, (hl) 
2094				;ex de,hl 
2094			 
2094			 
2094			exec1: 
2094 22 c2 e5			ld (os_tok_ptr), hl 
2097			 
2097				; copy our PC to working vars  
2097 22 40 ea			ld (cli_ptr), hl 
209a 22 3e ea			ld (cli_origptr), hl 
209d			 
209d 7e				ld a,(hl) 
209e fe 7f			cp FORTH_END_BUFFER 
20a0 c8				ret z 
20a1			 
20a1				; skip any nulls 
20a1			 
20a1 fe 00			cp 0 
20a3 20 03			jr nz, .execword 
20a5 23				inc hl 
20a6 18 ec			jr exec1 
20a8			 
20a8			 
20a8			.execword: 
20a8			 
20a8			 
20a8			 
20a8			if DEBUG_FORTH_PARSE_KEY 
20a8						DMARK "KYQ" 
20a8				CALLMONITOR 
20a8			endif 
20a8			;       while at start of word: 
20a8			; get start of dict (in user area first) 
20a8			 
20a8 21 40 65		ld hl, baseram 
20ab			;ld hl, sysdict 
20ab 22 42 ea		ld (cli_nextword),hl 
20ae			;           match word at pc 
20ae			;           exec word 
20ae			;           or push to dsp 
20ae			;           forward to next token 
20ae			;           if line term pop rsp and exit 
20ae			;        
20ae			 
20ae			if DEBUG_FORTH_PARSE_KEY 
20ae						DMARK "KYq" 
20ae				CALLMONITOR 
20ae			endif 
20ae			 
20ae			; 
20ae			; word comp 
20ae			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20ae			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20ae			;    move to start of word  
20ae			;    compare word to cli_token 
20ae			 
20ae			.execpnword:	; HL at start of a word in the dictionary to check 
20ae			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20ae			;	ld (cli_ptr), hl 
20ae			 
20ae 2a 42 ea			ld hl,(cli_nextword) 
20b1			 
20b1 cd 54 21			call forth_tok_next 
20b4			; tok next start here 
20b4			;	; TODO skip compiled symbol for now 
20b4			;	inc hl 
20b4			; 
20b4			;	; save pointer to next word 
20b4			; 
20b4			;	; hl now points to the address of the next word pointer  
20b4			;	ld e, (hl) 
20b4			;	inc hl 
20b4			;	ld d, (hl) 
20b4			;	inc l 
20b4			; 
20b4			;	ex de,hl 
20b4			;if DEBUG_FORTH_PARSE_NEXTWORD 
20b4			;	push bc 
20b4			;	ld bc, (cli_nextword) 
20b4			;			DMARK "NXW" 
20b4			;	CALLMONITOR 
20b4			;	pop bc 
20b4			;endif 
20b4			; tok next end here 
20b4 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
20b7 eb				ex de, hl 
20b8			 
20b8			 
20b8				; save the pointer of the current token - 1 to check against 
20b8				 
20b8 22 46 ea			ld (cli_token), hl   
20bb				; TODO maybe remove below save if no debug 
20bb				; save token string ptr for any debug later 
20bb 23				inc hl  
20bc 22 48 ea			ld (cli_origtoken), hl 
20bf 2b				dec hl 
20c0				; save pointer to the start of the next dictionay word 
20c0 7e				ld a,(hl)   ; get string length 
20c1 47				ld b,a 
20c2			.execpnwordinc:  
20c2 23				inc hl 
20c3 10 fd			djnz .execpnwordinc 
20c5 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
20c8			 
20c8				; now check the word token against the string being parsed 
20c8			 
20c8 2a 46 ea			ld hl,(cli_token) 
20cb 23				inc hl     ; skip string length (use zero term instead to end) 
20cc 22 46 ea			ld (cli_token), hl 
20cf			 
20cf			if DEBUG_FORTH_PARSE_KEY 
20cf						DMARK "KY2" 
20cf			endif 
20cf			if DEBUG_FORTH_PARSE_EXEC 
20cf				; see if disabled 
20cf			 
20cf			;	ld a, (os_view_disable) 
20cf			;	cp '*' 
20cf				ld a, (debug_vector) 
20cf				cp $c9   ; RET  
20cf				jr z, .skip 
20cf			 
20cf				push hl 
20cf				push hl 
20cf				call clear_display 
20cf				ld de, .compword 
20cf				ld a, display_row_1 
20cf				call str_at_display 
20cf				pop de 
20cf				ld a, display_row_2 
20cf				call str_at_display 
20cf				ld hl,(cli_ptr) 
20cf				ld a,(hl) 
20cf			        ld hl, os_word_scratch 
20cf				ld (hl),a 
20cf				ld a,0 
20cf				inc hl 
20cf				ld (hl),a 	 
20cf				ld de, os_word_scratch 
20cf				ld a, display_row_2+10 
20cf				call str_at_display 
20cf				call update_display 
20cf				ld a, 100 
20cf				call aDelayInMS 
20cf				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20cf				call delay250ms 
20cf				endif 
20cf				pop hl 
20cf			.skip:  
20cf			endif	 
20cf			.execpnchar:    ; compare char between token and string to parse 
20cf			 
20cf			if DEBUG_FORTH_PARSE_KEY 
20cf						DMARK "Ky3" 
20cf			endif 
20cf			if DEBUG_FORTH_PARSE_EXEC 
20cf				; see if disabled 
20cf			 
20cf			;	ld a, (os_view_disable) 
20cf			;	cp '*' 
20cf				ld a, (debug_vector) 
20cf				cp $C9  ; RET 
20cf				jr z, .skip2 
20cf			 
20cf			;	call clear_display 
20cf			ld hl,(cli_token) 
20cf			ld a,(hl) 
20cf			ld (os_word_scratch),a 
20cf				ld hl,(cli_ptr) 
20cf			ld a,(hl) 
20cf				ld (os_word_scratch+1),a 
20cf				ld a,0 
20cf				ld (os_word_scratch+2),a 
20cf				ld de,os_word_scratch 
20cf				ld a,display_row_4 
20cf				call str_at_display 
20cf				call update_display 
20cf			.skip2:  
20cf			endif 
20cf 2a 46 ea			ld hl,(cli_token) 
20d2 7e				ld a, (hl)	 ; char in word token 
20d3 23				inc hl 		; move to next char 
20d4 22 46 ea			ld (cli_token), hl ; and save it 
20d7 47				ld b,a 
20d8			 
20d8 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
20db 7e				ld a,(hl) 
20dc 23				inc hl 
20dd 22 40 ea			ld (cli_ptr), hl		; move to next char 
20e0 cd 3c 12			call toUpper 		; make sure the input string matches case 
20e3			 
20e3			if DEBUG_FORTH_PARSE 
20e3			endif 
20e3			 
20e3				; input stream end of token is a space so get rid of it 
20e3			 
20e3			;	cp ' ' 
20e3			;	jr nz, .pnskipspace 
20e3			; 
20e3			;	ld a, 0		; make same term as word token term 
20e3			; 
20e3			;.pnskipspace: 
20e3			 
20e3			if DEBUG_FORTH_PARSE_KEY 
20e3						DMARK "KY7" 
20e3			endif 
20e3 b8				cp b 
20e4 c2 fa 20			jp nz, .execpnskipword	 ; no match so move to next word 
20e7				 
20e7			;    if same 
20e7			;       scan for string terms 0 for token and 32 for input 
20e7			 
20e7				 
20e7			if DEBUG_FORTH_PARSE_KEY 
20e7						DMARK "KY8" 
20e7			endif 
20e7			 
20e7 80				add b			 
20e8 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20ea							; TODO need to make sure last word in zero term string is accounted for 
20ea 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20ec			 
20ec			 
20ec				; at end of both strings so both are exact match 
20ec			 
20ec			;       skip ptr for next word 
20ec			 
20ec 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
20ef 23				inc hl			 ; at next char 
20f0 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
20f3 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
20f6				 
20f6				 
20f6			if DEBUG_FORTH_PARSE_KEY 
20f6						DMARK "KY3" 
20f6			endif 
20f6			 
20f6			 
20f6			 
20f6			;       exec code block 
20f6			if DEBUG_FORTH_JP 
20f6				call clear_display 
20f6				call update_display 
20f6				call delay1s 
20f6				ld hl, (cli_execword)     ; save for next check if no match on this word 
20f6				ld a,h 
20f6				ld hl, os_word_scratch 
20f6				call hexout 
20f6				ld hl, (cli_execword)     ; save for next check if no match on this word 
20f6				ld a,l 
20f6				ld hl, os_word_scratch+2 
20f6				call hexout 
20f6				ld hl, os_word_scratch+4 
20f6				ld a,0 
20f6				ld (hl),a 
20f6				ld de,os_word_scratch 
20f6				call str_at_display 
20f6					ld a, display_row_2 
20f6					call str_at_display 
20f6				ld de, (cli_origtoken) 
20f6				ld a, display_row_1+10 
20f6					call str_at_display 
20f6			 
20f6				ld a,display_row_1 
20f6				ld de, .foundword 
20f6				ld a, display_row_3 
20f6				call str_at_display 
20f6				call update_display 
20f6				call delay1s 
20f6				call delay1s 
20f6				call delay1s 
20f6			endif 
20f6			 
20f6			if DEBUG_FORTH_PARSE_KEY 
20f6						DMARK "KYj" 
20f6			endif 
20f6				; TODO save the word pointer in this exec 
20f6			 
20f6 2a 44 ea			ld hl,(cli_execword) 
20f9 e9				jp (hl) 
20fa			 
20fa			 
20fa			;    if not same 
20fa			;	scan for zero term 
20fa			;	get ptr for next word 
20fa			;	goto word comp 
20fa			 
20fa			.execpnskipword:	; get pointer to next word 
20fa 2a 42 ea			ld hl,(cli_nextword) 
20fd			 
20fd 7e				ld a,(hl) 
20fe fe 00			cp WORD_SYS_END 
2100			;	cp 0 
2100 28 09			jr z, .execendofdict			 ; at end of words 
2102			 
2102			if DEBUG_FORTH_PARSE_KEY 
2102						DMARK "KY4" 
2102			endif 
2102			if DEBUG_FORTH_PARSE_EXEC 
2102			 
2102				; see if disabled 
2102			 
2102			;	ld a, (os_view_disable) 
2102			;	cp '*' 
2102				ld a,(debug_vector) 
2102				cp $c9   ; RET 
2102				jr z, .noskip 
2102			 
2102			 
2102				ld de, .nowordfound 
2102				ld a, display_row_3 
2102				call str_at_display 
2102				call update_display 
2102				ld a, 100 
2102				call aDelayInMS 
2102				 
2102				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2102					call delay250ms 
2102				endif 
2102			.noskip:  
2102			 
2102			endif	 
2102			 
2102 2a 3e ea			ld hl,(cli_origptr) 
2105 22 40 ea			ld (cli_ptr),hl 
2108			 
2108			if DEBUG_FORTH_PARSE_KEY 
2108						DMARK "KY5" 
2108			endif 
2108 c3 ae 20			jp .execpnword			; else go to next word 
210b			 
210b			.execendofdict:  
210b			 
210b			if DEBUG_FORTH_PARSE_KEY 
210b						DMARK "KYe" 
210b			endif 
210b			if DEBUG_FORTH_PARSE_EXEC 
210b				; see if disabled 
210b			 
210b			;	ld a, (os_view_disable) 
210b			;	cp '*' 
210b				ld a,(debug_vector) 
210b				cp $c9   ; ret 
210b				jr z, .ispskip 
210b			 
210b				call clear_display 
210b				call update_display 
210b				call delay1s 
210b				ld de, (cli_origptr) 
210b				ld a, display_row_1 
210b				call str_at_display 
210b				 
210b				ld de, .enddict 
210b				ld a, display_row_3 
210b				call str_at_display 
210b				call update_display 
210b				ld a, 100 
210b				call aDelayInMS 
210b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
210b				call delay1s 
210b				call delay1s 
210b				call delay1s 
210b				endif 
210b			.ispskip:  
210b				 
210b			endif	 
210b			 
210b			 
210b			 
210b				; if the word is not a keyword then must be a literal so push it to stack 
210b			 
210b			; push token to stack to end of word 
210b			 
210b				STACKFRAME ON $1efe $2f9f 
210b				if DEBUG_STACK_IMB 
210b					if ON 
210b						exx 
210b						ld de, $1efe 
210b						ld a, d 
210b						ld hl, curframe 
210b						call hexout 
210b						ld a, e 
210b						ld hl, curframe+2 
210b						call hexout 
210b						ld hl, $1efe 
210b						push hl 
210b						ld hl, $2f9f 
210b						push hl 
210b						exx 
210b					endif 
210b				endif 
210b			endm 
# End of macro STACKFRAME
210b			 
210b 2a c2 e5		ld hl,(os_tok_ptr) 
210e cd bf 1d		call forth_apush 
2111			 
2111				STACKFRAMECHK ON $1efe $2f9f 
2111				if DEBUG_STACK_IMB 
2111					if ON 
2111						exx 
2111						ld hl, $2f9f 
2111						pop de   ; $2f9f 
2111						call cmp16 
2111						jr nz, .spnosame 
2111						ld hl, $1efe 
2111						pop de   ; $1efe 
2111						call cmp16 
2111						jr z, .spfrsame 
2111						.spnosame: call showsperror 
2111						.spfrsame: nop 
2111						exx 
2111					endif 
2111				endif 
2111			endm 
# End of macro STACKFRAMECHK
2111			 
2111			execnext: 
2111			 
2111			if DEBUG_FORTH_PARSE_KEY 
2111						DMARK "KY>" 
2111			endif 
2111			; move past token to next word 
2111			 
2111 2a c2 e5		ld hl, (os_tok_ptr) 
2114 3e 00		ld a, 0 
2116 01 ff 00		ld bc, 255     ; input buffer size 
2119 ed b1		cpir 
211b			 
211b			if DEBUG_FORTH_PARSE_KEY 
211b						DMARK "KY!" 
211b				CALLMONITOR 
211b			endif	 
211b			; TODO this might place hl on the null, so will need to forward on??? 
211b			;inc hl   ; see if this gets onto the next item 
211b			 
211b			 
211b			; TODO pass a pointer to the buffer to push 
211b			; TODO call function to push 
211b			 
211b			; look for end of input 
211b			 
211b			;inc hl 
211b			;ld a,(hl) 
211b			;cp FORTH_END_BUFFER 
211b			;ret z 
211b			 
211b			 
211b c3 94 20		jp exec1 
211e			 
211e			 
211e			 
211e			 
211e			 
211e			 
211e			 
211e			 
211e			 
211e			findnexttok: 
211e			 
211e				; hl is pointer to move 
211e				; de is the token to locate 
211e			 
211e					if DEBUG_FORTH 
211e						DMARK "NTK" 
211e						CALLMONITOR 
211e					endif 
211e d5				push de 
211f			 
211f			.fnt1:	 
211f				; find first char of token to locate 
211f			 
211f 1a				ld a, (de) 
2120 4f				ld c,a 
2121 7e				ld a,(hl) 
2122 cd 3c 12			call toUpper 
2125					if DEBUG_FORTH 
2125						DMARK "NT1" 
2125						CALLMONITOR 
2125					endif 
2125 b9				cp c 
2126			 
2126 28 03			jr z, .fnt2cmpmorefirst	 
2128			 
2128				; first char not found move to next char 
2128			 
2128 23				inc hl 
2129 18 f4			jr .fnt1 
212b			 
212b			.fnt2cmpmorefirst:	 
212b				; first char of token found.  
212b			 
212b e5				push hl     ; save start of token just in case it is the right one 
212c d9				exx 
212d e1				pop hl        ; save it to hl' 
212e d9				exx 
212f			 
212f			 
212f			.fnt2cmpmore:	 
212f				; compare the rest 
212f				 
212f 23				inc hl 
2130 13				inc de 
2131				 
2131 1a				ld a, (de) 
2132 4f				ld c,a 
2133 7e				ld a,(hl) 
2134 cd 3c 12			call toUpper 
2137			 
2137					if DEBUG_FORTH 
2137						DMARK "NT2" 
2137						CALLMONITOR 
2137					endif 
2137				; c has the token to find char 
2137				; a has the mem to scan char 
2137			 
2137 b9				cp c 
2138 28 04			jr z,.fntmatch1 
213a			 
213a				; they are not the same 
213a			 
213a					if DEBUG_FORTH 
213a						DMARK "NT3" 
213a						CALLMONITOR 
213a					endif 
213a d1				pop de	; reset de token to look for 
213b d5				push de 
213c 18 e1			jr .fnt1 
213e				 
213e			.fntmatch1: 
213e			 
213e				; is the same char a null which means we might have a full hit? 
213e					if DEBUG_FORTH 
213e						DMARK "NT4" 
213e						CALLMONITOR 
213e					endif 
213e			 
213e fe 00			cp 0 
2140 28 0b			jr z, .fntmatchyes 
2142			 
2142				; are we at the end of the token to find? 
2142			 
2142					if DEBUG_FORTH 
2142						DMARK "NT5" 
2142						CALLMONITOR 
2142					endif 
2142 3e 00			ld a, 0 
2144 b9				cp c 
2145			 
2145 c2 2f 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2148			 
2148					if DEBUG_FORTH 
2148						DMARK "NT6" 
2148						CALLMONITOR 
2148					endif 
2148				; token to find is exhusted but no match to stream 
2148			 
2148				; restore tok pointer and continue on 
2148 d1				pop de 
2149 d5				push de 
214a c3 1f 21			jp .fnt1 
214d			 
214d			 
214d			.fntmatchyes: 
214d			 
214d				; hl now contains the end of the found token 
214d			 
214d				; get rid of saved token pointer to find 
214d			 
214d d1				pop de 
214e			 
214e					if DEBUG_FORTH 
214e						DMARK "NT9" 
214e						CALLMONITOR 
214e					endif 
214e			 
214e				; hl will be on the null term so forward on 
214e			 
214e				; get back the saved start of the token 
214e			 
214e d9				exx 
214f e5				push hl     ; save start of token just in case it is the right one 
2150 d9				exx 
2151 e1				pop hl        ; save it to hl 
2152			 
2152 c9				ret 
2153			 
2153			 
2153			; LIST needs to find a specific token   
2153			; FORGET needs to find a spefici token 
2153			 
2153			; SAVE needs to find all tokens by flag 
2153			; WORDS just needs to scan through all  by flag 
2153			; UWORDS needs to scan through all by flag 
2153			 
2153			 
2153			; given hl as pointer to start of dict look up string 
2153			; return hl as pointer to start of word block 
2153			; or 0 if not found 
2153			 
2153			forth_find_tok: 
2153 c9				ret 
2154			 
2154			; given hl as pointer to dict structure 
2154			; move to the next dict block structure 
2154			 
2154			forth_tok_next: 
2154				; hl now points to the address of the next word pointer  
2154				; TODO skip compiled symbol for now 
2154			;	push de 
2154 23				inc hl 
2155 5e				ld e, (hl) 
2156 23				inc hl 
2157 56				ld d, (hl) 
2158 23				inc hl 
2159			 
2159 eb				ex de,hl 
215a			if DEBUG_FORTH_PARSE_NEXTWORD 
215a				push bc 
215a				ld bc, (cli_nextword) 
215a						DMARK "NXW" 
215a				CALLMONITOR 
215a				pop bc 
215a			endif 
215a			;	pop de	 
215a c9				ret 
215b			 
215b			 
215b			 
215b			; eof 
# End of file forth_parserv5.asm
215b				include "forth_wordsv4.asm" 
215b			 
215b			; the core word dictionary v4 
215b			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
215b			 
215b			; this is a linked list for each of the system words used 
215b			; user defined words will follow the same format but will be in ram 
215b			 
215b			 
215b			; 
215b			; 
215b			; define linked list: 
215b			; 
215b			; 1. compiled byte op code 
215b			; 2. len of text word 
215b			; 3. text word 
215b			; 4. ptr to next dictionary word 
215b			; 5. asm, calls etc for the word 
215b			; 
215b			;  if 1 == 0 then last word in dict  
215b			;   
215b			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
215b			;  
215b			;  
215b			; create basic standard set of words 
215b			; 
215b			;  
215b			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
215b			; 2DUP 2DROP 2SWAP  
215b			; @ C@ - get byte  
215b			; ! C! - store byte 
215b			; 0< true if less than zero 
215b			; 0= true if zero 
215b			; < >  
215b			; = true if same 
215b			; variables 
215b			 
215b			 
215b			; Hardware specific words I may need 
215b			; 
215b			; IN OUT  
215b			; calls to key util functions 
215b			; calls to hardward abstraction stuff 
215b			; easy control of frame buffers and lcd i/o 
215b			; keyboard  
215b			 
215b			 
215b			;DICT: macro 
215b			; op_code, len, word, next 
215b			;    word: 
215b			;    db op_code 
215b			;    ds word zero term 
215b			;    dw next 
215b			;    endm 
215b			 
215b			 
215b			 
215b			 
215b			; op code 1 is a flag for user define words which are to be handled differently 
215b			 
215b			 
215b			; 
215b			; 
215b			;    TODO on entry to a word this should be the expected environment 
215b			;    hl - tos value if number then held, if string this is the ptr 
215b			;    de -  
215b			 
215b			 
215b			; opcode ranges 
215b			; 0 - end of word dict 
215b			; 255 - user define words 
215b			 
215b			sysdict: 
215b			include "forth_opcodes.asm" 
215b			; op codes for forth keywords 
215b			; free to use code 0  
215b				OPCODE_HEAP: equ  1 
215b				OPCODE_EXEC: equ 2 
215b				OPCODE_DUP: equ 3 
215b				OPCODE_SWAP: equ 4 
215b				OPCODE_COLN: equ 5 
215b				OPCODE_SCOLN: equ 6 
215b				OPCODE_DROP: equ 7 
215b				OPCODE_DUP2: equ 8 
215b				OPCODE_DROP2: equ 9 
215b				OPCODE_SWAP2: equ 10 
215b				OPCODE_AT: equ 11 
215b				OPCODE_CAT: equ 12 
215b				OPCODE_BANG: equ 13 
215b				OPCODE_CBANG: equ 14 
215b				OPCODE_SCALL: equ 15 
215b				OPCODE_DEPTH: equ 16 
215b				OPCODE_OVER: equ 17 
215b				OPCODE_PAUSE: equ 18 
215b				OPCODE_PAUSES: equ 19 
215b				OPCODE_ROT: equ 20 
215b			;free to reuse	OPCODE_WORDS: equ 21 
215b			        OPCODE_NOT: equ 21 
215b				OPCODE_UWORDS: equ 22 
215b				OPCODE_BP: equ 23 
215b				OPCODE_MONITOR: equ 24  
215b				OPCODE_MALLOC: equ 25 
215b				OPCODE_FREE: equ 26 
215b				OPCODE_LIST: equ 27 
215b				OPCODE_FORGET: equ 28 
215b				OPCODE_NOP: equ 29 
215b				OPCODE_COMO: equ 30 
215b				OPCODE_COMC: equ 31 
215b			;free to reuse	OPCODE_ENDCORE: equ 32 
215b				OPCODE_AFTERSOUND: equ 33 
215b				OPCODE_GP2: equ 34 
215b				OPCODE_GP3: equ 35 
215b				OPCODE_GP4: equ 36 
215b				OPCODE_SIN: equ 37 
215b				OPCODE_SOUT: equ 38 
215b				OPCODE_SPIO: equ 39 
215b				OPCODE_SPICEH: equ 40 
215b				OPCODE_SPIOb: equ 41 
215b				OPCODE_SPII: equ 42 
215b				OPCODE_SESEL: equ 43 
215b				OPCODE_CARTDEV: equ 44 
215b			; free to reuse	OPCODE_ENDDEVICE: equ 45 
215b				OPCODE_FB: equ 46 
215b				OPCODE_EMIT: equ 47 
215b				OPCODE_DOTH: equ 48 
215b				OPCODE_DOTF: equ 49 
215b				OPCODE_DOT: equ 50 
215b				OPCODE_CLS: equ 51 
215b				OPCODE_DRAW: equ 52 
215b				OPCODE_DUMP: equ 53 
215b				OPCODE_CDUMP: equ 54 
215b				OPCODE_DAT: equ 55 
215b				OPCODE_HOME: equ 56 
215b				OPCODE_SPACE: equ 57 
215b				OPCODE_SPACES: equ 58 
215b				OPCODE_SCROLL: equ 59 
215b				OPCODE_ATQ: equ 60 
215b				OPCODE_AUTODSP: equ 61 
215b				OPCODE_MENU: equ 62 
215b			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
215b				OPCODE_THEN: equ 64 
215b				OPCODE_ELSE: equ 65 
215b				OPCODE_DO: equ 66 
215b				OPCODE_LOOP: equ 67 
215b				OPCODE_I: equ 68 
215b				OPCODE_DLOOP: equ 69  
215b				OPCODE_REPEAT: equ 70  
215b				OPCODE_UNTIL: equ 71 
215b				OPCODE_ENDFLOW: equ 72 
215b				OPCODE_WAITK: equ 73 
215b				OPCODE_ACCEPT: equ 74 
215b				OPCODE_EDIT: equ 75 
215b			;free to reuse	OPCODE_ENDKEY: equ 76 
215b				OPCODE_LZERO: equ 77 
215b				OPCODE_TZERO: equ 78 
215b				OPCODE_LESS: equ 79 
215b				OPCODE_GT: equ 80 
215b				OPCODE_EQUAL: equ 81  
215b			;free to reuse	OPCODE_ENDLOGIC: equ 82 
215b				OPCODE_NEG: equ 83 
215b				OPCODE_DIV: equ 84 
215b				OPCODE_MUL: equ 85 
215b				OPCODE_MIN: equ 86 
215b				OPCODE_MAX: equ 87 
215b				OPCODE_RND16: equ 88 
215b				OPCODE_RND8: equ 89 
215b				OPCODE_RND: equ 90 
215b			;free to reuse	OPCODE_ENDMATHS: equ 91  
215b				OPCODE_BYNAME: equ 92 
215b				OPCODE_DIR: equ 93 
215b				OPCODE_SAVE: equ 94 
215b				OPCODE_LOAD: equ 95 
215b				OPCODE_BSAVE: equ 96 
215b				OPCODE_BLOAD: equ 97 
215b				OPCODE_SEO: equ 98  
215b				OPCODE_SEI: equ 99 
215b				OPCODE_SFREE: equ 100 
215b				OPCODE_SIZE: equ 101 
215b				OPCODE_CREATE: equ 102 
215b				OPCODE_APPEND: equ 103 
215b				OPCODE_SDEL: equ 104 
215b				OPCODE_OPEN: equ 105 
215b				OPCODE_READ: equ 106 
215b				OPCODE_EOF: equ 106 
215b				OPCODE_FORMAT: equ 107 
215b				OPCODE_LABEL: equ 108 
215b				OPCODE_LABELS: equ 109 
215b			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
215b				OPCODE_UPPER: equ 111 
215b				OPCODE_LOWER: equ 112 
215b				OPCODE_SUBSTR: equ 113 
215b				OPCODE_LEFT: equ 114 
215b				OPCODE_RIGHT: equ 115 
215b				OPCODE_STR2NUM: equ 116 
215b				OPCODE_NUM2STR: equ 117 
215b				OPCODE_CONCAT: equ 118 
215b				OPCODE_FIND: equ 119 
215b				OPCODE_LEN: equ 120 
215b				OPCODE_CHAR: equ 121 
215b			; free to reuse	OPCODE_STRLEN: equ 122 
215b			; free to reuse	OPCODE_ENDSTR: equ 123 
215b				OPCODE_V0S: equ 124 
215b				OPCODE_V0Q: equ 125 
215b				OPCODE_V1S: equ 126 
215b				OPCODE_V1Q: equ 127 
215b				OPCODE_V2S: equ 128 
215b				OPCODE_V2Q: equ 129 
215b				OPCODE_V3S: equ 130 
215b				OPCODE_V3Q: equ 131 
215b			;free to reuse	OPCODE_END: equ 132 
215b				OPCODE_ZDUP: equ 133 
215b			 
215b			; eof 
# End of file forth_opcodes.asm
215b			 
215b			include "forth_words_core.asm" 
215b			 
215b			; | ## Core Words 
215b			 
215b			;if MALLOC_4 
215b			 
215b			.HEAP: 
215b				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
215b 15				db WORD_SYS_CORE+OPCODE_HEAP             
215c 9a 21			dw .EXEC            
215e 05				db 4 + 1 
215f .. 00			db "HEAP",0              
2164				endm 
# End of macro CWHEAD
2164			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2164			; | | u1 - Current number of bytes in the heap 
2164			; | | u2 - Remaining bytes left on the heap 
2164			; | |  
2164			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2164			 
2164			 
2164					if DEBUG_FORTH_WORDS_KEY 
2164						DMARK "HEP" 
2164 f5				push af  
2165 3a 79 21			ld a, (.dmark)  
2168 32 6b ee			ld (debug_mark),a  
216b 3a 7a 21			ld a, (.dmark+1)  
216e 32 6c ee			ld (debug_mark+1),a  
2171 3a 7b 21			ld a, (.dmark+2)  
2174 32 6d ee			ld (debug_mark+2),a  
2177 18 03			jr .pastdmark  
2179 ..			.dmark: db "HEP"  
217c f1			.pastdmark: pop af  
217d			endm  
# End of macro DMARK
217d						CALLMONITOR 
217d cd 6f ee			call debug_vector  
2180				endm  
# End of macro CALLMONITOR
2180					endif 
2180 2a 4a 65				ld hl, (free_list )      
2183 11 4f 65				ld de, heap_start 
2186			 
2186 ed 52				sbc hl, de  
2188			 
2188 cd 56 1c				call forth_push_numhl 
218b			 
218b			 
218b ed 5b 4a 65			ld de, (free_list )      
218f 21 a8 e2				ld hl, heap_end 
2192			 
2192 ed 52				sbc hl, de 
2194			 
2194 cd 56 1c				call forth_push_numhl 
2197					 
2197			 
2197					 
2197			 
2197			 
2197			 
2197					NEXTW 
2197 c3 03 20			jp macro_next 
219a				endm 
# End of macro NEXTW
219a			;endif 
219a			 
219a			.EXEC: 
219a			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
219a			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
219a			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
219a			;; > > 
219a			;; > >   
219a			;	STACKFRAME OFF $5efe $5f9f 
219a			; 
219a			;		if DEBUG_FORTH_WORDS_KEY 
219a			;			DMARK "EXE" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			; 
219a			;	FORTH_DSP_VALUEHL 
219a			; 
219a			;	FORTH_DSP_POP 
219a			; 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX1" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;;	ld e,(hl) 
219a			;;	inc hl 
219a			;;	ld d,(hl) 
219a			;;	ex de,hl 
219a			; 
219a			;;		if DEBUG_FORTH_WORDS 
219a			;;			DMARK "EX2" 
219a			;;			CALLMONITOR 
219a			;;		endif 
219a			;	push hl 
219a			; 
219a			;	;ld a, 0 
219a			;	;ld a, FORTH_END_BUFFER 
219a			;	call strlenz 
219a			;	inc hl   ; include zero term to copy 
219a			;	inc hl   ; include term 
219a			;	inc hl   ; include term 
219a			;	ld b,0 
219a			;	ld c,l 
219a			;	pop hl 
219a			;	ld de, execscratch 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX3" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	ldir 
219a			; 
219a			; 
219a			;	ld hl, execscratch 
219a			; 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EXe" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			; 
219a			;	call forthparse 
219a			;	call forthexec 
219a			;;	call forthexec_cleanup 
219a			;;	call forthparse 
219a			;;	call forthexec 
219a			; 
219a			;	STACKFRAMECHK OFF $5efe $5f9f 
219a			; 
219a			;	; an immediate word so no need to process any more words 
219a			;	ret 
219a			;	NEXTW 
219a			 
219a			; dead code - old version  
219a			;	FORTH_RSP_NEXT 
219a			 
219a			;  
219a			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
219a			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
219a			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
219a			;	push hl 
219a			;	push de 
219a			;	push bc 
219a			; 
219a			; 
219a			;		if DEBUG_FORTH_WORDS_KEY 
219a			;			DMARK "EXR" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			; 
219a			; 
219a			; 
219a			;	;v5 FORTH_DSP_VALUE 
219a			;	FORTH_DSP_VALUEHL 
219a			; 
219a			;	; TODO do string type checks 
219a			; 
219a			;;v5	inc hl   ; skip type 
219a			; 
219a			;	push hl  ; source code  
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX1" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	ld a, 0 
219a			;	call strlent 
219a			; 
219a			;	inc hl 
219a			;	inc hl 
219a			;	inc hl 
219a			;	inc hl 
219a			; 
219a			;	push hl    ; size 
219a			; 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX2" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	call malloc 
219a			; 
219a			;	ex de, hl    ; de now contains malloc area 
219a			;	pop bc   	; get byte count 
219a			;	pop hl      ; get string to copy 
219a			; 
219a			;	push de     ; save malloc for free later 
219a			; 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX3" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	ldir       ; duplicate string 
219a			; 
219a			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
219a			;	 
219a			;	; TODO fix the parse would be better than this...  
219a			;	ex de, hl 
219a			;	dec hl 
219a			;	ld a, 0 
219a			;	ld (hl), a 
219a			;	dec hl 
219a			;	ld a, ' ' 
219a			;	ld (hl), a 
219a			;	dec hl 
219a			;	ld (hl), a 
219a			; 
219a			;	dec hl 
219a			;	ld (hl), a 
219a			; 
219a			; 
219a			;	FORTH_DSP_POP  
219a			; 
219a			;	pop hl     
219a			;	push hl    ; save malloc area 
219a			; 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX4" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			; 
219a			;	call forthparse 
219a			;	call forthexec 
219a			;	 
219a			;	pop hl 
219a			;	if DEBUG_FORTH_WORDS 
219a			;		DMARK "EX5" 
219a			;		CALLMONITOR 
219a			;	endif 
219a			; 
219a			;	if FORTH_ENABLE_FREE 
219a			;	call free 
219a			;	endif 
219a			; 
219a			;	if DEBUG_FORTH_WORDS 
219a			;		DMARK "EX6" 
219a			;		CALLMONITOR 
219a			;	endif 
219a			; 
219a			;	pop bc 
219a			;	pop de 
219a			;	pop hl 
219a			;;	FORTH_RSP_POP	  
219a			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
219a			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
219a			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
219a			; 
219a			;	if DEBUG_FORTH_WORDS 
219a			;		DMARK "EX7" 
219a			;		CALLMONITOR 
219a			;	endif 
219a			;	NEXTW 
219a			 
219a			;.STKEXEC: 
219a			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
219a			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
219a			; 
219a			; 
219a			;		if DEBUG_FORTH_WORDS_KEY 
219a			;			DMARK "STX" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			; 
219a			;	FORTH_DSP_VALUEHL 
219a			; 
219a			;	ld (store_tmp1), hl    ; count 
219a			; 
219a			;	FORTH_DSP_POP 
219a			;.stkexec1: 
219a			;	ld hl, (store_tmp1)   ; count 
219a			;	ld a, 0 
219a			;	cp l 
219a			;	ret z 
219a			; 
219a			;	dec hl 
219a			;	ld (store_tmp1), hl    ; count 
219a			;	 
219a			;	FORTH_DSP_VALUEHL 
219a			;	push hl 
219a			;	 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EXp" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	FORTH_DSP_POP 
219a			; 
219a			;	call strlenz 
219a			;	inc hl   ; include zero term to copy 
219a			;	inc hl   ; include zero term to copy 
219a			;	inc hl   ; include zero term to copy 
219a			;	ld b,0 
219a			;	ld c,l 
219a			;	pop hl 
219a			;	ld de, execscratch 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX3" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	ldir 
219a			; 
219a			; 
219a			;	ld hl, execscratch 
219a			; 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EXP" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			; 
219a			;	call forthparse 
219a			;	ld hl, execscratch 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EXx" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	call forthexec 
219a			; 
219a			;	jp .stkexec1 
219a			; 
219a			;	ret 
219a			 
219a			 
219a			.DUP: 
219a				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
219a 17				db WORD_SYS_CORE+OPCODE_DUP             
219b 10 22			dw .ZDUP            
219d 04				db 3 + 1 
219e .. 00			db "DUP",0              
21a2				endm 
# End of macro CWHEAD
21a2			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21a2			 
21a2					if DEBUG_FORTH_WORDS_KEY 
21a2						DMARK "DUP" 
21a2 f5				push af  
21a3 3a b7 21			ld a, (.dmark)  
21a6 32 6b ee			ld (debug_mark),a  
21a9 3a b8 21			ld a, (.dmark+1)  
21ac 32 6c ee			ld (debug_mark+1),a  
21af 3a b9 21			ld a, (.dmark+2)  
21b2 32 6d ee			ld (debug_mark+2),a  
21b5 18 03			jr .pastdmark  
21b7 ..			.dmark: db "DUP"  
21ba f1			.pastdmark: pop af  
21bb			endm  
# End of macro DMARK
21bb						CALLMONITOR 
21bb cd 6f ee			call debug_vector  
21be				endm  
# End of macro CALLMONITOR
21be					endif 
21be			 
21be					FORTH_DSP 
21be cd 13 1e			call macro_forth_dsp 
21c1				endm 
# End of macro FORTH_DSP
21c1			 
21c1 7e					ld a, (HL) 
21c2 fe 01				cp DS_TYPE_STR 
21c4 20 25				jr nz, .dupinum 
21c6			 
21c6					; push another string 
21c6			 
21c6					FORTH_DSP_VALUEHL     		 
21c6 cd 4d 1e			call macro_dsp_valuehl 
21c9				endm 
# End of macro FORTH_DSP_VALUEHL
21c9			 
21c9				if DEBUG_FORTH_WORDS 
21c9					DMARK "DUs" 
21c9 f5				push af  
21ca 3a de 21			ld a, (.dmark)  
21cd 32 6b ee			ld (debug_mark),a  
21d0 3a df 21			ld a, (.dmark+1)  
21d3 32 6c ee			ld (debug_mark+1),a  
21d6 3a e0 21			ld a, (.dmark+2)  
21d9 32 6d ee			ld (debug_mark+2),a  
21dc 18 03			jr .pastdmark  
21de ..			.dmark: db "DUs"  
21e1 f1			.pastdmark: pop af  
21e2			endm  
# End of macro DMARK
21e2					CALLMONITOR 
21e2 cd 6f ee			call debug_vector  
21e5				endm  
# End of macro CALLMONITOR
21e5				endif 
21e5 cd c4 1c				call forth_push_str 
21e8			 
21e8					NEXTW 
21e8 c3 03 20			jp macro_next 
21eb				endm 
# End of macro NEXTW
21eb			 
21eb			 
21eb			.dupinum: 
21eb					 
21eb			 
21eb			 
21eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21eb cd 4d 1e			call macro_dsp_valuehl 
21ee				endm 
# End of macro FORTH_DSP_VALUEHL
21ee			 
21ee				; TODO add floating point number detection 
21ee			 
21ee				if DEBUG_FORTH_WORDS 
21ee					DMARK "DUi" 
21ee f5				push af  
21ef 3a 03 22			ld a, (.dmark)  
21f2 32 6b ee			ld (debug_mark),a  
21f5 3a 04 22			ld a, (.dmark+1)  
21f8 32 6c ee			ld (debug_mark+1),a  
21fb 3a 05 22			ld a, (.dmark+2)  
21fe 32 6d ee			ld (debug_mark+2),a  
2201 18 03			jr .pastdmark  
2203 ..			.dmark: db "DUi"  
2206 f1			.pastdmark: pop af  
2207			endm  
# End of macro DMARK
2207					CALLMONITOR 
2207 cd 6f ee			call debug_vector  
220a				endm  
# End of macro CALLMONITOR
220a				endif 
220a			 
220a cd 56 1c				call forth_push_numhl 
220d					NEXTW 
220d c3 03 20			jp macro_next 
2210				endm 
# End of macro NEXTW
2210			.ZDUP: 
2210				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2210 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2211 48 22			dw .SWAP            
2213 05				db 4 + 1 
2214 .. 00			db "?DUP",0              
2219				endm 
# End of macro CWHEAD
2219			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2219			 
2219					if DEBUG_FORTH_WORDS_KEY 
2219						DMARK "qDU" 
2219 f5				push af  
221a 3a 2e 22			ld a, (.dmark)  
221d 32 6b ee			ld (debug_mark),a  
2220 3a 2f 22			ld a, (.dmark+1)  
2223 32 6c ee			ld (debug_mark+1),a  
2226 3a 30 22			ld a, (.dmark+2)  
2229 32 6d ee			ld (debug_mark+2),a  
222c 18 03			jr .pastdmark  
222e ..			.dmark: db "qDU"  
2231 f1			.pastdmark: pop af  
2232			endm  
# End of macro DMARK
2232						CALLMONITOR 
2232 cd 6f ee			call debug_vector  
2235				endm  
# End of macro CALLMONITOR
2235					endif 
2235					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2235 cd 4d 1e			call macro_dsp_valuehl 
2238				endm 
# End of macro FORTH_DSP_VALUEHL
2238			 
2238 e5					push hl 
2239			 
2239					; is it a zero? 
2239			 
2239 3e 00				ld a, 0 
223b 84					add h 
223c 85					add l 
223d			 
223d e1					pop hl 
223e			 
223e fe 00				cp 0 
2240 28 03				jr z, .dup2orig 
2242			 
2242			 
2242 cd 56 1c				call forth_push_numhl 
2245			 
2245			 
2245				; TODO add floating point number detection 
2245			 
2245			.dup2orig: 
2245			 
2245					NEXTW 
2245 c3 03 20			jp macro_next 
2248				endm 
# End of macro NEXTW
2248			.SWAP: 
2248				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2248 18				db WORD_SYS_CORE+OPCODE_SWAP             
2249 87 22			dw .COLN            
224b 05				db 4 + 1 
224c .. 00			db "SWAP",0              
2251				endm 
# End of macro CWHEAD
2251			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2251					if DEBUG_FORTH_WORDS_KEY 
2251						DMARK "SWP" 
2251 f5				push af  
2252 3a 66 22			ld a, (.dmark)  
2255 32 6b ee			ld (debug_mark),a  
2258 3a 67 22			ld a, (.dmark+1)  
225b 32 6c ee			ld (debug_mark+1),a  
225e 3a 68 22			ld a, (.dmark+2)  
2261 32 6d ee			ld (debug_mark+2),a  
2264 18 03			jr .pastdmark  
2266 ..			.dmark: db "SWP"  
2269 f1			.pastdmark: pop af  
226a			endm  
# End of macro DMARK
226a						CALLMONITOR 
226a cd 6f ee			call debug_vector  
226d				endm  
# End of macro CALLMONITOR
226d					endif 
226d			 
226d					FORTH_DSP_VALUEHL 
226d cd 4d 1e			call macro_dsp_valuehl 
2270				endm 
# End of macro FORTH_DSP_VALUEHL
2270 e5					push hl     ; w2 
2271			 
2271					FORTH_DSP_POP 
2271 cd 05 1f			call macro_forth_dsp_pop 
2274				endm 
# End of macro FORTH_DSP_POP
2274			 
2274					FORTH_DSP_VALUEHL 
2274 cd 4d 1e			call macro_dsp_valuehl 
2277				endm 
# End of macro FORTH_DSP_VALUEHL
2277			 
2277					FORTH_DSP_POP 
2277 cd 05 1f			call macro_forth_dsp_pop 
227a				endm 
# End of macro FORTH_DSP_POP
227a			 
227a d1					pop de     ; w2	, hl = w1 
227b			 
227b eb					ex de, hl 
227c d5					push de 
227d			 
227d cd 56 1c				call forth_push_numhl 
2280			 
2280 e1					pop hl 
2281			 
2281 cd 56 1c				call forth_push_numhl 
2284					 
2284			 
2284					NEXTW 
2284 c3 03 20			jp macro_next 
2287				endm 
# End of macro NEXTW
2287			.COLN: 
2287				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2287 19				db WORD_SYS_CORE+OPCODE_COLN             
2288 13 24			dw .SCOLN            
228a 02				db 1 + 1 
228b .. 00			db ":",0              
228d				endm 
# End of macro CWHEAD
228d			; | : ( -- )         Create new word | DONE 
228d			 
228d					if DEBUG_FORTH_WORDS_KEY 
228d						DMARK "CLN" 
228d f5				push af  
228e 3a a2 22			ld a, (.dmark)  
2291 32 6b ee			ld (debug_mark),a  
2294 3a a3 22			ld a, (.dmark+1)  
2297 32 6c ee			ld (debug_mark+1),a  
229a 3a a4 22			ld a, (.dmark+2)  
229d 32 6d ee			ld (debug_mark+2),a  
22a0 18 03			jr .pastdmark  
22a2 ..			.dmark: db "CLN"  
22a5 f1			.pastdmark: pop af  
22a6			endm  
# End of macro DMARK
22a6						CALLMONITOR 
22a6 cd 6f ee			call debug_vector  
22a9				endm  
# End of macro CALLMONITOR
22a9					endif 
22a9				STACKFRAME OFF $8efe $989f 
22a9				if DEBUG_STACK_IMB 
22a9					if OFF 
22a9						exx 
22a9						ld de, $8efe 
22a9						ld a, d 
22a9						ld hl, curframe 
22a9						call hexout 
22a9						ld a, e 
22a9						ld hl, curframe+2 
22a9						call hexout 
22a9						ld hl, $8efe 
22a9						push hl 
22a9						ld hl, $989f 
22a9						push hl 
22a9						exx 
22a9					endif 
22a9				endif 
22a9			endm 
# End of macro STACKFRAME
22a9				; get parser buffer length  of new word 
22a9			 
22a9				 
22a9			 
22a9					; move tok past this to start of name defintition 
22a9					; TODO get word to define 
22a9					; TODO Move past word token 
22a9					; TODO get length of string up to the ';' 
22a9			 
22a9 2a c2 e5			ld hl, (os_tok_ptr) 
22ac 23				inc hl 
22ad 23				inc hl 
22ae			 
22ae 3e 3b			ld a, ';' 
22b0 cd 50 12			call strlent 
22b3			 
22b3 7d				ld a,l 
22b4 32 bd e2			ld (os_new_parse_len), a 
22b7			 
22b7			 
22b7			if DEBUG_FORTH_UWORD 
22b7 ed 5b c2 e5		ld de, (os_tok_ptr) 
22bb						DMARK ":01" 
22bb f5				push af  
22bc 3a d0 22			ld a, (.dmark)  
22bf 32 6b ee			ld (debug_mark),a  
22c2 3a d1 22			ld a, (.dmark+1)  
22c5 32 6c ee			ld (debug_mark+1),a  
22c8 3a d2 22			ld a, (.dmark+2)  
22cb 32 6d ee			ld (debug_mark+2),a  
22ce 18 03			jr .pastdmark  
22d0 ..			.dmark: db ":01"  
22d3 f1			.pastdmark: pop af  
22d4			endm  
# End of macro DMARK
22d4				CALLMONITOR 
22d4 cd 6f ee			call debug_vector  
22d7				endm  
# End of macro CALLMONITOR
22d7			endif 
22d7			 
22d7			; 
22d7			;  new word memory layout: 
22d7			;  
22d7			;    : adg 6666 ;  
22d7			; 
22d7			;    db   1     ; user defined word  
22d7 23				inc hl    
22d8			;    dw   sysdict 
22d8 23				inc hl 
22d9 23				inc hl 
22da			;    db <word len>+1 (for null) 
22da 23				inc hl 
22db			;    db .... <word> 
22db			; 
22db			 
22db 23				inc hl    ; some extras for the word preamble before the above 
22dc 23				inc hl 
22dd 23				inc hl 
22de 23				inc hl 
22df 23				inc hl 
22e0 23				inc hl 
22e1 23				inc hl  
22e2 23				inc hl 
22e3 23				inc hl 
22e4 23				inc hl 
22e5 23				inc hl 
22e6 23				inc hl 
22e7 23				inc hl 
22e8 23				inc hl     ; TODO how many do we really need?     maybe only 6 
22e9			;       exec word buffer 
22e9			;	<ptr word>   
22e9 23				inc hl 
22ea 23				inc hl 
22eb			;       <word list><null term> 7F final term 
22eb			 
22eb			 
22eb			if DEBUG_FORTH_UWORD 
22eb						DMARK ":02" 
22eb f5				push af  
22ec 3a 00 23			ld a, (.dmark)  
22ef 32 6b ee			ld (debug_mark),a  
22f2 3a 01 23			ld a, (.dmark+1)  
22f5 32 6c ee			ld (debug_mark+1),a  
22f8 3a 02 23			ld a, (.dmark+2)  
22fb 32 6d ee			ld (debug_mark+2),a  
22fe 18 03			jr .pastdmark  
2300 ..			.dmark: db ":02"  
2303 f1			.pastdmark: pop af  
2304			endm  
# End of macro DMARK
2304				CALLMONITOR 
2304 cd 6f ee			call debug_vector  
2307				endm  
# End of macro CALLMONITOR
2307			endif 
2307			 
2307				 
2307					; malloc the size 
2307			 
2307 cd ae 12				call malloc 
230a 22 bf e2				ld (os_new_malloc), hl     ; save malloc start 
230d			 
230d			;    db   1     ; user defined word  
230d 3e 01				ld a, WORD_SYS_UWORD  
230f 77					ld (hl), a 
2310				 
2310 23				inc hl    
2311			;    dw   sysdict 
2311 11 5b 21			ld de, sysdict       ; continue on with the scan to the system dict 
2314 73				ld (hl), e 
2315 23				inc hl 
2316 72				ld (hl), d 
2317 23				inc hl 
2318			 
2318			 
2318			;    Setup dict word 
2318			 
2318 23				inc hl 
2319 22 b9 e2			ld (os_new_work_ptr), hl     ; save start of dict word  
231c			 
231c				; 1. get length of dict word 
231c			 
231c			 
231c 2a c2 e5			ld hl, (os_tok_ptr) 
231f 23				inc hl 
2320 23				inc hl    ; position to start of dict word 
2321 3e 00			ld a, 0 
2323 cd 50 12			call strlent 
2326			 
2326			 
2326 23				inc hl    ; to include null??? 
2327			 
2327				; write length of dict word 
2327			 
2327 ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
232b 1b				dec de 
232c eb				ex de, hl 
232d 73				ld (hl), e 
232e eb				ex de, hl 
232f			 
232f				 
232f			 
232f				; copy  
232f 4d				ld c, l 
2330 06 00			ld b, 0 
2332 ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2336 2a c2 e5			ld hl, (os_tok_ptr) 
2339 23				inc hl 
233a 23				inc hl    ; position to start of dict word 
233b				 
233b			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
233b				 
233b				; TODO need to convert word to upper case 
233b			 
233b			ucasetok:	 
233b 7e				ld a,(hl) 
233c cd 3c 12			call toUpper 
233f 77				ld (hl),a 
2340 ed a0			ldi 
2342 f2 3b 23		 	jp p, ucasetok 
2345			 
2345			 
2345			 
2345				; de now points to start of where the word body code should be placed 
2345 ed 53 b9 e2		ld (os_new_work_ptr), de 
2349				; hl now points to the words to throw at forthexec which needs to be copied 
2349 22 b7 e2			ld (os_new_src_ptr), hl 
234c			 
234c				; TODO add 'call to forthexec' 
234c			 
234c			if DEBUG_FORTH_UWORD 
234c c5				push bc 
234d ed 4b bf e2		ld bc, (os_new_malloc) 
2351						DMARK ":0x" 
2351 f5				push af  
2352 3a 66 23			ld a, (.dmark)  
2355 32 6b ee			ld (debug_mark),a  
2358 3a 67 23			ld a, (.dmark+1)  
235b 32 6c ee			ld (debug_mark+1),a  
235e 3a 68 23			ld a, (.dmark+2)  
2361 32 6d ee			ld (debug_mark+2),a  
2364 18 03			jr .pastdmark  
2366 ..			.dmark: db ":0x"  
2369 f1			.pastdmark: pop af  
236a			endm  
# End of macro DMARK
236a				CALLMONITOR 
236a cd 6f ee			call debug_vector  
236d				endm  
# End of macro CALLMONITOR
236d c1				pop bc 
236e			endif 
236e			 
236e			 
236e				; create word preamble which should be: 
236e			 
236e			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
236e			 
236e				;    ld hl, <word code> 
236e				;    jp user_exec 
236e			        ;    <word code bytes> 
236e			 
236e			 
236e			;	inc de     ; TODO ??? or are we already past the word's null 
236e eb				ex de, hl 
236f			 
236f 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2371			 
2371 23				inc hl 
2372 22 b3 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2375 23				inc hl 
2376			 
2376 23				inc hl 
2377 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2379			 
2379 01 10 4c			ld bc, user_exec 
237c 23				inc hl 
237d 71				ld (hl), c     ; poke address of user_exec 
237e 23				inc hl 
237f 70				ld (hl), b     
2380			 ; 
2380			;	inc hl 
2380			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2380			; 
2380			; 
2380			;	ld bc, macro_forth_rsp_next 
2380			;	inc hl 
2380			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2380			;	inc hl 
2380			;	ld (hl), b     
2380			 ; 
2380			;	inc hl 
2380			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2380			; 
2380			; 
2380			;	inc hl 
2380			;	ld bc, forthexec 
2380			;	ld (hl), c     ; poke address of forthexec 
2380			;	inc hl 
2380			;	ld (hl), b      
2380			; 
2380			;	inc hl 
2380			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2380			; 
2380			;	ld bc, user_dict_next 
2380			;	inc hl 
2380			;	ld (hl), c     ; poke address of forthexec 
2380			;	inc hl 
2380			;	ld (hl), b      
2380			 
2380				; hl is now where we need to copy the word byte data to save this 
2380			 
2380 23				inc hl 
2381 22 b5 e2			ld (os_new_exec), hl 
2384				 
2384				; copy definition 
2384			 
2384 eb				ex de, hl 
2385			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2385			;	inc de    ; skip the PC for this parse 
2385 3a bd e2			ld a, (os_new_parse_len) 
2388 4f				ld c, a 
2389 06 00			ld b, 0 
238b ed b0			ldir		 ; copy defintion 
238d			 
238d			 
238d				; poke the address of where the new word bytes live for forthexec 
238d			 
238d 2a b3 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2390			 
2390 ed 5b b5 e2		ld de, (os_new_exec)      
2394				 
2394 73				ld (hl), e 
2395 23				inc hl 
2396 72				ld (hl), d 
2397			 
2397					; TODO copy last user dict word next link to this word 
2397					; TODO update last user dict word to point to this word 
2397			; 
2397			; hl f923 de 812a ; bc 811a 
2397			 
2397			if DEBUG_FORTH_UWORD 
2397 c5				push bc 
2398 ed 4b bf e2		ld bc, (os_new_malloc) 
239c						DMARK ":0A" 
239c f5				push af  
239d 3a b1 23			ld a, (.dmark)  
23a0 32 6b ee			ld (debug_mark),a  
23a3 3a b2 23			ld a, (.dmark+1)  
23a6 32 6c ee			ld (debug_mark+1),a  
23a9 3a b3 23			ld a, (.dmark+2)  
23ac 32 6d ee			ld (debug_mark+2),a  
23af 18 03			jr .pastdmark  
23b1 ..			.dmark: db ":0A"  
23b4 f1			.pastdmark: pop af  
23b5			endm  
# End of macro DMARK
23b5				CALLMONITOR 
23b5 cd 6f ee			call debug_vector  
23b8				endm  
# End of macro CALLMONITOR
23b8 c1				pop bc 
23b9			endif 
23b9			if DEBUG_FORTH_UWORD 
23b9 c5				push bc 
23ba ed 4b bf e2		ld bc, (os_new_malloc) 
23be 03				inc bc 
23bf 03				inc bc 
23c0 03				inc bc 
23c1 03				inc bc 
23c2 03				inc bc 
23c3 03				inc bc 
23c4 03				inc bc 
23c5 03				inc bc 
23c6			 
23c6						DMARK ":0B" 
23c6 f5				push af  
23c7 3a db 23			ld a, (.dmark)  
23ca 32 6b ee			ld (debug_mark),a  
23cd 3a dc 23			ld a, (.dmark+1)  
23d0 32 6c ee			ld (debug_mark+1),a  
23d3 3a dd 23			ld a, (.dmark+2)  
23d6 32 6d ee			ld (debug_mark+2),a  
23d9 18 03			jr .pastdmark  
23db ..			.dmark: db ":0B"  
23de f1			.pastdmark: pop af  
23df			endm  
# End of macro DMARK
23df				CALLMONITOR 
23df cd 6f ee			call debug_vector  
23e2				endm  
# End of macro CALLMONITOR
23e2 c1				pop bc 
23e3			endif 
23e3			 
23e3			; update word dict linked list for new word 
23e3			 
23e3			 
23e3 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
23e6 23			inc hl     ; move to next work linked list ptr 
23e7			 
23e7 ed 5b bf e2	ld de, (os_new_malloc)		 ; new next word 
23eb 73			ld (hl), e 
23ec 23			inc hl 
23ed 72			ld (hl), d 
23ee			 
23ee			if DEBUG_FORTH_UWORD 
23ee ed 4b be e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
23f2			endif 
23f2			 
23f2 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
23f6			 
23f6			 
23f6			if DEBUG_FORTH_UWORD 
23f6						DMARK ":0+" 
23f6 f5				push af  
23f7 3a 0b 24			ld a, (.dmark)  
23fa 32 6b ee			ld (debug_mark),a  
23fd 3a 0c 24			ld a, (.dmark+1)  
2400 32 6c ee			ld (debug_mark+1),a  
2403 3a 0d 24			ld a, (.dmark+2)  
2406 32 6d ee			ld (debug_mark+2),a  
2409 18 03			jr .pastdmark  
240b ..			.dmark: db ":0+"  
240e f1			.pastdmark: pop af  
240f			endm  
# End of macro DMARK
240f				CALLMONITOR 
240f cd 6f ee			call debug_vector  
2412				endm  
# End of macro CALLMONITOR
2412			endif 
2412			 
2412				STACKFRAMECHK OFF $8efe $989f 
2412				if DEBUG_STACK_IMB 
2412					if OFF 
2412						exx 
2412						ld hl, $989f 
2412						pop de   ; $989f 
2412						call cmp16 
2412						jr nz, .spnosame 
2412						ld hl, $8efe 
2412						pop de   ; $8efe 
2412						call cmp16 
2412						jr z, .spfrsame 
2412						.spnosame: call showsperror 
2412						.spfrsame: nop 
2412						exx 
2412					endif 
2412				endif 
2412			endm 
# End of macro STACKFRAMECHK
2412			 
2412 c9			ret    ; dont process any remaining parser tokens as they form new word 
2413			 
2413			 
2413			 
2413			 
2413			;		NEXT 
2413			.SCOLN: 
2413			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2413 06				db OPCODE_SCOLN 
2414 5f 24			dw .DROP 
2416 02				db 2 
2417 .. 00			db ";",0           
2419			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2419					if DEBUG_FORTH_WORDS_KEY 
2419						DMARK "SCN" 
2419 f5				push af  
241a 3a 2e 24			ld a, (.dmark)  
241d 32 6b ee			ld (debug_mark),a  
2420 3a 2f 24			ld a, (.dmark+1)  
2423 32 6c ee			ld (debug_mark+1),a  
2426 3a 30 24			ld a, (.dmark+2)  
2429 32 6d ee			ld (debug_mark+2),a  
242c 18 03			jr .pastdmark  
242e ..			.dmark: db "SCN"  
2431 f1			.pastdmark: pop af  
2432			endm  
# End of macro DMARK
2432						CALLMONITOR 
2432 cd 6f ee			call debug_vector  
2435				endm  
# End of macro CALLMONITOR
2435					endif 
2435					FORTH_RSP_TOS 
2435 cd 14 1c			call macro_forth_rsp_tos 
2438				endm 
# End of macro FORTH_RSP_TOS
2438 e5					push hl 
2439					FORTH_RSP_POP 
2439 cd 1e 1c			call macro_forth_rsp_pop 
243c				endm 
# End of macro FORTH_RSP_POP
243c e1					pop hl 
243d			;		ex de,hl 
243d 22 c2 e5				ld (os_tok_ptr),hl 
2440			 
2440			if DEBUG_FORTH_UWORD 
2440						DMARK "SCL" 
2440 f5				push af  
2441 3a 55 24			ld a, (.dmark)  
2444 32 6b ee			ld (debug_mark),a  
2447 3a 56 24			ld a, (.dmark+1)  
244a 32 6c ee			ld (debug_mark+1),a  
244d 3a 57 24			ld a, (.dmark+2)  
2450 32 6d ee			ld (debug_mark+2),a  
2453 18 03			jr .pastdmark  
2455 ..			.dmark: db "SCL"  
2458 f1			.pastdmark: pop af  
2459			endm  
# End of macro DMARK
2459				CALLMONITOR 
2459 cd 6f ee			call debug_vector  
245c				endm  
# End of macro CALLMONITOR
245c			endif 
245c					NEXTW 
245c c3 03 20			jp macro_next 
245f				endm 
# End of macro NEXTW
245f			 
245f			.DROP: 
245f				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
245f 1b				db WORD_SYS_CORE+OPCODE_DROP             
2460 8a 24			dw .DUP2            
2462 05				db 4 + 1 
2463 .. 00			db "DROP",0              
2468				endm 
# End of macro CWHEAD
2468			; | DROP ( w -- )   drop the TOS item   | DONE 
2468					if DEBUG_FORTH_WORDS_KEY 
2468						DMARK "DRP" 
2468 f5				push af  
2469 3a 7d 24			ld a, (.dmark)  
246c 32 6b ee			ld (debug_mark),a  
246f 3a 7e 24			ld a, (.dmark+1)  
2472 32 6c ee			ld (debug_mark+1),a  
2475 3a 7f 24			ld a, (.dmark+2)  
2478 32 6d ee			ld (debug_mark+2),a  
247b 18 03			jr .pastdmark  
247d ..			.dmark: db "DRP"  
2480 f1			.pastdmark: pop af  
2481			endm  
# End of macro DMARK
2481						CALLMONITOR 
2481 cd 6f ee			call debug_vector  
2484				endm  
# End of macro CALLMONITOR
2484					endif 
2484					FORTH_DSP_POP 
2484 cd 05 1f			call macro_forth_dsp_pop 
2487				endm 
# End of macro FORTH_DSP_POP
2487					NEXTW 
2487 c3 03 20			jp macro_next 
248a				endm 
# End of macro NEXTW
248a			.DUP2: 
248a				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
248a 1c				db WORD_SYS_CORE+OPCODE_DUP2             
248b cf 24			dw .DROP2            
248d 05				db 4 + 1 
248e .. 00			db "2DUP",0              
2493				endm 
# End of macro CWHEAD
2493			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2493					if DEBUG_FORTH_WORDS_KEY 
2493						DMARK "2DU" 
2493 f5				push af  
2494 3a a8 24			ld a, (.dmark)  
2497 32 6b ee			ld (debug_mark),a  
249a 3a a9 24			ld a, (.dmark+1)  
249d 32 6c ee			ld (debug_mark+1),a  
24a0 3a aa 24			ld a, (.dmark+2)  
24a3 32 6d ee			ld (debug_mark+2),a  
24a6 18 03			jr .pastdmark  
24a8 ..			.dmark: db "2DU"  
24ab f1			.pastdmark: pop af  
24ac			endm  
# End of macro DMARK
24ac						CALLMONITOR 
24ac cd 6f ee			call debug_vector  
24af				endm  
# End of macro CALLMONITOR
24af					endif 
24af					FORTH_DSP_VALUEHL 
24af cd 4d 1e			call macro_dsp_valuehl 
24b2				endm 
# End of macro FORTH_DSP_VALUEHL
24b2 e5					push hl      ; 2 
24b3			 
24b3					FORTH_DSP_POP 
24b3 cd 05 1f			call macro_forth_dsp_pop 
24b6				endm 
# End of macro FORTH_DSP_POP
24b6					 
24b6					FORTH_DSP_VALUEHL 
24b6 cd 4d 1e			call macro_dsp_valuehl 
24b9				endm 
# End of macro FORTH_DSP_VALUEHL
24b9			;		push hl      ; 1 
24b9			 
24b9					FORTH_DSP_POP 
24b9 cd 05 1f			call macro_forth_dsp_pop 
24bc				endm 
# End of macro FORTH_DSP_POP
24bc			 
24bc			;		pop hl       ; 1 
24bc d1					pop de       ; 2 
24bd			 
24bd cd 56 1c				call forth_push_numhl 
24c0 eb					ex de, hl 
24c1 cd 56 1c				call forth_push_numhl 
24c4			 
24c4					 
24c4 eb					ex de, hl 
24c5			 
24c5 cd 56 1c				call forth_push_numhl 
24c8 eb					ex de, hl 
24c9 cd 56 1c				call forth_push_numhl 
24cc			 
24cc			 
24cc					NEXTW 
24cc c3 03 20			jp macro_next 
24cf				endm 
# End of macro NEXTW
24cf			.DROP2: 
24cf				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24cf 1d				db WORD_SYS_CORE+OPCODE_DROP2             
24d0 fe 24			dw .SWAP2            
24d2 06				db 5 + 1 
24d3 .. 00			db "2DROP",0              
24d9				endm 
# End of macro CWHEAD
24d9			; | 2DROP ( w w -- )    Double drop | DONE 
24d9					if DEBUG_FORTH_WORDS_KEY 
24d9						DMARK "2DR" 
24d9 f5				push af  
24da 3a ee 24			ld a, (.dmark)  
24dd 32 6b ee			ld (debug_mark),a  
24e0 3a ef 24			ld a, (.dmark+1)  
24e3 32 6c ee			ld (debug_mark+1),a  
24e6 3a f0 24			ld a, (.dmark+2)  
24e9 32 6d ee			ld (debug_mark+2),a  
24ec 18 03			jr .pastdmark  
24ee ..			.dmark: db "2DR"  
24f1 f1			.pastdmark: pop af  
24f2			endm  
# End of macro DMARK
24f2						CALLMONITOR 
24f2 cd 6f ee			call debug_vector  
24f5				endm  
# End of macro CALLMONITOR
24f5					endif 
24f5					FORTH_DSP_POP 
24f5 cd 05 1f			call macro_forth_dsp_pop 
24f8				endm 
# End of macro FORTH_DSP_POP
24f8					FORTH_DSP_POP 
24f8 cd 05 1f			call macro_forth_dsp_pop 
24fb				endm 
# End of macro FORTH_DSP_POP
24fb					NEXTW 
24fb c3 03 20			jp macro_next 
24fe				endm 
# End of macro NEXTW
24fe			.SWAP2: 
24fe				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
24fe 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
24ff 27 25			dw .AT            
2501 06				db 5 + 1 
2502 .. 00			db "2SWAP",0              
2508				endm 
# End of macro CWHEAD
2508			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2508					if DEBUG_FORTH_WORDS_KEY 
2508						DMARK "2SW" 
2508 f5				push af  
2509 3a 1d 25			ld a, (.dmark)  
250c 32 6b ee			ld (debug_mark),a  
250f 3a 1e 25			ld a, (.dmark+1)  
2512 32 6c ee			ld (debug_mark+1),a  
2515 3a 1f 25			ld a, (.dmark+2)  
2518 32 6d ee			ld (debug_mark+2),a  
251b 18 03			jr .pastdmark  
251d ..			.dmark: db "2SW"  
2520 f1			.pastdmark: pop af  
2521			endm  
# End of macro DMARK
2521						CALLMONITOR 
2521 cd 6f ee			call debug_vector  
2524				endm  
# End of macro CALLMONITOR
2524					endif 
2524					NEXTW 
2524 c3 03 20			jp macro_next 
2527				endm 
# End of macro NEXTW
2527			.AT: 
2527				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2527 1f				db WORD_SYS_CORE+OPCODE_AT             
2528 59 25			dw .CAT            
252a 02				db 1 + 1 
252b .. 00			db "@",0              
252d				endm 
# End of macro CWHEAD
252d			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
252d			 
252d					if DEBUG_FORTH_WORDS_KEY 
252d						DMARK "AT." 
252d f5				push af  
252e 3a 42 25			ld a, (.dmark)  
2531 32 6b ee			ld (debug_mark),a  
2534 3a 43 25			ld a, (.dmark+1)  
2537 32 6c ee			ld (debug_mark+1),a  
253a 3a 44 25			ld a, (.dmark+2)  
253d 32 6d ee			ld (debug_mark+2),a  
2540 18 03			jr .pastdmark  
2542 ..			.dmark: db "AT."  
2545 f1			.pastdmark: pop af  
2546			endm  
# End of macro DMARK
2546						CALLMONITOR 
2546 cd 6f ee			call debug_vector  
2549				endm  
# End of macro CALLMONITOR
2549					endif 
2549			.getbyteat:	 
2549					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2549 cd 4d 1e			call macro_dsp_valuehl 
254c				endm 
# End of macro FORTH_DSP_VALUEHL
254c					 
254c			;		push hl 
254c				 
254c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
254c cd 05 1f			call macro_forth_dsp_pop 
254f				endm 
# End of macro FORTH_DSP_POP
254f			 
254f			;		pop hl 
254f			 
254f 7e					ld a, (hl) 
2550			 
2550 6f					ld l, a 
2551 26 00				ld h, 0 
2553 cd 56 1c				call forth_push_numhl 
2556			 
2556					NEXTW 
2556 c3 03 20			jp macro_next 
2559				endm 
# End of macro NEXTW
2559			.CAT: 
2559				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2559 20				db WORD_SYS_CORE+OPCODE_CAT             
255a 82 25			dw .BANG            
255c 03				db 2 + 1 
255d .. 00			db "C@",0              
2560				endm 
# End of macro CWHEAD
2560			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2560					if DEBUG_FORTH_WORDS_KEY 
2560						DMARK "CAA" 
2560 f5				push af  
2561 3a 75 25			ld a, (.dmark)  
2564 32 6b ee			ld (debug_mark),a  
2567 3a 76 25			ld a, (.dmark+1)  
256a 32 6c ee			ld (debug_mark+1),a  
256d 3a 77 25			ld a, (.dmark+2)  
2570 32 6d ee			ld (debug_mark+2),a  
2573 18 03			jr .pastdmark  
2575 ..			.dmark: db "CAA"  
2578 f1			.pastdmark: pop af  
2579			endm  
# End of macro DMARK
2579						CALLMONITOR 
2579 cd 6f ee			call debug_vector  
257c				endm  
# End of macro CALLMONITOR
257c					endif 
257c c3 49 25				jp .getbyteat 
257f					NEXTW 
257f c3 03 20			jp macro_next 
2582				endm 
# End of macro NEXTW
2582			.BANG: 
2582				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2582 21				db WORD_SYS_CORE+OPCODE_BANG             
2583 b8 25			dw .CBANG            
2585 02				db 1 + 1 
2586 .. 00			db "!",0              
2588				endm 
# End of macro CWHEAD
2588			; | ! ( x w -- ) Store x at address w      | DONE 
2588					if DEBUG_FORTH_WORDS_KEY 
2588						DMARK "BNG" 
2588 f5				push af  
2589 3a 9d 25			ld a, (.dmark)  
258c 32 6b ee			ld (debug_mark),a  
258f 3a 9e 25			ld a, (.dmark+1)  
2592 32 6c ee			ld (debug_mark+1),a  
2595 3a 9f 25			ld a, (.dmark+2)  
2598 32 6d ee			ld (debug_mark+2),a  
259b 18 03			jr .pastdmark  
259d ..			.dmark: db "BNG"  
25a0 f1			.pastdmark: pop af  
25a1			endm  
# End of macro DMARK
25a1						CALLMONITOR 
25a1 cd 6f ee			call debug_vector  
25a4				endm  
# End of macro CALLMONITOR
25a4					endif 
25a4			 
25a4			.storebyteat:		 
25a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25a4 cd 4d 1e			call macro_dsp_valuehl 
25a7				endm 
# End of macro FORTH_DSP_VALUEHL
25a7					 
25a7 e5					push hl 
25a8				 
25a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25a8 cd 05 1f			call macro_forth_dsp_pop 
25ab				endm 
# End of macro FORTH_DSP_POP
25ab			 
25ab					; get byte to poke 
25ab			 
25ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25ab cd 4d 1e			call macro_dsp_valuehl 
25ae				endm 
# End of macro FORTH_DSP_VALUEHL
25ae e5					push hl 
25af			 
25af			 
25af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25af cd 05 1f			call macro_forth_dsp_pop 
25b2				endm 
# End of macro FORTH_DSP_POP
25b2			 
25b2			 
25b2 d1					pop de 
25b3 e1					pop hl 
25b4			 
25b4 73					ld (hl),e 
25b5			 
25b5			 
25b5					NEXTW 
25b5 c3 03 20			jp macro_next 
25b8				endm 
# End of macro NEXTW
25b8			.CBANG: 
25b8				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25b8 22				db WORD_SYS_CORE+OPCODE_CBANG             
25b9 e1 25			dw .SCALL            
25bb 03				db 2 + 1 
25bc .. 00			db "C!",0              
25bf				endm 
# End of macro CWHEAD
25bf			; | C!  ( x w -- ) Store x at address w  | DONE 
25bf					if DEBUG_FORTH_WORDS_KEY 
25bf						DMARK "CBA" 
25bf f5				push af  
25c0 3a d4 25			ld a, (.dmark)  
25c3 32 6b ee			ld (debug_mark),a  
25c6 3a d5 25			ld a, (.dmark+1)  
25c9 32 6c ee			ld (debug_mark+1),a  
25cc 3a d6 25			ld a, (.dmark+2)  
25cf 32 6d ee			ld (debug_mark+2),a  
25d2 18 03			jr .pastdmark  
25d4 ..			.dmark: db "CBA"  
25d7 f1			.pastdmark: pop af  
25d8			endm  
# End of macro DMARK
25d8						CALLMONITOR 
25d8 cd 6f ee			call debug_vector  
25db				endm  
# End of macro CALLMONITOR
25db					endif 
25db c3 a4 25				jp .storebyteat 
25de					NEXTW 
25de c3 03 20			jp macro_next 
25e1				endm 
# End of macro NEXTW
25e1			.SCALL: 
25e1				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25e1 23				db WORD_SYS_CORE+OPCODE_SCALL             
25e2 15 26			dw .DEPTH            
25e4 05				db 4 + 1 
25e5 .. 00			db "CALL",0              
25ea				endm 
# End of macro CWHEAD
25ea			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
25ea					if DEBUG_FORTH_WORDS_KEY 
25ea						DMARK "CLL" 
25ea f5				push af  
25eb 3a ff 25			ld a, (.dmark)  
25ee 32 6b ee			ld (debug_mark),a  
25f1 3a 00 26			ld a, (.dmark+1)  
25f4 32 6c ee			ld (debug_mark+1),a  
25f7 3a 01 26			ld a, (.dmark+2)  
25fa 32 6d ee			ld (debug_mark+2),a  
25fd 18 03			jr .pastdmark  
25ff ..			.dmark: db "CLL"  
2602 f1			.pastdmark: pop af  
2603			endm  
# End of macro DMARK
2603						CALLMONITOR 
2603 cd 6f ee			call debug_vector  
2606				endm  
# End of macro CALLMONITOR
2606					endif 
2606			 
2606					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2606 cd 4d 1e			call macro_dsp_valuehl 
2609				endm 
# End of macro FORTH_DSP_VALUEHL
2609			 
2609			;		push hl 
2609			 
2609					; destroy value TOS 
2609			 
2609					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2609 cd 05 1f			call macro_forth_dsp_pop 
260c				endm 
# End of macro FORTH_DSP_POP
260c			 
260c						 
260c			;		pop hl 
260c			 
260c					; how to do a call with hl???? save SP? 
260c cd a7 1f				call forth_call_hl 
260f			 
260f			 
260f					; TODO push value back onto stack for another op etc 
260f			 
260f cd 56 1c				call forth_push_numhl 
2612					NEXTW 
2612 c3 03 20			jp macro_next 
2615				endm 
# End of macro NEXTW
2615			.DEPTH: 
2615				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2615 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2616 52 26			dw .OVER            
2618 06				db 5 + 1 
2619 .. 00			db "DEPTH",0              
261f				endm 
# End of macro CWHEAD
261f			; | DEPTH ( -- u ) Push count of stack | DONE 
261f					; take current TOS and remove from base value div by two to get count 
261f					if DEBUG_FORTH_WORDS_KEY 
261f						DMARK "DEP" 
261f f5				push af  
2620 3a 34 26			ld a, (.dmark)  
2623 32 6b ee			ld (debug_mark),a  
2626 3a 35 26			ld a, (.dmark+1)  
2629 32 6c ee			ld (debug_mark+1),a  
262c 3a 36 26			ld a, (.dmark+2)  
262f 32 6d ee			ld (debug_mark+2),a  
2632 18 03			jr .pastdmark  
2634 ..			.dmark: db "DEP"  
2637 f1			.pastdmark: pop af  
2638			endm  
# End of macro DMARK
2638						CALLMONITOR 
2638 cd 6f ee			call debug_vector  
263b				endm  
# End of macro CALLMONITOR
263b					endif 
263b			 
263b			 
263b 2a ee e9			ld hl, (cli_data_sp) 
263e 11 28 e8			ld de, cli_data_stack 
2641 ed 52			sbc hl,de 
2643				 
2643				; div by size of stack item 
2643			 
2643 5d				ld e,l 
2644 0e 03			ld c, 3 
2646 cd 77 0d			call Div8 
2649			 
2649 6f				ld l,a 
264a 26 00			ld h,0 
264c			 
264c				;srl h 
264c				;rr l 
264c			 
264c cd 56 1c				call forth_push_numhl 
264f					NEXTW 
264f c3 03 20			jp macro_next 
2652				endm 
# End of macro NEXTW
2652			.OVER: 
2652				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2652 42				db WORD_SYS_CORE+46             
2653 99 26			dw .PAUSE            
2655 05				db 4 + 1 
2656 .. 00			db "OVER",0              
265b				endm 
# End of macro CWHEAD
265b			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
265b					if DEBUG_FORTH_WORDS_KEY 
265b						DMARK "OVR" 
265b f5				push af  
265c 3a 70 26			ld a, (.dmark)  
265f 32 6b ee			ld (debug_mark),a  
2662 3a 71 26			ld a, (.dmark+1)  
2665 32 6c ee			ld (debug_mark+1),a  
2668 3a 72 26			ld a, (.dmark+2)  
266b 32 6d ee			ld (debug_mark+2),a  
266e 18 03			jr .pastdmark  
2670 ..			.dmark: db "OVR"  
2673 f1			.pastdmark: pop af  
2674			endm  
# End of macro DMARK
2674						CALLMONITOR 
2674 cd 6f ee			call debug_vector  
2677				endm  
# End of macro CALLMONITOR
2677					endif 
2677			 
2677					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2677 cd 4d 1e			call macro_dsp_valuehl 
267a				endm 
# End of macro FORTH_DSP_VALUEHL
267a e5					push hl    ; n2 
267b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
267b cd 05 1f			call macro_forth_dsp_pop 
267e				endm 
# End of macro FORTH_DSP_POP
267e			 
267e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
267e cd 4d 1e			call macro_dsp_valuehl 
2681				endm 
# End of macro FORTH_DSP_VALUEHL
2681 e5					push hl    ; n1 
2682					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2682 cd 05 1f			call macro_forth_dsp_pop 
2685				endm 
# End of macro FORTH_DSP_POP
2685			 
2685 d1					pop de     ; n1 
2686 e1					pop hl     ; n2 
2687			 
2687 d5					push de 
2688 e5					push hl 
2689 d5					push de 
268a			 
268a					; push back  
268a			 
268a e1					pop hl 
268b cd 56 1c				call forth_push_numhl 
268e e1					pop hl 
268f cd 56 1c				call forth_push_numhl 
2692 e1					pop hl 
2693 cd 56 1c				call forth_push_numhl 
2696					NEXTW 
2696 c3 03 20			jp macro_next 
2699				endm 
# End of macro NEXTW
2699			 
2699			.PAUSE: 
2699				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2699 43				db WORD_SYS_CORE+47             
269a ce 26			dw .PAUSES            
269c 08				db 7 + 1 
269d .. 00			db "PAUSEMS",0              
26a5				endm 
# End of macro CWHEAD
26a5			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26a5					if DEBUG_FORTH_WORDS_KEY 
26a5						DMARK "PMS" 
26a5 f5				push af  
26a6 3a ba 26			ld a, (.dmark)  
26a9 32 6b ee			ld (debug_mark),a  
26ac 3a bb 26			ld a, (.dmark+1)  
26af 32 6c ee			ld (debug_mark+1),a  
26b2 3a bc 26			ld a, (.dmark+2)  
26b5 32 6d ee			ld (debug_mark+2),a  
26b8 18 03			jr .pastdmark  
26ba ..			.dmark: db "PMS"  
26bd f1			.pastdmark: pop af  
26be			endm  
# End of macro DMARK
26be						CALLMONITOR 
26be cd 6f ee			call debug_vector  
26c1				endm  
# End of macro CALLMONITOR
26c1					endif 
26c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c1 cd 4d 1e			call macro_dsp_valuehl 
26c4				endm 
# End of macro FORTH_DSP_VALUEHL
26c4			;		push hl    ; n2 
26c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c4 cd 05 1f			call macro_forth_dsp_pop 
26c7				endm 
# End of macro FORTH_DSP_POP
26c7			;		pop hl 
26c7			 
26c7 7d					ld a, l 
26c8 cd d7 0a				call aDelayInMS 
26cb				       NEXTW 
26cb c3 03 20			jp macro_next 
26ce				endm 
# End of macro NEXTW
26ce			.PAUSES:  
26ce				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
26ce 44				db WORD_SYS_CORE+48             
26cf 3d 27			dw .ROT            
26d1 06				db 5 + 1 
26d2 .. 00			db "PAUSE",0              
26d8				endm 
# End of macro CWHEAD
26d8			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26d8					if DEBUG_FORTH_WORDS_KEY 
26d8						DMARK "PAU" 
26d8 f5				push af  
26d9 3a ed 26			ld a, (.dmark)  
26dc 32 6b ee			ld (debug_mark),a  
26df 3a ee 26			ld a, (.dmark+1)  
26e2 32 6c ee			ld (debug_mark+1),a  
26e5 3a ef 26			ld a, (.dmark+2)  
26e8 32 6d ee			ld (debug_mark+2),a  
26eb 18 03			jr .pastdmark  
26ed ..			.dmark: db "PAU"  
26f0 f1			.pastdmark: pop af  
26f1			endm  
# End of macro DMARK
26f1						CALLMONITOR 
26f1 cd 6f ee			call debug_vector  
26f4				endm  
# End of macro CALLMONITOR
26f4					endif 
26f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26f4 cd 4d 1e			call macro_dsp_valuehl 
26f7				endm 
# End of macro FORTH_DSP_VALUEHL
26f7			;		push hl    ; n2 
26f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26f7 cd 05 1f			call macro_forth_dsp_pop 
26fa				endm 
# End of macro FORTH_DSP_POP
26fa			;		pop hl 
26fa 45					ld b, l 
26fb					if DEBUG_FORTH_WORDS 
26fb						DMARK "PAU" 
26fb f5				push af  
26fc 3a 10 27			ld a, (.dmark)  
26ff 32 6b ee			ld (debug_mark),a  
2702 3a 11 27			ld a, (.dmark+1)  
2705 32 6c ee			ld (debug_mark+1),a  
2708 3a 12 27			ld a, (.dmark+2)  
270b 32 6d ee			ld (debug_mark+2),a  
270e 18 03			jr .pastdmark  
2710 ..			.dmark: db "PAU"  
2713 f1			.pastdmark: pop af  
2714			endm  
# End of macro DMARK
2714						CALLMONITOR 
2714 cd 6f ee			call debug_vector  
2717				endm  
# End of macro CALLMONITOR
2717					endif 
2717 c5			.pauses1:	push bc 
2718 cd f2 0a				call delay1s 
271b c1					pop bc 
271c					if DEBUG_FORTH_WORDS 
271c						DMARK "PA1" 
271c f5				push af  
271d 3a 31 27			ld a, (.dmark)  
2720 32 6b ee			ld (debug_mark),a  
2723 3a 32 27			ld a, (.dmark+1)  
2726 32 6c ee			ld (debug_mark+1),a  
2729 3a 33 27			ld a, (.dmark+2)  
272c 32 6d ee			ld (debug_mark+2),a  
272f 18 03			jr .pastdmark  
2731 ..			.dmark: db "PA1"  
2734 f1			.pastdmark: pop af  
2735			endm  
# End of macro DMARK
2735						CALLMONITOR 
2735 cd 6f ee			call debug_vector  
2738				endm  
# End of macro CALLMONITOR
2738					endif 
2738 10 dd				djnz .pauses1 
273a			 
273a				       NEXTW 
273a c3 03 20			jp macro_next 
273d				endm 
# End of macro NEXTW
273d			.ROT: 
273d				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
273d 45				db WORD_SYS_CORE+49             
273e 8b 27			dw .UWORDS            
2740 04				db 3 + 1 
2741 .. 00			db "ROT",0              
2745				endm 
# End of macro CWHEAD
2745			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2745					if DEBUG_FORTH_WORDS_KEY 
2745						DMARK "ROT" 
2745 f5				push af  
2746 3a 5a 27			ld a, (.dmark)  
2749 32 6b ee			ld (debug_mark),a  
274c 3a 5b 27			ld a, (.dmark+1)  
274f 32 6c ee			ld (debug_mark+1),a  
2752 3a 5c 27			ld a, (.dmark+2)  
2755 32 6d ee			ld (debug_mark+2),a  
2758 18 03			jr .pastdmark  
275a ..			.dmark: db "ROT"  
275d f1			.pastdmark: pop af  
275e			endm  
# End of macro DMARK
275e						CALLMONITOR 
275e cd 6f ee			call debug_vector  
2761				endm  
# End of macro CALLMONITOR
2761					endif 
2761			 
2761					FORTH_DSP_VALUEHL 
2761 cd 4d 1e			call macro_dsp_valuehl 
2764				endm 
# End of macro FORTH_DSP_VALUEHL
2764 e5					push hl    ; u3  
2765			 
2765					FORTH_DSP_POP 
2765 cd 05 1f			call macro_forth_dsp_pop 
2768				endm 
# End of macro FORTH_DSP_POP
2768			   
2768					FORTH_DSP_VALUEHL 
2768 cd 4d 1e			call macro_dsp_valuehl 
276b				endm 
# End of macro FORTH_DSP_VALUEHL
276b e5					push hl     ; u2 
276c			 
276c					FORTH_DSP_POP 
276c cd 05 1f			call macro_forth_dsp_pop 
276f				endm 
# End of macro FORTH_DSP_POP
276f			 
276f					FORTH_DSP_VALUEHL 
276f cd 4d 1e			call macro_dsp_valuehl 
2772				endm 
# End of macro FORTH_DSP_VALUEHL
2772 e5					push hl     ; u1 
2773			 
2773					FORTH_DSP_POP 
2773 cd 05 1f			call macro_forth_dsp_pop 
2776				endm 
# End of macro FORTH_DSP_POP
2776			 
2776 c1					pop bc      ; u1 
2777 e1					pop hl      ; u2 
2778 d1					pop de      ; u3 
2779			 
2779			 
2779 c5					push bc 
277a d5					push de 
277b e5					push hl 
277c			 
277c			 
277c e1					pop hl 
277d cd 56 1c				call forth_push_numhl 
2780			 
2780 e1					pop hl 
2781 cd 56 1c				call forth_push_numhl 
2784			 
2784 e1					pop hl 
2785 cd 56 1c				call forth_push_numhl 
2788					 
2788			 
2788			 
2788			 
2788			 
2788			 
2788				       NEXTW 
2788 c3 03 20			jp macro_next 
278b				endm 
# End of macro NEXTW
278b			 
278b			.UWORDS: 
278b				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
278b 50				db WORD_SYS_CORE+60             
278c 4d 28			dw .BP            
278e 07				db 6 + 1 
278f .. 00			db "UWORDS",0              
2796				endm 
# End of macro CWHEAD
2796			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2796			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2796			; | | Following the count are the individual words. 
2796			; | | 
2796			; | | e.g. UWORDS 
2796			; | | BOX DIRLIST 2 
2796			; | |  
2796			; | | Can be used to save the words to storage via: 
2796			; | | UWORDS $01 DO $01 APPEND LOOP 
2796				if DEBUG_FORTH_WORDS_KEY 
2796					DMARK "UWR" 
2796 f5				push af  
2797 3a ab 27			ld a, (.dmark)  
279a 32 6b ee			ld (debug_mark),a  
279d 3a ac 27			ld a, (.dmark+1)  
27a0 32 6c ee			ld (debug_mark+1),a  
27a3 3a ad 27			ld a, (.dmark+2)  
27a6 32 6d ee			ld (debug_mark+2),a  
27a9 18 03			jr .pastdmark  
27ab ..			.dmark: db "UWR"  
27ae f1			.pastdmark: pop af  
27af			endm  
# End of macro DMARK
27af					CALLMONITOR 
27af cd 6f ee			call debug_vector  
27b2				endm  
# End of macro CALLMONITOR
27b2				endif 
27b2 21 40 65				ld hl, baseram 
27b5					;ld hl, baseusermem 
27b5 01 00 00				ld bc, 0    ; start a counter 
27b8			 
27b8				; skip dict stub 
27b8			 
27b8 cd 54 21				call forth_tok_next 
27bb			 
27bb			 
27bb			; while we have words to look for 
27bb			 
27bb 7e			.douscan:	ld a, (hl)      
27bc				if DEBUG_FORTH_WORDS 
27bc					DMARK "UWs" 
27bc f5				push af  
27bd 3a d1 27			ld a, (.dmark)  
27c0 32 6b ee			ld (debug_mark),a  
27c3 3a d2 27			ld a, (.dmark+1)  
27c6 32 6c ee			ld (debug_mark+1),a  
27c9 3a d3 27			ld a, (.dmark+2)  
27cc 32 6d ee			ld (debug_mark+2),a  
27cf 18 03			jr .pastdmark  
27d1 ..			.dmark: db "UWs"  
27d4 f1			.pastdmark: pop af  
27d5			endm  
# End of macro DMARK
27d5					CALLMONITOR 
27d5 cd 6f ee			call debug_vector  
27d8				endm  
# End of macro CALLMONITOR
27d8				endif 
27d8 fe 00				cp WORD_SYS_END 
27da 28 4d				jr z, .udone 
27dc fe 01				cp WORD_SYS_UWORD 
27de 20 44				jr nz, .nuword 
27e0			 
27e0				if DEBUG_FORTH_WORDS 
27e0					DMARK "UWu" 
27e0 f5				push af  
27e1 3a f5 27			ld a, (.dmark)  
27e4 32 6b ee			ld (debug_mark),a  
27e7 3a f6 27			ld a, (.dmark+1)  
27ea 32 6c ee			ld (debug_mark+1),a  
27ed 3a f7 27			ld a, (.dmark+2)  
27f0 32 6d ee			ld (debug_mark+2),a  
27f3 18 03			jr .pastdmark  
27f5 ..			.dmark: db "UWu"  
27f8 f1			.pastdmark: pop af  
27f9			endm  
# End of macro DMARK
27f9					CALLMONITOR 
27f9 cd 6f ee			call debug_vector  
27fc				endm  
# End of macro CALLMONITOR
27fc				endif 
27fc					; we have a uword so push its name to the stack 
27fc			 
27fc e5				   	push hl  ; save so we can move to next dict block 
27fd			 
27fd					; skip opcode 
27fd 23					inc hl  
27fe					; skip next ptr 
27fe 23					inc hl  
27ff 23					inc hl 
2800					; skip len 
2800 23					inc hl 
2801				if DEBUG_FORTH_WORDS 
2801					DMARK "UWt" 
2801 f5				push af  
2802 3a 16 28			ld a, (.dmark)  
2805 32 6b ee			ld (debug_mark),a  
2808 3a 17 28			ld a, (.dmark+1)  
280b 32 6c ee			ld (debug_mark+1),a  
280e 3a 18 28			ld a, (.dmark+2)  
2811 32 6d ee			ld (debug_mark+2),a  
2814 18 03			jr .pastdmark  
2816 ..			.dmark: db "UWt"  
2819 f1			.pastdmark: pop af  
281a			endm  
# End of macro DMARK
281a					CALLMONITOR 
281a cd 6f ee			call debug_vector  
281d				endm  
# End of macro CALLMONITOR
281d				endif 
281d 03					inc bc 
281e			 
281e c5					push bc 
281f cd c4 1c				call forth_push_str 
2822 c1					pop bc 
2823			 
2823 e1					pop hl 	 
2824			 
2824 cd 54 21		.nuword:	call forth_tok_next 
2827 18 92				jr .douscan  
2829			 
2829			.udone:		 ; push count of uwords found 
2829 c5					push bc 
282a e1					pop hl 
282b			 
282b				if DEBUG_FORTH_WORDS 
282b					DMARK "UWc" 
282b f5				push af  
282c 3a 40 28			ld a, (.dmark)  
282f 32 6b ee			ld (debug_mark),a  
2832 3a 41 28			ld a, (.dmark+1)  
2835 32 6c ee			ld (debug_mark+1),a  
2838 3a 42 28			ld a, (.dmark+2)  
283b 32 6d ee			ld (debug_mark+2),a  
283e 18 03			jr .pastdmark  
2840 ..			.dmark: db "UWc"  
2843 f1			.pastdmark: pop af  
2844			endm  
# End of macro DMARK
2844					CALLMONITOR 
2844 cd 6f ee			call debug_vector  
2847				endm  
# End of macro CALLMONITOR
2847				endif 
2847 cd 56 1c				call forth_push_numhl 
284a			 
284a			 
284a				       NEXTW 
284a c3 03 20			jp macro_next 
284d				endm 
# End of macro NEXTW
284d			 
284d			.BP: 
284d				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
284d 54				db WORD_SYS_CORE+64             
284e 87 28			dw .MONITOR            
2850 03				db 2 + 1 
2851 .. 00			db "BP",0              
2854				endm 
# End of macro CWHEAD
2854			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2854			; | | $00 Will enable the break points within specific code paths 
2854			; | | $01 Will disable break points 
2854			; | |  
2854			; | | By default break points are off. Either the above can be used to enable them 
2854			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2854			; | | and on release of the pressed key a message will be disaplayed to notify 
2854			; | | that break points are enabled. Pressing any key will then continue boot process. 
2854					; get byte count 
2854					if DEBUG_FORTH_WORDS_KEY 
2854						DMARK "BP." 
2854 f5				push af  
2855 3a 69 28			ld a, (.dmark)  
2858 32 6b ee			ld (debug_mark),a  
285b 3a 6a 28			ld a, (.dmark+1)  
285e 32 6c ee			ld (debug_mark+1),a  
2861 3a 6b 28			ld a, (.dmark+2)  
2864 32 6d ee			ld (debug_mark+2),a  
2867 18 03			jr .pastdmark  
2869 ..			.dmark: db "BP."  
286c f1			.pastdmark: pop af  
286d			endm  
# End of macro DMARK
286d						CALLMONITOR 
286d cd 6f ee			call debug_vector  
2870				endm  
# End of macro CALLMONITOR
2870					endif 
2870			 
2870					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2870 cd 4d 1e			call macro_dsp_valuehl 
2873				endm 
# End of macro FORTH_DSP_VALUEHL
2873			 
2873			;		push hl 
2873			 
2873					; destroy value TOS 
2873			 
2873					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2873 cd 05 1f			call macro_forth_dsp_pop 
2876				endm 
# End of macro FORTH_DSP_POP
2876			 
2876			;		pop hl 
2876			 
2876 3e 00				ld a,0 
2878 bd					cp l 
2879 28 06				jr z, .bpset 
287b			;		ld a, '*' 
287b cd e9 15				call bp_off 
287e					NEXTW 
287e c3 03 20			jp macro_next 
2881				endm 
# End of macro NEXTW
2881			 
2881			.bpset:	 
2881					;	ld (os_view_disable), a 
2881 cd dd 15				call bp_on 
2884			 
2884			 
2884					NEXTW 
2884 c3 03 20			jp macro_next 
2887				endm 
# End of macro NEXTW
2887			 
2887			 
2887			.MONITOR: 
2887				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2887 55				db WORD_SYS_CORE+65             
2888 b8 28			dw .MALLOC            
288a 08				db 7 + 1 
288b .. 00			db "MONITOR",0              
2893				endm 
# End of macro CWHEAD
2893			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2893			; | | At start the current various registers will be displayed with contents. 
2893			; | | Top right corner will show the most recent debug marker seen. 
2893			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2893			; | | and the return stack pointer (RSP). 
2893			; | | Pressing: 
2893			; | |    1 - Initial screen 
2893			; | |    2 - Display a data dump of HL 
2893			; | |    3 - Display a data dump of DE 
2893			; | |    4 - Display a data dump of BC 
2893			; | |    5 - Display a data dump of HL 
2893			; | |    6 - Display a data dump of DSP 
2893			; | |    7 - Display a data dump of RSP 
2893			; | |    8 - Display a data dump of what is at DSP 
2893			; | |    9 - Display a data dump of what is at RSP 
2893			; | |    0 - Exit monitor and continue running. This will also enable break points 
2893			; | |    * - Disable break points 
2893			; | |    # - Enter traditional monitor mode 
2893			; | | 
2893			; | | Monitor Mode 
2893			; | | ------------ 
2893			; | | A prompt of '>' will be shown for various commands: 
2893			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2893			; | |    C - Continue display a data dump from the last set address 
2893			; | |    M xxxx - Set start of memory edit at address xx 
2893			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2893			; | |    Q - Return to previous 
2893					if DEBUG_FORTH_WORDS_KEY 
2893						DMARK "MON" 
2893 f5				push af  
2894 3a a8 28			ld a, (.dmark)  
2897 32 6b ee			ld (debug_mark),a  
289a 3a a9 28			ld a, (.dmark+1)  
289d 32 6c ee			ld (debug_mark+1),a  
28a0 3a aa 28			ld a, (.dmark+2)  
28a3 32 6d ee			ld (debug_mark+2),a  
28a6 18 03			jr .pastdmark  
28a8 ..			.dmark: db "MON"  
28ab f1			.pastdmark: pop af  
28ac			endm  
# End of macro DMARK
28ac						CALLMONITOR 
28ac cd 6f ee			call debug_vector  
28af				endm  
# End of macro CALLMONITOR
28af					endif 
28af			;		ld a, 0 
28af			;		ld (os_view_disable), a 
28af cd dd 15				call bp_on 
28b2			 
28b2					CALLMONITOR 
28b2 cd 6f ee			call debug_vector  
28b5				endm  
# End of macro CALLMONITOR
28b5			 
28b5			;	call monitor 
28b5			 
28b5					NEXTW 
28b5 c3 03 20			jp macro_next 
28b8				endm 
# End of macro NEXTW
28b8			 
28b8			 
28b8			.MALLOC: 
28b8				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28b8 56				db WORD_SYS_CORE+66             
28b9 e1 28			dw .MALLOC2            
28bb 06				db 5 + 1 
28bc .. 00			db "ALLOT",0              
28c2				endm 
# End of macro CWHEAD
28c2			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28c2					if DEBUG_FORTH_WORDS_KEY 
28c2						DMARK "ALL" 
28c2 f5				push af  
28c3 3a d7 28			ld a, (.dmark)  
28c6 32 6b ee			ld (debug_mark),a  
28c9 3a d8 28			ld a, (.dmark+1)  
28cc 32 6c ee			ld (debug_mark+1),a  
28cf 3a d9 28			ld a, (.dmark+2)  
28d2 32 6d ee			ld (debug_mark+2),a  
28d5 18 03			jr .pastdmark  
28d7 ..			.dmark: db "ALL"  
28da f1			.pastdmark: pop af  
28db			endm  
# End of macro DMARK
28db						CALLMONITOR 
28db cd 6f ee			call debug_vector  
28de				endm  
# End of macro CALLMONITOR
28de					endif 
28de c3 08 29				jp .mallocc 
28e1			.MALLOC2: 
28e1				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28e1 56				db WORD_SYS_CORE+66             
28e2 1f 29			dw .FREE            
28e4 07				db 6 + 1 
28e5 .. 00			db "MALLOC",0              
28ec				endm 
# End of macro CWHEAD
28ec			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28ec					; get byte count 
28ec					if DEBUG_FORTH_WORDS_KEY 
28ec						DMARK "MAL" 
28ec f5				push af  
28ed 3a 01 29			ld a, (.dmark)  
28f0 32 6b ee			ld (debug_mark),a  
28f3 3a 02 29			ld a, (.dmark+1)  
28f6 32 6c ee			ld (debug_mark+1),a  
28f9 3a 03 29			ld a, (.dmark+2)  
28fc 32 6d ee			ld (debug_mark+2),a  
28ff 18 03			jr .pastdmark  
2901 ..			.dmark: db "MAL"  
2904 f1			.pastdmark: pop af  
2905			endm  
# End of macro DMARK
2905						CALLMONITOR 
2905 cd 6f ee			call debug_vector  
2908				endm  
# End of macro CALLMONITOR
2908					endif 
2908			.mallocc: 
2908					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2908 cd 4d 1e			call macro_dsp_valuehl 
290b				endm 
# End of macro FORTH_DSP_VALUEHL
290b			 
290b			;		push hl 
290b			 
290b					; destroy value TOS 
290b			 
290b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
290b cd 05 1f			call macro_forth_dsp_pop 
290e				endm 
# End of macro FORTH_DSP_POP
290e			 
290e			;		pop hl 
290e cd ae 12				call malloc 
2911				if DEBUG_FORTH_MALLOC_GUARD 
2911 f5					push af 
2912 cd 10 0e				call ishlzero 
2915			;		ld a, l 
2915			;		add h 
2915			;		cp 0 
2915 f1					pop af 
2916					 
2916 cc e2 4c				call z,malloc_error 
2919				endif 
2919			 
2919 cd 56 1c				call forth_push_numhl 
291c					NEXTW 
291c c3 03 20			jp macro_next 
291f				endm 
# End of macro NEXTW
291f			 
291f			.FREE: 
291f				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
291f 57				db WORD_SYS_CORE+67             
2920 50 29			dw .LIST            
2922 05				db 4 + 1 
2923 .. 00			db "FREE",0              
2928				endm 
# End of macro CWHEAD
2928			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2928					if DEBUG_FORTH_WORDS_KEY 
2928						DMARK "FRE" 
2928 f5				push af  
2929 3a 3d 29			ld a, (.dmark)  
292c 32 6b ee			ld (debug_mark),a  
292f 3a 3e 29			ld a, (.dmark+1)  
2932 32 6c ee			ld (debug_mark+1),a  
2935 3a 3f 29			ld a, (.dmark+2)  
2938 32 6d ee			ld (debug_mark+2),a  
293b 18 03			jr .pastdmark  
293d ..			.dmark: db "FRE"  
2940 f1			.pastdmark: pop af  
2941			endm  
# End of macro DMARK
2941						CALLMONITOR 
2941 cd 6f ee			call debug_vector  
2944				endm  
# End of macro CALLMONITOR
2944					endif 
2944					; get address 
2944			 
2944					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2944 cd 4d 1e			call macro_dsp_valuehl 
2947				endm 
# End of macro FORTH_DSP_VALUEHL
2947			 
2947			;		push hl 
2947			 
2947					; destroy value TOS 
2947			 
2947					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2947 cd 05 1f			call macro_forth_dsp_pop 
294a				endm 
# End of macro FORTH_DSP_POP
294a			 
294a			;		pop hl 
294a			if FORTH_ENABLE_MALLOCFREE 
294a cd 78 13				call free 
294d			endif 
294d					NEXTW 
294d c3 03 20			jp macro_next 
2950				endm 
# End of macro NEXTW
2950			.LIST: 
2950				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2950 5c				db WORD_SYS_CORE+72             
2951 3e 2b			dw .FORGET            
2953 05				db 4 + 1 
2954 .. 00			db "LIST",0              
2959				endm 
# End of macro CWHEAD
2959			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2959			; | | The quoted word must be in upper case. 
2959				if DEBUG_FORTH_WORDS_KEY 
2959					DMARK "LST" 
2959 f5				push af  
295a 3a 6e 29			ld a, (.dmark)  
295d 32 6b ee			ld (debug_mark),a  
2960 3a 6f 29			ld a, (.dmark+1)  
2963 32 6c ee			ld (debug_mark+1),a  
2966 3a 70 29			ld a, (.dmark+2)  
2969 32 6d ee			ld (debug_mark+2),a  
296c 18 03			jr .pastdmark  
296e ..			.dmark: db "LST"  
2971 f1			.pastdmark: pop af  
2972			endm  
# End of macro DMARK
2972					CALLMONITOR 
2972 cd 6f ee			call debug_vector  
2975				endm  
# End of macro CALLMONITOR
2975				endif 
2975			 
2975					FORTH_DSP_VALUEHL 
2975 cd 4d 1e			call macro_dsp_valuehl 
2978				endm 
# End of macro FORTH_DSP_VALUEHL
2978			 
2978 e5					push hl 
2979					FORTH_DSP_POP 
2979 cd 05 1f			call macro_forth_dsp_pop 
297c				endm 
# End of macro FORTH_DSP_POP
297c c1					pop bc 
297d			 
297d			; Start format of scratch string 
297d			 
297d 21 c1 e2				ld hl, scratch 
2980			 
2980 3e 3a				ld a, ':' 
2982 77					ld (hl),a 
2983 23					inc hl 
2984 3e 20				ld a, ' ' 
2986 77					ld (hl), a 
2987			 
2987					; Get ptr to the word we need to look up 
2987			 
2987			;		FORTH_DSP_VALUEHL 
2987					;v5 FORTH_DSP_VALUE 
2987				; TODO type check 
2987			;		inc hl    ; Skip type check  
2987			;		push hl 
2987			;		ex de, hl    ; put into DE 
2987			 
2987			 
2987 21 40 65				ld hl, baseram 
298a					;ld hl, baseusermem 
298a			 
298a e5			push hl   ; sacreifical push 
298b			 
298b			.ldouscanm: 
298b e1				pop hl 
298c			.ldouscan: 
298c				if DEBUG_FORTH_WORDS 
298c					DMARK "LSs" 
298c f5				push af  
298d 3a a1 29			ld a, (.dmark)  
2990 32 6b ee			ld (debug_mark),a  
2993 3a a2 29			ld a, (.dmark+1)  
2996 32 6c ee			ld (debug_mark+1),a  
2999 3a a3 29			ld a, (.dmark+2)  
299c 32 6d ee			ld (debug_mark+2),a  
299f 18 03			jr .pastdmark  
29a1 ..			.dmark: db "LSs"  
29a4 f1			.pastdmark: pop af  
29a5			endm  
# End of macro DMARK
29a5					CALLMONITOR 
29a5 cd 6f ee			call debug_vector  
29a8				endm  
# End of macro CALLMONITOR
29a8				endif 
29a8				; skip dict stub 
29a8 cd 54 21				call forth_tok_next 
29ab			 
29ab			 
29ab			; while we have words to look for 
29ab			 
29ab 7e				ld a, (hl)      
29ac				if DEBUG_FORTH_WORDS 
29ac					DMARK "LSk" 
29ac f5				push af  
29ad 3a c1 29			ld a, (.dmark)  
29b0 32 6b ee			ld (debug_mark),a  
29b3 3a c2 29			ld a, (.dmark+1)  
29b6 32 6c ee			ld (debug_mark+1),a  
29b9 3a c3 29			ld a, (.dmark+2)  
29bc 32 6d ee			ld (debug_mark+2),a  
29bf 18 03			jr .pastdmark  
29c1 ..			.dmark: db "LSk"  
29c4 f1			.pastdmark: pop af  
29c5			endm  
# End of macro DMARK
29c5					CALLMONITOR 
29c5 cd 6f ee			call debug_vector  
29c8				endm  
# End of macro CALLMONITOR
29c8				endif 
29c8					;cp WORD_SYS_END 
29c8					;jp z, .lunotfound 
29c8			 
29c8					; if we hit non uwords then gone too far 
29c8 fe 01				cp WORD_SYS_UWORD 
29ca c2 fa 2a				jp nz, .lunotfound 
29cd			 
29cd				if DEBUG_FORTH_WORDS 
29cd					DMARK "LSu" 
29cd f5				push af  
29ce 3a e2 29			ld a, (.dmark)  
29d1 32 6b ee			ld (debug_mark),a  
29d4 3a e3 29			ld a, (.dmark+1)  
29d7 32 6c ee			ld (debug_mark+1),a  
29da 3a e4 29			ld a, (.dmark+2)  
29dd 32 6d ee			ld (debug_mark+2),a  
29e0 18 03			jr .pastdmark  
29e2 ..			.dmark: db "LSu"  
29e5 f1			.pastdmark: pop af  
29e6			endm  
# End of macro DMARK
29e6					CALLMONITOR 
29e6 cd 6f ee			call debug_vector  
29e9				endm  
# End of macro CALLMONITOR
29e9				endif 
29e9			 
29e9					; found a uword but is it the one we want... 
29e9			 
29e9 c5					push bc     ; uword to find is on bc 
29ea d1					pop de 
29eb			 
29eb e5					push hl  ; to save the ptr 
29ec			 
29ec					; skip opcode 
29ec 23					inc hl  
29ed					; skip next ptr 
29ed 23					inc hl  
29ee 23					inc hl 
29ef					; skip len 
29ef 23					inc hl 
29f0			 
29f0				if DEBUG_FORTH_WORDS 
29f0					DMARK "LSc" 
29f0 f5				push af  
29f1 3a 05 2a			ld a, (.dmark)  
29f4 32 6b ee			ld (debug_mark),a  
29f7 3a 06 2a			ld a, (.dmark+1)  
29fa 32 6c ee			ld (debug_mark+1),a  
29fd 3a 07 2a			ld a, (.dmark+2)  
2a00 32 6d ee			ld (debug_mark+2),a  
2a03 18 03			jr .pastdmark  
2a05 ..			.dmark: db "LSc"  
2a08 f1			.pastdmark: pop af  
2a09			endm  
# End of macro DMARK
2a09					CALLMONITOR 
2a09 cd 6f ee			call debug_vector  
2a0c				endm  
# End of macro CALLMONITOR
2a0c				endif 
2a0c cd 7d 12				call strcmp 
2a0f c2 8b 29				jp nz, .ldouscanm 
2a12				 
2a12			 
2a12			 
2a12					; we have a uword so push its name to the stack 
2a12			 
2a12			;	   	push hl  ; save so we can move to next dict block 
2a12 e1			pop hl 
2a13			 
2a13				if DEBUG_FORTH_WORDS 
2a13					DMARK "LSm" 
2a13 f5				push af  
2a14 3a 28 2a			ld a, (.dmark)  
2a17 32 6b ee			ld (debug_mark),a  
2a1a 3a 29 2a			ld a, (.dmark+1)  
2a1d 32 6c ee			ld (debug_mark+1),a  
2a20 3a 2a 2a			ld a, (.dmark+2)  
2a23 32 6d ee			ld (debug_mark+2),a  
2a26 18 03			jr .pastdmark  
2a28 ..			.dmark: db "LSm"  
2a2b f1			.pastdmark: pop af  
2a2c			endm  
# End of macro DMARK
2a2c					CALLMONITOR 
2a2c cd 6f ee			call debug_vector  
2a2f				endm  
# End of macro CALLMONITOR
2a2f				endif 
2a2f			 
2a2f					; skip opcode 
2a2f 23					inc hl  
2a30					; skip next ptr 
2a30 23					inc hl  
2a31 23					inc hl 
2a32					; skip len 
2a32 7e					ld a, (hl)   ; save length to add 
2a33				if DEBUG_FORTH_WORDS 
2a33					DMARK "LS2" 
2a33 f5				push af  
2a34 3a 48 2a			ld a, (.dmark)  
2a37 32 6b ee			ld (debug_mark),a  
2a3a 3a 49 2a			ld a, (.dmark+1)  
2a3d 32 6c ee			ld (debug_mark+1),a  
2a40 3a 4a 2a			ld a, (.dmark+2)  
2a43 32 6d ee			ld (debug_mark+2),a  
2a46 18 03			jr .pastdmark  
2a48 ..			.dmark: db "LS2"  
2a4b f1			.pastdmark: pop af  
2a4c			endm  
# End of macro DMARK
2a4c					CALLMONITOR 
2a4c cd 6f ee			call debug_vector  
2a4f				endm  
# End of macro CALLMONITOR
2a4f				endif 
2a4f			 
2a4f					; save this location 
2a4f				 
2a4f e5					push hl 
2a50			 
2a50 23					inc hl 
2a51 11 c3 e2				ld de, scratch+2 
2a54 4f					ld c, a 
2a55 06 00				ld b, 0 
2a57			 
2a57				if DEBUG_FORTH_WORDS 
2a57					DMARK "LSn" 
2a57 f5				push af  
2a58 3a 6c 2a			ld a, (.dmark)  
2a5b 32 6b ee			ld (debug_mark),a  
2a5e 3a 6d 2a			ld a, (.dmark+1)  
2a61 32 6c ee			ld (debug_mark+1),a  
2a64 3a 6e 2a			ld a, (.dmark+2)  
2a67 32 6d ee			ld (debug_mark+2),a  
2a6a 18 03			jr .pastdmark  
2a6c ..			.dmark: db "LSn"  
2a6f f1			.pastdmark: pop af  
2a70			endm  
# End of macro DMARK
2a70					CALLMONITOR 
2a70 cd 6f ee			call debug_vector  
2a73				endm  
# End of macro CALLMONITOR
2a73				endif 
2a73			 
2a73					; copy uword name to scratch 
2a73			 
2a73 ed b0				ldir 
2a75			 
2a75 1b					dec de 
2a76 3e 20				ld a, ' '    ; change null to space 
2a78 12					ld (de), a 
2a79			 
2a79 13					inc de 
2a7a			 
2a7a d5					push de 
2a7b c1					pop bc     ; move scratch pointer to end of word name and save it 
2a7c			 
2a7c e1					pop hl 
2a7d 7e					ld a, (hl) 
2a7e					;inc hl 
2a7e					; skip word string 
2a7e cd e7 0d				call addatohl 
2a81			 
2a81 23					inc hl 
2a82			 
2a82				if DEBUG_FORTH_WORDS 
2a82					DMARK "LS3" 
2a82 f5				push af  
2a83 3a 97 2a			ld a, (.dmark)  
2a86 32 6b ee			ld (debug_mark),a  
2a89 3a 98 2a			ld a, (.dmark+1)  
2a8c 32 6c ee			ld (debug_mark+1),a  
2a8f 3a 99 2a			ld a, (.dmark+2)  
2a92 32 6d ee			ld (debug_mark+2),a  
2a95 18 03			jr .pastdmark  
2a97 ..			.dmark: db "LS3"  
2a9a f1			.pastdmark: pop af  
2a9b			endm  
# End of macro DMARK
2a9b					CALLMONITOR 
2a9b cd 6f ee			call debug_vector  
2a9e				endm  
# End of macro CALLMONITOR
2a9e				endif 
2a9e					; should now be at the start of the machine code to setup the eval of the uword 
2a9e					; now locate the ptr to the string defintion 
2a9e			 
2a9e					; skip ld hl, 
2a9e					; then load the ptr 
2a9e			; TODO use get from hl ptr 
2a9e 23					inc hl 
2a9f 5e					ld e, (hl) 
2aa0 23					inc hl 
2aa1 56					ld d, (hl) 
2aa2 eb					ex de, hl 
2aa3			 
2aa3			 
2aa3				if DEBUG_FORTH_WORDS 
2aa3					DMARK "LSt" 
2aa3 f5				push af  
2aa4 3a b8 2a			ld a, (.dmark)  
2aa7 32 6b ee			ld (debug_mark),a  
2aaa 3a b9 2a			ld a, (.dmark+1)  
2aad 32 6c ee			ld (debug_mark+1),a  
2ab0 3a ba 2a			ld a, (.dmark+2)  
2ab3 32 6d ee			ld (debug_mark+2),a  
2ab6 18 03			jr .pastdmark  
2ab8 ..			.dmark: db "LSt"  
2abb f1			.pastdmark: pop af  
2abc			endm  
# End of macro DMARK
2abc					CALLMONITOR 
2abc cd 6f ee			call debug_vector  
2abf				endm  
# End of macro CALLMONITOR
2abf				endif 
2abf			 
2abf			; cant push right now due to tokenised strings  
2abf			 
2abf			; get the destination of where to copy this definition to. 
2abf			 
2abf c5					push bc 
2ac0 d1					pop de 
2ac1			 
2ac1 7e			.listl:         ld a,(hl) 
2ac2 fe 00				cp 0 
2ac4 28 09				jr z, .lreplsp     ; replace zero with space 
2ac6					;cp FORTH_END_BUFFER 
2ac6 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ac8 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2aca				 
2aca					; just copy this char as is then 
2aca			 
2aca 12					ld (de), a 
2acb			 
2acb 23			.listnxt:	inc hl 
2acc 13					inc de 
2acd 18 f2				jr .listl 
2acf			 
2acf 3e 20		.lreplsp:	ld a,' ' 
2ad1 12					ld (de), a 
2ad2 18 f7				jr .listnxt 
2ad4			 
2ad4			; close up uword def 
2ad4			 
2ad4			.listdone: 
2ad4 12					ld (de), a 
2ad5 13					inc de 
2ad6 3e 00				ld a, 0 
2ad8 12					ld (de), a 
2ad9			 
2ad9			; now have def so clean up and push to stack 
2ad9			 
2ad9 21 c1 e2				ld hl, scratch 
2adc				if DEBUG_FORTH_WORDS 
2adc					DMARK "Ltp" 
2adc f5				push af  
2add 3a f1 2a			ld a, (.dmark)  
2ae0 32 6b ee			ld (debug_mark),a  
2ae3 3a f2 2a			ld a, (.dmark+1)  
2ae6 32 6c ee			ld (debug_mark+1),a  
2ae9 3a f3 2a			ld a, (.dmark+2)  
2aec 32 6d ee			ld (debug_mark+2),a  
2aef 18 03			jr .pastdmark  
2af1 ..			.dmark: db "Ltp"  
2af4 f1			.pastdmark: pop af  
2af5			endm  
# End of macro DMARK
2af5					CALLMONITOR 
2af5 cd 6f ee			call debug_vector  
2af8				endm  
# End of macro CALLMONITOR
2af8				endif 
2af8			 
2af8 18 1f			jr .listpush 
2afa			 
2afa			;.lnuword:	pop hl 
2afa			;		call forth_tok_next 
2afa			;		jp .ldouscan  
2afa			 
2afa			.lunotfound:		  
2afa			 
2afa				if DEBUG_FORTH_WORDS 
2afa					DMARK "LSn" 
2afa f5				push af  
2afb 3a 0f 2b			ld a, (.dmark)  
2afe 32 6b ee			ld (debug_mark),a  
2b01 3a 10 2b			ld a, (.dmark+1)  
2b04 32 6c ee			ld (debug_mark+1),a  
2b07 3a 11 2b			ld a, (.dmark+2)  
2b0a 32 6d ee			ld (debug_mark+2),a  
2b0d 18 03			jr .pastdmark  
2b0f ..			.dmark: db "LSn"  
2b12 f1			.pastdmark: pop af  
2b13			endm  
# End of macro DMARK
2b13					CALLMONITOR 
2b13 cd 6f ee			call debug_vector  
2b16				endm  
# End of macro CALLMONITOR
2b16				endif 
2b16			 
2b16					 
2b16			;		FORTH_DSP_POP 
2b16			;		ld hl, .luno 
2b16			 
2b16					NEXTW			 
2b16 c3 03 20			jp macro_next 
2b19				endm 
# End of macro NEXTW
2b19			 
2b19			.listpush: 
2b19				if DEBUG_FORTH_WORDS 
2b19					DMARK "LS>" 
2b19 f5				push af  
2b1a 3a 2e 2b			ld a, (.dmark)  
2b1d 32 6b ee			ld (debug_mark),a  
2b20 3a 2f 2b			ld a, (.dmark+1)  
2b23 32 6c ee			ld (debug_mark+1),a  
2b26 3a 30 2b			ld a, (.dmark+2)  
2b29 32 6d ee			ld (debug_mark+2),a  
2b2c 18 03			jr .pastdmark  
2b2e ..			.dmark: db "LS>"  
2b31 f1			.pastdmark: pop af  
2b32			endm  
# End of macro DMARK
2b32					CALLMONITOR 
2b32 cd 6f ee			call debug_vector  
2b35				endm  
# End of macro CALLMONITOR
2b35				endif 
2b35 cd c4 1c				call forth_push_str 
2b38			 
2b38			 
2b38			 
2b38					NEXTW 
2b38 c3 03 20			jp macro_next 
2b3b				endm 
# End of macro NEXTW
2b3b			 
2b3b			;.luno:    db "Word not found",0 
2b3b			 
2b3b			 
2b3b			 
2b3b			 
2b3b			 
2b3b			;		push hl   ; save pointer to start of uword def string 
2b3b			; 
2b3b			;; look for FORTH_EOL_LINE 
2b3b			;		ld a, FORTH_END_BUFFER 
2b3b			;		call strlent 
2b3b			; 
2b3b			;		inc hl		 ; space for coln def 
2b3b			;		inc hl 
2b3b			;		inc hl          ; space for terms 
2b3b			;		inc hl 
2b3b			; 
2b3b			;		ld a, 20   ; TODO get actual length 
2b3b			;		call addatohl    ; include a random amount of room for the uword name 
2b3b			; 
2b3b			;		 
2b3b			;	if DEBUG_FORTH_WORDS 
2b3b			;		DMARK "Lt1" 
2b3b			;		CALLMONITOR 
2b3b			;	endif 
2b3b			;		 
2b3b			; 
2b3b			;; malloc space for the string because we cant change it 
2b3b			; 
2b3b			;		call malloc 
2b3b			;	if DEBUG_FORTH_MALLOC_GUARD 
2b3b			;		push af 
2b3b			;		call ishlzero 
2b3b			;		pop af 
2b3b			;		 
2b3b			;		call z,malloc_error 
2b3b			;	endif 
2b3b			; 
2b3b			;	if DEBUG_FORTH_WORDS 
2b3b			;		DMARK "Lt2" 
2b3b			;		CALLMONITOR 
2b3b			;	endif 
2b3b			;		pop de 
2b3b			;		push hl    ; push the malloc to release later 
2b3b			;		push hl   ;  push back a copy for the later stack push 
2b3b			;		 
2b3b			;; copy the string swapping out the zero terms for spaces 
2b3b			; 
2b3b			;		; de has our source 
2b3b			;		; hl has our dest 
2b3b			; 
2b3b			;; add the coln def 
2b3b			; 
2b3b			;		ld a, ':' 
2b3b			;		ld (hl), a 
2b3b			;		inc hl 
2b3b			;		ld a, ' ' 
2b3b			;		ld (hl), a 
2b3b			;		inc hl 
2b3b			; 
2b3b			;; add the uname word 
2b3b			;		push de   ; save our string for now 
2b3b			;		ex de, hl 
2b3b			; 
2b3b			;		FORTH_DSP_VALUE 
2b3b			;		;v5 FORTH_DSP_VALUE 
2b3b			; 
2b3b			;		inc hl   ; skip type but we know by now this is OK 
2b3b			; 
2b3b			;.luword:	ld a,(hl) 
2b3b			;		cp 0 
2b3b			;		jr z, .luword2 
2b3b			;		ld (de), a 
2b3b			;		inc de 
2b3b			;		inc hl 
2b3b			;		jr .luword 
2b3b			; 
2b3b			;.luword2:	ld a, ' ' 
2b3b			;		ld (de), a 
2b3b			;;		inc hl 
2b3b			;;		inc de 
2b3b			;;		ld (de), a 
2b3b			;;		inc hl 
2b3b			;		inc de 
2b3b			; 
2b3b			;		ex de, hl 
2b3b			;		pop de 
2b3b			;		 
2b3b			;		 
2b3b			; 
2b3b			;; detoken that string and copy it 
2b3b			; 
2b3b			;	if DEBUG_FORTH_WORDS 
2b3b			;		DMARK "Lt2" 
2b3b			;		CALLMONITOR 
2b3b			;	endif 
2b3b			;.ldetok:	ld a, (de) 
2b3b			;		cp FORTH_END_BUFFER 
2b3b			;		jr z, .ldetokend 
2b3b			;		; swap out any zero term for space 
2b3b			;		cp 0 
2b3b			;		jr nz, .ldetoknext 
2b3b			;		ld a, ' ' 
2b3b			; 
2b3b			;	if DEBUG_FORTH_WORDS 
2b3b			;		DMARK "LtS" 
2b3b			;		CALLMONITOR 
2b3b			;	endif 
2b3b			;.ldetoknext:	ld (hl), a 
2b3b			;		inc de 
2b3b			;		inc hl 
2b3b			;		jr .ldetok 
2b3b			; 
2b3b			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b3b			;		ld (hl), a  
2b3b			; 
2b3b			;; free that temp malloc 
2b3b			; 
2b3b			;		pop hl    
2b3b			; 
2b3b			;	if DEBUG_FORTH_WORDS 
2b3b			;		DMARK "Lt4" 
2b3b			;		CALLMONITOR 
2b3b			;	endif 
2b3b			;		call forth_apushstrhl 
2b3b			; 
2b3b			;		; get rid of temp malloc area 
2b3b			; 
2b3b			;		pop hl 
2b3b			;		call free 
2b3b			; 
2b3b			;		jr .ludone 
2b3b			; 
2b3b			;.lnuword:	pop hl 
2b3b			;		call forth_tok_next 
2b3b			;		jp .ldouscan  
2b3b			; 
2b3b			;.ludone:		 pop hl 
2b3b			; 
2b3b					NEXTW 
2b3b c3 03 20			jp macro_next 
2b3e				endm 
# End of macro NEXTW
2b3e			 
2b3e			.FORGET: 
2b3e				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b3e 5d				db WORD_SYS_CORE+73             
2b3f b7 2b			dw .NOP            
2b41 07				db 6 + 1 
2b42 .. 00			db "FORGET",0              
2b49				endm 
# End of macro CWHEAD
2b49			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b49			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b49			; | |  
2b49			; | | e.g. "MORE" forget 
2b49					if DEBUG_FORTH_WORDS_KEY 
2b49						DMARK "FRG" 
2b49 f5				push af  
2b4a 3a 5e 2b			ld a, (.dmark)  
2b4d 32 6b ee			ld (debug_mark),a  
2b50 3a 5f 2b			ld a, (.dmark+1)  
2b53 32 6c ee			ld (debug_mark+1),a  
2b56 3a 60 2b			ld a, (.dmark+2)  
2b59 32 6d ee			ld (debug_mark+2),a  
2b5c 18 03			jr .pastdmark  
2b5e ..			.dmark: db "FRG"  
2b61 f1			.pastdmark: pop af  
2b62			endm  
# End of macro DMARK
2b62						CALLMONITOR 
2b62 cd 6f ee			call debug_vector  
2b65				endm  
# End of macro CALLMONITOR
2b65					endif 
2b65			 
2b65				; find uword 
2b65			        ; update start of word with "_" 
2b65				; replace uword with deleted flag 
2b65			 
2b65			 
2b65			;	if DEBUG_FORTH_WORDS 
2b65			;		DMARK "FOG" 
2b65			;		CALLMONITOR 
2b65			;	endif 
2b65			 
2b65			 
2b65					; Get ptr to the word we need to look up 
2b65			 
2b65					FORTH_DSP_VALUEHL 
2b65 cd 4d 1e			call macro_dsp_valuehl 
2b68				endm 
# End of macro FORTH_DSP_VALUEHL
2b68					;v5 FORTH_DSP_VALUE 
2b68				; TODO type check 
2b68			;		inc hl    ; Skip type check  
2b68 e5					push hl 
2b69 c1					pop bc 
2b6a			;		ex de, hl    ; put into DE 
2b6a			 
2b6a			 
2b6a 21 40 65				ld hl, baseram 
2b6d					;ld hl, baseusermem 
2b6d			 
2b6d				; skip dict stub 
2b6d			;	call forth_tok_next 
2b6d e5			push hl   ; sacreifical push 
2b6e			 
2b6e			.fldouscanm: 
2b6e e1				pop hl 
2b6f			.fldouscan: 
2b6f			;	if DEBUG_FORTH_WORDS 
2b6f			;		DMARK "LSs" 
2b6f			;		CALLMONITOR 
2b6f			;	endif 
2b6f				; skip dict stub 
2b6f cd 54 21				call forth_tok_next 
2b72			 
2b72			 
2b72			; while we have words to look for 
2b72			 
2b72 7e				ld a, (hl)      
2b73			;	if DEBUG_FORTH_WORDS 
2b73			;		DMARK "LSk" 
2b73			;		CALLMONITOR 
2b73			;	endif 
2b73 fe 00				cp WORD_SYS_END 
2b75 ca b1 2b				jp z, .flunotfound 
2b78 fe 01				cp WORD_SYS_UWORD 
2b7a c2 6f 2b				jp nz, .fldouscan 
2b7d			 
2b7d			;	if DEBUG_FORTH_WORDS 
2b7d			;		DMARK "LSu" 
2b7d			;		CALLMONITOR 
2b7d			;	endif 
2b7d			 
2b7d					; found a uword but is it the one we want... 
2b7d			 
2b7d c5					push bc     ; uword to find is on bc 
2b7e d1					pop de 
2b7f			 
2b7f e5					push hl  ; to save the ptr 
2b80			 
2b80					; skip opcode 
2b80 23					inc hl  
2b81					; skip next ptr 
2b81 23					inc hl  
2b82 23					inc hl 
2b83					; skip len 
2b83 23					inc hl 
2b84			 
2b84			;	if DEBUG_FORTH_WORDS 
2b84			;		DMARK "LSc" 
2b84			;		CALLMONITOR 
2b84			;	endif 
2b84 cd 7d 12				call strcmp 
2b87 c2 6e 2b				jp nz, .fldouscanm 
2b8a			; 
2b8a			; 
2b8a			;; while we have words to look for 
2b8a			; 
2b8a			;.fdouscan:	ld a, (hl)      
2b8a			;	if DEBUG_FORTH_WORDS 
2b8a			;		DMARK "LSs" 
2b8a			;		CALLMONITOR 
2b8a			;	endif 
2b8a			;		cp WORD_SYS_END 
2b8a			;		jp z, .fudone 
2b8a			;		cp WORD_SYS_UWORD 
2b8a			;		jp nz, .fnuword 
2b8a			; 
2b8a			;	if DEBUG_FORTH_WORDS 
2b8a			;		DMARK "FGu" 
2b8a			;		CALLMONITOR 
2b8a			;	endif 
2b8a			; 
2b8a			;		; found a uword but is it the one we want... 
2b8a			; 
2b8a			; 
2b8a			;	        pop de   ; get back the dsp name 
2b8a			;		push de 
2b8a			; 
2b8a			;		push hl  ; to save the ptr 
2b8a			; 
2b8a			;		; skip opcode 
2b8a			;		inc hl  
2b8a			;		; skip next ptr 
2b8a			;		inc hl  
2b8a			;		inc hl 
2b8a			;		; skip len 
2b8a			;		inc hl 
2b8a			; 
2b8a			;	if DEBUG_FORTH_WORDS 
2b8a			;		DMARK "FGc" 
2b8a			;		CALLMONITOR 
2b8a			;	endif 
2b8a			;		call strcmp 
2b8a			;		jp nz, .fnuword 
2b8a			 
2b8a			 
2b8a e1			pop hl 
2b8b			 
2b8b				 
2b8b				if DEBUG_FORTH_WORDS 
2b8b					DMARK "FGm" 
2b8b f5				push af  
2b8c 3a a0 2b			ld a, (.dmark)  
2b8f 32 6b ee			ld (debug_mark),a  
2b92 3a a1 2b			ld a, (.dmark+1)  
2b95 32 6c ee			ld (debug_mark+1),a  
2b98 3a a2 2b			ld a, (.dmark+2)  
2b9b 32 6d ee			ld (debug_mark+2),a  
2b9e 18 03			jr .pastdmark  
2ba0 ..			.dmark: db "FGm"  
2ba3 f1			.pastdmark: pop af  
2ba4			endm  
# End of macro DMARK
2ba4					CALLMONITOR 
2ba4 cd 6f ee			call debug_vector  
2ba7				endm  
# End of macro CALLMONITOR
2ba7				endif 
2ba7			 
2ba7			 
2ba7			 
2ba7					; we have a uword so push its name to the stack 
2ba7			 
2ba7			;	   	push hl  ; save so we can move to next dict block 
2ba7			;pop hl 
2ba7			 
2ba7					; update opcode to deleted 
2ba7 3e 03				ld a, WORD_SYS_DELETED 
2ba9 77					ld (hl), a 
2baa			 
2baa 23					inc hl  
2bab					; skip next ptr 
2bab 23					inc hl  
2bac 23					inc hl 
2bad					; skip len 
2bad 23					inc hl 
2bae			 
2bae					; TODO change parser to skip deleted words but for now mark it out 
2bae 3e 5f				ld a, "_" 
2bb0 77					ld  (hl),a 
2bb1			 
2bb1			;		jr .fudone 
2bb1			; 
2bb1			;.fnuword:	pop hl 
2bb1			;		call forth_tok_next 
2bb1			;		jp .fdouscan  
2bb1			 
2bb1			.flunotfound:		  
2bb1			 
2bb1			 
2bb1					 
2bb1					FORTH_DSP_POP 
2bb1 cd 05 1f			call macro_forth_dsp_pop 
2bb4				endm 
# End of macro FORTH_DSP_POP
2bb4			;		ld hl, .luno 
2bb4			;.fudone:		 pop hl 
2bb4					NEXTW 
2bb4 c3 03 20			jp macro_next 
2bb7				endm 
# End of macro NEXTW
2bb7			.NOP: 
2bb7				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2bb7 61				db WORD_SYS_CORE+77             
2bb8 de 2b			dw .COMO            
2bba 04				db 3 + 1 
2bbb .. 00			db "NOP",0              
2bbf				endm 
# End of macro CWHEAD
2bbf			; | NOP (  --  ) Do nothing | DONE 
2bbf					if DEBUG_FORTH_WORDS_KEY 
2bbf						DMARK "NOP" 
2bbf f5				push af  
2bc0 3a d4 2b			ld a, (.dmark)  
2bc3 32 6b ee			ld (debug_mark),a  
2bc6 3a d5 2b			ld a, (.dmark+1)  
2bc9 32 6c ee			ld (debug_mark+1),a  
2bcc 3a d6 2b			ld a, (.dmark+2)  
2bcf 32 6d ee			ld (debug_mark+2),a  
2bd2 18 03			jr .pastdmark  
2bd4 ..			.dmark: db "NOP"  
2bd7 f1			.pastdmark: pop af  
2bd8			endm  
# End of macro DMARK
2bd8						CALLMONITOR 
2bd8 cd 6f ee			call debug_vector  
2bdb				endm  
# End of macro CALLMONITOR
2bdb					endif 
2bdb				       NEXTW 
2bdb c3 03 20			jp macro_next 
2bde				endm 
# End of macro NEXTW
2bde			.COMO: 
2bde				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bde 6e				db WORD_SYS_CORE+90             
2bdf 30 2c			dw .COMC            
2be1 02				db 1 + 1 
2be2 .. 00			db "(",0              
2be4				endm 
# End of macro CWHEAD
2be4			; | ( ( -- )  Start of comment | DONE 
2be4			 
2be4			 
2be4 2a c2 e5				ld hl, ( os_tok_ptr) 
2be7 11 2b 2c			ld de, .closepar 
2bea					 
2bea					if DEBUG_FORTH_WORDS 
2bea						DMARK ").." 
2bea f5				push af  
2beb 3a ff 2b			ld a, (.dmark)  
2bee 32 6b ee			ld (debug_mark),a  
2bf1 3a 00 2c			ld a, (.dmark+1)  
2bf4 32 6c ee			ld (debug_mark+1),a  
2bf7 3a 01 2c			ld a, (.dmark+2)  
2bfa 32 6d ee			ld (debug_mark+2),a  
2bfd 18 03			jr .pastdmark  
2bff ..			.dmark: db ").."  
2c02 f1			.pastdmark: pop af  
2c03			endm  
# End of macro DMARK
2c03						CALLMONITOR 
2c03 cd 6f ee			call debug_vector  
2c06				endm  
# End of macro CALLMONITOR
2c06					endif 
2c06 cd 1e 21			call findnexttok  
2c09			 
2c09					if DEBUG_FORTH_WORDS 
2c09						DMARK "IF5" 
2c09 f5				push af  
2c0a 3a 1e 2c			ld a, (.dmark)  
2c0d 32 6b ee			ld (debug_mark),a  
2c10 3a 1f 2c			ld a, (.dmark+1)  
2c13 32 6c ee			ld (debug_mark+1),a  
2c16 3a 20 2c			ld a, (.dmark+2)  
2c19 32 6d ee			ld (debug_mark+2),a  
2c1c 18 03			jr .pastdmark  
2c1e ..			.dmark: db "IF5"  
2c21 f1			.pastdmark: pop af  
2c22			endm  
# End of macro DMARK
2c22						CALLMONITOR 
2c22 cd 6f ee			call debug_vector  
2c25				endm  
# End of macro CALLMONITOR
2c25					endif 
2c25				; replace below with ) exec using tok_ptr 
2c25 22 c2 e5			ld (os_tok_ptr), hl 
2c28 c3 94 20			jp exec1 
2c2b			 
2c2b .. 00			.closepar:   db ")",0 
2c2d			 
2c2d				       NEXTW 
2c2d c3 03 20			jp macro_next 
2c30				endm 
# End of macro NEXTW
2c30			.COMC: 
2c30				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c30 6f				db WORD_SYS_CORE+91             
2c31 39 2c			dw .SCRATCH            
2c33 02				db 1 + 1 
2c34 .. 00			db ")",0              
2c36				endm 
# End of macro CWHEAD
2c36			; | ) ( -- )  End of comment |  DONE  
2c36				       NEXTW 
2c36 c3 03 20			jp macro_next 
2c39				endm 
# End of macro NEXTW
2c39			 
2c39			.SCRATCH: 
2c39				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c39 6f				db WORD_SYS_CORE+91             
2c3a 74 2c			dw .INC            
2c3c 08				db 7 + 1 
2c3d .. 00			db "SCRATCH",0              
2c45				endm 
# End of macro CWHEAD
2c45			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c45			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c45			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c45			; | |  
2c45			; | | e.g.    : score $00 scratch ; 
2c45			; | |  
2c45			; | | $00 score ! 
2c45			; | | $01 score +! 
2c45			; | |  
2c45			; | | e.g.   : varword $0a scratch ;  
2c45			; | | 
2c45			; | | $8000 varword ! 
2c45					if DEBUG_FORTH_WORDS_KEY 
2c45						DMARK "SCR" 
2c45 f5				push af  
2c46 3a 5a 2c			ld a, (.dmark)  
2c49 32 6b ee			ld (debug_mark),a  
2c4c 3a 5b 2c			ld a, (.dmark+1)  
2c4f 32 6c ee			ld (debug_mark+1),a  
2c52 3a 5c 2c			ld a, (.dmark+2)  
2c55 32 6d ee			ld (debug_mark+2),a  
2c58 18 03			jr .pastdmark  
2c5a ..			.dmark: db "SCR"  
2c5d f1			.pastdmark: pop af  
2c5e			endm  
# End of macro DMARK
2c5e						CALLMONITOR 
2c5e cd 6f ee			call debug_vector  
2c61				endm  
# End of macro CALLMONITOR
2c61					endif 
2c61			 
2c61					FORTH_DSP_VALUEHL 
2c61 cd 4d 1e			call macro_dsp_valuehl 
2c64				endm 
# End of macro FORTH_DSP_VALUEHL
2c64				 
2c64					FORTH_DSP_POP 
2c64 cd 05 1f			call macro_forth_dsp_pop 
2c67				endm 
# End of macro FORTH_DSP_POP
2c67			 
2c67 7d					ld a, l 
2c68 21 e6 e7				ld hl, os_var_array 
2c6b cd e7 0d				call addatohl 
2c6e			 
2c6e cd 56 1c				call forth_push_numhl 
2c71			 
2c71				       NEXTW 
2c71 c3 03 20			jp macro_next 
2c74				endm 
# End of macro NEXTW
2c74			 
2c74			.INC: 
2c74				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c74 6f				db WORD_SYS_CORE+91             
2c75 c8 2c			dw .DEC            
2c77 03				db 2 + 1 
2c78 .. 00			db "+!",0              
2c7b				endm 
# End of macro CWHEAD
2c7b			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c7b					if DEBUG_FORTH_WORDS_KEY 
2c7b						DMARK "+s_" 
2c7b f5				push af  
2c7c 3a 90 2c			ld a, (.dmark)  
2c7f 32 6b ee			ld (debug_mark),a  
2c82 3a 91 2c			ld a, (.dmark+1)  
2c85 32 6c ee			ld (debug_mark+1),a  
2c88 3a 92 2c			ld a, (.dmark+2)  
2c8b 32 6d ee			ld (debug_mark+2),a  
2c8e 18 03			jr .pastdmark  
2c90 ..			.dmark: db "+s_"  
2c93 f1			.pastdmark: pop af  
2c94			endm  
# End of macro DMARK
2c94						CALLMONITOR 
2c94 cd 6f ee			call debug_vector  
2c97				endm  
# End of macro CALLMONITOR
2c97					endif 
2c97			 
2c97					FORTH_DSP_VALUEHL 
2c97 cd 4d 1e			call macro_dsp_valuehl 
2c9a				endm 
# End of macro FORTH_DSP_VALUEHL
2c9a			 
2c9a e5					push hl   ; save address 
2c9b			 
2c9b					FORTH_DSP_POP 
2c9b cd 05 1f			call macro_forth_dsp_pop 
2c9e				endm 
# End of macro FORTH_DSP_POP
2c9e			 
2c9e					FORTH_DSP_VALUEHL 
2c9e cd 4d 1e			call macro_dsp_valuehl 
2ca1				endm 
# End of macro FORTH_DSP_VALUEHL
2ca1			 
2ca1					FORTH_DSP_POP 
2ca1 cd 05 1f			call macro_forth_dsp_pop 
2ca4				endm 
# End of macro FORTH_DSP_POP
2ca4			 
2ca4					; hl contains value to add to byte at a 
2ca4				 
2ca4 eb					ex de, hl 
2ca5			 
2ca5 e1					pop hl 
2ca6			 
2ca6					if DEBUG_FORTH_WORDS 
2ca6						DMARK "INC" 
2ca6 f5				push af  
2ca7 3a bb 2c			ld a, (.dmark)  
2caa 32 6b ee			ld (debug_mark),a  
2cad 3a bc 2c			ld a, (.dmark+1)  
2cb0 32 6c ee			ld (debug_mark+1),a  
2cb3 3a bd 2c			ld a, (.dmark+2)  
2cb6 32 6d ee			ld (debug_mark+2),a  
2cb9 18 03			jr .pastdmark  
2cbb ..			.dmark: db "INC"  
2cbe f1			.pastdmark: pop af  
2cbf			endm  
# End of macro DMARK
2cbf						CALLMONITOR 
2cbf cd 6f ee			call debug_vector  
2cc2				endm  
# End of macro CALLMONITOR
2cc2					endif 
2cc2			 
2cc2 7e					ld a,(hl) 
2cc3 83					add e 
2cc4 77					ld (hl),a 
2cc5			 
2cc5			 
2cc5			 
2cc5				       NEXTW 
2cc5 c3 03 20			jp macro_next 
2cc8				endm 
# End of macro NEXTW
2cc8			 
2cc8			.DEC: 
2cc8				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cc8 6f				db WORD_SYS_CORE+91             
2cc9 19 2d			dw .INC2            
2ccb 03				db 2 + 1 
2ccc .. 00			db "-!",0              
2ccf				endm 
# End of macro CWHEAD
2ccf			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2ccf					if DEBUG_FORTH_WORDS_KEY 
2ccf						DMARK "-s_" 
2ccf f5				push af  
2cd0 3a e4 2c			ld a, (.dmark)  
2cd3 32 6b ee			ld (debug_mark),a  
2cd6 3a e5 2c			ld a, (.dmark+1)  
2cd9 32 6c ee			ld (debug_mark+1),a  
2cdc 3a e6 2c			ld a, (.dmark+2)  
2cdf 32 6d ee			ld (debug_mark+2),a  
2ce2 18 03			jr .pastdmark  
2ce4 ..			.dmark: db "-s_"  
2ce7 f1			.pastdmark: pop af  
2ce8			endm  
# End of macro DMARK
2ce8						CALLMONITOR 
2ce8 cd 6f ee			call debug_vector  
2ceb				endm  
# End of macro CALLMONITOR
2ceb					endif 
2ceb			 
2ceb					FORTH_DSP_VALUEHL 
2ceb cd 4d 1e			call macro_dsp_valuehl 
2cee				endm 
# End of macro FORTH_DSP_VALUEHL
2cee			 
2cee e5					push hl   ; save address 
2cef			 
2cef					FORTH_DSP_POP 
2cef cd 05 1f			call macro_forth_dsp_pop 
2cf2				endm 
# End of macro FORTH_DSP_POP
2cf2			 
2cf2					FORTH_DSP_VALUEHL 
2cf2 cd 4d 1e			call macro_dsp_valuehl 
2cf5				endm 
# End of macro FORTH_DSP_VALUEHL
2cf5			 
2cf5					; hl contains value to add to byte at a 
2cf5				 
2cf5 eb					ex de, hl 
2cf6			 
2cf6 e1					pop hl 
2cf7			 
2cf7					if DEBUG_FORTH_WORDS 
2cf7						DMARK "DEC" 
2cf7 f5				push af  
2cf8 3a 0c 2d			ld a, (.dmark)  
2cfb 32 6b ee			ld (debug_mark),a  
2cfe 3a 0d 2d			ld a, (.dmark+1)  
2d01 32 6c ee			ld (debug_mark+1),a  
2d04 3a 0e 2d			ld a, (.dmark+2)  
2d07 32 6d ee			ld (debug_mark+2),a  
2d0a 18 03			jr .pastdmark  
2d0c ..			.dmark: db "DEC"  
2d0f f1			.pastdmark: pop af  
2d10			endm  
# End of macro DMARK
2d10						CALLMONITOR 
2d10 cd 6f ee			call debug_vector  
2d13				endm  
# End of macro CALLMONITOR
2d13					endif 
2d13			 
2d13 7e					ld a,(hl) 
2d14 93					sub e 
2d15 77					ld (hl),a 
2d16			 
2d16			 
2d16			 
2d16				       NEXTW 
2d16 c3 03 20			jp macro_next 
2d19				endm 
# End of macro NEXTW
2d19			 
2d19			.INC2: 
2d19				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d19 6f				db WORD_SYS_CORE+91             
2d1a c3 2d			dw .DEC2            
2d1c 04				db 3 + 1 
2d1d .. 00			db "+2!",0              
2d21				endm 
# End of macro CWHEAD
2d21			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d21			 
2d21					if DEBUG_FORTH_WORDS_KEY 
2d21						DMARK "+2s" 
2d21 f5				push af  
2d22 3a 36 2d			ld a, (.dmark)  
2d25 32 6b ee			ld (debug_mark),a  
2d28 3a 37 2d			ld a, (.dmark+1)  
2d2b 32 6c ee			ld (debug_mark+1),a  
2d2e 3a 38 2d			ld a, (.dmark+2)  
2d31 32 6d ee			ld (debug_mark+2),a  
2d34 18 03			jr .pastdmark  
2d36 ..			.dmark: db "+2s"  
2d39 f1			.pastdmark: pop af  
2d3a			endm  
# End of macro DMARK
2d3a						CALLMONITOR 
2d3a cd 6f ee			call debug_vector  
2d3d				endm  
# End of macro CALLMONITOR
2d3d					endif 
2d3d			 
2d3d					; Address 
2d3d			 
2d3d					FORTH_DSP_VALUEHL 
2d3d cd 4d 1e			call macro_dsp_valuehl 
2d40				endm 
# End of macro FORTH_DSP_VALUEHL
2d40			 
2d40 e5					push hl    ; save address 
2d41			 
2d41					; load content into de 
2d41			 
2d41 5e					ld e,(hl) 
2d42 23					inc hl 
2d43 56					ld d, (hl) 
2d44			 
2d44					if DEBUG_FORTH_WORDS 
2d44						DMARK "+2a" 
2d44 f5				push af  
2d45 3a 59 2d			ld a, (.dmark)  
2d48 32 6b ee			ld (debug_mark),a  
2d4b 3a 5a 2d			ld a, (.dmark+1)  
2d4e 32 6c ee			ld (debug_mark+1),a  
2d51 3a 5b 2d			ld a, (.dmark+2)  
2d54 32 6d ee			ld (debug_mark+2),a  
2d57 18 03			jr .pastdmark  
2d59 ..			.dmark: db "+2a"  
2d5c f1			.pastdmark: pop af  
2d5d			endm  
# End of macro DMARK
2d5d						CALLMONITOR 
2d5d cd 6f ee			call debug_vector  
2d60				endm  
# End of macro CALLMONITOR
2d60					endif 
2d60			 
2d60					FORTH_DSP_POP 
2d60 cd 05 1f			call macro_forth_dsp_pop 
2d63				endm 
# End of macro FORTH_DSP_POP
2d63			 
2d63					; Get value to add 
2d63			 
2d63					FORTH_DSP_VALUE 
2d63 cd 36 1e			call macro_forth_dsp_value 
2d66				endm 
# End of macro FORTH_DSP_VALUE
2d66			 
2d66					if DEBUG_FORTH_WORDS 
2d66						DMARK "+2v" 
2d66 f5				push af  
2d67 3a 7b 2d			ld a, (.dmark)  
2d6a 32 6b ee			ld (debug_mark),a  
2d6d 3a 7c 2d			ld a, (.dmark+1)  
2d70 32 6c ee			ld (debug_mark+1),a  
2d73 3a 7d 2d			ld a, (.dmark+2)  
2d76 32 6d ee			ld (debug_mark+2),a  
2d79 18 03			jr .pastdmark  
2d7b ..			.dmark: db "+2v"  
2d7e f1			.pastdmark: pop af  
2d7f			endm  
# End of macro DMARK
2d7f						CALLMONITOR 
2d7f cd 6f ee			call debug_vector  
2d82				endm  
# End of macro CALLMONITOR
2d82					endif 
2d82			 
2d82 19					add hl, de 
2d83			 
2d83					if DEBUG_FORTH_WORDS 
2d83						DMARK "+2+" 
2d83 f5				push af  
2d84 3a 98 2d			ld a, (.dmark)  
2d87 32 6b ee			ld (debug_mark),a  
2d8a 3a 99 2d			ld a, (.dmark+1)  
2d8d 32 6c ee			ld (debug_mark+1),a  
2d90 3a 9a 2d			ld a, (.dmark+2)  
2d93 32 6d ee			ld (debug_mark+2),a  
2d96 18 03			jr .pastdmark  
2d98 ..			.dmark: db "+2+"  
2d9b f1			.pastdmark: pop af  
2d9c			endm  
# End of macro DMARK
2d9c						CALLMONITOR 
2d9c cd 6f ee			call debug_vector  
2d9f				endm  
# End of macro CALLMONITOR
2d9f					endif 
2d9f			 
2d9f					; move result to de 
2d9f			 
2d9f eb					ex de, hl 
2da0			 
2da0					; Address 
2da0			 
2da0 e1					pop hl 
2da1			 
2da1					; save it back 
2da1			 
2da1 73					ld (hl), e 
2da2 23					inc hl 
2da3 72					ld (hl), d 
2da4			 
2da4					if DEBUG_FORTH_WORDS 
2da4						DMARK "+2e" 
2da4 f5				push af  
2da5 3a b9 2d			ld a, (.dmark)  
2da8 32 6b ee			ld (debug_mark),a  
2dab 3a ba 2d			ld a, (.dmark+1)  
2dae 32 6c ee			ld (debug_mark+1),a  
2db1 3a bb 2d			ld a, (.dmark+2)  
2db4 32 6d ee			ld (debug_mark+2),a  
2db7 18 03			jr .pastdmark  
2db9 ..			.dmark: db "+2e"  
2dbc f1			.pastdmark: pop af  
2dbd			endm  
# End of macro DMARK
2dbd						CALLMONITOR 
2dbd cd 6f ee			call debug_vector  
2dc0				endm  
# End of macro CALLMONITOR
2dc0					endif 
2dc0			 
2dc0			 
2dc0			 
2dc0			 
2dc0			 
2dc0				       NEXTW 
2dc0 c3 03 20			jp macro_next 
2dc3				endm 
# End of macro NEXTW
2dc3			 
2dc3			.DEC2: 
2dc3				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2dc3 6f				db WORD_SYS_CORE+91             
2dc4 6f 2e			dw .GET2            
2dc6 04				db 3 + 1 
2dc7 .. 00			db "-2!",0              
2dcb				endm 
# End of macro CWHEAD
2dcb			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2dcb			 
2dcb			 
2dcb					if DEBUG_FORTH_WORDS_KEY 
2dcb						DMARK "-2s" 
2dcb f5				push af  
2dcc 3a e0 2d			ld a, (.dmark)  
2dcf 32 6b ee			ld (debug_mark),a  
2dd2 3a e1 2d			ld a, (.dmark+1)  
2dd5 32 6c ee			ld (debug_mark+1),a  
2dd8 3a e2 2d			ld a, (.dmark+2)  
2ddb 32 6d ee			ld (debug_mark+2),a  
2dde 18 03			jr .pastdmark  
2de0 ..			.dmark: db "-2s"  
2de3 f1			.pastdmark: pop af  
2de4			endm  
# End of macro DMARK
2de4						CALLMONITOR 
2de4 cd 6f ee			call debug_vector  
2de7				endm  
# End of macro CALLMONITOR
2de7					endif 
2de7			 
2de7					; Address 
2de7			 
2de7					FORTH_DSP_VALUEHL 
2de7 cd 4d 1e			call macro_dsp_valuehl 
2dea				endm 
# End of macro FORTH_DSP_VALUEHL
2dea			 
2dea e5					push hl    ; save address 
2deb			 
2deb					; load content into de 
2deb			 
2deb 5e					ld e,(hl) 
2dec 23					inc hl 
2ded 56					ld d, (hl) 
2dee			 
2dee					if DEBUG_FORTH_WORDS 
2dee						DMARK "-2a" 
2dee f5				push af  
2def 3a 03 2e			ld a, (.dmark)  
2df2 32 6b ee			ld (debug_mark),a  
2df5 3a 04 2e			ld a, (.dmark+1)  
2df8 32 6c ee			ld (debug_mark+1),a  
2dfb 3a 05 2e			ld a, (.dmark+2)  
2dfe 32 6d ee			ld (debug_mark+2),a  
2e01 18 03			jr .pastdmark  
2e03 ..			.dmark: db "-2a"  
2e06 f1			.pastdmark: pop af  
2e07			endm  
# End of macro DMARK
2e07						CALLMONITOR 
2e07 cd 6f ee			call debug_vector  
2e0a				endm  
# End of macro CALLMONITOR
2e0a					endif 
2e0a			 
2e0a					FORTH_DSP_POP 
2e0a cd 05 1f			call macro_forth_dsp_pop 
2e0d				endm 
# End of macro FORTH_DSP_POP
2e0d			 
2e0d					; Get value to remove 
2e0d			 
2e0d					FORTH_DSP_VALUE 
2e0d cd 36 1e			call macro_forth_dsp_value 
2e10				endm 
# End of macro FORTH_DSP_VALUE
2e10			 
2e10					if DEBUG_FORTH_WORDS 
2e10						DMARK "-2v" 
2e10 f5				push af  
2e11 3a 25 2e			ld a, (.dmark)  
2e14 32 6b ee			ld (debug_mark),a  
2e17 3a 26 2e			ld a, (.dmark+1)  
2e1a 32 6c ee			ld (debug_mark+1),a  
2e1d 3a 27 2e			ld a, (.dmark+2)  
2e20 32 6d ee			ld (debug_mark+2),a  
2e23 18 03			jr .pastdmark  
2e25 ..			.dmark: db "-2v"  
2e28 f1			.pastdmark: pop af  
2e29			endm  
# End of macro DMARK
2e29						CALLMONITOR 
2e29 cd 6f ee			call debug_vector  
2e2c				endm  
# End of macro CALLMONITOR
2e2c					endif 
2e2c			 
2e2c eb					ex de, hl 
2e2d ed 52				sbc hl, de 
2e2f			 
2e2f					if DEBUG_FORTH_WORDS 
2e2f						DMARK "-2d" 
2e2f f5				push af  
2e30 3a 44 2e			ld a, (.dmark)  
2e33 32 6b ee			ld (debug_mark),a  
2e36 3a 45 2e			ld a, (.dmark+1)  
2e39 32 6c ee			ld (debug_mark+1),a  
2e3c 3a 46 2e			ld a, (.dmark+2)  
2e3f 32 6d ee			ld (debug_mark+2),a  
2e42 18 03			jr .pastdmark  
2e44 ..			.dmark: db "-2d"  
2e47 f1			.pastdmark: pop af  
2e48			endm  
# End of macro DMARK
2e48						CALLMONITOR 
2e48 cd 6f ee			call debug_vector  
2e4b				endm  
# End of macro CALLMONITOR
2e4b					endif 
2e4b			 
2e4b					; move result to de 
2e4b			 
2e4b eb					ex de, hl 
2e4c			 
2e4c					; Address 
2e4c			 
2e4c e1					pop hl 
2e4d			 
2e4d					; save it back 
2e4d			 
2e4d 73					ld (hl), e 
2e4e 23					inc hl 
2e4f 72					ld (hl), d 
2e50			 
2e50					if DEBUG_FORTH_WORDS 
2e50						DMARK "-2e" 
2e50 f5				push af  
2e51 3a 65 2e			ld a, (.dmark)  
2e54 32 6b ee			ld (debug_mark),a  
2e57 3a 66 2e			ld a, (.dmark+1)  
2e5a 32 6c ee			ld (debug_mark+1),a  
2e5d 3a 67 2e			ld a, (.dmark+2)  
2e60 32 6d ee			ld (debug_mark+2),a  
2e63 18 03			jr .pastdmark  
2e65 ..			.dmark: db "-2e"  
2e68 f1			.pastdmark: pop af  
2e69			endm  
# End of macro DMARK
2e69						CALLMONITOR 
2e69 cd 6f ee			call debug_vector  
2e6c				endm  
# End of macro CALLMONITOR
2e6c					endif 
2e6c			 
2e6c			 
2e6c			 
2e6c			 
2e6c			 
2e6c				       NEXTW 
2e6c c3 03 20			jp macro_next 
2e6f				endm 
# End of macro NEXTW
2e6f			.GET2: 
2e6f				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e6f 6f				db WORD_SYS_CORE+91             
2e70 9f 2e			dw .BANG2            
2e72 03				db 2 + 1 
2e73 .. 00			db "2@",0              
2e76				endm 
# End of macro CWHEAD
2e76			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e76					if DEBUG_FORTH_WORDS_KEY 
2e76						DMARK "2A_" 
2e76 f5				push af  
2e77 3a 8b 2e			ld a, (.dmark)  
2e7a 32 6b ee			ld (debug_mark),a  
2e7d 3a 8c 2e			ld a, (.dmark+1)  
2e80 32 6c ee			ld (debug_mark+1),a  
2e83 3a 8d 2e			ld a, (.dmark+2)  
2e86 32 6d ee			ld (debug_mark+2),a  
2e89 18 03			jr .pastdmark  
2e8b ..			.dmark: db "2A_"  
2e8e f1			.pastdmark: pop af  
2e8f			endm  
# End of macro DMARK
2e8f						CALLMONITOR 
2e8f cd 6f ee			call debug_vector  
2e92				endm  
# End of macro CALLMONITOR
2e92					endif 
2e92			 
2e92					FORTH_DSP_VALUEHL 
2e92 cd 4d 1e			call macro_dsp_valuehl 
2e95				endm 
# End of macro FORTH_DSP_VALUEHL
2e95			 
2e95 5e					ld e, (hl) 
2e96 23					inc hl 
2e97 56					ld d, (hl) 
2e98			 
2e98 eb					ex de, hl 
2e99			 
2e99 cd 56 1c				call forth_push_numhl 
2e9c			 
2e9c				       NEXTW 
2e9c c3 03 20			jp macro_next 
2e9f				endm 
# End of macro NEXTW
2e9f			.BANG2: 
2e9f				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e9f 6f				db WORD_SYS_CORE+91             
2ea0 d7 2e			dw .CONFIG            
2ea2 03				db 2 + 1 
2ea3 .. 00			db "2!",0              
2ea6				endm 
# End of macro CWHEAD
2ea6			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ea6					if DEBUG_FORTH_WORDS_KEY 
2ea6						DMARK "2S_" 
2ea6 f5				push af  
2ea7 3a bb 2e			ld a, (.dmark)  
2eaa 32 6b ee			ld (debug_mark),a  
2ead 3a bc 2e			ld a, (.dmark+1)  
2eb0 32 6c ee			ld (debug_mark+1),a  
2eb3 3a bd 2e			ld a, (.dmark+2)  
2eb6 32 6d ee			ld (debug_mark+2),a  
2eb9 18 03			jr .pastdmark  
2ebb ..			.dmark: db "2S_"  
2ebe f1			.pastdmark: pop af  
2ebf			endm  
# End of macro DMARK
2ebf						CALLMONITOR 
2ebf cd 6f ee			call debug_vector  
2ec2				endm  
# End of macro CALLMONITOR
2ec2					endif 
2ec2			 
2ec2					FORTH_DSP_VALUEHL 
2ec2 cd 4d 1e			call macro_dsp_valuehl 
2ec5				endm 
# End of macro FORTH_DSP_VALUEHL
2ec5			 
2ec5 e5					push hl   ; save address 
2ec6			 
2ec6			 
2ec6					FORTH_DSP_POP 
2ec6 cd 05 1f			call macro_forth_dsp_pop 
2ec9				endm 
# End of macro FORTH_DSP_POP
2ec9			 
2ec9					 
2ec9					FORTH_DSP_VALUEHL 
2ec9 cd 4d 1e			call macro_dsp_valuehl 
2ecc				endm 
# End of macro FORTH_DSP_VALUEHL
2ecc			 
2ecc					FORTH_DSP_POP 
2ecc cd 05 1f			call macro_forth_dsp_pop 
2ecf				endm 
# End of macro FORTH_DSP_POP
2ecf			 
2ecf eb					ex de, hl    ; value now in de 
2ed0			 
2ed0 e1					pop hl 
2ed1			 
2ed1 73					ld (hl), e 
2ed2			 
2ed2 23					inc hl 
2ed3			 
2ed3 72					ld (hl), d 
2ed4			 
2ed4			 
2ed4				       NEXTW 
2ed4 c3 03 20			jp macro_next 
2ed7				endm 
# End of macro NEXTW
2ed7			.CONFIG: 
2ed7				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2ed7 6f				db WORD_SYS_CORE+91             
2ed8 e8 2e			dw .ENDCORE            
2eda 07				db 6 + 1 
2edb .. 00			db "CONFIG",0              
2ee2				endm 
# End of macro CWHEAD
2ee2			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ee2			 
2ee2 cd 47 14				call config 
2ee5					NEXTW 
2ee5 c3 03 20			jp macro_next 
2ee8				endm 
# End of macro NEXTW
2ee8			.ENDCORE: 
2ee8			 
2ee8			; eof 
2ee8			 
2ee8			 
# End of file forth_words_core.asm
2ee8			include "forth_words_flow.asm" 
2ee8			 
2ee8			; | ## Program Flow Words 
2ee8			 
2ee8			.IF: 
2ee8				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2ee8 1e				db WORD_SYS_CORE+10             
2ee9 dd 2f			dw .THEN            
2eeb 03				db 2 + 1 
2eec .. 00			db "IF",0              
2eef				endm 
# End of macro CWHEAD
2eef			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2eef			; 
2eef					if DEBUG_FORTH_WORDS_KEY 
2eef						DMARK "IF." 
2eef f5				push af  
2ef0 3a 04 2f			ld a, (.dmark)  
2ef3 32 6b ee			ld (debug_mark),a  
2ef6 3a 05 2f			ld a, (.dmark+1)  
2ef9 32 6c ee			ld (debug_mark+1),a  
2efc 3a 06 2f			ld a, (.dmark+2)  
2eff 32 6d ee			ld (debug_mark+2),a  
2f02 18 03			jr .pastdmark  
2f04 ..			.dmark: db "IF."  
2f07 f1			.pastdmark: pop af  
2f08			endm  
# End of macro DMARK
2f08						CALLMONITOR 
2f08 cd 6f ee			call debug_vector  
2f0b				endm  
# End of macro CALLMONITOR
2f0b					endif 
2f0b			; eval TOS 
2f0b			 
2f0b				FORTH_DSP_VALUEHL 
2f0b cd 4d 1e			call macro_dsp_valuehl 
2f0e				endm 
# End of macro FORTH_DSP_VALUEHL
2f0e			 
2f0e			;	push hl 
2f0e				FORTH_DSP_POP 
2f0e cd 05 1f			call macro_forth_dsp_pop 
2f11				endm 
# End of macro FORTH_DSP_POP
2f11			;	pop hl 
2f11			 
2f11					if DEBUG_FORTH_WORDS 
2f11						DMARK "IF1" 
2f11 f5				push af  
2f12 3a 26 2f			ld a, (.dmark)  
2f15 32 6b ee			ld (debug_mark),a  
2f18 3a 27 2f			ld a, (.dmark+1)  
2f1b 32 6c ee			ld (debug_mark+1),a  
2f1e 3a 28 2f			ld a, (.dmark+2)  
2f21 32 6d ee			ld (debug_mark+2),a  
2f24 18 03			jr .pastdmark  
2f26 ..			.dmark: db "IF1"  
2f29 f1			.pastdmark: pop af  
2f2a			endm  
# End of macro DMARK
2f2a						CALLMONITOR 
2f2a cd 6f ee			call debug_vector  
2f2d				endm  
# End of macro CALLMONITOR
2f2d					endif 
2f2d b7				or a        ; clear carry flag 
2f2e 11 00 00			ld de, 0 
2f31 eb				ex de,hl 
2f32 ed 52			sbc hl, de 
2f34 c2 be 2f			jp nz, .iftrue 
2f37			 
2f37					if DEBUG_FORTH_WORDS 
2f37						DMARK "IF2" 
2f37 f5				push af  
2f38 3a 4c 2f			ld a, (.dmark)  
2f3b 32 6b ee			ld (debug_mark),a  
2f3e 3a 4d 2f			ld a, (.dmark+1)  
2f41 32 6c ee			ld (debug_mark+1),a  
2f44 3a 4e 2f			ld a, (.dmark+2)  
2f47 32 6d ee			ld (debug_mark+2),a  
2f4a 18 03			jr .pastdmark  
2f4c ..			.dmark: db "IF2"  
2f4f f1			.pastdmark: pop af  
2f50			endm  
# End of macro DMARK
2f50						CALLMONITOR 
2f50 cd 6f ee			call debug_vector  
2f53				endm  
# End of macro CALLMONITOR
2f53					endif 
2f53			 
2f53			; if not true then skip to THEN 
2f53			 
2f53				; TODO get tok_ptr 
2f53				; TODO consume toks until we get to THEN 
2f53			 
2f53 2a c2 e5			ld hl, (os_tok_ptr) 
2f56					if DEBUG_FORTH_WORDS 
2f56						DMARK "IF3" 
2f56 f5				push af  
2f57 3a 6b 2f			ld a, (.dmark)  
2f5a 32 6b ee			ld (debug_mark),a  
2f5d 3a 6c 2f			ld a, (.dmark+1)  
2f60 32 6c ee			ld (debug_mark+1),a  
2f63 3a 6d 2f			ld a, (.dmark+2)  
2f66 32 6d ee			ld (debug_mark+2),a  
2f69 18 03			jr .pastdmark  
2f6b ..			.dmark: db "IF3"  
2f6e f1			.pastdmark: pop af  
2f6f			endm  
# End of macro DMARK
2f6f						CALLMONITOR 
2f6f cd 6f ee			call debug_vector  
2f72				endm  
# End of macro CALLMONITOR
2f72						 
2f72					endif 
2f72 11 b9 2f			ld de, .ifthen 
2f75					if DEBUG_FORTH_WORDS 
2f75						DMARK "IF4" 
2f75 f5				push af  
2f76 3a 8a 2f			ld a, (.dmark)  
2f79 32 6b ee			ld (debug_mark),a  
2f7c 3a 8b 2f			ld a, (.dmark+1)  
2f7f 32 6c ee			ld (debug_mark+1),a  
2f82 3a 8c 2f			ld a, (.dmark+2)  
2f85 32 6d ee			ld (debug_mark+2),a  
2f88 18 03			jr .pastdmark  
2f8a ..			.dmark: db "IF4"  
2f8d f1			.pastdmark: pop af  
2f8e			endm  
# End of macro DMARK
2f8e						CALLMONITOR 
2f8e cd 6f ee			call debug_vector  
2f91				endm  
# End of macro CALLMONITOR
2f91					endif 
2f91 cd 1e 21			call findnexttok  
2f94			 
2f94					if DEBUG_FORTH_WORDS 
2f94						DMARK "IF5" 
2f94 f5				push af  
2f95 3a a9 2f			ld a, (.dmark)  
2f98 32 6b ee			ld (debug_mark),a  
2f9b 3a aa 2f			ld a, (.dmark+1)  
2f9e 32 6c ee			ld (debug_mark+1),a  
2fa1 3a ab 2f			ld a, (.dmark+2)  
2fa4 32 6d ee			ld (debug_mark+2),a  
2fa7 18 03			jr .pastdmark  
2fa9 ..			.dmark: db "IF5"  
2fac f1			.pastdmark: pop af  
2fad			endm  
# End of macro DMARK
2fad						CALLMONITOR 
2fad cd 6f ee			call debug_vector  
2fb0				endm  
# End of macro CALLMONITOR
2fb0					endif 
2fb0				; TODO replace below with ; exec using tok_ptr 
2fb0 22 c2 e5			ld (os_tok_ptr), hl 
2fb3 c3 94 20			jp exec1 
2fb6				NEXTW 
2fb6 c3 03 20			jp macro_next 
2fb9				endm 
# End of macro NEXTW
2fb9			 
2fb9 .. 00		.ifthen:  db "THEN",0 
2fbe			 
2fbe			.iftrue:		 
2fbe				; Exec next words normally 
2fbe			 
2fbe				; if true then exec following IF as normal 
2fbe					if DEBUG_FORTH_WORDS 
2fbe						DMARK "IFT" 
2fbe f5				push af  
2fbf 3a d3 2f			ld a, (.dmark)  
2fc2 32 6b ee			ld (debug_mark),a  
2fc5 3a d4 2f			ld a, (.dmark+1)  
2fc8 32 6c ee			ld (debug_mark+1),a  
2fcb 3a d5 2f			ld a, (.dmark+2)  
2fce 32 6d ee			ld (debug_mark+2),a  
2fd1 18 03			jr .pastdmark  
2fd3 ..			.dmark: db "IFT"  
2fd6 f1			.pastdmark: pop af  
2fd7			endm  
# End of macro DMARK
2fd7						CALLMONITOR 
2fd7 cd 6f ee			call debug_vector  
2fda				endm  
# End of macro CALLMONITOR
2fda					endif 
2fda			 
2fda					NEXTW 
2fda c3 03 20			jp macro_next 
2fdd				endm 
# End of macro NEXTW
2fdd			.THEN: 
2fdd				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2fdd 1f				db WORD_SYS_CORE+11             
2fde 05 30			dw .ELSE            
2fe0 05				db 4 + 1 
2fe1 .. 00			db "THEN",0              
2fe6				endm 
# End of macro CWHEAD
2fe6			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2fe6					if DEBUG_FORTH_WORDS_KEY 
2fe6						DMARK "THN" 
2fe6 f5				push af  
2fe7 3a fb 2f			ld a, (.dmark)  
2fea 32 6b ee			ld (debug_mark),a  
2fed 3a fc 2f			ld a, (.dmark+1)  
2ff0 32 6c ee			ld (debug_mark+1),a  
2ff3 3a fd 2f			ld a, (.dmark+2)  
2ff6 32 6d ee			ld (debug_mark+2),a  
2ff9 18 03			jr .pastdmark  
2ffb ..			.dmark: db "THN"  
2ffe f1			.pastdmark: pop af  
2fff			endm  
# End of macro DMARK
2fff						CALLMONITOR 
2fff cd 6f ee			call debug_vector  
3002				endm  
# End of macro CALLMONITOR
3002					endif 
3002					NEXTW 
3002 c3 03 20			jp macro_next 
3005				endm 
# End of macro NEXTW
3005			.ELSE: 
3005				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3005 20				db WORD_SYS_CORE+12             
3006 2d 30			dw .DO            
3008 03				db 2 + 1 
3009 .. 00			db "ELSE",0              
300e				endm 
# End of macro CWHEAD
300e			; | ELSE ( -- ) Not supported - does nothing | TODO 
300e			 
300e					if DEBUG_FORTH_WORDS_KEY 
300e						DMARK "ELS" 
300e f5				push af  
300f 3a 23 30			ld a, (.dmark)  
3012 32 6b ee			ld (debug_mark),a  
3015 3a 24 30			ld a, (.dmark+1)  
3018 32 6c ee			ld (debug_mark+1),a  
301b 3a 25 30			ld a, (.dmark+2)  
301e 32 6d ee			ld (debug_mark+2),a  
3021 18 03			jr .pastdmark  
3023 ..			.dmark: db "ELS"  
3026 f1			.pastdmark: pop af  
3027			endm  
# End of macro DMARK
3027						CALLMONITOR 
3027 cd 6f ee			call debug_vector  
302a				endm  
# End of macro CALLMONITOR
302a					endif 
302a			 
302a			 
302a					NEXTW 
302a c3 03 20			jp macro_next 
302d				endm 
# End of macro NEXTW
302d			.DO: 
302d				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
302d 21				db WORD_SYS_CORE+13             
302e 54 31			dw .LOOP            
3030 03				db 2 + 1 
3031 .. 00			db "DO",0              
3034				endm 
# End of macro CWHEAD
3034			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3034			 
3034					if DEBUG_FORTH_WORDS_KEY 
3034						DMARK "DO." 
3034 f5				push af  
3035 3a 49 30			ld a, (.dmark)  
3038 32 6b ee			ld (debug_mark),a  
303b 3a 4a 30			ld a, (.dmark+1)  
303e 32 6c ee			ld (debug_mark+1),a  
3041 3a 4b 30			ld a, (.dmark+2)  
3044 32 6d ee			ld (debug_mark+2),a  
3047 18 03			jr .pastdmark  
3049 ..			.dmark: db "DO."  
304c f1			.pastdmark: pop af  
304d			endm  
# End of macro DMARK
304d						CALLMONITOR 
304d cd 6f ee			call debug_vector  
3050				endm  
# End of macro CALLMONITOR
3050					endif 
3050			;  push pc to rsp stack past the DO 
3050			 
3050 2a c2 e5				ld hl, (os_tok_ptr) 
3053 23					inc hl   ; D 
3054 23					inc hl  ; O 
3055 23					inc hl   ; null 
3056					if DEBUG_FORTH_WORDS 
3056						DMARK "DO2" 
3056 f5				push af  
3057 3a 6b 30			ld a, (.dmark)  
305a 32 6b ee			ld (debug_mark),a  
305d 3a 6c 30			ld a, (.dmark+1)  
3060 32 6c ee			ld (debug_mark+1),a  
3063 3a 6d 30			ld a, (.dmark+2)  
3066 32 6d ee			ld (debug_mark+2),a  
3069 18 03			jr .pastdmark  
306b ..			.dmark: db "DO2"  
306e f1			.pastdmark: pop af  
306f			endm  
# End of macro DMARK
306f						CALLMONITOR 
306f cd 6f ee			call debug_vector  
3072				endm  
# End of macro CALLMONITOR
3072					endif 
3072					FORTH_RSP_NEXT 
3072 cd fd 1b			call macro_forth_rsp_next 
3075				endm 
# End of macro FORTH_RSP_NEXT
3075					if DEBUG_FORTH_WORDS 
3075						DMARK "DO3" 
3075 f5				push af  
3076 3a 8a 30			ld a, (.dmark)  
3079 32 6b ee			ld (debug_mark),a  
307c 3a 8b 30			ld a, (.dmark+1)  
307f 32 6c ee			ld (debug_mark+1),a  
3082 3a 8c 30			ld a, (.dmark+2)  
3085 32 6d ee			ld (debug_mark+2),a  
3088 18 03			jr .pastdmark  
308a ..			.dmark: db "DO3"  
308d f1			.pastdmark: pop af  
308e			endm  
# End of macro DMARK
308e						CALLMONITOR 
308e cd 6f ee			call debug_vector  
3091				endm  
# End of macro CALLMONITOR
3091					endif 
3091			 
3091					;if DEBUG_FORTH_WORDS 
3091				;		push hl 
3091			;		endif  
3091			 
3091			; get counters from data stack 
3091			 
3091			 
3091					FORTH_DSP_VALUEHL 
3091 cd 4d 1e			call macro_dsp_valuehl 
3094				endm 
# End of macro FORTH_DSP_VALUEHL
3094 e5					push hl		 ; hl now has starting counter which needs to be tos 
3095			 
3095					if DEBUG_FORTH_WORDS 
3095						DMARK "DO4" 
3095 f5				push af  
3096 3a aa 30			ld a, (.dmark)  
3099 32 6b ee			ld (debug_mark),a  
309c 3a ab 30			ld a, (.dmark+1)  
309f 32 6c ee			ld (debug_mark+1),a  
30a2 3a ac 30			ld a, (.dmark+2)  
30a5 32 6d ee			ld (debug_mark+2),a  
30a8 18 03			jr .pastdmark  
30aa ..			.dmark: db "DO4"  
30ad f1			.pastdmark: pop af  
30ae			endm  
# End of macro DMARK
30ae						CALLMONITOR 
30ae cd 6f ee			call debug_vector  
30b1				endm  
# End of macro CALLMONITOR
30b1					endif 
30b1					FORTH_DSP_POP 
30b1 cd 05 1f			call macro_forth_dsp_pop 
30b4				endm 
# End of macro FORTH_DSP_POP
30b4			 
30b4					if DEBUG_FORTH_WORDS 
30b4						DMARK "DO5" 
30b4 f5				push af  
30b5 3a c9 30			ld a, (.dmark)  
30b8 32 6b ee			ld (debug_mark),a  
30bb 3a ca 30			ld a, (.dmark+1)  
30be 32 6c ee			ld (debug_mark+1),a  
30c1 3a cb 30			ld a, (.dmark+2)  
30c4 32 6d ee			ld (debug_mark+2),a  
30c7 18 03			jr .pastdmark  
30c9 ..			.dmark: db "DO5"  
30cc f1			.pastdmark: pop af  
30cd			endm  
# End of macro DMARK
30cd						CALLMONITOR 
30cd cd 6f ee			call debug_vector  
30d0				endm  
# End of macro CALLMONITOR
30d0					endif 
30d0			 
30d0					FORTH_DSP_VALUEHL 
30d0 cd 4d 1e			call macro_dsp_valuehl 
30d3				endm 
# End of macro FORTH_DSP_VALUEHL
30d3			;		push hl		 ; hl now has starting limit counter 
30d3			 
30d3					if DEBUG_FORTH_WORDS 
30d3						DMARK "DO6" 
30d3 f5				push af  
30d4 3a e8 30			ld a, (.dmark)  
30d7 32 6b ee			ld (debug_mark),a  
30da 3a e9 30			ld a, (.dmark+1)  
30dd 32 6c ee			ld (debug_mark+1),a  
30e0 3a ea 30			ld a, (.dmark+2)  
30e3 32 6d ee			ld (debug_mark+2),a  
30e6 18 03			jr .pastdmark  
30e8 ..			.dmark: db "DO6"  
30eb f1			.pastdmark: pop af  
30ec			endm  
# End of macro DMARK
30ec						CALLMONITOR 
30ec cd 6f ee			call debug_vector  
30ef				endm  
# End of macro CALLMONITOR
30ef					endif 
30ef					FORTH_DSP_POP 
30ef cd 05 1f			call macro_forth_dsp_pop 
30f2				endm 
# End of macro FORTH_DSP_POP
30f2			 
30f2			; put counters on the loop stack 
30f2			 
30f2			;		pop hl			 ; limit counter 
30f2 d1					pop de			; start counter 
30f3			 
30f3					; push limit counter 
30f3			 
30f3					if DEBUG_FORTH_WORDS 
30f3						DMARK "DO7" 
30f3 f5				push af  
30f4 3a 08 31			ld a, (.dmark)  
30f7 32 6b ee			ld (debug_mark),a  
30fa 3a 09 31			ld a, (.dmark+1)  
30fd 32 6c ee			ld (debug_mark+1),a  
3100 3a 0a 31			ld a, (.dmark+2)  
3103 32 6d ee			ld (debug_mark+2),a  
3106 18 03			jr .pastdmark  
3108 ..			.dmark: db "DO7"  
310b f1			.pastdmark: pop af  
310c			endm  
# End of macro DMARK
310c						CALLMONITOR 
310c cd 6f ee			call debug_vector  
310f				endm  
# End of macro CALLMONITOR
310f					endif 
310f					FORTH_LOOP_NEXT 
310f cd 7e 1e			call macro_forth_loop_next 
3112				endm 
# End of macro FORTH_LOOP_NEXT
3112			 
3112					; push start counter 
3112			 
3112 eb					ex de, hl 
3113					if DEBUG_FORTH_WORDS 
3113						DMARK "DO7" 
3113 f5				push af  
3114 3a 28 31			ld a, (.dmark)  
3117 32 6b ee			ld (debug_mark),a  
311a 3a 29 31			ld a, (.dmark+1)  
311d 32 6c ee			ld (debug_mark+1),a  
3120 3a 2a 31			ld a, (.dmark+2)  
3123 32 6d ee			ld (debug_mark+2),a  
3126 18 03			jr .pastdmark  
3128 ..			.dmark: db "DO7"  
312b f1			.pastdmark: pop af  
312c			endm  
# End of macro DMARK
312c						CALLMONITOR 
312c cd 6f ee			call debug_vector  
312f				endm  
# End of macro CALLMONITOR
312f					endif 
312f					FORTH_LOOP_NEXT 
312f cd 7e 1e			call macro_forth_loop_next 
3132				endm 
# End of macro FORTH_LOOP_NEXT
3132			 
3132			 
3132					; init first round of I counter 
3132			 
3132 22 e6 e5				ld (os_current_i), hl 
3135			 
3135					if DEBUG_FORTH_WORDS 
3135						DMARK "DO8" 
3135 f5				push af  
3136 3a 4a 31			ld a, (.dmark)  
3139 32 6b ee			ld (debug_mark),a  
313c 3a 4b 31			ld a, (.dmark+1)  
313f 32 6c ee			ld (debug_mark+1),a  
3142 3a 4c 31			ld a, (.dmark+2)  
3145 32 6d ee			ld (debug_mark+2),a  
3148 18 03			jr .pastdmark  
314a ..			.dmark: db "DO8"  
314d f1			.pastdmark: pop af  
314e			endm  
# End of macro DMARK
314e						CALLMONITOR 
314e cd 6f ee			call debug_vector  
3151				endm  
# End of macro CALLMONITOR
3151					endif 
3151			 
3151					NEXTW 
3151 c3 03 20			jp macro_next 
3154				endm 
# End of macro NEXTW
3154			.LOOP: 
3154				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3154 22				db WORD_SYS_CORE+14             
3155 6c 32			dw .I            
3157 05				db 4 + 1 
3158 .. 00			db "LOOP",0              
315d				endm 
# End of macro CWHEAD
315d			; | LOOP ( -- ) Increment and test loop counter  | DONE 
315d			 
315d				; pop tos as current loop count to hl 
315d			 
315d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
315d			 
315d				FORTH_LOOP_TOS 
315d cd b1 1e			call macro_forth_loop_tos 
3160				endm 
# End of macro FORTH_LOOP_TOS
3160 e5				push hl 
3161			 
3161					if DEBUG_FORTH_WORDS_KEY 
3161						DMARK "LOP" 
3161 f5				push af  
3162 3a 76 31			ld a, (.dmark)  
3165 32 6b ee			ld (debug_mark),a  
3168 3a 77 31			ld a, (.dmark+1)  
316b 32 6c ee			ld (debug_mark+1),a  
316e 3a 78 31			ld a, (.dmark+2)  
3171 32 6d ee			ld (debug_mark+2),a  
3174 18 03			jr .pastdmark  
3176 ..			.dmark: db "LOP"  
3179 f1			.pastdmark: pop af  
317a			endm  
# End of macro DMARK
317a						CALLMONITOR 
317a cd 6f ee			call debug_vector  
317d				endm  
# End of macro CALLMONITOR
317d					endif 
317d				; next item on the stack is the limit. get it 
317d			 
317d			 
317d				FORTH_LOOP_POP 
317d cd bb 1e			call macro_forth_loop_pop 
3180				endm 
# End of macro FORTH_LOOP_POP
3180			 
3180				FORTH_LOOP_TOS 
3180 cd b1 1e			call macro_forth_loop_tos 
3183				endm 
# End of macro FORTH_LOOP_TOS
3183			 
3183 d1				pop de		 ; de = i, hl = limit 
3184			 
3184					if DEBUG_FORTH_WORDS 
3184						DMARK "LP1" 
3184 f5				push af  
3185 3a 99 31			ld a, (.dmark)  
3188 32 6b ee			ld (debug_mark),a  
318b 3a 9a 31			ld a, (.dmark+1)  
318e 32 6c ee			ld (debug_mark+1),a  
3191 3a 9b 31			ld a, (.dmark+2)  
3194 32 6d ee			ld (debug_mark+2),a  
3197 18 03			jr .pastdmark  
3199 ..			.dmark: db "LP1"  
319c f1			.pastdmark: pop af  
319d			endm  
# End of macro DMARK
319d						CALLMONITOR 
319d cd 6f ee			call debug_vector  
31a0				endm  
# End of macro CALLMONITOR
31a0					endif 
31a0			 
31a0				; go back to previous word 
31a0			 
31a0 d5				push de    ; save I for inc later 
31a1			 
31a1			 
31a1				; get limit 
31a1				;  is I at limit? 
31a1			 
31a1			 
31a1					if DEBUG_FORTH_WORDS 
31a1						DMARK "LP1" 
31a1 f5				push af  
31a2 3a b6 31			ld a, (.dmark)  
31a5 32 6b ee			ld (debug_mark),a  
31a8 3a b7 31			ld a, (.dmark+1)  
31ab 32 6c ee			ld (debug_mark+1),a  
31ae 3a b8 31			ld a, (.dmark+2)  
31b1 32 6d ee			ld (debug_mark+2),a  
31b4 18 03			jr .pastdmark  
31b6 ..			.dmark: db "LP1"  
31b9 f1			.pastdmark: pop af  
31ba			endm  
# End of macro DMARK
31ba						CALLMONITOR 
31ba cd 6f ee			call debug_vector  
31bd				endm  
# End of macro CALLMONITOR
31bd					endif 
31bd			 
31bd ed 52			sbc hl, de 
31bf			 
31bf			 
31bf				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31bf			 
31bf 20 26				jr nz, .loopnotdone 
31c1			 
31c1 e1				pop hl   ; get rid of saved I 
31c2				FORTH_LOOP_POP     ; get rid of limit 
31c2 cd bb 1e			call macro_forth_loop_pop 
31c5				endm 
# End of macro FORTH_LOOP_POP
31c5			 
31c5				FORTH_RSP_POP     ; get rid of DO ptr 
31c5 cd 1e 1c			call macro_forth_rsp_pop 
31c8				endm 
# End of macro FORTH_RSP_POP
31c8			 
31c8			if DEBUG_FORTH_WORDS 
31c8						DMARK "LP>" 
31c8 f5				push af  
31c9 3a dd 31			ld a, (.dmark)  
31cc 32 6b ee			ld (debug_mark),a  
31cf 3a de 31			ld a, (.dmark+1)  
31d2 32 6c ee			ld (debug_mark+1),a  
31d5 3a df 31			ld a, (.dmark+2)  
31d8 32 6d ee			ld (debug_mark+2),a  
31db 18 03			jr .pastdmark  
31dd ..			.dmark: db "LP>"  
31e0 f1			.pastdmark: pop af  
31e1			endm  
# End of macro DMARK
31e1				CALLMONITOR 
31e1 cd 6f ee			call debug_vector  
31e4				endm  
# End of macro CALLMONITOR
31e4			endif 
31e4			 
31e4					NEXTW 
31e4 c3 03 20			jp macro_next 
31e7				endm 
# End of macro NEXTW
31e7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31e7			 
31e7			.loopnotdone: 
31e7			 
31e7 e1				pop hl    ; get I 
31e8 23				inc hl 
31e9			 
31e9			   	; save new I 
31e9			 
31e9			 
31e9					; set I counter 
31e9			 
31e9 22 e6 e5				ld (os_current_i), hl 
31ec			 
31ec					if DEBUG_FORTH_WORDS 
31ec						DMARK "LPN" 
31ec f5				push af  
31ed 3a 01 32			ld a, (.dmark)  
31f0 32 6b ee			ld (debug_mark),a  
31f3 3a 02 32			ld a, (.dmark+1)  
31f6 32 6c ee			ld (debug_mark+1),a  
31f9 3a 03 32			ld a, (.dmark+2)  
31fc 32 6d ee			ld (debug_mark+2),a  
31ff 18 03			jr .pastdmark  
3201 ..			.dmark: db "LPN"  
3204 f1			.pastdmark: pop af  
3205			endm  
# End of macro DMARK
3205					CALLMONITOR 
3205 cd 6f ee			call debug_vector  
3208				endm  
# End of macro CALLMONITOR
3208					endif 
3208					 
3208				FORTH_LOOP_NEXT 
3208 cd 7e 1e			call macro_forth_loop_next 
320b				endm 
# End of macro FORTH_LOOP_NEXT
320b			 
320b			 
320b					if DEBUG_FORTH_WORDS 
320b eb						ex de,hl 
320c					endif 
320c			 
320c			;	; get DO ptr 
320c			; 
320c					if DEBUG_FORTH_WORDS 
320c						DMARK "LP7" 
320c f5				push af  
320d 3a 21 32			ld a, (.dmark)  
3210 32 6b ee			ld (debug_mark),a  
3213 3a 22 32			ld a, (.dmark+1)  
3216 32 6c ee			ld (debug_mark+1),a  
3219 3a 23 32			ld a, (.dmark+2)  
321c 32 6d ee			ld (debug_mark+2),a  
321f 18 03			jr .pastdmark  
3221 ..			.dmark: db "LP7"  
3224 f1			.pastdmark: pop af  
3225			endm  
# End of macro DMARK
3225					CALLMONITOR 
3225 cd 6f ee			call debug_vector  
3228				endm  
# End of macro CALLMONITOR
3228					endif 
3228				FORTH_RSP_TOS 
3228 cd 14 1c			call macro_forth_rsp_tos 
322b				endm 
# End of macro FORTH_RSP_TOS
322b			 
322b					if DEBUG_FORTH_WORDS 
322b						DMARK "LP8" 
322b f5				push af  
322c 3a 40 32			ld a, (.dmark)  
322f 32 6b ee			ld (debug_mark),a  
3232 3a 41 32			ld a, (.dmark+1)  
3235 32 6c ee			ld (debug_mark+1),a  
3238 3a 42 32			ld a, (.dmark+2)  
323b 32 6d ee			ld (debug_mark+2),a  
323e 18 03			jr .pastdmark  
3240 ..			.dmark: db "LP8"  
3243 f1			.pastdmark: pop af  
3244			endm  
# End of macro DMARK
3244					CALLMONITOR 
3244 cd 6f ee			call debug_vector  
3247				endm  
# End of macro CALLMONITOR
3247					endif 
3247				;push hl 
3247			 
3247				; not going to DO any more 
3247				; get rid of the RSP pointer as DO will add it back in 
3247				;FORTH_RSP_POP 
3247				;pop hl 
3247			 
3247				;ld hl,(cli_ret_sp) 
3247				;ld e, (hl) 
3247				;inc hl 
3247				;ld d, (hl) 
3247				;ex de,hl 
3247 22 c2 e5			ld (os_tok_ptr), hl 
324a					if DEBUG_FORTH_WORDS 
324a						DMARK "LP<" 
324a f5				push af  
324b 3a 5f 32			ld a, (.dmark)  
324e 32 6b ee			ld (debug_mark),a  
3251 3a 60 32			ld a, (.dmark+1)  
3254 32 6c ee			ld (debug_mark+1),a  
3257 3a 61 32			ld a, (.dmark+2)  
325a 32 6d ee			ld (debug_mark+2),a  
325d 18 03			jr .pastdmark  
325f ..			.dmark: db "LP<"  
3262 f1			.pastdmark: pop af  
3263			endm  
# End of macro DMARK
3263					CALLMONITOR 
3263 cd 6f ee			call debug_vector  
3266				endm  
# End of macro CALLMONITOR
3266				endif 
3266 c3 94 20			jp exec1 
3269			 
3269					 
3269			 
3269			 
3269					NEXTW 
3269 c3 03 20			jp macro_next 
326c				endm 
# End of macro NEXTW
326c			.I:  
326c			 
326c				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
326c 5e				db WORD_SYS_CORE+74             
326d 97 32			dw .DLOOP            
326f 02				db 1 + 1 
3270 .. 00			db "I",0              
3272				endm 
# End of macro CWHEAD
3272			; | I ( -- ) Current loop counter | DONE 
3272					if DEBUG_FORTH_WORDS_KEY 
3272						DMARK "I.." 
3272 f5				push af  
3273 3a 87 32			ld a, (.dmark)  
3276 32 6b ee			ld (debug_mark),a  
3279 3a 88 32			ld a, (.dmark+1)  
327c 32 6c ee			ld (debug_mark+1),a  
327f 3a 89 32			ld a, (.dmark+2)  
3282 32 6d ee			ld (debug_mark+2),a  
3285 18 03			jr .pastdmark  
3287 ..			.dmark: db "I.."  
328a f1			.pastdmark: pop af  
328b			endm  
# End of macro DMARK
328b						CALLMONITOR 
328b cd 6f ee			call debug_vector  
328e				endm  
# End of macro CALLMONITOR
328e					endif 
328e			 
328e 2a e6 e5				ld hl,(os_current_i) 
3291 cd 56 1c				call forth_push_numhl 
3294			 
3294					NEXTW 
3294 c3 03 20			jp macro_next 
3297				endm 
# End of macro NEXTW
3297			.DLOOP: 
3297				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3297 5f				db WORD_SYS_CORE+75             
3298 78 33			dw .REPEAT            
329a 06				db 5 + 1 
329b .. 00			db "-LOOP",0              
32a1				endm 
# End of macro CWHEAD
32a1			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32a1				; pop tos as current loop count to hl 
32a1					if DEBUG_FORTH_WORDS_KEY 
32a1						DMARK "-LP" 
32a1 f5				push af  
32a2 3a b6 32			ld a, (.dmark)  
32a5 32 6b ee			ld (debug_mark),a  
32a8 3a b7 32			ld a, (.dmark+1)  
32ab 32 6c ee			ld (debug_mark+1),a  
32ae 3a b8 32			ld a, (.dmark+2)  
32b1 32 6d ee			ld (debug_mark+2),a  
32b4 18 03			jr .pastdmark  
32b6 ..			.dmark: db "-LP"  
32b9 f1			.pastdmark: pop af  
32ba			endm  
# End of macro DMARK
32ba						CALLMONITOR 
32ba cd 6f ee			call debug_vector  
32bd				endm  
# End of macro CALLMONITOR
32bd					endif 
32bd			 
32bd				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32bd			 
32bd				FORTH_LOOP_TOS 
32bd cd b1 1e			call macro_forth_loop_tos 
32c0				endm 
# End of macro FORTH_LOOP_TOS
32c0 e5				push hl 
32c1			 
32c1					if DEBUG_FORTH_WORDS 
32c1						DMARK "-LP" 
32c1 f5				push af  
32c2 3a d6 32			ld a, (.dmark)  
32c5 32 6b ee			ld (debug_mark),a  
32c8 3a d7 32			ld a, (.dmark+1)  
32cb 32 6c ee			ld (debug_mark+1),a  
32ce 3a d8 32			ld a, (.dmark+2)  
32d1 32 6d ee			ld (debug_mark+2),a  
32d4 18 03			jr .pastdmark  
32d6 ..			.dmark: db "-LP"  
32d9 f1			.pastdmark: pop af  
32da			endm  
# End of macro DMARK
32da						CALLMONITOR 
32da cd 6f ee			call debug_vector  
32dd				endm  
# End of macro CALLMONITOR
32dd					endif 
32dd				; next item on the stack is the limit. get it 
32dd			 
32dd			 
32dd				FORTH_LOOP_POP 
32dd cd bb 1e			call macro_forth_loop_pop 
32e0				endm 
# End of macro FORTH_LOOP_POP
32e0			 
32e0				FORTH_LOOP_TOS 
32e0 cd b1 1e			call macro_forth_loop_tos 
32e3				endm 
# End of macro FORTH_LOOP_TOS
32e3			 
32e3 d1				pop de		 ; de = i, hl = limit 
32e4			 
32e4					if DEBUG_FORTH_WORDS 
32e4						DMARK "-L1" 
32e4 f5				push af  
32e5 3a f9 32			ld a, (.dmark)  
32e8 32 6b ee			ld (debug_mark),a  
32eb 3a fa 32			ld a, (.dmark+1)  
32ee 32 6c ee			ld (debug_mark+1),a  
32f1 3a fb 32			ld a, (.dmark+2)  
32f4 32 6d ee			ld (debug_mark+2),a  
32f7 18 03			jr .pastdmark  
32f9 ..			.dmark: db "-L1"  
32fc f1			.pastdmark: pop af  
32fd			endm  
# End of macro DMARK
32fd						CALLMONITOR 
32fd cd 6f ee			call debug_vector  
3300				endm  
# End of macro CALLMONITOR
3300					endif 
3300			 
3300				; go back to previous word 
3300			 
3300 d5				push de    ; save I for inc later 
3301			 
3301			 
3301				; get limit 
3301				;  is I at limit? 
3301			 
3301			 
3301					if DEBUG_FORTH_WORDS 
3301						DMARK "-L1" 
3301 f5				push af  
3302 3a 16 33			ld a, (.dmark)  
3305 32 6b ee			ld (debug_mark),a  
3308 3a 17 33			ld a, (.dmark+1)  
330b 32 6c ee			ld (debug_mark+1),a  
330e 3a 18 33			ld a, (.dmark+2)  
3311 32 6d ee			ld (debug_mark+2),a  
3314 18 03			jr .pastdmark  
3316 ..			.dmark: db "-L1"  
3319 f1			.pastdmark: pop af  
331a			endm  
# End of macro DMARK
331a						CALLMONITOR 
331a cd 6f ee			call debug_vector  
331d				endm  
# End of macro CALLMONITOR
331d					endif 
331d			 
331d ed 52			sbc hl, de 
331f			 
331f			 
331f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
331f			 
331f 20 26				jr nz, .mloopnotdone 
3321			 
3321 e1				pop hl   ; get rid of saved I 
3322				FORTH_LOOP_POP     ; get rid of limit 
3322 cd bb 1e			call macro_forth_loop_pop 
3325				endm 
# End of macro FORTH_LOOP_POP
3325			 
3325				FORTH_RSP_POP     ; get rid of DO ptr 
3325 cd 1e 1c			call macro_forth_rsp_pop 
3328				endm 
# End of macro FORTH_RSP_POP
3328			 
3328			if DEBUG_FORTH_WORDS 
3328						DMARK "-L>" 
3328 f5				push af  
3329 3a 3d 33			ld a, (.dmark)  
332c 32 6b ee			ld (debug_mark),a  
332f 3a 3e 33			ld a, (.dmark+1)  
3332 32 6c ee			ld (debug_mark+1),a  
3335 3a 3f 33			ld a, (.dmark+2)  
3338 32 6d ee			ld (debug_mark+2),a  
333b 18 03			jr .pastdmark  
333d ..			.dmark: db "-L>"  
3340 f1			.pastdmark: pop af  
3341			endm  
# End of macro DMARK
3341				CALLMONITOR 
3341 cd 6f ee			call debug_vector  
3344				endm  
# End of macro CALLMONITOR
3344			endif 
3344			 
3344					NEXTW 
3344 c3 03 20			jp macro_next 
3347				endm 
# End of macro NEXTW
3347				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3347			 
3347			.mloopnotdone: 
3347			 
3347 e1				pop hl    ; get I 
3348 2b				dec hl 
3349			 
3349			   	; save new I 
3349			 
3349			 
3349					; set I counter 
3349			 
3349 22 e6 e5				ld (os_current_i), hl 
334c			 
334c					 
334c				FORTH_LOOP_NEXT 
334c cd 7e 1e			call macro_forth_loop_next 
334f				endm 
# End of macro FORTH_LOOP_NEXT
334f			 
334f			 
334f					if DEBUG_FORTH_WORDS 
334f eb						ex de,hl 
3350					endif 
3350			 
3350			;	; get DO ptr 
3350			; 
3350				FORTH_RSP_TOS 
3350 cd 14 1c			call macro_forth_rsp_tos 
3353				endm 
# End of macro FORTH_RSP_TOS
3353			 
3353				;push hl 
3353			 
3353				; not going to DO any more 
3353				; get rid of the RSP pointer as DO will add it back in 
3353				;FORTH_RSP_POP 
3353				;pop hl 
3353			 
3353			 
3353 22 c2 e5			ld (os_tok_ptr), hl 
3356					if DEBUG_FORTH_WORDS 
3356						DMARK "-L<" 
3356 f5				push af  
3357 3a 6b 33			ld a, (.dmark)  
335a 32 6b ee			ld (debug_mark),a  
335d 3a 6c 33			ld a, (.dmark+1)  
3360 32 6c ee			ld (debug_mark+1),a  
3363 3a 6d 33			ld a, (.dmark+2)  
3366 32 6d ee			ld (debug_mark+2),a  
3369 18 03			jr .pastdmark  
336b ..			.dmark: db "-L<"  
336e f1			.pastdmark: pop af  
336f			endm  
# End of macro DMARK
336f					CALLMONITOR 
336f cd 6f ee			call debug_vector  
3372				endm  
# End of macro CALLMONITOR
3372				endif 
3372 c3 94 20			jp exec1 
3375			 
3375					 
3375			 
3375			 
3375			 
3375				NEXTW 
3375 c3 03 20			jp macro_next 
3378				endm 
# End of macro NEXTW
3378			 
3378			 
3378			 
3378			 
3378			.REPEAT: 
3378				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3378 71				db WORD_SYS_CORE+93             
3379 cb 33			dw .UNTIL            
337b 06				db 5 + 1 
337c .. 00			db "REPEAT",0              
3383				endm 
# End of macro CWHEAD
3383			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3383			;  push pc to rsp stack past the REPEAT 
3383					if DEBUG_FORTH_WORDS_KEY 
3383						DMARK "REP" 
3383 f5				push af  
3384 3a 98 33			ld a, (.dmark)  
3387 32 6b ee			ld (debug_mark),a  
338a 3a 99 33			ld a, (.dmark+1)  
338d 32 6c ee			ld (debug_mark+1),a  
3390 3a 9a 33			ld a, (.dmark+2)  
3393 32 6d ee			ld (debug_mark+2),a  
3396 18 03			jr .pastdmark  
3398 ..			.dmark: db "REP"  
339b f1			.pastdmark: pop af  
339c			endm  
# End of macro DMARK
339c						CALLMONITOR 
339c cd 6f ee			call debug_vector  
339f				endm  
# End of macro CALLMONITOR
339f					endif 
339f			 
339f 2a c2 e5				ld hl, (os_tok_ptr) 
33a2 23					inc hl   ; R 
33a3 23					inc hl  ; E 
33a4 23					inc hl   ; P 
33a5 23					inc hl   ; E 
33a6 23					inc hl   ; A 
33a7 23					inc hl   ; T 
33a8 23					inc hl   ; zero 
33a9					FORTH_RSP_NEXT 
33a9 cd fd 1b			call macro_forth_rsp_next 
33ac				endm 
# End of macro FORTH_RSP_NEXT
33ac			 
33ac			 
33ac					if DEBUG_FORTH_WORDS 
33ac						DMARK "REP" 
33ac f5				push af  
33ad 3a c1 33			ld a, (.dmark)  
33b0 32 6b ee			ld (debug_mark),a  
33b3 3a c2 33			ld a, (.dmark+1)  
33b6 32 6c ee			ld (debug_mark+1),a  
33b9 3a c3 33			ld a, (.dmark+2)  
33bc 32 6d ee			ld (debug_mark+2),a  
33bf 18 03			jr .pastdmark  
33c1 ..			.dmark: db "REP"  
33c4 f1			.pastdmark: pop af  
33c5			endm  
# End of macro DMARK
33c5						;pop bc    ; TODO BUG ?????? what is this for???? 
33c5						CALLMONITOR 
33c5 cd 6f ee			call debug_vector  
33c8				endm  
# End of macro CALLMONITOR
33c8					endif 
33c8			 
33c8					NEXTW 
33c8 c3 03 20			jp macro_next 
33cb				endm 
# End of macro NEXTW
33cb			;	       NEXTW 
33cb			 
33cb			.UNTIL: 
33cb				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33cb 72				db WORD_SYS_CORE+94             
33cc 62 34			dw .ENDFLOW            
33ce 06				db 5 + 1 
33cf .. 00			db "UNTIL",0              
33d5				endm 
# End of macro CWHEAD
33d5			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
33d5			 
33d5				; pop tos as check 
33d5			 
33d5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33d5			 
33d5				FORTH_DSP_VALUEHL 
33d5 cd 4d 1e			call macro_dsp_valuehl 
33d8				endm 
# End of macro FORTH_DSP_VALUEHL
33d8			 
33d8					if DEBUG_FORTH_WORDS_KEY 
33d8						DMARK "UNT" 
33d8 f5				push af  
33d9 3a ed 33			ld a, (.dmark)  
33dc 32 6b ee			ld (debug_mark),a  
33df 3a ee 33			ld a, (.dmark+1)  
33e2 32 6c ee			ld (debug_mark+1),a  
33e5 3a ef 33			ld a, (.dmark+2)  
33e8 32 6d ee			ld (debug_mark+2),a  
33eb 18 03			jr .pastdmark  
33ed ..			.dmark: db "UNT"  
33f0 f1			.pastdmark: pop af  
33f1			endm  
# End of macro DMARK
33f1						CALLMONITOR 
33f1 cd 6f ee			call debug_vector  
33f4				endm  
# End of macro CALLMONITOR
33f4					endif 
33f4			 
33f4			;	push hl 
33f4				FORTH_DSP_POP 
33f4 cd 05 1f			call macro_forth_dsp_pop 
33f7				endm 
# End of macro FORTH_DSP_POP
33f7			 
33f7			;	pop hl 
33f7			 
33f7				; test if true 
33f7			 
33f7 cd 10 0e			call ishlzero 
33fa			;	ld a,l 
33fa			;	add h 
33fa			; 
33fa			;	cp 0 
33fa			 
33fa 20 3e			jr nz, .untilnotdone 
33fc			 
33fc					if DEBUG_FORTH_WORDS 
33fc						DMARK "UNf" 
33fc f5				push af  
33fd 3a 11 34			ld a, (.dmark)  
3400 32 6b ee			ld (debug_mark),a  
3403 3a 12 34			ld a, (.dmark+1)  
3406 32 6c ee			ld (debug_mark+1),a  
3409 3a 13 34			ld a, (.dmark+2)  
340c 32 6d ee			ld (debug_mark+2),a  
340f 18 03			jr .pastdmark  
3411 ..			.dmark: db "UNf"  
3414 f1			.pastdmark: pop af  
3415			endm  
# End of macro DMARK
3415						CALLMONITOR 
3415 cd 6f ee			call debug_vector  
3418				endm  
# End of macro CALLMONITOR
3418					endif 
3418			 
3418			 
3418			 
3418				FORTH_RSP_POP     ; get rid of DO ptr 
3418 cd 1e 1c			call macro_forth_rsp_pop 
341b				endm 
# End of macro FORTH_RSP_POP
341b			 
341b			if DEBUG_FORTH_WORDS 
341b						DMARK "UN>" 
341b f5				push af  
341c 3a 30 34			ld a, (.dmark)  
341f 32 6b ee			ld (debug_mark),a  
3422 3a 31 34			ld a, (.dmark+1)  
3425 32 6c ee			ld (debug_mark+1),a  
3428 3a 32 34			ld a, (.dmark+2)  
342b 32 6d ee			ld (debug_mark+2),a  
342e 18 03			jr .pastdmark  
3430 ..			.dmark: db "UN>"  
3433 f1			.pastdmark: pop af  
3434			endm  
# End of macro DMARK
3434				CALLMONITOR 
3434 cd 6f ee			call debug_vector  
3437				endm  
# End of macro CALLMONITOR
3437			endif 
3437			 
3437					NEXTW 
3437 c3 03 20			jp macro_next 
343a				endm 
# End of macro NEXTW
343a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
343a			 
343a			.untilnotdone: 
343a			 
343a			 
343a			;	; get DO ptr 
343a			; 
343a				FORTH_RSP_TOS 
343a cd 14 1c			call macro_forth_rsp_tos 
343d				endm 
# End of macro FORTH_RSP_TOS
343d			 
343d				;push hl 
343d			 
343d				; not going to DO any more 
343d				; get rid of the RSP pointer as DO will add it back in 
343d				;FORTH_RSP_POP 
343d				;pop hl 
343d			 
343d			 
343d 22 c2 e5			ld (os_tok_ptr), hl 
3440					if DEBUG_FORTH_WORDS 
3440						DMARK "UN<" 
3440 f5				push af  
3441 3a 55 34			ld a, (.dmark)  
3444 32 6b ee			ld (debug_mark),a  
3447 3a 56 34			ld a, (.dmark+1)  
344a 32 6c ee			ld (debug_mark+1),a  
344d 3a 57 34			ld a, (.dmark+2)  
3450 32 6d ee			ld (debug_mark+2),a  
3453 18 03			jr .pastdmark  
3455 ..			.dmark: db "UN<"  
3458 f1			.pastdmark: pop af  
3459			endm  
# End of macro DMARK
3459					CALLMONITOR 
3459 cd 6f ee			call debug_vector  
345c				endm  
# End of macro CALLMONITOR
345c				endif 
345c c3 94 20			jp exec1 
345f			 
345f					 
345f			 
345f			 
345f					NEXTW 
345f c3 03 20			jp macro_next 
3462				endm 
# End of macro NEXTW
3462			 
3462			 
3462			.ENDFLOW: 
3462			 
3462			; eof 
3462			 
# End of file forth_words_flow.asm
3462			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3462			include "forth_words_logic.asm" 
3462			 
3462			; | ## Logic Words 
3462			 
3462			.NOT: 
3462				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3462 2d				db WORD_SYS_CORE+25             
3463 aa 34			dw .IS            
3465 04				db 3 + 1 
3466 .. 00			db "NOT",0              
346a				endm 
# End of macro CWHEAD
346a			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
346a					if DEBUG_FORTH_WORDS_KEY 
346a						DMARK "NOT" 
346a f5				push af  
346b 3a 7f 34			ld a, (.dmark)  
346e 32 6b ee			ld (debug_mark),a  
3471 3a 80 34			ld a, (.dmark+1)  
3474 32 6c ee			ld (debug_mark+1),a  
3477 3a 81 34			ld a, (.dmark+2)  
347a 32 6d ee			ld (debug_mark+2),a  
347d 18 03			jr .pastdmark  
347f ..			.dmark: db "NOT"  
3482 f1			.pastdmark: pop af  
3483			endm  
# End of macro DMARK
3483						CALLMONITOR 
3483 cd 6f ee			call debug_vector  
3486				endm  
# End of macro CALLMONITOR
3486					endif 
3486					FORTH_DSP 
3486 cd 13 1e			call macro_forth_dsp 
3489				endm 
# End of macro FORTH_DSP
3489 7e					ld a,(hl)	; get type of value on TOS 
348a fe 02				cp DS_TYPE_INUM  
348c 28 03				jr z, .noti 
348e					NEXTW 
348e c3 03 20			jp macro_next 
3491				endm 
# End of macro NEXTW
3491			.noti:          FORTH_DSP_VALUEHL 
3491 cd 4d 1e			call macro_dsp_valuehl 
3494				endm 
# End of macro FORTH_DSP_VALUEHL
3494			;		push hl 
3494					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3494 cd 05 1f			call macro_forth_dsp_pop 
3497				endm 
# End of macro FORTH_DSP_POP
3497			;		pop hl 
3497 3e 00				ld a,0 
3499 bd					cp l 
349a 28 04				jr z, .not2t 
349c 2e 00				ld l, 0 
349e 18 02				jr .notip 
34a0			 
34a0 2e ff		.not2t:		ld l, 255 
34a2			 
34a2 26 00		.notip:		ld h, 0	 
34a4			 
34a4 cd 56 1c				call forth_push_numhl 
34a7					NEXTW 
34a7 c3 03 20			jp macro_next 
34aa				endm 
# End of macro NEXTW
34aa			 
34aa			.IS: 
34aa				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34aa 2d				db WORD_SYS_CORE+25             
34ab d0 34			dw .LZERO            
34ad 03				db 2 + 1 
34ae .. 00			db "IS",0              
34b1				endm 
# End of macro CWHEAD
34b1			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34b1					if DEBUG_FORTH_WORDS_KEY 
34b1						DMARK "IS." 
34b1 f5				push af  
34b2 3a c6 34			ld a, (.dmark)  
34b5 32 6b ee			ld (debug_mark),a  
34b8 3a c7 34			ld a, (.dmark+1)  
34bb 32 6c ee			ld (debug_mark+1),a  
34be 3a c8 34			ld a, (.dmark+2)  
34c1 32 6d ee			ld (debug_mark+2),a  
34c4 18 03			jr .pastdmark  
34c6 ..			.dmark: db "IS."  
34c9 f1			.pastdmark: pop af  
34ca			endm  
# End of macro DMARK
34ca						CALLMONITOR 
34ca cd 6f ee			call debug_vector  
34cd				endm  
# End of macro CALLMONITOR
34cd					endif 
34cd					NEXTW 
34cd c3 03 20			jp macro_next 
34d0				endm 
# End of macro NEXTW
34d0			.LZERO: 
34d0				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
34d0 2d				db WORD_SYS_CORE+25             
34d1 da 34			dw .TZERO            
34d3 03				db 2 + 1 
34d4 .. 00			db "0<",0              
34d7				endm 
# End of macro CWHEAD
34d7			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
34d7					NEXTW 
34d7 c3 03 20			jp macro_next 
34da				endm 
# End of macro NEXTW
34da			.TZERO: 
34da				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34da 2e				db WORD_SYS_CORE+26             
34db 21 35			dw .LESS            
34dd 03				db 2 + 1 
34de .. 00			db "0=",0              
34e1				endm 
# End of macro CWHEAD
34e1			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
34e1				; TODO add floating point number detection 
34e1					;v5 FORTH_DSP_VALUE 
34e1					if DEBUG_FORTH_WORDS_KEY 
34e1						DMARK "0=." 
34e1 f5				push af  
34e2 3a f6 34			ld a, (.dmark)  
34e5 32 6b ee			ld (debug_mark),a  
34e8 3a f7 34			ld a, (.dmark+1)  
34eb 32 6c ee			ld (debug_mark+1),a  
34ee 3a f8 34			ld a, (.dmark+2)  
34f1 32 6d ee			ld (debug_mark+2),a  
34f4 18 03			jr .pastdmark  
34f6 ..			.dmark: db "0=."  
34f9 f1			.pastdmark: pop af  
34fa			endm  
# End of macro DMARK
34fa						CALLMONITOR 
34fa cd 6f ee			call debug_vector  
34fd				endm  
# End of macro CALLMONITOR
34fd					endif 
34fd					FORTH_DSP 
34fd cd 13 1e			call macro_forth_dsp 
3500				endm 
# End of macro FORTH_DSP
3500 7e					ld a,(hl)	; get type of value on TOS 
3501 fe 02				cp DS_TYPE_INUM  
3503 28 00				jr z, .tz_inum 
3505			 
3505				if FORTH_ENABLE_FLOATMATH 
3505					jr .tz_done 
3505			 
3505				endif 
3505					 
3505			 
3505			.tz_inum: 
3505					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3505 cd 4d 1e			call macro_dsp_valuehl 
3508				endm 
# End of macro FORTH_DSP_VALUEHL
3508			 
3508			;		push hl 
3508			 
3508					; destroy value TOS 
3508			 
3508					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3508 cd 05 1f			call macro_forth_dsp_pop 
350b				endm 
# End of macro FORTH_DSP_POP
350b			 
350b			;		pop hl 
350b			 
350b 3e 00				ld a,0 
350d			 
350d bd					cp l 
350e 20 08				jr nz, .tz_notzero 
3510			 
3510 bc					cp h 
3511			 
3511 20 05				jr nz, .tz_notzero 
3513			 
3513			 
3513 21 01 00				ld hl, FORTH_TRUE 
3516 18 03				jr .tz_done 
3518			 
3518 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
351b			 
351b					; push value back onto stack for another op etc 
351b			 
351b			.tz_done: 
351b cd 56 1c				call forth_push_numhl 
351e			 
351e					NEXTW 
351e c3 03 20			jp macro_next 
3521				endm 
# End of macro NEXTW
3521			.LESS: 
3521				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3521 2f				db WORD_SYS_CORE+27             
3522 8a 35			dw .GT            
3524 02				db 1 + 1 
3525 .. 00			db "<",0              
3527				endm 
# End of macro CWHEAD
3527			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3527				; TODO add floating point number detection 
3527					if DEBUG_FORTH_WORDS_KEY 
3527						DMARK "LES" 
3527 f5				push af  
3528 3a 3c 35			ld a, (.dmark)  
352b 32 6b ee			ld (debug_mark),a  
352e 3a 3d 35			ld a, (.dmark+1)  
3531 32 6c ee			ld (debug_mark+1),a  
3534 3a 3e 35			ld a, (.dmark+2)  
3537 32 6d ee			ld (debug_mark+2),a  
353a 18 03			jr .pastdmark  
353c ..			.dmark: db "LES"  
353f f1			.pastdmark: pop af  
3540			endm  
# End of macro DMARK
3540						CALLMONITOR 
3540 cd 6f ee			call debug_vector  
3543				endm  
# End of macro CALLMONITOR
3543					endif 
3543					FORTH_DSP 
3543 cd 13 1e			call macro_forth_dsp 
3546				endm 
# End of macro FORTH_DSP
3546					;v5 FORTH_DSP_VALUE 
3546 7e					ld a,(hl)	; get type of value on TOS 
3547 fe 02				cp DS_TYPE_INUM  
3549 28 00				jr z, .less_inum 
354b			 
354b				if FORTH_ENABLE_FLOATMATH 
354b					jr .less_done 
354b			 
354b				endif 
354b					 
354b			 
354b			.less_inum: 
354b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
354b cd 4d 1e			call macro_dsp_valuehl 
354e				endm 
# End of macro FORTH_DSP_VALUEHL
354e			 
354e e5					push hl  ; u2 
354f			 
354f					; destroy value TOS 
354f			 
354f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
354f cd 05 1f			call macro_forth_dsp_pop 
3552				endm 
# End of macro FORTH_DSP_POP
3552			 
3552			 
3552					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3552 cd 4d 1e			call macro_dsp_valuehl 
3555				endm 
# End of macro FORTH_DSP_VALUEHL
3555			 
3555 e5					push hl    ; u1 
3556			 
3556					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3556 cd 05 1f			call macro_forth_dsp_pop 
3559				endm 
# End of macro FORTH_DSP_POP
3559			 
3559			 
3559 b7			 or a      ;clear carry flag 
355a 01 00 00		 ld bc, FORTH_FALSE 
355d e1			  pop hl    ; u1 
355e d1			  pop de    ; u2 
355f ed 52		  sbc hl,de 
3561 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3563			 
3563 01 01 00		 ld bc, FORTH_TRUE 
3566			.lscont:  
3566 c5					push bc 
3567 e1					pop hl 
3568			 
3568					if DEBUG_FORTH_WORDS 
3568						DMARK "LT1" 
3568 f5				push af  
3569 3a 7d 35			ld a, (.dmark)  
356c 32 6b ee			ld (debug_mark),a  
356f 3a 7e 35			ld a, (.dmark+1)  
3572 32 6c ee			ld (debug_mark+1),a  
3575 3a 7f 35			ld a, (.dmark+2)  
3578 32 6d ee			ld (debug_mark+2),a  
357b 18 03			jr .pastdmark  
357d ..			.dmark: db "LT1"  
3580 f1			.pastdmark: pop af  
3581			endm  
# End of macro DMARK
3581						CALLMONITOR 
3581 cd 6f ee			call debug_vector  
3584				endm  
# End of macro CALLMONITOR
3584					endif 
3584 cd 56 1c				call forth_push_numhl 
3587			 
3587					NEXTW 
3587 c3 03 20			jp macro_next 
358a				endm 
# End of macro NEXTW
358a			.GT: 
358a				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
358a 30				db WORD_SYS_CORE+28             
358b f3 35			dw .EQUAL            
358d 02				db 1 + 1 
358e .. 00			db ">",0              
3590				endm 
# End of macro CWHEAD
3590			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3590				; TODO add floating point number detection 
3590					if DEBUG_FORTH_WORDS_KEY 
3590						DMARK "GRT" 
3590 f5				push af  
3591 3a a5 35			ld a, (.dmark)  
3594 32 6b ee			ld (debug_mark),a  
3597 3a a6 35			ld a, (.dmark+1)  
359a 32 6c ee			ld (debug_mark+1),a  
359d 3a a7 35			ld a, (.dmark+2)  
35a0 32 6d ee			ld (debug_mark+2),a  
35a3 18 03			jr .pastdmark  
35a5 ..			.dmark: db "GRT"  
35a8 f1			.pastdmark: pop af  
35a9			endm  
# End of macro DMARK
35a9						CALLMONITOR 
35a9 cd 6f ee			call debug_vector  
35ac				endm  
# End of macro CALLMONITOR
35ac					endif 
35ac					FORTH_DSP 
35ac cd 13 1e			call macro_forth_dsp 
35af				endm 
# End of macro FORTH_DSP
35af					;FORTH_DSP_VALUE 
35af 7e					ld a,(hl)	; get type of value on TOS 
35b0 fe 02				cp DS_TYPE_INUM  
35b2 28 00				jr z, .gt_inum 
35b4			 
35b4				if FORTH_ENABLE_FLOATMATH 
35b4					jr .gt_done 
35b4			 
35b4				endif 
35b4					 
35b4			 
35b4			.gt_inum: 
35b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35b4 cd 4d 1e			call macro_dsp_valuehl 
35b7				endm 
# End of macro FORTH_DSP_VALUEHL
35b7			 
35b7 e5					push hl  ; u2 
35b8			 
35b8					; destroy value TOS 
35b8			 
35b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35b8 cd 05 1f			call macro_forth_dsp_pop 
35bb				endm 
# End of macro FORTH_DSP_POP
35bb			 
35bb			 
35bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35bb cd 4d 1e			call macro_dsp_valuehl 
35be				endm 
# End of macro FORTH_DSP_VALUEHL
35be			 
35be e5					push hl    ; u1 
35bf			 
35bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35bf cd 05 1f			call macro_forth_dsp_pop 
35c2				endm 
# End of macro FORTH_DSP_POP
35c2			 
35c2			 
35c2 b7			 or a      ;clear carry flag 
35c3 01 00 00		 ld bc, FORTH_FALSE 
35c6 e1			  pop hl    ; u1 
35c7 d1			  pop de    ; u2 
35c8 ed 52		  sbc hl,de 
35ca 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35cc			 
35cc 01 01 00		 ld bc, FORTH_TRUE 
35cf			.gtcont:  
35cf c5					push bc 
35d0 e1					pop hl 
35d1			 
35d1					if DEBUG_FORTH_WORDS 
35d1						DMARK "GT1" 
35d1 f5				push af  
35d2 3a e6 35			ld a, (.dmark)  
35d5 32 6b ee			ld (debug_mark),a  
35d8 3a e7 35			ld a, (.dmark+1)  
35db 32 6c ee			ld (debug_mark+1),a  
35de 3a e8 35			ld a, (.dmark+2)  
35e1 32 6d ee			ld (debug_mark+2),a  
35e4 18 03			jr .pastdmark  
35e6 ..			.dmark: db "GT1"  
35e9 f1			.pastdmark: pop af  
35ea			endm  
# End of macro DMARK
35ea						CALLMONITOR 
35ea cd 6f ee			call debug_vector  
35ed				endm  
# End of macro CALLMONITOR
35ed					endif 
35ed cd 56 1c				call forth_push_numhl 
35f0			 
35f0					NEXTW 
35f0 c3 03 20			jp macro_next 
35f3				endm 
# End of macro NEXTW
35f3			.EQUAL: 
35f3				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
35f3 31				db WORD_SYS_CORE+29             
35f4 5e 36			dw .ENDLOGIC            
35f6 02				db 1 + 1 
35f7 .. 00			db "=",0              
35f9				endm 
# End of macro CWHEAD
35f9			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
35f9				; TODO add floating point number detection 
35f9					if DEBUG_FORTH_WORDS_KEY 
35f9						DMARK "EQ." 
35f9 f5				push af  
35fa 3a 0e 36			ld a, (.dmark)  
35fd 32 6b ee			ld (debug_mark),a  
3600 3a 0f 36			ld a, (.dmark+1)  
3603 32 6c ee			ld (debug_mark+1),a  
3606 3a 10 36			ld a, (.dmark+2)  
3609 32 6d ee			ld (debug_mark+2),a  
360c 18 03			jr .pastdmark  
360e ..			.dmark: db "EQ."  
3611 f1			.pastdmark: pop af  
3612			endm  
# End of macro DMARK
3612						CALLMONITOR 
3612 cd 6f ee			call debug_vector  
3615				endm  
# End of macro CALLMONITOR
3615					endif 
3615					FORTH_DSP 
3615 cd 13 1e			call macro_forth_dsp 
3618				endm 
# End of macro FORTH_DSP
3618					;v5 FORTH_DSP_VALUE 
3618 7e					ld a,(hl)	; get type of value on TOS 
3619 fe 02				cp DS_TYPE_INUM  
361b 28 00				jr z, .eq_inum 
361d			 
361d				if FORTH_ENABLE_FLOATMATH 
361d					jr .eq_done 
361d			 
361d				endif 
361d					 
361d			 
361d			.eq_inum: 
361d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
361d cd 4d 1e			call macro_dsp_valuehl 
3620				endm 
# End of macro FORTH_DSP_VALUEHL
3620			 
3620 e5					push hl 
3621			 
3621					; destroy value TOS 
3621			 
3621					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3621 cd 05 1f			call macro_forth_dsp_pop 
3624				endm 
# End of macro FORTH_DSP_POP
3624			 
3624			 
3624					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3624 cd 4d 1e			call macro_dsp_valuehl 
3627				endm 
# End of macro FORTH_DSP_VALUEHL
3627			 
3627					; one value on hl get other one back 
3627			 
3627 e5					push hl 
3628			 
3628					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3628 cd 05 1f			call macro_forth_dsp_pop 
362b				endm 
# End of macro FORTH_DSP_POP
362b			 
362b 0e 00				ld c, FORTH_FALSE 
362d			 
362d e1					pop hl 
362e d1					pop de 
362f			 
362f 7b					ld a, e 
3630 bd					cp l 
3631			 
3631 20 06				jr nz, .eq_done 
3633			 
3633 7a					ld a, d 
3634 bc					cp h 
3635			 
3635 20 02				jr nz, .eq_done 
3637			 
3637 0e 01				ld c, FORTH_TRUE 
3639					 
3639			 
3639			 
3639			.eq_done: 
3639			 
3639					; TODO push value back onto stack for another op etc 
3639			 
3639 26 00				ld h, 0 
363b 69					ld l, c 
363c					if DEBUG_FORTH_WORDS 
363c						DMARK "EQ1" 
363c f5				push af  
363d 3a 51 36			ld a, (.dmark)  
3640 32 6b ee			ld (debug_mark),a  
3643 3a 52 36			ld a, (.dmark+1)  
3646 32 6c ee			ld (debug_mark+1),a  
3649 3a 53 36			ld a, (.dmark+2)  
364c 32 6d ee			ld (debug_mark+2),a  
364f 18 03			jr .pastdmark  
3651 ..			.dmark: db "EQ1"  
3654 f1			.pastdmark: pop af  
3655			endm  
# End of macro DMARK
3655						CALLMONITOR 
3655 cd 6f ee			call debug_vector  
3658				endm  
# End of macro CALLMONITOR
3658					endif 
3658 cd 56 1c				call forth_push_numhl 
365b			 
365b					NEXTW 
365b c3 03 20			jp macro_next 
365e				endm 
# End of macro NEXTW
365e			 
365e			 
365e			.ENDLOGIC: 
365e			; eof 
365e			 
365e			 
# End of file forth_words_logic.asm
365e			include "forth_words_maths.asm" 
365e			 
365e			; | ## Maths Words 
365e			 
365e			.PLUS:	 
365e				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
365e 15				db WORD_SYS_CORE+1             
365f bc 36			dw .NEG            
3661 02				db 1 + 1 
3662 .. 00			db "+",0              
3664				endm 
# End of macro CWHEAD
3664			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3664					if DEBUG_FORTH_WORDS_KEY 
3664						DMARK "PLU" 
3664 f5				push af  
3665 3a 79 36			ld a, (.dmark)  
3668 32 6b ee			ld (debug_mark),a  
366b 3a 7a 36			ld a, (.dmark+1)  
366e 32 6c ee			ld (debug_mark+1),a  
3671 3a 7b 36			ld a, (.dmark+2)  
3674 32 6d ee			ld (debug_mark+2),a  
3677 18 03			jr .pastdmark  
3679 ..			.dmark: db "PLU"  
367c f1			.pastdmark: pop af  
367d			endm  
# End of macro DMARK
367d						CALLMONITOR 
367d cd 6f ee			call debug_vector  
3680				endm  
# End of macro CALLMONITOR
3680					endif 
3680					; add top two values and push back result 
3680			 
3680					;for v5 FORTH_DSP_VALUE 
3680					FORTH_DSP 
3680 cd 13 1e			call macro_forth_dsp 
3683				endm 
# End of macro FORTH_DSP
3683 7e					ld a,(hl)	; get type of value on TOS 
3684 fe 02				cp DS_TYPE_INUM  
3686 28 03				jr z, .dot_inum 
3688			 
3688					NEXTW 
3688 c3 03 20			jp macro_next 
368b				endm 
# End of macro NEXTW
368b			 
368b			; float maths 
368b			 
368b				if FORTH_ENABLE_FLOATMATH 
368b						inc hl      ; now at start of numeric as string 
368b			 
368b					if DEBUG_FORTH_MATHS 
368b						DMARK "ADD" 
368b				CALLMONITOR 
368b					endif 
368b			 
368b					;ld ix, hl 
368b					call CON 
368b			 
368b			 
368b					push hl 
368b					 
368b					 
368b			 
368b						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
368b			 
368b					; get next number 
368b			 
368b						FORTH_DSP_VALUE 
368b			 
368b						inc hl      ; now at start of numeric as string 
368b			 
368b					;ld ix, hl 
368b					call CON 
368b			 
368b					push hl 
368b			 
368b			 
368b						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
368b			 
368b						; TODO do add 
368b			 
368b						call IADD 
368b			 
368b						; TODO get result back as ascii 
368b			 
368b						; TODO push result  
368b			 
368b			 
368b			 
368b						jr .dot_done 
368b				endif 
368b			 
368b			.dot_inum: 
368b			 
368b			 
368b					if DEBUG_FORTH_DOT 
368b						DMARK "+IT" 
368b f5				push af  
368c 3a a0 36			ld a, (.dmark)  
368f 32 6b ee			ld (debug_mark),a  
3692 3a a1 36			ld a, (.dmark+1)  
3695 32 6c ee			ld (debug_mark+1),a  
3698 3a a2 36			ld a, (.dmark+2)  
369b 32 6d ee			ld (debug_mark+2),a  
369e 18 03			jr .pastdmark  
36a0 ..			.dmark: db "+IT"  
36a3 f1			.pastdmark: pop af  
36a4			endm  
# End of macro DMARK
36a4				CALLMONITOR 
36a4 cd 6f ee			call debug_vector  
36a7				endm  
# End of macro CALLMONITOR
36a7					endif 
36a7			 
36a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36a7 cd 4d 1e			call macro_dsp_valuehl 
36aa				endm 
# End of macro FORTH_DSP_VALUEHL
36aa			 
36aa				; TODO add floating point number detection 
36aa			 
36aa e5					push hl 
36ab			 
36ab					; destroy value TOS 
36ab			 
36ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ab cd 05 1f			call macro_forth_dsp_pop 
36ae				endm 
# End of macro FORTH_DSP_POP
36ae			 
36ae			 
36ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ae cd 4d 1e			call macro_dsp_valuehl 
36b1				endm 
# End of macro FORTH_DSP_VALUEHL
36b1			 
36b1					; one value on hl get other one back 
36b1			 
36b1 d1					pop de 
36b2			 
36b2					; do the add 
36b2			 
36b2 19					add hl,de 
36b3			 
36b3					; save it 
36b3			 
36b3			;		push hl	 
36b3			 
36b3					; 
36b3			 
36b3					; destroy value TOS 
36b3			 
36b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b3 cd 05 1f			call macro_forth_dsp_pop 
36b6				endm 
# End of macro FORTH_DSP_POP
36b6			 
36b6					; TODO push value back onto stack for another op etc 
36b6			 
36b6			;		pop hl 
36b6			 
36b6			.dot_done: 
36b6 cd 56 1c				call forth_push_numhl 
36b9			 
36b9					NEXTW 
36b9 c3 03 20			jp macro_next 
36bc				endm 
# End of macro NEXTW
36bc			.NEG: 
36bc			 
36bc				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36bc 17				db WORD_SYS_CORE+3             
36bd ff 36			dw .DIV            
36bf 02				db 1 + 1 
36c0 .. 00			db "-",0              
36c2				endm 
# End of macro CWHEAD
36c2			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36c2					if DEBUG_FORTH_WORDS_KEY 
36c2						DMARK "SUB" 
36c2 f5				push af  
36c3 3a d7 36			ld a, (.dmark)  
36c6 32 6b ee			ld (debug_mark),a  
36c9 3a d8 36			ld a, (.dmark+1)  
36cc 32 6c ee			ld (debug_mark+1),a  
36cf 3a d9 36			ld a, (.dmark+2)  
36d2 32 6d ee			ld (debug_mark+2),a  
36d5 18 03			jr .pastdmark  
36d7 ..			.dmark: db "SUB"  
36da f1			.pastdmark: pop af  
36db			endm  
# End of macro DMARK
36db						CALLMONITOR 
36db cd 6f ee			call debug_vector  
36de				endm  
# End of macro CALLMONITOR
36de					endif 
36de			 
36de			 
36de				; TODO add floating point number detection 
36de					; v5 FORTH_DSP_VALUE 
36de					FORTH_DSP 
36de cd 13 1e			call macro_forth_dsp 
36e1				endm 
# End of macro FORTH_DSP
36e1 7e					ld a,(hl)	; get type of value on TOS 
36e2 fe 02				cp DS_TYPE_INUM  
36e4 28 03				jr z, .neg_inum 
36e6			 
36e6					NEXTW 
36e6 c3 03 20			jp macro_next 
36e9				endm 
# End of macro NEXTW
36e9			 
36e9			; float maths 
36e9			 
36e9				if FORTH_ENABLE_FLOATMATH 
36e9					jr .neg_done 
36e9			 
36e9				endif 
36e9					 
36e9			 
36e9			.neg_inum: 
36e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36e9 cd 4d 1e			call macro_dsp_valuehl 
36ec				endm 
# End of macro FORTH_DSP_VALUEHL
36ec			 
36ec e5					push hl 
36ed			 
36ed					; destroy value TOS 
36ed			 
36ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ed cd 05 1f			call macro_forth_dsp_pop 
36f0				endm 
# End of macro FORTH_DSP_POP
36f0			 
36f0			 
36f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f0 cd 4d 1e			call macro_dsp_valuehl 
36f3				endm 
# End of macro FORTH_DSP_VALUEHL
36f3			 
36f3					; one value on hl get other one back 
36f3			 
36f3 d1					pop de 
36f4			 
36f4					; do the sub 
36f4			;		ex de, hl 
36f4			 
36f4 ed 52				sbc hl,de 
36f6			 
36f6					; save it 
36f6			 
36f6			;		push hl	 
36f6			 
36f6					; 
36f6			 
36f6					; destroy value TOS 
36f6			 
36f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f6 cd 05 1f			call macro_forth_dsp_pop 
36f9				endm 
# End of macro FORTH_DSP_POP
36f9			 
36f9					; TODO push value back onto stack for another op etc 
36f9			 
36f9			;		pop hl 
36f9			 
36f9 cd 56 1c				call forth_push_numhl 
36fc			.neg_done: 
36fc			 
36fc					NEXTW 
36fc c3 03 20			jp macro_next 
36ff				endm 
# End of macro NEXTW
36ff			.DIV: 
36ff				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36ff 18				db WORD_SYS_CORE+4             
3700 4c 37			dw .MUL            
3702 02				db 1 + 1 
3703 .. 00			db "/",0              
3705				endm 
# End of macro CWHEAD
3705			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3705					if DEBUG_FORTH_WORDS_KEY 
3705						DMARK "DIV" 
3705 f5				push af  
3706 3a 1a 37			ld a, (.dmark)  
3709 32 6b ee			ld (debug_mark),a  
370c 3a 1b 37			ld a, (.dmark+1)  
370f 32 6c ee			ld (debug_mark+1),a  
3712 3a 1c 37			ld a, (.dmark+2)  
3715 32 6d ee			ld (debug_mark+2),a  
3718 18 03			jr .pastdmark  
371a ..			.dmark: db "DIV"  
371d f1			.pastdmark: pop af  
371e			endm  
# End of macro DMARK
371e						CALLMONITOR 
371e cd 6f ee			call debug_vector  
3721				endm  
# End of macro CALLMONITOR
3721					endif 
3721				; TODO add floating point number detection 
3721					; v5 FORTH_DSP_VALUE 
3721					FORTH_DSP 
3721 cd 13 1e			call macro_forth_dsp 
3724				endm 
# End of macro FORTH_DSP
3724 7e					ld a,(hl)	; get type of value on TOS 
3725 fe 02				cp DS_TYPE_INUM  
3727 28 03				jr z, .div_inum 
3729			 
3729				if FORTH_ENABLE_FLOATMATH 
3729					jr .div_done 
3729			 
3729				endif 
3729					NEXTW 
3729 c3 03 20			jp macro_next 
372c				endm 
# End of macro NEXTW
372c			.div_inum: 
372c			 
372c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
372c cd 4d 1e			call macro_dsp_valuehl 
372f				endm 
# End of macro FORTH_DSP_VALUEHL
372f			 
372f e5					push hl    ; to go to bc 
3730			 
3730					; destroy value TOS 
3730			 
3730					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3730 cd 05 1f			call macro_forth_dsp_pop 
3733				endm 
# End of macro FORTH_DSP_POP
3733			 
3733			 
3733					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3733 cd 4d 1e			call macro_dsp_valuehl 
3736				endm 
# End of macro FORTH_DSP_VALUEHL
3736			 
3736					; hl to go to de 
3736			 
3736 e5					push hl 
3737			 
3737 c1					pop bc 
3738 d1					pop de		 
3739			 
3739			 
3739					if DEBUG_FORTH_MATHS 
3739						DMARK "DIV" 
3739				CALLMONITOR 
3739					endif 
3739					; one value on hl but move to a get other one back 
3739			 
3739			        
3739 cd 44 0d			call Div16 
373c			 
373c			;	push af	 
373c e5				push hl 
373d c5				push bc 
373e			 
373e					if DEBUG_FORTH_MATHS 
373e						DMARK "DI1" 
373e				CALLMONITOR 
373e					endif 
373e			 
373e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
373e cd 05 1f			call macro_forth_dsp_pop 
3741				endm 
# End of macro FORTH_DSP_POP
3741			 
3741			 
3741			 
3741 e1					pop hl    ; result 
3742			 
3742 cd 56 1c				call forth_push_numhl 
3745			 
3745 e1					pop hl    ; reminder 
3746			;		ld h,0 
3746			;		ld l,d 
3746			 
3746 cd 56 1c				call forth_push_numhl 
3749			.div_done: 
3749					NEXTW 
3749 c3 03 20			jp macro_next 
374c				endm 
# End of macro NEXTW
374c			.MUL: 
374c				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
374c 19				db WORD_SYS_CORE+5             
374d 91 37			dw .MIN            
374f 02				db 1 + 1 
3750 .. 00			db "*",0              
3752				endm 
# End of macro CWHEAD
3752			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3752				; TODO add floating point number detection 
3752					if DEBUG_FORTH_WORDS_KEY 
3752						DMARK "MUL" 
3752 f5				push af  
3753 3a 67 37			ld a, (.dmark)  
3756 32 6b ee			ld (debug_mark),a  
3759 3a 68 37			ld a, (.dmark+1)  
375c 32 6c ee			ld (debug_mark+1),a  
375f 3a 69 37			ld a, (.dmark+2)  
3762 32 6d ee			ld (debug_mark+2),a  
3765 18 03			jr .pastdmark  
3767 ..			.dmark: db "MUL"  
376a f1			.pastdmark: pop af  
376b			endm  
# End of macro DMARK
376b						CALLMONITOR 
376b cd 6f ee			call debug_vector  
376e				endm  
# End of macro CALLMONITOR
376e					endif 
376e					FORTH_DSP 
376e cd 13 1e			call macro_forth_dsp 
3771				endm 
# End of macro FORTH_DSP
3771					; v5 FORTH_DSP_VALUE 
3771 7e					ld a,(hl)	; get type of value on TOS 
3772 fe 02				cp DS_TYPE_INUM  
3774 28 03				jr z, .mul_inum 
3776			 
3776				if FORTH_ENABLE_FLOATMATH 
3776					jr .mul_done 
3776			 
3776				endif 
3776			 
3776					NEXTW 
3776 c3 03 20			jp macro_next 
3779				endm 
# End of macro NEXTW
3779			.mul_inum:	 
3779			 
3779					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3779 cd 4d 1e			call macro_dsp_valuehl 
377c				endm 
# End of macro FORTH_DSP_VALUEHL
377c			 
377c e5					push hl 
377d			 
377d					; destroy value TOS 
377d			 
377d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
377d cd 05 1f			call macro_forth_dsp_pop 
3780				endm 
# End of macro FORTH_DSP_POP
3780			 
3780			 
3780					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3780 cd 4d 1e			call macro_dsp_valuehl 
3783				endm 
# End of macro FORTH_DSP_VALUEHL
3783			 
3783					; one value on hl but move to a get other one back 
3783			 
3783 7d					ld a, l 
3784			 
3784 d1					pop de 
3785			 
3785					; do the mull 
3785			;		ex de, hl 
3785			 
3785 cd 6a 0d				call Mult16 
3788					; save it 
3788			 
3788			;		push hl	 
3788			 
3788					; 
3788			 
3788					; destroy value TOS 
3788			 
3788					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3788 cd 05 1f			call macro_forth_dsp_pop 
378b				endm 
# End of macro FORTH_DSP_POP
378b			 
378b					; TODO push value back onto stack for another op etc 
378b			 
378b			;		pop hl 
378b			 
378b cd 56 1c				call forth_push_numhl 
378e			 
378e			.mul_done: 
378e					NEXTW 
378e c3 03 20			jp macro_next 
3791				endm 
# End of macro NEXTW
3791			 
3791			 
3791			 
3791			 
3791			.MIN: 
3791				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3791 49				db WORD_SYS_CORE+53             
3792 12 38			dw .MAX            
3794 04				db 3 + 1 
3795 .. 00			db "MIN",0              
3799				endm 
# End of macro CWHEAD
3799			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3799					if DEBUG_FORTH_WORDS_KEY 
3799						DMARK "MIN" 
3799 f5				push af  
379a 3a ae 37			ld a, (.dmark)  
379d 32 6b ee			ld (debug_mark),a  
37a0 3a af 37			ld a, (.dmark+1)  
37a3 32 6c ee			ld (debug_mark+1),a  
37a6 3a b0 37			ld a, (.dmark+2)  
37a9 32 6d ee			ld (debug_mark+2),a  
37ac 18 03			jr .pastdmark  
37ae ..			.dmark: db "MIN"  
37b1 f1			.pastdmark: pop af  
37b2			endm  
# End of macro DMARK
37b2						CALLMONITOR 
37b2 cd 6f ee			call debug_vector  
37b5				endm  
# End of macro CALLMONITOR
37b5					endif 
37b5					; get u2 
37b5			 
37b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b5 cd 4d 1e			call macro_dsp_valuehl 
37b8				endm 
# End of macro FORTH_DSP_VALUEHL
37b8			 
37b8 e5					push hl   ; u2 
37b9			 
37b9					; destroy value TOS 
37b9			 
37b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37b9 cd 05 1f			call macro_forth_dsp_pop 
37bc				endm 
# End of macro FORTH_DSP_POP
37bc			 
37bc					; get u1 
37bc			 
37bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37bc cd 4d 1e			call macro_dsp_valuehl 
37bf				endm 
# End of macro FORTH_DSP_VALUEHL
37bf			 
37bf e5					push hl  ; u1 
37c0			 
37c0					; destroy value TOS 
37c0			 
37c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37c0 cd 05 1f			call macro_forth_dsp_pop 
37c3				endm 
# End of macro FORTH_DSP_POP
37c3			 
37c3 b7			 or a      ;clear carry flag 
37c4 e1			  pop hl    ; u1 
37c5 d1			  pop de    ; u2 
37c6 e5				push hl   ; saved in case hl is lowest 
37c7 ed 52		  sbc hl,de 
37c9 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37cb			 
37cb e1				pop hl 
37cc					if DEBUG_FORTH_WORDS 
37cc						DMARK "MIN" 
37cc f5				push af  
37cd 3a e1 37			ld a, (.dmark)  
37d0 32 6b ee			ld (debug_mark),a  
37d3 3a e2 37			ld a, (.dmark+1)  
37d6 32 6c ee			ld (debug_mark+1),a  
37d9 3a e3 37			ld a, (.dmark+2)  
37dc 32 6d ee			ld (debug_mark+2),a  
37df 18 03			jr .pastdmark  
37e1 ..			.dmark: db "MIN"  
37e4 f1			.pastdmark: pop af  
37e5			endm  
# End of macro DMARK
37e5						CALLMONITOR 
37e5 cd 6f ee			call debug_vector  
37e8				endm  
# End of macro CALLMONITOR
37e8					endif 
37e8 cd 56 1c				call forth_push_numhl 
37eb			 
37eb				       NEXTW 
37eb c3 03 20			jp macro_next 
37ee				endm 
# End of macro NEXTW
37ee			 
37ee			.mincont:  
37ee c1				pop bc   ; tidy up 
37ef eb				ex de , hl  
37f0					if DEBUG_FORTH_WORDS 
37f0						DMARK "MI1" 
37f0 f5				push af  
37f1 3a 05 38			ld a, (.dmark)  
37f4 32 6b ee			ld (debug_mark),a  
37f7 3a 06 38			ld a, (.dmark+1)  
37fa 32 6c ee			ld (debug_mark+1),a  
37fd 3a 07 38			ld a, (.dmark+2)  
3800 32 6d ee			ld (debug_mark+2),a  
3803 18 03			jr .pastdmark  
3805 ..			.dmark: db "MI1"  
3808 f1			.pastdmark: pop af  
3809			endm  
# End of macro DMARK
3809						CALLMONITOR 
3809 cd 6f ee			call debug_vector  
380c				endm  
# End of macro CALLMONITOR
380c					endif 
380c cd 56 1c				call forth_push_numhl 
380f			 
380f				       NEXTW 
380f c3 03 20			jp macro_next 
3812				endm 
# End of macro NEXTW
3812			.MAX: 
3812				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3812 4a				db WORD_SYS_CORE+54             
3813 93 38			dw .RND16            
3815 04				db 3 + 1 
3816 .. 00			db "MAX",0              
381a				endm 
# End of macro CWHEAD
381a			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
381a					if DEBUG_FORTH_WORDS_KEY 
381a						DMARK "MAX" 
381a f5				push af  
381b 3a 2f 38			ld a, (.dmark)  
381e 32 6b ee			ld (debug_mark),a  
3821 3a 30 38			ld a, (.dmark+1)  
3824 32 6c ee			ld (debug_mark+1),a  
3827 3a 31 38			ld a, (.dmark+2)  
382a 32 6d ee			ld (debug_mark+2),a  
382d 18 03			jr .pastdmark  
382f ..			.dmark: db "MAX"  
3832 f1			.pastdmark: pop af  
3833			endm  
# End of macro DMARK
3833						CALLMONITOR 
3833 cd 6f ee			call debug_vector  
3836				endm  
# End of macro CALLMONITOR
3836					endif 
3836					; get u2 
3836			 
3836					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3836 cd 4d 1e			call macro_dsp_valuehl 
3839				endm 
# End of macro FORTH_DSP_VALUEHL
3839			 
3839 e5					push hl   ; u2 
383a			 
383a					; destroy value TOS 
383a			 
383a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
383a cd 05 1f			call macro_forth_dsp_pop 
383d				endm 
# End of macro FORTH_DSP_POP
383d			 
383d					; get u1 
383d			 
383d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
383d cd 4d 1e			call macro_dsp_valuehl 
3840				endm 
# End of macro FORTH_DSP_VALUEHL
3840			 
3840 e5					push hl  ; u1 
3841			 
3841					; destroy value TOS 
3841			 
3841					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3841 cd 05 1f			call macro_forth_dsp_pop 
3844				endm 
# End of macro FORTH_DSP_POP
3844			 
3844 b7			 or a      ;clear carry flag 
3845 e1			  pop hl    ; u1 
3846 d1			  pop de    ; u2 
3847 e5				push hl   ; saved in case hl is lowest 
3848 ed 52		  sbc hl,de 
384a 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
384c			 
384c e1				pop hl 
384d					if DEBUG_FORTH_WORDS 
384d						DMARK "MAX" 
384d f5				push af  
384e 3a 62 38			ld a, (.dmark)  
3851 32 6b ee			ld (debug_mark),a  
3854 3a 63 38			ld a, (.dmark+1)  
3857 32 6c ee			ld (debug_mark+1),a  
385a 3a 64 38			ld a, (.dmark+2)  
385d 32 6d ee			ld (debug_mark+2),a  
3860 18 03			jr .pastdmark  
3862 ..			.dmark: db "MAX"  
3865 f1			.pastdmark: pop af  
3866			endm  
# End of macro DMARK
3866						CALLMONITOR 
3866 cd 6f ee			call debug_vector  
3869				endm  
# End of macro CALLMONITOR
3869					endif 
3869 cd 56 1c				call forth_push_numhl 
386c			 
386c				       NEXTW 
386c c3 03 20			jp macro_next 
386f				endm 
# End of macro NEXTW
386f			 
386f			.maxcont:  
386f c1				pop bc   ; tidy up 
3870 eb				ex de , hl  
3871					if DEBUG_FORTH_WORDS 
3871						DMARK "MA1" 
3871 f5				push af  
3872 3a 86 38			ld a, (.dmark)  
3875 32 6b ee			ld (debug_mark),a  
3878 3a 87 38			ld a, (.dmark+1)  
387b 32 6c ee			ld (debug_mark+1),a  
387e 3a 88 38			ld a, (.dmark+2)  
3881 32 6d ee			ld (debug_mark+2),a  
3884 18 03			jr .pastdmark  
3886 ..			.dmark: db "MA1"  
3889 f1			.pastdmark: pop af  
388a			endm  
# End of macro DMARK
388a						CALLMONITOR 
388a cd 6f ee			call debug_vector  
388d				endm  
# End of macro CALLMONITOR
388d					endif 
388d cd 56 1c				call forth_push_numhl 
3890				       NEXTW 
3890 c3 03 20			jp macro_next 
3893				endm 
# End of macro NEXTW
3893			 
3893			.RND16: 
3893				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3893 4e				db WORD_SYS_CORE+58             
3894 c2 38			dw .RND8            
3896 06				db 5 + 1 
3897 .. 00			db "RND16",0              
389d				endm 
# End of macro CWHEAD
389d			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
389d					if DEBUG_FORTH_WORDS_KEY 
389d						DMARK "R16" 
389d f5				push af  
389e 3a b2 38			ld a, (.dmark)  
38a1 32 6b ee			ld (debug_mark),a  
38a4 3a b3 38			ld a, (.dmark+1)  
38a7 32 6c ee			ld (debug_mark+1),a  
38aa 3a b4 38			ld a, (.dmark+2)  
38ad 32 6d ee			ld (debug_mark+2),a  
38b0 18 03			jr .pastdmark  
38b2 ..			.dmark: db "R16"  
38b5 f1			.pastdmark: pop af  
38b6			endm  
# End of macro DMARK
38b6						CALLMONITOR 
38b6 cd 6f ee			call debug_vector  
38b9				endm  
# End of macro CALLMONITOR
38b9					endif 
38b9 cd 0e 0d				call prng16  
38bc cd 56 1c				call forth_push_numhl 
38bf				       NEXTW 
38bf c3 03 20			jp macro_next 
38c2				endm 
# End of macro NEXTW
38c2			.RND8: 
38c2				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38c2 60				db WORD_SYS_CORE+76             
38c3 f7 38			dw .RND            
38c5 05				db 4 + 1 
38c6 .. 00			db "RND8",0              
38cb				endm 
# End of macro CWHEAD
38cb			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38cb					if DEBUG_FORTH_WORDS_KEY 
38cb						DMARK "RN8" 
38cb f5				push af  
38cc 3a e0 38			ld a, (.dmark)  
38cf 32 6b ee			ld (debug_mark),a  
38d2 3a e1 38			ld a, (.dmark+1)  
38d5 32 6c ee			ld (debug_mark+1),a  
38d8 3a e2 38			ld a, (.dmark+2)  
38db 32 6d ee			ld (debug_mark+2),a  
38de 18 03			jr .pastdmark  
38e0 ..			.dmark: db "RN8"  
38e3 f1			.pastdmark: pop af  
38e4			endm  
# End of macro DMARK
38e4						CALLMONITOR 
38e4 cd 6f ee			call debug_vector  
38e7				endm  
# End of macro CALLMONITOR
38e7					endif 
38e7 2a a9 eb				ld hl,(xrandc) 
38ea 23					inc hl 
38eb cd 28 0d				call xrnd 
38ee 6f					ld l,a	 
38ef 26 00				ld h,0 
38f1 cd 56 1c				call forth_push_numhl 
38f4				       NEXTW 
38f4 c3 03 20			jp macro_next 
38f7				endm 
# End of macro NEXTW
38f7			.RND: 
38f7				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38f7 60				db WORD_SYS_CORE+76             
38f8 fd 39			dw .ENDMATHS            
38fa 04				db 3 + 1 
38fb .. 00			db "RND",0              
38ff				endm 
# End of macro CWHEAD
38ff			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38ff			 
38ff					if DEBUG_FORTH_WORDS_KEY 
38ff						DMARK "RND" 
38ff f5				push af  
3900 3a 14 39			ld a, (.dmark)  
3903 32 6b ee			ld (debug_mark),a  
3906 3a 15 39			ld a, (.dmark+1)  
3909 32 6c ee			ld (debug_mark+1),a  
390c 3a 16 39			ld a, (.dmark+2)  
390f 32 6d ee			ld (debug_mark+2),a  
3912 18 03			jr .pastdmark  
3914 ..			.dmark: db "RND"  
3917 f1			.pastdmark: pop af  
3918			endm  
# End of macro DMARK
3918						CALLMONITOR 
3918 cd 6f ee			call debug_vector  
391b				endm  
# End of macro CALLMONITOR
391b					endif 
391b					 
391b					FORTH_DSP_VALUEHL    ; upper range 
391b cd 4d 1e			call macro_dsp_valuehl 
391e				endm 
# End of macro FORTH_DSP_VALUEHL
391e			 
391e 22 ad eb				ld (LFSRSeed), hl	 
3921			 
3921					if DEBUG_FORTH_WORDS 
3921						DMARK "RN1" 
3921 f5				push af  
3922 3a 36 39			ld a, (.dmark)  
3925 32 6b ee			ld (debug_mark),a  
3928 3a 37 39			ld a, (.dmark+1)  
392b 32 6c ee			ld (debug_mark+1),a  
392e 3a 38 39			ld a, (.dmark+2)  
3931 32 6d ee			ld (debug_mark+2),a  
3934 18 03			jr .pastdmark  
3936 ..			.dmark: db "RN1"  
3939 f1			.pastdmark: pop af  
393a			endm  
# End of macro DMARK
393a						CALLMONITOR 
393a cd 6f ee			call debug_vector  
393d				endm  
# End of macro CALLMONITOR
393d					endif 
393d					FORTH_DSP_POP 
393d cd 05 1f			call macro_forth_dsp_pop 
3940				endm 
# End of macro FORTH_DSP_POP
3940			 
3940					FORTH_DSP_VALUEHL    ; low range 
3940 cd 4d 1e			call macro_dsp_valuehl 
3943				endm 
# End of macro FORTH_DSP_VALUEHL
3943			 
3943					if DEBUG_FORTH_WORDS 
3943						DMARK "RN2" 
3943 f5				push af  
3944 3a 58 39			ld a, (.dmark)  
3947 32 6b ee			ld (debug_mark),a  
394a 3a 59 39			ld a, (.dmark+1)  
394d 32 6c ee			ld (debug_mark+1),a  
3950 3a 5a 39			ld a, (.dmark+2)  
3953 32 6d ee			ld (debug_mark+2),a  
3956 18 03			jr .pastdmark  
3958 ..			.dmark: db "RN2"  
395b f1			.pastdmark: pop af  
395c			endm  
# End of macro DMARK
395c						CALLMONITOR 
395c cd 6f ee			call debug_vector  
395f				endm  
# End of macro CALLMONITOR
395f					endif 
395f 22 af eb				ld (LFSRSeed+2), hl 
3962			 
3962					FORTH_DSP_POP 
3962 cd 05 1f			call macro_forth_dsp_pop 
3965				endm 
# End of macro FORTH_DSP_POP
3965			 
3965 e5					push hl 
3966			 
3966 e1			.inrange:	pop hl 
3967 cd 0e 0d				call prng16  
396a					if DEBUG_FORTH_WORDS 
396a						DMARK "RN3" 
396a f5				push af  
396b 3a 7f 39			ld a, (.dmark)  
396e 32 6b ee			ld (debug_mark),a  
3971 3a 80 39			ld a, (.dmark+1)  
3974 32 6c ee			ld (debug_mark+1),a  
3977 3a 81 39			ld a, (.dmark+2)  
397a 32 6d ee			ld (debug_mark+2),a  
397d 18 03			jr .pastdmark  
397f ..			.dmark: db "RN3"  
3982 f1			.pastdmark: pop af  
3983			endm  
# End of macro DMARK
3983						CALLMONITOR 
3983 cd 6f ee			call debug_vector  
3986				endm  
# End of macro CALLMONITOR
3986					endif 
3986					 
3986					; if the range is 8bit knock out the high byte 
3986			 
3986 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
398a			 
398a 3e 00				ld a, 0 
398c ba					cp d  
398d 20 1e				jr nz, .hirange 
398f 26 00				ld h, 0   ; knock it down to 8bit 
3991			 
3991					if DEBUG_FORTH_WORDS 
3991						DMARK "RNk" 
3991 f5				push af  
3992 3a a6 39			ld a, (.dmark)  
3995 32 6b ee			ld (debug_mark),a  
3998 3a a7 39			ld a, (.dmark+1)  
399b 32 6c ee			ld (debug_mark+1),a  
399e 3a a8 39			ld a, (.dmark+2)  
39a1 32 6d ee			ld (debug_mark+2),a  
39a4 18 03			jr .pastdmark  
39a6 ..			.dmark: db "RNk"  
39a9 f1			.pastdmark: pop af  
39aa			endm  
# End of macro DMARK
39aa						CALLMONITOR 
39aa cd 6f ee			call debug_vector  
39ad				endm  
# End of macro CALLMONITOR
39ad					endif 
39ad			.hirange:   
39ad e5					push hl  
39ae b7					or a  
39af ed 52		                sbc hl, de 
39b1			 
39b1					;call cmp16 
39b1			 
39b1 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39b3 e1					pop hl 
39b4 e5					push hl 
39b5			 
39b5					if DEBUG_FORTH_WORDS 
39b5						DMARK "RN4" 
39b5 f5				push af  
39b6 3a ca 39			ld a, (.dmark)  
39b9 32 6b ee			ld (debug_mark),a  
39bc 3a cb 39			ld a, (.dmark+1)  
39bf 32 6c ee			ld (debug_mark+1),a  
39c2 3a cc 39			ld a, (.dmark+2)  
39c5 32 6d ee			ld (debug_mark+2),a  
39c8 18 03			jr .pastdmark  
39ca ..			.dmark: db "RN4"  
39cd f1			.pastdmark: pop af  
39ce			endm  
# End of macro DMARK
39ce						CALLMONITOR 
39ce cd 6f ee			call debug_vector  
39d1				endm  
# End of macro CALLMONITOR
39d1					endif 
39d1 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
39d5					;call cmp16 
39d5				 
39d5 b7					or a  
39d6 ed 52		                sbc hl, de 
39d8 38 8c				jr c, .inrange 
39da			 
39da e1					pop hl 
39db					 
39db					if DEBUG_FORTH_WORDS 
39db						DMARK "RNd" 
39db f5				push af  
39dc 3a f0 39			ld a, (.dmark)  
39df 32 6b ee			ld (debug_mark),a  
39e2 3a f1 39			ld a, (.dmark+1)  
39e5 32 6c ee			ld (debug_mark+1),a  
39e8 3a f2 39			ld a, (.dmark+2)  
39eb 32 6d ee			ld (debug_mark+2),a  
39ee 18 03			jr .pastdmark  
39f0 ..			.dmark: db "RNd"  
39f3 f1			.pastdmark: pop af  
39f4			endm  
# End of macro DMARK
39f4						CALLMONITOR 
39f4 cd 6f ee			call debug_vector  
39f7				endm  
# End of macro CALLMONITOR
39f7					endif 
39f7			 
39f7			 
39f7 cd 56 1c				call forth_push_numhl 
39fa				       NEXTW 
39fa c3 03 20			jp macro_next 
39fd				endm 
# End of macro NEXTW
39fd			 
39fd			.ENDMATHS: 
39fd			 
39fd			; eof 
39fd			 
# End of file forth_words_maths.asm
39fd			include "forth_words_display.asm" 
39fd			 
39fd			; | ## Display Words 
39fd			 
39fd			.ACT: 
39fd			 
39fd				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
39fd 62				db WORD_SYS_CORE+78             
39fe 49 3a			dw .INFO            
3a00 07				db 6 + 1 
3a01 .. 00			db "ACTIVE",0              
3a08				endm 
# End of macro CWHEAD
3a08			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3a08			;  
3a08			; | | e.g. $ff $00 do active . $01 pause loop 
3a08			 
3a08					if DEBUG_FORTH_WORDS_KEY 
3a08						DMARK "ACT" 
3a08 f5				push af  
3a09 3a 1d 3a			ld a, (.dmark)  
3a0c 32 6b ee			ld (debug_mark),a  
3a0f 3a 1e 3a			ld a, (.dmark+1)  
3a12 32 6c ee			ld (debug_mark+1),a  
3a15 3a 1f 3a			ld a, (.dmark+2)  
3a18 32 6d ee			ld (debug_mark+2),a  
3a1b 18 03			jr .pastdmark  
3a1d ..			.dmark: db "ACT"  
3a20 f1			.pastdmark: pop af  
3a21			endm  
# End of macro DMARK
3a21						CALLMONITOR 
3a21 cd 6f ee			call debug_vector  
3a24				endm  
# End of macro CALLMONITOR
3a24					endif 
3a24 cd 11 0b				call active 
3a27					if DEBUG_FORTH_WORDS 
3a27						DMARK "ACp" 
3a27 f5				push af  
3a28 3a 3c 3a			ld a, (.dmark)  
3a2b 32 6b ee			ld (debug_mark),a  
3a2e 3a 3d 3a			ld a, (.dmark+1)  
3a31 32 6c ee			ld (debug_mark+1),a  
3a34 3a 3e 3a			ld a, (.dmark+2)  
3a37 32 6d ee			ld (debug_mark+2),a  
3a3a 18 03			jr .pastdmark  
3a3c ..			.dmark: db "ACp"  
3a3f f1			.pastdmark: pop af  
3a40			endm  
# End of macro DMARK
3a40						CALLMONITOR 
3a40 cd 6f ee			call debug_vector  
3a43				endm  
# End of macro CALLMONITOR
3a43					endif 
3a43 cd c4 1c				call forth_push_str 
3a46			 
3a46					NEXTW 
3a46 c3 03 20			jp macro_next 
3a49				endm 
# End of macro NEXTW
3a49			.INFO: 
3a49			 
3a49				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a49 62				db WORD_SYS_CORE+78             
3a4a 66 3a			dw .ATP            
3a4c 05				db 4 + 1 
3a4d .. 00			db "INFO",0              
3a52				endm 
# End of macro CWHEAD
3a52			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a52					FORTH_DSP_VALUEHL 
3a52 cd 4d 1e			call macro_dsp_valuehl 
3a55				endm 
# End of macro FORTH_DSP_VALUEHL
3a55			 
3a55					FORTH_DSP_POP 
3a55 cd 05 1f			call macro_forth_dsp_pop 
3a58				endm 
# End of macro FORTH_DSP_POP
3a58			 
3a58 e5					push hl 
3a59			 
3a59					FORTH_DSP_VALUEHL 
3a59 cd 4d 1e			call macro_dsp_valuehl 
3a5c				endm 
# End of macro FORTH_DSP_VALUEHL
3a5c			 
3a5c					FORTH_DSP_POP 
3a5c cd 05 1f			call macro_forth_dsp_pop 
3a5f				endm 
# End of macro FORTH_DSP_POP
3a5f			 
3a5f d1					pop de 
3a60			 
3a60 cd 4b 0b				call info_panel 
3a63			 
3a63			 
3a63					NEXTW 
3a63 c3 03 20			jp macro_next 
3a66				endm 
# End of macro NEXTW
3a66			.ATP: 
3a66				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a66 62				db WORD_SYS_CORE+78             
3a67 dd 3a			dw .FB            
3a69 04				db 3 + 1 
3a6a .. 00			db "AT?",0              
3a6e				endm 
# End of macro CWHEAD
3a6e			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a6e					if DEBUG_FORTH_WORDS_KEY 
3a6e						DMARK "AT?" 
3a6e f5				push af  
3a6f 3a 83 3a			ld a, (.dmark)  
3a72 32 6b ee			ld (debug_mark),a  
3a75 3a 84 3a			ld a, (.dmark+1)  
3a78 32 6c ee			ld (debug_mark+1),a  
3a7b 3a 85 3a			ld a, (.dmark+2)  
3a7e 32 6d ee			ld (debug_mark+2),a  
3a81 18 03			jr .pastdmark  
3a83 ..			.dmark: db "AT?"  
3a86 f1			.pastdmark: pop af  
3a87			endm  
# End of macro DMARK
3a87						CALLMONITOR 
3a87 cd 6f ee			call debug_vector  
3a8a				endm  
# End of macro CALLMONITOR
3a8a					endif 
3a8a 3a 5e ea				ld a, (f_cursor_ptr) 
3a8d			 
3a8d			if DEBUG_FORTH_WORDS 
3a8d				DMARK "AT?" 
3a8d f5				push af  
3a8e 3a a2 3a			ld a, (.dmark)  
3a91 32 6b ee			ld (debug_mark),a  
3a94 3a a3 3a			ld a, (.dmark+1)  
3a97 32 6c ee			ld (debug_mark+1),a  
3a9a 3a a4 3a			ld a, (.dmark+2)  
3a9d 32 6d ee			ld (debug_mark+2),a  
3aa0 18 03			jr .pastdmark  
3aa2 ..			.dmark: db "AT?"  
3aa5 f1			.pastdmark: pop af  
3aa6			endm  
# End of macro DMARK
3aa6				CALLMONITOR 
3aa6 cd 6f ee			call debug_vector  
3aa9				endm  
# End of macro CALLMONITOR
3aa9			endif	 
3aa9					; count the number of rows 
3aa9			 
3aa9 06 00				ld b, 0 
3aab 4f			.atpr:		ld c, a    ; save in case we go below zero 
3aac d6 28				sub display_cols 
3aae f2 b4 3a				jp p, .atprunder 
3ab1 04					inc b 
3ab2 18 f7				jr .atpr 
3ab4			.atprunder:	 
3ab4			if DEBUG_FORTH_WORDS 
3ab4				DMARK "A?2" 
3ab4 f5				push af  
3ab5 3a c9 3a			ld a, (.dmark)  
3ab8 32 6b ee			ld (debug_mark),a  
3abb 3a ca 3a			ld a, (.dmark+1)  
3abe 32 6c ee			ld (debug_mark+1),a  
3ac1 3a cb 3a			ld a, (.dmark+2)  
3ac4 32 6d ee			ld (debug_mark+2),a  
3ac7 18 03			jr .pastdmark  
3ac9 ..			.dmark: db "A?2"  
3acc f1			.pastdmark: pop af  
3acd			endm  
# End of macro DMARK
3acd				CALLMONITOR 
3acd cd 6f ee			call debug_vector  
3ad0				endm  
# End of macro CALLMONITOR
3ad0			endif	 
3ad0 26 00				ld h, 0 
3ad2 69					ld l, c 
3ad3 cd 56 1c				call forth_push_numhl 
3ad6 68					ld l, b  
3ad7 cd 56 1c				call forth_push_numhl 
3ada			 
3ada			 
3ada				NEXTW 
3ada c3 03 20			jp macro_next 
3add				endm 
# End of macro NEXTW
3add			 
3add			.FB: 
3add				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3add 1b				db WORD_SYS_CORE+7             
3ade 2b 3b			dw .EMIT            
3ae0 03				db 2 + 1 
3ae1 .. 00			db "FB",0              
3ae4				endm 
# End of macro CWHEAD
3ae4			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ae4			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ae4			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ae4			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ae4					if DEBUG_FORTH_WORDS_KEY 
3ae4						DMARK "FB." 
3ae4 f5				push af  
3ae5 3a f9 3a			ld a, (.dmark)  
3ae8 32 6b ee			ld (debug_mark),a  
3aeb 3a fa 3a			ld a, (.dmark+1)  
3aee 32 6c ee			ld (debug_mark+1),a  
3af1 3a fb 3a			ld a, (.dmark+2)  
3af4 32 6d ee			ld (debug_mark+2),a  
3af7 18 03			jr .pastdmark  
3af9 ..			.dmark: db "FB."  
3afc f1			.pastdmark: pop af  
3afd			endm  
# End of macro DMARK
3afd						CALLMONITOR 
3afd cd 6f ee			call debug_vector  
3b00				endm  
# End of macro CALLMONITOR
3b00					endif 
3b00			 
3b00					FORTH_DSP_VALUEHL 
3b00 cd 4d 1e			call macro_dsp_valuehl 
3b03				endm 
# End of macro FORTH_DSP_VALUEHL
3b03			 
3b03 7d					ld a, l 
3b04 fe 01				cp 1 
3b06 20 05				jr nz, .fbn1 
3b08 21 10 ed				ld hl, display_fb1 
3b0b 18 15				jr .fbset 
3b0d fe 02		.fbn1:		cp 2 
3b0f 20 05				jr nz, .fbn2 
3b11 21 ce eb				ld hl, display_fb2 
3b14 18 0c				jr .fbset 
3b16 fe 03		.fbn2:		cp 3 
3b18 20 05				jr nz, .fbn3 
3b1a 21 6f ec				ld hl, display_fb3 
3b1d 18 03				jr .fbset 
3b1f			.fbn3:		 ; if invalid number select first 
3b1f 21 10 ed				ld hl, display_fb1 
3b22 22 cc eb		.fbset:		ld (display_fb_active), hl 
3b25			 
3b25					FORTH_DSP_POP 
3b25 cd 05 1f			call macro_forth_dsp_pop 
3b28				endm 
# End of macro FORTH_DSP_POP
3b28			 
3b28					NEXTW 
3b28 c3 03 20			jp macro_next 
3b2b				endm 
# End of macro NEXTW
3b2b			 
3b2b			 
3b2b			.EMIT: 
3b2b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b2b 1b				db WORD_SYS_CORE+7             
3b2c 7c 3b			dw .DOTH            
3b2e 05				db 4 + 1 
3b2f .. 00			db "EMIT",0              
3b34				endm 
# End of macro CWHEAD
3b34			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b34					; get value off TOS and display it 
3b34			 
3b34					if DEBUG_FORTH_WORDS_KEY 
3b34						DMARK "EMT" 
3b34 f5				push af  
3b35 3a 49 3b			ld a, (.dmark)  
3b38 32 6b ee			ld (debug_mark),a  
3b3b 3a 4a 3b			ld a, (.dmark+1)  
3b3e 32 6c ee			ld (debug_mark+1),a  
3b41 3a 4b 3b			ld a, (.dmark+2)  
3b44 32 6d ee			ld (debug_mark+2),a  
3b47 18 03			jr .pastdmark  
3b49 ..			.dmark: db "EMT"  
3b4c f1			.pastdmark: pop af  
3b4d			endm  
# End of macro DMARK
3b4d						CALLMONITOR 
3b4d cd 6f ee			call debug_vector  
3b50				endm  
# End of macro CALLMONITOR
3b50					endif 
3b50			 
3b50					FORTH_DSP_VALUEHL 
3b50 cd 4d 1e			call macro_dsp_valuehl 
3b53				endm 
# End of macro FORTH_DSP_VALUEHL
3b53			 
3b53 7d					ld a,l 
3b54			 
3b54					; TODO write to display 
3b54			 
3b54 32 bf e4				ld (os_input), a 
3b57 3e 00				ld a, 0 
3b59 32 c0 e4				ld (os_input+1), a 
3b5c					 
3b5c 3a 5e ea				ld a, (f_cursor_ptr) 
3b5f 11 bf e4				ld de, os_input 
3b62 cd cd 0b				call str_at_display 
3b65			 
3b65			 
3b65 3a 3c ea				ld a,(cli_autodisplay) 
3b68 fe 00				cp 0 
3b6a 28 03				jr z, .enoupdate 
3b6c cd dd 0b						call update_display 
3b6f					.enoupdate: 
3b6f			 
3b6f 3a 5e ea				ld a, (f_cursor_ptr) 
3b72 3c					inc a 
3b73 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3b76			 
3b76			 
3b76					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b76 cd 05 1f			call macro_forth_dsp_pop 
3b79				endm 
# End of macro FORTH_DSP_POP
3b79			  
3b79			 
3b79					NEXTW 
3b79 c3 03 20			jp macro_next 
3b7c				endm 
# End of macro NEXTW
3b7c			.DOTH: 
3b7c				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b7c 1c				db WORD_SYS_CORE+8             
3b7d ac 3b			dw .DOTF            
3b7f 03				db 2 + 1 
3b80 .. 00			db ".-",0              
3b83				endm 
# End of macro CWHEAD
3b83			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b83					; get value off TOS and display it 
3b83					if DEBUG_FORTH_WORDS_KEY 
3b83						DMARK "DTD" 
3b83 f5				push af  
3b84 3a 98 3b			ld a, (.dmark)  
3b87 32 6b ee			ld (debug_mark),a  
3b8a 3a 99 3b			ld a, (.dmark+1)  
3b8d 32 6c ee			ld (debug_mark+1),a  
3b90 3a 9a 3b			ld a, (.dmark+2)  
3b93 32 6d ee			ld (debug_mark+2),a  
3b96 18 03			jr .pastdmark  
3b98 ..			.dmark: db "DTD"  
3b9b f1			.pastdmark: pop af  
3b9c			endm  
# End of macro DMARK
3b9c						CALLMONITOR 
3b9c cd 6f ee			call debug_vector  
3b9f				endm  
# End of macro CALLMONITOR
3b9f					endif 
3b9f 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3ba1 3e 00			ld a, 0 
3ba3 32 3d ea			ld (cli_mvdot), a 
3ba6 c3 03 3c			jp .dotgo 
3ba9				NEXTW 
3ba9 c3 03 20			jp macro_next 
3bac				endm 
# End of macro NEXTW
3bac			.DOTF: 
3bac				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3bac 1c				db WORD_SYS_CORE+8             
3bad da 3b			dw .DOT            
3baf 03				db 2 + 1 
3bb0 .. 00			db ".>",0              
3bb3				endm 
# End of macro CWHEAD
3bb3			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3bb3					; get value off TOS and display it 
3bb3			        ; TODO BUG adds extra spaces 
3bb3			        ; TODO BUG handle numerics? 
3bb3					if DEBUG_FORTH_WORDS_KEY 
3bb3						DMARK "DTC" 
3bb3 f5				push af  
3bb4 3a c8 3b			ld a, (.dmark)  
3bb7 32 6b ee			ld (debug_mark),a  
3bba 3a c9 3b			ld a, (.dmark+1)  
3bbd 32 6c ee			ld (debug_mark+1),a  
3bc0 3a ca 3b			ld a, (.dmark+2)  
3bc3 32 6d ee			ld (debug_mark+2),a  
3bc6 18 03			jr .pastdmark  
3bc8 ..			.dmark: db "DTC"  
3bcb f1			.pastdmark: pop af  
3bcc			endm  
# End of macro DMARK
3bcc						CALLMONITOR 
3bcc cd 6f ee			call debug_vector  
3bcf				endm  
# End of macro CALLMONITOR
3bcf					endif 
3bcf 3e 01			ld a, 1 
3bd1 32 3d ea			ld (cli_mvdot), a 
3bd4 c3 03 3c			jp .dotgo 
3bd7				NEXTW 
3bd7 c3 03 20			jp macro_next 
3bda				endm 
# End of macro NEXTW
3bda			 
3bda			.DOT: 
3bda				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3bda 1c				db WORD_SYS_CORE+8             
3bdb b6 3d			dw .CLS            
3bdd 02				db 1 + 1 
3bde .. 00			db ".",0              
3be0				endm 
# End of macro CWHEAD
3be0			        ; | . ( u -- ) Display TOS | DONE 
3be0					; get value off TOS and display it 
3be0			 
3be0					if DEBUG_FORTH_WORDS_KEY 
3be0						DMARK "DOT" 
3be0 f5				push af  
3be1 3a f5 3b			ld a, (.dmark)  
3be4 32 6b ee			ld (debug_mark),a  
3be7 3a f6 3b			ld a, (.dmark+1)  
3bea 32 6c ee			ld (debug_mark+1),a  
3bed 3a f7 3b			ld a, (.dmark+2)  
3bf0 32 6d ee			ld (debug_mark+2),a  
3bf3 18 03			jr .pastdmark  
3bf5 ..			.dmark: db "DOT"  
3bf8 f1			.pastdmark: pop af  
3bf9			endm  
# End of macro DMARK
3bf9						CALLMONITOR 
3bf9 cd 6f ee			call debug_vector  
3bfc				endm  
# End of macro CALLMONITOR
3bfc					endif 
3bfc 3e 00			ld a, 0 
3bfe 32 3d ea			ld (cli_mvdot), a 
3c01 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c03				 
3c03			 
3c03			.dotgo: 
3c03			 
3c03			; move up type to on stack for parserv5 
3c03					FORTH_DSP 
3c03 cd 13 1e			call macro_forth_dsp 
3c06				endm 
# End of macro FORTH_DSP
3c06				;FORTH_DSP_VALUE  
3c06			 
3c06			if DEBUG_FORTH_DOT 
3c06				DMARK "DOT" 
3c06 f5				push af  
3c07 3a 1b 3c			ld a, (.dmark)  
3c0a 32 6b ee			ld (debug_mark),a  
3c0d 3a 1c 3c			ld a, (.dmark+1)  
3c10 32 6c ee			ld (debug_mark+1),a  
3c13 3a 1d 3c			ld a, (.dmark+2)  
3c16 32 6d ee			ld (debug_mark+2),a  
3c19 18 03			jr .pastdmark  
3c1b ..			.dmark: db "DOT"  
3c1e f1			.pastdmark: pop af  
3c1f			endm  
# End of macro DMARK
3c1f				CALLMONITOR 
3c1f cd 6f ee			call debug_vector  
3c22				endm  
# End of macro CALLMONITOR
3c22			endif	 
3c22			;		.print: 
3c22			 
3c22 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c23 23				inc hl   ; position to the actual value 
3c24 fe 01			cp DS_TYPE_STR 
3c26 20 06			jr nz, .dotnum1  
3c28			 
3c28			; display string 
3c28				FORTH_DSP_VALUE  
3c28 cd 36 1e			call macro_forth_dsp_value 
3c2b				endm 
# End of macro FORTH_DSP_VALUE
3c2b eb				ex de,hl 
3c2c 18 49			jr .dotwrite 
3c2e			 
3c2e			.dotnum1: 
3c2e fe 02			cp DS_TYPE_INUM 
3c30 20 44			jr nz, .dotflot 
3c32			 
3c32			 
3c32			; display number 
3c32			 
3c32			;	push hl 
3c32			;	call clear_display 
3c32			;	pop hl 
3c32			 
3c32 5e				ld e, (hl) 
3c33 23				inc hl 
3c34 56				ld d, (hl) 
3c35 21 c1 e2			ld hl, scratch 
3c38			if DEBUG_FORTH_DOT 
3c38				DMARK "DT1" 
3c38 f5				push af  
3c39 3a 4d 3c			ld a, (.dmark)  
3c3c 32 6b ee			ld (debug_mark),a  
3c3f 3a 4e 3c			ld a, (.dmark+1)  
3c42 32 6c ee			ld (debug_mark+1),a  
3c45 3a 4f 3c			ld a, (.dmark+2)  
3c48 32 6d ee			ld (debug_mark+2),a  
3c4b 18 03			jr .pastdmark  
3c4d ..			.dmark: db "DT1"  
3c50 f1			.pastdmark: pop af  
3c51			endm  
# End of macro DMARK
3c51				CALLMONITOR 
3c51 cd 6f ee			call debug_vector  
3c54				endm  
# End of macro CALLMONITOR
3c54			endif	 
3c54			 
3c54 cd f4 11			call uitoa_16 
3c57 eb				ex de,hl 
3c58			 
3c58			if DEBUG_FORTH_DOT 
3c58				DMARK "DT2" 
3c58 f5				push af  
3c59 3a 6d 3c			ld a, (.dmark)  
3c5c 32 6b ee			ld (debug_mark),a  
3c5f 3a 6e 3c			ld a, (.dmark+1)  
3c62 32 6c ee			ld (debug_mark+1),a  
3c65 3a 6f 3c			ld a, (.dmark+2)  
3c68 32 6d ee			ld (debug_mark+2),a  
3c6b 18 03			jr .pastdmark  
3c6d ..			.dmark: db "DT2"  
3c70 f1			.pastdmark: pop af  
3c71			endm  
# End of macro DMARK
3c71				CALLMONITOR 
3c71 cd 6f ee			call debug_vector  
3c74				endm  
# End of macro CALLMONITOR
3c74			endif	 
3c74			 
3c74			;	ld de, os_word_scratch 
3c74 18 01			jr .dotwrite 
3c76			 
3c76 00			.dotflot:   nop 
3c77			; TODO print floating point number 
3c77			 
3c77			.dotwrite:		 
3c77			 
3c77					; if c is set then set all '-' to spaces 
3c77					; need to also take into account .>  
3c77			 
3c77 3e 01				ld a, 1 
3c79 b9					cp c 
3c7a 20 67				jr nz, .nodashswap 
3c7c			 
3c7c					; DE has the string to write, working with HL 
3c7c			 
3c7c 06 ff				ld b, 255 
3c7e d5					push de 
3c7f e1					pop hl 
3c80			 
3c80			if DEBUG_FORTH_DOT 
3c80				DMARK "DT-" 
3c80 f5				push af  
3c81 3a 95 3c			ld a, (.dmark)  
3c84 32 6b ee			ld (debug_mark),a  
3c87 3a 96 3c			ld a, (.dmark+1)  
3c8a 32 6c ee			ld (debug_mark+1),a  
3c8d 3a 97 3c			ld a, (.dmark+2)  
3c90 32 6d ee			ld (debug_mark+2),a  
3c93 18 03			jr .pastdmark  
3c95 ..			.dmark: db "DT-"  
3c98 f1			.pastdmark: pop af  
3c99			endm  
# End of macro DMARK
3c99				CALLMONITOR 
3c99 cd 6f ee			call debug_vector  
3c9c				endm  
# End of macro CALLMONITOR
3c9c			endif	 
3c9c 7e			.dashscan:	ld a, (hl) 
3c9d fe 00				cp 0 
3c9f 28 42				jr z, .nodashswap 
3ca1 fe 2d				cp '-' 
3ca3 20 03				jr nz, .dashskip 
3ca5 3e 20				ld a, ' ' 
3ca7 77					ld (hl), a 
3ca8 23			.dashskip:	inc hl 
3ca9			if DEBUG_FORTH_DOT 
3ca9				DMARK "D-2" 
3ca9 f5				push af  
3caa 3a be 3c			ld a, (.dmark)  
3cad 32 6b ee			ld (debug_mark),a  
3cb0 3a bf 3c			ld a, (.dmark+1)  
3cb3 32 6c ee			ld (debug_mark+1),a  
3cb6 3a c0 3c			ld a, (.dmark+2)  
3cb9 32 6d ee			ld (debug_mark+2),a  
3cbc 18 03			jr .pastdmark  
3cbe ..			.dmark: db "D-2"  
3cc1 f1			.pastdmark: pop af  
3cc2			endm  
# End of macro DMARK
3cc2				CALLMONITOR 
3cc2 cd 6f ee			call debug_vector  
3cc5				endm  
# End of macro CALLMONITOR
3cc5			endif	 
3cc5 10 d5				djnz .dashscan 
3cc7			 
3cc7			if DEBUG_FORTH_DOT 
3cc7				DMARK "D-1" 
3cc7 f5				push af  
3cc8 3a dc 3c			ld a, (.dmark)  
3ccb 32 6b ee			ld (debug_mark),a  
3cce 3a dd 3c			ld a, (.dmark+1)  
3cd1 32 6c ee			ld (debug_mark+1),a  
3cd4 3a de 3c			ld a, (.dmark+2)  
3cd7 32 6d ee			ld (debug_mark+2),a  
3cda 18 03			jr .pastdmark  
3cdc ..			.dmark: db "D-1"  
3cdf f1			.pastdmark: pop af  
3ce0			endm  
# End of macro DMARK
3ce0				CALLMONITOR 
3ce0 cd 6f ee			call debug_vector  
3ce3				endm  
# End of macro CALLMONITOR
3ce3			endif	 
3ce3			 
3ce3			.nodashswap: 
3ce3			 
3ce3			if DEBUG_FORTH_DOT 
3ce3				DMARK "D-o" 
3ce3 f5				push af  
3ce4 3a f8 3c			ld a, (.dmark)  
3ce7 32 6b ee			ld (debug_mark),a  
3cea 3a f9 3c			ld a, (.dmark+1)  
3ced 32 6c ee			ld (debug_mark+1),a  
3cf0 3a fa 3c			ld a, (.dmark+2)  
3cf3 32 6d ee			ld (debug_mark+2),a  
3cf6 18 03			jr .pastdmark  
3cf8 ..			.dmark: db "D-o"  
3cfb f1			.pastdmark: pop af  
3cfc			endm  
# End of macro DMARK
3cfc				CALLMONITOR 
3cfc cd 6f ee			call debug_vector  
3cff				endm  
# End of macro CALLMONITOR
3cff			endif	 
3cff			 
3cff d5					push de   ; save string start in case we need to advance print 
3d00			 
3d00 3a 5e ea				ld a, (f_cursor_ptr) 
3d03 cd cd 0b				call str_at_display 
3d06 3a 3c ea				ld a,(cli_autodisplay) 
3d09 fe 00				cp 0 
3d0b 28 03				jr z, .noupdate 
3d0d cd dd 0b						call update_display 
3d10					.noupdate: 
3d10			 
3d10			 
3d10					; see if we need to advance the print position 
3d10			 
3d10 e1					pop hl   ; get back string 
3d11			;		ex de,hl 
3d11			 
3d11 3a 3d ea				ld a, (cli_mvdot) 
3d14			if DEBUG_FORTH_DOT 
3d14			;		ld e,a 
3d14				DMARK "D>1" 
3d14 f5				push af  
3d15 3a 29 3d			ld a, (.dmark)  
3d18 32 6b ee			ld (debug_mark),a  
3d1b 3a 2a 3d			ld a, (.dmark+1)  
3d1e 32 6c ee			ld (debug_mark+1),a  
3d21 3a 2b 3d			ld a, (.dmark+2)  
3d24 32 6d ee			ld (debug_mark+2),a  
3d27 18 03			jr .pastdmark  
3d29 ..			.dmark: db "D>1"  
3d2c f1			.pastdmark: pop af  
3d2d			endm  
# End of macro DMARK
3d2d				CALLMONITOR 
3d2d cd 6f ee			call debug_vector  
3d30				endm  
# End of macro CALLMONITOR
3d30			endif	 
3d30 fe 00				cp 0 
3d32 28 44				jr z, .noadv 
3d34					; yes, lets advance the print position 
3d34 3e 00				ld a, 0 
3d36 cd 50 12				call strlent 
3d39			if DEBUG_FORTH_DOT 
3d39				DMARK "D-?" 
3d39 f5				push af  
3d3a 3a 4e 3d			ld a, (.dmark)  
3d3d 32 6b ee			ld (debug_mark),a  
3d40 3a 4f 3d			ld a, (.dmark+1)  
3d43 32 6c ee			ld (debug_mark+1),a  
3d46 3a 50 3d			ld a, (.dmark+2)  
3d49 32 6d ee			ld (debug_mark+2),a  
3d4c 18 03			jr .pastdmark  
3d4e ..			.dmark: db "D-?"  
3d51 f1			.pastdmark: pop af  
3d52			endm  
# End of macro DMARK
3d52				CALLMONITOR 
3d52 cd 6f ee			call debug_vector  
3d55				endm  
# End of macro CALLMONITOR
3d55			endif	 
3d55 3a 5e ea				ld a, (f_cursor_ptr) 
3d58 85					add a,l 
3d59					;call addatohl 
3d59					;ld a, l 
3d59 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3d5c			 
3d5c			if DEBUG_FORTH_DOT 
3d5c				DMARK "D->" 
3d5c f5				push af  
3d5d 3a 71 3d			ld a, (.dmark)  
3d60 32 6b ee			ld (debug_mark),a  
3d63 3a 72 3d			ld a, (.dmark+1)  
3d66 32 6c ee			ld (debug_mark+1),a  
3d69 3a 73 3d			ld a, (.dmark+2)  
3d6c 32 6d ee			ld (debug_mark+2),a  
3d6f 18 03			jr .pastdmark  
3d71 ..			.dmark: db "D->"  
3d74 f1			.pastdmark: pop af  
3d75			endm  
# End of macro DMARK
3d75				CALLMONITOR 
3d75 cd 6f ee			call debug_vector  
3d78				endm  
# End of macro CALLMONITOR
3d78			endif	 
3d78			 
3d78			.noadv:	 
3d78			 
3d78					if DEBUG_FORTH_DOT_WAIT 
3d78							call next_page_prompt 
3d78					endif	 
3d78			; TODO this pop off the stack causes a crash. i dont know why 
3d78			 
3d78			 
3d78			if DEBUG_FORTH_DOT 
3d78				DMARK "DTh" 
3d78 f5				push af  
3d79 3a 8d 3d			ld a, (.dmark)  
3d7c 32 6b ee			ld (debug_mark),a  
3d7f 3a 8e 3d			ld a, (.dmark+1)  
3d82 32 6c ee			ld (debug_mark+1),a  
3d85 3a 8f 3d			ld a, (.dmark+2)  
3d88 32 6d ee			ld (debug_mark+2),a  
3d8b 18 03			jr .pastdmark  
3d8d ..			.dmark: db "DTh"  
3d90 f1			.pastdmark: pop af  
3d91			endm  
# End of macro DMARK
3d91				CALLMONITOR 
3d91 cd 6f ee			call debug_vector  
3d94				endm  
# End of macro CALLMONITOR
3d94			endif	 
3d94			 
3d94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d94 cd 05 1f			call macro_forth_dsp_pop 
3d97				endm 
# End of macro FORTH_DSP_POP
3d97			 
3d97			if DEBUG_FORTH_DOT 
3d97				DMARK "DTi" 
3d97 f5				push af  
3d98 3a ac 3d			ld a, (.dmark)  
3d9b 32 6b ee			ld (debug_mark),a  
3d9e 3a ad 3d			ld a, (.dmark+1)  
3da1 32 6c ee			ld (debug_mark+1),a  
3da4 3a ae 3d			ld a, (.dmark+2)  
3da7 32 6d ee			ld (debug_mark+2),a  
3daa 18 03			jr .pastdmark  
3dac ..			.dmark: db "DTi"  
3daf f1			.pastdmark: pop af  
3db0			endm  
# End of macro DMARK
3db0				CALLMONITOR 
3db0 cd 6f ee			call debug_vector  
3db3				endm  
# End of macro CALLMONITOR
3db3			endif	 
3db3			 
3db3			 
3db3					NEXTW 
3db3 c3 03 20			jp macro_next 
3db6				endm 
# End of macro NEXTW
3db6			 
3db6			.CLS: 
3db6				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3db6 35				db WORD_SYS_CORE+33             
3db7 e3 3d			dw .DRAW            
3db9 04				db 3 + 1 
3dba .. 00			db "CLS",0              
3dbe				endm 
# End of macro CWHEAD
3dbe			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3dbe					if DEBUG_FORTH_WORDS_KEY 
3dbe						DMARK "CLS" 
3dbe f5				push af  
3dbf 3a d3 3d			ld a, (.dmark)  
3dc2 32 6b ee			ld (debug_mark),a  
3dc5 3a d4 3d			ld a, (.dmark+1)  
3dc8 32 6c ee			ld (debug_mark+1),a  
3dcb 3a d5 3d			ld a, (.dmark+2)  
3dce 32 6d ee			ld (debug_mark+2),a  
3dd1 18 03			jr .pastdmark  
3dd3 ..			.dmark: db "CLS"  
3dd6 f1			.pastdmark: pop af  
3dd7			endm  
# End of macro DMARK
3dd7						CALLMONITOR 
3dd7 cd 6f ee			call debug_vector  
3dda				endm  
# End of macro CALLMONITOR
3dda					endif 
3dda cd ba 0b				call clear_display 
3ddd c3 f1 3e				jp .home		; and home cursor 
3de0					NEXTW 
3de0 c3 03 20			jp macro_next 
3de3				endm 
# End of macro NEXTW
3de3			 
3de3			.DRAW: 
3de3				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3de3 36				db WORD_SYS_CORE+34             
3de4 0e 3e			dw .DUMP            
3de6 05				db 4 + 1 
3de7 .. 00			db "DRAW",0              
3dec				endm 
# End of macro CWHEAD
3dec			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3dec					if DEBUG_FORTH_WORDS_KEY 
3dec						DMARK "DRW" 
3dec f5				push af  
3ded 3a 01 3e			ld a, (.dmark)  
3df0 32 6b ee			ld (debug_mark),a  
3df3 3a 02 3e			ld a, (.dmark+1)  
3df6 32 6c ee			ld (debug_mark+1),a  
3df9 3a 03 3e			ld a, (.dmark+2)  
3dfc 32 6d ee			ld (debug_mark+2),a  
3dff 18 03			jr .pastdmark  
3e01 ..			.dmark: db "DRW"  
3e04 f1			.pastdmark: pop af  
3e05			endm  
# End of macro DMARK
3e05						CALLMONITOR 
3e05 cd 6f ee			call debug_vector  
3e08				endm  
# End of macro CALLMONITOR
3e08					endif 
3e08 cd dd 0b				call update_display 
3e0b					NEXTW 
3e0b c3 03 20			jp macro_next 
3e0e				endm 
# End of macro NEXTW
3e0e			 
3e0e			.DUMP: 
3e0e				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3e0e 37				db WORD_SYS_CORE+35             
3e0f 46 3e			dw .CDUMP            
3e11 05				db 4 + 1 
3e12 .. 00			db "DUMP",0              
3e17				endm 
# End of macro CWHEAD
3e17			; | DUMP ( x -- ) With address x display dump   | DONE 
3e17			; TODO pop address to use off of the stack 
3e17					if DEBUG_FORTH_WORDS_KEY 
3e17						DMARK "DUM" 
3e17 f5				push af  
3e18 3a 2c 3e			ld a, (.dmark)  
3e1b 32 6b ee			ld (debug_mark),a  
3e1e 3a 2d 3e			ld a, (.dmark+1)  
3e21 32 6c ee			ld (debug_mark+1),a  
3e24 3a 2e 3e			ld a, (.dmark+2)  
3e27 32 6d ee			ld (debug_mark+2),a  
3e2a 18 03			jr .pastdmark  
3e2c ..			.dmark: db "DUM"  
3e2f f1			.pastdmark: pop af  
3e30			endm  
# End of macro DMARK
3e30						CALLMONITOR 
3e30 cd 6f ee			call debug_vector  
3e33				endm  
# End of macro CALLMONITOR
3e33					endif 
3e33 cd ba 0b				call clear_display 
3e36			 
3e36					; get address 
3e36			 
3e36					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e36 cd 4d 1e			call macro_dsp_valuehl 
3e39				endm 
# End of macro FORTH_DSP_VALUEHL
3e39				 
3e39					; save it for cdump 
3e39			 
3e39 22 e4 e5				ld (os_cur_ptr),hl 
3e3c			 
3e3c					; destroy value TOS 
3e3c			 
3e3c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e3c cd 05 1f			call macro_forth_dsp_pop 
3e3f				endm 
# End of macro FORTH_DSP_POP
3e3f			 
3e3f cd d6 1a				call dumpcont	; skip old style of param parsing	 
3e42 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3e43					NEXTW 
3e43 c3 03 20			jp macro_next 
3e46				endm 
# End of macro NEXTW
3e46			.CDUMP: 
3e46				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3e46 38				db WORD_SYS_CORE+36             
3e47 76 3e			dw .DAT            
3e49 06				db 5 + 1 
3e4a .. 00			db "CDUMP",0              
3e50				endm 
# End of macro CWHEAD
3e50			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3e50					if DEBUG_FORTH_WORDS_KEY 
3e50						DMARK "CDP" 
3e50 f5				push af  
3e51 3a 65 3e			ld a, (.dmark)  
3e54 32 6b ee			ld (debug_mark),a  
3e57 3a 66 3e			ld a, (.dmark+1)  
3e5a 32 6c ee			ld (debug_mark+1),a  
3e5d 3a 67 3e			ld a, (.dmark+2)  
3e60 32 6d ee			ld (debug_mark+2),a  
3e63 18 03			jr .pastdmark  
3e65 ..			.dmark: db "CDP"  
3e68 f1			.pastdmark: pop af  
3e69			endm  
# End of macro DMARK
3e69						CALLMONITOR 
3e69 cd 6f ee			call debug_vector  
3e6c				endm  
# End of macro CALLMONITOR
3e6c					endif 
3e6c cd ba 0b				call clear_display 
3e6f cd d6 1a				call dumpcont	 
3e72 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3e73					NEXTW 
3e73 c3 03 20			jp macro_next 
3e76				endm 
# End of macro NEXTW
3e76			 
3e76			 
3e76			 
3e76			 
3e76			.DAT: 
3e76				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3e76 3d				db WORD_SYS_CORE+41             
3e77 cc 3e			dw .HOME            
3e79 03				db 2 + 1 
3e7a .. 00			db "AT",0              
3e7d				endm 
# End of macro CWHEAD
3e7d			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3e7d					if DEBUG_FORTH_WORDS_KEY 
3e7d						DMARK "AT." 
3e7d f5				push af  
3e7e 3a 92 3e			ld a, (.dmark)  
3e81 32 6b ee			ld (debug_mark),a  
3e84 3a 93 3e			ld a, (.dmark+1)  
3e87 32 6c ee			ld (debug_mark+1),a  
3e8a 3a 94 3e			ld a, (.dmark+2)  
3e8d 32 6d ee			ld (debug_mark+2),a  
3e90 18 03			jr .pastdmark  
3e92 ..			.dmark: db "AT."  
3e95 f1			.pastdmark: pop af  
3e96			endm  
# End of macro DMARK
3e96						CALLMONITOR 
3e96 cd 6f ee			call debug_vector  
3e99				endm  
# End of macro CALLMONITOR
3e99					endif 
3e99					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e99 cd 4d 1e			call macro_dsp_valuehl 
3e9c				endm 
# End of macro FORTH_DSP_VALUEHL
3e9c			 
3e9c			 
3e9c					; TODO save cursor row 
3e9c 7d					ld a,l 
3e9d fe 02				cp 2 
3e9f 20 04				jr nz, .crow3 
3ea1 3e 28				ld a, display_row_2 
3ea3 18 12				jr .ccol1 
3ea5 fe 03		.crow3:		cp 3 
3ea7 20 04				jr nz, .crow4 
3ea9 3e 50				ld a, display_row_3 
3eab 18 0a				jr .ccol1 
3ead fe 04		.crow4:		cp 4 
3eaf 20 04				jr nz, .crow1 
3eb1 3e 78				ld a, display_row_4 
3eb3 18 02				jr .ccol1 
3eb5 3e 00		.crow1:		ld a,display_row_1 
3eb7 f5			.ccol1:		push af			; got row offset 
3eb8 6f					ld l,a 
3eb9 26 00				ld h,0 
3ebb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ebb cd 05 1f			call macro_forth_dsp_pop 
3ebe				endm 
# End of macro FORTH_DSP_POP
3ebe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ebe cd 4d 1e			call macro_dsp_valuehl 
3ec1				endm 
# End of macro FORTH_DSP_VALUEHL
3ec1					; TODO save cursor col 
3ec1 f1					pop af 
3ec2 85					add l		; add col offset 
3ec3 32 5e ea				ld (f_cursor_ptr), a 
3ec6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ec6 cd 05 1f			call macro_forth_dsp_pop 
3ec9				endm 
# End of macro FORTH_DSP_POP
3ec9			 
3ec9					; calculate  
3ec9			 
3ec9					NEXTW 
3ec9 c3 03 20			jp macro_next 
3ecc				endm 
# End of macro NEXTW
3ecc			 
3ecc			 
3ecc			.HOME: 
3ecc				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3ecc 41				db WORD_SYS_CORE+45             
3ecd f9 3e			dw .SPACE            
3ecf 05				db 4 + 1 
3ed0 .. 00			db "HOME",0              
3ed5				endm 
# End of macro CWHEAD
3ed5			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3ed5					if DEBUG_FORTH_WORDS_KEY 
3ed5						DMARK "HOM" 
3ed5 f5				push af  
3ed6 3a ea 3e			ld a, (.dmark)  
3ed9 32 6b ee			ld (debug_mark),a  
3edc 3a eb 3e			ld a, (.dmark+1)  
3edf 32 6c ee			ld (debug_mark+1),a  
3ee2 3a ec 3e			ld a, (.dmark+2)  
3ee5 32 6d ee			ld (debug_mark+2),a  
3ee8 18 03			jr .pastdmark  
3eea ..			.dmark: db "HOM"  
3eed f1			.pastdmark: pop af  
3eee			endm  
# End of macro DMARK
3eee						CALLMONITOR 
3eee cd 6f ee			call debug_vector  
3ef1				endm  
# End of macro CALLMONITOR
3ef1					endif 
3ef1 3e 00		.home:		ld a, 0		; and home cursor 
3ef3 32 5e ea				ld (f_cursor_ptr), a 
3ef6					NEXTW 
3ef6 c3 03 20			jp macro_next 
3ef9				endm 
# End of macro NEXTW
3ef9			 
3ef9			 
3ef9			.SPACE: 
3ef9				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3ef9 46				db WORD_SYS_CORE+50             
3efa 2f 3f			dw .SPACES            
3efc 03				db 2 + 1 
3efd .. 00			db "BL",0              
3f00				endm 
# End of macro CWHEAD
3f00			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f00					if DEBUG_FORTH_WORDS_KEY 
3f00						DMARK "BL." 
3f00 f5				push af  
3f01 3a 15 3f			ld a, (.dmark)  
3f04 32 6b ee			ld (debug_mark),a  
3f07 3a 16 3f			ld a, (.dmark+1)  
3f0a 32 6c ee			ld (debug_mark+1),a  
3f0d 3a 17 3f			ld a, (.dmark+2)  
3f10 32 6d ee			ld (debug_mark+2),a  
3f13 18 03			jr .pastdmark  
3f15 ..			.dmark: db "BL."  
3f18 f1			.pastdmark: pop af  
3f19			endm  
# End of macro DMARK
3f19						CALLMONITOR 
3f19 cd 6f ee			call debug_vector  
3f1c				endm  
# End of macro CALLMONITOR
3f1c					endif 
3f1c 3e 20				ld a, " " 
3f1e 32 c1 e2				ld (scratch),a 
3f21 3e 00				ld a, 0 
3f23 32 c2 e2				ld (scratch+1),a 
3f26 21 c1 e2				ld hl, scratch 
3f29 cd c4 1c				call forth_push_str 
3f2c					 
3f2c				       NEXTW 
3f2c c3 03 20			jp macro_next 
3f2f				endm 
# End of macro NEXTW
3f2f			 
3f2f			;.blstr: db " ", 0 
3f2f			 
3f2f			.SPACES: 
3f2f				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f2f 47				db WORD_SYS_CORE+51             
3f30 ca 3f			dw .SCROLL            
3f32 07				db 6 + 1 
3f33 .. 00			db "SPACES",0              
3f3a				endm 
# End of macro CWHEAD
3f3a			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f3a					if DEBUG_FORTH_WORDS_KEY 
3f3a						DMARK "SPS" 
3f3a f5				push af  
3f3b 3a 4f 3f			ld a, (.dmark)  
3f3e 32 6b ee			ld (debug_mark),a  
3f41 3a 50 3f			ld a, (.dmark+1)  
3f44 32 6c ee			ld (debug_mark+1),a  
3f47 3a 51 3f			ld a, (.dmark+2)  
3f4a 32 6d ee			ld (debug_mark+2),a  
3f4d 18 03			jr .pastdmark  
3f4f ..			.dmark: db "SPS"  
3f52 f1			.pastdmark: pop af  
3f53			endm  
# End of macro DMARK
3f53						CALLMONITOR 
3f53 cd 6f ee			call debug_vector  
3f56				endm  
# End of macro CALLMONITOR
3f56					endif 
3f56			 
3f56			 
3f56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f56 cd 4d 1e			call macro_dsp_valuehl 
3f59				endm 
# End of macro FORTH_DSP_VALUEHL
3f59			 
3f59 e5					push hl    ; u 
3f5a					if DEBUG_FORTH_WORDS 
3f5a						DMARK "SPA" 
3f5a f5				push af  
3f5b 3a 6f 3f			ld a, (.dmark)  
3f5e 32 6b ee			ld (debug_mark),a  
3f61 3a 70 3f			ld a, (.dmark+1)  
3f64 32 6c ee			ld (debug_mark+1),a  
3f67 3a 71 3f			ld a, (.dmark+2)  
3f6a 32 6d ee			ld (debug_mark+2),a  
3f6d 18 03			jr .pastdmark  
3f6f ..			.dmark: db "SPA"  
3f72 f1			.pastdmark: pop af  
3f73			endm  
# End of macro DMARK
3f73						CALLMONITOR 
3f73 cd 6f ee			call debug_vector  
3f76				endm  
# End of macro CALLMONITOR
3f76					endif 
3f76			 
3f76					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f76 cd 05 1f			call macro_forth_dsp_pop 
3f79				endm 
# End of macro FORTH_DSP_POP
3f79 e1					pop hl 
3f7a 0e 00				ld c, 0 
3f7c 45					ld b, l 
3f7d 21 c1 e2				ld hl, scratch  
3f80			 
3f80					if DEBUG_FORTH_WORDS 
3f80						DMARK "SP2" 
3f80 f5				push af  
3f81 3a 95 3f			ld a, (.dmark)  
3f84 32 6b ee			ld (debug_mark),a  
3f87 3a 96 3f			ld a, (.dmark+1)  
3f8a 32 6c ee			ld (debug_mark+1),a  
3f8d 3a 97 3f			ld a, (.dmark+2)  
3f90 32 6d ee			ld (debug_mark+2),a  
3f93 18 03			jr .pastdmark  
3f95 ..			.dmark: db "SP2"  
3f98 f1			.pastdmark: pop af  
3f99			endm  
# End of macro DMARK
3f99						CALLMONITOR 
3f99 cd 6f ee			call debug_vector  
3f9c				endm  
# End of macro CALLMONITOR
3f9c					endif 
3f9c 3e 20				ld a, ' ' 
3f9e			.spaces1:	 
3f9e 77					ld (hl),a 
3f9f 23					inc hl 
3fa0					 
3fa0 10 fc				djnz .spaces1 
3fa2 3e 00				ld a,0 
3fa4 77					ld (hl),a 
3fa5 21 c1 e2				ld hl, scratch 
3fa8					if DEBUG_FORTH_WORDS 
3fa8						DMARK "SP3" 
3fa8 f5				push af  
3fa9 3a bd 3f			ld a, (.dmark)  
3fac 32 6b ee			ld (debug_mark),a  
3faf 3a be 3f			ld a, (.dmark+1)  
3fb2 32 6c ee			ld (debug_mark+1),a  
3fb5 3a bf 3f			ld a, (.dmark+2)  
3fb8 32 6d ee			ld (debug_mark+2),a  
3fbb 18 03			jr .pastdmark  
3fbd ..			.dmark: db "SP3"  
3fc0 f1			.pastdmark: pop af  
3fc1			endm  
# End of macro DMARK
3fc1						CALLMONITOR 
3fc1 cd 6f ee			call debug_vector  
3fc4				endm  
# End of macro CALLMONITOR
3fc4					endif 
3fc4 cd c4 1c				call forth_push_str 
3fc7			 
3fc7				       NEXTW 
3fc7 c3 03 20			jp macro_next 
3fca				endm 
# End of macro NEXTW
3fca			 
3fca			 
3fca			 
3fca			.SCROLL: 
3fca				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3fca 53				db WORD_SYS_CORE+63             
3fcb f7 3f			dw .SCROLLD            
3fcd 07				db 6 + 1 
3fce .. 00			db "SCROLL",0              
3fd5				endm 
# End of macro CWHEAD
3fd5			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3fd5					if DEBUG_FORTH_WORDS_KEY 
3fd5						DMARK "SCR" 
3fd5 f5				push af  
3fd6 3a ea 3f			ld a, (.dmark)  
3fd9 32 6b ee			ld (debug_mark),a  
3fdc 3a eb 3f			ld a, (.dmark+1)  
3fdf 32 6c ee			ld (debug_mark+1),a  
3fe2 3a ec 3f			ld a, (.dmark+2)  
3fe5 32 6d ee			ld (debug_mark+2),a  
3fe8 18 03			jr .pastdmark  
3fea ..			.dmark: db "SCR"  
3fed f1			.pastdmark: pop af  
3fee			endm  
# End of macro DMARK
3fee						CALLMONITOR 
3fee cd 6f ee			call debug_vector  
3ff1				endm  
# End of macro CALLMONITOR
3ff1					endif 
3ff1			 
3ff1 cd 7c 0b			call scroll_up 
3ff4			;	call update_display 
3ff4			 
3ff4					NEXTW 
3ff4 c3 03 20			jp macro_next 
3ff7				endm 
# End of macro NEXTW
3ff7			 
3ff7			 
3ff7			 
3ff7			;		; get dir 
3ff7			; 
3ff7			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ff7			; 
3ff7			;		push hl 
3ff7			; 
3ff7			;		; destroy value TOS 
3ff7			; 
3ff7			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ff7			; 
3ff7			;		; get count 
3ff7			; 
3ff7			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ff7			; 
3ff7			;		push hl 
3ff7			; 
3ff7			;		; destroy value TOS 
3ff7			; 
3ff7			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ff7			; 
3ff7			;		; one value on hl get other one back 
3ff7			; 
3ff7			;		pop bc    ; count 
3ff7			; 
3ff7			;		pop de   ; dir 
3ff7			; 
3ff7			; 
3ff7			;		ld b, c 
3ff7			; 
3ff7			;.scrolldir:     push bc 
3ff7			;		push de 
3ff7			; 
3ff7			;		ld a, 0 
3ff7			;		cp e 
3ff7			;		jr z, .scrollup  
3ff7			;		call scroll_down 
3ff7			;		jr .scrollnext 
3ff7			;.scrollup:	call scroll_up 
3ff7			; 
3ff7			;		 
3ff7			;.scrollnext: 
3ff7			;		pop de 
3ff7			;		pop bc 
3ff7			;		djnz .scrolldir 
3ff7			; 
3ff7			; 
3ff7			; 
3ff7			; 
3ff7			; 
3ff7			;		NEXTW 
3ff7			 
3ff7			.SCROLLD: 
3ff7				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3ff7 53				db WORD_SYS_CORE+63             
3ff8 25 40			dw .ATQ            
3ffa 08				db 7 + 1 
3ffb .. 00			db "SCROLLD",0              
4003				endm 
# End of macro CWHEAD
4003			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4003					if DEBUG_FORTH_WORDS_KEY 
4003						DMARK "SCD" 
4003 f5				push af  
4004 3a 18 40			ld a, (.dmark)  
4007 32 6b ee			ld (debug_mark),a  
400a 3a 19 40			ld a, (.dmark+1)  
400d 32 6c ee			ld (debug_mark+1),a  
4010 3a 1a 40			ld a, (.dmark+2)  
4013 32 6d ee			ld (debug_mark+2),a  
4016 18 03			jr .pastdmark  
4018 ..			.dmark: db "SCD"  
401b f1			.pastdmark: pop af  
401c			endm  
# End of macro DMARK
401c						CALLMONITOR 
401c cd 6f ee			call debug_vector  
401f				endm  
# End of macro CALLMONITOR
401f					endif 
401f			 
401f cd a0 0b			call scroll_down 
4022			;	call update_display 
4022			 
4022					NEXTW 
4022 c3 03 20			jp macro_next 
4025				endm 
# End of macro NEXTW
4025			 
4025			 
4025			.ATQ: 
4025				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4025 62				db WORD_SYS_CORE+78             
4026 83 40			dw .AUTODSP            
4028 04				db 3 + 1 
4029 .. 00			db "AT@",0              
402d				endm 
# End of macro CWHEAD
402d			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
402d					if DEBUG_FORTH_WORDS_KEY 
402d						DMARK "ATA" 
402d f5				push af  
402e 3a 42 40			ld a, (.dmark)  
4031 32 6b ee			ld (debug_mark),a  
4034 3a 43 40			ld a, (.dmark+1)  
4037 32 6c ee			ld (debug_mark+1),a  
403a 3a 44 40			ld a, (.dmark+2)  
403d 32 6d ee			ld (debug_mark+2),a  
4040 18 03			jr .pastdmark  
4042 ..			.dmark: db "ATA"  
4045 f1			.pastdmark: pop af  
4046			endm  
# End of macro DMARK
4046						CALLMONITOR 
4046 cd 6f ee			call debug_vector  
4049				endm  
# End of macro CALLMONITOR
4049					endif 
4049			 
4049			 
4049					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4049 cd 4d 1e			call macro_dsp_valuehl 
404c				endm 
# End of macro FORTH_DSP_VALUEHL
404c			 
404c					; TODO save cursor row 
404c 7d					ld a,l 
404d fe 02				cp 2 
404f 20 04				jr nz, .crow3aq 
4051 3e 28				ld a, display_row_2 
4053 18 12				jr .ccol1aq 
4055 fe 03		.crow3aq:		cp 3 
4057 20 04				jr nz, .crow4aq 
4059 3e 50				ld a, display_row_3 
405b 18 0a				jr .ccol1aq 
405d fe 04		.crow4aq:		cp 4 
405f 20 04				jr nz, .crow1aq 
4061 3e 78				ld a, display_row_4 
4063 18 02				jr .ccol1aq 
4065 3e 00		.crow1aq:		ld a,display_row_1 
4067 f5			.ccol1aq:		push af			; got row offset 
4068 6f					ld l,a 
4069 26 00				ld h,0 
406b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
406b cd 05 1f			call macro_forth_dsp_pop 
406e				endm 
# End of macro FORTH_DSP_POP
406e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
406e cd 4d 1e			call macro_dsp_valuehl 
4071				endm 
# End of macro FORTH_DSP_VALUEHL
4071					; TODO save cursor col 
4071 f1					pop af 
4072 85					add l		; add col offset 
4073			 
4073					; add current frame buffer address 
4073 2a cc eb				ld hl, (display_fb_active) 
4076 cd e7 0d				call addatohl 
4079			 
4079			 
4079			 
4079			 
4079					; get char frame buffer location offset in hl 
4079			 
4079 7e					ld a,(hl) 
407a 26 00				ld h, 0 
407c 6f					ld l, a 
407d			 
407d cd 56 1c				call forth_push_numhl 
4080			 
4080			 
4080					NEXTW 
4080 c3 03 20			jp macro_next 
4083				endm 
# End of macro NEXTW
4083			 
4083			.AUTODSP: 
4083				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4083 63				db WORD_SYS_CORE+79             
4084 99 40			dw .MENU            
4086 05				db 4 + 1 
4087 .. 00			db "ADSP",0              
408c				endm 
# End of macro CWHEAD
408c			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
408c			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
408c			 
408c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
408c cd 4d 1e			call macro_dsp_valuehl 
408f				endm 
# End of macro FORTH_DSP_VALUEHL
408f			 
408f			;		push hl 
408f			 
408f					; destroy value TOS 
408f			 
408f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
408f cd 05 1f			call macro_forth_dsp_pop 
4092				endm 
# End of macro FORTH_DSP_POP
4092			 
4092			;		pop hl 
4092			 
4092 7d					ld a,l 
4093 32 3c ea				ld (cli_autodisplay), a 
4096				       NEXTW 
4096 c3 03 20			jp macro_next 
4099				endm 
# End of macro NEXTW
4099			 
4099			.MENU: 
4099				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4099 70				db WORD_SYS_CORE+92             
409a 42 41			dw .ENDDISPLAY            
409c 05				db 4 + 1 
409d .. 00			db "MENU",0              
40a2				endm 
# End of macro CWHEAD
40a2			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
40a2			 
40a2			;		; get number of items on the stack 
40a2			; 
40a2				 
40a2					FORTH_DSP_VALUEHL 
40a2 cd 4d 1e			call macro_dsp_valuehl 
40a5				endm 
# End of macro FORTH_DSP_VALUEHL
40a5				 
40a5					if DEBUG_FORTH_WORDS_KEY 
40a5						DMARK "MNU" 
40a5 f5				push af  
40a6 3a ba 40			ld a, (.dmark)  
40a9 32 6b ee			ld (debug_mark),a  
40ac 3a bb 40			ld a, (.dmark+1)  
40af 32 6c ee			ld (debug_mark+1),a  
40b2 3a bc 40			ld a, (.dmark+2)  
40b5 32 6d ee			ld (debug_mark+2),a  
40b8 18 03			jr .pastdmark  
40ba ..			.dmark: db "MNU"  
40bd f1			.pastdmark: pop af  
40be			endm  
# End of macro DMARK
40be						CALLMONITOR 
40be cd 6f ee			call debug_vector  
40c1				endm  
# End of macro CALLMONITOR
40c1					endif 
40c1			 
40c1 45					ld b, l	 
40c2 05					dec b 
40c3			 
40c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40c3 cd 05 1f			call macro_forth_dsp_pop 
40c6				endm 
# End of macro FORTH_DSP_POP
40c6			 
40c6			 
40c6					; go directly through the stack to pluck out the string pointers and build an array 
40c6			 
40c6			;		FORTH_DSP 
40c6			 
40c6					; hl contains top most stack item 
40c6				 
40c6 11 c1 e2				ld de, scratch 
40c9			 
40c9			.mbuild: 
40c9			 
40c9					FORTH_DSP_VALUEHL 
40c9 cd 4d 1e			call macro_dsp_valuehl 
40cc				endm 
# End of macro FORTH_DSP_VALUEHL
40cc			 
40cc					if DEBUG_FORTH_WORDS 
40cc						DMARK "MN3" 
40cc f5				push af  
40cd 3a e1 40			ld a, (.dmark)  
40d0 32 6b ee			ld (debug_mark),a  
40d3 3a e2 40			ld a, (.dmark+1)  
40d6 32 6c ee			ld (debug_mark+1),a  
40d9 3a e3 40			ld a, (.dmark+2)  
40dc 32 6d ee			ld (debug_mark+2),a  
40df 18 03			jr .pastdmark  
40e1 ..			.dmark: db "MN3"  
40e4 f1			.pastdmark: pop af  
40e5			endm  
# End of macro DMARK
40e5						CALLMONITOR 
40e5 cd 6f ee			call debug_vector  
40e8				endm  
# End of macro CALLMONITOR
40e8					endif 
40e8 eb					ex de, hl 
40e9 73					ld (hl), e 
40ea 23					inc hl 
40eb 72					ld (hl), d 
40ec 23					inc hl 
40ed eb					ex de, hl 
40ee			 
40ee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ee cd 05 1f			call macro_forth_dsp_pop 
40f1				endm 
# End of macro FORTH_DSP_POP
40f1			 
40f1 10 d6				djnz .mbuild 
40f3			 
40f3					; done add term 
40f3			 
40f3 eb					ex de, hl 
40f4 36 00				ld (hl), 0 
40f6 23					inc hl 
40f7 36 00				ld (hl), 0 
40f9			 
40f9				 
40f9					 
40f9 21 c1 e2				ld hl, scratch 
40fc			 
40fc					if DEBUG_FORTH_WORDS 
40fc						DMARK "MNx" 
40fc f5				push af  
40fd 3a 11 41			ld a, (.dmark)  
4100 32 6b ee			ld (debug_mark),a  
4103 3a 12 41			ld a, (.dmark+1)  
4106 32 6c ee			ld (debug_mark+1),a  
4109 3a 13 41			ld a, (.dmark+2)  
410c 32 6d ee			ld (debug_mark+2),a  
410f 18 03			jr .pastdmark  
4111 ..			.dmark: db "MNx"  
4114 f1			.pastdmark: pop af  
4115			endm  
# End of macro DMARK
4115						CALLMONITOR 
4115 cd 6f ee			call debug_vector  
4118				endm  
# End of macro CALLMONITOR
4118					endif 
4118			 
4118			 
4118			 
4118 3e 00				ld a, 0 
411a cd eb 0b				call menu 
411d			 
411d			 
411d 6f					ld l, a 
411e 26 00				ld h, 0 
4120			 
4120					if DEBUG_FORTH_WORDS 
4120						DMARK "MNr" 
4120 f5				push af  
4121 3a 35 41			ld a, (.dmark)  
4124 32 6b ee			ld (debug_mark),a  
4127 3a 36 41			ld a, (.dmark+1)  
412a 32 6c ee			ld (debug_mark+1),a  
412d 3a 37 41			ld a, (.dmark+2)  
4130 32 6d ee			ld (debug_mark+2),a  
4133 18 03			jr .pastdmark  
4135 ..			.dmark: db "MNr"  
4138 f1			.pastdmark: pop af  
4139			endm  
# End of macro DMARK
4139						CALLMONITOR 
4139 cd 6f ee			call debug_vector  
413c				endm  
# End of macro CALLMONITOR
413c					endif 
413c			 
413c cd 56 1c				call forth_push_numhl 
413f			 
413f			 
413f			 
413f			 
413f				       NEXTW 
413f c3 03 20			jp macro_next 
4142				endm 
# End of macro NEXTW
4142			 
4142			 
4142			.ENDDISPLAY: 
4142			 
4142			; eof 
# End of file forth_words_display.asm
4142			include "forth_words_str.asm" 
4142			 
4142			; | ## String Words 
4142			 
4142			.PTR:   
4142			 
4142				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4142 48				db WORD_SYS_CORE+52             
4143 6f 41			dw .STYPE            
4145 04				db 3 + 1 
4146 .. 00			db "PTR",0              
414a				endm 
# End of macro CWHEAD
414a			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
414a			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
414a			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
414a			 
414a					if DEBUG_FORTH_WORDS_KEY 
414a						DMARK "PTR" 
414a f5				push af  
414b 3a 5f 41			ld a, (.dmark)  
414e 32 6b ee			ld (debug_mark),a  
4151 3a 60 41			ld a, (.dmark+1)  
4154 32 6c ee			ld (debug_mark+1),a  
4157 3a 61 41			ld a, (.dmark+2)  
415a 32 6d ee			ld (debug_mark+2),a  
415d 18 03			jr .pastdmark  
415f ..			.dmark: db "PTR"  
4162 f1			.pastdmark: pop af  
4163			endm  
# End of macro DMARK
4163						CALLMONITOR 
4163 cd 6f ee			call debug_vector  
4166				endm  
# End of macro CALLMONITOR
4166					endif 
4166					FORTH_DSP_VALUEHL 
4166 cd 4d 1e			call macro_dsp_valuehl 
4169				endm 
# End of macro FORTH_DSP_VALUEHL
4169 cd 56 1c				call forth_push_numhl 
416c			 
416c			 
416c					NEXTW 
416c c3 03 20			jp macro_next 
416f				endm 
# End of macro NEXTW
416f			.STYPE: 
416f				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
416f 48				db WORD_SYS_CORE+52             
4170 be 41			dw .UPPER            
4172 06				db 5 + 1 
4173 .. 00			db "STYPE",0              
4179				endm 
# End of macro CWHEAD
4179			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4179					if DEBUG_FORTH_WORDS_KEY 
4179						DMARK "STY" 
4179 f5				push af  
417a 3a 8e 41			ld a, (.dmark)  
417d 32 6b ee			ld (debug_mark),a  
4180 3a 8f 41			ld a, (.dmark+1)  
4183 32 6c ee			ld (debug_mark+1),a  
4186 3a 90 41			ld a, (.dmark+2)  
4189 32 6d ee			ld (debug_mark+2),a  
418c 18 03			jr .pastdmark  
418e ..			.dmark: db "STY"  
4191 f1			.pastdmark: pop af  
4192			endm  
# End of macro DMARK
4192						CALLMONITOR 
4192 cd 6f ee			call debug_vector  
4195				endm  
# End of macro CALLMONITOR
4195					endif 
4195					FORTH_DSP 
4195 cd 13 1e			call macro_forth_dsp 
4198				endm 
# End of macro FORTH_DSP
4198					;v5 FORTH_DSP_VALUE 
4198			 
4198 7e					ld a, (hl) 
4199			 
4199 f5					push af 
419a			 
419a			; Dont destroy TOS		FORTH_DSP_POP 
419a			 
419a f1					pop af 
419b			 
419b fe 01				cp DS_TYPE_STR 
419d 28 09				jr z, .typestr 
419f			 
419f fe 02				cp DS_TYPE_INUM 
41a1 28 0a				jr z, .typeinum 
41a3			 
41a3 21 bc 41				ld hl, .tna 
41a6 18 0a				jr .tpush 
41a8			 
41a8 21 b8 41		.typestr:	ld hl, .tstr 
41ab 18 05				jr .tpush 
41ad 21 ba 41		.typeinum:	ld hl, .tinum 
41b0 18 00				jr .tpush 
41b2			 
41b2			.tpush: 
41b2			 
41b2 cd c4 1c				call forth_push_str 
41b5			 
41b5					NEXTW 
41b5 c3 03 20			jp macro_next 
41b8				endm 
# End of macro NEXTW
41b8 .. 00		.tstr:	db "s",0 
41ba .. 00		.tinum:  db "i",0 
41bc .. 00		.tna:   db "?", 0 
41be			 
41be			 
41be			.UPPER: 
41be				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
41be 48				db WORD_SYS_CORE+52             
41bf f9 41			dw .LOWER            
41c1 06				db 5 + 1 
41c2 .. 00			db "UPPER",0              
41c8				endm 
# End of macro CWHEAD
41c8			; | UPPER ( s -- s ) Upper case string s  | DONE 
41c8					if DEBUG_FORTH_WORDS_KEY 
41c8						DMARK "UPR" 
41c8 f5				push af  
41c9 3a dd 41			ld a, (.dmark)  
41cc 32 6b ee			ld (debug_mark),a  
41cf 3a de 41			ld a, (.dmark+1)  
41d2 32 6c ee			ld (debug_mark+1),a  
41d5 3a df 41			ld a, (.dmark+2)  
41d8 32 6d ee			ld (debug_mark+2),a  
41db 18 03			jr .pastdmark  
41dd ..			.dmark: db "UPR"  
41e0 f1			.pastdmark: pop af  
41e1			endm  
# End of macro DMARK
41e1						CALLMONITOR 
41e1 cd 6f ee			call debug_vector  
41e4				endm  
# End of macro CALLMONITOR
41e4					endif 
41e4			 
41e4					FORTH_DSP 
41e4 cd 13 1e			call macro_forth_dsp 
41e7				endm 
# End of macro FORTH_DSP
41e7					 
41e7			; TODO check is string type 
41e7			 
41e7					FORTH_DSP_VALUEHL 
41e7 cd 4d 1e			call macro_dsp_valuehl 
41ea				endm 
# End of macro FORTH_DSP_VALUEHL
41ea			; get pointer to string in hl 
41ea			 
41ea 7e			.toup:		ld a, (hl) 
41eb fe 00				cp 0 
41ed 28 07				jr z, .toupdone 
41ef			 
41ef cd 54 11				call to_upper 
41f2			 
41f2 77					ld (hl), a 
41f3 23					inc hl 
41f4 18 f4				jr .toup 
41f6			 
41f6					 
41f6			 
41f6			 
41f6			; for each char convert to upper 
41f6					 
41f6			.toupdone: 
41f6			 
41f6			 
41f6					NEXTW 
41f6 c3 03 20			jp macro_next 
41f9				endm 
# End of macro NEXTW
41f9			.LOWER: 
41f9				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
41f9 48				db WORD_SYS_CORE+52             
41fa 34 42			dw .TCASE            
41fc 06				db 5 + 1 
41fd .. 00			db "LOWER",0              
4203				endm 
# End of macro CWHEAD
4203			; | LOWER ( s -- s ) Lower case string s  | DONE 
4203					if DEBUG_FORTH_WORDS_KEY 
4203						DMARK "LWR" 
4203 f5				push af  
4204 3a 18 42			ld a, (.dmark)  
4207 32 6b ee			ld (debug_mark),a  
420a 3a 19 42			ld a, (.dmark+1)  
420d 32 6c ee			ld (debug_mark+1),a  
4210 3a 1a 42			ld a, (.dmark+2)  
4213 32 6d ee			ld (debug_mark+2),a  
4216 18 03			jr .pastdmark  
4218 ..			.dmark: db "LWR"  
421b f1			.pastdmark: pop af  
421c			endm  
# End of macro DMARK
421c						CALLMONITOR 
421c cd 6f ee			call debug_vector  
421f				endm  
# End of macro CALLMONITOR
421f					endif 
421f			 
421f					FORTH_DSP 
421f cd 13 1e			call macro_forth_dsp 
4222				endm 
# End of macro FORTH_DSP
4222					 
4222			; TODO check is string type 
4222			 
4222					FORTH_DSP_VALUEHL 
4222 cd 4d 1e			call macro_dsp_valuehl 
4225				endm 
# End of macro FORTH_DSP_VALUEHL
4225			; get pointer to string in hl 
4225			 
4225 7e			.tolow:		ld a, (hl) 
4226 fe 00				cp 0 
4228 28 07				jr z, .tolowdone 
422a			 
422a cd 5d 11				call to_lower 
422d			 
422d 77					ld (hl), a 
422e 23					inc hl 
422f 18 f4				jr .tolow 
4231			 
4231					 
4231			 
4231			 
4231			; for each char convert to low 
4231					 
4231			.tolowdone: 
4231					NEXTW 
4231 c3 03 20			jp macro_next 
4234				endm 
# End of macro NEXTW
4234			.TCASE: 
4234				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4234 48				db WORD_SYS_CORE+52             
4235 6a 43			dw .SUBSTR            
4237 06				db 5 + 1 
4238 .. 00			db "TCASE",0              
423e				endm 
# End of macro CWHEAD
423e			; | TCASE ( s -- s ) Title case string s  | DONE 
423e					if DEBUG_FORTH_WORDS_KEY 
423e						DMARK "TCS" 
423e f5				push af  
423f 3a 53 42			ld a, (.dmark)  
4242 32 6b ee			ld (debug_mark),a  
4245 3a 54 42			ld a, (.dmark+1)  
4248 32 6c ee			ld (debug_mark+1),a  
424b 3a 55 42			ld a, (.dmark+2)  
424e 32 6d ee			ld (debug_mark+2),a  
4251 18 03			jr .pastdmark  
4253 ..			.dmark: db "TCS"  
4256 f1			.pastdmark: pop af  
4257			endm  
# End of macro DMARK
4257						CALLMONITOR 
4257 cd 6f ee			call debug_vector  
425a				endm  
# End of macro CALLMONITOR
425a					endif 
425a			 
425a					FORTH_DSP 
425a cd 13 1e			call macro_forth_dsp 
425d				endm 
# End of macro FORTH_DSP
425d					 
425d			; TODO check is string type 
425d			 
425d					FORTH_DSP_VALUEHL 
425d cd 4d 1e			call macro_dsp_valuehl 
4260				endm 
# End of macro FORTH_DSP_VALUEHL
4260			; get pointer to string in hl 
4260			 
4260					if DEBUG_FORTH_WORDS 
4260						DMARK "TC1" 
4260 f5				push af  
4261 3a 75 42			ld a, (.dmark)  
4264 32 6b ee			ld (debug_mark),a  
4267 3a 76 42			ld a, (.dmark+1)  
426a 32 6c ee			ld (debug_mark+1),a  
426d 3a 77 42			ld a, (.dmark+2)  
4270 32 6d ee			ld (debug_mark+2),a  
4273 18 03			jr .pastdmark  
4275 ..			.dmark: db "TC1"  
4278 f1			.pastdmark: pop af  
4279			endm  
# End of macro DMARK
4279						CALLMONITOR 
4279 cd 6f ee			call debug_vector  
427c				endm  
# End of macro CALLMONITOR
427c					endif 
427c			 
427c					; first time in turn to upper case first char 
427c			 
427c 7e					ld a, (hl) 
427d c3 07 43				jp .totsiptou 
4280			 
4280			 
4280 7e			.tot:		ld a, (hl) 
4281 fe 00				cp 0 
4283 ca 4b 43				jp z, .totdone 
4286			 
4286					if DEBUG_FORTH_WORDS 
4286						DMARK "TC2" 
4286 f5				push af  
4287 3a 9b 42			ld a, (.dmark)  
428a 32 6b ee			ld (debug_mark),a  
428d 3a 9c 42			ld a, (.dmark+1)  
4290 32 6c ee			ld (debug_mark+1),a  
4293 3a 9d 42			ld a, (.dmark+2)  
4296 32 6d ee			ld (debug_mark+2),a  
4299 18 03			jr .pastdmark  
429b ..			.dmark: db "TC2"  
429e f1			.pastdmark: pop af  
429f			endm  
# End of macro DMARK
429f						CALLMONITOR 
429f cd 6f ee			call debug_vector  
42a2				endm  
# End of macro CALLMONITOR
42a2					endif 
42a2					; check to see if current char is a space 
42a2			 
42a2 fe 20				cp ' ' 
42a4 28 21				jr z, .totsp 
42a6 cd 5d 11				call to_lower 
42a9					if DEBUG_FORTH_WORDS 
42a9						DMARK "TC3" 
42a9 f5				push af  
42aa 3a be 42			ld a, (.dmark)  
42ad 32 6b ee			ld (debug_mark),a  
42b0 3a bf 42			ld a, (.dmark+1)  
42b3 32 6c ee			ld (debug_mark+1),a  
42b6 3a c0 42			ld a, (.dmark+2)  
42b9 32 6d ee			ld (debug_mark+2),a  
42bc 18 03			jr .pastdmark  
42be ..			.dmark: db "TC3"  
42c1 f1			.pastdmark: pop af  
42c2			endm  
# End of macro DMARK
42c2						CALLMONITOR 
42c2 cd 6f ee			call debug_vector  
42c5				endm  
# End of macro CALLMONITOR
42c5					endif 
42c5 18 63				jr .totnxt 
42c7			 
42c7			.totsp:         ; on a space, find next char which should be upper 
42c7			 
42c7					if DEBUG_FORTH_WORDS 
42c7						DMARK "TC4" 
42c7 f5				push af  
42c8 3a dc 42			ld a, (.dmark)  
42cb 32 6b ee			ld (debug_mark),a  
42ce 3a dd 42			ld a, (.dmark+1)  
42d1 32 6c ee			ld (debug_mark+1),a  
42d4 3a de 42			ld a, (.dmark+2)  
42d7 32 6d ee			ld (debug_mark+2),a  
42da 18 03			jr .pastdmark  
42dc ..			.dmark: db "TC4"  
42df f1			.pastdmark: pop af  
42e0			endm  
# End of macro DMARK
42e0						CALLMONITOR 
42e0 cd 6f ee			call debug_vector  
42e3				endm  
# End of macro CALLMONITOR
42e3					endif 
42e3					;; 
42e3			 
42e3 fe 20				cp ' ' 
42e5 20 20				jr nz, .totsiptou 
42e7 23					inc hl 
42e8 7e					ld a, (hl) 
42e9					if DEBUG_FORTH_WORDS 
42e9						DMARK "TC5" 
42e9 f5				push af  
42ea 3a fe 42			ld a, (.dmark)  
42ed 32 6b ee			ld (debug_mark),a  
42f0 3a ff 42			ld a, (.dmark+1)  
42f3 32 6c ee			ld (debug_mark+1),a  
42f6 3a 00 43			ld a, (.dmark+2)  
42f9 32 6d ee			ld (debug_mark+2),a  
42fc 18 03			jr .pastdmark  
42fe ..			.dmark: db "TC5"  
4301 f1			.pastdmark: pop af  
4302			endm  
# End of macro DMARK
4302						CALLMONITOR 
4302 cd 6f ee			call debug_vector  
4305				endm  
# End of macro CALLMONITOR
4305					endif 
4305 18 c0				jr .totsp 
4307 fe 00		.totsiptou:    cp 0 
4309 28 40				jr z, .totdone 
430b					; not space and not zero term so upper case it 
430b cd 54 11				call to_upper 
430e			 
430e					if DEBUG_FORTH_WORDS 
430e						DMARK "TC6" 
430e f5				push af  
430f 3a 23 43			ld a, (.dmark)  
4312 32 6b ee			ld (debug_mark),a  
4315 3a 24 43			ld a, (.dmark+1)  
4318 32 6c ee			ld (debug_mark+1),a  
431b 3a 25 43			ld a, (.dmark+2)  
431e 32 6d ee			ld (debug_mark+2),a  
4321 18 03			jr .pastdmark  
4323 ..			.dmark: db "TC6"  
4326 f1			.pastdmark: pop af  
4327			endm  
# End of macro DMARK
4327						CALLMONITOR 
4327 cd 6f ee			call debug_vector  
432a				endm  
# End of macro CALLMONITOR
432a					endif 
432a			 
432a			 
432a			.totnxt: 
432a			 
432a 77					ld (hl), a 
432b 23					inc hl 
432c					if DEBUG_FORTH_WORDS 
432c						DMARK "TC7" 
432c f5				push af  
432d 3a 41 43			ld a, (.dmark)  
4330 32 6b ee			ld (debug_mark),a  
4333 3a 42 43			ld a, (.dmark+1)  
4336 32 6c ee			ld (debug_mark+1),a  
4339 3a 43 43			ld a, (.dmark+2)  
433c 32 6d ee			ld (debug_mark+2),a  
433f 18 03			jr .pastdmark  
4341 ..			.dmark: db "TC7"  
4344 f1			.pastdmark: pop af  
4345			endm  
# End of macro DMARK
4345						CALLMONITOR 
4345 cd 6f ee			call debug_vector  
4348				endm  
# End of macro CALLMONITOR
4348					endif 
4348 c3 80 42				jp .tot 
434b			 
434b					 
434b			 
434b			 
434b			; for each char convert to low 
434b					 
434b			.totdone: 
434b					if DEBUG_FORTH_WORDS 
434b						DMARK "TCd" 
434b f5				push af  
434c 3a 60 43			ld a, (.dmark)  
434f 32 6b ee			ld (debug_mark),a  
4352 3a 61 43			ld a, (.dmark+1)  
4355 32 6c ee			ld (debug_mark+1),a  
4358 3a 62 43			ld a, (.dmark+2)  
435b 32 6d ee			ld (debug_mark+2),a  
435e 18 03			jr .pastdmark  
4360 ..			.dmark: db "TCd"  
4363 f1			.pastdmark: pop af  
4364			endm  
# End of macro DMARK
4364						CALLMONITOR 
4364 cd 6f ee			call debug_vector  
4367				endm  
# End of macro CALLMONITOR
4367					endif 
4367					NEXTW 
4367 c3 03 20			jp macro_next 
436a				endm 
# End of macro NEXTW
436a			 
436a			.SUBSTR: 
436a				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
436a 48				db WORD_SYS_CORE+52             
436b c8 43			dw .LEFT            
436d 07				db 6 + 1 
436e .. 00			db "SUBSTR",0              
4375				endm 
# End of macro CWHEAD
4375			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4375			 
4375					if DEBUG_FORTH_WORDS_KEY 
4375						DMARK "SST" 
4375 f5				push af  
4376 3a 8a 43			ld a, (.dmark)  
4379 32 6b ee			ld (debug_mark),a  
437c 3a 8b 43			ld a, (.dmark+1)  
437f 32 6c ee			ld (debug_mark+1),a  
4382 3a 8c 43			ld a, (.dmark+2)  
4385 32 6d ee			ld (debug_mark+2),a  
4388 18 03			jr .pastdmark  
438a ..			.dmark: db "SST"  
438d f1			.pastdmark: pop af  
438e			endm  
# End of macro DMARK
438e						CALLMONITOR 
438e cd 6f ee			call debug_vector  
4391				endm  
# End of macro CALLMONITOR
4391					endif 
4391			; TODO check string type 
4391					FORTH_DSP_VALUEHL 
4391 cd 4d 1e			call macro_dsp_valuehl 
4394				endm 
# End of macro FORTH_DSP_VALUEHL
4394			 
4394 e5					push hl      ; string length 
4395			 
4395					FORTH_DSP_POP 
4395 cd 05 1f			call macro_forth_dsp_pop 
4398				endm 
# End of macro FORTH_DSP_POP
4398			 
4398					FORTH_DSP_VALUEHL 
4398 cd 4d 1e			call macro_dsp_valuehl 
439b				endm 
# End of macro FORTH_DSP_VALUEHL
439b			 
439b e5					push hl     ; start char 
439c			 
439c					FORTH_DSP_POP 
439c cd 05 1f			call macro_forth_dsp_pop 
439f				endm 
# End of macro FORTH_DSP_POP
439f			 
439f			 
439f					FORTH_DSP_VALUE 
439f cd 36 1e			call macro_forth_dsp_value 
43a2				endm 
# End of macro FORTH_DSP_VALUE
43a2			 
43a2 d1					pop de    ; get start post offset 
43a3			 
43a3 19					add hl, de    ; starting offset 
43a4			 
43a4 c1					pop bc 
43a5 c5					push bc      ; grab size of string 
43a6			 
43a6 e5					push hl    ; save string start  
43a7			 
43a7 26 00				ld h, 0 
43a9 69					ld l, c 
43aa 23					inc hl 
43ab 23					inc hl 
43ac			 
43ac cd ae 12				call malloc 
43af				if DEBUG_FORTH_MALLOC_GUARD 
43af cc e2 4c				call z,malloc_error 
43b2				endif 
43b2			 
43b2 eb					ex de, hl      ; save malloc area for string copy 
43b3 e1					pop hl    ; get back source 
43b4 c1					pop bc    ; get length of string back 
43b5			 
43b5 d5					push de    ; save malloc area for after we push 
43b6 ed b0				ldir     ; copy substr 
43b8			 
43b8			 
43b8 eb					ex de, hl 
43b9 3e 00				ld a, 0 
43bb 77					ld (hl), a   ; term substr 
43bc			 
43bc					 
43bc e1					pop hl    ; get malloc so we can push it 
43bd e5					push hl   ; save so we can free it afterwards 
43be			 
43be cd c4 1c				call forth_push_str 
43c1			 
43c1 e1					pop hl 
43c2 cd 78 13				call free 
43c5			 
43c5					 
43c5					 
43c5			 
43c5			 
43c5					NEXTW 
43c5 c3 03 20			jp macro_next 
43c8				endm 
# End of macro NEXTW
43c8			 
43c8			.LEFT: 
43c8				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
43c8 48				db WORD_SYS_CORE+52             
43c9 f0 43			dw .RIGHT            
43cb 05				db 4 + 1 
43cc .. 00			db "LEFT",0              
43d1				endm 
# End of macro CWHEAD
43d1			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
43d1					if DEBUG_FORTH_WORDS_KEY 
43d1						DMARK "LEF" 
43d1 f5				push af  
43d2 3a e6 43			ld a, (.dmark)  
43d5 32 6b ee			ld (debug_mark),a  
43d8 3a e7 43			ld a, (.dmark+1)  
43db 32 6c ee			ld (debug_mark+1),a  
43de 3a e8 43			ld a, (.dmark+2)  
43e1 32 6d ee			ld (debug_mark+2),a  
43e4 18 03			jr .pastdmark  
43e6 ..			.dmark: db "LEF"  
43e9 f1			.pastdmark: pop af  
43ea			endm  
# End of macro DMARK
43ea						CALLMONITOR 
43ea cd 6f ee			call debug_vector  
43ed				endm  
# End of macro CALLMONITOR
43ed					endif 
43ed			 
43ed					NEXTW 
43ed c3 03 20			jp macro_next 
43f0				endm 
# End of macro NEXTW
43f0			.RIGHT: 
43f0				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
43f0 48				db WORD_SYS_CORE+52             
43f1 19 44			dw .STR2NUM            
43f3 06				db 5 + 1 
43f4 .. 00			db "RIGHT",0              
43fa				endm 
# End of macro CWHEAD
43fa			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
43fa					if DEBUG_FORTH_WORDS_KEY 
43fa						DMARK "RIG" 
43fa f5				push af  
43fb 3a 0f 44			ld a, (.dmark)  
43fe 32 6b ee			ld (debug_mark),a  
4401 3a 10 44			ld a, (.dmark+1)  
4404 32 6c ee			ld (debug_mark+1),a  
4407 3a 11 44			ld a, (.dmark+2)  
440a 32 6d ee			ld (debug_mark+2),a  
440d 18 03			jr .pastdmark  
440f ..			.dmark: db "RIG"  
4412 f1			.pastdmark: pop af  
4413			endm  
# End of macro DMARK
4413						CALLMONITOR 
4413 cd 6f ee			call debug_vector  
4416				endm  
# End of macro CALLMONITOR
4416					endif 
4416			 
4416					NEXTW 
4416 c3 03 20			jp macro_next 
4419				endm 
# End of macro NEXTW
4419			 
4419			 
4419			.STR2NUM: 
4419				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4419 48				db WORD_SYS_CORE+52             
441a a5 44			dw .NUM2STR            
441c 08				db 7 + 1 
441d .. 00			db "STR2NUM",0              
4425				endm 
# End of macro CWHEAD
4425			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4425			 
4425			 
4425			; TODO STR type check to do 
4425					if DEBUG_FORTH_WORDS_KEY 
4425						DMARK "S2N" 
4425 f5				push af  
4426 3a 3a 44			ld a, (.dmark)  
4429 32 6b ee			ld (debug_mark),a  
442c 3a 3b 44			ld a, (.dmark+1)  
442f 32 6c ee			ld (debug_mark+1),a  
4432 3a 3c 44			ld a, (.dmark+2)  
4435 32 6d ee			ld (debug_mark+2),a  
4438 18 03			jr .pastdmark  
443a ..			.dmark: db "S2N"  
443d f1			.pastdmark: pop af  
443e			endm  
# End of macro DMARK
443e						CALLMONITOR 
443e cd 6f ee			call debug_vector  
4441				endm  
# End of macro CALLMONITOR
4441					endif 
4441			 
4441					;FORTH_DSP 
4441					FORTH_DSP_VALUE 
4441 cd 36 1e			call macro_forth_dsp_value 
4444				endm 
# End of macro FORTH_DSP_VALUE
4444					;inc hl 
4444			 
4444 eb					ex de, hl 
4445					if DEBUG_FORTH_WORDS 
4445						DMARK "S2a" 
4445 f5				push af  
4446 3a 5a 44			ld a, (.dmark)  
4449 32 6b ee			ld (debug_mark),a  
444c 3a 5b 44			ld a, (.dmark+1)  
444f 32 6c ee			ld (debug_mark+1),a  
4452 3a 5c 44			ld a, (.dmark+2)  
4455 32 6d ee			ld (debug_mark+2),a  
4458 18 03			jr .pastdmark  
445a ..			.dmark: db "S2a"  
445d f1			.pastdmark: pop af  
445e			endm  
# End of macro DMARK
445e						CALLMONITOR 
445e cd 6f ee			call debug_vector  
4461				endm  
# End of macro CALLMONITOR
4461					endif 
4461 cd dc 11				call string_to_uint16 
4464			 
4464					if DEBUG_FORTH_WORDS 
4464						DMARK "S2b" 
4464 f5				push af  
4465 3a 79 44			ld a, (.dmark)  
4468 32 6b ee			ld (debug_mark),a  
446b 3a 7a 44			ld a, (.dmark+1)  
446e 32 6c ee			ld (debug_mark+1),a  
4471 3a 7b 44			ld a, (.dmark+2)  
4474 32 6d ee			ld (debug_mark+2),a  
4477 18 03			jr .pastdmark  
4479 ..			.dmark: db "S2b"  
447c f1			.pastdmark: pop af  
447d			endm  
# End of macro DMARK
447d						CALLMONITOR 
447d cd 6f ee			call debug_vector  
4480				endm  
# End of macro CALLMONITOR
4480					endif 
4480			;		push hl 
4480					FORTH_DSP_POP 
4480 cd 05 1f			call macro_forth_dsp_pop 
4483				endm 
# End of macro FORTH_DSP_POP
4483			;		pop hl 
4483					 
4483					if DEBUG_FORTH_WORDS 
4483						DMARK "S2b" 
4483 f5				push af  
4484 3a 98 44			ld a, (.dmark)  
4487 32 6b ee			ld (debug_mark),a  
448a 3a 99 44			ld a, (.dmark+1)  
448d 32 6c ee			ld (debug_mark+1),a  
4490 3a 9a 44			ld a, (.dmark+2)  
4493 32 6d ee			ld (debug_mark+2),a  
4496 18 03			jr .pastdmark  
4498 ..			.dmark: db "S2b"  
449b f1			.pastdmark: pop af  
449c			endm  
# End of macro DMARK
449c						CALLMONITOR 
449c cd 6f ee			call debug_vector  
449f				endm  
# End of macro CALLMONITOR
449f					endif 
449f cd 56 1c				call forth_push_numhl	 
44a2			 
44a2				 
44a2				       NEXTW 
44a2 c3 03 20			jp macro_next 
44a5				endm 
# End of macro NEXTW
44a5			.NUM2STR: 
44a5				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
44a5 48				db WORD_SYS_CORE+52             
44a6 b4 44			dw .CONCAT            
44a8 08				db 7 + 1 
44a9 .. 00			db "NUM2STR",0              
44b1				endm 
# End of macro CWHEAD
44b1			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
44b1			 
44b1			;		; malloc a string to target 
44b1			;		ld hl, 10     ; TODO max string size should be fine 
44b1			;		call malloc 
44b1			;		push hl    ; save malloc location 
44b1			; 
44b1			; 
44b1			;; TODO check int type 
44b1			;		FORTH_DSP_VALUEHL 
44b1			;		ld a, l 
44b1			;		call DispAToASCII   
44b1			;;TODO need to chage above call to dump into string 
44b1			; 
44b1			; 
44b1			 
44b1				       NEXTW 
44b1 c3 03 20			jp macro_next 
44b4				endm 
# End of macro NEXTW
44b4			 
44b4			.CONCAT: 
44b4				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
44b4 48				db WORD_SYS_CORE+52             
44b5 67 45			dw .FIND            
44b7 07				db 6 + 1 
44b8 .. 00			db "CONCAT",0              
44bf				endm 
# End of macro CWHEAD
44bf			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
44bf			 
44bf			; TODO check string type 
44bf			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
44bf			 
44bf					if DEBUG_FORTH_WORDS_KEY 
44bf						DMARK "CON" 
44bf f5				push af  
44c0 3a d4 44			ld a, (.dmark)  
44c3 32 6b ee			ld (debug_mark),a  
44c6 3a d5 44			ld a, (.dmark+1)  
44c9 32 6c ee			ld (debug_mark+1),a  
44cc 3a d6 44			ld a, (.dmark+2)  
44cf 32 6d ee			ld (debug_mark+2),a  
44d2 18 03			jr .pastdmark  
44d4 ..			.dmark: db "CON"  
44d7 f1			.pastdmark: pop af  
44d8			endm  
# End of macro DMARK
44d8						CALLMONITOR 
44d8 cd 6f ee			call debug_vector  
44db				endm  
# End of macro CALLMONITOR
44db					endif 
44db			 
44db			 
44db					FORTH_DSP_VALUE 
44db cd 36 1e			call macro_forth_dsp_value 
44de				endm 
# End of macro FORTH_DSP_VALUE
44de e5					push hl   ; s2 
44df			 
44df					FORTH_DSP_POP 
44df cd 05 1f			call macro_forth_dsp_pop 
44e2				endm 
# End of macro FORTH_DSP_POP
44e2			 
44e2					FORTH_DSP_VALUE 
44e2 cd 36 1e			call macro_forth_dsp_value 
44e5				endm 
# End of macro FORTH_DSP_VALUE
44e5			 
44e5 e5					push hl   ; s1 
44e6			 
44e6					FORTH_DSP_POP 
44e6 cd 05 1f			call macro_forth_dsp_pop 
44e9				endm 
# End of macro FORTH_DSP_POP
44e9					 
44e9			 
44e9					; copy s1 
44e9			 
44e9				 
44e9					; save ptr 
44e9 e1					pop hl  
44ea e5					push hl 
44eb 3e 00				ld a, 0 
44ed cd 50 12				call strlent 
44f0					;inc hl    ; zer0 
44f0 06 00				ld b, 0 
44f2 4d					ld c, l 
44f3 e1					pop hl		 
44f4 11 c1 e2				ld de, scratch	 
44f7					if DEBUG_FORTH_WORDS 
44f7						DMARK "CO1" 
44f7 f5				push af  
44f8 3a 0c 45			ld a, (.dmark)  
44fb 32 6b ee			ld (debug_mark),a  
44fe 3a 0d 45			ld a, (.dmark+1)  
4501 32 6c ee			ld (debug_mark+1),a  
4504 3a 0e 45			ld a, (.dmark+2)  
4507 32 6d ee			ld (debug_mark+2),a  
450a 18 03			jr .pastdmark  
450c ..			.dmark: db "CO1"  
450f f1			.pastdmark: pop af  
4510			endm  
# End of macro DMARK
4510						CALLMONITOR 
4510 cd 6f ee			call debug_vector  
4513				endm  
# End of macro CALLMONITOR
4513					endif 
4513 ed b0				ldir 
4515			 
4515 e1					pop hl 
4516 e5					push hl 
4517 d5					push de 
4518			 
4518			 
4518 3e 00				ld a, 0 
451a cd 50 12				call strlent 
451d 23					inc hl    ; zer0 
451e 23					inc hl 
451f 06 00				ld b, 0 
4521 4d					ld c, l 
4522 d1					pop de 
4523 e1					pop hl		 
4524					if DEBUG_FORTH_WORDS 
4524						DMARK "CO2" 
4524 f5				push af  
4525 3a 39 45			ld a, (.dmark)  
4528 32 6b ee			ld (debug_mark),a  
452b 3a 3a 45			ld a, (.dmark+1)  
452e 32 6c ee			ld (debug_mark+1),a  
4531 3a 3b 45			ld a, (.dmark+2)  
4534 32 6d ee			ld (debug_mark+2),a  
4537 18 03			jr .pastdmark  
4539 ..			.dmark: db "CO2"  
453c f1			.pastdmark: pop af  
453d			endm  
# End of macro DMARK
453d						CALLMONITOR 
453d cd 6f ee			call debug_vector  
4540				endm  
# End of macro CALLMONITOR
4540					endif 
4540 ed b0				ldir 
4542			 
4542			 
4542			 
4542 21 c1 e2				ld hl, scratch 
4545					if DEBUG_FORTH_WORDS 
4545						DMARK "CO5" 
4545 f5				push af  
4546 3a 5a 45			ld a, (.dmark)  
4549 32 6b ee			ld (debug_mark),a  
454c 3a 5b 45			ld a, (.dmark+1)  
454f 32 6c ee			ld (debug_mark+1),a  
4552 3a 5c 45			ld a, (.dmark+2)  
4555 32 6d ee			ld (debug_mark+2),a  
4558 18 03			jr .pastdmark  
455a ..			.dmark: db "CO5"  
455d f1			.pastdmark: pop af  
455e			endm  
# End of macro DMARK
455e						CALLMONITOR 
455e cd 6f ee			call debug_vector  
4561				endm  
# End of macro CALLMONITOR
4561					endif 
4561			 
4561 cd c4 1c				call forth_push_str 
4564			 
4564			 
4564			 
4564			 
4564				       NEXTW 
4564 c3 03 20			jp macro_next 
4567				endm 
# End of macro NEXTW
4567			 
4567			 
4567			.FIND: 
4567				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4567 4b				db WORD_SYS_CORE+55             
4568 25 46			dw .LEN            
456a 05				db 4 + 1 
456b .. 00			db "FIND",0              
4570				endm 
# End of macro CWHEAD
4570			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4570			 
4570					if DEBUG_FORTH_WORDS_KEY 
4570						DMARK "FND" 
4570 f5				push af  
4571 3a 85 45			ld a, (.dmark)  
4574 32 6b ee			ld (debug_mark),a  
4577 3a 86 45			ld a, (.dmark+1)  
457a 32 6c ee			ld (debug_mark+1),a  
457d 3a 87 45			ld a, (.dmark+2)  
4580 32 6d ee			ld (debug_mark+2),a  
4583 18 03			jr .pastdmark  
4585 ..			.dmark: db "FND"  
4588 f1			.pastdmark: pop af  
4589			endm  
# End of macro DMARK
4589						CALLMONITOR 
4589 cd 6f ee			call debug_vector  
458c				endm  
# End of macro CALLMONITOR
458c					endif 
458c			 
458c			; TODO check string type 
458c					FORTH_DSP_VALUE 
458c cd 36 1e			call macro_forth_dsp_value 
458f				endm 
# End of macro FORTH_DSP_VALUE
458f			 
458f e5					push hl    
4590 7e					ld a,(hl)    ; char to find   
4591			; TODO change char to substr 
4591			 
4591 f5					push af 
4592					 
4592			 
4592			 
4592					if DEBUG_FORTH_WORDS 
4592						DMARK "FN1" 
4592 f5				push af  
4593 3a a7 45			ld a, (.dmark)  
4596 32 6b ee			ld (debug_mark),a  
4599 3a a8 45			ld a, (.dmark+1)  
459c 32 6c ee			ld (debug_mark+1),a  
459f 3a a9 45			ld a, (.dmark+2)  
45a2 32 6d ee			ld (debug_mark+2),a  
45a5 18 03			jr .pastdmark  
45a7 ..			.dmark: db "FN1"  
45aa f1			.pastdmark: pop af  
45ab			endm  
# End of macro DMARK
45ab						CALLMONITOR 
45ab cd 6f ee			call debug_vector  
45ae				endm  
# End of macro CALLMONITOR
45ae					endif 
45ae			 
45ae					FORTH_DSP_POP 
45ae cd 05 1f			call macro_forth_dsp_pop 
45b1				endm 
# End of macro FORTH_DSP_POP
45b1			 
45b1					; string to search 
45b1			 
45b1					FORTH_DSP_VALUE 
45b1 cd 36 1e			call macro_forth_dsp_value 
45b4				endm 
# End of macro FORTH_DSP_VALUE
45b4			 
45b4 d1					pop de  ; d is char to find  
45b5			 
45b5					if DEBUG_FORTH_WORDS 
45b5						DMARK "FN2" 
45b5 f5				push af  
45b6 3a ca 45			ld a, (.dmark)  
45b9 32 6b ee			ld (debug_mark),a  
45bc 3a cb 45			ld a, (.dmark+1)  
45bf 32 6c ee			ld (debug_mark+1),a  
45c2 3a cc 45			ld a, (.dmark+2)  
45c5 32 6d ee			ld (debug_mark+2),a  
45c8 18 03			jr .pastdmark  
45ca ..			.dmark: db "FN2"  
45cd f1			.pastdmark: pop af  
45ce			endm  
# End of macro DMARK
45ce						CALLMONITOR 
45ce cd 6f ee			call debug_vector  
45d1				endm  
# End of macro CALLMONITOR
45d1					endif 
45d1					 
45d1 01 00 00				ld bc, 0 
45d4 7e			.findchar:      ld a,(hl) 
45d5 fe 00				cp 0   		 
45d7 28 27				jr z, .finddone     
45d9 ba					cp d 
45da 28 20				jr z, .foundchar 
45dc 03					inc bc 
45dd 23					inc hl 
45de					if DEBUG_FORTH_WORDS 
45de						DMARK "FN3" 
45de f5				push af  
45df 3a f3 45			ld a, (.dmark)  
45e2 32 6b ee			ld (debug_mark),a  
45e5 3a f4 45			ld a, (.dmark+1)  
45e8 32 6c ee			ld (debug_mark+1),a  
45eb 3a f5 45			ld a, (.dmark+2)  
45ee 32 6d ee			ld (debug_mark+2),a  
45f1 18 03			jr .pastdmark  
45f3 ..			.dmark: db "FN3"  
45f6 f1			.pastdmark: pop af  
45f7			endm  
# End of macro DMARK
45f7						CALLMONITOR 
45f7 cd 6f ee			call debug_vector  
45fa				endm  
# End of macro CALLMONITOR
45fa					endif 
45fa 18 d8				jr .findchar 
45fc			 
45fc			 
45fc c5			.foundchar:	push bc 
45fd e1					pop hl 
45fe 18 03				jr .findexit 
4600			 
4600			 
4600							 
4600			 
4600			.finddone:     ; got to end of string with no find 
4600 21 00 00				ld hl, 0 
4603			.findexit: 
4603			 
4603					if DEBUG_FORTH_WORDS 
4603						DMARK "FNd" 
4603 f5				push af  
4604 3a 18 46			ld a, (.dmark)  
4607 32 6b ee			ld (debug_mark),a  
460a 3a 19 46			ld a, (.dmark+1)  
460d 32 6c ee			ld (debug_mark+1),a  
4610 3a 1a 46			ld a, (.dmark+2)  
4613 32 6d ee			ld (debug_mark+2),a  
4616 18 03			jr .pastdmark  
4618 ..			.dmark: db "FNd"  
461b f1			.pastdmark: pop af  
461c			endm  
# End of macro DMARK
461c						CALLMONITOR 
461c cd 6f ee			call debug_vector  
461f				endm  
# End of macro CALLMONITOR
461f					endif 
461f cd 56 1c			call forth_push_numhl 
4622			 
4622				       NEXTW 
4622 c3 03 20			jp macro_next 
4625				endm 
# End of macro NEXTW
4625			 
4625			.LEN: 
4625				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4625 4c				db WORD_SYS_CORE+56             
4626 8f 46			dw .ASC            
4628 06				db 5 + 1 
4629 .. 00			db "COUNT",0              
462f				endm 
# End of macro CWHEAD
462f			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
462f			 
462f					if DEBUG_FORTH_WORDS_KEY 
462f						DMARK "CNT" 
462f f5				push af  
4630 3a 44 46			ld a, (.dmark)  
4633 32 6b ee			ld (debug_mark),a  
4636 3a 45 46			ld a, (.dmark+1)  
4639 32 6c ee			ld (debug_mark+1),a  
463c 3a 46 46			ld a, (.dmark+2)  
463f 32 6d ee			ld (debug_mark+2),a  
4642 18 03			jr .pastdmark  
4644 ..			.dmark: db "CNT"  
4647 f1			.pastdmark: pop af  
4648			endm  
# End of macro DMARK
4648						CALLMONITOR 
4648 cd 6f ee			call debug_vector  
464b				endm  
# End of macro CALLMONITOR
464b					endif 
464b			; TODO check string type 
464b					FORTH_DSP_VALUE 
464b cd 36 1e			call macro_forth_dsp_value 
464e				endm 
# End of macro FORTH_DSP_VALUE
464e			 
464e			 
464e					if DEBUG_FORTH_WORDS 
464e						DMARK "CN?" 
464e f5				push af  
464f 3a 63 46			ld a, (.dmark)  
4652 32 6b ee			ld (debug_mark),a  
4655 3a 64 46			ld a, (.dmark+1)  
4658 32 6c ee			ld (debug_mark+1),a  
465b 3a 65 46			ld a, (.dmark+2)  
465e 32 6d ee			ld (debug_mark+2),a  
4661 18 03			jr .pastdmark  
4663 ..			.dmark: db "CN?"  
4666 f1			.pastdmark: pop af  
4667			endm  
# End of macro DMARK
4667						CALLMONITOR 
4667 cd 6f ee			call debug_vector  
466a				endm  
# End of macro CALLMONITOR
466a					endif 
466a cd 45 12				call strlenz 
466d					if DEBUG_FORTH_WORDS 
466d						DMARK "CNl" 
466d f5				push af  
466e 3a 82 46			ld a, (.dmark)  
4671 32 6b ee			ld (debug_mark),a  
4674 3a 83 46			ld a, (.dmark+1)  
4677 32 6c ee			ld (debug_mark+1),a  
467a 3a 84 46			ld a, (.dmark+2)  
467d 32 6d ee			ld (debug_mark+2),a  
4680 18 03			jr .pastdmark  
4682 ..			.dmark: db "CNl"  
4685 f1			.pastdmark: pop af  
4686			endm  
# End of macro DMARK
4686						CALLMONITOR 
4686 cd 6f ee			call debug_vector  
4689				endm  
# End of macro CALLMONITOR
4689					endif 
4689			 
4689 cd 56 1c				call forth_push_numhl 
468c			 
468c			 
468c			 
468c				       NEXTW 
468c c3 03 20			jp macro_next 
468f				endm 
# End of macro NEXTW
468f			.ASC: 
468f				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
468f 4d				db WORD_SYS_CORE+57             
4690 fd 46			dw .CHR            
4692 04				db 3 + 1 
4693 .. 00			db "ASC",0              
4697				endm 
# End of macro CWHEAD
4697			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4697					if DEBUG_FORTH_WORDS_KEY 
4697						DMARK "ASC" 
4697 f5				push af  
4698 3a ac 46			ld a, (.dmark)  
469b 32 6b ee			ld (debug_mark),a  
469e 3a ad 46			ld a, (.dmark+1)  
46a1 32 6c ee			ld (debug_mark+1),a  
46a4 3a ae 46			ld a, (.dmark+2)  
46a7 32 6d ee			ld (debug_mark+2),a  
46aa 18 03			jr .pastdmark  
46ac ..			.dmark: db "ASC"  
46af f1			.pastdmark: pop af  
46b0			endm  
# End of macro DMARK
46b0						CALLMONITOR 
46b0 cd 6f ee			call debug_vector  
46b3				endm  
# End of macro CALLMONITOR
46b3					endif 
46b3					FORTH_DSP_VALUE 
46b3 cd 36 1e			call macro_forth_dsp_value 
46b6				endm 
# End of macro FORTH_DSP_VALUE
46b6					;v5 FORTH_DSP_VALUE 
46b6			;		inc hl      ; now at start of numeric as string 
46b6			 
46b6 e5					push hl 
46b7			 
46b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46b7 cd 05 1f			call macro_forth_dsp_pop 
46ba				endm 
# End of macro FORTH_DSP_POP
46ba			 
46ba e1					pop hl 
46bb			 
46bb					if DEBUG_FORTH_WORDS 
46bb						DMARK "AS1" 
46bb f5				push af  
46bc 3a d0 46			ld a, (.dmark)  
46bf 32 6b ee			ld (debug_mark),a  
46c2 3a d1 46			ld a, (.dmark+1)  
46c5 32 6c ee			ld (debug_mark+1),a  
46c8 3a d2 46			ld a, (.dmark+2)  
46cb 32 6d ee			ld (debug_mark+2),a  
46ce 18 03			jr .pastdmark  
46d0 ..			.dmark: db "AS1"  
46d3 f1			.pastdmark: pop af  
46d4			endm  
# End of macro DMARK
46d4						CALLMONITOR 
46d4 cd 6f ee			call debug_vector  
46d7				endm  
# End of macro CALLMONITOR
46d7					endif 
46d7					; push the content of a onto the stack as a value 
46d7			 
46d7 7e					ld a,(hl)   ; get char 
46d8 26 00				ld h,0 
46da 6f					ld l,a 
46db					if DEBUG_FORTH_WORDS 
46db						DMARK "AS2" 
46db f5				push af  
46dc 3a f0 46			ld a, (.dmark)  
46df 32 6b ee			ld (debug_mark),a  
46e2 3a f1 46			ld a, (.dmark+1)  
46e5 32 6c ee			ld (debug_mark+1),a  
46e8 3a f2 46			ld a, (.dmark+2)  
46eb 32 6d ee			ld (debug_mark+2),a  
46ee 18 03			jr .pastdmark  
46f0 ..			.dmark: db "AS2"  
46f3 f1			.pastdmark: pop af  
46f4			endm  
# End of macro DMARK
46f4						CALLMONITOR 
46f4 cd 6f ee			call debug_vector  
46f7				endm  
# End of macro CALLMONITOR
46f7					endif 
46f7 cd 56 1c				call forth_push_numhl 
46fa			 
46fa				       NEXTW 
46fa c3 03 20			jp macro_next 
46fd				endm 
# End of macro NEXTW
46fd			 
46fd			.CHR: 
46fd				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
46fd 4d				db WORD_SYS_CORE+57             
46fe 39 47			dw .ENDSTR            
4700 04				db 3 + 1 
4701 .. 00			db "CHR",0              
4705				endm 
# End of macro CWHEAD
4705			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4705					if DEBUG_FORTH_WORDS_KEY 
4705						DMARK "CHR" 
4705 f5				push af  
4706 3a 1a 47			ld a, (.dmark)  
4709 32 6b ee			ld (debug_mark),a  
470c 3a 1b 47			ld a, (.dmark+1)  
470f 32 6c ee			ld (debug_mark+1),a  
4712 3a 1c 47			ld a, (.dmark+2)  
4715 32 6d ee			ld (debug_mark+2),a  
4718 18 03			jr .pastdmark  
471a ..			.dmark: db "CHR"  
471d f1			.pastdmark: pop af  
471e			endm  
# End of macro DMARK
471e						CALLMONITOR 
471e cd 6f ee			call debug_vector  
4721				endm  
# End of macro CALLMONITOR
4721					endif 
4721					FORTH_DSP_VALUEHL 
4721 cd 4d 1e			call macro_dsp_valuehl 
4724				endm 
# End of macro FORTH_DSP_VALUEHL
4724			 
4724					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4724 cd 05 1f			call macro_forth_dsp_pop 
4727				endm 
# End of macro FORTH_DSP_POP
4727			 
4727					; save asci byte as a zero term string and push string 
4727			 
4727 7d					ld a,l 
4728 32 c1 e2				ld (scratch), a 
472b			 
472b 3e 00				ld a, 0 
472d 32 c2 e2				ld (scratch+1), a 
4730			 
4730 21 c1 e2				ld hl, scratch 
4733 cd c4 1c				call forth_push_str 
4736			 
4736			 
4736				       NEXTW 
4736 c3 03 20			jp macro_next 
4739				endm 
# End of macro NEXTW
4739			 
4739			 
4739			 
4739			 
4739			.ENDSTR: 
4739			; eof 
4739			 
# End of file forth_words_str.asm
4739			include "forth_words_key.asm" 
4739			 
4739			; | ## Keyboard Words 
4739			 
4739			.KEY: 
4739				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4739 3e				db WORD_SYS_CORE+42             
473a 69 47			dw .WAITK            
473c 04				db 3 + 1 
473d .. 00			db "KEY",0              
4741				endm 
# End of macro CWHEAD
4741			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4741			 
4741					if DEBUG_FORTH_WORDS_KEY 
4741						DMARK "KEY" 
4741 f5				push af  
4742 3a 56 47			ld a, (.dmark)  
4745 32 6b ee			ld (debug_mark),a  
4748 3a 57 47			ld a, (.dmark+1)  
474b 32 6c ee			ld (debug_mark+1),a  
474e 3a 58 47			ld a, (.dmark+2)  
4751 32 6d ee			ld (debug_mark+2),a  
4754 18 03			jr .pastdmark  
4756 ..			.dmark: db "KEY"  
4759 f1			.pastdmark: pop af  
475a			endm  
# End of macro DMARK
475a						CALLMONITOR 
475a cd 6f ee			call debug_vector  
475d				endm  
# End of macro CALLMONITOR
475d					endif 
475d			; TODO currently waits 
475d cd 27 65				call cin 
4760					;call cin_wait 
4760 6f					ld l, a 
4761 26 00				ld h, 0 
4763 cd 56 1c				call forth_push_numhl 
4766					NEXTW 
4766 c3 03 20			jp macro_next 
4769				endm 
# End of macro NEXTW
4769			.WAITK: 
4769				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4769 3f				db WORD_SYS_CORE+43             
476a 9b 47			dw .ACCEPT            
476c 06				db 5 + 1 
476d .. 00			db "WAITK",0              
4773				endm 
# End of macro CWHEAD
4773			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4773					if DEBUG_FORTH_WORDS_KEY 
4773						DMARK "WAI" 
4773 f5				push af  
4774 3a 88 47			ld a, (.dmark)  
4777 32 6b ee			ld (debug_mark),a  
477a 3a 89 47			ld a, (.dmark+1)  
477d 32 6c ee			ld (debug_mark+1),a  
4780 3a 8a 47			ld a, (.dmark+2)  
4783 32 6d ee			ld (debug_mark+2),a  
4786 18 03			jr .pastdmark  
4788 ..			.dmark: db "WAI"  
478b f1			.pastdmark: pop af  
478c			endm  
# End of macro DMARK
478c						CALLMONITOR 
478c cd 6f ee			call debug_vector  
478f				endm  
# End of macro CALLMONITOR
478f					endif 
478f cd 1f 65				call cin_wait 
4792 6f					ld l, a 
4793 26 00				ld h, 0 
4795 cd 56 1c				call forth_push_numhl 
4798					NEXTW 
4798 c3 03 20			jp macro_next 
479b				endm 
# End of macro NEXTW
479b			.ACCEPT: 
479b				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
479b 40				db WORD_SYS_CORE+44             
479c f9 47			dw .EDIT            
479e 07				db 6 + 1 
479f .. 00			db "ACCEPT",0              
47a6				endm 
# End of macro CWHEAD
47a6			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47a6					; TODO crashes on push 
47a6					if DEBUG_FORTH_WORDS_KEY 
47a6						DMARK "ACC" 
47a6 f5				push af  
47a7 3a bb 47			ld a, (.dmark)  
47aa 32 6b ee			ld (debug_mark),a  
47ad 3a bc 47			ld a, (.dmark+1)  
47b0 32 6c ee			ld (debug_mark+1),a  
47b3 3a bd 47			ld a, (.dmark+2)  
47b6 32 6d ee			ld (debug_mark+2),a  
47b9 18 03			jr .pastdmark  
47bb ..			.dmark: db "ACC"  
47be f1			.pastdmark: pop af  
47bf			endm  
# End of macro DMARK
47bf						CALLMONITOR 
47bf cd 6f ee			call debug_vector  
47c2				endm  
# End of macro CALLMONITOR
47c2					endif 
47c2 21 bf e4				ld hl, os_input 
47c5 3e 00				ld a, 0 
47c7 77					ld (hl),a 
47c8 3a 5e ea				ld a,(f_cursor_ptr) 
47cb 16 64				ld d, 100 
47cd 0e 00				ld c, 0 
47cf 1e 28				ld e, 40 
47d1 cd 14 0e				call input_str 
47d4					; TODO perhaps do a type check and wrap in quotes if not a number 
47d4 21 bf e4				ld hl, os_input 
47d7					if DEBUG_FORTH_WORDS 
47d7						DMARK "AC1" 
47d7 f5				push af  
47d8 3a ec 47			ld a, (.dmark)  
47db 32 6b ee			ld (debug_mark),a  
47de 3a ed 47			ld a, (.dmark+1)  
47e1 32 6c ee			ld (debug_mark+1),a  
47e4 3a ee 47			ld a, (.dmark+2)  
47e7 32 6d ee			ld (debug_mark+2),a  
47ea 18 03			jr .pastdmark  
47ec ..			.dmark: db "AC1"  
47ef f1			.pastdmark: pop af  
47f0			endm  
# End of macro DMARK
47f0						CALLMONITOR 
47f0 cd 6f ee			call debug_vector  
47f3				endm  
# End of macro CALLMONITOR
47f3					endif 
47f3 cd c4 1c				call forth_push_str 
47f6					NEXTW 
47f6 c3 03 20			jp macro_next 
47f9				endm 
# End of macro NEXTW
47f9			 
47f9			.EDIT: 
47f9				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
47f9 40				db WORD_SYS_CORE+44             
47fa 9b 48			dw .DEDIT            
47fc 05				db 4 + 1 
47fd .. 00			db "EDIT",0              
4802				endm 
# End of macro CWHEAD
4802			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4802			 
4802					; TODO does not copy from stack 
4802					if DEBUG_FORTH_WORDS_KEY 
4802						DMARK "EDT" 
4802 f5				push af  
4803 3a 17 48			ld a, (.dmark)  
4806 32 6b ee			ld (debug_mark),a  
4809 3a 18 48			ld a, (.dmark+1)  
480c 32 6c ee			ld (debug_mark+1),a  
480f 3a 19 48			ld a, (.dmark+2)  
4812 32 6d ee			ld (debug_mark+2),a  
4815 18 03			jr .pastdmark  
4817 ..			.dmark: db "EDT"  
481a f1			.pastdmark: pop af  
481b			endm  
# End of macro DMARK
481b						CALLMONITOR 
481b cd 6f ee			call debug_vector  
481e				endm  
# End of macro CALLMONITOR
481e					endif 
481e			 
481e					;FORTH_DSP 
481e					FORTH_DSP_VALUEHL 
481e cd 4d 1e			call macro_dsp_valuehl 
4821				endm 
# End of macro FORTH_DSP_VALUEHL
4821			;		inc hl    ; TODO do type check 
4821			 
4821			;		call get_word_hl 
4821 e5					push hl 
4822					if DEBUG_FORTH_WORDS 
4822						DMARK "EDp" 
4822 f5				push af  
4823 3a 37 48			ld a, (.dmark)  
4826 32 6b ee			ld (debug_mark),a  
4829 3a 38 48			ld a, (.dmark+1)  
482c 32 6c ee			ld (debug_mark+1),a  
482f 3a 39 48			ld a, (.dmark+2)  
4832 32 6d ee			ld (debug_mark+2),a  
4835 18 03			jr .pastdmark  
4837 ..			.dmark: db "EDp"  
483a f1			.pastdmark: pop af  
483b			endm  
# End of macro DMARK
483b						CALLMONITOR 
483b cd 6f ee			call debug_vector  
483e				endm  
# End of macro CALLMONITOR
483e					endif 
483e				;	ld a, 0 
483e cd 45 12				call strlenz 
4841 23					inc hl 
4842			 
4842 06 00				ld b, 0 
4844 4d					ld c, l 
4845			 
4845 e1					pop hl 
4846 11 bf e4				ld de, os_input 
4849					if DEBUG_FORTH_WORDS_KEY 
4849						DMARK "EDc" 
4849 f5				push af  
484a 3a 5e 48			ld a, (.dmark)  
484d 32 6b ee			ld (debug_mark),a  
4850 3a 5f 48			ld a, (.dmark+1)  
4853 32 6c ee			ld (debug_mark+1),a  
4856 3a 60 48			ld a, (.dmark+2)  
4859 32 6d ee			ld (debug_mark+2),a  
485c 18 03			jr .pastdmark  
485e ..			.dmark: db "EDc"  
4861 f1			.pastdmark: pop af  
4862			endm  
# End of macro DMARK
4862						CALLMONITOR 
4862 cd 6f ee			call debug_vector  
4865				endm  
# End of macro CALLMONITOR
4865					endif 
4865 ed b0				ldir 
4867			 
4867			 
4867 21 bf e4				ld hl, os_input 
486a					;ld a, 0 
486a					;ld (hl),a 
486a 3a 5e ea				ld a,(f_cursor_ptr) 
486d 16 64				ld d, 100 
486f 0e 00				ld c, 0 
4871 1e 28				ld e, 40 
4873 cd 14 0e				call input_str 
4876					; TODO perhaps do a type check and wrap in quotes if not a number 
4876 21 bf e4				ld hl, os_input 
4879					if DEBUG_FORTH_WORDS 
4879						DMARK "ED1" 
4879 f5				push af  
487a 3a 8e 48			ld a, (.dmark)  
487d 32 6b ee			ld (debug_mark),a  
4880 3a 8f 48			ld a, (.dmark+1)  
4883 32 6c ee			ld (debug_mark+1),a  
4886 3a 90 48			ld a, (.dmark+2)  
4889 32 6d ee			ld (debug_mark+2),a  
488c 18 03			jr .pastdmark  
488e ..			.dmark: db "ED1"  
4891 f1			.pastdmark: pop af  
4892			endm  
# End of macro DMARK
4892						CALLMONITOR 
4892 cd 6f ee			call debug_vector  
4895				endm  
# End of macro CALLMONITOR
4895					endif 
4895 cd c4 1c				call forth_push_str 
4898					NEXTW 
4898 c3 03 20			jp macro_next 
489b				endm 
# End of macro NEXTW
489b			 
489b			.DEDIT: 
489b				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
489b 40				db WORD_SYS_CORE+44             
489c fd 48			dw .ENDKEY            
489e 06				db 5 + 1 
489f .. 00			db "DEDIT",0              
48a5				endm 
# End of macro CWHEAD
48a5			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
48a5			 
48a5					; TODO does not copy from stack 
48a5					if DEBUG_FORTH_WORDS_KEY 
48a5						DMARK "DED" 
48a5 f5				push af  
48a6 3a ba 48			ld a, (.dmark)  
48a9 32 6b ee			ld (debug_mark),a  
48ac 3a bb 48			ld a, (.dmark+1)  
48af 32 6c ee			ld (debug_mark+1),a  
48b2 3a bc 48			ld a, (.dmark+2)  
48b5 32 6d ee			ld (debug_mark+2),a  
48b8 18 03			jr .pastdmark  
48ba ..			.dmark: db "DED"  
48bd f1			.pastdmark: pop af  
48be			endm  
# End of macro DMARK
48be						CALLMONITOR 
48be cd 6f ee			call debug_vector  
48c1				endm  
# End of macro CALLMONITOR
48c1					endif 
48c1			 
48c1					;FORTH_DSP 
48c1					FORTH_DSP_VALUEHL 
48c1 cd 4d 1e			call macro_dsp_valuehl 
48c4				endm 
# End of macro FORTH_DSP_VALUEHL
48c4			;		inc hl    ; TODO do type check 
48c4			 
48c4			;		call get_word_hl 
48c4 e5					push hl 
48c5 e5					push hl 
48c6					FORTH_DSP_POP 
48c6 cd 05 1f			call macro_forth_dsp_pop 
48c9				endm 
# End of macro FORTH_DSP_POP
48c9 e1					pop hl 
48ca					if DEBUG_FORTH_WORDS 
48ca						DMARK "EDp" 
48ca f5				push af  
48cb 3a df 48			ld a, (.dmark)  
48ce 32 6b ee			ld (debug_mark),a  
48d1 3a e0 48			ld a, (.dmark+1)  
48d4 32 6c ee			ld (debug_mark+1),a  
48d7 3a e1 48			ld a, (.dmark+2)  
48da 32 6d ee			ld (debug_mark+2),a  
48dd 18 03			jr .pastdmark  
48df ..			.dmark: db "EDp"  
48e2 f1			.pastdmark: pop af  
48e3			endm  
# End of macro DMARK
48e3						CALLMONITOR 
48e3 cd 6f ee			call debug_vector  
48e6				endm  
# End of macro CALLMONITOR
48e6					endif 
48e6				;	ld a, 0 
48e6 cd 45 12				call strlenz 
48e9 23					inc hl 
48ea			 
48ea 06 00				ld b, 0 
48ec 4d					ld c, l 
48ed			 
48ed e1					pop hl 
48ee			 
48ee					;ld a, 0 
48ee					;ld (hl),a 
48ee 3a 5e ea				ld a,(f_cursor_ptr) 
48f1 16 64				ld d, 100 
48f3 0e 00				ld c, 0 
48f5 1e 28				ld e, 40 
48f7 cd 14 0e				call input_str 
48fa					; TODO perhaps do a type check and wrap in quotes if not a number 
48fa					NEXTW 
48fa c3 03 20			jp macro_next 
48fd				endm 
# End of macro NEXTW
48fd			 
48fd			 
48fd			.ENDKEY: 
48fd			; eof 
48fd			 
# End of file forth_words_key.asm
48fd			include "forth_words_const.asm" 
48fd			 
48fd			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
48fd			 
48fd			 
48fd			.SPITIME: 
48fd				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
48fd 77				db WORD_SYS_CORE+99             
48fe 12 49			dw .VA            
4900 08				db 7 + 1 
4901 .. 00			db "SPITIME",0              
4909				endm 
# End of macro CWHEAD
4909			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4909			; 
4909			; | If using BANK devices then leave as is. 
4909			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4909			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4909			 
4909 21 64 ea				ld hl, spi_clktime  
490c cd 56 1c				call forth_push_numhl 
490f			 
490f					NEXTW 
490f c3 03 20			jp macro_next 
4912				endm 
# End of macro NEXTW
4912			 
4912			 
4912			.VA: 
4912				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4912 77				db WORD_SYS_CORE+99             
4913 22 49			dw .SYMBOL            
4915 03				db 2 + 1 
4916 .. 00			db "VA",0              
4919				endm 
# End of macro CWHEAD
4919			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4919 21 28 ea				ld hl, cli_var_array 
491c cd 56 1c				call forth_push_numhl 
491f			 
491f					NEXTW 
491f c3 03 20			jp macro_next 
4922				endm 
# End of macro NEXTW
4922			 
4922			.SYMBOL: 
4922				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4922 77				db WORD_SYS_CORE+99             
4923 2c 4a			dw .ENDCONST            
4925 07				db 6 + 1 
4926 .. 00			db "SYMBOL",0              
492d				endm 
# End of macro CWHEAD
492d			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
492d			; | 
492d			; | The value is the number reference and the final address is pushed to stack 
492d			 
492d			; | dw sym_table 
492d			; | dw nmi_vector 
492d			; | dw cli_autodisplay 
492d			; | dw cli_data_sp 
492d			; | dw cli_data_stack 
492d			; | dw cli_loop_sp 
492d			; | dw cli_loop_stack 
492d			; | dw cli_var_array 
492d			; | dw cursor_col 
492d			; | dw cursor_ptr 
492d			; | ; 10 
492d			; | dw cursor_row 
492d			; | dw debug_mark 
492d			; | dw display_fb0 
492d			; | dw display_fb1 
492d			; | dw display_fb2 
492d			; | dw display_fb3 
492d			; | dw display_fb_active 
492d			; | dw execscratch 
492d			; | dw f_cursor_ptr 
492d			; | dw hardware_word 
492d			; | ;20 
492d			; | dw input_at_cursor 
492d			; | dw input_at_pos 
492d			; | dw input_cur_flash 
492d			; | dw input_cur_onoff 
492d			; | dw input_cursor 
492d			; | dw input_display_size 
492d			; | dw input_len 
492d			; | dw input_ptr 
492d			; | dw input_size 
492d			; | dw input_start 
492d			; | ; 30 
492d			; | dw input_str 
492d			; | dw input_under_cursor 
492d			; | dw os_cli_cmd 
492d			; | dw os_cur_ptr 
492d			; | dw os_current_i 
492d			; | dw os_input 
492d			; | dw os_last_cmd 
492d			; | dw os_last_new_uword 
492d			; | dw debug_vector 
492d			; | dw os_view_hl 
492d			; | ;40 
492d			; | dw os_word_scratch 
492d			; | dw portbctl 
492d			; | dw portbdata 
492d			; | dw spi_cartdev 
492d			; | dw spi_cartdev2 
492d			; | dw spi_clktime 
492d			; | dw spi_device 
492d			; | dw spi_device_id 
492d			; | dw spi_portbyte 
492d			; | dw stackstore 
492d			; | ; 50 
492d			; | if STORAGE_SE 
492d			; | dw storage_actl 
492d			; | dw storage_adata 
492d			; | else 
492d			; | dw 0 
492d			; | dw 0 
492d			; | endif 
492d			; | dw storage_append 
492d			; | if STORAGE_SE 
492d			; | dw storage_bctl 
492d			; | else 
492d			; | dw 0 
492d			; | endif 
492d			; | dw store_bank_active 
492d			; | dw store_filecache 
492d			; | dw store_longread 
492d			; | dw store_openaddr 
492d			; | dw store_openext 
492d			; | dw store_openmaxext 
492d			; | ; 60 
492d			; | dw store_page 
492d			; | dw store_readbuf 
492d			; | dw store_readcont 
492d			; | dw store_readptr 
492d			; | dw store_tmpext 
492d			; | dw store_tmpid 
492d			; | dw store_tmppageid 
492d			; | dw malloc 
492d			; | dw free 
492d			; | dw cin 
492d			; | ; 70 
492d			; | dw cin_wait 
492d			; | dw forth_push_numhl 
492d			; | dw forth_push_str 
492d			 
492d					if DEBUG_FORTH_WORDS_KEY 
492d						DMARK "SYM" 
492d f5				push af  
492e 3a 42 49			ld a, (.dmark)  
4931 32 6b ee			ld (debug_mark),a  
4934 3a 43 49			ld a, (.dmark+1)  
4937 32 6c ee			ld (debug_mark+1),a  
493a 3a 44 49			ld a, (.dmark+2)  
493d 32 6d ee			ld (debug_mark+2),a  
4940 18 03			jr .pastdmark  
4942 ..			.dmark: db "SYM"  
4945 f1			.pastdmark: pop af  
4946			endm  
# End of macro DMARK
4946						CALLMONITOR 
4946 cd 6f ee			call debug_vector  
4949				endm  
# End of macro CALLMONITOR
4949					endif 
4949			 
4949					FORTH_DSP_VALUEHL 
4949 cd 4d 1e			call macro_dsp_valuehl 
494c				endm 
# End of macro FORTH_DSP_VALUEHL
494c			 
494c 7d					ld a, l     
494d			 
494d			 
494d					if DEBUG_FORTH_WORDS 
494d						DMARK "SY1" 
494d f5				push af  
494e 3a 62 49			ld a, (.dmark)  
4951 32 6b ee			ld (debug_mark),a  
4954 3a 63 49			ld a, (.dmark+1)  
4957 32 6c ee			ld (debug_mark+1),a  
495a 3a 64 49			ld a, (.dmark+2)  
495d 32 6d ee			ld (debug_mark+2),a  
4960 18 03			jr .pastdmark  
4962 ..			.dmark: db "SY1"  
4965 f1			.pastdmark: pop af  
4966			endm  
# End of macro DMARK
4966						CALLMONITOR 
4966 cd 6f ee			call debug_vector  
4969				endm  
# End of macro CALLMONITOR
4969					endif 
4969					 
4969 f5					push af	 
496a					FORTH_DSP_POP 
496a cd 05 1f			call macro_forth_dsp_pop 
496d				endm 
# End of macro FORTH_DSP_POP
496d f1					pop af 
496e			 
496e cb 27				sla a  
4970				 
4970					 
4970					if DEBUG_FORTH_WORDS 
4970						DMARK "SY" 
4970 f5				push af  
4971 3a 85 49			ld a, (.dmark)  
4974 32 6b ee			ld (debug_mark),a  
4977 3a 86 49			ld a, (.dmark+1)  
497a 32 6c ee			ld (debug_mark+1),a  
497d 3a 87 49			ld a, (.dmark+2)  
4980 32 6d ee			ld (debug_mark+2),a  
4983 18 02			jr .pastdmark  
4985 ..			.dmark: db "SY"  
4987 f1			.pastdmark: pop af  
4988			endm  
# End of macro DMARK
4988						CALLMONITOR 
4988 cd 6f ee			call debug_vector  
498b				endm  
# End of macro CALLMONITOR
498b					endif 
498b			 
498b 21 9a 49				ld hl, sym_table 
498e cd e7 0d				call addatohl 
4991 cd 85 1f				call loadwordinhl 
4994 cd 56 1c				call forth_push_numhl 
4997			 
4997			 
4997				       NEXTW 
4997 c3 03 20			jp macro_next 
499a				endm 
# End of macro NEXTW
499a			 
499a			sym_table: 
499a			 
499a			; 0 
499a 9a 49		dw sym_table 
499c 72 ee		dw nmi_vector 
499e 3c ea		dw cli_autodisplay 
49a0 ee e9		dw cli_data_sp 
49a2 28 e8		dw cli_data_stack 
49a4 f0 e9		dw cli_loop_sp 
49a6 2a e9		dw cli_loop_stack 
49a8 28 ea		dw cli_var_array 
49aa c5 eb		dw cursor_col 
49ac c3 eb		dw cursor_ptr 
49ae			; 10 
49ae c4 eb		dw cursor_row 
49b0 6b ee		dw debug_mark 
49b2 b1 ed		dw display_fb0 
49b4 10 ed		dw display_fb1 
49b6 ce eb		dw display_fb2 
49b8 6f ec		dw display_fb3 
49ba cc eb		dw display_fb_active 
49bc c0 e3		dw execscratch 
49be 5e ea		dw f_cursor_ptr 
49c0 75 ee		dw hardware_word 
49c2			;20 
49c2 62 ee		dw input_at_cursor 
49c4 64 ee		dw input_at_pos 
49c6 60 ee		dw input_cur_flash 
49c8 5f ee		dw input_cur_onoff 
49ca 55 ee		dw input_cursor 
49cc 65 ee		dw input_display_size 
49ce 5a ee		dw input_len 
49d0 69 ee		dw input_ptr 
49d2 66 ee		dw input_size 
49d4 67 ee		dw input_start 
49d6			; 30 
49d6 14 0e		dw input_str 
49d8 63 ee		dw input_under_cursor 
49da e8 e5		dw os_cli_cmd 
49dc e4 e5		dw os_cur_ptr 
49de e6 e5		dw os_current_i 
49e0 bf e4		dw os_input 
49e2 e7 e6		dw os_last_cmd 
49e4 be e5		dw os_last_new_uword 
49e6 6f ee		dw debug_vector 
49e8 af e2		dw os_view_hl 
49ea			;40 
49ea c6 e5		dw os_word_scratch 
49ec c3 00		dw portbctl 
49ee c1 00		dw portbdata 
49f0 63 ea		dw spi_cartdev 
49f2 62 ea		dw spi_cartdev2 
49f4 64 ea		dw spi_clktime 
49f6 60 ea		dw spi_device 
49f8 5f ea		dw spi_device_id 
49fa 61 ea		dw spi_portbyte 
49fc a7 eb		dw stackstore 
49fe			; 50 
49fe			if STORAGE_SE 
49fe			dw storage_actl 
49fe			dw storage_adata 
49fe			else 
49fe 00 00		dw 0 
4a00 00 00		dw 0 
4a02			endif 
4a02 69 09		dw storage_append 
4a04			if STORAGE_SE 
4a04			dw storage_bctl 
4a04			else 
4a04 00 00		dw 0 
4a06			endif 
4a06 93 eb		dw store_bank_active 
4a08 67 ea		dw store_filecache 
4a0a 75 ea		dw store_longread 
4a0c 6b ea		dw store_openaddr 
4a0e 6a ea		dw store_openext 
4a10 69 ea		dw store_openmaxext 
4a12			; 60 
4a12 7a ea		dw store_page 
4a14 76 ea		dw store_readbuf 
4a16 6d ea		dw store_readcont 
4a18 78 ea		dw store_readptr 
4a1a 6d ea		dw store_tmpext 
4a1c 6e ea		dw store_tmpid 
4a1e 65 ea		dw store_tmppageid 
4a20 ae 12		dw malloc 
4a22 78 13		dw free 
4a24 27 65		dw cin 
4a26			; 70 
4a26 1f 65		dw cin_wait 
4a28 56 1c		dw forth_push_numhl 
4a2a c4 1c		dw forth_push_str 
4a2c			 
4a2c			 
4a2c			.ENDCONST: 
4a2c			 
4a2c			; eof 
4a2c			 
4a2c			 
# End of file forth_words_const.asm
4a2c			 
4a2c			if STORAGE_SE 
4a2c			   	include "forth_words_storage.asm" 
4a2c			endif 
4a2c				include "forth_words_device.asm" 
4a2c			; Device related words 
4a2c			 
4a2c			; | ## Device Words 
4a2c			 
4a2c			;if SOUND_ENABLE 
4a2c			;.NOTE: 
4a2c			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a2c			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4a2c			;		if DEBUG_FORTH_WORDS_KEY 
4a2c			;			DMARK "NTE" 
4a2c			;			CALLMONITOR 
4a2c			;		endif 
4a2c			; 
4a2c			;	 
4a2c			; 
4a2c			;		NEXTW 
4a2c			;.AFTERSOUND: 
4a2c			;endif 
4a2c			 
4a2c			 
4a2c			USE_GPIO: equ 0 
4a2c			 
4a2c			if USE_GPIO 
4a2c			.GP1: 
4a2c				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a2c			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4a2c					NEXTW 
4a2c			.GP2: 
4a2c				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a2c			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4a2c			 
4a2c					NEXTW 
4a2c			 
4a2c			.GP3: 
4a2c				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a2c			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4a2c			 
4a2c					NEXTW 
4a2c			 
4a2c			.GP4: 
4a2c				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a2c			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4a2c			 
4a2c					NEXTW 
4a2c			.SIN: 
4a2c			 
4a2c			 
4a2c			endif 
4a2c			 
4a2c			 
4a2c				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a2c 33				db WORD_SYS_CORE+31             
4a2d 61 4a			dw .SOUT            
4a2f 03				db 2 + 1 
4a30 .. 00			db "IN",0              
4a33				endm 
# End of macro CWHEAD
4a33			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a33					if DEBUG_FORTH_WORDS_KEY 
4a33						DMARK "IN." 
4a33 f5				push af  
4a34 3a 48 4a			ld a, (.dmark)  
4a37 32 6b ee			ld (debug_mark),a  
4a3a 3a 49 4a			ld a, (.dmark+1)  
4a3d 32 6c ee			ld (debug_mark+1),a  
4a40 3a 4a 4a			ld a, (.dmark+2)  
4a43 32 6d ee			ld (debug_mark+2),a  
4a46 18 03			jr .pastdmark  
4a48 ..			.dmark: db "IN."  
4a4b f1			.pastdmark: pop af  
4a4c			endm  
# End of macro DMARK
4a4c						CALLMONITOR 
4a4c cd 6f ee			call debug_vector  
4a4f				endm  
# End of macro CALLMONITOR
4a4f					endif 
4a4f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a4f cd 4d 1e			call macro_dsp_valuehl 
4a52				endm 
# End of macro FORTH_DSP_VALUEHL
4a52			 
4a52 e5					push hl 
4a53			 
4a53					; destroy value TOS 
4a53			 
4a53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a53 cd 05 1f			call macro_forth_dsp_pop 
4a56				endm 
# End of macro FORTH_DSP_POP
4a56			 
4a56					; one value on hl get other one back 
4a56			 
4a56 c1					pop bc 
4a57			 
4a57					; do the sub 
4a57			;		ex de, hl 
4a57			 
4a57 ed 68				in l,(c) 
4a59			 
4a59					; save it 
4a59			 
4a59 26 00				ld h,0 
4a5b			 
4a5b					; TODO push value back onto stack for another op etc 
4a5b			 
4a5b cd 56 1c				call forth_push_numhl 
4a5e					NEXTW 
4a5e c3 03 20			jp macro_next 
4a61				endm 
# End of macro NEXTW
4a61			.SOUT: 
4a61				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4a61 34				db WORD_SYS_CORE+32             
4a62 b4 4a			dw .SPIO            
4a64 04				db 3 + 1 
4a65 .. 00			db "OUT",0              
4a69				endm 
# End of macro CWHEAD
4a69			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4a69					if DEBUG_FORTH_WORDS_KEY 
4a69						DMARK "OUT" 
4a69 f5				push af  
4a6a 3a 7e 4a			ld a, (.dmark)  
4a6d 32 6b ee			ld (debug_mark),a  
4a70 3a 7f 4a			ld a, (.dmark+1)  
4a73 32 6c ee			ld (debug_mark+1),a  
4a76 3a 80 4a			ld a, (.dmark+2)  
4a79 32 6d ee			ld (debug_mark+2),a  
4a7c 18 03			jr .pastdmark  
4a7e ..			.dmark: db "OUT"  
4a81 f1			.pastdmark: pop af  
4a82			endm  
# End of macro DMARK
4a82						CALLMONITOR 
4a82 cd 6f ee			call debug_vector  
4a85				endm  
# End of macro CALLMONITOR
4a85					endif 
4a85			 
4a85					; get port 
4a85			 
4a85					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a85 cd 4d 1e			call macro_dsp_valuehl 
4a88				endm 
# End of macro FORTH_DSP_VALUEHL
4a88			 
4a88 e5					push hl 
4a89			 
4a89					; destroy value TOS 
4a89			 
4a89					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a89 cd 05 1f			call macro_forth_dsp_pop 
4a8c				endm 
# End of macro FORTH_DSP_POP
4a8c			 
4a8c					; get byte to send 
4a8c			 
4a8c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a8c cd 4d 1e			call macro_dsp_valuehl 
4a8f				endm 
# End of macro FORTH_DSP_VALUEHL
4a8f			 
4a8f			;		push hl 
4a8f			 
4a8f					; destroy value TOS 
4a8f			 
4a8f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a8f cd 05 1f			call macro_forth_dsp_pop 
4a92				endm 
# End of macro FORTH_DSP_POP
4a92			 
4a92					; one value on hl get other one back 
4a92			 
4a92			;		pop hl 
4a92			 
4a92 c1					pop bc 
4a93			 
4a93					if DEBUG_FORTH_WORDS 
4a93						DMARK "OUT" 
4a93 f5				push af  
4a94 3a a8 4a			ld a, (.dmark)  
4a97 32 6b ee			ld (debug_mark),a  
4a9a 3a a9 4a			ld a, (.dmark+1)  
4a9d 32 6c ee			ld (debug_mark+1),a  
4aa0 3a aa 4a			ld a, (.dmark+2)  
4aa3 32 6d ee			ld (debug_mark+2),a  
4aa6 18 03			jr .pastdmark  
4aa8 ..			.dmark: db "OUT"  
4aab f1			.pastdmark: pop af  
4aac			endm  
# End of macro DMARK
4aac						CALLMONITOR 
4aac cd 6f ee			call debug_vector  
4aaf				endm  
# End of macro CALLMONITOR
4aaf					endif 
4aaf			 
4aaf ed 69				out (c), l 
4ab1			 
4ab1					NEXTW 
4ab1 c3 03 20			jp macro_next 
4ab4				endm 
# End of macro NEXTW
4ab4			 
4ab4			 
4ab4			.SPIO: 
4ab4			 
4ab4			if STORAGE_SE 
4ab4				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4ab4			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4ab4			 
4ab4					call spi_ce_low 
4ab4			    NEXTW 
4ab4			 
4ab4			.SPICEH: 
4ab4				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ab4			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4ab4			 
4ab4					call spi_ce_high 
4ab4			    NEXTW 
4ab4			 
4ab4			 
4ab4			.SPIOb: 
4ab4			 
4ab4				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4ab4			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4ab4			 
4ab4					if DEBUG_FORTH_WORDS_KEY 
4ab4						DMARK "SPo" 
4ab4						CALLMONITOR 
4ab4					endif 
4ab4					; get port 
4ab4			 
4ab4			 
4ab4					; get byte to send 
4ab4			 
4ab4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ab4			 
4ab4			;		push hl    ; u1  
4ab4			 
4ab4					; destroy value TOS 
4ab4			 
4ab4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ab4			 
4ab4					; one value on hl get other one back 
4ab4			 
4ab4			;		pop hl   ; u2 - addr 
4ab4			 
4ab4					; TODO Send SPI byte 
4ab4			 
4ab4			;		push hl 
4ab4			;		call spi_ce_low 
4ab4			;		pop hl 
4ab4					ld a, l 
4ab4					call spi_send_byte 
4ab4			;		call spi_ce_high 
4ab4			 
4ab4					NEXTW 
4ab4			 
4ab4			.SPII: 
4ab4				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4ab4			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4ab4					if DEBUG_FORTH_WORDS_KEY 
4ab4						DMARK "SPi" 
4ab4						CALLMONITOR 
4ab4					endif 
4ab4			 
4ab4					; TODO Get SPI byte 
4ab4			 
4ab4					call spi_read_byte 
4ab4			 
4ab4					if DEBUG_FORTH_WORDS 
4ab4						DMARK "Si2" 
4ab4						CALLMONITOR 
4ab4					endif 
4ab4					ld h, 0 
4ab4					ld l, a 
4ab4					if DEBUG_FORTH_WORDS 
4ab4						DMARK "Si3" 
4ab4						CALLMONITOR 
4ab4					endif 
4ab4					call forth_push_numhl 
4ab4			 
4ab4					NEXTW 
4ab4			 
4ab4			 
4ab4			 
4ab4			.SESEL: 
4ab4				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4ab4			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4ab4					if DEBUG_FORTH_WORDS_KEY 
4ab4						DMARK "BNK" 
4ab4						CALLMONITOR 
4ab4					endif 
4ab4			 
4ab4					ld a, 255 
4ab4					ld (spi_cartdev), a 
4ab4			 
4ab4					; get bank 
4ab4			 
4ab4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ab4			 
4ab4			;		push hl 
4ab4			 
4ab4					; destroy value TOS 
4ab4			 
4ab4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ab4			 
4ab4					; one value on hl get other one back 
4ab4			 
4ab4			;		pop hl 
4ab4			 
4ab4			 
4ab4					ld c, SPI_CE_HIGH 
4ab4					ld b, '0'    ; human readable bank number 
4ab4			 
4ab4					ld a, l 
4ab4			 
4ab4					if DEBUG_FORTH_WORDS 
4ab4						DMARK "BNK" 
4ab4						CALLMONITOR 
4ab4					endif 
4ab4			 
4ab4					; active low 
4ab4			 
4ab4					cp 0 
4ab4					jr z, .bset 
4ab4					cp 1 
4ab4					jr nz, .b2 
4ab4					res 0, c 
4ab4					ld b, '1'    ; human readable bank number 
4ab4			.b2:		cp 2 
4ab4					jr nz, .b3 
4ab4					res 1, c 
4ab4					ld b, '2'    ; human readable bank number 
4ab4			.b3:		cp 3 
4ab4					jr nz, .b4 
4ab4					res 2, c 
4ab4					ld b, '3'    ; human readable bank number 
4ab4			.b4:		cp 4 
4ab4					jr nz, .b5 
4ab4					res 3, c 
4ab4					ld b, '4'    ; human readable bank number 
4ab4			.b5:		cp 5 
4ab4					jr nz, .bset 
4ab4					res 4, c 
4ab4					ld b, '5'    ; human readable bank number 
4ab4			 
4ab4			.bset: 
4ab4					ld a, c 
4ab4					ld (spi_device),a 
4ab4					ld a, b 
4ab4					ld (spi_device_id),a 
4ab4					if DEBUG_FORTH_WORDS 
4ab4						DMARK "BN2" 
4ab4						CALLMONITOR 
4ab4					endif 
4ab4			 
4ab4					; set default SPI clk pulse time as disabled for BANK use 
4ab4			 
4ab4					ld a, 0 
4ab4					ld (spi_clktime), a 
4ab4			 
4ab4					NEXTW 
4ab4			 
4ab4			.CARTDEV: 
4ab4				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4ab4			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4ab4					if DEBUG_FORTH_WORDS_KEY 
4ab4						DMARK "CDV" 
4ab4						CALLMONITOR 
4ab4					endif 
4ab4			 
4ab4					; disable se storage bank selection 
4ab4			 
4ab4					ld a, SPI_CE_HIGH		; ce high 
4ab4					ld (spi_device), a 
4ab4			 
4ab4					; get bank 
4ab4			 
4ab4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ab4			 
4ab4			;		push hl 
4ab4			 
4ab4					; destroy value TOS 
4ab4			 
4ab4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ab4			 
4ab4					; one value on hl get other one back 
4ab4			 
4ab4			;		pop hl 
4ab4			 
4ab4					; active low 
4ab4			 
4ab4					ld c, 255 
4ab4			 
4ab4					ld a, l 
4ab4					if DEBUG_FORTH_WORDS 
4ab4						DMARK "CDV" 
4ab4						CALLMONITOR 
4ab4					endif 
4ab4					cp 0 
4ab4					jr z, .cset 
4ab4					cp 1 
4ab4					jr nz, .c2 
4ab4					res 0, c 
4ab4			.c2:		cp 2 
4ab4					jr nz, .c3 
4ab4					res 1, c 
4ab4			.c3:		cp 3 
4ab4					jr nz, .c4 
4ab4					res 2, c 
4ab4			.c4:		cp 4 
4ab4					jr nz, .c5 
4ab4					res 3, c 
4ab4			.c5:		cp 5 
4ab4					jr nz, .c6 
4ab4					res 4, c 
4ab4			.c6:		cp 6 
4ab4					jr nz, .c7 
4ab4					res 5, c 
4ab4			.c7:		cp 7 
4ab4					jr nz, .c8 
4ab4					res 6, c 
4ab4			.c8:		cp 8 
4ab4					jr nz, .cset 
4ab4					res 7, c 
4ab4			.cset:		ld a, c 
4ab4					ld (spi_cartdev),a 
4ab4			 
4ab4					if DEBUG_FORTH_WORDS 
4ab4						DMARK "CD2" 
4ab4						CALLMONITOR 
4ab4					endif 
4ab4			 
4ab4					; set default SPI clk pulse time as 10ms for CARTDEV use 
4ab4			 
4ab4					ld a, $0a 
4ab4					ld (spi_clktime), a 
4ab4					NEXTW 
4ab4			endif 
4ab4			 
4ab4			.ENDDEVICE: 
4ab4			; eof 
4ab4			 
# End of file forth_words_device.asm
4ab4			 
4ab4			; var handler 
4ab4			 
4ab4			 
4ab4			.VARS: 
4ab4				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4ab4 77				db WORD_SYS_CORE+99             
4ab5 65 4b			dw .V0            
4ab7 04				db 3 + 1 
4ab8 .. 00			db "VAR",0              
4abc				endm 
# End of macro CWHEAD
4abc			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4abc			;| 
4abc			;| The variable name should consist of a single letter. e.g. "a" 
4abc			;! If a full string is passed then only the first char is looked at 
4abc			;| Any other char could exceed bounds checks!  
4abc			 
4abc					if DEBUG_FORTH_WORDS_KEY 
4abc						DMARK "VAR" 
4abc f5				push af  
4abd 3a d1 4a			ld a, (.dmark)  
4ac0 32 6b ee			ld (debug_mark),a  
4ac3 3a d2 4a			ld a, (.dmark+1)  
4ac6 32 6c ee			ld (debug_mark+1),a  
4ac9 3a d3 4a			ld a, (.dmark+2)  
4acc 32 6d ee			ld (debug_mark+2),a  
4acf 18 03			jr .pastdmark  
4ad1 ..			.dmark: db "VAR"  
4ad4 f1			.pastdmark: pop af  
4ad5			endm  
# End of macro DMARK
4ad5						CALLMONITOR 
4ad5 cd 6f ee			call debug_vector  
4ad8				endm  
# End of macro CALLMONITOR
4ad8					endif 
4ad8			 
4ad8					FORTH_DSP_VALUEHL 
4ad8 cd 4d 1e			call macro_dsp_valuehl 
4adb				endm 
# End of macro FORTH_DSP_VALUEHL
4adb			 
4adb 7e					ld a, (hl)    ; get first char on of the string 
4adc			 
4adc			 
4adc					if DEBUG_FORTH_WORDS 
4adc						DMARK "VR1" 
4adc f5				push af  
4add 3a f1 4a			ld a, (.dmark)  
4ae0 32 6b ee			ld (debug_mark),a  
4ae3 3a f2 4a			ld a, (.dmark+1)  
4ae6 32 6c ee			ld (debug_mark+1),a  
4ae9 3a f3 4a			ld a, (.dmark+2)  
4aec 32 6d ee			ld (debug_mark+2),a  
4aef 18 03			jr .pastdmark  
4af1 ..			.dmark: db "VR1"  
4af4 f1			.pastdmark: pop af  
4af5			endm  
# End of macro DMARK
4af5						CALLMONITOR 
4af5 cd 6f ee			call debug_vector  
4af8				endm  
# End of macro CALLMONITOR
4af8					endif 
4af8					 
4af8 f5					push af	 
4af9					FORTH_DSP_POP 
4af9 cd 05 1f			call macro_forth_dsp_pop 
4afc				endm 
# End of macro FORTH_DSP_POP
4afc f1					pop af 
4afd			 
4afd					; convert to upper 
4afd			 
4afd cd 54 11				call to_upper 
4b00					if DEBUG_FORTH_WORDS 
4b00						DMARK "Vaa" 
4b00 f5				push af  
4b01 3a 15 4b			ld a, (.dmark)  
4b04 32 6b ee			ld (debug_mark),a  
4b07 3a 16 4b			ld a, (.dmark+1)  
4b0a 32 6c ee			ld (debug_mark+1),a  
4b0d 3a 17 4b			ld a, (.dmark+2)  
4b10 32 6d ee			ld (debug_mark+2),a  
4b13 18 03			jr .pastdmark  
4b15 ..			.dmark: db "Vaa"  
4b18 f1			.pastdmark: pop af  
4b19			endm  
# End of macro DMARK
4b19						CALLMONITOR 
4b19 cd 6f ee			call debug_vector  
4b1c				endm  
# End of macro CALLMONITOR
4b1c					endif 
4b1c 06 41				ld b, 'A' 
4b1e 90					sub b			; set offset 
4b1f					if DEBUG_FORTH_WORDS 
4b1f						DMARK "Vbb" 
4b1f f5				push af  
4b20 3a 34 4b			ld a, (.dmark)  
4b23 32 6b ee			ld (debug_mark),a  
4b26 3a 35 4b			ld a, (.dmark+1)  
4b29 32 6c ee			ld (debug_mark+1),a  
4b2c 3a 36 4b			ld a, (.dmark+2)  
4b2f 32 6d ee			ld (debug_mark+2),a  
4b32 18 03			jr .pastdmark  
4b34 ..			.dmark: db "Vbb"  
4b37 f1			.pastdmark: pop af  
4b38			endm  
# End of macro DMARK
4b38						CALLMONITOR 
4b38 cd 6f ee			call debug_vector  
4b3b				endm  
# End of macro CALLMONITOR
4b3b					endif 
4b3b cb 27				sla a  
4b3d				 
4b3d					 
4b3d					if DEBUG_FORTH_WORDS 
4b3d						DMARK "VR2" 
4b3d f5				push af  
4b3e 3a 52 4b			ld a, (.dmark)  
4b41 32 6b ee			ld (debug_mark),a  
4b44 3a 53 4b			ld a, (.dmark+1)  
4b47 32 6c ee			ld (debug_mark+1),a  
4b4a 3a 54 4b			ld a, (.dmark+2)  
4b4d 32 6d ee			ld (debug_mark+2),a  
4b50 18 03			jr .pastdmark  
4b52 ..			.dmark: db "VR2"  
4b55 f1			.pastdmark: pop af  
4b56			endm  
# End of macro DMARK
4b56						CALLMONITOR 
4b56 cd 6f ee			call debug_vector  
4b59				endm  
# End of macro CALLMONITOR
4b59					endif 
4b59			 
4b59 21 f4 e9				ld hl, cli_var_array2 
4b5c cd e7 0d				call addatohl 
4b5f cd 56 1c				call forth_push_numhl 
4b62			 
4b62			 
4b62				       NEXTW 
4b62 c3 03 20			jp macro_next 
4b65				endm 
# End of macro NEXTW
4b65			.V0: 
4b65				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4b65 78				db WORD_SYS_CORE+100             
4b66 7d 4b			dw .V0Q            
4b68 04				db 3 + 1 
4b69 .. 00			db "V0!",0              
4b6d				endm 
# End of macro CWHEAD
4b6d			;| V0! ( u1 -- )  Store value to v0  | DONE 
4b6d			 
4b6d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b6d cd 4d 1e			call macro_dsp_valuehl 
4b70				endm 
# End of macro FORTH_DSP_VALUEHL
4b70			 
4b70 11 28 ea				ld de, cli_var_array 
4b73			 
4b73 eb					ex de, hl 
4b74 73					ld (hl), e 
4b75 23					inc hl 
4b76 72					ld (hl), d 
4b77			 
4b77					; destroy value TOS 
4b77			 
4b77					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b77 cd 05 1f			call macro_forth_dsp_pop 
4b7a				endm 
# End of macro FORTH_DSP_POP
4b7a			 
4b7a				       NEXTW 
4b7a c3 03 20			jp macro_next 
4b7d				endm 
# End of macro NEXTW
4b7d			.V0Q: 
4b7d				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4b7d 79				db WORD_SYS_CORE+101             
4b7e 8e 4b			dw .V1S            
4b80 04				db 3 + 1 
4b81 .. 00			db "V0@",0              
4b85				endm 
# End of macro CWHEAD
4b85			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4b85 2a 28 ea				ld hl, (cli_var_array) 
4b88 cd 56 1c				call forth_push_numhl 
4b8b			 
4b8b				       NEXTW 
4b8b c3 03 20			jp macro_next 
4b8e				endm 
# End of macro NEXTW
4b8e			.V1S: 
4b8e				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4b8e 7a				db WORD_SYS_CORE+102             
4b8f a6 4b			dw .V1Q            
4b91 04				db 3 + 1 
4b92 .. 00			db "V1!",0              
4b96				endm 
# End of macro CWHEAD
4b96			;| V1! ( u1 -- )  Store value to v1 | DONE 
4b96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b96 cd 4d 1e			call macro_dsp_valuehl 
4b99				endm 
# End of macro FORTH_DSP_VALUEHL
4b99			 
4b99 11 2a ea				ld de, cli_var_array+2 
4b9c				 
4b9c eb					ex de, hl 
4b9d 73					ld (hl), e 
4b9e 23					inc hl 
4b9f 72					ld (hl), d 
4ba0			 
4ba0					; destroy value TOS 
4ba0			 
4ba0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ba0 cd 05 1f			call macro_forth_dsp_pop 
4ba3				endm 
# End of macro FORTH_DSP_POP
4ba3				       NEXTW 
4ba3 c3 03 20			jp macro_next 
4ba6				endm 
# End of macro NEXTW
4ba6			.V1Q: 
4ba6				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4ba6 7b				db WORD_SYS_CORE+103             
4ba7 b7 4b			dw .V2S            
4ba9 04				db 3 + 1 
4baa .. 00			db "V1@",0              
4bae				endm 
# End of macro CWHEAD
4bae			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4bae 2a 2a ea				ld hl, (cli_var_array+2) 
4bb1 cd 56 1c				call forth_push_numhl 
4bb4				       NEXTW 
4bb4 c3 03 20			jp macro_next 
4bb7				endm 
# End of macro NEXTW
4bb7			.V2S: 
4bb7				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4bb7 7c				db WORD_SYS_CORE+104             
4bb8 cf 4b			dw .V2Q            
4bba 04				db 3 + 1 
4bbb .. 00			db "V2!",0              
4bbf				endm 
# End of macro CWHEAD
4bbf			;| V2! ( u1 -- )  Store value to v2 | DONE 
4bbf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bbf cd 4d 1e			call macro_dsp_valuehl 
4bc2				endm 
# End of macro FORTH_DSP_VALUEHL
4bc2			 
4bc2 11 2c ea				ld de, cli_var_array+4 
4bc5				 
4bc5 eb					ex de, hl 
4bc6 73					ld (hl), e 
4bc7 23					inc hl 
4bc8 72					ld (hl), d 
4bc9			 
4bc9					; destroy value TOS 
4bc9			 
4bc9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bc9 cd 05 1f			call macro_forth_dsp_pop 
4bcc				endm 
# End of macro FORTH_DSP_POP
4bcc				       NEXTW 
4bcc c3 03 20			jp macro_next 
4bcf				endm 
# End of macro NEXTW
4bcf			.V2Q: 
4bcf				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4bcf 7d				db WORD_SYS_CORE+105             
4bd0 e0 4b			dw .V3S            
4bd2 04				db 3 + 1 
4bd3 .. 00			db "V2@",0              
4bd7				endm 
# End of macro CWHEAD
4bd7			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4bd7 2a 2c ea				ld hl, (cli_var_array+4) 
4bda cd 56 1c				call forth_push_numhl 
4bdd				       NEXTW 
4bdd c3 03 20			jp macro_next 
4be0				endm 
# End of macro NEXTW
4be0			.V3S: 
4be0				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4be0 7c				db WORD_SYS_CORE+104             
4be1 f8 4b			dw .V3Q            
4be3 04				db 3 + 1 
4be4 .. 00			db "V3!",0              
4be8				endm 
# End of macro CWHEAD
4be8			;| V3! ( u1 -- )  Store value to v3 | DONE 
4be8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4be8 cd 4d 1e			call macro_dsp_valuehl 
4beb				endm 
# End of macro FORTH_DSP_VALUEHL
4beb			 
4beb 11 2e ea				ld de, cli_var_array+6 
4bee				 
4bee eb					ex de, hl 
4bef 73					ld (hl), e 
4bf0 23					inc hl 
4bf1 72					ld (hl), d 
4bf2			 
4bf2					; destroy value TOS 
4bf2			 
4bf2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bf2 cd 05 1f			call macro_forth_dsp_pop 
4bf5				endm 
# End of macro FORTH_DSP_POP
4bf5				       NEXTW 
4bf5 c3 03 20			jp macro_next 
4bf8				endm 
# End of macro NEXTW
4bf8			.V3Q: 
4bf8				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4bf8 7d				db WORD_SYS_CORE+105             
4bf9 09 4c			dw .END            
4bfb 04				db 3 + 1 
4bfc .. 00			db "V3@",0              
4c00				endm 
# End of macro CWHEAD
4c00			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c00 2a 2e ea				ld hl, (cli_var_array+6) 
4c03 cd 56 1c				call forth_push_numhl 
4c06				       NEXTW 
4c06 c3 03 20			jp macro_next 
4c09				endm 
# End of macro NEXTW
4c09			 
4c09			 
4c09			 
4c09			 
4c09			 
4c09			; end of dict marker 
4c09			 
4c09 00			.END:    db WORD_SYS_END 
4c0a 00 00			dw 0 
4c0c 00				db 0 
4c0d			 
4c0d			; use to jp here for user dict words to save on macro expansion  
4c0d			 
4c0d			user_dict_next: 
4c0d				NEXTW 
4c0d c3 03 20			jp macro_next 
4c10				endm 
# End of macro NEXTW
4c10			 
4c10			 
4c10			user_exec: 
4c10				;    ld hl, <word code> 
4c10				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c10				;    call forthexec 
4c10				;    jp user_dict_next   (NEXT) 
4c10			        ;    <word code bytes> 
4c10 eb				ex de, hl 
4c11 2a c2 e5			ld hl,(os_tok_ptr) 
4c14				 
4c14				FORTH_RSP_NEXT 
4c14 cd fd 1b			call macro_forth_rsp_next 
4c17				endm 
# End of macro FORTH_RSP_NEXT
4c17			 
4c17			if DEBUG_FORTH_UWORD 
4c17						DMARK "UEX" 
4c17 f5				push af  
4c18 3a 2c 4c			ld a, (.dmark)  
4c1b 32 6b ee			ld (debug_mark),a  
4c1e 3a 2d 4c			ld a, (.dmark+1)  
4c21 32 6c ee			ld (debug_mark+1),a  
4c24 3a 2e 4c			ld a, (.dmark+2)  
4c27 32 6d ee			ld (debug_mark+2),a  
4c2a 18 03			jr .pastdmark  
4c2c ..			.dmark: db "UEX"  
4c2f f1			.pastdmark: pop af  
4c30			endm  
# End of macro DMARK
4c30				CALLMONITOR 
4c30 cd 6f ee			call debug_vector  
4c33				endm  
# End of macro CALLMONITOR
4c33			endif 
4c33			 
4c33			 
4c33			 
4c33 eb				ex de, hl 
4c34 22 c2 e5			ld (os_tok_ptr), hl 
4c37				 
4c37				; Don't use next - Skips the first word in uword. 
4c37			 
4c37 c3 94 20			jp exec1 
4c3a			;	NEXT 
4c3a			 
4c3a			 
4c3a			; eof 
# End of file forth_wordsv4.asm
4c3a			endif 
4c3a			;;;;;;;;;;;;;; Debug code 
4c3a			 
4c3a			 
4c3a			;if DEBUG_FORTH_PARSE 
4c3a .. 00		.nowordfound: db "No match",0 
4c43 .. 00		.compword:	db "Comparing word ",0 
4c53 .. 00		.nextwordat:	db "Next word at",0 
4c60 .. 00		.charmatch:	db "Char match",0 
4c6b			;endif 
4c6b			if DEBUG_FORTH_JP 
4c6b			.foundword:	db "Word match. Exec..",0 
4c6b			endif 
4c6b			;if DEBUG_FORTH_PUSH 
4c6b .. 00		.enddict:	db "Dict end. Push.",0 
4c7b .. 00		.push_str:	db "Pushing string",0 
4c8a .. 00		.push_num:	db "Pushing number",0 
4c99 .. 00		.data_sp:	db "SP:",0 
4c9d .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4caf .. 00		.wordinde:	db "Word in DE (3/0):",0 
4cc1 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4cd3			;endif 
4cd3			;if DEBUG_FORTH_MALLOC 
4cd3 .. 00		.push_malloc:	db "Malloc address",0 
4ce2			;endif 
4ce2			 
4ce2			 
4ce2			 
4ce2			; display malloc address and current data stack pointer  
4ce2			 
4ce2			malloc_error: 
4ce2 d5				push de 
4ce3 f5				push af 
4ce4 e5				push hl 
4ce5 cd ba 0b			call clear_display 
4ce8 11 08 4d			ld de, .mallocerr 
4ceb 3e 00			ld a,0 
4ced			;	ld de,os_word_scratch 
4ced cd cd 0b			call str_at_display 
4cf0 3e 11			ld a, display_row_1+17 
4cf2 11 6b ee			ld de, debug_mark 
4cf5 cd cd 0b			call str_at_display 
4cf8 cd dd 0b			call update_display 
4cfb				;call break_point_state 
4cfb cd 1f 65			call cin_wait 
4cfe			 
4cfe			;	ld a, ' ' 
4cfe			;	ld (os_view_disable), a 
4cfe cd dd 15			call bp_on 
4d01 e1				pop hl 
4d02 f1				pop af 
4d03 d1				pop de	 
4d04				CALLMONITOR 
4d04 cd 6f ee			call debug_vector  
4d07				endm  
# End of macro CALLMONITOR
4d07 c9				ret 
4d08			 
4d08 .. 00		.mallocerr: 	db "Malloc Error",0 
4d15			;if DEBUG_FORTH_PUSH 
4d15			display_data_sp: 
4d15 f5				push af 
4d16			 
4d16				; see if disabled 
4d16			 
4d16			 
4d16 3a 6f ee			ld a, (debug_vector) 
4d19 fe c9			cp $C9  ; RET 
4d1b				;ld a, (os_view_disable) 
4d1b				;cp '*' 
4d1b 28 67			jr z, .skipdsp 
4d1d			 
4d1d e5				push hl 
4d1e e5				push hl 
4d1f e5			push hl 
4d20 cd ba 0b			call clear_display 
4d23 e1			pop hl 
4d24 7c				ld a,h 
4d25 21 c6 e5			ld hl, os_word_scratch 
4d28 cd e8 10			call hexout 
4d2b e1				pop hl 
4d2c 7d				ld a,l 
4d2d 21 c8 e5			ld hl, os_word_scratch+2 
4d30 cd e8 10			call hexout 
4d33 21 ca e5			ld hl, os_word_scratch+4 
4d36 3e 00			ld a,0 
4d38 77				ld (hl),a 
4d39 11 c6 e5			ld de,os_word_scratch 
4d3c 3e 28				ld a, display_row_2 
4d3e cd cd 0b				call str_at_display 
4d41 11 9d 4c			ld de, .wordinhl 
4d44 3e 00			ld a, display_row_1 
4d46			 
4d46 cd cd 0b				call str_at_display 
4d49 11 6b ee			ld de, debug_mark 
4d4c 3e 11			ld a, display_row_1+17 
4d4e			 
4d4e cd cd 0b				call str_at_display 
4d51			 
4d51				; display current data stack pointer 
4d51 11 99 4c			ld de,.data_sp 
4d54 3e 30				ld a, display_row_2 + 8 
4d56 cd cd 0b				call str_at_display 
4d59			 
4d59 2a ee e9			ld hl,(cli_data_sp) 
4d5c e5				push hl 
4d5d 7c				ld a,h 
4d5e 21 c6 e5			ld hl, os_word_scratch 
4d61 cd e8 10			call hexout 
4d64 e1				pop hl 
4d65 7d				ld a,l 
4d66 21 c8 e5			ld hl, os_word_scratch+2 
4d69 cd e8 10			call hexout 
4d6c 21 ca e5			ld hl, os_word_scratch+4 
4d6f 3e 00			ld a,0 
4d71 77				ld (hl),a 
4d72 11 c6 e5			ld de,os_word_scratch 
4d75 3e 33				ld a, display_row_2 + 11 
4d77 cd cd 0b				call str_at_display 
4d7a			 
4d7a			 
4d7a cd dd 0b			call update_display 
4d7d cd f2 0a			call delay1s 
4d80 cd f2 0a			call delay1s 
4d83 e1				pop hl 
4d84			.skipdsp: 
4d84 f1				pop af 
4d85 c9				ret 
4d86			 
4d86			display_data_malloc: 
4d86			 
4d86 f5				push af 
4d87 e5				push hl 
4d88 e5				push hl 
4d89 e5			push hl 
4d8a cd ba 0b			call clear_display 
4d8d e1			pop hl 
4d8e 7c				ld a,h 
4d8f 21 c6 e5			ld hl, os_word_scratch 
4d92 cd e8 10			call hexout 
4d95 e1				pop hl 
4d96 7d				ld a,l 
4d97 21 c8 e5			ld hl, os_word_scratch+2 
4d9a cd e8 10			call hexout 
4d9d 21 ca e5			ld hl, os_word_scratch+4 
4da0 3e 00			ld a,0 
4da2 77				ld (hl),a 
4da3 11 c6 e5			ld de,os_word_scratch 
4da6 3e 28				ld a, display_row_2 
4da8 cd cd 0b				call str_at_display 
4dab 11 d3 4c			ld de, .push_malloc 
4dae 3e 00			ld a, display_row_1 
4db0			 
4db0 cd cd 0b				call str_at_display 
4db3			 
4db3				; display current data stack pointer 
4db3 11 99 4c			ld de,.data_sp 
4db6 3e 30				ld a, display_row_2 + 8 
4db8 cd cd 0b				call str_at_display 
4dbb			 
4dbb 2a ee e9			ld hl,(cli_data_sp) 
4dbe e5				push hl 
4dbf 7c				ld a,h 
4dc0 21 c6 e5			ld hl, os_word_scratch 
4dc3 cd e8 10			call hexout 
4dc6 e1				pop hl 
4dc7 7d				ld a,l 
4dc8 21 c8 e5			ld hl, os_word_scratch+2 
4dcb cd e8 10			call hexout 
4dce 21 ca e5			ld hl, os_word_scratch+4 
4dd1 3e 00			ld a,0 
4dd3 77				ld (hl),a 
4dd4 11 c6 e5			ld de,os_word_scratch 
4dd7 3e 33				ld a, display_row_2 + 11 
4dd9 cd cd 0b				call str_at_display 
4ddc			 
4ddc cd dd 0b			call update_display 
4ddf cd f2 0a			call delay1s 
4de2 cd f2 0a			call delay1s 
4de5 e1				pop hl 
4de6 f1				pop af 
4de7 c9				ret 
4de8			;endif 
4de8			 
4de8			include "forth_autostart.asm" 
4de8			; list of commands to perform at system start up 
4de8			 
4de8			startcmds: 
4de8			;	dw test11 
4de8			;	dw test12 
4de8			;	dw test13 
4de8			;	dw test14 
4de8			;	dw test15 
4de8			;	dw test16 
4de8			;	dw test17 
4de8			;	dw ifthtest1 
4de8			;	dw ifthtest2 
4de8			;	dw ifthtest3 
4de8			;	dw mmtest1 
4de8			;	dw mmtest2 
4de8			;	dw mmtest3 
4de8			;	dw mmtest4 
4de8			;	dw mmtest5 
4de8			;	dw mmtest6 
4de8			;	dw iftest1 
4de8			;	dw iftest2 
4de8			;	dw iftest3 
4de8			;	dw looptest1 
4de8			;	dw looptest2 
4de8			;	dw test1 
4de8			;	dw test2 
4de8			;	dw test3 
4de8			;	dw test4 
4de8			;	dw game2r 
4de8			;	dw game2b1 
4de8			;	dw game2b2 
4de8			 
4de8				; start up words that are actually useful 
4de8			 
4de8			;    dw spi1 
4de8			;    dw spi2 
4de8			;    dw spi3 
4de8			;    dw spi4 
4de8			;    dw spi5 
4de8			;    dw spi6 
4de8			;    dw spi7 
4de8			; 
4de8			;    dw spi8 
4de8			;    dw spi9 
4de8			;    dw spi10 
4de8			 
4de8			; file editor 
4de8			;	dw edit1 
4de8			;	dw edit2 
4de8			;	dw edit3 
4de8			 
4de8			;	dw longread 
4de8 e8 51			dw clrstack 
4dea 1c 52			dw type 
4dec			;	dw stest 
4dec 41 52			dw strncpy 
4dee			;	dw list 
4dee a2 52			dw start1 
4df0 b2 52			dw start2 
4df2			;	dw start3 
4df2			;	dw start3b 
4df2			;	dw start3c 
4df2			 
4df2				; (unit) testing words 
4df2			 
4df2			;	dw mtesta 
4df2			;	dw mtestb 
4df2			;	dw mtestc 
4df2			;	dw mtestd 
4df2			;	dw mteste 
4df2			 
4df2				; demo/game words 
4df2			 
4df2			;        dw game3w 
4df2			;        dw game3p 
4df2			;        dw game3sc 
4df2			;        dw game3vsi 
4df2			;        dw game3vs 
4df2				 
4df2 0b 5d			dw game2b 
4df4 79 5d			dw game2bf 
4df6 c3 5d			dw game2mba 
4df8 59 5e			dw game2mbas 
4dfa 9b 5e			dw game2mb 
4dfc			 
4dfc cc 59			dw game1 
4dfe dd 59			dw game1a 
4e00 3f 5a			dw game1b 
4e02 74 5a			dw game1c 
4e04 aa 5a			dw game1d 
4e06 db 5a			dw game1s 
4e08 ef 5a			dw game1t 
4e0a 04 5b			dw game1f 
4e0c 38 5b			dw game1z 
4e0e 7c 5b			dw game1zz 
4e10			 
4e10 e6 57			dw test5 
4e12 1e 58			dw test6 
4e14 56 58			dw test7 
4e16 6a 58			dw test8 
4e18 96 58			dw test9 
4e1a ac 58			dw test10 
4e1c				 
4e1c 53 5c		        dw ssv5 
4e1e 37 5c		        dw ssv4 
4e20 1b 5c		        dw ssv3 
4e22 e5 5b		        dw ssv2 
4e24 6c 5c		        dw ssv1 
4e26 b4 5c		        dw ssv1cpm 
4e28			;	dw keyup 
4e28			;	dw keydown 
4e28			;	dw keyleft 
4e28			;	dw keyright 
4e28			;	dw 	keyf1 
4e28			;	dw keyf2 
4e28			;	dw keyf3 
4e28			;	dw keyf4 
4e28			;	dw keyf5 
4e28			;	dw keyf6 
4e28			;	dw keyf7 
4e28			;	dw keyf8 
4e28			;	dw keyf9 
4e28			;	dw keyf10 
4e28			;	dw keyf11 
4e28			;	dw keyf12 
4e28			;	dw keytab 
4e28			;	dw keycr 
4e28			;	dw keyhome 
4e28			;	dw keyend 
4e28			;	dw keybs 
4e28 00 00			db 0, 0	 
4e2a			 
4e2a			 
4e2a			; File Editor 
4e2a			 
4e2a			; ( id - ) use 'e' to edit the displayed line 
4e2a .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4e4b .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e80			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e80 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4eb8			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4eb8			 
4eb8			; SPI Net support words 
4eb8			 
4eb8			; v0! = node to send to 
4eb8			; ( str count - ) 
4eb8 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4f11			 
4f11			; spiputchr ( char node - ) 
4f11 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
4f47			 
4f47			; spigetchr ( - n ) 
4f47 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
4f72			 
4f72			; getnode ( - n ) 
4f72 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4f9f			 
4f9f			; ( str node - )  
4f9f .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5005			; store string ( str i - ) 
5005			 
5005			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5005 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
505a			 
505a			; get string ( addr i -  )    TO FIX 
505a			 
505a .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
50b2			 
50b2			 
50b2			; NETCHAT (TODO) 
50b2			; Program to allow two nodes to chat with eachother 
50b2			; 
50b2			; v0 - target node 
50b2			;  
50b2			; accept input at 0,0 
50b2			; if input is string send spitype to target node 
50b2			; starting at row 2,0 , while spigetchr is not zero ->  
50b2			; 
50b2			; 
50b2			; TODO add paging of get request 
50b2			 
50b2			; ( node - ) 
50b2 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
50d1 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5129 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
51a1			 
51a1			 
51a1			; Long read of currently open file 
51a1 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
51e8			 
51e8			; clear stack  
51e8			 
51e8 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
521c			 
521c			; type ( addr count - ) 
521c .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
5241			 
5241			; some direct memory words 
5241			; strncpy ( len t f -- t ) 
5241			 
5241 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
52a2			 
52a2 .. 00		start1:     	db ": bpon $00 bp ;",0 
52b2 .. 00		start2:     	db ": bpoff $01 bp ;",0 
52c3 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
533e .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
539e			 
539e			 
539e			; a handy word to list items on the stack 
539e			 
539e .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5408			 
5408			 
5408			; test stack  
5408			; rnd8 stest 
5408			 
5408 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
547f			 
547f			; random malloc and free cycles 
547f			 
547f .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5534			 
5534			; fixed malloc and free cycles 
5534			 
5534 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
55d7			 
55d7			; fixed double string push and drop cycle  
55d7			 
55d7 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
568c			 
568c			; consistent fixed string push and drop cycle  
568c			 
568c .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5730			 
5730 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
57e6			 
57e6			;test1:		db ": aa 1 2 3 ;", 0 
57e6			;test2:     	db "111 aa 888 999",0 
57e6			;test3:     	db ": bb 77 ;",0 
57e6			;test4:     	db "$02 $01 do i . loop bb",0 
57e6			 
57e6 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
581e .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5856 .. 00		test7:     	db ": box hline vline ;",0 
586a .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5896 .. 00		test9:     	db ": sw $01 adsp world ;",0 
58ac .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
58d1 .. 00		test11:     	db "hello create .",0 
58e0 .. 00		test12:     	db "hello2 create .",0 
58f0			 
58f0			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
58f0			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
58f0			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
58f0			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
58f0			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
58f0			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
58f0			 
58f0			;iftest1:     	db "$0001 IF cls .",0 
58f0			;iftest2:     	db "$0000 IF cls .",0 
58f0			;iftest3:     	db "$0002 $0003 - IF cls .",0 
58f0			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
58f0			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
58f0			 
58f0			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
58f0			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
58f0			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
58f0			 
58f0			 
58f0 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5914 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5944 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5969 .. 00		sound4: db ": cha $00 ; ",0 
5976 .. 00		sound5: db ": chb $20 ; ",0 
5983 .. 00		sound6: db ": chc $40 ; ",0 
5990 .. 00		sound7: db ": chd $60 ; ",0 
599d .. 00		sound8: db ": cnote $80 + + note ; ", 0 
59b5 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
59cc			 
59cc			 
59cc			 
59cc			 
59cc			; a small guess the number game 
59cc			 
59cc .. 00		game1:          db ": gsn rnd8 v1! ;",0 
59dd .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a3f			 
5a3f .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5a74 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5aaa .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5adb .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5aef .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b04 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b38 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5b7c			 
5b7c			; Using 'ga' save a high score across multiple runs using external storage 
5b7c			 
5b7c .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5be5			 
5be5			 
5be5			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5be5			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5be5			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5be5			 
5be5			; simple screen saver to test code memory reuse to destruction 
5be5			 
5be5 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c1b .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c37 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5c53 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5c6c .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5cb4 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d0b			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d0b			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d0b			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d0b			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d0b			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d0b			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d0b			 
5d0b			 
5d0b			 
5d0b			; minesweeper/battleship finding game 
5d0b			; draws a game board of random ship/mine positions 
5d0b			; user enters coords to see if it hits on 
5d0b			; game ends when all are hit 
5d0b			; when hit or miss says how many may be in the area 
5d0b			 
5d0b			; setup the game board and then hide it 
5d0b .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5d79 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5dc3			; prompt for where to target 
5dc3 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5e59 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5e7e			; TODO see if the entered coords hits or misses pushes char hit of miss 
5e7e .. 00		game2mbht:      db ": mbckht nop ;",0 
5e8d .. 00		game2mbms:      db ": mbcms nop ;",0 
5e9b			; TODO how many might be near by 
5e9b .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f18			 
5f18			; Game 3 
5f18			 
5f18			; Vert scroller ski game - avoid the trees! 
5f18			 
5f18			; v0 score (ie turns) 
5f18			; v1 player pos 
5f18			; v2 left wall 
5f18			; v3 right wall 
5f18			 
5f18			; Draw side walls randomly 
5f18			 
5f18 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5f46			 
5f46			; Draw player 
5f46 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5f64			 
5f64			; TODO Get Key 
5f64			 
5f64			; TODO Move left right 
5f64			 
5f64			; scroll and move walls a bit 
5f64			 
5f64 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5f95			 
5f95			; main game loop 
5f95			 
5f95 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5fc1 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6000			 
6000			; key board defs 
6000			 
6000 .. 00		keyup:       db ": keyup $05 ;",0 
600e .. 00		keydown:       db ": keydown $0a ;",0 
601e .. 00		keyleft:       db ": keyleft $0b ;",0 
602e .. 00		keyright:       db ": keyright $0c ;",0 
603f .. 00		keyf1:       db ": keyf1 $10 ;",0 
604d .. 00		keyf2:       db ": keyf2 $11 ;",0 
605b .. 00		keyf3:       db ": keyf3 $12 ;",0 
6069 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6077 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6085 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6093 .. 00		keyf7:       db ": keyf7 $16 ;",0 
60a1 .. 00		keyf8:       db ": keyf8 $17 ;",0 
60af .. 00		keyf9:       db ": keyf9 $18 ;",0 
60bd .. 00		keyf10:       db ": keyf10 $19 ;",0 
60cc .. 00		keyf11:       db ": keyf11 $1a ;",0 
60db .. 00		keyf12:       db ": keyf12 $1b ;",0 
60ea			 
60ea .. 00		keytab:       db ": keytab $09 ;",0 
60f9 .. 00		keycr:       db ": keycr $0d ;",0 
6107 .. 00		keyhome:       db ": keyhome $0e ;",0 
6117 .. 00		keyend:       db ": keyend $0f ;",0 
6126 .. 00		keybs:       db ": keybs $08 ;",0 
6134			 
6134			   
6134			 
6134			 
6134			 
6134			; eof 
# End of file forth_autostart.asm
6134			 
6134			 
6134			 
6134			; stack over and underflow checks 
6134			 
6134			; init the words to detect the under/overflow 
6134			 
6134			chk_stk_init: 
6134				; a vague random number to check so we dont get any "lucky" hits 
6134 3e 2d			ld a, 45 
6136 6f				ld l, a 
6137 00				nop 
6138 3e 17			ld a, 23 
613a 67				ld h, a 
613b			 
613b 22 a9 e2			ld (chk_word), hl     ; the word we need to check against 
613e			 
613e			;	ld (chk_stund), hl	; stack points.... 
613e 22 00 ef			ld (chk_stovr), hl 
6141 22 ec e9			ld (chk_ret_und), hl 
6144 22 aa e9			ld (chk_ret_ovr), hl 
6147 22 28 e9			ld (chk_loop_ovr), hl 
614a 22 26 e8			ld (chk_data_ovr), hl 
614d c9				ret 
614e				 
614e			check_stacks: 
614e				; check all stack words 
614e			 
614e e5				push hl 
614f d5				push de 
6150			 
6150			;	ld de,(chk_word) 
6150			;	ld hl, (chk_stund)	; stack points.... 
6150			;	if DEBUG_STK_FAULT 
6150			;		DMARK "FAa" 
6150			;		CALLMONITOR 
6150			;	endif 
6150			;	call cmp16 
6150			;	jp z, .chk_faulta 
6150			; 
6150			;	ld de, sfaultsu 
6150			;	jp .chk_fault 
6150			 
6150 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
6153 ed 5b a9 e2		ld de,(chk_word) 
6157				if DEBUG_STK_FAULT 
6157					DMARK "FAb" 
6157					CALLMONITOR 
6157				endif 
6157 cd 05 0e			call cmp16 
615a 28 06			jr z, .chk_fault1 
615c 11 fd 61			ld de, sfaultso 
615f c3 b1 61			jp .chk_fault 
6162			.chk_fault1:  
6162 2a ec e9			ld hl, (chk_ret_und) 
6165 ed 5b a9 e2		ld de,(chk_word) 
6169				if DEBUG_STK_FAULT 
6169					DMARK "FAU" 
6169					CALLMONITOR 
6169				endif 
6169 cd 05 0e			call cmp16 
616c ca 75 61			jp z, .chk_fault2 
616f 11 0d 62			ld de, sfaultru 
6172 c3 b1 61			jp .chk_fault 
6175			.chk_fault2:  
6175 2a aa e9			ld hl, (chk_ret_ovr) 
6178 ed 5b a9 e2		ld de,(chk_word) 
617c				if DEBUG_STK_FAULT 
617c					DMARK "FA1" 
617c					CALLMONITOR 
617c				endif 
617c cd 05 0e			call cmp16 
617f ca 88 61			jp z, .chk_fault3 
6182 11 1b 62			ld de, sfaultro 
6185 c3 b1 61			jp .chk_fault 
6188			.chk_fault3:  
6188 2a 28 e9			ld hl, (chk_loop_ovr) 
618b ed 5b a9 e2		ld de,(chk_word) 
618f				if DEBUG_STK_FAULT 
618f					DMARK "FA2" 
618f					CALLMONITOR 
618f				endif 
618f cd 05 0e			call cmp16 
6192 ca 9b 61			jp z, .chk_fault4 
6195 11 35 62			ld de, sfaultlo 
6198 c3 b1 61			jp .chk_fault 
619b			.chk_fault4:  
619b 2a 26 e8			ld hl, (chk_data_ovr) 
619e ed 5b a9 e2		ld de,(chk_word) 
61a2				if DEBUG_STK_FAULT 
61a2					DMARK "FA3" 
61a2					CALLMONITOR 
61a2				endif 
61a2 cd 05 0e			call cmp16 
61a5 ca ae 61			jp z, .chk_fault5 
61a8 11 4f 62			ld de, sfaultdo 
61ab c3 b1 61			jp .chk_fault 
61ae			 
61ae			 
61ae			.chk_fault5:  
61ae d1				pop de 
61af e1				pop hl 
61b0			 
61b0 c9				ret 
61b1			 
61b1 cd ba 0b		.chk_fault: 	call clear_display 
61b4 3e 28				ld a, display_row_2 
61b6 cd cd 0b				call str_at_display 
61b9 11 df 61				   ld de, .stackfault 
61bc 3e 00				ld a, display_row_1 
61be cd cd 0b				call str_at_display 
61c1 11 6b ee				    ld de, debug_mark 
61c4 3e 11				ld a, display_row_1+17 
61c6 cd cd 0b				call str_at_display 
61c9 cd dd 0b				call update_display 
61cc			 
61cc				; prompt before entering montior for investigating issue 
61cc			 
61cc 3e 78			ld a, display_row_4 
61ce 11 48 19			ld de, endprog 
61d1			 
61d1 cd dd 0b			call update_display		 
61d4			 
61d4 cd ce 1b			call next_page_prompt 
61d7			 
61d7 d1				pop de 
61d8 e1				pop hl 
61d9 cd 9c 19				call monitor 
61dc c3 96 18				jp warmstart 
61df					;jp 0 
61df					;halt 
61df			 
61df			 
61df			 
61df .. 00		.stackfault: 	db "Stack fault:",0 
61ec			 
61ec .. 00		sfaultsu: 	db	"Stack under flow",0 
61fd .. 00		sfaultso: 	db	"Stack over flow",0 
620d .. 00		sfaultru:	db "RTS underflow",0 
621b .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6235 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
624f .. 00		sfaultdo:	db "DTS overflow", 0 
625c			 
625c			 
625c			fault_dsp_under: 
625c 11 6e 62			ld de, .dsp_under 
625f c3 1e 63			jp .show_fault 
6262			 
6262			fault_rsp_under: 
6262 11 7c 62			ld de, .rsp_under 
6265 c3 1e 63			jp .show_fault 
6268			fault_loop_under: 
6268 11 8a 62			ld de, .loop_under 
626b c3 1e 63			jp .show_fault 
626e			 
626e .. 00		.dsp_under: db "DSP Underflow",0 
627c .. 00		.rsp_under: db "RSP Underflow",0 
628a .. 00		.loop_under: db "LOOP Underflow",0 
6299			 
6299			 
6299 d5			type_faultn: 	push de 
629a e5					push hl 
629b cd ba 0b				call clear_display 
629e 11 c5 62				   ld de, .typefaultn 
62a1 3e 00				ld a, display_row_1 
62a3 cd cd 0b				call str_at_display 
62a6 11 6b ee				    ld de, debug_mark 
62a9 3e 11				ld a, display_row_1+17 
62ab cd cd 0b				call str_at_display 
62ae cd dd 0b				call update_display 
62b1			 
62b1				; prompt before entering montior for investigating issue 
62b1			 
62b1 3e 78			ld a, display_row_4 
62b3 11 48 19			ld de, endprog 
62b6			 
62b6 cd dd 0b			call update_display		 
62b9			 
62b9 cd ce 1b			call next_page_prompt 
62bc			 
62bc e5					push hl 
62bd d5					push de 
62be cd 9c 19				call monitor 
62c1 c3 96 18				jp warmstart 
62c4 76					halt 
62c5			 
62c5			 
62c5 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
62dc			 
62dc d5			type_faults: 	push de 
62dd e5					push hl 
62de cd ba 0b				call clear_display 
62e1 11 07 63				   ld de, .typefaults 
62e4 3e 00				ld a, display_row_1 
62e6 cd cd 0b				call str_at_display 
62e9 11 6b ee				    ld de, debug_mark 
62ec 3e 11				ld a, display_row_1+17 
62ee cd cd 0b				call str_at_display 
62f1 cd dd 0b				call update_display 
62f4			 
62f4				; prompt before entering montior for investigating issue 
62f4			 
62f4 3e 78			ld a, display_row_4 
62f6 11 48 19			ld de, endprog 
62f9			 
62f9 cd dd 0b			call update_display		 
62fc			 
62fc cd ce 1b			call next_page_prompt 
62ff			 
62ff e1					pop hl 
6300 d1					pop de 
6301 cd 9c 19				call monitor 
6304 c3 96 18				jp warmstart 
6307			 
6307			 
6307 .. 00		.typefaults: db "STR Type Expected TOS!",0 
631e			 
631e			.show_fault: 	 
631e d5					push de 
631f cd ba 0b				call clear_display 
6322 d1					pop de 
6323 3e 00				ld a, display_row_1 
6325 cd cd 0b				call str_at_display 
6328 11 6b ee				    ld de, debug_mark 
632b 3e 11				ld a, display_row_1+17 
632d cd cd 0b				call str_at_display 
6330 cd dd 0b				call update_display 
6333			 
6333				; prompt before entering montior for investigating issue 
6333			 
6333 3e 78			ld a, display_row_4 
6335 11 48 19			ld de, endprog 
6338			 
6338 cd dd 0b			call update_display		 
633b			 
633b cd ce 1b			call next_page_prompt 
633e			 
633e e1					pop hl 
633f d1					pop de 
6340 cd 9c 19				call monitor 
6343			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6343			; TODO Make optional fault restart to cli or warm boot? 
6343					;jp warmstart 
6343 c3 ee 18				jp cli 
6346 76					halt 
6347			 
6347			; handle the auto run of code from files in storage 
6347			 
6347			 
6347			include "forth_startup.asm" 
6347			; Which startup method to use? 
6347			; 
6347			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
6347			; followed by loading of a list of scripts in eeprom 
6347			 
6347			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
6347			; from eeprom 
6347			 
6347			; Select with define in main stubs 
6347			 
6347			if STARTUP_V1 
6347				include "forth_startupv1.asm" 
6347			; Startup script loading version 1 
6347			 
6347			; If SE storage is available first stage is to use the selected file 
6347			; then go through the eeprom list 
6347			 
6347 .. 00		sprompt1: db "Startup load...",0 
6357 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
636d			 
636d			 
636d			 
636d			 
636d			forth_startup: 
636d 21 e8 4d			ld hl, startcmds 
6370 3e 00			ld a, 0 
6372 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6375			 
6375 e5			.start1:	push hl 
6376 cd ba 0b			call clear_display 
6379 11 47 63			ld de, sprompt1 
637c 3e 00		        ld a, display_row_1 
637e cd cd 0b			call str_at_display 
6381 11 57 63			ld de, sprompt2 
6384 3e 28		        ld a, display_row_2 
6386 cd cd 0b			call str_at_display 
6389 e1				pop hl 
638a e5				push hl 
638b 5e				ld e,(hl) 
638c 23				inc hl 
638d 56				ld d,(hl) 
638e 3e 50		        ld a, display_row_3 
6390 cd cd 0b			call str_at_display 
6393 cd dd 0b			call update_display 
6396			 
6396			 
6396 3a e7 e6			ld a, (os_last_cmd) 
6399 fe 00			cp 0 
639b 28 05			jr z, .startprompt 
639d cd e6 0a			call delay250ms 
63a0 18 24			jr .startdo 
63a2				 
63a2				 
63a2			 
63a2			.startprompt: 
63a2			 
63a2 3e 9f			ld a,display_row_4 + display_cols - 1 
63a4 11 cc 1b		        ld de, endprg 
63a7 cd cd 0b			call str_at_display 
63aa cd dd 0b			call update_display 
63ad cd f2 0a			call delay1s 
63b0 cd 1f 65			call cin_wait 
63b3						 
63b3 fe 2a			cp '*' 
63b5 28 5e			jr z, .startupend1 
63b7 fe 23			cp '#' 
63b9 20 07			jr nz, .startno 
63bb 3e 01			ld a, 1 
63bd 32 e7 e6			ld (os_last_cmd),a 
63c0 18 04			jr .startdo 
63c2 fe 31		.startno:	cp '1' 
63c4 28 3a			jr z,.startnxt  
63c6			 
63c6				; exec startup line 
63c6			.startdo:	 
63c6 e1				pop hl 
63c7 e5				push hl 
63c8				 
63c8 5e				ld e,(hl) 
63c9 23				inc hl 
63ca 56				ld d,(hl) 
63cb eb				ex de,hl 
63cc			 
63cc e5				push hl 
63cd			 
63cd 3e 00			ld a, 0 
63cf				;ld a, FORTH_END_BUFFER 
63cf cd 50 12			call strlent 
63d2 23				inc hl   ; include zero term to copy 
63d3 06 00			ld b,0 
63d5 4d				ld c,l 
63d6 e1				pop hl 
63d7 11 c1 e2			ld de, scratch 
63da ed b0			ldir 
63dc			 
63dc			 
63dc 21 c1 e2			ld hl, scratch 
63df cd 51 20			call forthparse 
63e2 cd 91 20			call forthexec 
63e5 cd a3 1f			call forthexec_cleanup 
63e8			 
63e8 3e 78			ld a, display_row_4 
63ea 11 48 19			ld de, endprog 
63ed			 
63ed cd dd 0b			call update_display		 
63f0			 
63f0 3a e7 e6			ld a, (os_last_cmd) 
63f3 fe 00			cp 0 
63f5 20 09			jr nz, .startnxt 
63f7 cd ce 1b			call next_page_prompt 
63fa cd ba 0b		        call clear_display 
63fd cd dd 0b			call update_display		 
6400			 
6400				; move onto next startup line? 
6400			.startnxt: 
6400			 
6400 cd e6 0a			call delay250ms 
6403 e1				pop hl 
6404			 
6404 23				inc hl 
6405 23				inc hl 
6406			 
6406 e5				push hl 
6407 5e				ld e, (hl) 
6408 23				inc hl 
6409 56				ld d, (hl) 
640a e1				pop hl 
640b				; TODO replace 0 test 
640b			 
640b eb				ex de, hl 
640c cd 10 0e			call ishlzero 
640f			;	ld a,e 
640f			;	add d 
640f			;	cp 0    ; any left to do? 
640f eb				ex de, hl 
6410 c2 75 63			jp nz, .start1 
6413 18 01			jr .startupend 
6415			 
6415 e1			.startupend1: pop hl 
6416			.startupend: 
6416			 
6416 cd ba 0b			call clear_display 
6419 cd dd 0b			call update_display 
641c c9				ret 
641d			if STORAGE_SE 
641d			 
641d			sprompt3: db "Loading from start-up file?:",0 
641d			sprompt4: db "(Y=Any key/N=No)",0 
641d			 
641d			 
641d			forth_autoload: 
641d			 
641d				; load block 0 of store 1 
641d				 
641d				ld a, $fe      ; bit 0 clear 
641d				ld (spi_device), a 
641d			 
641d				call storage_get_block_0 
641d			 
641d				ld a, (store_page+STORE_0_AUTOFILE) 
641d			 
641d				cp 0 
641d				ret z     ; auto start not enabled 
641d			 
641d				call clear_display 
641d			 
641d				; set bank 
641d			 
641d					ld a, (store_page+STORE_0_BANKRUN) 
641d					ld (spi_device), a 
641d			 
641d				; get file id to load from and get the file name to display 
641d			 
641d					ld a, (store_page+STORE_0_FILERUN) 
641d			 
641d					ld l, 0 
641d					ld h, a 
641d					ld de, store_page 
641d			 
641d					if DEBUG_FORTH_WORDS 
641d						DMARK "ASp" 
641d						CALLMONITOR 
641d					endif 
641d					call storage_read 
641d			 
641d					if DEBUG_FORTH_WORDS 
641d						DMARK "ASr" 
641d						CALLMONITOR 
641d					endif 
641d			 
641d					call ishlzero 
641d					ret z             ; file not found 
641d			 
641d					ld a, display_row_2 + 10 
641d					ld de, store_page+3 
641d					call str_at_display 
641d				 
641d			; 
641d			 
641d				ld a, display_row_1+5 
641d				ld de, sprompt3 
641d				call str_at_display 
641d				ld a, display_row_3+15 
641d				ld de, sprompt4 
641d				call str_at_display 
641d			 
641d				call update_display 
641d			 
641d				call cin_wait 
641d				cp 'n' 
641d				ret z 
641d				cp 'N' 
641d				ret z 
641d			 
641d				call delay1s 
641d			 
641d				ld a, (store_page+2) 
641d				ld (store_openmaxext), a    ; save count of ext 
641d				ld a, 1  
641d				ld (store_openext), a    ; save count of ext 
641d			 
641d			.autof:  
641d				ld l , a 
641d				 
641d				ld a, (store_page) 
641d				ld h, a	 
641d				ld de, store_page 
641d					if DEBUG_FORTH_WORDS 
641d						DMARK "ASl" 
641d						CALLMONITOR 
641d					endif 
641d					call storage_read 
641d				call ishlzero 
641d				ret z 
641d			;	jr z, .autoend 
641d			 
641d					if DEBUG_FORTH_WORDS 
641d						DMARK "ASc" 
641d						CALLMONITOR 
641d					endif 
641d				ld de, store_page+2 
641d				ld a, display_row_4 
641d				call str_at_display 
641d			 
641d				call update_display 
641d				call delay250ms 
641d			 
641d			 
641d			 
641d				ld hl, store_page+2 
641d				call forthparse 
641d				call forthexec 
641d				call forthexec_cleanup 
641d			 
641d				 
641d				ld a, (store_openext) 
641d				inc a 
641d				ld (store_openext), a    ; save count of ext 
641d			 
641d				jr .autof 
641d			;.autofdone: 
641d			; 
641d			;		if DEBUG_FORTH_WORDS 
641d			;			DMARK "ASx" 
641d			;			CALLMONITOR 
641d			;		endif 
641d			;;	call clear_display 
641d			;	ret 
641d			 
641d			 
641d			 
641d			endif 
# End of file forth_startupv1.asm
641d			endif 
641d			if STARTUP_V2 
641d				include "forth_startupv2.asm" 
641d			endif 
641d			 
# End of file forth_startup.asm
641d			 
641d			; eof 
# End of file forth_kernel.asm
641d			;include "nascombasic.asm" 
641d			 
641d			 
641d			; find out where the code ends if loaded into RAM (for SC114) 
641d			;endofcode:  
641d			;	nop 
641d			 
641d			 
641d			; jump to nmi vector 
641d			 
641d			init_nmi: 
641d 3e c9			ld a, $c9   ; RET 
641f 32 72 ee			ld (nmi_vector), a 
6422 c9				ret 
6423			nmi: 
6423 e5				push hl 
6424 d5				push de 
6425 c5				push bc 
6426 f5				push af 
6427 cd 72 ee			call nmi_vector 
642a f5				push af 
642b c5				push bc 
642c d5				push de 
642d e5				push hl 
642e ed 4d			reti 
6430			 
6430			 
6430			; eof 
6430			 
# End of file main.asm
6430			;include "firmware_lcd_4x40.asm" 
6430			;;include "firmware_lcd_4x20.asm" 
6430			include "firmware_cpm_display.asm" 
6430			 
6430			; Serial display interface for SC114 
6430			 
6430			 
6430			display_row_1: equ 0 
6430			display_row_2: equ display_row_1+display_cols 
6430			display_row_3: equ display_row_2 + display_cols 
6430			display_row_4: equ display_row_3 + display_cols 
6430			 
6430			kLCDWidth:  EQU display_cols             ;Width in characters 
6430			kLCD_Line1: EQU 0x00  
6430			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
6430			; E1 
6430			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
6430			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
6430			 
6430			lcd_init: 
6430				; no init as handled by the SCM bios 
6430 c9				ret 
6431			 
6431			 
6431			; low level functions for direct screen writes 
6431			 
6431			; output char at pos? 
6431			fLCD_Str: 
6431			        ;out (SC114_SIO_1_OUT),a 
6431 c5				push bc 
6432 d5				push de 
6433 5f				ld e, a 
6434			; TODO Replace with CP/M BIOS call 
6434 0e 02			ld c, $02 
6436 cd 05 00			call 5 
6439 d1				pop de 
643a c1				pop bc 
643b c9				ret 
643c			 
643c			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
643c			fLCD_Pos: 
643c				; use ASCII escape to position 
643c			        ;out (SC114_SIO_1_OUT),a 
643c c5				push bc 
643d d5				push de 
643e 5f				ld e, a 
643f 0e 02			ld c, $02 
6441			; TODO Replace with CP/M BIOS call 
6441 cd 05 00			call 5 
6444 d1				pop de 
6445 c1				pop bc 
6446			 
6446 c9				ret 
6447			 
6447			; output char at pos 
6447			fLCD_Data: 
6447			      ;  out (SC114_SIO_1_OUT),a 
6447 c5				push bc 
6448 d5				push de 
6449 0e 02			ld c, $02 
644b 5f				ld e, a 
644c			; TODO Replace with CP/M BIOS call 
644c cd 05 00			call 5 
644f d1				pop de 
6450 c1				pop bc 
6451			 
6451 c9				ret 
6452			 
6452			; ascii cls  
6452			 
6452 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
6456			 
6456 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
646d			;.clscpm: db 3, $3c,"$" 
646d			 
646d			; write the frame buffer given in hl to hardware  
646d			write_display: 
646d			 
646d			API: equ 0 
646d			 
646d			if API 
646d				push bc 
646d				ld b, 4 
646d			 
646d			        ld (display_write_tmp), hl 	  
646d			 
646d				; clear and home cursor 
646d			 
646d				ld c, 9 
646d				ld de, .cls 
646d			; TODO Replace with CP/M BIOS call 
646d				call 5 
646d			 
646d			 
646d			.writeln: 
646d			 
646d				ld de, (display_write_tmp) 
646d				ld c, 6 
646d			; TODO Replace with CP/M BIOS call 
646d				rst $30 
646d				ld c, 7 
646d				rst $30 
646d			 
646d				ld hl, (display_write_tmp) 
646d				ld de, display_cols 
646d				add hl,de 
646d				ld (display_write_tmp),hl 
646d			 
646d				djnz  .writeln 
646d			 
646d				pop bc 
646d			 
646d			 
646d				ret 
646d			endif 
646d e5				push hl 
646e c5				push bc 
646f d5				push de 
6470			 
6470			;	ld c, 2 
6470			;	;ld de, .cls 
6470			;	ld a, 27 
6470			;	rst $30 
6470			;	ld c, 2 
6470			;	;ld de, .cls 
6470			;	ld a, '[' 
6470			;	rst $30 
6470			; 
6470			;	ld c, 2 
6470			;	;ld de, .cls 
6470			;	ld a, 'H' 
6470			;	rst $30 
6470			; 
6470			 
6470			 
6470			; lots of CR/LF 
6470			;	ld c, 9 
6470			;	ld de, .clscpm 
6470			;	call 5 
6470			 
6470			; xterm cls 
6470 0e 02			ld c, 2 
6472 1e 1b			ld e, 27 
6474 cd 05 00			call 5 
6477			; cls causes too much flicker 
6477			;	ld c, 2 
6477			;	ld e, 'c' 
6477			;	call 5 
6477			 
6477			; use xterm home instead 
6477 0e 02			ld c, 2 
6479 1e 5b			ld e, '[' 
647b cd 05 00			call 5 
647e 0e 02			ld c, 2 
6480 1e 48			ld e, 'H' 
6482 cd 05 00			call 5 
6485			LLL: equ 0 
6485			 
6485			if LLL 
6485			 
6485				ld c, 2 
6485				;ld de, .cls 
6485				ld e, 27 
6485			; TODO Replace with CP/M BIOS call 
6485				call 5 
6485			 
6485			 
6485				ld c, 2 
6485				;ld de, .cls 
6485				ld e, '[' 
6485			; TODO Replace with CP/M BIOS call 
6485				call 5 
6485				ld c, 2 
6485				;ld de, .cls 
6485				ld e, '2' 
6485			; TODO Replace with CP/M BIOS call 
6485				call 5 
6485				ld c, 2 
6485				;ld de, .cls 
6485				ld e, 'J' 
6485			; TODO Replace with CP/M BIOS call 
6485				call 5 
6485			 
6485			endif 
6485			 
6485 d1				pop de 
6486 c1				pop bc 
6487 e1				pop hl 
6488			 
6488			 
6488 22 c9 eb		        ld (display_write_tmp), hl 	  
648b 3e 00			ld a, kLCD_Line1 
648d			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
648d 06 28			ld b, display_cols 
648f ed 5b c9 eb		ld de, (display_write_tmp) 
6493 cd 16 65			call write_len_string 
6496				 
6496			 
6496 e5			push hl 
6497 d5			push de 
6498 c5			push bc 
6499 0e 02			ld c, 2 
649b 1e 0a			ld e, 10 
649d cd 05 00			call 5 
64a0 0e 02			ld c, 2 
64a2 1e 0d			ld e, 13 
64a4 cd 05 00			call 5 
64a7			; TODO Replace with CP/M BIOS call 
64a7				;rst $30 
64a7 c1			pop bc 
64a8 d1			pop de 
64a9 e1			pop hl 
64aa			 
64aa				 
64aa 2a c9 eb			ld hl, (display_write_tmp) 
64ad 11 28 00			ld de, display_cols 
64b0 19				add hl,de 
64b1 22 c9 eb			ld (display_write_tmp),hl 
64b4			 
64b4				 
64b4 3e 28			ld a, kLCD_Line2 
64b6			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
64b6 06 28			ld b, display_cols 
64b8 ed 5b c9 eb		ld de, (display_write_tmp) 
64bc cd 16 65			call write_len_string 
64bf				 
64bf 2a c9 eb			ld hl, (display_write_tmp) 
64c2 11 28 00			ld de, display_cols 
64c5 19				add hl,de 
64c6 22 c9 eb			ld (display_write_tmp),hl 
64c9			 
64c9 e5			push hl 
64ca d5			push de 
64cb c5			push bc 
64cc 0e 07			ld c, 7 
64ce			; TODO Replace with CP/M BIOS call 
64ce				;rst $30 
64ce 0e 02			ld c, 2 
64d0 1e 0a			ld e, 10 
64d2 cd 05 00			call 5 
64d5 0e 02			ld c, 2 
64d7 1e 0d			ld e, 13 
64d9 cd 05 00			call 5 
64dc c1			pop bc 
64dd d1			pop de 
64de e1			pop hl 
64df			 
64df				 
64df 3e 50			ld a, kLCD_Line3 
64e1			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
64e1 06 28			ld b, display_cols 
64e3 ed 5b c9 eb		ld de, (display_write_tmp) 
64e7 cd 16 65			call write_len_string 
64ea				 
64ea 2a c9 eb			ld hl, (display_write_tmp) 
64ed 11 28 00			ld de, display_cols 
64f0 19				add hl,de 
64f1 22 c9 eb			ld (display_write_tmp),hl 
64f4			 
64f4 e5			push hl 
64f5 d5			push de 
64f6 c5			push bc 
64f7 0e 07			ld c, 7 
64f9			; TODO Replace with CP/M BIOS call 
64f9				;rst $30 
64f9 0e 02			ld c, 2 
64fb 1e 0a			ld e, 10 
64fd cd 05 00			call 5 
6500 0e 02			ld c, 2 
6502 1e 0d			ld e, 13 
6504 cd 05 00			call 5 
6507 c1			pop bc 
6508 d1			pop de 
6509 e1			pop hl 
650a			 
650a				 
650a 3e 78			ld a, kLCD_Line4 
650c			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
650c 06 28			ld b, display_cols 
650e ed 5b c9 eb		ld de, (display_write_tmp) 
6512 cd 16 65			call write_len_string 
6515 c9					ret 
6516			 
6516			 
6516				; write out a fixed length string given in b from de 
6516			 
6516 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
6517 cd 47 64		            CALL fLCD_Data      ;Write character to display 
651a 13				inc de 
651b 10 f9			djnz write_len_string 
651d c9				ret 
651e			 
651e			 
651e			; eof 
# End of file firmware_cpm_display.asm
651e			;include "firmware_key_5x10.asm" 
651e			;;include "firmware_key_4x10.asm" 
651e			include "firmware_key_cpm.asm" 
651e			; Serial keyboard interface for SC114 
651e			 
651e			 
651e			key_init: 
651e				; no init as handled by the SCM bios 
651e c9				ret 
651f			 
651f			 
651f			cin_wait: 
651f			;	ld a, 0 
651f			;	ret 
651f			 
651f				;in a,(SC114_SIO_1_IN) 
651f			        ; Use SCM API to get from whatever console device we are using 
651f			 
651f			; TODO Replace with CP/M BIOS call 
651f c5				push bc 
6520 0e 01			ld c, $01 
6522 cd 05 00			call 5 
6525 c1				pop bc 
6526 c9				ret 
6527			 
6527			cin: 
6527			 
6527			 
6527 c5				push bc 
6528			 
6528				; any key waiting to process? 
6528			; TODO Replace with CP/M BIOS call 
6528 0e 06			ld c, $06 
652a cd 05 00			call 5 
652d 28 0d			jr z, .cin_skip 
652f			 
652f				; yep, get it 
652f			 
652f 0e 01			ld c, $01 
6531			; TODO Replace with CP/M BIOS call 
6531 cd 05 00			call 5 
6534			 
6534 fe 7f			cp $7f     ; back space 
6536 20 02			jr nz, .skipbs 
6538 3e 08			ld a, KEY_BS 
653a			.skipbs: 
653a			 
653a c1				pop bc 
653b c9				ret 
653c			.cin_skip: 
653c 3e 00			ld a, 0 
653e c1				pop bc 
653f c9				ret 
6540			 
6540			 
6540			 
6540			 
# End of file firmware_key_cpm.asm
6540			endofcode:  
6540			baseram:  
6540 00				nop 
6541			 
6541			heap_start: equ baseram+15  ; Starting address of heap 
6541			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
6541			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
6541			;VDU:  EQU     endofcode           ; BASIC Work space 
6541			; eof 
6541			 
# End of file os_mega_cpm.asm
6541
