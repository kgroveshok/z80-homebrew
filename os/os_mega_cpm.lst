# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 79 17			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-08-11 12:33' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
011f			 
011f			 
011f			 
011f			;        nop  
011f			;        nop 
011f			;;	org 05h		; null out bdos call 
011f			; 
011f			;        nop  
011f			;        nop  
011f			;        nop 
011f			;;	org 08h 
011f			;;; 
011f			;;	jp cin		; rst 8 - char in 
011f			;;; 
011f			; 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;	org 010h 
011f			;; 
011f			;	jp cout		; rest 010h  - char out 
011f			;; 
011f			;	org 01bh   
011f			; 
011f			;	;jp  		; rst 01bh   - write string to display 
011f			;	jp str_at_display 
011f			; 
011f			; 
011f			;	org 020h 
011f			; 
011f			;	; jp		 ; rst 020h - read char at screen location 
011f			; 
011f			;	org 028h 
011f			 
011f				; jp		 ; rst 028h  - storage i/o 
011f			 
011f			; 	org 030h 
011f			;	jp break_point_state 
011f			  
011f			; $30  
011f			; org 038h 
011f			; $38 
011f			 
011f			; TODO any more important entry points to add to jump table for easier coding use? 
011f			 
011f			if BASE_KEV = 1  
011f			 
011f				; need to be at $66 for nmi support 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255 
011f				jp nmi 
011f			endif 
011f			 
011f			include "firmware.asm" 
011f			  
011f			; main constants (used here and in firmware)  
011f			  
011f			; TODO have page 0 of storage as bios  
011f			  
011f			Device_A: equ 0h  
011f			Device_B: equ 040h          ; Sound  
011f			  
011f			if BASE_KEV  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_SC114  
011f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			; TODO fixup for CPM  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			Device_D: equ 0c0h             ; Keyboard and LCD  
011f			  
011f			; Odd specific debug points for testing hardware dev  
011f			  
011f			;if DEBUG_LEVEL0  
011f			;	include "debug_level0.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL1  
011f			;	include "debug_level1.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL2  
011f			;	include "debug_level2.asm"  
011f			;endif  
011f			  
011f			  
011f			CALLMONITOR: macro  
011f			;	call break_point_state  
011f			; now use the break point debug vector  
011f				call debug_vector  
011f				endm  
011f			  
011f			MALLOC_1: equ 1        ; from dk88   
011f			MALLOC_2: equ 0           ; broke  
011f			MALLOC_3: equ 0           ; really broke  
011f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011f			  
011f			if BASE_KEV   
011f			;stacksize: equ 256  
011f			; each stack entry is three bytes (type + word)  
011f			stacksize: equ 3*150  
011f			  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 512  
011f			endif  
011f			if BASE_SC114  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			;if STORAGE_SE == 0  
011f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011f			;endif  
011f			  
011f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011f			  
011f			STORE_0_AUTORUN: equ $20  
011f			  
011f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011f			  
011f			STORE_0_AUTOFILE: equ $21  
011f			STORE_0_BANKRUN: equ $23  
011f			STORE_0_FILERUN: equ $24  
011f			  
011f			; Block 0 offsets for settings  
011f			  
011f			; if set then skip prompt for start up and accept all  
011f			  
011f			STORE_0_QUICKSTART: equ $25  
011f			  
011f			; Blocks where directory table is held  
011f			  
011f			; Reducing the number of entries increases the max file size  
011f			  
011f			;STORE_DIR_START: equ 1  
011f			;STORE_DIR_END: equ 33  
011f			  
011f			; Blocks from where file data is stored  
011f			  
011f			;STORE_DATA_START: equ STORE_DIR_END + 1  
011f			  
011f			; Block indicators (<32 are data files)  
011f			  
011f			;STORE_BLOCK_CFG: equ $8f       ; config block  
011f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011f			;STORE_BLOCK_FREE: equ $85       ; data block free  
011f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011f			  
011f			  
011f			  
011f			; Directory entry flags  
011f			  
011f			;STORE_DIR_FREE: equ 0  
011f			;STORE_DIR_FILE:  equ 1  
011f			  
011f			; Structure offsets to directory entries  
011f			;STORE_DE_FLAG: equ 0  
011f			;STORE_DE_MAXEXT: equ 1  
011f			;STORE_DE_FILENAME: equ 2  
011f			  
011f			; Structure offsets to block 0  
011f			  
011f			;STORE_BK0_ISFOR: equ 1  
011f			;STORE_BK0_LABEL: equ 3  
011f			  
011f			; memory allocation   
011f			  
011f			chk_stund: equ tos+2           ; underflow check word  
011f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011f			  
011f			; keyscan table needs rows x cols buffer  
011f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011f			  
011f			keyscan_table_row1: equ chk_stovr -key_cols-1  
011f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011f			keyscan_scancol: equ keyscan_table-key_cols  
011f			;keyscan_table_len: equ key_rows*key_cols  
011f			;keybufptr: equ keyscan_table - 2  
011f			;keysymbol: equ keybufptr - 1  
011f			key_held: equ keyscan_scancol-1	; currently held  
011f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011f			key_fa: equ key_repeat_ct -1 ;  
011f			key_fb: equ key_fa -1 ;  
011f			key_fc: equ key_fb -1 ;  
011f			key_fd: equ key_fc -1 ;  
011f			key_face_held: equ key_fd - 1   
011f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011f			  
011f			hardware_config: equ key_face_held - 10  
011f			  
011f			; hardware config switches  
011f			; TODO add bitmasks on includes for hardware  
011f			; high byte for expansion ids  
011f			;     0000 0000  no card inserted  
011f			;     0000 0001  storage card inserted  
011f			;     0000 0010  spi sd card active  
011f			  
011f			;       
011f			; low byte:  
011f			;     0000 0001   4x4 keypad  
011f			;     0000 0010   full keyboard  
011f			;     0000 0011   spi/ext keyboard  
011f			;     0000 0100   20x4 lcd  
011f			;     0000 1000   40x4 lcd  
011f			;     0000 1100   spi/ext display  
011f			;     0001 0000   ide interface available  
011f			  
011f			hardware_word: equ hardware_config - 2  
011f			  
011f			; debug marker - optional display of debug point on the debug screens  
011f			  
011f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011f			  
011f			debug_mark: equ debug_vector - 4  
011f			  
011f			; input_str vars  
011f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011f			input_size: equ input_start -1  ; number of chars  
011f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011f			input_len: equ input_cur_onoff - 5 ; length of current input  
011f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011f			  
011f			; cursor blink rate  
011f			CUR_BLINK_RATE: equ $09  
011f			;CUR_BLINK_RATE: equ 15  
011f			  
011f			key_actual_pressed: equ input_cursor - 1   
011f			key_symbol: equ key_actual_pressed - 1   
011f			key_shift: equ key_symbol - 1   
011f			  
011f			; Display allocation  
011f			  
011f			;display_rows: equ 4     ; move out to mini and mega files  
011f			;display_cols: equ 20  
011f			  
011f			display_fb_len: equ display_rows*display_cols  
011f			  
011f			; primary frame buffer     
011f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011f			; working frame buffers  
011f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011f			display_fb3: equ  display_fb1-display_fb_len - 1  
011f			display_fb2: equ  display_fb3-display_fb_len - 1  
011f			;  
011f			; pointer to active frame buffer  
011f			display_fb_active: equ display_fb2 - 2  
011f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011f			display_write_tmp: equ display_lcde1e2 - 2  
011f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011f			  
011f			;  
011f			  
011f			;; can load into de directory  
011f			cursor_col: equ display_active-1  
011f			cursor_row: equ cursor_col-1  
011f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011f			  
011f			; maths vars  
011f			  
011f			LFSRSeed: equ cursor_shape -20   
011f			randData: equ LFSRSeed - 2  
011f			xrandc: equ randData - 2  
011f			stackstore: equ xrandc - 2  
011f			seed1: equ  stackstore -2   
011f			seed2: equ seed1 - 2  
011f			  
011f			; cf storage vars  
011f			  
011f			iErrorNum:  equ seed2-1         ;Error number  
011f			iErrorReg:  equ iErrorNum -1              ;Error register  
011f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011f			  
011f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011f			  
011f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011f			  
011f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011f			store_tmpid: equ store_tmp3 - 1		; page temp id  
011f			store_tmpext: equ store_tmpid - 1		; file extent temp  
011f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011f			;  
011f			; spi vars  
011f			  
011f			  
011f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011f			spi_device_id: equ spi_device - 1    ; human readable bank number  
011f			  
011f			;;;;; forth cli params  
011f			  
011f			; TODO use a different frame buffer for forth???  
011f			  
011f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011f			  
011f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011f			  
011f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011f			  
011f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011f			  
011f			; os/forth token vars  
011f			  
011f			os_last_cmd: equ os_var_array-255  
011f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011f			os_current_i: equ os_cli_cmd-2  
011f			os_cur_ptr: equ os_current_i-2  
011f			os_word_scratch: equ os_cur_ptr-30  
011f			os_tok_len: equ os_word_scratch - 2  
011f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011f			os_tok_malloc: equ os_tok_ptr - 2  
011f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011f			execscratch: equ os_input-255        ; exec cmd eval buffer  
011f			scratch: equ execscratch-255  
011f			  
011f			os_stack_1: equ scratch - 3       ; stack holding area 1  
011f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011f			  
011f			  
011f			; temp locations for new word processing to save on adding more   
011f			  
011f			os_new_malloc: equ os_stack_4-2  
011f			os_new_parse_len: equ os_new_malloc - 2  
011f			os_new_word_len: equ os_new_parse_len - 2  
011f			os_new_work_ptr: equ os_new_word_len - 2  
011f			os_new_src_ptr: equ os_new_work_ptr - 2  
011f			os_new_exec: equ os_new_src_ptr - 2  
011f			os_new_exec_ptr: equ os_new_exec - 2  
011f			  
011f			; resume memory alloocations....  
011f			  
011f			;os_view_disable: equ os_new_exec_ptr - 1  
011f			os_view_af: equ os_new_exec_ptr - 2  
011f			os_view_hl: equ os_view_af -2  
011f			os_view_de: equ os_view_hl - 2  
011f			os_view_bc: equ os_view_de - 2  
011f			  
011f			; stack checksum word  
011f			if DEBUG_STACK_IMB  
011f				curframe: equ  os_view_de - 5  
011f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			else  
011f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			endif  
011f			  
011f			; with data stack could see memory filled with junk. need some memory management   
011f			; malloc and free entry points added  
011f			  
011f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			;heap_end: equ free_list-1  ; Starting address of heap  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			heap_end: equ chk_word-1  ; Starting address of heap  
011f			  
011f			  
011f			;if BASE_KEV   
011f			;heap_start: equ 0800eh  ; Starting address of heap  
011f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;heap_start: equ baseram+15  ; Starting address of heap  
011f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;endif  
011f			  
011f			  
011f			;;;;  
011f			  
011f			  
011f			; change below to point to last memory alloc above  
011f			topusermem:  equ   heap_start  
011f			  
011f			;if BASE_KEV   
011f			;baseusermem: equ 08000h  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;;aseusermem:     equ    12  
011f			;baseusermem:     equ    prompt  
011f			;;baseusermem:     equ    endofcode  
011f			;endif  
011f			  
011f			  
011f			; **********************************************************************  
011f			; **  Constants  
011f			; **********************************************************************  
011f			  
011f			; Constants used by this code module  
011f			kDataReg:   EQU Device_D           ;PIO port A data register  
011f			kContReg:   EQU Device_D+2           ;PIO port A control register  
011f			  
011f			  
011f			portbdata:  equ Device_D+1    ; port b data  
011f			portbctl:   equ Device_D+3    ; port b control  
011f			  
011f			  
011f			;KEY_SHIFT:   equ 5  
011f			;KEY_SYMBOLSHIFT:  equ 6  
011f			  
011f			KEY_SHIFTLOCK: equ 4  
011f			  
011f			  
011f			KEY_UP: equ 5  
011f			KEY_NEXTWORD: equ 6  
011f			KEY_PREVWORD: equ 7  
011f			KEY_BS: equ 8  
011f			KEY_TAB:  equ 9  
011f			KEY_DOWN: equ 10  
011f			KEY_LEFT: equ 11  
011f			KEY_RIGHT: equ 12  
011f			KEY_CR:   equ 13  
011f			KEY_HOME: equ 14  
011f			KEY_END: equ 15  
011f			  
011f			KEY_F1: equ 16  
011f			KEY_F2: equ 17  
011f			KEY_F3: equ 18  
011f			KEY_F4: equ 19  
011f			  
011f			KEY_F5: equ 20  
011f			KEY_F6: equ 21  
011f			KEY_F7: equ 22  
011f			KEY_F8: equ 23  
011f			  
011f			KEY_F9: equ 24  
011f			KEY_F10: equ 25  
011f			KEY_F11: equ 26  
011f			KEY_F12: equ 27  
011f			  
011f			;if DEBUG_KEY  
011f			;	KEY_MATRIX_NO_PRESS: equ '.'  
011f			;	KEY_SHIFT:   equ '.'  
011f			;	KEY_SYMBOLSHIFT:  equ '.'  
011f			;else  
011f				KEY_SHIFT:   equ '~'  
011f				KEY_SYMBOLSHIFT:  equ '~'  
011f				KEY_MATRIX_NO_PRESS: equ '~'  
011f			;endi  
011f			  
011f			  
011f			  
011f			  
011f			; Macro to make adding debug marks easier  
011f			  
011f			DMARK: macro str  
011f				push af  
011f				ld a, (.dmark)  
011f				ld (debug_mark),a  
011f				ld a, (.dmark+1)  
011f				ld (debug_mark+1),a  
011f				ld a, (.dmark+2)  
011f				ld (debug_mark+2),a  
011f				jr .pastdmark  
011f			.dmark: db str  
011f			.pastdmark: pop af  
011f			  
011f			endm  
011f			  
011f			  
011f			; macro to detect for stack imbalances  
011f			  
011f			include "stackimbal.asm"  
011f			; Macro and code to detect stock imbalances 
011f			 
011f			SPPUSH: equ 0 
011f			 
011f			; Add a stack frame which can be checked before return 
011f			 
011f			STACKFRAME: macro onoff frame1 frame2 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f						exx 
011f			 
011f						ld de, frame1 
011f						ld a, d 
011f						ld hl, curframe 
011f						call hexout 
011f						ld a, e 
011f						ld hl, curframe+2 
011f						call hexout 
011f			  
011f						ld hl, frame1 
011f						push hl 
011f						ld hl, frame2 
011f						push hl 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			endm 
011f			 
011f			STACKFRAMECHK: macro onoff frame1 frame2 
011f			 
011f					 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						exx 
011f						; check stack frame SP 
011f			 
011f						ld hl, frame2 
011f						pop de   ; frame2 
011f			 
011f						call cmp16 
011f						jr nz, .spnosame 
011f						 
011f			 
011f						ld hl, frame1 
011f						pop de   ; frame1 
011f			 
011f						call cmp16 
011f						jr z, .spfrsame 
011f			 
011f						.spnosame: call showsperror 
011f			 
011f						.spfrsame: nop 
011f			 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			 
011f			 
011f			endm 
011f			 
011f			 
011f			; for a sub routine, wrap SP collection and comparisons 
011f			 
011f			; Usage: 
011f			; 
011f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011f			 
011f			SAVESP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f			 
011f						ld (store_sp+(storeword*4)), sp 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			CHECKSP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f			 
011f						; save SP after last save 
011f				 
011f						ld (store_sp+(storeword*4)+2), sp 
011f			 
011f						push hl 
011f						ld hl, store_sp+(storeword*4) 
011f						call check_stack_sp  
011f						pop hl 
011f			 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			if DEBUG_STACK_IMB 
011f			 
011f			check_stack_sp: 
011f					push de 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					push de 
011f			 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					pop hl 
011f			 
011f			 
011f					; check to see if the same 
011f			 
011f					call cmp16 
011f					jr z, .spsame 
011f			 
011f					; not same 
011f			 
011f					call showsperror 
011f			.spsame: 
011f			 
011f					pop de 
011f			 
011f					ret 
011f			 
011f			.sperr:  db "Stack imbalance",0 
011f			 
011f			 
011f			showsperror: 
011f			 
011f			 
011f				push hl 
011f				push af 
011f				push de 
011f				call clear_display 
011f				ld de, .sperr 
011f				ld a,0 
011f			;	ld de,os_word_scratch 
011f				call str_at_display 
011f				ld a, display_row_1+17 
011f				ld de, debug_mark 
011f				call str_at_display 
011f				ld a, 0 
011f				ld (curframe+4),a 
011f				ld hl, curframe 
011f				ld de, os_word_scratch 
011f				ld a, display_row_4 
011f				call str_at_display 
011f				call update_display 
011f				;call break_point_state 
011f				call cin_wait 
011f			 
011f			;	ld a, ' ' 
011f			;	ld (os_view_disable), a 
011f				call bp_on 
011f				pop de	 
011f				pop af 
011f				pop hl 
011f				CALLMONITOR 
011f				ret 
011f			 
011f			endif 
011f			 
011f			 
011f			 
011f			; eof 
# End of file stackimbal.asm
011f			  
011f			;TODO macro to calc col and row offset into screen  
011f			  
011f			  
011f			  
011f			hardware_init:  
011f			  
011f				  
011f			  
011f					;ld a, 0  
011f					;ld (hardware_diag), a  
011f			  
011f					; clear all the buffers  
011f			  
011f 21 10 ed				ld hl, display_fb1  
0122 22 cc eb				ld (display_fb_active), hl  
0125			  
0125 cd c5 0b				call clear_display  
0128			  
0128 21 ce eb				ld hl, display_fb2  
012b 22 cc eb				ld (display_fb_active), hl  
012e			  
012e cd c5 0b				call clear_display  
0131			  
0131					; init primary frame buffer area  
0131 21 b1 ed				ld hl, display_fb0  
0134 22 cc eb				ld (display_fb_active), hl  
0137			  
0137 cd c5 0b				call clear_display  
013a			  
013a			  
013a cd 85 5d				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013d			  
013d cd 73 5e			call key_init  
0140 cd aa 01			call storage_init  
0143			  
0143				; setup malloc functions  
0143			  
0143				if MALLOC_1  
0143 cd a9 11				call  heap_init  
0146				endif  
0146				if MALLOC_4  
0146					call  heap_init  
0146				endif  
0146			  
0146				; init sound hardware if present  
0146			  
0146				if SOUND_ENABLE  
0146					call sound_init  
0146				endif  
0146			  
0146				; lcd test sequence  
0146					  
0146 cd e8 0b			call update_display  
0149 cd fd 0a			call delay1s  
014c 3e 2b			ld a,'+'  
014e cd ca 0b			call fill_display  
0151 cd e8 0b			call update_display  
0154 cd fd 0a			call delay1s  
0157 3e 2a			ld a,'*'  
0159 cd ca 0b			call fill_display  
015c cd e8 0b			call update_display  
015f cd fd 0a			call delay1s  
0162 3e 2d			ld a,'-'  
0164 cd ca 0b			call fill_display  
0167 cd e8 0b			call update_display  
016a cd fd 0a			call delay1s  
016d			  
016d			; boot splash screen  
016d			if display_cols == 20	  
016d			        ld a, display_row_1    
016d			else  
016d 3e 0a		        ld a, display_row_1 +10   
016f			endif  
016f 11 d7 16			ld de, prom_bootmsg  
0172 cd d8 0b			call str_at_display  
0175 cd e8 0b			call update_display  
0178			  
0178			  
0178 cd fd 0a			call delay1s  
017b cd fd 0a			call delay1s  
017e			if display_cols == 20	  
017e			            LD   A, display_row_3+2  
017e			else  
017e 3e 5c		            LD   A, display_row_3+12  
0180			endif  
0180 11 ec 16			ld de, prom_bootmsg1  
0183 cd d8 0b			call str_at_display  
0186			; display debug level  
0186 3e 78		            LD   A, display_row_4  
0188 11 1b 01			ld de, debuglevel  
018b cd d8 0b			call str_at_display  
018e			  
018e cd e8 0b			call update_display  
0191 cd fd 0a			call delay1s  
0194 cd fd 0a			call delay1s  
0197			  
0197			;	ld a, display_row_4+3  
0197			;	ld de, bootmsg2  
0197			;	call str_at_display  
0197			;	call update_display  
0197			;	call delay1s  
0197			;	call delay1s  
0197			  
0197			; debug mark setup  
0197			  
0197 3e 5f		ld a, '_'  
0199 32 6b ee		ld (debug_mark),a  
019c 32 6c ee		ld (debug_mark+1),a  
019f 32 6d ee		ld (debug_mark+2),a  
01a2 3e 00		ld a,0  
01a4 32 6e ee		ld (debug_mark+3),a  
01a7			  
01a7 c9					ret  
01a8			  
01a8			  
01a8			;bootmsg2:	db "Firmware v0.1",0  
01a8			  
01a8			; a 4x20 lcd  
01a8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01a8			  
01a8			;if display_cols == 20  
01a8			;	include "firmware_lcd_4x20.asm"  
01a8			;endif  
01a8			  
01a8			;if display_cols == 40  
01a8			;	include "firmware_lcd_4x40.asm"  
01a8			;endif  
01a8			  
01a8			;  
01a8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01a8			; TODO abstract the bit bang video out interface for dual display  
01a8			; TODO wire video out to tx pin on rc2014 bus  
01a8			  
01a8			; must supply cin, and cin_wait for low level hardware abstraction   
01a8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01a8			; test scancode  
01a8			  
01a8			;;;;;  
01a8			;;;  
01a8			; Moved out to mini and maxi versions  
01a8			;  
01a8			; include "firmware_key_4x4.asm"  
01a8			; using existing 4 wire x 4 resistor array for input  
01a8			;include "firmware_key_4x10.asm"  
01a8			; need to mod the board for 5 rows due to resistor array  
01a8			;include "firmware_key_5x10.asm"  
01a8			  
01a8			; storage hardware interface  
01a8			  
01a8			; use microchip serial eeprom for storage  
01a8			  
01a8			  
01a8			if STORAGE_SE  
01a8				include "firmware_spi.asm"  
01a8				include "firmware_seeprom.asm"  
01a8			else  
01a8			   ; create some stubs for the labels  
01a8 c9			se_readbyte: ret  
01a9 c9			se_writebyte: ret  
01aa c9			storage_init: ret  
01ab			  
01ab			endif  
01ab			  
01ab			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01ab			;include "firmware_cf.asm"  
01ab			  
01ab			; load up high level storage hardward abstractions  
01ab			include "firmware_storage.asm"  
01ab			 
01ab			; persisent storage hardware abstraction layer  
01ab			 
01ab			 
01ab			 
01ab			; Block 0 on storage is a config state 
01ab			 
01ab			 
01ab			 
01ab			; TODO add read phy block and write phy block functions 
01ab			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01ab			 
01ab			; Abstraction layer  
01ab			 
01ab			; Logocial block size is same size as physical size - using tape concept 
01ab			 
01ab			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01ab			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01ab			 
01ab			 
01ab			 
01ab			; Filesystem layout (Logical layout) 
01ab			; 
01ab			; Block 0 - Bank config  
01ab			; 
01ab			;      Byte - 0 file id counter 
01ab			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01ab			;      Byte - 3-20 zero terminated bank label 
01ab			; 
01ab			; Block 1 > File storage 
01ab			; 
01ab			;      Byte 0 file id    - block 0 file details 
01ab			;      Byte 1 block id - block 0 is file  
01ab			;            Byte 2-15 - File name 
01ab			; 
01ab			;       - to end of block data 
01ab			; 
01ab			 
01ab			; Get ID for the file named in pointer held HL 
01ab			; Returns ID in HL = 255 if no file found 
01ab			 
01ab			storage_getid: 
01ab			 
01ab 22 73 ea			ld (store_tmp1), hl 
01ae			 
01ae				if DEBUG_STORESE 
01ae					DMARK "SGI" 
01ae f5				push af  
01af 3a c3 01			ld a, (.dmark)  
01b2 32 6b ee			ld (debug_mark),a  
01b5 3a c4 01			ld a, (.dmark+1)  
01b8 32 6c ee			ld (debug_mark+1),a  
01bb 3a c5 01			ld a, (.dmark+2)  
01be 32 6d ee			ld (debug_mark+2),a  
01c1 18 03			jr .pastdmark  
01c3 ..			.dmark: db "SGI"  
01c6 f1			.pastdmark: pop af  
01c7			endm  
# End of macro DMARK
01c7					CALLMONITOR 
01c7 cd 6f ee			call debug_vector  
01ca				endm  
# End of macro CALLMONITOR
01ca				endif 
01ca				; get block 0 and set counter for number of files to scan 
01ca			 
01ca cd 35 03			call storage_get_block_0 
01cd			 
01cd 3a 7a ea			ld a, (store_page) 
01d0 47				ld b, a 
01d1			 
01d1				; get extent 0 of each file id 
01d1			 
01d1				if DEBUG_STORESE 
01d1					DMARK "SGc" 
01d1 f5				push af  
01d2 3a e6 01			ld a, (.dmark)  
01d5 32 6b ee			ld (debug_mark),a  
01d8 3a e7 01			ld a, (.dmark+1)  
01db 32 6c ee			ld (debug_mark+1),a  
01de 3a e8 01			ld a, (.dmark+2)  
01e1 32 6d ee			ld (debug_mark+2),a  
01e4 18 03			jr .pastdmark  
01e6 ..			.dmark: db "SGc"  
01e9 f1			.pastdmark: pop af  
01ea			endm  
# End of macro DMARK
01ea					CALLMONITOR 
01ea cd 6f ee			call debug_vector  
01ed				endm  
# End of macro CALLMONITOR
01ed				endif 
01ed 60			.getloop:	ld h, b 
01ee 2e 00				ld l, 0 
01f0 c5					push bc 
01f1			 
01f1 11 7a ea				ld de, store_page 
01f4				if DEBUG_STORESE 
01f4					DMARK "SGr" 
01f4 f5				push af  
01f5 3a 09 02			ld a, (.dmark)  
01f8 32 6b ee			ld (debug_mark),a  
01fb 3a 0a 02			ld a, (.dmark+1)  
01fe 32 6c ee			ld (debug_mark+1),a  
0201 3a 0b 02			ld a, (.dmark+2)  
0204 32 6d ee			ld (debug_mark+2),a  
0207 18 03			jr .pastdmark  
0209 ..			.dmark: db "SGr"  
020c f1			.pastdmark: pop af  
020d			endm  
# End of macro DMARK
020d					CALLMONITOR 
020d cd 6f ee			call debug_vector  
0210				endm  
# End of macro CALLMONITOR
0210				endif 
0210 cd dd 07				call storage_read 
0213 cd 1b 0e				call ishlzero 
0216 28 2d				jr z, .gap 
0218					 
0218					; have a file name read. Is it one we want. 
0218			 
0218 2a 73 ea				ld hl, (store_tmp1) 
021b 11 7d ea				ld de, store_page+3   ; file name 
021e			 
021e				if DEBUG_STORESE 
021e					DMARK "SGc" 
021e f5				push af  
021f 3a 33 02			ld a, (.dmark)  
0222 32 6b ee			ld (debug_mark),a  
0225 3a 34 02			ld a, (.dmark+1)  
0228 32 6c ee			ld (debug_mark+1),a  
022b 3a 35 02			ld a, (.dmark+2)  
022e 32 6d ee			ld (debug_mark+2),a  
0231 18 03			jr .pastdmark  
0233 ..			.dmark: db "SGc"  
0236 f1			.pastdmark: pop af  
0237			endm  
# End of macro DMARK
0237					CALLMONITOR 
0237 cd 6f ee			call debug_vector  
023a				endm  
# End of macro CALLMONITOR
023a				endif 
023a cd 90 11				call strcmp 
023d 20 06				jr nz, .gap   ; not this one 
023f			 
023f c1				        pop bc 
0240			 
0240 26 00				ld h, 0 
0242 68					ld l, b 
0243 18 22				jr .getdone 
0245						 
0245			 
0245			 
0245			 
0245			.gap: 
0245				if DEBUG_STORESE 
0245					DMARK "SGg" 
0245 f5				push af  
0246 3a 5a 02			ld a, (.dmark)  
0249 32 6b ee			ld (debug_mark),a  
024c 3a 5b 02			ld a, (.dmark+1)  
024f 32 6c ee			ld (debug_mark+1),a  
0252 3a 5c 02			ld a, (.dmark+2)  
0255 32 6d ee			ld (debug_mark+2),a  
0258 18 03			jr .pastdmark  
025a ..			.dmark: db "SGg"  
025d f1			.pastdmark: pop af  
025e			endm  
# End of macro DMARK
025e					CALLMONITOR 
025e cd 6f ee			call debug_vector  
0261				endm  
# End of macro CALLMONITOR
0261				endif 
0261			 
0261 c1					pop bc 
0262 10 89				djnz .getloop 
0264 21 ff 00				ld hl, 255 
0267			.getdone: 
0267			 
0267				if DEBUG_STORESE 
0267					DMARK "SGe" 
0267 f5				push af  
0268 3a 7c 02			ld a, (.dmark)  
026b 32 6b ee			ld (debug_mark),a  
026e 3a 7d 02			ld a, (.dmark+1)  
0271 32 6c ee			ld (debug_mark+1),a  
0274 3a 7e 02			ld a, (.dmark+2)  
0277 32 6d ee			ld (debug_mark+2),a  
027a 18 03			jr .pastdmark  
027c ..			.dmark: db "SGe"  
027f f1			.pastdmark: pop af  
0280			endm  
# End of macro DMARK
0280					CALLMONITOR 
0280 cd 6f ee			call debug_vector  
0283				endm  
# End of macro CALLMONITOR
0283				endif 
0283			 
0283 c9				ret 
0284			 
0284			 
0284			 
0284			 
0284			 
0284			 
0284			 
0284			 
0284			; Read Block 
0284			; ---------- 
0284			; 
0284			; With current bank 
0284			;  
0284			; Get block number to read 
0284			; Load physical blocks starting at start block into buffer 
0284			 
0284			; de points to buffer to use 
0284			; hl holds logical block number  
0284			 
0284			storage_read_block: 
0284			 
0284				; TODO bank selection 
0284			 
0284				; for each of the physical blocks read it into the buffer 
0284 06 40			ld b, STORE_BLOCK_PHY 
0286			 
0286				if DEBUG_STORESE 
0286 d5					push de 
0287				endif 
0287				 
0287			.rl1:    
0287			 
0287				; read physical block at hl into de 
0287			        ; increment hl and de to next read position on exit 
0287			 
0287 e5				push hl 
0288 d5				push de	 
0289 c5				push bc 
028a			;	if DEBUG_STORESE 
028a			;		push af 
028a			;		ld a, 'R' 
028a			;		ld (debug_mark),a 
028a			;		pop af 
028a			;		CALLMONITOR 
028a			;	endif 
028a cd a8 01			call se_readbyte 
028d			;	if DEBUG_STORESE 
028d			;		ld a,(spi_portbyte) 
028d			;		ld l, a 
028d			;		push af 
028d			;		ld a, '1' 
028d			;		ld (debug_mark),a 
028d			;		pop af 
028d			;		CALLMONITOR 
028d			;	endif 
028d c1				pop bc 
028e d1				pop de 
028f e1				pop hl 
0290 12				ld (de),a 
0291 23				inc hl 
0292 13				inc de 
0293			 
0293			;	if DEBUG_STORESE 
0293			;		push af 
0293			;		ld a, 'r' 
0293			;		ld (debug_mark),a 
0293			;		pop af 
0293			;		CALLMONITOR 
0293			;	endif 
0293			 
0293 10 f2			djnz .rl1 
0295			 
0295				if DEBUG_STORESE 
0295					DMARK "SRB" 
0295 f5				push af  
0296 3a aa 02			ld a, (.dmark)  
0299 32 6b ee			ld (debug_mark),a  
029c 3a ab 02			ld a, (.dmark+1)  
029f 32 6c ee			ld (debug_mark+1),a  
02a2 3a ac 02			ld a, (.dmark+2)  
02a5 32 6d ee			ld (debug_mark+2),a  
02a8 18 03			jr .pastdmark  
02aa ..			.dmark: db "SRB"  
02ad f1			.pastdmark: pop af  
02ae			endm  
# End of macro DMARK
02ae d1					pop de 
02af			; 
02af			;		push af 
02af			;		ld a, 'R' 
02af			;		ld (debug_mark),a 
02af			;		pop af 
02af					CALLMONITOR 
02af cd 6f ee			call debug_vector  
02b2				endm  
# End of macro CALLMONITOR
02b2				endif 
02b2 c9				ret	 
02b3				 
02b3			 
02b3			; File Size 
02b3			; --------- 
02b3			; 
02b3			;   hl file id 
02b3			; 
02b3			;  returns in hl the number of blocks 
02b3			 
02b3			storage_file_size: 
02b3 5d				ld e, l 
02b4 16 00			ld d, 0 
02b6 21 40 00			ld hl, STORE_BLOCK_PHY 
02b9					if DEBUG_FORTH_WORDS 
02b9						DMARK "SIZ" 
02b9 f5				push af  
02ba 3a ce 02			ld a, (.dmark)  
02bd 32 6b ee			ld (debug_mark),a  
02c0 3a cf 02			ld a, (.dmark+1)  
02c3 32 6c ee			ld (debug_mark+1),a  
02c6 3a d0 02			ld a, (.dmark+2)  
02c9 32 6d ee			ld (debug_mark+2),a  
02cc 18 03			jr .pastdmark  
02ce ..			.dmark: db "SIZ"  
02d1 f1			.pastdmark: pop af  
02d2			endm  
# End of macro DMARK
02d2						CALLMONITOR 
02d2 cd 6f ee			call debug_vector  
02d5				endm  
# End of macro CALLMONITOR
02d5					endif 
02d5 cd b7 05			call storage_findnextid 
02d8			 
02d8 cd 1b 0e			call ishlzero 
02db			;	ld a, l 
02db			;	add h 
02db			;	cp 0 
02db c8				ret z			; block not found so EOF 
02dc			 
02dc 11 7a ea			ld de, store_page 
02df cd 84 02			call storage_read_block 
02e2			 
02e2 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02e5 6f				ld l, a 
02e6 26 00			ld h, 0 
02e8 c9			 	ret 
02e9			 
02e9			 
02e9			; Write Block 
02e9			; ----------- 
02e9			; 
02e9			; With current bank 
02e9			;  
02e9			; Get block number to write 
02e9			; Write physical blocks starting at start block from buffer 
02e9			  
02e9			storage_write_block: 
02e9				; TODO bank selection 
02e9			 
02e9				; for each of the physical blocks read it into the buffer 
02e9 06 40			ld b, STORE_BLOCK_PHY 
02eb			 
02eb				if DEBUG_STORESE 
02eb					DMARK "SWB" 
02eb f5				push af  
02ec 3a 00 03			ld a, (.dmark)  
02ef 32 6b ee			ld (debug_mark),a  
02f2 3a 01 03			ld a, (.dmark+1)  
02f5 32 6c ee			ld (debug_mark+1),a  
02f8 3a 02 03			ld a, (.dmark+2)  
02fb 32 6d ee			ld (debug_mark+2),a  
02fe 18 03			jr .pastdmark  
0300 ..			.dmark: db "SWB"  
0303 f1			.pastdmark: pop af  
0304			endm  
# End of macro DMARK
0304			 
0304					;push af 
0304					;ld a, 'W' 
0304					;ld (debug_mark),a 
0304					;pop af 
0304					CALLMONITOR 
0304 cd 6f ee			call debug_vector  
0307				endm  
# End of macro CALLMONITOR
0307				endif 
0307			 
0307			; might not be working 
0307			;	call se_writepage 
0307			 
0307			;	ret 
0307			; 
0307			 
0307			 
0307			 
0307			.wl1:    
0307			 
0307				; read physical block at hl into de 
0307			        ; increment hl and de to next read position on exit 
0307			 
0307 e5				push hl 
0308 d5				push de	 
0309 c5				push bc 
030a 1a				ld a,(de) 
030b				;if DEBUG_STORESE 
030b			;		push af 
030b			;		ld a, 'W' 
030b			;		ld (debug_mark),a 
030b			;		pop af 
030b			;		CALLMONITOR 
030b			;	endif 
030b cd a9 01			call se_writebyte 
030e			;	call delay250ms 
030e 00				nop 
030f 00				nop 
0310 00				nop 
0311			;	if DEBUG_STORESE 
0311			;		push af 
0311			;		ld a, 'w' 
0311			;		ld (debug_mark),a 
0311			;		pop af 
0311			;		CALLMONITOR 
0311			;	endif 
0311 c1				pop bc 
0312 d1				pop de 
0313 e1				pop hl 
0314 23				inc hl 
0315 13				inc de 
0316			 
0316			 
0316 10 ef			djnz .wl1 
0318			 
0318				if DEBUG_STORESE 
0318					DMARK "SW2" 
0318 f5				push af  
0319 3a 2d 03			ld a, (.dmark)  
031c 32 6b ee			ld (debug_mark),a  
031f 3a 2e 03			ld a, (.dmark+1)  
0322 32 6c ee			ld (debug_mark+1),a  
0325 3a 2f 03			ld a, (.dmark+2)  
0328 32 6d ee			ld (debug_mark+2),a  
032b 18 03			jr .pastdmark  
032d ..			.dmark: db "SW2"  
0330 f1			.pastdmark: pop af  
0331			endm  
# End of macro DMARK
0331			 
0331					;push af 
0331					;ld a, 'W' 
0331					;ld (debug_mark),a 
0331					;pop af 
0331					CALLMONITOR 
0331 cd 6f ee			call debug_vector  
0334				endm  
# End of macro CALLMONITOR
0334				endif 
0334 c9				ret	 
0335			 
0335			; Init bank 
0335			; --------- 
0335			; 
0335			; With current bank 
0335			; 
0335			; Setup block 0 config 
0335			;     Set 0 file id counter 
0335			;     Set formatted byte pattern 
0335			;     Zero out bank label 
0335			;      
0335			; For every logical block write 0-1 byte as null 
0335			 
0335			storage_get_block_0: 
0335			 
0335				; TODO check presence 
0335			 
0335				; get block 0 config 
0335			 
0335 21 00 00			ld hl, 0 
0338 11 7a ea			ld de, store_page 
033b cd 84 02			call storage_read_block 
033e			 
033e				if DEBUG_STORESE 
033e					DMARK "SB0" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 6b ee			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 6c ee			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 6d ee			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SB0"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357 11 7a ea				ld de, store_page 
035a			;		push af 
035a			;		ld a, 'i' 
035a			;		ld (debug_mark),a 
035a			;		pop af 
035a					CALLMONITOR 
035a cd 6f ee			call debug_vector  
035d				endm  
# End of macro CALLMONITOR
035d				endif 
035d			 
035d				; is this area formatted? 
035d			 
035d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
035d 2a 7b ea			ld hl, (store_page+1) 
0360 3e 80			ld a,0x80 
0362 bd				cp l 
0363 20 22			jr nz, .ininotformatted 
0365				; do a double check 
0365 3e 27			ld a, 0x27 
0367 bc				cp h 
0368 20 1d			jr nz, .ininotformatted 
036a			 
036a				; formatted then 
036a			 
036a				if DEBUG_STORESE 
036a					DMARK "SB1" 
036a f5				push af  
036b 3a 7f 03			ld a, (.dmark)  
036e 32 6b ee			ld (debug_mark),a  
0371 3a 80 03			ld a, (.dmark+1)  
0374 32 6c ee			ld (debug_mark+1),a  
0377 3a 81 03			ld a, (.dmark+2)  
037a 32 6d ee			ld (debug_mark+2),a  
037d 18 03			jr .pastdmark  
037f ..			.dmark: db "SB1"  
0382 f1			.pastdmark: pop af  
0383			endm  
# End of macro DMARK
0383					;push af 
0383					;ld a, 'I' 
0383					;ld (debug_mark),a 
0383					;pop af 
0383					CALLMONITOR 
0383 cd 6f ee			call debug_vector  
0386				endm  
# End of macro CALLMONITOR
0386				endif 
0386 c9				ret 
0387			 
0387			.ininotformatted: 
0387				; bank not formatted so poke various bits to make sure 
0387			 
0387				if DEBUG_STORESE 
0387					DMARK "SB2" 
0387 f5				push af  
0388 3a 9c 03			ld a, (.dmark)  
038b 32 6b ee			ld (debug_mark),a  
038e 3a 9d 03			ld a, (.dmark+1)  
0391 32 6c ee			ld (debug_mark+1),a  
0394 3a 9e 03			ld a, (.dmark+2)  
0397 32 6d ee			ld (debug_mark+2),a  
039a 18 03			jr .pastdmark  
039c ..			.dmark: db "SB2"  
039f f1			.pastdmark: pop af  
03a0			endm  
# End of macro DMARK
03a0					;push af 
03a0					;ld a, 'f' 
03a0					;ld (debug_mark),a 
03a0					;pop af 
03a0					CALLMONITOR 
03a0 cd 6f ee			call debug_vector  
03a3				endm  
# End of macro CALLMONITOR
03a3				endif 
03a3			 
03a3 cd c0 0a			call storage_clear_page 
03a6			 
03a6 21 7a ea			ld hl, store_page 
03a9 3e 00			ld a, 0 
03ab				 
03ab 77				ld (hl),a   ; reset file counter 
03ac			 
03ac 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03af 22 7b ea		 	ld (store_page+1), hl	 
03b2			 
03b2				; set default label 
03b2			 
03b2 21 4e 04			ld hl, .defaultbanklabl 
03b5 11 7d ea		 	ld de, store_page+3 
03b8 01 0f 00			ld bc, 15 
03bb ed b0			ldir 
03bd			 
03bd				; Append the current bank id 
03bd 21 86 ea			ld hl, store_page+3+9 
03c0 3a 5f ea			ld a, (spi_device_id) 
03c3 77				ld (hl), a 
03c4			 
03c4				; save default page 0 
03c4			 
03c4 21 00 00			ld hl, 0 
03c7 11 7a ea			ld de, store_page 
03ca				if DEBUG_STORESE 
03ca					DMARK "SB3" 
03ca f5				push af  
03cb 3a df 03			ld a, (.dmark)  
03ce 32 6b ee			ld (debug_mark),a  
03d1 3a e0 03			ld a, (.dmark+1)  
03d4 32 6c ee			ld (debug_mark+1),a  
03d7 3a e1 03			ld a, (.dmark+2)  
03da 32 6d ee			ld (debug_mark+2),a  
03dd 18 03			jr .pastdmark  
03df ..			.dmark: db "SB3"  
03e2 f1			.pastdmark: pop af  
03e3			endm  
# End of macro DMARK
03e3			;		push af 
03e3			;		ld a, 'F' 
03e3			;		ld (debug_mark),a 
03e3			;		pop af 
03e3					CALLMONITOR 
03e3 cd 6f ee			call debug_vector  
03e6				endm  
# End of macro CALLMONITOR
03e6				endif 
03e6 cd e9 02			call storage_write_block 
03e9				if DEBUG_STORESE 
03e9					DMARK "SB4" 
03e9 f5				push af  
03ea 3a fe 03			ld a, (.dmark)  
03ed 32 6b ee			ld (debug_mark),a  
03f0 3a ff 03			ld a, (.dmark+1)  
03f3 32 6c ee			ld (debug_mark+1),a  
03f6 3a 00 04			ld a, (.dmark+2)  
03f9 32 6d ee			ld (debug_mark+2),a  
03fc 18 03			jr .pastdmark  
03fe ..			.dmark: db "SB4"  
0401 f1			.pastdmark: pop af  
0402			endm  
# End of macro DMARK
0402			;		push af 
0402			;		ld a, '>' 
0402			;		ld (debug_mark),a 
0402			;		pop af 
0402					CALLMONITOR 
0402 cd 6f ee			call debug_vector  
0405				endm  
# End of macro CALLMONITOR
0405				endif 
0405			 
0405 00				nop 
0406 00				nop 
0407 00				nop 
0408			 
0408				; now set 0 in every page to mark as a free block 
0408			 
0408 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
040a 21 40 00			ld hl, STORE_BLOCK_PHY 
040d			 
040d 3e 00		.setmark1:   	ld a,0 
040f e5					push hl 
0410 c5					push bc 
0411 cd a9 01				call se_writebyte 
0414 3e 0a			ld a, 10 
0416 cd e2 0a			call aDelayInMS 
0419 23				inc hl 
041a cd a9 01				call se_writebyte 
041d 3e 0a			ld a, 10 
041f cd e2 0a			call aDelayInMS 
0422 2b				dec hl 
0423 c1					pop bc 
0424 e1					pop hl 
0425 3e 40				ld a, STORE_BLOCK_PHY 
0427 cd f2 0d				call addatohl 
042a 10 e1				djnz .setmark1 
042c			 
042c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
042e 3e 00		.setmark2:   	ld a,0 
0430 e5					push hl 
0431 c5					push bc 
0432 cd a9 01				call se_writebyte 
0435 3e 0a			ld a, 10 
0437 cd e2 0a			call aDelayInMS 
043a 23				inc hl 
043b cd a9 01				call se_writebyte 
043e 3e 0a			ld a, 10 
0440 cd e2 0a			call aDelayInMS 
0443 2b				dec hl 
0444 c1					pop bc 
0445 e1					pop hl 
0446 3e 40				ld a, STORE_BLOCK_PHY 
0448 cd f2 0d				call addatohl 
044b 10 e1				djnz .setmark2 
044d			 
044d					 
044d			 
044d			 
044d c9				ret 
044e			 
044e			 
044e			 
044e			 
044e .. 00		.defaultbanklabl:   db "BankLabel_",0 
0459			 
0459			 
0459			 
0459			; Label Bank 
0459			; ---------- 
0459			; 
0459			; With current bank 
0459			; Read block 0 
0459			; Set label 
0459			; Write block 0 
0459			 
0459			; label str pointer in hl 
0459			 
0459			storage_label:     
0459			 
0459				if DEBUG_STORESE 
0459					DMARK "LBL" 
0459 f5				push af  
045a 3a 6e 04			ld a, (.dmark)  
045d 32 6b ee			ld (debug_mark),a  
0460 3a 6f 04			ld a, (.dmark+1)  
0463 32 6c ee			ld (debug_mark+1),a  
0466 3a 70 04			ld a, (.dmark+2)  
0469 32 6d ee			ld (debug_mark+2),a  
046c 18 03			jr .pastdmark  
046e ..			.dmark: db "LBL"  
0471 f1			.pastdmark: pop af  
0472			endm  
# End of macro DMARK
0472					CALLMONITOR 
0472 cd 6f ee			call debug_vector  
0475				endm  
# End of macro CALLMONITOR
0475				endif 
0475			 
0475 e5				push hl 
0476			 
0476 cd 35 03			call storage_get_block_0 
0479			 
0479				; set default label 
0479			 
0479 e1				pop hl 
047a			 
047a 11 7d ea		 	ld de, store_page+3 
047d 01 0f 00			ld bc, 15 
0480				if DEBUG_STORESE 
0480					DMARK "LB3" 
0480 f5				push af  
0481 3a 95 04			ld a, (.dmark)  
0484 32 6b ee			ld (debug_mark),a  
0487 3a 96 04			ld a, (.dmark+1)  
048a 32 6c ee			ld (debug_mark+1),a  
048d 3a 97 04			ld a, (.dmark+2)  
0490 32 6d ee			ld (debug_mark+2),a  
0493 18 03			jr .pastdmark  
0495 ..			.dmark: db "LB3"  
0498 f1			.pastdmark: pop af  
0499			endm  
# End of macro DMARK
0499					CALLMONITOR 
0499 cd 6f ee			call debug_vector  
049c				endm  
# End of macro CALLMONITOR
049c				endif 
049c ed b0			ldir 
049e				; save default page 0 
049e			 
049e 21 00 00			ld hl, 0 
04a1 11 7a ea			ld de, store_page 
04a4				if DEBUG_STORESE 
04a4					DMARK "LBW" 
04a4 f5				push af  
04a5 3a b9 04			ld a, (.dmark)  
04a8 32 6b ee			ld (debug_mark),a  
04ab 3a ba 04			ld a, (.dmark+1)  
04ae 32 6c ee			ld (debug_mark+1),a  
04b1 3a bb 04			ld a, (.dmark+2)  
04b4 32 6d ee			ld (debug_mark+2),a  
04b7 18 03			jr .pastdmark  
04b9 ..			.dmark: db "LBW"  
04bc f1			.pastdmark: pop af  
04bd			endm  
# End of macro DMARK
04bd					CALLMONITOR 
04bd cd 6f ee			call debug_vector  
04c0				endm  
# End of macro CALLMONITOR
04c0				endif 
04c0 cd e9 02			call storage_write_block 
04c3			 
04c3 c9				ret 
04c4			 
04c4			 
04c4			 
04c4			; Read Block 0 - Config 
04c4			; --------------------- 
04c4			; 
04c4			; With current bank 
04c4			; Call presence test 
04c4			;    If not present format/init bank  
04c4			; Read block 0  
04c4			;  
04c4			 
04c4			 
04c4			; Dir 
04c4			; --- 
04c4			; 
04c4			; With current bank 
04c4			; Load Block 0 Config 
04c4			; Get max file id number 
04c4			; For each logical block 
04c4			;    Read block read byte 2 
04c4			;      if first block of file 
04c4			;         Display file name 
04c4			;         Display type flags for file 
04c4			;        
04c4			 
04c4			; moving to words as this requires stack control 
04c4			 
04c4			 
04c4			; Delete File 
04c4			; ----------- 
04c4			; 
04c4			; With current bank 
04c4			; 
04c4			; Load Block 0 Config 
04c4			; Get max file id number 
04c4			; For each logical block 
04c4			;    Read block file id 
04c4			;      If first block of file and dont have file id 
04c4			;         if file to delete 
04c4			;         Save file id 
04c4			;         Null file id 
04c4			;         Write this block back 
04c4			;      If file id is one saved 
04c4			;         Null file id 
04c4			;         Write this block back 
04c4			 
04c4			 
04c4			.se_done: 
04c4 e1				pop hl 
04c5 c9				ret 
04c6			 
04c6			storage_erase: 
04c6			 
04c6				; hl contains the file id 
04c6			 
04c6 5d				ld e, l 
04c7 16 00			ld d, 0 
04c9 21 40 00			ld hl, STORE_BLOCK_PHY 
04cc					if DEBUG_FORTH_WORDS 
04cc						DMARK "ERA" 
04cc f5				push af  
04cd 3a e1 04			ld a, (.dmark)  
04d0 32 6b ee			ld (debug_mark),a  
04d3 3a e2 04			ld a, (.dmark+1)  
04d6 32 6c ee			ld (debug_mark+1),a  
04d9 3a e3 04			ld a, (.dmark+2)  
04dc 32 6d ee			ld (debug_mark+2),a  
04df 18 03			jr .pastdmark  
04e1 ..			.dmark: db "ERA"  
04e4 f1			.pastdmark: pop af  
04e5			endm  
# End of macro DMARK
04e5						CALLMONITOR 
04e5 cd 6f ee			call debug_vector  
04e8				endm  
# End of macro CALLMONITOR
04e8					endif 
04e8 cd b7 05			call storage_findnextid 
04eb cd 1b 0e			call ishlzero 
04ee c8				ret z 
04ef			 
04ef e5				push hl 
04f0			 
04f0				; TODO check file not found 
04f0			 
04f0 11 7a ea			ld de, store_page 
04f3 cd 84 02			call storage_read_block 
04f6			 
04f6 cd 1b 0e			call ishlzero 
04f9 ca c4 04			jp z,.se_done 
04fc			 
04fc					if DEBUG_FORTH_WORDS 
04fc						DMARK "ER1" 
04fc f5				push af  
04fd 3a 11 05			ld a, (.dmark)  
0500 32 6b ee			ld (debug_mark),a  
0503 3a 12 05			ld a, (.dmark+1)  
0506 32 6c ee			ld (debug_mark+1),a  
0509 3a 13 05			ld a, (.dmark+2)  
050c 32 6d ee			ld (debug_mark+2),a  
050f 18 03			jr .pastdmark  
0511 ..			.dmark: db "ER1"  
0514 f1			.pastdmark: pop af  
0515			endm  
# End of macro DMARK
0515						CALLMONITOR 
0515 cd 6f ee			call debug_vector  
0518				endm  
# End of macro CALLMONITOR
0518					endif 
0518 3a 7a ea			ld a, (store_page)	; get file id 
051b 32 6e ea			ld (store_tmpid), a 
051e			 
051e 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0521 32 6d ea			ld (store_tmpext), a 
0524			 
0524				; wipe file header 
0524			 
0524 e1				pop hl 
0525 3e 00			ld a, 0 
0527 32 7a ea			ld (store_page), a 
052a 32 7b ea			ld (store_page+1),a 
052d 11 7a ea			ld de, store_page 
0530					if DEBUG_FORTH_WORDS 
0530						DMARK "ER2" 
0530 f5				push af  
0531 3a 45 05			ld a, (.dmark)  
0534 32 6b ee			ld (debug_mark),a  
0537 3a 46 05			ld a, (.dmark+1)  
053a 32 6c ee			ld (debug_mark+1),a  
053d 3a 47 05			ld a, (.dmark+2)  
0540 32 6d ee			ld (debug_mark+2),a  
0543 18 03			jr .pastdmark  
0545 ..			.dmark: db "ER2"  
0548 f1			.pastdmark: pop af  
0549			endm  
# End of macro DMARK
0549						CALLMONITOR 
0549 cd 6f ee			call debug_vector  
054c				endm  
# End of macro CALLMONITOR
054c					endif 
054c cd e9 02			call storage_write_block 
054f			 
054f			 
054f				; wipe file extents 
054f			 
054f 3a 6d ea			ld a, (store_tmpext) 
0552 47				ld b, a 
0553			 
0553			.eraext:	  
0553 c5				push bc 
0554			 
0554 21 40 00			ld hl, STORE_BLOCK_PHY 
0557 3a 6e ea			ld a,(store_tmpid) 
055a 5f				ld e, a 
055b 50				ld d, b	 
055c					if DEBUG_FORTH_WORDS 
055c						DMARK "ER3" 
055c f5				push af  
055d 3a 71 05			ld a, (.dmark)  
0560 32 6b ee			ld (debug_mark),a  
0563 3a 72 05			ld a, (.dmark+1)  
0566 32 6c ee			ld (debug_mark+1),a  
0569 3a 73 05			ld a, (.dmark+2)  
056c 32 6d ee			ld (debug_mark+2),a  
056f 18 03			jr .pastdmark  
0571 ..			.dmark: db "ER3"  
0574 f1			.pastdmark: pop af  
0575			endm  
# End of macro DMARK
0575						CALLMONITOR 
0575 cd 6f ee			call debug_vector  
0578				endm  
# End of macro CALLMONITOR
0578					endif 
0578 cd b7 05			call storage_findnextid 
057b cd 1b 0e			call ishlzero 
057e ca c4 04			jp z,.se_done 
0581			 
0581 e5				push hl 
0582 11 7a ea			ld de, store_page 
0585 cd 84 02			call storage_read_block 
0588			 
0588				; free block	 
0588			 
0588 3e 00			ld a, 0 
058a 32 7a ea			ld (store_page), a 
058d 32 7b ea			ld (store_page+1),a 
0590 11 7a ea			ld de, store_page 
0593 e1				pop hl 
0594					if DEBUG_FORTH_WORDS 
0594						DMARK "ER4" 
0594 f5				push af  
0595 3a a9 05			ld a, (.dmark)  
0598 32 6b ee			ld (debug_mark),a  
059b 3a aa 05			ld a, (.dmark+1)  
059e 32 6c ee			ld (debug_mark+1),a  
05a1 3a ab 05			ld a, (.dmark+2)  
05a4 32 6d ee			ld (debug_mark+2),a  
05a7 18 03			jr .pastdmark  
05a9 ..			.dmark: db "ER4"  
05ac f1			.pastdmark: pop af  
05ad			endm  
# End of macro DMARK
05ad						CALLMONITOR 
05ad cd 6f ee			call debug_vector  
05b0				endm  
# End of macro CALLMONITOR
05b0					endif 
05b0 cd e9 02			call storage_write_block 
05b3			 
05b3 c1				pop bc 
05b4 10 9d			djnz .eraext 
05b6			 
05b6 c9				ret 
05b7			 
05b7			 
05b7			; Find Free Block 
05b7			; --------------- 
05b7			; 
05b7			; With current bank 
05b7			;  
05b7			; From given starting logical block 
05b7			;    Read block  
05b7			;    If no file id 
05b7			;         Return block id 
05b7			 
05b7			 
05b7			; hl starting page number 
05b7			; hl contains free page number or zero if no pages free 
05b7			; e contains the file id to locate 
05b7			; d contains the block number 
05b7			 
05b7			; TODO change to find file id and use zero for free block 
05b7			 
05b7			storage_findnextid: 
05b7			 
05b7				; now locate first 0 page to mark as a free block 
05b7			 
05b7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05b9			;	ld hl, STORE_BLOCK_PHY 
05b9			 
05b9					if DEBUG_FORTH_WORDS 
05b9					DMARK "FNI" 
05b9 f5				push af  
05ba 3a ce 05			ld a, (.dmark)  
05bd 32 6b ee			ld (debug_mark),a  
05c0 3a cf 05			ld a, (.dmark+1)  
05c3 32 6c ee			ld (debug_mark+1),a  
05c6 3a d0 05			ld a, (.dmark+2)  
05c9 32 6d ee			ld (debug_mark+2),a  
05cc 18 03			jr .pastdmark  
05ce ..			.dmark: db "FNI"  
05d1 f1			.pastdmark: pop af  
05d2			endm  
# End of macro DMARK
05d2						CALLMONITOR 
05d2 cd 6f ee			call debug_vector  
05d5				endm  
# End of macro CALLMONITOR
05d5					endif 
05d5			.ff1:   	 
05d5 e5					push hl 
05d6 c5					push bc 
05d7 d5					push de 
05d8 cd a8 01				call se_readbyte 
05db 5f					ld e,a 
05dc 23					inc hl 
05dd cd a8 01				call se_readbyte 
05e0 57					ld d, a 
05e1 e1					pop hl 
05e2 e5					push hl 
05e3 cd 10 0e				call cmp16 
05e6 28 49				jr z, .fffound 
05e8			 
05e8 d1					pop de 
05e9 c1					pop bc 
05ea e1					pop hl 
05eb			 
05eb					; is found? 
05eb					;cp e 
05eb					;ret z 
05eb			 
05eb 3e 40				ld a, STORE_BLOCK_PHY 
05ed cd f2 0d				call addatohl 
05f0 10 e3				djnz .ff1 
05f2			 
05f2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05f4			.ff2:   	 
05f4			 
05f4 e5					push hl 
05f5 c5					push bc 
05f6 d5					push de 
05f7 cd a8 01				call se_readbyte 
05fa 5f					ld e,a 
05fb 23					inc hl 
05fc cd a8 01				call se_readbyte 
05ff 57					ld d, a 
0600			 
0600 e1					pop hl 
0601 e5					push hl 
0602 cd 10 0e				call cmp16 
0605 28 2a				jr z, .fffound 
0607			 
0607 d1					pop de 
0608 c1					pop bc 
0609 e1					pop hl 
060a					; is found? 
060a					;cp e 
060a					;ret z 
060a			 
060a 3e 40				ld a, STORE_BLOCK_PHY 
060c cd f2 0d				call addatohl 
060f 10 e3				djnz .ff2 
0611			 
0611			 
0611					if DEBUG_FORTH_WORDS 
0611					DMARK "FN-" 
0611 f5				push af  
0612 3a 26 06			ld a, (.dmark)  
0615 32 6b ee			ld (debug_mark),a  
0618 3a 27 06			ld a, (.dmark+1)  
061b 32 6c ee			ld (debug_mark+1),a  
061e 3a 28 06			ld a, (.dmark+2)  
0621 32 6d ee			ld (debug_mark+2),a  
0624 18 03			jr .pastdmark  
0626 ..			.dmark: db "FN-"  
0629 f1			.pastdmark: pop af  
062a			endm  
# End of macro DMARK
062a					;	push af 
062a					;	ld a, 'n' 
062a					;	ld (debug_mark),a 
062a					;	pop af 
062a						CALLMONITOR 
062a cd 6f ee			call debug_vector  
062d				endm  
# End of macro CALLMONITOR
062d					endif 
062d				; no free marks! 
062d 21 00 00				ld hl, 0 
0630 c9				ret 
0631			.fffound: 
0631				 
0631			 
0631 d1					pop de 
0632 c1					pop bc 
0633 e1					pop hl 
0634					if DEBUG_FORTH_WORDS 
0634					DMARK "FNF" 
0634 f5				push af  
0635 3a 49 06			ld a, (.dmark)  
0638 32 6b ee			ld (debug_mark),a  
063b 3a 4a 06			ld a, (.dmark+1)  
063e 32 6c ee			ld (debug_mark+1),a  
0641 3a 4b 06			ld a, (.dmark+2)  
0644 32 6d ee			ld (debug_mark+2),a  
0647 18 03			jr .pastdmark  
0649 ..			.dmark: db "FNF"  
064c f1			.pastdmark: pop af  
064d			endm  
# End of macro DMARK
064d					;	push af 
064d					;	ld a, 'n' 
064d					;	ld (debug_mark),a 
064d					;	pop af 
064d						CALLMONITOR 
064d cd 6f ee			call debug_vector  
0650				endm  
# End of macro CALLMONITOR
0650					endif 
0650 c9				ret 
0651			 
0651			 
0651			 
0651			; Free Space 
0651			; ---------- 
0651			; 
0651			; With current bank 
0651			; 
0651			; Set block count to zero 
0651			; Starting with first logical block 
0651			;      Find free block  
0651			;      If block id given, increment block count 
0651			; 
0651			;  
0651			 
0651			 
0651			; hl contains count of free blocks 
0651			 
0651			storage_freeblocks: 
0651			 
0651				; now locate first 0 page to mark as a free block 
0651			 
0651 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0653 21 40 00			ld hl, STORE_BLOCK_PHY 
0656 11 00 00			ld de, 0 
0659			 
0659			.fb1:   	 
0659 e5					push hl 
065a c5					push bc 
065b d5					push de 
065c cd a8 01				call se_readbyte 
065f d1					pop de 
0660 c1					pop bc 
0661 e1					pop hl 
0662			 
0662					; is free? 
0662 fe 00				cp 0 
0664 20 01				jr nz, .ff1cont 
0666 13					inc de 
0667			 
0667			.ff1cont: 
0667			 
0667			 
0667 3e 40				ld a, STORE_BLOCK_PHY 
0669 cd f2 0d				call addatohl 
066c 10 eb				djnz .fb1 
066e			 
066e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0670			.fb2:   	 
0670 e5					push hl 
0671 c5					push bc 
0672 d5					push de 
0673 cd a8 01				call se_readbyte 
0676 d1					pop de 
0677 c1					pop bc 
0678 e1					pop hl 
0679			 
0679					; is free? 
0679 fe 00				cp 0 
067b 20 01				jr nz, .ff2cont 
067d 13					inc de 
067e			 
067e			.ff2cont: 
067e			 
067e 3e 40				ld a, STORE_BLOCK_PHY 
0680 cd f2 0d				call addatohl 
0683 10 eb				djnz .fb2 
0685			 
0685 eb				ex de, hl 
0686 c9				ret 
0687			 
0687			; Get File ID 
0687			; ----------- 
0687			; 
0687			; With current bank 
0687			;  
0687			; Load Block 0 Config 
0687			; Get max file id number 
0687			; For each logical block 
0687			;    Read block file id 
0687			;      If first block of file and dont have file id 
0687			;         if file get id and exit 
0687			 
0687			 
0687			 
0687			 
0687			; Create File 
0687			; ----------- 
0687			; 
0687			; With current bank  
0687			; Load Block 0 Config 
0687			; Get max file id number 
0687			; Increment file id number 
0687			; Save Config 
0687			; Find free block 
0687			; Set buffer with file name and file id 
0687			; Write buffer to free block  
0687			 
0687			 
0687			; hl point to file name 
0687			; hl returns file id 
0687			 
0687			; file format: 
0687			; byte 0 - file id 
0687			; byte 1 - extent number 
0687			; byte 2-> data 
0687			 
0687			; format for extent number 0: 
0687			; 
0687			; byte 0 - file id 
0687			; byte 1 - extent 0 
0687			; byte 2 - extent count 
0687			; byte 3 -> file name and meta data 
0687			 
0687			 
0687			storage_create: 
0687				if DEBUG_STORESE 
0687					DMARK "SCR" 
0687 f5				push af  
0688 3a 9c 06			ld a, (.dmark)  
068b 32 6b ee			ld (debug_mark),a  
068e 3a 9d 06			ld a, (.dmark+1)  
0691 32 6c ee			ld (debug_mark+1),a  
0694 3a 9e 06			ld a, (.dmark+2)  
0697 32 6d ee			ld (debug_mark+2),a  
069a 18 03			jr .pastdmark  
069c ..			.dmark: db "SCR"  
069f f1			.pastdmark: pop af  
06a0			endm  
# End of macro DMARK
06a0					CALLMONITOR 
06a0 cd 6f ee			call debug_vector  
06a3				endm  
# End of macro CALLMONITOR
06a3				endif 
06a3			 
06a3 e5				push hl		; save file name pointer 
06a4			 
06a4 cd 35 03			call storage_get_block_0 
06a7			 
06a7 3a 7a ea			ld a,(store_page)	; get current file id 
06aa 3c				inc a 
06ab 32 7a ea			ld (store_page),a 
06ae				 
06ae 32 6e ea			ld (store_tmpid),a			; save id 
06b1			 
06b1 21 00 00			ld hl, 0 
06b4 11 7a ea			ld de, store_page 
06b7				if DEBUG_STORESE 
06b7					DMARK "SCw" 
06b7 f5				push af  
06b8 3a cc 06			ld a, (.dmark)  
06bb 32 6b ee			ld (debug_mark),a  
06be 3a cd 06			ld a, (.dmark+1)  
06c1 32 6c ee			ld (debug_mark+1),a  
06c4 3a ce 06			ld a, (.dmark+2)  
06c7 32 6d ee			ld (debug_mark+2),a  
06ca 18 03			jr .pastdmark  
06cc ..			.dmark: db "SCw"  
06cf f1			.pastdmark: pop af  
06d0			endm  
# End of macro DMARK
06d0					CALLMONITOR 
06d0 cd 6f ee			call debug_vector  
06d3				endm  
# End of macro CALLMONITOR
06d3				endif 
06d3 cd e9 02			call storage_write_block	 ; save update 
06d6			 
06d6				if DEBUG_STORESE 
06d6 11 7a ea				ld de, store_page 
06d9					DMARK "SCC" 
06d9 f5				push af  
06da 3a ee 06			ld a, (.dmark)  
06dd 32 6b ee			ld (debug_mark),a  
06e0 3a ef 06			ld a, (.dmark+1)  
06e3 32 6c ee			ld (debug_mark+1),a  
06e6 3a f0 06			ld a, (.dmark+2)  
06e9 32 6d ee			ld (debug_mark+2),a  
06ec 18 03			jr .pastdmark  
06ee ..			.dmark: db "SCC"  
06f1 f1			.pastdmark: pop af  
06f2			endm  
# End of macro DMARK
06f2					CALLMONITOR 
06f2 cd 6f ee			call debug_vector  
06f5				endm  
# End of macro CALLMONITOR
06f5				endif 
06f5				;  
06f5				 
06f5 21 40 00			ld hl, STORE_BLOCK_PHY 
06f8 11 00 00			ld de, 0 
06fb cd b7 05			call storage_findnextid 
06fe			 
06fe 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
0701			 
0701				; TODO detect 0 = no spare blocks 
0701			 
0701				; hl now contains the free page to use for the file header page 
0701			 
0701				if DEBUG_STORESE 
0701				DMARK "SCF" 
0701 f5				push af  
0702 3a 16 07			ld a, (.dmark)  
0705 32 6b ee			ld (debug_mark),a  
0708 3a 17 07			ld a, (.dmark+1)  
070b 32 6c ee			ld (debug_mark+1),a  
070e 3a 18 07			ld a, (.dmark+2)  
0711 32 6d ee			ld (debug_mark+2),a  
0714 18 03			jr .pastdmark  
0716 ..			.dmark: db "SCF"  
0719 f1			.pastdmark: pop af  
071a			endm  
# End of macro DMARK
071a					CALLMONITOR 
071a cd 6f ee			call debug_vector  
071d				endm  
# End of macro CALLMONITOR
071d				endif 
071d			 
071d 22 65 ea			ld (store_tmppageid), hl 
0720				 
0720 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0723			;	ld a, (store_filecache)			; save to cache 
0723			 
0723 32 7a ea			ld (store_page),a    ; set page id 
0726 3e 00			ld a, 0			 ; extent 0 is file header 
0728 32 7b ea			ld (store_page+1), a   ; set file extent 
072b			 
072b 32 7c ea			ld (store_page+2), a   ; extent count for the file 
072e			 
072e			;	inc hl 		; init block 0 of file 
072e			;	inc hl   		; skip file and extent id 
072e			 ;       ld a, 0 
072e			;	ld (hl),a 
072e			;	ld a, (store_filecache+1)  	; save to cache 
072e			 
072e			;	inc hl    ; file name 
072e				 
072e				 
072e 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0731				if DEBUG_STORESE 
0731					DMARK "SCc" 
0731 f5				push af  
0732 3a 46 07			ld a, (.dmark)  
0735 32 6b ee			ld (debug_mark),a  
0738 3a 47 07			ld a, (.dmark+1)  
073b 32 6c ee			ld (debug_mark+1),a  
073e 3a 48 07			ld a, (.dmark+2)  
0741 32 6d ee			ld (debug_mark+2),a  
0744 18 03			jr .pastdmark  
0746 ..			.dmark: db "SCc"  
0749 f1			.pastdmark: pop af  
074a			endm  
# End of macro DMARK
074a					CALLMONITOR 
074a cd 6f ee			call debug_vector  
074d				endm  
# End of macro CALLMONITOR
074d				endif 
074d e1				pop hl    ; get zero term string 
074e e5				push hl 
074f 3e 00			ld a, 0 
0751 cd 63 11			call strlent 
0754 23				inc hl   ; cover zero term 
0755 06 00			ld b,0 
0757 4d				ld c,l 
0758 e1				pop hl 
0759				;ex de, hl 
0759				if DEBUG_STORESE 
0759					DMARK "SCa" 
0759 f5				push af  
075a 3a 6e 07			ld a, (.dmark)  
075d 32 6b ee			ld (debug_mark),a  
0760 3a 6f 07			ld a, (.dmark+1)  
0763 32 6c ee			ld (debug_mark+1),a  
0766 3a 70 07			ld a, (.dmark+2)  
0769 32 6d ee			ld (debug_mark+2),a  
076c 18 03			jr .pastdmark  
076e ..			.dmark: db "SCa"  
0771 f1			.pastdmark: pop af  
0772			endm  
# End of macro DMARK
0772					;push af 
0772					;ld a, 'a' 
0772					;ld (debug_mark),a 
0772					;pop af 
0772					CALLMONITOR 
0772 cd 6f ee			call debug_vector  
0775				endm  
# End of macro CALLMONITOR
0775				endif 
0775 ed b0			ldir    ; copy zero term string 
0777				if DEBUG_STORESE 
0777					DMARK "SCA" 
0777 f5				push af  
0778 3a 8c 07			ld a, (.dmark)  
077b 32 6b ee			ld (debug_mark),a  
077e 3a 8d 07			ld a, (.dmark+1)  
0781 32 6c ee			ld (debug_mark+1),a  
0784 3a 8e 07			ld a, (.dmark+2)  
0787 32 6d ee			ld (debug_mark+2),a  
078a 18 03			jr .pastdmark  
078c ..			.dmark: db "SCA"  
078f f1			.pastdmark: pop af  
0790			endm  
# End of macro DMARK
0790					CALLMONITOR 
0790 cd 6f ee			call debug_vector  
0793				endm  
# End of macro CALLMONITOR
0793				endif 
0793			 
0793				; write file header page 
0793			 
0793 2a 65 ea			ld hl,(store_tmppageid) 
0796 11 7a ea			ld de, store_page 
0799				if DEBUG_STORESE 
0799					DMARK "SCb" 
0799 f5				push af  
079a 3a ae 07			ld a, (.dmark)  
079d 32 6b ee			ld (debug_mark),a  
07a0 3a af 07			ld a, (.dmark+1)  
07a3 32 6c ee			ld (debug_mark+1),a  
07a6 3a b0 07			ld a, (.dmark+2)  
07a9 32 6d ee			ld (debug_mark+2),a  
07ac 18 03			jr .pastdmark  
07ae ..			.dmark: db "SCb"  
07b1 f1			.pastdmark: pop af  
07b2			endm  
# End of macro DMARK
07b2					;push af 
07b2					;ld a, 'b' 
07b2					;ld (debug_mark),a 
07b2					;pop af 
07b2					CALLMONITOR 
07b2 cd 6f ee			call debug_vector  
07b5				endm  
# End of macro CALLMONITOR
07b5				endif 
07b5 cd e9 02			call storage_write_block 
07b8			 
07b8 3a 6e ea			ld a, (store_tmpid) 
07bb 6f				ld l, a 
07bc 26 00			ld h,0 
07be				if DEBUG_STORESE 
07be					DMARK "SCz" 
07be f5				push af  
07bf 3a d3 07			ld a, (.dmark)  
07c2 32 6b ee			ld (debug_mark),a  
07c5 3a d4 07			ld a, (.dmark+1)  
07c8 32 6c ee			ld (debug_mark+1),a  
07cb 3a d5 07			ld a, (.dmark+2)  
07ce 32 6d ee			ld (debug_mark+2),a  
07d1 18 03			jr .pastdmark  
07d3 ..			.dmark: db "SCz"  
07d6 f1			.pastdmark: pop af  
07d7			endm  
# End of macro DMARK
07d7					CALLMONITOR 
07d7 cd 6f ee			call debug_vector  
07da				endm  
# End of macro CALLMONITOR
07da				endif 
07da c9				ret 
07db				 
07db			 
07db			 
07db			; 
07db			; Read File 
07db			; 
07db			; h - file id to locate 
07db			; l - extent to locate 
07db			; de - pointer to string to read into 
07db			; 
07db			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07db			 
07db			.sr_fail: 
07db d1				pop de 
07dc c9				ret 
07dd			 
07dd			storage_read: 
07dd			 
07dd			 
07dd d5				push de 
07de			 
07de			; TODO BUG the above push is it popped before the RET Z? 
07de			 
07de			; TODO how to handle multiple part blocks 
07de			 
07de				; locate file extent to read 
07de			 
07de 5c				ld e, h 
07df 55				ld d, l 
07e0			 
07e0			.srext: 
07e0 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07e3 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07e7			 
07e7 21 40 00			ld hl, STORE_BLOCK_PHY 
07ea				if DEBUG_STORESE 
07ea					DMARK "sre" 
07ea f5				push af  
07eb 3a ff 07			ld a, (.dmark)  
07ee 32 6b ee			ld (debug_mark),a  
07f1 3a 00 08			ld a, (.dmark+1)  
07f4 32 6c ee			ld (debug_mark+1),a  
07f7 3a 01 08			ld a, (.dmark+2)  
07fa 32 6d ee			ld (debug_mark+2),a  
07fd 18 03			jr .pastdmark  
07ff ..			.dmark: db "sre"  
0802 f1			.pastdmark: pop af  
0803			endm  
# End of macro DMARK
0803					CALLMONITOR 
0803 cd 6f ee			call debug_vector  
0806				endm  
# End of macro CALLMONITOR
0806				endif 
0806 cd b7 05			call storage_findnextid 
0809			 
0809				if DEBUG_STORESE 
0809					DMARK "srf" 
0809 f5				push af  
080a 3a 1e 08			ld a, (.dmark)  
080d 32 6b ee			ld (debug_mark),a  
0810 3a 1f 08			ld a, (.dmark+1)  
0813 32 6c ee			ld (debug_mark+1),a  
0816 3a 20 08			ld a, (.dmark+2)  
0819 32 6d ee			ld (debug_mark+2),a  
081c 18 03			jr .pastdmark  
081e ..			.dmark: db "srf"  
0821 f1			.pastdmark: pop af  
0822			endm  
# End of macro DMARK
0822					CALLMONITOR 
0822 cd 6f ee			call debug_vector  
0825				endm  
# End of macro CALLMONITOR
0825				endif 
0825 cd 1b 0e			call ishlzero 
0828			;	ld a, l 
0828			;	add h 
0828			;	cp 0 
0828 28 b1			jr z,.sr_fail			; block not found so EOF 
082a			 
082a				; save current address for use by higher level words etc 
082a			 
082a 22 6b ea			ld (store_openaddr),hl 
082d			 
082d			 
082d				; hl contains page number to load 
082d d1				pop de   ; get storage 
082e ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0832 d5				push de 
0833				if DEBUG_STORESE 
0833					DMARK "srg" 
0833 f5				push af  
0834 3a 48 08			ld a, (.dmark)  
0837 32 6b ee			ld (debug_mark),a  
083a 3a 49 08			ld a, (.dmark+1)  
083d 32 6c ee			ld (debug_mark+1),a  
0840 3a 4a 08			ld a, (.dmark+2)  
0843 32 6d ee			ld (debug_mark+2),a  
0846 18 03			jr .pastdmark  
0848 ..			.dmark: db "srg"  
084b f1			.pastdmark: pop af  
084c			endm  
# End of macro DMARK
084c					CALLMONITOR 
084c cd 6f ee			call debug_vector  
084f				endm  
# End of macro CALLMONITOR
084f				endif 
084f cd 84 02			call storage_read_block 
0852			 
0852				; if this a continuation read??? 
0852			 
0852 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0855			 
0855 3e 3f			ld a, STORE_BLOCK_PHY-1 
0857 cd f2 0d			call addatohl 
085a 7e				ld a,(hl) 
085b fe 00			cp 0 
085d 28 02			jr z, .markiscont 
085f 3e ff			ld a, 255 
0861			 
0861			.markiscont: 
0861 32 6d ea			ld (store_readcont), a 
0864			 
0864				if DEBUG_STORESE 
0864					DMARK "srC" 
0864 f5				push af  
0865 3a 79 08			ld a, (.dmark)  
0868 32 6b ee			ld (debug_mark),a  
086b 3a 7a 08			ld a, (.dmark+1)  
086e 32 6c ee			ld (debug_mark+1),a  
0871 3a 7b 08			ld a, (.dmark+2)  
0874 32 6d ee			ld (debug_mark+2),a  
0877 18 03			jr .pastdmark  
0879 ..			.dmark: db "srC"  
087c f1			.pastdmark: pop af  
087d			endm  
# End of macro DMARK
087d					CALLMONITOR 
087d cd 6f ee			call debug_vector  
0880				endm  
# End of macro CALLMONITOR
0880				endif 
0880				; only short reads enabled 
0880			 
0880 3a 75 ea			ld a, (store_longread) 
0883 fe 00			cp 0 
0885 ca 52 09			jp z, .readdone 
0888			 
0888			; TODO if block has no zeros then need to read next block  
0888			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0888			; check last byte of physical block. 
0888			; if not zero then the next block needs to be loaded 
0888			 
0888			 
0888 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
088b			 
088b 3e 3f			ld a, STORE_BLOCK_PHY-1 
088d cd f2 0d			call addatohl 
0890				;dec hl 
0890 7e				ld a,(hl) 
0891				if DEBUG_STORESE 
0891					DMARK "sr?" 
0891 f5				push af  
0892 3a a6 08			ld a, (.dmark)  
0895 32 6b ee			ld (debug_mark),a  
0898 3a a7 08			ld a, (.dmark+1)  
089b 32 6c ee			ld (debug_mark+1),a  
089e 3a a8 08			ld a, (.dmark+2)  
08a1 32 6d ee			ld (debug_mark+2),a  
08a4 18 03			jr .pastdmark  
08a6 ..			.dmark: db "sr?"  
08a9 f1			.pastdmark: pop af  
08aa			endm  
# End of macro DMARK
08aa					CALLMONITOR 
08aa cd 6f ee			call debug_vector  
08ad				endm  
# End of macro CALLMONITOR
08ad				endif 
08ad fe 00			cp 0 
08af ca 52 09			jp z, .readdone 
08b2			 
08b2				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08b2			 
08b2 23				inc hl 
08b3			 
08b3 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08b6			 
08b6 ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08ba			 
08ba eb				ex de, hl 
08bb			 
08bb				; next ext 
08bb			 
08bb 23				inc hl 
08bc 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08bf			 
08bf				if DEBUG_STORESE 
08bf					DMARK "sF2" 
08bf f5				push af  
08c0 3a d4 08			ld a, (.dmark)  
08c3 32 6b ee			ld (debug_mark),a  
08c6 3a d5 08			ld a, (.dmark+1)  
08c9 32 6c ee			ld (debug_mark+1),a  
08cc 3a d6 08			ld a, (.dmark+2)  
08cf 32 6d ee			ld (debug_mark+2),a  
08d2 18 03			jr .pastdmark  
08d4 ..			.dmark: db "sF2"  
08d7 f1			.pastdmark: pop af  
08d8			endm  
# End of macro DMARK
08d8					CALLMONITOR 
08d8 cd 6f ee			call debug_vector  
08db				endm  
# End of macro CALLMONITOR
08db				endif 
08db			 
08db				; get and load block 
08db			 
08db cd b7 05			call storage_findnextid 
08de			 
08de				if DEBUG_STORESE 
08de					DMARK "sf2" 
08de f5				push af  
08df 3a f3 08			ld a, (.dmark)  
08e2 32 6b ee			ld (debug_mark),a  
08e5 3a f4 08			ld a, (.dmark+1)  
08e8 32 6c ee			ld (debug_mark+1),a  
08eb 3a f5 08			ld a, (.dmark+2)  
08ee 32 6d ee			ld (debug_mark+2),a  
08f1 18 03			jr .pastdmark  
08f3 ..			.dmark: db "sf2"  
08f6 f1			.pastdmark: pop af  
08f7			endm  
# End of macro DMARK
08f7					CALLMONITOR 
08f7 cd 6f ee			call debug_vector  
08fa				endm  
# End of macro CALLMONITOR
08fa				endif 
08fa cd 1b 0e			call ishlzero 
08fd			;	ld a, l 
08fd			;	add h 
08fd			;	cp 0 
08fd ca db 07			jp z,.sr_fail			; block not found so EOF 
0900				 
0900				; save current address for use by higher level words etc 
0900			 
0900 22 6b ea			ld (store_openaddr),hl 
0903			 
0903 cd 84 02			call storage_read_block 
0906			 
0906				; on a continuation block, we now have the file id and ext in the middle of the block 
0906				; we need to pull everything back  
0906			 
0906 ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
090a 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
090d 23				inc hl 
090e 23				inc hl     ; skip id and ext 
090f 01 40 00			ld bc, STORE_BLOCK_PHY 
0912				if DEBUG_STORESE 
0912					DMARK "SR<" 
0912 f5				push af  
0913 3a 27 09			ld a, (.dmark)  
0916 32 6b ee			ld (debug_mark),a  
0919 3a 28 09			ld a, (.dmark+1)  
091c 32 6c ee			ld (debug_mark+1),a  
091f 3a 29 09			ld a, (.dmark+2)  
0922 32 6d ee			ld (debug_mark+2),a  
0925 18 03			jr .pastdmark  
0927 ..			.dmark: db "SR<"  
092a f1			.pastdmark: pop af  
092b			endm  
# End of macro DMARK
092b					CALLMONITOR 
092b cd 6f ee			call debug_vector  
092e				endm  
# End of macro CALLMONITOR
092e				endif 
092e ed b0			ldir     ; copy data 
0930			 
0930				; move the pointer back and pretend we have a full buffer for next recheck 
0930			 
0930 1b				dec de 
0931 1b				dec de 
0932			 
0932			; TODO do pop below now short circuit loop????? 
0932 c1				pop bc     ; get rid of spare de on stack 
0933				if DEBUG_STORESE 
0933					DMARK "SR>" 
0933 f5				push af  
0934 3a 48 09			ld a, (.dmark)  
0937 32 6b ee			ld (debug_mark),a  
093a 3a 49 09			ld a, (.dmark+1)  
093d 32 6c ee			ld (debug_mark+1),a  
0940 3a 4a 09			ld a, (.dmark+2)  
0943 32 6d ee			ld (debug_mark+2),a  
0946 18 03			jr .pastdmark  
0948 ..			.dmark: db "SR>"  
094b f1			.pastdmark: pop af  
094c			endm  
# End of macro DMARK
094c					CALLMONITOR 
094c cd 6f ee			call debug_vector  
094f				endm  
# End of macro CALLMONITOR
094f				endif 
094f c3 e0 07			jp .srext 
0952			 
0952			 
0952			 
0952			 
0952			 
0952			.readdone:		 
0952 e1				pop hl 		 ; return start of data to show as not EOF 
0953 23				inc hl   ; past file id 
0954 23				inc hl   ; past ext 
0955				if DEBUG_STORESE 
0955					DMARK "SRe" 
0955 f5				push af  
0956 3a 6a 09			ld a, (.dmark)  
0959 32 6b ee			ld (debug_mark),a  
095c 3a 6b 09			ld a, (.dmark+1)  
095f 32 6c ee			ld (debug_mark+1),a  
0962 3a 6c 09			ld a, (.dmark+2)  
0965 32 6d ee			ld (debug_mark+2),a  
0968 18 03			jr .pastdmark  
096a ..			.dmark: db "SRe"  
096d f1			.pastdmark: pop af  
096e			endm  
# End of macro DMARK
096e					CALLMONITOR 
096e cd 6f ee			call debug_vector  
0971				endm  
# End of macro CALLMONITOR
0971				endif 
0971 c9					ret 
0972			 
0972			 
0972			 
0972			; 
0972			; Append File 
0972			; 
0972			; hl - file id to locate 
0972			; de - pointer to (multi block) string to write 
0972			 
0972			.sa_notfound: 
0972 d1				pop de 
0973 c9				ret 
0974			 
0974			 
0974			storage_append: 
0974				; hl -  file id to append to 
0974				; de - string to append 
0974			 
0974 d5				push de 
0975				 
0975				if DEBUG_STORESE 
0975					DMARK "AP1" 
0975 f5				push af  
0976 3a 8a 09			ld a, (.dmark)  
0979 32 6b ee			ld (debug_mark),a  
097c 3a 8b 09			ld a, (.dmark+1)  
097f 32 6c ee			ld (debug_mark+1),a  
0982 3a 8c 09			ld a, (.dmark+2)  
0985 32 6d ee			ld (debug_mark+2),a  
0988 18 03			jr .pastdmark  
098a ..			.dmark: db "AP1"  
098d f1			.pastdmark: pop af  
098e			endm  
# End of macro DMARK
098e					CALLMONITOR 
098e cd 6f ee			call debug_vector  
0991				endm  
# End of macro CALLMONITOR
0991				endif 
0991			 
0991 7d				ld a, l 
0992 32 6e ea			ld (store_tmpid), a 
0995			 
0995				; get file header  
0995			 
0995 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0997 3a 6e ea			ld a, (store_tmpid) 
099a 5f				ld e, a 
099b			 
099b 21 40 00				ld hl, STORE_BLOCK_PHY 
099e cd b7 05				call storage_findnextid 
09a1			 
09a1 cd 1b 0e			call ishlzero 
09a4 28 cc			jr z, .sa_notfound 
09a6			 
09a6 22 65 ea			ld (store_tmppageid), hl 
09a9			 
09a9				; TODO handle file id not found 
09a9			 
09a9				if DEBUG_STORESE 
09a9					DMARK "AP2" 
09a9 f5				push af  
09aa 3a be 09			ld a, (.dmark)  
09ad 32 6b ee			ld (debug_mark),a  
09b0 3a bf 09			ld a, (.dmark+1)  
09b3 32 6c ee			ld (debug_mark+1),a  
09b6 3a c0 09			ld a, (.dmark+2)  
09b9 32 6d ee			ld (debug_mark+2),a  
09bc 18 03			jr .pastdmark  
09be ..			.dmark: db "AP2"  
09c1 f1			.pastdmark: pop af  
09c2			endm  
# End of macro DMARK
09c2					CALLMONITOR 
09c2 cd 6f ee			call debug_vector  
09c5				endm  
# End of macro CALLMONITOR
09c5				endif 
09c5			 
09c5				; update file extent count 
09c5			 
09c5 11 7a ea			ld de, store_page 
09c8			 
09c8 cd 84 02			call storage_read_block 
09cb			 
09cb				if DEBUG_STORESE 
09cb					DMARK "AP3" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 6b ee			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 6c ee			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 6d ee			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "AP3"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd 6f ee			call debug_vector  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7			;	ld (store_tmppageid), hl 
09e7			 
09e7 3a 7c ea			ld a, (store_page+2) 
09ea 3c				inc a 
09eb 32 7c ea			ld (store_page+2), a 
09ee 32 6d ea			ld (store_tmpext), a 
09f1				 
09f1				if DEBUG_STORESE 
09f1					DMARK "AP3" 
09f1 f5				push af  
09f2 3a 06 0a			ld a, (.dmark)  
09f5 32 6b ee			ld (debug_mark),a  
09f8 3a 07 0a			ld a, (.dmark+1)  
09fb 32 6c ee			ld (debug_mark+1),a  
09fe 3a 08 0a			ld a, (.dmark+2)  
0a01 32 6d ee			ld (debug_mark+2),a  
0a04 18 03			jr .pastdmark  
0a06 ..			.dmark: db "AP3"  
0a09 f1			.pastdmark: pop af  
0a0a			endm  
# End of macro DMARK
0a0a					CALLMONITOR 
0a0a cd 6f ee			call debug_vector  
0a0d				endm  
# End of macro CALLMONITOR
0a0d				endif 
0a0d 2a 65 ea			ld hl, (store_tmppageid) 
0a10 11 7a ea			ld de, store_page 
0a13 cd e9 02			call storage_write_block 
0a16			 
0a16				; find free block 
0a16			 
0a16 11 00 00			ld de, 0			 ; file extent to locate 
0a19			 
0a19 21 40 00				ld hl, STORE_BLOCK_PHY 
0a1c cd b7 05				call storage_findnextid 
0a1f cd 1b 0e			call ishlzero 
0a22 ca 72 09			jp z, .sa_notfound 
0a25			 
0a25					; TODO handle no space left 
0a25					 
0a25 22 65 ea				ld (store_tmppageid), hl 
0a28			 
0a28				if DEBUG_STORESE 
0a28					DMARK "AP4" 
0a28 f5				push af  
0a29 3a 3d 0a			ld a, (.dmark)  
0a2c 32 6b ee			ld (debug_mark),a  
0a2f 3a 3e 0a			ld a, (.dmark+1)  
0a32 32 6c ee			ld (debug_mark+1),a  
0a35 3a 3f 0a			ld a, (.dmark+2)  
0a38 32 6d ee			ld (debug_mark+2),a  
0a3b 18 03			jr .pastdmark  
0a3d ..			.dmark: db "AP4"  
0a40 f1			.pastdmark: pop af  
0a41			endm  
# End of macro DMARK
0a41					CALLMONITOR 
0a41 cd 6f ee			call debug_vector  
0a44				endm  
# End of macro CALLMONITOR
0a44				endif 
0a44					; init the buffer with zeros so we can id if the buffer is full or not 
0a44			 
0a44 e5					push hl 
0a45 c5					push bc 
0a46			 
0a46 21 7a ea				ld hl, store_page 
0a49 06 40				ld b, STORE_BLOCK_PHY 
0a4b 3e 00				ld a, 0 
0a4d 77			.zeroblock:	ld (hl), a 
0a4e 23					inc hl 
0a4f 10 fc				djnz .zeroblock 
0a51			 
0a51 c1					pop bc 
0a52 e1					pop hl 
0a53			 
0a53					; construct block 
0a53			 
0a53 3a 6e ea				ld a, (store_tmpid) 
0a56 32 7a ea				ld (store_page), a   ; file id 
0a59 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a5c 32 7b ea				ld (store_page+1), a 
0a5f			 
0a5f e1					pop hl    ; get string to write 
0a60 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a62 11 7c ea				ld de, store_page+2 
0a65			 
0a65				if DEBUG_STORESE 
0a65					DMARK "AP5" 
0a65 f5				push af  
0a66 3a 7a 0a			ld a, (.dmark)  
0a69 32 6b ee			ld (debug_mark),a  
0a6c 3a 7b 0a			ld a, (.dmark+1)  
0a6f 32 6c ee			ld (debug_mark+1),a  
0a72 3a 7c 0a			ld a, (.dmark+2)  
0a75 32 6d ee			ld (debug_mark+2),a  
0a78 18 03			jr .pastdmark  
0a7a ..			.dmark: db "AP5"  
0a7d f1			.pastdmark: pop af  
0a7e			endm  
# End of macro DMARK
0a7e					CALLMONITOR 
0a7e cd 6f ee			call debug_vector  
0a81				endm  
# End of macro CALLMONITOR
0a81				endif 
0a81			 
0a81			 
0a81			 
0a81					; fill buffer with data until end of string or full block 
0a81			 
0a81 7e			.appd:		ld a, (hl) 
0a82 12					ld (de), a 
0a83 fe 00				cp 0 
0a85 28 04				jr z, .appdone 
0a87 23					inc hl 
0a88 13					inc de 
0a89 10 f6				djnz .appd 
0a8b			 
0a8b e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a8c f5					push af   		; save last byte dumped 
0a8d			 
0a8d			 
0a8d 2a 65 ea			ld hl, (store_tmppageid) 
0a90 11 7a ea			ld de, store_page 
0a93				if DEBUG_STORESE 
0a93					DMARK "AP6" 
0a93 f5				push af  
0a94 3a a8 0a			ld a, (.dmark)  
0a97 32 6b ee			ld (debug_mark),a  
0a9a 3a a9 0a			ld a, (.dmark+1)  
0a9d 32 6c ee			ld (debug_mark+1),a  
0aa0 3a aa 0a			ld a, (.dmark+2)  
0aa3 32 6d ee			ld (debug_mark+2),a  
0aa6 18 03			jr .pastdmark  
0aa8 ..			.dmark: db "AP6"  
0aab f1			.pastdmark: pop af  
0aac			endm  
# End of macro DMARK
0aac					CALLMONITOR 
0aac cd 6f ee			call debug_vector  
0aaf				endm  
# End of macro CALLMONITOR
0aaf				endif 
0aaf cd e9 02				call storage_write_block 
0ab2			 
0ab2			 
0ab2				; was that a full block of data written? 
0ab2				; any more to write out? 
0ab2			 
0ab2				; if yes then set vars and jump to start of function again 
0ab2			 
0ab2 f1					pop af 
0ab3 d1					pop de 
0ab4			 
0ab4 fe 00				cp 0		 ; no, string was fully written 
0ab6 c8					ret z 
0ab7			 
0ab7					; setup vars for next cycle 
0ab7			 
0ab7 3a 6e ea				ld a, (store_tmpid) 
0aba 6f					ld l, a 
0abb 26 00				ld h, 0 
0abd			 
0abd c3 74 09			 	jp storage_append	 ; yes, need to write out some more 
0ac0			 
0ac0			 
0ac0			 
0ac0			 
0ac0			 
0ac0			 
0ac0			 
0ac0			if DEBUG_STORECF 
0ac0			storageput:	 
0ac0					ret 
0ac0			storageread: 
0ac0					ld hl, store_page 
0ac0					ld b, 200 
0ac0					ld a,0 
0ac0			.src:		ld (hl),a 
0ac0					inc hl 
0ac0					djnz .src 
0ac0					 
0ac0			 
0ac0					ld de, 0 
0ac0					ld bc, 1 
0ac0					ld hl, store_page 
0ac0					call cfRead 
0ac0			 
0ac0				call cfGetError 
0ac0				ld hl,scratch 
0ac0				call hexout 
0ac0				ld hl, scratch+2 
0ac0				ld a, 0 
0ac0				ld (hl),a 
0ac0				ld de, scratch 
0ac0				ld a,display_row_1 
0ac0				call str_at_display 
0ac0				call update_display 
0ac0			 
0ac0					ld hl, store_page 
0ac0					ld (os_cur_ptr),hl 
0ac0			 
0ac0					ret 
0ac0			endif 
0ac0			 
0ac0			 
0ac0			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ac0			 
0ac0			storage_clear_page: 
0ac0 e5				push hl 
0ac1 d5				push de 
0ac2 c5				push bc 
0ac3 21 7a ea			ld hl, store_page 
0ac6 3e 00			ld a, 0 
0ac8 77				ld (hl), a 
0ac9			 
0ac9 11 7b ea			ld de, store_page+1 
0acc 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0acf			 
0acf ed b0			ldir 
0ad1				 
0ad1 c1				pop bc 
0ad2 d1				pop de 
0ad3 e1				pop hl 
0ad4 c9				ret 
0ad5			 
0ad5			; eof 
# End of file firmware_storage.asm
0ad5			  
0ad5			; support routines for above hardware abstraction layer  
0ad5			  
0ad5			include "firmware_general.asm"        ; general support functions  
0ad5			 
0ad5			; word look up 
0ad5			 
0ad5			; in 
0ad5			; a is the index 
0ad5			; hl is pointer start of array 
0ad5			; 
0ad5			; returns 
0ad5			; hl to the word 
0ad5			; 
0ad5			 
0ad5			table_lookup:  
0ad5 d5					push de 
0ad6 eb					ex de, hl 
0ad7			 
0ad7 6f					ld l, a 
0ad8 26 00				ld h, 0 
0ada 29					add hl, hl 
0adb 19					add hl, de 
0adc 7e					ld a, (hl) 
0add 23					inc hl 
0ade 66					ld h,(hl) 
0adf 6f					ld l, a 
0ae0			 
0ae0 d1					pop de 
0ae1 c9					ret 
0ae2			 
0ae2			; Delay loops 
0ae2			 
0ae2			 
0ae2			 
0ae2			aDelayInMS: 
0ae2 c5				push bc 
0ae3 47				ld b,a 
0ae4			msdelay: 
0ae4 c5				push bc 
0ae5				 
0ae5			 
0ae5 01 41 00			ld bc,041h 
0ae8 cd 00 0b			call delayloop 
0aeb c1				pop bc 
0aec 05				dec b 
0aed 20 f5			jr nz,msdelay 
0aef			 
0aef			;if CPU_CLOCK_8MHZ 
0aef			;msdelay8: 
0aef			;	push bc 
0aef			;	 
0aef			; 
0aef			;	ld bc,041h 
0aef			;	call delayloop 
0aef			;	pop bc 
0aef			;	dec b 
0aef			;	jr nz,msdelay8 
0aef			;endif 
0aef			 
0aef			 
0aef c1				pop bc 
0af0 c9				ret 
0af1			 
0af1			 
0af1			delay250ms: 
0af1				;push de 
0af1 01 00 40			ld bc, 04000h 
0af4 c3 00 0b			jp delayloop 
0af7			delay500ms: 
0af7				;push de 
0af7 01 00 80			ld bc, 08000h 
0afa c3 00 0b			jp delayloop 
0afd			delay1s: 
0afd				;push bc 
0afd			   ; Clobbers A, d and e 
0afd 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0b00			delayloop: 
0b00 c5			    push bc 
0b01			 
0b01			if BASE_CPM 
0b01 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0b04			.cpmloop: 
0b04 c5				push bc 
0b05			 
0b05			endif 
0b05			 
0b05			 
0b05			 
0b05			delayloopi: 
0b05			;	push bc 
0b05			;.dl: 
0b05 cb 47		    bit     0,a    	; 8 
0b07 cb 47		    bit     0,a    	; 8 
0b09 cb 47		    bit     0,a    	; 8 
0b0b e6 ff		    and     255  	; 7 
0b0d 0b			    dec     bc      	; 6 
0b0e 79			    ld      a,c     	; 4 
0b0f b0			    or      b     	; 4 
0b10 c2 05 0b		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b13			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b13				;pop de 
0b13			;pop bc 
0b13			 
0b13			if BASE_CPM 
0b13 c1				pop bc 
0b14				 
0b14 0b			    dec     bc      	; 6 
0b15 79			    ld      a,c     	; 4 
0b16 b0			    or      b     	; 4 
0b17 c2 04 0b		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b1a				 
0b1a			 
0b1a			endif 
0b1a			;if CPU_CLOCK_8MHZ 
0b1a			;    pop bc 
0b1a			;    push bc 
0b1a			;.dl8: 
0b1a			;    bit     0,a    	; 8 
0b1a			;    bit     0,a    	; 8 
0b1a			;    bit     0,a    	; 8 
0b1a			;    and     255  	; 7 
0b1a			;    dec     bc      	; 6 
0b1a			;    ld      a,c     	; 4 
0b1a			;    or      b     	; 4 
0b1a			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b1a			;endif 
0b1a			 
0b1a			;if CPU_CLOCK_10MHZ 
0b1a			;    pop bc 
0b1a			;    push bc 
0b1a			;.dl8: 
0b1a			;    bit     0,a    	; 8 
0b1a			;    bit     0,a    	; 8 
0b1a			;    bit     0,a    	; 8 
0b1a			;    and     255  	; 7 
0b1a			;    dec     bc      	; 6 
0b1a			;    ld      a,c     	; 4 
0b1a			;    or      b     	; 4 
0b1a			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b1a			;endif 
0b1a c1			    pop bc 
0b1b			 
0b1b c9				ret 
0b1c			 
0b1c			 
0b1c			 
0b1c			; eof 
# End of file firmware_general.asm
0b1c			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b1c			; display routines that use the physical hardware abstraction layer 
0b1c			 
0b1c			 
0b1c			; Display an activity indicator 
0b1c			; Each call returns the new char pointed to in hl 
0b1c			 
0b1c			active: 
0b1c 3a c6 eb			ld a, (display_active) 
0b1f fe 06			cp 6 
0b21			 
0b21 20 02			jr nz, .sne 
0b23				; gone past the last one reset sequence 
0b23 3e ff			ld a, 255 
0b25			 
0b25			.sne:   
0b25				; get the next char in seq 
0b25 3c				inc a 
0b26 32 c6 eb			ld (display_active), a 
0b29			 
0b29				; look up the string in the table 
0b29 21 40 0b			ld hl, actseq 
0b2c cb 27			sla a 
0b2e cd f2 0d			call addatohl 
0b31 cd b6 1e			call loadwordinhl 
0b34			 
0b34				; forth will write the to string when pushing so move from rom to ram 
0b34			 
0b34 11 c7 eb			ld de, display_active+1 
0b37 01 02 00			ld bc, 2 
0b3a ed b0			ldir 
0b3c			 
0b3c 21 c7 eb			ld hl, display_active+1 
0b3f c9				ret 
0b40				 
0b40				 
0b40			 
0b40			 
0b40			;db "|/-\|-\" 
0b40			 
0b40			actseq: 
0b40			 
0b40 4e 0b		dw spin0 
0b42 50 0b		dw spin1 
0b44 52 0b		dw spin2 
0b46 54 0b		dw spin3 
0b48 52 0b		dw spin2 
0b4a 50 0b		dw spin1 
0b4c 4e 0b		dw spin0 
0b4e			 
0b4e .. 00		spin0: db " ", 0 
0b50 .. 00		spin1: db "-", 0 
0b52 .. 00		spin2: db "+", 0 
0b54 .. 00		spin3: db "#", 0 
0b56			 
0b56			 
0b56			; information window 
0b56			 
0b56			; pass hl with 1st string to display 
0b56			; pass de with 2nd string to display 
0b56			 
0b56			info_panel: 
0b56 e5				push hl 
0b57			 
0b57 2a cc eb			ld hl, (display_fb_active) 
0b5a e5				push hl    ; future de destination 
0b5b 21 b1 ed				ld hl, display_fb0 
0b5e 22 cc eb				ld (display_fb_active), hl 
0b61			 
0b61			;	call clear_display 
0b61			 
0b61				if BASE_CPM 
0b61 3e 2e			ld a, '.' 
0b63				else 
0b63				ld a, 165 
0b63				endif 
0b63 cd ca 0b			call fill_display 
0b66			 
0b66			 
0b66 3e 55			ld a, display_row_3 + 5 
0b68 cd d8 0b			call str_at_display 
0b6b			 
0b6b e1				pop hl 
0b6c d1				pop de 
0b6d			 
0b6d e5				push hl 
0b6e			 
0b6e			 
0b6e 3e 2d			ld a, display_row_2 + 5 
0b70 cd d8 0b			call str_at_display 
0b73			 
0b73			 
0b73 cd e8 0b			call update_display 
0b76 cd f1 1a			call next_page_prompt 
0b79 cd c5 0b			call clear_display 
0b7c			 
0b7c				 
0b7c 21 10 ed				ld hl, display_fb1 
0b7f 22 cc eb				ld (display_fb_active), hl 
0b82 cd e8 0b			call update_display 
0b85			 
0b85 e1				pop hl 
0b86			 
0b86 c9				ret 
0b87			 
0b87			 
0b87			 
0b87			 
0b87			; TODO windowing? 
0b87			 
0b87			; TODO scroll line up 
0b87			 
0b87			scroll_up: 
0b87			 
0b87 e5				push hl 
0b88 d5				push de 
0b89 c5				push bc 
0b8a			 
0b8a				; get frame buffer  
0b8a			 
0b8a 2a cc eb			ld hl, (display_fb_active) 
0b8d e5				push hl    ; future de destination 
0b8e			 
0b8e 11 28 00			ld  de, display_cols 
0b91 19				add hl, de 
0b92			 
0b92 d1				pop de 
0b93			 
0b93				;ex de, hl 
0b93 01 9f 00			ld bc, display_fb_len -1  
0b96			;if DEBUG_FORTH_WORDS 
0b96			;	DMARK "SCL" 
0b96			;	CALLMONITOR 
0b96			;endif	 
0b96 ed b0			ldir 
0b98			 
0b98				; wipe bottom row 
0b98			 
0b98			 
0b98 2a cc eb			ld hl, (display_fb_active) 
0b9b 11 a0 00			ld de, display_cols*display_rows 
0b9e 19				add hl, de 
0b9f 06 28			ld b, display_cols 
0ba1 3e 20			ld a, ' ' 
0ba3			.scwipe: 
0ba3 77				ld (hl), a 
0ba4 2b				dec hl 
0ba5 10 fc			djnz .scwipe 
0ba7			 
0ba7				;pop hl 
0ba7			 
0ba7 c1				pop bc 
0ba8 d1				pop de 
0ba9 e1				pop hl 
0baa			 
0baa c9				ret 
0bab			 
0bab			 
0bab			;scroll_upo: 
0bab			;	ld de, display_row_1 
0bab			 ;	ld hl, display_row_2 
0bab			;	ld bc, display_cols 
0bab			;	ldir 
0bab			;	ld de, display_row_2 
0bab			 ;	ld hl, display_row_3 
0bab			;	ld bc, display_cols 
0bab			;	ldir 
0bab			;	ld de, display_row_3 
0bab			 ;	ld hl, display_row_4 
0bab			;	ld bc, display_cols 
0bab			;	ldir 
0bab			 
0bab			; TODO clear row 4 
0bab			 
0bab			;	ret 
0bab			 
0bab				 
0bab			scroll_down: 
0bab			 
0bab e5				push hl 
0bac d5				push de 
0bad c5				push bc 
0bae			 
0bae				; get frame buffer  
0bae			 
0bae 2a cc eb			ld hl, (display_fb_active) 
0bb1			 
0bb1 11 9f 00			ld de, display_fb_len - 1 
0bb4 19				add hl, de 
0bb5			 
0bb5 e5			push hl    ; future de destination 
0bb6			 
0bb6 11 28 00			ld  de, display_cols 
0bb9 ed 52			sbc hl, de 
0bbb			 
0bbb			 
0bbb d1				pop de 
0bbc			 
0bbc			;	ex de, hl 
0bbc 01 9f 00			ld bc, display_fb_len -1  
0bbf			 
0bbf			 
0bbf				 
0bbf			 
0bbf ed b0			ldir 
0bc1			 
0bc1				; wipe bottom row 
0bc1			 
0bc1			 
0bc1			;	ld hl, (display_fb_active) 
0bc1			;;	ld de, display_cols*display_rows 
0bc1			;;	add hl, de 
0bc1			;	ld b, display_cols 
0bc1			;	ld a, ' ' 
0bc1			;.scwiped: 
0bc1			;	ld (hl), a 
0bc1			;	dec hl 
0bc1			;	djnz .scwiped 
0bc1			 
0bc1				;pop hl 
0bc1			 
0bc1 c1				pop bc 
0bc2 d1				pop de 
0bc3 e1				pop hl 
0bc4			 
0bc4 c9				ret 
0bc5			;scroll_down: 
0bc5			;	ld de, display_row_4 
0bc5			;	ld hl, display_row_3 
0bc5			;	ld bc, display_cols 
0bc5			;	ldir 
0bc5			;	ld de, display_row_3 
0bc5			; 	ld hl, display_row_2 
0bc5			;	ld bc, display_cols 
0bc5			;	ldir 
0bc5			;	ld de, display_row_2 
0bc5			;	ld hl, display_row_1 
0bc5			;	ld bc, display_cols 
0bc5			;	ldir 
0bc5			;;; TODO clear row 1 
0bc5			;	ret 
0bc5			 
0bc5			 
0bc5			 
0bc5			 
0bc5			 
0bc5			; clear active frame buffer 
0bc5			 
0bc5			clear_display: 
0bc5 3e 20			ld a, ' ' 
0bc7 c3 ca 0b			jp fill_display 
0bca			 
0bca			; fill active frame buffer with a char in A 
0bca			 
0bca			fill_display: 
0bca 06 a0			ld b,display_fb_len 
0bcc 2a cc eb			ld hl, (display_fb_active) 
0bcf 77			.fd1:	ld (hl),a 
0bd0 23				inc hl 
0bd1 10 fc			djnz .fd1 
0bd3 23				inc hl 
0bd4 3e 00			ld a,0 
0bd6 77				ld (hl),a 
0bd7			 
0bd7			 
0bd7 c9				ret 
0bd8			; Write string (DE) at pos (A) to active frame buffer 
0bd8			 
0bd8 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bdb 06 00					ld b,0 
0bdd 4f					ld c,a 
0bde 09					add hl,bc 
0bdf 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0be0 b7			            OR   A              ;Null terminator? 
0be1 c8			            RET  Z              ;Yes, so finished 
0be2 77					ld (hl),a 
0be3 23				inc hl 
0be4 13			            INC  DE             ;Point to next character 
0be5 18 f8		            JR   .sad1     ;Repeat 
0be7 c9					ret 
0be8			 
0be8			; using current frame buffer write to physical display 
0be8			 
0be8			update_display: 
0be8 e5				push hl 
0be9 2a cc eb			ld hl, (display_fb_active) 
0bec cd c2 5d			call write_display 
0bef e1				pop hl 
0bf0 c9				ret 
0bf1			 
0bf1			; TODO scrolling 
0bf1			 
0bf1			 
0bf1			; move cursor right one char 
0bf1			cursor_right: 
0bf1			 
0bf1				; TODO shift right 
0bf1				; TODO if beyond max col 
0bf1				; TODO       cursor_next_line 
0bf1			 
0bf1 c9				ret 
0bf2			 
0bf2			 
0bf2			cursor_next_line: 
0bf2				; TODO first char 
0bf2				; TODO line down 
0bf2				; TODO if past last row 
0bf2				; TODO    scroll up 
0bf2			 
0bf2 c9				ret 
0bf3			 
0bf3			cursor_left: 
0bf3				; TODO shift left 
0bf3				; TODO if beyond left  
0bf3				; TODO     cursor prev line 
0bf3				 
0bf3 c9				ret 
0bf4			 
0bf4			cursor_prev_line: 
0bf4				; TODO last char 
0bf4				; TODO line up 
0bf4				; TODO if past first row 
0bf4				; TODO   scroll down 
0bf4			 
0bf4 c9				ret 
0bf5			 
0bf5			 
0bf5			cout: 
0bf5				; A - char 
0bf5 c9				ret 
0bf6			 
0bf6			 
0bf6			; Display a menu and allow item selection (optional toggle items) 
0bf6			; 
0bf6			; format: 
0bf6			; hl pointer to word array with zero term for items 
0bf6			; e.g.    db item1 
0bf6			;         db .... 
0bf6			;         db 0 
0bf6			; 
0bf6			; a = starting menu item  
0bf6			; 
0bf6			; de = pointer item toggle array   (todo) 
0bf6			; 
0bf6			; returns item selected in a 1-... 
0bf6			; returns 0 if back button pressed 
0bf6			; 
0bf6			; NOTE: Uses system frame buffer to display 
0bf6			; 
0bf6			; LEFT, Q = go back 
0bf6			; RIGHT, SPACE, CR = select 
0bf6			; UP, A - Up 
0bf6			; DOWN, Z - Down 
0bf6			 
0bf6			 
0bf6			 
0bf6			 
0bf6			 
0bf6			menu: 
0bf6			 
0bf6					; keep array pointer 
0bf6			 
0bf6 22 73 ea				ld (store_tmp1), hl 
0bf9 32 71 ea				ld (store_tmp2), a 
0bfc			 
0bfc					; check for key bounce 
0bfc			 
0bfc			if BASE_KEV 
0bfc			 
0bfc			.mbounce:	call cin 
0bfc					cp 0 
0bfc					jr nz, .mbounce 
0bfc			endif 
0bfc					; for ease use ex 
0bfc			 
0bfc					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bfc 21 b1 ed				ld hl, display_fb0 
0bff 22 cc eb				ld (display_fb_active), hl 
0c02			 
0c02 cd c5 0b		.mloop:		call clear_display 
0c05 cd e8 0b				call update_display 
0c08			 
0c08					; draw selection id '>' at 1 
0c08			 
0c08					; init start of list display 
0c08			 
0c08 3e 05				ld a, 5 
0c0a 32 6f ea				ld (store_tmp3), a   ; display row count 
0c0d 3a 71 ea				ld a,( store_tmp2) 
0c10 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c13			 
0c13					 
0c13			.mitem:	 
0c13			 
0c13			 
0c13 3a 72 ea				ld a,(store_tmp2+1) 
0c16 6f					ld l, a 
0c17 26 00				ld h, 0 
0c19 29					add hl, hl 
0c1a ed 5b 73 ea			ld de, (store_tmp1) 
0c1e 19					add hl, de 
0c1f 7e					ld a, (hl) 
0c20 23					inc hl 
0c21 66					ld h,(hl) 
0c22 6f					ld l, a 
0c23			 
0c23 cd 1b 0e				call ishlzero 
0c26 28 1a				jr z, .mdone 
0c28			 
0c28 eb					ex de, hl 
0c29 3a 6f ea				ld a, (store_tmp3) 
0c2c cd d8 0b				call str_at_display 
0c2f					 
0c2f			 
0c2f					; next item 
0c2f 3a 72 ea				ld a, (store_tmp2+1) 
0c32 3c					inc a 
0c33 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c36			 
0c36			 		; next row 
0c36			 
0c36 3a 6f ea				ld a, (store_tmp3) 
0c39 c6 28				add display_cols 
0c3b 32 6f ea				ld (store_tmp3), a 
0c3e			 
0c3e					; at end of screen? 
0c3e			 
0c3e fe 10				cp display_rows*4 
0c40 20 d1				jr nz, .mitem 
0c42			 
0c42			 
0c42			.mdone: 
0c42 cd 1b 0e				call ishlzero 
0c45 28 08				jr z, .nodn 
0c47			 
0c47 3e 78				ld a, display_row_4 
0c49 11 c8 0c				ld de, .mdown 
0c4c cd d8 0b				call str_at_display 
0c4f			 
0c4f					; draw options to fill the screens with active item on line 1 
0c4f					; if current option is 2 or more then display ^ in top 
0c4f			 
0c4f 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c52 fe 00				cp 0 
0c54 28 08				jr z, .noup 
0c56			 
0c56 3e 00				ld a, 0 
0c58 11 c6 0c				ld de, .mup 
0c5b cd d8 0b				call str_at_display 
0c5e			 
0c5e 3e 02		.noup:		ld a, 2 
0c60 11 c4 0c				ld de, .msel 
0c63 cd d8 0b				call str_at_display 
0c66			 
0c66					; if current option + 1 is not null then display V in bottom 
0c66					; get key 
0c66 cd e8 0b				call update_display 
0c69			 
0c69			 
0c69					; handle key 
0c69			 
0c69 cd 74 5e				call cin_wait 
0c6c			 
0c6c fe 05				cp KEY_UP 
0c6e 28 2b				jr z, .mgoup 
0c70 fe 61				cp 'a' 
0c72 28 27				jr z, .mgoup 
0c74 fe 0a				cp KEY_DOWN 
0c76 28 32				jr z, .mgod 
0c78 fe 7a				cp 'z' 
0c7a 28 2e				jr z, .mgod 
0c7c fe 20				cp ' ' 
0c7e 28 34				jr z, .goend 
0c80 fe 0c				cp KEY_RIGHT 
0c82 28 30				jr z, .goend 
0c84 fe 0d				cp KEY_CR 
0c86 28 2c				jr z, .goend 
0c88 fe 71				cp 'q' 
0c8a 28 0b				jr z, .goback 
0c8c			 
0c8c fe 0b				cp KEY_LEFT 
0c8e 28 07				jr z, .goback 
0c90 fe 08				cp KEY_BS 
0c92 28 03				jr z, .goback 
0c94 c3 02 0c				jp .mloop 
0c97			 
0c97			.goback: 
0c97 3e 00			ld a, 0 
0c99 18 1d			jr .goend2 
0c9b			 
0c9b				; move up one 
0c9b			.mgoup: 
0c9b 3a 71 ea				ld a, (store_tmp2) 
0c9e fe 00				cp 0 
0ca0 ca 02 0c				jp z, .mloop 
0ca3 3d					dec a 
0ca4 32 71 ea				ld (store_tmp2), a 
0ca7 c3 02 0c				jp .mloop 
0caa			 
0caa				; move down one 
0caa			.mgod: 
0caa 3a 71 ea				ld a, (store_tmp2) 
0cad 3c					inc a 
0cae 32 71 ea				ld (store_tmp2), a 
0cb1 c3 02 0c				jp .mloop 
0cb4			 
0cb4			 
0cb4			.goend: 
0cb4					; get selected item number 
0cb4			 
0cb4 3a 71 ea				ld a, (store_tmp2) 
0cb7 3c					inc a 
0cb8			 
0cb8			.goend2: 
0cb8 f5					push af 
0cb9			 
0cb9					; restore active fb 
0cb9					; TODO BUG assumes fb1 
0cb9			 
0cb9 21 10 ed				ld hl, display_fb1 
0cbc 22 cc eb				ld (display_fb_active), hl 
0cbf			 
0cbf					; restore main regs 
0cbf			 
0cbf			 
0cbf cd e8 0b				call update_display 
0cc2			 
0cc2 f1					pop af 
0cc3			 
0cc3 c9				ret 
0cc4			 
0cc4 .. 00		.msel:   db ">",0 
0cc6 .. 00		.mup:   db "^",0 
0cc8 .. 00		.mdown:   db "v",0 
0cca			 
0cca			 
0cca			; eof 
0cca			 
# End of file firmware_display.asm
0cca			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cca			; random number generators 
0cca			 
0cca			 
0cca			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cca			 
0cca			 
0cca			;-----> Generate a random number 
0cca			; output a=answer 0<=a<=255 
0cca			; all registers are preserved except: af 
0cca			random: 
0cca e5			        push    hl 
0ccb d5			        push    de 
0ccc 2a ab eb		        ld      hl,(randData) 
0ccf ed 5f		        ld      a,r 
0cd1 57			        ld      d,a 
0cd2 5e			        ld      e,(hl) 
0cd3 19			        add     hl,de 
0cd4 85			        add     a,l 
0cd5 ac			        xor     h 
0cd6 22 ab eb		        ld      (randData),hl 
0cd9 d1			        pop     de 
0cda e1			        pop     hl 
0cdb c9			        ret 
0cdc			 
0cdc			 
0cdc			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cdc			 
0cdc			 
0cdc			 
0cdc			;------LFSR------ 
0cdc			;James Montelongo 
0cdc			;optimized by Spencer Putt 
0cdc			;out: 
0cdc			; a = 8 bit random number 
0cdc			RandLFSR: 
0cdc 21 b1 eb		        ld hl,LFSRSeed+4 
0cdf 5e			        ld e,(hl) 
0ce0 23			        inc hl 
0ce1 56			        ld d,(hl) 
0ce2 23			        inc hl 
0ce3 4e			        ld c,(hl) 
0ce4 23			        inc hl 
0ce5 7e			        ld a,(hl) 
0ce6 47			        ld b,a 
0ce7 cb 13		        rl e  
0ce9 cb 12			rl d 
0ceb cb 11		        rl c  
0ced 17				rla 
0cee cb 13		        rl e  
0cf0 cb 12			rl d 
0cf2 cb 11		        rl c  
0cf4 17				rla 
0cf5 cb 13		        rl e  
0cf7 cb 12			rl d 
0cf9 cb 11		        rl c  
0cfb 17				rla 
0cfc 67			        ld h,a 
0cfd cb 13		        rl e  
0cff cb 12			rl d 
0d01 cb 11		        rl c  
0d03 17				rla 
0d04 a8			        xor b 
0d05 cb 13		        rl e  
0d07 cb 12			rl d 
0d09 ac			        xor h 
0d0a a9			        xor c 
0d0b aa			        xor d 
0d0c 21 b3 eb		        ld hl,LFSRSeed+6 
0d0f 11 b4 eb		        ld de,LFSRSeed+7 
0d12 01 07 00		        ld bc,7 
0d15 ed b8		        lddr 
0d17 12			        ld (de),a 
0d18 c9			        ret 
0d19			 
0d19			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d19			 
0d19			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d19			 
0d19			 
0d19			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d19			 
0d19			prng16: 
0d19			;Inputs: 
0d19			;   (seed1) contains a 16-bit seed value 
0d19			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d19			;Outputs: 
0d19			;   HL is the result 
0d19			;   BC is the result of the LCG, so not that great of quality 
0d19			;   DE is preserved 
0d19			;Destroys: 
0d19			;   AF 
0d19			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d19			;160cc 
0d19			;26 bytes 
0d19 2a a5 eb		    ld hl,(seed1) 
0d1c 44			    ld b,h 
0d1d 4d			    ld c,l 
0d1e 29			    add hl,hl 
0d1f 29			    add hl,hl 
0d20 2c			    inc l 
0d21 09			    add hl,bc 
0d22 22 a5 eb		    ld (seed1),hl 
0d25 2a a3 eb		    ld hl,(seed2) 
0d28 29			    add hl,hl 
0d29 9f			    sbc a,a 
0d2a e6 2d		    and %00101101 
0d2c ad			    xor l 
0d2d 6f			    ld l,a 
0d2e 22 a3 eb		    ld (seed2),hl 
0d31 09			    add hl,bc 
0d32 c9			    ret 
0d33			 
0d33			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d33			 
0d33			rand32: 
0d33			;Inputs: 
0d33			;   (seed1_0) holds the lower 16 bits of the first seed 
0d33			;   (seed1_1) holds the upper 16 bits of the first seed 
0d33			;   (seed2_0) holds the lower 16 bits of the second seed 
0d33			;   (seed2_1) holds the upper 16 bits of the second seed 
0d33			;   **NOTE: seed2 must be non-zero 
0d33			;Outputs: 
0d33			;   HL is the result 
0d33			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d33			;Destroys: 
0d33			;   AF 
0d33			;Tested and passes all CAcert tests 
0d33			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d33			;it has a period of 18,446,744,069,414,584,320 
0d33			;roughly 18.4 quintillion. 
0d33			;LFSR taps: 0,2,6,7  = 11000101 
0d33			;291cc 
0d33			;seed1_0=$+1 
0d33			;    ld hl,12345 
0d33			;seed1_1=$+1 
0d33			;    ld de,6789 
0d33			;    ld b,h 
0d33			;    ld c,l 
0d33			;    add hl,hl \ rl e \ rl d 
0d33			;    add hl,hl \ rl e \ rl d 
0d33			;    inc l 
0d33			;    add hl,bc 
0d33			;    ld (seed1_0),hl 
0d33			;    ld hl,(seed1_1) 
0d33			;    adc hl,de 
0d33			;    ld (seed1_1),hl 
0d33			;    ex de,hl 
0d33			;seed2_0=$+1 
0d33			;    ld hl,9876 
0d33			;seed2_1=$+1 
0d33			;    ld bc,54321 
0d33			;    add hl,hl \ rl c \ rl b 
0d33			;    ld (seed2_1),bc 
0d33			;    sbc a,a 
0d33			;    and %11000101 
0d33			;    xor l 
0d33			;    ld l,a 
0d33			;    ld (seed2_0),hl 
0d33			;    ex de,hl 
0d33			;    add hl,bc 
0d33			;    ret 
0d33			; 
0d33			 
0d33			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d33			; 20 bytes, 86 cycles (excluding ret) 
0d33			 
0d33			; returns   hl = pseudorandom number 
0d33			; corrupts   a 
0d33			 
0d33			; generates 16-bit pseudorandom numbers with a period of 65535 
0d33			; using the xorshift method: 
0d33			 
0d33			; hl ^= hl << 7 
0d33			; hl ^= hl >> 9 
0d33			; hl ^= hl << 8 
0d33			 
0d33			; some alternative shift triplets which also perform well are: 
0d33			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d33			 
0d33			;  org 32768 
0d33			 
0d33			xrnd: 
0d33 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d36 3e 00		  ld a,0 
0d38 bd			  cp l 
0d39 20 02		  jr nz, .xrnd1 
0d3b 2e 01		  ld l, 1 
0d3d			.xrnd1: 
0d3d			 
0d3d 7c			  ld a,h 
0d3e 1f			  rra 
0d3f 7d			  ld a,l 
0d40 1f			  rra 
0d41 ac			  xor h 
0d42 67			  ld h,a 
0d43 7d			  ld a,l 
0d44 1f			  rra 
0d45 7c			  ld a,h 
0d46 1f			  rra 
0d47 ad			  xor l 
0d48 6f			  ld l,a 
0d49 ac			  xor h 
0d4a 67			  ld h,a 
0d4b			 
0d4b 22 a9 eb		  ld (xrandc),hl 
0d4e			 
0d4e c9			  ret 
0d4f			;  
0d4f			 
0d4f			 
0d4f			;;;; int maths 
0d4f			 
0d4f			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d4f			; Divide 16-bit values (with 16-bit result) 
0d4f			; In: Divide BC by divider DE 
0d4f			; Out: BC = result, HL = rest 
0d4f			; 
0d4f			Div16: 
0d4f 21 00 00		    ld hl,0 
0d52 78			    ld a,b 
0d53 06 08		    ld b,8 
0d55			Div16_Loop1: 
0d55 17			    rla 
0d56 ed 6a		    adc hl,hl 
0d58 ed 52		    sbc hl,de 
0d5a 30 01		    jr nc,Div16_NoAdd1 
0d5c 19			    add hl,de 
0d5d			Div16_NoAdd1: 
0d5d 10 f6		    djnz Div16_Loop1 
0d5f 17			    rla 
0d60 2f			    cpl 
0d61 47			    ld b,a 
0d62 79			    ld a,c 
0d63 48			    ld c,b 
0d64 06 08		    ld b,8 
0d66			Div16_Loop2: 
0d66 17			    rla 
0d67 ed 6a		    adc hl,hl 
0d69 ed 52		    sbc hl,de 
0d6b 30 01		    jr nc,Div16_NoAdd2 
0d6d 19			    add hl,de 
0d6e			Div16_NoAdd2: 
0d6e 10 f6		    djnz Div16_Loop2 
0d70 17			    rla 
0d71 2f			    cpl 
0d72 41			    ld b,c 
0d73 4f			    ld c,a 
0d74 c9			ret 
0d75			 
0d75			 
0d75			;http://z80-heaven.wikidot.com/math 
0d75			; 
0d75			;Inputs: 
0d75			;     DE and A are factors 
0d75			;Outputs: 
0d75			;     A is not changed 
0d75			;     B is 0 
0d75			;     C is not changed 
0d75			;     DE is not changed 
0d75			;     HL is the product 
0d75			;Time: 
0d75			;     342+6x 
0d75			; 
0d75			Mult16: 
0d75			 
0d75 06 08		     ld b,8          ;7           7 
0d77 21 00 00		     ld hl,0         ;10         10 
0d7a 29			       add hl,hl     ;11*8       88 
0d7b 07			       rlca          ;4*8        32 
0d7c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d7e 19			         add hl,de   ;--         -- 
0d7f 10 f9		       djnz $-5      ;13*7+8     99 
0d81 c9			ret 
0d82			 
0d82			; 
0d82			; Square root of 16-bit value 
0d82			; In:  HL = value 
0d82			; Out:  D = result (rounded down) 
0d82			; 
0d82			;Sqr16: 
0d82			;    ld de,#0040 
0d82			;    ld a,l 
0d82			;    ld l,h 
0d82			;    ld h,d 
0d82			;    or a 
0d82			;    ld b,8 
0d82			;Sqr16_Loop: 
0d82			;    sbc hl,de 
0d82			;    jr nc,Sqr16_Skip 
0d82			;    add hl,de 
0d82			;Sqr16_Skip: 
0d82			;    ccf 
0d82			;    rl d 
0d82			;    add a,a 
0d82			;    adc hl,hl 
0d82			;    add a,a 
0d82			;    adc hl,hl 
0d82			;    djnz Sqr16_Loop 
0d82			;    ret 
0d82			; 
0d82			; 
0d82			; Divide 8-bit values 
0d82			; In: Divide E by divider C 
0d82			; Out: A = result, B = rest 
0d82			; 
0d82			Div8: 
0d82 af			    xor a 
0d83 06 08		    ld b,8 
0d85			Div8_Loop: 
0d85 cb 13		    rl e 
0d87 17			    rla 
0d88 91			    sub c 
0d89 30 01		    jr nc,Div8_NoAdd 
0d8b 81			    add a,c 
0d8c			Div8_NoAdd: 
0d8c 10 f7		    djnz Div8_Loop 
0d8e 47			    ld b,a 
0d8f 7b			    ld a,e 
0d90 17			    rla 
0d91 2f			    cpl 
0d92 c9			    ret 
0d93			 
0d93			; 
0d93			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d93			; In: Multiply A with DE 
0d93			; Out: HL = result 
0d93			; 
0d93			Mult12U: 
0d93 2e 00		    ld l,0 
0d95 87			    add a,a 
0d96 30 01		    jr nc,Mult12U_NoAdd0 
0d98 19			    add hl,de 
0d99			Mult12U_NoAdd0: 
0d99 29			    add hl,hl 
0d9a 87			    add a,a 
0d9b 30 01		    jr nc,Mult12U_NoAdd1 
0d9d 19			    add hl,de 
0d9e			Mult12U_NoAdd1: 
0d9e 29			    add hl,hl 
0d9f 87			    add a,a 
0da0 30 01		    jr nc,Mult12U_NoAdd2 
0da2 19			    add hl,de 
0da3			Mult12U_NoAdd2: 
0da3 29			    add hl,hl 
0da4 87			    add a,a 
0da5 30 01		    jr nc,Mult12U_NoAdd3 
0da7 19			    add hl,de 
0da8			Mult12U_NoAdd3: 
0da8 29			    add hl,hl 
0da9 87			    add a,a 
0daa 30 01		    jr nc,Mult12U_NoAdd4 
0dac 19			    add hl,de 
0dad			Mult12U_NoAdd4: 
0dad 29			    add hl,hl 
0dae 87			    add a,a 
0daf 30 01		    jr nc,Mult12U_NoAdd5 
0db1 19			    add hl,de 
0db2			Mult12U_NoAdd5: 
0db2 29			    add hl,hl 
0db3 87			    add a,a 
0db4 30 01		    jr nc,Mult12U_NoAdd6 
0db6 19			    add hl,de 
0db7			Mult12U_NoAdd6: 
0db7 29			    add hl,hl 
0db8 87			    add a,a 
0db9 d0			    ret nc 
0dba 19			    add hl,de 
0dbb c9			    ret 
0dbc			 
0dbc			; 
0dbc			; Multiply 8-bit value with a 16-bit value (right rotating) 
0dbc			; In: Multiply A with DE 
0dbc			;      Put lowest value in A for most efficient calculation 
0dbc			; Out: HL = result 
0dbc			; 
0dbc			Mult12R: 
0dbc 21 00 00		    ld hl,0 
0dbf			Mult12R_Loop: 
0dbf cb 3f		    srl a 
0dc1 30 01		    jr nc,Mult12R_NoAdd 
0dc3 19			    add hl,de 
0dc4			Mult12R_NoAdd: 
0dc4 cb 23		    sla e 
0dc6 cb 12		    rl d 
0dc8 b7			    or a 
0dc9 c2 bf 0d		    jp nz,Mult12R_Loop 
0dcc c9			    ret 
0dcd			 
0dcd			; 
0dcd			; Multiply 16-bit values (with 32-bit result) 
0dcd			; In: Multiply BC with DE 
0dcd			; Out: BCHL = result 
0dcd			; 
0dcd			Mult32: 
0dcd 79			    ld a,c 
0dce 48			    ld c,b 
0dcf 21 00 00		    ld hl,0 
0dd2 06 10		    ld b,16 
0dd4			Mult32_Loop: 
0dd4 29			    add hl,hl 
0dd5 17			    rla 
0dd6 cb 11		    rl c 
0dd8 30 07		    jr nc,Mult32_NoAdd 
0dda 19			    add hl,de 
0ddb ce 00		    adc a,0 
0ddd d2 e1 0d		    jp nc,Mult32_NoAdd 
0de0 0c			    inc c 
0de1			Mult32_NoAdd: 
0de1 10 f1		    djnz Mult32_Loop 
0de3 41			    ld b,c 
0de4 4f			    ld c,a 
0de5 c9			    ret 
0de6			 
0de6			 
0de6			 
0de6			; 
0de6			; Multiply 8-bit values 
0de6			; In:  Multiply H with E 
0de6			; Out: HL = result 
0de6			; 
0de6			Mult8: 
0de6 16 00		    ld d,0 
0de8 6a			    ld l,d 
0de9 06 08		    ld b,8 
0deb			Mult8_Loop: 
0deb 29			    add hl,hl 
0dec 30 01		    jr nc,Mult8_NoAdd 
0dee 19			    add hl,de 
0def			Mult8_NoAdd: 
0def 10 fa		    djnz Mult8_Loop 
0df1 c9			    ret 
0df2			 
0df2			 
0df2			 
0df2			 
0df2			 
0df2			 
0df2			 
0df2			 
0df2			;;http://z80-heaven.wikidot.com/math 
0df2			;;This divides DE by BC, storing the result in DE, remainder in HL 
0df2			; 
0df2			;DE_Div_BC:          ;1281-2x, x is at most 16 
0df2			;     ld a,16        ;7 
0df2			;     ld hl,0        ;10 
0df2			;     jp $+5         ;10 
0df2			;.DivLoop: 
0df2			;       add hl,bc    ;-- 
0df2			;       dec a        ;64 
0df2			;       jr z,.DivLoopEnd        ;86 
0df2			; 
0df2			;       sla e        ;128 
0df2			;       rl d         ;128 
0df2			;       adc hl,hl    ;240 
0df2			;       sbc hl,bc    ;240 
0df2			;       jr nc,.DivLoop ;23|21 
0df2			;       inc e        ;-- 
0df2			;       jp .DivLoop+1 
0df2			; 
0df2			;.DivLoopEnd: 
0df2			 
0df2			;HL_Div_C: 
0df2			;Inputs: 
0df2			;     HL is the numerator 
0df2			;     C is the denominator 
0df2			;Outputs: 
0df2			;     A is the remainder 
0df2			;     B is 0 
0df2			;     C is not changed 
0df2			;     DE is not changed 
0df2			;     HL is the quotient 
0df2			; 
0df2			;       ld b,16 
0df2			;       xor a 
0df2			;         add hl,hl 
0df2			;         rla 
0df2			;         cp c 
0df2			;         jr c,$+4 
0df2			;           inc l 
0df2			;           sub c 
0df2			;         djnz $-7 
0df2			 
0df2			; https://plutiedev.com/z80-add-8bit-to-16bit 
0df2			 
0df2			addatohl: 
0df2 85			    add   a, l    ; A = A+L 
0df3 6f			    ld    l, a    ; L = A+L 
0df4 8c			    adc   a, h    ; A = A+L+H+carry 
0df5 95			    sub   l       ; A = H+carry 
0df6 67			    ld    h, a    ; H = H+carry 
0df7 c9			ret 
0df8			 
0df8			addatode: 
0df8 83			    add   a, e    ; A = A+L 
0df9 5f			    ld    e, a    ; L = A+L 
0dfa 8a			    adc   a, d    ; A = A+L+H+carry 
0dfb 93			    sub   e       ; A = H+carry 
0dfc 57			    ld    d, a    ; H = H+carry 
0dfd c9			ret 
0dfe			 
0dfe			 
0dfe			addatobc: 
0dfe 81			    add   a, c    ; A = A+L 
0dff 4f			    ld    c, a    ; L = A+L 
0e00 88			    adc   a, b    ; A = A+L+H+carry 
0e01 91			    sub   c       ; A = H+carry 
0e02 47			    ld    b, a    ; H = H+carry 
0e03 c9			ret 
0e04			 
0e04			subafromhl: 
0e04			   ; If A=0 do nothing 
0e04			    ; Otherwise flip A's sign. Since 
0e04			    ; the upper byte becomes -1, also 
0e04			    ; substract 1 from H. 
0e04 ed 44		    neg 
0e06 ca 0f 0e		    jp    z, Skip 
0e09 25			    dec   h 
0e0a			     
0e0a			    ; Now add the low byte as usual 
0e0a			    ; Two's complement takes care of 
0e0a			    ; ensuring the result is correct 
0e0a 85			    add   a, l 
0e0b 6f			    ld    l, a 
0e0c 8c			    adc   a, h 
0e0d 95			    sub   l 
0e0e 67			    ld    h, a 
0e0f			Skip: 
0e0f c9				ret 
0e10			 
0e10			 
0e10			; compare hl and de 
0e10			; returns:  
0e10			; if hl = de, z=1, s=0, c0=0 
0e10			; if hl > de, z=0, s=0, c=0 
0e10			; if hl < de, z=0, s=1, c=1 
0e10			cmp16:	 
0e10 b7				or a 
0e11 ed 52			sbc hl,de 
0e13 e0				ret po 
0e14 7c				ld a,h 
0e15 1f				rra 
0e16 ee 40			xor 01000000B 
0e18 37				scf 
0e19 8f				adc a,a 
0e1a c9				ret 
0e1b			 
0e1b			 
0e1b			; test if hl contains zero   - A is destroyed 
0e1b			 
0e1b			ishlzero:    
0e1b b7				or a     ; reset flags 
0e1c 7c				ld a, h 
0e1d b5				or l        	 
0e1e			 
0e1e c9				ret 
0e1f			 
0e1f			 
0e1f			 
0e1f			 
0e1f			if FORTH_ENABLE_FLOATMATH 
0e1f			;include "float/bbcmath.z80" 
0e1f			include "float/lpfpcalc.asm" 
0e1f			endif 
0e1f			 
0e1f			 
0e1f			; eof 
0e1f			 
# End of file firmware_maths.asm
0e1f			include "firmware_strings.asm"   ; string handling  
0e1f			 
0e1f			 
0e1f			; TODO string len 
0e1f			; input text string, end on cr with zero term 
0e1f			; a offset into frame buffer to start prompt 
0e1f			; d is max length 
0e1f			; e is display size TODO 
0e1f			; c is current cursor position 
0e1f			; hl is ptr to where string will be stored and edited directly 
0e1f			 
0e1f			 
0e1f			; TODO check limit of buffer for new inserts 
0e1f			; TODO check insert does not push beyond buffer 
0e1f			; TODO scroll in a limited display area 
0e1f			; TODO scroll whole screen on page wrap 
0e1f			 
0e1f			 
0e1f			; TODO use LCD cursor? 
0e1f			 
0e1f			EDIT_V1: equ 0 
0e1f			EDIT_V2: equ 1 
0e1f			 
0e1f			 
0e1f			 
0e1f			if EDIT_V2 
0e1f			input_str: 
0e1f			 
0e1f 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
0e22			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e22 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e25			;		ld a, c 
0e25			;		call addatohl 
0e25			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e25 7a					ld a,d 
0e26 32 66 ee			        ld (input_size), a       ; save length of input area 
0e29 79					ld a, c 
0e2a 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e2d 7b					ld a,e 
0e2e 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e31			 
0e31			 
0e31					; add a trailing space to make screen refresh nicer 
0e31			 
0e31					;ld hl, (input_start) 
0e31					;push hl 
0e31					;ld a, 0 
0e31					;call strlent 
0e31					;ld a, l 
0e31					;pop hl 
0e31					;call addatohl 
0e31					;dec hl 
0e31					;ld a, ' ' 
0e31					;ld (hl), a 
0e31					;inc hl 
0e31					;ld (hl), a 
0e31					;inc hl 
0e31					;ld a, 0 
0e31					;ld (hl), a 
0e31			 
0e31			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e31					; init cursor shape if not set by the cin routines 
0e31 21 c1 eb				ld hl, cursor_shape 
0e34			if BASE_KEV 
0e34					ld a, 255 
0e34			else 
0e34 3e 23				ld a, '#' 
0e36			endif 
0e36 77					ld (hl), a 
0e37 23					inc hl 
0e38 3e 00				ld a, 0 
0e3a 77					ld (hl), a 
0e3b			 
0e3b 3e 09				ld a, CUR_BLINK_RATE 
0e3d 32 60 ee				ld (input_cur_flash), a 
0e40 3e 01				ld a, 1 
0e42 32 5f ee				ld (input_cur_onoff),a 
0e45			.inmain:	 
0e45			 
0e45 cd 6d 0f				call input_disp_ref 
0e48			 
0e48					; save current length of string 
0e48			 
0e48 2a 67 ee				ld hl, (input_start) 
0e4b 3e 00				ld a, 0 
0e4d cd 63 11				call strlent 
0e50 7d					ld a,l 
0e51 32 5a ee				ld (input_len), a 
0e54			 
0e54					;call input_disp_oncur 
0e54			 
0e54					; display current state of input buffer 
0e54			 
0e54					; clean any backspace chars 
0e54			 
0e54 3e 20				ld a, " " 
0e56 32 c1 e2				ld (scratch),a 
0e59 3e 00				ld a, 0 
0e5b 32 c2 e2				ld (scratch+1),a 
0e5e 3a 64 ee				ld a,(input_at_pos) 
0e61 85					add l 
0e62 11 c1 e2				ld de, scratch 
0e65 cd d8 0b				call str_at_display 
0e68			 
0e68					; pause 1ms 
0e68			 
0e68 3e 01				ld a, 1 
0e6a cd e2 0a				call aDelayInMS 
0e6d			 
0e6d			; display cursor if visible on this cycle 
0e6d			 
0e6d					; dec flash counter 
0e6d 3a 60 ee				ld a, (input_cur_flash) 
0e70 3d					dec a 
0e71 32 60 ee				ld (input_cur_flash), a 
0e74 fe 00				cp 0 
0e76 20 0d				jr nz, .inochgstate 
0e78			 
0e78			 
0e78					; reset on change of state 
0e78 3e 09				ld a, CUR_BLINK_RATE 
0e7a 32 60 ee				ld (input_cur_flash), a 
0e7d			 
0e7d					; change state 
0e7d 3a 5f ee				ld a,(input_cur_onoff) 
0e80 ed 44				neg 
0e82 32 5f ee				ld (input_cur_onoff),a 
0e85			 
0e85			 
0e85			 
0e85			 
0e85					; TODO is cursor visible? 
0e85					; TODO if so then over write the char at curspos pos with the cursor shape 
0e85			 
0e85								 
0e85			 
0e85			.inochgstate: 
0e85 3a 5f ee				ld a,(input_cur_onoff) 
0e88 fe ff				cp 255 
0e8a 28 0e				jr z, .skipcursor 
0e8c 3a 64 ee				ld a, (input_at_pos) 
0e8f 47					ld b, a 
0e90 3a 55 ee				ld a, (input_cursor) 
0e93 80					add b 
0e94 11 c1 eb				ld de, cursor_shape 
0e97					 
0e97 cd d8 0b				call str_at_display 
0e9a			 
0e9a			.skipcursor: 
0e9a				if DEBUG_INPUTV2 
0e9a			 
0e9a					ld a,(input_at_pos) 
0e9a					ld hl, LFSRSeed 
0e9a					call hexout 
0e9a					ld a, (input_cursor) 
0e9a					ld hl, LFSRSeed+2 
0e9a					call hexout 
0e9a					ld a,(input_size) 
0e9a					ld hl, LFSRSeed+4 
0e9a					call hexout 
0e9a			 
0e9a					ld a,(input_cur_onoff) 
0e9a					ld hl, LFSRSeed+6 
0e9a					call hexout 
0e9a			 
0e9a					ld a,(input_cur_flash) 
0e9a					ld hl, LFSRSeed+8 
0e9a					call hexout 
0e9a			 
0e9a					ld a,(input_len) 
0e9a					ld hl, LFSRSeed+10 
0e9a					call hexout 
0e9a					ld hl, LFSRSeed+12 
0e9a					ld a, 0 
0e9a					ld (hl),a 
0e9a					ld a, display_row_4 
0e9a					ld de, LFSRSeed 
0e9a					call str_at_display 
0e9a				endif 
0e9a cd e8 0b				call update_display 
0e9d			 
0e9d					; TODO keyboard processing 
0e9d			 
0e9d			if BASE_CPM 
0e9d cd 74 5e				call cin_wait 
0ea0			else 
0ea0					call cin    ; _wait 
0ea0			endif 
0ea0 fe 00				cp 0 
0ea2 ca 45 0e				jp z, .inmain 
0ea5			 
0ea5 fe 0b				cp KEY_LEFT    ; cursor left 
0ea7 ca 5f 0f				jp z, input_left 
0eaa				 
0eaa fe 0c				cp KEY_RIGHT      ; cursor right 
0eac ca 66 0f				jp z, input_right 
0eaf			 
0eaf fe 0d				cp KEY_CR 
0eb1 c8					ret z 
0eb2			 
0eb2 fe 08				cp KEY_BS 
0eb4 ca d4 0f				jp z, input_delchar 
0eb7			 
0eb7 fe 06				cp KEY_NEXTWORD 
0eb9 ca e0 0e				jp z, input_nxtword 
0ebc			 
0ebc fe 07				cp KEY_PREVWORD 
0ebe ca 07 0f				jp z, input_prvword 
0ec1			 
0ec1 fe 0e				cp KEY_HOME    ; jump to start of line 
0ec3 20 08				jr nz, .ikh 
0ec5 3e 00				ld a, 0 
0ec7 32 55 ee				ld (input_cursor), a 
0eca ca 45 0e				jp z, .inmain 
0ecd			.ikh: 
0ecd			 
0ecd fe 0f				cp KEY_END     ; jump to end of line 
0ecf 20 09				jr nz, .ike 
0ed1 3a 5a ee				ld a, (input_len) 
0ed4 32 55 ee				ld (input_cursor),a 
0ed7 ca 45 0e				jp z, .inmain 
0eda			.ike: 
0eda fe 05			        cp KEY_UP      ; recall last command 
0edc c8					ret z 
0edd			;jr nz, .irec 
0edd			; TODO next word 
0edd			; TODO prev word 
0edd			;  
0edd			; 
0edd			;	ld hl, scratch 
0edd			;	ld de, os_last_cmd 
0edd			;	call strcpy 
0edd			;		jp  .inmain 
0edd			.irec: 
0edd			;		jr .instr1 
0edd			 
0edd			 
0edd			 
0edd					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
0edd			 
0edd			; TODO return if any special keys are given 
0edd			;		ld l, a 
0edd			;		ld a, 28 ; KEY_F12   ; 27 
0edd			;		sub l 
0edd			;		ret m 
0edd			;		ld a, l 
0edd					; if no special key then insert as a char 
0edd			 
0edd c3 a6 0f				jp input_inschr 
0ee0			 
0ee0				 
0ee0			input_nxtword: 
0ee0				; jump to start next word after the cursor 
0ee0			 
0ee0			.insknwn:	 
0ee0 cd 9c 0f				call input_curptr	 
0ee3 7e					ld a,(hl)	 
0ee4 fe 00				cp 0 
0ee6 ca 45 0e				jp z, .inmain    ; end of string 
0ee9			 
0ee9			; if we are on a word, then move off of it 
0ee9			 
0ee9 fe 20				cp ' ' 
0eeb 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0eed 21 55 ee				ld hl, input_cursor 
0ef0 34					inc (hl) 
0ef1 18 ed				jr .insknwn 
0ef3			 
0ef3			.inspace: 
0ef3			 
0ef3 cd 9c 0f				call input_curptr	 
0ef6 7e					ld a,(hl)	 
0ef7 fe 00				cp 0 
0ef9 ca 45 0e				jp z, .inmain    ; end of string 
0efc			 
0efc			; if we are on a word, then move off of it 
0efc			 
0efc fe 20				cp ' ' 
0efe c2 45 0e				jp nz, .inmain     ; we are on non space so at next word 
0f01 21 55 ee				ld hl, input_cursor 
0f04 34					inc (hl) 
0f05 18 ec				jr .inspace 
0f07			 
0f07			 
0f07			 
0f07			 
0f07			input_prvword: 
0f07				; jump to the start of previous word before the cursor 
0f07			 
0f07			; where are we to start with currently? 
0f07			 
0f07 cd 9c 0f				call input_curptr	 
0f0a 7e					ld a, (hl) 
0f0b fe 20				cp ' ' 
0f0d 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0f0f			 
0f0f			 
0f0f			 
0f0f			.inskpwn:	 
0f0f 3a 55 ee				ld a,(input_cursor) 
0f12 fe 00				cp 0 
0f14 ca 45 0e				jp z, .inmain    ; start of string 
0f17			 
0f17			;if we are on a word, then move off of it 
0f17			 
0f17 cd 9c 0f				call input_curptr	 
0f1a 7e					ld a, (hl) 
0f1b fe 20				cp ' ' 
0f1d 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
0f1f					;jp z, .inmain    ; start of string 
0f1f 21 55 ee				ld hl, input_cursor 
0f22 35					dec (hl) 
0f23 18 ea				jr .inskpwn 
0f25			.iwstart: 
0f25 21 55 ee				ld hl, input_cursor 
0f28 34					inc (hl) 
0f29 c3 45 0e				jp .inmain 
0f2c					 
0f2c			 
0f2c			.inspacep: 
0f2c			 
0f2c					;jp .inmain    ; start of string 
0f2c			 
0f2c			 
0f2c			 
0f2c 3a 55 ee				ld a,(input_cursor) 
0f2f fe 00				cp 0 
0f31 ca 45 0e				jp z, .inmain    ; start of string 
0f34			 
0f34			; if we are on a word, then move off of it 
0f34			 
0f34 cd 9c 0f				call input_curptr	 
0f37 7e					ld a, (hl) 
0f38 fe 20				cp ' ' 
0f3a c2 43 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f3d 21 55 ee				ld hl, input_cursor 
0f40 35					dec (hl) 
0f41 18 e9				jr .inspacep 
0f43			 
0f43			 
0f43			.incharp:	 
0f43					; eat the word to get to the start 
0f43 3a 55 ee				ld a,(input_cursor) 
0f46 fe 00				cp 0 
0f48 ca 45 0e				jp z, .inmain    ; start of string 
0f4b			 
0f4b			; if we are on a word, then move off of it 
0f4b			 
0f4b cd 9c 0f				call input_curptr	 
0f4e 7e					ld a, (hl) 
0f4f fe 20				cp ' ' 
0f51 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f53 21 55 ee				ld hl, input_cursor 
0f56 35					dec (hl) 
0f57 18 ea				jr .incharp 
0f59			.ipwordst: 
0f59					; at space before the prev word so reposition over it 
0f59 21 55 ee				ld hl, input_cursor 
0f5c 34					inc (hl) 
0f5d 18 b0				jr .inskpwn 
0f5f					 
0f5f			 
0f5f			 
0f5f			input_left: 
0f5f				; move cursor left 
0f5f 21 55 ee			ld hl, input_cursor 
0f62 35				dec (hl) 
0f63			;	cp 0 
0f63			;	jp z, .inmain    ; ignore left as at the start of the string 
0f63 c3 45 0e			jp .inmain 
0f66			 
0f66			input_right: 
0f66				; move cursor right 
0f66				 
0f66				;ld a, (input_size) 
0f66				;ld b, a 
0f66 21 55 ee			ld hl, input_cursor 
0f69 34				inc (hl) 
0f6a				;dec b 
0f6a				;cp 0 
0f6a				;jp z, .inmain   ; ignore as at end of the string buffer 
0f6a				;ld a, b 
0f6a				;inc a 
0f6a				;ld (input_cursor), a 
0f6a c3 45 0e			jp .inmain 
0f6d			 
0f6d			 
0f6d			 
0f6d			input_disp_ref: 
0f6d				; display the text from start of buffer (ie full refresh) 
0f6d 3a 64 ee			ld a, (input_at_pos) 
0f70 2a 67 ee			ld hl,(input_start) 
0f73 eb				ex de, hl 
0f74 cd d8 0b			call str_at_display  
0f77 c9				ret 
0f78			input_disp_oncur: 
0f78				; display the text from cursor position to end of buffer 
0f78				; TODO position start of string at cursor position on screen 
0f78				; TODO draw from that point on 
0f78 3a 55 ee			ld a, (input_cursor) 
0f7b 47				ld b, a 
0f7c 3a 64 ee			ld a, (input_at_pos) 
0f7f 80				add b 
0f80 48				ld c, b     ; save a 
0f81 78				ld a, b     ; inc string start for cursor 
0f82 2a 67 ee			ld hl,(input_start) 
0f85 cd f2 0d			call addatohl 
0f88 eb				ex de, hl 
0f89 79				ld a, c 
0f8a cd d8 0b			call str_at_display  
0f8d c9				ret 
0f8e			 
0f8e			input_nxtw: 
0f8e				; Find next word 
0f8e c9				ret 
0f8f			 
0f8f			input_prvw: 
0f8f				; Find previous word 
0f8f c9				ret 
0f90			 
0f90			input_lenrem:   
0f90				; Calculate the length of string remaining from current cursor 
0f90				; position to end of buffer (exc null term) 
0f90				 
0f90 3a 55 ee			ld a, (input_cursor) 
0f93 4f				ld c, a 
0f94 3a 66 ee			ld a, (input_size) 
0f97 91				sub c 
0f98 06 00			ld b, 0 
0f9a 0d				dec c 
0f9b c9				ret	 
0f9c			 
0f9c			input_curptr: 
0f9c				; calc address of the character under the cursor 
0f9c				 
0f9c 2a 67 ee			ld hl, (input_start) 
0f9f 3a 55 ee			ld a, (input_cursor) 
0fa2 cd f2 0d			call addatohl 
0fa5 c9				ret 
0fa6			 
0fa6			input_inschr: 
0fa6				; Insert char at cursor position 
0fa6 f5				push af   ; save char 
0fa7				;call input_lenrem    ; get bc length of remaining string 
0fa7			 
0fa7				 
0fa7 cd 9c 0f			call input_curptr 
0faa			;	ld hl, (input_start) 
0faa			;	ld a, (input_cursor) 
0faa			;	call addatohl 
0faa				;push hl   ; save to come back to 
0faa			 
0faa				; shift everything up one to end of buffer 
0faa			 
0faa				;push hl 
0faa				;dec de 
0faa				;inc de 
0faa			;	ldir 
0faa				 
0faa				;pop hl 
0faa			 
0faa				; are we adding to the end of line? 
0faa			 
0faa 3a 55 ee			ld a, (input_cursor) 
0fad 47				ld b, a 
0fae 3a 5a ee			ld a, (input_len) 
0fb1 b8				cp b 
0fb2 20 09			jr nz, .insmid   ; no, insert in middle of text 
0fb4			 
0fb4				; tack on the end of the line 
0fb4 f1				pop af 
0fb5 77				ld (hl), a   ; save new char 
0fb6 23				inc hl 
0fb7 3e 00			ld a, 0 
0fb9 77				ld (hl), a 
0fba c3 66 0f			jp input_right 
0fbd				 
0fbd			.insmid: 
0fbd				; hl has insertion point so move everything up one to allow for insertion 
0fbd				;call input_shiftright 
0fbd f1				pop af 
0fbe			 
0fbe			.shufinsmid: 
0fbe 47				ld b, a     ; b contains new char, c prev char at this position  
0fbf 7e				ld a, (hl) 
0fc0			 
0fc0 fe 00			cp 0    ; at end of string need to then dump new char and add term 
0fc2 28 07			jr z, .endinsmid 
0fc4 4f				ld c, a 
0fc5 78				ld a, b 
0fc6 77				ld (hl), a 
0fc7 23				inc hl 
0fc8 79				ld a, c 
0fc9 18 f3			jr .shufinsmid 
0fcb				 
0fcb			 
0fcb			 
0fcb			 
0fcb			.endinsmid: 
0fcb 78				ld a, b 
0fcc 77				ld (hl), a 
0fcd 23				inc hl 
0fce 3e 00			ld a, 0 
0fd0 77				ld (hl), a 
0fd1			 
0fd1			 
0fd1			;	ld (hl), a   ; save new char 
0fd1			 
0fd1 c3 66 0f			jp input_right 
0fd4			 
0fd4			;input_shiftright: 
0fd4			;	; shift text right at cursor, hl has shift start 
0fd4			;	push hl 
0fd4			;	push de 
0fd4			;	push bc 
0fd4			; 
0fd4			; 
0fd4			;	; move to end of string past zero term 
0fd4			;	ld hl,(input_start) 
0fd4			;	ld a, (input_len) 
0fd4			;	call addatohl 
0fd4			;	inc hl 
0fd4			;;	inc hl 
0fd4			;;	inc hl 
0fd4			;	ld a, 0 
0fd4			;	ld (hl), a 
0fd4			;;	dec hl 
0fd4			;	 
0fd4			;;	ld (hl), a 
0fd4			;;	dec hl 
0fd4			; 
0fd4			;	push hl 
0fd4			;	pop de 
0fd4			;	inc de 
0fd4			;	 
0fd4			; 
0fd4			;;	ld hl,(input_start) 
0fd4			;;	ld a, (input_cursor) 
0fd4			;;	call addatohl 
0fd4			; 
0fd4			; 
0fd4			;	; calc how many bytes from cursor pos to end of string we need to shift 
0fd4			;	call input_lenrem    ; get bc length of remaining string 
0fd4			;	;ld a, (input_cursor) 
0fd4			;	;ld c, a 
0fd4			;	ld a, (input_len) 
0fd4			;	cp 2 
0fd4			;	jr z, .iskipzero	 
0fd4			;	;sub c 
0fd4			;	;inc a 
0fd4			;	;ld c, a 
0fd4			;	;ld b, 0 
0fd4			;	inc c 
0fd4			;	inc c 
0fd4			;	; move data 
0fd4			;	lddr 
0fd4			;.iskipzero: 
0fd4			; 
0fd4			;	pop bc 
0fd4			;	pop de 
0fd4			;	pop hl 
0fd4			;	ret	 
0fd4			 
0fd4			input_delchar: 
0fd4				; Delete char at cursor position 
0fd4 cd 90 0f			call input_lenrem    ; get bc length of remaining string 
0fd7 2a 67 ee			ld hl, (input_start) 
0fda 3a 55 ee			ld a, (input_cursor) 
0fdd cd f2 0d			call addatohl 
0fe0			 
0fe0 e5				push hl 
0fe1 d1				pop de 
0fe2 1b				dec de 
0fe3			 
0fe3			.dl:	 
0fe3 ed a0			ldi  
0fe5 7e				ld a, (hl) 
0fe6 fe 00			cp 0 
0fe8 28 02			jr z, .dldone 
0fea 18 f7			jr .dl 
0fec			.dldone: 
0fec ed a0			ldi 
0fee			 
0fee c3 5f 0f			jp input_left 
0ff1			 
0ff1			 
0ff1			endif 
0ff1			 
0ff1			 
0ff1			 
0ff1			if EDIT_V1 
0ff1			input_str: 
0ff1			 
0ff1				    	ld (input_at_pos),a      ; save display position to start 
0ff1					add c 
0ff1					ld (input_at_cursor),a	; save draw pos of cursor 
0ff1					ld (input_start), hl     ; save ptr to buffer 
0ff1					ld a, c 
0ff1					call addatohl 
0ff1					ld (input_ptr), hl     ; save ptr to point under the cursor 
0ff1					ld a,d 
0ff1				        ld (input_size), a       ; save length of input area 
0ff1					ld a, c 
0ff1					ld (input_cursor),a      ; init cursor start position  
0ff1					ld a,e 
0ff1				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0ff1					 
0ff1					 
0ff1			 
0ff1			;		ld a,(input_ptr) 
0ff1			;		ld (input_under_cursor),a 	; save what is under the cursor 
0ff1			 
0ff1			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0ff1					; init cursor shape if not set by the cin routines 
0ff1					ld hl, cursor_shape 
0ff1			if BASE_KEV 
0ff1					ld a, 255 
0ff1			else 
0ff1					ld a, '#' 
0ff1			endif 
0ff1					ld (hl), a 
0ff1					inc hl 
0ff1					ld a, 0 
0ff1					ld (hl), a 
0ff1			 
0ff1					ld a, CUR_BLINK_RATE 
0ff1					ld (input_cur_flash), a 
0ff1					ld a, 1 
0ff1					ld (input_cur_onoff),a 
0ff1			 
0ff1			;	if DEBUG_INPUT 
0ff1			;		push af 
0ff1			;		ld a, 'I' 
0ff1			;		ld (debug_mark),a 
0ff1			;		pop af 
0ff1			;		CALLMONITOR 
0ff1			;	endif 
0ff1			.is1:		; main entry loop 
0ff1			 
0ff1			 
0ff1			 
0ff1					; pause 1ms 
0ff1			 
0ff1					ld a, 1 
0ff1					call aDelayInMS 
0ff1			 
0ff1					; dec flash counter 
0ff1					ld a, (input_cur_flash) 
0ff1					dec a 
0ff1					ld (input_cur_flash), a 
0ff1					cp 0 
0ff1					jr nz, .nochgstate 
0ff1			 
0ff1			 
0ff1					; change state 
0ff1					ld a,(input_cur_onoff) 
0ff1					neg 
0ff1					ld (input_cur_onoff),a 
0ff1			 
0ff1			 
0ff1					; reset on change of state 
0ff1					ld a, CUR_BLINK_RATE 
0ff1					ld (input_cur_flash), a 
0ff1			 
0ff1			.nochgstate: 
0ff1					 
0ff1					 
0ff1			 
0ff1					; display cursor  
0ff1			 
0ff1			;		ld hl, (input_start) 
0ff1			;		ld a, (input_cursor) 
0ff1			;		call addatohl 
0ff1			 
0ff1					; get char under cursor and replace with cursor 
0ff1			ld hl, (input_ptr) 
0ff1			;		ld a, (hl) 
0ff1			;		ld (input_under_cursor),a 
0ff1			;		ld a, '_' 
0ff1			;		ld (hl), a 
0ff1			 
0ff1					; display string 
0ff1			 
0ff1					ld de, (input_start) 
0ff1					ld a, (input_at_pos) 
0ff1					call str_at_display 
0ff1			;	        call update_display 
0ff1			 
0ff1					; find place to put the cursor 
0ff1			;		add h 
0ff1			;		ld l, display_row_1 
0ff1			;		sub l 
0ff1			; (input_at_pos) 
0ff1					;ld c, a 
0ff1			;		ld a, (input_cursor) 
0ff1			;		ld l, (input_at_pos) 
0ff1			;		;ld b, h 
0ff1			;		add l 
0ff1			;		ld (input_at_cursor),a 
0ff1					;ld l,h 
0ff1			 
0ff1			;		ld h, 0 
0ff1			;		ld l,(input_at_pos) 
0ff1			;		ld a, (input_cursor) 
0ff1			;		call addatohl 
0ff1			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0ff1			;		call subafromhl 
0ff1			;		ld a,l 
0ff1			;		ld (input_at_cursor), a 
0ff1			 
0ff1				if DEBUG_INPUT 
0ff1					ld a, (hardware_diag) 
0ff1					cp 0 
0ff1					jr z, .skip_input_diag 
0ff1			 
0ff1					ld a,(input_at_pos) 
0ff1					ld hl, LFSRSeed 
0ff1					call hexout 
0ff1					ld a, (input_cursor) 
0ff1					ld hl, LFSRSeed+2 
0ff1					call hexout 
0ff1					ld a,(input_at_cursor) 
0ff1					ld hl, LFSRSeed+4 
0ff1					call hexout 
0ff1			 
0ff1					ld a,(input_cur_onoff) 
0ff1					ld hl, LFSRSeed+6 
0ff1					call hexout 
0ff1			 
0ff1					ld a,(input_cur_flash) 
0ff1					ld hl, LFSRSeed+8 
0ff1					call hexout 
0ff1			 
0ff1					ld a,(input_len) 
0ff1					ld hl, LFSRSeed+10 
0ff1					call hexout 
0ff1					ld hl, LFSRSeed+12 
0ff1					ld a, 0 
0ff1					ld (hl),a 
0ff1					ld a, display_row_4 
0ff1					ld de, LFSRSeed 
0ff1					call str_at_display 
0ff1					.skip_input_diag: 
0ff1				endif 
0ff1			 
0ff1					; decide on if we are showing the cursor this time round 
0ff1			 
0ff1					ld a, (input_cur_onoff) 
0ff1					cp 255 
0ff1					jr z, .skipcur 
0ff1			 
0ff1			 
0ff1					ld a,(input_at_cursor) 
0ff1					ld de, cursor_shape 
0ff1					call str_at_display 
0ff1			 
0ff1					; save length of current input string 
0ff1					ld hl, (input_start) 
0ff1					ld a, 0 
0ff1					call strlent 
0ff1					ld a,l 
0ff1					ld (input_len),a 
0ff1			 
0ff1			.skipcur: 
0ff1			 
0ff1				        call update_display 
0ff1					 
0ff1			 
0ff1			 
0ff1					; wait 
0ff1				 
0ff1					; TODO loop without wait to flash the cursor and char under cursor	 
0ff1					call cin    ; _wait 
0ff1			 
0ff1					cp 0 
0ff1					jp z, .is1 
0ff1			 
0ff1					; get ptr to char to input into 
0ff1			 
0ff1					ld c,a 
0ff1					ld hl, (input_start) 
0ff1					ld a, (input_cursor) 
0ff1					call addatohl 
0ff1					ld (input_ptr), hl 
0ff1					ld a,c 
0ff1			 
0ff1					; replace char under cursor 
0ff1			 
0ff1			;		ld hl, (input_ptr) 
0ff1			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ff1			;		ld (hl), a 
0ff1			 
0ff1			;	if DEBUG_INPUT 
0ff1			;		push af 
0ff1			;		ld a, 'i' 
0ff1			;		ld (debug_mark),a 
0ff1			;		pop af 
0ff1			;		CALLMONITOR 
0ff1			;	endif 
0ff1					cp KEY_HOME 
0ff1					jr nz, .iske 
0ff1			 
0ff1					ld a, (input_at_pos) 
0ff1					ld (input_at_cursor),a 
0ff1					ld a, 0 
0ff1					ld (input_cursor), a 
0ff1					jp .is1 
0ff1					 
0ff1			.iske:		cp KEY_END 
0ff1					jr nz, .isknw 
0ff1					jp .is1 
0ff1			 
0ff1			.isknw:		cp KEY_NEXTWORD 
0ff1					jr nz, .iskpw 
0ff1			 
0ff1			.isknwm:	ld hl, (input_ptr) 
0ff1					ld a,(hl)	 
0ff1					cp 0 
0ff1					jp z, .is1    ; end of string 
0ff1					cp ' ' 
0ff1					jp z, .is1    ; end of word 
0ff1					inc hl 
0ff1					ld (input_ptr), hl 
0ff1					ld a, (input_at_cursor) 
0ff1					inc a 
0ff1					ld (input_at_cursor), a 
0ff1					jr .isknwm 
0ff1			 
0ff1			.iskpw:		cp KEY_PREVWORD 
0ff1					jr nz, .iskl 
0ff1			.iskpwm:	 
0ff1					ld hl, (input_ptr) 
0ff1					ld a,(hl)	 
0ff1					cp 0  
0ff1					jp z, .is1    ; end of string 
0ff1					cp ' ' 
0ff1					jp z, .is1    ; end of word 
0ff1					dec hl 
0ff1					ld (input_ptr), hl 
0ff1					ld a, (input_at_cursor) 
0ff1					dec a 
0ff1					ld (input_at_cursor), a 
0ff1					jr .iskpwm 
0ff1			 
0ff1			 
0ff1			.iskl:		cp KEY_LEFT 
0ff1					jr nz, .isk1 
0ff1			 
0ff1					ld a, (input_cursor) 
0ff1			 
0ff1					cp 0 
0ff1					jp z, .is1 		; at start of line to ignore  
0ff1			 
0ff1					dec  a 		; TODO check underflow 
0ff1					ld (input_cursor), a 
0ff1			 
0ff1					ld hl, (input_ptr) 
0ff1					dec hl 
0ff1					ld (input_ptr), hl 
0ff1					 
0ff1					ld a, (input_at_cursor) 
0ff1					dec a 
0ff1					ld (input_at_cursor), a 
0ff1			 
0ff1					ld a, 1		; show cursor moving 
0ff1					ld (input_cur_onoff),a 
0ff1					ld a, CUR_BLINK_RATE 
0ff1					ld (input_cur_flash), a 
0ff1			 
0ff1					jp .is1 
0ff1			 
0ff1			.isk1:		cp KEY_RIGHT 
0ff1					jr nz, .isk2 
0ff1			 
0ff1					ld a,(input_len)		; TODO BUG why cant i load e direct? 
0ff1					ld e,a 
0ff1					ld a, (input_cursor) 
0ff1					cp e 
0ff1					jp z, .is1		; at the end of string so dont go right 
0ff1			 
0ff1					inc  a 		; TODO check overflow 
0ff1					ld (input_cursor), a 
0ff1			 
0ff1					ld a, (input_at_cursor) 
0ff1					inc a 
0ff1					ld (input_at_cursor), a 
0ff1			 
0ff1					ld hl, (input_ptr) 
0ff1					inc hl 
0ff1					ld (input_ptr), hl 
0ff1			 
0ff1					ld a, 1		; show cursor moving 
0ff1					ld (input_cur_onoff),a 
0ff1					ld a, CUR_BLINK_RATE 
0ff1					ld (input_cur_flash), a 
0ff1			 
0ff1					jp .is1 
0ff1			 
0ff1			.isk2:		cp KEY_UP 
0ff1			 
0ff1					jr nz, .isk3 
0ff1			 
0ff1					; swap last command with the current on 
0ff1			 
0ff1					; move cursor to start of string 
0ff1					ld hl, (input_start) 
0ff1					ld (input_ptr), hl 
0ff1			 
0ff1					ld a, (input_at_pos) 
0ff1					ld (input_at_cursor), a 
0ff1			 
0ff1					ld a, 0 
0ff1					ld (input_cursor), a 
0ff1					 
0ff1					; swap input and last command buffers 
0ff1			 
0ff1					ld hl, os_cli_cmd 
0ff1					ld de, os_last_cmd 
0ff1					ld b, 255 
0ff1			.swap1:		ld a, (hl) 
0ff1					ld c,a 
0ff1					ld a, (de) 
0ff1					ld (hl), a 
0ff1					ld a,c 
0ff1					ld (de),a 
0ff1					inc hl 
0ff1					inc de 
0ff1					djnz .swap1 
0ff1			 
0ff1			 
0ff1			 
0ff1			 
0ff1			 
0ff1					jp .is1 
0ff1			 
0ff1			.isk3:		cp KEY_BS 
0ff1					jr nz, .isk4 
0ff1			 
0ff1					ld a, (input_cursor) 
0ff1			 
0ff1					cp 0 
0ff1					jp z, .is1 		; at start of line to ignore  
0ff1			 
0ff1					dec  a 		; TODO check underflow 
0ff1					ld (input_cursor), a 
0ff1			 
0ff1					; hl is source 
0ff1					; de needs to be source - 1 
0ff1			 
0ff1			;		ld a, 0 
0ff1			;		dec hl 
0ff1			;		ld (hl), a 
0ff1			 
0ff1					ld hl, (input_ptr) 
0ff1					dec hl 
0ff1					ld (input_ptr), hl 
0ff1			 
0ff1					; shift all data 
0ff1			 
0ff1					push hl 
0ff1					inc hl 
0ff1					pop de 
0ff1					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ff1					ld c,a 
0ff1					ld b,0 
0ff1					ldir  
0ff1			 
0ff1			 
0ff1			 
0ff1			 
0ff1					ld a, (input_at_cursor) 
0ff1					dec a 
0ff1					ld (input_at_cursor), a 
0ff1			 
0ff1			 
0ff1					ld a, 1		; show cursor moving 
0ff1					ld (input_cur_onoff),a 
0ff1					ld a, CUR_BLINK_RATE 
0ff1					ld (input_cur_flash), a 
0ff1			 
0ff1					; remove char 
0ff1					ld a, (input_at_cursor) 
0ff1					inc a 
0ff1					ld de,.iblank 
0ff1					call str_at_display 
0ff1			 
0ff1					jp .is1 
0ff1			 
0ff1			.isk4:		cp KEY_CR 
0ff1					jr z, .endinput 
0ff1			 
0ff1					; else add the key press to the end 
0ff1			 
0ff1					ld c, a			; save key pressed 
0ff1			 
0ff1					ld a,(hl)		; get what is currently under char 
0ff1			 
0ff1					cp 0			; we are at the end of the string 
0ff1					jr nz, .onchar 
0ff1					 
0ff1					; add a char to the end of the string 
0ff1				 
0ff1					ld (hl),c 
0ff1					inc hl 
0ff1			;		ld a,' ' 
0ff1			;		ld (hl),a 
0ff1			;		inc hl 
0ff1					ld a,0 
0ff1					ld (hl),a 
0ff1					dec hl 
0ff1			 
0ff1					ld a, (input_cursor) 
0ff1					inc a				; TODO check max string length and scroll  
0ff1					ld (input_cursor), a		; inc cursor pos 
0ff1							 
0ff1					ld a, (input_at_cursor) 
0ff1					inc a 
0ff1					ld (input_at_cursor), a 
0ff1			 
0ff1					ld hl, (input_ptr) 
0ff1					inc hl 
0ff1					ld (input_ptr), hl 
0ff1			 
0ff1					ld hl, (input_ptr) 
0ff1					inc hl 
0ff1					ld (input_ptr), hl 
0ff1			;	if DEBUG_INPUT 
0ff1			;		push af 
0ff1			;		ld a, '+' 
0ff1			;		ld (debug_mark),a 
0ff1			;		pop af 
0ff1			;		CALLMONITOR 
0ff1			;	endif 
0ff1					ld a, 1		; show cursor moving 
0ff1					ld (input_cur_onoff),a 
0ff1					ld a, CUR_BLINK_RATE 
0ff1					ld (input_cur_flash), a 
0ff1					jp .is1 
0ff1					 
0ff1			 
0ff1			 
0ff1					; if on a char then insert 
0ff1			.onchar: 
0ff1			 
0ff1					; TODO over flow check: make sure insert does not blow out buffer 
0ff1			 
0ff1					; need to do some maths to use lddr 
0ff1			 
0ff1					push hl   ; save char pos 
0ff1					push bc 
0ff1			 
0ff1					ld hl, (input_start) 
0ff1					ld a, (input_len) 
0ff1					call addatohl  		; end of string 
0ff1					inc hl 
0ff1					inc hl		; past zero term 
0ff1					push hl 
0ff1					inc hl 
0ff1					push hl  
0ff1			 
0ff1								; start and end of lddr set, now how much to move? 
0ff1			 
0ff1							 
0ff1					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ff1					ld b,a 
0ff1					ld a,(input_len) 
0ff1					ld e,a 
0ff1					sub b 
0ff1					inc a		;?? 
0ff1					inc a		;?? 
0ff1					inc a		;?? 
0ff1			 
0ff1					ld b,0 
0ff1					ld c,a 
0ff1			 
0ff1				if DEBUG_INPUT 
0ff1					push af 
0ff1					ld a, 'i' 
0ff1					ld (debug_mark),a 
0ff1					pop af 
0ff1			;		CALLMONITOR 
0ff1				endif 
0ff1					pop de 
0ff1					pop hl 
0ff1				if DEBUG_INPUT 
0ff1					push af 
0ff1					ld a, 'I' 
0ff1					ld (debug_mark),a 
0ff1					pop af 
0ff1			;		CALLMONITOR 
0ff1				endif 
0ff1					lddr 
0ff1				 
0ff1			 
0ff1			 
0ff1					; TODO have a key for insert/overwrite mode???? 
0ff1					pop bc 
0ff1					pop hl 
0ff1					ld (hl), c		; otherwise overwrite current char 
0ff1					 
0ff1			 
0ff1			 
0ff1			 
0ff1					ld a, (input_cursor) 
0ff1					inc  a 		; TODO check overflow 
0ff1					ld (input_cursor), a 
0ff1			 
0ff1					ld a, (input_at_cursor) 
0ff1					inc a 
0ff1					ld (input_at_cursor), a 
0ff1			 
0ff1					jp .is1 
0ff1			 
0ff1			.endinput:	; TODO look for end of string 
0ff1			 
0ff1					; add trailing space for end of token 
0ff1			 
0ff1					ld hl, (input_start) 
0ff1					ld a,(input_len) 
0ff1					call addatohl 
0ff1					ld a, ' ' 
0ff1					ld (hl),a 
0ff1					; TODO eof of parse marker 
0ff1			 
0ff1					inc hl 
0ff1					ld a, 0 
0ff1					ld (hl),a 
0ff1			 
0ff1			 
0ff1					ret 
0ff1			 
0ff1			.iblank: db " ",0 
0ff1			 
0ff1			 
0ff1			input_str_prev:	ld (input_at_pos), a 
0ff1					ld (input_start), hl 
0ff1					ld a,1			; add cursor 
0ff1					ld (hl),a 
0ff1					inc hl 
0ff1					ld a,0 
0ff1					ld (hl),a 
0ff1					ld (input_ptr), hl 
0ff1					ld a,d 
0ff1					ld (input_size), a 
0ff1					ld a,0 
0ff1					ld (input_cursor),a 
0ff1			.instr1:	 
0ff1			 
0ff1					; TODO do block cursor 
0ff1					; TODO switch cursor depending on the modifer key 
0ff1			 
0ff1					; update cursor shape change on key hold 
0ff1			 
0ff1					ld hl, (input_ptr) 
0ff1					dec hl 
0ff1					ld a,(cursor_shape) 
0ff1					ld (hl), a 
0ff1			 
0ff1					; display entered text 
0ff1					ld a,(input_at_pos) 
0ff1			            	CALL fLCD_Pos       ;Position cursor to location in A 
0ff1			            	LD   de, (input_start) 
0ff1			            	CALL fLCD_Str       ;Display string pointed to by DE 
0ff1			 
0ff1					call cin 
0ff1					cp 0 
0ff1					jr z, .instr1 
0ff1			 
0ff1					; proecess keyboard controls first 
0ff1			 
0ff1					ld hl,(input_ptr) 
0ff1			 
0ff1					cp KEY_CR	 ; pressing enter ends input 
0ff1					jr z, .instrcr 
0ff1			 
0ff1					cp KEY_BS 	; back space 
0ff1					jr nz, .instr2 
0ff1					; process back space 
0ff1			 
0ff1					; TODO stop back space if at start of string 
0ff1					dec hl 
0ff1					dec hl ; to over write cursor 
0ff1					ld a,(cursor_shape) 
0ff1					;ld a,0 
0ff1					ld (hl),a 
0ff1					inc hl 
0ff1					ld a," " 
0ff1					ld (hl),a 
0ff1					ld (input_ptr),hl 
0ff1					 
0ff1			 
0ff1					jr .instr1 
0ff1			 
0ff1			.instr2:	cp KEY_LEFT    ; cursor left 
0ff1					jr nz, .instr3 
0ff1					dec hl 
0ff1					ld (input_ptr),hl 
0ff1					jr .instr1 
0ff1				 
0ff1			.instr3:	cp KEY_RIGHT      ; cursor right 
0ff1					jr nz, .instr4 
0ff1					inc hl 
0ff1					ld (input_ptr),hl 
0ff1					jr .instr1 
0ff1			 
0ff1			.instr4:	cp KEY_HOME    ; jump to start of line 
0ff1					jr nz, .instr5 
0ff1					dec hl 
0ff1					ld (input_ptr),hl 
0ff1					jr .instr1 
0ff1			 
0ff1			.instr5:	cp KEY_END     ; jump to end of line 
0ff1					jr nz, .instr6 
0ff1					dec hl 
0ff1					ld (input_ptr),hl 
0ff1					jr .instr1 
0ff1			.instr6:        cp KEY_UP      ; recall last command 
0ff1					jr nz, .instrnew 
0ff1			 
0ff1				ld hl, scratch 
0ff1				ld de, os_last_cmd 
0ff1				call strcpy 
0ff1					jr .instr1 
0ff1			 
0ff1			 
0ff1			.instrnew:	; no special key pressed to see if we have room to store it 
0ff1			 
0ff1					; TODO do string size test 
0ff1			 
0ff1					dec hl ; to over write cursor 
0ff1					ld (hl),a 
0ff1					inc hl 
0ff1					ld a,(cursor_shape) 
0ff1					ld (hl),a 
0ff1					inc hl 
0ff1					ld a,0 
0ff1					ld (hl),a 
0ff1			 
0ff1					ld (input_ptr),hl 
0ff1					 
0ff1					jr .instr1 
0ff1			.instrcr:	dec hl		; remove cursor 
0ff1					ld a,' '	; TODO add a trailing space for safety 
0ff1					ld (hl),a 
0ff1					inc hl 
0ff1					ld a,0 
0ff1					ld (hl),a 
0ff1			 
0ff1			 
0ff1					; if at end of line scroll up    
0ff1					; TODO detecting only end of line 4 for scroll up  
0ff1			 
0ff1					;ld   
0ff1			 
0ff1					ret 
0ff1			 
0ff1			 
0ff1			endif 
0ff1			; strcpy hl = dest, de source 
0ff1			 
0ff1 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ff2 b7			            OR   A              ;Null terminator? 
0ff3 c8			            RET  Z              ;Yes, so finished 
0ff4 1a					ld a,(de) 
0ff5 77					ld (hl),a 
0ff6 13			            INC  DE             ;Point to next character 
0ff7 23					inc hl 
0ff8 18 f7		            JR   strcpy       ;Repeat 
0ffa c9					ret 
0ffb			 
0ffb			 
0ffb			; TODO string_at  
0ffb			; pass string which starts with lcd offset address and then null term string 
0ffb			 
0ffb			; TODO string to dec 
0ffb			; TODO string to hex 
0ffb			; TODO byte to string hex 
0ffb			; TODO byte to string dec 
0ffb			 
0ffb			 
0ffb			 
0ffb			; from z80uartmonitor 
0ffb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffb			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0ffb			; pass hl for where to put the text 
0ffb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffb c5			hexout:	PUSH BC 
0ffc f5					PUSH AF 
0ffd 47					LD B, A 
0ffe					; Upper nybble 
0ffe cb 3f				SRL A 
1000 cb 3f				SRL A 
1002 cb 3f				SRL A 
1004 cb 3f				SRL A 
1006 cd 16 10				CALL tohex 
1009 77					ld (hl),a 
100a 23					inc hl	 
100b					 
100b					; Lower nybble 
100b 78					LD A, B 
100c e6 0f				AND 0FH 
100e cd 16 10				CALL tohex 
1011 77					ld (hl),a 
1012 23					inc hl	 
1013					 
1013 f1					POP AF 
1014 c1					POP BC 
1015 c9					RET 
1016					 
1016			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1016			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1016			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1016			tohex: 
1016 e5					PUSH HL 
1017 d5					PUSH DE 
1018 16 00				LD D, 0 
101a 5f					LD E, A 
101b 21 23 10				LD HL, .DATA 
101e 19					ADD HL, DE 
101f 7e					LD A, (HL) 
1020 d1					POP DE 
1021 e1					POP HL 
1022 c9					RET 
1023			 
1023			.DATA: 
1023 30					DEFB	30h	; 0 
1024 31					DEFB	31h	; 1 
1025 32					DEFB	32h	; 2 
1026 33					DEFB	33h	; 3 
1027 34					DEFB	34h	; 4 
1028 35					DEFB	35h	; 5 
1029 36					DEFB	36h	; 6 
102a 37					DEFB	37h	; 7 
102b 38					DEFB	38h	; 8 
102c 39					DEFB	39h	; 9 
102d 41					DEFB	41h	; A 
102e 42					DEFB	42h	; B 
102f 43					DEFB	43h	; C 
1030 44					DEFB	44h	; D 
1031 45					DEFB	45h	; E 
1032 46					DEFB	46h	; F 
1033			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1033			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1033			;;    subtract $30, if result > 9 then subtract $7 more 
1033			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1033			atohex: 
1033 d6 30				SUB $30 
1035 fe 0a				CP 10 
1037 f8					RET M		; If result negative it was 0-9 so we're done 
1038 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
103a c9					RET		 
103b			 
103b			 
103b			 
103b			 
103b			; Get 2 ASCII characters as hex byte from pointer in hl 
103b			 
103b			BYTERD: 
103b 16 00			LD	D,00h		;Set up 
103d cd 45 10			CALL	HEXCON		;Get byte and convert to hex 
1040 87				ADD	A,A		;First nibble so 
1041 87				ADD	A,A		;multiply by 16 
1042 87				ADD	A,A		; 
1043 87				ADD	A,A		; 
1044 57				LD	D,A		;Save hi nibble in D 
1045			HEXCON: 
1045 7e				ld a, (hl)		;Get next chr 
1046 23				inc hl 
1047 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1049 fe 0a			CP	00Ah		;Is it 0-9 ? 
104b 38 02			JR	C,NALPHA	;If so miss next bit 
104d d6 07			SUB	007h		;Else convert alpha 
104f			NALPHA: 
104f b2				OR	D		;Add hi nibble back 
1050 c9				RET			; 
1051			 
1051			 
1051			; 
1051			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1051			; Since the routines get_byte and therefore get_nibble are called, only valid 
1051			; characters (0-9a-f) are accepted. 
1051			; 
1051			;get_word        push    af 
1051			;                call    get_byte        ; Get the upper byte 
1051			;                ld      h, a 
1051			;                call    get_byte        ; Get the lower byte 
1051			;                ld      l, a 
1051			;                pop     af 
1051			;                ret 
1051			; 
1051			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1051			; the routine get_nibble is used only valid characters are accepted - the  
1051			; input routine only accepts characters 0-9a-f. 
1051			; 
1051 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1052 7e					ld a,(hl) 
1053 23					inc hl 
1054 cd 79 10		                call    nibble2val      ; Get upper nibble 
1057 cb 07		                rlc     a 
1059 cb 07		                rlc     a 
105b cb 07		                rlc     a 
105d cb 07		                rlc     a 
105f 47			                ld      b, a            ; Save upper four bits 
1060 7e					ld a,(hl) 
1061 cd 79 10		                call    nibble2val      ; Get lower nibble 
1064 b0			                or      b               ; Combine both nibbles 
1065 c1			                pop     bc              ; Restore B (and C) 
1066 c9			                ret 
1067			; 
1067			; Get a hexadecimal digit from the serial line. This routine blocks until 
1067			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1067			; to the serial line interface. The lower 4 bits of A contain the value of  
1067			; that particular digit. 
1067			; 
1067			;get_nibble      ld a,(hl)           ; Read a character 
1067			;                call    to_upper        ; Convert to upper case 
1067			;                call    is_hex          ; Was it a hex digit? 
1067			;                jr      nc, get_nibble  ; No, get another character 
1067			 ;               call    nibble2val      ; Convert nibble to value 
1067			 ;               call    print_nibble 
1067			 ;               ret 
1067			; 
1067			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1067			; A valid hexadecimal digit is denoted by a set C flag. 
1067			; 
1067			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1067			;                ret     nc              ; Yes 
1067			;                cp      '0'             ; Less than '0'? 
1067			;                jr      nc, is_hex_1    ; No, continue 
1067			;                ccf                     ; Complement carry (i.e. clear it) 
1067			;                ret 
1067			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1067			;                ret     c               ; Yes 
1067			;                cp      'A'             ; Less than 'A'? 
1067			;                jr      nc, is_hex_2    ; No, continue 
1067			;                ccf                     ; Yes - clear carry and return 
1067			;                ret 
1067			;is_hex_2        scf                     ; Set carry 
1067			;                ret 
1067			; 
1067			; Convert a single character contained in A to upper case: 
1067			; 
1067 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1069 d8			                ret     c 
106a fe 7b		                cp      'z' + 1         ; > 'z'? 
106c d0			                ret     nc              ; Nothing to do, either 
106d e6 5f		                and     $5f             ; Convert to upper case 
106f c9			                ret 
1070			 
1070			 
1070			to_lower: 
1070			 
1070			   ; if char is in [A-Z] make it lower case 
1070			 
1070			   ; enter : a = char 
1070			   ; exit  : a = lower case char 
1070			   ; uses  : af 
1070			 
1070 fe 41		   cp 'A' 
1072 d8			   ret c 
1073			    
1073 fe 5b		   cp 'Z'+1 
1075 d0			   ret nc 
1076			    
1076 f6 20		   or $20 
1078 c9			   ret 
1079			 
1079			; 
1079			; Expects a hexadecimal digit (upper case!) in A and returns the 
1079			; corresponding value in A. 
1079			; 
1079 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
107b 38 02		                jr      c, nibble2val_1 ; Yes 
107d d6 07		                sub     7               ; Adjust for A-F 
107f d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1081 e6 0f		                and     $f              ; Only return lower 4 bits 
1083 c9			                ret 
1084			; 
1084			; Print_nibble prints a single hex nibble which is contained in the lower  
1084			; four bits of A: 
1084			; 
1084			;print_nibble    push    af              ; We won't destroy the contents of A 
1084			;                and     $f              ; Just in case... 
1084			;                add     a, '0'             ; If we have a digit we are done here. 
1084			;                cp      '9' + 1         ; Is the result > 9? 
1084			;                jr      c, print_nibble_1 
1084			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1084			;print_nibble_1  call    putc            ; Print the nibble and 
1084			;                pop     af              ; restore the original value of A 
1084			;                ret 
1084			;; 
1084			;; Send a CR/LF pair: 
1084			; 
1084			;crlf            push    af 
1084			;                ld      a, cr 
1084			;                call    putc 
1084			;                ld      a, lf 
1084			;                call    putc 
1084			;                pop     af 
1084			;                ret 
1084			; 
1084			; Print_word prints the four hex digits of a word to the serial line. The  
1084			; word is expected to be in HL. 
1084			; 
1084			;print_word      push    hl 
1084			;                push    af 
1084			;                ld      a, h 
1084			;                call    print_byte 
1084			;                ld      a, l 
1084			;                call    print_byte 
1084			;                pop     af 
1084			;                pop     hl 
1084			;                ret 
1084			; 
1084			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1084			; The byte to be printed is expected to be in A. 
1084			; 
1084			;print_byte      push    af              ; Save the contents of the registers 
1084			;                push    bc 
1084			;                ld      b, a 
1084			;                rrca 
1084			;                rrca 
1084			;                rrca 
1084			;                rrca 
1084			;                call    print_nibble    ; Print high nibble 
1084			;                ld      a, b 
1084			;                call    print_nibble    ; Print low nibble 
1084			;                pop     bc              ; Restore original register contents 
1084			;                pop     af 
1084			;                ret 
1084			 
1084			 
1084			 
1084			 
1084			 
1084			fourehexhl:  
1084 7e				ld a,(hl) 
1085 cd 33 10			call atohex 
1088 cb 3f				SRL A 
108a cb 3f				SRL A 
108c cb 3f				SRL A 
108e cb 3f				SRL A 
1090 47				ld b, a 
1091 23				inc hl 
1092 7e				ld a,(hl) 
1093 23				inc hl 
1094 cd 33 10			call atohex 
1097 80				add b 
1098 57				ld d,a 
1099 7e				ld a,(hl) 
109a cd 33 10			call atohex 
109d cb 3f				SRL A 
109f cb 3f				SRL A 
10a1 cb 3f				SRL A 
10a3 cb 3f				SRL A 
10a5 47				ld b, a 
10a6 23				inc hl 
10a7 7e				ld a,(hl) 
10a8 23				inc hl 
10a9 cd 33 10			call atohex 
10ac 80				add b 
10ad 5f				ld e, a 
10ae d5				push de 
10af e1				pop hl 
10b0 c9				ret 
10b1			 
10b1			; pass hl. returns z set if the byte at hl is a digit 
10b1			;isdigithl:  
10b1			;	push bc 
10b1			;	ld a,(hl) 
10b1			;	cp ':' 
10b1			;	jr nc, .isdf 		; > 
10b1			;	cp '0' 
10b1			;	jr c, .isdf		; < 
10b1			; 
10b1			;	; TODO find a better way to set z 
10b1			; 
10b1			;	ld b,a 
10b1			;	cp b 
10b1			;	pop bc 
10b1			;	ret 
10b1			; 
10b1			;.isdf:	; not digit so clear z 
10b1			; 
10b1			;	; TODO find a better way to unset z 
10b1			; 
10b1			;	ld b,a 
10b1			;	inc b 
10b1			;	cp b 
10b1			; 
10b1			;	pop bc 
10b1			;	ret 
10b1				 
10b1				 
10b1			 
10b1			 
10b1			; pass hl as the four byte address to load 
10b1			 
10b1			get_word_hl:  
10b1 e5				push hl 
10b2 cd 51 10			call get_byte 
10b5				 
10b5 47				ld b, a 
10b6			 
10b6 e1				pop hl 
10b7 23				inc hl 
10b8 23				inc hl 
10b9			 
10b9			; TODO not able to handle a-f  
10b9 7e				ld a,(hl) 
10ba			;	;cp ':' 
10ba			;	cp 'g' 
10ba			;	jr nc, .single_byte_hl 		; > 
10ba			;	cp 'G' 
10ba			;	jr nc, .single_byte_hl 		; > 
10ba			;	cp '0' 
10ba			;	jr c, .single_byte_hl		; < 
10ba			 
10ba				;call isdigithl 
10ba fe 00			cp 0 
10bc 28 06			jr z, .single_byte_hl 
10be			 
10be			.getwhln:   ; hex word so get next byte 
10be			 
10be cd 51 10			call get_byte 
10c1 6f				ld l, a 
10c2 60				ld h,b 
10c3 c9				ret 
10c4 68			.single_byte_hl:   ld l,b 
10c5 26 00				ld h,0 
10c7 c9					ret 
10c8			 
10c8			 
10c8			 
10c8			 
10c8 21 68 18			ld hl,asc+1 
10cb			;	ld a, (hl) 
10cb			;	call nibble2val 
10cb cd 51 10			call get_byte 
10ce			 
10ce			;	call fourehexhl 
10ce 32 f5 e2			ld (scratch+52),a 
10d1				 
10d1 21 f3 e2			ld hl,scratch+50 
10d4 22 e4 e5			ld (os_cur_ptr),hl 
10d7			 
10d7 c9				ret 
10d8			 
10d8			 
10d8			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10d8			 
10d8			; Decimal Unsigned Version 
10d8			 
10d8			;Number in a to decimal ASCII 
10d8			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10d8			;Example: display a=56 as "056" 
10d8			;input: a = number 
10d8			;Output: a=0,value of a in the screen 
10d8			;destroys af,bc (don't know about hl and de) 
10d8			DispAToASCII: 
10d8 0e 9c			ld	c,-100 
10da cd e4 10			call	.Na1 
10dd 0e f6			ld	c,-10 
10df cd e4 10			call	.Na1 
10e2 0e ff			ld	c,-1 
10e4 06 2f		.Na1:	ld	b,'0'-1 
10e6 04			.Na2:	inc	b 
10e7 81				add	a,c 
10e8 38 fc			jr	c,.Na2 
10ea 91				sub	c		;works as add 100/10/1 
10eb f5				push af		;safer than ld c,a 
10ec 78				ld	a,b		;char is in b 
10ed			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10ed f1				pop af		;safer than ld a,c 
10ee c9				ret 
10ef			 
10ef			; Decimal Signed Version 
10ef			 
10ef			; DispA 
10ef			; -------------------------------------------------------------- 
10ef			; Converts a signed integer value to a zero-terminated ASCII 
10ef			; string representative of that value (using radix 10). 
10ef			; -------------------------------------------------------------- 
10ef			; INPUTS: 
10ef			;     HL     Value to convert (two's complement integer). 
10ef			;     DE     Base address of string destination. (pointer). 
10ef			; -------------------------------------------------------------- 
10ef			; OUTPUTS: 
10ef			;     None 
10ef			; -------------------------------------------------------------- 
10ef			; REGISTERS/MEMORY DESTROYED 
10ef			; AF HL 
10ef			; -------------------------------------------------------------- 
10ef			 
10ef			;DispHLToASCII: 
10ef			;   push    de 
10ef			;   push    bc 
10ef			; 
10ef			;; Detect sign of HL. 
10ef			;    bit    7, h 
10ef			;    jr     z, ._DoConvert 
10ef			; 
10ef			;; HL is negative. Output '-' to string and negate HL. 
10ef			;    ld     a, '-' 
10ef			;    ld     (de), a 
10ef			;    inc    de 
10ef			; 
10ef			;; Negate HL (using two's complement) 
10ef			;    xor    a 
10ef			;    sub    l 
10ef			;    ld     l, a 
10ef			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10ef			;    sbc    a, h 
10ef			;    ld     h, a 
10ef			; 
10ef			;; Convert HL to digit characters 
10ef			;._DoConvert: 
10ef			;    ld     b, 0     ; B will count character length of number 
10ef			;-   ld     a, 10 
10ef			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10ef			;    push   af 
10ef			;    inc    b 
10ef			;    ld     a, h 
10ef			;    or     l 
10ef			;    jr     nz, - 
10ef			; 
10ef			;; Retrieve digits from stack 
10ef			;-   pop    af 
10ef			;    or     $30 
10ef			;    ld     (de), a 
10ef			;    inc    de 
10ef			;    djnz   - 
10ef			; 
10ef			;; Terminate string with NULL 
10ef			;    xor    a 
10ef			;    ld     (de), a 
10ef			; 
10ef			;    pop    bc 
10ef			;    pop    de 
10ef			;    ret 
10ef			 
10ef			;Comments 
10ef			; 
10ef			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10ef			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10ef			;    Note that the output string will not be fixed-width. 
10ef			; 
10ef			;Example Usage 
10ef			; 
10ef			;    ld    hl, -1004 
10ef			;    ld    de, OP1 
10ef			;    call  DispA 
10ef			;    ld    hl, OP1 
10ef			;    syscall  PutS 
10ef			 
10ef			 
10ef			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10ef			 
10ef			 
10ef			;Converts an ASCII string to an unsigned 16-bit integer 
10ef			;Quits when it reaches a non-decimal digit 
10ef			 
10ef			string_to_uint16: 
10ef			atoui_16: 
10ef			;Input: 
10ef			;     DE points to the string 
10ef			;Outputs: 
10ef			;     HL is the result 
10ef			;     A is the 8-bit value of the number 
10ef			;     DE points to the byte after the number 
10ef			;Destroys: 
10ef			;     BC 
10ef			;       if the string is non-empty, BC is HL/10 
10ef			;Size:  24 bytes 
10ef			;Speed: 42+d(104+{0,9}) 
10ef			;       d is the number of digits in the number 
10ef			;       max is 640 cycles for a 5 digit number 
10ef			;Assuming no leading zeros: 
10ef			;1 digit:  146cc 
10ef			;2 digit:  250cc 
10ef			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10ef			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10ef			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10ef			;avg: 544.81158447265625cc (544+13297/16384) 
10ef			;=============================================================== 
10ef 21 00 00		  ld hl,0 
10f2			.u16a: 
10f2 1a			  ld a,(de) 
10f3 d6 30		  sub 30h 
10f5 fe 0a		  cp 10 
10f7 d0			  ret nc 
10f8 13			  inc de 
10f9 44			  ld b,h 
10fa 4d			  ld c,l 
10fb 29			  add hl,hl 
10fc 29			  add hl,hl 
10fd 09			  add hl,bc 
10fe 29			  add hl,hl 
10ff 85			  add a,l 
1100 6f			  ld l,a 
1101 30 ef		  jr nc,.u16a 
1103 24			  inc h 
1104 c3 f2 10		  jp .u16a 
1107			 
1107			 
1107			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1107			 
1107			;written by Zeda 
1107			;Converts a 16-bit unsigned integer to an ASCII string. 
1107			 
1107			uitoa_16: 
1107			;Input: 
1107			;   DE is the number to convert 
1107			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1107			;Output: 
1107			;   HL points to the null-terminated ASCII string 
1107			;      NOTE: This isn't necessarily the same as the input HL. 
1107 d5			  push de 
1108 c5			  push bc 
1109 f5			  push af 
110a eb			  ex de,hl 
110b			 
110b 01 f0 d8		  ld bc,-10000 
110e 3e 2f		  ld a,'0'-1 
1110 3c			  inc a 
1111 09			  add hl,bc  
1112 38 fc		   jr c,$-2 
1114 12			  ld (de),a 
1115 13			  inc de 
1116			 
1116 01 e8 03		  ld bc,1000 
1119 3e 3a		  ld a,'9'+1 
111b 3d			  dec a  
111c 09			  add hl,bc  
111d 30 fc		   jr nc,$-2 
111f 12			  ld (de),a 
1120 13			  inc de 
1121			 
1121 01 9c ff		  ld bc,-100 
1124 3e 2f		  ld a,'0'-1 
1126 3c			  inc a  
1127 09			  add hl,bc  
1128 38 fc		   jr c,$-2 
112a 12			  ld (de),a 
112b 13			  inc de 
112c			 
112c 7d			  ld a,l 
112d 26 3a		  ld h,'9'+1 
112f 25			  dec h  
1130 c6 0a		  add a,10  
1132 30 fb		   jr nc,$-3 
1134 c6 30		  add a,'0' 
1136 eb			  ex de,hl 
1137 72			  ld (hl),d 
1138 23			  inc hl 
1139 77			  ld (hl),a 
113a 23			  inc hl 
113b 36 00		  ld (hl),0 
113d			 
113d			;Now strip the leading zeros 
113d 0e fa		  ld c,-6 
113f 09			  add hl,bc 
1140 3e 30		  ld a,'0' 
1142 23			  inc hl  
1143 be			  cp (hl)  
1144 28 fc		  jr z,$-2 
1146			 
1146			;Make sure that the string is non-empty! 
1146 7e			  ld a,(hl) 
1147 b7			  or a 
1148 20 01		  jr nz,.atoub 
114a 2b			  dec hl 
114b			.atoub: 
114b			 
114b f1			  pop af 
114c c1			  pop bc 
114d d1			  pop de 
114e c9			  ret 
114f			 
114f			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
114f			 
114f			toUpper: 
114f			;A is the char. 
114f			;If A is a lowercase letter, this sets it to the matching uppercase 
114f			;18cc or 30cc or 41cc 
114f			;avg: 26.75cc 
114f fe 61		  cp 'a' 
1151 d8			  ret c 
1152 fe 7b		  cp 'z'+1 
1154 d0			  ret nc 
1155 d6 20		  sub 'a'-'A' 
1157 c9			  ret 
1158			 
1158			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1158			 
1158			; String Length 
1158			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1158			 
1158			; Get the length of the null-terminated string starting at $8000 hl 
1158			;    LD     HL, $8000 
1158			 
1158			strlenz: 
1158			 
1158 af			    XOR    A               ; Zero is the value we are looking for. 
1159 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
115a 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
115b			                           ; 65, 536 bytes (the entire addressable memory space). 
115b ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
115d			 
115d			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
115d 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
115e 6f			    LD     L, A             ; number of bytes 
115f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1161 2b			    DEC    HL              ; Compensate for null. 
1162 c9				ret 
1163			 
1163			; Get the length of the A terminated string starting at $8000 hl 
1163			;    LD     HL, $8000 
1163			 
1163			strlent: 
1163			 
1163			                  ; A is the value we are looking for. 
1163 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1165 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1167			                           ; 65, 536 bytes (the entire addressable memory space). 
1167 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1169			 
1169			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1169 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
116b 2e 00		    LD     L, 0             ; number of bytes 
116d ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
116f 2b			    DEC    HL              ; Compensate for null. 
1170 c9				ret 
1171			 
1171			 
1171			;Comparing Strings 
1171			 
1171			;IN    HL     Address of string1. 
1171			;      DE     Address of string2. 
1171			 
1171			; doc given but wrong??? 
1171			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1171			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1171			; tested 
1171			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1171			 
1171			strcmp_old: 
1171 e5			    PUSH   HL 
1172 d5			    PUSH   DE 
1173			 
1173 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1174 be			    CP     (HL)            ; (want to minimize work). 
1175 38 01		    JR     C, Str1IsBigger 
1177 7e			    LD     A, (HL) 
1178			 
1178			Str1IsBigger: 
1178 4f			    LD     C, A             ; Put length in BC 
1179 06 00		    LD     B, 0 
117b 13			    INC    DE              ; Increment pointers to meat of string. 
117c 23			    INC    HL 
117d			 
117d			CmpLoop: 
117d 1a			    LD     A, (DE)          ; Compare bytes. 
117e ed a1		    CPI 
1180 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1182 13			    INC    DE              ; Update pointer. 
1183 ea 7d 11		    JP     PE, CmpLoop 
1186			 
1186 d1			    POP    DE 
1187 e1			    POP    HL 
1188 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1189 be			    CP     (HL) 
118a c9			    RET 
118b			 
118b			NoMatch: 
118b 2b			    DEC    HL 
118c be			    CP     (HL)            ; Compare again to affect carry. 
118d d1			    POP    DE 
118e e1			    POP    HL 
118f c9			    RET 
1190			 
1190			;; test strmp 
1190			; 
1190			;ld de, .str1 
1190			;ld hl, .str2 
1190			;call strcmp 
1190			;jr z, .z1 
1190			;;this 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "NZ1" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			;.z1: 
1190			; 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "ZZ1" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			; 
1190			;ld de, .str1 
1190			;ld hl, .str1 
1190			;call strcmp 
1190			;jr z, .z2 
1190			;;this 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "NZ2" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			;.z2: 
1190			; 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "ZZ2" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			; 
1190			;ld de, .str1 
1190			;ld hl, .str2 
1190			;call strcmp 
1190			;jr c, .c1 
1190			; 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "Nc1" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			;.c1: 
1190			;;this 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "cc1" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			; 
1190			;ld de, .str1 
1190			;ld hl, .str1 
1190			;call strcmp 
1190			;jr c, .c2 
1190			;;this 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "Nc2" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			;.c2: 
1190			; 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "cc2" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			;	NEXTW 
1190			;.str1:   db "string1",0 
1190			;.str2:   db "string2",0 
1190			 
1190			; only care about direct match or not 
1190			; hl and de strings 
1190			; zero set if the same 
1190			 
1190			strcmp: 
1190 1a				ld a, (de) 
1191 be				cp (hl) 
1192 28 02			jr z, .ssame 
1194 b7				or a 
1195 c9				ret 
1196			 
1196			.ssame:  
1196 fe 00			cp 0 
1198 c8				ret z 
1199			 
1199 23				inc hl 
119a 13				inc de 
119b 18 f3			jr strcmp 
119d				 
119d				 
119d			 
119d			;Copyright (c) 2014, Luke Maurits 
119d			;All rights reserved. 
119d			; 
119d			;Redistribution and use in source and binary forms, with or without 
119d			;modification, are permitted provided that the following conditions are met: 
119d			; 
119d			;* Redistributions of source code must retain the above copyright notice, this 
119d			;  list of conditions and the following disclaimer. 
119d			; 
119d			;* Redistributions in binary form must reproduce the above copyright notice, 
119d			;  this list of conditions and the following disclaimer in the documentation 
119d			;  and/or other materials provided with the distribution. 
119d			; 
119d			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
119d			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
119d			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
119d			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
119d			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
119d			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
119d			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
119d			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
119d			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
119d			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
119d			 
119d			; https://github.com/lmaurits/lm512/blob/master/string.z80 
119d			 
119d			StrictStrCmp: 
119d				; Load next chars of each string 
119d 1a				ld a, (de) 
119e 47				ld b, a 
119f 7e				ld a, (hl) 
11a0				; Compare 
11a0 b8				cp b 
11a1				; Return non-zero if chars don't match 
11a1 c0				ret nz 
11a2				; Check for end of both strings 
11a2 fe 00			cp "\0" 
11a4				; Return if strings have ended 
11a4 c8				ret z 
11a5				; Otherwise, advance to next chars 
11a5 23				inc hl 
11a6 13				inc de 
11a7 18 f4			jr StrictStrCmp 
11a9			 
11a9			;end 
11a9			; eof 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
# End of file firmware_strings.asm
11a9			include "firmware_memory.asm"   ; malloc and free  
11a9			 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			.mallocsize: db "Wants malloc >256",0 
11a9			.mallocasize: db "MALLOC gives >256",0 
11a9			.malloczero: db "MALLOC gives zero",0 
11a9			 
11a9			malloc_guard_zerolen: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9				ld de, 0 
11a9			        call cmp16 
11a9				jr nz, .lowalloz 
11a9			 
11a9				push hl 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .malloczero 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				call bp_on 
11a9			;	ld a, 0 
11a9			;	ld (os_view_disable), a 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9			.lowalloz: 
11a9			 
11a9			 
11a9				pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_entry: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowalloc 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocsize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9			;	ld a, 0 
11a9			;	ld (os_view_disable), a 
11a9				call bp_on 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdone 
11a9			.lowalloc: 
11a9			 
11a9			 
11a9				pop hl 
11a9			.lowdone:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_exit: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowallocx 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocasize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9			;	ld a, 0 
11a9			;	ld (os_view_disable), a 
11a9				call bp_on 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdonex 
11a9			.lowallocx: 
11a9			 
11a9				pop hl 
11a9			.lowdonex:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			endif 
11a9			 
11a9			if MALLOC_2 
11a9			; Z80 Malloc and Free Functions 
11a9			 
11a9			; Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc: 
11a9				 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_entry 
11a9			endif 
11a9			 
11a9			 
11a9			 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "mal" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of size into A 
11a9			    or h               ; Check if size is zero 
11a9			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11a9			 
11a9			    ; Allocate memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma1" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    call malloc_internal ; Call internal malloc function 
11a9			    pop af             ; Restore AF register 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret                ; Return 
11a9			 
11a9			; Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free: 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of pointer into A 
11a9			    or h               ; Check if pointer is NULL 
11a9			    jp z, free_exit    ; If pointer is NULL, exit 
11a9			 
11a9			    ; Free memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9			    call free_internal  ; Call internal free function 
11a9			    pop af             ; Restore AF register 
11a9			    ret                ; Return 
11a9			 
11a9			; Internal Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc_internal: 
11a9			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to requested size 
11a9			    ex de, hl          ; Save total size in DE, and keep it in HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			 
11a9			    ; Search for free memory block 
11a9			    ld de, (heap_end)  ; Load end of heap into DE 
11a9			    ld bc, 0           ; Initialize counter 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			malloc_search_loop: 
11a9			    ; Check if current block is free 
11a9			    ld a, (hl)         ; Load current block's status (free or used) 
11a9			    cp 0               ; Compare with zero (free) 
11a9			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11a9			 
11a9			    ; Check if current block is large enough 
11a9			    ld a, (hl+1)       ; Load high byte of block size 
11a9			    cp l               ; Compare with low byte of requested size 
11a9			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11a9			 
11a9			    ld a, (hl+2)       ; Load low byte of block size 
11a9			    cp h               ; Compare with high byte of requested size 
11a9			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11a9			 
11a9			    ; Mark block as used 
11a9			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11a9			 
11a9			    ; Calculate remaining space in block 
11a9			    ld bc, 0           ; Clear BC 
11a9			    add hl, bc         ; Increment HL to point to start of data block 
11a9			    add hl, de         ; HL = HL + DE (total size) 
11a9			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to start of data block 
11a9			 
11a9			    ; Save pointer to allocated block in HL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma5" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			malloc_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3           ; Size of management overhead 
11a9			    add hl, bc         ; Move to the next block 
11a9			    inc de             ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e            ; Load low byte of heap end address 
11a9			    cp (hl)            ; Compare with low byte of current address 
11a9			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11a9			    ld a, d            ; Load high byte of heap end address 
11a9			    cp 0               ; Check if it's zero (end of memory) 
11a9			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, allocation failed 
11a9			    xor a              ; Set result to NULL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma6" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			malloc_exit: 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma7" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			; Internal Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free_internal: 
11a9			    ld de, (heap_start) ; Load start of heap into DE 
11a9			    ld bc, 0            ; Initialize counter 
11a9			 
11a9			free_search_loop: 
11a9			    ; Check if current block contains the pointer 
11a9			    ld a, l             ; Load low byte of pointer 
11a9			    cp (hl+1)           ; Compare with high byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			    ld a, h             ; Load high byte of pointer 
11a9			    cp (hl+2)           ; Compare with low byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			 
11a9			    ; Mark block as free 
11a9			    ld (hl), 0          ; Set status byte to indicate free block 
11a9			    ret                 ; Return 
11a9			 
11a9			free_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3            ; Size of management overhead 
11a9			    add hl, bc          ; Move to the next block 
11a9			    inc de              ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e             ; Load low byte of heap end address 
11a9			    cp (hl)             ; Compare with low byte of current address 
11a9			    jr nz, free_search_loop  ; If not equal, continue searching 
11a9			    ld a, d             ; Load high byte of heap end address 
11a9			    cp 0                ; Check if it's zero (end of memory) 
11a9			    jr nz, free_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, pointer is not found in heap 
11a9			    ret 
11a9			 
11a9			free_exit: 
11a9			    ret                 ; Return 
11a9			 
11a9			; Define heap start and end addresses 
11a9			;heap_start:    .dw 0xC000   ; Start of heap 
11a9			;heap_end:      .dw 0xE000   ; End of heap 
11a9			 
11a9			endif 
11a9			 
11a9			 
11a9			if MALLOC_1 
11a9			 
11a9			 
11a9			 
11a9			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11a9			 
11a9			;moved to firmware.asm 
11a9			;heap_start        .equ  0x9000      ; Starting address of heap 
11a9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11a9			 
11a9			;      .org 0 
11a9			;      jp    main 
11a9			 
11a9			 
11a9			;      .org  0x100 
11a9			;main: 
11a9			;      ld    HL, 0x8100 
11a9			;      ld    SP, HL 
11a9			; 
11a9			;      call  heap_init 
11a9			; 
11a9			;      ; Make some allocations 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9004 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9014 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9024 
11a9			; 
11a9			;      ; Free some allocations 
11a9			;      ld    HL, 0x9014 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9004 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9024 
11a9			;      call  free 
11a9			; 
11a9			; 
11a9			;      halt 
11a9			 
11a9			 
11a9			;------------------------------------------------------------------------------ 
11a9			;     heap_init                                                               : 
11a9			;                                                                             : 
11a9			; Description                                                                 : 
11a9			;     Initialise the heap and make it ready for malloc and free operations.   : 
11a9			;                                                                             : 
11a9			;     The heap is maintained as a linked list, starting with an initial       : 
11a9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11a9			;     the first free block in the heap. Each block then points to the next    : 
11a9			;     free block within the heap, and the free list ends at the first block   : 
11a9			;     with a null pointer to the next free block.                             : 
11a9			;                                                                             : 
11a9			; Parameters                                                                  : 
11a9			;     Inputs are compile-time only. Two defines which specify the starting    : 
11a9			;     address of the heap and its size are required, along with a memory      : 
11a9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11a9			;     principally stores a pointer to the first free block in the heap.       : 
11a9			;                                                                             : 
11a9			; Returns                                                                     : 
11a9			;     Nothing                                                                 : 
11a9			;------------------------------------------------------------------------------ 
11a9			heap_init: 
11a9 e5			      push  HL 
11aa			 
11aa			      ; Initialise free list struct 
11aa 21 a4 5e		      ld    HL, heap_start 
11ad 22 9f 5e		      ld    (free_list), HL 
11b0 21 00 00		      ld    HL, 0 
11b3 22 a1 5e		      ld    (free_list+2), HL 
11b6			 
11b6			      ; Insert first free block at bottom of heap, consumes entire heap 
11b6 21 98 e2		      ld    HL, heap_start+heap_size-4 
11b9 22 a4 5e		      ld    (heap_start), HL        ; Next block (end of free list) 
11bc 21 f4 83		      ld    HL, heap_size-4 
11bf 22 a6 5e		      ld    (heap_start+2), HL      ; Block size 
11c2			 
11c2			      ; Insert end of free list block at top of heap - two null words will 
11c2			      ; terminate the free list 
11c2 21 00 00		      ld    HL, 0 
11c5 22 9a e2		      ld    (heap_start+heap_size-2), HL 
11c8 22 98 e2		      ld    (heap_start+heap_size-4), HL 
11cb			 
11cb e1			      pop   HL 
11cc			 
11cc c9			      ret 
11cd			 
11cd			 
11cd			;------------------------------------------------------------------------------ 
11cd			;     malloc                                                                  : 
11cd			;                                                                             : 
11cd			; Description                                                                 : 
11cd			;     Allocates the wanted space from the heap and returns the address of the : 
11cd			;     first useable byte of the allocation.                                   : 
11cd			;                                                                             : 
11cd			;     Allocations can happen in one of two ways:                              : 
11cd			;                                                                             : 
11cd			;     1. A free block may be found which is the exact size wanted. In this    : 
11cd			;        case the block is removed from the free list and retuedn to the      : 
11cd			;        caller.                                                              : 
11cd			;     2. A free block may be found which is larger than the size wanted. In   : 
11cd			;        this case, the larger block is split into two. The first portion of  : 
11cd			;        this block will become the requested space by the malloc call and    : 
11cd			;        is returned to the caller. The second portion becomes a new free     : 
11cd			;        block, and the free list is adjusted to maintain continuity via this : 
11cd			;        newly created block.                                                 : 
11cd			;                                                                             : 
11cd			;     malloc does not set any initial value in the allocated space, the       : 
11cd			;     caller is required to do this as required.                              : 
11cd			;                                                                             : 
11cd			;     This implementation of malloc uses the stack exclusively, and is        : 
11cd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11cd			;     advisable to disable interrupts before calling malloc, and recommended  : 
11cd			;     to avoid the use of malloc inside ISRs in general.                      : 
11cd			;                                                                             : 
11cd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11cd			;                                                                             : 
11cd			; Parameters                                                                  : 
11cd			;     HL  Number of bytes wanted                                              : 
11cd			;                                                                             : 
11cd			; Returns                                                                     : 
11cd			;     HL  Address of the first useable byte of the allocation                 : 
11cd			;                                                                             : 
11cd			; Flags                                                                       : 
11cd			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11cd			;                                                                             : 
11cd			; Stack frame                                                                 : 
11cd			;       |             |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     BC      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     DE      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     IX      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |  prev_free  |                                                       : 
11cd			;   +4  +-------------+                                                       : 
11cd			;       |  this_free  |                                                       : 
11cd			;   +2  +-------------+                                                       : 
11cd			;       |  next_free  |                                                       : 
11cd			;   +0  +-------------+                                                       : 
11cd			;       |             |                                                       : 
11cd			;                                                                             : 
11cd			;------------------------------------------------------------------------------ 
11cd			 
11cd			 
11cd			;malloc: 
11cd			; 
11cd			;	SAVESP ON 1 
11cd			; 
11cd			;	call malloc_code 
11cd			; 
11cd			;	CHECKSP ON 1 
11cd			;	ret 
11cd			 
11cd			 
11cd			malloc: 
11cd c5			      push  BC 
11ce d5			      push  DE 
11cf dd e5		      push  IX 
11d1			if DEBUG_FORTH_MALLOC_HIGH 
11d1			call malloc_guard_entry 
11d1			endif 
11d1			 
11d1					if DEBUG_FORTH_MALLOC 
11d1						DMARK "mal" 
11d1						CALLMONITOR 
11d1					endif 
11d1 7c			      ld    A, H                    ; Exit if no space requested 
11d2 b5			      or    L 
11d3 ca 92 12		      jp    Z, malloc_early_exit 
11d6			 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			; 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			 
11d6			 
11d6			 
11d6			 
11d6					if DEBUG_FORTH_MALLOC 
11d6						DMARK "maA" 
11d6						CALLMONITOR 
11d6					endif 
11d6			      ; Set up stack frame 
11d6 eb			      ex    DE, HL 
11d7 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11da 39			      add   HL, SP 
11db f9			      ld    SP, HL 
11dc dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e0 dd 39		      add   IX, SP 
11e2			 
11e2			      ; Setup initial state 
11e2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e5 19			      add   HL, DE 
11e6			 
11e6 44			      ld    B, H                    ; Move want to BC 
11e7 4d			      ld    C, L 
11e8			 
11e8 21 9f 5e		      ld    HL, free_list           ; Store prev_free ptr to stack 
11eb dd 75 04		      ld    (IX+4), L 
11ee dd 74 05		      ld    (IX+5), H 
11f1			 
11f1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f2 23			      inc   HL 
11f3 56			      ld    D, (HL) 
11f4 dd 73 02		      ld    (IX+2), E 
11f7 dd 72 03		      ld    (IX+3), D 
11fa eb			      ex    DE, HL                  ; this_free ptr into HL 
11fb			 
11fb					if DEBUG_FORTH_MALLOC 
11fb						DMARK "maB" 
11fb						CALLMONITOR 
11fb					endif 
11fb			      ; Loop through free block list to find some space 
11fb			malloc_find_space: 
11fb 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11fc 23			      inc   HL 
11fd 56			      ld    D, (HL) 
11fe			 
11fe 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11ff b3			      or    E 
1200 ca 8c 12		      jp    Z, malloc_no_space 
1203			 
1203 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1206 dd 72 01		      ld    (IX+1), D 
1209			 
1209			      ; Does this block have enough space to make the allocation? 
1209 23			      inc   HL                      ; Load free block size into DE 
120a 5e			      ld    E, (HL) 
120b 23			      inc   HL 
120c 56			      ld    D, (HL) 
120d			 
120d eb			      ex    DE, HL                  ; Check size of block against want 
120e b7			      or    A                       ; Ensure carry flag clear 
120f ed 42		      sbc   HL, BC 
1211 e5			      push  HL                      ; Store the result for later (new block size) 
1212			 
1212 ca 61 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1215 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1217			 
1217			      ; this_free block is not big enough, setup ptrs to test next free block 
1217 e1			      pop   HL                      ; Discard previous result 
1218			 
1218 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121b dd 66 03		      ld    H, (IX+3) 
121e dd 75 04		      ld    (IX+4), L 
1221 dd 74 05		      ld    (IX+5), H 
1224			 
1224 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1227 dd 66 01		      ld    H, (IX+1) 
122a dd 75 02		      ld    (IX+2), L 
122d dd 74 03		      ld    (IX+3), H 
1230			 
1230					if DEBUG_FORTH_MALLOC 
1230						DMARK "MA>" 
1230						CALLMONITOR 
1230					endif 
1230 18 c9		      jr    malloc_find_space 
1232			 
1232			      ; split a bigger block into two - requested size and remaining size 
1232			malloc_alloc_split: 
1232					if DEBUG_FORTH_MALLOC 
1232						DMARK "MAs" 
1232						CALLMONITOR 
1232					endif 
1232 eb			      ex    DE, HL                  ; Calculate address of new free block 
1233 2b			      dec   HL 
1234 2b			      dec   HL 
1235 2b			      dec   HL 
1236 09			      add   HL, BC 
1237			 
1237			      ; Create a new block and point it at next_free 
1237 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123a dd 56 01		      ld    D, (IX+1) 
123d			 
123d 73			      ld    (HL), E                 ; Store next_free ptr into new block 
123e 23			      inc   HL 
123f 72			      ld    (HL), D 
1240			 
1240 d1			      pop   DE                      ; Store size of new block into new block 
1241 23			      inc   HL 
1242 73			      ld    (HL), E 
1243 23			      inc   HL 
1244 72			      ld    (HL), D 
1245			 
1245			      ; Update this_free ptr to point to new block 
1245 2b			      dec   HL 
1246 2b			      dec   HL 
1247 2b			      dec   HL 
1248			 
1248 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124b dd 56 03		      ld    D, (IX+3) 
124e			 
124e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1251 dd 74 03		      ld    (IX+3), H 
1254			 
1254			      ; Modify this_free block to be allocation 
1254 eb			      ex    DE, HL 
1255 af			      xor   A                       ; Null the next block ptr of allocated block 
1256 77			      ld    (HL), A 
1257 23			      inc   HL 
1258 77			      ld    (HL), A 
1259			 
1259 23			      inc   HL                      ; Store want size into allocated block 
125a 71			      ld    (HL), C 
125b 23			      inc   HL 
125c 70			      ld    (HL), B 
125d 23			      inc   HL 
125e e5			      push  HL                      ; Address of allocation to return 
125f			 
125f 18 19		      jr    malloc_update_links 
1261			 
1261			malloc_alloc_fit: 
1261 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1262			 
1262					if DEBUG_FORTH_MALLOC 
1262						DMARK "MAf" 
1262						CALLMONITOR 
1262					endif 
1262			      ; Modify this_free block to be allocation 
1262 eb			      ex    DE, HL 
1263 2b			      dec   HL 
1264 2b			      dec   HL 
1265 2b			      dec   HL 
1266			 
1266 af			      xor   A                       ; Null the next block ptr of allocated block 
1267 77			      ld    (HL), A 
1268 23			      inc   HL 
1269 77			      ld    (HL), A 
126a			 
126a 23			      inc   HL                      ; Store address of allocation to return 
126b 23			      inc   HL 
126c 23			      inc   HL 
126d e5			      push  HL 
126e			 
126e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
126e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1271 dd 66 01		      ld    H, (IX+1) 
1274			 
1274 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1277 dd 74 03		      ld    (IX+3), H 
127a			 
127a			 
127a			malloc_update_links: 
127a			      ; Update prev_free ptr to point to this_free 
127a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
127d dd 66 05		      ld    H, (IX+5) 
1280			 
1280 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1283 dd 56 03		      ld    D, (IX+3) 
1286			 
1286 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1287 23			      inc   HL 
1288 72			      ld    (HL), D 
1289			 
1289					if DEBUG_FORTH_MALLOC 
1289						DMARK "Mul" 
1289						CALLMONITOR 
1289					endif 
1289			      ; Clear the Z flag to indicate successful allocation 
1289 7a			      ld    A, D 
128a b3			      or    E 
128b			 
128b d1			      pop   DE                      ; Address of allocation 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "MAu" 
128c						CALLMONITOR 
128c					endif 
128c			 
128c			malloc_no_space: 
128c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
128f 39			      add   HL, SP 
1290 f9			      ld    SP, HL 
1291			 
1291 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAN" 
1292						CALLMONITOR 
1292					endif 
1292			 
1292			malloc_early_exit: 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAx" 
1292						CALLMONITOR 
1292					endif 
1292 dd e1		      pop   IX 
1294 d1			      pop   DE 
1295 c1			      pop   BC 
1296			 
1296			if DEBUG_FORTH_MALLOC_HIGH 
1296			call malloc_guard_exit 
1296			call malloc_guard_zerolen 
1296			endif 
1296 c9			      ret 
1297			 
1297			 
1297			;------------------------------------------------------------------------------ 
1297			;     free                                                                    : 
1297			;                                                                             : 
1297			; Description                                                                 : 
1297			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1297			;     returned by malloc, otherwise the behaviour is undefined.               : 
1297			;                                                                             : 
1297			;     Where possible, directly adjacent free blocks will be merged together   : 
1297			;     into larger blocks to help ensure that the heap does not become         : 
1297			;     excessively fragmented.                                                 : 
1297			;                                                                             : 
1297			;     free does not clear or set any other value into the freed space, and    : 
1297			;     therefore its contents may be visible through subsequent malloc's. The  : 
1297			;     caller should clear the freed space as required.                        : 
1297			;                                                                             : 
1297			;     This implementation of free uses the stack exclusively, and is          : 
1297			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1297			;     advisable to disable interrupts before calling free, and recommended    : 
1297			;     to avoid the use of free inside ISRs in general.                        : 
1297			;                                                                             : 
1297			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1297			;                                                                             : 
1297			; Parameters                                                                  : 
1297			;     HL  Pointer to address of first byte of allocation to be freed          : 
1297			;                                                                             : 
1297			; Returns                                                                     : 
1297			;     Nothing                                                                 : 
1297			;                                                                             : 
1297			; Stack frame                                                                 : 
1297			;       |             |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     BC      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     DE      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     IX      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |  prev_free  |                                                       : 
1297			;   +2  +-------------+                                                       : 
1297			;       |  next_free  |                                                       : 
1297			;   +0  +-------------+                                                       : 
1297			;       |             |                                                       : 
1297			;                                                                             : 
1297			;------------------------------------------------------------------------------ 
1297			free: 
1297 c5			      push  BC 
1298 d5			      push  DE 
1299 dd e5		      push  IX 
129b			 
129b 7c			      ld    A, H                    ; Exit if ptr is null 
129c b5			      or    L 
129d ca 61 13		      jp    Z, free_early_exit 
12a0			 
12a0			      ; Set up stack frame 
12a0 eb			      ex    DE, HL 
12a1 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a4 39			      add   HL, SP 
12a5 f9			      ld    SP, HL 
12a6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12aa dd 39		      add   IX, SP 
12ac			 
12ac			      ; The address in HL points to the start of the useable allocated space, 
12ac			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12ac			      ; address of the block itself. 
12ac eb			      ex    DE, HL 
12ad 11 fc ff		      ld    DE, -4 
12b0 19			      add   HL, DE 
12b1			 
12b1			      ; An allocated block must have a null next block pointer in it 
12b1 7e			      ld    A, (HL) 
12b2 23			      inc   HL 
12b3 b6			      or    (HL) 
12b4 c2 5c 13		      jp    NZ, free_done 
12b7			 
12b7 2b			      dec   HL 
12b8			 
12b8 44			      ld    B, H                    ; Copy HL to BC 
12b9 4d			      ld    C, L 
12ba			 
12ba			      ; Loop through the free list to find the first block with an address 
12ba			      ; higher than the block being freed 
12ba 21 9f 5e		      ld    HL, free_list 
12bd			 
12bd			free_find_higher_block: 
12bd 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12be 23			      inc   HL 
12bf 56			      ld    D, (HL) 
12c0 2b			      dec   HL 
12c1			 
12c1 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c4 dd 72 01		      ld    (IX+1), D 
12c7 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12ca dd 74 03		      ld    (IX+3), H 
12cd			 
12cd 78			      ld    A, B                    ; Check if DE is greater than BC 
12ce ba			      cp    D                       ; Compare MSB first 
12cf 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d1 30 04		      jr    NC, free_find_higher_block_skip 
12d3 79			      ld    A, C 
12d4 bb			      cp    E                       ; Then compare LSB 
12d5 38 08		      jr    C, free_found_higher_block 
12d7			 
12d7			free_find_higher_block_skip: 
12d7 7a			      ld    A, D                    ; Reached the end of the free list? 
12d8 b3			      or    E 
12d9 ca 5c 13		      jp    Z, free_done 
12dc			 
12dc eb			      ex    DE, HL 
12dd			 
12dd 18 de		      jr    free_find_higher_block 
12df			 
12df			free_found_higher_block: 
12df			      ; Insert freed block between prev and next free blocks 
12df 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e0 23			      inc   HL 
12e1 70			      ld    (HL), B 
12e2			 
12e2 60			      ld    H, B                    ; Point freed block at next free block 
12e3 69			      ld    L, C 
12e4 73			      ld    (HL), E 
12e5 23			      inc   HL 
12e6 72			      ld    (HL), D 
12e7			 
12e7			      ; Check if the freed block is adjacent to the next free block 
12e7 23			      inc   HL                      ; Load size of freed block into HL 
12e8 5e			      ld    E, (HL) 
12e9 23			      inc   HL 
12ea 56			      ld    D, (HL) 
12eb eb			      ex    DE, HL 
12ec			 
12ec 09			      add   HL, BC                  ; Add addr of freed block and its size 
12ed			 
12ed dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f0 dd 56 01		      ld    D, (IX+1) 
12f3			 
12f3 b7			      or    A                       ; Clear the carry flag 
12f4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f6 20 22		      jr    NZ, free_check_adjacent_to_prev 
12f8			 
12f8			      ; Freed block is adjacent to next, merge into one bigger block 
12f8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12f9 5e			      ld    E, (HL) 
12fa 23			      inc   HL 
12fb 56			      ld    D, (HL) 
12fc e5			      push  HL                      ; Save ptr to next block for later 
12fd			 
12fd 60			      ld    H, B                    ; Store ptr from next block into freed block 
12fe 69			      ld    L, C 
12ff 73			      ld    (HL), E 
1300 23			      inc   HL 
1301 72			      ld    (HL), D 
1302			 
1302 e1			      pop   HL                      ; Restore ptr to next block 
1303 23			      inc   HL                      ; Load size of next block into DE 
1304 5e			      ld    E, (HL) 
1305 23			      inc   HL 
1306 56			      ld    D, (HL) 
1307 d5			      push  DE                      ; Save next block size for later 
1308			 
1308 60			      ld    H, B                    ; Load size of freed block into HL 
1309 69			      ld    L, C 
130a 23			      inc   HL 
130b 23			      inc   HL 
130c 5e			      ld    E, (HL) 
130d 23			      inc   HL 
130e 56			      ld    D, (HL) 
130f eb			      ex    DE, HL 
1310			 
1310 d1			      pop   DE                      ; Restore size of next block 
1311 19			      add   HL, DE                  ; Add sizes of both blocks 
1312 eb			      ex    DE, HL 
1313			 
1313 60			      ld    H, B                    ; Store new bigger size into freed block 
1314 69			      ld    L, C 
1315 23			      inc   HL 
1316 23			      inc   HL 
1317 73			      ld    (HL), E 
1318 23			      inc   HL 
1319 72			      ld    (HL), D 
131a			 
131a			free_check_adjacent_to_prev: 
131a			      ; Check if the freed block is adjacent to the prev free block 
131a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
131d dd 66 03		      ld    H, (IX+3) 
1320			 
1320 23			      inc   HL                      ; Size of prev free block into DE 
1321 23			      inc   HL 
1322 5e			      ld    E, (HL) 
1323 23			      inc   HL 
1324 56			      ld    D, (HL) 
1325 2b			      dec   HL 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328			 
1328 19			      add   HL, DE                  ; Add prev block addr and size 
1329			 
1329 b7			      or    A                       ; Clear the carry flag 
132a ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132c 20 2e		      jr    NZ, free_done 
132e			 
132e			      ; Freed block is adjacent to prev, merge into one bigger block 
132e 60			      ld    H, B                    ; Load next ptr from freed block into DE 
132f 69			      ld    L, C 
1330 5e			      ld    E, (HL) 
1331 23			      inc   HL 
1332 56			      ld    D, (HL) 
1333 e5			      push  HL                      ; Save freed block ptr for later 
1334			 
1334 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1337 dd 66 03		      ld    H, (IX+3) 
133a 73			      ld    (HL), E 
133b 23			      inc   HL 
133c 72			      ld    (HL), D 
133d			 
133d e1			      pop   HL                      ; Restore freed block ptr 
133e 23			      inc   HL                      ; Load size of freed block into DE 
133f 5e			      ld    E, (HL) 
1340 23			      inc   HL 
1341 56			      ld    D, (HL) 
1342 d5			      push  DE                      ; Save freed block size for later 
1343			 
1343 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1346 dd 66 03		      ld    H, (IX+3) 
1349 23			      inc   HL 
134a 23			      inc   HL 
134b 5e			      ld    E, (HL) 
134c 23			      inc   HL 
134d 56			      ld    D, (HL) 
134e			 
134e e1			      pop   HL                      ; Add sizes of both blocks 
134f 19			      add   HL, DE 
1350 eb			      ex    DE, HL 
1351			 
1351 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1354 dd 66 03		      ld    H, (IX+3) 
1357 23			      inc   HL 
1358 23			      inc   HL 
1359 73			      ld    (HL), E 
135a 23			      inc   HL 
135b 72			      ld    (HL), D 
135c			 
135c			free_done: 
135c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
135f 39			      add   HL, SP 
1360 f9			      ld    SP, HL 
1361			 
1361			free_early_exit: 
1361 dd e1		      pop   IX 
1363 d1			      pop   DE 
1364 c1			      pop   BC 
1365			 
1365 c9			      ret 
1366			 
1366			; moved to firmware.asm 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			;                  .dw   0 
1366			 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_3 
1366			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1366			;heap_start        .equ  0x9000      ; Starting address of heap 
1366			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1366			; 
1366			 ;     .org 0 
1366			  ;    jp    main 
1366			; 
1366			; 
1366			 ;     .org  0x100 
1366			;main: 
1366			 ;     ld    HL, 0x8100 
1366			  ;    ld    SP, HL 
1366			; 
1366			;      call  heap_init 
1366			 
1366			      ; Make some allocations 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9004 
1366			; 
1366			 ;     ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9014 
1366			 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9024 
1366			 
1366			      ; Free some allocations 
1366			;      ld    HL, 0x9014 
1366			;      call  free 
1366			 
1366			;      ld    HL, 0x9004 
1366			;      call  free 
1366			; 
1366			;      ld    HL, 0x9024 
1366			;      call  free 
1366			 
1366			 
1366			 ;     halt 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     heap_init                                                               : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Initialise the heap and make it ready for malloc and free operations.   : 
1366			;                                                                             : 
1366			;     The heap is maintained as a linked list, starting with an initial       : 
1366			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1366			;     the first free block in the heap. Each block then points to the next    : 
1366			;     free block within the heap, and the free list ends at the first block   : 
1366			;     with a null pointer to the next free block.                             : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     Inputs are compile-time only. Two defines which specify the starting    : 
1366			;     address of the heap and its size are required, along with a memory      : 
1366			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1366			;     principally stores a pointer to the first free block in the heap.       : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;------------------------------------------------------------------------------ 
1366			heap_init: 
1366			      push  HL 
1366			 
1366			      ; Initialise free list struct 
1366			      ld    HL, heap_start 
1366			      ld    (free_list), HL 
1366			      ld    HL, 0 
1366			      ld    (free_list+2), HL 
1366			 
1366			      ; Insert first free block at bottom of heap, consumes entire heap 
1366			      ld    HL, heap_start+heap_size-4 
1366			      ld    (heap_start), HL        ; Next block (end of free list) 
1366			      ld    HL, heap_size-4 
1366			      ld    (heap_start+2), HL      ; Block size 
1366			 
1366			      ; Insert end of free list block at top of heap - two null words will 
1366			      ; terminate the free list 
1366			      ld    HL, 0 
1366			      ld    (heap_start+heap_size-2), HL 
1366			      ld    (heap_start+heap_size-4), HL 
1366			 
1366			      pop   HL 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     malloc                                                                  : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Allocates the wanted space from the heap and returns the address of the : 
1366			;     first useable byte of the allocation.                                   : 
1366			;                                                                             : 
1366			;     Allocations can happen in one of two ways:                              : 
1366			;                                                                             : 
1366			;     1. A free block may be found which is the exact size wanted. In this    : 
1366			;        case the block is removed from the free list and retuedn to the      : 
1366			;        caller.                                                              : 
1366			;     2. A free block may be found which is larger than the size wanted. In   : 
1366			;        this case, the larger block is split into two. The first portion of  : 
1366			;        this block will become the requested space by the malloc call and    : 
1366			;        is returned to the caller. The second portion becomes a new free     : 
1366			;        block, and the free list is adjusted to maintain continuity via this : 
1366			;        newly created block.                                                 : 
1366			;                                                                             : 
1366			;     malloc does not set any initial value in the allocated space, the       : 
1366			;     caller is required to do this as required.                              : 
1366			;                                                                             : 
1366			;     This implementation of malloc uses the stack exclusively, and is        : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling malloc, and recommended  : 
1366			;     to avoid the use of malloc inside ISRs in general.                      : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Number of bytes wanted                                              : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     HL  Address of the first useable byte of the allocation                 : 
1366			;                                                                             : 
1366			; Flags                                                                       : 
1366			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +4  +-------------+                                                       : 
1366			;       |  this_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			malloc: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if no space requested 
1366			      or    L 
1366			      jp    Z, malloc_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; Setup initial state 
1366			      ld    HL, 4                   ; want must also include space used by block struct 
1366			      add   HL, DE 
1366			 
1366			      ld    B, H                    ; Move want to BC 
1366			      ld    C, L 
1366			 
1366			      ld    HL, free_list           ; Store prev_free ptr to stack 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    E, (HL)                 ; Store this_free ptr to stack 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ld    (IX+2), E 
1366			      ld    (IX+3), D 
1366			      ex    DE, HL                  ; this_free ptr into HL 
1366			 
1366			      ; Loop through free block list to find some space 
1366			malloc_find_space: 
1366			      ld    E, (HL)                 ; Load next_free ptr into DE 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1366			      or    E 
1366			      jp    Z, malloc_no_space 
1366			 
1366			      ld    (IX+0), E               ; Store next_free ptr to stack 
1366			      ld    (IX+1), D 
1366			 
1366			      ; Does this block have enough space to make the allocation? 
1366			      inc   HL                      ; Load free block size into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ex    DE, HL                  ; Check size of block against want 
1366			      or    A                       ; Ensure carry flag clear 
1366			      sbc   HL, BC 
1366			      push  HL                      ; Store the result for later (new block size) 
1366			 
1366			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1366			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1366			 
1366			      ; this_free block is not big enough, setup ptrs to test next free block 
1366			      pop   HL                      ; Discard previous result 
1366			 
1366			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1366			      ld    H, (IX+3) 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1366			      ld    H, (IX+1) 
1366			      ld    (IX+2), L 
1366			      ld    (IX+3), H 
1366			 
1366			      jr    malloc_find_space 
1366			 
1366			      ; split a bigger block into two - requested size and remaining size 
1366			malloc_alloc_split: 
1366			      ex    DE, HL                  ; Calculate address of new free block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      add   HL, BC 
1366			 
1366			      ; Create a new block and point it at next_free 
1366			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      ld    (HL), E                 ; Store next_free ptr into new block 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   DE                      ; Store size of new block into new block 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Update this_free ptr to point to new block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1366			      ld    (IX+3), H 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store want size into allocated block 
1366			      ld    (HL), C 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			      inc   HL 
1366			      push  HL                      ; Address of allocation to return 
1366			 
1366			      jr    malloc_update_links 
1366			 
1366			malloc_alloc_fit: 
1366			      pop   HL                      ; Dont need new block size, want is exact fit 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store address of allocation to return 
1366			      inc   HL 
1366			      inc   HL 
1366			      push  HL 
1366			 
1366			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1366			      ld    L, (IX+0)               ; next_free to HL 
1366			      ld    H, (IX+1) 
1366			 
1366			      ld    (IX+2), L               ; HL to this_free 
1366			      ld    (IX+3), H 
1366			 
1366			 
1366			malloc_update_links: 
1366			      ; Update prev_free ptr to point to this_free 
1366			      ld    L, (IX+4)               ; prev_free ptr to HL 
1366			      ld    H, (IX+5) 
1366			 
1366			      ld    E, (IX+2)               ; this_free ptr to DE 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (HL), E                 ; this_free ptr into prev_free 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Clear the Z flag to indicate successful allocation 
1366			      ld    A, D 
1366			      or    E 
1366			 
1366			      pop   DE                      ; Address of allocation 
1366			 
1366			malloc_no_space: 
1366			      ld    HL, 6                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			      ex    DE, HL                  ; Alloc addr into HL for return 
1366			 
1366			malloc_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     free                                                                    : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1366			;     returned by malloc, otherwise the behaviour is undefined.               : 
1366			;                                                                             : 
1366			;     Where possible, directly adjacent free blocks will be merged together   : 
1366			;     into larger blocks to help ensure that the heap does not become         : 
1366			;     excessively fragmented.                                                 : 
1366			;                                                                             : 
1366			;     free does not clear or set any other value into the freed space, and    : 
1366			;     therefore its contents may be visible through subsequent malloc's. The  : 
1366			;     caller should clear the freed space as required.                        : 
1366			;                                                                             : 
1366			;     This implementation of free uses the stack exclusively, and is          : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling free, and recommended    : 
1366			;     to avoid the use of free inside ISRs in general.                        : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Pointer to address of first byte of allocation to be freed          : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			free: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if ptr is null 
1366			      or    L 
1366			      jp    Z, free_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; The address in HL points to the start of the useable allocated space, 
1366			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1366			      ; address of the block itself. 
1366			      ex    DE, HL 
1366			      ld    DE, -4 
1366			      add   HL, DE 
1366			 
1366			      ; An allocated block must have a null next block pointer in it 
1366			      ld    A, (HL) 
1366			      inc   HL 
1366			      or    (HL) 
1366			      jp    NZ, free_done 
1366			 
1366			      dec   HL 
1366			 
1366			      ld    B, H                    ; Copy HL to BC 
1366			      ld    C, L 
1366			 
1366			      ; Loop through the free list to find the first block with an address 
1366			      ; higher than the block being freed 
1366			      ld    HL, free_list 
1366			 
1366			free_find_higher_block: 
1366			      ld    E, (HL)                 ; Load next ptr from free block 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			 
1366			      ld    (IX+0), E               ; Save ptr to next free block 
1366			      ld    (IX+1), D 
1366			      ld    (IX+2), L               ; Save ptr to prev free block 
1366			      ld    (IX+3), H 
1366			 
1366			      ld    A, B                    ; Check if DE is greater than BC 
1366			      cp    D                       ; Compare MSB first 
1366			      jr    Z, $+4                  ; MSB the same, compare LSB 
1366			      jr    NC, free_find_higher_block_skip 
1366			      ld    A, C 
1366			      cp    E                       ; Then compare LSB 
1366			      jr    C, free_found_higher_block 
1366			 
1366			free_find_higher_block_skip: 
1366			      ld    A, D                    ; Reached the end of the free list? 
1366			      or    E 
1366			      jp    Z, free_done 
1366			 
1366			      ex    DE, HL 
1366			 
1366			      jr    free_find_higher_block 
1366			 
1366			free_found_higher_block: 
1366			      ; Insert freed block between prev and next free blocks 
1366			      ld    (HL), C                 ; Point prev free block to freed block 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			 
1366			      ld    H, B                    ; Point freed block at next free block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Check if the freed block is adjacent to the next free block 
1366			      inc   HL                      ; Load size of freed block into HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      add   HL, BC                  ; Add addr of freed block and its size 
1366			 
1366			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_check_adjacent_to_prev 
1366			 
1366			      ; Freed block is adjacent to next, merge into one bigger block 
1366			      ex    DE, HL                  ; Load next ptr from next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save ptr to next block for later 
1366			 
1366			      ld    H, B                    ; Store ptr from next block into freed block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore ptr to next block 
1366			      inc   HL                      ; Load size of next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save next block size for later 
1366			 
1366			      ld    H, B                    ; Load size of freed block into HL 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      pop   DE                      ; Restore size of next block 
1366			      add   HL, DE                  ; Add sizes of both blocks 
1366			      ex    DE, HL 
1366			 
1366			      ld    H, B                    ; Store new bigger size into freed block 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_check_adjacent_to_prev: 
1366			      ; Check if the freed block is adjacent to the prev free block 
1366			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1366			      ld    H, (IX+3) 
1366			 
1366			      inc   HL                      ; Size of prev free block into DE 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      add   HL, DE                  ; Add prev block addr and size 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_done 
1366			 
1366			      ; Freed block is adjacent to prev, merge into one bigger block 
1366			      ld    H, B                    ; Load next ptr from freed block into DE 
1366			      ld    L, C 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save freed block ptr for later 
1366			 
1366			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1366			      ld    H, (IX+3) 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore freed block ptr 
1366			      inc   HL                      ; Load size of freed block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save freed block size for later 
1366			 
1366			      ld    L, (IX+2)               ; Load size of prev block into DE 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      pop   HL                      ; Add sizes of both blocks 
1366			      add   HL, DE 
1366			      ex    DE, HL 
1366			 
1366			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_done: 
1366			      ld    HL, 4                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			free_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;      .org 0x8000 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			 ;                 .dw   0 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_4 
1366			 
1366			; My memory allocation code. Very very simple.... 
1366			; allocate space under 250 chars 
1366			 
1366			heap_init: 
1366				; init start of heap as zero 
1366				;  
1366			 
1366				ld hl, heap_start 
1366				ld a, 0 
1366				ld (hl), a      ; empty block 
1366				inc hl 
1366				ld a, 0 
1366				ld (hl), a      ; length of block 
1366				; write end of list 
1366				inc hl 
1366				ld a,(hl) 
1366				inc hl 
1366				ld a,(hl) 
1366				 
1366			 
1366				; init some malloc vars 
1366			 
1366				ld hl, 0 
1366				ld (free_list), hl       ; store last malloc location 
1366			 
1366				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1366				ld a, 0 
1366				ld (hl), a 
1366			 
1366			 
1366				ld hl, heap_start 
1366				;  
1366				  
1366				ret 
1366			 
1366			 
1366			;    free block marker 
1366			;    requested size  
1366			;    pointer to next block 
1366			;    .... 
1366			;    next block marker 
1366			 
1366			 
1366			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1366			; 
1366			 
1366			 
1366			malloc:  
1366				push de 
1366				push bc 
1366				push af 
1366			 
1366				; hl space required 
1366				 
1366				ld c, l    ; hold space   (TODO only a max of 255) 
1366			 
1366			;	inc c     ; TODO BUG need to fix memory leak on push str 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			 
1366			 
1366			 
1366				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1366			 
1366				ld a, (free_list+3) 
1366				cp 0 
1366				jr z, .contheap 
1366			 
1366				ld hl, (free_list)     ; get last alloc 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mrs" 
1366						CALLMONITOR 
1366					endif 
1366				jr .startalloc 
1366			 
1366			.contheap: 
1366				ld hl, heap_start 
1366			 
1366			.startalloc: 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mym" 
1366						CALLMONITOR 
1366					endif 
1366			.findblock: 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmf" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366				ld a,(hl)  
1366				; if byte is zero then clear to use 
1366			 
1366				cp 0 
1366				jr z, .foundemptyblock 
1366			 
1366				; if byte is not clear 
1366				;     then byte is offset to next block 
1366			 
1366				inc hl 
1366				ld a, (hl) ; get size 
1366			.nextblock:	inc hl 
1366					ld e, (hl) 
1366					inc hl 
1366					ld d, (hl) 
1366					ex de, hl 
1366			;	inc hl  ; move past the store space 
1366			;	inc hl  ; move past zero index  
1366			 
1366				; TODO detect no more space 
1366			 
1366				push hl 
1366				ld de, heap_end 
1366				call cmp16 
1366				pop hl 
1366				jr nc, .nospace 
1366			 
1366				jr .findblock 
1366			 
1366			.nospace: ld hl, 0 
1366				jp .exit 
1366			 
1366			 
1366			.foundemptyblock:	 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mme" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; TODO has block enough space if reusing??? 
1366			 
1366				;  
1366			 
1366			; see if this block has been previously used 
1366				inc hl 
1366				ld a, (hl) 
1366				dec hl 
1366				cp 0 
1366				jr z, .newblock 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meR" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; no reusing previously allocated block 
1366			 
1366			; is it smaller than previously used? 
1366				 
1366				inc hl    ; move to size 
1366				ld a, c 
1366				sub (hl)        ; we want c < (hl) 
1366				dec hl    ; move back to marker 
1366			        jr z, .findblock 
1366			 
1366				; update with the new size which should be lower 
1366			 
1366			        ;inc  hl   ; negate next move. move back to size  
1366			 
1366			.newblock: 
1366				; need to be at marker here 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meN" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			 
1366				ld a, c 
1366			 
1366				ld (free_list+3), a	 ; flag resume from last malloc  
1366				ld (free_list), hl    ; save out last location 
1366			 
1366			 
1366				;inc a     ; space for length byte 
1366				ld (hl), a     ; save block in use marker 
1366			 
1366				inc hl   ; move to space marker 
1366				ld (hl), a    ; save new space 
1366			 
1366				inc hl   ; move to start of allocated area 
1366				 
1366			;	push hl     ; save where we are - 1  
1366			 
1366			;	inc hl  ; move past zero index  
1366				; skip space to set down new marker 
1366			 
1366				; provide some extra space for now 
1366			 
1366				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1366				inc a 
1366				inc a 
1366			 
1366				push hl   ; save where we are in the node block 
1366			 
1366				call addatohl 
1366			 
1366				; write linked list point 
1366			 
1366				pop de     ; get our node position 
1366				ex de, hl 
1366			 
1366				ld (hl), e 
1366				inc hl 
1366				ld (hl), d 
1366			 
1366				inc hl 
1366			 
1366				; now at start of allocated data so save pointer 
1366			 
1366				push hl 
1366			 
1366				; jump to position of next node and setup empty header in DE 
1366			 
1366				ex de, hl 
1366			 
1366			;	inc hl ; move past end of block 
1366			 
1366				ld a, 0 
1366				ld (hl), a   ; empty marker 
1366				inc hl 
1366				ld (hl), a   ; size 
1366				inc hl  
1366				ld (hl), a   ; ptr 
1366				inc hl 
1366				ld (hl), a   ; ptr 
1366			 
1366			 
1366				pop hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmr" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			.exit: 
1366				pop af 
1366				pop bc 
1366				pop de  
1366				ret 
1366			 
1366			 
1366			 
1366			 
1366			free:  
1366				push hl 
1366				push af 
1366				; get address in hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "fre" 
1366						CALLMONITOR 
1366					endif 
1366				; data is at hl - move to block count 
1366				dec hl 
1366				dec hl    ; get past pointer 
1366				dec hl 
1366			 
1366				ld a, (hl)    ; need this for a validation check 
1366			 
1366				dec hl    ; move to block marker 
1366			 
1366				; now check that the block count and block marker are the same  
1366			        ; this checks that we are on a malloc node and not random memory 
1366			        ; OK a faint chance this could be a problem but rare - famous last words! 
1366			 
1366				ld c, a 
1366				ld a, (hl)    
1366			 
1366				cp c 
1366				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1366			 
1366				; yes good chance we are on a malloc node 
1366			 
1366				ld a, 0      
1366				ld (hl), a   ; mark as free 
1366			 
1366				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1366			 
1366			.freeignore:  
1366			 
1366				pop af 
1366				pop hl 
1366			 
1366				ret 
1366			 
1366			 
1366			 
1366			endif 
1366			 
1366			; eof 
# End of file firmware_memory.asm
1366			  
1366			; device C  
1366			; Now handled by SPI  
1366			;if SOUND_ENABLE  
1366			;	include "firmware_sound.asm"  
1366			;endif  
1366			  
1366			include "firmware_diags.asm"  
1366			; Hardware diags menu 
1366			 
1366			 
1366			config: 
1366			 
1366 3e 00			ld a, 0 
1368 21 8c 13			ld hl, .configmn 
136b cd f6 0b			call menu 
136e			 
136e fe 00			cp 0 
1370 c8				ret z 
1371			 
1371			;	cp 1 
1371			;	call z, .savetostore 
1371			 
1371 fe 01			cp 1 
1373			if STARTUP_V1 
1373 cc a2 13			call z, .selautoload 
1376			endif 
1376			 
1376			if STARTUP_V2 
1376				call z, .enautoload 
1376			endif 
1376 fe 02			cp 2 
1378 cc 98 13			call z, .disautoload 
137b			;	cp 3 
137b			;	call z, .selbank 
137b fe 03			cp 3 
137d cc c0 13			call z, .debug_tog 
1380 fe 04			cp 4 
1382 cc 0e 15			call z, .bpsgo 
1385 fe 05			cp 5 
1387 cc e9 13			call z, hardware_diags 
138a			if STARTUP_V2 
138a				cp 6 
138a				call z, create_startup 
138a			endif 
138a 18 da			jr config 
138c			 
138c			.configmn: 
138c			;	dw prom_c3 
138c fc 16			dw prom_c2 
138e 11 17			dw prom_c2a 
1390			;	dw prom_c2b 
1390			;	dw prom_c4 
1390 30 17			dw prom_m4 
1392 4b 17			dw prom_m4b 
1394 53 17			dw prom_c1 
1396			if STARTUP_V2 
1396				dw prom_c9 
1396			endif 
1396 00 00			dw 0 
1398				 
1398			 
1398			if STARTUP_V2 
1398			.enautoload: 
1398				if STORAGE_SE 
1398				ld a, $fe      ; bit 0 clear 
1398				ld (spi_device), a 
1398			 
1398				call storage_get_block_0 
1398			 
1398				ld a, 1 
1398				ld (store_page+STORE_0_AUTOFILE), a 
1398			 
1398					ld hl, 0 
1398					ld de, store_page 
1398				call storage_write_block	 ; save update 
1398				else 
1398			 
1398				ld hl, prom_notav 
1398				ld de, prom_empty 
1398				call info_panel 
1398				endif 
1398			 
1398			 
1398				ret 
1398			endif 
1398			 
1398			.disautoload: 
1398				if STORAGE_SE 
1398				ld a, $fe      ; bit 0 clear 
1398				ld (spi_device), a 
1398			 
1398				call storage_get_block_0 
1398			 
1398				ld a, 0 
1398				ld (store_page+STORE_0_AUTOFILE), a 
1398			 
1398					ld hl, 0 
1398					ld de, store_page 
1398				call storage_write_block	 ; save update 
1398				else 
1398			 
1398 21 62 17			ld hl, prom_notav 
139b 11 78 17			ld de, prom_empty 
139e cd 56 0b			call info_panel 
13a1				endif 
13a1			 
13a1			 
13a1 c9				ret 
13a2			 
13a2			if STARTUP_V1 
13a2			 
13a2			; Select auto start 
13a2			 
13a2			.selautoload: 
13a2			 
13a2				 
13a2				if STORAGE_SE 
13a2			 
13a2					call config_dir 
13a2				        ld hl, scratch 
13a2					ld a, 0 
13a2					call menu 
13a2			 
13a2					cp 0 
13a2					ret z 
13a2			 
13a2					dec a 
13a2			 
13a2			 
13a2					; locate menu option 
13a2			 
13a2					ld hl, scratch 
13a2					call table_lookup 
13a2			 
13a2					if DEBUG_FORTH_WORDS 
13a2						DMARK "ALl" 
13a2						CALLMONITOR 
13a2					endif 
13a2					; with the pointer to the menu it, the byte following the zero term is the file id 
13a2			 
13a2					ld a, 0 
13a2					ld bc, 50   ; max of bytes to look at 
13a2					cpir  
13a2			 
13a2					if DEBUG_FORTH_WORDS 
13a2						DMARK "ALb" 
13a2						CALLMONITOR 
13a2					endif 
13a2					;inc hl 
13a2			 
13a2					ld a, (hl)   ; file id 
13a2					 
13a2				        ; save bank and file ids 
13a2			 
13a2					push af 
13a2			 
13a2			; TODO need to save to block 0 on bank 1	 
13a2			 
13a2					call storage_get_block_0 
13a2			 
13a2					if DEBUG_FORTH_WORDS 
13a2						DMARK "AL0" 
13a2						CALLMONITOR 
13a2					endif 
13a2					pop af 
13a2			 
13a2					ld (store_page+STORE_0_FILERUN),a 
13a2					 
13a2					; save bank id 
13a2			 
13a2					ld a,(spi_device) 
13a2					ld (store_page+STORE_0_BANKRUN),a 
13a2			 
13a2					; enable auto run of store file 
13a2			 
13a2					ld a, 1 
13a2					ld (store_page+STORE_0_AUTOFILE),a 
13a2			 
13a2					; save buffer 
13a2			 
13a2					ld hl, 0 
13a2					ld de, store_page 
13a2					if DEBUG_FORTH_WORDS 
13a2						DMARK "ALw" 
13a2						CALLMONITOR 
13a2					endif 
13a2				call storage_write_block	 ; save update 
13a2			  
13a2			 
13a2			 
13a2			 
13a2					ld hl, scratch 
13a2					call config_fdir 
13a2			 
13a2				else 
13a2			 
13a2 21 62 17			ld hl, prom_notav 
13a5 11 78 17			ld de, prom_empty 
13a8 cd 56 0b			call info_panel 
13ab			 
13ab				endif 
13ab c9				ret 
13ac			endif 
13ac			 
13ac			 
13ac			; Select storage bank 
13ac			 
13ac			.selbank: 
13ac			 
13ac			;	if STORAGE_SE 
13ac			;	else 
13ac			 
13ac 21 62 17			ld hl, prom_notav 
13af 11 78 17			ld de, prom_empty 
13b2 cd 56 0b			call info_panel 
13b5			;	endif 
13b5				 
13b5 c9				ret 
13b6			 
13b6			if STORAGE_SE 
13b6			 
13b6			.config_ldir:   
13b6				; Load storage bank labels into menu array 
13b6			 
13b6				 
13b6			 
13b6			 
13b6				ret 
13b6			 
13b6			 
13b6			endif 
13b6			 
13b6			 
13b6			; Save user words to storage 
13b6			 
13b6			.savetostore: 
13b6			 
13b6			;	if STORAGE_SE 
13b6			; 
13b6			;		call config_dir 
13b6			;	        ld hl, scratch 
13b6			;		ld a, 0 
13b6			;		call menu 
13b6			;		 
13b6			;		ld hl, scratch 
13b6			;		call config_fdir 
13b6			; 
13b6			;	else 
13b6			 
13b6 21 62 17			ld hl, prom_notav 
13b9 11 78 17			ld de, prom_empty 
13bc cd 56 0b			call info_panel 
13bf			 
13bf			;	endif 
13bf			 
13bf c9				ret 
13c0			 
13c0			if STARTUP_V2 
13c0			 
13c0			create_startup: 
13c0			 
13c0				ld a, 0 
13c0				ld hl, .crstart 
13c0				call menu 
13c0			 
13c0				cp 0 
13c0				ret z 
13c0			 
13c0				cp 1 
13c0				call z, .genlsword 
13c0				cp 2 
13c0				call z, .genedword 
13c0			 
13c0				cp 3 
13c0				call z, .gendemword 
13c0			 
13c0				cp 4 
13c0				call z, .genutlword 
13c0				cp 5 
13c0				call z, .genspiword 
13c0				cp 6 
13c0				call z, .genkeyword 
13c0				cp 7 
13c0				call z, .gensoundword 
13c0				cp 7 
13c0				call z, .genhwword 
13c0				jr create_startup 
13c0			 
13c0			.genhwword: 
13c0				ld hl, crs_hw 
13c0				ld de, .hwworddef 
13c0				call .genfile 
13c0				ret 
13c0			.gensoundword: 
13c0				ld hl, crs_sound 
13c0				ld de, .soundworddef 
13c0				call .genfile 
13c0				ret 
13c0			.genlsword: 
13c0				ld hl, crs_s1 
13c0				ld de, .lsworddef 
13c0				call .genfile 
13c0				ret 
13c0			 
13c0			.genedword: 
13c0				ld de, .edworddef 
13c0				ld hl, crs_s2 
13c0				call .genfile 
13c0				ret 
13c0			 
13c0			.gendemword: 
13c0				ld de, .demoworddef 
13c0				ld hl, crs_s3 
13c0				call .genfile 
13c0				ret 
13c0			 
13c0			.genutlword: 
13c0				ld hl, crs_s4 
13c0				ld de, .utilwordef 
13c0				call .genfile 
13c0				ret 
13c0			.genspiword: 
13c0				ld hl, crs_s5 
13c0				ld de, .spiworddef 
13c0				call .genfile 
13c0				ret 
13c0			.genkeyword: 
13c0				ld hl, crs_s6 
13c0				ld de, .keyworddef 
13c0				call .genfile 
13c0				ret 
13c0			 
13c0			; hl - points to file name 
13c0			; de - points to strings to add to file 
13c0			 
13c0			.genfile: 
13c0				push hl 
13c0				push de 
13c0			 
13c0				call clear_display 
13c0				ld a, display_row_1 
13c0				ld de, .genfiletxt 
13c0				call str_at_display 
13c0				call update_display 
13c0			 
13c0				pop de 
13c0				pop hl 
13c0			 
13c0			 
13c0				push de 
13c0				call storage_create 
13c0				; id in hl 
13c0				pop de   ; table of strings to add 
13c0			 
13c0			.genloop: 
13c0			 
13c0				push hl ; save id for next time around 
13c0				push de ; save de for next time around 
13c0			 
13c0				ex de, hl 
13c0				call loadwordinhl 
13c0				ex de, hl 
13c0			 
13c0				; need hl to be the id 
13c0				; need de to be the string ptr 
13c0				 
13c0				call storage_append 
13c0			 
13c0				pop de 
13c0				pop hl 
13c0			 
13c0				inc de 
13c0				inc de 
13c0			 
13c0				ld a,(de) 
13c0				cp 0 
13c0				jr nz, .genloop 
13c0				inc de 
13c0				ld a, (de) 
13c0				dec de 
13c0				cp 0 
13c0				jr nz, .genloop	 
13c0			 
13c0				ret 
13c0			 
13c0			.genfiletxt:  db "Creating file...",0 
13c0			 
13c0			.hwworddef: 
13c0				dw test5 
13c0				dw test6 
13c0				dw test7 
13c0				dw test8 
13c0				dw test9 
13c0				dw test10 
13c0				dw 0 
13c0			 
13c0			.soundworddef: 
13c0				dw sound1 
13c0				dw sound2 
13c0				dw sound3 
13c0				dw sound4 
13c0				dw sound5 
13c0				dw sound6 
13c0				dw sound7 
13c0				dw sound8 
13c0				dw sound9 
13c0				dw 0 
13c0			 
13c0			.utilwordef: 
13c0				dw strncpy 
13c0				dw type 
13c0				dw clrstack 
13c0				dw longread 
13c0				dw start1 
13c0				dw start2 
13c0			; duplicated 
13c0			;	dw start3b 
13c0			;	dw start3c 
13c0				dw list 
13c0				dw 0 
13c0			 
13c0			.lsworddef: 
13c0				dw start3b 
13c0				dw 0 
13c0			 
13c0			.edworddef: 
13c0				dw edit1 
13c0				dw edit2 
13c0				dw edit3 
13c0				dw 0 
13c0			 
13c0			.demoworddef: 
13c0				dw game1 
13c0				dw game1a 
13c0				dw game1b 
13c0				dw game1c 
13c0				dw game1d 
13c0				dw game1s 
13c0				dw game1t 
13c0				dw game1f 
13c0				dw game1z 
13c0				dw game1zz 
13c0				dw ssv2 
13c0				dw ssv3 
13c0				dw ssv4 
13c0				dw ssv5 
13c0				dw ssv1 
13c0				dw ssv1cpm	 
13c0			;	dw game2b 
13c0			;	dw game2bf 
13c0			;	dw game2mba 
13c0			;	dw game2mbas	 
13c0			;	dw game2mbht 
13c0			;	dw game2mbms 
13c0			;	dw game2mb 
13c0			;	dw game3w 
13c0			;	dw game3p 
13c0			;	dw game3sc 
13c0			;	dw game3vsi 
13c0			;	dw game3vs 
13c0				dw 0 
13c0			 
13c0			 
13c0			.spiworddef: 
13c0			 
13c0			    dw spi1 
13c0			    dw spi2 
13c0			    dw spi2b 
13c0			    dw spi3 
13c0			    dw spi4 
13c0			    dw spi5 
13c0			;    dw spi6 
13c0			;    dw spi7 
13c0			 
13c0			;    dw spi8 
13c0			;    dw spi9 
13c0			;    dw spi10 
13c0			    dw 0 
13c0			 
13c0			.keyworddef: 
13c0			 
13c0				dw keyup 
13c0				dw keydown 
13c0				dw keyleft 
13c0				dw keyright 
13c0				dw 	keyf1 
13c0				dw keyf2 
13c0				dw keyf3 
13c0				dw keyf4 
13c0				dw keyf5 
13c0				dw keyf6 
13c0				dw keyf7 
13c0				dw keyf8 
13c0				dw keyf9 
13c0				dw keyf10 
13c0				dw keyf11 
13c0				dw keyf12 
13c0				dw keytab 
13c0				dw keycr 
13c0				dw keyhome 
13c0				dw keyend 
13c0				dw keybs 
13c0				dw 0 
13c0			 
13c0			.crstart: 
13c0				dw crs_s1 
13c0				dw crs_s2 
13c0				dw crs_s3 
13c0				dw crs_s4 
13c0				dw crs_s5 
13c0				dw crs_s6 
13c0				dw crs_sound 
13c0				dw crs_hw 
13c0				dw 0 
13c0			 
13c0			endif 
13c0			 
13c0			 
13c0			if STORAGE_SE 
13c0			 
13c0			config_fdir: 
13c0				; using the scratch dir go through and release the memory allocated for each string 
13c0				 
13c0				ld hl, scratch 
13c0			.cfdir:	ld e,(hl) 
13c0				inc hl 
13c0				ld d,(hl) 
13c0				inc hl 
13c0			 
13c0				ex de, hl 
13c0				call ishlzero 
13c0				ret z     ; return on null pointer 
13c0				call free 
13c0				ex de, hl 
13c0				jr .cfdir 
13c0			 
13c0			 
13c0				ret 
13c0			 
13c0			 
13c0			config_dir: 
13c0			 
13c0				; for the config menus that need to build a directory of storage call this routine 
13c0				; it will construct a menu in scratch to pass to menu 
13c0			 
13c0				; open storage device 
13c0			 
13c0				; execute DIR to build a list of files and their ids into scratch in menu format 
13c0				; once the menu has finished then will need to call config_fdir to release the strings 
13c0				 
13c0				; c = number items 
13c0			 
13c0				 
13c0				call storage_get_block_0 
13c0			 
13c0				ld hl, store_page     ; get current id count 
13c0				ld b, (hl) 
13c0				ld c, 0    ; count of files   
13c0			 
13c0			 
13c0				ld hl, scratch 
13c0				ld (store_tmp2), hl    ; location to poke strings 
13c0			 
13c0				; check for empty drive 
13c0			 
13c0				ld a, 0 
13c0				cp b 
13c0				jp z, .dirdone 
13c0			 
13c0				 
13c0					if DEBUG_FORTH_WORDS 
13c0						DMARK "Cdc" 
13c0						CALLMONITOR 
13c0					endif 
13c0			 
13c0			 
13c0			.diritem:	 
13c0				push bc 
13c0				; for each of the current ids do a search for them and if found push to stack 
13c0			 
13c0					ld hl, STORE_BLOCK_PHY 
13c0					ld d, 0		 ; look for extent 0 of block id as this contains file name 
13c0					ld e,b 
13c0			 
13c0					call storage_findnextid 
13c0			 
13c0			 
13c0					; if found hl will be non zero 
13c0			 
13c0					call ishlzero 
13c0					jr z, .dirnotfound 
13c0			 
13c0					; increase count 
13c0			 
13c0					pop bc	 
13c0					inc c 
13c0					push bc 
13c0					 
13c0			 
13c0					; get file header and push the file name 
13c0			 
13c0					ld de, store_page 
13c0					call storage_read_block 
13c0			 
13c0					; push file id to stack 
13c0				 
13c0					ld a, (store_page) 
13c0					ld h, 0 
13c0					ld l, a 
13c0			 
13c0					;call forth_push_numhl 
13c0					; TODO store id 
13c0			 
13c0					push hl 
13c0			 
13c0					; push extent count to stack  
13c0				 
13c0					ld hl, store_page+3 
13c0			 
13c0					; get file name length 
13c0			 
13c0					call strlenz   
13c0			 
13c0					inc hl   ; cover zero term 
13c0					inc hl  ; stick the id at the end of the area 
13c0			 
13c0					push hl 
13c0					pop bc    ; move length to bc 
13c0			 
13c0					call malloc 
13c0			 
13c0					; TODO save malloc area to scratch 
13c0			 
13c0					ex de, hl 
13c0					ld hl, (store_tmp2) 
13c0					ld (hl), e 
13c0					inc hl 
13c0					ld (hl), d 
13c0					inc hl 
13c0					ld (store_tmp2), hl 
13c0			 
13c0					 
13c0			 
13c0					;pop hl   ; get source 
13c0			;		ex de, hl    ; swap aronund	 
13c0			 
13c0					ld hl, store_page+3 
13c0					if DEBUG_FORTH_WORDS 
13c0						DMARK "CFd" 
13c0						CALLMONITOR 
13c0					endif 
13c0					ldir 
13c0			 
13c0					; de is past string, move back one and store id 
13c0					 
13c0					dec de 
13c0			 
13c0					; store file id 
13c0			 
13c0					pop hl 
13c0					ex de,hl 
13c0					ld (hl), e 
13c0			 
13c0					if DEBUG_FORTH_WORDS 
13c0						DMARK "Cdi" 
13c0						CALLMONITOR 
13c0					endif 
13c0					 
13c0			.dirnotfound: 
13c0					pop bc     
13c0					djnz .diritem 
13c0				 
13c0			.dirdone:	 
13c0			 
13c0					ld a, 0 
13c0					ld hl, (store_tmp2) 
13c0					ld (hl), a 
13c0					inc hl 
13c0					ld (hl), a 
13c0					inc hl 
13c0					; push a count of the dir items found 
13c0			 
13c0			;		ld h, 0 
13c0			;		ld l, c 
13c0			 
13c0				ret 
13c0			 
13c0			endif 
13c0			 
13c0			 
13c0			; Settings 
13c0			; Run  
13c0			 
13c0			 
13c0			 
13c0			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
13c0			;;hd_menu2:   db "        2: Editor",0   
13c0			;hd_menu2:   db "        2: Editor       6: Menu",0   
13c0			;hd_menu3:   db "        3: Storage",0 
13c0			;hd_menu4:   db "0=quit  4: Debug",0 
13c0			;hd_don:     db "ON",0 
13c0			;hd_doff:     db "OFF",0 
13c0			; 
13c0			; 
13c0			; 
13c0			;hardware_diags_old:       
13c0			; 
13c0			;.diagmenu: 
13c0			;	call clear_display 
13c0			;	ld a, display_row_1 
13c0			;	ld de, hd_menu1 
13c0			;	call str_at_display 
13c0			; 
13c0			;	ld a, display_row_2 
13c0			;	ld de, hd_menu2 
13c0			;	call str_at_display 
13c0			; 
13c0			;	ld a, display_row_3 
13c0			;	ld de, hd_menu3 
13c0			;	call str_at_display 
13c0			; 
13c0			;	ld a,  display_row_4 
13c0			;	ld de, hd_menu4 
13c0			;	call str_at_display 
13c0			; 
13c0			;	; display debug state 
13c0			; 
13c0			;	ld de, hd_don 
13c0			;	ld a, (os_view_disable) 
13c0			;	cp 0 
13c0			;	jr z, .distog 
13c0			;	ld de, hd_doff 
13c0			;.distog: ld a, display_row_4+17 
13c0			;	call str_at_display 
13c0			; 
13c0			;	call update_display 
13c0			; 
13c0			;	call cin_wait 
13c0			; 
13c0			; 
13c0			; 
13c0			;	cp '4' 
13c0			;	jr nz, .diagn1 
13c0			; 
13c0			;	; debug toggle 
13c0			; 
13c0			;	ld a, (os_view_disable) 
13c0			;	ld b, '*' 
13c0			;	cp 0 
13c0			;	jr z, .debtog 
13c0			;	ld b, 0 
13c0			;.debtog:	 
13c0			;	ld a,b 
13c0			;	ld (os_view_disable),a 
13c0			; 
13c0			;.diagn1: cp '0' 
13c0			;	 ret z 
13c0			; 
13c0			;;	cp '1' 
13c0			;;       jp z, matrix	 
13c0			;;   TODO keyboard matrix test 
13c0			; 
13c0			;	cp '2' 
13c0			;	jp z, .diagedit 
13c0			; 
13c0			;;	cp '6' 
13c0			;;	jp z, .menutest 
13c0			;;if ENABLE_BASIC 
13c0			;;	cp '6' 
13c0			;;	jp z, basic 
13c0			;;endif 
13c0			 ; 
13c0			;	jp .diagmenu 
13c0			; 
13c0			; 
13c0			;	ret 
13c0			 
13c0			 
13c0			.debug_tog: 
13c0 21 0a 14			ld hl, .menudebug 
13c3				 
13c3			;	ld a, (os_view_disable) 
13c3			;	cp '*' 
13c3 3a 6f ee			ld a,(debug_vector) 
13c6 fe c9			cp $C9   ; RET 
13c8 20 04			jr nz,.tdon  
13ca 3e 01			ld a, 1 
13cc 18 02			jr .tog1 
13ce 3e 00		.tdon: ld a, 0 
13d0			 
13d0			.tog1: 
13d0 cd f6 0b			call menu 
13d3 fe 00			cp 0 
13d5 c8				ret z 
13d6 fe 01			cp 1    ; disable debug 
13d8 28 04			jr z, .dtog0 
13da 3e 2a			ld a, '*' 
13dc 18 05			jr .dtogset 
13de			.dtog0:  
13de				;ld a, 0 
13de cd fc 14			call bp_on 
13e1 18 dd			jr .debug_tog 
13e3			.dtogset:  
13e3				; ld (os_view_disable), a 
13e3 cd 08 15			call bp_off 
13e6 c3 c0 13			jp .debug_tog 
13e9			 
13e9			 
13e9			hardware_diags:       
13e9			 
13e9			.diagm: 
13e9 21 fc 13			ld hl, .menuitems 
13ec 3e 00			ld a, 0 
13ee cd f6 0b			call menu 
13f1			 
13f1 fe 00		         cp 0 
13f3 c8				 ret z 
13f4			 
13f4 fe 02			cp 2 
13f6 ca 55 14			jp z, .diagedit 
13f9			 
13f9			;	cp '6' 
13f9			;	jp z, .menutest 
13f9			;if ENABLE_BASIC 
13f9			;	cp '6' 
13f9			;	jp z, basic 
13f9			;endif 
13f9			  
13f9 c3 e9 13			jp .diagm 
13fc			 
13fc				 
13fc 10 14		.menuitems:   	dw .m1 
13fe 1b 14				dw .m2 
1400 22 14				dw .m3 
1402 2a 14				dw .m5 
1404 30 14				dw .m5a 
1406 39 14				dw .m5b 
1408 00 00				dw 0 
140a			 
140a			.menudebug: 
140a 42 14				dw .m6 
140c 4b 14				dw .m7 
140e 00 00				dw 0 
1410			 
1410 .. 00		.m1:   db "Key Matrix",0 
141b .. 00		.m2:   db "Editor",0 
1422 .. 00		.m3:   db "Storage",0 
142a .. 00		.m5:   db "Sound",0 
1430 .. 00		.m5a:  db "RAM Test",0 
1439 .. 00		.m5b:  db "LCD Test",0 
1442			 
1442 .. 00		.m6:   db "Debug ON",0 
144b .. 00		.m7:   db "Debug OFF",0 
1455			 
1455			; debug editor 
1455			 
1455			.diagedit: 
1455			 
1455 21 c1 e2			ld hl, scratch 
1458			;	ld bc, 250 
1458			;	ldir 
1458				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1458 3e 00			ld a, 0 
145a 77				ld (hl), a 
145b 23				inc hl 
145c 77				ld (hl), a 
145d 23				inc hl 
145e 77				ld (hl), a 
145f			 
145f cd c5 0b		        call clear_display 
1462 cd e8 0b			call update_display 
1465				;ld a, 1 
1465				;ld (hardware_diag), a 
1465			.diloop: 
1465 3e 00			ld a, display_row_1 
1467 0e 00			ld c, 0 
1469 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
146b 1e 28			ld e, 40 
146d			 
146d 21 c1 e2			ld hl, scratch	 
1470 cd 1f 0e			call input_str 
1473			 
1473 3e 28			ld a, display_row_2 
1475 11 c1 e2			ld de, scratch 
1478 cd d8 0b			call str_at_display 
147b cd e8 0b			call update_display 
147e			 
147e c3 65 14			jp .diloop 
1481			 
1481			 
1481			; pass word in hl 
1481			; a has display location 
1481			display_word_at: 
1481 f5				push af 
1482 e5				push hl 
1483 7c				ld a,h 
1484 21 c6 e5			ld hl, os_word_scratch 
1487 cd fb 0f			call hexout 
148a e1				pop hl 
148b 7d				ld a,l 
148c 21 c8 e5			ld hl, os_word_scratch+2 
148f cd fb 0f			call hexout 
1492 21 ca e5			ld hl, os_word_scratch+4 
1495 3e 00			ld a,0 
1497 77				ld (hl),a 
1498 11 c6 e5			ld de,os_word_scratch 
149b f1				pop af 
149c cd d8 0b				call str_at_display 
149f c9				ret 
14a0			 
14a0			display_ptr_state: 
14a0			 
14a0				; to restore afterwards 
14a0			 
14a0 d5				push de 
14a1 c5				push bc 
14a2 e5				push hl 
14a3 f5				push af 
14a4			 
14a4				; for use in here 
14a4			 
14a4			;	push bc 
14a4			;	push de 
14a4			;	push hl 
14a4			;	push af 
14a4			 
14a4 cd c5 0b			call clear_display 
14a7			 
14a7 11 7f 16			ld de, .ptrstate 
14aa 3e 00			ld a, display_row_1 
14ac cd d8 0b			call str_at_display 
14af			 
14af				; display debug step 
14af			 
14af			 
14af 11 6b ee			ld de, debug_mark 
14b2 3e 26			ld a, display_row_1+display_cols-2 
14b4 cd d8 0b			call str_at_display 
14b7			 
14b7				; display a 
14b7 11 89 16			ld de, .ptrcliptr 
14ba 3e 28			ld a, display_row_2 
14bc cd d8 0b			call str_at_display 
14bf			 
14bf f1				pop af 
14c0 2a 40 ea			ld hl,(cli_ptr) 
14c3 3e 30			ld a, display_row_2+8 
14c5 cd 81 14			call display_word_at 
14c8			 
14c8			 
14c8				; display hl 
14c8			 
14c8			 
14c8 11 91 16			ld de, .ptrclioptr 
14cb 3e 32			ld a, display_row_2+10 
14cd cd d8 0b			call str_at_display 
14d0			; 
14d0			;	pop hl 
14d0 3e 35			ld a, display_row_2+13 
14d2 2a 3e ea			ld hl,(cli_origptr) 
14d5 cd 81 14			call display_word_at 
14d8			; 
14d8			;	 
14d8			;	; display de 
14d8			 
14d8			;	ld de, .regstatede 
14d8			;	ld a, display_row_3 
14d8			;	call str_at_display 
14d8			 
14d8			;	pop de 
14d8			;	ld h,d 
14d8			;	ld l, e 
14d8			;	ld a, display_row_3+3 
14d8			;	call display_word_at 
14d8			 
14d8			 
14d8				; display bc 
14d8			 
14d8			;	ld de, .regstatebc 
14d8			;	ld a, display_row_3+10 
14d8			;	call str_at_display 
14d8			 
14d8			;	pop bc 
14d8			;	ld h,b 
14d8			;	ld l, c 
14d8			;	ld a, display_row_3+13 
14d8			;	call display_word_at 
14d8			 
14d8			 
14d8				; display dsp 
14d8			 
14d8			;	ld de, .regstatedsp 
14d8			;	ld a, display_row_4 
14d8			;	call str_at_display 
14d8			 
14d8				 
14d8			;	ld hl,(cli_data_sp) 
14d8			;	ld a, display_row_4+4 
14d8			;	call display_word_at 
14d8			 
14d8				; display rsp 
14d8			 
14d8 11 c0 16			ld de, .regstatersp 
14db 3e 82			ld a, display_row_4+10 
14dd cd d8 0b			call str_at_display 
14e0			 
14e0				 
14e0 2a f2 e9			ld hl,(cli_ret_sp) 
14e3 3e 86			ld a, display_row_4+14 
14e5 cd 81 14			call display_word_at 
14e8			 
14e8 cd e8 0b			call update_display 
14eb			 
14eb cd fd 0a			call delay1s 
14ee cd fd 0a			call delay1s 
14f1 cd fd 0a			call delay1s 
14f4			 
14f4			 
14f4 cd f1 1a			call next_page_prompt 
14f7			 
14f7				; restore  
14f7			 
14f7 f1				pop af 
14f8 e1				pop hl 
14f9 c1				pop bc 
14fa d1				pop de 
14fb c9				ret 
14fc			 
14fc			; Update the break point vector so that the user can hook a new routine 
14fc			 
14fc			bp_on: 
14fc 3e c3			ld a, $c3    ; JP 
14fe 32 6f ee			ld (debug_vector), a 
1501 21 0e 15			ld hl, break_point_state 
1504 22 70 ee			ld (debug_vector+1), hl 
1507 c9				ret 
1508			 
1508			bp_off: 
1508 3e c9			ld a, $c9    ; RET 
150a 32 6f ee			ld (debug_vector), a 
150d c9				ret 
150e			 
150e			 
150e			break_point_state: 
150e			;	push af 
150e			; 
150e			;	; see if disabled 
150e			; 
150e			;	ld a, (os_view_disable) 
150e			;	cp '*' 
150e			;	jr nz, .bpsgo 
150e			;	pop af 
150e			;	ret 
150e			 
150e			.bpsgo: 
150e			;	pop af 
150e f5				push af 
150f 22 a3 e2			ld (os_view_hl), hl 
1512 ed 53 a1 e2		ld (os_view_de), de 
1516 ed 43 9f e2		ld (os_view_bc), bc 
151a e5				push hl 
151b 6f				ld l, a 
151c 26 00			ld h, 0 
151e 22 a5 e2			ld (os_view_af),hl 
1521			 
1521 21 b1 ed				ld hl, display_fb0 
1524 22 cc eb				ld (display_fb_active), hl 
1527 e1				pop hl	 
1528			 
1528 3e 31			ld a, '1' 
152a fe 2a		.bps1:  cp '*' 
152c cc 08 15			call z, bp_off 
152f			;	jr nz, .bps1b 
152f			;	ld (os_view_disable),a 
152f fe 31		.bps1b:  cp '1' 
1531 20 14			jr nz, .bps2 
1533			 
1533				; display reg 
1533			 
1533				 
1533			 
1533 3a a5 e2			ld a, (os_view_af) 
1536 2a a3 e2			ld hl, (os_view_hl) 
1539 ed 5b a1 e2		ld de, (os_view_de) 
153d ed 4b 9f e2		ld bc, (os_view_bc) 
1541 cd db 15			call display_reg_state 
1544 c3 c7 15			jp .bpschk 
1547			 
1547 fe 32		.bps2:  cp '2' 
1549 20 08			jr nz, .bps3 
154b				 
154b				; display hl 
154b 2a a3 e2			ld hl, (os_view_hl) 
154e cd c5 16			call display_dump_at_hl 
1551			 
1551 18 74			jr .bpschk 
1553			 
1553 fe 33		.bps3:  cp '3' 
1555 20 08			jr nz, .bps4 
1557			 
1557			        ; display de 
1557 2a a1 e2			ld hl, (os_view_de) 
155a cd c5 16			call display_dump_at_hl 
155d			 
155d 18 68			jr .bpschk 
155f fe 34		.bps4:  cp '4' 
1561 20 08			jr nz, .bps5 
1563			 
1563			        ; display bc 
1563 2a 9f e2			ld hl, (os_view_bc) 
1566 cd c5 16			call display_dump_at_hl 
1569			 
1569 18 5c			jr .bpschk 
156b fe 35		.bps5:  cp '5' 
156d 20 08		        jr nz, .bps7 
156f			 
156f				; display cur ptr 
156f 2a 40 ea			ld hl, (cli_ptr) 
1572 cd c5 16			call display_dump_at_hl 
1575			 
1575 18 50			jr .bpschk 
1577 fe 36		.bps7:  cp '6' 
1579 20 08			jr nz, .bps8b 
157b				 
157b				; display cur orig ptr 
157b 2a 3e ea			ld hl, (cli_origptr) 
157e cd c5 16			call display_dump_at_hl 
1581 18 44			jr .bpschk 
1583 fe 37		.bps8b:  cp '7' 
1585 20 08			jr nz, .bps9 
1587				 
1587				; display dsp 
1587 2a ee e9			ld hl, (cli_data_sp) 
158a cd c5 16			call display_dump_at_hl 
158d			 
158d 18 38			jr .bpschk 
158f fe 39		.bps9:  cp '9' 
1591 20 05			jr nz, .bps8c 
1593				 
1593				; display SP 
1593			;	ld hl, sp 
1593 cd c5 16			call display_dump_at_hl 
1596			 
1596 18 2f			jr .bpschk 
1598 fe 38		.bps8c:  cp '8' 
159a 20 08			jr nz, .bps8d 
159c				 
159c				; display rsp 
159c 2a f2 e9			ld hl, (cli_ret_sp) 
159f cd c5 16			call display_dump_at_hl 
15a2			 
15a2 18 23			jr .bpschk 
15a4 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
15a6 20 05			jr nz, .bps8 
15a8 cd bf 18			call monitor 
15ab			 
15ab 18 1a			jr .bpschk 
15ad fe 30		.bps8:  cp '0' 
15af 20 16			jr nz, .bpschk 
15b1			 
15b1 21 10 ed				ld hl, display_fb1 
15b4 22 cc eb				ld (display_fb_active), hl 
15b7 cd e8 0b				call update_display 
15ba			 
15ba				;ld a, (os_view_af) 
15ba 2a a3 e2			ld hl, (os_view_hl) 
15bd ed 5b a1 e2		ld de, (os_view_de) 
15c1 ed 4b 9f e2		ld bc, (os_view_bc) 
15c5 f1				pop af 
15c6 c9				ret 
15c7			 
15c7			.bpschk:   
15c7 cd fd 0a			call delay1s 
15ca 3e 9f		ld a,display_row_4 + display_cols - 1 
15cc 11 ef 1a		        ld de, endprg 
15cf cd d8 0b			call str_at_display 
15d2 cd e8 0b			call update_display 
15d5 cd 74 5e			call cin_wait 
15d8			 
15d8 c3 2a 15			jp .bps1 
15db			 
15db			 
15db			display_reg_state: 
15db			 
15db				; to restore afterwards 
15db			 
15db d5				push de 
15dc c5				push bc 
15dd e5				push hl 
15de f5				push af 
15df			 
15df				; for use in here 
15df			 
15df c5				push bc 
15e0 d5				push de 
15e1 e5				push hl 
15e2 f5				push af 
15e3			 
15e3 cd c5 0b			call clear_display 
15e6			 
15e6 11 9b 16			ld de, .regstate 
15e9 3e 00			ld a, display_row_1 
15eb cd d8 0b			call str_at_display 
15ee			 
15ee				; display debug step 
15ee			 
15ee			 
15ee 11 6b ee			ld de, debug_mark 
15f1 3e 25			ld a, display_row_1+display_cols-3 
15f3 cd d8 0b			call str_at_display 
15f6			 
15f6				; display a 
15f6 11 b7 16			ld de, .regstatea 
15f9 3e 28			ld a, display_row_2 
15fb cd d8 0b			call str_at_display 
15fe			 
15fe e1				pop hl 
15ff			;	ld h,0 
15ff			;	ld l, a 
15ff 3e 2b			ld a, display_row_2+3 
1601 cd 81 14			call display_word_at 
1604			 
1604			 
1604				; display hl 
1604			 
1604			 
1604 11 ab 16			ld de, .regstatehl 
1607 3e 32			ld a, display_row_2+10 
1609 cd d8 0b			call str_at_display 
160c			 
160c e1				pop hl 
160d 3e 35			ld a, display_row_2+13 
160f cd 81 14			call display_word_at 
1612			 
1612				 
1612				; display de 
1612			 
1612 11 af 16			ld de, .regstatede 
1615 3e 50			ld a, display_row_3 
1617 cd d8 0b			call str_at_display 
161a			 
161a e1				pop hl 
161b			;	ld h,d 
161b			;	ld l, e 
161b 3e 53			ld a, display_row_3+3 
161d cd 81 14			call display_word_at 
1620			 
1620			 
1620				; display bc 
1620			 
1620 11 b3 16			ld de, .regstatebc 
1623 3e 5a			ld a, display_row_3+10 
1625 cd d8 0b			call str_at_display 
1628			 
1628 e1				pop hl 
1629			;	ld h,b 
1629			;	ld l, c 
1629 3e 5d			ld a, display_row_3+13 
162b cd 81 14			call display_word_at 
162e			 
162e			 
162e				; display dsp 
162e			 
162e 11 bb 16			ld de, .regstatedsp 
1631 3e 78			ld a, display_row_4 
1633 cd d8 0b			call str_at_display 
1636			 
1636				 
1636 2a ee e9			ld hl,(cli_data_sp) 
1639 3e 7c			ld a, display_row_4+4 
163b cd 81 14			call display_word_at 
163e			 
163e				; display rsp 
163e			 
163e 11 c0 16			ld de, .regstatersp 
1641 3e 82			ld a, display_row_4+10 
1643 cd d8 0b			call str_at_display 
1646			 
1646				 
1646 2a f2 e9			ld hl,(cli_ret_sp) 
1649 3e 86			ld a, display_row_4+14 
164b cd 81 14			call display_word_at 
164e			 
164e cd e8 0b			call update_display 
1651			 
1651			;	call delay1s 
1651			;	call delay1s 
1651			;	call delay1s 
1651			 
1651			 
1651			;	call next_page_prompt 
1651			 
1651				; restore  
1651			 
1651 f1				pop af 
1652 e1				pop hl 
1653 c1				pop bc 
1654 d1				pop de 
1655 c9				ret 
1656			 
1656 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
166a .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
167f .. 00		.ptrstate:	db "Ptr State",0 
1689 .. 00		.ptrcliptr:     db "cli_ptr",0 
1691 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
169b .. 00		.regstate:	db "Reg State (1/0)",0 
16ab .. 00		.regstatehl:	db "HL:",0 
16af .. 00		.regstatede:	db "DE:",0 
16b3 .. 00		.regstatebc:	db "BC:",0 
16b7 .. 00		.regstatea:	db "A :",0 
16bb .. 00		.regstatedsp:	db "DSP:",0 
16c0 .. 00		.regstatersp:	db "RSP:",0 
16c5			 
16c5			display_dump_at_hl: 
16c5 e5				push hl 
16c6 d5				push de 
16c7 c5				push bc 
16c8 f5				push af 
16c9			 
16c9 22 e4 e5			ld (os_cur_ptr),hl	 
16cc cd c5 0b			call clear_display 
16cf cd f9 19			call dumpcont 
16d2			;	call delay1s 
16d2			;	call next_page_prompt 
16d2			 
16d2			 
16d2 f1				pop af 
16d3 c1				pop bc 
16d4 d1				pop de 
16d5 e1				pop hl 
16d6 c9				ret 
16d7			 
16d7			;if ENABLE_BASIC 
16d7			;	include "nascombasic.asm" 
16d7			;	basic: 
16d7			;	include "forth/FORTH.ASM" 
16d7			;endif 
16d7			 
16d7			; eof 
16d7			 
16d7			 
# End of file firmware_diags.asm
16d7			  
16d7			include "firmware_prompts.asm"  
16d7			; Prompts  
16d7			 
16d7			; boot messages 
16d7			 
16d7 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
16ec .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
16fc			 
16fc			 
16fc			; config menus 
16fc			 
16fc			;prom_c3: db "Add Dictionary To File",0 
16fc			 
16fc			if STARTUP_V1 
16fc .. 00		prom_c2: db "Select Autoload File",0 
1711 .. 00		prom_c2a: db "Disable Autoload File", 0 
1727			endif 
1727			 
1727			if STARTUP_V2 
1727			prom_c2: db "Enable Autoload Files",0 
1727			prom_c2a: db "Disable Autoload Files", 0 
1727			 
1727			crs_s1: db "*ls-word", 0 
1727			crs_s2: db "*ed-word", 0 
1727			crs_s3: db "*Demo-Games", 0 
1727			crs_s4: db "*Utils", 0 
1727			crs_s5: db "*SPI-Util", 0 
1727			crs_s6: db "*Key-Constants", 0 
1727			crs_sound: db "*Sound-Util", 0 
1727			crs_hw: db "*Hello-World",0 
1727			 
1727			 
1727			 
1727			endif 
1727			;prom_c2b: db "Select Storage Bank",0 
1727 .. 00		prom_c4: db "Settings",0 
1730 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
174b .. 00		prom_m4b:   db "Monitor",0 
1753 .. 00		prom_c1: db "Hardware Diags",0 
1762			 
1762			 
1762			if STARTUP_V2 
1762			prom_c9: db "Create Startup Files",0 
1762			endif 
1762			 
1762 .. 00		prom_notav:    db "Feature not available",0 
1778 .. 00		prom_empty:    db "",0 
1779			 
1779			; eof 
1779			 
# End of file firmware_prompts.asm
1779			  
1779			  
1779			; eof  
1779			  
# End of file firmware.asm
1779			 
1779			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1779			;if BASE_KEV  
1779			;baseram: equ 08000h 
1779			;endif 
1779			 
1779			;if BASE_SC114 
1779			;baseram:     equ    endofcode 
1779			;endif 
1779			 
1779			 
1779			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1779			 
1779			; start system 
1779			 
1779			coldstart: 
1779				; set sp 
1779				; di/ei 
1779			 
1779 f3				di 
177a 31 00 f0			ld sp, tos 
177d cd 72 5d			call init_nmi 
1780			;	ei 
1780			 
1780				; init spinner 
1780 3e 00			ld a,0 
1782 32 c6 eb			ld (display_active), a 
1785			 
1785				; disable breakpoint by default 
1785			 
1785				;ld a,'*' 
1785			;	ld a,' ' 
1785			;	ld (os_view_disable),a 
1785			 
1785				; set break point vector as new break point on or off 
1785 cd 08 15			call bp_off 
1788			 
1788				; init hardware 
1788			 
1788				; init keyboard and screen hardware 
1788			 
1788 cd 1f 01			call hardware_init 
178b			 
178b			 
178b cd fd 0a			call delay1s 
178e 3e 58			ld a, display_row_3+8 
1790 11 03 01			ld de, buildtime 
1793 cd d8 0b			call str_at_display 
1796 cd e8 0b			call update_display 
1799			 
1799 cd fd 0a			call delay1s 
179c cd fd 0a			call delay1s 
179f cd fd 0a			call delay1s 
17a2			 
17a2				; detect if any keys are held down to enable breakpoints at start up 
17a2			 
17a2 cd 7c 5e			call cin  
17a5 fe 00			cp 0 
17a7 28 03			jr z, .nokeys 
17a9			 
17a9				;call hardware_diags 
17a9 cd 66 13			call config 
17ac			 
17ac			;	ld de, .bpen 
17ac			;	ld a, display_row_4 
17ac			;	call str_at_display 
17ac			;	call update_display 
17ac			; 
17ac			;	ld a,0 
17ac			;	ld (os_view_disable),a 
17ac			; 
17ac			;.bpwait: 
17ac			;	call cin 
17ac			;	cp 0 
17ac			;	jr z, .bpwait 
17ac			;	jr .nokeys 
17ac			; 
17ac			; 
17ac			;.bpen:  db "Break points enabled!",0 
17ac			 
17ac			 
17ac			 
17ac			 
17ac			 
17ac			 
17ac			.nokeys: 
17ac			 
17ac			 
17ac				 
17ac			 
17ac			;jp  testkey 
17ac			 
17ac			;call storage_get_block_0 
17ac			; 
17ac			;ld hl, 0 
17ac			;ld de, store_page 
17ac			;call storage_read_block 
17ac			 
17ac				 
17ac			;ld hl, 10 
17ac			;ld de, store_page 
17ac			;call storage_read_block 
17ac			 
17ac			 
17ac			 
17ac			 
17ac			 
17ac			;stop:	nop 
17ac			;	jp stop 
17ac			 
17ac			 
17ac			 
17ac			main: 
17ac cd c5 0b			call clear_display 
17af cd e8 0b			call update_display 
17b2			 
17b2			 
17b2			 
17b2			;	call testlcd 
17b2			 
17b2			 
17b2			 
17b2 cd 04 1f			call forth_init 
17b5			 
17b5			 
17b5			warmstart: 
17b5 cd da 1e			call forth_warmstart 
17b8			 
17b8				; run startup word load 
17b8			        ; TODO prevent this running at warmstart after crash  
17b8			 
17b8				if STARTUP_ENABLE 
17b8			 
17b8					if STARTUP_V1 
17b8			 
17b8						if STORAGE_SE 
17b8							call forth_autoload 
17b8						endif 
17b8 cd c2 5c					call forth_startup 
17bb					endif 
17bb			 
17bb					if STARTUP_V2 
17bb			 
17bb						if STORAGE_SE 
17bb							call forth_autoload 
17bb						else 
17bb							call forth_startup 
17bb						endif 
17bb			 
17bb			 
17bb					endif 
17bb			 
17bb				endif 
17bb			 
17bb			warmstart_afterauto: 
17bb			 
17bb				; show free memory after boot 
17bb 11 5a 18			ld de, freeram 
17be 3e 00			ld a, display_row_1 
17c0 cd d8 0b			call str_at_display 
17c3			 
17c3				; get current heap start after loading any uwords 
17c3			 
17c3				;ld de, (os_last_new_uword) 
17c3				;ex de, hl 
17c3			 
17c3			; Or use heap_size word???? 
17c3				;ld hl, heap_end 
17c3				;ld hl, heap_size 
17c3				;ld de, topusermem 
17c3				;ld de, heap_start 
17c3 ed 5b 9f 5e			ld de, (free_list )      
17c7 21 9c e2				ld hl, heap_end 
17ca ed 52			sbc hl, de 
17cc				;push hl 
17cc				;ld a,h	         	 
17cc				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
17cc				;call hexout 
17cc			   	;pop hl 
17cc			; 
17cc			;	ld a,l 
17cc			;	ld hl, os_word_scratch+2 
17cc			;	call hexout 
17cc			;	ld hl, os_word_scratch+4 
17cc			;	ld a, 0 
17cc			;	ld (hl),a 
17cc eb				ex de, hl 
17cd 21 c6 e5			ld hl, os_word_scratch 
17d0 cd 07 11			call uitoa_16 
17d3			 
17d3			 
17d3 11 c6 e5			ld de, os_word_scratch 
17d6 3e 0d			ld a, display_row_1 + 13 
17d8 cd d8 0b			call str_at_display 
17db cd e8 0b			call update_display 
17de			 
17de			 
17de				;call demo 
17de			 
17de			 
17de				; init scratch input area for cli commands 
17de			 
17de 21 e8 e5			ld hl, os_cli_cmd 
17e1 3e 00			ld a,0 
17e3 77				ld (hl),a 
17e4 23				inc hl 
17e5 77				ld (hl),a 
17e6			 
17e6 3e 00			ld a,0 
17e8 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
17eb			 
17eb 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
17ee 32 e5 e5			ld (os_cur_ptr+1),a	 
17f1			 
17f1 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
17f4 32 c7 e5			ld (os_word_scratch+1),a	 
17f7				 
17f7			 
17f7				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17f7 21 e8 e5			ld hl, os_cli_cmd 
17fa			 
17fa 3e 00			ld a, 0		 ; init cli input 
17fc 77				ld (hl), a 
17fd 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17ff			cli: 
17ff				; show cli prompt 
17ff				;push af 
17ff				;ld a, 0 
17ff				;ld de, prompt 
17ff				;call str_at_display 
17ff			 
17ff				;call update_display 
17ff				;pop af 
17ff				;inc a 
17ff				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
17ff			 
17ff			.lastrecall: 
17ff			 
17ff 0e 00			ld c, 0 
1801 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1803 1e 28			ld e, 40 
1805			 
1805 21 e8 e5			ld hl, os_cli_cmd 
1808			 
1808				STACKFRAME OFF $fefe $9f9f 
1808				if DEBUG_STACK_IMB 
1808					if OFF 
1808						exx 
1808						ld de, $fefe 
1808						ld a, d 
1808						ld hl, curframe 
1808						call hexout 
1808						ld a, e 
1808						ld hl, curframe+2 
1808						call hexout 
1808						ld hl, $fefe 
1808						push hl 
1808						ld hl, $9f9f 
1808						push hl 
1808						exx 
1808					endif 
1808				endif 
1808			endm 
# End of macro STACKFRAME
1808			 
1808 cd 1f 0e			call input_str 
180b			 
180b				STACKFRAMECHK OFF $fefe $9f9f 
180b				if DEBUG_STACK_IMB 
180b					if OFF 
180b						exx 
180b						ld hl, $9f9f 
180b						pop de   ; $9f9f 
180b						call cmp16 
180b						jr nz, .spnosame 
180b						ld hl, $fefe 
180b						pop de   ; $fefe 
180b						call cmp16 
180b						jr z, .spfrsame 
180b						.spnosame: call showsperror 
180b						.spfrsame: nop 
180b						exx 
180b					endif 
180b				endif 
180b			endm 
# End of macro STACKFRAMECHK
180b			 
180b			 
180b				; check to see if last line recall has been requested 
180b			 
180b			if EDIT_V2 
180b fe 05			cp KEY_UP 
180d 20 0f			jr nz, .noexecline 
180f			 
180f 11 e8 e5			ld de, os_cli_cmd 
1812 21 e7 e6			ld hl, os_last_cmd 
1815 01 ff 00			ld bc, 255 
1818 ed b0			ldir 
181a 3e 00			ld a, 0 
181c 18 e1			jr .lastrecall 
181e			endif 
181e			 
181e			.noexecline: 
181e				; no so exec the line		 
181e			 
181e				; copy input to last command 
181e			 
181e 21 e8 e5			ld hl, os_cli_cmd 
1821 11 e7 e6			ld de, os_last_cmd 
1824 01 ff 00			ld bc, 255 
1827 ed b0			ldir 
1829			 
1829				; wipe current buffer 
1829			 
1829			;	ld a, 0 
1829			;	ld hl, os_cli_cmd 
1829			;	ld de, os_cli_cmd+1 
1829			;	ld bc, 254 
1829			;	ldir 
1829				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1829			;	call strcpy 
1829			;	ld a, 0 
1829			;	ld (hl), a 
1829			;	inc hl 
1829			;	ld (hl), a 
1829			;	inc hl 
1829			;	ld (hl), a 
1829			 
1829				; switch frame buffer to program  
1829			 
1829 21 10 ed				ld hl, display_fb1 
182c 22 cc eb				ld (display_fb_active), hl 
182f			 
182f			;	nop 
182f				STACKFRAME ON $fbfe $8f9f 
182f				if DEBUG_STACK_IMB 
182f					if ON 
182f						exx 
182f						ld de, $fbfe 
182f						ld a, d 
182f						ld hl, curframe 
182f						call hexout 
182f						ld a, e 
182f						ld hl, curframe+2 
182f						call hexout 
182f						ld hl, $fbfe 
182f						push hl 
182f						ld hl, $8f9f 
182f						push hl 
182f						exx 
182f					endif 
182f				endif 
182f			endm 
# End of macro STACKFRAME
182f				; first time into the parser so pass over the current scratch pad 
182f 21 e8 e5			ld hl,os_cli_cmd 
1832				; tokenise the entered statement(s) in HL 
1832 cd 82 1f			call forthparse 
1835			        ; exec forth statements in top of return stack 
1835 cd c2 1f			call forthexec 
1838				;call forthexec_cleanup 
1838			;	call parsenext 
1838			 
1838				STACKFRAMECHK ON $fbfe $8f9f 
1838				if DEBUG_STACK_IMB 
1838					if ON 
1838						exx 
1838						ld hl, $8f9f 
1838						pop de   ; $8f9f 
1838						call cmp16 
1838						jr nz, .spnosame 
1838						ld hl, $fbfe 
1838						pop de   ; $fbfe 
1838						call cmp16 
1838						jr z, .spfrsame 
1838						.spnosame: call showsperror 
1838						.spfrsame: nop 
1838						exx 
1838					endif 
1838				endif 
1838			endm 
# End of macro STACKFRAMECHK
1838				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1838			 
1838 3e 78			ld a, display_row_4 
183a 11 6b 18			ld de, endprog 
183d			 
183d cd e8 0b			call update_display		 
1840			 
1840 cd f1 1a			call next_page_prompt 
1843			 
1843				; switch frame buffer to cli 
1843			 
1843 21 b1 ed				ld hl, display_fb0 
1846 22 cc eb				ld (display_fb_active), hl 
1849			 
1849			 
1849 cd c5 0b		        call clear_display 
184c cd e8 0b			call update_display		 
184f			 
184f 21 e8 e5			ld hl, os_cli_cmd 
1852			 
1852 3e 00			ld a, 0		 ; init cli input 
1854 77				ld (hl), a 
1855			 
1855				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1855			 
1855				; now on last line 
1855			 
1855				; TODO scroll screen up 
1855			 
1855				; TODO instead just clear screen and place at top of screen 
1855			 
1855			;	ld a, 0 
1855			;	ld (f_cursor_ptr),a 
1855			 
1855				;call clear_display 
1855				;call update_display 
1855			 
1855				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1855 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1857 c3 ff 17			jp cli 
185a			 
185a .. 00		freeram: db "Free bytes: ",0 
1867 ..			asc: db "1A2F" 
186b .. 00		endprog: db "End prog...",0 
1877			 
1877			testenter2:   
1877 21 f3 e2			ld hl,scratch+50 
187a 22 e4 e5			ld (os_cur_ptr),hl 
187d c3 ff 17			jp cli 
1880			 
1880			testenter:  
1880			 
1880 21 67 18			ld hl,asc 
1883			;	ld a,(hl) 
1883			;	call nibble2val 
1883 cd 51 10			call get_byte 
1886			 
1886			 
1886			;	ld a,(hl) 
1886			;	call atohex 
1886			 
1886			;	call fourehexhl 
1886 32 f3 e2			ld (scratch+50),a 
1889			 
1889			 
1889			 
1889 21 69 18			ld hl,asc+2 
188c			;	ld a, (hl) 
188c			;	call nibble2val 
188c cd 51 10			call get_byte 
188f			 
188f			;	call fourehexhl 
188f 32 f5 e2			ld (scratch+52),a 
1892				 
1892 21 f3 e2			ld hl,scratch+50 
1895 22 e4 e5			ld (os_cur_ptr),hl 
1898 c3 ff 17			jp cli 
189b			 
189b			enter:	 
189b 3a c5 e2			ld a,(scratch+4) 
189e fe 00			cp 0 
18a0 28 0c			jr z, .entercont 
18a2				; no, not a null term line so has an address to work out.... 
18a2			 
18a2 21 c3 e2			ld hl,scratch+2 
18a5 cd b1 10			call get_word_hl 
18a8			 
18a8 22 e4 e5			ld (os_cur_ptr),hl	 
18ab c3 ff 17			jp cli 
18ae			 
18ae			 
18ae			.entercont:  
18ae			 
18ae 21 c3 e2			ld hl, scratch+2 
18b1 cd 51 10			call get_byte 
18b4			 
18b4 2a e4 e5		   	ld hl,(os_cur_ptr) 
18b7 77					ld (hl),a 
18b8 23					inc hl 
18b9 22 e4 e5				ld (os_cur_ptr),hl 
18bc				 
18bc			; get byte  
18bc			 
18bc			 
18bc c3 ff 17			jp cli 
18bf			 
18bf			 
18bf			; basic monitor support 
18bf			 
18bf			monitor: 
18bf				;  
18bf cd c5 0b			call clear_display 
18c2 3e 00			ld a, 0 
18c4 11 13 19			ld de, .monprompt 
18c7 cd d8 0b			call str_at_display 
18ca cd e8 0b			call update_display 
18cd			 
18cd				; get a monitor command 
18cd			 
18cd 0e 00			ld c, 0     ; entry at top left 
18cf 16 64			ld d, 100   ; max buffer size 
18d1 1e 0f			ld e, 15    ; input scroll area 
18d3 3e 00			ld a, 0     ; init string 
18d5 21 bf e4			ld hl, os_input 
18d8 77				ld (hl), a 
18d9 23				inc hl 
18da 77				ld (hl), a 
18db 21 bf e4			ld hl, os_input 
18de 3e 01			ld a, 1     ; init string 
18e0 cd 1f 0e			call input_str 
18e3			 
18e3 cd c5 0b		        call clear_display 
18e6 cd e8 0b			call update_display		 
18e9			 
18e9 3a bf e4			ld a, (os_input) 
18ec cd 4f 11			call toUpper 
18ef fe 48		        cp 'H' 
18f1 ca 78 19		        jp z, .monhelp 
18f4 fe 44			cp 'D'		; dump 
18f6 ca ab 19			jp z, .mondump	 
18f9 fe 43			cp 'C'		; dump 
18fb ca c5 19			jp z, .moncdump	 
18fe fe 4d			cp 'M'		; dump 
1900 ca 15 19			jp z, .moneditstart 
1903 fe 55			cp 'U'		; dump 
1905 ca 21 19			jp z, .monedit	 
1908 fe 47			cp 'G'		; dump 
190a ca a1 19			jp z, .monjump 
190d fe 51			cp 'Q'		; dump 
190f c8				ret z	 
1910			 
1910			 
1910				; TODO "S" to access symbol by name and not need the address 
1910				; TODO "F" to find a string in memory 
1910			 
1910 c3 bf 18			jp monitor 
1913			 
1913 .. 00		.monprompt: db ">", 0 
1915			 
1915			.moneditstart: 
1915				; get starting address 
1915			 
1915 21 c1 e4			ld hl,os_input+2 
1918 cd b1 10			call get_word_hl 
191b			 
191b 22 e4 e5			ld (os_cur_ptr),hl	 
191e			 
191e c3 bf 18			jp monitor 
1921			 
1921			.monedit: 
1921				; get byte to load 
1921			 
1921 21 c1 e4			ld hl,os_input+2 
1924 cd 51 10			call get_byte 
1927			 
1927				; get address to update 
1927 2a e4 e5			ld hl, (os_cur_ptr) 
192a			 
192a				; update byte 
192a			 
192a 77				ld (hl), a 
192b			 
192b				; move to next address and save it 
192b			 
192b 23				inc hl 
192c 22 e4 e5			ld (os_cur_ptr),hl	 
192f			 
192f c3 bf 18			jp monitor 
1932			 
1932			 
1932 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1946 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1962 .. 00		.monhelptext3:  db "G-Call address",0 
1971 .. 00		.monhelptext4:  db "Q-Quit",0 
1978			        
1978			.monhelp: 
1978 3e 00			ld a, display_row_1 
197a 11 32 19		        ld de, .monhelptext1 
197d			 
197d cd d8 0b			call str_at_display 
1980 3e 28			ld a, display_row_2 
1982 11 46 19		        ld de, .monhelptext2 
1985					 
1985 cd d8 0b			call str_at_display 
1988 3e 50			ld a, display_row_3 
198a 11 62 19		        ld de, .monhelptext3 
198d					 
198d cd d8 0b			call str_at_display 
1990 3e 78			ld a, display_row_4 
1992 11 71 19		        ld de, .monhelptext4 
1995 cd d8 0b			call str_at_display 
1998			 
1998 cd e8 0b			call update_display		 
199b			 
199b cd f1 1a			call next_page_prompt 
199e c3 bf 18			jp monitor 
19a1			 
19a1			.monjump:    
19a1 21 c1 e4			ld hl,os_input+2 
19a4 cd b1 10			call get_word_hl 
19a7			 
19a7 e9				jp (hl) 
19a8 c3 bf 18			jp monitor 
19ab			 
19ab			.mondump:    
19ab 21 c1 e4			ld hl,os_input+2 
19ae cd b1 10			call get_word_hl 
19b1			 
19b1 22 e4 e5			ld (os_cur_ptr),hl	 
19b4 cd f9 19			call dumpcont 
19b7 3e 78			ld a, display_row_4 
19b9 11 6b 18			ld de, endprog 
19bc			 
19bc cd e8 0b			call update_display		 
19bf			 
19bf cd f1 1a			call next_page_prompt 
19c2 c3 bf 18			jp monitor 
19c5			.moncdump: 
19c5 cd f9 19			call dumpcont 
19c8 3e 78			ld a, display_row_4 
19ca 11 6b 18			ld de, endprog 
19cd			 
19cd cd e8 0b			call update_display		 
19d0			 
19d0 cd f1 1a			call next_page_prompt 
19d3 c3 bf 18			jp monitor 
19d6			 
19d6			 
19d6			; TODO symbol access  
19d6			 
19d6			.symbols:     ;; A list of symbols that can be called up  
19d6 b1 ed			dw display_fb0 
19d8 .. 00			db "fb0",0  
19dc 7a ea		     	dw store_page 
19de .. 00			db "store_page",0 
19e9			 
19e9			 
19e9			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
19e9			 
19e9 3a c2 e2			ld a,(scratch+1) 
19ec fe 00			cp 0 
19ee 28 09			jr z, dumpcont 
19f0			 
19f0				; no, not a null term line so has an address to work out.... 
19f0			 
19f0 21 c3 e2			ld hl,scratch+2 
19f3 cd b1 10			call get_word_hl 
19f6			 
19f6 22 e4 e5			ld (os_cur_ptr),hl	 
19f9			 
19f9			 
19f9			 
19f9			dumpcont: 
19f9			 
19f9				; dump bytes at ptr 
19f9			 
19f9			 
19f9 3e 00			ld a, display_row_1 
19fb 2a cc eb			ld hl, (display_fb_active) 
19fe cd f2 0d			call addatohl 
1a01 cd 29 1a			call .dumpbyterow 
1a04			 
1a04 3e 28			ld a, display_row_2 
1a06 2a cc eb			ld hl, (display_fb_active) 
1a09 cd f2 0d			call addatohl 
1a0c cd 29 1a			call .dumpbyterow 
1a0f			 
1a0f			 
1a0f 3e 50			ld a, display_row_3 
1a11 2a cc eb			ld hl, (display_fb_active) 
1a14 cd f2 0d			call addatohl 
1a17 cd 29 1a			call .dumpbyterow 
1a1a			 
1a1a 3e 78			ld a, display_row_4 
1a1c 2a cc eb			ld hl, (display_fb_active) 
1a1f cd f2 0d			call addatohl 
1a22 cd 29 1a			call .dumpbyterow 
1a25			 
1a25 cd e8 0b			call update_display 
1a28			;		jp cli 
1a28 c9				ret 
1a29			 
1a29			.dumpbyterow: 
1a29			 
1a29				;push af 
1a29			 
1a29 e5				push hl 
1a2a			 
1a2a				; calc where to poke the ascii 
1a2a			if display_cols == 20 
1a2a				ld a, 16 
1a2a			else 
1a2a 3e 1f			ld a, 31 
1a2c			endif 
1a2c			 
1a2c cd f2 0d			call addatohl 
1a2f 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1a32			 
1a32			 
1a32			; display decoding address 
1a32 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a35			 
1a35 7c				ld a,h 
1a36 e1				pop hl 
1a37 e5				push hl 
1a38			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a38 cd fb 0f			call hexout 
1a3b 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a3e			 
1a3e 7d				ld a,l 
1a3f e1				pop hl 
1a40 23				inc hl 
1a41 23				inc hl 
1a42 e5				push hl 
1a43			;	ld hl, os_word_scratch+2 
1a43 cd fb 0f			call hexout 
1a46 e1				pop hl 
1a47 23				inc hl 
1a48 23				inc hl 
1a49				;ld hl, os_word_scratch+4 
1a49 3e 3a			ld a, ':' 
1a4b 77				ld (hl),a 
1a4c 23				inc hl 
1a4d				;ld a, 0 
1a4d				;ld (hl),a 
1a4d				;ld de, os_word_scratch 
1a4d				;pop af 
1a4d				;push af 
1a4d			;		ld a, display_row_2 
1a4d			;		call str_at_display 
1a4d			;		call update_display 
1a4d			 
1a4d			 
1a4d			;pop af 
1a4d			;	add 5 
1a4d			 
1a4d			if display_cols == 20 
1a4d				ld b, 4 
1a4d			else 
1a4d 06 08			ld b, 8 
1a4f			endif	 
1a4f			 
1a4f			.dumpbyte: 
1a4f c5				push bc 
1a50 e5				push hl 
1a51			 
1a51			 
1a51 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a54 7e					ld a,(hl) 
1a55			 
1a55					; poke the ascii to display 
1a55 2a c6 e5				ld hl,(os_word_scratch) 
1a58 77					ld (hl),a 
1a59 23					inc hl 
1a5a 22 c6 e5				ld (os_word_scratch),hl 
1a5d			 
1a5d					 
1a5d			 
1a5d			 
1a5d e1					pop hl 
1a5e e5					push hl 
1a5f			 
1a5f cd fb 0f				call hexout 
1a62			 
1a62					 
1a62 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a65 23				inc hl 
1a66 22 e4 e5		   	ld (os_cur_ptr),hl 
1a69			 
1a69 e1					pop hl 
1a6a 23					inc hl 
1a6b 23					inc hl 
1a6c 23					inc hl 
1a6d			 
1a6d			 
1a6d			 
1a6d					;ld a,0 
1a6d					;ld (os_word_scratch+2),a 
1a6d					;pop af 
1a6d					;push af 
1a6d			 
1a6d					;ld de, os_word_scratch 
1a6d					;call str_at_display 
1a6d			;		call update_display 
1a6d			;		pop af 
1a6d c1					pop bc 
1a6e c6 03				add 3 
1a70 10 dd			djnz .dumpbyte 
1a72			 
1a72				 
1a72			 
1a72 c9				ret 
1a73			 
1a73			jump:	 
1a73			 
1a73 21 c3 e2			ld hl,scratch+2 
1a76 cd b1 10			call get_word_hl 
1a79				;ld hl,(scratch+2) 
1a79				;call fourehexhl 
1a79			 
1a79 22 e4 e5			ld (os_cur_ptr),hl	 
1a7c			 
1a7c e9				jp (hl) 
1a7d			 
1a7d			 
1a7d			 
1a7d			; TODO implement a basic monitor mode to start with 
1a7d			 
1a7d			 
1a7d			 
1a7d			 
1a7d			 
1a7d			 
1a7d			 
1a7d			 
1a7d			 
1a7d			; testing and demo code during development 
1a7d			 
1a7d			 
1a7d .. 00		str1: db "Enter some text...",0 
1a90 .. 00		clear: db "                    ",0 
1aa5			 
1aa5			demo: 
1aa5			 
1aa5			 
1aa5			 
1aa5			;	call update_display 
1aa5			 
1aa5				; init scratch input area for testing 
1aa5 21 c1 e2			ld hl, scratch	 
1aa8 3e 00			ld a,0 
1aaa 77				ld (hl),a 
1aab			 
1aab			 
1aab 3e 28		            LD   A, display_row_2 
1aad			;            CALL fLCD_Pos       ;Position cursor to location in A 
1aad 11 7d 1a		            LD   DE, str1 
1ab0 cd d8 0b			call str_at_display 
1ab3			 
1ab3			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ab3			cloop:	 
1ab3 3e 50		            LD   A, display_row_3 
1ab5			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ab5 11 90 1a		            LD   DE, clear 
1ab8			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1ab8 cd d8 0b				call str_at_display 
1abb 3e 78			ld a, display_row_4 
1abd 11 ed 1a			ld de, prompt 
1ac0			 
1ac0 cd d8 0b				call str_at_display 
1ac3 cd e8 0b			call update_display 
1ac6			 
1ac6 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1ac8 16 0a			ld d, 10 
1aca 21 c1 e2			ld hl, scratch	 
1acd cd 1f 0e			call input_str 
1ad0			 
1ad0			;	call clear_display 
1ad0			;'	call update_display 
1ad0			 
1ad0 3e 00		            LD   A, display_row_1 
1ad2			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ad2 11 90 1a		            LD   DE, clear 
1ad5 cd d8 0b				call str_at_display 
1ad8			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ad8 3e 00		            LD   A, display_row_1 
1ada			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ada 11 c1 e2		            LD   DE, scratch 
1add			;            CALL fLCD_Str       ;Display string pointed to by DE 
1add cd d8 0b				call str_at_display 
1ae0 cd e8 0b			call update_display 
1ae3			 
1ae3 3e 00				ld a,0 
1ae5 21 c1 e2			ld hl, scratch 
1ae8 77				ld (hl),a 
1ae9			 
1ae9 00				nop 
1aea c3 b3 1a			jp cloop 
1aed			 
1aed			 
1aed			 
1aed			; OS Prompt 
1aed			 
1aed .. 00		prompt: db ">",0 
1aef .. 00		endprg: db "?",0 
1af1			 
1af1			 
1af1			; handy next page prompt 
1af1			next_page_prompt: 
1af1 e5				push hl 
1af2 d5				push de 
1af3 f5				push af 
1af4 c5				push bc 
1af5			 
1af5 3e 9f			ld a,display_row_4 + display_cols - 1 
1af7 11 ef 1a		        ld de, endprg 
1afa cd d8 0b			call str_at_display 
1afd cd e8 0b			call update_display 
1b00 cd 74 5e			call cin_wait 
1b03 c1				pop bc 
1b04 f1				pop af 
1b05 d1				pop de 
1b06 e1				pop hl 
1b07			 
1b07			 
1b07 c9				ret 
1b08			 
1b08			 
1b08			; forth parser 
1b08			 
1b08			; My forth kernel 
1b08			include "forth_kernel.asm" 
1b08			; 
1b08			; kernel to the forth OS 
1b08			 
1b08			DS_TYPE_STR: equ 1     ; string type 
1b08			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1b08			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1b08			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1b08			 
1b08			FORTH_PARSEV1: equ 0 
1b08			FORTH_PARSEV2: equ 0 
1b08			FORTH_PARSEV3: equ 0 
1b08			FORTH_PARSEV4: equ 0 
1b08			FORTH_PARSEV5: equ 1 
1b08			 
1b08			;if FORTH_PARSEV5 
1b08			;	FORTH_END_BUFFER: equ 0 
1b08			;else 
1b08			FORTH_END_BUFFER: equ 127 
1b08			;endif 
1b08			 
1b08			FORTH_TRUE: equ 1 
1b08			FORTH_FALSE: equ 0 
1b08			 
1b08			if FORTH_PARSEV4 
1b08			include "forth_stackops.asm" 
1b08			endif 
1b08			 
1b08			if FORTH_PARSEV5 
1b08			include "forth_stackopsv5.asm" 
1b08			 
1b08			; Stack operations for v5 parser on wards 
1b08			; * DATA stack 
1b08			; * LOOP stack 
1b08			; * RETURN stack 
1b08			 
1b08			 
1b08			 
1b08			FORTH_CHK_DSP_UNDER: macro 
1b08				push hl 
1b08				push de 
1b08				ld hl,(cli_data_sp) 
1b08				ld de, cli_data_stack 
1b08				call cmp16 
1b08				jp c, fault_dsp_under 
1b08				pop de 
1b08				pop hl 
1b08				endm 
1b08			 
1b08			 
1b08			FORTH_CHK_RSP_UNDER: macro 
1b08				push hl 
1b08				push de 
1b08				ld hl,(cli_ret_sp) 
1b08				ld de, cli_ret_stack 
1b08				call cmp16 
1b08				jp c, fault_rsp_under 
1b08				pop de 
1b08				pop hl 
1b08				endm 
1b08			 
1b08			FORTH_CHK_LOOP_UNDER: macro 
1b08				push hl 
1b08				push de 
1b08				ld hl,(cli_loop_sp) 
1b08				ld de, cli_loop_stack 
1b08				call cmp16 
1b08				jp c, fault_loop_under 
1b08				pop de 
1b08				pop hl 
1b08				endm 
1b08			 
1b08			FORTH_ERR_TOS_NOTSTR: macro 
1b08				; TOSO might need more for checks when used 
1b08				push af 
1b08				ld a,(hl) 
1b08				cp DS_TYPE_STR 
1b08				jp nz, type_faultn   
1b08				pop af 
1b08				endm 
1b08			 
1b08			FORTH_ERR_TOS_NOTNUM: macro 
1b08				push af 
1b08				ld a,(hl) 
1b08				cp DS_TYPE_INUM 
1b08				jp nz, type_faultn   
1b08				pop af 
1b08				endm 
1b08			 
1b08			 
1b08			; increase data stack pointer and save hl to it 
1b08				 
1b08			FORTH_DSP_NEXT: macro 
1b08				call macro_forth_dsp_next 
1b08				endm 
1b08			 
1b08			 
1b08			macro_forth_dsp_next: 
1b08				if DEBUG_FORTH_STACK_GUARD 
1b08 cd 9a 5a				call check_stacks 
1b0b				endif 
1b0b e5				push hl 
1b0c d5				push de 
1b0d eb				ex de,hl 
1b0e 2a ee e9			ld hl,(cli_data_sp) 
1b11 23				inc hl 
1b12 23				inc hl 
1b13			 
1b13			; PARSEV5 
1b13 23				inc hl 
1b14 22 ee e9			ld (cli_data_sp),hl 
1b17 73				ld (hl), e 
1b18 23				inc hl 
1b19 72				ld (hl), d 
1b1a d1				pop de 
1b1b e1				pop hl 
1b1c				if DEBUG_FORTH_STACK_GUARD 
1b1c cd 9a 5a				call check_stacks 
1b1f				endif 
1b1f c9				ret 
1b20			 
1b20			 
1b20			; increase ret stack pointer and save hl to it 
1b20				 
1b20			FORTH_RSP_NEXT: macro 
1b20				call macro_forth_rsp_next 
1b20				endm 
1b20			 
1b20			macro_forth_rsp_next: 
1b20				if DEBUG_FORTH_STACK_GUARD 
1b20 cd 9a 5a				call check_stacks 
1b23				endif 
1b23 e5				push hl 
1b24 d5				push de 
1b25 eb				ex de,hl 
1b26 2a f2 e9			ld hl,(cli_ret_sp) 
1b29 23				inc hl 
1b2a 23				inc hl 
1b2b 22 f2 e9			ld (cli_ret_sp),hl 
1b2e 73				ld (hl), e 
1b2f 23				inc hl 
1b30 72				ld (hl), d 
1b31 d1				pop de 
1b32 e1				pop hl 
1b33				if DEBUG_FORTH_STACK_GUARD 
1b33 cd 9a 5a				call check_stacks 
1b36				endif 
1b36 c9				ret 
1b37			 
1b37			; get current ret stack pointer and save to hl  
1b37				 
1b37			FORTH_RSP_TOS: macro 
1b37				call macro_forth_rsp_tos 
1b37				endm 
1b37			 
1b37			macro_forth_rsp_tos: 
1b37				;push de 
1b37 2a f2 e9			ld hl,(cli_ret_sp) 
1b3a cd 72 1b			call loadhlptrtohl 
1b3d				;ld e, (hl) 
1b3d				;inc hl 
1b3d				;ld d, (hl) 
1b3d				;ex de, hl 
1b3d					if DEBUG_FORTH_WORDS 
1b3d			;			DMARK "RST" 
1b3d						CALLMONITOR 
1b3d cd 6f ee			call debug_vector  
1b40				endm  
# End of macro CALLMONITOR
1b40					endif 
1b40				;pop de 
1b40 c9				ret 
1b41			 
1b41			; pop ret stack pointer 
1b41				 
1b41			FORTH_RSP_POP: macro 
1b41				call macro_forth_rsp_pop 
1b41				endm 
1b41			 
1b41			 
1b41			macro_forth_rsp_pop: 
1b41				if DEBUG_FORTH_STACK_GUARD 
1b41			;		DMARK "RPP" 
1b41 cd 9a 5a				call check_stacks 
1b44					FORTH_CHK_RSP_UNDER 
1b44 e5				push hl 
1b45 d5				push de 
1b46 2a f2 e9			ld hl,(cli_ret_sp) 
1b49 11 ac e9			ld de, cli_ret_stack 
1b4c cd 10 0e			call cmp16 
1b4f da b1 5b			jp c, fault_rsp_under 
1b52 d1				pop de 
1b53 e1				pop hl 
1b54				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b54				endif 
1b54 e5				push hl 
1b55 2a f2 e9			ld hl,(cli_ret_sp) 
1b58			 
1b58			 
1b58				if FORTH_ENABLE_FREE 
1b58			 
1b58					; get pointer 
1b58			 
1b58					push de 
1b58					push hl 
1b58			 
1b58					ld e, (hl) 
1b58					inc hl 
1b58					ld d, (hl) 
1b58			 
1b58					ex de, hl 
1b58					call free 
1b58			 
1b58					pop hl 
1b58					pop de 
1b58			 
1b58			 
1b58				endif 
1b58			 
1b58			 
1b58 2b				dec hl 
1b59 2b				dec hl 
1b5a 22 f2 e9			ld (cli_ret_sp), hl 
1b5d				; do stack underflow checks 
1b5d e1				pop hl 
1b5e				if DEBUG_FORTH_STACK_GUARD 
1b5e cd 9a 5a				call check_stacks 
1b61					FORTH_CHK_RSP_UNDER 
1b61 e5				push hl 
1b62 d5				push de 
1b63 2a f2 e9			ld hl,(cli_ret_sp) 
1b66 11 ac e9			ld de, cli_ret_stack 
1b69 cd 10 0e			call cmp16 
1b6c da b1 5b			jp c, fault_rsp_under 
1b6f d1				pop de 
1b70 e1				pop hl 
1b71				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b71				endif 
1b71 c9				ret 
1b72			 
1b72			 
1b72			 
1b72			; routine to load word pointed to by hl into hl 
1b72			 
1b72			loadhlptrtohl: 
1b72			 
1b72 d5				push de 
1b73 5e				ld e, (hl) 
1b74 23				inc hl 
1b75 56				ld d, (hl) 
1b76 eb				ex de, hl 
1b77 d1				pop de 
1b78			 
1b78 c9				ret 
1b79			 
1b79			 
1b79			 
1b79			 
1b79			 
1b79			; push a number held in HL onto the data stack 
1b79			; entry point for pushing a value when already in hl used in function above 
1b79			 
1b79			forth_push_numhl: 
1b79			 
1b79 e5				push hl    ; save value to push 
1b7a			 
1b7a			if DEBUG_FORTH_PUSH 
1b7a				; see if disabled 
1b7a			 
1b7a			 
1b7a f5				push af 
1b7b 3a 6f ee			ld a,(debug_vector) 
1b7e fe c9			cp $c9   ; ret 
1b80			;	ld a, (os_view_disable) 
1b80			;	cp '*' 
1b80 28 34			jr z, .pskip2 
1b82 e5				push hl 
1b83 e5			push hl 
1b84 cd c5 0b			call clear_display 
1b87 e1			pop hl 
1b88 7c				ld a,h 
1b89 21 c6 e5			ld hl, os_word_scratch 
1b8c cd fb 0f			call hexout 
1b8f e1				pop hl 
1b90 7d				ld a,l 
1b91 21 c8 e5			ld hl, os_word_scratch+2 
1b94 cd fb 0f			call hexout 
1b97			 
1b97 21 ca e5			ld hl, os_word_scratch+4 
1b9a 3e 00			ld a,0 
1b9c 77				ld (hl),a 
1b9d 11 c6 e5			ld de,os_word_scratch 
1ba0 3e 28				ld a, display_row_2 
1ba2 cd d8 0b				call str_at_display 
1ba5 11 a8 4c			ld de, .push_num 
1ba8 3e 00			ld a, display_row_1 
1baa			 
1baa cd d8 0b				call str_at_display 
1bad			 
1bad			 
1bad cd e8 0b			call update_display 
1bb0 cd fd 0a			call delay1s 
1bb3 cd fd 0a			call delay1s 
1bb6			.pskip2:  
1bb6			 
1bb6 f1				pop af 
1bb7			endif	 
1bb7			 
1bb7			 
1bb7				FORTH_DSP_NEXT 
1bb7 cd 08 1b			call macro_forth_dsp_next 
1bba				endm 
# End of macro FORTH_DSP_NEXT
1bba			 
1bba 2a ee e9			ld hl, (cli_data_sp) 
1bbd			 
1bbd				; save item type 
1bbd 3e 02			ld a,  DS_TYPE_INUM 
1bbf 77				ld (hl), a 
1bc0 23				inc hl 
1bc1			 
1bc1				; get word off stack 
1bc1 d1				pop de 
1bc2 7b				ld a,e 
1bc3 77				ld (hl), a 
1bc4 23				inc hl 
1bc5 7a				ld a,d 
1bc6 77				ld (hl), a 
1bc7			 
1bc7			if DEBUG_FORTH_PUSH 
1bc7 2b				dec hl 
1bc8 2b				dec hl 
1bc9 2b				dec hl 
1bca						DMARK "PH5" 
1bca f5				push af  
1bcb 3a df 1b			ld a, (.dmark)  
1bce 32 6b ee			ld (debug_mark),a  
1bd1 3a e0 1b			ld a, (.dmark+1)  
1bd4 32 6c ee			ld (debug_mark+1),a  
1bd7 3a e1 1b			ld a, (.dmark+2)  
1bda 32 6d ee			ld (debug_mark+2),a  
1bdd 18 03			jr .pastdmark  
1bdf ..			.dmark: db "PH5"  
1be2 f1			.pastdmark: pop af  
1be3			endm  
# End of macro DMARK
1be3				CALLMONITOR 
1be3 cd 6f ee			call debug_vector  
1be6				endm  
# End of macro CALLMONITOR
1be6			endif	 
1be6			 
1be6 c9				ret 
1be7			 
1be7			 
1be7			; Push a string to stack pointed to by hl 
1be7			 
1be7			forth_push_str: 
1be7			 
1be7			if DEBUG_FORTH_PUSH 
1be7						DMARK "PSQ" 
1be7 f5				push af  
1be8 3a fc 1b			ld a, (.dmark)  
1beb 32 6b ee			ld (debug_mark),a  
1bee 3a fd 1b			ld a, (.dmark+1)  
1bf1 32 6c ee			ld (debug_mark+1),a  
1bf4 3a fe 1b			ld a, (.dmark+2)  
1bf7 32 6d ee			ld (debug_mark+2),a  
1bfa 18 03			jr .pastdmark  
1bfc ..			.dmark: db "PSQ"  
1bff f1			.pastdmark: pop af  
1c00			endm  
# End of macro DMARK
1c00				CALLMONITOR 
1c00 cd 6f ee			call debug_vector  
1c03				endm  
# End of macro CALLMONITOR
1c03			endif	 
1c03			 
1c03			 
1c03			    
1c03 e5				push hl 
1c04 e5				push hl 
1c05			 
1c05			;	ld a, 0   ; find end of string 
1c05 cd 58 11			call strlenz 
1c08			if DEBUG_FORTH_PUSH 
1c08						DMARK "PQ2" 
1c08 f5				push af  
1c09 3a 1d 1c			ld a, (.dmark)  
1c0c 32 6b ee			ld (debug_mark),a  
1c0f 3a 1e 1c			ld a, (.dmark+1)  
1c12 32 6c ee			ld (debug_mark+1),a  
1c15 3a 1f 1c			ld a, (.dmark+2)  
1c18 32 6d ee			ld (debug_mark+2),a  
1c1b 18 03			jr .pastdmark  
1c1d ..			.dmark: db "PQ2"  
1c20 f1			.pastdmark: pop af  
1c21			endm  
# End of macro DMARK
1c21				CALLMONITOR 
1c21 cd 6f ee			call debug_vector  
1c24				endm  
# End of macro CALLMONITOR
1c24			endif	 
1c24 eb				ex de, hl 
1c25 e1				pop hl   ; get ptr to start of string 
1c26			if DEBUG_FORTH_PUSH 
1c26						DMARK "PQ3" 
1c26 f5				push af  
1c27 3a 3b 1c			ld a, (.dmark)  
1c2a 32 6b ee			ld (debug_mark),a  
1c2d 3a 3c 1c			ld a, (.dmark+1)  
1c30 32 6c ee			ld (debug_mark+1),a  
1c33 3a 3d 1c			ld a, (.dmark+2)  
1c36 32 6d ee			ld (debug_mark+2),a  
1c39 18 03			jr .pastdmark  
1c3b ..			.dmark: db "PQ3"  
1c3e f1			.pastdmark: pop af  
1c3f			endm  
# End of macro DMARK
1c3f				CALLMONITOR 
1c3f cd 6f ee			call debug_vector  
1c42				endm  
# End of macro CALLMONITOR
1c42			endif	 
1c42 19				add hl,de 
1c43			if DEBUG_FORTH_PUSH 
1c43						DMARK "PQE" 
1c43 f5				push af  
1c44 3a 58 1c			ld a, (.dmark)  
1c47 32 6b ee			ld (debug_mark),a  
1c4a 3a 59 1c			ld a, (.dmark+1)  
1c4d 32 6c ee			ld (debug_mark+1),a  
1c50 3a 5a 1c			ld a, (.dmark+2)  
1c53 32 6d ee			ld (debug_mark+2),a  
1c56 18 03			jr .pastdmark  
1c58 ..			.dmark: db "PQE"  
1c5b f1			.pastdmark: pop af  
1c5c			endm  
# End of macro DMARK
1c5c				CALLMONITOR 
1c5c cd 6f ee			call debug_vector  
1c5f				endm  
# End of macro CALLMONITOR
1c5f			endif	 
1c5f			 
1c5f 2b				dec hl    ; see if there is an optional trailing double quote 
1c60 7e				ld a,(hl) 
1c61 fe 22			cp '"' 
1c63 20 03			jr nz, .strnoq 
1c65 3e 00			ld a, 0      ; get rid of double quote 
1c67 77				ld (hl), a 
1c68 23			.strnoq: inc hl 
1c69			 
1c69 3e 00			ld a, 0 
1c6b 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1c6c			 
1c6c 13				inc de ; add one for the type string 
1c6d 13				inc de ; add one for null term??? 
1c6e			 
1c6e				; tos is get string pointer again 
1c6e				; de contains space to allocate 
1c6e				 
1c6e d5				push de 
1c6f			 
1c6f eb				ex de, hl 
1c70			 
1c70				;push af 
1c70			 
1c70			if DEBUG_FORTH_PUSH 
1c70						DMARK "PHm" 
1c70 f5				push af  
1c71 3a 85 1c			ld a, (.dmark)  
1c74 32 6b ee			ld (debug_mark),a  
1c77 3a 86 1c			ld a, (.dmark+1)  
1c7a 32 6c ee			ld (debug_mark+1),a  
1c7d 3a 87 1c			ld a, (.dmark+2)  
1c80 32 6d ee			ld (debug_mark+2),a  
1c83 18 03			jr .pastdmark  
1c85 ..			.dmark: db "PHm"  
1c88 f1			.pastdmark: pop af  
1c89			endm  
# End of macro DMARK
1c89				CALLMONITOR 
1c89 cd 6f ee			call debug_vector  
1c8c				endm  
# End of macro CALLMONITOR
1c8c			endif	 
1c8c cd cd 11			call malloc	; on ret hl now contains allocated memory 
1c8f				if DEBUG_FORTH_MALLOC_GUARD 
1c8f cc 00 4d				call z,malloc_error 
1c92				endif 
1c92			 
1c92				 
1c92 c1				pop bc    ; get length 
1c93 d1				pop de   ;  get string start    
1c94			 
1c94				; hl has destination from malloc 
1c94			 
1c94 eb				ex de, hl    ; prep for ldir 
1c95			 
1c95 d5				push de   ; save malloc area for DSP later 
1c96				;push hl   ; save malloc area for DSP later 
1c96			 
1c96			if DEBUG_FORTH_PUSH 
1c96						DMARK "PHc" 
1c96 f5				push af  
1c97 3a ab 1c			ld a, (.dmark)  
1c9a 32 6b ee			ld (debug_mark),a  
1c9d 3a ac 1c			ld a, (.dmark+1)  
1ca0 32 6c ee			ld (debug_mark+1),a  
1ca3 3a ad 1c			ld a, (.dmark+2)  
1ca6 32 6d ee			ld (debug_mark+2),a  
1ca9 18 03			jr .pastdmark  
1cab ..			.dmark: db "PHc"  
1cae f1			.pastdmark: pop af  
1caf			endm  
# End of macro DMARK
1caf				CALLMONITOR 
1caf cd 6f ee			call debug_vector  
1cb2				endm  
# End of macro CALLMONITOR
1cb2			endif	 
1cb2			 
1cb2			 
1cb2 ed b0			ldir 
1cb4			 
1cb4			 
1cb4				; push malloc to data stack     macro?????  
1cb4			 
1cb4				FORTH_DSP_NEXT 
1cb4 cd 08 1b			call macro_forth_dsp_next 
1cb7				endm 
# End of macro FORTH_DSP_NEXT
1cb7			 
1cb7				; save value and type 
1cb7			 
1cb7 2a ee e9			ld hl, (cli_data_sp) 
1cba			 
1cba				; save item type 
1cba 3e 01			ld a,  DS_TYPE_STR 
1cbc 77				ld (hl), a 
1cbd 23				inc hl 
1cbe			 
1cbe				; get malloc word off stack 
1cbe d1				pop de 
1cbf 73				ld (hl), e 
1cc0 23				inc hl 
1cc1 72				ld (hl), d 
1cc2			 
1cc2			 
1cc2			 
1cc2			if DEBUG_FORTH_PUSH 
1cc2 2a ee e9			ld hl, (cli_data_sp) 
1cc5						DMARK "PHS" 
1cc5 f5				push af  
1cc6 3a da 1c			ld a, (.dmark)  
1cc9 32 6b ee			ld (debug_mark),a  
1ccc 3a db 1c			ld a, (.dmark+1)  
1ccf 32 6c ee			ld (debug_mark+1),a  
1cd2 3a dc 1c			ld a, (.dmark+2)  
1cd5 32 6d ee			ld (debug_mark+2),a  
1cd8 18 03			jr .pastdmark  
1cda ..			.dmark: db "PHS"  
1cdd f1			.pastdmark: pop af  
1cde			endm  
# End of macro DMARK
1cde				CALLMONITOR 
1cde cd 6f ee			call debug_vector  
1ce1				endm  
# End of macro CALLMONITOR
1ce1			;	ex de,hl 
1ce1			endif	 
1ce1				; in case of spaces, skip the ptr past the copied string 
1ce1				;pop af 
1ce1				;ld (cli_origptr),hl 
1ce1			 
1ce1 c9				ret 
1ce2			 
1ce2			 
1ce2			 
1ce2			; TODO ascii push input onto stack given hl to start of input 
1ce2			 
1ce2			; identify type 
1ce2			; if starts with a " then a string 
1ce2			; otherwise it is a number 
1ce2			;  
1ce2			; if a string 
1ce2			;     scan for ending " to get length of string to malloc for + 1 
1ce2			;     malloc 
1ce2			;     put pointer to string on stack first byte flags as string 
1ce2			; 
1ce2			; else a number 
1ce2			;    look for number format identifier 
1ce2			;    $xx hex 
1ce2			;    %xxxxx bin 
1ce2			;    xxxxx decimal 
1ce2			;    convert number to 16bit word.  
1ce2			;    malloc word + 1 with flag to identiy as num 
1ce2			;    put pointer to number on stack 
1ce2			;   
1ce2			;  
1ce2			  
1ce2			forth_apush: 
1ce2				; kernel push 
1ce2			 
1ce2			if DEBUG_FORTH_PUSH 
1ce2						DMARK "PSH" 
1ce2 f5				push af  
1ce3 3a f7 1c			ld a, (.dmark)  
1ce6 32 6b ee			ld (debug_mark),a  
1ce9 3a f8 1c			ld a, (.dmark+1)  
1cec 32 6c ee			ld (debug_mark+1),a  
1cef 3a f9 1c			ld a, (.dmark+2)  
1cf2 32 6d ee			ld (debug_mark+2),a  
1cf5 18 03			jr .pastdmark  
1cf7 ..			.dmark: db "PSH"  
1cfa f1			.pastdmark: pop af  
1cfb			endm  
# End of macro DMARK
1cfb				CALLMONITOR 
1cfb cd 6f ee			call debug_vector  
1cfe				endm  
# End of macro CALLMONITOR
1cfe			endif	 
1cfe				; identify input type 
1cfe			 
1cfe 7e				ld a,(hl) 
1cff			 
1cff fe 23			cp '#' 
1d01 ca 3b 1d			jp z, .fapdec 
1d04			 
1d04			 
1d04 fe 22			cp '"' 
1d06 28 0a			jr z, .fapstr 
1d08 fe 24			cp '$' 
1d0a ca 32 1d			jp z, .faphex 
1d0d fe 25			cp '%' 
1d0f ca 1a 1d			jp z, .fapbin 
1d12			;	cp 'b' 
1d12			;	jp z, .fabin 
1d12				; else decimal 
1d12			 
1d12				; TODO do decimal conversion 
1d12				; decimal is stored as a 16bit word 
1d12			 
1d12				; by default everything is a string if type is not detected 
1d12			.fapstr: ; 
1d12 fe 22			cp '"' 
1d14 20 01			jr nz, .strnoqu 
1d16 23				inc hl 
1d17			.strnoqu: 
1d17 c3 e7 1b			jp forth_push_str 
1d1a			 
1d1a			 
1d1a			 
1d1a			.fapbin:    ; push a binary string.  
1d1a 11 00 00			ld de, 0   ; hold a 16bit value 
1d1d			 
1d1d 23			.fapbinshift:	inc hl  
1d1e 7e				ld a,(hl) 
1d1f fe 00			cp 0     ; done scanning  
1d21 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d23			 
1d23				; left shift de 
1d23 eb				ex de, hl	 
1d24 29				add hl, hl 
1d25			 
1d25				; is 1 
1d25 fe 31			cp '1' 
1d27 20 02			jr nz, .binzero 
1d29 cb 4d			bit 1, l 
1d2b			.binzero: 
1d2b eb				ex de, hl	 ; save current de 
1d2c 18 ef			jr .fapbinshift 
1d2e			 
1d2e			.fapbdone: 
1d2e eb				ex de, hl 
1d2f c3 79 1b			jp forth_push_numhl 
1d32			 
1d32			 
1d32			.faphex:   ; hex is always stored as a 16bit word 
1d32				; skip number prefix 
1d32 23				inc hl 
1d33				; turn ascii into number 
1d33 cd b1 10			call get_word_hl	; ret 16bit word in hl 
1d36			 
1d36 c3 79 1b			jp forth_push_numhl 
1d39			 
1d39 00				 nop 
1d3a			 
1d3a			.fabin:   ; TODO bin conversion 
1d3a			 
1d3a			 
1d3a c9				ret 
1d3b			.fapdec:	 
1d3b				; string to dec conversion 
1d3b 23				inc hl 
1d3c eb				ex de, hl 
1d3d cd ef 10			call string_to_uint16 
1d40 c3 79 1b			jp forth_push_numhl 
1d43 c9				ret 
1d44				 
1d44			;atoui_16: 
1d44			 
1d44			; get either a string ptr or a 16bit word from the data stack 
1d44			 
1d44			FORTH_DSP: macro 
1d44				call macro_forth_dsp 
1d44				endm 
1d44			 
1d44			macro_forth_dsp: 
1d44				; data stack pointer points to current word on tos 
1d44			 
1d44 2a ee e9			ld hl,(cli_data_sp) 
1d47			 
1d47				if DEBUG_FORTH_PUSH 
1d47						DMARK "DSP" 
1d47 f5				push af  
1d48 3a 5c 1d			ld a, (.dmark)  
1d4b 32 6b ee			ld (debug_mark),a  
1d4e 3a 5d 1d			ld a, (.dmark+1)  
1d51 32 6c ee			ld (debug_mark+1),a  
1d54 3a 5e 1d			ld a, (.dmark+2)  
1d57 32 6d ee			ld (debug_mark+2),a  
1d5a 18 03			jr .pastdmark  
1d5c ..			.dmark: db "DSP"  
1d5f f1			.pastdmark: pop af  
1d60			endm  
# End of macro DMARK
1d60			 
1d60 cd 33 4d				call display_data_sp 
1d63				;call break_point_state 
1d63				;rst 030h 
1d63				CALLMONITOR 
1d63 cd 6f ee			call debug_vector  
1d66				endm  
# End of macro CALLMONITOR
1d66				endif 
1d66			 
1d66 c9				ret 
1d67			 
1d67			; return hl to start of value on stack 
1d67			 
1d67			FORTH_DSP_VALUE: macro 
1d67				call macro_forth_dsp_value 
1d67				endm 
1d67			 
1d67			macro_forth_dsp_value: 
1d67			 
1d67				FORTH_DSP 
1d67 cd 44 1d			call macro_forth_dsp 
1d6a				endm 
# End of macro FORTH_DSP
1d6a			 
1d6a d5				push de 
1d6b			 
1d6b 23				inc hl ; skip type 
1d6c			 
1d6c 5e				ld e, (hl) 
1d6d 23				inc hl 
1d6e 56				ld d, (hl) 
1d6f eb				ex de,hl  
1d70			 
1d70 d1				pop de 
1d71			 
1d71 c9				ret 
1d72			 
1d72			; return hl to start of value to second item on stack 
1d72			 
1d72			FORTH_DSP_VALUEM1: macro 
1d72				call macro_forth_dsp_value_m1 
1d72				endm 
1d72			 
1d72			macro_forth_dsp_value_m1: 
1d72			 
1d72				FORTH_DSP 
1d72 cd 44 1d			call macro_forth_dsp 
1d75				endm 
# End of macro FORTH_DSP
1d75			 
1d75 2b				dec hl 
1d76 2b				dec hl 
1d77			;	dec hl 
1d77			 
1d77 d5				push de 
1d78			 
1d78 5e				ld e, (hl) 
1d79 23				inc hl 
1d7a 56				ld d, (hl) 
1d7b eb				ex de,hl  
1d7c			 
1d7c d1				pop de 
1d7d			 
1d7d c9				ret 
1d7e			 
1d7e				 
1d7e			 
1d7e			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1d7e			 
1d7e			FORTH_DSP_POP: macro 
1d7e				call macro_forth_dsp_pop 
1d7e				endm 
1d7e			 
1d7e			 
1d7e			; get the tos data type 
1d7e			 
1d7e			FORTH_DSP_TYPE:   macro 
1d7e			 
1d7e				;FORTH_DSP_VALUE 
1d7e				FORTH_DSP 
1d7e				 
1d7e				; hl points to value 
1d7e				; check type 
1d7e			 
1d7e				ld a,(hl) 
1d7e			 
1d7e				endm 
1d7e			 
1d7e			; load the tos value into hl 
1d7e			 
1d7e			 
1d7e			FORTH_DSP_VALUEHL:  macro 
1d7e				call macro_dsp_valuehl 
1d7e				endm 
1d7e			 
1d7e			 
1d7e			 
1d7e			macro_dsp_valuehl: 
1d7e				FORTH_DSP_VALUE 
1d7e cd 67 1d			call macro_forth_dsp_value 
1d81				endm 
# End of macro FORTH_DSP_VALUE
1d81			 
1d81				;FORTH_ERR_TOS_NOTNUM 
1d81			 
1d81				;inc hl   ; skip type id 
1d81			 
1d81			;	push de 
1d81			; 
1d81			;	ld e, (hl) 
1d81			;	inc hl 
1d81			;	ld d, (hl) 
1d81			;	ex de,hl  
1d81			 
1d81			;	pop de 
1d81			 
1d81				if DEBUG_FORTH_PUSH 
1d81						DMARK "DVL" 
1d81 f5				push af  
1d82 3a 96 1d			ld a, (.dmark)  
1d85 32 6b ee			ld (debug_mark),a  
1d88 3a 97 1d			ld a, (.dmark+1)  
1d8b 32 6c ee			ld (debug_mark+1),a  
1d8e 3a 98 1d			ld a, (.dmark+2)  
1d91 32 6d ee			ld (debug_mark+2),a  
1d94 18 03			jr .pastdmark  
1d96 ..			.dmark: db "DVL"  
1d99 f1			.pastdmark: pop af  
1d9a			endm  
# End of macro DMARK
1d9a				CALLMONITOR 
1d9a cd 6f ee			call debug_vector  
1d9d				endm  
# End of macro CALLMONITOR
1d9d				endif 
1d9d c9				ret 
1d9e			 
1d9e			forth_apushstrhl:      
1d9e				; push of string requires use of cli_origptr 
1d9e				; bodge use 
1d9e			 
1d9e				; get current cli_origptr, save, update with temp pointer  
1d9e ed 5b 3e ea		ld de, (cli_origptr) 
1da2 22 3e ea			ld (cli_origptr), hl 
1da5 d5				push de 
1da6 cd e2 1c			call forth_apush 
1da9 d1				pop de 
1daa ed 53 3e ea		ld (cli_origptr), de 
1dae c9			        ret	 
1daf			 
1daf			 
1daf			; increase loop stack pointer and save hl to it 
1daf				 
1daf			FORTH_LOOP_NEXT: macro 
1daf				call macro_forth_loop_next 
1daf				;nop 
1daf				endm 
1daf			 
1daf			macro_forth_loop_next: 
1daf				if DEBUG_FORTH_STACK_GUARD 
1daf cd 9a 5a				call check_stacks 
1db2				endif 
1db2 e5				push hl 
1db3 d5				push de 
1db4 eb				ex de,hl 
1db5 2a f0 e9			ld hl,(cli_loop_sp) 
1db8 23				inc hl 
1db9 23				inc hl 
1dba					if DEBUG_FORTH_WORDS 
1dba						DMARK "LNX" 
1dba f5				push af  
1dbb 3a cf 1d			ld a, (.dmark)  
1dbe 32 6b ee			ld (debug_mark),a  
1dc1 3a d0 1d			ld a, (.dmark+1)  
1dc4 32 6c ee			ld (debug_mark+1),a  
1dc7 3a d1 1d			ld a, (.dmark+2)  
1dca 32 6d ee			ld (debug_mark+2),a  
1dcd 18 03			jr .pastdmark  
1dcf ..			.dmark: db "LNX"  
1dd2 f1			.pastdmark: pop af  
1dd3			endm  
# End of macro DMARK
1dd3						CALLMONITOR 
1dd3 cd 6f ee			call debug_vector  
1dd6				endm  
# End of macro CALLMONITOR
1dd6					endif 
1dd6 22 f0 e9			ld (cli_loop_sp),hl 
1dd9 73				ld (hl), e 
1dda 23				inc hl 
1ddb 72				ld (hl), d 
1ddc d1				pop de    ; been reversed so save a swap on restore 
1ddd e1				pop hl 
1dde				if DEBUG_FORTH_STACK_GUARD 
1dde cd 9a 5a				call check_stacks 
1de1				endif 
1de1 c9				ret 
1de2			 
1de2			; get current ret stack pointer and save to hl  
1de2				 
1de2			FORTH_LOOP_TOS: macro 
1de2				call macro_forth_loop_tos 
1de2				endm 
1de2			 
1de2			macro_forth_loop_tos: 
1de2 d5				push de 
1de3 2a f0 e9			ld hl,(cli_loop_sp) 
1de6 5e				ld e, (hl) 
1de7 23				inc hl 
1de8 56				ld d, (hl) 
1de9 eb				ex de, hl 
1dea d1				pop de 
1deb c9				ret 
1dec			 
1dec			; pop loop stack pointer 
1dec				 
1dec			FORTH_LOOP_POP: macro 
1dec				call macro_forth_loop_pop 
1dec				endm 
1dec			 
1dec			 
1dec			macro_forth_loop_pop: 
1dec				if DEBUG_FORTH_STACK_GUARD 
1dec					DMARK "LPP" 
1dec f5				push af  
1ded 3a 01 1e			ld a, (.dmark)  
1df0 32 6b ee			ld (debug_mark),a  
1df3 3a 02 1e			ld a, (.dmark+1)  
1df6 32 6c ee			ld (debug_mark+1),a  
1df9 3a 03 1e			ld a, (.dmark+2)  
1dfc 32 6d ee			ld (debug_mark+2),a  
1dff 18 03			jr .pastdmark  
1e01 ..			.dmark: db "LPP"  
1e04 f1			.pastdmark: pop af  
1e05			endm  
# End of macro DMARK
1e05 cd 9a 5a				call check_stacks 
1e08					FORTH_CHK_LOOP_UNDER 
1e08 e5				push hl 
1e09 d5				push de 
1e0a 2a f0 e9			ld hl,(cli_loop_sp) 
1e0d 11 2a e9			ld de, cli_loop_stack 
1e10 cd 10 0e			call cmp16 
1e13 da b7 5b			jp c, fault_loop_under 
1e16 d1				pop de 
1e17 e1				pop hl 
1e18				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e18				endif 
1e18 e5				push hl 
1e19 2a f0 e9			ld hl,(cli_loop_sp) 
1e1c 2b				dec hl 
1e1d 2b				dec hl 
1e1e 22 f0 e9			ld (cli_loop_sp), hl 
1e21				; TODO do stack underflow checks 
1e21 e1				pop hl 
1e22				if DEBUG_FORTH_STACK_GUARD 
1e22 cd 9a 5a				call check_stacks 
1e25					FORTH_CHK_LOOP_UNDER 
1e25 e5				push hl 
1e26 d5				push de 
1e27 2a f0 e9			ld hl,(cli_loop_sp) 
1e2a 11 2a e9			ld de, cli_loop_stack 
1e2d cd 10 0e			call cmp16 
1e30 da b7 5b			jp c, fault_loop_under 
1e33 d1				pop de 
1e34 e1				pop hl 
1e35				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e35				endif 
1e35 c9				ret 
1e36			 
1e36			macro_forth_dsp_pop: 
1e36			 
1e36 e5				push hl 
1e37			 
1e37				; release malloc data 
1e37			 
1e37				if DEBUG_FORTH_STACK_GUARD 
1e37 cd 9a 5a				call check_stacks 
1e3a					FORTH_CHK_DSP_UNDER 
1e3a e5				push hl 
1e3b d5				push de 
1e3c 2a ee e9			ld hl,(cli_data_sp) 
1e3f 11 28 e8			ld de, cli_data_stack 
1e42 cd 10 0e			call cmp16 
1e45 da ab 5b			jp c, fault_dsp_under 
1e48 d1				pop de 
1e49 e1				pop hl 
1e4a				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e4a				endif 
1e4a				;ld hl,(cli_data_sp) 
1e4a			if DEBUG_FORTH_DOT 
1e4a				DMARK "DPP" 
1e4a f5				push af  
1e4b 3a 5f 1e			ld a, (.dmark)  
1e4e 32 6b ee			ld (debug_mark),a  
1e51 3a 60 1e			ld a, (.dmark+1)  
1e54 32 6c ee			ld (debug_mark+1),a  
1e57 3a 61 1e			ld a, (.dmark+2)  
1e5a 32 6d ee			ld (debug_mark+2),a  
1e5d 18 03			jr .pastdmark  
1e5f ..			.dmark: db "DPP"  
1e62 f1			.pastdmark: pop af  
1e63			endm  
# End of macro DMARK
1e63				CALLMONITOR 
1e63 cd 6f ee			call debug_vector  
1e66				endm  
# End of macro CALLMONITOR
1e66			endif	 
1e66			 
1e66			 
1e66			if FORTH_ENABLE_DSPPOPFREE 
1e66			 
1e66				FORTH_DSP 
1e66 cd 44 1d			call macro_forth_dsp 
1e69				endm 
# End of macro FORTH_DSP
1e69			 
1e69 7e				ld a, (hl) 
1e6a fe 01			cp DS_TYPE_STR 
1e6c 20 23			jr nz, .skippopfree 
1e6e			 
1e6e				FORTH_DSP_VALUEHL 
1e6e cd 7e 1d			call macro_dsp_valuehl 
1e71				endm 
# End of macro FORTH_DSP_VALUEHL
1e71 00				nop 
1e72			if DEBUG_FORTH_DOT 
1e72				DMARK "DPf" 
1e72 f5				push af  
1e73 3a 87 1e			ld a, (.dmark)  
1e76 32 6b ee			ld (debug_mark),a  
1e79 3a 88 1e			ld a, (.dmark+1)  
1e7c 32 6c ee			ld (debug_mark+1),a  
1e7f 3a 89 1e			ld a, (.dmark+2)  
1e82 32 6d ee			ld (debug_mark+2),a  
1e85 18 03			jr .pastdmark  
1e87 ..			.dmark: db "DPf"  
1e8a f1			.pastdmark: pop af  
1e8b			endm  
# End of macro DMARK
1e8b				CALLMONITOR 
1e8b cd 6f ee			call debug_vector  
1e8e				endm  
# End of macro CALLMONITOR
1e8e			endif	 
1e8e cd 97 12			call free 
1e91			.skippopfree: 
1e91				 
1e91			 
1e91			endif 
1e91			 
1e91			if DEBUG_FORTH_DOT_KEY 
1e91				DMARK "DP2" 
1e91				CALLMONITOR 
1e91			endif	 
1e91			 
1e91				; move pointer down 
1e91			 
1e91 2a ee e9			ld hl,(cli_data_sp) 
1e94 2b				dec hl 
1e95 2b				dec hl 
1e96			; PARSEV5 
1e96 2b				dec hl 
1e97 22 ee e9			ld (cli_data_sp), hl 
1e9a			 
1e9a				if DEBUG_FORTH_STACK_GUARD 
1e9a cd 9a 5a				call check_stacks 
1e9d					FORTH_CHK_DSP_UNDER 
1e9d e5				push hl 
1e9e d5				push de 
1e9f 2a ee e9			ld hl,(cli_data_sp) 
1ea2 11 28 e8			ld de, cli_data_stack 
1ea5 cd 10 0e			call cmp16 
1ea8 da ab 5b			jp c, fault_dsp_under 
1eab d1				pop de 
1eac e1				pop hl 
1ead				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ead				endif 
1ead			 
1ead e1				pop hl 
1eae			 
1eae c9				ret 
1eaf			 
1eaf			getwordathl: 
1eaf				; hl points to an address 
1eaf				; load hl with the word at that address 
1eaf			 
1eaf d5				push de 
1eb0			 
1eb0 5e				ld e, (hl) 
1eb1 23				inc hl 
1eb2 56				ld d, (hl) 
1eb3 eb				ex de, hl 
1eb4			 
1eb4 d1				pop de 
1eb5 c9				ret 
1eb6			 
1eb6			 
1eb6			 
1eb6			 
1eb6			 
1eb6			; eof 
1eb6			 
# End of file forth_stackopsv5.asm
1eb6			endif 
1eb6			 
1eb6			loadwordinhl:	 
1eb6			 
1eb6 d5				push de 
1eb7			 
1eb7 5e				ld e, (hl) 
1eb8 23				inc hl 
1eb9 56				ld d, (hl) 
1eba eb				ex de,hl  
1ebb			 
1ebb d1				pop de 
1ebc			 
1ebc c9				ret 
1ebd			 
1ebd			user_word_eol:  
1ebd				; hl contains the pointer to where to create a linked list item from the end 
1ebd				; of the user dict to continue on at the system word dict 
1ebd				 
1ebd				; poke the stub of the word list linked list to repoint to rom words 
1ebd			 
1ebd				; stub format 
1ebd				; db   word id 
1ebd				; dw    link to next word 
1ebd			        ; db char length of token 
1ebd				; db string + 0 term 
1ebd				; db exec code....  
1ebd			 
1ebd 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1ebf 77				ld (hl), a		; word id 
1ec0 23				inc hl 
1ec1			 
1ec1 11 8c 20			ld de, sysdict 
1ec4 73				ld (hl), e		; next word link ie system dict 
1ec5 23				inc hl 
1ec6 72				ld (hl), d		; next word link ie system dict 
1ec7 23				inc hl	 
1ec8			 
1ec8			;	ld (hl), sysdict		; next word link ie system dict 
1ec8			;	inc hl 
1ec8			;	inc hl 
1ec8			 
1ec8			;	inc hl 
1ec8			;	inc hl 
1ec8			 
1ec8 3e 02			ld a, 2			; word length is 0 
1eca 77				ld (hl), a	 
1ecb 23				inc hl 
1ecc			 
1ecc 3e 7e			ld a, '~'			; word length is 0 
1ece 77				ld (hl), a	 
1ecf 23				inc hl 
1ed0 3e 00			ld a, 0			; save empty word 
1ed2 77				ld (hl), a 
1ed3			 
1ed3 c9				ret 
1ed4			 
1ed4				 
1ed4			 
1ed4			forthexec_cleanup: 
1ed4				FORTH_RSP_POP 
1ed4 cd 41 1b			call macro_forth_rsp_pop 
1ed7				endm 
# End of macro FORTH_RSP_POP
1ed7 c9				ret 
1ed8			 
1ed8			forth_call_hl: 
1ed8				; taking hl 
1ed8 e5				push hl 
1ed9 c9				ret 
1eda			 
1eda			; this is called to reset Forth system but keep existing uwords etc 
1eda			 
1eda			forth_warmstart: 
1eda				; setup stack over/under flow checks 
1eda				if DEBUG_FORTH_STACK_GUARD 
1eda cd 80 5a				call chk_stk_init 
1edd				endif 
1edd			 
1edd				; init stack pointers  - * these stacks go upwards *  
1edd 21 ac e9			ld hl, cli_ret_stack 
1ee0 22 f2 e9			ld (cli_ret_sp), hl	 
1ee3				; set bottom of stack 
1ee3 3e 00			ld a,0 
1ee5 77				ld (hl),a 
1ee6 23				inc hl 
1ee7 77				ld (hl),a 
1ee8			 
1ee8 21 28 e8			ld hl, cli_data_stack 
1eeb 22 ee e9			ld (cli_data_sp), hl	 
1eee				; set bottom of stack 
1eee 3e 00			ld a,0 
1ef0 77				ld (hl),a 
1ef1 23				inc hl 
1ef2 77				ld (hl),a 
1ef3			 
1ef3 21 2a e9			ld hl, cli_loop_stack 
1ef6 22 f0 e9			ld (cli_loop_sp), hl	 
1ef9				; set bottom of stack 
1ef9 3e 00			ld a,0 
1efb 77				ld (hl),a 
1efc 23				inc hl 
1efd 77				ld (hl),a 
1efe			 
1efe				; init extent of current open file 
1efe			 
1efe 3e 00			ld a, 0 
1f00 32 6a ea			ld (store_openext), a 
1f03			 
1f03 c9				ret 
1f04			 
1f04			 
1f04			 
1f04			; Cold Start - this is called to setup the whole Forth system 
1f04			 
1f04			forth_init: 
1f04			 
1f04				; setup stack over/under flow checks 
1f04			 
1f04			;	if DEBUG_FORTH_STACK_GUARD 
1f04			;		call chk_stk_init 
1f04			;	endif 
1f04			 
1f04				; enable auto display updates (slow.....) 
1f04			 
1f04 3e 01			ld a, 1 
1f06 32 3c ea			ld (cli_autodisplay), a 
1f09			 
1f09				; if storage is in use disable long reads for now 
1f09 3e 00			ld a, 0 
1f0b 32 75 ea			ld (store_longread), a 
1f0e			 
1f0e			 
1f0e				; show start up screen 
1f0e			 
1f0e cd c5 0b			call clear_display 
1f11			 
1f11 3e 00			ld a,0 
1f13 32 5e ea			ld (f_cursor_ptr), a 
1f16			 
1f16				; set start of word list in start of ram - for use when creating user words 
1f16			 
1f16 21 95 5e			ld hl, baseram 
1f19 22 be e5			ld (os_last_new_uword), hl 
1f1c cd bd 1e			call user_word_eol 
1f1f				 
1f1f			;		call display_data_sp 
1f1f			;		call next_page_prompt 
1f1f			 
1f1f			 
1f1f			 
1f1f			 
1f1f c9				ret 
1f20			 
1f20 .. 00		.bootforth: db " Forth Kernel Init ",0 
1f34			 
1f34			; TODO push to stack 
1f34			 
1f34			;  
1f34			 
1f34			if FORTH_PARSEV2 
1f34			 
1f34			 
1f34				include "forth_parserv2.asm" 
1f34			 
1f34			endif 
1f34			 
1f34			 
1f34			; parse cli version 1 
1f34			 
1f34			if FORTH_PARSEV1 
1f34			 
1f34			 
1f34			 
1f34			      include "forth_parserv1.asm" 
1f34			endif 
1f34				 
1f34			if FORTH_PARSEV3 
1f34			 
1f34			 
1f34			 
1f34			      include "forth_parserv3.asm" 
1f34				include "forth_wordsv3.asm" 
1f34			endif 
1f34			 
1f34			if FORTH_PARSEV4 
1f34			 
1f34			 
1f34			 
1f34			      include "forth_parserv4.asm" 
1f34				include "forth_wordsv4.asm" 
1f34			endif 
1f34			 
1f34			if FORTH_PARSEV5 
1f34			 
1f34			 
1f34			 
1f34			      include "forth_parserv5.asm" 
1f34			 
1f34			 
1f34			; A better parser without using malloc and string copies all over the place.  
1f34			; Exec in situ should be faster 
1f34			 
1f34			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f34			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f34			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f34			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f34			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f34			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f34			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f34			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f34			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f34			 
1f34			; Core word preamble macro 
1f34			 
1f34			CWHEAD:   macro nxtword opcode lit len opflags 
1f34				db WORD_SYS_CORE+opcode             
1f34				; internal op code number 
1f34				dw nxtword            
1f34				; link to next dict word block 
1f34				db len + 1 
1f34				; literal length of dict word inc zero term 
1f34				db lit,0              
1f34				; literal dict word 
1f34			        ; TODO db opflags        
1f34				endm 
1f34			 
1f34			 
1f34			NEXTW: macro  
1f34				jp macro_next 
1f34				endm 
1f34			 
1f34			macro_next: 
1f34			if DEBUG_FORTH_PARSE_KEY 
1f34				DMARK "NXT" 
1f34				CALLMONITOR 
1f34			endif	 
1f34			;	inc hl  ; skip token null term  
1f34 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f38 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f3c 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f3f			if DEBUG_FORTH_PARSE_KEY 
1f3f				DMARK "}AA" 
1f3f				CALLMONITOR 
1f3f			endif	 
1f3f c3 42 20			jp execnext 
1f42				;jp exec1 
1f42			       
1f42			 
1f42			 
1f42			; Another go at the parser to compile  
1f42			 
1f42			 
1f42			; TODO rework parser to change all of the string words to byte tokens 
1f42			; TODO do a search for  
1f42			 
1f42			; TODO first run normal parser to zero term sections 
1f42			; TODO for each word do a token look up to get the op code 
1f42			; TODO need some means to flag to the exec that this is a byte code form    
1f42			 
1f42			 
1f42			forthcompile: 
1f42			 
1f42			; 
1f42			; line parse: 
1f42			;       parse raw input buffer 
1f42			;       tokenise the words 
1f42			;       malloc new copy (for looping etc) 
1f42			;       copy to malloc + current pc in line to start of string and add line term 
1f42			;       save on new rsp 
1f42			; 
1f42			 
1f42			; hl to point to the line to tokenise 
1f42			 
1f42			;	push hl 
1f42 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f45			 
1f45			;	ld a,0		; string term on input 
1f45			;	call strlent 
1f45			 
1f45			;	ld (os_tok_len), hl	 ; save string length 
1f45			 
1f45			;if DEBUG_FORTH_TOK 
1f45			;	ex de,hl		 
1f45			;endif 
1f45			 
1f45			;	pop hl 		; get back string pointer 
1f45			 
1f45			if DEBUG_FORTH_TOK 
1f45						DMARK "TOc" 
1f45				CALLMONITOR 
1f45			endif 
1f45 7e			.cptoken2:    ld a,(hl) 
1f46 23				inc hl 
1f47 fe 7f			cp FORTH_END_BUFFER 
1f49 28 29			jr z, .cptokendone2 
1f4b fe 00			cp 0 
1f4d 28 25			jr z, .cptokendone2 
1f4f fe 22			cp '"' 
1f51 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1f53 fe 20			cp ' ' 
1f55 20 ee			jr nz,  .cptoken2 
1f57			 
1f57			; TODO consume comments held between ( and ) 
1f57			 
1f57				; we have a space so change to zero term for dict match later 
1f57 2b				dec hl 
1f58 3e 00			ld a,0 
1f5a 77				ld (hl), a 
1f5b 23				inc hl 
1f5c 18 e7			jr .cptoken2 
1f5e				 
1f5e			 
1f5e			.cptokenstr2: 
1f5e				; skip all white space until either eol (because forgot to term) or end double quote 
1f5e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f5e				;inc hl ; skip current double quote 
1f5e 7e				ld a,(hl) 
1f5f 23				inc hl 
1f60 fe 22			cp '"' 
1f62 28 e1			jr z, .cptoken2 
1f64 fe 7f			cp FORTH_END_BUFFER 
1f66 28 0c			jr z, .cptokendone2 
1f68 fe 00			cp 0 
1f6a 28 08			jr z, .cptokendone2 
1f6c fe 20			cp ' ' 
1f6e 28 02			jr z, .cptmp2 
1f70 18 ec			jr .cptokenstr2 
1f72			 
1f72			.cptmp2:	; we have a space so change to zero term for dict match later 
1f72				;dec hl 
1f72				;ld a,"-"	; TODO remove this when working 
1f72				;ld (hl), a 
1f72				;inc hl 
1f72 18 ea			jr .cptokenstr2 
1f74			 
1f74			.cptokendone2: 
1f74				;inc hl 
1f74 3e 7f			ld a, FORTH_END_BUFFER 
1f76 77				ld (hl),a 
1f77 23				inc hl 
1f78 3e 21			ld a, '!' 
1f7a 77				ld (hl),a 
1f7b			 
1f7b 2a c2 e5			ld hl,(os_tok_ptr) 
1f7e			         
1f7e			if DEBUG_FORTH_TOK 
1f7e						DMARK "Tc1" 
1f7e				CALLMONITOR 
1f7e			endif 
1f7e			 
1f7e				; push exec string to top of return stack 
1f7e				FORTH_RSP_NEXT 
1f7e cd 20 1b			call macro_forth_rsp_next 
1f81				endm 
# End of macro FORTH_RSP_NEXT
1f81 c9				ret 
1f82			 
1f82			; Another go at the parser need to simplify the process 
1f82			 
1f82			forthparse: 
1f82			 
1f82			; 
1f82			; line parse: 
1f82			;       parse raw input buffer 
1f82			;       tokenise the words 
1f82			;       malloc new copy (for looping etc) 
1f82			;       copy to malloc + current pc in line to start of string and add line term 
1f82			;       save on new rsp 
1f82			; 
1f82			 
1f82			; hl to point to the line to tokenise 
1f82			 
1f82			;	push hl 
1f82 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f85			 
1f85			;	ld a,0		; string term on input 
1f85			;	call strlent 
1f85			 
1f85			;	ld (os_tok_len), hl	 ; save string length 
1f85			 
1f85			;if DEBUG_FORTH_TOK 
1f85			;	ex de,hl		 
1f85			;endif 
1f85			 
1f85			;	pop hl 		; get back string pointer 
1f85			 
1f85			if DEBUG_FORTH_TOK 
1f85						DMARK "TOK" 
1f85				CALLMONITOR 
1f85			endif 
1f85 7e			.ptoken2:    ld a,(hl) 
1f86 23				inc hl 
1f87 fe 7f			cp FORTH_END_BUFFER 
1f89 28 29			jr z, .ptokendone2 
1f8b fe 00			cp 0 
1f8d 28 25			jr z, .ptokendone2 
1f8f fe 22			cp '"' 
1f91 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1f93 fe 20			cp ' ' 
1f95 20 ee			jr nz,  .ptoken2 
1f97			 
1f97			; TODO consume comments held between ( and ) 
1f97			 
1f97				; we have a space so change to zero term for dict match later 
1f97 2b				dec hl 
1f98 3e 00			ld a,0 
1f9a 77				ld (hl), a 
1f9b 23				inc hl 
1f9c 18 e7			jr .ptoken2 
1f9e				 
1f9e			 
1f9e			.ptokenstr2: 
1f9e				; skip all white space until either eol (because forgot to term) or end double quote 
1f9e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f9e				;inc hl ; skip current double quote 
1f9e 7e				ld a,(hl) 
1f9f 23				inc hl 
1fa0 fe 22			cp '"' 
1fa2 28 e1			jr z, .ptoken2 
1fa4 fe 7f			cp FORTH_END_BUFFER 
1fa6 28 0c			jr z, .ptokendone2 
1fa8 fe 00			cp 0 
1faa 28 08			jr z, .ptokendone2 
1fac fe 20			cp ' ' 
1fae 28 02			jr z, .ptmp2 
1fb0 18 ec			jr .ptokenstr2 
1fb2			 
1fb2			.ptmp2:	; we have a space so change to zero term for dict match later 
1fb2				;dec hl 
1fb2				;ld a,"-"	; TODO remove this when working 
1fb2				;ld (hl), a 
1fb2				;inc hl 
1fb2 18 ea			jr .ptokenstr2 
1fb4			 
1fb4			.ptokendone2: 
1fb4				;inc hl 
1fb4 3e 7f			ld a, FORTH_END_BUFFER 
1fb6 77				ld (hl),a 
1fb7 23				inc hl 
1fb8 3e 21			ld a, '!' 
1fba 77				ld (hl),a 
1fbb			 
1fbb 2a c2 e5			ld hl,(os_tok_ptr) 
1fbe			         
1fbe			if DEBUG_FORTH_TOK 
1fbe						DMARK "TK1" 
1fbe				CALLMONITOR 
1fbe			endif 
1fbe			 
1fbe				; push exec string to top of return stack 
1fbe				FORTH_RSP_NEXT 
1fbe cd 20 1b			call macro_forth_rsp_next 
1fc1				endm 
# End of macro FORTH_RSP_NEXT
1fc1 c9				ret 
1fc2			 
1fc2			; 
1fc2			;	; malloc size + buffer pointer + if is loop flag 
1fc2			;	ld hl,(os_tok_len) 		 ; get string length 
1fc2			; 
1fc2			;	ld a,l 
1fc2			; 
1fc2			;	cp 0			; we dont want to use a null string 
1fc2			;	ret z 
1fc2			; 
1fc2			;;	add 3    ; prefix malloc with buffer for current word ptr 
1fc2			; 
1fc2			;	add 5     ; TODO when certain not over writing memory remove 
1fc2			; 
1fc2			;		 
1fc2			; 
1fc2			;if DEBUG_FORTH_TOK 
1fc2			;			DMARK "TKE" 
1fc2			;	CALLMONITOR 
1fc2			;endif 
1fc2			; 
1fc2			;	ld l,a 
1fc2			;	ld h,0 
1fc2			;;	push hl   ; save required space for the copy later 
1fc2			;	call malloc 
1fc2			;if DEBUG_FORTH_TOK 
1fc2			;			DMARK "TKM" 
1fc2			;	CALLMONITOR 
1fc2			;endif 
1fc2			;	if DEBUG_FORTH_MALLOC_GUARD 
1fc2			;		push af 
1fc2			;		call ishlzero 
1fc2			;;		ld a, l 
1fc2			;;		add h 
1fc2			;;		cp 0 
1fc2			;		pop af 
1fc2			;		 
1fc2			;		call z,malloc_error 
1fc2			;	endif 
1fc2			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1fc2			; 
1fc2			; 
1fc2			;if DEBUG_FORTH_TOK 
1fc2			;			DMARK "TKR" 
1fc2			;	CALLMONITOR 
1fc2			;endif 
1fc2			; 
1fc2			;	FORTH_RSP_NEXT 
1fc2			; 
1fc2			;	;inc hl	 ; go past current buffer pointer 
1fc2			;	;inc hl 
1fc2			;	;inc hl   ; and past if loop flag 
1fc2			;		; TODO Need to set flag  
1fc2			; 
1fc2			;	 
1fc2			;	 
1fc2			;	ex de,hl	; malloc is dest 
1fc2			;	ld hl, (os_tok_len) 
1fc2			;;	pop bc 
1fc2			;	ld c, l                
1fc2			;	ld b,0 
1fc2			;	ld hl, (os_tok_ptr) 
1fc2			; 
1fc2			;if DEBUG_FORTH_TOK 
1fc2			;			DMARK "TKT" 
1fc2			;	CALLMONITOR 
1fc2			;endif 
1fc2			; 
1fc2			;	; do str cpy 
1fc2			; 
1fc2			;	ldir      ; copy byte in hl to de 
1fc2			; 
1fc2			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1fc2			; 
1fc2			;if DEBUG_FORTH_TOK 
1fc2			; 
1fc2			;			DMARK "TKY" 
1fc2			;	CALLMONITOR 
1fc2			;endif 
1fc2			;	;ld a,0 
1fc2			;	;ld a,FORTH_END_BUFFER 
1fc2			;	ex de, hl 
1fc2			;	;dec hl			 ; go back over the space delim at the end of word 
1fc2			;	;ld (hl),a 
1fc2			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1fc2			;	ld a,FORTH_END_BUFFER 
1fc2			;	ld (hl),a 
1fc2			;	inc hl 
1fc2			;	ld a,FORTH_END_BUFFER 
1fc2			;	ld (hl),a 
1fc2			; 
1fc2			;	; init the malloc area data 
1fc2			;	; set pc for in current area 
1fc2			;	;ld hl, (os_tok_malloc) 
1fc2			;	;inc hl 
1fc2			;	;inc hl 
1fc2			;	;inc hl 
1fc2			;	;ex de,hl 
1fc2			;	;ld hl, (os_tok_malloc) 
1fc2			;	;ld (hl),e 
1fc2			;	;inc hl 
1fc2			;	;ld (hl),d 
1fc2			; 
1fc2			; 
1fc2			;	ld hl,(os_tok_malloc) 
1fc2			;if DEBUG_FORTH_PARSE_KEY 
1fc2			;			DMARK "TKU" 
1fc2			;	CALLMONITOR 
1fc2			;endif 
1fc2			; 
1fc2			;	ret 
1fc2			 
1fc2			forthexec: 
1fc2			 
1fc2			; line exec: 
1fc2			; forth parser 
1fc2			 
1fc2			; 
1fc2			;       get current exec line on rsp 
1fc2			 
1fc2				FORTH_RSP_TOS 
1fc2 cd 37 1b			call macro_forth_rsp_tos 
1fc5				endm 
# End of macro FORTH_RSP_TOS
1fc5			 
1fc5			;       restore current pc - hl points to malloc of data 
1fc5			 
1fc5				;ld e, (hl) 
1fc5				;inc hl 
1fc5				;ld d, (hl) 
1fc5				;ex de,hl 
1fc5			 
1fc5			 
1fc5			exec1: 
1fc5 22 c2 e5			ld (os_tok_ptr), hl 
1fc8			 
1fc8				; copy our PC to working vars  
1fc8 22 40 ea			ld (cli_ptr), hl 
1fcb 22 3e ea			ld (cli_origptr), hl 
1fce			 
1fce 7e				ld a,(hl) 
1fcf fe 7f			cp FORTH_END_BUFFER 
1fd1 c8				ret z 
1fd2			 
1fd2				; skip any nulls 
1fd2			 
1fd2 fe 00			cp 0 
1fd4 20 03			jr nz, .execword 
1fd6 23				inc hl 
1fd7 18 ec			jr exec1 
1fd9			 
1fd9			 
1fd9			.execword: 
1fd9			 
1fd9			 
1fd9			 
1fd9			if DEBUG_FORTH_PARSE_KEY 
1fd9						DMARK "KYQ" 
1fd9				CALLMONITOR 
1fd9			endif 
1fd9			;       while at start of word: 
1fd9			; get start of dict (in user area first) 
1fd9			 
1fd9 21 95 5e		ld hl, baseram 
1fdc			;ld hl, sysdict 
1fdc 22 42 ea		ld (cli_nextword),hl 
1fdf			;           match word at pc 
1fdf			;           exec word 
1fdf			;           or push to dsp 
1fdf			;           forward to next token 
1fdf			;           if line term pop rsp and exit 
1fdf			;        
1fdf			 
1fdf			if DEBUG_FORTH_PARSE_KEY 
1fdf						DMARK "KYq" 
1fdf				CALLMONITOR 
1fdf			endif 
1fdf			 
1fdf			; 
1fdf			; word comp 
1fdf			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1fdf			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1fdf			;    move to start of word  
1fdf			;    compare word to cli_token 
1fdf			 
1fdf			.execpnword:	; HL at start of a word in the dictionary to check 
1fdf			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1fdf			;	ld (cli_ptr), hl 
1fdf			 
1fdf 2a 42 ea			ld hl,(cli_nextword) 
1fe2			 
1fe2 cd 85 20			call forth_tok_next 
1fe5			; tok next start here 
1fe5			;	; TODO skip compiled symbol for now 
1fe5			;	inc hl 
1fe5			; 
1fe5			;	; save pointer to next word 
1fe5			; 
1fe5			;	; hl now points to the address of the next word pointer  
1fe5			;	ld e, (hl) 
1fe5			;	inc hl 
1fe5			;	ld d, (hl) 
1fe5			;	inc l 
1fe5			; 
1fe5			;	ex de,hl 
1fe5			;if DEBUG_FORTH_PARSE_NEXTWORD 
1fe5			;	push bc 
1fe5			;	ld bc, (cli_nextword) 
1fe5			;			DMARK "NXW" 
1fe5			;	CALLMONITOR 
1fe5			;	pop bc 
1fe5			;endif 
1fe5			; tok next end here 
1fe5 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
1fe8 eb				ex de, hl 
1fe9			 
1fe9			 
1fe9				; save the pointer of the current token - 1 to check against 
1fe9				 
1fe9 22 46 ea			ld (cli_token), hl   
1fec				; TODO maybe remove below save if no debug 
1fec				; save token string ptr for any debug later 
1fec 23				inc hl  
1fed 22 48 ea			ld (cli_origtoken), hl 
1ff0 2b				dec hl 
1ff1				; save pointer to the start of the next dictionay word 
1ff1 7e				ld a,(hl)   ; get string length 
1ff2 47				ld b,a 
1ff3			.execpnwordinc:  
1ff3 23				inc hl 
1ff4 10 fd			djnz .execpnwordinc 
1ff6 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
1ff9			 
1ff9				; now check the word token against the string being parsed 
1ff9			 
1ff9 2a 46 ea			ld hl,(cli_token) 
1ffc 23				inc hl     ; skip string length (use zero term instead to end) 
1ffd 22 46 ea			ld (cli_token), hl 
2000			 
2000			if DEBUG_FORTH_PARSE_KEY 
2000						DMARK "KY2" 
2000			endif 
2000			if DEBUG_FORTH_PARSE_EXEC 
2000				; see if disabled 
2000			 
2000			;	ld a, (os_view_disable) 
2000			;	cp '*' 
2000				ld a, (debug_vector) 
2000				cp $c9   ; RET  
2000				jr z, .skip 
2000			 
2000				push hl 
2000				push hl 
2000				call clear_display 
2000				ld de, .compword 
2000				ld a, display_row_1 
2000				call str_at_display 
2000				pop de 
2000				ld a, display_row_2 
2000				call str_at_display 
2000				ld hl,(cli_ptr) 
2000				ld a,(hl) 
2000			        ld hl, os_word_scratch 
2000				ld (hl),a 
2000				ld a,0 
2000				inc hl 
2000				ld (hl),a 	 
2000				ld de, os_word_scratch 
2000				ld a, display_row_2+10 
2000				call str_at_display 
2000				call update_display 
2000				ld a, 100 
2000				call aDelayInMS 
2000				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2000				call delay250ms 
2000				endif 
2000				pop hl 
2000			.skip:  
2000			endif	 
2000			.execpnchar:    ; compare char between token and string to parse 
2000			 
2000			if DEBUG_FORTH_PARSE_KEY 
2000						DMARK "Ky3" 
2000			endif 
2000			if DEBUG_FORTH_PARSE_EXEC 
2000				; see if disabled 
2000			 
2000			;	ld a, (os_view_disable) 
2000			;	cp '*' 
2000				ld a, (debug_vector) 
2000				cp $C9  ; RET 
2000				jr z, .skip2 
2000			 
2000			;	call clear_display 
2000			ld hl,(cli_token) 
2000			ld a,(hl) 
2000			ld (os_word_scratch),a 
2000				ld hl,(cli_ptr) 
2000			ld a,(hl) 
2000				ld (os_word_scratch+1),a 
2000				ld a,0 
2000				ld (os_word_scratch+2),a 
2000				ld de,os_word_scratch 
2000				ld a,display_row_4 
2000				call str_at_display 
2000				call update_display 
2000			.skip2:  
2000			endif 
2000 2a 46 ea			ld hl,(cli_token) 
2003 7e				ld a, (hl)	 ; char in word token 
2004 23				inc hl 		; move to next char 
2005 22 46 ea			ld (cli_token), hl ; and save it 
2008 47				ld b,a 
2009			 
2009 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
200c 7e				ld a,(hl) 
200d 23				inc hl 
200e 22 40 ea			ld (cli_ptr), hl		; move to next char 
2011 cd 4f 11			call toUpper 		; make sure the input string matches case 
2014			 
2014			if DEBUG_FORTH_PARSE 
2014			endif 
2014			 
2014				; input stream end of token is a space so get rid of it 
2014			 
2014			;	cp ' ' 
2014			;	jr nz, .pnskipspace 
2014			; 
2014			;	ld a, 0		; make same term as word token term 
2014			; 
2014			;.pnskipspace: 
2014			 
2014			if DEBUG_FORTH_PARSE_KEY 
2014						DMARK "KY7" 
2014			endif 
2014 b8				cp b 
2015 c2 2b 20			jp nz, .execpnskipword	 ; no match so move to next word 
2018				 
2018			;    if same 
2018			;       scan for string terms 0 for token and 32 for input 
2018			 
2018				 
2018			if DEBUG_FORTH_PARSE_KEY 
2018						DMARK "KY8" 
2018			endif 
2018			 
2018 80				add b			 
2019 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
201b							; TODO need to make sure last word in zero term string is accounted for 
201b 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
201d			 
201d			 
201d				; at end of both strings so both are exact match 
201d			 
201d			;       skip ptr for next word 
201d			 
201d 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
2020 23				inc hl			 ; at next char 
2021 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
2024 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2027				 
2027				 
2027			if DEBUG_FORTH_PARSE_KEY 
2027						DMARK "KY3" 
2027			endif 
2027			 
2027			 
2027			 
2027			;       exec code block 
2027			if DEBUG_FORTH_JP 
2027				call clear_display 
2027				call update_display 
2027				call delay1s 
2027				ld hl, (cli_execword)     ; save for next check if no match on this word 
2027				ld a,h 
2027				ld hl, os_word_scratch 
2027				call hexout 
2027				ld hl, (cli_execword)     ; save for next check if no match on this word 
2027				ld a,l 
2027				ld hl, os_word_scratch+2 
2027				call hexout 
2027				ld hl, os_word_scratch+4 
2027				ld a,0 
2027				ld (hl),a 
2027				ld de,os_word_scratch 
2027				call str_at_display 
2027					ld a, display_row_2 
2027					call str_at_display 
2027				ld de, (cli_origtoken) 
2027				ld a, display_row_1+10 
2027					call str_at_display 
2027			 
2027				ld a,display_row_1 
2027				ld de, .foundword 
2027				ld a, display_row_3 
2027				call str_at_display 
2027				call update_display 
2027				call delay1s 
2027				call delay1s 
2027				call delay1s 
2027			endif 
2027			 
2027			if DEBUG_FORTH_PARSE_KEY 
2027						DMARK "KYj" 
2027			endif 
2027				; TODO save the word pointer in this exec 
2027			 
2027 2a 44 ea			ld hl,(cli_execword) 
202a e9				jp (hl) 
202b			 
202b			 
202b			;    if not same 
202b			;	scan for zero term 
202b			;	get ptr for next word 
202b			;	goto word comp 
202b			 
202b			.execpnskipword:	; get pointer to next word 
202b 2a 42 ea			ld hl,(cli_nextword) 
202e			 
202e 7e				ld a,(hl) 
202f fe 00			cp WORD_SYS_END 
2031			;	cp 0 
2031 28 09			jr z, .execendofdict			 ; at end of words 
2033			 
2033			if DEBUG_FORTH_PARSE_KEY 
2033						DMARK "KY4" 
2033			endif 
2033			if DEBUG_FORTH_PARSE_EXEC 
2033			 
2033				; see if disabled 
2033			 
2033			;	ld a, (os_view_disable) 
2033			;	cp '*' 
2033				ld a,(debug_vector) 
2033				cp $c9   ; RET 
2033				jr z, .noskip 
2033			 
2033			 
2033				ld de, .nowordfound 
2033				ld a, display_row_3 
2033				call str_at_display 
2033				call update_display 
2033				ld a, 100 
2033				call aDelayInMS 
2033				 
2033				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2033					call delay250ms 
2033				endif 
2033			.noskip:  
2033			 
2033			endif	 
2033			 
2033 2a 3e ea			ld hl,(cli_origptr) 
2036 22 40 ea			ld (cli_ptr),hl 
2039			 
2039			if DEBUG_FORTH_PARSE_KEY 
2039						DMARK "KY5" 
2039			endif 
2039 c3 df 1f			jp .execpnword			; else go to next word 
203c			 
203c			.execendofdict:  
203c			 
203c			if DEBUG_FORTH_PARSE_KEY 
203c						DMARK "KYe" 
203c			endif 
203c			if DEBUG_FORTH_PARSE_EXEC 
203c				; see if disabled 
203c			 
203c			;	ld a, (os_view_disable) 
203c			;	cp '*' 
203c				ld a,(debug_vector) 
203c				cp $c9   ; ret 
203c				jr z, .ispskip 
203c			 
203c				call clear_display 
203c				call update_display 
203c				call delay1s 
203c				ld de, (cli_origptr) 
203c				ld a, display_row_1 
203c				call str_at_display 
203c				 
203c				ld de, .enddict 
203c				ld a, display_row_3 
203c				call str_at_display 
203c				call update_display 
203c				ld a, 100 
203c				call aDelayInMS 
203c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
203c				call delay1s 
203c				call delay1s 
203c				call delay1s 
203c				endif 
203c			.ispskip:  
203c				 
203c			endif	 
203c			 
203c			 
203c			 
203c				; if the word is not a keyword then must be a literal so push it to stack 
203c			 
203c			; push token to stack to end of word 
203c			 
203c				STACKFRAME ON $1efe $2f9f 
203c				if DEBUG_STACK_IMB 
203c					if ON 
203c						exx 
203c						ld de, $1efe 
203c						ld a, d 
203c						ld hl, curframe 
203c						call hexout 
203c						ld a, e 
203c						ld hl, curframe+2 
203c						call hexout 
203c						ld hl, $1efe 
203c						push hl 
203c						ld hl, $2f9f 
203c						push hl 
203c						exx 
203c					endif 
203c				endif 
203c			endm 
# End of macro STACKFRAME
203c			 
203c 2a c2 e5		ld hl,(os_tok_ptr) 
203f cd e2 1c		call forth_apush 
2042			 
2042				STACKFRAMECHK ON $1efe $2f9f 
2042				if DEBUG_STACK_IMB 
2042					if ON 
2042						exx 
2042						ld hl, $2f9f 
2042						pop de   ; $2f9f 
2042						call cmp16 
2042						jr nz, .spnosame 
2042						ld hl, $1efe 
2042						pop de   ; $1efe 
2042						call cmp16 
2042						jr z, .spfrsame 
2042						.spnosame: call showsperror 
2042						.spfrsame: nop 
2042						exx 
2042					endif 
2042				endif 
2042			endm 
# End of macro STACKFRAMECHK
2042			 
2042			execnext: 
2042			 
2042			if DEBUG_FORTH_PARSE_KEY 
2042						DMARK "KY>" 
2042			endif 
2042			; move past token to next word 
2042			 
2042 2a c2 e5		ld hl, (os_tok_ptr) 
2045 3e 00		ld a, 0 
2047 01 ff 00		ld bc, 255     ; input buffer size 
204a ed b1		cpir 
204c			 
204c			if DEBUG_FORTH_PARSE_KEY 
204c						DMARK "KY!" 
204c				CALLMONITOR 
204c			endif	 
204c			; TODO this might place hl on the null, so will need to forward on??? 
204c			;inc hl   ; see if this gets onto the next item 
204c			 
204c			 
204c			; TODO pass a pointer to the buffer to push 
204c			; TODO call function to push 
204c			 
204c			; look for end of input 
204c			 
204c			;inc hl 
204c			;ld a,(hl) 
204c			;cp FORTH_END_BUFFER 
204c			;ret z 
204c			 
204c			 
204c c3 c5 1f		jp exec1 
204f			 
204f			 
204f			 
204f			 
204f			 
204f			 
204f			 
204f			 
204f			 
204f			findnexttok: 
204f			 
204f				; hl is pointer to move 
204f				; de is the token to locate 
204f			 
204f					if DEBUG_FORTH 
204f						DMARK "NTK" 
204f						CALLMONITOR 
204f					endif 
204f d5				push de 
2050			 
2050			.fnt1:	 
2050				; find first char of token to locate 
2050			 
2050 1a				ld a, (de) 
2051 4f				ld c,a 
2052 7e				ld a,(hl) 
2053 cd 4f 11			call toUpper 
2056					if DEBUG_FORTH 
2056						DMARK "NT1" 
2056						CALLMONITOR 
2056					endif 
2056 b9				cp c 
2057			 
2057 28 03			jr z, .fnt2cmpmorefirst	 
2059			 
2059				; first char not found move to next char 
2059			 
2059 23				inc hl 
205a 18 f4			jr .fnt1 
205c			 
205c			.fnt2cmpmorefirst:	 
205c				; first char of token found.  
205c			 
205c e5				push hl     ; save start of token just in case it is the right one 
205d d9				exx 
205e e1				pop hl        ; save it to hl' 
205f d9				exx 
2060			 
2060			 
2060			.fnt2cmpmore:	 
2060				; compare the rest 
2060				 
2060 23				inc hl 
2061 13				inc de 
2062				 
2062 1a				ld a, (de) 
2063 4f				ld c,a 
2064 7e				ld a,(hl) 
2065 cd 4f 11			call toUpper 
2068			 
2068					if DEBUG_FORTH 
2068						DMARK "NT2" 
2068						CALLMONITOR 
2068					endif 
2068				; c has the token to find char 
2068				; a has the mem to scan char 
2068			 
2068 b9				cp c 
2069 28 04			jr z,.fntmatch1 
206b			 
206b				; they are not the same 
206b			 
206b					if DEBUG_FORTH 
206b						DMARK "NT3" 
206b						CALLMONITOR 
206b					endif 
206b d1				pop de	; reset de token to look for 
206c d5				push de 
206d 18 e1			jr .fnt1 
206f				 
206f			.fntmatch1: 
206f			 
206f				; is the same char a null which means we might have a full hit? 
206f					if DEBUG_FORTH 
206f						DMARK "NT4" 
206f						CALLMONITOR 
206f					endif 
206f			 
206f fe 00			cp 0 
2071 28 0b			jr z, .fntmatchyes 
2073			 
2073				; are we at the end of the token to find? 
2073			 
2073					if DEBUG_FORTH 
2073						DMARK "NT5" 
2073						CALLMONITOR 
2073					endif 
2073 3e 00			ld a, 0 
2075 b9				cp c 
2076			 
2076 c2 60 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2079			 
2079					if DEBUG_FORTH 
2079						DMARK "NT6" 
2079						CALLMONITOR 
2079					endif 
2079				; token to find is exhusted but no match to stream 
2079			 
2079				; restore tok pointer and continue on 
2079 d1				pop de 
207a d5				push de 
207b c3 50 20			jp .fnt1 
207e			 
207e			 
207e			.fntmatchyes: 
207e			 
207e				; hl now contains the end of the found token 
207e			 
207e				; get rid of saved token pointer to find 
207e			 
207e d1				pop de 
207f			 
207f					if DEBUG_FORTH 
207f						DMARK "NT9" 
207f						CALLMONITOR 
207f					endif 
207f			 
207f				; hl will be on the null term so forward on 
207f			 
207f				; get back the saved start of the token 
207f			 
207f d9				exx 
2080 e5				push hl     ; save start of token just in case it is the right one 
2081 d9				exx 
2082 e1				pop hl        ; save it to hl 
2083			 
2083 c9				ret 
2084			 
2084			 
2084			; LIST needs to find a specific token   
2084			; FORGET needs to find a spefici token 
2084			 
2084			; SAVE needs to find all tokens by flag 
2084			; WORDS just needs to scan through all  by flag 
2084			; UWORDS needs to scan through all by flag 
2084			 
2084			 
2084			; given hl as pointer to start of dict look up string 
2084			; return hl as pointer to start of word block 
2084			; or 0 if not found 
2084			 
2084			forth_find_tok: 
2084 c9				ret 
2085			 
2085			; given hl as pointer to dict structure 
2085			; move to the next dict block structure 
2085			 
2085			forth_tok_next: 
2085				; hl now points to the address of the next word pointer  
2085				; TODO skip compiled symbol for now 
2085			;	push de 
2085 23				inc hl 
2086 5e				ld e, (hl) 
2087 23				inc hl 
2088 56				ld d, (hl) 
2089 23				inc hl 
208a			 
208a eb				ex de,hl 
208b			if DEBUG_FORTH_PARSE_NEXTWORD 
208b				push bc 
208b				ld bc, (cli_nextword) 
208b						DMARK "NXW" 
208b				CALLMONITOR 
208b				pop bc 
208b			endif 
208b			;	pop de	 
208b c9				ret 
208c			 
208c			 
208c			 
208c			; eof 
# End of file forth_parserv5.asm
208c				include "forth_wordsv4.asm" 
208c			 
208c			; the core word dictionary v4 
208c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
208c			 
208c			; this is a linked list for each of the system words used 
208c			; user defined words will follow the same format but will be in ram 
208c			 
208c			 
208c			; 
208c			; 
208c			; define linked list: 
208c			; 
208c			; 1. compiled byte op code 
208c			; 2. len of text word 
208c			; 3. text word 
208c			; 4. ptr to next dictionary word 
208c			; 5. asm, calls etc for the word 
208c			; 
208c			;  if 1 == 0 then last word in dict  
208c			;   
208c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
208c			;  
208c			;  
208c			; create basic standard set of words 
208c			; 
208c			;  
208c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
208c			; 2DUP 2DROP 2SWAP  
208c			; @ C@ - get byte  
208c			; ! C! - store byte 
208c			; 0< true if less than zero 
208c			; 0= true if zero 
208c			; < >  
208c			; = true if same 
208c			; variables 
208c			 
208c			 
208c			; Hardware specific words I may need 
208c			; 
208c			; IN OUT  
208c			; calls to key util functions 
208c			; calls to hardward abstraction stuff 
208c			; easy control of frame buffers and lcd i/o 
208c			; keyboard  
208c			 
208c			 
208c			;DICT: macro 
208c			; op_code, len, word, next 
208c			;    word: 
208c			;    db op_code 
208c			;    ds word zero term 
208c			;    dw next 
208c			;    endm 
208c			 
208c			 
208c			 
208c			 
208c			; op code 1 is a flag for user define words which are to be handled differently 
208c			 
208c			 
208c			; 
208c			; 
208c			;    TODO on entry to a word this should be the expected environment 
208c			;    hl - tos value if number then held, if string this is the ptr 
208c			;    de -  
208c			 
208c			 
208c			; opcode ranges 
208c			; 0 - end of word dict 
208c			; 255 - user define words 
208c			 
208c			sysdict: 
208c			include "forth_opcodes.asm" 
208c			; op codes for forth keywords 
208c			; free to use code 0  
208c				OPCODE_HEAP: equ  1 
208c				OPCODE_EXEC: equ 2 
208c				OPCODE_DUP: equ 3 
208c				OPCODE_SWAP: equ 4 
208c				OPCODE_COLN: equ 5 
208c				OPCODE_SCOLN: equ 6 
208c				OPCODE_DROP: equ 7 
208c				OPCODE_DUP2: equ 8 
208c				OPCODE_DROP2: equ 9 
208c				OPCODE_SWAP2: equ 10 
208c				OPCODE_AT: equ 11 
208c				OPCODE_CAT: equ 12 
208c				OPCODE_BANG: equ 13 
208c				OPCODE_CBANG: equ 14 
208c				OPCODE_SCALL: equ 15 
208c				OPCODE_DEPTH: equ 16 
208c				OPCODE_OVER: equ 17 
208c				OPCODE_PAUSE: equ 18 
208c				OPCODE_PAUSES: equ 19 
208c				OPCODE_ROT: equ 20 
208c			;free to reuse	OPCODE_WORDS: equ 21 
208c			        OPCODE_NOT: equ 21 
208c				OPCODE_UWORDS: equ 22 
208c				OPCODE_BP: equ 23 
208c				OPCODE_MONITOR: equ 24  
208c				OPCODE_MALLOC: equ 25 
208c				OPCODE_FREE: equ 26 
208c				OPCODE_LIST: equ 27 
208c				OPCODE_FORGET: equ 28 
208c				OPCODE_NOP: equ 29 
208c				OPCODE_COMO: equ 30 
208c				OPCODE_COMC: equ 31 
208c			;free to reuse	OPCODE_ENDCORE: equ 32 
208c				OPCODE_AFTERSOUND: equ 33 
208c				OPCODE_GP2: equ 34 
208c				OPCODE_GP3: equ 35 
208c				OPCODE_GP4: equ 36 
208c				OPCODE_SIN: equ 37 
208c				OPCODE_SOUT: equ 38 
208c				OPCODE_SPIO: equ 39 
208c				OPCODE_SPICEH: equ 40 
208c				OPCODE_SPIOb: equ 41 
208c				OPCODE_SPII: equ 42 
208c				OPCODE_SESEL: equ 43 
208c				OPCODE_CARTDEV: equ 44 
208c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
208c				OPCODE_FB: equ 46 
208c				OPCODE_EMIT: equ 47 
208c				OPCODE_DOTH: equ 48 
208c				OPCODE_DOTF: equ 49 
208c				OPCODE_DOT: equ 50 
208c				OPCODE_CLS: equ 51 
208c				OPCODE_DRAW: equ 52 
208c				OPCODE_DUMP: equ 53 
208c				OPCODE_CDUMP: equ 54 
208c				OPCODE_DAT: equ 55 
208c				OPCODE_HOME: equ 56 
208c				OPCODE_SPACE: equ 57 
208c				OPCODE_SPACES: equ 58 
208c				OPCODE_SCROLL: equ 59 
208c				OPCODE_ATQ: equ 60 
208c				OPCODE_AUTODSP: equ 61 
208c				OPCODE_MENU: equ 62 
208c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
208c				OPCODE_THEN: equ 64 
208c				OPCODE_ELSE: equ 65 
208c				OPCODE_DO: equ 66 
208c				OPCODE_LOOP: equ 67 
208c				OPCODE_I: equ 68 
208c				OPCODE_DLOOP: equ 69  
208c				OPCODE_REPEAT: equ 70  
208c				OPCODE_UNTIL: equ 71 
208c				OPCODE_ENDFLOW: equ 72 
208c				OPCODE_WAITK: equ 73 
208c				OPCODE_ACCEPT: equ 74 
208c				OPCODE_EDIT: equ 75 
208c			;free to reuse	OPCODE_ENDKEY: equ 76 
208c				OPCODE_LZERO: equ 77 
208c				OPCODE_TZERO: equ 78 
208c				OPCODE_LESS: equ 79 
208c				OPCODE_GT: equ 80 
208c				OPCODE_EQUAL: equ 81  
208c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
208c				OPCODE_NEG: equ 83 
208c				OPCODE_DIV: equ 84 
208c				OPCODE_MUL: equ 85 
208c				OPCODE_MIN: equ 86 
208c				OPCODE_MAX: equ 87 
208c				OPCODE_RND16: equ 88 
208c				OPCODE_RND8: equ 89 
208c				OPCODE_RND: equ 90 
208c			;free to reuse	OPCODE_ENDMATHS: equ 91  
208c				OPCODE_BYNAME: equ 92 
208c				OPCODE_DIR: equ 93 
208c				OPCODE_SAVE: equ 94 
208c				OPCODE_LOAD: equ 95 
208c				OPCODE_BSAVE: equ 96 
208c				OPCODE_BLOAD: equ 97 
208c				OPCODE_SEO: equ 98  
208c				OPCODE_SEI: equ 99 
208c				OPCODE_SFREE: equ 100 
208c				OPCODE_SIZE: equ 101 
208c				OPCODE_CREATE: equ 102 
208c				OPCODE_APPEND: equ 103 
208c				OPCODE_SDEL: equ 104 
208c				OPCODE_OPEN: equ 105 
208c				OPCODE_READ: equ 106 
208c				OPCODE_EOF: equ 106 
208c				OPCODE_FORMAT: equ 107 
208c				OPCODE_LABEL: equ 108 
208c				OPCODE_LABELS: equ 109 
208c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
208c				OPCODE_UPPER: equ 111 
208c				OPCODE_LOWER: equ 112 
208c				OPCODE_SUBSTR: equ 113 
208c				OPCODE_LEFT: equ 114 
208c				OPCODE_RIGHT: equ 115 
208c				OPCODE_STR2NUM: equ 116 
208c				OPCODE_NUM2STR: equ 117 
208c				OPCODE_CONCAT: equ 118 
208c				OPCODE_FIND: equ 119 
208c				OPCODE_LEN: equ 120 
208c				OPCODE_CHAR: equ 121 
208c			; free to reuse	OPCODE_STRLEN: equ 122 
208c			; free to reuse	OPCODE_ENDSTR: equ 123 
208c				OPCODE_V0S: equ 124 
208c				OPCODE_V0Q: equ 125 
208c				OPCODE_V1S: equ 126 
208c				OPCODE_V1Q: equ 127 
208c				OPCODE_V2S: equ 128 
208c				OPCODE_V2Q: equ 129 
208c				OPCODE_V3S: equ 130 
208c				OPCODE_V3Q: equ 131 
208c			;free to reuse	OPCODE_END: equ 132 
208c				OPCODE_ZDUP: equ 133 
208c			 
208c			; eof 
# End of file forth_opcodes.asm
208c			 
208c			include "forth_words_core.asm" 
208c			 
208c			; | ## Core Words 
208c			 
208c			;if MALLOC_4 
208c			 
208c			.HEAP: 
208c			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
208c 15				db WORD_SYS_CORE+OPCODE_HEAP             
208d cb 20			dw .EXEC            
208f 05				db 4 + 1 
2090 .. 00			db "HEAP",0              
2095				endm 
# End of macro CWHEAD
2095			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2095			; | | u1 - Current number of bytes in the heap 
2095			; | | u2 - Remaining bytes left on the heap 
2095			; | |  
2095			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2095			 
2095			 
2095				if DEBUG_FORTH_WORDS_KEY 
2095					DMARK "HEP" 
2095 f5				push af  
2096 3a aa 20			ld a, (.dmark)  
2099 32 6b ee			ld (debug_mark),a  
209c 3a ab 20			ld a, (.dmark+1)  
209f 32 6c ee			ld (debug_mark+1),a  
20a2 3a ac 20			ld a, (.dmark+2)  
20a5 32 6d ee			ld (debug_mark+2),a  
20a8 18 03			jr .pastdmark  
20aa ..			.dmark: db "HEP"  
20ad f1			.pastdmark: pop af  
20ae			endm  
# End of macro DMARK
20ae					CALLMONITOR 
20ae cd 6f ee			call debug_vector  
20b1				endm  
# End of macro CALLMONITOR
20b1				endif 
20b1 2a 9f 5e			ld hl, (free_list )      
20b4 11 a4 5e			ld de, heap_start 
20b7			 
20b7 ed 52			sbc hl, de  
20b9			 
20b9 cd 79 1b			call forth_push_numhl 
20bc			 
20bc			 
20bc ed 5b 9f 5e		ld de, (free_list )      
20c0 21 9c e2			ld hl, heap_end 
20c3			 
20c3 ed 52			sbc hl, de 
20c5			 
20c5 cd 79 1b			call forth_push_numhl 
20c8				 
20c8			 
20c8				 
20c8			 
20c8			 
20c8			 
20c8				NEXTW 
20c8 c3 34 1f			jp macro_next 
20cb				endm 
# End of macro NEXTW
20cb			;endif 
20cb			 
20cb			.EXEC: 
20cb			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
20cb			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
20cb			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
20cb			;; > > 
20cb			;; > >   
20cb			;	STACKFRAME OFF $5efe $5f9f 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS_KEY 
20cb			;			DMARK "EXE" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			; 
20cb			;	FORTH_DSP_VALUEHL 
20cb			; 
20cb			;	FORTH_DSP_POP 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX1" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;;	ld e,(hl) 
20cb			;;	inc hl 
20cb			;;	ld d,(hl) 
20cb			;;	ex de,hl 
20cb			; 
20cb			;;		if DEBUG_FORTH_WORDS 
20cb			;;			DMARK "EX2" 
20cb			;;			CALLMONITOR 
20cb			;;		endif 
20cb			;	push hl 
20cb			; 
20cb			;	;ld a, 0 
20cb			;	;ld a, FORTH_END_BUFFER 
20cb			;	call strlenz 
20cb			;	inc hl   ; include zero term to copy 
20cb			;	inc hl   ; include term 
20cb			;	inc hl   ; include term 
20cb			;	ld b,0 
20cb			;	ld c,l 
20cb			;	pop hl 
20cb			;	ld de, execscratch 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX3" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	ldir 
20cb			; 
20cb			; 
20cb			;	ld hl, execscratch 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EXe" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			; 
20cb			;	call forthparse 
20cb			;	call forthexec 
20cb			;;	call forthexec_cleanup 
20cb			;;	call forthparse 
20cb			;;	call forthexec 
20cb			; 
20cb			;	STACKFRAMECHK OFF $5efe $5f9f 
20cb			; 
20cb			;	; an immediate word so no need to process any more words 
20cb			;	ret 
20cb			;	NEXTW 
20cb			 
20cb			; dead code - old version  
20cb			;	FORTH_RSP_NEXT 
20cb			 
20cb			;  
20cb			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
20cb			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
20cb			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
20cb			;	push hl 
20cb			;	push de 
20cb			;	push bc 
20cb			; 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS_KEY 
20cb			;			DMARK "EXR" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			; 
20cb			; 
20cb			; 
20cb			;	;v5 FORTH_DSP_VALUE 
20cb			;	FORTH_DSP_VALUEHL 
20cb			; 
20cb			;	; TODO do string type checks 
20cb			; 
20cb			;;v5	inc hl   ; skip type 
20cb			; 
20cb			;	push hl  ; source code  
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX1" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	ld a, 0 
20cb			;	call strlent 
20cb			; 
20cb			;	inc hl 
20cb			;	inc hl 
20cb			;	inc hl 
20cb			;	inc hl 
20cb			; 
20cb			;	push hl    ; size 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX2" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	call malloc 
20cb			; 
20cb			;	ex de, hl    ; de now contains malloc area 
20cb			;	pop bc   	; get byte count 
20cb			;	pop hl      ; get string to copy 
20cb			; 
20cb			;	push de     ; save malloc for free later 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX3" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	ldir       ; duplicate string 
20cb			; 
20cb			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
20cb			;	 
20cb			;	; TODO fix the parse would be better than this...  
20cb			;	ex de, hl 
20cb			;	dec hl 
20cb			;	ld a, 0 
20cb			;	ld (hl), a 
20cb			;	dec hl 
20cb			;	ld a, ' ' 
20cb			;	ld (hl), a 
20cb			;	dec hl 
20cb			;	ld (hl), a 
20cb			; 
20cb			;	dec hl 
20cb			;	ld (hl), a 
20cb			; 
20cb			; 
20cb			;	FORTH_DSP_POP  
20cb			; 
20cb			;	pop hl     
20cb			;	push hl    ; save malloc area 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX4" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			; 
20cb			;	call forthparse 
20cb			;	call forthexec 
20cb			;	 
20cb			;	pop hl 
20cb			;	if DEBUG_FORTH_WORDS 
20cb			;		DMARK "EX5" 
20cb			;		CALLMONITOR 
20cb			;	endif 
20cb			; 
20cb			;	if FORTH_ENABLE_FREE 
20cb			;	call free 
20cb			;	endif 
20cb			; 
20cb			;	if DEBUG_FORTH_WORDS 
20cb			;		DMARK "EX6" 
20cb			;		CALLMONITOR 
20cb			;	endif 
20cb			; 
20cb			;	pop bc 
20cb			;	pop de 
20cb			;	pop hl 
20cb			;;	FORTH_RSP_POP	  
20cb			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
20cb			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
20cb			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
20cb			; 
20cb			;	if DEBUG_FORTH_WORDS 
20cb			;		DMARK "EX7" 
20cb			;		CALLMONITOR 
20cb			;	endif 
20cb			;	NEXTW 
20cb			 
20cb			;.STKEXEC: 
20cb			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
20cb			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
20cb			; 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS_KEY 
20cb			;			DMARK "STX" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			; 
20cb			;	FORTH_DSP_VALUEHL 
20cb			; 
20cb			;	ld (store_tmp1), hl    ; count 
20cb			; 
20cb			;	FORTH_DSP_POP 
20cb			;.stkexec1: 
20cb			;	ld hl, (store_tmp1)   ; count 
20cb			;	ld a, 0 
20cb			;	cp l 
20cb			;	ret z 
20cb			; 
20cb			;	dec hl 
20cb			;	ld (store_tmp1), hl    ; count 
20cb			;	 
20cb			;	FORTH_DSP_VALUEHL 
20cb			;	push hl 
20cb			;	 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EXp" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	FORTH_DSP_POP 
20cb			; 
20cb			;	call strlenz 
20cb			;	inc hl   ; include zero term to copy 
20cb			;	inc hl   ; include zero term to copy 
20cb			;	inc hl   ; include zero term to copy 
20cb			;	ld b,0 
20cb			;	ld c,l 
20cb			;	pop hl 
20cb			;	ld de, execscratch 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX3" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	ldir 
20cb			; 
20cb			; 
20cb			;	ld hl, execscratch 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EXP" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			; 
20cb			;	call forthparse 
20cb			;	ld hl, execscratch 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EXx" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	call forthexec 
20cb			; 
20cb			;	jp .stkexec1 
20cb			; 
20cb			;	ret 
20cb			 
20cb			 
20cb			.DUP: 
20cb			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
20cb 17				db WORD_SYS_CORE+OPCODE_DUP             
20cc 41 21			dw .ZDUP            
20ce 04				db 3 + 1 
20cf .. 00			db "DUP",0              
20d3				endm 
# End of macro CWHEAD
20d3			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
20d3			 
20d3				if DEBUG_FORTH_WORDS_KEY 
20d3					DMARK "DUP" 
20d3 f5				push af  
20d4 3a e8 20			ld a, (.dmark)  
20d7 32 6b ee			ld (debug_mark),a  
20da 3a e9 20			ld a, (.dmark+1)  
20dd 32 6c ee			ld (debug_mark+1),a  
20e0 3a ea 20			ld a, (.dmark+2)  
20e3 32 6d ee			ld (debug_mark+2),a  
20e6 18 03			jr .pastdmark  
20e8 ..			.dmark: db "DUP"  
20eb f1			.pastdmark: pop af  
20ec			endm  
# End of macro DMARK
20ec					CALLMONITOR 
20ec cd 6f ee			call debug_vector  
20ef				endm  
# End of macro CALLMONITOR
20ef				endif 
20ef			 
20ef				FORTH_DSP 
20ef cd 44 1d			call macro_forth_dsp 
20f2				endm 
# End of macro FORTH_DSP
20f2			 
20f2 7e				ld a, (HL) 
20f3 fe 01			cp DS_TYPE_STR 
20f5 20 25			jr nz, .dupinum 
20f7			 
20f7				; push another string 
20f7			 
20f7				FORTH_DSP_VALUEHL     		 
20f7 cd 7e 1d			call macro_dsp_valuehl 
20fa				endm 
# End of macro FORTH_DSP_VALUEHL
20fa			 
20fa			if DEBUG_FORTH_WORDS 
20fa				DMARK "DUs" 
20fa f5				push af  
20fb 3a 0f 21			ld a, (.dmark)  
20fe 32 6b ee			ld (debug_mark),a  
2101 3a 10 21			ld a, (.dmark+1)  
2104 32 6c ee			ld (debug_mark+1),a  
2107 3a 11 21			ld a, (.dmark+2)  
210a 32 6d ee			ld (debug_mark+2),a  
210d 18 03			jr .pastdmark  
210f ..			.dmark: db "DUs"  
2112 f1			.pastdmark: pop af  
2113			endm  
# End of macro DMARK
2113				CALLMONITOR 
2113 cd 6f ee			call debug_vector  
2116				endm  
# End of macro CALLMONITOR
2116			endif 
2116 cd e7 1b			call forth_push_str 
2119			 
2119				NEXTW 
2119 c3 34 1f			jp macro_next 
211c				endm 
# End of macro NEXTW
211c			 
211c			 
211c			.dupinum: 
211c				 
211c			 
211c			 
211c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
211c cd 7e 1d			call macro_dsp_valuehl 
211f				endm 
# End of macro FORTH_DSP_VALUEHL
211f			 
211f			; TODO add floating point number detection 
211f			 
211f			if DEBUG_FORTH_WORDS 
211f				DMARK "DUi" 
211f f5				push af  
2120 3a 34 21			ld a, (.dmark)  
2123 32 6b ee			ld (debug_mark),a  
2126 3a 35 21			ld a, (.dmark+1)  
2129 32 6c ee			ld (debug_mark+1),a  
212c 3a 36 21			ld a, (.dmark+2)  
212f 32 6d ee			ld (debug_mark+2),a  
2132 18 03			jr .pastdmark  
2134 ..			.dmark: db "DUi"  
2137 f1			.pastdmark: pop af  
2138			endm  
# End of macro DMARK
2138				CALLMONITOR 
2138 cd 6f ee			call debug_vector  
213b				endm  
# End of macro CALLMONITOR
213b			endif 
213b			 
213b cd 79 1b			call forth_push_numhl 
213e				NEXTW 
213e c3 34 1f			jp macro_next 
2141				endm 
# End of macro NEXTW
2141			.ZDUP: 
2141			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2141 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2142 79 21			dw .SWAP            
2144 05				db 4 + 1 
2145 .. 00			db "?DUP",0              
214a				endm 
# End of macro CWHEAD
214a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
214a			 
214a				if DEBUG_FORTH_WORDS_KEY 
214a					DMARK "qDU" 
214a f5				push af  
214b 3a 5f 21			ld a, (.dmark)  
214e 32 6b ee			ld (debug_mark),a  
2151 3a 60 21			ld a, (.dmark+1)  
2154 32 6c ee			ld (debug_mark+1),a  
2157 3a 61 21			ld a, (.dmark+2)  
215a 32 6d ee			ld (debug_mark+2),a  
215d 18 03			jr .pastdmark  
215f ..			.dmark: db "qDU"  
2162 f1			.pastdmark: pop af  
2163			endm  
# End of macro DMARK
2163					CALLMONITOR 
2163 cd 6f ee			call debug_vector  
2166				endm  
# End of macro CALLMONITOR
2166				endif 
2166				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2166 cd 7e 1d			call macro_dsp_valuehl 
2169				endm 
# End of macro FORTH_DSP_VALUEHL
2169			 
2169 e5				push hl 
216a			 
216a				; is it a zero? 
216a			 
216a 3e 00			ld a, 0 
216c 84				add h 
216d 85				add l 
216e			 
216e e1				pop hl 
216f			 
216f fe 00			cp 0 
2171 28 03			jr z, .dup2orig 
2173			 
2173			 
2173 cd 79 1b			call forth_push_numhl 
2176			 
2176			 
2176			; TODO add floating point number detection 
2176			 
2176			.dup2orig: 
2176			 
2176				NEXTW 
2176 c3 34 1f			jp macro_next 
2179				endm 
# End of macro NEXTW
2179			.SWAP: 
2179			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2179 18				db WORD_SYS_CORE+OPCODE_SWAP             
217a b8 21			dw .COLN            
217c 05				db 4 + 1 
217d .. 00			db "SWAP",0              
2182				endm 
# End of macro CWHEAD
2182			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2182				if DEBUG_FORTH_WORDS_KEY 
2182					DMARK "SWP" 
2182 f5				push af  
2183 3a 97 21			ld a, (.dmark)  
2186 32 6b ee			ld (debug_mark),a  
2189 3a 98 21			ld a, (.dmark+1)  
218c 32 6c ee			ld (debug_mark+1),a  
218f 3a 99 21			ld a, (.dmark+2)  
2192 32 6d ee			ld (debug_mark+2),a  
2195 18 03			jr .pastdmark  
2197 ..			.dmark: db "SWP"  
219a f1			.pastdmark: pop af  
219b			endm  
# End of macro DMARK
219b					CALLMONITOR 
219b cd 6f ee			call debug_vector  
219e				endm  
# End of macro CALLMONITOR
219e				endif 
219e			 
219e			; TODO Use os stack swap memory 
219e				FORTH_DSP_VALUEHL 
219e cd 7e 1d			call macro_dsp_valuehl 
21a1				endm 
# End of macro FORTH_DSP_VALUEHL
21a1 e5				push hl     ; w2 
21a2			 
21a2				FORTH_DSP_POP 
21a2 cd 36 1e			call macro_forth_dsp_pop 
21a5				endm 
# End of macro FORTH_DSP_POP
21a5			 
21a5				FORTH_DSP_VALUEHL 
21a5 cd 7e 1d			call macro_dsp_valuehl 
21a8				endm 
# End of macro FORTH_DSP_VALUEHL
21a8			 
21a8				FORTH_DSP_POP 
21a8 cd 36 1e			call macro_forth_dsp_pop 
21ab				endm 
# End of macro FORTH_DSP_POP
21ab			 
21ab d1				pop de     ; w2	, hl = w1 
21ac			 
21ac eb				ex de, hl 
21ad d5				push de 
21ae			 
21ae cd 79 1b			call forth_push_numhl 
21b1			 
21b1 e1				pop hl 
21b2			 
21b2 cd 79 1b			call forth_push_numhl 
21b5				 
21b5			 
21b5				NEXTW 
21b5 c3 34 1f			jp macro_next 
21b8				endm 
# End of macro NEXTW
21b8			.COLN: 
21b8			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
21b8 19				db WORD_SYS_CORE+OPCODE_COLN             
21b9 44 23			dw .SCOLN            
21bb 02				db 1 + 1 
21bc .. 00			db ":",0              
21be				endm 
# End of macro CWHEAD
21be			; | : ( -- )         Create new word | DONE 
21be			 
21be				if DEBUG_FORTH_WORDS_KEY 
21be					DMARK "CLN" 
21be f5				push af  
21bf 3a d3 21			ld a, (.dmark)  
21c2 32 6b ee			ld (debug_mark),a  
21c5 3a d4 21			ld a, (.dmark+1)  
21c8 32 6c ee			ld (debug_mark+1),a  
21cb 3a d5 21			ld a, (.dmark+2)  
21ce 32 6d ee			ld (debug_mark+2),a  
21d1 18 03			jr .pastdmark  
21d3 ..			.dmark: db "CLN"  
21d6 f1			.pastdmark: pop af  
21d7			endm  
# End of macro DMARK
21d7					CALLMONITOR 
21d7 cd 6f ee			call debug_vector  
21da				endm  
# End of macro CALLMONITOR
21da				endif 
21da			STACKFRAME OFF $8efe $989f 
21da				if DEBUG_STACK_IMB 
21da					if OFF 
21da						exx 
21da						ld de, $8efe 
21da						ld a, d 
21da						ld hl, curframe 
21da						call hexout 
21da						ld a, e 
21da						ld hl, curframe+2 
21da						call hexout 
21da						ld hl, $8efe 
21da						push hl 
21da						ld hl, $989f 
21da						push hl 
21da						exx 
21da					endif 
21da				endif 
21da			endm 
# End of macro STACKFRAME
21da			; get parser buffer length  of new word 
21da			 
21da			 
21da			 
21da				; move tok past this to start of name defintition 
21da				; TODO get word to define 
21da				; TODO Move past word token 
21da				; TODO get length of string up to the ';' 
21da			 
21da 2a c2 e5		ld hl, (os_tok_ptr) 
21dd 23			inc hl 
21de 23			inc hl 
21df			 
21df 3e 3b		ld a, ';' 
21e1 cd 63 11		call strlent 
21e4			 
21e4 7d			ld a,l 
21e5 32 b1 e2		ld (os_new_parse_len), a 
21e8			 
21e8			 
21e8			if DEBUG_FORTH_UWORD 
21e8 ed 5b c2 e5	ld de, (os_tok_ptr) 
21ec					DMARK ":01" 
21ec f5				push af  
21ed 3a 01 22			ld a, (.dmark)  
21f0 32 6b ee			ld (debug_mark),a  
21f3 3a 02 22			ld a, (.dmark+1)  
21f6 32 6c ee			ld (debug_mark+1),a  
21f9 3a 03 22			ld a, (.dmark+2)  
21fc 32 6d ee			ld (debug_mark+2),a  
21ff 18 03			jr .pastdmark  
2201 ..			.dmark: db ":01"  
2204 f1			.pastdmark: pop af  
2205			endm  
# End of macro DMARK
2205			CALLMONITOR 
2205 cd 6f ee			call debug_vector  
2208				endm  
# End of macro CALLMONITOR
2208			endif 
2208			 
2208			; 
2208			;  new word memory layout: 
2208			;  
2208			;    : adg 6666 ;  
2208			; 
2208			;    db   1     ; user defined word  
2208 23			inc hl    
2209			;    dw   sysdict 
2209 23			inc hl 
220a 23			inc hl 
220b			;    db <word len>+1 (for null) 
220b 23			inc hl 
220c			;    db .... <word> 
220c			; 
220c			 
220c 23			inc hl    ; some extras for the word preamble before the above 
220d 23			inc hl 
220e 23			inc hl 
220f 23			inc hl 
2210 23			inc hl 
2211 23			inc hl 
2212 23			inc hl  
2213 23			inc hl 
2214 23			inc hl 
2215 23			inc hl 
2216 23			inc hl 
2217 23			inc hl 
2218 23			inc hl 
2219 23			inc hl     ; TODO how many do we really need?     maybe only 6 
221a			;       exec word buffer 
221a			;	<ptr word>   
221a 23			inc hl 
221b 23			inc hl 
221c			;       <word list><null term> 7F final term 
221c			 
221c			 
221c			if DEBUG_FORTH_UWORD 
221c					DMARK ":02" 
221c f5				push af  
221d 3a 31 22			ld a, (.dmark)  
2220 32 6b ee			ld (debug_mark),a  
2223 3a 32 22			ld a, (.dmark+1)  
2226 32 6c ee			ld (debug_mark+1),a  
2229 3a 33 22			ld a, (.dmark+2)  
222c 32 6d ee			ld (debug_mark+2),a  
222f 18 03			jr .pastdmark  
2231 ..			.dmark: db ":02"  
2234 f1			.pastdmark: pop af  
2235			endm  
# End of macro DMARK
2235			CALLMONITOR 
2235 cd 6f ee			call debug_vector  
2238				endm  
# End of macro CALLMONITOR
2238			endif 
2238			 
2238			 
2238				; malloc the size 
2238			 
2238 cd cd 11			call malloc 
223b 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
223e			 
223e			;    db   1     ; user defined word  
223e 3e 01			ld a, WORD_SYS_UWORD  
2240 77				ld (hl), a 
2241			 
2241 23			inc hl    
2242			;    dw   sysdict 
2242 11 8c 20		ld de, sysdict       ; continue on with the scan to the system dict 
2245 73			ld (hl), e 
2246 23			inc hl 
2247 72			ld (hl), d 
2248 23			inc hl 
2249			 
2249			 
2249			;    Setup dict word 
2249			 
2249 23			inc hl 
224a 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
224d			 
224d			; 1. get length of dict word 
224d			 
224d			 
224d 2a c2 e5		ld hl, (os_tok_ptr) 
2250 23			inc hl 
2251 23			inc hl    ; position to start of dict word 
2252 3e 00		ld a, 0 
2254 cd 63 11		call strlent 
2257			 
2257			 
2257 23			inc hl    ; to include null??? 
2258			 
2258			; write length of dict word 
2258			 
2258 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
225c 1b			dec de 
225d eb			ex de, hl 
225e 73			ld (hl), e 
225f eb			ex de, hl 
2260			 
2260			 
2260			 
2260			; copy  
2260 4d			ld c, l 
2261 06 00		ld b, 0 
2263 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2267 2a c2 e5		ld hl, (os_tok_ptr) 
226a 23			inc hl 
226b 23			inc hl    ; position to start of dict word 
226c			 
226c			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
226c			 
226c			; TODO need to convert word to upper case 
226c			 
226c			ucasetok:	 
226c 7e			ld a,(hl) 
226d cd 4f 11		call toUpper 
2270 77			ld (hl),a 
2271 ed a0		ldi 
2273 f2 6c 22		jp p, ucasetok 
2276			 
2276			 
2276			 
2276			; de now points to start of where the word body code should be placed 
2276 ed 53 ad e2	ld (os_new_work_ptr), de 
227a			; hl now points to the words to throw at forthexec which needs to be copied 
227a 22 ab e2		ld (os_new_src_ptr), hl 
227d			 
227d			; TODO add 'call to forthexec' 
227d			 
227d			if DEBUG_FORTH_UWORD 
227d c5			push bc 
227e ed 4b b3 e2	ld bc, (os_new_malloc) 
2282					DMARK ":0x" 
2282 f5				push af  
2283 3a 97 22			ld a, (.dmark)  
2286 32 6b ee			ld (debug_mark),a  
2289 3a 98 22			ld a, (.dmark+1)  
228c 32 6c ee			ld (debug_mark+1),a  
228f 3a 99 22			ld a, (.dmark+2)  
2292 32 6d ee			ld (debug_mark+2),a  
2295 18 03			jr .pastdmark  
2297 ..			.dmark: db ":0x"  
229a f1			.pastdmark: pop af  
229b			endm  
# End of macro DMARK
229b			CALLMONITOR 
229b cd 6f ee			call debug_vector  
229e				endm  
# End of macro CALLMONITOR
229e c1			pop bc 
229f			endif 
229f			 
229f			 
229f			; create word preamble which should be: 
229f			 
229f			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
229f			 
229f			;    ld hl, <word code> 
229f			;    jp user_exec 
229f			;    <word code bytes> 
229f			 
229f			 
229f			;	inc de     ; TODO ??? or are we already past the word's null 
229f eb			ex de, hl 
22a0			 
22a0 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
22a2			 
22a2 23			inc hl 
22a3 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
22a6 23			inc hl 
22a7			 
22a7 23			inc hl 
22a8 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
22aa			 
22aa 01 2e 4c		ld bc, user_exec 
22ad 23			inc hl 
22ae 71			ld (hl), c     ; poke address of user_exec 
22af 23			inc hl 
22b0 70			ld (hl), b     
22b1			; 
22b1			;	inc hl 
22b1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22b1			; 
22b1			; 
22b1			;	ld bc, macro_forth_rsp_next 
22b1			;	inc hl 
22b1			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
22b1			;	inc hl 
22b1			;	ld (hl), b     
22b1			; 
22b1			;	inc hl 
22b1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22b1			; 
22b1			; 
22b1			;	inc hl 
22b1			;	ld bc, forthexec 
22b1			;	ld (hl), c     ; poke address of forthexec 
22b1			;	inc hl 
22b1			;	ld (hl), b      
22b1			; 
22b1			;	inc hl 
22b1			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
22b1			; 
22b1			;	ld bc, user_dict_next 
22b1			;	inc hl 
22b1			;	ld (hl), c     ; poke address of forthexec 
22b1			;	inc hl 
22b1			;	ld (hl), b      
22b1			 
22b1			; hl is now where we need to copy the word byte data to save this 
22b1			 
22b1 23			inc hl 
22b2 22 a9 e2		ld (os_new_exec), hl 
22b5			 
22b5			; copy definition 
22b5			 
22b5 eb			ex de, hl 
22b6			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
22b6			;	inc de    ; skip the PC for this parse 
22b6 3a b1 e2		ld a, (os_new_parse_len) 
22b9 4f			ld c, a 
22ba 06 00		ld b, 0 
22bc ed b0		ldir		 ; copy defintion 
22be			 
22be			 
22be			; poke the address of where the new word bytes live for forthexec 
22be			 
22be 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
22c1			 
22c1 ed 5b a9 e2	ld de, (os_new_exec)      
22c5			 
22c5 73			ld (hl), e 
22c6 23			inc hl 
22c7 72			ld (hl), d 
22c8			 
22c8				; TODO copy last user dict word next link to this word 
22c8				; TODO update last user dict word to point to this word 
22c8			; 
22c8			; hl f923 de 812a ; bc 811a 
22c8			 
22c8			if DEBUG_FORTH_UWORD 
22c8 c5			push bc 
22c9 ed 4b b3 e2	ld bc, (os_new_malloc) 
22cd					DMARK ":0A" 
22cd f5				push af  
22ce 3a e2 22			ld a, (.dmark)  
22d1 32 6b ee			ld (debug_mark),a  
22d4 3a e3 22			ld a, (.dmark+1)  
22d7 32 6c ee			ld (debug_mark+1),a  
22da 3a e4 22			ld a, (.dmark+2)  
22dd 32 6d ee			ld (debug_mark+2),a  
22e0 18 03			jr .pastdmark  
22e2 ..			.dmark: db ":0A"  
22e5 f1			.pastdmark: pop af  
22e6			endm  
# End of macro DMARK
22e6			CALLMONITOR 
22e6 cd 6f ee			call debug_vector  
22e9				endm  
# End of macro CALLMONITOR
22e9 c1			pop bc 
22ea			endif 
22ea			if DEBUG_FORTH_UWORD 
22ea c5			push bc 
22eb ed 4b b3 e2	ld bc, (os_new_malloc) 
22ef 03			inc bc 
22f0 03			inc bc 
22f1 03			inc bc 
22f2 03			inc bc 
22f3 03			inc bc 
22f4 03			inc bc 
22f5 03			inc bc 
22f6 03			inc bc 
22f7			 
22f7					DMARK ":0B" 
22f7 f5				push af  
22f8 3a 0c 23			ld a, (.dmark)  
22fb 32 6b ee			ld (debug_mark),a  
22fe 3a 0d 23			ld a, (.dmark+1)  
2301 32 6c ee			ld (debug_mark+1),a  
2304 3a 0e 23			ld a, (.dmark+2)  
2307 32 6d ee			ld (debug_mark+2),a  
230a 18 03			jr .pastdmark  
230c ..			.dmark: db ":0B"  
230f f1			.pastdmark: pop af  
2310			endm  
# End of macro DMARK
2310			CALLMONITOR 
2310 cd 6f ee			call debug_vector  
2313				endm  
# End of macro CALLMONITOR
2313 c1			pop bc 
2314			endif 
2314			 
2314			; update word dict linked list for new word 
2314			 
2314			 
2314 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2317 23			inc hl     ; move to next work linked list ptr 
2318			 
2318 ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
231c 73			ld (hl), e 
231d 23			inc hl 
231e 72			ld (hl), d 
231f			 
231f			if DEBUG_FORTH_UWORD 
231f ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2323			endif 
2323			 
2323 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
2327			 
2327			 
2327			if DEBUG_FORTH_UWORD 
2327					DMARK ":0+" 
2327 f5				push af  
2328 3a 3c 23			ld a, (.dmark)  
232b 32 6b ee			ld (debug_mark),a  
232e 3a 3d 23			ld a, (.dmark+1)  
2331 32 6c ee			ld (debug_mark+1),a  
2334 3a 3e 23			ld a, (.dmark+2)  
2337 32 6d ee			ld (debug_mark+2),a  
233a 18 03			jr .pastdmark  
233c ..			.dmark: db ":0+"  
233f f1			.pastdmark: pop af  
2340			endm  
# End of macro DMARK
2340			CALLMONITOR 
2340 cd 6f ee			call debug_vector  
2343				endm  
# End of macro CALLMONITOR
2343			endif 
2343			 
2343			STACKFRAMECHK OFF $8efe $989f 
2343				if DEBUG_STACK_IMB 
2343					if OFF 
2343						exx 
2343						ld hl, $989f 
2343						pop de   ; $989f 
2343						call cmp16 
2343						jr nz, .spnosame 
2343						ld hl, $8efe 
2343						pop de   ; $8efe 
2343						call cmp16 
2343						jr z, .spfrsame 
2343						.spnosame: call showsperror 
2343						.spfrsame: nop 
2343						exx 
2343					endif 
2343				endif 
2343			endm 
# End of macro STACKFRAMECHK
2343			 
2343 c9			ret    ; dont process any remaining parser tokens as they form new word 
2344			 
2344			 
2344			 
2344			 
2344			;		NEXT 
2344			.SCOLN: 
2344			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2344 06			db OPCODE_SCOLN 
2345 90 23		dw .DROP 
2347 02			db 2 
2348 .. 00		db ";",0           
234a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
234a				if DEBUG_FORTH_WORDS_KEY 
234a					DMARK "SCN" 
234a f5				push af  
234b 3a 5f 23			ld a, (.dmark)  
234e 32 6b ee			ld (debug_mark),a  
2351 3a 60 23			ld a, (.dmark+1)  
2354 32 6c ee			ld (debug_mark+1),a  
2357 3a 61 23			ld a, (.dmark+2)  
235a 32 6d ee			ld (debug_mark+2),a  
235d 18 03			jr .pastdmark  
235f ..			.dmark: db "SCN"  
2362 f1			.pastdmark: pop af  
2363			endm  
# End of macro DMARK
2363					CALLMONITOR 
2363 cd 6f ee			call debug_vector  
2366				endm  
# End of macro CALLMONITOR
2366				endif 
2366				FORTH_RSP_TOS 
2366 cd 37 1b			call macro_forth_rsp_tos 
2369				endm 
# End of macro FORTH_RSP_TOS
2369 e5				push hl 
236a				FORTH_RSP_POP 
236a cd 41 1b			call macro_forth_rsp_pop 
236d				endm 
# End of macro FORTH_RSP_POP
236d e1				pop hl 
236e			;		ex de,hl 
236e 22 c2 e5			ld (os_tok_ptr),hl 
2371			 
2371			if DEBUG_FORTH_UWORD 
2371					DMARK "SCL" 
2371 f5				push af  
2372 3a 86 23			ld a, (.dmark)  
2375 32 6b ee			ld (debug_mark),a  
2378 3a 87 23			ld a, (.dmark+1)  
237b 32 6c ee			ld (debug_mark+1),a  
237e 3a 88 23			ld a, (.dmark+2)  
2381 32 6d ee			ld (debug_mark+2),a  
2384 18 03			jr .pastdmark  
2386 ..			.dmark: db "SCL"  
2389 f1			.pastdmark: pop af  
238a			endm  
# End of macro DMARK
238a			CALLMONITOR 
238a cd 6f ee			call debug_vector  
238d				endm  
# End of macro CALLMONITOR
238d			endif 
238d				NEXTW 
238d c3 34 1f			jp macro_next 
2390				endm 
# End of macro NEXTW
2390			 
2390			.DROP: 
2390			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2390 1b				db WORD_SYS_CORE+OPCODE_DROP             
2391 bb 23			dw .DUP2            
2393 05				db 4 + 1 
2394 .. 00			db "DROP",0              
2399				endm 
# End of macro CWHEAD
2399			; | DROP ( w -- )   drop the TOS item   | DONE 
2399				if DEBUG_FORTH_WORDS_KEY 
2399					DMARK "DRP" 
2399 f5				push af  
239a 3a ae 23			ld a, (.dmark)  
239d 32 6b ee			ld (debug_mark),a  
23a0 3a af 23			ld a, (.dmark+1)  
23a3 32 6c ee			ld (debug_mark+1),a  
23a6 3a b0 23			ld a, (.dmark+2)  
23a9 32 6d ee			ld (debug_mark+2),a  
23ac 18 03			jr .pastdmark  
23ae ..			.dmark: db "DRP"  
23b1 f1			.pastdmark: pop af  
23b2			endm  
# End of macro DMARK
23b2					CALLMONITOR 
23b2 cd 6f ee			call debug_vector  
23b5				endm  
# End of macro CALLMONITOR
23b5				endif 
23b5				FORTH_DSP_POP 
23b5 cd 36 1e			call macro_forth_dsp_pop 
23b8				endm 
# End of macro FORTH_DSP_POP
23b8				NEXTW 
23b8 c3 34 1f			jp macro_next 
23bb				endm 
# End of macro NEXTW
23bb			.DUP2: 
23bb			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
23bb 1c				db WORD_SYS_CORE+OPCODE_DUP2             
23bc 00 24			dw .DROP2            
23be 05				db 4 + 1 
23bf .. 00			db "2DUP",0              
23c4				endm 
# End of macro CWHEAD
23c4			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
23c4				if DEBUG_FORTH_WORDS_KEY 
23c4					DMARK "2DU" 
23c4 f5				push af  
23c5 3a d9 23			ld a, (.dmark)  
23c8 32 6b ee			ld (debug_mark),a  
23cb 3a da 23			ld a, (.dmark+1)  
23ce 32 6c ee			ld (debug_mark+1),a  
23d1 3a db 23			ld a, (.dmark+2)  
23d4 32 6d ee			ld (debug_mark+2),a  
23d7 18 03			jr .pastdmark  
23d9 ..			.dmark: db "2DU"  
23dc f1			.pastdmark: pop af  
23dd			endm  
# End of macro DMARK
23dd					CALLMONITOR 
23dd cd 6f ee			call debug_vector  
23e0				endm  
# End of macro CALLMONITOR
23e0				endif 
23e0				FORTH_DSP_VALUEHL 
23e0 cd 7e 1d			call macro_dsp_valuehl 
23e3				endm 
# End of macro FORTH_DSP_VALUEHL
23e3 e5				push hl      ; 2 
23e4			 
23e4				FORTH_DSP_POP 
23e4 cd 36 1e			call macro_forth_dsp_pop 
23e7				endm 
# End of macro FORTH_DSP_POP
23e7				 
23e7				FORTH_DSP_VALUEHL 
23e7 cd 7e 1d			call macro_dsp_valuehl 
23ea				endm 
# End of macro FORTH_DSP_VALUEHL
23ea			;		push hl      ; 1 
23ea			 
23ea				FORTH_DSP_POP 
23ea cd 36 1e			call macro_forth_dsp_pop 
23ed				endm 
# End of macro FORTH_DSP_POP
23ed			 
23ed			;		pop hl       ; 1 
23ed d1				pop de       ; 2 
23ee			 
23ee cd 79 1b			call forth_push_numhl 
23f1 eb				ex de, hl 
23f2 cd 79 1b			call forth_push_numhl 
23f5			 
23f5				 
23f5 eb				ex de, hl 
23f6			 
23f6 cd 79 1b			call forth_push_numhl 
23f9 eb				ex de, hl 
23fa cd 79 1b			call forth_push_numhl 
23fd			 
23fd			 
23fd				NEXTW 
23fd c3 34 1f			jp macro_next 
2400				endm 
# End of macro NEXTW
2400			.DROP2: 
2400			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2400 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2401 2f 24			dw .SWAP2            
2403 06				db 5 + 1 
2404 .. 00			db "2DROP",0              
240a				endm 
# End of macro CWHEAD
240a			; | 2DROP ( w w -- )    Double drop | DONE 
240a				if DEBUG_FORTH_WORDS_KEY 
240a					DMARK "2DR" 
240a f5				push af  
240b 3a 1f 24			ld a, (.dmark)  
240e 32 6b ee			ld (debug_mark),a  
2411 3a 20 24			ld a, (.dmark+1)  
2414 32 6c ee			ld (debug_mark+1),a  
2417 3a 21 24			ld a, (.dmark+2)  
241a 32 6d ee			ld (debug_mark+2),a  
241d 18 03			jr .pastdmark  
241f ..			.dmark: db "2DR"  
2422 f1			.pastdmark: pop af  
2423			endm  
# End of macro DMARK
2423					CALLMONITOR 
2423 cd 6f ee			call debug_vector  
2426				endm  
# End of macro CALLMONITOR
2426				endif 
2426				FORTH_DSP_POP 
2426 cd 36 1e			call macro_forth_dsp_pop 
2429				endm 
# End of macro FORTH_DSP_POP
2429				FORTH_DSP_POP 
2429 cd 36 1e			call macro_forth_dsp_pop 
242c				endm 
# End of macro FORTH_DSP_POP
242c				NEXTW 
242c c3 34 1f			jp macro_next 
242f				endm 
# End of macro NEXTW
242f			.SWAP2: 
242f			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
242f 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2430 58 24			dw .AT            
2432 06				db 5 + 1 
2433 .. 00			db "2SWAP",0              
2439				endm 
# End of macro CWHEAD
2439			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2439				if DEBUG_FORTH_WORDS_KEY 
2439					DMARK "2SW" 
2439 f5				push af  
243a 3a 4e 24			ld a, (.dmark)  
243d 32 6b ee			ld (debug_mark),a  
2440 3a 4f 24			ld a, (.dmark+1)  
2443 32 6c ee			ld (debug_mark+1),a  
2446 3a 50 24			ld a, (.dmark+2)  
2449 32 6d ee			ld (debug_mark+2),a  
244c 18 03			jr .pastdmark  
244e ..			.dmark: db "2SW"  
2451 f1			.pastdmark: pop af  
2452			endm  
# End of macro DMARK
2452					CALLMONITOR 
2452 cd 6f ee			call debug_vector  
2455				endm  
# End of macro CALLMONITOR
2455				endif 
2455			; TODO Use os stack swap memory 
2455				NEXTW 
2455 c3 34 1f			jp macro_next 
2458				endm 
# End of macro NEXTW
2458			.AT: 
2458			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2458 1f				db WORD_SYS_CORE+OPCODE_AT             
2459 8a 24			dw .CAT            
245b 02				db 1 + 1 
245c .. 00			db "@",0              
245e				endm 
# End of macro CWHEAD
245e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
245e			 
245e				if DEBUG_FORTH_WORDS_KEY 
245e					DMARK "AT." 
245e f5				push af  
245f 3a 73 24			ld a, (.dmark)  
2462 32 6b ee			ld (debug_mark),a  
2465 3a 74 24			ld a, (.dmark+1)  
2468 32 6c ee			ld (debug_mark+1),a  
246b 3a 75 24			ld a, (.dmark+2)  
246e 32 6d ee			ld (debug_mark+2),a  
2471 18 03			jr .pastdmark  
2473 ..			.dmark: db "AT."  
2476 f1			.pastdmark: pop af  
2477			endm  
# End of macro DMARK
2477					CALLMONITOR 
2477 cd 6f ee			call debug_vector  
247a				endm  
# End of macro CALLMONITOR
247a				endif 
247a			.getbyteat:	 
247a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
247a cd 7e 1d			call macro_dsp_valuehl 
247d				endm 
# End of macro FORTH_DSP_VALUEHL
247d				 
247d			;		push hl 
247d			 
247d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
247d cd 36 1e			call macro_forth_dsp_pop 
2480				endm 
# End of macro FORTH_DSP_POP
2480			 
2480			;		pop hl 
2480			 
2480 7e				ld a, (hl) 
2481			 
2481 6f				ld l, a 
2482 26 00			ld h, 0 
2484 cd 79 1b			call forth_push_numhl 
2487			 
2487				NEXTW 
2487 c3 34 1f			jp macro_next 
248a				endm 
# End of macro NEXTW
248a			.CAT: 
248a			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
248a 20				db WORD_SYS_CORE+OPCODE_CAT             
248b b3 24			dw .BANG            
248d 03				db 2 + 1 
248e .. 00			db "C@",0              
2491				endm 
# End of macro CWHEAD
2491			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2491				if DEBUG_FORTH_WORDS_KEY 
2491					DMARK "CAA" 
2491 f5				push af  
2492 3a a6 24			ld a, (.dmark)  
2495 32 6b ee			ld (debug_mark),a  
2498 3a a7 24			ld a, (.dmark+1)  
249b 32 6c ee			ld (debug_mark+1),a  
249e 3a a8 24			ld a, (.dmark+2)  
24a1 32 6d ee			ld (debug_mark+2),a  
24a4 18 03			jr .pastdmark  
24a6 ..			.dmark: db "CAA"  
24a9 f1			.pastdmark: pop af  
24aa			endm  
# End of macro DMARK
24aa					CALLMONITOR 
24aa cd 6f ee			call debug_vector  
24ad				endm  
# End of macro CALLMONITOR
24ad				endif 
24ad c3 7a 24			jp .getbyteat 
24b0				NEXTW 
24b0 c3 34 1f			jp macro_next 
24b3				endm 
# End of macro NEXTW
24b3			.BANG: 
24b3			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
24b3 21				db WORD_SYS_CORE+OPCODE_BANG             
24b4 e9 24			dw .CBANG            
24b6 02				db 1 + 1 
24b7 .. 00			db "!",0              
24b9				endm 
# End of macro CWHEAD
24b9			; | ! ( x w -- ) Store x at address w      | DONE 
24b9				if DEBUG_FORTH_WORDS_KEY 
24b9					DMARK "BNG" 
24b9 f5				push af  
24ba 3a ce 24			ld a, (.dmark)  
24bd 32 6b ee			ld (debug_mark),a  
24c0 3a cf 24			ld a, (.dmark+1)  
24c3 32 6c ee			ld (debug_mark+1),a  
24c6 3a d0 24			ld a, (.dmark+2)  
24c9 32 6d ee			ld (debug_mark+2),a  
24cc 18 03			jr .pastdmark  
24ce ..			.dmark: db "BNG"  
24d1 f1			.pastdmark: pop af  
24d2			endm  
# End of macro DMARK
24d2					CALLMONITOR 
24d2 cd 6f ee			call debug_vector  
24d5				endm  
# End of macro CALLMONITOR
24d5				endif 
24d5			 
24d5			.storebyteat:		 
24d5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24d5 cd 7e 1d			call macro_dsp_valuehl 
24d8				endm 
# End of macro FORTH_DSP_VALUEHL
24d8				 
24d8 e5				push hl 
24d9			 
24d9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24d9 cd 36 1e			call macro_forth_dsp_pop 
24dc				endm 
# End of macro FORTH_DSP_POP
24dc			 
24dc				; get byte to poke 
24dc			 
24dc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24dc cd 7e 1d			call macro_dsp_valuehl 
24df				endm 
# End of macro FORTH_DSP_VALUEHL
24df e5				push hl 
24e0			 
24e0			 
24e0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24e0 cd 36 1e			call macro_forth_dsp_pop 
24e3				endm 
# End of macro FORTH_DSP_POP
24e3			 
24e3			 
24e3 d1				pop de 
24e4 e1				pop hl 
24e5			 
24e5 73				ld (hl),e 
24e6			 
24e6			 
24e6				NEXTW 
24e6 c3 34 1f			jp macro_next 
24e9				endm 
# End of macro NEXTW
24e9			.CBANG: 
24e9			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
24e9 22				db WORD_SYS_CORE+OPCODE_CBANG             
24ea 12 25			dw .SCALL            
24ec 03				db 2 + 1 
24ed .. 00			db "C!",0              
24f0				endm 
# End of macro CWHEAD
24f0			; | C!  ( x w -- ) Store x at address w  | DONE 
24f0				if DEBUG_FORTH_WORDS_KEY 
24f0					DMARK "CBA" 
24f0 f5				push af  
24f1 3a 05 25			ld a, (.dmark)  
24f4 32 6b ee			ld (debug_mark),a  
24f7 3a 06 25			ld a, (.dmark+1)  
24fa 32 6c ee			ld (debug_mark+1),a  
24fd 3a 07 25			ld a, (.dmark+2)  
2500 32 6d ee			ld (debug_mark+2),a  
2503 18 03			jr .pastdmark  
2505 ..			.dmark: db "CBA"  
2508 f1			.pastdmark: pop af  
2509			endm  
# End of macro DMARK
2509					CALLMONITOR 
2509 cd 6f ee			call debug_vector  
250c				endm  
# End of macro CALLMONITOR
250c				endif 
250c c3 d5 24			jp .storebyteat 
250f				NEXTW 
250f c3 34 1f			jp macro_next 
2512				endm 
# End of macro NEXTW
2512			.SCALL: 
2512			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2512 23				db WORD_SYS_CORE+OPCODE_SCALL             
2513 46 25			dw .DEPTH            
2515 05				db 4 + 1 
2516 .. 00			db "CALL",0              
251b				endm 
# End of macro CWHEAD
251b			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
251b				if DEBUG_FORTH_WORDS_KEY 
251b					DMARK "CLL" 
251b f5				push af  
251c 3a 30 25			ld a, (.dmark)  
251f 32 6b ee			ld (debug_mark),a  
2522 3a 31 25			ld a, (.dmark+1)  
2525 32 6c ee			ld (debug_mark+1),a  
2528 3a 32 25			ld a, (.dmark+2)  
252b 32 6d ee			ld (debug_mark+2),a  
252e 18 03			jr .pastdmark  
2530 ..			.dmark: db "CLL"  
2533 f1			.pastdmark: pop af  
2534			endm  
# End of macro DMARK
2534					CALLMONITOR 
2534 cd 6f ee			call debug_vector  
2537				endm  
# End of macro CALLMONITOR
2537				endif 
2537			 
2537				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2537 cd 7e 1d			call macro_dsp_valuehl 
253a				endm 
# End of macro FORTH_DSP_VALUEHL
253a			 
253a			;		push hl 
253a			 
253a				; destroy value TOS 
253a			 
253a				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
253a cd 36 1e			call macro_forth_dsp_pop 
253d				endm 
# End of macro FORTH_DSP_POP
253d			 
253d					 
253d			;		pop hl 
253d			 
253d				; how to do a call with hl???? save SP? 
253d cd d8 1e			call forth_call_hl 
2540			 
2540			 
2540				; TODO push value back onto stack for another op etc 
2540			 
2540 cd 79 1b			call forth_push_numhl 
2543				NEXTW 
2543 c3 34 1f			jp macro_next 
2546				endm 
# End of macro NEXTW
2546			.DEPTH: 
2546			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2546 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2547 83 25			dw .OVER            
2549 06				db 5 + 1 
254a .. 00			db "DEPTH",0              
2550				endm 
# End of macro CWHEAD
2550			; | DEPTH ( -- u ) Push count of stack | DONE 
2550				; take current TOS and remove from base value div by two to get count 
2550				if DEBUG_FORTH_WORDS_KEY 
2550					DMARK "DEP" 
2550 f5				push af  
2551 3a 65 25			ld a, (.dmark)  
2554 32 6b ee			ld (debug_mark),a  
2557 3a 66 25			ld a, (.dmark+1)  
255a 32 6c ee			ld (debug_mark+1),a  
255d 3a 67 25			ld a, (.dmark+2)  
2560 32 6d ee			ld (debug_mark+2),a  
2563 18 03			jr .pastdmark  
2565 ..			.dmark: db "DEP"  
2568 f1			.pastdmark: pop af  
2569			endm  
# End of macro DMARK
2569					CALLMONITOR 
2569 cd 6f ee			call debug_vector  
256c				endm  
# End of macro CALLMONITOR
256c				endif 
256c			 
256c			 
256c 2a ee e9		ld hl, (cli_data_sp) 
256f 11 28 e8		ld de, cli_data_stack 
2572 ed 52		sbc hl,de 
2574			 
2574			; div by size of stack item 
2574			 
2574 5d			ld e,l 
2575 0e 03		ld c, 3 
2577 cd 82 0d		call Div8 
257a			 
257a 6f			ld l,a 
257b 26 00		ld h,0 
257d			 
257d			;srl h 
257d			;rr l 
257d			 
257d cd 79 1b			call forth_push_numhl 
2580				NEXTW 
2580 c3 34 1f			jp macro_next 
2583				endm 
# End of macro NEXTW
2583			.OVER: 
2583			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2583 42				db WORD_SYS_CORE+46             
2584 ca 25			dw .PAUSE            
2586 05				db 4 + 1 
2587 .. 00			db "OVER",0              
258c				endm 
# End of macro CWHEAD
258c			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
258c				if DEBUG_FORTH_WORDS_KEY 
258c					DMARK "OVR" 
258c f5				push af  
258d 3a a1 25			ld a, (.dmark)  
2590 32 6b ee			ld (debug_mark),a  
2593 3a a2 25			ld a, (.dmark+1)  
2596 32 6c ee			ld (debug_mark+1),a  
2599 3a a3 25			ld a, (.dmark+2)  
259c 32 6d ee			ld (debug_mark+2),a  
259f 18 03			jr .pastdmark  
25a1 ..			.dmark: db "OVR"  
25a4 f1			.pastdmark: pop af  
25a5			endm  
# End of macro DMARK
25a5					CALLMONITOR 
25a5 cd 6f ee			call debug_vector  
25a8				endm  
# End of macro CALLMONITOR
25a8				endif 
25a8			 
25a8			; TODO Use os stack swap memory 
25a8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25a8 cd 7e 1d			call macro_dsp_valuehl 
25ab				endm 
# End of macro FORTH_DSP_VALUEHL
25ab e5				push hl    ; n2 
25ac				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ac cd 36 1e			call macro_forth_dsp_pop 
25af				endm 
# End of macro FORTH_DSP_POP
25af			 
25af				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25af cd 7e 1d			call macro_dsp_valuehl 
25b2				endm 
# End of macro FORTH_DSP_VALUEHL
25b2 e5				push hl    ; n1 
25b3				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25b3 cd 36 1e			call macro_forth_dsp_pop 
25b6				endm 
# End of macro FORTH_DSP_POP
25b6			 
25b6 d1				pop de     ; n1 
25b7 e1				pop hl     ; n2 
25b8			 
25b8 d5				push de 
25b9 e5				push hl 
25ba d5				push de 
25bb			 
25bb				; push back  
25bb			 
25bb e1				pop hl 
25bc cd 79 1b			call forth_push_numhl 
25bf e1				pop hl 
25c0 cd 79 1b			call forth_push_numhl 
25c3 e1				pop hl 
25c4 cd 79 1b			call forth_push_numhl 
25c7				NEXTW 
25c7 c3 34 1f			jp macro_next 
25ca				endm 
# End of macro NEXTW
25ca			 
25ca			.PAUSE: 
25ca			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
25ca 43				db WORD_SYS_CORE+47             
25cb ff 25			dw .PAUSES            
25cd 08				db 7 + 1 
25ce .. 00			db "PAUSEMS",0              
25d6				endm 
# End of macro CWHEAD
25d6			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
25d6				if DEBUG_FORTH_WORDS_KEY 
25d6					DMARK "PMS" 
25d6 f5				push af  
25d7 3a eb 25			ld a, (.dmark)  
25da 32 6b ee			ld (debug_mark),a  
25dd 3a ec 25			ld a, (.dmark+1)  
25e0 32 6c ee			ld (debug_mark+1),a  
25e3 3a ed 25			ld a, (.dmark+2)  
25e6 32 6d ee			ld (debug_mark+2),a  
25e9 18 03			jr .pastdmark  
25eb ..			.dmark: db "PMS"  
25ee f1			.pastdmark: pop af  
25ef			endm  
# End of macro DMARK
25ef					CALLMONITOR 
25ef cd 6f ee			call debug_vector  
25f2				endm  
# End of macro CALLMONITOR
25f2				endif 
25f2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25f2 cd 7e 1d			call macro_dsp_valuehl 
25f5				endm 
# End of macro FORTH_DSP_VALUEHL
25f5			;		push hl    ; n2 
25f5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25f5 cd 36 1e			call macro_forth_dsp_pop 
25f8				endm 
# End of macro FORTH_DSP_POP
25f8			;		pop hl 
25f8			 
25f8 7d				ld a, l 
25f9 cd e2 0a			call aDelayInMS 
25fc			       NEXTW 
25fc c3 34 1f			jp macro_next 
25ff				endm 
# End of macro NEXTW
25ff			.PAUSES:  
25ff			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
25ff 44				db WORD_SYS_CORE+48             
2600 6e 26			dw .ROT            
2602 06				db 5 + 1 
2603 .. 00			db "PAUSE",0              
2609				endm 
# End of macro CWHEAD
2609			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2609				if DEBUG_FORTH_WORDS_KEY 
2609					DMARK "PAU" 
2609 f5				push af  
260a 3a 1e 26			ld a, (.dmark)  
260d 32 6b ee			ld (debug_mark),a  
2610 3a 1f 26			ld a, (.dmark+1)  
2613 32 6c ee			ld (debug_mark+1),a  
2616 3a 20 26			ld a, (.dmark+2)  
2619 32 6d ee			ld (debug_mark+2),a  
261c 18 03			jr .pastdmark  
261e ..			.dmark: db "PAU"  
2621 f1			.pastdmark: pop af  
2622			endm  
# End of macro DMARK
2622					CALLMONITOR 
2622 cd 6f ee			call debug_vector  
2625				endm  
# End of macro CALLMONITOR
2625				endif 
2625				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2625 cd 7e 1d			call macro_dsp_valuehl 
2628				endm 
# End of macro FORTH_DSP_VALUEHL
2628			;		push hl    ; n2 
2628				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2628 cd 36 1e			call macro_forth_dsp_pop 
262b				endm 
# End of macro FORTH_DSP_POP
262b			;		pop hl 
262b 45				ld b, l 
262c				if DEBUG_FORTH_WORDS 
262c					DMARK "PAU" 
262c f5				push af  
262d 3a 41 26			ld a, (.dmark)  
2630 32 6b ee			ld (debug_mark),a  
2633 3a 42 26			ld a, (.dmark+1)  
2636 32 6c ee			ld (debug_mark+1),a  
2639 3a 43 26			ld a, (.dmark+2)  
263c 32 6d ee			ld (debug_mark+2),a  
263f 18 03			jr .pastdmark  
2641 ..			.dmark: db "PAU"  
2644 f1			.pastdmark: pop af  
2645			endm  
# End of macro DMARK
2645					CALLMONITOR 
2645 cd 6f ee			call debug_vector  
2648				endm  
# End of macro CALLMONITOR
2648				endif 
2648 c5			.pauses1:	push bc 
2649 cd fd 0a			call delay1s 
264c c1				pop bc 
264d				if DEBUG_FORTH_WORDS 
264d					DMARK "PA1" 
264d f5				push af  
264e 3a 62 26			ld a, (.dmark)  
2651 32 6b ee			ld (debug_mark),a  
2654 3a 63 26			ld a, (.dmark+1)  
2657 32 6c ee			ld (debug_mark+1),a  
265a 3a 64 26			ld a, (.dmark+2)  
265d 32 6d ee			ld (debug_mark+2),a  
2660 18 03			jr .pastdmark  
2662 ..			.dmark: db "PA1"  
2665 f1			.pastdmark: pop af  
2666			endm  
# End of macro DMARK
2666					CALLMONITOR 
2666 cd 6f ee			call debug_vector  
2669				endm  
# End of macro CALLMONITOR
2669				endif 
2669 10 dd			djnz .pauses1 
266b			 
266b			       NEXTW 
266b c3 34 1f			jp macro_next 
266e				endm 
# End of macro NEXTW
266e			.ROT: 
266e			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
266e 45				db WORD_SYS_CORE+49             
266f bc 26			dw .UWORDS            
2671 04				db 3 + 1 
2672 .. 00			db "ROT",0              
2676				endm 
# End of macro CWHEAD
2676			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2676				if DEBUG_FORTH_WORDS_KEY 
2676					DMARK "ROT" 
2676 f5				push af  
2677 3a 8b 26			ld a, (.dmark)  
267a 32 6b ee			ld (debug_mark),a  
267d 3a 8c 26			ld a, (.dmark+1)  
2680 32 6c ee			ld (debug_mark+1),a  
2683 3a 8d 26			ld a, (.dmark+2)  
2686 32 6d ee			ld (debug_mark+2),a  
2689 18 03			jr .pastdmark  
268b ..			.dmark: db "ROT"  
268e f1			.pastdmark: pop af  
268f			endm  
# End of macro DMARK
268f					CALLMONITOR 
268f cd 6f ee			call debug_vector  
2692				endm  
# End of macro CALLMONITOR
2692				endif 
2692			 
2692			; TODO Use os stack swap memory 
2692				FORTH_DSP_VALUEHL 
2692 cd 7e 1d			call macro_dsp_valuehl 
2695				endm 
# End of macro FORTH_DSP_VALUEHL
2695 e5				push hl    ; u3  
2696			 
2696				FORTH_DSP_POP 
2696 cd 36 1e			call macro_forth_dsp_pop 
2699				endm 
# End of macro FORTH_DSP_POP
2699			 
2699				FORTH_DSP_VALUEHL 
2699 cd 7e 1d			call macro_dsp_valuehl 
269c				endm 
# End of macro FORTH_DSP_VALUEHL
269c e5				push hl     ; u2 
269d			 
269d				FORTH_DSP_POP 
269d cd 36 1e			call macro_forth_dsp_pop 
26a0				endm 
# End of macro FORTH_DSP_POP
26a0			 
26a0				FORTH_DSP_VALUEHL 
26a0 cd 7e 1d			call macro_dsp_valuehl 
26a3				endm 
# End of macro FORTH_DSP_VALUEHL
26a3 e5				push hl     ; u1 
26a4			 
26a4				FORTH_DSP_POP 
26a4 cd 36 1e			call macro_forth_dsp_pop 
26a7				endm 
# End of macro FORTH_DSP_POP
26a7			 
26a7 c1				pop bc      ; u1 
26a8 e1				pop hl      ; u2 
26a9 d1				pop de      ; u3 
26aa			 
26aa			 
26aa c5				push bc 
26ab d5				push de 
26ac e5				push hl 
26ad			 
26ad			 
26ad e1				pop hl 
26ae cd 79 1b			call forth_push_numhl 
26b1			 
26b1 e1				pop hl 
26b2 cd 79 1b			call forth_push_numhl 
26b5			 
26b5 e1				pop hl 
26b6 cd 79 1b			call forth_push_numhl 
26b9				 
26b9			 
26b9			 
26b9			 
26b9			 
26b9			 
26b9			       NEXTW 
26b9 c3 34 1f			jp macro_next 
26bc				endm 
# End of macro NEXTW
26bc			 
26bc			.UWORDS: 
26bc			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
26bc 50				db WORD_SYS_CORE+60             
26bd 7e 27			dw .BP            
26bf 07				db 6 + 1 
26c0 .. 00			db "UWORDS",0              
26c7				endm 
# End of macro CWHEAD
26c7			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
26c7			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
26c7			; | | Following the count are the individual words. 
26c7			; | | 
26c7			; | | e.g. UWORDS 
26c7			; | | BOX DIRLIST 2 
26c7			; | |  
26c7			; | | Can be used to save the words to storage via: 
26c7			; | | UWORDS $01 DO $01 APPEND LOOP 
26c7			if DEBUG_FORTH_WORDS_KEY 
26c7				DMARK "UWR" 
26c7 f5				push af  
26c8 3a dc 26			ld a, (.dmark)  
26cb 32 6b ee			ld (debug_mark),a  
26ce 3a dd 26			ld a, (.dmark+1)  
26d1 32 6c ee			ld (debug_mark+1),a  
26d4 3a de 26			ld a, (.dmark+2)  
26d7 32 6d ee			ld (debug_mark+2),a  
26da 18 03			jr .pastdmark  
26dc ..			.dmark: db "UWR"  
26df f1			.pastdmark: pop af  
26e0			endm  
# End of macro DMARK
26e0				CALLMONITOR 
26e0 cd 6f ee			call debug_vector  
26e3				endm  
# End of macro CALLMONITOR
26e3			endif 
26e3 21 95 5e			ld hl, baseram 
26e6				;ld hl, baseusermem 
26e6 01 00 00			ld bc, 0    ; start a counter 
26e9			 
26e9			; skip dict stub 
26e9			 
26e9 cd 85 20			call forth_tok_next 
26ec			 
26ec			 
26ec			; while we have words to look for 
26ec			 
26ec 7e			.douscan:	ld a, (hl)      
26ed			if DEBUG_FORTH_WORDS 
26ed				DMARK "UWs" 
26ed f5				push af  
26ee 3a 02 27			ld a, (.dmark)  
26f1 32 6b ee			ld (debug_mark),a  
26f4 3a 03 27			ld a, (.dmark+1)  
26f7 32 6c ee			ld (debug_mark+1),a  
26fa 3a 04 27			ld a, (.dmark+2)  
26fd 32 6d ee			ld (debug_mark+2),a  
2700 18 03			jr .pastdmark  
2702 ..			.dmark: db "UWs"  
2705 f1			.pastdmark: pop af  
2706			endm  
# End of macro DMARK
2706				CALLMONITOR 
2706 cd 6f ee			call debug_vector  
2709				endm  
# End of macro CALLMONITOR
2709			endif 
2709 fe 00			cp WORD_SYS_END 
270b 28 4d			jr z, .udone 
270d fe 01			cp WORD_SYS_UWORD 
270f 20 44			jr nz, .nuword 
2711			 
2711			if DEBUG_FORTH_WORDS 
2711				DMARK "UWu" 
2711 f5				push af  
2712 3a 26 27			ld a, (.dmark)  
2715 32 6b ee			ld (debug_mark),a  
2718 3a 27 27			ld a, (.dmark+1)  
271b 32 6c ee			ld (debug_mark+1),a  
271e 3a 28 27			ld a, (.dmark+2)  
2721 32 6d ee			ld (debug_mark+2),a  
2724 18 03			jr .pastdmark  
2726 ..			.dmark: db "UWu"  
2729 f1			.pastdmark: pop af  
272a			endm  
# End of macro DMARK
272a				CALLMONITOR 
272a cd 6f ee			call debug_vector  
272d				endm  
# End of macro CALLMONITOR
272d			endif 
272d				; we have a uword so push its name to the stack 
272d			 
272d e5				push hl  ; save so we can move to next dict block 
272e			 
272e				; skip opcode 
272e 23				inc hl  
272f				; skip next ptr 
272f 23				inc hl  
2730 23				inc hl 
2731				; skip len 
2731 23				inc hl 
2732			if DEBUG_FORTH_WORDS 
2732				DMARK "UWt" 
2732 f5				push af  
2733 3a 47 27			ld a, (.dmark)  
2736 32 6b ee			ld (debug_mark),a  
2739 3a 48 27			ld a, (.dmark+1)  
273c 32 6c ee			ld (debug_mark+1),a  
273f 3a 49 27			ld a, (.dmark+2)  
2742 32 6d ee			ld (debug_mark+2),a  
2745 18 03			jr .pastdmark  
2747 ..			.dmark: db "UWt"  
274a f1			.pastdmark: pop af  
274b			endm  
# End of macro DMARK
274b				CALLMONITOR 
274b cd 6f ee			call debug_vector  
274e				endm  
# End of macro CALLMONITOR
274e			endif 
274e 03				inc bc 
274f			 
274f c5				push bc 
2750 cd e7 1b			call forth_push_str 
2753 c1				pop bc 
2754			 
2754 e1				pop hl 	 
2755			 
2755 cd 85 20		.nuword:	call forth_tok_next 
2758 18 92			jr .douscan  
275a			 
275a			.udone:		 ; push count of uwords found 
275a c5				push bc 
275b e1				pop hl 
275c			 
275c			if DEBUG_FORTH_WORDS 
275c				DMARK "UWc" 
275c f5				push af  
275d 3a 71 27			ld a, (.dmark)  
2760 32 6b ee			ld (debug_mark),a  
2763 3a 72 27			ld a, (.dmark+1)  
2766 32 6c ee			ld (debug_mark+1),a  
2769 3a 73 27			ld a, (.dmark+2)  
276c 32 6d ee			ld (debug_mark+2),a  
276f 18 03			jr .pastdmark  
2771 ..			.dmark: db "UWc"  
2774 f1			.pastdmark: pop af  
2775			endm  
# End of macro DMARK
2775				CALLMONITOR 
2775 cd 6f ee			call debug_vector  
2778				endm  
# End of macro CALLMONITOR
2778			endif 
2778 cd 79 1b			call forth_push_numhl 
277b			 
277b			 
277b			       NEXTW 
277b c3 34 1f			jp macro_next 
277e				endm 
# End of macro NEXTW
277e			 
277e			.BP: 
277e			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
277e 54				db WORD_SYS_CORE+64             
277f b8 27			dw .MONITOR            
2781 03				db 2 + 1 
2782 .. 00			db "BP",0              
2785				endm 
# End of macro CWHEAD
2785			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2785			; | | $00 Will enable the break points within specific code paths 
2785			; | | $01 Will disable break points 
2785			; | |  
2785			; | | By default break points are off. Either the above can be used to enable them 
2785			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2785			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2785			; | | can disable break points. Exiting will then continue boot process. 
2785				; get byte count 
2785				if DEBUG_FORTH_WORDS_KEY 
2785					DMARK "BP." 
2785 f5				push af  
2786 3a 9a 27			ld a, (.dmark)  
2789 32 6b ee			ld (debug_mark),a  
278c 3a 9b 27			ld a, (.dmark+1)  
278f 32 6c ee			ld (debug_mark+1),a  
2792 3a 9c 27			ld a, (.dmark+2)  
2795 32 6d ee			ld (debug_mark+2),a  
2798 18 03			jr .pastdmark  
279a ..			.dmark: db "BP."  
279d f1			.pastdmark: pop af  
279e			endm  
# End of macro DMARK
279e					CALLMONITOR 
279e cd 6f ee			call debug_vector  
27a1				endm  
# End of macro CALLMONITOR
27a1				endif 
27a1			 
27a1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27a1 cd 7e 1d			call macro_dsp_valuehl 
27a4				endm 
# End of macro FORTH_DSP_VALUEHL
27a4			 
27a4			;		push hl 
27a4			 
27a4				; destroy value TOS 
27a4			 
27a4				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27a4 cd 36 1e			call macro_forth_dsp_pop 
27a7				endm 
# End of macro FORTH_DSP_POP
27a7			 
27a7			;		pop hl 
27a7			 
27a7 3e 00			ld a,0 
27a9 bd				cp l 
27aa 28 06			jr z, .bpset 
27ac			;		ld a, '*' 
27ac cd 08 15			call bp_off 
27af				NEXTW 
27af c3 34 1f			jp macro_next 
27b2				endm 
# End of macro NEXTW
27b2			 
27b2			.bpset:	 
27b2				;	ld (os_view_disable), a 
27b2 cd fc 14			call bp_on 
27b5			 
27b5			 
27b5				NEXTW 
27b5 c3 34 1f			jp macro_next 
27b8				endm 
# End of macro NEXTW
27b8			 
27b8			 
27b8			.MONITOR: 
27b8			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
27b8 55				db WORD_SYS_CORE+65             
27b9 e9 27			dw .MALLOC            
27bb 08				db 7 + 1 
27bc .. 00			db "MONITOR",0              
27c4				endm 
# End of macro CWHEAD
27c4			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
27c4			; | | At start the current various registers will be displayed with contents. 
27c4			; | | Top right corner will show the most recent debug marker seen. 
27c4			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
27c4			; | | and the return stack pointer (RSP). 
27c4			; | | Pressing: 
27c4			; | |    1 - Initial screen 
27c4			; | |    2 - Display a data dump of HL 
27c4			; | |    3 - Display a data dump of DE 
27c4			; | |    4 - Display a data dump of BC 
27c4			; | |    5 - Display a data dump of HL 
27c4			; | |    6 - Display a data dump of DSP 
27c4			; | |    7 - Display a data dump of RSP 
27c4			; | |    8 - Display a data dump of what is at DSP 
27c4			; | |    9 - Display a data dump of what is at RSP 
27c4			; | |    0 - Exit monitor and continue running. This will also enable break points 
27c4			; | |    * - Disable break points 
27c4			; | |    # - Enter traditional monitor mode 
27c4			; | | 
27c4			; | | Monitor Mode 
27c4			; | | ------------ 
27c4			; | | A prompt of '>' will be shown for various commands: 
27c4			; | |    D xxxx - Display a data dump starting from hex address xxxx 
27c4			; | |    C - Continue display a data dump from the last set address 
27c4			; | |    M xxxx - Set start of memory edit at address xx 
27c4			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
27c4			; | |    G xxxx - Exec code at specific address 
27c4			; | |    Q - Return to previous 
27c4				if DEBUG_FORTH_WORDS_KEY 
27c4					DMARK "MON" 
27c4 f5				push af  
27c5 3a d9 27			ld a, (.dmark)  
27c8 32 6b ee			ld (debug_mark),a  
27cb 3a da 27			ld a, (.dmark+1)  
27ce 32 6c ee			ld (debug_mark+1),a  
27d1 3a db 27			ld a, (.dmark+2)  
27d4 32 6d ee			ld (debug_mark+2),a  
27d7 18 03			jr .pastdmark  
27d9 ..			.dmark: db "MON"  
27dc f1			.pastdmark: pop af  
27dd			endm  
# End of macro DMARK
27dd					CALLMONITOR 
27dd cd 6f ee			call debug_vector  
27e0				endm  
# End of macro CALLMONITOR
27e0				endif 
27e0			;		ld a, 0 
27e0			;		ld (os_view_disable), a 
27e0 cd fc 14			call bp_on 
27e3			 
27e3				CALLMONITOR 
27e3 cd 6f ee			call debug_vector  
27e6				endm  
# End of macro CALLMONITOR
27e6			 
27e6			;	call monitor 
27e6			 
27e6				NEXTW 
27e6 c3 34 1f			jp macro_next 
27e9				endm 
# End of macro NEXTW
27e9			 
27e9			 
27e9			.MALLOC: 
27e9			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
27e9 56				db WORD_SYS_CORE+66             
27ea 12 28			dw .MALLOC2            
27ec 06				db 5 + 1 
27ed .. 00			db "ALLOT",0              
27f3				endm 
# End of macro CWHEAD
27f3			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
27f3				if DEBUG_FORTH_WORDS_KEY 
27f3					DMARK "ALL" 
27f3 f5				push af  
27f4 3a 08 28			ld a, (.dmark)  
27f7 32 6b ee			ld (debug_mark),a  
27fa 3a 09 28			ld a, (.dmark+1)  
27fd 32 6c ee			ld (debug_mark+1),a  
2800 3a 0a 28			ld a, (.dmark+2)  
2803 32 6d ee			ld (debug_mark+2),a  
2806 18 03			jr .pastdmark  
2808 ..			.dmark: db "ALL"  
280b f1			.pastdmark: pop af  
280c			endm  
# End of macro DMARK
280c					CALLMONITOR 
280c cd 6f ee			call debug_vector  
280f				endm  
# End of macro CALLMONITOR
280f				endif 
280f c3 39 28			jp .mallocc 
2812			.MALLOC2: 
2812			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2812 56				db WORD_SYS_CORE+66             
2813 50 28			dw .FREE            
2815 07				db 6 + 1 
2816 .. 00			db "MALLOC",0              
281d				endm 
# End of macro CWHEAD
281d			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
281d				; get byte count 
281d				if DEBUG_FORTH_WORDS_KEY 
281d					DMARK "MAL" 
281d f5				push af  
281e 3a 32 28			ld a, (.dmark)  
2821 32 6b ee			ld (debug_mark),a  
2824 3a 33 28			ld a, (.dmark+1)  
2827 32 6c ee			ld (debug_mark+1),a  
282a 3a 34 28			ld a, (.dmark+2)  
282d 32 6d ee			ld (debug_mark+2),a  
2830 18 03			jr .pastdmark  
2832 ..			.dmark: db "MAL"  
2835 f1			.pastdmark: pop af  
2836			endm  
# End of macro DMARK
2836					CALLMONITOR 
2836 cd 6f ee			call debug_vector  
2839				endm  
# End of macro CALLMONITOR
2839				endif 
2839			.mallocc: 
2839				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2839 cd 7e 1d			call macro_dsp_valuehl 
283c				endm 
# End of macro FORTH_DSP_VALUEHL
283c			 
283c			;		push hl 
283c			 
283c				; destroy value TOS 
283c			 
283c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
283c cd 36 1e			call macro_forth_dsp_pop 
283f				endm 
# End of macro FORTH_DSP_POP
283f			 
283f			;		pop hl 
283f cd cd 11			call malloc 
2842			if DEBUG_FORTH_MALLOC_GUARD 
2842 f5				push af 
2843 cd 1b 0e			call ishlzero 
2846			;		ld a, l 
2846			;		add h 
2846			;		cp 0 
2846 f1				pop af 
2847				 
2847 cc 00 4d			call z,malloc_error 
284a			endif 
284a			 
284a cd 79 1b			call forth_push_numhl 
284d				NEXTW 
284d c3 34 1f			jp macro_next 
2850				endm 
# End of macro NEXTW
2850			 
2850			.FREE: 
2850			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2850 57				db WORD_SYS_CORE+67             
2851 81 28			dw .LIST            
2853 05				db 4 + 1 
2854 .. 00			db "FREE",0              
2859				endm 
# End of macro CWHEAD
2859			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2859				if DEBUG_FORTH_WORDS_KEY 
2859					DMARK "FRE" 
2859 f5				push af  
285a 3a 6e 28			ld a, (.dmark)  
285d 32 6b ee			ld (debug_mark),a  
2860 3a 6f 28			ld a, (.dmark+1)  
2863 32 6c ee			ld (debug_mark+1),a  
2866 3a 70 28			ld a, (.dmark+2)  
2869 32 6d ee			ld (debug_mark+2),a  
286c 18 03			jr .pastdmark  
286e ..			.dmark: db "FRE"  
2871 f1			.pastdmark: pop af  
2872			endm  
# End of macro DMARK
2872					CALLMONITOR 
2872 cd 6f ee			call debug_vector  
2875				endm  
# End of macro CALLMONITOR
2875				endif 
2875				; get address 
2875			 
2875				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2875 cd 7e 1d			call macro_dsp_valuehl 
2878				endm 
# End of macro FORTH_DSP_VALUEHL
2878			 
2878			;		push hl 
2878			 
2878				; destroy value TOS 
2878			 
2878				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2878 cd 36 1e			call macro_forth_dsp_pop 
287b				endm 
# End of macro FORTH_DSP_POP
287b			 
287b			;		pop hl 
287b			if FORTH_ENABLE_MALLOCFREE 
287b cd 97 12			call free 
287e			endif 
287e				NEXTW 
287e c3 34 1f			jp macro_next 
2881				endm 
# End of macro NEXTW
2881			.LIST: 
2881			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2881 5c				db WORD_SYS_CORE+72             
2882 7d 2a			dw .FORGET            
2884 05				db 4 + 1 
2885 .. 00			db "LIST",0              
288a				endm 
# End of macro CWHEAD
288a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
288a			; | | The quoted word must be in upper case. 
288a			if DEBUG_FORTH_WORDS_KEY 
288a				DMARK "LST" 
288a f5				push af  
288b 3a 9f 28			ld a, (.dmark)  
288e 32 6b ee			ld (debug_mark),a  
2891 3a a0 28			ld a, (.dmark+1)  
2894 32 6c ee			ld (debug_mark+1),a  
2897 3a a1 28			ld a, (.dmark+2)  
289a 32 6d ee			ld (debug_mark+2),a  
289d 18 03			jr .pastdmark  
289f ..			.dmark: db "LST"  
28a2 f1			.pastdmark: pop af  
28a3			endm  
# End of macro DMARK
28a3				CALLMONITOR 
28a3 cd 6f ee			call debug_vector  
28a6				endm  
# End of macro CALLMONITOR
28a6			endif 
28a6			 
28a6				FORTH_DSP_VALUEHL 
28a6 cd 7e 1d			call macro_dsp_valuehl 
28a9				endm 
# End of macro FORTH_DSP_VALUEHL
28a9			 
28a9 e5				push hl 
28aa				FORTH_DSP_POP 
28aa cd 36 1e			call macro_forth_dsp_pop 
28ad				endm 
# End of macro FORTH_DSP_POP
28ad c1				pop bc 
28ae			 
28ae			; Start format of scratch string 
28ae			 
28ae 21 c1 e2			ld hl, scratch 
28b1			 
28b1 3e 3a			ld a, ':' 
28b3 77				ld (hl),a 
28b4 23				inc hl 
28b5 3e 20			ld a, ' ' 
28b7 77				ld (hl), a 
28b8			 
28b8				; Get ptr to the word we need to look up 
28b8			 
28b8			;		FORTH_DSP_VALUEHL 
28b8				;v5 FORTH_DSP_VALUE 
28b8			; TODO type check 
28b8			;		inc hl    ; Skip type check  
28b8			;		push hl 
28b8			;		ex de, hl    ; put into DE 
28b8			 
28b8			 
28b8 21 95 5e			ld hl, baseram 
28bb				;ld hl, baseusermem 
28bb			 
28bb e5			push hl   ; sacreifical push 
28bc			 
28bc			.ldouscanm: 
28bc e1			pop hl 
28bd			.ldouscan: 
28bd			if DEBUG_FORTH_WORDS 
28bd				DMARK "LSs" 
28bd f5				push af  
28be 3a d2 28			ld a, (.dmark)  
28c1 32 6b ee			ld (debug_mark),a  
28c4 3a d3 28			ld a, (.dmark+1)  
28c7 32 6c ee			ld (debug_mark+1),a  
28ca 3a d4 28			ld a, (.dmark+2)  
28cd 32 6d ee			ld (debug_mark+2),a  
28d0 18 03			jr .pastdmark  
28d2 ..			.dmark: db "LSs"  
28d5 f1			.pastdmark: pop af  
28d6			endm  
# End of macro DMARK
28d6				CALLMONITOR 
28d6 cd 6f ee			call debug_vector  
28d9				endm  
# End of macro CALLMONITOR
28d9			endif 
28d9			; skip dict stub 
28d9 cd 85 20			call forth_tok_next 
28dc			 
28dc			 
28dc			; while we have words to look for 
28dc			 
28dc 7e			ld a, (hl)      
28dd			if DEBUG_FORTH_WORDS 
28dd				DMARK "LSk" 
28dd f5				push af  
28de 3a f2 28			ld a, (.dmark)  
28e1 32 6b ee			ld (debug_mark),a  
28e4 3a f3 28			ld a, (.dmark+1)  
28e7 32 6c ee			ld (debug_mark+1),a  
28ea 3a f4 28			ld a, (.dmark+2)  
28ed 32 6d ee			ld (debug_mark+2),a  
28f0 18 03			jr .pastdmark  
28f2 ..			.dmark: db "LSk"  
28f5 f1			.pastdmark: pop af  
28f6			endm  
# End of macro DMARK
28f6				CALLMONITOR 
28f6 cd 6f ee			call debug_vector  
28f9				endm  
# End of macro CALLMONITOR
28f9			endif 
28f9				;cp WORD_SYS_END 
28f9				;jp z, .lunotfound 
28f9			 
28f9					; if we hit non uwords then gone too far 
28f9 fe 01				cp WORD_SYS_UWORD 
28fb c2 39 2a				jp nz, .lunotfound 
28fe			 
28fe				if DEBUG_FORTH_WORDS 
28fe					DMARK "LSu" 
28fe f5				push af  
28ff 3a 13 29			ld a, (.dmark)  
2902 32 6b ee			ld (debug_mark),a  
2905 3a 14 29			ld a, (.dmark+1)  
2908 32 6c ee			ld (debug_mark+1),a  
290b 3a 15 29			ld a, (.dmark+2)  
290e 32 6d ee			ld (debug_mark+2),a  
2911 18 03			jr .pastdmark  
2913 ..			.dmark: db "LSu"  
2916 f1			.pastdmark: pop af  
2917			endm  
# End of macro DMARK
2917					CALLMONITOR 
2917 cd 6f ee			call debug_vector  
291a				endm  
# End of macro CALLMONITOR
291a				endif 
291a			 
291a					; found a uword but is it the one we want... 
291a			 
291a c5					push bc     ; uword to find is on bc 
291b d1					pop de 
291c			 
291c e5					push hl  ; to save the ptr 
291d			 
291d					; skip opcode 
291d 23					inc hl  
291e					; skip next ptr 
291e 23					inc hl  
291f 23					inc hl 
2920					; skip len 
2920 23					inc hl 
2921			 
2921				if DEBUG_FORTH_WORDS 
2921					DMARK "LSc" 
2921 f5				push af  
2922 3a 36 29			ld a, (.dmark)  
2925 32 6b ee			ld (debug_mark),a  
2928 3a 37 29			ld a, (.dmark+1)  
292b 32 6c ee			ld (debug_mark+1),a  
292e 3a 38 29			ld a, (.dmark+2)  
2931 32 6d ee			ld (debug_mark+2),a  
2934 18 03			jr .pastdmark  
2936 ..			.dmark: db "LSc"  
2939 f1			.pastdmark: pop af  
293a			endm  
# End of macro DMARK
293a					CALLMONITOR 
293a cd 6f ee			call debug_vector  
293d				endm  
# End of macro CALLMONITOR
293d				endif 
293d			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
293d			; ie. If WOO is defined first and then WO. Couldnt list WO. 
293d			; Nope that has gone the other way. It needs to be exact not on first zero 
293d			;		call strcmp 
293d c5					push bc 
293e cd 9d 11				call StrictStrCmp 
2941 c1					pop bc 
2942 c2 bc 28				jp nz, .ldouscanm 
2945				 
2945			 
2945			 
2945					; we have a uword so push its name to the stack 
2945			 
2945			;	   	push hl  ; save so we can move to next dict block 
2945 e1			pop hl 
2946			 
2946				if DEBUG_FORTH_WORDS 
2946					DMARK "LSm" 
2946 f5				push af  
2947 3a 5b 29			ld a, (.dmark)  
294a 32 6b ee			ld (debug_mark),a  
294d 3a 5c 29			ld a, (.dmark+1)  
2950 32 6c ee			ld (debug_mark+1),a  
2953 3a 5d 29			ld a, (.dmark+2)  
2956 32 6d ee			ld (debug_mark+2),a  
2959 18 03			jr .pastdmark  
295b ..			.dmark: db "LSm"  
295e f1			.pastdmark: pop af  
295f			endm  
# End of macro DMARK
295f					CALLMONITOR 
295f cd 6f ee			call debug_vector  
2962				endm  
# End of macro CALLMONITOR
2962				endif 
2962			 
2962					; skip opcode 
2962 23					inc hl  
2963					; skip next ptr 
2963 23					inc hl  
2964 23					inc hl 
2965					; skip len 
2965 7e					ld a, (hl)   ; save length to add 
2966				if DEBUG_FORTH_WORDS 
2966					DMARK "LS2" 
2966 f5				push af  
2967 3a 7b 29			ld a, (.dmark)  
296a 32 6b ee			ld (debug_mark),a  
296d 3a 7c 29			ld a, (.dmark+1)  
2970 32 6c ee			ld (debug_mark+1),a  
2973 3a 7d 29			ld a, (.dmark+2)  
2976 32 6d ee			ld (debug_mark+2),a  
2979 18 03			jr .pastdmark  
297b ..			.dmark: db "LS2"  
297e f1			.pastdmark: pop af  
297f			endm  
# End of macro DMARK
297f					CALLMONITOR 
297f cd 6f ee			call debug_vector  
2982				endm  
# End of macro CALLMONITOR
2982				endif 
2982			 
2982					; save this location 
2982				 
2982 e5					push hl 
2983			 
2983 23					inc hl 
2984 11 c3 e2				ld de, scratch+2 
2987 4f					ld c, a 
2988 06 00				ld b, 0 
298a			 
298a				if DEBUG_FORTH_WORDS 
298a					DMARK "LSn" 
298a f5				push af  
298b 3a 9f 29			ld a, (.dmark)  
298e 32 6b ee			ld (debug_mark),a  
2991 3a a0 29			ld a, (.dmark+1)  
2994 32 6c ee			ld (debug_mark+1),a  
2997 3a a1 29			ld a, (.dmark+2)  
299a 32 6d ee			ld (debug_mark+2),a  
299d 18 03			jr .pastdmark  
299f ..			.dmark: db "LSn"  
29a2 f1			.pastdmark: pop af  
29a3			endm  
# End of macro DMARK
29a3					CALLMONITOR 
29a3 cd 6f ee			call debug_vector  
29a6				endm  
# End of macro CALLMONITOR
29a6				endif 
29a6			 
29a6					; copy uword name to scratch 
29a6			 
29a6			;		ldir 
29a6			.licplw:	; copy uword name to scratch converting to lower case as we go 
29a6 ed a0				ldi 
29a8 1b					dec de 
29a9 1a					ld a, (de) 
29aa cd 70 10				call to_lower 
29ad 12					ld (de),a 
29ae 13					inc de 
29af 3e 00				ld a, 0 
29b1 b9					cp c 
29b2 20 f2				jr nz, .licplw 
29b4			 
29b4			 
29b4			 
29b4 1b					dec de 
29b5 3e 20				ld a, ' '    ; change null to space 
29b7 12					ld (de), a 
29b8			 
29b8 13					inc de 
29b9			 
29b9 d5					push de 
29ba c1					pop bc     ; move scratch pointer to end of word name and save it 
29bb			 
29bb e1					pop hl 
29bc 7e					ld a, (hl) 
29bd					;inc hl 
29bd					; skip word string 
29bd cd f2 0d				call addatohl 
29c0			 
29c0 23					inc hl 
29c1			 
29c1				if DEBUG_FORTH_WORDS 
29c1					DMARK "LS3" 
29c1 f5				push af  
29c2 3a d6 29			ld a, (.dmark)  
29c5 32 6b ee			ld (debug_mark),a  
29c8 3a d7 29			ld a, (.dmark+1)  
29cb 32 6c ee			ld (debug_mark+1),a  
29ce 3a d8 29			ld a, (.dmark+2)  
29d1 32 6d ee			ld (debug_mark+2),a  
29d4 18 03			jr .pastdmark  
29d6 ..			.dmark: db "LS3"  
29d9 f1			.pastdmark: pop af  
29da			endm  
# End of macro DMARK
29da					CALLMONITOR 
29da cd 6f ee			call debug_vector  
29dd				endm  
# End of macro CALLMONITOR
29dd				endif 
29dd					; should now be at the start of the machine code to setup the eval of the uword 
29dd					; now locate the ptr to the string defintion 
29dd			 
29dd					; skip ld hl, 
29dd					; then load the ptr 
29dd			; TODO use get from hl ptr 
29dd 23					inc hl 
29de 5e					ld e, (hl) 
29df 23					inc hl 
29e0 56					ld d, (hl) 
29e1 eb					ex de, hl 
29e2			 
29e2			 
29e2				if DEBUG_FORTH_WORDS 
29e2					DMARK "LSt" 
29e2 f5				push af  
29e3 3a f7 29			ld a, (.dmark)  
29e6 32 6b ee			ld (debug_mark),a  
29e9 3a f8 29			ld a, (.dmark+1)  
29ec 32 6c ee			ld (debug_mark+1),a  
29ef 3a f9 29			ld a, (.dmark+2)  
29f2 32 6d ee			ld (debug_mark+2),a  
29f5 18 03			jr .pastdmark  
29f7 ..			.dmark: db "LSt"  
29fa f1			.pastdmark: pop af  
29fb			endm  
# End of macro DMARK
29fb					CALLMONITOR 
29fb cd 6f ee			call debug_vector  
29fe				endm  
# End of macro CALLMONITOR
29fe				endif 
29fe			 
29fe			; cant push right now due to tokenised strings  
29fe			 
29fe			; get the destination of where to copy this definition to. 
29fe			 
29fe c5					push bc 
29ff d1					pop de 
2a00			 
2a00 7e			.listl:         ld a,(hl) 
2a01 fe 00				cp 0 
2a03 28 09				jr z, .lreplsp     ; replace zero with space 
2a05					;cp FORTH_END_BUFFER 
2a05 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2a07 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2a09				 
2a09					; just copy this char as is then 
2a09			 
2a09 12					ld (de), a 
2a0a			 
2a0a 23			.listnxt:	inc hl 
2a0b 13					inc de 
2a0c 18 f2				jr .listl 
2a0e			 
2a0e 3e 20		.lreplsp:	ld a,' ' 
2a10 12					ld (de), a 
2a11 18 f7				jr .listnxt 
2a13			 
2a13			; close up uword def 
2a13			 
2a13			.listdone: 
2a13 12					ld (de), a 
2a14 13					inc de 
2a15 3e 00				ld a, 0 
2a17 12					ld (de), a 
2a18			 
2a18			; now have def so clean up and push to stack 
2a18			 
2a18 21 c1 e2				ld hl, scratch 
2a1b				if DEBUG_FORTH_WORDS 
2a1b					DMARK "Ltp" 
2a1b f5				push af  
2a1c 3a 30 2a			ld a, (.dmark)  
2a1f 32 6b ee			ld (debug_mark),a  
2a22 3a 31 2a			ld a, (.dmark+1)  
2a25 32 6c ee			ld (debug_mark+1),a  
2a28 3a 32 2a			ld a, (.dmark+2)  
2a2b 32 6d ee			ld (debug_mark+2),a  
2a2e 18 03			jr .pastdmark  
2a30 ..			.dmark: db "Ltp"  
2a33 f1			.pastdmark: pop af  
2a34			endm  
# End of macro DMARK
2a34					CALLMONITOR 
2a34 cd 6f ee			call debug_vector  
2a37				endm  
# End of macro CALLMONITOR
2a37				endif 
2a37			 
2a37 18 1f			jr .listpush 
2a39			 
2a39			;.lnuword:	pop hl 
2a39			;		call forth_tok_next 
2a39			;		jp .ldouscan  
2a39			 
2a39			.lunotfound:		  
2a39			 
2a39				if DEBUG_FORTH_WORDS 
2a39					DMARK "LSn" 
2a39 f5				push af  
2a3a 3a 4e 2a			ld a, (.dmark)  
2a3d 32 6b ee			ld (debug_mark),a  
2a40 3a 4f 2a			ld a, (.dmark+1)  
2a43 32 6c ee			ld (debug_mark+1),a  
2a46 3a 50 2a			ld a, (.dmark+2)  
2a49 32 6d ee			ld (debug_mark+2),a  
2a4c 18 03			jr .pastdmark  
2a4e ..			.dmark: db "LSn"  
2a51 f1			.pastdmark: pop af  
2a52			endm  
# End of macro DMARK
2a52					CALLMONITOR 
2a52 cd 6f ee			call debug_vector  
2a55				endm  
# End of macro CALLMONITOR
2a55				endif 
2a55			 
2a55					 
2a55			;		FORTH_DSP_POP 
2a55			;		ld hl, .luno 
2a55			 
2a55					NEXTW			 
2a55 c3 34 1f			jp macro_next 
2a58				endm 
# End of macro NEXTW
2a58			 
2a58			.listpush: 
2a58				if DEBUG_FORTH_WORDS 
2a58					DMARK "LS>" 
2a58 f5				push af  
2a59 3a 6d 2a			ld a, (.dmark)  
2a5c 32 6b ee			ld (debug_mark),a  
2a5f 3a 6e 2a			ld a, (.dmark+1)  
2a62 32 6c ee			ld (debug_mark+1),a  
2a65 3a 6f 2a			ld a, (.dmark+2)  
2a68 32 6d ee			ld (debug_mark+2),a  
2a6b 18 03			jr .pastdmark  
2a6d ..			.dmark: db "LS>"  
2a70 f1			.pastdmark: pop af  
2a71			endm  
# End of macro DMARK
2a71					CALLMONITOR 
2a71 cd 6f ee			call debug_vector  
2a74				endm  
# End of macro CALLMONITOR
2a74				endif 
2a74 cd e7 1b				call forth_push_str 
2a77			 
2a77			 
2a77			 
2a77					NEXTW 
2a77 c3 34 1f			jp macro_next 
2a7a				endm 
# End of macro NEXTW
2a7a			 
2a7a			;.luno:    db "Word not found",0 
2a7a			 
2a7a			 
2a7a			 
2a7a			 
2a7a			 
2a7a			;		push hl   ; save pointer to start of uword def string 
2a7a			; 
2a7a			;; look for FORTH_EOL_LINE 
2a7a			;		ld a, FORTH_END_BUFFER 
2a7a			;		call strlent 
2a7a			; 
2a7a			;		inc hl		 ; space for coln def 
2a7a			;		inc hl 
2a7a			;		inc hl          ; space for terms 
2a7a			;		inc hl 
2a7a			; 
2a7a			;		ld a, 20   ; TODO get actual length 
2a7a			;		call addatohl    ; include a random amount of room for the uword name 
2a7a			; 
2a7a			;		 
2a7a			;	if DEBUG_FORTH_WORDS 
2a7a			;		DMARK "Lt1" 
2a7a			;		CALLMONITOR 
2a7a			;	endif 
2a7a			;		 
2a7a			; 
2a7a			;; malloc space for the string because we cant change it 
2a7a			; 
2a7a			;		call malloc 
2a7a			;	if DEBUG_FORTH_MALLOC_GUARD 
2a7a			;		push af 
2a7a			;		call ishlzero 
2a7a			;		pop af 
2a7a			;		 
2a7a			;		call z,malloc_error 
2a7a			;	endif 
2a7a			; 
2a7a			;	if DEBUG_FORTH_WORDS 
2a7a			;		DMARK "Lt2" 
2a7a			;		CALLMONITOR 
2a7a			;	endif 
2a7a			;		pop de 
2a7a			;		push hl    ; push the malloc to release later 
2a7a			;		push hl   ;  push back a copy for the later stack push 
2a7a			;		 
2a7a			;; copy the string swapping out the zero terms for spaces 
2a7a			; 
2a7a			;		; de has our source 
2a7a			;		; hl has our dest 
2a7a			; 
2a7a			;; add the coln def 
2a7a			; 
2a7a			;		ld a, ':' 
2a7a			;		ld (hl), a 
2a7a			;		inc hl 
2a7a			;		ld a, ' ' 
2a7a			;		ld (hl), a 
2a7a			;		inc hl 
2a7a			; 
2a7a			;; add the uname word 
2a7a			;		push de   ; save our string for now 
2a7a			;		ex de, hl 
2a7a			; 
2a7a			;		FORTH_DSP_VALUE 
2a7a			;		;v5 FORTH_DSP_VALUE 
2a7a			; 
2a7a			;		inc hl   ; skip type but we know by now this is OK 
2a7a			; 
2a7a			;.luword:	ld a,(hl) 
2a7a			;		cp 0 
2a7a			;		jr z, .luword2 
2a7a			;		ld (de), a 
2a7a			;		inc de 
2a7a			;		inc hl 
2a7a			;		jr .luword 
2a7a			; 
2a7a			;.luword2:	ld a, ' ' 
2a7a			;		ld (de), a 
2a7a			;;		inc hl 
2a7a			;;		inc de 
2a7a			;;		ld (de), a 
2a7a			;;		inc hl 
2a7a			;		inc de 
2a7a			; 
2a7a			;		ex de, hl 
2a7a			;		pop de 
2a7a			;		 
2a7a			;		 
2a7a			; 
2a7a			;; detoken that string and copy it 
2a7a			; 
2a7a			;	if DEBUG_FORTH_WORDS 
2a7a			;		DMARK "Lt2" 
2a7a			;		CALLMONITOR 
2a7a			;	endif 
2a7a			;.ldetok:	ld a, (de) 
2a7a			;		cp FORTH_END_BUFFER 
2a7a			;		jr z, .ldetokend 
2a7a			;		; swap out any zero term for space 
2a7a			;		cp 0 
2a7a			;		jr nz, .ldetoknext 
2a7a			;		ld a, ' ' 
2a7a			; 
2a7a			;	if DEBUG_FORTH_WORDS 
2a7a			;		DMARK "LtS" 
2a7a			;		CALLMONITOR 
2a7a			;	endif 
2a7a			;.ldetoknext:	ld (hl), a 
2a7a			;		inc de 
2a7a			;		inc hl 
2a7a			;		jr .ldetok 
2a7a			; 
2a7a			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2a7a			;		ld (hl), a  
2a7a			; 
2a7a			;; free that temp malloc 
2a7a			; 
2a7a			;		pop hl    
2a7a			; 
2a7a			;	if DEBUG_FORTH_WORDS 
2a7a			;		DMARK "Lt4" 
2a7a			;		CALLMONITOR 
2a7a			;	endif 
2a7a			;		call forth_apushstrhl 
2a7a			; 
2a7a			;		; get rid of temp malloc area 
2a7a			; 
2a7a			;		pop hl 
2a7a			;		call free 
2a7a			; 
2a7a			;		jr .ludone 
2a7a			; 
2a7a			;.lnuword:	pop hl 
2a7a			;		call forth_tok_next 
2a7a			;		jp .ldouscan  
2a7a			; 
2a7a			;.ludone:		 pop hl 
2a7a			; 
2a7a					NEXTW 
2a7a c3 34 1f			jp macro_next 
2a7d				endm 
# End of macro NEXTW
2a7d			 
2a7d			.FORGET: 
2a7d				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2a7d 5d				db WORD_SYS_CORE+73             
2a7e f6 2a			dw .NOP            
2a80 07				db 6 + 1 
2a81 .. 00			db "FORGET",0              
2a88				endm 
# End of macro CWHEAD
2a88			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2a88			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2a88			; | |  
2a88			; | | e.g. "MORE" forget 
2a88					if DEBUG_FORTH_WORDS_KEY 
2a88						DMARK "FRG" 
2a88 f5				push af  
2a89 3a 9d 2a			ld a, (.dmark)  
2a8c 32 6b ee			ld (debug_mark),a  
2a8f 3a 9e 2a			ld a, (.dmark+1)  
2a92 32 6c ee			ld (debug_mark+1),a  
2a95 3a 9f 2a			ld a, (.dmark+2)  
2a98 32 6d ee			ld (debug_mark+2),a  
2a9b 18 03			jr .pastdmark  
2a9d ..			.dmark: db "FRG"  
2aa0 f1			.pastdmark: pop af  
2aa1			endm  
# End of macro DMARK
2aa1						CALLMONITOR 
2aa1 cd 6f ee			call debug_vector  
2aa4				endm  
# End of macro CALLMONITOR
2aa4					endif 
2aa4			 
2aa4				; find uword 
2aa4			        ; update start of word with "_" 
2aa4				; replace uword with deleted flag 
2aa4			 
2aa4			 
2aa4			;	if DEBUG_FORTH_WORDS 
2aa4			;		DMARK "FOG" 
2aa4			;		CALLMONITOR 
2aa4			;	endif 
2aa4			 
2aa4			 
2aa4					; Get ptr to the word we need to look up 
2aa4			 
2aa4					FORTH_DSP_VALUEHL 
2aa4 cd 7e 1d			call macro_dsp_valuehl 
2aa7				endm 
# End of macro FORTH_DSP_VALUEHL
2aa7					;v5 FORTH_DSP_VALUE 
2aa7				; TODO type check 
2aa7			;		inc hl    ; Skip type check  
2aa7 e5					push hl 
2aa8 c1					pop bc 
2aa9			;		ex de, hl    ; put into DE 
2aa9			 
2aa9			 
2aa9 21 95 5e				ld hl, baseram 
2aac					;ld hl, baseusermem 
2aac			 
2aac				; skip dict stub 
2aac			;	call forth_tok_next 
2aac e5			push hl   ; sacreifical push 
2aad			 
2aad			.fldouscanm: 
2aad e1				pop hl 
2aae			.fldouscan: 
2aae			;	if DEBUG_FORTH_WORDS 
2aae			;		DMARK "LSs" 
2aae			;		CALLMONITOR 
2aae			;	endif 
2aae				; skip dict stub 
2aae cd 85 20				call forth_tok_next 
2ab1			 
2ab1			 
2ab1			; while we have words to look for 
2ab1			 
2ab1 7e				ld a, (hl)      
2ab2			;	if DEBUG_FORTH_WORDS 
2ab2			;		DMARK "LSk" 
2ab2			;		CALLMONITOR 
2ab2			;	endif 
2ab2 fe 00				cp WORD_SYS_END 
2ab4 ca f0 2a				jp z, .flunotfound 
2ab7 fe 01				cp WORD_SYS_UWORD 
2ab9 c2 ae 2a				jp nz, .fldouscan 
2abc			 
2abc			;	if DEBUG_FORTH_WORDS 
2abc			;		DMARK "LSu" 
2abc			;		CALLMONITOR 
2abc			;	endif 
2abc			 
2abc					; found a uword but is it the one we want... 
2abc			 
2abc c5					push bc     ; uword to find is on bc 
2abd d1					pop de 
2abe			 
2abe e5					push hl  ; to save the ptr 
2abf			 
2abf					; skip opcode 
2abf 23					inc hl  
2ac0					; skip next ptr 
2ac0 23					inc hl  
2ac1 23					inc hl 
2ac2					; skip len 
2ac2 23					inc hl 
2ac3			 
2ac3			;	if DEBUG_FORTH_WORDS 
2ac3			;		DMARK "LSc" 
2ac3			;		CALLMONITOR 
2ac3			;	endif 
2ac3 cd 90 11				call strcmp 
2ac6 c2 ad 2a				jp nz, .fldouscanm 
2ac9			; 
2ac9			; 
2ac9			;; while we have words to look for 
2ac9			; 
2ac9			;.fdouscan:	ld a, (hl)      
2ac9			;	if DEBUG_FORTH_WORDS 
2ac9			;		DMARK "LSs" 
2ac9			;		CALLMONITOR 
2ac9			;	endif 
2ac9			;		cp WORD_SYS_END 
2ac9			;		jp z, .fudone 
2ac9			;		cp WORD_SYS_UWORD 
2ac9			;		jp nz, .fnuword 
2ac9			; 
2ac9			;	if DEBUG_FORTH_WORDS 
2ac9			;		DMARK "FGu" 
2ac9			;		CALLMONITOR 
2ac9			;	endif 
2ac9			; 
2ac9			;		; found a uword but is it the one we want... 
2ac9			; 
2ac9			; 
2ac9			;	        pop de   ; get back the dsp name 
2ac9			;		push de 
2ac9			; 
2ac9			;		push hl  ; to save the ptr 
2ac9			; 
2ac9			;		; skip opcode 
2ac9			;		inc hl  
2ac9			;		; skip next ptr 
2ac9			;		inc hl  
2ac9			;		inc hl 
2ac9			;		; skip len 
2ac9			;		inc hl 
2ac9			; 
2ac9			;	if DEBUG_FORTH_WORDS 
2ac9			;		DMARK "FGc" 
2ac9			;		CALLMONITOR 
2ac9			;	endif 
2ac9			;		call strcmp 
2ac9			;		jp nz, .fnuword 
2ac9			 
2ac9			 
2ac9 e1			pop hl 
2aca			 
2aca				 
2aca				if DEBUG_FORTH_WORDS 
2aca					DMARK "FGm" 
2aca f5				push af  
2acb 3a df 2a			ld a, (.dmark)  
2ace 32 6b ee			ld (debug_mark),a  
2ad1 3a e0 2a			ld a, (.dmark+1)  
2ad4 32 6c ee			ld (debug_mark+1),a  
2ad7 3a e1 2a			ld a, (.dmark+2)  
2ada 32 6d ee			ld (debug_mark+2),a  
2add 18 03			jr .pastdmark  
2adf ..			.dmark: db "FGm"  
2ae2 f1			.pastdmark: pop af  
2ae3			endm  
# End of macro DMARK
2ae3					CALLMONITOR 
2ae3 cd 6f ee			call debug_vector  
2ae6				endm  
# End of macro CALLMONITOR
2ae6				endif 
2ae6			 
2ae6			 
2ae6			 
2ae6					; we have a uword so push its name to the stack 
2ae6			 
2ae6			;	   	push hl  ; save so we can move to next dict block 
2ae6			;pop hl 
2ae6			 
2ae6					; update opcode to deleted 
2ae6 3e 03				ld a, WORD_SYS_DELETED 
2ae8 77					ld (hl), a 
2ae9			 
2ae9 23					inc hl  
2aea					; skip next ptr 
2aea 23					inc hl  
2aeb 23					inc hl 
2aec					; skip len 
2aec 23					inc hl 
2aed			 
2aed					; TODO change parser to skip deleted words but for now mark it out 
2aed 3e 5f				ld a, "_" 
2aef 77					ld  (hl),a 
2af0			 
2af0			;		jr .fudone 
2af0			; 
2af0			;.fnuword:	pop hl 
2af0			;		call forth_tok_next 
2af0			;		jp .fdouscan  
2af0			 
2af0			.flunotfound:		  
2af0			 
2af0			 
2af0					 
2af0					FORTH_DSP_POP 
2af0 cd 36 1e			call macro_forth_dsp_pop 
2af3				endm 
# End of macro FORTH_DSP_POP
2af3			;		ld hl, .luno 
2af3			;.fudone:		 pop hl 
2af3					NEXTW 
2af3 c3 34 1f			jp macro_next 
2af6				endm 
# End of macro NEXTW
2af6			.NOP: 
2af6				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2af6 61				db WORD_SYS_CORE+77             
2af7 1d 2b			dw .COMO            
2af9 04				db 3 + 1 
2afa .. 00			db "NOP",0              
2afe				endm 
# End of macro CWHEAD
2afe			; | NOP (  --  ) Do nothing | DONE 
2afe					if DEBUG_FORTH_WORDS_KEY 
2afe						DMARK "NOP" 
2afe f5				push af  
2aff 3a 13 2b			ld a, (.dmark)  
2b02 32 6b ee			ld (debug_mark),a  
2b05 3a 14 2b			ld a, (.dmark+1)  
2b08 32 6c ee			ld (debug_mark+1),a  
2b0b 3a 15 2b			ld a, (.dmark+2)  
2b0e 32 6d ee			ld (debug_mark+2),a  
2b11 18 03			jr .pastdmark  
2b13 ..			.dmark: db "NOP"  
2b16 f1			.pastdmark: pop af  
2b17			endm  
# End of macro DMARK
2b17						CALLMONITOR 
2b17 cd 6f ee			call debug_vector  
2b1a				endm  
# End of macro CALLMONITOR
2b1a					endif 
2b1a				       NEXTW 
2b1a c3 34 1f			jp macro_next 
2b1d				endm 
# End of macro NEXTW
2b1d			.COMO: 
2b1d				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2b1d 6e				db WORD_SYS_CORE+90             
2b1e 6f 2b			dw .COMC            
2b20 02				db 1 + 1 
2b21 .. 00			db "(",0              
2b23				endm 
# End of macro CWHEAD
2b23			; | ( ( -- )  Start of comment | DONE 
2b23			 
2b23			 
2b23 2a c2 e5				ld hl, ( os_tok_ptr) 
2b26 11 6a 2b			ld de, .closepar 
2b29					 
2b29					if DEBUG_FORTH_WORDS 
2b29						DMARK ").." 
2b29 f5				push af  
2b2a 3a 3e 2b			ld a, (.dmark)  
2b2d 32 6b ee			ld (debug_mark),a  
2b30 3a 3f 2b			ld a, (.dmark+1)  
2b33 32 6c ee			ld (debug_mark+1),a  
2b36 3a 40 2b			ld a, (.dmark+2)  
2b39 32 6d ee			ld (debug_mark+2),a  
2b3c 18 03			jr .pastdmark  
2b3e ..			.dmark: db ").."  
2b41 f1			.pastdmark: pop af  
2b42			endm  
# End of macro DMARK
2b42						CALLMONITOR 
2b42 cd 6f ee			call debug_vector  
2b45				endm  
# End of macro CALLMONITOR
2b45					endif 
2b45 cd 4f 20			call findnexttok  
2b48			 
2b48					if DEBUG_FORTH_WORDS 
2b48						DMARK "IF5" 
2b48 f5				push af  
2b49 3a 5d 2b			ld a, (.dmark)  
2b4c 32 6b ee			ld (debug_mark),a  
2b4f 3a 5e 2b			ld a, (.dmark+1)  
2b52 32 6c ee			ld (debug_mark+1),a  
2b55 3a 5f 2b			ld a, (.dmark+2)  
2b58 32 6d ee			ld (debug_mark+2),a  
2b5b 18 03			jr .pastdmark  
2b5d ..			.dmark: db "IF5"  
2b60 f1			.pastdmark: pop af  
2b61			endm  
# End of macro DMARK
2b61						CALLMONITOR 
2b61 cd 6f ee			call debug_vector  
2b64				endm  
# End of macro CALLMONITOR
2b64					endif 
2b64				; replace below with ) exec using tok_ptr 
2b64 22 c2 e5			ld (os_tok_ptr), hl 
2b67 c3 c5 1f			jp exec1 
2b6a			 
2b6a .. 00			.closepar:   db ")",0 
2b6c			 
2b6c				       NEXTW 
2b6c c3 34 1f			jp macro_next 
2b6f				endm 
# End of macro NEXTW
2b6f			.COMC: 
2b6f				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2b6f 6f				db WORD_SYS_CORE+91             
2b70 78 2b			dw .SCRATCH            
2b72 02				db 1 + 1 
2b73 .. 00			db ")",0              
2b75				endm 
# End of macro CWHEAD
2b75			; | ) ( -- )  End of comment |  DONE  
2b75				       NEXTW 
2b75 c3 34 1f			jp macro_next 
2b78				endm 
# End of macro NEXTW
2b78			 
2b78			.SCRATCH: 
2b78				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2b78 6f				db WORD_SYS_CORE+91             
2b79 b3 2b			dw .INC            
2b7b 08				db 7 + 1 
2b7c .. 00			db "SCRATCH",0              
2b84				endm 
# End of macro CWHEAD
2b84			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2b84			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2b84			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2b84			; | |  
2b84			; | | e.g.    : score $00 scratch ; 
2b84			; | |  
2b84			; | | $00 score ! 
2b84			; | | $01 score +! 
2b84			; | |  
2b84			; | | e.g.   : varword $0a scratch ;  
2b84			; | | 
2b84			; | | $8000 varword ! 
2b84					if DEBUG_FORTH_WORDS_KEY 
2b84						DMARK "SCR" 
2b84 f5				push af  
2b85 3a 99 2b			ld a, (.dmark)  
2b88 32 6b ee			ld (debug_mark),a  
2b8b 3a 9a 2b			ld a, (.dmark+1)  
2b8e 32 6c ee			ld (debug_mark+1),a  
2b91 3a 9b 2b			ld a, (.dmark+2)  
2b94 32 6d ee			ld (debug_mark+2),a  
2b97 18 03			jr .pastdmark  
2b99 ..			.dmark: db "SCR"  
2b9c f1			.pastdmark: pop af  
2b9d			endm  
# End of macro DMARK
2b9d						CALLMONITOR 
2b9d cd 6f ee			call debug_vector  
2ba0				endm  
# End of macro CALLMONITOR
2ba0					endif 
2ba0			 
2ba0					FORTH_DSP_VALUEHL 
2ba0 cd 7e 1d			call macro_dsp_valuehl 
2ba3				endm 
# End of macro FORTH_DSP_VALUEHL
2ba3				 
2ba3					FORTH_DSP_POP 
2ba3 cd 36 1e			call macro_forth_dsp_pop 
2ba6				endm 
# End of macro FORTH_DSP_POP
2ba6			 
2ba6 7d					ld a, l 
2ba7 21 e6 e7				ld hl, os_var_array 
2baa cd f2 0d				call addatohl 
2bad			 
2bad cd 79 1b				call forth_push_numhl 
2bb0			 
2bb0				       NEXTW 
2bb0 c3 34 1f			jp macro_next 
2bb3				endm 
# End of macro NEXTW
2bb3			 
2bb3			.INC: 
2bb3				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2bb3 6f				db WORD_SYS_CORE+91             
2bb4 09 2c			dw .DEC            
2bb6 03				db 2 + 1 
2bb7 .. 00			db "+!",0              
2bba				endm 
# End of macro CWHEAD
2bba			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2bba					if DEBUG_FORTH_WORDS_KEY 
2bba						DMARK "+s_" 
2bba f5				push af  
2bbb 3a cf 2b			ld a, (.dmark)  
2bbe 32 6b ee			ld (debug_mark),a  
2bc1 3a d0 2b			ld a, (.dmark+1)  
2bc4 32 6c ee			ld (debug_mark+1),a  
2bc7 3a d1 2b			ld a, (.dmark+2)  
2bca 32 6d ee			ld (debug_mark+2),a  
2bcd 18 03			jr .pastdmark  
2bcf ..			.dmark: db "+s_"  
2bd2 f1			.pastdmark: pop af  
2bd3			endm  
# End of macro DMARK
2bd3						CALLMONITOR 
2bd3 cd 6f ee			call debug_vector  
2bd6				endm  
# End of macro CALLMONITOR
2bd6					endif 
2bd6			 
2bd6					FORTH_DSP_VALUEHL 
2bd6 cd 7e 1d			call macro_dsp_valuehl 
2bd9				endm 
# End of macro FORTH_DSP_VALUEHL
2bd9			 
2bd9 e5					push hl   ; save address 
2bda			 
2bda					FORTH_DSP_POP 
2bda cd 36 1e			call macro_forth_dsp_pop 
2bdd				endm 
# End of macro FORTH_DSP_POP
2bdd			 
2bdd					FORTH_DSP_VALUEHL 
2bdd cd 7e 1d			call macro_dsp_valuehl 
2be0				endm 
# End of macro FORTH_DSP_VALUEHL
2be0			 
2be0 e5					push hl 
2be1					FORTH_DSP_POP 
2be1 cd 36 1e			call macro_forth_dsp_pop 
2be4				endm 
# End of macro FORTH_DSP_POP
2be4 e1					pop hl 
2be5			 
2be5					; hl contains value to add to byte at a 
2be5				 
2be5 eb					ex de, hl 
2be6			 
2be6 e1					pop hl 
2be7			 
2be7					if DEBUG_FORTH_WORDS 
2be7						DMARK "INC" 
2be7 f5				push af  
2be8 3a fc 2b			ld a, (.dmark)  
2beb 32 6b ee			ld (debug_mark),a  
2bee 3a fd 2b			ld a, (.dmark+1)  
2bf1 32 6c ee			ld (debug_mark+1),a  
2bf4 3a fe 2b			ld a, (.dmark+2)  
2bf7 32 6d ee			ld (debug_mark+2),a  
2bfa 18 03			jr .pastdmark  
2bfc ..			.dmark: db "INC"  
2bff f1			.pastdmark: pop af  
2c00			endm  
# End of macro DMARK
2c00						CALLMONITOR 
2c00 cd 6f ee			call debug_vector  
2c03				endm  
# End of macro CALLMONITOR
2c03					endif 
2c03			 
2c03 7e					ld a,(hl) 
2c04 83					add e 
2c05 77					ld (hl),a 
2c06			 
2c06			 
2c06			 
2c06				       NEXTW 
2c06 c3 34 1f			jp macro_next 
2c09				endm 
# End of macro NEXTW
2c09			 
2c09			.DEC: 
2c09				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2c09 6f				db WORD_SYS_CORE+91             
2c0a 5d 2c			dw .INC2            
2c0c 03				db 2 + 1 
2c0d .. 00			db "-!",0              
2c10				endm 
# End of macro CWHEAD
2c10			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2c10					if DEBUG_FORTH_WORDS_KEY 
2c10						DMARK "-s_" 
2c10 f5				push af  
2c11 3a 25 2c			ld a, (.dmark)  
2c14 32 6b ee			ld (debug_mark),a  
2c17 3a 26 2c			ld a, (.dmark+1)  
2c1a 32 6c ee			ld (debug_mark+1),a  
2c1d 3a 27 2c			ld a, (.dmark+2)  
2c20 32 6d ee			ld (debug_mark+2),a  
2c23 18 03			jr .pastdmark  
2c25 ..			.dmark: db "-s_"  
2c28 f1			.pastdmark: pop af  
2c29			endm  
# End of macro DMARK
2c29						CALLMONITOR 
2c29 cd 6f ee			call debug_vector  
2c2c				endm  
# End of macro CALLMONITOR
2c2c					endif 
2c2c			 
2c2c					FORTH_DSP_VALUEHL 
2c2c cd 7e 1d			call macro_dsp_valuehl 
2c2f				endm 
# End of macro FORTH_DSP_VALUEHL
2c2f			 
2c2f e5					push hl   ; save address 
2c30			 
2c30					FORTH_DSP_POP 
2c30 cd 36 1e			call macro_forth_dsp_pop 
2c33				endm 
# End of macro FORTH_DSP_POP
2c33			 
2c33					FORTH_DSP_VALUEHL 
2c33 cd 7e 1d			call macro_dsp_valuehl 
2c36				endm 
# End of macro FORTH_DSP_VALUEHL
2c36			 
2c36					; hl contains value to add to byte at a 
2c36				 
2c36 eb					ex de, hl 
2c37			 
2c37 e1					pop hl 
2c38			 
2c38					if DEBUG_FORTH_WORDS 
2c38						DMARK "DEC" 
2c38 f5				push af  
2c39 3a 4d 2c			ld a, (.dmark)  
2c3c 32 6b ee			ld (debug_mark),a  
2c3f 3a 4e 2c			ld a, (.dmark+1)  
2c42 32 6c ee			ld (debug_mark+1),a  
2c45 3a 4f 2c			ld a, (.dmark+2)  
2c48 32 6d ee			ld (debug_mark+2),a  
2c4b 18 03			jr .pastdmark  
2c4d ..			.dmark: db "DEC"  
2c50 f1			.pastdmark: pop af  
2c51			endm  
# End of macro DMARK
2c51						CALLMONITOR 
2c51 cd 6f ee			call debug_vector  
2c54				endm  
# End of macro CALLMONITOR
2c54					endif 
2c54			 
2c54 7e					ld a,(hl) 
2c55 93					sub e 
2c56 77					ld (hl),a 
2c57			 
2c57			 
2c57					FORTH_DSP_POP 
2c57 cd 36 1e			call macro_forth_dsp_pop 
2c5a				endm 
# End of macro FORTH_DSP_POP
2c5a			 
2c5a				       NEXTW 
2c5a c3 34 1f			jp macro_next 
2c5d				endm 
# End of macro NEXTW
2c5d			 
2c5d			.INC2: 
2c5d				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2c5d 6f				db WORD_SYS_CORE+91             
2c5e 0a 2d			dw .DEC2            
2c60 04				db 3 + 1 
2c61 .. 00			db "+2!",0              
2c65				endm 
# End of macro CWHEAD
2c65			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2c65			 
2c65					if DEBUG_FORTH_WORDS_KEY 
2c65						DMARK "+2s" 
2c65 f5				push af  
2c66 3a 7a 2c			ld a, (.dmark)  
2c69 32 6b ee			ld (debug_mark),a  
2c6c 3a 7b 2c			ld a, (.dmark+1)  
2c6f 32 6c ee			ld (debug_mark+1),a  
2c72 3a 7c 2c			ld a, (.dmark+2)  
2c75 32 6d ee			ld (debug_mark+2),a  
2c78 18 03			jr .pastdmark  
2c7a ..			.dmark: db "+2s"  
2c7d f1			.pastdmark: pop af  
2c7e			endm  
# End of macro DMARK
2c7e						CALLMONITOR 
2c7e cd 6f ee			call debug_vector  
2c81				endm  
# End of macro CALLMONITOR
2c81					endif 
2c81			 
2c81					; Address 
2c81			 
2c81					FORTH_DSP_VALUEHL 
2c81 cd 7e 1d			call macro_dsp_valuehl 
2c84				endm 
# End of macro FORTH_DSP_VALUEHL
2c84			 
2c84 e5					push hl    ; save address 
2c85			 
2c85					; load content into de 
2c85			 
2c85 5e					ld e,(hl) 
2c86 23					inc hl 
2c87 56					ld d, (hl) 
2c88			 
2c88					if DEBUG_FORTH_WORDS 
2c88						DMARK "+2a" 
2c88 f5				push af  
2c89 3a 9d 2c			ld a, (.dmark)  
2c8c 32 6b ee			ld (debug_mark),a  
2c8f 3a 9e 2c			ld a, (.dmark+1)  
2c92 32 6c ee			ld (debug_mark+1),a  
2c95 3a 9f 2c			ld a, (.dmark+2)  
2c98 32 6d ee			ld (debug_mark+2),a  
2c9b 18 03			jr .pastdmark  
2c9d ..			.dmark: db "+2a"  
2ca0 f1			.pastdmark: pop af  
2ca1			endm  
# End of macro DMARK
2ca1						CALLMONITOR 
2ca1 cd 6f ee			call debug_vector  
2ca4				endm  
# End of macro CALLMONITOR
2ca4					endif 
2ca4			 
2ca4					FORTH_DSP_POP 
2ca4 cd 36 1e			call macro_forth_dsp_pop 
2ca7				endm 
# End of macro FORTH_DSP_POP
2ca7			 
2ca7					; Get value to add 
2ca7			 
2ca7					FORTH_DSP_VALUE 
2ca7 cd 67 1d			call macro_forth_dsp_value 
2caa				endm 
# End of macro FORTH_DSP_VALUE
2caa			 
2caa					if DEBUG_FORTH_WORDS 
2caa						DMARK "+2v" 
2caa f5				push af  
2cab 3a bf 2c			ld a, (.dmark)  
2cae 32 6b ee			ld (debug_mark),a  
2cb1 3a c0 2c			ld a, (.dmark+1)  
2cb4 32 6c ee			ld (debug_mark+1),a  
2cb7 3a c1 2c			ld a, (.dmark+2)  
2cba 32 6d ee			ld (debug_mark+2),a  
2cbd 18 03			jr .pastdmark  
2cbf ..			.dmark: db "+2v"  
2cc2 f1			.pastdmark: pop af  
2cc3			endm  
# End of macro DMARK
2cc3						CALLMONITOR 
2cc3 cd 6f ee			call debug_vector  
2cc6				endm  
# End of macro CALLMONITOR
2cc6					endif 
2cc6			 
2cc6 19					add hl, de 
2cc7			 
2cc7					if DEBUG_FORTH_WORDS 
2cc7						DMARK "+2+" 
2cc7 f5				push af  
2cc8 3a dc 2c			ld a, (.dmark)  
2ccb 32 6b ee			ld (debug_mark),a  
2cce 3a dd 2c			ld a, (.dmark+1)  
2cd1 32 6c ee			ld (debug_mark+1),a  
2cd4 3a de 2c			ld a, (.dmark+2)  
2cd7 32 6d ee			ld (debug_mark+2),a  
2cda 18 03			jr .pastdmark  
2cdc ..			.dmark: db "+2+"  
2cdf f1			.pastdmark: pop af  
2ce0			endm  
# End of macro DMARK
2ce0						CALLMONITOR 
2ce0 cd 6f ee			call debug_vector  
2ce3				endm  
# End of macro CALLMONITOR
2ce3					endif 
2ce3			 
2ce3					; move result to de 
2ce3			 
2ce3 eb					ex de, hl 
2ce4			 
2ce4					; Address 
2ce4			 
2ce4 e1					pop hl 
2ce5			 
2ce5					; save it back 
2ce5			 
2ce5 73					ld (hl), e 
2ce6 23					inc hl 
2ce7 72					ld (hl), d 
2ce8			 
2ce8					if DEBUG_FORTH_WORDS 
2ce8						DMARK "+2e" 
2ce8 f5				push af  
2ce9 3a fd 2c			ld a, (.dmark)  
2cec 32 6b ee			ld (debug_mark),a  
2cef 3a fe 2c			ld a, (.dmark+1)  
2cf2 32 6c ee			ld (debug_mark+1),a  
2cf5 3a ff 2c			ld a, (.dmark+2)  
2cf8 32 6d ee			ld (debug_mark+2),a  
2cfb 18 03			jr .pastdmark  
2cfd ..			.dmark: db "+2e"  
2d00 f1			.pastdmark: pop af  
2d01			endm  
# End of macro DMARK
2d01						CALLMONITOR 
2d01 cd 6f ee			call debug_vector  
2d04				endm  
# End of macro CALLMONITOR
2d04					endif 
2d04			 
2d04			 
2d04			 
2d04					FORTH_DSP_POP 
2d04 cd 36 1e			call macro_forth_dsp_pop 
2d07				endm 
# End of macro FORTH_DSP_POP
2d07			 
2d07			 
2d07				       NEXTW 
2d07 c3 34 1f			jp macro_next 
2d0a				endm 
# End of macro NEXTW
2d0a			 
2d0a			.DEC2: 
2d0a				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2d0a 6f				db WORD_SYS_CORE+91             
2d0b b9 2d			dw .GET2            
2d0d 04				db 3 + 1 
2d0e .. 00			db "-2!",0              
2d12				endm 
# End of macro CWHEAD
2d12			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2d12			 
2d12			 
2d12					if DEBUG_FORTH_WORDS_KEY 
2d12						DMARK "-2s" 
2d12 f5				push af  
2d13 3a 27 2d			ld a, (.dmark)  
2d16 32 6b ee			ld (debug_mark),a  
2d19 3a 28 2d			ld a, (.dmark+1)  
2d1c 32 6c ee			ld (debug_mark+1),a  
2d1f 3a 29 2d			ld a, (.dmark+2)  
2d22 32 6d ee			ld (debug_mark+2),a  
2d25 18 03			jr .pastdmark  
2d27 ..			.dmark: db "-2s"  
2d2a f1			.pastdmark: pop af  
2d2b			endm  
# End of macro DMARK
2d2b						CALLMONITOR 
2d2b cd 6f ee			call debug_vector  
2d2e				endm  
# End of macro CALLMONITOR
2d2e					endif 
2d2e			 
2d2e					; Address 
2d2e			 
2d2e					FORTH_DSP_VALUEHL 
2d2e cd 7e 1d			call macro_dsp_valuehl 
2d31				endm 
# End of macro FORTH_DSP_VALUEHL
2d31			 
2d31 e5					push hl    ; save address 
2d32			 
2d32					; load content into de 
2d32			 
2d32 5e					ld e,(hl) 
2d33 23					inc hl 
2d34 56					ld d, (hl) 
2d35			 
2d35					if DEBUG_FORTH_WORDS 
2d35						DMARK "-2a" 
2d35 f5				push af  
2d36 3a 4a 2d			ld a, (.dmark)  
2d39 32 6b ee			ld (debug_mark),a  
2d3c 3a 4b 2d			ld a, (.dmark+1)  
2d3f 32 6c ee			ld (debug_mark+1),a  
2d42 3a 4c 2d			ld a, (.dmark+2)  
2d45 32 6d ee			ld (debug_mark+2),a  
2d48 18 03			jr .pastdmark  
2d4a ..			.dmark: db "-2a"  
2d4d f1			.pastdmark: pop af  
2d4e			endm  
# End of macro DMARK
2d4e						CALLMONITOR 
2d4e cd 6f ee			call debug_vector  
2d51				endm  
# End of macro CALLMONITOR
2d51					endif 
2d51			 
2d51					FORTH_DSP_POP 
2d51 cd 36 1e			call macro_forth_dsp_pop 
2d54				endm 
# End of macro FORTH_DSP_POP
2d54			 
2d54					; Get value to remove 
2d54			 
2d54					FORTH_DSP_VALUE 
2d54 cd 67 1d			call macro_forth_dsp_value 
2d57				endm 
# End of macro FORTH_DSP_VALUE
2d57			 
2d57					if DEBUG_FORTH_WORDS 
2d57						DMARK "-2v" 
2d57 f5				push af  
2d58 3a 6c 2d			ld a, (.dmark)  
2d5b 32 6b ee			ld (debug_mark),a  
2d5e 3a 6d 2d			ld a, (.dmark+1)  
2d61 32 6c ee			ld (debug_mark+1),a  
2d64 3a 6e 2d			ld a, (.dmark+2)  
2d67 32 6d ee			ld (debug_mark+2),a  
2d6a 18 03			jr .pastdmark  
2d6c ..			.dmark: db "-2v"  
2d6f f1			.pastdmark: pop af  
2d70			endm  
# End of macro DMARK
2d70						CALLMONITOR 
2d70 cd 6f ee			call debug_vector  
2d73				endm  
# End of macro CALLMONITOR
2d73					endif 
2d73			 
2d73 eb					ex de, hl 
2d74 ed 52				sbc hl, de 
2d76			 
2d76					if DEBUG_FORTH_WORDS 
2d76						DMARK "-2d" 
2d76 f5				push af  
2d77 3a 8b 2d			ld a, (.dmark)  
2d7a 32 6b ee			ld (debug_mark),a  
2d7d 3a 8c 2d			ld a, (.dmark+1)  
2d80 32 6c ee			ld (debug_mark+1),a  
2d83 3a 8d 2d			ld a, (.dmark+2)  
2d86 32 6d ee			ld (debug_mark+2),a  
2d89 18 03			jr .pastdmark  
2d8b ..			.dmark: db "-2d"  
2d8e f1			.pastdmark: pop af  
2d8f			endm  
# End of macro DMARK
2d8f						CALLMONITOR 
2d8f cd 6f ee			call debug_vector  
2d92				endm  
# End of macro CALLMONITOR
2d92					endif 
2d92			 
2d92					; move result to de 
2d92			 
2d92 eb					ex de, hl 
2d93			 
2d93					; Address 
2d93			 
2d93 e1					pop hl 
2d94			 
2d94					; save it back 
2d94			 
2d94 73					ld (hl), e 
2d95 23					inc hl 
2d96 72					ld (hl), d 
2d97			 
2d97					if DEBUG_FORTH_WORDS 
2d97						DMARK "-2e" 
2d97 f5				push af  
2d98 3a ac 2d			ld a, (.dmark)  
2d9b 32 6b ee			ld (debug_mark),a  
2d9e 3a ad 2d			ld a, (.dmark+1)  
2da1 32 6c ee			ld (debug_mark+1),a  
2da4 3a ae 2d			ld a, (.dmark+2)  
2da7 32 6d ee			ld (debug_mark+2),a  
2daa 18 03			jr .pastdmark  
2dac ..			.dmark: db "-2e"  
2daf f1			.pastdmark: pop af  
2db0			endm  
# End of macro DMARK
2db0						CALLMONITOR 
2db0 cd 6f ee			call debug_vector  
2db3				endm  
# End of macro CALLMONITOR
2db3					endif 
2db3			 
2db3			 
2db3					FORTH_DSP_POP 
2db3 cd 36 1e			call macro_forth_dsp_pop 
2db6				endm 
# End of macro FORTH_DSP_POP
2db6			 
2db6			 
2db6			 
2db6				       NEXTW 
2db6 c3 34 1f			jp macro_next 
2db9				endm 
# End of macro NEXTW
2db9			.GET2: 
2db9				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2db9 6f				db WORD_SYS_CORE+91             
2dba ee 2d			dw .BANG2            
2dbc 03				db 2 + 1 
2dbd .. 00			db "2@",0              
2dc0				endm 
# End of macro CWHEAD
2dc0			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2dc0					if DEBUG_FORTH_WORDS_KEY 
2dc0						DMARK "2A_" 
2dc0 f5				push af  
2dc1 3a d5 2d			ld a, (.dmark)  
2dc4 32 6b ee			ld (debug_mark),a  
2dc7 3a d6 2d			ld a, (.dmark+1)  
2dca 32 6c ee			ld (debug_mark+1),a  
2dcd 3a d7 2d			ld a, (.dmark+2)  
2dd0 32 6d ee			ld (debug_mark+2),a  
2dd3 18 03			jr .pastdmark  
2dd5 ..			.dmark: db "2A_"  
2dd8 f1			.pastdmark: pop af  
2dd9			endm  
# End of macro DMARK
2dd9						CALLMONITOR 
2dd9 cd 6f ee			call debug_vector  
2ddc				endm  
# End of macro CALLMONITOR
2ddc					endif 
2ddc			 
2ddc					FORTH_DSP_VALUEHL 
2ddc cd 7e 1d			call macro_dsp_valuehl 
2ddf				endm 
# End of macro FORTH_DSP_VALUEHL
2ddf			 
2ddf e5					push hl   ; save address 
2de0			 
2de0					FORTH_DSP_POP 
2de0 cd 36 1e			call macro_forth_dsp_pop 
2de3				endm 
# End of macro FORTH_DSP_POP
2de3			 
2de3 e1					pop hl 
2de4			 
2de4 5e					ld e, (hl) 
2de5 23					inc hl 
2de6 56					ld d, (hl) 
2de7			 
2de7 eb					ex de, hl 
2de8			 
2de8 cd 79 1b				call forth_push_numhl 
2deb			 
2deb				       NEXTW 
2deb c3 34 1f			jp macro_next 
2dee				endm 
# End of macro NEXTW
2dee			.BANG2: 
2dee				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2dee 6f				db WORD_SYS_CORE+91             
2def 26 2e			dw .CONFIG            
2df1 03				db 2 + 1 
2df2 .. 00			db "2!",0              
2df5				endm 
# End of macro CWHEAD
2df5			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2df5					if DEBUG_FORTH_WORDS_KEY 
2df5						DMARK "2S_" 
2df5 f5				push af  
2df6 3a 0a 2e			ld a, (.dmark)  
2df9 32 6b ee			ld (debug_mark),a  
2dfc 3a 0b 2e			ld a, (.dmark+1)  
2dff 32 6c ee			ld (debug_mark+1),a  
2e02 3a 0c 2e			ld a, (.dmark+2)  
2e05 32 6d ee			ld (debug_mark+2),a  
2e08 18 03			jr .pastdmark  
2e0a ..			.dmark: db "2S_"  
2e0d f1			.pastdmark: pop af  
2e0e			endm  
# End of macro DMARK
2e0e						CALLMONITOR 
2e0e cd 6f ee			call debug_vector  
2e11				endm  
# End of macro CALLMONITOR
2e11					endif 
2e11			 
2e11					FORTH_DSP_VALUEHL 
2e11 cd 7e 1d			call macro_dsp_valuehl 
2e14				endm 
# End of macro FORTH_DSP_VALUEHL
2e14			 
2e14 e5					push hl   ; save address 
2e15			 
2e15			 
2e15					FORTH_DSP_POP 
2e15 cd 36 1e			call macro_forth_dsp_pop 
2e18				endm 
# End of macro FORTH_DSP_POP
2e18			 
2e18					 
2e18					FORTH_DSP_VALUEHL 
2e18 cd 7e 1d			call macro_dsp_valuehl 
2e1b				endm 
# End of macro FORTH_DSP_VALUEHL
2e1b			 
2e1b					FORTH_DSP_POP 
2e1b cd 36 1e			call macro_forth_dsp_pop 
2e1e				endm 
# End of macro FORTH_DSP_POP
2e1e			 
2e1e eb					ex de, hl    ; value now in de 
2e1f			 
2e1f e1					pop hl 
2e20			 
2e20 73					ld (hl), e 
2e21			 
2e21 23					inc hl 
2e22			 
2e22 72					ld (hl), d 
2e23			 
2e23			 
2e23				       NEXTW 
2e23 c3 34 1f			jp macro_next 
2e26				endm 
# End of macro NEXTW
2e26			.CONFIG: 
2e26				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2e26 6f				db WORD_SYS_CORE+91             
2e27 37 2e			dw .ADTOS            
2e29 07				db 6 + 1 
2e2a .. 00			db "CONFIG",0              
2e31				endm 
# End of macro CWHEAD
2e31			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2e31			 
2e31 cd 66 13				call config 
2e34					NEXTW 
2e34 c3 34 1f			jp macro_next 
2e37				endm 
# End of macro NEXTW
2e37			 
2e37			.ADTOS: 
2e37				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2e37 6f				db WORD_SYS_CORE+91             
2e38 4d 2e			dw .SBTOS            
2e3a 03				db 2 + 1 
2e3b .. 00			db "1+",0              
2e3e				endm 
# End of macro CWHEAD
2e3e			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2e3e			 
2e3e					FORTH_DSP_VALUEHL 
2e3e cd 7e 1d			call macro_dsp_valuehl 
2e41				endm 
# End of macro FORTH_DSP_VALUEHL
2e41 e5					push hl 
2e42			 
2e42					FORTH_DSP_POP 
2e42 cd 36 1e			call macro_forth_dsp_pop 
2e45				endm 
# End of macro FORTH_DSP_POP
2e45 e1					pop hl 
2e46			 
2e46 23					inc hl 
2e47 cd 79 1b				call forth_push_numhl 
2e4a					 
2e4a					NEXTW 
2e4a c3 34 1f			jp macro_next 
2e4d				endm 
# End of macro NEXTW
2e4d			.SBTOS: 
2e4d				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2e4d 6f				db WORD_SYS_CORE+91             
2e4e 63 2e			dw .ADSTORE            
2e50 03				db 2 + 1 
2e51 .. 00			db "1-",0              
2e54				endm 
# End of macro CWHEAD
2e54			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2e54			 
2e54					FORTH_DSP_VALUEHL 
2e54 cd 7e 1d			call macro_dsp_valuehl 
2e57				endm 
# End of macro FORTH_DSP_VALUEHL
2e57 e5					push hl 
2e58			 
2e58					FORTH_DSP_POP 
2e58 cd 36 1e			call macro_forth_dsp_pop 
2e5b				endm 
# End of macro FORTH_DSP_POP
2e5b e1					pop hl 
2e5c			 
2e5c 2b					dec hl 
2e5d cd 79 1b				call forth_push_numhl 
2e60					 
2e60					NEXTW 
2e60 c3 34 1f			jp macro_next 
2e63				endm 
# End of macro NEXTW
2e63			.ADSTORE: 
2e63				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2e63 6f				db WORD_SYS_CORE+91             
2e64 79 2e			dw .ADWSTORE            
2e66 04				db 3 + 1 
2e67 .. 00			db "1+!",0              
2e6b				endm 
# End of macro CWHEAD
2e6b			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2e6b			 
2e6b					FORTH_DSP_VALUEHL 
2e6b cd 7e 1d			call macro_dsp_valuehl 
2e6e				endm 
# End of macro FORTH_DSP_VALUEHL
2e6e e5					push hl 
2e6f			 
2e6f					FORTH_DSP_POP 
2e6f cd 36 1e			call macro_forth_dsp_pop 
2e72				endm 
# End of macro FORTH_DSP_POP
2e72 e1					pop hl 
2e73			 
2e73 7e					ld a, (hl) 
2e74 3c					inc a 
2e75 77					ld (hl), a 
2e76					 
2e76					NEXTW 
2e76 c3 34 1f			jp macro_next 
2e79				endm 
# End of macro NEXTW
2e79			.ADWSTORE: 
2e79				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
2e79 6f				db WORD_SYS_CORE+91             
2e7a 97 2e			dw .SBSTORE            
2e7c 05				db 4 + 1 
2e7d .. 00			db "1+2!",0              
2e82				endm 
# End of macro CWHEAD
2e82			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2e82			 
2e82					FORTH_DSP_VALUEHL 
2e82 cd 7e 1d			call macro_dsp_valuehl 
2e85				endm 
# End of macro FORTH_DSP_VALUEHL
2e85 e5					push hl 
2e86			 
2e86					FORTH_DSP_POP 
2e86 cd 36 1e			call macro_forth_dsp_pop 
2e89				endm 
# End of macro FORTH_DSP_POP
2e89 e1					pop hl 
2e8a			 
2e8a e5					push hl 
2e8b			 
2e8b cd b6 1e				call loadwordinhl 
2e8e 23					inc hl 
2e8f			 
2e8f d1					pop de 
2e90 eb					ex de, hl 
2e91 73					ld (hl), e 
2e92 23					inc hl 
2e93 72					ld (hl), d 
2e94					 
2e94					NEXTW 
2e94 c3 34 1f			jp macro_next 
2e97				endm 
# End of macro NEXTW
2e97			.SBSTORE: 
2e97				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
2e97 6f				db WORD_SYS_CORE+91             
2e98 ad 2e			dw .SBWSTORE            
2e9a 04				db 3 + 1 
2e9b .. 00			db "1-!",0              
2e9f				endm 
# End of macro CWHEAD
2e9f			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
2e9f			 
2e9f					FORTH_DSP_VALUEHL 
2e9f cd 7e 1d			call macro_dsp_valuehl 
2ea2				endm 
# End of macro FORTH_DSP_VALUEHL
2ea2 e5					push hl 
2ea3			 
2ea3					FORTH_DSP_POP 
2ea3 cd 36 1e			call macro_forth_dsp_pop 
2ea6				endm 
# End of macro FORTH_DSP_POP
2ea6 e1					pop hl 
2ea7			 
2ea7 7e					ld a, (hl) 
2ea8 3d					dec a 
2ea9 77					ld (hl), a 
2eaa					 
2eaa					NEXTW 
2eaa c3 34 1f			jp macro_next 
2ead				endm 
# End of macro NEXTW
2ead			.SBWSTORE: 
2ead				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
2ead 6f				db WORD_SYS_CORE+91             
2eae cb 2e			dw .ENDCORE            
2eb0 05				db 4 + 1 
2eb1 .. 00			db "1-2!",0              
2eb6				endm 
# End of macro CWHEAD
2eb6			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
2eb6			 
2eb6					FORTH_DSP_VALUEHL 
2eb6 cd 7e 1d			call macro_dsp_valuehl 
2eb9				endm 
# End of macro FORTH_DSP_VALUEHL
2eb9 e5					push hl 
2eba			 
2eba					FORTH_DSP_POP 
2eba cd 36 1e			call macro_forth_dsp_pop 
2ebd				endm 
# End of macro FORTH_DSP_POP
2ebd e1					pop hl 
2ebe			 
2ebe e5					push hl 
2ebf			 
2ebf cd b6 1e				call loadwordinhl 
2ec2 2b					dec hl 
2ec3			 
2ec3 d1					pop de 
2ec4 eb					ex de, hl 
2ec5 73					ld (hl), e 
2ec6 23					inc hl 
2ec7 72					ld (hl), d 
2ec8					 
2ec8					NEXTW 
2ec8 c3 34 1f			jp macro_next 
2ecb				endm 
# End of macro NEXTW
2ecb			.ENDCORE: 
2ecb			 
2ecb			; eof 
2ecb			 
2ecb			 
# End of file forth_words_core.asm
2ecb			include "forth_words_flow.asm" 
2ecb			 
2ecb			; | ## Program Flow Words 
2ecb			 
2ecb			.IF: 
2ecb				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2ecb 1e				db WORD_SYS_CORE+10             
2ecc c0 2f			dw .THEN            
2ece 03				db 2 + 1 
2ecf .. 00			db "IF",0              
2ed2				endm 
# End of macro CWHEAD
2ed2			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2ed2			; 
2ed2					if DEBUG_FORTH_WORDS_KEY 
2ed2						DMARK "IF." 
2ed2 f5				push af  
2ed3 3a e7 2e			ld a, (.dmark)  
2ed6 32 6b ee			ld (debug_mark),a  
2ed9 3a e8 2e			ld a, (.dmark+1)  
2edc 32 6c ee			ld (debug_mark+1),a  
2edf 3a e9 2e			ld a, (.dmark+2)  
2ee2 32 6d ee			ld (debug_mark+2),a  
2ee5 18 03			jr .pastdmark  
2ee7 ..			.dmark: db "IF."  
2eea f1			.pastdmark: pop af  
2eeb			endm  
# End of macro DMARK
2eeb						CALLMONITOR 
2eeb cd 6f ee			call debug_vector  
2eee				endm  
# End of macro CALLMONITOR
2eee					endif 
2eee			; eval TOS 
2eee			 
2eee				FORTH_DSP_VALUEHL 
2eee cd 7e 1d			call macro_dsp_valuehl 
2ef1				endm 
# End of macro FORTH_DSP_VALUEHL
2ef1			 
2ef1			;	push hl 
2ef1				FORTH_DSP_POP 
2ef1 cd 36 1e			call macro_forth_dsp_pop 
2ef4				endm 
# End of macro FORTH_DSP_POP
2ef4			;	pop hl 
2ef4			 
2ef4					if DEBUG_FORTH_WORDS 
2ef4						DMARK "IF1" 
2ef4 f5				push af  
2ef5 3a 09 2f			ld a, (.dmark)  
2ef8 32 6b ee			ld (debug_mark),a  
2efb 3a 0a 2f			ld a, (.dmark+1)  
2efe 32 6c ee			ld (debug_mark+1),a  
2f01 3a 0b 2f			ld a, (.dmark+2)  
2f04 32 6d ee			ld (debug_mark+2),a  
2f07 18 03			jr .pastdmark  
2f09 ..			.dmark: db "IF1"  
2f0c f1			.pastdmark: pop af  
2f0d			endm  
# End of macro DMARK
2f0d						CALLMONITOR 
2f0d cd 6f ee			call debug_vector  
2f10				endm  
# End of macro CALLMONITOR
2f10					endif 
2f10 b7				or a        ; clear carry flag 
2f11 11 00 00			ld de, 0 
2f14 eb				ex de,hl 
2f15 ed 52			sbc hl, de 
2f17 c2 a1 2f			jp nz, .iftrue 
2f1a			 
2f1a					if DEBUG_FORTH_WORDS 
2f1a						DMARK "IF2" 
2f1a f5				push af  
2f1b 3a 2f 2f			ld a, (.dmark)  
2f1e 32 6b ee			ld (debug_mark),a  
2f21 3a 30 2f			ld a, (.dmark+1)  
2f24 32 6c ee			ld (debug_mark+1),a  
2f27 3a 31 2f			ld a, (.dmark+2)  
2f2a 32 6d ee			ld (debug_mark+2),a  
2f2d 18 03			jr .pastdmark  
2f2f ..			.dmark: db "IF2"  
2f32 f1			.pastdmark: pop af  
2f33			endm  
# End of macro DMARK
2f33						CALLMONITOR 
2f33 cd 6f ee			call debug_vector  
2f36				endm  
# End of macro CALLMONITOR
2f36					endif 
2f36			 
2f36			; if not true then skip to THEN 
2f36			 
2f36				; TODO get tok_ptr 
2f36				; TODO consume toks until we get to THEN 
2f36			 
2f36 2a c2 e5			ld hl, (os_tok_ptr) 
2f39					if DEBUG_FORTH_WORDS 
2f39						DMARK "IF3" 
2f39 f5				push af  
2f3a 3a 4e 2f			ld a, (.dmark)  
2f3d 32 6b ee			ld (debug_mark),a  
2f40 3a 4f 2f			ld a, (.dmark+1)  
2f43 32 6c ee			ld (debug_mark+1),a  
2f46 3a 50 2f			ld a, (.dmark+2)  
2f49 32 6d ee			ld (debug_mark+2),a  
2f4c 18 03			jr .pastdmark  
2f4e ..			.dmark: db "IF3"  
2f51 f1			.pastdmark: pop af  
2f52			endm  
# End of macro DMARK
2f52						CALLMONITOR 
2f52 cd 6f ee			call debug_vector  
2f55				endm  
# End of macro CALLMONITOR
2f55						 
2f55					endif 
2f55 11 9c 2f			ld de, .ifthen 
2f58					if DEBUG_FORTH_WORDS 
2f58						DMARK "IF4" 
2f58 f5				push af  
2f59 3a 6d 2f			ld a, (.dmark)  
2f5c 32 6b ee			ld (debug_mark),a  
2f5f 3a 6e 2f			ld a, (.dmark+1)  
2f62 32 6c ee			ld (debug_mark+1),a  
2f65 3a 6f 2f			ld a, (.dmark+2)  
2f68 32 6d ee			ld (debug_mark+2),a  
2f6b 18 03			jr .pastdmark  
2f6d ..			.dmark: db "IF4"  
2f70 f1			.pastdmark: pop af  
2f71			endm  
# End of macro DMARK
2f71						CALLMONITOR 
2f71 cd 6f ee			call debug_vector  
2f74				endm  
# End of macro CALLMONITOR
2f74					endif 
2f74 cd 4f 20			call findnexttok  
2f77			 
2f77					if DEBUG_FORTH_WORDS 
2f77						DMARK "IF5" 
2f77 f5				push af  
2f78 3a 8c 2f			ld a, (.dmark)  
2f7b 32 6b ee			ld (debug_mark),a  
2f7e 3a 8d 2f			ld a, (.dmark+1)  
2f81 32 6c ee			ld (debug_mark+1),a  
2f84 3a 8e 2f			ld a, (.dmark+2)  
2f87 32 6d ee			ld (debug_mark+2),a  
2f8a 18 03			jr .pastdmark  
2f8c ..			.dmark: db "IF5"  
2f8f f1			.pastdmark: pop af  
2f90			endm  
# End of macro DMARK
2f90						CALLMONITOR 
2f90 cd 6f ee			call debug_vector  
2f93				endm  
# End of macro CALLMONITOR
2f93					endif 
2f93				; TODO replace below with ; exec using tok_ptr 
2f93 22 c2 e5			ld (os_tok_ptr), hl 
2f96 c3 c5 1f			jp exec1 
2f99				NEXTW 
2f99 c3 34 1f			jp macro_next 
2f9c				endm 
# End of macro NEXTW
2f9c			 
2f9c .. 00		.ifthen:  db "THEN",0 
2fa1			 
2fa1			.iftrue:		 
2fa1				; Exec next words normally 
2fa1			 
2fa1				; if true then exec following IF as normal 
2fa1					if DEBUG_FORTH_WORDS 
2fa1						DMARK "IFT" 
2fa1 f5				push af  
2fa2 3a b6 2f			ld a, (.dmark)  
2fa5 32 6b ee			ld (debug_mark),a  
2fa8 3a b7 2f			ld a, (.dmark+1)  
2fab 32 6c ee			ld (debug_mark+1),a  
2fae 3a b8 2f			ld a, (.dmark+2)  
2fb1 32 6d ee			ld (debug_mark+2),a  
2fb4 18 03			jr .pastdmark  
2fb6 ..			.dmark: db "IFT"  
2fb9 f1			.pastdmark: pop af  
2fba			endm  
# End of macro DMARK
2fba						CALLMONITOR 
2fba cd 6f ee			call debug_vector  
2fbd				endm  
# End of macro CALLMONITOR
2fbd					endif 
2fbd			 
2fbd					NEXTW 
2fbd c3 34 1f			jp macro_next 
2fc0				endm 
# End of macro NEXTW
2fc0			.THEN: 
2fc0				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2fc0 1f				db WORD_SYS_CORE+11             
2fc1 e8 2f			dw .ELSE            
2fc3 05				db 4 + 1 
2fc4 .. 00			db "THEN",0              
2fc9				endm 
# End of macro CWHEAD
2fc9			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2fc9					if DEBUG_FORTH_WORDS_KEY 
2fc9						DMARK "THN" 
2fc9 f5				push af  
2fca 3a de 2f			ld a, (.dmark)  
2fcd 32 6b ee			ld (debug_mark),a  
2fd0 3a df 2f			ld a, (.dmark+1)  
2fd3 32 6c ee			ld (debug_mark+1),a  
2fd6 3a e0 2f			ld a, (.dmark+2)  
2fd9 32 6d ee			ld (debug_mark+2),a  
2fdc 18 03			jr .pastdmark  
2fde ..			.dmark: db "THN"  
2fe1 f1			.pastdmark: pop af  
2fe2			endm  
# End of macro DMARK
2fe2						CALLMONITOR 
2fe2 cd 6f ee			call debug_vector  
2fe5				endm  
# End of macro CALLMONITOR
2fe5					endif 
2fe5					NEXTW 
2fe5 c3 34 1f			jp macro_next 
2fe8				endm 
# End of macro NEXTW
2fe8			.ELSE: 
2fe8				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2fe8 20				db WORD_SYS_CORE+12             
2fe9 10 30			dw .DO            
2feb 03				db 2 + 1 
2fec .. 00			db "ELSE",0              
2ff1				endm 
# End of macro CWHEAD
2ff1			; | ELSE ( -- ) Not supported - does nothing | TODO 
2ff1			 
2ff1					if DEBUG_FORTH_WORDS_KEY 
2ff1						DMARK "ELS" 
2ff1 f5				push af  
2ff2 3a 06 30			ld a, (.dmark)  
2ff5 32 6b ee			ld (debug_mark),a  
2ff8 3a 07 30			ld a, (.dmark+1)  
2ffb 32 6c ee			ld (debug_mark+1),a  
2ffe 3a 08 30			ld a, (.dmark+2)  
3001 32 6d ee			ld (debug_mark+2),a  
3004 18 03			jr .pastdmark  
3006 ..			.dmark: db "ELS"  
3009 f1			.pastdmark: pop af  
300a			endm  
# End of macro DMARK
300a						CALLMONITOR 
300a cd 6f ee			call debug_vector  
300d				endm  
# End of macro CALLMONITOR
300d					endif 
300d			 
300d			 
300d					NEXTW 
300d c3 34 1f			jp macro_next 
3010				endm 
# End of macro NEXTW
3010			.DO: 
3010				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3010 21				db WORD_SYS_CORE+13             
3011 37 31			dw .LOOP            
3013 03				db 2 + 1 
3014 .. 00			db "DO",0              
3017				endm 
# End of macro CWHEAD
3017			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3017			 
3017					if DEBUG_FORTH_WORDS_KEY 
3017						DMARK "DO." 
3017 f5				push af  
3018 3a 2c 30			ld a, (.dmark)  
301b 32 6b ee			ld (debug_mark),a  
301e 3a 2d 30			ld a, (.dmark+1)  
3021 32 6c ee			ld (debug_mark+1),a  
3024 3a 2e 30			ld a, (.dmark+2)  
3027 32 6d ee			ld (debug_mark+2),a  
302a 18 03			jr .pastdmark  
302c ..			.dmark: db "DO."  
302f f1			.pastdmark: pop af  
3030			endm  
# End of macro DMARK
3030						CALLMONITOR 
3030 cd 6f ee			call debug_vector  
3033				endm  
# End of macro CALLMONITOR
3033					endif 
3033			;  push pc to rsp stack past the DO 
3033			 
3033 2a c2 e5				ld hl, (os_tok_ptr) 
3036 23					inc hl   ; D 
3037 23					inc hl  ; O 
3038 23					inc hl   ; null 
3039					if DEBUG_FORTH_WORDS 
3039						DMARK "DO2" 
3039 f5				push af  
303a 3a 4e 30			ld a, (.dmark)  
303d 32 6b ee			ld (debug_mark),a  
3040 3a 4f 30			ld a, (.dmark+1)  
3043 32 6c ee			ld (debug_mark+1),a  
3046 3a 50 30			ld a, (.dmark+2)  
3049 32 6d ee			ld (debug_mark+2),a  
304c 18 03			jr .pastdmark  
304e ..			.dmark: db "DO2"  
3051 f1			.pastdmark: pop af  
3052			endm  
# End of macro DMARK
3052						CALLMONITOR 
3052 cd 6f ee			call debug_vector  
3055				endm  
# End of macro CALLMONITOR
3055					endif 
3055					FORTH_RSP_NEXT 
3055 cd 20 1b			call macro_forth_rsp_next 
3058				endm 
# End of macro FORTH_RSP_NEXT
3058					if DEBUG_FORTH_WORDS 
3058						DMARK "DO3" 
3058 f5				push af  
3059 3a 6d 30			ld a, (.dmark)  
305c 32 6b ee			ld (debug_mark),a  
305f 3a 6e 30			ld a, (.dmark+1)  
3062 32 6c ee			ld (debug_mark+1),a  
3065 3a 6f 30			ld a, (.dmark+2)  
3068 32 6d ee			ld (debug_mark+2),a  
306b 18 03			jr .pastdmark  
306d ..			.dmark: db "DO3"  
3070 f1			.pastdmark: pop af  
3071			endm  
# End of macro DMARK
3071						CALLMONITOR 
3071 cd 6f ee			call debug_vector  
3074				endm  
# End of macro CALLMONITOR
3074					endif 
3074			 
3074					;if DEBUG_FORTH_WORDS 
3074				;		push hl 
3074			;		endif  
3074			 
3074			; get counters from data stack 
3074			 
3074			 
3074					FORTH_DSP_VALUEHL 
3074 cd 7e 1d			call macro_dsp_valuehl 
3077				endm 
# End of macro FORTH_DSP_VALUEHL
3077 e5					push hl		 ; hl now has starting counter which needs to be tos 
3078			 
3078					if DEBUG_FORTH_WORDS 
3078						DMARK "DO4" 
3078 f5				push af  
3079 3a 8d 30			ld a, (.dmark)  
307c 32 6b ee			ld (debug_mark),a  
307f 3a 8e 30			ld a, (.dmark+1)  
3082 32 6c ee			ld (debug_mark+1),a  
3085 3a 8f 30			ld a, (.dmark+2)  
3088 32 6d ee			ld (debug_mark+2),a  
308b 18 03			jr .pastdmark  
308d ..			.dmark: db "DO4"  
3090 f1			.pastdmark: pop af  
3091			endm  
# End of macro DMARK
3091						CALLMONITOR 
3091 cd 6f ee			call debug_vector  
3094				endm  
# End of macro CALLMONITOR
3094					endif 
3094					FORTH_DSP_POP 
3094 cd 36 1e			call macro_forth_dsp_pop 
3097				endm 
# End of macro FORTH_DSP_POP
3097			 
3097					if DEBUG_FORTH_WORDS 
3097						DMARK "DO5" 
3097 f5				push af  
3098 3a ac 30			ld a, (.dmark)  
309b 32 6b ee			ld (debug_mark),a  
309e 3a ad 30			ld a, (.dmark+1)  
30a1 32 6c ee			ld (debug_mark+1),a  
30a4 3a ae 30			ld a, (.dmark+2)  
30a7 32 6d ee			ld (debug_mark+2),a  
30aa 18 03			jr .pastdmark  
30ac ..			.dmark: db "DO5"  
30af f1			.pastdmark: pop af  
30b0			endm  
# End of macro DMARK
30b0						CALLMONITOR 
30b0 cd 6f ee			call debug_vector  
30b3				endm  
# End of macro CALLMONITOR
30b3					endif 
30b3			 
30b3					FORTH_DSP_VALUEHL 
30b3 cd 7e 1d			call macro_dsp_valuehl 
30b6				endm 
# End of macro FORTH_DSP_VALUEHL
30b6			;		push hl		 ; hl now has starting limit counter 
30b6			 
30b6					if DEBUG_FORTH_WORDS 
30b6						DMARK "DO6" 
30b6 f5				push af  
30b7 3a cb 30			ld a, (.dmark)  
30ba 32 6b ee			ld (debug_mark),a  
30bd 3a cc 30			ld a, (.dmark+1)  
30c0 32 6c ee			ld (debug_mark+1),a  
30c3 3a cd 30			ld a, (.dmark+2)  
30c6 32 6d ee			ld (debug_mark+2),a  
30c9 18 03			jr .pastdmark  
30cb ..			.dmark: db "DO6"  
30ce f1			.pastdmark: pop af  
30cf			endm  
# End of macro DMARK
30cf						CALLMONITOR 
30cf cd 6f ee			call debug_vector  
30d2				endm  
# End of macro CALLMONITOR
30d2					endif 
30d2					FORTH_DSP_POP 
30d2 cd 36 1e			call macro_forth_dsp_pop 
30d5				endm 
# End of macro FORTH_DSP_POP
30d5			 
30d5			; put counters on the loop stack 
30d5			 
30d5			;		pop hl			 ; limit counter 
30d5 d1					pop de			; start counter 
30d6			 
30d6					; push limit counter 
30d6			 
30d6					if DEBUG_FORTH_WORDS 
30d6						DMARK "DO7" 
30d6 f5				push af  
30d7 3a eb 30			ld a, (.dmark)  
30da 32 6b ee			ld (debug_mark),a  
30dd 3a ec 30			ld a, (.dmark+1)  
30e0 32 6c ee			ld (debug_mark+1),a  
30e3 3a ed 30			ld a, (.dmark+2)  
30e6 32 6d ee			ld (debug_mark+2),a  
30e9 18 03			jr .pastdmark  
30eb ..			.dmark: db "DO7"  
30ee f1			.pastdmark: pop af  
30ef			endm  
# End of macro DMARK
30ef						CALLMONITOR 
30ef cd 6f ee			call debug_vector  
30f2				endm  
# End of macro CALLMONITOR
30f2					endif 
30f2					FORTH_LOOP_NEXT 
30f2 cd af 1d			call macro_forth_loop_next 
30f5				endm 
# End of macro FORTH_LOOP_NEXT
30f5			 
30f5					; push start counter 
30f5			 
30f5 eb					ex de, hl 
30f6					if DEBUG_FORTH_WORDS 
30f6						DMARK "DO7" 
30f6 f5				push af  
30f7 3a 0b 31			ld a, (.dmark)  
30fa 32 6b ee			ld (debug_mark),a  
30fd 3a 0c 31			ld a, (.dmark+1)  
3100 32 6c ee			ld (debug_mark+1),a  
3103 3a 0d 31			ld a, (.dmark+2)  
3106 32 6d ee			ld (debug_mark+2),a  
3109 18 03			jr .pastdmark  
310b ..			.dmark: db "DO7"  
310e f1			.pastdmark: pop af  
310f			endm  
# End of macro DMARK
310f						CALLMONITOR 
310f cd 6f ee			call debug_vector  
3112				endm  
# End of macro CALLMONITOR
3112					endif 
3112					FORTH_LOOP_NEXT 
3112 cd af 1d			call macro_forth_loop_next 
3115				endm 
# End of macro FORTH_LOOP_NEXT
3115			 
3115			 
3115					; init first round of I counter 
3115			 
3115 22 e6 e5				ld (os_current_i), hl 
3118			 
3118					if DEBUG_FORTH_WORDS 
3118						DMARK "DO8" 
3118 f5				push af  
3119 3a 2d 31			ld a, (.dmark)  
311c 32 6b ee			ld (debug_mark),a  
311f 3a 2e 31			ld a, (.dmark+1)  
3122 32 6c ee			ld (debug_mark+1),a  
3125 3a 2f 31			ld a, (.dmark+2)  
3128 32 6d ee			ld (debug_mark+2),a  
312b 18 03			jr .pastdmark  
312d ..			.dmark: db "DO8"  
3130 f1			.pastdmark: pop af  
3131			endm  
# End of macro DMARK
3131						CALLMONITOR 
3131 cd 6f ee			call debug_vector  
3134				endm  
# End of macro CALLMONITOR
3134					endif 
3134			 
3134					NEXTW 
3134 c3 34 1f			jp macro_next 
3137				endm 
# End of macro NEXTW
3137			.LOOP: 
3137				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3137 22				db WORD_SYS_CORE+14             
3138 4f 32			dw .I            
313a 05				db 4 + 1 
313b .. 00			db "LOOP",0              
3140				endm 
# End of macro CWHEAD
3140			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3140			 
3140				; pop tos as current loop count to hl 
3140			 
3140				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3140			 
3140				FORTH_LOOP_TOS 
3140 cd e2 1d			call macro_forth_loop_tos 
3143				endm 
# End of macro FORTH_LOOP_TOS
3143 e5				push hl 
3144			 
3144					if DEBUG_FORTH_WORDS_KEY 
3144						DMARK "LOP" 
3144 f5				push af  
3145 3a 59 31			ld a, (.dmark)  
3148 32 6b ee			ld (debug_mark),a  
314b 3a 5a 31			ld a, (.dmark+1)  
314e 32 6c ee			ld (debug_mark+1),a  
3151 3a 5b 31			ld a, (.dmark+2)  
3154 32 6d ee			ld (debug_mark+2),a  
3157 18 03			jr .pastdmark  
3159 ..			.dmark: db "LOP"  
315c f1			.pastdmark: pop af  
315d			endm  
# End of macro DMARK
315d						CALLMONITOR 
315d cd 6f ee			call debug_vector  
3160				endm  
# End of macro CALLMONITOR
3160					endif 
3160				; next item on the stack is the limit. get it 
3160			 
3160			 
3160				FORTH_LOOP_POP 
3160 cd ec 1d			call macro_forth_loop_pop 
3163				endm 
# End of macro FORTH_LOOP_POP
3163			 
3163				FORTH_LOOP_TOS 
3163 cd e2 1d			call macro_forth_loop_tos 
3166				endm 
# End of macro FORTH_LOOP_TOS
3166			 
3166 d1				pop de		 ; de = i, hl = limit 
3167			 
3167					if DEBUG_FORTH_WORDS 
3167						DMARK "LP1" 
3167 f5				push af  
3168 3a 7c 31			ld a, (.dmark)  
316b 32 6b ee			ld (debug_mark),a  
316e 3a 7d 31			ld a, (.dmark+1)  
3171 32 6c ee			ld (debug_mark+1),a  
3174 3a 7e 31			ld a, (.dmark+2)  
3177 32 6d ee			ld (debug_mark+2),a  
317a 18 03			jr .pastdmark  
317c ..			.dmark: db "LP1"  
317f f1			.pastdmark: pop af  
3180			endm  
# End of macro DMARK
3180						CALLMONITOR 
3180 cd 6f ee			call debug_vector  
3183				endm  
# End of macro CALLMONITOR
3183					endif 
3183			 
3183				; go back to previous word 
3183			 
3183 d5				push de    ; save I for inc later 
3184			 
3184			 
3184				; get limit 
3184				;  is I at limit? 
3184			 
3184			 
3184					if DEBUG_FORTH_WORDS 
3184						DMARK "LP1" 
3184 f5				push af  
3185 3a 99 31			ld a, (.dmark)  
3188 32 6b ee			ld (debug_mark),a  
318b 3a 9a 31			ld a, (.dmark+1)  
318e 32 6c ee			ld (debug_mark+1),a  
3191 3a 9b 31			ld a, (.dmark+2)  
3194 32 6d ee			ld (debug_mark+2),a  
3197 18 03			jr .pastdmark  
3199 ..			.dmark: db "LP1"  
319c f1			.pastdmark: pop af  
319d			endm  
# End of macro DMARK
319d						CALLMONITOR 
319d cd 6f ee			call debug_vector  
31a0				endm  
# End of macro CALLMONITOR
31a0					endif 
31a0			 
31a0 ed 52			sbc hl, de 
31a2			 
31a2			 
31a2				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31a2			 
31a2 20 26				jr nz, .loopnotdone 
31a4			 
31a4 e1				pop hl   ; get rid of saved I 
31a5				FORTH_LOOP_POP     ; get rid of limit 
31a5 cd ec 1d			call macro_forth_loop_pop 
31a8				endm 
# End of macro FORTH_LOOP_POP
31a8			 
31a8				FORTH_RSP_POP     ; get rid of DO ptr 
31a8 cd 41 1b			call macro_forth_rsp_pop 
31ab				endm 
# End of macro FORTH_RSP_POP
31ab			 
31ab			if DEBUG_FORTH_WORDS 
31ab						DMARK "LP>" 
31ab f5				push af  
31ac 3a c0 31			ld a, (.dmark)  
31af 32 6b ee			ld (debug_mark),a  
31b2 3a c1 31			ld a, (.dmark+1)  
31b5 32 6c ee			ld (debug_mark+1),a  
31b8 3a c2 31			ld a, (.dmark+2)  
31bb 32 6d ee			ld (debug_mark+2),a  
31be 18 03			jr .pastdmark  
31c0 ..			.dmark: db "LP>"  
31c3 f1			.pastdmark: pop af  
31c4			endm  
# End of macro DMARK
31c4				CALLMONITOR 
31c4 cd 6f ee			call debug_vector  
31c7				endm  
# End of macro CALLMONITOR
31c7			endif 
31c7			 
31c7					NEXTW 
31c7 c3 34 1f			jp macro_next 
31ca				endm 
# End of macro NEXTW
31ca				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31ca			 
31ca			.loopnotdone: 
31ca			 
31ca e1				pop hl    ; get I 
31cb 23				inc hl 
31cc			 
31cc			   	; save new I 
31cc			 
31cc			 
31cc					; set I counter 
31cc			 
31cc 22 e6 e5				ld (os_current_i), hl 
31cf			 
31cf					if DEBUG_FORTH_WORDS 
31cf						DMARK "LPN" 
31cf f5				push af  
31d0 3a e4 31			ld a, (.dmark)  
31d3 32 6b ee			ld (debug_mark),a  
31d6 3a e5 31			ld a, (.dmark+1)  
31d9 32 6c ee			ld (debug_mark+1),a  
31dc 3a e6 31			ld a, (.dmark+2)  
31df 32 6d ee			ld (debug_mark+2),a  
31e2 18 03			jr .pastdmark  
31e4 ..			.dmark: db "LPN"  
31e7 f1			.pastdmark: pop af  
31e8			endm  
# End of macro DMARK
31e8					CALLMONITOR 
31e8 cd 6f ee			call debug_vector  
31eb				endm  
# End of macro CALLMONITOR
31eb					endif 
31eb					 
31eb				FORTH_LOOP_NEXT 
31eb cd af 1d			call macro_forth_loop_next 
31ee				endm 
# End of macro FORTH_LOOP_NEXT
31ee			 
31ee			 
31ee					if DEBUG_FORTH_WORDS 
31ee eb						ex de,hl 
31ef					endif 
31ef			 
31ef			;	; get DO ptr 
31ef			; 
31ef					if DEBUG_FORTH_WORDS 
31ef						DMARK "LP7" 
31ef f5				push af  
31f0 3a 04 32			ld a, (.dmark)  
31f3 32 6b ee			ld (debug_mark),a  
31f6 3a 05 32			ld a, (.dmark+1)  
31f9 32 6c ee			ld (debug_mark+1),a  
31fc 3a 06 32			ld a, (.dmark+2)  
31ff 32 6d ee			ld (debug_mark+2),a  
3202 18 03			jr .pastdmark  
3204 ..			.dmark: db "LP7"  
3207 f1			.pastdmark: pop af  
3208			endm  
# End of macro DMARK
3208					CALLMONITOR 
3208 cd 6f ee			call debug_vector  
320b				endm  
# End of macro CALLMONITOR
320b					endif 
320b				FORTH_RSP_TOS 
320b cd 37 1b			call macro_forth_rsp_tos 
320e				endm 
# End of macro FORTH_RSP_TOS
320e			 
320e					if DEBUG_FORTH_WORDS 
320e						DMARK "LP8" 
320e f5				push af  
320f 3a 23 32			ld a, (.dmark)  
3212 32 6b ee			ld (debug_mark),a  
3215 3a 24 32			ld a, (.dmark+1)  
3218 32 6c ee			ld (debug_mark+1),a  
321b 3a 25 32			ld a, (.dmark+2)  
321e 32 6d ee			ld (debug_mark+2),a  
3221 18 03			jr .pastdmark  
3223 ..			.dmark: db "LP8"  
3226 f1			.pastdmark: pop af  
3227			endm  
# End of macro DMARK
3227					CALLMONITOR 
3227 cd 6f ee			call debug_vector  
322a				endm  
# End of macro CALLMONITOR
322a					endif 
322a				;push hl 
322a			 
322a				; not going to DO any more 
322a				; get rid of the RSP pointer as DO will add it back in 
322a				;FORTH_RSP_POP 
322a				;pop hl 
322a			 
322a				;ld hl,(cli_ret_sp) 
322a				;ld e, (hl) 
322a				;inc hl 
322a				;ld d, (hl) 
322a				;ex de,hl 
322a 22 c2 e5			ld (os_tok_ptr), hl 
322d					if DEBUG_FORTH_WORDS 
322d						DMARK "LP<" 
322d f5				push af  
322e 3a 42 32			ld a, (.dmark)  
3231 32 6b ee			ld (debug_mark),a  
3234 3a 43 32			ld a, (.dmark+1)  
3237 32 6c ee			ld (debug_mark+1),a  
323a 3a 44 32			ld a, (.dmark+2)  
323d 32 6d ee			ld (debug_mark+2),a  
3240 18 03			jr .pastdmark  
3242 ..			.dmark: db "LP<"  
3245 f1			.pastdmark: pop af  
3246			endm  
# End of macro DMARK
3246					CALLMONITOR 
3246 cd 6f ee			call debug_vector  
3249				endm  
# End of macro CALLMONITOR
3249				endif 
3249 c3 c5 1f			jp exec1 
324c			 
324c					 
324c			 
324c			 
324c					NEXTW 
324c c3 34 1f			jp macro_next 
324f				endm 
# End of macro NEXTW
324f			.I:  
324f			 
324f				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
324f 5e				db WORD_SYS_CORE+74             
3250 7a 32			dw .DLOOP            
3252 02				db 1 + 1 
3253 .. 00			db "I",0              
3255				endm 
# End of macro CWHEAD
3255			; | I ( -- ) Current loop counter | DONE 
3255					if DEBUG_FORTH_WORDS_KEY 
3255						DMARK "I.." 
3255 f5				push af  
3256 3a 6a 32			ld a, (.dmark)  
3259 32 6b ee			ld (debug_mark),a  
325c 3a 6b 32			ld a, (.dmark+1)  
325f 32 6c ee			ld (debug_mark+1),a  
3262 3a 6c 32			ld a, (.dmark+2)  
3265 32 6d ee			ld (debug_mark+2),a  
3268 18 03			jr .pastdmark  
326a ..			.dmark: db "I.."  
326d f1			.pastdmark: pop af  
326e			endm  
# End of macro DMARK
326e						CALLMONITOR 
326e cd 6f ee			call debug_vector  
3271				endm  
# End of macro CALLMONITOR
3271					endif 
3271			 
3271 2a e6 e5				ld hl,(os_current_i) 
3274 cd 79 1b				call forth_push_numhl 
3277			 
3277					NEXTW 
3277 c3 34 1f			jp macro_next 
327a				endm 
# End of macro NEXTW
327a			.DLOOP: 
327a				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
327a 5f				db WORD_SYS_CORE+75             
327b 5b 33			dw .REPEAT            
327d 06				db 5 + 1 
327e .. 00			db "-LOOP",0              
3284				endm 
# End of macro CWHEAD
3284			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3284				; pop tos as current loop count to hl 
3284					if DEBUG_FORTH_WORDS_KEY 
3284						DMARK "-LP" 
3284 f5				push af  
3285 3a 99 32			ld a, (.dmark)  
3288 32 6b ee			ld (debug_mark),a  
328b 3a 9a 32			ld a, (.dmark+1)  
328e 32 6c ee			ld (debug_mark+1),a  
3291 3a 9b 32			ld a, (.dmark+2)  
3294 32 6d ee			ld (debug_mark+2),a  
3297 18 03			jr .pastdmark  
3299 ..			.dmark: db "-LP"  
329c f1			.pastdmark: pop af  
329d			endm  
# End of macro DMARK
329d						CALLMONITOR 
329d cd 6f ee			call debug_vector  
32a0				endm  
# End of macro CALLMONITOR
32a0					endif 
32a0			 
32a0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32a0			 
32a0				FORTH_LOOP_TOS 
32a0 cd e2 1d			call macro_forth_loop_tos 
32a3				endm 
# End of macro FORTH_LOOP_TOS
32a3 e5				push hl 
32a4			 
32a4					if DEBUG_FORTH_WORDS 
32a4						DMARK "-LP" 
32a4 f5				push af  
32a5 3a b9 32			ld a, (.dmark)  
32a8 32 6b ee			ld (debug_mark),a  
32ab 3a ba 32			ld a, (.dmark+1)  
32ae 32 6c ee			ld (debug_mark+1),a  
32b1 3a bb 32			ld a, (.dmark+2)  
32b4 32 6d ee			ld (debug_mark+2),a  
32b7 18 03			jr .pastdmark  
32b9 ..			.dmark: db "-LP"  
32bc f1			.pastdmark: pop af  
32bd			endm  
# End of macro DMARK
32bd						CALLMONITOR 
32bd cd 6f ee			call debug_vector  
32c0				endm  
# End of macro CALLMONITOR
32c0					endif 
32c0				; next item on the stack is the limit. get it 
32c0			 
32c0			 
32c0				FORTH_LOOP_POP 
32c0 cd ec 1d			call macro_forth_loop_pop 
32c3				endm 
# End of macro FORTH_LOOP_POP
32c3			 
32c3				FORTH_LOOP_TOS 
32c3 cd e2 1d			call macro_forth_loop_tos 
32c6				endm 
# End of macro FORTH_LOOP_TOS
32c6			 
32c6 d1				pop de		 ; de = i, hl = limit 
32c7			 
32c7					if DEBUG_FORTH_WORDS 
32c7						DMARK "-L1" 
32c7 f5				push af  
32c8 3a dc 32			ld a, (.dmark)  
32cb 32 6b ee			ld (debug_mark),a  
32ce 3a dd 32			ld a, (.dmark+1)  
32d1 32 6c ee			ld (debug_mark+1),a  
32d4 3a de 32			ld a, (.dmark+2)  
32d7 32 6d ee			ld (debug_mark+2),a  
32da 18 03			jr .pastdmark  
32dc ..			.dmark: db "-L1"  
32df f1			.pastdmark: pop af  
32e0			endm  
# End of macro DMARK
32e0						CALLMONITOR 
32e0 cd 6f ee			call debug_vector  
32e3				endm  
# End of macro CALLMONITOR
32e3					endif 
32e3			 
32e3				; go back to previous word 
32e3			 
32e3 d5				push de    ; save I for inc later 
32e4			 
32e4			 
32e4				; get limit 
32e4				;  is I at limit? 
32e4			 
32e4			 
32e4					if DEBUG_FORTH_WORDS 
32e4						DMARK "-L1" 
32e4 f5				push af  
32e5 3a f9 32			ld a, (.dmark)  
32e8 32 6b ee			ld (debug_mark),a  
32eb 3a fa 32			ld a, (.dmark+1)  
32ee 32 6c ee			ld (debug_mark+1),a  
32f1 3a fb 32			ld a, (.dmark+2)  
32f4 32 6d ee			ld (debug_mark+2),a  
32f7 18 03			jr .pastdmark  
32f9 ..			.dmark: db "-L1"  
32fc f1			.pastdmark: pop af  
32fd			endm  
# End of macro DMARK
32fd						CALLMONITOR 
32fd cd 6f ee			call debug_vector  
3300				endm  
# End of macro CALLMONITOR
3300					endif 
3300			 
3300 ed 52			sbc hl, de 
3302			 
3302			 
3302				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3302			 
3302 20 26				jr nz, .mloopnotdone 
3304			 
3304 e1				pop hl   ; get rid of saved I 
3305				FORTH_LOOP_POP     ; get rid of limit 
3305 cd ec 1d			call macro_forth_loop_pop 
3308				endm 
# End of macro FORTH_LOOP_POP
3308			 
3308				FORTH_RSP_POP     ; get rid of DO ptr 
3308 cd 41 1b			call macro_forth_rsp_pop 
330b				endm 
# End of macro FORTH_RSP_POP
330b			 
330b			if DEBUG_FORTH_WORDS 
330b						DMARK "-L>" 
330b f5				push af  
330c 3a 20 33			ld a, (.dmark)  
330f 32 6b ee			ld (debug_mark),a  
3312 3a 21 33			ld a, (.dmark+1)  
3315 32 6c ee			ld (debug_mark+1),a  
3318 3a 22 33			ld a, (.dmark+2)  
331b 32 6d ee			ld (debug_mark+2),a  
331e 18 03			jr .pastdmark  
3320 ..			.dmark: db "-L>"  
3323 f1			.pastdmark: pop af  
3324			endm  
# End of macro DMARK
3324				CALLMONITOR 
3324 cd 6f ee			call debug_vector  
3327				endm  
# End of macro CALLMONITOR
3327			endif 
3327			 
3327					NEXTW 
3327 c3 34 1f			jp macro_next 
332a				endm 
# End of macro NEXTW
332a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
332a			 
332a			.mloopnotdone: 
332a			 
332a e1				pop hl    ; get I 
332b 2b				dec hl 
332c			 
332c			   	; save new I 
332c			 
332c			 
332c					; set I counter 
332c			 
332c 22 e6 e5				ld (os_current_i), hl 
332f			 
332f					 
332f				FORTH_LOOP_NEXT 
332f cd af 1d			call macro_forth_loop_next 
3332				endm 
# End of macro FORTH_LOOP_NEXT
3332			 
3332			 
3332					if DEBUG_FORTH_WORDS 
3332 eb						ex de,hl 
3333					endif 
3333			 
3333			;	; get DO ptr 
3333			; 
3333				FORTH_RSP_TOS 
3333 cd 37 1b			call macro_forth_rsp_tos 
3336				endm 
# End of macro FORTH_RSP_TOS
3336			 
3336				;push hl 
3336			 
3336				; not going to DO any more 
3336				; get rid of the RSP pointer as DO will add it back in 
3336				;FORTH_RSP_POP 
3336				;pop hl 
3336			 
3336			 
3336 22 c2 e5			ld (os_tok_ptr), hl 
3339					if DEBUG_FORTH_WORDS 
3339						DMARK "-L<" 
3339 f5				push af  
333a 3a 4e 33			ld a, (.dmark)  
333d 32 6b ee			ld (debug_mark),a  
3340 3a 4f 33			ld a, (.dmark+1)  
3343 32 6c ee			ld (debug_mark+1),a  
3346 3a 50 33			ld a, (.dmark+2)  
3349 32 6d ee			ld (debug_mark+2),a  
334c 18 03			jr .pastdmark  
334e ..			.dmark: db "-L<"  
3351 f1			.pastdmark: pop af  
3352			endm  
# End of macro DMARK
3352					CALLMONITOR 
3352 cd 6f ee			call debug_vector  
3355				endm  
# End of macro CALLMONITOR
3355				endif 
3355 c3 c5 1f			jp exec1 
3358			 
3358					 
3358			 
3358			 
3358			 
3358				NEXTW 
3358 c3 34 1f			jp macro_next 
335b				endm 
# End of macro NEXTW
335b			 
335b			 
335b			 
335b			 
335b			.REPEAT: 
335b				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
335b 71				db WORD_SYS_CORE+93             
335c ae 33			dw .UNTIL            
335e 06				db 5 + 1 
335f .. 00			db "REPEAT",0              
3366				endm 
# End of macro CWHEAD
3366			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3366			;  push pc to rsp stack past the REPEAT 
3366					if DEBUG_FORTH_WORDS_KEY 
3366						DMARK "REP" 
3366 f5				push af  
3367 3a 7b 33			ld a, (.dmark)  
336a 32 6b ee			ld (debug_mark),a  
336d 3a 7c 33			ld a, (.dmark+1)  
3370 32 6c ee			ld (debug_mark+1),a  
3373 3a 7d 33			ld a, (.dmark+2)  
3376 32 6d ee			ld (debug_mark+2),a  
3379 18 03			jr .pastdmark  
337b ..			.dmark: db "REP"  
337e f1			.pastdmark: pop af  
337f			endm  
# End of macro DMARK
337f						CALLMONITOR 
337f cd 6f ee			call debug_vector  
3382				endm  
# End of macro CALLMONITOR
3382					endif 
3382			 
3382 2a c2 e5				ld hl, (os_tok_ptr) 
3385 23					inc hl   ; R 
3386 23					inc hl  ; E 
3387 23					inc hl   ; P 
3388 23					inc hl   ; E 
3389 23					inc hl   ; A 
338a 23					inc hl   ; T 
338b 23					inc hl   ; zero 
338c					FORTH_RSP_NEXT 
338c cd 20 1b			call macro_forth_rsp_next 
338f				endm 
# End of macro FORTH_RSP_NEXT
338f			 
338f			 
338f					if DEBUG_FORTH_WORDS 
338f						DMARK "REP" 
338f f5				push af  
3390 3a a4 33			ld a, (.dmark)  
3393 32 6b ee			ld (debug_mark),a  
3396 3a a5 33			ld a, (.dmark+1)  
3399 32 6c ee			ld (debug_mark+1),a  
339c 3a a6 33			ld a, (.dmark+2)  
339f 32 6d ee			ld (debug_mark+2),a  
33a2 18 03			jr .pastdmark  
33a4 ..			.dmark: db "REP"  
33a7 f1			.pastdmark: pop af  
33a8			endm  
# End of macro DMARK
33a8						;pop bc    ; TODO BUG ?????? what is this for???? 
33a8						CALLMONITOR 
33a8 cd 6f ee			call debug_vector  
33ab				endm  
# End of macro CALLMONITOR
33ab					endif 
33ab			 
33ab					NEXTW 
33ab c3 34 1f			jp macro_next 
33ae				endm 
# End of macro NEXTW
33ae			;	       NEXTW 
33ae			 
33ae			.UNTIL: 
33ae				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33ae 72				db WORD_SYS_CORE+94             
33af 45 34			dw .ENDFLOW            
33b1 06				db 5 + 1 
33b2 .. 00			db "UNTIL",0              
33b8				endm 
# End of macro CWHEAD
33b8			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
33b8			 
33b8				; pop tos as check 
33b8			 
33b8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33b8			 
33b8				FORTH_DSP_VALUEHL 
33b8 cd 7e 1d			call macro_dsp_valuehl 
33bb				endm 
# End of macro FORTH_DSP_VALUEHL
33bb			 
33bb					if DEBUG_FORTH_WORDS_KEY 
33bb						DMARK "UNT" 
33bb f5				push af  
33bc 3a d0 33			ld a, (.dmark)  
33bf 32 6b ee			ld (debug_mark),a  
33c2 3a d1 33			ld a, (.dmark+1)  
33c5 32 6c ee			ld (debug_mark+1),a  
33c8 3a d2 33			ld a, (.dmark+2)  
33cb 32 6d ee			ld (debug_mark+2),a  
33ce 18 03			jr .pastdmark  
33d0 ..			.dmark: db "UNT"  
33d3 f1			.pastdmark: pop af  
33d4			endm  
# End of macro DMARK
33d4						CALLMONITOR 
33d4 cd 6f ee			call debug_vector  
33d7				endm  
# End of macro CALLMONITOR
33d7					endif 
33d7			 
33d7			;	push hl 
33d7				FORTH_DSP_POP 
33d7 cd 36 1e			call macro_forth_dsp_pop 
33da				endm 
# End of macro FORTH_DSP_POP
33da			 
33da			;	pop hl 
33da			 
33da				; test if true 
33da			 
33da cd 1b 0e			call ishlzero 
33dd			;	ld a,l 
33dd			;	add h 
33dd			; 
33dd			;	cp 0 
33dd			 
33dd 20 3e			jr nz, .untilnotdone 
33df			 
33df					if DEBUG_FORTH_WORDS 
33df						DMARK "UNf" 
33df f5				push af  
33e0 3a f4 33			ld a, (.dmark)  
33e3 32 6b ee			ld (debug_mark),a  
33e6 3a f5 33			ld a, (.dmark+1)  
33e9 32 6c ee			ld (debug_mark+1),a  
33ec 3a f6 33			ld a, (.dmark+2)  
33ef 32 6d ee			ld (debug_mark+2),a  
33f2 18 03			jr .pastdmark  
33f4 ..			.dmark: db "UNf"  
33f7 f1			.pastdmark: pop af  
33f8			endm  
# End of macro DMARK
33f8						CALLMONITOR 
33f8 cd 6f ee			call debug_vector  
33fb				endm  
# End of macro CALLMONITOR
33fb					endif 
33fb			 
33fb			 
33fb			 
33fb				FORTH_RSP_POP     ; get rid of DO ptr 
33fb cd 41 1b			call macro_forth_rsp_pop 
33fe				endm 
# End of macro FORTH_RSP_POP
33fe			 
33fe			if DEBUG_FORTH_WORDS 
33fe						DMARK "UN>" 
33fe f5				push af  
33ff 3a 13 34			ld a, (.dmark)  
3402 32 6b ee			ld (debug_mark),a  
3405 3a 14 34			ld a, (.dmark+1)  
3408 32 6c ee			ld (debug_mark+1),a  
340b 3a 15 34			ld a, (.dmark+2)  
340e 32 6d ee			ld (debug_mark+2),a  
3411 18 03			jr .pastdmark  
3413 ..			.dmark: db "UN>"  
3416 f1			.pastdmark: pop af  
3417			endm  
# End of macro DMARK
3417				CALLMONITOR 
3417 cd 6f ee			call debug_vector  
341a				endm  
# End of macro CALLMONITOR
341a			endif 
341a			 
341a					NEXTW 
341a c3 34 1f			jp macro_next 
341d				endm 
# End of macro NEXTW
341d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
341d			 
341d			.untilnotdone: 
341d			 
341d			 
341d			;	; get DO ptr 
341d			; 
341d				FORTH_RSP_TOS 
341d cd 37 1b			call macro_forth_rsp_tos 
3420				endm 
# End of macro FORTH_RSP_TOS
3420			 
3420				;push hl 
3420			 
3420				; not going to DO any more 
3420				; get rid of the RSP pointer as DO will add it back in 
3420				;FORTH_RSP_POP 
3420				;pop hl 
3420			 
3420			 
3420 22 c2 e5			ld (os_tok_ptr), hl 
3423					if DEBUG_FORTH_WORDS 
3423						DMARK "UN<" 
3423 f5				push af  
3424 3a 38 34			ld a, (.dmark)  
3427 32 6b ee			ld (debug_mark),a  
342a 3a 39 34			ld a, (.dmark+1)  
342d 32 6c ee			ld (debug_mark+1),a  
3430 3a 3a 34			ld a, (.dmark+2)  
3433 32 6d ee			ld (debug_mark+2),a  
3436 18 03			jr .pastdmark  
3438 ..			.dmark: db "UN<"  
343b f1			.pastdmark: pop af  
343c			endm  
# End of macro DMARK
343c					CALLMONITOR 
343c cd 6f ee			call debug_vector  
343f				endm  
# End of macro CALLMONITOR
343f				endif 
343f c3 c5 1f			jp exec1 
3442			 
3442					 
3442			 
3442			 
3442					NEXTW 
3442 c3 34 1f			jp macro_next 
3445				endm 
# End of macro NEXTW
3445			 
3445			 
3445			.ENDFLOW: 
3445			 
3445			; eof 
3445			 
# End of file forth_words_flow.asm
3445			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3445			include "forth_words_logic.asm" 
3445			 
3445			; | ## Logic Words 
3445			 
3445			.NOT: 
3445				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3445 2d				db WORD_SYS_CORE+25             
3446 8d 34			dw .IS            
3448 04				db 3 + 1 
3449 .. 00			db "NOT",0              
344d				endm 
# End of macro CWHEAD
344d			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
344d					if DEBUG_FORTH_WORDS_KEY 
344d						DMARK "NOT" 
344d f5				push af  
344e 3a 62 34			ld a, (.dmark)  
3451 32 6b ee			ld (debug_mark),a  
3454 3a 63 34			ld a, (.dmark+1)  
3457 32 6c ee			ld (debug_mark+1),a  
345a 3a 64 34			ld a, (.dmark+2)  
345d 32 6d ee			ld (debug_mark+2),a  
3460 18 03			jr .pastdmark  
3462 ..			.dmark: db "NOT"  
3465 f1			.pastdmark: pop af  
3466			endm  
# End of macro DMARK
3466						CALLMONITOR 
3466 cd 6f ee			call debug_vector  
3469				endm  
# End of macro CALLMONITOR
3469					endif 
3469					FORTH_DSP 
3469 cd 44 1d			call macro_forth_dsp 
346c				endm 
# End of macro FORTH_DSP
346c 7e					ld a,(hl)	; get type of value on TOS 
346d fe 02				cp DS_TYPE_INUM  
346f 28 03				jr z, .noti 
3471					NEXTW 
3471 c3 34 1f			jp macro_next 
3474				endm 
# End of macro NEXTW
3474			.noti:          FORTH_DSP_VALUEHL 
3474 cd 7e 1d			call macro_dsp_valuehl 
3477				endm 
# End of macro FORTH_DSP_VALUEHL
3477			;		push hl 
3477					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3477 cd 36 1e			call macro_forth_dsp_pop 
347a				endm 
# End of macro FORTH_DSP_POP
347a			;		pop hl 
347a 3e 00				ld a,0 
347c bd					cp l 
347d 28 04				jr z, .not2t 
347f 2e 00				ld l, 0 
3481 18 02				jr .notip 
3483			 
3483 2e ff		.not2t:		ld l, 255 
3485			 
3485 26 00		.notip:		ld h, 0	 
3487			 
3487 cd 79 1b				call forth_push_numhl 
348a					NEXTW 
348a c3 34 1f			jp macro_next 
348d				endm 
# End of macro NEXTW
348d			 
348d			.IS: 
348d				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
348d 2d				db WORD_SYS_CORE+25             
348e b3 34			dw .LZERO            
3490 03				db 2 + 1 
3491 .. 00			db "IS",0              
3494				endm 
# End of macro CWHEAD
3494			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3494					if DEBUG_FORTH_WORDS_KEY 
3494						DMARK "IS." 
3494 f5				push af  
3495 3a a9 34			ld a, (.dmark)  
3498 32 6b ee			ld (debug_mark),a  
349b 3a aa 34			ld a, (.dmark+1)  
349e 32 6c ee			ld (debug_mark+1),a  
34a1 3a ab 34			ld a, (.dmark+2)  
34a4 32 6d ee			ld (debug_mark+2),a  
34a7 18 03			jr .pastdmark  
34a9 ..			.dmark: db "IS."  
34ac f1			.pastdmark: pop af  
34ad			endm  
# End of macro DMARK
34ad						CALLMONITOR 
34ad cd 6f ee			call debug_vector  
34b0				endm  
# End of macro CALLMONITOR
34b0					endif 
34b0					NEXTW 
34b0 c3 34 1f			jp macro_next 
34b3				endm 
# End of macro NEXTW
34b3			.LZERO: 
34b3				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
34b3 2d				db WORD_SYS_CORE+25             
34b4 bd 34			dw .TZERO            
34b6 03				db 2 + 1 
34b7 .. 00			db "0<",0              
34ba				endm 
# End of macro CWHEAD
34ba			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
34ba					NEXTW 
34ba c3 34 1f			jp macro_next 
34bd				endm 
# End of macro NEXTW
34bd			.TZERO: 
34bd				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34bd 2e				db WORD_SYS_CORE+26             
34be 04 35			dw .LESS            
34c0 03				db 2 + 1 
34c1 .. 00			db "0=",0              
34c4				endm 
# End of macro CWHEAD
34c4			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
34c4				; TODO add floating point number detection 
34c4					;v5 FORTH_DSP_VALUE 
34c4					if DEBUG_FORTH_WORDS_KEY 
34c4						DMARK "0=." 
34c4 f5				push af  
34c5 3a d9 34			ld a, (.dmark)  
34c8 32 6b ee			ld (debug_mark),a  
34cb 3a da 34			ld a, (.dmark+1)  
34ce 32 6c ee			ld (debug_mark+1),a  
34d1 3a db 34			ld a, (.dmark+2)  
34d4 32 6d ee			ld (debug_mark+2),a  
34d7 18 03			jr .pastdmark  
34d9 ..			.dmark: db "0=."  
34dc f1			.pastdmark: pop af  
34dd			endm  
# End of macro DMARK
34dd						CALLMONITOR 
34dd cd 6f ee			call debug_vector  
34e0				endm  
# End of macro CALLMONITOR
34e0					endif 
34e0					FORTH_DSP 
34e0 cd 44 1d			call macro_forth_dsp 
34e3				endm 
# End of macro FORTH_DSP
34e3 7e					ld a,(hl)	; get type of value on TOS 
34e4 fe 02				cp DS_TYPE_INUM  
34e6 28 00				jr z, .tz_inum 
34e8			 
34e8				if FORTH_ENABLE_FLOATMATH 
34e8					jr .tz_done 
34e8			 
34e8				endif 
34e8					 
34e8			 
34e8			.tz_inum: 
34e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34e8 cd 7e 1d			call macro_dsp_valuehl 
34eb				endm 
# End of macro FORTH_DSP_VALUEHL
34eb			 
34eb			;		push hl 
34eb			 
34eb					; destroy value TOS 
34eb			 
34eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34eb cd 36 1e			call macro_forth_dsp_pop 
34ee				endm 
# End of macro FORTH_DSP_POP
34ee			 
34ee			;		pop hl 
34ee			 
34ee 3e 00				ld a,0 
34f0			 
34f0 bd					cp l 
34f1 20 08				jr nz, .tz_notzero 
34f3			 
34f3 bc					cp h 
34f4			 
34f4 20 05				jr nz, .tz_notzero 
34f6			 
34f6			 
34f6 21 01 00				ld hl, FORTH_TRUE 
34f9 18 03				jr .tz_done 
34fb			 
34fb 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
34fe			 
34fe					; push value back onto stack for another op etc 
34fe			 
34fe			.tz_done: 
34fe cd 79 1b				call forth_push_numhl 
3501			 
3501					NEXTW 
3501 c3 34 1f			jp macro_next 
3504				endm 
# End of macro NEXTW
3504			.LESS: 
3504				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3504 2f				db WORD_SYS_CORE+27             
3505 6d 35			dw .GT            
3507 02				db 1 + 1 
3508 .. 00			db "<",0              
350a				endm 
# End of macro CWHEAD
350a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
350a				; TODO add floating point number detection 
350a					if DEBUG_FORTH_WORDS_KEY 
350a						DMARK "LES" 
350a f5				push af  
350b 3a 1f 35			ld a, (.dmark)  
350e 32 6b ee			ld (debug_mark),a  
3511 3a 20 35			ld a, (.dmark+1)  
3514 32 6c ee			ld (debug_mark+1),a  
3517 3a 21 35			ld a, (.dmark+2)  
351a 32 6d ee			ld (debug_mark+2),a  
351d 18 03			jr .pastdmark  
351f ..			.dmark: db "LES"  
3522 f1			.pastdmark: pop af  
3523			endm  
# End of macro DMARK
3523						CALLMONITOR 
3523 cd 6f ee			call debug_vector  
3526				endm  
# End of macro CALLMONITOR
3526					endif 
3526					FORTH_DSP 
3526 cd 44 1d			call macro_forth_dsp 
3529				endm 
# End of macro FORTH_DSP
3529					;v5 FORTH_DSP_VALUE 
3529 7e					ld a,(hl)	; get type of value on TOS 
352a fe 02				cp DS_TYPE_INUM  
352c 28 00				jr z, .less_inum 
352e			 
352e				if FORTH_ENABLE_FLOATMATH 
352e					jr .less_done 
352e			 
352e				endif 
352e					 
352e			 
352e			.less_inum: 
352e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
352e cd 7e 1d			call macro_dsp_valuehl 
3531				endm 
# End of macro FORTH_DSP_VALUEHL
3531			 
3531 e5					push hl  ; u2 
3532			 
3532					; destroy value TOS 
3532			 
3532					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3532 cd 36 1e			call macro_forth_dsp_pop 
3535				endm 
# End of macro FORTH_DSP_POP
3535			 
3535			 
3535					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3535 cd 7e 1d			call macro_dsp_valuehl 
3538				endm 
# End of macro FORTH_DSP_VALUEHL
3538			 
3538 e5					push hl    ; u1 
3539			 
3539					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3539 cd 36 1e			call macro_forth_dsp_pop 
353c				endm 
# End of macro FORTH_DSP_POP
353c			 
353c			 
353c b7			 or a      ;clear carry flag 
353d 01 00 00		 ld bc, FORTH_FALSE 
3540 e1			  pop hl    ; u1 
3541 d1			  pop de    ; u2 
3542 ed 52		  sbc hl,de 
3544 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3546			 
3546 01 01 00		 ld bc, FORTH_TRUE 
3549			.lscont:  
3549 c5					push bc 
354a e1					pop hl 
354b			 
354b					if DEBUG_FORTH_WORDS 
354b						DMARK "LT1" 
354b f5				push af  
354c 3a 60 35			ld a, (.dmark)  
354f 32 6b ee			ld (debug_mark),a  
3552 3a 61 35			ld a, (.dmark+1)  
3555 32 6c ee			ld (debug_mark+1),a  
3558 3a 62 35			ld a, (.dmark+2)  
355b 32 6d ee			ld (debug_mark+2),a  
355e 18 03			jr .pastdmark  
3560 ..			.dmark: db "LT1"  
3563 f1			.pastdmark: pop af  
3564			endm  
# End of macro DMARK
3564						CALLMONITOR 
3564 cd 6f ee			call debug_vector  
3567				endm  
# End of macro CALLMONITOR
3567					endif 
3567 cd 79 1b				call forth_push_numhl 
356a			 
356a					NEXTW 
356a c3 34 1f			jp macro_next 
356d				endm 
# End of macro NEXTW
356d			.GT: 
356d				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
356d 30				db WORD_SYS_CORE+28             
356e d6 35			dw .EQUAL            
3570 02				db 1 + 1 
3571 .. 00			db ">",0              
3573				endm 
# End of macro CWHEAD
3573			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3573				; TODO add floating point number detection 
3573					if DEBUG_FORTH_WORDS_KEY 
3573						DMARK "GRT" 
3573 f5				push af  
3574 3a 88 35			ld a, (.dmark)  
3577 32 6b ee			ld (debug_mark),a  
357a 3a 89 35			ld a, (.dmark+1)  
357d 32 6c ee			ld (debug_mark+1),a  
3580 3a 8a 35			ld a, (.dmark+2)  
3583 32 6d ee			ld (debug_mark+2),a  
3586 18 03			jr .pastdmark  
3588 ..			.dmark: db "GRT"  
358b f1			.pastdmark: pop af  
358c			endm  
# End of macro DMARK
358c						CALLMONITOR 
358c cd 6f ee			call debug_vector  
358f				endm  
# End of macro CALLMONITOR
358f					endif 
358f					FORTH_DSP 
358f cd 44 1d			call macro_forth_dsp 
3592				endm 
# End of macro FORTH_DSP
3592					;FORTH_DSP_VALUE 
3592 7e					ld a,(hl)	; get type of value on TOS 
3593 fe 02				cp DS_TYPE_INUM  
3595 28 00				jr z, .gt_inum 
3597			 
3597				if FORTH_ENABLE_FLOATMATH 
3597					jr .gt_done 
3597			 
3597				endif 
3597					 
3597			 
3597			.gt_inum: 
3597					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3597 cd 7e 1d			call macro_dsp_valuehl 
359a				endm 
# End of macro FORTH_DSP_VALUEHL
359a			 
359a e5					push hl  ; u2 
359b			 
359b					; destroy value TOS 
359b			 
359b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
359b cd 36 1e			call macro_forth_dsp_pop 
359e				endm 
# End of macro FORTH_DSP_POP
359e			 
359e			 
359e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
359e cd 7e 1d			call macro_dsp_valuehl 
35a1				endm 
# End of macro FORTH_DSP_VALUEHL
35a1			 
35a1 e5					push hl    ; u1 
35a2			 
35a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a2 cd 36 1e			call macro_forth_dsp_pop 
35a5				endm 
# End of macro FORTH_DSP_POP
35a5			 
35a5			 
35a5 b7			 or a      ;clear carry flag 
35a6 01 00 00		 ld bc, FORTH_FALSE 
35a9 e1			  pop hl    ; u1 
35aa d1			  pop de    ; u2 
35ab ed 52		  sbc hl,de 
35ad 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35af			 
35af 01 01 00		 ld bc, FORTH_TRUE 
35b2			.gtcont:  
35b2 c5					push bc 
35b3 e1					pop hl 
35b4			 
35b4					if DEBUG_FORTH_WORDS 
35b4						DMARK "GT1" 
35b4 f5				push af  
35b5 3a c9 35			ld a, (.dmark)  
35b8 32 6b ee			ld (debug_mark),a  
35bb 3a ca 35			ld a, (.dmark+1)  
35be 32 6c ee			ld (debug_mark+1),a  
35c1 3a cb 35			ld a, (.dmark+2)  
35c4 32 6d ee			ld (debug_mark+2),a  
35c7 18 03			jr .pastdmark  
35c9 ..			.dmark: db "GT1"  
35cc f1			.pastdmark: pop af  
35cd			endm  
# End of macro DMARK
35cd						CALLMONITOR 
35cd cd 6f ee			call debug_vector  
35d0				endm  
# End of macro CALLMONITOR
35d0					endif 
35d0 cd 79 1b				call forth_push_numhl 
35d3			 
35d3					NEXTW 
35d3 c3 34 1f			jp macro_next 
35d6				endm 
# End of macro NEXTW
35d6			.EQUAL: 
35d6				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
35d6 31				db WORD_SYS_CORE+29             
35d7 41 36			dw .ENDLOGIC            
35d9 02				db 1 + 1 
35da .. 00			db "=",0              
35dc				endm 
# End of macro CWHEAD
35dc			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
35dc				; TODO add floating point number detection 
35dc					if DEBUG_FORTH_WORDS_KEY 
35dc						DMARK "EQ." 
35dc f5				push af  
35dd 3a f1 35			ld a, (.dmark)  
35e0 32 6b ee			ld (debug_mark),a  
35e3 3a f2 35			ld a, (.dmark+1)  
35e6 32 6c ee			ld (debug_mark+1),a  
35e9 3a f3 35			ld a, (.dmark+2)  
35ec 32 6d ee			ld (debug_mark+2),a  
35ef 18 03			jr .pastdmark  
35f1 ..			.dmark: db "EQ."  
35f4 f1			.pastdmark: pop af  
35f5			endm  
# End of macro DMARK
35f5						CALLMONITOR 
35f5 cd 6f ee			call debug_vector  
35f8				endm  
# End of macro CALLMONITOR
35f8					endif 
35f8					FORTH_DSP 
35f8 cd 44 1d			call macro_forth_dsp 
35fb				endm 
# End of macro FORTH_DSP
35fb					;v5 FORTH_DSP_VALUE 
35fb 7e					ld a,(hl)	; get type of value on TOS 
35fc fe 02				cp DS_TYPE_INUM  
35fe 28 00				jr z, .eq_inum 
3600			 
3600				if FORTH_ENABLE_FLOATMATH 
3600					jr .eq_done 
3600			 
3600				endif 
3600					 
3600			 
3600			.eq_inum: 
3600					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3600 cd 7e 1d			call macro_dsp_valuehl 
3603				endm 
# End of macro FORTH_DSP_VALUEHL
3603			 
3603 e5					push hl 
3604			 
3604					; destroy value TOS 
3604			 
3604					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3604 cd 36 1e			call macro_forth_dsp_pop 
3607				endm 
# End of macro FORTH_DSP_POP
3607			 
3607			 
3607					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3607 cd 7e 1d			call macro_dsp_valuehl 
360a				endm 
# End of macro FORTH_DSP_VALUEHL
360a			 
360a					; one value on hl get other one back 
360a			 
360a e5					push hl 
360b			 
360b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
360b cd 36 1e			call macro_forth_dsp_pop 
360e				endm 
# End of macro FORTH_DSP_POP
360e			 
360e 0e 00				ld c, FORTH_FALSE 
3610			 
3610 e1					pop hl 
3611 d1					pop de 
3612			 
3612 7b					ld a, e 
3613 bd					cp l 
3614			 
3614 20 06				jr nz, .eq_done 
3616			 
3616 7a					ld a, d 
3617 bc					cp h 
3618			 
3618 20 02				jr nz, .eq_done 
361a			 
361a 0e 01				ld c, FORTH_TRUE 
361c					 
361c			 
361c			 
361c			.eq_done: 
361c			 
361c					; TODO push value back onto stack for another op etc 
361c			 
361c 26 00				ld h, 0 
361e 69					ld l, c 
361f					if DEBUG_FORTH_WORDS 
361f						DMARK "EQ1" 
361f f5				push af  
3620 3a 34 36			ld a, (.dmark)  
3623 32 6b ee			ld (debug_mark),a  
3626 3a 35 36			ld a, (.dmark+1)  
3629 32 6c ee			ld (debug_mark+1),a  
362c 3a 36 36			ld a, (.dmark+2)  
362f 32 6d ee			ld (debug_mark+2),a  
3632 18 03			jr .pastdmark  
3634 ..			.dmark: db "EQ1"  
3637 f1			.pastdmark: pop af  
3638			endm  
# End of macro DMARK
3638						CALLMONITOR 
3638 cd 6f ee			call debug_vector  
363b				endm  
# End of macro CALLMONITOR
363b					endif 
363b cd 79 1b				call forth_push_numhl 
363e			 
363e					NEXTW 
363e c3 34 1f			jp macro_next 
3641				endm 
# End of macro NEXTW
3641			 
3641			 
3641			.ENDLOGIC: 
3641			; eof 
3641			 
3641			 
# End of file forth_words_logic.asm
3641			include "forth_words_maths.asm" 
3641			 
3641			; | ## Maths Words 
3641			 
3641			.PLUS:	 
3641				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3641 15				db WORD_SYS_CORE+1             
3642 9f 36			dw .NEG            
3644 02				db 1 + 1 
3645 .. 00			db "+",0              
3647				endm 
# End of macro CWHEAD
3647			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3647					if DEBUG_FORTH_WORDS_KEY 
3647						DMARK "PLU" 
3647 f5				push af  
3648 3a 5c 36			ld a, (.dmark)  
364b 32 6b ee			ld (debug_mark),a  
364e 3a 5d 36			ld a, (.dmark+1)  
3651 32 6c ee			ld (debug_mark+1),a  
3654 3a 5e 36			ld a, (.dmark+2)  
3657 32 6d ee			ld (debug_mark+2),a  
365a 18 03			jr .pastdmark  
365c ..			.dmark: db "PLU"  
365f f1			.pastdmark: pop af  
3660			endm  
# End of macro DMARK
3660						CALLMONITOR 
3660 cd 6f ee			call debug_vector  
3663				endm  
# End of macro CALLMONITOR
3663					endif 
3663					; add top two values and push back result 
3663			 
3663					;for v5 FORTH_DSP_VALUE 
3663					FORTH_DSP 
3663 cd 44 1d			call macro_forth_dsp 
3666				endm 
# End of macro FORTH_DSP
3666 7e					ld a,(hl)	; get type of value on TOS 
3667 fe 02				cp DS_TYPE_INUM  
3669 28 03				jr z, .dot_inum 
366b			 
366b					NEXTW 
366b c3 34 1f			jp macro_next 
366e				endm 
# End of macro NEXTW
366e			 
366e			; float maths 
366e			 
366e				if FORTH_ENABLE_FLOATMATH 
366e						inc hl      ; now at start of numeric as string 
366e			 
366e					if DEBUG_FORTH_MATHS 
366e						DMARK "ADD" 
366e				CALLMONITOR 
366e					endif 
366e			 
366e					;ld ix, hl 
366e					call CON 
366e			 
366e			 
366e					push hl 
366e					 
366e					 
366e			 
366e						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
366e			 
366e					; get next number 
366e			 
366e						FORTH_DSP_VALUE 
366e			 
366e						inc hl      ; now at start of numeric as string 
366e			 
366e					;ld ix, hl 
366e					call CON 
366e			 
366e					push hl 
366e			 
366e			 
366e						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
366e			 
366e						; TODO do add 
366e			 
366e						call IADD 
366e			 
366e						; TODO get result back as ascii 
366e			 
366e						; TODO push result  
366e			 
366e			 
366e			 
366e						jr .dot_done 
366e				endif 
366e			 
366e			.dot_inum: 
366e			 
366e			 
366e					if DEBUG_FORTH_DOT 
366e						DMARK "+IT" 
366e f5				push af  
366f 3a 83 36			ld a, (.dmark)  
3672 32 6b ee			ld (debug_mark),a  
3675 3a 84 36			ld a, (.dmark+1)  
3678 32 6c ee			ld (debug_mark+1),a  
367b 3a 85 36			ld a, (.dmark+2)  
367e 32 6d ee			ld (debug_mark+2),a  
3681 18 03			jr .pastdmark  
3683 ..			.dmark: db "+IT"  
3686 f1			.pastdmark: pop af  
3687			endm  
# End of macro DMARK
3687				CALLMONITOR 
3687 cd 6f ee			call debug_vector  
368a				endm  
# End of macro CALLMONITOR
368a					endif 
368a			 
368a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
368a cd 7e 1d			call macro_dsp_valuehl 
368d				endm 
# End of macro FORTH_DSP_VALUEHL
368d			 
368d				; TODO add floating point number detection 
368d			 
368d e5					push hl 
368e			 
368e					; destroy value TOS 
368e			 
368e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
368e cd 36 1e			call macro_forth_dsp_pop 
3691				endm 
# End of macro FORTH_DSP_POP
3691			 
3691			 
3691					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3691 cd 7e 1d			call macro_dsp_valuehl 
3694				endm 
# End of macro FORTH_DSP_VALUEHL
3694			 
3694					; one value on hl get other one back 
3694			 
3694 d1					pop de 
3695			 
3695					; do the add 
3695			 
3695 19					add hl,de 
3696			 
3696					; save it 
3696			 
3696			;		push hl	 
3696			 
3696					; 
3696			 
3696					; destroy value TOS 
3696			 
3696					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3696 cd 36 1e			call macro_forth_dsp_pop 
3699				endm 
# End of macro FORTH_DSP_POP
3699			 
3699					; TODO push value back onto stack for another op etc 
3699			 
3699			;		pop hl 
3699			 
3699			.dot_done: 
3699 cd 79 1b				call forth_push_numhl 
369c			 
369c					NEXTW 
369c c3 34 1f			jp macro_next 
369f				endm 
# End of macro NEXTW
369f			.NEG: 
369f			 
369f				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
369f 17				db WORD_SYS_CORE+3             
36a0 e2 36			dw .DIV            
36a2 02				db 1 + 1 
36a3 .. 00			db "-",0              
36a5				endm 
# End of macro CWHEAD
36a5			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36a5					if DEBUG_FORTH_WORDS_KEY 
36a5						DMARK "SUB" 
36a5 f5				push af  
36a6 3a ba 36			ld a, (.dmark)  
36a9 32 6b ee			ld (debug_mark),a  
36ac 3a bb 36			ld a, (.dmark+1)  
36af 32 6c ee			ld (debug_mark+1),a  
36b2 3a bc 36			ld a, (.dmark+2)  
36b5 32 6d ee			ld (debug_mark+2),a  
36b8 18 03			jr .pastdmark  
36ba ..			.dmark: db "SUB"  
36bd f1			.pastdmark: pop af  
36be			endm  
# End of macro DMARK
36be						CALLMONITOR 
36be cd 6f ee			call debug_vector  
36c1				endm  
# End of macro CALLMONITOR
36c1					endif 
36c1			 
36c1			 
36c1				; TODO add floating point number detection 
36c1					; v5 FORTH_DSP_VALUE 
36c1					FORTH_DSP 
36c1 cd 44 1d			call macro_forth_dsp 
36c4				endm 
# End of macro FORTH_DSP
36c4 7e					ld a,(hl)	; get type of value on TOS 
36c5 fe 02				cp DS_TYPE_INUM  
36c7 28 03				jr z, .neg_inum 
36c9			 
36c9					NEXTW 
36c9 c3 34 1f			jp macro_next 
36cc				endm 
# End of macro NEXTW
36cc			 
36cc			; float maths 
36cc			 
36cc				if FORTH_ENABLE_FLOATMATH 
36cc					jr .neg_done 
36cc			 
36cc				endif 
36cc					 
36cc			 
36cc			.neg_inum: 
36cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36cc cd 7e 1d			call macro_dsp_valuehl 
36cf				endm 
# End of macro FORTH_DSP_VALUEHL
36cf			 
36cf e5					push hl 
36d0			 
36d0					; destroy value TOS 
36d0			 
36d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36d0 cd 36 1e			call macro_forth_dsp_pop 
36d3				endm 
# End of macro FORTH_DSP_POP
36d3			 
36d3			 
36d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36d3 cd 7e 1d			call macro_dsp_valuehl 
36d6				endm 
# End of macro FORTH_DSP_VALUEHL
36d6			 
36d6					; one value on hl get other one back 
36d6			 
36d6 d1					pop de 
36d7			 
36d7					; do the sub 
36d7			;		ex de, hl 
36d7			 
36d7 ed 52				sbc hl,de 
36d9			 
36d9					; save it 
36d9			 
36d9			;		push hl	 
36d9			 
36d9					; 
36d9			 
36d9					; destroy value TOS 
36d9			 
36d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36d9 cd 36 1e			call macro_forth_dsp_pop 
36dc				endm 
# End of macro FORTH_DSP_POP
36dc			 
36dc					; TODO push value back onto stack for another op etc 
36dc			 
36dc			;		pop hl 
36dc			 
36dc cd 79 1b				call forth_push_numhl 
36df			.neg_done: 
36df			 
36df					NEXTW 
36df c3 34 1f			jp macro_next 
36e2				endm 
# End of macro NEXTW
36e2			.DIV: 
36e2				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36e2 18				db WORD_SYS_CORE+4             
36e3 2f 37			dw .MUL            
36e5 02				db 1 + 1 
36e6 .. 00			db "/",0              
36e8				endm 
# End of macro CWHEAD
36e8			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
36e8					if DEBUG_FORTH_WORDS_KEY 
36e8						DMARK "DIV" 
36e8 f5				push af  
36e9 3a fd 36			ld a, (.dmark)  
36ec 32 6b ee			ld (debug_mark),a  
36ef 3a fe 36			ld a, (.dmark+1)  
36f2 32 6c ee			ld (debug_mark+1),a  
36f5 3a ff 36			ld a, (.dmark+2)  
36f8 32 6d ee			ld (debug_mark+2),a  
36fb 18 03			jr .pastdmark  
36fd ..			.dmark: db "DIV"  
3700 f1			.pastdmark: pop af  
3701			endm  
# End of macro DMARK
3701						CALLMONITOR 
3701 cd 6f ee			call debug_vector  
3704				endm  
# End of macro CALLMONITOR
3704					endif 
3704				; TODO add floating point number detection 
3704					; v5 FORTH_DSP_VALUE 
3704					FORTH_DSP 
3704 cd 44 1d			call macro_forth_dsp 
3707				endm 
# End of macro FORTH_DSP
3707 7e					ld a,(hl)	; get type of value on TOS 
3708 fe 02				cp DS_TYPE_INUM  
370a 28 03				jr z, .div_inum 
370c			 
370c				if FORTH_ENABLE_FLOATMATH 
370c					jr .div_done 
370c			 
370c				endif 
370c					NEXTW 
370c c3 34 1f			jp macro_next 
370f				endm 
# End of macro NEXTW
370f			.div_inum: 
370f			 
370f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
370f cd 7e 1d			call macro_dsp_valuehl 
3712				endm 
# End of macro FORTH_DSP_VALUEHL
3712			 
3712 e5					push hl    ; to go to bc 
3713			 
3713					; destroy value TOS 
3713			 
3713					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3713 cd 36 1e			call macro_forth_dsp_pop 
3716				endm 
# End of macro FORTH_DSP_POP
3716			 
3716			 
3716					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3716 cd 7e 1d			call macro_dsp_valuehl 
3719				endm 
# End of macro FORTH_DSP_VALUEHL
3719			 
3719					; hl to go to de 
3719			 
3719 e5					push hl 
371a			 
371a c1					pop bc 
371b d1					pop de		 
371c			 
371c			 
371c					if DEBUG_FORTH_MATHS 
371c						DMARK "DIV" 
371c				CALLMONITOR 
371c					endif 
371c					; one value on hl but move to a get other one back 
371c			 
371c			        
371c cd 4f 0d			call Div16 
371f			 
371f			;	push af	 
371f e5				push hl 
3720 c5				push bc 
3721			 
3721					if DEBUG_FORTH_MATHS 
3721						DMARK "DI1" 
3721				CALLMONITOR 
3721					endif 
3721			 
3721					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3721 cd 36 1e			call macro_forth_dsp_pop 
3724				endm 
# End of macro FORTH_DSP_POP
3724			 
3724			 
3724			 
3724 e1					pop hl    ; result 
3725			 
3725 cd 79 1b				call forth_push_numhl 
3728			 
3728 e1					pop hl    ; reminder 
3729			;		ld h,0 
3729			;		ld l,d 
3729			 
3729 cd 79 1b				call forth_push_numhl 
372c			.div_done: 
372c					NEXTW 
372c c3 34 1f			jp macro_next 
372f				endm 
# End of macro NEXTW
372f			.MUL: 
372f				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
372f 19				db WORD_SYS_CORE+5             
3730 74 37			dw .MIN            
3732 02				db 1 + 1 
3733 .. 00			db "*",0              
3735				endm 
# End of macro CWHEAD
3735			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3735				; TODO add floating point number detection 
3735					if DEBUG_FORTH_WORDS_KEY 
3735						DMARK "MUL" 
3735 f5				push af  
3736 3a 4a 37			ld a, (.dmark)  
3739 32 6b ee			ld (debug_mark),a  
373c 3a 4b 37			ld a, (.dmark+1)  
373f 32 6c ee			ld (debug_mark+1),a  
3742 3a 4c 37			ld a, (.dmark+2)  
3745 32 6d ee			ld (debug_mark+2),a  
3748 18 03			jr .pastdmark  
374a ..			.dmark: db "MUL"  
374d f1			.pastdmark: pop af  
374e			endm  
# End of macro DMARK
374e						CALLMONITOR 
374e cd 6f ee			call debug_vector  
3751				endm  
# End of macro CALLMONITOR
3751					endif 
3751					FORTH_DSP 
3751 cd 44 1d			call macro_forth_dsp 
3754				endm 
# End of macro FORTH_DSP
3754					; v5 FORTH_DSP_VALUE 
3754 7e					ld a,(hl)	; get type of value on TOS 
3755 fe 02				cp DS_TYPE_INUM  
3757 28 03				jr z, .mul_inum 
3759			 
3759				if FORTH_ENABLE_FLOATMATH 
3759					jr .mul_done 
3759			 
3759				endif 
3759			 
3759					NEXTW 
3759 c3 34 1f			jp macro_next 
375c				endm 
# End of macro NEXTW
375c			.mul_inum:	 
375c			 
375c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
375c cd 7e 1d			call macro_dsp_valuehl 
375f				endm 
# End of macro FORTH_DSP_VALUEHL
375f			 
375f e5					push hl 
3760			 
3760					; destroy value TOS 
3760			 
3760					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3760 cd 36 1e			call macro_forth_dsp_pop 
3763				endm 
# End of macro FORTH_DSP_POP
3763			 
3763			 
3763					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3763 cd 7e 1d			call macro_dsp_valuehl 
3766				endm 
# End of macro FORTH_DSP_VALUEHL
3766			 
3766					; one value on hl but move to a get other one back 
3766			 
3766 7d					ld a, l 
3767			 
3767 d1					pop de 
3768			 
3768					; do the mull 
3768			;		ex de, hl 
3768			 
3768 cd 75 0d				call Mult16 
376b					; save it 
376b			 
376b			;		push hl	 
376b			 
376b					; 
376b			 
376b					; destroy value TOS 
376b			 
376b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
376b cd 36 1e			call macro_forth_dsp_pop 
376e				endm 
# End of macro FORTH_DSP_POP
376e			 
376e					; TODO push value back onto stack for another op etc 
376e			 
376e			;		pop hl 
376e			 
376e cd 79 1b				call forth_push_numhl 
3771			 
3771			.mul_done: 
3771					NEXTW 
3771 c3 34 1f			jp macro_next 
3774				endm 
# End of macro NEXTW
3774			 
3774			 
3774			 
3774			 
3774			.MIN: 
3774				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3774 49				db WORD_SYS_CORE+53             
3775 f5 37			dw .MAX            
3777 04				db 3 + 1 
3778 .. 00			db "MIN",0              
377c				endm 
# End of macro CWHEAD
377c			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
377c					if DEBUG_FORTH_WORDS_KEY 
377c						DMARK "MIN" 
377c f5				push af  
377d 3a 91 37			ld a, (.dmark)  
3780 32 6b ee			ld (debug_mark),a  
3783 3a 92 37			ld a, (.dmark+1)  
3786 32 6c ee			ld (debug_mark+1),a  
3789 3a 93 37			ld a, (.dmark+2)  
378c 32 6d ee			ld (debug_mark+2),a  
378f 18 03			jr .pastdmark  
3791 ..			.dmark: db "MIN"  
3794 f1			.pastdmark: pop af  
3795			endm  
# End of macro DMARK
3795						CALLMONITOR 
3795 cd 6f ee			call debug_vector  
3798				endm  
# End of macro CALLMONITOR
3798					endif 
3798					; get u2 
3798			 
3798					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3798 cd 7e 1d			call macro_dsp_valuehl 
379b				endm 
# End of macro FORTH_DSP_VALUEHL
379b			 
379b e5					push hl   ; u2 
379c			 
379c					; destroy value TOS 
379c			 
379c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
379c cd 36 1e			call macro_forth_dsp_pop 
379f				endm 
# End of macro FORTH_DSP_POP
379f			 
379f					; get u1 
379f			 
379f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
379f cd 7e 1d			call macro_dsp_valuehl 
37a2				endm 
# End of macro FORTH_DSP_VALUEHL
37a2			 
37a2 e5					push hl  ; u1 
37a3			 
37a3					; destroy value TOS 
37a3			 
37a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a3 cd 36 1e			call macro_forth_dsp_pop 
37a6				endm 
# End of macro FORTH_DSP_POP
37a6			 
37a6 b7			 or a      ;clear carry flag 
37a7 e1			  pop hl    ; u1 
37a8 d1			  pop de    ; u2 
37a9 e5				push hl   ; saved in case hl is lowest 
37aa ed 52		  sbc hl,de 
37ac 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37ae			 
37ae e1				pop hl 
37af					if DEBUG_FORTH_WORDS 
37af						DMARK "MIN" 
37af f5				push af  
37b0 3a c4 37			ld a, (.dmark)  
37b3 32 6b ee			ld (debug_mark),a  
37b6 3a c5 37			ld a, (.dmark+1)  
37b9 32 6c ee			ld (debug_mark+1),a  
37bc 3a c6 37			ld a, (.dmark+2)  
37bf 32 6d ee			ld (debug_mark+2),a  
37c2 18 03			jr .pastdmark  
37c4 ..			.dmark: db "MIN"  
37c7 f1			.pastdmark: pop af  
37c8			endm  
# End of macro DMARK
37c8						CALLMONITOR 
37c8 cd 6f ee			call debug_vector  
37cb				endm  
# End of macro CALLMONITOR
37cb					endif 
37cb cd 79 1b				call forth_push_numhl 
37ce			 
37ce				       NEXTW 
37ce c3 34 1f			jp macro_next 
37d1				endm 
# End of macro NEXTW
37d1			 
37d1			.mincont:  
37d1 c1				pop bc   ; tidy up 
37d2 eb				ex de , hl  
37d3					if DEBUG_FORTH_WORDS 
37d3						DMARK "MI1" 
37d3 f5				push af  
37d4 3a e8 37			ld a, (.dmark)  
37d7 32 6b ee			ld (debug_mark),a  
37da 3a e9 37			ld a, (.dmark+1)  
37dd 32 6c ee			ld (debug_mark+1),a  
37e0 3a ea 37			ld a, (.dmark+2)  
37e3 32 6d ee			ld (debug_mark+2),a  
37e6 18 03			jr .pastdmark  
37e8 ..			.dmark: db "MI1"  
37eb f1			.pastdmark: pop af  
37ec			endm  
# End of macro DMARK
37ec						CALLMONITOR 
37ec cd 6f ee			call debug_vector  
37ef				endm  
# End of macro CALLMONITOR
37ef					endif 
37ef cd 79 1b				call forth_push_numhl 
37f2			 
37f2				       NEXTW 
37f2 c3 34 1f			jp macro_next 
37f5				endm 
# End of macro NEXTW
37f5			.MAX: 
37f5				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
37f5 4a				db WORD_SYS_CORE+54             
37f6 76 38			dw .RND16            
37f8 04				db 3 + 1 
37f9 .. 00			db "MAX",0              
37fd				endm 
# End of macro CWHEAD
37fd			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
37fd					if DEBUG_FORTH_WORDS_KEY 
37fd						DMARK "MAX" 
37fd f5				push af  
37fe 3a 12 38			ld a, (.dmark)  
3801 32 6b ee			ld (debug_mark),a  
3804 3a 13 38			ld a, (.dmark+1)  
3807 32 6c ee			ld (debug_mark+1),a  
380a 3a 14 38			ld a, (.dmark+2)  
380d 32 6d ee			ld (debug_mark+2),a  
3810 18 03			jr .pastdmark  
3812 ..			.dmark: db "MAX"  
3815 f1			.pastdmark: pop af  
3816			endm  
# End of macro DMARK
3816						CALLMONITOR 
3816 cd 6f ee			call debug_vector  
3819				endm  
# End of macro CALLMONITOR
3819					endif 
3819					; get u2 
3819			 
3819					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3819 cd 7e 1d			call macro_dsp_valuehl 
381c				endm 
# End of macro FORTH_DSP_VALUEHL
381c			 
381c e5					push hl   ; u2 
381d			 
381d					; destroy value TOS 
381d			 
381d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
381d cd 36 1e			call macro_forth_dsp_pop 
3820				endm 
# End of macro FORTH_DSP_POP
3820			 
3820					; get u1 
3820			 
3820					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3820 cd 7e 1d			call macro_dsp_valuehl 
3823				endm 
# End of macro FORTH_DSP_VALUEHL
3823			 
3823 e5					push hl  ; u1 
3824			 
3824					; destroy value TOS 
3824			 
3824					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3824 cd 36 1e			call macro_forth_dsp_pop 
3827				endm 
# End of macro FORTH_DSP_POP
3827			 
3827 b7			 or a      ;clear carry flag 
3828 e1			  pop hl    ; u1 
3829 d1			  pop de    ; u2 
382a e5				push hl   ; saved in case hl is lowest 
382b ed 52		  sbc hl,de 
382d 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
382f			 
382f e1				pop hl 
3830					if DEBUG_FORTH_WORDS 
3830						DMARK "MAX" 
3830 f5				push af  
3831 3a 45 38			ld a, (.dmark)  
3834 32 6b ee			ld (debug_mark),a  
3837 3a 46 38			ld a, (.dmark+1)  
383a 32 6c ee			ld (debug_mark+1),a  
383d 3a 47 38			ld a, (.dmark+2)  
3840 32 6d ee			ld (debug_mark+2),a  
3843 18 03			jr .pastdmark  
3845 ..			.dmark: db "MAX"  
3848 f1			.pastdmark: pop af  
3849			endm  
# End of macro DMARK
3849						CALLMONITOR 
3849 cd 6f ee			call debug_vector  
384c				endm  
# End of macro CALLMONITOR
384c					endif 
384c cd 79 1b				call forth_push_numhl 
384f			 
384f				       NEXTW 
384f c3 34 1f			jp macro_next 
3852				endm 
# End of macro NEXTW
3852			 
3852			.maxcont:  
3852 c1				pop bc   ; tidy up 
3853 eb				ex de , hl  
3854					if DEBUG_FORTH_WORDS 
3854						DMARK "MA1" 
3854 f5				push af  
3855 3a 69 38			ld a, (.dmark)  
3858 32 6b ee			ld (debug_mark),a  
385b 3a 6a 38			ld a, (.dmark+1)  
385e 32 6c ee			ld (debug_mark+1),a  
3861 3a 6b 38			ld a, (.dmark+2)  
3864 32 6d ee			ld (debug_mark+2),a  
3867 18 03			jr .pastdmark  
3869 ..			.dmark: db "MA1"  
386c f1			.pastdmark: pop af  
386d			endm  
# End of macro DMARK
386d						CALLMONITOR 
386d cd 6f ee			call debug_vector  
3870				endm  
# End of macro CALLMONITOR
3870					endif 
3870 cd 79 1b				call forth_push_numhl 
3873				       NEXTW 
3873 c3 34 1f			jp macro_next 
3876				endm 
# End of macro NEXTW
3876			 
3876			.RND16: 
3876				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3876 4e				db WORD_SYS_CORE+58             
3877 a5 38			dw .RND8            
3879 06				db 5 + 1 
387a .. 00			db "RND16",0              
3880				endm 
# End of macro CWHEAD
3880			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3880					if DEBUG_FORTH_WORDS_KEY 
3880						DMARK "R16" 
3880 f5				push af  
3881 3a 95 38			ld a, (.dmark)  
3884 32 6b ee			ld (debug_mark),a  
3887 3a 96 38			ld a, (.dmark+1)  
388a 32 6c ee			ld (debug_mark+1),a  
388d 3a 97 38			ld a, (.dmark+2)  
3890 32 6d ee			ld (debug_mark+2),a  
3893 18 03			jr .pastdmark  
3895 ..			.dmark: db "R16"  
3898 f1			.pastdmark: pop af  
3899			endm  
# End of macro DMARK
3899						CALLMONITOR 
3899 cd 6f ee			call debug_vector  
389c				endm  
# End of macro CALLMONITOR
389c					endif 
389c cd 19 0d				call prng16  
389f cd 79 1b				call forth_push_numhl 
38a2				       NEXTW 
38a2 c3 34 1f			jp macro_next 
38a5				endm 
# End of macro NEXTW
38a5			.RND8: 
38a5				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38a5 60				db WORD_SYS_CORE+76             
38a6 da 38			dw .RND            
38a8 05				db 4 + 1 
38a9 .. 00			db "RND8",0              
38ae				endm 
# End of macro CWHEAD
38ae			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38ae					if DEBUG_FORTH_WORDS_KEY 
38ae						DMARK "RN8" 
38ae f5				push af  
38af 3a c3 38			ld a, (.dmark)  
38b2 32 6b ee			ld (debug_mark),a  
38b5 3a c4 38			ld a, (.dmark+1)  
38b8 32 6c ee			ld (debug_mark+1),a  
38bb 3a c5 38			ld a, (.dmark+2)  
38be 32 6d ee			ld (debug_mark+2),a  
38c1 18 03			jr .pastdmark  
38c3 ..			.dmark: db "RN8"  
38c6 f1			.pastdmark: pop af  
38c7			endm  
# End of macro DMARK
38c7						CALLMONITOR 
38c7 cd 6f ee			call debug_vector  
38ca				endm  
# End of macro CALLMONITOR
38ca					endif 
38ca 2a a9 eb				ld hl,(xrandc) 
38cd 23					inc hl 
38ce cd 33 0d				call xrnd 
38d1 6f					ld l,a	 
38d2 26 00				ld h,0 
38d4 cd 79 1b				call forth_push_numhl 
38d7				       NEXTW 
38d7 c3 34 1f			jp macro_next 
38da				endm 
# End of macro NEXTW
38da			.RND: 
38da				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38da 60				db WORD_SYS_CORE+76             
38db e0 39			dw .ENDMATHS            
38dd 04				db 3 + 1 
38de .. 00			db "RND",0              
38e2				endm 
# End of macro CWHEAD
38e2			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38e2			 
38e2					if DEBUG_FORTH_WORDS_KEY 
38e2						DMARK "RND" 
38e2 f5				push af  
38e3 3a f7 38			ld a, (.dmark)  
38e6 32 6b ee			ld (debug_mark),a  
38e9 3a f8 38			ld a, (.dmark+1)  
38ec 32 6c ee			ld (debug_mark+1),a  
38ef 3a f9 38			ld a, (.dmark+2)  
38f2 32 6d ee			ld (debug_mark+2),a  
38f5 18 03			jr .pastdmark  
38f7 ..			.dmark: db "RND"  
38fa f1			.pastdmark: pop af  
38fb			endm  
# End of macro DMARK
38fb						CALLMONITOR 
38fb cd 6f ee			call debug_vector  
38fe				endm  
# End of macro CALLMONITOR
38fe					endif 
38fe					 
38fe					FORTH_DSP_VALUEHL    ; upper range 
38fe cd 7e 1d			call macro_dsp_valuehl 
3901				endm 
# End of macro FORTH_DSP_VALUEHL
3901			 
3901 22 ad eb				ld (LFSRSeed), hl	 
3904			 
3904					if DEBUG_FORTH_WORDS 
3904						DMARK "RN1" 
3904 f5				push af  
3905 3a 19 39			ld a, (.dmark)  
3908 32 6b ee			ld (debug_mark),a  
390b 3a 1a 39			ld a, (.dmark+1)  
390e 32 6c ee			ld (debug_mark+1),a  
3911 3a 1b 39			ld a, (.dmark+2)  
3914 32 6d ee			ld (debug_mark+2),a  
3917 18 03			jr .pastdmark  
3919 ..			.dmark: db "RN1"  
391c f1			.pastdmark: pop af  
391d			endm  
# End of macro DMARK
391d						CALLMONITOR 
391d cd 6f ee			call debug_vector  
3920				endm  
# End of macro CALLMONITOR
3920					endif 
3920					FORTH_DSP_POP 
3920 cd 36 1e			call macro_forth_dsp_pop 
3923				endm 
# End of macro FORTH_DSP_POP
3923			 
3923					FORTH_DSP_VALUEHL    ; low range 
3923 cd 7e 1d			call macro_dsp_valuehl 
3926				endm 
# End of macro FORTH_DSP_VALUEHL
3926			 
3926					if DEBUG_FORTH_WORDS 
3926						DMARK "RN2" 
3926 f5				push af  
3927 3a 3b 39			ld a, (.dmark)  
392a 32 6b ee			ld (debug_mark),a  
392d 3a 3c 39			ld a, (.dmark+1)  
3930 32 6c ee			ld (debug_mark+1),a  
3933 3a 3d 39			ld a, (.dmark+2)  
3936 32 6d ee			ld (debug_mark+2),a  
3939 18 03			jr .pastdmark  
393b ..			.dmark: db "RN2"  
393e f1			.pastdmark: pop af  
393f			endm  
# End of macro DMARK
393f						CALLMONITOR 
393f cd 6f ee			call debug_vector  
3942				endm  
# End of macro CALLMONITOR
3942					endif 
3942 22 af eb				ld (LFSRSeed+2), hl 
3945			 
3945					FORTH_DSP_POP 
3945 cd 36 1e			call macro_forth_dsp_pop 
3948				endm 
# End of macro FORTH_DSP_POP
3948			 
3948 e5					push hl 
3949			 
3949 e1			.inrange:	pop hl 
394a cd 19 0d				call prng16  
394d					if DEBUG_FORTH_WORDS 
394d						DMARK "RN3" 
394d f5				push af  
394e 3a 62 39			ld a, (.dmark)  
3951 32 6b ee			ld (debug_mark),a  
3954 3a 63 39			ld a, (.dmark+1)  
3957 32 6c ee			ld (debug_mark+1),a  
395a 3a 64 39			ld a, (.dmark+2)  
395d 32 6d ee			ld (debug_mark+2),a  
3960 18 03			jr .pastdmark  
3962 ..			.dmark: db "RN3"  
3965 f1			.pastdmark: pop af  
3966			endm  
# End of macro DMARK
3966						CALLMONITOR 
3966 cd 6f ee			call debug_vector  
3969				endm  
# End of macro CALLMONITOR
3969					endif 
3969					 
3969					; if the range is 8bit knock out the high byte 
3969			 
3969 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
396d			 
396d 3e 00				ld a, 0 
396f ba					cp d  
3970 20 1e				jr nz, .hirange 
3972 26 00				ld h, 0   ; knock it down to 8bit 
3974			 
3974					if DEBUG_FORTH_WORDS 
3974						DMARK "RNk" 
3974 f5				push af  
3975 3a 89 39			ld a, (.dmark)  
3978 32 6b ee			ld (debug_mark),a  
397b 3a 8a 39			ld a, (.dmark+1)  
397e 32 6c ee			ld (debug_mark+1),a  
3981 3a 8b 39			ld a, (.dmark+2)  
3984 32 6d ee			ld (debug_mark+2),a  
3987 18 03			jr .pastdmark  
3989 ..			.dmark: db "RNk"  
398c f1			.pastdmark: pop af  
398d			endm  
# End of macro DMARK
398d						CALLMONITOR 
398d cd 6f ee			call debug_vector  
3990				endm  
# End of macro CALLMONITOR
3990					endif 
3990			.hirange:   
3990 e5					push hl  
3991 b7					or a  
3992 ed 52		                sbc hl, de 
3994			 
3994					;call cmp16 
3994			 
3994 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3996 e1					pop hl 
3997 e5					push hl 
3998			 
3998					if DEBUG_FORTH_WORDS 
3998						DMARK "RN4" 
3998 f5				push af  
3999 3a ad 39			ld a, (.dmark)  
399c 32 6b ee			ld (debug_mark),a  
399f 3a ae 39			ld a, (.dmark+1)  
39a2 32 6c ee			ld (debug_mark+1),a  
39a5 3a af 39			ld a, (.dmark+2)  
39a8 32 6d ee			ld (debug_mark+2),a  
39ab 18 03			jr .pastdmark  
39ad ..			.dmark: db "RN4"  
39b0 f1			.pastdmark: pop af  
39b1			endm  
# End of macro DMARK
39b1						CALLMONITOR 
39b1 cd 6f ee			call debug_vector  
39b4				endm  
# End of macro CALLMONITOR
39b4					endif 
39b4 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
39b8					;call cmp16 
39b8				 
39b8 b7					or a  
39b9 ed 52		                sbc hl, de 
39bb 38 8c				jr c, .inrange 
39bd			 
39bd e1					pop hl 
39be					 
39be					if DEBUG_FORTH_WORDS 
39be						DMARK "RNd" 
39be f5				push af  
39bf 3a d3 39			ld a, (.dmark)  
39c2 32 6b ee			ld (debug_mark),a  
39c5 3a d4 39			ld a, (.dmark+1)  
39c8 32 6c ee			ld (debug_mark+1),a  
39cb 3a d5 39			ld a, (.dmark+2)  
39ce 32 6d ee			ld (debug_mark+2),a  
39d1 18 03			jr .pastdmark  
39d3 ..			.dmark: db "RNd"  
39d6 f1			.pastdmark: pop af  
39d7			endm  
# End of macro DMARK
39d7						CALLMONITOR 
39d7 cd 6f ee			call debug_vector  
39da				endm  
# End of macro CALLMONITOR
39da					endif 
39da			 
39da			 
39da cd 79 1b				call forth_push_numhl 
39dd				       NEXTW 
39dd c3 34 1f			jp macro_next 
39e0				endm 
# End of macro NEXTW
39e0			 
39e0			.ENDMATHS: 
39e0			 
39e0			; eof 
39e0			 
# End of file forth_words_maths.asm
39e0			include "forth_words_display.asm" 
39e0			 
39e0			; | ## Display Words 
39e0			 
39e0			.ACT: 
39e0			 
39e0				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
39e0 62				db WORD_SYS_CORE+78             
39e1 2c 3a			dw .INFO            
39e3 07				db 6 + 1 
39e4 .. 00			db "ACTIVE",0              
39eb				endm 
# End of macro CWHEAD
39eb			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
39eb			;  
39eb			; | | To display a pulsing activity indicator in a processing loop do this... 
39eb			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
39eb			 
39eb					if DEBUG_FORTH_WORDS_KEY 
39eb						DMARK "ACT" 
39eb f5				push af  
39ec 3a 00 3a			ld a, (.dmark)  
39ef 32 6b ee			ld (debug_mark),a  
39f2 3a 01 3a			ld a, (.dmark+1)  
39f5 32 6c ee			ld (debug_mark+1),a  
39f8 3a 02 3a			ld a, (.dmark+2)  
39fb 32 6d ee			ld (debug_mark+2),a  
39fe 18 03			jr .pastdmark  
3a00 ..			.dmark: db "ACT"  
3a03 f1			.pastdmark: pop af  
3a04			endm  
# End of macro DMARK
3a04						CALLMONITOR 
3a04 cd 6f ee			call debug_vector  
3a07				endm  
# End of macro CALLMONITOR
3a07					endif 
3a07 cd 1c 0b				call active 
3a0a					if DEBUG_FORTH_WORDS 
3a0a						DMARK "ACp" 
3a0a f5				push af  
3a0b 3a 1f 3a			ld a, (.dmark)  
3a0e 32 6b ee			ld (debug_mark),a  
3a11 3a 20 3a			ld a, (.dmark+1)  
3a14 32 6c ee			ld (debug_mark+1),a  
3a17 3a 21 3a			ld a, (.dmark+2)  
3a1a 32 6d ee			ld (debug_mark+2),a  
3a1d 18 03			jr .pastdmark  
3a1f ..			.dmark: db "ACp"  
3a22 f1			.pastdmark: pop af  
3a23			endm  
# End of macro DMARK
3a23						CALLMONITOR 
3a23 cd 6f ee			call debug_vector  
3a26				endm  
# End of macro CALLMONITOR
3a26					endif 
3a26 cd e7 1b				call forth_push_str 
3a29			 
3a29					NEXTW 
3a29 c3 34 1f			jp macro_next 
3a2c				endm 
# End of macro NEXTW
3a2c			.INFO: 
3a2c			 
3a2c				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a2c 62				db WORD_SYS_CORE+78             
3a2d 49 3a			dw .ATP            
3a2f 05				db 4 + 1 
3a30 .. 00			db "INFO",0              
3a35				endm 
# End of macro CWHEAD
3a35			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a35					FORTH_DSP_VALUEHL 
3a35 cd 7e 1d			call macro_dsp_valuehl 
3a38				endm 
# End of macro FORTH_DSP_VALUEHL
3a38			 
3a38					FORTH_DSP_POP 
3a38 cd 36 1e			call macro_forth_dsp_pop 
3a3b				endm 
# End of macro FORTH_DSP_POP
3a3b			 
3a3b e5					push hl 
3a3c			 
3a3c					FORTH_DSP_VALUEHL 
3a3c cd 7e 1d			call macro_dsp_valuehl 
3a3f				endm 
# End of macro FORTH_DSP_VALUEHL
3a3f			 
3a3f					FORTH_DSP_POP 
3a3f cd 36 1e			call macro_forth_dsp_pop 
3a42				endm 
# End of macro FORTH_DSP_POP
3a42			 
3a42 d1					pop de 
3a43			 
3a43 cd 56 0b				call info_panel 
3a46			 
3a46			 
3a46					NEXTW 
3a46 c3 34 1f			jp macro_next 
3a49				endm 
# End of macro NEXTW
3a49			.ATP: 
3a49				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a49 62				db WORD_SYS_CORE+78             
3a4a c0 3a			dw .FB            
3a4c 04				db 3 + 1 
3a4d .. 00			db "AT?",0              
3a51				endm 
# End of macro CWHEAD
3a51			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a51					if DEBUG_FORTH_WORDS_KEY 
3a51						DMARK "AT?" 
3a51 f5				push af  
3a52 3a 66 3a			ld a, (.dmark)  
3a55 32 6b ee			ld (debug_mark),a  
3a58 3a 67 3a			ld a, (.dmark+1)  
3a5b 32 6c ee			ld (debug_mark+1),a  
3a5e 3a 68 3a			ld a, (.dmark+2)  
3a61 32 6d ee			ld (debug_mark+2),a  
3a64 18 03			jr .pastdmark  
3a66 ..			.dmark: db "AT?"  
3a69 f1			.pastdmark: pop af  
3a6a			endm  
# End of macro DMARK
3a6a						CALLMONITOR 
3a6a cd 6f ee			call debug_vector  
3a6d				endm  
# End of macro CALLMONITOR
3a6d					endif 
3a6d 3a 5e ea				ld a, (f_cursor_ptr) 
3a70			 
3a70			if DEBUG_FORTH_WORDS 
3a70				DMARK "AT?" 
3a70 f5				push af  
3a71 3a 85 3a			ld a, (.dmark)  
3a74 32 6b ee			ld (debug_mark),a  
3a77 3a 86 3a			ld a, (.dmark+1)  
3a7a 32 6c ee			ld (debug_mark+1),a  
3a7d 3a 87 3a			ld a, (.dmark+2)  
3a80 32 6d ee			ld (debug_mark+2),a  
3a83 18 03			jr .pastdmark  
3a85 ..			.dmark: db "AT?"  
3a88 f1			.pastdmark: pop af  
3a89			endm  
# End of macro DMARK
3a89				CALLMONITOR 
3a89 cd 6f ee			call debug_vector  
3a8c				endm  
# End of macro CALLMONITOR
3a8c			endif	 
3a8c					; count the number of rows 
3a8c			 
3a8c 06 00				ld b, 0 
3a8e 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a8f d6 28				sub display_cols 
3a91 f2 97 3a				jp p, .atprunder 
3a94 04					inc b 
3a95 18 f7				jr .atpr 
3a97			.atprunder:	 
3a97			if DEBUG_FORTH_WORDS 
3a97				DMARK "A?2" 
3a97 f5				push af  
3a98 3a ac 3a			ld a, (.dmark)  
3a9b 32 6b ee			ld (debug_mark),a  
3a9e 3a ad 3a			ld a, (.dmark+1)  
3aa1 32 6c ee			ld (debug_mark+1),a  
3aa4 3a ae 3a			ld a, (.dmark+2)  
3aa7 32 6d ee			ld (debug_mark+2),a  
3aaa 18 03			jr .pastdmark  
3aac ..			.dmark: db "A?2"  
3aaf f1			.pastdmark: pop af  
3ab0			endm  
# End of macro DMARK
3ab0				CALLMONITOR 
3ab0 cd 6f ee			call debug_vector  
3ab3				endm  
# End of macro CALLMONITOR
3ab3			endif	 
3ab3 26 00				ld h, 0 
3ab5 69					ld l, c 
3ab6 cd 79 1b				call forth_push_numhl 
3ab9 68					ld l, b  
3aba cd 79 1b				call forth_push_numhl 
3abd			 
3abd			 
3abd				NEXTW 
3abd c3 34 1f			jp macro_next 
3ac0				endm 
# End of macro NEXTW
3ac0			 
3ac0			.FB: 
3ac0				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3ac0 1b				db WORD_SYS_CORE+7             
3ac1 0e 3b			dw .EMIT            
3ac3 03				db 2 + 1 
3ac4 .. 00			db "FB",0              
3ac7				endm 
# End of macro CWHEAD
3ac7			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ac7			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ac7			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ac7			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ac7					if DEBUG_FORTH_WORDS_KEY 
3ac7						DMARK "FB." 
3ac7 f5				push af  
3ac8 3a dc 3a			ld a, (.dmark)  
3acb 32 6b ee			ld (debug_mark),a  
3ace 3a dd 3a			ld a, (.dmark+1)  
3ad1 32 6c ee			ld (debug_mark+1),a  
3ad4 3a de 3a			ld a, (.dmark+2)  
3ad7 32 6d ee			ld (debug_mark+2),a  
3ada 18 03			jr .pastdmark  
3adc ..			.dmark: db "FB."  
3adf f1			.pastdmark: pop af  
3ae0			endm  
# End of macro DMARK
3ae0						CALLMONITOR 
3ae0 cd 6f ee			call debug_vector  
3ae3				endm  
# End of macro CALLMONITOR
3ae3					endif 
3ae3			 
3ae3					FORTH_DSP_VALUEHL 
3ae3 cd 7e 1d			call macro_dsp_valuehl 
3ae6				endm 
# End of macro FORTH_DSP_VALUEHL
3ae6			 
3ae6 7d					ld a, l 
3ae7 fe 01				cp 1 
3ae9 20 05				jr nz, .fbn1 
3aeb 21 10 ed				ld hl, display_fb1 
3aee 18 15				jr .fbset 
3af0 fe 02		.fbn1:		cp 2 
3af2 20 05				jr nz, .fbn2 
3af4 21 ce eb				ld hl, display_fb2 
3af7 18 0c				jr .fbset 
3af9 fe 03		.fbn2:		cp 3 
3afb 20 05				jr nz, .fbn3 
3afd 21 6f ec				ld hl, display_fb3 
3b00 18 03				jr .fbset 
3b02			.fbn3:		 ; if invalid number select first 
3b02 21 10 ed				ld hl, display_fb1 
3b05 22 cc eb		.fbset:		ld (display_fb_active), hl 
3b08			 
3b08					FORTH_DSP_POP 
3b08 cd 36 1e			call macro_forth_dsp_pop 
3b0b				endm 
# End of macro FORTH_DSP_POP
3b0b			 
3b0b					NEXTW 
3b0b c3 34 1f			jp macro_next 
3b0e				endm 
# End of macro NEXTW
3b0e			 
3b0e			 
3b0e			.EMIT: 
3b0e				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b0e 1b				db WORD_SYS_CORE+7             
3b0f 5f 3b			dw .DOTH            
3b11 05				db 4 + 1 
3b12 .. 00			db "EMIT",0              
3b17				endm 
# End of macro CWHEAD
3b17			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b17					; get value off TOS and display it 
3b17			 
3b17					if DEBUG_FORTH_WORDS_KEY 
3b17						DMARK "EMT" 
3b17 f5				push af  
3b18 3a 2c 3b			ld a, (.dmark)  
3b1b 32 6b ee			ld (debug_mark),a  
3b1e 3a 2d 3b			ld a, (.dmark+1)  
3b21 32 6c ee			ld (debug_mark+1),a  
3b24 3a 2e 3b			ld a, (.dmark+2)  
3b27 32 6d ee			ld (debug_mark+2),a  
3b2a 18 03			jr .pastdmark  
3b2c ..			.dmark: db "EMT"  
3b2f f1			.pastdmark: pop af  
3b30			endm  
# End of macro DMARK
3b30						CALLMONITOR 
3b30 cd 6f ee			call debug_vector  
3b33				endm  
# End of macro CALLMONITOR
3b33					endif 
3b33			 
3b33					FORTH_DSP_VALUEHL 
3b33 cd 7e 1d			call macro_dsp_valuehl 
3b36				endm 
# End of macro FORTH_DSP_VALUEHL
3b36			 
3b36 7d					ld a,l 
3b37			 
3b37					; TODO write to display 
3b37			 
3b37 32 bf e4				ld (os_input), a 
3b3a 3e 00				ld a, 0 
3b3c 32 c0 e4				ld (os_input+1), a 
3b3f					 
3b3f 3a 5e ea				ld a, (f_cursor_ptr) 
3b42 11 bf e4				ld de, os_input 
3b45 cd d8 0b				call str_at_display 
3b48			 
3b48			 
3b48 3a 3c ea				ld a,(cli_autodisplay) 
3b4b fe 00				cp 0 
3b4d 28 03				jr z, .enoupdate 
3b4f cd e8 0b						call update_display 
3b52					.enoupdate: 
3b52			 
3b52 3a 5e ea				ld a, (f_cursor_ptr) 
3b55 3c					inc a 
3b56 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3b59			 
3b59			 
3b59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b59 cd 36 1e			call macro_forth_dsp_pop 
3b5c				endm 
# End of macro FORTH_DSP_POP
3b5c			  
3b5c			 
3b5c					NEXTW 
3b5c c3 34 1f			jp macro_next 
3b5f				endm 
# End of macro NEXTW
3b5f			.DOTH: 
3b5f				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b5f 1c				db WORD_SYS_CORE+8             
3b60 8f 3b			dw .DOTF            
3b62 03				db 2 + 1 
3b63 .. 00			db ".-",0              
3b66				endm 
# End of macro CWHEAD
3b66			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b66					; get value off TOS and display it 
3b66					if DEBUG_FORTH_WORDS_KEY 
3b66						DMARK "DTD" 
3b66 f5				push af  
3b67 3a 7b 3b			ld a, (.dmark)  
3b6a 32 6b ee			ld (debug_mark),a  
3b6d 3a 7c 3b			ld a, (.dmark+1)  
3b70 32 6c ee			ld (debug_mark+1),a  
3b73 3a 7d 3b			ld a, (.dmark+2)  
3b76 32 6d ee			ld (debug_mark+2),a  
3b79 18 03			jr .pastdmark  
3b7b ..			.dmark: db "DTD"  
3b7e f1			.pastdmark: pop af  
3b7f			endm  
# End of macro DMARK
3b7f						CALLMONITOR 
3b7f cd 6f ee			call debug_vector  
3b82				endm  
# End of macro CALLMONITOR
3b82					endif 
3b82 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b84 3e 00			ld a, 0 
3b86 32 3d ea			ld (cli_mvdot), a 
3b89 c3 e6 3b			jp .dotgo 
3b8c				NEXTW 
3b8c c3 34 1f			jp macro_next 
3b8f				endm 
# End of macro NEXTW
3b8f			.DOTF: 
3b8f				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b8f 1c				db WORD_SYS_CORE+8             
3b90 bd 3b			dw .DOT            
3b92 03				db 2 + 1 
3b93 .. 00			db ".>",0              
3b96				endm 
# End of macro CWHEAD
3b96			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3b96					; get value off TOS and display it 
3b96			        ; TODO BUG adds extra spaces 
3b96			        ; TODO BUG handle numerics? 
3b96					if DEBUG_FORTH_WORDS_KEY 
3b96						DMARK "DTC" 
3b96 f5				push af  
3b97 3a ab 3b			ld a, (.dmark)  
3b9a 32 6b ee			ld (debug_mark),a  
3b9d 3a ac 3b			ld a, (.dmark+1)  
3ba0 32 6c ee			ld (debug_mark+1),a  
3ba3 3a ad 3b			ld a, (.dmark+2)  
3ba6 32 6d ee			ld (debug_mark+2),a  
3ba9 18 03			jr .pastdmark  
3bab ..			.dmark: db "DTC"  
3bae f1			.pastdmark: pop af  
3baf			endm  
# End of macro DMARK
3baf						CALLMONITOR 
3baf cd 6f ee			call debug_vector  
3bb2				endm  
# End of macro CALLMONITOR
3bb2					endif 
3bb2 3e 01			ld a, 1 
3bb4 32 3d ea			ld (cli_mvdot), a 
3bb7 c3 e6 3b			jp .dotgo 
3bba				NEXTW 
3bba c3 34 1f			jp macro_next 
3bbd				endm 
# End of macro NEXTW
3bbd			 
3bbd			.DOT: 
3bbd				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3bbd 1c				db WORD_SYS_CORE+8             
3bbe 99 3d			dw .CLS            
3bc0 02				db 1 + 1 
3bc1 .. 00			db ".",0              
3bc3				endm 
# End of macro CWHEAD
3bc3			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3bc3					; get value off TOS and display it 
3bc3			 
3bc3					if DEBUG_FORTH_WORDS_KEY 
3bc3						DMARK "DOT" 
3bc3 f5				push af  
3bc4 3a d8 3b			ld a, (.dmark)  
3bc7 32 6b ee			ld (debug_mark),a  
3bca 3a d9 3b			ld a, (.dmark+1)  
3bcd 32 6c ee			ld (debug_mark+1),a  
3bd0 3a da 3b			ld a, (.dmark+2)  
3bd3 32 6d ee			ld (debug_mark+2),a  
3bd6 18 03			jr .pastdmark  
3bd8 ..			.dmark: db "DOT"  
3bdb f1			.pastdmark: pop af  
3bdc			endm  
# End of macro DMARK
3bdc						CALLMONITOR 
3bdc cd 6f ee			call debug_vector  
3bdf				endm  
# End of macro CALLMONITOR
3bdf					endif 
3bdf 3e 00			ld a, 0 
3be1 32 3d ea			ld (cli_mvdot), a 
3be4 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3be6				 
3be6			 
3be6			.dotgo: 
3be6			 
3be6			; move up type to on stack for parserv5 
3be6					FORTH_DSP 
3be6 cd 44 1d			call macro_forth_dsp 
3be9				endm 
# End of macro FORTH_DSP
3be9				;FORTH_DSP_VALUE  
3be9			 
3be9			if DEBUG_FORTH_DOT 
3be9				DMARK "DOT" 
3be9 f5				push af  
3bea 3a fe 3b			ld a, (.dmark)  
3bed 32 6b ee			ld (debug_mark),a  
3bf0 3a ff 3b			ld a, (.dmark+1)  
3bf3 32 6c ee			ld (debug_mark+1),a  
3bf6 3a 00 3c			ld a, (.dmark+2)  
3bf9 32 6d ee			ld (debug_mark+2),a  
3bfc 18 03			jr .pastdmark  
3bfe ..			.dmark: db "DOT"  
3c01 f1			.pastdmark: pop af  
3c02			endm  
# End of macro DMARK
3c02				CALLMONITOR 
3c02 cd 6f ee			call debug_vector  
3c05				endm  
# End of macro CALLMONITOR
3c05			endif	 
3c05			;		.print: 
3c05			 
3c05 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c06 23				inc hl   ; position to the actual value 
3c07 fe 01			cp DS_TYPE_STR 
3c09 20 06			jr nz, .dotnum1  
3c0b			 
3c0b			; display string 
3c0b				FORTH_DSP_VALUE  
3c0b cd 67 1d			call macro_forth_dsp_value 
3c0e				endm 
# End of macro FORTH_DSP_VALUE
3c0e eb				ex de,hl 
3c0f 18 49			jr .dotwrite 
3c11			 
3c11			.dotnum1: 
3c11 fe 02			cp DS_TYPE_INUM 
3c13 20 44			jr nz, .dotflot 
3c15			 
3c15			 
3c15			; display number 
3c15			 
3c15			;	push hl 
3c15			;	call clear_display 
3c15			;	pop hl 
3c15			 
3c15 5e				ld e, (hl) 
3c16 23				inc hl 
3c17 56				ld d, (hl) 
3c18 21 c1 e2			ld hl, scratch 
3c1b			if DEBUG_FORTH_DOT 
3c1b				DMARK "DT1" 
3c1b f5				push af  
3c1c 3a 30 3c			ld a, (.dmark)  
3c1f 32 6b ee			ld (debug_mark),a  
3c22 3a 31 3c			ld a, (.dmark+1)  
3c25 32 6c ee			ld (debug_mark+1),a  
3c28 3a 32 3c			ld a, (.dmark+2)  
3c2b 32 6d ee			ld (debug_mark+2),a  
3c2e 18 03			jr .pastdmark  
3c30 ..			.dmark: db "DT1"  
3c33 f1			.pastdmark: pop af  
3c34			endm  
# End of macro DMARK
3c34				CALLMONITOR 
3c34 cd 6f ee			call debug_vector  
3c37				endm  
# End of macro CALLMONITOR
3c37			endif	 
3c37			 
3c37 cd 07 11			call uitoa_16 
3c3a eb				ex de,hl 
3c3b			 
3c3b			if DEBUG_FORTH_DOT 
3c3b				DMARK "DT2" 
3c3b f5				push af  
3c3c 3a 50 3c			ld a, (.dmark)  
3c3f 32 6b ee			ld (debug_mark),a  
3c42 3a 51 3c			ld a, (.dmark+1)  
3c45 32 6c ee			ld (debug_mark+1),a  
3c48 3a 52 3c			ld a, (.dmark+2)  
3c4b 32 6d ee			ld (debug_mark+2),a  
3c4e 18 03			jr .pastdmark  
3c50 ..			.dmark: db "DT2"  
3c53 f1			.pastdmark: pop af  
3c54			endm  
# End of macro DMARK
3c54				CALLMONITOR 
3c54 cd 6f ee			call debug_vector  
3c57				endm  
# End of macro CALLMONITOR
3c57			endif	 
3c57			 
3c57			;	ld de, os_word_scratch 
3c57 18 01			jr .dotwrite 
3c59			 
3c59 00			.dotflot:   nop 
3c5a			; TODO print floating point number 
3c5a			 
3c5a			.dotwrite:		 
3c5a			 
3c5a					; if c is set then set all '-' to spaces 
3c5a					; need to also take into account .>  
3c5a			 
3c5a 3e 01				ld a, 1 
3c5c b9					cp c 
3c5d 20 67				jr nz, .nodashswap 
3c5f			 
3c5f					; DE has the string to write, working with HL 
3c5f			 
3c5f 06 ff				ld b, 255 
3c61 d5					push de 
3c62 e1					pop hl 
3c63			 
3c63			if DEBUG_FORTH_DOT 
3c63				DMARK "DT-" 
3c63 f5				push af  
3c64 3a 78 3c			ld a, (.dmark)  
3c67 32 6b ee			ld (debug_mark),a  
3c6a 3a 79 3c			ld a, (.dmark+1)  
3c6d 32 6c ee			ld (debug_mark+1),a  
3c70 3a 7a 3c			ld a, (.dmark+2)  
3c73 32 6d ee			ld (debug_mark+2),a  
3c76 18 03			jr .pastdmark  
3c78 ..			.dmark: db "DT-"  
3c7b f1			.pastdmark: pop af  
3c7c			endm  
# End of macro DMARK
3c7c				CALLMONITOR 
3c7c cd 6f ee			call debug_vector  
3c7f				endm  
# End of macro CALLMONITOR
3c7f			endif	 
3c7f 7e			.dashscan:	ld a, (hl) 
3c80 fe 00				cp 0 
3c82 28 42				jr z, .nodashswap 
3c84 fe 2d				cp '-' 
3c86 20 03				jr nz, .dashskip 
3c88 3e 20				ld a, ' ' 
3c8a 77					ld (hl), a 
3c8b 23			.dashskip:	inc hl 
3c8c			if DEBUG_FORTH_DOT 
3c8c				DMARK "D-2" 
3c8c f5				push af  
3c8d 3a a1 3c			ld a, (.dmark)  
3c90 32 6b ee			ld (debug_mark),a  
3c93 3a a2 3c			ld a, (.dmark+1)  
3c96 32 6c ee			ld (debug_mark+1),a  
3c99 3a a3 3c			ld a, (.dmark+2)  
3c9c 32 6d ee			ld (debug_mark+2),a  
3c9f 18 03			jr .pastdmark  
3ca1 ..			.dmark: db "D-2"  
3ca4 f1			.pastdmark: pop af  
3ca5			endm  
# End of macro DMARK
3ca5				CALLMONITOR 
3ca5 cd 6f ee			call debug_vector  
3ca8				endm  
# End of macro CALLMONITOR
3ca8			endif	 
3ca8 10 d5				djnz .dashscan 
3caa			 
3caa			if DEBUG_FORTH_DOT 
3caa				DMARK "D-1" 
3caa f5				push af  
3cab 3a bf 3c			ld a, (.dmark)  
3cae 32 6b ee			ld (debug_mark),a  
3cb1 3a c0 3c			ld a, (.dmark+1)  
3cb4 32 6c ee			ld (debug_mark+1),a  
3cb7 3a c1 3c			ld a, (.dmark+2)  
3cba 32 6d ee			ld (debug_mark+2),a  
3cbd 18 03			jr .pastdmark  
3cbf ..			.dmark: db "D-1"  
3cc2 f1			.pastdmark: pop af  
3cc3			endm  
# End of macro DMARK
3cc3				CALLMONITOR 
3cc3 cd 6f ee			call debug_vector  
3cc6				endm  
# End of macro CALLMONITOR
3cc6			endif	 
3cc6			 
3cc6			.nodashswap: 
3cc6			 
3cc6			if DEBUG_FORTH_DOT 
3cc6				DMARK "D-o" 
3cc6 f5				push af  
3cc7 3a db 3c			ld a, (.dmark)  
3cca 32 6b ee			ld (debug_mark),a  
3ccd 3a dc 3c			ld a, (.dmark+1)  
3cd0 32 6c ee			ld (debug_mark+1),a  
3cd3 3a dd 3c			ld a, (.dmark+2)  
3cd6 32 6d ee			ld (debug_mark+2),a  
3cd9 18 03			jr .pastdmark  
3cdb ..			.dmark: db "D-o"  
3cde f1			.pastdmark: pop af  
3cdf			endm  
# End of macro DMARK
3cdf				CALLMONITOR 
3cdf cd 6f ee			call debug_vector  
3ce2				endm  
# End of macro CALLMONITOR
3ce2			endif	 
3ce2			 
3ce2 d5					push de   ; save string start in case we need to advance print 
3ce3			 
3ce3 3a 5e ea				ld a, (f_cursor_ptr) 
3ce6 cd d8 0b				call str_at_display 
3ce9 3a 3c ea				ld a,(cli_autodisplay) 
3cec fe 00				cp 0 
3cee 28 03				jr z, .noupdate 
3cf0 cd e8 0b						call update_display 
3cf3					.noupdate: 
3cf3			 
3cf3			 
3cf3					; see if we need to advance the print position 
3cf3			 
3cf3 e1					pop hl   ; get back string 
3cf4			;		ex de,hl 
3cf4			 
3cf4 3a 3d ea				ld a, (cli_mvdot) 
3cf7			if DEBUG_FORTH_DOT 
3cf7			;		ld e,a 
3cf7				DMARK "D>1" 
3cf7 f5				push af  
3cf8 3a 0c 3d			ld a, (.dmark)  
3cfb 32 6b ee			ld (debug_mark),a  
3cfe 3a 0d 3d			ld a, (.dmark+1)  
3d01 32 6c ee			ld (debug_mark+1),a  
3d04 3a 0e 3d			ld a, (.dmark+2)  
3d07 32 6d ee			ld (debug_mark+2),a  
3d0a 18 03			jr .pastdmark  
3d0c ..			.dmark: db "D>1"  
3d0f f1			.pastdmark: pop af  
3d10			endm  
# End of macro DMARK
3d10				CALLMONITOR 
3d10 cd 6f ee			call debug_vector  
3d13				endm  
# End of macro CALLMONITOR
3d13			endif	 
3d13 fe 00				cp 0 
3d15 28 44				jr z, .noadv 
3d17					; yes, lets advance the print position 
3d17 3e 00				ld a, 0 
3d19 cd 63 11				call strlent 
3d1c			if DEBUG_FORTH_DOT 
3d1c				DMARK "D-?" 
3d1c f5				push af  
3d1d 3a 31 3d			ld a, (.dmark)  
3d20 32 6b ee			ld (debug_mark),a  
3d23 3a 32 3d			ld a, (.dmark+1)  
3d26 32 6c ee			ld (debug_mark+1),a  
3d29 3a 33 3d			ld a, (.dmark+2)  
3d2c 32 6d ee			ld (debug_mark+2),a  
3d2f 18 03			jr .pastdmark  
3d31 ..			.dmark: db "D-?"  
3d34 f1			.pastdmark: pop af  
3d35			endm  
# End of macro DMARK
3d35				CALLMONITOR 
3d35 cd 6f ee			call debug_vector  
3d38				endm  
# End of macro CALLMONITOR
3d38			endif	 
3d38 3a 5e ea				ld a, (f_cursor_ptr) 
3d3b 85					add a,l 
3d3c					;call addatohl 
3d3c					;ld a, l 
3d3c 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3d3f			 
3d3f			if DEBUG_FORTH_DOT 
3d3f				DMARK "D->" 
3d3f f5				push af  
3d40 3a 54 3d			ld a, (.dmark)  
3d43 32 6b ee			ld (debug_mark),a  
3d46 3a 55 3d			ld a, (.dmark+1)  
3d49 32 6c ee			ld (debug_mark+1),a  
3d4c 3a 56 3d			ld a, (.dmark+2)  
3d4f 32 6d ee			ld (debug_mark+2),a  
3d52 18 03			jr .pastdmark  
3d54 ..			.dmark: db "D->"  
3d57 f1			.pastdmark: pop af  
3d58			endm  
# End of macro DMARK
3d58				CALLMONITOR 
3d58 cd 6f ee			call debug_vector  
3d5b				endm  
# End of macro CALLMONITOR
3d5b			endif	 
3d5b			 
3d5b			.noadv:	 
3d5b			 
3d5b					if DEBUG_FORTH_DOT_WAIT 
3d5b							call next_page_prompt 
3d5b					endif	 
3d5b			; TODO this pop off the stack causes a crash. i dont know why 
3d5b			 
3d5b			 
3d5b			if DEBUG_FORTH_DOT 
3d5b				DMARK "DTh" 
3d5b f5				push af  
3d5c 3a 70 3d			ld a, (.dmark)  
3d5f 32 6b ee			ld (debug_mark),a  
3d62 3a 71 3d			ld a, (.dmark+1)  
3d65 32 6c ee			ld (debug_mark+1),a  
3d68 3a 72 3d			ld a, (.dmark+2)  
3d6b 32 6d ee			ld (debug_mark+2),a  
3d6e 18 03			jr .pastdmark  
3d70 ..			.dmark: db "DTh"  
3d73 f1			.pastdmark: pop af  
3d74			endm  
# End of macro DMARK
3d74				CALLMONITOR 
3d74 cd 6f ee			call debug_vector  
3d77				endm  
# End of macro CALLMONITOR
3d77			endif	 
3d77			 
3d77					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d77 cd 36 1e			call macro_forth_dsp_pop 
3d7a				endm 
# End of macro FORTH_DSP_POP
3d7a			 
3d7a			if DEBUG_FORTH_DOT 
3d7a				DMARK "DTi" 
3d7a f5				push af  
3d7b 3a 8f 3d			ld a, (.dmark)  
3d7e 32 6b ee			ld (debug_mark),a  
3d81 3a 90 3d			ld a, (.dmark+1)  
3d84 32 6c ee			ld (debug_mark+1),a  
3d87 3a 91 3d			ld a, (.dmark+2)  
3d8a 32 6d ee			ld (debug_mark+2),a  
3d8d 18 03			jr .pastdmark  
3d8f ..			.dmark: db "DTi"  
3d92 f1			.pastdmark: pop af  
3d93			endm  
# End of macro DMARK
3d93				CALLMONITOR 
3d93 cd 6f ee			call debug_vector  
3d96				endm  
# End of macro CALLMONITOR
3d96			endif	 
3d96			 
3d96			 
3d96					NEXTW 
3d96 c3 34 1f			jp macro_next 
3d99				endm 
# End of macro NEXTW
3d99			 
3d99			.CLS: 
3d99				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3d99 35				db WORD_SYS_CORE+33             
3d9a c6 3d			dw .DRAW            
3d9c 04				db 3 + 1 
3d9d .. 00			db "CLS",0              
3da1				endm 
# End of macro CWHEAD
3da1			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3da1					if DEBUG_FORTH_WORDS_KEY 
3da1						DMARK "CLS" 
3da1 f5				push af  
3da2 3a b6 3d			ld a, (.dmark)  
3da5 32 6b ee			ld (debug_mark),a  
3da8 3a b7 3d			ld a, (.dmark+1)  
3dab 32 6c ee			ld (debug_mark+1),a  
3dae 3a b8 3d			ld a, (.dmark+2)  
3db1 32 6d ee			ld (debug_mark+2),a  
3db4 18 03			jr .pastdmark  
3db6 ..			.dmark: db "CLS"  
3db9 f1			.pastdmark: pop af  
3dba			endm  
# End of macro DMARK
3dba						CALLMONITOR 
3dba cd 6f ee			call debug_vector  
3dbd				endm  
# End of macro CALLMONITOR
3dbd					endif 
3dbd cd c5 0b				call clear_display 
3dc0 c3 d4 3e				jp .home		; and home cursor 
3dc3					NEXTW 
3dc3 c3 34 1f			jp macro_next 
3dc6				endm 
# End of macro NEXTW
3dc6			 
3dc6			.DRAW: 
3dc6				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3dc6 36				db WORD_SYS_CORE+34             
3dc7 f1 3d			dw .DUMP            
3dc9 05				db 4 + 1 
3dca .. 00			db "DRAW",0              
3dcf				endm 
# End of macro CWHEAD
3dcf			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3dcf					if DEBUG_FORTH_WORDS_KEY 
3dcf						DMARK "DRW" 
3dcf f5				push af  
3dd0 3a e4 3d			ld a, (.dmark)  
3dd3 32 6b ee			ld (debug_mark),a  
3dd6 3a e5 3d			ld a, (.dmark+1)  
3dd9 32 6c ee			ld (debug_mark+1),a  
3ddc 3a e6 3d			ld a, (.dmark+2)  
3ddf 32 6d ee			ld (debug_mark+2),a  
3de2 18 03			jr .pastdmark  
3de4 ..			.dmark: db "DRW"  
3de7 f1			.pastdmark: pop af  
3de8			endm  
# End of macro DMARK
3de8						CALLMONITOR 
3de8 cd 6f ee			call debug_vector  
3deb				endm  
# End of macro CALLMONITOR
3deb					endif 
3deb cd e8 0b				call update_display 
3dee					NEXTW 
3dee c3 34 1f			jp macro_next 
3df1				endm 
# End of macro NEXTW
3df1			 
3df1			.DUMP: 
3df1				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3df1 37				db WORD_SYS_CORE+35             
3df2 29 3e			dw .CDUMP            
3df4 05				db 4 + 1 
3df5 .. 00			db "DUMP",0              
3dfa				endm 
# End of macro CWHEAD
3dfa			; | DUMP ( x -- ) With address x display dump   | DONE 
3dfa			; TODO pop address to use off of the stack 
3dfa					if DEBUG_FORTH_WORDS_KEY 
3dfa						DMARK "DUM" 
3dfa f5				push af  
3dfb 3a 0f 3e			ld a, (.dmark)  
3dfe 32 6b ee			ld (debug_mark),a  
3e01 3a 10 3e			ld a, (.dmark+1)  
3e04 32 6c ee			ld (debug_mark+1),a  
3e07 3a 11 3e			ld a, (.dmark+2)  
3e0a 32 6d ee			ld (debug_mark+2),a  
3e0d 18 03			jr .pastdmark  
3e0f ..			.dmark: db "DUM"  
3e12 f1			.pastdmark: pop af  
3e13			endm  
# End of macro DMARK
3e13						CALLMONITOR 
3e13 cd 6f ee			call debug_vector  
3e16				endm  
# End of macro CALLMONITOR
3e16					endif 
3e16 cd c5 0b				call clear_display 
3e19			 
3e19					; get address 
3e19			 
3e19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e19 cd 7e 1d			call macro_dsp_valuehl 
3e1c				endm 
# End of macro FORTH_DSP_VALUEHL
3e1c				 
3e1c					; save it for cdump 
3e1c			 
3e1c 22 e4 e5				ld (os_cur_ptr),hl 
3e1f			 
3e1f					; destroy value TOS 
3e1f			 
3e1f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e1f cd 36 1e			call macro_forth_dsp_pop 
3e22				endm 
# End of macro FORTH_DSP_POP
3e22			 
3e22 cd f9 19				call dumpcont	; skip old style of param parsing	 
3e25 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3e26					NEXTW 
3e26 c3 34 1f			jp macro_next 
3e29				endm 
# End of macro NEXTW
3e29			.CDUMP: 
3e29				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3e29 38				db WORD_SYS_CORE+36             
3e2a 59 3e			dw .DAT            
3e2c 06				db 5 + 1 
3e2d .. 00			db "CDUMP",0              
3e33				endm 
# End of macro CWHEAD
3e33			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3e33					if DEBUG_FORTH_WORDS_KEY 
3e33						DMARK "CDP" 
3e33 f5				push af  
3e34 3a 48 3e			ld a, (.dmark)  
3e37 32 6b ee			ld (debug_mark),a  
3e3a 3a 49 3e			ld a, (.dmark+1)  
3e3d 32 6c ee			ld (debug_mark+1),a  
3e40 3a 4a 3e			ld a, (.dmark+2)  
3e43 32 6d ee			ld (debug_mark+2),a  
3e46 18 03			jr .pastdmark  
3e48 ..			.dmark: db "CDP"  
3e4b f1			.pastdmark: pop af  
3e4c			endm  
# End of macro DMARK
3e4c						CALLMONITOR 
3e4c cd 6f ee			call debug_vector  
3e4f				endm  
# End of macro CALLMONITOR
3e4f					endif 
3e4f cd c5 0b				call clear_display 
3e52 cd f9 19				call dumpcont	 
3e55 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3e56					NEXTW 
3e56 c3 34 1f			jp macro_next 
3e59				endm 
# End of macro NEXTW
3e59			 
3e59			 
3e59			 
3e59			 
3e59			.DAT: 
3e59				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3e59 3d				db WORD_SYS_CORE+41             
3e5a af 3e			dw .HOME            
3e5c 03				db 2 + 1 
3e5d .. 00			db "AT",0              
3e60				endm 
# End of macro CWHEAD
3e60			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3e60					if DEBUG_FORTH_WORDS_KEY 
3e60						DMARK "AT." 
3e60 f5				push af  
3e61 3a 75 3e			ld a, (.dmark)  
3e64 32 6b ee			ld (debug_mark),a  
3e67 3a 76 3e			ld a, (.dmark+1)  
3e6a 32 6c ee			ld (debug_mark+1),a  
3e6d 3a 77 3e			ld a, (.dmark+2)  
3e70 32 6d ee			ld (debug_mark+2),a  
3e73 18 03			jr .pastdmark  
3e75 ..			.dmark: db "AT."  
3e78 f1			.pastdmark: pop af  
3e79			endm  
# End of macro DMARK
3e79						CALLMONITOR 
3e79 cd 6f ee			call debug_vector  
3e7c				endm  
# End of macro CALLMONITOR
3e7c					endif 
3e7c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e7c cd 7e 1d			call macro_dsp_valuehl 
3e7f				endm 
# End of macro FORTH_DSP_VALUEHL
3e7f			 
3e7f			 
3e7f					; TODO save cursor row 
3e7f 7d					ld a,l 
3e80 fe 02				cp 2 
3e82 20 04				jr nz, .crow3 
3e84 3e 28				ld a, display_row_2 
3e86 18 12				jr .ccol1 
3e88 fe 03		.crow3:		cp 3 
3e8a 20 04				jr nz, .crow4 
3e8c 3e 50				ld a, display_row_3 
3e8e 18 0a				jr .ccol1 
3e90 fe 04		.crow4:		cp 4 
3e92 20 04				jr nz, .crow1 
3e94 3e 78				ld a, display_row_4 
3e96 18 02				jr .ccol1 
3e98 3e 00		.crow1:		ld a,display_row_1 
3e9a f5			.ccol1:		push af			; got row offset 
3e9b 6f					ld l,a 
3e9c 26 00				ld h,0 
3e9e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e9e cd 36 1e			call macro_forth_dsp_pop 
3ea1				endm 
# End of macro FORTH_DSP_POP
3ea1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ea1 cd 7e 1d			call macro_dsp_valuehl 
3ea4				endm 
# End of macro FORTH_DSP_VALUEHL
3ea4					; TODO save cursor col 
3ea4 f1					pop af 
3ea5 85					add l		; add col offset 
3ea6 32 5e ea				ld (f_cursor_ptr), a 
3ea9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ea9 cd 36 1e			call macro_forth_dsp_pop 
3eac				endm 
# End of macro FORTH_DSP_POP
3eac			 
3eac					; calculate  
3eac			 
3eac					NEXTW 
3eac c3 34 1f			jp macro_next 
3eaf				endm 
# End of macro NEXTW
3eaf			 
3eaf			 
3eaf			.HOME: 
3eaf				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
3eaf 41				db WORD_SYS_CORE+45             
3eb0 dc 3e			dw .CR            
3eb2 05				db 4 + 1 
3eb3 .. 00			db "HOME",0              
3eb8				endm 
# End of macro CWHEAD
3eb8			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3eb8					if DEBUG_FORTH_WORDS_KEY 
3eb8						DMARK "HOM" 
3eb8 f5				push af  
3eb9 3a cd 3e			ld a, (.dmark)  
3ebc 32 6b ee			ld (debug_mark),a  
3ebf 3a ce 3e			ld a, (.dmark+1)  
3ec2 32 6c ee			ld (debug_mark+1),a  
3ec5 3a cf 3e			ld a, (.dmark+2)  
3ec8 32 6d ee			ld (debug_mark+2),a  
3ecb 18 03			jr .pastdmark  
3ecd ..			.dmark: db "HOM"  
3ed0 f1			.pastdmark: pop af  
3ed1			endm  
# End of macro DMARK
3ed1						CALLMONITOR 
3ed1 cd 6f ee			call debug_vector  
3ed4				endm  
# End of macro CALLMONITOR
3ed4					endif 
3ed4 3e 00		.home:		ld a, 0		; and home cursor 
3ed6 32 5e ea				ld (f_cursor_ptr), a 
3ed9					NEXTW 
3ed9 c3 34 1f			jp macro_next 
3edc				endm 
# End of macro NEXTW
3edc			 
3edc			 
3edc			.CR: 
3edc				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
3edc 46				db WORD_SYS_CORE+50             
3edd 17 3f			dw .SPACE            
3edf 03				db 2 + 1 
3ee0 .. 00			db "CR",0              
3ee3				endm 
# End of macro CWHEAD
3ee3			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
3ee3					if DEBUG_FORTH_WORDS_KEY 
3ee3						DMARK "CR." 
3ee3 f5				push af  
3ee4 3a f8 3e			ld a, (.dmark)  
3ee7 32 6b ee			ld (debug_mark),a  
3eea 3a f9 3e			ld a, (.dmark+1)  
3eed 32 6c ee			ld (debug_mark+1),a  
3ef0 3a fa 3e			ld a, (.dmark+2)  
3ef3 32 6d ee			ld (debug_mark+2),a  
3ef6 18 03			jr .pastdmark  
3ef8 ..			.dmark: db "CR."  
3efb f1			.pastdmark: pop af  
3efc			endm  
# End of macro DMARK
3efc						CALLMONITOR 
3efc cd 6f ee			call debug_vector  
3eff				endm  
# End of macro CALLMONITOR
3eff					endif 
3eff 3e 0d				ld a, 13 
3f01 32 c1 e2				ld (scratch),a 
3f04 3e 0a				ld a, 10 
3f06 32 c2 e2				ld (scratch+1),a 
3f09 3e 00				ld a, 0 
3f0b 32 c3 e2				ld (scratch+2),a 
3f0e 21 c1 e2				ld hl, scratch 
3f11 cd e7 1b				call forth_push_str 
3f14					 
3f14				       NEXTW 
3f14 c3 34 1f			jp macro_next 
3f17				endm 
# End of macro NEXTW
3f17			.SPACE: 
3f17				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f17 46				db WORD_SYS_CORE+50             
3f18 4d 3f			dw .SPACES            
3f1a 03				db 2 + 1 
3f1b .. 00			db "BL",0              
3f1e				endm 
# End of macro CWHEAD
3f1e			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f1e					if DEBUG_FORTH_WORDS_KEY 
3f1e						DMARK "BL." 
3f1e f5				push af  
3f1f 3a 33 3f			ld a, (.dmark)  
3f22 32 6b ee			ld (debug_mark),a  
3f25 3a 34 3f			ld a, (.dmark+1)  
3f28 32 6c ee			ld (debug_mark+1),a  
3f2b 3a 35 3f			ld a, (.dmark+2)  
3f2e 32 6d ee			ld (debug_mark+2),a  
3f31 18 03			jr .pastdmark  
3f33 ..			.dmark: db "BL."  
3f36 f1			.pastdmark: pop af  
3f37			endm  
# End of macro DMARK
3f37						CALLMONITOR 
3f37 cd 6f ee			call debug_vector  
3f3a				endm  
# End of macro CALLMONITOR
3f3a					endif 
3f3a 3e 20				ld a, " " 
3f3c 32 c1 e2				ld (scratch),a 
3f3f 3e 00				ld a, 0 
3f41 32 c2 e2				ld (scratch+1),a 
3f44 21 c1 e2				ld hl, scratch 
3f47 cd e7 1b				call forth_push_str 
3f4a					 
3f4a				       NEXTW 
3f4a c3 34 1f			jp macro_next 
3f4d				endm 
# End of macro NEXTW
3f4d			 
3f4d			;.blstr: db " ", 0 
3f4d			 
3f4d			.SPACES: 
3f4d				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f4d 47				db WORD_SYS_CORE+51             
3f4e e8 3f			dw .SCROLL            
3f50 07				db 6 + 1 
3f51 .. 00			db "SPACES",0              
3f58				endm 
# End of macro CWHEAD
3f58			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f58					if DEBUG_FORTH_WORDS_KEY 
3f58						DMARK "SPS" 
3f58 f5				push af  
3f59 3a 6d 3f			ld a, (.dmark)  
3f5c 32 6b ee			ld (debug_mark),a  
3f5f 3a 6e 3f			ld a, (.dmark+1)  
3f62 32 6c ee			ld (debug_mark+1),a  
3f65 3a 6f 3f			ld a, (.dmark+2)  
3f68 32 6d ee			ld (debug_mark+2),a  
3f6b 18 03			jr .pastdmark  
3f6d ..			.dmark: db "SPS"  
3f70 f1			.pastdmark: pop af  
3f71			endm  
# End of macro DMARK
3f71						CALLMONITOR 
3f71 cd 6f ee			call debug_vector  
3f74				endm  
# End of macro CALLMONITOR
3f74					endif 
3f74			 
3f74			 
3f74					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f74 cd 7e 1d			call macro_dsp_valuehl 
3f77				endm 
# End of macro FORTH_DSP_VALUEHL
3f77			 
3f77 e5					push hl    ; u 
3f78					if DEBUG_FORTH_WORDS 
3f78						DMARK "SPA" 
3f78 f5				push af  
3f79 3a 8d 3f			ld a, (.dmark)  
3f7c 32 6b ee			ld (debug_mark),a  
3f7f 3a 8e 3f			ld a, (.dmark+1)  
3f82 32 6c ee			ld (debug_mark+1),a  
3f85 3a 8f 3f			ld a, (.dmark+2)  
3f88 32 6d ee			ld (debug_mark+2),a  
3f8b 18 03			jr .pastdmark  
3f8d ..			.dmark: db "SPA"  
3f90 f1			.pastdmark: pop af  
3f91			endm  
# End of macro DMARK
3f91						CALLMONITOR 
3f91 cd 6f ee			call debug_vector  
3f94				endm  
# End of macro CALLMONITOR
3f94					endif 
3f94			 
3f94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f94 cd 36 1e			call macro_forth_dsp_pop 
3f97				endm 
# End of macro FORTH_DSP_POP
3f97 e1					pop hl 
3f98 0e 00				ld c, 0 
3f9a 45					ld b, l 
3f9b 21 c1 e2				ld hl, scratch  
3f9e			 
3f9e					if DEBUG_FORTH_WORDS 
3f9e						DMARK "SP2" 
3f9e f5				push af  
3f9f 3a b3 3f			ld a, (.dmark)  
3fa2 32 6b ee			ld (debug_mark),a  
3fa5 3a b4 3f			ld a, (.dmark+1)  
3fa8 32 6c ee			ld (debug_mark+1),a  
3fab 3a b5 3f			ld a, (.dmark+2)  
3fae 32 6d ee			ld (debug_mark+2),a  
3fb1 18 03			jr .pastdmark  
3fb3 ..			.dmark: db "SP2"  
3fb6 f1			.pastdmark: pop af  
3fb7			endm  
# End of macro DMARK
3fb7						CALLMONITOR 
3fb7 cd 6f ee			call debug_vector  
3fba				endm  
# End of macro CALLMONITOR
3fba					endif 
3fba 3e 20				ld a, ' ' 
3fbc			.spaces1:	 
3fbc 77					ld (hl),a 
3fbd 23					inc hl 
3fbe					 
3fbe 10 fc				djnz .spaces1 
3fc0 3e 00				ld a,0 
3fc2 77					ld (hl),a 
3fc3 21 c1 e2				ld hl, scratch 
3fc6					if DEBUG_FORTH_WORDS 
3fc6						DMARK "SP3" 
3fc6 f5				push af  
3fc7 3a db 3f			ld a, (.dmark)  
3fca 32 6b ee			ld (debug_mark),a  
3fcd 3a dc 3f			ld a, (.dmark+1)  
3fd0 32 6c ee			ld (debug_mark+1),a  
3fd3 3a dd 3f			ld a, (.dmark+2)  
3fd6 32 6d ee			ld (debug_mark+2),a  
3fd9 18 03			jr .pastdmark  
3fdb ..			.dmark: db "SP3"  
3fde f1			.pastdmark: pop af  
3fdf			endm  
# End of macro DMARK
3fdf						CALLMONITOR 
3fdf cd 6f ee			call debug_vector  
3fe2				endm  
# End of macro CALLMONITOR
3fe2					endif 
3fe2 cd e7 1b				call forth_push_str 
3fe5			 
3fe5				       NEXTW 
3fe5 c3 34 1f			jp macro_next 
3fe8				endm 
# End of macro NEXTW
3fe8			 
3fe8			 
3fe8			 
3fe8			.SCROLL: 
3fe8				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3fe8 53				db WORD_SYS_CORE+63             
3fe9 15 40			dw .SCROLLD            
3feb 07				db 6 + 1 
3fec .. 00			db "SCROLL",0              
3ff3				endm 
# End of macro CWHEAD
3ff3			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3ff3					if DEBUG_FORTH_WORDS_KEY 
3ff3						DMARK "SCR" 
3ff3 f5				push af  
3ff4 3a 08 40			ld a, (.dmark)  
3ff7 32 6b ee			ld (debug_mark),a  
3ffa 3a 09 40			ld a, (.dmark+1)  
3ffd 32 6c ee			ld (debug_mark+1),a  
4000 3a 0a 40			ld a, (.dmark+2)  
4003 32 6d ee			ld (debug_mark+2),a  
4006 18 03			jr .pastdmark  
4008 ..			.dmark: db "SCR"  
400b f1			.pastdmark: pop af  
400c			endm  
# End of macro DMARK
400c						CALLMONITOR 
400c cd 6f ee			call debug_vector  
400f				endm  
# End of macro CALLMONITOR
400f					endif 
400f			 
400f cd 87 0b			call scroll_up 
4012			;	call update_display 
4012			 
4012					NEXTW 
4012 c3 34 1f			jp macro_next 
4015				endm 
# End of macro NEXTW
4015			 
4015			 
4015			 
4015			;		; get dir 
4015			; 
4015			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4015			; 
4015			;		push hl 
4015			; 
4015			;		; destroy value TOS 
4015			; 
4015			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4015			; 
4015			;		; get count 
4015			; 
4015			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4015			; 
4015			;		push hl 
4015			; 
4015			;		; destroy value TOS 
4015			; 
4015			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4015			; 
4015			;		; one value on hl get other one back 
4015			; 
4015			;		pop bc    ; count 
4015			; 
4015			;		pop de   ; dir 
4015			; 
4015			; 
4015			;		ld b, c 
4015			; 
4015			;.scrolldir:     push bc 
4015			;		push de 
4015			; 
4015			;		ld a, 0 
4015			;		cp e 
4015			;		jr z, .scrollup  
4015			;		call scroll_down 
4015			;		jr .scrollnext 
4015			;.scrollup:	call scroll_up 
4015			; 
4015			;		 
4015			;.scrollnext: 
4015			;		pop de 
4015			;		pop bc 
4015			;		djnz .scrolldir 
4015			; 
4015			; 
4015			; 
4015			; 
4015			; 
4015			;		NEXTW 
4015			 
4015			.SCROLLD: 
4015				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4015 53				db WORD_SYS_CORE+63             
4016 43 40			dw .ATQ            
4018 08				db 7 + 1 
4019 .. 00			db "SCROLLD",0              
4021				endm 
# End of macro CWHEAD
4021			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4021					if DEBUG_FORTH_WORDS_KEY 
4021						DMARK "SCD" 
4021 f5				push af  
4022 3a 36 40			ld a, (.dmark)  
4025 32 6b ee			ld (debug_mark),a  
4028 3a 37 40			ld a, (.dmark+1)  
402b 32 6c ee			ld (debug_mark+1),a  
402e 3a 38 40			ld a, (.dmark+2)  
4031 32 6d ee			ld (debug_mark+2),a  
4034 18 03			jr .pastdmark  
4036 ..			.dmark: db "SCD"  
4039 f1			.pastdmark: pop af  
403a			endm  
# End of macro DMARK
403a						CALLMONITOR 
403a cd 6f ee			call debug_vector  
403d				endm  
# End of macro CALLMONITOR
403d					endif 
403d			 
403d cd ab 0b			call scroll_down 
4040			;	call update_display 
4040			 
4040					NEXTW 
4040 c3 34 1f			jp macro_next 
4043				endm 
# End of macro NEXTW
4043			 
4043			 
4043			.ATQ: 
4043				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4043 62				db WORD_SYS_CORE+78             
4044 a1 40			dw .AUTODSP            
4046 04				db 3 + 1 
4047 .. 00			db "AT@",0              
404b				endm 
# End of macro CWHEAD
404b			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
404b					if DEBUG_FORTH_WORDS_KEY 
404b						DMARK "ATA" 
404b f5				push af  
404c 3a 60 40			ld a, (.dmark)  
404f 32 6b ee			ld (debug_mark),a  
4052 3a 61 40			ld a, (.dmark+1)  
4055 32 6c ee			ld (debug_mark+1),a  
4058 3a 62 40			ld a, (.dmark+2)  
405b 32 6d ee			ld (debug_mark+2),a  
405e 18 03			jr .pastdmark  
4060 ..			.dmark: db "ATA"  
4063 f1			.pastdmark: pop af  
4064			endm  
# End of macro DMARK
4064						CALLMONITOR 
4064 cd 6f ee			call debug_vector  
4067				endm  
# End of macro CALLMONITOR
4067					endif 
4067			 
4067			 
4067					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4067 cd 7e 1d			call macro_dsp_valuehl 
406a				endm 
# End of macro FORTH_DSP_VALUEHL
406a			 
406a					; TODO save cursor row 
406a 7d					ld a,l 
406b fe 02				cp 2 
406d 20 04				jr nz, .crow3aq 
406f 3e 28				ld a, display_row_2 
4071 18 12				jr .ccol1aq 
4073 fe 03		.crow3aq:		cp 3 
4075 20 04				jr nz, .crow4aq 
4077 3e 50				ld a, display_row_3 
4079 18 0a				jr .ccol1aq 
407b fe 04		.crow4aq:		cp 4 
407d 20 04				jr nz, .crow1aq 
407f 3e 78				ld a, display_row_4 
4081 18 02				jr .ccol1aq 
4083 3e 00		.crow1aq:		ld a,display_row_1 
4085 f5			.ccol1aq:		push af			; got row offset 
4086 6f					ld l,a 
4087 26 00				ld h,0 
4089					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4089 cd 36 1e			call macro_forth_dsp_pop 
408c				endm 
# End of macro FORTH_DSP_POP
408c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
408c cd 7e 1d			call macro_dsp_valuehl 
408f				endm 
# End of macro FORTH_DSP_VALUEHL
408f					; TODO save cursor col 
408f f1					pop af 
4090 85					add l		; add col offset 
4091			 
4091					; add current frame buffer address 
4091 2a cc eb				ld hl, (display_fb_active) 
4094 cd f2 0d				call addatohl 
4097			 
4097			 
4097			 
4097			 
4097					; get char frame buffer location offset in hl 
4097			 
4097 7e					ld a,(hl) 
4098 26 00				ld h, 0 
409a 6f					ld l, a 
409b			 
409b cd 79 1b				call forth_push_numhl 
409e			 
409e			 
409e					NEXTW 
409e c3 34 1f			jp macro_next 
40a1				endm 
# End of macro NEXTW
40a1			 
40a1			.AUTODSP: 
40a1				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
40a1 63				db WORD_SYS_CORE+79             
40a2 b7 40			dw .MENU            
40a4 05				db 4 + 1 
40a5 .. 00			db "ADSP",0              
40aa				endm 
# End of macro CWHEAD
40aa			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
40aa			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
40aa			 
40aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40aa cd 7e 1d			call macro_dsp_valuehl 
40ad				endm 
# End of macro FORTH_DSP_VALUEHL
40ad			 
40ad			;		push hl 
40ad			 
40ad					; destroy value TOS 
40ad			 
40ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ad cd 36 1e			call macro_forth_dsp_pop 
40b0				endm 
# End of macro FORTH_DSP_POP
40b0			 
40b0			;		pop hl 
40b0			 
40b0 7d					ld a,l 
40b1 32 3c ea				ld (cli_autodisplay), a 
40b4				       NEXTW 
40b4 c3 34 1f			jp macro_next 
40b7				endm 
# End of macro NEXTW
40b7			 
40b7			.MENU: 
40b7				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
40b7 70				db WORD_SYS_CORE+92             
40b8 60 41			dw .ENDDISPLAY            
40ba 05				db 4 + 1 
40bb .. 00			db "MENU",0              
40c0				endm 
# End of macro CWHEAD
40c0			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
40c0			 
40c0			;		; get number of items on the stack 
40c0			; 
40c0				 
40c0					FORTH_DSP_VALUEHL 
40c0 cd 7e 1d			call macro_dsp_valuehl 
40c3				endm 
# End of macro FORTH_DSP_VALUEHL
40c3				 
40c3					if DEBUG_FORTH_WORDS_KEY 
40c3						DMARK "MNU" 
40c3 f5				push af  
40c4 3a d8 40			ld a, (.dmark)  
40c7 32 6b ee			ld (debug_mark),a  
40ca 3a d9 40			ld a, (.dmark+1)  
40cd 32 6c ee			ld (debug_mark+1),a  
40d0 3a da 40			ld a, (.dmark+2)  
40d3 32 6d ee			ld (debug_mark+2),a  
40d6 18 03			jr .pastdmark  
40d8 ..			.dmark: db "MNU"  
40db f1			.pastdmark: pop af  
40dc			endm  
# End of macro DMARK
40dc						CALLMONITOR 
40dc cd 6f ee			call debug_vector  
40df				endm  
# End of macro CALLMONITOR
40df					endif 
40df			 
40df 45					ld b, l	 
40e0 05					dec b 
40e1			 
40e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40e1 cd 36 1e			call macro_forth_dsp_pop 
40e4				endm 
# End of macro FORTH_DSP_POP
40e4			 
40e4			 
40e4					; go directly through the stack to pluck out the string pointers and build an array 
40e4			 
40e4			;		FORTH_DSP 
40e4			 
40e4					; hl contains top most stack item 
40e4				 
40e4 11 c1 e2				ld de, scratch 
40e7			 
40e7			.mbuild: 
40e7			 
40e7					FORTH_DSP_VALUEHL 
40e7 cd 7e 1d			call macro_dsp_valuehl 
40ea				endm 
# End of macro FORTH_DSP_VALUEHL
40ea			 
40ea					if DEBUG_FORTH_WORDS 
40ea						DMARK "MN3" 
40ea f5				push af  
40eb 3a ff 40			ld a, (.dmark)  
40ee 32 6b ee			ld (debug_mark),a  
40f1 3a 00 41			ld a, (.dmark+1)  
40f4 32 6c ee			ld (debug_mark+1),a  
40f7 3a 01 41			ld a, (.dmark+2)  
40fa 32 6d ee			ld (debug_mark+2),a  
40fd 18 03			jr .pastdmark  
40ff ..			.dmark: db "MN3"  
4102 f1			.pastdmark: pop af  
4103			endm  
# End of macro DMARK
4103						CALLMONITOR 
4103 cd 6f ee			call debug_vector  
4106				endm  
# End of macro CALLMONITOR
4106					endif 
4106 eb					ex de, hl 
4107 73					ld (hl), e 
4108 23					inc hl 
4109 72					ld (hl), d 
410a 23					inc hl 
410b eb					ex de, hl 
410c			 
410c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
410c cd 36 1e			call macro_forth_dsp_pop 
410f				endm 
# End of macro FORTH_DSP_POP
410f			 
410f 10 d6				djnz .mbuild 
4111			 
4111					; done add term 
4111			 
4111 eb					ex de, hl 
4112 36 00				ld (hl), 0 
4114 23					inc hl 
4115 36 00				ld (hl), 0 
4117			 
4117				 
4117					 
4117 21 c1 e2				ld hl, scratch 
411a			 
411a					if DEBUG_FORTH_WORDS 
411a						DMARK "MNx" 
411a f5				push af  
411b 3a 2f 41			ld a, (.dmark)  
411e 32 6b ee			ld (debug_mark),a  
4121 3a 30 41			ld a, (.dmark+1)  
4124 32 6c ee			ld (debug_mark+1),a  
4127 3a 31 41			ld a, (.dmark+2)  
412a 32 6d ee			ld (debug_mark+2),a  
412d 18 03			jr .pastdmark  
412f ..			.dmark: db "MNx"  
4132 f1			.pastdmark: pop af  
4133			endm  
# End of macro DMARK
4133						CALLMONITOR 
4133 cd 6f ee			call debug_vector  
4136				endm  
# End of macro CALLMONITOR
4136					endif 
4136			 
4136			 
4136			 
4136 3e 00				ld a, 0 
4138 cd f6 0b				call menu 
413b			 
413b			 
413b 6f					ld l, a 
413c 26 00				ld h, 0 
413e			 
413e					if DEBUG_FORTH_WORDS 
413e						DMARK "MNr" 
413e f5				push af  
413f 3a 53 41			ld a, (.dmark)  
4142 32 6b ee			ld (debug_mark),a  
4145 3a 54 41			ld a, (.dmark+1)  
4148 32 6c ee			ld (debug_mark+1),a  
414b 3a 55 41			ld a, (.dmark+2)  
414e 32 6d ee			ld (debug_mark+2),a  
4151 18 03			jr .pastdmark  
4153 ..			.dmark: db "MNr"  
4156 f1			.pastdmark: pop af  
4157			endm  
# End of macro DMARK
4157						CALLMONITOR 
4157 cd 6f ee			call debug_vector  
415a				endm  
# End of macro CALLMONITOR
415a					endif 
415a			 
415a cd 79 1b				call forth_push_numhl 
415d			 
415d			 
415d			 
415d			 
415d				       NEXTW 
415d c3 34 1f			jp macro_next 
4160				endm 
# End of macro NEXTW
4160			 
4160			 
4160			.ENDDISPLAY: 
4160			 
4160			; eof 
# End of file forth_words_display.asm
4160			include "forth_words_str.asm" 
4160			 
4160			; | ## String Words 
4160			 
4160			.PTR:   
4160			 
4160				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4160 48				db WORD_SYS_CORE+52             
4161 8d 41			dw .STYPE            
4163 04				db 3 + 1 
4164 .. 00			db "PTR",0              
4168				endm 
# End of macro CWHEAD
4168			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4168			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4168			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4168			 
4168					if DEBUG_FORTH_WORDS_KEY 
4168						DMARK "PTR" 
4168 f5				push af  
4169 3a 7d 41			ld a, (.dmark)  
416c 32 6b ee			ld (debug_mark),a  
416f 3a 7e 41			ld a, (.dmark+1)  
4172 32 6c ee			ld (debug_mark+1),a  
4175 3a 7f 41			ld a, (.dmark+2)  
4178 32 6d ee			ld (debug_mark+2),a  
417b 18 03			jr .pastdmark  
417d ..			.dmark: db "PTR"  
4180 f1			.pastdmark: pop af  
4181			endm  
# End of macro DMARK
4181						CALLMONITOR 
4181 cd 6f ee			call debug_vector  
4184				endm  
# End of macro CALLMONITOR
4184					endif 
4184					FORTH_DSP_VALUEHL 
4184 cd 7e 1d			call macro_dsp_valuehl 
4187				endm 
# End of macro FORTH_DSP_VALUEHL
4187 cd 79 1b				call forth_push_numhl 
418a			 
418a			 
418a					NEXTW 
418a c3 34 1f			jp macro_next 
418d				endm 
# End of macro NEXTW
418d			.STYPE: 
418d				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
418d 48				db WORD_SYS_CORE+52             
418e dc 41			dw .UPPER            
4190 06				db 5 + 1 
4191 .. 00			db "STYPE",0              
4197				endm 
# End of macro CWHEAD
4197			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4197					if DEBUG_FORTH_WORDS_KEY 
4197						DMARK "STY" 
4197 f5				push af  
4198 3a ac 41			ld a, (.dmark)  
419b 32 6b ee			ld (debug_mark),a  
419e 3a ad 41			ld a, (.dmark+1)  
41a1 32 6c ee			ld (debug_mark+1),a  
41a4 3a ae 41			ld a, (.dmark+2)  
41a7 32 6d ee			ld (debug_mark+2),a  
41aa 18 03			jr .pastdmark  
41ac ..			.dmark: db "STY"  
41af f1			.pastdmark: pop af  
41b0			endm  
# End of macro DMARK
41b0						CALLMONITOR 
41b0 cd 6f ee			call debug_vector  
41b3				endm  
# End of macro CALLMONITOR
41b3					endif 
41b3					FORTH_DSP 
41b3 cd 44 1d			call macro_forth_dsp 
41b6				endm 
# End of macro FORTH_DSP
41b6					;v5 FORTH_DSP_VALUE 
41b6			 
41b6 7e					ld a, (hl) 
41b7			 
41b7 f5					push af 
41b8			 
41b8			; Dont destroy TOS		FORTH_DSP_POP 
41b8			 
41b8 f1					pop af 
41b9			 
41b9 fe 01				cp DS_TYPE_STR 
41bb 28 09				jr z, .typestr 
41bd			 
41bd fe 02				cp DS_TYPE_INUM 
41bf 28 0a				jr z, .typeinum 
41c1			 
41c1 21 da 41				ld hl, .tna 
41c4 18 0a				jr .tpush 
41c6			 
41c6 21 d6 41		.typestr:	ld hl, .tstr 
41c9 18 05				jr .tpush 
41cb 21 d8 41		.typeinum:	ld hl, .tinum 
41ce 18 00				jr .tpush 
41d0			 
41d0			.tpush: 
41d0			 
41d0 cd e7 1b				call forth_push_str 
41d3			 
41d3					NEXTW 
41d3 c3 34 1f			jp macro_next 
41d6				endm 
# End of macro NEXTW
41d6 .. 00		.tstr:	db "s",0 
41d8 .. 00		.tinum:  db "i",0 
41da .. 00		.tna:   db "?", 0 
41dc			 
41dc			 
41dc			.UPPER: 
41dc				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
41dc 48				db WORD_SYS_CORE+52             
41dd 17 42			dw .LOWER            
41df 06				db 5 + 1 
41e0 .. 00			db "UPPER",0              
41e6				endm 
# End of macro CWHEAD
41e6			; | UPPER ( s -- s ) Upper case string s  | DONE 
41e6					if DEBUG_FORTH_WORDS_KEY 
41e6						DMARK "UPR" 
41e6 f5				push af  
41e7 3a fb 41			ld a, (.dmark)  
41ea 32 6b ee			ld (debug_mark),a  
41ed 3a fc 41			ld a, (.dmark+1)  
41f0 32 6c ee			ld (debug_mark+1),a  
41f3 3a fd 41			ld a, (.dmark+2)  
41f6 32 6d ee			ld (debug_mark+2),a  
41f9 18 03			jr .pastdmark  
41fb ..			.dmark: db "UPR"  
41fe f1			.pastdmark: pop af  
41ff			endm  
# End of macro DMARK
41ff						CALLMONITOR 
41ff cd 6f ee			call debug_vector  
4202				endm  
# End of macro CALLMONITOR
4202					endif 
4202			 
4202					FORTH_DSP 
4202 cd 44 1d			call macro_forth_dsp 
4205				endm 
# End of macro FORTH_DSP
4205					 
4205			; TODO check is string type 
4205			 
4205					FORTH_DSP_VALUEHL 
4205 cd 7e 1d			call macro_dsp_valuehl 
4208				endm 
# End of macro FORTH_DSP_VALUEHL
4208			; get pointer to string in hl 
4208			 
4208 7e			.toup:		ld a, (hl) 
4209 fe 00				cp 0 
420b 28 07				jr z, .toupdone 
420d			 
420d cd 67 10				call to_upper 
4210			 
4210 77					ld (hl), a 
4211 23					inc hl 
4212 18 f4				jr .toup 
4214			 
4214					 
4214			 
4214			 
4214			; for each char convert to upper 
4214					 
4214			.toupdone: 
4214			 
4214			 
4214					NEXTW 
4214 c3 34 1f			jp macro_next 
4217				endm 
# End of macro NEXTW
4217			.LOWER: 
4217				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4217 48				db WORD_SYS_CORE+52             
4218 52 42			dw .TCASE            
421a 06				db 5 + 1 
421b .. 00			db "LOWER",0              
4221				endm 
# End of macro CWHEAD
4221			; | LOWER ( s -- s ) Lower case string s  | DONE 
4221					if DEBUG_FORTH_WORDS_KEY 
4221						DMARK "LWR" 
4221 f5				push af  
4222 3a 36 42			ld a, (.dmark)  
4225 32 6b ee			ld (debug_mark),a  
4228 3a 37 42			ld a, (.dmark+1)  
422b 32 6c ee			ld (debug_mark+1),a  
422e 3a 38 42			ld a, (.dmark+2)  
4231 32 6d ee			ld (debug_mark+2),a  
4234 18 03			jr .pastdmark  
4236 ..			.dmark: db "LWR"  
4239 f1			.pastdmark: pop af  
423a			endm  
# End of macro DMARK
423a						CALLMONITOR 
423a cd 6f ee			call debug_vector  
423d				endm  
# End of macro CALLMONITOR
423d					endif 
423d			 
423d					FORTH_DSP 
423d cd 44 1d			call macro_forth_dsp 
4240				endm 
# End of macro FORTH_DSP
4240					 
4240			; TODO check is string type 
4240			 
4240					FORTH_DSP_VALUEHL 
4240 cd 7e 1d			call macro_dsp_valuehl 
4243				endm 
# End of macro FORTH_DSP_VALUEHL
4243			; get pointer to string in hl 
4243			 
4243 7e			.tolow:		ld a, (hl) 
4244 fe 00				cp 0 
4246 28 07				jr z, .tolowdone 
4248			 
4248 cd 70 10				call to_lower 
424b			 
424b 77					ld (hl), a 
424c 23					inc hl 
424d 18 f4				jr .tolow 
424f			 
424f					 
424f			 
424f			 
424f			; for each char convert to low 
424f					 
424f			.tolowdone: 
424f					NEXTW 
424f c3 34 1f			jp macro_next 
4252				endm 
# End of macro NEXTW
4252			.TCASE: 
4252				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4252 48				db WORD_SYS_CORE+52             
4253 88 43			dw .SUBSTR            
4255 06				db 5 + 1 
4256 .. 00			db "TCASE",0              
425c				endm 
# End of macro CWHEAD
425c			; | TCASE ( s -- s ) Title case string s  | DONE 
425c					if DEBUG_FORTH_WORDS_KEY 
425c						DMARK "TCS" 
425c f5				push af  
425d 3a 71 42			ld a, (.dmark)  
4260 32 6b ee			ld (debug_mark),a  
4263 3a 72 42			ld a, (.dmark+1)  
4266 32 6c ee			ld (debug_mark+1),a  
4269 3a 73 42			ld a, (.dmark+2)  
426c 32 6d ee			ld (debug_mark+2),a  
426f 18 03			jr .pastdmark  
4271 ..			.dmark: db "TCS"  
4274 f1			.pastdmark: pop af  
4275			endm  
# End of macro DMARK
4275						CALLMONITOR 
4275 cd 6f ee			call debug_vector  
4278				endm  
# End of macro CALLMONITOR
4278					endif 
4278			 
4278					FORTH_DSP 
4278 cd 44 1d			call macro_forth_dsp 
427b				endm 
# End of macro FORTH_DSP
427b					 
427b			; TODO check is string type 
427b			 
427b					FORTH_DSP_VALUEHL 
427b cd 7e 1d			call macro_dsp_valuehl 
427e				endm 
# End of macro FORTH_DSP_VALUEHL
427e			; get pointer to string in hl 
427e			 
427e					if DEBUG_FORTH_WORDS 
427e						DMARK "TC1" 
427e f5				push af  
427f 3a 93 42			ld a, (.dmark)  
4282 32 6b ee			ld (debug_mark),a  
4285 3a 94 42			ld a, (.dmark+1)  
4288 32 6c ee			ld (debug_mark+1),a  
428b 3a 95 42			ld a, (.dmark+2)  
428e 32 6d ee			ld (debug_mark+2),a  
4291 18 03			jr .pastdmark  
4293 ..			.dmark: db "TC1"  
4296 f1			.pastdmark: pop af  
4297			endm  
# End of macro DMARK
4297						CALLMONITOR 
4297 cd 6f ee			call debug_vector  
429a				endm  
# End of macro CALLMONITOR
429a					endif 
429a			 
429a					; first time in turn to upper case first char 
429a			 
429a 7e					ld a, (hl) 
429b c3 25 43				jp .totsiptou 
429e			 
429e			 
429e 7e			.tot:		ld a, (hl) 
429f fe 00				cp 0 
42a1 ca 69 43				jp z, .totdone 
42a4			 
42a4					if DEBUG_FORTH_WORDS 
42a4						DMARK "TC2" 
42a4 f5				push af  
42a5 3a b9 42			ld a, (.dmark)  
42a8 32 6b ee			ld (debug_mark),a  
42ab 3a ba 42			ld a, (.dmark+1)  
42ae 32 6c ee			ld (debug_mark+1),a  
42b1 3a bb 42			ld a, (.dmark+2)  
42b4 32 6d ee			ld (debug_mark+2),a  
42b7 18 03			jr .pastdmark  
42b9 ..			.dmark: db "TC2"  
42bc f1			.pastdmark: pop af  
42bd			endm  
# End of macro DMARK
42bd						CALLMONITOR 
42bd cd 6f ee			call debug_vector  
42c0				endm  
# End of macro CALLMONITOR
42c0					endif 
42c0					; check to see if current char is a space 
42c0			 
42c0 fe 20				cp ' ' 
42c2 28 21				jr z, .totsp 
42c4 cd 70 10				call to_lower 
42c7					if DEBUG_FORTH_WORDS 
42c7						DMARK "TC3" 
42c7 f5				push af  
42c8 3a dc 42			ld a, (.dmark)  
42cb 32 6b ee			ld (debug_mark),a  
42ce 3a dd 42			ld a, (.dmark+1)  
42d1 32 6c ee			ld (debug_mark+1),a  
42d4 3a de 42			ld a, (.dmark+2)  
42d7 32 6d ee			ld (debug_mark+2),a  
42da 18 03			jr .pastdmark  
42dc ..			.dmark: db "TC3"  
42df f1			.pastdmark: pop af  
42e0			endm  
# End of macro DMARK
42e0						CALLMONITOR 
42e0 cd 6f ee			call debug_vector  
42e3				endm  
# End of macro CALLMONITOR
42e3					endif 
42e3 18 63				jr .totnxt 
42e5			 
42e5			.totsp:         ; on a space, find next char which should be upper 
42e5			 
42e5					if DEBUG_FORTH_WORDS 
42e5						DMARK "TC4" 
42e5 f5				push af  
42e6 3a fa 42			ld a, (.dmark)  
42e9 32 6b ee			ld (debug_mark),a  
42ec 3a fb 42			ld a, (.dmark+1)  
42ef 32 6c ee			ld (debug_mark+1),a  
42f2 3a fc 42			ld a, (.dmark+2)  
42f5 32 6d ee			ld (debug_mark+2),a  
42f8 18 03			jr .pastdmark  
42fa ..			.dmark: db "TC4"  
42fd f1			.pastdmark: pop af  
42fe			endm  
# End of macro DMARK
42fe						CALLMONITOR 
42fe cd 6f ee			call debug_vector  
4301				endm  
# End of macro CALLMONITOR
4301					endif 
4301					;; 
4301			 
4301 fe 20				cp ' ' 
4303 20 20				jr nz, .totsiptou 
4305 23					inc hl 
4306 7e					ld a, (hl) 
4307					if DEBUG_FORTH_WORDS 
4307						DMARK "TC5" 
4307 f5				push af  
4308 3a 1c 43			ld a, (.dmark)  
430b 32 6b ee			ld (debug_mark),a  
430e 3a 1d 43			ld a, (.dmark+1)  
4311 32 6c ee			ld (debug_mark+1),a  
4314 3a 1e 43			ld a, (.dmark+2)  
4317 32 6d ee			ld (debug_mark+2),a  
431a 18 03			jr .pastdmark  
431c ..			.dmark: db "TC5"  
431f f1			.pastdmark: pop af  
4320			endm  
# End of macro DMARK
4320						CALLMONITOR 
4320 cd 6f ee			call debug_vector  
4323				endm  
# End of macro CALLMONITOR
4323					endif 
4323 18 c0				jr .totsp 
4325 fe 00		.totsiptou:    cp 0 
4327 28 40				jr z, .totdone 
4329					; not space and not zero term so upper case it 
4329 cd 67 10				call to_upper 
432c			 
432c					if DEBUG_FORTH_WORDS 
432c						DMARK "TC6" 
432c f5				push af  
432d 3a 41 43			ld a, (.dmark)  
4330 32 6b ee			ld (debug_mark),a  
4333 3a 42 43			ld a, (.dmark+1)  
4336 32 6c ee			ld (debug_mark+1),a  
4339 3a 43 43			ld a, (.dmark+2)  
433c 32 6d ee			ld (debug_mark+2),a  
433f 18 03			jr .pastdmark  
4341 ..			.dmark: db "TC6"  
4344 f1			.pastdmark: pop af  
4345			endm  
# End of macro DMARK
4345						CALLMONITOR 
4345 cd 6f ee			call debug_vector  
4348				endm  
# End of macro CALLMONITOR
4348					endif 
4348			 
4348			 
4348			.totnxt: 
4348			 
4348 77					ld (hl), a 
4349 23					inc hl 
434a					if DEBUG_FORTH_WORDS 
434a						DMARK "TC7" 
434a f5				push af  
434b 3a 5f 43			ld a, (.dmark)  
434e 32 6b ee			ld (debug_mark),a  
4351 3a 60 43			ld a, (.dmark+1)  
4354 32 6c ee			ld (debug_mark+1),a  
4357 3a 61 43			ld a, (.dmark+2)  
435a 32 6d ee			ld (debug_mark+2),a  
435d 18 03			jr .pastdmark  
435f ..			.dmark: db "TC7"  
4362 f1			.pastdmark: pop af  
4363			endm  
# End of macro DMARK
4363						CALLMONITOR 
4363 cd 6f ee			call debug_vector  
4366				endm  
# End of macro CALLMONITOR
4366					endif 
4366 c3 9e 42				jp .tot 
4369			 
4369					 
4369			 
4369			 
4369			; for each char convert to low 
4369					 
4369			.totdone: 
4369					if DEBUG_FORTH_WORDS 
4369						DMARK "TCd" 
4369 f5				push af  
436a 3a 7e 43			ld a, (.dmark)  
436d 32 6b ee			ld (debug_mark),a  
4370 3a 7f 43			ld a, (.dmark+1)  
4373 32 6c ee			ld (debug_mark+1),a  
4376 3a 80 43			ld a, (.dmark+2)  
4379 32 6d ee			ld (debug_mark+2),a  
437c 18 03			jr .pastdmark  
437e ..			.dmark: db "TCd"  
4381 f1			.pastdmark: pop af  
4382			endm  
# End of macro DMARK
4382						CALLMONITOR 
4382 cd 6f ee			call debug_vector  
4385				endm  
# End of macro CALLMONITOR
4385					endif 
4385					NEXTW 
4385 c3 34 1f			jp macro_next 
4388				endm 
# End of macro NEXTW
4388			 
4388			.SUBSTR: 
4388				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4388 48				db WORD_SYS_CORE+52             
4389 e6 43			dw .LEFT            
438b 07				db 6 + 1 
438c .. 00			db "SUBSTR",0              
4393				endm 
# End of macro CWHEAD
4393			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4393			 
4393					if DEBUG_FORTH_WORDS_KEY 
4393						DMARK "SST" 
4393 f5				push af  
4394 3a a8 43			ld a, (.dmark)  
4397 32 6b ee			ld (debug_mark),a  
439a 3a a9 43			ld a, (.dmark+1)  
439d 32 6c ee			ld (debug_mark+1),a  
43a0 3a aa 43			ld a, (.dmark+2)  
43a3 32 6d ee			ld (debug_mark+2),a  
43a6 18 03			jr .pastdmark  
43a8 ..			.dmark: db "SST"  
43ab f1			.pastdmark: pop af  
43ac			endm  
# End of macro DMARK
43ac						CALLMONITOR 
43ac cd 6f ee			call debug_vector  
43af				endm  
# End of macro CALLMONITOR
43af					endif 
43af			; TODO check string type 
43af					FORTH_DSP_VALUEHL 
43af cd 7e 1d			call macro_dsp_valuehl 
43b2				endm 
# End of macro FORTH_DSP_VALUEHL
43b2			 
43b2 e5					push hl      ; string length 
43b3			 
43b3					FORTH_DSP_POP 
43b3 cd 36 1e			call macro_forth_dsp_pop 
43b6				endm 
# End of macro FORTH_DSP_POP
43b6			 
43b6					FORTH_DSP_VALUEHL 
43b6 cd 7e 1d			call macro_dsp_valuehl 
43b9				endm 
# End of macro FORTH_DSP_VALUEHL
43b9			 
43b9 e5					push hl     ; start char 
43ba			 
43ba					FORTH_DSP_POP 
43ba cd 36 1e			call macro_forth_dsp_pop 
43bd				endm 
# End of macro FORTH_DSP_POP
43bd			 
43bd			 
43bd					FORTH_DSP_VALUE 
43bd cd 67 1d			call macro_forth_dsp_value 
43c0				endm 
# End of macro FORTH_DSP_VALUE
43c0			 
43c0 d1					pop de    ; get start post offset 
43c1			 
43c1 19					add hl, de    ; starting offset 
43c2			 
43c2 c1					pop bc 
43c3 c5					push bc      ; grab size of string 
43c4			 
43c4 e5					push hl    ; save string start  
43c5			 
43c5 26 00				ld h, 0 
43c7 69					ld l, c 
43c8 23					inc hl 
43c9 23					inc hl 
43ca			 
43ca cd cd 11				call malloc 
43cd				if DEBUG_FORTH_MALLOC_GUARD 
43cd cc 00 4d				call z,malloc_error 
43d0				endif 
43d0			 
43d0 eb					ex de, hl      ; save malloc area for string copy 
43d1 e1					pop hl    ; get back source 
43d2 c1					pop bc    ; get length of string back 
43d3			 
43d3 d5					push de    ; save malloc area for after we push 
43d4 ed b0				ldir     ; copy substr 
43d6			 
43d6			 
43d6 eb					ex de, hl 
43d7 3e 00				ld a, 0 
43d9 77					ld (hl), a   ; term substr 
43da			 
43da					 
43da e1					pop hl    ; get malloc so we can push it 
43db e5					push hl   ; save so we can free it afterwards 
43dc			 
43dc cd e7 1b				call forth_push_str 
43df			 
43df e1					pop hl 
43e0 cd 97 12				call free 
43e3			 
43e3					 
43e3					 
43e3			 
43e3			 
43e3					NEXTW 
43e3 c3 34 1f			jp macro_next 
43e6				endm 
# End of macro NEXTW
43e6			 
43e6			.LEFT: 
43e6				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
43e6 48				db WORD_SYS_CORE+52             
43e7 0e 44			dw .RIGHT            
43e9 05				db 4 + 1 
43ea .. 00			db "LEFT",0              
43ef				endm 
# End of macro CWHEAD
43ef			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
43ef					if DEBUG_FORTH_WORDS_KEY 
43ef						DMARK "LEF" 
43ef f5				push af  
43f0 3a 04 44			ld a, (.dmark)  
43f3 32 6b ee			ld (debug_mark),a  
43f6 3a 05 44			ld a, (.dmark+1)  
43f9 32 6c ee			ld (debug_mark+1),a  
43fc 3a 06 44			ld a, (.dmark+2)  
43ff 32 6d ee			ld (debug_mark+2),a  
4402 18 03			jr .pastdmark  
4404 ..			.dmark: db "LEF"  
4407 f1			.pastdmark: pop af  
4408			endm  
# End of macro DMARK
4408						CALLMONITOR 
4408 cd 6f ee			call debug_vector  
440b				endm  
# End of macro CALLMONITOR
440b					endif 
440b			 
440b					NEXTW 
440b c3 34 1f			jp macro_next 
440e				endm 
# End of macro NEXTW
440e			.RIGHT: 
440e				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
440e 48				db WORD_SYS_CORE+52             
440f 37 44			dw .STR2NUM            
4411 06				db 5 + 1 
4412 .. 00			db "RIGHT",0              
4418				endm 
# End of macro CWHEAD
4418			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4418					if DEBUG_FORTH_WORDS_KEY 
4418						DMARK "RIG" 
4418 f5				push af  
4419 3a 2d 44			ld a, (.dmark)  
441c 32 6b ee			ld (debug_mark),a  
441f 3a 2e 44			ld a, (.dmark+1)  
4422 32 6c ee			ld (debug_mark+1),a  
4425 3a 2f 44			ld a, (.dmark+2)  
4428 32 6d ee			ld (debug_mark+2),a  
442b 18 03			jr .pastdmark  
442d ..			.dmark: db "RIG"  
4430 f1			.pastdmark: pop af  
4431			endm  
# End of macro DMARK
4431						CALLMONITOR 
4431 cd 6f ee			call debug_vector  
4434				endm  
# End of macro CALLMONITOR
4434					endif 
4434			 
4434					NEXTW 
4434 c3 34 1f			jp macro_next 
4437				endm 
# End of macro NEXTW
4437			 
4437			 
4437			.STR2NUM: 
4437				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4437 48				db WORD_SYS_CORE+52             
4438 c3 44			dw .NUM2STR            
443a 08				db 7 + 1 
443b .. 00			db "STR2NUM",0              
4443				endm 
# End of macro CWHEAD
4443			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4443			 
4443			 
4443			; TODO STR type check to do 
4443					if DEBUG_FORTH_WORDS_KEY 
4443						DMARK "S2N" 
4443 f5				push af  
4444 3a 58 44			ld a, (.dmark)  
4447 32 6b ee			ld (debug_mark),a  
444a 3a 59 44			ld a, (.dmark+1)  
444d 32 6c ee			ld (debug_mark+1),a  
4450 3a 5a 44			ld a, (.dmark+2)  
4453 32 6d ee			ld (debug_mark+2),a  
4456 18 03			jr .pastdmark  
4458 ..			.dmark: db "S2N"  
445b f1			.pastdmark: pop af  
445c			endm  
# End of macro DMARK
445c						CALLMONITOR 
445c cd 6f ee			call debug_vector  
445f				endm  
# End of macro CALLMONITOR
445f					endif 
445f			 
445f					;FORTH_DSP 
445f					FORTH_DSP_VALUE 
445f cd 67 1d			call macro_forth_dsp_value 
4462				endm 
# End of macro FORTH_DSP_VALUE
4462					;inc hl 
4462			 
4462 eb					ex de, hl 
4463					if DEBUG_FORTH_WORDS 
4463						DMARK "S2a" 
4463 f5				push af  
4464 3a 78 44			ld a, (.dmark)  
4467 32 6b ee			ld (debug_mark),a  
446a 3a 79 44			ld a, (.dmark+1)  
446d 32 6c ee			ld (debug_mark+1),a  
4470 3a 7a 44			ld a, (.dmark+2)  
4473 32 6d ee			ld (debug_mark+2),a  
4476 18 03			jr .pastdmark  
4478 ..			.dmark: db "S2a"  
447b f1			.pastdmark: pop af  
447c			endm  
# End of macro DMARK
447c						CALLMONITOR 
447c cd 6f ee			call debug_vector  
447f				endm  
# End of macro CALLMONITOR
447f					endif 
447f cd ef 10				call string_to_uint16 
4482			 
4482					if DEBUG_FORTH_WORDS 
4482						DMARK "S2b" 
4482 f5				push af  
4483 3a 97 44			ld a, (.dmark)  
4486 32 6b ee			ld (debug_mark),a  
4489 3a 98 44			ld a, (.dmark+1)  
448c 32 6c ee			ld (debug_mark+1),a  
448f 3a 99 44			ld a, (.dmark+2)  
4492 32 6d ee			ld (debug_mark+2),a  
4495 18 03			jr .pastdmark  
4497 ..			.dmark: db "S2b"  
449a f1			.pastdmark: pop af  
449b			endm  
# End of macro DMARK
449b						CALLMONITOR 
449b cd 6f ee			call debug_vector  
449e				endm  
# End of macro CALLMONITOR
449e					endif 
449e			;		push hl 
449e					FORTH_DSP_POP 
449e cd 36 1e			call macro_forth_dsp_pop 
44a1				endm 
# End of macro FORTH_DSP_POP
44a1			;		pop hl 
44a1					 
44a1					if DEBUG_FORTH_WORDS 
44a1						DMARK "S2b" 
44a1 f5				push af  
44a2 3a b6 44			ld a, (.dmark)  
44a5 32 6b ee			ld (debug_mark),a  
44a8 3a b7 44			ld a, (.dmark+1)  
44ab 32 6c ee			ld (debug_mark+1),a  
44ae 3a b8 44			ld a, (.dmark+2)  
44b1 32 6d ee			ld (debug_mark+2),a  
44b4 18 03			jr .pastdmark  
44b6 ..			.dmark: db "S2b"  
44b9 f1			.pastdmark: pop af  
44ba			endm  
# End of macro DMARK
44ba						CALLMONITOR 
44ba cd 6f ee			call debug_vector  
44bd				endm  
# End of macro CALLMONITOR
44bd					endif 
44bd cd 79 1b				call forth_push_numhl	 
44c0			 
44c0				 
44c0				       NEXTW 
44c0 c3 34 1f			jp macro_next 
44c3				endm 
# End of macro NEXTW
44c3			.NUM2STR: 
44c3				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
44c3 48				db WORD_SYS_CORE+52             
44c4 d2 44			dw .CONCAT            
44c6 08				db 7 + 1 
44c7 .. 00			db "NUM2STR",0              
44cf				endm 
# End of macro CWHEAD
44cf			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
44cf			 
44cf			;		; malloc a string to target 
44cf			;		ld hl, 10     ; TODO max string size should be fine 
44cf			;		call malloc 
44cf			;		push hl    ; save malloc location 
44cf			; 
44cf			; 
44cf			;; TODO check int type 
44cf			;		FORTH_DSP_VALUEHL 
44cf			;		ld a, l 
44cf			;		call DispAToASCII   
44cf			;;TODO need to chage above call to dump into string 
44cf			; 
44cf			; 
44cf			 
44cf				       NEXTW 
44cf c3 34 1f			jp macro_next 
44d2				endm 
# End of macro NEXTW
44d2			 
44d2			.CONCAT: 
44d2				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
44d2 48				db WORD_SYS_CORE+52             
44d3 85 45			dw .FIND            
44d5 07				db 6 + 1 
44d6 .. 00			db "CONCAT",0              
44dd				endm 
# End of macro CWHEAD
44dd			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
44dd			 
44dd			; TODO check string type 
44dd			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
44dd			 
44dd					if DEBUG_FORTH_WORDS_KEY 
44dd						DMARK "CON" 
44dd f5				push af  
44de 3a f2 44			ld a, (.dmark)  
44e1 32 6b ee			ld (debug_mark),a  
44e4 3a f3 44			ld a, (.dmark+1)  
44e7 32 6c ee			ld (debug_mark+1),a  
44ea 3a f4 44			ld a, (.dmark+2)  
44ed 32 6d ee			ld (debug_mark+2),a  
44f0 18 03			jr .pastdmark  
44f2 ..			.dmark: db "CON"  
44f5 f1			.pastdmark: pop af  
44f6			endm  
# End of macro DMARK
44f6						CALLMONITOR 
44f6 cd 6f ee			call debug_vector  
44f9				endm  
# End of macro CALLMONITOR
44f9					endif 
44f9			 
44f9			 
44f9					FORTH_DSP_VALUE 
44f9 cd 67 1d			call macro_forth_dsp_value 
44fc				endm 
# End of macro FORTH_DSP_VALUE
44fc e5					push hl   ; s2 
44fd			 
44fd					FORTH_DSP_POP 
44fd cd 36 1e			call macro_forth_dsp_pop 
4500				endm 
# End of macro FORTH_DSP_POP
4500			 
4500					FORTH_DSP_VALUE 
4500 cd 67 1d			call macro_forth_dsp_value 
4503				endm 
# End of macro FORTH_DSP_VALUE
4503			 
4503 e5					push hl   ; s1 
4504			 
4504					FORTH_DSP_POP 
4504 cd 36 1e			call macro_forth_dsp_pop 
4507				endm 
# End of macro FORTH_DSP_POP
4507					 
4507			 
4507					; copy s1 
4507			 
4507				 
4507					; save ptr 
4507 e1					pop hl  
4508 e5					push hl 
4509 3e 00				ld a, 0 
450b cd 63 11				call strlent 
450e					;inc hl    ; zer0 
450e 06 00				ld b, 0 
4510 4d					ld c, l 
4511 e1					pop hl		 
4512 11 c1 e2				ld de, scratch	 
4515					if DEBUG_FORTH_WORDS 
4515						DMARK "CO1" 
4515 f5				push af  
4516 3a 2a 45			ld a, (.dmark)  
4519 32 6b ee			ld (debug_mark),a  
451c 3a 2b 45			ld a, (.dmark+1)  
451f 32 6c ee			ld (debug_mark+1),a  
4522 3a 2c 45			ld a, (.dmark+2)  
4525 32 6d ee			ld (debug_mark+2),a  
4528 18 03			jr .pastdmark  
452a ..			.dmark: db "CO1"  
452d f1			.pastdmark: pop af  
452e			endm  
# End of macro DMARK
452e						CALLMONITOR 
452e cd 6f ee			call debug_vector  
4531				endm  
# End of macro CALLMONITOR
4531					endif 
4531 ed b0				ldir 
4533			 
4533 e1					pop hl 
4534 e5					push hl 
4535 d5					push de 
4536			 
4536			 
4536 3e 00				ld a, 0 
4538 cd 63 11				call strlent 
453b 23					inc hl    ; zer0 
453c 23					inc hl 
453d 06 00				ld b, 0 
453f 4d					ld c, l 
4540 d1					pop de 
4541 e1					pop hl		 
4542					if DEBUG_FORTH_WORDS 
4542						DMARK "CO2" 
4542 f5				push af  
4543 3a 57 45			ld a, (.dmark)  
4546 32 6b ee			ld (debug_mark),a  
4549 3a 58 45			ld a, (.dmark+1)  
454c 32 6c ee			ld (debug_mark+1),a  
454f 3a 59 45			ld a, (.dmark+2)  
4552 32 6d ee			ld (debug_mark+2),a  
4555 18 03			jr .pastdmark  
4557 ..			.dmark: db "CO2"  
455a f1			.pastdmark: pop af  
455b			endm  
# End of macro DMARK
455b						CALLMONITOR 
455b cd 6f ee			call debug_vector  
455e				endm  
# End of macro CALLMONITOR
455e					endif 
455e ed b0				ldir 
4560			 
4560			 
4560			 
4560 21 c1 e2				ld hl, scratch 
4563					if DEBUG_FORTH_WORDS 
4563						DMARK "CO5" 
4563 f5				push af  
4564 3a 78 45			ld a, (.dmark)  
4567 32 6b ee			ld (debug_mark),a  
456a 3a 79 45			ld a, (.dmark+1)  
456d 32 6c ee			ld (debug_mark+1),a  
4570 3a 7a 45			ld a, (.dmark+2)  
4573 32 6d ee			ld (debug_mark+2),a  
4576 18 03			jr .pastdmark  
4578 ..			.dmark: db "CO5"  
457b f1			.pastdmark: pop af  
457c			endm  
# End of macro DMARK
457c						CALLMONITOR 
457c cd 6f ee			call debug_vector  
457f				endm  
# End of macro CALLMONITOR
457f					endif 
457f			 
457f cd e7 1b				call forth_push_str 
4582			 
4582			 
4582			 
4582			 
4582				       NEXTW 
4582 c3 34 1f			jp macro_next 
4585				endm 
# End of macro NEXTW
4585			 
4585			 
4585			.FIND: 
4585				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4585 4b				db WORD_SYS_CORE+55             
4586 43 46			dw .LEN            
4588 05				db 4 + 1 
4589 .. 00			db "FIND",0              
458e				endm 
# End of macro CWHEAD
458e			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
458e			 
458e					if DEBUG_FORTH_WORDS_KEY 
458e						DMARK "FND" 
458e f5				push af  
458f 3a a3 45			ld a, (.dmark)  
4592 32 6b ee			ld (debug_mark),a  
4595 3a a4 45			ld a, (.dmark+1)  
4598 32 6c ee			ld (debug_mark+1),a  
459b 3a a5 45			ld a, (.dmark+2)  
459e 32 6d ee			ld (debug_mark+2),a  
45a1 18 03			jr .pastdmark  
45a3 ..			.dmark: db "FND"  
45a6 f1			.pastdmark: pop af  
45a7			endm  
# End of macro DMARK
45a7						CALLMONITOR 
45a7 cd 6f ee			call debug_vector  
45aa				endm  
# End of macro CALLMONITOR
45aa					endif 
45aa			 
45aa			; TODO check string type 
45aa					FORTH_DSP_VALUE 
45aa cd 67 1d			call macro_forth_dsp_value 
45ad				endm 
# End of macro FORTH_DSP_VALUE
45ad			 
45ad e5					push hl    
45ae 7e					ld a,(hl)    ; char to find   
45af			; TODO change char to substr 
45af			 
45af f5					push af 
45b0					 
45b0			 
45b0			 
45b0					if DEBUG_FORTH_WORDS 
45b0						DMARK "FN1" 
45b0 f5				push af  
45b1 3a c5 45			ld a, (.dmark)  
45b4 32 6b ee			ld (debug_mark),a  
45b7 3a c6 45			ld a, (.dmark+1)  
45ba 32 6c ee			ld (debug_mark+1),a  
45bd 3a c7 45			ld a, (.dmark+2)  
45c0 32 6d ee			ld (debug_mark+2),a  
45c3 18 03			jr .pastdmark  
45c5 ..			.dmark: db "FN1"  
45c8 f1			.pastdmark: pop af  
45c9			endm  
# End of macro DMARK
45c9						CALLMONITOR 
45c9 cd 6f ee			call debug_vector  
45cc				endm  
# End of macro CALLMONITOR
45cc					endif 
45cc			 
45cc					FORTH_DSP_POP 
45cc cd 36 1e			call macro_forth_dsp_pop 
45cf				endm 
# End of macro FORTH_DSP_POP
45cf			 
45cf					; string to search 
45cf			 
45cf					FORTH_DSP_VALUE 
45cf cd 67 1d			call macro_forth_dsp_value 
45d2				endm 
# End of macro FORTH_DSP_VALUE
45d2			 
45d2 d1					pop de  ; d is char to find  
45d3			 
45d3					if DEBUG_FORTH_WORDS 
45d3						DMARK "FN2" 
45d3 f5				push af  
45d4 3a e8 45			ld a, (.dmark)  
45d7 32 6b ee			ld (debug_mark),a  
45da 3a e9 45			ld a, (.dmark+1)  
45dd 32 6c ee			ld (debug_mark+1),a  
45e0 3a ea 45			ld a, (.dmark+2)  
45e3 32 6d ee			ld (debug_mark+2),a  
45e6 18 03			jr .pastdmark  
45e8 ..			.dmark: db "FN2"  
45eb f1			.pastdmark: pop af  
45ec			endm  
# End of macro DMARK
45ec						CALLMONITOR 
45ec cd 6f ee			call debug_vector  
45ef				endm  
# End of macro CALLMONITOR
45ef					endif 
45ef					 
45ef 01 00 00				ld bc, 0 
45f2 7e			.findchar:      ld a,(hl) 
45f3 fe 00				cp 0   		 
45f5 28 27				jr z, .finddone     
45f7 ba					cp d 
45f8 28 20				jr z, .foundchar 
45fa 03					inc bc 
45fb 23					inc hl 
45fc					if DEBUG_FORTH_WORDS 
45fc						DMARK "FN3" 
45fc f5				push af  
45fd 3a 11 46			ld a, (.dmark)  
4600 32 6b ee			ld (debug_mark),a  
4603 3a 12 46			ld a, (.dmark+1)  
4606 32 6c ee			ld (debug_mark+1),a  
4609 3a 13 46			ld a, (.dmark+2)  
460c 32 6d ee			ld (debug_mark+2),a  
460f 18 03			jr .pastdmark  
4611 ..			.dmark: db "FN3"  
4614 f1			.pastdmark: pop af  
4615			endm  
# End of macro DMARK
4615						CALLMONITOR 
4615 cd 6f ee			call debug_vector  
4618				endm  
# End of macro CALLMONITOR
4618					endif 
4618 18 d8				jr .findchar 
461a			 
461a			 
461a c5			.foundchar:	push bc 
461b e1					pop hl 
461c 18 03				jr .findexit 
461e			 
461e			 
461e							 
461e			 
461e			.finddone:     ; got to end of string with no find 
461e 21 00 00				ld hl, 0 
4621			.findexit: 
4621			 
4621					if DEBUG_FORTH_WORDS 
4621						DMARK "FNd" 
4621 f5				push af  
4622 3a 36 46			ld a, (.dmark)  
4625 32 6b ee			ld (debug_mark),a  
4628 3a 37 46			ld a, (.dmark+1)  
462b 32 6c ee			ld (debug_mark+1),a  
462e 3a 38 46			ld a, (.dmark+2)  
4631 32 6d ee			ld (debug_mark+2),a  
4634 18 03			jr .pastdmark  
4636 ..			.dmark: db "FNd"  
4639 f1			.pastdmark: pop af  
463a			endm  
# End of macro DMARK
463a						CALLMONITOR 
463a cd 6f ee			call debug_vector  
463d				endm  
# End of macro CALLMONITOR
463d					endif 
463d cd 79 1b			call forth_push_numhl 
4640			 
4640				       NEXTW 
4640 c3 34 1f			jp macro_next 
4643				endm 
# End of macro NEXTW
4643			 
4643			.LEN: 
4643				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4643 4c				db WORD_SYS_CORE+56             
4644 ad 46			dw .ASC            
4646 06				db 5 + 1 
4647 .. 00			db "COUNT",0              
464d				endm 
# End of macro CWHEAD
464d			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
464d			 
464d					if DEBUG_FORTH_WORDS_KEY 
464d						DMARK "CNT" 
464d f5				push af  
464e 3a 62 46			ld a, (.dmark)  
4651 32 6b ee			ld (debug_mark),a  
4654 3a 63 46			ld a, (.dmark+1)  
4657 32 6c ee			ld (debug_mark+1),a  
465a 3a 64 46			ld a, (.dmark+2)  
465d 32 6d ee			ld (debug_mark+2),a  
4660 18 03			jr .pastdmark  
4662 ..			.dmark: db "CNT"  
4665 f1			.pastdmark: pop af  
4666			endm  
# End of macro DMARK
4666						CALLMONITOR 
4666 cd 6f ee			call debug_vector  
4669				endm  
# End of macro CALLMONITOR
4669					endif 
4669			; TODO check string type 
4669					FORTH_DSP_VALUE 
4669 cd 67 1d			call macro_forth_dsp_value 
466c				endm 
# End of macro FORTH_DSP_VALUE
466c			 
466c			 
466c					if DEBUG_FORTH_WORDS 
466c						DMARK "CN?" 
466c f5				push af  
466d 3a 81 46			ld a, (.dmark)  
4670 32 6b ee			ld (debug_mark),a  
4673 3a 82 46			ld a, (.dmark+1)  
4676 32 6c ee			ld (debug_mark+1),a  
4679 3a 83 46			ld a, (.dmark+2)  
467c 32 6d ee			ld (debug_mark+2),a  
467f 18 03			jr .pastdmark  
4681 ..			.dmark: db "CN?"  
4684 f1			.pastdmark: pop af  
4685			endm  
# End of macro DMARK
4685						CALLMONITOR 
4685 cd 6f ee			call debug_vector  
4688				endm  
# End of macro CALLMONITOR
4688					endif 
4688 cd 58 11				call strlenz 
468b					if DEBUG_FORTH_WORDS 
468b						DMARK "CNl" 
468b f5				push af  
468c 3a a0 46			ld a, (.dmark)  
468f 32 6b ee			ld (debug_mark),a  
4692 3a a1 46			ld a, (.dmark+1)  
4695 32 6c ee			ld (debug_mark+1),a  
4698 3a a2 46			ld a, (.dmark+2)  
469b 32 6d ee			ld (debug_mark+2),a  
469e 18 03			jr .pastdmark  
46a0 ..			.dmark: db "CNl"  
46a3 f1			.pastdmark: pop af  
46a4			endm  
# End of macro DMARK
46a4						CALLMONITOR 
46a4 cd 6f ee			call debug_vector  
46a7				endm  
# End of macro CALLMONITOR
46a7					endif 
46a7			 
46a7 cd 79 1b				call forth_push_numhl 
46aa			 
46aa			 
46aa			 
46aa				       NEXTW 
46aa c3 34 1f			jp macro_next 
46ad				endm 
# End of macro NEXTW
46ad			.ASC: 
46ad				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
46ad 4d				db WORD_SYS_CORE+57             
46ae 1b 47			dw .CHR            
46b0 04				db 3 + 1 
46b1 .. 00			db "ASC",0              
46b5				endm 
# End of macro CWHEAD
46b5			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
46b5					if DEBUG_FORTH_WORDS_KEY 
46b5						DMARK "ASC" 
46b5 f5				push af  
46b6 3a ca 46			ld a, (.dmark)  
46b9 32 6b ee			ld (debug_mark),a  
46bc 3a cb 46			ld a, (.dmark+1)  
46bf 32 6c ee			ld (debug_mark+1),a  
46c2 3a cc 46			ld a, (.dmark+2)  
46c5 32 6d ee			ld (debug_mark+2),a  
46c8 18 03			jr .pastdmark  
46ca ..			.dmark: db "ASC"  
46cd f1			.pastdmark: pop af  
46ce			endm  
# End of macro DMARK
46ce						CALLMONITOR 
46ce cd 6f ee			call debug_vector  
46d1				endm  
# End of macro CALLMONITOR
46d1					endif 
46d1					FORTH_DSP_VALUE 
46d1 cd 67 1d			call macro_forth_dsp_value 
46d4				endm 
# End of macro FORTH_DSP_VALUE
46d4					;v5 FORTH_DSP_VALUE 
46d4			;		inc hl      ; now at start of numeric as string 
46d4			 
46d4 e5					push hl 
46d5			 
46d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46d5 cd 36 1e			call macro_forth_dsp_pop 
46d8				endm 
# End of macro FORTH_DSP_POP
46d8			 
46d8 e1					pop hl 
46d9			 
46d9					if DEBUG_FORTH_WORDS 
46d9						DMARK "AS1" 
46d9 f5				push af  
46da 3a ee 46			ld a, (.dmark)  
46dd 32 6b ee			ld (debug_mark),a  
46e0 3a ef 46			ld a, (.dmark+1)  
46e3 32 6c ee			ld (debug_mark+1),a  
46e6 3a f0 46			ld a, (.dmark+2)  
46e9 32 6d ee			ld (debug_mark+2),a  
46ec 18 03			jr .pastdmark  
46ee ..			.dmark: db "AS1"  
46f1 f1			.pastdmark: pop af  
46f2			endm  
# End of macro DMARK
46f2						CALLMONITOR 
46f2 cd 6f ee			call debug_vector  
46f5				endm  
# End of macro CALLMONITOR
46f5					endif 
46f5					; push the content of a onto the stack as a value 
46f5			 
46f5 7e					ld a,(hl)   ; get char 
46f6 26 00				ld h,0 
46f8 6f					ld l,a 
46f9					if DEBUG_FORTH_WORDS 
46f9						DMARK "AS2" 
46f9 f5				push af  
46fa 3a 0e 47			ld a, (.dmark)  
46fd 32 6b ee			ld (debug_mark),a  
4700 3a 0f 47			ld a, (.dmark+1)  
4703 32 6c ee			ld (debug_mark+1),a  
4706 3a 10 47			ld a, (.dmark+2)  
4709 32 6d ee			ld (debug_mark+2),a  
470c 18 03			jr .pastdmark  
470e ..			.dmark: db "AS2"  
4711 f1			.pastdmark: pop af  
4712			endm  
# End of macro DMARK
4712						CALLMONITOR 
4712 cd 6f ee			call debug_vector  
4715				endm  
# End of macro CALLMONITOR
4715					endif 
4715 cd 79 1b				call forth_push_numhl 
4718			 
4718				       NEXTW 
4718 c3 34 1f			jp macro_next 
471b				endm 
# End of macro NEXTW
471b			 
471b			.CHR: 
471b				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
471b 4d				db WORD_SYS_CORE+57             
471c 57 47			dw .ENDSTR            
471e 04				db 3 + 1 
471f .. 00			db "CHR",0              
4723				endm 
# End of macro CWHEAD
4723			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4723					if DEBUG_FORTH_WORDS_KEY 
4723						DMARK "CHR" 
4723 f5				push af  
4724 3a 38 47			ld a, (.dmark)  
4727 32 6b ee			ld (debug_mark),a  
472a 3a 39 47			ld a, (.dmark+1)  
472d 32 6c ee			ld (debug_mark+1),a  
4730 3a 3a 47			ld a, (.dmark+2)  
4733 32 6d ee			ld (debug_mark+2),a  
4736 18 03			jr .pastdmark  
4738 ..			.dmark: db "CHR"  
473b f1			.pastdmark: pop af  
473c			endm  
# End of macro DMARK
473c						CALLMONITOR 
473c cd 6f ee			call debug_vector  
473f				endm  
# End of macro CALLMONITOR
473f					endif 
473f					FORTH_DSP_VALUEHL 
473f cd 7e 1d			call macro_dsp_valuehl 
4742				endm 
# End of macro FORTH_DSP_VALUEHL
4742			 
4742					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4742 cd 36 1e			call macro_forth_dsp_pop 
4745				endm 
# End of macro FORTH_DSP_POP
4745			 
4745					; save asci byte as a zero term string and push string 
4745			 
4745 7d					ld a,l 
4746 32 c1 e2				ld (scratch), a 
4749			 
4749 3e 00				ld a, 0 
474b 32 c2 e2				ld (scratch+1), a 
474e			 
474e 21 c1 e2				ld hl, scratch 
4751 cd e7 1b				call forth_push_str 
4754			 
4754			 
4754				       NEXTW 
4754 c3 34 1f			jp macro_next 
4757				endm 
# End of macro NEXTW
4757			 
4757			 
4757			 
4757			 
4757			.ENDSTR: 
4757			; eof 
4757			 
# End of file forth_words_str.asm
4757			include "forth_words_key.asm" 
4757			 
4757			; | ## Keyboard Words 
4757			 
4757			.KEY: 
4757				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4757 3e				db WORD_SYS_CORE+42             
4758 87 47			dw .WAITK            
475a 04				db 3 + 1 
475b .. 00			db "KEY",0              
475f				endm 
# End of macro CWHEAD
475f			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
475f			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
475f			; | | Can use something like this to process: 
475f			; | | > repeat active . key ?dup if emit then #1 until  
475f			 
475f					if DEBUG_FORTH_WORDS_KEY 
475f						DMARK "KEY" 
475f f5				push af  
4760 3a 74 47			ld a, (.dmark)  
4763 32 6b ee			ld (debug_mark),a  
4766 3a 75 47			ld a, (.dmark+1)  
4769 32 6c ee			ld (debug_mark+1),a  
476c 3a 76 47			ld a, (.dmark+2)  
476f 32 6d ee			ld (debug_mark+2),a  
4772 18 03			jr .pastdmark  
4774 ..			.dmark: db "KEY"  
4777 f1			.pastdmark: pop af  
4778			endm  
# End of macro DMARK
4778						CALLMONITOR 
4778 cd 6f ee			call debug_vector  
477b				endm  
# End of macro CALLMONITOR
477b					endif 
477b			; TODO currently waits 
477b cd 7c 5e				call cin 
477e					;call cin_wait 
477e 6f					ld l, a 
477f 26 00				ld h, 0 
4781 cd 79 1b				call forth_push_numhl 
4784					NEXTW 
4784 c3 34 1f			jp macro_next 
4787				endm 
# End of macro NEXTW
4787			.WAITK: 
4787				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4787 3f				db WORD_SYS_CORE+43             
4788 b9 47			dw .ACCEPT            
478a 06				db 5 + 1 
478b .. 00			db "WAITK",0              
4791				endm 
# End of macro CWHEAD
4791			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4791					if DEBUG_FORTH_WORDS_KEY 
4791						DMARK "WAI" 
4791 f5				push af  
4792 3a a6 47			ld a, (.dmark)  
4795 32 6b ee			ld (debug_mark),a  
4798 3a a7 47			ld a, (.dmark+1)  
479b 32 6c ee			ld (debug_mark+1),a  
479e 3a a8 47			ld a, (.dmark+2)  
47a1 32 6d ee			ld (debug_mark+2),a  
47a4 18 03			jr .pastdmark  
47a6 ..			.dmark: db "WAI"  
47a9 f1			.pastdmark: pop af  
47aa			endm  
# End of macro DMARK
47aa						CALLMONITOR 
47aa cd 6f ee			call debug_vector  
47ad				endm  
# End of macro CALLMONITOR
47ad					endif 
47ad cd 74 5e				call cin_wait 
47b0 6f					ld l, a 
47b1 26 00				ld h, 0 
47b3 cd 79 1b				call forth_push_numhl 
47b6					NEXTW 
47b6 c3 34 1f			jp macro_next 
47b9				endm 
# End of macro NEXTW
47b9			.ACCEPT: 
47b9				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47b9 40				db WORD_SYS_CORE+44             
47ba 17 48			dw .EDIT            
47bc 07				db 6 + 1 
47bd .. 00			db "ACCEPT",0              
47c4				endm 
# End of macro CWHEAD
47c4			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47c4					; TODO crashes on push 
47c4					if DEBUG_FORTH_WORDS_KEY 
47c4						DMARK "ACC" 
47c4 f5				push af  
47c5 3a d9 47			ld a, (.dmark)  
47c8 32 6b ee			ld (debug_mark),a  
47cb 3a da 47			ld a, (.dmark+1)  
47ce 32 6c ee			ld (debug_mark+1),a  
47d1 3a db 47			ld a, (.dmark+2)  
47d4 32 6d ee			ld (debug_mark+2),a  
47d7 18 03			jr .pastdmark  
47d9 ..			.dmark: db "ACC"  
47dc f1			.pastdmark: pop af  
47dd			endm  
# End of macro DMARK
47dd						CALLMONITOR 
47dd cd 6f ee			call debug_vector  
47e0				endm  
# End of macro CALLMONITOR
47e0					endif 
47e0 21 bf e4				ld hl, os_input 
47e3 3e 00				ld a, 0 
47e5 77					ld (hl),a 
47e6 3a 5e ea				ld a,(f_cursor_ptr) 
47e9 16 64				ld d, 100 
47eb 0e 00				ld c, 0 
47ed 1e 28				ld e, 40 
47ef cd 1f 0e				call input_str 
47f2					; TODO perhaps do a type check and wrap in quotes if not a number 
47f2 21 bf e4				ld hl, os_input 
47f5					if DEBUG_FORTH_WORDS 
47f5						DMARK "AC1" 
47f5 f5				push af  
47f6 3a 0a 48			ld a, (.dmark)  
47f9 32 6b ee			ld (debug_mark),a  
47fc 3a 0b 48			ld a, (.dmark+1)  
47ff 32 6c ee			ld (debug_mark+1),a  
4802 3a 0c 48			ld a, (.dmark+2)  
4805 32 6d ee			ld (debug_mark+2),a  
4808 18 03			jr .pastdmark  
480a ..			.dmark: db "AC1"  
480d f1			.pastdmark: pop af  
480e			endm  
# End of macro DMARK
480e						CALLMONITOR 
480e cd 6f ee			call debug_vector  
4811				endm  
# End of macro CALLMONITOR
4811					endif 
4811 cd e7 1b				call forth_push_str 
4814					NEXTW 
4814 c3 34 1f			jp macro_next 
4817				endm 
# End of macro NEXTW
4817			 
4817			.EDIT: 
4817				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4817 40				db WORD_SYS_CORE+44             
4818 b9 48			dw .DEDIT            
481a 05				db 4 + 1 
481b .. 00			db "EDIT",0              
4820				endm 
# End of macro CWHEAD
4820			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4820			 
4820					; TODO does not copy from stack 
4820					if DEBUG_FORTH_WORDS_KEY 
4820						DMARK "EDT" 
4820 f5				push af  
4821 3a 35 48			ld a, (.dmark)  
4824 32 6b ee			ld (debug_mark),a  
4827 3a 36 48			ld a, (.dmark+1)  
482a 32 6c ee			ld (debug_mark+1),a  
482d 3a 37 48			ld a, (.dmark+2)  
4830 32 6d ee			ld (debug_mark+2),a  
4833 18 03			jr .pastdmark  
4835 ..			.dmark: db "EDT"  
4838 f1			.pastdmark: pop af  
4839			endm  
# End of macro DMARK
4839						CALLMONITOR 
4839 cd 6f ee			call debug_vector  
483c				endm  
# End of macro CALLMONITOR
483c					endif 
483c			 
483c					;FORTH_DSP 
483c					FORTH_DSP_VALUEHL 
483c cd 7e 1d			call macro_dsp_valuehl 
483f				endm 
# End of macro FORTH_DSP_VALUEHL
483f			;		inc hl    ; TODO do type check 
483f			 
483f			;		call get_word_hl 
483f e5					push hl 
4840					if DEBUG_FORTH_WORDS 
4840						DMARK "EDp" 
4840 f5				push af  
4841 3a 55 48			ld a, (.dmark)  
4844 32 6b ee			ld (debug_mark),a  
4847 3a 56 48			ld a, (.dmark+1)  
484a 32 6c ee			ld (debug_mark+1),a  
484d 3a 57 48			ld a, (.dmark+2)  
4850 32 6d ee			ld (debug_mark+2),a  
4853 18 03			jr .pastdmark  
4855 ..			.dmark: db "EDp"  
4858 f1			.pastdmark: pop af  
4859			endm  
# End of macro DMARK
4859						CALLMONITOR 
4859 cd 6f ee			call debug_vector  
485c				endm  
# End of macro CALLMONITOR
485c					endif 
485c				;	ld a, 0 
485c cd 58 11				call strlenz 
485f 23					inc hl 
4860			 
4860 06 00				ld b, 0 
4862 4d					ld c, l 
4863			 
4863 e1					pop hl 
4864 11 bf e4				ld de, os_input 
4867					if DEBUG_FORTH_WORDS_KEY 
4867						DMARK "EDc" 
4867 f5				push af  
4868 3a 7c 48			ld a, (.dmark)  
486b 32 6b ee			ld (debug_mark),a  
486e 3a 7d 48			ld a, (.dmark+1)  
4871 32 6c ee			ld (debug_mark+1),a  
4874 3a 7e 48			ld a, (.dmark+2)  
4877 32 6d ee			ld (debug_mark+2),a  
487a 18 03			jr .pastdmark  
487c ..			.dmark: db "EDc"  
487f f1			.pastdmark: pop af  
4880			endm  
# End of macro DMARK
4880						CALLMONITOR 
4880 cd 6f ee			call debug_vector  
4883				endm  
# End of macro CALLMONITOR
4883					endif 
4883 ed b0				ldir 
4885			 
4885			 
4885 21 bf e4				ld hl, os_input 
4888					;ld a, 0 
4888					;ld (hl),a 
4888 3a 5e ea				ld a,(f_cursor_ptr) 
488b 16 64				ld d, 100 
488d 0e 00				ld c, 0 
488f 1e 28				ld e, 40 
4891 cd 1f 0e				call input_str 
4894					; TODO perhaps do a type check and wrap in quotes if not a number 
4894 21 bf e4				ld hl, os_input 
4897					if DEBUG_FORTH_WORDS 
4897						DMARK "ED1" 
4897 f5				push af  
4898 3a ac 48			ld a, (.dmark)  
489b 32 6b ee			ld (debug_mark),a  
489e 3a ad 48			ld a, (.dmark+1)  
48a1 32 6c ee			ld (debug_mark+1),a  
48a4 3a ae 48			ld a, (.dmark+2)  
48a7 32 6d ee			ld (debug_mark+2),a  
48aa 18 03			jr .pastdmark  
48ac ..			.dmark: db "ED1"  
48af f1			.pastdmark: pop af  
48b0			endm  
# End of macro DMARK
48b0						CALLMONITOR 
48b0 cd 6f ee			call debug_vector  
48b3				endm  
# End of macro CALLMONITOR
48b3					endif 
48b3 cd e7 1b				call forth_push_str 
48b6					NEXTW 
48b6 c3 34 1f			jp macro_next 
48b9				endm 
# End of macro NEXTW
48b9			 
48b9			.DEDIT: 
48b9				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
48b9 40				db WORD_SYS_CORE+44             
48ba 1b 49			dw .ENDKEY            
48bc 06				db 5 + 1 
48bd .. 00			db "DEDIT",0              
48c3				endm 
# End of macro CWHEAD
48c3			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
48c3			 
48c3					; TODO does not copy from stack 
48c3					if DEBUG_FORTH_WORDS_KEY 
48c3						DMARK "DED" 
48c3 f5				push af  
48c4 3a d8 48			ld a, (.dmark)  
48c7 32 6b ee			ld (debug_mark),a  
48ca 3a d9 48			ld a, (.dmark+1)  
48cd 32 6c ee			ld (debug_mark+1),a  
48d0 3a da 48			ld a, (.dmark+2)  
48d3 32 6d ee			ld (debug_mark+2),a  
48d6 18 03			jr .pastdmark  
48d8 ..			.dmark: db "DED"  
48db f1			.pastdmark: pop af  
48dc			endm  
# End of macro DMARK
48dc						CALLMONITOR 
48dc cd 6f ee			call debug_vector  
48df				endm  
# End of macro CALLMONITOR
48df					endif 
48df			 
48df					;FORTH_DSP 
48df					FORTH_DSP_VALUEHL 
48df cd 7e 1d			call macro_dsp_valuehl 
48e2				endm 
# End of macro FORTH_DSP_VALUEHL
48e2			;		inc hl    ; TODO do type check 
48e2			 
48e2			;		call get_word_hl 
48e2 e5					push hl 
48e3 e5					push hl 
48e4					FORTH_DSP_POP 
48e4 cd 36 1e			call macro_forth_dsp_pop 
48e7				endm 
# End of macro FORTH_DSP_POP
48e7 e1					pop hl 
48e8					if DEBUG_FORTH_WORDS 
48e8						DMARK "EDp" 
48e8 f5				push af  
48e9 3a fd 48			ld a, (.dmark)  
48ec 32 6b ee			ld (debug_mark),a  
48ef 3a fe 48			ld a, (.dmark+1)  
48f2 32 6c ee			ld (debug_mark+1),a  
48f5 3a ff 48			ld a, (.dmark+2)  
48f8 32 6d ee			ld (debug_mark+2),a  
48fb 18 03			jr .pastdmark  
48fd ..			.dmark: db "EDp"  
4900 f1			.pastdmark: pop af  
4901			endm  
# End of macro DMARK
4901						CALLMONITOR 
4901 cd 6f ee			call debug_vector  
4904				endm  
# End of macro CALLMONITOR
4904					endif 
4904				;	ld a, 0 
4904 cd 58 11				call strlenz 
4907 23					inc hl 
4908			 
4908 06 00				ld b, 0 
490a 4d					ld c, l 
490b			 
490b e1					pop hl 
490c			 
490c					;ld a, 0 
490c					;ld (hl),a 
490c 3a 5e ea				ld a,(f_cursor_ptr) 
490f 16 64				ld d, 100 
4911 0e 00				ld c, 0 
4913 1e 28				ld e, 40 
4915 cd 1f 0e				call input_str 
4918					; TODO perhaps do a type check and wrap in quotes if not a number 
4918					NEXTW 
4918 c3 34 1f			jp macro_next 
491b				endm 
# End of macro NEXTW
491b			 
491b			 
491b			.ENDKEY: 
491b			; eof 
491b			 
# End of file forth_words_key.asm
491b			include "forth_words_const.asm" 
491b			 
491b			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
491b			 
491b			 
491b			.SPITIME: 
491b				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
491b 77				db WORD_SYS_CORE+99             
491c 30 49			dw .VA            
491e 08				db 7 + 1 
491f .. 00			db "SPITIME",0              
4927				endm 
# End of macro CWHEAD
4927			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4927			; 
4927			; | | If using BANK devices then leave as is. 
4927			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4927			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4927			 
4927 21 64 ea				ld hl, spi_clktime  
492a cd 79 1b				call forth_push_numhl 
492d			 
492d					NEXTW 
492d c3 34 1f			jp macro_next 
4930				endm 
# End of macro NEXTW
4930			 
4930			 
4930			.VA: 
4930				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4930 77				db WORD_SYS_CORE+99             
4931 40 49			dw .SYMBOL            
4933 03				db 2 + 1 
4934 .. 00			db "VA",0              
4937				endm 
# End of macro CWHEAD
4937			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4937 21 28 ea				ld hl, cli_var_array 
493a cd 79 1b				call forth_push_numhl 
493d			 
493d					NEXTW 
493d c3 34 1f			jp macro_next 
4940				endm 
# End of macro NEXTW
4940			 
4940			.SYMBOL: 
4940				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4940 77				db WORD_SYS_CORE+99             
4941 4a 4a			dw .ENDCONST            
4943 07				db 6 + 1 
4944 .. 00			db "SYMBOL",0              
494b				endm 
# End of macro CWHEAD
494b			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
494b			; | 
494b			; | | The value is the number reference and the final address is pushed to stack 
494b			 
494b			; | | ``` 
494b			; | | dw sym_table 
494b			; | | dw nmi_vector 
494b			; | | dw cli_autodisplay 
494b			; | | dw cli_data_sp 
494b			; | | dw cli_data_stack 
494b			; | | dw cli_loop_sp 
494b			; | | dw cli_loop_stack 
494b			; | | dw cli_var_array 
494b			; | | dw cursor_col 
494b			; | | dw cursor_ptr 
494b			; | | ; 10 
494b			; | | dw cursor_row 
494b			; | | dw debug_mark 
494b			; | | dw display_fb0 
494b			; | | dw display_fb1 
494b			; | | dw display_fb2 
494b			; | | dw display_fb3 
494b			; | | dw display_fb_active 
494b			; | | dw execscratch 
494b			; | | dw f_cursor_ptr 
494b			; | | dw hardware_word 
494b			; | | ;20 
494b			; | | dw input_at_cursor 
494b			; | | dw input_at_pos 
494b			; | | dw input_cur_flash 
494b			; | | dw input_cur_onoff 
494b			; | | dw input_cursor 
494b			; | | dw input_display_size 
494b			; | | dw input_len 
494b			; | | dw input_ptr 
494b			; | | dw input_size 
494b			; | | dw input_start 
494b			; | | ; 30 
494b			; | | dw input_str 
494b			; | | dw input_under_cursor 
494b			; | | dw os_cli_cmd 
494b			; | | dw os_cur_ptr 
494b			; | | dw os_current_i 
494b			; | | dw os_input 
494b			; | | dw os_last_cmd 
494b			; | | dw os_last_new_uword 
494b			; | | dw debug_vector 
494b			; | | dw os_view_hl 
494b			; | | ;40 
494b			; | | dw os_word_scratch 
494b			; | | dw portbctl 
494b			; | | dw portbdata 
494b			; | | dw spi_cartdev 
494b			; | | dw spi_cartdev2 
494b			; | | dw spi_clktime 
494b			; | | dw spi_device 
494b			; | | dw spi_device_id 
494b			; | | dw spi_portbyte 
494b			; | | dw stackstore 
494b			; | | ; 50 
494b			; | | if STORAGE_SE 
494b			; | | dw storage_actl 
494b			; | | dw storage_adata 
494b			; | | else 
494b			; | | dw 0 
494b			; | | dw 0 
494b			; | | endif 
494b			; | | dw storage_append 
494b			; | | if STORAGE_SE 
494b			; | | dw storage_bctl 
494b			; | | else 
494b			; | | dw 0 
494b			; | | endif 
494b			; | | dw store_bank_active 
494b			; | | dw store_filecache 
494b			; | | dw store_longread 
494b			; | | dw store_openaddr 
494b			; | | dw store_openext 
494b			; | | dw store_openmaxext 
494b			; | | ; 60 
494b			; | | dw store_page 
494b			; | | dw store_readbuf 
494b			; | | dw store_readcont 
494b			; | | dw store_readptr 
494b			; | | dw store_tmpext 
494b			; | | dw store_tmpid 
494b			; | | dw store_tmppageid 
494b			; | | dw malloc 
494b			; | | dw free 
494b			; | | dw cin 
494b			; | | ; 70 
494b			; | | dw cin_wait 
494b			; | | dw forth_push_numhl 
494b			; | | dw forth_push_str 
494b			; | | ``` 
494b			 
494b					if DEBUG_FORTH_WORDS_KEY 
494b						DMARK "SYM" 
494b f5				push af  
494c 3a 60 49			ld a, (.dmark)  
494f 32 6b ee			ld (debug_mark),a  
4952 3a 61 49			ld a, (.dmark+1)  
4955 32 6c ee			ld (debug_mark+1),a  
4958 3a 62 49			ld a, (.dmark+2)  
495b 32 6d ee			ld (debug_mark+2),a  
495e 18 03			jr .pastdmark  
4960 ..			.dmark: db "SYM"  
4963 f1			.pastdmark: pop af  
4964			endm  
# End of macro DMARK
4964						CALLMONITOR 
4964 cd 6f ee			call debug_vector  
4967				endm  
# End of macro CALLMONITOR
4967					endif 
4967			 
4967					FORTH_DSP_VALUEHL 
4967 cd 7e 1d			call macro_dsp_valuehl 
496a				endm 
# End of macro FORTH_DSP_VALUEHL
496a			 
496a 7d					ld a, l     
496b			 
496b			 
496b					if DEBUG_FORTH_WORDS 
496b						DMARK "SY1" 
496b f5				push af  
496c 3a 80 49			ld a, (.dmark)  
496f 32 6b ee			ld (debug_mark),a  
4972 3a 81 49			ld a, (.dmark+1)  
4975 32 6c ee			ld (debug_mark+1),a  
4978 3a 82 49			ld a, (.dmark+2)  
497b 32 6d ee			ld (debug_mark+2),a  
497e 18 03			jr .pastdmark  
4980 ..			.dmark: db "SY1"  
4983 f1			.pastdmark: pop af  
4984			endm  
# End of macro DMARK
4984						CALLMONITOR 
4984 cd 6f ee			call debug_vector  
4987				endm  
# End of macro CALLMONITOR
4987					endif 
4987					 
4987 f5					push af	 
4988					FORTH_DSP_POP 
4988 cd 36 1e			call macro_forth_dsp_pop 
498b				endm 
# End of macro FORTH_DSP_POP
498b f1					pop af 
498c			 
498c cb 27				sla a  
498e				 
498e					 
498e					if DEBUG_FORTH_WORDS 
498e						DMARK "SY" 
498e f5				push af  
498f 3a a3 49			ld a, (.dmark)  
4992 32 6b ee			ld (debug_mark),a  
4995 3a a4 49			ld a, (.dmark+1)  
4998 32 6c ee			ld (debug_mark+1),a  
499b 3a a5 49			ld a, (.dmark+2)  
499e 32 6d ee			ld (debug_mark+2),a  
49a1 18 02			jr .pastdmark  
49a3 ..			.dmark: db "SY"  
49a5 f1			.pastdmark: pop af  
49a6			endm  
# End of macro DMARK
49a6						CALLMONITOR 
49a6 cd 6f ee			call debug_vector  
49a9				endm  
# End of macro CALLMONITOR
49a9					endif 
49a9			 
49a9 21 b8 49				ld hl, sym_table 
49ac cd f2 0d				call addatohl 
49af cd b6 1e				call loadwordinhl 
49b2 cd 79 1b				call forth_push_numhl 
49b5			 
49b5			 
49b5				       NEXTW 
49b5 c3 34 1f			jp macro_next 
49b8				endm 
# End of macro NEXTW
49b8			 
49b8			sym_table: 
49b8			 
49b8			; 0 
49b8 b8 49		dw sym_table 
49ba 72 ee		dw nmi_vector 
49bc 3c ea		dw cli_autodisplay 
49be ee e9		dw cli_data_sp 
49c0 28 e8		dw cli_data_stack 
49c2 f0 e9		dw cli_loop_sp 
49c4 2a e9		dw cli_loop_stack 
49c6 28 ea		dw cli_var_array 
49c8 c5 eb		dw cursor_col 
49ca c3 eb		dw cursor_ptr 
49cc			; 10 
49cc c4 eb		dw cursor_row 
49ce 6b ee		dw debug_mark 
49d0 b1 ed		dw display_fb0 
49d2 10 ed		dw display_fb1 
49d4 ce eb		dw display_fb2 
49d6 6f ec		dw display_fb3 
49d8 cc eb		dw display_fb_active 
49da c0 e3		dw execscratch 
49dc 5e ea		dw f_cursor_ptr 
49de 75 ee		dw hardware_word 
49e0			;20 
49e0 62 ee		dw input_at_cursor 
49e2 64 ee		dw input_at_pos 
49e4 60 ee		dw input_cur_flash 
49e6 5f ee		dw input_cur_onoff 
49e8 55 ee		dw input_cursor 
49ea 65 ee		dw input_display_size 
49ec 5a ee		dw input_len 
49ee 69 ee		dw input_ptr 
49f0 66 ee		dw input_size 
49f2 67 ee		dw input_start 
49f4			; 30 
49f4 1f 0e		dw input_str 
49f6 63 ee		dw input_under_cursor 
49f8 e8 e5		dw os_cli_cmd 
49fa e4 e5		dw os_cur_ptr 
49fc e6 e5		dw os_current_i 
49fe bf e4		dw os_input 
4a00 e7 e6		dw os_last_cmd 
4a02 be e5		dw os_last_new_uword 
4a04 6f ee		dw debug_vector 
4a06 a3 e2		dw os_view_hl 
4a08			;40 
4a08 c6 e5		dw os_word_scratch 
4a0a c3 00		dw portbctl 
4a0c c1 00		dw portbdata 
4a0e 63 ea		dw spi_cartdev 
4a10 62 ea		dw spi_cartdev2 
4a12 64 ea		dw spi_clktime 
4a14 60 ea		dw spi_device 
4a16 5f ea		dw spi_device_id 
4a18 61 ea		dw spi_portbyte 
4a1a a7 eb		dw stackstore 
4a1c			; 50 
4a1c			if STORAGE_SE 
4a1c			dw storage_actl 
4a1c			dw storage_adata 
4a1c			else 
4a1c 00 00		dw 0 
4a1e 00 00		dw 0 
4a20			endif 
4a20 74 09		dw storage_append 
4a22			if STORAGE_SE 
4a22			dw storage_bctl 
4a22			else 
4a22 00 00		dw 0 
4a24			endif 
4a24 93 eb		dw store_bank_active 
4a26 67 ea		dw store_filecache 
4a28 75 ea		dw store_longread 
4a2a 6b ea		dw store_openaddr 
4a2c 6a ea		dw store_openext 
4a2e 69 ea		dw store_openmaxext 
4a30			; 60 
4a30 7a ea		dw store_page 
4a32 76 ea		dw store_readbuf 
4a34 6d ea		dw store_readcont 
4a36 78 ea		dw store_readptr 
4a38 6d ea		dw store_tmpext 
4a3a 6e ea		dw store_tmpid 
4a3c 65 ea		dw store_tmppageid 
4a3e cd 11		dw malloc 
4a40 97 12		dw free 
4a42 7c 5e		dw cin 
4a44			; 70 
4a44 74 5e		dw cin_wait 
4a46 79 1b		dw forth_push_numhl 
4a48 e7 1b		dw forth_push_str 
4a4a			 
4a4a			 
4a4a			.ENDCONST: 
4a4a			 
4a4a			; eof 
4a4a			 
4a4a			 
# End of file forth_words_const.asm
4a4a			 
4a4a			if STORAGE_SE 
4a4a			   	include "forth_words_storage.asm" 
4a4a			endif 
4a4a				include "forth_words_device.asm" 
4a4a			; Device related words 
4a4a			 
4a4a			; | ## Device Words 
4a4a			 
4a4a			;if SOUND_ENABLE 
4a4a			;.NOTE: 
4a4a			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a4a			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
4a4a			;		if DEBUG_FORTH_WORDS_KEY 
4a4a			;			DMARK "NTE" 
4a4a			;			CALLMONITOR 
4a4a			;		endif 
4a4a			; 
4a4a			;	 
4a4a			; 
4a4a			;		NEXTW 
4a4a			;.AFTERSOUND: 
4a4a			;endif 
4a4a			 
4a4a			 
4a4a			USE_GPIO: equ 0 
4a4a			 
4a4a			if USE_GPIO 
4a4a			.GP1: 
4a4a				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a4a			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
4a4a					NEXTW 
4a4a			.GP2: 
4a4a				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a4a			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
4a4a			 
4a4a					NEXTW 
4a4a			 
4a4a			.GP3: 
4a4a				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a4a			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
4a4a			 
4a4a					NEXTW 
4a4a			 
4a4a			.GP4: 
4a4a				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a4a			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
4a4a			 
4a4a					NEXTW 
4a4a			.SIN: 
4a4a			 
4a4a			 
4a4a			endif 
4a4a			 
4a4a			 
4a4a				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a4a 33				db WORD_SYS_CORE+31             
4a4b 7f 4a			dw .SOUT            
4a4d 03				db 2 + 1 
4a4e .. 00			db "IN",0              
4a51				endm 
# End of macro CWHEAD
4a51			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a51					if DEBUG_FORTH_WORDS_KEY 
4a51						DMARK "IN." 
4a51 f5				push af  
4a52 3a 66 4a			ld a, (.dmark)  
4a55 32 6b ee			ld (debug_mark),a  
4a58 3a 67 4a			ld a, (.dmark+1)  
4a5b 32 6c ee			ld (debug_mark+1),a  
4a5e 3a 68 4a			ld a, (.dmark+2)  
4a61 32 6d ee			ld (debug_mark+2),a  
4a64 18 03			jr .pastdmark  
4a66 ..			.dmark: db "IN."  
4a69 f1			.pastdmark: pop af  
4a6a			endm  
# End of macro DMARK
4a6a						CALLMONITOR 
4a6a cd 6f ee			call debug_vector  
4a6d				endm  
# End of macro CALLMONITOR
4a6d					endif 
4a6d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a6d cd 7e 1d			call macro_dsp_valuehl 
4a70				endm 
# End of macro FORTH_DSP_VALUEHL
4a70			 
4a70 e5					push hl 
4a71			 
4a71					; destroy value TOS 
4a71			 
4a71					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a71 cd 36 1e			call macro_forth_dsp_pop 
4a74				endm 
# End of macro FORTH_DSP_POP
4a74			 
4a74					; one value on hl get other one back 
4a74			 
4a74 c1					pop bc 
4a75			 
4a75					; do the sub 
4a75			;		ex de, hl 
4a75			 
4a75 ed 68				in l,(c) 
4a77			 
4a77					; save it 
4a77			 
4a77 26 00				ld h,0 
4a79			 
4a79					; TODO push value back onto stack for another op etc 
4a79			 
4a79 cd 79 1b				call forth_push_numhl 
4a7c					NEXTW 
4a7c c3 34 1f			jp macro_next 
4a7f				endm 
# End of macro NEXTW
4a7f			.SOUT: 
4a7f				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4a7f 34				db WORD_SYS_CORE+32             
4a80 d2 4a			dw .SPIO            
4a82 04				db 3 + 1 
4a83 .. 00			db "OUT",0              
4a87				endm 
# End of macro CWHEAD
4a87			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4a87					if DEBUG_FORTH_WORDS_KEY 
4a87						DMARK "OUT" 
4a87 f5				push af  
4a88 3a 9c 4a			ld a, (.dmark)  
4a8b 32 6b ee			ld (debug_mark),a  
4a8e 3a 9d 4a			ld a, (.dmark+1)  
4a91 32 6c ee			ld (debug_mark+1),a  
4a94 3a 9e 4a			ld a, (.dmark+2)  
4a97 32 6d ee			ld (debug_mark+2),a  
4a9a 18 03			jr .pastdmark  
4a9c ..			.dmark: db "OUT"  
4a9f f1			.pastdmark: pop af  
4aa0			endm  
# End of macro DMARK
4aa0						CALLMONITOR 
4aa0 cd 6f ee			call debug_vector  
4aa3				endm  
# End of macro CALLMONITOR
4aa3					endif 
4aa3			 
4aa3					; get port 
4aa3			 
4aa3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aa3 cd 7e 1d			call macro_dsp_valuehl 
4aa6				endm 
# End of macro FORTH_DSP_VALUEHL
4aa6			 
4aa6 e5					push hl 
4aa7			 
4aa7					; destroy value TOS 
4aa7			 
4aa7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aa7 cd 36 1e			call macro_forth_dsp_pop 
4aaa				endm 
# End of macro FORTH_DSP_POP
4aaa			 
4aaa					; get byte to send 
4aaa			 
4aaa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aaa cd 7e 1d			call macro_dsp_valuehl 
4aad				endm 
# End of macro FORTH_DSP_VALUEHL
4aad			 
4aad			;		push hl 
4aad			 
4aad					; destroy value TOS 
4aad			 
4aad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aad cd 36 1e			call macro_forth_dsp_pop 
4ab0				endm 
# End of macro FORTH_DSP_POP
4ab0			 
4ab0					; one value on hl get other one back 
4ab0			 
4ab0			;		pop hl 
4ab0			 
4ab0 c1					pop bc 
4ab1			 
4ab1					if DEBUG_FORTH_WORDS 
4ab1						DMARK "OUT" 
4ab1 f5				push af  
4ab2 3a c6 4a			ld a, (.dmark)  
4ab5 32 6b ee			ld (debug_mark),a  
4ab8 3a c7 4a			ld a, (.dmark+1)  
4abb 32 6c ee			ld (debug_mark+1),a  
4abe 3a c8 4a			ld a, (.dmark+2)  
4ac1 32 6d ee			ld (debug_mark+2),a  
4ac4 18 03			jr .pastdmark  
4ac6 ..			.dmark: db "OUT"  
4ac9 f1			.pastdmark: pop af  
4aca			endm  
# End of macro DMARK
4aca						CALLMONITOR 
4aca cd 6f ee			call debug_vector  
4acd				endm  
# End of macro CALLMONITOR
4acd					endif 
4acd			 
4acd ed 69				out (c), l 
4acf			 
4acf					NEXTW 
4acf c3 34 1f			jp macro_next 
4ad2				endm 
# End of macro NEXTW
4ad2			 
4ad2			 
4ad2			.SPIO: 
4ad2			 
4ad2			if STORAGE_SE 
4ad2				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4ad2			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4ad2			 
4ad2					call spi_ce_low 
4ad2			    NEXTW 
4ad2			 
4ad2			.SPICEH: 
4ad2				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ad2			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4ad2			 
4ad2					call spi_ce_high 
4ad2			    NEXTW 
4ad2			 
4ad2			 
4ad2			.SPIOb: 
4ad2			 
4ad2				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4ad2			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4ad2			 
4ad2					if DEBUG_FORTH_WORDS_KEY 
4ad2						DMARK "SPo" 
4ad2						CALLMONITOR 
4ad2					endif 
4ad2					; get port 
4ad2			 
4ad2			 
4ad2					; get byte to send 
4ad2			 
4ad2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ad2			 
4ad2			;		push hl    ; u1  
4ad2			 
4ad2					; destroy value TOS 
4ad2			 
4ad2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ad2			 
4ad2					; one value on hl get other one back 
4ad2			 
4ad2			;		pop hl   ; u2 - addr 
4ad2			 
4ad2					; TODO Send SPI byte 
4ad2			 
4ad2			;		push hl 
4ad2			;		call spi_ce_low 
4ad2			;		pop hl 
4ad2					ld a, l 
4ad2					call spi_send_byte 
4ad2			;		call spi_ce_high 
4ad2			 
4ad2					NEXTW 
4ad2			 
4ad2			.SPII: 
4ad2				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4ad2			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4ad2					if DEBUG_FORTH_WORDS_KEY 
4ad2						DMARK "SPi" 
4ad2						CALLMONITOR 
4ad2					endif 
4ad2			 
4ad2					; TODO Get SPI byte 
4ad2			 
4ad2					call spi_read_byte 
4ad2			 
4ad2					if DEBUG_FORTH_WORDS 
4ad2						DMARK "Si2" 
4ad2						CALLMONITOR 
4ad2					endif 
4ad2					ld h, 0 
4ad2					ld l, a 
4ad2					if DEBUG_FORTH_WORDS 
4ad2						DMARK "Si3" 
4ad2						CALLMONITOR 
4ad2					endif 
4ad2					call forth_push_numhl 
4ad2			 
4ad2					NEXTW 
4ad2			 
4ad2			 
4ad2			 
4ad2			.SESEL: 
4ad2				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4ad2			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4ad2					if DEBUG_FORTH_WORDS_KEY 
4ad2						DMARK "BNK" 
4ad2						CALLMONITOR 
4ad2					endif 
4ad2			 
4ad2					ld a, 255 
4ad2					ld (spi_cartdev), a 
4ad2			 
4ad2					; get bank 
4ad2			 
4ad2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ad2			 
4ad2			;		push hl 
4ad2			 
4ad2					; destroy value TOS 
4ad2			 
4ad2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ad2			 
4ad2					; one value on hl get other one back 
4ad2			 
4ad2			;		pop hl 
4ad2			 
4ad2			 
4ad2					ld c, SPI_CE_HIGH 
4ad2					ld b, '0'    ; human readable bank number 
4ad2			 
4ad2					ld a, l 
4ad2			 
4ad2					if DEBUG_FORTH_WORDS 
4ad2						DMARK "BNK" 
4ad2						CALLMONITOR 
4ad2					endif 
4ad2			 
4ad2					; active low 
4ad2			 
4ad2					cp 0 
4ad2					jr z, .bset 
4ad2					cp 1 
4ad2					jr nz, .b2 
4ad2					res 0, c 
4ad2					ld b, '1'    ; human readable bank number 
4ad2			.b2:		cp 2 
4ad2					jr nz, .b3 
4ad2					res 1, c 
4ad2					ld b, '2'    ; human readable bank number 
4ad2			.b3:		cp 3 
4ad2					jr nz, .b4 
4ad2					res 2, c 
4ad2					ld b, '3'    ; human readable bank number 
4ad2			.b4:		cp 4 
4ad2					jr nz, .b5 
4ad2					res 3, c 
4ad2					ld b, '4'    ; human readable bank number 
4ad2			.b5:		cp 5 
4ad2					jr nz, .bset 
4ad2					res 4, c 
4ad2					ld b, '5'    ; human readable bank number 
4ad2			 
4ad2			.bset: 
4ad2					ld a, c 
4ad2					ld (spi_device),a 
4ad2					ld a, b 
4ad2					ld (spi_device_id),a 
4ad2					if DEBUG_FORTH_WORDS 
4ad2						DMARK "BN2" 
4ad2						CALLMONITOR 
4ad2					endif 
4ad2			 
4ad2					; set default SPI clk pulse time as disabled for BANK use 
4ad2			 
4ad2					ld a, 0 
4ad2					ld (spi_clktime), a 
4ad2			 
4ad2					NEXTW 
4ad2			 
4ad2			.CARTDEV: 
4ad2				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4ad2			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4ad2					if DEBUG_FORTH_WORDS_KEY 
4ad2						DMARK "CDV" 
4ad2						CALLMONITOR 
4ad2					endif 
4ad2			 
4ad2					; disable se storage bank selection 
4ad2			 
4ad2					ld a, SPI_CE_HIGH		; ce high 
4ad2					ld (spi_device), a 
4ad2			 
4ad2					; get bank 
4ad2			 
4ad2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ad2			 
4ad2			;		push hl 
4ad2			 
4ad2					; destroy value TOS 
4ad2			 
4ad2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ad2			 
4ad2					; one value on hl get other one back 
4ad2			 
4ad2			;		pop hl 
4ad2			 
4ad2					; active low 
4ad2			 
4ad2					ld c, 255 
4ad2			 
4ad2					ld a, l 
4ad2					if DEBUG_FORTH_WORDS 
4ad2						DMARK "CDV" 
4ad2						CALLMONITOR 
4ad2					endif 
4ad2					cp 0 
4ad2					jr z, .cset 
4ad2					cp 1 
4ad2					jr nz, .c2 
4ad2					res 0, c 
4ad2			.c2:		cp 2 
4ad2					jr nz, .c3 
4ad2					res 1, c 
4ad2			.c3:		cp 3 
4ad2					jr nz, .c4 
4ad2					res 2, c 
4ad2			.c4:		cp 4 
4ad2					jr nz, .c5 
4ad2					res 3, c 
4ad2			.c5:		cp 5 
4ad2					jr nz, .c6 
4ad2					res 4, c 
4ad2			.c6:		cp 6 
4ad2					jr nz, .c7 
4ad2					res 5, c 
4ad2			.c7:		cp 7 
4ad2					jr nz, .c8 
4ad2					res 6, c 
4ad2			.c8:		cp 8 
4ad2					jr nz, .cset 
4ad2					res 7, c 
4ad2			.cset:		ld a, c 
4ad2					ld (spi_cartdev),a 
4ad2			 
4ad2					if DEBUG_FORTH_WORDS 
4ad2						DMARK "CD2" 
4ad2						CALLMONITOR 
4ad2					endif 
4ad2			 
4ad2					; set default SPI clk pulse time as 10ms for CARTDEV use 
4ad2			 
4ad2					ld a, $0a 
4ad2					ld (spi_clktime), a 
4ad2					NEXTW 
4ad2			endif 
4ad2			 
4ad2			.ENDDEVICE: 
4ad2			; eof 
4ad2			 
# End of file forth_words_device.asm
4ad2			 
4ad2			; var handler 
4ad2			 
4ad2			 
4ad2			.VARS: 
4ad2				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4ad2 77				db WORD_SYS_CORE+99             
4ad3 83 4b			dw .V0            
4ad5 04				db 3 + 1 
4ad6 .. 00			db "VAR",0              
4ada				endm 
# End of macro CWHEAD
4ada			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4ada			;| 
4ada			;| The variable name should consist of a single letter. e.g. "a" 
4ada			;! If a full string is passed then only the first char is looked at 
4ada			;| Any other char could exceed bounds checks!  
4ada			 
4ada					if DEBUG_FORTH_WORDS_KEY 
4ada						DMARK "VAR" 
4ada f5				push af  
4adb 3a ef 4a			ld a, (.dmark)  
4ade 32 6b ee			ld (debug_mark),a  
4ae1 3a f0 4a			ld a, (.dmark+1)  
4ae4 32 6c ee			ld (debug_mark+1),a  
4ae7 3a f1 4a			ld a, (.dmark+2)  
4aea 32 6d ee			ld (debug_mark+2),a  
4aed 18 03			jr .pastdmark  
4aef ..			.dmark: db "VAR"  
4af2 f1			.pastdmark: pop af  
4af3			endm  
# End of macro DMARK
4af3						CALLMONITOR 
4af3 cd 6f ee			call debug_vector  
4af6				endm  
# End of macro CALLMONITOR
4af6					endif 
4af6			 
4af6					FORTH_DSP_VALUEHL 
4af6 cd 7e 1d			call macro_dsp_valuehl 
4af9				endm 
# End of macro FORTH_DSP_VALUEHL
4af9			 
4af9 7e					ld a, (hl)    ; get first char on of the string 
4afa			 
4afa			 
4afa					if DEBUG_FORTH_WORDS 
4afa						DMARK "VR1" 
4afa f5				push af  
4afb 3a 0f 4b			ld a, (.dmark)  
4afe 32 6b ee			ld (debug_mark),a  
4b01 3a 10 4b			ld a, (.dmark+1)  
4b04 32 6c ee			ld (debug_mark+1),a  
4b07 3a 11 4b			ld a, (.dmark+2)  
4b0a 32 6d ee			ld (debug_mark+2),a  
4b0d 18 03			jr .pastdmark  
4b0f ..			.dmark: db "VR1"  
4b12 f1			.pastdmark: pop af  
4b13			endm  
# End of macro DMARK
4b13						CALLMONITOR 
4b13 cd 6f ee			call debug_vector  
4b16				endm  
# End of macro CALLMONITOR
4b16					endif 
4b16					 
4b16 f5					push af	 
4b17					FORTH_DSP_POP 
4b17 cd 36 1e			call macro_forth_dsp_pop 
4b1a				endm 
# End of macro FORTH_DSP_POP
4b1a f1					pop af 
4b1b			 
4b1b					; convert to upper 
4b1b			 
4b1b cd 67 10				call to_upper 
4b1e					if DEBUG_FORTH_WORDS 
4b1e						DMARK "Vaa" 
4b1e f5				push af  
4b1f 3a 33 4b			ld a, (.dmark)  
4b22 32 6b ee			ld (debug_mark),a  
4b25 3a 34 4b			ld a, (.dmark+1)  
4b28 32 6c ee			ld (debug_mark+1),a  
4b2b 3a 35 4b			ld a, (.dmark+2)  
4b2e 32 6d ee			ld (debug_mark+2),a  
4b31 18 03			jr .pastdmark  
4b33 ..			.dmark: db "Vaa"  
4b36 f1			.pastdmark: pop af  
4b37			endm  
# End of macro DMARK
4b37						CALLMONITOR 
4b37 cd 6f ee			call debug_vector  
4b3a				endm  
# End of macro CALLMONITOR
4b3a					endif 
4b3a 06 41				ld b, 'A' 
4b3c 90					sub b			; set offset 
4b3d					if DEBUG_FORTH_WORDS 
4b3d						DMARK "Vbb" 
4b3d f5				push af  
4b3e 3a 52 4b			ld a, (.dmark)  
4b41 32 6b ee			ld (debug_mark),a  
4b44 3a 53 4b			ld a, (.dmark+1)  
4b47 32 6c ee			ld (debug_mark+1),a  
4b4a 3a 54 4b			ld a, (.dmark+2)  
4b4d 32 6d ee			ld (debug_mark+2),a  
4b50 18 03			jr .pastdmark  
4b52 ..			.dmark: db "Vbb"  
4b55 f1			.pastdmark: pop af  
4b56			endm  
# End of macro DMARK
4b56						CALLMONITOR 
4b56 cd 6f ee			call debug_vector  
4b59				endm  
# End of macro CALLMONITOR
4b59					endif 
4b59 cb 27				sla a  
4b5b				 
4b5b					 
4b5b					if DEBUG_FORTH_WORDS 
4b5b						DMARK "VR2" 
4b5b f5				push af  
4b5c 3a 70 4b			ld a, (.dmark)  
4b5f 32 6b ee			ld (debug_mark),a  
4b62 3a 71 4b			ld a, (.dmark+1)  
4b65 32 6c ee			ld (debug_mark+1),a  
4b68 3a 72 4b			ld a, (.dmark+2)  
4b6b 32 6d ee			ld (debug_mark+2),a  
4b6e 18 03			jr .pastdmark  
4b70 ..			.dmark: db "VR2"  
4b73 f1			.pastdmark: pop af  
4b74			endm  
# End of macro DMARK
4b74						CALLMONITOR 
4b74 cd 6f ee			call debug_vector  
4b77				endm  
# End of macro CALLMONITOR
4b77					endif 
4b77			 
4b77 21 f4 e9				ld hl, cli_var_array2 
4b7a cd f2 0d				call addatohl 
4b7d cd 79 1b				call forth_push_numhl 
4b80			 
4b80			 
4b80				       NEXTW 
4b80 c3 34 1f			jp macro_next 
4b83				endm 
# End of macro NEXTW
4b83			.V0: 
4b83				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4b83 78				db WORD_SYS_CORE+100             
4b84 9b 4b			dw .V0Q            
4b86 04				db 3 + 1 
4b87 .. 00			db "V0!",0              
4b8b				endm 
# End of macro CWHEAD
4b8b			;| V0! ( u1 -- )  Store value to v0  | DONE 
4b8b			 
4b8b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b8b cd 7e 1d			call macro_dsp_valuehl 
4b8e				endm 
# End of macro FORTH_DSP_VALUEHL
4b8e			 
4b8e 11 28 ea				ld de, cli_var_array 
4b91			 
4b91 eb					ex de, hl 
4b92 73					ld (hl), e 
4b93 23					inc hl 
4b94 72					ld (hl), d 
4b95			 
4b95					; destroy value TOS 
4b95			 
4b95					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b95 cd 36 1e			call macro_forth_dsp_pop 
4b98				endm 
# End of macro FORTH_DSP_POP
4b98			 
4b98				       NEXTW 
4b98 c3 34 1f			jp macro_next 
4b9b				endm 
# End of macro NEXTW
4b9b			.V0Q: 
4b9b				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4b9b 79				db WORD_SYS_CORE+101             
4b9c ac 4b			dw .V1S            
4b9e 04				db 3 + 1 
4b9f .. 00			db "V0@",0              
4ba3				endm 
# End of macro CWHEAD
4ba3			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4ba3 2a 28 ea				ld hl, (cli_var_array) 
4ba6 cd 79 1b				call forth_push_numhl 
4ba9			 
4ba9				       NEXTW 
4ba9 c3 34 1f			jp macro_next 
4bac				endm 
# End of macro NEXTW
4bac			.V1S: 
4bac				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4bac 7a				db WORD_SYS_CORE+102             
4bad c4 4b			dw .V1Q            
4baf 04				db 3 + 1 
4bb0 .. 00			db "V1!",0              
4bb4				endm 
# End of macro CWHEAD
4bb4			;| V1! ( u1 -- )  Store value to v1 | DONE 
4bb4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bb4 cd 7e 1d			call macro_dsp_valuehl 
4bb7				endm 
# End of macro FORTH_DSP_VALUEHL
4bb7			 
4bb7 11 2a ea				ld de, cli_var_array+2 
4bba				 
4bba eb					ex de, hl 
4bbb 73					ld (hl), e 
4bbc 23					inc hl 
4bbd 72					ld (hl), d 
4bbe			 
4bbe					; destroy value TOS 
4bbe			 
4bbe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bbe cd 36 1e			call macro_forth_dsp_pop 
4bc1				endm 
# End of macro FORTH_DSP_POP
4bc1				       NEXTW 
4bc1 c3 34 1f			jp macro_next 
4bc4				endm 
# End of macro NEXTW
4bc4			.V1Q: 
4bc4				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4bc4 7b				db WORD_SYS_CORE+103             
4bc5 d5 4b			dw .V2S            
4bc7 04				db 3 + 1 
4bc8 .. 00			db "V1@",0              
4bcc				endm 
# End of macro CWHEAD
4bcc			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4bcc 2a 2a ea				ld hl, (cli_var_array+2) 
4bcf cd 79 1b				call forth_push_numhl 
4bd2				       NEXTW 
4bd2 c3 34 1f			jp macro_next 
4bd5				endm 
# End of macro NEXTW
4bd5			.V2S: 
4bd5				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4bd5 7c				db WORD_SYS_CORE+104             
4bd6 ed 4b			dw .V2Q            
4bd8 04				db 3 + 1 
4bd9 .. 00			db "V2!",0              
4bdd				endm 
# End of macro CWHEAD
4bdd			;| V2! ( u1 -- )  Store value to v2 | DONE 
4bdd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bdd cd 7e 1d			call macro_dsp_valuehl 
4be0				endm 
# End of macro FORTH_DSP_VALUEHL
4be0			 
4be0 11 2c ea				ld de, cli_var_array+4 
4be3				 
4be3 eb					ex de, hl 
4be4 73					ld (hl), e 
4be5 23					inc hl 
4be6 72					ld (hl), d 
4be7			 
4be7					; destroy value TOS 
4be7			 
4be7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4be7 cd 36 1e			call macro_forth_dsp_pop 
4bea				endm 
# End of macro FORTH_DSP_POP
4bea				       NEXTW 
4bea c3 34 1f			jp macro_next 
4bed				endm 
# End of macro NEXTW
4bed			.V2Q: 
4bed				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4bed 7d				db WORD_SYS_CORE+105             
4bee fe 4b			dw .V3S            
4bf0 04				db 3 + 1 
4bf1 .. 00			db "V2@",0              
4bf5				endm 
# End of macro CWHEAD
4bf5			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4bf5 2a 2c ea				ld hl, (cli_var_array+4) 
4bf8 cd 79 1b				call forth_push_numhl 
4bfb				       NEXTW 
4bfb c3 34 1f			jp macro_next 
4bfe				endm 
# End of macro NEXTW
4bfe			.V3S: 
4bfe				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4bfe 7c				db WORD_SYS_CORE+104             
4bff 16 4c			dw .V3Q            
4c01 04				db 3 + 1 
4c02 .. 00			db "V3!",0              
4c06				endm 
# End of macro CWHEAD
4c06			;| V3! ( u1 -- )  Store value to v3 | DONE 
4c06					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c06 cd 7e 1d			call macro_dsp_valuehl 
4c09				endm 
# End of macro FORTH_DSP_VALUEHL
4c09			 
4c09 11 2e ea				ld de, cli_var_array+6 
4c0c				 
4c0c eb					ex de, hl 
4c0d 73					ld (hl), e 
4c0e 23					inc hl 
4c0f 72					ld (hl), d 
4c10			 
4c10					; destroy value TOS 
4c10			 
4c10					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c10 cd 36 1e			call macro_forth_dsp_pop 
4c13				endm 
# End of macro FORTH_DSP_POP
4c13				       NEXTW 
4c13 c3 34 1f			jp macro_next 
4c16				endm 
# End of macro NEXTW
4c16			.V3Q: 
4c16				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4c16 7d				db WORD_SYS_CORE+105             
4c17 27 4c			dw .END            
4c19 04				db 3 + 1 
4c1a .. 00			db "V3@",0              
4c1e				endm 
# End of macro CWHEAD
4c1e			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c1e 2a 2e ea				ld hl, (cli_var_array+6) 
4c21 cd 79 1b				call forth_push_numhl 
4c24				       NEXTW 
4c24 c3 34 1f			jp macro_next 
4c27				endm 
# End of macro NEXTW
4c27			 
4c27			 
4c27			 
4c27			 
4c27			 
4c27			; end of dict marker 
4c27			 
4c27 00			.END:    db WORD_SYS_END 
4c28 00 00			dw 0 
4c2a 00				db 0 
4c2b			 
4c2b			; use to jp here for user dict words to save on macro expansion  
4c2b			 
4c2b			user_dict_next: 
4c2b				NEXTW 
4c2b c3 34 1f			jp macro_next 
4c2e				endm 
# End of macro NEXTW
4c2e			 
4c2e			 
4c2e			user_exec: 
4c2e				;    ld hl, <word code> 
4c2e				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c2e				;    call forthexec 
4c2e				;    jp user_dict_next   (NEXT) 
4c2e			        ;    <word code bytes> 
4c2e eb				ex de, hl 
4c2f 2a c2 e5			ld hl,(os_tok_ptr) 
4c32				 
4c32				FORTH_RSP_NEXT 
4c32 cd 20 1b			call macro_forth_rsp_next 
4c35				endm 
# End of macro FORTH_RSP_NEXT
4c35			 
4c35			if DEBUG_FORTH_UWORD 
4c35						DMARK "UEX" 
4c35 f5				push af  
4c36 3a 4a 4c			ld a, (.dmark)  
4c39 32 6b ee			ld (debug_mark),a  
4c3c 3a 4b 4c			ld a, (.dmark+1)  
4c3f 32 6c ee			ld (debug_mark+1),a  
4c42 3a 4c 4c			ld a, (.dmark+2)  
4c45 32 6d ee			ld (debug_mark+2),a  
4c48 18 03			jr .pastdmark  
4c4a ..			.dmark: db "UEX"  
4c4d f1			.pastdmark: pop af  
4c4e			endm  
# End of macro DMARK
4c4e				CALLMONITOR 
4c4e cd 6f ee			call debug_vector  
4c51				endm  
# End of macro CALLMONITOR
4c51			endif 
4c51			 
4c51			 
4c51			 
4c51 eb				ex de, hl 
4c52 22 c2 e5			ld (os_tok_ptr), hl 
4c55				 
4c55				; Don't use next - Skips the first word in uword. 
4c55			 
4c55 c3 c5 1f			jp exec1 
4c58			;	NEXT 
4c58			 
4c58			 
4c58			; eof 
# End of file forth_wordsv4.asm
4c58			endif 
4c58			;;;;;;;;;;;;;; Debug code 
4c58			 
4c58			 
4c58			;if DEBUG_FORTH_PARSE 
4c58 .. 00		.nowordfound: db "No match",0 
4c61 .. 00		.compword:	db "Comparing word ",0 
4c71 .. 00		.nextwordat:	db "Next word at",0 
4c7e .. 00		.charmatch:	db "Char match",0 
4c89			;endif 
4c89			if DEBUG_FORTH_JP 
4c89			.foundword:	db "Word match. Exec..",0 
4c89			endif 
4c89			;if DEBUG_FORTH_PUSH 
4c89 .. 00		.enddict:	db "Dict end. Push.",0 
4c99 .. 00		.push_str:	db "Pushing string",0 
4ca8 .. 00		.push_num:	db "Pushing number",0 
4cb7 .. 00		.data_sp:	db "SP:",0 
4cbb .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4ccd .. 00		.wordinde:	db "Word in DE (3/0):",0 
4cdf .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4cf1			;endif 
4cf1			;if DEBUG_FORTH_MALLOC 
4cf1 .. 00		.push_malloc:	db "Malloc address",0 
4d00			;endif 
4d00			 
4d00			 
4d00			 
4d00			; display malloc address and current data stack pointer  
4d00			 
4d00			malloc_error: 
4d00 d5				push de 
4d01 f5				push af 
4d02 e5				push hl 
4d03 cd c5 0b			call clear_display 
4d06 11 26 4d			ld de, .mallocerr 
4d09 3e 00			ld a,0 
4d0b			;	ld de,os_word_scratch 
4d0b cd d8 0b			call str_at_display 
4d0e 3e 11			ld a, display_row_1+17 
4d10 11 6b ee			ld de, debug_mark 
4d13 cd d8 0b			call str_at_display 
4d16 cd e8 0b			call update_display 
4d19				;call break_point_state 
4d19 cd 74 5e			call cin_wait 
4d1c			 
4d1c			;	ld a, ' ' 
4d1c			;	ld (os_view_disable), a 
4d1c cd fc 14			call bp_on 
4d1f e1				pop hl 
4d20 f1				pop af 
4d21 d1				pop de	 
4d22				CALLMONITOR 
4d22 cd 6f ee			call debug_vector  
4d25				endm  
# End of macro CALLMONITOR
4d25 c9				ret 
4d26			 
4d26 .. 00		.mallocerr: 	db "Malloc Error",0 
4d33			;if DEBUG_FORTH_PUSH 
4d33			display_data_sp: 
4d33 f5				push af 
4d34			 
4d34				; see if disabled 
4d34			 
4d34			 
4d34 3a 6f ee			ld a, (debug_vector) 
4d37 fe c9			cp $C9  ; RET 
4d39				;ld a, (os_view_disable) 
4d39				;cp '*' 
4d39 28 67			jr z, .skipdsp 
4d3b			 
4d3b e5				push hl 
4d3c e5				push hl 
4d3d e5			push hl 
4d3e cd c5 0b			call clear_display 
4d41 e1			pop hl 
4d42 7c				ld a,h 
4d43 21 c6 e5			ld hl, os_word_scratch 
4d46 cd fb 0f			call hexout 
4d49 e1				pop hl 
4d4a 7d				ld a,l 
4d4b 21 c8 e5			ld hl, os_word_scratch+2 
4d4e cd fb 0f			call hexout 
4d51 21 ca e5			ld hl, os_word_scratch+4 
4d54 3e 00			ld a,0 
4d56 77				ld (hl),a 
4d57 11 c6 e5			ld de,os_word_scratch 
4d5a 3e 28				ld a, display_row_2 
4d5c cd d8 0b				call str_at_display 
4d5f 11 bb 4c			ld de, .wordinhl 
4d62 3e 00			ld a, display_row_1 
4d64			 
4d64 cd d8 0b				call str_at_display 
4d67 11 6b ee			ld de, debug_mark 
4d6a 3e 11			ld a, display_row_1+17 
4d6c			 
4d6c cd d8 0b				call str_at_display 
4d6f			 
4d6f				; display current data stack pointer 
4d6f 11 b7 4c			ld de,.data_sp 
4d72 3e 30				ld a, display_row_2 + 8 
4d74 cd d8 0b				call str_at_display 
4d77			 
4d77 2a ee e9			ld hl,(cli_data_sp) 
4d7a e5				push hl 
4d7b 7c				ld a,h 
4d7c 21 c6 e5			ld hl, os_word_scratch 
4d7f cd fb 0f			call hexout 
4d82 e1				pop hl 
4d83 7d				ld a,l 
4d84 21 c8 e5			ld hl, os_word_scratch+2 
4d87 cd fb 0f			call hexout 
4d8a 21 ca e5			ld hl, os_word_scratch+4 
4d8d 3e 00			ld a,0 
4d8f 77				ld (hl),a 
4d90 11 c6 e5			ld de,os_word_scratch 
4d93 3e 33				ld a, display_row_2 + 11 
4d95 cd d8 0b				call str_at_display 
4d98			 
4d98			 
4d98 cd e8 0b			call update_display 
4d9b cd fd 0a			call delay1s 
4d9e cd fd 0a			call delay1s 
4da1 e1				pop hl 
4da2			.skipdsp: 
4da2 f1				pop af 
4da3 c9				ret 
4da4			 
4da4			display_data_malloc: 
4da4			 
4da4 f5				push af 
4da5 e5				push hl 
4da6 e5				push hl 
4da7 e5			push hl 
4da8 cd c5 0b			call clear_display 
4dab e1			pop hl 
4dac 7c				ld a,h 
4dad 21 c6 e5			ld hl, os_word_scratch 
4db0 cd fb 0f			call hexout 
4db3 e1				pop hl 
4db4 7d				ld a,l 
4db5 21 c8 e5			ld hl, os_word_scratch+2 
4db8 cd fb 0f			call hexout 
4dbb 21 ca e5			ld hl, os_word_scratch+4 
4dbe 3e 00			ld a,0 
4dc0 77				ld (hl),a 
4dc1 11 c6 e5			ld de,os_word_scratch 
4dc4 3e 28				ld a, display_row_2 
4dc6 cd d8 0b				call str_at_display 
4dc9 11 f1 4c			ld de, .push_malloc 
4dcc 3e 00			ld a, display_row_1 
4dce			 
4dce cd d8 0b				call str_at_display 
4dd1			 
4dd1				; display current data stack pointer 
4dd1 11 b7 4c			ld de,.data_sp 
4dd4 3e 30				ld a, display_row_2 + 8 
4dd6 cd d8 0b				call str_at_display 
4dd9			 
4dd9 2a ee e9			ld hl,(cli_data_sp) 
4ddc e5				push hl 
4ddd 7c				ld a,h 
4dde 21 c6 e5			ld hl, os_word_scratch 
4de1 cd fb 0f			call hexout 
4de4 e1				pop hl 
4de5 7d				ld a,l 
4de6 21 c8 e5			ld hl, os_word_scratch+2 
4de9 cd fb 0f			call hexout 
4dec 21 ca e5			ld hl, os_word_scratch+4 
4def 3e 00			ld a,0 
4df1 77				ld (hl),a 
4df2 11 c6 e5			ld de,os_word_scratch 
4df5 3e 33				ld a, display_row_2 + 11 
4df7 cd d8 0b				call str_at_display 
4dfa			 
4dfa cd e8 0b			call update_display 
4dfd cd fd 0a			call delay1s 
4e00 cd fd 0a			call delay1s 
4e03 e1				pop hl 
4e04 f1				pop af 
4e05 c9				ret 
4e06			;endif 
4e06			 
4e06			include "forth_autostart.asm" 
4e06			; list of commands to perform at system start up 
4e06			 
4e06			startcmds: 
4e06			;	dw test11 
4e06			;	dw test12 
4e06			;	dw test13 
4e06			;	dw test14 
4e06			;	dw test15 
4e06			;	dw test16 
4e06			;	dw test17 
4e06			;	dw ifthtest1 
4e06			;	dw ifthtest2 
4e06			;	dw ifthtest3 
4e06			;	dw mmtest1 
4e06			;	dw mmtest2 
4e06			;	dw mmtest3 
4e06			;	dw mmtest4 
4e06			;	dw mmtest5 
4e06			;	dw mmtest6 
4e06			;	dw iftest1 
4e06			;	dw iftest2 
4e06			;	dw iftest3 
4e06			;	dw looptest1 
4e06			;	dw looptest2 
4e06			;	dw test1 
4e06			;	dw test2 
4e06			;	dw test3 
4e06			;	dw test4 
4e06			;	dw game2r 
4e06			;	dw game2b1 
4e06			;	dw game2b2 
4e06			 
4e06				; start up words that are actually useful 
4e06			 
4e06			;    dw spi1 
4e06			;    dw spi2 
4e06			;    dw spi3 
4e06			;    dw spi4 
4e06			;    dw spi5 
4e06			;    dw spi6 
4e06			;    dw spi7 
4e06			; 
4e06			;    dw spi8 
4e06			;    dw spi9 
4e06			;    dw spi10 
4e06			 
4e06			; file editor 
4e06			;	dw edit1 
4e06			;	dw edit2 
4e06			;	dw edit3 
4e06			 
4e06			;	dw longread 
4e06 26 52			dw clrstack 
4e08 5a 52			dw type 
4e0a			;	dw stest 
4e0a 7f 52			dw strncpy 
4e0c			;	dw list 
4e0c e0 52			dw start1 
4e0e f0 52			dw start2 
4e10			;	dw start3 
4e10			;	dw start3b 
4e10			;	dw start3c 
4e10			 
4e10				; (unit) testing words 
4e10			 
4e10			;	dw mtesta 
4e10			;	dw mtestb 
4e10			;	dw mtestc 
4e10			;	dw mtestd 
4e10			;	dw mteste 
4e10			 
4e10				; demo/game words 
4e10			 
4e10			;        dw game3w 
4e10			;        dw game3p 
4e10			;        dw game3sc 
4e10			;        dw game3vsi 
4e10			;        dw game3vs 
4e10				 
4e10			;	dw game2b 
4e10			;	dw game2bf 
4e10			;	dw game2mba 
4e10			;	dw game2mbas 
4e10			;	dw game2mb 
4e10			 
4e10 0d 56			dw game1 
4e12 1e 56			dw game1a 
4e14 80 56			dw game1b 
4e16 b5 56			dw game1c 
4e18 eb 56			dw game1d 
4e1a 1c 57			dw game1s 
4e1c 30 57			dw game1t 
4e1e 45 57			dw game1f 
4e20 79 57			dw game1z 
4e22 bd 57			dw game1zz 
4e24			 
4e24 46 54			dw test5 
4e26 7e 54			dw test6 
4e28 b6 54			dw test7 
4e2a ca 54			dw test8 
4e2c f6 54			dw test9 
4e2e 0c 55			dw test10 
4e30				 
4e30 94 58		        dw ssv5 
4e32 78 58		        dw ssv4 
4e34 5c 58		        dw ssv3 
4e36 26 58		        dw ssv2 
4e38 ad 58		        dw ssv1 
4e3a f5 58		        dw ssv1cpm 
4e3c			;	dw keyup 
4e3c			;	dw keydown 
4e3c			;	dw keyleft 
4e3c			;	dw keyright 
4e3c			;	dw 	keyf1 
4e3c			;	dw keyf2 
4e3c			;	dw keyf3 
4e3c			;	dw keyf4 
4e3c			;	dw keyf5 
4e3c			;	dw keyf6 
4e3c			;	dw keyf7 
4e3c			;	dw keyf8 
4e3c			;	dw keyf9 
4e3c			;	dw keyf10 
4e3c			;	dw keyf11 
4e3c			;	dw keyf12 
4e3c			;	dw keytab 
4e3c			;	dw keycr 
4e3c			;	dw keyhome 
4e3c			;	dw keyend 
4e3c			;	dw keybs 
4e3c 00 00			db 0, 0	 
4e3e			 
4e3e			 
4e3e			; File Editor 
4e3e			 
4e3e			; ( id - ) use 'e' to edit the displayed line 
4e3e .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4e5f .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e94			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e94 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4ecc			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4ecc			 
4ecc			; SPI Net support words 
4ecc			 
4ecc			; v0! = node to send to 
4ecc			; ( str count - ) 
4ecc .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4f25			 
4f25			; spiputc ( char node - ) 
4f25 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
4f59			; spiputc ( u node - ) 
4f59 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
4f87			 
4f87			; spigetc ( - n ) 
4f87 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
4fb0			 
4fb0			; getnode ( - n ) 
4fb0 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4fdd			 
4fdd			; ( str node - )  
4fdd .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5043			; store string ( str i - ) 
5043			 
5043			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5043 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5098			 
5098			; get string ( addr i -  )    TO FIX 
5098			 
5098 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
50f0			 
50f0			 
50f0			; NETCHAT (TODO) 
50f0			; Program to allow two nodes to chat with eachother 
50f0			; 
50f0			; v0 - target node 
50f0			;  
50f0			; accept input at 0,0 
50f0			; if input is string send spitype to target node 
50f0			; starting at row 2,0 , while spigetchr is not zero ->  
50f0			; 
50f0			; 
50f0			; TODO add paging of get request 
50f0			 
50f0			; ( node - ) 
50f0 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
510f .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5167 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
51df			 
51df			 
51df			; Long read of currently open file 
51df .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5226			 
5226			; clear stack  
5226			 
5226 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
525a			 
525a			; type ( addr count - ) 
525a .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
527f			 
527f			; some direct memory words 
527f			; strncpy ( len t f -- t ) 
527f			 
527f .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
52e0			 
52e0 .. 00		start1:     	db ": bpon $00 bp ;",0 
52f0 .. 00		start2:     	db ": bpoff $01 bp ;",0 
5301 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
537c .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
53dc			 
53dc			 
53dc			; a handy word to list items on the stack 
53dc			 
53dc .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5446			 
5446			 
5446			; test stack  
5446			; rnd8 stest 
5446			 
5446			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5446			 
5446			; random malloc and free cycles 
5446			 
5446			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5446			 
5446			; fixed malloc and free cycles 
5446			 
5446			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5446			 
5446			; fixed double string push and drop cycle  
5446			 
5446			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5446			 
5446			; consistent fixed string push and drop cycle  
5446			 
5446			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5446			 
5446			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5446			 
5446			;test1:		db ": aa 1 2 3 ;", 0 
5446			;test2:     	db "111 aa 888 999",0 
5446			;test3:     	db ": bb 77 ;",0 
5446			;test4:     	db "$02 $01 do i . loop bb",0 
5446			 
5446 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
547e .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
54b6 .. 00		test7:     	db ": box hline vline ;",0 
54ca .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
54f6 .. 00		test9:     	db ": sw $01 adsp world ;",0 
550c .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5531			;test11:     	db "hello create .",0 
5531			;test12:     	db "hello2 create .",0 
5531			 
5531			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5531			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5531			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5531			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5531			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5531			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5531			 
5531			;iftest1:     	db "$0001 IF cls .",0 
5531			;iftest2:     	db "$0000 IF cls .",0 
5531			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5531			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5531			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5531			 
5531			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5531			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5531			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5531			 
5531			 
5531 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5555 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5585 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
55aa .. 00		sound4: db ": cha $00 ; ",0 
55b7 .. 00		sound5: db ": chb $20 ; ",0 
55c4 .. 00		sound6: db ": chc $40 ; ",0 
55d1 .. 00		sound7: db ": chd $60 ; ",0 
55de .. 00		sound8: db ": cnote $80 + + note ; ", 0 
55f6 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
560d			 
560d			 
560d			 
560d			 
560d			; a small guess the number game 
560d			 
560d .. 00		game1:          db ": gsn rnd8 v1! ;",0 
561e .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5680			 
5680 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
56b5 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
56eb .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
571c .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5730 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5745 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5779 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
57bd			 
57bd			; Using 'ga' save a high score across multiple runs using external storage 
57bd			 
57bd .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5826			 
5826			 
5826			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5826			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5826			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5826			 
5826			; simple screen saver to test code memory reuse to destruction 
5826			 
5826 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
585c .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5878 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5894 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
58ad .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
58f5 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
594c			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
594c			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
594c			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
594c			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
594c			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
594c			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
594c			 
594c			 
594c			 
594c			; minesweeper/battleship finding game 
594c			; draws a game board of random ship/mine positions 
594c			; user enters coords to see if it hits on 
594c			; game ends when all are hit 
594c			; when hit or miss says how many may be in the area 
594c			 
594c			; setup the game board and then hide it 
594c			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
594c			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
594c			;; prompt for where to target 
594c			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
594c			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
594c			;; TODO see if the entered coords hits or misses pushes char hit of miss 
594c			;game2mbht:      db ": mbckht nop ;",0 
594c			;game2mbms:      db ": mbcms nop ;",0 
594c			; TODO how many might be near by 
594c			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
594c			 
594c			; Game 3 
594c			 
594c			; Vert scroller ski game - avoid the trees! 
594c			 
594c			; v0 score (ie turns) 
594c			; v1 player pos 
594c			; v2 left wall 
594c			; v3 right wall 
594c			 
594c			; Draw side walls randomly 
594c			 
594c			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
594c			 
594c			; Draw player 
594c			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
594c			 
594c			; TODO Get Key 
594c			 
594c			; TODO Move left right 
594c			 
594c			; scroll and move walls a bit 
594c			 
594c			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
594c			 
594c			; main game loop 
594c			 
594c			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
594c			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
594c			 
594c			; key board defs 
594c			 
594c .. 00		keyup:       db ": keyup $05 ;",0 
595a .. 00		keydown:       db ": keydown $0a ;",0 
596a .. 00		keyleft:       db ": keyleft $0b ;",0 
597a .. 00		keyright:       db ": keyright $0c ;",0 
598b .. 00		keyf1:       db ": keyf1 $10 ;",0 
5999 .. 00		keyf2:       db ": keyf2 $11 ;",0 
59a7 .. 00		keyf3:       db ": keyf3 $12 ;",0 
59b5 .. 00		keyf4:       db ": keyf4 $13 ;",0 
59c3 .. 00		keyf5:       db ": keyf5 $14 ;",0 
59d1 .. 00		keyf6:       db ": keyf6 $15 ;",0 
59df .. 00		keyf7:       db ": keyf7 $16 ;",0 
59ed .. 00		keyf8:       db ": keyf8 $17 ;",0 
59fb .. 00		keyf9:       db ": keyf9 $18 ;",0 
5a09 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5a18 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5a27 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5a36			 
5a36 .. 00		keytab:       db ": keytab $09 ;",0 
5a45 .. 00		keycr:       db ": keycr $0d ;",0 
5a53 .. 00		keyhome:       db ": keyhome $0e ;",0 
5a63 .. 00		keyend:       db ": keyend $0f ;",0 
5a72 .. 00		keybs:       db ": keybs $08 ;",0 
5a80			 
5a80			   
5a80			 
5a80			 
5a80			 
5a80			; eof 
# End of file forth_autostart.asm
5a80			 
5a80			 
5a80			 
5a80			; stack over and underflow checks 
5a80			 
5a80			; init the words to detect the under/overflow 
5a80			 
5a80			chk_stk_init: 
5a80				; a vague random number to check so we dont get any "lucky" hits 
5a80 3e 2d			ld a, 45 
5a82 6f				ld l, a 
5a83 00				nop 
5a84 3e 17			ld a, 23 
5a86 67				ld h, a 
5a87			 
5a87 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
5a8a			 
5a8a			;	ld (chk_stund), hl	; stack points.... 
5a8a 22 00 ef			ld (chk_stovr), hl 
5a8d 22 ec e9			ld (chk_ret_und), hl 
5a90 22 aa e9			ld (chk_ret_ovr), hl 
5a93 22 28 e9			ld (chk_loop_ovr), hl 
5a96 22 26 e8			ld (chk_data_ovr), hl 
5a99 c9				ret 
5a9a				 
5a9a			check_stacks: 
5a9a				; check all stack words 
5a9a			 
5a9a e5				push hl 
5a9b d5				push de 
5a9c			 
5a9c			;	ld de,(chk_word) 
5a9c			;	ld hl, (chk_stund)	; stack points.... 
5a9c			;	if DEBUG_STK_FAULT 
5a9c			;		DMARK "FAa" 
5a9c			;		CALLMONITOR 
5a9c			;	endif 
5a9c			;	call cmp16 
5a9c			;	jp z, .chk_faulta 
5a9c			; 
5a9c			;	ld de, sfaultsu 
5a9c			;	jp .chk_fault 
5a9c			 
5a9c 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5a9f ed 5b 9d e2		ld de,(chk_word) 
5aa3				if DEBUG_STK_FAULT 
5aa3					DMARK "FAb" 
5aa3					CALLMONITOR 
5aa3				endif 
5aa3 cd 10 0e			call cmp16 
5aa6 28 06			jr z, .chk_fault1 
5aa8 11 4c 5b			ld de, sfaultso 
5aab c3 fd 5a			jp .chk_fault 
5aae			.chk_fault1:  
5aae 2a ec e9			ld hl, (chk_ret_und) 
5ab1 ed 5b 9d e2		ld de,(chk_word) 
5ab5				if DEBUG_STK_FAULT 
5ab5					DMARK "FAU" 
5ab5					CALLMONITOR 
5ab5				endif 
5ab5 cd 10 0e			call cmp16 
5ab8 ca c1 5a			jp z, .chk_fault2 
5abb 11 5c 5b			ld de, sfaultru 
5abe c3 fd 5a			jp .chk_fault 
5ac1			.chk_fault2:  
5ac1 2a aa e9			ld hl, (chk_ret_ovr) 
5ac4 ed 5b 9d e2		ld de,(chk_word) 
5ac8				if DEBUG_STK_FAULT 
5ac8					DMARK "FA1" 
5ac8					CALLMONITOR 
5ac8				endif 
5ac8 cd 10 0e			call cmp16 
5acb ca d4 5a			jp z, .chk_fault3 
5ace 11 6a 5b			ld de, sfaultro 
5ad1 c3 fd 5a			jp .chk_fault 
5ad4			.chk_fault3:  
5ad4 2a 28 e9			ld hl, (chk_loop_ovr) 
5ad7 ed 5b 9d e2		ld de,(chk_word) 
5adb				if DEBUG_STK_FAULT 
5adb					DMARK "FA2" 
5adb					CALLMONITOR 
5adb				endif 
5adb cd 10 0e			call cmp16 
5ade ca e7 5a			jp z, .chk_fault4 
5ae1 11 84 5b			ld de, sfaultlo 
5ae4 c3 fd 5a			jp .chk_fault 
5ae7			.chk_fault4:  
5ae7 2a 26 e8			ld hl, (chk_data_ovr) 
5aea ed 5b 9d e2		ld de,(chk_word) 
5aee				if DEBUG_STK_FAULT 
5aee					DMARK "FA3" 
5aee					CALLMONITOR 
5aee				endif 
5aee cd 10 0e			call cmp16 
5af1 ca fa 5a			jp z, .chk_fault5 
5af4 11 9e 5b			ld de, sfaultdo 
5af7 c3 fd 5a			jp .chk_fault 
5afa			 
5afa			 
5afa			.chk_fault5:  
5afa d1				pop de 
5afb e1				pop hl 
5afc			 
5afc c9				ret 
5afd			 
5afd cd c5 0b		.chk_fault: 	call clear_display 
5b00 3e 28				ld a, display_row_2 
5b02 cd d8 0b				call str_at_display 
5b05 11 2e 5b				   ld de, .stackfault 
5b08 3e 00				ld a, display_row_1 
5b0a cd d8 0b				call str_at_display 
5b0d 11 6b ee				    ld de, debug_mark 
5b10 3e 11				ld a, display_row_1+17 
5b12 cd d8 0b				call str_at_display 
5b15 cd e8 0b				call update_display 
5b18			 
5b18				; prompt before entering montior for investigating issue 
5b18			 
5b18 3e 78			ld a, display_row_4 
5b1a 11 6b 18			ld de, endprog 
5b1d			 
5b1d cd e8 0b			call update_display		 
5b20			 
5b20 cd f1 1a			call next_page_prompt 
5b23			 
5b23 d1				pop de 
5b24 e1				pop hl 
5b25 cd bf 18				call monitor 
5b28 cd da 1e				call forth_warmstart 
5b2b c3 bb 17				jp warmstart_afterauto 
5b2e					;jp 0 
5b2e					;halt 
5b2e			 
5b2e			 
5b2e			 
5b2e .. 00		.stackfault: 	db "Stack fault:",0 
5b3b			 
5b3b .. 00		sfaultsu: 	db	"Stack under flow",0 
5b4c .. 00		sfaultso: 	db	"Stack over flow",0 
5b5c .. 00		sfaultru:	db "RTS underflow",0 
5b6a .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5b84 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5b9e .. 00		sfaultdo:	db "DTS overflow", 0 
5bab			 
5bab			 
5bab			fault_dsp_under: 
5bab 11 bd 5b			ld de, .dsp_under 
5bae c3 73 5c			jp .show_fault 
5bb1			 
5bb1			fault_rsp_under: 
5bb1 11 cb 5b			ld de, .rsp_under 
5bb4 c3 73 5c			jp .show_fault 
5bb7			fault_loop_under: 
5bb7 11 d9 5b			ld de, .loop_under 
5bba c3 73 5c			jp .show_fault 
5bbd			 
5bbd .. 00		.dsp_under: db "DSP Underflow",0 
5bcb .. 00		.rsp_under: db "RSP Underflow",0 
5bd9 .. 00		.loop_under: db "LOOP Underflow",0 
5be8			 
5be8			 
5be8 d5			type_faultn: 	push de 
5be9 e5					push hl 
5bea cd c5 0b				call clear_display 
5bed 11 17 5c				   ld de, .typefaultn 
5bf0 3e 00				ld a, display_row_1 
5bf2 cd d8 0b				call str_at_display 
5bf5 11 6b ee				    ld de, debug_mark 
5bf8 3e 11				ld a, display_row_1+17 
5bfa cd d8 0b				call str_at_display 
5bfd cd e8 0b				call update_display 
5c00			 
5c00				; prompt before entering montior for investigating issue 
5c00			 
5c00 3e 78			ld a, display_row_4 
5c02 11 6b 18			ld de, endprog 
5c05			 
5c05 cd e8 0b			call update_display		 
5c08			 
5c08 cd f1 1a			call next_page_prompt 
5c0b			 
5c0b e5					push hl 
5c0c d5					push de 
5c0d cd bf 18				call monitor 
5c10 cd da 1e				call forth_warmstart 
5c13 c3 bb 17				jp warmstart_afterauto 
5c16 76					halt 
5c17			 
5c17			 
5c17 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
5c2e			 
5c2e d5			type_faults: 	push de 
5c2f e5					push hl 
5c30 cd c5 0b				call clear_display 
5c33 11 5c 5c				   ld de, .typefaults 
5c36 3e 00				ld a, display_row_1 
5c38 cd d8 0b				call str_at_display 
5c3b 11 6b ee				    ld de, debug_mark 
5c3e 3e 11				ld a, display_row_1+17 
5c40 cd d8 0b				call str_at_display 
5c43 cd e8 0b				call update_display 
5c46			 
5c46				; prompt before entering montior for investigating issue 
5c46			 
5c46 3e 78			ld a, display_row_4 
5c48 11 6b 18			ld de, endprog 
5c4b			 
5c4b cd e8 0b			call update_display		 
5c4e			 
5c4e cd f1 1a			call next_page_prompt 
5c51			 
5c51 e1					pop hl 
5c52 d1					pop de 
5c53 cd bf 18				call monitor 
5c56 cd da 1e				call forth_warmstart 
5c59 c3 bb 17				jp warmstart_afterauto 
5c5c			 
5c5c			 
5c5c .. 00		.typefaults: db "STR Type Expected TOS!",0 
5c73			 
5c73			.show_fault: 	 
5c73 d5					push de 
5c74 cd c5 0b				call clear_display 
5c77 d1					pop de 
5c78 3e 00				ld a, display_row_1 
5c7a cd d8 0b				call str_at_display 
5c7d 11 6b ee				    ld de, debug_mark 
5c80 3e 11				ld a, display_row_1+17 
5c82 cd d8 0b				call str_at_display 
5c85 cd e8 0b				call update_display 
5c88			 
5c88				; prompt before entering montior for investigating issue 
5c88			 
5c88 3e 78			ld a, display_row_4 
5c8a 11 6b 18			ld de, endprog 
5c8d			 
5c8d cd e8 0b			call update_display		 
5c90			 
5c90 cd f1 1a			call next_page_prompt 
5c93			 
5c93 e1					pop hl 
5c94 d1					pop de 
5c95 cd bf 18				call monitor 
5c98			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5c98			; TODO Make optional fault restart to cli or warm boot? 
5c98					;jp warmstart 
5c98 c3 ff 17				jp cli 
5c9b 76					halt 
5c9c			 
5c9c			; handle the auto run of code from files in storage 
5c9c			 
5c9c			 
5c9c			include "forth_startup.asm" 
5c9c			; Which startup method to use? 
5c9c			; 
5c9c			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
5c9c			; followed by loading of a list of scripts in eeprom 
5c9c			 
5c9c			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
5c9c			; from eeprom 
5c9c			 
5c9c			; Select with define in main stubs 
5c9c			 
5c9c			if STARTUP_V1 
5c9c				include "forth_startupv1.asm" 
5c9c			; Startup script loading version 1 
5c9c			 
5c9c			; If SE storage is available first stage is to use the selected file 
5c9c			; then go through the eeprom list 
5c9c			 
5c9c .. 00		sprompt1: db "Startup load...",0 
5cac .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5cc2			 
5cc2			 
5cc2			 
5cc2			 
5cc2			forth_startup: 
5cc2 21 06 4e			ld hl, startcmds 
5cc5 3e 00			ld a, 0 
5cc7 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5cca			 
5cca e5			.start1:	push hl 
5ccb cd c5 0b			call clear_display 
5cce 11 9c 5c			ld de, sprompt1 
5cd1 3e 00		        ld a, display_row_1 
5cd3 cd d8 0b			call str_at_display 
5cd6 11 ac 5c			ld de, sprompt2 
5cd9 3e 28		        ld a, display_row_2 
5cdb cd d8 0b			call str_at_display 
5cde e1				pop hl 
5cdf e5				push hl 
5ce0 5e				ld e,(hl) 
5ce1 23				inc hl 
5ce2 56				ld d,(hl) 
5ce3 3e 50		        ld a, display_row_3 
5ce5 cd d8 0b			call str_at_display 
5ce8 cd e8 0b			call update_display 
5ceb			 
5ceb			 
5ceb 3a e7 e6			ld a, (os_last_cmd) 
5cee fe 00			cp 0 
5cf0 28 05			jr z, .startprompt 
5cf2 cd f1 0a			call delay250ms 
5cf5 18 24			jr .startdo 
5cf7				 
5cf7				 
5cf7			 
5cf7			.startprompt: 
5cf7			 
5cf7 3e 9f			ld a,display_row_4 + display_cols - 1 
5cf9 11 ef 1a		        ld de, endprg 
5cfc cd d8 0b			call str_at_display 
5cff cd e8 0b			call update_display 
5d02 cd fd 0a			call delay1s 
5d05 cd 74 5e			call cin_wait 
5d08						 
5d08 fe 2a			cp '*' 
5d0a 28 5e			jr z, .startupend1 
5d0c fe 23			cp '#' 
5d0e 20 07			jr nz, .startno 
5d10 3e 01			ld a, 1 
5d12 32 e7 e6			ld (os_last_cmd),a 
5d15 18 04			jr .startdo 
5d17 fe 31		.startno:	cp '1' 
5d19 28 3a			jr z,.startnxt  
5d1b			 
5d1b				; exec startup line 
5d1b			.startdo:	 
5d1b e1				pop hl 
5d1c e5				push hl 
5d1d				 
5d1d 5e				ld e,(hl) 
5d1e 23				inc hl 
5d1f 56				ld d,(hl) 
5d20 eb				ex de,hl 
5d21			 
5d21 e5				push hl 
5d22			 
5d22 3e 00			ld a, 0 
5d24				;ld a, FORTH_END_BUFFER 
5d24 cd 63 11			call strlent 
5d27 23				inc hl   ; include zero term to copy 
5d28 06 00			ld b,0 
5d2a 4d				ld c,l 
5d2b e1				pop hl 
5d2c 11 c1 e2			ld de, scratch 
5d2f ed b0			ldir 
5d31			 
5d31			 
5d31 21 c1 e2			ld hl, scratch 
5d34 cd 82 1f			call forthparse 
5d37 cd c2 1f			call forthexec 
5d3a cd d4 1e			call forthexec_cleanup 
5d3d			 
5d3d 3e 78			ld a, display_row_4 
5d3f 11 6b 18			ld de, endprog 
5d42			 
5d42 cd e8 0b			call update_display		 
5d45			 
5d45 3a e7 e6			ld a, (os_last_cmd) 
5d48 fe 00			cp 0 
5d4a 20 09			jr nz, .startnxt 
5d4c cd f1 1a			call next_page_prompt 
5d4f cd c5 0b		        call clear_display 
5d52 cd e8 0b			call update_display		 
5d55			 
5d55				; move onto next startup line? 
5d55			.startnxt: 
5d55			 
5d55 cd f1 0a			call delay250ms 
5d58 e1				pop hl 
5d59			 
5d59 23				inc hl 
5d5a 23				inc hl 
5d5b			 
5d5b e5				push hl 
5d5c 5e				ld e, (hl) 
5d5d 23				inc hl 
5d5e 56				ld d, (hl) 
5d5f e1				pop hl 
5d60				; TODO replace 0 test 
5d60			 
5d60 eb				ex de, hl 
5d61 cd 1b 0e			call ishlzero 
5d64			;	ld a,e 
5d64			;	add d 
5d64			;	cp 0    ; any left to do? 
5d64 eb				ex de, hl 
5d65 c2 ca 5c			jp nz, .start1 
5d68 18 01			jr .startupend 
5d6a			 
5d6a e1			.startupend1: pop hl 
5d6b			.startupend: 
5d6b			 
5d6b cd c5 0b			call clear_display 
5d6e cd e8 0b			call update_display 
5d71 c9				ret 
5d72			if STORAGE_SE 
5d72			 
5d72			sprompt3: db "Loading from start-up file?:",0 
5d72			sprompt4: db "(Y=Any key/N=No)",0 
5d72			 
5d72			 
5d72			forth_autoload: 
5d72			 
5d72				; load block 0 of store 1 
5d72				 
5d72				ld a, $fe      ; bit 0 clear 
5d72				ld (spi_device), a 
5d72			 
5d72				call storage_get_block_0 
5d72			 
5d72				ld a, (store_page+STORE_0_AUTOFILE) 
5d72			 
5d72				cp 0 
5d72				ret z     ; auto start not enabled 
5d72			 
5d72				call clear_display 
5d72			 
5d72				; set bank 
5d72			 
5d72					ld a, (store_page+STORE_0_BANKRUN) 
5d72					ld (spi_device), a 
5d72			 
5d72				; get file id to load from and get the file name to display 
5d72			 
5d72					ld a, (store_page+STORE_0_FILERUN) 
5d72			 
5d72					ld l, 0 
5d72					ld h, a 
5d72					ld de, store_page 
5d72			 
5d72					if DEBUG_FORTH_WORDS 
5d72						DMARK "ASp" 
5d72						CALLMONITOR 
5d72					endif 
5d72					call storage_read 
5d72			 
5d72					if DEBUG_FORTH_WORDS 
5d72						DMARK "ASr" 
5d72						CALLMONITOR 
5d72					endif 
5d72			 
5d72					call ishlzero 
5d72					ret z             ; file not found 
5d72			 
5d72					ld a, display_row_2 + 10 
5d72					ld de, store_page+3 
5d72					call str_at_display 
5d72				 
5d72			; 
5d72			 
5d72				ld a, display_row_1+5 
5d72				ld de, sprompt3 
5d72				call str_at_display 
5d72				ld a, display_row_3+15 
5d72				ld de, sprompt4 
5d72				call str_at_display 
5d72			 
5d72				call update_display 
5d72			 
5d72				call cin_wait 
5d72				cp 'n' 
5d72				ret z 
5d72				cp 'N' 
5d72				ret z 
5d72			 
5d72				call delay1s 
5d72			 
5d72				ld a, (store_page+2) 
5d72				ld (store_openmaxext), a    ; save count of ext 
5d72				ld a, 1  
5d72				ld (store_openext), a    ; save count of ext 
5d72			 
5d72			.autof:  
5d72				ld l , a 
5d72				 
5d72				ld a, (store_page) 
5d72				ld h, a	 
5d72				ld de, store_page 
5d72					if DEBUG_FORTH_WORDS 
5d72						DMARK "ASl" 
5d72						CALLMONITOR 
5d72					endif 
5d72					call storage_read 
5d72				call ishlzero 
5d72				ret z 
5d72			;	jr z, .autoend 
5d72			 
5d72					if DEBUG_FORTH_WORDS 
5d72						DMARK "ASc" 
5d72						CALLMONITOR 
5d72					endif 
5d72				ld de, store_page+2 
5d72				ld a, display_row_4 
5d72				call str_at_display 
5d72			 
5d72				call update_display 
5d72				call delay250ms 
5d72			 
5d72			 
5d72			 
5d72				ld hl, store_page+2 
5d72				call forthparse 
5d72				call forthexec 
5d72				call forthexec_cleanup 
5d72			 
5d72				 
5d72				ld a, (store_openext) 
5d72				inc a 
5d72				ld (store_openext), a    ; save count of ext 
5d72			 
5d72				jr .autof 
5d72			;.autofdone: 
5d72			; 
5d72			;		if DEBUG_FORTH_WORDS 
5d72			;			DMARK "ASx" 
5d72			;			CALLMONITOR 
5d72			;		endif 
5d72			;;	call clear_display 
5d72			;	ret 
5d72			 
5d72			 
5d72			 
5d72			endif 
# End of file forth_startupv1.asm
5d72			endif 
5d72			if STARTUP_V2 
5d72				include "forth_startupv2.asm" 
5d72			endif 
5d72			 
# End of file forth_startup.asm
5d72			 
5d72			; eof 
# End of file forth_kernel.asm
5d72			;include "nascombasic.asm" 
5d72			 
5d72			 
5d72			; find out where the code ends if loaded into RAM (for SC114) 
5d72			;endofcode:  
5d72			;	nop 
5d72			 
5d72			 
5d72			; jump to nmi vector 
5d72			 
5d72			init_nmi: 
5d72 3e c9			ld a, $c9   ; RET 
5d74 32 72 ee			ld (nmi_vector), a 
5d77 c9				ret 
5d78			nmi: 
5d78 e5				push hl 
5d79 d5				push de 
5d7a c5				push bc 
5d7b f5				push af 
5d7c cd 72 ee			call nmi_vector 
5d7f f5				push af 
5d80 c5				push bc 
5d81 d5				push de 
5d82 e5				push hl 
5d83 ed 4d			reti 
5d85			 
5d85			 
5d85			; eof 
5d85			 
# End of file main.asm
5d85			;include "firmware_lcd_4x40.asm" 
5d85			;;include "firmware_lcd_4x20.asm" 
5d85			include "firmware_cpm_display.asm" 
5d85			 
5d85			; Serial display interface for SC114 
5d85			 
5d85			 
5d85			display_row_1: equ 0 
5d85			display_row_2: equ display_row_1+display_cols 
5d85			display_row_3: equ display_row_2 + display_cols 
5d85			display_row_4: equ display_row_3 + display_cols 
5d85			 
5d85			kLCDWidth:  EQU display_cols             ;Width in characters 
5d85			kLCD_Line1: EQU 0x00  
5d85			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5d85			; E1 
5d85			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5d85			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5d85			 
5d85			lcd_init: 
5d85				; no init as handled by the SCM bios 
5d85 c9				ret 
5d86			 
5d86			 
5d86			; low level functions for direct screen writes 
5d86			 
5d86			; output char at pos? 
5d86			fLCD_Str: 
5d86			        ;out (SC114_SIO_1_OUT),a 
5d86 c5				push bc 
5d87 d5				push de 
5d88 5f				ld e, a 
5d89			; TODO Replace with CP/M BIOS call 
5d89 0e 02			ld c, $02 
5d8b cd 05 00			call 5 
5d8e d1				pop de 
5d8f c1				pop bc 
5d90 c9				ret 
5d91			 
5d91			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5d91			fLCD_Pos: 
5d91				; use ASCII escape to position 
5d91			        ;out (SC114_SIO_1_OUT),a 
5d91 c5				push bc 
5d92 d5				push de 
5d93 5f				ld e, a 
5d94 0e 02			ld c, $02 
5d96			; TODO Replace with CP/M BIOS call 
5d96 cd 05 00			call 5 
5d99 d1				pop de 
5d9a c1				pop bc 
5d9b			 
5d9b c9				ret 
5d9c			 
5d9c			; output char at pos 
5d9c			fLCD_Data: 
5d9c			      ;  out (SC114_SIO_1_OUT),a 
5d9c c5				push bc 
5d9d d5				push de 
5d9e 0e 02			ld c, $02 
5da0 5f				ld e, a 
5da1			; TODO Replace with CP/M BIOS call 
5da1 cd 05 00			call 5 
5da4 d1				pop de 
5da5 c1				pop bc 
5da6			 
5da6 c9				ret 
5da7			 
5da7			; ascii cls  
5da7			 
5da7 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
5dab			 
5dab 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5dc2			;.clscpm: db 3, $3c,"$" 
5dc2			 
5dc2			; write the frame buffer given in hl to hardware  
5dc2			write_display: 
5dc2			 
5dc2			API: equ 0 
5dc2			 
5dc2			if API 
5dc2				push bc 
5dc2				ld b, 4 
5dc2			 
5dc2			        ld (display_write_tmp), hl 	  
5dc2			 
5dc2				; clear and home cursor 
5dc2			 
5dc2				ld c, 9 
5dc2				ld de, .cls 
5dc2			; TODO Replace with CP/M BIOS call 
5dc2				call 5 
5dc2			 
5dc2			 
5dc2			.writeln: 
5dc2			 
5dc2				ld de, (display_write_tmp) 
5dc2				ld c, 6 
5dc2			; TODO Replace with CP/M BIOS call 
5dc2				rst $30 
5dc2				ld c, 7 
5dc2				rst $30 
5dc2			 
5dc2				ld hl, (display_write_tmp) 
5dc2				ld de, display_cols 
5dc2				add hl,de 
5dc2				ld (display_write_tmp),hl 
5dc2			 
5dc2				djnz  .writeln 
5dc2			 
5dc2				pop bc 
5dc2			 
5dc2			 
5dc2				ret 
5dc2			endif 
5dc2 e5				push hl 
5dc3 c5				push bc 
5dc4 d5				push de 
5dc5			 
5dc5			;	ld c, 2 
5dc5			;	;ld de, .cls 
5dc5			;	ld a, 27 
5dc5			;	rst $30 
5dc5			;	ld c, 2 
5dc5			;	;ld de, .cls 
5dc5			;	ld a, '[' 
5dc5			;	rst $30 
5dc5			; 
5dc5			;	ld c, 2 
5dc5			;	;ld de, .cls 
5dc5			;	ld a, 'H' 
5dc5			;	rst $30 
5dc5			; 
5dc5			 
5dc5			 
5dc5			; lots of CR/LF 
5dc5			;	ld c, 9 
5dc5			;	ld de, .clscpm 
5dc5			;	call 5 
5dc5			 
5dc5			; xterm cls 
5dc5 0e 02			ld c, 2 
5dc7 1e 1b			ld e, 27 
5dc9 cd 05 00			call 5 
5dcc			; cls causes too much flicker 
5dcc			;	ld c, 2 
5dcc			;	ld e, 'c' 
5dcc			;	call 5 
5dcc			 
5dcc			; use xterm home instead 
5dcc 0e 02			ld c, 2 
5dce 1e 5b			ld e, '[' 
5dd0 cd 05 00			call 5 
5dd3 0e 02			ld c, 2 
5dd5 1e 48			ld e, 'H' 
5dd7 cd 05 00			call 5 
5dda			LLL: equ 0 
5dda			 
5dda			if LLL 
5dda			 
5dda				ld c, 2 
5dda				;ld de, .cls 
5dda				ld e, 27 
5dda			; TODO Replace with CP/M BIOS call 
5dda				call 5 
5dda			 
5dda			 
5dda				ld c, 2 
5dda				;ld de, .cls 
5dda				ld e, '[' 
5dda			; TODO Replace with CP/M BIOS call 
5dda				call 5 
5dda				ld c, 2 
5dda				;ld de, .cls 
5dda				ld e, '2' 
5dda			; TODO Replace with CP/M BIOS call 
5dda				call 5 
5dda				ld c, 2 
5dda				;ld de, .cls 
5dda				ld e, 'J' 
5dda			; TODO Replace with CP/M BIOS call 
5dda				call 5 
5dda			 
5dda			endif 
5dda			 
5dda d1				pop de 
5ddb c1				pop bc 
5ddc e1				pop hl 
5ddd			 
5ddd			 
5ddd 22 c9 eb		        ld (display_write_tmp), hl 	  
5de0 3e 00			ld a, kLCD_Line1 
5de2			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5de2 06 28			ld b, display_cols 
5de4 ed 5b c9 eb		ld de, (display_write_tmp) 
5de8 cd 6b 5e			call write_len_string 
5deb				 
5deb			 
5deb e5			push hl 
5dec d5			push de 
5ded c5			push bc 
5dee 0e 02			ld c, 2 
5df0 1e 0a			ld e, 10 
5df2 cd 05 00			call 5 
5df5 0e 02			ld c, 2 
5df7 1e 0d			ld e, 13 
5df9 cd 05 00			call 5 
5dfc			; TODO Replace with CP/M BIOS call 
5dfc				;rst $30 
5dfc c1			pop bc 
5dfd d1			pop de 
5dfe e1			pop hl 
5dff			 
5dff				 
5dff 2a c9 eb			ld hl, (display_write_tmp) 
5e02 11 28 00			ld de, display_cols 
5e05 19				add hl,de 
5e06 22 c9 eb			ld (display_write_tmp),hl 
5e09			 
5e09				 
5e09 3e 28			ld a, kLCD_Line2 
5e0b			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5e0b 06 28			ld b, display_cols 
5e0d ed 5b c9 eb		ld de, (display_write_tmp) 
5e11 cd 6b 5e			call write_len_string 
5e14				 
5e14 2a c9 eb			ld hl, (display_write_tmp) 
5e17 11 28 00			ld de, display_cols 
5e1a 19				add hl,de 
5e1b 22 c9 eb			ld (display_write_tmp),hl 
5e1e			 
5e1e e5			push hl 
5e1f d5			push de 
5e20 c5			push bc 
5e21 0e 07			ld c, 7 
5e23			; TODO Replace with CP/M BIOS call 
5e23				;rst $30 
5e23 0e 02			ld c, 2 
5e25 1e 0a			ld e, 10 
5e27 cd 05 00			call 5 
5e2a 0e 02			ld c, 2 
5e2c 1e 0d			ld e, 13 
5e2e cd 05 00			call 5 
5e31 c1			pop bc 
5e32 d1			pop de 
5e33 e1			pop hl 
5e34			 
5e34				 
5e34 3e 50			ld a, kLCD_Line3 
5e36			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5e36 06 28			ld b, display_cols 
5e38 ed 5b c9 eb		ld de, (display_write_tmp) 
5e3c cd 6b 5e			call write_len_string 
5e3f				 
5e3f 2a c9 eb			ld hl, (display_write_tmp) 
5e42 11 28 00			ld de, display_cols 
5e45 19				add hl,de 
5e46 22 c9 eb			ld (display_write_tmp),hl 
5e49			 
5e49 e5			push hl 
5e4a d5			push de 
5e4b c5			push bc 
5e4c 0e 07			ld c, 7 
5e4e			; TODO Replace with CP/M BIOS call 
5e4e				;rst $30 
5e4e 0e 02			ld c, 2 
5e50 1e 0a			ld e, 10 
5e52 cd 05 00			call 5 
5e55 0e 02			ld c, 2 
5e57 1e 0d			ld e, 13 
5e59 cd 05 00			call 5 
5e5c c1			pop bc 
5e5d d1			pop de 
5e5e e1			pop hl 
5e5f			 
5e5f				 
5e5f 3e 78			ld a, kLCD_Line4 
5e61			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5e61 06 28			ld b, display_cols 
5e63 ed 5b c9 eb		ld de, (display_write_tmp) 
5e67 cd 6b 5e			call write_len_string 
5e6a c9					ret 
5e6b			 
5e6b			 
5e6b				; write out a fixed length string given in b from de 
5e6b			 
5e6b 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
5e6c cd 9c 5d		            CALL fLCD_Data      ;Write character to display 
5e6f 13				inc de 
5e70 10 f9			djnz write_len_string 
5e72 c9				ret 
5e73			 
5e73			 
5e73			; eof 
# End of file firmware_cpm_display.asm
5e73			;include "firmware_key_5x10.asm" 
5e73			;;include "firmware_key_4x10.asm" 
5e73			include "firmware_key_cpm.asm" 
5e73			; Serial keyboard interface for SC114 
5e73			 
5e73			 
5e73			key_init: 
5e73				; no init as handled by the SCM bios 
5e73 c9				ret 
5e74			 
5e74			 
5e74			cin_wait: 
5e74			;	ld a, 0 
5e74			;	ret 
5e74			 
5e74				;in a,(SC114_SIO_1_IN) 
5e74			        ; Use SCM API to get from whatever console device we are using 
5e74			 
5e74			; TODO Replace with CP/M BIOS call 
5e74 c5				push bc 
5e75 0e 01			ld c, $01 
5e77 cd 05 00			call 5 
5e7a c1				pop bc 
5e7b c9				ret 
5e7c			 
5e7c			cin: 
5e7c			 
5e7c			 
5e7c c5				push bc 
5e7d			 
5e7d				; any key waiting to process? 
5e7d			; TODO Replace with CP/M BIOS call 
5e7d 0e 06			ld c, $06 
5e7f cd 05 00			call 5 
5e82 28 0d			jr z, .cin_skip 
5e84			 
5e84				; yep, get it 
5e84			 
5e84 0e 01			ld c, $01 
5e86			; TODO Replace with CP/M BIOS call 
5e86 cd 05 00			call 5 
5e89			 
5e89 fe 7f			cp $7f     ; back space 
5e8b 20 02			jr nz, .skipbs 
5e8d 3e 08			ld a, KEY_BS 
5e8f			.skipbs: 
5e8f			 
5e8f c1				pop bc 
5e90 c9				ret 
5e91			.cin_skip: 
5e91 3e 00			ld a, 0 
5e93 c1				pop bc 
5e94 c9				ret 
5e95			 
5e95			 
5e95			 
5e95			 
# End of file firmware_key_cpm.asm
5e95			endofcode:  
5e95			baseram:  
5e95 00				nop 
5e96			 
5e96			heap_start: equ baseram+15  ; Starting address of heap 
5e96			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5e96			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5e96			;VDU:  EQU     endofcode           ; BASIC Work space 
5e96			; eof 
5e96			 
# End of file os_mega_cpm.asm
5e96
