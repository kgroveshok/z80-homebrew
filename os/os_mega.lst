# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 ff 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-09-19 10:42' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
001f			 
001f			 
001f			 
001f			;        nop  
001f			;        nop 
001f			;;	org 05h		; null out bdos call 
001f			; 
001f			;        nop  
001f			;        nop  
001f			;        nop 
001f			;;	org 08h 
001f			;;; 
001f			;;	jp cin		; rst 8 - char in 
001f			;;; 
001f			; 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;	org 010h 
001f			;; 
001f			;	jp cout		; rest 010h  - char out 
001f			;; 
001f			;	org 01bh   
001f			; 
001f			;	;jp  		; rst 01bh   - write string to display 
001f			;	jp str_at_display 
001f			; 
001f			; 
001f			;	org 020h 
001f			; 
001f			;	; jp		 ; rst 020h - read char at screen location 
001f			; 
001f			;	org 028h 
001f			 
001f				; jp		 ; rst 028h  - storage i/o 
001f			 
001f			; 	org 030h 
001f			;	jp break_point_state 
001f			  
001f			; $30  
001f			; org 038h 
001f			; $38 
001f			 
001f			; TODO any more important entry points to add to jump table for easier coding use? 
001f			 
001f			if BASE_KEV = 1  
001f			 
001f				; need to be at $66 for nmi support 
001f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0025 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0031 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0037 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0043 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0049 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0055 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0061 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0067 00 ff			db 0,255 
0069 c3 70 79			jp nmi 
006c			endif 
006c			 
006c			include "firmware.asm" 
006c			  
006c			; main constants (used here and in firmware)  
006c			  
006c			; TODO have page 0 of storage as bios  
006c			  
006c			Device_A: equ 0h  
006c			Device_B: equ 040h          ; Sound  
006c			  
006c			if BASE_KEV  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_SC114  
006c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			; TODO fixup for CPM  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			Device_D: equ 0c0h             ; Keyboard and LCD  
006c			  
006c			; Odd specific debug points for testing hardware dev  
006c			  
006c			;if DEBUG_LEVEL0  
006c			;	include "debug_level0.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL1  
006c			;	include "debug_level1.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL2  
006c			;	include "debug_level2.asm"  
006c			;endif  
006c			  
006c			  
006c			CALLMONITOR: macro  
006c			;	call break_point_state  
006c			; now use the break point debug vector  
006c				call debug_vector  
006c				endm  
006c			  
006c			MALLOC_1: equ 1        ; from dk88   
006c			MALLOC_2: equ 0           ; broke  
006c			MALLOC_3: equ 0           ; really broke  
006c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
006c			  
006c			if BASE_KEV   
006c			;stacksize: equ 256  
006c			; each stack entry is three bytes (type + word)  
006c			stacksize: equ 3*150  
006c			  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 512  
006c			endif  
006c			if BASE_SC114  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			;if STORAGE_SE == 0  
006c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
006c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
006c			;endif  
006c			  
006c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
006c			  
006c			STORE_0_AUTORUN: equ $20  
006c			  
006c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
006c			  
006c			STORE_0_AUTOFILE: equ $21  
006c			STORE_0_BANKRUN: equ $23  
006c			STORE_0_FILERUN: equ $24  
006c			STORE_0_BANKRUNN: equ $25   ; human readable bank id  
006c			  
006c			; Block 0 offsets for settings  
006c			  
006c			; if set then skip prompt for start up and accept all  
006c			  
006c			STORE_0_QUICKSTART: equ $25  
006c			  
006c			; Blocks where directory table is held  
006c			  
006c			; Reducing the number of entries increases the max file size  
006c			  
006c			;STORE_DIR_START: equ 1  
006c			;STORE_DIR_END: equ 33  
006c			  
006c			; Blocks from where file data is stored  
006c			  
006c			;STORE_DATA_START: equ STORE_DIR_END + 1  
006c			  
006c			; Block indicators (<32 are data files)  
006c			  
006c			;STORE_BLOCK_CFG: equ $8f       ; config block  
006c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
006c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
006c			;STORE_BLOCK_FREE: equ $85       ; data block free  
006c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
006c			  
006c			  
006c			  
006c			; Directory entry flags  
006c			  
006c			;STORE_DIR_FREE: equ 0  
006c			;STORE_DIR_FILE:  equ 1  
006c			  
006c			; Structure offsets to directory entries  
006c			;STORE_DE_FLAG: equ 0  
006c			;STORE_DE_MAXEXT: equ 1  
006c			;STORE_DE_FILENAME: equ 2  
006c			  
006c			; Structure offsets to block 0  
006c			  
006c			;STORE_BK0_ISFOR: equ 1  
006c			;STORE_BK0_LABEL: equ 3  
006c			  
006c			; memory allocation   
006c			  
006c			chk_stund: equ tos+2           ; underflow check word  
006c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
006c			  
006c			; keyscan table needs rows x cols buffer  
006c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
006c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
006c			  
006c			key_macroroot:  equ chk_stovr - 2       ; root ptr for start of keyboard macro strings  
006c			key_macrolast:  equ key_macroroot - 2   ; last macro defined to aid linked list ptr  
006c			;  
006c			; Macro linked list format  
006c			; key code single byte   
006c			; ptr to next or zero if last in the list  
006c			; zero term string   
006c			  
006c			;keyscan_table_row1: equ chk_stovr -key_cols-1  
006c			keyscan_table_row1: equ key_macrolast -key_cols-1  
006c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
006c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
006c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
006c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
006c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
006c			keyscan_scancol: equ keyscan_table-key_cols  
006c			;keyscan_table_len: equ key_rows*key_cols  
006c			;keybufptr: equ keyscan_table - 2  
006c			;keysymbol: equ keybufptr - 1  
006c			key_held: equ keyscan_scancol-1	; currently held  
006c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
006c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
006c			key_fa: equ key_repeat_ct -1 ;  
006c			key_fb: equ key_fa -1 ;  
006c			key_fc: equ key_fb -1 ;  
006c			key_fd: equ key_fc -1 ;  
006c			key_face_held: equ key_fd - 1   
006c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
006c			  
006c			hardware_config: equ key_face_held - 10  
006c			  
006c			; hardware config switches  
006c			; TODO add bitmasks on includes for hardware  
006c			; high byte for expansion ids  
006c			;     0000 0000  no card inserted  
006c			;     0000 0001  storage card inserted  
006c			;     0000 0010  spi sd card active  
006c			  
006c			;       
006c			; low byte:  
006c			;     0000 0001   4x4 keypad  
006c			;     0000 0010   full keyboard  
006c			;     0000 0011   spi/ext keyboard  
006c			;     0000 0100   20x4 lcd  
006c			;     0000 1000   40x4 lcd  
006c			;     0000 1100   spi/ext display  
006c			;     0001 0000   ide interface available  
006c			  
006c			hardware_word: equ hardware_config - 2  
006c			  
006c			; debug marker - optional display of debug point on the debug screens  
006c			  
006c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
006c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
006c			parse_vector:  equ debug_vector - 3 ; vector to the parser vector  
006c			  
006c			debug_umark: equ parse_vector - 6  ; current user mark  
006c			debug_mark: equ debug_umark - 4    ; internal word debug points  
006c			  
006c			; input_str vars  
006c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
006c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
006c			input_size: equ input_start -1  ; number of chars  
006c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
006c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
006c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
006c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
006c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
006c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
006c			input_len: equ input_cur_onoff - 5 ; length of current input  
006c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
006c			  
006c			; cursor blink rate  
006c			CUR_BLINK_RATE: equ $09  
006c			;CUR_BLINK_RATE: equ 15  
006c			  
006c			key_actual_pressed: equ input_cursor - 1   
006c			key_symbol: equ key_actual_pressed - 1   
006c			key_shift: equ key_symbol - 1   
006c			  
006c			; Display allocation  
006c			  
006c			;display_rows: equ 4     ; move out to mini and mega files  
006c			;display_cols: equ 20  
006c			  
006c			display_fb_len: equ display_rows*display_cols  
006c			  
006c			; primary frame buffer     
006c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
006c			; working frame buffers  
006c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
006c			display_fb3: equ  display_fb1-display_fb_len - 1  
006c			display_fb2: equ  display_fb3-display_fb_len - 1  
006c			;  
006c			; pointer to active frame buffer  
006c			display_fb_active: equ display_fb2 - 2  
006c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
006c			display_write_tmp: equ display_lcde1e2 - 2  
006c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
006c			  
006c			;  
006c			  
006c			;; can load into de directory  
006c			cursor_col: equ display_active-1  
006c			cursor_row: equ cursor_col-1  
006c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
006c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
006c			  
006c			; maths vars  
006c			  
006c			LFSRSeed: equ cursor_shape -20   
006c			randData: equ LFSRSeed - 2  
006c			xrandc: equ randData - 2  
006c			stackstore: equ xrandc - 2  
006c			seed1: equ  stackstore -2   
006c			seed2: equ seed1 - 2  
006c			  
006c			; cf storage vars  
006c			  
006c			iErrorNum:  equ seed2-1         ;Error number  
006c			iErrorReg:  equ iErrorNum -1              ;Error register  
006c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
006c			  
006c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
006c			  
006c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
006c			  
006c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
006c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
006c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
006c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
006c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
006c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
006c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
006c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
006c			store_tmpid: equ store_tmp3 - 1		; page temp id  
006c			store_tmpext: equ store_tmpid - 1		; file extent temp  
006c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
006c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
006c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
006c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
006c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
006c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
006c			;  
006c			; spi vars  
006c			  
006c			  
006c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
006c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
006c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
006c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
006c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
006c			spi_device_id: equ spi_device - 1    ; human readable bank number  
006c			  
006c			;;;;; forth cli params  
006c			  
006c			; TODO use a different frame buffer for forth???  
006c			  
006c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
006c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
006c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
006c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
006c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
006c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
006c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
006c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
006c			  
006c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
006c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
006c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
006c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
006c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
006c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
006c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
006c			  
006c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
006c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
006c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
006c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
006c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
006c			  
006c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
006c			  
006c			; os/forth token vars  
006c			  
006c			os_last_cmd: equ os_var_array-255  
006c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
006c			os_current_i: equ os_cli_cmd-2  
006c			os_cur_ptr: equ os_current_i-2  
006c			os_word_scratch: equ os_cur_ptr-30  
006c			os_tok_len: equ os_word_scratch - 2  
006c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
006c			os_tok_malloc: equ os_tok_ptr - 2  
006c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
006c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
006c			execscratch: equ os_input-255        ; exec cmd eval buffer  
006c			scratch: equ execscratch-255  
006c			  
006c			os_stack_1: equ scratch - 3       ; stack holding area 1  
006c			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
006c			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
006c			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
006c			  
006c			  
006c			; temp locations for new word processing to save on adding more   
006c			  
006c			os_new_malloc: equ os_stack_4-2  
006c			os_new_parse_len: equ os_new_malloc - 2  
006c			os_new_word_len: equ os_new_parse_len - 2  
006c			os_new_work_ptr: equ os_new_word_len - 2  
006c			os_new_src_ptr: equ os_new_work_ptr - 2  
006c			os_new_exec: equ os_new_src_ptr - 2  
006c			os_new_exec_ptr: equ os_new_exec - 2  
006c			  
006c			; resume memory alloocations....  
006c			  
006c			;os_view_disable: equ os_new_exec_ptr - 1  
006c			os_view_af: equ os_new_exec_ptr - 2  
006c			os_view_hl: equ os_view_af -2  
006c			os_view_de: equ os_view_hl - 2  
006c			os_view_bc: equ os_view_de - 2  
006c			  
006c			; stack checksum word  
006c			if DEBUG_STACK_IMB  
006c				curframe: equ  os_view_de - 5  
006c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
006c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			else  
006c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			endif  
006c			  
006c			; with data stack could see memory filled with junk. need some memory management   
006c			; malloc and free entry points added  
006c			  
006c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
006c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			;heap_end: equ free_list-1  ; Starting address of heap  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			heap_end: equ chk_word-1  ; Starting address of heap  
006c			  
006c			  
006c			;if BASE_KEV   
006c			;heap_start: equ 0800eh  ; Starting address of heap  
006c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;heap_start: equ baseram+15  ; Starting address of heap  
006c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;endif  
006c			  
006c			  
006c			;;;;  
006c			  
006c			  
006c			; change below to point to last memory alloc above  
006c			topusermem:  equ   heap_start  
006c			  
006c			;if BASE_KEV   
006c			;baseusermem: equ 08000h  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;;aseusermem:     equ    12  
006c			;baseusermem:     equ    prompt  
006c			;;baseusermem:     equ    endofcode  
006c			;endif  
006c			  
006c			  
006c			; **********************************************************************  
006c			; **  Constants  
006c			; **********************************************************************  
006c			  
006c			; Constants used by this code module  
006c			kDataReg:   EQU Device_D           ;PIO port A data register  
006c			kContReg:   EQU Device_D+2           ;PIO port A control register  
006c			  
006c			  
006c			portbdata:  equ Device_D+1    ; port b data  
006c			portbctl:   equ Device_D+3    ; port b control  
006c			  
006c			  
006c			;KEY_SHIFT:   equ 5  
006c			;KEY_SYMBOLSHIFT:  equ 6  
006c			  
006c			KEY_SHIFTLOCK: equ 4  
006c			  
006c			  
006c			KEY_UP: equ 5  
006c			KEY_NEXTWORD: equ 6  
006c			KEY_PREVWORD: equ 7  
006c			KEY_BS: equ 8  
006c			KEY_TAB:  equ 9  
006c			KEY_DOWN: equ 10  
006c			KEY_LEFT: equ 11  
006c			KEY_RIGHT: equ 12  
006c			KEY_CR:   equ 13  
006c			KEY_HOME: equ 14  
006c			KEY_END: equ 15  
006c			  
006c			KEY_F1: equ 16  
006c			KEY_F2: equ 17  
006c			KEY_F3: equ 18  
006c			KEY_F4: equ 19  
006c			  
006c			KEY_F5: equ 20  
006c			KEY_F6: equ 21  
006c			KEY_F7: equ 22  
006c			KEY_F8: equ 23  
006c			  
006c			KEY_F9: equ 24  
006c			KEY_F10: equ 25  
006c			KEY_F11: equ 26  
006c			KEY_F12: equ 27  
006c			  
006c			;if DEBUG_KEY  
006c			;	KEY_MATRIX_NO_PRESS: equ '.'  
006c			;	KEY_SHIFT:   equ '.'  
006c			;	KEY_SYMBOLSHIFT:  equ '.'  
006c			;else  
006c				KEY_SHIFT:   equ '~'  
006c				KEY_SYMBOLSHIFT:  equ '~'  
006c				KEY_MATRIX_NO_PRESS: equ '~'  
006c			;endi  
006c			  
006c			  
006c			  
006c			  
006c			; Macro to make adding debug marks easier  
006c			  
006c			DMARK: macro str  
006c				push af  
006c				ld a, (.dmark)  
006c				ld (debug_mark),a  
006c				ld a, (.dmark+1)  
006c				ld (debug_mark+1),a  
006c				ld a, (.dmark+2)  
006c				ld (debug_mark+2),a  
006c				jr .pastdmark  
006c			.dmark: db str  
006c			.pastdmark: pop af  
006c			  
006c			endm  
006c			  
006c			  
006c			; macro to detect for stack imbalances  
006c			  
006c			include "stackimbal.asm"  
006c			; Macro and code to detect stock imbalances 
006c			 
006c			SPPUSH: equ 0 
006c			 
006c			; Add a stack frame which can be checked before return 
006c			 
006c			STACKFRAME: macro onoff frame1 frame2 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c						exx 
006c			 
006c						ld de, frame1 
006c						ld a, d 
006c						ld hl, curframe 
006c						call hexout 
006c						ld a, e 
006c						ld hl, curframe+2 
006c						call hexout 
006c			  
006c						ld hl, frame1 
006c						push hl 
006c						ld hl, frame2 
006c						push hl 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			endm 
006c			 
006c			STACKFRAMECHK: macro onoff frame1 frame2 
006c			 
006c					 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						exx 
006c						; check stack frame SP 
006c			 
006c						ld hl, frame2 
006c						pop de   ; frame2 
006c			 
006c						call cmp16 
006c						jr nz, .spnosame 
006c						 
006c			 
006c						ld hl, frame1 
006c						pop de   ; frame1 
006c			 
006c						call cmp16 
006c						jr z, .spfrsame 
006c			 
006c						.spnosame: call showsperror 
006c			 
006c						.spfrsame: nop 
006c			 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			 
006c			 
006c			endm 
006c			 
006c			 
006c			; for a sub routine, wrap SP collection and comparisons 
006c			 
006c			; Usage: 
006c			; 
006c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
006c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
006c			 
006c			SAVESP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c			 
006c						ld (store_sp+(storeword*4)), sp 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			CHECKSP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c			 
006c						; save SP after last save 
006c				 
006c						ld (store_sp+(storeword*4)+2), sp 
006c			 
006c						push hl 
006c						ld hl, store_sp+(storeword*4) 
006c						call check_stack_sp  
006c						pop hl 
006c			 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			if DEBUG_STACK_IMB 
006c			 
006c			check_stack_sp: 
006c					push de 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					push de 
006c			 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					pop hl 
006c			 
006c			 
006c					; check to see if the same 
006c			 
006c					call cmp16 
006c					jr z, .spsame 
006c			 
006c					; not same 
006c			 
006c					call showsperror 
006c			.spsame: 
006c			 
006c					pop de 
006c			 
006c					ret 
006c			 
006c			.sperr:  db "Stack imbalance",0 
006c			 
006c			 
006c			showsperror: 
006c			 
006c			 
006c				push hl 
006c				push af 
006c				push de 
006c				call clear_display 
006c				ld de, .sperr 
006c				ld a,0 
006c			;	ld de,os_word_scratch 
006c				call str_at_display 
006c				ld a, display_row_1+17 
006c				ld de, debug_mark 
006c				call str_at_display 
006c				ld a, 0 
006c				ld (curframe+4),a 
006c				ld hl, curframe 
006c				ld de, os_word_scratch 
006c				ld a, display_row_4 
006c				call str_at_display 
006c				call update_display 
006c				;call break_point_state 
006c				call cin_wait 
006c			 
006c			;	ld a, ' ' 
006c			;	ld (os_view_disable), a 
006c				call bp_on 
006c				pop de	 
006c				pop af 
006c				pop hl 
006c				CALLMONITOR 
006c				ret 
006c			 
006c			endif 
006c			 
006c			 
006c			 
006c			; eof 
# End of file stackimbal.asm
006c			  
006c			;TODO macro to calc col and row offset into screen  
006c			  
006c			  
006c			  
006c			hardware_init:  
006c			  
006c				  
006c			  
006c					;ld a, 0  
006c					;ld (hardware_diag), a  
006c			  
006c					; clear all the buffers  
006c			  
006c 21 3e fc				ld hl, display_fb1  
006f 22 fa fa				ld (display_fb_active), hl  
0072			  
0072 cd 81 0d				call clear_display  
0075			  
0075 21 fc fa				ld hl, display_fb2  
0078 22 fa fa				ld (display_fb_active), hl  
007b			  
007b cd 81 0d				call clear_display  
007e			  
007e					; init primary frame buffer area  
007e 21 df fc				ld hl, display_fb0  
0081 22 fa fa				ld (display_fb_active), hl  
0084			  
0084 cd 81 0d				call clear_display  
0087			  
0087			  
0087 cd 7d 79				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
008a			  
008a cd 14 7c			call key_init  
008d cd 42 02			call storage_init  
0090			  
0090				; setup malloc functions  
0090			  
0090				if MALLOC_1  
0090 cd 59 13				call  heap_init  
0093				endif  
0093				if MALLOC_4  
0093					call  heap_init  
0093				endif  
0093			  
0093				; init sound hardware if present  
0093			  
0093				if SOUND_ENABLE  
0093					call sound_init  
0093				endif  
0093			  
0093				; lcd test sequence  
0093					  
0093 cd a3 0d			call update_display  
0096 cd c0 0c			call delay1s  
0099 3e 2b			ld a,'+'  
009b cd 86 0d			call fill_display  
009e cd a3 0d			call update_display  
00a1 cd c0 0c			call delay1s  
00a4 3e 2a			ld a,'*'  
00a6 cd 86 0d			call fill_display  
00a9 cd a3 0d			call update_display  
00ac cd c0 0c			call delay1s  
00af 3e 2d			ld a,'-'  
00b1 cd 86 0d			call fill_display  
00b4 cd a3 0d			call update_display  
00b7 cd c0 0c			call delay1s  
00ba			  
00ba			; boot splash screen  
00ba			if display_cols == 20	  
00ba			        ld a, display_row_1    
00ba			else  
00ba 3e 0a		        ld a, display_row_1 +10   
00bc			endif  
00bc 11 bc 1a			ld de, prom_bootmsg  
00bf cd 93 0d			call str_at_display  
00c2 cd a3 0d			call update_display  
00c5			  
00c5			  
00c5 cd c0 0c			call delay1s  
00c8 cd c0 0c			call delay1s  
00cb			if display_cols == 20	  
00cb			            LD   A, display_row_3+2  
00cb			else  
00cb 3e 5c		            LD   A, display_row_3+12  
00cd			endif  
00cd 11 d1 1a			ld de, prom_bootmsg1  
00d0 cd 93 0d			call str_at_display  
00d3			; display debug level  
00d3 3e 78		            LD   A, display_row_4  
00d5 11 1b 00			ld de, debuglevel  
00d8 cd 93 0d			call str_at_display  
00db			  
00db cd a3 0d			call update_display  
00de cd c0 0c			call delay1s  
00e1 cd c0 0c			call delay1s  
00e4			  
00e4			;	ld a, display_row_4+3  
00e4			;	ld de, bootmsg2  
00e4			;	call str_at_display  
00e4			;	call update_display  
00e4			;	call delay1s  
00e4			;	call delay1s  
00e4			  
00e4			; debug mark setup  
00e4			  
00e4 3e 5f		ld a, '_'  
00e6 32 99 fd		ld (debug_mark),a  
00e9 32 9a fd		ld (debug_mark+1),a  
00ec 32 9b fd		ld (debug_mark+2),a  
00ef 3e 00		ld a,0  
00f1 32 9c fd		ld (debug_mark+3),a  
00f4 32 9d fd		ld (debug_umark),a  
00f7			  
00f7 c9					ret  
00f8			  
00f8			  
00f8			;bootmsg2:	db "Firmware v0.1",0  
00f8			  
00f8			; a 4x20 lcd  
00f8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00f8			  
00f8			;if display_cols == 20  
00f8			;	include "firmware_lcd_4x20.asm"  
00f8			;endif  
00f8			  
00f8			;if display_cols == 40  
00f8			;	include "firmware_lcd_4x40.asm"  
00f8			;endif  
00f8			  
00f8			;  
00f8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00f8			; TODO abstract the bit bang video out interface for dual display  
00f8			; TODO wire video out to tx pin on rc2014 bus  
00f8			  
00f8			; must supply cin, and cin_wait for low level hardware abstraction   
00f8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00f8			; test scancode  
00f8			  
00f8			;;;;;  
00f8			;;;  
00f8			; Moved out to mini and maxi versions  
00f8			;  
00f8			; include "firmware_key_4x4.asm"  
00f8			; using existing 4 wire x 4 resistor array for input  
00f8			;include "firmware_key_4x10.asm"  
00f8			; need to mod the board for 5 rows due to resistor array  
00f8			;include "firmware_key_5x10.asm"  
00f8			  
00f8			; storage hardware interface  
00f8			  
00f8			; use microchip serial eeprom for storage  
00f8			  
00f8			  
00f8			if STORAGE_SE  
00f8				include "firmware_spi.asm"  
00f8			; my spi protocol (used by storage) 
00f8			 
00f8			; SPI pins 
00f8			 
00f8			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00f8			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00f8			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00f8			 
00f8			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00f8			; chip pin 4 gnd 
00f8			 
00f8			 
00f8			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00f8			SPI_CE1: equ 1      ;    port a1 pin 14  
00f8			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00f8			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00f8			SPI_CE4: equ 4      ; port a4     pin 10 
00f8			 
00f8			; active low AND masks 
00f8			 
00f8			;SPI_CE0_MASK: equ    255-1 
00f8			;SPI_CE1_MASK: equ   255-2 
00f8			;SPI_CE2_MASK: equ   255-4 
00f8			;SPI_CE3_MASK: equ   255-8 
00f8			;SPI_CE4_MASK: equ   255-16 
00f8			SPI_CE_HIGH:  equ 255 
00f8			 
00f8			 
00f8			 
00f8			;  Perform SCLK wait pulse 
00f8			 
00f8			spi_clk: 
00f8 f5				push af 
00f9 3a 92 f9			ld a, (spi_clktime) 
00fc			;	cp 0 
00fc b7				or a 
00fd 28 03			jr z, .scskip 
00ff cd a5 0c			call aDelayInMS 
0102			.scskip: 
0102 f1				pop af 
0103 c9				ret 
0104			 
0104			 
0104			 
0104			; TODO store port id for spi device ie dev c 
0104			; TODO store pin for SO 
0104			; TODO store pin for SI 
0104			; TODO store pin for SCLK 
0104			 
0104			; 
0104			 
0104			; ensure that spi bus is in a stable state with default pins  
0104			 
0104			se_stable_spi:   
0104			 
0104				 ; set DI high, CE high , SCLK low 
0104				;ld a, SPI_DI | SPI_CE0 
0104 3e 07			ld a, SPI_DI  
0106 cd fd 01			call spi_ce_high 
0109 d3 80			 out (storage_adata),a 
010b 32 8f f9			ld (spi_portbyte),a 
010e			 
010e				if DEBUG_SPI 
010e					push hl 
010e					ld l, a 
010e					DMARK "SPI" 
010e					CALLMONITOR 
010e					pop hl 
010e				endif 
010e c9				ret 
010f			 
010f			; byte to send in a 
010f			 
010f			spi_send_byte: 
010f				; save byte to send for bit mask shift out 
010f 4f			        ld c,a 
0110 3a 8f f9			ld a,(spi_portbyte) 
0113				  
0113				; clock out	each bit of the byte msb first 
0113			 
0113 06 08			ld b, 8 
0115			.ssb1: 
0115				; clear so bit  
0115 cb bf			res SPI_DI, a 
0117 cb 11			rl c 
0119				; if bit 7 is set then carry is set 
0119 30 02			jr nc, .ssb2 
011b cb ff			set SPI_DI,a 
011d			.ssb2:  ; output bit to ensure it is stable 
011d d3 80			out (storage_adata),a 
011f			;	nop 
011f				; clock bit high 
011f cb ef			set SPI_SCLK,a 
0121 d3 80			out (storage_adata),a 
0123			;	nop 
0123 cd f8 00			call spi_clk 
0126				; then low 
0126 cb af			res SPI_SCLK,a 
0128 d3 80			out (storage_adata),a 
012a			;	nop 
012a cd f8 00			call spi_clk 
012d 10 e6			djnz .ssb1 
012f			 
012f 32 8f f9			ld (spi_portbyte),a 
0132 c9				ret 
0133			 
0133			; TODO low level get byte into A on spi 
0133			 
0133			spi_read_byte:  
0133			 
0133				; save byte to send for bit mask shift out 
0133 0e 00		    ld c,0 
0135 3a 8f f9			ld a,(spi_portbyte) 
0138				  
0138				; clock out	each bit of the byte msb first 
0138			 
0138			 
0138				; clock bit high 
0138 cb ef			set SPI_SCLK,a 
013a d3 80			out (storage_adata),a 
013c			;	nop 
013c cd f8 00			call spi_clk 
013f			 
013f			    ; read DO  
013f			 
013f cb f9		    set 7,c 
0141 db 80			in a,(storage_adata) 
0143 cb 77		    bit SPI_DO,a 
0145 20 02		    jr nz, .b7 
0147 cb b9		    res 7,c 
0149			.b7: 
0149				; then low 
0149 cb af			res SPI_SCLK,a 
014b d3 80			out (storage_adata),a 
014d			;	nop 
014d cd f8 00			call spi_clk 
0150			     
0150			 
0150				; clock bit high 
0150 cb ef			set SPI_SCLK,a 
0152 d3 80			out (storage_adata),a 
0154			;	nop 
0154 cd f8 00			call spi_clk 
0157			 
0157			    ; read DO  
0157			 
0157 cb f1		    set 6,c 
0159 db 80			in a,(storage_adata) 
015b cb 77		    bit SPI_DO,a 
015d 20 02		    jr nz, .b6 
015f cb b1		    res 6,c 
0161			.b6: 
0161				; then low 
0161 cb af			res SPI_SCLK,a 
0163 d3 80			out (storage_adata),a 
0165			;	nop 
0165 cd f8 00			call spi_clk 
0168			 
0168				; clock bit high 
0168 cb ef			set SPI_SCLK,a 
016a d3 80			out (storage_adata),a 
016c			;	nop 
016c cd f8 00			call spi_clk 
016f			 
016f			 
016f			    ; read DO  
016f			 
016f cb e9		    set 5,c 
0171 db 80			in a,(storage_adata) 
0173 cb 77		    bit SPI_DO,a 
0175 20 02		    jr nz, .b5 
0177 cb a9		    res 5,c 
0179			.b5: 
0179				; then low 
0179 cb af			res SPI_SCLK,a 
017b d3 80			out (storage_adata),a 
017d			;	nop 
017d cd f8 00			call spi_clk 
0180				; clock bit high 
0180 cb ef			set SPI_SCLK,a 
0182 d3 80			out (storage_adata),a 
0184			;	nop 
0184 cd f8 00			call spi_clk 
0187			 
0187			    ; read DO  
0187			 
0187 cb e1		    set 4,c 
0189 db 80			in a,(storage_adata) 
018b cb 77		    bit SPI_DO,a 
018d 20 02		    jr nz, .b4 
018f cb a1		    res 4,c 
0191			.b4: 
0191				; then low 
0191 cb af			res SPI_SCLK,a 
0193 d3 80			out (storage_adata),a 
0195			;	nop 
0195 cd f8 00			call spi_clk 
0198				; clock bit high 
0198 cb ef			set SPI_SCLK,a 
019a d3 80			out (storage_adata),a 
019c			;	nop 
019c cd f8 00			call spi_clk 
019f			 
019f			    ; read DO  
019f			 
019f cb d9		    set 3,c 
01a1 db 80			in a,(storage_adata) 
01a3 cb 77		    bit SPI_DO,a 
01a5 20 02		    jr nz, .b3 
01a7 cb 99		    res 3,c 
01a9			.b3: 
01a9				; then low 
01a9 cb af			res SPI_SCLK,a 
01ab d3 80			out (storage_adata),a 
01ad			;	nop 
01ad cd f8 00			call spi_clk 
01b0				; clock bit high 
01b0 cb ef			set SPI_SCLK,a 
01b2 d3 80			out (storage_adata),a 
01b4			;	nop 
01b4 cd f8 00			call spi_clk 
01b7			 
01b7			    ; read DO  
01b7			 
01b7 cb d1		    set 2,c 
01b9 db 80			in a,(storage_adata) 
01bb cb 77		    bit SPI_DO,a 
01bd 20 02		    jr nz, .b2 
01bf cb 91		    res 2,c 
01c1			.b2: 
01c1				; then low 
01c1 cb af			res SPI_SCLK,a 
01c3 d3 80			out (storage_adata),a 
01c5			;	nop 
01c5 cd f8 00			call spi_clk 
01c8				; clock bit high 
01c8 cb ef			set SPI_SCLK,a 
01ca d3 80			out (storage_adata),a 
01cc			;	nop 
01cc cd f8 00			call spi_clk 
01cf			 
01cf			    ; read DO  
01cf			 
01cf cb c9		    set 1,c 
01d1 db 80			in a,(storage_adata) 
01d3 cb 77		    bit SPI_DO,a 
01d5 20 02		    jr nz, .b1 
01d7 cb 89		    res 1,c 
01d9			.b1: 
01d9				; then low 
01d9 cb af			res SPI_SCLK,a 
01db d3 80			out (storage_adata),a 
01dd			;	nop 
01dd cd f8 00			call spi_clk 
01e0				; clock bit high 
01e0 cb ef			set SPI_SCLK,a 
01e2 d3 80			out (storage_adata),a 
01e4			;	nop 
01e4 cd f8 00			call spi_clk 
01e7			 
01e7			    ; read DO  
01e7			 
01e7 cb c1		    set 0,c 
01e9 db 80			in a,(storage_adata) 
01eb cb 77		    bit SPI_DO,a 
01ed 20 02		    jr nz, .b0 
01ef cb 81		    res 0,c 
01f1			.b0: 
01f1				; then low 
01f1 cb af			res SPI_SCLK,a 
01f3 d3 80			out (storage_adata),a 
01f5			;	nop 
01f5 cd f8 00			call spi_clk 
01f8			 
01f8			 
01f8 32 8f f9			ld (spi_portbyte),a 
01fb			 
01fb			    ; return byte 
01fb 79			    ld a,c 
01fc			 
01fc			 
01fc c9				ret 
01fd			 
01fd			 
01fd			 
01fd			spi_ce_high: 
01fd			 
01fd				if DEBUG_SPI_HARD_CE0 
01fd			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01fd					ret 
01fd			 
01fd				endif 
01fd			 
01fd			 
01fd f5				push af 
01fe			 
01fe				; send direct ce to port b 
01fe 3e ff			ld a, 255 
0200 d3 81			out (storage_bdata), a 
0202			 
0202 f1				pop af 
0203			 
0203				; for port a that shares with spi lines AND the mask 
0203			  
0203				if DEBUG_SPI 
0203					push hl 
0203					ld h, a 
0203				endif 
0203			;	ld c, SPI_CE_HIGH 
0203			;	and c 
0203 cb c7			set SPI_CE0, a 
0205 cb cf			set SPI_CE1, a 
0207 cb d7			set SPI_CE2, a 
0209 cb df			set SPI_CE3, a 
020b cb e7			set SPI_CE4, a 
020d			 
020d				if DEBUG_SPI 
020d					ld l, a 
020d					DMARK "CEh" 
020d					CALLMONITOR 
020d					pop hl 
020d				endif 
020d c9				ret 
020e			 
020e			 
020e			spi_ce_low: 
020e			 
020e				if DEBUG_SPI_HARD_CE0 
020e			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e					ret 
020e			 
020e				endif 
020e			 
020e c5				push bc 
020f f5				push af 
0210			 
0210				; send direct ce to port b 
0210 3a 91 f9			ld a, (spi_cartdev) 
0213 d3 81			out (storage_bdata), a 
0215			 
0215			 
0215			 
0215				; for port a that shares with spi lines AND the mask 
0215			 
0215 3a 8e f9			ld a, (spi_device)  
0218 4f				ld c, a 
0219			 
0219 f1				pop af 
021a			 
021a				; detect CEx 
021a			 
021a				if DEBUG_SPI 
021a					push hl 
021a					ld h, a 
021a				endif 
021a			 
021a cb 41			bit SPI_CE0, c 
021c 20 04			jr nz, .cel1 
021e cb 87			res SPI_CE0, a 
0220 18 1e			jr .celn 
0222			.cel1: 
0222 cb 49			bit SPI_CE1, c 
0224 20 04			jr nz, .cel2 
0226 cb 8f			res SPI_CE1, a 
0228 18 16			jr .celn 
022a			.cel2: 
022a cb 51			bit SPI_CE2, c 
022c 20 04			jr nz, .cel3 
022e cb 97			res SPI_CE2, a 
0230 18 0e			jr .celn 
0232			.cel3: 
0232 cb 59			bit SPI_CE3, c 
0234 20 04			jr nz, .cel4 
0236 cb 9f			res SPI_CE3, a 
0238 18 06			jr .celn 
023a			.cel4: 
023a cb 61			bit SPI_CE4, c 
023c 20 02			jr nz, .celn 
023e cb a7			res SPI_CE4, a 
0240			.celn: 
0240			 
0240			 
0240			 
0240			;	add c 
0240			 
0240				if DEBUG_SPI 
0240					ld l, a 
0240					DMARK "CEl" 
0240					CALLMONITOR 
0240					pop hl 
0240				endif 
0240 c1				pop bc 
0241 c9				ret 
0242			 
0242			 
0242			 
0242			; eof 
0242			 
0242			 
0242			 
0242			 
0242			 
# End of file firmware_spi.asm
0242				include "firmware_seeprom.asm"  
0242			; 
0242			; persisent storage interface via microchip serial eeprom 
0242			 
0242			; port a pio 2 
0242			; pa 7 - si 
0242			; pa 6 - sclk  
0242			; pa 5 - so 
0242			; pa 4 - cs 
0242			; pa 3 - cs 
0242			; pa 2 - cs 
0242			; pa 1 - cs 
0242			; pa 0 - cs 
0242			; 
0242			; TODO get block 
0242			; TODO save block 
0242			; TODO load file 
0242			; TODO save file 
0242			; TODO get dir  
0242			 
0242			;  
0242			storage_adata: equ Device_C    ; device c port a - onboard storage 
0242			storage_actl: equ Device_C+2     ; device c port a 
0242			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0242			storage_bctl: equ Device_C+3     ; device c port b 
0242			 
0242			 
0242			; TODO move these to hardware driver file 
0242			 
0242			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0242			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0242			; storage bank file system format 
0242			; 
0242			; first page of bank: 
0242			; 	addr 0 - status check 
0242			;       addr 1 - write protect flag 
0242			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0242			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0242			;         TODO see if scanning whole of for available next file id is fast enough 
0242			;	addr 4 > zero term string of bank label 
0242			; 
0242			;        
0242			;  
0242			; first page of any file: 
0242			;      byte 0 - file id  
0242			;      byte 1-17 - fixed file name  
0242			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0242			; 
0242			; other pages of any file: 
0242			;      byte 0 - file id 
0242			;      byte 1> - file data 
0242			; 
0242			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0242			;  
0242			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0242			 
0242			 
0242			;storage_so_bit: 5 
0242			;storage_si_bit: 7 
0242			;storage_sclk_bit: 6 
0242			  
0242			 
0242			; init storage pio 
0242			 
0242			storage_init: 
0242			 
0242			 
0242					; set default SPI clk pulse time as disabled 
0242			 
0242 3e 00				ld a, 0 
0244 32 92 f9				ld (spi_clktime), a 
0247			 
0247					; init hardware 
0247			 
0247 3e cf		            LD   A, 11001111b 
0249 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
024b 3e 00		            LD   A, 00000000b 
024d cb f7			set SPI_DO,a 
024f			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
024f d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0251			 
0251 3e cf		            LD   A, 11001111b 
0253 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0255 3e 00		            LD   A, 00000000b 
0257 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0259			 
0259				; set all external spi devices off  
0259 3e ff			ld a, 255 
025b 32 8e f9			ld (spi_device), a 
025e 32 91 f9			ld (spi_cartdev), a 
0261			 
0261					; ensure the spi bus is in a default stable state 
0261 cd 04 01				call se_stable_spi 
0264			 
0264			; TODO scan spi bus and gather which storage banks are present 
0264			 
0264			; populate store_bank_active  
0264			; for each ce line activate and attempt to write first byte of bank and read back 
0264			; if zero is returned then bank is empty 
0264			;   
0264			; 
0264			 
0264					; init file extent cache to save on slow reads 
0264			 
0264			;	ld hl, store_filecache 
0264			;	ld de, 0 
0264			;	ld hl,(de)	 
0264			 
0264			 
0264 c9			    ret 
0265			 
0265			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0265			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0265			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0265			 
0265			; INSTRUCTION SET 
0265			; READ 0000 0011 Read data from memory array beginning at selected address 
0265			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0265			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0265			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0265			; RDSR 0000 0101 Read STATUS register 
0265			; WRSR 0000 0001 Write STATUS register 
0265			; PE 0100 0010 Page Erase – erase one page in memory array 
0265			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0265			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0265			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0265			 
0265			; TODO send byte steam for page without setting the address for every single byte 
0265			; TODO read byte  
0265			 
0265			; byte in a 
0265			; address in hl  
0265			se_writebyte: 
0265			        
0265			    ;   ld c, a 
0265 f5			        push af 
0266 e5			        push hl 
0267			 
0267			    ; initi write mode 
0267			    ; 
0267			    ;CS low 
0267			 
0267 3a 8f f9		       ld a,(spi_portbyte) 
026a cd 0e 02			call spi_ce_low 
026d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
026d d3 80		       out (storage_adata),a 
026f 32 8f f9		       ld (spi_portbyte), a 
0272			 
0272			    ;clock out wren instruction 
0272			 
0272 3e 06		    ld a, store_wren_ins 
0274 cd 0f 01		    call spi_send_byte  
0277			 
0277			    ;cs high to enable write latch 
0277			 
0277 3a 8f f9		       ld a,(spi_portbyte) 
027a cd fd 01			call spi_ce_high 
027d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
027d d3 80		       out (storage_adata),a 
027f 32 8f f9		       ld (spi_portbyte), a 
0282			 
0282			;	nop 
0282			    ; 
0282			    ; intial write data 
0282			    ; 
0282			    ; cs low 
0282			     
0282			;       ld a,(spi_portbyte) 
0282 cd 0e 02			call spi_ce_low 
0285			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0285 d3 80		       out (storage_adata),a 
0287 32 8f f9		       ld (spi_portbyte), a 
028a			 
028a			    ; clock out write instruction 
028a			     
028a 3e 02		    ld a, store_write_ins  
028c cd 0f 01		    call spi_send_byte  
028f			 
028f			    ; clock out address (depending on address size) 
028f			     
028f e1			    pop hl 
0290 7c			    ld a,h    ; address out msb first 
0291 cd 0f 01		    call spi_send_byte  
0294 7d			    ld a,l 
0295 cd 0f 01		    call spi_send_byte  
0298			 
0298			    ; clock out byte(s) for page 
0298			 
0298 f1			    pop af 
0299 cd 0f 01		    call spi_send_byte  
029c			 
029c			    ; end write with ce high 
029c 3a 8f f9		       ld a,(spi_portbyte) 
029f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
029f cd fd 01			call spi_ce_high 
02a2 d3 80		       out (storage_adata),a 
02a4 32 8f f9		       ld (spi_portbyte), a 
02a7			 
02a7				; pause for internal write cycle 
02a7 3e 0a			ld a, 10 
02a9 cd a5 0c			call aDelayInMS 
02ac c9			    ret 
02ad			 
02ad			; buffer to write in de 
02ad			; address in hl  
02ad			se_writepage: 
02ad			        
02ad			    ;   ld c, a 
02ad d5				push de 
02ae e5			        push hl 
02af			 
02af			    ; initi write mode 
02af			    ; 
02af			    ;CS low 
02af			 
02af 3a 8f f9		       ld a,(spi_portbyte) 
02b2 cd 0e 02			call spi_ce_low 
02b5			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02b5 d3 80		       out (storage_adata),a 
02b7 32 8f f9		       ld (spi_portbyte), a 
02ba			 
02ba			    ;clock out wren instruction 
02ba			 
02ba 3e 06		    ld a, store_wren_ins 
02bc cd 0f 01		    call spi_send_byte  
02bf			 
02bf			    ;cs high to enable write latch 
02bf			 
02bf 3a 8f f9		       ld a,(spi_portbyte) 
02c2 cd fd 01			call spi_ce_high 
02c5			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02c5 d3 80		       out (storage_adata),a 
02c7 32 8f f9		       ld (spi_portbyte), a 
02ca			 
02ca			;	nop 
02ca			    ; 
02ca			    ; intial write data 
02ca			    ; 
02ca			    ; cs low 
02ca			     
02ca			;       ld a,(spi_portbyte) 
02ca			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02ca cd 0e 02			call spi_ce_low 
02cd d3 80		       out (storage_adata),a 
02cf 32 8f f9		       ld (spi_portbyte), a 
02d2			 
02d2			    ; clock out write instruction 
02d2			     
02d2 3e 02		    ld a, store_write_ins  
02d4 cd 0f 01		    call spi_send_byte  
02d7			 
02d7			    ; clock out address (depending on address size) 
02d7			     
02d7 e1			    pop hl 
02d8 7c			    ld a,h    ; address out msb first 
02d9 cd 0f 01		    call spi_send_byte  
02dc 7d			    ld a,l 
02dd cd 0f 01		    call spi_send_byte  
02e0			 
02e0			    ; clock out byte(s) for page 
02e0			 
02e0 e1				pop hl 
02e1 06 40			ld b, STORE_BLOCK_PHY 
02e3			.bytewrite: 
02e3			 
02e3 7e				ld a,(hl) 
02e4 e5			    push hl 
02e5 c5				push bc 
02e6 cd 0f 01		    call spi_send_byte  
02e9 c1				pop bc 
02ea e1				pop hl 
02eb			 
02eb			    ; end write with ce high 
02eb 3a 8f f9		       ld a,(spi_portbyte) 
02ee cd fd 01			call spi_ce_high 
02f1			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02f1 d3 80		       out (storage_adata),a 
02f3 32 8f f9		       ld (spi_portbyte), a 
02f6			 
02f6 23				inc hl 
02f7 10 ea			djnz .bytewrite 
02f9			 
02f9				; pause for internal write cycle 
02f9 3e 64			ld a, 100 
02fb cd a5 0c			call aDelayInMS 
02fe c9			    ret 
02ff			; returns byte in a 
02ff			; address in hl  
02ff			se_readbyte: 
02ff d5				push de 
0300 c5				push bc 
0301			 
0301			    ;   ld c, a 
0301 e5			        push hl 
0302			 
0302			    ; initi write mode 
0302			    ; 
0302			    ;CS low 
0302			 
0302 3a 8f f9		       ld a,(spi_portbyte) 
0305 cd 0e 02			call spi_ce_low 
0308			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0308 d3 80		       out (storage_adata),a 
030a 32 8f f9		       ld (spi_portbyte), a 
030d			 
030d			    ;clock out wren instruction 
030d			 
030d 3e 03		    ld a, store_read_ins 
030f cd 0f 01		    call spi_send_byte  
0312			 
0312			 
0312			    ; clock out address (depending on address size) 
0312			     
0312 e1			    pop hl 
0313 7c			    ld a,h    ; address out msb first 
0314 cd 0f 01		    call spi_send_byte  
0317 7d			    ld a,l 
0318 cd 0f 01		    call spi_send_byte  
031b			 
031b			    ; clock in byte(s) for page 
031b			 
031b cd 33 01		    call spi_read_byte  
031e f5				push af 
031f			 
031f			    ; end write with ce high 
031f 3a 8f f9		       ld a,(spi_portbyte) 
0322			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0322 cd fd 01			call spi_ce_high 
0325 d3 80		       out (storage_adata),a 
0327 32 8f f9		       ld (spi_portbyte), a 
032a			 
032a f1				pop af 
032b			 
032b c1				pop bc 
032c d1				pop de 
032d			 
032d c9			    ret 
032e			 
032e			if DEBUG_STORESE 
032e			 
032e			storageput:  
032e			 
032e			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
032e			 
032e 21 f1 f0			ld hl,scratch+2 
0331 cd 63 12			call get_word_hl 
0334			 
0334				; stuff it here for the moment as it will be overwritten later anyway 
0334			 
0334 22 12 f4			ld (os_cur_ptr),hl	 
0337			 
0337			 
0337			; get pointer to start of string 
0337			 
0337 21 f6 f0			ld hl, scratch+7 
033a			 
033a			; loop writing char of string to eeprom 
033a			 
033a 7e			.writestr:	ld a,(hl) 
033b			;		cp 0 
033b b7					or a 
033c 28 12				jr z, .wsdone		; done writing 
033e e5					push hl 
033f 2a 12 f4				ld hl,(os_cur_ptr) 
0342 cd 65 02				call se_writebyte 
0345			 
0345 2a 12 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0348 23					inc hl 
0349 22 12 f4				ld (os_cur_ptr),hl 
034c			 
034c					; restore string pointer and get next char 
034c			 
034c e1					pop hl 
034d 23					inc hl 
034e 18 ea				jr .writestr 
0350			 
0350			 
0350			 
0350			.wsdone: 
0350			 
0350			 
0350			; when done load first page into a buffer  
0350			 
0350 21 00 80				ld hl,08000h		; start in ram 
0353 22 12 f4				ld (os_cur_ptr),hl 
0356 21 00 00				ld hl, 0		 ; start of page 
0359 22 17 f1				ld (scratch+40),hl	; hang on to it 
035c			 
035c 06 80				ld b, 128		; actually get more then one page 
035e c5			.wsload:	push bc 
035f 2a 17 f1				ld hl,(scratch+40) 
0362 e5					push hl 
0363 cd ff 02				call se_readbyte 
0366			 
0366					; a now as the byte 
0366			 
0366 2a 12 f4				ld hl,(os_cur_ptr) 
0369 77					ld (hl),a 
036a					; inc next buffer area 
036a 23					inc hl 
036b 22 12 f4				ld (os_cur_ptr),hl 
036e			 
036e					; get eeprom position, inc and save for next round 
036e e1					pop hl		 
036f 23					inc hl 
0370 22 17 f1				ld (scratch+40),hl 
0373 c1					pop bc 
0374 10 e8				djnz .wsload 
0376			 
0376			; set 'd' pointer to start of buffer 
0376			 
0376 21 00 80				ld hl,08000h 
0379 22 12 f4				ld (os_cur_ptr),hl 
037c			 
037c			 
037c c9			ret 
037d			 
037d			 
037d c9			storageread: ret 
037e			 
037e			 
037e			 
037e			 
037e			 
037e			 
037e			endif 
037e			 
037e			 
037e			 
# End of file firmware_seeprom.asm
037e			else  
037e			   ; create some stubs for the labels  
037e			se_readbyte: ret  
037e			se_writebyte: ret  
037e			storage_init: ret  
037e			  
037e			endif  
037e			  
037e			; use cf card for storage - throwing timeout errors. Hardware or software?????  
037e			;include "firmware_cf.asm"  
037e			  
037e			; load up high level storage hardward abstractions  
037e			include "firmware_storage.asm"  
037e			 
037e			; persisent storage hardware abstraction layer  
037e			 
037e			 
037e			 
037e			; Block 0 on storage is a config state 
037e			 
037e			 
037e			 
037e			; TODO add read phy block and write phy block functions 
037e			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
037e			 
037e			; Abstraction layer  
037e			 
037e			; Logocial block size is same size as physical size - using tape concept 
037e			 
037e			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
037e			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
037e			 
037e			 
037e			 
037e			; Filesystem layout (Logical layout) 
037e			; 
037e			; Block 0 - Bank config  
037e			; 
037e			;      Byte - 0 file id counter 
037e			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
037e			;      Byte - 3-20 zero terminated bank label 
037e			; 
037e			; Block 1 > File storage 
037e			; 
037e			;      Byte 0 file id    - block 0 file details 
037e			;      Byte 1 block id - block 0 is file  
037e			;            Byte 2-15 - File name 
037e			; 
037e			;       - to end of block data 
037e			; 
037e			 
037e			; Get ID for the file named in pointer held HL 
037e			; Returns ID in HL = 255 if no file found 
037e			 
037e			storage_getid: 
037e			 
037e 22 a1 f9			ld (store_tmp1), hl 
0381			 
0381				if DEBUG_STORESE 
0381					DMARK "SGI" 
0381 f5				push af  
0382 3a 96 03			ld a, (.dmark)  
0385 32 99 fd			ld (debug_mark),a  
0388 3a 97 03			ld a, (.dmark+1)  
038b 32 9a fd			ld (debug_mark+1),a  
038e 3a 98 03			ld a, (.dmark+2)  
0391 32 9b fd			ld (debug_mark+2),a  
0394 18 03			jr .pastdmark  
0396 ..			.dmark: db "SGI"  
0399 f1			.pastdmark: pop af  
039a			endm  
# End of macro DMARK
039a					CALLMONITOR 
039a cd a6 fd			call debug_vector  
039d				endm  
# End of macro CALLMONITOR
039d				endif 
039d				; get block 0 and set counter for number of files to scan 
039d			 
039d cd 05 05			call storage_get_block_0 
03a0			 
03a0 3a a8 f9			ld a, (store_page) 
03a3 47				ld b, a 
03a4			 
03a4				; get extent 0 of each file id 
03a4			 
03a4				if DEBUG_STORESE 
03a4					DMARK "SGc" 
03a4 f5				push af  
03a5 3a b9 03			ld a, (.dmark)  
03a8 32 99 fd			ld (debug_mark),a  
03ab 3a ba 03			ld a, (.dmark+1)  
03ae 32 9a fd			ld (debug_mark+1),a  
03b1 3a bb 03			ld a, (.dmark+2)  
03b4 32 9b fd			ld (debug_mark+2),a  
03b7 18 03			jr .pastdmark  
03b9 ..			.dmark: db "SGc"  
03bc f1			.pastdmark: pop af  
03bd			endm  
# End of macro DMARK
03bd					CALLMONITOR 
03bd cd a6 fd			call debug_vector  
03c0				endm  
# End of macro CALLMONITOR
03c0				endif 
03c0 60			.getloop:	ld h, b 
03c1 2e 00				ld l, 0 
03c3 c5					push bc 
03c4			 
03c4 11 a8 f9				ld de, store_page 
03c7				if DEBUG_STORESE 
03c7					DMARK "SGr" 
03c7 f5				push af  
03c8 3a dc 03			ld a, (.dmark)  
03cb 32 99 fd			ld (debug_mark),a  
03ce 3a dd 03			ld a, (.dmark+1)  
03d1 32 9a fd			ld (debug_mark+1),a  
03d4 3a de 03			ld a, (.dmark+2)  
03d7 32 9b fd			ld (debug_mark+2),a  
03da 18 03			jr .pastdmark  
03dc ..			.dmark: db "SGr"  
03df f1			.pastdmark: pop af  
03e0			endm  
# End of macro DMARK
03e0					CALLMONITOR 
03e0 cd a6 fd			call debug_vector  
03e3				endm  
# End of macro CALLMONITOR
03e3				endif 
03e3 cd a7 09				call storage_read 
03e6 cd da 0f				call ishlzero 
03e9 28 2d				jr z, .gap 
03eb					 
03eb					; have a file name read. Is it one we want. 
03eb			 
03eb 2a a1 f9				ld hl, (store_tmp1) 
03ee 11 ab f9				ld de, store_page+3   ; file name 
03f1			 
03f1				if DEBUG_STORESE 
03f1					DMARK "SGc" 
03f1 f5				push af  
03f2 3a 06 04			ld a, (.dmark)  
03f5 32 99 fd			ld (debug_mark),a  
03f8 3a 07 04			ld a, (.dmark+1)  
03fb 32 9a fd			ld (debug_mark+1),a  
03fe 3a 08 04			ld a, (.dmark+2)  
0401 32 9b fd			ld (debug_mark+2),a  
0404 18 03			jr .pastdmark  
0406 ..			.dmark: db "SGc"  
0409 f1			.pastdmark: pop af  
040a			endm  
# End of macro DMARK
040a					CALLMONITOR 
040a cd a6 fd			call debug_vector  
040d				endm  
# End of macro CALLMONITOR
040d				endif 
040d cd 41 13				call strcmp 
0410 20 06				jr nz, .gap   ; not this one 
0412			 
0412 c1				        pop bc 
0413			 
0413 26 00				ld h, 0 
0415 68					ld l, b 
0416 18 22				jr .getdone 
0418						 
0418			 
0418			 
0418			 
0418			.gap: 
0418				if DEBUG_STORESE 
0418					DMARK "SGg" 
0418 f5				push af  
0419 3a 2d 04			ld a, (.dmark)  
041c 32 99 fd			ld (debug_mark),a  
041f 3a 2e 04			ld a, (.dmark+1)  
0422 32 9a fd			ld (debug_mark+1),a  
0425 3a 2f 04			ld a, (.dmark+2)  
0428 32 9b fd			ld (debug_mark+2),a  
042b 18 03			jr .pastdmark  
042d ..			.dmark: db "SGg"  
0430 f1			.pastdmark: pop af  
0431			endm  
# End of macro DMARK
0431					CALLMONITOR 
0431 cd a6 fd			call debug_vector  
0434				endm  
# End of macro CALLMONITOR
0434				endif 
0434			 
0434 c1					pop bc 
0435 10 89				djnz .getloop 
0437 21 ff 00				ld hl, 255 
043a			.getdone: 
043a			 
043a				if DEBUG_STORESE 
043a					DMARK "SGe" 
043a f5				push af  
043b 3a 4f 04			ld a, (.dmark)  
043e 32 99 fd			ld (debug_mark),a  
0441 3a 50 04			ld a, (.dmark+1)  
0444 32 9a fd			ld (debug_mark+1),a  
0447 3a 51 04			ld a, (.dmark+2)  
044a 32 9b fd			ld (debug_mark+2),a  
044d 18 03			jr .pastdmark  
044f ..			.dmark: db "SGe"  
0452 f1			.pastdmark: pop af  
0453			endm  
# End of macro DMARK
0453					CALLMONITOR 
0453 cd a6 fd			call debug_vector  
0456				endm  
# End of macro CALLMONITOR
0456				endif 
0456			 
0456 c9				ret 
0457			 
0457			 
0457			 
0457			 
0457			 
0457			 
0457			 
0457			 
0457			; Read Block 
0457			; ---------- 
0457			; 
0457			; With current bank 
0457			;  
0457			; Get block number to read 
0457			; Load physical blocks starting at start block into buffer 
0457			 
0457			; de points to buffer to use 
0457			; hl holds logical block number  
0457			 
0457			storage_read_block: 
0457			 
0457				; TODO bank selection 
0457			 
0457				; for each of the physical blocks read it into the buffer 
0457 06 40			ld b, STORE_BLOCK_PHY 
0459			 
0459				if DEBUG_STORESE 
0459 d5					push de 
045a				endif 
045a				 
045a			.rl1:    
045a			 
045a				; read physical block at hl into de 
045a			        ; increment hl and de to next read position on exit 
045a			 
045a e5				push hl 
045b d5				push de	 
045c c5				push bc 
045d			;	if DEBUG_STORESE 
045d			;		push af 
045d			;		ld a, 'R' 
045d			;		ld (debug_mark),a 
045d			;		pop af 
045d			;		CALLMONITOR 
045d			;	endif 
045d cd ff 02			call se_readbyte 
0460			;	if DEBUG_STORESE 
0460			;		ld a,(spi_portbyte) 
0460			;		ld l, a 
0460			;		push af 
0460			;		ld a, '1' 
0460			;		ld (debug_mark),a 
0460			;		pop af 
0460			;		CALLMONITOR 
0460			;	endif 
0460 c1				pop bc 
0461 d1				pop de 
0462 e1				pop hl 
0463 12				ld (de),a 
0464 23				inc hl 
0465 13				inc de 
0466			 
0466			;	if DEBUG_STORESE 
0466			;		push af 
0466			;		ld a, 'r' 
0466			;		ld (debug_mark),a 
0466			;		pop af 
0466			;		CALLMONITOR 
0466			;	endif 
0466			 
0466 10 f2			djnz .rl1 
0468			 
0468				if DEBUG_STORESE 
0468					DMARK "SRB" 
0468 f5				push af  
0469 3a 7d 04			ld a, (.dmark)  
046c 32 99 fd			ld (debug_mark),a  
046f 3a 7e 04			ld a, (.dmark+1)  
0472 32 9a fd			ld (debug_mark+1),a  
0475 3a 7f 04			ld a, (.dmark+2)  
0478 32 9b fd			ld (debug_mark+2),a  
047b 18 03			jr .pastdmark  
047d ..			.dmark: db "SRB"  
0480 f1			.pastdmark: pop af  
0481			endm  
# End of macro DMARK
0481 d1					pop de 
0482			; 
0482			;		push af 
0482			;		ld a, 'R' 
0482			;		ld (debug_mark),a 
0482			;		pop af 
0482					CALLMONITOR 
0482 cd a6 fd			call debug_vector  
0485				endm  
# End of macro CALLMONITOR
0485				endif 
0485 c9				ret	 
0486				 
0486			 
0486			; File Size 
0486			; --------- 
0486			; 
0486			;   hl file id 
0486			; 
0486			;  returns in hl the number of blocks 
0486			 
0486			storage_file_size: 
0486 5d				ld e, l 
0487 16 00			ld d, 0 
0489 21 40 00			ld hl, STORE_BLOCK_PHY 
048c					if DEBUG_FORTH_WORDS 
048c						DMARK "SIZ" 
048c f5				push af  
048d 3a a1 04			ld a, (.dmark)  
0490 32 99 fd			ld (debug_mark),a  
0493 3a a2 04			ld a, (.dmark+1)  
0496 32 9a fd			ld (debug_mark+1),a  
0499 3a a3 04			ld a, (.dmark+2)  
049c 32 9b fd			ld (debug_mark+2),a  
049f 18 03			jr .pastdmark  
04a1 ..			.dmark: db "SIZ"  
04a4 f1			.pastdmark: pop af  
04a5			endm  
# End of macro DMARK
04a5						CALLMONITOR 
04a5 cd a6 fd			call debug_vector  
04a8				endm  
# End of macro CALLMONITOR
04a8					endif 
04a8 cd 83 07			call storage_findnextid 
04ab			 
04ab cd da 0f			call ishlzero 
04ae			;	ld a, l 
04ae			;	add h 
04ae			;	cp 0 
04ae c8				ret z			; block not found so EOF 
04af			 
04af 11 a8 f9			ld de, store_page 
04b2 cd 57 04			call storage_read_block 
04b5			 
04b5 3a aa f9			ld a, (store_page+2)	 ; get extent count 
04b8 6f				ld l, a 
04b9 26 00			ld h, 0 
04bb c9			 	ret 
04bc			 
04bc			 
04bc			; Write Block 
04bc			; ----------- 
04bc			; 
04bc			; With current bank 
04bc			;  
04bc			; Get block number to write 
04bc			; Write physical blocks starting at start block from buffer 
04bc			  
04bc			storage_write_block: 
04bc				; TODO bank selection 
04bc			 
04bc				; for each of the physical blocks read it into the buffer 
04bc 06 40			ld b, STORE_BLOCK_PHY 
04be			 
04be				if DEBUG_STORESE 
04be					DMARK "SWB" 
04be f5				push af  
04bf 3a d3 04			ld a, (.dmark)  
04c2 32 99 fd			ld (debug_mark),a  
04c5 3a d4 04			ld a, (.dmark+1)  
04c8 32 9a fd			ld (debug_mark+1),a  
04cb 3a d5 04			ld a, (.dmark+2)  
04ce 32 9b fd			ld (debug_mark+2),a  
04d1 18 03			jr .pastdmark  
04d3 ..			.dmark: db "SWB"  
04d6 f1			.pastdmark: pop af  
04d7			endm  
# End of macro DMARK
04d7			 
04d7					;push af 
04d7					;ld a, 'W' 
04d7					;ld (debug_mark),a 
04d7					;pop af 
04d7					CALLMONITOR 
04d7 cd a6 fd			call debug_vector  
04da				endm  
# End of macro CALLMONITOR
04da				endif 
04da			 
04da			; might not be working 
04da			;	call se_writepage 
04da			 
04da			;	ret 
04da			; 
04da			 
04da			 
04da			 
04da			.wl1:    
04da			 
04da				; read physical block at hl into de 
04da			        ; increment hl and de to next read position on exit 
04da			 
04da e5				push hl 
04db d5				push de	 
04dc c5				push bc 
04dd 1a				ld a,(de) 
04de				;if DEBUG_STORESE 
04de			;		push af 
04de			;		ld a, 'W' 
04de			;		ld (debug_mark),a 
04de			;		pop af 
04de			;		CALLMONITOR 
04de			;	endif 
04de cd 65 02			call se_writebyte 
04e1			;	call delay250ms 
04e1			;	nop 
04e1			;	nop 
04e1			;	nop 
04e1			;	if DEBUG_STORESE 
04e1			;		push af 
04e1			;		ld a, 'w' 
04e1			;		ld (debug_mark),a 
04e1			;		pop af 
04e1			;		CALLMONITOR 
04e1			;	endif 
04e1 c1				pop bc 
04e2 d1				pop de 
04e3 e1				pop hl 
04e4 23				inc hl 
04e5 13				inc de 
04e6			 
04e6			 
04e6 10 f2			djnz .wl1 
04e8			 
04e8				if DEBUG_STORESE 
04e8					DMARK "SW2" 
04e8 f5				push af  
04e9 3a fd 04			ld a, (.dmark)  
04ec 32 99 fd			ld (debug_mark),a  
04ef 3a fe 04			ld a, (.dmark+1)  
04f2 32 9a fd			ld (debug_mark+1),a  
04f5 3a ff 04			ld a, (.dmark+2)  
04f8 32 9b fd			ld (debug_mark+2),a  
04fb 18 03			jr .pastdmark  
04fd ..			.dmark: db "SW2"  
0500 f1			.pastdmark: pop af  
0501			endm  
# End of macro DMARK
0501			 
0501					;push af 
0501					;ld a, 'W' 
0501					;ld (debug_mark),a 
0501					;pop af 
0501					CALLMONITOR 
0501 cd a6 fd			call debug_vector  
0504				endm  
# End of macro CALLMONITOR
0504				endif 
0504 c9				ret	 
0505			 
0505			; Init bank 
0505			; --------- 
0505			; 
0505			; With current bank 
0505			; 
0505			; Setup block 0 config 
0505			;     Set 0 file id counter 
0505			;     Set formatted byte pattern 
0505			;     Zero out bank label 
0505			;      
0505			; For every logical block write 0-1 byte as null 
0505			 
0505			storage_get_block_0: 
0505			 
0505				; TODO check presence 
0505			 
0505				; get block 0 config 
0505			 
0505 21 00 00			ld hl, 0 
0508 11 a8 f9			ld de, store_page 
050b cd 57 04			call storage_read_block 
050e			 
050e				if DEBUG_STORESE 
050e					DMARK "SB0" 
050e f5				push af  
050f 3a 23 05			ld a, (.dmark)  
0512 32 99 fd			ld (debug_mark),a  
0515 3a 24 05			ld a, (.dmark+1)  
0518 32 9a fd			ld (debug_mark+1),a  
051b 3a 25 05			ld a, (.dmark+2)  
051e 32 9b fd			ld (debug_mark+2),a  
0521 18 03			jr .pastdmark  
0523 ..			.dmark: db "SB0"  
0526 f1			.pastdmark: pop af  
0527			endm  
# End of macro DMARK
0527 11 a8 f9				ld de, store_page 
052a			;		push af 
052a			;		ld a, 'i' 
052a			;		ld (debug_mark),a 
052a			;		pop af 
052a					CALLMONITOR 
052a cd a6 fd			call debug_vector  
052d				endm  
# End of macro CALLMONITOR
052d				endif 
052d			 
052d				; is this area formatted? 
052d			 
052d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
052d 2a a9 f9			ld hl, (store_page+1) 
0530 3e 80			ld a,0x80 
0532 bd				cp l 
0533 20 22			jr nz, .ininotformatted 
0535				; do a double check 
0535 3e 27			ld a, 0x27 
0537 bc				cp h 
0538 20 1d			jr nz, .ininotformatted 
053a			 
053a				; formatted then 
053a			 
053a				if DEBUG_STORESE 
053a					DMARK "SB1" 
053a f5				push af  
053b 3a 4f 05			ld a, (.dmark)  
053e 32 99 fd			ld (debug_mark),a  
0541 3a 50 05			ld a, (.dmark+1)  
0544 32 9a fd			ld (debug_mark+1),a  
0547 3a 51 05			ld a, (.dmark+2)  
054a 32 9b fd			ld (debug_mark+2),a  
054d 18 03			jr .pastdmark  
054f ..			.dmark: db "SB1"  
0552 f1			.pastdmark: pop af  
0553			endm  
# End of macro DMARK
0553					;push af 
0553					;ld a, 'I' 
0553					;ld (debug_mark),a 
0553					;pop af 
0553					CALLMONITOR 
0553 cd a6 fd			call debug_vector  
0556				endm  
# End of macro CALLMONITOR
0556				endif 
0556 c9				ret 
0557			 
0557			.ininotformatted: 
0557				; bank not formatted so poke various bits to make sure 
0557			 
0557				if DEBUG_STORESE 
0557					DMARK "SB2" 
0557 f5				push af  
0558 3a 6c 05			ld a, (.dmark)  
055b 32 99 fd			ld (debug_mark),a  
055e 3a 6d 05			ld a, (.dmark+1)  
0561 32 9a fd			ld (debug_mark+1),a  
0564 3a 6e 05			ld a, (.dmark+2)  
0567 32 9b fd			ld (debug_mark+2),a  
056a 18 03			jr .pastdmark  
056c ..			.dmark: db "SB2"  
056f f1			.pastdmark: pop af  
0570			endm  
# End of macro DMARK
0570					;push af 
0570					;ld a, 'f' 
0570					;ld (debug_mark),a 
0570					;pop af 
0570					CALLMONITOR 
0570 cd a6 fd			call debug_vector  
0573				endm  
# End of macro CALLMONITOR
0573				endif 
0573			 
0573 cd 84 0c			call storage_clear_page 
0576			 
0576 21 a8 f9			ld hl, store_page 
0579			;	ld a, 0 
0579				 
0579 36 00			ld (hl),0   ; reset file counter 
057b			 
057b 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
057e 22 a9 f9		 	ld (store_page+1), hl	 
0581			 
0581				; set default label 
0581			 
0581 21 1a 06			ld hl, .defaultbanklabl 
0584 11 ab f9		 	ld de, store_page+3 
0587 01 0f 00			ld bc, 15 
058a ed b0			ldir 
058c			 
058c				; Append the current bank id 
058c 21 b4 f9			ld hl, store_page+3+9 
058f 3a 8d f9			ld a, (spi_device_id) 
0592 77				ld (hl), a 
0593			 
0593				; save default page 0 
0593			 
0593 21 00 00			ld hl, 0 
0596 11 a8 f9			ld de, store_page 
0599				if DEBUG_STORESE 
0599					DMARK "SB3" 
0599 f5				push af  
059a 3a ae 05			ld a, (.dmark)  
059d 32 99 fd			ld (debug_mark),a  
05a0 3a af 05			ld a, (.dmark+1)  
05a3 32 9a fd			ld (debug_mark+1),a  
05a6 3a b0 05			ld a, (.dmark+2)  
05a9 32 9b fd			ld (debug_mark+2),a  
05ac 18 03			jr .pastdmark  
05ae ..			.dmark: db "SB3"  
05b1 f1			.pastdmark: pop af  
05b2			endm  
# End of macro DMARK
05b2			;		push af 
05b2			;		ld a, 'F' 
05b2			;		ld (debug_mark),a 
05b2			;		pop af 
05b2					CALLMONITOR 
05b2 cd a6 fd			call debug_vector  
05b5				endm  
# End of macro CALLMONITOR
05b5				endif 
05b5 cd bc 04			call storage_write_block 
05b8				if DEBUG_STORESE 
05b8					DMARK "SB4" 
05b8 f5				push af  
05b9 3a cd 05			ld a, (.dmark)  
05bc 32 99 fd			ld (debug_mark),a  
05bf 3a ce 05			ld a, (.dmark+1)  
05c2 32 9a fd			ld (debug_mark+1),a  
05c5 3a cf 05			ld a, (.dmark+2)  
05c8 32 9b fd			ld (debug_mark+2),a  
05cb 18 03			jr .pastdmark  
05cd ..			.dmark: db "SB4"  
05d0 f1			.pastdmark: pop af  
05d1			endm  
# End of macro DMARK
05d1			;		push af 
05d1			;		ld a, '>' 
05d1			;		ld (debug_mark),a 
05d1			;		pop af 
05d1					CALLMONITOR 
05d1 cd a6 fd			call debug_vector  
05d4				endm  
# End of macro CALLMONITOR
05d4				endif 
05d4			 
05d4			;	nop 
05d4			;	nop 
05d4			;	nop 
05d4			 
05d4				; now set 0 in every page to mark as a free block 
05d4			 
05d4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05d6 21 40 00			ld hl, STORE_BLOCK_PHY 
05d9			 
05d9 3e 00		.setmark1:   	ld a,0 
05db e5					push hl 
05dc c5					push bc 
05dd cd 65 02				call se_writebyte 
05e0 3e 0a			ld a, 10 
05e2 cd a5 0c			call aDelayInMS 
05e5 23				inc hl 
05e6 cd 65 02				call se_writebyte 
05e9 3e 0a			ld a, 10 
05eb cd a5 0c			call aDelayInMS 
05ee 2b				dec hl 
05ef c1					pop bc 
05f0 e1					pop hl 
05f1 3e 40				ld a, STORE_BLOCK_PHY 
05f3 cd b1 0f				call addatohl 
05f6 10 e1				djnz .setmark1 
05f8			 
05f8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05fa 3e 00		.setmark2:   	ld a,0 
05fc e5					push hl 
05fd c5					push bc 
05fe cd 65 02				call se_writebyte 
0601 3e 0a			ld a, 10 
0603 cd a5 0c			call aDelayInMS 
0606 23				inc hl 
0607 cd 65 02				call se_writebyte 
060a 3e 0a			ld a, 10 
060c cd a5 0c			call aDelayInMS 
060f 2b				dec hl 
0610 c1					pop bc 
0611 e1					pop hl 
0612 3e 40				ld a, STORE_BLOCK_PHY 
0614 cd b1 0f				call addatohl 
0617 10 e1				djnz .setmark2 
0619			 
0619					 
0619			 
0619			 
0619 c9				ret 
061a			 
061a			 
061a			 
061a			 
061a .. 00		.defaultbanklabl:   db "BankLabel_",0 
0625			 
0625			 
0625			 
0625			; Label Bank 
0625			; ---------- 
0625			; 
0625			; With current bank 
0625			; Read block 0 
0625			; Set label 
0625			; Write block 0 
0625			 
0625			; label str pointer in hl 
0625			 
0625			storage_label:     
0625			 
0625				if DEBUG_STORESE 
0625					DMARK "LBL" 
0625 f5				push af  
0626 3a 3a 06			ld a, (.dmark)  
0629 32 99 fd			ld (debug_mark),a  
062c 3a 3b 06			ld a, (.dmark+1)  
062f 32 9a fd			ld (debug_mark+1),a  
0632 3a 3c 06			ld a, (.dmark+2)  
0635 32 9b fd			ld (debug_mark+2),a  
0638 18 03			jr .pastdmark  
063a ..			.dmark: db "LBL"  
063d f1			.pastdmark: pop af  
063e			endm  
# End of macro DMARK
063e					CALLMONITOR 
063e cd a6 fd			call debug_vector  
0641				endm  
# End of macro CALLMONITOR
0641				endif 
0641			 
0641 e5				push hl 
0642			 
0642 cd 05 05			call storage_get_block_0 
0645			 
0645				; set default label 
0645			 
0645 e1				pop hl 
0646			 
0646 11 ab f9		 	ld de, store_page+3 
0649 01 0f 00			ld bc, 15 
064c				if DEBUG_STORESE 
064c					DMARK "LB3" 
064c f5				push af  
064d 3a 61 06			ld a, (.dmark)  
0650 32 99 fd			ld (debug_mark),a  
0653 3a 62 06			ld a, (.dmark+1)  
0656 32 9a fd			ld (debug_mark+1),a  
0659 3a 63 06			ld a, (.dmark+2)  
065c 32 9b fd			ld (debug_mark+2),a  
065f 18 03			jr .pastdmark  
0661 ..			.dmark: db "LB3"  
0664 f1			.pastdmark: pop af  
0665			endm  
# End of macro DMARK
0665					CALLMONITOR 
0665 cd a6 fd			call debug_vector  
0668				endm  
# End of macro CALLMONITOR
0668				endif 
0668 ed b0			ldir 
066a				; save default page 0 
066a			 
066a 21 00 00			ld hl, 0 
066d 11 a8 f9			ld de, store_page 
0670				if DEBUG_STORESE 
0670					DMARK "LBW" 
0670 f5				push af  
0671 3a 85 06			ld a, (.dmark)  
0674 32 99 fd			ld (debug_mark),a  
0677 3a 86 06			ld a, (.dmark+1)  
067a 32 9a fd			ld (debug_mark+1),a  
067d 3a 87 06			ld a, (.dmark+2)  
0680 32 9b fd			ld (debug_mark+2),a  
0683 18 03			jr .pastdmark  
0685 ..			.dmark: db "LBW"  
0688 f1			.pastdmark: pop af  
0689			endm  
# End of macro DMARK
0689					CALLMONITOR 
0689 cd a6 fd			call debug_vector  
068c				endm  
# End of macro CALLMONITOR
068c				endif 
068c cd bc 04			call storage_write_block 
068f			 
068f c9				ret 
0690			 
0690			 
0690			 
0690			; Read Block 0 - Config 
0690			; --------------------- 
0690			; 
0690			; With current bank 
0690			; Call presence test 
0690			;    If not present format/init bank  
0690			; Read block 0  
0690			;  
0690			 
0690			 
0690			; Dir 
0690			; --- 
0690			; 
0690			; With current bank 
0690			; Load Block 0 Config 
0690			; Get max file id number 
0690			; For each logical block 
0690			;    Read block read byte 2 
0690			;      if first block of file 
0690			;         Display file name 
0690			;         Display type flags for file 
0690			;        
0690			 
0690			; moving to words as this requires stack control 
0690			 
0690			 
0690			; Delete File 
0690			; ----------- 
0690			; 
0690			; With current bank 
0690			; 
0690			; Load Block 0 Config 
0690			; Get max file id number 
0690			; For each logical block 
0690			;    Read block file id 
0690			;      If first block of file and dont have file id 
0690			;         if file to delete 
0690			;         Save file id 
0690			;         Null file id 
0690			;         Write this block back 
0690			;      If file id is one saved 
0690			;         Null file id 
0690			;         Write this block back 
0690			 
0690			 
0690			.se_done: 
0690 e1				pop hl 
0691 c9				ret 
0692			 
0692			storage_erase: 
0692			 
0692				; hl contains the file id 
0692			 
0692 5d				ld e, l 
0693 16 00			ld d, 0 
0695 21 40 00			ld hl, STORE_BLOCK_PHY 
0698					if DEBUG_FORTH_WORDS 
0698						DMARK "ERA" 
0698 f5				push af  
0699 3a ad 06			ld a, (.dmark)  
069c 32 99 fd			ld (debug_mark),a  
069f 3a ae 06			ld a, (.dmark+1)  
06a2 32 9a fd			ld (debug_mark+1),a  
06a5 3a af 06			ld a, (.dmark+2)  
06a8 32 9b fd			ld (debug_mark+2),a  
06ab 18 03			jr .pastdmark  
06ad ..			.dmark: db "ERA"  
06b0 f1			.pastdmark: pop af  
06b1			endm  
# End of macro DMARK
06b1						CALLMONITOR 
06b1 cd a6 fd			call debug_vector  
06b4				endm  
# End of macro CALLMONITOR
06b4					endif 
06b4 cd 83 07			call storage_findnextid 
06b7 cd da 0f			call ishlzero 
06ba c8				ret z 
06bb			 
06bb e5				push hl 
06bc			 
06bc				; TODO check file not found 
06bc			 
06bc 11 a8 f9			ld de, store_page 
06bf cd 57 04			call storage_read_block 
06c2			 
06c2 cd da 0f			call ishlzero 
06c5 ca 90 06			jp z,.se_done 
06c8			 
06c8					if DEBUG_FORTH_WORDS 
06c8						DMARK "ER1" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 99 fd			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 9a fd			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 9b fd			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "ER1"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1						CALLMONITOR 
06e1 cd a6 fd			call debug_vector  
06e4				endm  
# End of macro CALLMONITOR
06e4					endif 
06e4 3a a8 f9			ld a, (store_page)	; get file id 
06e7 32 9c f9			ld (store_tmpid), a 
06ea			 
06ea 3a aa f9			ld a, (store_page+2)    ; get count of extends 
06ed 32 9b f9			ld (store_tmpext), a 
06f0			 
06f0				; wipe file header 
06f0			 
06f0 e1				pop hl 
06f1 3e 00			ld a, 0 
06f3 32 a8 f9			ld (store_page), a 
06f6 32 a9 f9			ld (store_page+1),a 
06f9 11 a8 f9			ld de, store_page 
06fc					if DEBUG_FORTH_WORDS 
06fc						DMARK "ER2" 
06fc f5				push af  
06fd 3a 11 07			ld a, (.dmark)  
0700 32 99 fd			ld (debug_mark),a  
0703 3a 12 07			ld a, (.dmark+1)  
0706 32 9a fd			ld (debug_mark+1),a  
0709 3a 13 07			ld a, (.dmark+2)  
070c 32 9b fd			ld (debug_mark+2),a  
070f 18 03			jr .pastdmark  
0711 ..			.dmark: db "ER2"  
0714 f1			.pastdmark: pop af  
0715			endm  
# End of macro DMARK
0715						CALLMONITOR 
0715 cd a6 fd			call debug_vector  
0718				endm  
# End of macro CALLMONITOR
0718					endif 
0718 cd bc 04			call storage_write_block 
071b			 
071b			 
071b				; wipe file extents 
071b			 
071b 3a 9b f9			ld a, (store_tmpext) 
071e 47				ld b, a 
071f			 
071f			.eraext:	  
071f c5				push bc 
0720			 
0720 21 40 00			ld hl, STORE_BLOCK_PHY 
0723 3a 9c f9			ld a,(store_tmpid) 
0726 5f				ld e, a 
0727 50				ld d, b	 
0728					if DEBUG_FORTH_WORDS 
0728						DMARK "ER3" 
0728 f5				push af  
0729 3a 3d 07			ld a, (.dmark)  
072c 32 99 fd			ld (debug_mark),a  
072f 3a 3e 07			ld a, (.dmark+1)  
0732 32 9a fd			ld (debug_mark+1),a  
0735 3a 3f 07			ld a, (.dmark+2)  
0738 32 9b fd			ld (debug_mark+2),a  
073b 18 03			jr .pastdmark  
073d ..			.dmark: db "ER3"  
0740 f1			.pastdmark: pop af  
0741			endm  
# End of macro DMARK
0741						CALLMONITOR 
0741 cd a6 fd			call debug_vector  
0744				endm  
# End of macro CALLMONITOR
0744					endif 
0744 cd 83 07			call storage_findnextid 
0747 cd da 0f			call ishlzero 
074a ca 90 06			jp z,.se_done 
074d			 
074d e5				push hl 
074e 11 a8 f9			ld de, store_page 
0751 cd 57 04			call storage_read_block 
0754			 
0754				; free block	 
0754			 
0754 3e 00			ld a, 0 
0756 32 a8 f9			ld (store_page), a 
0759 32 a9 f9			ld (store_page+1),a 
075c 11 a8 f9			ld de, store_page 
075f e1				pop hl 
0760					if DEBUG_FORTH_WORDS 
0760						DMARK "ER4" 
0760 f5				push af  
0761 3a 75 07			ld a, (.dmark)  
0764 32 99 fd			ld (debug_mark),a  
0767 3a 76 07			ld a, (.dmark+1)  
076a 32 9a fd			ld (debug_mark+1),a  
076d 3a 77 07			ld a, (.dmark+2)  
0770 32 9b fd			ld (debug_mark+2),a  
0773 18 03			jr .pastdmark  
0775 ..			.dmark: db "ER4"  
0778 f1			.pastdmark: pop af  
0779			endm  
# End of macro DMARK
0779						CALLMONITOR 
0779 cd a6 fd			call debug_vector  
077c				endm  
# End of macro CALLMONITOR
077c					endif 
077c cd bc 04			call storage_write_block 
077f			 
077f c1				pop bc 
0780 10 9d			djnz .eraext 
0782			 
0782 c9				ret 
0783			 
0783			 
0783			; Find Free Block 
0783			; --------------- 
0783			; 
0783			; With current bank 
0783			;  
0783			; From given starting logical block 
0783			;    Read block  
0783			;    If no file id 
0783			;         Return block id 
0783			 
0783			 
0783			; hl starting page number 
0783			; hl contains free page number or zero if no pages free 
0783			; e contains the file id to locate 
0783			; d contains the block number 
0783			 
0783			; TODO change to find file id and use zero for free block 
0783			 
0783			storage_findnextid: 
0783			 
0783				; now locate first 0 page to mark as a free block 
0783			 
0783 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0785			;	ld hl, STORE_BLOCK_PHY 
0785			 
0785					if DEBUG_FORTH_WORDS 
0785					DMARK "FNI" 
0785 f5				push af  
0786 3a 9a 07			ld a, (.dmark)  
0789 32 99 fd			ld (debug_mark),a  
078c 3a 9b 07			ld a, (.dmark+1)  
078f 32 9a fd			ld (debug_mark+1),a  
0792 3a 9c 07			ld a, (.dmark+2)  
0795 32 9b fd			ld (debug_mark+2),a  
0798 18 03			jr .pastdmark  
079a ..			.dmark: db "FNI"  
079d f1			.pastdmark: pop af  
079e			endm  
# End of macro DMARK
079e						CALLMONITOR 
079e cd a6 fd			call debug_vector  
07a1				endm  
# End of macro CALLMONITOR
07a1					endif 
07a1			.ff1:   	 
07a1 e5					push hl 
07a2 c5					push bc 
07a3 d5					push de 
07a4 cd ff 02				call se_readbyte 
07a7 5f					ld e,a 
07a8 23					inc hl 
07a9 cd ff 02				call se_readbyte 
07ac 57					ld d, a 
07ad e1					pop hl 
07ae e5					push hl 
07af cd cf 0f				call cmp16 
07b2 28 49				jr z, .fffound 
07b4			 
07b4 d1					pop de 
07b5 c1					pop bc 
07b6 e1					pop hl 
07b7			 
07b7					; is found? 
07b7					;cp e 
07b7					;ret z 
07b7			 
07b7 3e 40				ld a, STORE_BLOCK_PHY 
07b9 cd b1 0f				call addatohl 
07bc 10 e3				djnz .ff1 
07be			 
07be 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07c0			.ff2:   	 
07c0			 
07c0 e5					push hl 
07c1 c5					push bc 
07c2 d5					push de 
07c3 cd ff 02				call se_readbyte 
07c6 5f					ld e,a 
07c7 23					inc hl 
07c8 cd ff 02				call se_readbyte 
07cb 57					ld d, a 
07cc			 
07cc e1					pop hl 
07cd e5					push hl 
07ce cd cf 0f				call cmp16 
07d1 28 2a				jr z, .fffound 
07d3			 
07d3 d1					pop de 
07d4 c1					pop bc 
07d5 e1					pop hl 
07d6					; is found? 
07d6					;cp e 
07d6					;ret z 
07d6			 
07d6 3e 40				ld a, STORE_BLOCK_PHY 
07d8 cd b1 0f				call addatohl 
07db 10 e3				djnz .ff2 
07dd			 
07dd			 
07dd					if DEBUG_FORTH_WORDS 
07dd					DMARK "FN-" 
07dd f5				push af  
07de 3a f2 07			ld a, (.dmark)  
07e1 32 99 fd			ld (debug_mark),a  
07e4 3a f3 07			ld a, (.dmark+1)  
07e7 32 9a fd			ld (debug_mark+1),a  
07ea 3a f4 07			ld a, (.dmark+2)  
07ed 32 9b fd			ld (debug_mark+2),a  
07f0 18 03			jr .pastdmark  
07f2 ..			.dmark: db "FN-"  
07f5 f1			.pastdmark: pop af  
07f6			endm  
# End of macro DMARK
07f6					;	push af 
07f6					;	ld a, 'n' 
07f6					;	ld (debug_mark),a 
07f6					;	pop af 
07f6						CALLMONITOR 
07f6 cd a6 fd			call debug_vector  
07f9				endm  
# End of macro CALLMONITOR
07f9					endif 
07f9				; no free marks! 
07f9 21 00 00				ld hl, 0 
07fc c9				ret 
07fd			.fffound: 
07fd				 
07fd			 
07fd d1					pop de 
07fe c1					pop bc 
07ff e1					pop hl 
0800					if DEBUG_FORTH_WORDS 
0800					DMARK "FNF" 
0800 f5				push af  
0801 3a 15 08			ld a, (.dmark)  
0804 32 99 fd			ld (debug_mark),a  
0807 3a 16 08			ld a, (.dmark+1)  
080a 32 9a fd			ld (debug_mark+1),a  
080d 3a 17 08			ld a, (.dmark+2)  
0810 32 9b fd			ld (debug_mark+2),a  
0813 18 03			jr .pastdmark  
0815 ..			.dmark: db "FNF"  
0818 f1			.pastdmark: pop af  
0819			endm  
# End of macro DMARK
0819					;	push af 
0819					;	ld a, 'n' 
0819					;	ld (debug_mark),a 
0819					;	pop af 
0819						CALLMONITOR 
0819 cd a6 fd			call debug_vector  
081c				endm  
# End of macro CALLMONITOR
081c					endif 
081c c9				ret 
081d			 
081d			 
081d			 
081d			; Free Space 
081d			; ---------- 
081d			; 
081d			; With current bank 
081d			; 
081d			; Set block count to zero 
081d			; Starting with first logical block 
081d			;      Find free block  
081d			;      If block id given, increment block count 
081d			; 
081d			;  
081d			 
081d			 
081d			; hl contains count of free blocks 
081d			 
081d			storage_freeblocks: 
081d			 
081d				; now locate first 0 page to mark as a free block 
081d			 
081d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
081f 21 40 00			ld hl, STORE_BLOCK_PHY 
0822 11 00 00			ld de, 0 
0825			 
0825			.fb1:   	 
0825 e5					push hl 
0826 c5					push bc 
0827 d5					push de 
0828 cd ff 02				call se_readbyte 
082b d1					pop de 
082c c1					pop bc 
082d e1					pop hl 
082e			 
082e					; is free? 
082e			;		cp 0 
082e b7					or a 
082f 20 01				jr nz, .ff1cont 
0831 13					inc de 
0832			 
0832			.ff1cont: 
0832			 
0832			 
0832 3e 40				ld a, STORE_BLOCK_PHY 
0834 cd b1 0f				call addatohl 
0837 10 ec				djnz .fb1 
0839			 
0839 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
083b			.fb2:   	 
083b e5					push hl 
083c c5					push bc 
083d d5					push de 
083e cd ff 02				call se_readbyte 
0841 d1					pop de 
0842 c1					pop bc 
0843 e1					pop hl 
0844			 
0844					; is free? 
0844			;		cp 0 
0844 b7					or a 
0845 20 01				jr nz, .ff2cont 
0847 13					inc de 
0848			 
0848			.ff2cont: 
0848			 
0848 3e 40				ld a, STORE_BLOCK_PHY 
084a cd b1 0f				call addatohl 
084d 10 ec				djnz .fb2 
084f			 
084f eb				ex de, hl 
0850 c9				ret 
0851			 
0851			; Get File ID 
0851			; ----------- 
0851			; 
0851			; With current bank 
0851			;  
0851			; Load Block 0 Config 
0851			; Get max file id number 
0851			; For each logical block 
0851			;    Read block file id 
0851			;      If first block of file and dont have file id 
0851			;         if file get id and exit 
0851			 
0851			 
0851			 
0851			 
0851			; Create File 
0851			; ----------- 
0851			; 
0851			; With current bank  
0851			; Load Block 0 Config 
0851			; Get max file id number 
0851			; Increment file id number 
0851			; Save Config 
0851			; Find free block 
0851			; Set buffer with file name and file id 
0851			; Write buffer to free block  
0851			 
0851			 
0851			; hl point to file name 
0851			; hl returns file id 
0851			 
0851			; file format: 
0851			; byte 0 - file id 
0851			; byte 1 - extent number 
0851			; byte 2-> data 
0851			 
0851			; format for extent number 0: 
0851			; 
0851			; byte 0 - file id 
0851			; byte 1 - extent 0 
0851			; byte 2 - extent count 
0851			; byte 3 -> file name and meta data 
0851			 
0851			 
0851			storage_create: 
0851				if DEBUG_STORESE 
0851					DMARK "SCR" 
0851 f5				push af  
0852 3a 66 08			ld a, (.dmark)  
0855 32 99 fd			ld (debug_mark),a  
0858 3a 67 08			ld a, (.dmark+1)  
085b 32 9a fd			ld (debug_mark+1),a  
085e 3a 68 08			ld a, (.dmark+2)  
0861 32 9b fd			ld (debug_mark+2),a  
0864 18 03			jr .pastdmark  
0866 ..			.dmark: db "SCR"  
0869 f1			.pastdmark: pop af  
086a			endm  
# End of macro DMARK
086a					CALLMONITOR 
086a cd a6 fd			call debug_vector  
086d				endm  
# End of macro CALLMONITOR
086d				endif 
086d			 
086d e5				push hl		; save file name pointer 
086e			 
086e cd 05 05			call storage_get_block_0 
0871			 
0871 3a a8 f9			ld a,(store_page)	; get current file id 
0874 3c				inc a 
0875 32 a8 f9			ld (store_page),a 
0878				 
0878 32 9c f9			ld (store_tmpid),a			; save id 
087b			 
087b 21 00 00			ld hl, 0 
087e 11 a8 f9			ld de, store_page 
0881				if DEBUG_STORESE 
0881					DMARK "SCw" 
0881 f5				push af  
0882 3a 96 08			ld a, (.dmark)  
0885 32 99 fd			ld (debug_mark),a  
0888 3a 97 08			ld a, (.dmark+1)  
088b 32 9a fd			ld (debug_mark+1),a  
088e 3a 98 08			ld a, (.dmark+2)  
0891 32 9b fd			ld (debug_mark+2),a  
0894 18 03			jr .pastdmark  
0896 ..			.dmark: db "SCw"  
0899 f1			.pastdmark: pop af  
089a			endm  
# End of macro DMARK
089a					CALLMONITOR 
089a cd a6 fd			call debug_vector  
089d				endm  
# End of macro CALLMONITOR
089d				endif 
089d cd bc 04			call storage_write_block	 ; save update 
08a0			 
08a0				if DEBUG_STORESE 
08a0 11 a8 f9				ld de, store_page 
08a3					DMARK "SCC" 
08a3 f5				push af  
08a4 3a b8 08			ld a, (.dmark)  
08a7 32 99 fd			ld (debug_mark),a  
08aa 3a b9 08			ld a, (.dmark+1)  
08ad 32 9a fd			ld (debug_mark+1),a  
08b0 3a ba 08			ld a, (.dmark+2)  
08b3 32 9b fd			ld (debug_mark+2),a  
08b6 18 03			jr .pastdmark  
08b8 ..			.dmark: db "SCC"  
08bb f1			.pastdmark: pop af  
08bc			endm  
# End of macro DMARK
08bc					CALLMONITOR 
08bc cd a6 fd			call debug_vector  
08bf				endm  
# End of macro CALLMONITOR
08bf				endif 
08bf				;  
08bf				 
08bf 21 40 00			ld hl, STORE_BLOCK_PHY 
08c2 11 00 00			ld de, 0 
08c5 cd 83 07			call storage_findnextid 
08c8			 
08c8 22 93 f9			ld (store_tmppageid), hl    ; save page to use  
08cb			 
08cb				; TODO detect 0 = no spare blocks 
08cb			 
08cb				; hl now contains the free page to use for the file header page 
08cb			 
08cb				if DEBUG_STORESE 
08cb				DMARK "SCF" 
08cb f5				push af  
08cc 3a e0 08			ld a, (.dmark)  
08cf 32 99 fd			ld (debug_mark),a  
08d2 3a e1 08			ld a, (.dmark+1)  
08d5 32 9a fd			ld (debug_mark+1),a  
08d8 3a e2 08			ld a, (.dmark+2)  
08db 32 9b fd			ld (debug_mark+2),a  
08de 18 03			jr .pastdmark  
08e0 ..			.dmark: db "SCF"  
08e3 f1			.pastdmark: pop af  
08e4			endm  
# End of macro DMARK
08e4					CALLMONITOR 
08e4 cd a6 fd			call debug_vector  
08e7				endm  
# End of macro CALLMONITOR
08e7				endif 
08e7			 
08e7 22 93 f9			ld (store_tmppageid), hl 
08ea				 
08ea 3a 9c f9			ld a,(store_tmpid)    ; get file id 
08ed			;	ld a, (store_filecache)			; save to cache 
08ed			 
08ed 32 a8 f9			ld (store_page),a    ; set page id 
08f0 3e 00			ld a, 0			 ; extent 0 is file header 
08f2 32 a9 f9			ld (store_page+1), a   ; set file extent 
08f5			 
08f5 32 aa f9			ld (store_page+2), a   ; extent count for the file 
08f8			 
08f8			;	inc hl 		; init block 0 of file 
08f8			;	inc hl   		; skip file and extent id 
08f8			 ;       ld a, 0 
08f8			;	ld (hl),a 
08f8			;	ld a, (store_filecache+1)  	; save to cache 
08f8			 
08f8			;	inc hl    ; file name 
08f8				 
08f8				 
08f8 11 ab f9			ld de, store_page+3    ; get buffer for term string to use as file name 
08fb				if DEBUG_STORESE 
08fb					DMARK "SCc" 
08fb f5				push af  
08fc 3a 10 09			ld a, (.dmark)  
08ff 32 99 fd			ld (debug_mark),a  
0902 3a 11 09			ld a, (.dmark+1)  
0905 32 9a fd			ld (debug_mark+1),a  
0908 3a 12 09			ld a, (.dmark+2)  
090b 32 9b fd			ld (debug_mark+2),a  
090e 18 03			jr .pastdmark  
0910 ..			.dmark: db "SCc"  
0913 f1			.pastdmark: pop af  
0914			endm  
# End of macro DMARK
0914					CALLMONITOR 
0914 cd a6 fd			call debug_vector  
0917				endm  
# End of macro CALLMONITOR
0917				endif 
0917 e1				pop hl    ; get zero term string 
0918 e5				push hl 
0919 3e 00			ld a, 0 
091b cd 14 13			call strlent 
091e 23				inc hl   ; cover zero term 
091f 06 00			ld b,0 
0921 4d				ld c,l 
0922 e1				pop hl 
0923				;ex de, hl 
0923				if DEBUG_STORESE 
0923					DMARK "SCa" 
0923 f5				push af  
0924 3a 38 09			ld a, (.dmark)  
0927 32 99 fd			ld (debug_mark),a  
092a 3a 39 09			ld a, (.dmark+1)  
092d 32 9a fd			ld (debug_mark+1),a  
0930 3a 3a 09			ld a, (.dmark+2)  
0933 32 9b fd			ld (debug_mark+2),a  
0936 18 03			jr .pastdmark  
0938 ..			.dmark: db "SCa"  
093b f1			.pastdmark: pop af  
093c			endm  
# End of macro DMARK
093c					;push af 
093c					;ld a, 'a' 
093c					;ld (debug_mark),a 
093c					;pop af 
093c					CALLMONITOR 
093c cd a6 fd			call debug_vector  
093f				endm  
# End of macro CALLMONITOR
093f				endif 
093f ed b0			ldir    ; copy zero term string 
0941				if DEBUG_STORESE 
0941					DMARK "SCA" 
0941 f5				push af  
0942 3a 56 09			ld a, (.dmark)  
0945 32 99 fd			ld (debug_mark),a  
0948 3a 57 09			ld a, (.dmark+1)  
094b 32 9a fd			ld (debug_mark+1),a  
094e 3a 58 09			ld a, (.dmark+2)  
0951 32 9b fd			ld (debug_mark+2),a  
0954 18 03			jr .pastdmark  
0956 ..			.dmark: db "SCA"  
0959 f1			.pastdmark: pop af  
095a			endm  
# End of macro DMARK
095a					CALLMONITOR 
095a cd a6 fd			call debug_vector  
095d				endm  
# End of macro CALLMONITOR
095d				endif 
095d			 
095d				; write file header page 
095d			 
095d 2a 93 f9			ld hl,(store_tmppageid) 
0960 11 a8 f9			ld de, store_page 
0963				if DEBUG_STORESE 
0963					DMARK "SCb" 
0963 f5				push af  
0964 3a 78 09			ld a, (.dmark)  
0967 32 99 fd			ld (debug_mark),a  
096a 3a 79 09			ld a, (.dmark+1)  
096d 32 9a fd			ld (debug_mark+1),a  
0970 3a 7a 09			ld a, (.dmark+2)  
0973 32 9b fd			ld (debug_mark+2),a  
0976 18 03			jr .pastdmark  
0978 ..			.dmark: db "SCb"  
097b f1			.pastdmark: pop af  
097c			endm  
# End of macro DMARK
097c					;push af 
097c					;ld a, 'b' 
097c					;ld (debug_mark),a 
097c					;pop af 
097c					CALLMONITOR 
097c cd a6 fd			call debug_vector  
097f				endm  
# End of macro CALLMONITOR
097f				endif 
097f cd bc 04			call storage_write_block 
0982			 
0982 3a 9c f9			ld a, (store_tmpid) 
0985 6f				ld l, a 
0986 26 00			ld h,0 
0988				if DEBUG_STORESE 
0988					DMARK "SCz" 
0988 f5				push af  
0989 3a 9d 09			ld a, (.dmark)  
098c 32 99 fd			ld (debug_mark),a  
098f 3a 9e 09			ld a, (.dmark+1)  
0992 32 9a fd			ld (debug_mark+1),a  
0995 3a 9f 09			ld a, (.dmark+2)  
0998 32 9b fd			ld (debug_mark+2),a  
099b 18 03			jr .pastdmark  
099d ..			.dmark: db "SCz"  
09a0 f1			.pastdmark: pop af  
09a1			endm  
# End of macro DMARK
09a1					CALLMONITOR 
09a1 cd a6 fd			call debug_vector  
09a4				endm  
# End of macro CALLMONITOR
09a4				endif 
09a4 c9				ret 
09a5				 
09a5			 
09a5			 
09a5			; 
09a5			; Read File 
09a5			; 
09a5			; h - file id to locate 
09a5			; l - extent to locate 
09a5			; de - pointer to string to read into 
09a5			; 
09a5			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09a5			 
09a5			.sr_fail: 
09a5 d1				pop de 
09a6 c9				ret 
09a7			 
09a7			storage_read: 
09a7			 
09a7			 
09a7 d5				push de 
09a8			 
09a8			; TODO BUG the above push is it popped before the RET Z? 
09a8			 
09a8			; TODO how to handle multiple part blocks 
09a8			 
09a8				; locate file extent to read 
09a8			 
09a8 5c				ld e, h 
09a9 55				ld d, l 
09aa			 
09aa			.srext: 
09aa 22 a6 f9			ld (store_readptr), hl     ; save the current extent to load 
09ad ed 53 a4 f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09b1			 
09b1 21 40 00			ld hl, STORE_BLOCK_PHY 
09b4				if DEBUG_STORESE 
09b4					DMARK "sre" 
09b4 f5				push af  
09b5 3a c9 09			ld a, (.dmark)  
09b8 32 99 fd			ld (debug_mark),a  
09bb 3a ca 09			ld a, (.dmark+1)  
09be 32 9a fd			ld (debug_mark+1),a  
09c1 3a cb 09			ld a, (.dmark+2)  
09c4 32 9b fd			ld (debug_mark+2),a  
09c7 18 03			jr .pastdmark  
09c9 ..			.dmark: db "sre"  
09cc f1			.pastdmark: pop af  
09cd			endm  
# End of macro DMARK
09cd					CALLMONITOR 
09cd cd a6 fd			call debug_vector  
09d0				endm  
# End of macro CALLMONITOR
09d0				endif 
09d0 cd 83 07			call storage_findnextid 
09d3			 
09d3				if DEBUG_STORESE 
09d3					DMARK "srf" 
09d3 f5				push af  
09d4 3a e8 09			ld a, (.dmark)  
09d7 32 99 fd			ld (debug_mark),a  
09da 3a e9 09			ld a, (.dmark+1)  
09dd 32 9a fd			ld (debug_mark+1),a  
09e0 3a ea 09			ld a, (.dmark+2)  
09e3 32 9b fd			ld (debug_mark+2),a  
09e6 18 03			jr .pastdmark  
09e8 ..			.dmark: db "srf"  
09eb f1			.pastdmark: pop af  
09ec			endm  
# End of macro DMARK
09ec					CALLMONITOR 
09ec cd a6 fd			call debug_vector  
09ef				endm  
# End of macro CALLMONITOR
09ef				endif 
09ef cd da 0f			call ishlzero 
09f2			;	ld a, l 
09f2			;	add h 
09f2			;	cp 0 
09f2 28 b1			jr z,.sr_fail			; block not found so EOF 
09f4			 
09f4				; save current address for use by higher level words etc 
09f4			 
09f4 22 99 f9			ld (store_openaddr),hl 
09f7			 
09f7			 
09f7				; hl contains page number to load 
09f7 d1				pop de   ; get storage 
09f8 ed 53 a4 f9		ld (store_readbuf), de     ; current buffer to load in to 
09fc d5				push de 
09fd				if DEBUG_STORESE 
09fd					DMARK "srg" 
09fd f5				push af  
09fe 3a 12 0a			ld a, (.dmark)  
0a01 32 99 fd			ld (debug_mark),a  
0a04 3a 13 0a			ld a, (.dmark+1)  
0a07 32 9a fd			ld (debug_mark+1),a  
0a0a 3a 14 0a			ld a, (.dmark+2)  
0a0d 32 9b fd			ld (debug_mark+2),a  
0a10 18 03			jr .pastdmark  
0a12 ..			.dmark: db "srg"  
0a15 f1			.pastdmark: pop af  
0a16			endm  
# End of macro DMARK
0a16					CALLMONITOR 
0a16 cd a6 fd			call debug_vector  
0a19				endm  
# End of macro CALLMONITOR
0a19				endif 
0a19 cd 57 04			call storage_read_block 
0a1c			 
0a1c				; if this a continuation read??? 
0a1c			 
0a1c 2a a4 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a1f			 
0a1f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a21 cd b1 0f			call addatohl 
0a24 7e				ld a,(hl) 
0a25			;	cp 0 
0a25 b7				or a 
0a26 28 02			jr z, .markiscont 
0a28 3e ff			ld a, 255 
0a2a			 
0a2a			.markiscont: 
0a2a 32 9b f9			ld (store_readcont), a 
0a2d			 
0a2d				if DEBUG_STORESE 
0a2d					DMARK "srC" 
0a2d f5				push af  
0a2e 3a 42 0a			ld a, (.dmark)  
0a31 32 99 fd			ld (debug_mark),a  
0a34 3a 43 0a			ld a, (.dmark+1)  
0a37 32 9a fd			ld (debug_mark+1),a  
0a3a 3a 44 0a			ld a, (.dmark+2)  
0a3d 32 9b fd			ld (debug_mark+2),a  
0a40 18 03			jr .pastdmark  
0a42 ..			.dmark: db "srC"  
0a45 f1			.pastdmark: pop af  
0a46			endm  
# End of macro DMARK
0a46					CALLMONITOR 
0a46 cd a6 fd			call debug_vector  
0a49				endm  
# End of macro CALLMONITOR
0a49				endif 
0a49				; only short reads enabled 
0a49			 
0a49 3a a3 f9			ld a, (store_longread) 
0a4c			;	cp 0 
0a4c b7				or a 
0a4d ca 19 0b			jp z, .readdone 
0a50			 
0a50			; TODO if block has no zeros then need to read next block  
0a50			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a50			; check last byte of physical block. 
0a50			; if not zero then the next block needs to be loaded 
0a50			 
0a50			 
0a50 2a a4 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a53			 
0a53 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a55 cd b1 0f			call addatohl 
0a58				;dec hl 
0a58 7e				ld a,(hl) 
0a59				if DEBUG_STORESE 
0a59					DMARK "sr?" 
0a59 f5				push af  
0a5a 3a 6e 0a			ld a, (.dmark)  
0a5d 32 99 fd			ld (debug_mark),a  
0a60 3a 6f 0a			ld a, (.dmark+1)  
0a63 32 9a fd			ld (debug_mark+1),a  
0a66 3a 70 0a			ld a, (.dmark+2)  
0a69 32 9b fd			ld (debug_mark+2),a  
0a6c 18 03			jr .pastdmark  
0a6e ..			.dmark: db "sr?"  
0a71 f1			.pastdmark: pop af  
0a72			endm  
# End of macro DMARK
0a72					CALLMONITOR 
0a72 cd a6 fd			call debug_vector  
0a75				endm  
# End of macro CALLMONITOR
0a75				endif 
0a75			;	cp 0 
0a75 b7				or a 
0a76 ca 19 0b			jp z, .readdone 
0a79			 
0a79				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a79			 
0a79 23				inc hl 
0a7a			 
0a7a 22 a4 f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a7d			 
0a7d ed 5b a6 f9		ld de, (store_readptr)     ; save the current extent to load 
0a81			 
0a81 eb				ex de, hl 
0a82			 
0a82				; next ext 
0a82			 
0a82 23				inc hl 
0a83 22 a6 f9			ld  (store_readptr), hl     ; save the current extent to load 
0a86			 
0a86				if DEBUG_STORESE 
0a86					DMARK "sF2" 
0a86 f5				push af  
0a87 3a 9b 0a			ld a, (.dmark)  
0a8a 32 99 fd			ld (debug_mark),a  
0a8d 3a 9c 0a			ld a, (.dmark+1)  
0a90 32 9a fd			ld (debug_mark+1),a  
0a93 3a 9d 0a			ld a, (.dmark+2)  
0a96 32 9b fd			ld (debug_mark+2),a  
0a99 18 03			jr .pastdmark  
0a9b ..			.dmark: db "sF2"  
0a9e f1			.pastdmark: pop af  
0a9f			endm  
# End of macro DMARK
0a9f					CALLMONITOR 
0a9f cd a6 fd			call debug_vector  
0aa2				endm  
# End of macro CALLMONITOR
0aa2				endif 
0aa2			 
0aa2				; get and load block 
0aa2			 
0aa2 cd 83 07			call storage_findnextid 
0aa5			 
0aa5				if DEBUG_STORESE 
0aa5					DMARK "sf2" 
0aa5 f5				push af  
0aa6 3a ba 0a			ld a, (.dmark)  
0aa9 32 99 fd			ld (debug_mark),a  
0aac 3a bb 0a			ld a, (.dmark+1)  
0aaf 32 9a fd			ld (debug_mark+1),a  
0ab2 3a bc 0a			ld a, (.dmark+2)  
0ab5 32 9b fd			ld (debug_mark+2),a  
0ab8 18 03			jr .pastdmark  
0aba ..			.dmark: db "sf2"  
0abd f1			.pastdmark: pop af  
0abe			endm  
# End of macro DMARK
0abe					CALLMONITOR 
0abe cd a6 fd			call debug_vector  
0ac1				endm  
# End of macro CALLMONITOR
0ac1				endif 
0ac1 cd da 0f			call ishlzero 
0ac4			;	ld a, l 
0ac4			;	add h 
0ac4			;	cp 0 
0ac4 ca a5 09			jp z,.sr_fail			; block not found so EOF 
0ac7				 
0ac7				; save current address for use by higher level words etc 
0ac7			 
0ac7 22 99 f9			ld (store_openaddr),hl 
0aca			 
0aca cd 57 04			call storage_read_block 
0acd			 
0acd				; on a continuation block, we now have the file id and ext in the middle of the block 
0acd				; we need to pull everything back  
0acd			 
0acd ed 5b a4 f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0ad1 2a a4 f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0ad4 23				inc hl 
0ad5 23				inc hl     ; skip id and ext 
0ad6 01 40 00			ld bc, STORE_BLOCK_PHY 
0ad9				if DEBUG_STORESE 
0ad9					DMARK "SR<" 
0ad9 f5				push af  
0ada 3a ee 0a			ld a, (.dmark)  
0add 32 99 fd			ld (debug_mark),a  
0ae0 3a ef 0a			ld a, (.dmark+1)  
0ae3 32 9a fd			ld (debug_mark+1),a  
0ae6 3a f0 0a			ld a, (.dmark+2)  
0ae9 32 9b fd			ld (debug_mark+2),a  
0aec 18 03			jr .pastdmark  
0aee ..			.dmark: db "SR<"  
0af1 f1			.pastdmark: pop af  
0af2			endm  
# End of macro DMARK
0af2					CALLMONITOR 
0af2 cd a6 fd			call debug_vector  
0af5				endm  
# End of macro CALLMONITOR
0af5				endif 
0af5 ed b0			ldir     ; copy data 
0af7			 
0af7				; move the pointer back and pretend we have a full buffer for next recheck 
0af7			 
0af7 1b				dec de 
0af8 1b				dec de 
0af9			 
0af9			; TODO do pop below now short circuit loop????? 
0af9 c1				pop bc     ; get rid of spare de on stack 
0afa				if DEBUG_STORESE 
0afa					DMARK "SR>" 
0afa f5				push af  
0afb 3a 0f 0b			ld a, (.dmark)  
0afe 32 99 fd			ld (debug_mark),a  
0b01 3a 10 0b			ld a, (.dmark+1)  
0b04 32 9a fd			ld (debug_mark+1),a  
0b07 3a 11 0b			ld a, (.dmark+2)  
0b0a 32 9b fd			ld (debug_mark+2),a  
0b0d 18 03			jr .pastdmark  
0b0f ..			.dmark: db "SR>"  
0b12 f1			.pastdmark: pop af  
0b13			endm  
# End of macro DMARK
0b13					CALLMONITOR 
0b13 cd a6 fd			call debug_vector  
0b16				endm  
# End of macro CALLMONITOR
0b16				endif 
0b16 c3 aa 09			jp .srext 
0b19			 
0b19			 
0b19			 
0b19			 
0b19			 
0b19			.readdone:		 
0b19 e1				pop hl 		 ; return start of data to show as not EOF 
0b1a 23				inc hl   ; past file id 
0b1b 23				inc hl   ; past ext 
0b1c				if DEBUG_STORESE 
0b1c					DMARK "SRe" 
0b1c f5				push af  
0b1d 3a 31 0b			ld a, (.dmark)  
0b20 32 99 fd			ld (debug_mark),a  
0b23 3a 32 0b			ld a, (.dmark+1)  
0b26 32 9a fd			ld (debug_mark+1),a  
0b29 3a 33 0b			ld a, (.dmark+2)  
0b2c 32 9b fd			ld (debug_mark+2),a  
0b2f 18 03			jr .pastdmark  
0b31 ..			.dmark: db "SRe"  
0b34 f1			.pastdmark: pop af  
0b35			endm  
# End of macro DMARK
0b35					CALLMONITOR 
0b35 cd a6 fd			call debug_vector  
0b38				endm  
# End of macro CALLMONITOR
0b38				endif 
0b38 c9					ret 
0b39			 
0b39			 
0b39			 
0b39			; 
0b39			; Append File 
0b39			; 
0b39			; hl - file id to locate 
0b39			; de - pointer to (multi block) string to write 
0b39			 
0b39			.sa_notfound: 
0b39 d1				pop de 
0b3a c9				ret 
0b3b			 
0b3b			 
0b3b			storage_append: 
0b3b				; hl -  file id to append to 
0b3b				; de - string to append 
0b3b			 
0b3b d5				push de 
0b3c				 
0b3c				if DEBUG_STORESE 
0b3c					DMARK "AP1" 
0b3c f5				push af  
0b3d 3a 51 0b			ld a, (.dmark)  
0b40 32 99 fd			ld (debug_mark),a  
0b43 3a 52 0b			ld a, (.dmark+1)  
0b46 32 9a fd			ld (debug_mark+1),a  
0b49 3a 53 0b			ld a, (.dmark+2)  
0b4c 32 9b fd			ld (debug_mark+2),a  
0b4f 18 03			jr .pastdmark  
0b51 ..			.dmark: db "AP1"  
0b54 f1			.pastdmark: pop af  
0b55			endm  
# End of macro DMARK
0b55					CALLMONITOR 
0b55 cd a6 fd			call debug_vector  
0b58				endm  
# End of macro CALLMONITOR
0b58				endif 
0b58			 
0b58 7d				ld a, l 
0b59 32 9c f9			ld (store_tmpid), a 
0b5c			 
0b5c				; get file header  
0b5c			 
0b5c 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b5e 3a 9c f9			ld a, (store_tmpid) 
0b61 5f				ld e, a 
0b62			 
0b62 21 40 00				ld hl, STORE_BLOCK_PHY 
0b65 cd 83 07				call storage_findnextid 
0b68			 
0b68 cd da 0f			call ishlzero 
0b6b 28 cc			jr z, .sa_notfound 
0b6d			 
0b6d 22 93 f9			ld (store_tmppageid), hl 
0b70			 
0b70				; TODO handle file id not found 
0b70			 
0b70				if DEBUG_STORESE 
0b70					DMARK "AP2" 
0b70 f5				push af  
0b71 3a 85 0b			ld a, (.dmark)  
0b74 32 99 fd			ld (debug_mark),a  
0b77 3a 86 0b			ld a, (.dmark+1)  
0b7a 32 9a fd			ld (debug_mark+1),a  
0b7d 3a 87 0b			ld a, (.dmark+2)  
0b80 32 9b fd			ld (debug_mark+2),a  
0b83 18 03			jr .pastdmark  
0b85 ..			.dmark: db "AP2"  
0b88 f1			.pastdmark: pop af  
0b89			endm  
# End of macro DMARK
0b89					CALLMONITOR 
0b89 cd a6 fd			call debug_vector  
0b8c				endm  
# End of macro CALLMONITOR
0b8c				endif 
0b8c			 
0b8c				; update file extent count 
0b8c			 
0b8c 11 a8 f9			ld de, store_page 
0b8f			 
0b8f cd 57 04			call storage_read_block 
0b92			 
0b92				if DEBUG_STORESE 
0b92					DMARK "AP3" 
0b92 f5				push af  
0b93 3a a7 0b			ld a, (.dmark)  
0b96 32 99 fd			ld (debug_mark),a  
0b99 3a a8 0b			ld a, (.dmark+1)  
0b9c 32 9a fd			ld (debug_mark+1),a  
0b9f 3a a9 0b			ld a, (.dmark+2)  
0ba2 32 9b fd			ld (debug_mark+2),a  
0ba5 18 03			jr .pastdmark  
0ba7 ..			.dmark: db "AP3"  
0baa f1			.pastdmark: pop af  
0bab			endm  
# End of macro DMARK
0bab					CALLMONITOR 
0bab cd a6 fd			call debug_vector  
0bae				endm  
# End of macro CALLMONITOR
0bae				endif 
0bae			;	ld (store_tmppageid), hl 
0bae			 
0bae 3a aa f9			ld a, (store_page+2) 
0bb1 3c				inc a 
0bb2 32 aa f9			ld (store_page+2), a 
0bb5 32 9b f9			ld (store_tmpext), a 
0bb8				 
0bb8				if DEBUG_STORESE 
0bb8					DMARK "AP3" 
0bb8 f5				push af  
0bb9 3a cd 0b			ld a, (.dmark)  
0bbc 32 99 fd			ld (debug_mark),a  
0bbf 3a ce 0b			ld a, (.dmark+1)  
0bc2 32 9a fd			ld (debug_mark+1),a  
0bc5 3a cf 0b			ld a, (.dmark+2)  
0bc8 32 9b fd			ld (debug_mark+2),a  
0bcb 18 03			jr .pastdmark  
0bcd ..			.dmark: db "AP3"  
0bd0 f1			.pastdmark: pop af  
0bd1			endm  
# End of macro DMARK
0bd1					CALLMONITOR 
0bd1 cd a6 fd			call debug_vector  
0bd4				endm  
# End of macro CALLMONITOR
0bd4				endif 
0bd4 2a 93 f9			ld hl, (store_tmppageid) 
0bd7 11 a8 f9			ld de, store_page 
0bda cd bc 04			call storage_write_block 
0bdd			 
0bdd				; find free block 
0bdd			 
0bdd 11 00 00			ld de, 0			 ; file extent to locate 
0be0			 
0be0 21 40 00				ld hl, STORE_BLOCK_PHY 
0be3 cd 83 07				call storage_findnextid 
0be6 cd da 0f			call ishlzero 
0be9 ca 39 0b			jp z, .sa_notfound 
0bec			 
0bec					; TODO handle no space left 
0bec					 
0bec 22 93 f9				ld (store_tmppageid), hl 
0bef			 
0bef				if DEBUG_STORESE 
0bef					DMARK "AP4" 
0bef f5				push af  
0bf0 3a 04 0c			ld a, (.dmark)  
0bf3 32 99 fd			ld (debug_mark),a  
0bf6 3a 05 0c			ld a, (.dmark+1)  
0bf9 32 9a fd			ld (debug_mark+1),a  
0bfc 3a 06 0c			ld a, (.dmark+2)  
0bff 32 9b fd			ld (debug_mark+2),a  
0c02 18 03			jr .pastdmark  
0c04 ..			.dmark: db "AP4"  
0c07 f1			.pastdmark: pop af  
0c08			endm  
# End of macro DMARK
0c08					CALLMONITOR 
0c08 cd a6 fd			call debug_vector  
0c0b				endm  
# End of macro CALLMONITOR
0c0b				endif 
0c0b					; init the buffer with zeros so we can id if the buffer is full or not 
0c0b			 
0c0b e5					push hl 
0c0c c5					push bc 
0c0d			 
0c0d 21 a8 f9				ld hl, store_page 
0c10 06 40				ld b, STORE_BLOCK_PHY 
0c12			;		ld a, 0 
0c12 36 00		.zeroblock:	ld (hl), 0 
0c14 23					inc hl 
0c15 10 fb				djnz .zeroblock 
0c17			 
0c17 c1					pop bc 
0c18 e1					pop hl 
0c19			 
0c19					; construct block 
0c19			 
0c19 3a 9c f9				ld a, (store_tmpid) 
0c1c 32 a8 f9				ld (store_page), a   ; file id 
0c1f 3a 9b f9				ld a, (store_tmpext)   ; extent for this block 
0c22 32 a9 f9				ld (store_page+1), a 
0c25			 
0c25 e1					pop hl    ; get string to write 
0c26 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c28 11 aa f9				ld de, store_page+2 
0c2b			 
0c2b				if DEBUG_STORESE 
0c2b					DMARK "AP5" 
0c2b f5				push af  
0c2c 3a 40 0c			ld a, (.dmark)  
0c2f 32 99 fd			ld (debug_mark),a  
0c32 3a 41 0c			ld a, (.dmark+1)  
0c35 32 9a fd			ld (debug_mark+1),a  
0c38 3a 42 0c			ld a, (.dmark+2)  
0c3b 32 9b fd			ld (debug_mark+2),a  
0c3e 18 03			jr .pastdmark  
0c40 ..			.dmark: db "AP5"  
0c43 f1			.pastdmark: pop af  
0c44			endm  
# End of macro DMARK
0c44					CALLMONITOR 
0c44 cd a6 fd			call debug_vector  
0c47				endm  
# End of macro CALLMONITOR
0c47				endif 
0c47			 
0c47			 
0c47			 
0c47					; fill buffer with data until end of string or full block 
0c47			 
0c47 7e			.appd:		ld a, (hl) 
0c48 12					ld (de), a 
0c49			;		cp 0 
0c49 b7					or a 
0c4a 28 04				jr z, .appdone 
0c4c 23					inc hl 
0c4d 13					inc de 
0c4e 10 f7				djnz .appd 
0c50			 
0c50 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c51 f5					push af   		; save last byte dumped 
0c52			 
0c52			 
0c52 2a 93 f9			ld hl, (store_tmppageid) 
0c55 11 a8 f9			ld de, store_page 
0c58				if DEBUG_STORESE 
0c58					DMARK "AP6" 
0c58 f5				push af  
0c59 3a 6d 0c			ld a, (.dmark)  
0c5c 32 99 fd			ld (debug_mark),a  
0c5f 3a 6e 0c			ld a, (.dmark+1)  
0c62 32 9a fd			ld (debug_mark+1),a  
0c65 3a 6f 0c			ld a, (.dmark+2)  
0c68 32 9b fd			ld (debug_mark+2),a  
0c6b 18 03			jr .pastdmark  
0c6d ..			.dmark: db "AP6"  
0c70 f1			.pastdmark: pop af  
0c71			endm  
# End of macro DMARK
0c71					CALLMONITOR 
0c71 cd a6 fd			call debug_vector  
0c74				endm  
# End of macro CALLMONITOR
0c74				endif 
0c74 cd bc 04				call storage_write_block 
0c77			 
0c77			 
0c77				; was that a full block of data written? 
0c77				; any more to write out? 
0c77			 
0c77				; if yes then set vars and jump to start of function again 
0c77			 
0c77 f1					pop af 
0c78 d1					pop de 
0c79			 
0c79					;cp 0		 ; no, string was fully written 
0c79 b7					or a 
0c7a c8					ret z 
0c7b			 
0c7b					; setup vars for next cycle 
0c7b			 
0c7b 3a 9c f9				ld a, (store_tmpid) 
0c7e 6f					ld l, a 
0c7f 26 00				ld h, 0 
0c81			 
0c81 c3 3b 0b			 	jp storage_append	 ; yes, need to write out some more 
0c84			 
0c84			 
0c84			 
0c84			 
0c84			 
0c84			 
0c84			 
0c84			if DEBUG_STORECF 
0c84			storageput:	 
0c84					ret 
0c84			storageread: 
0c84					ld hl, store_page 
0c84					ld b, 200 
0c84			;		ld a,0 
0c84			.src:		ld (hl),0 
0c84					inc hl 
0c84					djnz .src 
0c84					 
0c84			 
0c84					ld de, 0 
0c84					ld bc, 1 
0c84					ld hl, store_page 
0c84					call cfRead 
0c84			 
0c84				call cfGetError 
0c84				ld hl,scratch 
0c84				call hexout 
0c84				ld hl, scratch+2 
0c84			;	ld a, 0 
0c84				ld (hl),0 
0c84				ld de, scratch 
0c84				ld a,display_row_1 
0c84				call str_at_display 
0c84				call update_display 
0c84			 
0c84					ld hl, store_page 
0c84					ld (os_cur_ptr),hl 
0c84			 
0c84					ret 
0c84			endif 
0c84			 
0c84			 
0c84			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c84			 
0c84			storage_clear_page: 
0c84 e5				push hl 
0c85 d5				push de 
0c86 c5				push bc 
0c87 21 a8 f9			ld hl, store_page 
0c8a			;	ld a, 0 
0c8a 36 00			ld (hl), 0 
0c8c			 
0c8c 11 a9 f9			ld de, store_page+1 
0c8f 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0c92			 
0c92 ed b0			ldir 
0c94				 
0c94 c1				pop bc 
0c95 d1				pop de 
0c96 e1				pop hl 
0c97 c9				ret 
0c98			 
0c98			; eof 
# End of file firmware_storage.asm
0c98			  
0c98			; support routines for above hardware abstraction layer  
0c98			  
0c98			include "firmware_general.asm"        ; general support functions  
0c98			 
0c98			; word look up 
0c98			 
0c98			; in 
0c98			; a is the index 
0c98			; hl is pointer start of array 
0c98			; 
0c98			; returns 
0c98			; hl to the word 
0c98			; 
0c98			 
0c98			table_lookup:  
0c98 d5					push de 
0c99 eb					ex de, hl 
0c9a			 
0c9a 6f					ld l, a 
0c9b 26 00				ld h, 0 
0c9d 29					add hl, hl 
0c9e 19					add hl, de 
0c9f 7e					ld a, (hl) 
0ca0 23					inc hl 
0ca1 66					ld h,(hl) 
0ca2 6f					ld l, a 
0ca3			 
0ca3 d1					pop de 
0ca4 c9					ret 
0ca5			 
0ca5			; Delay loops 
0ca5			 
0ca5			 
0ca5			 
0ca5			aDelayInMS: 
0ca5 c5				push bc 
0ca6 47				ld b,a 
0ca7			msdelay: 
0ca7 c5				push bc 
0ca8				 
0ca8			 
0ca8 01 41 00			ld bc,041h 
0cab cd c3 0c			call delayloop 
0cae c1				pop bc 
0caf 05				dec b 
0cb0 20 f5			jr nz,msdelay 
0cb2			 
0cb2			;if CPU_CLOCK_8MHZ 
0cb2			;msdelay8: 
0cb2			;	push bc 
0cb2			;	 
0cb2			; 
0cb2			;	ld bc,041h 
0cb2			;	call delayloop 
0cb2			;	pop bc 
0cb2			;	dec b 
0cb2			;	jr nz,msdelay8 
0cb2			;endif 
0cb2			 
0cb2			 
0cb2 c1				pop bc 
0cb3 c9				ret 
0cb4			 
0cb4			 
0cb4			delay250ms: 
0cb4				;push de 
0cb4 01 00 40			ld bc, 04000h 
0cb7 c3 c3 0c			jp delayloop 
0cba			delay500ms: 
0cba				;push de 
0cba 01 00 80			ld bc, 08000h 
0cbd c3 c3 0c			jp delayloop 
0cc0			delay1s: 
0cc0				;push bc 
0cc0			   ; Clobbers A, d and e 
0cc0 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0cc3			delayloop: 
0cc3 c5			    push bc 
0cc4			 
0cc4			if BASE_CPM 
0cc4				ld bc, CPM_DELAY_TUNE 
0cc4			.cpmloop: 
0cc4				push bc 
0cc4			 
0cc4			endif 
0cc4			 
0cc4			 
0cc4			 
0cc4			delayloopi: 
0cc4			;	push bc 
0cc4			;.dl: 
0cc4 cb 47		    bit     0,a    	; 8 
0cc6 cb 47		    bit     0,a    	; 8 
0cc8 cb 47		    bit     0,a    	; 8 
0cca e6 ff		    and     255  	; 7 
0ccc 0b			    dec     bc      	; 6 
0ccd 79			    ld      a,c     	; 4 
0cce b0			    or      b     	; 4 
0ccf c2 c4 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cd2			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cd2				;pop de 
0cd2			;pop bc 
0cd2			 
0cd2			if BASE_CPM 
0cd2				pop bc 
0cd2				 
0cd2			    dec     bc      	; 6 
0cd2			    ld      a,c     	; 4 
0cd2			    or      b     	; 4 
0cd2			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cd2				 
0cd2			 
0cd2			endif 
0cd2			;if CPU_CLOCK_8MHZ 
0cd2			;    pop bc 
0cd2			;    push bc 
0cd2			;.dl8: 
0cd2			;    bit     0,a    	; 8 
0cd2			;    bit     0,a    	; 8 
0cd2			;    bit     0,a    	; 8 
0cd2			;    and     255  	; 7 
0cd2			;    dec     bc      	; 6 
0cd2			;    ld      a,c     	; 4 
0cd2			;    or      b     	; 4 
0cd2			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cd2			;endif 
0cd2			 
0cd2			;if CPU_CLOCK_10MHZ 
0cd2			;    pop bc 
0cd2			;    push bc 
0cd2			;.dl8: 
0cd2			;    bit     0,a    	; 8 
0cd2			;    bit     0,a    	; 8 
0cd2			;    bit     0,a    	; 8 
0cd2			;    and     255  	; 7 
0cd2			;    dec     bc      	; 6 
0cd2			;    ld      a,c     	; 4 
0cd2			;    or      b     	; 4 
0cd2			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cd2			;endif 
0cd2 c1			    pop bc 
0cd3			 
0cd3 c9				ret 
0cd4			 
0cd4			; look for any ldir blank calls and replace with 
0cd4			; hl is the start address 
0cd4			; b is the number of bytes 
0cd4			; a is the char to fill 
0cd4			 
0cd4			 
0cd4			filllen: 
0cd4 77				LD (HL),A      ;STORE BYTE 
0cd5 23				INC HL      ; BUMP POINTER 
0cd6 10 fc			DJNZ   filllen      ;  CONTINUE IF B NOT 0 
0cd8 c9				ret 
0cd9			 
0cd9			; eof 
# End of file firmware_general.asm
0cd9			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cd9			; display routines that use the physical hardware abstraction layer 
0cd9			 
0cd9			 
0cd9			; Display an activity indicator 
0cd9			; Each call returns the new char pointed to in hl 
0cd9			 
0cd9			active: 
0cd9 3a f4 fa			ld a, (display_active) 
0cdc fe 06			cp 6 
0cde			 
0cde 20 02			jr nz, .sne 
0ce0				; gone past the last one reset sequence 
0ce0 3e ff			ld a, 255 
0ce2			 
0ce2			.sne:   
0ce2				; get the next char in seq 
0ce2 3c				inc a 
0ce3 32 f4 fa			ld (display_active), a 
0ce6			 
0ce6				; look up the string in the table 
0ce6 21 fd 0c			ld hl, actseq 
0ce9 cb 27			sla a 
0ceb cd b1 0f			call addatohl 
0cee cd 7b 23			call loadwordinhl 
0cf1			 
0cf1				; forth will write the to string when pushing so move from rom to ram 
0cf1			 
0cf1 11 f5 fa			ld de, display_active+1 
0cf4 01 02 00			ld bc, 2 
0cf7 ed b0			ldir 
0cf9			 
0cf9 21 f5 fa			ld hl, display_active+1 
0cfc c9				ret 
0cfd				 
0cfd				 
0cfd			 
0cfd			 
0cfd			;db "|/-\|-\" 
0cfd			 
0cfd			actseq: 
0cfd			 
0cfd 0b 0d		dw spin0 
0cff 0d 0d		dw spin1 
0d01 0f 0d		dw spin2 
0d03 11 0d		dw spin3 
0d05 0f 0d		dw spin2 
0d07 0d 0d		dw spin1 
0d09 0b 0d		dw spin0 
0d0b			 
0d0b .. 00		spin0: db " ", 0 
0d0d .. 00		spin1: db "-", 0 
0d0f .. 00		spin2: db "+", 0 
0d11 .. 00		spin3: db "#", 0 
0d13			 
0d13			 
0d13			; information window 
0d13			 
0d13			; pass hl with 1st string to display 
0d13			; pass de with 2nd string to display 
0d13			 
0d13			info_panel: 
0d13 e5				push hl 
0d14			 
0d14 2a fa fa			ld hl, (display_fb_active) 
0d17 e5				push hl    ; future de destination 
0d18 21 df fc				ld hl, display_fb0 
0d1b 22 fa fa				ld (display_fb_active), hl 
0d1e			 
0d1e			;	call clear_display 
0d1e			 
0d1e				if BASE_CPM 
0d1e				ld a, '.' 
0d1e				else 
0d1e 3e a5			ld a, 165 
0d20				endif 
0d20 cd 86 0d			call fill_display 
0d23			 
0d23			 
0d23 3e 55			ld a, display_row_3 + 5 
0d25 cd 93 0d			call str_at_display 
0d28			 
0d28 e1				pop hl 
0d29 d1				pop de 
0d2a			 
0d2a e5				push hl 
0d2b			 
0d2b			 
0d2b 3e 2d			ld a, display_row_2 + 5 
0d2d cd 93 0d			call str_at_display 
0d30			 
0d30			 
0d30 cd a3 0d			call update_display 
0d33 cd 8a 1f			call next_page_prompt 
0d36 cd 81 0d			call clear_display 
0d39			 
0d39				 
0d39 21 3e fc				ld hl, display_fb1 
0d3c 22 fa fa				ld (display_fb_active), hl 
0d3f cd a3 0d			call update_display 
0d42			 
0d42 e1				pop hl 
0d43			 
0d43 c9				ret 
0d44			 
0d44			 
0d44			 
0d44			 
0d44			; TODO windowing? 
0d44			 
0d44			; TODO scroll line up 
0d44			 
0d44			scroll_up: 
0d44			 
0d44 e5				push hl 
0d45 d5				push de 
0d46 c5				push bc 
0d47			 
0d47				; get frame buffer  
0d47			 
0d47 2a fa fa			ld hl, (display_fb_active) 
0d4a e5				push hl    ; future de destination 
0d4b			 
0d4b 11 28 00			ld  de, display_cols 
0d4e 19				add hl, de 
0d4f			 
0d4f d1				pop de 
0d50			 
0d50				;ex de, hl 
0d50 01 9f 00			ld bc, display_fb_len -1  
0d53			;if DEBUG_FORTH_WORDS 
0d53			;	DMARK "SCL" 
0d53			;	CALLMONITOR 
0d53			;endif	 
0d53 ed b0			ldir 
0d55			 
0d55				; wipe bottom row 
0d55			 
0d55			 
0d55 2a fa fa			ld hl, (display_fb_active) 
0d58 11 a0 00			ld de, display_cols*display_rows 
0d5b 19				add hl, de 
0d5c 06 28			ld b, display_cols 
0d5e			;	ld a, ' ' 
0d5e			.scwipe: 
0d5e 36 20			ld (hl), ' ' 
0d60 2b				dec hl 
0d61 10 fb			djnz .scwipe 
0d63			 
0d63				;pop hl 
0d63			 
0d63 c1				pop bc 
0d64 d1				pop de 
0d65 e1				pop hl 
0d66			 
0d66 c9				ret 
0d67			 
0d67			 
0d67			;scroll_upo: 
0d67			;	ld de, display_row_1 
0d67			 ;	ld hl, display_row_2 
0d67			;	ld bc, display_cols 
0d67			;	ldir 
0d67			;	ld de, display_row_2 
0d67			 ;	ld hl, display_row_3 
0d67			;	ld bc, display_cols 
0d67			;	ldir 
0d67			;	ld de, display_row_3 
0d67			 ;	ld hl, display_row_4 
0d67			;	ld bc, display_cols 
0d67			;	ldir 
0d67			 
0d67			; TODO clear row 4 
0d67			 
0d67			;	ret 
0d67			 
0d67				 
0d67			scroll_down: 
0d67			 
0d67 e5				push hl 
0d68 d5				push de 
0d69 c5				push bc 
0d6a			 
0d6a				; get frame buffer  
0d6a			 
0d6a 2a fa fa			ld hl, (display_fb_active) 
0d6d			 
0d6d 11 9f 00			ld de, display_fb_len - 1 
0d70 19				add hl, de 
0d71			 
0d71 e5			push hl    ; future de destination 
0d72			 
0d72 11 28 00			ld  de, display_cols 
0d75 ed 52			sbc hl, de 
0d77			 
0d77			 
0d77 d1				pop de 
0d78			 
0d78			;	ex de, hl 
0d78 01 9f 00			ld bc, display_fb_len -1  
0d7b			 
0d7b			 
0d7b				 
0d7b			 
0d7b ed b0			ldir 
0d7d			 
0d7d				; wipe bottom row 
0d7d			 
0d7d			 
0d7d			;	ld hl, (display_fb_active) 
0d7d			;;	ld de, display_cols*display_rows 
0d7d			;;	add hl, de 
0d7d			;	ld b, display_cols 
0d7d			;	ld a, ' ' 
0d7d			;.scwiped: 
0d7d			;	ld (hl), a 
0d7d			;	dec hl 
0d7d			;	djnz .scwiped 
0d7d			 
0d7d				;pop hl 
0d7d			 
0d7d c1				pop bc 
0d7e d1				pop de 
0d7f e1				pop hl 
0d80			 
0d80 c9				ret 
0d81			;scroll_down: 
0d81			;	ld de, display_row_4 
0d81			;	ld hl, display_row_3 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_3 
0d81			; 	ld hl, display_row_2 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_2 
0d81			;	ld hl, display_row_1 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;;; TODO clear row 1 
0d81			;	ret 
0d81			 
0d81			 
0d81			 
0d81			 
0d81			 
0d81			; clear active frame buffer 
0d81			 
0d81			clear_display: 
0d81 3e 20			ld a, ' ' 
0d83 c3 86 0d			jp fill_display 
0d86			 
0d86			; fill active frame buffer with a char in A 
0d86			 
0d86			fill_display: 
0d86 06 a0			ld b,display_fb_len 
0d88 2a fa fa			ld hl, (display_fb_active) 
0d8b 77			.fd1:	ld (hl),a 
0d8c 23				inc hl 
0d8d 10 fc			djnz .fd1 
0d8f 23				inc hl 
0d90			;	ld a,0 
0d90 36 00			ld (hl),0 
0d92			 
0d92			 
0d92 c9				ret 
0d93			; Write string (DE) at pos (A) to active frame buffer 
0d93			 
0d93 2a fa fa		str_at_display:    ld hl,(display_fb_active) 
0d96 06 00					ld b,0 
0d98 4f					ld c,a 
0d99 09					add hl,bc 
0d9a 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d9b b7			            OR   A              ;Null terminator? 
0d9c c8			            RET  Z              ;Yes, so finished 
0d9d 77					ld (hl),a 
0d9e 23				inc hl 
0d9f 13			            INC  DE             ;Point to next character 
0da0 18 f8		            JR   .sad1     ;Repeat 
0da2 c9					ret 
0da3			 
0da3			; using current frame buffer write to physical display 
0da3			 
0da3			update_display: 
0da3 e5				push hl 
0da4 2a fa fa			ld hl, (display_fb_active) 
0da7 cd a9 79			call write_display 
0daa e1				pop hl 
0dab c9				ret 
0dac			 
0dac			; TODO scrolling 
0dac			 
0dac			 
0dac			; move cursor right one char 
0dac			cursor_right: 
0dac			 
0dac				; TODO shift right 
0dac				; TODO if beyond max col 
0dac				; TODO       cursor_next_line 
0dac			 
0dac c9				ret 
0dad			 
0dad			 
0dad			cursor_next_line: 
0dad				; TODO first char 
0dad				; TODO line down 
0dad				; TODO if past last row 
0dad				; TODO    scroll up 
0dad			 
0dad c9				ret 
0dae			 
0dae			cursor_left: 
0dae				; TODO shift left 
0dae				; TODO if beyond left  
0dae				; TODO     cursor prev line 
0dae				 
0dae c9				ret 
0daf			 
0daf			cursor_prev_line: 
0daf				; TODO last char 
0daf				; TODO line up 
0daf				; TODO if past first row 
0daf				; TODO   scroll down 
0daf			 
0daf c9				ret 
0db0			 
0db0			 
0db0			cout: 
0db0				; A - char 
0db0 c9				ret 
0db1			 
0db1			 
0db1			; Display a menu and allow item selection (optional toggle items) 
0db1			; 
0db1			; format: 
0db1			; hl pointer to word array with zero term for items 
0db1			; e.g.    db item1 
0db1			;         db .... 
0db1			;         db 0 
0db1			; 
0db1			; a = starting menu item  
0db1			; 
0db1			; de = pointer item toggle array   (todo) 
0db1			; 
0db1			; returns item selected in a 1-... 
0db1			; returns 0 if back button pressed 
0db1			; 
0db1			; NOTE: Uses system frame buffer to display 
0db1			; 
0db1			; LEFT, Q = go back 
0db1			; RIGHT, SPACE, CR = select 
0db1			; UP, A - Up 
0db1			; DOWN, Z - Down 
0db1			 
0db1			 
0db1			 
0db1			 
0db1			 
0db1			menu: 
0db1			 
0db1					; keep array pointer 
0db1			 
0db1 22 a1 f9				ld (store_tmp1), hl 
0db4 32 9f f9				ld (store_tmp2), a 
0db7			 
0db7					; check for key bounce 
0db7			 
0db7			if BASE_KEV 
0db7			 
0db7 cd fb 7c		.mbounce:	call cin 
0dba			;		cp 0 
0dba b7					or a 
0dbb 20 fa				jr nz, .mbounce 
0dbd			endif 
0dbd					; for ease use ex 
0dbd			 
0dbd					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dbd 21 df fc				ld hl, display_fb0 
0dc0 22 fa fa				ld (display_fb_active), hl 
0dc3			 
0dc3 cd 81 0d		.mloop:		call clear_display 
0dc6 cd a3 0d				call update_display 
0dc9			 
0dc9					; draw selection id '>' at 1 
0dc9			 
0dc9					; init start of list display 
0dc9			 
0dc9 3e 05				ld a, 5 
0dcb 32 9d f9				ld (store_tmp3), a   ; display row count 
0dce 3a 9f f9				ld a,( store_tmp2) 
0dd1 32 a0 f9				ld (store_tmp2+1), a   ; display item count 
0dd4			 
0dd4					 
0dd4			.mitem:	 
0dd4			 
0dd4			 
0dd4 3a a0 f9				ld a,(store_tmp2+1) 
0dd7 6f					ld l, a 
0dd8 26 00				ld h, 0 
0dda 29					add hl, hl 
0ddb ed 5b a1 f9			ld de, (store_tmp1) 
0ddf 19					add hl, de 
0de0 7e					ld a, (hl) 
0de1 23					inc hl 
0de2 66					ld h,(hl) 
0de3 6f					ld l, a 
0de4			 
0de4 cd da 0f				call ishlzero 
0de7 28 1a				jr z, .mdone 
0de9			 
0de9 eb					ex de, hl 
0dea 3a 9d f9				ld a, (store_tmp3) 
0ded cd 93 0d				call str_at_display 
0df0					 
0df0			 
0df0					; next item 
0df0 3a a0 f9				ld a, (store_tmp2+1) 
0df3 3c					inc a 
0df4 32 a0 f9				ld (store_tmp2+1), a   ; display item count 
0df7			 
0df7			 		; next row 
0df7			 
0df7 3a 9d f9				ld a, (store_tmp3) 
0dfa c6 28				add display_cols 
0dfc 32 9d f9				ld (store_tmp3), a 
0dff			 
0dff					; at end of screen? 
0dff			 
0dff fe 10				cp display_rows*4 
0e01 20 d1				jr nz, .mitem 
0e03			 
0e03			 
0e03			.mdone: 
0e03 cd da 0f				call ishlzero 
0e06 28 08				jr z, .nodn 
0e08			 
0e08 3e 78				ld a, display_row_4 
0e0a 11 87 0e				ld de, .mdown 
0e0d cd 93 0d				call str_at_display 
0e10			 
0e10					; draw options to fill the screens with active item on line 1 
0e10					; if current option is 2 or more then display ^ in top 
0e10			 
0e10 3a 9f f9		.nodn:		ld a, (store_tmp2) 
0e13			;		cp 0 
0e13 b7					or a 
0e14 28 08				jr z, .noup 
0e16			 
0e16 3e 00				ld a, 0 
0e18 11 85 0e				ld de, .mup 
0e1b cd 93 0d				call str_at_display 
0e1e			 
0e1e 3e 02		.noup:		ld a, 2 
0e20 11 83 0e				ld de, .msel 
0e23 cd 93 0d				call str_at_display 
0e26			 
0e26					; if current option + 1 is not null then display V in bottom 
0e26					; get key 
0e26 cd a3 0d				call update_display 
0e29			 
0e29			 
0e29					; handle key 
0e29			 
0e29 cd ec 7c				call cin_wait 
0e2c			 
0e2c fe 05				cp KEY_UP 
0e2e 28 2b				jr z, .mgoup 
0e30 fe 61				cp 'a' 
0e32 28 27				jr z, .mgoup 
0e34 fe 0a				cp KEY_DOWN 
0e36 28 31				jr z, .mgod 
0e38 fe 7a				cp 'z' 
0e3a 28 2d				jr z, .mgod 
0e3c fe 20				cp ' ' 
0e3e 28 33				jr z, .goend 
0e40 fe 0c				cp KEY_RIGHT 
0e42 28 2f				jr z, .goend 
0e44 fe 0d				cp KEY_CR 
0e46 28 2b				jr z, .goend 
0e48 fe 71				cp 'q' 
0e4a 28 0b				jr z, .goback 
0e4c			 
0e4c fe 0b				cp KEY_LEFT 
0e4e 28 07				jr z, .goback 
0e50 fe 08				cp KEY_BS 
0e52 28 03				jr z, .goback 
0e54 c3 c3 0d				jp .mloop 
0e57			 
0e57			.goback: 
0e57 3e 00			ld a, 0 
0e59 18 1c			jr .goend2 
0e5b			 
0e5b				; move up one 
0e5b			.mgoup: 
0e5b 3a 9f f9				ld a, (store_tmp2) 
0e5e			;		cp 0 
0e5e b7					or a 
0e5f ca c3 0d				jp z, .mloop 
0e62 3d					dec a 
0e63 32 9f f9				ld (store_tmp2), a 
0e66 c3 c3 0d				jp .mloop 
0e69			 
0e69				; move down one 
0e69			.mgod: 
0e69 3a 9f f9				ld a, (store_tmp2) 
0e6c 3c					inc a 
0e6d 32 9f f9				ld (store_tmp2), a 
0e70 c3 c3 0d				jp .mloop 
0e73			 
0e73			 
0e73			.goend: 
0e73					; get selected item number 
0e73			 
0e73 3a 9f f9				ld a, (store_tmp2) 
0e76 3c					inc a 
0e77			 
0e77			.goend2: 
0e77 f5					push af 
0e78			 
0e78					; restore active fb 
0e78					; TODO BUG assumes fb1 
0e78			 
0e78 21 3e fc				ld hl, display_fb1 
0e7b 22 fa fa				ld (display_fb_active), hl 
0e7e			 
0e7e					; restore main regs 
0e7e			 
0e7e			 
0e7e cd a3 0d				call update_display 
0e81			 
0e81 f1					pop af 
0e82			 
0e82 c9				ret 
0e83			 
0e83 .. 00		.msel:   db ">",0 
0e85 .. 00		.mup:   db "^",0 
0e87 .. 00		.mdown:   db "v",0 
0e89			 
0e89			 
0e89			; eof 
0e89			 
# End of file firmware_display.asm
0e89			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e89			; random number generators 
0e89			 
0e89			 
0e89			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e89			 
0e89			 
0e89			;-----> Generate a random number 
0e89			; output a=answer 0<=a<=255 
0e89			; all registers are preserved except: af 
0e89			random: 
0e89 e5			        push    hl 
0e8a d5			        push    de 
0e8b 2a d9 fa		        ld      hl,(randData) 
0e8e ed 5f		        ld      a,r 
0e90 57			        ld      d,a 
0e91 5e			        ld      e,(hl) 
0e92 19			        add     hl,de 
0e93 85			        add     a,l 
0e94 ac			        xor     h 
0e95 22 d9 fa		        ld      (randData),hl 
0e98 d1			        pop     de 
0e99 e1			        pop     hl 
0e9a c9			        ret 
0e9b			 
0e9b			 
0e9b			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e9b			 
0e9b			 
0e9b			 
0e9b			;------LFSR------ 
0e9b			;James Montelongo 
0e9b			;optimized by Spencer Putt 
0e9b			;out: 
0e9b			; a = 8 bit random number 
0e9b			RandLFSR: 
0e9b 21 df fa		        ld hl,LFSRSeed+4 
0e9e 5e			        ld e,(hl) 
0e9f 23			        inc hl 
0ea0 56			        ld d,(hl) 
0ea1 23			        inc hl 
0ea2 4e			        ld c,(hl) 
0ea3 23			        inc hl 
0ea4 7e			        ld a,(hl) 
0ea5 47			        ld b,a 
0ea6 cb 13		        rl e  
0ea8 cb 12			rl d 
0eaa cb 11		        rl c  
0eac 17				rla 
0ead cb 13		        rl e  
0eaf cb 12			rl d 
0eb1 cb 11		        rl c  
0eb3 17				rla 
0eb4 cb 13		        rl e  
0eb6 cb 12			rl d 
0eb8 cb 11		        rl c  
0eba 17				rla 
0ebb 67			        ld h,a 
0ebc cb 13		        rl e  
0ebe cb 12			rl d 
0ec0 cb 11		        rl c  
0ec2 17				rla 
0ec3 a8			        xor b 
0ec4 cb 13		        rl e  
0ec6 cb 12			rl d 
0ec8 ac			        xor h 
0ec9 a9			        xor c 
0eca aa			        xor d 
0ecb 21 e1 fa		        ld hl,LFSRSeed+6 
0ece 11 e2 fa		        ld de,LFSRSeed+7 
0ed1 01 07 00		        ld bc,7 
0ed4 ed b8		        lddr 
0ed6 12			        ld (de),a 
0ed7 c9			        ret 
0ed8			 
0ed8			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ed8			 
0ed8			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ed8			 
0ed8			 
0ed8			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ed8			 
0ed8			prng16: 
0ed8			;Inputs: 
0ed8			;   (seed1) contains a 16-bit seed value 
0ed8			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ed8			;Outputs: 
0ed8			;   HL is the result 
0ed8			;   BC is the result of the LCG, so not that great of quality 
0ed8			;   DE is preserved 
0ed8			;Destroys: 
0ed8			;   AF 
0ed8			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ed8			;160cc 
0ed8			;26 bytes 
0ed8 2a d3 fa		    ld hl,(seed1) 
0edb 44			    ld b,h 
0edc 4d			    ld c,l 
0edd 29			    add hl,hl 
0ede 29			    add hl,hl 
0edf 2c			    inc l 
0ee0 09			    add hl,bc 
0ee1 22 d3 fa		    ld (seed1),hl 
0ee4 2a d1 fa		    ld hl,(seed2) 
0ee7 29			    add hl,hl 
0ee8 9f			    sbc a,a 
0ee9 e6 2d		    and %00101101 
0eeb ad			    xor l 
0eec 6f			    ld l,a 
0eed 22 d1 fa		    ld (seed2),hl 
0ef0 09			    add hl,bc 
0ef1 c9			    ret 
0ef2			 
0ef2			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0ef2			 
0ef2			rand32: 
0ef2			;Inputs: 
0ef2			;   (seed1_0) holds the lower 16 bits of the first seed 
0ef2			;   (seed1_1) holds the upper 16 bits of the first seed 
0ef2			;   (seed2_0) holds the lower 16 bits of the second seed 
0ef2			;   (seed2_1) holds the upper 16 bits of the second seed 
0ef2			;   **NOTE: seed2 must be non-zero 
0ef2			;Outputs: 
0ef2			;   HL is the result 
0ef2			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0ef2			;Destroys: 
0ef2			;   AF 
0ef2			;Tested and passes all CAcert tests 
0ef2			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0ef2			;it has a period of 18,446,744,069,414,584,320 
0ef2			;roughly 18.4 quintillion. 
0ef2			;LFSR taps: 0,2,6,7  = 11000101 
0ef2			;291cc 
0ef2			;seed1_0=$+1 
0ef2			;    ld hl,12345 
0ef2			;seed1_1=$+1 
0ef2			;    ld de,6789 
0ef2			;    ld b,h 
0ef2			;    ld c,l 
0ef2			;    add hl,hl \ rl e \ rl d 
0ef2			;    add hl,hl \ rl e \ rl d 
0ef2			;    inc l 
0ef2			;    add hl,bc 
0ef2			;    ld (seed1_0),hl 
0ef2			;    ld hl,(seed1_1) 
0ef2			;    adc hl,de 
0ef2			;    ld (seed1_1),hl 
0ef2			;    ex de,hl 
0ef2			;seed2_0=$+1 
0ef2			;    ld hl,9876 
0ef2			;seed2_1=$+1 
0ef2			;    ld bc,54321 
0ef2			;    add hl,hl \ rl c \ rl b 
0ef2			;    ld (seed2_1),bc 
0ef2			;    sbc a,a 
0ef2			;    and %11000101 
0ef2			;    xor l 
0ef2			;    ld l,a 
0ef2			;    ld (seed2_0),hl 
0ef2			;    ex de,hl 
0ef2			;    add hl,bc 
0ef2			;    ret 
0ef2			; 
0ef2			 
0ef2			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0ef2			; 20 bytes, 86 cycles (excluding ret) 
0ef2			 
0ef2			; returns   hl = pseudorandom number 
0ef2			; corrupts   a 
0ef2			 
0ef2			; generates 16-bit pseudorandom numbers with a period of 65535 
0ef2			; using the xorshift method: 
0ef2			 
0ef2			; hl ^= hl << 7 
0ef2			; hl ^= hl >> 9 
0ef2			; hl ^= hl << 8 
0ef2			 
0ef2			; some alternative shift triplets which also perform well are: 
0ef2			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0ef2			 
0ef2			;  org 32768 
0ef2			 
0ef2			xrnd: 
0ef2 2a d7 fa		  ld hl,(xrandc)       ; seed must not be 0 
0ef5 3e 00		  ld a,0 
0ef7 bd			  cp l 
0ef8 20 02		  jr nz, .xrnd1 
0efa 2e 01		  ld l, 1 
0efc			.xrnd1: 
0efc			 
0efc 7c			  ld a,h 
0efd 1f			  rra 
0efe 7d			  ld a,l 
0eff 1f			  rra 
0f00 ac			  xor h 
0f01 67			  ld h,a 
0f02 7d			  ld a,l 
0f03 1f			  rra 
0f04 7c			  ld a,h 
0f05 1f			  rra 
0f06 ad			  xor l 
0f07 6f			  ld l,a 
0f08 ac			  xor h 
0f09 67			  ld h,a 
0f0a			 
0f0a 22 d7 fa		  ld (xrandc),hl 
0f0d			 
0f0d c9			  ret 
0f0e			;  
0f0e			 
0f0e			 
0f0e			;;;; int maths 
0f0e			 
0f0e			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f0e			; Divide 16-bit values (with 16-bit result) 
0f0e			; In: Divide BC by divider DE 
0f0e			; Out: BC = result, HL = rest 
0f0e			; 
0f0e			Div16: 
0f0e 21 00 00		    ld hl,0 
0f11 78			    ld a,b 
0f12 06 08		    ld b,8 
0f14			Div16_Loop1: 
0f14 17			    rla 
0f15 ed 6a		    adc hl,hl 
0f17 ed 52		    sbc hl,de 
0f19 30 01		    jr nc,Div16_NoAdd1 
0f1b 19			    add hl,de 
0f1c			Div16_NoAdd1: 
0f1c 10 f6		    djnz Div16_Loop1 
0f1e 17			    rla 
0f1f 2f			    cpl 
0f20 47			    ld b,a 
0f21 79			    ld a,c 
0f22 48			    ld c,b 
0f23 06 08		    ld b,8 
0f25			Div16_Loop2: 
0f25 17			    rla 
0f26 ed 6a		    adc hl,hl 
0f28 ed 52		    sbc hl,de 
0f2a 30 01		    jr nc,Div16_NoAdd2 
0f2c 19			    add hl,de 
0f2d			Div16_NoAdd2: 
0f2d 10 f6		    djnz Div16_Loop2 
0f2f 17			    rla 
0f30 2f			    cpl 
0f31 41			    ld b,c 
0f32 4f			    ld c,a 
0f33 c9			ret 
0f34			 
0f34			 
0f34			;http://z80-heaven.wikidot.com/math 
0f34			; 
0f34			;Inputs: 
0f34			;     DE and A are factors 
0f34			;Outputs: 
0f34			;     A is not changed 
0f34			;     B is 0 
0f34			;     C is not changed 
0f34			;     DE is not changed 
0f34			;     HL is the product 
0f34			;Time: 
0f34			;     342+6x 
0f34			; 
0f34			Mult16: 
0f34			 
0f34 06 08		     ld b,8          ;7           7 
0f36 21 00 00		     ld hl,0         ;10         10 
0f39 29			       add hl,hl     ;11*8       88 
0f3a 07			       rlca          ;4*8        32 
0f3b 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f3d 19			         add hl,de   ;--         -- 
0f3e 10 f9		       djnz $-5      ;13*7+8     99 
0f40 c9			ret 
0f41			 
0f41			; 
0f41			; Square root of 16-bit value 
0f41			; In:  HL = value 
0f41			; Out:  D = result (rounded down) 
0f41			; 
0f41			;Sqr16: 
0f41			;    ld de,#0040 
0f41			;    ld a,l 
0f41			;    ld l,h 
0f41			;    ld h,d 
0f41			;    or a 
0f41			;    ld b,8 
0f41			;Sqr16_Loop: 
0f41			;    sbc hl,de 
0f41			;    jr nc,Sqr16_Skip 
0f41			;    add hl,de 
0f41			;Sqr16_Skip: 
0f41			;    ccf 
0f41			;    rl d 
0f41			;    add a,a 
0f41			;    adc hl,hl 
0f41			;    add a,a 
0f41			;    adc hl,hl 
0f41			;    djnz Sqr16_Loop 
0f41			;    ret 
0f41			; 
0f41			; 
0f41			; Divide 8-bit values 
0f41			; In: Divide E by divider C 
0f41			; Out: A = result, B = rest 
0f41			; 
0f41			Div8: 
0f41 af			    xor a 
0f42 06 08		    ld b,8 
0f44			Div8_Loop: 
0f44 cb 13		    rl e 
0f46 17			    rla 
0f47 91			    sub c 
0f48 30 01		    jr nc,Div8_NoAdd 
0f4a 81			    add a,c 
0f4b			Div8_NoAdd: 
0f4b 10 f7		    djnz Div8_Loop 
0f4d 47			    ld b,a 
0f4e 7b			    ld a,e 
0f4f 17			    rla 
0f50 2f			    cpl 
0f51 c9			    ret 
0f52			 
0f52			; 
0f52			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f52			; In: Multiply A with DE 
0f52			; Out: HL = result 
0f52			; 
0f52			Mult12U: 
0f52 2e 00		    ld l,0 
0f54 87			    add a,a 
0f55 30 01		    jr nc,Mult12U_NoAdd0 
0f57 19			    add hl,de 
0f58			Mult12U_NoAdd0: 
0f58 29			    add hl,hl 
0f59 87			    add a,a 
0f5a 30 01		    jr nc,Mult12U_NoAdd1 
0f5c 19			    add hl,de 
0f5d			Mult12U_NoAdd1: 
0f5d 29			    add hl,hl 
0f5e 87			    add a,a 
0f5f 30 01		    jr nc,Mult12U_NoAdd2 
0f61 19			    add hl,de 
0f62			Mult12U_NoAdd2: 
0f62 29			    add hl,hl 
0f63 87			    add a,a 
0f64 30 01		    jr nc,Mult12U_NoAdd3 
0f66 19			    add hl,de 
0f67			Mult12U_NoAdd3: 
0f67 29			    add hl,hl 
0f68 87			    add a,a 
0f69 30 01		    jr nc,Mult12U_NoAdd4 
0f6b 19			    add hl,de 
0f6c			Mult12U_NoAdd4: 
0f6c 29			    add hl,hl 
0f6d 87			    add a,a 
0f6e 30 01		    jr nc,Mult12U_NoAdd5 
0f70 19			    add hl,de 
0f71			Mult12U_NoAdd5: 
0f71 29			    add hl,hl 
0f72 87			    add a,a 
0f73 30 01		    jr nc,Mult12U_NoAdd6 
0f75 19			    add hl,de 
0f76			Mult12U_NoAdd6: 
0f76 29			    add hl,hl 
0f77 87			    add a,a 
0f78 d0			    ret nc 
0f79 19			    add hl,de 
0f7a c9			    ret 
0f7b			 
0f7b			; 
0f7b			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f7b			; In: Multiply A with DE 
0f7b			;      Put lowest value in A for most efficient calculation 
0f7b			; Out: HL = result 
0f7b			; 
0f7b			Mult12R: 
0f7b 21 00 00		    ld hl,0 
0f7e			Mult12R_Loop: 
0f7e cb 3f		    srl a 
0f80 30 01		    jr nc,Mult12R_NoAdd 
0f82 19			    add hl,de 
0f83			Mult12R_NoAdd: 
0f83 cb 23		    sla e 
0f85 cb 12		    rl d 
0f87 b7			    or a 
0f88 c2 7e 0f		    jp nz,Mult12R_Loop 
0f8b c9			    ret 
0f8c			 
0f8c			; 
0f8c			; Multiply 16-bit values (with 32-bit result) 
0f8c			; In: Multiply BC with DE 
0f8c			; Out: BCHL = result 
0f8c			; 
0f8c			Mult32: 
0f8c 79			    ld a,c 
0f8d 48			    ld c,b 
0f8e 21 00 00		    ld hl,0 
0f91 06 10		    ld b,16 
0f93			Mult32_Loop: 
0f93 29			    add hl,hl 
0f94 17			    rla 
0f95 cb 11		    rl c 
0f97 30 07		    jr nc,Mult32_NoAdd 
0f99 19			    add hl,de 
0f9a ce 00		    adc a,0 
0f9c d2 a0 0f		    jp nc,Mult32_NoAdd 
0f9f 0c			    inc c 
0fa0			Mult32_NoAdd: 
0fa0 10 f1		    djnz Mult32_Loop 
0fa2 41			    ld b,c 
0fa3 4f			    ld c,a 
0fa4 c9			    ret 
0fa5			 
0fa5			 
0fa5			 
0fa5			; 
0fa5			; Multiply 8-bit values 
0fa5			; In:  Multiply H with E 
0fa5			; Out: HL = result 
0fa5			; 
0fa5			Mult8: 
0fa5 16 00		    ld d,0 
0fa7 6a			    ld l,d 
0fa8 06 08		    ld b,8 
0faa			Mult8_Loop: 
0faa 29			    add hl,hl 
0fab 30 01		    jr nc,Mult8_NoAdd 
0fad 19			    add hl,de 
0fae			Mult8_NoAdd: 
0fae 10 fa		    djnz Mult8_Loop 
0fb0 c9			    ret 
0fb1			 
0fb1			 
0fb1			 
0fb1			 
0fb1			 
0fb1			 
0fb1			 
0fb1			 
0fb1			;;http://z80-heaven.wikidot.com/math 
0fb1			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fb1			; 
0fb1			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fb1			;     ld a,16        ;7 
0fb1			;     ld hl,0        ;10 
0fb1			;     jp $+5         ;10 
0fb1			;.DivLoop: 
0fb1			;       add hl,bc    ;-- 
0fb1			;       dec a        ;64 
0fb1			;       jr z,.DivLoopEnd        ;86 
0fb1			; 
0fb1			;       sla e        ;128 
0fb1			;       rl d         ;128 
0fb1			;       adc hl,hl    ;240 
0fb1			;       sbc hl,bc    ;240 
0fb1			;       jr nc,.DivLoop ;23|21 
0fb1			;       inc e        ;-- 
0fb1			;       jp .DivLoop+1 
0fb1			; 
0fb1			;.DivLoopEnd: 
0fb1			 
0fb1			;HL_Div_C: 
0fb1			;Inputs: 
0fb1			;     HL is the numerator 
0fb1			;     C is the denominator 
0fb1			;Outputs: 
0fb1			;     A is the remainder 
0fb1			;     B is 0 
0fb1			;     C is not changed 
0fb1			;     DE is not changed 
0fb1			;     HL is the quotient 
0fb1			; 
0fb1			;       ld b,16 
0fb1			;       xor a 
0fb1			;         add hl,hl 
0fb1			;         rla 
0fb1			;         cp c 
0fb1			;         jr c,$+4 
0fb1			;           inc l 
0fb1			;           sub c 
0fb1			;         djnz $-7 
0fb1			 
0fb1			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fb1			 
0fb1			addatohl: 
0fb1 85			    add   a, l    ; A = A+L 
0fb2 6f			    ld    l, a    ; L = A+L 
0fb3 8c			    adc   a, h    ; A = A+L+H+carry 
0fb4 95			    sub   l       ; A = H+carry 
0fb5 67			    ld    h, a    ; H = H+carry 
0fb6 c9			ret 
0fb7			 
0fb7			addatode: 
0fb7 83			    add   a, e    ; A = A+L 
0fb8 5f			    ld    e, a    ; L = A+L 
0fb9 8a			    adc   a, d    ; A = A+L+H+carry 
0fba 93			    sub   e       ; A = H+carry 
0fbb 57			    ld    d, a    ; H = H+carry 
0fbc c9			ret 
0fbd			 
0fbd			 
0fbd			addatobc: 
0fbd 81			    add   a, c    ; A = A+L 
0fbe 4f			    ld    c, a    ; L = A+L 
0fbf 88			    adc   a, b    ; A = A+L+H+carry 
0fc0 91			    sub   c       ; A = H+carry 
0fc1 47			    ld    b, a    ; H = H+carry 
0fc2 c9			ret 
0fc3			 
0fc3			subafromhl: 
0fc3			   ; If A=0 do nothing 
0fc3			    ; Otherwise flip A's sign. Since 
0fc3			    ; the upper byte becomes -1, also 
0fc3			    ; substract 1 from H. 
0fc3 ed 44		    neg 
0fc5 ca ce 0f		    jp    z, Skip 
0fc8 25			    dec   h 
0fc9			     
0fc9			    ; Now add the low byte as usual 
0fc9			    ; Two's complement takes care of 
0fc9			    ; ensuring the result is correct 
0fc9 85			    add   a, l 
0fca 6f			    ld    l, a 
0fcb 8c			    adc   a, h 
0fcc 95			    sub   l 
0fcd 67			    ld    h, a 
0fce			Skip: 
0fce c9				ret 
0fcf			 
0fcf			 
0fcf			; compare hl and de 
0fcf			; returns:  
0fcf			; if hl = de, z=1, s=0, c0=0 
0fcf			; if hl > de, z=0, s=0, c=0 
0fcf			; if hl < de, z=0, s=1, c=1 
0fcf			cmp16:	 
0fcf b7				or a 
0fd0 ed 52			sbc hl,de 
0fd2 e0				ret po 
0fd3 7c				ld a,h 
0fd4 1f				rra 
0fd5 ee 40			xor 01000000B 
0fd7 37				scf 
0fd8 8f				adc a,a 
0fd9 c9				ret 
0fda			 
0fda			 
0fda			; test if hl contains zero   - A is destroyed 
0fda			 
0fda			ishlzero:    
0fda b7				or a     ; reset flags 
0fdb 7c				ld a, h 
0fdc b5				or l        	 
0fdd			 
0fdd c9				ret 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			if FORTH_ENABLE_FLOATMATH 
0fde			;include "float/bbcmath.z80" 
0fde			include "float/lpfpcalc.asm" 
0fde			endif 
0fde			 
0fde			 
0fde			; eof 
0fde			 
# End of file firmware_maths.asm
0fde			include "firmware_strings.asm"   ; string handling  
0fde			 
0fde			 
0fde			; TODO string len 
0fde			; input text string, end on cr with zero term 
0fde			; a offset into frame buffer to start prompt 
0fde			; d is max length 
0fde			; e is display size TODO 
0fde			; c is current cursor position 
0fde			; hl is ptr to where string will be stored and edited directly 
0fde			 
0fde			 
0fde			; TODO check limit of buffer for new inserts 
0fde			; TODO check insert does not push beyond buffer 
0fde			; TODO scroll in a limited display area 
0fde			; TODO scroll whole screen on page wrap 
0fde			 
0fde			 
0fde			; TODO use LCD cursor? 
0fde			 
0fde			EDIT_V1: equ 0 
0fde			EDIT_V2: equ 1 
0fde			 
0fde			 
0fde			 
0fde			if EDIT_V2 
0fde			input_str: 
0fde			 
0fde 32 92 fd			    	ld (input_at_pos),a      ; save display position to start 
0fe1			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0fe1 22 95 fd				ld (input_start), hl     ; save ptr to buffer 
0fe4			;		ld a, c 
0fe4			;		call addatohl 
0fe4			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0fe4 7a					ld a,d 
0fe5 32 94 fd			        ld (input_size), a       ; save length of input area 
0fe8 79					ld a, c 
0fe9 32 83 fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
0fec 7b					ld a,e 
0fed 32 93 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0ff0			 
0ff0			 
0ff0					; add a trailing space to make screen refresh nicer 
0ff0			 
0ff0					;ld hl, (input_start) 
0ff0					;push hl 
0ff0					;ld a, 0 
0ff0					;call strlent 
0ff0					;ld a, l 
0ff0					;pop hl 
0ff0					;call addatohl 
0ff0					;dec hl 
0ff0					;ld a, ' ' 
0ff0					;ld (hl), a 
0ff0					;inc hl 
0ff0					;ld (hl), a 
0ff0					;inc hl 
0ff0					;ld a, 0 
0ff0					;ld (hl), a 
0ff0			 
0ff0			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0ff0					; init cursor shape if not set by the cin routines 
0ff0 21 ef fa				ld hl, cursor_shape 
0ff3			if BASE_KEV 
0ff3			;		ld a, 255 
0ff3 36 ff				ld (hl), 255 
0ff5			else 
0ff5					;ld a, '#' 
0ff5					ld (hl), '#' 
0ff5			endif 
0ff5 23					inc hl 
0ff6			;		ld a, 0 
0ff6 36 00				ld (hl), 0 
0ff8			 
0ff8 3e 09				ld a, CUR_BLINK_RATE 
0ffa 32 8e fd				ld (input_cur_flash), a 
0ffd 3e 01				ld a, 1 
0fff 32 8d fd				ld (input_cur_onoff),a 
1002			.inmain:	 
1002			 
1002 cd 23 11				call input_disp_ref 
1005			 
1005					; save current length of string 
1005			 
1005 2a 95 fd				ld hl, (input_start) 
1008 3e 00				ld a, 0 
100a cd 14 13				call strlent 
100d 7d					ld a,l 
100e 32 88 fd				ld (input_len), a 
1011			 
1011					;call input_disp_oncur 
1011			 
1011					; display current state of input buffer 
1011			 
1011					; clean any backspace chars 
1011			 
1011 3e 20				ld a, " " 
1013 32 ef f0				ld (scratch),a 
1016 3e 00				ld a, 0 
1018 32 f0 f0				ld (scratch+1),a 
101b 3a 92 fd				ld a,(input_at_pos) 
101e 85					add l 
101f 11 ef f0				ld de, scratch 
1022 cd 93 0d				call str_at_display 
1025			 
1025					; pause 1ms 
1025			 
1025 3e 01				ld a, 1 
1027 cd a5 0c				call aDelayInMS 
102a			 
102a			; display cursor if visible on this cycle 
102a			 
102a					; dec flash counter 
102a 3a 8e fd				ld a, (input_cur_flash) 
102d 3d					dec a 
102e 32 8e fd				ld (input_cur_flash), a 
1031			;		cp 0 
1031 b7					or a 
1032 20 0d				jr nz, .inochgstate 
1034			 
1034			 
1034					; reset on change of state 
1034 3e 09				ld a, CUR_BLINK_RATE 
1036 32 8e fd				ld (input_cur_flash), a 
1039			 
1039					; change state 
1039 3a 8d fd				ld a,(input_cur_onoff) 
103c ed 44				neg 
103e 32 8d fd				ld (input_cur_onoff),a 
1041			 
1041			 
1041			 
1041			 
1041					; TODO is cursor visible? 
1041					; TODO if so then over write the char at curspos pos with the cursor shape 
1041			 
1041								 
1041			 
1041			.inochgstate: 
1041 3a 8d fd				ld a,(input_cur_onoff) 
1044 fe ff				cp 255 
1046 28 0e				jr z, .skipcursor 
1048 3a 92 fd				ld a, (input_at_pos) 
104b 47					ld b, a 
104c 3a 83 fd				ld a, (input_cursor) 
104f 80					add b 
1050 11 ef fa				ld de, cursor_shape 
1053					 
1053 cd 93 0d				call str_at_display 
1056			 
1056			.skipcursor: 
1056				if DEBUG_INPUTV2 
1056			 
1056					ld a,(input_at_pos) 
1056					ld hl, LFSRSeed 
1056					call hexout 
1056					ld a, (input_cursor) 
1056					ld hl, LFSRSeed+2 
1056					call hexout 
1056					ld a,(input_size) 
1056					ld hl, LFSRSeed+4 
1056					call hexout 
1056			 
1056					ld a,(input_cur_onoff) 
1056					ld hl, LFSRSeed+6 
1056					call hexout 
1056			 
1056					ld a,(input_cur_flash) 
1056					ld hl, LFSRSeed+8 
1056					call hexout 
1056			 
1056					ld a,(input_len) 
1056					ld hl, LFSRSeed+10 
1056					call hexout 
1056					ld hl, LFSRSeed+12 
1056			;		ld a, 0 
1056					ld (hl),0 
1056					ld a, display_row_4 
1056					ld de, LFSRSeed 
1056					call str_at_display 
1056				endif 
1056 cd a3 0d				call update_display 
1059			 
1059					; TODO keyboard processing 
1059			 
1059			if BASE_CPM 
1059					call cin_wait 
1059			else 
1059 cd fb 7c				call cin    ; _wait 
105c			endif 
105c			;		cp 0 
105c b7					or a 
105d ca 02 10				jp z, .inmain 
1060			 
1060			 
1060					; TODO handle macro 
1060			 
1060			 
1060			 
1060 fe 0b				cp KEY_LEFT    ; cursor left 
1062 ca 15 11				jp z, input_left 
1065				 
1065 fe 0c				cp KEY_RIGHT      ; cursor right 
1067 ca 1c 11				jp z, input_right 
106a			 
106a fe 0d				cp KEY_CR 
106c c8					ret z 
106d			 
106d fe 08				cp KEY_BS 
106f ca 87 11				jp z, input_delchar 
1072			 
1072 fe 06				cp KEY_NEXTWORD 
1074 ca 9b 10				jp z, input_nxtword 
1077			 
1077 fe 07				cp KEY_PREVWORD 
1079 ca c0 10				jp z, input_prvword 
107c			 
107c fe 0e				cp KEY_HOME    ; jump to start of line 
107e 20 08				jr nz, .ikh 
1080 3e 00				ld a, 0 
1082 32 83 fd				ld (input_cursor), a 
1085 ca 02 10				jp z, .inmain 
1088			.ikh: 
1088			 
1088 fe 0f				cp KEY_END     ; jump to end of line 
108a 20 09				jr nz, .ike 
108c 3a 88 fd				ld a, (input_len) 
108f 32 83 fd				ld (input_cursor),a 
1092 ca 02 10				jp z, .inmain 
1095			.ike: 
1095 fe 05			        cp KEY_UP      ; recall last command 
1097 c8					ret z 
1098			;jr nz, .irec 
1098			; TODO next word 
1098			; TODO prev word 
1098			;  
1098			; 
1098			;	ld hl, scratch 
1098			;	ld de, os_last_cmd 
1098			;	call strcpy 
1098			;		jp  .inmain 
1098			.irec: 
1098			;		jr .instr1 
1098			 
1098			 
1098			 
1098					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
1098			 
1098			; TODO return if any special keys are given 
1098			;		ld l, a 
1098			;		ld a, 28 ; KEY_F12   ; 27 
1098			;		sub l 
1098			;		ret m 
1098			;		ld a, l 
1098					; if no special key then insert as a char 
1098			 
1098			 
1098			 
1098 c3 5c 11				jp input_inschr 
109b			 
109b				 
109b			input_nxtword: 
109b				; jump to start next word after the cursor 
109b			 
109b			.insknwn:	 
109b cd 52 11				call input_curptr	 
109e 7e					ld a,(hl)	 
109f			;		cp 0 
109f b7					or a 
10a0 ca 02 10				jp z, .inmain    ; end of string 
10a3			 
10a3			; if we are on a word, then move off of it 
10a3			 
10a3 fe 20				cp ' ' 
10a5 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10a7 21 83 fd				ld hl, input_cursor 
10aa 34					inc (hl) 
10ab 18 ee				jr .insknwn 
10ad			 
10ad			.inspace: 
10ad			 
10ad cd 52 11				call input_curptr	 
10b0 7e					ld a,(hl)	 
10b1			;		cp 0 
10b1 b7					or a 
10b2 ca 02 10				jp z, .inmain    ; end of string 
10b5			 
10b5			; if we are on a word, then move off of it 
10b5			 
10b5 fe 20				cp ' ' 
10b7 c2 02 10				jp nz, .inmain     ; we are on non space so at next word 
10ba 21 83 fd				ld hl, input_cursor 
10bd 34					inc (hl) 
10be 18 ed				jr .inspace 
10c0			 
10c0			 
10c0			 
10c0			 
10c0			input_prvword: 
10c0				; jump to the start of previous word before the cursor 
10c0			 
10c0			; where are we to start with currently? 
10c0			 
10c0 cd 52 11				call input_curptr	 
10c3 7e					ld a, (hl) 
10c4 fe 20				cp ' ' 
10c6 28 1c				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10c8			 
10c8			 
10c8			 
10c8			.inskpwn:	 
10c8 3a 83 fd				ld a,(input_cursor) 
10cb			;		cp 0 
10cb b7					or a 
10cc ca 02 10				jp z, .inmain    ; start of string 
10cf			 
10cf			;if we are on a word, then move off of it 
10cf			 
10cf cd 52 11				call input_curptr	 
10d2 7e					ld a, (hl) 
10d3 fe 20				cp ' ' 
10d5 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
10d7					;jp z, .inmain    ; start of string 
10d7 21 83 fd				ld hl, input_cursor 
10da 35					dec (hl) 
10db 18 eb				jr .inskpwn 
10dd			.iwstart: 
10dd 21 83 fd				ld hl, input_cursor 
10e0 34					inc (hl) 
10e1 c3 02 10				jp .inmain 
10e4					 
10e4			 
10e4			.inspacep: 
10e4			 
10e4					;jp .inmain    ; start of string 
10e4			 
10e4			 
10e4			 
10e4 3a 83 fd				ld a,(input_cursor) 
10e7			;		cp 0 
10e7 b7					or a 
10e8 ca 02 10				jp z, .inmain    ; start of string 
10eb			 
10eb			; if we are on a word, then move off of it 
10eb			 
10eb cd 52 11				call input_curptr	 
10ee 7e					ld a, (hl) 
10ef fe 20				cp ' ' 
10f1 c2 fa 10				jp nz, .incharp     ; we are on non space so at end of prev word 
10f4 21 83 fd				ld hl, input_cursor 
10f7 35					dec (hl) 
10f8 18 ea				jr .inspacep 
10fa			 
10fa			 
10fa			.incharp:	 
10fa					; eat the word to get to the start 
10fa 3a 83 fd				ld a,(input_cursor) 
10fd			;		cp 0 
10fd b7					or a 
10fe ca 02 10				jp z, .inmain    ; start of string 
1101			 
1101			; if we are on a word, then move off of it 
1101			 
1101 cd 52 11				call input_curptr	 
1104 7e					ld a, (hl) 
1105 fe 20				cp ' ' 
1107 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
1109 21 83 fd				ld hl, input_cursor 
110c 35					dec (hl) 
110d 18 eb				jr .incharp 
110f			.ipwordst: 
110f					; at space before the prev word so reposition over it 
110f 21 83 fd				ld hl, input_cursor 
1112 34					inc (hl) 
1113 18 b3				jr .inskpwn 
1115					 
1115			 
1115			 
1115			input_left: 
1115				; move cursor left 
1115 21 83 fd			ld hl, input_cursor 
1118 35				dec (hl) 
1119			;	cp 0 
1119			;	jp z, .inmain    ; ignore left as at the start of the string 
1119 c3 02 10			jp .inmain 
111c			 
111c			input_right: 
111c				; move cursor right 
111c				 
111c				;ld a, (input_size) 
111c				;ld b, a 
111c 21 83 fd			ld hl, input_cursor 
111f 34				inc (hl) 
1120				;dec b 
1120				;cp 0 
1120				;jp z, .inmain   ; ignore as at end of the string buffer 
1120				;ld a, b 
1120				;inc a 
1120				;ld (input_cursor), a 
1120 c3 02 10			jp .inmain 
1123			 
1123			 
1123			 
1123			input_disp_ref: 
1123				; display the text from start of buffer (ie full refresh) 
1123 3a 92 fd			ld a, (input_at_pos) 
1126 2a 95 fd			ld hl,(input_start) 
1129 eb				ex de, hl 
112a cd 93 0d			call str_at_display  
112d c9				ret 
112e			input_disp_oncur: 
112e				; display the text from cursor position to end of buffer 
112e				; TODO position start of string at cursor position on screen 
112e				; TODO draw from that point on 
112e 3a 83 fd			ld a, (input_cursor) 
1131 47				ld b, a 
1132 3a 92 fd			ld a, (input_at_pos) 
1135 80				add b 
1136 48				ld c, b     ; save a 
1137 78				ld a, b     ; inc string start for cursor 
1138 2a 95 fd			ld hl,(input_start) 
113b cd b1 0f			call addatohl 
113e eb				ex de, hl 
113f 79				ld a, c 
1140 cd 93 0d			call str_at_display  
1143 c9				ret 
1144			 
1144			input_nxtw: 
1144				; Find next word 
1144 c9				ret 
1145			 
1145			input_prvw: 
1145				; Find previous word 
1145 c9				ret 
1146			 
1146			input_lenrem:   
1146				; Calculate the length of string remaining from current cursor 
1146				; position to end of buffer (exc null term) 
1146				 
1146 3a 83 fd			ld a, (input_cursor) 
1149 4f				ld c, a 
114a 3a 94 fd			ld a, (input_size) 
114d 91				sub c 
114e 06 00			ld b, 0 
1150 0d				dec c 
1151 c9				ret	 
1152			 
1152			input_curptr: 
1152				; calc address of the character under the cursor 
1152				 
1152 2a 95 fd			ld hl, (input_start) 
1155 3a 83 fd			ld a, (input_cursor) 
1158 cd b1 0f			call addatohl 
115b c9				ret 
115c			 
115c			input_inschr: 
115c				; Insert char at cursor position 
115c f5				push af   ; save char 
115d				;call input_lenrem    ; get bc length of remaining string 
115d			 
115d				 
115d cd 52 11			call input_curptr 
1160			;	ld hl, (input_start) 
1160			;	ld a, (input_cursor) 
1160			;	call addatohl 
1160				;push hl   ; save to come back to 
1160			 
1160				; shift everything up one to end of buffer 
1160			 
1160				;push hl 
1160				;dec de 
1160				;inc de 
1160			;	ldir 
1160				 
1160				;pop hl 
1160			 
1160				; are we adding to the end of line? 
1160			 
1160 3a 83 fd			ld a, (input_cursor) 
1163 47				ld b, a 
1164 3a 88 fd			ld a, (input_len) 
1167 b8				cp b 
1168 20 08			jr nz, .insmid   ; no, insert in middle of text 
116a			 
116a				; tack on the end of the line 
116a f1				pop af 
116b 77				ld (hl), a   ; save new char 
116c 23				inc hl 
116d			;	ld a, 0 
116d 36 00			ld (hl), 0 
116f c3 1c 11			jp input_right 
1172				 
1172			.insmid: 
1172				; hl has insertion point so move everything up one to allow for insertion 
1172				;call input_shiftright 
1172 f1				pop af 
1173			 
1173			.shufinsmid: 
1173 47				ld b, a     ; b contains new char, c prev char at this position  
1174 7e				ld a, (hl) 
1175			 
1175			;	cp 0    ; at end of string need to then dump new char and add term 
1175 b7				or a 
1176 28 07			jr z, .endinsmid 
1178 4f				ld c, a 
1179 78				ld a, b 
117a 77				ld (hl), a 
117b 23				inc hl 
117c 79				ld a, c 
117d 18 f4			jr .shufinsmid 
117f				 
117f			 
117f			 
117f			 
117f			.endinsmid: 
117f 78				ld a, b 
1180 77				ld (hl), a 
1181 23				inc hl 
1182			;	ld a, 0 
1182 36 00			ld (hl), 0 
1184			 
1184			 
1184			;	ld (hl), a   ; save new char 
1184			 
1184 c3 1c 11			jp input_right 
1187			 
1187			;input_shiftright: 
1187			;	; shift text right at cursor, hl has shift start 
1187			;	push hl 
1187			;	push de 
1187			;	push bc 
1187			; 
1187			; 
1187			;	; move to end of string past zero term 
1187			;	ld hl,(input_start) 
1187			;	ld a, (input_len) 
1187			;	call addatohl 
1187			;	inc hl 
1187			;;	inc hl 
1187			;;	inc hl 
1187			;	ld a, 0 
1187			;	ld (hl), a 
1187			;;	dec hl 
1187			;	 
1187			;;	ld (hl), a 
1187			;;	dec hl 
1187			; 
1187			;	push hl 
1187			;	pop de 
1187			;	inc de 
1187			;	 
1187			; 
1187			;;	ld hl,(input_start) 
1187			;;	ld a, (input_cursor) 
1187			;;	call addatohl 
1187			; 
1187			; 
1187			;	; calc how many bytes from cursor pos to end of string we need to shift 
1187			;	call input_lenrem    ; get bc length of remaining string 
1187			;	;ld a, (input_cursor) 
1187			;	;ld c, a 
1187			;	ld a, (input_len) 
1187			;	cp 2 
1187			;	jr z, .iskipzero	 
1187			;	;sub c 
1187			;	;inc a 
1187			;	;ld c, a 
1187			;	;ld b, 0 
1187			;	inc c 
1187			;	inc c 
1187			;	; move data 
1187			;	lddr 
1187			;.iskipzero: 
1187			; 
1187			;	pop bc 
1187			;	pop de 
1187			;	pop hl 
1187			;	ret	 
1187			 
1187			input_delchar: 
1187				; Delete char at cursor position 
1187 cd 46 11			call input_lenrem    ; get bc length of remaining string 
118a 2a 95 fd			ld hl, (input_start) 
118d 3a 83 fd			ld a, (input_cursor) 
1190 cd b1 0f			call addatohl 
1193			 
1193 e5				push hl 
1194 d1				pop de 
1195 1b				dec de 
1196			 
1196			.dl:	 
1196 ed a0			ldi  
1198 7e				ld a, (hl) 
1199			;	cp 0 
1199 b7				or a 
119a 28 02			jr z, .dldone 
119c 18 f8			jr .dl 
119e			.dldone: 
119e ed a0			ldi 
11a0			 
11a0 c3 15 11			jp input_left 
11a3			 
11a3			 
11a3			endif 
11a3			 
11a3			 
11a3			 
11a3			if EDIT_V1 
11a3			input_str: 
11a3			 
11a3				    	ld (input_at_pos),a      ; save display position to start 
11a3					add c 
11a3					ld (input_at_cursor),a	; save draw pos of cursor 
11a3					ld (input_start), hl     ; save ptr to buffer 
11a3					ld a, c 
11a3					call addatohl 
11a3					ld (input_ptr), hl     ; save ptr to point under the cursor 
11a3					ld a,d 
11a3				        ld (input_size), a       ; save length of input area 
11a3					ld a, c 
11a3					ld (input_cursor),a      ; init cursor start position  
11a3					ld a,e 
11a3				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
11a3					 
11a3					 
11a3			 
11a3			;		ld a,(input_ptr) 
11a3			;		ld (input_under_cursor),a 	; save what is under the cursor 
11a3			 
11a3			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
11a3					; init cursor shape if not set by the cin routines 
11a3					ld hl, cursor_shape 
11a3			if BASE_KEV 
11a3					ld a, 255 
11a3			else 
11a3					ld a, '#' 
11a3			endif 
11a3					ld (hl), a 
11a3					inc hl 
11a3					ld a, 0 
11a3					ld (hl), a 
11a3			 
11a3					ld a, CUR_BLINK_RATE 
11a3					ld (input_cur_flash), a 
11a3					ld a, 1 
11a3					ld (input_cur_onoff),a 
11a3			 
11a3			;	if DEBUG_INPUT 
11a3			;		push af 
11a3			;		ld a, 'I' 
11a3			;		ld (debug_mark),a 
11a3			;		pop af 
11a3			;		CALLMONITOR 
11a3			;	endif 
11a3			.is1:		; main entry loop 
11a3			 
11a3			 
11a3			 
11a3					; pause 1ms 
11a3			 
11a3					ld a, 1 
11a3					call aDelayInMS 
11a3			 
11a3					; dec flash counter 
11a3					ld a, (input_cur_flash) 
11a3					dec a 
11a3					ld (input_cur_flash), a 
11a3			;		cp 0 
11a3					or a 
11a3					jr nz, .nochgstate 
11a3			 
11a3			 
11a3					; change state 
11a3					ld a,(input_cur_onoff) 
11a3					neg 
11a3					ld (input_cur_onoff),a 
11a3			 
11a3			 
11a3					; reset on change of state 
11a3					ld a, CUR_BLINK_RATE 
11a3					ld (input_cur_flash), a 
11a3			 
11a3			.nochgstate: 
11a3					 
11a3					 
11a3			 
11a3					; display cursor  
11a3			 
11a3			;		ld hl, (input_start) 
11a3			;		ld a, (input_cursor) 
11a3			;		call addatohl 
11a3			 
11a3					; get char under cursor and replace with cursor 
11a3			ld hl, (input_ptr) 
11a3			;		ld a, (hl) 
11a3			;		ld (input_under_cursor),a 
11a3			;		ld a, '_' 
11a3			;		ld (hl), a 
11a3			 
11a3					; display string 
11a3			 
11a3					ld de, (input_start) 
11a3					ld a, (input_at_pos) 
11a3					call str_at_display 
11a3			;	        call update_display 
11a3			 
11a3					; find place to put the cursor 
11a3			;		add h 
11a3			;		ld l, display_row_1 
11a3			;		sub l 
11a3			; (input_at_pos) 
11a3					;ld c, a 
11a3			;		ld a, (input_cursor) 
11a3			;		ld l, (input_at_pos) 
11a3			;		;ld b, h 
11a3			;		add l 
11a3			;		ld (input_at_cursor),a 
11a3					;ld l,h 
11a3			 
11a3			;		ld h, 0 
11a3			;		ld l,(input_at_pos) 
11a3			;		ld a, (input_cursor) 
11a3			;		call addatohl 
11a3			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
11a3			;		call subafromhl 
11a3			;		ld a,l 
11a3			;		ld (input_at_cursor), a 
11a3			 
11a3				if DEBUG_INPUT 
11a3					ld a, (hardware_diag) 
11a3			;		cp 0 
11a3					or a 
11a3					jr z, .skip_input_diag 
11a3			 
11a3					ld a,(input_at_pos) 
11a3					ld hl, LFSRSeed 
11a3					call hexout 
11a3					ld a, (input_cursor) 
11a3					ld hl, LFSRSeed+2 
11a3					call hexout 
11a3					ld a,(input_at_cursor) 
11a3					ld hl, LFSRSeed+4 
11a3					call hexout 
11a3			 
11a3					ld a,(input_cur_onoff) 
11a3					ld hl, LFSRSeed+6 
11a3					call hexout 
11a3			 
11a3					ld a,(input_cur_flash) 
11a3					ld hl, LFSRSeed+8 
11a3					call hexout 
11a3			 
11a3					ld a,(input_len) 
11a3					ld hl, LFSRSeed+10 
11a3					call hexout 
11a3					ld hl, LFSRSeed+12 
11a3					ld a, 0 
11a3					ld (hl),a 
11a3					ld a, display_row_4 
11a3					ld de, LFSRSeed 
11a3					call str_at_display 
11a3					.skip_input_diag: 
11a3				endif 
11a3			 
11a3					; decide on if we are showing the cursor this time round 
11a3			 
11a3					ld a, (input_cur_onoff) 
11a3					cp 255 
11a3					jr z, .skipcur 
11a3			 
11a3			 
11a3					ld a,(input_at_cursor) 
11a3					ld de, cursor_shape 
11a3					call str_at_display 
11a3			 
11a3					; save length of current input string 
11a3					ld hl, (input_start) 
11a3					ld a, 0 
11a3					call strlent 
11a3					ld a,l 
11a3					ld (input_len),a 
11a3			 
11a3			.skipcur: 
11a3			 
11a3				        call update_display 
11a3					 
11a3			 
11a3			 
11a3					; wait 
11a3				 
11a3					; TODO loop without wait to flash the cursor and char under cursor	 
11a3					call cin    ; _wait 
11a3			 
11a3			;		cp 0 
11a3					or a 
11a3					jp z, .is1 
11a3			 
11a3					; get ptr to char to input into 
11a3			 
11a3					ld c,a 
11a3					ld hl, (input_start) 
11a3					ld a, (input_cursor) 
11a3					call addatohl 
11a3					ld (input_ptr), hl 
11a3					ld a,c 
11a3			 
11a3					; replace char under cursor 
11a3			 
11a3			;		ld hl, (input_ptr) 
11a3			;		ld a, (input_under_cursor) 	; get what is under the cursor 
11a3			;		ld (hl), a 
11a3			 
11a3			;	if DEBUG_INPUT 
11a3			;		push af 
11a3			;		ld a, 'i' 
11a3			;		ld (debug_mark),a 
11a3			;		pop af 
11a3			;		CALLMONITOR 
11a3			;	endif 
11a3					cp KEY_HOME 
11a3					jr nz, .iske 
11a3			 
11a3					ld a, (input_at_pos) 
11a3					ld (input_at_cursor),a 
11a3					ld a, 0 
11a3					ld (input_cursor), a 
11a3					jp .is1 
11a3					 
11a3			.iske:		cp KEY_END 
11a3					jr nz, .isknw 
11a3					jp .is1 
11a3			 
11a3			.isknw:		cp KEY_NEXTWORD 
11a3					jr nz, .iskpw 
11a3			 
11a3			.isknwm:	ld hl, (input_ptr) 
11a3					ld a,(hl)	 
11a3			;		cp 0 
11a3					or a 
11a3					jp z, .is1    ; end of string 
11a3					cp ' ' 
11a3					jp z, .is1    ; end of word 
11a3					inc hl 
11a3					ld (input_ptr), hl 
11a3					ld a, (input_at_cursor) 
11a3					inc a 
11a3					ld (input_at_cursor), a 
11a3					jr .isknwm 
11a3			 
11a3			.iskpw:		cp KEY_PREVWORD 
11a3					jr nz, .iskl 
11a3			.iskpwm:	 
11a3					ld hl, (input_ptr) 
11a3					ld a,(hl)	 
11a3			;		cp 0  
11a3					or a 
11a3					jp z, .is1    ; end of string 
11a3					cp ' ' 
11a3					jp z, .is1    ; end of word 
11a3					dec hl 
11a3					ld (input_ptr), hl 
11a3					ld a, (input_at_cursor) 
11a3					dec a 
11a3					ld (input_at_cursor), a 
11a3					jr .iskpwm 
11a3			 
11a3			 
11a3			.iskl:		cp KEY_LEFT 
11a3					jr nz, .isk1 
11a3			 
11a3					ld a, (input_cursor) 
11a3			 
11a3			;		cp 0 
11a3					or a 
11a3					jp z, .is1 		; at start of line to ignore  
11a3			 
11a3					dec  a 		; TODO check underflow 
11a3					ld (input_cursor), a 
11a3			 
11a3					ld hl, (input_ptr) 
11a3					dec hl 
11a3					ld (input_ptr), hl 
11a3					 
11a3					ld a, (input_at_cursor) 
11a3					dec a 
11a3					ld (input_at_cursor), a 
11a3			 
11a3					ld a, 1		; show cursor moving 
11a3					ld (input_cur_onoff),a 
11a3					ld a, CUR_BLINK_RATE 
11a3					ld (input_cur_flash), a 
11a3			 
11a3					jp .is1 
11a3			 
11a3			.isk1:		cp KEY_RIGHT 
11a3					jr nz, .isk2 
11a3			 
11a3					ld a,(input_len)		; TODO BUG why cant i load e direct? 
11a3					ld e,a 
11a3					ld a, (input_cursor) 
11a3					cp e 
11a3					jp z, .is1		; at the end of string so dont go right 
11a3			 
11a3					inc  a 		; TODO check overflow 
11a3					ld (input_cursor), a 
11a3			 
11a3					ld a, (input_at_cursor) 
11a3					inc a 
11a3					ld (input_at_cursor), a 
11a3			 
11a3					ld hl, (input_ptr) 
11a3					inc hl 
11a3					ld (input_ptr), hl 
11a3			 
11a3					ld a, 1		; show cursor moving 
11a3					ld (input_cur_onoff),a 
11a3					ld a, CUR_BLINK_RATE 
11a3					ld (input_cur_flash), a 
11a3			 
11a3					jp .is1 
11a3			 
11a3			.isk2:		cp KEY_UP 
11a3			 
11a3					jr nz, .isk3 
11a3			 
11a3					; swap last command with the current on 
11a3			 
11a3					; move cursor to start of string 
11a3					ld hl, (input_start) 
11a3					ld (input_ptr), hl 
11a3			 
11a3					ld a, (input_at_pos) 
11a3					ld (input_at_cursor), a 
11a3			 
11a3					ld a, 0 
11a3					ld (input_cursor), a 
11a3					 
11a3					; swap input and last command buffers 
11a3			 
11a3					ld hl, os_cli_cmd 
11a3					ld de, os_last_cmd 
11a3					ld b, 255 
11a3			.swap1:		ld a, (hl) 
11a3					ld c,a 
11a3					ld a, (de) 
11a3					ld (hl), a 
11a3					ld a,c 
11a3					ld (de),a 
11a3					inc hl 
11a3					inc de 
11a3					djnz .swap1 
11a3			 
11a3			 
11a3			 
11a3			 
11a3			 
11a3					jp .is1 
11a3			 
11a3			.isk3:		cp KEY_BS 
11a3					jr nz, .isk4 
11a3			 
11a3					ld a, (input_cursor) 
11a3			 
11a3			;		cp 0 
11a3					or a 
11a3					jp z, .is1 		; at start of line to ignore  
11a3			 
11a3					dec  a 		; TODO check underflow 
11a3					ld (input_cursor), a 
11a3			 
11a3					; hl is source 
11a3					; de needs to be source - 1 
11a3			 
11a3			;		ld a, 0 
11a3			;		dec hl 
11a3			;		ld (hl), a 
11a3			 
11a3					ld hl, (input_ptr) 
11a3					dec hl 
11a3					ld (input_ptr), hl 
11a3			 
11a3					; shift all data 
11a3			 
11a3					push hl 
11a3					inc hl 
11a3					pop de 
11a3					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
11a3					ld c,a 
11a3					ld b,0 
11a3					ldir  
11a3			 
11a3			 
11a3			 
11a3			 
11a3					ld a, (input_at_cursor) 
11a3					dec a 
11a3					ld (input_at_cursor), a 
11a3			 
11a3			 
11a3					ld a, 1		; show cursor moving 
11a3					ld (input_cur_onoff),a 
11a3					ld a, CUR_BLINK_RATE 
11a3					ld (input_cur_flash), a 
11a3			 
11a3					; remove char 
11a3					ld a, (input_at_cursor) 
11a3					inc a 
11a3					ld de,.iblank 
11a3					call str_at_display 
11a3			 
11a3					jp .is1 
11a3			 
11a3			.isk4:		cp KEY_CR 
11a3					jr z, .endinput 
11a3			 
11a3					; else add the key press to the end 
11a3			 
11a3					ld c, a			; save key pressed 
11a3			 
11a3					ld a,(hl)		; get what is currently under char 
11a3			 
11a3			;		cp 0			; we are at the end of the string 
11a3					or a 
11a3					jr nz, .onchar 
11a3					 
11a3					; add a char to the end of the string 
11a3				 
11a3					ld (hl),c 
11a3					inc hl 
11a3			;		ld a,' ' 
11a3			;		ld (hl),a 
11a3			;		inc hl 
11a3					ld a,0 
11a3					ld (hl),a 
11a3					dec hl 
11a3			 
11a3					ld a, (input_cursor) 
11a3					inc a				; TODO check max string length and scroll  
11a3					ld (input_cursor), a		; inc cursor pos 
11a3							 
11a3					ld a, (input_at_cursor) 
11a3					inc a 
11a3					ld (input_at_cursor), a 
11a3			 
11a3					ld hl, (input_ptr) 
11a3					inc hl 
11a3					ld (input_ptr), hl 
11a3			 
11a3					ld hl, (input_ptr) 
11a3					inc hl 
11a3					ld (input_ptr), hl 
11a3			;	if DEBUG_INPUT 
11a3			;		push af 
11a3			;		ld a, '+' 
11a3			;		ld (debug_mark),a 
11a3			;		pop af 
11a3			;		CALLMONITOR 
11a3			;	endif 
11a3					ld a, 1		; show cursor moving 
11a3					ld (input_cur_onoff),a 
11a3					ld a, CUR_BLINK_RATE 
11a3					ld (input_cur_flash), a 
11a3					jp .is1 
11a3					 
11a3			 
11a3			 
11a3					; if on a char then insert 
11a3			.onchar: 
11a3			 
11a3					; TODO over flow check: make sure insert does not blow out buffer 
11a3			 
11a3					; need to do some maths to use lddr 
11a3			 
11a3					push hl   ; save char pos 
11a3					push bc 
11a3			 
11a3					ld hl, (input_start) 
11a3					ld a, (input_len) 
11a3					call addatohl  		; end of string 
11a3					inc hl 
11a3					inc hl		; past zero term 
11a3					push hl 
11a3					inc hl 
11a3					push hl  
11a3			 
11a3								; start and end of lddr set, now how much to move? 
11a3			 
11a3							 
11a3					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11a3					ld b,a 
11a3					ld a,(input_len) 
11a3					ld e,a 
11a3					sub b 
11a3					inc a		;?? 
11a3					inc a		;?? 
11a3					inc a		;?? 
11a3			 
11a3					ld b,0 
11a3					ld c,a 
11a3			 
11a3				if DEBUG_INPUT 
11a3					push af 
11a3					ld a, 'i' 
11a3					ld (debug_mark),a 
11a3					pop af 
11a3			;		CALLMONITOR 
11a3				endif 
11a3					pop de 
11a3					pop hl 
11a3				if DEBUG_INPUT 
11a3					push af 
11a3					ld a, 'I' 
11a3					ld (debug_mark),a 
11a3					pop af 
11a3			;		CALLMONITOR 
11a3				endif 
11a3					lddr 
11a3				 
11a3			 
11a3			 
11a3					; TODO have a key for insert/overwrite mode???? 
11a3					pop bc 
11a3					pop hl 
11a3					ld (hl), c		; otherwise overwrite current char 
11a3					 
11a3			 
11a3			 
11a3			 
11a3					ld a, (input_cursor) 
11a3					inc  a 		; TODO check overflow 
11a3					ld (input_cursor), a 
11a3			 
11a3					ld a, (input_at_cursor) 
11a3					inc a 
11a3					ld (input_at_cursor), a 
11a3			 
11a3					jp .is1 
11a3			 
11a3			.endinput:	; TODO look for end of string 
11a3			 
11a3					; add trailing space for end of token 
11a3			 
11a3					ld hl, (input_start) 
11a3					ld a,(input_len) 
11a3					call addatohl 
11a3					ld a, ' ' 
11a3					ld (hl),a 
11a3					; TODO eof of parse marker 
11a3			 
11a3					inc hl 
11a3					ld a, 0 
11a3					ld (hl),a 
11a3			 
11a3			 
11a3					ret 
11a3			 
11a3			.iblank: db " ",0 
11a3			 
11a3			 
11a3			input_str_prev:	ld (input_at_pos), a 
11a3					ld (input_start), hl 
11a3					ld a,1			; add cursor 
11a3					ld (hl),a 
11a3					inc hl 
11a3					ld a,0 
11a3					ld (hl),a 
11a3					ld (input_ptr), hl 
11a3					ld a,d 
11a3					ld (input_size), a 
11a3					ld a,0 
11a3					ld (input_cursor),a 
11a3			.instr1:	 
11a3			 
11a3					; TODO do block cursor 
11a3					; TODO switch cursor depending on the modifer key 
11a3			 
11a3					; update cursor shape change on key hold 
11a3			 
11a3					ld hl, (input_ptr) 
11a3					dec hl 
11a3					ld a,(cursor_shape) 
11a3					ld (hl), a 
11a3			 
11a3					; display entered text 
11a3					ld a,(input_at_pos) 
11a3			            	CALL fLCD_Pos       ;Position cursor to location in A 
11a3			            	LD   de, (input_start) 
11a3			            	CALL fLCD_Str       ;Display string pointed to by DE 
11a3			 
11a3					call cin 
11a3			;		cp 0 
11a3					or a 
11a3					jr z, .instr1 
11a3			 
11a3					; proecess keyboard controls first 
11a3			 
11a3					ld hl,(input_ptr) 
11a3			 
11a3					cp KEY_CR	 ; pressing enter ends input 
11a3					jr z, .instrcr 
11a3			 
11a3					cp KEY_BS 	; back space 
11a3					jr nz, .instr2 
11a3					; process back space 
11a3			 
11a3					; TODO stop back space if at start of string 
11a3					dec hl 
11a3					dec hl ; to over write cursor 
11a3					ld a,(cursor_shape) 
11a3					;ld a,0 
11a3					ld (hl),a 
11a3					inc hl 
11a3					ld a," " 
11a3					ld (hl),a 
11a3					ld (input_ptr),hl 
11a3					 
11a3			 
11a3					jr .instr1 
11a3			 
11a3			.instr2:	cp KEY_LEFT    ; cursor left 
11a3					jr nz, .instr3 
11a3					dec hl 
11a3					ld (input_ptr),hl 
11a3					jr .instr1 
11a3				 
11a3			.instr3:	cp KEY_RIGHT      ; cursor right 
11a3					jr nz, .instr4 
11a3					inc hl 
11a3					ld (input_ptr),hl 
11a3					jr .instr1 
11a3			 
11a3			.instr4:	cp KEY_HOME    ; jump to start of line 
11a3					jr nz, .instr5 
11a3					dec hl 
11a3					ld (input_ptr),hl 
11a3					jr .instr1 
11a3			 
11a3			.instr5:	cp KEY_END     ; jump to end of line 
11a3					jr nz, .instr6 
11a3					dec hl 
11a3					ld (input_ptr),hl 
11a3					jr .instr1 
11a3			.instr6:        cp KEY_UP      ; recall last command 
11a3					jr nz, .instrnew 
11a3			 
11a3				ld hl, scratch 
11a3				ld de, os_last_cmd 
11a3				call strcpy 
11a3					jr .instr1 
11a3			 
11a3			 
11a3			.instrnew:	; no special key pressed to see if we have room to store it 
11a3			 
11a3					; TODO do string size test 
11a3			 
11a3					dec hl ; to over write cursor 
11a3					ld (hl),a 
11a3					inc hl 
11a3					ld a,(cursor_shape) 
11a3					ld (hl),a 
11a3					inc hl 
11a3					ld a,0 
11a3					ld (hl),a 
11a3			 
11a3					ld (input_ptr),hl 
11a3					 
11a3					jr .instr1 
11a3			.instrcr:	dec hl		; remove cursor 
11a3					ld a,' '	; TODO add a trailing space for safety 
11a3					ld (hl),a 
11a3					inc hl 
11a3					ld a,0 
11a3					ld (hl),a 
11a3			 
11a3			 
11a3					; if at end of line scroll up    
11a3					; TODO detecting only end of line 4 for scroll up  
11a3			 
11a3					;ld   
11a3			 
11a3					ret 
11a3			 
11a3			 
11a3			endif 
11a3			; strcpy hl = dest, de source 
11a3			 
11a3 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11a4 b7			            OR   A              ;Null terminator? 
11a5 c8			            RET  Z              ;Yes, so finished 
11a6 1a					ld a,(de) 
11a7 77					ld (hl),a 
11a8 13			            INC  DE             ;Point to next character 
11a9 23					inc hl 
11aa 18 f7		            JR   strcpy       ;Repeat 
11ac c9					ret 
11ad			 
11ad			 
11ad			; TODO string_at  
11ad			; pass string which starts with lcd offset address and then null term string 
11ad			 
11ad			; TODO string to dec 
11ad			; TODO string to hex 
11ad			; TODO byte to string hex 
11ad			; TODO byte to string dec 
11ad			 
11ad			 
11ad			 
11ad			; from z80uartmonitor 
11ad			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11ad			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11ad			; pass hl for where to put the text 
11ad			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11ad c5			hexout:	PUSH BC 
11ae f5					PUSH AF 
11af 47					LD B, A 
11b0					; Upper nybble 
11b0 cb 3f				SRL A 
11b2 cb 3f				SRL A 
11b4 cb 3f				SRL A 
11b6 cb 3f				SRL A 
11b8 cd c8 11				CALL tohex 
11bb 77					ld (hl),a 
11bc 23					inc hl	 
11bd					 
11bd					; Lower nybble 
11bd 78					LD A, B 
11be e6 0f				AND 0FH 
11c0 cd c8 11				CALL tohex 
11c3 77					ld (hl),a 
11c4 23					inc hl	 
11c5					 
11c5 f1					POP AF 
11c6 c1					POP BC 
11c7 c9					RET 
11c8					 
11c8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11c8			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
11c8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11c8			tohex: 
11c8 e5					PUSH HL 
11c9 d5					PUSH DE 
11ca 16 00				LD D, 0 
11cc 5f					LD E, A 
11cd 21 d5 11				LD HL, .DATA 
11d0 19					ADD HL, DE 
11d1 7e					LD A, (HL) 
11d2 d1					POP DE 
11d3 e1					POP HL 
11d4 c9					RET 
11d5			 
11d5			.DATA: 
11d5 30					DEFB	30h	; 0 
11d6 31					DEFB	31h	; 1 
11d7 32					DEFB	32h	; 2 
11d8 33					DEFB	33h	; 3 
11d9 34					DEFB	34h	; 4 
11da 35					DEFB	35h	; 5 
11db 36					DEFB	36h	; 6 
11dc 37					DEFB	37h	; 7 
11dd 38					DEFB	38h	; 8 
11de 39					DEFB	39h	; 9 
11df 41					DEFB	41h	; A 
11e0 42					DEFB	42h	; B 
11e1 43					DEFB	43h	; C 
11e2 44					DEFB	44h	; D 
11e3 45					DEFB	45h	; E 
11e4 46					DEFB	46h	; F 
11e5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
11e5			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
11e5			;;    subtract $30, if result > 9 then subtract $7 more 
11e5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
11e5			atohex: 
11e5 d6 30				SUB $30 
11e7 fe 0a				CP 10 
11e9 f8					RET M		; If result negative it was 0-9 so we're done 
11ea d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
11ec c9					RET		 
11ed			 
11ed			 
11ed			 
11ed			 
11ed			; Get 2 ASCII characters as hex byte from pointer in hl 
11ed			 
11ed			BYTERD: 
11ed 16 00			LD	D,00h		;Set up 
11ef cd f7 11			CALL	HEXCON		;Get byte and convert to hex 
11f2 87				ADD	A,A		;First nibble so 
11f3 87				ADD	A,A		;multiply by 16 
11f4 87				ADD	A,A		; 
11f5 87				ADD	A,A		; 
11f6 57				LD	D,A		;Save hi nibble in D 
11f7			HEXCON: 
11f7 7e				ld a, (hl)		;Get next chr 
11f8 23				inc hl 
11f9 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
11fb fe 0a			CP	00Ah		;Is it 0-9 ? 
11fd 38 02			JR	C,NALPHA	;If so miss next bit 
11ff d6 07			SUB	007h		;Else convert alpha 
1201			NALPHA: 
1201 b2				OR	D		;Add hi nibble back 
1202 c9				RET			; 
1203			 
1203			 
1203			; 
1203			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1203			; Since the routines get_byte and therefore get_nibble are called, only valid 
1203			; characters (0-9a-f) are accepted. 
1203			; 
1203			;get_word        push    af 
1203			;                call    get_byte        ; Get the upper byte 
1203			;                ld      h, a 
1203			;                call    get_byte        ; Get the lower byte 
1203			;                ld      l, a 
1203			;                pop     af 
1203			;                ret 
1203			; 
1203			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1203			; the routine get_nibble is used only valid characters are accepted - the  
1203			; input routine only accepts characters 0-9a-f. 
1203			; 
1203 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1204 7e					ld a,(hl) 
1205 23					inc hl 
1206 cd 2b 12		                call    nibble2val      ; Get upper nibble 
1209 cb 07		                rlc     a 
120b cb 07		                rlc     a 
120d cb 07		                rlc     a 
120f cb 07		                rlc     a 
1211 47			                ld      b, a            ; Save upper four bits 
1212 7e					ld a,(hl) 
1213 cd 2b 12		                call    nibble2val      ; Get lower nibble 
1216 b0			                or      b               ; Combine both nibbles 
1217 c1			                pop     bc              ; Restore B (and C) 
1218 c9			                ret 
1219			; 
1219			; Get a hexadecimal digit from the serial line. This routine blocks until 
1219			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1219			; to the serial line interface. The lower 4 bits of A contain the value of  
1219			; that particular digit. 
1219			; 
1219			;get_nibble      ld a,(hl)           ; Read a character 
1219			;                call    to_upper        ; Convert to upper case 
1219			;                call    is_hex          ; Was it a hex digit? 
1219			;                jr      nc, get_nibble  ; No, get another character 
1219			 ;               call    nibble2val      ; Convert nibble to value 
1219			 ;               call    print_nibble 
1219			 ;               ret 
1219			; 
1219			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1219			; A valid hexadecimal digit is denoted by a set C flag. 
1219			; 
1219			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1219			;                ret     nc              ; Yes 
1219			;                cp      '0'             ; Less than '0'? 
1219			;                jr      nc, is_hex_1    ; No, continue 
1219			;                ccf                     ; Complement carry (i.e. clear it) 
1219			;                ret 
1219			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1219			;                ret     c               ; Yes 
1219			;                cp      'A'             ; Less than 'A'? 
1219			;                jr      nc, is_hex_2    ; No, continue 
1219			;                ccf                     ; Yes - clear carry and return 
1219			;                ret 
1219			;is_hex_2        scf                     ; Set carry 
1219			;                ret 
1219			; 
1219			; Convert a single character contained in A to upper case: 
1219			; 
1219 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
121b d8			                ret     c 
121c fe 7b		                cp      'z' + 1         ; > 'z'? 
121e d0			                ret     nc              ; Nothing to do, either 
121f e6 5f		                and     $5f             ; Convert to upper case 
1221 c9			                ret 
1222			 
1222			 
1222			to_lower: 
1222			 
1222			   ; if char is in [A-Z] make it lower case 
1222			 
1222			   ; enter : a = char 
1222			   ; exit  : a = lower case char 
1222			   ; uses  : af 
1222			 
1222 fe 41		   cp 'A' 
1224 d8			   ret c 
1225			    
1225 fe 5b		   cp 'Z'+1 
1227 d0			   ret nc 
1228			    
1228 f6 20		   or $20 
122a c9			   ret 
122b			 
122b			; 
122b			; Expects a hexadecimal digit (upper case!) in A and returns the 
122b			; corresponding value in A. 
122b			; 
122b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
122d 38 02		                jr      c, nibble2val_1 ; Yes 
122f d6 07		                sub     7               ; Adjust for A-F 
1231 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1233 e6 0f		                and     $f              ; Only return lower 4 bits 
1235 c9			                ret 
1236			; 
1236			; Print_nibble prints a single hex nibble which is contained in the lower  
1236			; four bits of A: 
1236			; 
1236			;print_nibble    push    af              ; We won't destroy the contents of A 
1236			;                and     $f              ; Just in case... 
1236			;                add     a, '0'             ; If we have a digit we are done here. 
1236			;                cp      '9' + 1         ; Is the result > 9? 
1236			;                jr      c, print_nibble_1 
1236			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1236			;print_nibble_1  call    putc            ; Print the nibble and 
1236			;                pop     af              ; restore the original value of A 
1236			;                ret 
1236			;; 
1236			;; Send a CR/LF pair: 
1236			; 
1236			;crlf            push    af 
1236			;                ld      a, cr 
1236			;                call    putc 
1236			;                ld      a, lf 
1236			;                call    putc 
1236			;                pop     af 
1236			;                ret 
1236			; 
1236			; Print_word prints the four hex digits of a word to the serial line. The  
1236			; word is expected to be in HL. 
1236			; 
1236			;print_word      push    hl 
1236			;                push    af 
1236			;                ld      a, h 
1236			;                call    print_byte 
1236			;                ld      a, l 
1236			;                call    print_byte 
1236			;                pop     af 
1236			;                pop     hl 
1236			;                ret 
1236			; 
1236			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1236			; The byte to be printed is expected to be in A. 
1236			; 
1236			;print_byte      push    af              ; Save the contents of the registers 
1236			;                push    bc 
1236			;                ld      b, a 
1236			;                rrca 
1236			;                rrca 
1236			;                rrca 
1236			;                rrca 
1236			;                call    print_nibble    ; Print high nibble 
1236			;                ld      a, b 
1236			;                call    print_nibble    ; Print low nibble 
1236			;                pop     bc              ; Restore original register contents 
1236			;                pop     af 
1236			;                ret 
1236			 
1236			 
1236			 
1236			 
1236			 
1236			fourehexhl:  
1236 7e				ld a,(hl) 
1237 cd e5 11			call atohex 
123a cb 3f				SRL A 
123c cb 3f				SRL A 
123e cb 3f				SRL A 
1240 cb 3f				SRL A 
1242 47				ld b, a 
1243 23				inc hl 
1244 7e				ld a,(hl) 
1245 23				inc hl 
1246 cd e5 11			call atohex 
1249 80				add b 
124a 57				ld d,a 
124b 7e				ld a,(hl) 
124c cd e5 11			call atohex 
124f cb 3f				SRL A 
1251 cb 3f				SRL A 
1253 cb 3f				SRL A 
1255 cb 3f				SRL A 
1257 47				ld b, a 
1258 23				inc hl 
1259 7e				ld a,(hl) 
125a 23				inc hl 
125b cd e5 11			call atohex 
125e 80				add b 
125f 5f				ld e, a 
1260 d5				push de 
1261 e1				pop hl 
1262 c9				ret 
1263			 
1263			; pass hl. returns z set if the byte at hl is a digit 
1263			;isdigithl:  
1263			;	push bc 
1263			;	ld a,(hl) 
1263			;	cp ':' 
1263			;	jr nc, .isdf 		; > 
1263			;	cp '0' 
1263			;	jr c, .isdf		; < 
1263			; 
1263			;	; TODO find a better way to set z 
1263			; 
1263			;	ld b,a 
1263			;	cp b 
1263			;	pop bc 
1263			;	ret 
1263			; 
1263			;.isdf:	; not digit so clear z 
1263			; 
1263			;	; TODO find a better way to unset z 
1263			; 
1263			;	ld b,a 
1263			;	inc b 
1263			;	cp b 
1263			; 
1263			;	pop bc 
1263			;	ret 
1263				 
1263				 
1263			 
1263			 
1263			; pass hl as the four byte address to load 
1263			 
1263			get_word_hl:  
1263 e5				push hl 
1264 cd 03 12			call get_byte 
1267				 
1267 47				ld b, a 
1268			 
1268 e1				pop hl 
1269 23				inc hl 
126a 23				inc hl 
126b			 
126b			; TODO not able to handle a-f  
126b 7e				ld a,(hl) 
126c			;	;cp ':' 
126c			;	cp 'g' 
126c			;	jr nc, .single_byte_hl 		; > 
126c			;	cp 'G' 
126c			;	jr nc, .single_byte_hl 		; > 
126c			;	cp '0' 
126c			;	jr c, .single_byte_hl		; < 
126c			 
126c				;call isdigithl 
126c			;	cp 0 
126c b7				or a 
126d 28 06			jr z, .single_byte_hl 
126f			 
126f			.getwhln:   ; hex word so get next byte 
126f			 
126f cd 03 12			call get_byte 
1272 6f				ld l, a 
1273 60				ld h,b 
1274 c9				ret 
1275 68			.single_byte_hl:   ld l,b 
1276 26 00				ld h,0 
1278 c9					ret 
1279			 
1279			 
1279			 
1279			 
1279 21 f1 1c			ld hl,asc+1 
127c			;	ld a, (hl) 
127c			;	call nibble2val 
127c cd 03 12			call get_byte 
127f			 
127f			;	call fourehexhl 
127f 32 23 f1			ld (scratch+52),a 
1282				 
1282 21 21 f1			ld hl,scratch+50 
1285 22 12 f4			ld (os_cur_ptr),hl 
1288			 
1288 c9				ret 
1289			 
1289			 
1289			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1289			 
1289			; Decimal Unsigned Version 
1289			 
1289			;Number in a to decimal ASCII 
1289			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1289			;Example: display a=56 as "056" 
1289			;input: a = number 
1289			;Output: a=0,value of a in the screen 
1289			;destroys af,bc (don't know about hl and de) 
1289			DispAToASCII: 
1289 0e 9c			ld	c,-100 
128b cd 95 12			call	.Na1 
128e 0e f6			ld	c,-10 
1290 cd 95 12			call	.Na1 
1293 0e ff			ld	c,-1 
1295 06 2f		.Na1:	ld	b,'0'-1 
1297 04			.Na2:	inc	b 
1298 81				add	a,c 
1299 38 fc			jr	c,.Na2 
129b 91				sub	c		;works as add 100/10/1 
129c f5				push af		;safer than ld c,a 
129d 78				ld	a,b		;char is in b 
129e			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
129e f1				pop af		;safer than ld a,c 
129f c9				ret 
12a0			 
12a0			; Decimal Signed Version 
12a0			 
12a0			; DispA 
12a0			; -------------------------------------------------------------- 
12a0			; Converts a signed integer value to a zero-terminated ASCII 
12a0			; string representative of that value (using radix 10). 
12a0			; -------------------------------------------------------------- 
12a0			; INPUTS: 
12a0			;     HL     Value to convert (two's complement integer). 
12a0			;     DE     Base address of string destination. (pointer). 
12a0			; -------------------------------------------------------------- 
12a0			; OUTPUTS: 
12a0			;     None 
12a0			; -------------------------------------------------------------- 
12a0			; REGISTERS/MEMORY DESTROYED 
12a0			; AF HL 
12a0			; -------------------------------------------------------------- 
12a0			 
12a0			;DispHLToASCII: 
12a0			;   push    de 
12a0			;   push    bc 
12a0			; 
12a0			;; Detect sign of HL. 
12a0			;    bit    7, h 
12a0			;    jr     z, ._DoConvert 
12a0			; 
12a0			;; HL is negative. Output '-' to string and negate HL. 
12a0			;    ld     a, '-' 
12a0			;    ld     (de), a 
12a0			;    inc    de 
12a0			; 
12a0			;; Negate HL (using two's complement) 
12a0			;    xor    a 
12a0			;    sub    l 
12a0			;    ld     l, a 
12a0			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12a0			;    sbc    a, h 
12a0			;    ld     h, a 
12a0			; 
12a0			;; Convert HL to digit characters 
12a0			;._DoConvert: 
12a0			;    ld     b, 0     ; B will count character length of number 
12a0			;-   ld     a, 10 
12a0			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12a0			;    push   af 
12a0			;    inc    b 
12a0			;    ld     a, h 
12a0			;    or     l 
12a0			;    jr     nz, - 
12a0			; 
12a0			;; Retrieve digits from stack 
12a0			;-   pop    af 
12a0			;    or     $30 
12a0			;    ld     (de), a 
12a0			;    inc    de 
12a0			;    djnz   - 
12a0			; 
12a0			;; Terminate string with NULL 
12a0			;    xor    a 
12a0			;    ld     (de), a 
12a0			; 
12a0			;    pop    bc 
12a0			;    pop    de 
12a0			;    ret 
12a0			 
12a0			;Comments 
12a0			; 
12a0			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12a0			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12a0			;    Note that the output string will not be fixed-width. 
12a0			; 
12a0			;Example Usage 
12a0			; 
12a0			;    ld    hl, -1004 
12a0			;    ld    de, OP1 
12a0			;    call  DispA 
12a0			;    ld    hl, OP1 
12a0			;    syscall  PutS 
12a0			 
12a0			 
12a0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12a0			 
12a0			 
12a0			;Converts an ASCII string to an unsigned 16-bit integer 
12a0			;Quits when it reaches a non-decimal digit 
12a0			 
12a0			string_to_uint16: 
12a0			atoui_16: 
12a0			;Input: 
12a0			;     DE points to the string 
12a0			;Outputs: 
12a0			;     HL is the result 
12a0			;     A is the 8-bit value of the number 
12a0			;     DE points to the byte after the number 
12a0			;Destroys: 
12a0			;     BC 
12a0			;       if the string is non-empty, BC is HL/10 
12a0			;Size:  24 bytes 
12a0			;Speed: 42+d(104+{0,9}) 
12a0			;       d is the number of digits in the number 
12a0			;       max is 640 cycles for a 5 digit number 
12a0			;Assuming no leading zeros: 
12a0			;1 digit:  146cc 
12a0			;2 digit:  250cc 
12a0			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12a0			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12a0			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12a0			;avg: 544.81158447265625cc (544+13297/16384) 
12a0			;=============================================================== 
12a0 21 00 00		  ld hl,0 
12a3			.u16a: 
12a3 1a			  ld a,(de) 
12a4 d6 30		  sub 30h 
12a6 fe 0a		  cp 10 
12a8 d0			  ret nc 
12a9 13			  inc de 
12aa 44			  ld b,h 
12ab 4d			  ld c,l 
12ac 29			  add hl,hl 
12ad 29			  add hl,hl 
12ae 09			  add hl,bc 
12af 29			  add hl,hl 
12b0 85			  add a,l 
12b1 6f			  ld l,a 
12b2 30 ef		  jr nc,.u16a 
12b4 24			  inc h 
12b5 c3 a3 12		  jp .u16a 
12b8			 
12b8			 
12b8			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12b8			 
12b8			;written by Zeda 
12b8			;Converts a 16-bit unsigned integer to an ASCII string. 
12b8			 
12b8			uitoa_16: 
12b8			;Input: 
12b8			;   DE is the number to convert 
12b8			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12b8			;Output: 
12b8			;   HL points to the null-terminated ASCII string 
12b8			;      NOTE: This isn't necessarily the same as the input HL. 
12b8 d5			  push de 
12b9 c5			  push bc 
12ba f5			  push af 
12bb eb			  ex de,hl 
12bc			 
12bc 01 f0 d8		  ld bc,-10000 
12bf 3e 2f		  ld a,'0'-1 
12c1 3c			  inc a 
12c2 09			  add hl,bc  
12c3 38 fc		   jr c,$-2 
12c5 12			  ld (de),a 
12c6 13			  inc de 
12c7			 
12c7 01 e8 03		  ld bc,1000 
12ca 3e 3a		  ld a,'9'+1 
12cc 3d			  dec a  
12cd 09			  add hl,bc  
12ce 30 fc		   jr nc,$-2 
12d0 12			  ld (de),a 
12d1 13			  inc de 
12d2			 
12d2 01 9c ff		  ld bc,-100 
12d5 3e 2f		  ld a,'0'-1 
12d7 3c			  inc a  
12d8 09			  add hl,bc  
12d9 38 fc		   jr c,$-2 
12db 12			  ld (de),a 
12dc 13			  inc de 
12dd			 
12dd 7d			  ld a,l 
12de 26 3a		  ld h,'9'+1 
12e0 25			  dec h  
12e1 c6 0a		  add a,10  
12e3 30 fb		   jr nc,$-3 
12e5 c6 30		  add a,'0' 
12e7 eb			  ex de,hl 
12e8 72			  ld (hl),d 
12e9 23			  inc hl 
12ea 77			  ld (hl),a 
12eb 23			  inc hl 
12ec 36 00		  ld (hl),0 
12ee			 
12ee			;Now strip the leading zeros 
12ee 0e fa		  ld c,-6 
12f0 09			  add hl,bc 
12f1 3e 30		  ld a,'0' 
12f3 23			  inc hl  
12f4 be			  cp (hl)  
12f5 28 fc		  jr z,$-2 
12f7			 
12f7			;Make sure that the string is non-empty! 
12f7 7e			  ld a,(hl) 
12f8 b7			  or a 
12f9 20 01		  jr nz,.atoub 
12fb 2b			  dec hl 
12fc			.atoub: 
12fc			 
12fc f1			  pop af 
12fd c1			  pop bc 
12fe d1			  pop de 
12ff c9			  ret 
1300			 
1300			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1300			 
1300			toUpper: 
1300			;A is the char. 
1300			;If A is a lowercase letter, this sets it to the matching uppercase 
1300			;18cc or 30cc or 41cc 
1300			;avg: 26.75cc 
1300 fe 61		  cp 'a' 
1302 d8			  ret c 
1303 fe 7b		  cp 'z'+1 
1305 d0			  ret nc 
1306 d6 20		  sub 'a'-'A' 
1308 c9			  ret 
1309			 
1309			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1309			 
1309			; String Length 
1309			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1309			 
1309			; Get the length of the null-terminated string starting at $8000 hl 
1309			;    LD     HL, $8000 
1309			 
1309			strlenz: 
1309			 
1309 af			    XOR    A               ; Zero is the value we are looking for. 
130a 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
130b 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
130c			                           ; 65, 536 bytes (the entire addressable memory space). 
130c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
130e			 
130e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
130e 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
130f 6f			    LD     L, A             ; number of bytes 
1310 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1312 2b			    DEC    HL              ; Compensate for null. 
1313 c9				ret 
1314			 
1314			; Get the length of the A terminated string starting at $8000 hl 
1314			;    LD     HL, $8000 
1314			 
1314			strlent: 
1314			 
1314			                  ; A is the value we are looking for. 
1314 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1316 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1318			                           ; 65, 536 bytes (the entire addressable memory space). 
1318 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
131a			 
131a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
131a 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
131c 2e 00		    LD     L, 0             ; number of bytes 
131e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1320 2b			    DEC    HL              ; Compensate for null. 
1321 c9				ret 
1322			 
1322			 
1322			;Comparing Strings 
1322			 
1322			;IN    HL     Address of string1. 
1322			;      DE     Address of string2. 
1322			 
1322			; doc given but wrong??? 
1322			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1322			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1322			; tested 
1322			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1322			 
1322			strcmp_old: 
1322 e5			    PUSH   HL 
1323 d5			    PUSH   DE 
1324			 
1324 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1325 be			    CP     (HL)            ; (want to minimize work). 
1326 38 01		    JR     C, Str1IsBigger 
1328 7e			    LD     A, (HL) 
1329			 
1329			Str1IsBigger: 
1329 4f			    LD     C, A             ; Put length in BC 
132a 06 00		    LD     B, 0 
132c 13			    INC    DE              ; Increment pointers to meat of string. 
132d 23			    INC    HL 
132e			 
132e			CmpLoop: 
132e 1a			    LD     A, (DE)          ; Compare bytes. 
132f ed a1		    CPI 
1331 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1333 13			    INC    DE              ; Update pointer. 
1334 ea 2e 13		    JP     PE, CmpLoop 
1337			 
1337 d1			    POP    DE 
1338 e1			    POP    HL 
1339 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
133a be			    CP     (HL) 
133b c9			    RET 
133c			 
133c			NoMatch: 
133c 2b			    DEC    HL 
133d be			    CP     (HL)            ; Compare again to affect carry. 
133e d1			    POP    DE 
133f e1			    POP    HL 
1340 c9			    RET 
1341			 
1341			;; test strmp 
1341			; 
1341			;ld de, .str1 
1341			;ld hl, .str2 
1341			;call strcmp 
1341			;jr z, .z1 
1341			;;this 
1341			;	if DEBUG_FORTH_WORDS 
1341			;		DMARK "NZ1" 
1341			;		CALLMONITOR 
1341			;	endif 
1341			;.z1: 
1341			; 
1341			;	if DEBUG_FORTH_WORDS 
1341			;		DMARK "ZZ1" 
1341			;		CALLMONITOR 
1341			;	endif 
1341			; 
1341			;ld de, .str1 
1341			;ld hl, .str1 
1341			;call strcmp 
1341			;jr z, .z2 
1341			;;this 
1341			;	if DEBUG_FORTH_WORDS 
1341			;		DMARK "NZ2" 
1341			;		CALLMONITOR 
1341			;	endif 
1341			;.z2: 
1341			; 
1341			;	if DEBUG_FORTH_WORDS 
1341			;		DMARK "ZZ2" 
1341			;		CALLMONITOR 
1341			;	endif 
1341			; 
1341			;ld de, .str1 
1341			;ld hl, .str2 
1341			;call strcmp 
1341			;jr c, .c1 
1341			; 
1341			;	if DEBUG_FORTH_WORDS 
1341			;		DMARK "Nc1" 
1341			;		CALLMONITOR 
1341			;	endif 
1341			;.c1: 
1341			;;this 
1341			;	if DEBUG_FORTH_WORDS 
1341			;		DMARK "cc1" 
1341			;		CALLMONITOR 
1341			;	endif 
1341			; 
1341			;ld de, .str1 
1341			;ld hl, .str1 
1341			;call strcmp 
1341			;jr c, .c2 
1341			;;this 
1341			;	if DEBUG_FORTH_WORDS 
1341			;		DMARK "Nc2" 
1341			;		CALLMONITOR 
1341			;	endif 
1341			;.c2: 
1341			; 
1341			;	if DEBUG_FORTH_WORDS 
1341			;		DMARK "cc2" 
1341			;		CALLMONITOR 
1341			;	endif 
1341			;	NEXTW 
1341			;.str1:   db "string1",0 
1341			;.str2:   db "string2",0 
1341			 
1341			; only care about direct match or not 
1341			; hl and de strings 
1341			; zero set if the same 
1341			 
1341			strcmp: 
1341 1a				ld a, (de) 
1342 be				cp (hl) 
1343 28 02			jr z, .ssame 
1345 b7				or a 
1346 c9				ret 
1347			 
1347			.ssame:  
1347			;	cp 0 
1347 b7				or a 
1348 c8				ret z 
1349			 
1349 23				inc hl 
134a 13				inc de 
134b 18 f4			jr strcmp 
134d				 
134d				 
134d			 
134d			;Copyright (c) 2014, Luke Maurits 
134d			;All rights reserved. 
134d			; 
134d			;Redistribution and use in source and binary forms, with or without 
134d			;modification, are permitted provided that the following conditions are met: 
134d			; 
134d			;* Redistributions of source code must retain the above copyright notice, this 
134d			;  list of conditions and the following disclaimer. 
134d			; 
134d			;* Redistributions in binary form must reproduce the above copyright notice, 
134d			;  this list of conditions and the following disclaimer in the documentation 
134d			;  and/or other materials provided with the distribution. 
134d			; 
134d			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
134d			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
134d			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
134d			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
134d			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
134d			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
134d			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
134d			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
134d			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
134d			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
134d			 
134d			; https://github.com/lmaurits/lm512/blob/master/string.z80 
134d			 
134d			StrictStrCmp: 
134d				; Load next chars of each string 
134d 1a				ld a, (de) 
134e 47				ld b, a 
134f 7e				ld a, (hl) 
1350				; Compare 
1350 b8				cp b 
1351				; Return non-zero if chars don't match 
1351 c0				ret nz 
1352				; Check for end of both strings 
1352 fe 00			cp "\0" 
1354				; Return if strings have ended 
1354 c8				ret z 
1355				; Otherwise, advance to next chars 
1355 23				inc hl 
1356 13				inc de 
1357 18 f4			jr StrictStrCmp 
1359			 
1359			;end 
1359			; eof 
1359			 
1359			 
1359			 
1359			 
1359			 
1359			 
# End of file firmware_strings.asm
1359			include "firmware_memory.asm"   ; malloc and free  
1359			 
1359			if DEBUG_FORTH_MALLOC_HIGH 
1359			.mallocsize: db "Wants malloc >256",0 
1359			.mallocasize: db "MALLOC gives >256",0 
1359			.malloczero: db "MALLOC gives zero",0 
1359			 
1359			malloc_guard_zerolen: 
1359				push hl 
1359				push de 
1359				push af 
1359			 
1359				ld de, 0 
1359			        call cmp16 
1359				jr nz, .lowalloz 
1359			 
1359				push hl 
1359				push de 
1359					ld hl, display_fb0 
1359					ld (display_fb_active), hl 
1359				call clear_display 
1359				ld a, 0 
1359				ld de, .malloczero 
1359				call str_at_display 
1359				call update_display 
1359				call delay1s 
1359				call delay1s 
1359				call bp_on 
1359			;	ld a, 0 
1359			;	ld (os_view_disable), a 
1359			 
1359				pop de 
1359				pop hl 
1359			 
1359				 
1359			 
1359				CALLMONITOR 
1359			.lowalloz: 
1359			 
1359			 
1359				pop af 
1359				pop de 
1359				pop hl 
1359			ret 
1359			 
1359			malloc_guard_entry: 
1359				push hl 
1359				push de 
1359				push af 
1359			 
1359			 	or a      ;clear carry flag 
1359				push hl 
1359				ld de, 255 
1359				sbc hl, de 
1359				jr c, .lowalloc 
1359			 
1359				push de 
1359					ld hl, display_fb0 
1359					ld (display_fb_active), hl 
1359				call clear_display 
1359				ld a, 0 
1359				ld de, .mallocsize 
1359				call str_at_display 
1359				call update_display 
1359				call delay1s 
1359				call delay1s 
1359			;	ld a, 0 
1359			;	ld (os_view_disable), a 
1359				call bp_on 
1359			 
1359				pop de 
1359				pop hl 
1359			 
1359				 
1359			 
1359				CALLMONITOR 
1359				jr .lowdone 
1359			.lowalloc: 
1359			 
1359			 
1359				pop hl 
1359			.lowdone:	pop af 
1359				pop de 
1359				pop hl 
1359			ret 
1359			 
1359			malloc_guard_exit: 
1359				push hl 
1359				push de 
1359				push af 
1359			 
1359			 	or a      ;clear carry flag 
1359				push hl 
1359				ld de, 255 
1359				sbc hl, de 
1359				jr c, .lowallocx 
1359			 
1359				push de 
1359					ld hl, display_fb0 
1359					ld (display_fb_active), hl 
1359				call clear_display 
1359				ld a, 0 
1359				ld de, .mallocasize 
1359				call str_at_display 
1359				call update_display 
1359				call delay1s 
1359				call delay1s 
1359			;	ld a, 0 
1359			;	ld (os_view_disable), a 
1359				call bp_on 
1359				pop de 
1359				pop hl 
1359			 
1359				CALLMONITOR 
1359				jr .lowdonex 
1359			.lowallocx: 
1359			 
1359				pop hl 
1359			.lowdonex:	pop af 
1359				pop de 
1359				pop hl 
1359			ret 
1359			endif 
1359			 
1359			if MALLOC_2 
1359			; Z80 Malloc and Free Functions 
1359			 
1359			; Malloc Function: 
1359			; Input: 
1359			;   HL: Size of block to allocate 
1359			; Output: 
1359			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1359			 
1359			malloc: 
1359				 
1359			if DEBUG_FORTH_MALLOC_HIGH 
1359			call malloc_guard_entry 
1359			endif 
1359			 
1359			 
1359			 
1359			 
1359					if DEBUG_FORTH_MALLOC 
1359						DMARK "mal" 
1359						CALLMONITOR 
1359					endif 
1359			    push af            ; Save AF register 
1359			    ld a, l            ; Load low byte of size into A 
1359			    or h               ; Check if size is zero 
1359			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1359			 
1359			    ; Allocate memory 
1359			    ld hl, (heap_start) ; Load start of heap into HL 
1359					if DEBUG_FORTH_MALLOC 
1359						DMARK "ma1" 
1359						CALLMONITOR 
1359					endif 
1359			    call malloc_internal ; Call internal malloc function 
1359			    pop af             ; Restore AF register 
1359			if DEBUG_FORTH_MALLOC_HIGH 
1359			call malloc_guard_exit 
1359			call malloc_guard_zerolen 
1359			endif 
1359			    ret                ; Return 
1359			 
1359			; Free Function: 
1359			; Input: 
1359			;   HL: Pointer to memory block to free 
1359			; Output: 
1359			;   None 
1359			 
1359			free: 
1359			    push af            ; Save AF register 
1359			    ld a, l            ; Load low byte of pointer into A 
1359			    or h               ; Check if pointer is NULL 
1359			    jp z, free_exit    ; If pointer is NULL, exit 
1359			 
1359			    ; Free memory 
1359			    ld hl, (heap_start) ; Load start of heap into HL 
1359			    call free_internal  ; Call internal free function 
1359			    pop af             ; Restore AF register 
1359			    ret                ; Return 
1359			 
1359			; Internal Malloc Function: 
1359			; Input: 
1359			;   HL: Size of block to allocate 
1359			; Output: 
1359			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1359			 
1359			malloc_internal: 
1359			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1359			    add hl, bc         ; Add management overhead to requested size 
1359			    ex de, hl          ; Save total size in DE, and keep it in HL 
1359					if DEBUG_FORTH_MALLOC 
1359						DMARK "ma2" 
1359						CALLMONITOR 
1359					endif 
1359			 
1359			    ; Search for free memory block 
1359			    ld de, (heap_end)  ; Load end of heap into DE 
1359			    ld bc, 0           ; Initialize counter 
1359			 
1359					if DEBUG_FORTH_MALLOC 
1359						DMARK "ma2" 
1359						CALLMONITOR 
1359					endif 
1359			malloc_search_loop: 
1359			    ; Check if current block is free 
1359			    ld a, (hl)         ; Load current block's status (free or used) 
1359			;    cp 0               ; Compare with zero (free) 
1359				or a 
1359			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1359			 
1359			    ; Check if current block is large enough 
1359			    ld a, (hl+1)       ; Load high byte of block size 
1359			    cp l               ; Compare with low byte of requested size 
1359			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1359			 
1359			    ld a, (hl+2)       ; Load low byte of block size 
1359			    cp h               ; Compare with high byte of requested size 
1359			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1359			 
1359			    ; Mark block as used 
1359			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1359			 
1359			    ; Calculate remaining space in block 
1359			    ld bc, 0           ; Clear BC 
1359			    add hl, bc         ; Increment HL to point to start of data block 
1359			    add hl, de         ; HL = HL + DE (total size) 
1359			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1359			    add hl, bc         ; Add management overhead to start of data block 
1359			 
1359			    ; Save pointer to allocated block in HL 
1359			if DEBUG_FORTH_MALLOC_HIGH 
1359						DMARK "ma5" 
1359			call malloc_guard_exit 
1359			call malloc_guard_zerolen 
1359			endif 
1359			    ret 
1359			 
1359			malloc_skip_block_check: 
1359			    ; Move to the next block 
1359			    ld bc, 3           ; Size of management overhead 
1359			    add hl, bc         ; Move to the next block 
1359			    inc de             ; Increment counter 
1359			 
1359			    ; Check if we have reached the end of heap 
1359			    ld a, e            ; Load low byte of heap end address 
1359			    cp (hl)            ; Compare with low byte of current address 
1359			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1359			    ld a, d            ; Load high byte of heap end address 
1359			;    cp 0               ; Check if it's zero (end of memory) 
1359				or a 
1359			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1359			 
1359			    ; If we reached here, allocation failed 
1359			    xor a              ; Set result to NULL 
1359			if DEBUG_FORTH_MALLOC_HIGH 
1359						DMARK "ma6" 
1359			call malloc_guard_exit 
1359			call malloc_guard_zerolen 
1359			endif 
1359			    ret 
1359			malloc_exit: 
1359			if DEBUG_FORTH_MALLOC_HIGH 
1359						DMARK "ma7" 
1359			call malloc_guard_exit 
1359			call malloc_guard_zerolen 
1359			endif 
1359			    ret 
1359			 
1359			; Internal Free Function: 
1359			; Input: 
1359			;   HL: Pointer to memory block to free 
1359			; Output: 
1359			;   None 
1359			 
1359			free_internal: 
1359			    ld de, (heap_start) ; Load start of heap into DE 
1359			    ld bc, 0            ; Initialize counter 
1359			 
1359			free_search_loop: 
1359			    ; Check if current block contains the pointer 
1359			    ld a, l             ; Load low byte of pointer 
1359			    cp (hl+1)           ; Compare with high byte of current block's address 
1359			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1359			    ld a, h             ; Load high byte of pointer 
1359			    cp (hl+2)           ; Compare with low byte of current block's address 
1359			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1359			 
1359			    ; Mark block as free 
1359			    ld (hl), 0          ; Set status byte to indicate free block 
1359			    ret                 ; Return 
1359			 
1359			free_skip_block_check: 
1359			    ; Move to the next block 
1359			    ld bc, 3            ; Size of management overhead 
1359			    add hl, bc          ; Move to the next block 
1359			    inc de              ; Increment counter 
1359			 
1359			    ; Check if we have reached the end of heap 
1359			    ld a, e             ; Load low byte of heap end address 
1359			    cp (hl)             ; Compare with low byte of current address 
1359			    jr nz, free_search_loop  ; If not equal, continue searching 
1359			    ld a, d             ; Load high byte of heap end address 
1359			;    cp 0                ; Check if it's zero (end of memory) 
1359				or a 
1359			    jr nz, free_search_loop  ; If not zero, continue searching 
1359			 
1359			    ; If we reached here, pointer is not found in heap 
1359			    ret 
1359			 
1359			free_exit: 
1359			    ret                 ; Return 
1359			 
1359			; Define heap start and end addresses 
1359			;heap_start:    .dw 0xC000   ; Start of heap 
1359			;heap_end:      .dw 0xE000   ; End of heap 
1359			 
1359			endif 
1359			 
1359			 
1359			if MALLOC_1 
1359			 
1359			 
1359			 
1359			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1359			 
1359			;moved to firmware.asm 
1359			;heap_start        .equ  0x9000      ; Starting address of heap 
1359			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1359			 
1359			;      .org 0 
1359			;      jp    main 
1359			 
1359			 
1359			;      .org  0x100 
1359			;main: 
1359			;      ld    HL, 0x8100 
1359			;      ld    SP, HL 
1359			; 
1359			;      call  heap_init 
1359			; 
1359			;      ; Make some allocations 
1359			;      ld    HL, 12 
1359			;      call  malloc            ; Allocates 0x9004 
1359			; 
1359			;      ld    HL, 12 
1359			;      call  malloc            ; Allocates 0x9014 
1359			; 
1359			;      ld    HL, 12 
1359			;      call  malloc            ; Allocates 0x9024 
1359			; 
1359			;      ; Free some allocations 
1359			;      ld    HL, 0x9014 
1359			;      call  free 
1359			; 
1359			;      ld    HL, 0x9004 
1359			;      call  free 
1359			; 
1359			;      ld    HL, 0x9024 
1359			;      call  free 
1359			; 
1359			; 
1359			;      halt 
1359			 
1359			 
1359			;------------------------------------------------------------------------------ 
1359			;     heap_init                                                               : 
1359			;                                                                             : 
1359			; Description                                                                 : 
1359			;     Initialise the heap and make it ready for malloc and free operations.   : 
1359			;                                                                             : 
1359			;     The heap is maintained as a linked list, starting with an initial       : 
1359			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1359			;     the first free block in the heap. Each block then points to the next    : 
1359			;     free block within the heap, and the free list ends at the first block   : 
1359			;     with a null pointer to the next free block.                             : 
1359			;                                                                             : 
1359			; Parameters                                                                  : 
1359			;     Inputs are compile-time only. Two defines which specify the starting    : 
1359			;     address of the heap and its size are required, along with a memory      : 
1359			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1359			;     principally stores a pointer to the first free block in the heap.       : 
1359			;                                                                             : 
1359			; Returns                                                                     : 
1359			;     Nothing                                                                 : 
1359			;------------------------------------------------------------------------------ 
1359			heap_init: 
1359 e5			      push  HL 
135a			 
135a			      ; Initialise free list struct 
135a 21 0e 80		      ld    HL, heap_start 
135d 22 0a 80		      ld    (free_list), HL 
1360 21 00 00		      ld    HL, 0 
1363 22 0c 80		      ld    (free_list+2), HL 
1366			 
1366			      ; Insert first free block at bottom of heap, consumes entire heap 
1366 21 c6 f0		      ld    HL, heap_start+heap_size-4 
1369 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
136c 21 b8 70		      ld    HL, heap_size-4 
136f 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1372			 
1372			      ; Insert end of free list block at top of heap - two null words will 
1372			      ; terminate the free list 
1372 21 00 00		      ld    HL, 0 
1375 22 c8 f0		      ld    (heap_start+heap_size-2), HL 
1378 22 c6 f0		      ld    (heap_start+heap_size-4), HL 
137b			 
137b e1			      pop   HL 
137c			 
137c c9			      ret 
137d			 
137d			 
137d			;------------------------------------------------------------------------------ 
137d			;     malloc                                                                  : 
137d			;                                                                             : 
137d			; Description                                                                 : 
137d			;     Allocates the wanted space from the heap and returns the address of the : 
137d			;     first useable byte of the allocation.                                   : 
137d			;                                                                             : 
137d			;     Allocations can happen in one of two ways:                              : 
137d			;                                                                             : 
137d			;     1. A free block may be found which is the exact size wanted. In this    : 
137d			;        case the block is removed from the free list and retuedn to the      : 
137d			;        caller.                                                              : 
137d			;     2. A free block may be found which is larger than the size wanted. In   : 
137d			;        this case, the larger block is split into two. The first portion of  : 
137d			;        this block will become the requested space by the malloc call and    : 
137d			;        is returned to the caller. The second portion becomes a new free     : 
137d			;        block, and the free list is adjusted to maintain continuity via this : 
137d			;        newly created block.                                                 : 
137d			;                                                                             : 
137d			;     malloc does not set any initial value in the allocated space, the       : 
137d			;     caller is required to do this as required.                              : 
137d			;                                                                             : 
137d			;     This implementation of malloc uses the stack exclusively, and is        : 
137d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
137d			;     advisable to disable interrupts before calling malloc, and recommended  : 
137d			;     to avoid the use of malloc inside ISRs in general.                      : 
137d			;                                                                             : 
137d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
137d			;                                                                             : 
137d			; Parameters                                                                  : 
137d			;     HL  Number of bytes wanted                                              : 
137d			;                                                                             : 
137d			; Returns                                                                     : 
137d			;     HL  Address of the first useable byte of the allocation                 : 
137d			;                                                                             : 
137d			; Flags                                                                       : 
137d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
137d			;                                                                             : 
137d			; Stack frame                                                                 : 
137d			;       |             |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     BC      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     DE      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     IX      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |  prev_free  |                                                       : 
137d			;   +4  +-------------+                                                       : 
137d			;       |  this_free  |                                                       : 
137d			;   +2  +-------------+                                                       : 
137d			;       |  next_free  |                                                       : 
137d			;   +0  +-------------+                                                       : 
137d			;       |             |                                                       : 
137d			;                                                                             : 
137d			;------------------------------------------------------------------------------ 
137d			 
137d			 
137d			;malloc: 
137d			; 
137d			;	SAVESP ON 1 
137d			; 
137d			;	call malloc_code 
137d			; 
137d			;	CHECKSP ON 1 
137d			;	ret 
137d			 
137d			 
137d			malloc: 
137d c5			      push  BC 
137e d5			      push  DE 
137f dd e5		      push  IX 
1381			if DEBUG_FORTH_MALLOC_HIGH 
1381			call malloc_guard_entry 
1381			endif 
1381			 
1381					if DEBUG_FORTH_MALLOC 
1381						DMARK "mal" 
1381						CALLMONITOR 
1381					endif 
1381 7c			      ld    A, H                    ; Exit if no space requested 
1382 b5			      or    L 
1383 ca 42 14		      jp    Z, malloc_early_exit 
1386			 
1386			;inc hl 
1386			;inc hl 
1386			;inc hl 
1386			; 
1386			;inc hl 
1386			;inc hl 
1386			;inc hl 
1386			;inc hl 
1386			;inc hl 
1386			;inc hl 
1386			;inc hl 
1386			;inc hl 
1386			;inc hl 
1386			 
1386			 
1386			 
1386			 
1386					if DEBUG_FORTH_MALLOC 
1386						DMARK "maA" 
1386						CALLMONITOR 
1386					endif 
1386			      ; Set up stack frame 
1386 eb			      ex    DE, HL 
1387 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
138a 39			      add   HL, SP 
138b f9			      ld    SP, HL 
138c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1390 dd 39		      add   IX, SP 
1392			 
1392			      ; Setup initial state 
1392 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1395 19			      add   HL, DE 
1396			 
1396 44			      ld    B, H                    ; Move want to BC 
1397 4d			      ld    C, L 
1398			 
1398 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
139b dd 75 04		      ld    (IX+4), L 
139e dd 74 05		      ld    (IX+5), H 
13a1			 
13a1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13a2 23			      inc   HL 
13a3 56			      ld    D, (HL) 
13a4 dd 73 02		      ld    (IX+2), E 
13a7 dd 72 03		      ld    (IX+3), D 
13aa eb			      ex    DE, HL                  ; this_free ptr into HL 
13ab			 
13ab					if DEBUG_FORTH_MALLOC 
13ab						DMARK "maB" 
13ab						CALLMONITOR 
13ab					endif 
13ab			      ; Loop through free block list to find some space 
13ab			malloc_find_space: 
13ab 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13ac 23			      inc   HL 
13ad 56			      ld    D, (HL) 
13ae			 
13ae 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13af b3			      or    E 
13b0 ca 3c 14		      jp    Z, malloc_no_space 
13b3			 
13b3 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13b6 dd 72 01		      ld    (IX+1), D 
13b9			 
13b9			      ; Does this block have enough space to make the allocation? 
13b9 23			      inc   HL                      ; Load free block size into DE 
13ba 5e			      ld    E, (HL) 
13bb 23			      inc   HL 
13bc 56			      ld    D, (HL) 
13bd			 
13bd eb			      ex    DE, HL                  ; Check size of block against want 
13be b7			      or    A                       ; Ensure carry flag clear 
13bf ed 42		      sbc   HL, BC 
13c1 e5			      push  HL                      ; Store the result for later (new block size) 
13c2			 
13c2 ca 11 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
13c5 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
13c7			 
13c7			      ; this_free block is not big enough, setup ptrs to test next free block 
13c7 e1			      pop   HL                      ; Discard previous result 
13c8			 
13c8 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
13cb dd 66 03		      ld    H, (IX+3) 
13ce dd 75 04		      ld    (IX+4), L 
13d1 dd 74 05		      ld    (IX+5), H 
13d4			 
13d4 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
13d7 dd 66 01		      ld    H, (IX+1) 
13da dd 75 02		      ld    (IX+2), L 
13dd dd 74 03		      ld    (IX+3), H 
13e0			 
13e0					if DEBUG_FORTH_MALLOC 
13e0						DMARK "MA>" 
13e0						CALLMONITOR 
13e0					endif 
13e0 18 c9		      jr    malloc_find_space 
13e2			 
13e2			      ; split a bigger block into two - requested size and remaining size 
13e2			malloc_alloc_split: 
13e2					if DEBUG_FORTH_MALLOC 
13e2						DMARK "MAs" 
13e2						CALLMONITOR 
13e2					endif 
13e2 eb			      ex    DE, HL                  ; Calculate address of new free block 
13e3 2b			      dec   HL 
13e4 2b			      dec   HL 
13e5 2b			      dec   HL 
13e6 09			      add   HL, BC 
13e7			 
13e7			      ; Create a new block and point it at next_free 
13e7 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
13ea dd 56 01		      ld    D, (IX+1) 
13ed			 
13ed 73			      ld    (HL), E                 ; Store next_free ptr into new block 
13ee 23			      inc   HL 
13ef 72			      ld    (HL), D 
13f0			 
13f0 d1			      pop   DE                      ; Store size of new block into new block 
13f1 23			      inc   HL 
13f2 73			      ld    (HL), E 
13f3 23			      inc   HL 
13f4 72			      ld    (HL), D 
13f5			 
13f5			      ; Update this_free ptr to point to new block 
13f5 2b			      dec   HL 
13f6 2b			      dec   HL 
13f7 2b			      dec   HL 
13f8			 
13f8 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
13fb dd 56 03		      ld    D, (IX+3) 
13fe			 
13fe dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1401 dd 74 03		      ld    (IX+3), H 
1404			 
1404			      ; Modify this_free block to be allocation 
1404 eb			      ex    DE, HL 
1405 af			      xor   A                       ; Null the next block ptr of allocated block 
1406 77			      ld    (HL), A 
1407 23			      inc   HL 
1408 77			      ld    (HL), A 
1409			 
1409 23			      inc   HL                      ; Store want size into allocated block 
140a 71			      ld    (HL), C 
140b 23			      inc   HL 
140c 70			      ld    (HL), B 
140d 23			      inc   HL 
140e e5			      push  HL                      ; Address of allocation to return 
140f			 
140f 18 19		      jr    malloc_update_links 
1411			 
1411			malloc_alloc_fit: 
1411 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1412			 
1412					if DEBUG_FORTH_MALLOC 
1412						DMARK "MAf" 
1412						CALLMONITOR 
1412					endif 
1412			      ; Modify this_free block to be allocation 
1412 eb			      ex    DE, HL 
1413 2b			      dec   HL 
1414 2b			      dec   HL 
1415 2b			      dec   HL 
1416			 
1416 af			      xor   A                       ; Null the next block ptr of allocated block 
1417 77			      ld    (HL), A 
1418 23			      inc   HL 
1419 77			      ld    (HL), A 
141a			 
141a 23			      inc   HL                      ; Store address of allocation to return 
141b 23			      inc   HL 
141c 23			      inc   HL 
141d e5			      push  HL 
141e			 
141e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
141e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1421 dd 66 01		      ld    H, (IX+1) 
1424			 
1424 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1427 dd 74 03		      ld    (IX+3), H 
142a			 
142a			 
142a			malloc_update_links: 
142a			      ; Update prev_free ptr to point to this_free 
142a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
142d dd 66 05		      ld    H, (IX+5) 
1430			 
1430 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1433 dd 56 03		      ld    D, (IX+3) 
1436			 
1436 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1437 23			      inc   HL 
1438 72			      ld    (HL), D 
1439			 
1439					if DEBUG_FORTH_MALLOC 
1439						DMARK "Mul" 
1439						CALLMONITOR 
1439					endif 
1439			      ; Clear the Z flag to indicate successful allocation 
1439 7a			      ld    A, D 
143a b3			      or    E 
143b			 
143b d1			      pop   DE                      ; Address of allocation 
143c					if DEBUG_FORTH_MALLOC 
143c						DMARK "MAu" 
143c						CALLMONITOR 
143c					endif 
143c			 
143c			malloc_no_space: 
143c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
143f 39			      add   HL, SP 
1440 f9			      ld    SP, HL 
1441			 
1441 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1442					if DEBUG_FORTH_MALLOC 
1442						DMARK "MAN" 
1442						CALLMONITOR 
1442					endif 
1442			 
1442			malloc_early_exit: 
1442					if DEBUG_FORTH_MALLOC 
1442						DMARK "MAx" 
1442						CALLMONITOR 
1442					endif 
1442 dd e1		      pop   IX 
1444 d1			      pop   DE 
1445 c1			      pop   BC 
1446			 
1446			if DEBUG_FORTH_MALLOC_HIGH 
1446			call malloc_guard_exit 
1446			call malloc_guard_zerolen 
1446			endif 
1446 c9			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     free                                                                    : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1447			;     returned by malloc, otherwise the behaviour is undefined.               : 
1447			;                                                                             : 
1447			;     Where possible, directly adjacent free blocks will be merged together   : 
1447			;     into larger blocks to help ensure that the heap does not become         : 
1447			;     excessively fragmented.                                                 : 
1447			;                                                                             : 
1447			;     free does not clear or set any other value into the freed space, and    : 
1447			;     therefore its contents may be visible through subsequent malloc's. The  : 
1447			;     caller should clear the freed space as required.                        : 
1447			;                                                                             : 
1447			;     This implementation of free uses the stack exclusively, and is          : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling free, and recommended    : 
1447			;     to avoid the use of free inside ISRs in general.                        : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Pointer to address of first byte of allocation to be freed          : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			free: 
1447 c5			      push  BC 
1448 d5			      push  DE 
1449 dd e5		      push  IX 
144b			 
144b 7c			      ld    A, H                    ; Exit if ptr is null 
144c b5			      or    L 
144d ca 11 15		      jp    Z, free_early_exit 
1450			 
1450			      ; Set up stack frame 
1450 eb			      ex    DE, HL 
1451 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1454 39			      add   HL, SP 
1455 f9			      ld    SP, HL 
1456 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
145a dd 39		      add   IX, SP 
145c			 
145c			      ; The address in HL points to the start of the useable allocated space, 
145c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
145c			      ; address of the block itself. 
145c eb			      ex    DE, HL 
145d 11 fc ff		      ld    DE, -4 
1460 19			      add   HL, DE 
1461			 
1461			      ; An allocated block must have a null next block pointer in it 
1461 7e			      ld    A, (HL) 
1462 23			      inc   HL 
1463 b6			      or    (HL) 
1464 c2 0c 15		      jp    NZ, free_done 
1467			 
1467 2b			      dec   HL 
1468			 
1468 44			      ld    B, H                    ; Copy HL to BC 
1469 4d			      ld    C, L 
146a			 
146a			      ; Loop through the free list to find the first block with an address 
146a			      ; higher than the block being freed 
146a 21 0a 80		      ld    HL, free_list 
146d			 
146d			free_find_higher_block: 
146d 5e			      ld    E, (HL)                 ; Load next ptr from free block 
146e 23			      inc   HL 
146f 56			      ld    D, (HL) 
1470 2b			      dec   HL 
1471			 
1471 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1474 dd 72 01		      ld    (IX+1), D 
1477 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
147a dd 74 03		      ld    (IX+3), H 
147d			 
147d 78			      ld    A, B                    ; Check if DE is greater than BC 
147e ba			      cp    D                       ; Compare MSB first 
147f 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1481 30 04		      jr    NC, free_find_higher_block_skip 
1483 79			      ld    A, C 
1484 bb			      cp    E                       ; Then compare LSB 
1485 38 08		      jr    C, free_found_higher_block 
1487			 
1487			free_find_higher_block_skip: 
1487 7a			      ld    A, D                    ; Reached the end of the free list? 
1488 b3			      or    E 
1489 ca 0c 15		      jp    Z, free_done 
148c			 
148c eb			      ex    DE, HL 
148d			 
148d 18 de		      jr    free_find_higher_block 
148f			 
148f			free_found_higher_block: 
148f			      ; Insert freed block between prev and next free blocks 
148f 71			      ld    (HL), C                 ; Point prev free block to freed block 
1490 23			      inc   HL 
1491 70			      ld    (HL), B 
1492			 
1492 60			      ld    H, B                    ; Point freed block at next free block 
1493 69			      ld    L, C 
1494 73			      ld    (HL), E 
1495 23			      inc   HL 
1496 72			      ld    (HL), D 
1497			 
1497			      ; Check if the freed block is adjacent to the next free block 
1497 23			      inc   HL                      ; Load size of freed block into HL 
1498 5e			      ld    E, (HL) 
1499 23			      inc   HL 
149a 56			      ld    D, (HL) 
149b eb			      ex    DE, HL 
149c			 
149c 09			      add   HL, BC                  ; Add addr of freed block and its size 
149d			 
149d dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14a0 dd 56 01		      ld    D, (IX+1) 
14a3			 
14a3 b7			      or    A                       ; Clear the carry flag 
14a4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14a6 20 22		      jr    NZ, free_check_adjacent_to_prev 
14a8			 
14a8			      ; Freed block is adjacent to next, merge into one bigger block 
14a8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14a9 5e			      ld    E, (HL) 
14aa 23			      inc   HL 
14ab 56			      ld    D, (HL) 
14ac e5			      push  HL                      ; Save ptr to next block for later 
14ad			 
14ad 60			      ld    H, B                    ; Store ptr from next block into freed block 
14ae 69			      ld    L, C 
14af 73			      ld    (HL), E 
14b0 23			      inc   HL 
14b1 72			      ld    (HL), D 
14b2			 
14b2 e1			      pop   HL                      ; Restore ptr to next block 
14b3 23			      inc   HL                      ; Load size of next block into DE 
14b4 5e			      ld    E, (HL) 
14b5 23			      inc   HL 
14b6 56			      ld    D, (HL) 
14b7 d5			      push  DE                      ; Save next block size for later 
14b8			 
14b8 60			      ld    H, B                    ; Load size of freed block into HL 
14b9 69			      ld    L, C 
14ba 23			      inc   HL 
14bb 23			      inc   HL 
14bc 5e			      ld    E, (HL) 
14bd 23			      inc   HL 
14be 56			      ld    D, (HL) 
14bf eb			      ex    DE, HL 
14c0			 
14c0 d1			      pop   DE                      ; Restore size of next block 
14c1 19			      add   HL, DE                  ; Add sizes of both blocks 
14c2 eb			      ex    DE, HL 
14c3			 
14c3 60			      ld    H, B                    ; Store new bigger size into freed block 
14c4 69			      ld    L, C 
14c5 23			      inc   HL 
14c6 23			      inc   HL 
14c7 73			      ld    (HL), E 
14c8 23			      inc   HL 
14c9 72			      ld    (HL), D 
14ca			 
14ca			free_check_adjacent_to_prev: 
14ca			      ; Check if the freed block is adjacent to the prev free block 
14ca dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
14cd dd 66 03		      ld    H, (IX+3) 
14d0			 
14d0 23			      inc   HL                      ; Size of prev free block into DE 
14d1 23			      inc   HL 
14d2 5e			      ld    E, (HL) 
14d3 23			      inc   HL 
14d4 56			      ld    D, (HL) 
14d5 2b			      dec   HL 
14d6 2b			      dec   HL 
14d7 2b			      dec   HL 
14d8			 
14d8 19			      add   HL, DE                  ; Add prev block addr and size 
14d9			 
14d9 b7			      or    A                       ; Clear the carry flag 
14da ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
14dc 20 2e		      jr    NZ, free_done 
14de			 
14de			      ; Freed block is adjacent to prev, merge into one bigger block 
14de 60			      ld    H, B                    ; Load next ptr from freed block into DE 
14df 69			      ld    L, C 
14e0 5e			      ld    E, (HL) 
14e1 23			      inc   HL 
14e2 56			      ld    D, (HL) 
14e3 e5			      push  HL                      ; Save freed block ptr for later 
14e4			 
14e4 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
14e7 dd 66 03		      ld    H, (IX+3) 
14ea 73			      ld    (HL), E 
14eb 23			      inc   HL 
14ec 72			      ld    (HL), D 
14ed			 
14ed e1			      pop   HL                      ; Restore freed block ptr 
14ee 23			      inc   HL                      ; Load size of freed block into DE 
14ef 5e			      ld    E, (HL) 
14f0 23			      inc   HL 
14f1 56			      ld    D, (HL) 
14f2 d5			      push  DE                      ; Save freed block size for later 
14f3			 
14f3 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
14f6 dd 66 03		      ld    H, (IX+3) 
14f9 23			      inc   HL 
14fa 23			      inc   HL 
14fb 5e			      ld    E, (HL) 
14fc 23			      inc   HL 
14fd 56			      ld    D, (HL) 
14fe			 
14fe e1			      pop   HL                      ; Add sizes of both blocks 
14ff 19			      add   HL, DE 
1500 eb			      ex    DE, HL 
1501			 
1501 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1504 dd 66 03		      ld    H, (IX+3) 
1507 23			      inc   HL 
1508 23			      inc   HL 
1509 73			      ld    (HL), E 
150a 23			      inc   HL 
150b 72			      ld    (HL), D 
150c			 
150c			free_done: 
150c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
150f 39			      add   HL, SP 
1510 f9			      ld    SP, HL 
1511			 
1511			free_early_exit: 
1511 dd e1		      pop   IX 
1513 d1			      pop   DE 
1514 c1			      pop   BC 
1515			 
1515 c9			      ret 
1516			 
1516			; moved to firmware.asm 
1516			; 
1516			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1516			;                  .dw   0 
1516			 
1516			 
1516			endif 
1516			 
1516			 
1516			if MALLOC_3 
1516			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1516			;heap_start        .equ  0x9000      ; Starting address of heap 
1516			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1516			; 
1516			 ;     .org 0 
1516			  ;    jp    main 
1516			; 
1516			; 
1516			 ;     .org  0x100 
1516			;main: 
1516			 ;     ld    HL, 0x8100 
1516			  ;    ld    SP, HL 
1516			; 
1516			;      call  heap_init 
1516			 
1516			      ; Make some allocations 
1516			;      ld    HL, 12 
1516			;      call  malloc            ; Allocates 0x9004 
1516			; 
1516			 ;     ld    HL, 12 
1516			;      call  malloc            ; Allocates 0x9014 
1516			 
1516			;      ld    HL, 12 
1516			;      call  malloc            ; Allocates 0x9024 
1516			 
1516			      ; Free some allocations 
1516			;      ld    HL, 0x9014 
1516			;      call  free 
1516			 
1516			;      ld    HL, 0x9004 
1516			;      call  free 
1516			; 
1516			;      ld    HL, 0x9024 
1516			;      call  free 
1516			 
1516			 
1516			 ;     halt 
1516			 
1516			 
1516			;------------------------------------------------------------------------------ 
1516			;     heap_init                                                               : 
1516			;                                                                             : 
1516			; Description                                                                 : 
1516			;     Initialise the heap and make it ready for malloc and free operations.   : 
1516			;                                                                             : 
1516			;     The heap is maintained as a linked list, starting with an initial       : 
1516			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1516			;     the first free block in the heap. Each block then points to the next    : 
1516			;     free block within the heap, and the free list ends at the first block   : 
1516			;     with a null pointer to the next free block.                             : 
1516			;                                                                             : 
1516			; Parameters                                                                  : 
1516			;     Inputs are compile-time only. Two defines which specify the starting    : 
1516			;     address of the heap and its size are required, along with a memory      : 
1516			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1516			;     principally stores a pointer to the first free block in the heap.       : 
1516			;                                                                             : 
1516			; Returns                                                                     : 
1516			;     Nothing                                                                 : 
1516			;------------------------------------------------------------------------------ 
1516			heap_init: 
1516			      push  HL 
1516			 
1516			      ; Initialise free list struct 
1516			      ld    HL, heap_start 
1516			      ld    (free_list), HL 
1516			      ld    HL, 0 
1516			      ld    (free_list+2), HL 
1516			 
1516			      ; Insert first free block at bottom of heap, consumes entire heap 
1516			      ld    HL, heap_start+heap_size-4 
1516			      ld    (heap_start), HL        ; Next block (end of free list) 
1516			      ld    HL, heap_size-4 
1516			      ld    (heap_start+2), HL      ; Block size 
1516			 
1516			      ; Insert end of free list block at top of heap - two null words will 
1516			      ; terminate the free list 
1516			      ld    HL, 0 
1516			      ld    (heap_start+heap_size-2), HL 
1516			      ld    (heap_start+heap_size-4), HL 
1516			 
1516			      pop   HL 
1516			 
1516			      ret 
1516			 
1516			 
1516			;------------------------------------------------------------------------------ 
1516			;     malloc                                                                  : 
1516			;                                                                             : 
1516			; Description                                                                 : 
1516			;     Allocates the wanted space from the heap and returns the address of the : 
1516			;     first useable byte of the allocation.                                   : 
1516			;                                                                             : 
1516			;     Allocations can happen in one of two ways:                              : 
1516			;                                                                             : 
1516			;     1. A free block may be found which is the exact size wanted. In this    : 
1516			;        case the block is removed from the free list and retuedn to the      : 
1516			;        caller.                                                              : 
1516			;     2. A free block may be found which is larger than the size wanted. In   : 
1516			;        this case, the larger block is split into two. The first portion of  : 
1516			;        this block will become the requested space by the malloc call and    : 
1516			;        is returned to the caller. The second portion becomes a new free     : 
1516			;        block, and the free list is adjusted to maintain continuity via this : 
1516			;        newly created block.                                                 : 
1516			;                                                                             : 
1516			;     malloc does not set any initial value in the allocated space, the       : 
1516			;     caller is required to do this as required.                              : 
1516			;                                                                             : 
1516			;     This implementation of malloc uses the stack exclusively, and is        : 
1516			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1516			;     advisable to disable interrupts before calling malloc, and recommended  : 
1516			;     to avoid the use of malloc inside ISRs in general.                      : 
1516			;                                                                             : 
1516			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1516			;                                                                             : 
1516			; Parameters                                                                  : 
1516			;     HL  Number of bytes wanted                                              : 
1516			;                                                                             : 
1516			; Returns                                                                     : 
1516			;     HL  Address of the first useable byte of the allocation                 : 
1516			;                                                                             : 
1516			; Flags                                                                       : 
1516			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1516			;                                                                             : 
1516			; Stack frame                                                                 : 
1516			;       |             |                                                       : 
1516			;       +-------------+                                                       : 
1516			;       |     BC      |                                                       : 
1516			;       +-------------+                                                       : 
1516			;       |     DE      |                                                       : 
1516			;       +-------------+                                                       : 
1516			;       |     IX      |                                                       : 
1516			;       +-------------+                                                       : 
1516			;       |  prev_free  |                                                       : 
1516			;   +4  +-------------+                                                       : 
1516			;       |  this_free  |                                                       : 
1516			;   +2  +-------------+                                                       : 
1516			;       |  next_free  |                                                       : 
1516			;   +0  +-------------+                                                       : 
1516			;       |             |                                                       : 
1516			;                                                                             : 
1516			;------------------------------------------------------------------------------ 
1516			malloc: 
1516			      push  BC 
1516			      push  DE 
1516			      push  IX 
1516			 
1516			      ld    A, H                    ; Exit if no space requested 
1516			      or    L 
1516			      jp    Z, malloc_early_exit 
1516			 
1516			      ; Set up stack frame 
1516			      ex    DE, HL 
1516			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1516			      add   HL, SP 
1516			      ld    SP, HL 
1516			      ld    IX, 0                   ; Use IX as a frame pointer 
1516			      add   IX, SP 
1516			 
1516			      ; Setup initial state 
1516			      ld    HL, 4                   ; want must also include space used by block struct 
1516			      add   HL, DE 
1516			 
1516			      ld    B, H                    ; Move want to BC 
1516			      ld    C, L 
1516			 
1516			      ld    HL, free_list           ; Store prev_free ptr to stack 
1516			      ld    (IX+4), L 
1516			      ld    (IX+5), H 
1516			 
1516			      ld    E, (HL)                 ; Store this_free ptr to stack 
1516			      inc   HL 
1516			      ld    D, (HL) 
1516			      ld    (IX+2), E 
1516			      ld    (IX+3), D 
1516			      ex    DE, HL                  ; this_free ptr into HL 
1516			 
1516			      ; Loop through free block list to find some space 
1516			malloc_find_space: 
1516			      ld    E, (HL)                 ; Load next_free ptr into DE 
1516			      inc   HL 
1516			      ld    D, (HL) 
1516			 
1516			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1516			      or    E 
1516			      jp    Z, malloc_no_space 
1516			 
1516			      ld    (IX+0), E               ; Store next_free ptr to stack 
1516			      ld    (IX+1), D 
1516			 
1516			      ; Does this block have enough space to make the allocation? 
1516			      inc   HL                      ; Load free block size into DE 
1516			      ld    E, (HL) 
1516			      inc   HL 
1516			      ld    D, (HL) 
1516			 
1516			      ex    DE, HL                  ; Check size of block against want 
1516			      or    A                       ; Ensure carry flag clear 
1516			      sbc   HL, BC 
1516			      push  HL                      ; Store the result for later (new block size) 
1516			 
1516			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1516			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1516			 
1516			      ; this_free block is not big enough, setup ptrs to test next free block 
1516			      pop   HL                      ; Discard previous result 
1516			 
1516			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1516			      ld    H, (IX+3) 
1516			      ld    (IX+4), L 
1516			      ld    (IX+5), H 
1516			 
1516			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1516			      ld    H, (IX+1) 
1516			      ld    (IX+2), L 
1516			      ld    (IX+3), H 
1516			 
1516			      jr    malloc_find_space 
1516			 
1516			      ; split a bigger block into two - requested size and remaining size 
1516			malloc_alloc_split: 
1516			      ex    DE, HL                  ; Calculate address of new free block 
1516			      dec   HL 
1516			      dec   HL 
1516			      dec   HL 
1516			      add   HL, BC 
1516			 
1516			      ; Create a new block and point it at next_free 
1516			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1516			      ld    D, (IX+1) 
1516			 
1516			      ld    (HL), E                 ; Store next_free ptr into new block 
1516			      inc   HL 
1516			      ld    (HL), D 
1516			 
1516			      pop   DE                      ; Store size of new block into new block 
1516			      inc   HL 
1516			      ld    (HL), E 
1516			      inc   HL 
1516			      ld    (HL), D 
1516			 
1516			      ; Update this_free ptr to point to new block 
1516			      dec   HL 
1516			      dec   HL 
1516			      dec   HL 
1516			 
1516			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1516			      ld    D, (IX+3) 
1516			 
1516			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1516			      ld    (IX+3), H 
1516			 
1516			      ; Modify this_free block to be allocation 
1516			      ex    DE, HL 
1516			      xor   A                       ; Null the next block ptr of allocated block 
1516			      ld    (HL), A 
1516			      inc   HL 
1516			      ld    (HL), A 
1516			 
1516			      inc   HL                      ; Store want size into allocated block 
1516			      ld    (HL), C 
1516			      inc   HL 
1516			      ld    (HL), B 
1516			      inc   HL 
1516			      push  HL                      ; Address of allocation to return 
1516			 
1516			      jr    malloc_update_links 
1516			 
1516			malloc_alloc_fit: 
1516			      pop   HL                      ; Dont need new block size, want is exact fit 
1516			 
1516			      ; Modify this_free block to be allocation 
1516			      ex    DE, HL 
1516			      dec   HL 
1516			      dec   HL 
1516			      dec   HL 
1516			 
1516			      xor   A                       ; Null the next block ptr of allocated block 
1516			      ld    (HL), A 
1516			      inc   HL 
1516			      ld    (HL), A 
1516			 
1516			      inc   HL                      ; Store address of allocation to return 
1516			      inc   HL 
1516			      inc   HL 
1516			      push  HL 
1516			 
1516			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1516			      ld    L, (IX+0)               ; next_free to HL 
1516			      ld    H, (IX+1) 
1516			 
1516			      ld    (IX+2), L               ; HL to this_free 
1516			      ld    (IX+3), H 
1516			 
1516			 
1516			malloc_update_links: 
1516			      ; Update prev_free ptr to point to this_free 
1516			      ld    L, (IX+4)               ; prev_free ptr to HL 
1516			      ld    H, (IX+5) 
1516			 
1516			      ld    E, (IX+2)               ; this_free ptr to DE 
1516			      ld    D, (IX+3) 
1516			 
1516			      ld    (HL), E                 ; this_free ptr into prev_free 
1516			      inc   HL 
1516			      ld    (HL), D 
1516			 
1516			      ; Clear the Z flag to indicate successful allocation 
1516			      ld    A, D 
1516			      or    E 
1516			 
1516			      pop   DE                      ; Address of allocation 
1516			 
1516			malloc_no_space: 
1516			      ld    HL, 6                   ; Clean up stack frame 
1516			      add   HL, SP 
1516			      ld    SP, HL 
1516			 
1516			      ex    DE, HL                  ; Alloc addr into HL for return 
1516			 
1516			malloc_early_exit: 
1516			      pop   IX 
1516			      pop   DE 
1516			      pop   BC 
1516			 
1516			      ret 
1516			 
1516			 
1516			;------------------------------------------------------------------------------ 
1516			;     free                                                                    : 
1516			;                                                                             : 
1516			; Description                                                                 : 
1516			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1516			;     returned by malloc, otherwise the behaviour is undefined.               : 
1516			;                                                                             : 
1516			;     Where possible, directly adjacent free blocks will be merged together   : 
1516			;     into larger blocks to help ensure that the heap does not become         : 
1516			;     excessively fragmented.                                                 : 
1516			;                                                                             : 
1516			;     free does not clear or set any other value into the freed space, and    : 
1516			;     therefore its contents may be visible through subsequent malloc's. The  : 
1516			;     caller should clear the freed space as required.                        : 
1516			;                                                                             : 
1516			;     This implementation of free uses the stack exclusively, and is          : 
1516			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1516			;     advisable to disable interrupts before calling free, and recommended    : 
1516			;     to avoid the use of free inside ISRs in general.                        : 
1516			;                                                                             : 
1516			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1516			;                                                                             : 
1516			; Parameters                                                                  : 
1516			;     HL  Pointer to address of first byte of allocation to be freed          : 
1516			;                                                                             : 
1516			; Returns                                                                     : 
1516			;     Nothing                                                                 : 
1516			;                                                                             : 
1516			; Stack frame                                                                 : 
1516			;       |             |                                                       : 
1516			;       +-------------+                                                       : 
1516			;       |     BC      |                                                       : 
1516			;       +-------------+                                                       : 
1516			;       |     DE      |                                                       : 
1516			;       +-------------+                                                       : 
1516			;       |     IX      |                                                       : 
1516			;       +-------------+                                                       : 
1516			;       |  prev_free  |                                                       : 
1516			;   +2  +-------------+                                                       : 
1516			;       |  next_free  |                                                       : 
1516			;   +0  +-------------+                                                       : 
1516			;       |             |                                                       : 
1516			;                                                                             : 
1516			;------------------------------------------------------------------------------ 
1516			free: 
1516			      push  BC 
1516			      push  DE 
1516			      push  IX 
1516			 
1516			      ld    A, H                    ; Exit if ptr is null 
1516			      or    L 
1516			      jp    Z, free_early_exit 
1516			 
1516			      ; Set up stack frame 
1516			      ex    DE, HL 
1516			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1516			      add   HL, SP 
1516			      ld    SP, HL 
1516			      ld    IX, 0                   ; Use IX as a frame pointer 
1516			      add   IX, SP 
1516			 
1516			      ; The address in HL points to the start of the useable allocated space, 
1516			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1516			      ; address of the block itself. 
1516			      ex    DE, HL 
1516			      ld    DE, -4 
1516			      add   HL, DE 
1516			 
1516			      ; An allocated block must have a null next block pointer in it 
1516			      ld    A, (HL) 
1516			      inc   HL 
1516			      or    (HL) 
1516			      jp    NZ, free_done 
1516			 
1516			      dec   HL 
1516			 
1516			      ld    B, H                    ; Copy HL to BC 
1516			      ld    C, L 
1516			 
1516			      ; Loop through the free list to find the first block with an address 
1516			      ; higher than the block being freed 
1516			      ld    HL, free_list 
1516			 
1516			free_find_higher_block: 
1516			      ld    E, (HL)                 ; Load next ptr from free block 
1516			      inc   HL 
1516			      ld    D, (HL) 
1516			      dec   HL 
1516			 
1516			      ld    (IX+0), E               ; Save ptr to next free block 
1516			      ld    (IX+1), D 
1516			      ld    (IX+2), L               ; Save ptr to prev free block 
1516			      ld    (IX+3), H 
1516			 
1516			      ld    A, B                    ; Check if DE is greater than BC 
1516			      cp    D                       ; Compare MSB first 
1516			      jr    Z, $+4                  ; MSB the same, compare LSB 
1516			      jr    NC, free_find_higher_block_skip 
1516			      ld    A, C 
1516			      cp    E                       ; Then compare LSB 
1516			      jr    C, free_found_higher_block 
1516			 
1516			free_find_higher_block_skip: 
1516			      ld    A, D                    ; Reached the end of the free list? 
1516			      or    E 
1516			      jp    Z, free_done 
1516			 
1516			      ex    DE, HL 
1516			 
1516			      jr    free_find_higher_block 
1516			 
1516			free_found_higher_block: 
1516			      ; Insert freed block between prev and next free blocks 
1516			      ld    (HL), C                 ; Point prev free block to freed block 
1516			      inc   HL 
1516			      ld    (HL), B 
1516			 
1516			      ld    H, B                    ; Point freed block at next free block 
1516			      ld    L, C 
1516			      ld    (HL), E 
1516			      inc   HL 
1516			      ld    (HL), D 
1516			 
1516			      ; Check if the freed block is adjacent to the next free block 
1516			      inc   HL                      ; Load size of freed block into HL 
1516			      ld    E, (HL) 
1516			      inc   HL 
1516			      ld    D, (HL) 
1516			      ex    DE, HL 
1516			 
1516			      add   HL, BC                  ; Add addr of freed block and its size 
1516			 
1516			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1516			      ld    D, (IX+1) 
1516			 
1516			      or    A                       ; Clear the carry flag 
1516			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1516			      jr    NZ, free_check_adjacent_to_prev 
1516			 
1516			      ; Freed block is adjacent to next, merge into one bigger block 
1516			      ex    DE, HL                  ; Load next ptr from next block into DE 
1516			      ld    E, (HL) 
1516			      inc   HL 
1516			      ld    D, (HL) 
1516			      push  HL                      ; Save ptr to next block for later 
1516			 
1516			      ld    H, B                    ; Store ptr from next block into freed block 
1516			      ld    L, C 
1516			      ld    (HL), E 
1516			      inc   HL 
1516			      ld    (HL), D 
1516			 
1516			      pop   HL                      ; Restore ptr to next block 
1516			      inc   HL                      ; Load size of next block into DE 
1516			      ld    E, (HL) 
1516			      inc   HL 
1516			      ld    D, (HL) 
1516			      push  DE                      ; Save next block size for later 
1516			 
1516			      ld    H, B                    ; Load size of freed block into HL 
1516			      ld    L, C 
1516			      inc   HL 
1516			      inc   HL 
1516			      ld    E, (HL) 
1516			      inc   HL 
1516			      ld    D, (HL) 
1516			      ex    DE, HL 
1516			 
1516			      pop   DE                      ; Restore size of next block 
1516			      add   HL, DE                  ; Add sizes of both blocks 
1516			      ex    DE, HL 
1516			 
1516			      ld    H, B                    ; Store new bigger size into freed block 
1516			      ld    L, C 
1516			      inc   HL 
1516			      inc   HL 
1516			      ld    (HL), E 
1516			      inc   HL 
1516			      ld    (HL), D 
1516			 
1516			free_check_adjacent_to_prev: 
1516			      ; Check if the freed block is adjacent to the prev free block 
1516			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1516			      ld    H, (IX+3) 
1516			 
1516			      inc   HL                      ; Size of prev free block into DE 
1516			      inc   HL 
1516			      ld    E, (HL) 
1516			      inc   HL 
1516			      ld    D, (HL) 
1516			      dec   HL 
1516			      dec   HL 
1516			      dec   HL 
1516			 
1516			      add   HL, DE                  ; Add prev block addr and size 
1516			 
1516			      or    A                       ; Clear the carry flag 
1516			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1516			      jr    NZ, free_done 
1516			 
1516			      ; Freed block is adjacent to prev, merge into one bigger block 
1516			      ld    H, B                    ; Load next ptr from freed block into DE 
1516			      ld    L, C 
1516			      ld    E, (HL) 
1516			      inc   HL 
1516			      ld    D, (HL) 
1516			      push  HL                      ; Save freed block ptr for later 
1516			 
1516			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1516			      ld    H, (IX+3) 
1516			      ld    (HL), E 
1516			      inc   HL 
1516			      ld    (HL), D 
1516			 
1516			      pop   HL                      ; Restore freed block ptr 
1516			      inc   HL                      ; Load size of freed block into DE 
1516			      ld    E, (HL) 
1516			      inc   HL 
1516			      ld    D, (HL) 
1516			      push  DE                      ; Save freed block size for later 
1516			 
1516			      ld    L, (IX+2)               ; Load size of prev block into DE 
1516			      ld    H, (IX+3) 
1516			      inc   HL 
1516			      inc   HL 
1516			      ld    E, (HL) 
1516			      inc   HL 
1516			      ld    D, (HL) 
1516			 
1516			      pop   HL                      ; Add sizes of both blocks 
1516			      add   HL, DE 
1516			      ex    DE, HL 
1516			 
1516			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1516			      ld    H, (IX+3) 
1516			      inc   HL 
1516			      inc   HL 
1516			      ld    (HL), E 
1516			      inc   HL 
1516			      ld    (HL), D 
1516			 
1516			free_done: 
1516			      ld    HL, 4                   ; Clean up stack frame 
1516			      add   HL, SP 
1516			      ld    SP, HL 
1516			 
1516			free_early_exit: 
1516			      pop   IX 
1516			      pop   DE 
1516			      pop   BC 
1516			 
1516			      ret 
1516			 
1516			 
1516			;      .org 0x8000 
1516			; 
1516			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1516			 ;                 .dw   0 
1516			 
1516			endif 
1516			 
1516			 
1516			if MALLOC_4 
1516			 
1516			; My memory allocation code. Very very simple.... 
1516			; allocate space under 250 chars 
1516			 
1516			heap_init: 
1516				; init start of heap as zero 
1516				;  
1516			 
1516				ld hl, heap_start 
1516			;	ld a, 0 
1516				ld (hl), 0      ; empty block 
1516				inc hl 
1516			;	ld a, 0 
1516				ld (hl), 0      ; length of block 
1516				; write end of list 
1516				inc hl 
1516				ld a,(hl) 
1516				inc hl 
1516				ld a,(hl) 
1516				 
1516			 
1516				; init some malloc vars 
1516			 
1516				ld hl, 0 
1516				ld (free_list), hl       ; store last malloc location 
1516			 
1516				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1516			;	ld a, 0 
1516				ld (hl), 0 
1516			 
1516			 
1516				ld hl, heap_start 
1516				;  
1516				  
1516				ret 
1516			 
1516			 
1516			;    free block marker 
1516			;    requested size  
1516			;    pointer to next block 
1516			;    .... 
1516			;    next block marker 
1516			 
1516			 
1516			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1516			; 
1516			 
1516			 
1516			malloc:  
1516				push de 
1516				push bc 
1516				push af 
1516			 
1516				; hl space required 
1516				 
1516				ld c, l    ; hold space   (TODO only a max of 255) 
1516			 
1516			;	inc c     ; TODO BUG need to fix memory leak on push str 
1516			;	inc c 
1516			;	inc c 
1516			;	inc c 
1516			;	inc c 
1516			;	inc c 
1516			;	inc c 
1516			 
1516			 
1516			 
1516				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1516			 
1516				ld a, (free_list+3) 
1516			;	cp 0 
1516				or a 
1516				jr z, .contheap 
1516			 
1516				ld hl, (free_list)     ; get last alloc 
1516					if DEBUG_FORTH_MALLOC_INT 
1516						DMARK "mrs" 
1516						CALLMONITOR 
1516					endif 
1516				jr .startalloc 
1516			 
1516			.contheap: 
1516				ld hl, heap_start 
1516			 
1516			.startalloc: 
1516			 
1516					if DEBUG_FORTH_MALLOC_INT 
1516						DMARK "mym" 
1516						CALLMONITOR 
1516					endif 
1516			.findblock: 
1516					if DEBUG_FORTH_MALLOC_INT 
1516						DMARK "mmf" 
1516						CALLMONITOR 
1516					endif 
1516			 
1516				ld a,(hl)  
1516				; if byte is zero then clear to use 
1516			 
1516			;	cp 0 
1516				or a 
1516				jr z, .foundemptyblock 
1516			 
1516				; if byte is not clear 
1516				;     then byte is offset to next block 
1516			 
1516				inc hl 
1516				ld a, (hl) ; get size 
1516			.nextblock:	inc hl 
1516					ld e, (hl) 
1516					inc hl 
1516					ld d, (hl) 
1516					ex de, hl 
1516			;	inc hl  ; move past the store space 
1516			;	inc hl  ; move past zero index  
1516			 
1516				; TODO detect no more space 
1516			 
1516				push hl 
1516				ld de, heap_end 
1516				call cmp16 
1516				pop hl 
1516				jr nc, .nospace 
1516			 
1516				jr .findblock 
1516			 
1516			.nospace: ld hl, 0 
1516				jp .exit 
1516			 
1516			 
1516			.foundemptyblock:	 
1516					if DEBUG_FORTH_MALLOC_INT 
1516						DMARK "mme" 
1516						CALLMONITOR 
1516					endif 
1516			 
1516			; TODO has block enough space if reusing??? 
1516			 
1516				;  
1516			 
1516			; see if this block has been previously used 
1516				inc hl 
1516				ld a, (hl) 
1516				dec hl 
1516			;	cp 0 
1516				or a 
1516				jr z, .newblock 
1516			 
1516					if DEBUG_FORTH_MALLOC_INT 
1516						DMARK "meR" 
1516						CALLMONITOR 
1516					endif 
1516			 
1516			; no reusing previously allocated block 
1516			 
1516			; is it smaller than previously used? 
1516				 
1516				inc hl    ; move to size 
1516				ld a, c 
1516				sub (hl)        ; we want c < (hl) 
1516				dec hl    ; move back to marker 
1516			        jr z, .findblock 
1516			 
1516				; update with the new size which should be lower 
1516			 
1516			        ;inc  hl   ; negate next move. move back to size  
1516			 
1516			.newblock: 
1516				; need to be at marker here 
1516			 
1516					if DEBUG_FORTH_MALLOC_INT 
1516						DMARK "meN" 
1516						CALLMONITOR 
1516					endif 
1516			 
1516			 
1516				ld a, c 
1516			 
1516				ld (free_list+3), a	 ; flag resume from last malloc  
1516				ld (free_list), hl    ; save out last location 
1516			 
1516			 
1516				;inc a     ; space for length byte 
1516				ld (hl), a     ; save block in use marker 
1516			 
1516				inc hl   ; move to space marker 
1516				ld (hl), a    ; save new space 
1516			 
1516				inc hl   ; move to start of allocated area 
1516				 
1516			;	push hl     ; save where we are - 1  
1516			 
1516			;	inc hl  ; move past zero index  
1516				; skip space to set down new marker 
1516			 
1516				; provide some extra space for now 
1516			 
1516				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1516				inc a 
1516				inc a 
1516			 
1516				push hl   ; save where we are in the node block 
1516			 
1516				call addatohl 
1516			 
1516				; write linked list point 
1516			 
1516				pop de     ; get our node position 
1516				ex de, hl 
1516			 
1516				ld (hl), e 
1516				inc hl 
1516				ld (hl), d 
1516			 
1516				inc hl 
1516			 
1516				; now at start of allocated data so save pointer 
1516			 
1516				push hl 
1516			 
1516				; jump to position of next node and setup empty header in DE 
1516			 
1516				ex de, hl 
1516			 
1516			;	inc hl ; move past end of block 
1516			 
1516			;	ld a, 0 
1516				ld (hl), 0   ; empty marker 
1516				inc hl 
1516				ld (hl), 0   ; size 
1516				inc hl  
1516				ld (hl), 0   ; ptr 
1516				inc hl 
1516				ld (hl), 0   ; ptr 
1516			 
1516			 
1516				pop hl 
1516			 
1516					if DEBUG_FORTH_MALLOC_INT 
1516						DMARK "mmr" 
1516						CALLMONITOR 
1516					endif 
1516			 
1516			.exit: 
1516				pop af 
1516				pop bc 
1516				pop de  
1516				ret 
1516			 
1516			 
1516			 
1516			 
1516			free:  
1516				push hl 
1516				push af 
1516				; get address in hl 
1516			 
1516					if DEBUG_FORTH_MALLOC_INT 
1516						DMARK "fre" 
1516						CALLMONITOR 
1516					endif 
1516				; data is at hl - move to block count 
1516				dec hl 
1516				dec hl    ; get past pointer 
1516				dec hl 
1516			 
1516				ld a, (hl)    ; need this for a validation check 
1516			 
1516				dec hl    ; move to block marker 
1516			 
1516				; now check that the block count and block marker are the same  
1516			        ; this checks that we are on a malloc node and not random memory 
1516			        ; OK a faint chance this could be a problem but rare - famous last words! 
1516			 
1516				ld c, a 
1516				ld a, (hl)    
1516			 
1516				cp c 
1516				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1516			 
1516				; yes good chance we are on a malloc node 
1516			 
1516			;	ld a, 0      
1516				ld (hl), 0   ; mark as free 
1516			 
1516				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1516			 
1516			.freeignore:  
1516			 
1516				pop af 
1516				pop hl 
1516			 
1516				ret 
1516			 
1516			 
1516			 
1516			endif 
1516			 
1516			; eof 
# End of file firmware_memory.asm
1516			  
1516			; device C  
1516			; Now handled by SPI  
1516			;if SOUND_ENABLE  
1516			;	include "firmware_sound.asm"  
1516			;endif  
1516			  
1516			include "firmware_diags.asm"  
1516			; Hardware diags menu 
1516			 
1516			 
1516			config: 
1516			 
1516 3e 00			ld a, 0 
1518 21 3b 15			ld hl, .configmn 
151b cd b1 0d			call menu 
151e			 
151e fe 00			cp 0 
1520 c8				ret z 
1521			 
1521			;	cp 1 
1521			;	call z, .savetostore 
1521			 
1521 3d				dec a 
1522			if STARTUP_V1 
1522				call z, .selautoload 
1522			endif 
1522			 
1522			if STARTUP_V2 
1522 cc 49 15			call z, .enautoload 
1525			endif 
1525				;cp 2 
1525 3d				dec a 
1526 cc 60 15			call z, .disautoload 
1529			if STARTUP_V2 
1529 3d				dec a 
152a cc 77 15			call z, .selbank 
152d			endif 
152d			;	cp 3 
152d			;	call z, .selbank 
152d			;	cp 3 
152d 3d				dec a 
152e cc 25 18			call z, .debug_tog 
1531			;	cp 4 
1531 3d				dec a 
1532 cc f3 18			call z, .bpsgo 
1535			;	cp 5 
1535			;	call z, hardware_diags 
1535			if STARTUP_V2 
1535			;	cp 5 
1535 3d				dec a 
1536 cc d8 15			call z, create_startup 
1539			endif 
1539 18 db			jr config 
153b			 
153b			.configmn: 
153b			;	dw prom_c3 
153b e1 1a			dw prom_c2 
153d f7 1a			dw prom_c2a 
153f			if STARTUP_V2 
153f a6 1b			dw prom_bsel  
1541			endif 
1541			;	dw prom_c2b 
1541			;	dw prom_c4 
1541 6e 1b			dw prom_m4 
1543 89 1b			dw prom_m4b 
1545			;	dw prom_c1 
1545			if STARTUP_V2 
1545 91 1b			dw prom_c9 
1547			endif 
1547 00 00			dw 0 
1549				 
1549			 
1549			if STARTUP_V2 
1549			.enautoload: 
1549				if STORAGE_SE 
1549 3e fe			ld a, $fe      ; bit 0 clear 
154b 32 8e f9			ld (spi_device), a 
154e			 
154e cd 05 05			call storage_get_block_0 
1551			 
1551 3e 01			ld a, 1 
1553 32 c9 f9			ld (store_page+STORE_0_AUTOFILE), a 
1556			 
1556 21 00 00				ld hl, 0 
1559 11 a8 f9				ld de, store_page 
155c cd bc 04			call storage_write_block	 ; save update 
155f				else 
155f			 
155f				ld hl, prom_notav 
155f				ld de, prom_empty 
155f				call info_panel 
155f				endif 
155f			 
155f			 
155f c9				ret 
1560			endif 
1560			 
1560			.disautoload: 
1560				if STORAGE_SE 
1560 3e fe			ld a, $fe      ; bit 0 clear 
1562 32 8e f9			ld (spi_device), a 
1565			 
1565 cd 05 05			call storage_get_block_0 
1568			 
1568 3e 00			ld a, 0 
156a 32 c9 f9			ld (store_page+STORE_0_AUTOFILE), a 
156d			 
156d 21 00 00				ld hl, 0 
1570 11 a8 f9				ld de, store_page 
1573 cd bc 04			call storage_write_block	 ; save update 
1576				else 
1576			 
1576				ld hl, prom_notav 
1576				ld de, prom_empty 
1576				call info_panel 
1576				endif 
1576			 
1576			 
1576 c9				ret 
1577			 
1577			if STARTUP_V1 
1577			 
1577			; Select auto start 
1577			 
1577			.selautoload: 
1577			 
1577				 
1577				if STORAGE_SE 
1577			 
1577					call config_dir 
1577				        ld hl, scratch 
1577					ld a, 0 
1577					call menu 
1577			 
1577					cp 0 
1577					ret z 
1577			 
1577					dec a 
1577			 
1577			 
1577					; locate menu option 
1577			 
1577					ld hl, scratch 
1577					call table_lookup 
1577			 
1577					if DEBUG_FORTH_WORDS 
1577						DMARK "ALl" 
1577						CALLMONITOR 
1577					endif 
1577					; with the pointer to the menu it, the byte following the zero term is the file id 
1577			 
1577					ld a, 0 
1577					ld bc, 50   ; max of bytes to look at 
1577					cpir  
1577			 
1577					if DEBUG_FORTH_WORDS 
1577						DMARK "ALb" 
1577						CALLMONITOR 
1577					endif 
1577					;inc hl 
1577			 
1577					ld a, (hl)   ; file id 
1577					 
1577				        ; save bank and file ids 
1577			 
1577					push af 
1577			 
1577			; TODO need to save to block 0 on bank 1	 
1577			 
1577					call storage_get_block_0 
1577			 
1577					if DEBUG_FORTH_WORDS 
1577						DMARK "AL0" 
1577						CALLMONITOR 
1577					endif 
1577					pop af 
1577			 
1577					ld (store_page+STORE_0_FILERUN),a 
1577					 
1577					; save bank id 
1577			 
1577					ld a,(spi_device) 
1577					ld (store_page+STORE_0_BANKRUN),a 
1577			 
1577					; enable auto run of store file 
1577			 
1577					ld a, 1 
1577					ld (store_page+STORE_0_AUTOFILE),a 
1577			 
1577					; save buffer 
1577			 
1577					ld hl, 0 
1577					ld de, store_page 
1577					if DEBUG_FORTH_WORDS 
1577						DMARK "ALw" 
1577						CALLMONITOR 
1577					endif 
1577				call storage_write_block	 ; save update 
1577			  
1577			 
1577			 
1577			 
1577					ld hl, scratch 
1577					call config_fdir 
1577			 
1577				else 
1577			 
1577				ld hl, prom_notav 
1577				ld de, prom_empty 
1577				call info_panel 
1577			 
1577				endif 
1577				ret 
1577			endif 
1577			 
1577			 
1577			; Select storage bank 
1577			 
1577			.selbank: 
1577			 
1577			if STARTUP_V2 
1577			;	if STORAGE_SE 
1577			;	else 
1577			 
1577 21 dc 1b			ld hl, prom_banks 
157a cd b1 0d			call menu 
157d fe 00			cp 0 
157f c8				ret z 
1580				 
1580				; set the bank number from the result 
1580			 
1580				 
1580 0e ff				ld c, SPI_CE_HIGH 
1582 06 30				ld b, '0'    ; human readable bank number 
1584			 
1584			 
1584					; active low 
1584			 
1584			;		cp 0 
1584 b7					or a 
1585 28 28				jr z, .bset 
1587 fe 01				cp 1 
1589 20 04				jr nz, .b2 
158b cb 81				res 0, c 
158d 06 31				ld b, '1'    ; human readable bank number 
158f fe 02		.b2:		cp 2 
1591 20 04				jr nz, .b3 
1593 cb 89				res 1, c 
1595 06 32				ld b, '2'    ; human readable bank number 
1597 fe 03		.b3:		cp 3 
1599 20 04				jr nz, .b4 
159b cb 91				res 2, c 
159d 06 33				ld b, '3'    ; human readable bank number 
159f fe 04		.b4:		cp 4 
15a1 20 04				jr nz, .b5 
15a3 cb 99				res 3, c 
15a5 06 34				ld b, '4'    ; human readable bank number 
15a7 fe 05		.b5:		cp 5 
15a9 20 04				jr nz, .bset 
15ab cb a1				res 4, c 
15ad 06 35				ld b, '5'    ; human readable bank number 
15af			 
15af			.bset: 
15af			 
15af 79					ld a, c 
15b0			;		ld (spi_device),a 
15b0 78					ld a, b 
15b1			;		ld (spi_device_id),a 
15b1 c5					push bc 
15b2			 
15b2					; select bank 1 and load block 0  
15b2			 
15b2 3e fe			ld a, $fe      ; bit 0 clear 
15b4 32 8e f9			ld (spi_device), a 
15b7			 
15b7 cd 05 05			call storage_get_block_0 
15ba			 
15ba c1				pop bc 
15bb 79				ld a,c 
15bc 32 cb f9			ld (store_page+STORE_0_BANKRUN), a 
15bf 78				ld a,b 
15c0 32 cd f9			ld (store_page+STORE_0_BANKRUNN), a 
15c3 21 00 00				ld hl, 0 
15c6 11 a8 f9				ld de, store_page 
15c9 cd bc 04			call storage_write_block 
15cc			 
15cc			else 
15cc				ld hl, prom_notav 
15cc				ld de, prom_empty 
15cc				call info_panel 
15cc			;	endif 
15cc				 
15cc			endif 
15cc c9				ret 
15cd			 
15cd			if STORAGE_SE 
15cd			 
15cd			.config_ldir:   
15cd				; Load storage bank labels into menu array 
15cd			 
15cd				 
15cd			 
15cd			 
15cd c9				ret 
15ce			 
15ce			 
15ce			endif 
15ce			 
15ce			 
15ce			; Save user words to storage 
15ce			 
15ce			.savetostore: 
15ce			 
15ce			;	if STORAGE_SE 
15ce			; 
15ce			;		call config_dir 
15ce			;	        ld hl, scratch 
15ce			;		ld a, 0 
15ce			;		call menu 
15ce			;		 
15ce			;		ld hl, scratch 
15ce			;		call config_fdir 
15ce			; 
15ce			;	else 
15ce			 
15ce 21 e8 1b			ld hl, prom_notav 
15d1 11 fe 1b			ld de, prom_empty 
15d4 cd 13 0d			call info_panel 
15d7			 
15d7			;	endif 
15d7			 
15d7 c9				ret 
15d8			 
15d8			if STARTUP_V2 
15d8			 
15d8			create_startup: 
15d8			 
15d8 3e 00			ld a, 0 
15da 21 4a 17			ld hl, .crstart 
15dd cd b1 0d			call menu 
15e0			 
15e0 fe 00			cp 0 
15e2 c8				ret z 
15e3			 
15e3 fe 01			cp 1 
15e5 cc 21 16			call z, .genlsword 
15e8 fe 02			cp 2 
15ea cc 2b 16			call z, .genedword 
15ed			 
15ed fe 03			cp 3 
15ef cc 35 16			call z, .gendemword 
15f2			 
15f2 fe 04			cp 4 
15f4 cc 3f 16			call z, .genutlword 
15f7 fe 05			cp 5 
15f9 cc 49 16			call z, .genspiword 
15fc fe 06			cp 6 
15fe cc 53 16			call z, .genkeyword 
1601 fe 07			cp 7 
1603 cc 17 16			call z, .gensoundword 
1606 fe 08			cp 8 
1608 cc 0d 16			call z, .genhwword 
160b 18 cb			jr create_startup 
160d			 
160d			.genhwword: 
160d 21 58 1b			ld hl, crs_hw 
1610 11 a0 16			ld de, .hwworddef 
1613 cd 5d 16			call .genfile 
1616 c9				ret 
1617			.gensoundword: 
1617 21 4c 1b			ld hl, crs_sound 
161a 11 ae 16			ld de, .soundworddef 
161d cd 5d 16			call .genfile 
1620 c9				ret 
1621			.genlsword: 
1621 21 0e 1b			ld hl, crs_s1 
1624 11 d8 16			ld de, .lsworddef 
1627 cd 5d 16			call .genfile 
162a c9				ret 
162b			 
162b			.genedword: 
162b 11 dc 16			ld de, .edworddef 
162e 21 17 1b			ld hl, crs_s2 
1631 cd 5d 16			call .genfile 
1634 c9				ret 
1635			 
1635			.gendemword: 
1635 11 e4 16			ld de, .demoworddef 
1638 21 20 1b			ld hl, crs_s3 
163b cd 5d 16			call .genfile 
163e c9				ret 
163f			 
163f			.genutlword: 
163f 21 2c 1b			ld hl, crs_s4 
1642 11 c2 16			ld de, .utilwordef 
1645 cd 5d 16			call .genfile 
1648 c9				ret 
1649			.genspiword: 
1649 21 33 1b			ld hl, crs_s5 
164c 11 06 17			ld de, .spiworddef 
164f cd 5d 16			call .genfile 
1652 c9				ret 
1653			.genkeyword: 
1653 21 3d 1b			ld hl, crs_s6 
1656 11 1e 17			ld de, .keyworddef 
1659 cd 5d 16			call .genfile 
165c c9				ret 
165d			 
165d			; hl - points to file name 
165d			; de - points to strings to add to file 
165d			 
165d			.genfile: 
165d e5				push hl 
165e d5				push de 
165f			 
165f cd 81 0d			call clear_display 
1662 3e 00			ld a, display_row_1 
1664 11 8f 16			ld de, .genfiletxt 
1667 cd 93 0d			call str_at_display 
166a cd a3 0d			call update_display 
166d			 
166d d1				pop de 
166e e1				pop hl 
166f			 
166f			 
166f d5				push de 
1670 cd 51 08			call storage_create 
1673				; id in hl 
1673 d1				pop de   ; table of strings to add 
1674			 
1674			.genloop: 
1674			 
1674 e5				push hl ; save id for next time around 
1675 d5				push de ; save de for next time around 
1676			 
1676 eb				ex de, hl 
1677 cd 7b 23			call loadwordinhl 
167a eb				ex de, hl 
167b			 
167b				; need hl to be the id 
167b				; need de to be the string ptr 
167b				 
167b cd 3b 0b			call storage_append 
167e			 
167e d1				pop de 
167f e1				pop hl 
1680			 
1680 13				inc de 
1681 13				inc de 
1682			 
1682 1a				ld a,(de) 
1683 fe 00			cp 0 
1685 20 ed			jr nz, .genloop 
1687 13				inc de 
1688 1a				ld a, (de) 
1689 1b				dec de 
168a fe 00			cp 0 
168c 20 e6			jr nz, .genloop	 
168e			 
168e c9				ret 
168f			 
168f .. 00		.genfiletxt:  db "Creating file...",0 
16a0			 
16a0			.hwworddef: 
16a0 2f 6f			dw test5 
16a2 67 6f			dw test6 
16a4 9f 6f			dw test7 
16a6 b3 6f			dw test8 
16a8 df 6f			dw test9 
16aa f5 6f			dw test10 
16ac 00 00			dw 0 
16ae			 
16ae			.soundworddef: 
16ae 1a 70			dw sound1 
16b0 3e 70			dw sound2 
16b2 6e 70			dw sound3 
16b4 93 70			dw sound4 
16b6 a0 70			dw sound5 
16b8 ad 70			dw sound6 
16ba ba 70			dw sound7 
16bc c7 70			dw sound8 
16be df 70			dw sound9 
16c0 00 00			dw 0 
16c2			 
16c2			.utilwordef: 
16c2 43 6d			dw strncpy 
16c4 e7 6c			dw type 
16c6 0c 6d			dw ztype 
16c8 a0 6e			dw tuck 
16ca b3 6e			dw nip 
16cc b3 6c			dw clrstack 
16ce 6c 6c			dw longread 
16d0 a4 6d			dw start1 
16d2 b4 6d			dw start2 
16d4			; duplicated 
16d4			;	dw start3b 
16d4			;	dw start3c 
16d4 c5 6e			dw list 
16d6 00 00			dw 0 
16d8			 
16d8			.lsworddef: 
16d8 c5 6d			dw start3b 
16da 00 00			dw 0 
16dc			 
16dc			.edworddef: 
16dc 7e 67			dw edit1 
16de 9f 67			dw edit2 
16e0 d4 67			dw edit3 
16e2 00 00			dw 0 
16e4			 
16e4			.demoworddef: 
16e4 f6 70			dw game1 
16e6 07 71			dw game1a 
16e8 69 71			dw game1b 
16ea 9e 71			dw game1c 
16ec d4 71			dw game1d 
16ee 05 72			dw game1s 
16f0 19 72			dw game1t 
16f2 2e 72			dw game1f 
16f4 62 72			dw game1z 
16f6 a6 72			dw game1zz 
16f8 0f 73			dw ssv2 
16fa 45 73			dw ssv3 
16fc 61 73			dw ssv4 
16fe 7d 73			dw ssv5 
1700 96 73			dw ssv1 
1702 de 73			dw ssv1cpm	 
1704			;	dw game2b 
1704			;	dw game2bf 
1704			;	dw game2mba 
1704			;	dw game2mbas	 
1704			;	dw game2mbht 
1704			;	dw game2mbms 
1704			;	dw game2mb 
1704			;	dw game3w 
1704			;	dw game3p 
1704			;	dw game3sc 
1704			;	dw game3vsi 
1704			;	dw game3vs 
1704 00 00			dw 0 
1706			 
1706			 
1706			.spiworddef: 
1706			 
1706 0c 68		    dw spi1 
1708 65 68		    dw spi2 
170a 99 68		    dw spi2b 
170c 1d 69		    dw spi3 
170e c7 68		    dw spi4 
1710 f0 68		    dw spi5 
1712 30 6a		    dw spib1 
1714 7d 6a		    dw spib2 
1716 e1 6a		    dw spib3 
1718 1c 6b		    dw spib4 
171a 3f 6b		    dw spib5 
171c			;    dw spi6 
171c			;    dw spi7 
171c			 
171c			;    dw spi8 
171c			;    dw spi9 
171c			;    dw spi10 
171c 00 00		    dw 0 
171e			 
171e			.keyworddef: 
171e			 
171e 35 74			dw keyup 
1720 43 74			dw keydown 
1722 53 74			dw keyleft 
1724 63 74			dw keyright 
1726 74 74			dw 	keyf1 
1728 82 74			dw keyf2 
172a 90 74			dw keyf3 
172c 9e 74			dw keyf4 
172e ac 74			dw keyf5 
1730 ba 74			dw keyf6 
1732 c8 74			dw keyf7 
1734 d6 74			dw keyf8 
1736 e4 74			dw keyf9 
1738 f2 74			dw keyf10 
173a 01 75			dw keyf11 
173c 10 75			dw keyf12 
173e 1f 75			dw keytab 
1740 2e 75			dw keycr 
1742 3c 75			dw keyhome 
1744 4c 75			dw keyend 
1746 5b 75			dw keybs 
1748 00 00			dw 0 
174a			 
174a			.crstart: 
174a 0e 1b			dw crs_s1 
174c 17 1b			dw crs_s2 
174e 20 1b			dw crs_s3 
1750 2c 1b			dw crs_s4 
1752 33 1b			dw crs_s5 
1754 3d 1b			dw crs_s6 
1756 4c 1b			dw crs_sound 
1758 58 1b			dw crs_hw 
175a 00 00			dw 0 
175c			 
175c			endif 
175c			 
175c			 
175c			if STORAGE_SE 
175c			 
175c			config_fdir: 
175c				; using the scratch dir go through and release the memory allocated for each string 
175c				 
175c 21 ef f0			ld hl, scratch 
175f 5e			.cfdir:	ld e,(hl) 
1760 23				inc hl 
1761 56				ld d,(hl) 
1762 23				inc hl 
1763			 
1763 eb				ex de, hl 
1764 cd da 0f			call ishlzero 
1767 c8				ret z     ; return on null pointer 
1768 cd 47 14			call free 
176b eb				ex de, hl 
176c 18 f1			jr .cfdir 
176e			 
176e			 
176e c9				ret 
176f			 
176f			 
176f			config_dir: 
176f			 
176f				; for the config menus that need to build a directory of storage call this routine 
176f				; it will construct a menu in scratch to pass to menu 
176f			 
176f				; open storage device 
176f			 
176f				; execute DIR to build a list of files and their ids into scratch in menu format 
176f				; once the menu has finished then will need to call config_fdir to release the strings 
176f				 
176f				; c = number items 
176f			 
176f				 
176f cd 05 05			call storage_get_block_0 
1772			 
1772 21 a8 f9			ld hl, store_page     ; get current id count 
1775 46				ld b, (hl) 
1776 0e 00			ld c, 0    ; count of files   
1778			 
1778			 
1778 21 ef f0			ld hl, scratch 
177b 22 9f f9			ld (store_tmp2), hl    ; location to poke strings 
177e			 
177e				; check for empty drive 
177e			 
177e 3e 00			ld a, 0 
1780 b8				cp b 
1781 ca 1b 18			jp z, .dirdone 
1784			 
1784				 
1784					if DEBUG_FORTH_WORDS 
1784						DMARK "Cdc" 
1784 f5				push af  
1785 3a 99 17			ld a, (.dmark)  
1788 32 99 fd			ld (debug_mark),a  
178b 3a 9a 17			ld a, (.dmark+1)  
178e 32 9a fd			ld (debug_mark+1),a  
1791 3a 9b 17			ld a, (.dmark+2)  
1794 32 9b fd			ld (debug_mark+2),a  
1797 18 03			jr .pastdmark  
1799 ..			.dmark: db "Cdc"  
179c f1			.pastdmark: pop af  
179d			endm  
# End of macro DMARK
179d						CALLMONITOR 
179d cd a6 fd			call debug_vector  
17a0				endm  
# End of macro CALLMONITOR
17a0					endif 
17a0			 
17a0			 
17a0			.diritem:	 
17a0 c5				push bc 
17a1				; for each of the current ids do a search for them and if found push to stack 
17a1			 
17a1 21 40 00				ld hl, STORE_BLOCK_PHY 
17a4 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
17a6 58					ld e,b 
17a7			 
17a7 cd 83 07				call storage_findnextid 
17aa			 
17aa			 
17aa					; if found hl will be non zero 
17aa			 
17aa cd da 0f				call ishlzero 
17ad 28 69				jr z, .dirnotfound 
17af			 
17af					; increase count 
17af			 
17af c1					pop bc	 
17b0 0c					inc c 
17b1 c5					push bc 
17b2					 
17b2			 
17b2					; get file header and push the file name 
17b2			 
17b2 11 a8 f9				ld de, store_page 
17b5 cd 57 04				call storage_read_block 
17b8			 
17b8					; push file id to stack 
17b8				 
17b8 3a a8 f9				ld a, (store_page) 
17bb 26 00				ld h, 0 
17bd 6f					ld l, a 
17be			 
17be					;call forth_push_numhl 
17be					; TODO store id 
17be			 
17be e5					push hl 
17bf			 
17bf					; push extent count to stack  
17bf				 
17bf 21 ab f9				ld hl, store_page+3 
17c2			 
17c2					; get file name length 
17c2			 
17c2 cd 09 13				call strlenz   
17c5			 
17c5 23					inc hl   ; cover zero term 
17c6 23					inc hl  ; stick the id at the end of the area 
17c7			 
17c7 e5					push hl 
17c8 c1					pop bc    ; move length to bc 
17c9			 
17c9 cd 7d 13				call malloc 
17cc			 
17cc					; TODO save malloc area to scratch 
17cc			 
17cc eb					ex de, hl 
17cd 2a 9f f9				ld hl, (store_tmp2) 
17d0 73					ld (hl), e 
17d1 23					inc hl 
17d2 72					ld (hl), d 
17d3 23					inc hl 
17d4 22 9f f9				ld (store_tmp2), hl 
17d7			 
17d7					 
17d7			 
17d7					;pop hl   ; get source 
17d7			;		ex de, hl    ; swap aronund	 
17d7			 
17d7 21 ab f9				ld hl, store_page+3 
17da					if DEBUG_FORTH_WORDS 
17da						DMARK "CFd" 
17da f5				push af  
17db 3a ef 17			ld a, (.dmark)  
17de 32 99 fd			ld (debug_mark),a  
17e1 3a f0 17			ld a, (.dmark+1)  
17e4 32 9a fd			ld (debug_mark+1),a  
17e7 3a f1 17			ld a, (.dmark+2)  
17ea 32 9b fd			ld (debug_mark+2),a  
17ed 18 03			jr .pastdmark  
17ef ..			.dmark: db "CFd"  
17f2 f1			.pastdmark: pop af  
17f3			endm  
# End of macro DMARK
17f3						CALLMONITOR 
17f3 cd a6 fd			call debug_vector  
17f6				endm  
# End of macro CALLMONITOR
17f6					endif 
17f6 ed b0				ldir 
17f8			 
17f8					; de is past string, move back one and store id 
17f8					 
17f8 1b					dec de 
17f9			 
17f9					; store file id 
17f9			 
17f9 e1					pop hl 
17fa eb					ex de,hl 
17fb 73					ld (hl), e 
17fc			 
17fc					if DEBUG_FORTH_WORDS 
17fc						DMARK "Cdi" 
17fc f5				push af  
17fd 3a 11 18			ld a, (.dmark)  
1800 32 99 fd			ld (debug_mark),a  
1803 3a 12 18			ld a, (.dmark+1)  
1806 32 9a fd			ld (debug_mark+1),a  
1809 3a 13 18			ld a, (.dmark+2)  
180c 32 9b fd			ld (debug_mark+2),a  
180f 18 03			jr .pastdmark  
1811 ..			.dmark: db "Cdi"  
1814 f1			.pastdmark: pop af  
1815			endm  
# End of macro DMARK
1815						CALLMONITOR 
1815 cd a6 fd			call debug_vector  
1818				endm  
# End of macro CALLMONITOR
1818					endif 
1818					 
1818			.dirnotfound: 
1818 c1					pop bc     
1819 10 85				djnz .diritem 
181b				 
181b			.dirdone:	 
181b			 
181b			;		ld a, 0 
181b 2a 9f f9				ld hl, (store_tmp2) 
181e 36 00				ld (hl), 0 
1820 23					inc hl 
1821 36 00				ld (hl), 0 
1823 23					inc hl 
1824					; push a count of the dir items found 
1824			 
1824			;		ld h, 0 
1824			;		ld l, c 
1824			 
1824 c9				ret 
1825			 
1825			endif 
1825			 
1825			 
1825			; Settings 
1825			; Run  
1825			 
1825			 
1825			 
1825			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1825			;;hd_menu2:   db "        2: Editor",0   
1825			;hd_menu2:   db "        2: Editor       6: Menu",0   
1825			;hd_menu3:   db "        3: Storage",0 
1825			;hd_menu4:   db "0=quit  4: Debug",0 
1825			;hd_don:     db "ON",0 
1825			;hd_doff:     db "OFF",0 
1825			; 
1825			; 
1825			; 
1825			;hardware_diags_old:       
1825			; 
1825			;.diagmenu: 
1825			;	call clear_display 
1825			;	ld a, display_row_1 
1825			;	ld de, hd_menu1 
1825			;	call str_at_display 
1825			; 
1825			;	ld a, display_row_2 
1825			;	ld de, hd_menu2 
1825			;	call str_at_display 
1825			; 
1825			;	ld a, display_row_3 
1825			;	ld de, hd_menu3 
1825			;	call str_at_display 
1825			; 
1825			;	ld a,  display_row_4 
1825			;	ld de, hd_menu4 
1825			;	call str_at_display 
1825			; 
1825			;	; display debug state 
1825			; 
1825			;	ld de, hd_don 
1825			;	ld a, (os_view_disable) 
1825			;	cp 0 
1825			;	jr z, .distog 
1825			;	ld de, hd_doff 
1825			;.distog: ld a, display_row_4+17 
1825			;	call str_at_display 
1825			; 
1825			;	call update_display 
1825			; 
1825			;	call cin_wait 
1825			; 
1825			; 
1825			; 
1825			;	cp '4' 
1825			;	jr nz, .diagn1 
1825			; 
1825			;	; debug toggle 
1825			; 
1825			;	ld a, (os_view_disable) 
1825			;	ld b, '*' 
1825			;	cp 0 
1825			;	jr z, .debtog 
1825			;	ld b, 0 
1825			;.debtog:	 
1825			;	ld a,b 
1825			;	ld (os_view_disable),a 
1825			; 
1825			;.diagn1: cp '0' 
1825			;	 ret z 
1825			; 
1825			;;	cp '1' 
1825			;;       jp z, matrix	 
1825			;;   TODO keyboard matrix test 
1825			; 
1825			;	cp '2' 
1825			;	jp z, .diagedit 
1825			; 
1825			;;	cp '6' 
1825			;;	jp z, .menutest 
1825			;;if ENABLE_BASIC 
1825			;;	cp '6' 
1825			;;	jp z, basic 
1825			;;endif 
1825			 ; 
1825			;	jp .diagmenu 
1825			; 
1825			; 
1825			;	ret 
1825			 
1825			 
1825			.debug_tog: 
1825 21 4e 18			ld hl, .menudebug 
1828				 
1828			;	ld a, (os_view_disable) 
1828			;	cp '*' 
1828 3a a6 fd			ld a,(debug_vector) 
182b fe c9			cp $C9   ; RET 
182d 20 04			jr nz,.tdon  
182f 3e 01			ld a, 1 
1831 18 02			jr .tog1 
1833 3e 00		.tdon: ld a, 0 
1835			 
1835			.tog1: 
1835 cd b1 0d			call menu 
1838 fe 00			cp 0 
183a c8				ret z 
183b fe 01			cp 1    ; disable debug 
183d 28 04			jr z, .dtog0 
183f 3e 2a			ld a, '*' 
1841 18 05			jr .dtogset 
1843			.dtog0:  
1843				;ld a, 0 
1843 cd e1 18			call bp_on 
1846 18 dd			jr .debug_tog 
1848			.dtogset:  
1848				; ld (os_view_disable), a 
1848 cd ed 18			call bp_off 
184b c3 25 18			jp .debug_tog 
184e			 
184e			 
184e			.menudebug: 
184e 54 18				dw .m6 
1850 5d 18				dw .m7 
1852 00 00				dw 0 
1854 .. 00		.m6:   db "Debug ON",0 
185d .. 00		.m7:   db "Debug OFF",0 
1867			;hardware_diags:       
1867			 
1867			ENABLE_HDIAGS: equ 0 
1867			 
1867			if ENABLE_HDIAGS 
1867			.diagm: 
1867				ld hl, .menuitems 
1867				ld a, 0 
1867				call menu 
1867			 
1867			         cp 0 
1867				 ret z 
1867			 
1867				cp 2 
1867				jp z, .diagedit 
1867			 
1867			;	cp '6' 
1867			;	jp z, .menutest 
1867			;if ENABLE_BASIC 
1867			;	cp '6' 
1867			;	jp z, basic 
1867			;endif 
1867			  
1867				jp .diagm 
1867			 
1867				 
1867			.menuitems:   	dw .m1 
1867					dw .m2 
1867					dw .m3 
1867					dw .m5 
1867					dw .m5a 
1867					dw .m5b 
1867					dw 0 
1867			 
1867			 
1867			.m1:   db "Key Matrix",0 
1867			.m2:   db "Editor",0 
1867			.m3:   db "Storage",0 
1867			.m5:   db "Sound",0 
1867			.m5a:  db "RAM Test",0 
1867			.m5b:  db "LCD Test",0 
1867			 
1867			 
1867			; debug editor 
1867			 
1867			.diagedit: 
1867			 
1867				ld hl, scratch 
1867			;	ld bc, 250 
1867			;	ldir 
1867				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1867			;	ld a, 0 
1867				ld (hl), 0 
1867				inc hl 
1867				ld (hl), 0 
1867				inc hl 
1867				ld (hl), 0 
1867			 
1867			        call clear_display 
1867				call update_display 
1867				;ld a, 1 
1867				;ld (hardware_diag), a 
1867			.diloop: 
1867				ld a, display_row_1 
1867				ld c, 0 
1867				ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1867				ld e, 40 
1867			 
1867				ld hl, scratch	 
1867				call input_str 
1867			 
1867				ld a, display_row_2 
1867				ld de, scratch 
1867				call str_at_display 
1867				call update_display 
1867			 
1867				jp .diloop 
1867			endif 
1867			 
1867			; pass word in hl 
1867			; a has display location 
1867			display_word_at: 
1867 f5				push af 
1868 e5				push hl 
1869 7c				ld a,h 
186a 21 f4 f3			ld hl, os_word_scratch 
186d cd ad 11			call hexout 
1870 e1				pop hl 
1871 7d				ld a,l 
1872 21 f6 f3			ld hl, os_word_scratch+2 
1875 cd ad 11			call hexout 
1878 21 f8 f3			ld hl, os_word_scratch+4 
187b			;	ld a,0 
187b 36 00			ld (hl),0 
187d 11 f4 f3			ld de,os_word_scratch 
1880 f1				pop af 
1881 cd 93 0d				call str_at_display 
1884 c9				ret 
1885			 
1885			display_ptr_state: 
1885			 
1885				; to restore afterwards 
1885			 
1885 d5				push de 
1886 c5				push bc 
1887 e5				push hl 
1888 f5				push af 
1889			 
1889				; for use in here 
1889			 
1889			;	push bc 
1889			;	push de 
1889			;	push hl 
1889			;	push af 
1889			 
1889 cd 81 0d			call clear_display 
188c			 
188c 11 64 1a			ld de, .ptrstate 
188f 3e 00			ld a, display_row_1 
1891 cd 93 0d			call str_at_display 
1894			 
1894				; display debug step 
1894			 
1894			 
1894 11 99 fd			ld de, debug_mark 
1897 3e 26			ld a, display_row_1+display_cols-2 
1899 cd 93 0d			call str_at_display 
189c			 
189c				; display a 
189c 11 6e 1a			ld de, .ptrcliptr 
189f 3e 28			ld a, display_row_2 
18a1 cd 93 0d			call str_at_display 
18a4			 
18a4 f1				pop af 
18a5 2a 6e f9			ld hl,(cli_ptr) 
18a8 3e 30			ld a, display_row_2+8 
18aa cd 67 18			call display_word_at 
18ad			 
18ad			 
18ad				; display hl 
18ad			 
18ad			 
18ad 11 76 1a			ld de, .ptrclioptr 
18b0 3e 32			ld a, display_row_2+10 
18b2 cd 93 0d			call str_at_display 
18b5			; 
18b5			;	pop hl 
18b5 3e 35			ld a, display_row_2+13 
18b7 2a 6c f9			ld hl,(cli_origptr) 
18ba cd 67 18			call display_word_at 
18bd			; 
18bd			;	 
18bd			;	; display de 
18bd			 
18bd			;	ld de, .regstatede 
18bd			;	ld a, display_row_3 
18bd			;	call str_at_display 
18bd			 
18bd			;	pop de 
18bd			;	ld h,d 
18bd			;	ld l, e 
18bd			;	ld a, display_row_3+3 
18bd			;	call display_word_at 
18bd			 
18bd			 
18bd				; display bc 
18bd			 
18bd			;	ld de, .regstatebc 
18bd			;	ld a, display_row_3+10 
18bd			;	call str_at_display 
18bd			 
18bd			;	pop bc 
18bd			;	ld h,b 
18bd			;	ld l, c 
18bd			;	ld a, display_row_3+13 
18bd			;	call display_word_at 
18bd			 
18bd			 
18bd				; display dsp 
18bd			 
18bd			;	ld de, .regstatedsp 
18bd			;	ld a, display_row_4 
18bd			;	call str_at_display 
18bd			 
18bd				 
18bd			;	ld hl,(cli_data_sp) 
18bd			;	ld a, display_row_4+4 
18bd			;	call display_word_at 
18bd			 
18bd				; display rsp 
18bd			 
18bd 11 a5 1a			ld de, .regstatersp 
18c0 3e 82			ld a, display_row_4+10 
18c2 cd 93 0d			call str_at_display 
18c5			 
18c5				 
18c5 2a 20 f9			ld hl,(cli_ret_sp) 
18c8 3e 86			ld a, display_row_4+14 
18ca cd 67 18			call display_word_at 
18cd			 
18cd cd a3 0d			call update_display 
18d0			 
18d0 cd c0 0c			call delay1s 
18d3 cd c0 0c			call delay1s 
18d6 cd c0 0c			call delay1s 
18d9			 
18d9			 
18d9 cd 8a 1f			call next_page_prompt 
18dc			 
18dc				; restore  
18dc			 
18dc f1				pop af 
18dd e1				pop hl 
18de c1				pop bc 
18df d1				pop de 
18e0 c9				ret 
18e1			 
18e1			; Update the break point vector so that the user can hook a new routine 
18e1			 
18e1			bp_on: 
18e1 3e c3			ld a, $c3    ; JP 
18e3 32 a6 fd			ld (debug_vector), a 
18e6 21 f3 18			ld hl, break_point_state 
18e9 22 a7 fd			ld (debug_vector+1), hl 
18ec c9				ret 
18ed			 
18ed			bp_off: 
18ed 3e c9			ld a, $c9    ; RET 
18ef 32 a6 fd			ld (debug_vector), a 
18f2 c9				ret 
18f3			 
18f3			 
18f3			break_point_state: 
18f3			;	push af 
18f3			; 
18f3			;	; see if disabled 
18f3			; 
18f3			;	ld a, (os_view_disable) 
18f3			;	cp '*' 
18f3			;	jr nz, .bpsgo 
18f3			;	pop af 
18f3			;	ret 
18f3			 
18f3			.bpsgo: 
18f3			;	pop af 
18f3 f5				push af 
18f4 22 d1 f0			ld (os_view_hl), hl 
18f7 ed 53 cf f0		ld (os_view_de), de 
18fb ed 43 cd f0		ld (os_view_bc), bc 
18ff e5				push hl 
1900 6f				ld l, a 
1901 26 00			ld h, 0 
1903 22 d3 f0			ld (os_view_af),hl 
1906			 
1906 21 df fc				ld hl, display_fb0 
1909 22 fa fa				ld (display_fb_active), hl 
190c e1				pop hl	 
190d			 
190d 3e 31			ld a, '1' 
190f fe 2a		.bps1:  cp '*' 
1911 cc ed 18			call z, bp_off 
1914			;	jr nz, .bps1b 
1914			;	ld (os_view_disable),a 
1914 fe 31		.bps1b:  cp '1' 
1916 20 14			jr nz, .bps2 
1918			 
1918				; display reg 
1918			 
1918				 
1918			 
1918 3a d3 f0			ld a, (os_view_af) 
191b 2a d1 f0			ld hl, (os_view_hl) 
191e ed 5b cf f0		ld de, (os_view_de) 
1922 ed 4b cd f0		ld bc, (os_view_bc) 
1926 cd c0 19			call display_reg_state 
1929 c3 ac 19			jp .bpschk 
192c			 
192c fe 32		.bps2:  cp '2' 
192e 20 08			jr nz, .bps3 
1930				 
1930				; display hl 
1930 2a d1 f0			ld hl, (os_view_hl) 
1933 cd aa 1a			call display_dump_at_hl 
1936			 
1936 18 74			jr .bpschk 
1938			 
1938 fe 33		.bps3:  cp '3' 
193a 20 08			jr nz, .bps4 
193c			 
193c			        ; display de 
193c 2a cf f0			ld hl, (os_view_de) 
193f cd aa 1a			call display_dump_at_hl 
1942			 
1942 18 68			jr .bpschk 
1944 fe 34		.bps4:  cp '4' 
1946 20 08			jr nz, .bps5 
1948			 
1948			        ; display bc 
1948 2a cd f0			ld hl, (os_view_bc) 
194b cd aa 1a			call display_dump_at_hl 
194e			 
194e 18 5c			jr .bpschk 
1950 fe 35		.bps5:  cp '5' 
1952 20 08		        jr nz, .bps7 
1954			 
1954				; display cur ptr 
1954 2a 6e f9			ld hl, (cli_ptr) 
1957 cd aa 1a			call display_dump_at_hl 
195a			 
195a 18 50			jr .bpschk 
195c fe 36		.bps7:  cp '6' 
195e 20 08			jr nz, .bps8b 
1960				 
1960				; display cur orig ptr 
1960 2a 6c f9			ld hl, (cli_origptr) 
1963 cd aa 1a			call display_dump_at_hl 
1966 18 44			jr .bpschk 
1968 fe 37		.bps8b:  cp '7' 
196a 20 08			jr nz, .bps9 
196c				 
196c				; display dsp 
196c 2a 1c f9			ld hl, (cli_data_sp) 
196f cd aa 1a			call display_dump_at_hl 
1972			 
1972 18 38			jr .bpschk 
1974 fe 39		.bps9:  cp '9' 
1976 20 05			jr nz, .bps8c 
1978				 
1978				; display SP 
1978			;	ld hl, sp 
1978 cd aa 1a			call display_dump_at_hl 
197b			 
197b 18 2f			jr .bpschk 
197d fe 38		.bps8c:  cp '8' 
197f 20 08			jr nz, .bps8d 
1981				 
1981				; display rsp 
1981 2a 20 f9			ld hl, (cli_ret_sp) 
1984 cd aa 1a			call display_dump_at_hl 
1987			 
1987 18 23			jr .bpschk 
1989 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
198b 20 05			jr nz, .bps8 
198d cd 48 1d			call monitor 
1990			 
1990 18 1a			jr .bpschk 
1992 fe 30		.bps8:  cp '0' 
1994 20 16			jr nz, .bpschk 
1996			 
1996 21 3e fc				ld hl, display_fb1 
1999 22 fa fa				ld (display_fb_active), hl 
199c cd a3 0d				call update_display 
199f			 
199f				;ld a, (os_view_af) 
199f 2a d1 f0			ld hl, (os_view_hl) 
19a2 ed 5b cf f0		ld de, (os_view_de) 
19a6 ed 4b cd f0		ld bc, (os_view_bc) 
19aa f1				pop af 
19ab c9				ret 
19ac			 
19ac			.bpschk:   
19ac cd c0 0c			call delay1s 
19af 3e 9f		ld a,display_row_4 + display_cols - 1 
19b1 11 88 1f		        ld de, endprg 
19b4 cd 93 0d			call str_at_display 
19b7 cd a3 0d			call update_display 
19ba cd ec 7c			call cin_wait 
19bd			 
19bd c3 0f 19			jp .bps1 
19c0			 
19c0			 
19c0			display_reg_state: 
19c0			 
19c0				; to restore afterwards 
19c0			 
19c0 d5				push de 
19c1 c5				push bc 
19c2 e5				push hl 
19c3 f5				push af 
19c4			 
19c4				; for use in here 
19c4			 
19c4 c5				push bc 
19c5 d5				push de 
19c6 e5				push hl 
19c7 f5				push af 
19c8			 
19c8 cd 81 0d			call clear_display 
19cb			 
19cb 11 80 1a			ld de, .regstate 
19ce 3e 00			ld a, display_row_1 
19d0 cd 93 0d			call str_at_display 
19d3			 
19d3				; display debug step 
19d3			 
19d3			 
19d3 11 99 fd			ld de, debug_mark 
19d6 3e 25			ld a, display_row_1+display_cols-3 
19d8 cd 93 0d			call str_at_display 
19db			 
19db				; display a 
19db 11 9c 1a			ld de, .regstatea 
19de 3e 28			ld a, display_row_2 
19e0 cd 93 0d			call str_at_display 
19e3			 
19e3 e1				pop hl 
19e4			;	ld h,0 
19e4			;	ld l, a 
19e4 3e 2b			ld a, display_row_2+3 
19e6 cd 67 18			call display_word_at 
19e9			 
19e9			 
19e9				; display hl 
19e9			 
19e9			 
19e9 11 90 1a			ld de, .regstatehl 
19ec 3e 32			ld a, display_row_2+10 
19ee cd 93 0d			call str_at_display 
19f1			 
19f1 e1				pop hl 
19f2 3e 35			ld a, display_row_2+13 
19f4 cd 67 18			call display_word_at 
19f7			 
19f7				 
19f7				; display de 
19f7			 
19f7 11 94 1a			ld de, .regstatede 
19fa 3e 50			ld a, display_row_3 
19fc cd 93 0d			call str_at_display 
19ff			 
19ff e1				pop hl 
1a00			;	ld h,d 
1a00			;	ld l, e 
1a00 3e 53			ld a, display_row_3+3 
1a02 cd 67 18			call display_word_at 
1a05			 
1a05			 
1a05				; display bc 
1a05			 
1a05 11 98 1a			ld de, .regstatebc 
1a08 3e 5a			ld a, display_row_3+10 
1a0a cd 93 0d			call str_at_display 
1a0d			 
1a0d e1				pop hl 
1a0e			;	ld h,b 
1a0e			;	ld l, c 
1a0e 3e 5d			ld a, display_row_3+13 
1a10 cd 67 18			call display_word_at 
1a13			 
1a13			 
1a13				; display dsp 
1a13			 
1a13 11 a0 1a			ld de, .regstatedsp 
1a16 3e 78			ld a, display_row_4 
1a18 cd 93 0d			call str_at_display 
1a1b			 
1a1b				 
1a1b 2a 1c f9			ld hl,(cli_data_sp) 
1a1e 3e 7c			ld a, display_row_4+4 
1a20 cd 67 18			call display_word_at 
1a23			 
1a23				; display rsp 
1a23			 
1a23 11 a5 1a			ld de, .regstatersp 
1a26 3e 82			ld a, display_row_4+10 
1a28 cd 93 0d			call str_at_display 
1a2b			 
1a2b				 
1a2b 2a 20 f9			ld hl,(cli_ret_sp) 
1a2e 3e 86			ld a, display_row_4+14 
1a30 cd 67 18			call display_word_at 
1a33			 
1a33 cd a3 0d			call update_display 
1a36			 
1a36			;	call delay1s 
1a36			;	call delay1s 
1a36			;	call delay1s 
1a36			 
1a36			 
1a36			;	call next_page_prompt 
1a36			 
1a36				; restore  
1a36			 
1a36 f1				pop af 
1a37 e1				pop hl 
1a38 c1				pop bc 
1a39 d1				pop de 
1a3a c9				ret 
1a3b			 
1a3b .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1a4f .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a64 .. 00		.ptrstate:	db "Ptr State",0 
1a6e .. 00		.ptrcliptr:     db "cli_ptr",0 
1a76 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a80 .. 00		.regstate:	db "Reg State (1/0)",0 
1a90 .. 00		.regstatehl:	db "HL:",0 
1a94 .. 00		.regstatede:	db "DE:",0 
1a98 .. 00		.regstatebc:	db "BC:",0 
1a9c .. 00		.regstatea:	db "A :",0 
1aa0 .. 00		.regstatedsp:	db "DSP:",0 
1aa5 .. 00		.regstatersp:	db "RSP:",0 
1aaa			 
1aaa			display_dump_at_hl: 
1aaa e5				push hl 
1aab d5				push de 
1aac c5				push bc 
1aad f5				push af 
1aae			 
1aae 22 12 f4			ld (os_cur_ptr),hl	 
1ab1 cd 81 0d			call clear_display 
1ab4 cd 96 1e			call dumpcont 
1ab7			;	call delay1s 
1ab7			;	call next_page_prompt 
1ab7			 
1ab7			 
1ab7 f1				pop af 
1ab8 c1				pop bc 
1ab9 d1				pop de 
1aba e1				pop hl 
1abb c9				ret 
1abc			 
1abc			;if ENABLE_BASIC 
1abc			;	include "nascombasic.asm" 
1abc			;	basic: 
1abc			;	include "forth/FORTH.ASM" 
1abc			;endif 
1abc			 
1abc			; eof 
1abc			 
1abc			 
# End of file firmware_diags.asm
1abc			  
1abc			include "firmware_prompts.asm"  
1abc			; Prompts  
1abc			 
1abc			; boot messages 
1abc			 
1abc .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1ad1 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1ae1			 
1ae1			 
1ae1			; config menus 
1ae1			 
1ae1			;prom_c3: db "Add Dictionary To File",0 
1ae1			 
1ae1			if STARTUP_V1 
1ae1			prom_c2: db "Select Autoload File",0 
1ae1			prom_c2a: db "Disable Autoload File", 0 
1ae1			endif 
1ae1			 
1ae1			if STARTUP_V2 
1ae1 .. 00		prom_c2: db "Enable Autoload Files",0 
1af7 .. 00		prom_c2a: db "Disable Autoload Files", 0 
1b0e			 
1b0e .. 00		crs_s1: db "*ls-word", 0 
1b17 .. 00		crs_s2: db "*ed-word", 0 
1b20 .. 00		crs_s3: db "*Demo-Games", 0 
1b2c .. 00		crs_s4: db "*Utils", 0 
1b33 .. 00		crs_s5: db "*SPI-Util", 0 
1b3d .. 00		crs_s6: db "*Key-Constants", 0 
1b4c .. 00		crs_sound: db "*Sound-Util", 0 
1b58 .. 00		crs_hw: db "*Hello-World",0 
1b65			 
1b65			 
1b65			 
1b65			endif 
1b65			;prom_c2b: db "Select Storage Bank",0 
1b65 .. 00		prom_c4: db "Settings",0 
1b6e .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b89 .. 00		prom_m4b:   db "Monitor",0 
1b91			;prom_c1: db "Hardware Diags",0 
1b91			 
1b91			 
1b91			if STARTUP_V2 
1b91 .. 00		prom_c9: db "Create Startup Files",0 
1ba6 .. 00		prom_bsel: db "Start From Bank...",0 
1bb9 .. 00		prom_bsel1: db "Bank 1",0 
1bc0 .. 00		prom_bsel2: db "Bank 2",0 
1bc7 .. 00		prom_bsel3: db "Bank 3",0 
1bce .. 00		prom_bsel4: db "Bank 4",0 
1bd5 .. 00		prom_bsel5: db "Bank 5",0 
1bdc			 
1bdc			prom_banks: 
1bdc b9 1b			dw prom_bsel1 
1bde c0 1b			dw prom_bsel2 
1be0 c7 1b			dw prom_bsel3 
1be2 ce 1b			dw prom_bsel4 
1be4 d5 1b			dw prom_bsel5 
1be6 00 00			dw 0 
1be8			endif 
1be8			 
1be8 .. 00		prom_notav:    db "Feature not available",0 
1bfe .. 00		prom_empty:    db "",0 
1bff			 
1bff			; eof 
1bff			 
# End of file firmware_prompts.asm
1bff			  
1bff			; eof  
1bff			  
# End of file firmware.asm
1bff			 
1bff			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1bff			;if BASE_KEV  
1bff			;baseram: equ 08000h 
1bff			;endif 
1bff			 
1bff			;if BASE_SC114 
1bff			;baseram:     equ    endofcode 
1bff			;endif 
1bff			 
1bff			 
1bff			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1bff			 
1bff			; start system 
1bff			 
1bff			coldstart: 
1bff				; set sp 
1bff				; di/ei 
1bff			 
1bff f3				di 
1c00 31 fd ff			ld sp, tos 
1c03 cd 6a 79			call init_nmi 
1c06			;	ei 
1c06			 
1c06				; init spinner 
1c06 3e 00			ld a,0 
1c08 32 f4 fa			ld (display_active), a 
1c0b			 
1c0b				; disable breakpoint by default 
1c0b			 
1c0b				;ld a,'*' 
1c0b			;	ld a,' ' 
1c0b			;	ld (os_view_disable),a 
1c0b			 
1c0b				; set break point vector as new break point on or off 
1c0b cd ed 18			call bp_off 
1c0e			 
1c0e			 
1c0e				; default the parse vector to just a RET 
1c0e 3e c9			ld a, $c9 
1c10 32 a3 fd			ld (parse_vector), a 
1c13			 
1c13				; init hardware 
1c13			 
1c13				; init keyboard and screen hardware 
1c13			 
1c13 cd 6c 00			call hardware_init 
1c16			 
1c16			 
1c16 cd c0 0c			call delay1s 
1c19 3e 58			ld a, display_row_3+8 
1c1b 11 03 00			ld de, buildtime 
1c1e cd 93 0d			call str_at_display 
1c21 cd a3 0d			call update_display 
1c24			 
1c24 cd c0 0c			call delay1s 
1c27 cd c0 0c			call delay1s 
1c2a cd c0 0c			call delay1s 
1c2d			 
1c2d				; detect if any keys are held down to enable breakpoints at start up 
1c2d			 
1c2d cd fb 7c			call cin  
1c30 fe 00			cp 0 
1c32 28 03			jr z, .nokeys 
1c34			 
1c34				;call hardware_diags 
1c34 cd 16 15			call config 
1c37			 
1c37			;	ld de, .bpen 
1c37			;	ld a, display_row_4 
1c37			;	call str_at_display 
1c37			;	call update_display 
1c37			; 
1c37			;	ld a,0 
1c37			;	ld (os_view_disable),a 
1c37			; 
1c37			;.bpwait: 
1c37			;	call cin 
1c37			;	cp 0 
1c37			;	jr z, .bpwait 
1c37			;	jr .nokeys 
1c37			; 
1c37			; 
1c37			;.bpen:  db "Break points enabled!",0 
1c37			 
1c37			 
1c37			 
1c37			 
1c37			 
1c37			 
1c37			.nokeys: 
1c37			 
1c37			 
1c37				 
1c37			 
1c37			;jp  testkey 
1c37			 
1c37			;call storage_get_block_0 
1c37			; 
1c37			;ld hl, 0 
1c37			;ld de, store_page 
1c37			;call storage_read_block 
1c37			 
1c37				 
1c37			;ld hl, 10 
1c37			;ld de, store_page 
1c37			;call storage_read_block 
1c37			 
1c37			 
1c37			 
1c37			 
1c37			 
1c37			;stop:	nop 
1c37			;	jp stop 
1c37			 
1c37			 
1c37			 
1c37			main: 
1c37 cd 81 0d			call clear_display 
1c3a cd a3 0d			call update_display 
1c3d			 
1c3d			 
1c3d			 
1c3d			;	call testlcd 
1c3d			 
1c3d			 
1c3d			 
1c3d cd c5 23			call forth_init 
1c40			 
1c40			 
1c40			warmstart: 
1c40 cd 9b 23			call forth_warmstart 
1c43			 
1c43				; run startup word load 
1c43			        ; TODO prevent this running at warmstart after crash  
1c43			 
1c43				if STARTUP_ENABLE 
1c43			 
1c43					if STARTUP_V1 
1c43			 
1c43						if STORAGE_SE 
1c43							call forth_autoload 
1c43						endif 
1c43						call forth_startup 
1c43					endif 
1c43			 
1c43					if STARTUP_V2 
1c43			 
1c43						if STORAGE_SE 
1c43 cd 94 77						call forth_autoload 
1c46						else 
1c46							call forth_startup 
1c46						endif 
1c46			 
1c46			 
1c46					endif 
1c46			 
1c46				endif 
1c46			 
1c46			warmstart_afterauto: 
1c46			 
1c46				; show free memory after boot 
1c46 11 e3 1c			ld de, freeram 
1c49 3e 00			ld a, display_row_1 
1c4b cd 93 0d			call str_at_display 
1c4e			 
1c4e				; get current heap start after loading any uwords 
1c4e			 
1c4e				;ld de, (os_last_new_uword) 
1c4e				;ex de, hl 
1c4e			 
1c4e			; Or use heap_size word???? 
1c4e				;ld hl, heap_end 
1c4e				;ld hl, heap_size 
1c4e				;ld de, topusermem 
1c4e				;ld de, heap_start 
1c4e ed 5b 0a 80			ld de, (free_list )      
1c52 21 ca f0				ld hl, heap_end 
1c55 ed 52			sbc hl, de 
1c57				;push hl 
1c57				;ld a,h	         	 
1c57				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c57				;call hexout 
1c57			   	;pop hl 
1c57			; 
1c57			;	ld a,l 
1c57			;	ld hl, os_word_scratch+2 
1c57			;	call hexout 
1c57			;	ld hl, os_word_scratch+4 
1c57			;	ld a, 0 
1c57			;	ld (hl),a 
1c57 eb				ex de, hl 
1c58 21 f4 f3			ld hl, os_word_scratch 
1c5b cd b8 12			call uitoa_16 
1c5e			 
1c5e			 
1c5e 11 f4 f3			ld de, os_word_scratch 
1c61 3e 0d			ld a, display_row_1 + 13 
1c63 cd 93 0d			call str_at_display 
1c66 cd a3 0d			call update_display 
1c69			 
1c69			 
1c69				;call demo 
1c69			 
1c69			 
1c69				; init scratch input area for cli commands 
1c69			 
1c69 21 16 f4			ld hl, os_cli_cmd 
1c6c			;	ld a,0 
1c6c 36 00			ld (hl),0 
1c6e 23				inc hl 
1c6f 36 00			ld (hl),0 
1c71			 
1c71 3e 00			ld a,0 
1c73 32 15 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1c76			 
1c76 32 12 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1c79 32 13 f4			ld (os_cur_ptr+1),a	 
1c7c			 
1c7c 32 f4 f3			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1c7f 32 f5 f3			ld (os_word_scratch+1),a	 
1c82				 
1c82			 
1c82				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c82 21 16 f4			ld hl, os_cli_cmd 
1c85			 
1c85			;	ld a, 0		 ; init cli input 
1c85 36 00			ld (hl), 0 
1c87 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c89			cli: 
1c89				; show cli prompt 
1c89				;push af 
1c89				;ld a, 0 
1c89				;ld de, prompt 
1c89				;call str_at_display 
1c89			 
1c89				;call update_display 
1c89				;pop af 
1c89				;inc a 
1c89				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c89			 
1c89			.lastrecall: 
1c89			 
1c89 0e 00			ld c, 0 
1c8b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1c8d 1e 28			ld e, 40 
1c8f			 
1c8f 21 16 f4			ld hl, os_cli_cmd 
1c92			 
1c92				STACKFRAME OFF $fefe $9f9f 
1c92				if DEBUG_STACK_IMB 
1c92					if OFF 
1c92						exx 
1c92						ld de, $fefe 
1c92						ld a, d 
1c92						ld hl, curframe 
1c92						call hexout 
1c92						ld a, e 
1c92						ld hl, curframe+2 
1c92						call hexout 
1c92						ld hl, $fefe 
1c92						push hl 
1c92						ld hl, $9f9f 
1c92						push hl 
1c92						exx 
1c92					endif 
1c92				endif 
1c92			endm 
# End of macro STACKFRAME
1c92			 
1c92 cd de 0f			call input_str 
1c95			 
1c95				STACKFRAMECHK OFF $fefe $9f9f 
1c95				if DEBUG_STACK_IMB 
1c95					if OFF 
1c95						exx 
1c95						ld hl, $9f9f 
1c95						pop de   ; $9f9f 
1c95						call cmp16 
1c95						jr nz, .spnosame 
1c95						ld hl, $fefe 
1c95						pop de   ; $fefe 
1c95						call cmp16 
1c95						jr z, .spfrsame 
1c95						.spnosame: call showsperror 
1c95						.spfrsame: nop 
1c95						exx 
1c95					endif 
1c95				endif 
1c95			endm 
# End of macro STACKFRAMECHK
1c95			 
1c95			 
1c95				; check to see if last line recall has been requested 
1c95			 
1c95			if EDIT_V2 
1c95 fe 05			cp KEY_UP 
1c97 20 0f			jr nz, .noexecline 
1c99			 
1c99 11 16 f4			ld de, os_cli_cmd 
1c9c 21 15 f5			ld hl, os_last_cmd 
1c9f 01 ff 00			ld bc, 255 
1ca2 ed b0			ldir 
1ca4 3e 00			ld a, 0 
1ca6 18 e1			jr .lastrecall 
1ca8			endif 
1ca8			 
1ca8			.noexecline: 
1ca8				; no so exec the line		 
1ca8			 
1ca8				; copy input to last command 
1ca8			 
1ca8 21 16 f4			ld hl, os_cli_cmd 
1cab 11 15 f5			ld de, os_last_cmd 
1cae 01 ff 00			ld bc, 255 
1cb1 ed b0			ldir 
1cb3			 
1cb3				; wipe current buffer 
1cb3			 
1cb3			;	ld a, 0 
1cb3			;	ld hl, os_cli_cmd 
1cb3			;	ld de, os_cli_cmd+1 
1cb3			;	ld bc, 254 
1cb3			;	ldir 
1cb3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1cb3			;	call strcpy 
1cb3			;	ld a, 0 
1cb3			;	ld (hl), a 
1cb3			;	inc hl 
1cb3			;	ld (hl), a 
1cb3			;	inc hl 
1cb3			;	ld (hl), a 
1cb3			 
1cb3				; switch frame buffer to program  
1cb3			 
1cb3 21 3e fc				ld hl, display_fb1 
1cb6 22 fa fa				ld (display_fb_active), hl 
1cb9			 
1cb9			;	nop 
1cb9				STACKFRAME ON $fbfe $8f9f 
1cb9				if DEBUG_STACK_IMB 
1cb9					if ON 
1cb9						exx 
1cb9						ld de, $fbfe 
1cb9						ld a, d 
1cb9						ld hl, curframe 
1cb9						call hexout 
1cb9						ld a, e 
1cb9						ld hl, curframe+2 
1cb9						call hexout 
1cb9						ld hl, $fbfe 
1cb9						push hl 
1cb9						ld hl, $8f9f 
1cb9						push hl 
1cb9						exx 
1cb9					endif 
1cb9				endif 
1cb9			endm 
# End of macro STACKFRAME
1cb9				; first time into the parser so pass over the current scratch pad 
1cb9 21 16 f4			ld hl,os_cli_cmd 
1cbc				; tokenise the entered statement(s) in HL 
1cbc cd 3b 24			call forthparse 
1cbf			        ; exec forth statements in top of return stack 
1cbf cd 73 24			call forthexec 
1cc2				;call forthexec_cleanup 
1cc2			;	call parsenext 
1cc2			 
1cc2				STACKFRAMECHK ON $fbfe $8f9f 
1cc2				if DEBUG_STACK_IMB 
1cc2					if ON 
1cc2						exx 
1cc2						ld hl, $8f9f 
1cc2						pop de   ; $8f9f 
1cc2						call cmp16 
1cc2						jr nz, .spnosame 
1cc2						ld hl, $fbfe 
1cc2						pop de   ; $fbfe 
1cc2						call cmp16 
1cc2						jr z, .spfrsame 
1cc2						.spnosame: call showsperror 
1cc2						.spfrsame: nop 
1cc2						exx 
1cc2					endif 
1cc2				endif 
1cc2			endm 
# End of macro STACKFRAMECHK
1cc2				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1cc2			 
1cc2 3e 78			ld a, display_row_4 
1cc4 11 f4 1c			ld de, endprog 
1cc7			 
1cc7 cd a3 0d			call update_display		 
1cca			 
1cca cd 8a 1f			call next_page_prompt 
1ccd			 
1ccd				; switch frame buffer to cli 
1ccd			 
1ccd 21 df fc				ld hl, display_fb0 
1cd0 22 fa fa				ld (display_fb_active), hl 
1cd3			 
1cd3			 
1cd3 cd 81 0d		        call clear_display 
1cd6 cd a3 0d			call update_display		 
1cd9			 
1cd9 21 16 f4			ld hl, os_cli_cmd 
1cdc			 
1cdc			;	ld a, 0		 ; init cli input 
1cdc 36 00			ld (hl), 0 
1cde			 
1cde				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1cde			 
1cde				; now on last line 
1cde			 
1cde				; TODO scroll screen up 
1cde			 
1cde				; TODO instead just clear screen and place at top of screen 
1cde			 
1cde			;	ld a, 0 
1cde			;	ld (f_cursor_ptr),a 
1cde			 
1cde				;call clear_display 
1cde				;call update_display 
1cde			 
1cde				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cde 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ce0 c3 89 1c			jp cli 
1ce3			 
1ce3 .. 00		freeram: db "Free bytes: ",0 
1cf0 ..			asc: db "1A2F" 
1cf4 .. 00		endprog: db "End prog...",0 
1d00			 
1d00			testenter2:   
1d00 21 21 f1			ld hl,scratch+50 
1d03 22 12 f4			ld (os_cur_ptr),hl 
1d06 c3 89 1c			jp cli 
1d09			 
1d09			testenter:  
1d09			 
1d09 21 f0 1c			ld hl,asc 
1d0c			;	ld a,(hl) 
1d0c			;	call nibble2val 
1d0c cd 03 12			call get_byte 
1d0f			 
1d0f			 
1d0f			;	ld a,(hl) 
1d0f			;	call atohex 
1d0f			 
1d0f			;	call fourehexhl 
1d0f 32 21 f1			ld (scratch+50),a 
1d12			 
1d12			 
1d12			 
1d12 21 f2 1c			ld hl,asc+2 
1d15			;	ld a, (hl) 
1d15			;	call nibble2val 
1d15 cd 03 12			call get_byte 
1d18			 
1d18			;	call fourehexhl 
1d18 32 23 f1			ld (scratch+52),a 
1d1b				 
1d1b 21 21 f1			ld hl,scratch+50 
1d1e 22 12 f4			ld (os_cur_ptr),hl 
1d21 c3 89 1c			jp cli 
1d24			 
1d24			enter:	 
1d24 3a f3 f0			ld a,(scratch+4) 
1d27 fe 00			cp 0 
1d29 28 0c			jr z, .entercont 
1d2b				; no, not a null term line so has an address to work out.... 
1d2b			 
1d2b 21 f1 f0			ld hl,scratch+2 
1d2e cd 63 12			call get_word_hl 
1d31			 
1d31 22 12 f4			ld (os_cur_ptr),hl	 
1d34 c3 89 1c			jp cli 
1d37			 
1d37			 
1d37			.entercont:  
1d37			 
1d37 21 f1 f0			ld hl, scratch+2 
1d3a cd 03 12			call get_byte 
1d3d			 
1d3d 2a 12 f4		   	ld hl,(os_cur_ptr) 
1d40 77					ld (hl),a 
1d41 23					inc hl 
1d42 22 12 f4				ld (os_cur_ptr),hl 
1d45				 
1d45			; get byte  
1d45			 
1d45			 
1d45 c3 89 1c			jp cli 
1d48			 
1d48			 
1d48			; basic monitor support 
1d48			 
1d48			monitor: 
1d48				;  
1d48 cd 81 0d			call clear_display 
1d4b 3e 00			ld a, 0 
1d4d 11 a1 1d			ld de, .monprompt 
1d50 cd 93 0d			call str_at_display 
1d53 cd a3 0d			call update_display 
1d56			 
1d56				; get a monitor command 
1d56			 
1d56 0e 00			ld c, 0     ; entry at top left 
1d58 16 64			ld d, 100   ; max buffer size 
1d5a 1e 0f			ld e, 15    ; input scroll area 
1d5c			;	ld a, 0     ; init string 
1d5c 21 ed f2			ld hl, os_input 
1d5f 36 00			ld (hl), 0 
1d61 23				inc hl 
1d62 36 00			ld (hl), 0 
1d64 21 ed f2			ld hl, os_input 
1d67 3e 01			ld a, 1     ; init string 
1d69 cd de 0f			call input_str 
1d6c			 
1d6c cd 81 0d		        call clear_display 
1d6f cd a3 0d			call update_display		 
1d72			 
1d72 3a ed f2			ld a, (os_input) 
1d75 cd 00 13			call toUpper 
1d78 fe 48		        cp 'H' 
1d7a ca 15 1e		        jp z, .monhelp 
1d7d fe 44			cp 'D'		; dump 
1d7f ca 48 1e			jp z, .mondump	 
1d82 fe 43			cp 'C'		; dump 
1d84 ca 62 1e			jp z, .moncdump	 
1d87 fe 4d			cp 'M'		; dump 
1d89 ca a3 1d			jp z, .moneditstart 
1d8c fe 55			cp 'U'		; dump 
1d8e ca af 1d			jp z, .monedit	 
1d91 fe 47			cp 'G'		; dump 
1d93 ca 3e 1e			jp z, .monjump 
1d96 fe 42			cp 'B'		; forth breakpoint 
1d98 cc f3 18			call z, break_point_state 
1d9b fe 51			cp 'Q'		; dump 
1d9d c8				ret z	 
1d9e			 
1d9e			 
1d9e				; TODO "S" to access symbol by name and not need the address 
1d9e				; TODO "F" to find a string in memory 
1d9e			 
1d9e c3 48 1d			jp monitor 
1da1			 
1da1 .. 00		.monprompt: db ">", 0 
1da3			 
1da3			.moneditstart: 
1da3				; get starting address 
1da3			 
1da3 21 ef f2			ld hl,os_input+2 
1da6 cd 63 12			call get_word_hl 
1da9			 
1da9 22 12 f4			ld (os_cur_ptr),hl	 
1dac			 
1dac c3 48 1d			jp monitor 
1daf			 
1daf			.monedit: 
1daf				; get byte to load 
1daf			 
1daf 21 ef f2			ld hl,os_input+2 
1db2 cd 03 12			call get_byte 
1db5			 
1db5				; get address to update 
1db5 2a 12 f4			ld hl, (os_cur_ptr) 
1db8			 
1db8				; update byte 
1db8			 
1db8 77				ld (hl), a 
1db9			 
1db9				; move to next address and save it 
1db9			 
1db9 23				inc hl 
1dba 22 12 f4			ld (os_cur_ptr),hl	 
1dbd			 
1dbd c3 48 1d			jp monitor 
1dc0			 
1dc0			 
1dc0 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1dd4 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1df0 .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
1e0e .. 00		.monhelptext4:  db "Q-Quit",0 
1e15			        
1e15			.monhelp: 
1e15 3e 00			ld a, display_row_1 
1e17 11 c0 1d		        ld de, .monhelptext1 
1e1a			 
1e1a cd 93 0d			call str_at_display 
1e1d 3e 28			ld a, display_row_2 
1e1f 11 d4 1d		        ld de, .monhelptext2 
1e22					 
1e22 cd 93 0d			call str_at_display 
1e25 3e 50			ld a, display_row_3 
1e27 11 f0 1d		        ld de, .monhelptext3 
1e2a					 
1e2a cd 93 0d			call str_at_display 
1e2d 3e 78			ld a, display_row_4 
1e2f 11 0e 1e		        ld de, .monhelptext4 
1e32 cd 93 0d			call str_at_display 
1e35			 
1e35 cd a3 0d			call update_display		 
1e38			 
1e38 cd 8a 1f			call next_page_prompt 
1e3b c3 48 1d			jp monitor 
1e3e			 
1e3e			.monjump:    
1e3e 21 ef f2			ld hl,os_input+2 
1e41 cd 63 12			call get_word_hl 
1e44			 
1e44 e9				jp (hl) 
1e45 c3 48 1d			jp monitor 
1e48			 
1e48			.mondump:    
1e48 21 ef f2			ld hl,os_input+2 
1e4b cd 63 12			call get_word_hl 
1e4e			 
1e4e 22 12 f4			ld (os_cur_ptr),hl	 
1e51 cd 96 1e			call dumpcont 
1e54 3e 78			ld a, display_row_4 
1e56 11 f4 1c			ld de, endprog 
1e59			 
1e59 cd a3 0d			call update_display		 
1e5c			 
1e5c cd 8a 1f			call next_page_prompt 
1e5f c3 48 1d			jp monitor 
1e62			.moncdump: 
1e62 cd 96 1e			call dumpcont 
1e65 3e 78			ld a, display_row_4 
1e67 11 f4 1c			ld de, endprog 
1e6a			 
1e6a cd a3 0d			call update_display		 
1e6d			 
1e6d cd 8a 1f			call next_page_prompt 
1e70 c3 48 1d			jp monitor 
1e73			 
1e73			 
1e73			; TODO symbol access  
1e73			 
1e73			.symbols:     ;; A list of symbols that can be called up  
1e73 df fc			dw display_fb0 
1e75 .. 00			db "fb0",0  
1e79 a8 f9		     	dw store_page 
1e7b .. 00			db "store_page",0 
1e86			 
1e86			 
1e86			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1e86			 
1e86 3a f0 f0			ld a,(scratch+1) 
1e89 fe 00			cp 0 
1e8b 28 09			jr z, dumpcont 
1e8d			 
1e8d				; no, not a null term line so has an address to work out.... 
1e8d			 
1e8d 21 f1 f0			ld hl,scratch+2 
1e90 cd 63 12			call get_word_hl 
1e93			 
1e93 22 12 f4			ld (os_cur_ptr),hl	 
1e96			 
1e96			 
1e96			 
1e96			dumpcont: 
1e96			 
1e96				; dump bytes at ptr 
1e96			 
1e96			 
1e96 3e 00			ld a, display_row_1 
1e98 2a fa fa			ld hl, (display_fb_active) 
1e9b cd b1 0f			call addatohl 
1e9e cd c6 1e			call .dumpbyterow 
1ea1			 
1ea1 3e 28			ld a, display_row_2 
1ea3 2a fa fa			ld hl, (display_fb_active) 
1ea6 cd b1 0f			call addatohl 
1ea9 cd c6 1e			call .dumpbyterow 
1eac			 
1eac			 
1eac 3e 50			ld a, display_row_3 
1eae 2a fa fa			ld hl, (display_fb_active) 
1eb1 cd b1 0f			call addatohl 
1eb4 cd c6 1e			call .dumpbyterow 
1eb7			 
1eb7 3e 78			ld a, display_row_4 
1eb9 2a fa fa			ld hl, (display_fb_active) 
1ebc cd b1 0f			call addatohl 
1ebf cd c6 1e			call .dumpbyterow 
1ec2			 
1ec2 cd a3 0d			call update_display 
1ec5			;		jp cli 
1ec5 c9				ret 
1ec6			 
1ec6			.dumpbyterow: 
1ec6			 
1ec6				;push af 
1ec6			 
1ec6 e5				push hl 
1ec7			 
1ec7				; calc where to poke the ascii 
1ec7			if display_cols == 20 
1ec7				ld a, 16 
1ec7			else 
1ec7 3e 1f			ld a, 31 
1ec9			endif 
1ec9			 
1ec9 cd b1 0f			call addatohl 
1ecc 22 f4 f3			ld (os_word_scratch),hl  		; save pos for later 
1ecf			 
1ecf			 
1ecf			; display decoding address 
1ecf 2a 12 f4		   	ld hl,(os_cur_ptr) 
1ed2			 
1ed2 7c				ld a,h 
1ed3 e1				pop hl 
1ed4 e5				push hl 
1ed5			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ed5 cd ad 11			call hexout 
1ed8 2a 12 f4		   	ld hl,(os_cur_ptr) 
1edb			 
1edb 7d				ld a,l 
1edc e1				pop hl 
1edd 23				inc hl 
1ede 23				inc hl 
1edf e5				push hl 
1ee0			;	ld hl, os_word_scratch+2 
1ee0 cd ad 11			call hexout 
1ee3 e1				pop hl 
1ee4 23				inc hl 
1ee5 23				inc hl 
1ee6				;ld hl, os_word_scratch+4 
1ee6			;	ld a, ':' 
1ee6 36 3a			ld (hl),':' 
1ee8 23				inc hl 
1ee9				;ld a, 0 
1ee9				;ld (hl),a 
1ee9				;ld de, os_word_scratch 
1ee9				;pop af 
1ee9				;push af 
1ee9			;		ld a, display_row_2 
1ee9			;		call str_at_display 
1ee9			;		call update_display 
1ee9			 
1ee9			 
1ee9			;pop af 
1ee9			;	add 5 
1ee9			 
1ee9			if display_cols == 20 
1ee9				ld b, 4 
1ee9			else 
1ee9 06 08			ld b, 8 
1eeb			endif	 
1eeb			 
1eeb			.dumpbyte: 
1eeb c5				push bc 
1eec e5				push hl 
1eed			 
1eed			 
1eed 2a 12 f4		   	ld hl,(os_cur_ptr) 
1ef0 7e					ld a,(hl) 
1ef1			 
1ef1					; poke the ascii to display 
1ef1 2a f4 f3				ld hl,(os_word_scratch) 
1ef4 77					ld (hl),a 
1ef5 23					inc hl 
1ef6 22 f4 f3				ld (os_word_scratch),hl 
1ef9			 
1ef9					 
1ef9			 
1ef9			 
1ef9 e1					pop hl 
1efa e5					push hl 
1efb			 
1efb cd ad 11				call hexout 
1efe			 
1efe					 
1efe 2a 12 f4		   	ld hl,(os_cur_ptr) 
1f01 23				inc hl 
1f02 22 12 f4		   	ld (os_cur_ptr),hl 
1f05			 
1f05 e1					pop hl 
1f06 23					inc hl 
1f07 23					inc hl 
1f08 23					inc hl 
1f09			 
1f09			 
1f09			 
1f09					;ld a,0 
1f09					;ld (os_word_scratch+2),a 
1f09					;pop af 
1f09					;push af 
1f09			 
1f09					;ld de, os_word_scratch 
1f09					;call str_at_display 
1f09			;		call update_display 
1f09			;		pop af 
1f09 c1					pop bc 
1f0a c6 03				add 3 
1f0c 10 dd			djnz .dumpbyte 
1f0e			 
1f0e				 
1f0e			 
1f0e c9				ret 
1f0f			 
1f0f			jump:	 
1f0f			 
1f0f 21 f1 f0			ld hl,scratch+2 
1f12 cd 63 12			call get_word_hl 
1f15				;ld hl,(scratch+2) 
1f15				;call fourehexhl 
1f15			 
1f15 22 12 f4			ld (os_cur_ptr),hl	 
1f18			 
1f18 e9				jp (hl) 
1f19			 
1f19			 
1f19			 
1f19			; TODO implement a basic monitor mode to start with 
1f19			 
1f19			 
1f19			 
1f19			 
1f19			 
1f19			 
1f19			 
1f19			 
1f19			 
1f19			; testing and demo code during development 
1f19			 
1f19			 
1f19 .. 00		str1: db "Enter some text...",0 
1f2c .. 00		clear: db "                    ",0 
1f41			 
1f41			demo: 
1f41			 
1f41			 
1f41			 
1f41			;	call update_display 
1f41			 
1f41				; init scratch input area for testing 
1f41 21 ef f0			ld hl, scratch	 
1f44			;	ld a,0 
1f44 36 00			ld (hl),0 
1f46			 
1f46			 
1f46 3e 28		            LD   A, display_row_2 
1f48			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f48 11 19 1f		            LD   DE, str1 
1f4b cd 93 0d			call str_at_display 
1f4e			 
1f4e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f4e			cloop:	 
1f4e 3e 50		            LD   A, display_row_3 
1f50			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f50 11 2c 1f		            LD   DE, clear 
1f53			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1f53 cd 93 0d				call str_at_display 
1f56 3e 78			ld a, display_row_4 
1f58 11 86 1f			ld de, prompt 
1f5b			 
1f5b cd 93 0d				call str_at_display 
1f5e cd a3 0d			call update_display 
1f61			 
1f61 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1f63 16 0a			ld d, 10 
1f65 21 ef f0			ld hl, scratch	 
1f68 cd de 0f			call input_str 
1f6b			 
1f6b			;	call clear_display 
1f6b			;'	call update_display 
1f6b			 
1f6b 3e 00		            LD   A, display_row_1 
1f6d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f6d 11 2c 1f		            LD   DE, clear 
1f70 cd 93 0d				call str_at_display 
1f73			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f73 3e 00		            LD   A, display_row_1 
1f75			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f75 11 ef f0		            LD   DE, scratch 
1f78			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f78 cd 93 0d				call str_at_display 
1f7b cd a3 0d			call update_display 
1f7e			 
1f7e			;		ld a,0 
1f7e 21 ef f0			ld hl, scratch 
1f81 36 00			ld (hl),0 
1f83			 
1f83			;	nop 
1f83 c3 4e 1f			jp cloop 
1f86			 
1f86			 
1f86			 
1f86			; OS Prompt 
1f86			 
1f86 .. 00		prompt: db ">",0 
1f88 .. 00		endprg: db "?",0 
1f8a			 
1f8a			 
1f8a			; handy next page prompt 
1f8a			next_page_prompt: 
1f8a e5				push hl 
1f8b d5				push de 
1f8c f5				push af 
1f8d c5				push bc 
1f8e			 
1f8e 3e 9f			ld a,display_row_4 + display_cols - 1 
1f90 11 88 1f		        ld de, endprg 
1f93 cd 93 0d			call str_at_display 
1f96 cd a3 0d			call update_display 
1f99 cd ec 7c			call cin_wait 
1f9c c1				pop bc 
1f9d f1				pop af 
1f9e d1				pop de 
1f9f e1				pop hl 
1fa0			 
1fa0			 
1fa0 c9				ret 
1fa1			 
1fa1			 
1fa1			; forth parser 
1fa1			 
1fa1			; My forth kernel 
1fa1			include "forth_kernel.asm" 
1fa1			; 
1fa1			; kernel to the forth OS 
1fa1			 
1fa1			DS_TYPE_STR: equ 1     ; string type 
1fa1			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1fa1			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1fa1			DS_TYPE_CONST: equ 4     ; string type that won't be freed on a POP 
1fa1			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1fa1			 
1fa1			FORTH_PARSEV1: equ 0 
1fa1			FORTH_PARSEV2: equ 0 
1fa1			FORTH_PARSEV3: equ 0 
1fa1			FORTH_PARSEV4: equ 0 
1fa1			FORTH_PARSEV5: equ 0 
1fa1			FORTH_PARSEV6: equ 1 
1fa1			 
1fa1			;if FORTH_PARSEV5 
1fa1			;	FORTH_END_BUFFER: equ 0 
1fa1			;else 
1fa1			FORTH_END_BUFFER: equ 127 
1fa1			;endif 
1fa1			 
1fa1			FORTH_TRUE: equ 1 
1fa1			FORTH_FALSE: equ 0 
1fa1			 
1fa1			if FORTH_PARSEV4 
1fa1			include "forth_stackops.asm" 
1fa1			endif 
1fa1			 
1fa1			if FORTH_PARSEV5 
1fa1			include "forth_stackopsv5.asm" 
1fa1			endif 
1fa1			 
1fa1			if FORTH_PARSEV6 
1fa1			include "forth_stackopsv5.asm" 
1fa1			 
1fa1			; Stack operations for v5 parser on wards 
1fa1			; * DATA stack 
1fa1			; * LOOP stack 
1fa1			; * RETURN stack 
1fa1			 
1fa1			 
1fa1			 
1fa1			FORTH_CHK_DSP_UNDER: macro 
1fa1				push hl 
1fa1				push de 
1fa1				ld hl,(cli_data_sp) 
1fa1				ld de, cli_data_stack 
1fa1				call cmp16 
1fa1				jp c, fault_dsp_under 
1fa1				pop de 
1fa1				pop hl 
1fa1				endm 
1fa1			 
1fa1			 
1fa1			FORTH_CHK_RSP_UNDER: macro 
1fa1				push hl 
1fa1				push de 
1fa1				ld hl,(cli_ret_sp) 
1fa1				ld de, cli_ret_stack 
1fa1				call cmp16 
1fa1				jp c, fault_rsp_under 
1fa1				pop de 
1fa1				pop hl 
1fa1				endm 
1fa1			 
1fa1			FORTH_CHK_LOOP_UNDER: macro 
1fa1				push hl 
1fa1				push de 
1fa1				ld hl,(cli_loop_sp) 
1fa1				ld de, cli_loop_stack 
1fa1				call cmp16 
1fa1				jp c, fault_loop_under 
1fa1				pop de 
1fa1				pop hl 
1fa1				endm 
1fa1			 
1fa1			FORTH_ERR_TOS_NOTSTR: macro 
1fa1				; TOSO might need more for checks when used 
1fa1				push af 
1fa1				ld a,(hl) 
1fa1				cp DS_TYPE_STR 
1fa1				jp nz, type_faultn   
1fa1				pop af 
1fa1				endm 
1fa1			 
1fa1			FORTH_ERR_TOS_NOTNUM: macro 
1fa1				push af 
1fa1				ld a,(hl) 
1fa1				cp DS_TYPE_INUM 
1fa1				jp nz, type_faultn   
1fa1				pop af 
1fa1				endm 
1fa1			 
1fa1			 
1fa1			; increase data stack pointer and save hl to it 
1fa1				 
1fa1			FORTH_DSP_NEXT: macro 
1fa1				call macro_forth_dsp_next 
1fa1				endm 
1fa1			 
1fa1			 
1fa1			macro_forth_dsp_next: 
1fa1				if DEBUG_FORTH_STACK_GUARD 
1fa1 cd 83 75				call check_stacks 
1fa4				endif 
1fa4 e5				push hl 
1fa5 d5				push de 
1fa6 eb				ex de,hl 
1fa7 2a 1c f9			ld hl,(cli_data_sp) 
1faa 23				inc hl 
1fab 23				inc hl 
1fac			 
1fac			; PARSEV5 
1fac 23				inc hl 
1fad 22 1c f9			ld (cli_data_sp),hl 
1fb0 73				ld (hl), e 
1fb1 23				inc hl 
1fb2 72				ld (hl), d 
1fb3 d1				pop de 
1fb4 e1				pop hl 
1fb5				if DEBUG_FORTH_STACK_GUARD 
1fb5 cd 83 75				call check_stacks 
1fb8				endif 
1fb8 c9				ret 
1fb9			 
1fb9			 
1fb9			; increase ret stack pointer and save hl to it 
1fb9				 
1fb9			FORTH_RSP_NEXT: macro 
1fb9				call macro_forth_rsp_next 
1fb9				endm 
1fb9			 
1fb9			macro_forth_rsp_next: 
1fb9				if DEBUG_FORTH_STACK_GUARD 
1fb9 cd 83 75				call check_stacks 
1fbc				endif 
1fbc e5				push hl 
1fbd d5				push de 
1fbe eb				ex de,hl 
1fbf 2a 20 f9			ld hl,(cli_ret_sp) 
1fc2 23				inc hl 
1fc3 23				inc hl 
1fc4 22 20 f9			ld (cli_ret_sp),hl 
1fc7 73				ld (hl), e 
1fc8 23				inc hl 
1fc9 72				ld (hl), d 
1fca d1				pop de 
1fcb e1				pop hl 
1fcc				if DEBUG_FORTH_STACK_GUARD 
1fcc cd 83 75				call check_stacks 
1fcf				endif 
1fcf c9				ret 
1fd0			 
1fd0			; get current ret stack pointer and save to hl  
1fd0				 
1fd0			FORTH_RSP_TOS: macro 
1fd0				call macro_forth_rsp_tos 
1fd0				endm 
1fd0			 
1fd0			macro_forth_rsp_tos: 
1fd0				;push de 
1fd0 2a 20 f9			ld hl,(cli_ret_sp) 
1fd3 cd 0b 20			call loadhlptrtohl 
1fd6				;ld e, (hl) 
1fd6				;inc hl 
1fd6				;ld d, (hl) 
1fd6				;ex de, hl 
1fd6					if DEBUG_FORTH_WORDS 
1fd6			;			DMARK "RST" 
1fd6						CALLMONITOR 
1fd6 cd a6 fd			call debug_vector  
1fd9				endm  
# End of macro CALLMONITOR
1fd9					endif 
1fd9				;pop de 
1fd9 c9				ret 
1fda			 
1fda			; pop ret stack pointer 
1fda				 
1fda			FORTH_RSP_POP: macro 
1fda				call macro_forth_rsp_pop 
1fda				endm 
1fda			 
1fda			 
1fda			macro_forth_rsp_pop: 
1fda				if DEBUG_FORTH_STACK_GUARD 
1fda			;		DMARK "RPP" 
1fda cd 83 75				call check_stacks 
1fdd					FORTH_CHK_RSP_UNDER 
1fdd e5				push hl 
1fde d5				push de 
1fdf 2a 20 f9			ld hl,(cli_ret_sp) 
1fe2 11 da f8			ld de, cli_ret_stack 
1fe5 cd cf 0f			call cmp16 
1fe8 da 9a 76			jp c, fault_rsp_under 
1feb d1				pop de 
1fec e1				pop hl 
1fed				endm 
# End of macro FORTH_CHK_RSP_UNDER
1fed				endif 
1fed e5				push hl 
1fee 2a 20 f9			ld hl,(cli_ret_sp) 
1ff1			 
1ff1			 
1ff1				if FORTH_ENABLE_FREE 
1ff1			 
1ff1					; get pointer 
1ff1			 
1ff1					push de 
1ff1					push hl 
1ff1			 
1ff1					ld e, (hl) 
1ff1					inc hl 
1ff1					ld d, (hl) 
1ff1			 
1ff1					ex de, hl 
1ff1					call free 
1ff1			 
1ff1					pop hl 
1ff1					pop de 
1ff1			 
1ff1			 
1ff1				endif 
1ff1			 
1ff1			 
1ff1 2b				dec hl 
1ff2 2b				dec hl 
1ff3 22 20 f9			ld (cli_ret_sp), hl 
1ff6				; do stack underflow checks 
1ff6 e1				pop hl 
1ff7				if DEBUG_FORTH_STACK_GUARD 
1ff7 cd 83 75				call check_stacks 
1ffa					FORTH_CHK_RSP_UNDER 
1ffa e5				push hl 
1ffb d5				push de 
1ffc 2a 20 f9			ld hl,(cli_ret_sp) 
1fff 11 da f8			ld de, cli_ret_stack 
2002 cd cf 0f			call cmp16 
2005 da 9a 76			jp c, fault_rsp_under 
2008 d1				pop de 
2009 e1				pop hl 
200a				endm 
# End of macro FORTH_CHK_RSP_UNDER
200a				endif 
200a c9				ret 
200b			 
200b			 
200b			 
200b			; routine to load word pointed to by hl into hl 
200b			 
200b			loadhlptrtohl: 
200b			 
200b d5				push de 
200c 5e				ld e, (hl) 
200d 23				inc hl 
200e 56				ld d, (hl) 
200f eb				ex de, hl 
2010 d1				pop de 
2011			 
2011 c9				ret 
2012			 
2012			 
2012			 
2012			 
2012			 
2012			; push a number held in HL onto the data stack 
2012			; entry point for pushing a value when already in hl used in function above 
2012			 
2012			forth_push_numhl: 
2012			 
2012 e5				push hl    ; save value to push 
2013			 
2013			if DEBUG_FORTH_PUSH 
2013				; see if disabled 
2013			 
2013			 
2013 f5				push af 
2014 3a a6 fd			ld a,(debug_vector) 
2017 fe c9			cp $c9   ; ret 
2019			;	ld a, (os_view_disable) 
2019			;	cp '*' 
2019 28 33			jr z, .pskip2 
201b e5				push hl 
201c e5			push hl 
201d cd 81 0d			call clear_display 
2020 e1			pop hl 
2021 7c				ld a,h 
2022 21 f4 f3			ld hl, os_word_scratch 
2025 cd ad 11			call hexout 
2028 e1				pop hl 
2029 7d				ld a,l 
202a 21 f6 f3			ld hl, os_word_scratch+2 
202d cd ad 11			call hexout 
2030			 
2030 21 f8 f3			ld hl, os_word_scratch+4 
2033			;	ld a,0 
2033 36 00			ld (hl),0 
2035 11 f4 f3			ld de,os_word_scratch 
2038 3e 28				ld a, display_row_2 
203a cd 93 0d				call str_at_display 
203d 11 e4 65			ld de, .push_num 
2040 3e 00			ld a, display_row_1 
2042			 
2042 cd 93 0d				call str_at_display 
2045			 
2045			 
2045 cd a3 0d			call update_display 
2048 cd c0 0c			call delay1s 
204b cd c0 0c			call delay1s 
204e			.pskip2:  
204e			 
204e f1				pop af 
204f			endif	 
204f			 
204f			 
204f				FORTH_DSP_NEXT 
204f cd a1 1f			call macro_forth_dsp_next 
2052				endm 
# End of macro FORTH_DSP_NEXT
2052			 
2052 2a 1c f9			ld hl, (cli_data_sp) 
2055			 
2055				; save item type 
2055			;	ld a,  DS_TYPE_INUM 
2055 36 02			ld (hl), DS_TYPE_INUM 
2057 23				inc hl 
2058			 
2058				; get word off stack 
2058 d1				pop de 
2059				;ld a,e 
2059 73				ld (hl), e 
205a 23				inc hl 
205b			;	ld a,d 
205b 72				ld (hl), d 
205c			 
205c			if DEBUG_FORTH_PUSH 
205c 2b				dec hl 
205d 2b				dec hl 
205e 2b				dec hl 
205f						DMARK "PH5" 
205f f5				push af  
2060 3a 74 20			ld a, (.dmark)  
2063 32 99 fd			ld (debug_mark),a  
2066 3a 75 20			ld a, (.dmark+1)  
2069 32 9a fd			ld (debug_mark+1),a  
206c 3a 76 20			ld a, (.dmark+2)  
206f 32 9b fd			ld (debug_mark+2),a  
2072 18 03			jr .pastdmark  
2074 ..			.dmark: db "PH5"  
2077 f1			.pastdmark: pop af  
2078			endm  
# End of macro DMARK
2078				CALLMONITOR 
2078 cd a6 fd			call debug_vector  
207b				endm  
# End of macro CALLMONITOR
207b			endif	 
207b			 
207b c9				ret 
207c			 
207c			 
207c			; Push a string to stack pointed to by hl 
207c			 
207c			forth_push_str: 
207c			 
207c			if DEBUG_FORTH_PUSH 
207c						DMARK "PSQ" 
207c f5				push af  
207d 3a 91 20			ld a, (.dmark)  
2080 32 99 fd			ld (debug_mark),a  
2083 3a 92 20			ld a, (.dmark+1)  
2086 32 9a fd			ld (debug_mark+1),a  
2089 3a 93 20			ld a, (.dmark+2)  
208c 32 9b fd			ld (debug_mark+2),a  
208f 18 03			jr .pastdmark  
2091 ..			.dmark: db "PSQ"  
2094 f1			.pastdmark: pop af  
2095			endm  
# End of macro DMARK
2095				CALLMONITOR 
2095 cd a6 fd			call debug_vector  
2098				endm  
# End of macro CALLMONITOR
2098			endif	 
2098			 
2098			 
2098			    
2098 e5				push hl 
2099 e5				push hl 
209a			 
209a			;	ld a, 0   ; find end of string 
209a cd 09 13			call strlenz 
209d			if DEBUG_FORTH_PUSH 
209d						DMARK "PQ2" 
209d f5				push af  
209e 3a b2 20			ld a, (.dmark)  
20a1 32 99 fd			ld (debug_mark),a  
20a4 3a b3 20			ld a, (.dmark+1)  
20a7 32 9a fd			ld (debug_mark+1),a  
20aa 3a b4 20			ld a, (.dmark+2)  
20ad 32 9b fd			ld (debug_mark+2),a  
20b0 18 03			jr .pastdmark  
20b2 ..			.dmark: db "PQ2"  
20b5 f1			.pastdmark: pop af  
20b6			endm  
# End of macro DMARK
20b6				CALLMONITOR 
20b6 cd a6 fd			call debug_vector  
20b9				endm  
# End of macro CALLMONITOR
20b9			endif	 
20b9 eb				ex de, hl 
20ba e1				pop hl   ; get ptr to start of string 
20bb			if DEBUG_FORTH_PUSH 
20bb						DMARK "PQ3" 
20bb f5				push af  
20bc 3a d0 20			ld a, (.dmark)  
20bf 32 99 fd			ld (debug_mark),a  
20c2 3a d1 20			ld a, (.dmark+1)  
20c5 32 9a fd			ld (debug_mark+1),a  
20c8 3a d2 20			ld a, (.dmark+2)  
20cb 32 9b fd			ld (debug_mark+2),a  
20ce 18 03			jr .pastdmark  
20d0 ..			.dmark: db "PQ3"  
20d3 f1			.pastdmark: pop af  
20d4			endm  
# End of macro DMARK
20d4				CALLMONITOR 
20d4 cd a6 fd			call debug_vector  
20d7				endm  
# End of macro CALLMONITOR
20d7			endif	 
20d7 19				add hl,de 
20d8			if DEBUG_FORTH_PUSH 
20d8						DMARK "PQE" 
20d8 f5				push af  
20d9 3a ed 20			ld a, (.dmark)  
20dc 32 99 fd			ld (debug_mark),a  
20df 3a ee 20			ld a, (.dmark+1)  
20e2 32 9a fd			ld (debug_mark+1),a  
20e5 3a ef 20			ld a, (.dmark+2)  
20e8 32 9b fd			ld (debug_mark+2),a  
20eb 18 03			jr .pastdmark  
20ed ..			.dmark: db "PQE"  
20f0 f1			.pastdmark: pop af  
20f1			endm  
# End of macro DMARK
20f1				CALLMONITOR 
20f1 cd a6 fd			call debug_vector  
20f4				endm  
# End of macro CALLMONITOR
20f4			endif	 
20f4			 
20f4 2b				dec hl    ; see if there is an optional trailing double quote 
20f5 7e				ld a,(hl) 
20f6 fe 22			cp '"' 
20f8 20 02			jr nz, .strnoq 
20fa			;	ld a, 0      ; get rid of double quote 
20fa 36 00			ld (hl), 0 
20fc 23			.strnoq: inc hl 
20fd			 
20fd			;	ld a, 0 
20fd 36 00			ld (hl), 0     ; add null term and get rid of trailing double quote 
20ff			 
20ff 13				inc de ; add one for the type string 
2100 13				inc de ; add one for null term??? 
2101			 
2101				; tos is get string pointer again 
2101				; de contains space to allocate 
2101				 
2101 d5				push de 
2102			 
2102 eb				ex de, hl 
2103			 
2103				;push af 
2103			 
2103			if DEBUG_FORTH_PUSH 
2103						DMARK "PHm" 
2103 f5				push af  
2104 3a 18 21			ld a, (.dmark)  
2107 32 99 fd			ld (debug_mark),a  
210a 3a 19 21			ld a, (.dmark+1)  
210d 32 9a fd			ld (debug_mark+1),a  
2110 3a 1a 21			ld a, (.dmark+2)  
2113 32 9b fd			ld (debug_mark+2),a  
2116 18 03			jr .pastdmark  
2118 ..			.dmark: db "PHm"  
211b f1			.pastdmark: pop af  
211c			endm  
# End of macro DMARK
211c				CALLMONITOR 
211c cd a6 fd			call debug_vector  
211f				endm  
# End of macro CALLMONITOR
211f			endif	 
211f cd 7d 13			call malloc	; on ret hl now contains allocated memory 
2122				if DEBUG_FORTH_MALLOC_GUARD 
2122 cc 3c 66				call z,malloc_error 
2125				endif 
2125			 
2125				 
2125 c1				pop bc    ; get length 
2126 d1				pop de   ;  get string start    
2127			 
2127				; hl has destination from malloc 
2127			 
2127 eb				ex de, hl    ; prep for ldir 
2128			 
2128 d5				push de   ; save malloc area for DSP later 
2129				;push hl   ; save malloc area for DSP later 
2129			 
2129			if DEBUG_FORTH_PUSH 
2129						DMARK "PHc" 
2129 f5				push af  
212a 3a 3e 21			ld a, (.dmark)  
212d 32 99 fd			ld (debug_mark),a  
2130 3a 3f 21			ld a, (.dmark+1)  
2133 32 9a fd			ld (debug_mark+1),a  
2136 3a 40 21			ld a, (.dmark+2)  
2139 32 9b fd			ld (debug_mark+2),a  
213c 18 03			jr .pastdmark  
213e ..			.dmark: db "PHc"  
2141 f1			.pastdmark: pop af  
2142			endm  
# End of macro DMARK
2142				CALLMONITOR 
2142 cd a6 fd			call debug_vector  
2145				endm  
# End of macro CALLMONITOR
2145			endif	 
2145			 
2145			 
2145 ed b0			ldir 
2147			 
2147			 
2147				; push malloc to data stack     macro?????  
2147			 
2147				FORTH_DSP_NEXT 
2147 cd a1 1f			call macro_forth_dsp_next 
214a				endm 
# End of macro FORTH_DSP_NEXT
214a			 
214a				; save value and type 
214a			 
214a 2a 1c f9			ld hl, (cli_data_sp) 
214d			 
214d				; save item type 
214d			;	ld a,  DS_TYPE_STR 
214d 36 01			ld (hl), DS_TYPE_STR 
214f 23				inc hl 
2150			 
2150				; get malloc word off stack 
2150 d1				pop de 
2151 73				ld (hl), e 
2152 23				inc hl 
2153 72				ld (hl), d 
2154			 
2154			 
2154			 
2154			if DEBUG_FORTH_PUSH 
2154 2a 1c f9			ld hl, (cli_data_sp) 
2157						DMARK "PHS" 
2157 f5				push af  
2158 3a 6c 21			ld a, (.dmark)  
215b 32 99 fd			ld (debug_mark),a  
215e 3a 6d 21			ld a, (.dmark+1)  
2161 32 9a fd			ld (debug_mark+1),a  
2164 3a 6e 21			ld a, (.dmark+2)  
2167 32 9b fd			ld (debug_mark+2),a  
216a 18 03			jr .pastdmark  
216c ..			.dmark: db "PHS"  
216f f1			.pastdmark: pop af  
2170			endm  
# End of macro DMARK
2170				CALLMONITOR 
2170 cd a6 fd			call debug_vector  
2173				endm  
# End of macro CALLMONITOR
2173			;	ex de,hl 
2173			endif	 
2173				; in case of spaces, skip the ptr past the copied string 
2173				;pop af 
2173				;ld (cli_origptr),hl 
2173			 
2173 c9				ret 
2174			 
2174			 
2174			 
2174			; TODO ascii push input onto stack given hl to start of input 
2174			 
2174			; identify type 
2174			; if starts with a " then a string 
2174			; otherwise it is a number 
2174			;  
2174			; if a string 
2174			;     scan for ending " to get length of string to malloc for + 1 
2174			;     malloc 
2174			;     put pointer to string on stack first byte flags as string 
2174			; 
2174			; else a number 
2174			;    look for number format identifier 
2174			;    $xx hex 
2174			;    %xxxxx bin 
2174			;    xxxxx decimal 
2174			;    convert number to 16bit word.  
2174			;    malloc word + 1 with flag to identiy as num 
2174			;    put pointer to number on stack 
2174			;   
2174			;  
2174			  
2174			forth_apush: 
2174				; kernel push 
2174			 
2174			if DEBUG_FORTH_PUSH 
2174						DMARK "PSH" 
2174 f5				push af  
2175 3a 89 21			ld a, (.dmark)  
2178 32 99 fd			ld (debug_mark),a  
217b 3a 8a 21			ld a, (.dmark+1)  
217e 32 9a fd			ld (debug_mark+1),a  
2181 3a 8b 21			ld a, (.dmark+2)  
2184 32 9b fd			ld (debug_mark+2),a  
2187 18 03			jr .pastdmark  
2189 ..			.dmark: db "PSH"  
218c f1			.pastdmark: pop af  
218d			endm  
# End of macro DMARK
218d				CALLMONITOR 
218d cd a6 fd			call debug_vector  
2190				endm  
# End of macro CALLMONITOR
2190			endif	 
2190				; identify input type 
2190			 
2190 7e				ld a,(hl) 
2191			 
2191 fe 23			cp '#' 
2193 ca cb 21			jp z, .fapdec 
2196			 
2196			 
2196 fe 22			cp '"' 
2198 28 0a			jr z, .fapstr 
219a fe 24			cp '$' 
219c ca c3 21			jp z, .faphex 
219f fe 25			cp '%' 
21a1 ca ac 21			jp z, .fapbin 
21a4			;	cp 'b' 
21a4			;	jp z, .fabin 
21a4				; else decimal 
21a4			 
21a4				; TODO do decimal conversion 
21a4				; decimal is stored as a 16bit word 
21a4			 
21a4				; by default everything is a string if type is not detected 
21a4			.fapstr: ; 
21a4 fe 22			cp '"' 
21a6 20 01			jr nz, .strnoqu 
21a8 23				inc hl 
21a9			.strnoqu: 
21a9 c3 7c 20			jp forth_push_str 
21ac			 
21ac			 
21ac			 
21ac			.fapbin:    ; push a binary string.  
21ac 11 00 00			ld de, 0   ; hold a 16bit value 
21af			 
21af 23			.fapbinshift:	inc hl  
21b0 7e				ld a,(hl) 
21b1			;	cp 0     ; done scanning  
21b1 b7				or a 
21b2 28 0b			jr z, .fapbdone  	; got it in HL so push  
21b4			 
21b4				; left shift de 
21b4 eb				ex de, hl	 
21b5 29				add hl, hl 
21b6			 
21b6				; is 1 
21b6 fe 31			cp '1' 
21b8 20 02			jr nz, .binzero 
21ba cb 4d			bit 1, l 
21bc			.binzero: 
21bc eb				ex de, hl	 ; save current de 
21bd 18 f0			jr .fapbinshift 
21bf			 
21bf			.fapbdone: 
21bf eb				ex de, hl 
21c0 c3 12 20			jp forth_push_numhl 
21c3			 
21c3			 
21c3			.faphex:   ; hex is always stored as a 16bit word 
21c3				; skip number prefix 
21c3 23				inc hl 
21c4				; turn ascii into number 
21c4 cd 63 12			call get_word_hl	; ret 16bit word in hl 
21c7			 
21c7 c3 12 20			jp forth_push_numhl 
21ca			 
21ca			;	 nop 
21ca			 
21ca			.fabin:   ; TODO bin conversion 
21ca			 
21ca			 
21ca c9				ret 
21cb			.fapdec:	 
21cb				; string to dec conversion 
21cb 23				inc hl 
21cc eb				ex de, hl 
21cd cd a0 12			call string_to_uint16 
21d0 c3 12 20			jp forth_push_numhl 
21d3 c9				ret 
21d4				 
21d4			;atoui_16: 
21d4			 
21d4			; get either a string ptr or a 16bit word from the data stack 
21d4			 
21d4			FORTH_DSP: macro 
21d4				call macro_forth_dsp 
21d4				endm 
21d4			 
21d4			macro_forth_dsp: 
21d4				; data stack pointer points to current word on tos 
21d4			 
21d4 2a 1c f9			ld hl,(cli_data_sp) 
21d7			 
21d7				if DEBUG_FORTH_PUSH 
21d7						DMARK "DSP" 
21d7 f5				push af  
21d8 3a ec 21			ld a, (.dmark)  
21db 32 99 fd			ld (debug_mark),a  
21de 3a ed 21			ld a, (.dmark+1)  
21e1 32 9a fd			ld (debug_mark+1),a  
21e4 3a ee 21			ld a, (.dmark+2)  
21e7 32 9b fd			ld (debug_mark+2),a  
21ea 18 03			jr .pastdmark  
21ec ..			.dmark: db "DSP"  
21ef f1			.pastdmark: pop af  
21f0			endm  
# End of macro DMARK
21f0			 
21f0 cd 6f 66				call display_data_sp 
21f3				;call break_point_state 
21f3				;rst 030h 
21f3				CALLMONITOR 
21f3 cd a6 fd			call debug_vector  
21f6				endm  
# End of macro CALLMONITOR
21f6				endif 
21f6			 
21f6 c9				ret 
21f7			 
21f7			; return hl to start of value on stack 
21f7			 
21f7			FORTH_DSP_VALUE: macro 
21f7				call macro_forth_dsp_value 
21f7				endm 
21f7			 
21f7			macro_forth_dsp_value: 
21f7			 
21f7				FORTH_DSP 
21f7 cd d4 21			call macro_forth_dsp 
21fa				endm 
# End of macro FORTH_DSP
21fa			 
21fa d5				push de 
21fb			 
21fb 23				inc hl ; skip type 
21fc			 
21fc 5e				ld e, (hl) 
21fd 23				inc hl 
21fe 56				ld d, (hl) 
21ff eb				ex de,hl  
2200			 
2200 d1				pop de 
2201			 
2201 c9				ret 
2202			 
2202			; return hl to start of value to second item on stack 
2202			 
2202			FORTH_DSP_VALUEM1: macro 
2202				call macro_forth_dsp_value_m1 
2202				endm 
2202			 
2202			macro_forth_dsp_value_m1: 
2202			 
2202				FORTH_DSP 
2202 cd d4 21			call macro_forth_dsp 
2205				endm 
# End of macro FORTH_DSP
2205			 
2205 2b				dec hl 
2206 2b				dec hl 
2207			;	dec hl 
2207			 
2207 d5				push de 
2208			 
2208 5e				ld e, (hl) 
2209 23				inc hl 
220a 56				ld d, (hl) 
220b eb				ex de,hl  
220c			 
220c d1				pop de 
220d			 
220d c9				ret 
220e			 
220e				 
220e			 
220e			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
220e			 
220e			FORTH_DSP_POP: macro 
220e				call macro_forth_dsp_pop 
220e				endm 
220e			 
220e			 
220e			; get the tos data type 
220e			 
220e			FORTH_DSP_TYPE:   macro 
220e			 
220e				;FORTH_DSP_VALUE 
220e				FORTH_DSP 
220e				 
220e				; hl points to value 
220e				; check type 
220e			 
220e				ld a,(hl) 
220e			 
220e				endm 
220e			 
220e			; load the tos value into hl 
220e			 
220e			 
220e			FORTH_DSP_VALUEHL:  macro 
220e				call macro_dsp_valuehl 
220e				endm 
220e			 
220e			 
220e			 
220e			macro_dsp_valuehl: 
220e				FORTH_DSP_VALUE 
220e cd f7 21			call macro_forth_dsp_value 
2211				endm 
# End of macro FORTH_DSP_VALUE
2211			 
2211				;FORTH_ERR_TOS_NOTNUM 
2211			 
2211				;inc hl   ; skip type id 
2211			 
2211			;	push de 
2211			; 
2211			;	ld e, (hl) 
2211			;	inc hl 
2211			;	ld d, (hl) 
2211			;	ex de,hl  
2211			 
2211			;	pop de 
2211			 
2211				if DEBUG_FORTH_PUSH 
2211						DMARK "DVL" 
2211 f5				push af  
2212 3a 26 22			ld a, (.dmark)  
2215 32 99 fd			ld (debug_mark),a  
2218 3a 27 22			ld a, (.dmark+1)  
221b 32 9a fd			ld (debug_mark+1),a  
221e 3a 28 22			ld a, (.dmark+2)  
2221 32 9b fd			ld (debug_mark+2),a  
2224 18 03			jr .pastdmark  
2226 ..			.dmark: db "DVL"  
2229 f1			.pastdmark: pop af  
222a			endm  
# End of macro DMARK
222a				CALLMONITOR 
222a cd a6 fd			call debug_vector  
222d				endm  
# End of macro CALLMONITOR
222d				endif 
222d c9				ret 
222e			 
222e			forth_apushstrhl:      
222e				; push of string requires use of cli_origptr 
222e				; bodge use 
222e			 
222e				; get current cli_origptr, save, update with temp pointer  
222e ed 5b 6c f9		ld de, (cli_origptr) 
2232 22 6c f9			ld (cli_origptr), hl 
2235 d5				push de 
2236 cd 74 21			call forth_apush 
2239 d1				pop de 
223a ed 53 6c f9		ld (cli_origptr), de 
223e c9			        ret	 
223f			 
223f			 
223f			; increase loop stack pointer and save hl to it 
223f				 
223f			FORTH_LOOP_NEXT: macro 
223f				call macro_forth_loop_next 
223f				;nop 
223f				endm 
223f			 
223f			macro_forth_loop_next: 
223f				if DEBUG_FORTH_STACK_GUARD 
223f cd 83 75				call check_stacks 
2242				endif 
2242 e5				push hl 
2243 d5				push de 
2244 eb				ex de,hl 
2245 2a 1e f9			ld hl,(cli_loop_sp) 
2248 23				inc hl 
2249 23				inc hl 
224a					if DEBUG_FORTH_WORDS 
224a						DMARK "LNX" 
224a f5				push af  
224b 3a 5f 22			ld a, (.dmark)  
224e 32 99 fd			ld (debug_mark),a  
2251 3a 60 22			ld a, (.dmark+1)  
2254 32 9a fd			ld (debug_mark+1),a  
2257 3a 61 22			ld a, (.dmark+2)  
225a 32 9b fd			ld (debug_mark+2),a  
225d 18 03			jr .pastdmark  
225f ..			.dmark: db "LNX"  
2262 f1			.pastdmark: pop af  
2263			endm  
# End of macro DMARK
2263						CALLMONITOR 
2263 cd a6 fd			call debug_vector  
2266				endm  
# End of macro CALLMONITOR
2266					endif 
2266 22 1e f9			ld (cli_loop_sp),hl 
2269 73				ld (hl), e 
226a 23				inc hl 
226b 72				ld (hl), d 
226c d1				pop de    ; been reversed so save a swap on restore 
226d e1				pop hl 
226e				if DEBUG_FORTH_STACK_GUARD 
226e cd 83 75				call check_stacks 
2271				endif 
2271 c9				ret 
2272			 
2272			; get current ret stack pointer and save to hl  
2272				 
2272			FORTH_LOOP_TOS: macro 
2272				call macro_forth_loop_tos 
2272				endm 
2272			 
2272			macro_forth_loop_tos: 
2272 d5				push de 
2273 2a 1e f9			ld hl,(cli_loop_sp) 
2276 5e				ld e, (hl) 
2277 23				inc hl 
2278 56				ld d, (hl) 
2279 eb				ex de, hl 
227a d1				pop de 
227b c9				ret 
227c			 
227c			; pop loop stack pointer 
227c				 
227c			FORTH_LOOP_POP: macro 
227c				call macro_forth_loop_pop 
227c				endm 
227c			 
227c			 
227c			macro_forth_loop_pop: 
227c				if DEBUG_FORTH_STACK_GUARD 
227c					DMARK "LPP" 
227c f5				push af  
227d 3a 91 22			ld a, (.dmark)  
2280 32 99 fd			ld (debug_mark),a  
2283 3a 92 22			ld a, (.dmark+1)  
2286 32 9a fd			ld (debug_mark+1),a  
2289 3a 93 22			ld a, (.dmark+2)  
228c 32 9b fd			ld (debug_mark+2),a  
228f 18 03			jr .pastdmark  
2291 ..			.dmark: db "LPP"  
2294 f1			.pastdmark: pop af  
2295			endm  
# End of macro DMARK
2295 cd 83 75				call check_stacks 
2298					FORTH_CHK_LOOP_UNDER 
2298 e5				push hl 
2299 d5				push de 
229a 2a 1e f9			ld hl,(cli_loop_sp) 
229d 11 58 f8			ld de, cli_loop_stack 
22a0 cd cf 0f			call cmp16 
22a3 da a0 76			jp c, fault_loop_under 
22a6 d1				pop de 
22a7 e1				pop hl 
22a8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22a8				endif 
22a8 e5				push hl 
22a9 2a 1e f9			ld hl,(cli_loop_sp) 
22ac 2b				dec hl 
22ad 2b				dec hl 
22ae 22 1e f9			ld (cli_loop_sp), hl 
22b1				; TODO do stack underflow checks 
22b1 e1				pop hl 
22b2				if DEBUG_FORTH_STACK_GUARD 
22b2 cd 83 75				call check_stacks 
22b5					FORTH_CHK_LOOP_UNDER 
22b5 e5				push hl 
22b6 d5				push de 
22b7 2a 1e f9			ld hl,(cli_loop_sp) 
22ba 11 58 f8			ld de, cli_loop_stack 
22bd cd cf 0f			call cmp16 
22c0 da a0 76			jp c, fault_loop_under 
22c3 d1				pop de 
22c4 e1				pop hl 
22c5				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22c5				endif 
22c5 c9				ret 
22c6			 
22c6			macro_forth_dsp_pop: 
22c6			 
22c6 e5				push hl 
22c7			 
22c7				; release malloc data 
22c7			 
22c7				if DEBUG_FORTH_STACK_GUARD 
22c7 cd 83 75				call check_stacks 
22ca					FORTH_CHK_DSP_UNDER 
22ca e5				push hl 
22cb d5				push de 
22cc 2a 1c f9			ld hl,(cli_data_sp) 
22cf 11 56 f6			ld de, cli_data_stack 
22d2 cd cf 0f			call cmp16 
22d5 da 94 76			jp c, fault_dsp_under 
22d8 d1				pop de 
22d9 e1				pop hl 
22da				endm 
# End of macro FORTH_CHK_DSP_UNDER
22da				endif 
22da				;ld hl,(cli_data_sp) 
22da			if DEBUG_FORTH_DOT 
22da				DMARK "DPP" 
22da f5				push af  
22db 3a ef 22			ld a, (.dmark)  
22de 32 99 fd			ld (debug_mark),a  
22e1 3a f0 22			ld a, (.dmark+1)  
22e4 32 9a fd			ld (debug_mark+1),a  
22e7 3a f1 22			ld a, (.dmark+2)  
22ea 32 9b fd			ld (debug_mark+2),a  
22ed 18 03			jr .pastdmark  
22ef ..			.dmark: db "DPP"  
22f2 f1			.pastdmark: pop af  
22f3			endm  
# End of macro DMARK
22f3				CALLMONITOR 
22f3 cd a6 fd			call debug_vector  
22f6				endm  
# End of macro CALLMONITOR
22f6			endif	 
22f6			 
22f6			 
22f6			if FORTH_ENABLE_DSPPOPFREE 
22f6			 
22f6				FORTH_DSP 
22f6 cd d4 21			call macro_forth_dsp 
22f9				endm 
# End of macro FORTH_DSP
22f9			 
22f9 7e				ld a, (hl) 
22fa fe 01			cp DS_TYPE_STR             ; implies that DS_TYPE_CONST *WONT* be freed 
22fc 20 22			jr nz, .skippopfree 
22fe			 
22fe				FORTH_DSP_VALUEHL 
22fe cd 0e 22			call macro_dsp_valuehl 
2301				endm 
# End of macro FORTH_DSP_VALUEHL
2301			;	nop 
2301			if DEBUG_FORTH_DOT 
2301				DMARK "DPf" 
2301 f5				push af  
2302 3a 16 23			ld a, (.dmark)  
2305 32 99 fd			ld (debug_mark),a  
2308 3a 17 23			ld a, (.dmark+1)  
230b 32 9a fd			ld (debug_mark+1),a  
230e 3a 18 23			ld a, (.dmark+2)  
2311 32 9b fd			ld (debug_mark+2),a  
2314 18 03			jr .pastdmark  
2316 ..			.dmark: db "DPf"  
2319 f1			.pastdmark: pop af  
231a			endm  
# End of macro DMARK
231a				CALLMONITOR 
231a cd a6 fd			call debug_vector  
231d				endm  
# End of macro CALLMONITOR
231d			endif	 
231d cd 47 14			call free 
2320			.skippopfree: 
2320				 
2320			 
2320			endif 
2320			 
2320			if DEBUG_FORTH_DOT_KEY 
2320				DMARK "DP2" 
2320				CALLMONITOR 
2320			endif	 
2320			 
2320				; move pointer down 
2320			 
2320 2a 1c f9			ld hl,(cli_data_sp) 
2323 2b				dec hl 
2324 2b				dec hl 
2325			; PARSEV5 
2325 2b				dec hl 
2326 22 1c f9			ld (cli_data_sp), hl 
2329			 
2329				if DEBUG_FORTH_STACK_GUARD 
2329 cd 83 75				call check_stacks 
232c					FORTH_CHK_DSP_UNDER 
232c e5				push hl 
232d d5				push de 
232e 2a 1c f9			ld hl,(cli_data_sp) 
2331 11 56 f6			ld de, cli_data_stack 
2334 cd cf 0f			call cmp16 
2337 da 94 76			jp c, fault_dsp_under 
233a d1				pop de 
233b e1				pop hl 
233c				endm 
# End of macro FORTH_CHK_DSP_UNDER
233c				endif 
233c			 
233c e1				pop hl 
233d			 
233d c9				ret 
233e			 
233e			getwordathl: 
233e				; hl points to an address 
233e				; load hl with the word at that address 
233e			 
233e d5				push de 
233f			 
233f 5e				ld e, (hl) 
2340 23				inc hl 
2341 56				ld d, (hl) 
2342 eb				ex de, hl 
2343			 
2343 d1				pop de 
2344 c9				ret 
2345			 
2345			 
2345			; functions to manuplite stack pointers 
2345			 
2345			; generate fragment to set hl to be pointer to a stack item 
2345			 
2345			FORTH_DSP_PTR: macro  x 
2345				ld hl,(cli_data_sp) 
2345				ld de, x * 3 
2345				sbc hl, de 
2345				endm 
2345			 
2345			 
2345			 
2345			; copy point in hl to stack tmp storage slots 1-4 
2345			hltostack1: 
2345 11 ec f0			ld de, os_stack_1  
2348 c3 73 23			jp hltostackmv 
234b			 
234b			hltostack2:  
234b 11 e9 f0			ld de, os_stack_2 
234e c3 73 23			jp hltostackmv 
2351			 
2351			hltostack3:  
2351 11 e6 f0			ld de, os_stack_3 
2354 c3 73 23			jp hltostackmv 
2357			 
2357			hltostack4:  
2357 11 e3 f0			ld de, os_stack_4  
235a c3 73 23			jp hltostackmv 
235d			 
235d			; copy to point in hl from stack tmp storage slots 1-4 
235d			hlfromstack1: 
235d 11 ec f0			ld de, os_stack_1 
2360 c3 72 23			jp hlfromsttackmv 
2363			 
2363			hlfromstack2:  
2363 11 e9 f0			ld de, os_stack_2 
2366 c3 72 23			jp hlfromsttackmv 
2369			 
2369			hlfromstack3:  
2369 11 e6 f0			ld de, os_stack_3 
236c c3 72 23			jp hlfromsttackmv 
236f			 
236f			hlfromstack4:  
236f 11 e3 f0			ld de, os_stack_4 
2372			 
2372			hlfromsttackmv: 
2372 eb				ex de, hl 
2373			 
2373			hltostackmv: 
2373			 
2373				; do stack move 
2373 c5				push bc 
2374 01 03 00			ld bc, 3 
2377 ed b0			ldir  
2379 c1				pop bc	 
237a c9				ret 
237b			 
237b			; eof 
237b			 
# End of file forth_stackopsv5.asm
237b			endif 
237b			loadwordinhl:	 
237b			 
237b d5				push de 
237c			 
237c 5e				ld e, (hl) 
237d 23				inc hl 
237e 56				ld d, (hl) 
237f eb				ex de,hl  
2380			 
2380 d1				pop de 
2381			 
2381 c9				ret 
2382			 
2382			user_word_eol:  
2382				; hl contains the pointer to where to create a linked list item from the end 
2382				; of the user dict to continue on at the system word dict 
2382				 
2382				; poke the stub of the word list linked list to repoint to rom words 
2382			 
2382				; stub format 
2382				; db   word id 
2382				; dw    link to next word 
2382			        ; db char length of token 
2382				; db string + 0 term 
2382				; db exec code....  
2382			 
2382			;	ld a, WORD_SYS_ROOT     ; root word 
2382 36 00			ld (hl), WORD_SYS_ROOT		; word id 
2384 23				inc hl 
2385			 
2385 11 2e 25			ld de, sysdict 
2388 73				ld (hl), e		; next word link ie system dict 
2389 23				inc hl 
238a 72				ld (hl), d		; next word link ie system dict 
238b 23				inc hl	 
238c			 
238c			;	ld (hl), sysdict		; next word link ie system dict 
238c			;	inc hl 
238c			;	inc hl 
238c			 
238c			;	inc hl 
238c			;	inc hl 
238c			 
238c			;	ld a, 2			; word length is 0 
238c 36 02			ld (hl), 2 
238e 23				inc hl 
238f			 
238f			;	ld a, '~'			; word length is 0 
238f 36 7e			ld (hl), '~' 
2391 23				inc hl 
2392			;	ld a, 0			; save empty word 
2392 36 00			ld (hl), 0 
2394			 
2394 c9				ret 
2395			 
2395				 
2395			 
2395			forthexec_cleanup: 
2395				FORTH_RSP_POP 
2395 cd da 1f			call macro_forth_rsp_pop 
2398				endm 
# End of macro FORTH_RSP_POP
2398 c9				ret 
2399			 
2399			forth_call_hl: 
2399				; taking hl 
2399 e5				push hl 
239a c9				ret 
239b			 
239b			; this is called to reset Forth system but keep existing uwords etc 
239b			 
239b			forth_warmstart: 
239b				; setup stack over/under flow checks 
239b				if DEBUG_FORTH_STACK_GUARD 
239b cd 69 75				call chk_stk_init 
239e				endif 
239e			 
239e				; init stack pointers  - * these stacks go upwards *  
239e 21 da f8			ld hl, cli_ret_stack 
23a1 22 20 f9			ld (cli_ret_sp), hl	 
23a4				; set bottom of stack 
23a4			;	ld a,0 
23a4 36 00			ld (hl),0 
23a6 23				inc hl 
23a7 36 00			ld (hl),0 
23a9			 
23a9 21 56 f6			ld hl, cli_data_stack 
23ac 22 1c f9			ld (cli_data_sp), hl	 
23af				; set bottom of stack 
23af			;	ld a,0 
23af 36 00			ld (hl),0 
23b1 23				inc hl 
23b2 36 00			ld (hl),0 
23b4			 
23b4 21 58 f8			ld hl, cli_loop_stack 
23b7 22 1e f9			ld (cli_loop_sp), hl	 
23ba				; set bottom of stack 
23ba			;	ld a,0 
23ba 36 00			ld (hl),0 
23bc 23				inc hl 
23bd 36 00			ld (hl),0 
23bf			 
23bf				; init extent of current open file 
23bf			 
23bf 3e 00			ld a, 0 
23c1 32 98 f9			ld (store_openext), a 
23c4			 
23c4 c9				ret 
23c5			 
23c5			 
23c5			 
23c5			; Cold Start - this is called to setup the whole Forth system 
23c5			 
23c5			forth_init: 
23c5			 
23c5				; setup stack over/under flow checks 
23c5			 
23c5			;	if DEBUG_FORTH_STACK_GUARD 
23c5			;		call chk_stk_init 
23c5			;	endif 
23c5			 
23c5				; enable auto display updates (slow.....) 
23c5			 
23c5 3e 01			ld a, 1 
23c7 32 6a f9			ld (cli_autodisplay), a 
23ca			 
23ca				; if storage is in use disable long reads for now 
23ca 3e 00			ld a, 0 
23cc 32 a3 f9			ld (store_longread), a 
23cf			 
23cf			 
23cf				; show start up screen 
23cf			 
23cf cd 81 0d			call clear_display 
23d2			 
23d2 3e 00			ld a,0 
23d4 32 8c f9			ld (f_cursor_ptr), a 
23d7			 
23d7				; set start of word list in start of ram - for use when creating user words 
23d7			 
23d7 21 00 80			ld hl, baseram 
23da 22 ec f3			ld (os_last_new_uword), hl 
23dd cd 82 23			call user_word_eol 
23e0				 
23e0			;		call display_data_sp 
23e0			;		call next_page_prompt 
23e0			 
23e0			 
23e0			 
23e0			 
23e0 c9				ret 
23e1			 
23e1 .. 00		.bootforth: db " Forth Kernel Init ",0 
23f5			 
23f5			; TODO push to stack 
23f5			 
23f5			;  
23f5			 
23f5			if FORTH_PARSEV2 
23f5			 
23f5			 
23f5				include "forth_parserv2.asm" 
23f5			 
23f5			endif 
23f5			 
23f5			 
23f5			; parse cli version 1 
23f5			 
23f5			if FORTH_PARSEV1 
23f5			 
23f5			 
23f5			 
23f5			      include "forth_parserv1.asm" 
23f5			endif 
23f5				 
23f5			if FORTH_PARSEV3 
23f5			      include "forth_parserv3.asm" 
23f5				include "forth_wordsv3.asm" 
23f5			endif 
23f5			 
23f5			if FORTH_PARSEV4 
23f5			      include "forth_parserv4.asm" 
23f5				include "forth_wordsv4.asm" 
23f5			endif 
23f5			 
23f5			if FORTH_PARSEV5 
23f5			      include "forth_parserv5.asm" 
23f5				include "forth_wordsv4.asm" 
23f5			endif 
23f5			 
23f5			if FORTH_PARSEV6 
23f5			      include "forth_parserv6.asm" 
23f5			 
23f5			 
23f5			; A better parser without using malloc and string copies all over the place.  
23f5			; Exec in situ should be faster 
23f5			 
23f5			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
23f5			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
23f5			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
23f5			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
23f5			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
23f5			WORD_SYS_END: equ 0   ; Opcode for all user words 
23f5			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
23f5			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
23f5			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
23f5			 
23f5			; Core word preamble macro 
23f5			 
23f5			CWHEAD:   macro nxtword opcode lit len opflags 
23f5				db WORD_SYS_CORE+opcode             
23f5				; internal op code number 
23f5				dw nxtword            
23f5				; link to next dict word block 
23f5				db len + 1 
23f5				; literal length of dict word inc zero term 
23f5				db lit,0              
23f5				; literal dict word 
23f5			        ; TODO db opflags        
23f5				endm 
23f5			 
23f5			 
23f5			NEXTW: macro  
23f5				call parse_vector 
23f5				jp macro_next 
23f5				endm 
23f5			 
23f5			macro_next: 
23f5			if DEBUG_FORTH_PARSE_EXEC 
23f5				DMARK "NXT" 
23f5				CALLMONITOR 
23f5			endif	 
23f5			;	inc hl  ; skip token null term  
23f5 ed 4b 6e f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
23f9 ed 5b 6c f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
23fd 2a f0 f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2400			if DEBUG_FORTH_PARSE_EXEC 
2400				DMARK "}AA" 
2400				CALLMONITOR 
2400			endif	 
2400 c3 e5 24			jp execnext 
2403				;jp exec1 
2403			       
2403			 
2403			 
2403			; Another go at the parser to compile  
2403			 
2403			 
2403			; TODO rework parser to change all of the string words to byte tokens 
2403			; TODO do a search for  
2403			 
2403			; TODO first run normal parser to zero term sections 
2403			; TODO for each word do a token look up to get the op code 
2403			; TODO need some means to flag to the exec that this is a byte code form    
2403			 
2403			 
2403			forthcompile: 
2403			 
2403			; 
2403			; line parse: 
2403			;       parse raw input buffer 
2403			;       tokenise the words 
2403			;       malloc new copy (for looping etc) 
2403			;       copy to malloc + current pc in line to start of string and add line term 
2403			;       save on new rsp 
2403			; 
2403			 
2403			; hl to point to the line to tokenise 
2403			 
2403			;	push hl 
2403 22 f0 f3			ld (os_tok_ptr), hl  ; save ptr to string 
2406			 
2406			;	ld a,0		; string term on input 
2406			;	call strlent 
2406			 
2406			;	ld (os_tok_len), hl	 ; save string length 
2406			 
2406			;if DEBUG_FORTH_TOK 
2406			;	ex de,hl		 
2406			;endif 
2406			 
2406			;	pop hl 		; get back string pointer 
2406			 
2406			if DEBUG_FORTH_TOK 
2406						DMARK "TOc" 
2406				CALLMONITOR 
2406			endif 
2406 7e			.cptoken2:    ld a,(hl) 
2407 23				inc hl 
2408 fe 7f			cp FORTH_END_BUFFER 
240a 28 26			jr z, .cptokendone2 
240c			;	cp 0 
240c b7				or a 
240d 28 23			jr z, .cptokendone2 
240f fe 22			cp '"' 
2411 28 0a			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2413 fe 20			cp ' ' 
2415 20 ef			jr nz,  .cptoken2 
2417			 
2417			; TODO consume comments held between ( and ) 
2417			 
2417				; we have a space so change to zero term for dict match later 
2417 2b				dec hl 
2418			;	ld a,0 
2418 36 00			ld (hl), 0 
241a 23				inc hl 
241b 18 e9			jr .cptoken2 
241d				 
241d			 
241d			.cptokenstr2: 
241d				; skip all white space until either eol (because forgot to term) or end double quote 
241d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
241d				;inc hl ; skip current double quote 
241d 7e				ld a,(hl) 
241e 23				inc hl 
241f fe 22			cp '"' 
2421 28 e3			jr z, .cptoken2 
2423 fe 7f			cp FORTH_END_BUFFER 
2425 28 0b			jr z, .cptokendone2 
2427			;	cp 0 
2427 b7				or a 
2428 28 08			jr z, .cptokendone2 
242a fe 20			cp ' ' 
242c 28 02			jr z, .cptmp2 
242e 18 ed			jr .cptokenstr2 
2430			 
2430			.cptmp2:	; we have a space so change to zero term for dict match later 
2430				;dec hl 
2430				;ld a,"-"	; TODO remove this when working 
2430				;ld (hl), a 
2430				;inc hl 
2430 18 eb			jr .cptokenstr2 
2432			 
2432			.cptokendone2: 
2432				;inc hl 
2432			;	ld a, FORTH_END_BUFFER 
2432 36 7f			ld (hl),FORTH_END_BUFFER 
2434			;	inc hl 
2434			;	ld a, '!' 
2434			;	ld (hl),a 
2434			 
2434 2a f0 f3			ld hl,(os_tok_ptr) 
2437			         
2437			if DEBUG_FORTH_TOK 
2437						DMARK "Tc1" 
2437				CALLMONITOR 
2437			endif 
2437			 
2437				; push exec string to top of return stack 
2437				FORTH_RSP_NEXT 
2437 cd b9 1f			call macro_forth_rsp_next 
243a				endm 
# End of macro FORTH_RSP_NEXT
243a c9				ret 
243b			 
243b			; Another go at the parser need to simplify the process 
243b			 
243b			forthparse: 
243b			 
243b			; 
243b			; line parse: 
243b			;       parse raw input buffer 
243b			;       tokenise the words 
243b			;       malloc new copy (for looping etc) 
243b			;       copy to malloc + current pc in line to start of string and add line term 
243b			;       save on new rsp 
243b			; 
243b			 
243b			; hl to point to the line to tokenise 
243b			 
243b			;	push hl 
243b 22 f0 f3			ld (os_tok_ptr), hl  ; save ptr to string 
243e			 
243e			;	ld a,0		; string term on input 
243e			;	call strlent 
243e			 
243e			;	ld (os_tok_len), hl	 ; save string length 
243e			 
243e			;if DEBUG_FORTH_TOK 
243e			;	ex de,hl		 
243e			;endif 
243e			 
243e			;	pop hl 		; get back string pointer 
243e			 
243e			if DEBUG_FORTH_TOK 
243e						DMARK "TOK" 
243e				CALLMONITOR 
243e			endif 
243e 7e			.ptoken2:    ld a,(hl) 
243f 23				inc hl 
2440 fe 7f			cp FORTH_END_BUFFER 
2442 28 26			jr z, .ptokendone2 
2444			;	cp 0 
2444 b7				or a 
2445 28 23			jr z, .ptokendone2 
2447 fe 22			cp '"' 
2449 28 0a			jr z, .ptokenstr2     ; will want to skip until end of string delim 
244b fe 20			cp ' ' 
244d 20 ef			jr nz,  .ptoken2 
244f			 
244f			; TODO consume comments held between ( and ) 
244f			 
244f				; we have a space so change to zero term for dict match later 
244f 2b				dec hl 
2450			;	ld a,0 
2450 36 00			ld (hl), 0 
2452 23				inc hl 
2453 18 e9			jr .ptoken2 
2455				 
2455			 
2455			.ptokenstr2: 
2455				; skip all white space until either eol (because forgot to term) or end double quote 
2455			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2455				;inc hl ; skip current double quote 
2455 7e				ld a,(hl) 
2456 23				inc hl 
2457 fe 22			cp '"' 
2459 28 e3			jr z, .ptoken2 
245b fe 7f			cp FORTH_END_BUFFER 
245d 28 0b			jr z, .ptokendone2 
245f			;	cp 0 
245f b7				or a 
2460 28 08			jr z, .ptokendone2 
2462 fe 20			cp ' ' 
2464 28 02			jr z, .ptmp2 
2466 18 ed			jr .ptokenstr2 
2468			 
2468			.ptmp2:	; we have a space so change to zero term for dict match later 
2468				;dec hl 
2468				;ld a,"-"	; TODO remove this when working 
2468				;ld (hl), a 
2468				;inc hl 
2468 18 eb			jr .ptokenstr2 
246a			 
246a			.ptokendone2: 
246a				;inc hl 
246a			;	ld a, FORTH_END_BUFFER 
246a 36 7f			ld (hl),FORTH_END_BUFFER 
246c			;	inc hl 
246c			;	ld a, '!' 
246c			;	ld (hl),a 
246c			 
246c 2a f0 f3			ld hl,(os_tok_ptr) 
246f			         
246f			if DEBUG_FORTH_TOK 
246f						DMARK "TK1" 
246f				CALLMONITOR 
246f			endif 
246f			 
246f				; push exec string to top of return stack 
246f				FORTH_RSP_NEXT 
246f cd b9 1f			call macro_forth_rsp_next 
2472				endm 
# End of macro FORTH_RSP_NEXT
2472 c9				ret 
2473			 
2473			; 
2473			;	; malloc size + buffer pointer + if is loop flag 
2473			;	ld hl,(os_tok_len) 		 ; get string length 
2473			; 
2473			;	ld a,l 
2473			; 
2473			;	cp 0			; we dont want to use a null string 
2473			;	ret z 
2473			; 
2473			;;	add 3    ; prefix malloc with buffer for current word ptr 
2473			; 
2473			;	add 5     ; TODO when certain not over writing memory remove 
2473			; 
2473			;		 
2473			; 
2473			;if DEBUG_FORTH_TOK 
2473			;			DMARK "TKE" 
2473			;	CALLMONITOR 
2473			;endif 
2473			; 
2473			;	ld l,a 
2473			;	ld h,0 
2473			;;	push hl   ; save required space for the copy later 
2473			;	call malloc 
2473			;if DEBUG_FORTH_TOK 
2473			;			DMARK "TKM" 
2473			;	CALLMONITOR 
2473			;endif 
2473			;	if DEBUG_FORTH_MALLOC_GUARD 
2473			;		push af 
2473			;		call ishlzero 
2473			;;		ld a, l 
2473			;;		add h 
2473			;;		cp 0 
2473			;		pop af 
2473			;		 
2473			;		call z,malloc_error 
2473			;	endif 
2473			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2473			; 
2473			; 
2473			;if DEBUG_FORTH_TOK 
2473			;			DMARK "TKR" 
2473			;	CALLMONITOR 
2473			;endif 
2473			; 
2473			;	FORTH_RSP_NEXT 
2473			; 
2473			;	;inc hl	 ; go past current buffer pointer 
2473			;	;inc hl 
2473			;	;inc hl   ; and past if loop flag 
2473			;		; TODO Need to set flag  
2473			; 
2473			;	 
2473			;	 
2473			;	ex de,hl	; malloc is dest 
2473			;	ld hl, (os_tok_len) 
2473			;;	pop bc 
2473			;	ld c, l                
2473			;	ld b,0 
2473			;	ld hl, (os_tok_ptr) 
2473			; 
2473			;if DEBUG_FORTH_TOK 
2473			;			DMARK "TKT" 
2473			;	CALLMONITOR 
2473			;endif 
2473			; 
2473			;	; do str cpy 
2473			; 
2473			;	ldir      ; copy byte in hl to de 
2473			; 
2473			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2473			; 
2473			;if DEBUG_FORTH_TOK 
2473			; 
2473			;			DMARK "TKY" 
2473			;	CALLMONITOR 
2473			;endif 
2473			;	;ld a,0 
2473			;	;ld a,FORTH_END_BUFFER 
2473			;	ex de, hl 
2473			;	;dec hl			 ; go back over the space delim at the end of word 
2473			;	;ld (hl),a 
2473			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2473			;	ld a,FORTH_END_BUFFER 
2473			;	ld (hl),a 
2473			;	inc hl 
2473			;	ld a,FORTH_END_BUFFER 
2473			;	ld (hl),a 
2473			; 
2473			;	; init the malloc area data 
2473			;	; set pc for in current area 
2473			;	;ld hl, (os_tok_malloc) 
2473			;	;inc hl 
2473			;	;inc hl 
2473			;	;inc hl 
2473			;	;ex de,hl 
2473			;	;ld hl, (os_tok_malloc) 
2473			;	;ld (hl),e 
2473			;	;inc hl 
2473			;	;ld (hl),d 
2473			; 
2473			; 
2473			;	ld hl,(os_tok_malloc) 
2473			;if DEBUG_FORTH_PARSE_KEY 
2473			;			DMARK "TKU" 
2473			;	CALLMONITOR 
2473			;endif 
2473			; 
2473			;	ret 
2473			 
2473			forthexec: 
2473			 
2473			; line exec: 
2473			; forth parser 
2473			 
2473			; 
2473			;       get current exec line on rsp 
2473			 
2473				FORTH_RSP_TOS 
2473 cd d0 1f			call macro_forth_rsp_tos 
2476				endm 
# End of macro FORTH_RSP_TOS
2476			 
2476			;       restore current pc - hl points to malloc of data 
2476			 
2476				;ld e, (hl) 
2476				;inc hl 
2476				;ld d, (hl) 
2476				;ex de,hl 
2476			 
2476			 
2476			exec1: 
2476 22 f0 f3			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
2479			 
2479				; copy our PC to working vars  
2479 22 6e f9			ld (cli_ptr), hl                    ; here 
247c 22 6c f9			ld (cli_origptr), hl                ; here 
247f			 
247f 7e				ld a,(hl)                           ; here make hl be the ram ptr 
2480 fe 7f			cp FORTH_END_BUFFER 
2482 c8				ret z 
2483			 
2483				; skip any nulls 
2483			 
2483			;	cp 0 
2483 b7				or a 
2484 20 03			jr nz, .execword 
2486 23				inc hl 
2487 18 ed			jr exec1 
2489			 
2489			 
2489			.execword: 
2489			 
2489			 
2489			 
2489			if DEBUG_FORTH_PARSE_EXEC 
2489						DMARK "KYQ" 
2489				CALLMONITOR 
2489			endif 
2489			;       while at start of word: 
2489			; get start of dict (in user area first) 
2489			 
2489 21 00 80		ld hl, baseram 
248c			;ld hl, sysdict 
248c 22 70 f9		ld (cli_nextword),hl                            ; here do we need to do this? 
248f			;           match word at pc 
248f			;           exec word 
248f			;           or push to dsp 
248f			;           forward to next token 
248f			;           if line term pop rsp and exit 
248f			;        
248f			 
248f			if DEBUG_FORTH_PARSE_EXEC 
248f						DMARK "KYq" 
248f				CALLMONITOR 
248f			endif 
248f			 
248f			; 
248f			; word comp 
248f			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
248f			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
248f			;    move to start of word  
248f			;    compare word to cli_token 
248f			 
248f			.execpnword:	; HL at start of a word in the dictionary to check 
248f			 
248f 2a 70 f9			ld hl,(cli_nextword)                  ; here remove the need to store???? 
2492			 
2492 cd 27 25			call forth_tok_next 
2495			; tok next end here 
2495 22 70 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
2498 eb				ex de, hl 
2499			 
2499			 
2499				; save the pointer of the current token - 1 to check against 
2499				 
2499 22 74 f9			ld (cli_token), hl   
249c				; TODO maybe remove below save if no debug 
249c				; save token string ptr for any debug later 
249c 23				inc hl  
249d 22 76 f9			ld (cli_origtoken), hl 
24a0 2b				dec hl 
24a1				; save pointer to the start of the next dictionay word 
24a1 7e				ld a,(hl)   ; get string length 
24a2			;	ld b,a 
24a2			;.execpnwordinc:  
24a2			;	inc hl 
24a2			;	djnz .execpnwordinc 
24a2 06 00			ld b, 0 
24a4 4f				ld c, a 
24a5 09				add hl, bc 
24a6 22 72 f9			ld (cli_execword), hl      ; save start of this words code 
24a9			 
24a9				; now check the word token against the string being parsed 
24a9			 
24a9 2a 74 f9			ld hl,(cli_token) 
24ac 23				inc hl     ; skip string length (use zero term instead to end) 
24ad				;ld (cli_token), hl 
24ad			 
24ad			.execpnchar:    ; compare char between token and string to parse 
24ad			 
24ad			 
24ad				;ld hl, (cli_token)     ; the dict word  
24ad ed 5b 6e f9		ld de, (cli_ptr)     ; cli to parse 
24b1			 
24b1			 
24b1			.execpncharl:    ; compare char between token and string to parse (loop) 
24b1			 
24b1 1a				ld a,(de) 
24b2 cd 00 13			call toUpper 		; make sure the input string matches case 
24b5 be				cp (hl) 
24b6			 
24b6 c2 ce 24			jp nz, .execpnskipword	 ; no match so move to next word 
24b9				 
24b9			;    if same 
24b9			;       scan for string terms 0 for token and 32 for input 
24b9 46				ld b,(hl) 
24ba 80				add b			 
24bb 23				inc hl 
24bc 13				inc de 
24bd b7				or a 
24be			;	cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
24be							; TODO need to make sure last word in zero term string is accounted for 
24be 20 f1			jr nz, .execpncharl 		 ; not at end of strings yet 
24c0			 
24c0			 
24c0				; at end of both strings so both are exact match 
24c0			 
24c0			;       skip ptr for next word 
24c0			 
24c0 2a 6e f9			ld hl,(cli_ptr) 	; at input string term 
24c3 23				inc hl			 ; at next char 
24c4 22 6e f9			ld (cli_ptr), hl     ; save for next round of the parser 
24c7 22 6c f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
24ca				 
24ca				 
24ca			 
24ca			 
24ca			 
24ca			;       exec code block 
24ca			if DEBUG_FORTH_JP 
24ca				call clear_display 
24ca				call update_display 
24ca				call delay1s 
24ca				ld hl, (cli_execword)     ; save for next check if no match on this word 
24ca				ld a,h 
24ca				ld hl, os_word_scratch 
24ca				call hexout 
24ca				ld hl, (cli_execword)     ; save for next check if no match on this word 
24ca				ld a,l 
24ca				ld hl, os_word_scratch+2 
24ca				call hexout 
24ca				ld hl, os_word_scratch+4 
24ca			;	ld a,0 
24ca				ld (hl),0 
24ca				ld de,os_word_scratch 
24ca				call str_at_display 
24ca					ld a, display_row_2 
24ca					call str_at_display 
24ca				ld de, (cli_origtoken) 
24ca				ld a, display_row_1+10 
24ca					call str_at_display 
24ca			 
24ca				ld a,display_row_1 
24ca				ld de, .foundword 
24ca				ld a, display_row_3 
24ca				call str_at_display 
24ca				call update_display 
24ca				call delay1s 
24ca				call delay1s 
24ca				call delay1s 
24ca			endif 
24ca			 
24ca			if DEBUG_FORTH_PARSE_EXEC 
24ca						DMARK "KYj" 
24ca			endif 
24ca				; TODO save the word pointer in this exec 
24ca			 
24ca 2a 72 f9			ld hl,(cli_execword) 
24cd e9				jp (hl) 
24ce			 
24ce			 
24ce			;    if not same 
24ce			;	scan for zero term 
24ce			;	get ptr for next word 
24ce			;	goto word comp 
24ce			 
24ce			.execpnskipword:	; get pointer to next word 
24ce 2a 70 f9			ld hl,(cli_nextword) 
24d1			 
24d1 7e				ld a,(hl) 
24d2 fe 00			cp WORD_SYS_END 
24d4			;	cp 0 
24d4 28 09			jr z, .execendofdict			 ; at end of words 
24d6			 
24d6			if DEBUG_FORTH_PARSE_EXEC 
24d6						DMARK "KY4" 
24d6			endif 
24d6			if DEBUG_FORTH_PARSE_EXEC 
24d6			 
24d6				; see if disabled 
24d6			 
24d6			;	ld a, (os_view_disable) 
24d6			;	cp '*' 
24d6				ld a,(debug_vector) 
24d6				cp $c9   ; RET 
24d6				jr z, .noskip 
24d6			 
24d6			 
24d6				ld de, .nowordfound 
24d6				ld a, display_row_3 
24d6				call str_at_display 
24d6				call update_display 
24d6				ld a, 100 
24d6				call aDelayInMS 
24d6				 
24d6				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24d6					call delay250ms 
24d6				endif 
24d6			.noskip:  
24d6			 
24d6			endif	 
24d6			 
24d6 2a 6c f9			ld hl,(cli_origptr) 
24d9 22 6e f9			ld (cli_ptr),hl 
24dc			 
24dc			if DEBUG_FORTH_PARSE_EXEC 
24dc						DMARK "KY5" 
24dc			endif 
24dc c3 8f 24			jp .execpnword			; else go to next word 
24df			 
24df			.execendofdict:  
24df			 
24df			if DEBUG_FORTH_PARSE_EXEC 
24df						DMARK "KYe" 
24df			endif 
24df			if DEBUG_FORTH_PARSE_EXEC 
24df				; see if disabled 
24df			 
24df			;	ld a, (os_view_disable) 
24df			;	cp '*' 
24df				ld a,(debug_vector) 
24df				cp $c9   ; ret 
24df				jr z, .ispskip 
24df			 
24df				call clear_display 
24df				call update_display 
24df				call delay1s 
24df				ld de, (cli_origptr) 
24df				ld a, display_row_1 
24df				call str_at_display 
24df				 
24df				ld de, .enddict 
24df				ld a, display_row_3 
24df				call str_at_display 
24df				call update_display 
24df				ld a, 100 
24df				call aDelayInMS 
24df				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24df				call delay1s 
24df				call delay1s 
24df				call delay1s 
24df				endif 
24df			.ispskip:  
24df				 
24df			endif	 
24df			 
24df			 
24df			 
24df				; if the word is not a keyword then must be a literal so push it to stack 
24df			 
24df			; push token to stack to end of word 
24df			 
24df				STACKFRAME ON $1efe $2f9f 
24df				if DEBUG_STACK_IMB 
24df					if ON 
24df						exx 
24df						ld de, $1efe 
24df						ld a, d 
24df						ld hl, curframe 
24df						call hexout 
24df						ld a, e 
24df						ld hl, curframe+2 
24df						call hexout 
24df						ld hl, $1efe 
24df						push hl 
24df						ld hl, $2f9f 
24df						push hl 
24df						exx 
24df					endif 
24df				endif 
24df			endm 
# End of macro STACKFRAME
24df			 
24df 2a f0 f3		ld hl,(os_tok_ptr) 
24e2 cd 74 21		call forth_apush 
24e5			 
24e5				STACKFRAMECHK ON $1efe $2f9f 
24e5				if DEBUG_STACK_IMB 
24e5					if ON 
24e5						exx 
24e5						ld hl, $2f9f 
24e5						pop de   ; $2f9f 
24e5						call cmp16 
24e5						jr nz, .spnosame 
24e5						ld hl, $1efe 
24e5						pop de   ; $1efe 
24e5						call cmp16 
24e5						jr z, .spfrsame 
24e5						.spnosame: call showsperror 
24e5						.spfrsame: nop 
24e5						exx 
24e5					endif 
24e5				endif 
24e5			endm 
# End of macro STACKFRAMECHK
24e5			 
24e5			execnext: 
24e5			 
24e5			if DEBUG_FORTH_PARSE_EXEC 
24e5						DMARK "KY>" 
24e5			endif 
24e5			; move past token to next word 
24e5			 
24e5 2a f0 f3		ld hl, (os_tok_ptr) 
24e8 3e 00		ld a, 0 
24ea 01 ff 00		ld bc, 255     ; input buffer size 
24ed ed b1		cpir 
24ef			 
24ef			if DEBUG_FORTH_PARSE_EXEC 
24ef						DMARK "KY!" 
24ef				CALLMONITOR 
24ef			endif	 
24ef			; TODO this might place hl on the null, so will need to forward on??? 
24ef			;inc hl   ; see if this gets onto the next item 
24ef			 
24ef			 
24ef			; TODO pass a pointer to the buffer to push 
24ef			; TODO call function to push 
24ef			 
24ef			; look for end of input 
24ef			 
24ef			;inc hl 
24ef			;ld a,(hl) 
24ef			;cp FORTH_END_BUFFER 
24ef			;ret z 
24ef			 
24ef			 
24ef c3 76 24		jp exec1 
24f2			 
24f2			 
24f2			 
24f2			 
24f2			 
24f2			 
24f2			 
24f2			 
24f2			 
24f2			findnexttok: 
24f2			 
24f2				; hl is pointer to move 
24f2				; de is the token to locate 
24f2			 
24f2					if DEBUG_FORTH 
24f2						DMARK "NTK" 
24f2						CALLMONITOR 
24f2					endif 
24f2 d5				push de 
24f3			 
24f3			.fnt1:	 
24f3				; find first char of token to locate 
24f3			 
24f3 1a				ld a, (de) 
24f4 4f				ld c,a 
24f5 7e				ld a,(hl) 
24f6 cd 00 13			call toUpper 
24f9					if DEBUG_FORTH 
24f9						DMARK "NT1" 
24f9						CALLMONITOR 
24f9					endif 
24f9 b9				cp c 
24fa			 
24fa 28 03			jr z, .fnt2cmpmorefirst	 
24fc			 
24fc				; first char not found move to next char 
24fc			 
24fc 23				inc hl 
24fd 18 f4			jr .fnt1 
24ff			 
24ff			.fnt2cmpmorefirst:	 
24ff				; first char of token found.  
24ff			 
24ff e5				push hl     ; save start of token just in case it is the right one 
2500 d9				exx 
2501 e1				pop hl        ; save it to hl' 
2502 d9				exx 
2503			 
2503			 
2503			.fnt2cmpmore:	 
2503				; compare the rest 
2503				 
2503 23				inc hl 
2504 13				inc de 
2505				 
2505 1a				ld a, (de) 
2506 4f				ld c,a 
2507 7e				ld a,(hl) 
2508 cd 00 13			call toUpper 
250b			 
250b					if DEBUG_FORTH 
250b						DMARK "NT2" 
250b						CALLMONITOR 
250b					endif 
250b				; c has the token to find char 
250b				; a has the mem to scan char 
250b			 
250b b9				cp c 
250c 28 04			jr z,.fntmatch1 
250e			 
250e				; they are not the same 
250e			 
250e					if DEBUG_FORTH 
250e						DMARK "NT3" 
250e						CALLMONITOR 
250e					endif 
250e d1				pop de	; reset de token to look for 
250f d5				push de 
2510 18 e1			jr .fnt1 
2512				 
2512			.fntmatch1: 
2512			 
2512				; is the same char a null which means we might have a full hit? 
2512					if DEBUG_FORTH 
2512						DMARK "NT4" 
2512						CALLMONITOR 
2512					endif 
2512			 
2512			;	cp 0 
2512 b7				or a 
2513 28 0b			jr z, .fntmatchyes 
2515			 
2515				; are we at the end of the token to find? 
2515			 
2515					if DEBUG_FORTH 
2515						DMARK "NT5" 
2515						CALLMONITOR 
2515					endif 
2515 3e 00			ld a, 0 
2517 b9				cp c 
2518			 
2518 c2 03 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
251b			 
251b					if DEBUG_FORTH 
251b						DMARK "NT6" 
251b						CALLMONITOR 
251b					endif 
251b				; token to find is exhusted but no match to stream 
251b			 
251b				; restore tok pointer and continue on 
251b d1				pop de 
251c d5				push de 
251d c3 f3 24			jp .fnt1 
2520			 
2520			 
2520			.fntmatchyes: 
2520			 
2520				; hl now contains the end of the found token 
2520			 
2520				; get rid of saved token pointer to find 
2520			 
2520 d1				pop de 
2521			 
2521					if DEBUG_FORTH 
2521						DMARK "NT9" 
2521						CALLMONITOR 
2521					endif 
2521			 
2521				; hl will be on the null term so forward on 
2521			 
2521				; get back the saved start of the token 
2521			 
2521 d9				exx 
2522 e5				push hl     ; save start of token just in case it is the right one 
2523 d9				exx 
2524 e1				pop hl        ; save it to hl 
2525			 
2525 c9				ret 
2526			 
2526			 
2526			; LIST needs to find a specific token   
2526			; FORGET needs to find a spefici token 
2526			 
2526			; SAVE needs to find all tokens by flag 
2526			; WORDS just needs to scan through all  by flag 
2526			; UWORDS needs to scan through all by flag 
2526			 
2526			 
2526			; given hl as pointer to start of dict look up string 
2526			; return hl as pointer to start of word block 
2526			; or 0 if not found 
2526			 
2526			forth_find_tok: 
2526 c9				ret 
2527			 
2527			; given hl as pointer to dict structure 
2527			; move to the next dict block structure 
2527			 
2527			forth_tok_next: 
2527				; hl now points to the address of the next word pointer  
2527				; TODO skip compiled symbol for now 
2527			;	push de 
2527 23				inc hl 
2528 5e				ld e, (hl) 
2529 23				inc hl 
252a 56				ld d, (hl) 
252b 23				inc hl 
252c			 
252c eb				ex de,hl 
252d			if DEBUG_FORTH_PARSE_NEXTWORD 
252d				push bc 
252d				ld bc, (cli_nextword) 
252d						DMARK "NXW" 
252d				CALLMONITOR 
252d				pop bc 
252d			endif 
252d			;	pop de	 
252d c9				ret 
252e			 
252e			 
252e			 
252e			; eof 
# End of file forth_parserv6.asm
252e				include "forth_wordsv4.asm" 
252e			 
252e			; the core word dictionary v4 
252e			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
252e			 
252e			; this is a linked list for each of the system words used 
252e			; user defined words will follow the same format but will be in ram 
252e			 
252e			 
252e			; 
252e			; 
252e			; define linked list: 
252e			; 
252e			; 1. compiled byte op code 
252e			; 2. len of text word 
252e			; 3. text word 
252e			; 4. ptr to next dictionary word 
252e			; 5. asm, calls etc for the word 
252e			; 
252e			;  if 1 == 0 then last word in dict  
252e			;   
252e			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
252e			;  
252e			;  
252e			; create basic standard set of words 
252e			; 
252e			;  
252e			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
252e			; 2DUP 2DROP 2SWAP  
252e			; @ C@ - get byte  
252e			; ! C! - store byte 
252e			; 0< true if less than zero 
252e			; 0= true if zero 
252e			; < >  
252e			; = true if same 
252e			; variables 
252e			 
252e			 
252e			; Hardware specific words I may need 
252e			; 
252e			; IN OUT  
252e			; calls to key util functions 
252e			; calls to hardward abstraction stuff 
252e			; easy control of frame buffers and lcd i/o 
252e			; keyboard  
252e			 
252e			 
252e			;DICT: macro 
252e			; op_code, len, word, next 
252e			;    word: 
252e			;    db op_code 
252e			;    ds word zero term 
252e			;    dw next 
252e			;    endm 
252e			 
252e			 
252e			 
252e			 
252e			; op code 1 is a flag for user define words which are to be handled differently 
252e			 
252e			 
252e			; 
252e			; 
252e			;    TODO on entry to a word this should be the expected environment 
252e			;    hl - tos value if number then held, if string this is the ptr 
252e			;    de -  
252e			 
252e			 
252e			; opcode ranges 
252e			; 0 - end of word dict 
252e			; 255 - user define words 
252e			 
252e			sysdict: 
252e			include "forth_opcodes.asm" 
252e			; op codes for forth keywords 
252e			 
252e			; Changing use of opcodes to flag is the word exists in compiled form or not.  
252e			; This provides a means to compile uwords if required for higher performance 
252e			; by avoiding the use of the keyword parser and just jumping directly to the code 
252e			; Actually there is already a flag for if the code exists as binary thinking about it... 
252e			 
252e			 
252e			 
252e			 
252e			 
252e			; free to use code 0  
252e				OPCODE_HEAP: equ  1 
252e				OPCODE_EXEC: equ 2 
252e				OPCODE_DUP: equ 3 
252e				OPCODE_SWAP: equ 4 
252e				OPCODE_COLN: equ 5 
252e				OPCODE_SCOLN: equ 6 
252e				OPCODE_DROP: equ 7 
252e				OPCODE_DUP2: equ 8 
252e				OPCODE_DROP2: equ 9 
252e				OPCODE_SWAP2: equ 10 
252e				OPCODE_AT: equ 11 
252e				OPCODE_CAT: equ 12 
252e				OPCODE_BANG: equ 13 
252e				OPCODE_CBANG: equ 14 
252e				OPCODE_SCALL: equ 15 
252e				OPCODE_DEPTH: equ 16 
252e				OPCODE_OVER: equ 17 
252e				OPCODE_PAUSE: equ 18 
252e				OPCODE_PAUSES: equ 19 
252e				OPCODE_ROT: equ 20 
252e			;free to reuse	OPCODE_WORDS: equ 21 
252e			        OPCODE_NOT: equ 21 
252e				OPCODE_UWORDS: equ 22 
252e				OPCODE_BP: equ 23 
252e				OPCODE_MONITOR: equ 24  
252e				OPCODE_MALLOC: equ 25 
252e				OPCODE_FREE: equ 26 
252e				OPCODE_LIST: equ 27 
252e				OPCODE_FORGET: equ 28 
252e				OPCODE_NOP: equ 29 
252e				OPCODE_COMO: equ 30 
252e				OPCODE_COMC: equ 31 
252e			;free to reuse	OPCODE_ENDCORE: equ 32 
252e				OPCODE_AFTERSOUND: equ 33 
252e				OPCODE_GP2: equ 34 
252e				OPCODE_GP3: equ 35 
252e				OPCODE_GP4: equ 36 
252e				OPCODE_SIN: equ 37 
252e				OPCODE_SOUT: equ 38 
252e				OPCODE_SPIO: equ 39 
252e				OPCODE_SPICEH: equ 40 
252e				OPCODE_SPIOb: equ 41 
252e				OPCODE_SPII: equ 42 
252e				OPCODE_SESEL: equ 43 
252e				OPCODE_CARTDEV: equ 44 
252e			; free to reuse	OPCODE_ENDDEVICE: equ 45 
252e				OPCODE_FB: equ 46 
252e				OPCODE_EMIT: equ 47 
252e				OPCODE_DOTH: equ 48 
252e				OPCODE_DOTF: equ 49 
252e				OPCODE_DOT: equ 50 
252e				OPCODE_CLS: equ 51 
252e				OPCODE_DRAW: equ 52 
252e				OPCODE_DUMP: equ 53 
252e				OPCODE_CDUMP: equ 54 
252e				OPCODE_DAT: equ 55 
252e				OPCODE_HOME: equ 56 
252e				OPCODE_SPACE: equ 57 
252e				OPCODE_SPACES: equ 58 
252e				OPCODE_SCROLL: equ 59 
252e				OPCODE_ATQ: equ 60 
252e				OPCODE_AUTODSP: equ 61 
252e				OPCODE_MENU: equ 62 
252e			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
252e				OPCODE_THEN: equ 64 
252e				OPCODE_ELSE: equ 65 
252e				OPCODE_DO: equ 66 
252e				OPCODE_LOOP: equ 67 
252e				OPCODE_I: equ 68 
252e				OPCODE_DLOOP: equ 69  
252e				OPCODE_REPEAT: equ 70  
252e				OPCODE_UNTIL: equ 71 
252e				OPCODE_ENDFLOW: equ 72 
252e				OPCODE_WAITK: equ 73 
252e				OPCODE_ACCEPT: equ 74 
252e				OPCODE_EDIT: equ 75 
252e			;free to reuse	OPCODE_ENDKEY: equ 76 
252e				OPCODE_LZERO: equ 77 
252e				OPCODE_TZERO: equ 78 
252e				OPCODE_LESS: equ 79 
252e				OPCODE_GT: equ 80 
252e				OPCODE_EQUAL: equ 81  
252e			;free to reuse	OPCODE_ENDLOGIC: equ 82 
252e				OPCODE_NEG: equ 83 
252e				OPCODE_DIV: equ 84 
252e				OPCODE_MUL: equ 85 
252e				OPCODE_MIN: equ 86 
252e				OPCODE_MAX: equ 87 
252e				OPCODE_RND16: equ 88 
252e				OPCODE_RND8: equ 89 
252e				OPCODE_RND: equ 90 
252e			;free to reuse	OPCODE_ENDMATHS: equ 91  
252e				OPCODE_BYNAME: equ 92 
252e				OPCODE_DIR: equ 93 
252e				OPCODE_SAVE: equ 94 
252e				OPCODE_LOAD: equ 95 
252e				OPCODE_BSAVE: equ 96 
252e				OPCODE_BLOAD: equ 97 
252e				OPCODE_SEO: equ 98  
252e				OPCODE_SEI: equ 99 
252e				OPCODE_SFREE: equ 100 
252e				OPCODE_SIZE: equ 101 
252e				OPCODE_CREATE: equ 102 
252e				OPCODE_APPEND: equ 103 
252e				OPCODE_SDEL: equ 104 
252e				OPCODE_OPEN: equ 105 
252e				OPCODE_READ: equ 106 
252e				OPCODE_EOF: equ 106 
252e				OPCODE_FORMAT: equ 107 
252e				OPCODE_LABEL: equ 108 
252e				OPCODE_LABELS: equ 109 
252e			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
252e				OPCODE_UPPER: equ 111 
252e				OPCODE_LOWER: equ 112 
252e				OPCODE_SUBSTR: equ 113 
252e				OPCODE_LEFT: equ 114 
252e				OPCODE_RIGHT: equ 115 
252e				OPCODE_STR2NUM: equ 116 
252e				OPCODE_NUM2STR: equ 117 
252e				OPCODE_CONCAT: equ 118 
252e				OPCODE_FIND: equ 119 
252e				OPCODE_LEN: equ 120 
252e				OPCODE_CHAR: equ 121 
252e			; free to reuse	OPCODE_STRLEN: equ 122 
252e			; free to reuse	OPCODE_ENDSTR: equ 123 
252e				OPCODE_V0S: equ 124 
252e				OPCODE_V0Q: equ 125 
252e				OPCODE_V1S: equ 126 
252e				OPCODE_V1Q: equ 127 
252e				OPCODE_V2S: equ 128 
252e				OPCODE_V2Q: equ 129 
252e				OPCODE_V3S: equ 130 
252e				OPCODE_V3Q: equ 131 
252e			;free to reuse	OPCODE_END: equ 132 
252e				OPCODE_ZDUP: equ 133 
252e			 
252e			; eof 
# End of file forth_opcodes.asm
252e			 
252e			include "forth_words_core.asm" 
252e			 
252e			; | ## Core Words 
252e			 
252e			;if MALLOC_4 
252e			 
252e			.HEAP: 
252e			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
252e 15				db WORD_SYS_CORE+OPCODE_HEAP             
252f 70 25			dw .EXEC            
2531 05				db 4 + 1 
2532 .. 00			db "HEAP",0              
2537				endm 
# End of macro CWHEAD
2537			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2537			; | | u1 - Current number of bytes in the heap 
2537			; | | u2 - Remaining bytes left on the heap 
2537			; | |  
2537			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2537			 
2537			 
2537				if DEBUG_FORTH_WORDS_KEY 
2537					DMARK "HEP" 
2537 f5				push af  
2538 3a 4c 25			ld a, (.dmark)  
253b 32 99 fd			ld (debug_mark),a  
253e 3a 4d 25			ld a, (.dmark+1)  
2541 32 9a fd			ld (debug_mark+1),a  
2544 3a 4e 25			ld a, (.dmark+2)  
2547 32 9b fd			ld (debug_mark+2),a  
254a 18 03			jr .pastdmark  
254c ..			.dmark: db "HEP"  
254f f1			.pastdmark: pop af  
2550			endm  
# End of macro DMARK
2550					CALLMONITOR 
2550 cd a6 fd			call debug_vector  
2553				endm  
# End of macro CALLMONITOR
2553				endif 
2553 2a 0a 80			ld hl, (free_list )      
2556 11 0e 80			ld de, heap_start 
2559			 
2559 ed 52			sbc hl, de  
255b			 
255b cd 12 20			call forth_push_numhl 
255e			 
255e			 
255e ed 5b 0a 80		ld de, (free_list )      
2562 21 ca f0			ld hl, heap_end 
2565			 
2565 ed 52			sbc hl, de 
2567			 
2567 cd 12 20			call forth_push_numhl 
256a				 
256a			 
256a				 
256a			 
256a			 
256a			 
256a				NEXTW 
256a cd a3 fd			call parse_vector 
256d c3 f5 23			jp macro_next 
2570				endm 
# End of macro NEXTW
2570			;endif 
2570			 
2570			.EXEC: 
2570			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2570			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2570			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2570			;; > > 
2570			;; > >   
2570			;	STACKFRAME OFF $5efe $5f9f 
2570			; 
2570			;		if DEBUG_FORTH_WORDS_KEY 
2570			;			DMARK "EXE" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			; 
2570			;	FORTH_DSP_VALUEHL 
2570			; 
2570			;	FORTH_DSP_POP 
2570			; 
2570			;		if DEBUG_FORTH_WORDS 
2570			;			DMARK "EX1" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			;;	ld e,(hl) 
2570			;;	inc hl 
2570			;;	ld d,(hl) 
2570			;;	ex de,hl 
2570			; 
2570			;;		if DEBUG_FORTH_WORDS 
2570			;;			DMARK "EX2" 
2570			;;			CALLMONITOR 
2570			;;		endif 
2570			;	push hl 
2570			; 
2570			;	;ld a, 0 
2570			;	;ld a, FORTH_END_BUFFER 
2570			;	call strlenz 
2570			;	inc hl   ; include zero term to copy 
2570			;	inc hl   ; include term 
2570			;	inc hl   ; include term 
2570			;	ld b,0 
2570			;	ld c,l 
2570			;	pop hl 
2570			;	ld de, execscratch 
2570			;		if DEBUG_FORTH_WORDS 
2570			;			DMARK "EX3" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			;	ldir 
2570			; 
2570			; 
2570			;	ld hl, execscratch 
2570			; 
2570			;		if DEBUG_FORTH_WORDS 
2570			;			DMARK "EXe" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			; 
2570			;	call forthparse 
2570			;	call forthexec 
2570			;;	call forthexec_cleanup 
2570			;;	call forthparse 
2570			;;	call forthexec 
2570			; 
2570			;	STACKFRAMECHK OFF $5efe $5f9f 
2570			; 
2570			;	; an immediate word so no need to process any more words 
2570			;	ret 
2570			;	NEXTW 
2570			 
2570			; dead code - old version  
2570			;	FORTH_RSP_NEXT 
2570			 
2570			;  
2570			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2570			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2570			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2570			;	push hl 
2570			;	push de 
2570			;	push bc 
2570			; 
2570			; 
2570			;		if DEBUG_FORTH_WORDS_KEY 
2570			;			DMARK "EXR" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			; 
2570			; 
2570			; 
2570			;	;v5 FORTH_DSP_VALUE 
2570			;	FORTH_DSP_VALUEHL 
2570			; 
2570			;	; TODO do string type checks 
2570			; 
2570			;;v5	inc hl   ; skip type 
2570			; 
2570			;	push hl  ; source code  
2570			;		if DEBUG_FORTH_WORDS 
2570			;			DMARK "EX1" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			;	ld a, 0 
2570			;	call strlent 
2570			; 
2570			;	inc hl 
2570			;	inc hl 
2570			;	inc hl 
2570			;	inc hl 
2570			; 
2570			;	push hl    ; size 
2570			; 
2570			;		if DEBUG_FORTH_WORDS 
2570			;			DMARK "EX2" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			;	call malloc 
2570			; 
2570			;	ex de, hl    ; de now contains malloc area 
2570			;	pop bc   	; get byte count 
2570			;	pop hl      ; get string to copy 
2570			; 
2570			;	push de     ; save malloc for free later 
2570			; 
2570			;		if DEBUG_FORTH_WORDS 
2570			;			DMARK "EX3" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			;	ldir       ; duplicate string 
2570			; 
2570			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2570			;	 
2570			;	; TODO fix the parse would be better than this...  
2570			;	ex de, hl 
2570			;	dec hl 
2570			;	ld a, 0 
2570			;	ld (hl), a 
2570			;	dec hl 
2570			;	ld a, ' ' 
2570			;	ld (hl), a 
2570			;	dec hl 
2570			;	ld (hl), a 
2570			; 
2570			;	dec hl 
2570			;	ld (hl), a 
2570			; 
2570			; 
2570			;	FORTH_DSP_POP  
2570			; 
2570			;	pop hl     
2570			;	push hl    ; save malloc area 
2570			; 
2570			;		if DEBUG_FORTH_WORDS 
2570			;			DMARK "EX4" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			; 
2570			;	call forthparse 
2570			;	call forthexec 
2570			;	 
2570			;	pop hl 
2570			;	if DEBUG_FORTH_WORDS 
2570			;		DMARK "EX5" 
2570			;		CALLMONITOR 
2570			;	endif 
2570			; 
2570			;	if FORTH_ENABLE_FREE 
2570			;	call free 
2570			;	endif 
2570			; 
2570			;	if DEBUG_FORTH_WORDS 
2570			;		DMARK "EX6" 
2570			;		CALLMONITOR 
2570			;	endif 
2570			; 
2570			;	pop bc 
2570			;	pop de 
2570			;	pop hl 
2570			;;	FORTH_RSP_POP	  
2570			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2570			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2570			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2570			; 
2570			;	if DEBUG_FORTH_WORDS 
2570			;		DMARK "EX7" 
2570			;		CALLMONITOR 
2570			;	endif 
2570			;	NEXTW 
2570			 
2570			;.STKEXEC: 
2570			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2570			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2570			; 
2570			; 
2570			;		if DEBUG_FORTH_WORDS_KEY 
2570			;			DMARK "STX" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			; 
2570			;	FORTH_DSP_VALUEHL 
2570			; 
2570			;	ld (store_tmp1), hl    ; count 
2570			; 
2570			;	FORTH_DSP_POP 
2570			;.stkexec1: 
2570			;	ld hl, (store_tmp1)   ; count 
2570			;	ld a, 0 
2570			;	cp l 
2570			;	ret z 
2570			; 
2570			;	dec hl 
2570			;	ld (store_tmp1), hl    ; count 
2570			;	 
2570			;	FORTH_DSP_VALUEHL 
2570			;	push hl 
2570			;	 
2570			;		if DEBUG_FORTH_WORDS 
2570			;			DMARK "EXp" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			;	FORTH_DSP_POP 
2570			; 
2570			;	call strlenz 
2570			;	inc hl   ; include zero term to copy 
2570			;	inc hl   ; include zero term to copy 
2570			;	inc hl   ; include zero term to copy 
2570			;	ld b,0 
2570			;	ld c,l 
2570			;	pop hl 
2570			;	ld de, execscratch 
2570			;		if DEBUG_FORTH_WORDS 
2570			;			DMARK "EX3" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			;	ldir 
2570			; 
2570			; 
2570			;	ld hl, execscratch 
2570			; 
2570			;		if DEBUG_FORTH_WORDS 
2570			;			DMARK "EXP" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			; 
2570			;	call forthparse 
2570			;	ld hl, execscratch 
2570			;		if DEBUG_FORTH_WORDS 
2570			;			DMARK "EXx" 
2570			;			CALLMONITOR 
2570			;		endif 
2570			;	call forthexec 
2570			; 
2570			;	jp .stkexec1 
2570			; 
2570			;	ret 
2570			 
2570			 
2570			.DUP: 
2570			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2570 17				db WORD_SYS_CORE+OPCODE_DUP             
2571 ec 25			dw .ZDUP            
2573 04				db 3 + 1 
2574 .. 00			db "DUP",0              
2578				endm 
# End of macro CWHEAD
2578			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2578			; | | >[!NOTE] 
2578			; | | > If the duplicated item is a string it is safely duplicated 
2578			 
2578				if DEBUG_FORTH_WORDS_KEY 
2578					DMARK "DUP" 
2578 f5				push af  
2579 3a 8d 25			ld a, (.dmark)  
257c 32 99 fd			ld (debug_mark),a  
257f 3a 8e 25			ld a, (.dmark+1)  
2582 32 9a fd			ld (debug_mark+1),a  
2585 3a 8f 25			ld a, (.dmark+2)  
2588 32 9b fd			ld (debug_mark+2),a  
258b 18 03			jr .pastdmark  
258d ..			.dmark: db "DUP"  
2590 f1			.pastdmark: pop af  
2591			endm  
# End of macro DMARK
2591					CALLMONITOR 
2591 cd a6 fd			call debug_vector  
2594				endm  
# End of macro CALLMONITOR
2594				endif 
2594			 
2594				FORTH_DSP 
2594 cd d4 21			call macro_forth_dsp 
2597				endm 
# End of macro FORTH_DSP
2597			 
2597 7e				ld a, (HL) 
2598 fe 01			cp DS_TYPE_STR 
259a 20 28			jr nz, .dupinum 
259c			 
259c				; push another string 
259c			 
259c				FORTH_DSP_VALUEHL     		 
259c cd 0e 22			call macro_dsp_valuehl 
259f				endm 
# End of macro FORTH_DSP_VALUEHL
259f			 
259f			if DEBUG_FORTH_WORDS 
259f				DMARK "DUs" 
259f f5				push af  
25a0 3a b4 25			ld a, (.dmark)  
25a3 32 99 fd			ld (debug_mark),a  
25a6 3a b5 25			ld a, (.dmark+1)  
25a9 32 9a fd			ld (debug_mark+1),a  
25ac 3a b6 25			ld a, (.dmark+2)  
25af 32 9b fd			ld (debug_mark+2),a  
25b2 18 03			jr .pastdmark  
25b4 ..			.dmark: db "DUs"  
25b7 f1			.pastdmark: pop af  
25b8			endm  
# End of macro DMARK
25b8				CALLMONITOR 
25b8 cd a6 fd			call debug_vector  
25bb				endm  
# End of macro CALLMONITOR
25bb			endif 
25bb cd 7c 20			call forth_push_str 
25be			 
25be				NEXTW 
25be cd a3 fd			call parse_vector 
25c1 c3 f5 23			jp macro_next 
25c4				endm 
# End of macro NEXTW
25c4			 
25c4			 
25c4			.dupinum: 
25c4				 
25c4			 
25c4			 
25c4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25c4 cd 0e 22			call macro_dsp_valuehl 
25c7				endm 
# End of macro FORTH_DSP_VALUEHL
25c7			 
25c7			; TODO add floating point number detection 
25c7			 
25c7			if DEBUG_FORTH_WORDS 
25c7				DMARK "DUi" 
25c7 f5				push af  
25c8 3a dc 25			ld a, (.dmark)  
25cb 32 99 fd			ld (debug_mark),a  
25ce 3a dd 25			ld a, (.dmark+1)  
25d1 32 9a fd			ld (debug_mark+1),a  
25d4 3a de 25			ld a, (.dmark+2)  
25d7 32 9b fd			ld (debug_mark+2),a  
25da 18 03			jr .pastdmark  
25dc ..			.dmark: db "DUi"  
25df f1			.pastdmark: pop af  
25e0			endm  
# End of macro DMARK
25e0				CALLMONITOR 
25e0 cd a6 fd			call debug_vector  
25e3				endm  
# End of macro CALLMONITOR
25e3			endif 
25e3			 
25e3 cd 12 20			call forth_push_numhl 
25e6				NEXTW 
25e6 cd a3 fd			call parse_vector 
25e9 c3 f5 23			jp macro_next 
25ec				endm 
# End of macro NEXTW
25ec			.ZDUP: 
25ec			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
25ec 99				db WORD_SYS_CORE+OPCODE_ZDUP             
25ed 26 26			dw .DMRK            
25ef 05				db 4 + 1 
25f0 .. 00			db "?DUP",0              
25f5				endm 
# End of macro CWHEAD
25f5			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
25f5			; | | >[!NOTE] 
25f5			; | | > If the duplicated item is a string it is not safely duplicated and remain as pointer to the origin 
25f5			 
25f5				if DEBUG_FORTH_WORDS_KEY 
25f5					DMARK "qDU" 
25f5 f5				push af  
25f6 3a 0a 26			ld a, (.dmark)  
25f9 32 99 fd			ld (debug_mark),a  
25fc 3a 0b 26			ld a, (.dmark+1)  
25ff 32 9a fd			ld (debug_mark+1),a  
2602 3a 0c 26			ld a, (.dmark+2)  
2605 32 9b fd			ld (debug_mark+2),a  
2608 18 03			jr .pastdmark  
260a ..			.dmark: db "qDU"  
260d f1			.pastdmark: pop af  
260e			endm  
# End of macro DMARK
260e					CALLMONITOR 
260e cd a6 fd			call debug_vector  
2611				endm  
# End of macro CALLMONITOR
2611				endif 
2611				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2611 cd 0e 22			call macro_dsp_valuehl 
2614				endm 
# End of macro FORTH_DSP_VALUEHL
2614			 
2614 e5				push hl 
2615			 
2615				; is it a zero? 
2615			 
2615 3e 00			ld a, 0 
2617 84				add h 
2618 85				add l 
2619			 
2619 e1				pop hl 
261a			 
261a			;	cp 0 
261a b7				or a 
261b 28 03			jr z, .dup2orig 
261d			 
261d			 
261d cd 12 20			call forth_push_numhl 
2620			 
2620			 
2620			; TODO add floating point number detection 
2620			 
2620			.dup2orig: 
2620			 
2620				NEXTW 
2620 cd a3 fd			call parse_vector 
2623 c3 f5 23			jp macro_next 
2626				endm 
# End of macro NEXTW
2626			.DMRK: 
2626			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
2626 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2627 66 26			dw .LSHIFT            
2629 06				db 5 + 1 
262a .. 00			db "DMARK",0              
2630				endm 
# End of macro CWHEAD
2630			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
2630			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
2630				if DEBUG_FORTH_WORDS_KEY 
2630					DMARK "DMK" 
2630 f5				push af  
2631 3a 45 26			ld a, (.dmark)  
2634 32 99 fd			ld (debug_mark),a  
2637 3a 46 26			ld a, (.dmark+1)  
263a 32 9a fd			ld (debug_mark+1),a  
263d 3a 47 26			ld a, (.dmark+2)  
2640 32 9b fd			ld (debug_mark+2),a  
2643 18 03			jr .pastdmark  
2645 ..			.dmark: db "DMK"  
2648 f1			.pastdmark: pop af  
2649			endm  
# End of macro DMARK
2649					CALLMONITOR 
2649 cd a6 fd			call debug_vector  
264c				endm  
# End of macro CALLMONITOR
264c				endif 
264c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
264c cd 0e 22			call macro_dsp_valuehl 
264f				endm 
# End of macro FORTH_DSP_VALUEHL
264f			 
264f 7e				ld a, (hl) 
2650 32 99 fd			ld (debug_mark),a 
2653 23				inc hl 
2654 7e				ld a, (hl) 
2655 32 9a fd			ld (debug_mark+1),a 
2658 23				inc hl 
2659 7e				ld a, (hl) 
265a 32 9b fd			ld (debug_mark+2),a 
265d			 
265d			 
265d				FORTH_DSP_POP 
265d cd c6 22			call macro_forth_dsp_pop 
2660				endm 
# End of macro FORTH_DSP_POP
2660				NEXTW 
2660 cd a3 fd			call parse_vector 
2663 c3 f5 23			jp macro_next 
2666				endm 
# End of macro NEXTW
2666			.LSHIFT: 
2666			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
2666 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2667 9d 26			dw .RSHIFT            
2669 07				db 6 + 1 
266a .. 00			db "LSHIFT",0              
2671				endm 
# End of macro CWHEAD
2671			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
2671				if DEBUG_FORTH_WORDS_KEY 
2671					DMARK "LSH" 
2671 f5				push af  
2672 3a 86 26			ld a, (.dmark)  
2675 32 99 fd			ld (debug_mark),a  
2678 3a 87 26			ld a, (.dmark+1)  
267b 32 9a fd			ld (debug_mark+1),a  
267e 3a 88 26			ld a, (.dmark+2)  
2681 32 9b fd			ld (debug_mark+2),a  
2684 18 03			jr .pastdmark  
2686 ..			.dmark: db "LSH"  
2689 f1			.pastdmark: pop af  
268a			endm  
# End of macro DMARK
268a					CALLMONITOR 
268a cd a6 fd			call debug_vector  
268d				endm  
# End of macro CALLMONITOR
268d				endif 
268d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
268d cd 0e 22			call macro_dsp_valuehl 
2690				endm 
# End of macro FORTH_DSP_VALUEHL
2690				FORTH_DSP_POP 
2690 cd c6 22			call macro_forth_dsp_pop 
2693				endm 
# End of macro FORTH_DSP_POP
2693			 
2693 29				add hl, hl 
2694 cd 12 20			call forth_push_numhl 
2697				NEXTW 
2697 cd a3 fd			call parse_vector 
269a c3 f5 23			jp macro_next 
269d				endm 
# End of macro NEXTW
269d			.RSHIFT: 
269d			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
269d 99				db WORD_SYS_CORE+OPCODE_ZDUP             
269e d7 26			dw .SWAP            
26a0 07				db 6 + 1 
26a1 .. 00			db "RSHIFT",0              
26a8				endm 
# End of macro CWHEAD
26a8			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
26a8				if DEBUG_FORTH_WORDS_KEY 
26a8					DMARK "RSH" 
26a8 f5				push af  
26a9 3a bd 26			ld a, (.dmark)  
26ac 32 99 fd			ld (debug_mark),a  
26af 3a be 26			ld a, (.dmark+1)  
26b2 32 9a fd			ld (debug_mark+1),a  
26b5 3a bf 26			ld a, (.dmark+2)  
26b8 32 9b fd			ld (debug_mark+2),a  
26bb 18 03			jr .pastdmark  
26bd ..			.dmark: db "RSH"  
26c0 f1			.pastdmark: pop af  
26c1			endm  
# End of macro DMARK
26c1					CALLMONITOR 
26c1 cd a6 fd			call debug_vector  
26c4				endm  
# End of macro CALLMONITOR
26c4				endif 
26c4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c4 cd 0e 22			call macro_dsp_valuehl 
26c7				endm 
# End of macro FORTH_DSP_VALUEHL
26c7				FORTH_DSP_POP 
26c7 cd c6 22			call macro_forth_dsp_pop 
26ca				endm 
# End of macro FORTH_DSP_POP
26ca cb 3c			srl h 
26cc cb 1d			rr l 
26ce cd 12 20			call forth_push_numhl 
26d1				NEXTW 
26d1 cd a3 fd			call parse_vector 
26d4 c3 f5 23			jp macro_next 
26d7				endm 
# End of macro NEXTW
26d7			.SWAP: 
26d7			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
26d7 18				db WORD_SYS_CORE+OPCODE_SWAP             
26d8 2e 27			dw .COLN            
26da 05				db 4 + 1 
26db .. 00			db "SWAP",0              
26e0				endm 
# End of macro CWHEAD
26e0			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
26e0				if DEBUG_FORTH_WORDS_KEY 
26e0					DMARK "SWP" 
26e0 f5				push af  
26e1 3a f5 26			ld a, (.dmark)  
26e4 32 99 fd			ld (debug_mark),a  
26e7 3a f6 26			ld a, (.dmark+1)  
26ea 32 9a fd			ld (debug_mark+1),a  
26ed 3a f7 26			ld a, (.dmark+2)  
26f0 32 9b fd			ld (debug_mark+2),a  
26f3 18 03			jr .pastdmark  
26f5 ..			.dmark: db "SWP"  
26f8 f1			.pastdmark: pop af  
26f9			endm  
# End of macro DMARK
26f9					CALLMONITOR 
26f9 cd a6 fd			call debug_vector  
26fc				endm  
# End of macro CALLMONITOR
26fc				endif 
26fc			 
26fc			; DONE Use os stack swap memory 
26fc			 
26fc				FORTH_DSP_PTR 0     ; TOS 
26fc 2a 1c f9			ld hl,(cli_data_sp) 
26ff 11 00 00			ld de, 0 * 3 
2702 ed 52			sbc hl, de 
2704				endm 
# End of macro FORTH_DSP_PTR
2704 cd 45 23			call hltostack1 
2707			  
2707				FORTH_DSP_PTR 1     ; TOS 
2707 2a 1c f9			ld hl,(cli_data_sp) 
270a 11 03 00			ld de, 1 * 3 
270d ed 52			sbc hl, de 
270f				endm 
# End of macro FORTH_DSP_PTR
270f cd 4b 23			call hltostack2 
2712			 
2712				FORTH_DSP_PTR 0     ; TOS 
2712 2a 1c f9			ld hl,(cli_data_sp) 
2715 11 00 00			ld de, 0 * 3 
2718 ed 52			sbc hl, de 
271a				endm 
# End of macro FORTH_DSP_PTR
271a cd 63 23			call hlfromstack2 
271d			 
271d				FORTH_DSP_PTR 1     ; TOS 
271d 2a 1c f9			ld hl,(cli_data_sp) 
2720 11 03 00			ld de, 1 * 3 
2723 ed 52			sbc hl, de 
2725				endm 
# End of macro FORTH_DSP_PTR
2725 cd 5d 23			call hlfromstack1 
2728			;	FORTH_DSP_VALUEHL 
2728			;	push hl     ; w2 
2728			; 
2728			;	FORTH_DSP_POP 
2728			; 
2728			;	FORTH_DSP_VALUEHL 
2728			; 
2728			;	FORTH_DSP_POP 
2728			; 
2728			;	pop de     ; w2	, hl = w1 
2728			; 
2728			;	ex de, hl 
2728			;	push de 
2728			; 
2728			;	call forth_push_numhl 
2728			; 
2728			;	pop hl 
2728			; 
2728			;	call forth_push_numhl 
2728				 
2728			 
2728				NEXTW 
2728 cd a3 fd			call parse_vector 
272b c3 f5 23			jp macro_next 
272e				endm 
# End of macro NEXTW
272e			.COLN: 
272e			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
272e 19				db WORD_SYS_CORE+OPCODE_COLN             
272f b9 28			dw .SCOLN            
2731 02				db 1 + 1 
2732 .. 00			db ":",0              
2734				endm 
# End of macro CWHEAD
2734			; | : ( -- )         Create new word | DONE 
2734			 
2734				if DEBUG_FORTH_WORDS_KEY 
2734					DMARK "CLN" 
2734 f5				push af  
2735 3a 49 27			ld a, (.dmark)  
2738 32 99 fd			ld (debug_mark),a  
273b 3a 4a 27			ld a, (.dmark+1)  
273e 32 9a fd			ld (debug_mark+1),a  
2741 3a 4b 27			ld a, (.dmark+2)  
2744 32 9b fd			ld (debug_mark+2),a  
2747 18 03			jr .pastdmark  
2749 ..			.dmark: db "CLN"  
274c f1			.pastdmark: pop af  
274d			endm  
# End of macro DMARK
274d					CALLMONITOR 
274d cd a6 fd			call debug_vector  
2750				endm  
# End of macro CALLMONITOR
2750				endif 
2750			STACKFRAME OFF $8efe $989f 
2750				if DEBUG_STACK_IMB 
2750					if OFF 
2750						exx 
2750						ld de, $8efe 
2750						ld a, d 
2750						ld hl, curframe 
2750						call hexout 
2750						ld a, e 
2750						ld hl, curframe+2 
2750						call hexout 
2750						ld hl, $8efe 
2750						push hl 
2750						ld hl, $989f 
2750						push hl 
2750						exx 
2750					endif 
2750				endif 
2750			endm 
# End of macro STACKFRAME
2750			; get parser buffer length  of new word 
2750			 
2750			 
2750			 
2750				; move tok past this to start of name defintition 
2750				; TODO get word to define 
2750				; TODO Move past word token 
2750				; TODO get length of string up to the ';' 
2750			 
2750 2a f0 f3		ld hl, (os_tok_ptr) 
2753 23			inc hl 
2754 23			inc hl 
2755			 
2755 3e 3b		ld a, ';' 
2757 cd 14 13		call strlent 
275a			 
275a 7d			ld a,l 
275b 32 df f0		ld (os_new_parse_len), a 
275e			 
275e			 
275e			if DEBUG_FORTH_UWORD 
275e ed 5b f0 f3	ld de, (os_tok_ptr) 
2762					DMARK ":01" 
2762 f5				push af  
2763 3a 77 27			ld a, (.dmark)  
2766 32 99 fd			ld (debug_mark),a  
2769 3a 78 27			ld a, (.dmark+1)  
276c 32 9a fd			ld (debug_mark+1),a  
276f 3a 79 27			ld a, (.dmark+2)  
2772 32 9b fd			ld (debug_mark+2),a  
2775 18 03			jr .pastdmark  
2777 ..			.dmark: db ":01"  
277a f1			.pastdmark: pop af  
277b			endm  
# End of macro DMARK
277b			CALLMONITOR 
277b cd a6 fd			call debug_vector  
277e				endm  
# End of macro CALLMONITOR
277e			endif 
277e			 
277e			; 
277e			;  new word memory layout: 
277e			;  
277e			;    : adg 6666 ;  
277e			; 
277e			;    db   1     ; user defined word  
277e 23			inc hl    
277f			;    dw   sysdict 
277f 23			inc hl 
2780 23			inc hl 
2781			;    db <word len>+1 (for null) 
2781 23			inc hl 
2782			;    db .... <word> 
2782			; 
2782			 
2782 23			inc hl    ; some extras for the word preamble before the above 
2783 23			inc hl 
2784 23			inc hl 
2785 23			inc hl 
2786 23			inc hl 
2787 23			inc hl 
2788 23			inc hl  
2789 23			inc hl 
278a 23			inc hl 
278b 23			inc hl 
278c 23			inc hl 
278d 23			inc hl 
278e 23			inc hl 
278f 23			inc hl     ; TODO how many do we really need?     maybe only 6 
2790			;       exec word buffer 
2790			;	<ptr word>   
2790 23			inc hl 
2791 23			inc hl 
2792			;       <word list><null term> 7F final term 
2792			 
2792			 
2792			if DEBUG_FORTH_UWORD 
2792					DMARK ":02" 
2792 f5				push af  
2793 3a a7 27			ld a, (.dmark)  
2796 32 99 fd			ld (debug_mark),a  
2799 3a a8 27			ld a, (.dmark+1)  
279c 32 9a fd			ld (debug_mark+1),a  
279f 3a a9 27			ld a, (.dmark+2)  
27a2 32 9b fd			ld (debug_mark+2),a  
27a5 18 03			jr .pastdmark  
27a7 ..			.dmark: db ":02"  
27aa f1			.pastdmark: pop af  
27ab			endm  
# End of macro DMARK
27ab			CALLMONITOR 
27ab cd a6 fd			call debug_vector  
27ae				endm  
# End of macro CALLMONITOR
27ae			endif 
27ae			 
27ae			 
27ae				; malloc the size 
27ae			 
27ae cd 7d 13			call malloc 
27b1 22 e1 f0			ld (os_new_malloc), hl     ; save malloc start 
27b4			 
27b4			;    db   1     ; user defined word  
27b4			;	ld a, WORD_SYS_UWORD  
27b4 36 01			ld (hl), WORD_SYS_UWORD 
27b6			 
27b6 23			inc hl    
27b7			;    dw   sysdict 
27b7 11 2e 25		ld de, sysdict       ; continue on with the scan to the system dict 
27ba 73			ld (hl), e 
27bb 23			inc hl 
27bc 72			ld (hl), d 
27bd 23			inc hl 
27be			 
27be			 
27be			;    Setup dict word 
27be			 
27be 23			inc hl 
27bf 22 db f0		ld (os_new_work_ptr), hl     ; save start of dict word  
27c2			 
27c2			; 1. get length of dict word 
27c2			 
27c2			 
27c2 2a f0 f3		ld hl, (os_tok_ptr) 
27c5 23			inc hl 
27c6 23			inc hl    ; position to start of dict word 
27c7 3e 00		ld a, 0 
27c9 cd 14 13		call strlent 
27cc			 
27cc			 
27cc 23			inc hl    ; to include null??? 
27cd			 
27cd			; write length of dict word 
27cd			 
27cd ed 5b db f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
27d1 1b			dec de 
27d2 eb			ex de, hl 
27d3 73			ld (hl), e 
27d4 eb			ex de, hl 
27d5			 
27d5			 
27d5			 
27d5			; copy  
27d5 4d			ld c, l 
27d6 06 00		ld b, 0 
27d8 ed 5b db f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
27dc 2a f0 f3		ld hl, (os_tok_ptr) 
27df 23			inc hl 
27e0 23			inc hl    ; position to start of dict word 
27e1			 
27e1			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27e1			 
27e1			; TODO need to convert word to upper case 
27e1			 
27e1			ucasetok:	 
27e1 7e			ld a,(hl) 
27e2 cd 00 13		call toUpper 
27e5 77			ld (hl),a 
27e6 ed a0		ldi 
27e8 f2 e1 27		jp p, ucasetok 
27eb			 
27eb			 
27eb			 
27eb			; de now points to start of where the word body code should be placed 
27eb ed 53 db f0	ld (os_new_work_ptr), de 
27ef			; hl now points to the words to throw at forthexec which needs to be copied 
27ef 22 d9 f0		ld (os_new_src_ptr), hl 
27f2			 
27f2			; TODO add 'call to forthexec' 
27f2			 
27f2			if DEBUG_FORTH_UWORD 
27f2 c5			push bc 
27f3 ed 4b e1 f0	ld bc, (os_new_malloc) 
27f7					DMARK ":0x" 
27f7 f5				push af  
27f8 3a 0c 28			ld a, (.dmark)  
27fb 32 99 fd			ld (debug_mark),a  
27fe 3a 0d 28			ld a, (.dmark+1)  
2801 32 9a fd			ld (debug_mark+1),a  
2804 3a 0e 28			ld a, (.dmark+2)  
2807 32 9b fd			ld (debug_mark+2),a  
280a 18 03			jr .pastdmark  
280c ..			.dmark: db ":0x"  
280f f1			.pastdmark: pop af  
2810			endm  
# End of macro DMARK
2810			CALLMONITOR 
2810 cd a6 fd			call debug_vector  
2813				endm  
# End of macro CALLMONITOR
2813 c1			pop bc 
2814			endif 
2814			 
2814			 
2814			; create word preamble which should be: 
2814			 
2814			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2814			 
2814			;    ld hl, <word code> 
2814			;    jp user_exec 
2814			;    <word code bytes> 
2814			 
2814			 
2814			;	inc de     ; TODO ??? or are we already past the word's null 
2814 eb			ex de, hl 
2815			 
2815 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2817			 
2817 23			inc hl 
2818 22 d5 f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
281b 23			inc hl 
281c			 
281c 23			inc hl 
281d 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
281f			 
281f 01 6a 65		ld bc, user_exec 
2822 23			inc hl 
2823 71			ld (hl), c     ; poke address of user_exec 
2824 23			inc hl 
2825 70			ld (hl), b     
2826			; 
2826			;	inc hl 
2826			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2826			; 
2826			; 
2826			;	ld bc, macro_forth_rsp_next 
2826			;	inc hl 
2826			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2826			;	inc hl 
2826			;	ld (hl), b     
2826			; 
2826			;	inc hl 
2826			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2826			; 
2826			; 
2826			;	inc hl 
2826			;	ld bc, forthexec 
2826			;	ld (hl), c     ; poke address of forthexec 
2826			;	inc hl 
2826			;	ld (hl), b      
2826			; 
2826			;	inc hl 
2826			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2826			; 
2826			;	ld bc, user_dict_next 
2826			;	inc hl 
2826			;	ld (hl), c     ; poke address of forthexec 
2826			;	inc hl 
2826			;	ld (hl), b      
2826			 
2826			; hl is now where we need to copy the word byte data to save this 
2826			 
2826 23			inc hl 
2827 22 d7 f0		ld (os_new_exec), hl 
282a			 
282a			; copy definition 
282a			 
282a eb			ex de, hl 
282b			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
282b			;	inc de    ; skip the PC for this parse 
282b 3a df f0		ld a, (os_new_parse_len) 
282e 4f			ld c, a 
282f 06 00		ld b, 0 
2831 ed b0		ldir		 ; copy defintion 
2833			 
2833			 
2833			; poke the address of where the new word bytes live for forthexec 
2833			 
2833 2a d5 f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2836			 
2836 ed 5b d7 f0	ld de, (os_new_exec)      
283a			 
283a 73			ld (hl), e 
283b 23			inc hl 
283c 72			ld (hl), d 
283d			 
283d				; TODO copy last user dict word next link to this word 
283d				; TODO update last user dict word to point to this word 
283d			; 
283d			; hl f923 de 812a ; bc 811a 
283d			 
283d			if DEBUG_FORTH_UWORD 
283d c5			push bc 
283e ed 4b e1 f0	ld bc, (os_new_malloc) 
2842					DMARK ":0A" 
2842 f5				push af  
2843 3a 57 28			ld a, (.dmark)  
2846 32 99 fd			ld (debug_mark),a  
2849 3a 58 28			ld a, (.dmark+1)  
284c 32 9a fd			ld (debug_mark+1),a  
284f 3a 59 28			ld a, (.dmark+2)  
2852 32 9b fd			ld (debug_mark+2),a  
2855 18 03			jr .pastdmark  
2857 ..			.dmark: db ":0A"  
285a f1			.pastdmark: pop af  
285b			endm  
# End of macro DMARK
285b			CALLMONITOR 
285b cd a6 fd			call debug_vector  
285e				endm  
# End of macro CALLMONITOR
285e c1			pop bc 
285f			endif 
285f			if DEBUG_FORTH_UWORD 
285f c5			push bc 
2860 ed 4b e1 f0	ld bc, (os_new_malloc) 
2864 03			inc bc 
2865 03			inc bc 
2866 03			inc bc 
2867 03			inc bc 
2868 03			inc bc 
2869 03			inc bc 
286a 03			inc bc 
286b 03			inc bc 
286c			 
286c					DMARK ":0B" 
286c f5				push af  
286d 3a 81 28			ld a, (.dmark)  
2870 32 99 fd			ld (debug_mark),a  
2873 3a 82 28			ld a, (.dmark+1)  
2876 32 9a fd			ld (debug_mark+1),a  
2879 3a 83 28			ld a, (.dmark+2)  
287c 32 9b fd			ld (debug_mark+2),a  
287f 18 03			jr .pastdmark  
2881 ..			.dmark: db ":0B"  
2884 f1			.pastdmark: pop af  
2885			endm  
# End of macro DMARK
2885			CALLMONITOR 
2885 cd a6 fd			call debug_vector  
2888				endm  
# End of macro CALLMONITOR
2888 c1			pop bc 
2889			endif 
2889			 
2889			; update word dict linked list for new word 
2889			 
2889			 
2889 2a ec f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
288c 23			inc hl     ; move to next work linked list ptr 
288d			 
288d ed 5b e1 f0	ld de, (os_new_malloc)		 ; new next word 
2891 73			ld (hl), e 
2892 23			inc hl 
2893 72			ld (hl), d 
2894			 
2894			if DEBUG_FORTH_UWORD 
2894 ed 4b ec f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2898			endif 
2898			 
2898 ed 53 ec f3	ld (os_last_new_uword), de      ; update last new uword ptr 
289c			 
289c			 
289c			if DEBUG_FORTH_UWORD 
289c					DMARK ":0+" 
289c f5				push af  
289d 3a b1 28			ld a, (.dmark)  
28a0 32 99 fd			ld (debug_mark),a  
28a3 3a b2 28			ld a, (.dmark+1)  
28a6 32 9a fd			ld (debug_mark+1),a  
28a9 3a b3 28			ld a, (.dmark+2)  
28ac 32 9b fd			ld (debug_mark+2),a  
28af 18 03			jr .pastdmark  
28b1 ..			.dmark: db ":0+"  
28b4 f1			.pastdmark: pop af  
28b5			endm  
# End of macro DMARK
28b5			CALLMONITOR 
28b5 cd a6 fd			call debug_vector  
28b8				endm  
# End of macro CALLMONITOR
28b8			endif 
28b8			 
28b8			STACKFRAMECHK OFF $8efe $989f 
28b8				if DEBUG_STACK_IMB 
28b8					if OFF 
28b8						exx 
28b8						ld hl, $989f 
28b8						pop de   ; $989f 
28b8						call cmp16 
28b8						jr nz, .spnosame 
28b8						ld hl, $8efe 
28b8						pop de   ; $8efe 
28b8						call cmp16 
28b8						jr z, .spfrsame 
28b8						.spnosame: call showsperror 
28b8						.spfrsame: nop 
28b8						exx 
28b8					endif 
28b8				endif 
28b8			endm 
# End of macro STACKFRAMECHK
28b8			 
28b8 c9			ret    ; dont process any remaining parser tokens as they form new word 
28b9			 
28b9			 
28b9			 
28b9			 
28b9			;		NEXT 
28b9			.SCOLN: 
28b9			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
28b9 06			db OPCODE_SCOLN 
28ba 08 29		dw .DROP 
28bc 02			db 2 
28bd .. 00		db ";",0           
28bf			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
28bf				if DEBUG_FORTH_WORDS_KEY 
28bf					DMARK "SCN" 
28bf f5				push af  
28c0 3a d4 28			ld a, (.dmark)  
28c3 32 99 fd			ld (debug_mark),a  
28c6 3a d5 28			ld a, (.dmark+1)  
28c9 32 9a fd			ld (debug_mark+1),a  
28cc 3a d6 28			ld a, (.dmark+2)  
28cf 32 9b fd			ld (debug_mark+2),a  
28d2 18 03			jr .pastdmark  
28d4 ..			.dmark: db "SCN"  
28d7 f1			.pastdmark: pop af  
28d8			endm  
# End of macro DMARK
28d8					CALLMONITOR 
28d8 cd a6 fd			call debug_vector  
28db				endm  
# End of macro CALLMONITOR
28db				endif 
28db				FORTH_RSP_TOS 
28db cd d0 1f			call macro_forth_rsp_tos 
28de				endm 
# End of macro FORTH_RSP_TOS
28de e5				push hl 
28df				FORTH_RSP_POP 
28df cd da 1f			call macro_forth_rsp_pop 
28e2				endm 
# End of macro FORTH_RSP_POP
28e2 e1				pop hl 
28e3			;		ex de,hl 
28e3 22 f0 f3			ld (os_tok_ptr),hl 
28e6			 
28e6			if DEBUG_FORTH_UWORD 
28e6					DMARK "SCL" 
28e6 f5				push af  
28e7 3a fb 28			ld a, (.dmark)  
28ea 32 99 fd			ld (debug_mark),a  
28ed 3a fc 28			ld a, (.dmark+1)  
28f0 32 9a fd			ld (debug_mark+1),a  
28f3 3a fd 28			ld a, (.dmark+2)  
28f6 32 9b fd			ld (debug_mark+2),a  
28f9 18 03			jr .pastdmark  
28fb ..			.dmark: db "SCL"  
28fe f1			.pastdmark: pop af  
28ff			endm  
# End of macro DMARK
28ff			CALLMONITOR 
28ff cd a6 fd			call debug_vector  
2902				endm  
# End of macro CALLMONITOR
2902			endif 
2902				NEXTW 
2902 cd a3 fd			call parse_vector 
2905 c3 f5 23			jp macro_next 
2908				endm 
# End of macro NEXTW
2908			 
2908			.DROP: 
2908			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2908 1b				db WORD_SYS_CORE+OPCODE_DROP             
2909 36 29			dw .DUP2            
290b 05				db 4 + 1 
290c .. 00			db "DROP",0              
2911				endm 
# End of macro CWHEAD
2911			; | DROP ( w -- )   drop the TOS item   | DONE 
2911				if DEBUG_FORTH_WORDS_KEY 
2911					DMARK "DRP" 
2911 f5				push af  
2912 3a 26 29			ld a, (.dmark)  
2915 32 99 fd			ld (debug_mark),a  
2918 3a 27 29			ld a, (.dmark+1)  
291b 32 9a fd			ld (debug_mark+1),a  
291e 3a 28 29			ld a, (.dmark+2)  
2921 32 9b fd			ld (debug_mark+2),a  
2924 18 03			jr .pastdmark  
2926 ..			.dmark: db "DRP"  
2929 f1			.pastdmark: pop af  
292a			endm  
# End of macro DMARK
292a					CALLMONITOR 
292a cd a6 fd			call debug_vector  
292d				endm  
# End of macro CALLMONITOR
292d				endif 
292d				FORTH_DSP_POP 
292d cd c6 22			call macro_forth_dsp_pop 
2930				endm 
# End of macro FORTH_DSP_POP
2930				NEXTW 
2930 cd a3 fd			call parse_vector 
2933 c3 f5 23			jp macro_next 
2936				endm 
# End of macro NEXTW
2936			.DUP2: 
2936			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2936 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2937 7e 29			dw .DROP2            
2939 05				db 4 + 1 
293a .. 00			db "2DUP",0              
293f				endm 
# End of macro CWHEAD
293f			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
293f			; | | >[!NOTE] 
293f			; | | > If the duplicated items are string pointers, string are not safely duplicated and remain as pointers to the origin 
293f				if DEBUG_FORTH_WORDS_KEY 
293f					DMARK "2DU" 
293f f5				push af  
2940 3a 54 29			ld a, (.dmark)  
2943 32 99 fd			ld (debug_mark),a  
2946 3a 55 29			ld a, (.dmark+1)  
2949 32 9a fd			ld (debug_mark+1),a  
294c 3a 56 29			ld a, (.dmark+2)  
294f 32 9b fd			ld (debug_mark+2),a  
2952 18 03			jr .pastdmark  
2954 ..			.dmark: db "2DU"  
2957 f1			.pastdmark: pop af  
2958			endm  
# End of macro DMARK
2958					CALLMONITOR 
2958 cd a6 fd			call debug_vector  
295b				endm  
# End of macro CALLMONITOR
295b				endif 
295b				FORTH_DSP_VALUEHL 
295b cd 0e 22			call macro_dsp_valuehl 
295e				endm 
# End of macro FORTH_DSP_VALUEHL
295e e5				push hl      ; 2 
295f			 
295f				FORTH_DSP_POP 
295f cd c6 22			call macro_forth_dsp_pop 
2962				endm 
# End of macro FORTH_DSP_POP
2962				 
2962				FORTH_DSP_VALUEHL 
2962 cd 0e 22			call macro_dsp_valuehl 
2965				endm 
# End of macro FORTH_DSP_VALUEHL
2965			;		push hl      ; 1 
2965			 
2965				FORTH_DSP_POP 
2965 cd c6 22			call macro_forth_dsp_pop 
2968				endm 
# End of macro FORTH_DSP_POP
2968			 
2968			;		pop hl       ; 1 
2968 d1				pop de       ; 2 
2969			 
2969 cd 12 20			call forth_push_numhl 
296c eb				ex de, hl 
296d cd 12 20			call forth_push_numhl 
2970			 
2970				 
2970 eb				ex de, hl 
2971			 
2971 cd 12 20			call forth_push_numhl 
2974 eb				ex de, hl 
2975 cd 12 20			call forth_push_numhl 
2978			 
2978			 
2978				NEXTW 
2978 cd a3 fd			call parse_vector 
297b c3 f5 23			jp macro_next 
297e				endm 
# End of macro NEXTW
297e			.DROP2: 
297e			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
297e 1d				db WORD_SYS_CORE+OPCODE_DROP2             
297f b0 29			dw .PICK            
2981 06				db 5 + 1 
2982 .. 00			db "2DROP",0              
2988				endm 
# End of macro CWHEAD
2988			; | 2DROP ( w w -- )    Double drop | DONE 
2988				if DEBUG_FORTH_WORDS_KEY 
2988					DMARK "2DR" 
2988 f5				push af  
2989 3a 9d 29			ld a, (.dmark)  
298c 32 99 fd			ld (debug_mark),a  
298f 3a 9e 29			ld a, (.dmark+1)  
2992 32 9a fd			ld (debug_mark+1),a  
2995 3a 9f 29			ld a, (.dmark+2)  
2998 32 9b fd			ld (debug_mark+2),a  
299b 18 03			jr .pastdmark  
299d ..			.dmark: db "2DR"  
29a0 f1			.pastdmark: pop af  
29a1			endm  
# End of macro DMARK
29a1					CALLMONITOR 
29a1 cd a6 fd			call debug_vector  
29a4				endm  
# End of macro CALLMONITOR
29a4				endif 
29a4				FORTH_DSP_POP 
29a4 cd c6 22			call macro_forth_dsp_pop 
29a7				endm 
# End of macro FORTH_DSP_POP
29a7				FORTH_DSP_POP 
29a7 cd c6 22			call macro_forth_dsp_pop 
29aa				endm 
# End of macro FORTH_DSP_POP
29aa				NEXTW 
29aa cd a3 fd			call parse_vector 
29ad c3 f5 23			jp macro_next 
29b0				endm 
# End of macro NEXTW
29b0			.PICK: 
29b0			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
29b0 77				db WORD_SYS_CORE+99             
29b1 4d 2a			dw .SWAP2            
29b3 05				db 4 + 1 
29b4 .. 00			db "PICK",0              
29b9				endm 
# End of macro CWHEAD
29b9			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
29b9			; | | >[!NOTE] 
29b9			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
29b9				if DEBUG_FORTH_WORDS_KEY 
29b9					DMARK "PIK" 
29b9 f5				push af  
29ba 3a ce 29			ld a, (.dmark)  
29bd 32 99 fd			ld (debug_mark),a  
29c0 3a cf 29			ld a, (.dmark+1)  
29c3 32 9a fd			ld (debug_mark+1),a  
29c6 3a d0 29			ld a, (.dmark+2)  
29c9 32 9b fd			ld (debug_mark+2),a  
29cc 18 03			jr .pastdmark  
29ce ..			.dmark: db "PIK"  
29d1 f1			.pastdmark: pop af  
29d2			endm  
# End of macro DMARK
29d2					CALLMONITOR 
29d2 cd a6 fd			call debug_vector  
29d5				endm  
# End of macro CALLMONITOR
29d5				endif 
29d5			 
29d5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29d5 cd 0e 22			call macro_dsp_valuehl 
29d8				endm 
# End of macro FORTH_DSP_VALUEHL
29d8				 
29d8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29d8 cd c6 22			call macro_forth_dsp_pop 
29db				endm 
# End of macro FORTH_DSP_POP
29db			 
29db				; init from TOS 
29db e5				push hl 
29dc				FORTH_DSP 
29dc cd d4 21			call macro_forth_dsp 
29df				endm 
# End of macro FORTH_DSP
29df			;	ld hl, cli_data_sp 
29df				if DEBUG_FORTH_WORDS 
29df					DMARK "PK1" 
29df f5				push af  
29e0 3a f4 29			ld a, (.dmark)  
29e3 32 99 fd			ld (debug_mark),a  
29e6 3a f5 29			ld a, (.dmark+1)  
29e9 32 9a fd			ld (debug_mark+1),a  
29ec 3a f6 29			ld a, (.dmark+2)  
29ef 32 9b fd			ld (debug_mark+2),a  
29f2 18 03			jr .pastdmark  
29f4 ..			.dmark: db "PK1"  
29f7 f1			.pastdmark: pop af  
29f8			endm  
# End of macro DMARK
29f8					CALLMONITOR 
29f8 cd a6 fd			call debug_vector  
29fb				endm  
# End of macro CALLMONITOR
29fb				endif 
29fb c1				pop bc 
29fc 41				ld b,c 
29fd 3e 00			ld a, 0 
29ff b8				cp b 
2a00 28 21			jr z, .pdone	 
2a02			.pkl: 
2a02 2b				dec hl 
2a03 2b				dec hl 
2a04 2b				dec hl 
2a05			 
2a05				if DEBUG_FORTH_WORDS 
2a05					DMARK "PKl" 
2a05 f5				push af  
2a06 3a 1a 2a			ld a, (.dmark)  
2a09 32 99 fd			ld (debug_mark),a  
2a0c 3a 1b 2a			ld a, (.dmark+1)  
2a0f 32 9a fd			ld (debug_mark+1),a  
2a12 3a 1c 2a			ld a, (.dmark+2)  
2a15 32 9b fd			ld (debug_mark+2),a  
2a18 18 03			jr .pastdmark  
2a1a ..			.dmark: db "PKl"  
2a1d f1			.pastdmark: pop af  
2a1e			endm  
# End of macro DMARK
2a1e					CALLMONITOR 
2a1e cd a6 fd			call debug_vector  
2a21				endm  
# End of macro CALLMONITOR
2a21				endif 
2a21 10 df			djnz .pkl 
2a23			.pdone: 
2a23				 
2a23				; TODO do type check with correct push 
2a23			 
2a23 23				inc hl 
2a24				;call loadwordinhl 
2a24 5e				ld e, (hl) 
2a25 23				inc hl 
2a26 56				ld d, (hl) 
2a27 eb				ex de,hl 
2a28				if DEBUG_FORTH_WORDS 
2a28					DMARK "PKp" 
2a28 f5				push af  
2a29 3a 3d 2a			ld a, (.dmark)  
2a2c 32 99 fd			ld (debug_mark),a  
2a2f 3a 3e 2a			ld a, (.dmark+1)  
2a32 32 9a fd			ld (debug_mark+1),a  
2a35 3a 3f 2a			ld a, (.dmark+2)  
2a38 32 9b fd			ld (debug_mark+2),a  
2a3b 18 03			jr .pastdmark  
2a3d ..			.dmark: db "PKp"  
2a40 f1			.pastdmark: pop af  
2a41			endm  
# End of macro DMARK
2a41					CALLMONITOR 
2a41 cd a6 fd			call debug_vector  
2a44				endm  
# End of macro CALLMONITOR
2a44				endif 
2a44 cd 12 20			call forth_push_numhl 
2a47			 
2a47				NEXTW 
2a47 cd a3 fd			call parse_vector 
2a4a c3 f5 23			jp macro_next 
2a4d				endm 
# End of macro NEXTW
2a4d			.SWAP2: 
2a4d			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2a4d 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2a4e d1 2a			dw .AT            
2a50 06				db 5 + 1 
2a51 .. 00			db "2SWAP",0              
2a57				endm 
# End of macro CWHEAD
2a57			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | DONE 
2a57				if DEBUG_FORTH_WORDS_KEY 
2a57					DMARK "2SW" 
2a57 f5				push af  
2a58 3a 6c 2a			ld a, (.dmark)  
2a5b 32 99 fd			ld (debug_mark),a  
2a5e 3a 6d 2a			ld a, (.dmark+1)  
2a61 32 9a fd			ld (debug_mark+1),a  
2a64 3a 6e 2a			ld a, (.dmark+2)  
2a67 32 9b fd			ld (debug_mark+2),a  
2a6a 18 03			jr .pastdmark  
2a6c ..			.dmark: db "2SW"  
2a6f f1			.pastdmark: pop af  
2a70			endm  
# End of macro DMARK
2a70					CALLMONITOR 
2a70 cd a6 fd			call debug_vector  
2a73				endm  
# End of macro CALLMONITOR
2a73				endif 
2a73			; TODO Use os stack swap memory 
2a73			 
2a73				FORTH_DSP_PTR 0     ; TOS    w4 
2a73 2a 1c f9			ld hl,(cli_data_sp) 
2a76 11 00 00			ld de, 0 * 3 
2a79 ed 52			sbc hl, de 
2a7b				endm 
# End of macro FORTH_DSP_PTR
2a7b cd 45 23			call hltostack1 
2a7e			  
2a7e				FORTH_DSP_PTR 1     ; TOS    w3 
2a7e 2a 1c f9			ld hl,(cli_data_sp) 
2a81 11 03 00			ld de, 1 * 3 
2a84 ed 52			sbc hl, de 
2a86				endm 
# End of macro FORTH_DSP_PTR
2a86 cd 4b 23			call hltostack2 
2a89			 
2a89			 
2a89			 
2a89				FORTH_DSP_PTR 2     ; TOS    w2 
2a89 2a 1c f9			ld hl,(cli_data_sp) 
2a8c 11 06 00			ld de, 2 * 3 
2a8f ed 52			sbc hl, de 
2a91				endm 
# End of macro FORTH_DSP_PTR
2a91 cd 51 23			call hltostack3 
2a94			 
2a94				FORTH_DSP_PTR 3     ; TOS   w1 
2a94 2a 1c f9			ld hl,(cli_data_sp) 
2a97 11 09 00			ld de, 3 * 3 
2a9a ed 52			sbc hl, de 
2a9c				endm 
# End of macro FORTH_DSP_PTR
2a9c cd 57 23			call hltostack4 
2a9f			 
2a9f			 
2a9f			 
2a9f			 
2a9f				FORTH_DSP_PTR 0     ; TOS 
2a9f 2a 1c f9			ld hl,(cli_data_sp) 
2aa2 11 00 00			ld de, 0 * 3 
2aa5 ed 52			sbc hl, de 
2aa7				endm 
# End of macro FORTH_DSP_PTR
2aa7 cd 69 23			call hlfromstack3 
2aaa			 
2aaa				FORTH_DSP_PTR 1     ; TOS 
2aaa 2a 1c f9			ld hl,(cli_data_sp) 
2aad 11 03 00			ld de, 1 * 3 
2ab0 ed 52			sbc hl, de 
2ab2				endm 
# End of macro FORTH_DSP_PTR
2ab2 cd 6f 23			call hlfromstack4 
2ab5			 
2ab5			 
2ab5			 
2ab5				FORTH_DSP_PTR 2     ; TOS 
2ab5 2a 1c f9			ld hl,(cli_data_sp) 
2ab8 11 06 00			ld de, 2 * 3 
2abb ed 52			sbc hl, de 
2abd				endm 
# End of macro FORTH_DSP_PTR
2abd cd 5d 23			call hlfromstack1 
2ac0			 
2ac0				FORTH_DSP_PTR 3     ; TOS 
2ac0 2a 1c f9			ld hl,(cli_data_sp) 
2ac3 11 09 00			ld de, 3 * 3 
2ac6 ed 52			sbc hl, de 
2ac8				endm 
# End of macro FORTH_DSP_PTR
2ac8 cd 63 23			call hlfromstack2 
2acb			 
2acb				NEXTW 
2acb cd a3 fd			call parse_vector 
2ace c3 f5 23			jp macro_next 
2ad1				endm 
# End of macro NEXTW
2ad1			.AT: 
2ad1			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2ad1 1f				db WORD_SYS_CORE+OPCODE_AT             
2ad2 06 2b			dw .CAT            
2ad4 02				db 1 + 1 
2ad5 .. 00			db "@",0              
2ad7				endm 
# End of macro CWHEAD
2ad7			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2ad7			 
2ad7				if DEBUG_FORTH_WORDS_KEY 
2ad7					DMARK "AT." 
2ad7 f5				push af  
2ad8 3a ec 2a			ld a, (.dmark)  
2adb 32 99 fd			ld (debug_mark),a  
2ade 3a ed 2a			ld a, (.dmark+1)  
2ae1 32 9a fd			ld (debug_mark+1),a  
2ae4 3a ee 2a			ld a, (.dmark+2)  
2ae7 32 9b fd			ld (debug_mark+2),a  
2aea 18 03			jr .pastdmark  
2aec ..			.dmark: db "AT."  
2aef f1			.pastdmark: pop af  
2af0			endm  
# End of macro DMARK
2af0					CALLMONITOR 
2af0 cd a6 fd			call debug_vector  
2af3				endm  
# End of macro CALLMONITOR
2af3				endif 
2af3			.getbyteat:	 
2af3				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2af3 cd 0e 22			call macro_dsp_valuehl 
2af6				endm 
# End of macro FORTH_DSP_VALUEHL
2af6				 
2af6			;		push hl 
2af6			 
2af6				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2af6 cd c6 22			call macro_forth_dsp_pop 
2af9				endm 
# End of macro FORTH_DSP_POP
2af9			 
2af9			;		pop hl 
2af9			 
2af9 7e				ld a, (hl) 
2afa			 
2afa 6f				ld l, a 
2afb 26 00			ld h, 0 
2afd cd 12 20			call forth_push_numhl 
2b00			 
2b00				NEXTW 
2b00 cd a3 fd			call parse_vector 
2b03 c3 f5 23			jp macro_next 
2b06				endm 
# End of macro NEXTW
2b06			.CAT: 
2b06			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2b06 20				db WORD_SYS_CORE+OPCODE_CAT             
2b07 32 2b			dw .BANG            
2b09 03				db 2 + 1 
2b0a .. 00			db "C@",0              
2b0d				endm 
# End of macro CWHEAD
2b0d			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2b0d				if DEBUG_FORTH_WORDS_KEY 
2b0d					DMARK "CAA" 
2b0d f5				push af  
2b0e 3a 22 2b			ld a, (.dmark)  
2b11 32 99 fd			ld (debug_mark),a  
2b14 3a 23 2b			ld a, (.dmark+1)  
2b17 32 9a fd			ld (debug_mark+1),a  
2b1a 3a 24 2b			ld a, (.dmark+2)  
2b1d 32 9b fd			ld (debug_mark+2),a  
2b20 18 03			jr .pastdmark  
2b22 ..			.dmark: db "CAA"  
2b25 f1			.pastdmark: pop af  
2b26			endm  
# End of macro DMARK
2b26					CALLMONITOR 
2b26 cd a6 fd			call debug_vector  
2b29				endm  
# End of macro CALLMONITOR
2b29				endif 
2b29 c3 f3 2a			jp .getbyteat 
2b2c				NEXTW 
2b2c cd a3 fd			call parse_vector 
2b2f c3 f5 23			jp macro_next 
2b32				endm 
# End of macro NEXTW
2b32			.BANG: 
2b32			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2b32 21				db WORD_SYS_CORE+OPCODE_BANG             
2b33 6b 2b			dw .CBANG            
2b35 02				db 1 + 1 
2b36 .. 00			db "!",0              
2b38				endm 
# End of macro CWHEAD
2b38			; | ! ( x w -- ) Store x at address w      | DONE 
2b38				if DEBUG_FORTH_WORDS_KEY 
2b38					DMARK "BNG" 
2b38 f5				push af  
2b39 3a 4d 2b			ld a, (.dmark)  
2b3c 32 99 fd			ld (debug_mark),a  
2b3f 3a 4e 2b			ld a, (.dmark+1)  
2b42 32 9a fd			ld (debug_mark+1),a  
2b45 3a 4f 2b			ld a, (.dmark+2)  
2b48 32 9b fd			ld (debug_mark+2),a  
2b4b 18 03			jr .pastdmark  
2b4d ..			.dmark: db "BNG"  
2b50 f1			.pastdmark: pop af  
2b51			endm  
# End of macro DMARK
2b51					CALLMONITOR 
2b51 cd a6 fd			call debug_vector  
2b54				endm  
# End of macro CALLMONITOR
2b54				endif 
2b54			 
2b54			.storebyteat:		 
2b54				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b54 cd 0e 22			call macro_dsp_valuehl 
2b57				endm 
# End of macro FORTH_DSP_VALUEHL
2b57				 
2b57 e5				push hl 
2b58			 
2b58				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b58 cd c6 22			call macro_forth_dsp_pop 
2b5b				endm 
# End of macro FORTH_DSP_POP
2b5b			 
2b5b				; get byte to poke 
2b5b			 
2b5b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b5b cd 0e 22			call macro_dsp_valuehl 
2b5e				endm 
# End of macro FORTH_DSP_VALUEHL
2b5e e5				push hl 
2b5f			 
2b5f			 
2b5f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b5f cd c6 22			call macro_forth_dsp_pop 
2b62				endm 
# End of macro FORTH_DSP_POP
2b62			 
2b62			 
2b62 d1				pop de 
2b63 e1				pop hl 
2b64			 
2b64 73				ld (hl),e 
2b65			 
2b65			 
2b65				NEXTW 
2b65 cd a3 fd			call parse_vector 
2b68 c3 f5 23			jp macro_next 
2b6b				endm 
# End of macro NEXTW
2b6b			.CBANG: 
2b6b			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2b6b 22				db WORD_SYS_CORE+OPCODE_CBANG             
2b6c 97 2b			dw .SCALL            
2b6e 03				db 2 + 1 
2b6f .. 00			db "C!",0              
2b72				endm 
# End of macro CWHEAD
2b72			; | C!  ( x w -- ) Store x at address w  | DONE 
2b72				if DEBUG_FORTH_WORDS_KEY 
2b72					DMARK "CBA" 
2b72 f5				push af  
2b73 3a 87 2b			ld a, (.dmark)  
2b76 32 99 fd			ld (debug_mark),a  
2b79 3a 88 2b			ld a, (.dmark+1)  
2b7c 32 9a fd			ld (debug_mark+1),a  
2b7f 3a 89 2b			ld a, (.dmark+2)  
2b82 32 9b fd			ld (debug_mark+2),a  
2b85 18 03			jr .pastdmark  
2b87 ..			.dmark: db "CBA"  
2b8a f1			.pastdmark: pop af  
2b8b			endm  
# End of macro DMARK
2b8b					CALLMONITOR 
2b8b cd a6 fd			call debug_vector  
2b8e				endm  
# End of macro CALLMONITOR
2b8e				endif 
2b8e c3 54 2b			jp .storebyteat 
2b91				NEXTW 
2b91 cd a3 fd			call parse_vector 
2b94 c3 f5 23			jp macro_next 
2b97				endm 
# End of macro NEXTW
2b97			.SCALL: 
2b97			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2b97 23				db WORD_SYS_CORE+OPCODE_SCALL             
2b98 ce 2b			dw .DEPTH            
2b9a 05				db 4 + 1 
2b9b .. 00			db "CALL",0              
2ba0				endm 
# End of macro CWHEAD
2ba0			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2ba0				if DEBUG_FORTH_WORDS_KEY 
2ba0					DMARK "CLL" 
2ba0 f5				push af  
2ba1 3a b5 2b			ld a, (.dmark)  
2ba4 32 99 fd			ld (debug_mark),a  
2ba7 3a b6 2b			ld a, (.dmark+1)  
2baa 32 9a fd			ld (debug_mark+1),a  
2bad 3a b7 2b			ld a, (.dmark+2)  
2bb0 32 9b fd			ld (debug_mark+2),a  
2bb3 18 03			jr .pastdmark  
2bb5 ..			.dmark: db "CLL"  
2bb8 f1			.pastdmark: pop af  
2bb9			endm  
# End of macro DMARK
2bb9					CALLMONITOR 
2bb9 cd a6 fd			call debug_vector  
2bbc				endm  
# End of macro CALLMONITOR
2bbc				endif 
2bbc			 
2bbc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bbc cd 0e 22			call macro_dsp_valuehl 
2bbf				endm 
# End of macro FORTH_DSP_VALUEHL
2bbf			 
2bbf			;		push hl 
2bbf			 
2bbf				; destroy value TOS 
2bbf			 
2bbf				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bbf cd c6 22			call macro_forth_dsp_pop 
2bc2				endm 
# End of macro FORTH_DSP_POP
2bc2			 
2bc2					 
2bc2			;		pop hl 
2bc2			 
2bc2				; how to do a call with hl???? save SP? 
2bc2 cd 99 23			call forth_call_hl 
2bc5			 
2bc5			 
2bc5				; TODO push value back onto stack for another op etc 
2bc5			 
2bc5 cd 12 20			call forth_push_numhl 
2bc8				NEXTW 
2bc8 cd a3 fd			call parse_vector 
2bcb c3 f5 23			jp macro_next 
2bce				endm 
# End of macro NEXTW
2bce			.DEPTH: 
2bce			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2bce 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2bcf 0e 2c			dw .OVER            
2bd1 06				db 5 + 1 
2bd2 .. 00			db "DEPTH",0              
2bd8				endm 
# End of macro CWHEAD
2bd8			; | DEPTH ( -- u ) Push count of stack | DONE 
2bd8				; take current TOS and remove from base value div by two to get count 
2bd8				if DEBUG_FORTH_WORDS_KEY 
2bd8					DMARK "DEP" 
2bd8 f5				push af  
2bd9 3a ed 2b			ld a, (.dmark)  
2bdc 32 99 fd			ld (debug_mark),a  
2bdf 3a ee 2b			ld a, (.dmark+1)  
2be2 32 9a fd			ld (debug_mark+1),a  
2be5 3a ef 2b			ld a, (.dmark+2)  
2be8 32 9b fd			ld (debug_mark+2),a  
2beb 18 03			jr .pastdmark  
2bed ..			.dmark: db "DEP"  
2bf0 f1			.pastdmark: pop af  
2bf1			endm  
# End of macro DMARK
2bf1					CALLMONITOR 
2bf1 cd a6 fd			call debug_vector  
2bf4				endm  
# End of macro CALLMONITOR
2bf4				endif 
2bf4			 
2bf4			 
2bf4 2a 1c f9		ld hl, (cli_data_sp) 
2bf7 11 56 f6		ld de, cli_data_stack 
2bfa ed 52		sbc hl,de 
2bfc			 
2bfc			; div by size of stack item 
2bfc			 
2bfc 5d			ld e,l 
2bfd 0e 03		ld c, 3 
2bff cd 41 0f		call Div8 
2c02			 
2c02 6f			ld l,a 
2c03 26 00		ld h,0 
2c05			 
2c05			;srl h 
2c05			;rr l 
2c05			 
2c05 cd 12 20			call forth_push_numhl 
2c08				NEXTW 
2c08 cd a3 fd			call parse_vector 
2c0b c3 f5 23			jp macro_next 
2c0e				endm 
# End of macro NEXTW
2c0e			.OVER: 
2c0e			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2c0e 42				db WORD_SYS_CORE+46             
2c0f 5e 2c			dw .PAUSE            
2c11 05				db 4 + 1 
2c12 .. 00			db "OVER",0              
2c17				endm 
# End of macro CWHEAD
2c17			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2c17			; | | >[!NOTE] 
2c17			; | | > If the copied item is a string it is properly duplicated allowing for a safe release after use.  
2c17				if DEBUG_FORTH_WORDS_KEY 
2c17					DMARK "OVR" 
2c17 f5				push af  
2c18 3a 2c 2c			ld a, (.dmark)  
2c1b 32 99 fd			ld (debug_mark),a  
2c1e 3a 2d 2c			ld a, (.dmark+1)  
2c21 32 9a fd			ld (debug_mark+1),a  
2c24 3a 2e 2c			ld a, (.dmark+2)  
2c27 32 9b fd			ld (debug_mark+2),a  
2c2a 18 03			jr .pastdmark  
2c2c ..			.dmark: db "OVR"  
2c2f f1			.pastdmark: pop af  
2c30			endm  
# End of macro DMARK
2c30					CALLMONITOR 
2c30 cd a6 fd			call debug_vector  
2c33				endm  
# End of macro CALLMONITOR
2c33				endif 
2c33			 
2c33			; TODO Use os stack swap memory 
2c33			 
2c33				; work out what type we are looking at 
2c33			 
2c33				FORTH_DSP_PTR 1 
2c33 2a 1c f9			ld hl,(cli_data_sp) 
2c36 11 03 00			ld de, 1 * 3 
2c39 ed 52			sbc hl, de 
2c3b				endm 
# End of macro FORTH_DSP_PTR
2c3b			 
2c3b 7e				ld a, (hl) 
2c3c				 
2c3c f5				push af 
2c3d				; whatever the type lets get the pointer or word 
2c3d 23				inc hl 
2c3e			;; 
2c3e			 
2c3e				; type check now to decide on how to push  
2c3e			 
2c3e cd 7b 23			call loadwordinhl 
2c41 f1				pop af 
2c42 fe 01			cp DS_TYPE_STR 
2c44 28 09			jr z, .ovstr 
2c46			 
2c46				; we have a numeric so load the word and push 
2c46			;	ld e, (hl) 
2c46			;	inc hl 
2c46			;	ld d, (hl) 
2c46			;	ex de, hl 
2c46 cd 12 20			call forth_push_numhl 
2c49				NEXTW 
2c49 cd a3 fd			call parse_vector 
2c4c c3 f5 23			jp macro_next 
2c4f				endm 
# End of macro NEXTW
2c4f			 
2c4f			.ovstr: 
2c4f				; ok, a string so get the pointer and push as a string 
2c4f			 
2c4f			;	call loadwordinhl 
2c4f cd 7c 20			call forth_push_str 
2c52				NEXTW 
2c52 cd a3 fd			call parse_vector 
2c55 c3 f5 23			jp macro_next 
2c58				endm 
# End of macro NEXTW
2c58			 
2c58			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c58			;	push hl    ; n2 
2c58			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c58			; 
2c58			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c58			;	push hl    ; n1 
2c58			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c58			; 
2c58			;	pop de     ; n1 
2c58			;	pop hl     ; n2 
2c58			; 
2c58			;	push de 
2c58			;	push hl 
2c58			;	push de 
2c58			 
2c58				; push back  
2c58			 
2c58			;	pop hl 
2c58			;	call forth_push_numhl 
2c58			;	pop hl 
2c58			;	call forth_push_numhl 
2c58			;	pop hl 
2c58			;	call forth_push_numhl 
2c58				NEXTW 
2c58 cd a3 fd			call parse_vector 
2c5b c3 f5 23			jp macro_next 
2c5e				endm 
# End of macro NEXTW
2c5e			 
2c5e			.PAUSE: 
2c5e			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2c5e 43				db WORD_SYS_CORE+47             
2c5f 96 2c			dw .PAUSES            
2c61 08				db 7 + 1 
2c62 .. 00			db "PAUSEMS",0              
2c6a				endm 
# End of macro CWHEAD
2c6a			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2c6a				if DEBUG_FORTH_WORDS_KEY 
2c6a					DMARK "PMS" 
2c6a f5				push af  
2c6b 3a 7f 2c			ld a, (.dmark)  
2c6e 32 99 fd			ld (debug_mark),a  
2c71 3a 80 2c			ld a, (.dmark+1)  
2c74 32 9a fd			ld (debug_mark+1),a  
2c77 3a 81 2c			ld a, (.dmark+2)  
2c7a 32 9b fd			ld (debug_mark+2),a  
2c7d 18 03			jr .pastdmark  
2c7f ..			.dmark: db "PMS"  
2c82 f1			.pastdmark: pop af  
2c83			endm  
# End of macro DMARK
2c83					CALLMONITOR 
2c83 cd a6 fd			call debug_vector  
2c86				endm  
# End of macro CALLMONITOR
2c86				endif 
2c86				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c86 cd 0e 22			call macro_dsp_valuehl 
2c89				endm 
# End of macro FORTH_DSP_VALUEHL
2c89			;		push hl    ; n2 
2c89				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c89 cd c6 22			call macro_forth_dsp_pop 
2c8c				endm 
# End of macro FORTH_DSP_POP
2c8c			;		pop hl 
2c8c			 
2c8c 7d				ld a, l 
2c8d cd a5 0c			call aDelayInMS 
2c90			       NEXTW 
2c90 cd a3 fd			call parse_vector 
2c93 c3 f5 23			jp macro_next 
2c96				endm 
# End of macro NEXTW
2c96			.PAUSES:  
2c96			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2c96 44				db WORD_SYS_CORE+48             
2c97 08 2d			dw .ROT            
2c99 06				db 5 + 1 
2c9a .. 00			db "PAUSE",0              
2ca0				endm 
# End of macro CWHEAD
2ca0			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2ca0				if DEBUG_FORTH_WORDS_KEY 
2ca0					DMARK "PAU" 
2ca0 f5				push af  
2ca1 3a b5 2c			ld a, (.dmark)  
2ca4 32 99 fd			ld (debug_mark),a  
2ca7 3a b6 2c			ld a, (.dmark+1)  
2caa 32 9a fd			ld (debug_mark+1),a  
2cad 3a b7 2c			ld a, (.dmark+2)  
2cb0 32 9b fd			ld (debug_mark+2),a  
2cb3 18 03			jr .pastdmark  
2cb5 ..			.dmark: db "PAU"  
2cb8 f1			.pastdmark: pop af  
2cb9			endm  
# End of macro DMARK
2cb9					CALLMONITOR 
2cb9 cd a6 fd			call debug_vector  
2cbc				endm  
# End of macro CALLMONITOR
2cbc				endif 
2cbc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2cbc cd 0e 22			call macro_dsp_valuehl 
2cbf				endm 
# End of macro FORTH_DSP_VALUEHL
2cbf			;		push hl    ; n2 
2cbf				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2cbf cd c6 22			call macro_forth_dsp_pop 
2cc2				endm 
# End of macro FORTH_DSP_POP
2cc2			;		pop hl 
2cc2 45				ld b, l 
2cc3				if DEBUG_FORTH_WORDS 
2cc3					DMARK "PAU" 
2cc3 f5				push af  
2cc4 3a d8 2c			ld a, (.dmark)  
2cc7 32 99 fd			ld (debug_mark),a  
2cca 3a d9 2c			ld a, (.dmark+1)  
2ccd 32 9a fd			ld (debug_mark+1),a  
2cd0 3a da 2c			ld a, (.dmark+2)  
2cd3 32 9b fd			ld (debug_mark+2),a  
2cd6 18 03			jr .pastdmark  
2cd8 ..			.dmark: db "PAU"  
2cdb f1			.pastdmark: pop af  
2cdc			endm  
# End of macro DMARK
2cdc					CALLMONITOR 
2cdc cd a6 fd			call debug_vector  
2cdf				endm  
# End of macro CALLMONITOR
2cdf				endif 
2cdf c5			.pauses1:	push bc 
2ce0 cd c0 0c			call delay1s 
2ce3 c1				pop bc 
2ce4				if DEBUG_FORTH_WORDS 
2ce4					DMARK "PA1" 
2ce4 f5				push af  
2ce5 3a f9 2c			ld a, (.dmark)  
2ce8 32 99 fd			ld (debug_mark),a  
2ceb 3a fa 2c			ld a, (.dmark+1)  
2cee 32 9a fd			ld (debug_mark+1),a  
2cf1 3a fb 2c			ld a, (.dmark+2)  
2cf4 32 9b fd			ld (debug_mark+2),a  
2cf7 18 03			jr .pastdmark  
2cf9 ..			.dmark: db "PA1"  
2cfc f1			.pastdmark: pop af  
2cfd			endm  
# End of macro DMARK
2cfd					CALLMONITOR 
2cfd cd a6 fd			call debug_vector  
2d00				endm  
# End of macro CALLMONITOR
2d00				endif 
2d00 10 dd			djnz .pauses1 
2d02			 
2d02			       NEXTW 
2d02 cd a3 fd			call parse_vector 
2d05 c3 f5 23			jp macro_next 
2d08				endm 
# End of macro NEXTW
2d08			.ROT: 
2d08			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2d08 45				db WORD_SYS_CORE+49             
2d09 74 2d			dw .UWORDS            
2d0b 04				db 3 + 1 
2d0c .. 00			db "ROT",0              
2d10				endm 
# End of macro CWHEAD
2d10			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2d10				if DEBUG_FORTH_WORDS_KEY 
2d10					DMARK "ROT" 
2d10 f5				push af  
2d11 3a 25 2d			ld a, (.dmark)  
2d14 32 99 fd			ld (debug_mark),a  
2d17 3a 26 2d			ld a, (.dmark+1)  
2d1a 32 9a fd			ld (debug_mark+1),a  
2d1d 3a 27 2d			ld a, (.dmark+2)  
2d20 32 9b fd			ld (debug_mark+2),a  
2d23 18 03			jr .pastdmark  
2d25 ..			.dmark: db "ROT"  
2d28 f1			.pastdmark: pop af  
2d29			endm  
# End of macro DMARK
2d29					CALLMONITOR 
2d29 cd a6 fd			call debug_vector  
2d2c				endm  
# End of macro CALLMONITOR
2d2c				endif 
2d2c			 
2d2c			; DONE Use os stack swap memory 
2d2c			 
2d2c				FORTH_DSP_PTR 0     ; u3 
2d2c 2a 1c f9			ld hl,(cli_data_sp) 
2d2f 11 00 00			ld de, 0 * 3 
2d32 ed 52			sbc hl, de 
2d34				endm 
# End of macro FORTH_DSP_PTR
2d34 cd 45 23			call hltostack1     
2d37			  
2d37				FORTH_DSP_PTR 1     ; u2 
2d37 2a 1c f9			ld hl,(cli_data_sp) 
2d3a 11 03 00			ld de, 1 * 3 
2d3d ed 52			sbc hl, de 
2d3f				endm 
# End of macro FORTH_DSP_PTR
2d3f cd 4b 23			call hltostack2      
2d42			 
2d42				FORTH_DSP_PTR 2     ; u1 
2d42 2a 1c f9			ld hl,(cli_data_sp) 
2d45 11 06 00			ld de, 2 * 3 
2d48 ed 52			sbc hl, de 
2d4a				endm 
# End of macro FORTH_DSP_PTR
2d4a cd 51 23			call hltostack3 
2d4d			 
2d4d			 
2d4d				FORTH_DSP_PTR 0     ;  
2d4d 2a 1c f9			ld hl,(cli_data_sp) 
2d50 11 00 00			ld de, 0 * 3 
2d53 ed 52			sbc hl, de 
2d55				endm 
# End of macro FORTH_DSP_PTR
2d55 cd 69 23			call hlfromstack3 
2d58			 
2d58				FORTH_DSP_PTR 1     ; TOS 
2d58 2a 1c f9			ld hl,(cli_data_sp) 
2d5b 11 03 00			ld de, 1 * 3 
2d5e ed 52			sbc hl, de 
2d60				endm 
# End of macro FORTH_DSP_PTR
2d60 cd 5d 23			call hlfromstack1 
2d63			 
2d63				FORTH_DSP_PTR 2     ; TOS 
2d63 2a 1c f9			ld hl,(cli_data_sp) 
2d66 11 06 00			ld de, 2 * 3 
2d69 ed 52			sbc hl, de 
2d6b				endm 
# End of macro FORTH_DSP_PTR
2d6b cd 63 23			call hlfromstack2 
2d6e			 
2d6e			 
2d6e			;	FORTH_DSP_VALUEHL 
2d6e			;	push hl    ; u3  
2d6e			; 
2d6e			;	FORTH_DSP_POP 
2d6e			; 
2d6e			;	FORTH_DSP_VALUEHL 
2d6e			;	push hl     ; u2 
2d6e			; 
2d6e			;	FORTH_DSP_POP 
2d6e			; 
2d6e			;	FORTH_DSP_VALUEHL 
2d6e			;	push hl     ; u1 
2d6e			; 
2d6e			;	FORTH_DSP_POP 
2d6e			; 
2d6e			;	pop bc      ; u1 
2d6e			;	pop hl      ; u2 
2d6e			;	pop de      ; u3 
2d6e			; 
2d6e			; 
2d6e			;	push bc 
2d6e			;	push de 
2d6e			;	push hl 
2d6e			; 
2d6e			; 
2d6e			;	pop hl 
2d6e			;	call forth_push_numhl 
2d6e			; 
2d6e			;	pop hl 
2d6e			;	call forth_push_numhl 
2d6e			; 
2d6e			;	pop hl 
2d6e			;	call forth_push_numhl 
2d6e				 
2d6e			 
2d6e			 
2d6e			 
2d6e			 
2d6e			 
2d6e			       NEXTW 
2d6e cd a3 fd			call parse_vector 
2d71 c3 f5 23			jp macro_next 
2d74				endm 
# End of macro NEXTW
2d74			 
2d74			.UWORDS: 
2d74			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2d74 50				db WORD_SYS_CORE+60             
2d75 39 2e			dw .BP            
2d77 07				db 6 + 1 
2d78 .. 00			db "UWORDS",0              
2d7f				endm 
# End of macro CWHEAD
2d7f			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2d7f			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2d7f			; | | Following the count are the individual words. 
2d7f			; | | 
2d7f			; | | e.g. UWORDS 
2d7f			; | | BOX DIRLIST 2 
2d7f			; | |  
2d7f			; | | Can be used to save the words to storage via: 
2d7f			; | | UWORDS $01 DO $01 APPEND LOOP 
2d7f			if DEBUG_FORTH_WORDS_KEY 
2d7f				DMARK "UWR" 
2d7f f5				push af  
2d80 3a 94 2d			ld a, (.dmark)  
2d83 32 99 fd			ld (debug_mark),a  
2d86 3a 95 2d			ld a, (.dmark+1)  
2d89 32 9a fd			ld (debug_mark+1),a  
2d8c 3a 96 2d			ld a, (.dmark+2)  
2d8f 32 9b fd			ld (debug_mark+2),a  
2d92 18 03			jr .pastdmark  
2d94 ..			.dmark: db "UWR"  
2d97 f1			.pastdmark: pop af  
2d98			endm  
# End of macro DMARK
2d98				CALLMONITOR 
2d98 cd a6 fd			call debug_vector  
2d9b				endm  
# End of macro CALLMONITOR
2d9b			endif 
2d9b 21 00 80			ld hl, baseram 
2d9e				;ld hl, baseusermem 
2d9e 01 00 00			ld bc, 0    ; start a counter 
2da1			 
2da1			; skip dict stub 
2da1			 
2da1 cd 27 25			call forth_tok_next 
2da4			 
2da4			 
2da4			; while we have words to look for 
2da4			 
2da4 7e			.douscan:	ld a, (hl)      
2da5			if DEBUG_FORTH_WORDS 
2da5				DMARK "UWs" 
2da5 f5				push af  
2da6 3a ba 2d			ld a, (.dmark)  
2da9 32 99 fd			ld (debug_mark),a  
2dac 3a bb 2d			ld a, (.dmark+1)  
2daf 32 9a fd			ld (debug_mark+1),a  
2db2 3a bc 2d			ld a, (.dmark+2)  
2db5 32 9b fd			ld (debug_mark+2),a  
2db8 18 03			jr .pastdmark  
2dba ..			.dmark: db "UWs"  
2dbd f1			.pastdmark: pop af  
2dbe			endm  
# End of macro DMARK
2dbe				CALLMONITOR 
2dbe cd a6 fd			call debug_vector  
2dc1				endm  
# End of macro CALLMONITOR
2dc1			endif 
2dc1 fe 00			cp WORD_SYS_END 
2dc3 28 4d			jr z, .udone 
2dc5 fe 01			cp WORD_SYS_UWORD 
2dc7 20 44			jr nz, .nuword 
2dc9			 
2dc9			if DEBUG_FORTH_WORDS 
2dc9				DMARK "UWu" 
2dc9 f5				push af  
2dca 3a de 2d			ld a, (.dmark)  
2dcd 32 99 fd			ld (debug_mark),a  
2dd0 3a df 2d			ld a, (.dmark+1)  
2dd3 32 9a fd			ld (debug_mark+1),a  
2dd6 3a e0 2d			ld a, (.dmark+2)  
2dd9 32 9b fd			ld (debug_mark+2),a  
2ddc 18 03			jr .pastdmark  
2dde ..			.dmark: db "UWu"  
2de1 f1			.pastdmark: pop af  
2de2			endm  
# End of macro DMARK
2de2				CALLMONITOR 
2de2 cd a6 fd			call debug_vector  
2de5				endm  
# End of macro CALLMONITOR
2de5			endif 
2de5				; we have a uword so push its name to the stack 
2de5			 
2de5 e5				push hl  ; save so we can move to next dict block 
2de6			 
2de6				; skip opcode 
2de6 23				inc hl  
2de7				; skip next ptr 
2de7 23				inc hl  
2de8 23				inc hl 
2de9				; skip len 
2de9 23				inc hl 
2dea			if DEBUG_FORTH_WORDS 
2dea				DMARK "UWt" 
2dea f5				push af  
2deb 3a ff 2d			ld a, (.dmark)  
2dee 32 99 fd			ld (debug_mark),a  
2df1 3a 00 2e			ld a, (.dmark+1)  
2df4 32 9a fd			ld (debug_mark+1),a  
2df7 3a 01 2e			ld a, (.dmark+2)  
2dfa 32 9b fd			ld (debug_mark+2),a  
2dfd 18 03			jr .pastdmark  
2dff ..			.dmark: db "UWt"  
2e02 f1			.pastdmark: pop af  
2e03			endm  
# End of macro DMARK
2e03				CALLMONITOR 
2e03 cd a6 fd			call debug_vector  
2e06				endm  
# End of macro CALLMONITOR
2e06			endif 
2e06 03				inc bc 
2e07			 
2e07 c5				push bc 
2e08 cd 7c 20			call forth_push_str 
2e0b c1				pop bc 
2e0c			 
2e0c e1				pop hl 	 
2e0d			 
2e0d cd 27 25		.nuword:	call forth_tok_next 
2e10 18 92			jr .douscan  
2e12			 
2e12			.udone:		 ; push count of uwords found 
2e12 c5				push bc 
2e13 e1				pop hl 
2e14			 
2e14			if DEBUG_FORTH_WORDS 
2e14				DMARK "UWc" 
2e14 f5				push af  
2e15 3a 29 2e			ld a, (.dmark)  
2e18 32 99 fd			ld (debug_mark),a  
2e1b 3a 2a 2e			ld a, (.dmark+1)  
2e1e 32 9a fd			ld (debug_mark+1),a  
2e21 3a 2b 2e			ld a, (.dmark+2)  
2e24 32 9b fd			ld (debug_mark+2),a  
2e27 18 03			jr .pastdmark  
2e29 ..			.dmark: db "UWc"  
2e2c f1			.pastdmark: pop af  
2e2d			endm  
# End of macro DMARK
2e2d				CALLMONITOR 
2e2d cd a6 fd			call debug_vector  
2e30				endm  
# End of macro CALLMONITOR
2e30			endif 
2e30 cd 12 20			call forth_push_numhl 
2e33			 
2e33			 
2e33			       NEXTW 
2e33 cd a3 fd			call parse_vector 
2e36 c3 f5 23			jp macro_next 
2e39				endm 
# End of macro NEXTW
2e39			 
2e39			.BP: 
2e39			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2e39 54				db WORD_SYS_CORE+64             
2e3a 79 2e			dw .MONITOR            
2e3c 03				db 2 + 1 
2e3d .. 00			db "BP",0              
2e40				endm 
# End of macro CWHEAD
2e40			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2e40			; | | $00 Will enable the break points within specific code paths 
2e40			; | | $01 Will disable break points 
2e40			; | |  
2e40			; | | By default break points are off. Either the above can be used to enable them 
2e40			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2e40			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2e40			; | | can disable break points. Exiting will then continue boot process. 
2e40				; get byte count 
2e40				if DEBUG_FORTH_WORDS_KEY 
2e40					DMARK "BP." 
2e40 f5				push af  
2e41 3a 55 2e			ld a, (.dmark)  
2e44 32 99 fd			ld (debug_mark),a  
2e47 3a 56 2e			ld a, (.dmark+1)  
2e4a 32 9a fd			ld (debug_mark+1),a  
2e4d 3a 57 2e			ld a, (.dmark+2)  
2e50 32 9b fd			ld (debug_mark+2),a  
2e53 18 03			jr .pastdmark  
2e55 ..			.dmark: db "BP."  
2e58 f1			.pastdmark: pop af  
2e59			endm  
# End of macro DMARK
2e59					CALLMONITOR 
2e59 cd a6 fd			call debug_vector  
2e5c				endm  
# End of macro CALLMONITOR
2e5c				endif 
2e5c			 
2e5c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e5c cd 0e 22			call macro_dsp_valuehl 
2e5f				endm 
# End of macro FORTH_DSP_VALUEHL
2e5f			 
2e5f			;		push hl 
2e5f			 
2e5f				; destroy value TOS 
2e5f			 
2e5f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e5f cd c6 22			call macro_forth_dsp_pop 
2e62				endm 
# End of macro FORTH_DSP_POP
2e62			 
2e62			;		pop hl 
2e62			 
2e62 3e 00			ld a,0 
2e64 bd				cp l 
2e65 28 09			jr z, .bpset 
2e67			;		ld a, '*' 
2e67 cd ed 18			call bp_off 
2e6a				NEXTW 
2e6a cd a3 fd			call parse_vector 
2e6d c3 f5 23			jp macro_next 
2e70				endm 
# End of macro NEXTW
2e70			 
2e70			.bpset:	 
2e70				;	ld (os_view_disable), a 
2e70 cd e1 18			call bp_on 
2e73			 
2e73			 
2e73				NEXTW 
2e73 cd a3 fd			call parse_vector 
2e76 c3 f5 23			jp macro_next 
2e79				endm 
# End of macro NEXTW
2e79			 
2e79			 
2e79			.MONITOR: 
2e79			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2e79 55				db WORD_SYS_CORE+65             
2e7a ad 2e			dw .MALLOC            
2e7c 08				db 7 + 1 
2e7d .. 00			db "MONITOR",0              
2e85				endm 
# End of macro CWHEAD
2e85			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2e85			; | | At start the current various registers will be displayed with contents. 
2e85			; | | Top right corner will show the most recent debug marker seen. 
2e85			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2e85			; | | and the return stack pointer (RSP). 
2e85			; | | Pressing: 
2e85			; | |  
2e85			; | |    1 - Initial screen 
2e85			; | |  
2e85			; | |    2 - Display a data dump of HL 
2e85			; | |  
2e85			; | |    3 - Display a data dump of DE 
2e85			; | |  
2e85			; | |    4 - Display a data dump of BC 
2e85			; | |  
2e85			; | |    5 - Display a data dump of HL 
2e85			; | |  
2e85			; | |    6 - Display a data dump of DSP 
2e85			; | |  
2e85			; | |    7 - Display a data dump of RSP 
2e85			; | |  
2e85			; | |    8 - Display a data dump of what is at DSP 
2e85			; | |  
2e85			; | |    9 - Display a data dump of what is at RSP 
2e85			; | |  
2e85			; | |    0 - Exit monitor and continue running. This will also enable break points 
2e85			; | |  
2e85			; | |    * - Disable break points 
2e85			; | |  
2e85			; | |    # - Enter traditional monitor mode 
2e85			; | |  
2e85			; | | 
2e85			; | | Monitor Mode 
2e85			; | | ------------ 
2e85			; | | A prompt of '>' will be shown for various commands: 
2e85			; | |  
2e85			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2e85			; | |  
2e85			; | |    C - Continue display a data dump from the last set address 
2e85			; | |  
2e85			; | |    M xxxx - Set start of memory edit at address xx 
2e85			; | |  
2e85			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2e85			; | |  
2e85			; | |    G xxxx - Exec code at specific address 
2e85			; | |  
2e85			; | |    Q - Return to previous 
2e85				if DEBUG_FORTH_WORDS_KEY 
2e85					DMARK "MON" 
2e85 f5				push af  
2e86 3a 9a 2e			ld a, (.dmark)  
2e89 32 99 fd			ld (debug_mark),a  
2e8c 3a 9b 2e			ld a, (.dmark+1)  
2e8f 32 9a fd			ld (debug_mark+1),a  
2e92 3a 9c 2e			ld a, (.dmark+2)  
2e95 32 9b fd			ld (debug_mark+2),a  
2e98 18 03			jr .pastdmark  
2e9a ..			.dmark: db "MON"  
2e9d f1			.pastdmark: pop af  
2e9e			endm  
# End of macro DMARK
2e9e					CALLMONITOR 
2e9e cd a6 fd			call debug_vector  
2ea1				endm  
# End of macro CALLMONITOR
2ea1				endif 
2ea1			;		ld a, 0 
2ea1			;		ld (os_view_disable), a 
2ea1 cd e1 18			call bp_on 
2ea4			 
2ea4				CALLMONITOR 
2ea4 cd a6 fd			call debug_vector  
2ea7				endm  
# End of macro CALLMONITOR
2ea7			 
2ea7			;	call monitor 
2ea7			 
2ea7				NEXTW 
2ea7 cd a3 fd			call parse_vector 
2eaa c3 f5 23			jp macro_next 
2ead				endm 
# End of macro NEXTW
2ead			 
2ead			 
2ead			.MALLOC: 
2ead			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2ead 56				db WORD_SYS_CORE+66             
2eae d6 2e			dw .MALLOC2            
2eb0 06				db 5 + 1 
2eb1 .. 00			db "ALLOT",0              
2eb7				endm 
# End of macro CWHEAD
2eb7			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2eb7				if DEBUG_FORTH_WORDS_KEY 
2eb7					DMARK "ALL" 
2eb7 f5				push af  
2eb8 3a cc 2e			ld a, (.dmark)  
2ebb 32 99 fd			ld (debug_mark),a  
2ebe 3a cd 2e			ld a, (.dmark+1)  
2ec1 32 9a fd			ld (debug_mark+1),a  
2ec4 3a ce 2e			ld a, (.dmark+2)  
2ec7 32 9b fd			ld (debug_mark+2),a  
2eca 18 03			jr .pastdmark  
2ecc ..			.dmark: db "ALL"  
2ecf f1			.pastdmark: pop af  
2ed0			endm  
# End of macro DMARK
2ed0					CALLMONITOR 
2ed0 cd a6 fd			call debug_vector  
2ed3				endm  
# End of macro CALLMONITOR
2ed3				endif 
2ed3 c3 fd 2e			jp .mallocc 
2ed6			.MALLOC2: 
2ed6			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2ed6 56				db WORD_SYS_CORE+66             
2ed7 17 2f			dw .FREE            
2ed9 07				db 6 + 1 
2eda .. 00			db "MALLOC",0              
2ee1				endm 
# End of macro CWHEAD
2ee1			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2ee1				; get byte count 
2ee1				if DEBUG_FORTH_WORDS_KEY 
2ee1					DMARK "MAL" 
2ee1 f5				push af  
2ee2 3a f6 2e			ld a, (.dmark)  
2ee5 32 99 fd			ld (debug_mark),a  
2ee8 3a f7 2e			ld a, (.dmark+1)  
2eeb 32 9a fd			ld (debug_mark+1),a  
2eee 3a f8 2e			ld a, (.dmark+2)  
2ef1 32 9b fd			ld (debug_mark+2),a  
2ef4 18 03			jr .pastdmark  
2ef6 ..			.dmark: db "MAL"  
2ef9 f1			.pastdmark: pop af  
2efa			endm  
# End of macro DMARK
2efa					CALLMONITOR 
2efa cd a6 fd			call debug_vector  
2efd				endm  
# End of macro CALLMONITOR
2efd				endif 
2efd			.mallocc: 
2efd				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2efd cd 0e 22			call macro_dsp_valuehl 
2f00				endm 
# End of macro FORTH_DSP_VALUEHL
2f00			 
2f00			;		push hl 
2f00			 
2f00				; destroy value TOS 
2f00			 
2f00				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f00 cd c6 22			call macro_forth_dsp_pop 
2f03				endm 
# End of macro FORTH_DSP_POP
2f03			 
2f03			;		pop hl 
2f03 cd 7d 13			call malloc 
2f06			if DEBUG_FORTH_MALLOC_GUARD 
2f06 f5				push af 
2f07 cd da 0f			call ishlzero 
2f0a			;		ld a, l 
2f0a			;		add h 
2f0a			;		cp 0 
2f0a f1				pop af 
2f0b				 
2f0b cc 3c 66			call z,malloc_error 
2f0e			endif 
2f0e			 
2f0e cd 12 20			call forth_push_numhl 
2f11				NEXTW 
2f11 cd a3 fd			call parse_vector 
2f14 c3 f5 23			jp macro_next 
2f17				endm 
# End of macro NEXTW
2f17			 
2f17			.FREE: 
2f17			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
2f17 57				db WORD_SYS_CORE+67             
2f18 4b 2f			dw .UPTR            
2f1a 05				db 4 + 1 
2f1b .. 00			db "FREE",0              
2f20				endm 
# End of macro CWHEAD
2f20			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2f20				if DEBUG_FORTH_WORDS_KEY 
2f20					DMARK "FRE" 
2f20 f5				push af  
2f21 3a 35 2f			ld a, (.dmark)  
2f24 32 99 fd			ld (debug_mark),a  
2f27 3a 36 2f			ld a, (.dmark+1)  
2f2a 32 9a fd			ld (debug_mark+1),a  
2f2d 3a 37 2f			ld a, (.dmark+2)  
2f30 32 9b fd			ld (debug_mark+2),a  
2f33 18 03			jr .pastdmark  
2f35 ..			.dmark: db "FRE"  
2f38 f1			.pastdmark: pop af  
2f39			endm  
# End of macro DMARK
2f39					CALLMONITOR 
2f39 cd a6 fd			call debug_vector  
2f3c				endm  
# End of macro CALLMONITOR
2f3c				endif 
2f3c				; get address 
2f3c			 
2f3c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f3c cd 0e 22			call macro_dsp_valuehl 
2f3f				endm 
# End of macro FORTH_DSP_VALUEHL
2f3f			 
2f3f			;		push hl 
2f3f			 
2f3f				; destroy value TOS 
2f3f			 
2f3f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f3f cd c6 22			call macro_forth_dsp_pop 
2f42				endm 
# End of macro FORTH_DSP_POP
2f42			 
2f42			;		pop hl 
2f42			if FORTH_ENABLE_MALLOCFREE 
2f42 cd 47 14			call free 
2f45			endif 
2f45				NEXTW 
2f45 cd a3 fd			call parse_vector 
2f48 c3 f5 23			jp macro_next 
2f4b				endm 
# End of macro NEXTW
2f4b			.UPTR: 
2f4b			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
2f4b 57				db WORD_SYS_CORE+67             
2f4c 51 30			dw .LIST            
2f4e 05				db 4 + 1 
2f4f .. 00			db "UPTR",0              
2f54				endm 
# End of macro CWHEAD
2f54			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
2f54				if DEBUG_FORTH_WORDS_KEY 
2f54					DMARK "UPT" 
2f54 f5				push af  
2f55 3a 69 2f			ld a, (.dmark)  
2f58 32 99 fd			ld (debug_mark),a  
2f5b 3a 6a 2f			ld a, (.dmark+1)  
2f5e 32 9a fd			ld (debug_mark+1),a  
2f61 3a 6b 2f			ld a, (.dmark+2)  
2f64 32 9b fd			ld (debug_mark+2),a  
2f67 18 03			jr .pastdmark  
2f69 ..			.dmark: db "UPT"  
2f6c f1			.pastdmark: pop af  
2f6d			endm  
# End of macro DMARK
2f6d					CALLMONITOR 
2f6d cd a6 fd			call debug_vector  
2f70				endm  
# End of macro CALLMONITOR
2f70				endif 
2f70				FORTH_DSP_VALUEHL 
2f70 cd 0e 22			call macro_dsp_valuehl 
2f73				endm 
# End of macro FORTH_DSP_VALUEHL
2f73			 
2f73 e5				push hl 
2f74				FORTH_DSP_POP 
2f74 cd c6 22			call macro_forth_dsp_pop 
2f77				endm 
# End of macro FORTH_DSP_POP
2f77 c1				pop bc 
2f78			 
2f78			 
2f78				; Get ptr to the word we need to look up 
2f78			 
2f78			;		FORTH_DSP_VALUEHL 
2f78				;v5 FORTH_DSP_VALUE 
2f78			; TODO type check 
2f78			;		inc hl    ; Skip type check  
2f78			;		push hl 
2f78			;		ex de, hl    ; put into DE 
2f78			 
2f78			 
2f78 21 00 80			ld hl, baseram 
2f7b				;ld hl, baseusermem 
2f7b			 
2f7b e5			push hl   ; sacreifical push 
2f7c			 
2f7c			.uldouscanm: 
2f7c e1			pop hl 
2f7d			.uldouscan: 
2f7d			if DEBUG_FORTH_WORDS 
2f7d				DMARK "LSs" 
2f7d f5				push af  
2f7e 3a 92 2f			ld a, (.dmark)  
2f81 32 99 fd			ld (debug_mark),a  
2f84 3a 93 2f			ld a, (.dmark+1)  
2f87 32 9a fd			ld (debug_mark+1),a  
2f8a 3a 94 2f			ld a, (.dmark+2)  
2f8d 32 9b fd			ld (debug_mark+2),a  
2f90 18 03			jr .pastdmark  
2f92 ..			.dmark: db "LSs"  
2f95 f1			.pastdmark: pop af  
2f96			endm  
# End of macro DMARK
2f96				CALLMONITOR 
2f96 cd a6 fd			call debug_vector  
2f99				endm  
# End of macro CALLMONITOR
2f99			endif 
2f99			; skip dict stub 
2f99 cd 27 25			call forth_tok_next 
2f9c			 
2f9c			 
2f9c			; while we have words to look for 
2f9c			 
2f9c 7e			ld a, (hl)      
2f9d			if DEBUG_FORTH_WORDS 
2f9d				DMARK "LSk" 
2f9d f5				push af  
2f9e 3a b2 2f			ld a, (.dmark)  
2fa1 32 99 fd			ld (debug_mark),a  
2fa4 3a b3 2f			ld a, (.dmark+1)  
2fa7 32 9a fd			ld (debug_mark+1),a  
2faa 3a b4 2f			ld a, (.dmark+2)  
2fad 32 9b fd			ld (debug_mark+2),a  
2fb0 18 03			jr .pastdmark  
2fb2 ..			.dmark: db "LSk"  
2fb5 f1			.pastdmark: pop af  
2fb6			endm  
# End of macro DMARK
2fb6				CALLMONITOR 
2fb6 cd a6 fd			call debug_vector  
2fb9				endm  
# End of macro CALLMONITOR
2fb9			endif 
2fb9				;cp WORD_SYS_END 
2fb9				;jp z, .lunotfound 
2fb9			 
2fb9					; if we hit non uwords then gone too far 
2fb9 fe 01				cp WORD_SYS_UWORD 
2fbb c2 48 30				jp nz, .ulunotfound 
2fbe			 
2fbe				if DEBUG_FORTH_WORDS 
2fbe					DMARK "LSu" 
2fbe f5				push af  
2fbf 3a d3 2f			ld a, (.dmark)  
2fc2 32 99 fd			ld (debug_mark),a  
2fc5 3a d4 2f			ld a, (.dmark+1)  
2fc8 32 9a fd			ld (debug_mark+1),a  
2fcb 3a d5 2f			ld a, (.dmark+2)  
2fce 32 9b fd			ld (debug_mark+2),a  
2fd1 18 03			jr .pastdmark  
2fd3 ..			.dmark: db "LSu"  
2fd6 f1			.pastdmark: pop af  
2fd7			endm  
# End of macro DMARK
2fd7					CALLMONITOR 
2fd7 cd a6 fd			call debug_vector  
2fda				endm  
# End of macro CALLMONITOR
2fda				endif 
2fda			 
2fda					; found a uword but is it the one we want... 
2fda			 
2fda c5					push bc     ; uword to find is on bc 
2fdb d1					pop de 
2fdc			 
2fdc e5					push hl  ; to save the ptr 
2fdd			 
2fdd					; skip opcode 
2fdd 23					inc hl  
2fde					; skip next ptr 
2fde 23					inc hl  
2fdf 23					inc hl 
2fe0					; skip len 
2fe0 23					inc hl 
2fe1			 
2fe1				if DEBUG_FORTH_WORDS 
2fe1					DMARK "LSc" 
2fe1 f5				push af  
2fe2 3a f6 2f			ld a, (.dmark)  
2fe5 32 99 fd			ld (debug_mark),a  
2fe8 3a f7 2f			ld a, (.dmark+1)  
2feb 32 9a fd			ld (debug_mark+1),a  
2fee 3a f8 2f			ld a, (.dmark+2)  
2ff1 32 9b fd			ld (debug_mark+2),a  
2ff4 18 03			jr .pastdmark  
2ff6 ..			.dmark: db "LSc"  
2ff9 f1			.pastdmark: pop af  
2ffa			endm  
# End of macro DMARK
2ffa					CALLMONITOR 
2ffa cd a6 fd			call debug_vector  
2ffd				endm  
# End of macro CALLMONITOR
2ffd				endif 
2ffd			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2ffd			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2ffd			; Nope that has gone the other way. It needs to be exact not on first zero 
2ffd			;		call strcmp 
2ffd c5					push bc 
2ffe cd 4d 13				call StrictStrCmp 
3001 c1					pop bc 
3002 c2 7c 2f				jp nz, .uldouscanm 
3005				 
3005			 
3005			 
3005					; we have a uword so push its name to the stack 
3005			 
3005			;	   	push hl  ; save so we can move to next dict block 
3005 e1			pop hl 
3006			 
3006				if DEBUG_FORTH_WORDS 
3006					DMARK "LSm" 
3006 f5				push af  
3007 3a 1b 30			ld a, (.dmark)  
300a 32 99 fd			ld (debug_mark),a  
300d 3a 1c 30			ld a, (.dmark+1)  
3010 32 9a fd			ld (debug_mark+1),a  
3013 3a 1d 30			ld a, (.dmark+2)  
3016 32 9b fd			ld (debug_mark+2),a  
3019 18 03			jr .pastdmark  
301b ..			.dmark: db "LSm"  
301e f1			.pastdmark: pop af  
301f			endm  
# End of macro DMARK
301f					CALLMONITOR 
301f cd a6 fd			call debug_vector  
3022				endm  
# End of macro CALLMONITOR
3022				endif 
3022			 
3022					; skip opcode 
3022 23					inc hl  
3023					; skip next ptr 
3023 23					inc hl  
3024 23					inc hl 
3025					; skip len 
3025 7e					ld a, (hl)   ; save length to add 
3026				if DEBUG_FORTH_WORDS 
3026					DMARK "LS2" 
3026 f5				push af  
3027 3a 3b 30			ld a, (.dmark)  
302a 32 99 fd			ld (debug_mark),a  
302d 3a 3c 30			ld a, (.dmark+1)  
3030 32 9a fd			ld (debug_mark+1),a  
3033 3a 3d 30			ld a, (.dmark+2)  
3036 32 9b fd			ld (debug_mark+2),a  
3039 18 03			jr .pastdmark  
303b ..			.dmark: db "LS2"  
303e f1			.pastdmark: pop af  
303f			endm  
# End of macro DMARK
303f					CALLMONITOR 
303f cd a6 fd			call debug_vector  
3042				endm  
# End of macro CALLMONITOR
3042				endif 
3042			 
3042				; skip zero term and other uword defs to position right at the exec code 
3042 06 04			ld b, 4 
3044 80				add a,b 
3045			 
3045 cd b1 0f			call addatohl 
3048					; save this location 
3048				 
3048			.ulunotfound: 
3048 cd 12 20			call forth_push_numhl 
304b						 
304b				NEXTW 
304b cd a3 fd			call parse_vector 
304e c3 f5 23			jp macro_next 
3051				endm 
# End of macro NEXTW
3051			.LIST: 
3051			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
3051 5c				db WORD_SYS_CORE+72             
3052 53 32			dw .FORGET            
3054 05				db 4 + 1 
3055 .. 00			db "LIST",0              
305a				endm 
# End of macro CWHEAD
305a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
305a			; | | The quoted word must be in upper case. 
305a			if DEBUG_FORTH_WORDS_KEY 
305a				DMARK "LST" 
305a f5				push af  
305b 3a 6f 30			ld a, (.dmark)  
305e 32 99 fd			ld (debug_mark),a  
3061 3a 70 30			ld a, (.dmark+1)  
3064 32 9a fd			ld (debug_mark+1),a  
3067 3a 71 30			ld a, (.dmark+2)  
306a 32 9b fd			ld (debug_mark+2),a  
306d 18 03			jr .pastdmark  
306f ..			.dmark: db "LST"  
3072 f1			.pastdmark: pop af  
3073			endm  
# End of macro DMARK
3073				CALLMONITOR 
3073 cd a6 fd			call debug_vector  
3076				endm  
# End of macro CALLMONITOR
3076			endif 
3076			 
3076				FORTH_DSP_VALUEHL 
3076 cd 0e 22			call macro_dsp_valuehl 
3079				endm 
# End of macro FORTH_DSP_VALUEHL
3079			 
3079 e5				push hl 
307a				FORTH_DSP_POP 
307a cd c6 22			call macro_forth_dsp_pop 
307d				endm 
# End of macro FORTH_DSP_POP
307d c1				pop bc 
307e			 
307e			; Start format of scratch string 
307e			 
307e 21 ef f0			ld hl, scratch 
3081			 
3081			;	ld a, ':' 
3081 36 3a			ld (hl),':' 
3083 23				inc hl 
3084			;	ld a, ' ' 
3084 36 20			ld (hl), ' ' 
3086			 
3086				; Get ptr to the word we need to look up 
3086			 
3086			;		FORTH_DSP_VALUEHL 
3086				;v5 FORTH_DSP_VALUE 
3086			; TODO type check 
3086			;		inc hl    ; Skip type check  
3086			;		push hl 
3086			;		ex de, hl    ; put into DE 
3086			 
3086			 
3086 21 00 80			ld hl, baseram 
3089				;ld hl, baseusermem 
3089			 
3089 e5			push hl   ; sacreifical push 
308a			 
308a			.ldouscanm: 
308a e1			pop hl 
308b			.ldouscan: 
308b			if DEBUG_FORTH_WORDS 
308b				DMARK "LSs" 
308b f5				push af  
308c 3a a0 30			ld a, (.dmark)  
308f 32 99 fd			ld (debug_mark),a  
3092 3a a1 30			ld a, (.dmark+1)  
3095 32 9a fd			ld (debug_mark+1),a  
3098 3a a2 30			ld a, (.dmark+2)  
309b 32 9b fd			ld (debug_mark+2),a  
309e 18 03			jr .pastdmark  
30a0 ..			.dmark: db "LSs"  
30a3 f1			.pastdmark: pop af  
30a4			endm  
# End of macro DMARK
30a4				CALLMONITOR 
30a4 cd a6 fd			call debug_vector  
30a7				endm  
# End of macro CALLMONITOR
30a7			endif 
30a7			; skip dict stub 
30a7 cd 27 25			call forth_tok_next 
30aa			 
30aa			 
30aa			; while we have words to look for 
30aa			 
30aa 7e			ld a, (hl)      
30ab			if DEBUG_FORTH_WORDS 
30ab				DMARK "LSk" 
30ab f5				push af  
30ac 3a c0 30			ld a, (.dmark)  
30af 32 99 fd			ld (debug_mark),a  
30b2 3a c1 30			ld a, (.dmark+1)  
30b5 32 9a fd			ld (debug_mark+1),a  
30b8 3a c2 30			ld a, (.dmark+2)  
30bb 32 9b fd			ld (debug_mark+2),a  
30be 18 03			jr .pastdmark  
30c0 ..			.dmark: db "LSk"  
30c3 f1			.pastdmark: pop af  
30c4			endm  
# End of macro DMARK
30c4				CALLMONITOR 
30c4 cd a6 fd			call debug_vector  
30c7				endm  
# End of macro CALLMONITOR
30c7			endif 
30c7				;cp WORD_SYS_END 
30c7				;jp z, .lunotfound 
30c7			 
30c7					; if we hit non uwords then gone too far 
30c7 fe 01				cp WORD_SYS_UWORD 
30c9 c2 06 32				jp nz, .lunotfound 
30cc			 
30cc				if DEBUG_FORTH_WORDS 
30cc					DMARK "LSu" 
30cc f5				push af  
30cd 3a e1 30			ld a, (.dmark)  
30d0 32 99 fd			ld (debug_mark),a  
30d3 3a e2 30			ld a, (.dmark+1)  
30d6 32 9a fd			ld (debug_mark+1),a  
30d9 3a e3 30			ld a, (.dmark+2)  
30dc 32 9b fd			ld (debug_mark+2),a  
30df 18 03			jr .pastdmark  
30e1 ..			.dmark: db "LSu"  
30e4 f1			.pastdmark: pop af  
30e5			endm  
# End of macro DMARK
30e5					CALLMONITOR 
30e5 cd a6 fd			call debug_vector  
30e8				endm  
# End of macro CALLMONITOR
30e8				endif 
30e8			 
30e8					; found a uword but is it the one we want... 
30e8			 
30e8 c5					push bc     ; uword to find is on bc 
30e9 d1					pop de 
30ea			 
30ea e5					push hl  ; to save the ptr 
30eb			 
30eb					; skip opcode 
30eb 23					inc hl  
30ec					; skip next ptr 
30ec 23					inc hl  
30ed 23					inc hl 
30ee					; skip len 
30ee 23					inc hl 
30ef			 
30ef				if DEBUG_FORTH_WORDS 
30ef					DMARK "LSc" 
30ef f5				push af  
30f0 3a 04 31			ld a, (.dmark)  
30f3 32 99 fd			ld (debug_mark),a  
30f6 3a 05 31			ld a, (.dmark+1)  
30f9 32 9a fd			ld (debug_mark+1),a  
30fc 3a 06 31			ld a, (.dmark+2)  
30ff 32 9b fd			ld (debug_mark+2),a  
3102 18 03			jr .pastdmark  
3104 ..			.dmark: db "LSc"  
3107 f1			.pastdmark: pop af  
3108			endm  
# End of macro DMARK
3108					CALLMONITOR 
3108 cd a6 fd			call debug_vector  
310b				endm  
# End of macro CALLMONITOR
310b				endif 
310b			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
310b			; ie. If WOO is defined first and then WO. Couldnt list WO. 
310b			; Nope that has gone the other way. It needs to be exact not on first zero 
310b			;		call strcmp 
310b c5					push bc 
310c cd 4d 13				call StrictStrCmp 
310f c1					pop bc 
3110 c2 8a 30				jp nz, .ldouscanm 
3113				 
3113			 
3113			 
3113					; we have a uword so push its name to the stack 
3113			 
3113			;	   	push hl  ; save so we can move to next dict block 
3113 e1			pop hl 
3114			 
3114				if DEBUG_FORTH_WORDS 
3114					DMARK "LSm" 
3114 f5				push af  
3115 3a 29 31			ld a, (.dmark)  
3118 32 99 fd			ld (debug_mark),a  
311b 3a 2a 31			ld a, (.dmark+1)  
311e 32 9a fd			ld (debug_mark+1),a  
3121 3a 2b 31			ld a, (.dmark+2)  
3124 32 9b fd			ld (debug_mark+2),a  
3127 18 03			jr .pastdmark  
3129 ..			.dmark: db "LSm"  
312c f1			.pastdmark: pop af  
312d			endm  
# End of macro DMARK
312d					CALLMONITOR 
312d cd a6 fd			call debug_vector  
3130				endm  
# End of macro CALLMONITOR
3130				endif 
3130			 
3130					; skip opcode 
3130 23					inc hl  
3131					; skip next ptr 
3131 23					inc hl  
3132 23					inc hl 
3133					; skip len 
3133 7e					ld a, (hl)   ; save length to add 
3134				if DEBUG_FORTH_WORDS 
3134					DMARK "LS2" 
3134 f5				push af  
3135 3a 49 31			ld a, (.dmark)  
3138 32 99 fd			ld (debug_mark),a  
313b 3a 4a 31			ld a, (.dmark+1)  
313e 32 9a fd			ld (debug_mark+1),a  
3141 3a 4b 31			ld a, (.dmark+2)  
3144 32 9b fd			ld (debug_mark+2),a  
3147 18 03			jr .pastdmark  
3149 ..			.dmark: db "LS2"  
314c f1			.pastdmark: pop af  
314d			endm  
# End of macro DMARK
314d					CALLMONITOR 
314d cd a6 fd			call debug_vector  
3150				endm  
# End of macro CALLMONITOR
3150				endif 
3150			 
3150					; save this location 
3150				 
3150 e5					push hl 
3151			 
3151 23					inc hl 
3152 11 f1 f0				ld de, scratch+2 
3155 4f					ld c, a 
3156 06 00				ld b, 0 
3158			 
3158				if DEBUG_FORTH_WORDS 
3158					DMARK "LSn" 
3158 f5				push af  
3159 3a 6d 31			ld a, (.dmark)  
315c 32 99 fd			ld (debug_mark),a  
315f 3a 6e 31			ld a, (.dmark+1)  
3162 32 9a fd			ld (debug_mark+1),a  
3165 3a 6f 31			ld a, (.dmark+2)  
3168 32 9b fd			ld (debug_mark+2),a  
316b 18 03			jr .pastdmark  
316d ..			.dmark: db "LSn"  
3170 f1			.pastdmark: pop af  
3171			endm  
# End of macro DMARK
3171					CALLMONITOR 
3171 cd a6 fd			call debug_vector  
3174				endm  
# End of macro CALLMONITOR
3174				endif 
3174			 
3174					; copy uword name to scratch 
3174			 
3174			;		ldir 
3174			.licplw:	; copy uword name to scratch converting to lower case as we go 
3174 ed a0				ldi 
3176 1b					dec de 
3177 1a					ld a, (de) 
3178 cd 22 12				call to_lower 
317b 12					ld (de),a 
317c 13					inc de 
317d 3e 00				ld a, 0 
317f b9					cp c 
3180 20 f2				jr nz, .licplw 
3182			 
3182			 
3182			 
3182 1b					dec de 
3183 3e 20				ld a, ' '    ; change null to space 
3185 12					ld (de), a 
3186			 
3186 13					inc de 
3187			 
3187 d5					push de 
3188 c1					pop bc     ; move scratch pointer to end of word name and save it 
3189			 
3189 e1					pop hl 
318a 7e					ld a, (hl) 
318b					;inc hl 
318b					; skip word string 
318b cd b1 0f				call addatohl 
318e			 
318e 23					inc hl 
318f			 
318f				if DEBUG_FORTH_WORDS 
318f					DMARK "LS3" 
318f f5				push af  
3190 3a a4 31			ld a, (.dmark)  
3193 32 99 fd			ld (debug_mark),a  
3196 3a a5 31			ld a, (.dmark+1)  
3199 32 9a fd			ld (debug_mark+1),a  
319c 3a a6 31			ld a, (.dmark+2)  
319f 32 9b fd			ld (debug_mark+2),a  
31a2 18 03			jr .pastdmark  
31a4 ..			.dmark: db "LS3"  
31a7 f1			.pastdmark: pop af  
31a8			endm  
# End of macro DMARK
31a8					CALLMONITOR 
31a8 cd a6 fd			call debug_vector  
31ab				endm  
# End of macro CALLMONITOR
31ab				endif 
31ab					; should now be at the start of the machine code to setup the eval of the uword 
31ab					; now locate the ptr to the string defintion 
31ab			 
31ab					; skip ld hl, 
31ab					; then load the ptr 
31ab			; TODO use get from hl ptr 
31ab 23					inc hl 
31ac 5e					ld e, (hl) 
31ad 23					inc hl 
31ae 56					ld d, (hl) 
31af eb					ex de, hl 
31b0			 
31b0			 
31b0				if DEBUG_FORTH_WORDS 
31b0					DMARK "LSt" 
31b0 f5				push af  
31b1 3a c5 31			ld a, (.dmark)  
31b4 32 99 fd			ld (debug_mark),a  
31b7 3a c6 31			ld a, (.dmark+1)  
31ba 32 9a fd			ld (debug_mark+1),a  
31bd 3a c7 31			ld a, (.dmark+2)  
31c0 32 9b fd			ld (debug_mark+2),a  
31c3 18 03			jr .pastdmark  
31c5 ..			.dmark: db "LSt"  
31c8 f1			.pastdmark: pop af  
31c9			endm  
# End of macro DMARK
31c9					CALLMONITOR 
31c9 cd a6 fd			call debug_vector  
31cc				endm  
# End of macro CALLMONITOR
31cc				endif 
31cc			 
31cc			; cant push right now due to tokenised strings  
31cc			 
31cc			; get the destination of where to copy this definition to. 
31cc			 
31cc c5					push bc 
31cd d1					pop de 
31ce			 
31ce 7e			.listl:         ld a,(hl) 
31cf			;		cp 0 
31cf b7					or a 
31d0 28 09				jr z, .lreplsp     ; replace zero with space 
31d2					;cp FORTH_END_BUFFER 
31d2 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
31d4 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
31d6				 
31d6					; just copy this char as is then 
31d6			 
31d6 12					ld (de), a 
31d7			 
31d7 23			.listnxt:	inc hl 
31d8 13					inc de 
31d9 18 f3				jr .listl 
31db			 
31db 3e 20		.lreplsp:	ld a,' ' 
31dd 12					ld (de), a 
31de 18 f7				jr .listnxt 
31e0			 
31e0			; close up uword def 
31e0			 
31e0			.listdone: 
31e0 12					ld (de), a 
31e1 13					inc de 
31e2 3e 00				ld a, 0 
31e4 12					ld (de), a 
31e5			 
31e5			; now have def so clean up and push to stack 
31e5			 
31e5 21 ef f0				ld hl, scratch 
31e8				if DEBUG_FORTH_WORDS 
31e8					DMARK "Ltp" 
31e8 f5				push af  
31e9 3a fd 31			ld a, (.dmark)  
31ec 32 99 fd			ld (debug_mark),a  
31ef 3a fe 31			ld a, (.dmark+1)  
31f2 32 9a fd			ld (debug_mark+1),a  
31f5 3a ff 31			ld a, (.dmark+2)  
31f8 32 9b fd			ld (debug_mark+2),a  
31fb 18 03			jr .pastdmark  
31fd ..			.dmark: db "Ltp"  
3200 f1			.pastdmark: pop af  
3201			endm  
# End of macro DMARK
3201					CALLMONITOR 
3201 cd a6 fd			call debug_vector  
3204				endm  
# End of macro CALLMONITOR
3204				endif 
3204			 
3204 18 22			jr .listpush 
3206			 
3206			;.lnuword:	pop hl 
3206			;		call forth_tok_next 
3206			;		jp .ldouscan  
3206			 
3206			.lunotfound:		  
3206			 
3206				if DEBUG_FORTH_WORDS 
3206					DMARK "LSn" 
3206 f5				push af  
3207 3a 1b 32			ld a, (.dmark)  
320a 32 99 fd			ld (debug_mark),a  
320d 3a 1c 32			ld a, (.dmark+1)  
3210 32 9a fd			ld (debug_mark+1),a  
3213 3a 1d 32			ld a, (.dmark+2)  
3216 32 9b fd			ld (debug_mark+2),a  
3219 18 03			jr .pastdmark  
321b ..			.dmark: db "LSn"  
321e f1			.pastdmark: pop af  
321f			endm  
# End of macro DMARK
321f					CALLMONITOR 
321f cd a6 fd			call debug_vector  
3222				endm  
# End of macro CALLMONITOR
3222				endif 
3222			 
3222					 
3222			;		FORTH_DSP_POP 
3222			;		ld hl, .luno 
3222			 
3222					NEXTW			 
3222 cd a3 fd			call parse_vector 
3225 c3 f5 23			jp macro_next 
3228				endm 
# End of macro NEXTW
3228			 
3228			.listpush: 
3228				if DEBUG_FORTH_WORDS 
3228					DMARK "LS>" 
3228 f5				push af  
3229 3a 3d 32			ld a, (.dmark)  
322c 32 99 fd			ld (debug_mark),a  
322f 3a 3e 32			ld a, (.dmark+1)  
3232 32 9a fd			ld (debug_mark+1),a  
3235 3a 3f 32			ld a, (.dmark+2)  
3238 32 9b fd			ld (debug_mark+2),a  
323b 18 03			jr .pastdmark  
323d ..			.dmark: db "LS>"  
3240 f1			.pastdmark: pop af  
3241			endm  
# End of macro DMARK
3241					CALLMONITOR 
3241 cd a6 fd			call debug_vector  
3244				endm  
# End of macro CALLMONITOR
3244				endif 
3244 cd 7c 20				call forth_push_str 
3247			 
3247			 
3247			 
3247					NEXTW 
3247 cd a3 fd			call parse_vector 
324a c3 f5 23			jp macro_next 
324d				endm 
# End of macro NEXTW
324d			 
324d			;.luno:    db "Word not found",0 
324d			 
324d			 
324d			 
324d			 
324d			 
324d			;		push hl   ; save pointer to start of uword def string 
324d			; 
324d			;; look for FORTH_EOL_LINE 
324d			;		ld a, FORTH_END_BUFFER 
324d			;		call strlent 
324d			; 
324d			;		inc hl		 ; space for coln def 
324d			;		inc hl 
324d			;		inc hl          ; space for terms 
324d			;		inc hl 
324d			; 
324d			;		ld a, 20   ; TODO get actual length 
324d			;		call addatohl    ; include a random amount of room for the uword name 
324d			; 
324d			;		 
324d			;	if DEBUG_FORTH_WORDS 
324d			;		DMARK "Lt1" 
324d			;		CALLMONITOR 
324d			;	endif 
324d			;		 
324d			; 
324d			;; malloc space for the string because we cant change it 
324d			; 
324d			;		call malloc 
324d			;	if DEBUG_FORTH_MALLOC_GUARD 
324d			;		push af 
324d			;		call ishlzero 
324d			;		pop af 
324d			;		 
324d			;		call z,malloc_error 
324d			;	endif 
324d			; 
324d			;	if DEBUG_FORTH_WORDS 
324d			;		DMARK "Lt2" 
324d			;		CALLMONITOR 
324d			;	endif 
324d			;		pop de 
324d			;		push hl    ; push the malloc to release later 
324d			;		push hl   ;  push back a copy for the later stack push 
324d			;		 
324d			;; copy the string swapping out the zero terms for spaces 
324d			; 
324d			;		; de has our source 
324d			;		; hl has our dest 
324d			; 
324d			;; add the coln def 
324d			; 
324d			;		ld a, ':' 
324d			;		ld (hl), a 
324d			;		inc hl 
324d			;		ld a, ' ' 
324d			;		ld (hl), a 
324d			;		inc hl 
324d			; 
324d			;; add the uname word 
324d			;		push de   ; save our string for now 
324d			;		ex de, hl 
324d			; 
324d			;		FORTH_DSP_VALUE 
324d			;		;v5 FORTH_DSP_VALUE 
324d			; 
324d			;		inc hl   ; skip type but we know by now this is OK 
324d			; 
324d			;.luword:	ld a,(hl) 
324d			;		cp 0 
324d			;		jr z, .luword2 
324d			;		ld (de), a 
324d			;		inc de 
324d			;		inc hl 
324d			;		jr .luword 
324d			; 
324d			;.luword2:	ld a, ' ' 
324d			;		ld (de), a 
324d			;;		inc hl 
324d			;;		inc de 
324d			;;		ld (de), a 
324d			;;		inc hl 
324d			;		inc de 
324d			; 
324d			;		ex de, hl 
324d			;		pop de 
324d			;		 
324d			;		 
324d			; 
324d			;; detoken that string and copy it 
324d			; 
324d			;	if DEBUG_FORTH_WORDS 
324d			;		DMARK "Lt2" 
324d			;		CALLMONITOR 
324d			;	endif 
324d			;.ldetok:	ld a, (de) 
324d			;		cp FORTH_END_BUFFER 
324d			;		jr z, .ldetokend 
324d			;		; swap out any zero term for space 
324d			;		cp 0 
324d			;		jr nz, .ldetoknext 
324d			;		ld a, ' ' 
324d			; 
324d			;	if DEBUG_FORTH_WORDS 
324d			;		DMARK "LtS" 
324d			;		CALLMONITOR 
324d			;	endif 
324d			;.ldetoknext:	ld (hl), a 
324d			;		inc de 
324d			;		inc hl 
324d			;		jr .ldetok 
324d			; 
324d			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
324d			;		ld (hl), a  
324d			; 
324d			;; free that temp malloc 
324d			; 
324d			;		pop hl    
324d			; 
324d			;	if DEBUG_FORTH_WORDS 
324d			;		DMARK "Lt4" 
324d			;		CALLMONITOR 
324d			;	endif 
324d			;		call forth_apushstrhl 
324d			; 
324d			;		; get rid of temp malloc area 
324d			; 
324d			;		pop hl 
324d			;		call free 
324d			; 
324d			;		jr .ludone 
324d			; 
324d			;.lnuword:	pop hl 
324d			;		call forth_tok_next 
324d			;		jp .ldouscan  
324d			; 
324d			;.ludone:		 pop hl 
324d			; 
324d					NEXTW 
324d cd a3 fd			call parse_vector 
3250 c3 f5 23			jp macro_next 
3253				endm 
# End of macro NEXTW
3253			 
3253			.FORGET: 
3253				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
3253 5d				db WORD_SYS_CORE+73             
3254 ce 32			dw .NOP            
3256 07				db 6 + 1 
3257 .. 00			db "FORGET",0              
325e				endm 
# End of macro CWHEAD
325e			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
325e			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
325e			; | |  
325e			; | | e.g. "MORE" forget 
325e					if DEBUG_FORTH_WORDS_KEY 
325e						DMARK "FRG" 
325e f5				push af  
325f 3a 73 32			ld a, (.dmark)  
3262 32 99 fd			ld (debug_mark),a  
3265 3a 74 32			ld a, (.dmark+1)  
3268 32 9a fd			ld (debug_mark+1),a  
326b 3a 75 32			ld a, (.dmark+2)  
326e 32 9b fd			ld (debug_mark+2),a  
3271 18 03			jr .pastdmark  
3273 ..			.dmark: db "FRG"  
3276 f1			.pastdmark: pop af  
3277			endm  
# End of macro DMARK
3277						CALLMONITOR 
3277 cd a6 fd			call debug_vector  
327a				endm  
# End of macro CALLMONITOR
327a					endif 
327a			 
327a				; find uword 
327a			        ; update start of word with "_" 
327a				; replace uword with deleted flag 
327a			 
327a			 
327a			;	if DEBUG_FORTH_WORDS 
327a			;		DMARK "FOG" 
327a			;		CALLMONITOR 
327a			;	endif 
327a			 
327a			 
327a					; Get ptr to the word we need to look up 
327a			 
327a					FORTH_DSP_VALUEHL 
327a cd 0e 22			call macro_dsp_valuehl 
327d				endm 
# End of macro FORTH_DSP_VALUEHL
327d					;v5 FORTH_DSP_VALUE 
327d				; TODO type check 
327d			;		inc hl    ; Skip type check  
327d e5					push hl 
327e c1					pop bc 
327f			;		ex de, hl    ; put into DE 
327f			 
327f			 
327f 21 00 80				ld hl, baseram 
3282					;ld hl, baseusermem 
3282			 
3282				; skip dict stub 
3282			;	call forth_tok_next 
3282 e5			push hl   ; sacreifical push 
3283			 
3283			.fldouscanm: 
3283 e1				pop hl 
3284			.fldouscan: 
3284			;	if DEBUG_FORTH_WORDS 
3284			;		DMARK "LSs" 
3284			;		CALLMONITOR 
3284			;	endif 
3284				; skip dict stub 
3284 cd 27 25				call forth_tok_next 
3287			 
3287			 
3287			; while we have words to look for 
3287			 
3287 7e				ld a, (hl)      
3288			;	if DEBUG_FORTH_WORDS 
3288			;		DMARK "LSk" 
3288			;		CALLMONITOR 
3288			;	endif 
3288 fe 00				cp WORD_SYS_END 
328a ca c5 32				jp z, .flunotfound 
328d fe 01				cp WORD_SYS_UWORD 
328f c2 84 32				jp nz, .fldouscan 
3292			 
3292			;	if DEBUG_FORTH_WORDS 
3292			;		DMARK "LSu" 
3292			;		CALLMONITOR 
3292			;	endif 
3292			 
3292					; found a uword but is it the one we want... 
3292			 
3292 c5					push bc     ; uword to find is on bc 
3293 d1					pop de 
3294			 
3294 e5					push hl  ; to save the ptr 
3295			 
3295					; skip opcode 
3295 23					inc hl  
3296					; skip next ptr 
3296 23					inc hl  
3297 23					inc hl 
3298					; skip len 
3298 23					inc hl 
3299			 
3299			;	if DEBUG_FORTH_WORDS 
3299			;		DMARK "LSc" 
3299			;		CALLMONITOR 
3299			;	endif 
3299 cd 41 13				call strcmp 
329c c2 83 32				jp nz, .fldouscanm 
329f			; 
329f			; 
329f			;; while we have words to look for 
329f			; 
329f			;.fdouscan:	ld a, (hl)      
329f			;	if DEBUG_FORTH_WORDS 
329f			;		DMARK "LSs" 
329f			;		CALLMONITOR 
329f			;	endif 
329f			;		cp WORD_SYS_END 
329f			;		jp z, .fudone 
329f			;		cp WORD_SYS_UWORD 
329f			;		jp nz, .fnuword 
329f			; 
329f			;	if DEBUG_FORTH_WORDS 
329f			;		DMARK "FGu" 
329f			;		CALLMONITOR 
329f			;	endif 
329f			; 
329f			;		; found a uword but is it the one we want... 
329f			; 
329f			; 
329f			;	        pop de   ; get back the dsp name 
329f			;		push de 
329f			; 
329f			;		push hl  ; to save the ptr 
329f			; 
329f			;		; skip opcode 
329f			;		inc hl  
329f			;		; skip next ptr 
329f			;		inc hl  
329f			;		inc hl 
329f			;		; skip len 
329f			;		inc hl 
329f			; 
329f			;	if DEBUG_FORTH_WORDS 
329f			;		DMARK "FGc" 
329f			;		CALLMONITOR 
329f			;	endif 
329f			;		call strcmp 
329f			;		jp nz, .fnuword 
329f			 
329f			 
329f e1			pop hl 
32a0			 
32a0				 
32a0				if DEBUG_FORTH_WORDS 
32a0					DMARK "FGm" 
32a0 f5				push af  
32a1 3a b5 32			ld a, (.dmark)  
32a4 32 99 fd			ld (debug_mark),a  
32a7 3a b6 32			ld a, (.dmark+1)  
32aa 32 9a fd			ld (debug_mark+1),a  
32ad 3a b7 32			ld a, (.dmark+2)  
32b0 32 9b fd			ld (debug_mark+2),a  
32b3 18 03			jr .pastdmark  
32b5 ..			.dmark: db "FGm"  
32b8 f1			.pastdmark: pop af  
32b9			endm  
# End of macro DMARK
32b9					CALLMONITOR 
32b9 cd a6 fd			call debug_vector  
32bc				endm  
# End of macro CALLMONITOR
32bc				endif 
32bc			 
32bc			 
32bc			 
32bc					; we have a uword so push its name to the stack 
32bc			 
32bc			;	   	push hl  ; save so we can move to next dict block 
32bc			;pop hl 
32bc			 
32bc					; update opcode to deleted 
32bc			;		ld a, WORD_SYS_DELETED 
32bc 36 03				ld (hl), WORD_SYS_DELETED 
32be			 
32be 23					inc hl  
32bf					; skip next ptr 
32bf 23					inc hl  
32c0 23					inc hl 
32c1					; skip len 
32c1 23					inc hl 
32c2			 
32c2					; TODO change parser to skip deleted words but for now mark it out 
32c2 3e 5f				ld a, "_" 
32c4 77					ld  (hl),a 
32c5			 
32c5			;		jr .fudone 
32c5			; 
32c5			;.fnuword:	pop hl 
32c5			;		call forth_tok_next 
32c5			;		jp .fdouscan  
32c5			 
32c5			.flunotfound:		  
32c5			 
32c5			 
32c5					 
32c5					FORTH_DSP_POP 
32c5 cd c6 22			call macro_forth_dsp_pop 
32c8				endm 
# End of macro FORTH_DSP_POP
32c8			;		ld hl, .luno 
32c8			;.fudone:		 pop hl 
32c8					NEXTW 
32c8 cd a3 fd			call parse_vector 
32cb c3 f5 23			jp macro_next 
32ce				endm 
# End of macro NEXTW
32ce			.NOP: 
32ce				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
32ce 61				db WORD_SYS_CORE+77             
32cf f8 32			dw .COMO            
32d1 04				db 3 + 1 
32d2 .. 00			db "NOP",0              
32d6				endm 
# End of macro CWHEAD
32d6			; | NOP (  --  ) Do nothing | DONE 
32d6					if DEBUG_FORTH_WORDS_KEY 
32d6						DMARK "NOP" 
32d6 f5				push af  
32d7 3a eb 32			ld a, (.dmark)  
32da 32 99 fd			ld (debug_mark),a  
32dd 3a ec 32			ld a, (.dmark+1)  
32e0 32 9a fd			ld (debug_mark+1),a  
32e3 3a ed 32			ld a, (.dmark+2)  
32e6 32 9b fd			ld (debug_mark+2),a  
32e9 18 03			jr .pastdmark  
32eb ..			.dmark: db "NOP"  
32ee f1			.pastdmark: pop af  
32ef			endm  
# End of macro DMARK
32ef						CALLMONITOR 
32ef cd a6 fd			call debug_vector  
32f2				endm  
# End of macro CALLMONITOR
32f2					endif 
32f2				       NEXTW 
32f2 cd a3 fd			call parse_vector 
32f5 c3 f5 23			jp macro_next 
32f8				endm 
# End of macro NEXTW
32f8			.COMO: 
32f8				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
32f8 6e				db WORD_SYS_CORE+90             
32f9 4d 33			dw .COMC            
32fb 02				db 1 + 1 
32fc .. 00			db "(",0              
32fe				endm 
# End of macro CWHEAD
32fe			; | ( ( -- )  Start of comment | DONE 
32fe			 
32fe			 
32fe 2a f0 f3				ld hl, ( os_tok_ptr) 
3301 11 45 33			ld de, .closepar 
3304					 
3304					if DEBUG_FORTH_WORDS 
3304						DMARK ").." 
3304 f5				push af  
3305 3a 19 33			ld a, (.dmark)  
3308 32 99 fd			ld (debug_mark),a  
330b 3a 1a 33			ld a, (.dmark+1)  
330e 32 9a fd			ld (debug_mark+1),a  
3311 3a 1b 33			ld a, (.dmark+2)  
3314 32 9b fd			ld (debug_mark+2),a  
3317 18 03			jr .pastdmark  
3319 ..			.dmark: db ").."  
331c f1			.pastdmark: pop af  
331d			endm  
# End of macro DMARK
331d						CALLMONITOR 
331d cd a6 fd			call debug_vector  
3320				endm  
# End of macro CALLMONITOR
3320					endif 
3320 cd f2 24			call findnexttok  
3323			 
3323					if DEBUG_FORTH_WORDS 
3323						DMARK "IF5" 
3323 f5				push af  
3324 3a 38 33			ld a, (.dmark)  
3327 32 99 fd			ld (debug_mark),a  
332a 3a 39 33			ld a, (.dmark+1)  
332d 32 9a fd			ld (debug_mark+1),a  
3330 3a 3a 33			ld a, (.dmark+2)  
3333 32 9b fd			ld (debug_mark+2),a  
3336 18 03			jr .pastdmark  
3338 ..			.dmark: db "IF5"  
333b f1			.pastdmark: pop af  
333c			endm  
# End of macro DMARK
333c						CALLMONITOR 
333c cd a6 fd			call debug_vector  
333f				endm  
# End of macro CALLMONITOR
333f					endif 
333f				; replace below with ) exec using tok_ptr 
333f 22 f0 f3			ld (os_tok_ptr), hl 
3342 c3 76 24			jp exec1 
3345			 
3345 .. 00			.closepar:   db ")",0 
3347			 
3347				       NEXTW 
3347 cd a3 fd			call parse_vector 
334a c3 f5 23			jp macro_next 
334d				endm 
# End of macro NEXTW
334d			.COMC: 
334d				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
334d 6f				db WORD_SYS_CORE+91             
334e 59 33			dw .SCRATCH            
3350 02				db 1 + 1 
3351 .. 00			db ")",0              
3353				endm 
# End of macro CWHEAD
3353			; | ) ( -- )  End of comment |  DONE  
3353				       NEXTW 
3353 cd a3 fd			call parse_vector 
3356 c3 f5 23			jp macro_next 
3359				endm 
# End of macro NEXTW
3359			 
3359			.SCRATCH: 
3359				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
3359 6f				db WORD_SYS_CORE+91             
335a 97 33			dw .INC            
335c 08				db 7 + 1 
335d .. 00			db "SCRATCH",0              
3365				endm 
# End of macro CWHEAD
3365			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3365			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3365			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3365			; | |  
3365			; | | e.g.    : score $00 scratch ; 
3365			; | |  
3365			; | | $00 score ! 
3365			; | | $01 score +! 
3365			; | |  
3365			; | | e.g.   : varword $0a scratch ;  
3365			; | | 
3365			; | | $8000 varword ! 
3365					if DEBUG_FORTH_WORDS_KEY 
3365						DMARK "SCR" 
3365 f5				push af  
3366 3a 7a 33			ld a, (.dmark)  
3369 32 99 fd			ld (debug_mark),a  
336c 3a 7b 33			ld a, (.dmark+1)  
336f 32 9a fd			ld (debug_mark+1),a  
3372 3a 7c 33			ld a, (.dmark+2)  
3375 32 9b fd			ld (debug_mark+2),a  
3378 18 03			jr .pastdmark  
337a ..			.dmark: db "SCR"  
337d f1			.pastdmark: pop af  
337e			endm  
# End of macro DMARK
337e						CALLMONITOR 
337e cd a6 fd			call debug_vector  
3381				endm  
# End of macro CALLMONITOR
3381					endif 
3381			 
3381					FORTH_DSP_VALUEHL 
3381 cd 0e 22			call macro_dsp_valuehl 
3384				endm 
# End of macro FORTH_DSP_VALUEHL
3384				 
3384					FORTH_DSP_POP 
3384 cd c6 22			call macro_forth_dsp_pop 
3387				endm 
# End of macro FORTH_DSP_POP
3387			 
3387 7d					ld a, l 
3388 21 14 f6				ld hl, os_var_array 
338b cd b1 0f				call addatohl 
338e			 
338e cd 12 20				call forth_push_numhl 
3391			 
3391				       NEXTW 
3391 cd a3 fd			call parse_vector 
3394 c3 f5 23			jp macro_next 
3397				endm 
# End of macro NEXTW
3397			 
3397			.INC: 
3397				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3397 6f				db WORD_SYS_CORE+91             
3398 f0 33			dw .DEC            
339a 03				db 2 + 1 
339b .. 00			db "+!",0              
339e				endm 
# End of macro CWHEAD
339e			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
339e					if DEBUG_FORTH_WORDS_KEY 
339e						DMARK "+s_" 
339e f5				push af  
339f 3a b3 33			ld a, (.dmark)  
33a2 32 99 fd			ld (debug_mark),a  
33a5 3a b4 33			ld a, (.dmark+1)  
33a8 32 9a fd			ld (debug_mark+1),a  
33ab 3a b5 33			ld a, (.dmark+2)  
33ae 32 9b fd			ld (debug_mark+2),a  
33b1 18 03			jr .pastdmark  
33b3 ..			.dmark: db "+s_"  
33b6 f1			.pastdmark: pop af  
33b7			endm  
# End of macro DMARK
33b7						CALLMONITOR 
33b7 cd a6 fd			call debug_vector  
33ba				endm  
# End of macro CALLMONITOR
33ba					endif 
33ba			 
33ba					FORTH_DSP_VALUEHL 
33ba cd 0e 22			call macro_dsp_valuehl 
33bd				endm 
# End of macro FORTH_DSP_VALUEHL
33bd			 
33bd e5					push hl   ; save address 
33be			 
33be					FORTH_DSP_POP 
33be cd c6 22			call macro_forth_dsp_pop 
33c1				endm 
# End of macro FORTH_DSP_POP
33c1			 
33c1					FORTH_DSP_VALUEHL 
33c1 cd 0e 22			call macro_dsp_valuehl 
33c4				endm 
# End of macro FORTH_DSP_VALUEHL
33c4			 
33c4 e5					push hl 
33c5					FORTH_DSP_POP 
33c5 cd c6 22			call macro_forth_dsp_pop 
33c8				endm 
# End of macro FORTH_DSP_POP
33c8 e1					pop hl 
33c9			 
33c9					; hl contains value to add to byte at a 
33c9				 
33c9 eb					ex de, hl 
33ca			 
33ca e1					pop hl 
33cb			 
33cb					if DEBUG_FORTH_WORDS 
33cb						DMARK "INC" 
33cb f5				push af  
33cc 3a e0 33			ld a, (.dmark)  
33cf 32 99 fd			ld (debug_mark),a  
33d2 3a e1 33			ld a, (.dmark+1)  
33d5 32 9a fd			ld (debug_mark+1),a  
33d8 3a e2 33			ld a, (.dmark+2)  
33db 32 9b fd			ld (debug_mark+2),a  
33de 18 03			jr .pastdmark  
33e0 ..			.dmark: db "INC"  
33e3 f1			.pastdmark: pop af  
33e4			endm  
# End of macro DMARK
33e4						CALLMONITOR 
33e4 cd a6 fd			call debug_vector  
33e7				endm  
# End of macro CALLMONITOR
33e7					endif 
33e7			 
33e7 7e					ld a,(hl) 
33e8 83					add e 
33e9 77					ld (hl),a 
33ea			 
33ea			 
33ea			 
33ea				       NEXTW 
33ea cd a3 fd			call parse_vector 
33ed c3 f5 23			jp macro_next 
33f0				endm 
# End of macro NEXTW
33f0			 
33f0			.DEC: 
33f0				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
33f0 6f				db WORD_SYS_CORE+91             
33f1 47 34			dw .INC2            
33f3 03				db 2 + 1 
33f4 .. 00			db "-!",0              
33f7				endm 
# End of macro CWHEAD
33f7			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
33f7					if DEBUG_FORTH_WORDS_KEY 
33f7						DMARK "-s_" 
33f7 f5				push af  
33f8 3a 0c 34			ld a, (.dmark)  
33fb 32 99 fd			ld (debug_mark),a  
33fe 3a 0d 34			ld a, (.dmark+1)  
3401 32 9a fd			ld (debug_mark+1),a  
3404 3a 0e 34			ld a, (.dmark+2)  
3407 32 9b fd			ld (debug_mark+2),a  
340a 18 03			jr .pastdmark  
340c ..			.dmark: db "-s_"  
340f f1			.pastdmark: pop af  
3410			endm  
# End of macro DMARK
3410						CALLMONITOR 
3410 cd a6 fd			call debug_vector  
3413				endm  
# End of macro CALLMONITOR
3413					endif 
3413			 
3413					FORTH_DSP_VALUEHL 
3413 cd 0e 22			call macro_dsp_valuehl 
3416				endm 
# End of macro FORTH_DSP_VALUEHL
3416			 
3416 e5					push hl   ; save address 
3417			 
3417					FORTH_DSP_POP 
3417 cd c6 22			call macro_forth_dsp_pop 
341a				endm 
# End of macro FORTH_DSP_POP
341a			 
341a					FORTH_DSP_VALUEHL 
341a cd 0e 22			call macro_dsp_valuehl 
341d				endm 
# End of macro FORTH_DSP_VALUEHL
341d			 
341d					; hl contains value to add to byte at a 
341d				 
341d eb					ex de, hl 
341e			 
341e e1					pop hl 
341f			 
341f					if DEBUG_FORTH_WORDS 
341f						DMARK "DEC" 
341f f5				push af  
3420 3a 34 34			ld a, (.dmark)  
3423 32 99 fd			ld (debug_mark),a  
3426 3a 35 34			ld a, (.dmark+1)  
3429 32 9a fd			ld (debug_mark+1),a  
342c 3a 36 34			ld a, (.dmark+2)  
342f 32 9b fd			ld (debug_mark+2),a  
3432 18 03			jr .pastdmark  
3434 ..			.dmark: db "DEC"  
3437 f1			.pastdmark: pop af  
3438			endm  
# End of macro DMARK
3438						CALLMONITOR 
3438 cd a6 fd			call debug_vector  
343b				endm  
# End of macro CALLMONITOR
343b					endif 
343b			 
343b 7e					ld a,(hl) 
343c 93					sub e 
343d 77					ld (hl),a 
343e			 
343e			 
343e					FORTH_DSP_POP 
343e cd c6 22			call macro_forth_dsp_pop 
3441				endm 
# End of macro FORTH_DSP_POP
3441			 
3441				       NEXTW 
3441 cd a3 fd			call parse_vector 
3444 c3 f5 23			jp macro_next 
3447				endm 
# End of macro NEXTW
3447			 
3447			.INC2: 
3447				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
3447 6f				db WORD_SYS_CORE+91             
3448 f7 34			dw .DEC2            
344a 04				db 3 + 1 
344b .. 00			db "+2!",0              
344f				endm 
# End of macro CWHEAD
344f			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
344f			 
344f					if DEBUG_FORTH_WORDS_KEY 
344f						DMARK "+2s" 
344f f5				push af  
3450 3a 64 34			ld a, (.dmark)  
3453 32 99 fd			ld (debug_mark),a  
3456 3a 65 34			ld a, (.dmark+1)  
3459 32 9a fd			ld (debug_mark+1),a  
345c 3a 66 34			ld a, (.dmark+2)  
345f 32 9b fd			ld (debug_mark+2),a  
3462 18 03			jr .pastdmark  
3464 ..			.dmark: db "+2s"  
3467 f1			.pastdmark: pop af  
3468			endm  
# End of macro DMARK
3468						CALLMONITOR 
3468 cd a6 fd			call debug_vector  
346b				endm  
# End of macro CALLMONITOR
346b					endif 
346b			 
346b					; Address 
346b			 
346b					FORTH_DSP_VALUEHL 
346b cd 0e 22			call macro_dsp_valuehl 
346e				endm 
# End of macro FORTH_DSP_VALUEHL
346e			 
346e e5					push hl    ; save address 
346f			 
346f					; load content into de 
346f			 
346f 5e					ld e,(hl) 
3470 23					inc hl 
3471 56					ld d, (hl) 
3472			 
3472					if DEBUG_FORTH_WORDS 
3472						DMARK "+2a" 
3472 f5				push af  
3473 3a 87 34			ld a, (.dmark)  
3476 32 99 fd			ld (debug_mark),a  
3479 3a 88 34			ld a, (.dmark+1)  
347c 32 9a fd			ld (debug_mark+1),a  
347f 3a 89 34			ld a, (.dmark+2)  
3482 32 9b fd			ld (debug_mark+2),a  
3485 18 03			jr .pastdmark  
3487 ..			.dmark: db "+2a"  
348a f1			.pastdmark: pop af  
348b			endm  
# End of macro DMARK
348b						CALLMONITOR 
348b cd a6 fd			call debug_vector  
348e				endm  
# End of macro CALLMONITOR
348e					endif 
348e			 
348e					FORTH_DSP_POP 
348e cd c6 22			call macro_forth_dsp_pop 
3491				endm 
# End of macro FORTH_DSP_POP
3491			 
3491					; Get value to add 
3491			 
3491					FORTH_DSP_VALUE 
3491 cd f7 21			call macro_forth_dsp_value 
3494				endm 
# End of macro FORTH_DSP_VALUE
3494			 
3494					if DEBUG_FORTH_WORDS 
3494						DMARK "+2v" 
3494 f5				push af  
3495 3a a9 34			ld a, (.dmark)  
3498 32 99 fd			ld (debug_mark),a  
349b 3a aa 34			ld a, (.dmark+1)  
349e 32 9a fd			ld (debug_mark+1),a  
34a1 3a ab 34			ld a, (.dmark+2)  
34a4 32 9b fd			ld (debug_mark+2),a  
34a7 18 03			jr .pastdmark  
34a9 ..			.dmark: db "+2v"  
34ac f1			.pastdmark: pop af  
34ad			endm  
# End of macro DMARK
34ad						CALLMONITOR 
34ad cd a6 fd			call debug_vector  
34b0				endm  
# End of macro CALLMONITOR
34b0					endif 
34b0			 
34b0 19					add hl, de 
34b1			 
34b1					if DEBUG_FORTH_WORDS 
34b1						DMARK "+2+" 
34b1 f5				push af  
34b2 3a c6 34			ld a, (.dmark)  
34b5 32 99 fd			ld (debug_mark),a  
34b8 3a c7 34			ld a, (.dmark+1)  
34bb 32 9a fd			ld (debug_mark+1),a  
34be 3a c8 34			ld a, (.dmark+2)  
34c1 32 9b fd			ld (debug_mark+2),a  
34c4 18 03			jr .pastdmark  
34c6 ..			.dmark: db "+2+"  
34c9 f1			.pastdmark: pop af  
34ca			endm  
# End of macro DMARK
34ca						CALLMONITOR 
34ca cd a6 fd			call debug_vector  
34cd				endm  
# End of macro CALLMONITOR
34cd					endif 
34cd			 
34cd					; move result to de 
34cd			 
34cd eb					ex de, hl 
34ce			 
34ce					; Address 
34ce			 
34ce e1					pop hl 
34cf			 
34cf					; save it back 
34cf			 
34cf 73					ld (hl), e 
34d0 23					inc hl 
34d1 72					ld (hl), d 
34d2			 
34d2					if DEBUG_FORTH_WORDS 
34d2						DMARK "+2e" 
34d2 f5				push af  
34d3 3a e7 34			ld a, (.dmark)  
34d6 32 99 fd			ld (debug_mark),a  
34d9 3a e8 34			ld a, (.dmark+1)  
34dc 32 9a fd			ld (debug_mark+1),a  
34df 3a e9 34			ld a, (.dmark+2)  
34e2 32 9b fd			ld (debug_mark+2),a  
34e5 18 03			jr .pastdmark  
34e7 ..			.dmark: db "+2e"  
34ea f1			.pastdmark: pop af  
34eb			endm  
# End of macro DMARK
34eb						CALLMONITOR 
34eb cd a6 fd			call debug_vector  
34ee				endm  
# End of macro CALLMONITOR
34ee					endif 
34ee			 
34ee			 
34ee			 
34ee					FORTH_DSP_POP 
34ee cd c6 22			call macro_forth_dsp_pop 
34f1				endm 
# End of macro FORTH_DSP_POP
34f1			 
34f1			 
34f1				       NEXTW 
34f1 cd a3 fd			call parse_vector 
34f4 c3 f5 23			jp macro_next 
34f7				endm 
# End of macro NEXTW
34f7			 
34f7			.DEC2: 
34f7				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
34f7 6f				db WORD_SYS_CORE+91             
34f8 a9 35			dw .GET2            
34fa 04				db 3 + 1 
34fb .. 00			db "-2!",0              
34ff				endm 
# End of macro CWHEAD
34ff			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
34ff			 
34ff			 
34ff					if DEBUG_FORTH_WORDS_KEY 
34ff						DMARK "-2s" 
34ff f5				push af  
3500 3a 14 35			ld a, (.dmark)  
3503 32 99 fd			ld (debug_mark),a  
3506 3a 15 35			ld a, (.dmark+1)  
3509 32 9a fd			ld (debug_mark+1),a  
350c 3a 16 35			ld a, (.dmark+2)  
350f 32 9b fd			ld (debug_mark+2),a  
3512 18 03			jr .pastdmark  
3514 ..			.dmark: db "-2s"  
3517 f1			.pastdmark: pop af  
3518			endm  
# End of macro DMARK
3518						CALLMONITOR 
3518 cd a6 fd			call debug_vector  
351b				endm  
# End of macro CALLMONITOR
351b					endif 
351b			 
351b					; Address 
351b			 
351b					FORTH_DSP_VALUEHL 
351b cd 0e 22			call macro_dsp_valuehl 
351e				endm 
# End of macro FORTH_DSP_VALUEHL
351e			 
351e e5					push hl    ; save address 
351f			 
351f					; load content into de 
351f			 
351f 5e					ld e,(hl) 
3520 23					inc hl 
3521 56					ld d, (hl) 
3522			 
3522					if DEBUG_FORTH_WORDS 
3522						DMARK "-2a" 
3522 f5				push af  
3523 3a 37 35			ld a, (.dmark)  
3526 32 99 fd			ld (debug_mark),a  
3529 3a 38 35			ld a, (.dmark+1)  
352c 32 9a fd			ld (debug_mark+1),a  
352f 3a 39 35			ld a, (.dmark+2)  
3532 32 9b fd			ld (debug_mark+2),a  
3535 18 03			jr .pastdmark  
3537 ..			.dmark: db "-2a"  
353a f1			.pastdmark: pop af  
353b			endm  
# End of macro DMARK
353b						CALLMONITOR 
353b cd a6 fd			call debug_vector  
353e				endm  
# End of macro CALLMONITOR
353e					endif 
353e			 
353e					FORTH_DSP_POP 
353e cd c6 22			call macro_forth_dsp_pop 
3541				endm 
# End of macro FORTH_DSP_POP
3541			 
3541					; Get value to remove 
3541			 
3541					FORTH_DSP_VALUE 
3541 cd f7 21			call macro_forth_dsp_value 
3544				endm 
# End of macro FORTH_DSP_VALUE
3544			 
3544					if DEBUG_FORTH_WORDS 
3544						DMARK "-2v" 
3544 f5				push af  
3545 3a 59 35			ld a, (.dmark)  
3548 32 99 fd			ld (debug_mark),a  
354b 3a 5a 35			ld a, (.dmark+1)  
354e 32 9a fd			ld (debug_mark+1),a  
3551 3a 5b 35			ld a, (.dmark+2)  
3554 32 9b fd			ld (debug_mark+2),a  
3557 18 03			jr .pastdmark  
3559 ..			.dmark: db "-2v"  
355c f1			.pastdmark: pop af  
355d			endm  
# End of macro DMARK
355d						CALLMONITOR 
355d cd a6 fd			call debug_vector  
3560				endm  
# End of macro CALLMONITOR
3560					endif 
3560			 
3560 eb					ex de, hl 
3561 ed 52				sbc hl, de 
3563			 
3563					if DEBUG_FORTH_WORDS 
3563						DMARK "-2d" 
3563 f5				push af  
3564 3a 78 35			ld a, (.dmark)  
3567 32 99 fd			ld (debug_mark),a  
356a 3a 79 35			ld a, (.dmark+1)  
356d 32 9a fd			ld (debug_mark+1),a  
3570 3a 7a 35			ld a, (.dmark+2)  
3573 32 9b fd			ld (debug_mark+2),a  
3576 18 03			jr .pastdmark  
3578 ..			.dmark: db "-2d"  
357b f1			.pastdmark: pop af  
357c			endm  
# End of macro DMARK
357c						CALLMONITOR 
357c cd a6 fd			call debug_vector  
357f				endm  
# End of macro CALLMONITOR
357f					endif 
357f			 
357f					; move result to de 
357f			 
357f eb					ex de, hl 
3580			 
3580					; Address 
3580			 
3580 e1					pop hl 
3581			 
3581					; save it back 
3581			 
3581 73					ld (hl), e 
3582 23					inc hl 
3583 72					ld (hl), d 
3584			 
3584					if DEBUG_FORTH_WORDS 
3584						DMARK "-2e" 
3584 f5				push af  
3585 3a 99 35			ld a, (.dmark)  
3588 32 99 fd			ld (debug_mark),a  
358b 3a 9a 35			ld a, (.dmark+1)  
358e 32 9a fd			ld (debug_mark+1),a  
3591 3a 9b 35			ld a, (.dmark+2)  
3594 32 9b fd			ld (debug_mark+2),a  
3597 18 03			jr .pastdmark  
3599 ..			.dmark: db "-2e"  
359c f1			.pastdmark: pop af  
359d			endm  
# End of macro DMARK
359d						CALLMONITOR 
359d cd a6 fd			call debug_vector  
35a0				endm  
# End of macro CALLMONITOR
35a0					endif 
35a0			 
35a0			 
35a0					FORTH_DSP_POP 
35a0 cd c6 22			call macro_forth_dsp_pop 
35a3				endm 
# End of macro FORTH_DSP_POP
35a3			 
35a3			 
35a3			 
35a3				       NEXTW 
35a3 cd a3 fd			call parse_vector 
35a6 c3 f5 23			jp macro_next 
35a9				endm 
# End of macro NEXTW
35a9			.GET2: 
35a9				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
35a9 6f				db WORD_SYS_CORE+91             
35aa e1 35			dw .BANG2            
35ac 03				db 2 + 1 
35ad .. 00			db "2@",0              
35b0				endm 
# End of macro CWHEAD
35b0			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
35b0					if DEBUG_FORTH_WORDS_KEY 
35b0						DMARK "2A_" 
35b0 f5				push af  
35b1 3a c5 35			ld a, (.dmark)  
35b4 32 99 fd			ld (debug_mark),a  
35b7 3a c6 35			ld a, (.dmark+1)  
35ba 32 9a fd			ld (debug_mark+1),a  
35bd 3a c7 35			ld a, (.dmark+2)  
35c0 32 9b fd			ld (debug_mark+2),a  
35c3 18 03			jr .pastdmark  
35c5 ..			.dmark: db "2A_"  
35c8 f1			.pastdmark: pop af  
35c9			endm  
# End of macro DMARK
35c9						CALLMONITOR 
35c9 cd a6 fd			call debug_vector  
35cc				endm  
# End of macro CALLMONITOR
35cc					endif 
35cc			 
35cc					FORTH_DSP_VALUEHL 
35cc cd 0e 22			call macro_dsp_valuehl 
35cf				endm 
# End of macro FORTH_DSP_VALUEHL
35cf			 
35cf e5					push hl   ; save address 
35d0			 
35d0					FORTH_DSP_POP 
35d0 cd c6 22			call macro_forth_dsp_pop 
35d3				endm 
# End of macro FORTH_DSP_POP
35d3			 
35d3 e1					pop hl 
35d4			 
35d4 5e					ld e, (hl) 
35d5 23					inc hl 
35d6 56					ld d, (hl) 
35d7			 
35d7 eb					ex de, hl 
35d8			 
35d8 cd 12 20				call forth_push_numhl 
35db			 
35db				       NEXTW 
35db cd a3 fd			call parse_vector 
35de c3 f5 23			jp macro_next 
35e1				endm 
# End of macro NEXTW
35e1			.BANG2: 
35e1				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
35e1 6f				db WORD_SYS_CORE+91             
35e2 1c 36			dw .CONFIG            
35e4 03				db 2 + 1 
35e5 .. 00			db "2!",0              
35e8				endm 
# End of macro CWHEAD
35e8			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
35e8					if DEBUG_FORTH_WORDS_KEY 
35e8						DMARK "2S_" 
35e8 f5				push af  
35e9 3a fd 35			ld a, (.dmark)  
35ec 32 99 fd			ld (debug_mark),a  
35ef 3a fe 35			ld a, (.dmark+1)  
35f2 32 9a fd			ld (debug_mark+1),a  
35f5 3a ff 35			ld a, (.dmark+2)  
35f8 32 9b fd			ld (debug_mark+2),a  
35fb 18 03			jr .pastdmark  
35fd ..			.dmark: db "2S_"  
3600 f1			.pastdmark: pop af  
3601			endm  
# End of macro DMARK
3601						CALLMONITOR 
3601 cd a6 fd			call debug_vector  
3604				endm  
# End of macro CALLMONITOR
3604					endif 
3604			 
3604					FORTH_DSP_VALUEHL 
3604 cd 0e 22			call macro_dsp_valuehl 
3607				endm 
# End of macro FORTH_DSP_VALUEHL
3607			 
3607 e5					push hl   ; save address 
3608			 
3608			 
3608					FORTH_DSP_POP 
3608 cd c6 22			call macro_forth_dsp_pop 
360b				endm 
# End of macro FORTH_DSP_POP
360b			 
360b					 
360b					FORTH_DSP_VALUEHL 
360b cd 0e 22			call macro_dsp_valuehl 
360e				endm 
# End of macro FORTH_DSP_VALUEHL
360e			 
360e					FORTH_DSP_POP 
360e cd c6 22			call macro_forth_dsp_pop 
3611				endm 
# End of macro FORTH_DSP_POP
3611			 
3611 eb					ex de, hl    ; value now in de 
3612			 
3612 e1					pop hl 
3613			 
3613 73					ld (hl), e 
3614			 
3614 23					inc hl 
3615			 
3615 72					ld (hl), d 
3616			 
3616			 
3616				       NEXTW 
3616 cd a3 fd			call parse_vector 
3619 c3 f5 23			jp macro_next 
361c				endm 
# End of macro NEXTW
361c			.CONFIG: 
361c				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
361c 6f				db WORD_SYS_CORE+91             
361d 30 36			dw .ADTOS            
361f 07				db 6 + 1 
3620 .. 00			db "CONFIG",0              
3627				endm 
# End of macro CWHEAD
3627			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3627			 
3627 cd 16 15				call config 
362a					NEXTW 
362a cd a3 fd			call parse_vector 
362d c3 f5 23			jp macro_next 
3630				endm 
# End of macro NEXTW
3630			 
3630			.ADTOS: 
3630				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
3630 6f				db WORD_SYS_CORE+91             
3631 49 36			dw .SBTOS            
3633 03				db 2 + 1 
3634 .. 00			db "1+",0              
3637				endm 
# End of macro CWHEAD
3637			; | 1+ ( u -- u )  Increment value on TOS | DONE 
3637			 
3637					FORTH_DSP_VALUEHL 
3637 cd 0e 22			call macro_dsp_valuehl 
363a				endm 
# End of macro FORTH_DSP_VALUEHL
363a e5					push hl 
363b			 
363b					FORTH_DSP_POP 
363b cd c6 22			call macro_forth_dsp_pop 
363e				endm 
# End of macro FORTH_DSP_POP
363e e1					pop hl 
363f			 
363f 23					inc hl 
3640 cd 12 20				call forth_push_numhl 
3643					 
3643					NEXTW 
3643 cd a3 fd			call parse_vector 
3646 c3 f5 23			jp macro_next 
3649				endm 
# End of macro NEXTW
3649			.SBTOS: 
3649				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
3649 6f				db WORD_SYS_CORE+91             
364a 62 36			dw .ADSTORE            
364c 03				db 2 + 1 
364d .. 00			db "1-",0              
3650				endm 
# End of macro CWHEAD
3650			; | 1- ( u -- u )  Decrement value on TOS | DONE 
3650			 
3650					FORTH_DSP_VALUEHL 
3650 cd 0e 22			call macro_dsp_valuehl 
3653				endm 
# End of macro FORTH_DSP_VALUEHL
3653 e5					push hl 
3654			 
3654					FORTH_DSP_POP 
3654 cd c6 22			call macro_forth_dsp_pop 
3657				endm 
# End of macro FORTH_DSP_POP
3657 e1					pop hl 
3658			 
3658 2b					dec hl 
3659 cd 12 20				call forth_push_numhl 
365c					 
365c					NEXTW 
365c cd a3 fd			call parse_vector 
365f c3 f5 23			jp macro_next 
3662				endm 
# End of macro NEXTW
3662			.ADSTORE: 
3662				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
3662 6f				db WORD_SYS_CORE+91             
3663 7b 36			dw .ADWSTORE            
3665 04				db 3 + 1 
3666 .. 00			db "1+!",0              
366a				endm 
# End of macro CWHEAD
366a			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
366a			 
366a					FORTH_DSP_VALUEHL 
366a cd 0e 22			call macro_dsp_valuehl 
366d				endm 
# End of macro FORTH_DSP_VALUEHL
366d e5					push hl 
366e			 
366e					FORTH_DSP_POP 
366e cd c6 22			call macro_forth_dsp_pop 
3671				endm 
# End of macro FORTH_DSP_POP
3671 e1					pop hl 
3672			 
3672 7e					ld a, (hl) 
3673 3c					inc a 
3674 77					ld (hl), a 
3675					 
3675					NEXTW 
3675 cd a3 fd			call parse_vector 
3678 c3 f5 23			jp macro_next 
367b				endm 
# End of macro NEXTW
367b			.ADWSTORE: 
367b				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
367b 6f				db WORD_SYS_CORE+91             
367c 9c 36			dw .SBSTORE            
367e 05				db 4 + 1 
367f .. 00			db "1+2!",0              
3684				endm 
# End of macro CWHEAD
3684			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3684			 
3684					FORTH_DSP_VALUEHL 
3684 cd 0e 22			call macro_dsp_valuehl 
3687				endm 
# End of macro FORTH_DSP_VALUEHL
3687 e5					push hl 
3688			 
3688					FORTH_DSP_POP 
3688 cd c6 22			call macro_forth_dsp_pop 
368b				endm 
# End of macro FORTH_DSP_POP
368b e1					pop hl 
368c			 
368c e5					push hl 
368d			 
368d cd 7b 23				call loadwordinhl 
3690 23					inc hl 
3691			 
3691 d1					pop de 
3692 eb					ex de, hl 
3693 73					ld (hl), e 
3694 23					inc hl 
3695 72					ld (hl), d 
3696					 
3696					NEXTW 
3696 cd a3 fd			call parse_vector 
3699 c3 f5 23			jp macro_next 
369c				endm 
# End of macro NEXTW
369c			.SBSTORE: 
369c				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
369c 6f				db WORD_SYS_CORE+91             
369d b5 36			dw .SBWSTORE            
369f 04				db 3 + 1 
36a0 .. 00			db "1-!",0              
36a4				endm 
# End of macro CWHEAD
36a4			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
36a4			 
36a4					FORTH_DSP_VALUEHL 
36a4 cd 0e 22			call macro_dsp_valuehl 
36a7				endm 
# End of macro FORTH_DSP_VALUEHL
36a7 e5					push hl 
36a8			 
36a8					FORTH_DSP_POP 
36a8 cd c6 22			call macro_forth_dsp_pop 
36ab				endm 
# End of macro FORTH_DSP_POP
36ab e1					pop hl 
36ac			 
36ac 7e					ld a, (hl) 
36ad 3d					dec a 
36ae 77					ld (hl), a 
36af					 
36af					NEXTW 
36af cd a3 fd			call parse_vector 
36b2 c3 f5 23			jp macro_next 
36b5				endm 
# End of macro NEXTW
36b5			.SBWSTORE: 
36b5				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
36b5 6f				db WORD_SYS_CORE+91             
36b6 d6 36			dw .ENDCORE            
36b8 05				db 4 + 1 
36b9 .. 00			db "1-2!",0              
36be				endm 
# End of macro CWHEAD
36be			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
36be			 
36be					FORTH_DSP_VALUEHL 
36be cd 0e 22			call macro_dsp_valuehl 
36c1				endm 
# End of macro FORTH_DSP_VALUEHL
36c1 e5					push hl 
36c2			 
36c2					FORTH_DSP_POP 
36c2 cd c6 22			call macro_forth_dsp_pop 
36c5				endm 
# End of macro FORTH_DSP_POP
36c5 e1					pop hl 
36c6			 
36c6 e5					push hl 
36c7			 
36c7 cd 7b 23				call loadwordinhl 
36ca 2b					dec hl 
36cb			 
36cb d1					pop de 
36cc eb					ex de, hl 
36cd 73					ld (hl), e 
36ce 23					inc hl 
36cf 72					ld (hl), d 
36d0					 
36d0					NEXTW 
36d0 cd a3 fd			call parse_vector 
36d3 c3 f5 23			jp macro_next 
36d6				endm 
# End of macro NEXTW
36d6			.ENDCORE: 
36d6			 
36d6			; eof 
36d6			 
36d6			 
# End of file forth_words_core.asm
36d6			include "forth_words_flow.asm" 
36d6			 
36d6			; | ## Program Flow Words 
36d6			 
36d6			.IF: 
36d6				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
36d6 1e				db WORD_SYS_CORE+10             
36d7 d1 37			dw .THEN            
36d9 03				db 2 + 1 
36da .. 00			db "IF",0              
36dd				endm 
# End of macro CWHEAD
36dd			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
36dd			; | | Note: currently not supporting ELSE or nested IF 
36dd			; 
36dd					if DEBUG_FORTH_WORDS_KEY 
36dd						DMARK "IF." 
36dd f5				push af  
36de 3a f2 36			ld a, (.dmark)  
36e1 32 99 fd			ld (debug_mark),a  
36e4 3a f3 36			ld a, (.dmark+1)  
36e7 32 9a fd			ld (debug_mark+1),a  
36ea 3a f4 36			ld a, (.dmark+2)  
36ed 32 9b fd			ld (debug_mark+2),a  
36f0 18 03			jr .pastdmark  
36f2 ..			.dmark: db "IF."  
36f5 f1			.pastdmark: pop af  
36f6			endm  
# End of macro DMARK
36f6						CALLMONITOR 
36f6 cd a6 fd			call debug_vector  
36f9				endm  
# End of macro CALLMONITOR
36f9					endif 
36f9			; eval TOS 
36f9			 
36f9				FORTH_DSP_VALUEHL 
36f9 cd 0e 22			call macro_dsp_valuehl 
36fc				endm 
# End of macro FORTH_DSP_VALUEHL
36fc			 
36fc			;	push hl 
36fc				FORTH_DSP_POP 
36fc cd c6 22			call macro_forth_dsp_pop 
36ff				endm 
# End of macro FORTH_DSP_POP
36ff			;	pop hl 
36ff			 
36ff					if DEBUG_FORTH_WORDS 
36ff						DMARK "IF1" 
36ff f5				push af  
3700 3a 14 37			ld a, (.dmark)  
3703 32 99 fd			ld (debug_mark),a  
3706 3a 15 37			ld a, (.dmark+1)  
3709 32 9a fd			ld (debug_mark+1),a  
370c 3a 16 37			ld a, (.dmark+2)  
370f 32 9b fd			ld (debug_mark+2),a  
3712 18 03			jr .pastdmark  
3714 ..			.dmark: db "IF1"  
3717 f1			.pastdmark: pop af  
3718			endm  
# End of macro DMARK
3718						CALLMONITOR 
3718 cd a6 fd			call debug_vector  
371b				endm  
# End of macro CALLMONITOR
371b					endif 
371b b7				or a        ; clear carry flag 
371c 11 00 00			ld de, 0 
371f eb				ex de,hl 
3720 ed 52			sbc hl, de 
3722 c2 af 37			jp nz, .iftrue 
3725			 
3725					if DEBUG_FORTH_WORDS 
3725						DMARK "IF2" 
3725 f5				push af  
3726 3a 3a 37			ld a, (.dmark)  
3729 32 99 fd			ld (debug_mark),a  
372c 3a 3b 37			ld a, (.dmark+1)  
372f 32 9a fd			ld (debug_mark+1),a  
3732 3a 3c 37			ld a, (.dmark+2)  
3735 32 9b fd			ld (debug_mark+2),a  
3738 18 03			jr .pastdmark  
373a ..			.dmark: db "IF2"  
373d f1			.pastdmark: pop af  
373e			endm  
# End of macro DMARK
373e						CALLMONITOR 
373e cd a6 fd			call debug_vector  
3741				endm  
# End of macro CALLMONITOR
3741					endif 
3741			 
3741			; if not true then skip to THEN 
3741			 
3741				; TODO get tok_ptr 
3741				; TODO consume toks until we get to THEN 
3741			 
3741 2a f0 f3			ld hl, (os_tok_ptr) 
3744					if DEBUG_FORTH_WORDS 
3744						DMARK "IF3" 
3744 f5				push af  
3745 3a 59 37			ld a, (.dmark)  
3748 32 99 fd			ld (debug_mark),a  
374b 3a 5a 37			ld a, (.dmark+1)  
374e 32 9a fd			ld (debug_mark+1),a  
3751 3a 5b 37			ld a, (.dmark+2)  
3754 32 9b fd			ld (debug_mark+2),a  
3757 18 03			jr .pastdmark  
3759 ..			.dmark: db "IF3"  
375c f1			.pastdmark: pop af  
375d			endm  
# End of macro DMARK
375d						CALLMONITOR 
375d cd a6 fd			call debug_vector  
3760				endm  
# End of macro CALLMONITOR
3760						 
3760					endif 
3760 11 aa 37			ld de, .ifthen 
3763					if DEBUG_FORTH_WORDS 
3763						DMARK "IF4" 
3763 f5				push af  
3764 3a 78 37			ld a, (.dmark)  
3767 32 99 fd			ld (debug_mark),a  
376a 3a 79 37			ld a, (.dmark+1)  
376d 32 9a fd			ld (debug_mark+1),a  
3770 3a 7a 37			ld a, (.dmark+2)  
3773 32 9b fd			ld (debug_mark+2),a  
3776 18 03			jr .pastdmark  
3778 ..			.dmark: db "IF4"  
377b f1			.pastdmark: pop af  
377c			endm  
# End of macro DMARK
377c						CALLMONITOR 
377c cd a6 fd			call debug_vector  
377f				endm  
# End of macro CALLMONITOR
377f					endif 
377f cd f2 24			call findnexttok  
3782			 
3782					if DEBUG_FORTH_WORDS 
3782						DMARK "IF5" 
3782 f5				push af  
3783 3a 97 37			ld a, (.dmark)  
3786 32 99 fd			ld (debug_mark),a  
3789 3a 98 37			ld a, (.dmark+1)  
378c 32 9a fd			ld (debug_mark+1),a  
378f 3a 99 37			ld a, (.dmark+2)  
3792 32 9b fd			ld (debug_mark+2),a  
3795 18 03			jr .pastdmark  
3797 ..			.dmark: db "IF5"  
379a f1			.pastdmark: pop af  
379b			endm  
# End of macro DMARK
379b						CALLMONITOR 
379b cd a6 fd			call debug_vector  
379e				endm  
# End of macro CALLMONITOR
379e					endif 
379e				; TODO replace below with ; exec using tok_ptr 
379e 22 f0 f3			ld (os_tok_ptr), hl 
37a1 c3 76 24			jp exec1 
37a4				NEXTW 
37a4 cd a3 fd			call parse_vector 
37a7 c3 f5 23			jp macro_next 
37aa				endm 
# End of macro NEXTW
37aa			 
37aa .. 00		.ifthen:  db "THEN",0 
37af			 
37af			.iftrue:		 
37af				; Exec next words normally 
37af			 
37af				; if true then exec following IF as normal 
37af					if DEBUG_FORTH_WORDS 
37af						DMARK "IFT" 
37af f5				push af  
37b0 3a c4 37			ld a, (.dmark)  
37b3 32 99 fd			ld (debug_mark),a  
37b6 3a c5 37			ld a, (.dmark+1)  
37b9 32 9a fd			ld (debug_mark+1),a  
37bc 3a c6 37			ld a, (.dmark+2)  
37bf 32 9b fd			ld (debug_mark+2),a  
37c2 18 03			jr .pastdmark  
37c4 ..			.dmark: db "IFT"  
37c7 f1			.pastdmark: pop af  
37c8			endm  
# End of macro DMARK
37c8						CALLMONITOR 
37c8 cd a6 fd			call debug_vector  
37cb				endm  
# End of macro CALLMONITOR
37cb					endif 
37cb			 
37cb					NEXTW 
37cb cd a3 fd			call parse_vector 
37ce c3 f5 23			jp macro_next 
37d1				endm 
# End of macro NEXTW
37d1			.THEN: 
37d1				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
37d1 1f				db WORD_SYS_CORE+11             
37d2 fc 37			dw .ELSE            
37d4 05				db 4 + 1 
37d5 .. 00			db "THEN",0              
37da				endm 
# End of macro CWHEAD
37da			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
37da					if DEBUG_FORTH_WORDS_KEY 
37da						DMARK "THN" 
37da f5				push af  
37db 3a ef 37			ld a, (.dmark)  
37de 32 99 fd			ld (debug_mark),a  
37e1 3a f0 37			ld a, (.dmark+1)  
37e4 32 9a fd			ld (debug_mark+1),a  
37e7 3a f1 37			ld a, (.dmark+2)  
37ea 32 9b fd			ld (debug_mark+2),a  
37ed 18 03			jr .pastdmark  
37ef ..			.dmark: db "THN"  
37f2 f1			.pastdmark: pop af  
37f3			endm  
# End of macro DMARK
37f3						CALLMONITOR 
37f3 cd a6 fd			call debug_vector  
37f6				endm  
# End of macro CALLMONITOR
37f6					endif 
37f6					NEXTW 
37f6 cd a3 fd			call parse_vector 
37f9 c3 f5 23			jp macro_next 
37fc				endm 
# End of macro NEXTW
37fc			.ELSE: 
37fc				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
37fc 20				db WORD_SYS_CORE+12             
37fd 27 38			dw .DO            
37ff 03				db 2 + 1 
3800 .. 00			db "ELSE",0              
3805				endm 
# End of macro CWHEAD
3805			; | ELSE ( -- ) Not supported - does nothing | TODO 
3805			 
3805					if DEBUG_FORTH_WORDS_KEY 
3805						DMARK "ELS" 
3805 f5				push af  
3806 3a 1a 38			ld a, (.dmark)  
3809 32 99 fd			ld (debug_mark),a  
380c 3a 1b 38			ld a, (.dmark+1)  
380f 32 9a fd			ld (debug_mark+1),a  
3812 3a 1c 38			ld a, (.dmark+2)  
3815 32 9b fd			ld (debug_mark+2),a  
3818 18 03			jr .pastdmark  
381a ..			.dmark: db "ELS"  
381d f1			.pastdmark: pop af  
381e			endm  
# End of macro DMARK
381e						CALLMONITOR 
381e cd a6 fd			call debug_vector  
3821				endm  
# End of macro CALLMONITOR
3821					endif 
3821			 
3821			 
3821					NEXTW 
3821 cd a3 fd			call parse_vector 
3824 c3 f5 23			jp macro_next 
3827				endm 
# End of macro NEXTW
3827			.DO: 
3827				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3827 21				db WORD_SYS_CORE+13             
3828 51 39			dw .LOOP            
382a 03				db 2 + 1 
382b .. 00			db "DO",0              
382e				endm 
# End of macro CWHEAD
382e			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
382e			 
382e					if DEBUG_FORTH_WORDS_KEY 
382e						DMARK "DO." 
382e f5				push af  
382f 3a 43 38			ld a, (.dmark)  
3832 32 99 fd			ld (debug_mark),a  
3835 3a 44 38			ld a, (.dmark+1)  
3838 32 9a fd			ld (debug_mark+1),a  
383b 3a 45 38			ld a, (.dmark+2)  
383e 32 9b fd			ld (debug_mark+2),a  
3841 18 03			jr .pastdmark  
3843 ..			.dmark: db "DO."  
3846 f1			.pastdmark: pop af  
3847			endm  
# End of macro DMARK
3847						CALLMONITOR 
3847 cd a6 fd			call debug_vector  
384a				endm  
# End of macro CALLMONITOR
384a					endif 
384a			;  push pc to rsp stack past the DO 
384a			 
384a 2a f0 f3				ld hl, (os_tok_ptr) 
384d 23					inc hl   ; D 
384e 23					inc hl  ; O 
384f 23					inc hl   ; null 
3850					if DEBUG_FORTH_WORDS 
3850						DMARK "DO2" 
3850 f5				push af  
3851 3a 65 38			ld a, (.dmark)  
3854 32 99 fd			ld (debug_mark),a  
3857 3a 66 38			ld a, (.dmark+1)  
385a 32 9a fd			ld (debug_mark+1),a  
385d 3a 67 38			ld a, (.dmark+2)  
3860 32 9b fd			ld (debug_mark+2),a  
3863 18 03			jr .pastdmark  
3865 ..			.dmark: db "DO2"  
3868 f1			.pastdmark: pop af  
3869			endm  
# End of macro DMARK
3869						CALLMONITOR 
3869 cd a6 fd			call debug_vector  
386c				endm  
# End of macro CALLMONITOR
386c					endif 
386c					FORTH_RSP_NEXT 
386c cd b9 1f			call macro_forth_rsp_next 
386f				endm 
# End of macro FORTH_RSP_NEXT
386f					if DEBUG_FORTH_WORDS 
386f						DMARK "DO3" 
386f f5				push af  
3870 3a 84 38			ld a, (.dmark)  
3873 32 99 fd			ld (debug_mark),a  
3876 3a 85 38			ld a, (.dmark+1)  
3879 32 9a fd			ld (debug_mark+1),a  
387c 3a 86 38			ld a, (.dmark+2)  
387f 32 9b fd			ld (debug_mark+2),a  
3882 18 03			jr .pastdmark  
3884 ..			.dmark: db "DO3"  
3887 f1			.pastdmark: pop af  
3888			endm  
# End of macro DMARK
3888						CALLMONITOR 
3888 cd a6 fd			call debug_vector  
388b				endm  
# End of macro CALLMONITOR
388b					endif 
388b			 
388b					;if DEBUG_FORTH_WORDS 
388b				;		push hl 
388b			;		endif  
388b			 
388b			; get counters from data stack 
388b			 
388b			 
388b					FORTH_DSP_VALUEHL 
388b cd 0e 22			call macro_dsp_valuehl 
388e				endm 
# End of macro FORTH_DSP_VALUEHL
388e e5					push hl		 ; hl now has starting counter which needs to be tos 
388f			 
388f					if DEBUG_FORTH_WORDS 
388f						DMARK "DO4" 
388f f5				push af  
3890 3a a4 38			ld a, (.dmark)  
3893 32 99 fd			ld (debug_mark),a  
3896 3a a5 38			ld a, (.dmark+1)  
3899 32 9a fd			ld (debug_mark+1),a  
389c 3a a6 38			ld a, (.dmark+2)  
389f 32 9b fd			ld (debug_mark+2),a  
38a2 18 03			jr .pastdmark  
38a4 ..			.dmark: db "DO4"  
38a7 f1			.pastdmark: pop af  
38a8			endm  
# End of macro DMARK
38a8						CALLMONITOR 
38a8 cd a6 fd			call debug_vector  
38ab				endm  
# End of macro CALLMONITOR
38ab					endif 
38ab					FORTH_DSP_POP 
38ab cd c6 22			call macro_forth_dsp_pop 
38ae				endm 
# End of macro FORTH_DSP_POP
38ae			 
38ae					if DEBUG_FORTH_WORDS 
38ae						DMARK "DO5" 
38ae f5				push af  
38af 3a c3 38			ld a, (.dmark)  
38b2 32 99 fd			ld (debug_mark),a  
38b5 3a c4 38			ld a, (.dmark+1)  
38b8 32 9a fd			ld (debug_mark+1),a  
38bb 3a c5 38			ld a, (.dmark+2)  
38be 32 9b fd			ld (debug_mark+2),a  
38c1 18 03			jr .pastdmark  
38c3 ..			.dmark: db "DO5"  
38c6 f1			.pastdmark: pop af  
38c7			endm  
# End of macro DMARK
38c7						CALLMONITOR 
38c7 cd a6 fd			call debug_vector  
38ca				endm  
# End of macro CALLMONITOR
38ca					endif 
38ca			 
38ca					FORTH_DSP_VALUEHL 
38ca cd 0e 22			call macro_dsp_valuehl 
38cd				endm 
# End of macro FORTH_DSP_VALUEHL
38cd			;		push hl		 ; hl now has starting limit counter 
38cd			 
38cd					if DEBUG_FORTH_WORDS 
38cd						DMARK "DO6" 
38cd f5				push af  
38ce 3a e2 38			ld a, (.dmark)  
38d1 32 99 fd			ld (debug_mark),a  
38d4 3a e3 38			ld a, (.dmark+1)  
38d7 32 9a fd			ld (debug_mark+1),a  
38da 3a e4 38			ld a, (.dmark+2)  
38dd 32 9b fd			ld (debug_mark+2),a  
38e0 18 03			jr .pastdmark  
38e2 ..			.dmark: db "DO6"  
38e5 f1			.pastdmark: pop af  
38e6			endm  
# End of macro DMARK
38e6						CALLMONITOR 
38e6 cd a6 fd			call debug_vector  
38e9				endm  
# End of macro CALLMONITOR
38e9					endif 
38e9					FORTH_DSP_POP 
38e9 cd c6 22			call macro_forth_dsp_pop 
38ec				endm 
# End of macro FORTH_DSP_POP
38ec			 
38ec			; put counters on the loop stack 
38ec			 
38ec			;		pop hl			 ; limit counter 
38ec d1					pop de			; start counter 
38ed			 
38ed					; push limit counter 
38ed			 
38ed					if DEBUG_FORTH_WORDS 
38ed						DMARK "DO7" 
38ed f5				push af  
38ee 3a 02 39			ld a, (.dmark)  
38f1 32 99 fd			ld (debug_mark),a  
38f4 3a 03 39			ld a, (.dmark+1)  
38f7 32 9a fd			ld (debug_mark+1),a  
38fa 3a 04 39			ld a, (.dmark+2)  
38fd 32 9b fd			ld (debug_mark+2),a  
3900 18 03			jr .pastdmark  
3902 ..			.dmark: db "DO7"  
3905 f1			.pastdmark: pop af  
3906			endm  
# End of macro DMARK
3906						CALLMONITOR 
3906 cd a6 fd			call debug_vector  
3909				endm  
# End of macro CALLMONITOR
3909					endif 
3909					FORTH_LOOP_NEXT 
3909 cd 3f 22			call macro_forth_loop_next 
390c				endm 
# End of macro FORTH_LOOP_NEXT
390c			 
390c					; push start counter 
390c			 
390c eb					ex de, hl 
390d					if DEBUG_FORTH_WORDS 
390d						DMARK "DO7" 
390d f5				push af  
390e 3a 22 39			ld a, (.dmark)  
3911 32 99 fd			ld (debug_mark),a  
3914 3a 23 39			ld a, (.dmark+1)  
3917 32 9a fd			ld (debug_mark+1),a  
391a 3a 24 39			ld a, (.dmark+2)  
391d 32 9b fd			ld (debug_mark+2),a  
3920 18 03			jr .pastdmark  
3922 ..			.dmark: db "DO7"  
3925 f1			.pastdmark: pop af  
3926			endm  
# End of macro DMARK
3926						CALLMONITOR 
3926 cd a6 fd			call debug_vector  
3929				endm  
# End of macro CALLMONITOR
3929					endif 
3929					FORTH_LOOP_NEXT 
3929 cd 3f 22			call macro_forth_loop_next 
392c				endm 
# End of macro FORTH_LOOP_NEXT
392c			 
392c			 
392c					; init first round of I counter 
392c			 
392c 22 14 f4				ld (os_current_i), hl 
392f			 
392f					if DEBUG_FORTH_WORDS 
392f						DMARK "DO8" 
392f f5				push af  
3930 3a 44 39			ld a, (.dmark)  
3933 32 99 fd			ld (debug_mark),a  
3936 3a 45 39			ld a, (.dmark+1)  
3939 32 9a fd			ld (debug_mark+1),a  
393c 3a 46 39			ld a, (.dmark+2)  
393f 32 9b fd			ld (debug_mark+2),a  
3942 18 03			jr .pastdmark  
3944 ..			.dmark: db "DO8"  
3947 f1			.pastdmark: pop af  
3948			endm  
# End of macro DMARK
3948						CALLMONITOR 
3948 cd a6 fd			call debug_vector  
394b				endm  
# End of macro CALLMONITOR
394b					endif 
394b			 
394b					NEXTW 
394b cd a3 fd			call parse_vector 
394e c3 f5 23			jp macro_next 
3951				endm 
# End of macro NEXTW
3951			.LOOP: 
3951				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3951 22				db WORD_SYS_CORE+14             
3952 6f 3a			dw .I            
3954 05				db 4 + 1 
3955 .. 00			db "LOOP",0              
395a				endm 
# End of macro CWHEAD
395a			; | LOOP ( -- ) Increment and test loop counter  | DONE 
395a			 
395a				; pop tos as current loop count to hl 
395a			 
395a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
395a			 
395a				FORTH_LOOP_TOS 
395a cd 72 22			call macro_forth_loop_tos 
395d				endm 
# End of macro FORTH_LOOP_TOS
395d e5				push hl 
395e			 
395e					if DEBUG_FORTH_WORDS_KEY 
395e						DMARK "LOP" 
395e f5				push af  
395f 3a 73 39			ld a, (.dmark)  
3962 32 99 fd			ld (debug_mark),a  
3965 3a 74 39			ld a, (.dmark+1)  
3968 32 9a fd			ld (debug_mark+1),a  
396b 3a 75 39			ld a, (.dmark+2)  
396e 32 9b fd			ld (debug_mark+2),a  
3971 18 03			jr .pastdmark  
3973 ..			.dmark: db "LOP"  
3976 f1			.pastdmark: pop af  
3977			endm  
# End of macro DMARK
3977						CALLMONITOR 
3977 cd a6 fd			call debug_vector  
397a				endm  
# End of macro CALLMONITOR
397a					endif 
397a				; next item on the stack is the limit. get it 
397a			 
397a			 
397a				FORTH_LOOP_POP 
397a cd 7c 22			call macro_forth_loop_pop 
397d				endm 
# End of macro FORTH_LOOP_POP
397d			 
397d				FORTH_LOOP_TOS 
397d cd 72 22			call macro_forth_loop_tos 
3980				endm 
# End of macro FORTH_LOOP_TOS
3980			 
3980 d1				pop de		 ; de = i, hl = limit 
3981			 
3981					if DEBUG_FORTH_WORDS 
3981						DMARK "LP1" 
3981 f5				push af  
3982 3a 96 39			ld a, (.dmark)  
3985 32 99 fd			ld (debug_mark),a  
3988 3a 97 39			ld a, (.dmark+1)  
398b 32 9a fd			ld (debug_mark+1),a  
398e 3a 98 39			ld a, (.dmark+2)  
3991 32 9b fd			ld (debug_mark+2),a  
3994 18 03			jr .pastdmark  
3996 ..			.dmark: db "LP1"  
3999 f1			.pastdmark: pop af  
399a			endm  
# End of macro DMARK
399a						CALLMONITOR 
399a cd a6 fd			call debug_vector  
399d				endm  
# End of macro CALLMONITOR
399d					endif 
399d			 
399d				; go back to previous word 
399d			 
399d d5				push de    ; save I for inc later 
399e			 
399e			 
399e				; get limit 
399e				;  is I at limit? 
399e			 
399e			 
399e					if DEBUG_FORTH_WORDS 
399e						DMARK "LP1" 
399e f5				push af  
399f 3a b3 39			ld a, (.dmark)  
39a2 32 99 fd			ld (debug_mark),a  
39a5 3a b4 39			ld a, (.dmark+1)  
39a8 32 9a fd			ld (debug_mark+1),a  
39ab 3a b5 39			ld a, (.dmark+2)  
39ae 32 9b fd			ld (debug_mark+2),a  
39b1 18 03			jr .pastdmark  
39b3 ..			.dmark: db "LP1"  
39b6 f1			.pastdmark: pop af  
39b7			endm  
# End of macro DMARK
39b7						CALLMONITOR 
39b7 cd a6 fd			call debug_vector  
39ba				endm  
# End of macro CALLMONITOR
39ba					endif 
39ba			 
39ba ed 52			sbc hl, de 
39bc			 
39bc			 
39bc				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
39bc			 
39bc 20 29				jr nz, .loopnotdone 
39be			 
39be e1				pop hl   ; get rid of saved I 
39bf				FORTH_LOOP_POP     ; get rid of limit 
39bf cd 7c 22			call macro_forth_loop_pop 
39c2				endm 
# End of macro FORTH_LOOP_POP
39c2			 
39c2				FORTH_RSP_POP     ; get rid of DO ptr 
39c2 cd da 1f			call macro_forth_rsp_pop 
39c5				endm 
# End of macro FORTH_RSP_POP
39c5			 
39c5			if DEBUG_FORTH_WORDS 
39c5						DMARK "LP>" 
39c5 f5				push af  
39c6 3a da 39			ld a, (.dmark)  
39c9 32 99 fd			ld (debug_mark),a  
39cc 3a db 39			ld a, (.dmark+1)  
39cf 32 9a fd			ld (debug_mark+1),a  
39d2 3a dc 39			ld a, (.dmark+2)  
39d5 32 9b fd			ld (debug_mark+2),a  
39d8 18 03			jr .pastdmark  
39da ..			.dmark: db "LP>"  
39dd f1			.pastdmark: pop af  
39de			endm  
# End of macro DMARK
39de				CALLMONITOR 
39de cd a6 fd			call debug_vector  
39e1				endm  
# End of macro CALLMONITOR
39e1			endif 
39e1			 
39e1					NEXTW 
39e1 cd a3 fd			call parse_vector 
39e4 c3 f5 23			jp macro_next 
39e7				endm 
# End of macro NEXTW
39e7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
39e7			 
39e7			.loopnotdone: 
39e7			 
39e7 e1				pop hl    ; get I 
39e8 23				inc hl 
39e9			 
39e9			   	; save new I 
39e9			 
39e9			 
39e9					; set I counter 
39e9			 
39e9 22 14 f4				ld (os_current_i), hl 
39ec			 
39ec					if DEBUG_FORTH_WORDS 
39ec						DMARK "LPN" 
39ec f5				push af  
39ed 3a 01 3a			ld a, (.dmark)  
39f0 32 99 fd			ld (debug_mark),a  
39f3 3a 02 3a			ld a, (.dmark+1)  
39f6 32 9a fd			ld (debug_mark+1),a  
39f9 3a 03 3a			ld a, (.dmark+2)  
39fc 32 9b fd			ld (debug_mark+2),a  
39ff 18 03			jr .pastdmark  
3a01 ..			.dmark: db "LPN"  
3a04 f1			.pastdmark: pop af  
3a05			endm  
# End of macro DMARK
3a05					CALLMONITOR 
3a05 cd a6 fd			call debug_vector  
3a08				endm  
# End of macro CALLMONITOR
3a08					endif 
3a08					 
3a08				FORTH_LOOP_NEXT 
3a08 cd 3f 22			call macro_forth_loop_next 
3a0b				endm 
# End of macro FORTH_LOOP_NEXT
3a0b			 
3a0b			 
3a0b					if DEBUG_FORTH_WORDS 
3a0b eb						ex de,hl 
3a0c					endif 
3a0c			 
3a0c			;	; get DO ptr 
3a0c			; 
3a0c					if DEBUG_FORTH_WORDS 
3a0c						DMARK "LP7" 
3a0c f5				push af  
3a0d 3a 21 3a			ld a, (.dmark)  
3a10 32 99 fd			ld (debug_mark),a  
3a13 3a 22 3a			ld a, (.dmark+1)  
3a16 32 9a fd			ld (debug_mark+1),a  
3a19 3a 23 3a			ld a, (.dmark+2)  
3a1c 32 9b fd			ld (debug_mark+2),a  
3a1f 18 03			jr .pastdmark  
3a21 ..			.dmark: db "LP7"  
3a24 f1			.pastdmark: pop af  
3a25			endm  
# End of macro DMARK
3a25					CALLMONITOR 
3a25 cd a6 fd			call debug_vector  
3a28				endm  
# End of macro CALLMONITOR
3a28					endif 
3a28				FORTH_RSP_TOS 
3a28 cd d0 1f			call macro_forth_rsp_tos 
3a2b				endm 
# End of macro FORTH_RSP_TOS
3a2b			 
3a2b					if DEBUG_FORTH_WORDS 
3a2b						DMARK "LP8" 
3a2b f5				push af  
3a2c 3a 40 3a			ld a, (.dmark)  
3a2f 32 99 fd			ld (debug_mark),a  
3a32 3a 41 3a			ld a, (.dmark+1)  
3a35 32 9a fd			ld (debug_mark+1),a  
3a38 3a 42 3a			ld a, (.dmark+2)  
3a3b 32 9b fd			ld (debug_mark+2),a  
3a3e 18 03			jr .pastdmark  
3a40 ..			.dmark: db "LP8"  
3a43 f1			.pastdmark: pop af  
3a44			endm  
# End of macro DMARK
3a44					CALLMONITOR 
3a44 cd a6 fd			call debug_vector  
3a47				endm  
# End of macro CALLMONITOR
3a47					endif 
3a47				;push hl 
3a47			 
3a47				; not going to DO any more 
3a47				; get rid of the RSP pointer as DO will add it back in 
3a47				;FORTH_RSP_POP 
3a47				;pop hl 
3a47			 
3a47				;ld hl,(cli_ret_sp) 
3a47				;ld e, (hl) 
3a47				;inc hl 
3a47				;ld d, (hl) 
3a47				;ex de,hl 
3a47 22 f0 f3			ld (os_tok_ptr), hl 
3a4a					if DEBUG_FORTH_WORDS 
3a4a						DMARK "LP<" 
3a4a f5				push af  
3a4b 3a 5f 3a			ld a, (.dmark)  
3a4e 32 99 fd			ld (debug_mark),a  
3a51 3a 60 3a			ld a, (.dmark+1)  
3a54 32 9a fd			ld (debug_mark+1),a  
3a57 3a 61 3a			ld a, (.dmark+2)  
3a5a 32 9b fd			ld (debug_mark+2),a  
3a5d 18 03			jr .pastdmark  
3a5f ..			.dmark: db "LP<"  
3a62 f1			.pastdmark: pop af  
3a63			endm  
# End of macro DMARK
3a63					CALLMONITOR 
3a63 cd a6 fd			call debug_vector  
3a66				endm  
# End of macro CALLMONITOR
3a66				endif 
3a66 c3 76 24			jp exec1 
3a69			 
3a69					 
3a69			 
3a69			 
3a69					NEXTW 
3a69 cd a3 fd			call parse_vector 
3a6c c3 f5 23			jp macro_next 
3a6f				endm 
# End of macro NEXTW
3a6f			.I:  
3a6f			 
3a6f				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3a6f 5e				db WORD_SYS_CORE+74             
3a70 9d 3a			dw .DLOOP            
3a72 02				db 1 + 1 
3a73 .. 00			db "I",0              
3a75				endm 
# End of macro CWHEAD
3a75			; | I ( -- ) Current loop counter | DONE 
3a75					if DEBUG_FORTH_WORDS_KEY 
3a75						DMARK "I.." 
3a75 f5				push af  
3a76 3a 8a 3a			ld a, (.dmark)  
3a79 32 99 fd			ld (debug_mark),a  
3a7c 3a 8b 3a			ld a, (.dmark+1)  
3a7f 32 9a fd			ld (debug_mark+1),a  
3a82 3a 8c 3a			ld a, (.dmark+2)  
3a85 32 9b fd			ld (debug_mark+2),a  
3a88 18 03			jr .pastdmark  
3a8a ..			.dmark: db "I.."  
3a8d f1			.pastdmark: pop af  
3a8e			endm  
# End of macro DMARK
3a8e						CALLMONITOR 
3a8e cd a6 fd			call debug_vector  
3a91				endm  
# End of macro CALLMONITOR
3a91					endif 
3a91			 
3a91 2a 14 f4				ld hl,(os_current_i) 
3a94 cd 12 20				call forth_push_numhl 
3a97			 
3a97					NEXTW 
3a97 cd a3 fd			call parse_vector 
3a9a c3 f5 23			jp macro_next 
3a9d				endm 
# End of macro NEXTW
3a9d			.DLOOP: 
3a9d				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3a9d 5f				db WORD_SYS_CORE+75             
3a9e 84 3b			dw .REPEAT            
3aa0 06				db 5 + 1 
3aa1 .. 00			db "-LOOP",0              
3aa7				endm 
# End of macro CWHEAD
3aa7			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3aa7				; pop tos as current loop count to hl 
3aa7					if DEBUG_FORTH_WORDS_KEY 
3aa7						DMARK "-LP" 
3aa7 f5				push af  
3aa8 3a bc 3a			ld a, (.dmark)  
3aab 32 99 fd			ld (debug_mark),a  
3aae 3a bd 3a			ld a, (.dmark+1)  
3ab1 32 9a fd			ld (debug_mark+1),a  
3ab4 3a be 3a			ld a, (.dmark+2)  
3ab7 32 9b fd			ld (debug_mark+2),a  
3aba 18 03			jr .pastdmark  
3abc ..			.dmark: db "-LP"  
3abf f1			.pastdmark: pop af  
3ac0			endm  
# End of macro DMARK
3ac0						CALLMONITOR 
3ac0 cd a6 fd			call debug_vector  
3ac3				endm  
# End of macro CALLMONITOR
3ac3					endif 
3ac3			 
3ac3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3ac3			 
3ac3				FORTH_LOOP_TOS 
3ac3 cd 72 22			call macro_forth_loop_tos 
3ac6				endm 
# End of macro FORTH_LOOP_TOS
3ac6 e5				push hl 
3ac7			 
3ac7					if DEBUG_FORTH_WORDS 
3ac7						DMARK "-LP" 
3ac7 f5				push af  
3ac8 3a dc 3a			ld a, (.dmark)  
3acb 32 99 fd			ld (debug_mark),a  
3ace 3a dd 3a			ld a, (.dmark+1)  
3ad1 32 9a fd			ld (debug_mark+1),a  
3ad4 3a de 3a			ld a, (.dmark+2)  
3ad7 32 9b fd			ld (debug_mark+2),a  
3ada 18 03			jr .pastdmark  
3adc ..			.dmark: db "-LP"  
3adf f1			.pastdmark: pop af  
3ae0			endm  
# End of macro DMARK
3ae0						CALLMONITOR 
3ae0 cd a6 fd			call debug_vector  
3ae3				endm  
# End of macro CALLMONITOR
3ae3					endif 
3ae3				; next item on the stack is the limit. get it 
3ae3			 
3ae3			 
3ae3				FORTH_LOOP_POP 
3ae3 cd 7c 22			call macro_forth_loop_pop 
3ae6				endm 
# End of macro FORTH_LOOP_POP
3ae6			 
3ae6				FORTH_LOOP_TOS 
3ae6 cd 72 22			call macro_forth_loop_tos 
3ae9				endm 
# End of macro FORTH_LOOP_TOS
3ae9			 
3ae9 d1				pop de		 ; de = i, hl = limit 
3aea			 
3aea					if DEBUG_FORTH_WORDS 
3aea						DMARK "-L1" 
3aea f5				push af  
3aeb 3a ff 3a			ld a, (.dmark)  
3aee 32 99 fd			ld (debug_mark),a  
3af1 3a 00 3b			ld a, (.dmark+1)  
3af4 32 9a fd			ld (debug_mark+1),a  
3af7 3a 01 3b			ld a, (.dmark+2)  
3afa 32 9b fd			ld (debug_mark+2),a  
3afd 18 03			jr .pastdmark  
3aff ..			.dmark: db "-L1"  
3b02 f1			.pastdmark: pop af  
3b03			endm  
# End of macro DMARK
3b03						CALLMONITOR 
3b03 cd a6 fd			call debug_vector  
3b06				endm  
# End of macro CALLMONITOR
3b06					endif 
3b06			 
3b06				; go back to previous word 
3b06			 
3b06 d5				push de    ; save I for inc later 
3b07			 
3b07			 
3b07				; get limit 
3b07				;  is I at limit? 
3b07			 
3b07			 
3b07					if DEBUG_FORTH_WORDS 
3b07						DMARK "-L1" 
3b07 f5				push af  
3b08 3a 1c 3b			ld a, (.dmark)  
3b0b 32 99 fd			ld (debug_mark),a  
3b0e 3a 1d 3b			ld a, (.dmark+1)  
3b11 32 9a fd			ld (debug_mark+1),a  
3b14 3a 1e 3b			ld a, (.dmark+2)  
3b17 32 9b fd			ld (debug_mark+2),a  
3b1a 18 03			jr .pastdmark  
3b1c ..			.dmark: db "-L1"  
3b1f f1			.pastdmark: pop af  
3b20			endm  
# End of macro DMARK
3b20						CALLMONITOR 
3b20 cd a6 fd			call debug_vector  
3b23				endm  
# End of macro CALLMONITOR
3b23					endif 
3b23			 
3b23 ed 52			sbc hl, de 
3b25			 
3b25			 
3b25				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3b25			 
3b25 20 29				jr nz, .mloopnotdone 
3b27			 
3b27 e1				pop hl   ; get rid of saved I 
3b28				FORTH_LOOP_POP     ; get rid of limit 
3b28 cd 7c 22			call macro_forth_loop_pop 
3b2b				endm 
# End of macro FORTH_LOOP_POP
3b2b			 
3b2b				FORTH_RSP_POP     ; get rid of DO ptr 
3b2b cd da 1f			call macro_forth_rsp_pop 
3b2e				endm 
# End of macro FORTH_RSP_POP
3b2e			 
3b2e			if DEBUG_FORTH_WORDS 
3b2e						DMARK "-L>" 
3b2e f5				push af  
3b2f 3a 43 3b			ld a, (.dmark)  
3b32 32 99 fd			ld (debug_mark),a  
3b35 3a 44 3b			ld a, (.dmark+1)  
3b38 32 9a fd			ld (debug_mark+1),a  
3b3b 3a 45 3b			ld a, (.dmark+2)  
3b3e 32 9b fd			ld (debug_mark+2),a  
3b41 18 03			jr .pastdmark  
3b43 ..			.dmark: db "-L>"  
3b46 f1			.pastdmark: pop af  
3b47			endm  
# End of macro DMARK
3b47				CALLMONITOR 
3b47 cd a6 fd			call debug_vector  
3b4a				endm  
# End of macro CALLMONITOR
3b4a			endif 
3b4a			 
3b4a					NEXTW 
3b4a cd a3 fd			call parse_vector 
3b4d c3 f5 23			jp macro_next 
3b50				endm 
# End of macro NEXTW
3b50				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3b50			 
3b50			.mloopnotdone: 
3b50			 
3b50 e1				pop hl    ; get I 
3b51 2b				dec hl 
3b52			 
3b52			   	; save new I 
3b52			 
3b52			 
3b52					; set I counter 
3b52			 
3b52 22 14 f4				ld (os_current_i), hl 
3b55			 
3b55					 
3b55				FORTH_LOOP_NEXT 
3b55 cd 3f 22			call macro_forth_loop_next 
3b58				endm 
# End of macro FORTH_LOOP_NEXT
3b58			 
3b58			 
3b58					if DEBUG_FORTH_WORDS 
3b58 eb						ex de,hl 
3b59					endif 
3b59			 
3b59			;	; get DO ptr 
3b59			; 
3b59				FORTH_RSP_TOS 
3b59 cd d0 1f			call macro_forth_rsp_tos 
3b5c				endm 
# End of macro FORTH_RSP_TOS
3b5c			 
3b5c				;push hl 
3b5c			 
3b5c				; not going to DO any more 
3b5c				; get rid of the RSP pointer as DO will add it back in 
3b5c				;FORTH_RSP_POP 
3b5c				;pop hl 
3b5c			 
3b5c			 
3b5c 22 f0 f3			ld (os_tok_ptr), hl 
3b5f					if DEBUG_FORTH_WORDS 
3b5f						DMARK "-L<" 
3b5f f5				push af  
3b60 3a 74 3b			ld a, (.dmark)  
3b63 32 99 fd			ld (debug_mark),a  
3b66 3a 75 3b			ld a, (.dmark+1)  
3b69 32 9a fd			ld (debug_mark+1),a  
3b6c 3a 76 3b			ld a, (.dmark+2)  
3b6f 32 9b fd			ld (debug_mark+2),a  
3b72 18 03			jr .pastdmark  
3b74 ..			.dmark: db "-L<"  
3b77 f1			.pastdmark: pop af  
3b78			endm  
# End of macro DMARK
3b78					CALLMONITOR 
3b78 cd a6 fd			call debug_vector  
3b7b				endm  
# End of macro CALLMONITOR
3b7b				endif 
3b7b c3 76 24			jp exec1 
3b7e			 
3b7e					 
3b7e			 
3b7e			 
3b7e			 
3b7e				NEXTW 
3b7e cd a3 fd			call parse_vector 
3b81 c3 f5 23			jp macro_next 
3b84				endm 
# End of macro NEXTW
3b84			 
3b84			 
3b84			 
3b84			 
3b84			.REPEAT: 
3b84				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3b84 71				db WORD_SYS_CORE+93             
3b85 da 3b			dw .UNTIL            
3b87 06				db 5 + 1 
3b88 .. 00			db "REPEAT",0              
3b8f				endm 
# End of macro CWHEAD
3b8f			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3b8f			;  push pc to rsp stack past the REPEAT 
3b8f					if DEBUG_FORTH_WORDS_KEY 
3b8f						DMARK "REP" 
3b8f f5				push af  
3b90 3a a4 3b			ld a, (.dmark)  
3b93 32 99 fd			ld (debug_mark),a  
3b96 3a a5 3b			ld a, (.dmark+1)  
3b99 32 9a fd			ld (debug_mark+1),a  
3b9c 3a a6 3b			ld a, (.dmark+2)  
3b9f 32 9b fd			ld (debug_mark+2),a  
3ba2 18 03			jr .pastdmark  
3ba4 ..			.dmark: db "REP"  
3ba7 f1			.pastdmark: pop af  
3ba8			endm  
# End of macro DMARK
3ba8						CALLMONITOR 
3ba8 cd a6 fd			call debug_vector  
3bab				endm  
# End of macro CALLMONITOR
3bab					endif 
3bab			 
3bab 2a f0 f3				ld hl, (os_tok_ptr) 
3bae 23					inc hl   ; R 
3baf 23					inc hl  ; E 
3bb0 23					inc hl   ; P 
3bb1 23					inc hl   ; E 
3bb2 23					inc hl   ; A 
3bb3 23					inc hl   ; T 
3bb4 23					inc hl   ; zero 
3bb5					FORTH_RSP_NEXT 
3bb5 cd b9 1f			call macro_forth_rsp_next 
3bb8				endm 
# End of macro FORTH_RSP_NEXT
3bb8			 
3bb8			 
3bb8					if DEBUG_FORTH_WORDS 
3bb8						DMARK "REP" 
3bb8 f5				push af  
3bb9 3a cd 3b			ld a, (.dmark)  
3bbc 32 99 fd			ld (debug_mark),a  
3bbf 3a ce 3b			ld a, (.dmark+1)  
3bc2 32 9a fd			ld (debug_mark+1),a  
3bc5 3a cf 3b			ld a, (.dmark+2)  
3bc8 32 9b fd			ld (debug_mark+2),a  
3bcb 18 03			jr .pastdmark  
3bcd ..			.dmark: db "REP"  
3bd0 f1			.pastdmark: pop af  
3bd1			endm  
# End of macro DMARK
3bd1						;pop bc    ; TODO BUG ?????? what is this for???? 
3bd1						CALLMONITOR 
3bd1 cd a6 fd			call debug_vector  
3bd4				endm  
# End of macro CALLMONITOR
3bd4					endif 
3bd4			 
3bd4					NEXTW 
3bd4 cd a3 fd			call parse_vector 
3bd7 c3 f5 23			jp macro_next 
3bda				endm 
# End of macro NEXTW
3bda			;	       NEXTW 
3bda			 
3bda			.UNTIL: 
3bda				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3bda 72				db WORD_SYS_CORE+94             
3bdb 77 3c			dw .ENDFLOW            
3bdd 06				db 5 + 1 
3bde .. 00			db "UNTIL",0              
3be4				endm 
# End of macro CWHEAD
3be4			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3be4			 
3be4				; pop tos as check 
3be4			 
3be4				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3be4			 
3be4				FORTH_DSP_VALUEHL 
3be4 cd 0e 22			call macro_dsp_valuehl 
3be7				endm 
# End of macro FORTH_DSP_VALUEHL
3be7			 
3be7					if DEBUG_FORTH_WORDS_KEY 
3be7						DMARK "UNT" 
3be7 f5				push af  
3be8 3a fc 3b			ld a, (.dmark)  
3beb 32 99 fd			ld (debug_mark),a  
3bee 3a fd 3b			ld a, (.dmark+1)  
3bf1 32 9a fd			ld (debug_mark+1),a  
3bf4 3a fe 3b			ld a, (.dmark+2)  
3bf7 32 9b fd			ld (debug_mark+2),a  
3bfa 18 03			jr .pastdmark  
3bfc ..			.dmark: db "UNT"  
3bff f1			.pastdmark: pop af  
3c00			endm  
# End of macro DMARK
3c00						CALLMONITOR 
3c00 cd a6 fd			call debug_vector  
3c03				endm  
# End of macro CALLMONITOR
3c03					endif 
3c03			 
3c03			;	push hl 
3c03				FORTH_DSP_POP 
3c03 cd c6 22			call macro_forth_dsp_pop 
3c06				endm 
# End of macro FORTH_DSP_POP
3c06			 
3c06			;	pop hl 
3c06			 
3c06				; test if true 
3c06			 
3c06 cd da 0f			call ishlzero 
3c09			;	ld a,l 
3c09			;	add h 
3c09			; 
3c09			;	cp 0 
3c09			 
3c09 20 41			jr nz, .untilnotdone 
3c0b			 
3c0b					if DEBUG_FORTH_WORDS 
3c0b						DMARK "UNf" 
3c0b f5				push af  
3c0c 3a 20 3c			ld a, (.dmark)  
3c0f 32 99 fd			ld (debug_mark),a  
3c12 3a 21 3c			ld a, (.dmark+1)  
3c15 32 9a fd			ld (debug_mark+1),a  
3c18 3a 22 3c			ld a, (.dmark+2)  
3c1b 32 9b fd			ld (debug_mark+2),a  
3c1e 18 03			jr .pastdmark  
3c20 ..			.dmark: db "UNf"  
3c23 f1			.pastdmark: pop af  
3c24			endm  
# End of macro DMARK
3c24						CALLMONITOR 
3c24 cd a6 fd			call debug_vector  
3c27				endm  
# End of macro CALLMONITOR
3c27					endif 
3c27			 
3c27			 
3c27			 
3c27				FORTH_RSP_POP     ; get rid of DO ptr 
3c27 cd da 1f			call macro_forth_rsp_pop 
3c2a				endm 
# End of macro FORTH_RSP_POP
3c2a			 
3c2a			if DEBUG_FORTH_WORDS 
3c2a						DMARK "UN>" 
3c2a f5				push af  
3c2b 3a 3f 3c			ld a, (.dmark)  
3c2e 32 99 fd			ld (debug_mark),a  
3c31 3a 40 3c			ld a, (.dmark+1)  
3c34 32 9a fd			ld (debug_mark+1),a  
3c37 3a 41 3c			ld a, (.dmark+2)  
3c3a 32 9b fd			ld (debug_mark+2),a  
3c3d 18 03			jr .pastdmark  
3c3f ..			.dmark: db "UN>"  
3c42 f1			.pastdmark: pop af  
3c43			endm  
# End of macro DMARK
3c43				CALLMONITOR 
3c43 cd a6 fd			call debug_vector  
3c46				endm  
# End of macro CALLMONITOR
3c46			endif 
3c46			 
3c46					NEXTW 
3c46 cd a3 fd			call parse_vector 
3c49 c3 f5 23			jp macro_next 
3c4c				endm 
# End of macro NEXTW
3c4c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3c4c			 
3c4c			.untilnotdone: 
3c4c			 
3c4c			 
3c4c			;	; get DO ptr 
3c4c			; 
3c4c				FORTH_RSP_TOS 
3c4c cd d0 1f			call macro_forth_rsp_tos 
3c4f				endm 
# End of macro FORTH_RSP_TOS
3c4f			 
3c4f				;push hl 
3c4f			 
3c4f				; not going to DO any more 
3c4f				; get rid of the RSP pointer as DO will add it back in 
3c4f				;FORTH_RSP_POP 
3c4f				;pop hl 
3c4f			 
3c4f			 
3c4f 22 f0 f3			ld (os_tok_ptr), hl 
3c52					if DEBUG_FORTH_WORDS 
3c52						DMARK "UN<" 
3c52 f5				push af  
3c53 3a 67 3c			ld a, (.dmark)  
3c56 32 99 fd			ld (debug_mark),a  
3c59 3a 68 3c			ld a, (.dmark+1)  
3c5c 32 9a fd			ld (debug_mark+1),a  
3c5f 3a 69 3c			ld a, (.dmark+2)  
3c62 32 9b fd			ld (debug_mark+2),a  
3c65 18 03			jr .pastdmark  
3c67 ..			.dmark: db "UN<"  
3c6a f1			.pastdmark: pop af  
3c6b			endm  
# End of macro DMARK
3c6b					CALLMONITOR 
3c6b cd a6 fd			call debug_vector  
3c6e				endm  
# End of macro CALLMONITOR
3c6e				endif 
3c6e c3 76 24			jp exec1 
3c71			 
3c71					 
3c71			 
3c71			 
3c71					NEXTW 
3c71 cd a3 fd			call parse_vector 
3c74 c3 f5 23			jp macro_next 
3c77				endm 
# End of macro NEXTW
3c77			 
3c77			 
3c77			.ENDFLOW: 
3c77			 
3c77			; eof 
3c77			 
# End of file forth_words_flow.asm
3c77			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3c77			include "forth_words_logic.asm" 
3c77			 
3c77			; | ## Logic Words 
3c77			 
3c77			.NOT: 
3c77				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3c77 2d				db WORD_SYS_CORE+25             
3c78 c5 3c			dw .IS            
3c7a 04				db 3 + 1 
3c7b .. 00			db "NOT",0              
3c7f				endm 
# End of macro CWHEAD
3c7f			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3c7f					if DEBUG_FORTH_WORDS_KEY 
3c7f						DMARK "NOT" 
3c7f f5				push af  
3c80 3a 94 3c			ld a, (.dmark)  
3c83 32 99 fd			ld (debug_mark),a  
3c86 3a 95 3c			ld a, (.dmark+1)  
3c89 32 9a fd			ld (debug_mark+1),a  
3c8c 3a 96 3c			ld a, (.dmark+2)  
3c8f 32 9b fd			ld (debug_mark+2),a  
3c92 18 03			jr .pastdmark  
3c94 ..			.dmark: db "NOT"  
3c97 f1			.pastdmark: pop af  
3c98			endm  
# End of macro DMARK
3c98						CALLMONITOR 
3c98 cd a6 fd			call debug_vector  
3c9b				endm  
# End of macro CALLMONITOR
3c9b					endif 
3c9b					FORTH_DSP 
3c9b cd d4 21			call macro_forth_dsp 
3c9e				endm 
# End of macro FORTH_DSP
3c9e 7e					ld a,(hl)	; get type of value on TOS 
3c9f fe 02				cp DS_TYPE_INUM  
3ca1 28 06				jr z, .noti 
3ca3					NEXTW 
3ca3 cd a3 fd			call parse_vector 
3ca6 c3 f5 23			jp macro_next 
3ca9				endm 
# End of macro NEXTW
3ca9			.noti:          FORTH_DSP_VALUEHL 
3ca9 cd 0e 22			call macro_dsp_valuehl 
3cac				endm 
# End of macro FORTH_DSP_VALUEHL
3cac			;		push hl 
3cac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cac cd c6 22			call macro_forth_dsp_pop 
3caf				endm 
# End of macro FORTH_DSP_POP
3caf			;		pop hl 
3caf 3e 00				ld a,0 
3cb1 bd					cp l 
3cb2 28 04				jr z, .not2t 
3cb4 2e 00				ld l, 0 
3cb6 18 02				jr .notip 
3cb8			 
3cb8 2e ff		.not2t:		ld l, 255 
3cba			 
3cba 26 00		.notip:		ld h, 0	 
3cbc			 
3cbc cd 12 20				call forth_push_numhl 
3cbf					NEXTW 
3cbf cd a3 fd			call parse_vector 
3cc2 c3 f5 23			jp macro_next 
3cc5				endm 
# End of macro NEXTW
3cc5			 
3cc5			.IS: 
3cc5				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
3cc5 2d				db WORD_SYS_CORE+25             
3cc6 09 3d			dw .LZERO            
3cc8 08				db 7 + 1 
3cc9 .. 00			db "COMPARE",0              
3cd1				endm 
# End of macro CWHEAD
3cd1			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
3cd1					if DEBUG_FORTH_WORDS_KEY 
3cd1						DMARK "CMP" 
3cd1 f5				push af  
3cd2 3a e6 3c			ld a, (.dmark)  
3cd5 32 99 fd			ld (debug_mark),a  
3cd8 3a e7 3c			ld a, (.dmark+1)  
3cdb 32 9a fd			ld (debug_mark+1),a  
3cde 3a e8 3c			ld a, (.dmark+2)  
3ce1 32 9b fd			ld (debug_mark+2),a  
3ce4 18 03			jr .pastdmark  
3ce6 ..			.dmark: db "CMP"  
3ce9 f1			.pastdmark: pop af  
3cea			endm  
# End of macro DMARK
3cea						CALLMONITOR 
3cea cd a6 fd			call debug_vector  
3ced				endm  
# End of macro CALLMONITOR
3ced					endif 
3ced			 
3ced					FORTH_DSP_VALUEHL 
3ced cd 0e 22			call macro_dsp_valuehl 
3cf0				endm 
# End of macro FORTH_DSP_VALUEHL
3cf0			 
3cf0 e5					push hl 
3cf1			 
3cf1					FORTH_DSP_VALUEM1 
3cf1 cd 02 22			call macro_forth_dsp_value_m1 
3cf4				endm 
# End of macro FORTH_DSP_VALUEM1
3cf4			 
3cf4 d1					pop de 
3cf5			 
3cf5					; got pointers to both. Now check. 
3cf5			 
3cf5 cd 41 13				call strcmp 
3cf8				 
3cf8 26 00				ld h, 0 
3cfa 2e 00				ld l, 0 
3cfc 20 02				jr nz, .compnsame 
3cfe 2e 01				ld l, 1	 
3d00			.compnsame: 
3d00 cd 12 20				call forth_push_numhl 
3d03			 
3d03					NEXTW 
3d03 cd a3 fd			call parse_vector 
3d06 c3 f5 23			jp macro_next 
3d09				endm 
# End of macro NEXTW
3d09			.LZERO: 
3d09				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3d09 2d				db WORD_SYS_CORE+25             
3d0a 16 3d			dw .TZERO            
3d0c 03				db 2 + 1 
3d0d .. 00			db "0<",0              
3d10				endm 
# End of macro CWHEAD
3d10			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3d10					NEXTW 
3d10 cd a3 fd			call parse_vector 
3d13 c3 f5 23			jp macro_next 
3d16				endm 
# End of macro NEXTW
3d16			.TZERO: 
3d16				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3d16 2e				db WORD_SYS_CORE+26             
3d17 60 3d			dw .LESS            
3d19 03				db 2 + 1 
3d1a .. 00			db "0=",0              
3d1d				endm 
# End of macro CWHEAD
3d1d			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3d1d				; TODO add floating point number detection 
3d1d					;v5 FORTH_DSP_VALUE 
3d1d					if DEBUG_FORTH_WORDS_KEY 
3d1d						DMARK "0=." 
3d1d f5				push af  
3d1e 3a 32 3d			ld a, (.dmark)  
3d21 32 99 fd			ld (debug_mark),a  
3d24 3a 33 3d			ld a, (.dmark+1)  
3d27 32 9a fd			ld (debug_mark+1),a  
3d2a 3a 34 3d			ld a, (.dmark+2)  
3d2d 32 9b fd			ld (debug_mark+2),a  
3d30 18 03			jr .pastdmark  
3d32 ..			.dmark: db "0=."  
3d35 f1			.pastdmark: pop af  
3d36			endm  
# End of macro DMARK
3d36						CALLMONITOR 
3d36 cd a6 fd			call debug_vector  
3d39				endm  
# End of macro CALLMONITOR
3d39					endif 
3d39					FORTH_DSP 
3d39 cd d4 21			call macro_forth_dsp 
3d3c				endm 
# End of macro FORTH_DSP
3d3c 7e					ld a,(hl)	; get type of value on TOS 
3d3d fe 02				cp DS_TYPE_INUM  
3d3f 28 00				jr z, .tz_inum 
3d41			 
3d41				if FORTH_ENABLE_FLOATMATH 
3d41					jr .tz_done 
3d41			 
3d41				endif 
3d41					 
3d41			 
3d41			.tz_inum: 
3d41					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d41 cd 0e 22			call macro_dsp_valuehl 
3d44				endm 
# End of macro FORTH_DSP_VALUEHL
3d44			 
3d44			;		push hl 
3d44			 
3d44					; destroy value TOS 
3d44			 
3d44					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d44 cd c6 22			call macro_forth_dsp_pop 
3d47				endm 
# End of macro FORTH_DSP_POP
3d47			 
3d47			;		pop hl 
3d47			 
3d47 3e 00				ld a,0 
3d49			 
3d49 bd					cp l 
3d4a 20 08				jr nz, .tz_notzero 
3d4c			 
3d4c bc					cp h 
3d4d			 
3d4d 20 05				jr nz, .tz_notzero 
3d4f			 
3d4f			 
3d4f 21 01 00				ld hl, FORTH_TRUE 
3d52 18 03				jr .tz_done 
3d54			 
3d54 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3d57			 
3d57					; push value back onto stack for another op etc 
3d57			 
3d57			.tz_done: 
3d57 cd 12 20				call forth_push_numhl 
3d5a			 
3d5a					NEXTW 
3d5a cd a3 fd			call parse_vector 
3d5d c3 f5 23			jp macro_next 
3d60				endm 
# End of macro NEXTW
3d60			.LESS: 
3d60				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3d60 2f				db WORD_SYS_CORE+27             
3d61 cc 3d			dw .GT            
3d63 02				db 1 + 1 
3d64 .. 00			db "<",0              
3d66				endm 
# End of macro CWHEAD
3d66			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3d66				; TODO add floating point number detection 
3d66					if DEBUG_FORTH_WORDS_KEY 
3d66						DMARK "LES" 
3d66 f5				push af  
3d67 3a 7b 3d			ld a, (.dmark)  
3d6a 32 99 fd			ld (debug_mark),a  
3d6d 3a 7c 3d			ld a, (.dmark+1)  
3d70 32 9a fd			ld (debug_mark+1),a  
3d73 3a 7d 3d			ld a, (.dmark+2)  
3d76 32 9b fd			ld (debug_mark+2),a  
3d79 18 03			jr .pastdmark  
3d7b ..			.dmark: db "LES"  
3d7e f1			.pastdmark: pop af  
3d7f			endm  
# End of macro DMARK
3d7f						CALLMONITOR 
3d7f cd a6 fd			call debug_vector  
3d82				endm  
# End of macro CALLMONITOR
3d82					endif 
3d82					FORTH_DSP 
3d82 cd d4 21			call macro_forth_dsp 
3d85				endm 
# End of macro FORTH_DSP
3d85					;v5 FORTH_DSP_VALUE 
3d85 7e					ld a,(hl)	; get type of value on TOS 
3d86 fe 02				cp DS_TYPE_INUM  
3d88 28 00				jr z, .less_inum 
3d8a			 
3d8a				if FORTH_ENABLE_FLOATMATH 
3d8a					jr .less_done 
3d8a			 
3d8a				endif 
3d8a					 
3d8a			 
3d8a			.less_inum: 
3d8a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d8a cd 0e 22			call macro_dsp_valuehl 
3d8d				endm 
# End of macro FORTH_DSP_VALUEHL
3d8d			 
3d8d e5					push hl  ; u2 
3d8e			 
3d8e					; destroy value TOS 
3d8e			 
3d8e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d8e cd c6 22			call macro_forth_dsp_pop 
3d91				endm 
# End of macro FORTH_DSP_POP
3d91			 
3d91			 
3d91					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d91 cd 0e 22			call macro_dsp_valuehl 
3d94				endm 
# End of macro FORTH_DSP_VALUEHL
3d94			 
3d94 e5					push hl    ; u1 
3d95			 
3d95					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d95 cd c6 22			call macro_forth_dsp_pop 
3d98				endm 
# End of macro FORTH_DSP_POP
3d98			 
3d98			 
3d98 b7			 or a      ;clear carry flag 
3d99 01 00 00		 ld bc, FORTH_FALSE 
3d9c e1			  pop hl    ; u1 
3d9d d1			  pop de    ; u2 
3d9e ed 52		  sbc hl,de 
3da0 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3da2			 
3da2 01 01 00		 ld bc, FORTH_TRUE 
3da5			.lscont:  
3da5 c5					push bc 
3da6 e1					pop hl 
3da7			 
3da7					if DEBUG_FORTH_WORDS 
3da7						DMARK "LT1" 
3da7 f5				push af  
3da8 3a bc 3d			ld a, (.dmark)  
3dab 32 99 fd			ld (debug_mark),a  
3dae 3a bd 3d			ld a, (.dmark+1)  
3db1 32 9a fd			ld (debug_mark+1),a  
3db4 3a be 3d			ld a, (.dmark+2)  
3db7 32 9b fd			ld (debug_mark+2),a  
3dba 18 03			jr .pastdmark  
3dbc ..			.dmark: db "LT1"  
3dbf f1			.pastdmark: pop af  
3dc0			endm  
# End of macro DMARK
3dc0						CALLMONITOR 
3dc0 cd a6 fd			call debug_vector  
3dc3				endm  
# End of macro CALLMONITOR
3dc3					endif 
3dc3 cd 12 20				call forth_push_numhl 
3dc6			 
3dc6					NEXTW 
3dc6 cd a3 fd			call parse_vector 
3dc9 c3 f5 23			jp macro_next 
3dcc				endm 
# End of macro NEXTW
3dcc			.GT: 
3dcc				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3dcc 30				db WORD_SYS_CORE+28             
3dcd 38 3e			dw .EQUAL            
3dcf 02				db 1 + 1 
3dd0 .. 00			db ">",0              
3dd2				endm 
# End of macro CWHEAD
3dd2			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3dd2				; TODO add floating point number detection 
3dd2					if DEBUG_FORTH_WORDS_KEY 
3dd2						DMARK "GRT" 
3dd2 f5				push af  
3dd3 3a e7 3d			ld a, (.dmark)  
3dd6 32 99 fd			ld (debug_mark),a  
3dd9 3a e8 3d			ld a, (.dmark+1)  
3ddc 32 9a fd			ld (debug_mark+1),a  
3ddf 3a e9 3d			ld a, (.dmark+2)  
3de2 32 9b fd			ld (debug_mark+2),a  
3de5 18 03			jr .pastdmark  
3de7 ..			.dmark: db "GRT"  
3dea f1			.pastdmark: pop af  
3deb			endm  
# End of macro DMARK
3deb						CALLMONITOR 
3deb cd a6 fd			call debug_vector  
3dee				endm  
# End of macro CALLMONITOR
3dee					endif 
3dee					FORTH_DSP 
3dee cd d4 21			call macro_forth_dsp 
3df1				endm 
# End of macro FORTH_DSP
3df1					;FORTH_DSP_VALUE 
3df1 7e					ld a,(hl)	; get type of value on TOS 
3df2 fe 02				cp DS_TYPE_INUM  
3df4 28 00				jr z, .gt_inum 
3df6			 
3df6				if FORTH_ENABLE_FLOATMATH 
3df6					jr .gt_done 
3df6			 
3df6				endif 
3df6					 
3df6			 
3df6			.gt_inum: 
3df6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3df6 cd 0e 22			call macro_dsp_valuehl 
3df9				endm 
# End of macro FORTH_DSP_VALUEHL
3df9			 
3df9 e5					push hl  ; u2 
3dfa			 
3dfa					; destroy value TOS 
3dfa			 
3dfa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dfa cd c6 22			call macro_forth_dsp_pop 
3dfd				endm 
# End of macro FORTH_DSP_POP
3dfd			 
3dfd			 
3dfd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dfd cd 0e 22			call macro_dsp_valuehl 
3e00				endm 
# End of macro FORTH_DSP_VALUEHL
3e00			 
3e00 e5					push hl    ; u1 
3e01			 
3e01					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e01 cd c6 22			call macro_forth_dsp_pop 
3e04				endm 
# End of macro FORTH_DSP_POP
3e04			 
3e04			 
3e04 b7			 or a      ;clear carry flag 
3e05 01 00 00		 ld bc, FORTH_FALSE 
3e08 e1			  pop hl    ; u1 
3e09 d1			  pop de    ; u2 
3e0a ed 52		  sbc hl,de 
3e0c 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3e0e			 
3e0e 01 01 00		 ld bc, FORTH_TRUE 
3e11			.gtcont:  
3e11 c5					push bc 
3e12 e1					pop hl 
3e13			 
3e13					if DEBUG_FORTH_WORDS 
3e13						DMARK "GT1" 
3e13 f5				push af  
3e14 3a 28 3e			ld a, (.dmark)  
3e17 32 99 fd			ld (debug_mark),a  
3e1a 3a 29 3e			ld a, (.dmark+1)  
3e1d 32 9a fd			ld (debug_mark+1),a  
3e20 3a 2a 3e			ld a, (.dmark+2)  
3e23 32 9b fd			ld (debug_mark+2),a  
3e26 18 03			jr .pastdmark  
3e28 ..			.dmark: db "GT1"  
3e2b f1			.pastdmark: pop af  
3e2c			endm  
# End of macro DMARK
3e2c						CALLMONITOR 
3e2c cd a6 fd			call debug_vector  
3e2f				endm  
# End of macro CALLMONITOR
3e2f					endif 
3e2f cd 12 20				call forth_push_numhl 
3e32			 
3e32					NEXTW 
3e32 cd a3 fd			call parse_vector 
3e35 c3 f5 23			jp macro_next 
3e38				endm 
# End of macro NEXTW
3e38			.EQUAL: 
3e38				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3e38 31				db WORD_SYS_CORE+29             
3e39 a6 3e			dw .ENDLOGIC            
3e3b 02				db 1 + 1 
3e3c .. 00			db "=",0              
3e3e				endm 
# End of macro CWHEAD
3e3e			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3e3e				; TODO add floating point number detection 
3e3e					if DEBUG_FORTH_WORDS_KEY 
3e3e						DMARK "EQ." 
3e3e f5				push af  
3e3f 3a 53 3e			ld a, (.dmark)  
3e42 32 99 fd			ld (debug_mark),a  
3e45 3a 54 3e			ld a, (.dmark+1)  
3e48 32 9a fd			ld (debug_mark+1),a  
3e4b 3a 55 3e			ld a, (.dmark+2)  
3e4e 32 9b fd			ld (debug_mark+2),a  
3e51 18 03			jr .pastdmark  
3e53 ..			.dmark: db "EQ."  
3e56 f1			.pastdmark: pop af  
3e57			endm  
# End of macro DMARK
3e57						CALLMONITOR 
3e57 cd a6 fd			call debug_vector  
3e5a				endm  
# End of macro CALLMONITOR
3e5a					endif 
3e5a					FORTH_DSP 
3e5a cd d4 21			call macro_forth_dsp 
3e5d				endm 
# End of macro FORTH_DSP
3e5d					;v5 FORTH_DSP_VALUE 
3e5d 7e					ld a,(hl)	; get type of value on TOS 
3e5e fe 02				cp DS_TYPE_INUM  
3e60 28 00				jr z, .eq_inum 
3e62			 
3e62				if FORTH_ENABLE_FLOATMATH 
3e62					jr .eq_done 
3e62			 
3e62				endif 
3e62					 
3e62			 
3e62			.eq_inum: 
3e62					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e62 cd 0e 22			call macro_dsp_valuehl 
3e65				endm 
# End of macro FORTH_DSP_VALUEHL
3e65			 
3e65 e5					push hl 
3e66			 
3e66					; destroy value TOS 
3e66			 
3e66					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e66 cd c6 22			call macro_forth_dsp_pop 
3e69				endm 
# End of macro FORTH_DSP_POP
3e69			 
3e69			 
3e69					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e69 cd 0e 22			call macro_dsp_valuehl 
3e6c				endm 
# End of macro FORTH_DSP_VALUEHL
3e6c			 
3e6c					; one value on hl get other one back 
3e6c			 
3e6c e5					push hl 
3e6d			 
3e6d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e6d cd c6 22			call macro_forth_dsp_pop 
3e70				endm 
# End of macro FORTH_DSP_POP
3e70			 
3e70 0e 00				ld c, FORTH_FALSE 
3e72			 
3e72 e1					pop hl 
3e73 d1					pop de 
3e74			 
3e74 7b					ld a, e 
3e75 bd					cp l 
3e76			 
3e76 20 06				jr nz, .eq_done 
3e78			 
3e78 7a					ld a, d 
3e79 bc					cp h 
3e7a			 
3e7a 20 02				jr nz, .eq_done 
3e7c			 
3e7c 0e 01				ld c, FORTH_TRUE 
3e7e					 
3e7e			 
3e7e			 
3e7e			.eq_done: 
3e7e			 
3e7e					; TODO push value back onto stack for another op etc 
3e7e			 
3e7e 26 00				ld h, 0 
3e80 69					ld l, c 
3e81					if DEBUG_FORTH_WORDS 
3e81						DMARK "EQ1" 
3e81 f5				push af  
3e82 3a 96 3e			ld a, (.dmark)  
3e85 32 99 fd			ld (debug_mark),a  
3e88 3a 97 3e			ld a, (.dmark+1)  
3e8b 32 9a fd			ld (debug_mark+1),a  
3e8e 3a 98 3e			ld a, (.dmark+2)  
3e91 32 9b fd			ld (debug_mark+2),a  
3e94 18 03			jr .pastdmark  
3e96 ..			.dmark: db "EQ1"  
3e99 f1			.pastdmark: pop af  
3e9a			endm  
# End of macro DMARK
3e9a						CALLMONITOR 
3e9a cd a6 fd			call debug_vector  
3e9d				endm  
# End of macro CALLMONITOR
3e9d					endif 
3e9d cd 12 20				call forth_push_numhl 
3ea0			 
3ea0					NEXTW 
3ea0 cd a3 fd			call parse_vector 
3ea3 c3 f5 23			jp macro_next 
3ea6				endm 
# End of macro NEXTW
3ea6			 
3ea6			 
3ea6			.ENDLOGIC: 
3ea6			; eof 
3ea6			 
3ea6			 
# End of file forth_words_logic.asm
3ea6			include "forth_words_maths.asm" 
3ea6			 
3ea6			; | ## Maths Words 
3ea6			 
3ea6			.PLUS:	 
3ea6				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3ea6 15				db WORD_SYS_CORE+1             
3ea7 0a 3f			dw .NEG            
3ea9 02				db 1 + 1 
3eaa .. 00			db "+",0              
3eac				endm 
# End of macro CWHEAD
3eac			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3eac					if DEBUG_FORTH_WORDS_KEY 
3eac						DMARK "PLU" 
3eac f5				push af  
3ead 3a c1 3e			ld a, (.dmark)  
3eb0 32 99 fd			ld (debug_mark),a  
3eb3 3a c2 3e			ld a, (.dmark+1)  
3eb6 32 9a fd			ld (debug_mark+1),a  
3eb9 3a c3 3e			ld a, (.dmark+2)  
3ebc 32 9b fd			ld (debug_mark+2),a  
3ebf 18 03			jr .pastdmark  
3ec1 ..			.dmark: db "PLU"  
3ec4 f1			.pastdmark: pop af  
3ec5			endm  
# End of macro DMARK
3ec5						CALLMONITOR 
3ec5 cd a6 fd			call debug_vector  
3ec8				endm  
# End of macro CALLMONITOR
3ec8					endif 
3ec8					; add top two values and push back result 
3ec8			 
3ec8					;for v5 FORTH_DSP_VALUE 
3ec8					FORTH_DSP 
3ec8 cd d4 21			call macro_forth_dsp 
3ecb				endm 
# End of macro FORTH_DSP
3ecb 7e					ld a,(hl)	; get type of value on TOS 
3ecc fe 02				cp DS_TYPE_INUM  
3ece 28 06				jr z, .dot_inum 
3ed0			 
3ed0					NEXTW 
3ed0 cd a3 fd			call parse_vector 
3ed3 c3 f5 23			jp macro_next 
3ed6				endm 
# End of macro NEXTW
3ed6			 
3ed6			; float maths 
3ed6			 
3ed6				if FORTH_ENABLE_FLOATMATH 
3ed6						inc hl      ; now at start of numeric as string 
3ed6			 
3ed6					if DEBUG_FORTH_MATHS 
3ed6						DMARK "ADD" 
3ed6				CALLMONITOR 
3ed6					endif 
3ed6			 
3ed6					;ld ix, hl 
3ed6					call CON 
3ed6			 
3ed6			 
3ed6					push hl 
3ed6					 
3ed6					 
3ed6			 
3ed6						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3ed6			 
3ed6					; get next number 
3ed6			 
3ed6						FORTH_DSP_VALUE 
3ed6			 
3ed6						inc hl      ; now at start of numeric as string 
3ed6			 
3ed6					;ld ix, hl 
3ed6					call CON 
3ed6			 
3ed6					push hl 
3ed6			 
3ed6			 
3ed6						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ed6			 
3ed6						; TODO do add 
3ed6			 
3ed6						call IADD 
3ed6			 
3ed6						; TODO get result back as ascii 
3ed6			 
3ed6						; TODO push result  
3ed6			 
3ed6			 
3ed6			 
3ed6						jr .dot_done 
3ed6				endif 
3ed6			 
3ed6			.dot_inum: 
3ed6			 
3ed6			 
3ed6					if DEBUG_FORTH_DOT 
3ed6						DMARK "+IT" 
3ed6 f5				push af  
3ed7 3a eb 3e			ld a, (.dmark)  
3eda 32 99 fd			ld (debug_mark),a  
3edd 3a ec 3e			ld a, (.dmark+1)  
3ee0 32 9a fd			ld (debug_mark+1),a  
3ee3 3a ed 3e			ld a, (.dmark+2)  
3ee6 32 9b fd			ld (debug_mark+2),a  
3ee9 18 03			jr .pastdmark  
3eeb ..			.dmark: db "+IT"  
3eee f1			.pastdmark: pop af  
3eef			endm  
# End of macro DMARK
3eef				CALLMONITOR 
3eef cd a6 fd			call debug_vector  
3ef2				endm  
# End of macro CALLMONITOR
3ef2					endif 
3ef2			 
3ef2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ef2 cd 0e 22			call macro_dsp_valuehl 
3ef5				endm 
# End of macro FORTH_DSP_VALUEHL
3ef5			 
3ef5				; TODO add floating point number detection 
3ef5			 
3ef5 e5					push hl 
3ef6			 
3ef6					; destroy value TOS 
3ef6			 
3ef6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ef6 cd c6 22			call macro_forth_dsp_pop 
3ef9				endm 
# End of macro FORTH_DSP_POP
3ef9			 
3ef9			 
3ef9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ef9 cd 0e 22			call macro_dsp_valuehl 
3efc				endm 
# End of macro FORTH_DSP_VALUEHL
3efc			 
3efc					; one value on hl get other one back 
3efc			 
3efc d1					pop de 
3efd			 
3efd					; do the add 
3efd			 
3efd 19					add hl,de 
3efe			 
3efe					; save it 
3efe			 
3efe			;		push hl	 
3efe			 
3efe					; 
3efe			 
3efe					; destroy value TOS 
3efe			 
3efe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3efe cd c6 22			call macro_forth_dsp_pop 
3f01				endm 
# End of macro FORTH_DSP_POP
3f01			 
3f01					; TODO push value back onto stack for another op etc 
3f01			 
3f01			;		pop hl 
3f01			 
3f01			.dot_done: 
3f01 cd 12 20				call forth_push_numhl 
3f04			 
3f04					NEXTW 
3f04 cd a3 fd			call parse_vector 
3f07 c3 f5 23			jp macro_next 
3f0a				endm 
# End of macro NEXTW
3f0a			.NEG: 
3f0a			 
3f0a				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3f0a 17				db WORD_SYS_CORE+3             
3f0b 53 3f			dw .DIV            
3f0d 02				db 1 + 1 
3f0e .. 00			db "-",0              
3f10				endm 
# End of macro CWHEAD
3f10			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3f10					if DEBUG_FORTH_WORDS_KEY 
3f10						DMARK "SUB" 
3f10 f5				push af  
3f11 3a 25 3f			ld a, (.dmark)  
3f14 32 99 fd			ld (debug_mark),a  
3f17 3a 26 3f			ld a, (.dmark+1)  
3f1a 32 9a fd			ld (debug_mark+1),a  
3f1d 3a 27 3f			ld a, (.dmark+2)  
3f20 32 9b fd			ld (debug_mark+2),a  
3f23 18 03			jr .pastdmark  
3f25 ..			.dmark: db "SUB"  
3f28 f1			.pastdmark: pop af  
3f29			endm  
# End of macro DMARK
3f29						CALLMONITOR 
3f29 cd a6 fd			call debug_vector  
3f2c				endm  
# End of macro CALLMONITOR
3f2c					endif 
3f2c			 
3f2c			 
3f2c				; TODO add floating point number detection 
3f2c					; v5 FORTH_DSP_VALUE 
3f2c					FORTH_DSP 
3f2c cd d4 21			call macro_forth_dsp 
3f2f				endm 
# End of macro FORTH_DSP
3f2f 7e					ld a,(hl)	; get type of value on TOS 
3f30 fe 02				cp DS_TYPE_INUM  
3f32 28 06				jr z, .neg_inum 
3f34			 
3f34					NEXTW 
3f34 cd a3 fd			call parse_vector 
3f37 c3 f5 23			jp macro_next 
3f3a				endm 
# End of macro NEXTW
3f3a			 
3f3a			; float maths 
3f3a			 
3f3a				if FORTH_ENABLE_FLOATMATH 
3f3a					jr .neg_done 
3f3a			 
3f3a				endif 
3f3a					 
3f3a			 
3f3a			.neg_inum: 
3f3a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f3a cd 0e 22			call macro_dsp_valuehl 
3f3d				endm 
# End of macro FORTH_DSP_VALUEHL
3f3d			 
3f3d e5					push hl 
3f3e			 
3f3e					; destroy value TOS 
3f3e			 
3f3e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f3e cd c6 22			call macro_forth_dsp_pop 
3f41				endm 
# End of macro FORTH_DSP_POP
3f41			 
3f41			 
3f41					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f41 cd 0e 22			call macro_dsp_valuehl 
3f44				endm 
# End of macro FORTH_DSP_VALUEHL
3f44			 
3f44					; one value on hl get other one back 
3f44			 
3f44 d1					pop de 
3f45			 
3f45					; do the sub 
3f45			;		ex de, hl 
3f45			 
3f45 ed 52				sbc hl,de 
3f47			 
3f47					; save it 
3f47			 
3f47			;		push hl	 
3f47			 
3f47					; 
3f47			 
3f47					; destroy value TOS 
3f47			 
3f47					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f47 cd c6 22			call macro_forth_dsp_pop 
3f4a				endm 
# End of macro FORTH_DSP_POP
3f4a			 
3f4a					; TODO push value back onto stack for another op etc 
3f4a			 
3f4a			;		pop hl 
3f4a			 
3f4a cd 12 20				call forth_push_numhl 
3f4d			.neg_done: 
3f4d			 
3f4d					NEXTW 
3f4d cd a3 fd			call parse_vector 
3f50 c3 f5 23			jp macro_next 
3f53				endm 
# End of macro NEXTW
3f53			.DIV: 
3f53				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3f53 18				db WORD_SYS_CORE+4             
3f54 a6 3f			dw .MUL            
3f56 02				db 1 + 1 
3f57 .. 00			db "/",0              
3f59				endm 
# End of macro CWHEAD
3f59			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3f59					if DEBUG_FORTH_WORDS_KEY 
3f59						DMARK "DIV" 
3f59 f5				push af  
3f5a 3a 6e 3f			ld a, (.dmark)  
3f5d 32 99 fd			ld (debug_mark),a  
3f60 3a 6f 3f			ld a, (.dmark+1)  
3f63 32 9a fd			ld (debug_mark+1),a  
3f66 3a 70 3f			ld a, (.dmark+2)  
3f69 32 9b fd			ld (debug_mark+2),a  
3f6c 18 03			jr .pastdmark  
3f6e ..			.dmark: db "DIV"  
3f71 f1			.pastdmark: pop af  
3f72			endm  
# End of macro DMARK
3f72						CALLMONITOR 
3f72 cd a6 fd			call debug_vector  
3f75				endm  
# End of macro CALLMONITOR
3f75					endif 
3f75				; TODO add floating point number detection 
3f75					; v5 FORTH_DSP_VALUE 
3f75					FORTH_DSP 
3f75 cd d4 21			call macro_forth_dsp 
3f78				endm 
# End of macro FORTH_DSP
3f78 7e					ld a,(hl)	; get type of value on TOS 
3f79 fe 02				cp DS_TYPE_INUM  
3f7b 28 06				jr z, .div_inum 
3f7d			 
3f7d				if FORTH_ENABLE_FLOATMATH 
3f7d					jr .div_done 
3f7d			 
3f7d				endif 
3f7d					NEXTW 
3f7d cd a3 fd			call parse_vector 
3f80 c3 f5 23			jp macro_next 
3f83				endm 
# End of macro NEXTW
3f83			.div_inum: 
3f83			 
3f83					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f83 cd 0e 22			call macro_dsp_valuehl 
3f86				endm 
# End of macro FORTH_DSP_VALUEHL
3f86			 
3f86 e5					push hl    ; to go to bc 
3f87			 
3f87					; destroy value TOS 
3f87			 
3f87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f87 cd c6 22			call macro_forth_dsp_pop 
3f8a				endm 
# End of macro FORTH_DSP_POP
3f8a			 
3f8a			 
3f8a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f8a cd 0e 22			call macro_dsp_valuehl 
3f8d				endm 
# End of macro FORTH_DSP_VALUEHL
3f8d			 
3f8d					; hl to go to de 
3f8d			 
3f8d e5					push hl 
3f8e			 
3f8e c1					pop bc 
3f8f d1					pop de		 
3f90			 
3f90			 
3f90					if DEBUG_FORTH_MATHS 
3f90						DMARK "DIV" 
3f90				CALLMONITOR 
3f90					endif 
3f90					; one value on hl but move to a get other one back 
3f90			 
3f90			        
3f90 cd 0e 0f			call Div16 
3f93			 
3f93			;	push af	 
3f93 e5				push hl 
3f94 c5				push bc 
3f95			 
3f95					if DEBUG_FORTH_MATHS 
3f95						DMARK "DI1" 
3f95				CALLMONITOR 
3f95					endif 
3f95			 
3f95					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f95 cd c6 22			call macro_forth_dsp_pop 
3f98				endm 
# End of macro FORTH_DSP_POP
3f98			 
3f98			 
3f98			 
3f98 e1					pop hl    ; result 
3f99			 
3f99 cd 12 20				call forth_push_numhl 
3f9c			 
3f9c e1					pop hl    ; reminder 
3f9d			;		ld h,0 
3f9d			;		ld l,d 
3f9d			 
3f9d cd 12 20				call forth_push_numhl 
3fa0			.div_done: 
3fa0					NEXTW 
3fa0 cd a3 fd			call parse_vector 
3fa3 c3 f5 23			jp macro_next 
3fa6				endm 
# End of macro NEXTW
3fa6			.MUL: 
3fa6				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3fa6 19				db WORD_SYS_CORE+5             
3fa7 f1 3f			dw .MIN            
3fa9 02				db 1 + 1 
3faa .. 00			db "*",0              
3fac				endm 
# End of macro CWHEAD
3fac			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3fac				; TODO add floating point number detection 
3fac					if DEBUG_FORTH_WORDS_KEY 
3fac						DMARK "MUL" 
3fac f5				push af  
3fad 3a c1 3f			ld a, (.dmark)  
3fb0 32 99 fd			ld (debug_mark),a  
3fb3 3a c2 3f			ld a, (.dmark+1)  
3fb6 32 9a fd			ld (debug_mark+1),a  
3fb9 3a c3 3f			ld a, (.dmark+2)  
3fbc 32 9b fd			ld (debug_mark+2),a  
3fbf 18 03			jr .pastdmark  
3fc1 ..			.dmark: db "MUL"  
3fc4 f1			.pastdmark: pop af  
3fc5			endm  
# End of macro DMARK
3fc5						CALLMONITOR 
3fc5 cd a6 fd			call debug_vector  
3fc8				endm  
# End of macro CALLMONITOR
3fc8					endif 
3fc8					FORTH_DSP 
3fc8 cd d4 21			call macro_forth_dsp 
3fcb				endm 
# End of macro FORTH_DSP
3fcb					; v5 FORTH_DSP_VALUE 
3fcb 7e					ld a,(hl)	; get type of value on TOS 
3fcc fe 02				cp DS_TYPE_INUM  
3fce 28 06				jr z, .mul_inum 
3fd0			 
3fd0				if FORTH_ENABLE_FLOATMATH 
3fd0					jr .mul_done 
3fd0			 
3fd0				endif 
3fd0			 
3fd0					NEXTW 
3fd0 cd a3 fd			call parse_vector 
3fd3 c3 f5 23			jp macro_next 
3fd6				endm 
# End of macro NEXTW
3fd6			.mul_inum:	 
3fd6			 
3fd6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fd6 cd 0e 22			call macro_dsp_valuehl 
3fd9				endm 
# End of macro FORTH_DSP_VALUEHL
3fd9			 
3fd9 e5					push hl 
3fda			 
3fda					; destroy value TOS 
3fda			 
3fda					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fda cd c6 22			call macro_forth_dsp_pop 
3fdd				endm 
# End of macro FORTH_DSP_POP
3fdd			 
3fdd			 
3fdd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fdd cd 0e 22			call macro_dsp_valuehl 
3fe0				endm 
# End of macro FORTH_DSP_VALUEHL
3fe0			 
3fe0					; one value on hl but move to a get other one back 
3fe0			 
3fe0 7d					ld a, l 
3fe1			 
3fe1 d1					pop de 
3fe2			 
3fe2					; do the mull 
3fe2			;		ex de, hl 
3fe2			 
3fe2 cd 34 0f				call Mult16 
3fe5					; save it 
3fe5			 
3fe5			;		push hl	 
3fe5			 
3fe5					; 
3fe5			 
3fe5					; destroy value TOS 
3fe5			 
3fe5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fe5 cd c6 22			call macro_forth_dsp_pop 
3fe8				endm 
# End of macro FORTH_DSP_POP
3fe8			 
3fe8					; TODO push value back onto stack for another op etc 
3fe8			 
3fe8			;		pop hl 
3fe8			 
3fe8 cd 12 20				call forth_push_numhl 
3feb			 
3feb			.mul_done: 
3feb					NEXTW 
3feb cd a3 fd			call parse_vector 
3fee c3 f5 23			jp macro_next 
3ff1				endm 
# End of macro NEXTW
3ff1			 
3ff1			 
3ff1			 
3ff1			 
3ff1			.MIN: 
3ff1				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3ff1 49				db WORD_SYS_CORE+53             
3ff2 78 40			dw .MAX            
3ff4 04				db 3 + 1 
3ff5 .. 00			db "MIN",0              
3ff9				endm 
# End of macro CWHEAD
3ff9			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3ff9					if DEBUG_FORTH_WORDS_KEY 
3ff9						DMARK "MIN" 
3ff9 f5				push af  
3ffa 3a 0e 40			ld a, (.dmark)  
3ffd 32 99 fd			ld (debug_mark),a  
4000 3a 0f 40			ld a, (.dmark+1)  
4003 32 9a fd			ld (debug_mark+1),a  
4006 3a 10 40			ld a, (.dmark+2)  
4009 32 9b fd			ld (debug_mark+2),a  
400c 18 03			jr .pastdmark  
400e ..			.dmark: db "MIN"  
4011 f1			.pastdmark: pop af  
4012			endm  
# End of macro DMARK
4012						CALLMONITOR 
4012 cd a6 fd			call debug_vector  
4015				endm  
# End of macro CALLMONITOR
4015					endif 
4015					; get u2 
4015			 
4015					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4015 cd 0e 22			call macro_dsp_valuehl 
4018				endm 
# End of macro FORTH_DSP_VALUEHL
4018			 
4018 e5					push hl   ; u2 
4019			 
4019					; destroy value TOS 
4019			 
4019					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4019 cd c6 22			call macro_forth_dsp_pop 
401c				endm 
# End of macro FORTH_DSP_POP
401c			 
401c					; get u1 
401c			 
401c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
401c cd 0e 22			call macro_dsp_valuehl 
401f				endm 
# End of macro FORTH_DSP_VALUEHL
401f			 
401f e5					push hl  ; u1 
4020			 
4020					; destroy value TOS 
4020			 
4020					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4020 cd c6 22			call macro_forth_dsp_pop 
4023				endm 
# End of macro FORTH_DSP_POP
4023			 
4023 b7			 or a      ;clear carry flag 
4024 e1			  pop hl    ; u1 
4025 d1			  pop de    ; u2 
4026 e5				push hl   ; saved in case hl is lowest 
4027 ed 52		  sbc hl,de 
4029 30 26		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
402b			 
402b e1				pop hl 
402c					if DEBUG_FORTH_WORDS 
402c						DMARK "MIN" 
402c f5				push af  
402d 3a 41 40			ld a, (.dmark)  
4030 32 99 fd			ld (debug_mark),a  
4033 3a 42 40			ld a, (.dmark+1)  
4036 32 9a fd			ld (debug_mark+1),a  
4039 3a 43 40			ld a, (.dmark+2)  
403c 32 9b fd			ld (debug_mark+2),a  
403f 18 03			jr .pastdmark  
4041 ..			.dmark: db "MIN"  
4044 f1			.pastdmark: pop af  
4045			endm  
# End of macro DMARK
4045						CALLMONITOR 
4045 cd a6 fd			call debug_vector  
4048				endm  
# End of macro CALLMONITOR
4048					endif 
4048 cd 12 20				call forth_push_numhl 
404b			 
404b				       NEXTW 
404b cd a3 fd			call parse_vector 
404e c3 f5 23			jp macro_next 
4051				endm 
# End of macro NEXTW
4051			 
4051			.mincont:  
4051 c1				pop bc   ; tidy up 
4052 eb				ex de , hl  
4053					if DEBUG_FORTH_WORDS 
4053						DMARK "MI1" 
4053 f5				push af  
4054 3a 68 40			ld a, (.dmark)  
4057 32 99 fd			ld (debug_mark),a  
405a 3a 69 40			ld a, (.dmark+1)  
405d 32 9a fd			ld (debug_mark+1),a  
4060 3a 6a 40			ld a, (.dmark+2)  
4063 32 9b fd			ld (debug_mark+2),a  
4066 18 03			jr .pastdmark  
4068 ..			.dmark: db "MI1"  
406b f1			.pastdmark: pop af  
406c			endm  
# End of macro DMARK
406c						CALLMONITOR 
406c cd a6 fd			call debug_vector  
406f				endm  
# End of macro CALLMONITOR
406f					endif 
406f cd 12 20				call forth_push_numhl 
4072			 
4072				       NEXTW 
4072 cd a3 fd			call parse_vector 
4075 c3 f5 23			jp macro_next 
4078				endm 
# End of macro NEXTW
4078			.MAX: 
4078				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
4078 4a				db WORD_SYS_CORE+54             
4079 ff 40			dw .RND16            
407b 04				db 3 + 1 
407c .. 00			db "MAX",0              
4080				endm 
# End of macro CWHEAD
4080			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
4080					if DEBUG_FORTH_WORDS_KEY 
4080						DMARK "MAX" 
4080 f5				push af  
4081 3a 95 40			ld a, (.dmark)  
4084 32 99 fd			ld (debug_mark),a  
4087 3a 96 40			ld a, (.dmark+1)  
408a 32 9a fd			ld (debug_mark+1),a  
408d 3a 97 40			ld a, (.dmark+2)  
4090 32 9b fd			ld (debug_mark+2),a  
4093 18 03			jr .pastdmark  
4095 ..			.dmark: db "MAX"  
4098 f1			.pastdmark: pop af  
4099			endm  
# End of macro DMARK
4099						CALLMONITOR 
4099 cd a6 fd			call debug_vector  
409c				endm  
# End of macro CALLMONITOR
409c					endif 
409c					; get u2 
409c			 
409c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
409c cd 0e 22			call macro_dsp_valuehl 
409f				endm 
# End of macro FORTH_DSP_VALUEHL
409f			 
409f e5					push hl   ; u2 
40a0			 
40a0					; destroy value TOS 
40a0			 
40a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40a0 cd c6 22			call macro_forth_dsp_pop 
40a3				endm 
# End of macro FORTH_DSP_POP
40a3			 
40a3					; get u1 
40a3			 
40a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40a3 cd 0e 22			call macro_dsp_valuehl 
40a6				endm 
# End of macro FORTH_DSP_VALUEHL
40a6			 
40a6 e5					push hl  ; u1 
40a7			 
40a7					; destroy value TOS 
40a7			 
40a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40a7 cd c6 22			call macro_forth_dsp_pop 
40aa				endm 
# End of macro FORTH_DSP_POP
40aa			 
40aa b7			 or a      ;clear carry flag 
40ab e1			  pop hl    ; u1 
40ac d1			  pop de    ; u2 
40ad e5				push hl   ; saved in case hl is lowest 
40ae ed 52		  sbc hl,de 
40b0 38 26		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
40b2			 
40b2 e1				pop hl 
40b3					if DEBUG_FORTH_WORDS 
40b3						DMARK "MAX" 
40b3 f5				push af  
40b4 3a c8 40			ld a, (.dmark)  
40b7 32 99 fd			ld (debug_mark),a  
40ba 3a c9 40			ld a, (.dmark+1)  
40bd 32 9a fd			ld (debug_mark+1),a  
40c0 3a ca 40			ld a, (.dmark+2)  
40c3 32 9b fd			ld (debug_mark+2),a  
40c6 18 03			jr .pastdmark  
40c8 ..			.dmark: db "MAX"  
40cb f1			.pastdmark: pop af  
40cc			endm  
# End of macro DMARK
40cc						CALLMONITOR 
40cc cd a6 fd			call debug_vector  
40cf				endm  
# End of macro CALLMONITOR
40cf					endif 
40cf cd 12 20				call forth_push_numhl 
40d2			 
40d2				       NEXTW 
40d2 cd a3 fd			call parse_vector 
40d5 c3 f5 23			jp macro_next 
40d8				endm 
# End of macro NEXTW
40d8			 
40d8			.maxcont:  
40d8 c1				pop bc   ; tidy up 
40d9 eb				ex de , hl  
40da					if DEBUG_FORTH_WORDS 
40da						DMARK "MA1" 
40da f5				push af  
40db 3a ef 40			ld a, (.dmark)  
40de 32 99 fd			ld (debug_mark),a  
40e1 3a f0 40			ld a, (.dmark+1)  
40e4 32 9a fd			ld (debug_mark+1),a  
40e7 3a f1 40			ld a, (.dmark+2)  
40ea 32 9b fd			ld (debug_mark+2),a  
40ed 18 03			jr .pastdmark  
40ef ..			.dmark: db "MA1"  
40f2 f1			.pastdmark: pop af  
40f3			endm  
# End of macro DMARK
40f3						CALLMONITOR 
40f3 cd a6 fd			call debug_vector  
40f6				endm  
# End of macro CALLMONITOR
40f6					endif 
40f6 cd 12 20				call forth_push_numhl 
40f9				       NEXTW 
40f9 cd a3 fd			call parse_vector 
40fc c3 f5 23			jp macro_next 
40ff				endm 
# End of macro NEXTW
40ff			 
40ff			.RND16: 
40ff				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
40ff 4e				db WORD_SYS_CORE+58             
4100 31 41			dw .RND8            
4102 06				db 5 + 1 
4103 .. 00			db "RND16",0              
4109				endm 
# End of macro CWHEAD
4109			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
4109					if DEBUG_FORTH_WORDS_KEY 
4109						DMARK "R16" 
4109 f5				push af  
410a 3a 1e 41			ld a, (.dmark)  
410d 32 99 fd			ld (debug_mark),a  
4110 3a 1f 41			ld a, (.dmark+1)  
4113 32 9a fd			ld (debug_mark+1),a  
4116 3a 20 41			ld a, (.dmark+2)  
4119 32 9b fd			ld (debug_mark+2),a  
411c 18 03			jr .pastdmark  
411e ..			.dmark: db "R16"  
4121 f1			.pastdmark: pop af  
4122			endm  
# End of macro DMARK
4122						CALLMONITOR 
4122 cd a6 fd			call debug_vector  
4125				endm  
# End of macro CALLMONITOR
4125					endif 
4125 cd d8 0e				call prng16  
4128 cd 12 20				call forth_push_numhl 
412b				       NEXTW 
412b cd a3 fd			call parse_vector 
412e c3 f5 23			jp macro_next 
4131				endm 
# End of macro NEXTW
4131			.RND8: 
4131				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
4131 60				db WORD_SYS_CORE+76             
4132 69 41			dw .RND            
4134 05				db 4 + 1 
4135 .. 00			db "RND8",0              
413a				endm 
# End of macro CWHEAD
413a			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
413a					if DEBUG_FORTH_WORDS_KEY 
413a						DMARK "RN8" 
413a f5				push af  
413b 3a 4f 41			ld a, (.dmark)  
413e 32 99 fd			ld (debug_mark),a  
4141 3a 50 41			ld a, (.dmark+1)  
4144 32 9a fd			ld (debug_mark+1),a  
4147 3a 51 41			ld a, (.dmark+2)  
414a 32 9b fd			ld (debug_mark+2),a  
414d 18 03			jr .pastdmark  
414f ..			.dmark: db "RN8"  
4152 f1			.pastdmark: pop af  
4153			endm  
# End of macro DMARK
4153						CALLMONITOR 
4153 cd a6 fd			call debug_vector  
4156				endm  
# End of macro CALLMONITOR
4156					endif 
4156 2a d7 fa				ld hl,(xrandc) 
4159 23					inc hl 
415a cd f2 0e				call xrnd 
415d 6f					ld l,a	 
415e 26 00				ld h,0 
4160 cd 12 20				call forth_push_numhl 
4163				       NEXTW 
4163 cd a3 fd			call parse_vector 
4166 c3 f5 23			jp macro_next 
4169				endm 
# End of macro NEXTW
4169			.RND: 
4169				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
4169 60				db WORD_SYS_CORE+76             
416a 72 42			dw .ENDMATHS            
416c 04				db 3 + 1 
416d .. 00			db "RND",0              
4171				endm 
# End of macro CWHEAD
4171			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
4171			 
4171					if DEBUG_FORTH_WORDS_KEY 
4171						DMARK "RND" 
4171 f5				push af  
4172 3a 86 41			ld a, (.dmark)  
4175 32 99 fd			ld (debug_mark),a  
4178 3a 87 41			ld a, (.dmark+1)  
417b 32 9a fd			ld (debug_mark+1),a  
417e 3a 88 41			ld a, (.dmark+2)  
4181 32 9b fd			ld (debug_mark+2),a  
4184 18 03			jr .pastdmark  
4186 ..			.dmark: db "RND"  
4189 f1			.pastdmark: pop af  
418a			endm  
# End of macro DMARK
418a						CALLMONITOR 
418a cd a6 fd			call debug_vector  
418d				endm  
# End of macro CALLMONITOR
418d					endif 
418d					 
418d					FORTH_DSP_VALUEHL    ; upper range 
418d cd 0e 22			call macro_dsp_valuehl 
4190				endm 
# End of macro FORTH_DSP_VALUEHL
4190			 
4190 22 db fa				ld (LFSRSeed), hl	 
4193			 
4193					if DEBUG_FORTH_WORDS 
4193						DMARK "RN1" 
4193 f5				push af  
4194 3a a8 41			ld a, (.dmark)  
4197 32 99 fd			ld (debug_mark),a  
419a 3a a9 41			ld a, (.dmark+1)  
419d 32 9a fd			ld (debug_mark+1),a  
41a0 3a aa 41			ld a, (.dmark+2)  
41a3 32 9b fd			ld (debug_mark+2),a  
41a6 18 03			jr .pastdmark  
41a8 ..			.dmark: db "RN1"  
41ab f1			.pastdmark: pop af  
41ac			endm  
# End of macro DMARK
41ac						CALLMONITOR 
41ac cd a6 fd			call debug_vector  
41af				endm  
# End of macro CALLMONITOR
41af					endif 
41af					FORTH_DSP_POP 
41af cd c6 22			call macro_forth_dsp_pop 
41b2				endm 
# End of macro FORTH_DSP_POP
41b2			 
41b2					FORTH_DSP_VALUEHL    ; low range 
41b2 cd 0e 22			call macro_dsp_valuehl 
41b5				endm 
# End of macro FORTH_DSP_VALUEHL
41b5			 
41b5					if DEBUG_FORTH_WORDS 
41b5						DMARK "RN2" 
41b5 f5				push af  
41b6 3a ca 41			ld a, (.dmark)  
41b9 32 99 fd			ld (debug_mark),a  
41bc 3a cb 41			ld a, (.dmark+1)  
41bf 32 9a fd			ld (debug_mark+1),a  
41c2 3a cc 41			ld a, (.dmark+2)  
41c5 32 9b fd			ld (debug_mark+2),a  
41c8 18 03			jr .pastdmark  
41ca ..			.dmark: db "RN2"  
41cd f1			.pastdmark: pop af  
41ce			endm  
# End of macro DMARK
41ce						CALLMONITOR 
41ce cd a6 fd			call debug_vector  
41d1				endm  
# End of macro CALLMONITOR
41d1					endif 
41d1 22 dd fa				ld (LFSRSeed+2), hl 
41d4			 
41d4					FORTH_DSP_POP 
41d4 cd c6 22			call macro_forth_dsp_pop 
41d7				endm 
# End of macro FORTH_DSP_POP
41d7			 
41d7 e5					push hl 
41d8			 
41d8 e1			.inrange:	pop hl 
41d9 cd d8 0e				call prng16  
41dc					if DEBUG_FORTH_WORDS 
41dc						DMARK "RN3" 
41dc f5				push af  
41dd 3a f1 41			ld a, (.dmark)  
41e0 32 99 fd			ld (debug_mark),a  
41e3 3a f2 41			ld a, (.dmark+1)  
41e6 32 9a fd			ld (debug_mark+1),a  
41e9 3a f3 41			ld a, (.dmark+2)  
41ec 32 9b fd			ld (debug_mark+2),a  
41ef 18 03			jr .pastdmark  
41f1 ..			.dmark: db "RN3"  
41f4 f1			.pastdmark: pop af  
41f5			endm  
# End of macro DMARK
41f5						CALLMONITOR 
41f5 cd a6 fd			call debug_vector  
41f8				endm  
# End of macro CALLMONITOR
41f8					endif 
41f8					 
41f8					; if the range is 8bit knock out the high byte 
41f8			 
41f8 ed 5b db fa			ld de, (LFSRSeed)     ; check high level 
41fc			 
41fc 3e 00				ld a, 0 
41fe ba					cp d  
41ff 20 1e				jr nz, .hirange 
4201 26 00				ld h, 0   ; knock it down to 8bit 
4203			 
4203					if DEBUG_FORTH_WORDS 
4203						DMARK "RNk" 
4203 f5				push af  
4204 3a 18 42			ld a, (.dmark)  
4207 32 99 fd			ld (debug_mark),a  
420a 3a 19 42			ld a, (.dmark+1)  
420d 32 9a fd			ld (debug_mark+1),a  
4210 3a 1a 42			ld a, (.dmark+2)  
4213 32 9b fd			ld (debug_mark+2),a  
4216 18 03			jr .pastdmark  
4218 ..			.dmark: db "RNk"  
421b f1			.pastdmark: pop af  
421c			endm  
# End of macro DMARK
421c						CALLMONITOR 
421c cd a6 fd			call debug_vector  
421f				endm  
# End of macro CALLMONITOR
421f					endif 
421f			.hirange:   
421f e5					push hl  
4220 b7					or a  
4221 ed 52		                sbc hl, de 
4223			 
4223					;call cmp16 
4223			 
4223 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
4225 e1					pop hl 
4226 e5					push hl 
4227			 
4227					if DEBUG_FORTH_WORDS 
4227						DMARK "RN4" 
4227 f5				push af  
4228 3a 3c 42			ld a, (.dmark)  
422b 32 99 fd			ld (debug_mark),a  
422e 3a 3d 42			ld a, (.dmark+1)  
4231 32 9a fd			ld (debug_mark+1),a  
4234 3a 3e 42			ld a, (.dmark+2)  
4237 32 9b fd			ld (debug_mark+2),a  
423a 18 03			jr .pastdmark  
423c ..			.dmark: db "RN4"  
423f f1			.pastdmark: pop af  
4240			endm  
# End of macro DMARK
4240						CALLMONITOR 
4240 cd a6 fd			call debug_vector  
4243				endm  
# End of macro CALLMONITOR
4243					endif 
4243 ed 5b dd fa			ld de, (LFSRSeed+2)   ; check low range 
4247					;call cmp16 
4247				 
4247 b7					or a  
4248 ed 52		                sbc hl, de 
424a 38 8c				jr c, .inrange 
424c			 
424c e1					pop hl 
424d					 
424d					if DEBUG_FORTH_WORDS 
424d						DMARK "RNd" 
424d f5				push af  
424e 3a 62 42			ld a, (.dmark)  
4251 32 99 fd			ld (debug_mark),a  
4254 3a 63 42			ld a, (.dmark+1)  
4257 32 9a fd			ld (debug_mark+1),a  
425a 3a 64 42			ld a, (.dmark+2)  
425d 32 9b fd			ld (debug_mark+2),a  
4260 18 03			jr .pastdmark  
4262 ..			.dmark: db "RNd"  
4265 f1			.pastdmark: pop af  
4266			endm  
# End of macro DMARK
4266						CALLMONITOR 
4266 cd a6 fd			call debug_vector  
4269				endm  
# End of macro CALLMONITOR
4269					endif 
4269			 
4269			 
4269 cd 12 20				call forth_push_numhl 
426c				       NEXTW 
426c cd a3 fd			call parse_vector 
426f c3 f5 23			jp macro_next 
4272				endm 
# End of macro NEXTW
4272			 
4272			.ENDMATHS: 
4272			 
4272			; eof 
4272			 
# End of file forth_words_maths.asm
4272			include "forth_words_display.asm" 
4272			 
4272			; | ## Display Words 
4272			 
4272			.ACT: 
4272			 
4272				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
4272 62				db WORD_SYS_CORE+78             
4273 c1 42			dw .INFO            
4275 07				db 6 + 1 
4276 .. 00			db "ACTIVE",0              
427d				endm 
# End of macro CWHEAD
427d			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
427d			;  
427d			; | | To display a pulsing activity indicator in a processing loop do this... 
427d			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
427d			 
427d					if DEBUG_FORTH_WORDS_KEY 
427d						DMARK "ACT" 
427d f5				push af  
427e 3a 92 42			ld a, (.dmark)  
4281 32 99 fd			ld (debug_mark),a  
4284 3a 93 42			ld a, (.dmark+1)  
4287 32 9a fd			ld (debug_mark+1),a  
428a 3a 94 42			ld a, (.dmark+2)  
428d 32 9b fd			ld (debug_mark+2),a  
4290 18 03			jr .pastdmark  
4292 ..			.dmark: db "ACT"  
4295 f1			.pastdmark: pop af  
4296			endm  
# End of macro DMARK
4296						CALLMONITOR 
4296 cd a6 fd			call debug_vector  
4299				endm  
# End of macro CALLMONITOR
4299					endif 
4299 cd d9 0c				call active 
429c					if DEBUG_FORTH_WORDS 
429c						DMARK "ACp" 
429c f5				push af  
429d 3a b1 42			ld a, (.dmark)  
42a0 32 99 fd			ld (debug_mark),a  
42a3 3a b2 42			ld a, (.dmark+1)  
42a6 32 9a fd			ld (debug_mark+1),a  
42a9 3a b3 42			ld a, (.dmark+2)  
42ac 32 9b fd			ld (debug_mark+2),a  
42af 18 03			jr .pastdmark  
42b1 ..			.dmark: db "ACp"  
42b4 f1			.pastdmark: pop af  
42b5			endm  
# End of macro DMARK
42b5						CALLMONITOR 
42b5 cd a6 fd			call debug_vector  
42b8				endm  
# End of macro CALLMONITOR
42b8					endif 
42b8 cd 7c 20				call forth_push_str 
42bb			 
42bb					NEXTW 
42bb cd a3 fd			call parse_vector 
42be c3 f5 23			jp macro_next 
42c1				endm 
# End of macro NEXTW
42c1			.INFO: 
42c1			 
42c1				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
42c1 62				db WORD_SYS_CORE+78             
42c2 e1 42			dw .ATP            
42c4 05				db 4 + 1 
42c5 .. 00			db "INFO",0              
42ca				endm 
# End of macro CWHEAD
42ca			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
42ca					FORTH_DSP_VALUEHL 
42ca cd 0e 22			call macro_dsp_valuehl 
42cd				endm 
# End of macro FORTH_DSP_VALUEHL
42cd			 
42cd					FORTH_DSP_POP 
42cd cd c6 22			call macro_forth_dsp_pop 
42d0				endm 
# End of macro FORTH_DSP_POP
42d0			 
42d0 e5					push hl 
42d1			 
42d1					FORTH_DSP_VALUEHL 
42d1 cd 0e 22			call macro_dsp_valuehl 
42d4				endm 
# End of macro FORTH_DSP_VALUEHL
42d4			 
42d4					FORTH_DSP_POP 
42d4 cd c6 22			call macro_forth_dsp_pop 
42d7				endm 
# End of macro FORTH_DSP_POP
42d7			 
42d7 d1					pop de 
42d8			 
42d8 cd 13 0d				call info_panel 
42db			 
42db			 
42db					NEXTW 
42db cd a3 fd			call parse_vector 
42de c3 f5 23			jp macro_next 
42e1				endm 
# End of macro NEXTW
42e1			.ATP: 
42e1				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
42e1 62				db WORD_SYS_CORE+78             
42e2 5b 43			dw .FB            
42e4 04				db 3 + 1 
42e5 .. 00			db "AT?",0              
42e9				endm 
# End of macro CWHEAD
42e9			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
42e9					if DEBUG_FORTH_WORDS_KEY 
42e9						DMARK "AT?" 
42e9 f5				push af  
42ea 3a fe 42			ld a, (.dmark)  
42ed 32 99 fd			ld (debug_mark),a  
42f0 3a ff 42			ld a, (.dmark+1)  
42f3 32 9a fd			ld (debug_mark+1),a  
42f6 3a 00 43			ld a, (.dmark+2)  
42f9 32 9b fd			ld (debug_mark+2),a  
42fc 18 03			jr .pastdmark  
42fe ..			.dmark: db "AT?"  
4301 f1			.pastdmark: pop af  
4302			endm  
# End of macro DMARK
4302						CALLMONITOR 
4302 cd a6 fd			call debug_vector  
4305				endm  
# End of macro CALLMONITOR
4305					endif 
4305 3a 8c f9				ld a, (f_cursor_ptr) 
4308			 
4308			if DEBUG_FORTH_WORDS 
4308				DMARK "AT?" 
4308 f5				push af  
4309 3a 1d 43			ld a, (.dmark)  
430c 32 99 fd			ld (debug_mark),a  
430f 3a 1e 43			ld a, (.dmark+1)  
4312 32 9a fd			ld (debug_mark+1),a  
4315 3a 1f 43			ld a, (.dmark+2)  
4318 32 9b fd			ld (debug_mark+2),a  
431b 18 03			jr .pastdmark  
431d ..			.dmark: db "AT?"  
4320 f1			.pastdmark: pop af  
4321			endm  
# End of macro DMARK
4321				CALLMONITOR 
4321 cd a6 fd			call debug_vector  
4324				endm  
# End of macro CALLMONITOR
4324			endif	 
4324					; count the number of rows 
4324			 
4324 06 00				ld b, 0 
4326 4f			.atpr:		ld c, a    ; save in case we go below zero 
4327 d6 28				sub display_cols 
4329 f2 2f 43				jp p, .atprunder 
432c 04					inc b 
432d 18 f7				jr .atpr 
432f			.atprunder:	 
432f			if DEBUG_FORTH_WORDS 
432f				DMARK "A?2" 
432f f5				push af  
4330 3a 44 43			ld a, (.dmark)  
4333 32 99 fd			ld (debug_mark),a  
4336 3a 45 43			ld a, (.dmark+1)  
4339 32 9a fd			ld (debug_mark+1),a  
433c 3a 46 43			ld a, (.dmark+2)  
433f 32 9b fd			ld (debug_mark+2),a  
4342 18 03			jr .pastdmark  
4344 ..			.dmark: db "A?2"  
4347 f1			.pastdmark: pop af  
4348			endm  
# End of macro DMARK
4348				CALLMONITOR 
4348 cd a6 fd			call debug_vector  
434b				endm  
# End of macro CALLMONITOR
434b			endif	 
434b 26 00				ld h, 0 
434d 69					ld l, c 
434e cd 12 20				call forth_push_numhl 
4351 68					ld l, b  
4352 cd 12 20				call forth_push_numhl 
4355			 
4355			 
4355				NEXTW 
4355 cd a3 fd			call parse_vector 
4358 c3 f5 23			jp macro_next 
435b				endm 
# End of macro NEXTW
435b			 
435b			.FB: 
435b				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
435b 1b				db WORD_SYS_CORE+7             
435c ac 43			dw .EMIT            
435e 03				db 2 + 1 
435f .. 00			db "FB",0              
4362				endm 
# End of macro CWHEAD
4362			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
4362			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
4362			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
4362			; | | If automatic display is off then updates will not be shown until DRAW is used. 
4362					if DEBUG_FORTH_WORDS_KEY 
4362						DMARK "FB." 
4362 f5				push af  
4363 3a 77 43			ld a, (.dmark)  
4366 32 99 fd			ld (debug_mark),a  
4369 3a 78 43			ld a, (.dmark+1)  
436c 32 9a fd			ld (debug_mark+1),a  
436f 3a 79 43			ld a, (.dmark+2)  
4372 32 9b fd			ld (debug_mark+2),a  
4375 18 03			jr .pastdmark  
4377 ..			.dmark: db "FB."  
437a f1			.pastdmark: pop af  
437b			endm  
# End of macro DMARK
437b						CALLMONITOR 
437b cd a6 fd			call debug_vector  
437e				endm  
# End of macro CALLMONITOR
437e					endif 
437e			 
437e					FORTH_DSP_VALUEHL 
437e cd 0e 22			call macro_dsp_valuehl 
4381				endm 
# End of macro FORTH_DSP_VALUEHL
4381			 
4381 7d					ld a, l 
4382 fe 01				cp 1 
4384 20 05				jr nz, .fbn1 
4386 21 3e fc				ld hl, display_fb1 
4389 18 15				jr .fbset 
438b fe 02		.fbn1:		cp 2 
438d 20 05				jr nz, .fbn2 
438f 21 fc fa				ld hl, display_fb2 
4392 18 0c				jr .fbset 
4394 fe 03		.fbn2:		cp 3 
4396 20 05				jr nz, .fbn3 
4398 21 9d fb				ld hl, display_fb3 
439b 18 03				jr .fbset 
439d			.fbn3:		 ; if invalid number select first 
439d 21 3e fc				ld hl, display_fb1 
43a0 22 fa fa		.fbset:		ld (display_fb_active), hl 
43a3			 
43a3					FORTH_DSP_POP 
43a3 cd c6 22			call macro_forth_dsp_pop 
43a6				endm 
# End of macro FORTH_DSP_POP
43a6			 
43a6					NEXTW 
43a6 cd a3 fd			call parse_vector 
43a9 c3 f5 23			jp macro_next 
43ac				endm 
# End of macro NEXTW
43ac			 
43ac			 
43ac			.EMIT: 
43ac				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
43ac 1b				db WORD_SYS_CORE+7             
43ad ff 43			dw .DOTH            
43af 05				db 4 + 1 
43b0 .. 00			db "EMIT",0              
43b5				endm 
# End of macro CWHEAD
43b5			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
43b5					; get value off TOS and display it 
43b5			 
43b5					if DEBUG_FORTH_WORDS_KEY 
43b5						DMARK "EMT" 
43b5 f5				push af  
43b6 3a ca 43			ld a, (.dmark)  
43b9 32 99 fd			ld (debug_mark),a  
43bc 3a cb 43			ld a, (.dmark+1)  
43bf 32 9a fd			ld (debug_mark+1),a  
43c2 3a cc 43			ld a, (.dmark+2)  
43c5 32 9b fd			ld (debug_mark+2),a  
43c8 18 03			jr .pastdmark  
43ca ..			.dmark: db "EMT"  
43cd f1			.pastdmark: pop af  
43ce			endm  
# End of macro DMARK
43ce						CALLMONITOR 
43ce cd a6 fd			call debug_vector  
43d1				endm  
# End of macro CALLMONITOR
43d1					endif 
43d1			 
43d1					FORTH_DSP_VALUEHL 
43d1 cd 0e 22			call macro_dsp_valuehl 
43d4				endm 
# End of macro FORTH_DSP_VALUEHL
43d4			 
43d4 7d					ld a,l 
43d5			 
43d5					; TODO write to display 
43d5			 
43d5 32 ed f2				ld (os_input), a 
43d8 3e 00				ld a, 0 
43da 32 ee f2				ld (os_input+1), a 
43dd					 
43dd 3a 8c f9				ld a, (f_cursor_ptr) 
43e0 11 ed f2				ld de, os_input 
43e3 cd 93 0d				call str_at_display 
43e6			 
43e6			 
43e6 3a 6a f9				ld a,(cli_autodisplay) 
43e9			;		cp 0 
43e9 b7					or a 
43ea 28 03				jr z, .enoupdate 
43ec cd a3 0d						call update_display 
43ef					.enoupdate: 
43ef			 
43ef 3a 8c f9				ld a, (f_cursor_ptr) 
43f2 3c					inc a 
43f3 32 8c f9				ld (f_cursor_ptr), a   ; save new pos 
43f6			 
43f6			 
43f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43f6 cd c6 22			call macro_forth_dsp_pop 
43f9				endm 
# End of macro FORTH_DSP_POP
43f9			  
43f9			 
43f9					NEXTW 
43f9 cd a3 fd			call parse_vector 
43fc c3 f5 23			jp macro_next 
43ff				endm 
# End of macro NEXTW
43ff			.DOTH: 
43ff				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
43ff 1c				db WORD_SYS_CORE+8             
4400 32 44			dw .DOTF            
4402 03				db 2 + 1 
4403 .. 00			db ".-",0              
4406				endm 
# End of macro CWHEAD
4406			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
4406					; get value off TOS and display it 
4406					if DEBUG_FORTH_WORDS_KEY 
4406						DMARK "DTD" 
4406 f5				push af  
4407 3a 1b 44			ld a, (.dmark)  
440a 32 99 fd			ld (debug_mark),a  
440d 3a 1c 44			ld a, (.dmark+1)  
4410 32 9a fd			ld (debug_mark+1),a  
4413 3a 1d 44			ld a, (.dmark+2)  
4416 32 9b fd			ld (debug_mark+2),a  
4419 18 03			jr .pastdmark  
441b ..			.dmark: db "DTD"  
441e f1			.pastdmark: pop af  
441f			endm  
# End of macro DMARK
441f						CALLMONITOR 
441f cd a6 fd			call debug_vector  
4422				endm  
# End of macro CALLMONITOR
4422					endif 
4422 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
4424 3e 00			ld a, 0 
4426 32 6b f9			ld (cli_mvdot), a 
4429 c3 8c 44			jp .dotgo 
442c				NEXTW 
442c cd a3 fd			call parse_vector 
442f c3 f5 23			jp macro_next 
4432				endm 
# End of macro NEXTW
4432			.DOTF: 
4432				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
4432 1c				db WORD_SYS_CORE+8             
4433 63 44			dw .DOT            
4435 03				db 2 + 1 
4436 .. 00			db ".>",0              
4439				endm 
# End of macro CWHEAD
4439			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
4439					; get value off TOS and display it 
4439			        ; TODO BUG adds extra spaces 
4439			        ; TODO BUG handle numerics? 
4439					if DEBUG_FORTH_WORDS_KEY 
4439						DMARK "DTC" 
4439 f5				push af  
443a 3a 4e 44			ld a, (.dmark)  
443d 32 99 fd			ld (debug_mark),a  
4440 3a 4f 44			ld a, (.dmark+1)  
4443 32 9a fd			ld (debug_mark+1),a  
4446 3a 50 44			ld a, (.dmark+2)  
4449 32 9b fd			ld (debug_mark+2),a  
444c 18 03			jr .pastdmark  
444e ..			.dmark: db "DTC"  
4451 f1			.pastdmark: pop af  
4452			endm  
# End of macro DMARK
4452						CALLMONITOR 
4452 cd a6 fd			call debug_vector  
4455				endm  
# End of macro CALLMONITOR
4455					endif 
4455 3e 01			ld a, 1 
4457 32 6b f9			ld (cli_mvdot), a 
445a c3 8c 44			jp .dotgo 
445d				NEXTW 
445d cd a3 fd			call parse_vector 
4460 c3 f5 23			jp macro_next 
4463				endm 
# End of macro NEXTW
4463			 
4463			.DOT: 
4463				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
4463 1c				db WORD_SYS_CORE+8             
4464 3e 46			dw .CLS            
4466 02				db 1 + 1 
4467 .. 00			db ".",0              
4469				endm 
# End of macro CWHEAD
4469			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
4469					; get value off TOS and display it 
4469			 
4469					if DEBUG_FORTH_WORDS_KEY 
4469						DMARK "DOT" 
4469 f5				push af  
446a 3a 7e 44			ld a, (.dmark)  
446d 32 99 fd			ld (debug_mark),a  
4470 3a 7f 44			ld a, (.dmark+1)  
4473 32 9a fd			ld (debug_mark+1),a  
4476 3a 80 44			ld a, (.dmark+2)  
4479 32 9b fd			ld (debug_mark+2),a  
447c 18 03			jr .pastdmark  
447e ..			.dmark: db "DOT"  
4481 f1			.pastdmark: pop af  
4482			endm  
# End of macro DMARK
4482						CALLMONITOR 
4482 cd a6 fd			call debug_vector  
4485				endm  
# End of macro CALLMONITOR
4485					endif 
4485 3e 00			ld a, 0 
4487 32 6b f9			ld (cli_mvdot), a 
448a 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
448c				 
448c			 
448c			.dotgo: 
448c			 
448c			; move up type to on stack for parserv5 
448c					FORTH_DSP 
448c cd d4 21			call macro_forth_dsp 
448f				endm 
# End of macro FORTH_DSP
448f				;FORTH_DSP_VALUE  
448f			 
448f			if DEBUG_FORTH_DOT 
448f				DMARK "DOT" 
448f f5				push af  
4490 3a a4 44			ld a, (.dmark)  
4493 32 99 fd			ld (debug_mark),a  
4496 3a a5 44			ld a, (.dmark+1)  
4499 32 9a fd			ld (debug_mark+1),a  
449c 3a a6 44			ld a, (.dmark+2)  
449f 32 9b fd			ld (debug_mark+2),a  
44a2 18 03			jr .pastdmark  
44a4 ..			.dmark: db "DOT"  
44a7 f1			.pastdmark: pop af  
44a8			endm  
# End of macro DMARK
44a8				CALLMONITOR 
44a8 cd a6 fd			call debug_vector  
44ab				endm  
# End of macro CALLMONITOR
44ab			endif	 
44ab			;		.print: 
44ab			 
44ab 7e				ld a,(hl)  ; work out what type of value is on the TOS 
44ac 23				inc hl   ; position to the actual value 
44ad fe 01			cp DS_TYPE_STR 
44af 20 06			jr nz, .dotnum1  
44b1			 
44b1			; display string 
44b1				FORTH_DSP_VALUE  
44b1 cd f7 21			call macro_forth_dsp_value 
44b4				endm 
# End of macro FORTH_DSP_VALUE
44b4 eb				ex de,hl 
44b5 18 49			jr .dotwrite 
44b7			 
44b7			.dotnum1: 
44b7 fe 02			cp DS_TYPE_INUM 
44b9 20 44			jr nz, .dotflot 
44bb			 
44bb			 
44bb			; display number 
44bb			 
44bb			;	push hl 
44bb			;	call clear_display 
44bb			;	pop hl 
44bb			 
44bb 5e				ld e, (hl) 
44bc 23				inc hl 
44bd 56				ld d, (hl) 
44be 21 ef f0			ld hl, scratch 
44c1			if DEBUG_FORTH_DOT 
44c1				DMARK "DT1" 
44c1 f5				push af  
44c2 3a d6 44			ld a, (.dmark)  
44c5 32 99 fd			ld (debug_mark),a  
44c8 3a d7 44			ld a, (.dmark+1)  
44cb 32 9a fd			ld (debug_mark+1),a  
44ce 3a d8 44			ld a, (.dmark+2)  
44d1 32 9b fd			ld (debug_mark+2),a  
44d4 18 03			jr .pastdmark  
44d6 ..			.dmark: db "DT1"  
44d9 f1			.pastdmark: pop af  
44da			endm  
# End of macro DMARK
44da				CALLMONITOR 
44da cd a6 fd			call debug_vector  
44dd				endm  
# End of macro CALLMONITOR
44dd			endif	 
44dd			 
44dd cd b8 12			call uitoa_16 
44e0 eb				ex de,hl 
44e1			 
44e1			if DEBUG_FORTH_DOT 
44e1				DMARK "DT2" 
44e1 f5				push af  
44e2 3a f6 44			ld a, (.dmark)  
44e5 32 99 fd			ld (debug_mark),a  
44e8 3a f7 44			ld a, (.dmark+1)  
44eb 32 9a fd			ld (debug_mark+1),a  
44ee 3a f8 44			ld a, (.dmark+2)  
44f1 32 9b fd			ld (debug_mark+2),a  
44f4 18 03			jr .pastdmark  
44f6 ..			.dmark: db "DT2"  
44f9 f1			.pastdmark: pop af  
44fa			endm  
# End of macro DMARK
44fa				CALLMONITOR 
44fa cd a6 fd			call debug_vector  
44fd				endm  
# End of macro CALLMONITOR
44fd			endif	 
44fd			 
44fd			;	ld de, os_word_scratch 
44fd 18 01			jr .dotwrite 
44ff			 
44ff 00			.dotflot:   nop 
4500			; TODO print floating point number 
4500			 
4500			.dotwrite:		 
4500			 
4500					; if c is set then set all '-' to spaces 
4500					; need to also take into account .>  
4500			 
4500 3e 01				ld a, 1 
4502 b9					cp c 
4503 20 65				jr nz, .nodashswap 
4505			 
4505					; DE has the string to write, working with HL 
4505			 
4505 06 ff				ld b, 255 
4507 d5					push de 
4508 e1					pop hl 
4509			 
4509			if DEBUG_FORTH_DOT 
4509				DMARK "DT-" 
4509 f5				push af  
450a 3a 1e 45			ld a, (.dmark)  
450d 32 99 fd			ld (debug_mark),a  
4510 3a 1f 45			ld a, (.dmark+1)  
4513 32 9a fd			ld (debug_mark+1),a  
4516 3a 20 45			ld a, (.dmark+2)  
4519 32 9b fd			ld (debug_mark+2),a  
451c 18 03			jr .pastdmark  
451e ..			.dmark: db "DT-"  
4521 f1			.pastdmark: pop af  
4522			endm  
# End of macro DMARK
4522				CALLMONITOR 
4522 cd a6 fd			call debug_vector  
4525				endm  
# End of macro CALLMONITOR
4525			endif	 
4525 7e			.dashscan:	ld a, (hl) 
4526			;		cp 0 
4526 b7					or a 
4527 28 41				jr z, .nodashswap 
4529 fe 2d				cp '-' 
452b 20 02				jr nz, .dashskip 
452d			;		ld a, ' ' 
452d 36 20				ld (hl), ' ' 
452f 23			.dashskip:	inc hl 
4530			if DEBUG_FORTH_DOT 
4530				DMARK "D-2" 
4530 f5				push af  
4531 3a 45 45			ld a, (.dmark)  
4534 32 99 fd			ld (debug_mark),a  
4537 3a 46 45			ld a, (.dmark+1)  
453a 32 9a fd			ld (debug_mark+1),a  
453d 3a 47 45			ld a, (.dmark+2)  
4540 32 9b fd			ld (debug_mark+2),a  
4543 18 03			jr .pastdmark  
4545 ..			.dmark: db "D-2"  
4548 f1			.pastdmark: pop af  
4549			endm  
# End of macro DMARK
4549				CALLMONITOR 
4549 cd a6 fd			call debug_vector  
454c				endm  
# End of macro CALLMONITOR
454c			endif	 
454c 10 d7				djnz .dashscan 
454e			 
454e			if DEBUG_FORTH_DOT 
454e				DMARK "D-1" 
454e f5				push af  
454f 3a 63 45			ld a, (.dmark)  
4552 32 99 fd			ld (debug_mark),a  
4555 3a 64 45			ld a, (.dmark+1)  
4558 32 9a fd			ld (debug_mark+1),a  
455b 3a 65 45			ld a, (.dmark+2)  
455e 32 9b fd			ld (debug_mark+2),a  
4561 18 03			jr .pastdmark  
4563 ..			.dmark: db "D-1"  
4566 f1			.pastdmark: pop af  
4567			endm  
# End of macro DMARK
4567				CALLMONITOR 
4567 cd a6 fd			call debug_vector  
456a				endm  
# End of macro CALLMONITOR
456a			endif	 
456a			 
456a			.nodashswap: 
456a			 
456a			if DEBUG_FORTH_DOT 
456a				DMARK "D-o" 
456a f5				push af  
456b 3a 7f 45			ld a, (.dmark)  
456e 32 99 fd			ld (debug_mark),a  
4571 3a 80 45			ld a, (.dmark+1)  
4574 32 9a fd			ld (debug_mark+1),a  
4577 3a 81 45			ld a, (.dmark+2)  
457a 32 9b fd			ld (debug_mark+2),a  
457d 18 03			jr .pastdmark  
457f ..			.dmark: db "D-o"  
4582 f1			.pastdmark: pop af  
4583			endm  
# End of macro DMARK
4583				CALLMONITOR 
4583 cd a6 fd			call debug_vector  
4586				endm  
# End of macro CALLMONITOR
4586			endif	 
4586			 
4586 d5					push de   ; save string start in case we need to advance print 
4587			 
4587 3a 8c f9				ld a, (f_cursor_ptr) 
458a cd 93 0d				call str_at_display 
458d 3a 6a f9				ld a,(cli_autodisplay) 
4590			;		cp 0 
4590 b7					or a 
4591 28 03				jr z, .noupdate 
4593 cd a3 0d						call update_display 
4596					.noupdate: 
4596			 
4596			 
4596					; see if we need to advance the print position 
4596			 
4596 e1					pop hl   ; get back string 
4597			;		ex de,hl 
4597			 
4597 3a 6b f9				ld a, (cli_mvdot) 
459a			if DEBUG_FORTH_DOT 
459a			;		ld e,a 
459a				DMARK "D>1" 
459a f5				push af  
459b 3a af 45			ld a, (.dmark)  
459e 32 99 fd			ld (debug_mark),a  
45a1 3a b0 45			ld a, (.dmark+1)  
45a4 32 9a fd			ld (debug_mark+1),a  
45a7 3a b1 45			ld a, (.dmark+2)  
45aa 32 9b fd			ld (debug_mark+2),a  
45ad 18 03			jr .pastdmark  
45af ..			.dmark: db "D>1"  
45b2 f1			.pastdmark: pop af  
45b3			endm  
# End of macro DMARK
45b3				CALLMONITOR 
45b3 cd a6 fd			call debug_vector  
45b6				endm  
# End of macro CALLMONITOR
45b6			endif	 
45b6			;		cp 0 
45b6 b7					or a 
45b7 28 44				jr z, .noadv 
45b9					; yes, lets advance the print position 
45b9 3e 00				ld a, 0 
45bb cd 14 13				call strlent 
45be			if DEBUG_FORTH_DOT 
45be				DMARK "D-?" 
45be f5				push af  
45bf 3a d3 45			ld a, (.dmark)  
45c2 32 99 fd			ld (debug_mark),a  
45c5 3a d4 45			ld a, (.dmark+1)  
45c8 32 9a fd			ld (debug_mark+1),a  
45cb 3a d5 45			ld a, (.dmark+2)  
45ce 32 9b fd			ld (debug_mark+2),a  
45d1 18 03			jr .pastdmark  
45d3 ..			.dmark: db "D-?"  
45d6 f1			.pastdmark: pop af  
45d7			endm  
# End of macro DMARK
45d7				CALLMONITOR 
45d7 cd a6 fd			call debug_vector  
45da				endm  
# End of macro CALLMONITOR
45da			endif	 
45da 3a 8c f9				ld a, (f_cursor_ptr) 
45dd 85					add a,l 
45de					;call addatohl 
45de					;ld a, l 
45de 32 8c f9				ld (f_cursor_ptr), a   ; save new pos 
45e1			 
45e1			if DEBUG_FORTH_DOT 
45e1				DMARK "D->" 
45e1 f5				push af  
45e2 3a f6 45			ld a, (.dmark)  
45e5 32 99 fd			ld (debug_mark),a  
45e8 3a f7 45			ld a, (.dmark+1)  
45eb 32 9a fd			ld (debug_mark+1),a  
45ee 3a f8 45			ld a, (.dmark+2)  
45f1 32 9b fd			ld (debug_mark+2),a  
45f4 18 03			jr .pastdmark  
45f6 ..			.dmark: db "D->"  
45f9 f1			.pastdmark: pop af  
45fa			endm  
# End of macro DMARK
45fa				CALLMONITOR 
45fa cd a6 fd			call debug_vector  
45fd				endm  
# End of macro CALLMONITOR
45fd			endif	 
45fd			 
45fd			.noadv:	 
45fd			 
45fd					if DEBUG_FORTH_DOT_WAIT 
45fd							call next_page_prompt 
45fd					endif	 
45fd			; TODO this pop off the stack causes a crash. i dont know why 
45fd			 
45fd			 
45fd			if DEBUG_FORTH_DOT 
45fd				DMARK "DTh" 
45fd f5				push af  
45fe 3a 12 46			ld a, (.dmark)  
4601 32 99 fd			ld (debug_mark),a  
4604 3a 13 46			ld a, (.dmark+1)  
4607 32 9a fd			ld (debug_mark+1),a  
460a 3a 14 46			ld a, (.dmark+2)  
460d 32 9b fd			ld (debug_mark+2),a  
4610 18 03			jr .pastdmark  
4612 ..			.dmark: db "DTh"  
4615 f1			.pastdmark: pop af  
4616			endm  
# End of macro DMARK
4616				CALLMONITOR 
4616 cd a6 fd			call debug_vector  
4619				endm  
# End of macro CALLMONITOR
4619			endif	 
4619			 
4619					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4619 cd c6 22			call macro_forth_dsp_pop 
461c				endm 
# End of macro FORTH_DSP_POP
461c			 
461c			if DEBUG_FORTH_DOT 
461c				DMARK "DTi" 
461c f5				push af  
461d 3a 31 46			ld a, (.dmark)  
4620 32 99 fd			ld (debug_mark),a  
4623 3a 32 46			ld a, (.dmark+1)  
4626 32 9a fd			ld (debug_mark+1),a  
4629 3a 33 46			ld a, (.dmark+2)  
462c 32 9b fd			ld (debug_mark+2),a  
462f 18 03			jr .pastdmark  
4631 ..			.dmark: db "DTi"  
4634 f1			.pastdmark: pop af  
4635			endm  
# End of macro DMARK
4635				CALLMONITOR 
4635 cd a6 fd			call debug_vector  
4638				endm  
# End of macro CALLMONITOR
4638			endif	 
4638			 
4638			 
4638					NEXTW 
4638 cd a3 fd			call parse_vector 
463b c3 f5 23			jp macro_next 
463e				endm 
# End of macro NEXTW
463e			 
463e			.CLS: 
463e				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
463e 35				db WORD_SYS_CORE+33             
463f 6e 46			dw .DRAW            
4641 04				db 3 + 1 
4642 .. 00			db "CLS",0              
4646				endm 
# End of macro CWHEAD
4646			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4646					if DEBUG_FORTH_WORDS_KEY 
4646						DMARK "CLS" 
4646 f5				push af  
4647 3a 5b 46			ld a, (.dmark)  
464a 32 99 fd			ld (debug_mark),a  
464d 3a 5c 46			ld a, (.dmark+1)  
4650 32 9a fd			ld (debug_mark+1),a  
4653 3a 5d 46			ld a, (.dmark+2)  
4656 32 9b fd			ld (debug_mark+2),a  
4659 18 03			jr .pastdmark  
465b ..			.dmark: db "CLS"  
465e f1			.pastdmark: pop af  
465f			endm  
# End of macro DMARK
465f						CALLMONITOR 
465f cd a6 fd			call debug_vector  
4662				endm  
# End of macro CALLMONITOR
4662					endif 
4662 cd 81 0d				call clear_display 
4665 c3 88 47				jp .home		; and home cursor 
4668					NEXTW 
4668 cd a3 fd			call parse_vector 
466b c3 f5 23			jp macro_next 
466e				endm 
# End of macro NEXTW
466e			 
466e			.DRAW: 
466e				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
466e 36				db WORD_SYS_CORE+34             
466f 9c 46			dw .DUMP            
4671 05				db 4 + 1 
4672 .. 00			db "DRAW",0              
4677				endm 
# End of macro CWHEAD
4677			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4677					if DEBUG_FORTH_WORDS_KEY 
4677						DMARK "DRW" 
4677 f5				push af  
4678 3a 8c 46			ld a, (.dmark)  
467b 32 99 fd			ld (debug_mark),a  
467e 3a 8d 46			ld a, (.dmark+1)  
4681 32 9a fd			ld (debug_mark+1),a  
4684 3a 8e 46			ld a, (.dmark+2)  
4687 32 9b fd			ld (debug_mark+2),a  
468a 18 03			jr .pastdmark  
468c ..			.dmark: db "DRW"  
468f f1			.pastdmark: pop af  
4690			endm  
# End of macro DMARK
4690						CALLMONITOR 
4690 cd a6 fd			call debug_vector  
4693				endm  
# End of macro CALLMONITOR
4693					endif 
4693 cd a3 0d				call update_display 
4696					NEXTW 
4696 cd a3 fd			call parse_vector 
4699 c3 f5 23			jp macro_next 
469c				endm 
# End of macro NEXTW
469c			 
469c			.DUMP: 
469c				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
469c 37				db WORD_SYS_CORE+35             
469d d7 46			dw .CDUMP            
469f 05				db 4 + 1 
46a0 .. 00			db "DUMP",0              
46a5				endm 
# End of macro CWHEAD
46a5			; | DUMP ( x -- ) With address x display dump   | DONE 
46a5			; TODO pop address to use off of the stack 
46a5					if DEBUG_FORTH_WORDS_KEY 
46a5						DMARK "DUM" 
46a5 f5				push af  
46a6 3a ba 46			ld a, (.dmark)  
46a9 32 99 fd			ld (debug_mark),a  
46ac 3a bb 46			ld a, (.dmark+1)  
46af 32 9a fd			ld (debug_mark+1),a  
46b2 3a bc 46			ld a, (.dmark+2)  
46b5 32 9b fd			ld (debug_mark+2),a  
46b8 18 03			jr .pastdmark  
46ba ..			.dmark: db "DUM"  
46bd f1			.pastdmark: pop af  
46be			endm  
# End of macro DMARK
46be						CALLMONITOR 
46be cd a6 fd			call debug_vector  
46c1				endm  
# End of macro CALLMONITOR
46c1					endif 
46c1 cd 81 0d				call clear_display 
46c4			 
46c4					; get address 
46c4			 
46c4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46c4 cd 0e 22			call macro_dsp_valuehl 
46c7				endm 
# End of macro FORTH_DSP_VALUEHL
46c7				 
46c7					; save it for cdump 
46c7			 
46c7 22 12 f4				ld (os_cur_ptr),hl 
46ca			 
46ca					; destroy value TOS 
46ca			 
46ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46ca cd c6 22			call macro_forth_dsp_pop 
46cd				endm 
# End of macro FORTH_DSP_POP
46cd			 
46cd cd 96 1e				call dumpcont	; skip old style of param parsing	 
46d0 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
46d1					NEXTW 
46d1 cd a3 fd			call parse_vector 
46d4 c3 f5 23			jp macro_next 
46d7				endm 
# End of macro NEXTW
46d7			.CDUMP: 
46d7				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
46d7 38				db WORD_SYS_CORE+36             
46d8 0a 47			dw .DAT            
46da 06				db 5 + 1 
46db .. 00			db "CDUMP",0              
46e1				endm 
# End of macro CWHEAD
46e1			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
46e1					if DEBUG_FORTH_WORDS_KEY 
46e1						DMARK "CDP" 
46e1 f5				push af  
46e2 3a f6 46			ld a, (.dmark)  
46e5 32 99 fd			ld (debug_mark),a  
46e8 3a f7 46			ld a, (.dmark+1)  
46eb 32 9a fd			ld (debug_mark+1),a  
46ee 3a f8 46			ld a, (.dmark+2)  
46f1 32 9b fd			ld (debug_mark+2),a  
46f4 18 03			jr .pastdmark  
46f6 ..			.dmark: db "CDP"  
46f9 f1			.pastdmark: pop af  
46fa			endm  
# End of macro DMARK
46fa						CALLMONITOR 
46fa cd a6 fd			call debug_vector  
46fd				endm  
# End of macro CALLMONITOR
46fd					endif 
46fd cd 81 0d				call clear_display 
4700 cd 96 1e				call dumpcont	 
4703 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4704					NEXTW 
4704 cd a3 fd			call parse_vector 
4707 c3 f5 23			jp macro_next 
470a				endm 
# End of macro NEXTW
470a			 
470a			 
470a			 
470a			 
470a			.DAT: 
470a				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
470a 3d				db WORD_SYS_CORE+41             
470b 63 47			dw .HOME            
470d 03				db 2 + 1 
470e .. 00			db "AT",0              
4711				endm 
# End of macro CWHEAD
4711			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4711					if DEBUG_FORTH_WORDS_KEY 
4711						DMARK "AT." 
4711 f5				push af  
4712 3a 26 47			ld a, (.dmark)  
4715 32 99 fd			ld (debug_mark),a  
4718 3a 27 47			ld a, (.dmark+1)  
471b 32 9a fd			ld (debug_mark+1),a  
471e 3a 28 47			ld a, (.dmark+2)  
4721 32 9b fd			ld (debug_mark+2),a  
4724 18 03			jr .pastdmark  
4726 ..			.dmark: db "AT."  
4729 f1			.pastdmark: pop af  
472a			endm  
# End of macro DMARK
472a						CALLMONITOR 
472a cd a6 fd			call debug_vector  
472d				endm  
# End of macro CALLMONITOR
472d					endif 
472d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
472d cd 0e 22			call macro_dsp_valuehl 
4730				endm 
# End of macro FORTH_DSP_VALUEHL
4730			 
4730			 
4730					; TODO save cursor row 
4730 7d					ld a,l 
4731 fe 02				cp 2 
4733 20 04				jr nz, .crow3 
4735 3e 28				ld a, display_row_2 
4737 18 12				jr .ccol1 
4739 fe 03		.crow3:		cp 3 
473b 20 04				jr nz, .crow4 
473d 3e 50				ld a, display_row_3 
473f 18 0a				jr .ccol1 
4741 fe 04		.crow4:		cp 4 
4743 20 04				jr nz, .crow1 
4745 3e 78				ld a, display_row_4 
4747 18 02				jr .ccol1 
4749 3e 00		.crow1:		ld a,display_row_1 
474b f5			.ccol1:		push af			; got row offset 
474c 6f					ld l,a 
474d 26 00				ld h,0 
474f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
474f cd c6 22			call macro_forth_dsp_pop 
4752				endm 
# End of macro FORTH_DSP_POP
4752					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4752 cd 0e 22			call macro_dsp_valuehl 
4755				endm 
# End of macro FORTH_DSP_VALUEHL
4755					; TODO save cursor col 
4755 f1					pop af 
4756 85					add l		; add col offset 
4757 32 8c f9				ld (f_cursor_ptr), a 
475a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
475a cd c6 22			call macro_forth_dsp_pop 
475d				endm 
# End of macro FORTH_DSP_POP
475d			 
475d					; calculate  
475d			 
475d					NEXTW 
475d cd a3 fd			call parse_vector 
4760 c3 f5 23			jp macro_next 
4763				endm 
# End of macro NEXTW
4763			 
4763			 
4763			.HOME: 
4763				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4763 41				db WORD_SYS_CORE+45             
4764 93 47			dw .CR            
4766 05				db 4 + 1 
4767 .. 00			db "HOME",0              
476c				endm 
# End of macro CWHEAD
476c			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
476c					if DEBUG_FORTH_WORDS_KEY 
476c						DMARK "HOM" 
476c f5				push af  
476d 3a 81 47			ld a, (.dmark)  
4770 32 99 fd			ld (debug_mark),a  
4773 3a 82 47			ld a, (.dmark+1)  
4776 32 9a fd			ld (debug_mark+1),a  
4779 3a 83 47			ld a, (.dmark+2)  
477c 32 9b fd			ld (debug_mark+2),a  
477f 18 03			jr .pastdmark  
4781 ..			.dmark: db "HOM"  
4784 f1			.pastdmark: pop af  
4785			endm  
# End of macro DMARK
4785						CALLMONITOR 
4785 cd a6 fd			call debug_vector  
4788				endm  
# End of macro CALLMONITOR
4788					endif 
4788 3e 00		.home:		ld a, 0		; and home cursor 
478a 32 8c f9				ld (f_cursor_ptr), a 
478d					NEXTW 
478d cd a3 fd			call parse_vector 
4790 c3 f5 23			jp macro_next 
4793				endm 
# End of macro NEXTW
4793			 
4793			 
4793			.CR: 
4793				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
4793 46				db WORD_SYS_CORE+50             
4794 d1 47			dw .SPACE            
4796 03				db 2 + 1 
4797 .. 00			db "CR",0              
479a				endm 
# End of macro CWHEAD
479a			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
479a					if DEBUG_FORTH_WORDS_KEY 
479a						DMARK "CR." 
479a f5				push af  
479b 3a af 47			ld a, (.dmark)  
479e 32 99 fd			ld (debug_mark),a  
47a1 3a b0 47			ld a, (.dmark+1)  
47a4 32 9a fd			ld (debug_mark+1),a  
47a7 3a b1 47			ld a, (.dmark+2)  
47aa 32 9b fd			ld (debug_mark+2),a  
47ad 18 03			jr .pastdmark  
47af ..			.dmark: db "CR."  
47b2 f1			.pastdmark: pop af  
47b3			endm  
# End of macro DMARK
47b3						CALLMONITOR 
47b3 cd a6 fd			call debug_vector  
47b6				endm  
# End of macro CALLMONITOR
47b6					endif 
47b6 3e 0d				ld a, 13 
47b8 32 ef f0				ld (scratch),a 
47bb 3e 0a				ld a, 10 
47bd 32 f0 f0				ld (scratch+1),a 
47c0 3e 00				ld a, 0 
47c2 32 f1 f0				ld (scratch+2),a 
47c5 21 ef f0				ld hl, scratch 
47c8 cd 7c 20				call forth_push_str 
47cb					 
47cb				       NEXTW 
47cb cd a3 fd			call parse_vector 
47ce c3 f5 23			jp macro_next 
47d1				endm 
# End of macro NEXTW
47d1			.SPACE: 
47d1				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
47d1 46				db WORD_SYS_CORE+50             
47d2 0a 48			dw .SPACES            
47d4 03				db 2 + 1 
47d5 .. 00			db "BL",0              
47d8				endm 
# End of macro CWHEAD
47d8			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
47d8					if DEBUG_FORTH_WORDS_KEY 
47d8						DMARK "BL." 
47d8 f5				push af  
47d9 3a ed 47			ld a, (.dmark)  
47dc 32 99 fd			ld (debug_mark),a  
47df 3a ee 47			ld a, (.dmark+1)  
47e2 32 9a fd			ld (debug_mark+1),a  
47e5 3a ef 47			ld a, (.dmark+2)  
47e8 32 9b fd			ld (debug_mark+2),a  
47eb 18 03			jr .pastdmark  
47ed ..			.dmark: db "BL."  
47f0 f1			.pastdmark: pop af  
47f1			endm  
# End of macro DMARK
47f1						CALLMONITOR 
47f1 cd a6 fd			call debug_vector  
47f4				endm  
# End of macro CALLMONITOR
47f4					endif 
47f4 3e 20				ld a, " " 
47f6 32 ef f0				ld (scratch),a 
47f9 3e 00				ld a, 0 
47fb 32 f0 f0				ld (scratch+1),a 
47fe 21 ef f0				ld hl, scratch 
4801 cd 7c 20				call forth_push_str 
4804					 
4804				       NEXTW 
4804 cd a3 fd			call parse_vector 
4807 c3 f5 23			jp macro_next 
480a				endm 
# End of macro NEXTW
480a			 
480a			;.blstr: db " ", 0 
480a			 
480a			.SPACES: 
480a				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
480a 47				db WORD_SYS_CORE+51             
480b a6 48			dw .SCROLL            
480d 07				db 6 + 1 
480e .. 00			db "SPACES",0              
4815				endm 
# End of macro CWHEAD
4815			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4815					if DEBUG_FORTH_WORDS_KEY 
4815						DMARK "SPS" 
4815 f5				push af  
4816 3a 2a 48			ld a, (.dmark)  
4819 32 99 fd			ld (debug_mark),a  
481c 3a 2b 48			ld a, (.dmark+1)  
481f 32 9a fd			ld (debug_mark+1),a  
4822 3a 2c 48			ld a, (.dmark+2)  
4825 32 9b fd			ld (debug_mark+2),a  
4828 18 03			jr .pastdmark  
482a ..			.dmark: db "SPS"  
482d f1			.pastdmark: pop af  
482e			endm  
# End of macro DMARK
482e						CALLMONITOR 
482e cd a6 fd			call debug_vector  
4831				endm  
# End of macro CALLMONITOR
4831					endif 
4831			 
4831			 
4831					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4831 cd 0e 22			call macro_dsp_valuehl 
4834				endm 
# End of macro FORTH_DSP_VALUEHL
4834			 
4834 e5					push hl    ; u 
4835					if DEBUG_FORTH_WORDS 
4835						DMARK "SPA" 
4835 f5				push af  
4836 3a 4a 48			ld a, (.dmark)  
4839 32 99 fd			ld (debug_mark),a  
483c 3a 4b 48			ld a, (.dmark+1)  
483f 32 9a fd			ld (debug_mark+1),a  
4842 3a 4c 48			ld a, (.dmark+2)  
4845 32 9b fd			ld (debug_mark+2),a  
4848 18 03			jr .pastdmark  
484a ..			.dmark: db "SPA"  
484d f1			.pastdmark: pop af  
484e			endm  
# End of macro DMARK
484e						CALLMONITOR 
484e cd a6 fd			call debug_vector  
4851				endm  
# End of macro CALLMONITOR
4851					endif 
4851			 
4851					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4851 cd c6 22			call macro_forth_dsp_pop 
4854				endm 
# End of macro FORTH_DSP_POP
4854 e1					pop hl 
4855 0e 00				ld c, 0 
4857 45					ld b, l 
4858 21 ef f0				ld hl, scratch  
485b			 
485b					if DEBUG_FORTH_WORDS 
485b						DMARK "SP2" 
485b f5				push af  
485c 3a 70 48			ld a, (.dmark)  
485f 32 99 fd			ld (debug_mark),a  
4862 3a 71 48			ld a, (.dmark+1)  
4865 32 9a fd			ld (debug_mark+1),a  
4868 3a 72 48			ld a, (.dmark+2)  
486b 32 9b fd			ld (debug_mark+2),a  
486e 18 03			jr .pastdmark  
4870 ..			.dmark: db "SP2"  
4873 f1			.pastdmark: pop af  
4874			endm  
# End of macro DMARK
4874						CALLMONITOR 
4874 cd a6 fd			call debug_vector  
4877				endm  
# End of macro CALLMONITOR
4877					endif 
4877			;		ld a, ' ' 
4877			.spaces1:	 
4877 36 20				ld (hl),' ' 
4879 23					inc hl 
487a					 
487a 10 fb				djnz .spaces1 
487c			;		ld a,0 
487c 36 00				ld (hl),0 
487e 21 ef f0				ld hl, scratch 
4881					if DEBUG_FORTH_WORDS 
4881						DMARK "SP3" 
4881 f5				push af  
4882 3a 96 48			ld a, (.dmark)  
4885 32 99 fd			ld (debug_mark),a  
4888 3a 97 48			ld a, (.dmark+1)  
488b 32 9a fd			ld (debug_mark+1),a  
488e 3a 98 48			ld a, (.dmark+2)  
4891 32 9b fd			ld (debug_mark+2),a  
4894 18 03			jr .pastdmark  
4896 ..			.dmark: db "SP3"  
4899 f1			.pastdmark: pop af  
489a			endm  
# End of macro DMARK
489a						CALLMONITOR 
489a cd a6 fd			call debug_vector  
489d				endm  
# End of macro CALLMONITOR
489d					endif 
489d cd 7c 20				call forth_push_str 
48a0			 
48a0				       NEXTW 
48a0 cd a3 fd			call parse_vector 
48a3 c3 f5 23			jp macro_next 
48a6				endm 
# End of macro NEXTW
48a6			 
48a6			 
48a6			 
48a6			.SCROLL: 
48a6				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
48a6 53				db WORD_SYS_CORE+63             
48a7 d6 48			dw .SCROLLD            
48a9 07				db 6 + 1 
48aa .. 00			db "SCROLL",0              
48b1				endm 
# End of macro CWHEAD
48b1			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
48b1					if DEBUG_FORTH_WORDS_KEY 
48b1						DMARK "SCR" 
48b1 f5				push af  
48b2 3a c6 48			ld a, (.dmark)  
48b5 32 99 fd			ld (debug_mark),a  
48b8 3a c7 48			ld a, (.dmark+1)  
48bb 32 9a fd			ld (debug_mark+1),a  
48be 3a c8 48			ld a, (.dmark+2)  
48c1 32 9b fd			ld (debug_mark+2),a  
48c4 18 03			jr .pastdmark  
48c6 ..			.dmark: db "SCR"  
48c9 f1			.pastdmark: pop af  
48ca			endm  
# End of macro DMARK
48ca						CALLMONITOR 
48ca cd a6 fd			call debug_vector  
48cd				endm  
# End of macro CALLMONITOR
48cd					endif 
48cd			 
48cd cd 44 0d			call scroll_up 
48d0			;	call update_display 
48d0			 
48d0					NEXTW 
48d0 cd a3 fd			call parse_vector 
48d3 c3 f5 23			jp macro_next 
48d6				endm 
# End of macro NEXTW
48d6			 
48d6			 
48d6			 
48d6			;		; get dir 
48d6			; 
48d6			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48d6			; 
48d6			;		push hl 
48d6			; 
48d6			;		; destroy value TOS 
48d6			; 
48d6			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48d6			; 
48d6			;		; get count 
48d6			; 
48d6			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48d6			; 
48d6			;		push hl 
48d6			; 
48d6			;		; destroy value TOS 
48d6			; 
48d6			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48d6			; 
48d6			;		; one value on hl get other one back 
48d6			; 
48d6			;		pop bc    ; count 
48d6			; 
48d6			;		pop de   ; dir 
48d6			; 
48d6			; 
48d6			;		ld b, c 
48d6			; 
48d6			;.scrolldir:     push bc 
48d6			;		push de 
48d6			; 
48d6			;		ld a, 0 
48d6			;		cp e 
48d6			;		jr z, .scrollup  
48d6			;		call scroll_down 
48d6			;		jr .scrollnext 
48d6			;.scrollup:	call scroll_up 
48d6			; 
48d6			;		 
48d6			;.scrollnext: 
48d6			;		pop de 
48d6			;		pop bc 
48d6			;		djnz .scrolldir 
48d6			; 
48d6			; 
48d6			; 
48d6			; 
48d6			; 
48d6			;		NEXTW 
48d6			 
48d6			.SCROLLD: 
48d6				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
48d6 53				db WORD_SYS_CORE+63             
48d7 07 49			dw .ATQ            
48d9 08				db 7 + 1 
48da .. 00			db "SCROLLD",0              
48e2				endm 
# End of macro CWHEAD
48e2			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
48e2					if DEBUG_FORTH_WORDS_KEY 
48e2						DMARK "SCD" 
48e2 f5				push af  
48e3 3a f7 48			ld a, (.dmark)  
48e6 32 99 fd			ld (debug_mark),a  
48e9 3a f8 48			ld a, (.dmark+1)  
48ec 32 9a fd			ld (debug_mark+1),a  
48ef 3a f9 48			ld a, (.dmark+2)  
48f2 32 9b fd			ld (debug_mark+2),a  
48f5 18 03			jr .pastdmark  
48f7 ..			.dmark: db "SCD"  
48fa f1			.pastdmark: pop af  
48fb			endm  
# End of macro DMARK
48fb						CALLMONITOR 
48fb cd a6 fd			call debug_vector  
48fe				endm  
# End of macro CALLMONITOR
48fe					endif 
48fe			 
48fe cd 67 0d			call scroll_down 
4901			;	call update_display 
4901			 
4901					NEXTW 
4901 cd a3 fd			call parse_vector 
4904 c3 f5 23			jp macro_next 
4907				endm 
# End of macro NEXTW
4907			 
4907			 
4907			.ATQ: 
4907				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4907 62				db WORD_SYS_CORE+78             
4908 68 49			dw .AUTODSP            
490a 04				db 3 + 1 
490b .. 00			db "AT@",0              
490f				endm 
# End of macro CWHEAD
490f			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
490f					if DEBUG_FORTH_WORDS_KEY 
490f						DMARK "ATA" 
490f f5				push af  
4910 3a 24 49			ld a, (.dmark)  
4913 32 99 fd			ld (debug_mark),a  
4916 3a 25 49			ld a, (.dmark+1)  
4919 32 9a fd			ld (debug_mark+1),a  
491c 3a 26 49			ld a, (.dmark+2)  
491f 32 9b fd			ld (debug_mark+2),a  
4922 18 03			jr .pastdmark  
4924 ..			.dmark: db "ATA"  
4927 f1			.pastdmark: pop af  
4928			endm  
# End of macro DMARK
4928						CALLMONITOR 
4928 cd a6 fd			call debug_vector  
492b				endm  
# End of macro CALLMONITOR
492b					endif 
492b			 
492b			 
492b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
492b cd 0e 22			call macro_dsp_valuehl 
492e				endm 
# End of macro FORTH_DSP_VALUEHL
492e			 
492e					; TODO save cursor row 
492e 7d					ld a,l 
492f fe 02				cp 2 
4931 20 04				jr nz, .crow3aq 
4933 3e 28				ld a, display_row_2 
4935 18 12				jr .ccol1aq 
4937 fe 03		.crow3aq:		cp 3 
4939 20 04				jr nz, .crow4aq 
493b 3e 50				ld a, display_row_3 
493d 18 0a				jr .ccol1aq 
493f fe 04		.crow4aq:		cp 4 
4941 20 04				jr nz, .crow1aq 
4943 3e 78				ld a, display_row_4 
4945 18 02				jr .ccol1aq 
4947 3e 00		.crow1aq:		ld a,display_row_1 
4949 f5			.ccol1aq:		push af			; got row offset 
494a 6f					ld l,a 
494b 26 00				ld h,0 
494d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
494d cd c6 22			call macro_forth_dsp_pop 
4950				endm 
# End of macro FORTH_DSP_POP
4950					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4950 cd 0e 22			call macro_dsp_valuehl 
4953				endm 
# End of macro FORTH_DSP_VALUEHL
4953					; TODO save cursor col 
4953 f1					pop af 
4954 85					add l		; add col offset 
4955			 
4955					; add current frame buffer address 
4955 2a fa fa				ld hl, (display_fb_active) 
4958 cd b1 0f				call addatohl 
495b			 
495b			 
495b			 
495b			 
495b					; get char frame buffer location offset in hl 
495b			 
495b 7e					ld a,(hl) 
495c 26 00				ld h, 0 
495e 6f					ld l, a 
495f			 
495f cd 12 20				call forth_push_numhl 
4962			 
4962			 
4962					NEXTW 
4962 cd a3 fd			call parse_vector 
4965 c3 f5 23			jp macro_next 
4968				endm 
# End of macro NEXTW
4968			 
4968			.AUTODSP: 
4968				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4968 63				db WORD_SYS_CORE+79             
4969 81 49			dw .MENU            
496b 05				db 4 + 1 
496c .. 00			db "ADSP",0              
4971				endm 
# End of macro CWHEAD
4971			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4971			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4971			 
4971					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4971 cd 0e 22			call macro_dsp_valuehl 
4974				endm 
# End of macro FORTH_DSP_VALUEHL
4974			 
4974			;		push hl 
4974			 
4974					; destroy value TOS 
4974			 
4974					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4974 cd c6 22			call macro_forth_dsp_pop 
4977				endm 
# End of macro FORTH_DSP_POP
4977			 
4977			;		pop hl 
4977			 
4977 7d					ld a,l 
4978 32 6a f9				ld (cli_autodisplay), a 
497b				       NEXTW 
497b cd a3 fd			call parse_vector 
497e c3 f5 23			jp macro_next 
4981				endm 
# End of macro NEXTW
4981			 
4981			.MENU: 
4981				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4981 70				db WORD_SYS_CORE+92             
4982 2d 4a			dw .ENDDISPLAY            
4984 05				db 4 + 1 
4985 .. 00			db "MENU",0              
498a				endm 
# End of macro CWHEAD
498a			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
498a			 
498a			;		; get number of items on the stack 
498a			; 
498a				 
498a					FORTH_DSP_VALUEHL 
498a cd 0e 22			call macro_dsp_valuehl 
498d				endm 
# End of macro FORTH_DSP_VALUEHL
498d				 
498d					if DEBUG_FORTH_WORDS_KEY 
498d						DMARK "MNU" 
498d f5				push af  
498e 3a a2 49			ld a, (.dmark)  
4991 32 99 fd			ld (debug_mark),a  
4994 3a a3 49			ld a, (.dmark+1)  
4997 32 9a fd			ld (debug_mark+1),a  
499a 3a a4 49			ld a, (.dmark+2)  
499d 32 9b fd			ld (debug_mark+2),a  
49a0 18 03			jr .pastdmark  
49a2 ..			.dmark: db "MNU"  
49a5 f1			.pastdmark: pop af  
49a6			endm  
# End of macro DMARK
49a6						CALLMONITOR 
49a6 cd a6 fd			call debug_vector  
49a9				endm  
# End of macro CALLMONITOR
49a9					endif 
49a9			 
49a9 45					ld b, l	 
49aa 05					dec b 
49ab			 
49ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49ab cd c6 22			call macro_forth_dsp_pop 
49ae				endm 
# End of macro FORTH_DSP_POP
49ae			 
49ae			 
49ae					; go directly through the stack to pluck out the string pointers and build an array 
49ae			 
49ae			;		FORTH_DSP 
49ae			 
49ae					; hl contains top most stack item 
49ae				 
49ae 11 ef f0				ld de, scratch 
49b1			 
49b1			.mbuild: 
49b1			 
49b1					FORTH_DSP_VALUEHL 
49b1 cd 0e 22			call macro_dsp_valuehl 
49b4				endm 
# End of macro FORTH_DSP_VALUEHL
49b4			 
49b4					if DEBUG_FORTH_WORDS 
49b4						DMARK "MN3" 
49b4 f5				push af  
49b5 3a c9 49			ld a, (.dmark)  
49b8 32 99 fd			ld (debug_mark),a  
49bb 3a ca 49			ld a, (.dmark+1)  
49be 32 9a fd			ld (debug_mark+1),a  
49c1 3a cb 49			ld a, (.dmark+2)  
49c4 32 9b fd			ld (debug_mark+2),a  
49c7 18 03			jr .pastdmark  
49c9 ..			.dmark: db "MN3"  
49cc f1			.pastdmark: pop af  
49cd			endm  
# End of macro DMARK
49cd						CALLMONITOR 
49cd cd a6 fd			call debug_vector  
49d0				endm  
# End of macro CALLMONITOR
49d0					endif 
49d0 eb					ex de, hl 
49d1 73					ld (hl), e 
49d2 23					inc hl 
49d3 72					ld (hl), d 
49d4 23					inc hl 
49d5 eb					ex de, hl 
49d6			 
49d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49d6 cd c6 22			call macro_forth_dsp_pop 
49d9				endm 
# End of macro FORTH_DSP_POP
49d9			 
49d9 10 d6				djnz .mbuild 
49db			 
49db					; done add term 
49db			 
49db eb					ex de, hl 
49dc 36 00				ld (hl), 0 
49de 23					inc hl 
49df 36 00				ld (hl), 0 
49e1			 
49e1				 
49e1					 
49e1 21 ef f0				ld hl, scratch 
49e4			 
49e4					if DEBUG_FORTH_WORDS 
49e4						DMARK "MNx" 
49e4 f5				push af  
49e5 3a f9 49			ld a, (.dmark)  
49e8 32 99 fd			ld (debug_mark),a  
49eb 3a fa 49			ld a, (.dmark+1)  
49ee 32 9a fd			ld (debug_mark+1),a  
49f1 3a fb 49			ld a, (.dmark+2)  
49f4 32 9b fd			ld (debug_mark+2),a  
49f7 18 03			jr .pastdmark  
49f9 ..			.dmark: db "MNx"  
49fc f1			.pastdmark: pop af  
49fd			endm  
# End of macro DMARK
49fd						CALLMONITOR 
49fd cd a6 fd			call debug_vector  
4a00				endm  
# End of macro CALLMONITOR
4a00					endif 
4a00			 
4a00			 
4a00			 
4a00 3e 00				ld a, 0 
4a02 cd b1 0d				call menu 
4a05			 
4a05			 
4a05 6f					ld l, a 
4a06 26 00				ld h, 0 
4a08			 
4a08					if DEBUG_FORTH_WORDS 
4a08						DMARK "MNr" 
4a08 f5				push af  
4a09 3a 1d 4a			ld a, (.dmark)  
4a0c 32 99 fd			ld (debug_mark),a  
4a0f 3a 1e 4a			ld a, (.dmark+1)  
4a12 32 9a fd			ld (debug_mark+1),a  
4a15 3a 1f 4a			ld a, (.dmark+2)  
4a18 32 9b fd			ld (debug_mark+2),a  
4a1b 18 03			jr .pastdmark  
4a1d ..			.dmark: db "MNr"  
4a20 f1			.pastdmark: pop af  
4a21			endm  
# End of macro DMARK
4a21						CALLMONITOR 
4a21 cd a6 fd			call debug_vector  
4a24				endm  
# End of macro CALLMONITOR
4a24					endif 
4a24			 
4a24 cd 12 20				call forth_push_numhl 
4a27			 
4a27			 
4a27			 
4a27			 
4a27				       NEXTW 
4a27 cd a3 fd			call parse_vector 
4a2a c3 f5 23			jp macro_next 
4a2d				endm 
# End of macro NEXTW
4a2d			 
4a2d			 
4a2d			.ENDDISPLAY: 
4a2d			 
4a2d			; eof 
# End of file forth_words_display.asm
4a2d			include "forth_words_str.asm" 
4a2d			 
4a2d			; | ## String Words 
4a2d			 
4a2d			.CONST: 
4a2d				 
4a2d				CWHEAD .MOVE 52 "CONST" 5 WORD_FLAG_CODE 
4a2d 48				db WORD_SYS_CORE+52             
4a2e 42 4a			dw .MOVE            
4a30 06				db 5 + 1 
4a31 .. 00			db "CONST",0              
4a37				endm 
# End of macro CWHEAD
4a37			; | CONST ( u -- u ) Change the type of var on TOS to a constant. i.e. if a string it won't be freed on consuption, | TODO 
4a37					FORTH_DSP 
4a37 cd d4 21			call macro_forth_dsp 
4a3a				endm 
# End of macro FORTH_DSP
4a3a 36 04				ld (hl), DS_TYPE_CONST 
4a3c					NEXTW 
4a3c cd a3 fd			call parse_vector 
4a3f c3 f5 23			jp macro_next 
4a42				endm 
# End of macro NEXTW
4a42			 
4a42			.MOVE:   
4a42			 
4a42				CWHEAD .ZMOVE 52 "MOVE" 4 WORD_FLAG_CODE 
4a42 48				db WORD_SYS_CORE+52             
4a43 69 4a			dw .ZMOVE            
4a45 05				db 4 + 1 
4a46 .. 00			db "MOVE",0              
4a4b				endm 
# End of macro CWHEAD
4a4b			; | MOVE ( a1 a2 c -- ) Copy from address a1 to address a2 for the length of c | DONE 
4a4b			 
4a4b					FORTH_DSP_VALUEHL 
4a4b cd 0e 22			call macro_dsp_valuehl 
4a4e				endm 
# End of macro FORTH_DSP_VALUEHL
4a4e e5					push hl    ; push count 
4a4f			 
4a4f					FORTH_DSP_POP 
4a4f cd c6 22			call macro_forth_dsp_pop 
4a52				endm 
# End of macro FORTH_DSP_POP
4a52			 
4a52					FORTH_DSP_VALUEHL 
4a52 cd 0e 22			call macro_dsp_valuehl 
4a55				endm 
# End of macro FORTH_DSP_VALUEHL
4a55 e5					push hl    ; dest 
4a56			 
4a56					FORTH_DSP_POP 
4a56 cd c6 22			call macro_forth_dsp_pop 
4a59				endm 
# End of macro FORTH_DSP_POP
4a59			 
4a59					FORTH_DSP_VALUEHL 
4a59 cd 0e 22			call macro_dsp_valuehl 
4a5c				endm 
# End of macro FORTH_DSP_VALUEHL
4a5c			 
4a5c					FORTH_DSP_POP 
4a5c cd c6 22			call macro_forth_dsp_pop 
4a5f				endm 
# End of macro FORTH_DSP_POP
4a5f			 
4a5f d1					pop de 
4a60 c1					pop bc 
4a61				 
4a61 ed b0				ldir 
4a63				NEXTW 
4a63 cd a3 fd			call parse_vector 
4a66 c3 f5 23			jp macro_next 
4a69				endm 
# End of macro NEXTW
4a69			.ZMOVE:   
4a69			 
4a69				CWHEAD .TABLE 52 "ZMOVE" 5 WORD_FLAG_CODE 
4a69 48				db WORD_SYS_CORE+52             
4a6a 92 4a			dw .TABLE            
4a6c 06				db 5 + 1 
4a6d .. 00			db "ZMOVE",0              
4a73				endm 
# End of macro CWHEAD
4a73					 
4a73			; | ZMOVE ( a1 a2 -- ) Copy from address a1 to address a2 until a1 hits zero term string | DONE 
4a73			; | | Ensure you have enough space! 
4a73			 
4a73			 
4a73					FORTH_DSP_VALUEHL 
4a73 cd 0e 22			call macro_dsp_valuehl 
4a76				endm 
# End of macro FORTH_DSP_VALUEHL
4a76 e5					push hl    ; dest 
4a77			 
4a77					FORTH_DSP_POP 
4a77 cd c6 22			call macro_forth_dsp_pop 
4a7a				endm 
# End of macro FORTH_DSP_POP
4a7a			 
4a7a					FORTH_DSP_VALUEHL 
4a7a cd 0e 22			call macro_dsp_valuehl 
4a7d				endm 
# End of macro FORTH_DSP_VALUEHL
4a7d			 
4a7d					FORTH_DSP_POP 
4a7d cd c6 22			call macro_forth_dsp_pop 
4a80				endm 
# End of macro FORTH_DSP_POP
4a80			 
4a80 d1					pop de 
4a81			 
4a81 01 ff 00				ld bc, 255 
4a84 ed a0		.zmovel:	ldi 
4a86 2b					dec hl 
4a87 7e					ld a,(hl) 
4a88 23					inc hl 
4a89 b7					or a  
4a8a 20 f8				jr nz, .zmovel    
4a8c					 
4a8c			 
4a8c				NEXTW 
4a8c cd a3 fd			call parse_vector 
4a8f c3 f5 23			jp macro_next 
4a92				endm 
# End of macro NEXTW
4a92			 
4a92			.TABLE:   
4a92			 
4a92				CWHEAD .SPLIT 52 "TABLE" 5 WORD_FLAG_CODE 
4a92 48				db WORD_SYS_CORE+52             
4a93 f7 4a			dw .SPLIT            
4a95 06				db 5 + 1 
4a96 .. 00			db "TABLE",0              
4a9c				endm 
# End of macro CWHEAD
4a9c					 
4a9c			; | TABLE ( s .. sx c -- a) For the number c of strings s on the stack. Generate a look up table array a | DONE 
4a9c			; | | Takes a list of strings and creates a block of pointers to each string which can then be used 
4a9c			; | | in any kind of lookup or iteration.  
4a9c			; | | Last item in the array will be a zero pointer for ease of iteration 
4a9c			 
4a9c			 
4a9c				; get the count of strings 
4a9c			 
4a9c					FORTH_DSP_VALUEHL 
4a9c cd 0e 22			call macro_dsp_valuehl 
4a9f				endm 
# End of macro FORTH_DSP_VALUEHL
4a9f			 
4a9f					FORTH_DSP_POP 
4a9f cd c6 22			call macro_forth_dsp_pop 
4aa2				endm 
# End of macro FORTH_DSP_POP
4aa2			 
4aa2				; allocate memory for (count + 1 ) * 2 for word array plus zero pointer 
4aa2			 
4aa2					; l contains count 
4aa2			 
4aa2 7d					ld a,l 
4aa3 32 ef f0				ld (scratch), a     ; save it for the loading loop 
4aa6			 
4aa6 2c					inc l  ; for zero pointer 
4aa7 eb					ex de, hl 
4aa8 3e 02				ld a, 2 
4aaa cd 34 0f				call Mult16 
4aad			 
4aad					; hl is the size of block to allocate 
4aad			 
4aad cd 7d 13				call malloc 
4ab0				if DEBUG_FORTH_MALLOC_GUARD 
4ab0 cc 3c 66				call z,malloc_error 
4ab3				endif 
4ab3					; hl is the pointer to the array block 
4ab3						 
4ab3 22 f0 f0				ld (scratch+1), hl    ; save the base for later push to stack 
4ab6 22 f2 f0				ld (scratch+3), hl    ; save the base for current string to push 
4ab9			 
4ab9 3a ef f0				ld a, (scratch) 
4abc 47					ld b, a 
4abd			 
4abd				; for each string 
4abd			 
4abd			.tablelop: 
4abd			 
4abd c5					push bc 
4abe			 
4abe				;     get string pointer 
4abe			 
4abe					FORTH_DSP_VALUEHL 
4abe cd 0e 22			call macro_dsp_valuehl 
4ac1				endm 
# End of macro FORTH_DSP_VALUEHL
4ac1			 
4ac1 e5					push hl 
4ac2			 
4ac2				;     get string length 
4ac2			 
4ac2 3e 00				ld a,0 
4ac4 cd 14 13				call strlent 
4ac7			 
4ac7 23					inc hl 
4ac8 e5					push hl 
4ac9			 
4ac9				;     allocate string length 
4ac9			 
4ac9 cd 7d 13				call malloc 
4acc			 
4acc			        ;     copy string to block 
4acc			 
4acc c1					pop bc 
4acd eb					ex de, hl 
4ace e1					pop hl 
4acf d5					push de 
4ad0			 
4ad0 ed b0				ldir 
4ad2			 
4ad2			 
4ad2			        ;     add pointer to string to array block 
4ad2			 
4ad2 2a f2 f0				ld hl, (scratch+3)    ; save the base for current string to push 
4ad5			 
4ad5 d1					pop de     ; the pointer to the newly copied string to add to the array 
4ad6 73					ld (hl), e 
4ad7 23					inc hl 
4ad8 72					ld (hl), d	 
4ad9 23					inc hl 
4ada				 
4ada 22 f2 f0				ld (scratch+3), hl    ; save the base for current string to push 
4add			 
4add					FORTH_DSP_POP 
4add cd c6 22			call macro_forth_dsp_pop 
4ae0				endm 
# End of macro FORTH_DSP_POP
4ae0			 
4ae0 c1					pop bc 
4ae1 10 da				djnz .tablelop 
4ae3			 
4ae3			        ;  push array block pointer 
4ae3			 
4ae3 2a f2 f0				ld hl, (scratch+3)    ; save the base for current string to push 
4ae6 36 00				ld (hl), 0 
4ae8 23					inc hl 
4ae9 36 00				ld (hl), 0 
4aeb			 
4aeb			 
4aeb				 
4aeb 2a f0 f0				ld hl, (scratch+1)    ; save the base for current string to push 
4aee cd 12 20				call forth_push_numhl 
4af1			 
4af1				NEXTW 
4af1 cd a3 fd			call parse_vector 
4af4 c3 f5 23			jp macro_next 
4af7				endm 
# End of macro NEXTW
4af7			 
4af7			.SPLIT:   
4af7			 
4af7				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
4af7 48				db WORD_SYS_CORE+52             
4af8 ee 4b			dw .PTR            
4afa 06				db 5 + 1 
4afb .. 00			db "SPLIT",0              
4b01				endm 
# End of macro CWHEAD
4b01			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
4b01					if DEBUG_FORTH_WORDS_KEY 
4b01						DMARK "SPT" 
4b01 f5				push af  
4b02 3a 16 4b			ld a, (.dmark)  
4b05 32 99 fd			ld (debug_mark),a  
4b08 3a 17 4b			ld a, (.dmark+1)  
4b0b 32 9a fd			ld (debug_mark+1),a  
4b0e 3a 18 4b			ld a, (.dmark+2)  
4b11 32 9b fd			ld (debug_mark+2),a  
4b14 18 03			jr .pastdmark  
4b16 ..			.dmark: db "SPT"  
4b19 f1			.pastdmark: pop af  
4b1a			endm  
# End of macro DMARK
4b1a						CALLMONITOR 
4b1a cd a6 fd			call debug_vector  
4b1d				endm  
# End of macro CALLMONITOR
4b1d					endif 
4b1d			 
4b1d					; get delim 
4b1d					FORTH_DSP_VALUEHL 
4b1d cd 0e 22			call macro_dsp_valuehl 
4b20				endm 
# End of macro FORTH_DSP_VALUEHL
4b20			 
4b20					FORTH_DSP_POP 
4b20 cd c6 22			call macro_forth_dsp_pop 
4b23				endm 
# End of macro FORTH_DSP_POP
4b23					 
4b23			 
4b23 45					ld b, l    ; move delim to b 
4b24 0e 01				ld c, 1   ; count of poritions 
4b26			 
4b26 c5					push bc 
4b27			 
4b27					if DEBUG_FORTH_WORDS 
4b27						DMARK "SPa" 
4b27 f5				push af  
4b28 3a 3c 4b			ld a, (.dmark)  
4b2b 32 99 fd			ld (debug_mark),a  
4b2e 3a 3d 4b			ld a, (.dmark+1)  
4b31 32 9a fd			ld (debug_mark+1),a  
4b34 3a 3e 4b			ld a, (.dmark+2)  
4b37 32 9b fd			ld (debug_mark+2),a  
4b3a 18 03			jr .pastdmark  
4b3c ..			.dmark: db "SPa"  
4b3f f1			.pastdmark: pop af  
4b40			endm  
# End of macro DMARK
4b40						CALLMONITOR 
4b40 cd a6 fd			call debug_vector  
4b43				endm  
# End of macro CALLMONITOR
4b43					endif 
4b43					; get pointer to string to chop up 
4b43					FORTH_DSP_VALUEHL 
4b43 cd 0e 22			call macro_dsp_valuehl 
4b46				endm 
# End of macro FORTH_DSP_VALUEHL
4b46			 
4b46			;		push hl 
4b46 11 ef f0				ld de, scratch 
4b49			.spllop: 
4b49 c1					pop bc 
4b4a c5					push bc 
4b4b			;		pop hl 
4b4b					if DEBUG_FORTH_WORDS 
4b4b						DMARK "SPl" 
4b4b f5				push af  
4b4c 3a 60 4b			ld a, (.dmark)  
4b4f 32 99 fd			ld (debug_mark),a  
4b52 3a 61 4b			ld a, (.dmark+1)  
4b55 32 9a fd			ld (debug_mark+1),a  
4b58 3a 62 4b			ld a, (.dmark+2)  
4b5b 32 9b fd			ld (debug_mark+2),a  
4b5e 18 03			jr .pastdmark  
4b60 ..			.dmark: db "SPl"  
4b63 f1			.pastdmark: pop af  
4b64			endm  
# End of macro DMARK
4b64						CALLMONITOR 
4b64 cd a6 fd			call debug_vector  
4b67				endm  
# End of macro CALLMONITOR
4b67					endif 
4b67 7e					ld a, (hl) 
4b68 b8					cp b 
4b69 28 07				jr z, .splnxt 
4b6b			;		cp 0 
4b6b b7					or a 
4b6c 28 34				jr z, .splend 
4b6e ed a0				ldi 
4b70 18 d7				jr .spllop 
4b72			 
4b72					; hit dlim 
4b72			 
4b72			.splnxt: 
4b72					if DEBUG_FORTH_WORDS 
4b72						DMARK "SPx" 
4b72 f5				push af  
4b73 3a 87 4b			ld a, (.dmark)  
4b76 32 99 fd			ld (debug_mark),a  
4b79 3a 88 4b			ld a, (.dmark+1)  
4b7c 32 9a fd			ld (debug_mark+1),a  
4b7f 3a 89 4b			ld a, (.dmark+2)  
4b82 32 9b fd			ld (debug_mark+2),a  
4b85 18 03			jr .pastdmark  
4b87 ..			.dmark: db "SPx"  
4b8a f1			.pastdmark: pop af  
4b8b			endm  
# End of macro DMARK
4b8b						CALLMONITOR 
4b8b cd a6 fd			call debug_vector  
4b8e				endm  
# End of macro CALLMONITOR
4b8e					endif 
4b8e 3e 00				ld a, 0 
4b90 12					ld (de), a 
4b91					;ex de, hl 
4b91 e5					push hl 
4b92 21 ef f0				ld hl, scratch 
4b95 cd 7c 20				call forth_push_str 
4b98 e1					pop hl 
4b99					;ex de, hl 
4b99 23					inc hl 
4b9a c1					pop bc 
4b9b 0c					inc c 
4b9c c5					push bc 
4b9d 11 ef f0				ld de, scratch 
4ba0 18 a7				jr .spllop 
4ba2			 
4ba2			.splend:		 
4ba2					if DEBUG_FORTH_WORDS 
4ba2						DMARK "SPe" 
4ba2 f5				push af  
4ba3 3a b7 4b			ld a, (.dmark)  
4ba6 32 99 fd			ld (debug_mark),a  
4ba9 3a b8 4b			ld a, (.dmark+1)  
4bac 32 9a fd			ld (debug_mark+1),a  
4baf 3a b9 4b			ld a, (.dmark+2)  
4bb2 32 9b fd			ld (debug_mark+2),a  
4bb5 18 03			jr .pastdmark  
4bb7 ..			.dmark: db "SPe"  
4bba f1			.pastdmark: pop af  
4bbb			endm  
# End of macro DMARK
4bbb						CALLMONITOR 
4bbb cd a6 fd			call debug_vector  
4bbe				endm  
# End of macro CALLMONITOR
4bbe					endif 
4bbe 12					ld (de), a 
4bbf eb					ex de, hl 
4bc0			;		push hl 
4bc0 21 ef f0				ld hl, scratch 
4bc3 cd 7c 20				call forth_push_str 
4bc6					 
4bc6					if DEBUG_FORTH_WORDS 
4bc6						DMARK "SPc" 
4bc6 f5				push af  
4bc7 3a db 4b			ld a, (.dmark)  
4bca 32 99 fd			ld (debug_mark),a  
4bcd 3a dc 4b			ld a, (.dmark+1)  
4bd0 32 9a fd			ld (debug_mark+1),a  
4bd3 3a dd 4b			ld a, (.dmark+2)  
4bd6 32 9b fd			ld (debug_mark+2),a  
4bd9 18 03			jr .pastdmark  
4bdb ..			.dmark: db "SPc"  
4bde f1			.pastdmark: pop af  
4bdf			endm  
# End of macro DMARK
4bdf						CALLMONITOR 
4bdf cd a6 fd			call debug_vector  
4be2				endm  
# End of macro CALLMONITOR
4be2					endif 
4be2			 
4be2 e1					pop hl    ; get counter from bc which has been push 
4be3 26 00				ld h, 0 
4be5			;		ld l, c 
4be5 cd 12 20				call forth_push_numhl 
4be8			 
4be8			 
4be8				NEXTW 
4be8 cd a3 fd			call parse_vector 
4beb c3 f5 23			jp macro_next 
4bee				endm 
# End of macro NEXTW
4bee			.PTR:   
4bee			 
4bee				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4bee 48				db WORD_SYS_CORE+52             
4bef 1e 4c			dw .STYPE            
4bf1 04				db 3 + 1 
4bf2 .. 00			db "PTR",0              
4bf6				endm 
# End of macro CWHEAD
4bf6			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4bf6			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4bf6			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4bf6			 
4bf6					if DEBUG_FORTH_WORDS_KEY 
4bf6						DMARK "PTR" 
4bf6 f5				push af  
4bf7 3a 0b 4c			ld a, (.dmark)  
4bfa 32 99 fd			ld (debug_mark),a  
4bfd 3a 0c 4c			ld a, (.dmark+1)  
4c00 32 9a fd			ld (debug_mark+1),a  
4c03 3a 0d 4c			ld a, (.dmark+2)  
4c06 32 9b fd			ld (debug_mark+2),a  
4c09 18 03			jr .pastdmark  
4c0b ..			.dmark: db "PTR"  
4c0e f1			.pastdmark: pop af  
4c0f			endm  
# End of macro DMARK
4c0f						CALLMONITOR 
4c0f cd a6 fd			call debug_vector  
4c12				endm  
# End of macro CALLMONITOR
4c12					endif 
4c12					FORTH_DSP_VALUEHL 
4c12 cd 0e 22			call macro_dsp_valuehl 
4c15				endm 
# End of macro FORTH_DSP_VALUEHL
4c15 cd 12 20				call forth_push_numhl 
4c18			 
4c18			 
4c18					NEXTW 
4c18 cd a3 fd			call parse_vector 
4c1b c3 f5 23			jp macro_next 
4c1e				endm 
# End of macro NEXTW
4c1e			.STYPE: 
4c1e				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4c1e 48				db WORD_SYS_CORE+52             
4c1f 7b 4c			dw .UPPER            
4c21 06				db 5 + 1 
4c22 .. 00			db "STYPE",0              
4c28				endm 
# End of macro CWHEAD
4c28			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
4c28			; | | 's' string or 'i' integer or 'c' const 
4c28					if DEBUG_FORTH_WORDS_KEY 
4c28						DMARK "STY" 
4c28 f5				push af  
4c29 3a 3d 4c			ld a, (.dmark)  
4c2c 32 99 fd			ld (debug_mark),a  
4c2f 3a 3e 4c			ld a, (.dmark+1)  
4c32 32 9a fd			ld (debug_mark+1),a  
4c35 3a 3f 4c			ld a, (.dmark+2)  
4c38 32 9b fd			ld (debug_mark+2),a  
4c3b 18 03			jr .pastdmark  
4c3d ..			.dmark: db "STY"  
4c40 f1			.pastdmark: pop af  
4c41			endm  
# End of macro DMARK
4c41						CALLMONITOR 
4c41 cd a6 fd			call debug_vector  
4c44				endm  
# End of macro CALLMONITOR
4c44					endif 
4c44					FORTH_DSP 
4c44 cd d4 21			call macro_forth_dsp 
4c47				endm 
# End of macro FORTH_DSP
4c47					;v5 FORTH_DSP_VALUE 
4c47			 
4c47 7e					ld a, (hl) 
4c48			 
4c48 f5					push af 
4c49			 
4c49			; Dont destroy TOS		FORTH_DSP_POP 
4c49			 
4c49 f1					pop af 
4c4a			 
4c4a fe 01				cp DS_TYPE_STR 
4c4c 28 12				jr z, .typestr 
4c4e fe 04				cp DS_TYPE_CONST 
4c50 28 09				jr z, .typeconst 
4c52			 
4c52 fe 02				cp DS_TYPE_INUM 
4c54 28 0f				jr z, .typeinum 
4c56			 
4c56 21 79 4c				ld hl, .tna 
4c59 18 0f				jr .tpush 
4c5b			 
4c5b 21 75 4c		.typeconst:	ld hl, .tconst 
4c5e 18 0a				jr .tpush 
4c60 21 73 4c		.typestr:	ld hl, .tstr 
4c63 18 05				jr .tpush 
4c65 21 77 4c		.typeinum:	ld hl, .tinum 
4c68 18 00				jr .tpush 
4c6a			 
4c6a			.tpush: 
4c6a			 
4c6a cd 7c 20				call forth_push_str 
4c6d			 
4c6d					NEXTW 
4c6d cd a3 fd			call parse_vector 
4c70 c3 f5 23			jp macro_next 
4c73				endm 
# End of macro NEXTW
4c73 .. 00		.tstr:	db "s",0 
4c75 .. 00		.tconst:	db "c",0 
4c77 .. 00		.tinum:  db "i",0 
4c79 .. 00		.tna:   db "?", 0 
4c7b			 
4c7b			 
4c7b			.UPPER: 
4c7b				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4c7b 48				db WORD_SYS_CORE+52             
4c7c b8 4c			dw .LOWER            
4c7e 06				db 5 + 1 
4c7f .. 00			db "UPPER",0              
4c85				endm 
# End of macro CWHEAD
4c85			; | UPPER ( s -- s ) Upper case string s  | DONE 
4c85					if DEBUG_FORTH_WORDS_KEY 
4c85						DMARK "UPR" 
4c85 f5				push af  
4c86 3a 9a 4c			ld a, (.dmark)  
4c89 32 99 fd			ld (debug_mark),a  
4c8c 3a 9b 4c			ld a, (.dmark+1)  
4c8f 32 9a fd			ld (debug_mark+1),a  
4c92 3a 9c 4c			ld a, (.dmark+2)  
4c95 32 9b fd			ld (debug_mark+2),a  
4c98 18 03			jr .pastdmark  
4c9a ..			.dmark: db "UPR"  
4c9d f1			.pastdmark: pop af  
4c9e			endm  
# End of macro DMARK
4c9e						CALLMONITOR 
4c9e cd a6 fd			call debug_vector  
4ca1				endm  
# End of macro CALLMONITOR
4ca1					endif 
4ca1			 
4ca1					FORTH_DSP 
4ca1 cd d4 21			call macro_forth_dsp 
4ca4				endm 
# End of macro FORTH_DSP
4ca4					 
4ca4			; TODO check is string type 
4ca4			 
4ca4					FORTH_DSP_VALUEHL 
4ca4 cd 0e 22			call macro_dsp_valuehl 
4ca7				endm 
# End of macro FORTH_DSP_VALUEHL
4ca7			; get pointer to string in hl 
4ca7			 
4ca7 7e			.toup:		ld a, (hl) 
4ca8			;		cp 0 
4ca8 b7					or a 
4ca9 28 07				jr z, .toupdone 
4cab			 
4cab cd 19 12				call to_upper 
4cae			 
4cae 77					ld (hl), a 
4caf 23					inc hl 
4cb0 18 f5				jr .toup 
4cb2			 
4cb2					 
4cb2			 
4cb2			 
4cb2			; for each char convert to upper 
4cb2					 
4cb2			.toupdone: 
4cb2			 
4cb2			 
4cb2					NEXTW 
4cb2 cd a3 fd			call parse_vector 
4cb5 c3 f5 23			jp macro_next 
4cb8				endm 
# End of macro NEXTW
4cb8			.LOWER: 
4cb8				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4cb8 48				db WORD_SYS_CORE+52             
4cb9 f5 4c			dw .TCASE            
4cbb 06				db 5 + 1 
4cbc .. 00			db "LOWER",0              
4cc2				endm 
# End of macro CWHEAD
4cc2			; | LOWER ( s -- s ) Lower case string s  | DONE 
4cc2					if DEBUG_FORTH_WORDS_KEY 
4cc2						DMARK "LWR" 
4cc2 f5				push af  
4cc3 3a d7 4c			ld a, (.dmark)  
4cc6 32 99 fd			ld (debug_mark),a  
4cc9 3a d8 4c			ld a, (.dmark+1)  
4ccc 32 9a fd			ld (debug_mark+1),a  
4ccf 3a d9 4c			ld a, (.dmark+2)  
4cd2 32 9b fd			ld (debug_mark+2),a  
4cd5 18 03			jr .pastdmark  
4cd7 ..			.dmark: db "LWR"  
4cda f1			.pastdmark: pop af  
4cdb			endm  
# End of macro DMARK
4cdb						CALLMONITOR 
4cdb cd a6 fd			call debug_vector  
4cde				endm  
# End of macro CALLMONITOR
4cde					endif 
4cde			 
4cde					FORTH_DSP 
4cde cd d4 21			call macro_forth_dsp 
4ce1				endm 
# End of macro FORTH_DSP
4ce1					 
4ce1			; TODO check is string type 
4ce1			 
4ce1					FORTH_DSP_VALUEHL 
4ce1 cd 0e 22			call macro_dsp_valuehl 
4ce4				endm 
# End of macro FORTH_DSP_VALUEHL
4ce4			; get pointer to string in hl 
4ce4			 
4ce4 7e			.tolow:		ld a, (hl) 
4ce5			;		cp 0 
4ce5 b7					or a 
4ce6 28 07				jr z, .tolowdone 
4ce8			 
4ce8 cd 22 12				call to_lower 
4ceb			 
4ceb 77					ld (hl), a 
4cec 23					inc hl 
4ced 18 f5				jr .tolow 
4cef			 
4cef					 
4cef			 
4cef			 
4cef			; for each char convert to low 
4cef					 
4cef			.tolowdone: 
4cef					NEXTW 
4cef cd a3 fd			call parse_vector 
4cf2 c3 f5 23			jp macro_next 
4cf5				endm 
# End of macro NEXTW
4cf5			.TCASE: 
4cf5				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4cf5 48				db WORD_SYS_CORE+52             
4cf6 2c 4e			dw .SUBSTR            
4cf8 06				db 5 + 1 
4cf9 .. 00			db "TCASE",0              
4cff				endm 
# End of macro CWHEAD
4cff			; | TCASE ( s -- s ) Title case string s  | DONE 
4cff					if DEBUG_FORTH_WORDS_KEY 
4cff						DMARK "TCS" 
4cff f5				push af  
4d00 3a 14 4d			ld a, (.dmark)  
4d03 32 99 fd			ld (debug_mark),a  
4d06 3a 15 4d			ld a, (.dmark+1)  
4d09 32 9a fd			ld (debug_mark+1),a  
4d0c 3a 16 4d			ld a, (.dmark+2)  
4d0f 32 9b fd			ld (debug_mark+2),a  
4d12 18 03			jr .pastdmark  
4d14 ..			.dmark: db "TCS"  
4d17 f1			.pastdmark: pop af  
4d18			endm  
# End of macro DMARK
4d18						CALLMONITOR 
4d18 cd a6 fd			call debug_vector  
4d1b				endm  
# End of macro CALLMONITOR
4d1b					endif 
4d1b			 
4d1b					FORTH_DSP 
4d1b cd d4 21			call macro_forth_dsp 
4d1e				endm 
# End of macro FORTH_DSP
4d1e					 
4d1e			; TODO check is string type 
4d1e			 
4d1e					FORTH_DSP_VALUEHL 
4d1e cd 0e 22			call macro_dsp_valuehl 
4d21				endm 
# End of macro FORTH_DSP_VALUEHL
4d21			; get pointer to string in hl 
4d21			 
4d21					if DEBUG_FORTH_WORDS 
4d21						DMARK "TC1" 
4d21 f5				push af  
4d22 3a 36 4d			ld a, (.dmark)  
4d25 32 99 fd			ld (debug_mark),a  
4d28 3a 37 4d			ld a, (.dmark+1)  
4d2b 32 9a fd			ld (debug_mark+1),a  
4d2e 3a 38 4d			ld a, (.dmark+2)  
4d31 32 9b fd			ld (debug_mark+2),a  
4d34 18 03			jr .pastdmark  
4d36 ..			.dmark: db "TC1"  
4d39 f1			.pastdmark: pop af  
4d3a			endm  
# End of macro DMARK
4d3a						CALLMONITOR 
4d3a cd a6 fd			call debug_vector  
4d3d				endm  
# End of macro CALLMONITOR
4d3d					endif 
4d3d			 
4d3d					; first time in turn to upper case first char 
4d3d			 
4d3d 7e					ld a, (hl) 
4d3e c3 c7 4d				jp .totsiptou 
4d41			 
4d41			 
4d41 7e			.tot:		ld a, (hl) 
4d42			;		cp 0 
4d42 b7					or a 
4d43 ca 0a 4e				jp z, .totdone 
4d46			 
4d46					if DEBUG_FORTH_WORDS 
4d46						DMARK "TC2" 
4d46 f5				push af  
4d47 3a 5b 4d			ld a, (.dmark)  
4d4a 32 99 fd			ld (debug_mark),a  
4d4d 3a 5c 4d			ld a, (.dmark+1)  
4d50 32 9a fd			ld (debug_mark+1),a  
4d53 3a 5d 4d			ld a, (.dmark+2)  
4d56 32 9b fd			ld (debug_mark+2),a  
4d59 18 03			jr .pastdmark  
4d5b ..			.dmark: db "TC2"  
4d5e f1			.pastdmark: pop af  
4d5f			endm  
# End of macro DMARK
4d5f						CALLMONITOR 
4d5f cd a6 fd			call debug_vector  
4d62				endm  
# End of macro CALLMONITOR
4d62					endif 
4d62					; check to see if current char is a space 
4d62			 
4d62 fe 20				cp ' ' 
4d64 28 21				jr z, .totsp 
4d66 cd 22 12				call to_lower 
4d69					if DEBUG_FORTH_WORDS 
4d69						DMARK "TC3" 
4d69 f5				push af  
4d6a 3a 7e 4d			ld a, (.dmark)  
4d6d 32 99 fd			ld (debug_mark),a  
4d70 3a 7f 4d			ld a, (.dmark+1)  
4d73 32 9a fd			ld (debug_mark+1),a  
4d76 3a 80 4d			ld a, (.dmark+2)  
4d79 32 9b fd			ld (debug_mark+2),a  
4d7c 18 03			jr .pastdmark  
4d7e ..			.dmark: db "TC3"  
4d81 f1			.pastdmark: pop af  
4d82			endm  
# End of macro DMARK
4d82						CALLMONITOR 
4d82 cd a6 fd			call debug_vector  
4d85				endm  
# End of macro CALLMONITOR
4d85					endif 
4d85 18 62				jr .totnxt 
4d87			 
4d87			.totsp:         ; on a space, find next char which should be upper 
4d87			 
4d87					if DEBUG_FORTH_WORDS 
4d87						DMARK "TC4" 
4d87 f5				push af  
4d88 3a 9c 4d			ld a, (.dmark)  
4d8b 32 99 fd			ld (debug_mark),a  
4d8e 3a 9d 4d			ld a, (.dmark+1)  
4d91 32 9a fd			ld (debug_mark+1),a  
4d94 3a 9e 4d			ld a, (.dmark+2)  
4d97 32 9b fd			ld (debug_mark+2),a  
4d9a 18 03			jr .pastdmark  
4d9c ..			.dmark: db "TC4"  
4d9f f1			.pastdmark: pop af  
4da0			endm  
# End of macro DMARK
4da0						CALLMONITOR 
4da0 cd a6 fd			call debug_vector  
4da3				endm  
# End of macro CALLMONITOR
4da3					endif 
4da3					;; 
4da3			 
4da3 fe 20				cp ' ' 
4da5 20 20				jr nz, .totsiptou 
4da7 23					inc hl 
4da8 7e					ld a, (hl) 
4da9					if DEBUG_FORTH_WORDS 
4da9						DMARK "TC5" 
4da9 f5				push af  
4daa 3a be 4d			ld a, (.dmark)  
4dad 32 99 fd			ld (debug_mark),a  
4db0 3a bf 4d			ld a, (.dmark+1)  
4db3 32 9a fd			ld (debug_mark+1),a  
4db6 3a c0 4d			ld a, (.dmark+2)  
4db9 32 9b fd			ld (debug_mark+2),a  
4dbc 18 03			jr .pastdmark  
4dbe ..			.dmark: db "TC5"  
4dc1 f1			.pastdmark: pop af  
4dc2			endm  
# End of macro DMARK
4dc2						CALLMONITOR 
4dc2 cd a6 fd			call debug_vector  
4dc5				endm  
# End of macro CALLMONITOR
4dc5					endif 
4dc5 18 c0				jr .totsp 
4dc7			.totsiptou:     
4dc7					;cp 0 
4dc7 b7					or a 
4dc8 28 40				jr z, .totdone 
4dca					; not space and not zero term so upper case it 
4dca cd 19 12				call to_upper 
4dcd			 
4dcd					if DEBUG_FORTH_WORDS 
4dcd						DMARK "TC6" 
4dcd f5				push af  
4dce 3a e2 4d			ld a, (.dmark)  
4dd1 32 99 fd			ld (debug_mark),a  
4dd4 3a e3 4d			ld a, (.dmark+1)  
4dd7 32 9a fd			ld (debug_mark+1),a  
4dda 3a e4 4d			ld a, (.dmark+2)  
4ddd 32 9b fd			ld (debug_mark+2),a  
4de0 18 03			jr .pastdmark  
4de2 ..			.dmark: db "TC6"  
4de5 f1			.pastdmark: pop af  
4de6			endm  
# End of macro DMARK
4de6						CALLMONITOR 
4de6 cd a6 fd			call debug_vector  
4de9				endm  
# End of macro CALLMONITOR
4de9					endif 
4de9			 
4de9			 
4de9			.totnxt: 
4de9			 
4de9 77					ld (hl), a 
4dea 23					inc hl 
4deb					if DEBUG_FORTH_WORDS 
4deb						DMARK "TC7" 
4deb f5				push af  
4dec 3a 00 4e			ld a, (.dmark)  
4def 32 99 fd			ld (debug_mark),a  
4df2 3a 01 4e			ld a, (.dmark+1)  
4df5 32 9a fd			ld (debug_mark+1),a  
4df8 3a 02 4e			ld a, (.dmark+2)  
4dfb 32 9b fd			ld (debug_mark+2),a  
4dfe 18 03			jr .pastdmark  
4e00 ..			.dmark: db "TC7"  
4e03 f1			.pastdmark: pop af  
4e04			endm  
# End of macro DMARK
4e04						CALLMONITOR 
4e04 cd a6 fd			call debug_vector  
4e07				endm  
# End of macro CALLMONITOR
4e07					endif 
4e07 c3 41 4d				jp .tot 
4e0a			 
4e0a					 
4e0a			 
4e0a			 
4e0a			; for each char convert to low 
4e0a					 
4e0a			.totdone: 
4e0a					if DEBUG_FORTH_WORDS 
4e0a						DMARK "TCd" 
4e0a f5				push af  
4e0b 3a 1f 4e			ld a, (.dmark)  
4e0e 32 99 fd			ld (debug_mark),a  
4e11 3a 20 4e			ld a, (.dmark+1)  
4e14 32 9a fd			ld (debug_mark+1),a  
4e17 3a 21 4e			ld a, (.dmark+2)  
4e1a 32 9b fd			ld (debug_mark+2),a  
4e1d 18 03			jr .pastdmark  
4e1f ..			.dmark: db "TCd"  
4e22 f1			.pastdmark: pop af  
4e23			endm  
# End of macro DMARK
4e23						CALLMONITOR 
4e23 cd a6 fd			call debug_vector  
4e26				endm  
# End of macro CALLMONITOR
4e26					endif 
4e26					NEXTW 
4e26 cd a3 fd			call parse_vector 
4e29 c3 f5 23			jp macro_next 
4e2c				endm 
# End of macro NEXTW
4e2c			 
4e2c			.SUBSTR: 
4e2c				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4e2c 48				db WORD_SYS_CORE+52             
4e2d 8c 4e			dw .LEFT            
4e2f 07				db 6 + 1 
4e30 .. 00			db "SUBSTR",0              
4e37				endm 
# End of macro CWHEAD
4e37			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4e37			 
4e37					if DEBUG_FORTH_WORDS_KEY 
4e37						DMARK "SST" 
4e37 f5				push af  
4e38 3a 4c 4e			ld a, (.dmark)  
4e3b 32 99 fd			ld (debug_mark),a  
4e3e 3a 4d 4e			ld a, (.dmark+1)  
4e41 32 9a fd			ld (debug_mark+1),a  
4e44 3a 4e 4e			ld a, (.dmark+2)  
4e47 32 9b fd			ld (debug_mark+2),a  
4e4a 18 03			jr .pastdmark  
4e4c ..			.dmark: db "SST"  
4e4f f1			.pastdmark: pop af  
4e50			endm  
# End of macro DMARK
4e50						CALLMONITOR 
4e50 cd a6 fd			call debug_vector  
4e53				endm  
# End of macro CALLMONITOR
4e53					endif 
4e53			; TODO check string type 
4e53					FORTH_DSP_VALUEHL 
4e53 cd 0e 22			call macro_dsp_valuehl 
4e56				endm 
# End of macro FORTH_DSP_VALUEHL
4e56			 
4e56 e5					push hl      ; string length 
4e57			 
4e57					FORTH_DSP_POP 
4e57 cd c6 22			call macro_forth_dsp_pop 
4e5a				endm 
# End of macro FORTH_DSP_POP
4e5a			 
4e5a					FORTH_DSP_VALUEHL 
4e5a cd 0e 22			call macro_dsp_valuehl 
4e5d				endm 
# End of macro FORTH_DSP_VALUEHL
4e5d			 
4e5d e5					push hl     ; start char 
4e5e			 
4e5e					FORTH_DSP_POP 
4e5e cd c6 22			call macro_forth_dsp_pop 
4e61				endm 
# End of macro FORTH_DSP_POP
4e61			 
4e61			 
4e61					FORTH_DSP_VALUE 
4e61 cd f7 21			call macro_forth_dsp_value 
4e64				endm 
# End of macro FORTH_DSP_VALUE
4e64			 
4e64 d1					pop de    ; get start post offset 
4e65			 
4e65 19					add hl, de    ; starting offset 
4e66			 
4e66 c1					pop bc 
4e67 c5					push bc      ; grab size of string 
4e68			 
4e68 e5					push hl    ; save string start  
4e69			 
4e69 26 00				ld h, 0 
4e6b 69					ld l, c 
4e6c 23					inc hl 
4e6d 23					inc hl 
4e6e			 
4e6e cd 7d 13				call malloc 
4e71				if DEBUG_FORTH_MALLOC_GUARD 
4e71 cc 3c 66				call z,malloc_error 
4e74				endif 
4e74			 
4e74 eb					ex de, hl      ; save malloc area for string copy 
4e75 e1					pop hl    ; get back source 
4e76 c1					pop bc    ; get length of string back 
4e77			 
4e77 d5					push de    ; save malloc area for after we push 
4e78 ed b0				ldir     ; copy substr 
4e7a			 
4e7a			 
4e7a eb					ex de, hl 
4e7b			;		ld a, 0 
4e7b 36 00				ld (hl), 0   ; term substr 
4e7d			 
4e7d					 
4e7d e1					pop hl    ; get malloc so we can push it 
4e7e e5					push hl   ; save so we can free it afterwards 
4e7f			 
4e7f cd 7c 20				call forth_push_str 
4e82			 
4e82 e1					pop hl 
4e83 cd 47 14				call free 
4e86			 
4e86					 
4e86					 
4e86			 
4e86			 
4e86					NEXTW 
4e86 cd a3 fd			call parse_vector 
4e89 c3 f5 23			jp macro_next 
4e8c				endm 
# End of macro NEXTW
4e8c			 
4e8c			.LEFT: 
4e8c				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4e8c 48				db WORD_SYS_CORE+52             
4e8d d0 4e			dw .RIGHT            
4e8f 05				db 4 + 1 
4e90 .. 00			db "LEFT",0              
4e95				endm 
# End of macro CWHEAD
4e95			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
4e95					if DEBUG_FORTH_WORDS_KEY 
4e95						DMARK "LEF" 
4e95 f5				push af  
4e96 3a aa 4e			ld a, (.dmark)  
4e99 32 99 fd			ld (debug_mark),a  
4e9c 3a ab 4e			ld a, (.dmark+1)  
4e9f 32 9a fd			ld (debug_mark+1),a  
4ea2 3a ac 4e			ld a, (.dmark+2)  
4ea5 32 9b fd			ld (debug_mark+2),a  
4ea8 18 03			jr .pastdmark  
4eaa ..			.dmark: db "LEF"  
4ead f1			.pastdmark: pop af  
4eae			endm  
# End of macro DMARK
4eae						CALLMONITOR 
4eae cd a6 fd			call debug_vector  
4eb1				endm  
# End of macro CALLMONITOR
4eb1					endif 
4eb1			 
4eb1					 
4eb1			; TODO check string type 
4eb1					FORTH_DSP_VALUEHL 
4eb1 cd 0e 22			call macro_dsp_valuehl 
4eb4				endm 
# End of macro FORTH_DSP_VALUEHL
4eb4			 
4eb4 e5					push hl      ; string length 
4eb5			 
4eb5					FORTH_DSP_POP 
4eb5 cd c6 22			call macro_forth_dsp_pop 
4eb8				endm 
# End of macro FORTH_DSP_POP
4eb8			 
4eb8					FORTH_DSP_VALUEHL 
4eb8 cd 0e 22			call macro_dsp_valuehl 
4ebb				endm 
# End of macro FORTH_DSP_VALUEHL
4ebb			 
4ebb c1					pop bc 
4ebc			 
4ebc 11 ef f0				ld de, scratch 
4ebf ed b0				ldir 
4ec1 3e 00				ld a, 0 
4ec3 12					ld (de), a 
4ec4					 
4ec4 21 ef f0				ld hl, scratch 
4ec7 cd 7c 20				call forth_push_str 
4eca			 
4eca					NEXTW 
4eca cd a3 fd			call parse_vector 
4ecd c3 f5 23			jp macro_next 
4ed0				endm 
# End of macro NEXTW
4ed0			.RIGHT: 
4ed0				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4ed0 48				db WORD_SYS_CORE+52             
4ed1 91 4f			dw .STR2NUM            
4ed3 06				db 5 + 1 
4ed4 .. 00			db "RIGHT",0              
4eda				endm 
# End of macro CWHEAD
4eda			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
4eda					if DEBUG_FORTH_WORDS_KEY 
4eda						DMARK "RIG" 
4eda f5				push af  
4edb 3a ef 4e			ld a, (.dmark)  
4ede 32 99 fd			ld (debug_mark),a  
4ee1 3a f0 4e			ld a, (.dmark+1)  
4ee4 32 9a fd			ld (debug_mark+1),a  
4ee7 3a f1 4e			ld a, (.dmark+2)  
4eea 32 9b fd			ld (debug_mark+2),a  
4eed 18 03			jr .pastdmark  
4eef ..			.dmark: db "RIG"  
4ef2 f1			.pastdmark: pop af  
4ef3			endm  
# End of macro DMARK
4ef3						CALLMONITOR 
4ef3 cd a6 fd			call debug_vector  
4ef6				endm  
# End of macro CALLMONITOR
4ef6					endif 
4ef6			 
4ef6			; TODO check string type 
4ef6					FORTH_DSP_VALUEHL 
4ef6 cd 0e 22			call macro_dsp_valuehl 
4ef9				endm 
# End of macro FORTH_DSP_VALUEHL
4ef9			 
4ef9 e5					push hl      ; string length 
4efa			 
4efa					FORTH_DSP_POP 
4efa cd c6 22			call macro_forth_dsp_pop 
4efd				endm 
# End of macro FORTH_DSP_POP
4efd			 
4efd					FORTH_DSP_VALUEHL 
4efd cd 0e 22			call macro_dsp_valuehl 
4f00				endm 
# End of macro FORTH_DSP_VALUEHL
4f00			 
4f00					if DEBUG_FORTH_WORDS 
4f00						DMARK "RI1" 
4f00 f5				push af  
4f01 3a 15 4f			ld a, (.dmark)  
4f04 32 99 fd			ld (debug_mark),a  
4f07 3a 16 4f			ld a, (.dmark+1)  
4f0a 32 9a fd			ld (debug_mark+1),a  
4f0d 3a 17 4f			ld a, (.dmark+2)  
4f10 32 9b fd			ld (debug_mark+2),a  
4f13 18 03			jr .pastdmark  
4f15 ..			.dmark: db "RI1"  
4f18 f1			.pastdmark: pop af  
4f19			endm  
# End of macro DMARK
4f19						CALLMONITOR 
4f19 cd a6 fd			call debug_vector  
4f1c				endm  
# End of macro CALLMONITOR
4f1c					endif 
4f1c					; from the pointer to string get to the end of string 
4f1c			 
4f1c 01 ff 00				ld bc, 255 
4f1f 3e 00				ld a, 0 
4f21 ed b1				cpir 
4f23 2b					dec hl 
4f24			 
4f24					;  
4f24			 
4f24					if DEBUG_FORTH_WORDS 
4f24						DMARK "RI2" 
4f24 f5				push af  
4f25 3a 39 4f			ld a, (.dmark)  
4f28 32 99 fd			ld (debug_mark),a  
4f2b 3a 3a 4f			ld a, (.dmark+1)  
4f2e 32 9a fd			ld (debug_mark+1),a  
4f31 3a 3b 4f			ld a, (.dmark+2)  
4f34 32 9b fd			ld (debug_mark+2),a  
4f37 18 03			jr .pastdmark  
4f39 ..			.dmark: db "RI2"  
4f3c f1			.pastdmark: pop af  
4f3d			endm  
# End of macro DMARK
4f3d						CALLMONITOR 
4f3d cd a6 fd			call debug_vector  
4f40				endm  
# End of macro CALLMONITOR
4f40					endif 
4f40			 
4f40 c1					pop bc    ;  length of string to copy 
4f41			 
4f41 79					ld a, c 
4f42 eb					ex de, hl 
4f43 21 ef f0				ld hl, scratch  
4f46 cd b1 0f				call addatohl 
4f49			 
4f49 eb					ex de, hl 
4f4a			 
4f4a					if DEBUG_FORTH_WORDS 
4f4a						DMARK "RI3" 
4f4a f5				push af  
4f4b 3a 5f 4f			ld a, (.dmark)  
4f4e 32 99 fd			ld (debug_mark),a  
4f51 3a 60 4f			ld a, (.dmark+1)  
4f54 32 9a fd			ld (debug_mark+1),a  
4f57 3a 61 4f			ld a, (.dmark+2)  
4f5a 32 9b fd			ld (debug_mark+2),a  
4f5d 18 03			jr .pastdmark  
4f5f ..			.dmark: db "RI3"  
4f62 f1			.pastdmark: pop af  
4f63			endm  
# End of macro DMARK
4f63						CALLMONITOR 
4f63 cd a6 fd			call debug_vector  
4f66				endm  
# End of macro CALLMONITOR
4f66					endif 
4f66			 
4f66 03					inc bc 
4f67 ed b8				lddr 
4f69					 
4f69 21 ef f0				ld hl, scratch 
4f6c					if DEBUG_FORTH_WORDS 
4f6c						DMARK "RI4" 
4f6c f5				push af  
4f6d 3a 81 4f			ld a, (.dmark)  
4f70 32 99 fd			ld (debug_mark),a  
4f73 3a 82 4f			ld a, (.dmark+1)  
4f76 32 9a fd			ld (debug_mark+1),a  
4f79 3a 83 4f			ld a, (.dmark+2)  
4f7c 32 9b fd			ld (debug_mark+2),a  
4f7f 18 03			jr .pastdmark  
4f81 ..			.dmark: db "RI4"  
4f84 f1			.pastdmark: pop af  
4f85			endm  
# End of macro DMARK
4f85						CALLMONITOR 
4f85 cd a6 fd			call debug_vector  
4f88				endm  
# End of macro CALLMONITOR
4f88					endif 
4f88 cd 7c 20				call forth_push_str 
4f8b			 
4f8b			 
4f8b					NEXTW 
4f8b cd a3 fd			call parse_vector 
4f8e c3 f5 23			jp macro_next 
4f91				endm 
# End of macro NEXTW
4f91			 
4f91			 
4f91			.STR2NUM: 
4f91				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4f91 48				db WORD_SYS_CORE+52             
4f92 20 50			dw .NUM2STR            
4f94 08				db 7 + 1 
4f95 .. 00			db "STR2NUM",0              
4f9d				endm 
# End of macro CWHEAD
4f9d			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4f9d			 
4f9d			 
4f9d			; TODO STR type check to do 
4f9d					if DEBUG_FORTH_WORDS_KEY 
4f9d						DMARK "S2N" 
4f9d f5				push af  
4f9e 3a b2 4f			ld a, (.dmark)  
4fa1 32 99 fd			ld (debug_mark),a  
4fa4 3a b3 4f			ld a, (.dmark+1)  
4fa7 32 9a fd			ld (debug_mark+1),a  
4faa 3a b4 4f			ld a, (.dmark+2)  
4fad 32 9b fd			ld (debug_mark+2),a  
4fb0 18 03			jr .pastdmark  
4fb2 ..			.dmark: db "S2N"  
4fb5 f1			.pastdmark: pop af  
4fb6			endm  
# End of macro DMARK
4fb6						CALLMONITOR 
4fb6 cd a6 fd			call debug_vector  
4fb9				endm  
# End of macro CALLMONITOR
4fb9					endif 
4fb9			 
4fb9					;FORTH_DSP 
4fb9					FORTH_DSP_VALUE 
4fb9 cd f7 21			call macro_forth_dsp_value 
4fbc				endm 
# End of macro FORTH_DSP_VALUE
4fbc					;inc hl 
4fbc			 
4fbc eb					ex de, hl 
4fbd					if DEBUG_FORTH_WORDS 
4fbd						DMARK "S2a" 
4fbd f5				push af  
4fbe 3a d2 4f			ld a, (.dmark)  
4fc1 32 99 fd			ld (debug_mark),a  
4fc4 3a d3 4f			ld a, (.dmark+1)  
4fc7 32 9a fd			ld (debug_mark+1),a  
4fca 3a d4 4f			ld a, (.dmark+2)  
4fcd 32 9b fd			ld (debug_mark+2),a  
4fd0 18 03			jr .pastdmark  
4fd2 ..			.dmark: db "S2a"  
4fd5 f1			.pastdmark: pop af  
4fd6			endm  
# End of macro DMARK
4fd6						CALLMONITOR 
4fd6 cd a6 fd			call debug_vector  
4fd9				endm  
# End of macro CALLMONITOR
4fd9					endif 
4fd9 cd a0 12				call string_to_uint16 
4fdc			 
4fdc					if DEBUG_FORTH_WORDS 
4fdc						DMARK "S2b" 
4fdc f5				push af  
4fdd 3a f1 4f			ld a, (.dmark)  
4fe0 32 99 fd			ld (debug_mark),a  
4fe3 3a f2 4f			ld a, (.dmark+1)  
4fe6 32 9a fd			ld (debug_mark+1),a  
4fe9 3a f3 4f			ld a, (.dmark+2)  
4fec 32 9b fd			ld (debug_mark+2),a  
4fef 18 03			jr .pastdmark  
4ff1 ..			.dmark: db "S2b"  
4ff4 f1			.pastdmark: pop af  
4ff5			endm  
# End of macro DMARK
4ff5						CALLMONITOR 
4ff5 cd a6 fd			call debug_vector  
4ff8				endm  
# End of macro CALLMONITOR
4ff8					endif 
4ff8			;		push hl 
4ff8					FORTH_DSP_POP 
4ff8 cd c6 22			call macro_forth_dsp_pop 
4ffb				endm 
# End of macro FORTH_DSP_POP
4ffb			;		pop hl 
4ffb					 
4ffb					if DEBUG_FORTH_WORDS 
4ffb						DMARK "S2b" 
4ffb f5				push af  
4ffc 3a 10 50			ld a, (.dmark)  
4fff 32 99 fd			ld (debug_mark),a  
5002 3a 11 50			ld a, (.dmark+1)  
5005 32 9a fd			ld (debug_mark+1),a  
5008 3a 12 50			ld a, (.dmark+2)  
500b 32 9b fd			ld (debug_mark+2),a  
500e 18 03			jr .pastdmark  
5010 ..			.dmark: db "S2b"  
5013 f1			.pastdmark: pop af  
5014			endm  
# End of macro DMARK
5014						CALLMONITOR 
5014 cd a6 fd			call debug_vector  
5017				endm  
# End of macro CALLMONITOR
5017					endif 
5017 cd 12 20				call forth_push_numhl	 
501a			 
501a				 
501a				       NEXTW 
501a cd a3 fd			call parse_vector 
501d c3 f5 23			jp macro_next 
5020				endm 
# End of macro NEXTW
5020			.NUM2STR: 
5020				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
5020 48				db WORD_SYS_CORE+52             
5021 b5 50			dw .CONCAT            
5023 08				db 7 + 1 
5024 .. 00			db "NUM2STR",0              
502c				endm 
# End of macro CWHEAD
502c			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
502c			 
502c			;		; malloc a string to target 
502c			;		ld hl, 10     ; TODO max string size should be fine 
502c			;		call malloc 
502c			;		push hl    ; save malloc location 
502c			; 
502c			; 
502c			;; TODO check int type 
502c					if DEBUG_FORTH_WORDS_KEY 
502c						DMARK "N2S" 
502c f5				push af  
502d 3a 41 50			ld a, (.dmark)  
5030 32 99 fd			ld (debug_mark),a  
5033 3a 42 50			ld a, (.dmark+1)  
5036 32 9a fd			ld (debug_mark+1),a  
5039 3a 43 50			ld a, (.dmark+2)  
503c 32 9b fd			ld (debug_mark+2),a  
503f 18 03			jr .pastdmark  
5041 ..			.dmark: db "N2S"  
5044 f1			.pastdmark: pop af  
5045			endm  
# End of macro DMARK
5045						CALLMONITOR 
5045 cd a6 fd			call debug_vector  
5048				endm  
# End of macro CALLMONITOR
5048					endif 
5048			 
5048					FORTH_DSP_VALUEHL 
5048 cd 0e 22			call macro_dsp_valuehl 
504b				endm 
# End of macro FORTH_DSP_VALUEHL
504b			 
504b					if DEBUG_FORTH_WORDS 
504b						DMARK "NS1" 
504b f5				push af  
504c 3a 60 50			ld a, (.dmark)  
504f 32 99 fd			ld (debug_mark),a  
5052 3a 61 50			ld a, (.dmark+1)  
5055 32 9a fd			ld (debug_mark+1),a  
5058 3a 62 50			ld a, (.dmark+2)  
505b 32 9b fd			ld (debug_mark+2),a  
505e 18 03			jr .pastdmark  
5060 ..			.dmark: db "NS1"  
5063 f1			.pastdmark: pop af  
5064			endm  
# End of macro DMARK
5064						CALLMONITOR 
5064 cd a6 fd			call debug_vector  
5067				endm  
# End of macro CALLMONITOR
5067					endif 
5067					FORTH_DSP_POP 
5067 cd c6 22			call macro_forth_dsp_pop 
506a				endm 
# End of macro FORTH_DSP_POP
506a			 
506a eb					ex de, hl 
506b 21 ef f0				ld hl, scratch 
506e					if DEBUG_FORTH_WORDS 
506e						DMARK "NS2" 
506e f5				push af  
506f 3a 83 50			ld a, (.dmark)  
5072 32 99 fd			ld (debug_mark),a  
5075 3a 84 50			ld a, (.dmark+1)  
5078 32 9a fd			ld (debug_mark+1),a  
507b 3a 85 50			ld a, (.dmark+2)  
507e 32 9b fd			ld (debug_mark+2),a  
5081 18 03			jr .pastdmark  
5083 ..			.dmark: db "NS2"  
5086 f1			.pastdmark: pop af  
5087			endm  
# End of macro DMARK
5087						CALLMONITOR 
5087 cd a6 fd			call debug_vector  
508a				endm  
# End of macro CALLMONITOR
508a					endif 
508a cd b8 12				call uitoa_16 
508d 21 ef f0				ld hl, scratch 
5090					if DEBUG_FORTH_WORDS 
5090						DMARK "NS3" 
5090 f5				push af  
5091 3a a5 50			ld a, (.dmark)  
5094 32 99 fd			ld (debug_mark),a  
5097 3a a6 50			ld a, (.dmark+1)  
509a 32 9a fd			ld (debug_mark+1),a  
509d 3a a7 50			ld a, (.dmark+2)  
50a0 32 9b fd			ld (debug_mark+2),a  
50a3 18 03			jr .pastdmark  
50a5 ..			.dmark: db "NS3"  
50a8 f1			.pastdmark: pop af  
50a9			endm  
# End of macro DMARK
50a9						CALLMONITOR 
50a9 cd a6 fd			call debug_vector  
50ac				endm  
# End of macro CALLMONITOR
50ac					endif 
50ac cd 7c 20				call forth_push_str 
50af			;		ld a, l 
50af			;		call DispAToASCII   
50af			;;TODO need to chage above call to dump into string 
50af			; 
50af			; 
50af			 
50af				       NEXTW 
50af cd a3 fd			call parse_vector 
50b2 c3 f5 23			jp macro_next 
50b5				endm 
# End of macro NEXTW
50b5			 
50b5			.CONCAT: 
50b5				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
50b5 48				db WORD_SYS_CORE+52             
50b6 6b 51			dw .FIND            
50b8 07				db 6 + 1 
50b9 .. 00			db "CONCAT",0              
50c0				endm 
# End of macro CWHEAD
50c0			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
50c0			 
50c0			; TODO check string type 
50c0			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
50c0			 
50c0					if DEBUG_FORTH_WORDS_KEY 
50c0						DMARK "CON" 
50c0 f5				push af  
50c1 3a d5 50			ld a, (.dmark)  
50c4 32 99 fd			ld (debug_mark),a  
50c7 3a d6 50			ld a, (.dmark+1)  
50ca 32 9a fd			ld (debug_mark+1),a  
50cd 3a d7 50			ld a, (.dmark+2)  
50d0 32 9b fd			ld (debug_mark+2),a  
50d3 18 03			jr .pastdmark  
50d5 ..			.dmark: db "CON"  
50d8 f1			.pastdmark: pop af  
50d9			endm  
# End of macro DMARK
50d9						CALLMONITOR 
50d9 cd a6 fd			call debug_vector  
50dc				endm  
# End of macro CALLMONITOR
50dc					endif 
50dc			 
50dc			 
50dc					FORTH_DSP_VALUE 
50dc cd f7 21			call macro_forth_dsp_value 
50df				endm 
# End of macro FORTH_DSP_VALUE
50df e5					push hl   ; s2 
50e0			 
50e0					FORTH_DSP_POP 
50e0 cd c6 22			call macro_forth_dsp_pop 
50e3				endm 
# End of macro FORTH_DSP_POP
50e3			 
50e3					FORTH_DSP_VALUE 
50e3 cd f7 21			call macro_forth_dsp_value 
50e6				endm 
# End of macro FORTH_DSP_VALUE
50e6			 
50e6 e5					push hl   ; s1 
50e7			 
50e7					FORTH_DSP_POP 
50e7 cd c6 22			call macro_forth_dsp_pop 
50ea				endm 
# End of macro FORTH_DSP_POP
50ea					 
50ea			 
50ea					; copy s1 
50ea			 
50ea				 
50ea					; save ptr 
50ea e1					pop hl  
50eb e5					push hl 
50ec 3e 00				ld a, 0 
50ee cd 14 13				call strlent 
50f1					;inc hl    ; zer0 
50f1 06 00				ld b, 0 
50f3 4d					ld c, l 
50f4 e1					pop hl		 
50f5 11 ef f0				ld de, scratch	 
50f8					if DEBUG_FORTH_WORDS 
50f8						DMARK "CO1" 
50f8 f5				push af  
50f9 3a 0d 51			ld a, (.dmark)  
50fc 32 99 fd			ld (debug_mark),a  
50ff 3a 0e 51			ld a, (.dmark+1)  
5102 32 9a fd			ld (debug_mark+1),a  
5105 3a 0f 51			ld a, (.dmark+2)  
5108 32 9b fd			ld (debug_mark+2),a  
510b 18 03			jr .pastdmark  
510d ..			.dmark: db "CO1"  
5110 f1			.pastdmark: pop af  
5111			endm  
# End of macro DMARK
5111						CALLMONITOR 
5111 cd a6 fd			call debug_vector  
5114				endm  
# End of macro CALLMONITOR
5114					endif 
5114 ed b0				ldir 
5116			 
5116 e1					pop hl 
5117 e5					push hl 
5118 d5					push de 
5119			 
5119			 
5119 3e 00				ld a, 0 
511b cd 14 13				call strlent 
511e 23					inc hl    ; zer0 
511f 23					inc hl 
5120 06 00				ld b, 0 
5122 4d					ld c, l 
5123 d1					pop de 
5124 e1					pop hl		 
5125					if DEBUG_FORTH_WORDS 
5125						DMARK "CO2" 
5125 f5				push af  
5126 3a 3a 51			ld a, (.dmark)  
5129 32 99 fd			ld (debug_mark),a  
512c 3a 3b 51			ld a, (.dmark+1)  
512f 32 9a fd			ld (debug_mark+1),a  
5132 3a 3c 51			ld a, (.dmark+2)  
5135 32 9b fd			ld (debug_mark+2),a  
5138 18 03			jr .pastdmark  
513a ..			.dmark: db "CO2"  
513d f1			.pastdmark: pop af  
513e			endm  
# End of macro DMARK
513e						CALLMONITOR 
513e cd a6 fd			call debug_vector  
5141				endm  
# End of macro CALLMONITOR
5141					endif 
5141 ed b0				ldir 
5143			 
5143			 
5143			 
5143 21 ef f0				ld hl, scratch 
5146					if DEBUG_FORTH_WORDS 
5146						DMARK "CO5" 
5146 f5				push af  
5147 3a 5b 51			ld a, (.dmark)  
514a 32 99 fd			ld (debug_mark),a  
514d 3a 5c 51			ld a, (.dmark+1)  
5150 32 9a fd			ld (debug_mark+1),a  
5153 3a 5d 51			ld a, (.dmark+2)  
5156 32 9b fd			ld (debug_mark+2),a  
5159 18 03			jr .pastdmark  
515b ..			.dmark: db "CO5"  
515e f1			.pastdmark: pop af  
515f			endm  
# End of macro DMARK
515f						CALLMONITOR 
515f cd a6 fd			call debug_vector  
5162				endm  
# End of macro CALLMONITOR
5162					endif 
5162			 
5162 cd 7c 20				call forth_push_str 
5165			 
5165			 
5165			 
5165			 
5165				       NEXTW 
5165 cd a3 fd			call parse_vector 
5168 c3 f5 23			jp macro_next 
516b				endm 
# End of macro NEXTW
516b			 
516b			 
516b			.FIND: 
516b				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
516b 4b				db WORD_SYS_CORE+55             
516c 2b 52			dw .LEN            
516e 05				db 4 + 1 
516f .. 00			db "FIND",0              
5174				endm 
# End of macro CWHEAD
5174			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
5174			 
5174					if DEBUG_FORTH_WORDS_KEY 
5174						DMARK "FND" 
5174 f5				push af  
5175 3a 89 51			ld a, (.dmark)  
5178 32 99 fd			ld (debug_mark),a  
517b 3a 8a 51			ld a, (.dmark+1)  
517e 32 9a fd			ld (debug_mark+1),a  
5181 3a 8b 51			ld a, (.dmark+2)  
5184 32 9b fd			ld (debug_mark+2),a  
5187 18 03			jr .pastdmark  
5189 ..			.dmark: db "FND"  
518c f1			.pastdmark: pop af  
518d			endm  
# End of macro DMARK
518d						CALLMONITOR 
518d cd a6 fd			call debug_vector  
5190				endm  
# End of macro CALLMONITOR
5190					endif 
5190			 
5190			; TODO check string type 
5190					FORTH_DSP_VALUE 
5190 cd f7 21			call macro_forth_dsp_value 
5193				endm 
# End of macro FORTH_DSP_VALUE
5193			 
5193 e5					push hl    
5194 7e					ld a,(hl)    ; char to find   
5195			; TODO change char to substr 
5195			 
5195 f5					push af 
5196					 
5196			 
5196			 
5196					if DEBUG_FORTH_WORDS 
5196						DMARK "FN1" 
5196 f5				push af  
5197 3a ab 51			ld a, (.dmark)  
519a 32 99 fd			ld (debug_mark),a  
519d 3a ac 51			ld a, (.dmark+1)  
51a0 32 9a fd			ld (debug_mark+1),a  
51a3 3a ad 51			ld a, (.dmark+2)  
51a6 32 9b fd			ld (debug_mark+2),a  
51a9 18 03			jr .pastdmark  
51ab ..			.dmark: db "FN1"  
51ae f1			.pastdmark: pop af  
51af			endm  
# End of macro DMARK
51af						CALLMONITOR 
51af cd a6 fd			call debug_vector  
51b2				endm  
# End of macro CALLMONITOR
51b2					endif 
51b2			 
51b2					FORTH_DSP_POP 
51b2 cd c6 22			call macro_forth_dsp_pop 
51b5				endm 
# End of macro FORTH_DSP_POP
51b5			 
51b5					; string to search 
51b5			 
51b5					FORTH_DSP_VALUE 
51b5 cd f7 21			call macro_forth_dsp_value 
51b8				endm 
# End of macro FORTH_DSP_VALUE
51b8			 
51b8 d1					pop de  ; d is char to find  
51b9			 
51b9					if DEBUG_FORTH_WORDS 
51b9						DMARK "FN2" 
51b9 f5				push af  
51ba 3a ce 51			ld a, (.dmark)  
51bd 32 99 fd			ld (debug_mark),a  
51c0 3a cf 51			ld a, (.dmark+1)  
51c3 32 9a fd			ld (debug_mark+1),a  
51c6 3a d0 51			ld a, (.dmark+2)  
51c9 32 9b fd			ld (debug_mark+2),a  
51cc 18 03			jr .pastdmark  
51ce ..			.dmark: db "FN2"  
51d1 f1			.pastdmark: pop af  
51d2			endm  
# End of macro DMARK
51d2						CALLMONITOR 
51d2 cd a6 fd			call debug_vector  
51d5				endm  
# End of macro CALLMONITOR
51d5					endif 
51d5					 
51d5 01 00 00				ld bc, 0 
51d8 7e			.findchar:      ld a,(hl) 
51d9			;		cp 0   		 
51d9 b7					or a 
51da 28 27				jr z, .finddone     
51dc ba					cp d 
51dd 28 20				jr z, .foundchar 
51df 03					inc bc 
51e0 23					inc hl 
51e1					if DEBUG_FORTH_WORDS 
51e1						DMARK "FN3" 
51e1 f5				push af  
51e2 3a f6 51			ld a, (.dmark)  
51e5 32 99 fd			ld (debug_mark),a  
51e8 3a f7 51			ld a, (.dmark+1)  
51eb 32 9a fd			ld (debug_mark+1),a  
51ee 3a f8 51			ld a, (.dmark+2)  
51f1 32 9b fd			ld (debug_mark+2),a  
51f4 18 03			jr .pastdmark  
51f6 ..			.dmark: db "FN3"  
51f9 f1			.pastdmark: pop af  
51fa			endm  
# End of macro DMARK
51fa						CALLMONITOR 
51fa cd a6 fd			call debug_vector  
51fd				endm  
# End of macro CALLMONITOR
51fd					endif 
51fd 18 d9				jr .findchar 
51ff			 
51ff			 
51ff c5			.foundchar:	push bc 
5200 e1					pop hl 
5201 18 03				jr .findexit 
5203			 
5203			 
5203							 
5203			 
5203			.finddone:     ; got to end of string with no find 
5203 21 00 00				ld hl, 0 
5206			.findexit: 
5206			 
5206					if DEBUG_FORTH_WORDS 
5206						DMARK "FNd" 
5206 f5				push af  
5207 3a 1b 52			ld a, (.dmark)  
520a 32 99 fd			ld (debug_mark),a  
520d 3a 1c 52			ld a, (.dmark+1)  
5210 32 9a fd			ld (debug_mark+1),a  
5213 3a 1d 52			ld a, (.dmark+2)  
5216 32 9b fd			ld (debug_mark+2),a  
5219 18 03			jr .pastdmark  
521b ..			.dmark: db "FNd"  
521e f1			.pastdmark: pop af  
521f			endm  
# End of macro DMARK
521f						CALLMONITOR 
521f cd a6 fd			call debug_vector  
5222				endm  
# End of macro CALLMONITOR
5222					endif 
5222 cd 12 20			call forth_push_numhl 
5225			 
5225				       NEXTW 
5225 cd a3 fd			call parse_vector 
5228 c3 f5 23			jp macro_next 
522b				endm 
# End of macro NEXTW
522b			 
522b			.LEN: 
522b				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
522b 4c				db WORD_SYS_CORE+56             
522c 98 52			dw .ASC            
522e 06				db 5 + 1 
522f .. 00			db "COUNT",0              
5235				endm 
# End of macro CWHEAD
5235			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
5235			 
5235					if DEBUG_FORTH_WORDS_KEY 
5235						DMARK "CNT" 
5235 f5				push af  
5236 3a 4a 52			ld a, (.dmark)  
5239 32 99 fd			ld (debug_mark),a  
523c 3a 4b 52			ld a, (.dmark+1)  
523f 32 9a fd			ld (debug_mark+1),a  
5242 3a 4c 52			ld a, (.dmark+2)  
5245 32 9b fd			ld (debug_mark+2),a  
5248 18 03			jr .pastdmark  
524a ..			.dmark: db "CNT"  
524d f1			.pastdmark: pop af  
524e			endm  
# End of macro DMARK
524e						CALLMONITOR 
524e cd a6 fd			call debug_vector  
5251				endm  
# End of macro CALLMONITOR
5251					endif 
5251			; TODO check string type 
5251					FORTH_DSP_VALUE 
5251 cd f7 21			call macro_forth_dsp_value 
5254				endm 
# End of macro FORTH_DSP_VALUE
5254			 
5254			 
5254					if DEBUG_FORTH_WORDS 
5254						DMARK "CN?" 
5254 f5				push af  
5255 3a 69 52			ld a, (.dmark)  
5258 32 99 fd			ld (debug_mark),a  
525b 3a 6a 52			ld a, (.dmark+1)  
525e 32 9a fd			ld (debug_mark+1),a  
5261 3a 6b 52			ld a, (.dmark+2)  
5264 32 9b fd			ld (debug_mark+2),a  
5267 18 03			jr .pastdmark  
5269 ..			.dmark: db "CN?"  
526c f1			.pastdmark: pop af  
526d			endm  
# End of macro DMARK
526d						CALLMONITOR 
526d cd a6 fd			call debug_vector  
5270				endm  
# End of macro CALLMONITOR
5270					endif 
5270 cd 09 13				call strlenz 
5273					if DEBUG_FORTH_WORDS 
5273						DMARK "CNl" 
5273 f5				push af  
5274 3a 88 52			ld a, (.dmark)  
5277 32 99 fd			ld (debug_mark),a  
527a 3a 89 52			ld a, (.dmark+1)  
527d 32 9a fd			ld (debug_mark+1),a  
5280 3a 8a 52			ld a, (.dmark+2)  
5283 32 9b fd			ld (debug_mark+2),a  
5286 18 03			jr .pastdmark  
5288 ..			.dmark: db "CNl"  
528b f1			.pastdmark: pop af  
528c			endm  
# End of macro DMARK
528c						CALLMONITOR 
528c cd a6 fd			call debug_vector  
528f				endm  
# End of macro CALLMONITOR
528f					endif 
528f			 
528f cd 12 20				call forth_push_numhl 
5292			 
5292			 
5292			 
5292				       NEXTW 
5292 cd a3 fd			call parse_vector 
5295 c3 f5 23			jp macro_next 
5298				endm 
# End of macro NEXTW
5298			.ASC: 
5298				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
5298 4d				db WORD_SYS_CORE+57             
5299 09 53			dw .CHR            
529b 04				db 3 + 1 
529c .. 00			db "ASC",0              
52a0				endm 
# End of macro CWHEAD
52a0			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
52a0					if DEBUG_FORTH_WORDS_KEY 
52a0						DMARK "ASC" 
52a0 f5				push af  
52a1 3a b5 52			ld a, (.dmark)  
52a4 32 99 fd			ld (debug_mark),a  
52a7 3a b6 52			ld a, (.dmark+1)  
52aa 32 9a fd			ld (debug_mark+1),a  
52ad 3a b7 52			ld a, (.dmark+2)  
52b0 32 9b fd			ld (debug_mark+2),a  
52b3 18 03			jr .pastdmark  
52b5 ..			.dmark: db "ASC"  
52b8 f1			.pastdmark: pop af  
52b9			endm  
# End of macro DMARK
52b9						CALLMONITOR 
52b9 cd a6 fd			call debug_vector  
52bc				endm  
# End of macro CALLMONITOR
52bc					endif 
52bc					FORTH_DSP_VALUE 
52bc cd f7 21			call macro_forth_dsp_value 
52bf				endm 
# End of macro FORTH_DSP_VALUE
52bf					;v5 FORTH_DSP_VALUE 
52bf			;		inc hl      ; now at start of numeric as string 
52bf			 
52bf e5					push hl 
52c0			 
52c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52c0 cd c6 22			call macro_forth_dsp_pop 
52c3				endm 
# End of macro FORTH_DSP_POP
52c3			 
52c3 e1					pop hl 
52c4			 
52c4					if DEBUG_FORTH_WORDS 
52c4						DMARK "AS1" 
52c4 f5				push af  
52c5 3a d9 52			ld a, (.dmark)  
52c8 32 99 fd			ld (debug_mark),a  
52cb 3a da 52			ld a, (.dmark+1)  
52ce 32 9a fd			ld (debug_mark+1),a  
52d1 3a db 52			ld a, (.dmark+2)  
52d4 32 9b fd			ld (debug_mark+2),a  
52d7 18 03			jr .pastdmark  
52d9 ..			.dmark: db "AS1"  
52dc f1			.pastdmark: pop af  
52dd			endm  
# End of macro DMARK
52dd						CALLMONITOR 
52dd cd a6 fd			call debug_vector  
52e0				endm  
# End of macro CALLMONITOR
52e0					endif 
52e0					; push the content of a onto the stack as a value 
52e0			 
52e0 7e					ld a,(hl)   ; get char 
52e1 26 00				ld h,0 
52e3 6f					ld l,a 
52e4					if DEBUG_FORTH_WORDS 
52e4						DMARK "AS2" 
52e4 f5				push af  
52e5 3a f9 52			ld a, (.dmark)  
52e8 32 99 fd			ld (debug_mark),a  
52eb 3a fa 52			ld a, (.dmark+1)  
52ee 32 9a fd			ld (debug_mark+1),a  
52f1 3a fb 52			ld a, (.dmark+2)  
52f4 32 9b fd			ld (debug_mark+2),a  
52f7 18 03			jr .pastdmark  
52f9 ..			.dmark: db "AS2"  
52fc f1			.pastdmark: pop af  
52fd			endm  
# End of macro DMARK
52fd						CALLMONITOR 
52fd cd a6 fd			call debug_vector  
5300				endm  
# End of macro CALLMONITOR
5300					endif 
5300 cd 12 20				call forth_push_numhl 
5303			 
5303				       NEXTW 
5303 cd a3 fd			call parse_vector 
5306 c3 f5 23			jp macro_next 
5309				endm 
# End of macro NEXTW
5309			 
5309			.CHR: 
5309				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
5309 4d				db WORD_SYS_CORE+57             
530a 48 53			dw .ENDSTR            
530c 04				db 3 + 1 
530d .. 00			db "CHR",0              
5311				endm 
# End of macro CWHEAD
5311			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
5311					if DEBUG_FORTH_WORDS_KEY 
5311						DMARK "CHR" 
5311 f5				push af  
5312 3a 26 53			ld a, (.dmark)  
5315 32 99 fd			ld (debug_mark),a  
5318 3a 27 53			ld a, (.dmark+1)  
531b 32 9a fd			ld (debug_mark+1),a  
531e 3a 28 53			ld a, (.dmark+2)  
5321 32 9b fd			ld (debug_mark+2),a  
5324 18 03			jr .pastdmark  
5326 ..			.dmark: db "CHR"  
5329 f1			.pastdmark: pop af  
532a			endm  
# End of macro DMARK
532a						CALLMONITOR 
532a cd a6 fd			call debug_vector  
532d				endm  
# End of macro CALLMONITOR
532d					endif 
532d					FORTH_DSP_VALUEHL 
532d cd 0e 22			call macro_dsp_valuehl 
5330				endm 
# End of macro FORTH_DSP_VALUEHL
5330			 
5330					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5330 cd c6 22			call macro_forth_dsp_pop 
5333				endm 
# End of macro FORTH_DSP_POP
5333			 
5333					; save asci byte as a zero term string and push string 
5333			 
5333 7d					ld a,l 
5334 32 ef f0				ld (scratch), a 
5337			 
5337 3e 00				ld a, 0 
5339 32 f0 f0				ld (scratch+1), a 
533c			 
533c 21 ef f0				ld hl, scratch 
533f cd 7c 20				call forth_push_str 
5342			 
5342			 
5342				       NEXTW 
5342 cd a3 fd			call parse_vector 
5345 c3 f5 23			jp macro_next 
5348				endm 
# End of macro NEXTW
5348			 
5348			 
5348			 
5348			 
5348			.ENDSTR: 
5348			; eof 
5348			 
# End of file forth_words_str.asm
5348			include "forth_words_key.asm" 
5348			 
5348			; | ## Keyboard Words 
5348			 
5348			.MACRO: 
5348			 
5348				CWHEAD .KEY 42 "MACRO" 5 WORD_FLAG_CODE 
5348 3e				db WORD_SYS_CORE+42             
5349 74 53			dw .KEY            
534b 06				db 5 + 1 
534c .. 00			db "MACRO",0              
5352				endm 
# End of macro CWHEAD
5352			; | MACRO ( s u -- ) Maps a string s against a key code u for use in the editor functions (CLI/EDIT/ACCEPT)  | TODO 
5352			 
5352					if DEBUG_FORTH_WORDS_KEY 
5352						DMARK "MAC" 
5352 f5				push af  
5353 3a 67 53			ld a, (.dmark)  
5356 32 99 fd			ld (debug_mark),a  
5359 3a 68 53			ld a, (.dmark+1)  
535c 32 9a fd			ld (debug_mark+1),a  
535f 3a 69 53			ld a, (.dmark+2)  
5362 32 9b fd			ld (debug_mark+2),a  
5365 18 03			jr .pastdmark  
5367 ..			.dmark: db "MAC"  
536a f1			.pastdmark: pop af  
536b			endm  
# End of macro DMARK
536b						CALLMONITOR 
536b cd a6 fd			call debug_vector  
536e				endm  
# End of macro CALLMONITOR
536e					endif 
536e			 
536e					; get key code 
536e					; calc string length 
536e					; malloc string size 
536e					; copy string 
536e					; patch keyboard scan 
536e			 
536e					; maintain a linked list?  
536e					; need a structure for root of key mappings 
536e					; hold last defined macro so that link can be made to the next one 
536e					; key_macroroot   is the first one 
536e					; key_macrolast is location of the last macro defined 
536e			 
536e			 
536e					NEXTW 
536e cd a3 fd			call parse_vector 
5371 c3 f5 23			jp macro_next 
5374				endm 
# End of macro NEXTW
5374			 
5374			.KEY: 
5374				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
5374 3e				db WORD_SYS_CORE+42             
5375 a7 53			dw .KEYDB            
5377 04				db 3 + 1 
5378 .. 00			db "KEY",0              
537c				endm 
# End of macro CWHEAD
537c			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
537c			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
537c			; | | Can use something like this to process: 
537c			; | | > repeat active . key ?dup if emit then #1 until  
537c			 
537c					if DEBUG_FORTH_WORDS_KEY 
537c						DMARK "KEY" 
537c f5				push af  
537d 3a 91 53			ld a, (.dmark)  
5380 32 99 fd			ld (debug_mark),a  
5383 3a 92 53			ld a, (.dmark+1)  
5386 32 9a fd			ld (debug_mark+1),a  
5389 3a 93 53			ld a, (.dmark+2)  
538c 32 9b fd			ld (debug_mark+2),a  
538f 18 03			jr .pastdmark  
5391 ..			.dmark: db "KEY"  
5394 f1			.pastdmark: pop af  
5395			endm  
# End of macro DMARK
5395						CALLMONITOR 
5395 cd a6 fd			call debug_vector  
5398				endm  
# End of macro CALLMONITOR
5398					endif 
5398			; TODO currently waits 
5398 cd 0e 7d				call cinndb 
539b					;call cin_wait 
539b 6f					ld l, a 
539c 26 00				ld h, 0 
539e cd 12 20				call forth_push_numhl 
53a1					NEXTW 
53a1 cd a3 fd			call parse_vector 
53a4 c3 f5 23			jp macro_next 
53a7				endm 
# End of macro NEXTW
53a7			.KEYDB: 
53a7				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
53a7 3e				db WORD_SYS_CORE+42             
53a8 dc 53			dw .WAITK            
53aa 06				db 5 + 1 
53ab .. 00			db "KEYDB",0              
53b1				endm 
# End of macro CWHEAD
53b1			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
53b1			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
53b1			; | | Can use something like this to process: 
53b1			; | | > repeat active . key ?dup if emit then #1 until  
53b1			 
53b1					if DEBUG_FORTH_WORDS_KEY 
53b1						DMARK "KEB" 
53b1 f5				push af  
53b2 3a c6 53			ld a, (.dmark)  
53b5 32 99 fd			ld (debug_mark),a  
53b8 3a c7 53			ld a, (.dmark+1)  
53bb 32 9a fd			ld (debug_mark+1),a  
53be 3a c8 53			ld a, (.dmark+2)  
53c1 32 9b fd			ld (debug_mark+2),a  
53c4 18 03			jr .pastdmark  
53c6 ..			.dmark: db "KEB"  
53c9 f1			.pastdmark: pop af  
53ca			endm  
# End of macro DMARK
53ca						CALLMONITOR 
53ca cd a6 fd			call debug_vector  
53cd				endm  
# End of macro CALLMONITOR
53cd					endif 
53cd			; TODO currently waits 
53cd cd fb 7c				call cin 
53d0					;call cin_wait 
53d0 6f					ld l, a 
53d1 26 00				ld h, 0 
53d3 cd 12 20				call forth_push_numhl 
53d6					NEXTW 
53d6 cd a3 fd			call parse_vector 
53d9 c3 f5 23			jp macro_next 
53dc				endm 
# End of macro NEXTW
53dc			.WAITK: 
53dc				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
53dc 3f				db WORD_SYS_CORE+43             
53dd 11 54			dw .ACCEPT            
53df 06				db 5 + 1 
53e0 .. 00			db "WAITK",0              
53e6				endm 
# End of macro CWHEAD
53e6			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
53e6					if DEBUG_FORTH_WORDS_KEY 
53e6						DMARK "WAI" 
53e6 f5				push af  
53e7 3a fb 53			ld a, (.dmark)  
53ea 32 99 fd			ld (debug_mark),a  
53ed 3a fc 53			ld a, (.dmark+1)  
53f0 32 9a fd			ld (debug_mark+1),a  
53f3 3a fd 53			ld a, (.dmark+2)  
53f6 32 9b fd			ld (debug_mark+2),a  
53f9 18 03			jr .pastdmark  
53fb ..			.dmark: db "WAI"  
53fe f1			.pastdmark: pop af  
53ff			endm  
# End of macro DMARK
53ff						CALLMONITOR 
53ff cd a6 fd			call debug_vector  
5402				endm  
# End of macro CALLMONITOR
5402					endif 
5402 cd ec 7c				call cin_wait 
5405 6f					ld l, a 
5406 26 00				ld h, 0 
5408 cd 12 20				call forth_push_numhl 
540b					NEXTW 
540b cd a3 fd			call parse_vector 
540e c3 f5 23			jp macro_next 
5411				endm 
# End of macro NEXTW
5411			.ACCEPT: 
5411				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
5411 40				db WORD_SYS_CORE+44             
5412 71 54			dw .EDIT            
5414 07				db 6 + 1 
5415 .. 00			db "ACCEPT",0              
541c				endm 
# End of macro CWHEAD
541c			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
541c					; TODO crashes on push 
541c					if DEBUG_FORTH_WORDS_KEY 
541c						DMARK "ACC" 
541c f5				push af  
541d 3a 31 54			ld a, (.dmark)  
5420 32 99 fd			ld (debug_mark),a  
5423 3a 32 54			ld a, (.dmark+1)  
5426 32 9a fd			ld (debug_mark+1),a  
5429 3a 33 54			ld a, (.dmark+2)  
542c 32 9b fd			ld (debug_mark+2),a  
542f 18 03			jr .pastdmark  
5431 ..			.dmark: db "ACC"  
5434 f1			.pastdmark: pop af  
5435			endm  
# End of macro DMARK
5435						CALLMONITOR 
5435 cd a6 fd			call debug_vector  
5438				endm  
# End of macro CALLMONITOR
5438					endif 
5438 21 ed f2				ld hl, os_input 
543b			;		ld a, 0 
543b 36 00				ld (hl),0 
543d 3a 8c f9				ld a,(f_cursor_ptr) 
5440 16 64				ld d, 100 
5442 0e 00				ld c, 0 
5444 1e 28				ld e, 40 
5446 cd de 0f				call input_str 
5449					; TODO perhaps do a type check and wrap in quotes if not a number 
5449 21 ed f2				ld hl, os_input 
544c					if DEBUG_FORTH_WORDS 
544c						DMARK "AC1" 
544c f5				push af  
544d 3a 61 54			ld a, (.dmark)  
5450 32 99 fd			ld (debug_mark),a  
5453 3a 62 54			ld a, (.dmark+1)  
5456 32 9a fd			ld (debug_mark+1),a  
5459 3a 63 54			ld a, (.dmark+2)  
545c 32 9b fd			ld (debug_mark+2),a  
545f 18 03			jr .pastdmark  
5461 ..			.dmark: db "AC1"  
5464 f1			.pastdmark: pop af  
5465			endm  
# End of macro DMARK
5465						CALLMONITOR 
5465 cd a6 fd			call debug_vector  
5468				endm  
# End of macro CALLMONITOR
5468					endif 
5468 cd 7c 20				call forth_push_str 
546b					NEXTW 
546b cd a3 fd			call parse_vector 
546e c3 f5 23			jp macro_next 
5471				endm 
# End of macro NEXTW
5471			 
5471			.EDIT: 
5471				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
5471 40				db WORD_SYS_CORE+44             
5472 16 55			dw .DEDIT            
5474 05				db 4 + 1 
5475 .. 00			db "EDIT",0              
547a				endm 
# End of macro CWHEAD
547a			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
547a			 
547a					; TODO does not copy from stack 
547a					if DEBUG_FORTH_WORDS_KEY 
547a						DMARK "EDT" 
547a f5				push af  
547b 3a 8f 54			ld a, (.dmark)  
547e 32 99 fd			ld (debug_mark),a  
5481 3a 90 54			ld a, (.dmark+1)  
5484 32 9a fd			ld (debug_mark+1),a  
5487 3a 91 54			ld a, (.dmark+2)  
548a 32 9b fd			ld (debug_mark+2),a  
548d 18 03			jr .pastdmark  
548f ..			.dmark: db "EDT"  
5492 f1			.pastdmark: pop af  
5493			endm  
# End of macro DMARK
5493						CALLMONITOR 
5493 cd a6 fd			call debug_vector  
5496				endm  
# End of macro CALLMONITOR
5496					endif 
5496			 
5496					;FORTH_DSP 
5496					FORTH_DSP_VALUEHL 
5496 cd 0e 22			call macro_dsp_valuehl 
5499				endm 
# End of macro FORTH_DSP_VALUEHL
5499			;		inc hl    ; TODO do type check 
5499			 
5499			;		call get_word_hl 
5499 e5					push hl 
549a					if DEBUG_FORTH_WORDS 
549a						DMARK "EDp" 
549a f5				push af  
549b 3a af 54			ld a, (.dmark)  
549e 32 99 fd			ld (debug_mark),a  
54a1 3a b0 54			ld a, (.dmark+1)  
54a4 32 9a fd			ld (debug_mark+1),a  
54a7 3a b1 54			ld a, (.dmark+2)  
54aa 32 9b fd			ld (debug_mark+2),a  
54ad 18 03			jr .pastdmark  
54af ..			.dmark: db "EDp"  
54b2 f1			.pastdmark: pop af  
54b3			endm  
# End of macro DMARK
54b3						CALLMONITOR 
54b3 cd a6 fd			call debug_vector  
54b6				endm  
# End of macro CALLMONITOR
54b6					endif 
54b6				;	ld a, 0 
54b6 cd 09 13				call strlenz 
54b9 23					inc hl 
54ba			 
54ba 06 00				ld b, 0 
54bc 4d					ld c, l 
54bd			 
54bd e1					pop hl 
54be 11 ed f2				ld de, os_input 
54c1					if DEBUG_FORTH_WORDS_KEY 
54c1						DMARK "EDc" 
54c1 f5				push af  
54c2 3a d6 54			ld a, (.dmark)  
54c5 32 99 fd			ld (debug_mark),a  
54c8 3a d7 54			ld a, (.dmark+1)  
54cb 32 9a fd			ld (debug_mark+1),a  
54ce 3a d8 54			ld a, (.dmark+2)  
54d1 32 9b fd			ld (debug_mark+2),a  
54d4 18 03			jr .pastdmark  
54d6 ..			.dmark: db "EDc"  
54d9 f1			.pastdmark: pop af  
54da			endm  
# End of macro DMARK
54da						CALLMONITOR 
54da cd a6 fd			call debug_vector  
54dd				endm  
# End of macro CALLMONITOR
54dd					endif 
54dd ed b0				ldir 
54df			 
54df			 
54df 21 ed f2				ld hl, os_input 
54e2					;ld a, 0 
54e2					;ld (hl),a 
54e2 3a 8c f9				ld a,(f_cursor_ptr) 
54e5 16 64				ld d, 100 
54e7 0e 00				ld c, 0 
54e9 1e 28				ld e, 40 
54eb cd de 0f				call input_str 
54ee					; TODO perhaps do a type check and wrap in quotes if not a number 
54ee 21 ed f2				ld hl, os_input 
54f1					if DEBUG_FORTH_WORDS 
54f1						DMARK "ED1" 
54f1 f5				push af  
54f2 3a 06 55			ld a, (.dmark)  
54f5 32 99 fd			ld (debug_mark),a  
54f8 3a 07 55			ld a, (.dmark+1)  
54fb 32 9a fd			ld (debug_mark+1),a  
54fe 3a 08 55			ld a, (.dmark+2)  
5501 32 9b fd			ld (debug_mark+2),a  
5504 18 03			jr .pastdmark  
5506 ..			.dmark: db "ED1"  
5509 f1			.pastdmark: pop af  
550a			endm  
# End of macro DMARK
550a						CALLMONITOR 
550a cd a6 fd			call debug_vector  
550d				endm  
# End of macro CALLMONITOR
550d					endif 
550d cd 7c 20				call forth_push_str 
5510					NEXTW 
5510 cd a3 fd			call parse_vector 
5513 c3 f5 23			jp macro_next 
5516				endm 
# End of macro NEXTW
5516			 
5516			.DEDIT: 
5516				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
5516 40				db WORD_SYS_CORE+44             
5517 7b 55			dw .ENDKEY            
5519 06				db 5 + 1 
551a .. 00			db "DEDIT",0              
5520				endm 
# End of macro CWHEAD
5520			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
5520			 
5520					; TODO does not copy from stack 
5520					if DEBUG_FORTH_WORDS_KEY 
5520						DMARK "DED" 
5520 f5				push af  
5521 3a 35 55			ld a, (.dmark)  
5524 32 99 fd			ld (debug_mark),a  
5527 3a 36 55			ld a, (.dmark+1)  
552a 32 9a fd			ld (debug_mark+1),a  
552d 3a 37 55			ld a, (.dmark+2)  
5530 32 9b fd			ld (debug_mark+2),a  
5533 18 03			jr .pastdmark  
5535 ..			.dmark: db "DED"  
5538 f1			.pastdmark: pop af  
5539			endm  
# End of macro DMARK
5539						CALLMONITOR 
5539 cd a6 fd			call debug_vector  
553c				endm  
# End of macro CALLMONITOR
553c					endif 
553c			 
553c					;FORTH_DSP 
553c					FORTH_DSP_VALUEHL 
553c cd 0e 22			call macro_dsp_valuehl 
553f				endm 
# End of macro FORTH_DSP_VALUEHL
553f			;		inc hl    ; TODO do type check 
553f			 
553f			;		call get_word_hl 
553f e5					push hl 
5540 e5					push hl 
5541					FORTH_DSP_POP 
5541 cd c6 22			call macro_forth_dsp_pop 
5544				endm 
# End of macro FORTH_DSP_POP
5544 e1					pop hl 
5545					if DEBUG_FORTH_WORDS 
5545						DMARK "EDp" 
5545 f5				push af  
5546 3a 5a 55			ld a, (.dmark)  
5549 32 99 fd			ld (debug_mark),a  
554c 3a 5b 55			ld a, (.dmark+1)  
554f 32 9a fd			ld (debug_mark+1),a  
5552 3a 5c 55			ld a, (.dmark+2)  
5555 32 9b fd			ld (debug_mark+2),a  
5558 18 03			jr .pastdmark  
555a ..			.dmark: db "EDp"  
555d f1			.pastdmark: pop af  
555e			endm  
# End of macro DMARK
555e						CALLMONITOR 
555e cd a6 fd			call debug_vector  
5561				endm  
# End of macro CALLMONITOR
5561					endif 
5561				;	ld a, 0 
5561 cd 09 13				call strlenz 
5564 23					inc hl 
5565			 
5565 06 00				ld b, 0 
5567 4d					ld c, l 
5568			 
5568 e1					pop hl 
5569			 
5569					;ld a, 0 
5569					;ld (hl),a 
5569 3a 8c f9				ld a,(f_cursor_ptr) 
556c 16 64				ld d, 100 
556e 0e 00				ld c, 0 
5570 1e 28				ld e, 40 
5572 cd de 0f				call input_str 
5575					; TODO perhaps do a type check and wrap in quotes if not a number 
5575					NEXTW 
5575 cd a3 fd			call parse_vector 
5578 c3 f5 23			jp macro_next 
557b				endm 
# End of macro NEXTW
557b			 
557b			 
557b			.ENDKEY: 
557b			; eof 
557b			 
# End of file forth_words_key.asm
557b			include "forth_words_const.asm" 
557b			 
557b			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
557b			 
557b			 
557b			.SPITIME: 
557b				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
557b 77				db WORD_SYS_CORE+99             
557c 93 55			dw .VA            
557e 08				db 7 + 1 
557f .. 00			db "SPITIME",0              
5587				endm 
# End of macro CWHEAD
5587			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
5587			; 
5587			; | | If using BANK devices then leave as is. 
5587			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
5587			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
5587			 
5587 21 92 f9				ld hl, spi_clktime  
558a cd 12 20				call forth_push_numhl 
558d			 
558d					NEXTW 
558d cd a3 fd			call parse_vector 
5590 c3 f5 23			jp macro_next 
5593				endm 
# End of macro NEXTW
5593			 
5593			 
5593			.VA: 
5593				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
5593 77				db WORD_SYS_CORE+99             
5594 a6 55			dw .SYMBOL            
5596 03				db 2 + 1 
5597 .. 00			db "VA",0              
559a				endm 
# End of macro CWHEAD
559a			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
559a 21 56 f9				ld hl, cli_var_array 
559d cd 12 20				call forth_push_numhl 
55a0			 
55a0					NEXTW 
55a0 cd a3 fd			call parse_vector 
55a3 c3 f5 23			jp macro_next 
55a6				endm 
# End of macro NEXTW
55a6			 
55a6			.SYMBOL: 
55a6				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
55a6 77				db WORD_SYS_CORE+99             
55a7 b5 56			dw .ENDCONST            
55a9 07				db 6 + 1 
55aa .. 00			db "SYMBOL",0              
55b1				endm 
# End of macro CWHEAD
55b1			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
55b1			; | 
55b1			; | | The value is the number reference and the final address is pushed to stack 
55b1			 
55b1			; | | ``` 
55b1			; | | dw sym_table 
55b1			; | | dw nmi_vector 
55b1			; | | dw cli_autodisplay 
55b1			; | | dw cli_data_sp 
55b1			; | | dw cli_data_stack 
55b1			; | | dw cli_loop_sp 
55b1			; | | dw cli_loop_stack 
55b1			; | | dw cli_var_array 
55b1			; | | dw cursor_col 
55b1			; | | dw cursor_ptr 
55b1			; | | ; 10 
55b1			; | | dw cursor_row 
55b1			; | | dw debug_mark 
55b1			; | | dw display_fb0 
55b1			; | | dw display_fb1 
55b1			; | | dw display_fb2 
55b1			; | | dw display_fb3 
55b1			; | | dw display_fb_active 
55b1			; | | dw execscratch 
55b1			; | | dw f_cursor_ptr 
55b1			; | | dw hardware_word 
55b1			; | | ;20 
55b1			; | | dw input_at_cursor 
55b1			; | | dw input_at_pos 
55b1			; | | dw input_cur_flash 
55b1			; | | dw input_cur_onoff 
55b1			; | | dw input_cursor 
55b1			; | | dw input_display_size 
55b1			; | | dw input_len 
55b1			; | | dw input_ptr 
55b1			; | | dw input_size 
55b1			; | | dw input_start 
55b1			; | | ; 30 
55b1			; | | dw input_str 
55b1			; | | dw input_under_cursor 
55b1			; | | dw os_cli_cmd 
55b1			; | | dw os_cur_ptr 
55b1			; | | dw os_current_i 
55b1			; | | dw os_input 
55b1			; | | dw os_last_cmd 
55b1			; | | dw os_last_new_uword 
55b1			; | | dw debug_vector 
55b1			; | | dw os_view_hl 
55b1			; | | ;40 
55b1			; | | dw os_word_scratch 
55b1			; | | dw portbctl 
55b1			; | | dw portbdata 
55b1			; | | dw spi_cartdev 
55b1			; | | dw spi_cartdev2 
55b1			; | | dw spi_clktime 
55b1			; | | dw spi_device 
55b1			; | | dw spi_device_id 
55b1			; | | dw spi_portbyte 
55b1			; | | dw stackstore 
55b1			; | | ; 50 
55b1			; | | if STORAGE_SE 
55b1			; | | dw storage_actl 
55b1			; | | dw storage_adata 
55b1			; | | else 
55b1			; | | dw 0 
55b1			; | | dw 0 
55b1			; | | endif 
55b1			; | | dw storage_append 
55b1			; | | if STORAGE_SE 
55b1			; | | dw storage_bctl 
55b1			; | | else 
55b1			; | | dw 0 
55b1			; | | endif 
55b1			; | | dw store_bank_active 
55b1			; | | dw store_filecache 
55b1			; | | dw store_longread 
55b1			; | | dw store_openaddr 
55b1			; | | dw store_openext 
55b1			; | | dw store_openmaxext 
55b1			; | | ; 60 
55b1			; | | dw store_page 
55b1			; | | dw store_readbuf 
55b1			; | | dw store_readcont 
55b1			; | | dw store_readptr 
55b1			; | | dw store_tmpext 
55b1			; | | dw store_tmpid 
55b1			; | | dw store_tmppageid 
55b1			; | | dw malloc 
55b1			; | | dw free 
55b1			; | | dw cin 
55b1			; | | ; 70 
55b1			; | | dw cin_wait 
55b1			; | | dw forth_push_numhl 
55b1			; | | dw forth_push_str 
55b1			; | | dw parse_vector 
55b1			; | | ``` 
55b1			 
55b1					if DEBUG_FORTH_WORDS_KEY 
55b1						DMARK "SYM" 
55b1 f5				push af  
55b2 3a c6 55			ld a, (.dmark)  
55b5 32 99 fd			ld (debug_mark),a  
55b8 3a c7 55			ld a, (.dmark+1)  
55bb 32 9a fd			ld (debug_mark+1),a  
55be 3a c8 55			ld a, (.dmark+2)  
55c1 32 9b fd			ld (debug_mark+2),a  
55c4 18 03			jr .pastdmark  
55c6 ..			.dmark: db "SYM"  
55c9 f1			.pastdmark: pop af  
55ca			endm  
# End of macro DMARK
55ca						CALLMONITOR 
55ca cd a6 fd			call debug_vector  
55cd				endm  
# End of macro CALLMONITOR
55cd					endif 
55cd			 
55cd					FORTH_DSP_VALUEHL 
55cd cd 0e 22			call macro_dsp_valuehl 
55d0				endm 
# End of macro FORTH_DSP_VALUEHL
55d0			 
55d0 7d					ld a, l     
55d1			 
55d1			 
55d1					if DEBUG_FORTH_WORDS 
55d1						DMARK "SY1" 
55d1 f5				push af  
55d2 3a e6 55			ld a, (.dmark)  
55d5 32 99 fd			ld (debug_mark),a  
55d8 3a e7 55			ld a, (.dmark+1)  
55db 32 9a fd			ld (debug_mark+1),a  
55de 3a e8 55			ld a, (.dmark+2)  
55e1 32 9b fd			ld (debug_mark+2),a  
55e4 18 03			jr .pastdmark  
55e6 ..			.dmark: db "SY1"  
55e9 f1			.pastdmark: pop af  
55ea			endm  
# End of macro DMARK
55ea						CALLMONITOR 
55ea cd a6 fd			call debug_vector  
55ed				endm  
# End of macro CALLMONITOR
55ed					endif 
55ed					 
55ed f5					push af	 
55ee					FORTH_DSP_POP 
55ee cd c6 22			call macro_forth_dsp_pop 
55f1				endm 
# End of macro FORTH_DSP_POP
55f1 f1					pop af 
55f2			 
55f2 cb 27				sla a  
55f4				 
55f4					 
55f4					if DEBUG_FORTH_WORDS 
55f4						DMARK "SY" 
55f4 f5				push af  
55f5 3a 09 56			ld a, (.dmark)  
55f8 32 99 fd			ld (debug_mark),a  
55fb 3a 0a 56			ld a, (.dmark+1)  
55fe 32 9a fd			ld (debug_mark+1),a  
5601 3a 0b 56			ld a, (.dmark+2)  
5604 32 9b fd			ld (debug_mark+2),a  
5607 18 02			jr .pastdmark  
5609 ..			.dmark: db "SY"  
560b f1			.pastdmark: pop af  
560c			endm  
# End of macro DMARK
560c						CALLMONITOR 
560c cd a6 fd			call debug_vector  
560f				endm  
# End of macro CALLMONITOR
560f					endif 
560f			 
560f 21 21 56				ld hl, sym_table 
5612 cd b1 0f				call addatohl 
5615 cd 7b 23				call loadwordinhl 
5618 cd 12 20				call forth_push_numhl 
561b			 
561b			 
561b				       NEXTW 
561b cd a3 fd			call parse_vector 
561e c3 f5 23			jp macro_next 
5621				endm 
# End of macro NEXTW
5621			 
5621			sym_table: 
5621			 
5621			; 0 
5621 21 56		dw sym_table 
5623 a9 fd		dw nmi_vector 
5625 6a f9		dw cli_autodisplay 
5627 1c f9		dw cli_data_sp 
5629 56 f6		dw cli_data_stack 
562b 1e f9		dw cli_loop_sp 
562d 58 f8		dw cli_loop_stack 
562f 56 f9		dw cli_var_array 
5631 f3 fa		dw cursor_col 
5633 f1 fa		dw cursor_ptr 
5635			; 10 
5635 f2 fa		dw cursor_row 
5637 99 fd		dw debug_mark 
5639 df fc		dw display_fb0 
563b 3e fc		dw display_fb1 
563d fc fa		dw display_fb2 
563f 9d fb		dw display_fb3 
5641 fa fa		dw display_fb_active 
5643 ee f1		dw execscratch 
5645 8c f9		dw f_cursor_ptr 
5647 ac fd		dw hardware_word 
5649			;20 
5649 90 fd		dw input_at_cursor 
564b 92 fd		dw input_at_pos 
564d 8e fd		dw input_cur_flash 
564f 8d fd		dw input_cur_onoff 
5651 83 fd		dw input_cursor 
5653 93 fd		dw input_display_size 
5655 88 fd		dw input_len 
5657 97 fd		dw input_ptr 
5659 94 fd		dw input_size 
565b 95 fd		dw input_start 
565d			; 30 
565d de 0f		dw input_str 
565f 91 fd		dw input_under_cursor 
5661 16 f4		dw os_cli_cmd 
5663 12 f4		dw os_cur_ptr 
5665 14 f4		dw os_current_i 
5667 ed f2		dw os_input 
5669 15 f5		dw os_last_cmd 
566b ec f3		dw os_last_new_uword 
566d a6 fd		dw debug_vector 
566f d1 f0		dw os_view_hl 
5671			;40 
5671 f4 f3		dw os_word_scratch 
5673 c3 00		dw portbctl 
5675 c1 00		dw portbdata 
5677 91 f9		dw spi_cartdev 
5679 90 f9		dw spi_cartdev2 
567b 92 f9		dw spi_clktime 
567d 8e f9		dw spi_device 
567f 8d f9		dw spi_device_id 
5681 8f f9		dw spi_portbyte 
5683 d5 fa		dw stackstore 
5685			; 50 
5685			if STORAGE_SE 
5685 82 00		dw storage_actl 
5687 80 00		dw storage_adata 
5689			else 
5689			dw 0 
5689			dw 0 
5689			endif 
5689 3b 0b		dw storage_append 
568b			if STORAGE_SE 
568b 83 00		dw storage_bctl 
568d			else 
568d			dw 0 
568d			endif 
568d c1 fa		dw store_bank_active 
568f 95 f9		dw store_filecache 
5691 a3 f9		dw store_longread 
5693 99 f9		dw store_openaddr 
5695 98 f9		dw store_openext 
5697 97 f9		dw store_openmaxext 
5699			; 60 
5699 a8 f9		dw store_page 
569b a4 f9		dw store_readbuf 
569d 9b f9		dw store_readcont 
569f a6 f9		dw store_readptr 
56a1 9b f9		dw store_tmpext 
56a3 9c f9		dw store_tmpid 
56a5 93 f9		dw store_tmppageid 
56a7 7d 13		dw malloc 
56a9 47 14		dw free 
56ab fb 7c		dw cin 
56ad			; 70 
56ad ec 7c		dw cin_wait 
56af 12 20		dw forth_push_numhl 
56b1 7c 20		dw forth_push_str 
56b3 a3 fd		dw parse_vector 
56b5			 
56b5			.ENDCONST: 
56b5			 
56b5			; eof 
56b5			 
56b5			 
# End of file forth_words_const.asm
56b5			 
56b5			if STORAGE_SE 
56b5			   	include "forth_words_storage.asm" 
56b5			 
56b5			; | ## Fixed Storage Words 
56b5			 
56b5			.RENAME: 
56b5			  
56b5				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
56b5 3a				db WORD_SYS_CORE+38             
56b6 ae 57			dw .RECORD            
56b8 07				db 6 + 1 
56b9 .. 00			db "RENAME",0              
56c0				endm 
# End of macro CWHEAD
56c0			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
56c0			; | | > [!NOTE] 
56c0			; | | > Compatible with PicoSPINet  
56c0					if DEBUG_FORTH_WORDS_KEY 
56c0						DMARK "REN" 
56c0 f5				push af  
56c1 3a d5 56			ld a, (.dmark)  
56c4 32 99 fd			ld (debug_mark),a  
56c7 3a d6 56			ld a, (.dmark+1)  
56ca 32 9a fd			ld (debug_mark+1),a  
56cd 3a d7 56			ld a, (.dmark+2)  
56d0 32 9b fd			ld (debug_mark+2),a  
56d3 18 03			jr .pastdmark  
56d5 ..			.dmark: db "REN"  
56d8 f1			.pastdmark: pop af  
56d9			endm  
# End of macro DMARK
56d9						CALLMONITOR 
56d9 cd a6 fd			call debug_vector  
56dc				endm  
# End of macro CALLMONITOR
56dc					endif 
56dc			 
56dc			 
56dc					; preserve some internal vars used by other file handing routines 
56dc			 
56dc 2a 99 f9				ld hl, (store_openaddr) 
56df e5					push hl 
56e0 3a 9b f9				ld a, (store_readcont) 
56e3 f5					push af 
56e4			 
56e4					FORTH_DSP_VALUEHL 
56e4 cd 0e 22			call macro_dsp_valuehl 
56e7				endm 
# End of macro FORTH_DSP_VALUEHL
56e7			 
56e7					; move ext and id around for the file header 
56e7			 
56e7 65					ld h, l 
56e8 2e 00				ld l, 0 
56ea			 
56ea e5					push hl    ; id 
56eb			 
56eb					FORTH_DSP_POP 
56eb cd c6 22			call macro_forth_dsp_pop 
56ee				endm 
# End of macro FORTH_DSP_POP
56ee			 
56ee					; Locate the file header 
56ee			 
56ee e1					pop hl 
56ef e5					push hl 
56f0 11 a8 f9				ld de, store_page      ; get block zero of file 
56f3					if DEBUG_FORTH_WORDS 
56f3						DMARK "REr" 
56f3 f5				push af  
56f4 3a 08 57			ld a, (.dmark)  
56f7 32 99 fd			ld (debug_mark),a  
56fa 3a 09 57			ld a, (.dmark+1)  
56fd 32 9a fd			ld (debug_mark+1),a  
5700 3a 0a 57			ld a, (.dmark+2)  
5703 32 9b fd			ld (debug_mark+2),a  
5706 18 03			jr .pastdmark  
5708 ..			.dmark: db "REr"  
570b f1			.pastdmark: pop af  
570c			endm  
# End of macro DMARK
570c						CALLMONITOR 
570c cd a6 fd			call debug_vector  
570f				endm  
# End of macro CALLMONITOR
570f					endif 
570f cd a7 09				call storage_read 
5712			 
5712 cd da 0f			call ishlzero 
5715 20 05			jr nz, .rnfound 
5717			 
5717				; file does not exist so indicate with 255 extents in use 
5717			 
5717 3e ff			ld a, 255 
5719 e1				pop hl ; clear dup hl 
571a 18 7b			jr .skiprneof 
571c			 
571c			 
571c			.rnfound: 
571c					; file found so rename 
571c			 
571c					FORTH_DSP_VALUEHL 
571c cd 0e 22			call macro_dsp_valuehl 
571f				endm 
# End of macro FORTH_DSP_VALUEHL
571f			 
571f e5				push hl 
5720 3e 00			ld a, 0 
5722 cd 14 13			call strlent 
5725 23				inc hl   ; cover zero term 
5726 06 00			ld b,0 
5728 4d				ld c,l 
5729 e1				pop hl 
572a 11 ab f9				ld de, store_page + 3 
572d ed b0				ldir 
572f			 
572f 11 a8 f9				ld de, store_page 
5732					if DEBUG_FORTH_WORDS 
5732						DMARK "RER" 
5732 f5				push af  
5733 3a 47 57			ld a, (.dmark)  
5736 32 99 fd			ld (debug_mark),a  
5739 3a 48 57			ld a, (.dmark+1)  
573c 32 9a fd			ld (debug_mark+1),a  
573f 3a 49 57			ld a, (.dmark+2)  
5742 32 9b fd			ld (debug_mark+2),a  
5745 18 03			jr .pastdmark  
5747 ..			.dmark: db "RER"  
574a f1			.pastdmark: pop af  
574b			endm  
# End of macro DMARK
574b						CALLMONITOR 
574b cd a6 fd			call debug_vector  
574e				endm  
# End of macro CALLMONITOR
574e					endif 
574e			 
574e e1					pop hl    ; get orig file id and mangle it for find id 
574f 55					ld d, l 
5750 5c					ld e, h 
5751			 
5751 21 00 00				ld hl, 0 
5754					if DEBUG_FORTH_WORDS 
5754						DMARK "REf" 
5754 f5				push af  
5755 3a 69 57			ld a, (.dmark)  
5758 32 99 fd			ld (debug_mark),a  
575b 3a 6a 57			ld a, (.dmark+1)  
575e 32 9a fd			ld (debug_mark+1),a  
5761 3a 6b 57			ld a, (.dmark+2)  
5764 32 9b fd			ld (debug_mark+2),a  
5767 18 03			jr .pastdmark  
5769 ..			.dmark: db "REf"  
576c f1			.pastdmark: pop af  
576d			endm  
# End of macro DMARK
576d						CALLMONITOR 
576d cd a6 fd			call debug_vector  
5770				endm  
# End of macro CALLMONITOR
5770					endif 
5770 cd 83 07				call storage_findnextid 
5773 11 a8 f9				ld de, store_page 
5776					if DEBUG_FORTH_WORDS 
5776						DMARK "REw" 
5776 f5				push af  
5777 3a 8b 57			ld a, (.dmark)  
577a 32 99 fd			ld (debug_mark),a  
577d 3a 8c 57			ld a, (.dmark+1)  
5780 32 9a fd			ld (debug_mark+1),a  
5783 3a 8d 57			ld a, (.dmark+2)  
5786 32 9b fd			ld (debug_mark+2),a  
5789 18 03			jr .pastdmark  
578b ..			.dmark: db "REw"  
578e f1			.pastdmark: pop af  
578f			endm  
# End of macro DMARK
578f						CALLMONITOR 
578f cd a6 fd			call debug_vector  
5792				endm  
# End of macro CALLMONITOR
5792					endif 
5792 cd bc 04				call storage_write_block 
5795			 
5795 3e 00				ld a, 0 
5797			.skiprneof: 
5797					; drop file name 
5797					FORTH_DSP_POP 
5797 cd c6 22			call macro_forth_dsp_pop 
579a				endm 
# End of macro FORTH_DSP_POP
579a			 
579a 6f					ld l, a 
579b 26 00				ld h, 0 
579d cd 12 20				call forth_push_numhl 
57a0			 
57a0			 
57a0 f1					pop af 
57a1 32 9b f9				ld (store_readcont),a 
57a4 e1					pop hl 
57a5 22 99 f9				ld (store_openaddr), hl 
57a8						 
57a8				NEXTW 
57a8 cd a3 fd			call parse_vector 
57ab c3 f5 23			jp macro_next 
57ae				endm 
# End of macro NEXTW
57ae			.RECORD: 
57ae			  
57ae				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
57ae 3a				db WORD_SYS_CORE+38             
57af 58 58			dw .BREAD            
57b1 07				db 6 + 1 
57b2 .. 00			db "RECORD",0              
57b9				endm 
# End of macro CWHEAD
57b9			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
57b9			; | | > [!NOTE] 
57b9			; | | > Compatible with PicoSPINet  
57b9			 
57b9					if DEBUG_FORTH_WORDS_KEY 
57b9						DMARK "REC" 
57b9 f5				push af  
57ba 3a ce 57			ld a, (.dmark)  
57bd 32 99 fd			ld (debug_mark),a  
57c0 3a cf 57			ld a, (.dmark+1)  
57c3 32 9a fd			ld (debug_mark+1),a  
57c6 3a d0 57			ld a, (.dmark+2)  
57c9 32 9b fd			ld (debug_mark+2),a  
57cc 18 03			jr .pastdmark  
57ce ..			.dmark: db "REC"  
57d1 f1			.pastdmark: pop af  
57d2			endm  
# End of macro DMARK
57d2						CALLMONITOR 
57d2 cd a6 fd			call debug_vector  
57d5				endm  
# End of macro CALLMONITOR
57d5					endif 
57d5			 
57d5					FORTH_DSP_VALUEHL 
57d5 cd 0e 22			call macro_dsp_valuehl 
57d8				endm 
# End of macro FORTH_DSP_VALUEHL
57d8			 
57d8 e5					push hl    ; id 
57d9			 
57d9					FORTH_DSP_POP 
57d9 cd c6 22			call macro_forth_dsp_pop 
57dc				endm 
# End of macro FORTH_DSP_POP
57dc			 
57dc					FORTH_DSP_VALUEHL 
57dc cd 0e 22			call macro_dsp_valuehl 
57df				endm 
# End of macro FORTH_DSP_VALUEHL
57df			 
57df					FORTH_DSP_POP 
57df cd c6 22			call macro_forth_dsp_pop 
57e2				endm 
# End of macro FORTH_DSP_POP
57e2			 
57e2 d1					pop de     ; get file id 
57e3			 
57e3					; e = file id 
57e3					; l = file extent 
57e3			 
57e3			 
57e3					; construct request to access file extent 
57e3			 
57e3			;		ld a, e 
57e3 63					ld h, e 
57e4					 
57e4					 
57e4					 
57e4			 
57e4					; e has id 
57e4			 
57e4 11 a8 f9			ld de, store_page 
57e7					if DEBUG_FORTH_WORDS 
57e7						DMARK "REr" 
57e7 f5				push af  
57e8 3a fc 57			ld a, (.dmark)  
57eb 32 99 fd			ld (debug_mark),a  
57ee 3a fd 57			ld a, (.dmark+1)  
57f1 32 9a fd			ld (debug_mark+1),a  
57f4 3a fe 57			ld a, (.dmark+2)  
57f7 32 9b fd			ld (debug_mark+2),a  
57fa 18 03			jr .pastdmark  
57fc ..			.dmark: db "REr"  
57ff f1			.pastdmark: pop af  
5800			endm  
# End of macro DMARK
5800						CALLMONITOR 
5800 cd a6 fd			call debug_vector  
5803				endm  
# End of macro CALLMONITOR
5803					endif 
5803 cd a7 09				call storage_read 
5806 cd da 0f			call ishlzero 
5809 28 25			jr z, .recnotfound 
580b			 
580b			 
580b					if DEBUG_FORTH_WORDS 
580b						DMARK "REe" 
580b f5				push af  
580c 3a 20 58			ld a, (.dmark)  
580f 32 99 fd			ld (debug_mark),a  
5812 3a 21 58			ld a, (.dmark+1)  
5815 32 9a fd			ld (debug_mark+1),a  
5818 3a 22 58			ld a, (.dmark+2)  
581b 32 9b fd			ld (debug_mark+2),a  
581e 18 03			jr .pastdmark  
5820 ..			.dmark: db "REe"  
5823 f1			.pastdmark: pop af  
5824			endm  
# End of macro DMARK
5824						CALLMONITOR 
5824 cd a6 fd			call debug_vector  
5827				endm  
# End of macro CALLMONITOR
5827					endif 
5827 cd 7c 20			call forth_push_str 
582a			 
582a					NEXTW 
582a cd a3 fd			call parse_vector 
582d c3 f5 23			jp macro_next 
5830				endm 
# End of macro NEXTW
5830			 
5830			.recnotfound: 
5830					if DEBUG_FORTH_WORDS 
5830						DMARK "REf" 
5830 f5				push af  
5831 3a 45 58			ld a, (.dmark)  
5834 32 99 fd			ld (debug_mark),a  
5837 3a 46 58			ld a, (.dmark+1)  
583a 32 9a fd			ld (debug_mark+1),a  
583d 3a 47 58			ld a, (.dmark+2)  
5840 32 9b fd			ld (debug_mark+2),a  
5843 18 03			jr .pastdmark  
5845 ..			.dmark: db "REf"  
5848 f1			.pastdmark: pop af  
5849			endm  
# End of macro DMARK
5849						CALLMONITOR 
5849 cd a6 fd			call debug_vector  
584c				endm  
# End of macro CALLMONITOR
584c					endif 
584c 21 ff 00			ld hl, 255 
584f cd 12 20			call forth_push_numhl 
5852				NEXTW 
5852 cd a3 fd			call parse_vector 
5855 c3 f5 23			jp macro_next 
5858				endm 
# End of macro NEXTW
5858			 
5858			 
5858			.BREAD: 
5858			  
5858				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
5858 3a				db WORD_SYS_CORE+38             
5859 de 58			dw .BWRITE            
585b 06				db 5 + 1 
585c .. 00			db "BREAD",0              
5862				endm 
# End of macro CWHEAD
5862			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
5862			; | | > [!NOTE] 
5862			; | | > Compatible with PicoSPINet  
5862				 
5862					if DEBUG_FORTH_WORDS_KEY 
5862						DMARK "BRD" 
5862 f5				push af  
5863 3a 77 58			ld a, (.dmark)  
5866 32 99 fd			ld (debug_mark),a  
5869 3a 78 58			ld a, (.dmark+1)  
586c 32 9a fd			ld (debug_mark+1),a  
586f 3a 79 58			ld a, (.dmark+2)  
5872 32 9b fd			ld (debug_mark+2),a  
5875 18 03			jr .pastdmark  
5877 ..			.dmark: db "BRD"  
587a f1			.pastdmark: pop af  
587b			endm  
# End of macro DMARK
587b						CALLMONITOR 
587b cd a6 fd			call debug_vector  
587e				endm  
# End of macro CALLMONITOR
587e					endif 
587e			 
587e				FORTH_DSP_VALUEHL 
587e cd 0e 22			call macro_dsp_valuehl 
5881				endm 
# End of macro FORTH_DSP_VALUEHL
5881			 
5881				FORTH_DSP_POP 
5881 cd c6 22			call macro_forth_dsp_pop 
5884				endm 
# End of macro FORTH_DSP_POP
5884			 
5884				; calc block address 
5884			 
5884 eb				ex de, hl 
5885 3e 40			ld a, STORE_BLOCK_PHY 
5887 cd 34 0f			call Mult16 
588a			 
588a			 
588a 11 a8 f9			ld de, store_page 
588d			 
588d					if DEBUG_FORTH_WORDS 
588d						DMARK "BR1" 
588d f5				push af  
588e 3a a2 58			ld a, (.dmark)  
5891 32 99 fd			ld (debug_mark),a  
5894 3a a3 58			ld a, (.dmark+1)  
5897 32 9a fd			ld (debug_mark+1),a  
589a 3a a4 58			ld a, (.dmark+2)  
589d 32 9b fd			ld (debug_mark+2),a  
58a0 18 03			jr .pastdmark  
58a2 ..			.dmark: db "BR1"  
58a5 f1			.pastdmark: pop af  
58a6			endm  
# End of macro DMARK
58a6						CALLMONITOR 
58a6 cd a6 fd			call debug_vector  
58a9				endm  
# End of macro CALLMONITOR
58a9					endif 
58a9			 
58a9 cd 57 04			call storage_read_block 
58ac			 
58ac cd da 0f			call ishlzero 
58af 20 05			jr nz, .brfound 
58b1			 
58b1 cd 12 20			call forth_push_numhl 
58b4 18 22			jr .brdone 
58b6			 
58b6			 
58b6			.brfound: 
58b6 21 aa f9		        ld hl, store_page+2 
58b9			 
58b9					if DEBUG_FORTH_WORDS 
58b9						DMARK "BR2" 
58b9 f5				push af  
58ba 3a ce 58			ld a, (.dmark)  
58bd 32 99 fd			ld (debug_mark),a  
58c0 3a cf 58			ld a, (.dmark+1)  
58c3 32 9a fd			ld (debug_mark+1),a  
58c6 3a d0 58			ld a, (.dmark+2)  
58c9 32 9b fd			ld (debug_mark+2),a  
58cc 18 03			jr .pastdmark  
58ce ..			.dmark: db "BR2"  
58d1 f1			.pastdmark: pop af  
58d2			endm  
# End of macro DMARK
58d2						CALLMONITOR 
58d2 cd a6 fd			call debug_vector  
58d5				endm  
# End of macro CALLMONITOR
58d5					endif 
58d5			 
58d5 cd 7c 20			call forth_push_str 
58d8			 
58d8			 
58d8			.brdone: 
58d8			 
58d8					NEXTW 
58d8 cd a3 fd			call parse_vector 
58db c3 f5 23			jp macro_next 
58de				endm 
# End of macro NEXTW
58de			.BWRITE: 
58de				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
58de 3a				db WORD_SYS_CORE+38             
58df 76 59			dw .BUPD            
58e1 07				db 6 + 1 
58e2 .. 00			db "BWRITE",0              
58e9				endm 
# End of macro CWHEAD
58e9			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
58e9			; | | > [!NOTE] 
58e9			; | | > Compatible with PicoSPINet  
58e9			 
58e9					if DEBUG_FORTH_WORDS_KEY 
58e9						DMARK "BWR" 
58e9 f5				push af  
58ea 3a fe 58			ld a, (.dmark)  
58ed 32 99 fd			ld (debug_mark),a  
58f0 3a ff 58			ld a, (.dmark+1)  
58f3 32 9a fd			ld (debug_mark+1),a  
58f6 3a 00 59			ld a, (.dmark+2)  
58f9 32 9b fd			ld (debug_mark+2),a  
58fc 18 03			jr .pastdmark  
58fe ..			.dmark: db "BWR"  
5901 f1			.pastdmark: pop af  
5902			endm  
# End of macro DMARK
5902						CALLMONITOR 
5902 cd a6 fd			call debug_vector  
5905				endm  
# End of macro CALLMONITOR
5905					endif 
5905			 
5905				FORTH_DSP_VALUEHL 
5905 cd 0e 22			call macro_dsp_valuehl 
5908				endm 
# End of macro FORTH_DSP_VALUEHL
5908			 
5908				; calc block address 
5908			 
5908 eb				ex de, hl 
5909 3e 40			ld a, STORE_BLOCK_PHY 
590b cd 34 0f			call Mult16 
590e			 
590e e5				push hl         ; address 
590f			 
590f				FORTH_DSP_POP 
590f cd c6 22			call macro_forth_dsp_pop 
5912				endm 
# End of macro FORTH_DSP_POP
5912			 
5912				FORTH_DSP_VALUEHL 
5912 cd 0e 22			call macro_dsp_valuehl 
5915				endm 
# End of macro FORTH_DSP_VALUEHL
5915			 
5915				FORTH_DSP_POP 
5915 cd c6 22			call macro_forth_dsp_pop 
5918				endm 
# End of macro FORTH_DSP_POP
5918			 
5918 cd 84 0c			call storage_clear_page 
591b			 
591b				; copy string to store page 
591b			 
591b e5				push hl     ; save string address 
591c			 
591c 3e 00			ld a, 0 
591e cd 14 13			call strlent 
5921			 
5921 23				inc hl 
5922			 
5922 4d				ld c, l 
5923 06 00			ld b, 0 
5925			 
5925 e1				pop hl 
5926 11 aa f9			ld de, store_page + 2 
5929					if DEBUG_FORTH_WORDS 
5929						DMARK "BW1" 
5929 f5				push af  
592a 3a 3e 59			ld a, (.dmark)  
592d 32 99 fd			ld (debug_mark),a  
5930 3a 3f 59			ld a, (.dmark+1)  
5933 32 9a fd			ld (debug_mark+1),a  
5936 3a 40 59			ld a, (.dmark+2)  
5939 32 9b fd			ld (debug_mark+2),a  
593c 18 03			jr .pastdmark  
593e ..			.dmark: db "BW1"  
5941 f1			.pastdmark: pop af  
5942			endm  
# End of macro DMARK
5942						CALLMONITOR 
5942 cd a6 fd			call debug_vector  
5945				endm  
# End of macro CALLMONITOR
5945					endif 
5945 ed b0			ldir 
5947			 
5947			 
5947				; poke the start of the block with flags to prevent high level file ops hitting the block 
5947			 
5947 21 ff ff			ld hl, $ffff 
594a			 
594a 22 a8 f9			ld (store_page), hl	 
594d				 
594d e1				pop hl    ; get address 
594e 11 a8 f9			ld de, store_page 
5951			 
5951					if DEBUG_FORTH_WORDS 
5951						DMARK "BW2" 
5951 f5				push af  
5952 3a 66 59			ld a, (.dmark)  
5955 32 99 fd			ld (debug_mark),a  
5958 3a 67 59			ld a, (.dmark+1)  
595b 32 9a fd			ld (debug_mark+1),a  
595e 3a 68 59			ld a, (.dmark+2)  
5961 32 9b fd			ld (debug_mark+2),a  
5964 18 03			jr .pastdmark  
5966 ..			.dmark: db "BW2"  
5969 f1			.pastdmark: pop af  
596a			endm  
# End of macro DMARK
596a						CALLMONITOR 
596a cd a6 fd			call debug_vector  
596d				endm  
# End of macro CALLMONITOR
596d					endif 
596d			 
596d cd bc 04			call storage_write_block 
5970			 
5970					NEXTW 
5970 cd a3 fd			call parse_vector 
5973 c3 f5 23			jp macro_next 
5976				endm 
# End of macro NEXTW
5976			 
5976			.BUPD: 
5976				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
5976 3a				db WORD_SYS_CORE+38             
5977 cf 59			dw .BYID            
5979 05				db 4 + 1 
597a .. 00			db "BUPD",0              
597f				endm 
# End of macro CWHEAD
597f			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
597f			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
597f			; | | or completely different file system structure. 
597f			; | | > [!NOTE] 
597f			; | | > Compatible with PicoSPINet  
597f			 
597f					if DEBUG_FORTH_WORDS_KEY 
597f						DMARK "BUD" 
597f f5				push af  
5980 3a 94 59			ld a, (.dmark)  
5983 32 99 fd			ld (debug_mark),a  
5986 3a 95 59			ld a, (.dmark+1)  
5989 32 9a fd			ld (debug_mark+1),a  
598c 3a 96 59			ld a, (.dmark+2)  
598f 32 9b fd			ld (debug_mark+2),a  
5992 18 03			jr .pastdmark  
5994 ..			.dmark: db "BUD"  
5997 f1			.pastdmark: pop af  
5998			endm  
# End of macro DMARK
5998						CALLMONITOR 
5998 cd a6 fd			call debug_vector  
599b				endm  
# End of macro CALLMONITOR
599b					endif 
599b			 
599b				FORTH_DSP_VALUEHL 
599b cd 0e 22			call macro_dsp_valuehl 
599e				endm 
# End of macro FORTH_DSP_VALUEHL
599e			 
599e				; calc block address 
599e			 
599e eb				ex de, hl 
599f 3e 40			ld a, STORE_BLOCK_PHY 
59a1 cd 34 0f			call Mult16 
59a4			 
59a4				FORTH_DSP_POP 
59a4 cd c6 22			call macro_forth_dsp_pop 
59a7				endm 
# End of macro FORTH_DSP_POP
59a7			 
59a7			 
59a7 11 a8 f9			ld de, store_page 
59aa			 
59aa					if DEBUG_FORTH_WORDS 
59aa						DMARK "BUe" 
59aa f5				push af  
59ab 3a bf 59			ld a, (.dmark)  
59ae 32 99 fd			ld (debug_mark),a  
59b1 3a c0 59			ld a, (.dmark+1)  
59b4 32 9a fd			ld (debug_mark+1),a  
59b7 3a c1 59			ld a, (.dmark+2)  
59ba 32 9b fd			ld (debug_mark+2),a  
59bd 18 03			jr .pastdmark  
59bf ..			.dmark: db "BUe"  
59c2 f1			.pastdmark: pop af  
59c3			endm  
# End of macro DMARK
59c3						CALLMONITOR 
59c3 cd a6 fd			call debug_vector  
59c6				endm  
# End of macro CALLMONITOR
59c6					endif 
59c6			 
59c6 cd bc 04			call storage_write_block 
59c9			 
59c9					NEXTW 
59c9 cd a3 fd			call parse_vector 
59cc c3 f5 23			jp macro_next 
59cf				endm 
# End of macro NEXTW
59cf			 
59cf			.BYID: 
59cf			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
59cf			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
59cf			; 
59cf			;		 
59cf			;		if DEBUG_FORTH_WORDS_KEY 
59cf			;			DMARK "BYID" 
59cf			;			CALLMONITOR 
59cf			;		endif 
59cf			; 
59cf			;		; get direct address 
59cf			; 
59cf			;		FORTH_DSP_VALUEHL 
59cf			; 
59cf			;		FORTH_DSP_POP 
59cf			; 
59cf			;	; calc block address 
59cf			; 
59cf			;	ex de, hl 
59cf			;	ld a, STORE_BLOCK_PHY 
59cf			;	call Mult16 
59cf			;	;	do BREAD with number as param 
59cf			;	; push the file name	 
59cf			;	ld de, store_page 
59cf			;	call storage_read_block 
59cf			 ;       ld hl, store_page+2 
59cf			; 
59cf			; 
59cf			;		NEXTW 
59cf			;.BYNAME: 
59cf				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
59cf 3a				db WORD_SYS_CORE+38             
59d0 eb 59			dw .DIR            
59d2 06				db 5 + 1 
59d3 .. 00			db "GETID",0              
59d9				endm 
# End of macro CWHEAD
59d9			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
59d9			; | | > [!NOTE] 
59d9			; | | > Compatible with PicoSPINet  
59d9			 
59d9					; get pointer to file name to seek 
59d9			 
59d9					FORTH_DSP_VALUEHL 
59d9 cd 0e 22			call macro_dsp_valuehl 
59dc				endm 
# End of macro FORTH_DSP_VALUEHL
59dc			 
59dc			 
59dc cd 7e 03				call storage_getid  
59df			 
59df					FORTH_DSP_POP 
59df cd c6 22			call macro_forth_dsp_pop 
59e2				endm 
# End of macro FORTH_DSP_POP
59e2			 
59e2 cd 12 20				call forth_push_numhl 
59e5			 
59e5					NEXTW 
59e5 cd a3 fd			call parse_vector 
59e8 c3 f5 23			jp macro_next 
59eb				endm 
# End of macro NEXTW
59eb			; 
59eb			.DIR: 
59eb				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
59eb 3a				db WORD_SYS_CORE+38             
59ec f2 5a			dw .SAVE            
59ee 04				db 3 + 1 
59ef .. 00			db "DIR",0              
59f3				endm 
# End of macro CWHEAD
59f3			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
59f3			; | | > [!NOTE] 
59f3			; | | > Compatible with PicoSPINet  
59f3			 
59f3					if DEBUG_FORTH_WORDS_KEY 
59f3						DMARK "DIR" 
59f3 f5				push af  
59f4 3a 08 5a			ld a, (.dmark)  
59f7 32 99 fd			ld (debug_mark),a  
59fa 3a 09 5a			ld a, (.dmark+1)  
59fd 32 9a fd			ld (debug_mark+1),a  
5a00 3a 0a 5a			ld a, (.dmark+2)  
5a03 32 9b fd			ld (debug_mark+2),a  
5a06 18 03			jr .pastdmark  
5a08 ..			.dmark: db "DIR"  
5a0b f1			.pastdmark: pop af  
5a0c			endm  
# End of macro DMARK
5a0c						CALLMONITOR 
5a0c cd a6 fd			call debug_vector  
5a0f				endm  
# End of macro CALLMONITOR
5a0f					endif 
5a0f cd 05 05			call storage_get_block_0 
5a12			 
5a12 21 a8 f9			ld hl, store_page     ; get current id count 
5a15 46				ld b, (hl) 
5a16 0e 00			ld c, 0    ; count of files   
5a18					if DEBUG_FORTH_WORDS 
5a18						DMARK "DI1" 
5a18 f5				push af  
5a19 3a 2d 5a			ld a, (.dmark)  
5a1c 32 99 fd			ld (debug_mark),a  
5a1f 3a 2e 5a			ld a, (.dmark+1)  
5a22 32 9a fd			ld (debug_mark+1),a  
5a25 3a 2f 5a			ld a, (.dmark+2)  
5a28 32 9b fd			ld (debug_mark+2),a  
5a2b 18 03			jr .pastdmark  
5a2d ..			.dmark: db "DI1"  
5a30 f1			.pastdmark: pop af  
5a31			endm  
# End of macro DMARK
5a31						CALLMONITOR 
5a31 cd a6 fd			call debug_vector  
5a34				endm  
# End of macro CALLMONITOR
5a34					endif 
5a34			 
5a34				; check for empty drive 
5a34			 
5a34 3e 00			ld a, 0 
5a36 b8				cp b 
5a37 ca a5 5a			jp z, .dirdone 
5a3a			 
5a3a				; for each of the current ids do a search for them and if found push to stack 
5a3a			 
5a3a c5			.diritem:	push bc 
5a3b 21 40 00				ld hl, STORE_BLOCK_PHY 
5a3e 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5a40 58					ld e,b 
5a41			 
5a41			;		if DEBUG_FORTH_WORDS 
5a41			;			DMARK "DI2" 
5a41			;			CALLMONITOR 
5a41			;		endif 
5a41			 
5a41 cd 83 07				call storage_findnextid 
5a44			 
5a44			;		if DEBUG_FORTH_WORDS 
5a44			;			DMARK "DI3" 
5a44			;			CALLMONITOR 
5a44			;		endif 
5a44			 
5a44					; if found hl will be non zero 
5a44			 
5a44 cd da 0f				call ishlzero 
5a47			;		ld a, l 
5a47			;		add h 
5a47			; 
5a47			;		cp 0 
5a47 28 59				jr z, .dirnotfound 
5a49			 
5a49					; increase count 
5a49			 
5a49 c1					pop bc	 
5a4a 0c					inc c 
5a4b c5					push bc 
5a4c					 
5a4c			 
5a4c					; get file header and push the file name 
5a4c			 
5a4c 11 a8 f9				ld de, store_page 
5a4f cd 57 04				call storage_read_block 
5a52			 
5a52					; push file id to stack 
5a52				 
5a52 3a a8 f9				ld a, (store_page) 
5a55 26 00				ld h, 0 
5a57 6f					ld l, a 
5a58 cd 12 20				call forth_push_numhl 
5a5b			 
5a5b					; push extent count to stack  
5a5b				 
5a5b 3a aa f9				ld a, (store_page+2) 
5a5e 26 00				ld h, 0 
5a60 6f					ld l, a 
5a61 cd 12 20				call forth_push_numhl 
5a64			 
5a64					; push file name 
5a64			 
5a64 21 ab f9				ld hl, store_page+3 
5a67					if DEBUG_FORTH_WORDS 
5a67						DMARK "DI5" 
5a67 f5				push af  
5a68 3a 7c 5a			ld a, (.dmark)  
5a6b 32 99 fd			ld (debug_mark),a  
5a6e 3a 7d 5a			ld a, (.dmark+1)  
5a71 32 9a fd			ld (debug_mark+1),a  
5a74 3a 7e 5a			ld a, (.dmark+2)  
5a77 32 9b fd			ld (debug_mark+2),a  
5a7a 18 03			jr .pastdmark  
5a7c ..			.dmark: db "DI5"  
5a7f f1			.pastdmark: pop af  
5a80			endm  
# End of macro DMARK
5a80						CALLMONITOR 
5a80 cd a6 fd			call debug_vector  
5a83				endm  
# End of macro CALLMONITOR
5a83					endif 
5a83 cd 7c 20				call forth_push_str 
5a86					if DEBUG_FORTH_WORDS 
5a86						DMARK "DI6" 
5a86 f5				push af  
5a87 3a 9b 5a			ld a, (.dmark)  
5a8a 32 99 fd			ld (debug_mark),a  
5a8d 3a 9c 5a			ld a, (.dmark+1)  
5a90 32 9a fd			ld (debug_mark+1),a  
5a93 3a 9d 5a			ld a, (.dmark+2)  
5a96 32 9b fd			ld (debug_mark+2),a  
5a99 18 03			jr .pastdmark  
5a9b ..			.dmark: db "DI6"  
5a9e f1			.pastdmark: pop af  
5a9f			endm  
# End of macro DMARK
5a9f						CALLMONITOR 
5a9f cd a6 fd			call debug_vector  
5aa2				endm  
# End of macro CALLMONITOR
5aa2					endif 
5aa2			.dirnotfound: 
5aa2 c1					pop bc     
5aa3 10 95				djnz .diritem 
5aa5				 
5aa5			.dirdone:	 
5aa5					if DEBUG_FORTH_WORDS 
5aa5						DMARK "DI7" 
5aa5 f5				push af  
5aa6 3a ba 5a			ld a, (.dmark)  
5aa9 32 99 fd			ld (debug_mark),a  
5aac 3a bb 5a			ld a, (.dmark+1)  
5aaf 32 9a fd			ld (debug_mark+1),a  
5ab2 3a bc 5a			ld a, (.dmark+2)  
5ab5 32 9b fd			ld (debug_mark+2),a  
5ab8 18 03			jr .pastdmark  
5aba ..			.dmark: db "DI7"  
5abd f1			.pastdmark: pop af  
5abe			endm  
# End of macro DMARK
5abe						CALLMONITOR 
5abe cd a6 fd			call debug_vector  
5ac1				endm  
# End of macro CALLMONITOR
5ac1					endif 
5ac1			 
5ac1					; push a count of the dir items found 
5ac1			 
5ac1 26 00				ld h, 0 
5ac3 69					ld l, c 
5ac4 cd 12 20				call forth_push_numhl 
5ac7			 
5ac7					; push the bank label 
5ac7			 
5ac7 cd 05 05				call storage_get_block_0 
5aca			 
5aca				 
5aca 21 ab f9		 		ld hl, store_page+3 
5acd			 
5acd					if DEBUG_FORTH_WORDS 
5acd						DMARK "DI8" 
5acd f5				push af  
5ace 3a e2 5a			ld a, (.dmark)  
5ad1 32 99 fd			ld (debug_mark),a  
5ad4 3a e3 5a			ld a, (.dmark+1)  
5ad7 32 9a fd			ld (debug_mark+1),a  
5ada 3a e4 5a			ld a, (.dmark+2)  
5add 32 9b fd			ld (debug_mark+2),a  
5ae0 18 03			jr .pastdmark  
5ae2 ..			.dmark: db "DI8"  
5ae5 f1			.pastdmark: pop af  
5ae6			endm  
# End of macro DMARK
5ae6						CALLMONITOR 
5ae6 cd a6 fd			call debug_vector  
5ae9				endm  
# End of macro CALLMONITOR
5ae9					endif 
5ae9 cd 7c 20				call forth_push_str 
5aec			 
5aec			 
5aec				 
5aec					NEXTW 
5aec cd a3 fd			call parse_vector 
5aef c3 f5 23			jp macro_next 
5af2				endm 
# End of macro NEXTW
5af2			.SAVE: 
5af2			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
5af2			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
5af2			;		NEXTW 
5af2			;.LOAD: 
5af2			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
5af2			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
5af2			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
5af2			;; > > The LOAD command can not be used in any user words or compound lines. 
5af2			; 
5af2			;		; store_openext use it. If zero it is EOF 
5af2			; 
5af2			;		; read block from current stream id 
5af2			;		; if the block does not contain zero term keep reading blocks until zero found 
5af2			;		; push the block to stack 
5af2			;		; save the block id to stream 
5af2			; 
5af2			; 
5af2			;		FORTH_DSP_VALUEHL 
5af2			; 
5af2			;;		push hl 
5af2			; 
5af2			;	if DEBUG_STORESE 
5af2			;		DMARK "LOA" 
5af2			;		CALLMONITOR 
5af2			;	endif 
5af2			;		FORTH_DSP_POP 
5af2			; 
5af2			;;		pop hl 
5af2			; 
5af2			;		ld h, l 
5af2			;		ld l, 0 
5af2			; 
5af2			;		push hl     ; stack holds current file id and extent to work with 
5af2			; 
5af2			; 
5af2			;		ld de, store_page      ; get block zero of file 
5af2			;	if DEBUG_STORESE 
5af2			;		DMARK "LO0" 
5af2			;		CALLMONITOR 
5af2			;	endif 
5af2			;		call storage_read 
5af2			; 
5af2			;		ld a, (store_page+2)    ; max extents for this file 
5af2			;		ld  (store_openmaxext),a   ; get our limit 
5af2			; 
5af2			;	if DEBUG_STORESE 
5af2			;		DMARK "LOE" 
5af2			;		CALLMONITOR 
5af2			;	endif 
5af2			; 
5af2			;; TODO dont know why max extents are not present 
5af2			;;		cp 0 
5af2			;;		jp z, .loadeof     ; dont read past eof 
5af2			; 
5af2			;;		ld a, 1   ; start from the head of the file 
5af2			; 
5af2			;.loadline:	pop hl 
5af2			;		inc hl 
5af2			;		ld  a, (store_openmaxext)   ; get our limit 
5af2			;	if DEBUG_STORESE 
5af2			;		DMARK "LOx" 
5af2			;		CALLMONITOR 
5af2			;	endif 
5af2			;		inc a 
5af2			;		cp l 
5af2			;		jp z, .loadeof 
5af2			;		push hl    ; save current extent 
5af2			; 
5af2			;		ld de, store_page 
5af2			; 
5af2			;	if DEBUG_STORESE 
5af2			;		DMARK "LO1" 
5af2			;		CALLMONITOR 
5af2			;	endif 
5af2			;		call storage_read 
5af2			; 
5af2			;	if DEBUG_STORESE 
5af2			;		DMARK "LO2" 
5af2			;		CALLMONITOR 
5af2			;	endif 
5af2			;	call ishlzero 
5af2			;	ld a, l 
5af2			;	add h 
5af2			;	cp 0 
5af2			;	jr z, .loadeof 
5af2			; 
5af2			;	; not eof so hl should point to data to exec 
5af2			; 
5af2			;	; will need to add the FORTH_END_BUFFER flag 
5af2			 ; 
5af2			;	ld hl, store_page+2 
5af2			;	ld bc, 255 
5af2			;	ld a, 0 
5af2			;	cpir 
5af2			;	if DEBUG_STORESE 
5af2			;		DMARK "LOt" 
5af2			;		CALLMONITOR 
5af2			;	endif 
5af2			;	dec hl 
5af2			;	ld a, ' ' 
5af2			;	ld (hl), a 
5af2			;	inc hl 
5af2			;	ld (hl), a 
5af2			;	inc hl 
5af2			;	ld (hl), a 
5af2			;	inc hl 
5af2			;	ld a, FORTH_END_BUFFER 
5af2			;	ld (hl), a 
5af2			; 
5af2			;	; TODO handle more than a single block read 
5af2			; 
5af2			; 
5af2			;	ld hl, store_page+2 
5af2			; 
5af2			;	ld (os_tok_ptr), hl 
5af2			; 
5af2			;	if DEBUG_STORESE 
5af2			;		DMARK "LO3" 
5af2			;		CALLMONITOR 
5af2			;	endif 
5af2			; 
5af2			;	call forthparse 
5af2			;	call forthexec 
5af2			;	call forthexec_cleanup 
5af2			; 
5af2			;	; go to next extent 
5af2			; 
5af2			;	; get next block  or mark as eof 
5af2			;	jp .loadline 
5af2			; 
5af2			; 
5af2			; 
5af2			;	       NEXTW 
5af2			;.loadeof:	ld a, 0 
5af2			;		ld (store_openext), a 
5af2			; 
5af2			;	if DEBUG_STORESE 
5af2			;		DMARK "LOF" 
5af2			;		CALLMONITOR 
5af2			;	endif 
5af2			;		ret 
5af2			;		;NEXTW 
5af2			;.BSAVE:   
5af2			; 
5af2			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
5af2			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
5af2			;		NEXTW 
5af2			;.BLOAD: 
5af2			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
5af2			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
5af2			;		NEXTW 
5af2			;;;; counter gap 
5af2			 
5af2			 
5af2			.SEO: 
5af2				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
5af2 64				db WORD_SYS_CORE+80             
5af3 14 5b			dw .SEI            
5af5 04				db 3 + 1 
5af6 .. 00			db "SEO",0              
5afa				endm 
# End of macro CWHEAD
5afa			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5afa			 
5afa					; get port 
5afa			 
5afa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5afa cd 0e 22			call macro_dsp_valuehl 
5afd				endm 
# End of macro FORTH_DSP_VALUEHL
5afd			 
5afd e5					push hl    ; u2 - byte 
5afe			 
5afe					; destroy value TOS 
5afe			 
5afe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5afe cd c6 22			call macro_forth_dsp_pop 
5b01				endm 
# End of macro FORTH_DSP_POP
5b01			 
5b01					; get byte to send 
5b01			 
5b01					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b01 cd 0e 22			call macro_dsp_valuehl 
5b04				endm 
# End of macro FORTH_DSP_VALUEHL
5b04			 
5b04 e5					push hl    ; u1 - addr 
5b05			 
5b05					; destroy value TOS 
5b05			 
5b05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b05 cd c6 22			call macro_forth_dsp_pop 
5b08				endm 
# End of macro FORTH_DSP_POP
5b08			 
5b08					; one value on hl get other one back 
5b08			 
5b08 d1					pop de   ; u1 - byte 
5b09			 
5b09 e1					pop hl   ; u2 - addr 
5b0a			 
5b0a					; TODO Send SPI byte 
5b0a			 
5b0a			 
5b0a 7b					ld a, e 
5b0b cd 65 02				call se_writebyte 
5b0e			 
5b0e					 
5b0e			 
5b0e					NEXTW 
5b0e cd a3 fd			call parse_vector 
5b11 c3 f5 23			jp macro_next 
5b14				endm 
# End of macro NEXTW
5b14			 
5b14			.SEI: 
5b14				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5b14 65				db WORD_SYS_CORE+81             
5b15 31 5b			dw .SFREE            
5b17 04				db 3 + 1 
5b18 .. 00			db "SEI",0              
5b1c				endm 
# End of macro CWHEAD
5b1c			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5b1c			 
5b1c					; get port 
5b1c			 
5b1c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b1c cd 0e 22			call macro_dsp_valuehl 
5b1f				endm 
# End of macro FORTH_DSP_VALUEHL
5b1f			 
5b1f			;		push hl 
5b1f			 
5b1f					; destroy value TOS 
5b1f			 
5b1f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b1f cd c6 22			call macro_forth_dsp_pop 
5b22				endm 
# End of macro FORTH_DSP_POP
5b22			 
5b22					; one value on hl get other one back 
5b22			 
5b22			;		pop hl 
5b22			 
5b22			 
5b22					; TODO Get SPI byte 
5b22			 
5b22 cd ff 02				call se_readbyte 
5b25			 
5b25 26 00				ld h, 0 
5b27 6f					ld l, a 
5b28 cd 12 20				call forth_push_numhl 
5b2b			 
5b2b					NEXTW 
5b2b cd a3 fd			call parse_vector 
5b2e c3 f5 23			jp macro_next 
5b31				endm 
# End of macro NEXTW
5b31			 
5b31			.SFREE: 
5b31				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5b31 67				db WORD_SYS_CORE+83             
5b32 63 5b			dw .SIZE            
5b34 06				db 5 + 1 
5b35 .. 00			db "FFREE",0              
5b3b				endm 
# End of macro CWHEAD
5b3b			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5b3b			; | | > [!NOTE] 
5b3b			; | | > Compatible with PicoSPINet  
5b3b					if DEBUG_FORTH_WORDS_KEY 
5b3b						DMARK "FFR" 
5b3b f5				push af  
5b3c 3a 50 5b			ld a, (.dmark)  
5b3f 32 99 fd			ld (debug_mark),a  
5b42 3a 51 5b			ld a, (.dmark+1)  
5b45 32 9a fd			ld (debug_mark+1),a  
5b48 3a 52 5b			ld a, (.dmark+2)  
5b4b 32 9b fd			ld (debug_mark+2),a  
5b4e 18 03			jr .pastdmark  
5b50 ..			.dmark: db "FFR"  
5b53 f1			.pastdmark: pop af  
5b54			endm  
# End of macro DMARK
5b54						CALLMONITOR 
5b54 cd a6 fd			call debug_vector  
5b57				endm  
# End of macro CALLMONITOR
5b57					endif 
5b57			 
5b57 cd 1d 08				call storage_freeblocks 
5b5a			 
5b5a cd 12 20				call forth_push_numhl 
5b5d			 
5b5d				       NEXTW 
5b5d cd a3 fd			call parse_vector 
5b60 c3 f5 23			jp macro_next 
5b63				endm 
# End of macro NEXTW
5b63			.SIZE: 
5b63				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5b63 67				db WORD_SYS_CORE+83             
5b64 9a 5b			dw .CREATE            
5b66 05				db 4 + 1 
5b67 .. 00			db "SIZE",0              
5b6c				endm 
# End of macro CWHEAD
5b6c			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5b6c			; | | > [!NOTE] 
5b6c			; | | > Compatible with PicoSPINet  
5b6c					if DEBUG_FORTH_WORDS_KEY 
5b6c						DMARK "SIZ" 
5b6c f5				push af  
5b6d 3a 81 5b			ld a, (.dmark)  
5b70 32 99 fd			ld (debug_mark),a  
5b73 3a 82 5b			ld a, (.dmark+1)  
5b76 32 9a fd			ld (debug_mark+1),a  
5b79 3a 83 5b			ld a, (.dmark+2)  
5b7c 32 9b fd			ld (debug_mark+2),a  
5b7f 18 03			jr .pastdmark  
5b81 ..			.dmark: db "SIZ"  
5b84 f1			.pastdmark: pop af  
5b85			endm  
# End of macro DMARK
5b85						CALLMONITOR 
5b85 cd a6 fd			call debug_vector  
5b88				endm  
# End of macro CALLMONITOR
5b88					endif 
5b88			 
5b88					FORTH_DSP_VALUEHL 
5b88 cd 0e 22			call macro_dsp_valuehl 
5b8b				endm 
# End of macro FORTH_DSP_VALUEHL
5b8b			;		push hl 
5b8b					FORTH_DSP_POP 
5b8b cd c6 22			call macro_forth_dsp_pop 
5b8e				endm 
# End of macro FORTH_DSP_POP
5b8e			;		pop hl 
5b8e cd 86 04				call storage_file_size 
5b91			 
5b91 cd 12 20				call forth_push_numhl 
5b94			  
5b94			 
5b94				       NEXTW 
5b94 cd a3 fd			call parse_vector 
5b97 c3 f5 23			jp macro_next 
5b9a				endm 
# End of macro NEXTW
5b9a			 
5b9a			.CREATE: 
5b9a				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
5b9a 68				db WORD_SYS_CORE+84             
5b9b 0b 5c			dw .APPEND            
5b9d 07				db 6 + 1 
5b9e .. 00			db "CREATE",0              
5ba5				endm 
# End of macro CWHEAD
5ba5			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5ba5			; | | e.g.  
5ba5			; | | TestProgram CREATE 
5ba5			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5ba5			; | |  
5ba5			; | | Max file IDs are 255. 
5ba5			; | |  
5ba5			; | | > [!NOTE] 
5ba5			; | | > Compatible with PicoSPINet  
5ba5					 
5ba5					if DEBUG_FORTH_WORDS_KEY 
5ba5						DMARK "CRT" 
5ba5 f5				push af  
5ba6 3a ba 5b			ld a, (.dmark)  
5ba9 32 99 fd			ld (debug_mark),a  
5bac 3a bb 5b			ld a, (.dmark+1)  
5baf 32 9a fd			ld (debug_mark+1),a  
5bb2 3a bc 5b			ld a, (.dmark+2)  
5bb5 32 9b fd			ld (debug_mark+2),a  
5bb8 18 03			jr .pastdmark  
5bba ..			.dmark: db "CRT"  
5bbd f1			.pastdmark: pop af  
5bbe			endm  
# End of macro DMARK
5bbe						CALLMONITOR 
5bbe cd a6 fd			call debug_vector  
5bc1				endm  
# End of macro CALLMONITOR
5bc1					endif 
5bc1			;		call storage_get_block_0 
5bc1			 
5bc1					; TODO pop hl 
5bc1			 
5bc1					;v5 FORTH_DSP_VALUE 
5bc1					FORTH_DSP_VALUE 
5bc1 cd f7 21			call macro_forth_dsp_value 
5bc4				endm 
# End of macro FORTH_DSP_VALUE
5bc4			 
5bc4				if DEBUG_STORESE 
5bc4					DMARK "CR1" 
5bc4 f5				push af  
5bc5 3a d9 5b			ld a, (.dmark)  
5bc8 32 99 fd			ld (debug_mark),a  
5bcb 3a da 5b			ld a, (.dmark+1)  
5bce 32 9a fd			ld (debug_mark+1),a  
5bd1 3a db 5b			ld a, (.dmark+2)  
5bd4 32 9b fd			ld (debug_mark+2),a  
5bd7 18 03			jr .pastdmark  
5bd9 ..			.dmark: db "CR1"  
5bdc f1			.pastdmark: pop af  
5bdd			endm  
# End of macro DMARK
5bdd					CALLMONITOR 
5bdd cd a6 fd			call debug_vector  
5be0				endm  
# End of macro CALLMONITOR
5be0				endif 
5be0			;		push hl 
5be0			;		FORTH_DSP_POP 
5be0			;		pop hl 
5be0			 
5be0			;		inc hl   ; move past the type marker 
5be0			 
5be0 cd 51 08				call storage_create 
5be3			 
5be3				if DEBUG_STORESE 
5be3					DMARK "CT1" 
5be3 f5				push af  
5be4 3a f8 5b			ld a, (.dmark)  
5be7 32 99 fd			ld (debug_mark),a  
5bea 3a f9 5b			ld a, (.dmark+1)  
5bed 32 9a fd			ld (debug_mark+1),a  
5bf0 3a fa 5b			ld a, (.dmark+2)  
5bf3 32 9b fd			ld (debug_mark+2),a  
5bf6 18 03			jr .pastdmark  
5bf8 ..			.dmark: db "CT1"  
5bfb f1			.pastdmark: pop af  
5bfc			endm  
# End of macro DMARK
5bfc					CALLMONITOR 
5bfc cd a6 fd			call debug_vector  
5bff				endm  
# End of macro CALLMONITOR
5bff				endif 
5bff			;		push hl 
5bff					FORTH_DSP_POP 
5bff cd c6 22			call macro_forth_dsp_pop 
5c02				endm 
# End of macro FORTH_DSP_POP
5c02			;		pop hl 
5c02					; push file id to stack 
5c02 cd 12 20				call forth_push_numhl 
5c05			 
5c05			 
5c05			 
5c05				       NEXTW 
5c05 cd a3 fd			call parse_vector 
5c08 c3 f5 23			jp macro_next 
5c0b				endm 
# End of macro NEXTW
5c0b			 
5c0b			.APPEND: 
5c0b				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5c0b 69				db WORD_SYS_CORE+85             
5c0c 9f 5c			dw .SDEL            
5c0e 07				db 6 + 1 
5c0f .. 00			db "APPEND",0              
5c16				endm 
# End of macro CWHEAD
5c16			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5c16			; | | e.g. 
5c16			; | | Test CREATE      -> $01 
5c16			; | | "A string to add to file" $01 APPEND 
5c16			; | |  
5c16			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5c16			; | | > [!NOTE] 
5c16			; | | > Compatible with PicoSPINet  
5c16					if DEBUG_FORTH_WORDS_KEY 
5c16						DMARK "APP" 
5c16 f5				push af  
5c17 3a 2b 5c			ld a, (.dmark)  
5c1a 32 99 fd			ld (debug_mark),a  
5c1d 3a 2c 5c			ld a, (.dmark+1)  
5c20 32 9a fd			ld (debug_mark+1),a  
5c23 3a 2d 5c			ld a, (.dmark+2)  
5c26 32 9b fd			ld (debug_mark+2),a  
5c29 18 03			jr .pastdmark  
5c2b ..			.dmark: db "APP"  
5c2e f1			.pastdmark: pop af  
5c2f			endm  
# End of macro DMARK
5c2f						CALLMONITOR 
5c2f cd a6 fd			call debug_vector  
5c32				endm  
# End of macro CALLMONITOR
5c32					endif 
5c32			 
5c32					FORTH_DSP_VALUEHL 
5c32 cd 0e 22			call macro_dsp_valuehl 
5c35				endm 
# End of macro FORTH_DSP_VALUEHL
5c35 e5					push hl 	; save file id 
5c36			 
5c36				if DEBUG_STORESE 
5c36					DMARK "AP1" 
5c36 f5				push af  
5c37 3a 4b 5c			ld a, (.dmark)  
5c3a 32 99 fd			ld (debug_mark),a  
5c3d 3a 4c 5c			ld a, (.dmark+1)  
5c40 32 9a fd			ld (debug_mark+1),a  
5c43 3a 4d 5c			ld a, (.dmark+2)  
5c46 32 9b fd			ld (debug_mark+2),a  
5c49 18 03			jr .pastdmark  
5c4b ..			.dmark: db "AP1"  
5c4e f1			.pastdmark: pop af  
5c4f			endm  
# End of macro DMARK
5c4f					CALLMONITOR 
5c4f cd a6 fd			call debug_vector  
5c52				endm  
# End of macro CALLMONITOR
5c52				endif 
5c52					FORTH_DSP_POP 
5c52 cd c6 22			call macro_forth_dsp_pop 
5c55				endm 
# End of macro FORTH_DSP_POP
5c55			 
5c55					FORTH_DSP_VALUEHL 
5c55 cd 0e 22			call macro_dsp_valuehl 
5c58				endm 
# End of macro FORTH_DSP_VALUEHL
5c58					;v5 FORTH_DSP_VALUE 
5c58 e5					push hl 	; save ptr to string to save 
5c59			 
5c59				if DEBUG_STORESE 
5c59					DMARK "AP1" 
5c59 f5				push af  
5c5a 3a 6e 5c			ld a, (.dmark)  
5c5d 32 99 fd			ld (debug_mark),a  
5c60 3a 6f 5c			ld a, (.dmark+1)  
5c63 32 9a fd			ld (debug_mark+1),a  
5c66 3a 70 5c			ld a, (.dmark+2)  
5c69 32 9b fd			ld (debug_mark+2),a  
5c6c 18 03			jr .pastdmark  
5c6e ..			.dmark: db "AP1"  
5c71 f1			.pastdmark: pop af  
5c72			endm  
# End of macro DMARK
5c72					CALLMONITOR 
5c72 cd a6 fd			call debug_vector  
5c75				endm  
# End of macro CALLMONITOR
5c75				endif 
5c75					FORTH_DSP_POP 
5c75 cd c6 22			call macro_forth_dsp_pop 
5c78				endm 
# End of macro FORTH_DSP_POP
5c78			 
5c78 d1					pop de 
5c79 e1					pop hl 
5c7a				if DEBUG_STORESE 
5c7a					DMARK "AP2" 
5c7a f5				push af  
5c7b 3a 8f 5c			ld a, (.dmark)  
5c7e 32 99 fd			ld (debug_mark),a  
5c81 3a 90 5c			ld a, (.dmark+1)  
5c84 32 9a fd			ld (debug_mark+1),a  
5c87 3a 91 5c			ld a, (.dmark+2)  
5c8a 32 9b fd			ld (debug_mark+2),a  
5c8d 18 03			jr .pastdmark  
5c8f ..			.dmark: db "AP2"  
5c92 f1			.pastdmark: pop af  
5c93			endm  
# End of macro DMARK
5c93					CALLMONITOR 
5c93 cd a6 fd			call debug_vector  
5c96				endm  
# End of macro CALLMONITOR
5c96				endif 
5c96					;inc de ; skip var type indicator 
5c96			 
5c96					; TODO how to append numerics???? 
5c96			 
5c96 cd 3b 0b				call storage_append		 
5c99			 
5c99				       NEXTW 
5c99 cd a3 fd			call parse_vector 
5c9c c3 f5 23			jp macro_next 
5c9f				endm 
# End of macro NEXTW
5c9f			.SDEL: 
5c9f				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
5c9f 6a				db WORD_SYS_CORE+86             
5ca0 ee 5c			dw .OPEN            
5ca2 05				db 4 + 1 
5ca3 .. 00			db "ERA",0              
5ca7				endm 
# End of macro CWHEAD
5ca7			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5ca7			; | | > [!NOTE] 
5ca7			; | | > Compatible with PicoSPINet  
5ca7					FORTH_DSP_VALUEHL 
5ca7 cd 0e 22			call macro_dsp_valuehl 
5caa				endm 
# End of macro FORTH_DSP_VALUEHL
5caa			;		push hl 	; save file id 
5caa			 
5caa					if DEBUG_FORTH_WORDS_KEY 
5caa						DMARK "ERA" 
5caa f5				push af  
5cab 3a bf 5c			ld a, (.dmark)  
5cae 32 99 fd			ld (debug_mark),a  
5cb1 3a c0 5c			ld a, (.dmark+1)  
5cb4 32 9a fd			ld (debug_mark+1),a  
5cb7 3a c1 5c			ld a, (.dmark+2)  
5cba 32 9b fd			ld (debug_mark+2),a  
5cbd 18 03			jr .pastdmark  
5cbf ..			.dmark: db "ERA"  
5cc2 f1			.pastdmark: pop af  
5cc3			endm  
# End of macro DMARK
5cc3						CALLMONITOR 
5cc3 cd a6 fd			call debug_vector  
5cc6				endm  
# End of macro CALLMONITOR
5cc6					endif 
5cc6				if DEBUG_STORESE 
5cc6					DMARK "ER1" 
5cc6 f5				push af  
5cc7 3a db 5c			ld a, (.dmark)  
5cca 32 99 fd			ld (debug_mark),a  
5ccd 3a dc 5c			ld a, (.dmark+1)  
5cd0 32 9a fd			ld (debug_mark+1),a  
5cd3 3a dd 5c			ld a, (.dmark+2)  
5cd6 32 9b fd			ld (debug_mark+2),a  
5cd9 18 03			jr .pastdmark  
5cdb ..			.dmark: db "ER1"  
5cde f1			.pastdmark: pop af  
5cdf			endm  
# End of macro DMARK
5cdf					CALLMONITOR 
5cdf cd a6 fd			call debug_vector  
5ce2				endm  
# End of macro CALLMONITOR
5ce2				endif 
5ce2					FORTH_DSP_POP 
5ce2 cd c6 22			call macro_forth_dsp_pop 
5ce5				endm 
# End of macro FORTH_DSP_POP
5ce5			 
5ce5			;		pop hl 
5ce5			 
5ce5 cd 92 06				call storage_erase 
5ce8				       NEXTW 
5ce8 cd a3 fd			call parse_vector 
5ceb c3 f5 23			jp macro_next 
5cee				endm 
# End of macro NEXTW
5cee			 
5cee			.OPEN: 
5cee				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5cee 6b				db WORD_SYS_CORE+87             
5cef 84 5d			dw .READ            
5cf1 05				db 4 + 1 
5cf2 .. 00			db "OPEN",0              
5cf7				endm 
# End of macro CWHEAD
5cf7			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5cf7			; | | e.g. 
5cf7			; | | $01 OPEN $01 DO $01 READ . LOOP 
5cf7			; | | 
5cf7			; | | Will return with 255 blocks if the file does not exist 
5cf7			; | | > [!NOTE] 
5cf7			; | | > Compatible with PicoSPINet  
5cf7			 
5cf7					if DEBUG_FORTH_WORDS_KEY 
5cf7						DMARK "OPN" 
5cf7 f5				push af  
5cf8 3a 0c 5d			ld a, (.dmark)  
5cfb 32 99 fd			ld (debug_mark),a  
5cfe 3a 0d 5d			ld a, (.dmark+1)  
5d01 32 9a fd			ld (debug_mark+1),a  
5d04 3a 0e 5d			ld a, (.dmark+2)  
5d07 32 9b fd			ld (debug_mark+2),a  
5d0a 18 03			jr .pastdmark  
5d0c ..			.dmark: db "OPN"  
5d0f f1			.pastdmark: pop af  
5d10			endm  
# End of macro DMARK
5d10						CALLMONITOR 
5d10 cd a6 fd			call debug_vector  
5d13				endm  
# End of macro CALLMONITOR
5d13					endif 
5d13					; TODO handle multiple file opens 
5d13			 
5d13 3e 01			       	ld a, 1 
5d15 32 98 f9				ld (store_openext), a 
5d18			 
5d18					; get max extents for this file 
5d18				 
5d18								 
5d18					FORTH_DSP_VALUEHL 
5d18 cd 0e 22			call macro_dsp_valuehl 
5d1b				endm 
# End of macro FORTH_DSP_VALUEHL
5d1b			 
5d1b 65					ld h, l 
5d1c 2e 00				ld l, 0 
5d1e			 
5d1e					; store file id 
5d1e			 
5d1e 7c					ld a, h 
5d1f 32 95 f9				ld (store_filecache), a 
5d22			 
5d22				if DEBUG_STORESE 
5d22					DMARK "OPN" 
5d22 f5				push af  
5d23 3a 37 5d			ld a, (.dmark)  
5d26 32 99 fd			ld (debug_mark),a  
5d29 3a 38 5d			ld a, (.dmark+1)  
5d2c 32 9a fd			ld (debug_mark+1),a  
5d2f 3a 39 5d			ld a, (.dmark+2)  
5d32 32 9b fd			ld (debug_mark+2),a  
5d35 18 03			jr .pastdmark  
5d37 ..			.dmark: db "OPN"  
5d3a f1			.pastdmark: pop af  
5d3b			endm  
# End of macro DMARK
5d3b					CALLMONITOR 
5d3b cd a6 fd			call debug_vector  
5d3e				endm  
# End of macro CALLMONITOR
5d3e				endif 
5d3e			;		push hl 
5d3e					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5d3e cd c6 22			call macro_forth_dsp_pop 
5d41				endm 
# End of macro FORTH_DSP_POP
5d41			;		pop hl 
5d41						 
5d41 11 a8 f9				ld de, store_page      ; get block zero of file 
5d44 cd a7 09				call storage_read 
5d47 cd da 0f			call ishlzero 
5d4a 20 04			jr nz, .opfound 
5d4c			 
5d4c				; file does not exist so indicate with 255 extents in use 
5d4c			 
5d4c 3e ff			ld a, 255 
5d4e 18 28			jr .skipopeneof 
5d50			 
5d50			 
5d50			.opfound: 
5d50			 
5d50			 
5d50 3a aa f9				ld a, (store_page+2)    ; max extents for this file 
5d53 32 97 f9				ld  (store_openmaxext), a   ; get our limit and push 
5d56					 
5d56				if DEBUG_STORESE 
5d56					DMARK "OPx" 
5d56 f5				push af  
5d57 3a 6b 5d			ld a, (.dmark)  
5d5a 32 99 fd			ld (debug_mark),a  
5d5d 3a 6c 5d			ld a, (.dmark+1)  
5d60 32 9a fd			ld (debug_mark+1),a  
5d63 3a 6d 5d			ld a, (.dmark+2)  
5d66 32 9b fd			ld (debug_mark+2),a  
5d69 18 03			jr .pastdmark  
5d6b ..			.dmark: db "OPx"  
5d6e f1			.pastdmark: pop af  
5d6f			endm  
# End of macro DMARK
5d6f					CALLMONITOR 
5d6f cd a6 fd			call debug_vector  
5d72				endm  
# End of macro CALLMONITOR
5d72				endif 
5d72			;		cp 0 
5d72 b7					or a 
5d73 20 03				jr nz, .skipopeneof 
5d75					; have opened an empty file 
5d75					 
5d75 32 98 f9				ld (store_openext), a 
5d78			 
5d78			.skipopeneof: 
5d78			 
5d78 6f					ld l, a 
5d79 26 00				ld h, 0 
5d7b cd 12 20				call forth_push_numhl 
5d7e			 
5d7e			 
5d7e				       NEXTW 
5d7e cd a3 fd			call parse_vector 
5d81 c3 f5 23			jp macro_next 
5d84				endm 
# End of macro NEXTW
5d84			.READ: 
5d84				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5d84 6c				db WORD_SYS_CORE+88             
5d85 b3 5e			dw .EOF            
5d87 05				db 4 + 1 
5d88 .. 00			db "READ",0              
5d8d				endm 
# End of macro CWHEAD
5d8d			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5d8d			; | | e.g. 
5d8d			; | | $01 OPEN $01 DO READ . LOOP 
5d8d			; | | 
5d8d			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5d8d			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5d8d			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5d8d			; | | two bytes contain the file id and extent. 
5d8d			; | |  
5d8d			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5d8d			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5d8d			; | | > [!NOTE] 
5d8d			; | | > Compatible with PicoSPINet  
5d8d			 
5d8d					if DEBUG_FORTH_WORDS_KEY 
5d8d						DMARK "REA" 
5d8d f5				push af  
5d8e 3a a2 5d			ld a, (.dmark)  
5d91 32 99 fd			ld (debug_mark),a  
5d94 3a a3 5d			ld a, (.dmark+1)  
5d97 32 9a fd			ld (debug_mark+1),a  
5d9a 3a a4 5d			ld a, (.dmark+2)  
5d9d 32 9b fd			ld (debug_mark+2),a  
5da0 18 03			jr .pastdmark  
5da2 ..			.dmark: db "REA"  
5da5 f1			.pastdmark: pop af  
5da6			endm  
# End of macro DMARK
5da6						CALLMONITOR 
5da6 cd a6 fd			call debug_vector  
5da9				endm  
# End of macro CALLMONITOR
5da9					endif 
5da9					; store_openext use it. If zero it is EOF 
5da9			 
5da9					; read block from current stream id 
5da9					; if the block does not contain zero term keep reading blocks until zero found 
5da9					; push the block to stack 
5da9					; save the block id to stream 
5da9			 
5da9			 
5da9 cd e3 5e				call .testeof 
5dac 3e 01				ld a, 1 
5dae bd					cp l 
5daf ca 8c 5e				jp z, .ateof 
5db2			 
5db2			 
5db2			;		FORTH_DSP_VALUEHL 
5db2			 
5db2			;		push hl 
5db2			 
5db2			;	if DEBUG_STORESE 
5db2			;		DMARK "REA" 
5db2			;		CALLMONITOR 
5db2			;	endif 
5db2			;		FORTH_DSP_POP 
5db2			 
5db2			;		pop hl 
5db2				 
5db2 3a 95 f9				ld a, (store_filecache) 
5db5 67					ld h,a 
5db6			 
5db6 3a 98 f9				ld a, (store_openext) 
5db9 6f					ld l, a 
5dba					 
5dba			;		cp 0 
5dba b7					or a 
5dbb ca 8c 5e				jp z, .ateof     ; dont read past eof 
5dbe			 
5dbe cd 84 0c				call storage_clear_page 
5dc1			 
5dc1 11 a8 f9				ld de, store_page 
5dc4				if DEBUG_STORESE 
5dc4					DMARK "RE1" 
5dc4 f5				push af  
5dc5 3a d9 5d			ld a, (.dmark)  
5dc8 32 99 fd			ld (debug_mark),a  
5dcb 3a da 5d			ld a, (.dmark+1)  
5dce 32 9a fd			ld (debug_mark+1),a  
5dd1 3a db 5d			ld a, (.dmark+2)  
5dd4 32 9b fd			ld (debug_mark+2),a  
5dd7 18 03			jr .pastdmark  
5dd9 ..			.dmark: db "RE1"  
5ddc f1			.pastdmark: pop af  
5ddd			endm  
# End of macro DMARK
5ddd					CALLMONITOR 
5ddd cd a6 fd			call debug_vector  
5de0				endm  
# End of macro CALLMONITOR
5de0				endif 
5de0 cd a7 09				call storage_read 
5de3			 
5de3				if DEBUG_STORESE 
5de3					DMARK "RE2" 
5de3 f5				push af  
5de4 3a f8 5d			ld a, (.dmark)  
5de7 32 99 fd			ld (debug_mark),a  
5dea 3a f9 5d			ld a, (.dmark+1)  
5ded 32 9a fd			ld (debug_mark+1),a  
5df0 3a fa 5d			ld a, (.dmark+2)  
5df3 32 9b fd			ld (debug_mark+2),a  
5df6 18 03			jr .pastdmark  
5df8 ..			.dmark: db "RE2"  
5dfb f1			.pastdmark: pop af  
5dfc			endm  
# End of macro DMARK
5dfc					CALLMONITOR 
5dfc cd a6 fd			call debug_vector  
5dff				endm  
# End of macro CALLMONITOR
5dff				endif 
5dff cd da 0f			call ishlzero 
5e02			;	ld a, l 
5e02			;	add h 
5e02			;	cp 0 
5e02 ca 8c 5e			jp z, .readeof 
5e05			 
5e05				; not eof so hl should point to data to push to stack 
5e05			 
5e05				if DEBUG_STORESE 
5e05					DMARK "RE3" 
5e05 f5				push af  
5e06 3a 1a 5e			ld a, (.dmark)  
5e09 32 99 fd			ld (debug_mark),a  
5e0c 3a 1b 5e			ld a, (.dmark+1)  
5e0f 32 9a fd			ld (debug_mark+1),a  
5e12 3a 1c 5e			ld a, (.dmark+2)  
5e15 32 9b fd			ld (debug_mark+2),a  
5e18 18 03			jr .pastdmark  
5e1a ..			.dmark: db "RE3"  
5e1d f1			.pastdmark: pop af  
5e1e			endm  
# End of macro DMARK
5e1e					CALLMONITOR 
5e1e cd a6 fd			call debug_vector  
5e21				endm  
# End of macro CALLMONITOR
5e21				endif 
5e21 cd 7c 20			call forth_push_str 
5e24			 
5e24				if DEBUG_STORESE 
5e24					DMARK "RE4" 
5e24 f5				push af  
5e25 3a 39 5e			ld a, (.dmark)  
5e28 32 99 fd			ld (debug_mark),a  
5e2b 3a 3a 5e			ld a, (.dmark+1)  
5e2e 32 9a fd			ld (debug_mark+1),a  
5e31 3a 3b 5e			ld a, (.dmark+2)  
5e34 32 9b fd			ld (debug_mark+2),a  
5e37 18 03			jr .pastdmark  
5e39 ..			.dmark: db "RE4"  
5e3c f1			.pastdmark: pop af  
5e3d			endm  
# End of macro DMARK
5e3d					CALLMONITOR 
5e3d cd a6 fd			call debug_vector  
5e40				endm  
# End of macro CALLMONITOR
5e40				endif 
5e40				; get next block  or mark as eof 
5e40			 
5e40 3a 97 f9			ld a, (store_openmaxext)   ; get our limit 
5e43 4f				ld c, a	 
5e44 3a 98 f9			ld a, (store_openext) 
5e47			 
5e47				if DEBUG_STORESE 
5e47					DMARK "RE5" 
5e47 f5				push af  
5e48 3a 5c 5e			ld a, (.dmark)  
5e4b 32 99 fd			ld (debug_mark),a  
5e4e 3a 5d 5e			ld a, (.dmark+1)  
5e51 32 9a fd			ld (debug_mark+1),a  
5e54 3a 5e 5e			ld a, (.dmark+2)  
5e57 32 9b fd			ld (debug_mark+2),a  
5e5a 18 03			jr .pastdmark  
5e5c ..			.dmark: db "RE5"  
5e5f f1			.pastdmark: pop af  
5e60			endm  
# End of macro DMARK
5e60					CALLMONITOR 
5e60 cd a6 fd			call debug_vector  
5e63				endm  
# End of macro CALLMONITOR
5e63				endif 
5e63 b9				cp c 
5e64 28 26			jr z, .readeof     ; at last extent 
5e66			 
5e66 3c					inc a 
5e67 32 98 f9				ld (store_openext), a 
5e6a			 
5e6a				if DEBUG_STORESE 
5e6a					DMARK "RE6" 
5e6a f5				push af  
5e6b 3a 7f 5e			ld a, (.dmark)  
5e6e 32 99 fd			ld (debug_mark),a  
5e71 3a 80 5e			ld a, (.dmark+1)  
5e74 32 9a fd			ld (debug_mark+1),a  
5e77 3a 81 5e			ld a, (.dmark+2)  
5e7a 32 9b fd			ld (debug_mark+2),a  
5e7d 18 03			jr .pastdmark  
5e7f ..			.dmark: db "RE6"  
5e82 f1			.pastdmark: pop af  
5e83			endm  
# End of macro DMARK
5e83					CALLMONITOR 
5e83 cd a6 fd			call debug_vector  
5e86				endm  
# End of macro CALLMONITOR
5e86				endif 
5e86			 
5e86			 
5e86				       NEXTW 
5e86 cd a3 fd			call parse_vector 
5e89 c3 f5 23			jp macro_next 
5e8c				endm 
# End of macro NEXTW
5e8c			.ateof: 
5e8c				;	ld hl, .showeof 
5e8c				;	call forth_push_str 
5e8c 3e 00		.readeof:	ld a, 0 
5e8e 32 98 f9				ld (store_openext), a 
5e91			 
5e91					 
5e91				if DEBUG_STORESE 
5e91					DMARK "REF" 
5e91 f5				push af  
5e92 3a a6 5e			ld a, (.dmark)  
5e95 32 99 fd			ld (debug_mark),a  
5e98 3a a7 5e			ld a, (.dmark+1)  
5e9b 32 9a fd			ld (debug_mark+1),a  
5e9e 3a a8 5e			ld a, (.dmark+2)  
5ea1 32 9b fd			ld (debug_mark+2),a  
5ea4 18 03			jr .pastdmark  
5ea6 ..			.dmark: db "REF"  
5ea9 f1			.pastdmark: pop af  
5eaa			endm  
# End of macro DMARK
5eaa					CALLMONITOR 
5eaa cd a6 fd			call debug_vector  
5ead				endm  
# End of macro CALLMONITOR
5ead				endif 
5ead				       NEXTW 
5ead cd a3 fd			call parse_vector 
5eb0 c3 f5 23			jp macro_next 
5eb3				endm 
# End of macro NEXTW
5eb3			 
5eb3			;.showeof:   db "eof", 0 
5eb3			 
5eb3			 
5eb3			.EOF: 
5eb3				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5eb3 6d				db WORD_SYS_CORE+89             
5eb4 f6 5e			dw .FORMAT            
5eb6 04				db 3 + 1 
5eb7 .. 00			db "EOF",0              
5ebb				endm 
# End of macro CWHEAD
5ebb			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
5ebb			; | | e.g. 
5ebb			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
5ebb			; | | > [!NOTE] 
5ebb			; | | > Compatible with PicoSPINet  
5ebb					; TODO if current block id for stream is zero then push true else false 
5ebb			 
5ebb					if DEBUG_FORTH_WORDS_KEY 
5ebb						DMARK "EOF" 
5ebb f5				push af  
5ebc 3a d0 5e			ld a, (.dmark)  
5ebf 32 99 fd			ld (debug_mark),a  
5ec2 3a d1 5e			ld a, (.dmark+1)  
5ec5 32 9a fd			ld (debug_mark+1),a  
5ec8 3a d2 5e			ld a, (.dmark+2)  
5ecb 32 9b fd			ld (debug_mark+2),a  
5ece 18 03			jr .pastdmark  
5ed0 ..			.dmark: db "EOF"  
5ed3 f1			.pastdmark: pop af  
5ed4			endm  
# End of macro DMARK
5ed4						CALLMONITOR 
5ed4 cd a6 fd			call debug_vector  
5ed7				endm  
# End of macro CALLMONITOR
5ed7					endif 
5ed7			 
5ed7					; TODO handlue multiple file streams 
5ed7			 
5ed7			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5ed7 cd e3 5e				call .testeof 
5eda cd 12 20				call forth_push_numhl 
5edd			 
5edd			 
5edd				       NEXTW 
5edd cd a3 fd			call parse_vector 
5ee0 c3 f5 23			jp macro_next 
5ee3				endm 
# End of macro NEXTW
5ee3			 
5ee3			.testeof: 
5ee3 2e 01				ld l, 1 
5ee5 3a 97 f9				ld a, (store_openmaxext) 
5ee8			;		cp 0 
5ee8 b7					or a 
5ee9 28 08				jr  z, .eofdone   ; empty file 
5eeb 3a 98 f9				ld a, (store_openext) 
5eee			;		cp 0 
5eee b7					or a 
5eef 28 02				jr  z, .eofdone 
5ef1 2e 00				ld l, 0 
5ef3 26 00		.eofdone:	ld h, 0 
5ef5 c9					ret 
5ef6			 
5ef6			 
5ef6			 
5ef6			 
5ef6			.FORMAT: 
5ef6				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5ef6 6d				db WORD_SYS_CORE+89             
5ef7 4a 5f			dw .LABEL            
5ef9 07				db 6 + 1 
5efa .. 00			db "FORMAT",0              
5f01				endm 
# End of macro CWHEAD
5f01			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5f01			; | | > [!NOTE] 
5f01			; | | > Compatible with PicoSPINet  
5f01					; TODO if current block id for stream is zero then push true else false 
5f01				 
5f01				if DEBUG_STORESE 
5f01					DMARK "FOR" 
5f01 f5				push af  
5f02 3a 16 5f			ld a, (.dmark)  
5f05 32 99 fd			ld (debug_mark),a  
5f08 3a 17 5f			ld a, (.dmark+1)  
5f0b 32 9a fd			ld (debug_mark+1),a  
5f0e 3a 18 5f			ld a, (.dmark+2)  
5f11 32 9b fd			ld (debug_mark+2),a  
5f14 18 03			jr .pastdmark  
5f16 ..			.dmark: db "FOR"  
5f19 f1			.pastdmark: pop af  
5f1a			endm  
# End of macro DMARK
5f1a					CALLMONITOR 
5f1a cd a6 fd			call debug_vector  
5f1d				endm  
# End of macro CALLMONITOR
5f1d				endif 
5f1d					; Wipes the bank check flags to cause a reformat on next block 0 read 
5f1d			 
5f1d 21 01 00				ld hl, 1 
5f20 3e 00				ld a, 0 
5f22 cd 65 02				call se_writebyte 
5f25			 
5f25				if DEBUG_STORESE 
5f25					DMARK "FO0" 
5f25 f5				push af  
5f26 3a 3a 5f			ld a, (.dmark)  
5f29 32 99 fd			ld (debug_mark),a  
5f2c 3a 3b 5f			ld a, (.dmark+1)  
5f2f 32 9a fd			ld (debug_mark+1),a  
5f32 3a 3c 5f			ld a, (.dmark+2)  
5f35 32 9b fd			ld (debug_mark+2),a  
5f38 18 03			jr .pastdmark  
5f3a ..			.dmark: db "FO0"  
5f3d f1			.pastdmark: pop af  
5f3e			endm  
# End of macro DMARK
5f3e					CALLMONITOR 
5f3e cd a6 fd			call debug_vector  
5f41				endm  
# End of macro CALLMONITOR
5f41				endif 
5f41					; force bank init 
5f41			 
5f41 cd 05 05				call storage_get_block_0 
5f44					 
5f44				       NEXTW 
5f44 cd a3 fd			call parse_vector 
5f47 c3 f5 23			jp macro_next 
5f4a				endm 
# End of macro NEXTW
5f4a			.LABEL: 
5f4a				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5f4a 6d				db WORD_SYS_CORE+89             
5f4b 9b 5f			dw .STOREPAGE            
5f4d 06				db 5 + 1 
5f4e .. 00			db "LABEL",0              
5f54				endm 
# End of macro CWHEAD
5f54			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5f54			; | | > [!NOTE] 
5f54			; | | > Compatible with PicoSPINet  
5f54					; TODO test to see if bank is selected 
5f54				 
5f54					if DEBUG_FORTH_WORDS_KEY 
5f54						DMARK "LBL" 
5f54 f5				push af  
5f55 3a 69 5f			ld a, (.dmark)  
5f58 32 99 fd			ld (debug_mark),a  
5f5b 3a 6a 5f			ld a, (.dmark+1)  
5f5e 32 9a fd			ld (debug_mark+1),a  
5f61 3a 6b 5f			ld a, (.dmark+2)  
5f64 32 9b fd			ld (debug_mark+2),a  
5f67 18 03			jr .pastdmark  
5f69 ..			.dmark: db "LBL"  
5f6c f1			.pastdmark: pop af  
5f6d			endm  
# End of macro DMARK
5f6d						CALLMONITOR 
5f6d cd a6 fd			call debug_vector  
5f70				endm  
# End of macro CALLMONITOR
5f70					endif 
5f70			;	if DEBUG_STORESE 
5f70			;		DMARK "LBL" 
5f70			;		CALLMONITOR 
5f70			;	endif 
5f70					FORTH_DSP_VALUEHL 
5f70 cd 0e 22			call macro_dsp_valuehl 
5f73				endm 
# End of macro FORTH_DSP_VALUEHL
5f73					;v5FORTH_DSP_VALUE 
5f73					 
5f73			;		push hl 
5f73					FORTH_DSP_POP 
5f73 cd c6 22			call macro_forth_dsp_pop 
5f76				endm 
# End of macro FORTH_DSP_POP
5f76			;		pop hl 
5f76			 
5f76			;v5		inc hl   ; move past the type marker 
5f76			 
5f76				if DEBUG_STORESE 
5f76					DMARK "LBl" 
5f76 f5				push af  
5f77 3a 8b 5f			ld a, (.dmark)  
5f7a 32 99 fd			ld (debug_mark),a  
5f7d 3a 8c 5f			ld a, (.dmark+1)  
5f80 32 9a fd			ld (debug_mark+1),a  
5f83 3a 8d 5f			ld a, (.dmark+2)  
5f86 32 9b fd			ld (debug_mark+2),a  
5f89 18 03			jr .pastdmark  
5f8b ..			.dmark: db "LBl"  
5f8e f1			.pastdmark: pop af  
5f8f			endm  
# End of macro DMARK
5f8f					CALLMONITOR 
5f8f cd a6 fd			call debug_vector  
5f92				endm  
# End of macro CALLMONITOR
5f92				endif 
5f92 cd 25 06				call storage_label 
5f95			 
5f95				       NEXTW 
5f95 cd a3 fd			call parse_vector 
5f98 c3 f5 23			jp macro_next 
5f9b				endm 
# End of macro NEXTW
5f9b			.STOREPAGE: 
5f9b				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5f9b 6d				db WORD_SYS_CORE+89             
5f9c d1 5f			dw .LABELS            
5f9e 0a				db 9 + 1 
5f9f .. 00			db "STOREPAGE",0              
5fa9				endm 
# End of macro CWHEAD
5fa9			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5fa9			; | | > [!NOTE] 
5fa9			; | | > Compatible with PicoSPINet  
5fa9					; TODO test to see if bank is selected 
5fa9				 
5fa9					if DEBUG_FORTH_WORDS_KEY 
5fa9						DMARK "STP" 
5fa9 f5				push af  
5faa 3a be 5f			ld a, (.dmark)  
5fad 32 99 fd			ld (debug_mark),a  
5fb0 3a bf 5f			ld a, (.dmark+1)  
5fb3 32 9a fd			ld (debug_mark+1),a  
5fb6 3a c0 5f			ld a, (.dmark+2)  
5fb9 32 9b fd			ld (debug_mark+2),a  
5fbc 18 03			jr .pastdmark  
5fbe ..			.dmark: db "STP"  
5fc1 f1			.pastdmark: pop af  
5fc2			endm  
# End of macro DMARK
5fc2						CALLMONITOR 
5fc2 cd a6 fd			call debug_vector  
5fc5				endm  
# End of macro CALLMONITOR
5fc5					endif 
5fc5			;	if DEBUG_STORESE 
5fc5			;		DMARK "STP" 
5fc5			;		CALLMONITOR 
5fc5			;	endif 
5fc5			 
5fc5 21 a8 f9			ld hl, store_page 
5fc8 cd 12 20			call forth_push_numhl 
5fcb			 
5fcb			 
5fcb				       NEXTW 
5fcb cd a3 fd			call parse_vector 
5fce c3 f5 23			jp macro_next 
5fd1				endm 
# End of macro NEXTW
5fd1			.LABELS: 
5fd1				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5fd1 6d				db WORD_SYS_CORE+89             
5fd2 5e 60			dw .SCONST1            
5fd4 07				db 6 + 1 
5fd5 .. 00			db "LABELS",0              
5fdc				endm 
# End of macro CWHEAD
5fdc			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
5fdc			; | | > [!CAUTION] 
5fdc			; | | > *NOT* Compatible with PicoSPINet  
5fdc					;  
5fdc			 
5fdc					; save the current device selected to restore afterwards 
5fdc				 
5fdc 3a 8e f9				ld a, (spi_device) 
5fdf f5					push af 
5fe0			 
5fe0			 
5fe0					; run through each of the banks 
5fe0			 
5fe0 21 01 00				ld hl, 1 
5fe3 cd 12 20				call forth_push_numhl 
5fe6 3e ff				ld a, SPI_CE_HIGH 
5fe8 cb 87				res SPI_CE0, a 
5fea 32 8e f9				ld (spi_device), a 
5fed cd 05 05				call storage_get_block_0 
5ff0 21 ab f9				ld hl, store_page+3 
5ff3 cd 7c 20				call forth_push_str 
5ff6			 
5ff6					 
5ff6 21 02 00				ld hl, 2 
5ff9 cd 12 20				call forth_push_numhl 
5ffc 3e ff				ld a, SPI_CE_HIGH 
5ffe cb 8f				res SPI_CE1, a 
6000 32 8e f9				ld (spi_device), a 
6003 cd 05 05				call storage_get_block_0 
6006 21 ab f9				ld hl, store_page+3 
6009 cd 7c 20				call forth_push_str 
600c			 
600c					 
600c 21 03 00				ld hl, 3 
600f cd 12 20				call forth_push_numhl 
6012 3e ff				ld a, SPI_CE_HIGH 
6014 cb 97				res SPI_CE2, a 
6016 32 8e f9				ld (spi_device), a 
6019 cd 05 05				call storage_get_block_0 
601c 21 ab f9				ld hl, store_page+3 
601f cd 7c 20				call forth_push_str 
6022			 
6022			 
6022 21 04 00				ld hl, 4 
6025 cd 12 20				call forth_push_numhl 
6028 3e ff				ld a, SPI_CE_HIGH 
602a cb 9f				res SPI_CE3, a 
602c 32 8e f9				ld (spi_device), a 
602f cd 05 05				call storage_get_block_0 
6032 21 ab f9				ld hl, store_page+3 
6035 cd 7c 20				call forth_push_str 
6038			 
6038					 
6038			 
6038 21 05 00				ld hl, 5 
603b cd 12 20				call forth_push_numhl 
603e 3e ff				ld a, SPI_CE_HIGH 
6040 cb a7				res SPI_CE4, a 
6042 32 8e f9				ld (spi_device), a 
6045 cd 05 05				call storage_get_block_0 
6048 21 ab f9				ld hl, store_page+3 
604b cd 7c 20				call forth_push_str 
604e			 
604e					 
604e					; push fixed count of storage devices (on board) for now 
604e			 
604e 21 05 00				ld hl, 5 
6051 cd 12 20				call forth_push_numhl 
6054			 
6054					; restore selected device  
6054				 
6054 f1					pop af 
6055 32 8e f9				ld (spi_device), a 
6058			 
6058				       NEXTW 
6058 cd a3 fd			call parse_vector 
605b c3 f5 23			jp macro_next 
605e				endm 
# End of macro NEXTW
605e			 
605e			.SCONST1: 
605e				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
605e 6d				db WORD_SYS_CORE+89             
605f 78 60			dw .SCONST2            
6061 07				db 6 + 1 
6062 .. 00			db "FILEID",0              
6069				endm 
# End of macro CWHEAD
6069			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
6069			; | | > [!NOTE] 
6069			; | | > Compatible with PicoSPINet  
6069 3a 95 f9				ld a, (store_filecache) 
606c 26 00				ld h, 0 
606e 6f					ld l, a 
606f cd 12 20				call forth_push_numhl 
6072					NEXTW 
6072 cd a3 fd			call parse_vector 
6075 c3 f5 23			jp macro_next 
6078				endm 
# End of macro NEXTW
6078			.SCONST2: 
6078				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
6078 6d				db WORD_SYS_CORE+89             
6079 93 60			dw .SCONST3            
607b 08				db 7 + 1 
607c .. 00			db "FILEEXT",0              
6084				endm 
# End of macro CWHEAD
6084			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
6084			; | | > [!NOTE] 
6084			; | | > Compatible with PicoSPINet  
6084 3a 98 f9				ld a, (store_openext) 
6087 26 00				ld h, 0 
6089 6f					ld l, a 
608a cd 12 20				call forth_push_numhl 
608d					NEXTW 
608d cd a3 fd			call parse_vector 
6090 c3 f5 23			jp macro_next 
6093				endm 
# End of macro NEXTW
6093			.SCONST3: 
6093				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
6093 6d				db WORD_SYS_CORE+89             
6094 ae 60			dw .SCONST4            
6096 08				db 7 + 1 
6097 .. 00			db "FILEMAX",0              
609f				endm 
# End of macro CWHEAD
609f			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
609f			; | | > [!NOTE] 
609f			; | | > Compatible with PicoSPINet  
609f 3a 97 f9				ld a, (store_openmaxext) 
60a2 26 00				ld h, 0 
60a4 6f					ld l, a 
60a5 cd 12 20				call forth_push_numhl 
60a8					NEXTW 
60a8 cd a3 fd			call parse_vector 
60ab c3 f5 23			jp macro_next 
60ae				endm 
# End of macro NEXTW
60ae			.SCONST4: 
60ae				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
60ae 6d				db WORD_SYS_CORE+89             
60af c7 60			dw .SCONST5            
60b1 09				db 8 + 1 
60b2 .. 00			db "FILEADDR",0              
60bb				endm 
# End of macro CWHEAD
60bb			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
60bb			; | | > [!NOTE] 
60bb			; | | > Compatible with PicoSPINet  
60bb 2a 99 f9				ld hl, (store_openaddr) 
60be cd 12 20				call forth_push_numhl 
60c1					NEXTW 
60c1 cd a3 fd			call parse_vector 
60c4 c3 f5 23			jp macro_next 
60c7				endm 
# End of macro NEXTW
60c7			.SCONST5: 
60c7				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
60c7 6d				db WORD_SYS_CORE+89             
60c8 eb 60			dw .SCONST6            
60ca 09				db 8 + 1 
60cb .. 00			db "FILEPAGE",0              
60d4				endm 
# End of macro CWHEAD
60d4			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
60d4			; | | > [!NOTE] 
60d4			; | | > Compatible with PicoSPINet  
60d4 2a 99 f9				ld hl, (store_openaddr) 
60d7 e5					push hl 
60d8 c1					pop bc 
60d9 16 00				ld d, 0 
60db 1e 40				ld e, STORE_BLOCK_PHY 
60dd cd 0e 0f				call Div16 
60e0 c5					push bc 
60e1 e1					pop hl 
60e2 cd 12 20				call forth_push_numhl 
60e5					NEXTW 
60e5 cd a3 fd			call parse_vector 
60e8 c3 f5 23			jp macro_next 
60eb				endm 
# End of macro NEXTW
60eb			.SCONST6: 
60eb				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
60eb 6d				db WORD_SYS_CORE+89             
60ec 07 61			dw .ENDSTORAGE            
60ee 09				db 8 + 1 
60ef .. 00			db "READCONT",0              
60f8				endm 
# End of macro CWHEAD
60f8			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
60f8			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
60f8			; | | a further read should, if applicable, be CONCAT to the previous read. 
60f8			; | | > [!NOTE] 
60f8			; | | > Compatible with PicoSPINet  
60f8 3a 9b f9				ld a, (store_readcont) 
60fb 26 00				ld h, 0 
60fd 6f					ld l, a 
60fe cd 12 20				call forth_push_numhl 
6101					NEXTW 
6101 cd a3 fd			call parse_vector 
6104 c3 f5 23			jp macro_next 
6107				endm 
# End of macro NEXTW
6107			.ENDSTORAGE: 
6107			; eof 
# End of file forth_words_storage.asm
6107			endif 
6107				include "forth_words_device.asm" 
6107			; Device related words 
6107			 
6107			; | ## Device Words 
6107			 
6107			;if SOUND_ENABLE 
6107			;.NOTE: 
6107			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
6107			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
6107			;		if DEBUG_FORTH_WORDS_KEY 
6107			;			DMARK "NTE" 
6107			;			CALLMONITOR 
6107			;		endif 
6107			; 
6107			;	 
6107			; 
6107			;		NEXTW 
6107			;.AFTERSOUND: 
6107			;endif 
6107			 
6107			 
6107			USE_GPIO: equ 0 
6107			 
6107			if USE_GPIO 
6107			.GP1: 
6107				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
6107			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
6107					NEXTW 
6107			.GP2: 
6107				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
6107			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
6107			 
6107					NEXTW 
6107			 
6107			.GP3: 
6107				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
6107			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
6107			 
6107					NEXTW 
6107			 
6107			.GP4: 
6107				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
6107			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
6107			 
6107					NEXTW 
6107			.SIN: 
6107			 
6107			 
6107			endif 
6107			 
6107			 
6107				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
6107 33				db WORD_SYS_CORE+31             
6108 3f 61			dw .SOUT            
610a 03				db 2 + 1 
610b .. 00			db "IN",0              
610e				endm 
# End of macro CWHEAD
610e			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
610e					if DEBUG_FORTH_WORDS_KEY 
610e						DMARK "IN." 
610e f5				push af  
610f 3a 23 61			ld a, (.dmark)  
6112 32 99 fd			ld (debug_mark),a  
6115 3a 24 61			ld a, (.dmark+1)  
6118 32 9a fd			ld (debug_mark+1),a  
611b 3a 25 61			ld a, (.dmark+2)  
611e 32 9b fd			ld (debug_mark+2),a  
6121 18 03			jr .pastdmark  
6123 ..			.dmark: db "IN."  
6126 f1			.pastdmark: pop af  
6127			endm  
# End of macro DMARK
6127						CALLMONITOR 
6127 cd a6 fd			call debug_vector  
612a				endm  
# End of macro CALLMONITOR
612a					endif 
612a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
612a cd 0e 22			call macro_dsp_valuehl 
612d				endm 
# End of macro FORTH_DSP_VALUEHL
612d			 
612d e5					push hl 
612e			 
612e					; destroy value TOS 
612e			 
612e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
612e cd c6 22			call macro_forth_dsp_pop 
6131				endm 
# End of macro FORTH_DSP_POP
6131			 
6131					; one value on hl get other one back 
6131			 
6131 c1					pop bc 
6132			 
6132					; do the sub 
6132			;		ex de, hl 
6132			 
6132 ed 68				in l,(c) 
6134			 
6134					; save it 
6134			 
6134 26 00				ld h,0 
6136			 
6136					; TODO push value back onto stack for another op etc 
6136			 
6136 cd 12 20				call forth_push_numhl 
6139					NEXTW 
6139 cd a3 fd			call parse_vector 
613c c3 f5 23			jp macro_next 
613f				endm 
# End of macro NEXTW
613f			.SOUT: 
613f				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
613f 34				db WORD_SYS_CORE+32             
6140 95 61			dw .SPIO            
6142 04				db 3 + 1 
6143 .. 00			db "OUT",0              
6147				endm 
# End of macro CWHEAD
6147			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
6147					if DEBUG_FORTH_WORDS_KEY 
6147						DMARK "OUT" 
6147 f5				push af  
6148 3a 5c 61			ld a, (.dmark)  
614b 32 99 fd			ld (debug_mark),a  
614e 3a 5d 61			ld a, (.dmark+1)  
6151 32 9a fd			ld (debug_mark+1),a  
6154 3a 5e 61			ld a, (.dmark+2)  
6157 32 9b fd			ld (debug_mark+2),a  
615a 18 03			jr .pastdmark  
615c ..			.dmark: db "OUT"  
615f f1			.pastdmark: pop af  
6160			endm  
# End of macro DMARK
6160						CALLMONITOR 
6160 cd a6 fd			call debug_vector  
6163				endm  
# End of macro CALLMONITOR
6163					endif 
6163			 
6163					; get port 
6163			 
6163					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6163 cd 0e 22			call macro_dsp_valuehl 
6166				endm 
# End of macro FORTH_DSP_VALUEHL
6166			 
6166 e5					push hl 
6167			 
6167					; destroy value TOS 
6167			 
6167					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6167 cd c6 22			call macro_forth_dsp_pop 
616a				endm 
# End of macro FORTH_DSP_POP
616a			 
616a					; get byte to send 
616a			 
616a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
616a cd 0e 22			call macro_dsp_valuehl 
616d				endm 
# End of macro FORTH_DSP_VALUEHL
616d			 
616d			;		push hl 
616d			 
616d					; destroy value TOS 
616d			 
616d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
616d cd c6 22			call macro_forth_dsp_pop 
6170				endm 
# End of macro FORTH_DSP_POP
6170			 
6170					; one value on hl get other one back 
6170			 
6170			;		pop hl 
6170			 
6170 c1					pop bc 
6171			 
6171					if DEBUG_FORTH_WORDS 
6171						DMARK "OUT" 
6171 f5				push af  
6172 3a 86 61			ld a, (.dmark)  
6175 32 99 fd			ld (debug_mark),a  
6178 3a 87 61			ld a, (.dmark+1)  
617b 32 9a fd			ld (debug_mark+1),a  
617e 3a 88 61			ld a, (.dmark+2)  
6181 32 9b fd			ld (debug_mark+2),a  
6184 18 03			jr .pastdmark  
6186 ..			.dmark: db "OUT"  
6189 f1			.pastdmark: pop af  
618a			endm  
# End of macro DMARK
618a						CALLMONITOR 
618a cd a6 fd			call debug_vector  
618d				endm  
# End of macro CALLMONITOR
618d					endif 
618d			 
618d ed 69				out (c), l 
618f			 
618f					NEXTW 
618f cd a3 fd			call parse_vector 
6192 c3 f5 23			jp macro_next 
6195				endm 
# End of macro NEXTW
6195			 
6195			 
6195			.SPIO: 
6195			 
6195			if STORAGE_SE 
6195				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
6195 51				db WORD_SYS_CORE+61             
6196 a9 61			dw .SPICEH            
6198 07				db 6 + 1 
6199 .. 00			db "SPICEL",0              
61a0				endm 
# End of macro CWHEAD
61a0			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
61a0			 
61a0 cd 0e 02				call spi_ce_low 
61a3			    NEXTW 
61a3 cd a3 fd			call parse_vector 
61a6 c3 f5 23			jp macro_next 
61a9				endm 
# End of macro NEXTW
61a9			 
61a9			.SPICEH: 
61a9				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
61a9 51				db WORD_SYS_CORE+61             
61aa bd 61			dw .SPIOb            
61ac 07				db 6 + 1 
61ad .. 00			db "SPICEH",0              
61b4				endm 
# End of macro CWHEAD
61b4			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
61b4			 
61b4 cd fd 01				call spi_ce_high 
61b7			    NEXTW 
61b7 cd a3 fd			call parse_vector 
61ba c3 f5 23			jp macro_next 
61bd				endm 
# End of macro NEXTW
61bd			 
61bd			 
61bd			.SPIOb: 
61bd			 
61bd				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
61bd 51				db WORD_SYS_CORE+61             
61be f2 61			dw .SPII            
61c0 05				db 4 + 1 
61c1 .. 00			db "SPIO",0              
61c6				endm 
# End of macro CWHEAD
61c6			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
61c6			 
61c6					if DEBUG_FORTH_WORDS_KEY 
61c6						DMARK "SPo" 
61c6 f5				push af  
61c7 3a db 61			ld a, (.dmark)  
61ca 32 99 fd			ld (debug_mark),a  
61cd 3a dc 61			ld a, (.dmark+1)  
61d0 32 9a fd			ld (debug_mark+1),a  
61d3 3a dd 61			ld a, (.dmark+2)  
61d6 32 9b fd			ld (debug_mark+2),a  
61d9 18 03			jr .pastdmark  
61db ..			.dmark: db "SPo"  
61de f1			.pastdmark: pop af  
61df			endm  
# End of macro DMARK
61df						CALLMONITOR 
61df cd a6 fd			call debug_vector  
61e2				endm  
# End of macro CALLMONITOR
61e2					endif 
61e2					; get port 
61e2			 
61e2			 
61e2					; get byte to send 
61e2			 
61e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
61e2 cd 0e 22			call macro_dsp_valuehl 
61e5				endm 
# End of macro FORTH_DSP_VALUEHL
61e5			 
61e5			;		push hl    ; u1  
61e5			 
61e5					; destroy value TOS 
61e5			 
61e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
61e5 cd c6 22			call macro_forth_dsp_pop 
61e8				endm 
# End of macro FORTH_DSP_POP
61e8			 
61e8					; one value on hl get other one back 
61e8			 
61e8			;		pop hl   ; u2 - addr 
61e8			 
61e8					; TODO Send SPI byte 
61e8			 
61e8			;		push hl 
61e8			;		call spi_ce_low 
61e8			;		pop hl 
61e8 7d					ld a, l 
61e9 cd 0f 01				call spi_send_byte 
61ec			;		call spi_ce_high 
61ec			 
61ec					NEXTW 
61ec cd a3 fd			call parse_vector 
61ef c3 f5 23			jp macro_next 
61f2				endm 
# End of macro NEXTW
61f2			 
61f2			.SPII: 
61f2				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
61f2 52				db WORD_SYS_CORE+62             
61f3 5e 62			dw .SESEL            
61f5 06				db 5 + 1 
61f6 .. 00			db "SPII",0              
61fb				endm 
# End of macro CWHEAD
61fb			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
61fb					if DEBUG_FORTH_WORDS_KEY 
61fb						DMARK "SPi" 
61fb f5				push af  
61fc 3a 10 62			ld a, (.dmark)  
61ff 32 99 fd			ld (debug_mark),a  
6202 3a 11 62			ld a, (.dmark+1)  
6205 32 9a fd			ld (debug_mark+1),a  
6208 3a 12 62			ld a, (.dmark+2)  
620b 32 9b fd			ld (debug_mark+2),a  
620e 18 03			jr .pastdmark  
6210 ..			.dmark: db "SPi"  
6213 f1			.pastdmark: pop af  
6214			endm  
# End of macro DMARK
6214						CALLMONITOR 
6214 cd a6 fd			call debug_vector  
6217				endm  
# End of macro CALLMONITOR
6217					endif 
6217			 
6217					; TODO Get SPI byte 
6217			 
6217 cd 33 01				call spi_read_byte 
621a			 
621a					if DEBUG_FORTH_WORDS 
621a						DMARK "Si2" 
621a f5				push af  
621b 3a 2f 62			ld a, (.dmark)  
621e 32 99 fd			ld (debug_mark),a  
6221 3a 30 62			ld a, (.dmark+1)  
6224 32 9a fd			ld (debug_mark+1),a  
6227 3a 31 62			ld a, (.dmark+2)  
622a 32 9b fd			ld (debug_mark+2),a  
622d 18 03			jr .pastdmark  
622f ..			.dmark: db "Si2"  
6232 f1			.pastdmark: pop af  
6233			endm  
# End of macro DMARK
6233						CALLMONITOR 
6233 cd a6 fd			call debug_vector  
6236				endm  
# End of macro CALLMONITOR
6236					endif 
6236 26 00				ld h, 0 
6238 6f					ld l, a 
6239					if DEBUG_FORTH_WORDS 
6239						DMARK "Si3" 
6239 f5				push af  
623a 3a 4e 62			ld a, (.dmark)  
623d 32 99 fd			ld (debug_mark),a  
6240 3a 4f 62			ld a, (.dmark+1)  
6243 32 9a fd			ld (debug_mark+1),a  
6246 3a 50 62			ld a, (.dmark+2)  
6249 32 9b fd			ld (debug_mark+2),a  
624c 18 03			jr .pastdmark  
624e ..			.dmark: db "Si3"  
6251 f1			.pastdmark: pop af  
6252			endm  
# End of macro DMARK
6252						CALLMONITOR 
6252 cd a6 fd			call debug_vector  
6255				endm  
# End of macro CALLMONITOR
6255					endif 
6255 cd 12 20				call forth_push_numhl 
6258			 
6258					NEXTW 
6258 cd a3 fd			call parse_vector 
625b c3 f5 23			jp macro_next 
625e				endm 
# End of macro NEXTW
625e			 
625e			 
625e			 
625e			.SESEL: 
625e				CWHEAD .SESELS 82 "BANK?" 5 WORD_FLAG_CODE 
625e 66				db WORD_SYS_CORE+82             
625f 95 62			dw .SESELS            
6261 06				db 5 + 1 
6262 .. 00			db "BANK?",0              
6268				endm 
# End of macro CWHEAD
6268			; | BANK? ( -- u ) Reports on the serial EEPROM Bank Device at bank address u1 1-5.  | DONE 
6268			; | | Zero is disabled storage. 
6268					if DEBUG_FORTH_WORDS_KEY 
6268						DMARK "BN?" 
6268 f5				push af  
6269 3a 7d 62			ld a, (.dmark)  
626c 32 99 fd			ld (debug_mark),a  
626f 3a 7e 62			ld a, (.dmark+1)  
6272 32 9a fd			ld (debug_mark+1),a  
6275 3a 7f 62			ld a, (.dmark+2)  
6278 32 9b fd			ld (debug_mark+2),a  
627b 18 03			jr .pastdmark  
627d ..			.dmark: db "BN?"  
6280 f1			.pastdmark: pop af  
6281			endm  
# End of macro DMARK
6281						CALLMONITOR 
6281 cd a6 fd			call debug_vector  
6284				endm  
# End of macro CALLMONITOR
6284					endif 
6284 3a 8d f9				ld a, (spi_device_id) 
6287 d6 30				sub '0' 
6289 26 00				ld h, 0 
628b 6f					ld l, a 
628c cd 12 20				call forth_push_numhl 
628f					NEXTW 
628f cd a3 fd			call parse_vector 
6292 c3 f5 23			jp macro_next 
6295				endm 
# End of macro NEXTW
6295			.SESELS: 
6295				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
6295 66				db WORD_SYS_CORE+82             
6296 40 63			dw .CARTDEV            
6298 05				db 4 + 1 
6299 .. 00			db "BANK",0              
629e				endm 
# End of macro CWHEAD
629e			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV).  | DONE 
629e			; | | Set to zero to disable storage. 
629e					if DEBUG_FORTH_WORDS_KEY 
629e						DMARK "BNK" 
629e f5				push af  
629f 3a b3 62			ld a, (.dmark)  
62a2 32 99 fd			ld (debug_mark),a  
62a5 3a b4 62			ld a, (.dmark+1)  
62a8 32 9a fd			ld (debug_mark+1),a  
62ab 3a b5 62			ld a, (.dmark+2)  
62ae 32 9b fd			ld (debug_mark+2),a  
62b1 18 03			jr .pastdmark  
62b3 ..			.dmark: db "BNK"  
62b6 f1			.pastdmark: pop af  
62b7			endm  
# End of macro DMARK
62b7						CALLMONITOR 
62b7 cd a6 fd			call debug_vector  
62ba				endm  
# End of macro CALLMONITOR
62ba					endif 
62ba			 
62ba 3e ff				ld a, 255 
62bc 32 91 f9				ld (spi_cartdev), a 
62bf			 
62bf					; get bank 
62bf			 
62bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
62bf cd 0e 22			call macro_dsp_valuehl 
62c2				endm 
# End of macro FORTH_DSP_VALUEHL
62c2			 
62c2			;		push hl 
62c2			 
62c2					; destroy value TOS 
62c2			 
62c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
62c2 cd c6 22			call macro_forth_dsp_pop 
62c5				endm 
# End of macro FORTH_DSP_POP
62c5			 
62c5					; one value on hl get other one back 
62c5			 
62c5			;		pop hl 
62c5			 
62c5			 
62c5 0e ff				ld c, SPI_CE_HIGH 
62c7 06 30				ld b, '0'    ; human readable bank number 
62c9			 
62c9 7d					ld a, l 
62ca			 
62ca					if DEBUG_FORTH_WORDS 
62ca						DMARK "BNK" 
62ca f5				push af  
62cb 3a df 62			ld a, (.dmark)  
62ce 32 99 fd			ld (debug_mark),a  
62d1 3a e0 62			ld a, (.dmark+1)  
62d4 32 9a fd			ld (debug_mark+1),a  
62d7 3a e1 62			ld a, (.dmark+2)  
62da 32 9b fd			ld (debug_mark+2),a  
62dd 18 03			jr .pastdmark  
62df ..			.dmark: db "BNK"  
62e2 f1			.pastdmark: pop af  
62e3			endm  
# End of macro DMARK
62e3						CALLMONITOR 
62e3 cd a6 fd			call debug_vector  
62e6				endm  
# End of macro CALLMONITOR
62e6					endif 
62e6			 
62e6					; active low 
62e6			 
62e6			;		cp 0 
62e6 b7					or a 
62e7 28 28				jr z, .bset 
62e9 fe 01				cp 1 
62eb 20 04				jr nz, .b2 
62ed cb 81				res 0, c 
62ef 06 31				ld b, '1'    ; human readable bank number 
62f1 fe 02		.b2:		cp 2 
62f3 20 04				jr nz, .b3 
62f5 cb 89				res 1, c 
62f7 06 32				ld b, '2'    ; human readable bank number 
62f9 fe 03		.b3:		cp 3 
62fb 20 04				jr nz, .b4 
62fd cb 91				res 2, c 
62ff 06 33				ld b, '3'    ; human readable bank number 
6301 fe 04		.b4:		cp 4 
6303 20 04				jr nz, .b5 
6305 cb 99				res 3, c 
6307 06 34				ld b, '4'    ; human readable bank number 
6309 fe 05		.b5:		cp 5 
630b 20 04				jr nz, .bset 
630d cb a1				res 4, c 
630f 06 35				ld b, '5'    ; human readable bank number 
6311			 
6311			.bset: 
6311 79					ld a, c 
6312 32 8e f9				ld (spi_device),a 
6315 78					ld a, b 
6316 32 8d f9				ld (spi_device_id),a 
6319					if DEBUG_FORTH_WORDS 
6319						DMARK "BN2" 
6319 f5				push af  
631a 3a 2e 63			ld a, (.dmark)  
631d 32 99 fd			ld (debug_mark),a  
6320 3a 2f 63			ld a, (.dmark+1)  
6323 32 9a fd			ld (debug_mark+1),a  
6326 3a 30 63			ld a, (.dmark+2)  
6329 32 9b fd			ld (debug_mark+2),a  
632c 18 03			jr .pastdmark  
632e ..			.dmark: db "BN2"  
6331 f1			.pastdmark: pop af  
6332			endm  
# End of macro DMARK
6332						CALLMONITOR 
6332 cd a6 fd			call debug_vector  
6335				endm  
# End of macro CALLMONITOR
6335					endif 
6335			 
6335					; set default SPI clk pulse time as disabled for BANK use 
6335			 
6335 3e 00				ld a, 0 
6337 32 92 f9				ld (spi_clktime), a 
633a			 
633a					NEXTW 
633a cd a3 fd			call parse_vector 
633d c3 f5 23			jp macro_next 
6340				endm 
# End of macro NEXTW
6340			 
6340			.CARTDEV: 
6340				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
6340 66				db WORD_SYS_CORE+82             
6341 f0 63			dw .ENDDEVICE            
6343 08				db 7 + 1 
6344 .. 00			db "CARTDEV",0              
634c				endm 
# End of macro CWHEAD
634c			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). | DONE 
634c			; | | Set to zero to disable devices. 
634c					if DEBUG_FORTH_WORDS_KEY 
634c						DMARK "CDV" 
634c f5				push af  
634d 3a 61 63			ld a, (.dmark)  
6350 32 99 fd			ld (debug_mark),a  
6353 3a 62 63			ld a, (.dmark+1)  
6356 32 9a fd			ld (debug_mark+1),a  
6359 3a 63 63			ld a, (.dmark+2)  
635c 32 9b fd			ld (debug_mark+2),a  
635f 18 03			jr .pastdmark  
6361 ..			.dmark: db "CDV"  
6364 f1			.pastdmark: pop af  
6365			endm  
# End of macro DMARK
6365						CALLMONITOR 
6365 cd a6 fd			call debug_vector  
6368				endm  
# End of macro CALLMONITOR
6368					endif 
6368			 
6368					; disable se storage bank selection 
6368			 
6368 3e ff				ld a, SPI_CE_HIGH		; ce high 
636a 32 8e f9				ld (spi_device), a 
636d			 
636d					; get bank 
636d			 
636d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
636d cd 0e 22			call macro_dsp_valuehl 
6370				endm 
# End of macro FORTH_DSP_VALUEHL
6370			 
6370			;		push hl 
6370			 
6370					; destroy value TOS 
6370			 
6370					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6370 cd c6 22			call macro_forth_dsp_pop 
6373				endm 
# End of macro FORTH_DSP_POP
6373			 
6373					; one value on hl get other one back 
6373			 
6373			;		pop hl 
6373			 
6373					; active low 
6373			 
6373 0e ff				ld c, 255 
6375			 
6375 7d					ld a, l 
6376					if DEBUG_FORTH_WORDS 
6376						DMARK "CDV" 
6376 f5				push af  
6377 3a 8b 63			ld a, (.dmark)  
637a 32 99 fd			ld (debug_mark),a  
637d 3a 8c 63			ld a, (.dmark+1)  
6380 32 9a fd			ld (debug_mark+1),a  
6383 3a 8d 63			ld a, (.dmark+2)  
6386 32 9b fd			ld (debug_mark+2),a  
6389 18 03			jr .pastdmark  
638b ..			.dmark: db "CDV"  
638e f1			.pastdmark: pop af  
638f			endm  
# End of macro DMARK
638f						CALLMONITOR 
638f cd a6 fd			call debug_vector  
6392				endm  
# End of macro CALLMONITOR
6392					endif 
6392			;		cp 0 
6392 b7					or a 
6393 28 30				jr z, .cset 
6395 fe 01				cp 1 
6397 20 02				jr nz, .c2 
6399 cb 81				res 0, c 
639b fe 02		.c2:		cp 2 
639d 20 02				jr nz, .c3 
639f cb 89				res 1, c 
63a1 fe 03		.c3:		cp 3 
63a3 20 02				jr nz, .c4 
63a5 cb 91				res 2, c 
63a7 fe 04		.c4:		cp 4 
63a9 20 02				jr nz, .c5 
63ab cb 99				res 3, c 
63ad fe 05		.c5:		cp 5 
63af 20 02				jr nz, .c6 
63b1 cb a1				res 4, c 
63b3 fe 06		.c6:		cp 6 
63b5 20 02				jr nz, .c7 
63b7 cb a9				res 5, c 
63b9 fe 07		.c7:		cp 7 
63bb 20 02				jr nz, .c8 
63bd cb b1				res 6, c 
63bf fe 08		.c8:		cp 8 
63c1 20 02				jr nz, .cset 
63c3 cb b9				res 7, c 
63c5 79			.cset:		ld a, c 
63c6 32 91 f9				ld (spi_cartdev),a 
63c9			 
63c9					if DEBUG_FORTH_WORDS 
63c9						DMARK "CD2" 
63c9 f5				push af  
63ca 3a de 63			ld a, (.dmark)  
63cd 32 99 fd			ld (debug_mark),a  
63d0 3a df 63			ld a, (.dmark+1)  
63d3 32 9a fd			ld (debug_mark+1),a  
63d6 3a e0 63			ld a, (.dmark+2)  
63d9 32 9b fd			ld (debug_mark+2),a  
63dc 18 03			jr .pastdmark  
63de ..			.dmark: db "CD2"  
63e1 f1			.pastdmark: pop af  
63e2			endm  
# End of macro DMARK
63e2						CALLMONITOR 
63e2 cd a6 fd			call debug_vector  
63e5				endm  
# End of macro CALLMONITOR
63e5					endif 
63e5			 
63e5					; set default SPI clk pulse time as 10ms for CARTDEV use 
63e5			 
63e5 3e 0a				ld a, $0a 
63e7 32 92 f9				ld (spi_clktime), a 
63ea					NEXTW 
63ea cd a3 fd			call parse_vector 
63ed c3 f5 23			jp macro_next 
63f0				endm 
# End of macro NEXTW
63f0			endif 
63f0			 
63f0			.ENDDEVICE: 
63f0			; eof 
63f0			 
# End of file forth_words_device.asm
63f0			 
63f0			; var handler 
63f0			 
63f0			 
63f0			.VARS: 
63f0				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
63f0 77				db WORD_SYS_CORE+99             
63f1 a4 64			dw .V0            
63f3 04				db 3 + 1 
63f4 .. 00			db "VAR",0              
63f8				endm 
# End of macro CWHEAD
63f8			; | VAR ( u1 -- )  Get the address of the (word) variable referenced on TOS  | DONE 
63f8			; | 
63f8			; | | The variable name should consist of a single letter (a-z). e.g. "a" 
63f8			; | |  
63f8			; | | e.g. 
63f8			; | |         #30 a var ! 
63f8			; | |         a var @ . 
63f8			; | |   
63f8			; | |     Displays the number 30 
63f8			; | | 
63f8			; | | Each variable pointer is a word so can use for any words that use that:  
63f8			; | |  
63f8			; | | e.g. 
63f8			; | |  
63f8			; | |         #30 a var 2! 
63f8			; | |         a var 2@ . 
63f8			; | |   
63f8			; | |     Displays the number 30 
63f8			; | |  
63f8			; | | > [!NOTE]  
63f8			; ! | > If a full string is passed then only the first char is looked at 
63f8			; | | > Any other char could exceed bounds checks!  
63f8			; | | > 
63f8			; | | > Each variable location follows the previous. Watch you don't clobber any others. 
63f8			 
63f8					if DEBUG_FORTH_WORDS_KEY 
63f8						DMARK "VAR" 
63f8 f5				push af  
63f9 3a 0d 64			ld a, (.dmark)  
63fc 32 99 fd			ld (debug_mark),a  
63ff 3a 0e 64			ld a, (.dmark+1)  
6402 32 9a fd			ld (debug_mark+1),a  
6405 3a 0f 64			ld a, (.dmark+2)  
6408 32 9b fd			ld (debug_mark+2),a  
640b 18 03			jr .pastdmark  
640d ..			.dmark: db "VAR"  
6410 f1			.pastdmark: pop af  
6411			endm  
# End of macro DMARK
6411						CALLMONITOR 
6411 cd a6 fd			call debug_vector  
6414				endm  
# End of macro CALLMONITOR
6414					endif 
6414			 
6414					FORTH_DSP_VALUEHL 
6414 cd 0e 22			call macro_dsp_valuehl 
6417				endm 
# End of macro FORTH_DSP_VALUEHL
6417			 
6417 7e					ld a, (hl)    ; get first char on of the string 
6418			 
6418			 
6418					if DEBUG_FORTH_WORDS 
6418						DMARK "VR1" 
6418 f5				push af  
6419 3a 2d 64			ld a, (.dmark)  
641c 32 99 fd			ld (debug_mark),a  
641f 3a 2e 64			ld a, (.dmark+1)  
6422 32 9a fd			ld (debug_mark+1),a  
6425 3a 2f 64			ld a, (.dmark+2)  
6428 32 9b fd			ld (debug_mark+2),a  
642b 18 03			jr .pastdmark  
642d ..			.dmark: db "VR1"  
6430 f1			.pastdmark: pop af  
6431			endm  
# End of macro DMARK
6431						CALLMONITOR 
6431 cd a6 fd			call debug_vector  
6434				endm  
# End of macro CALLMONITOR
6434					endif 
6434					 
6434 f5					push af	 
6435					FORTH_DSP_POP 
6435 cd c6 22			call macro_forth_dsp_pop 
6438				endm 
# End of macro FORTH_DSP_POP
6438 f1					pop af 
6439			 
6439					; convert to upper 
6439			 
6439 cd 19 12				call to_upper 
643c					if DEBUG_FORTH_WORDS 
643c						DMARK "Vaa" 
643c f5				push af  
643d 3a 51 64			ld a, (.dmark)  
6440 32 99 fd			ld (debug_mark),a  
6443 3a 52 64			ld a, (.dmark+1)  
6446 32 9a fd			ld (debug_mark+1),a  
6449 3a 53 64			ld a, (.dmark+2)  
644c 32 9b fd			ld (debug_mark+2),a  
644f 18 03			jr .pastdmark  
6451 ..			.dmark: db "Vaa"  
6454 f1			.pastdmark: pop af  
6455			endm  
# End of macro DMARK
6455						CALLMONITOR 
6455 cd a6 fd			call debug_vector  
6458				endm  
# End of macro CALLMONITOR
6458					endif 
6458 06 41				ld b, 'A' 
645a 90					sub b			; set offset 
645b					if DEBUG_FORTH_WORDS 
645b						DMARK "Vbb" 
645b f5				push af  
645c 3a 70 64			ld a, (.dmark)  
645f 32 99 fd			ld (debug_mark),a  
6462 3a 71 64			ld a, (.dmark+1)  
6465 32 9a fd			ld (debug_mark+1),a  
6468 3a 72 64			ld a, (.dmark+2)  
646b 32 9b fd			ld (debug_mark+2),a  
646e 18 03			jr .pastdmark  
6470 ..			.dmark: db "Vbb"  
6473 f1			.pastdmark: pop af  
6474			endm  
# End of macro DMARK
6474						CALLMONITOR 
6474 cd a6 fd			call debug_vector  
6477				endm  
# End of macro CALLMONITOR
6477					endif 
6477 cb 27				sla a  
6479				 
6479					 
6479					if DEBUG_FORTH_WORDS 
6479						DMARK "VR2" 
6479 f5				push af  
647a 3a 8e 64			ld a, (.dmark)  
647d 32 99 fd			ld (debug_mark),a  
6480 3a 8f 64			ld a, (.dmark+1)  
6483 32 9a fd			ld (debug_mark+1),a  
6486 3a 90 64			ld a, (.dmark+2)  
6489 32 9b fd			ld (debug_mark+2),a  
648c 18 03			jr .pastdmark  
648e ..			.dmark: db "VR2"  
6491 f1			.pastdmark: pop af  
6492			endm  
# End of macro DMARK
6492						CALLMONITOR 
6492 cd a6 fd			call debug_vector  
6495				endm  
# End of macro CALLMONITOR
6495					endif 
6495			 
6495 21 22 f9				ld hl, cli_var_array2 
6498 cd b1 0f				call addatohl 
649b cd 12 20				call forth_push_numhl 
649e			 
649e			 
649e				       NEXTW 
649e cd a3 fd			call parse_vector 
64a1 c3 f5 23			jp macro_next 
64a4				endm 
# End of macro NEXTW
64a4			.V0: 
64a4				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
64a4 78				db WORD_SYS_CORE+100             
64a5 bf 64			dw .V0Q            
64a7 04				db 3 + 1 
64a8 .. 00			db "V0!",0              
64ac				endm 
# End of macro CWHEAD
64ac			;| V0! ( u1 -- )  Store value to v0  | DONE 
64ac			 
64ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
64ac cd 0e 22			call macro_dsp_valuehl 
64af				endm 
# End of macro FORTH_DSP_VALUEHL
64af			 
64af 11 56 f9				ld de, cli_var_array 
64b2			 
64b2 eb					ex de, hl 
64b3 73					ld (hl), e 
64b4 23					inc hl 
64b5 72					ld (hl), d 
64b6			 
64b6					; destroy value TOS 
64b6			 
64b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
64b6 cd c6 22			call macro_forth_dsp_pop 
64b9				endm 
# End of macro FORTH_DSP_POP
64b9			 
64b9				       NEXTW 
64b9 cd a3 fd			call parse_vector 
64bc c3 f5 23			jp macro_next 
64bf				endm 
# End of macro NEXTW
64bf			.V0Q: 
64bf				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
64bf 79				db WORD_SYS_CORE+101             
64c0 d3 64			dw .V1S            
64c2 04				db 3 + 1 
64c3 .. 00			db "V0@",0              
64c7				endm 
# End of macro CWHEAD
64c7			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
64c7 2a 56 f9				ld hl, (cli_var_array) 
64ca cd 12 20				call forth_push_numhl 
64cd			 
64cd				       NEXTW 
64cd cd a3 fd			call parse_vector 
64d0 c3 f5 23			jp macro_next 
64d3				endm 
# End of macro NEXTW
64d3			.V1S: 
64d3				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
64d3 7a				db WORD_SYS_CORE+102             
64d4 ee 64			dw .V1Q            
64d6 04				db 3 + 1 
64d7 .. 00			db "V1!",0              
64db				endm 
# End of macro CWHEAD
64db			;| V1! ( u1 -- )  Store value to v1 | DONE 
64db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
64db cd 0e 22			call macro_dsp_valuehl 
64de				endm 
# End of macro FORTH_DSP_VALUEHL
64de			 
64de 11 58 f9				ld de, cli_var_array+2 
64e1				 
64e1 eb					ex de, hl 
64e2 73					ld (hl), e 
64e3 23					inc hl 
64e4 72					ld (hl), d 
64e5			 
64e5					; destroy value TOS 
64e5			 
64e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
64e5 cd c6 22			call macro_forth_dsp_pop 
64e8				endm 
# End of macro FORTH_DSP_POP
64e8				       NEXTW 
64e8 cd a3 fd			call parse_vector 
64eb c3 f5 23			jp macro_next 
64ee				endm 
# End of macro NEXTW
64ee			.V1Q: 
64ee				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
64ee 7b				db WORD_SYS_CORE+103             
64ef 02 65			dw .V2S            
64f1 04				db 3 + 1 
64f2 .. 00			db "V1@",0              
64f6				endm 
# End of macro CWHEAD
64f6			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
64f6 2a 58 f9				ld hl, (cli_var_array+2) 
64f9 cd 12 20				call forth_push_numhl 
64fc				       NEXTW 
64fc cd a3 fd			call parse_vector 
64ff c3 f5 23			jp macro_next 
6502				endm 
# End of macro NEXTW
6502			.V2S: 
6502				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
6502 7c				db WORD_SYS_CORE+104             
6503 1d 65			dw .V2Q            
6505 04				db 3 + 1 
6506 .. 00			db "V2!",0              
650a				endm 
# End of macro CWHEAD
650a			;| V2! ( u1 -- )  Store value to v2 | DONE 
650a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
650a cd 0e 22			call macro_dsp_valuehl 
650d				endm 
# End of macro FORTH_DSP_VALUEHL
650d			 
650d 11 5a f9				ld de, cli_var_array+4 
6510				 
6510 eb					ex de, hl 
6511 73					ld (hl), e 
6512 23					inc hl 
6513 72					ld (hl), d 
6514			 
6514					; destroy value TOS 
6514			 
6514					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6514 cd c6 22			call macro_forth_dsp_pop 
6517				endm 
# End of macro FORTH_DSP_POP
6517				       NEXTW 
6517 cd a3 fd			call parse_vector 
651a c3 f5 23			jp macro_next 
651d				endm 
# End of macro NEXTW
651d			.V2Q: 
651d				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
651d 7d				db WORD_SYS_CORE+105             
651e 31 65			dw .V3S            
6520 04				db 3 + 1 
6521 .. 00			db "V2@",0              
6525				endm 
# End of macro CWHEAD
6525			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
6525 2a 5a f9				ld hl, (cli_var_array+4) 
6528 cd 12 20				call forth_push_numhl 
652b				       NEXTW 
652b cd a3 fd			call parse_vector 
652e c3 f5 23			jp macro_next 
6531				endm 
# End of macro NEXTW
6531			.V3S: 
6531				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
6531 7c				db WORD_SYS_CORE+104             
6532 4c 65			dw .V3Q            
6534 04				db 3 + 1 
6535 .. 00			db "V3!",0              
6539				endm 
# End of macro CWHEAD
6539			;| V3! ( u1 -- )  Store value to v3 | DONE 
6539					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6539 cd 0e 22			call macro_dsp_valuehl 
653c				endm 
# End of macro FORTH_DSP_VALUEHL
653c			 
653c 11 5c f9				ld de, cli_var_array+6 
653f				 
653f eb					ex de, hl 
6540 73					ld (hl), e 
6541 23					inc hl 
6542 72					ld (hl), d 
6543			 
6543					; destroy value TOS 
6543			 
6543					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6543 cd c6 22			call macro_forth_dsp_pop 
6546				endm 
# End of macro FORTH_DSP_POP
6546				       NEXTW 
6546 cd a3 fd			call parse_vector 
6549 c3 f5 23			jp macro_next 
654c				endm 
# End of macro NEXTW
654c			.V3Q: 
654c				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
654c 7d				db WORD_SYS_CORE+105             
654d 60 65			dw .END            
654f 04				db 3 + 1 
6550 .. 00			db "V3@",0              
6554				endm 
# End of macro CWHEAD
6554			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
6554 2a 5c f9				ld hl, (cli_var_array+6) 
6557 cd 12 20				call forth_push_numhl 
655a				       NEXTW 
655a cd a3 fd			call parse_vector 
655d c3 f5 23			jp macro_next 
6560				endm 
# End of macro NEXTW
6560			 
6560			 
6560			 
6560			 
6560			 
6560			; end of dict marker 
6560			 
6560 00			.END:    db WORD_SYS_END 
6561 00 00			dw 0 
6563 00				db 0 
6564			 
6564			; use to jp here for user dict words to save on macro expansion  
6564			 
6564			user_dict_next: 
6564				NEXTW 
6564 cd a3 fd			call parse_vector 
6567 c3 f5 23			jp macro_next 
656a				endm 
# End of macro NEXTW
656a			 
656a			 
656a			user_exec: 
656a				;    ld hl, <word code> 
656a				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
656a				;    call forthexec 
656a				;    jp user_dict_next   (NEXT) 
656a			        ;    <word code bytes> 
656a eb				ex de, hl 
656b 2a f0 f3			ld hl,(os_tok_ptr) 
656e				 
656e				FORTH_RSP_NEXT 
656e cd b9 1f			call macro_forth_rsp_next 
6571				endm 
# End of macro FORTH_RSP_NEXT
6571			 
6571			if DEBUG_FORTH_UWORD 
6571						DMARK "UEX" 
6571 f5				push af  
6572 3a 86 65			ld a, (.dmark)  
6575 32 99 fd			ld (debug_mark),a  
6578 3a 87 65			ld a, (.dmark+1)  
657b 32 9a fd			ld (debug_mark+1),a  
657e 3a 88 65			ld a, (.dmark+2)  
6581 32 9b fd			ld (debug_mark+2),a  
6584 18 03			jr .pastdmark  
6586 ..			.dmark: db "UEX"  
6589 f1			.pastdmark: pop af  
658a			endm  
# End of macro DMARK
658a				CALLMONITOR 
658a cd a6 fd			call debug_vector  
658d				endm  
# End of macro CALLMONITOR
658d			endif 
658d			 
658d			 
658d			 
658d eb				ex de, hl 
658e 22 f0 f3			ld (os_tok_ptr), hl 
6591				 
6591				; Don't use next - Skips the first word in uword. 
6591			 
6591 c3 76 24			jp exec1 
6594			;	NEXT 
6594			 
6594			 
6594			; eof 
# End of file forth_wordsv4.asm
6594			endif 
6594			;;;;;;;;;;;;;; Debug code 
6594			 
6594			 
6594			;if DEBUG_FORTH_PARSE 
6594 .. 00		.nowordfound: db "No match",0 
659d .. 00		.compword:	db "Comparing word ",0 
65ad .. 00		.nextwordat:	db "Next word at",0 
65ba .. 00		.charmatch:	db "Char match",0 
65c5			;endif 
65c5			if DEBUG_FORTH_JP 
65c5			.foundword:	db "Word match. Exec..",0 
65c5			endif 
65c5			;if DEBUG_FORTH_PUSH 
65c5 .. 00		.enddict:	db "Dict end. Push.",0 
65d5 .. 00		.push_str:	db "Pushing string",0 
65e4 .. 00		.push_num:	db "Pushing number",0 
65f3 .. 00		.data_sp:	db "SP:",0 
65f7 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
6609 .. 00		.wordinde:	db "Word in DE (3/0):",0 
661b .. 00		.wordinbc:	db "Word in BC (4/0):",0 
662d			;endif 
662d			;if DEBUG_FORTH_MALLOC 
662d .. 00		.push_malloc:	db "Malloc address",0 
663c			;endif 
663c			 
663c			 
663c			 
663c			; display malloc address and current data stack pointer  
663c			 
663c			malloc_error: 
663c d5				push de 
663d f5				push af 
663e e5				push hl 
663f cd 81 0d			call clear_display 
6642 11 62 66			ld de, .mallocerr 
6645 3e 00			ld a,0 
6647			;	ld de,os_word_scratch 
6647 cd 93 0d			call str_at_display 
664a 3e 11			ld a, display_row_1+17 
664c 11 99 fd			ld de, debug_mark 
664f cd 93 0d			call str_at_display 
6652 cd a3 0d			call update_display 
6655				;call break_point_state 
6655 cd ec 7c			call cin_wait 
6658			 
6658			;	ld a, ' ' 
6658			;	ld (os_view_disable), a 
6658 cd e1 18			call bp_on 
665b e1				pop hl 
665c f1				pop af 
665d d1				pop de	 
665e				CALLMONITOR 
665e cd a6 fd			call debug_vector  
6661				endm  
# End of macro CALLMONITOR
6661 c9				ret 
6662			 
6662 .. 00		.mallocerr: 	db "Malloc Error",0 
666f			;if DEBUG_FORTH_PUSH 
666f			display_data_sp: 
666f f5				push af 
6670			 
6670				; see if disabled 
6670			 
6670			 
6670 3a a6 fd			ld a, (debug_vector) 
6673 fe c9			cp $C9  ; RET 
6675				;ld a, (os_view_disable) 
6675				;cp '*' 
6675 28 65			jr z, .skipdsp 
6677			 
6677 e5				push hl 
6678 e5				push hl 
6679 e5			push hl 
667a cd 81 0d			call clear_display 
667d e1			pop hl 
667e 7c				ld a,h 
667f 21 f4 f3			ld hl, os_word_scratch 
6682 cd ad 11			call hexout 
6685 e1				pop hl 
6686 7d				ld a,l 
6687 21 f6 f3			ld hl, os_word_scratch+2 
668a cd ad 11			call hexout 
668d 21 f8 f3			ld hl, os_word_scratch+4 
6690			;	ld a,0 
6690 36 00			ld (hl),0 
6692 11 f4 f3			ld de,os_word_scratch 
6695 3e 28				ld a, display_row_2 
6697 cd 93 0d				call str_at_display 
669a 11 f7 65			ld de, .wordinhl 
669d 3e 00			ld a, display_row_1 
669f			 
669f cd 93 0d				call str_at_display 
66a2 11 99 fd			ld de, debug_mark 
66a5 3e 11			ld a, display_row_1+17 
66a7			 
66a7 cd 93 0d				call str_at_display 
66aa			 
66aa				; display current data stack pointer 
66aa 11 f3 65			ld de,.data_sp 
66ad 3e 30				ld a, display_row_2 + 8 
66af cd 93 0d				call str_at_display 
66b2			 
66b2 2a 1c f9			ld hl,(cli_data_sp) 
66b5 e5				push hl 
66b6 7c				ld a,h 
66b7 21 f4 f3			ld hl, os_word_scratch 
66ba cd ad 11			call hexout 
66bd e1				pop hl 
66be 7d				ld a,l 
66bf 21 f6 f3			ld hl, os_word_scratch+2 
66c2 cd ad 11			call hexout 
66c5 21 f8 f3			ld hl, os_word_scratch+4 
66c8			;	ld a,0 
66c8 36 00			ld (hl),0 
66ca 11 f4 f3			ld de,os_word_scratch 
66cd 3e 33				ld a, display_row_2 + 11 
66cf cd 93 0d				call str_at_display 
66d2			 
66d2			 
66d2 cd a3 0d			call update_display 
66d5 cd c0 0c			call delay1s 
66d8 cd c0 0c			call delay1s 
66db e1				pop hl 
66dc			.skipdsp: 
66dc f1				pop af 
66dd c9				ret 
66de			 
66de			display_data_malloc: 
66de			 
66de f5				push af 
66df e5				push hl 
66e0 e5				push hl 
66e1 e5			push hl 
66e2 cd 81 0d			call clear_display 
66e5 e1			pop hl 
66e6 7c				ld a,h 
66e7 21 f4 f3			ld hl, os_word_scratch 
66ea cd ad 11			call hexout 
66ed e1				pop hl 
66ee 7d				ld a,l 
66ef 21 f6 f3			ld hl, os_word_scratch+2 
66f2 cd ad 11			call hexout 
66f5 21 f8 f3			ld hl, os_word_scratch+4 
66f8			;	ld a,0 
66f8 36 00			ld (hl),0 
66fa 11 f4 f3			ld de,os_word_scratch 
66fd 3e 28				ld a, display_row_2 
66ff cd 93 0d				call str_at_display 
6702 11 2d 66			ld de, .push_malloc 
6705 3e 00			ld a, display_row_1 
6707			 
6707 cd 93 0d				call str_at_display 
670a			 
670a				; display current data stack pointer 
670a 11 f3 65			ld de,.data_sp 
670d 3e 30				ld a, display_row_2 + 8 
670f cd 93 0d				call str_at_display 
6712			 
6712 2a 1c f9			ld hl,(cli_data_sp) 
6715 e5				push hl 
6716 7c				ld a,h 
6717 21 f4 f3			ld hl, os_word_scratch 
671a cd ad 11			call hexout 
671d e1				pop hl 
671e 7d				ld a,l 
671f 21 f6 f3			ld hl, os_word_scratch+2 
6722 cd ad 11			call hexout 
6725 21 f8 f3			ld hl, os_word_scratch+4 
6728			;	ld a,0 
6728 36 00			ld (hl),0 
672a 11 f4 f3			ld de,os_word_scratch 
672d 3e 33				ld a, display_row_2 + 11 
672f cd 93 0d				call str_at_display 
6732			 
6732 cd a3 0d			call update_display 
6735 cd c0 0c			call delay1s 
6738 cd c0 0c			call delay1s 
673b e1				pop hl 
673c f1				pop af 
673d c9				ret 
673e			;endif 
673e			 
673e			include "forth_autostart.asm" 
673e			; list of commands to perform at system start up 
673e			 
673e			startcmds: 
673e			;	dw test11 
673e			;	dw test12 
673e			;	dw test13 
673e			;	dw test14 
673e			;	dw test15 
673e			;	dw test16 
673e			;	dw test17 
673e			;	dw ifthtest1 
673e			;	dw ifthtest2 
673e			;	dw ifthtest3 
673e			;	dw mmtest1 
673e			;	dw mmtest2 
673e			;	dw mmtest3 
673e			;	dw mmtest4 
673e			;	dw mmtest5 
673e			;	dw mmtest6 
673e			;	dw iftest1 
673e			;	dw iftest2 
673e			;	dw iftest3 
673e			;	dw looptest1 
673e			;	dw looptest2 
673e			;	dw test1 
673e			;	dw test2 
673e			;	dw test3 
673e			;	dw test4 
673e			;	dw game2r 
673e			;	dw game2b1 
673e			;	dw game2b2 
673e			 
673e				; start up words that are actually useful 
673e			 
673e			;    dw spi1 
673e			;    dw spi2 
673e			;    dw spi3 
673e			;    dw spi4 
673e			;    dw spi5 
673e			;    dw spi6 
673e			;    dw spi7 
673e			; 
673e			;    dw spi8 
673e			;    dw spi9 
673e			;    dw spi10 
673e			 
673e			; file editor 
673e			;	dw edit1 
673e			;	dw edit2 
673e			;	dw edit3 
673e			 
673e			;	dw longread 
673e b3 6c			dw clrstack 
6740 e7 6c			dw type 
6742 0c 6d			dw ztype 
6744 b3 6e			dw nip 
6746 a0 6e			dw tuck 
6748			;	dw stest 
6748 43 6d			dw strncpy 
674a c5 6e			dw list 
674c a4 6d			dw start1 
674e b4 6d			dw start2 
6750			;	dw start3 
6750			;	dw start3b 
6750			;	dw start3c 
6750			 
6750				; (unit) testing words 
6750			 
6750			;	dw mtesta 
6750			;	dw mtestb 
6750			;	dw mtestc 
6750			;	dw mtestd 
6750			;	dw mteste 
6750			 
6750				; demo/game words 
6750			 
6750			;        dw game3w 
6750			;        dw game3p 
6750			;        dw game3sc 
6750			;        dw game3vsi 
6750			;        dw game3vs 
6750				 
6750			;	dw game2b 
6750			;	dw game2bf 
6750			;	dw game2mba 
6750			;	dw game2mbas 
6750			;	dw game2mb 
6750			 
6750 f6 70			dw game1 
6752 07 71			dw game1a 
6754 69 71			dw game1b 
6756 9e 71			dw game1c 
6758 d4 71			dw game1d 
675a 05 72			dw game1s 
675c 19 72			dw game1t 
675e 2e 72			dw game1f 
6760 62 72			dw game1z 
6762 a6 72			dw game1zz 
6764			 
6764 2f 6f			dw test5 
6766 67 6f			dw test6 
6768 9f 6f			dw test7 
676a b3 6f			dw test8 
676c df 6f			dw test9 
676e f5 6f			dw test10 
6770				 
6770 7d 73		        dw ssv5 
6772 61 73		        dw ssv4 
6774 45 73		        dw ssv3 
6776 0f 73		        dw ssv2 
6778 96 73		        dw ssv1 
677a de 73		        dw ssv1cpm 
677c			;	dw keyup 
677c			;	dw keydown 
677c			;	dw keyleft 
677c			;	dw keyright 
677c			;	dw 	keyf1 
677c			;	dw keyf2 
677c			;	dw keyf3 
677c			;	dw keyf4 
677c			;	dw keyf5 
677c			;	dw keyf6 
677c			;	dw keyf7 
677c			;	dw keyf8 
677c			;	dw keyf9 
677c			;	dw keyf10 
677c			;	dw keyf11 
677c			;	dw keyf12 
677c			;	dw keytab 
677c			;	dw keycr 
677c			;	dw keyhome 
677c			;	dw keyend 
677c			;	dw keybs 
677c 00 00			db 0, 0	 
677e			 
677e			 
677e			; File Editor 
677e			 
677e			; ( id - ) use 'e' to edit the displayed line 
677e .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
679f .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
67d4			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
67d4 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
680c			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
680c			 
680c			; SPI Net support words 
680c			 
680c			; v0! = node to send to 
680c			; ( str count - ) 
680c .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
6865			 
6865			; spiputc ( char node - ) 
6865 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
6899			; spiputc ( u node - ) 
6899 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
68c7			 
68c7			; spigetc ( - n ) 
68c7 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
68f0			 
68f0			; getnode ( - n ) 
68f0 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
691d			 
691d			; ( str node - )  
691d .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
6983			; store string ( str i - ) 
6983			 
6983			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
6983 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
69d8			 
69d8			; get string ( addr i -  )    TO FIX 
69d8			 
69d8 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
6a30			 
6a30			 
6a30			; user word backup 
6a30			; ubie 
6a30			; ubiall 
6a30			 
6a30 .. 00		spib1: db ": UBIALL $01 do cls ptr count type list cr concat count soctype 2drop loop ;",0 
6a7d .. 00		spib2: db ": UBIE $01 do cls ptr count type waitk $79 = if list cr concat count soctype drop then 2drop loop ;", 0 
6ae1 .. 00		spib3: db ": SPISTRZ ptr count $00 do dup i + @ spio $01 pause loop ;",0 
6b1c .. 00		spib4: db ": SOCCON spicel $22 spio spistrz ;",0 
6b3f .. 00		spib5: db ": SOCTYPE spiceh spicel $00 do dup i + @ $20 spio spio loop ;",0 
6b7d			 
6b7d			 
6b7d			; NETCHAT (TODO) 
6b7d			; Program to allow two nodes to chat with eachother 
6b7d			; 
6b7d			; v0 - target node 
6b7d			;  
6b7d			; accept input at 0,0 
6b7d			; if input is string send spitype to target node 
6b7d			; starting at row 2,0 , while spigetchr is not zero ->  
6b7d			; 
6b7d			; 
6b7d			; TODO add paging of get request 
6b7d			 
6b7d			; ( node - ) 
6b7d .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
6b9c .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
6bf4 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
6c6c			 
6c6c			 
6c6c			; Long read of currently open file 
6c6c .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
6cb3			 
6cb3			; clear stack  
6cb3			 
6cb3 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
6ce7			 
6ce7			; type ( addr count - ) 
6ce7 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6d0c .. 00		ztype:     db ": ztype repeat dup @ emit #1 + dup @ #0 = not until ; ", 0 
6d43			 
6d43			; some direct memory words 
6d43			; strncpy ( len t f -- t ) 
6d43			 
6d43 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6da4			 
6da4 .. 00		start1:     	db ": bpon $00 bp ;",0 
6db4 .. 00		start2:     	db ": bpoff $01 bp ;",0 
6dc5 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6e40 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
6ea0			 
6ea0 .. 00		tuck:         db ": tuck swap over ;", 0 
6eb3 .. 00		nip:         db ": nip swap drop ;", 0 
6ec5			 
6ec5			; a handy word to list items on the stack 
6ec5			 
6ec5 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6f2f			 
6f2f			 
6f2f			; test stack  
6f2f			; rnd8 stest 
6f2f			 
6f2f			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
6f2f			 
6f2f			; random malloc and free cycles 
6f2f			 
6f2f			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6f2f			 
6f2f			; fixed malloc and free cycles 
6f2f			 
6f2f			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6f2f			 
6f2f			; fixed double string push and drop cycle  
6f2f			 
6f2f			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
6f2f			 
6f2f			; consistent fixed string push and drop cycle  
6f2f			 
6f2f			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6f2f			 
6f2f			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6f2f			 
6f2f			;test1:		db ": aa 1 2 3 ;", 0 
6f2f			;test2:     	db "111 aa 888 999",0 
6f2f			;test3:     	db ": bb 77 ;",0 
6f2f			;test4:     	db "$02 $01 do i . loop bb",0 
6f2f			 
6f2f .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6f67 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6f9f .. 00		test7:     	db ": box hline vline ;",0 
6fb3 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6fdf .. 00		test9:     	db ": sw $01 adsp world ;",0 
6ff5 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
701a			;test11:     	db "hello create .",0 
701a			;test12:     	db "hello2 create .",0 
701a			 
701a			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
701a			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
701a			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
701a			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
701a			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
701a			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
701a			 
701a			;iftest1:     	db "$0001 IF cls .",0 
701a			;iftest2:     	db "$0000 IF cls .",0 
701a			;iftest3:     	db "$0002 $0003 - IF cls .",0 
701a			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
701a			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
701a			 
701a			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
701a			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
701a			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
701a			 
701a			 
701a .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
703e .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
706e .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
7093 .. 00		sound4: db ": cha $00 ; ",0 
70a0 .. 00		sound5: db ": chb $20 ; ",0 
70ad .. 00		sound6: db ": chc $40 ; ",0 
70ba .. 00		sound7: db ": chd $60 ; ",0 
70c7 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
70df .. 00		sound9: db ": cvol $90 + + note ; ", 0 
70f6			 
70f6			 
70f6			 
70f6			 
70f6			; a small guess the number game 
70f6			 
70f6 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
7107 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
7169			 
7169 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
719e .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
71d4 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
7205 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
7219 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
722e .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
7262 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
72a6			 
72a6			; Using 'ga' save a high score across multiple runs using external storage 
72a6			 
72a6 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
730f			 
730f			 
730f			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
730f			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
730f			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
730f			 
730f			; simple screen saver to test code memory reuse to destruction 
730f			 
730f .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
7345 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
7361 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
737d .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
7396 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
73de .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
7435			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
7435			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
7435			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
7435			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
7435			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
7435			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
7435			 
7435			 
7435			 
7435			; minesweeper/battleship finding game 
7435			; draws a game board of random ship/mine positions 
7435			; user enters coords to see if it hits on 
7435			; game ends when all are hit 
7435			; when hit or miss says how many may be in the area 
7435			 
7435			; setup the game board and then hide it 
7435			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
7435			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
7435			;; prompt for where to target 
7435			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
7435			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
7435			;; TODO see if the entered coords hits or misses pushes char hit of miss 
7435			;game2mbht:      db ": mbckht nop ;",0 
7435			;game2mbms:      db ": mbcms nop ;",0 
7435			; TODO how many might be near by 
7435			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
7435			 
7435			; Game 3 
7435			 
7435			; Vert scroller ski game - avoid the trees! 
7435			 
7435			; v0 score (ie turns) 
7435			; v1 player pos 
7435			; v2 left wall 
7435			; v3 right wall 
7435			 
7435			; Draw side walls randomly 
7435			 
7435			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
7435			 
7435			; Draw player 
7435			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
7435			 
7435			; TODO Get Key 
7435			 
7435			; TODO Move left right 
7435			 
7435			; scroll and move walls a bit 
7435			 
7435			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
7435			 
7435			; main game loop 
7435			 
7435			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
7435			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
7435			 
7435			; key board defs 
7435			 
7435 .. 00		keyup:       db ": keyup $05 ;",0 
7443 .. 00		keydown:       db ": keydown $0a ;",0 
7453 .. 00		keyleft:       db ": keyleft $0b ;",0 
7463 .. 00		keyright:       db ": keyright $0c ;",0 
7474 .. 00		keyf1:       db ": keyf1 $10 ;",0 
7482 .. 00		keyf2:       db ": keyf2 $11 ;",0 
7490 .. 00		keyf3:       db ": keyf3 $12 ;",0 
749e .. 00		keyf4:       db ": keyf4 $13 ;",0 
74ac .. 00		keyf5:       db ": keyf5 $14 ;",0 
74ba .. 00		keyf6:       db ": keyf6 $15 ;",0 
74c8 .. 00		keyf7:       db ": keyf7 $16 ;",0 
74d6 .. 00		keyf8:       db ": keyf8 $17 ;",0 
74e4 .. 00		keyf9:       db ": keyf9 $18 ;",0 
74f2 .. 00		keyf10:       db ": keyf10 $19 ;",0 
7501 .. 00		keyf11:       db ": keyf11 $1a ;",0 
7510 .. 00		keyf12:       db ": keyf12 $1b ;",0 
751f			 
751f .. 00		keytab:       db ": keytab $09 ;",0 
752e .. 00		keycr:       db ": keycr $0d ;",0 
753c .. 00		keyhome:       db ": keyhome $0e ;",0 
754c .. 00		keyend:       db ": keyend $0f ;",0 
755b .. 00		keybs:       db ": keybs $08 ;",0 
7569			 
7569			   
7569			 
7569			 
7569			 
7569			; eof 
# End of file forth_autostart.asm
7569			 
7569			 
7569			 
7569			; stack over and underflow checks 
7569			 
7569			; init the words to detect the under/overflow 
7569			 
7569			chk_stk_init: 
7569				; a vague random number to check so we dont get any "lucky" hits 
7569 3e 2d			ld a, 45 
756b 6f				ld l, a 
756c 00				nop 
756d 3e 17			ld a, 23 
756f 67				ld h, a 
7570			 
7570 22 cb f0			ld (chk_word), hl     ; the word we need to check against 
7573			 
7573			;	ld (chk_stund), hl	; stack points.... 
7573 22 3b fe			ld (chk_stovr), hl 
7576 22 1a f9			ld (chk_ret_und), hl 
7579 22 d8 f8			ld (chk_ret_ovr), hl 
757c 22 56 f8			ld (chk_loop_ovr), hl 
757f 22 54 f6			ld (chk_data_ovr), hl 
7582 c9				ret 
7583				 
7583			check_stacks: 
7583				; check all stack words 
7583			 
7583 e5				push hl 
7584 d5				push de 
7585			 
7585			;	ld de,(chk_word) 
7585			;	ld hl, (chk_stund)	; stack points.... 
7585			;	if DEBUG_STK_FAULT 
7585			;		DMARK "FAa" 
7585			;		CALLMONITOR 
7585			;	endif 
7585			;	call cmp16 
7585			;	jp z, .chk_faulta 
7585			; 
7585			;	ld de, sfaultsu 
7585			;	jp .chk_fault 
7585			 
7585 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
7588 ed 5b cb f0		ld de,(chk_word) 
758c				if DEBUG_STK_FAULT 
758c					DMARK "FAb" 
758c					CALLMONITOR 
758c				endif 
758c cd cf 0f			call cmp16 
758f 28 06			jr z, .chk_fault1 
7591 11 35 76			ld de, sfaultso 
7594 c3 e6 75			jp .chk_fault 
7597			.chk_fault1:  
7597 2a 1a f9			ld hl, (chk_ret_und) 
759a ed 5b cb f0		ld de,(chk_word) 
759e				if DEBUG_STK_FAULT 
759e					DMARK "FAU" 
759e					CALLMONITOR 
759e				endif 
759e cd cf 0f			call cmp16 
75a1 ca aa 75			jp z, .chk_fault2 
75a4 11 45 76			ld de, sfaultru 
75a7 c3 e6 75			jp .chk_fault 
75aa			.chk_fault2:  
75aa 2a d8 f8			ld hl, (chk_ret_ovr) 
75ad ed 5b cb f0		ld de,(chk_word) 
75b1				if DEBUG_STK_FAULT 
75b1					DMARK "FA1" 
75b1					CALLMONITOR 
75b1				endif 
75b1 cd cf 0f			call cmp16 
75b4 ca bd 75			jp z, .chk_fault3 
75b7 11 53 76			ld de, sfaultro 
75ba c3 e6 75			jp .chk_fault 
75bd			.chk_fault3:  
75bd 2a 56 f8			ld hl, (chk_loop_ovr) 
75c0 ed 5b cb f0		ld de,(chk_word) 
75c4				if DEBUG_STK_FAULT 
75c4					DMARK "FA2" 
75c4					CALLMONITOR 
75c4				endif 
75c4 cd cf 0f			call cmp16 
75c7 ca d0 75			jp z, .chk_fault4 
75ca 11 6d 76			ld de, sfaultlo 
75cd c3 e6 75			jp .chk_fault 
75d0			.chk_fault4:  
75d0 2a 54 f6			ld hl, (chk_data_ovr) 
75d3 ed 5b cb f0		ld de,(chk_word) 
75d7				if DEBUG_STK_FAULT 
75d7					DMARK "FA3" 
75d7					CALLMONITOR 
75d7				endif 
75d7 cd cf 0f			call cmp16 
75da ca e3 75			jp z, .chk_fault5 
75dd 11 87 76			ld de, sfaultdo 
75e0 c3 e6 75			jp .chk_fault 
75e3			 
75e3			 
75e3			.chk_fault5:  
75e3 d1				pop de 
75e4 e1				pop hl 
75e5			 
75e5 c9				ret 
75e6			 
75e6 cd 81 0d		.chk_fault: 	call clear_display 
75e9 3e 28				ld a, display_row_2 
75eb cd 93 0d				call str_at_display 
75ee 11 17 76				   ld de, .stackfault 
75f1 3e 00				ld a, display_row_1 
75f3 cd 93 0d				call str_at_display 
75f6 11 99 fd				    ld de, debug_mark 
75f9 3e 11				ld a, display_row_1+17 
75fb cd 93 0d				call str_at_display 
75fe cd a3 0d				call update_display 
7601			 
7601				; prompt before entering montior for investigating issue 
7601			 
7601 3e 78			ld a, display_row_4 
7603 11 f4 1c			ld de, endprog 
7606			 
7606 cd a3 0d			call update_display		 
7609			 
7609 cd 8a 1f			call next_page_prompt 
760c			 
760c d1				pop de 
760d e1				pop hl 
760e cd 48 1d				call monitor 
7611 cd 9b 23				call forth_warmstart 
7614 c3 46 1c				jp warmstart_afterauto 
7617					;jp 0 
7617					;halt 
7617			 
7617			 
7617			 
7617 .. 00		.stackfault: 	db "Stack fault:",0 
7624			 
7624 .. 00		sfaultsu: 	db	"Stack under flow",0 
7635 .. 00		sfaultso: 	db	"Stack over flow",0 
7645 .. 00		sfaultru:	db "RTS underflow",0 
7653 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
766d .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
7687 .. 00		sfaultdo:	db "DTS overflow", 0 
7694			 
7694			 
7694			fault_dsp_under: 
7694 11 a6 76			ld de, .dsp_under 
7697 c3 5c 77			jp .show_fault 
769a			 
769a			fault_rsp_under: 
769a 11 b4 76			ld de, .rsp_under 
769d c3 5c 77			jp .show_fault 
76a0			fault_loop_under: 
76a0 11 c2 76			ld de, .loop_under 
76a3 c3 5c 77			jp .show_fault 
76a6			 
76a6 .. 00		.dsp_under: db "DSP Underflow",0 
76b4 .. 00		.rsp_under: db "RSP Underflow",0 
76c2 .. 00		.loop_under: db "LOOP Underflow",0 
76d1			 
76d1			 
76d1 d5			type_faultn: 	push de 
76d2 e5					push hl 
76d3 cd 81 0d				call clear_display 
76d6 11 00 77				   ld de, .typefaultn 
76d9 3e 00				ld a, display_row_1 
76db cd 93 0d				call str_at_display 
76de 11 99 fd				    ld de, debug_mark 
76e1 3e 11				ld a, display_row_1+17 
76e3 cd 93 0d				call str_at_display 
76e6 cd a3 0d				call update_display 
76e9			 
76e9				; prompt before entering montior for investigating issue 
76e9			 
76e9 3e 78			ld a, display_row_4 
76eb 11 f4 1c			ld de, endprog 
76ee			 
76ee cd a3 0d			call update_display		 
76f1			 
76f1 cd 8a 1f			call next_page_prompt 
76f4			 
76f4 e5					push hl 
76f5 d5					push de 
76f6 cd 48 1d				call monitor 
76f9 cd 9b 23				call forth_warmstart 
76fc c3 46 1c				jp warmstart_afterauto 
76ff 76					halt 
7700			 
7700			 
7700 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
7717			 
7717 d5			type_faults: 	push de 
7718 e5					push hl 
7719 cd 81 0d				call clear_display 
771c 11 45 77				   ld de, .typefaults 
771f 3e 00				ld a, display_row_1 
7721 cd 93 0d				call str_at_display 
7724 11 99 fd				    ld de, debug_mark 
7727 3e 11				ld a, display_row_1+17 
7729 cd 93 0d				call str_at_display 
772c cd a3 0d				call update_display 
772f			 
772f				; prompt before entering montior for investigating issue 
772f			 
772f 3e 78			ld a, display_row_4 
7731 11 f4 1c			ld de, endprog 
7734			 
7734 cd a3 0d			call update_display		 
7737			 
7737 cd 8a 1f			call next_page_prompt 
773a			 
773a e1					pop hl 
773b d1					pop de 
773c cd 48 1d				call monitor 
773f cd 9b 23				call forth_warmstart 
7742 c3 46 1c				jp warmstart_afterauto 
7745			 
7745			 
7745 .. 00		.typefaults: db "STR Type Expected TOS!",0 
775c			 
775c			.show_fault: 	 
775c d5					push de 
775d cd 81 0d				call clear_display 
7760 d1					pop de 
7761 3e 00				ld a, display_row_1 
7763 cd 93 0d				call str_at_display 
7766 11 99 fd				    ld de, debug_mark 
7769 3e 11				ld a, display_row_1+17 
776b cd 93 0d				call str_at_display 
776e cd a3 0d				call update_display 
7771			 
7771				; prompt before entering montior for investigating issue 
7771			 
7771 3e 78			ld a, display_row_4 
7773 11 f4 1c			ld de, endprog 
7776			 
7776 cd a3 0d			call update_display		 
7779			 
7779 cd 8a 1f			call next_page_prompt 
777c			 
777c e1					pop hl 
777d d1					pop de 
777e cd 48 1d				call monitor 
7781			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7781			; TODO Make optional fault restart to cli or warm boot? 
7781					;jp warmstart 
7781 c3 89 1c				jp cli 
7784 76					halt 
7785			 
7785			 
7785			; handle the auto run of code from files in storage 
7785			 
7785			 
7785			include "forth_startup.asm" 
7785			; Which startup method to use? 
7785			; 
7785			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
7785			; followed by loading of a list of scripts in eeprom 
7785			 
7785			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
7785			; from eeprom 
7785			 
7785			; Select with define in main stubs 
7785			 
7785			if STARTUP_V1 
7785				include "forth_startupv1.asm" 
7785			endif 
7785			if STARTUP_V2 
7785				include "forth_startupv2.asm" 
7785			; Version 2 of the startup  
7785			;  
7785			; Auto load any files in bank 1 that start with a '*' 
7785			; If no se storage then revert to using eprom 
7785			 
7785			 
7785			if STORAGE_SE = 0 
7785			 
7785			sprompt1: db "Startup load...",0 
7785			sprompt2: db "Run? 1=No *=End #=All",0 
7785			 
7785			 
7785			 
7785			 
7785			forth_startup: 
7785				ld hl, startcmds 
7785				ld a, 0 
7785				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
7785			 
7785			.start1:	push hl 
7785				call clear_display 
7785				ld de, sprompt1 
7785			        ld a, display_row_1 
7785				call str_at_display 
7785				ld de, sprompt2 
7785			        ld a, display_row_2 
7785				call str_at_display 
7785				pop hl 
7785				push hl 
7785				ld e,(hl) 
7785				inc hl 
7785				ld d,(hl) 
7785			        ld a, display_row_3 
7785				call str_at_display 
7785				call update_display 
7785			 
7785			 
7785				ld a, (os_last_cmd) 
7785			;	cp 0 
7785				or a 
7785				jr z, .startprompt 
7785				call delay250ms 
7785				jr .startdo 
7785				 
7785				 
7785			 
7785			.startprompt: 
7785			 
7785				ld a,display_row_4 + display_cols - 1 
7785			        ld de, endprg 
7785				call str_at_display 
7785				call update_display 
7785				call delay1s 
7785				call cin_wait 
7785						 
7785				cp '*' 
7785				jr z, .startupend1 
7785				cp '#' 
7785				jr nz, .startno 
7785				ld a, 1 
7785				ld (os_last_cmd),a 
7785				jr .startdo 
7785			.startno:	cp '1' 
7785				jr z,.startnxt  
7785			 
7785				; exec startup line 
7785			.startdo:	 
7785				pop hl 
7785				push hl 
7785				 
7785				ld e,(hl) 
7785				inc hl 
7785				ld d,(hl) 
7785				ex de,hl 
7785			 
7785				push hl 
7785			 
7785				ld a, 0 
7785				;ld a, FORTH_END_BUFFER 
7785				call strlent 
7785				inc hl   ; include zero term to copy 
7785				ld b,0 
7785				ld c,l 
7785				pop hl 
7785				ld de, scratch 
7785				ldir 
7785			 
7785			 
7785				ld hl, scratch 
7785				call forthparse 
7785				call forthexec 
7785				call forthexec_cleanup 
7785			 
7785				ld a, display_row_4 
7785				ld de, endprog 
7785			 
7785				call update_display		 
7785			 
7785				ld a, (os_last_cmd) 
7785			;	cp 0 
7785				or a 
7785				jr nz, .startnxt 
7785				call next_page_prompt 
7785			        call clear_display 
7785				call update_display		 
7785			 
7785				; move onto next startup line? 
7785			.startnxt: 
7785			 
7785				call delay250ms 
7785				pop hl 
7785			 
7785				inc hl 
7785				inc hl 
7785			 
7785				push hl 
7785				ld e, (hl) 
7785				inc hl 
7785				ld d, (hl) 
7785				pop hl 
7785				; TODO replace 0 test 
7785			 
7785				ex de, hl 
7785				call ishlzero 
7785			;	ld a,e 
7785			;	add d 
7785			;	cp 0    ; any left to do? 
7785				ex de, hl 
7785				jp nz, .start1 
7785				jr .startupend 
7785			 
7785			.startupend1: pop hl 
7785			.startupend: 
7785			 
7785				call clear_display 
7785				call update_display 
7785				ret 
7785			endif 
7785			 
7785			 
7785			if STORAGE_SE 
7785			 
7785			;sprompt3: db "Loading from start-up file:",0 
7785 .. 00		sprompt3: db "  Searching...",0 
7794			;sprompt4: db "(Any key to stop)",0 
7794			 
7794			 
7794			forth_autoload: 
7794			 
7794				; load block 0 of store 1 
7794				 
7794 3e fe			ld a, $fe      ; bit 0 clear 
7796 32 8e f9			ld (spi_device), a 
7799			 
7799 cd 05 05			call storage_get_block_0 
779c			 
779c 3a c9 f9			ld a, (store_page+STORE_0_AUTOFILE) 
779f			 
779f			;	cp 0 
779f b7				or a 
77a0 c8				ret z     ; auto start not enabled 
77a1			 
77a1 cd 81 0d			call clear_display 
77a4			 
77a4				; set bank 
77a4			 
77a4 3a cb f9				ld a, (store_page+STORE_0_BANKRUN) 
77a7 32 8e f9				ld (spi_device), a 
77aa 3a cd f9				ld a, (store_page+STORE_0_BANKRUNN) 
77ad 32 8d f9				ld (spi_device_id), a 
77b0			 
77b0			 
77b0				; generate a directory of bank 1 and search for flagged files 
77b0			 
77b0					if DEBUG_FORTH_WORDS_KEY 
77b0						DMARK "DIR" 
77b0 f5				push af  
77b1 3a c5 77			ld a, (.dmark)  
77b4 32 99 fd			ld (debug_mark),a  
77b7 3a c6 77			ld a, (.dmark+1)  
77ba 32 9a fd			ld (debug_mark+1),a  
77bd 3a c7 77			ld a, (.dmark+2)  
77c0 32 9b fd			ld (debug_mark+2),a  
77c3 18 03			jr .pastdmark  
77c5 ..			.dmark: db "DIR"  
77c8 f1			.pastdmark: pop af  
77c9			endm  
# End of macro DMARK
77c9						CALLMONITOR 
77c9 cd a6 fd			call debug_vector  
77cc				endm  
# End of macro CALLMONITOR
77cc					endif 
77cc			 
77cc cd 05 05			call storage_get_block_0 
77cf			 
77cf 21 a8 f9			ld hl, store_page     ; get current id count 
77d2 46				ld b, (hl) 
77d3 0e 00			ld c, 0    ; count of files   
77d5					if DEBUG_FORTH_WORDS 
77d5						DMARK "DI1" 
77d5 f5				push af  
77d6 3a ea 77			ld a, (.dmark)  
77d9 32 99 fd			ld (debug_mark),a  
77dc 3a eb 77			ld a, (.dmark+1)  
77df 32 9a fd			ld (debug_mark+1),a  
77e2 3a ec 77			ld a, (.dmark+2)  
77e5 32 9b fd			ld (debug_mark+2),a  
77e8 18 03			jr .pastdmark  
77ea ..			.dmark: db "DI1"  
77ed f1			.pastdmark: pop af  
77ee			endm  
# End of macro DMARK
77ee						CALLMONITOR 
77ee cd a6 fd			call debug_vector  
77f1				endm  
# End of macro CALLMONITOR
77f1					endif 
77f1			 
77f1				; check for empty drive 
77f1			 
77f1 3e 00			ld a, 0 
77f3 b8				cp b 
77f4 ca 41 78			jp z, .dirdone 
77f7			 
77f7				; for each of the current ids do a search for them and if found push to stack 
77f7			 
77f7 c5			.diritem:	push bc 
77f8 21 40 00				ld hl, STORE_BLOCK_PHY 
77fb 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
77fd 58					ld e,b 
77fe			 
77fe d5					push de 
77ff e5					push hl 
7800 cd 81 0d			call clear_display 
7803 3e 32			ld a, display_row_2 + 10 
7805 11 85 77			ld de, sprompt3 
7808 cd 93 0d			call str_at_display 
780b cd d9 0c			call active 
780e eb				ex de, hl 
780f 3e 2f			ld a, display_row_2 + 7 
7811 cd 93 0d			call str_at_display 
7814 cd a3 0d			call update_display 
7817 e1				pop hl 
7818 d1				pop de 
7819			 
7819			;		if DEBUG_FORTH_WORDS 
7819			;			DMARK "DI2" 
7819			;			CALLMONITOR 
7819			;		endif 
7819			 
7819 cd 83 07				call storage_findnextid 
781c			 
781c			;		if DEBUG_FORTH_WORDS 
781c			;			DMARK "DI3" 
781c			;			CALLMONITOR 
781c			;		endif 
781c			 
781c					; if found hl will be non zero 
781c			 
781c cd da 0f				call ishlzero 
781f			;		ld a, l 
781f			;		add h 
781f			; 
781f			;		cp 0 
781f 28 1d				jr z, .dirnotfound 
7821			 
7821					; increase count 
7821			 
7821 c1					pop bc	 
7822 0c					inc c 
7823 c5					push bc 
7824					 
7824			 
7824					; get file header and push the file name 
7824			 
7824 11 a8 f9				ld de, store_page 
7827 cd 57 04				call storage_read_block 
782a			 
782a					; push file id to stack 
782a				 
782a			 
782a					; is this a file we want to run? 
782a			 
782a 21 ab f9				ld hl, store_page+3 
782d 7e					ld a,(hl) 
782e fe 2a				cp '*' 
7830 20 0c				jr nz,  .dirnotfound 
7832					 
7832			 
7832			 
7832 3a a8 f9				ld a, (store_page) 
7835 d5					push de 
7836 e5					push hl 
7837 c5					push bc 
7838 cd 64 78				call .autorunf 
783b c1					pop bc 
783c e1					pop hl 
783d d1					pop de 
783e			 
783e			 
783e			 
783e				; save this extent 
783e			 
783e					; push file name 
783e			;display file name to run 
783e			 
783e			;		ld hl, store_page+3 
783e			;		if DEBUG_FORTH_WORDS 
783e			;			DMARK "DI5" 
783e			;			CALLMONITOR 
783e			;		endif 
783e			; 
783e			;		 
783e			; 
783e			;		call forth_push_str 
783e			;		if DEBUG_FORTH_WORDS 
783e			;			DMARK "DI6" 
783e			;			CALLMONITOR 
783e			;		endif 
783e			.dirnotfound: 
783e c1					pop bc     
783f 10 b6				djnz .diritem 
7841				 
7841			.dirdone:	 
7841					if DEBUG_FORTH_WORDS 
7841						DMARK "DI7" 
7841 f5				push af  
7842 3a 56 78			ld a, (.dmark)  
7845 32 99 fd			ld (debug_mark),a  
7848 3a 57 78			ld a, (.dmark+1)  
784b 32 9a fd			ld (debug_mark+1),a  
784e 3a 58 78			ld a, (.dmark+2)  
7851 32 9b fd			ld (debug_mark+2),a  
7854 18 03			jr .pastdmark  
7856 ..			.dmark: db "DI7"  
7859 f1			.pastdmark: pop af  
785a			endm  
# End of macro DMARK
785a						CALLMONITOR 
785a cd a6 fd			call debug_vector  
785d				endm  
# End of macro CALLMONITOR
785d					endif 
785d			 
785d cd 81 0d				call clear_display 
7860 cd a3 0d				call update_display 
7863			 
7863 c9					ret 
7864			 
7864			 
7864			 
7864			 
7864			 
7864			.autorunf: 
7864			 
7864			 
7864				; get file id to load from and get the file name to display 
7864			 
7864			;		ld a, (store_page+STORE_0_FILERUN) 
7864			 
7864 2e 00				ld l, 0 
7866 67					ld h, a 
7867 11 a8 f9				ld de, store_page 
786a			 
786a					if DEBUG_FORTH_WORDS 
786a						DMARK "ASp" 
786a f5				push af  
786b 3a 7f 78			ld a, (.dmark)  
786e 32 99 fd			ld (debug_mark),a  
7871 3a 80 78			ld a, (.dmark+1)  
7874 32 9a fd			ld (debug_mark+1),a  
7877 3a 81 78			ld a, (.dmark+2)  
787a 32 9b fd			ld (debug_mark+2),a  
787d 18 03			jr .pastdmark  
787f ..			.dmark: db "ASp"  
7882 f1			.pastdmark: pop af  
7883			endm  
# End of macro DMARK
7883						CALLMONITOR 
7883 cd a6 fd			call debug_vector  
7886				endm  
# End of macro CALLMONITOR
7886					endif 
7886 cd a7 09				call storage_read 
7889			 
7889					if DEBUG_FORTH_WORDS 
7889						DMARK "ASr" 
7889 f5				push af  
788a 3a 9e 78			ld a, (.dmark)  
788d 32 99 fd			ld (debug_mark),a  
7890 3a 9f 78			ld a, (.dmark+1)  
7893 32 9a fd			ld (debug_mark+1),a  
7896 3a a0 78			ld a, (.dmark+2)  
7899 32 9b fd			ld (debug_mark+2),a  
789c 18 03			jr .pastdmark  
789e ..			.dmark: db "ASr"  
78a1 f1			.pastdmark: pop af  
78a2			endm  
# End of macro DMARK
78a2						CALLMONITOR 
78a2 cd a6 fd			call debug_vector  
78a5				endm  
# End of macro CALLMONITOR
78a5					endif 
78a5			 
78a5 cd da 0f				call ishlzero 
78a8 c8					ret z             ; file not found 
78a9			 
78a9					; display file name we are loading 
78a9			 
78a9 cd 81 0d				call clear_display 
78ac			 
78ac 3e 32				ld a, display_row_2 + 10 
78ae 11 ab f9				ld de, store_page+3 
78b1 cd 93 0d				call str_at_display 
78b4				 
78b4			; 
78b4			 
78b4			;	ld a, display_row_1+5 
78b4			;	ld de, sprompt3 
78b4			;	call str_at_display 
78b4			;	ld a, display_row_2+7 
78b4			;	call active 
78b4			;	ex de, hl 
78b4			;;	ld de, sprompt4 
78b4			;	call str_at_display 
78b4			; 
78b4 cd a3 0d			call update_display 
78b7			 
78b7			;	call cin_wait 
78b7			;	cp 'n' 
78b7			;	ret z 
78b7			;	cp 'N' 
78b7			;	ret z 
78b7			 
78b7			;	call delay1s 
78b7			 
78b7 3a aa f9			ld a, (store_page+2) 
78ba 32 97 f9			ld (store_openmaxext), a    ; save count of ext 
78bd 3e 01			ld a, 1  
78bf 32 98 f9			ld (store_openext), a    ; save count of ext 
78c2			 
78c2			.autof: 
78c2				; begin to read a line from file 
78c2			 
78c2 21 16 f4			ld hl, os_cli_cmd 
78c5 22 14 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
78c8			  
78c8			.readext: 
78c8 3a 98 f9			ld a, (store_openext) 
78cb 6f				ld l , a 
78cc				 
78cc 3a a8 f9			ld a, (store_page) 
78cf 67				ld h, a	 
78d0 11 a8 f9			ld de, store_page 
78d3					if DEBUG_FORTH_WORDS 
78d3						DMARK "ASl" 
78d3 f5				push af  
78d4 3a e8 78			ld a, (.dmark)  
78d7 32 99 fd			ld (debug_mark),a  
78da 3a e9 78			ld a, (.dmark+1)  
78dd 32 9a fd			ld (debug_mark+1),a  
78e0 3a ea 78			ld a, (.dmark+2)  
78e3 32 9b fd			ld (debug_mark+2),a  
78e6 18 03			jr .pastdmark  
78e8 ..			.dmark: db "ASl"  
78eb f1			.pastdmark: pop af  
78ec			endm  
# End of macro DMARK
78ec						CALLMONITOR 
78ec cd a6 fd			call debug_vector  
78ef				endm  
# End of macro CALLMONITOR
78ef					endif 
78ef cd a7 09				call storage_read 
78f2 cd da 0f			call ishlzero 
78f5 c8				ret z 
78f6			 
78f6			; TODO copy to exec buffer 
78f6			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
78f6			 
78f6				; copy the record buffer to the cli buffer 
78f6			 
78f6 ed 5b 14 f6		ld de, (os_var_array) 
78fa 21 aa f9			ld hl, store_page+2 
78fd			;	ex de, hl 
78fd 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
7900 ed b0			ldir 
7902 ed 53 14 f6		ld (os_var_array), de 
7906				 
7906 3a 98 f9			ld a, (store_openext) 
7909 3c				inc a 
790a 32 98 f9			ld (store_openext), a    ; save count of ext 
790d			 
790d			 
790d			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
790d				 
790d 3a 9b f9			ld a, (store_readcont) 
7910			;	cp 0 
7910 b7				or a 
7911 20 b5			jr nz, .readext 
7913			 
7913			;	jr z, .autoend 
7913			 
7913					if DEBUG_FORTH_WORDS 
7913						DMARK "ASc" 
7913 f5				push af  
7914 3a 28 79			ld a, (.dmark)  
7917 32 99 fd			ld (debug_mark),a  
791a 3a 29 79			ld a, (.dmark+1)  
791d 32 9a fd			ld (debug_mark+1),a  
7920 3a 2a 79			ld a, (.dmark+2)  
7923 32 9b fd			ld (debug_mark+2),a  
7926 18 03			jr .pastdmark  
7928 ..			.dmark: db "ASc"  
792b f1			.pastdmark: pop af  
792c			endm  
# End of macro DMARK
792c						CALLMONITOR 
792c cd a6 fd			call debug_vector  
792f				endm  
# End of macro CALLMONITOR
792f					endif 
792f e5				push hl	 
7930 d5				push de 
7931 cd d9 0c			call active 
7934 eb				ex de, hl 
7935 3e 2f			ld a, display_row_2 + 7 
7937 cd 93 0d			call str_at_display 
793a			 
793a cd a3 0d			call update_display 
793d d1				pop de  
793e e1				pop hl 
793f			;	call delay250ms 
793f			 
793f			 
793f			 
793f			 
793f			.autoexec: 
793f			 
793f			 
793f 21 16 f4			ld hl, os_cli_cmd 
7942					if DEBUG_FORTH_WORDS 
7942						DMARK "ASx" 
7942 f5				push af  
7943 3a 57 79			ld a, (.dmark)  
7946 32 99 fd			ld (debug_mark),a  
7949 3a 58 79			ld a, (.dmark+1)  
794c 32 9a fd			ld (debug_mark+1),a  
794f 3a 59 79			ld a, (.dmark+2)  
7952 32 9b fd			ld (debug_mark+2),a  
7955 18 03			jr .pastdmark  
7957 ..			.dmark: db "ASx"  
795a f1			.pastdmark: pop af  
795b			endm  
# End of macro DMARK
795b						CALLMONITOR 
795b cd a6 fd			call debug_vector  
795e				endm  
# End of macro CALLMONITOR
795e					endif 
795e cd 3b 24			call forthparse 
7961 cd 73 24			call forthexec 
7964 cd 95 23			call forthexec_cleanup 
7967			 
7967			 
7967			 
7967 c3 c2 78			jp .autof 
796a			;.autofdone: 
796a			; 
796a			;		if DEBUG_FORTH_WORDS 
796a			;			DMARK "ASx" 
796a			;			CALLMONITOR 
796a			;		endif 
796a			;;	call clear_display 
796a			;	ret 
796a			 
796a			 
796a			 
796a			endif 
# End of file forth_startupv2.asm
796a			endif 
796a			 
# End of file forth_startup.asm
796a			 
796a			; eof 
# End of file forth_kernel.asm
796a			;include "nascombasic.asm" 
796a			;include "basicZ80.asm" 
796a			 
796a			 
796a			 
796a			; find out where the code ends if loaded into RAM (for SC114) 
796a			;endofcode:  
796a			;	nop 
796a			 
796a			 
796a			; jump to nmi vector 
796a			 
796a			init_nmi: 
796a 3e c9			ld a, $c9   ; RET 
796c 32 a9 fd			ld (nmi_vector), a 
796f c9				ret 
7970			nmi: 
7970 e5				push hl 
7971 d5				push de 
7972 c5				push bc 
7973 f5				push af 
7974 cd a9 fd			call nmi_vector 
7977 f5				push af 
7978 c5				push bc 
7979 d5				push de 
797a e5				push hl 
797b ed 4d			reti 
797d			 
797d			 
797d			; eof 
797d			 
# End of file main.asm
797d			include "firmware_lcd_4x40.asm" 
797d			; **********************************************************************  
797d			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
797d			; **********************************************************************  
797d			;  
797d			; **  Written as a Small Computer Monitor App  
797d			; **  www.scc.me.uk  
797d			;  
797d			; History  
797d			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
797d			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
797d			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
797d			;  
797d			; **********************************************************************  
797d			;  
797d			; This program is an example of one of the methods of interfacing an   
797d			; alphanumeric LCD module.   
797d			;  
797d			; In this example the display is connected to either a Z80 PIO or a   
797d			; simple 8-bit output port.   
797d			;  
797d			; This interfacing method uses 4-bit data mode and uses time delays  
797d			; rather than polling the display's ready status. As a result the   
797d			; interface only requires 6 simple output lines:  
797d			;   Output bit 0 = not used  
797d			;   Output bit 1 = not used  
797d			;   Output bit 2 = RS         High = data, Low = instruction  
797d			;   Output bit 3 = E          Active high  
797d			;   Output bit 4 = DB4  
797d			;   Output bit 5 = DB5  
797d			;   Output bit 6 = DB6  
797d			;   Output bit 7 = DB7  
797d			; Display's R/W is connected to 0v so it is always in write mode  
797d			;  
797d			; This set up should work with any system supporting the RC2014 bus  
797d			  
797d			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
797d			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
797d			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
797d			;  
797d			; **********************************************************************  
797d			  
797d			; Additonal for 4x40. E1 and E2 instead of just E   
797d			; TODO swipe vidout signal on port a to activate E2  
797d			  
797d			; **********************************************************************  
797d			; **  Constants  
797d			; **********************************************************************  
797d			; LCD constants required by LCD support module  
797d			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
797d			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
797d			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
797d			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
797d			; TODO Decide which E is being set  
797d			kLCDWidth:  EQU display_cols             ;Width in characters  
797d			  
797d			; **********************************************************************  
797d			; **  Code library usage  
797d			; **********************************************************************  
797d			  
797d			; send character to current cursor position  
797d			; wraps and/or scrolls screen automatically  
797d			  
797d			  
797d			  
797d			lcd_init:  
797d			  
797d			; SCMonAPI functions used  
797d			  
797d			; Alphanumeric LCD functions used  
797d			; no need to specify specific functions for this module  
797d			  
797d 3e cf		            LD   A, 11001111b  
797f d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7981 3e 00		            LD   A, 00000000b  
7983 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
7985			  
7985			; Initialise alphanumeric LCD module  
7985 3e 00				ld a, 0  
7987 32 f9 fa				ld (display_lcde1e2), a  
798a cd 0b 7a		            CALL fLCD_Init      ;Initialise LCD module  
798d 3e 01				ld a, 1  
798f 32 f9 fa				ld (display_lcde1e2), a  
7992 cd 0b 7a		            CALL fLCD_Init      ;Initialise LCD module  
7995			  
7995 c9				ret  
7996			  
7996			;  
7996			;;  
7996			; lcd functions  
7996			;  
7996			;  
7996			  
7996			; what is at cursor position   
7996			  
7996			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7996			;		call curptr  
7996			;		ret  
7996			  
7996			  
7996			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7996			  
7996			curptr:  
7996 c5				push bc  
7997 21 df fc			ld hl, display_fb0  
799a			cpr:	  
799a				; loop for cursor whole row  
799a 0e 28			ld c, display_cols  
799c 23			cpr1:	inc hl  
799d 0d				dec c  
799e 20 fc			jr nz, cpr1  
79a0 05				dec b  
79a1 20 f7			jr nz, cpr  
79a3			  
79a3				; add col	  
79a3			  
79a3 23			cpr2:	inc hl  
79a4 1d				dec e  
79a5 20 fc			jr nz, cpr2  
79a7			  
79a7 c1				pop bc  
79a8 c9				ret  
79a9				  
79a9			  
79a9			  
79a9			  
79a9			  
79a9			; write the frame buffer given in hl to hardware   
79a9 22 f7 fa		write_display: ld (display_write_tmp), hl 	   
79ac 3e 00			ld a, kLCD_Line1  
79ae cd b8 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
79b1 06 28			ld b, display_cols  
79b3 ed 5b f7 fa		ld de, (display_write_tmp)  
79b7 cd 03 7a			call write_len_string  
79ba				  
79ba				  
79ba 2a f7 fa			ld hl, (display_write_tmp)  
79bd 11 28 00			ld de, display_cols  
79c0 19				add hl,de  
79c1 22 f7 fa			ld (display_write_tmp),hl  
79c4			  
79c4				  
79c4 3e 28			ld a, kLCD_Line2  
79c6 cd b8 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
79c9 06 28			ld b, display_cols  
79cb ed 5b f7 fa		ld de, (display_write_tmp)  
79cf cd 03 7a			call write_len_string  
79d2				  
79d2 2a f7 fa			ld hl, (display_write_tmp)  
79d5 11 28 00			ld de, display_cols  
79d8 19				add hl,de  
79d9 22 f7 fa			ld (display_write_tmp),hl  
79dc			  
79dc				  
79dc 3e 50			ld a, kLCD_Line3  
79de cd b8 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
79e1 06 28			ld b, display_cols  
79e3 ed 5b f7 fa		ld de, (display_write_tmp)  
79e7 cd 03 7a			call write_len_string  
79ea				  
79ea 2a f7 fa			ld hl, (display_write_tmp)  
79ed 11 28 00			ld de, display_cols  
79f0 19				add hl,de  
79f1 22 f7 fa			ld (display_write_tmp),hl  
79f4			  
79f4				  
79f4 3e 78			ld a, kLCD_Line4  
79f6 cd b8 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
79f9 06 28			ld b, display_cols  
79fb ed 5b f7 fa		ld de, (display_write_tmp)  
79ff cd 03 7a			call write_len_string  
7a02 c9					ret  
7a03				  
7a03				; write out a fixed length string given in b from de  
7a03			  
7a03 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
7a04 cd 70 7a		            CALL fLCD_Data      ;Write character to display  
7a07 13				inc de  
7a08 10 f9			djnz write_len_string  
7a0a c9				ret  
7a0b			  
7a0b			; Some other things to do  
7a0b			;            LD   A, kLCD_Clear ;Display clear  
7a0b			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
7a0b			;            LD   A, kLCD_Under ;Display on with underscore cursor  
7a0b			;            LD   A, kLCD_On     ;Display on with no cursor  
7a0b			;            ;LD   A, kLCD_Off   ;Display off  
7a0b			;            CALL fLCD_Inst      ;Send instruction to display  
7a0b			;  
7a0b			;  
7a0b			;            halt  
7a0b			;  
7a0b			;  
7a0b			;MsgHello:   DB  "Hello World!",0  
7a0b			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
7a0b			  
7a0b			; Custom characters 5 pixels wide by 8 pixels high  
7a0b			; Up to 8 custom characters can be defined  
7a0b			;BitMaps:      
7a0b			;; Character 0x00 = Battery icon  
7a0b			;            DB  01110b  
7a0b			;            DB  11011b  
7a0b			;            DB  10001b  
7a0b			;            DB  10001b  
7a0b			;            DB  11111b  
7a0b			;            DB  11111b  
7a0b			;            DB  11111b  
7a0b			;            DB  11111b  
7a0b			;; Character 0x01 = Bluetooth icon  
7a0b			;            DB  01100b  
7a0b			;            DB  01010b  
7a0b			;            DB  11100b  
7a0b			;            DB  01000b  
7a0b			;            DB  11100b  
7a0b			;            DB  01010b  
7a0b			;            DB  01100b  
7a0b			;            DB  00000b  
7a0b			;  
7a0b			  
7a0b			  
7a0b			; **********************************************************************  
7a0b			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
7a0b			; **********************************************************************  
7a0b			;  
7a0b			; **  Written as a Small Computer Monitor App   
7a0b			; **  Version 0.1 SCC 2018-05-16  
7a0b			; **  www.scc.me.uk  
7a0b			;  
7a0b			; **********************************************************************  
7a0b			;  
7a0b			; This module provides support for alphanumeric LCD modules using with  
7a0b			; *  HD44780 (or compatible) controller  
7a0b			; *  5 x 7 pixel fonts  
7a0b			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
7a0b			; *  Interface via six digital outputs to the display (see below)  
7a0b			;  
7a0b			; LCD module pinout:  
7a0b			;   1  Vss   0v supply  
7a0b			;   2  Vdd   5v supply  
7a0b			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
7a0b			;   4  RS    High = data, Low = instruction  
7a0b			;   5  R/W   High = Read, Low = Write  
7a0b			;   6  E     Enable signal (active high)  
7a0b			;   7  DB0   Data bit 0  
7a0b			;   8  DB1   Data bit 1  
7a0b			;   9  DB2   Data bit 2  
7a0b			;  10  DB3   Data bit 3  
7a0b			;  11  DB4   Data bit 4  
7a0b			;  12  DB5   Data bit 5  
7a0b			;  13  DB6   Data bit 6  
7a0b			;  14  DB7   Data bit 7  
7a0b			;  15  A     Backlight anode (+)  
7a0b			;  16  K     Backlight cathode (-)  
7a0b			;  
7a0b			; This interfacing method uses 4-bit data mode and uses time delays  
7a0b			; rather than polling the display's ready status. As a result the   
7a0b			; interface only requires 6 simple output lines:  
7a0b			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
7a0b			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
7a0b			;   LCD DB4 = Microcomputer output port bit 4  
7a0b			;   LCD DB5 = Microcomputer output port bit 5  
7a0b			;   LCD DB6 = Microcomputer output port bit 6  
7a0b			;   LCD DB7 = Microcomputer output port bit 7  
7a0b			; Display's R/W is connected to 0v so it is always in write mode  
7a0b			; All 6 connections must be on the same port address <kLCDPrt>  
7a0b			; This method also allows a decent length of cable from micro to LCD  
7a0b			;  
7a0b			; **********************************************************************  
7a0b			;  
7a0b			; To include the code for any given function provided by this module,   
7a0b			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
7a0b			; the parent source file.  
7a0b			; For example:  #REQUIRES   uHexPrefix  
7a0b			;  
7a0b			; Also #INCLUDE this file at some point after the #REQUIRES statements  
7a0b			; in the parent source file.  
7a0b			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
7a0b			;  
7a0b			; These are the function names provided by this module:  
7a0b			; fLCD_Init                     ;Initialise LCD  
7a0b			; fLCD_Inst                     ;Send instruction to LCD  
7a0b			; fLCD_Data                     ;Send data byte to LCD  
7a0b			; fLCD_Pos                      ;Position cursor  
7a0b			; fLCD_Str                      ;Display string  
7a0b			; fLCD_Def                      ;Define custom character  
7a0b			;  
7a0b			; **********************************************************************  
7a0b			;  
7a0b			; Requires SCMonAPI.asm to also be included in the project  
7a0b			;  
7a0b			  
7a0b			  
7a0b			; **********************************************************************  
7a0b			; **  Constants  
7a0b			; **********************************************************************  
7a0b			  
7a0b			; Constants that must be defined externally  
7a0b			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
7a0b			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
7a0b			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
7a0b			;kLCDWidth: EQU 20             ;Width in characters  
7a0b			  
7a0b			; general line offsets in any frame buffer  
7a0b			  
7a0b			  
7a0b			display_row_1: equ 0  
7a0b			display_row_2: equ display_row_1+display_cols  
7a0b			display_row_3: equ display_row_2 + display_cols  
7a0b			display_row_4: equ display_row_3 + display_cols  
7a0b			;display_row_4_eol:   
7a0b			  
7a0b			  
7a0b			; Cursor position values for the start of each line  
7a0b			  
7a0b			; E  
7a0b			kLCD_Line1: EQU 0x00   
7a0b			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
7a0b			; E1  
7a0b			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
7a0b			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
7a0b			  
7a0b			; Instructions to send as A register to fLCD_Inst  
7a0b			kLCD_Clear: EQU 00000001b     ;LCD clear  
7a0b			kLCD_Off:   EQU 00001000b     ;LCD off  
7a0b			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
7a0b			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
7a0b			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
7a0b			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
7a0b			  
7a0b			; Constants used by this code module  
7a0b			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
7a0b			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
7a0b			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
7a0b			  
7a0b			  
7a0b			  
7a0b			; **********************************************************************  
7a0b			; **  LCD support functions  
7a0b			; **********************************************************************  
7a0b			  
7a0b			; Initialise alphanumeric LCD module  
7a0b			; LCD control register codes:  
7a0b			;   DL   0 = 4-bit mode        1 = 8-bit mode  
7a0b			;   N    0 = 1-line mode       1 = 2-line mode  
7a0b			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
7a0b			;   D    0 = Display off       1 = Display on  
7a0b			;   C    0 = Cursor off        1 = Cursor on  
7a0b			;   B    0 = Blinking off      1 = Blinking on  
7a0b			;   ID   0 = Decrement mode    1 = Increment mode  
7a0b			;   SH   0 = Entire shift off  1 = Entire shift on  
7a0b 3e 28		fLCD_Init:  LD   A, 40  
7a0d cd 32 7b		            CALL LCDDelay       ;Delay 40ms after power up  
7a10			; For reliable reset set 8-bit mode - 3 times  
7a10 cd 02 7b		            CALL WrFn8bit       ;Function = 8-bit mode  
7a13 cd 02 7b		            CALL WrFn8bit       ;Function = 8-bit mode  
7a16 cd 02 7b		            CALL WrFn8bit       ;Function = 8-bit mode  
7a19			; Set 4-bit mode  
7a19 cd fe 7a		            CALL WrFn4bit       ;Function = 4-bit mode  
7a1c cd 30 7b		            CALL LCDDelay1      ;Delay 37 us or more  
7a1f			; Function set  
7a1f 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7a21 cd 34 7a		            CALL fLCD_Inst      ;2 line, display on  
7a24			; Display On/Off control  
7a24 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
7a26 cd 34 7a		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7a29			; Display Clear  
7a29 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7a2b cd 34 7a		            CALL fLCD_Inst      ;Clear display  
7a2e			; Entry mode  
7a2e 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7a30 cd 34 7a		            CALL fLCD_Inst      ;Increment mode, shift off  
7a33			; Display module now initialised  
7a33 c9			            RET  
7a34			; ok to here  
7a34			  
7a34			; Write instruction to LCD  
7a34			;   On entry: A = Instruction byte to be written  
7a34			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7a34 f5			fLCD_Inst:  PUSH AF  
7a35 f5			            PUSH AF  
7a36 cd 48 7a		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
7a39 f1			            POP  AF  
7a3a 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7a3b 17			            RLA  
7a3c 17			            RLA  
7a3d 17			            RLA  
7a3e cd 48 7a		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7a41 3e 02		            LD   A, 2  
7a43 cd 32 7b		            CALL LCDDelay       ;Delay 2 ms to complete   
7a46 f1			            POP  AF  
7a47 c9			            RET  
7a48			Wr4bits:   
7a48 f5					push af  
7a49 3a f9 fa				ld a, (display_lcde1e2)  
7a4c fe 00				cp 0     ; e  
7a4e 20 10				jr nz, .wea2	  
7a50 f1					pop af  
7a51 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7a53 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7a55 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7a57 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7a59 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7a5b cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
7a5d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7a5f c9			            RET  
7a60 f1			.wea2:		pop af  
7a61 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7a63 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7a65 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7a67 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7a69 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7a6b cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7a6d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7a6f c9			            RET  
7a70			  
7a70			  
7a70			; Write data to LCD  
7a70			;   On entry: A = Data byte to be written  
7a70			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7a70 f5			fLCD_Data:  PUSH AF  
7a71 f5			            PUSH AF  
7a72 cd 84 7a		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7a75 f1			            POP  AF  
7a76 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7a77 17			            RLA  
7a78 17			            RLA  
7a79 17			            RLA  
7a7a cd 84 7a		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7a7d 3e 96		            LD   A, 150  
7a7f 3d			Wait:      DEC  A              ;Wait a while to allow data   
7a80 20 fd		            JR   NZ, Wait      ;  write to complete  
7a82 f1			            POP  AF  
7a83 c9			            RET  
7a84			Wr4bitsa:     
7a84 f5					push af  
7a85 3a f9 fa				ld a, (display_lcde1e2)  
7a88 fe 00				cp 0     ; e1  
7a8a 20 16				jr nz, .we2	  
7a8c f1					pop af  
7a8d e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7a8f cb d7		            SET  kLCDBitRS, A  
7a91 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7a93 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7a95 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7a97 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7a99 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7a9b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7a9d cb 97		            RES  kLCDBitRS, A  
7a9f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7aa1 c9			            RET  
7aa2 f1			.we2:		pop af  
7aa3 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7aa5 cb d7		            SET  kLCDBitRS, A  
7aa7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7aa9 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7aab cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
7aad d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7aaf cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
7ab1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7ab3 cb 97		            RES  kLCDBitRS, A  
7ab5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7ab7 c9			            RET  
7ab8			  
7ab8			  
7ab8			; Position cursor to specified location  
7ab8			;   On entry: A = Cursor position  
7ab8			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7ab8 f5			fLCD_Pos:   PUSH AF  
7ab9					; at this point set the E1 or E2 flag depending on position  
7ab9			  
7ab9 c5					push bc  
7aba			;		push af  
7aba 06 00				ld b, 0  
7abc 4f					ld c, a  
7abd 3e 4f				ld a, kLCD_Line3-1  
7abf b7			 		or a      ;clear carry flag  
7ac0 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
7ac1 38 04				jr c, .pe1  
7ac3			  
7ac3					; E selection  
7ac3 cb 80				res 0, b         ; bit 0 unset e  
7ac5			;		pop af    ; before line 3 so recover orig pos  
7ac5			;		ld c, a    ; save for poking back  
7ac5 18 06				jr .peset	          
7ac7			.pe1:          	; E2 selection  
7ac7 cb c0				set 0, b         ; bit 0 set e1  
7ac9 79					ld a, c  
7aca de 4f				sbc a, kLCD_Line3-1  
7acc 4f					ld c, a	         ; save caculated offset  
7acd			;		pop af     ; bin this original value now we have calculated form  
7acd			  
7acd			.peset:		; set bit  
7acd 78					ld a, b  
7ace 32 f9 fa				ld (display_lcde1e2), a 	  
7ad1 79					ld a, c  
7ad2 c1					pop bc  
7ad3			  
7ad3 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
7ad5 cd 34 7a		            CALL fLCD_Inst      ;Write instruction to LCD  
7ad8 f1			            POP  AF  
7ad9 c9			            RET  
7ada			  
7ada			  
7ada			; Output text string to LCD  
7ada			;   On entry: DE = Pointer to null terminated text string  
7ada			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7ada 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7adb b7			            OR   A              ;Null terminator?  
7adc c8			            RET  Z              ;Yes, so finished  
7add cd 70 7a		            CALL fLCD_Data      ;Write character to display  
7ae0 13			            INC  DE             ;Point to next character  
7ae1 18 f7		            JR   fLCD_Str       ;Repeat  
7ae3 c9					ret  
7ae4			  
7ae4			; Define custom character  
7ae4			;   On entry: A = Character number (0 to 7)  
7ae4			;             DE = Pointer to character bitmap data  
7ae4			;   On exit:  A = Next character number  
7ae4			;             DE = Next location following bitmap  
7ae4			;             BC HL IX IY I AF' BC' DE' HL' preserved  
7ae4			; Character is   
7ae4 c5			fLCD_Def:   PUSH BC  
7ae5 f5			            PUSH AF  
7ae6 07			            RLCA                ;Calculate location  
7ae7 07			            RLCA                ;  for bitmap data  
7ae8 07			            RLCA                ;  = 8 x CharacterNumber  
7ae9 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7aeb cd 34 7a		            CALL fLCD_Inst      ;Write instruction to LCD  
7aee 06 00		            LD   B, 0  
7af0 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
7af1 cd 70 7a		            CALL fLCD_Data      ;Write byte to display  
7af4 13			            INC  DE             ;Point to next byte  
7af5 04			            INC  B              ;Count bytes  
7af6 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
7af8 28 f6		            JR   Z, Loop       ;No, so repeat  
7afa f1			            POP  AF  
7afb 3c			            INC  A              ;Increment character number  
7afc c1			            POP  BC  
7afd c9			            RET  
7afe			  
7afe			  
7afe			; **********************************************************************  
7afe			; **  Private functions  
7afe			; **********************************************************************  
7afe			  
7afe			; Write function to LCD  
7afe			;   On entry: A = Function byte to be written  
7afe			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7afe 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7b00 18 02		            JR   WrFunc  
7b02 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
7b04 f5			WrFunc:     PUSH AF  
7b05 f5					push af  
7b06 3a f9 fa				ld a, (display_lcde1e2)  
7b09 fe 00				cp 0     ; e1  
7b0b 20 0f				jr nz, .wfea2	  
7b0d f1					pop af  
7b0e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7b10 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
7b12 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7b14 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7b16 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7b18 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7b1a 18 0d			jr .wfskip  
7b1c f1			.wfea2:		pop af  
7b1d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7b1f cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7b21 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7b23 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7b25 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7b27 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7b29 3e 05		.wfskip:            LD  A, 5  
7b2b cd 32 7b		            CALL LCDDelay       ;Delay 5 ms to complete  
7b2e f1			            POP  AF  
7b2f c9			            RET  
7b30			  
7b30			  
7b30			; Delay in milliseconds  
7b30			;   On entry: A = Number of milliseconds delay  
7b30			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7b30 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7b32 d5			LCDDelay:   PUSH DE  
7b33 5f			            LD   E, A           ;Delay by 'A' ms  
7b34 16 00		            LD   D, 0  
7b36 cd a5 0c		            CALL aDelayInMS  
7b39 d1			            POP  DE  
7b3a c9			            RET  
7b3b			  
7b3b			  
7b3b			testlcd:  
7b3b 3e 00			ld a, kLCD_Line1  
7b3d cd b8 7a			call fLCD_Pos  
7b40 06 28			ld b, 40  
7b42 11 70 7b			ld de, .ttext1  
7b45 cd 03 7a			call write_len_string  
7b48			  
7b48 3e 28			ld a, kLCD_Line2  
7b4a cd b8 7a			call fLCD_Pos  
7b4d 06 28			ld b, 40  
7b4f 11 99 7b			ld de, .ttext2  
7b52 cd 03 7a			call write_len_string  
7b55 3e 50			ld a, kLCD_Line3  
7b57 cd b8 7a			call fLCD_Pos  
7b5a 06 28			ld b, 40  
7b5c 11 c2 7b			ld de, .ttext3  
7b5f cd 03 7a			call write_len_string  
7b62 3e 78			ld a, kLCD_Line4  
7b64 cd b8 7a			call fLCD_Pos  
7b67 06 28			ld b, 40  
7b69 11 eb 7b			ld de, .ttext4  
7b6c cd 03 7a			call write_len_string  
7b6f			  
7b6f 76				halt  
7b70			  
7b70			  
7b70 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7b99 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
7bc2 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7beb .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
7c14			   
7c14			  
7c14			  
7c14			; eof  
7c14			  
# End of file firmware_lcd_4x40.asm
7c14			;include "firmware_lcd_4x20.asm" 
7c14			include "firmware_key_5x10.asm" 
7c14			; 5 x 10 decade counter scanner  
7c14			  
7c14			  
7c14			; TODO do cursor shape change for shift keys  
7c14			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
7c14			  
7c14			  
7c14			; bit mask for each scan column and row for teing the matrix  
7c14			  
7c14			  
7c14			key_init:  
7c14			  
7c14				; init keyboard macro pointers  
7c14 21 00 00			ld hl, 0  
7c17 22 39 fe			ld (key_macroroot), hl  
7c1a 22 37 fe			ld (key_macrolast), hl  
7c1d			; SCMonAPI functions used  
7c1d			  
7c1d			; Alphanumeric LCD functions used  
7c1d			; no need to specify specific functions for this module  
7c1d			  
7c1d			  
7c1d 3e cf		            LD   A, 11001111b  
7c1f d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
7c21			;            LD   A, 00000000b  
7c21 3e 1f		            LD   A, 00011111b  
7c23 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7c25			  
7c25			  
7c25				; TODO Configure cursor shapes  
7c25			  
7c25				; Load cursor shapes   
7c25 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7c27 11 37 7c		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7c2a 06 02		            LD   B, 2           ;Number of characters to define  
7c2c cd e4 7a		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7c2f 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7c31			  
7c31 3e 01				ld a, 1  
7c33 32 ef fa			ld (cursor_shape),a  
7c36 c9				ret  
7c37			  
7c37			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7c37			; Up to 8 custom characters can be defined  
7c37			.cursor_shapes:      
7c37			;; Character 0x00 = Normal  
7c37 1f			            DB  11111b  
7c38 1f			            DB  11111b  
7c39 1f			            DB  11111b  
7c3a 1f			            DB  11111b  
7c3b 1f			            DB  11111b  
7c3c 1f			            DB  11111b  
7c3d 1f			            DB  11111b  
7c3e 1f			            DB  11111b  
7c3f			;; Character 0x01 = Modifier  
7c3f 1f			            DB  11111b  
7c40 1b			            DB  11011b  
7c41 1b			            DB  11011b  
7c42 1b			            DB  11011b  
7c43 1b			            DB  11011b  
7c44 1f			            DB  11111b  
7c45 1b			            DB  11011b  
7c46 1f			            DB  11111b  
7c47			  
7c47			  
7c47			  
7c47			  
7c47			; Display custom character 0  
7c47			;            LD   A, kLCD_Line1+14  
7c47			;            CALL fLCD_Pos       ;Position cursor to location in A  
7c47			;            LD   A, 0  
7c47			;            CALL fLCD_Data      ;Write character in A at cursor  
7c47			  
7c47			; Display custom character 1  
7c47			;            LD   A, kLCD_Line2+14  
7c47			;            CALL fLCD_Pos      ;Position cursor to location in A  
7c47			;            LD   A, 1  
7c47			;            CALL fLCD_Data     ;Write character in A at cursor  
7c47			  
7c47			; keyboard scanning   
7c47			  
7c47			; character in from keyboard  
7c47			  
7c47			; mapping for the pcb layout  
7c47			  
7c47			.matrix_to_char:  
7c47 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7c52 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7c5d 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7c68 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7c73 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7c7e			.matrix_to_shift:  
7c7e			  
7c7e .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7c89 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7c94 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7c9f 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7caa .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7cb5			  
7cb5			.matrix_to_symbolshift:  
7cb5			  
7cb5 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7cc0 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7ccb 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
7cd6			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
7cd6 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7ce1 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7cec			  
7cec			  
7cec			  
7cec			; mapping for a simple straight through breadboard layout  
7cec			  
7cec			;.matrix_to_char:  
7cec			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7cec			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7cec			;		db "asdfghjkl",KEY_CR,0  
7cec			;		db "qwertyuiop",0  
7cec			;		 db "1234567890",0  
7cec			;.matrix_to_shift:  
7cec			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7cec			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7cec			;		db "ASDFGHJKL",KEY_CR,0  
7cec			;		db "QWERTYUIOP",0  
7cec			;		 db "!",'"',"#$%^&*()",0  
7cec			;.matrix_to_symbolshift:  
7cec			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7cec			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7cec			;		db "_?*fghjk=",KEY_CR,0  
7cec			;		db "-/+*[]{}@#",0  
7cec			;		 db "1234567890",0  
7cec			  
7cec			;.matrix_to_char: db "D#0*C987B654A321"  
7cec			  
7cec			  
7cec				  
7cec			  
7cec			; add cin and cin_wait  
7cec			  
7cec cd fb 7c		cin_wait: 	call cin  
7cef						if DEBUG_KEYCINWAIT  
7cef							push af  
7cef							  
7cef							ld hl,key_repeat_ct  
7cef							ld (hl),a  
7cef							inc hl  
7cef							call hexout  
7cef							ld hl,key_repeat_ct+3  
7cef			;				ld a,0  
7cef							ld (hl),0  
7cef			  
7cef							    LD   A, kLCD_Line1+11  
7cef							    CALL fLCD_Pos       ;Position cursor to location in A  
7cef							    LD   DE, key_repeat_ct  
7cef							    ;LD   DE, MsgHello  
7cef							    CALL fLCD_Str       ;Display string pointed to by DE  
7cef			  
7cef			  
7cef			  
7cef							pop af  
7cef						endif  
7cef			;	cp 0  
7cef b7				or a  
7cf0 28 fa			jr z, cin_wait   ; block until key press  
7cf2			  
7cf2							if DEBUG_KEYCINWAIT  
7cf2								push af  
7cf2			  
7cf2			;					ld a, 'A'	  
7cf2								ld hl,key_repeat_ct  
7cf2								ld (hl),'A'  
7cf2								inc hl  
7cf2			;					ld a,0  
7cf2								ld (hl),0  
7cf2			  
7cf2								    LD   A, kLCD_Line2+11  
7cf2								    CALL fLCD_Pos       ;Position cursor to location in A  
7cf2								    LD   DE, key_repeat_ct  
7cf2								    ;LD   DE, MsgHello  
7cf2								    CALL fLCD_Str       ;Display string pointed to by DE  
7cf2			  
7cf2							call delay500ms  
7cf2			  
7cf2								pop af  
7cf2							endif  
7cf2 f5				push af   ; save key pressed  
7cf3			  
7cf3			.cin_wait1:	  
7cf3							if DEBUG_KEYCINWAIT  
7cf3								push af  
7cf3			  
7cf3			;					ld a, 'b'	  
7cf3								ld hl,key_repeat_ct  
7cf3								ld (hl),'b'  
7cf3								inc hl  
7cf3			;					ld a,0  
7cf3								ld (hl),0  
7cf3			  
7cf3								    LD   A, kLCD_Line2+11  
7cf3								    CALL fLCD_Pos       ;Position cursor to location in A  
7cf3								    LD   DE, key_repeat_ct  
7cf3								    ;LD   DE, MsgHello  
7cf3								    CALL fLCD_Str       ;Display string pointed to by DE  
7cf3			  
7cf3			  
7cf3							call delay500ms  
7cf3			  
7cf3								pop af  
7cf3							endif  
7cf3			  
7cf3 cd fb 7c		call cin  
7cf6			;	cp 0  
7cf6 b7				or a  
7cf7 20 fa			jr nz, .cin_wait1  	; wait for key release  
7cf9			if DEBUG_KEYCINWAIT  
7cf9				push af  
7cf9			  
7cf9			;	ld a, '3'	  
7cf9				ld hl,key_repeat_ct  
7cf9				ld (hl),'3'  
7cf9				inc hl  
7cf9			;	ld a,0  
7cf9				ld (hl),0  
7cf9			  
7cf9			            LD   A, kLCD_Line2+11  
7cf9			            CALL fLCD_Pos       ;Position cursor to location in A  
7cf9			            LD   DE, key_repeat_ct  
7cf9			            ;LD   DE, MsgHello  
7cf9			            CALL fLCD_Str       ;Display string pointed to by DE  
7cf9			  
7cf9			  
7cf9			call delay500ms  
7cf9			  
7cf9				pop af  
7cf9			endif  
7cf9			  
7cf9 f1				pop af   ; get key  
7cfa c9				ret  
7cfb			  
7cfb			  
7cfb			; cin - key non-blocking except for keybounce release  
7cfb			  
7cfb cd 17 7d		cin: 	call .mtoc  
7cfe			  
7cfe			if DEBUG_KEYCIN  
7cfe				push af  
7cfe				  
7cfe				ld hl,key_repeat_ct  
7cfe				ld (hl),a  
7cfe				inc hl  
7cfe				call hexout  
7cfe				ld hl,key_repeat_ct+3  
7cfe			;	ld a,0  
7cfe				ld (hl),0  
7cfe			  
7cfe			            LD   A, kLCD_Line3+15  
7cfe			            CALL fLCD_Pos       ;Position cursor to location in A  
7cfe			            LD   DE, key_repeat_ct  
7cfe			            ;LD   DE, MsgHello  
7cfe			            CALL fLCD_Str       ;Display string pointed to by DE  
7cfe			  
7cfe			  
7cfe			call delay500ms  
7cfe			  
7cfe				pop af  
7cfe			endif  
7cfe			  
7cfe			  
7cfe				; no key held  
7cfe			;	cp 0  
7cfe b7				or a  
7cff c8				ret z  
7d00			  
7d00			if DEBUG_KEYCIN  
7d00				push af  
7d00			  
7d00			;	ld a, '1'	  
7d00				ld hl,key_repeat_ct  
7d00				ld (hl),'1'  
7d00				inc hl  
7d00			;	ld a,0  
7d00				ld (hl),0  
7d00			  
7d00			            LD   A, kLCD_Line4+15  
7d00			            CALL fLCD_Pos       ;Position cursor to location in A  
7d00			            LD   DE, key_repeat_ct  
7d00			            ;LD   DE, MsgHello  
7d00			            CALL fLCD_Str       ;Display string pointed to by DE  
7d00			  
7d00			  
7d00			call delay500ms  
7d00			  
7d00				pop af  
7d00			endif  
7d00			  
7d00				; stop key bounce  
7d00			  
7d00 32 c2 fd			ld (key_held),a		 ; save it  
7d03 47				ld b, a  
7d04			  
7d04 c5			.cina1:	push bc  
7d05			if DEBUG_KEYCIN  
7d05				push af  
7d05			  
7d05				ld hl,key_repeat_ct  
7d05				inc hl  
7d05				call hexout  
7d05				ld hl,key_repeat_ct+3  
7d05			;	ld a,0  
7d05				ld (hl),0  
7d05				ld hl,key_repeat_ct  
7d05			;	ld a, '2'	  
7d05				ld (hl),'2'  
7d05			  
7d05			            LD   A, kLCD_Line4+15  
7d05			            CALL fLCD_Pos       ;Position cursor to location in A  
7d05			            LD   DE, key_repeat_ct  
7d05			            ;LD   DE, MsgHello  
7d05			            CALL fLCD_Str       ;Display string pointed to by DE  
7d05			  
7d05				pop af  
7d05			endif  
7d05 cd 17 7d			call .mtoc  
7d08 c1				pop bc  
7d09 b8				cp b  
7d0a 28 f8			jr z, .cina1  
7d0c 78				ld a,b		  
7d0d			if DEBUG_KEYCIN  
7d0d				push af  
7d0d			  
7d0d				ld hl,key_repeat_ct  
7d0d				inc hl  
7d0d				call hexout  
7d0d				ld hl,key_repeat_ct+3  
7d0d			;	ld a,0  
7d0d				ld (hl),0  
7d0d				ld hl,key_repeat_ct  
7d0d			;	ld a, '3'	  
7d0d				ld (hl),'3'  
7d0d			  
7d0d			            LD   A, kLCD_Line4+15  
7d0d			            CALL fLCD_Pos       ;Position cursor to location in A  
7d0d			            LD   DE, key_repeat_ct  
7d0d			            ;LD   DE, MsgHello  
7d0d			            CALL fLCD_Str       ;Display string pointed to by DE  
7d0d			  
7d0d				pop af  
7d0d			endif  
7d0d c9				ret  
7d0e			  
7d0e			; cinndb - key non-blocking without keybounce release  
7d0e			  
7d0e cd 17 7d		cinndb: 	call .mtoc  
7d11			  
7d11			if DEBUG_KEYCIN  
7d11				push af  
7d11				  
7d11				ld hl,key_repeat_ct  
7d11				ld (hl),a  
7d11				inc hl  
7d11				call hexout  
7d11				ld hl,key_repeat_ct+3  
7d11			;	ld a,0  
7d11				ld (hl),0  
7d11			  
7d11			            LD   A, kLCD_Line3+15  
7d11			            CALL fLCD_Pos       ;Position cursor to location in A  
7d11			            LD   DE, key_repeat_ct  
7d11			            ;LD   DE, MsgHello  
7d11			            CALL fLCD_Str       ;Display string pointed to by DE  
7d11			  
7d11			  
7d11			call delay500ms  
7d11			  
7d11				pop af  
7d11			endif  
7d11			  
7d11			  
7d11				; no key held  
7d11			;	cp 0  
7d11 b7				or a  
7d12 c8				ret z  
7d13			  
7d13			if DEBUG_KEYCIN  
7d13				push af  
7d13			  
7d13			;	ld a, '1'	  
7d13				ld hl,key_repeat_ct  
7d13				ld (hl),'1'  
7d13				inc hl  
7d13			;	ld a,0  
7d13				ld (hl),0  
7d13			  
7d13			            LD   A, kLCD_Line4+15  
7d13			            CALL fLCD_Pos       ;Position cursor to location in A  
7d13			            LD   DE, key_repeat_ct  
7d13			            ;LD   DE, MsgHello  
7d13			            CALL fLCD_Str       ;Display string pointed to by DE  
7d13			  
7d13			  
7d13			call delay500ms  
7d13			  
7d13				pop af  
7d13			endif  
7d13			  
7d13 32 c2 fd			ld (key_held),a		 ; save it  
7d16			  
7d16			if DEBUG_KEYCIN  
7d16				push af  
7d16			  
7d16				ld hl,key_repeat_ct  
7d16				inc hl  
7d16				call hexout  
7d16				ld hl,key_repeat_ct+3  
7d16			;	ld a,0  
7d16				ld (hl),0  
7d16				ld hl,key_repeat_ct  
7d16			;	ld a, '3'	  
7d16				ld (hl),'3'  
7d16			  
7d16			            LD   A, kLCD_Line4+15  
7d16			            CALL fLCD_Pos       ;Position cursor to location in A  
7d16			            LD   DE, key_repeat_ct  
7d16			            ;LD   DE, MsgHello  
7d16			            CALL fLCD_Str       ;Display string pointed to by DE  
7d16			  
7d16				pop af  
7d16			endif  
7d16 c9				ret  
7d17			; detect keyboard modifier key press and apply new overlay to the face key held  
7d17			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
7d17			  
7d17			;.cin_map_modifier:   
7d17			;	ld a, (hl)  
7d17			;	and 255  
7d17			;	ret NZ		; modifier key not flagged  
7d17			;  
7d17			;	; get key face  
7d17			;  
7d17			;	ld b,(key_face_held)  
7d17			;  
7d17			;	ld b, key_cols * key_rows  
7d17			;  
7d17			;	push de  
7d17			;	pop hl  
7d17			;  
7d17			;.mmod1: ld a,(hl)   ; get map test  
7d17			;	cp b  
7d17			;	jr z, .mmod2  
7d17			;  
7d17			;  
7d17			;  
7d17			;.mmod2: inc hl    ;   
7d17			;  
7d17			;	  
7d17			;  
7d17			;	  
7d17			;  
7d17			;	ld hl,key_actual_pressed  
7d17			;	ld (hl),a,  
7d17			;	ret  
7d17			  
7d17			; map matrix key held to char on face of key  
7d17			  
7d17			.mtoc:  
7d17			  
7d17			; test decade counter strobes  
7d17			  
7d17			;.decadetest1:  
7d17			  
7d17			; reset counter  
7d17			;ld a, 128  
7d17			;out (portbdata),a  
7d17			  
7d17			  
7d17			;ld b, 5  
7d17			;.dec1:  
7d17			;ld a, 0  
7d17			;out (portbdata),a  
7d17			;call delay1s  
7d17			  
7d17			;ld a, 32  
7d17			;out (portbdata),a  
7d17			;call delay1s  
7d17			;call delay1s  
7d17			;call delay1s  
7d17			;  
7d17			;ld a, 64+32  
7d17			;out (portbdata),a  
7d17			;call delay1s  
7d17			;;djnz .dec1  
7d17			;  
7d17			;jp .decadetest1  
7d17			  
7d17			  
7d17			  
7d17			  
7d17			  
7d17			  
7d17			  
7d17			  
7d17			  
7d17			  
7d17				; scan keyboard matrix and generate raw scan map  
7d17 cd a8 7d			call matrix  
7d1a			  
7d1a				; reuse c bit 0 left modifer button - ie shift  
7d1a			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7d1a				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7d1a			  
7d1a 0e 00			ld c, 0  
7d1c			  
7d1c				; TODO set flags for modifer key presses   
7d1c				; TODO do a search for modifer key...  
7d1c			  
7d1c				;ld hl,keyscan_table_row4  
7d1c 21 21 fe			ld hl,keyscan_table_row2  
7d1f			  
7d1f 7e				ld a, (hl)  
7d20 fe 23			cp '#'  
7d22 20 07			jr nz, .nextmodcheck  
7d24 cb c1			set 0, c  
7d26 21 7e 7c			ld hl, .matrix_to_shift  
7d29 18 21			jr .dokeymap  
7d2b				; TODO for now igonre  
7d2b			.nextmodcheck:  
7d2b 21 16 fe			ld hl,keyscan_table_row3  
7d2e			  
7d2e 7e				ld a, (hl)  
7d2f fe 23			cp '#'  
7d31 20 07			jr nz, .nextmodcheck2  
7d33 cb c9			set 1, c   
7d35 21 b5 7c			ld hl, .matrix_to_symbolshift  
7d38 18 12			jr .dokeymap  
7d3a			.nextmodcheck2:  
7d3a 21 2a fe			ld hl,keyscan_table_row2+9    ; right shift  
7d3d			  
7d3d 7e				ld a, (hl)  
7d3e fe 23			cp '#'  
7d40 20 07			jr nz, .donemodcheck  
7d42 cb c9			set 1, c   
7d44 21 7e 7c			ld hl, .matrix_to_shift  
7d47 18 03			jr .dokeymap  
7d49			  
7d49				; no modifer found so just map to normal keys  
7d49				; get mtoc map matrix to respective keys  
7d49			;	ld hl, .matrix_to_char  
7d49			;	ld hl, .matrix_to_char  
7d49			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7d49			;	ld a, KEY_SHIFT  
7d49			;	call findchar  
7d49			;  
7d49			;	; got offset to key modifer in b  
7d49			;  
7d49			;	ld hl,keyscan_table_row5  
7d49			;  
7d49			;	ld a,b  
7d49			;	call addatohl  
7d49			;	ld a,(hl)  
7d49			;  
7d49			;	cp '#'  
7d49			;	jr nz, .nextmodcheck  
7d49			;	set 0, c  
7d49			;	ld hl, .matrix_to_char  
7d49			;	jr .dokeymap  
7d49			;	; TODO for now igonre  
7d49			;.nextmodcheck:  
7d49			;	ld hl, .matrix_to_symbolshift  
7d49			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7d49			;	ld a, KEY_SYMBOLSHIFT  
7d49			;	call findchar  
7d49			;  
7d49			;  
7d49			;	; got offset to key modifer in b  
7d49			;  
7d49			;	ld hl,keyscan_table_row5  
7d49			;  
7d49			;	ld a,b  
7d49			;	call addatohl  
7d49			;	ld a,(hl)  
7d49			;  
7d49			;	cp '#'  
7d49			;	jr nz, .donemodcheck  
7d49			;	set 1, c   
7d49			;	ld hl, .matrix_to_symbolshift  
7d49			;	jr .dokeymap  
7d49			  
7d49			  
7d49			  
7d49			.donemodcheck:  
7d49				; no modifer found so just map to normal keys  
7d49				; get mtoc map matrix to respective keys  
7d49 21 47 7c			ld hl, .matrix_to_char  
7d4c			  
7d4c			.dokeymap:  
7d4c				;ld (key_fa), c   
7d4c cd 64 7d			call .mapkeys  
7d4f			  
7d4f			  
7d4f			if DEBUG_KEY  
7d4f			  
7d4f			; Display text on first line  
7d4f			            LD   A, kLCD_Line1  
7d4f			            CALL fLCD_Pos       ;Position cursor to location in A  
7d4f			            LD   DE, keyscan_table_row1  
7d4f			            ;LD   DE, MsgHello  
7d4f			            CALL fLCD_Str       ;Display string pointed to by DE  
7d4f			  
7d4f			; Display text on second line  
7d4f			            LD   A, kLCD_Line2  
7d4f			            CALL fLCD_Pos       ;Position cursor to location in A  
7d4f			            LD   DE, keyscan_table_row2  
7d4f			            CALL fLCD_Str       ;Display string pointed to by DE  
7d4f			            LD   A, kLCD_Line3  
7d4f			            CALL fLCD_Pos       ;Position cursor to location in A  
7d4f			            LD   DE, keyscan_table_row3  
7d4f			            CALL fLCD_Str       ;Display string pointed to by DE  
7d4f			            LD   A, kLCD_Line4  
7d4f			            CALL fLCD_Pos       ;Position cursor to location in A  
7d4f			            LD   DE, keyscan_table_row4  
7d4f			            CALL fLCD_Str       ;Display string pointed to by DE  
7d4f			            LD   A, kLCD_Line1+10  
7d4f			            CALL fLCD_Pos       ;Position cursor to location in A  
7d4f			            LD   DE, keyscan_table_row5  
7d4f			            CALL fLCD_Str       ;Display string pointed to by DE  
7d4f			  
7d4f				;call delay250ms  
7d4f			endif  
7d4f			;	jp testkey  
7d4f			  
7d4f			; get first char reported  
7d4f			  
7d4f 21 00 fe			ld hl,keyscan_table_row5  
7d52			  
7d52				;ld b, 46   ; 30 keys to remap + 8 nulls   
7d52 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7d54			.findkey:  
7d54 7e				ld a,(hl)  
7d55			;	cp 0  
7d55 b7				or a  
7d56 28 04			jr z, .nextkey  
7d58 fe 7e			cp KEY_MATRIX_NO_PRESS  
7d5a 20 06			jr nz, .foundkey  
7d5c			.nextkey:  
7d5c 23				inc hl  
7d5d 10 f5			djnz .findkey  
7d5f 3e 00			ld a,0  
7d61 c9				ret  
7d62			.foundkey:  
7d62 7e				ld a,(hl)  
7d63 c9				ret  
7d64				  
7d64			  
7d64			; convert the raw key map given hl for destination key  
7d64			.mapkeys:  
7d64 11 00 fe			ld de,keyscan_table_row5  
7d67			  
7d67 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7d69			.remap:  
7d69 1a				ld a,(de)  
7d6a fe 23			cp '#'  
7d6c 20 02			jr nz, .remapnext  
7d6e				;CALLMONITOR  
7d6e 7e				ld a,(hl)  
7d6f 12				ld (de),a  
7d70			  
7d70			  
7d70			  
7d70			.remapnext:  
7d70 23				inc hl  
7d71 13				inc de  
7d72 10 f5			djnz .remap  
7d74				  
7d74 c9				ret  
7d75			  
7d75			  
7d75			  
7d75			.mtocold2:  
7d75			  
7d75			;	; flag if key D is held down and remove from reporting  
7d75			;	ld bc, .key_map_fd    
7d75			;	ld hl, keyscan_table  
7d75			;	ld de, key_fd  
7d75			;	call .key_shift_hold  
7d75			;	cp 255  
7d75			;	jr z, .cinmap  
7d75			;	; flag if key C is held down and remove from reporting  
7d75			;	ld bc, .key_map_fc    
7d75			;	ld hl, keyscan_table+key_cols  
7d75			;	ld de, key_fc  
7d75			;	call .key_shift_hold  
7d75			;	cp 255  
7d75			;	jr z, .cinmap  
7d75			;	; flag if key B is held down and remove from reporting  
7d75			;	ld bc, .key_map_fb    
7d75			;	ld hl, keyscan_table+(key_cols*2)  
7d75			;	ld de, key_fb  
7d75			;	call .key_shift_hold  
7d75			;	cp 255  
7d75			;	jr z, .cinmap  
7d75			;	; flag if key A is held down and remove from reporting  
7d75			;	ld bc, .key_map_fa    
7d75			;	ld hl, keyscan_table+(key_cols*3)  
7d75			;	ld de, key_fa  
7d75			;	call .key_shift_hold  
7d75			;	cp 255  
7d75			;	jr z, .cinmap  
7d75			  
7d75 11 47 7c			ld de, .matrix_to_char  
7d78			  
7d78			  
7d78			.cinmap1:   
7d78				if DEBUG_KEY  
7d78			            LD   A, kLCD_Line4  
7d78			            CALL fLCD_Pos       ;Position cursor to location in A  
7d78					push de  
7d78			            LD   DE, keyscan_table  
7d78			            CALL fLCD_Str       ;Display string pointed to by DE  
7d78					pop de  
7d78				endif  
7d78			  
7d78				; scan key matrix table for any held key  
7d78			  
7d78				; de holds either the default matrix or one selected above  
7d78			  
7d78 21 cd fd			ld hl, keyscan_table  
7d7b 06 32			ld b,key_cols*key_rows  
7d7d			  
7d7d 7e			.cin11:	ld a,(hl)  
7d7e fe 23			cp '#'  
7d80 28 08			jr z, .cinhit1  
7d82 23				inc hl  
7d83 13				inc de  
7d84 05				dec b  
7d85 20 f6			jr nz, .cin11  
7d87				; no key found held  
7d87 3e 00			ld a,0  
7d89 c9				ret  
7d8a d5			.cinhit1: push de  
7d8b e1				pop hl  
7d8c 7e				ld a,(hl)  
7d8d c9				ret  
7d8e			  
7d8e			; flag a control key is held   
7d8e			; hl is key pin, de is flag indicator  
7d8e			  
7d8e			.key_shift_hold1:  
7d8e c5				push bc  
7d8f 3e 01			ld a, 1  
7d91 32 ef fa			ld (cursor_shape),a  
7d94 06 00			ld b, 0  
7d96 7e				ld a, (hl)  
7d97 fe 2e			cp '.'  
7d99 28 09			jr z, .key_shift11  
7d9b 06 ff			ld b, 255  
7d9d			;	ld a, '+'    ; hide key from later scans  
7d9d 36 2b			ld (hl),'+'  
7d9f 3e 02			ld a, 2  
7da1 32 ef fa			ld (cursor_shape), a  
7da4			.key_shift11:  
7da4				; write flag indicator  
7da4 78				ld a,b  
7da5 12				ld (de),a  
7da6			  
7da6 d1				pop de    ; de now holds the key map ptr  
7da7 c9				ret  
7da8			  
7da8				  
7da8			  
7da8			; scans keyboard matrix and flags key press in memory array	  
7da8				  
7da8			matrix:  
7da8				;call matrix  
7da8				; TODO optimise the code....  
7da8			  
7da8			  
7da8			;ld hl, keyscan_table_row1  
7da8			;ld de, keyscan_table_row1+1  
7da8			;ld bc,46  
7da8			;ld a,KEY_MATRIX_NO_PRESS  
7da8			;ldir  
7da8			  
7da8			  
7da8			  
7da8			; reset counter  
7da8 3e 80		ld a, 128  
7daa d3 c1		out (portbdata),a  
7dac			  
7dac 06 0a		ld b, 10  
7dae 0e 00		ld c, 0       ; current clock toggle  
7db0			  
7db0			.colscan:  
7db0			  
7db0			; set current column  
7db0			; disable clock enable and set clock low  
7db0			  
7db0			;ld a, 0  
7db0			;out (portbdata),a  
7db0			  
7db0			; For each column scan for switches  
7db0			  
7db0 c5			push bc  
7db1 21 c3 fd		ld hl, keyscan_scancol  
7db4 cd b8 7e		call .rowscan  
7db7 c1			pop bc  
7db8			  
7db8			  
7db8			; get back current column  
7db8			  
7db8			; translate the row scan  
7db8			  
7db8			;   
7db8			; row 1  
7db8			  
7db8 78			ld a,b  
7db9			  
7db9 21 36 fe		LD   hl, keyscan_table_row1+10  
7dbc			  
7dbc cd c3 0f		call subafromhl  
7dbf			;call addatohl  
7dbf			  
7dbf 11 c3 fd		ld de, keyscan_scancol  
7dc2			  
7dc2 1a			ld a,(de)  
7dc3 77			ld (hl),a  
7dc4			  
7dc4			  
7dc4			  
7dc4			  
7dc4			; row 2  
7dc4			  
7dc4 78			ld a,b  
7dc5			  
7dc5 21 2b fe		LD   hl, keyscan_table_row2+10  
7dc8			  
7dc8			;call addatohl  
7dc8 cd c3 0f		call subafromhl  
7dcb			  
7dcb			  
7dcb 11 c4 fd		ld de, keyscan_scancol+1  
7dce			  
7dce 1a			ld a,(de)  
7dcf 77			ld (hl),a  
7dd0			  
7dd0			  
7dd0			; row 3  
7dd0			  
7dd0 78			ld a,b  
7dd1			  
7dd1 21 20 fe		LD   hl, keyscan_table_row3+10  
7dd4			  
7dd4			;call addatohl  
7dd4 cd c3 0f		call subafromhl  
7dd7			  
7dd7 11 c5 fd		ld de, keyscan_scancol+2  
7dda			  
7dda 1a			ld a,(de)  
7ddb 77			ld (hl),a  
7ddc			  
7ddc			  
7ddc			  
7ddc			; row 4  
7ddc			  
7ddc 78			ld a,b  
7ddd			  
7ddd 21 15 fe		LD   hl, keyscan_table_row4+10  
7de0			  
7de0			;call addatohl  
7de0 cd c3 0f		call subafromhl  
7de3			  
7de3 11 c6 fd		ld de, keyscan_scancol+3  
7de6			  
7de6 1a			ld a,(de)  
7de7 77			ld (hl),a  
7de8			  
7de8			; row 5  
7de8			  
7de8 78			ld a,b  
7de9			  
7de9 21 0a fe		LD   hl, keyscan_table_row5+10  
7dec			  
7dec			;call addatohl  
7dec cd c3 0f		call subafromhl  
7def			  
7def 11 c7 fd		ld de, keyscan_scancol+4  
7df2			  
7df2 1a			ld a,(de)  
7df3 77			ld (hl),a  
7df4			  
7df4			; handshake next column  
7df4			  
7df4			  
7df4 3e 40		ld a, 64  
7df6 d3 c1		out (portbdata),a  
7df8			  
7df8 3e 00		ld a, 0  
7dfa d3 c1		out (portbdata),a  
7dfc			  
7dfc			; toggle clk and move to next column  
7dfc			;ld a, 64  
7dfc			;cp c  
7dfc			;  
7dfc			;jr z, .coltoglow  
7dfc			;ld c, a  
7dfc			;jr .coltog  
7dfc			;.coltoglow:  
7dfc			;ld c, 0  
7dfc			;.coltog:  
7dfc			;ld a, c  
7dfc			;out (portbdata),a  
7dfc			  
7dfc 10 b2		djnz .colscan  
7dfe			  
7dfe 3e 0a		ld a,10  
7e00 21 2c fe		LD   hl, keyscan_table_row1  
7e03 cd b1 0f		call addatohl  
7e06			;ld a, 0  
7e06 36 00		ld (hl), 0  
7e08			  
7e08			  
7e08 3e 0a		ld a,10  
7e0a 21 21 fe		LD   hl, keyscan_table_row2  
7e0d cd b1 0f		call addatohl  
7e10			;ld a, 0  
7e10 36 00		ld (hl), 0  
7e12			  
7e12 3e 0a		ld a,10  
7e14 21 16 fe		LD   hl, keyscan_table_row3  
7e17 cd b1 0f		call addatohl  
7e1a			;ld a, 0  
7e1a 36 00		ld (hl), 0  
7e1c			  
7e1c 3e 0a		ld a,10  
7e1e 21 0b fe		LD   hl, keyscan_table_row4  
7e21 cd b1 0f		call addatohl  
7e24			;ld a, 0  
7e24 36 00		ld (hl), 0  
7e26			  
7e26 3e 0a		ld a,10  
7e28 21 00 fe		LD   hl, keyscan_table_row5  
7e2b cd b1 0f		call addatohl  
7e2e			;ld a, 0  
7e2e 36 00		ld (hl), 0  
7e30			  
7e30			if DEBUG_KEY_MATRIX  
7e30			  
7e30			; Display text on first line  
7e30			            LD   A, kLCD_Line1  
7e30			            CALL fLCD_Pos       ;Position cursor to location in A  
7e30			            LD   DE, keyscan_table_row1  
7e30			            ;LD   DE, MsgHello  
7e30			            CALL fLCD_Str       ;Display string pointed to by DE  
7e30			  
7e30			; Display text on second line  
7e30			            LD   A, kLCD_Line2  
7e30			            CALL fLCD_Pos       ;Position cursor to location in A  
7e30			            LD   DE, keyscan_table_row2  
7e30			            CALL fLCD_Str       ;Display string pointed to by DE  
7e30			            LD   A, kLCD_Line3  
7e30			            CALL fLCD_Pos       ;Position cursor to location in A  
7e30			            LD   DE, keyscan_table_row3  
7e30			            CALL fLCD_Str       ;Display string pointed to by DE  
7e30			            LD   A, kLCD_Line4  
7e30			            CALL fLCD_Pos       ;Position cursor to location in A  
7e30			            LD   DE, keyscan_table_row4  
7e30			            CALL fLCD_Str       ;Display string pointed to by DE  
7e30			            LD   A, kLCD_Line4+10  
7e30			            CALL fLCD_Pos       ;Position cursor to location in A  
7e30			            LD   DE, keyscan_table_row5  
7e30			            CALL fLCD_Str       ;Display string pointed to by DE  
7e30			  
7e30			;call delay250ms  
7e30				jp matrix  
7e30			endif  
7e30 c9			ret  
7e31			  
7e31			; using decade counter....  
7e31			  
7e31			  
7e31			; TODO reset decade counter to start of scan  
7e31			  
7e31			; reset 15  
7e31			; clock 14  
7e31			; ce 13  
7e31			  
7e31			; 1 - q5  
7e31			; 2 - q1  
7e31			; 3 - q0  
7e31			; 4 - q2  
7e31			; 5 - q6  
7e31			; 6 - q7  
7e31			; 7 - q3  
7e31			; 8 - vss  
7e31			; 9 - q8  
7e31			; 10 - q4  
7e31			; 11 - q9  
7e31			; 12 - cout  
7e31			; 16 - vdd  
7e31			  
7e31			; clock      ce       reset     output  
7e31			; 0          x        0         n  
7e31			; x          1        0         n  
7e31			; x          x        1         q0  
7e31			; rising     0        0         n+1  
7e31			; falling    x        0         n  
7e31			; x          rising   0         n  
7e31			; 1          falling  0         x+1  
7e31			;  
7e31			; x = dont care, if n < 5 carry = 1 otherwise 0  
7e31			  
7e31			;   
7e31			; reset   
7e31			; 13=0, 14=0, 15=1 .. 15=0  
7e31			;  
7e31			; handshake line  
7e31			; 14=1.... read line 14=0  
7e31			  
7e31			  
7e31			  
7e31			  
7e31			  
7e31			; TODO hand shake clock for next column scan  
7e31			; TODO detect each row  
7e31			  
7e31			  
7e31			  
7e31			  
7e31			; reset 128  
7e31			; clock 64  
7e31			; ce 32  
7e31			  
7e31			  
7e31			.cyclestart:  
7e31			  
7e31			; reset counter  
7e31 3e 80		ld a, 128  
7e33 d3 c1		out (portbdata),a  
7e35			  
7e35			; loop leds  
7e35 06 0a		ld b,10  
7e37			  
7e37			.cycle1:  
7e37 c5			push bc  
7e38 3e 00		ld a, 0  
7e3a d3 c1		out (portbdata),a  
7e3c cd b4 0c		call delay250ms  
7e3f			  
7e3f 3e 40		ld a, 64  
7e41 d3 c1		out (portbdata),a  
7e43 cd b4 0c		call delay250ms  
7e46			  
7e46 3e 00		ld a, 0  
7e48 d3 c1		out (portbdata),a  
7e4a cd b4 0c		call delay250ms  
7e4d			  
7e4d c1			pop bc  
7e4e 10 e7		djnz .cycle1  
7e50			  
7e50			  
7e50 18 df		jr .cyclestart  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			; map matrix key held to char on face of key  
7e52			  
7e52			;.mtocold:  
7e52			;  
7e52			;  
7e52			;; reset counter  
7e52			;ld a, 128  
7e52			;out (portbdata),a  
7e52			;  
7e52			;  
7e52			;; scan keyboard row 1  
7e52			;ld a, 0  
7e52			;out (portbdata),a  
7e52			;;ld a, 64  
7e52			;;out (portbdata),a  
7e52			;  
7e52			;  
7e52			;	ld a, 128  
7e52			;	ld hl, keyscan_table  
7e52			;	call .rowscan  
7e52			;  
7e52			;;ld a, 0  
7e52			;;out (portbdata),a  
7e52			;ld a, 64  
7e52			;out (portbdata),a  
7e52			;  
7e52			;	ld a, 64  
7e52			;	ld hl, keyscan_table+key_cols  
7e52			;	call .rowscan  
7e52			;  
7e52			;ld a, 0  
7e52			;out (portbdata),a  
7e52			;;ld a, 64  
7e52			;;out (portbdata),a  
7e52			;	ld a, 32  
7e52			;	ld hl, keyscan_table+(key_cols*2)  
7e52			;	call .rowscan  
7e52			;  
7e52			;  
7e52			;;ld a, 0  
7e52			;;out (portbdata),a  
7e52			;ld a, 64  
7e52			;out (portbdata),a  
7e52			;  
7e52			;	ld a, 16  
7e52			;	ld hl, keyscan_table+(key_cols*3)  
7e52			;	call .rowscan  
7e52			;  
7e52			;  
7e52			;	; flag if key D is held down and remove from reporting  
7e52			;	ld bc, .key_map_fd    
7e52			;	ld hl, keyscan_table  
7e52			;	ld de, key_fd  
7e52			;	call .key_shift_hold  
7e52			;	cp 255  
7e52			;	jr z, .cinmap  
7e52			;	; flag if key C is held down and remove from reporting  
7e52			;	ld bc, .key_map_fc    
7e52			;	ld hl, keyscan_table+key_cols  
7e52			;	ld de, key_fc  
7e52			;	call .key_shift_hold  
7e52			;	cp 255  
7e52			;	jr z, .cinmap  
7e52			;	; flag if key B is held down and remove from reporting  
7e52			;	ld bc, .key_map_fb    
7e52			;	ld hl, keyscan_table+(key_cols*2)  
7e52			;	ld de, key_fb  
7e52			;	call .key_shift_hold  
7e52			;	cp 255  
7e52			;	jr z, .cinmap  
7e52			;	; flag if key A is held down and remove from reporting  
7e52			;	ld bc, .key_map_fa    
7e52			;	ld hl, keyscan_table+(key_cols*3)  
7e52			;	ld de, key_fa  
7e52			;	call .key_shift_hold  
7e52			;	cp 255  
7e52			;	jr z, .cinmap  
7e52			;  
7e52			;	ld de, .matrix_to_char  
7e52			;  
7e52			;  
7e52			;.cinmap:   
7e52			;	if DEBUG_KEY  
7e52			;            LD   A, kLCD_Line4  
7e52			;            CALL fLCD_Pos       ;Position cursor to location in A  
7e52			;		push de  
7e52			;            LD   DE, keyscan_table  
7e52			;            CALL fLCD_Str       ;Display string pointed to by DE  
7e52			;		pop de  
7e52			;	endif  
7e52			  
7e52				; scan key matrix table for any held key  
7e52			  
7e52				; de holds either the default matrix or one selected above  
7e52			  
7e52			;	ld hl, keyscan_table  
7e52			;	ld b,key_cols*key_rows  
7e52			;  
7e52			;.cin1:	ld a,(hl)  
7e52			;	cp '#'  
7e52			;	jr z, .cinhit  
7e52			;	inc hl  
7e52			;	inc de  
7e52			;	dec b  
7e52			;	jr nz, .cin1  
7e52			;	; no key found held  
7e52			;	ld a,0  
7e52			;	ret  
7e52			;.cinhit: push de  
7e52			;	pop hl  
7e52			;	ld a,(hl)  
7e52			;	ret  
7e52			  
7e52			; flag a control key is held   
7e52			; hl is key pin, de is flag indicator  
7e52			  
7e52			;.key_shift_hold:  
7e52			;	push bc  
7e52			;	ld a, 1  
7e52			;	ld (cursor_shape),a  
7e52			;	ld b, 0  
7e52			;	ld a, (hl)  
7e52			;	cp '.'  
7e52			;	jr z, .key_shift1  
7e52			;	ld b, 255  
7e52			;	ld a, '+'    ; hide key from later scans  
7e52			;	ld (hl),a  
7e52			;	ld a, 2  
7e52			;	ld (cursor_shape),a  
7e52			;.key_shift1:  
7e52			;	; write flag indicator  
7e52			;	ld a,b  
7e52			;	ld (de),a  
7e52			;  
7e52			;	pop de    ; de now holds the key map ptr  
7e52			;	ret  
7e52			  
7e52				  
7e52				  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			;	push hl  
7e52			;	push de  
7e52			;	push bc  
7e52			;	call keyscan  
7e52			;	; map key matrix to ascii value of key face  
7e52			;  
7e52			;	ld hl, key_face_map  
7e52			;	ld de, keyscan_table  
7e52			;  
7e52			;	; get how many keys to look at  
7e52			;	ld b, keyscan_table_len  
7e52			;	  
7e52			;  
7e52			;	; at this stage fall out on first key hit  
7e52			;	; TODO handle multiple key press  
7e52			;  
7e52			;map1:	ld a,(hl)  
7e52			;	cp '#'  
7e52			;	jr z, keyhit  
7e52			;	inc hl  
7e52			;	inc de  
7e52			;	dec b  
7e52			;	jr nz, map1  
7e52			;nohit:	ld a, 0  
7e52			;	jr keydone  
7e52			;keyhit: push de  
7e52			;	pop hl  
7e52			;	ld a,(hl)  
7e52			;keydone:  
7e52			;	push bc  
7e52			;	push de  
7e52			; 	push hl  
7e52			;	ret   
7e52			;  
7e52			  
7e52			  
7e52			  
7e52			  
7e52			; scan physical key matrix  
7e52			  
7e52			  
7e52			;keyscan:  
7e52			;  
7e52			;; for each key_row use keyscanr bit mask for out  
7e52			;; then read in for keyscanc bitmask  
7e52			;; save result of row scan to keyscantable  
7e52			;  
7e52			;; scan keyboard row 1  
7e52			;  
7e52			;	ld b, key_rows  
7e52			;	ld hl, key_scanr  
7e52			;	ld de, keyscan_table  
7e52			;  
7e52			;rowloop:  
7e52			;  
7e52			;	ld a,(hl)		; out bit mask to energise keyboard row  
7e52			;	call rowscan  
7e52			;	inc hl  
7e52			;	dec b  
7e52			;	jr nz, rowloop  
7e52			;  
7e52			;	ret  
7e52			;  
7e52			;  
7e52			;; pass a out bitmask, b row number  
7e52			;arowscan:   
7e52			;	push bc  
7e52			;  
7e52			;	ld d, b  
7e52			;  
7e52			;	; calculate buffer location for this row  
7e52			;  
7e52			;	ld hl, keyscan_table	  
7e52			;kbufr:  ld e, key_cols  
7e52			;kbufc:	inc hl  
7e52			;	dec e  
7e52			;	jr nz, kbufc  
7e52			;	dec d  
7e52			;	jr nz, kbufr  
7e52			;  
7e52			;	; energise row and read columns  
7e52			;  
7e52			;	out (portbdata),a  
7e52			;	in a,(portbdata)  
7e52			;	ld c,a  
7e52			;  
7e52			;  
7e52			;	; save buffer loc  
7e52			;  
7e52			;	ld (keybufptr), hl  
7e52			;  
7e52			;	ld hl, key_scanc  
7e52			;	ld d, key_cols  
7e52			;  
7e52			;	; for each column check each bit mask  
7e52			;  
7e52			;colloop:  
7e52			;	  
7e52			;  
7e52			;	; reset flags for the row   
7e52			;  
7e52			;	ld b,'.'  
7e52			;	and (hl)  
7e52			;	jr z, maskskip  
7e52			;	ld b,'#'  
7e52			;maskskip:  
7e52			;	; save  key state  
7e52			;	push hl  
7e52			;	ld hl, (keybufptr)  
7e52			;	ld (hl), b  
7e52			;	inc hl  
7e52			;	ld (keybufptr), hl  
7e52			;  
7e52			;	; move to next bit mask  
7e52			;	pop hl  
7e52			;	inc hl  
7e52			;  
7e52			;	dec d  
7e52			;	jr nz, colloop  
7e52			;  
7e52			;	ret  
7e52			;  
7e52			;  
7e52			;;  
7e52			; lcd functions  
7e52			;  
7e52			;  
7e52			  
7e52			;if DEBUG_KEY_MATRIX  
7e52			  
7e52			; test function to display hardware view of matrix state  
7e52			  
7e52			matrixold:  
7e52			  
7e52			  
7e52			  
7e52			; reset counter  
7e52 3e 80		ld a, 128  
7e54 d3 c1		out (portbdata),a  
7e56			; scan keyboard row 1  
7e56 3e 00		ld a, 0  
7e58 d3 c1		out (portbdata),a  
7e5a			;ld a, 64  
7e5a			;out (portbdata),a  
7e5a 3e 80			ld a, 128  
7e5c 21 2c fe			ld hl, keyscan_table_row1  
7e5f cd b8 7e			call .rowscan  
7e62			  
7e62			;ld a, 0  
7e62			;out (portbdata),a  
7e62 3e 40		ld a, 64  
7e64 d3 c1		out (portbdata),a  
7e66 3e 40			ld a, 64  
7e68 21 21 fe			ld hl, keyscan_table_row2  
7e6b cd b8 7e			call .rowscan  
7e6e			  
7e6e 3e 00		ld a, 0  
7e70 d3 c1		out (portbdata),a  
7e72			;ld a, 64  
7e72			;out (portbdata),a  
7e72 3e 20			ld a, 32  
7e74 21 16 fe			ld hl, keyscan_table_row3  
7e77 cd b8 7e			call .rowscan  
7e7a			  
7e7a			;ld a, 0  
7e7a			;out (portbdata),a  
7e7a 3e 40		ld a, 64  
7e7c d3 c1		out (portbdata),a  
7e7e 3e 10			ld a, 16  
7e80 21 0b fe			ld hl, keyscan_table_row4  
7e83 cd b8 7e			call .rowscan  
7e86			  
7e86			; Display text on first line  
7e86 3e 00		            LD   A, kLCD_Line1  
7e88 cd b8 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
7e8b 11 2c fe		            LD   DE, keyscan_table_row1  
7e8e			            ;LD   DE, MsgHello  
7e8e cd da 7a		            CALL fLCD_Str       ;Display string pointed to by DE  
7e91			  
7e91			; Display text on second line  
7e91 3e 28		            LD   A, kLCD_Line2  
7e93 cd b8 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
7e96 11 21 fe		            LD   DE, keyscan_table_row2  
7e99 cd da 7a		            CALL fLCD_Str       ;Display string pointed to by DE  
7e9c 3e 50		            LD   A, kLCD_Line3  
7e9e cd b8 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
7ea1 11 16 fe		            LD   DE, keyscan_table_row3  
7ea4 cd da 7a		            CALL fLCD_Str       ;Display string pointed to by DE  
7ea7 3e 78		            LD   A, kLCD_Line4  
7ea9 cd b8 7a		            CALL fLCD_Pos       ;Position cursor to location in A  
7eac 11 0b fe		            LD   DE, keyscan_table_row4  
7eaf cd da 7a		            CALL fLCD_Str       ;Display string pointed to by DE  
7eb2			  
7eb2 cd b4 0c			call delay250ms  
7eb5 c3 a8 7d			jp matrix  
7eb8			  
7eb8			; pass de as row display flags  
7eb8			.rowscan:   
7eb8			;	out (portbdata),a  
7eb8 db c1			in a,(portbdata)  
7eba 4f				ld c,a  
7ebb				; reset flags for the row   
7ebb 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7ebd e6 01			and 1  
7ebf 28 02			jr z, .p1on  
7ec1 06 23			ld b,'#'  
7ec3			.p1on:  
7ec3 70				ld (hl), b  
7ec4 23				inc hl  
7ec5			  
7ec5 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7ec7 79				ld a,c  
7ec8 e6 02			and 2  
7eca			;	bit 0,a  
7eca 28 02			jr z, .p2on  
7ecc 06 23			ld b,'#'  
7ece			.p2on:  
7ece 70				ld (hl), b  
7ecf 23				inc hl  
7ed0			;  
7ed0 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7ed2 79				ld a,c  
7ed3 e6 04			and 4  
7ed5			;;	bit 0,a  
7ed5 28 02			jr z, .p3on  
7ed7 06 23			ld b,'#'  
7ed9			.p3on:  
7ed9 70				ld (hl), b  
7eda 23				inc hl  
7edb			;;  
7edb 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7edd			;;	bit 0,a  
7edd 79				ld a,c  
7ede e6 08			and 8  
7ee0 28 02			jr z, .p4on  
7ee2 06 23			ld b,'#'  
7ee4			.p4on:  
7ee4 70				ld (hl), b  
7ee5 23				inc hl  
7ee6			  
7ee6 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7ee8			;;	bit 0,a  
7ee8 79				ld a,c  
7ee9 e6 10			and 16  
7eeb 28 02			jr z, .p5on  
7eed 06 23			ld b,'#'  
7eef			.p5on:  
7eef 70				ld (hl), b  
7ef0 23				inc hl  
7ef1			; zero term  
7ef1			;	ld b,0  
7ef1 36 00			ld (hl), 0  
7ef3			  
7ef3 c9			.rscandone: ret  
7ef4			  
7ef4			;addatohl:  
7ef4			;  
7ef4			 ;add   a, l    ; A = A+L  
7ef4			  ;  ld    l, a    ; L = A+L  
7ef4			   ; adc   a, h    ; A = A+L+H+carry  
7ef4			   ; sub   l       ; A = H+carry  
7ef4			   ; ld    h, a    ; H = H+carry  
7ef4			  
7ef4			;ret  
7ef4			; eof  
# End of file firmware_key_5x10.asm
7ef4			;include "firmware_key_4x10.asm" 
7ef4			 
7ef4			heap_size:    equ heap_end - heap_start 
7ef4			;eof 
# End of file os_mega.asm
7ef4
