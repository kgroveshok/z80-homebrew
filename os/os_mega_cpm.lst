# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 4d 16			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 1   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0103			  
0103			STORE_0_AUTOFILE: equ $21  
0103			STORE_0_BANKRUN: equ $23  
0103			STORE_0_FILERUN: equ $24  
0103			  
0103			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0103			  
0103			STORE_0_AUTORUN: equ $20  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diags   
0103			  
0103			hardware_diag: equ key_face_held - 1  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_diag - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			spi_device_id: equ spi_device - 1    ; human readable bank number  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ scratch-2  
0103			os_new_parse_len: equ os_new_malloc - 2  
0103			os_new_word_len: equ os_new_parse_len - 2  
0103			os_new_work_ptr: equ os_new_word_len - 2  
0103			os_new_src_ptr: equ os_new_work_ptr - 2  
0103			os_new_exec: equ os_new_src_ptr - 2  
0103			os_new_exec_ptr: equ os_new_exec - 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ os_new_exec_ptr - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103 3e 00				ld a, 0  
0105 32 80 ee				ld (hardware_diag), a  
0108			  
0108					; clear all the buffers  
0108			  
0108 21 1f ed				ld hl, display_fb1  
010b 22 db eb				ld (display_fb_active), hl  
010e			  
010e cd 9c 09				call clear_display  
0111			  
0111 21 dd eb				ld hl, display_fb2  
0114 22 db eb				ld (display_fb_active), hl  
0117			  
0117 cd 9c 09				call clear_display  
011a			  
011a					; init primary frame buffer area  
011a 21 c0 ed				ld hl, display_fb0  
011d 22 db eb				ld (display_fb_active), hl  
0120			  
0120 cd 9c 09				call clear_display  
0123			  
0123			  
0123 cd 32 58				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0126			  
0126 cd 20 59			call key_init  
0129 cd b0 01			call storage_init  
012c			  
012c				; setup malloc functions  
012c			  
012c				if MALLOC_1  
012c cd 6c 10				call  heap_init  
012f				endif  
012f				if MALLOC_4  
012f					call  heap_init  
012f				endif  
012f			  
012f				; init sound hardware if present  
012f			  
012f				if SOUND_ENABLE  
012f					call sound_init  
012f				endif  
012f			  
012f				; lcd test sequence  
012f					  
012f cd bf 09			call update_display  
0132 cd 0e 09			call delay1s  
0135 3e 2b			ld a,'+'  
0137 cd a1 09			call fill_display  
013a cd bf 09			call update_display  
013d cd 0e 09			call delay1s  
0140 3e 2a			ld a,'*'  
0142 cd a1 09			call fill_display  
0145 cd bf 09			call update_display  
0148 cd 0e 09			call delay1s  
014b 3e 2d			ld a,'-'  
014d cd a1 09			call fill_display  
0150 cd bf 09			call update_display  
0153 cd 0e 09			call delay1s  
0156			  
0156			; boot splash screen  
0156			if display_cols == 20	  
0156			        ld a, display_row_1    
0156			else  
0156 3e 0a		        ld a, display_row_1 +10   
0158			endif  
0158 11 89 01			ld de, bootmsg  
015b cd af 09			call str_at_display  
015e cd bf 09			call update_display  
0161			  
0161			  
0161 cd 0e 09			call delay1s  
0164 cd 0e 09			call delay1s  
0167			if display_cols == 20	  
0167			            LD   A, display_row_3+2  
0167			else  
0167 3e 5c		            LD   A, display_row_3+12  
0169			endif  
0169 11 9e 01			ld de, bootmsg1  
016c cd af 09			call str_at_display  
016f cd bf 09			call update_display  
0172 cd 0e 09			call delay1s  
0175 cd 0e 09			call delay1s  
0178			  
0178			;	ld a, display_row_4+3  
0178			;	ld de, bootmsg2  
0178			;	call str_at_display  
0178			;	call update_display  
0178			;	call delay1s  
0178			;	call delay1s  
0178			  
0178			; debug mark setup  
0178			  
0178 3e 5f		ld a, '_'  
017a 32 7a ee		ld (debug_mark),a  
017d 32 7b ee		ld (debug_mark+1),a  
0180 32 7c ee		ld (debug_mark+2),a  
0183 3e 00		ld a,0  
0185 32 7d ee		ld (debug_mark+3),a  
0188			  
0188 c9					ret  
0189			  
0189			  
0189 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
019e .. 00		bootmsg1:	db "by Kevin Groves",0  
01ae			;bootmsg2:	db "Firmware v0.1",0  
01ae			  
01ae			; a 4x20 lcd  
01ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ae			  
01ae			;if display_cols == 20  
01ae			;	include "firmware_lcd_4x20.asm"  
01ae			;endif  
01ae			  
01ae			;if display_cols == 40  
01ae			;	include "firmware_lcd_4x40.asm"  
01ae			;endif  
01ae			  
01ae			;  
01ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ae			; TODO abstract the bit bang video out interface for dual display  
01ae			; TODO wire video out to tx pin on rc2014 bus  
01ae			  
01ae			; must supply cin, and cin_wait for low level hardware abstraction   
01ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ae			; test scancode  
01ae			  
01ae			;;;;;  
01ae			;;;  
01ae			; Moved out to mini and maxi versions  
01ae			;  
01ae			; include "firmware_key_4x4.asm"  
01ae			; using existing 4 wire x 4 resistor array for input  
01ae			;include "firmware_key_4x10.asm"  
01ae			; need to mod the board for 5 rows due to resistor array  
01ae			;include "firmware_key_5x10.asm"  
01ae			  
01ae			; storage hardware interface  
01ae			  
01ae			; use microchip serial eeprom for storage  
01ae			  
01ae			  
01ae			if STORAGE_SE  
01ae				include "firmware_spi.asm"  
01ae				include "firmware_seeprom.asm"  
01ae			else  
01ae			   ; create some stubs for the labels  
01ae c9			se_readbyte: ret  
01af c9			se_writebyte: ret  
01b0 c9			storage_init: ret  
01b1			  
01b1			endif  
01b1			  
01b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01b1			;include "firmware_cf.asm"  
01b1			  
01b1			; load up high level storage hardward abstractions  
01b1			include "firmware_storage.asm"  
01b1			 
01b1			; persisent storage hardware abstraction layer  
01b1			 
01b1			 
01b1			 
01b1			; Block 0 on storage is a config state 
01b1			 
01b1			 
01b1			 
01b1			; TODO add read phy block and write phy block functions 
01b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01b1			 
01b1			; Abstraction layer  
01b1			 
01b1			; Logocial block size is same size as physical size - using tape concept 
01b1			 
01b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01b1			 
01b1			 
01b1			 
01b1			; Filesystem layout (Logical layout) 
01b1			; 
01b1			; Block 0 - Bank config  
01b1			; 
01b1			;      Byte - 0 file id counter 
01b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01b1			;      Byte - 3-20 zero terminated bank label 
01b1			; 
01b1			; Block 1 > File storage 
01b1			; 
01b1			;      Byte 0 file id    - block 0 file details 
01b1			;      Byte 1 block id - block 0 is file  
01b1			;            Byte 2-15 - File name 
01b1			; 
01b1			;       - to end of block data 
01b1			; 
01b1			 
01b1			 
01b1			; Read Block 
01b1			; ---------- 
01b1			; 
01b1			; With current bank 
01b1			;  
01b1			; Get block number to read 
01b1			; Load physical blocks starting at start block into buffer 
01b1			 
01b1			; de points to buffer to use 
01b1			; hl holds logical block number  
01b1			 
01b1			storage_read_block: 
01b1			 
01b1				; TODO bank selection 
01b1			 
01b1				; for each of the physical blocks read it into the buffer 
01b1 06 40			ld b, STORE_BLOCK_PHY 
01b3			 
01b3				if DEBUG_STORESE 
01b3 d5					push de 
01b4				endif 
01b4				 
01b4			.rl1:    
01b4			 
01b4				; read physical block at hl into de 
01b4			        ; increment hl and de to next read position on exit 
01b4			 
01b4 e5				push hl 
01b5 d5				push de	 
01b6 c5				push bc 
01b7			;	if DEBUG_STORESE 
01b7			;		push af 
01b7			;		ld a, 'R' 
01b7			;		ld (debug_mark),a 
01b7			;		pop af 
01b7			;		CALLMONITOR 
01b7			;	endif 
01b7 cd ae 01			call se_readbyte 
01ba			;	if DEBUG_STORESE 
01ba			;		ld a,(spi_portbyte) 
01ba			;		ld l, a 
01ba			;		push af 
01ba			;		ld a, '1' 
01ba			;		ld (debug_mark),a 
01ba			;		pop af 
01ba			;		CALLMONITOR 
01ba			;	endif 
01ba c1				pop bc 
01bb d1				pop de 
01bc e1				pop hl 
01bd 12				ld (de),a 
01be 23				inc hl 
01bf 13				inc de 
01c0			 
01c0			;	if DEBUG_STORESE 
01c0			;		push af 
01c0			;		ld a, 'r' 
01c0			;		ld (debug_mark),a 
01c0			;		pop af 
01c0			;		CALLMONITOR 
01c0			;	endif 
01c0			 
01c0 10 f2			djnz .rl1 
01c2			 
01c2				if DEBUG_STORESE 
01c2					DMARK "SRB" 
01c2 f5				push af  
01c3 3a d7 01			ld a, (.dmark)  
01c6 32 7a ee			ld (debug_mark),a  
01c9 3a d8 01			ld a, (.dmark+1)  
01cc 32 7b ee			ld (debug_mark+1),a  
01cf 3a d9 01			ld a, (.dmark+2)  
01d2 32 7c ee			ld (debug_mark+2),a  
01d5 18 03			jr .pastdmark  
01d7 ..			.dmark: db "SRB"  
01da f1			.pastdmark: pop af  
01db			endm  
# End of macro DMARK
01db d1					pop de 
01dc			; 
01dc			;		push af 
01dc			;		ld a, 'R' 
01dc			;		ld (debug_mark),a 
01dc			;		pop af 
01dc					CALLMONITOR 
01dc cd 77 14			call break_point_state  
01df				endm  
# End of macro CALLMONITOR
01df				endif 
01df c9				ret	 
01e0				 
01e0			 
01e0			; File Size 
01e0			; --------- 
01e0			; 
01e0			;   hl file id 
01e0			; 
01e0			;  returns in hl the number of blocks 
01e0			 
01e0			storage_file_size: 
01e0 5d				ld e, l 
01e1 16 00			ld d, 0 
01e3 21 40 00			ld hl, STORE_BLOCK_PHY 
01e6					if DEBUG_FORTH_WORDS 
01e6						DMARK "SIZ" 
01e6 f5				push af  
01e7 3a fb 01			ld a, (.dmark)  
01ea 32 7a ee			ld (debug_mark),a  
01ed 3a fc 01			ld a, (.dmark+1)  
01f0 32 7b ee			ld (debug_mark+1),a  
01f3 3a fd 01			ld a, (.dmark+2)  
01f6 32 7c ee			ld (debug_mark+2),a  
01f9 18 03			jr .pastdmark  
01fb ..			.dmark: db "SIZ"  
01fe f1			.pastdmark: pop af  
01ff			endm  
# End of macro DMARK
01ff						CALLMONITOR 
01ff cd 77 14			call break_point_state  
0202				endm  
# End of macro CALLMONITOR
0202					endif 
0202 cd d6 04			call storage_findnextid 
0205			 
0205 cd f2 0b			call ishlzero 
0208			;	ld a, l 
0208			;	add h 
0208			;	cp 0 
0208 c8				ret z			; block not found so EOF 
0209			 
0209 11 65 eb			ld de, store_page 
020c cd b1 01			call storage_read_block 
020f			 
020f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
0212 6f				ld l, a 
0213 26 00			ld h, 0 
0215 c9			 	ret 
0216			 
0216			 
0216			; Write Block 
0216			; ----------- 
0216			; 
0216			; With current bank 
0216			;  
0216			; Get block number to write 
0216			; Write physical blocks starting at start block from buffer 
0216			  
0216			storage_write_block: 
0216				; TODO bank selection 
0216			 
0216				; for each of the physical blocks read it into the buffer 
0216 06 40			ld b, STORE_BLOCK_PHY 
0218			 
0218				if DEBUG_STORESE 
0218					DMARK "SWB" 
0218 f5				push af  
0219 3a 2d 02			ld a, (.dmark)  
021c 32 7a ee			ld (debug_mark),a  
021f 3a 2e 02			ld a, (.dmark+1)  
0222 32 7b ee			ld (debug_mark+1),a  
0225 3a 2f 02			ld a, (.dmark+2)  
0228 32 7c ee			ld (debug_mark+2),a  
022b 18 03			jr .pastdmark  
022d ..			.dmark: db "SWB"  
0230 f1			.pastdmark: pop af  
0231			endm  
# End of macro DMARK
0231			 
0231					;push af 
0231					;ld a, 'W' 
0231					;ld (debug_mark),a 
0231					;pop af 
0231					CALLMONITOR 
0231 cd 77 14			call break_point_state  
0234				endm  
# End of macro CALLMONITOR
0234				endif 
0234			 
0234			; might not be working 
0234			;	call se_writepage 
0234			 
0234			;	ret 
0234			; 
0234			 
0234			 
0234			 
0234			.wl1:    
0234			 
0234				; read physical block at hl into de 
0234			        ; increment hl and de to next read position on exit 
0234			 
0234 e5				push hl 
0235 d5				push de	 
0236 c5				push bc 
0237 1a				ld a,(de) 
0238				;if DEBUG_STORESE 
0238			;		push af 
0238			;		ld a, 'W' 
0238			;		ld (debug_mark),a 
0238			;		pop af 
0238			;		CALLMONITOR 
0238			;	endif 
0238 cd af 01			call se_writebyte 
023b			;	call delay250ms 
023b 00				nop 
023c 00				nop 
023d 00				nop 
023e			;	if DEBUG_STORESE 
023e			;		push af 
023e			;		ld a, 'w' 
023e			;		ld (debug_mark),a 
023e			;		pop af 
023e			;		CALLMONITOR 
023e			;	endif 
023e c1				pop bc 
023f d1				pop de 
0240 e1				pop hl 
0241 23				inc hl 
0242 13				inc de 
0243			 
0243			 
0243 10 ef			djnz .wl1 
0245			 
0245				if DEBUG_STORESE 
0245					DMARK "SW2" 
0245 f5				push af  
0246 3a 5a 02			ld a, (.dmark)  
0249 32 7a ee			ld (debug_mark),a  
024c 3a 5b 02			ld a, (.dmark+1)  
024f 32 7b ee			ld (debug_mark+1),a  
0252 3a 5c 02			ld a, (.dmark+2)  
0255 32 7c ee			ld (debug_mark+2),a  
0258 18 03			jr .pastdmark  
025a ..			.dmark: db "SW2"  
025d f1			.pastdmark: pop af  
025e			endm  
# End of macro DMARK
025e			 
025e					;push af 
025e					;ld a, 'W' 
025e					;ld (debug_mark),a 
025e					;pop af 
025e					CALLMONITOR 
025e cd 77 14			call break_point_state  
0261				endm  
# End of macro CALLMONITOR
0261				endif 
0261 c9				ret	 
0262			 
0262			; Init bank 
0262			; --------- 
0262			; 
0262			; With current bank 
0262			; 
0262			; Setup block 0 config 
0262			;     Set 0 file id counter 
0262			;     Set formatted byte pattern 
0262			;     Zero out bank label 
0262			;      
0262			; For every logical block write 0-1 byte as null 
0262			 
0262			storage_get_block_0: 
0262			 
0262				; TODO check presence 
0262			 
0262				; get block 0 config 
0262			 
0262 21 00 00			ld hl, 0 
0265 11 65 eb			ld de, store_page 
0268 cd b1 01			call storage_read_block 
026b			 
026b				if DEBUG_STORESE 
026b					DMARK "SB0" 
026b f5				push af  
026c 3a 80 02			ld a, (.dmark)  
026f 32 7a ee			ld (debug_mark),a  
0272 3a 81 02			ld a, (.dmark+1)  
0275 32 7b ee			ld (debug_mark+1),a  
0278 3a 82 02			ld a, (.dmark+2)  
027b 32 7c ee			ld (debug_mark+2),a  
027e 18 03			jr .pastdmark  
0280 ..			.dmark: db "SB0"  
0283 f1			.pastdmark: pop af  
0284			endm  
# End of macro DMARK
0284 11 65 eb				ld de, store_page 
0287			;		push af 
0287			;		ld a, 'i' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287					CALLMONITOR 
0287 cd 77 14			call break_point_state  
028a				endm  
# End of macro CALLMONITOR
028a				endif 
028a			 
028a				; is this area formatted? 
028a			 
028a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
028a 2a 66 eb			ld hl, (store_page+1) 
028d 3e 80			ld a,0x80 
028f bd				cp l 
0290 20 22			jr nz, .ininotformatted 
0292				; do a double check 
0292 3e 27			ld a, 0x27 
0294 bc				cp h 
0295 20 1d			jr nz, .ininotformatted 
0297			 
0297				; formatted then 
0297			 
0297				if DEBUG_STORESE 
0297					DMARK "SB1" 
0297 f5				push af  
0298 3a ac 02			ld a, (.dmark)  
029b 32 7a ee			ld (debug_mark),a  
029e 3a ad 02			ld a, (.dmark+1)  
02a1 32 7b ee			ld (debug_mark+1),a  
02a4 3a ae 02			ld a, (.dmark+2)  
02a7 32 7c ee			ld (debug_mark+2),a  
02aa 18 03			jr .pastdmark  
02ac ..			.dmark: db "SB1"  
02af f1			.pastdmark: pop af  
02b0			endm  
# End of macro DMARK
02b0					;push af 
02b0					;ld a, 'I' 
02b0					;ld (debug_mark),a 
02b0					;pop af 
02b0					CALLMONITOR 
02b0 cd 77 14			call break_point_state  
02b3				endm  
# End of macro CALLMONITOR
02b3				endif 
02b3 c9				ret 
02b4			 
02b4			.ininotformatted: 
02b4				; bank not formatted so poke various bits to make sure 
02b4			 
02b4				if DEBUG_STORESE 
02b4					DMARK "SB2" 
02b4 f5				push af  
02b5 3a c9 02			ld a, (.dmark)  
02b8 32 7a ee			ld (debug_mark),a  
02bb 3a ca 02			ld a, (.dmark+1)  
02be 32 7b ee			ld (debug_mark+1),a  
02c1 3a cb 02			ld a, (.dmark+2)  
02c4 32 7c ee			ld (debug_mark+2),a  
02c7 18 03			jr .pastdmark  
02c9 ..			.dmark: db "SB2"  
02cc f1			.pastdmark: pop af  
02cd			endm  
# End of macro DMARK
02cd					;push af 
02cd					;ld a, 'f' 
02cd					;ld (debug_mark),a 
02cd					;pop af 
02cd					CALLMONITOR 
02cd cd 77 14			call break_point_state  
02d0				endm  
# End of macro CALLMONITOR
02d0				endif 
02d0			 
02d0 cd d1 08			call storage_clear_page 
02d3			 
02d3 21 65 eb			ld hl, store_page 
02d6 3e 00			ld a, 0 
02d8				 
02d8 77				ld (hl),a   ; reset file counter 
02d9			 
02d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02dc 22 66 eb		 	ld (store_page+1), hl	 
02df			 
02df				; set default label 
02df			 
02df 21 7b 03			ld hl, .defaultbanklabl 
02e2 11 68 eb		 	ld de, store_page+3 
02e5 01 0f 00			ld bc, 15 
02e8 ed b0			ldir 
02ea			 
02ea				; Append the current bank id 
02ea 21 71 eb			ld hl, store_page+3+9 
02ed 3a 4a eb			ld a, (spi_device_id) 
02f0 77				ld (hl), a 
02f1			 
02f1				; save default page 0 
02f1			 
02f1 21 00 00			ld hl, 0 
02f4 11 65 eb			ld de, store_page 
02f7				if DEBUG_STORESE 
02f7					DMARK "SB3" 
02f7 f5				push af  
02f8 3a 0c 03			ld a, (.dmark)  
02fb 32 7a ee			ld (debug_mark),a  
02fe 3a 0d 03			ld a, (.dmark+1)  
0301 32 7b ee			ld (debug_mark+1),a  
0304 3a 0e 03			ld a, (.dmark+2)  
0307 32 7c ee			ld (debug_mark+2),a  
030a 18 03			jr .pastdmark  
030c ..			.dmark: db "SB3"  
030f f1			.pastdmark: pop af  
0310			endm  
# End of macro DMARK
0310			;		push af 
0310			;		ld a, 'F' 
0310			;		ld (debug_mark),a 
0310			;		pop af 
0310					CALLMONITOR 
0310 cd 77 14			call break_point_state  
0313				endm  
# End of macro CALLMONITOR
0313				endif 
0313 cd 16 02			call storage_write_block 
0316				if DEBUG_STORESE 
0316					DMARK "SB4" 
0316 f5				push af  
0317 3a 2b 03			ld a, (.dmark)  
031a 32 7a ee			ld (debug_mark),a  
031d 3a 2c 03			ld a, (.dmark+1)  
0320 32 7b ee			ld (debug_mark+1),a  
0323 3a 2d 03			ld a, (.dmark+2)  
0326 32 7c ee			ld (debug_mark+2),a  
0329 18 03			jr .pastdmark  
032b ..			.dmark: db "SB4"  
032e f1			.pastdmark: pop af  
032f			endm  
# End of macro DMARK
032f			;		push af 
032f			;		ld a, '>' 
032f			;		ld (debug_mark),a 
032f			;		pop af 
032f					CALLMONITOR 
032f cd 77 14			call break_point_state  
0332				endm  
# End of macro CALLMONITOR
0332				endif 
0332			 
0332 00				nop 
0333 00				nop 
0334 00				nop 
0335			 
0335				; now set 0 in every page to mark as a free block 
0335			 
0335 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0337 21 40 00			ld hl, STORE_BLOCK_PHY 
033a			 
033a 3e 00		.setmark1:   	ld a,0 
033c e5					push hl 
033d c5					push bc 
033e cd af 01				call se_writebyte 
0341 3e 0a			ld a, 10 
0343 cd f3 08			call aDelayInMS 
0346 23				inc hl 
0347 cd af 01				call se_writebyte 
034a 3e 0a			ld a, 10 
034c cd f3 08			call aDelayInMS 
034f 2b				dec hl 
0350 c1					pop bc 
0351 e1					pop hl 
0352 3e 40				ld a, STORE_BLOCK_PHY 
0354 cd c9 0b				call addatohl 
0357 10 e1				djnz .setmark1 
0359			 
0359 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
035b 3e 00		.setmark2:   	ld a,0 
035d e5					push hl 
035e c5					push bc 
035f cd af 01				call se_writebyte 
0362 3e 0a			ld a, 10 
0364 cd f3 08			call aDelayInMS 
0367 23				inc hl 
0368 cd af 01				call se_writebyte 
036b 3e 0a			ld a, 10 
036d cd f3 08			call aDelayInMS 
0370 2b				dec hl 
0371 c1					pop bc 
0372 e1					pop hl 
0373 3e 40				ld a, STORE_BLOCK_PHY 
0375 cd c9 0b				call addatohl 
0378 10 e1				djnz .setmark2 
037a			 
037a					 
037a			 
037a			 
037a c9				ret 
037b			 
037b			 
037b			 
037b			 
037b .. 00		.defaultbanklabl:   db "BankLabel_",0 
0386			 
0386			 
0386			 
0386			; Label Bank 
0386			; ---------- 
0386			; 
0386			; With current bank 
0386			; Read block 0 
0386			; Set label 
0386			; Write block 0 
0386			 
0386			; label str pointer in hl 
0386			 
0386			storage_label:     
0386			 
0386				if DEBUG_STORESE 
0386					DMARK "LBL" 
0386 f5				push af  
0387 3a 9b 03			ld a, (.dmark)  
038a 32 7a ee			ld (debug_mark),a  
038d 3a 9c 03			ld a, (.dmark+1)  
0390 32 7b ee			ld (debug_mark+1),a  
0393 3a 9d 03			ld a, (.dmark+2)  
0396 32 7c ee			ld (debug_mark+2),a  
0399 18 03			jr .pastdmark  
039b ..			.dmark: db "LBL"  
039e f1			.pastdmark: pop af  
039f			endm  
# End of macro DMARK
039f					CALLMONITOR 
039f cd 77 14			call break_point_state  
03a2				endm  
# End of macro CALLMONITOR
03a2				endif 
03a2			 
03a2 e5				push hl 
03a3			 
03a3 cd 62 02			call storage_get_block_0 
03a6			 
03a6				; set default label 
03a6			 
03a6 e1				pop hl 
03a7			 
03a7 11 68 eb		 	ld de, store_page+3 
03aa 01 0f 00			ld bc, 15 
03ad				if DEBUG_STORESE 
03ad					DMARK "LB3" 
03ad f5				push af  
03ae 3a c2 03			ld a, (.dmark)  
03b1 32 7a ee			ld (debug_mark),a  
03b4 3a c3 03			ld a, (.dmark+1)  
03b7 32 7b ee			ld (debug_mark+1),a  
03ba 3a c4 03			ld a, (.dmark+2)  
03bd 32 7c ee			ld (debug_mark+2),a  
03c0 18 03			jr .pastdmark  
03c2 ..			.dmark: db "LB3"  
03c5 f1			.pastdmark: pop af  
03c6			endm  
# End of macro DMARK
03c6					CALLMONITOR 
03c6 cd 77 14			call break_point_state  
03c9				endm  
# End of macro CALLMONITOR
03c9				endif 
03c9 ed b0			ldir 
03cb				; save default page 0 
03cb			 
03cb 21 00 00			ld hl, 0 
03ce 11 65 eb			ld de, store_page 
03d1				if DEBUG_STORESE 
03d1					DMARK "LBW" 
03d1 f5				push af  
03d2 3a e6 03			ld a, (.dmark)  
03d5 32 7a ee			ld (debug_mark),a  
03d8 3a e7 03			ld a, (.dmark+1)  
03db 32 7b ee			ld (debug_mark+1),a  
03de 3a e8 03			ld a, (.dmark+2)  
03e1 32 7c ee			ld (debug_mark+2),a  
03e4 18 03			jr .pastdmark  
03e6 ..			.dmark: db "LBW"  
03e9 f1			.pastdmark: pop af  
03ea			endm  
# End of macro DMARK
03ea					CALLMONITOR 
03ea cd 77 14			call break_point_state  
03ed				endm  
# End of macro CALLMONITOR
03ed				endif 
03ed cd 16 02			call storage_write_block 
03f0			 
03f0 c9				ret 
03f1			 
03f1			 
03f1			 
03f1			; Read Block 0 - Config 
03f1			; --------------------- 
03f1			; 
03f1			; With current bank 
03f1			; Call presence test 
03f1			;    If not present format/init bank  
03f1			; Read block 0  
03f1			;  
03f1			 
03f1			 
03f1			; Dir 
03f1			; --- 
03f1			; 
03f1			; With current bank 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block read byte 2 
03f1			;      if first block of file 
03f1			;         Display file name 
03f1			;         Display type flags for file 
03f1			;        
03f1			 
03f1			; moving to words as this requires stack control 
03f1			 
03f1			 
03f1			; Delete File 
03f1			; ----------- 
03f1			; 
03f1			; With current bank 
03f1			; 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block file id 
03f1			;      If first block of file and dont have file id 
03f1			;         if file to delete 
03f1			;         Save file id 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			;      If file id is one saved 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			 
03f1			storage_erase: 
03f1			 
03f1				; hl contains the file id 
03f1			 
03f1 5d				ld e, l 
03f2 16 00			ld d, 0 
03f4 21 40 00			ld hl, STORE_BLOCK_PHY 
03f7					if DEBUG_FORTH_WORDS 
03f7						DMARK "ERA" 
03f7 f5				push af  
03f8 3a 0c 04			ld a, (.dmark)  
03fb 32 7a ee			ld (debug_mark),a  
03fe 3a 0d 04			ld a, (.dmark+1)  
0401 32 7b ee			ld (debug_mark+1),a  
0404 3a 0e 04			ld a, (.dmark+2)  
0407 32 7c ee			ld (debug_mark+2),a  
040a 18 03			jr .pastdmark  
040c ..			.dmark: db "ERA"  
040f f1			.pastdmark: pop af  
0410			endm  
# End of macro DMARK
0410						CALLMONITOR 
0410 cd 77 14			call break_point_state  
0413				endm  
# End of macro CALLMONITOR
0413					endif 
0413 cd d6 04			call storage_findnextid 
0416 cd f2 0b			call ishlzero 
0419 c8				ret z 
041a			 
041a e5				push hl 
041b			 
041b				; TODO check file not found 
041b			 
041b 11 65 eb			ld de, store_page 
041e cd b1 01			call storage_read_block 
0421			 
0421					if DEBUG_FORTH_WORDS 
0421						DMARK "ER1" 
0421 f5				push af  
0422 3a 36 04			ld a, (.dmark)  
0425 32 7a ee			ld (debug_mark),a  
0428 3a 37 04			ld a, (.dmark+1)  
042b 32 7b ee			ld (debug_mark+1),a  
042e 3a 38 04			ld a, (.dmark+2)  
0431 32 7c ee			ld (debug_mark+2),a  
0434 18 03			jr .pastdmark  
0436 ..			.dmark: db "ER1"  
0439 f1			.pastdmark: pop af  
043a			endm  
# End of macro DMARK
043a						CALLMONITOR 
043a cd 77 14			call break_point_state  
043d				endm  
# End of macro CALLMONITOR
043d					endif 
043d 3a 65 eb			ld a, (store_page)	; get file id 
0440 32 5e eb			ld (store_tmpid), a 
0443			 
0443 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
0446 32 5d eb			ld (store_tmpext), a 
0449			 
0449				; wipe file header 
0449			 
0449 e1				pop hl 
044a 3e 00			ld a, 0 
044c 32 65 eb			ld (store_page), a 
044f 32 66 eb			ld (store_page+1),a 
0452 11 65 eb			ld de, store_page 
0455					if DEBUG_FORTH_WORDS 
0455						DMARK "ER2" 
0455 f5				push af  
0456 3a 6a 04			ld a, (.dmark)  
0459 32 7a ee			ld (debug_mark),a  
045c 3a 6b 04			ld a, (.dmark+1)  
045f 32 7b ee			ld (debug_mark+1),a  
0462 3a 6c 04			ld a, (.dmark+2)  
0465 32 7c ee			ld (debug_mark+2),a  
0468 18 03			jr .pastdmark  
046a ..			.dmark: db "ER2"  
046d f1			.pastdmark: pop af  
046e			endm  
# End of macro DMARK
046e						CALLMONITOR 
046e cd 77 14			call break_point_state  
0471				endm  
# End of macro CALLMONITOR
0471					endif 
0471 cd 16 02			call storage_write_block 
0474			 
0474			 
0474				; wipe file extents 
0474			 
0474 3a 5d eb			ld a, (store_tmpext) 
0477 47				ld b, a 
0478			 
0478			.eraext:	  
0478 c5				push bc 
0479			 
0479 21 40 00			ld hl, STORE_BLOCK_PHY 
047c 3a 5e eb			ld a,(store_tmpid) 
047f 5f				ld e, a 
0480 50				ld d, b	 
0481					if DEBUG_FORTH_WORDS 
0481						DMARK "ER3" 
0481 f5				push af  
0482 3a 96 04			ld a, (.dmark)  
0485 32 7a ee			ld (debug_mark),a  
0488 3a 97 04			ld a, (.dmark+1)  
048b 32 7b ee			ld (debug_mark+1),a  
048e 3a 98 04			ld a, (.dmark+2)  
0491 32 7c ee			ld (debug_mark+2),a  
0494 18 03			jr .pastdmark  
0496 ..			.dmark: db "ER3"  
0499 f1			.pastdmark: pop af  
049a			endm  
# End of macro DMARK
049a						CALLMONITOR 
049a cd 77 14			call break_point_state  
049d				endm  
# End of macro CALLMONITOR
049d					endif 
049d cd d6 04			call storage_findnextid 
04a0			 
04a0 e5				push hl 
04a1 11 65 eb			ld de, store_page 
04a4 cd b1 01			call storage_read_block 
04a7			 
04a7				; free block	 
04a7			 
04a7 3e 00			ld a, 0 
04a9 32 65 eb			ld (store_page), a 
04ac 32 66 eb			ld (store_page+1),a 
04af 11 65 eb			ld de, store_page 
04b2 e1				pop hl 
04b3					if DEBUG_FORTH_WORDS 
04b3						DMARK "ER4" 
04b3 f5				push af  
04b4 3a c8 04			ld a, (.dmark)  
04b7 32 7a ee			ld (debug_mark),a  
04ba 3a c9 04			ld a, (.dmark+1)  
04bd 32 7b ee			ld (debug_mark+1),a  
04c0 3a ca 04			ld a, (.dmark+2)  
04c3 32 7c ee			ld (debug_mark+2),a  
04c6 18 03			jr .pastdmark  
04c8 ..			.dmark: db "ER4"  
04cb f1			.pastdmark: pop af  
04cc			endm  
# End of macro DMARK
04cc						CALLMONITOR 
04cc cd 77 14			call break_point_state  
04cf				endm  
# End of macro CALLMONITOR
04cf					endif 
04cf cd 16 02			call storage_write_block 
04d2			 
04d2 c1				pop bc 
04d3 10 a3			djnz .eraext 
04d5			 
04d5 c9				ret 
04d6			 
04d6			 
04d6			; Find Free Block 
04d6			; --------------- 
04d6			; 
04d6			; With current bank 
04d6			;  
04d6			; From given starting logical block 
04d6			;    Read block  
04d6			;    If no file id 
04d6			;         Return block id 
04d6			 
04d6			 
04d6			; hl starting page number 
04d6			; hl contains free page number or zero if no pages free 
04d6			; e contains the file id to locate 
04d6			; d contains the block number 
04d6			 
04d6			; TODO change to find file id and use zero for free block 
04d6			 
04d6			storage_findnextid: 
04d6			 
04d6				; now locate first 0 page to mark as a free block 
04d6			 
04d6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04d8			;	ld hl, STORE_BLOCK_PHY 
04d8			 
04d8					if DEBUG_FORTH_WORDS 
04d8					DMARK "FNI" 
04d8 f5				push af  
04d9 3a ed 04			ld a, (.dmark)  
04dc 32 7a ee			ld (debug_mark),a  
04df 3a ee 04			ld a, (.dmark+1)  
04e2 32 7b ee			ld (debug_mark+1),a  
04e5 3a ef 04			ld a, (.dmark+2)  
04e8 32 7c ee			ld (debug_mark+2),a  
04eb 18 03			jr .pastdmark  
04ed ..			.dmark: db "FNI"  
04f0 f1			.pastdmark: pop af  
04f1			endm  
# End of macro DMARK
04f1						CALLMONITOR 
04f1 cd 77 14			call break_point_state  
04f4				endm  
# End of macro CALLMONITOR
04f4					endif 
04f4			.ff1:   	 
04f4 e5					push hl 
04f5 c5					push bc 
04f6 d5					push de 
04f7 cd ae 01				call se_readbyte 
04fa 5f					ld e,a 
04fb 23					inc hl 
04fc cd ae 01				call se_readbyte 
04ff 57					ld d, a 
0500 e1					pop hl 
0501 e5					push hl 
0502 cd e7 0b				call cmp16 
0505 28 49				jr z, .fffound 
0507			 
0507 d1					pop de 
0508 c1					pop bc 
0509 e1					pop hl 
050a			 
050a					; is found? 
050a					;cp e 
050a					;ret z 
050a			 
050a 3e 40				ld a, STORE_BLOCK_PHY 
050c cd c9 0b				call addatohl 
050f 10 e3				djnz .ff1 
0511			 
0511 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0513			.ff2:   	 
0513			 
0513 e5					push hl 
0514 c5					push bc 
0515 d5					push de 
0516 cd ae 01				call se_readbyte 
0519 5f					ld e,a 
051a 23					inc hl 
051b cd ae 01				call se_readbyte 
051e 57					ld d, a 
051f			 
051f e1					pop hl 
0520 e5					push hl 
0521 cd e7 0b				call cmp16 
0524 28 2a				jr z, .fffound 
0526			 
0526 d1					pop de 
0527 c1					pop bc 
0528 e1					pop hl 
0529					; is found? 
0529					;cp e 
0529					;ret z 
0529			 
0529 3e 40				ld a, STORE_BLOCK_PHY 
052b cd c9 0b				call addatohl 
052e 10 e3				djnz .ff2 
0530			 
0530			 
0530					if DEBUG_FORTH_WORDS 
0530					DMARK "FN-" 
0530 f5				push af  
0531 3a 45 05			ld a, (.dmark)  
0534 32 7a ee			ld (debug_mark),a  
0537 3a 46 05			ld a, (.dmark+1)  
053a 32 7b ee			ld (debug_mark+1),a  
053d 3a 47 05			ld a, (.dmark+2)  
0540 32 7c ee			ld (debug_mark+2),a  
0543 18 03			jr .pastdmark  
0545 ..			.dmark: db "FN-"  
0548 f1			.pastdmark: pop af  
0549			endm  
# End of macro DMARK
0549					;	push af 
0549					;	ld a, 'n' 
0549					;	ld (debug_mark),a 
0549					;	pop af 
0549						CALLMONITOR 
0549 cd 77 14			call break_point_state  
054c				endm  
# End of macro CALLMONITOR
054c					endif 
054c				; no free marks! 
054c 21 00 00				ld hl, 0 
054f c9				ret 
0550			.fffound: 
0550				 
0550			 
0550 d1					pop de 
0551 c1					pop bc 
0552 e1					pop hl 
0553					if DEBUG_FORTH_WORDS 
0553					DMARK "FNF" 
0553 f5				push af  
0554 3a 68 05			ld a, (.dmark)  
0557 32 7a ee			ld (debug_mark),a  
055a 3a 69 05			ld a, (.dmark+1)  
055d 32 7b ee			ld (debug_mark+1),a  
0560 3a 6a 05			ld a, (.dmark+2)  
0563 32 7c ee			ld (debug_mark+2),a  
0566 18 03			jr .pastdmark  
0568 ..			.dmark: db "FNF"  
056b f1			.pastdmark: pop af  
056c			endm  
# End of macro DMARK
056c					;	push af 
056c					;	ld a, 'n' 
056c					;	ld (debug_mark),a 
056c					;	pop af 
056c						CALLMONITOR 
056c cd 77 14			call break_point_state  
056f				endm  
# End of macro CALLMONITOR
056f					endif 
056f c9				ret 
0570			 
0570			 
0570			 
0570			; Free Space 
0570			; ---------- 
0570			; 
0570			; With current bank 
0570			; 
0570			; Set block count to zero 
0570			; Starting with first logical block 
0570			;      Find free block  
0570			;      If block id given, increment block count 
0570			; 
0570			;  
0570			 
0570			 
0570			; hl contains count of free blocks 
0570			 
0570			storage_freeblocks: 
0570			 
0570				; now locate first 0 page to mark as a free block 
0570			 
0570 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0572 21 40 00			ld hl, STORE_BLOCK_PHY 
0575 11 00 00			ld de, 0 
0578			 
0578			.fb1:   	 
0578 e5					push hl 
0579 c5					push bc 
057a d5					push de 
057b cd ae 01				call se_readbyte 
057e d1					pop de 
057f c1					pop bc 
0580 e1					pop hl 
0581			 
0581					; is free? 
0581 fe 00				cp 0 
0583 20 01				jr nz, .ff1cont 
0585 13					inc de 
0586			 
0586			.ff1cont: 
0586			 
0586			 
0586 3e 40				ld a, STORE_BLOCK_PHY 
0588 cd c9 0b				call addatohl 
058b 10 eb				djnz .fb1 
058d			 
058d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
058f			.fb2:   	 
058f e5					push hl 
0590 c5					push bc 
0591 d5					push de 
0592 cd ae 01				call se_readbyte 
0595 d1					pop de 
0596 c1					pop bc 
0597 e1					pop hl 
0598			 
0598					; is free? 
0598 fe 00				cp 0 
059a 20 01				jr nz, .ff2cont 
059c 13					inc de 
059d			 
059d			.ff2cont: 
059d			 
059d 3e 40				ld a, STORE_BLOCK_PHY 
059f cd c9 0b				call addatohl 
05a2 10 eb				djnz .fb2 
05a4			 
05a4 eb				ex de, hl 
05a5 c9				ret 
05a6			 
05a6			; Get File ID 
05a6			; ----------- 
05a6			; 
05a6			; With current bank 
05a6			;  
05a6			; Load Block 0 Config 
05a6			; Get max file id number 
05a6			; For each logical block 
05a6			;    Read block file id 
05a6			;      If first block of file and dont have file id 
05a6			;         if file get id and exit 
05a6			 
05a6			 
05a6			 
05a6			 
05a6			; Create File 
05a6			; ----------- 
05a6			; 
05a6			; With current bank  
05a6			; Load Block 0 Config 
05a6			; Get max file id number 
05a6			; Increment file id number 
05a6			; Save Config 
05a6			; Find free block 
05a6			; Set buffer with file name and file id 
05a6			; Write buffer to free block  
05a6			 
05a6			 
05a6			; hl point to file name 
05a6			; hl returns file id 
05a6			 
05a6			; file format: 
05a6			; byte 0 - file id 
05a6			; byte 1 - extent number 
05a6			; byte 2-> data 
05a6			 
05a6			; format for extent number 0: 
05a6			; 
05a6			; byte 0 - file id 
05a6			; byte 1 - extent 0 
05a6			; byte 2 - extent count 
05a6			; byte 3 -> file name and meta data 
05a6			 
05a6			 
05a6			storage_create: 
05a6				if DEBUG_STORESE 
05a6					DMARK "SCR" 
05a6 f5				push af  
05a7 3a bb 05			ld a, (.dmark)  
05aa 32 7a ee			ld (debug_mark),a  
05ad 3a bc 05			ld a, (.dmark+1)  
05b0 32 7b ee			ld (debug_mark+1),a  
05b3 3a bd 05			ld a, (.dmark+2)  
05b6 32 7c ee			ld (debug_mark+2),a  
05b9 18 03			jr .pastdmark  
05bb ..			.dmark: db "SCR"  
05be f1			.pastdmark: pop af  
05bf			endm  
# End of macro DMARK
05bf					CALLMONITOR 
05bf cd 77 14			call break_point_state  
05c2				endm  
# End of macro CALLMONITOR
05c2				endif 
05c2			 
05c2 e5				push hl		; save file name pointer 
05c3			 
05c3 cd 62 02			call storage_get_block_0 
05c6			 
05c6 3a 65 eb			ld a,(store_page)	; get current file id 
05c9 3c				inc a 
05ca 32 65 eb			ld (store_page),a 
05cd				 
05cd 32 5e eb			ld (store_tmpid),a			; save id 
05d0			 
05d0 21 00 00			ld hl, 0 
05d3 11 65 eb			ld de, store_page 
05d6				if DEBUG_STORESE 
05d6					DMARK "SCw" 
05d6 f5				push af  
05d7 3a eb 05			ld a, (.dmark)  
05da 32 7a ee			ld (debug_mark),a  
05dd 3a ec 05			ld a, (.dmark+1)  
05e0 32 7b ee			ld (debug_mark+1),a  
05e3 3a ed 05			ld a, (.dmark+2)  
05e6 32 7c ee			ld (debug_mark+2),a  
05e9 18 03			jr .pastdmark  
05eb ..			.dmark: db "SCw"  
05ee f1			.pastdmark: pop af  
05ef			endm  
# End of macro DMARK
05ef					CALLMONITOR 
05ef cd 77 14			call break_point_state  
05f2				endm  
# End of macro CALLMONITOR
05f2				endif 
05f2 cd 16 02			call storage_write_block	 ; save update 
05f5			 
05f5				if DEBUG_STORESE 
05f5 11 65 eb				ld de, store_page 
05f8					DMARK "SCC" 
05f8 f5				push af  
05f9 3a 0d 06			ld a, (.dmark)  
05fc 32 7a ee			ld (debug_mark),a  
05ff 3a 0e 06			ld a, (.dmark+1)  
0602 32 7b ee			ld (debug_mark+1),a  
0605 3a 0f 06			ld a, (.dmark+2)  
0608 32 7c ee			ld (debug_mark+2),a  
060b 18 03			jr .pastdmark  
060d ..			.dmark: db "SCC"  
0610 f1			.pastdmark: pop af  
0611			endm  
# End of macro DMARK
0611					CALLMONITOR 
0611 cd 77 14			call break_point_state  
0614				endm  
# End of macro CALLMONITOR
0614				endif 
0614				;  
0614				 
0614 21 40 00			ld hl, STORE_BLOCK_PHY 
0617 11 00 00			ld de, 0 
061a cd d6 04			call storage_findnextid 
061d			 
061d 22 4f eb			ld (store_tmppageid), hl    ; save page to use  
0620			 
0620				; TODO detect 0 = no spare blocks 
0620			 
0620				; hl now contains the free page to use for the file header page 
0620			 
0620				if DEBUG_STORESE 
0620				DMARK "SCF" 
0620 f5				push af  
0621 3a 35 06			ld a, (.dmark)  
0624 32 7a ee			ld (debug_mark),a  
0627 3a 36 06			ld a, (.dmark+1)  
062a 32 7b ee			ld (debug_mark+1),a  
062d 3a 37 06			ld a, (.dmark+2)  
0630 32 7c ee			ld (debug_mark+2),a  
0633 18 03			jr .pastdmark  
0635 ..			.dmark: db "SCF"  
0638 f1			.pastdmark: pop af  
0639			endm  
# End of macro DMARK
0639					CALLMONITOR 
0639 cd 77 14			call break_point_state  
063c				endm  
# End of macro CALLMONITOR
063c				endif 
063c			 
063c 22 4f eb			ld (store_tmppageid), hl 
063f				 
063f 3a 5e eb			ld a,(store_tmpid)    ; get file id 
0642			;	ld a, (store_filecache)			; save to cache 
0642			 
0642 32 65 eb			ld (store_page),a    ; set page id 
0645 3e 00			ld a, 0			 ; extent 0 is file header 
0647 32 66 eb			ld (store_page+1), a   ; set file extent 
064a			 
064a 32 67 eb			ld (store_page+2), a   ; extent count for the file 
064d			 
064d			;	inc hl 		; init block 0 of file 
064d			;	inc hl   		; skip file and extent id 
064d			 ;       ld a, 0 
064d			;	ld (hl),a 
064d			;	ld a, (store_filecache+1)  	; save to cache 
064d			 
064d			;	inc hl    ; file name 
064d				 
064d				 
064d 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
0650				if DEBUG_STORESE 
0650					DMARK "SCc" 
0650 f5				push af  
0651 3a 65 06			ld a, (.dmark)  
0654 32 7a ee			ld (debug_mark),a  
0657 3a 66 06			ld a, (.dmark+1)  
065a 32 7b ee			ld (debug_mark+1),a  
065d 3a 67 06			ld a, (.dmark+2)  
0660 32 7c ee			ld (debug_mark+2),a  
0663 18 03			jr .pastdmark  
0665 ..			.dmark: db "SCc"  
0668 f1			.pastdmark: pop af  
0669			endm  
# End of macro DMARK
0669					CALLMONITOR 
0669 cd 77 14			call break_point_state  
066c				endm  
# End of macro CALLMONITOR
066c				endif 
066c e1				pop hl    ; get zero term string 
066d e5				push hl 
066e 3e 00			ld a, 0 
0670 cd 32 10			call strlent 
0673 23				inc hl   ; cover zero term 
0674 06 00			ld b,0 
0676 4d				ld c,l 
0677 e1				pop hl 
0678				;ex de, hl 
0678				if DEBUG_STORESE 
0678					DMARK "SCa" 
0678 f5				push af  
0679 3a 8d 06			ld a, (.dmark)  
067c 32 7a ee			ld (debug_mark),a  
067f 3a 8e 06			ld a, (.dmark+1)  
0682 32 7b ee			ld (debug_mark+1),a  
0685 3a 8f 06			ld a, (.dmark+2)  
0688 32 7c ee			ld (debug_mark+2),a  
068b 18 03			jr .pastdmark  
068d ..			.dmark: db "SCa"  
0690 f1			.pastdmark: pop af  
0691			endm  
# End of macro DMARK
0691					;push af 
0691					;ld a, 'a' 
0691					;ld (debug_mark),a 
0691					;pop af 
0691					CALLMONITOR 
0691 cd 77 14			call break_point_state  
0694				endm  
# End of macro CALLMONITOR
0694				endif 
0694 ed b0			ldir    ; copy zero term string 
0696				if DEBUG_STORESE 
0696					DMARK "SCA" 
0696 f5				push af  
0697 3a ab 06			ld a, (.dmark)  
069a 32 7a ee			ld (debug_mark),a  
069d 3a ac 06			ld a, (.dmark+1)  
06a0 32 7b ee			ld (debug_mark+1),a  
06a3 3a ad 06			ld a, (.dmark+2)  
06a6 32 7c ee			ld (debug_mark+2),a  
06a9 18 03			jr .pastdmark  
06ab ..			.dmark: db "SCA"  
06ae f1			.pastdmark: pop af  
06af			endm  
# End of macro DMARK
06af					CALLMONITOR 
06af cd 77 14			call break_point_state  
06b2				endm  
# End of macro CALLMONITOR
06b2				endif 
06b2			 
06b2				; write file header page 
06b2			 
06b2 2a 4f eb			ld hl,(store_tmppageid) 
06b5 11 65 eb			ld de, store_page 
06b8				if DEBUG_STORESE 
06b8					DMARK "SCb" 
06b8 f5				push af  
06b9 3a cd 06			ld a, (.dmark)  
06bc 32 7a ee			ld (debug_mark),a  
06bf 3a ce 06			ld a, (.dmark+1)  
06c2 32 7b ee			ld (debug_mark+1),a  
06c5 3a cf 06			ld a, (.dmark+2)  
06c8 32 7c ee			ld (debug_mark+2),a  
06cb 18 03			jr .pastdmark  
06cd ..			.dmark: db "SCb"  
06d0 f1			.pastdmark: pop af  
06d1			endm  
# End of macro DMARK
06d1					;push af 
06d1					;ld a, 'b' 
06d1					;ld (debug_mark),a 
06d1					;pop af 
06d1					CALLMONITOR 
06d1 cd 77 14			call break_point_state  
06d4				endm  
# End of macro CALLMONITOR
06d4				endif 
06d4 cd 16 02			call storage_write_block 
06d7			 
06d7 3a 5e eb			ld a, (store_tmpid) 
06da 6f				ld l, a 
06db 26 00			ld h,0 
06dd				if DEBUG_STORESE 
06dd					DMARK "SCz" 
06dd f5				push af  
06de 3a f2 06			ld a, (.dmark)  
06e1 32 7a ee			ld (debug_mark),a  
06e4 3a f3 06			ld a, (.dmark+1)  
06e7 32 7b ee			ld (debug_mark+1),a  
06ea 3a f4 06			ld a, (.dmark+2)  
06ed 32 7c ee			ld (debug_mark+2),a  
06f0 18 03			jr .pastdmark  
06f2 ..			.dmark: db "SCz"  
06f5 f1			.pastdmark: pop af  
06f6			endm  
# End of macro DMARK
06f6					CALLMONITOR 
06f6 cd 77 14			call break_point_state  
06f9				endm  
# End of macro CALLMONITOR
06f9				endif 
06f9 c9				ret 
06fa				 
06fa			 
06fa			 
06fa			; 
06fa			; Read File 
06fa			; 
06fa			; h - file id to locate 
06fa			; l - extent to locate 
06fa			; de - pointer to string to read into 
06fa			; 
06fa			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
06fa			 
06fa			.sr_fail: 
06fa d1				pop de 
06fb c9				ret 
06fc			 
06fc			storage_read: 
06fc d5				push de 
06fd			 
06fd			; TODO BUG the above push is it popped before the RET Z? 
06fd			 
06fd			; TODO how to handle multiple part blocks 
06fd			 
06fd				; locate file extent to read 
06fd			 
06fd 5c				ld e, h 
06fe 55				ld d, l 
06ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0702				if DEBUG_STORESE 
0702					DMARK "SRE" 
0702 f5				push af  
0703 3a 17 07			ld a, (.dmark)  
0706 32 7a ee			ld (debug_mark),a  
0709 3a 18 07			ld a, (.dmark+1)  
070c 32 7b ee			ld (debug_mark+1),a  
070f 3a 19 07			ld a, (.dmark+2)  
0712 32 7c ee			ld (debug_mark+2),a  
0715 18 03			jr .pastdmark  
0717 ..			.dmark: db "SRE"  
071a f1			.pastdmark: pop af  
071b			endm  
# End of macro DMARK
071b					CALLMONITOR 
071b cd 77 14			call break_point_state  
071e				endm  
# End of macro CALLMONITOR
071e				endif 
071e cd d6 04			call storage_findnextid 
0721			 
0721				if DEBUG_STORESE 
0721					DMARK "SRf" 
0721 f5				push af  
0722 3a 36 07			ld a, (.dmark)  
0725 32 7a ee			ld (debug_mark),a  
0728 3a 37 07			ld a, (.dmark+1)  
072b 32 7b ee			ld (debug_mark+1),a  
072e 3a 38 07			ld a, (.dmark+2)  
0731 32 7c ee			ld (debug_mark+2),a  
0734 18 03			jr .pastdmark  
0736 ..			.dmark: db "SRf"  
0739 f1			.pastdmark: pop af  
073a			endm  
# End of macro DMARK
073a					CALLMONITOR 
073a cd 77 14			call break_point_state  
073d				endm  
# End of macro CALLMONITOR
073d				endif 
073d cd f2 0b			call ishlzero 
0740			;	ld a, l 
0740			;	add h 
0740			;	cp 0 
0740 28 b8			jr z,.sr_fail			; block not found so EOF 
0742			 
0742				; hl contains page number to load 
0742 d1				pop de   ; get storage 
0743 d5				push de 
0744				if DEBUG_STORESE 
0744					DMARK "SRg" 
0744 f5				push af  
0745 3a 59 07			ld a, (.dmark)  
0748 32 7a ee			ld (debug_mark),a  
074b 3a 5a 07			ld a, (.dmark+1)  
074e 32 7b ee			ld (debug_mark+1),a  
0751 3a 5b 07			ld a, (.dmark+2)  
0754 32 7c ee			ld (debug_mark+2),a  
0757 18 03			jr .pastdmark  
0759 ..			.dmark: db "SRg"  
075c f1			.pastdmark: pop af  
075d			endm  
# End of macro DMARK
075d					CALLMONITOR 
075d cd 77 14			call break_point_state  
0760				endm  
# End of macro CALLMONITOR
0760				endif 
0760 cd b1 01			call storage_read_block 
0763			 
0763			 
0763			; TODO if block has no zeros then need to read next block  
0763			 
0763			 
0763					 
0763 e1				pop hl 		 ; return start of data to show as not EOF 
0764 23				inc hl   ; past file id 
0765 23				inc hl   ; past ext 
0766				if DEBUG_STORESE 
0766					DMARK "SRe" 
0766 f5				push af  
0767 3a 7b 07			ld a, (.dmark)  
076a 32 7a ee			ld (debug_mark),a  
076d 3a 7c 07			ld a, (.dmark+1)  
0770 32 7b ee			ld (debug_mark+1),a  
0773 3a 7d 07			ld a, (.dmark+2)  
0776 32 7c ee			ld (debug_mark+2),a  
0779 18 03			jr .pastdmark  
077b ..			.dmark: db "SRe"  
077e f1			.pastdmark: pop af  
077f			endm  
# End of macro DMARK
077f					CALLMONITOR 
077f cd 77 14			call break_point_state  
0782				endm  
# End of macro CALLMONITOR
0782				endif 
0782 c9					ret 
0783			 
0783			 
0783			 
0783			; 
0783			; Append File 
0783			; 
0783			; hl - file id to locate 
0783			; de - pointer to (multi block) string to write 
0783			 
0783			.sa_notfound: 
0783 d1				pop de 
0784 c9				ret 
0785			 
0785			 
0785			storage_append: 
0785				; hl -  file id to append to 
0785				; de - string to append 
0785			 
0785 d5				push de 
0786				 
0786				if DEBUG_STORESE 
0786					DMARK "AP1" 
0786 f5				push af  
0787 3a 9b 07			ld a, (.dmark)  
078a 32 7a ee			ld (debug_mark),a  
078d 3a 9c 07			ld a, (.dmark+1)  
0790 32 7b ee			ld (debug_mark+1),a  
0793 3a 9d 07			ld a, (.dmark+2)  
0796 32 7c ee			ld (debug_mark+2),a  
0799 18 03			jr .pastdmark  
079b ..			.dmark: db "AP1"  
079e f1			.pastdmark: pop af  
079f			endm  
# End of macro DMARK
079f					CALLMONITOR 
079f cd 77 14			call break_point_state  
07a2				endm  
# End of macro CALLMONITOR
07a2				endif 
07a2			 
07a2 7d				ld a, l 
07a3 32 5e eb			ld (store_tmpid), a 
07a6			 
07a6				; get file header  
07a6			 
07a6 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
07a8 3a 5e eb			ld a, (store_tmpid) 
07ab 5f				ld e, a 
07ac			 
07ac 21 40 00				ld hl, STORE_BLOCK_PHY 
07af cd d6 04				call storage_findnextid 
07b2			 
07b2 cd f2 0b			call ishlzero 
07b5 28 cc			jr z, .sa_notfound 
07b7			 
07b7 22 4f eb			ld (store_tmppageid), hl 
07ba			 
07ba				; TODO handle file id not found 
07ba			 
07ba				if DEBUG_STORESE 
07ba					DMARK "AP2" 
07ba f5				push af  
07bb 3a cf 07			ld a, (.dmark)  
07be 32 7a ee			ld (debug_mark),a  
07c1 3a d0 07			ld a, (.dmark+1)  
07c4 32 7b ee			ld (debug_mark+1),a  
07c7 3a d1 07			ld a, (.dmark+2)  
07ca 32 7c ee			ld (debug_mark+2),a  
07cd 18 03			jr .pastdmark  
07cf ..			.dmark: db "AP2"  
07d2 f1			.pastdmark: pop af  
07d3			endm  
# End of macro DMARK
07d3					CALLMONITOR 
07d3 cd 77 14			call break_point_state  
07d6				endm  
# End of macro CALLMONITOR
07d6				endif 
07d6			 
07d6				; update file extent count 
07d6			 
07d6 11 65 eb			ld de, store_page 
07d9			 
07d9 cd b1 01			call storage_read_block 
07dc			 
07dc				if DEBUG_STORESE 
07dc					DMARK "AP3" 
07dc f5				push af  
07dd 3a f1 07			ld a, (.dmark)  
07e0 32 7a ee			ld (debug_mark),a  
07e3 3a f2 07			ld a, (.dmark+1)  
07e6 32 7b ee			ld (debug_mark+1),a  
07e9 3a f3 07			ld a, (.dmark+2)  
07ec 32 7c ee			ld (debug_mark+2),a  
07ef 18 03			jr .pastdmark  
07f1 ..			.dmark: db "AP3"  
07f4 f1			.pastdmark: pop af  
07f5			endm  
# End of macro DMARK
07f5					CALLMONITOR 
07f5 cd 77 14			call break_point_state  
07f8				endm  
# End of macro CALLMONITOR
07f8				endif 
07f8			;	ld (store_tmppageid), hl 
07f8			 
07f8 3a 67 eb			ld a, (store_page+2) 
07fb 3c				inc a 
07fc 32 67 eb			ld (store_page+2), a 
07ff 32 5d eb			ld (store_tmpext), a 
0802				 
0802				if DEBUG_STORESE 
0802					DMARK "AP3" 
0802 f5				push af  
0803 3a 17 08			ld a, (.dmark)  
0806 32 7a ee			ld (debug_mark),a  
0809 3a 18 08			ld a, (.dmark+1)  
080c 32 7b ee			ld (debug_mark+1),a  
080f 3a 19 08			ld a, (.dmark+2)  
0812 32 7c ee			ld (debug_mark+2),a  
0815 18 03			jr .pastdmark  
0817 ..			.dmark: db "AP3"  
081a f1			.pastdmark: pop af  
081b			endm  
# End of macro DMARK
081b					CALLMONITOR 
081b cd 77 14			call break_point_state  
081e				endm  
# End of macro CALLMONITOR
081e				endif 
081e 2a 4f eb			ld hl, (store_tmppageid) 
0821 11 65 eb			ld de, store_page 
0824 cd 16 02			call storage_write_block 
0827			 
0827				; find free block 
0827			 
0827 11 00 00			ld de, 0			 ; file extent to locate 
082a			 
082a 21 40 00				ld hl, STORE_BLOCK_PHY 
082d cd d6 04				call storage_findnextid 
0830 cd f2 0b			call ishlzero 
0833 ca 83 07			jp z, .sa_notfound 
0836			 
0836					; TODO handle no space left 
0836					 
0836 22 4f eb				ld (store_tmppageid), hl 
0839			 
0839				if DEBUG_STORESE 
0839					DMARK "AP4" 
0839 f5				push af  
083a 3a 4e 08			ld a, (.dmark)  
083d 32 7a ee			ld (debug_mark),a  
0840 3a 4f 08			ld a, (.dmark+1)  
0843 32 7b ee			ld (debug_mark+1),a  
0846 3a 50 08			ld a, (.dmark+2)  
0849 32 7c ee			ld (debug_mark+2),a  
084c 18 03			jr .pastdmark  
084e ..			.dmark: db "AP4"  
0851 f1			.pastdmark: pop af  
0852			endm  
# End of macro DMARK
0852					CALLMONITOR 
0852 cd 77 14			call break_point_state  
0855				endm  
# End of macro CALLMONITOR
0855				endif 
0855					; init the buffer with zeros so we can id if the buffer is full or not 
0855			 
0855 e5					push hl 
0856 c5					push bc 
0857			 
0857 21 65 eb				ld hl, store_page 
085a 06 40				ld b, STORE_BLOCK_PHY 
085c 3e 00				ld a, 0 
085e 77			.zeroblock:	ld (hl), a 
085f 23					inc hl 
0860 10 fc				djnz .zeroblock 
0862			 
0862 c1					pop bc 
0863 e1					pop hl 
0864			 
0864					; construct block 
0864			 
0864 3a 5e eb				ld a, (store_tmpid) 
0867 32 65 eb				ld (store_page), a   ; file id 
086a 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
086d 32 66 eb				ld (store_page+1), a 
0870			 
0870 e1					pop hl    ; get string to write 
0871 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0873 11 67 eb				ld de, store_page+2 
0876			 
0876				if DEBUG_STORESE 
0876					DMARK "AP5" 
0876 f5				push af  
0877 3a 8b 08			ld a, (.dmark)  
087a 32 7a ee			ld (debug_mark),a  
087d 3a 8c 08			ld a, (.dmark+1)  
0880 32 7b ee			ld (debug_mark+1),a  
0883 3a 8d 08			ld a, (.dmark+2)  
0886 32 7c ee			ld (debug_mark+2),a  
0889 18 03			jr .pastdmark  
088b ..			.dmark: db "AP5"  
088e f1			.pastdmark: pop af  
088f			endm  
# End of macro DMARK
088f					CALLMONITOR 
088f cd 77 14			call break_point_state  
0892				endm  
# End of macro CALLMONITOR
0892				endif 
0892			 
0892			 
0892			 
0892					; fill buffer with data until end of string or full block 
0892			 
0892 7e			.appd:		ld a, (hl) 
0893 12					ld (de), a 
0894 fe 00				cp 0 
0896 28 04				jr z, .appdone 
0898 23					inc hl 
0899 13					inc de 
089a 10 f6				djnz .appd 
089c			 
089c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
089d f5					push af   		; save last byte dumped 
089e			 
089e			 
089e 2a 4f eb			ld hl, (store_tmppageid) 
08a1 11 65 eb			ld de, store_page 
08a4				if DEBUG_STORESE 
08a4					DMARK "AP6" 
08a4 f5				push af  
08a5 3a b9 08			ld a, (.dmark)  
08a8 32 7a ee			ld (debug_mark),a  
08ab 3a ba 08			ld a, (.dmark+1)  
08ae 32 7b ee			ld (debug_mark+1),a  
08b1 3a bb 08			ld a, (.dmark+2)  
08b4 32 7c ee			ld (debug_mark+2),a  
08b7 18 03			jr .pastdmark  
08b9 ..			.dmark: db "AP6"  
08bc f1			.pastdmark: pop af  
08bd			endm  
# End of macro DMARK
08bd					CALLMONITOR 
08bd cd 77 14			call break_point_state  
08c0				endm  
# End of macro CALLMONITOR
08c0				endif 
08c0 cd 16 02				call storage_write_block 
08c3			 
08c3			 
08c3				; was that a full block of data written? 
08c3				; any more to write out? 
08c3			 
08c3				; if yes then set vars and jump to start of function again 
08c3			 
08c3 f1					pop af 
08c4 d1					pop de 
08c5			 
08c5 fe 00				cp 0		 ; no, string was fully written 
08c7 c8					ret z 
08c8			 
08c8					; setup vars for next cycle 
08c8			 
08c8 3a 5e eb				ld a, (store_tmpid) 
08cb 6f					ld l, a 
08cc 26 00				ld h, 0 
08ce			 
08ce c3 85 07			 	jp storage_append	 ; yes, need to write out some more 
08d1			 
08d1			 
08d1			 
08d1			 
08d1			 
08d1			 
08d1			 
08d1			if DEBUG_STORECF 
08d1			storageput:	 
08d1					ret 
08d1			storageread: 
08d1					ld hl, store_page 
08d1					ld b, 200 
08d1					ld a,0 
08d1			.src:		ld (hl),a 
08d1					inc hl 
08d1					djnz .src 
08d1					 
08d1			 
08d1					ld de, 0 
08d1					ld bc, 1 
08d1					ld hl, store_page 
08d1					call cfRead 
08d1			 
08d1				call cfGetError 
08d1				ld hl,scratch 
08d1				call hexout 
08d1				ld hl, scratch+2 
08d1				ld a, 0 
08d1				ld (hl),a 
08d1				ld de, scratch 
08d1				ld a,display_row_1 
08d1				call str_at_display 
08d1				call update_display 
08d1			 
08d1					ld hl, store_page 
08d1					ld (os_cur_ptr),hl 
08d1			 
08d1					ret 
08d1			endif 
08d1			 
08d1			 
08d1			; Clear out the main buffer store (used to remove junk before writing a new block) 
08d1			 
08d1			storage_clear_page: 
08d1 e5				push hl 
08d2 d5				push de 
08d3 c5				push bc 
08d4 21 65 eb			ld hl, store_page 
08d7 3e 00			ld a, 0 
08d9 77				ld (hl), a 
08da			 
08da 11 66 eb			ld de, store_page+1 
08dd 01 40 00			ld bc, STORE_BLOCK_PHY 
08e0			 
08e0 ed b0			ldir 
08e2				 
08e2 c1				pop bc 
08e3 d1				pop de 
08e4 e1				pop hl 
08e5 c9				ret 
08e6			 
08e6			; eof 
# End of file firmware_storage.asm
08e6			  
08e6			; support routines for above hardware abstraction layer  
08e6			  
08e6			include "firmware_general.asm"        ; general support functions  
08e6			 
08e6			; word look up 
08e6			 
08e6			; in 
08e6			; a is the index 
08e6			; hl is pointer start of array 
08e6			; 
08e6			; returns 
08e6			; hl to the word 
08e6			; 
08e6			 
08e6			table_lookup:  
08e6 d5					push de 
08e7 eb					ex de, hl 
08e8			 
08e8 6f					ld l, a 
08e9 26 00				ld h, 0 
08eb 29					add hl, hl 
08ec 19					add hl, de 
08ed 7e					ld a, (hl) 
08ee 23					inc hl 
08ef 66					ld h,(hl) 
08f0 6f					ld l, a 
08f1			 
08f1 d1					pop de 
08f2 c9					ret 
08f3			 
08f3			; Delay loops 
08f3			 
08f3			 
08f3			 
08f3			aDelayInMS: 
08f3 c5				push bc 
08f4 47				ld b,a 
08f5			msdelay: 
08f5 c5				push bc 
08f6				 
08f6			 
08f6 01 41 00			ld bc,041h 
08f9 cd 11 09			call delayloop 
08fc c1				pop bc 
08fd 05				dec b 
08fe 20 f5			jr nz,msdelay 
0900			 
0900			;if CPU_CLOCK_8MHZ 
0900			;msdelay8: 
0900			;	push bc 
0900			;	 
0900			; 
0900			;	ld bc,041h 
0900			;	call delayloop 
0900			;	pop bc 
0900			;	dec b 
0900			;	jr nz,msdelay8 
0900			;endif 
0900			 
0900			 
0900 c1				pop bc 
0901 c9				ret 
0902			 
0902			 
0902			delay250ms: 
0902				;push de 
0902 01 00 40			ld bc, 04000h 
0905 c3 11 09			jp delayloop 
0908			delay500ms: 
0908				;push de 
0908 01 00 80			ld bc, 08000h 
090b c3 11 09			jp delayloop 
090e			delay1s: 
090e				;push bc 
090e			   ; Clobbers A, d and e 
090e 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0911			delayloop: 
0911 c5			    push bc 
0912			 
0912			if BASE_CPM 
0912 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0915			.cpmloop: 
0915 c5				push bc 
0916			 
0916			endif 
0916			 
0916			 
0916			 
0916			delayloopi: 
0916			;	push bc 
0916			;.dl: 
0916 cb 47		    bit     0,a    	; 8 
0918 cb 47		    bit     0,a    	; 8 
091a cb 47		    bit     0,a    	; 8 
091c e6 ff		    and     255  	; 7 
091e 0b			    dec     bc      	; 6 
091f 79			    ld      a,c     	; 4 
0920 b0			    or      b     	; 4 
0921 c2 16 09		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0924			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0924				;pop de 
0924			;pop bc 
0924			 
0924			if BASE_CPM 
0924 c1				pop bc 
0925				 
0925 0b			    dec     bc      	; 6 
0926 79			    ld      a,c     	; 4 
0927 b0			    or      b     	; 4 
0928 c2 15 09		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
092b				 
092b			 
092b			endif 
092b			;if CPU_CLOCK_8MHZ 
092b			;    pop bc 
092b			;    push bc 
092b			;.dl8: 
092b			;    bit     0,a    	; 8 
092b			;    bit     0,a    	; 8 
092b			;    bit     0,a    	; 8 
092b			;    and     255  	; 7 
092b			;    dec     bc      	; 6 
092b			;    ld      a,c     	; 4 
092b			;    or      b     	; 4 
092b			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
092b			;endif 
092b			 
092b			;if CPU_CLOCK_10MHZ 
092b			;    pop bc 
092b			;    push bc 
092b			;.dl8: 
092b			;    bit     0,a    	; 8 
092b			;    bit     0,a    	; 8 
092b			;    bit     0,a    	; 8 
092b			;    and     255  	; 7 
092b			;    dec     bc      	; 6 
092b			;    ld      a,c     	; 4 
092b			;    or      b     	; 4 
092b			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
092b			;endif 
092b c1			    pop bc 
092c			 
092c c9				ret 
092d			 
092d			 
092d			 
092d			; eof 
# End of file firmware_general.asm
092d			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
092d			; display routines that use the physical hardware abstraction layer 
092d			 
092d			 
092d			; information window 
092d			 
092d			; pass hl with 1st string to display 
092d			; pass de with 2nd string to display 
092d			 
092d			info_panel: 
092d e5				push hl 
092e			 
092e 2a db eb			ld hl, (display_fb_active) 
0931 e5				push hl    ; future de destination 
0932 21 c0 ed				ld hl, display_fb0 
0935 22 db eb				ld (display_fb_active), hl 
0938			 
0938			;	call clear_display 
0938			 
0938				if BASE_CPM 
0938 3e 2e			ld a, '.' 
093a				else 
093a				ld a, 165 
093a				endif 
093a cd a1 09			call fill_display 
093d			 
093d			 
093d 3e 55			ld a, display_row_3 + 5 
093f cd af 09			call str_at_display 
0942			 
0942 e1				pop hl 
0943 d1				pop de 
0944			 
0944 e5				push hl 
0945			 
0945			 
0945 3e 2d			ld a, display_row_2 + 5 
0947 cd af 09			call str_at_display 
094a			 
094a			 
094a cd bf 09			call update_display 
094d cd 7c 19			call next_page_prompt 
0950 cd 9c 09			call clear_display 
0953			 
0953				 
0953 21 1f ed				ld hl, display_fb1 
0956 22 db eb				ld (display_fb_active), hl 
0959 cd bf 09			call update_display 
095c			 
095c e1				pop hl 
095d			 
095d c9				ret 
095e			 
095e			 
095e			 
095e			 
095e			; TODO windowing? 
095e			 
095e			; TODO scroll line up 
095e			 
095e			scroll_up: 
095e			 
095e e5				push hl 
095f d5				push de 
0960 c5				push bc 
0961			 
0961				; get frame buffer  
0961			 
0961 2a db eb			ld hl, (display_fb_active) 
0964 e5				push hl    ; future de destination 
0965			 
0965 11 28 00			ld  de, display_cols 
0968 19				add hl, de 
0969			 
0969 d1				pop de 
096a			 
096a				;ex de, hl 
096a 01 9f 00			ld bc, display_fb_len -1  
096d			;if DEBUG_FORTH_WORDS 
096d			;	DMARK "SCL" 
096d			;	CALLMONITOR 
096d			;endif	 
096d ed b0			ldir 
096f			 
096f				; wipe bottom row 
096f			 
096f			 
096f 2a db eb			ld hl, (display_fb_active) 
0972 11 a0 00			ld de, display_cols*display_rows 
0975 19				add hl, de 
0976 06 28			ld b, display_cols 
0978 3e 20			ld a, ' ' 
097a			.scwipe: 
097a 77				ld (hl), a 
097b 2b				dec hl 
097c 10 fc			djnz .scwipe 
097e			 
097e				;pop hl 
097e			 
097e c1				pop bc 
097f d1				pop de 
0980 e1				pop hl 
0981			 
0981 c9				ret 
0982			 
0982			 
0982			;scroll_upo: 
0982			;	ld de, display_row_1 
0982			 ;	ld hl, display_row_2 
0982			;	ld bc, display_cols 
0982			;	ldir 
0982			;	ld de, display_row_2 
0982			 ;	ld hl, display_row_3 
0982			;	ld bc, display_cols 
0982			;	ldir 
0982			;	ld de, display_row_3 
0982			 ;	ld hl, display_row_4 
0982			;	ld bc, display_cols 
0982			;	ldir 
0982			 
0982			; TODO clear row 4 
0982			 
0982			;	ret 
0982			 
0982				 
0982			scroll_down: 
0982			 
0982 e5				push hl 
0983 d5				push de 
0984 c5				push bc 
0985			 
0985				; get frame buffer  
0985			 
0985 2a db eb			ld hl, (display_fb_active) 
0988			 
0988 11 9f 00			ld de, display_fb_len - 1 
098b 19				add hl, de 
098c			 
098c e5			push hl    ; future de destination 
098d			 
098d 11 28 00			ld  de, display_cols 
0990 ed 52			sbc hl, de 
0992			 
0992			 
0992 d1				pop de 
0993			 
0993			;	ex de, hl 
0993 01 9f 00			ld bc, display_fb_len -1  
0996			 
0996			 
0996				 
0996			 
0996 ed b0			ldir 
0998			 
0998				; wipe bottom row 
0998			 
0998			 
0998			;	ld hl, (display_fb_active) 
0998			;;	ld de, display_cols*display_rows 
0998			;;	add hl, de 
0998			;	ld b, display_cols 
0998			;	ld a, ' ' 
0998			;.scwiped: 
0998			;	ld (hl), a 
0998			;	dec hl 
0998			;	djnz .scwiped 
0998			 
0998				;pop hl 
0998			 
0998 c1				pop bc 
0999 d1				pop de 
099a e1				pop hl 
099b			 
099b c9				ret 
099c			;scroll_down: 
099c			;	ld de, display_row_4 
099c			;	ld hl, display_row_3 
099c			;	ld bc, display_cols 
099c			;	ldir 
099c			;	ld de, display_row_3 
099c			; 	ld hl, display_row_2 
099c			;	ld bc, display_cols 
099c			;	ldir 
099c			;	ld de, display_row_2 
099c			;	ld hl, display_row_1 
099c			;	ld bc, display_cols 
099c			;	ldir 
099c			;;; TODO clear row 1 
099c			;	ret 
099c			 
099c			 
099c			 
099c			 
099c			 
099c			; clear active frame buffer 
099c			 
099c			clear_display: 
099c 3e 20			ld a, ' ' 
099e c3 a1 09			jp fill_display 
09a1			 
09a1			; fill active frame buffer with a char in A 
09a1			 
09a1			fill_display: 
09a1 06 a0			ld b,display_fb_len 
09a3 2a db eb			ld hl, (display_fb_active) 
09a6 77			.fd1:	ld (hl),a 
09a7 23				inc hl 
09a8 10 fc			djnz .fd1 
09aa 23				inc hl 
09ab 3e 00			ld a,0 
09ad 77				ld (hl),a 
09ae			 
09ae			 
09ae c9				ret 
09af			; Write string (DE) at pos (A) to active frame buffer 
09af			 
09af 2a db eb		str_at_display:    ld hl,(display_fb_active) 
09b2 06 00					ld b,0 
09b4 4f					ld c,a 
09b5 09					add hl,bc 
09b6 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
09b7 b7			            OR   A              ;Null terminator? 
09b8 c8			            RET  Z              ;Yes, so finished 
09b9 77					ld (hl),a 
09ba 23				inc hl 
09bb 13			            INC  DE             ;Point to next character 
09bc 18 f8		            JR   .sad1     ;Repeat 
09be c9					ret 
09bf			 
09bf			; using current frame buffer write to physical display 
09bf			 
09bf			update_display: 
09bf e5				push hl 
09c0 2a db eb			ld hl, (display_fb_active) 
09c3 cd 6f 58			call write_display 
09c6 e1				pop hl 
09c7 c9				ret 
09c8			 
09c8			; TODO scrolling 
09c8			 
09c8			 
09c8			; move cursor right one char 
09c8			cursor_right: 
09c8			 
09c8				; TODO shift right 
09c8				; TODO if beyond max col 
09c8				; TODO       cursor_next_line 
09c8			 
09c8 c9				ret 
09c9			 
09c9			 
09c9			cursor_next_line: 
09c9				; TODO first char 
09c9				; TODO line down 
09c9				; TODO if past last row 
09c9				; TODO    scroll up 
09c9			 
09c9 c9				ret 
09ca			 
09ca			cursor_left: 
09ca				; TODO shift left 
09ca				; TODO if beyond left  
09ca				; TODO     cursor prev line 
09ca				 
09ca c9				ret 
09cb			 
09cb			cursor_prev_line: 
09cb				; TODO last char 
09cb				; TODO line up 
09cb				; TODO if past first row 
09cb				; TODO   scroll down 
09cb			 
09cb c9				ret 
09cc			 
09cc			 
09cc			cout: 
09cc				; A - char 
09cc c9				ret 
09cd			 
09cd			 
09cd			; Display a menu and allow item selection (optional toggle items) 
09cd			; 
09cd			; format: 
09cd			; hl pointer to word array with zero term for items 
09cd			; e.g.    db item1 
09cd			;         db .... 
09cd			;         db 0 
09cd			; 
09cd			; a = starting menu item  
09cd			; 
09cd			; de = pointer item toggle array   (todo) 
09cd			; 
09cd			; returns item selected in a 1-... 
09cd			; returns 0 if back button pressed 
09cd			; 
09cd			; NOTE: Uses system frame buffer to display 
09cd			; 
09cd			; LEFT, Q = go back 
09cd			; RIGHT, SPACE, CR = select 
09cd			; UP, A - Up 
09cd			; DOWN, Z - Down 
09cd			 
09cd			 
09cd			 
09cd			 
09cd			 
09cd			menu: 
09cd			 
09cd					; keep array pointer 
09cd			 
09cd 22 63 eb				ld (store_tmp1), hl 
09d0 32 61 eb				ld (store_tmp2), a 
09d3			 
09d3					; check for key bounce 
09d3			 
09d3			if BASE_KEV 
09d3			 
09d3			.mbounce:	call cin 
09d3					cp 0 
09d3					jr nz, .mbounce 
09d3			endif 
09d3					; for ease use ex 
09d3			 
09d3					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
09d3 21 c0 ed				ld hl, display_fb0 
09d6 22 db eb				ld (display_fb_active), hl 
09d9			 
09d9 cd 9c 09		.mloop:		call clear_display 
09dc cd bf 09				call update_display 
09df			 
09df					; draw selection id '>' at 1 
09df			 
09df					; init start of list display 
09df			 
09df 3e 05				ld a, 5 
09e1 32 5f eb				ld (store_tmp3), a   ; display row count 
09e4 3a 61 eb				ld a,( store_tmp2) 
09e7 32 62 eb				ld (store_tmp2+1), a   ; display item count 
09ea			 
09ea					 
09ea			.mitem:	 
09ea			 
09ea			 
09ea 3a 62 eb				ld a,(store_tmp2+1) 
09ed 6f					ld l, a 
09ee 26 00				ld h, 0 
09f0 29					add hl, hl 
09f1 ed 5b 63 eb			ld de, (store_tmp1) 
09f5 19					add hl, de 
09f6 7e					ld a, (hl) 
09f7 23					inc hl 
09f8 66					ld h,(hl) 
09f9 6f					ld l, a 
09fa			 
09fa cd f2 0b				call ishlzero 
09fd 28 1a				jr z, .mdone 
09ff			 
09ff eb					ex de, hl 
0a00 3a 5f eb				ld a, (store_tmp3) 
0a03 cd af 09				call str_at_display 
0a06					 
0a06			 
0a06					; next item 
0a06 3a 62 eb				ld a, (store_tmp2+1) 
0a09 3c					inc a 
0a0a 32 62 eb				ld (store_tmp2+1), a   ; display item count 
0a0d			 
0a0d			 		; next row 
0a0d			 
0a0d 3a 5f eb				ld a, (store_tmp3) 
0a10 c6 28				add display_cols 
0a12 32 5f eb				ld (store_tmp3), a 
0a15			 
0a15					; at end of screen? 
0a15			 
0a15 fe 10				cp display_rows*4 
0a17 20 d1				jr nz, .mitem 
0a19			 
0a19			 
0a19			.mdone: 
0a19 cd f2 0b				call ishlzero 
0a1c 28 08				jr z, .nodn 
0a1e			 
0a1e 3e 78				ld a, display_row_4 
0a20 11 9f 0a				ld de, .mdown 
0a23 cd af 09				call str_at_display 
0a26			 
0a26					; draw options to fill the screens with active item on line 1 
0a26					; if current option is 2 or more then display ^ in top 
0a26			 
0a26 3a 61 eb		.nodn:		ld a, (store_tmp2) 
0a29 fe 00				cp 0 
0a2b 28 08				jr z, .noup 
0a2d			 
0a2d 3e 00				ld a, 0 
0a2f 11 9d 0a				ld de, .mup 
0a32 cd af 09				call str_at_display 
0a35			 
0a35 3e 02		.noup:		ld a, 2 
0a37 11 9b 0a				ld de, .msel 
0a3a cd af 09				call str_at_display 
0a3d			 
0a3d					; if current option + 1 is not null then display V in bottom 
0a3d					; get key 
0a3d cd bf 09				call update_display 
0a40			 
0a40			 
0a40					; handle key 
0a40			 
0a40 cd 21 59				call cin_wait 
0a43			 
0a43 fe 05				cp KEY_UP 
0a45 28 2b				jr z, .mgoup 
0a47 fe 61				cp 'a' 
0a49 28 27				jr z, .mgoup 
0a4b fe 0a				cp KEY_DOWN 
0a4d 28 32				jr z, .mgod 
0a4f fe 7a				cp 'z' 
0a51 28 2e				jr z, .mgod 
0a53 fe 20				cp ' ' 
0a55 28 34				jr z, .goend 
0a57 fe 0c				cp KEY_RIGHT 
0a59 28 30				jr z, .goend 
0a5b fe 0d				cp KEY_CR 
0a5d 28 2c				jr z, .goend 
0a5f fe 71				cp 'q' 
0a61 28 0b				jr z, .goback 
0a63			 
0a63 fe 0b				cp KEY_LEFT 
0a65 28 07				jr z, .goback 
0a67 fe 08				cp KEY_BS 
0a69 28 03				jr z, .goback 
0a6b c3 d9 09				jp .mloop 
0a6e			 
0a6e			.goback: 
0a6e 3e 00			ld a, 0 
0a70 18 1d			jr .goend2 
0a72			 
0a72				; move up one 
0a72			.mgoup: 
0a72 3a 61 eb				ld a, (store_tmp2) 
0a75 fe 00				cp 0 
0a77 ca d9 09				jp z, .mloop 
0a7a 3d					dec a 
0a7b 32 61 eb				ld (store_tmp2), a 
0a7e c3 d9 09				jp .mloop 
0a81			 
0a81				; move down one 
0a81			.mgod: 
0a81 3a 61 eb				ld a, (store_tmp2) 
0a84 3c					inc a 
0a85 32 61 eb				ld (store_tmp2), a 
0a88 c3 d9 09				jp .mloop 
0a8b			 
0a8b			 
0a8b			.goend: 
0a8b					; get selected item number 
0a8b			 
0a8b 3a 61 eb				ld a, (store_tmp2) 
0a8e 3c					inc a 
0a8f			 
0a8f			.goend2: 
0a8f f5					push af 
0a90			 
0a90					; restore active fb 
0a90					; TODO BUG assumes fb1 
0a90			 
0a90 21 1f ed				ld hl, display_fb1 
0a93 22 db eb				ld (display_fb_active), hl 
0a96			 
0a96					; restore main regs 
0a96			 
0a96			 
0a96 cd bf 09				call update_display 
0a99			 
0a99 f1					pop af 
0a9a			 
0a9a c9				ret 
0a9b			 
0a9b .. 00		.msel:   db ">",0 
0a9d .. 00		.mup:   db "^",0 
0a9f .. 00		.mdown:   db "v",0 
0aa1			 
0aa1			 
0aa1			; eof 
0aa1			 
# End of file firmware_display.asm
0aa1			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0aa1			; random number generators 
0aa1			 
0aa1			 
0aa1			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0aa1			 
0aa1			 
0aa1			;-----> Generate a random number 
0aa1			; output a=answer 0<=a<=255 
0aa1			; all registers are preserved except: af 
0aa1			random: 
0aa1 e5			        push    hl 
0aa2 d5			        push    de 
0aa3 2a bd eb		        ld      hl,(randData) 
0aa6 ed 5f		        ld      a,r 
0aa8 57			        ld      d,a 
0aa9 5e			        ld      e,(hl) 
0aaa 19			        add     hl,de 
0aab 85			        add     a,l 
0aac ac			        xor     h 
0aad 22 bd eb		        ld      (randData),hl 
0ab0 d1			        pop     de 
0ab1 e1			        pop     hl 
0ab2 c9			        ret 
0ab3			 
0ab3			 
0ab3			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ab3			 
0ab3			 
0ab3			 
0ab3			;------LFSR------ 
0ab3			;James Montelongo 
0ab3			;optimized by Spencer Putt 
0ab3			;out: 
0ab3			; a = 8 bit random number 
0ab3			RandLFSR: 
0ab3 21 c3 eb		        ld hl,LFSRSeed+4 
0ab6 5e			        ld e,(hl) 
0ab7 23			        inc hl 
0ab8 56			        ld d,(hl) 
0ab9 23			        inc hl 
0aba 4e			        ld c,(hl) 
0abb 23			        inc hl 
0abc 7e			        ld a,(hl) 
0abd 47			        ld b,a 
0abe cb 13		        rl e  
0ac0 cb 12			rl d 
0ac2 cb 11		        rl c  
0ac4 17				rla 
0ac5 cb 13		        rl e  
0ac7 cb 12			rl d 
0ac9 cb 11		        rl c  
0acb 17				rla 
0acc cb 13		        rl e  
0ace cb 12			rl d 
0ad0 cb 11		        rl c  
0ad2 17				rla 
0ad3 67			        ld h,a 
0ad4 cb 13		        rl e  
0ad6 cb 12			rl d 
0ad8 cb 11		        rl c  
0ada 17				rla 
0adb a8			        xor b 
0adc cb 13		        rl e  
0ade cb 12			rl d 
0ae0 ac			        xor h 
0ae1 a9			        xor c 
0ae2 aa			        xor d 
0ae3 21 c5 eb		        ld hl,LFSRSeed+6 
0ae6 11 c6 eb		        ld de,LFSRSeed+7 
0ae9 01 07 00		        ld bc,7 
0aec ed b8		        lddr 
0aee 12			        ld (de),a 
0aef c9			        ret 
0af0			 
0af0			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0af0			 
0af0			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0af0			 
0af0			 
0af0			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0af0			 
0af0			prng16: 
0af0			;Inputs: 
0af0			;   (seed1) contains a 16-bit seed value 
0af0			;   (seed2) contains a NON-ZERO 16-bit seed value 
0af0			;Outputs: 
0af0			;   HL is the result 
0af0			;   BC is the result of the LCG, so not that great of quality 
0af0			;   DE is preserved 
0af0			;Destroys: 
0af0			;   AF 
0af0			;cycle: 4,294,901,760 (almost 4.3 billion) 
0af0			;160cc 
0af0			;26 bytes 
0af0 2a b7 eb		    ld hl,(seed1) 
0af3 44			    ld b,h 
0af4 4d			    ld c,l 
0af5 29			    add hl,hl 
0af6 29			    add hl,hl 
0af7 2c			    inc l 
0af8 09			    add hl,bc 
0af9 22 b7 eb		    ld (seed1),hl 
0afc 2a b5 eb		    ld hl,(seed2) 
0aff 29			    add hl,hl 
0b00 9f			    sbc a,a 
0b01 e6 2d		    and %00101101 
0b03 ad			    xor l 
0b04 6f			    ld l,a 
0b05 22 b5 eb		    ld (seed2),hl 
0b08 09			    add hl,bc 
0b09 c9			    ret 
0b0a			 
0b0a			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0b0a			 
0b0a			rand32: 
0b0a			;Inputs: 
0b0a			;   (seed1_0) holds the lower 16 bits of the first seed 
0b0a			;   (seed1_1) holds the upper 16 bits of the first seed 
0b0a			;   (seed2_0) holds the lower 16 bits of the second seed 
0b0a			;   (seed2_1) holds the upper 16 bits of the second seed 
0b0a			;   **NOTE: seed2 must be non-zero 
0b0a			;Outputs: 
0b0a			;   HL is the result 
0b0a			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0b0a			;Destroys: 
0b0a			;   AF 
0b0a			;Tested and passes all CAcert tests 
0b0a			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0b0a			;it has a period of 18,446,744,069,414,584,320 
0b0a			;roughly 18.4 quintillion. 
0b0a			;LFSR taps: 0,2,6,7  = 11000101 
0b0a			;291cc 
0b0a			;seed1_0=$+1 
0b0a			;    ld hl,12345 
0b0a			;seed1_1=$+1 
0b0a			;    ld de,6789 
0b0a			;    ld b,h 
0b0a			;    ld c,l 
0b0a			;    add hl,hl \ rl e \ rl d 
0b0a			;    add hl,hl \ rl e \ rl d 
0b0a			;    inc l 
0b0a			;    add hl,bc 
0b0a			;    ld (seed1_0),hl 
0b0a			;    ld hl,(seed1_1) 
0b0a			;    adc hl,de 
0b0a			;    ld (seed1_1),hl 
0b0a			;    ex de,hl 
0b0a			;seed2_0=$+1 
0b0a			;    ld hl,9876 
0b0a			;seed2_1=$+1 
0b0a			;    ld bc,54321 
0b0a			;    add hl,hl \ rl c \ rl b 
0b0a			;    ld (seed2_1),bc 
0b0a			;    sbc a,a 
0b0a			;    and %11000101 
0b0a			;    xor l 
0b0a			;    ld l,a 
0b0a			;    ld (seed2_0),hl 
0b0a			;    ex de,hl 
0b0a			;    add hl,bc 
0b0a			;    ret 
0b0a			; 
0b0a			 
0b0a			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0b0a			; 20 bytes, 86 cycles (excluding ret) 
0b0a			 
0b0a			; returns   hl = pseudorandom number 
0b0a			; corrupts   a 
0b0a			 
0b0a			; generates 16-bit pseudorandom numbers with a period of 65535 
0b0a			; using the xorshift method: 
0b0a			 
0b0a			; hl ^= hl << 7 
0b0a			; hl ^= hl >> 9 
0b0a			; hl ^= hl << 8 
0b0a			 
0b0a			; some alternative shift triplets which also perform well are: 
0b0a			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0b0a			 
0b0a			;  org 32768 
0b0a			 
0b0a			xrnd: 
0b0a 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
0b0d 3e 00		  ld a,0 
0b0f bd			  cp l 
0b10 20 02		  jr nz, .xrnd1 
0b12 2e 01		  ld l, 1 
0b14			.xrnd1: 
0b14			 
0b14 7c			  ld a,h 
0b15 1f			  rra 
0b16 7d			  ld a,l 
0b17 1f			  rra 
0b18 ac			  xor h 
0b19 67			  ld h,a 
0b1a 7d			  ld a,l 
0b1b 1f			  rra 
0b1c 7c			  ld a,h 
0b1d 1f			  rra 
0b1e ad			  xor l 
0b1f 6f			  ld l,a 
0b20 ac			  xor h 
0b21 67			  ld h,a 
0b22			 
0b22 22 bb eb		  ld (xrandc),hl 
0b25			 
0b25 c9			  ret 
0b26			;  
0b26			 
0b26			 
0b26			;;;; int maths 
0b26			 
0b26			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b26			; Divide 16-bit values (with 16-bit result) 
0b26			; In: Divide BC by divider DE 
0b26			; Out: BC = result, HL = rest 
0b26			; 
0b26			Div16: 
0b26 21 00 00		    ld hl,0 
0b29 78			    ld a,b 
0b2a 06 08		    ld b,8 
0b2c			Div16_Loop1: 
0b2c 17			    rla 
0b2d ed 6a		    adc hl,hl 
0b2f ed 52		    sbc hl,de 
0b31 30 01		    jr nc,Div16_NoAdd1 
0b33 19			    add hl,de 
0b34			Div16_NoAdd1: 
0b34 10 f6		    djnz Div16_Loop1 
0b36 17			    rla 
0b37 2f			    cpl 
0b38 47			    ld b,a 
0b39 79			    ld a,c 
0b3a 48			    ld c,b 
0b3b 06 08		    ld b,8 
0b3d			Div16_Loop2: 
0b3d 17			    rla 
0b3e ed 6a		    adc hl,hl 
0b40 ed 52		    sbc hl,de 
0b42 30 01		    jr nc,Div16_NoAdd2 
0b44 19			    add hl,de 
0b45			Div16_NoAdd2: 
0b45 10 f6		    djnz Div16_Loop2 
0b47 17			    rla 
0b48 2f			    cpl 
0b49 41			    ld b,c 
0b4a 4f			    ld c,a 
0b4b c9			ret 
0b4c			 
0b4c			 
0b4c			;http://z80-heaven.wikidot.com/math 
0b4c			; 
0b4c			;Inputs: 
0b4c			;     DE and A are factors 
0b4c			;Outputs: 
0b4c			;     A is not changed 
0b4c			;     B is 0 
0b4c			;     C is not changed 
0b4c			;     DE is not changed 
0b4c			;     HL is the product 
0b4c			;Time: 
0b4c			;     342+6x 
0b4c			; 
0b4c			Mult16: 
0b4c			 
0b4c 06 08		     ld b,8          ;7           7 
0b4e 21 00 00		     ld hl,0         ;10         10 
0b51 29			       add hl,hl     ;11*8       88 
0b52 07			       rlca          ;4*8        32 
0b53 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b55 19			         add hl,de   ;--         -- 
0b56 10 f9		       djnz $-5      ;13*7+8     99 
0b58 c9			ret 
0b59			 
0b59			; 
0b59			; Square root of 16-bit value 
0b59			; In:  HL = value 
0b59			; Out:  D = result (rounded down) 
0b59			; 
0b59			;Sqr16: 
0b59			;    ld de,#0040 
0b59			;    ld a,l 
0b59			;    ld l,h 
0b59			;    ld h,d 
0b59			;    or a 
0b59			;    ld b,8 
0b59			;Sqr16_Loop: 
0b59			;    sbc hl,de 
0b59			;    jr nc,Sqr16_Skip 
0b59			;    add hl,de 
0b59			;Sqr16_Skip: 
0b59			;    ccf 
0b59			;    rl d 
0b59			;    add a,a 
0b59			;    adc hl,hl 
0b59			;    add a,a 
0b59			;    adc hl,hl 
0b59			;    djnz Sqr16_Loop 
0b59			;    ret 
0b59			; 
0b59			; 
0b59			; Divide 8-bit values 
0b59			; In: Divide E by divider C 
0b59			; Out: A = result, B = rest 
0b59			; 
0b59			Div8: 
0b59 af			    xor a 
0b5a 06 08		    ld b,8 
0b5c			Div8_Loop: 
0b5c cb 13		    rl e 
0b5e 17			    rla 
0b5f 91			    sub c 
0b60 30 01		    jr nc,Div8_NoAdd 
0b62 81			    add a,c 
0b63			Div8_NoAdd: 
0b63 10 f7		    djnz Div8_Loop 
0b65 47			    ld b,a 
0b66 7b			    ld a,e 
0b67 17			    rla 
0b68 2f			    cpl 
0b69 c9			    ret 
0b6a			 
0b6a			; 
0b6a			; Multiply 8-bit value with a 16-bit value (unrolled) 
0b6a			; In: Multiply A with DE 
0b6a			; Out: HL = result 
0b6a			; 
0b6a			Mult12U: 
0b6a 2e 00		    ld l,0 
0b6c 87			    add a,a 
0b6d 30 01		    jr nc,Mult12U_NoAdd0 
0b6f 19			    add hl,de 
0b70			Mult12U_NoAdd0: 
0b70 29			    add hl,hl 
0b71 87			    add a,a 
0b72 30 01		    jr nc,Mult12U_NoAdd1 
0b74 19			    add hl,de 
0b75			Mult12U_NoAdd1: 
0b75 29			    add hl,hl 
0b76 87			    add a,a 
0b77 30 01		    jr nc,Mult12U_NoAdd2 
0b79 19			    add hl,de 
0b7a			Mult12U_NoAdd2: 
0b7a 29			    add hl,hl 
0b7b 87			    add a,a 
0b7c 30 01		    jr nc,Mult12U_NoAdd3 
0b7e 19			    add hl,de 
0b7f			Mult12U_NoAdd3: 
0b7f 29			    add hl,hl 
0b80 87			    add a,a 
0b81 30 01		    jr nc,Mult12U_NoAdd4 
0b83 19			    add hl,de 
0b84			Mult12U_NoAdd4: 
0b84 29			    add hl,hl 
0b85 87			    add a,a 
0b86 30 01		    jr nc,Mult12U_NoAdd5 
0b88 19			    add hl,de 
0b89			Mult12U_NoAdd5: 
0b89 29			    add hl,hl 
0b8a 87			    add a,a 
0b8b 30 01		    jr nc,Mult12U_NoAdd6 
0b8d 19			    add hl,de 
0b8e			Mult12U_NoAdd6: 
0b8e 29			    add hl,hl 
0b8f 87			    add a,a 
0b90 d0			    ret nc 
0b91 19			    add hl,de 
0b92 c9			    ret 
0b93			 
0b93			; 
0b93			; Multiply 8-bit value with a 16-bit value (right rotating) 
0b93			; In: Multiply A with DE 
0b93			;      Put lowest value in A for most efficient calculation 
0b93			; Out: HL = result 
0b93			; 
0b93			Mult12R: 
0b93 21 00 00		    ld hl,0 
0b96			Mult12R_Loop: 
0b96 cb 3f		    srl a 
0b98 30 01		    jr nc,Mult12R_NoAdd 
0b9a 19			    add hl,de 
0b9b			Mult12R_NoAdd: 
0b9b cb 23		    sla e 
0b9d cb 12		    rl d 
0b9f b7			    or a 
0ba0 c2 96 0b		    jp nz,Mult12R_Loop 
0ba3 c9			    ret 
0ba4			 
0ba4			; 
0ba4			; Multiply 16-bit values (with 32-bit result) 
0ba4			; In: Multiply BC with DE 
0ba4			; Out: BCHL = result 
0ba4			; 
0ba4			Mult32: 
0ba4 79			    ld a,c 
0ba5 48			    ld c,b 
0ba6 21 00 00		    ld hl,0 
0ba9 06 10		    ld b,16 
0bab			Mult32_Loop: 
0bab 29			    add hl,hl 
0bac 17			    rla 
0bad cb 11		    rl c 
0baf 30 07		    jr nc,Mult32_NoAdd 
0bb1 19			    add hl,de 
0bb2 ce 00		    adc a,0 
0bb4 d2 b8 0b		    jp nc,Mult32_NoAdd 
0bb7 0c			    inc c 
0bb8			Mult32_NoAdd: 
0bb8 10 f1		    djnz Mult32_Loop 
0bba 41			    ld b,c 
0bbb 4f			    ld c,a 
0bbc c9			    ret 
0bbd			 
0bbd			 
0bbd			 
0bbd			; 
0bbd			; Multiply 8-bit values 
0bbd			; In:  Multiply H with E 
0bbd			; Out: HL = result 
0bbd			; 
0bbd			Mult8: 
0bbd 16 00		    ld d,0 
0bbf 6a			    ld l,d 
0bc0 06 08		    ld b,8 
0bc2			Mult8_Loop: 
0bc2 29			    add hl,hl 
0bc3 30 01		    jr nc,Mult8_NoAdd 
0bc5 19			    add hl,de 
0bc6			Mult8_NoAdd: 
0bc6 10 fa		    djnz Mult8_Loop 
0bc8 c9			    ret 
0bc9			 
0bc9			 
0bc9			 
0bc9			 
0bc9			 
0bc9			 
0bc9			 
0bc9			 
0bc9			;;http://z80-heaven.wikidot.com/math 
0bc9			;;This divides DE by BC, storing the result in DE, remainder in HL 
0bc9			; 
0bc9			;DE_Div_BC:          ;1281-2x, x is at most 16 
0bc9			;     ld a,16        ;7 
0bc9			;     ld hl,0        ;10 
0bc9			;     jp $+5         ;10 
0bc9			;.DivLoop: 
0bc9			;       add hl,bc    ;-- 
0bc9			;       dec a        ;64 
0bc9			;       jr z,.DivLoopEnd        ;86 
0bc9			; 
0bc9			;       sla e        ;128 
0bc9			;       rl d         ;128 
0bc9			;       adc hl,hl    ;240 
0bc9			;       sbc hl,bc    ;240 
0bc9			;       jr nc,.DivLoop ;23|21 
0bc9			;       inc e        ;-- 
0bc9			;       jp .DivLoop+1 
0bc9			; 
0bc9			;.DivLoopEnd: 
0bc9			 
0bc9			;HL_Div_C: 
0bc9			;Inputs: 
0bc9			;     HL is the numerator 
0bc9			;     C is the denominator 
0bc9			;Outputs: 
0bc9			;     A is the remainder 
0bc9			;     B is 0 
0bc9			;     C is not changed 
0bc9			;     DE is not changed 
0bc9			;     HL is the quotient 
0bc9			; 
0bc9			;       ld b,16 
0bc9			;       xor a 
0bc9			;         add hl,hl 
0bc9			;         rla 
0bc9			;         cp c 
0bc9			;         jr c,$+4 
0bc9			;           inc l 
0bc9			;           sub c 
0bc9			;         djnz $-7 
0bc9			 
0bc9			; https://plutiedev.com/z80-add-8bit-to-16bit 
0bc9			 
0bc9			addatohl: 
0bc9 85			    add   a, l    ; A = A+L 
0bca 6f			    ld    l, a    ; L = A+L 
0bcb 8c			    adc   a, h    ; A = A+L+H+carry 
0bcc 95			    sub   l       ; A = H+carry 
0bcd 67			    ld    h, a    ; H = H+carry 
0bce c9			ret 
0bcf			 
0bcf			addatode: 
0bcf 83			    add   a, e    ; A = A+L 
0bd0 5f			    ld    e, a    ; L = A+L 
0bd1 8a			    adc   a, d    ; A = A+L+H+carry 
0bd2 93			    sub   e       ; A = H+carry 
0bd3 57			    ld    d, a    ; H = H+carry 
0bd4 c9			ret 
0bd5			 
0bd5			 
0bd5			addatobc: 
0bd5 81			    add   a, c    ; A = A+L 
0bd6 4f			    ld    c, a    ; L = A+L 
0bd7 88			    adc   a, b    ; A = A+L+H+carry 
0bd8 91			    sub   c       ; A = H+carry 
0bd9 47			    ld    b, a    ; H = H+carry 
0bda c9			ret 
0bdb			 
0bdb			subafromhl: 
0bdb			   ; If A=0 do nothing 
0bdb			    ; Otherwise flip A's sign. Since 
0bdb			    ; the upper byte becomes -1, also 
0bdb			    ; substract 1 from H. 
0bdb ed 44		    neg 
0bdd ca e6 0b		    jp    z, Skip 
0be0 25			    dec   h 
0be1			     
0be1			    ; Now add the low byte as usual 
0be1			    ; Two's complement takes care of 
0be1			    ; ensuring the result is correct 
0be1 85			    add   a, l 
0be2 6f			    ld    l, a 
0be3 8c			    adc   a, h 
0be4 95			    sub   l 
0be5 67			    ld    h, a 
0be6			Skip: 
0be6 c9				ret 
0be7			 
0be7			 
0be7			; compare hl and de 
0be7			; returns:  
0be7			; if hl = de, z=1, s=0, c0=0 
0be7			; if hl > de, z=0, s=0, c=0 
0be7			; if hl < de, z=0, s=1, c=1 
0be7			cmp16:	 
0be7 b7				or a 
0be8 ed 52			sbc hl,de 
0bea e0				ret po 
0beb 7c				ld a,h 
0bec 1f				rra 
0bed ee 40			xor 01000000B 
0bef 37				scf 
0bf0 8f				adc a,a 
0bf1 c9				ret 
0bf2			 
0bf2			 
0bf2			; test if hl contains zero   - A is destroyed 
0bf2			 
0bf2			ishlzero:    
0bf2 b7				or a     ; reset flags 
0bf3 7c				ld a, h 
0bf4 b5				or l        	 
0bf5			 
0bf5 c9				ret 
0bf6			 
0bf6			 
0bf6			 
0bf6			 
0bf6			if FORTH_ENABLE_FLOATMATH 
0bf6			;include "float/bbcmath.z80" 
0bf6			include "float/lpfpcalc.asm" 
0bf6			endif 
0bf6			 
0bf6			 
0bf6			; eof 
0bf6			 
# End of file firmware_maths.asm
0bf6			include "firmware_strings.asm"   ; string handling  
0bf6			 
0bf6			 
0bf6			; TODO string len 
0bf6			; input text string, end on cr with zero term 
0bf6			; a offset into frame buffer to start prompt 
0bf6			; d is max length 
0bf6			; e is display size TODO 
0bf6			; c is current cursor position 
0bf6			; hl is ptr to where string will be stored 
0bf6			 
0bf6			 
0bf6			; TODO check limit of buffer for new inserts 
0bf6			; TODO check insert does not push beyond buffer 
0bf6			; TODO scroll in a limited display area 
0bf6			; TODO scroll whole screen on page wrap 
0bf6			 
0bf6			 
0bf6			; TODO handle KEY_PREVWORD 
0bf6			; TODO handle KEY_NEXTWORD 
0bf6			; TODO handle KEY_HOME 
0bf6			; TODO handle KEY_END 
0bf6			; TODO use LCD cursor? 
0bf6			 
0bf6 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0bf9 81					add c 
0bfa 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0bfd 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
0c00 79					ld a, c 
0c01 cd c9 0b				call addatohl 
0c04 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0c07 7a					ld a,d 
0c08 32 75 ee			        ld (input_size), a       ; save length of input area 
0c0b 79					ld a, c 
0c0c 32 64 ee				ld (input_cursor),a      ; init cursor start position  
0c0f 7b					ld a,e 
0c10 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0c13					 
0c13					 
0c13			 
0c13			;		ld a,(input_ptr) 
0c13			;		ld (input_under_cursor),a 	; save what is under the cursor 
0c13			 
0c13			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0c13					; init cursor shape if not set by the cin routines 
0c13 21 d3 eb				ld hl, cursor_shape 
0c16 3e ff				ld a, 255 
0c18 77					ld (hl), a 
0c19 23					inc hl 
0c1a 3e 00				ld a, 0 
0c1c 77					ld (hl), a 
0c1d			 
0c1d 3e 0f				ld a, CUR_BLINK_RATE 
0c1f 32 6f ee				ld (input_cur_flash), a 
0c22 3e 01				ld a, 1 
0c24 32 6e ee				ld (input_cur_onoff),a 
0c27			 
0c27			;	if DEBUG_INPUT 
0c27			;		push af 
0c27			;		ld a, 'I' 
0c27			;		ld (debug_mark),a 
0c27			;		pop af 
0c27			;		CALLMONITOR 
0c27			;	endif 
0c27			.is1:		; main entry loop 
0c27			 
0c27			 
0c27			 
0c27					; pause 1ms 
0c27			 
0c27 3e 01				ld a, 1 
0c29 cd f3 08				call aDelayInMS 
0c2c			 
0c2c					; dec flash counter 
0c2c 3a 6f ee				ld a, (input_cur_flash) 
0c2f 3d					dec a 
0c30 32 6f ee				ld (input_cur_flash), a 
0c33 fe 00				cp 0 
0c35 20 0d				jr nz, .nochgstate 
0c37			 
0c37			 
0c37					; change state 
0c37 3a 6e ee				ld a,(input_cur_onoff) 
0c3a ed 44				neg 
0c3c 32 6e ee				ld (input_cur_onoff),a 
0c3f			 
0c3f			 
0c3f					; reset on change of state 
0c3f 3e 0f				ld a, CUR_BLINK_RATE 
0c41 32 6f ee				ld (input_cur_flash), a 
0c44			 
0c44			.nochgstate: 
0c44					 
0c44					 
0c44			 
0c44					; display cursor  
0c44			 
0c44			;		ld hl, (input_start) 
0c44			;		ld a, (input_cursor) 
0c44			;		call addatohl 
0c44			 
0c44					; get char under cursor and replace with cursor 
0c44 2a 78 ee		ld hl, (input_ptr) 
0c47			;		ld a, (hl) 
0c47			;		ld (input_under_cursor),a 
0c47			;		ld a, '_' 
0c47			;		ld (hl), a 
0c47			 
0c47					; display string 
0c47			 
0c47 ed 5b 76 ee			ld de, (input_start) 
0c4b 3a 73 ee				ld a, (input_at_pos) 
0c4e cd af 09				call str_at_display 
0c51			;	        call update_display 
0c51			 
0c51					; find place to put the cursor 
0c51			;		add h 
0c51			;		ld l, display_row_1 
0c51			;		sub l 
0c51			; (input_at_pos) 
0c51					;ld c, a 
0c51			;		ld a, (input_cursor) 
0c51			;		ld l, (input_at_pos) 
0c51			;		;ld b, h 
0c51			;		add l 
0c51			;		ld (input_at_cursor),a 
0c51					;ld l,h 
0c51			 
0c51			;		ld h, 0 
0c51			;		ld l,(input_at_pos) 
0c51			;		ld a, (input_cursor) 
0c51			;		call addatohl 
0c51			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c51			;		call subafromhl 
0c51			;		ld a,l 
0c51			;		ld (input_at_cursor), a 
0c51			 
0c51				if DEBUG_INPUT 
0c51					ld a, (hardware_diag) 
0c51					cp 0 
0c51					jr z, .skip_input_diag 
0c51			 
0c51					ld a,(input_at_pos) 
0c51					ld hl, LFSRSeed 
0c51					call hexout 
0c51					ld a, (input_cursor) 
0c51					ld hl, LFSRSeed+2 
0c51					call hexout 
0c51					ld a,(input_at_cursor) 
0c51					ld hl, LFSRSeed+4 
0c51					call hexout 
0c51			 
0c51					ld a,(input_cur_onoff) 
0c51					ld hl, LFSRSeed+6 
0c51					call hexout 
0c51			 
0c51					ld a,(input_cur_flash) 
0c51					ld hl, LFSRSeed+8 
0c51					call hexout 
0c51			 
0c51					ld a,(input_len) 
0c51					ld hl, LFSRSeed+10 
0c51					call hexout 
0c51					ld hl, LFSRSeed+12 
0c51					ld a, 0 
0c51					ld (hl),a 
0c51					ld a, display_row_4 
0c51					ld de, LFSRSeed 
0c51					call str_at_display 
0c51					.skip_input_diag: 
0c51				endif 
0c51			 
0c51					; decide on if we are showing the cursor this time round 
0c51			 
0c51 3a 6e ee				ld a, (input_cur_onoff) 
0c54 fe ff				cp 255 
0c56 28 13				jr z, .skipcur 
0c58			 
0c58			 
0c58 3a 71 ee				ld a,(input_at_cursor) 
0c5b 11 d3 eb				ld de, cursor_shape 
0c5e cd af 09				call str_at_display 
0c61			 
0c61					; save length of current input string 
0c61 2a 76 ee				ld hl, (input_start) 
0c64 cd 27 10				call strlenz 
0c67 7d					ld a,l 
0c68 32 69 ee				ld (input_len),a 
0c6b			 
0c6b			.skipcur: 
0c6b			 
0c6b cd bf 09			        call update_display 
0c6e					 
0c6e			 
0c6e			 
0c6e					; wait 
0c6e				 
0c6e					; TODO loop without wait to flash the cursor and char under cursor	 
0c6e cd 29 59				call cin    ; _wait 
0c71			 
0c71 fe 00				cp 0 
0c73 ca 27 0c				jp z, .is1 
0c76			 
0c76					; get ptr to char to input into 
0c76			 
0c76 4f					ld c,a 
0c77 2a 76 ee				ld hl, (input_start) 
0c7a 3a 64 ee				ld a, (input_cursor) 
0c7d cd c9 0b				call addatohl 
0c80 22 78 ee				ld (input_ptr), hl 
0c83 79					ld a,c 
0c84			 
0c84					; replace char under cursor 
0c84			 
0c84			;		ld hl, (input_ptr) 
0c84			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0c84			;		ld (hl), a 
0c84			 
0c84			;	if DEBUG_INPUT 
0c84			;		push af 
0c84			;		ld a, 'i' 
0c84			;		ld (debug_mark),a 
0c84			;		pop af 
0c84			;		CALLMONITOR 
0c84			;	endif 
0c84 fe 0e				cp KEY_HOME 
0c86 20 0e				jr nz, .iske 
0c88			 
0c88 3a 73 ee				ld a, (input_at_pos) 
0c8b 32 71 ee				ld (input_at_cursor),a 
0c8e 3e 00				ld a, 0 
0c90 32 64 ee				ld (input_cursor), a 
0c93 c3 27 0c				jp .is1 
0c96					 
0c96 fe 0f		.iske:		cp KEY_END 
0c98 20 03				jr nz, .isknw 
0c9a c3 27 0c				jp .is1 
0c9d			 
0c9d fe 06		.isknw:		cp KEY_NEXTWORD 
0c9f 20 1b				jr nz, .iskpw 
0ca1			 
0ca1 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
0ca4 7e					ld a,(hl)	 
0ca5 fe 00				cp 0 
0ca7 ca 27 0c				jp z, .is1    ; end of string 
0caa fe 20				cp ' ' 
0cac ca 27 0c				jp z, .is1    ; end of word 
0caf 23					inc hl 
0cb0 22 78 ee				ld (input_ptr), hl 
0cb3 3a 71 ee				ld a, (input_at_cursor) 
0cb6 3c					inc a 
0cb7 32 71 ee				ld (input_at_cursor), a 
0cba 18 e5				jr .isknwm 
0cbc			 
0cbc fe 07		.iskpw:		cp KEY_PREVWORD 
0cbe 20 1b				jr nz, .iskl 
0cc0			.iskpwm:	 
0cc0 2a 78 ee				ld hl, (input_ptr) 
0cc3 7e					ld a,(hl)	 
0cc4 fe 00				cp 0  
0cc6 ca 27 0c				jp z, .is1    ; end of string 
0cc9 fe 20				cp ' ' 
0ccb ca 27 0c				jp z, .is1    ; end of word 
0cce 2b					dec hl 
0ccf 22 78 ee				ld (input_ptr), hl 
0cd2 3a 71 ee				ld a, (input_at_cursor) 
0cd5 3d					dec a 
0cd6 32 71 ee				ld (input_at_cursor), a 
0cd9 18 e5				jr .iskpwm 
0cdb			 
0cdb			 
0cdb fe 0b		.iskl:		cp KEY_LEFT 
0cdd 20 27				jr nz, .isk1 
0cdf			 
0cdf 3a 64 ee				ld a, (input_cursor) 
0ce2			 
0ce2 fe 00				cp 0 
0ce4 ca 27 0c				jp z, .is1 		; at start of line to ignore  
0ce7			 
0ce7 3d					dec  a 		; TODO check underflow 
0ce8 32 64 ee				ld (input_cursor), a 
0ceb			 
0ceb 2a 78 ee				ld hl, (input_ptr) 
0cee 2b					dec hl 
0cef 22 78 ee				ld (input_ptr), hl 
0cf2					 
0cf2 3a 71 ee				ld a, (input_at_cursor) 
0cf5 3d					dec a 
0cf6 32 71 ee				ld (input_at_cursor), a 
0cf9			 
0cf9 3e 01				ld a, 1		; show cursor moving 
0cfb 32 6e ee				ld (input_cur_onoff),a 
0cfe 3e 0f				ld a, CUR_BLINK_RATE 
0d00 32 6f ee				ld (input_cur_flash), a 
0d03			 
0d03 c3 27 0c				jp .is1 
0d06			 
0d06 fe 0c		.isk1:		cp KEY_RIGHT 
0d08 20 2a				jr nz, .isk2 
0d0a			 
0d0a 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0d0d 5f					ld e,a 
0d0e 3a 64 ee				ld a, (input_cursor) 
0d11 bb					cp e 
0d12 ca 27 0c				jp z, .is1		; at the end of string so dont go right 
0d15			 
0d15 3c					inc  a 		; TODO check overflow 
0d16 32 64 ee				ld (input_cursor), a 
0d19			 
0d19 3a 71 ee				ld a, (input_at_cursor) 
0d1c 3c					inc a 
0d1d 32 71 ee				ld (input_at_cursor), a 
0d20			 
0d20 2a 78 ee				ld hl, (input_ptr) 
0d23 23					inc hl 
0d24 22 78 ee				ld (input_ptr), hl 
0d27			 
0d27 3e 01				ld a, 1		; show cursor moving 
0d29 32 6e ee				ld (input_cur_onoff),a 
0d2c 3e 0f				ld a, CUR_BLINK_RATE 
0d2e 32 6f ee				ld (input_cur_flash), a 
0d31			 
0d31 c3 27 0c				jp .is1 
0d34			 
0d34 fe 05		.isk2:		cp KEY_UP 
0d36			 
0d36 20 26				jr nz, .isk3 
0d38			 
0d38					; swap last command with the current on 
0d38			 
0d38					; move cursor to start of string 
0d38 2a 76 ee				ld hl, (input_start) 
0d3b 22 78 ee				ld (input_ptr), hl 
0d3e			 
0d3e 3a 73 ee				ld a, (input_at_pos) 
0d41 32 71 ee				ld (input_at_cursor), a 
0d44			 
0d44 3e 00				ld a, 0 
0d46 32 64 ee				ld (input_cursor), a 
0d49					 
0d49					; swap input and last command buffers 
0d49			 
0d49 21 87 e6				ld hl, os_cli_cmd 
0d4c 11 86 e7				ld de, os_last_cmd 
0d4f 06 ff				ld b, 255 
0d51 7e			.swap1:		ld a, (hl) 
0d52 4f					ld c,a 
0d53 1a					ld a, (de) 
0d54 77					ld (hl), a 
0d55 79					ld a,c 
0d56 12					ld (de),a 
0d57 23					inc hl 
0d58 13					inc de 
0d59 10 f6				djnz .swap1 
0d5b			 
0d5b			 
0d5b			 
0d5b			 
0d5b			 
0d5b c3 27 0c				jp .is1 
0d5e			 
0d5e fe 08		.isk3:		cp KEY_BS 
0d60 20 3c				jr nz, .isk4 
0d62			 
0d62 3a 64 ee				ld a, (input_cursor) 
0d65			 
0d65 fe 00				cp 0 
0d67 ca 27 0c				jp z, .is1 		; at start of line to ignore  
0d6a			 
0d6a 3d					dec  a 		; TODO check underflow 
0d6b 32 64 ee				ld (input_cursor), a 
0d6e			 
0d6e					; hl is source 
0d6e					; de needs to be source - 1 
0d6e			 
0d6e			;		ld a, 0 
0d6e			;		dec hl 
0d6e			;		ld (hl), a 
0d6e			 
0d6e 2a 78 ee				ld hl, (input_ptr) 
0d71 2b					dec hl 
0d72 22 78 ee				ld (input_ptr), hl 
0d75			 
0d75					; shift all data 
0d75			 
0d75 e5					push hl 
0d76 23					inc hl 
0d77 d1					pop de 
0d78 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0d7b 4f					ld c,a 
0d7c 06 00				ld b,0 
0d7e ed b0				ldir  
0d80			 
0d80			 
0d80			 
0d80			 
0d80 3a 71 ee				ld a, (input_at_cursor) 
0d83 3d					dec a 
0d84 32 71 ee				ld (input_at_cursor), a 
0d87			 
0d87			 
0d87 3e 01				ld a, 1		; show cursor moving 
0d89 32 6e ee				ld (input_cur_onoff),a 
0d8c 3e 0f				ld a, CUR_BLINK_RATE 
0d8e 32 6f ee				ld (input_cur_flash), a 
0d91			 
0d91					; remove char 
0d91 3a 71 ee				ld a, (input_at_cursor) 
0d94 3c					inc a 
0d95 11 1f 0e				ld de,.iblank 
0d98 cd af 09				call str_at_display 
0d9b			 
0d9b c3 27 0c				jp .is1 
0d9e			 
0d9e fe 0d		.isk4:		cp KEY_CR 
0da0 28 6c				jr z, .endinput 
0da2			 
0da2					; else add the key press to the end 
0da2			 
0da2 4f					ld c, a			; save key pressed 
0da3			 
0da3 7e					ld a,(hl)		; get what is currently under char 
0da4			 
0da4 fe 00				cp 0			; we are at the end of the string 
0da6 20 2f				jr nz, .onchar 
0da8					 
0da8					; add a char to the end of the string 
0da8				 
0da8 71					ld (hl),c 
0da9 23					inc hl 
0daa			;		ld a,' ' 
0daa			;		ld (hl),a 
0daa			;		inc hl 
0daa 3e 00				ld a,0 
0dac 77					ld (hl),a 
0dad 2b					dec hl 
0dae			 
0dae 3a 64 ee				ld a, (input_cursor) 
0db1 3c					inc a				; TODO check max string length and scroll  
0db2 32 64 ee				ld (input_cursor), a		; inc cursor pos 
0db5							 
0db5 3a 71 ee				ld a, (input_at_cursor) 
0db8 3c					inc a 
0db9 32 71 ee				ld (input_at_cursor), a 
0dbc			 
0dbc 2a 78 ee				ld hl, (input_ptr) 
0dbf 23					inc hl 
0dc0 22 78 ee				ld (input_ptr), hl 
0dc3			 
0dc3 2a 78 ee				ld hl, (input_ptr) 
0dc6 23					inc hl 
0dc7 22 78 ee				ld (input_ptr), hl 
0dca			;	if DEBUG_INPUT 
0dca			;		push af 
0dca			;		ld a, '+' 
0dca			;		ld (debug_mark),a 
0dca			;		pop af 
0dca			;		CALLMONITOR 
0dca			;	endif 
0dca 3e 01				ld a, 1		; show cursor moving 
0dcc 32 6e ee				ld (input_cur_onoff),a 
0dcf 3e 0f				ld a, CUR_BLINK_RATE 
0dd1 32 6f ee				ld (input_cur_flash), a 
0dd4 c3 27 0c				jp .is1 
0dd7					 
0dd7			 
0dd7			 
0dd7					; if on a char then insert 
0dd7			.onchar: 
0dd7			 
0dd7					; TODO over flow check: make sure insert does not blow out buffer 
0dd7			 
0dd7					; need to do some maths to use lddr 
0dd7			 
0dd7 e5					push hl   ; save char pos 
0dd8 c5					push bc 
0dd9			 
0dd9 2a 76 ee				ld hl, (input_start) 
0ddc 3a 69 ee				ld a, (input_len) 
0ddf cd c9 0b				call addatohl  		; end of string 
0de2 23					inc hl 
0de3 23					inc hl		; past zero term 
0de4 e5					push hl 
0de5 23					inc hl 
0de6 e5					push hl  
0de7			 
0de7								; start and end of lddr set, now how much to move? 
0de7			 
0de7							 
0de7 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0dea 47					ld b,a 
0deb 3a 69 ee				ld a,(input_len) 
0dee 5f					ld e,a 
0def 90					sub b 
0df0 3c					inc a		;?? 
0df1 3c					inc a		;?? 
0df2 3c					inc a		;?? 
0df3			 
0df3 06 00				ld b,0 
0df5 4f					ld c,a 
0df6			 
0df6				if DEBUG_INPUT 
0df6					push af 
0df6					ld a, 'i' 
0df6					ld (debug_mark),a 
0df6					pop af 
0df6			;		CALLMONITOR 
0df6				endif 
0df6 d1					pop de 
0df7 e1					pop hl 
0df8				if DEBUG_INPUT 
0df8					push af 
0df8					ld a, 'I' 
0df8					ld (debug_mark),a 
0df8					pop af 
0df8			;		CALLMONITOR 
0df8				endif 
0df8 ed b8				lddr 
0dfa				 
0dfa			 
0dfa			 
0dfa					; TODO have a key for insert/overwrite mode???? 
0dfa c1					pop bc 
0dfb e1					pop hl 
0dfc 71					ld (hl), c		; otherwise overwrite current char 
0dfd					 
0dfd			 
0dfd			 
0dfd			 
0dfd 3a 64 ee				ld a, (input_cursor) 
0e00 3c					inc  a 		; TODO check overflow 
0e01 32 64 ee				ld (input_cursor), a 
0e04			 
0e04 3a 71 ee				ld a, (input_at_cursor) 
0e07 3c					inc a 
0e08 32 71 ee				ld (input_at_cursor), a 
0e0b			 
0e0b c3 27 0c				jp .is1 
0e0e			 
0e0e			.endinput:	; TODO look for end of string 
0e0e			 
0e0e					; add trailing space for end of token 
0e0e			 
0e0e 2a 76 ee				ld hl, (input_start) 
0e11 3a 69 ee				ld a,(input_len) 
0e14 cd c9 0b				call addatohl 
0e17 3e 20				ld a, ' ' 
0e19 77					ld (hl),a 
0e1a					; TODO eof of parse marker 
0e1a			 
0e1a 23					inc hl 
0e1b 3e 00				ld a, 0 
0e1d 77					ld (hl),a 
0e1e			 
0e1e			 
0e1e c9					ret 
0e1f			 
0e1f .. 00		.iblank: db " ",0 
0e21			 
0e21			 
0e21 32 73 ee		input_str_prev:	ld (input_at_pos), a 
0e24 22 76 ee				ld (input_start), hl 
0e27 3e 01				ld a,1			; add cursor 
0e29 77					ld (hl),a 
0e2a 23					inc hl 
0e2b 3e 00				ld a,0 
0e2d 77					ld (hl),a 
0e2e 22 78 ee				ld (input_ptr), hl 
0e31 7a					ld a,d 
0e32 32 75 ee				ld (input_size), a 
0e35 3e 00				ld a,0 
0e37 32 64 ee				ld (input_cursor),a 
0e3a			.instr1:	 
0e3a			 
0e3a					; TODO do block cursor 
0e3a					; TODO switch cursor depending on the modifer key 
0e3a			 
0e3a					; update cursor shape change on key hold 
0e3a			 
0e3a 2a 78 ee				ld hl, (input_ptr) 
0e3d 2b					dec hl 
0e3e 3a d3 eb				ld a,(cursor_shape) 
0e41 77					ld (hl), a 
0e42			 
0e42					; display entered text 
0e42 3a 73 ee				ld a,(input_at_pos) 
0e45 cd 3e 58		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e48 ed 5b 76 ee	            	LD   de, (input_start) 
0e4c cd 33 58		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e4f			 
0e4f cd 29 59				call cin 
0e52 fe 00				cp 0 
0e54 28 e4				jr z, .instr1 
0e56			 
0e56					; proecess keyboard controls first 
0e56			 
0e56 2a 78 ee				ld hl,(input_ptr) 
0e59			 
0e59 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0e5b 28 5a				jr z, .instrcr 
0e5d			 
0e5d fe 08				cp KEY_BS 	; back space 
0e5f 20 0f				jr nz, .instr2 
0e61					; process back space 
0e61			 
0e61					; TODO stop back space if at start of string 
0e61 2b					dec hl 
0e62 2b					dec hl ; to over write cursor 
0e63 3a d3 eb				ld a,(cursor_shape) 
0e66					;ld a,0 
0e66 77					ld (hl),a 
0e67 23					inc hl 
0e68 3e 20				ld a," " 
0e6a 77					ld (hl),a 
0e6b 22 78 ee				ld (input_ptr),hl 
0e6e					 
0e6e			 
0e6e 18 ca				jr .instr1 
0e70			 
0e70 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0e72 20 06				jr nz, .instr3 
0e74 2b					dec hl 
0e75 22 78 ee				ld (input_ptr),hl 
0e78 18 c0				jr .instr1 
0e7a				 
0e7a fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0e7c 20 06				jr nz, .instr4 
0e7e 23					inc hl 
0e7f 22 78 ee				ld (input_ptr),hl 
0e82 18 b6				jr .instr1 
0e84			 
0e84 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0e86 20 06				jr nz, .instr5 
0e88 2b					dec hl 
0e89 22 78 ee				ld (input_ptr),hl 
0e8c 18 ac				jr .instr1 
0e8e			 
0e8e fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0e90 20 06				jr nz, .instr6 
0e92 2b					dec hl 
0e93 22 78 ee				ld (input_ptr),hl 
0e96 18 a2				jr .instr1 
0e98 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0e9a 20 0b				jr nz, .instrnew 
0e9c			 
0e9c 21 60 e3			ld hl, scratch 
0e9f 11 86 e7			ld de, os_last_cmd 
0ea2 cd c0 0e			call strcpy 
0ea5 18 93				jr .instr1 
0ea7			 
0ea7			 
0ea7			.instrnew:	; no special key pressed to see if we have room to store it 
0ea7			 
0ea7					; TODO do string size test 
0ea7			 
0ea7 2b					dec hl ; to over write cursor 
0ea8 77					ld (hl),a 
0ea9 23					inc hl 
0eaa 3a d3 eb				ld a,(cursor_shape) 
0ead 77					ld (hl),a 
0eae 23					inc hl 
0eaf 3e 00				ld a,0 
0eb1 77					ld (hl),a 
0eb2			 
0eb2 22 78 ee				ld (input_ptr),hl 
0eb5					 
0eb5 18 83				jr .instr1 
0eb7 2b			.instrcr:	dec hl		; remove cursor 
0eb8 3e 20				ld a,' '	; TODO add a trailing space for safety 
0eba 77					ld (hl),a 
0ebb 23					inc hl 
0ebc 3e 00				ld a,0 
0ebe 77					ld (hl),a 
0ebf			 
0ebf			 
0ebf					; if at end of line scroll up    
0ebf					; TODO detecting only end of line 4 for scroll up  
0ebf			 
0ebf					;ld   
0ebf			 
0ebf c9					ret 
0ec0			 
0ec0			 
0ec0			; strcpy hl = dest, de source 
0ec0			 
0ec0 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ec1 b7			            OR   A              ;Null terminator? 
0ec2 c8			            RET  Z              ;Yes, so finished 
0ec3 1a					ld a,(de) 
0ec4 77					ld (hl),a 
0ec5 13			            INC  DE             ;Point to next character 
0ec6 23					inc hl 
0ec7 18 f7		            JR   strcpy       ;Repeat 
0ec9 c9					ret 
0eca			 
0eca			 
0eca			; TODO string_at  
0eca			; pass string which starts with lcd offset address and then null term string 
0eca			 
0eca			; TODO string to dec 
0eca			; TODO string to hex 
0eca			; TODO byte to string hex 
0eca			; TODO byte to string dec 
0eca			 
0eca			 
0eca			 
0eca			; from z80uartmonitor 
0eca			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0eca			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0eca			; pass hl for where to put the text 
0eca			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0eca c5			hexout:	PUSH BC 
0ecb f5					PUSH AF 
0ecc 47					LD B, A 
0ecd					; Upper nybble 
0ecd cb 3f				SRL A 
0ecf cb 3f				SRL A 
0ed1 cb 3f				SRL A 
0ed3 cb 3f				SRL A 
0ed5 cd e5 0e				CALL tohex 
0ed8 77					ld (hl),a 
0ed9 23					inc hl	 
0eda					 
0eda					; Lower nybble 
0eda 78					LD A, B 
0edb e6 0f				AND 0FH 
0edd cd e5 0e				CALL tohex 
0ee0 77					ld (hl),a 
0ee1 23					inc hl	 
0ee2					 
0ee2 f1					POP AF 
0ee3 c1					POP BC 
0ee4 c9					RET 
0ee5					 
0ee5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ee5			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0ee5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ee5			tohex: 
0ee5 e5					PUSH HL 
0ee6 d5					PUSH DE 
0ee7 16 00				LD D, 0 
0ee9 5f					LD E, A 
0eea 21 f2 0e				LD HL, .DATA 
0eed 19					ADD HL, DE 
0eee 7e					LD A, (HL) 
0eef d1					POP DE 
0ef0 e1					POP HL 
0ef1 c9					RET 
0ef2			 
0ef2			.DATA: 
0ef2 30					DEFB	30h	; 0 
0ef3 31					DEFB	31h	; 1 
0ef4 32					DEFB	32h	; 2 
0ef5 33					DEFB	33h	; 3 
0ef6 34					DEFB	34h	; 4 
0ef7 35					DEFB	35h	; 5 
0ef8 36					DEFB	36h	; 6 
0ef9 37					DEFB	37h	; 7 
0efa 38					DEFB	38h	; 8 
0efb 39					DEFB	39h	; 9 
0efc 41					DEFB	41h	; A 
0efd 42					DEFB	42h	; B 
0efe 43					DEFB	43h	; C 
0eff 44					DEFB	44h	; D 
0f00 45					DEFB	45h	; E 
0f01 46					DEFB	46h	; F 
0f02			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0f02			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0f02			;;    subtract $30, if result > 9 then subtract $7 more 
0f02			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0f02			atohex: 
0f02 d6 30				SUB $30 
0f04 fe 0a				CP 10 
0f06 f8					RET M		; If result negative it was 0-9 so we're done 
0f07 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0f09 c9					RET		 
0f0a			 
0f0a			 
0f0a			 
0f0a			 
0f0a			; Get 2 ASCII characters as hex byte from pointer in hl 
0f0a			 
0f0a			BYTERD: 
0f0a 16 00			LD	D,00h		;Set up 
0f0c cd 14 0f			CALL	HEXCON		;Get byte and convert to hex 
0f0f 87				ADD	A,A		;First nibble so 
0f10 87				ADD	A,A		;multiply by 16 
0f11 87				ADD	A,A		; 
0f12 87				ADD	A,A		; 
0f13 57				LD	D,A		;Save hi nibble in D 
0f14			HEXCON: 
0f14 7e				ld a, (hl)		;Get next chr 
0f15 23				inc hl 
0f16 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0f18 fe 0a			CP	00Ah		;Is it 0-9 ? 
0f1a 38 02			JR	C,NALPHA	;If so miss next bit 
0f1c d6 07			SUB	007h		;Else convert alpha 
0f1e			NALPHA: 
0f1e b2				OR	D		;Add hi nibble back 
0f1f c9				RET			; 
0f20			 
0f20			 
0f20			; 
0f20			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f20			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f20			; characters (0-9a-f) are accepted. 
0f20			; 
0f20			;get_word        push    af 
0f20			;                call    get_byte        ; Get the upper byte 
0f20			;                ld      h, a 
0f20			;                call    get_byte        ; Get the lower byte 
0f20			;                ld      l, a 
0f20			;                pop     af 
0f20			;                ret 
0f20			; 
0f20			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f20			; the routine get_nibble is used only valid characters are accepted - the  
0f20			; input routine only accepts characters 0-9a-f. 
0f20			; 
0f20 c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f21 7e					ld a,(hl) 
0f22 23					inc hl 
0f23 cd 48 0f		                call    nibble2val      ; Get upper nibble 
0f26 cb 07		                rlc     a 
0f28 cb 07		                rlc     a 
0f2a cb 07		                rlc     a 
0f2c cb 07		                rlc     a 
0f2e 47			                ld      b, a            ; Save upper four bits 
0f2f 7e					ld a,(hl) 
0f30 cd 48 0f		                call    nibble2val      ; Get lower nibble 
0f33 b0			                or      b               ; Combine both nibbles 
0f34 c1			                pop     bc              ; Restore B (and C) 
0f35 c9			                ret 
0f36			; 
0f36			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f36			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f36			; to the serial line interface. The lower 4 bits of A contain the value of  
0f36			; that particular digit. 
0f36			; 
0f36			;get_nibble      ld a,(hl)           ; Read a character 
0f36			;                call    to_upper        ; Convert to upper case 
0f36			;                call    is_hex          ; Was it a hex digit? 
0f36			;                jr      nc, get_nibble  ; No, get another character 
0f36			 ;               call    nibble2val      ; Convert nibble to value 
0f36			 ;               call    print_nibble 
0f36			 ;               ret 
0f36			; 
0f36			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f36			; A valid hexadecimal digit is denoted by a set C flag. 
0f36			; 
0f36			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f36			;                ret     nc              ; Yes 
0f36			;                cp      '0'             ; Less than '0'? 
0f36			;                jr      nc, is_hex_1    ; No, continue 
0f36			;                ccf                     ; Complement carry (i.e. clear it) 
0f36			;                ret 
0f36			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f36			;                ret     c               ; Yes 
0f36			;                cp      'A'             ; Less than 'A'? 
0f36			;                jr      nc, is_hex_2    ; No, continue 
0f36			;                ccf                     ; Yes - clear carry and return 
0f36			;                ret 
0f36			;is_hex_2        scf                     ; Set carry 
0f36			;                ret 
0f36			; 
0f36			; Convert a single character contained in A to upper case: 
0f36			; 
0f36 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f38 d8			                ret     c 
0f39 fe 7b		                cp      'z' + 1         ; > 'z'? 
0f3b d0			                ret     nc              ; Nothing to do, either 
0f3c e6 5f		                and     $5f             ; Convert to upper case 
0f3e c9			                ret 
0f3f			 
0f3f			 
0f3f			to_lower: 
0f3f			 
0f3f			   ; if char is in [A-Z] make it lower case 
0f3f			 
0f3f			   ; enter : a = char 
0f3f			   ; exit  : a = lower case char 
0f3f			   ; uses  : af 
0f3f			 
0f3f fe 41		   cp 'A' 
0f41 d8			   ret c 
0f42			    
0f42 fe 5b		   cp 'Z'+1 
0f44 d0			   ret nc 
0f45			    
0f45 f6 20		   or $20 
0f47 c9			   ret 
0f48			 
0f48			; 
0f48			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f48			; corresponding value in A. 
0f48			; 
0f48 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f4a 38 02		                jr      c, nibble2val_1 ; Yes 
0f4c d6 07		                sub     7               ; Adjust for A-F 
0f4e d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f50 e6 0f		                and     $f              ; Only return lower 4 bits 
0f52 c9			                ret 
0f53			; 
0f53			; Print_nibble prints a single hex nibble which is contained in the lower  
0f53			; four bits of A: 
0f53			; 
0f53			;print_nibble    push    af              ; We won't destroy the contents of A 
0f53			;                and     $f              ; Just in case... 
0f53			;                add     a, '0'             ; If we have a digit we are done here. 
0f53			;                cp      '9' + 1         ; Is the result > 9? 
0f53			;                jr      c, print_nibble_1 
0f53			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f53			;print_nibble_1  call    putc            ; Print the nibble and 
0f53			;                pop     af              ; restore the original value of A 
0f53			;                ret 
0f53			;; 
0f53			;; Send a CR/LF pair: 
0f53			; 
0f53			;crlf            push    af 
0f53			;                ld      a, cr 
0f53			;                call    putc 
0f53			;                ld      a, lf 
0f53			;                call    putc 
0f53			;                pop     af 
0f53			;                ret 
0f53			; 
0f53			; Print_word prints the four hex digits of a word to the serial line. The  
0f53			; word is expected to be in HL. 
0f53			; 
0f53			;print_word      push    hl 
0f53			;                push    af 
0f53			;                ld      a, h 
0f53			;                call    print_byte 
0f53			;                ld      a, l 
0f53			;                call    print_byte 
0f53			;                pop     af 
0f53			;                pop     hl 
0f53			;                ret 
0f53			; 
0f53			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f53			; The byte to be printed is expected to be in A. 
0f53			; 
0f53			;print_byte      push    af              ; Save the contents of the registers 
0f53			;                push    bc 
0f53			;                ld      b, a 
0f53			;                rrca 
0f53			;                rrca 
0f53			;                rrca 
0f53			;                rrca 
0f53			;                call    print_nibble    ; Print high nibble 
0f53			;                ld      a, b 
0f53			;                call    print_nibble    ; Print low nibble 
0f53			;                pop     bc              ; Restore original register contents 
0f53			;                pop     af 
0f53			;                ret 
0f53			 
0f53			 
0f53			 
0f53			 
0f53			 
0f53			fourehexhl:  
0f53 7e				ld a,(hl) 
0f54 cd 02 0f			call atohex 
0f57 cb 3f				SRL A 
0f59 cb 3f				SRL A 
0f5b cb 3f				SRL A 
0f5d cb 3f				SRL A 
0f5f 47				ld b, a 
0f60 23				inc hl 
0f61 7e				ld a,(hl) 
0f62 23				inc hl 
0f63 cd 02 0f			call atohex 
0f66 80				add b 
0f67 57				ld d,a 
0f68 7e				ld a,(hl) 
0f69 cd 02 0f			call atohex 
0f6c cb 3f				SRL A 
0f6e cb 3f				SRL A 
0f70 cb 3f				SRL A 
0f72 cb 3f				SRL A 
0f74 47				ld b, a 
0f75 23				inc hl 
0f76 7e				ld a,(hl) 
0f77 23				inc hl 
0f78 cd 02 0f			call atohex 
0f7b 80				add b 
0f7c 5f				ld e, a 
0f7d d5				push de 
0f7e e1				pop hl 
0f7f c9				ret 
0f80			 
0f80			; pass hl. returns z set if the byte at hl is a digit 
0f80			;isdigithl:  
0f80			;	push bc 
0f80			;	ld a,(hl) 
0f80			;	cp ':' 
0f80			;	jr nc, .isdf 		; > 
0f80			;	cp '0' 
0f80			;	jr c, .isdf		; < 
0f80			; 
0f80			;	; TODO find a better way to set z 
0f80			; 
0f80			;	ld b,a 
0f80			;	cp b 
0f80			;	pop bc 
0f80			;	ret 
0f80			; 
0f80			;.isdf:	; not digit so clear z 
0f80			; 
0f80			;	; TODO find a better way to unset z 
0f80			; 
0f80			;	ld b,a 
0f80			;	inc b 
0f80			;	cp b 
0f80			; 
0f80			;	pop bc 
0f80			;	ret 
0f80				 
0f80				 
0f80			 
0f80			 
0f80			; pass hl as the four byte address to load 
0f80			 
0f80			get_word_hl:  
0f80 e5				push hl 
0f81 cd 20 0f			call get_byte 
0f84				 
0f84 47				ld b, a 
0f85			 
0f85 e1				pop hl 
0f86 23				inc hl 
0f87 23				inc hl 
0f88			 
0f88			; TODO not able to handle a-f  
0f88 7e				ld a,(hl) 
0f89			;	;cp ':' 
0f89			;	cp 'g' 
0f89			;	jr nc, .single_byte_hl 		; > 
0f89			;	cp 'G' 
0f89			;	jr nc, .single_byte_hl 		; > 
0f89			;	cp '0' 
0f89			;	jr c, .single_byte_hl		; < 
0f89			 
0f89				;call isdigithl 
0f89 fe 00			cp 0 
0f8b 28 06			jr z, .single_byte_hl 
0f8d			 
0f8d			.getwhln:   ; hex word so get next byte 
0f8d			 
0f8d cd 20 0f			call get_byte 
0f90 6f				ld l, a 
0f91 60				ld h,b 
0f92 c9				ret 
0f93 68			.single_byte_hl:   ld l,b 
0f94 26 00				ld h,0 
0f96 c9					ret 
0f97			 
0f97			 
0f97			 
0f97			 
0f97 21 1b 17			ld hl,asc+1 
0f9a			;	ld a, (hl) 
0f9a			;	call nibble2val 
0f9a cd 20 0f			call get_byte 
0f9d			 
0f9d			;	call fourehexhl 
0f9d 32 94 e3			ld (scratch+52),a 
0fa0				 
0fa0 21 92 e3			ld hl,scratch+50 
0fa3 22 83 e6			ld (os_cur_ptr),hl 
0fa6			 
0fa6 c9				ret 
0fa7			 
0fa7			 
0fa7			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0fa7			 
0fa7			; Decimal Unsigned Version 
0fa7			 
0fa7			;Number in a to decimal ASCII 
0fa7			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0fa7			;Example: display a=56 as "056" 
0fa7			;input: a = number 
0fa7			;Output: a=0,value of a in the screen 
0fa7			;destroys af,bc (don't know about hl and de) 
0fa7			DispAToASCII: 
0fa7 0e 9c			ld	c,-100 
0fa9 cd b3 0f			call	.Na1 
0fac 0e f6			ld	c,-10 
0fae cd b3 0f			call	.Na1 
0fb1 0e ff			ld	c,-1 
0fb3 06 2f		.Na1:	ld	b,'0'-1 
0fb5 04			.Na2:	inc	b 
0fb6 81				add	a,c 
0fb7 38 fc			jr	c,.Na2 
0fb9 91				sub	c		;works as add 100/10/1 
0fba f5				push af		;safer than ld c,a 
0fbb 78				ld	a,b		;char is in b 
0fbc			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0fbc f1				pop af		;safer than ld a,c 
0fbd c9				ret 
0fbe			 
0fbe			; Decimal Signed Version 
0fbe			 
0fbe			; DispA 
0fbe			; -------------------------------------------------------------- 
0fbe			; Converts a signed integer value to a zero-terminated ASCII 
0fbe			; string representative of that value (using radix 10). 
0fbe			; -------------------------------------------------------------- 
0fbe			; INPUTS: 
0fbe			;     HL     Value to convert (two's complement integer). 
0fbe			;     DE     Base address of string destination. (pointer). 
0fbe			; -------------------------------------------------------------- 
0fbe			; OUTPUTS: 
0fbe			;     None 
0fbe			; -------------------------------------------------------------- 
0fbe			; REGISTERS/MEMORY DESTROYED 
0fbe			; AF HL 
0fbe			; -------------------------------------------------------------- 
0fbe			 
0fbe			;DispHLToASCII: 
0fbe			;   push    de 
0fbe			;   push    bc 
0fbe			; 
0fbe			;; Detect sign of HL. 
0fbe			;    bit    7, h 
0fbe			;    jr     z, ._DoConvert 
0fbe			; 
0fbe			;; HL is negative. Output '-' to string and negate HL. 
0fbe			;    ld     a, '-' 
0fbe			;    ld     (de), a 
0fbe			;    inc    de 
0fbe			; 
0fbe			;; Negate HL (using two's complement) 
0fbe			;    xor    a 
0fbe			;    sub    l 
0fbe			;    ld     l, a 
0fbe			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0fbe			;    sbc    a, h 
0fbe			;    ld     h, a 
0fbe			; 
0fbe			;; Convert HL to digit characters 
0fbe			;._DoConvert: 
0fbe			;    ld     b, 0     ; B will count character length of number 
0fbe			;-   ld     a, 10 
0fbe			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0fbe			;    push   af 
0fbe			;    inc    b 
0fbe			;    ld     a, h 
0fbe			;    or     l 
0fbe			;    jr     nz, - 
0fbe			; 
0fbe			;; Retrieve digits from stack 
0fbe			;-   pop    af 
0fbe			;    or     $30 
0fbe			;    ld     (de), a 
0fbe			;    inc    de 
0fbe			;    djnz   - 
0fbe			; 
0fbe			;; Terminate string with NULL 
0fbe			;    xor    a 
0fbe			;    ld     (de), a 
0fbe			; 
0fbe			;    pop    bc 
0fbe			;    pop    de 
0fbe			;    ret 
0fbe			 
0fbe			;Comments 
0fbe			; 
0fbe			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0fbe			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0fbe			;    Note that the output string will not be fixed-width. 
0fbe			; 
0fbe			;Example Usage 
0fbe			; 
0fbe			;    ld    hl, -1004 
0fbe			;    ld    de, OP1 
0fbe			;    call  DispA 
0fbe			;    ld    hl, OP1 
0fbe			;    syscall  PutS 
0fbe			 
0fbe			 
0fbe			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fbe			 
0fbe			 
0fbe			;Converts an ASCII string to an unsigned 16-bit integer 
0fbe			;Quits when it reaches a non-decimal digit 
0fbe			 
0fbe			string_to_uint16: 
0fbe			atoui_16: 
0fbe			;Input: 
0fbe			;     DE points to the string 
0fbe			;Outputs: 
0fbe			;     HL is the result 
0fbe			;     A is the 8-bit value of the number 
0fbe			;     DE points to the byte after the number 
0fbe			;Destroys: 
0fbe			;     BC 
0fbe			;       if the string is non-empty, BC is HL/10 
0fbe			;Size:  24 bytes 
0fbe			;Speed: 42+d(104+{0,9}) 
0fbe			;       d is the number of digits in the number 
0fbe			;       max is 640 cycles for a 5 digit number 
0fbe			;Assuming no leading zeros: 
0fbe			;1 digit:  146cc 
0fbe			;2 digit:  250cc 
0fbe			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0fbe			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0fbe			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0fbe			;avg: 544.81158447265625cc (544+13297/16384) 
0fbe			;=============================================================== 
0fbe 21 00 00		  ld hl,0 
0fc1			.u16a: 
0fc1 1a			  ld a,(de) 
0fc2 d6 30		  sub 30h 
0fc4 fe 0a		  cp 10 
0fc6 d0			  ret nc 
0fc7 13			  inc de 
0fc8 44			  ld b,h 
0fc9 4d			  ld c,l 
0fca 29			  add hl,hl 
0fcb 29			  add hl,hl 
0fcc 09			  add hl,bc 
0fcd 29			  add hl,hl 
0fce 85			  add a,l 
0fcf 6f			  ld l,a 
0fd0 30 ef		  jr nc,.u16a 
0fd2 24			  inc h 
0fd3 c3 c1 0f		  jp .u16a 
0fd6			 
0fd6			 
0fd6			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fd6			 
0fd6			;written by Zeda 
0fd6			;Converts a 16-bit unsigned integer to an ASCII string. 
0fd6			 
0fd6			uitoa_16: 
0fd6			;Input: 
0fd6			;   DE is the number to convert 
0fd6			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0fd6			;Output: 
0fd6			;   HL points to the null-terminated ASCII string 
0fd6			;      NOTE: This isn't necessarily the same as the input HL. 
0fd6 d5			  push de 
0fd7 c5			  push bc 
0fd8 f5			  push af 
0fd9 eb			  ex de,hl 
0fda			 
0fda 01 f0 d8		  ld bc,-10000 
0fdd 3e 2f		  ld a,'0'-1 
0fdf 3c			  inc a 
0fe0 09			  add hl,bc  
0fe1 38 fc		   jr c,$-2 
0fe3 12			  ld (de),a 
0fe4 13			  inc de 
0fe5			 
0fe5 01 e8 03		  ld bc,1000 
0fe8 3e 3a		  ld a,'9'+1 
0fea 3d			  dec a  
0feb 09			  add hl,bc  
0fec 30 fc		   jr nc,$-2 
0fee 12			  ld (de),a 
0fef 13			  inc de 
0ff0			 
0ff0 01 9c ff		  ld bc,-100 
0ff3 3e 2f		  ld a,'0'-1 
0ff5 3c			  inc a  
0ff6 09			  add hl,bc  
0ff7 38 fc		   jr c,$-2 
0ff9 12			  ld (de),a 
0ffa 13			  inc de 
0ffb			 
0ffb 7d			  ld a,l 
0ffc 26 3a		  ld h,'9'+1 
0ffe 25			  dec h  
0fff c6 0a		  add a,10  
1001 30 fb		   jr nc,$-3 
1003 c6 30		  add a,'0' 
1005 eb			  ex de,hl 
1006 72			  ld (hl),d 
1007 23			  inc hl 
1008 77			  ld (hl),a 
1009 23			  inc hl 
100a 36 00		  ld (hl),0 
100c			 
100c			;Now strip the leading zeros 
100c 0e fa		  ld c,-6 
100e 09			  add hl,bc 
100f 3e 30		  ld a,'0' 
1011 23			  inc hl  
1012 be			  cp (hl)  
1013 28 fc		  jr z,$-2 
1015			 
1015			;Make sure that the string is non-empty! 
1015 7e			  ld a,(hl) 
1016 b7			  or a 
1017 20 01		  jr nz,.atoub 
1019 2b			  dec hl 
101a			.atoub: 
101a			 
101a f1			  pop af 
101b c1			  pop bc 
101c d1			  pop de 
101d c9			  ret 
101e			 
101e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
101e			 
101e			toUpper: 
101e			;A is the char. 
101e			;If A is a lowercase letter, this sets it to the matching uppercase 
101e			;18cc or 30cc or 41cc 
101e			;avg: 26.75cc 
101e fe 61		  cp 'a' 
1020 d8			  ret c 
1021 fe 7b		  cp 'z'+1 
1023 d0			  ret nc 
1024 d6 20		  sub 'a'-'A' 
1026 c9			  ret 
1027			 
1027			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1027			 
1027			; String Length 
1027			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1027			 
1027			; Get the length of the null-terminated string starting at $8000 hl 
1027			;    LD     HL, $8000 
1027			 
1027			strlenz: 
1027			 
1027 af			    XOR    A               ; Zero is the value we are looking for. 
1028 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1029 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
102a			                           ; 65, 536 bytes (the entire addressable memory space). 
102a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
102c			 
102c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
102c 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
102d 6f			    LD     L, A             ; number of bytes 
102e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1030 2b			    DEC    HL              ; Compensate for null. 
1031 c9				ret 
1032			 
1032			; Get the length of the A terminated string starting at $8000 hl 
1032			;    LD     HL, $8000 
1032			 
1032			strlent: 
1032			 
1032			                  ; A is the value we are looking for. 
1032 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1034 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1036			                           ; 65, 536 bytes (the entire addressable memory space). 
1036 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1038			 
1038			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1038 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
103a 2e 00		    LD     L, 0             ; number of bytes 
103c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
103e 2b			    DEC    HL              ; Compensate for null. 
103f c9				ret 
1040			 
1040			 
1040			;Comparing Strings 
1040			 
1040			;IN    HL     Address of string1. 
1040			;      DE     Address of string2. 
1040			 
1040			; doc given but wrong??? 
1040			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1040			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1040			; tested 
1040			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1040			 
1040			strcmp_old: 
1040 e5			    PUSH   HL 
1041 d5			    PUSH   DE 
1042			 
1042 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1043 be			    CP     (HL)            ; (want to minimize work). 
1044 38 01		    JR     C, Str1IsBigger 
1046 7e			    LD     A, (HL) 
1047			 
1047			Str1IsBigger: 
1047 4f			    LD     C, A             ; Put length in BC 
1048 06 00		    LD     B, 0 
104a 13			    INC    DE              ; Increment pointers to meat of string. 
104b 23			    INC    HL 
104c			 
104c			CmpLoop: 
104c 1a			    LD     A, (DE)          ; Compare bytes. 
104d ed a1		    CPI 
104f 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1051 13			    INC    DE              ; Update pointer. 
1052 ea 4c 10		    JP     PE, CmpLoop 
1055			 
1055 d1			    POP    DE 
1056 e1			    POP    HL 
1057 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1058 be			    CP     (HL) 
1059 c9			    RET 
105a			 
105a			NoMatch: 
105a 2b			    DEC    HL 
105b be			    CP     (HL)            ; Compare again to affect carry. 
105c d1			    POP    DE 
105d e1			    POP    HL 
105e c9			    RET 
105f			 
105f			;; test strmp 
105f			; 
105f			;ld de, .str1 
105f			;ld hl, .str2 
105f			;call strcmp 
105f			;jr z, .z1 
105f			;;this 
105f			;	if DEBUG_FORTH_WORDS 
105f			;		DMARK "NZ1" 
105f			;		CALLMONITOR 
105f			;	endif 
105f			;.z1: 
105f			; 
105f			;	if DEBUG_FORTH_WORDS 
105f			;		DMARK "ZZ1" 
105f			;		CALLMONITOR 
105f			;	endif 
105f			; 
105f			;ld de, .str1 
105f			;ld hl, .str1 
105f			;call strcmp 
105f			;jr z, .z2 
105f			;;this 
105f			;	if DEBUG_FORTH_WORDS 
105f			;		DMARK "NZ2" 
105f			;		CALLMONITOR 
105f			;	endif 
105f			;.z2: 
105f			; 
105f			;	if DEBUG_FORTH_WORDS 
105f			;		DMARK "ZZ2" 
105f			;		CALLMONITOR 
105f			;	endif 
105f			; 
105f			;ld de, .str1 
105f			;ld hl, .str2 
105f			;call strcmp 
105f			;jr c, .c1 
105f			; 
105f			;	if DEBUG_FORTH_WORDS 
105f			;		DMARK "Nc1" 
105f			;		CALLMONITOR 
105f			;	endif 
105f			;.c1: 
105f			;;this 
105f			;	if DEBUG_FORTH_WORDS 
105f			;		DMARK "cc1" 
105f			;		CALLMONITOR 
105f			;	endif 
105f			; 
105f			;ld de, .str1 
105f			;ld hl, .str1 
105f			;call strcmp 
105f			;jr c, .c2 
105f			;;this 
105f			;	if DEBUG_FORTH_WORDS 
105f			;		DMARK "Nc2" 
105f			;		CALLMONITOR 
105f			;	endif 
105f			;.c2: 
105f			; 
105f			;	if DEBUG_FORTH_WORDS 
105f			;		DMARK "cc2" 
105f			;		CALLMONITOR 
105f			;	endif 
105f			;	NEXTW 
105f			;.str1:   db "string1",0 
105f			;.str2:   db "string2",0 
105f			 
105f			; only care about direct match or not 
105f			; hl and de strings 
105f			; zero set if the same 
105f			 
105f			strcmp: 
105f 1a				ld a, (de) 
1060 be				cp (hl) 
1061 28 02			jr z, .ssame 
1063 b7				or a 
1064 c9				ret 
1065			 
1065			.ssame:  
1065 fe 00			cp 0 
1067 c8				ret z 
1068			 
1068 23				inc hl 
1069 13				inc de 
106a 18 f3			jr strcmp 
106c				 
106c				 
106c			 
106c			 
106c			 
106c			 
106c			; eof 
106c			 
106c			 
106c			 
106c			 
106c			 
106c			 
# End of file firmware_strings.asm
106c			include "firmware_memory.asm"   ; malloc and free  
106c			 
106c			if DEBUG_FORTH_MALLOC_HIGH 
106c			.mallocsize: db "Wants malloc >256",0 
106c			.mallocasize: db "MALLOC gives >256",0 
106c			.malloczero: db "MALLOC gives zero",0 
106c			 
106c			malloc_guard_zerolen: 
106c				push hl 
106c				push de 
106c				push af 
106c			 
106c				ld de, 0 
106c			        call cmp16 
106c				jr nz, .lowalloz 
106c			 
106c				push hl 
106c				push de 
106c					ld hl, display_fb0 
106c					ld (display_fb_active), hl 
106c				call clear_display 
106c				ld a, 0 
106c				ld de, .malloczero 
106c				call str_at_display 
106c				call update_display 
106c				call delay1s 
106c				call delay1s 
106c				ld a, 0 
106c				ld (os_view_disable), a 
106c			 
106c				pop de 
106c				pop hl 
106c			 
106c				 
106c			 
106c				CALLMONITOR 
106c			.lowalloz: 
106c			 
106c			 
106c				pop af 
106c				pop de 
106c				pop hl 
106c			ret 
106c			 
106c			malloc_guard_entry: 
106c				push hl 
106c				push de 
106c				push af 
106c			 
106c			 	or a      ;clear carry flag 
106c				push hl 
106c				ld de, 255 
106c				sbc hl, de 
106c				jr c, .lowalloc 
106c			 
106c				push de 
106c					ld hl, display_fb0 
106c					ld (display_fb_active), hl 
106c				call clear_display 
106c				ld a, 0 
106c				ld de, .mallocsize 
106c				call str_at_display 
106c				call update_display 
106c				call delay1s 
106c				call delay1s 
106c				ld a, 0 
106c				ld (os_view_disable), a 
106c			 
106c				pop de 
106c				pop hl 
106c			 
106c				 
106c			 
106c				CALLMONITOR 
106c				jr .lowdone 
106c			.lowalloc: 
106c			 
106c			 
106c				pop hl 
106c			.lowdone:	pop af 
106c				pop de 
106c				pop hl 
106c			ret 
106c			 
106c			malloc_guard_exit: 
106c				push hl 
106c				push de 
106c				push af 
106c			 
106c			 	or a      ;clear carry flag 
106c				push hl 
106c				ld de, 255 
106c				sbc hl, de 
106c				jr c, .lowallocx 
106c			 
106c				push de 
106c					ld hl, display_fb0 
106c					ld (display_fb_active), hl 
106c				call clear_display 
106c				ld a, 0 
106c				ld de, .mallocasize 
106c				call str_at_display 
106c				call update_display 
106c				call delay1s 
106c				call delay1s 
106c				ld a, 0 
106c				ld (os_view_disable), a 
106c				pop de 
106c				pop hl 
106c			 
106c				CALLMONITOR 
106c				jr .lowdonex 
106c			.lowallocx: 
106c			 
106c				pop hl 
106c			.lowdonex:	pop af 
106c				pop de 
106c				pop hl 
106c			ret 
106c			endif 
106c			 
106c			if MALLOC_2 
106c			; Z80 Malloc and Free Functions 
106c			 
106c			; Malloc Function: 
106c			; Input: 
106c			;   HL: Size of block to allocate 
106c			; Output: 
106c			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
106c			 
106c			malloc: 
106c				 
106c			if DEBUG_FORTH_MALLOC_HIGH 
106c			call malloc_guard_entry 
106c			endif 
106c			 
106c			 
106c			 
106c			 
106c					if DEBUG_FORTH_MALLOC 
106c						DMARK "mal" 
106c						CALLMONITOR 
106c					endif 
106c			    push af            ; Save AF register 
106c			    ld a, l            ; Load low byte of size into A 
106c			    or h               ; Check if size is zero 
106c			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
106c			 
106c			    ; Allocate memory 
106c			    ld hl, (heap_start) ; Load start of heap into HL 
106c					if DEBUG_FORTH_MALLOC 
106c						DMARK "ma1" 
106c						CALLMONITOR 
106c					endif 
106c			    call malloc_internal ; Call internal malloc function 
106c			    pop af             ; Restore AF register 
106c			if DEBUG_FORTH_MALLOC_HIGH 
106c			call malloc_guard_exit 
106c			call malloc_guard_zerolen 
106c			endif 
106c			    ret                ; Return 
106c			 
106c			; Free Function: 
106c			; Input: 
106c			;   HL: Pointer to memory block to free 
106c			; Output: 
106c			;   None 
106c			 
106c			free: 
106c			    push af            ; Save AF register 
106c			    ld a, l            ; Load low byte of pointer into A 
106c			    or h               ; Check if pointer is NULL 
106c			    jp z, free_exit    ; If pointer is NULL, exit 
106c			 
106c			    ; Free memory 
106c			    ld hl, (heap_start) ; Load start of heap into HL 
106c			    call free_internal  ; Call internal free function 
106c			    pop af             ; Restore AF register 
106c			    ret                ; Return 
106c			 
106c			; Internal Malloc Function: 
106c			; Input: 
106c			;   HL: Size of block to allocate 
106c			; Output: 
106c			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
106c			 
106c			malloc_internal: 
106c			    ld bc, 2           ; Number of bytes to allocate for management overhead 
106c			    add hl, bc         ; Add management overhead to requested size 
106c			    ex de, hl          ; Save total size in DE, and keep it in HL 
106c					if DEBUG_FORTH_MALLOC 
106c						DMARK "ma2" 
106c						CALLMONITOR 
106c					endif 
106c			 
106c			    ; Search for free memory block 
106c			    ld de, (heap_end)  ; Load end of heap into DE 
106c			    ld bc, 0           ; Initialize counter 
106c			 
106c					if DEBUG_FORTH_MALLOC 
106c						DMARK "ma2" 
106c						CALLMONITOR 
106c					endif 
106c			malloc_search_loop: 
106c			    ; Check if current block is free 
106c			    ld a, (hl)         ; Load current block's status (free or used) 
106c			    cp 0               ; Compare with zero (free) 
106c			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
106c			 
106c			    ; Check if current block is large enough 
106c			    ld a, (hl+1)       ; Load high byte of block size 
106c			    cp l               ; Compare with low byte of requested size 
106c			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
106c			 
106c			    ld a, (hl+2)       ; Load low byte of block size 
106c			    cp h               ; Compare with high byte of requested size 
106c			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
106c			 
106c			    ; Mark block as used 
106c			    ld (hl), 0xFF      ; Set status byte to indicate used block 
106c			 
106c			    ; Calculate remaining space in block 
106c			    ld bc, 0           ; Clear BC 
106c			    add hl, bc         ; Increment HL to point to start of data block 
106c			    add hl, de         ; HL = HL + DE (total size) 
106c			    ld bc, 1           ; Number of bytes to allocate for management overhead 
106c			    add hl, bc         ; Add management overhead to start of data block 
106c			 
106c			    ; Save pointer to allocated block in HL 
106c			if DEBUG_FORTH_MALLOC_HIGH 
106c						DMARK "ma5" 
106c			call malloc_guard_exit 
106c			call malloc_guard_zerolen 
106c			endif 
106c			    ret 
106c			 
106c			malloc_skip_block_check: 
106c			    ; Move to the next block 
106c			    ld bc, 3           ; Size of management overhead 
106c			    add hl, bc         ; Move to the next block 
106c			    inc de             ; Increment counter 
106c			 
106c			    ; Check if we have reached the end of heap 
106c			    ld a, e            ; Load low byte of heap end address 
106c			    cp (hl)            ; Compare with low byte of current address 
106c			    jr nz, malloc_search_loop  ; If not equal, continue searching 
106c			    ld a, d            ; Load high byte of heap end address 
106c			    cp 0               ; Check if it's zero (end of memory) 
106c			    jr nz, malloc_search_loop  ; If not zero, continue searching 
106c			 
106c			    ; If we reached here, allocation failed 
106c			    xor a              ; Set result to NULL 
106c			if DEBUG_FORTH_MALLOC_HIGH 
106c						DMARK "ma6" 
106c			call malloc_guard_exit 
106c			call malloc_guard_zerolen 
106c			endif 
106c			    ret 
106c			malloc_exit: 
106c			if DEBUG_FORTH_MALLOC_HIGH 
106c						DMARK "ma7" 
106c			call malloc_guard_exit 
106c			call malloc_guard_zerolen 
106c			endif 
106c			    ret 
106c			 
106c			; Internal Free Function: 
106c			; Input: 
106c			;   HL: Pointer to memory block to free 
106c			; Output: 
106c			;   None 
106c			 
106c			free_internal: 
106c			    ld de, (heap_start) ; Load start of heap into DE 
106c			    ld bc, 0            ; Initialize counter 
106c			 
106c			free_search_loop: 
106c			    ; Check if current block contains the pointer 
106c			    ld a, l             ; Load low byte of pointer 
106c			    cp (hl+1)           ; Compare with high byte of current block's address 
106c			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
106c			    ld a, h             ; Load high byte of pointer 
106c			    cp (hl+2)           ; Compare with low byte of current block's address 
106c			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
106c			 
106c			    ; Mark block as free 
106c			    ld (hl), 0          ; Set status byte to indicate free block 
106c			    ret                 ; Return 
106c			 
106c			free_skip_block_check: 
106c			    ; Move to the next block 
106c			    ld bc, 3            ; Size of management overhead 
106c			    add hl, bc          ; Move to the next block 
106c			    inc de              ; Increment counter 
106c			 
106c			    ; Check if we have reached the end of heap 
106c			    ld a, e             ; Load low byte of heap end address 
106c			    cp (hl)             ; Compare with low byte of current address 
106c			    jr nz, free_search_loop  ; If not equal, continue searching 
106c			    ld a, d             ; Load high byte of heap end address 
106c			    cp 0                ; Check if it's zero (end of memory) 
106c			    jr nz, free_search_loop  ; If not zero, continue searching 
106c			 
106c			    ; If we reached here, pointer is not found in heap 
106c			    ret 
106c			 
106c			free_exit: 
106c			    ret                 ; Return 
106c			 
106c			; Define heap start and end addresses 
106c			;heap_start:    .dw 0xC000   ; Start of heap 
106c			;heap_end:      .dw 0xE000   ; End of heap 
106c			 
106c			endif 
106c			 
106c			 
106c			if MALLOC_1 
106c			 
106c			 
106c			 
106c			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
106c			 
106c			;moved to firmware.asm 
106c			;heap_start        .equ  0x9000      ; Starting address of heap 
106c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
106c			 
106c			;      .org 0 
106c			;      jp    main 
106c			 
106c			 
106c			;      .org  0x100 
106c			;main: 
106c			;      ld    HL, 0x8100 
106c			;      ld    SP, HL 
106c			; 
106c			;      call  heap_init 
106c			; 
106c			;      ; Make some allocations 
106c			;      ld    HL, 12 
106c			;      call  malloc            ; Allocates 0x9004 
106c			; 
106c			;      ld    HL, 12 
106c			;      call  malloc            ; Allocates 0x9014 
106c			; 
106c			;      ld    HL, 12 
106c			;      call  malloc            ; Allocates 0x9024 
106c			; 
106c			;      ; Free some allocations 
106c			;      ld    HL, 0x9014 
106c			;      call  free 
106c			; 
106c			;      ld    HL, 0x9004 
106c			;      call  free 
106c			; 
106c			;      ld    HL, 0x9024 
106c			;      call  free 
106c			; 
106c			; 
106c			;      halt 
106c			 
106c			 
106c			;------------------------------------------------------------------------------ 
106c			;     heap_init                                                               : 
106c			;                                                                             : 
106c			; Description                                                                 : 
106c			;     Initialise the heap and make it ready for malloc and free operations.   : 
106c			;                                                                             : 
106c			;     The heap is maintained as a linked list, starting with an initial       : 
106c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
106c			;     the first free block in the heap. Each block then points to the next    : 
106c			;     free block within the heap, and the free list ends at the first block   : 
106c			;     with a null pointer to the next free block.                             : 
106c			;                                                                             : 
106c			; Parameters                                                                  : 
106c			;     Inputs are compile-time only. Two defines which specify the starting    : 
106c			;     address of the heap and its size are required, along with a memory      : 
106c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
106c			;     principally stores a pointer to the first free block in the heap.       : 
106c			;                                                                             : 
106c			; Returns                                                                     : 
106c			;     Nothing                                                                 : 
106c			;------------------------------------------------------------------------------ 
106c			heap_init: 
106c e5			      push  HL 
106d			 
106d			      ; Initialise free list struct 
106d 21 51 59		      ld    HL, heap_start 
1070 22 4c 59		      ld    (free_list), HL 
1073 21 00 00		      ld    HL, 0 
1076 22 4e 59		      ld    (free_list+2), HL 
1079			 
1079			      ; Insert first free block at bottom of heap, consumes entire heap 
1079 21 42 e3		      ld    HL, heap_start+heap_size-4 
107c 22 51 59		      ld    (heap_start), HL        ; Next block (end of free list) 
107f 21 f1 89		      ld    HL, heap_size-4 
1082 22 53 59		      ld    (heap_start+2), HL      ; Block size 
1085			 
1085			      ; Insert end of free list block at top of heap - two null words will 
1085			      ; terminate the free list 
1085 21 00 00		      ld    HL, 0 
1088 22 44 e3		      ld    (heap_start+heap_size-2), HL 
108b 22 42 e3		      ld    (heap_start+heap_size-4), HL 
108e			 
108e e1			      pop   HL 
108f			 
108f c9			      ret 
1090			 
1090			 
1090			;------------------------------------------------------------------------------ 
1090			;     malloc                                                                  : 
1090			;                                                                             : 
1090			; Description                                                                 : 
1090			;     Allocates the wanted space from the heap and returns the address of the : 
1090			;     first useable byte of the allocation.                                   : 
1090			;                                                                             : 
1090			;     Allocations can happen in one of two ways:                              : 
1090			;                                                                             : 
1090			;     1. A free block may be found which is the exact size wanted. In this    : 
1090			;        case the block is removed from the free list and retuedn to the      : 
1090			;        caller.                                                              : 
1090			;     2. A free block may be found which is larger than the size wanted. In   : 
1090			;        this case, the larger block is split into two. The first portion of  : 
1090			;        this block will become the requested space by the malloc call and    : 
1090			;        is returned to the caller. The second portion becomes a new free     : 
1090			;        block, and the free list is adjusted to maintain continuity via this : 
1090			;        newly created block.                                                 : 
1090			;                                                                             : 
1090			;     malloc does not set any initial value in the allocated space, the       : 
1090			;     caller is required to do this as required.                              : 
1090			;                                                                             : 
1090			;     This implementation of malloc uses the stack exclusively, and is        : 
1090			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1090			;     advisable to disable interrupts before calling malloc, and recommended  : 
1090			;     to avoid the use of malloc inside ISRs in general.                      : 
1090			;                                                                             : 
1090			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1090			;                                                                             : 
1090			; Parameters                                                                  : 
1090			;     HL  Number of bytes wanted                                              : 
1090			;                                                                             : 
1090			; Returns                                                                     : 
1090			;     HL  Address of the first useable byte of the allocation                 : 
1090			;                                                                             : 
1090			; Flags                                                                       : 
1090			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1090			;                                                                             : 
1090			; Stack frame                                                                 : 
1090			;       |             |                                                       : 
1090			;       +-------------+                                                       : 
1090			;       |     BC      |                                                       : 
1090			;       +-------------+                                                       : 
1090			;       |     DE      |                                                       : 
1090			;       +-------------+                                                       : 
1090			;       |     IX      |                                                       : 
1090			;       +-------------+                                                       : 
1090			;       |  prev_free  |                                                       : 
1090			;   +4  +-------------+                                                       : 
1090			;       |  this_free  |                                                       : 
1090			;   +2  +-------------+                                                       : 
1090			;       |  next_free  |                                                       : 
1090			;   +0  +-------------+                                                       : 
1090			;       |             |                                                       : 
1090			;                                                                             : 
1090			;------------------------------------------------------------------------------ 
1090			 
1090			 
1090			;malloc: 
1090			; 
1090			;	SAVESP ON 1 
1090			; 
1090			;	call malloc_code 
1090			; 
1090			;	CHECKSP ON 1 
1090			;	ret 
1090			 
1090			 
1090			malloc: 
1090 c5			      push  BC 
1091 d5			      push  DE 
1092 dd e5		      push  IX 
1094			if DEBUG_FORTH_MALLOC_HIGH 
1094			call malloc_guard_entry 
1094			endif 
1094			 
1094					if DEBUG_FORTH_MALLOC 
1094						DMARK "mal" 
1094						CALLMONITOR 
1094					endif 
1094 7c			      ld    A, H                    ; Exit if no space requested 
1095 b5			      or    L 
1096 ca 55 11		      jp    Z, malloc_early_exit 
1099			 
1099			;inc hl 
1099			;inc hl 
1099			;inc hl 
1099			; 
1099			;inc hl 
1099			;inc hl 
1099			;inc hl 
1099			;inc hl 
1099			;inc hl 
1099			;inc hl 
1099			;inc hl 
1099			;inc hl 
1099			;inc hl 
1099			 
1099			 
1099			 
1099			 
1099					if DEBUG_FORTH_MALLOC 
1099						DMARK "maA" 
1099						CALLMONITOR 
1099					endif 
1099			      ; Set up stack frame 
1099 eb			      ex    DE, HL 
109a 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
109d 39			      add   HL, SP 
109e f9			      ld    SP, HL 
109f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
10a3 dd 39		      add   IX, SP 
10a5			 
10a5			      ; Setup initial state 
10a5 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
10a8 19			      add   HL, DE 
10a9			 
10a9 44			      ld    B, H                    ; Move want to BC 
10aa 4d			      ld    C, L 
10ab			 
10ab 21 4c 59		      ld    HL, free_list           ; Store prev_free ptr to stack 
10ae dd 75 04		      ld    (IX+4), L 
10b1 dd 74 05		      ld    (IX+5), H 
10b4			 
10b4 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
10b5 23			      inc   HL 
10b6 56			      ld    D, (HL) 
10b7 dd 73 02		      ld    (IX+2), E 
10ba dd 72 03		      ld    (IX+3), D 
10bd eb			      ex    DE, HL                  ; this_free ptr into HL 
10be			 
10be					if DEBUG_FORTH_MALLOC 
10be						DMARK "maB" 
10be						CALLMONITOR 
10be					endif 
10be			      ; Loop through free block list to find some space 
10be			malloc_find_space: 
10be 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
10bf 23			      inc   HL 
10c0 56			      ld    D, (HL) 
10c1			 
10c1 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
10c2 b3			      or    E 
10c3 ca 4f 11		      jp    Z, malloc_no_space 
10c6			 
10c6 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
10c9 dd 72 01		      ld    (IX+1), D 
10cc			 
10cc			      ; Does this block have enough space to make the allocation? 
10cc 23			      inc   HL                      ; Load free block size into DE 
10cd 5e			      ld    E, (HL) 
10ce 23			      inc   HL 
10cf 56			      ld    D, (HL) 
10d0			 
10d0 eb			      ex    DE, HL                  ; Check size of block against want 
10d1 b7			      or    A                       ; Ensure carry flag clear 
10d2 ed 42		      sbc   HL, BC 
10d4 e5			      push  HL                      ; Store the result for later (new block size) 
10d5			 
10d5 ca 24 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
10d8 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
10da			 
10da			      ; this_free block is not big enough, setup ptrs to test next free block 
10da e1			      pop   HL                      ; Discard previous result 
10db			 
10db dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
10de dd 66 03		      ld    H, (IX+3) 
10e1 dd 75 04		      ld    (IX+4), L 
10e4 dd 74 05		      ld    (IX+5), H 
10e7			 
10e7 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
10ea dd 66 01		      ld    H, (IX+1) 
10ed dd 75 02		      ld    (IX+2), L 
10f0 dd 74 03		      ld    (IX+3), H 
10f3			 
10f3					if DEBUG_FORTH_MALLOC 
10f3						DMARK "MA>" 
10f3						CALLMONITOR 
10f3					endif 
10f3 18 c9		      jr    malloc_find_space 
10f5			 
10f5			      ; split a bigger block into two - requested size and remaining size 
10f5			malloc_alloc_split: 
10f5					if DEBUG_FORTH_MALLOC 
10f5						DMARK "MAs" 
10f5						CALLMONITOR 
10f5					endif 
10f5 eb			      ex    DE, HL                  ; Calculate address of new free block 
10f6 2b			      dec   HL 
10f7 2b			      dec   HL 
10f8 2b			      dec   HL 
10f9 09			      add   HL, BC 
10fa			 
10fa			      ; Create a new block and point it at next_free 
10fa dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
10fd dd 56 01		      ld    D, (IX+1) 
1100			 
1100 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1101 23			      inc   HL 
1102 72			      ld    (HL), D 
1103			 
1103 d1			      pop   DE                      ; Store size of new block into new block 
1104 23			      inc   HL 
1105 73			      ld    (HL), E 
1106 23			      inc   HL 
1107 72			      ld    (HL), D 
1108			 
1108			      ; Update this_free ptr to point to new block 
1108 2b			      dec   HL 
1109 2b			      dec   HL 
110a 2b			      dec   HL 
110b			 
110b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
110e dd 56 03		      ld    D, (IX+3) 
1111			 
1111 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1114 dd 74 03		      ld    (IX+3), H 
1117			 
1117			      ; Modify this_free block to be allocation 
1117 eb			      ex    DE, HL 
1118 af			      xor   A                       ; Null the next block ptr of allocated block 
1119 77			      ld    (HL), A 
111a 23			      inc   HL 
111b 77			      ld    (HL), A 
111c			 
111c 23			      inc   HL                      ; Store want size into allocated block 
111d 71			      ld    (HL), C 
111e 23			      inc   HL 
111f 70			      ld    (HL), B 
1120 23			      inc   HL 
1121 e5			      push  HL                      ; Address of allocation to return 
1122			 
1122 18 19		      jr    malloc_update_links 
1124			 
1124			malloc_alloc_fit: 
1124 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1125			 
1125					if DEBUG_FORTH_MALLOC 
1125						DMARK "MAf" 
1125						CALLMONITOR 
1125					endif 
1125			      ; Modify this_free block to be allocation 
1125 eb			      ex    DE, HL 
1126 2b			      dec   HL 
1127 2b			      dec   HL 
1128 2b			      dec   HL 
1129			 
1129 af			      xor   A                       ; Null the next block ptr of allocated block 
112a 77			      ld    (HL), A 
112b 23			      inc   HL 
112c 77			      ld    (HL), A 
112d			 
112d 23			      inc   HL                      ; Store address of allocation to return 
112e 23			      inc   HL 
112f 23			      inc   HL 
1130 e5			      push  HL 
1131			 
1131			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1131 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1134 dd 66 01		      ld    H, (IX+1) 
1137			 
1137 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
113a dd 74 03		      ld    (IX+3), H 
113d			 
113d			 
113d			malloc_update_links: 
113d			      ; Update prev_free ptr to point to this_free 
113d dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1140 dd 66 05		      ld    H, (IX+5) 
1143			 
1143 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1146 dd 56 03		      ld    D, (IX+3) 
1149			 
1149 73			      ld    (HL), E                 ; this_free ptr into prev_free 
114a 23			      inc   HL 
114b 72			      ld    (HL), D 
114c			 
114c					if DEBUG_FORTH_MALLOC 
114c						DMARK "Mul" 
114c						CALLMONITOR 
114c					endif 
114c			      ; Clear the Z flag to indicate successful allocation 
114c 7a			      ld    A, D 
114d b3			      or    E 
114e			 
114e d1			      pop   DE                      ; Address of allocation 
114f					if DEBUG_FORTH_MALLOC 
114f						DMARK "MAu" 
114f						CALLMONITOR 
114f					endif 
114f			 
114f			malloc_no_space: 
114f 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1152 39			      add   HL, SP 
1153 f9			      ld    SP, HL 
1154			 
1154 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1155					if DEBUG_FORTH_MALLOC 
1155						DMARK "MAN" 
1155						CALLMONITOR 
1155					endif 
1155			 
1155			malloc_early_exit: 
1155					if DEBUG_FORTH_MALLOC 
1155						DMARK "MAx" 
1155						CALLMONITOR 
1155					endif 
1155 dd e1		      pop   IX 
1157 d1			      pop   DE 
1158 c1			      pop   BC 
1159			 
1159			if DEBUG_FORTH_MALLOC_HIGH 
1159			call malloc_guard_exit 
1159			call malloc_guard_zerolen 
1159			endif 
1159 c9			      ret 
115a			 
115a			 
115a			;------------------------------------------------------------------------------ 
115a			;     free                                                                    : 
115a			;                                                                             : 
115a			; Description                                                                 : 
115a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
115a			;     returned by malloc, otherwise the behaviour is undefined.               : 
115a			;                                                                             : 
115a			;     Where possible, directly adjacent free blocks will be merged together   : 
115a			;     into larger blocks to help ensure that the heap does not become         : 
115a			;     excessively fragmented.                                                 : 
115a			;                                                                             : 
115a			;     free does not clear or set any other value into the freed space, and    : 
115a			;     therefore its contents may be visible through subsequent malloc's. The  : 
115a			;     caller should clear the freed space as required.                        : 
115a			;                                                                             : 
115a			;     This implementation of free uses the stack exclusively, and is          : 
115a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
115a			;     advisable to disable interrupts before calling free, and recommended    : 
115a			;     to avoid the use of free inside ISRs in general.                        : 
115a			;                                                                             : 
115a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
115a			;                                                                             : 
115a			; Parameters                                                                  : 
115a			;     HL  Pointer to address of first byte of allocation to be freed          : 
115a			;                                                                             : 
115a			; Returns                                                                     : 
115a			;     Nothing                                                                 : 
115a			;                                                                             : 
115a			; Stack frame                                                                 : 
115a			;       |             |                                                       : 
115a			;       +-------------+                                                       : 
115a			;       |     BC      |                                                       : 
115a			;       +-------------+                                                       : 
115a			;       |     DE      |                                                       : 
115a			;       +-------------+                                                       : 
115a			;       |     IX      |                                                       : 
115a			;       +-------------+                                                       : 
115a			;       |  prev_free  |                                                       : 
115a			;   +2  +-------------+                                                       : 
115a			;       |  next_free  |                                                       : 
115a			;   +0  +-------------+                                                       : 
115a			;       |             |                                                       : 
115a			;                                                                             : 
115a			;------------------------------------------------------------------------------ 
115a			free: 
115a c5			      push  BC 
115b d5			      push  DE 
115c dd e5		      push  IX 
115e			 
115e 7c			      ld    A, H                    ; Exit if ptr is null 
115f b5			      or    L 
1160 ca 24 12		      jp    Z, free_early_exit 
1163			 
1163			      ; Set up stack frame 
1163 eb			      ex    DE, HL 
1164 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1167 39			      add   HL, SP 
1168 f9			      ld    SP, HL 
1169 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
116d dd 39		      add   IX, SP 
116f			 
116f			      ; The address in HL points to the start of the useable allocated space, 
116f			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
116f			      ; address of the block itself. 
116f eb			      ex    DE, HL 
1170 11 fc ff		      ld    DE, -4 
1173 19			      add   HL, DE 
1174			 
1174			      ; An allocated block must have a null next block pointer in it 
1174 7e			      ld    A, (HL) 
1175 23			      inc   HL 
1176 b6			      or    (HL) 
1177 c2 1f 12		      jp    NZ, free_done 
117a			 
117a 2b			      dec   HL 
117b			 
117b 44			      ld    B, H                    ; Copy HL to BC 
117c 4d			      ld    C, L 
117d			 
117d			      ; Loop through the free list to find the first block with an address 
117d			      ; higher than the block being freed 
117d 21 4c 59		      ld    HL, free_list 
1180			 
1180			free_find_higher_block: 
1180 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1181 23			      inc   HL 
1182 56			      ld    D, (HL) 
1183 2b			      dec   HL 
1184			 
1184 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1187 dd 72 01		      ld    (IX+1), D 
118a dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
118d dd 74 03		      ld    (IX+3), H 
1190			 
1190 78			      ld    A, B                    ; Check if DE is greater than BC 
1191 ba			      cp    D                       ; Compare MSB first 
1192 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1194 30 04		      jr    NC, free_find_higher_block_skip 
1196 79			      ld    A, C 
1197 bb			      cp    E                       ; Then compare LSB 
1198 38 08		      jr    C, free_found_higher_block 
119a			 
119a			free_find_higher_block_skip: 
119a 7a			      ld    A, D                    ; Reached the end of the free list? 
119b b3			      or    E 
119c ca 1f 12		      jp    Z, free_done 
119f			 
119f eb			      ex    DE, HL 
11a0			 
11a0 18 de		      jr    free_find_higher_block 
11a2			 
11a2			free_found_higher_block: 
11a2			      ; Insert freed block between prev and next free blocks 
11a2 71			      ld    (HL), C                 ; Point prev free block to freed block 
11a3 23			      inc   HL 
11a4 70			      ld    (HL), B 
11a5			 
11a5 60			      ld    H, B                    ; Point freed block at next free block 
11a6 69			      ld    L, C 
11a7 73			      ld    (HL), E 
11a8 23			      inc   HL 
11a9 72			      ld    (HL), D 
11aa			 
11aa			      ; Check if the freed block is adjacent to the next free block 
11aa 23			      inc   HL                      ; Load size of freed block into HL 
11ab 5e			      ld    E, (HL) 
11ac 23			      inc   HL 
11ad 56			      ld    D, (HL) 
11ae eb			      ex    DE, HL 
11af			 
11af 09			      add   HL, BC                  ; Add addr of freed block and its size 
11b0			 
11b0 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
11b3 dd 56 01		      ld    D, (IX+1) 
11b6			 
11b6 b7			      or    A                       ; Clear the carry flag 
11b7 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
11b9 20 22		      jr    NZ, free_check_adjacent_to_prev 
11bb			 
11bb			      ; Freed block is adjacent to next, merge into one bigger block 
11bb eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
11bc 5e			      ld    E, (HL) 
11bd 23			      inc   HL 
11be 56			      ld    D, (HL) 
11bf e5			      push  HL                      ; Save ptr to next block for later 
11c0			 
11c0 60			      ld    H, B                    ; Store ptr from next block into freed block 
11c1 69			      ld    L, C 
11c2 73			      ld    (HL), E 
11c3 23			      inc   HL 
11c4 72			      ld    (HL), D 
11c5			 
11c5 e1			      pop   HL                      ; Restore ptr to next block 
11c6 23			      inc   HL                      ; Load size of next block into DE 
11c7 5e			      ld    E, (HL) 
11c8 23			      inc   HL 
11c9 56			      ld    D, (HL) 
11ca d5			      push  DE                      ; Save next block size for later 
11cb			 
11cb 60			      ld    H, B                    ; Load size of freed block into HL 
11cc 69			      ld    L, C 
11cd 23			      inc   HL 
11ce 23			      inc   HL 
11cf 5e			      ld    E, (HL) 
11d0 23			      inc   HL 
11d1 56			      ld    D, (HL) 
11d2 eb			      ex    DE, HL 
11d3			 
11d3 d1			      pop   DE                      ; Restore size of next block 
11d4 19			      add   HL, DE                  ; Add sizes of both blocks 
11d5 eb			      ex    DE, HL 
11d6			 
11d6 60			      ld    H, B                    ; Store new bigger size into freed block 
11d7 69			      ld    L, C 
11d8 23			      inc   HL 
11d9 23			      inc   HL 
11da 73			      ld    (HL), E 
11db 23			      inc   HL 
11dc 72			      ld    (HL), D 
11dd			 
11dd			free_check_adjacent_to_prev: 
11dd			      ; Check if the freed block is adjacent to the prev free block 
11dd dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
11e0 dd 66 03		      ld    H, (IX+3) 
11e3			 
11e3 23			      inc   HL                      ; Size of prev free block into DE 
11e4 23			      inc   HL 
11e5 5e			      ld    E, (HL) 
11e6 23			      inc   HL 
11e7 56			      ld    D, (HL) 
11e8 2b			      dec   HL 
11e9 2b			      dec   HL 
11ea 2b			      dec   HL 
11eb			 
11eb 19			      add   HL, DE                  ; Add prev block addr and size 
11ec			 
11ec b7			      or    A                       ; Clear the carry flag 
11ed ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
11ef 20 2e		      jr    NZ, free_done 
11f1			 
11f1			      ; Freed block is adjacent to prev, merge into one bigger block 
11f1 60			      ld    H, B                    ; Load next ptr from freed block into DE 
11f2 69			      ld    L, C 
11f3 5e			      ld    E, (HL) 
11f4 23			      inc   HL 
11f5 56			      ld    D, (HL) 
11f6 e5			      push  HL                      ; Save freed block ptr for later 
11f7			 
11f7 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
11fa dd 66 03		      ld    H, (IX+3) 
11fd 73			      ld    (HL), E 
11fe 23			      inc   HL 
11ff 72			      ld    (HL), D 
1200			 
1200 e1			      pop   HL                      ; Restore freed block ptr 
1201 23			      inc   HL                      ; Load size of freed block into DE 
1202 5e			      ld    E, (HL) 
1203 23			      inc   HL 
1204 56			      ld    D, (HL) 
1205 d5			      push  DE                      ; Save freed block size for later 
1206			 
1206 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1209 dd 66 03		      ld    H, (IX+3) 
120c 23			      inc   HL 
120d 23			      inc   HL 
120e 5e			      ld    E, (HL) 
120f 23			      inc   HL 
1210 56			      ld    D, (HL) 
1211			 
1211 e1			      pop   HL                      ; Add sizes of both blocks 
1212 19			      add   HL, DE 
1213 eb			      ex    DE, HL 
1214			 
1214 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1217 dd 66 03		      ld    H, (IX+3) 
121a 23			      inc   HL 
121b 23			      inc   HL 
121c 73			      ld    (HL), E 
121d 23			      inc   HL 
121e 72			      ld    (HL), D 
121f			 
121f			free_done: 
121f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1222 39			      add   HL, SP 
1223 f9			      ld    SP, HL 
1224			 
1224			free_early_exit: 
1224 dd e1		      pop   IX 
1226 d1			      pop   DE 
1227 c1			      pop   BC 
1228			 
1228 c9			      ret 
1229			 
1229			; moved to firmware.asm 
1229			; 
1229			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1229			;                  .dw   0 
1229			 
1229			 
1229			endif 
1229			 
1229			 
1229			if MALLOC_3 
1229			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1229			;heap_start        .equ  0x9000      ; Starting address of heap 
1229			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1229			; 
1229			 ;     .org 0 
1229			  ;    jp    main 
1229			; 
1229			; 
1229			 ;     .org  0x100 
1229			;main: 
1229			 ;     ld    HL, 0x8100 
1229			  ;    ld    SP, HL 
1229			; 
1229			;      call  heap_init 
1229			 
1229			      ; Make some allocations 
1229			;      ld    HL, 12 
1229			;      call  malloc            ; Allocates 0x9004 
1229			; 
1229			 ;     ld    HL, 12 
1229			;      call  malloc            ; Allocates 0x9014 
1229			 
1229			;      ld    HL, 12 
1229			;      call  malloc            ; Allocates 0x9024 
1229			 
1229			      ; Free some allocations 
1229			;      ld    HL, 0x9014 
1229			;      call  free 
1229			 
1229			;      ld    HL, 0x9004 
1229			;      call  free 
1229			; 
1229			;      ld    HL, 0x9024 
1229			;      call  free 
1229			 
1229			 
1229			 ;     halt 
1229			 
1229			 
1229			;------------------------------------------------------------------------------ 
1229			;     heap_init                                                               : 
1229			;                                                                             : 
1229			; Description                                                                 : 
1229			;     Initialise the heap and make it ready for malloc and free operations.   : 
1229			;                                                                             : 
1229			;     The heap is maintained as a linked list, starting with an initial       : 
1229			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1229			;     the first free block in the heap. Each block then points to the next    : 
1229			;     free block within the heap, and the free list ends at the first block   : 
1229			;     with a null pointer to the next free block.                             : 
1229			;                                                                             : 
1229			; Parameters                                                                  : 
1229			;     Inputs are compile-time only. Two defines which specify the starting    : 
1229			;     address of the heap and its size are required, along with a memory      : 
1229			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1229			;     principally stores a pointer to the first free block in the heap.       : 
1229			;                                                                             : 
1229			; Returns                                                                     : 
1229			;     Nothing                                                                 : 
1229			;------------------------------------------------------------------------------ 
1229			heap_init: 
1229			      push  HL 
1229			 
1229			      ; Initialise free list struct 
1229			      ld    HL, heap_start 
1229			      ld    (free_list), HL 
1229			      ld    HL, 0 
1229			      ld    (free_list+2), HL 
1229			 
1229			      ; Insert first free block at bottom of heap, consumes entire heap 
1229			      ld    HL, heap_start+heap_size-4 
1229			      ld    (heap_start), HL        ; Next block (end of free list) 
1229			      ld    HL, heap_size-4 
1229			      ld    (heap_start+2), HL      ; Block size 
1229			 
1229			      ; Insert end of free list block at top of heap - two null words will 
1229			      ; terminate the free list 
1229			      ld    HL, 0 
1229			      ld    (heap_start+heap_size-2), HL 
1229			      ld    (heap_start+heap_size-4), HL 
1229			 
1229			      pop   HL 
1229			 
1229			      ret 
1229			 
1229			 
1229			;------------------------------------------------------------------------------ 
1229			;     malloc                                                                  : 
1229			;                                                                             : 
1229			; Description                                                                 : 
1229			;     Allocates the wanted space from the heap and returns the address of the : 
1229			;     first useable byte of the allocation.                                   : 
1229			;                                                                             : 
1229			;     Allocations can happen in one of two ways:                              : 
1229			;                                                                             : 
1229			;     1. A free block may be found which is the exact size wanted. In this    : 
1229			;        case the block is removed from the free list and retuedn to the      : 
1229			;        caller.                                                              : 
1229			;     2. A free block may be found which is larger than the size wanted. In   : 
1229			;        this case, the larger block is split into two. The first portion of  : 
1229			;        this block will become the requested space by the malloc call and    : 
1229			;        is returned to the caller. The second portion becomes a new free     : 
1229			;        block, and the free list is adjusted to maintain continuity via this : 
1229			;        newly created block.                                                 : 
1229			;                                                                             : 
1229			;     malloc does not set any initial value in the allocated space, the       : 
1229			;     caller is required to do this as required.                              : 
1229			;                                                                             : 
1229			;     This implementation of malloc uses the stack exclusively, and is        : 
1229			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1229			;     advisable to disable interrupts before calling malloc, and recommended  : 
1229			;     to avoid the use of malloc inside ISRs in general.                      : 
1229			;                                                                             : 
1229			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1229			;                                                                             : 
1229			; Parameters                                                                  : 
1229			;     HL  Number of bytes wanted                                              : 
1229			;                                                                             : 
1229			; Returns                                                                     : 
1229			;     HL  Address of the first useable byte of the allocation                 : 
1229			;                                                                             : 
1229			; Flags                                                                       : 
1229			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1229			;                                                                             : 
1229			; Stack frame                                                                 : 
1229			;       |             |                                                       : 
1229			;       +-------------+                                                       : 
1229			;       |     BC      |                                                       : 
1229			;       +-------------+                                                       : 
1229			;       |     DE      |                                                       : 
1229			;       +-------------+                                                       : 
1229			;       |     IX      |                                                       : 
1229			;       +-------------+                                                       : 
1229			;       |  prev_free  |                                                       : 
1229			;   +4  +-------------+                                                       : 
1229			;       |  this_free  |                                                       : 
1229			;   +2  +-------------+                                                       : 
1229			;       |  next_free  |                                                       : 
1229			;   +0  +-------------+                                                       : 
1229			;       |             |                                                       : 
1229			;                                                                             : 
1229			;------------------------------------------------------------------------------ 
1229			malloc: 
1229			      push  BC 
1229			      push  DE 
1229			      push  IX 
1229			 
1229			      ld    A, H                    ; Exit if no space requested 
1229			      or    L 
1229			      jp    Z, malloc_early_exit 
1229			 
1229			      ; Set up stack frame 
1229			      ex    DE, HL 
1229			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1229			      add   HL, SP 
1229			      ld    SP, HL 
1229			      ld    IX, 0                   ; Use IX as a frame pointer 
1229			      add   IX, SP 
1229			 
1229			      ; Setup initial state 
1229			      ld    HL, 4                   ; want must also include space used by block struct 
1229			      add   HL, DE 
1229			 
1229			      ld    B, H                    ; Move want to BC 
1229			      ld    C, L 
1229			 
1229			      ld    HL, free_list           ; Store prev_free ptr to stack 
1229			      ld    (IX+4), L 
1229			      ld    (IX+5), H 
1229			 
1229			      ld    E, (HL)                 ; Store this_free ptr to stack 
1229			      inc   HL 
1229			      ld    D, (HL) 
1229			      ld    (IX+2), E 
1229			      ld    (IX+3), D 
1229			      ex    DE, HL                  ; this_free ptr into HL 
1229			 
1229			      ; Loop through free block list to find some space 
1229			malloc_find_space: 
1229			      ld    E, (HL)                 ; Load next_free ptr into DE 
1229			      inc   HL 
1229			      ld    D, (HL) 
1229			 
1229			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1229			      or    E 
1229			      jp    Z, malloc_no_space 
1229			 
1229			      ld    (IX+0), E               ; Store next_free ptr to stack 
1229			      ld    (IX+1), D 
1229			 
1229			      ; Does this block have enough space to make the allocation? 
1229			      inc   HL                      ; Load free block size into DE 
1229			      ld    E, (HL) 
1229			      inc   HL 
1229			      ld    D, (HL) 
1229			 
1229			      ex    DE, HL                  ; Check size of block against want 
1229			      or    A                       ; Ensure carry flag clear 
1229			      sbc   HL, BC 
1229			      push  HL                      ; Store the result for later (new block size) 
1229			 
1229			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1229			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1229			 
1229			      ; this_free block is not big enough, setup ptrs to test next free block 
1229			      pop   HL                      ; Discard previous result 
1229			 
1229			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1229			      ld    H, (IX+3) 
1229			      ld    (IX+4), L 
1229			      ld    (IX+5), H 
1229			 
1229			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1229			      ld    H, (IX+1) 
1229			      ld    (IX+2), L 
1229			      ld    (IX+3), H 
1229			 
1229			      jr    malloc_find_space 
1229			 
1229			      ; split a bigger block into two - requested size and remaining size 
1229			malloc_alloc_split: 
1229			      ex    DE, HL                  ; Calculate address of new free block 
1229			      dec   HL 
1229			      dec   HL 
1229			      dec   HL 
1229			      add   HL, BC 
1229			 
1229			      ; Create a new block and point it at next_free 
1229			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1229			      ld    D, (IX+1) 
1229			 
1229			      ld    (HL), E                 ; Store next_free ptr into new block 
1229			      inc   HL 
1229			      ld    (HL), D 
1229			 
1229			      pop   DE                      ; Store size of new block into new block 
1229			      inc   HL 
1229			      ld    (HL), E 
1229			      inc   HL 
1229			      ld    (HL), D 
1229			 
1229			      ; Update this_free ptr to point to new block 
1229			      dec   HL 
1229			      dec   HL 
1229			      dec   HL 
1229			 
1229			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1229			      ld    D, (IX+3) 
1229			 
1229			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1229			      ld    (IX+3), H 
1229			 
1229			      ; Modify this_free block to be allocation 
1229			      ex    DE, HL 
1229			      xor   A                       ; Null the next block ptr of allocated block 
1229			      ld    (HL), A 
1229			      inc   HL 
1229			      ld    (HL), A 
1229			 
1229			      inc   HL                      ; Store want size into allocated block 
1229			      ld    (HL), C 
1229			      inc   HL 
1229			      ld    (HL), B 
1229			      inc   HL 
1229			      push  HL                      ; Address of allocation to return 
1229			 
1229			      jr    malloc_update_links 
1229			 
1229			malloc_alloc_fit: 
1229			      pop   HL                      ; Dont need new block size, want is exact fit 
1229			 
1229			      ; Modify this_free block to be allocation 
1229			      ex    DE, HL 
1229			      dec   HL 
1229			      dec   HL 
1229			      dec   HL 
1229			 
1229			      xor   A                       ; Null the next block ptr of allocated block 
1229			      ld    (HL), A 
1229			      inc   HL 
1229			      ld    (HL), A 
1229			 
1229			      inc   HL                      ; Store address of allocation to return 
1229			      inc   HL 
1229			      inc   HL 
1229			      push  HL 
1229			 
1229			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1229			      ld    L, (IX+0)               ; next_free to HL 
1229			      ld    H, (IX+1) 
1229			 
1229			      ld    (IX+2), L               ; HL to this_free 
1229			      ld    (IX+3), H 
1229			 
1229			 
1229			malloc_update_links: 
1229			      ; Update prev_free ptr to point to this_free 
1229			      ld    L, (IX+4)               ; prev_free ptr to HL 
1229			      ld    H, (IX+5) 
1229			 
1229			      ld    E, (IX+2)               ; this_free ptr to DE 
1229			      ld    D, (IX+3) 
1229			 
1229			      ld    (HL), E                 ; this_free ptr into prev_free 
1229			      inc   HL 
1229			      ld    (HL), D 
1229			 
1229			      ; Clear the Z flag to indicate successful allocation 
1229			      ld    A, D 
1229			      or    E 
1229			 
1229			      pop   DE                      ; Address of allocation 
1229			 
1229			malloc_no_space: 
1229			      ld    HL, 6                   ; Clean up stack frame 
1229			      add   HL, SP 
1229			      ld    SP, HL 
1229			 
1229			      ex    DE, HL                  ; Alloc addr into HL for return 
1229			 
1229			malloc_early_exit: 
1229			      pop   IX 
1229			      pop   DE 
1229			      pop   BC 
1229			 
1229			      ret 
1229			 
1229			 
1229			;------------------------------------------------------------------------------ 
1229			;     free                                                                    : 
1229			;                                                                             : 
1229			; Description                                                                 : 
1229			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1229			;     returned by malloc, otherwise the behaviour is undefined.               : 
1229			;                                                                             : 
1229			;     Where possible, directly adjacent free blocks will be merged together   : 
1229			;     into larger blocks to help ensure that the heap does not become         : 
1229			;     excessively fragmented.                                                 : 
1229			;                                                                             : 
1229			;     free does not clear or set any other value into the freed space, and    : 
1229			;     therefore its contents may be visible through subsequent malloc's. The  : 
1229			;     caller should clear the freed space as required.                        : 
1229			;                                                                             : 
1229			;     This implementation of free uses the stack exclusively, and is          : 
1229			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1229			;     advisable to disable interrupts before calling free, and recommended    : 
1229			;     to avoid the use of free inside ISRs in general.                        : 
1229			;                                                                             : 
1229			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1229			;                                                                             : 
1229			; Parameters                                                                  : 
1229			;     HL  Pointer to address of first byte of allocation to be freed          : 
1229			;                                                                             : 
1229			; Returns                                                                     : 
1229			;     Nothing                                                                 : 
1229			;                                                                             : 
1229			; Stack frame                                                                 : 
1229			;       |             |                                                       : 
1229			;       +-------------+                                                       : 
1229			;       |     BC      |                                                       : 
1229			;       +-------------+                                                       : 
1229			;       |     DE      |                                                       : 
1229			;       +-------------+                                                       : 
1229			;       |     IX      |                                                       : 
1229			;       +-------------+                                                       : 
1229			;       |  prev_free  |                                                       : 
1229			;   +2  +-------------+                                                       : 
1229			;       |  next_free  |                                                       : 
1229			;   +0  +-------------+                                                       : 
1229			;       |             |                                                       : 
1229			;                                                                             : 
1229			;------------------------------------------------------------------------------ 
1229			free: 
1229			      push  BC 
1229			      push  DE 
1229			      push  IX 
1229			 
1229			      ld    A, H                    ; Exit if ptr is null 
1229			      or    L 
1229			      jp    Z, free_early_exit 
1229			 
1229			      ; Set up stack frame 
1229			      ex    DE, HL 
1229			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1229			      add   HL, SP 
1229			      ld    SP, HL 
1229			      ld    IX, 0                   ; Use IX as a frame pointer 
1229			      add   IX, SP 
1229			 
1229			      ; The address in HL points to the start of the useable allocated space, 
1229			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1229			      ; address of the block itself. 
1229			      ex    DE, HL 
1229			      ld    DE, -4 
1229			      add   HL, DE 
1229			 
1229			      ; An allocated block must have a null next block pointer in it 
1229			      ld    A, (HL) 
1229			      inc   HL 
1229			      or    (HL) 
1229			      jp    NZ, free_done 
1229			 
1229			      dec   HL 
1229			 
1229			      ld    B, H                    ; Copy HL to BC 
1229			      ld    C, L 
1229			 
1229			      ; Loop through the free list to find the first block with an address 
1229			      ; higher than the block being freed 
1229			      ld    HL, free_list 
1229			 
1229			free_find_higher_block: 
1229			      ld    E, (HL)                 ; Load next ptr from free block 
1229			      inc   HL 
1229			      ld    D, (HL) 
1229			      dec   HL 
1229			 
1229			      ld    (IX+0), E               ; Save ptr to next free block 
1229			      ld    (IX+1), D 
1229			      ld    (IX+2), L               ; Save ptr to prev free block 
1229			      ld    (IX+3), H 
1229			 
1229			      ld    A, B                    ; Check if DE is greater than BC 
1229			      cp    D                       ; Compare MSB first 
1229			      jr    Z, $+4                  ; MSB the same, compare LSB 
1229			      jr    NC, free_find_higher_block_skip 
1229			      ld    A, C 
1229			      cp    E                       ; Then compare LSB 
1229			      jr    C, free_found_higher_block 
1229			 
1229			free_find_higher_block_skip: 
1229			      ld    A, D                    ; Reached the end of the free list? 
1229			      or    E 
1229			      jp    Z, free_done 
1229			 
1229			      ex    DE, HL 
1229			 
1229			      jr    free_find_higher_block 
1229			 
1229			free_found_higher_block: 
1229			      ; Insert freed block between prev and next free blocks 
1229			      ld    (HL), C                 ; Point prev free block to freed block 
1229			      inc   HL 
1229			      ld    (HL), B 
1229			 
1229			      ld    H, B                    ; Point freed block at next free block 
1229			      ld    L, C 
1229			      ld    (HL), E 
1229			      inc   HL 
1229			      ld    (HL), D 
1229			 
1229			      ; Check if the freed block is adjacent to the next free block 
1229			      inc   HL                      ; Load size of freed block into HL 
1229			      ld    E, (HL) 
1229			      inc   HL 
1229			      ld    D, (HL) 
1229			      ex    DE, HL 
1229			 
1229			      add   HL, BC                  ; Add addr of freed block and its size 
1229			 
1229			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1229			      ld    D, (IX+1) 
1229			 
1229			      or    A                       ; Clear the carry flag 
1229			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1229			      jr    NZ, free_check_adjacent_to_prev 
1229			 
1229			      ; Freed block is adjacent to next, merge into one bigger block 
1229			      ex    DE, HL                  ; Load next ptr from next block into DE 
1229			      ld    E, (HL) 
1229			      inc   HL 
1229			      ld    D, (HL) 
1229			      push  HL                      ; Save ptr to next block for later 
1229			 
1229			      ld    H, B                    ; Store ptr from next block into freed block 
1229			      ld    L, C 
1229			      ld    (HL), E 
1229			      inc   HL 
1229			      ld    (HL), D 
1229			 
1229			      pop   HL                      ; Restore ptr to next block 
1229			      inc   HL                      ; Load size of next block into DE 
1229			      ld    E, (HL) 
1229			      inc   HL 
1229			      ld    D, (HL) 
1229			      push  DE                      ; Save next block size for later 
1229			 
1229			      ld    H, B                    ; Load size of freed block into HL 
1229			      ld    L, C 
1229			      inc   HL 
1229			      inc   HL 
1229			      ld    E, (HL) 
1229			      inc   HL 
1229			      ld    D, (HL) 
1229			      ex    DE, HL 
1229			 
1229			      pop   DE                      ; Restore size of next block 
1229			      add   HL, DE                  ; Add sizes of both blocks 
1229			      ex    DE, HL 
1229			 
1229			      ld    H, B                    ; Store new bigger size into freed block 
1229			      ld    L, C 
1229			      inc   HL 
1229			      inc   HL 
1229			      ld    (HL), E 
1229			      inc   HL 
1229			      ld    (HL), D 
1229			 
1229			free_check_adjacent_to_prev: 
1229			      ; Check if the freed block is adjacent to the prev free block 
1229			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1229			      ld    H, (IX+3) 
1229			 
1229			      inc   HL                      ; Size of prev free block into DE 
1229			      inc   HL 
1229			      ld    E, (HL) 
1229			      inc   HL 
1229			      ld    D, (HL) 
1229			      dec   HL 
1229			      dec   HL 
1229			      dec   HL 
1229			 
1229			      add   HL, DE                  ; Add prev block addr and size 
1229			 
1229			      or    A                       ; Clear the carry flag 
1229			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1229			      jr    NZ, free_done 
1229			 
1229			      ; Freed block is adjacent to prev, merge into one bigger block 
1229			      ld    H, B                    ; Load next ptr from freed block into DE 
1229			      ld    L, C 
1229			      ld    E, (HL) 
1229			      inc   HL 
1229			      ld    D, (HL) 
1229			      push  HL                      ; Save freed block ptr for later 
1229			 
1229			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1229			      ld    H, (IX+3) 
1229			      ld    (HL), E 
1229			      inc   HL 
1229			      ld    (HL), D 
1229			 
1229			      pop   HL                      ; Restore freed block ptr 
1229			      inc   HL                      ; Load size of freed block into DE 
1229			      ld    E, (HL) 
1229			      inc   HL 
1229			      ld    D, (HL) 
1229			      push  DE                      ; Save freed block size for later 
1229			 
1229			      ld    L, (IX+2)               ; Load size of prev block into DE 
1229			      ld    H, (IX+3) 
1229			      inc   HL 
1229			      inc   HL 
1229			      ld    E, (HL) 
1229			      inc   HL 
1229			      ld    D, (HL) 
1229			 
1229			      pop   HL                      ; Add sizes of both blocks 
1229			      add   HL, DE 
1229			      ex    DE, HL 
1229			 
1229			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1229			      ld    H, (IX+3) 
1229			      inc   HL 
1229			      inc   HL 
1229			      ld    (HL), E 
1229			      inc   HL 
1229			      ld    (HL), D 
1229			 
1229			free_done: 
1229			      ld    HL, 4                   ; Clean up stack frame 
1229			      add   HL, SP 
1229			      ld    SP, HL 
1229			 
1229			free_early_exit: 
1229			      pop   IX 
1229			      pop   DE 
1229			      pop   BC 
1229			 
1229			      ret 
1229			 
1229			 
1229			;      .org 0x8000 
1229			; 
1229			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1229			 ;                 .dw   0 
1229			 
1229			endif 
1229			 
1229			 
1229			if MALLOC_4 
1229			 
1229			; My memory allocation code. Very very simple.... 
1229			; allocate space under 250 chars 
1229			 
1229			heap_init: 
1229				; init start of heap as zero 
1229				;  
1229			 
1229				ld hl, heap_start 
1229				ld a, 0 
1229				ld (hl), a      ; empty block 
1229				inc hl 
1229				ld a, 0 
1229				ld (hl), a      ; length of block 
1229				; write end of list 
1229				inc hl 
1229				ld a,(hl) 
1229				inc hl 
1229				ld a,(hl) 
1229				 
1229			 
1229				; init some malloc vars 
1229			 
1229				ld hl, 0 
1229				ld (free_list), hl       ; store last malloc location 
1229			 
1229				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1229				ld a, 0 
1229				ld (hl), a 
1229			 
1229			 
1229				ld hl, heap_start 
1229				;  
1229				  
1229				ret 
1229			 
1229			 
1229			;    free block marker 
1229			;    requested size  
1229			;    pointer to next block 
1229			;    .... 
1229			;    next block marker 
1229			 
1229			 
1229			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1229			; 
1229			 
1229			 
1229			malloc:  
1229				push de 
1229				push bc 
1229				push af 
1229			 
1229				; hl space required 
1229				 
1229				ld c, l    ; hold space   (TODO only a max of 255) 
1229			 
1229			;	inc c     ; TODO BUG need to fix memory leak on push str 
1229			;	inc c 
1229			;	inc c 
1229			;	inc c 
1229			;	inc c 
1229			;	inc c 
1229			;	inc c 
1229			 
1229			 
1229			 
1229				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1229			 
1229				ld a, (free_list+3) 
1229				cp 0 
1229				jr z, .contheap 
1229			 
1229				ld hl, (free_list)     ; get last alloc 
1229					if DEBUG_FORTH_MALLOC_INT 
1229						DMARK "mrs" 
1229						CALLMONITOR 
1229					endif 
1229				jr .startalloc 
1229			 
1229			.contheap: 
1229				ld hl, heap_start 
1229			 
1229			.startalloc: 
1229			 
1229					if DEBUG_FORTH_MALLOC_INT 
1229						DMARK "mym" 
1229						CALLMONITOR 
1229					endif 
1229			.findblock: 
1229					if DEBUG_FORTH_MALLOC_INT 
1229						DMARK "mmf" 
1229						CALLMONITOR 
1229					endif 
1229			 
1229				ld a,(hl)  
1229				; if byte is zero then clear to use 
1229			 
1229				cp 0 
1229				jr z, .foundemptyblock 
1229			 
1229				; if byte is not clear 
1229				;     then byte is offset to next block 
1229			 
1229				inc hl 
1229				ld a, (hl) ; get size 
1229			.nextblock:	inc hl 
1229					ld e, (hl) 
1229					inc hl 
1229					ld d, (hl) 
1229					ex de, hl 
1229			;	inc hl  ; move past the store space 
1229			;	inc hl  ; move past zero index  
1229			 
1229				; TODO detect no more space 
1229			 
1229				push hl 
1229				ld de, heap_end 
1229				call cmp16 
1229				pop hl 
1229				jr nc, .nospace 
1229			 
1229				jr .findblock 
1229			 
1229			.nospace: ld hl, 0 
1229				jp .exit 
1229			 
1229			 
1229			.foundemptyblock:	 
1229					if DEBUG_FORTH_MALLOC_INT 
1229						DMARK "mme" 
1229						CALLMONITOR 
1229					endif 
1229			 
1229			; TODO has block enough space if reusing??? 
1229			 
1229				;  
1229			 
1229			; see if this block has been previously used 
1229				inc hl 
1229				ld a, (hl) 
1229				dec hl 
1229				cp 0 
1229				jr z, .newblock 
1229			 
1229					if DEBUG_FORTH_MALLOC_INT 
1229						DMARK "meR" 
1229						CALLMONITOR 
1229					endif 
1229			 
1229			; no reusing previously allocated block 
1229			 
1229			; is it smaller than previously used? 
1229				 
1229				inc hl    ; move to size 
1229				ld a, c 
1229				sub (hl)        ; we want c < (hl) 
1229				dec hl    ; move back to marker 
1229			        jr z, .findblock 
1229			 
1229				; update with the new size which should be lower 
1229			 
1229			        ;inc  hl   ; negate next move. move back to size  
1229			 
1229			.newblock: 
1229				; need to be at marker here 
1229			 
1229					if DEBUG_FORTH_MALLOC_INT 
1229						DMARK "meN" 
1229						CALLMONITOR 
1229					endif 
1229			 
1229			 
1229				ld a, c 
1229			 
1229				ld (free_list+3), a	 ; flag resume from last malloc  
1229				ld (free_list), hl    ; save out last location 
1229			 
1229			 
1229				;inc a     ; space for length byte 
1229				ld (hl), a     ; save block in use marker 
1229			 
1229				inc hl   ; move to space marker 
1229				ld (hl), a    ; save new space 
1229			 
1229				inc hl   ; move to start of allocated area 
1229				 
1229			;	push hl     ; save where we are - 1  
1229			 
1229			;	inc hl  ; move past zero index  
1229				; skip space to set down new marker 
1229			 
1229				; provide some extra space for now 
1229			 
1229				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1229				inc a 
1229				inc a 
1229			 
1229				push hl   ; save where we are in the node block 
1229			 
1229				call addatohl 
1229			 
1229				; write linked list point 
1229			 
1229				pop de     ; get our node position 
1229				ex de, hl 
1229			 
1229				ld (hl), e 
1229				inc hl 
1229				ld (hl), d 
1229			 
1229				inc hl 
1229			 
1229				; now at start of allocated data so save pointer 
1229			 
1229				push hl 
1229			 
1229				; jump to position of next node and setup empty header in DE 
1229			 
1229				ex de, hl 
1229			 
1229			;	inc hl ; move past end of block 
1229			 
1229				ld a, 0 
1229				ld (hl), a   ; empty marker 
1229				inc hl 
1229				ld (hl), a   ; size 
1229				inc hl  
1229				ld (hl), a   ; ptr 
1229				inc hl 
1229				ld (hl), a   ; ptr 
1229			 
1229			 
1229				pop hl 
1229			 
1229					if DEBUG_FORTH_MALLOC_INT 
1229						DMARK "mmr" 
1229						CALLMONITOR 
1229					endif 
1229			 
1229			.exit: 
1229				pop af 
1229				pop bc 
1229				pop de  
1229				ret 
1229			 
1229			 
1229			 
1229			 
1229			free:  
1229				push hl 
1229				push af 
1229				; get address in hl 
1229			 
1229					if DEBUG_FORTH_MALLOC_INT 
1229						DMARK "fre" 
1229						CALLMONITOR 
1229					endif 
1229				; data is at hl - move to block count 
1229				dec hl 
1229				dec hl    ; get past pointer 
1229				dec hl 
1229			 
1229				ld a, (hl)    ; need this for a validation check 
1229			 
1229				dec hl    ; move to block marker 
1229			 
1229				; now check that the block count and block marker are the same  
1229			        ; this checks that we are on a malloc node and not random memory 
1229			        ; OK a faint chance this could be a problem but rare - famous last words! 
1229			 
1229				ld c, a 
1229				ld a, (hl)    
1229			 
1229				cp c 
1229				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1229			 
1229				; yes good chance we are on a malloc node 
1229			 
1229				ld a, 0      
1229				ld (hl), a   ; mark as free 
1229			 
1229				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1229			 
1229			.freeignore:  
1229			 
1229				pop af 
1229				pop hl 
1229			 
1229				ret 
1229			 
1229			 
1229			 
1229			endif 
1229			 
1229			; eof 
# End of file firmware_memory.asm
1229			  
1229			; device C  
1229			if SOUND_ENABLE  
1229				include "firmware_sound.asm"  
1229			endif  
1229			  
1229			include "firmware_diags.asm"  
1229			; Hardware diags menu 
1229			 
1229			 
1229			config: 
1229			 
1229 3e 00			ld a, 0 
122b 21 59 12			ld hl, .configmn 
122e cd cd 09			call menu 
1231			 
1231 fe 00			cp 0 
1233 c8				ret z 
1234			 
1234 fe 01			cp 1 
1236 cc 18 13			call z, .savetostore 
1239			 
1239 fe 02			cp 2 
123b cc 04 13			call z, .selautoload 
123e fe 03			cp 3 
1240 cc fa 12			call z, .disautoload 
1243 fe 04			cp 4 
1245 cc 0e 13			call z, .selbank 
1248 fe 05			cp 5 
124a cc 39 13			call z, .debug_tog 
124d fe 06			cp 6 
124f cc 81 14			call z, .bpsgo 
1252 fe 07			cp 7 
1254 cc 5f 13			call z, hardware_diags 
1257			 
1257 18 d0			jr config 
1259			 
1259			.configmn: 
1259 69 12			dw .c3 
125b 80 12			dw .c2 
125d 95 12			dw .c2a 
125f ab 12			dw .c2b 
1261			;	dw .c4 
1261 c8 12			dw .m4 
1263 e3 12			dw .m4b 
1265 eb 12			dw .c1 
1267 00 00			dw 0 
1269				 
1269			 
1269 .. 00		.c3: db "Add Dictionary To File",0 
1280 .. 00		.c2: db "Select Autoload File",0 
1295 .. 00		.c2a: db "Disable Autoload File", 0 
12ab .. 00		.c2b: db "Select Storage Bank",0 
12bf .. 00		.c4: db "Settings",0 
12c8 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
12e3 .. 00		.m4b:   db "Monitor",0 
12eb .. 00		.c1: db "Hardware Diags",0 
12fa			 
12fa			 
12fa			.disautoload: 
12fa				if STORAGE_SE 
12fa				ld a, $fe      ; bit 0 clear 
12fa				ld (spi_device), a 
12fa			 
12fa				call storage_get_block_0 
12fa			 
12fa				ld a, 0 
12fa				ld (store_page+STORE_0_AUTOFILE), a 
12fa			 
12fa					ld hl, 0 
12fa					ld de, store_page 
12fa				call storage_write_block	 ; save update 
12fa				else 
12fa			 
12fa 21 22 13			ld hl, .notav 
12fd 11 38 13			ld de, .empty 
1300 cd 2d 09			call info_panel 
1303				endif 
1303			 
1303			 
1303 c9				ret 
1304			 
1304			 
1304			 
1304			; Select auto start 
1304			 
1304			.selautoload: 
1304			 
1304				 
1304				if STORAGE_SE 
1304			 
1304					call config_dir 
1304				        ld hl, scratch 
1304					ld a, 0 
1304					call menu 
1304			 
1304					cp 0 
1304					ret z 
1304			 
1304					dec a 
1304			 
1304			 
1304					; locate menu option 
1304			 
1304					ld hl, scratch 
1304					call table_lookup 
1304			 
1304					if DEBUG_FORTH_WORDS 
1304						DMARK "ALl" 
1304						CALLMONITOR 
1304					endif 
1304					; with the pointer to the menu it, the byte following the zero term is the file id 
1304			 
1304					ld a, 0 
1304					ld bc, 50   ; max of bytes to look at 
1304					cpir  
1304			 
1304					if DEBUG_FORTH_WORDS 
1304						DMARK "ALb" 
1304						CALLMONITOR 
1304					endif 
1304					;inc hl 
1304			 
1304					ld a, (hl)   ; file id 
1304					 
1304				        ; save bank and file ids 
1304			 
1304					push af 
1304			 
1304			; TODO need to save to block 0 on bank 1	 
1304			 
1304					call storage_get_block_0 
1304			 
1304					if DEBUG_FORTH_WORDS 
1304						DMARK "AL0" 
1304						CALLMONITOR 
1304					endif 
1304					pop af 
1304			 
1304					ld (store_page+STORE_0_FILERUN),a 
1304					 
1304					; save bank id 
1304			 
1304					ld a,(spi_device) 
1304					ld (store_page+STORE_0_BANKRUN),a 
1304			 
1304					; enable auto run of store file 
1304			 
1304					ld a, 1 
1304					ld (store_page+STORE_0_AUTOFILE),a 
1304			 
1304					; save buffer 
1304			 
1304					ld hl, 0 
1304					ld de, store_page 
1304					if DEBUG_FORTH_WORDS 
1304						DMARK "ALw" 
1304						CALLMONITOR 
1304					endif 
1304				call storage_write_block	 ; save update 
1304			  
1304			 
1304			 
1304			 
1304					ld hl, scratch 
1304					call config_fdir 
1304			 
1304				else 
1304			 
1304 21 22 13			ld hl, .notav 
1307 11 38 13			ld de, .empty 
130a cd 2d 09			call info_panel 
130d			 
130d				endif 
130d c9				ret 
130e			 
130e			 
130e			 
130e			; Select storage bank 
130e			 
130e			.selbank: 
130e			 
130e				if STORAGE_SE 
130e				else 
130e			 
130e 21 22 13			ld hl, .notav 
1311 11 38 13			ld de, .empty 
1314 cd 2d 09			call info_panel 
1317				endif 
1317				 
1317 c9				ret 
1318			 
1318			if STORAGE_SE 
1318			 
1318			.config_ldir:   
1318				; Load storage bank labels into menu array 
1318			 
1318				 
1318			 
1318			 
1318				ret 
1318			 
1318			 
1318			endif 
1318			 
1318			 
1318			; Save user words to storage 
1318			 
1318			.savetostore: 
1318			 
1318				if STORAGE_SE 
1318			 
1318					call config_dir 
1318				        ld hl, scratch 
1318					ld a, 0 
1318					call menu 
1318					 
1318					ld hl, scratch 
1318					call config_fdir 
1318			 
1318				else 
1318			 
1318 21 22 13			ld hl, .notav 
131b 11 38 13			ld de, .empty 
131e cd 2d 09			call info_panel 
1321			 
1321				endif 
1321			 
1321 c9				ret 
1322 .. 00		.notav:    db "Feature not available",0 
1338 .. 00		.empty:    db "",0 
1339			 
1339			 
1339			 
1339			if STORAGE_SE 
1339			 
1339			config_fdir: 
1339				; using the scratch dir go through and release the memory allocated for each string 
1339				 
1339				ld hl, scratch 
1339			.cfdir:	ld e,(hl) 
1339				inc hl 
1339				ld d,(hl) 
1339				inc hl 
1339			 
1339				ex de, hl 
1339				call ishlzero 
1339				ret z     ; return on null pointer 
1339				call free 
1339				ex de, hl 
1339				jr .cfdir 
1339			 
1339			 
1339				ret 
1339			 
1339			 
1339			config_dir: 
1339			 
1339				; for the config menus that need to build a directory of storage call this routine 
1339				; it will construct a menu in scratch to pass to menu 
1339			 
1339				; open storage device 
1339			 
1339				; execute DIR to build a list of files and their ids into scratch in menu format 
1339				; once the menu has finished then will need to call config_fdir to release the strings 
1339				 
1339				; c = number items 
1339			 
1339				 
1339				call storage_get_block_0 
1339			 
1339				ld hl, store_page     ; get current id count 
1339				ld b, (hl) 
1339				ld c, 0    ; count of files   
1339			 
1339			 
1339				ld hl, scratch 
1339				ld (store_tmp2), hl    ; location to poke strings 
1339			 
1339				; check for empty drive 
1339			 
1339				ld a, 0 
1339				cp b 
1339				jp z, .dirdone 
1339			 
1339				 
1339					if DEBUG_FORTH_WORDS 
1339						DMARK "Cdc" 
1339						CALLMONITOR 
1339					endif 
1339			 
1339			 
1339			.diritem:	 
1339				push bc 
1339				; for each of the current ids do a search for them and if found push to stack 
1339			 
1339					ld hl, STORE_BLOCK_PHY 
1339					ld d, 0		 ; look for extent 0 of block id as this contains file name 
1339					ld e,b 
1339			 
1339					call storage_findnextid 
1339			 
1339			 
1339					; if found hl will be non zero 
1339			 
1339					call ishlzero 
1339					jr z, .dirnotfound 
1339			 
1339					; increase count 
1339			 
1339					pop bc	 
1339					inc c 
1339					push bc 
1339					 
1339			 
1339					; get file header and push the file name 
1339			 
1339					ld de, store_page 
1339					call storage_read_block 
1339			 
1339					; push file id to stack 
1339				 
1339					ld a, (store_page) 
1339					ld h, 0 
1339					ld l, a 
1339			 
1339					;call forth_push_numhl 
1339					; TODO store id 
1339			 
1339					push hl 
1339			 
1339					; push extent count to stack  
1339				 
1339					ld hl, store_page+3 
1339			 
1339					; get file name length 
1339			 
1339					call strlenz   
1339			 
1339					inc hl   ; cover zero term 
1339					inc hl  ; stick the id at the end of the area 
1339			 
1339					push hl 
1339					pop bc    ; move length to bc 
1339			 
1339					call malloc 
1339			 
1339					; TODO save malloc area to scratch 
1339			 
1339					ex de, hl 
1339					ld hl, (store_tmp2) 
1339					ld (hl), e 
1339					inc hl 
1339					ld (hl), d 
1339					inc hl 
1339					ld (store_tmp2), hl 
1339			 
1339					 
1339			 
1339					;pop hl   ; get source 
1339			;		ex de, hl    ; swap aronund	 
1339			 
1339					ld hl, store_page+3 
1339					if DEBUG_FORTH_WORDS 
1339						DMARK "CFd" 
1339						CALLMONITOR 
1339					endif 
1339					ldir 
1339			 
1339					; de is past string, move back one and store id 
1339					 
1339					dec de 
1339			 
1339					; store file id 
1339			 
1339					pop hl 
1339					ex de,hl 
1339					ld (hl), e 
1339			 
1339					if DEBUG_FORTH_WORDS 
1339						DMARK "Cdi" 
1339						CALLMONITOR 
1339					endif 
1339					 
1339			.dirnotfound: 
1339					pop bc     
1339					djnz .diritem 
1339				 
1339			.dirdone:	 
1339			 
1339					ld a, 0 
1339					ld hl, (store_tmp2) 
1339					ld (hl), a 
1339					inc hl 
1339					ld (hl), a 
1339					inc hl 
1339					; push a count of the dir items found 
1339			 
1339			;		ld h, 0 
1339			;		ld l, c 
1339			 
1339				ret 
1339			 
1339			endif 
1339			 
1339			 
1339			; Settings 
1339			; Run  
1339			 
1339			 
1339			 
1339			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1339			;;hd_menu2:   db "        2: Editor",0   
1339			;hd_menu2:   db "        2: Editor       6: Menu",0   
1339			;hd_menu3:   db "        3: Storage",0 
1339			;hd_menu4:   db "0=quit  4: Debug",0 
1339			;hd_don:     db "ON",0 
1339			;hd_doff:     db "OFF",0 
1339			; 
1339			; 
1339			; 
1339			;hardware_diags_old:       
1339			; 
1339			;.diagmenu: 
1339			;	call clear_display 
1339			;	ld a, display_row_1 
1339			;	ld de, hd_menu1 
1339			;	call str_at_display 
1339			; 
1339			;	ld a, display_row_2 
1339			;	ld de, hd_menu2 
1339			;	call str_at_display 
1339			; 
1339			;	ld a, display_row_3 
1339			;	ld de, hd_menu3 
1339			;	call str_at_display 
1339			; 
1339			;	ld a,  display_row_4 
1339			;	ld de, hd_menu4 
1339			;	call str_at_display 
1339			; 
1339			;	; display debug state 
1339			; 
1339			;	ld de, hd_don 
1339			;	ld a, (os_view_disable) 
1339			;	cp 0 
1339			;	jr z, .distog 
1339			;	ld de, hd_doff 
1339			;.distog: ld a, display_row_4+17 
1339			;	call str_at_display 
1339			; 
1339			;	call update_display 
1339			; 
1339			;	call cin_wait 
1339			; 
1339			; 
1339			; 
1339			;	cp '4' 
1339			;	jr nz, .diagn1 
1339			; 
1339			;	; debug toggle 
1339			; 
1339			;	ld a, (os_view_disable) 
1339			;	ld b, '*' 
1339			;	cp 0 
1339			;	jr z, .debtog 
1339			;	ld b, 0 
1339			;.debtog:	 
1339			;	ld a,b 
1339			;	ld (os_view_disable),a 
1339			; 
1339			;.diagn1: cp '0' 
1339			;	 ret z 
1339			; 
1339			;;	cp '1' 
1339			;;       jp z, matrix	 
1339			;;   TODO keyboard matrix test 
1339			; 
1339			;	cp '2' 
1339			;	jp z, .diagedit 
1339			; 
1339			;;	cp '6' 
1339			;;	jp z, .menutest 
1339			;;if ENABLE_BASIC 
1339			;;	cp '6' 
1339			;;	jp z, basic 
1339			;;endif 
1339			 ; 
1339			;	jp .diagmenu 
1339			; 
1339			; 
1339			;	ret 
1339			 
1339			 
1339			.debug_tog: 
1339 21 80 13			ld hl, .menudebug 
133c				 
133c 3a 51 e3			ld a, (os_view_disable) 
133f fe 2a			cp '*' 
1341 20 04			jr nz,.tdon  
1343 3e 01			ld a, 1 
1345 18 02			jr .tog1 
1347 3e 00		.tdon: ld a, 0 
1349			 
1349			.tog1: 
1349 cd cd 09			call menu 
134c fe 00			cp 0 
134e c8				ret z 
134f fe 01			cp 1    ; disable debug 
1351 28 04			jr z, .dtog0 
1353 3e 2a			ld a, '*' 
1355 18 02			jr .dtogset 
1357 3e 00		.dtog0: ld a, 0 
1359 32 51 e3		.dtogset:  ld (os_view_disable), a 
135c c3 39 13			jp .debug_tog 
135f			 
135f			 
135f			hardware_diags:       
135f			 
135f			.diagm: 
135f 21 72 13			ld hl, .menuitems 
1362 3e 00			ld a, 0 
1364 cd cd 09			call menu 
1367			 
1367 fe 00		         cp 0 
1369 c8				 ret z 
136a			 
136a fe 02			cp 2 
136c ca cb 13			jp z, .diagedit 
136f			 
136f			;	cp '6' 
136f			;	jp z, .menutest 
136f			;if ENABLE_BASIC 
136f			;	cp '6' 
136f			;	jp z, basic 
136f			;endif 
136f			  
136f c3 5f 13			jp .diagm 
1372			 
1372				 
1372 86 13		.menuitems:   	dw .m1 
1374 91 13				dw .m2 
1376 98 13				dw .m3 
1378 a0 13				dw .m5 
137a a6 13				dw .m5a 
137c af 13				dw .m5b 
137e 00 00				dw 0 
1380			 
1380			.menudebug: 
1380 b8 13				dw .m6 
1382 c1 13				dw .m7 
1384 00 00				dw 0 
1386			 
1386 .. 00		.m1:   db "Key Matrix",0 
1391 .. 00		.m2:   db "Editor",0 
1398 .. 00		.m3:   db "Storage",0 
13a0 .. 00		.m5:   db "Sound",0 
13a6 .. 00		.m5a:  db "RAM Test",0 
13af .. 00		.m5b:  db "LCD Test",0 
13b8			 
13b8 .. 00		.m6:   db "Debug ON",0 
13c1 .. 00		.m7:   db "Debug OFF",0 
13cb			 
13cb			; debug editor 
13cb			 
13cb			.diagedit: 
13cb			 
13cb 21 60 e3			ld hl, scratch 
13ce			;	ld bc, 250 
13ce			;	ldir 
13ce				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
13ce 3e 00			ld a, 0 
13d0 77				ld (hl), a 
13d1 23				inc hl 
13d2 77				ld (hl), a 
13d3 23				inc hl 
13d4 77				ld (hl), a 
13d5			 
13d5 cd 9c 09		        call clear_display 
13d8 cd bf 09			call update_display 
13db 3e 01			ld a, 1 
13dd 32 80 ee			ld (hardware_diag), a 
13e0			.diloop: 
13e0 3e 00			ld a, display_row_1 
13e2 0e 00			ld c, 0 
13e4 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
13e6 1e 28			ld e, 40 
13e8			 
13e8 21 60 e3			ld hl, scratch	 
13eb cd f6 0b			call input_str 
13ee			 
13ee 3e 28			ld a, display_row_2 
13f0 11 60 e3			ld de, scratch 
13f3 cd af 09			call str_at_display 
13f6 cd bf 09			call update_display 
13f9			 
13f9 c3 e0 13			jp .diloop 
13fc			 
13fc			 
13fc			; pass word in hl 
13fc			; a has display location 
13fc			display_word_at: 
13fc f5				push af 
13fd e5				push hl 
13fe 7c				ld a,h 
13ff 21 65 e6			ld hl, os_word_scratch 
1402 cd ca 0e			call hexout 
1405 e1				pop hl 
1406 7d				ld a,l 
1407 21 67 e6			ld hl, os_word_scratch+2 
140a cd ca 0e			call hexout 
140d 21 69 e6			ld hl, os_word_scratch+4 
1410 3e 00			ld a,0 
1412 77				ld (hl),a 
1413 11 65 e6			ld de,os_word_scratch 
1416 f1				pop af 
1417 cd af 09				call str_at_display 
141a c9				ret 
141b			 
141b			display_ptr_state: 
141b			 
141b				; to restore afterwards 
141b			 
141b d5				push de 
141c c5				push bc 
141d e5				push hl 
141e f5				push af 
141f			 
141f				; for use in here 
141f			 
141f			;	push bc 
141f			;	push de 
141f			;	push hl 
141f			;	push af 
141f			 
141f cd 9c 09			call clear_display 
1422			 
1422 11 f5 15			ld de, .ptrstate 
1425 3e 00			ld a, display_row_1 
1427 cd af 09			call str_at_display 
142a			 
142a				; display debug step 
142a			 
142a			 
142a 11 7a ee			ld de, debug_mark 
142d 3e 26			ld a, display_row_1+display_cols-2 
142f cd af 09			call str_at_display 
1432			 
1432				; display a 
1432 11 ff 15			ld de, .ptrcliptr 
1435 3e 28			ld a, display_row_2 
1437 cd af 09			call str_at_display 
143a			 
143a f1				pop af 
143b 2a 2b eb			ld hl,(cli_ptr) 
143e 3e 30			ld a, display_row_2+8 
1440 cd fc 13			call display_word_at 
1443			 
1443			 
1443				; display hl 
1443			 
1443			 
1443 11 07 16			ld de, .ptrclioptr 
1446 3e 32			ld a, display_row_2+10 
1448 cd af 09			call str_at_display 
144b			; 
144b			;	pop hl 
144b 3e 35			ld a, display_row_2+13 
144d 2a 29 eb			ld hl,(cli_origptr) 
1450 cd fc 13			call display_word_at 
1453			; 
1453			;	 
1453			;	; display de 
1453			 
1453			;	ld de, .regstatede 
1453			;	ld a, display_row_3 
1453			;	call str_at_display 
1453			 
1453			;	pop de 
1453			;	ld h,d 
1453			;	ld l, e 
1453			;	ld a, display_row_3+3 
1453			;	call display_word_at 
1453			 
1453			 
1453				; display bc 
1453			 
1453			;	ld de, .regstatebc 
1453			;	ld a, display_row_3+10 
1453			;	call str_at_display 
1453			 
1453			;	pop bc 
1453			;	ld h,b 
1453			;	ld l, c 
1453			;	ld a, display_row_3+13 
1453			;	call display_word_at 
1453			 
1453			 
1453				; display dsp 
1453			 
1453			;	ld de, .regstatedsp 
1453			;	ld a, display_row_4 
1453			;	call str_at_display 
1453			 
1453				 
1453			;	ld hl,(cli_data_sp) 
1453			;	ld a, display_row_4+4 
1453			;	call display_word_at 
1453			 
1453				; display rsp 
1453			 
1453 11 36 16			ld de, .regstatersp 
1456 3e 82			ld a, display_row_4+10 
1458 cd af 09			call str_at_display 
145b			 
145b				 
145b 2a 11 eb			ld hl,(cli_ret_sp) 
145e 3e 86			ld a, display_row_4+14 
1460 cd fc 13			call display_word_at 
1463			 
1463 cd bf 09			call update_display 
1466			 
1466 cd 0e 09			call delay1s 
1469 cd 0e 09			call delay1s 
146c cd 0e 09			call delay1s 
146f			 
146f			 
146f cd 7c 19			call next_page_prompt 
1472			 
1472				; restore  
1472			 
1472 f1				pop af 
1473 e1				pop hl 
1474 c1				pop bc 
1475 d1				pop de 
1476 c9				ret 
1477			 
1477			break_point_state: 
1477 f5				push af 
1478			 
1478				; see if disabled 
1478			 
1478 3a 51 e3			ld a, (os_view_disable) 
147b fe 2a			cp '*' 
147d 20 02			jr nz, .bpsgo 
147f f1				pop af 
1480 c9				ret 
1481			 
1481			.bpsgo: 
1481 f1				pop af 
1482 f5				push af 
1483 22 4d e3			ld (os_view_hl), hl 
1486 ed 53 4b e3		ld (os_view_de), de 
148a ed 43 49 e3		ld (os_view_bc), bc 
148e e5				push hl 
148f 6f				ld l, a 
1490 26 00			ld h, 0 
1492 22 4f e3			ld (os_view_af),hl 
1495			 
1495 21 c0 ed				ld hl, display_fb0 
1498 22 db eb				ld (display_fb_active), hl 
149b e1				pop hl	 
149c			 
149c 3e 31			ld a, '1' 
149e fe 2a		.bps1:  cp '*' 
14a0 20 03			jr nz, .bps1b 
14a2 32 51 e3			ld (os_view_disable),a 
14a5 fe 31		.bps1b:  cp '1' 
14a7 20 14			jr nz, .bps2 
14a9			 
14a9				; display reg 
14a9			 
14a9				 
14a9			 
14a9 3a 4f e3			ld a, (os_view_af) 
14ac 2a 4d e3			ld hl, (os_view_hl) 
14af ed 5b 4b e3		ld de, (os_view_de) 
14b3 ed 4b 49 e3		ld bc, (os_view_bc) 
14b7 cd 51 15			call display_reg_state 
14ba c3 3d 15			jp .bpschk 
14bd			 
14bd fe 32		.bps2:  cp '2' 
14bf 20 08			jr nz, .bps3 
14c1				 
14c1				; display hl 
14c1 2a 4d e3			ld hl, (os_view_hl) 
14c4 cd 3b 16			call display_dump_at_hl 
14c7			 
14c7 18 74			jr .bpschk 
14c9			 
14c9 fe 33		.bps3:  cp '3' 
14cb 20 08			jr nz, .bps4 
14cd			 
14cd			        ; display de 
14cd 2a 4b e3			ld hl, (os_view_de) 
14d0 cd 3b 16			call display_dump_at_hl 
14d3			 
14d3 18 68			jr .bpschk 
14d5 fe 34		.bps4:  cp '4' 
14d7 20 08			jr nz, .bps5 
14d9			 
14d9			        ; display bc 
14d9 2a 49 e3			ld hl, (os_view_bc) 
14dc cd 3b 16			call display_dump_at_hl 
14df			 
14df 18 5c			jr .bpschk 
14e1 fe 35		.bps5:  cp '5' 
14e3 20 08		        jr nz, .bps7 
14e5			 
14e5				; display cur ptr 
14e5 2a 2b eb			ld hl, (cli_ptr) 
14e8 cd 3b 16			call display_dump_at_hl 
14eb			 
14eb 18 50			jr .bpschk 
14ed fe 36		.bps7:  cp '6' 
14ef 20 08			jr nz, .bps8b 
14f1				 
14f1				; display cur orig ptr 
14f1 2a 29 eb			ld hl, (cli_origptr) 
14f4 cd 3b 16			call display_dump_at_hl 
14f7 18 44			jr .bpschk 
14f9 fe 37		.bps8b:  cp '7' 
14fb 20 08			jr nz, .bps9 
14fd				 
14fd				; display dsp 
14fd 2a 0d eb			ld hl, (cli_data_sp) 
1500 cd 3b 16			call display_dump_at_hl 
1503			 
1503 18 38			jr .bpschk 
1505 fe 39		.bps9:  cp '9' 
1507 20 05			jr nz, .bps8c 
1509				 
1509				; display SP 
1509			;	ld hl, sp 
1509 cd 3b 16			call display_dump_at_hl 
150c			 
150c 18 2f			jr .bpschk 
150e fe 38		.bps8c:  cp '8' 
1510 20 08			jr nz, .bps8d 
1512				 
1512				; display rsp 
1512 2a 11 eb			ld hl, (cli_ret_sp) 
1515 cd 3b 16			call display_dump_at_hl 
1518			 
1518 18 23			jr .bpschk 
151a fe 23		.bps8d:  cp '#'     ; access monitor sub system 
151c 20 05			jr nz, .bps8 
151e cd 72 17			call monitor 
1521			 
1521 18 1a			jr .bpschk 
1523 fe 30		.bps8:  cp '0' 
1525 20 16			jr nz, .bpschk 
1527			 
1527 21 1f ed				ld hl, display_fb1 
152a 22 db eb				ld (display_fb_active), hl 
152d cd bf 09				call update_display 
1530			 
1530				;ld a, (os_view_af) 
1530 2a 4d e3			ld hl, (os_view_hl) 
1533 ed 5b 4b e3		ld de, (os_view_de) 
1537 ed 4b 49 e3		ld bc, (os_view_bc) 
153b f1				pop af 
153c c9				ret 
153d			 
153d			.bpschk:   
153d cd 0e 09			call delay1s 
1540 3e 9f		ld a,display_row_4 + display_cols - 1 
1542 11 7a 19		        ld de, endprg 
1545 cd af 09			call str_at_display 
1548 cd bf 09			call update_display 
154b cd 21 59			call cin_wait 
154e			 
154e c3 9e 14			jp .bps1 
1551			 
1551			 
1551			display_reg_state: 
1551			 
1551				; to restore afterwards 
1551			 
1551 d5				push de 
1552 c5				push bc 
1553 e5				push hl 
1554 f5				push af 
1555			 
1555				; for use in here 
1555			 
1555 c5				push bc 
1556 d5				push de 
1557 e5				push hl 
1558 f5				push af 
1559			 
1559 cd 9c 09			call clear_display 
155c			 
155c 11 11 16			ld de, .regstate 
155f 3e 00			ld a, display_row_1 
1561 cd af 09			call str_at_display 
1564			 
1564				; display debug step 
1564			 
1564			 
1564 11 7a ee			ld de, debug_mark 
1567 3e 25			ld a, display_row_1+display_cols-3 
1569 cd af 09			call str_at_display 
156c			 
156c				; display a 
156c 11 2d 16			ld de, .regstatea 
156f 3e 28			ld a, display_row_2 
1571 cd af 09			call str_at_display 
1574			 
1574 e1				pop hl 
1575			;	ld h,0 
1575			;	ld l, a 
1575 3e 2b			ld a, display_row_2+3 
1577 cd fc 13			call display_word_at 
157a			 
157a			 
157a				; display hl 
157a			 
157a			 
157a 11 21 16			ld de, .regstatehl 
157d 3e 32			ld a, display_row_2+10 
157f cd af 09			call str_at_display 
1582			 
1582 e1				pop hl 
1583 3e 35			ld a, display_row_2+13 
1585 cd fc 13			call display_word_at 
1588			 
1588				 
1588				; display de 
1588			 
1588 11 25 16			ld de, .regstatede 
158b 3e 50			ld a, display_row_3 
158d cd af 09			call str_at_display 
1590			 
1590 e1				pop hl 
1591			;	ld h,d 
1591			;	ld l, e 
1591 3e 53			ld a, display_row_3+3 
1593 cd fc 13			call display_word_at 
1596			 
1596			 
1596				; display bc 
1596			 
1596 11 29 16			ld de, .regstatebc 
1599 3e 5a			ld a, display_row_3+10 
159b cd af 09			call str_at_display 
159e			 
159e e1				pop hl 
159f			;	ld h,b 
159f			;	ld l, c 
159f 3e 5d			ld a, display_row_3+13 
15a1 cd fc 13			call display_word_at 
15a4			 
15a4			 
15a4				; display dsp 
15a4			 
15a4 11 31 16			ld de, .regstatedsp 
15a7 3e 78			ld a, display_row_4 
15a9 cd af 09			call str_at_display 
15ac			 
15ac				 
15ac 2a 0d eb			ld hl,(cli_data_sp) 
15af 3e 7c			ld a, display_row_4+4 
15b1 cd fc 13			call display_word_at 
15b4			 
15b4				; display rsp 
15b4			 
15b4 11 36 16			ld de, .regstatersp 
15b7 3e 82			ld a, display_row_4+10 
15b9 cd af 09			call str_at_display 
15bc			 
15bc				 
15bc 2a 11 eb			ld hl,(cli_ret_sp) 
15bf 3e 86			ld a, display_row_4+14 
15c1 cd fc 13			call display_word_at 
15c4			 
15c4 cd bf 09			call update_display 
15c7			 
15c7			;	call delay1s 
15c7			;	call delay1s 
15c7			;	call delay1s 
15c7			 
15c7			 
15c7			;	call next_page_prompt 
15c7			 
15c7				; restore  
15c7			 
15c7 f1				pop af 
15c8 e1				pop hl 
15c9 c1				pop bc 
15ca d1				pop de 
15cb c9				ret 
15cc			 
15cc .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
15e0 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
15f5 .. 00		.ptrstate:	db "Ptr State",0 
15ff .. 00		.ptrcliptr:     db "cli_ptr",0 
1607 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1611 .. 00		.regstate:	db "Reg State (1/0)",0 
1621 .. 00		.regstatehl:	db "HL:",0 
1625 .. 00		.regstatede:	db "DE:",0 
1629 .. 00		.regstatebc:	db "BC:",0 
162d .. 00		.regstatea:	db "A :",0 
1631 .. 00		.regstatedsp:	db "DSP:",0 
1636 .. 00		.regstatersp:	db "RSP:",0 
163b			 
163b			display_dump_at_hl: 
163b e5				push hl 
163c d5				push de 
163d c5				push bc 
163e f5				push af 
163f			 
163f 22 83 e6			ld (os_cur_ptr),hl	 
1642 cd 9c 09			call clear_display 
1645 cd 84 18			call dumpcont 
1648			;	call delay1s 
1648			;	call next_page_prompt 
1648			 
1648			 
1648 f1				pop af 
1649 c1				pop bc 
164a d1				pop de 
164b e1				pop hl 
164c c9				ret 
164d			 
164d			;if ENABLE_BASIC 
164d			;	include "nascombasic.asm" 
164d			;	basic: 
164d			;	include "forth/FORTH.ASM" 
164d			;endif 
164d			 
164d			; eof 
164d			 
164d			 
# End of file firmware_diags.asm
164d			  
164d			  
164d			  
164d			  
164d			; eof  
164d			  
# End of file firmware.asm
164d			 
164d			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
164d			;if BASE_KEV  
164d			;baseram: equ 08000h 
164d			;endif 
164d			 
164d			;if BASE_SC114 
164d			;baseram:     equ    endofcode 
164d			;endif 
164d			 
164d			 
164d			; start system 
164d			 
164d			coldstart: 
164d				; set sp 
164d				; di/ei 
164d			 
164d f3				di 
164e 31 00 f0			ld sp, tos 
1651			;	ei 
1651			 
1651			 
1651				; disable breakpoint by default 
1651			 
1651 3e 2a			ld a,'*' 
1653 32 51 e3			ld (os_view_disable),a 
1656			 
1656				; init hardware 
1656			 
1656				; init keyboard and screen hardware 
1656			 
1656 cd 03 01			call hardware_init 
1659			 
1659			 
1659				; detect if any keys are held down to enable breakpoints at start up 
1659			 
1659 cd 29 59			call cin  
165c fe 00			cp 0 
165e 28 03			jr z, .nokeys 
1660			 
1660				;call hardware_diags 
1660 cd 29 12			call config 
1663			 
1663			;	ld de, .bpen 
1663			;	ld a, display_row_4 
1663			;	call str_at_display 
1663			;	call update_display 
1663			; 
1663			;	ld a,0 
1663			;	ld (os_view_disable),a 
1663			; 
1663			;.bpwait: 
1663			;	call cin 
1663			;	cp 0 
1663			;	jr z, .bpwait 
1663			;	jr .nokeys 
1663			; 
1663			; 
1663			;.bpen:  db "Break points enabled!",0 
1663			 
1663			 
1663			 
1663			 
1663			 
1663			 
1663			.nokeys: 
1663			 
1663			 
1663				 
1663			 
1663			;jp  testkey 
1663			 
1663			;call storage_get_block_0 
1663			; 
1663			;ld hl, 0 
1663			;ld de, store_page 
1663			;call storage_read_block 
1663			 
1663				 
1663			;ld hl, 10 
1663			;ld de, store_page 
1663			;call storage_read_block 
1663			 
1663			 
1663			 
1663			 
1663			 
1663			;stop:	nop 
1663			;	jp stop 
1663			 
1663			 
1663			 
1663			main: 
1663 cd 9c 09			call clear_display 
1666 cd bf 09			call update_display 
1669			 
1669			 
1669			 
1669			;	call testlcd 
1669			 
1669			 
1669			 
1669 cd 42 1d			call forth_init 
166c			 
166c			 
166c			warmstart: 
166c cd 18 1d			call forth_warmstart 
166f			 
166f				; run startup word load 
166f			        ; TODO prevent this running at warmstart after crash  
166f			 
166f				if STARTUP_ENABLE 
166f					if STORAGE_SE 
166f						call forth_autoload 
166f					endif 
166f cd 6f 55				call forth_startup 
1672			 
1672			 
1672				endif 
1672			 
1672				; show free memory after boot 
1672 11 0c 17			ld de, freeram 
1675 3e 00			ld a, display_row_1 
1677 cd af 09			call str_at_display 
167a			 
167a			; Or use heap_size word???? 
167a 21 46 e3			ld hl, heap_end 
167d 11 51 59			ld de, heap_start 
1680 ed 52			sbc hl, de 
1682 e5				push hl 
1683 7c				ld a,h	         	 
1684 21 65 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1687 cd ca 0e			call hexout 
168a e1			   	pop hl 
168b			 
168b 7d				ld a,l 
168c 21 67 e6			ld hl, os_word_scratch+2 
168f cd ca 0e			call hexout 
1692 21 69 e6			ld hl, os_word_scratch+4 
1695 3e 00			ld a, 0 
1697 77				ld (hl),a 
1698 11 65 e6			ld de, os_word_scratch 
169b 3e 0d			ld a, display_row_1 + 13 
169d cd af 09			call str_at_display 
16a0 cd bf 09			call update_display 
16a3			 
16a3			 
16a3				;call demo 
16a3			 
16a3			 
16a3				; init scratch input area for cli commands 
16a3			 
16a3 21 87 e6			ld hl, os_cli_cmd 
16a6 3e 00			ld a,0 
16a8 77				ld (hl),a 
16a9 23				inc hl 
16aa 77				ld (hl),a 
16ab			 
16ab 3e 00			ld a,0 
16ad 32 86 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
16b0			 
16b0 32 83 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
16b3 32 84 e6			ld (os_cur_ptr+1),a	 
16b6			 
16b6 32 65 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
16b9 32 66 e6			ld (os_word_scratch+1),a	 
16bc				 
16bc			 
16bc				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16bc 21 87 e6			ld hl, os_cli_cmd 
16bf			 
16bf 3e 00			ld a, 0		 ; init cli input 
16c1 77				ld (hl), a 
16c2 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16c4			cli: 
16c4				; show cli prompt 
16c4				;push af 
16c4				;ld a, 0 
16c4				;ld de, prompt 
16c4				;call str_at_display 
16c4			 
16c4				;call update_display 
16c4				;pop af 
16c4				;inc a 
16c4				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
16c4 0e 00			ld c, 0 
16c6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16c8 1e 28			ld e, 40 
16ca			 
16ca 21 87 e6			ld hl, os_cli_cmd 
16cd			 
16cd				STACKFRAME OFF $fefe $9f9f 
16cd				if DEBUG_STACK_IMB 
16cd					if OFF 
16cd						exx 
16cd						ld de, $fefe 
16cd						ld a, d 
16cd						ld hl, curframe 
16cd						call hexout 
16cd						ld a, e 
16cd						ld hl, curframe+2 
16cd						call hexout 
16cd						ld hl, $fefe 
16cd						push hl 
16cd						ld hl, $9f9f 
16cd						push hl 
16cd						exx 
16cd					endif 
16cd				endif 
16cd			endm 
# End of macro STACKFRAME
16cd			 
16cd cd f6 0b			call input_str 
16d0			 
16d0				STACKFRAMECHK OFF $fefe $9f9f 
16d0				if DEBUG_STACK_IMB 
16d0					if OFF 
16d0						exx 
16d0						ld hl, $9f9f 
16d0						pop de   ; $9f9f 
16d0						call cmp16 
16d0						jr nz, .spnosame 
16d0						ld hl, $fefe 
16d0						pop de   ; $fefe 
16d0						call cmp16 
16d0						jr z, .spfrsame 
16d0						.spnosame: call showsperror 
16d0						.spfrsame: nop 
16d0						exx 
16d0					endif 
16d0				endif 
16d0			endm 
# End of macro STACKFRAMECHK
16d0			 
16d0				; copy input to last command 
16d0			 
16d0 21 87 e6			ld hl, os_cli_cmd 
16d3 11 86 e7			ld de, os_last_cmd 
16d6 01 ff 00			ld bc, 255 
16d9 ed b0			ldir 
16db			 
16db				; wipe current buffer 
16db			 
16db			;	ld a, 0 
16db			;	ld hl, os_cli_cmd 
16db			;	ld de, os_cli_cmd+1 
16db			;	ld bc, 254 
16db			;	ldir 
16db				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
16db			;	call strcpy 
16db			;	ld a, 0 
16db			;	ld (hl), a 
16db			;	inc hl 
16db			;	ld (hl), a 
16db			;	inc hl 
16db			;	ld (hl), a 
16db			 
16db				; switch frame buffer to program  
16db			 
16db 21 1f ed				ld hl, display_fb1 
16de 22 db eb				ld (display_fb_active), hl 
16e1			 
16e1			;	nop 
16e1				STACKFRAME ON $fbfe $8f9f 
16e1				if DEBUG_STACK_IMB 
16e1					if ON 
16e1						exx 
16e1						ld de, $fbfe 
16e1						ld a, d 
16e1						ld hl, curframe 
16e1						call hexout 
16e1						ld a, e 
16e1						ld hl, curframe+2 
16e1						call hexout 
16e1						ld hl, $fbfe 
16e1						push hl 
16e1						ld hl, $8f9f 
16e1						push hl 
16e1						exx 
16e1					endif 
16e1				endif 
16e1			endm 
# End of macro STACKFRAME
16e1				; first time into the parser so pass over the current scratch pad 
16e1 21 87 e6			ld hl,os_cli_cmd 
16e4				; tokenise the entered statement(s) in HL 
16e4 cd bb 1d			call forthparse 
16e7			        ; exec forth statements in top of return stack 
16e7 cd fb 1d			call forthexec 
16ea				;call forthexec_cleanup 
16ea			;	call parsenext 
16ea			 
16ea				STACKFRAMECHK ON $fbfe $8f9f 
16ea				if DEBUG_STACK_IMB 
16ea					if ON 
16ea						exx 
16ea						ld hl, $8f9f 
16ea						pop de   ; $8f9f 
16ea						call cmp16 
16ea						jr nz, .spnosame 
16ea						ld hl, $fbfe 
16ea						pop de   ; $fbfe 
16ea						call cmp16 
16ea						jr z, .spfrsame 
16ea						.spnosame: call showsperror 
16ea						.spfrsame: nop 
16ea						exx 
16ea					endif 
16ea				endif 
16ea			endm 
# End of macro STACKFRAMECHK
16ea				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
16ea			 
16ea 3e 78			ld a, display_row_4 
16ec 11 1e 17			ld de, endprog 
16ef			 
16ef cd bf 09			call update_display		 
16f2			 
16f2 cd 7c 19			call next_page_prompt 
16f5			 
16f5				; switch frame buffer to cli 
16f5			 
16f5 21 c0 ed				ld hl, display_fb0 
16f8 22 db eb				ld (display_fb_active), hl 
16fb			 
16fb			 
16fb cd 9c 09		        call clear_display 
16fe cd bf 09			call update_display		 
1701			 
1701 21 87 e6			ld hl, os_cli_cmd 
1704			 
1704 3e 00			ld a, 0		 ; init cli input 
1706 77				ld (hl), a 
1707			 
1707				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1707			 
1707				; now on last line 
1707			 
1707				; TODO scroll screen up 
1707			 
1707				; TODO instead just clear screen and place at top of screen 
1707			 
1707			;	ld a, 0 
1707			;	ld (f_cursor_ptr),a 
1707			 
1707				;call clear_display 
1707				;call update_display 
1707			 
1707				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1707 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1709 c3 c4 16			jp cli 
170c			 
170c .. 00		freeram: db "Free bytes: $",0 
171a ..			asc: db "1A2F" 
171e .. 00		endprog: db "End prog...",0 
172a			 
172a			testenter2:   
172a 21 92 e3			ld hl,scratch+50 
172d 22 83 e6			ld (os_cur_ptr),hl 
1730 c3 c4 16			jp cli 
1733			 
1733			testenter:  
1733			 
1733 21 1a 17			ld hl,asc 
1736			;	ld a,(hl) 
1736			;	call nibble2val 
1736 cd 20 0f			call get_byte 
1739			 
1739			 
1739			;	ld a,(hl) 
1739			;	call atohex 
1739			 
1739			;	call fourehexhl 
1739 32 92 e3			ld (scratch+50),a 
173c			 
173c			 
173c			 
173c 21 1c 17			ld hl,asc+2 
173f			;	ld a, (hl) 
173f			;	call nibble2val 
173f cd 20 0f			call get_byte 
1742			 
1742			;	call fourehexhl 
1742 32 94 e3			ld (scratch+52),a 
1745				 
1745 21 92 e3			ld hl,scratch+50 
1748 22 83 e6			ld (os_cur_ptr),hl 
174b c3 c4 16			jp cli 
174e			 
174e			enter:	 
174e 3a 64 e3			ld a,(scratch+4) 
1751 fe 00			cp 0 
1753 28 0c			jr z, .entercont 
1755				; no, not a null term line so has an address to work out.... 
1755			 
1755 21 62 e3			ld hl,scratch+2 
1758 cd 80 0f			call get_word_hl 
175b			 
175b 22 83 e6			ld (os_cur_ptr),hl	 
175e c3 c4 16			jp cli 
1761			 
1761			 
1761			.entercont:  
1761			 
1761 21 62 e3			ld hl, scratch+2 
1764 cd 20 0f			call get_byte 
1767			 
1767 2a 83 e6		   	ld hl,(os_cur_ptr) 
176a 77					ld (hl),a 
176b 23					inc hl 
176c 22 83 e6				ld (os_cur_ptr),hl 
176f				 
176f			; get byte  
176f			 
176f			 
176f c3 c4 16			jp cli 
1772			 
1772			 
1772			; basic monitor support 
1772			 
1772			monitor: 
1772				;  
1772 cd 9c 09			call clear_display 
1775 3e 00			ld a, 0 
1777 11 bf 17			ld de, .monprompt 
177a cd af 09			call str_at_display 
177d cd bf 09			call update_display 
1780			 
1780				; get a monitor command 
1780			 
1780 0e 00			ld c, 0     ; entry at top left 
1782 16 64			ld d, 100   ; max buffer size 
1784 1e 0f			ld e, 15    ; input scroll area 
1786 3e 00			ld a, 0     ; init string 
1788 21 5e e5			ld hl, os_input 
178b 77				ld (hl), a 
178c 23				inc hl 
178d 77				ld (hl), a 
178e 21 5e e5			ld hl, os_input 
1791 3e 01			ld a, 1     ; init string 
1793 cd f6 0b			call input_str 
1796			 
1796 cd 9c 09		        call clear_display 
1799 cd bf 09			call update_display		 
179c			 
179c 3a 5e e5			ld a, (os_input) 
179f cd 1e 10			call toUpper 
17a2 fe 48		        cp 'H' 
17a4 28 6f		        jr z, .monhelp 
17a6 fe 44			cp 'D'		; dump 
17a8 ca 36 18			jp z, .mondump	 
17ab fe 43			cp 'C'		; dump 
17ad ca 50 18			jp z, .moncdump	 
17b0 fe 4d			cp 'M'		; dump 
17b2 ca c1 17			jp z, .moneditstart 
17b5 fe 55			cp 'U'		; dump 
17b7 28 14			jr z, .monedit	 
17b9 fe 51			cp 'Q'		; dump 
17bb c8				ret z	 
17bc			 
17bc			 
17bc				; TODO "S" to access symbol by name and not need the address 
17bc				; TODO "F" to find a string in memory 
17bc			 
17bc c3 72 17			jp monitor 
17bf			 
17bf .. 00		.monprompt: db ">", 0 
17c1			 
17c1			.moneditstart: 
17c1				; get starting address 
17c1			 
17c1 21 60 e5			ld hl,os_input+2 
17c4 cd 80 0f			call get_word_hl 
17c7			 
17c7 22 83 e6			ld (os_cur_ptr),hl	 
17ca			 
17ca c3 72 17			jp monitor 
17cd			 
17cd			.monedit: 
17cd				; get byte to load 
17cd			 
17cd 21 60 e5			ld hl,os_input+2 
17d0 cd 20 0f			call get_byte 
17d3			 
17d3				; get address to update 
17d3 2a 83 e6			ld hl, (os_cur_ptr) 
17d6			 
17d6				; update byte 
17d6			 
17d6 77				ld (hl), a 
17d7			 
17d7				; move to next address and save it 
17d7			 
17d7 23				inc hl 
17d8 22 83 e6			ld (os_cur_ptr),hl	 
17db			 
17db c3 72 17			jp monitor 
17de			 
17de			 
17de .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
17f2 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
180e .. 00		.monhelptext3:  db "Q-Quit",0 
1815			        
1815			.monhelp: 
1815 3e 00			ld a, display_row_1 
1817 11 de 17		        ld de, .monhelptext1 
181a			 
181a cd af 09			call str_at_display 
181d 3e 28			ld a, display_row_2 
181f 11 f2 17		        ld de, .monhelptext2 
1822					 
1822 cd af 09			call str_at_display 
1825 3e 50			ld a, display_row_3 
1827 11 0e 18		        ld de, .monhelptext3 
182a					 
182a cd af 09			call str_at_display 
182d cd bf 09			call update_display		 
1830			 
1830 cd 7c 19			call next_page_prompt 
1833 c3 72 17			jp monitor 
1836			 
1836			.mondump:    
1836 21 60 e5			ld hl,os_input+2 
1839 cd 80 0f			call get_word_hl 
183c			 
183c 22 83 e6			ld (os_cur_ptr),hl	 
183f cd 84 18			call dumpcont 
1842 3e 78			ld a, display_row_4 
1844 11 1e 17			ld de, endprog 
1847			 
1847 cd bf 09			call update_display		 
184a			 
184a cd 7c 19			call next_page_prompt 
184d c3 72 17			jp monitor 
1850			.moncdump: 
1850 cd 84 18			call dumpcont 
1853 3e 78			ld a, display_row_4 
1855 11 1e 17			ld de, endprog 
1858			 
1858 cd bf 09			call update_display		 
185b			 
185b cd 7c 19			call next_page_prompt 
185e c3 72 17			jp monitor 
1861			 
1861			 
1861			; TODO symbol access  
1861			 
1861			.symbols:     ;; A list of symbols that can be called up  
1861 c0 ed			dw display_fb0 
1863 .. 00			db "fb0",0  
1867 65 eb		     	dw store_page 
1869 .. 00			db "store_page",0 
1874			 
1874			 
1874			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1874			 
1874 3a 61 e3			ld a,(scratch+1) 
1877 fe 00			cp 0 
1879 28 09			jr z, dumpcont 
187b			 
187b				; no, not a null term line so has an address to work out.... 
187b			 
187b 21 62 e3			ld hl,scratch+2 
187e cd 80 0f			call get_word_hl 
1881			 
1881 22 83 e6			ld (os_cur_ptr),hl	 
1884			 
1884			 
1884			 
1884			dumpcont: 
1884			 
1884				; dump bytes at ptr 
1884			 
1884			 
1884 3e 00			ld a, display_row_1 
1886 2a db eb			ld hl, (display_fb_active) 
1889 cd c9 0b			call addatohl 
188c cd b4 18			call .dumpbyterow 
188f			 
188f 3e 28			ld a, display_row_2 
1891 2a db eb			ld hl, (display_fb_active) 
1894 cd c9 0b			call addatohl 
1897 cd b4 18			call .dumpbyterow 
189a			 
189a			 
189a 3e 50			ld a, display_row_3 
189c 2a db eb			ld hl, (display_fb_active) 
189f cd c9 0b			call addatohl 
18a2 cd b4 18			call .dumpbyterow 
18a5			 
18a5 3e 78			ld a, display_row_4 
18a7 2a db eb			ld hl, (display_fb_active) 
18aa cd c9 0b			call addatohl 
18ad cd b4 18			call .dumpbyterow 
18b0			 
18b0 cd bf 09			call update_display 
18b3			;		jp cli 
18b3 c9				ret 
18b4			 
18b4			.dumpbyterow: 
18b4			 
18b4				;push af 
18b4			 
18b4 e5				push hl 
18b5			 
18b5				; calc where to poke the ascii 
18b5			if display_cols == 20 
18b5				ld a, 16 
18b5			else 
18b5 3e 1f			ld a, 31 
18b7			endif 
18b7			 
18b7 cd c9 0b			call addatohl 
18ba 22 65 e6			ld (os_word_scratch),hl  		; save pos for later 
18bd			 
18bd			 
18bd			; display decoding address 
18bd 2a 83 e6		   	ld hl,(os_cur_ptr) 
18c0			 
18c0 7c				ld a,h 
18c1 e1				pop hl 
18c2 e5				push hl 
18c3			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18c3 cd ca 0e			call hexout 
18c6 2a 83 e6		   	ld hl,(os_cur_ptr) 
18c9			 
18c9 7d				ld a,l 
18ca e1				pop hl 
18cb 23				inc hl 
18cc 23				inc hl 
18cd e5				push hl 
18ce			;	ld hl, os_word_scratch+2 
18ce cd ca 0e			call hexout 
18d1 e1				pop hl 
18d2 23				inc hl 
18d3 23				inc hl 
18d4				;ld hl, os_word_scratch+4 
18d4 3e 3a			ld a, ':' 
18d6 77				ld (hl),a 
18d7 23				inc hl 
18d8				;ld a, 0 
18d8				;ld (hl),a 
18d8				;ld de, os_word_scratch 
18d8				;pop af 
18d8				;push af 
18d8			;		ld a, display_row_2 
18d8			;		call str_at_display 
18d8			;		call update_display 
18d8			 
18d8			 
18d8			;pop af 
18d8			;	add 5 
18d8			 
18d8			if display_cols == 20 
18d8				ld b, 4 
18d8			else 
18d8 06 08			ld b, 8 
18da			endif	 
18da			 
18da			.dumpbyte: 
18da c5				push bc 
18db e5				push hl 
18dc			 
18dc			 
18dc 2a 83 e6		   	ld hl,(os_cur_ptr) 
18df 7e					ld a,(hl) 
18e0			 
18e0					; poke the ascii to display 
18e0 2a 65 e6				ld hl,(os_word_scratch) 
18e3 77					ld (hl),a 
18e4 23					inc hl 
18e5 22 65 e6				ld (os_word_scratch),hl 
18e8			 
18e8					 
18e8			 
18e8			 
18e8 e1					pop hl 
18e9 e5					push hl 
18ea			 
18ea cd ca 0e				call hexout 
18ed			 
18ed					 
18ed 2a 83 e6		   	ld hl,(os_cur_ptr) 
18f0 23				inc hl 
18f1 22 83 e6		   	ld (os_cur_ptr),hl 
18f4			 
18f4 e1					pop hl 
18f5 23					inc hl 
18f6 23					inc hl 
18f7 23					inc hl 
18f8			 
18f8			 
18f8			 
18f8					;ld a,0 
18f8					;ld (os_word_scratch+2),a 
18f8					;pop af 
18f8					;push af 
18f8			 
18f8					;ld de, os_word_scratch 
18f8					;call str_at_display 
18f8			;		call update_display 
18f8			;		pop af 
18f8 c1					pop bc 
18f9 c6 03				add 3 
18fb 10 dd			djnz .dumpbyte 
18fd			 
18fd				 
18fd			 
18fd c9				ret 
18fe			 
18fe			jump:	 
18fe			 
18fe 21 62 e3			ld hl,scratch+2 
1901 cd 80 0f			call get_word_hl 
1904				;ld hl,(scratch+2) 
1904				;call fourehexhl 
1904			 
1904 22 83 e6			ld (os_cur_ptr),hl	 
1907			 
1907 e9				jp (hl) 
1908			 
1908			 
1908			 
1908			; TODO implement a basic monitor mode to start with 
1908			 
1908			 
1908			 
1908			 
1908			 
1908			 
1908			 
1908			 
1908			 
1908			; testing and demo code during development 
1908			 
1908			 
1908 .. 00		str1: db "Enter some text...",0 
191b .. 00		clear: db "                    ",0 
1930			 
1930			demo: 
1930			 
1930			 
1930			 
1930			;	call update_display 
1930			 
1930				; init scratch input area for testing 
1930 21 60 e3			ld hl, scratch	 
1933 3e 00			ld a,0 
1935 77				ld (hl),a 
1936			 
1936			 
1936 3e 28		            LD   A, display_row_2 
1938			;            CALL fLCD_Pos       ;Position cursor to location in A 
1938 11 08 19		            LD   DE, str1 
193b cd af 09			call str_at_display 
193e			 
193e			;            CALL fLCD_Str       ;Display string pointed to by DE 
193e			cloop:	 
193e 3e 50		            LD   A, display_row_3 
1940			;            CALL fLCD_Pos       ;Position cursor to location in A 
1940 11 1b 19		            LD   DE, clear 
1943			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1943 cd af 09				call str_at_display 
1946 3e 78			ld a, display_row_4 
1948 11 78 19			ld de, prompt 
194b			 
194b cd af 09				call str_at_display 
194e cd bf 09			call update_display 
1951			 
1951 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1953 16 0a			ld d, 10 
1955 21 60 e3			ld hl, scratch	 
1958 cd f6 0b			call input_str 
195b			 
195b			;	call clear_display 
195b			;'	call update_display 
195b			 
195b 3e 00		            LD   A, display_row_1 
195d			;            CALL fLCD_Pos       ;Position cursor to location in A 
195d 11 1b 19		            LD   DE, clear 
1960 cd af 09				call str_at_display 
1963			;            CALL fLCD_Str       ;Display string pointed to by DE 
1963 3e 00		            LD   A, display_row_1 
1965			;            CALL fLCD_Pos       ;Position cursor to location in A 
1965 11 60 e3		            LD   DE, scratch 
1968			;            CALL fLCD_Str       ;Display string pointed to by DE 
1968 cd af 09				call str_at_display 
196b cd bf 09			call update_display 
196e			 
196e 3e 00				ld a,0 
1970 21 60 e3			ld hl, scratch 
1973 77				ld (hl),a 
1974			 
1974 00				nop 
1975 c3 3e 19			jp cloop 
1978			 
1978			 
1978			 
1978			; OS Prompt 
1978			 
1978 .. 00		prompt: db ">",0 
197a .. 00		endprg: db "?",0 
197c			 
197c			 
197c			; handy next page prompt 
197c			next_page_prompt: 
197c e5				push hl 
197d d5				push de 
197e f5				push af 
197f c5				push bc 
1980			 
1980 3e 9f			ld a,display_row_4 + display_cols - 1 
1982 11 7a 19		        ld de, endprg 
1985 cd af 09			call str_at_display 
1988 cd bf 09			call update_display 
198b cd 21 59			call cin_wait 
198e c1				pop bc 
198f f1				pop af 
1990 d1				pop de 
1991 e1				pop hl 
1992			 
1992			 
1992 c9				ret 
1993			 
1993			 
1993			; forth parser 
1993			 
1993			; My forth kernel 
1993			include "forth_kernel.asm" 
1993			; 
1993			; kernel to the forth OS 
1993			 
1993			DS_TYPE_STR: equ 1     ; string type 
1993			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1993			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1993			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1993			 
1993			FORTH_PARSEV1: equ 0 
1993			FORTH_PARSEV2: equ 0 
1993			FORTH_PARSEV3: equ 0 
1993			FORTH_PARSEV4: equ 0 
1993			FORTH_PARSEV5: equ 1 
1993			 
1993			;if FORTH_PARSEV5 
1993			;	FORTH_END_BUFFER: equ 0 
1993			;else 
1993			FORTH_END_BUFFER: equ 127 
1993			;endif 
1993			 
1993			FORTH_TRUE: equ 1 
1993			FORTH_FALSE: equ 0 
1993			 
1993			if FORTH_PARSEV4 
1993			include "forth_stackops.asm" 
1993			endif 
1993			 
1993			if FORTH_PARSEV5 
1993			include "forth_stackopsv5.asm" 
1993			 
1993			; Stack operations for v5 parser on wards 
1993			; * DATA stack 
1993			; * LOOP stack 
1993			; * RETURN stack 
1993			 
1993			 
1993			 
1993			FORTH_CHK_DSP_UNDER: macro 
1993				push hl 
1993				push de 
1993				ld hl,(cli_data_sp) 
1993				ld de, cli_data_stack 
1993				call cmp16 
1993				jp c, fault_dsp_under 
1993				pop de 
1993				pop hl 
1993				endm 
1993			 
1993			 
1993			FORTH_CHK_RSP_UNDER: macro 
1993				push hl 
1993				push de 
1993				ld hl,(cli_ret_sp) 
1993				ld de, cli_ret_stack 
1993				call cmp16 
1993				jp c, fault_rsp_under 
1993				pop de 
1993				pop hl 
1993				endm 
1993			 
1993			FORTH_CHK_LOOP_UNDER: macro 
1993				push hl 
1993				push de 
1993				ld hl,(cli_loop_sp) 
1993				ld de, cli_loop_stack 
1993				call cmp16 
1993				jp c, fault_loop_under 
1993				pop de 
1993				pop hl 
1993				endm 
1993			 
1993			FORTH_ERR_TOS_NOTSTR: macro 
1993				; TOSO might need more for checks when used 
1993				push af 
1993				ld a,(hl) 
1993				cp DS_TYPE_STR 
1993				jp nz, type_faultn   
1993				pop af 
1993				endm 
1993			 
1993			FORTH_ERR_TOS_NOTNUM: macro 
1993				push af 
1993				ld a,(hl) 
1993				cp DS_TYPE_INUM 
1993				jp nz, type_faultn   
1993				pop af 
1993				endm 
1993			 
1993			 
1993			; increase data stack pointer and save hl to it 
1993				 
1993			FORTH_DSP_NEXT: macro 
1993				call macro_forth_dsp_next 
1993				endm 
1993			 
1993			 
1993			macro_forth_dsp_next: 
1993				if DEBUG_FORTH_STACK_GUARD 
1993 cd 39 56				call check_stacks 
1996				endif 
1996 e5				push hl 
1997 d5				push de 
1998 eb				ex de,hl 
1999 2a 0d eb			ld hl,(cli_data_sp) 
199c 23				inc hl 
199d 23				inc hl 
199e			 
199e			; PARSEV5 
199e 23				inc hl 
199f 22 0d eb			ld (cli_data_sp),hl 
19a2 73				ld (hl), e 
19a3 23				inc hl 
19a4 72				ld (hl), d 
19a5 d1				pop de 
19a6 e1				pop hl 
19a7				if DEBUG_FORTH_STACK_GUARD 
19a7 cd 39 56				call check_stacks 
19aa				endif 
19aa c9				ret 
19ab			 
19ab			 
19ab			; increase ret stack pointer and save hl to it 
19ab				 
19ab			FORTH_RSP_NEXT: macro 
19ab				call macro_forth_rsp_next 
19ab				endm 
19ab			 
19ab			macro_forth_rsp_next: 
19ab				if DEBUG_FORTH_STACK_GUARD 
19ab cd 39 56				call check_stacks 
19ae				endif 
19ae e5				push hl 
19af d5				push de 
19b0 eb				ex de,hl 
19b1 2a 11 eb			ld hl,(cli_ret_sp) 
19b4 23				inc hl 
19b5 23				inc hl 
19b6 22 11 eb			ld (cli_ret_sp),hl 
19b9 73				ld (hl), e 
19ba 23				inc hl 
19bb 72				ld (hl), d 
19bc d1				pop de 
19bd e1				pop hl 
19be				if DEBUG_FORTH_STACK_GUARD 
19be cd 39 56				call check_stacks 
19c1				endif 
19c1 c9				ret 
19c2			 
19c2			; get current ret stack pointer and save to hl  
19c2				 
19c2			FORTH_RSP_TOS: macro 
19c2				call macro_forth_rsp_tos 
19c2				endm 
19c2			 
19c2			macro_forth_rsp_tos: 
19c2				;push de 
19c2 2a 11 eb			ld hl,(cli_ret_sp) 
19c5 cd fd 19			call loadhlptrtohl 
19c8				;ld e, (hl) 
19c8				;inc hl 
19c8				;ld d, (hl) 
19c8				;ex de, hl 
19c8					if DEBUG_FORTH_WORDS 
19c8			;			DMARK "RST" 
19c8						CALLMONITOR 
19c8 cd 77 14			call break_point_state  
19cb				endm  
# End of macro CALLMONITOR
19cb					endif 
19cb				;pop de 
19cb c9				ret 
19cc			 
19cc			; pop ret stack pointer 
19cc				 
19cc			FORTH_RSP_POP: macro 
19cc				call macro_forth_rsp_pop 
19cc				endm 
19cc			 
19cc			 
19cc			macro_forth_rsp_pop: 
19cc				if DEBUG_FORTH_STACK_GUARD 
19cc			;		DMARK "RPP" 
19cc cd 39 56				call check_stacks 
19cf					FORTH_CHK_RSP_UNDER 
19cf e5				push hl 
19d0 d5				push de 
19d1 2a 11 eb			ld hl,(cli_ret_sp) 
19d4 11 cb ea			ld de, cli_ret_stack 
19d7 cd e7 0b			call cmp16 
19da da 4d 57			jp c, fault_rsp_under 
19dd d1				pop de 
19de e1				pop hl 
19df				endm 
# End of macro FORTH_CHK_RSP_UNDER
19df				endif 
19df e5				push hl 
19e0 2a 11 eb			ld hl,(cli_ret_sp) 
19e3			 
19e3			 
19e3				if FORTH_ENABLE_FREE 
19e3			 
19e3					; get pointer 
19e3			 
19e3					push de 
19e3					push hl 
19e3			 
19e3					ld e, (hl) 
19e3					inc hl 
19e3					ld d, (hl) 
19e3			 
19e3					ex de, hl 
19e3					call free 
19e3			 
19e3					pop hl 
19e3					pop de 
19e3			 
19e3			 
19e3				endif 
19e3			 
19e3			 
19e3 2b				dec hl 
19e4 2b				dec hl 
19e5 22 11 eb			ld (cli_ret_sp), hl 
19e8				; do stack underflow checks 
19e8 e1				pop hl 
19e9				if DEBUG_FORTH_STACK_GUARD 
19e9 cd 39 56				call check_stacks 
19ec					FORTH_CHK_RSP_UNDER 
19ec e5				push hl 
19ed d5				push de 
19ee 2a 11 eb			ld hl,(cli_ret_sp) 
19f1 11 cb ea			ld de, cli_ret_stack 
19f4 cd e7 0b			call cmp16 
19f7 da 4d 57			jp c, fault_rsp_under 
19fa d1				pop de 
19fb e1				pop hl 
19fc				endm 
# End of macro FORTH_CHK_RSP_UNDER
19fc				endif 
19fc c9				ret 
19fd			 
19fd			 
19fd			 
19fd			; routine to load word pointed to by hl into hl 
19fd			 
19fd			loadhlptrtohl: 
19fd			 
19fd d5				push de 
19fe 5e				ld e, (hl) 
19ff 23				inc hl 
1a00 56				ld d, (hl) 
1a01 eb				ex de, hl 
1a02 d1				pop de 
1a03			 
1a03 c9				ret 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			; push a number held in HL onto the data stack 
1a04			; entry point for pushing a value when already in hl used in function above 
1a04			 
1a04			forth_push_numhl: 
1a04			 
1a04 e5				push hl    ; save value to push 
1a05			 
1a05			if DEBUG_FORTH_PUSH 
1a05				; see if disabled 
1a05			 
1a05			 
1a05 f5				push af 
1a06 3a 51 e3			ld a, (os_view_disable) 
1a09 fe 2a			cp '*' 
1a0b 28 34			jr z, .pskip2 
1a0d e5				push hl 
1a0e e5			push hl 
1a0f cd 9c 09			call clear_display 
1a12 e1			pop hl 
1a13 7c				ld a,h 
1a14 21 65 e6			ld hl, os_word_scratch 
1a17 cd ca 0e			call hexout 
1a1a e1				pop hl 
1a1b 7d				ld a,l 
1a1c 21 67 e6			ld hl, os_word_scratch+2 
1a1f cd ca 0e			call hexout 
1a22			 
1a22 21 69 e6			ld hl, os_word_scratch+4 
1a25 3e 00			ld a,0 
1a27 77				ld (hl),a 
1a28 11 65 e6			ld de,os_word_scratch 
1a2b 3e 28				ld a, display_row_2 
1a2d cd af 09				call str_at_display 
1a30 11 47 45			ld de, .push_num 
1a33 3e 00			ld a, display_row_1 
1a35			 
1a35 cd af 09				call str_at_display 
1a38			 
1a38			 
1a38 cd bf 09			call update_display 
1a3b cd 0e 09			call delay1s 
1a3e cd 0e 09			call delay1s 
1a41			.pskip2:  
1a41			 
1a41 f1				pop af 
1a42			endif	 
1a42			 
1a42			 
1a42				FORTH_DSP_NEXT 
1a42 cd 93 19			call macro_forth_dsp_next 
1a45				endm 
# End of macro FORTH_DSP_NEXT
1a45			 
1a45 2a 0d eb			ld hl, (cli_data_sp) 
1a48			 
1a48				; save item type 
1a48 3e 02			ld a,  DS_TYPE_INUM 
1a4a 77				ld (hl), a 
1a4b 23				inc hl 
1a4c			 
1a4c				; get word off stack 
1a4c d1				pop de 
1a4d 7b				ld a,e 
1a4e 77				ld (hl), a 
1a4f 23				inc hl 
1a50 7a				ld a,d 
1a51 77				ld (hl), a 
1a52			 
1a52			if DEBUG_FORTH_PUSH 
1a52 2b				dec hl 
1a53 2b				dec hl 
1a54 2b				dec hl 
1a55						DMARK "PH5" 
1a55 f5				push af  
1a56 3a 6a 1a			ld a, (.dmark)  
1a59 32 7a ee			ld (debug_mark),a  
1a5c 3a 6b 1a			ld a, (.dmark+1)  
1a5f 32 7b ee			ld (debug_mark+1),a  
1a62 3a 6c 1a			ld a, (.dmark+2)  
1a65 32 7c ee			ld (debug_mark+2),a  
1a68 18 03			jr .pastdmark  
1a6a ..			.dmark: db "PH5"  
1a6d f1			.pastdmark: pop af  
1a6e			endm  
# End of macro DMARK
1a6e				CALLMONITOR 
1a6e cd 77 14			call break_point_state  
1a71				endm  
# End of macro CALLMONITOR
1a71			endif	 
1a71			 
1a71 c9				ret 
1a72			 
1a72			 
1a72			; Push a string to stack pointed to by hl 
1a72			 
1a72			forth_push_str: 
1a72			 
1a72			if DEBUG_FORTH_PUSH 
1a72						DMARK "PSQ" 
1a72 f5				push af  
1a73 3a 87 1a			ld a, (.dmark)  
1a76 32 7a ee			ld (debug_mark),a  
1a79 3a 88 1a			ld a, (.dmark+1)  
1a7c 32 7b ee			ld (debug_mark+1),a  
1a7f 3a 89 1a			ld a, (.dmark+2)  
1a82 32 7c ee			ld (debug_mark+2),a  
1a85 18 03			jr .pastdmark  
1a87 ..			.dmark: db "PSQ"  
1a8a f1			.pastdmark: pop af  
1a8b			endm  
# End of macro DMARK
1a8b				CALLMONITOR 
1a8b cd 77 14			call break_point_state  
1a8e				endm  
# End of macro CALLMONITOR
1a8e			endif	 
1a8e			    
1a8e e5				push hl 
1a8f e5				push hl 
1a90			 
1a90			;	ld a, 0   ; find end of string 
1a90 cd 27 10			call strlenz 
1a93			if DEBUG_FORTH_PUSH 
1a93						DMARK "PQ2" 
1a93 f5				push af  
1a94 3a a8 1a			ld a, (.dmark)  
1a97 32 7a ee			ld (debug_mark),a  
1a9a 3a a9 1a			ld a, (.dmark+1)  
1a9d 32 7b ee			ld (debug_mark+1),a  
1aa0 3a aa 1a			ld a, (.dmark+2)  
1aa3 32 7c ee			ld (debug_mark+2),a  
1aa6 18 03			jr .pastdmark  
1aa8 ..			.dmark: db "PQ2"  
1aab f1			.pastdmark: pop af  
1aac			endm  
# End of macro DMARK
1aac				CALLMONITOR 
1aac cd 77 14			call break_point_state  
1aaf				endm  
# End of macro CALLMONITOR
1aaf			endif	 
1aaf eb				ex de, hl 
1ab0 e1				pop hl   ; get ptr to start of string 
1ab1			if DEBUG_FORTH_PUSH 
1ab1						DMARK "PQ3" 
1ab1 f5				push af  
1ab2 3a c6 1a			ld a, (.dmark)  
1ab5 32 7a ee			ld (debug_mark),a  
1ab8 3a c7 1a			ld a, (.dmark+1)  
1abb 32 7b ee			ld (debug_mark+1),a  
1abe 3a c8 1a			ld a, (.dmark+2)  
1ac1 32 7c ee			ld (debug_mark+2),a  
1ac4 18 03			jr .pastdmark  
1ac6 ..			.dmark: db "PQ3"  
1ac9 f1			.pastdmark: pop af  
1aca			endm  
# End of macro DMARK
1aca				CALLMONITOR 
1aca cd 77 14			call break_point_state  
1acd				endm  
# End of macro CALLMONITOR
1acd			endif	 
1acd 19				add hl,de 
1ace			if DEBUG_FORTH_PUSH 
1ace						DMARK "PQE" 
1ace f5				push af  
1acf 3a e3 1a			ld a, (.dmark)  
1ad2 32 7a ee			ld (debug_mark),a  
1ad5 3a e4 1a			ld a, (.dmark+1)  
1ad8 32 7b ee			ld (debug_mark+1),a  
1adb 3a e5 1a			ld a, (.dmark+2)  
1ade 32 7c ee			ld (debug_mark+2),a  
1ae1 18 03			jr .pastdmark  
1ae3 ..			.dmark: db "PQE"  
1ae6 f1			.pastdmark: pop af  
1ae7			endm  
# End of macro DMARK
1ae7				CALLMONITOR 
1ae7 cd 77 14			call break_point_state  
1aea				endm  
# End of macro CALLMONITOR
1aea			endif	 
1aea			 
1aea 2b				dec hl    ; see if there is an optional trailing double quote 
1aeb 7e				ld a,(hl) 
1aec fe 22			cp '"' 
1aee 20 03			jr nz, .strnoq 
1af0 3e 00			ld a, 0      ; get rid of double quote 
1af2 77				ld (hl), a 
1af3 23			.strnoq: inc hl 
1af4			 
1af4 3e 00			ld a, 0 
1af6 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1af7			 
1af7 13				inc de ; add one for the type string 
1af8 13				inc de ; add one for null term??? 
1af9			 
1af9				; tos is get string pointer again 
1af9				; de contains space to allocate 
1af9				 
1af9 d5				push de 
1afa			 
1afa eb				ex de, hl 
1afb			 
1afb				;push af 
1afb			 
1afb			if DEBUG_FORTH_PUSH 
1afb						DMARK "PHm" 
1afb f5				push af  
1afc 3a 10 1b			ld a, (.dmark)  
1aff 32 7a ee			ld (debug_mark),a  
1b02 3a 11 1b			ld a, (.dmark+1)  
1b05 32 7b ee			ld (debug_mark+1),a  
1b08 3a 12 1b			ld a, (.dmark+2)  
1b0b 32 7c ee			ld (debug_mark+2),a  
1b0e 18 03			jr .pastdmark  
1b10 ..			.dmark: db "PHm"  
1b13 f1			.pastdmark: pop af  
1b14			endm  
# End of macro DMARK
1b14				CALLMONITOR 
1b14 cd 77 14			call break_point_state  
1b17				endm  
# End of macro CALLMONITOR
1b17			endif	 
1b17 cd 90 10			call malloc	; on ret hl now contains allocated memory 
1b1a				if DEBUG_FORTH_MALLOC_GUARD 
1b1a cc 9f 45				call z,malloc_error 
1b1d				endif 
1b1d			 
1b1d				 
1b1d c1				pop bc    ; get length 
1b1e d1				pop de   ;  get string start    
1b1f			 
1b1f				; hl has destination from malloc 
1b1f			 
1b1f eb				ex de, hl    ; prep for ldir 
1b20			 
1b20 d5				push de   ; save malloc area for DSP later 
1b21				;push hl   ; save malloc area for DSP later 
1b21			 
1b21			if DEBUG_FORTH_PUSH 
1b21						DMARK "PHc" 
1b21 f5				push af  
1b22 3a 36 1b			ld a, (.dmark)  
1b25 32 7a ee			ld (debug_mark),a  
1b28 3a 37 1b			ld a, (.dmark+1)  
1b2b 32 7b ee			ld (debug_mark+1),a  
1b2e 3a 38 1b			ld a, (.dmark+2)  
1b31 32 7c ee			ld (debug_mark+2),a  
1b34 18 03			jr .pastdmark  
1b36 ..			.dmark: db "PHc"  
1b39 f1			.pastdmark: pop af  
1b3a			endm  
# End of macro DMARK
1b3a				CALLMONITOR 
1b3a cd 77 14			call break_point_state  
1b3d				endm  
# End of macro CALLMONITOR
1b3d			endif	 
1b3d			 
1b3d			 
1b3d ed b0			ldir 
1b3f			 
1b3f			 
1b3f				; push malloc to data stack     macro?????  
1b3f			 
1b3f				FORTH_DSP_NEXT 
1b3f cd 93 19			call macro_forth_dsp_next 
1b42				endm 
# End of macro FORTH_DSP_NEXT
1b42			 
1b42				; save value and type 
1b42			 
1b42 2a 0d eb			ld hl, (cli_data_sp) 
1b45			 
1b45				; save item type 
1b45 3e 01			ld a,  DS_TYPE_STR 
1b47 77				ld (hl), a 
1b48 23				inc hl 
1b49			 
1b49				; get malloc word off stack 
1b49 d1				pop de 
1b4a 73				ld (hl), e 
1b4b 23				inc hl 
1b4c 72				ld (hl), d 
1b4d			 
1b4d			 
1b4d			 
1b4d			if DEBUG_FORTH_PUSH 
1b4d 2a 0d eb			ld hl, (cli_data_sp) 
1b50						DMARK "PHS" 
1b50 f5				push af  
1b51 3a 65 1b			ld a, (.dmark)  
1b54 32 7a ee			ld (debug_mark),a  
1b57 3a 66 1b			ld a, (.dmark+1)  
1b5a 32 7b ee			ld (debug_mark+1),a  
1b5d 3a 67 1b			ld a, (.dmark+2)  
1b60 32 7c ee			ld (debug_mark+2),a  
1b63 18 03			jr .pastdmark  
1b65 ..			.dmark: db "PHS"  
1b68 f1			.pastdmark: pop af  
1b69			endm  
# End of macro DMARK
1b69				CALLMONITOR 
1b69 cd 77 14			call break_point_state  
1b6c				endm  
# End of macro CALLMONITOR
1b6c			;	ex de,hl 
1b6c			endif	 
1b6c				; in case of spaces, skip the ptr past the copied string 
1b6c				;pop af 
1b6c				;ld (cli_origptr),hl 
1b6c			 
1b6c c9				ret 
1b6d			 
1b6d			 
1b6d			 
1b6d			; TODO ascii push input onto stack given hl to start of input 
1b6d			 
1b6d			; identify type 
1b6d			; if starts with a " then a string 
1b6d			; otherwise it is a number 
1b6d			;  
1b6d			; if a string 
1b6d			;     scan for ending " to get length of string to malloc for + 1 
1b6d			;     malloc 
1b6d			;     put pointer to string on stack first byte flags as string 
1b6d			; 
1b6d			; else a number 
1b6d			;    look for number format identifier 
1b6d			;    $xx hex 
1b6d			;    %xxxxx bin 
1b6d			;    xxxxx decimal 
1b6d			;    convert number to 16bit word.  
1b6d			;    malloc word + 1 with flag to identiy as num 
1b6d			;    put pointer to number on stack 
1b6d			;   
1b6d			;  
1b6d			  
1b6d			forth_apush: 
1b6d				; kernel push 
1b6d			 
1b6d			if DEBUG_FORTH_PUSH 
1b6d						DMARK "PSH" 
1b6d f5				push af  
1b6e 3a 82 1b			ld a, (.dmark)  
1b71 32 7a ee			ld (debug_mark),a  
1b74 3a 83 1b			ld a, (.dmark+1)  
1b77 32 7b ee			ld (debug_mark+1),a  
1b7a 3a 84 1b			ld a, (.dmark+2)  
1b7d 32 7c ee			ld (debug_mark+2),a  
1b80 18 03			jr .pastdmark  
1b82 ..			.dmark: db "PSH"  
1b85 f1			.pastdmark: pop af  
1b86			endm  
# End of macro DMARK
1b86				CALLMONITOR 
1b86 cd 77 14			call break_point_state  
1b89				endm  
# End of macro CALLMONITOR
1b89			endif	 
1b89				; identify input type 
1b89			 
1b89 7e				ld a,(hl) 
1b8a fe 22			cp '"' 
1b8c 28 0a			jr z, .fapstr 
1b8e fe 24			cp '$' 
1b90 ca b8 1b			jp z, .faphex 
1b93 fe 25			cp '%' 
1b95 ca a0 1b			jp z, .fapbin 
1b98			;	cp 'b' 
1b98			;	jp z, .fabin 
1b98				; else decimal 
1b98			 
1b98				; TODO do decimal conversion 
1b98				; decimal is stored as a 16bit word 
1b98			 
1b98				; by default everything is a string if type is not detected 
1b98			.fapstr: ; 
1b98 fe 22			cp '"' 
1b9a 20 01			jr nz, .strnoqu 
1b9c 23				inc hl 
1b9d			.strnoqu: 
1b9d c3 72 1a			jp forth_push_str 
1ba0			 
1ba0			 
1ba0			 
1ba0			.fapbin:    ; push a binary string.  
1ba0 11 00 00			ld de, 0   ; hold a 16bit value 
1ba3			 
1ba3 23			.fapbinshift:	inc hl  
1ba4 7e				ld a,(hl) 
1ba5 fe 00			cp 0     ; done scanning  
1ba7 28 0b			jr z, .fapbdone  	; got it in HL so push  
1ba9			 
1ba9				; left shift de 
1ba9 eb				ex de, hl	 
1baa 29				add hl, hl 
1bab			 
1bab				; is 1 
1bab fe 31			cp '1' 
1bad 20 02			jr nz, .binzero 
1baf cb 4d			bit 1, l 
1bb1			.binzero: 
1bb1 eb				ex de, hl	 ; save current de 
1bb2 18 ef			jr .fapbinshift 
1bb4			 
1bb4			.fapbdone: 
1bb4 eb				ex de, hl 
1bb5 c3 04 1a			jp forth_push_numhl 
1bb8			 
1bb8			 
1bb8			.faphex:   ; hex is always stored as a 16bit word 
1bb8				; skip number prefix 
1bb8 23				inc hl 
1bb9				; turn ascii into number 
1bb9 cd 80 0f			call get_word_hl	; ret 16bit word in hl 
1bbc			 
1bbc c3 04 1a			jp forth_push_numhl 
1bbf			 
1bbf 00				 nop 
1bc0			 
1bc0			.fabin:   ; TODO bin conversion 
1bc0			 
1bc0			 
1bc0 c9				ret 
1bc1			 
1bc1			 
1bc1			; get either a string ptr or a 16bit word from the data stack 
1bc1			 
1bc1			FORTH_DSP: macro 
1bc1				call macro_forth_dsp 
1bc1				endm 
1bc1			 
1bc1			macro_forth_dsp: 
1bc1				; data stack pointer points to current word on tos 
1bc1			 
1bc1 2a 0d eb			ld hl,(cli_data_sp) 
1bc4			 
1bc4				if DEBUG_FORTH_PUSH 
1bc4						DMARK "DSP" 
1bc4 f5				push af  
1bc5 3a d9 1b			ld a, (.dmark)  
1bc8 32 7a ee			ld (debug_mark),a  
1bcb 3a da 1b			ld a, (.dmark+1)  
1bce 32 7b ee			ld (debug_mark+1),a  
1bd1 3a db 1b			ld a, (.dmark+2)  
1bd4 32 7c ee			ld (debug_mark+2),a  
1bd7 18 03			jr .pastdmark  
1bd9 ..			.dmark: db "DSP"  
1bdc f1			.pastdmark: pop af  
1bdd			endm  
# End of macro DMARK
1bdd			 
1bdd cd d4 45				call display_data_sp 
1be0				;call break_point_state 
1be0				;rst 030h 
1be0				CALLMONITOR 
1be0 cd 77 14			call break_point_state  
1be3				endm  
# End of macro CALLMONITOR
1be3				endif 
1be3			 
1be3 c9				ret 
1be4			 
1be4			; return hl to start of value on stack 
1be4			 
1be4			FORTH_DSP_VALUE: macro 
1be4				call macro_forth_dsp_value 
1be4				endm 
1be4			 
1be4			macro_forth_dsp_value: 
1be4			 
1be4				FORTH_DSP 
1be4 cd c1 1b			call macro_forth_dsp 
1be7				endm 
# End of macro FORTH_DSP
1be7			 
1be7 d5				push de 
1be8			 
1be8 23				inc hl ; skip type 
1be9			 
1be9 5e				ld e, (hl) 
1bea 23				inc hl 
1beb 56				ld d, (hl) 
1bec eb				ex de,hl  
1bed			 
1bed d1				pop de 
1bee			 
1bee c9				ret 
1bef			 
1bef			; return hl to start of value to second item on stack 
1bef			 
1bef			FORTH_DSP_VALUEM1: macro 
1bef				call macro_forth_dsp_value_m1 
1bef				endm 
1bef			 
1bef			macro_forth_dsp_value_m1: 
1bef			 
1bef				FORTH_DSP 
1bef cd c1 1b			call macro_forth_dsp 
1bf2				endm 
# End of macro FORTH_DSP
1bf2			 
1bf2 2b				dec hl 
1bf3 2b				dec hl 
1bf4			;	dec hl 
1bf4			 
1bf4 d5				push de 
1bf5			 
1bf5 5e				ld e, (hl) 
1bf6 23				inc hl 
1bf7 56				ld d, (hl) 
1bf8 eb				ex de,hl  
1bf9			 
1bf9 d1				pop de 
1bfa			 
1bfa c9				ret 
1bfb			 
1bfb				 
1bfb			 
1bfb			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1bfb			 
1bfb			FORTH_DSP_POP: macro 
1bfb				call macro_forth_dsp_pop 
1bfb				endm 
1bfb			 
1bfb			 
1bfb			; get the tos data type 
1bfb			 
1bfb			FORTH_DSP_TYPE:   macro 
1bfb			 
1bfb				;FORTH_DSP_VALUE 
1bfb				FORTH_DSP 
1bfb				 
1bfb				; hl points to value 
1bfb				; check type 
1bfb			 
1bfb				ld a,(hl) 
1bfb			 
1bfb				endm 
1bfb			 
1bfb			; load the tos value into hl 
1bfb			 
1bfb			 
1bfb			FORTH_DSP_VALUEHL:  macro 
1bfb				call macro_dsp_valuehl 
1bfb				endm 
1bfb			 
1bfb			 
1bfb			 
1bfb			macro_dsp_valuehl: 
1bfb				FORTH_DSP_VALUE 
1bfb cd e4 1b			call macro_forth_dsp_value 
1bfe				endm 
# End of macro FORTH_DSP_VALUE
1bfe			 
1bfe				;FORTH_ERR_TOS_NOTNUM 
1bfe			 
1bfe				;inc hl   ; skip type id 
1bfe			 
1bfe			;	push de 
1bfe			; 
1bfe			;	ld e, (hl) 
1bfe			;	inc hl 
1bfe			;	ld d, (hl) 
1bfe			;	ex de,hl  
1bfe			 
1bfe			;	pop de 
1bfe			 
1bfe				if DEBUG_FORTH_PUSH 
1bfe						DMARK "DVL" 
1bfe f5				push af  
1bff 3a 13 1c			ld a, (.dmark)  
1c02 32 7a ee			ld (debug_mark),a  
1c05 3a 14 1c			ld a, (.dmark+1)  
1c08 32 7b ee			ld (debug_mark+1),a  
1c0b 3a 15 1c			ld a, (.dmark+2)  
1c0e 32 7c ee			ld (debug_mark+2),a  
1c11 18 03			jr .pastdmark  
1c13 ..			.dmark: db "DVL"  
1c16 f1			.pastdmark: pop af  
1c17			endm  
# End of macro DMARK
1c17				CALLMONITOR 
1c17 cd 77 14			call break_point_state  
1c1a				endm  
# End of macro CALLMONITOR
1c1a				endif 
1c1a c9				ret 
1c1b			 
1c1b			forth_apushstrhl:      
1c1b				; push of string requires use of cli_origptr 
1c1b				; bodge use 
1c1b			 
1c1b				; get current cli_origptr, save, update with temp pointer  
1c1b ed 5b 29 eb		ld de, (cli_origptr) 
1c1f 22 29 eb			ld (cli_origptr), hl 
1c22 d5				push de 
1c23 cd 6d 1b			call forth_apush 
1c26 d1				pop de 
1c27 ed 53 29 eb		ld (cli_origptr), de 
1c2b c9			        ret	 
1c2c			 
1c2c			 
1c2c			; increase loop stack pointer and save hl to it 
1c2c				 
1c2c			FORTH_LOOP_NEXT: macro 
1c2c				call macro_forth_loop_next 
1c2c				;nop 
1c2c				endm 
1c2c			 
1c2c			macro_forth_loop_next: 
1c2c				if DEBUG_FORTH_STACK_GUARD 
1c2c cd 39 56				call check_stacks 
1c2f				endif 
1c2f e5				push hl 
1c30 d5				push de 
1c31 eb				ex de,hl 
1c32 2a 0f eb			ld hl,(cli_loop_sp) 
1c35 23				inc hl 
1c36 23				inc hl 
1c37					if DEBUG_FORTH_WORDS 
1c37						DMARK "LNX" 
1c37 f5				push af  
1c38 3a 4c 1c			ld a, (.dmark)  
1c3b 32 7a ee			ld (debug_mark),a  
1c3e 3a 4d 1c			ld a, (.dmark+1)  
1c41 32 7b ee			ld (debug_mark+1),a  
1c44 3a 4e 1c			ld a, (.dmark+2)  
1c47 32 7c ee			ld (debug_mark+2),a  
1c4a 18 03			jr .pastdmark  
1c4c ..			.dmark: db "LNX"  
1c4f f1			.pastdmark: pop af  
1c50			endm  
# End of macro DMARK
1c50						CALLMONITOR 
1c50 cd 77 14			call break_point_state  
1c53				endm  
# End of macro CALLMONITOR
1c53					endif 
1c53 22 0f eb			ld (cli_loop_sp),hl 
1c56 73				ld (hl), e 
1c57 23				inc hl 
1c58 72				ld (hl), d 
1c59 d1				pop de    ; been reversed so save a swap on restore 
1c5a e1				pop hl 
1c5b				if DEBUG_FORTH_STACK_GUARD 
1c5b cd 39 56				call check_stacks 
1c5e				endif 
1c5e c9				ret 
1c5f			 
1c5f			; get current ret stack pointer and save to hl  
1c5f				 
1c5f			FORTH_LOOP_TOS: macro 
1c5f				call macro_forth_loop_tos 
1c5f				endm 
1c5f			 
1c5f			macro_forth_loop_tos: 
1c5f d5				push de 
1c60 2a 0f eb			ld hl,(cli_loop_sp) 
1c63 5e				ld e, (hl) 
1c64 23				inc hl 
1c65 56				ld d, (hl) 
1c66 eb				ex de, hl 
1c67 d1				pop de 
1c68 c9				ret 
1c69			 
1c69			; pop loop stack pointer 
1c69				 
1c69			FORTH_LOOP_POP: macro 
1c69				call macro_forth_loop_pop 
1c69				endm 
1c69			 
1c69			 
1c69			macro_forth_loop_pop: 
1c69				if DEBUG_FORTH_STACK_GUARD 
1c69					DMARK "LPP" 
1c69 f5				push af  
1c6a 3a 7e 1c			ld a, (.dmark)  
1c6d 32 7a ee			ld (debug_mark),a  
1c70 3a 7f 1c			ld a, (.dmark+1)  
1c73 32 7b ee			ld (debug_mark+1),a  
1c76 3a 80 1c			ld a, (.dmark+2)  
1c79 32 7c ee			ld (debug_mark+2),a  
1c7c 18 03			jr .pastdmark  
1c7e ..			.dmark: db "LPP"  
1c81 f1			.pastdmark: pop af  
1c82			endm  
# End of macro DMARK
1c82 cd 39 56				call check_stacks 
1c85					FORTH_CHK_LOOP_UNDER 
1c85 e5				push hl 
1c86 d5				push de 
1c87 2a 0f eb			ld hl,(cli_loop_sp) 
1c8a 11 c9 e9			ld de, cli_loop_stack 
1c8d cd e7 0b			call cmp16 
1c90 da 53 57			jp c, fault_loop_under 
1c93 d1				pop de 
1c94 e1				pop hl 
1c95				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c95				endif 
1c95 e5				push hl 
1c96 2a 0f eb			ld hl,(cli_loop_sp) 
1c99 2b				dec hl 
1c9a 2b				dec hl 
1c9b 22 0f eb			ld (cli_loop_sp), hl 
1c9e				; TODO do stack underflow checks 
1c9e e1				pop hl 
1c9f				if DEBUG_FORTH_STACK_GUARD 
1c9f cd 39 56				call check_stacks 
1ca2					FORTH_CHK_LOOP_UNDER 
1ca2 e5				push hl 
1ca3 d5				push de 
1ca4 2a 0f eb			ld hl,(cli_loop_sp) 
1ca7 11 c9 e9			ld de, cli_loop_stack 
1caa cd e7 0b			call cmp16 
1cad da 53 57			jp c, fault_loop_under 
1cb0 d1				pop de 
1cb1 e1				pop hl 
1cb2				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1cb2				endif 
1cb2 c9				ret 
1cb3			 
1cb3			macro_forth_dsp_pop: 
1cb3			 
1cb3 e5				push hl 
1cb4			 
1cb4				; release malloc data 
1cb4			 
1cb4				if DEBUG_FORTH_STACK_GUARD 
1cb4 cd 39 56				call check_stacks 
1cb7					FORTH_CHK_DSP_UNDER 
1cb7 e5				push hl 
1cb8 d5				push de 
1cb9 2a 0d eb			ld hl,(cli_data_sp) 
1cbc 11 c7 e8			ld de, cli_data_stack 
1cbf cd e7 0b			call cmp16 
1cc2 da 47 57			jp c, fault_dsp_under 
1cc5 d1				pop de 
1cc6 e1				pop hl 
1cc7				endm 
# End of macro FORTH_CHK_DSP_UNDER
1cc7				endif 
1cc7				;ld hl,(cli_data_sp) 
1cc7			if DEBUG_FORTH_DOT 
1cc7				DMARK "DPP" 
1cc7				CALLMONITOR 
1cc7			endif	 
1cc7			 
1cc7			 
1cc7			if FORTH_ENABLE_DSPPOPFREE 
1cc7			 
1cc7				FORTH_DSP 
1cc7 cd c1 1b			call macro_forth_dsp 
1cca				endm 
# End of macro FORTH_DSP
1cca			 
1cca 7e				ld a, (hl) 
1ccb fe 01			cp DS_TYPE_STR 
1ccd 20 07			jr nz, .skippopfree 
1ccf			 
1ccf				FORTH_DSP_VALUEHL 
1ccf cd fb 1b			call macro_dsp_valuehl 
1cd2				endm 
# End of macro FORTH_DSP_VALUEHL
1cd2 00				nop 
1cd3			if DEBUG_FORTH_DOT 
1cd3				DMARK "DPf" 
1cd3				CALLMONITOR 
1cd3			endif	 
1cd3 cd 5a 11			call free 
1cd6			.skippopfree: 
1cd6				 
1cd6			 
1cd6			endif 
1cd6			 
1cd6			if DEBUG_FORTH_DOT_KEY 
1cd6				DMARK "DP2" 
1cd6				CALLMONITOR 
1cd6			endif	 
1cd6			 
1cd6				; move pointer down 
1cd6			 
1cd6 2a 0d eb			ld hl,(cli_data_sp) 
1cd9 2b				dec hl 
1cda 2b				dec hl 
1cdb			; PARSEV5 
1cdb 2b				dec hl 
1cdc 22 0d eb			ld (cli_data_sp), hl 
1cdf			 
1cdf				if DEBUG_FORTH_STACK_GUARD 
1cdf cd 39 56				call check_stacks 
1ce2					FORTH_CHK_DSP_UNDER 
1ce2 e5				push hl 
1ce3 d5				push de 
1ce4 2a 0d eb			ld hl,(cli_data_sp) 
1ce7 11 c7 e8			ld de, cli_data_stack 
1cea cd e7 0b			call cmp16 
1ced da 47 57			jp c, fault_dsp_under 
1cf0 d1				pop de 
1cf1 e1				pop hl 
1cf2				endm 
# End of macro FORTH_CHK_DSP_UNDER
1cf2				endif 
1cf2			 
1cf2 e1				pop hl 
1cf3			 
1cf3 c9				ret 
1cf4			 
1cf4			getwordathl: 
1cf4				; hl points to an address 
1cf4				; load hl with the word at that address 
1cf4			 
1cf4 d5				push de 
1cf5			 
1cf5 5e				ld e, (hl) 
1cf6 23				inc hl 
1cf7 56				ld d, (hl) 
1cf8 eb				ex de, hl 
1cf9			 
1cf9 d1				pop de 
1cfa c9				ret 
1cfb			 
1cfb			 
1cfb			 
1cfb			 
1cfb			 
1cfb			; eof 
1cfb			 
# End of file forth_stackopsv5.asm
1cfb			endif 
1cfb			 
1cfb			user_word_eol:  
1cfb				; hl contains the pointer to where to create a linked list item from the end 
1cfb				; of the user dict to continue on at the system word dict 
1cfb				 
1cfb				; poke the stub of the word list linked list to repoint to rom words 
1cfb			 
1cfb				; stub format 
1cfb				; db   word id 
1cfb				; dw    link to next word 
1cfb			        ; db char length of token 
1cfb				; db string + 0 term 
1cfb				; db exec code....  
1cfb			 
1cfb 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1cfd 77				ld (hl), a		; word id 
1cfe 23				inc hl 
1cff			 
1cff 11 c5 1e			ld de, sysdict 
1d02 73				ld (hl), e		; next word link ie system dict 
1d03 23				inc hl 
1d04 72				ld (hl), d		; next word link ie system dict 
1d05 23				inc hl	 
1d06			 
1d06			;	ld (hl), sysdict		; next word link ie system dict 
1d06			;	inc hl 
1d06			;	inc hl 
1d06			 
1d06			;	inc hl 
1d06			;	inc hl 
1d06			 
1d06 3e 02			ld a, 2			; word length is 0 
1d08 77				ld (hl), a	 
1d09 23				inc hl 
1d0a			 
1d0a 3e 7e			ld a, '~'			; word length is 0 
1d0c 77				ld (hl), a	 
1d0d 23				inc hl 
1d0e 3e 00			ld a, 0			; save empty word 
1d10 77				ld (hl), a 
1d11			 
1d11 c9				ret 
1d12			 
1d12				 
1d12			 
1d12			forthexec_cleanup: 
1d12				FORTH_RSP_POP 
1d12 cd cc 19			call macro_forth_rsp_pop 
1d15				endm 
# End of macro FORTH_RSP_POP
1d15 c9				ret 
1d16			 
1d16			forth_call_hl: 
1d16				; taking hl 
1d16 e5				push hl 
1d17 c9				ret 
1d18			 
1d18			; this is called to reset Forth system but keep existing uwords etc 
1d18			 
1d18			forth_warmstart: 
1d18				; setup stack over/under flow checks 
1d18				if DEBUG_FORTH_STACK_GUARD 
1d18 cd 1f 56				call chk_stk_init 
1d1b				endif 
1d1b			 
1d1b				; init stack pointers  - * these stacks go upwards *  
1d1b 21 cb ea			ld hl, cli_ret_stack 
1d1e 22 11 eb			ld (cli_ret_sp), hl	 
1d21				; set bottom of stack 
1d21 3e 00			ld a,0 
1d23 77				ld (hl),a 
1d24 23				inc hl 
1d25 77				ld (hl),a 
1d26			 
1d26 21 c7 e8			ld hl, cli_data_stack 
1d29 22 0d eb			ld (cli_data_sp), hl	 
1d2c				; set bottom of stack 
1d2c 3e 00			ld a,0 
1d2e 77				ld (hl),a 
1d2f 23				inc hl 
1d30 77				ld (hl),a 
1d31			 
1d31 21 c9 e9			ld hl, cli_loop_stack 
1d34 22 0f eb			ld (cli_loop_sp), hl	 
1d37				; set bottom of stack 
1d37 3e 00			ld a,0 
1d39 77				ld (hl),a 
1d3a 23				inc hl 
1d3b 77				ld (hl),a 
1d3c			 
1d3c				; init extent of current open file 
1d3c			 
1d3c 3e 00			ld a, 0 
1d3e 32 5c eb			ld (store_openext), a 
1d41			 
1d41 c9				ret 
1d42			 
1d42			 
1d42			; Cold Start - this is called to setup the whole Forth system 
1d42			 
1d42			forth_init: 
1d42			 
1d42				; setup stack over/under flow checks 
1d42			 
1d42			;	if DEBUG_FORTH_STACK_GUARD 
1d42			;		call chk_stk_init 
1d42			;	endif 
1d42			 
1d42				; enable auto display updates (slow.....) 
1d42			 
1d42 3e 01			ld a, 1 
1d44 32 27 eb			ld (cli_autodisplay), a 
1d47			 
1d47			 
1d47			 
1d47				; show start up screen 
1d47			 
1d47 cd 9c 09			call clear_display 
1d4a			 
1d4a 3e 00			ld a,0 
1d4c 32 49 eb			ld (f_cursor_ptr), a 
1d4f			 
1d4f				; set start of word list in start of ram - for use when creating user words 
1d4f			 
1d4f 21 42 59			ld hl, baseram 
1d52 22 5d e6			ld (os_last_new_uword), hl 
1d55 cd fb 1c			call user_word_eol 
1d58				 
1d58			;		call display_data_sp 
1d58			;		call next_page_prompt 
1d58			 
1d58			 
1d58			 
1d58			 
1d58 c9				ret 
1d59			 
1d59 .. 00		.bootforth: db " Forth Kernel Init ",0 
1d6d			 
1d6d			; TODO push to stack 
1d6d			 
1d6d			;  
1d6d			 
1d6d			if FORTH_PARSEV2 
1d6d			 
1d6d			 
1d6d				include "forth_parserv2.asm" 
1d6d			 
1d6d			endif 
1d6d			 
1d6d			 
1d6d			; parse cli version 1 
1d6d			 
1d6d			if FORTH_PARSEV1 
1d6d			 
1d6d			 
1d6d			 
1d6d			      include "forth_parserv1.asm" 
1d6d			endif 
1d6d				 
1d6d			if FORTH_PARSEV3 
1d6d			 
1d6d			 
1d6d			 
1d6d			      include "forth_parserv3.asm" 
1d6d				include "forth_wordsv3.asm" 
1d6d			endif 
1d6d			 
1d6d			if FORTH_PARSEV4 
1d6d			 
1d6d			 
1d6d			 
1d6d			      include "forth_parserv4.asm" 
1d6d				include "forth_wordsv4.asm" 
1d6d			endif 
1d6d			 
1d6d			if FORTH_PARSEV5 
1d6d			 
1d6d			 
1d6d			 
1d6d			      include "forth_parserv5.asm" 
1d6d			 
1d6d			 
1d6d			; A better parser without using malloc and string copies all over the place.  
1d6d			; Exec in situ should be faster 
1d6d			 
1d6d			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1d6d			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1d6d			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1d6d			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1d6d			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1d6d			WORD_SYS_END: equ 0   ; Opcode for all user words 
1d6d			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1d6d			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1d6d			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1d6d			 
1d6d			; Core word preamble macro 
1d6d			 
1d6d			CWHEAD:   macro nxtword opcode lit len opflags 
1d6d				db WORD_SYS_CORE+opcode             
1d6d				; internal op code number 
1d6d				dw nxtword            
1d6d				; link to next dict word block 
1d6d				db len + 1 
1d6d				; literal length of dict word inc zero term 
1d6d				db lit,0              
1d6d				; literal dict word 
1d6d			        ; TODO db opflags        
1d6d				endm 
1d6d			 
1d6d			 
1d6d			NEXTW: macro  
1d6d				jp macro_next 
1d6d				endm 
1d6d			 
1d6d			macro_next: 
1d6d			if DEBUG_FORTH_PARSE_KEY 
1d6d				DMARK "NXT" 
1d6d				CALLMONITOR 
1d6d			endif	 
1d6d			;	inc hl  ; skip token null term  
1d6d ed 4b 2b eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1d71 ed 5b 29 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1d75 2a 61 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1d78			if DEBUG_FORTH_PARSE_KEY 
1d78				DMARK "}AA" 
1d78				CALLMONITOR 
1d78			endif	 
1d78 c3 7b 1e			jp execnext 
1d7b				;jp exec1 
1d7b			       
1d7b			 
1d7b			 
1d7b			; Another go at the parser to compile  
1d7b			 
1d7b			 
1d7b			; TODO rework parser to change all of the string words to byte tokens 
1d7b			; TODO do a search for  
1d7b			 
1d7b			; TODO first run normal parser to zero term sections 
1d7b			; TODO for each word do a token look up to get the op code 
1d7b			; TODO need some means to flag to the exec that this is a byte code form    
1d7b			 
1d7b			 
1d7b			forthcompile: 
1d7b			 
1d7b			; 
1d7b			; line parse: 
1d7b			;       parse raw input buffer 
1d7b			;       tokenise the words 
1d7b			;       malloc new copy (for looping etc) 
1d7b			;       copy to malloc + current pc in line to start of string and add line term 
1d7b			;       save on new rsp 
1d7b			; 
1d7b			 
1d7b			; hl to point to the line to tokenise 
1d7b			 
1d7b			;	push hl 
1d7b 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d7e			 
1d7e			;	ld a,0		; string term on input 
1d7e			;	call strlent 
1d7e			 
1d7e			;	ld (os_tok_len), hl	 ; save string length 
1d7e			 
1d7e			;if DEBUG_FORTH_TOK 
1d7e			;	ex de,hl		 
1d7e			;endif 
1d7e			 
1d7e			;	pop hl 		; get back string pointer 
1d7e			 
1d7e			if DEBUG_FORTH_TOK 
1d7e						DMARK "TOc" 
1d7e				CALLMONITOR 
1d7e			endif 
1d7e 7e			.cptoken2:    ld a,(hl) 
1d7f 23				inc hl 
1d80 fe 7f			cp FORTH_END_BUFFER 
1d82 28 29			jr z, .cptokendone2 
1d84 fe 00			cp 0 
1d86 28 25			jr z, .cptokendone2 
1d88 fe 22			cp '"' 
1d8a 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1d8c fe 20			cp ' ' 
1d8e 20 ee			jr nz,  .cptoken2 
1d90			 
1d90			; TODO consume comments held between ( and ) 
1d90			 
1d90				; we have a space so change to zero term for dict match later 
1d90 2b				dec hl 
1d91 3e 00			ld a,0 
1d93 77				ld (hl), a 
1d94 23				inc hl 
1d95 18 e7			jr .cptoken2 
1d97				 
1d97			 
1d97			.cptokenstr2: 
1d97				; skip all white space until either eol (because forgot to term) or end double quote 
1d97			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d97				;inc hl ; skip current double quote 
1d97 7e				ld a,(hl) 
1d98 23				inc hl 
1d99 fe 22			cp '"' 
1d9b 28 e1			jr z, .cptoken2 
1d9d fe 7f			cp FORTH_END_BUFFER 
1d9f 28 0c			jr z, .cptokendone2 
1da1 fe 00			cp 0 
1da3 28 08			jr z, .cptokendone2 
1da5 fe 20			cp ' ' 
1da7 28 02			jr z, .cptmp2 
1da9 18 ec			jr .cptokenstr2 
1dab			 
1dab			.cptmp2:	; we have a space so change to zero term for dict match later 
1dab				;dec hl 
1dab				;ld a,"-"	; TODO remove this when working 
1dab				;ld (hl), a 
1dab				;inc hl 
1dab 18 ea			jr .cptokenstr2 
1dad			 
1dad			.cptokendone2: 
1dad				;inc hl 
1dad 3e 7f			ld a, FORTH_END_BUFFER 
1daf 77				ld (hl),a 
1db0 23				inc hl 
1db1 3e 21			ld a, '!' 
1db3 77				ld (hl),a 
1db4			 
1db4 2a 61 e6			ld hl,(os_tok_ptr) 
1db7			         
1db7			if DEBUG_FORTH_TOK 
1db7						DMARK "Tc1" 
1db7				CALLMONITOR 
1db7			endif 
1db7			 
1db7				; push exec string to top of return stack 
1db7				FORTH_RSP_NEXT 
1db7 cd ab 19			call macro_forth_rsp_next 
1dba				endm 
# End of macro FORTH_RSP_NEXT
1dba c9				ret 
1dbb			 
1dbb			; Another go at the parser need to simplify the process 
1dbb			 
1dbb			forthparse: 
1dbb			 
1dbb			; 
1dbb			; line parse: 
1dbb			;       parse raw input buffer 
1dbb			;       tokenise the words 
1dbb			;       malloc new copy (for looping etc) 
1dbb			;       copy to malloc + current pc in line to start of string and add line term 
1dbb			;       save on new rsp 
1dbb			; 
1dbb			 
1dbb			; hl to point to the line to tokenise 
1dbb			 
1dbb			;	push hl 
1dbb 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1dbe			 
1dbe			;	ld a,0		; string term on input 
1dbe			;	call strlent 
1dbe			 
1dbe			;	ld (os_tok_len), hl	 ; save string length 
1dbe			 
1dbe			;if DEBUG_FORTH_TOK 
1dbe			;	ex de,hl		 
1dbe			;endif 
1dbe			 
1dbe			;	pop hl 		; get back string pointer 
1dbe			 
1dbe			if DEBUG_FORTH_TOK 
1dbe						DMARK "TOK" 
1dbe				CALLMONITOR 
1dbe			endif 
1dbe 7e			.ptoken2:    ld a,(hl) 
1dbf 23				inc hl 
1dc0 fe 7f			cp FORTH_END_BUFFER 
1dc2 28 29			jr z, .ptokendone2 
1dc4 fe 00			cp 0 
1dc6 28 25			jr z, .ptokendone2 
1dc8 fe 22			cp '"' 
1dca 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1dcc fe 20			cp ' ' 
1dce 20 ee			jr nz,  .ptoken2 
1dd0			 
1dd0			; TODO consume comments held between ( and ) 
1dd0			 
1dd0				; we have a space so change to zero term for dict match later 
1dd0 2b				dec hl 
1dd1 3e 00			ld a,0 
1dd3 77				ld (hl), a 
1dd4 23				inc hl 
1dd5 18 e7			jr .ptoken2 
1dd7				 
1dd7			 
1dd7			.ptokenstr2: 
1dd7				; skip all white space until either eol (because forgot to term) or end double quote 
1dd7			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1dd7				;inc hl ; skip current double quote 
1dd7 7e				ld a,(hl) 
1dd8 23				inc hl 
1dd9 fe 22			cp '"' 
1ddb 28 e1			jr z, .ptoken2 
1ddd fe 7f			cp FORTH_END_BUFFER 
1ddf 28 0c			jr z, .ptokendone2 
1de1 fe 00			cp 0 
1de3 28 08			jr z, .ptokendone2 
1de5 fe 20			cp ' ' 
1de7 28 02			jr z, .ptmp2 
1de9 18 ec			jr .ptokenstr2 
1deb			 
1deb			.ptmp2:	; we have a space so change to zero term for dict match later 
1deb				;dec hl 
1deb				;ld a,"-"	; TODO remove this when working 
1deb				;ld (hl), a 
1deb				;inc hl 
1deb 18 ea			jr .ptokenstr2 
1ded			 
1ded			.ptokendone2: 
1ded				;inc hl 
1ded 3e 7f			ld a, FORTH_END_BUFFER 
1def 77				ld (hl),a 
1df0 23				inc hl 
1df1 3e 21			ld a, '!' 
1df3 77				ld (hl),a 
1df4			 
1df4 2a 61 e6			ld hl,(os_tok_ptr) 
1df7			         
1df7			if DEBUG_FORTH_TOK 
1df7						DMARK "TK1" 
1df7				CALLMONITOR 
1df7			endif 
1df7			 
1df7				; push exec string to top of return stack 
1df7				FORTH_RSP_NEXT 
1df7 cd ab 19			call macro_forth_rsp_next 
1dfa				endm 
# End of macro FORTH_RSP_NEXT
1dfa c9				ret 
1dfb			 
1dfb			; 
1dfb			;	; malloc size + buffer pointer + if is loop flag 
1dfb			;	ld hl,(os_tok_len) 		 ; get string length 
1dfb			; 
1dfb			;	ld a,l 
1dfb			; 
1dfb			;	cp 0			; we dont want to use a null string 
1dfb			;	ret z 
1dfb			; 
1dfb			;;	add 3    ; prefix malloc with buffer for current word ptr 
1dfb			; 
1dfb			;	add 5     ; TODO when certain not over writing memory remove 
1dfb			; 
1dfb			;		 
1dfb			; 
1dfb			;if DEBUG_FORTH_TOK 
1dfb			;			DMARK "TKE" 
1dfb			;	CALLMONITOR 
1dfb			;endif 
1dfb			; 
1dfb			;	ld l,a 
1dfb			;	ld h,0 
1dfb			;;	push hl   ; save required space for the copy later 
1dfb			;	call malloc 
1dfb			;if DEBUG_FORTH_TOK 
1dfb			;			DMARK "TKM" 
1dfb			;	CALLMONITOR 
1dfb			;endif 
1dfb			;	if DEBUG_FORTH_MALLOC_GUARD 
1dfb			;		push af 
1dfb			;		call ishlzero 
1dfb			;;		ld a, l 
1dfb			;;		add h 
1dfb			;;		cp 0 
1dfb			;		pop af 
1dfb			;		 
1dfb			;		call z,malloc_error 
1dfb			;	endif 
1dfb			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1dfb			; 
1dfb			; 
1dfb			;if DEBUG_FORTH_TOK 
1dfb			;			DMARK "TKR" 
1dfb			;	CALLMONITOR 
1dfb			;endif 
1dfb			; 
1dfb			;	FORTH_RSP_NEXT 
1dfb			; 
1dfb			;	;inc hl	 ; go past current buffer pointer 
1dfb			;	;inc hl 
1dfb			;	;inc hl   ; and past if loop flag 
1dfb			;		; TODO Need to set flag  
1dfb			; 
1dfb			;	 
1dfb			;	 
1dfb			;	ex de,hl	; malloc is dest 
1dfb			;	ld hl, (os_tok_len) 
1dfb			;;	pop bc 
1dfb			;	ld c, l                
1dfb			;	ld b,0 
1dfb			;	ld hl, (os_tok_ptr) 
1dfb			; 
1dfb			;if DEBUG_FORTH_TOK 
1dfb			;			DMARK "TKT" 
1dfb			;	CALLMONITOR 
1dfb			;endif 
1dfb			; 
1dfb			;	; do str cpy 
1dfb			; 
1dfb			;	ldir      ; copy byte in hl to de 
1dfb			; 
1dfb			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1dfb			; 
1dfb			;if DEBUG_FORTH_TOK 
1dfb			; 
1dfb			;			DMARK "TKY" 
1dfb			;	CALLMONITOR 
1dfb			;endif 
1dfb			;	;ld a,0 
1dfb			;	;ld a,FORTH_END_BUFFER 
1dfb			;	ex de, hl 
1dfb			;	;dec hl			 ; go back over the space delim at the end of word 
1dfb			;	;ld (hl),a 
1dfb			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1dfb			;	ld a,FORTH_END_BUFFER 
1dfb			;	ld (hl),a 
1dfb			;	inc hl 
1dfb			;	ld a,FORTH_END_BUFFER 
1dfb			;	ld (hl),a 
1dfb			; 
1dfb			;	; init the malloc area data 
1dfb			;	; set pc for in current area 
1dfb			;	;ld hl, (os_tok_malloc) 
1dfb			;	;inc hl 
1dfb			;	;inc hl 
1dfb			;	;inc hl 
1dfb			;	;ex de,hl 
1dfb			;	;ld hl, (os_tok_malloc) 
1dfb			;	;ld (hl),e 
1dfb			;	;inc hl 
1dfb			;	;ld (hl),d 
1dfb			; 
1dfb			; 
1dfb			;	ld hl,(os_tok_malloc) 
1dfb			;if DEBUG_FORTH_PARSE_KEY 
1dfb			;			DMARK "TKU" 
1dfb			;	CALLMONITOR 
1dfb			;endif 
1dfb			; 
1dfb			;	ret 
1dfb			 
1dfb			forthexec: 
1dfb			 
1dfb			; line exec: 
1dfb			; forth parser 
1dfb			 
1dfb			; 
1dfb			;       get current exec line on rsp 
1dfb			 
1dfb				FORTH_RSP_TOS 
1dfb cd c2 19			call macro_forth_rsp_tos 
1dfe				endm 
# End of macro FORTH_RSP_TOS
1dfe			 
1dfe			;       restore current pc - hl points to malloc of data 
1dfe			 
1dfe				;ld e, (hl) 
1dfe				;inc hl 
1dfe				;ld d, (hl) 
1dfe				;ex de,hl 
1dfe			 
1dfe			 
1dfe			exec1: 
1dfe 22 61 e6			ld (os_tok_ptr), hl 
1e01			 
1e01				; copy our PC to working vars  
1e01 22 2b eb			ld (cli_ptr), hl 
1e04 22 29 eb			ld (cli_origptr), hl 
1e07			 
1e07 7e				ld a,(hl) 
1e08 fe 7f			cp FORTH_END_BUFFER 
1e0a c8				ret z 
1e0b			 
1e0b				; skip any nulls 
1e0b			 
1e0b fe 00			cp 0 
1e0d 20 03			jr nz, .execword 
1e0f 23				inc hl 
1e10 18 ec			jr exec1 
1e12			 
1e12			 
1e12			.execword: 
1e12			 
1e12			 
1e12			 
1e12			if DEBUG_FORTH_PARSE_KEY 
1e12						DMARK "KYQ" 
1e12				CALLMONITOR 
1e12			endif 
1e12			;       while at start of word: 
1e12			; get start of dict (in user area first) 
1e12			 
1e12 21 42 59		ld hl, baseram 
1e15			;ld hl, sysdict 
1e15 22 2d eb		ld (cli_nextword),hl 
1e18			;           match word at pc 
1e18			;           exec word 
1e18			;           or push to dsp 
1e18			;           forward to next token 
1e18			;           if line term pop rsp and exit 
1e18			;        
1e18			 
1e18			if DEBUG_FORTH_PARSE_KEY 
1e18						DMARK "KYq" 
1e18				CALLMONITOR 
1e18			endif 
1e18			 
1e18			; 
1e18			; word comp 
1e18			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1e18			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1e18			;    move to start of word  
1e18			;    compare word to cli_token 
1e18			 
1e18			.execpnword:	; HL at start of a word in the dictionary to check 
1e18			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1e18			;	ld (cli_ptr), hl 
1e18			 
1e18 2a 2d eb			ld hl,(cli_nextword) 
1e1b			 
1e1b cd be 1e			call forth_tok_next 
1e1e			; tok next start here 
1e1e			;	; TODO skip compiled symbol for now 
1e1e			;	inc hl 
1e1e			; 
1e1e			;	; save pointer to next word 
1e1e			; 
1e1e			;	; hl now points to the address of the next word pointer  
1e1e			;	ld e, (hl) 
1e1e			;	inc hl 
1e1e			;	ld d, (hl) 
1e1e			;	inc l 
1e1e			; 
1e1e			;	ex de,hl 
1e1e			;if DEBUG_FORTH_PARSE_NEXTWORD 
1e1e			;	push bc 
1e1e			;	ld bc, (cli_nextword) 
1e1e			;			DMARK "NXW" 
1e1e			;	CALLMONITOR 
1e1e			;	pop bc 
1e1e			;endif 
1e1e			; tok next end here 
1e1e 22 2d eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1e21 eb				ex de, hl 
1e22			 
1e22			 
1e22				; save the pointer of the current token - 1 to check against 
1e22				 
1e22 22 31 eb			ld (cli_token), hl   
1e25				; TODO maybe remove below save if no debug 
1e25				; save token string ptr for any debug later 
1e25 23				inc hl  
1e26 22 33 eb			ld (cli_origtoken), hl 
1e29 2b				dec hl 
1e2a				; save pointer to the start of the next dictionay word 
1e2a 7e				ld a,(hl)   ; get string length 
1e2b 47				ld b,a 
1e2c			.execpnwordinc:  
1e2c 23				inc hl 
1e2d 10 fd			djnz .execpnwordinc 
1e2f 22 2f eb			ld (cli_execword), hl      ; save start of this words code 
1e32			 
1e32				; now check the word token against the string being parsed 
1e32			 
1e32 2a 31 eb			ld hl,(cli_token) 
1e35 23				inc hl     ; skip string length (use zero term instead to end) 
1e36 22 31 eb			ld (cli_token), hl 
1e39			 
1e39			if DEBUG_FORTH_PARSE_KEY 
1e39						DMARK "KY2" 
1e39			endif 
1e39			if DEBUG_FORTH_PARSE_EXEC 
1e39				; see if disabled 
1e39			 
1e39				ld a, (os_view_disable) 
1e39				cp '*' 
1e39				jr z, .skip 
1e39			 
1e39				push hl 
1e39				push hl 
1e39				call clear_display 
1e39				ld de, .compword 
1e39				ld a, display_row_1 
1e39				call str_at_display 
1e39				pop de 
1e39				ld a, display_row_2 
1e39				call str_at_display 
1e39				ld hl,(cli_ptr) 
1e39				ld a,(hl) 
1e39			        ld hl, os_word_scratch 
1e39				ld (hl),a 
1e39				ld a,0 
1e39				inc hl 
1e39				ld (hl),a 	 
1e39				ld de, os_word_scratch 
1e39				ld a, display_row_2+10 
1e39				call str_at_display 
1e39				call update_display 
1e39				ld a, 100 
1e39				call aDelayInMS 
1e39				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e39				call delay250ms 
1e39				endif 
1e39				pop hl 
1e39			.skip:  
1e39			endif	 
1e39			.execpnchar:    ; compare char between token and string to parse 
1e39			 
1e39			if DEBUG_FORTH_PARSE_KEY 
1e39						DMARK "Ky3" 
1e39			endif 
1e39			if DEBUG_FORTH_PARSE_EXEC 
1e39				; see if disabled 
1e39			 
1e39				ld a, (os_view_disable) 
1e39				cp '*' 
1e39				jr z, .skip2 
1e39			 
1e39			;	call clear_display 
1e39			ld hl,(cli_token) 
1e39			ld a,(hl) 
1e39			ld (os_word_scratch),a 
1e39				ld hl,(cli_ptr) 
1e39			ld a,(hl) 
1e39				ld (os_word_scratch+1),a 
1e39				ld a,0 
1e39				ld (os_word_scratch+2),a 
1e39				ld de,os_word_scratch 
1e39				ld a,display_row_4 
1e39				call str_at_display 
1e39				call update_display 
1e39			.skip2:  
1e39			endif 
1e39 2a 31 eb			ld hl,(cli_token) 
1e3c 7e				ld a, (hl)	 ; char in word token 
1e3d 23				inc hl 		; move to next char 
1e3e 22 31 eb			ld (cli_token), hl ; and save it 
1e41 47				ld b,a 
1e42			 
1e42 2a 2b eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1e45 7e				ld a,(hl) 
1e46 23				inc hl 
1e47 22 2b eb			ld (cli_ptr), hl		; move to next char 
1e4a cd 1e 10			call toUpper 		; make sure the input string matches case 
1e4d			 
1e4d			if DEBUG_FORTH_PARSE 
1e4d			endif 
1e4d			 
1e4d				; input stream end of token is a space so get rid of it 
1e4d			 
1e4d			;	cp ' ' 
1e4d			;	jr nz, .pnskipspace 
1e4d			; 
1e4d			;	ld a, 0		; make same term as word token term 
1e4d			; 
1e4d			;.pnskipspace: 
1e4d			 
1e4d			if DEBUG_FORTH_PARSE_KEY 
1e4d						DMARK "KY7" 
1e4d			endif 
1e4d b8				cp b 
1e4e c2 64 1e			jp nz, .execpnskipword	 ; no match so move to next word 
1e51				 
1e51			;    if same 
1e51			;       scan for string terms 0 for token and 32 for input 
1e51			 
1e51				 
1e51			if DEBUG_FORTH_PARSE_KEY 
1e51						DMARK "KY8" 
1e51			endif 
1e51			 
1e51 80				add b			 
1e52 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1e54							; TODO need to make sure last word in zero term string is accounted for 
1e54 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1e56			 
1e56			 
1e56				; at end of both strings so both are exact match 
1e56			 
1e56			;       skip ptr for next word 
1e56			 
1e56 2a 2b eb			ld hl,(cli_ptr) 	; at input string term 
1e59 23				inc hl			 ; at next char 
1e5a 22 2b eb			ld (cli_ptr), hl     ; save for next round of the parser 
1e5d 22 29 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1e60				 
1e60				 
1e60			if DEBUG_FORTH_PARSE_KEY 
1e60						DMARK "KY3" 
1e60			endif 
1e60			 
1e60			 
1e60			 
1e60			;       exec code block 
1e60			if DEBUG_FORTH_JP 
1e60				call clear_display 
1e60				call update_display 
1e60				call delay1s 
1e60				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e60				ld a,h 
1e60				ld hl, os_word_scratch 
1e60				call hexout 
1e60				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e60				ld a,l 
1e60				ld hl, os_word_scratch+2 
1e60				call hexout 
1e60				ld hl, os_word_scratch+4 
1e60				ld a,0 
1e60				ld (hl),a 
1e60				ld de,os_word_scratch 
1e60				call str_at_display 
1e60					ld a, display_row_2 
1e60					call str_at_display 
1e60				ld de, (cli_origtoken) 
1e60				ld a, display_row_1+10 
1e60					call str_at_display 
1e60			 
1e60				ld a,display_row_1 
1e60				ld de, .foundword 
1e60				ld a, display_row_3 
1e60				call str_at_display 
1e60				call update_display 
1e60				call delay1s 
1e60				call delay1s 
1e60				call delay1s 
1e60			endif 
1e60			 
1e60			if DEBUG_FORTH_PARSE_KEY 
1e60						DMARK "KYj" 
1e60			endif 
1e60				; TODO save the word pointer in this exec 
1e60			 
1e60 2a 2f eb			ld hl,(cli_execword) 
1e63 e9				jp (hl) 
1e64			 
1e64			 
1e64			;    if not same 
1e64			;	scan for zero term 
1e64			;	get ptr for next word 
1e64			;	goto word comp 
1e64			 
1e64			.execpnskipword:	; get pointer to next word 
1e64 2a 2d eb			ld hl,(cli_nextword) 
1e67			 
1e67 7e				ld a,(hl) 
1e68 fe 00			cp WORD_SYS_END 
1e6a			;	cp 0 
1e6a 28 09			jr z, .execendofdict			 ; at end of words 
1e6c			 
1e6c			if DEBUG_FORTH_PARSE_KEY 
1e6c						DMARK "KY4" 
1e6c			endif 
1e6c			if DEBUG_FORTH_PARSE_EXEC 
1e6c			 
1e6c				; see if disabled 
1e6c			 
1e6c				ld a, (os_view_disable) 
1e6c				cp '*' 
1e6c				jr z, .noskip 
1e6c			 
1e6c			 
1e6c				ld de, .nowordfound 
1e6c				ld a, display_row_3 
1e6c				call str_at_display 
1e6c				call update_display 
1e6c				ld a, 100 
1e6c				call aDelayInMS 
1e6c				 
1e6c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e6c					call delay250ms 
1e6c				endif 
1e6c			.noskip:  
1e6c			 
1e6c			endif	 
1e6c			 
1e6c 2a 29 eb			ld hl,(cli_origptr) 
1e6f 22 2b eb			ld (cli_ptr),hl 
1e72			 
1e72			if DEBUG_FORTH_PARSE_KEY 
1e72						DMARK "KY5" 
1e72			endif 
1e72 c3 18 1e			jp .execpnword			; else go to next word 
1e75			 
1e75			.execendofdict:  
1e75			 
1e75			if DEBUG_FORTH_PARSE_KEY 
1e75						DMARK "KYe" 
1e75			endif 
1e75			if DEBUG_FORTH_PARSE_EXEC 
1e75				; see if disabled 
1e75			 
1e75				ld a, (os_view_disable) 
1e75				cp '*' 
1e75				jr z, .ispskip 
1e75			 
1e75				call clear_display 
1e75				call update_display 
1e75				call delay1s 
1e75				ld de, (cli_origptr) 
1e75				ld a, display_row_1 
1e75				call str_at_display 
1e75				 
1e75				ld de, .enddict 
1e75				ld a, display_row_3 
1e75				call str_at_display 
1e75				call update_display 
1e75				ld a, 100 
1e75				call aDelayInMS 
1e75				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e75				call delay1s 
1e75				call delay1s 
1e75				call delay1s 
1e75				endif 
1e75			.ispskip:  
1e75				 
1e75			endif	 
1e75			 
1e75			 
1e75			 
1e75				; if the word is not a keyword then must be a literal so push it to stack 
1e75			 
1e75			; push token to stack to end of word 
1e75			 
1e75				STACKFRAME ON $1efe $2f9f 
1e75				if DEBUG_STACK_IMB 
1e75					if ON 
1e75						exx 
1e75						ld de, $1efe 
1e75						ld a, d 
1e75						ld hl, curframe 
1e75						call hexout 
1e75						ld a, e 
1e75						ld hl, curframe+2 
1e75						call hexout 
1e75						ld hl, $1efe 
1e75						push hl 
1e75						ld hl, $2f9f 
1e75						push hl 
1e75						exx 
1e75					endif 
1e75				endif 
1e75			endm 
# End of macro STACKFRAME
1e75			 
1e75 2a 61 e6		ld hl,(os_tok_ptr) 
1e78 cd 6d 1b		call forth_apush 
1e7b			 
1e7b				STACKFRAMECHK ON $1efe $2f9f 
1e7b				if DEBUG_STACK_IMB 
1e7b					if ON 
1e7b						exx 
1e7b						ld hl, $2f9f 
1e7b						pop de   ; $2f9f 
1e7b						call cmp16 
1e7b						jr nz, .spnosame 
1e7b						ld hl, $1efe 
1e7b						pop de   ; $1efe 
1e7b						call cmp16 
1e7b						jr z, .spfrsame 
1e7b						.spnosame: call showsperror 
1e7b						.spfrsame: nop 
1e7b						exx 
1e7b					endif 
1e7b				endif 
1e7b			endm 
# End of macro STACKFRAMECHK
1e7b			 
1e7b			execnext: 
1e7b			 
1e7b			if DEBUG_FORTH_PARSE_KEY 
1e7b						DMARK "KY>" 
1e7b			endif 
1e7b			; move past token to next word 
1e7b			 
1e7b 2a 61 e6		ld hl, (os_tok_ptr) 
1e7e 3e 00		ld a, 0 
1e80 01 ff 00		ld bc, 255     ; input buffer size 
1e83 ed b1		cpir 
1e85			 
1e85			if DEBUG_FORTH_PARSE_KEY 
1e85						DMARK "KY!" 
1e85				CALLMONITOR 
1e85			endif	 
1e85			; TODO this might place hl on the null, so will need to forward on??? 
1e85			;inc hl   ; see if this gets onto the next item 
1e85			 
1e85			 
1e85			; TODO pass a pointer to the buffer to push 
1e85			; TODO call function to push 
1e85			 
1e85			; look for end of input 
1e85			 
1e85			;inc hl 
1e85			;ld a,(hl) 
1e85			;cp FORTH_END_BUFFER 
1e85			;ret z 
1e85			 
1e85			 
1e85 c3 fe 1d		jp exec1 
1e88			 
1e88			 
1e88			 
1e88			 
1e88			 
1e88			 
1e88			 
1e88			 
1e88			 
1e88			findnexttok: 
1e88			 
1e88				; hl is pointer to move 
1e88				; de is the token to locate 
1e88			 
1e88					if DEBUG_FORTH 
1e88						DMARK "NTK" 
1e88						CALLMONITOR 
1e88					endif 
1e88 d5				push de 
1e89			 
1e89			.fnt1:	 
1e89				; find first char of token to locate 
1e89			 
1e89 1a				ld a, (de) 
1e8a 4f				ld c,a 
1e8b 7e				ld a,(hl) 
1e8c cd 1e 10			call toUpper 
1e8f					if DEBUG_FORTH 
1e8f						DMARK "NT1" 
1e8f						CALLMONITOR 
1e8f					endif 
1e8f b9				cp c 
1e90			 
1e90 28 03			jr z, .fnt2cmpmorefirst	 
1e92			 
1e92				; first char not found move to next char 
1e92			 
1e92 23				inc hl 
1e93 18 f4			jr .fnt1 
1e95			 
1e95			.fnt2cmpmorefirst:	 
1e95				; first char of token found.  
1e95			 
1e95 e5				push hl     ; save start of token just in case it is the right one 
1e96 d9				exx 
1e97 e1				pop hl        ; save it to hl' 
1e98 d9				exx 
1e99			 
1e99			 
1e99			.fnt2cmpmore:	 
1e99				; compare the rest 
1e99				 
1e99 23				inc hl 
1e9a 13				inc de 
1e9b				 
1e9b 1a				ld a, (de) 
1e9c 4f				ld c,a 
1e9d 7e				ld a,(hl) 
1e9e cd 1e 10			call toUpper 
1ea1			 
1ea1					if DEBUG_FORTH 
1ea1						DMARK "NT2" 
1ea1						CALLMONITOR 
1ea1					endif 
1ea1				; c has the token to find char 
1ea1				; a has the mem to scan char 
1ea1			 
1ea1 b9				cp c 
1ea2 28 04			jr z,.fntmatch1 
1ea4			 
1ea4				; they are not the same 
1ea4			 
1ea4					if DEBUG_FORTH 
1ea4						DMARK "NT3" 
1ea4						CALLMONITOR 
1ea4					endif 
1ea4 d1				pop de	; reset de token to look for 
1ea5 d5				push de 
1ea6 18 e1			jr .fnt1 
1ea8				 
1ea8			.fntmatch1: 
1ea8			 
1ea8				; is the same char a null which means we might have a full hit? 
1ea8					if DEBUG_FORTH 
1ea8						DMARK "NT4" 
1ea8						CALLMONITOR 
1ea8					endif 
1ea8			 
1ea8 fe 00			cp 0 
1eaa 28 0b			jr z, .fntmatchyes 
1eac			 
1eac				; are we at the end of the token to find? 
1eac			 
1eac					if DEBUG_FORTH 
1eac						DMARK "NT5" 
1eac						CALLMONITOR 
1eac					endif 
1eac 3e 00			ld a, 0 
1eae b9				cp c 
1eaf			 
1eaf c2 99 1e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1eb2			 
1eb2					if DEBUG_FORTH 
1eb2						DMARK "NT6" 
1eb2						CALLMONITOR 
1eb2					endif 
1eb2				; token to find is exhusted but no match to stream 
1eb2			 
1eb2				; restore tok pointer and continue on 
1eb2 d1				pop de 
1eb3 d5				push de 
1eb4 c3 89 1e			jp .fnt1 
1eb7			 
1eb7			 
1eb7			.fntmatchyes: 
1eb7			 
1eb7				; hl now contains the end of the found token 
1eb7			 
1eb7				; get rid of saved token pointer to find 
1eb7			 
1eb7 d1				pop de 
1eb8			 
1eb8					if DEBUG_FORTH 
1eb8						DMARK "NT9" 
1eb8						CALLMONITOR 
1eb8					endif 
1eb8			 
1eb8				; hl will be on the null term so forward on 
1eb8			 
1eb8				; get back the saved start of the token 
1eb8			 
1eb8 d9				exx 
1eb9 e5				push hl     ; save start of token just in case it is the right one 
1eba d9				exx 
1ebb e1				pop hl        ; save it to hl 
1ebc			 
1ebc c9				ret 
1ebd			 
1ebd			 
1ebd			; LIST needs to find a specific token   
1ebd			; FORGET needs to find a spefici token 
1ebd			 
1ebd			; SAVE needs to find all tokens by flag 
1ebd			; WORDS just needs to scan through all  by flag 
1ebd			; UWORDS needs to scan through all by flag 
1ebd			 
1ebd			 
1ebd			; given hl as pointer to start of dict look up string 
1ebd			; return hl as pointer to start of word block 
1ebd			; or 0 if not found 
1ebd			 
1ebd			forth_find_tok: 
1ebd c9				ret 
1ebe			 
1ebe			; given hl as pointer to dict structure 
1ebe			; move to the next dict block structure 
1ebe			 
1ebe			forth_tok_next: 
1ebe				; hl now points to the address of the next word pointer  
1ebe				; TODO skip compiled symbol for now 
1ebe			;	push de 
1ebe 23				inc hl 
1ebf 5e				ld e, (hl) 
1ec0 23				inc hl 
1ec1 56				ld d, (hl) 
1ec2 23				inc hl 
1ec3			 
1ec3 eb				ex de,hl 
1ec4			if DEBUG_FORTH_PARSE_NEXTWORD 
1ec4				push bc 
1ec4				ld bc, (cli_nextword) 
1ec4						DMARK "NXW" 
1ec4				CALLMONITOR 
1ec4				pop bc 
1ec4			endif 
1ec4			;	pop de	 
1ec4 c9				ret 
1ec5			 
1ec5			 
1ec5			 
1ec5			; eof 
# End of file forth_parserv5.asm
1ec5				include "forth_wordsv4.asm" 
1ec5			 
1ec5			; the core word dictionary v4 
1ec5			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1ec5			 
1ec5			; this is a linked list for each of the system words used 
1ec5			; user defined words will follow the same format but will be in ram 
1ec5			 
1ec5			 
1ec5			; 
1ec5			; 
1ec5			; define linked list: 
1ec5			; 
1ec5			; 1. compiled byte op code 
1ec5			; 2. len of text word 
1ec5			; 3. text word 
1ec5			; 4. ptr to next dictionary word 
1ec5			; 5. asm, calls etc for the word 
1ec5			; 
1ec5			;  if 1 == 0 then last word in dict  
1ec5			;   
1ec5			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1ec5			;  
1ec5			;  
1ec5			; create basic standard set of words 
1ec5			; 
1ec5			;  
1ec5			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1ec5			; 2DUP 2DROP 2SWAP  
1ec5			; @ C@ - get byte  
1ec5			; ! C! - store byte 
1ec5			; 0< true if less than zero 
1ec5			; 0= true if zero 
1ec5			; < >  
1ec5			; = true if same 
1ec5			; variables 
1ec5			 
1ec5			 
1ec5			; Hardware specific words I may need 
1ec5			; 
1ec5			; IN OUT  
1ec5			; calls to key util functions 
1ec5			; calls to hardward abstraction stuff 
1ec5			; easy control of frame buffers and lcd i/o 
1ec5			; keyboard  
1ec5			 
1ec5			 
1ec5			;DICT: macro 
1ec5			; op_code, len, word, next 
1ec5			;    word: 
1ec5			;    db op_code 
1ec5			;    ds word zero term 
1ec5			;    dw next 
1ec5			;    endm 
1ec5			 
1ec5			 
1ec5			 
1ec5			 
1ec5			; op code 1 is a flag for user define words which are to be handled differently 
1ec5			 
1ec5			 
1ec5			; 
1ec5			; 
1ec5			;    TODO on entry to a word this should be the expected environment 
1ec5			;    hl - tos value if number then held, if string this is the ptr 
1ec5			;    de -  
1ec5			 
1ec5			 
1ec5			; opcode ranges 
1ec5			; 0 - end of word dict 
1ec5			; 255 - user define words 
1ec5			 
1ec5			sysdict: 
1ec5			include "forth_opcodes.asm" 
1ec5			; op codes for forth keywords 
1ec5			; free to use code 0  
1ec5				OPCODE_HEAP: equ  1 
1ec5				OPCODE_EXEC: equ 2 
1ec5				OPCODE_DUP: equ 3 
1ec5				OPCODE_SWAP: equ 4 
1ec5				OPCODE_COLN: equ 5 
1ec5				OPCODE_SCOLN: equ 6 
1ec5				OPCODE_DROP: equ 7 
1ec5				OPCODE_DUP2: equ 8 
1ec5				OPCODE_DROP2: equ 9 
1ec5				OPCODE_SWAP2: equ 10 
1ec5				OPCODE_AT: equ 11 
1ec5				OPCODE_CAT: equ 12 
1ec5				OPCODE_BANG: equ 13 
1ec5				OPCODE_CBANG: equ 14 
1ec5				OPCODE_SCALL: equ 15 
1ec5				OPCODE_DEPTH: equ 16 
1ec5				OPCODE_OVER: equ 17 
1ec5				OPCODE_PAUSE: equ 18 
1ec5				OPCODE_PAUSES: equ 19 
1ec5				OPCODE_ROT: equ 20 
1ec5			;free to reuse	OPCODE_WORDS: equ 21 
1ec5			        OPCODE_NOT: equ 21 
1ec5				OPCODE_UWORDS: equ 22 
1ec5				OPCODE_BP: equ 23 
1ec5				OPCODE_MONITOR: equ 24  
1ec5				OPCODE_MALLOC: equ 25 
1ec5				OPCODE_FREE: equ 26 
1ec5				OPCODE_LIST: equ 27 
1ec5				OPCODE_FORGET: equ 28 
1ec5				OPCODE_NOP: equ 29 
1ec5				OPCODE_COMO: equ 30 
1ec5				OPCODE_COMC: equ 31 
1ec5			;free to reuse	OPCODE_ENDCORE: equ 32 
1ec5				OPCODE_AFTERSOUND: equ 33 
1ec5				OPCODE_GP2: equ 34 
1ec5				OPCODE_GP3: equ 35 
1ec5				OPCODE_GP4: equ 36 
1ec5				OPCODE_SIN: equ 37 
1ec5				OPCODE_SOUT: equ 38 
1ec5				OPCODE_SPIO: equ 39 
1ec5				OPCODE_SPICEH: equ 40 
1ec5				OPCODE_SPIOb: equ 41 
1ec5				OPCODE_SPII: equ 42 
1ec5				OPCODE_SESEL: equ 43 
1ec5				OPCODE_CARTDEV: equ 44 
1ec5			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1ec5				OPCODE_FB: equ 46 
1ec5				OPCODE_EMIT: equ 47 
1ec5				OPCODE_DOTH: equ 48 
1ec5				OPCODE_DOTF: equ 49 
1ec5				OPCODE_DOT: equ 50 
1ec5				OPCODE_CLS: equ 51 
1ec5				OPCODE_DRAW: equ 52 
1ec5				OPCODE_DUMP: equ 53 
1ec5				OPCODE_CDUMP: equ 54 
1ec5				OPCODE_DAT: equ 55 
1ec5				OPCODE_HOME: equ 56 
1ec5				OPCODE_SPACE: equ 57 
1ec5				OPCODE_SPACES: equ 58 
1ec5				OPCODE_SCROLL: equ 59 
1ec5				OPCODE_ATQ: equ 60 
1ec5				OPCODE_AUTODSP: equ 61 
1ec5				OPCODE_MENU: equ 62 
1ec5			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1ec5				OPCODE_THEN: equ 64 
1ec5				OPCODE_ELSE: equ 65 
1ec5				OPCODE_DO: equ 66 
1ec5				OPCODE_LOOP: equ 67 
1ec5				OPCODE_I: equ 68 
1ec5				OPCODE_DLOOP: equ 69  
1ec5				OPCODE_REPEAT: equ 70  
1ec5				OPCODE_UNTIL: equ 71 
1ec5				OPCODE_ENDFLOW: equ 72 
1ec5				OPCODE_WAITK: equ 73 
1ec5				OPCODE_ACCEPT: equ 74 
1ec5				OPCODE_EDIT: equ 75 
1ec5			;free to reuse	OPCODE_ENDKEY: equ 76 
1ec5				OPCODE_LZERO: equ 77 
1ec5				OPCODE_TZERO: equ 78 
1ec5				OPCODE_LESS: equ 79 
1ec5				OPCODE_GT: equ 80 
1ec5				OPCODE_EQUAL: equ 81  
1ec5			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1ec5				OPCODE_NEG: equ 83 
1ec5				OPCODE_DIV: equ 84 
1ec5				OPCODE_MUL: equ 85 
1ec5				OPCODE_MIN: equ 86 
1ec5				OPCODE_MAX: equ 87 
1ec5				OPCODE_RND16: equ 88 
1ec5				OPCODE_RND8: equ 89 
1ec5				OPCODE_RND: equ 90 
1ec5			;free to reuse	OPCODE_ENDMATHS: equ 91  
1ec5				OPCODE_BYNAME: equ 92 
1ec5				OPCODE_DIR: equ 93 
1ec5				OPCODE_SAVE: equ 94 
1ec5				OPCODE_LOAD: equ 95 
1ec5				OPCODE_BSAVE: equ 96 
1ec5				OPCODE_BLOAD: equ 97 
1ec5				OPCODE_SEO: equ 98  
1ec5				OPCODE_SEI: equ 99 
1ec5				OPCODE_SFREE: equ 100 
1ec5				OPCODE_SIZE: equ 101 
1ec5				OPCODE_CREATE: equ 102 
1ec5				OPCODE_APPEND: equ 103 
1ec5				OPCODE_SDEL: equ 104 
1ec5				OPCODE_OPEN: equ 105 
1ec5				OPCODE_READ: equ 106 
1ec5				OPCODE_EOF: equ 106 
1ec5				OPCODE_FORMAT: equ 107 
1ec5				OPCODE_LABEL: equ 108 
1ec5				OPCODE_LABELS: equ 109 
1ec5			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1ec5				OPCODE_UPPER: equ 111 
1ec5				OPCODE_LOWER: equ 112 
1ec5				OPCODE_SUBSTR: equ 113 
1ec5				OPCODE_LEFT: equ 114 
1ec5				OPCODE_RIGHT: equ 115 
1ec5				OPCODE_STR2NUM: equ 116 
1ec5				OPCODE_NUM2STR: equ 117 
1ec5				OPCODE_CONCAT: equ 118 
1ec5				OPCODE_FIND: equ 119 
1ec5				OPCODE_LEN: equ 120 
1ec5				OPCODE_CHAR: equ 121 
1ec5			; free to reuse	OPCODE_STRLEN: equ 122 
1ec5			; free to reuse	OPCODE_ENDSTR: equ 123 
1ec5				OPCODE_V0S: equ 124 
1ec5				OPCODE_V0Q: equ 125 
1ec5				OPCODE_V1S: equ 126 
1ec5				OPCODE_V1Q: equ 127 
1ec5				OPCODE_V2S: equ 128 
1ec5				OPCODE_V2Q: equ 129 
1ec5				OPCODE_V3S: equ 130 
1ec5				OPCODE_V3Q: equ 131 
1ec5			;free to reuse	OPCODE_END: equ 132 
1ec5				OPCODE_ZDUP: equ 133 
1ec5			 
1ec5			; eof 
# End of file forth_opcodes.asm
1ec5			 
1ec5			include "forth_words_core.asm" 
1ec5			 
1ec5			; | ## Core Words 
1ec5			 
1ec5			;if MALLOC_4 
1ec5			 
1ec5			.HEAP: 
1ec5				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1ec5 15				db WORD_SYS_CORE+OPCODE_HEAP             
1ec6 04 1f			dw .EXEC            
1ec8 05				db 4 + 1 
1ec9 .. 00			db "HEAP",0              
1ece				endm 
# End of macro CWHEAD
1ece			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1ece			; | | u1 - Current number of bytes in the heap 
1ece			; | | u2 - Remaining bytes left on the heap 
1ece			; | |  
1ece			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1ece			 
1ece			 
1ece					if DEBUG_FORTH_WORDS_KEY 
1ece						DMARK "HEP" 
1ece f5				push af  
1ecf 3a e3 1e			ld a, (.dmark)  
1ed2 32 7a ee			ld (debug_mark),a  
1ed5 3a e4 1e			ld a, (.dmark+1)  
1ed8 32 7b ee			ld (debug_mark+1),a  
1edb 3a e5 1e			ld a, (.dmark+2)  
1ede 32 7c ee			ld (debug_mark+2),a  
1ee1 18 03			jr .pastdmark  
1ee3 ..			.dmark: db "HEP"  
1ee6 f1			.pastdmark: pop af  
1ee7			endm  
# End of macro DMARK
1ee7						CALLMONITOR 
1ee7 cd 77 14			call break_point_state  
1eea				endm  
# End of macro CALLMONITOR
1eea					endif 
1eea 2a 4c 59				ld hl, (free_list )      
1eed 11 51 59				ld de, heap_start 
1ef0			 
1ef0 ed 52				sbc hl, de  
1ef2			 
1ef2 cd 04 1a				call forth_push_numhl 
1ef5			 
1ef5			 
1ef5 ed 5b 4c 59			ld de, (free_list )      
1ef9 21 46 e3				ld hl, heap_end 
1efc			 
1efc ed 52				sbc hl, de 
1efe			 
1efe cd 04 1a				call forth_push_numhl 
1f01					 
1f01			 
1f01					 
1f01			 
1f01			 
1f01			 
1f01					NEXTW 
1f01 c3 6d 1d			jp macro_next 
1f04				endm 
# End of macro NEXTW
1f04			;endif 
1f04			 
1f04			.EXEC: 
1f04			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1f04			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
1f04			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1f04			;; > > 
1f04			;; > >   
1f04			;	STACKFRAME OFF $5efe $5f9f 
1f04			; 
1f04			;		if DEBUG_FORTH_WORDS_KEY 
1f04			;			DMARK "EXE" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			; 
1f04			;	FORTH_DSP_VALUEHL 
1f04			; 
1f04			;	FORTH_DSP_POP 
1f04			; 
1f04			;		if DEBUG_FORTH_WORDS 
1f04			;			DMARK "EX1" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			;;	ld e,(hl) 
1f04			;;	inc hl 
1f04			;;	ld d,(hl) 
1f04			;;	ex de,hl 
1f04			; 
1f04			;;		if DEBUG_FORTH_WORDS 
1f04			;;			DMARK "EX2" 
1f04			;;			CALLMONITOR 
1f04			;;		endif 
1f04			;	push hl 
1f04			; 
1f04			;	;ld a, 0 
1f04			;	;ld a, FORTH_END_BUFFER 
1f04			;	call strlenz 
1f04			;	inc hl   ; include zero term to copy 
1f04			;	inc hl   ; include term 
1f04			;	inc hl   ; include term 
1f04			;	ld b,0 
1f04			;	ld c,l 
1f04			;	pop hl 
1f04			;	ld de, execscratch 
1f04			;		if DEBUG_FORTH_WORDS 
1f04			;			DMARK "EX3" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			;	ldir 
1f04			; 
1f04			; 
1f04			;	ld hl, execscratch 
1f04			; 
1f04			;		if DEBUG_FORTH_WORDS 
1f04			;			DMARK "EXe" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			; 
1f04			;	call forthparse 
1f04			;	call forthexec 
1f04			;;	call forthexec_cleanup 
1f04			;;	call forthparse 
1f04			;;	call forthexec 
1f04			; 
1f04			;	STACKFRAMECHK OFF $5efe $5f9f 
1f04			; 
1f04			;	; an immediate word so no need to process any more words 
1f04			;	ret 
1f04			;	NEXTW 
1f04			 
1f04			; dead code - old version  
1f04			;	FORTH_RSP_NEXT 
1f04			 
1f04			;  
1f04			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f04			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f04			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f04			;	push hl 
1f04			;	push de 
1f04			;	push bc 
1f04			; 
1f04			; 
1f04			;		if DEBUG_FORTH_WORDS_KEY 
1f04			;			DMARK "EXR" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			; 
1f04			; 
1f04			; 
1f04			;	;v5 FORTH_DSP_VALUE 
1f04			;	FORTH_DSP_VALUEHL 
1f04			; 
1f04			;	; TODO do string type checks 
1f04			; 
1f04			;;v5	inc hl   ; skip type 
1f04			; 
1f04			;	push hl  ; source code  
1f04			;		if DEBUG_FORTH_WORDS 
1f04			;			DMARK "EX1" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			;	ld a, 0 
1f04			;	call strlent 
1f04			; 
1f04			;	inc hl 
1f04			;	inc hl 
1f04			;	inc hl 
1f04			;	inc hl 
1f04			; 
1f04			;	push hl    ; size 
1f04			; 
1f04			;		if DEBUG_FORTH_WORDS 
1f04			;			DMARK "EX2" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			;	call malloc 
1f04			; 
1f04			;	ex de, hl    ; de now contains malloc area 
1f04			;	pop bc   	; get byte count 
1f04			;	pop hl      ; get string to copy 
1f04			; 
1f04			;	push de     ; save malloc for free later 
1f04			; 
1f04			;		if DEBUG_FORTH_WORDS 
1f04			;			DMARK "EX3" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			;	ldir       ; duplicate string 
1f04			; 
1f04			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1f04			;	 
1f04			;	; TODO fix the parse would be better than this...  
1f04			;	ex de, hl 
1f04			;	dec hl 
1f04			;	ld a, 0 
1f04			;	ld (hl), a 
1f04			;	dec hl 
1f04			;	ld a, ' ' 
1f04			;	ld (hl), a 
1f04			;	dec hl 
1f04			;	ld (hl), a 
1f04			; 
1f04			;	dec hl 
1f04			;	ld (hl), a 
1f04			; 
1f04			; 
1f04			;	FORTH_DSP_POP  
1f04			; 
1f04			;	pop hl     
1f04			;	push hl    ; save malloc area 
1f04			; 
1f04			;		if DEBUG_FORTH_WORDS 
1f04			;			DMARK "EX4" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			; 
1f04			;	call forthparse 
1f04			;	call forthexec 
1f04			;	 
1f04			;	pop hl 
1f04			;	if DEBUG_FORTH_WORDS 
1f04			;		DMARK "EX5" 
1f04			;		CALLMONITOR 
1f04			;	endif 
1f04			; 
1f04			;	if FORTH_ENABLE_FREE 
1f04			;	call free 
1f04			;	endif 
1f04			; 
1f04			;	if DEBUG_FORTH_WORDS 
1f04			;		DMARK "EX6" 
1f04			;		CALLMONITOR 
1f04			;	endif 
1f04			; 
1f04			;	pop bc 
1f04			;	pop de 
1f04			;	pop hl 
1f04			;;	FORTH_RSP_POP	  
1f04			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1f04			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1f04			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1f04			; 
1f04			;	if DEBUG_FORTH_WORDS 
1f04			;		DMARK "EX7" 
1f04			;		CALLMONITOR 
1f04			;	endif 
1f04			;	NEXTW 
1f04			 
1f04			;.STKEXEC: 
1f04			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1f04			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
1f04			; 
1f04			; 
1f04			;		if DEBUG_FORTH_WORDS_KEY 
1f04			;			DMARK "STX" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			; 
1f04			;	FORTH_DSP_VALUEHL 
1f04			; 
1f04			;	ld (store_tmp1), hl    ; count 
1f04			; 
1f04			;	FORTH_DSP_POP 
1f04			;.stkexec1: 
1f04			;	ld hl, (store_tmp1)   ; count 
1f04			;	ld a, 0 
1f04			;	cp l 
1f04			;	ret z 
1f04			; 
1f04			;	dec hl 
1f04			;	ld (store_tmp1), hl    ; count 
1f04			;	 
1f04			;	FORTH_DSP_VALUEHL 
1f04			;	push hl 
1f04			;	 
1f04			;		if DEBUG_FORTH_WORDS 
1f04			;			DMARK "EXp" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			;	FORTH_DSP_POP 
1f04			; 
1f04			;	call strlenz 
1f04			;	inc hl   ; include zero term to copy 
1f04			;	inc hl   ; include zero term to copy 
1f04			;	inc hl   ; include zero term to copy 
1f04			;	ld b,0 
1f04			;	ld c,l 
1f04			;	pop hl 
1f04			;	ld de, execscratch 
1f04			;		if DEBUG_FORTH_WORDS 
1f04			;			DMARK "EX3" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			;	ldir 
1f04			; 
1f04			; 
1f04			;	ld hl, execscratch 
1f04			; 
1f04			;		if DEBUG_FORTH_WORDS 
1f04			;			DMARK "EXP" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			; 
1f04			;	call forthparse 
1f04			;	ld hl, execscratch 
1f04			;		if DEBUG_FORTH_WORDS 
1f04			;			DMARK "EXx" 
1f04			;			CALLMONITOR 
1f04			;		endif 
1f04			;	call forthexec 
1f04			; 
1f04			;	jp .stkexec1 
1f04			; 
1f04			;	ret 
1f04			 
1f04			 
1f04			.DUP: 
1f04				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1f04 17				db WORD_SYS_CORE+OPCODE_DUP             
1f05 7a 1f			dw .ZDUP            
1f07 04				db 3 + 1 
1f08 .. 00			db "DUP",0              
1f0c				endm 
# End of macro CWHEAD
1f0c			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1f0c			 
1f0c					if DEBUG_FORTH_WORDS_KEY 
1f0c						DMARK "DUP" 
1f0c f5				push af  
1f0d 3a 21 1f			ld a, (.dmark)  
1f10 32 7a ee			ld (debug_mark),a  
1f13 3a 22 1f			ld a, (.dmark+1)  
1f16 32 7b ee			ld (debug_mark+1),a  
1f19 3a 23 1f			ld a, (.dmark+2)  
1f1c 32 7c ee			ld (debug_mark+2),a  
1f1f 18 03			jr .pastdmark  
1f21 ..			.dmark: db "DUP"  
1f24 f1			.pastdmark: pop af  
1f25			endm  
# End of macro DMARK
1f25						CALLMONITOR 
1f25 cd 77 14			call break_point_state  
1f28				endm  
# End of macro CALLMONITOR
1f28					endif 
1f28			 
1f28					FORTH_DSP 
1f28 cd c1 1b			call macro_forth_dsp 
1f2b				endm 
# End of macro FORTH_DSP
1f2b			 
1f2b 7e					ld a, (HL) 
1f2c fe 01				cp DS_TYPE_STR 
1f2e 20 25				jr nz, .dupinum 
1f30			 
1f30					; push another string 
1f30			 
1f30					FORTH_DSP_VALUEHL     		 
1f30 cd fb 1b			call macro_dsp_valuehl 
1f33				endm 
# End of macro FORTH_DSP_VALUEHL
1f33			 
1f33				if DEBUG_FORTH_WORDS 
1f33					DMARK "DUs" 
1f33 f5				push af  
1f34 3a 48 1f			ld a, (.dmark)  
1f37 32 7a ee			ld (debug_mark),a  
1f3a 3a 49 1f			ld a, (.dmark+1)  
1f3d 32 7b ee			ld (debug_mark+1),a  
1f40 3a 4a 1f			ld a, (.dmark+2)  
1f43 32 7c ee			ld (debug_mark+2),a  
1f46 18 03			jr .pastdmark  
1f48 ..			.dmark: db "DUs"  
1f4b f1			.pastdmark: pop af  
1f4c			endm  
# End of macro DMARK
1f4c					CALLMONITOR 
1f4c cd 77 14			call break_point_state  
1f4f				endm  
# End of macro CALLMONITOR
1f4f				endif 
1f4f cd 72 1a				call forth_push_str 
1f52			 
1f52					NEXTW 
1f52 c3 6d 1d			jp macro_next 
1f55				endm 
# End of macro NEXTW
1f55			 
1f55			 
1f55			.dupinum: 
1f55					 
1f55			 
1f55			 
1f55					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f55 cd fb 1b			call macro_dsp_valuehl 
1f58				endm 
# End of macro FORTH_DSP_VALUEHL
1f58			 
1f58				; TODO add floating point number detection 
1f58			 
1f58				if DEBUG_FORTH_WORDS 
1f58					DMARK "DUi" 
1f58 f5				push af  
1f59 3a 6d 1f			ld a, (.dmark)  
1f5c 32 7a ee			ld (debug_mark),a  
1f5f 3a 6e 1f			ld a, (.dmark+1)  
1f62 32 7b ee			ld (debug_mark+1),a  
1f65 3a 6f 1f			ld a, (.dmark+2)  
1f68 32 7c ee			ld (debug_mark+2),a  
1f6b 18 03			jr .pastdmark  
1f6d ..			.dmark: db "DUi"  
1f70 f1			.pastdmark: pop af  
1f71			endm  
# End of macro DMARK
1f71					CALLMONITOR 
1f71 cd 77 14			call break_point_state  
1f74				endm  
# End of macro CALLMONITOR
1f74				endif 
1f74			 
1f74 cd 04 1a				call forth_push_numhl 
1f77					NEXTW 
1f77 c3 6d 1d			jp macro_next 
1f7a				endm 
# End of macro NEXTW
1f7a			.ZDUP: 
1f7a				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1f7a 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1f7b b2 1f			dw .SWAP            
1f7d 05				db 4 + 1 
1f7e .. 00			db "?DUP",0              
1f83				endm 
# End of macro CWHEAD
1f83			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1f83			 
1f83					if DEBUG_FORTH_WORDS_KEY 
1f83						DMARK "qDU" 
1f83 f5				push af  
1f84 3a 98 1f			ld a, (.dmark)  
1f87 32 7a ee			ld (debug_mark),a  
1f8a 3a 99 1f			ld a, (.dmark+1)  
1f8d 32 7b ee			ld (debug_mark+1),a  
1f90 3a 9a 1f			ld a, (.dmark+2)  
1f93 32 7c ee			ld (debug_mark+2),a  
1f96 18 03			jr .pastdmark  
1f98 ..			.dmark: db "qDU"  
1f9b f1			.pastdmark: pop af  
1f9c			endm  
# End of macro DMARK
1f9c						CALLMONITOR 
1f9c cd 77 14			call break_point_state  
1f9f				endm  
# End of macro CALLMONITOR
1f9f					endif 
1f9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f9f cd fb 1b			call macro_dsp_valuehl 
1fa2				endm 
# End of macro FORTH_DSP_VALUEHL
1fa2			 
1fa2 e5					push hl 
1fa3			 
1fa3					; is it a zero? 
1fa3			 
1fa3 3e 00				ld a, 0 
1fa5 84					add h 
1fa6 85					add l 
1fa7			 
1fa7 e1					pop hl 
1fa8			 
1fa8 fe 00				cp 0 
1faa 28 03				jr z, .dup2orig 
1fac			 
1fac			 
1fac cd 04 1a				call forth_push_numhl 
1faf			 
1faf			 
1faf				; TODO add floating point number detection 
1faf			 
1faf			.dup2orig: 
1faf			 
1faf					NEXTW 
1faf c3 6d 1d			jp macro_next 
1fb2				endm 
# End of macro NEXTW
1fb2			.SWAP: 
1fb2				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1fb2 18				db WORD_SYS_CORE+OPCODE_SWAP             
1fb3 f1 1f			dw .COLN            
1fb5 05				db 4 + 1 
1fb6 .. 00			db "SWAP",0              
1fbb				endm 
# End of macro CWHEAD
1fbb			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1fbb					if DEBUG_FORTH_WORDS_KEY 
1fbb						DMARK "SWP" 
1fbb f5				push af  
1fbc 3a d0 1f			ld a, (.dmark)  
1fbf 32 7a ee			ld (debug_mark),a  
1fc2 3a d1 1f			ld a, (.dmark+1)  
1fc5 32 7b ee			ld (debug_mark+1),a  
1fc8 3a d2 1f			ld a, (.dmark+2)  
1fcb 32 7c ee			ld (debug_mark+2),a  
1fce 18 03			jr .pastdmark  
1fd0 ..			.dmark: db "SWP"  
1fd3 f1			.pastdmark: pop af  
1fd4			endm  
# End of macro DMARK
1fd4						CALLMONITOR 
1fd4 cd 77 14			call break_point_state  
1fd7				endm  
# End of macro CALLMONITOR
1fd7					endif 
1fd7			 
1fd7					FORTH_DSP_VALUEHL 
1fd7 cd fb 1b			call macro_dsp_valuehl 
1fda				endm 
# End of macro FORTH_DSP_VALUEHL
1fda e5					push hl     ; w2 
1fdb			 
1fdb					FORTH_DSP_POP 
1fdb cd b3 1c			call macro_forth_dsp_pop 
1fde				endm 
# End of macro FORTH_DSP_POP
1fde			 
1fde					FORTH_DSP_VALUEHL 
1fde cd fb 1b			call macro_dsp_valuehl 
1fe1				endm 
# End of macro FORTH_DSP_VALUEHL
1fe1			 
1fe1					FORTH_DSP_POP 
1fe1 cd b3 1c			call macro_forth_dsp_pop 
1fe4				endm 
# End of macro FORTH_DSP_POP
1fe4			 
1fe4 d1					pop de     ; w2	, hl = w1 
1fe5			 
1fe5 eb					ex de, hl 
1fe6 d5					push de 
1fe7			 
1fe7 cd 04 1a				call forth_push_numhl 
1fea			 
1fea e1					pop hl 
1feb			 
1feb cd 04 1a				call forth_push_numhl 
1fee					 
1fee			 
1fee					NEXTW 
1fee c3 6d 1d			jp macro_next 
1ff1				endm 
# End of macro NEXTW
1ff1			.COLN: 
1ff1				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1ff1 19				db WORD_SYS_CORE+OPCODE_COLN             
1ff2 7d 21			dw .SCOLN            
1ff4 02				db 1 + 1 
1ff5 .. 00			db ":",0              
1ff7				endm 
# End of macro CWHEAD
1ff7			; | : ( -- )         Create new word | DONE 
1ff7			 
1ff7					if DEBUG_FORTH_WORDS_KEY 
1ff7						DMARK "CLN" 
1ff7 f5				push af  
1ff8 3a 0c 20			ld a, (.dmark)  
1ffb 32 7a ee			ld (debug_mark),a  
1ffe 3a 0d 20			ld a, (.dmark+1)  
2001 32 7b ee			ld (debug_mark+1),a  
2004 3a 0e 20			ld a, (.dmark+2)  
2007 32 7c ee			ld (debug_mark+2),a  
200a 18 03			jr .pastdmark  
200c ..			.dmark: db "CLN"  
200f f1			.pastdmark: pop af  
2010			endm  
# End of macro DMARK
2010						CALLMONITOR 
2010 cd 77 14			call break_point_state  
2013				endm  
# End of macro CALLMONITOR
2013					endif 
2013				STACKFRAME OFF $8efe $989f 
2013				if DEBUG_STACK_IMB 
2013					if OFF 
2013						exx 
2013						ld de, $8efe 
2013						ld a, d 
2013						ld hl, curframe 
2013						call hexout 
2013						ld a, e 
2013						ld hl, curframe+2 
2013						call hexout 
2013						ld hl, $8efe 
2013						push hl 
2013						ld hl, $989f 
2013						push hl 
2013						exx 
2013					endif 
2013				endif 
2013			endm 
# End of macro STACKFRAME
2013				; get parser buffer length  of new word 
2013			 
2013				 
2013			 
2013					; move tok past this to start of name defintition 
2013					; TODO get word to define 
2013					; TODO Move past word token 
2013					; TODO get length of string up to the ';' 
2013			 
2013 2a 61 e6			ld hl, (os_tok_ptr) 
2016 23				inc hl 
2017 23				inc hl 
2018			 
2018 3e 3b			ld a, ';' 
201a cd 32 10			call strlent 
201d			 
201d 7d				ld a,l 
201e 32 5c e3			ld (os_new_parse_len), a 
2021			 
2021			 
2021			if DEBUG_FORTH_UWORD 
2021 ed 5b 61 e6		ld de, (os_tok_ptr) 
2025						DMARK ":01" 
2025 f5				push af  
2026 3a 3a 20			ld a, (.dmark)  
2029 32 7a ee			ld (debug_mark),a  
202c 3a 3b 20			ld a, (.dmark+1)  
202f 32 7b ee			ld (debug_mark+1),a  
2032 3a 3c 20			ld a, (.dmark+2)  
2035 32 7c ee			ld (debug_mark+2),a  
2038 18 03			jr .pastdmark  
203a ..			.dmark: db ":01"  
203d f1			.pastdmark: pop af  
203e			endm  
# End of macro DMARK
203e				CALLMONITOR 
203e cd 77 14			call break_point_state  
2041				endm  
# End of macro CALLMONITOR
2041			endif 
2041			 
2041			; 
2041			;  new word memory layout: 
2041			;  
2041			;    : adg 6666 ;  
2041			; 
2041			;    db   1     ; user defined word  
2041 23				inc hl    
2042			;    dw   sysdict 
2042 23				inc hl 
2043 23				inc hl 
2044			;    db <word len>+1 (for null) 
2044 23				inc hl 
2045			;    db .... <word> 
2045			; 
2045			 
2045 23				inc hl    ; some extras for the word preamble before the above 
2046 23				inc hl 
2047 23				inc hl 
2048 23				inc hl 
2049 23				inc hl 
204a 23				inc hl 
204b 23				inc hl  
204c 23				inc hl 
204d 23				inc hl 
204e 23				inc hl 
204f 23				inc hl 
2050 23				inc hl 
2051 23				inc hl 
2052 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2053			;       exec word buffer 
2053			;	<ptr word>   
2053 23				inc hl 
2054 23				inc hl 
2055			;       <word list><null term> 7F final term 
2055			 
2055			 
2055			if DEBUG_FORTH_UWORD 
2055						DMARK ":02" 
2055 f5				push af  
2056 3a 6a 20			ld a, (.dmark)  
2059 32 7a ee			ld (debug_mark),a  
205c 3a 6b 20			ld a, (.dmark+1)  
205f 32 7b ee			ld (debug_mark+1),a  
2062 3a 6c 20			ld a, (.dmark+2)  
2065 32 7c ee			ld (debug_mark+2),a  
2068 18 03			jr .pastdmark  
206a ..			.dmark: db ":02"  
206d f1			.pastdmark: pop af  
206e			endm  
# End of macro DMARK
206e				CALLMONITOR 
206e cd 77 14			call break_point_state  
2071				endm  
# End of macro CALLMONITOR
2071			endif 
2071			 
2071				 
2071					; malloc the size 
2071			 
2071 cd 90 10				call malloc 
2074 22 5e e3				ld (os_new_malloc), hl     ; save malloc start 
2077			 
2077			;    db   1     ; user defined word  
2077 3e 01				ld a, WORD_SYS_UWORD  
2079 77					ld (hl), a 
207a				 
207a 23				inc hl    
207b			;    dw   sysdict 
207b 11 c5 1e			ld de, sysdict       ; continue on with the scan to the system dict 
207e 73				ld (hl), e 
207f 23				inc hl 
2080 72				ld (hl), d 
2081 23				inc hl 
2082			 
2082			 
2082			;    Setup dict word 
2082			 
2082 23				inc hl 
2083 22 58 e3			ld (os_new_work_ptr), hl     ; save start of dict word  
2086			 
2086				; 1. get length of dict word 
2086			 
2086			 
2086 2a 61 e6			ld hl, (os_tok_ptr) 
2089 23				inc hl 
208a 23				inc hl    ; position to start of dict word 
208b 3e 00			ld a, 0 
208d cd 32 10			call strlent 
2090			 
2090			 
2090 23				inc hl    ; to include null??? 
2091			 
2091				; write length of dict word 
2091			 
2091 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2095 1b				dec de 
2096 eb				ex de, hl 
2097 73				ld (hl), e 
2098 eb				ex de, hl 
2099			 
2099				 
2099			 
2099				; copy  
2099 4d				ld c, l 
209a 06 00			ld b, 0 
209c ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
20a0 2a 61 e6			ld hl, (os_tok_ptr) 
20a3 23				inc hl 
20a4 23				inc hl    ; position to start of dict word 
20a5				 
20a5			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
20a5				 
20a5				; TODO need to convert word to upper case 
20a5			 
20a5			ucasetok:	 
20a5 7e				ld a,(hl) 
20a6 cd 1e 10			call toUpper 
20a9 77				ld (hl),a 
20aa ed a0			ldi 
20ac f2 a5 20		 	jp p, ucasetok 
20af			 
20af			 
20af			 
20af				; de now points to start of where the word body code should be placed 
20af ed 53 58 e3		ld (os_new_work_ptr), de 
20b3				; hl now points to the words to throw at forthexec which needs to be copied 
20b3 22 56 e3			ld (os_new_src_ptr), hl 
20b6			 
20b6				; TODO add 'call to forthexec' 
20b6			 
20b6			if DEBUG_FORTH_UWORD 
20b6 c5				push bc 
20b7 ed 4b 5e e3		ld bc, (os_new_malloc) 
20bb						DMARK ":0x" 
20bb f5				push af  
20bc 3a d0 20			ld a, (.dmark)  
20bf 32 7a ee			ld (debug_mark),a  
20c2 3a d1 20			ld a, (.dmark+1)  
20c5 32 7b ee			ld (debug_mark+1),a  
20c8 3a d2 20			ld a, (.dmark+2)  
20cb 32 7c ee			ld (debug_mark+2),a  
20ce 18 03			jr .pastdmark  
20d0 ..			.dmark: db ":0x"  
20d3 f1			.pastdmark: pop af  
20d4			endm  
# End of macro DMARK
20d4				CALLMONITOR 
20d4 cd 77 14			call break_point_state  
20d7				endm  
# End of macro CALLMONITOR
20d7 c1				pop bc 
20d8			endif 
20d8			 
20d8			 
20d8				; create word preamble which should be: 
20d8			 
20d8			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
20d8			 
20d8				;    ld hl, <word code> 
20d8				;    jp user_exec 
20d8			        ;    <word code bytes> 
20d8			 
20d8			 
20d8			;	inc de     ; TODO ??? or are we already past the word's null 
20d8 eb				ex de, hl 
20d9			 
20d9 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
20db			 
20db 23				inc hl 
20dc 22 52 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
20df 23				inc hl 
20e0			 
20e0 23				inc hl 
20e1 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
20e3			 
20e3 01 cd 44			ld bc, user_exec 
20e6 23				inc hl 
20e7 71				ld (hl), c     ; poke address of user_exec 
20e8 23				inc hl 
20e9 70				ld (hl), b     
20ea			 ; 
20ea			;	inc hl 
20ea			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
20ea			; 
20ea			; 
20ea			;	ld bc, macro_forth_rsp_next 
20ea			;	inc hl 
20ea			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
20ea			;	inc hl 
20ea			;	ld (hl), b     
20ea			 ; 
20ea			;	inc hl 
20ea			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
20ea			; 
20ea			; 
20ea			;	inc hl 
20ea			;	ld bc, forthexec 
20ea			;	ld (hl), c     ; poke address of forthexec 
20ea			;	inc hl 
20ea			;	ld (hl), b      
20ea			; 
20ea			;	inc hl 
20ea			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
20ea			; 
20ea			;	ld bc, user_dict_next 
20ea			;	inc hl 
20ea			;	ld (hl), c     ; poke address of forthexec 
20ea			;	inc hl 
20ea			;	ld (hl), b      
20ea			 
20ea				; hl is now where we need to copy the word byte data to save this 
20ea			 
20ea 23				inc hl 
20eb 22 54 e3			ld (os_new_exec), hl 
20ee				 
20ee				; copy definition 
20ee			 
20ee eb				ex de, hl 
20ef			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
20ef			;	inc de    ; skip the PC for this parse 
20ef 3a 5c e3			ld a, (os_new_parse_len) 
20f2 4f				ld c, a 
20f3 06 00			ld b, 0 
20f5 ed b0			ldir		 ; copy defintion 
20f7			 
20f7			 
20f7				; poke the address of where the new word bytes live for forthexec 
20f7			 
20f7 2a 52 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
20fa			 
20fa ed 5b 54 e3		ld de, (os_new_exec)      
20fe				 
20fe 73				ld (hl), e 
20ff 23				inc hl 
2100 72				ld (hl), d 
2101			 
2101					; TODO copy last user dict word next link to this word 
2101					; TODO update last user dict word to point to this word 
2101			; 
2101			; hl f923 de 812a ; bc 811a 
2101			 
2101			if DEBUG_FORTH_UWORD 
2101 c5				push bc 
2102 ed 4b 5e e3		ld bc, (os_new_malloc) 
2106						DMARK ":0A" 
2106 f5				push af  
2107 3a 1b 21			ld a, (.dmark)  
210a 32 7a ee			ld (debug_mark),a  
210d 3a 1c 21			ld a, (.dmark+1)  
2110 32 7b ee			ld (debug_mark+1),a  
2113 3a 1d 21			ld a, (.dmark+2)  
2116 32 7c ee			ld (debug_mark+2),a  
2119 18 03			jr .pastdmark  
211b ..			.dmark: db ":0A"  
211e f1			.pastdmark: pop af  
211f			endm  
# End of macro DMARK
211f				CALLMONITOR 
211f cd 77 14			call break_point_state  
2122				endm  
# End of macro CALLMONITOR
2122 c1				pop bc 
2123			endif 
2123			if DEBUG_FORTH_UWORD 
2123 c5				push bc 
2124 ed 4b 5e e3		ld bc, (os_new_malloc) 
2128 03				inc bc 
2129 03				inc bc 
212a 03				inc bc 
212b 03				inc bc 
212c 03				inc bc 
212d 03				inc bc 
212e 03				inc bc 
212f 03				inc bc 
2130			 
2130						DMARK ":0B" 
2130 f5				push af  
2131 3a 45 21			ld a, (.dmark)  
2134 32 7a ee			ld (debug_mark),a  
2137 3a 46 21			ld a, (.dmark+1)  
213a 32 7b ee			ld (debug_mark+1),a  
213d 3a 47 21			ld a, (.dmark+2)  
2140 32 7c ee			ld (debug_mark+2),a  
2143 18 03			jr .pastdmark  
2145 ..			.dmark: db ":0B"  
2148 f1			.pastdmark: pop af  
2149			endm  
# End of macro DMARK
2149				CALLMONITOR 
2149 cd 77 14			call break_point_state  
214c				endm  
# End of macro CALLMONITOR
214c c1				pop bc 
214d			endif 
214d			 
214d			; update word dict linked list for new word 
214d			 
214d			 
214d 2a 5d e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2150 23			inc hl     ; move to next work linked list ptr 
2151			 
2151 ed 5b 5e e3	ld de, (os_new_malloc)		 ; new next word 
2155 73			ld (hl), e 
2156 23			inc hl 
2157 72			ld (hl), d 
2158			 
2158			if DEBUG_FORTH_UWORD 
2158 ed 4b 5d e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
215c			endif 
215c			 
215c ed 53 5d e6	ld (os_last_new_uword), de      ; update last new uword ptr 
2160			 
2160			 
2160			if DEBUG_FORTH_UWORD 
2160						DMARK ":0+" 
2160 f5				push af  
2161 3a 75 21			ld a, (.dmark)  
2164 32 7a ee			ld (debug_mark),a  
2167 3a 76 21			ld a, (.dmark+1)  
216a 32 7b ee			ld (debug_mark+1),a  
216d 3a 77 21			ld a, (.dmark+2)  
2170 32 7c ee			ld (debug_mark+2),a  
2173 18 03			jr .pastdmark  
2175 ..			.dmark: db ":0+"  
2178 f1			.pastdmark: pop af  
2179			endm  
# End of macro DMARK
2179				CALLMONITOR 
2179 cd 77 14			call break_point_state  
217c				endm  
# End of macro CALLMONITOR
217c			endif 
217c			 
217c				STACKFRAMECHK OFF $8efe $989f 
217c				if DEBUG_STACK_IMB 
217c					if OFF 
217c						exx 
217c						ld hl, $989f 
217c						pop de   ; $989f 
217c						call cmp16 
217c						jr nz, .spnosame 
217c						ld hl, $8efe 
217c						pop de   ; $8efe 
217c						call cmp16 
217c						jr z, .spfrsame 
217c						.spnosame: call showsperror 
217c						.spfrsame: nop 
217c						exx 
217c					endif 
217c				endif 
217c			endm 
# End of macro STACKFRAMECHK
217c			 
217c c9			ret    ; dont process any remaining parser tokens as they form new word 
217d			 
217d			 
217d			 
217d			 
217d			;		NEXT 
217d			.SCOLN: 
217d			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
217d 06				db OPCODE_SCOLN 
217e c9 21			dw .DROP 
2180 02				db 2 
2181 .. 00			db ";",0           
2183			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2183					if DEBUG_FORTH_WORDS_KEY 
2183						DMARK "SCN" 
2183 f5				push af  
2184 3a 98 21			ld a, (.dmark)  
2187 32 7a ee			ld (debug_mark),a  
218a 3a 99 21			ld a, (.dmark+1)  
218d 32 7b ee			ld (debug_mark+1),a  
2190 3a 9a 21			ld a, (.dmark+2)  
2193 32 7c ee			ld (debug_mark+2),a  
2196 18 03			jr .pastdmark  
2198 ..			.dmark: db "SCN"  
219b f1			.pastdmark: pop af  
219c			endm  
# End of macro DMARK
219c						CALLMONITOR 
219c cd 77 14			call break_point_state  
219f				endm  
# End of macro CALLMONITOR
219f					endif 
219f					FORTH_RSP_TOS 
219f cd c2 19			call macro_forth_rsp_tos 
21a2				endm 
# End of macro FORTH_RSP_TOS
21a2 e5					push hl 
21a3					FORTH_RSP_POP 
21a3 cd cc 19			call macro_forth_rsp_pop 
21a6				endm 
# End of macro FORTH_RSP_POP
21a6 e1					pop hl 
21a7			;		ex de,hl 
21a7 22 61 e6				ld (os_tok_ptr),hl 
21aa			 
21aa			if DEBUG_FORTH_UWORD 
21aa						DMARK "SCL" 
21aa f5				push af  
21ab 3a bf 21			ld a, (.dmark)  
21ae 32 7a ee			ld (debug_mark),a  
21b1 3a c0 21			ld a, (.dmark+1)  
21b4 32 7b ee			ld (debug_mark+1),a  
21b7 3a c1 21			ld a, (.dmark+2)  
21ba 32 7c ee			ld (debug_mark+2),a  
21bd 18 03			jr .pastdmark  
21bf ..			.dmark: db "SCL"  
21c2 f1			.pastdmark: pop af  
21c3			endm  
# End of macro DMARK
21c3				CALLMONITOR 
21c3 cd 77 14			call break_point_state  
21c6				endm  
# End of macro CALLMONITOR
21c6			endif 
21c6					NEXTW 
21c6 c3 6d 1d			jp macro_next 
21c9				endm 
# End of macro NEXTW
21c9			 
21c9			.DROP: 
21c9				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
21c9 1b				db WORD_SYS_CORE+OPCODE_DROP             
21ca f4 21			dw .DUP2            
21cc 05				db 4 + 1 
21cd .. 00			db "DROP",0              
21d2				endm 
# End of macro CWHEAD
21d2			; | DROP ( w -- )   drop the TOS item   | DONE 
21d2					if DEBUG_FORTH_WORDS_KEY 
21d2						DMARK "DRP" 
21d2 f5				push af  
21d3 3a e7 21			ld a, (.dmark)  
21d6 32 7a ee			ld (debug_mark),a  
21d9 3a e8 21			ld a, (.dmark+1)  
21dc 32 7b ee			ld (debug_mark+1),a  
21df 3a e9 21			ld a, (.dmark+2)  
21e2 32 7c ee			ld (debug_mark+2),a  
21e5 18 03			jr .pastdmark  
21e7 ..			.dmark: db "DRP"  
21ea f1			.pastdmark: pop af  
21eb			endm  
# End of macro DMARK
21eb						CALLMONITOR 
21eb cd 77 14			call break_point_state  
21ee				endm  
# End of macro CALLMONITOR
21ee					endif 
21ee					FORTH_DSP_POP 
21ee cd b3 1c			call macro_forth_dsp_pop 
21f1				endm 
# End of macro FORTH_DSP_POP
21f1					NEXTW 
21f1 c3 6d 1d			jp macro_next 
21f4				endm 
# End of macro NEXTW
21f4			.DUP2: 
21f4				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
21f4 1c				db WORD_SYS_CORE+OPCODE_DUP2             
21f5 39 22			dw .DROP2            
21f7 05				db 4 + 1 
21f8 .. 00			db "2DUP",0              
21fd				endm 
# End of macro CWHEAD
21fd			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
21fd					if DEBUG_FORTH_WORDS_KEY 
21fd						DMARK "2DU" 
21fd f5				push af  
21fe 3a 12 22			ld a, (.dmark)  
2201 32 7a ee			ld (debug_mark),a  
2204 3a 13 22			ld a, (.dmark+1)  
2207 32 7b ee			ld (debug_mark+1),a  
220a 3a 14 22			ld a, (.dmark+2)  
220d 32 7c ee			ld (debug_mark+2),a  
2210 18 03			jr .pastdmark  
2212 ..			.dmark: db "2DU"  
2215 f1			.pastdmark: pop af  
2216			endm  
# End of macro DMARK
2216						CALLMONITOR 
2216 cd 77 14			call break_point_state  
2219				endm  
# End of macro CALLMONITOR
2219					endif 
2219					FORTH_DSP_VALUEHL 
2219 cd fb 1b			call macro_dsp_valuehl 
221c				endm 
# End of macro FORTH_DSP_VALUEHL
221c e5					push hl      ; 2 
221d			 
221d					FORTH_DSP_POP 
221d cd b3 1c			call macro_forth_dsp_pop 
2220				endm 
# End of macro FORTH_DSP_POP
2220					 
2220					FORTH_DSP_VALUEHL 
2220 cd fb 1b			call macro_dsp_valuehl 
2223				endm 
# End of macro FORTH_DSP_VALUEHL
2223			;		push hl      ; 1 
2223			 
2223					FORTH_DSP_POP 
2223 cd b3 1c			call macro_forth_dsp_pop 
2226				endm 
# End of macro FORTH_DSP_POP
2226			 
2226			;		pop hl       ; 1 
2226 d1					pop de       ; 2 
2227			 
2227 cd 04 1a				call forth_push_numhl 
222a eb					ex de, hl 
222b cd 04 1a				call forth_push_numhl 
222e			 
222e					 
222e eb					ex de, hl 
222f			 
222f cd 04 1a				call forth_push_numhl 
2232 eb					ex de, hl 
2233 cd 04 1a				call forth_push_numhl 
2236			 
2236			 
2236					NEXTW 
2236 c3 6d 1d			jp macro_next 
2239				endm 
# End of macro NEXTW
2239			.DROP2: 
2239				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2239 1d				db WORD_SYS_CORE+OPCODE_DROP2             
223a 68 22			dw .SWAP2            
223c 06				db 5 + 1 
223d .. 00			db "2DROP",0              
2243				endm 
# End of macro CWHEAD
2243			; | 2DROP ( w w -- )    Double drop | DONE 
2243					if DEBUG_FORTH_WORDS_KEY 
2243						DMARK "2DR" 
2243 f5				push af  
2244 3a 58 22			ld a, (.dmark)  
2247 32 7a ee			ld (debug_mark),a  
224a 3a 59 22			ld a, (.dmark+1)  
224d 32 7b ee			ld (debug_mark+1),a  
2250 3a 5a 22			ld a, (.dmark+2)  
2253 32 7c ee			ld (debug_mark+2),a  
2256 18 03			jr .pastdmark  
2258 ..			.dmark: db "2DR"  
225b f1			.pastdmark: pop af  
225c			endm  
# End of macro DMARK
225c						CALLMONITOR 
225c cd 77 14			call break_point_state  
225f				endm  
# End of macro CALLMONITOR
225f					endif 
225f					FORTH_DSP_POP 
225f cd b3 1c			call macro_forth_dsp_pop 
2262				endm 
# End of macro FORTH_DSP_POP
2262					FORTH_DSP_POP 
2262 cd b3 1c			call macro_forth_dsp_pop 
2265				endm 
# End of macro FORTH_DSP_POP
2265					NEXTW 
2265 c3 6d 1d			jp macro_next 
2268				endm 
# End of macro NEXTW
2268			.SWAP2: 
2268				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2268 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2269 91 22			dw .AT            
226b 06				db 5 + 1 
226c .. 00			db "2SWAP",0              
2272				endm 
# End of macro CWHEAD
2272			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2272					if DEBUG_FORTH_WORDS_KEY 
2272						DMARK "2SW" 
2272 f5				push af  
2273 3a 87 22			ld a, (.dmark)  
2276 32 7a ee			ld (debug_mark),a  
2279 3a 88 22			ld a, (.dmark+1)  
227c 32 7b ee			ld (debug_mark+1),a  
227f 3a 89 22			ld a, (.dmark+2)  
2282 32 7c ee			ld (debug_mark+2),a  
2285 18 03			jr .pastdmark  
2287 ..			.dmark: db "2SW"  
228a f1			.pastdmark: pop af  
228b			endm  
# End of macro DMARK
228b						CALLMONITOR 
228b cd 77 14			call break_point_state  
228e				endm  
# End of macro CALLMONITOR
228e					endif 
228e					NEXTW 
228e c3 6d 1d			jp macro_next 
2291				endm 
# End of macro NEXTW
2291			.AT: 
2291				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2291 1f				db WORD_SYS_CORE+OPCODE_AT             
2292 c3 22			dw .CAT            
2294 02				db 1 + 1 
2295 .. 00			db "@",0              
2297				endm 
# End of macro CWHEAD
2297			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2297			 
2297					if DEBUG_FORTH_WORDS_KEY 
2297						DMARK "AT." 
2297 f5				push af  
2298 3a ac 22			ld a, (.dmark)  
229b 32 7a ee			ld (debug_mark),a  
229e 3a ad 22			ld a, (.dmark+1)  
22a1 32 7b ee			ld (debug_mark+1),a  
22a4 3a ae 22			ld a, (.dmark+2)  
22a7 32 7c ee			ld (debug_mark+2),a  
22aa 18 03			jr .pastdmark  
22ac ..			.dmark: db "AT."  
22af f1			.pastdmark: pop af  
22b0			endm  
# End of macro DMARK
22b0						CALLMONITOR 
22b0 cd 77 14			call break_point_state  
22b3				endm  
# End of macro CALLMONITOR
22b3					endif 
22b3			.getbyteat:	 
22b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22b3 cd fb 1b			call macro_dsp_valuehl 
22b6				endm 
# End of macro FORTH_DSP_VALUEHL
22b6					 
22b6			;		push hl 
22b6				 
22b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22b6 cd b3 1c			call macro_forth_dsp_pop 
22b9				endm 
# End of macro FORTH_DSP_POP
22b9			 
22b9			;		pop hl 
22b9			 
22b9 7e					ld a, (hl) 
22ba			 
22ba 6f					ld l, a 
22bb 26 00				ld h, 0 
22bd cd 04 1a				call forth_push_numhl 
22c0			 
22c0					NEXTW 
22c0 c3 6d 1d			jp macro_next 
22c3				endm 
# End of macro NEXTW
22c3			.CAT: 
22c3				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
22c3 20				db WORD_SYS_CORE+OPCODE_CAT             
22c4 ec 22			dw .BANG            
22c6 03				db 2 + 1 
22c7 .. 00			db "C@",0              
22ca				endm 
# End of macro CWHEAD
22ca			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
22ca					if DEBUG_FORTH_WORDS_KEY 
22ca						DMARK "CAA" 
22ca f5				push af  
22cb 3a df 22			ld a, (.dmark)  
22ce 32 7a ee			ld (debug_mark),a  
22d1 3a e0 22			ld a, (.dmark+1)  
22d4 32 7b ee			ld (debug_mark+1),a  
22d7 3a e1 22			ld a, (.dmark+2)  
22da 32 7c ee			ld (debug_mark+2),a  
22dd 18 03			jr .pastdmark  
22df ..			.dmark: db "CAA"  
22e2 f1			.pastdmark: pop af  
22e3			endm  
# End of macro DMARK
22e3						CALLMONITOR 
22e3 cd 77 14			call break_point_state  
22e6				endm  
# End of macro CALLMONITOR
22e6					endif 
22e6 c3 b3 22				jp .getbyteat 
22e9					NEXTW 
22e9 c3 6d 1d			jp macro_next 
22ec				endm 
# End of macro NEXTW
22ec			.BANG: 
22ec				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
22ec 21				db WORD_SYS_CORE+OPCODE_BANG             
22ed 22 23			dw .CBANG            
22ef 02				db 1 + 1 
22f0 .. 00			db "!",0              
22f2				endm 
# End of macro CWHEAD
22f2			; | ! ( x w -- ) Store x at address w      | DONE 
22f2					if DEBUG_FORTH_WORDS_KEY 
22f2						DMARK "BNG" 
22f2 f5				push af  
22f3 3a 07 23			ld a, (.dmark)  
22f6 32 7a ee			ld (debug_mark),a  
22f9 3a 08 23			ld a, (.dmark+1)  
22fc 32 7b ee			ld (debug_mark+1),a  
22ff 3a 09 23			ld a, (.dmark+2)  
2302 32 7c ee			ld (debug_mark+2),a  
2305 18 03			jr .pastdmark  
2307 ..			.dmark: db "BNG"  
230a f1			.pastdmark: pop af  
230b			endm  
# End of macro DMARK
230b						CALLMONITOR 
230b cd 77 14			call break_point_state  
230e				endm  
# End of macro CALLMONITOR
230e					endif 
230e			 
230e			.storebyteat:		 
230e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
230e cd fb 1b			call macro_dsp_valuehl 
2311				endm 
# End of macro FORTH_DSP_VALUEHL
2311					 
2311 e5					push hl 
2312				 
2312					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2312 cd b3 1c			call macro_forth_dsp_pop 
2315				endm 
# End of macro FORTH_DSP_POP
2315			 
2315					; get byte to poke 
2315			 
2315					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2315 cd fb 1b			call macro_dsp_valuehl 
2318				endm 
# End of macro FORTH_DSP_VALUEHL
2318 e5					push hl 
2319			 
2319			 
2319					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2319 cd b3 1c			call macro_forth_dsp_pop 
231c				endm 
# End of macro FORTH_DSP_POP
231c			 
231c			 
231c d1					pop de 
231d e1					pop hl 
231e			 
231e 73					ld (hl),e 
231f			 
231f			 
231f					NEXTW 
231f c3 6d 1d			jp macro_next 
2322				endm 
# End of macro NEXTW
2322			.CBANG: 
2322				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2322 22				db WORD_SYS_CORE+OPCODE_CBANG             
2323 4b 23			dw .SCALL            
2325 03				db 2 + 1 
2326 .. 00			db "C!",0              
2329				endm 
# End of macro CWHEAD
2329			; | C!  ( x w -- ) Store x at address w  | DONE 
2329					if DEBUG_FORTH_WORDS_KEY 
2329						DMARK "CBA" 
2329 f5				push af  
232a 3a 3e 23			ld a, (.dmark)  
232d 32 7a ee			ld (debug_mark),a  
2330 3a 3f 23			ld a, (.dmark+1)  
2333 32 7b ee			ld (debug_mark+1),a  
2336 3a 40 23			ld a, (.dmark+2)  
2339 32 7c ee			ld (debug_mark+2),a  
233c 18 03			jr .pastdmark  
233e ..			.dmark: db "CBA"  
2341 f1			.pastdmark: pop af  
2342			endm  
# End of macro DMARK
2342						CALLMONITOR 
2342 cd 77 14			call break_point_state  
2345				endm  
# End of macro CALLMONITOR
2345					endif 
2345 c3 0e 23				jp .storebyteat 
2348					NEXTW 
2348 c3 6d 1d			jp macro_next 
234b				endm 
# End of macro NEXTW
234b			.SCALL: 
234b				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
234b 23				db WORD_SYS_CORE+OPCODE_SCALL             
234c 7f 23			dw .DEPTH            
234e 05				db 4 + 1 
234f .. 00			db "CALL",0              
2354				endm 
# End of macro CWHEAD
2354			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2354					if DEBUG_FORTH_WORDS_KEY 
2354						DMARK "CLL" 
2354 f5				push af  
2355 3a 69 23			ld a, (.dmark)  
2358 32 7a ee			ld (debug_mark),a  
235b 3a 6a 23			ld a, (.dmark+1)  
235e 32 7b ee			ld (debug_mark+1),a  
2361 3a 6b 23			ld a, (.dmark+2)  
2364 32 7c ee			ld (debug_mark+2),a  
2367 18 03			jr .pastdmark  
2369 ..			.dmark: db "CLL"  
236c f1			.pastdmark: pop af  
236d			endm  
# End of macro DMARK
236d						CALLMONITOR 
236d cd 77 14			call break_point_state  
2370				endm  
# End of macro CALLMONITOR
2370					endif 
2370			 
2370					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2370 cd fb 1b			call macro_dsp_valuehl 
2373				endm 
# End of macro FORTH_DSP_VALUEHL
2373			 
2373			;		push hl 
2373			 
2373					; destroy value TOS 
2373			 
2373					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2373 cd b3 1c			call macro_forth_dsp_pop 
2376				endm 
# End of macro FORTH_DSP_POP
2376			 
2376						 
2376			;		pop hl 
2376			 
2376					; how to do a call with hl???? save SP? 
2376 cd 16 1d				call forth_call_hl 
2379			 
2379			 
2379					; TODO push value back onto stack for another op etc 
2379			 
2379 cd 04 1a				call forth_push_numhl 
237c					NEXTW 
237c c3 6d 1d			jp macro_next 
237f				endm 
# End of macro NEXTW
237f			.DEPTH: 
237f				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
237f 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2380 bc 23			dw .OVER            
2382 06				db 5 + 1 
2383 .. 00			db "DEPTH",0              
2389				endm 
# End of macro CWHEAD
2389			; | DEPTH ( -- u ) Push count of stack | DONE 
2389					; take current TOS and remove from base value div by two to get count 
2389					if DEBUG_FORTH_WORDS_KEY 
2389						DMARK "DEP" 
2389 f5				push af  
238a 3a 9e 23			ld a, (.dmark)  
238d 32 7a ee			ld (debug_mark),a  
2390 3a 9f 23			ld a, (.dmark+1)  
2393 32 7b ee			ld (debug_mark+1),a  
2396 3a a0 23			ld a, (.dmark+2)  
2399 32 7c ee			ld (debug_mark+2),a  
239c 18 03			jr .pastdmark  
239e ..			.dmark: db "DEP"  
23a1 f1			.pastdmark: pop af  
23a2			endm  
# End of macro DMARK
23a2						CALLMONITOR 
23a2 cd 77 14			call break_point_state  
23a5				endm  
# End of macro CALLMONITOR
23a5					endif 
23a5			 
23a5			 
23a5 2a 0d eb			ld hl, (cli_data_sp) 
23a8 11 c7 e8			ld de, cli_data_stack 
23ab ed 52			sbc hl,de 
23ad				 
23ad				; div by size of stack item 
23ad			 
23ad 5d				ld e,l 
23ae 0e 03			ld c, 3 
23b0 cd 59 0b			call Div8 
23b3			 
23b3 6f				ld l,a 
23b4 26 00			ld h,0 
23b6			 
23b6				;srl h 
23b6				;rr l 
23b6			 
23b6 cd 04 1a				call forth_push_numhl 
23b9					NEXTW 
23b9 c3 6d 1d			jp macro_next 
23bc				endm 
# End of macro NEXTW
23bc			.OVER: 
23bc				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
23bc 42				db WORD_SYS_CORE+46             
23bd 03 24			dw .PAUSE            
23bf 05				db 4 + 1 
23c0 .. 00			db "OVER",0              
23c5				endm 
# End of macro CWHEAD
23c5			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
23c5					if DEBUG_FORTH_WORDS_KEY 
23c5						DMARK "OVR" 
23c5 f5				push af  
23c6 3a da 23			ld a, (.dmark)  
23c9 32 7a ee			ld (debug_mark),a  
23cc 3a db 23			ld a, (.dmark+1)  
23cf 32 7b ee			ld (debug_mark+1),a  
23d2 3a dc 23			ld a, (.dmark+2)  
23d5 32 7c ee			ld (debug_mark+2),a  
23d8 18 03			jr .pastdmark  
23da ..			.dmark: db "OVR"  
23dd f1			.pastdmark: pop af  
23de			endm  
# End of macro DMARK
23de						CALLMONITOR 
23de cd 77 14			call break_point_state  
23e1				endm  
# End of macro CALLMONITOR
23e1					endif 
23e1			 
23e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23e1 cd fb 1b			call macro_dsp_valuehl 
23e4				endm 
# End of macro FORTH_DSP_VALUEHL
23e4 e5					push hl    ; n2 
23e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23e5 cd b3 1c			call macro_forth_dsp_pop 
23e8				endm 
# End of macro FORTH_DSP_POP
23e8			 
23e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23e8 cd fb 1b			call macro_dsp_valuehl 
23eb				endm 
# End of macro FORTH_DSP_VALUEHL
23eb e5					push hl    ; n1 
23ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23ec cd b3 1c			call macro_forth_dsp_pop 
23ef				endm 
# End of macro FORTH_DSP_POP
23ef			 
23ef d1					pop de     ; n1 
23f0 e1					pop hl     ; n2 
23f1			 
23f1 d5					push de 
23f2 e5					push hl 
23f3 d5					push de 
23f4			 
23f4					; push back  
23f4			 
23f4 e1					pop hl 
23f5 cd 04 1a				call forth_push_numhl 
23f8 e1					pop hl 
23f9 cd 04 1a				call forth_push_numhl 
23fc e1					pop hl 
23fd cd 04 1a				call forth_push_numhl 
2400					NEXTW 
2400 c3 6d 1d			jp macro_next 
2403				endm 
# End of macro NEXTW
2403			 
2403			.PAUSE: 
2403				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2403 43				db WORD_SYS_CORE+47             
2404 38 24			dw .PAUSES            
2406 08				db 7 + 1 
2407 .. 00			db "PAUSEMS",0              
240f				endm 
# End of macro CWHEAD
240f			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
240f					if DEBUG_FORTH_WORDS_KEY 
240f						DMARK "PMS" 
240f f5				push af  
2410 3a 24 24			ld a, (.dmark)  
2413 32 7a ee			ld (debug_mark),a  
2416 3a 25 24			ld a, (.dmark+1)  
2419 32 7b ee			ld (debug_mark+1),a  
241c 3a 26 24			ld a, (.dmark+2)  
241f 32 7c ee			ld (debug_mark+2),a  
2422 18 03			jr .pastdmark  
2424 ..			.dmark: db "PMS"  
2427 f1			.pastdmark: pop af  
2428			endm  
# End of macro DMARK
2428						CALLMONITOR 
2428 cd 77 14			call break_point_state  
242b				endm  
# End of macro CALLMONITOR
242b					endif 
242b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
242b cd fb 1b			call macro_dsp_valuehl 
242e				endm 
# End of macro FORTH_DSP_VALUEHL
242e			;		push hl    ; n2 
242e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
242e cd b3 1c			call macro_forth_dsp_pop 
2431				endm 
# End of macro FORTH_DSP_POP
2431			;		pop hl 
2431			 
2431 7d					ld a, l 
2432 cd f3 08				call aDelayInMS 
2435				       NEXTW 
2435 c3 6d 1d			jp macro_next 
2438				endm 
# End of macro NEXTW
2438			.PAUSES:  
2438				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2438 44				db WORD_SYS_CORE+48             
2439 a7 24			dw .ROT            
243b 06				db 5 + 1 
243c .. 00			db "PAUSE",0              
2442				endm 
# End of macro CWHEAD
2442			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2442					if DEBUG_FORTH_WORDS_KEY 
2442						DMARK "PAU" 
2442 f5				push af  
2443 3a 57 24			ld a, (.dmark)  
2446 32 7a ee			ld (debug_mark),a  
2449 3a 58 24			ld a, (.dmark+1)  
244c 32 7b ee			ld (debug_mark+1),a  
244f 3a 59 24			ld a, (.dmark+2)  
2452 32 7c ee			ld (debug_mark+2),a  
2455 18 03			jr .pastdmark  
2457 ..			.dmark: db "PAU"  
245a f1			.pastdmark: pop af  
245b			endm  
# End of macro DMARK
245b						CALLMONITOR 
245b cd 77 14			call break_point_state  
245e				endm  
# End of macro CALLMONITOR
245e					endif 
245e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
245e cd fb 1b			call macro_dsp_valuehl 
2461				endm 
# End of macro FORTH_DSP_VALUEHL
2461			;		push hl    ; n2 
2461					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2461 cd b3 1c			call macro_forth_dsp_pop 
2464				endm 
# End of macro FORTH_DSP_POP
2464			;		pop hl 
2464 45					ld b, l 
2465					if DEBUG_FORTH_WORDS 
2465						DMARK "PAU" 
2465 f5				push af  
2466 3a 7a 24			ld a, (.dmark)  
2469 32 7a ee			ld (debug_mark),a  
246c 3a 7b 24			ld a, (.dmark+1)  
246f 32 7b ee			ld (debug_mark+1),a  
2472 3a 7c 24			ld a, (.dmark+2)  
2475 32 7c ee			ld (debug_mark+2),a  
2478 18 03			jr .pastdmark  
247a ..			.dmark: db "PAU"  
247d f1			.pastdmark: pop af  
247e			endm  
# End of macro DMARK
247e						CALLMONITOR 
247e cd 77 14			call break_point_state  
2481				endm  
# End of macro CALLMONITOR
2481					endif 
2481 c5			.pauses1:	push bc 
2482 cd 0e 09				call delay1s 
2485 c1					pop bc 
2486					if DEBUG_FORTH_WORDS 
2486						DMARK "PA1" 
2486 f5				push af  
2487 3a 9b 24			ld a, (.dmark)  
248a 32 7a ee			ld (debug_mark),a  
248d 3a 9c 24			ld a, (.dmark+1)  
2490 32 7b ee			ld (debug_mark+1),a  
2493 3a 9d 24			ld a, (.dmark+2)  
2496 32 7c ee			ld (debug_mark+2),a  
2499 18 03			jr .pastdmark  
249b ..			.dmark: db "PA1"  
249e f1			.pastdmark: pop af  
249f			endm  
# End of macro DMARK
249f						CALLMONITOR 
249f cd 77 14			call break_point_state  
24a2				endm  
# End of macro CALLMONITOR
24a2					endif 
24a2 10 dd				djnz .pauses1 
24a4			 
24a4				       NEXTW 
24a4 c3 6d 1d			jp macro_next 
24a7				endm 
# End of macro NEXTW
24a7			.ROT: 
24a7				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
24a7 45				db WORD_SYS_CORE+49             
24a8 f5 24			dw .UWORDS            
24aa 04				db 3 + 1 
24ab .. 00			db "ROT",0              
24af				endm 
# End of macro CWHEAD
24af			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
24af					if DEBUG_FORTH_WORDS_KEY 
24af						DMARK "ROT" 
24af f5				push af  
24b0 3a c4 24			ld a, (.dmark)  
24b3 32 7a ee			ld (debug_mark),a  
24b6 3a c5 24			ld a, (.dmark+1)  
24b9 32 7b ee			ld (debug_mark+1),a  
24bc 3a c6 24			ld a, (.dmark+2)  
24bf 32 7c ee			ld (debug_mark+2),a  
24c2 18 03			jr .pastdmark  
24c4 ..			.dmark: db "ROT"  
24c7 f1			.pastdmark: pop af  
24c8			endm  
# End of macro DMARK
24c8						CALLMONITOR 
24c8 cd 77 14			call break_point_state  
24cb				endm  
# End of macro CALLMONITOR
24cb					endif 
24cb			 
24cb					FORTH_DSP_VALUEHL 
24cb cd fb 1b			call macro_dsp_valuehl 
24ce				endm 
# End of macro FORTH_DSP_VALUEHL
24ce e5					push hl    ; u3  
24cf			 
24cf					FORTH_DSP_POP 
24cf cd b3 1c			call macro_forth_dsp_pop 
24d2				endm 
# End of macro FORTH_DSP_POP
24d2			   
24d2					FORTH_DSP_VALUEHL 
24d2 cd fb 1b			call macro_dsp_valuehl 
24d5				endm 
# End of macro FORTH_DSP_VALUEHL
24d5 e5					push hl     ; u2 
24d6			 
24d6					FORTH_DSP_POP 
24d6 cd b3 1c			call macro_forth_dsp_pop 
24d9				endm 
# End of macro FORTH_DSP_POP
24d9			 
24d9					FORTH_DSP_VALUEHL 
24d9 cd fb 1b			call macro_dsp_valuehl 
24dc				endm 
# End of macro FORTH_DSP_VALUEHL
24dc e5					push hl     ; u1 
24dd			 
24dd					FORTH_DSP_POP 
24dd cd b3 1c			call macro_forth_dsp_pop 
24e0				endm 
# End of macro FORTH_DSP_POP
24e0			 
24e0 c1					pop bc      ; u1 
24e1 e1					pop hl      ; u2 
24e2 d1					pop de      ; u3 
24e3			 
24e3			 
24e3 c5					push bc 
24e4 d5					push de 
24e5 e5					push hl 
24e6			 
24e6			 
24e6 e1					pop hl 
24e7 cd 04 1a				call forth_push_numhl 
24ea			 
24ea e1					pop hl 
24eb cd 04 1a				call forth_push_numhl 
24ee			 
24ee e1					pop hl 
24ef cd 04 1a				call forth_push_numhl 
24f2					 
24f2			 
24f2			 
24f2			 
24f2			 
24f2			 
24f2				       NEXTW 
24f2 c3 6d 1d			jp macro_next 
24f5				endm 
# End of macro NEXTW
24f5			 
24f5			.UWORDS: 
24f5				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
24f5 50				db WORD_SYS_CORE+60             
24f6 b7 25			dw .BP            
24f8 07				db 6 + 1 
24f9 .. 00			db "UWORDS",0              
2500				endm 
# End of macro CWHEAD
2500			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2500			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2500			; | | Following the count are the individual words. 
2500			; | | 
2500			; | | e.g. UWORDS 
2500			; | | BOX DIRLIST 2 
2500			; | |  
2500			; | | Can be used to save the words to storage via: 
2500			; | | UWORDS $01 DO $01 APPEND LOOP 
2500				if DEBUG_FORTH_WORDS_KEY 
2500					DMARK "UWR" 
2500 f5				push af  
2501 3a 15 25			ld a, (.dmark)  
2504 32 7a ee			ld (debug_mark),a  
2507 3a 16 25			ld a, (.dmark+1)  
250a 32 7b ee			ld (debug_mark+1),a  
250d 3a 17 25			ld a, (.dmark+2)  
2510 32 7c ee			ld (debug_mark+2),a  
2513 18 03			jr .pastdmark  
2515 ..			.dmark: db "UWR"  
2518 f1			.pastdmark: pop af  
2519			endm  
# End of macro DMARK
2519					CALLMONITOR 
2519 cd 77 14			call break_point_state  
251c				endm  
# End of macro CALLMONITOR
251c				endif 
251c 21 42 59				ld hl, baseram 
251f					;ld hl, baseusermem 
251f 01 00 00				ld bc, 0    ; start a counter 
2522			 
2522				; skip dict stub 
2522			 
2522 cd be 1e				call forth_tok_next 
2525			 
2525			 
2525			; while we have words to look for 
2525			 
2525 7e			.douscan:	ld a, (hl)      
2526				if DEBUG_FORTH_WORDS 
2526					DMARK "UWs" 
2526 f5				push af  
2527 3a 3b 25			ld a, (.dmark)  
252a 32 7a ee			ld (debug_mark),a  
252d 3a 3c 25			ld a, (.dmark+1)  
2530 32 7b ee			ld (debug_mark+1),a  
2533 3a 3d 25			ld a, (.dmark+2)  
2536 32 7c ee			ld (debug_mark+2),a  
2539 18 03			jr .pastdmark  
253b ..			.dmark: db "UWs"  
253e f1			.pastdmark: pop af  
253f			endm  
# End of macro DMARK
253f					CALLMONITOR 
253f cd 77 14			call break_point_state  
2542				endm  
# End of macro CALLMONITOR
2542				endif 
2542 fe 00				cp WORD_SYS_END 
2544 28 4d				jr z, .udone 
2546 fe 01				cp WORD_SYS_UWORD 
2548 20 44				jr nz, .nuword 
254a			 
254a				if DEBUG_FORTH_WORDS 
254a					DMARK "UWu" 
254a f5				push af  
254b 3a 5f 25			ld a, (.dmark)  
254e 32 7a ee			ld (debug_mark),a  
2551 3a 60 25			ld a, (.dmark+1)  
2554 32 7b ee			ld (debug_mark+1),a  
2557 3a 61 25			ld a, (.dmark+2)  
255a 32 7c ee			ld (debug_mark+2),a  
255d 18 03			jr .pastdmark  
255f ..			.dmark: db "UWu"  
2562 f1			.pastdmark: pop af  
2563			endm  
# End of macro DMARK
2563					CALLMONITOR 
2563 cd 77 14			call break_point_state  
2566				endm  
# End of macro CALLMONITOR
2566				endif 
2566					; we have a uword so push its name to the stack 
2566			 
2566 e5				   	push hl  ; save so we can move to next dict block 
2567			 
2567					; skip opcode 
2567 23					inc hl  
2568					; skip next ptr 
2568 23					inc hl  
2569 23					inc hl 
256a					; skip len 
256a 23					inc hl 
256b				if DEBUG_FORTH_WORDS 
256b					DMARK "UWt" 
256b f5				push af  
256c 3a 80 25			ld a, (.dmark)  
256f 32 7a ee			ld (debug_mark),a  
2572 3a 81 25			ld a, (.dmark+1)  
2575 32 7b ee			ld (debug_mark+1),a  
2578 3a 82 25			ld a, (.dmark+2)  
257b 32 7c ee			ld (debug_mark+2),a  
257e 18 03			jr .pastdmark  
2580 ..			.dmark: db "UWt"  
2583 f1			.pastdmark: pop af  
2584			endm  
# End of macro DMARK
2584					CALLMONITOR 
2584 cd 77 14			call break_point_state  
2587				endm  
# End of macro CALLMONITOR
2587				endif 
2587 03					inc bc 
2588			 
2588 c5					push bc 
2589 cd 72 1a				call forth_push_str 
258c c1					pop bc 
258d			 
258d e1					pop hl 	 
258e			 
258e cd be 1e		.nuword:	call forth_tok_next 
2591 18 92				jr .douscan  
2593			 
2593			.udone:		 ; push count of uwords found 
2593 c5					push bc 
2594 e1					pop hl 
2595			 
2595				if DEBUG_FORTH_WORDS 
2595					DMARK "UWc" 
2595 f5				push af  
2596 3a aa 25			ld a, (.dmark)  
2599 32 7a ee			ld (debug_mark),a  
259c 3a ab 25			ld a, (.dmark+1)  
259f 32 7b ee			ld (debug_mark+1),a  
25a2 3a ac 25			ld a, (.dmark+2)  
25a5 32 7c ee			ld (debug_mark+2),a  
25a8 18 03			jr .pastdmark  
25aa ..			.dmark: db "UWc"  
25ad f1			.pastdmark: pop af  
25ae			endm  
# End of macro DMARK
25ae					CALLMONITOR 
25ae cd 77 14			call break_point_state  
25b1				endm  
# End of macro CALLMONITOR
25b1				endif 
25b1 cd 04 1a				call forth_push_numhl 
25b4			 
25b4			 
25b4				       NEXTW 
25b4 c3 6d 1d			jp macro_next 
25b7				endm 
# End of macro NEXTW
25b7			 
25b7			.BP: 
25b7				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
25b7 54				db WORD_SYS_CORE+64             
25b8 ed 25			dw .MONITOR            
25ba 03				db 2 + 1 
25bb .. 00			db "BP",0              
25be				endm 
# End of macro CWHEAD
25be			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
25be			; | | $00 Will enable the break points within specific code paths 
25be			; | | $01 Will disable break points 
25be			; | |  
25be			; | | By default break points are off. Either the above can be used to enable them 
25be			; | | or if a key is held down during start up the spashscreen will appear to freeze 
25be			; | | and on release of the pressed key a message will be disaplayed to notify 
25be			; | | that break points are enabled. Pressing any key will then continue boot process. 
25be					; get byte count 
25be					if DEBUG_FORTH_WORDS_KEY 
25be						DMARK "BP." 
25be f5				push af  
25bf 3a d3 25			ld a, (.dmark)  
25c2 32 7a ee			ld (debug_mark),a  
25c5 3a d4 25			ld a, (.dmark+1)  
25c8 32 7b ee			ld (debug_mark+1),a  
25cb 3a d5 25			ld a, (.dmark+2)  
25ce 32 7c ee			ld (debug_mark+2),a  
25d1 18 03			jr .pastdmark  
25d3 ..			.dmark: db "BP."  
25d6 f1			.pastdmark: pop af  
25d7			endm  
# End of macro DMARK
25d7						CALLMONITOR 
25d7 cd 77 14			call break_point_state  
25da				endm  
# End of macro CALLMONITOR
25da					endif 
25da			 
25da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25da cd fb 1b			call macro_dsp_valuehl 
25dd				endm 
# End of macro FORTH_DSP_VALUEHL
25dd			 
25dd			;		push hl 
25dd			 
25dd					; destroy value TOS 
25dd			 
25dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25dd cd b3 1c			call macro_forth_dsp_pop 
25e0				endm 
# End of macro FORTH_DSP_POP
25e0			 
25e0			;		pop hl 
25e0			 
25e0 3e 00				ld a,0 
25e2 bd					cp l 
25e3 28 02				jr z, .bpset 
25e5 3e 2a				ld a, '*' 
25e7			 
25e7 32 51 e3		.bpset:		ld (os_view_disable), a 
25ea			 
25ea			 
25ea					NEXTW 
25ea c3 6d 1d			jp macro_next 
25ed				endm 
# End of macro NEXTW
25ed			 
25ed			 
25ed			.MONITOR: 
25ed				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
25ed 55				db WORD_SYS_CORE+65             
25ee 20 26			dw .MALLOC            
25f0 08				db 7 + 1 
25f1 .. 00			db "MONITOR",0              
25f9				endm 
# End of macro CWHEAD
25f9			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
25f9			; | | At start the current various registers will be displayed with contents. 
25f9			; | | Top right corner will show the most recent debug marker seen. 
25f9			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
25f9			; | | and the return stack pointer (RSP). 
25f9			; | | Pressing: 
25f9			; | |    1 - Initial screen 
25f9			; | |    2 - Display a data dump of HL 
25f9			; | |    3 - Display a data dump of DE 
25f9			; | |    4 - Display a data dump of BC 
25f9			; | |    5 - Display a data dump of HL 
25f9			; | |    6 - Display a data dump of DSP 
25f9			; | |    7 - Display a data dump of RSP 
25f9			; | |    8 - Display a data dump of what is at DSP 
25f9			; | |    9 - Display a data dump of what is at RSP 
25f9			; | |    0 - Exit monitor and continue running. This will also enable break points 
25f9			; | |    * - Disable break points 
25f9			; | |    # - Enter traditional monitor mode 
25f9			; | | 
25f9			; | | Monitor Mode 
25f9			; | | ------------ 
25f9			; | | A prompt of '>' will be shown for various commands: 
25f9			; | |    D xxxx - Display a data dump starting from hex address xxxx 
25f9			; | |    C - Continue display a data dump from the last set address 
25f9			; | |    M xxxx - Set start of memory edit at address xx 
25f9			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
25f9			; | |    Q - Return to previous 
25f9					if DEBUG_FORTH_WORDS_KEY 
25f9						DMARK "MON" 
25f9 f5				push af  
25fa 3a 0e 26			ld a, (.dmark)  
25fd 32 7a ee			ld (debug_mark),a  
2600 3a 0f 26			ld a, (.dmark+1)  
2603 32 7b ee			ld (debug_mark+1),a  
2606 3a 10 26			ld a, (.dmark+2)  
2609 32 7c ee			ld (debug_mark+2),a  
260c 18 03			jr .pastdmark  
260e ..			.dmark: db "MON"  
2611 f1			.pastdmark: pop af  
2612			endm  
# End of macro DMARK
2612						CALLMONITOR 
2612 cd 77 14			call break_point_state  
2615				endm  
# End of macro CALLMONITOR
2615					endif 
2615 3e 00				ld a, 0 
2617 32 51 e3				ld (os_view_disable), a 
261a			 
261a					CALLMONITOR 
261a cd 77 14			call break_point_state  
261d				endm  
# End of macro CALLMONITOR
261d			 
261d			;	call monitor 
261d			 
261d					NEXTW 
261d c3 6d 1d			jp macro_next 
2620				endm 
# End of macro NEXTW
2620			 
2620			 
2620			.MALLOC: 
2620				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2620 56				db WORD_SYS_CORE+66             
2621 49 26			dw .MALLOC2            
2623 06				db 5 + 1 
2624 .. 00			db "ALLOT",0              
262a				endm 
# End of macro CWHEAD
262a			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
262a					if DEBUG_FORTH_WORDS_KEY 
262a						DMARK "ALL" 
262a f5				push af  
262b 3a 3f 26			ld a, (.dmark)  
262e 32 7a ee			ld (debug_mark),a  
2631 3a 40 26			ld a, (.dmark+1)  
2634 32 7b ee			ld (debug_mark+1),a  
2637 3a 41 26			ld a, (.dmark+2)  
263a 32 7c ee			ld (debug_mark+2),a  
263d 18 03			jr .pastdmark  
263f ..			.dmark: db "ALL"  
2642 f1			.pastdmark: pop af  
2643			endm  
# End of macro DMARK
2643						CALLMONITOR 
2643 cd 77 14			call break_point_state  
2646				endm  
# End of macro CALLMONITOR
2646					endif 
2646 c3 70 26				jp .mallocc 
2649			.MALLOC2: 
2649				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2649 56				db WORD_SYS_CORE+66             
264a 87 26			dw .FREE            
264c 07				db 6 + 1 
264d .. 00			db "MALLOC",0              
2654				endm 
# End of macro CWHEAD
2654			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2654					; get byte count 
2654					if DEBUG_FORTH_WORDS_KEY 
2654						DMARK "MAL" 
2654 f5				push af  
2655 3a 69 26			ld a, (.dmark)  
2658 32 7a ee			ld (debug_mark),a  
265b 3a 6a 26			ld a, (.dmark+1)  
265e 32 7b ee			ld (debug_mark+1),a  
2661 3a 6b 26			ld a, (.dmark+2)  
2664 32 7c ee			ld (debug_mark+2),a  
2667 18 03			jr .pastdmark  
2669 ..			.dmark: db "MAL"  
266c f1			.pastdmark: pop af  
266d			endm  
# End of macro DMARK
266d						CALLMONITOR 
266d cd 77 14			call break_point_state  
2670				endm  
# End of macro CALLMONITOR
2670					endif 
2670			.mallocc: 
2670					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2670 cd fb 1b			call macro_dsp_valuehl 
2673				endm 
# End of macro FORTH_DSP_VALUEHL
2673			 
2673			;		push hl 
2673			 
2673					; destroy value TOS 
2673			 
2673					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2673 cd b3 1c			call macro_forth_dsp_pop 
2676				endm 
# End of macro FORTH_DSP_POP
2676			 
2676			;		pop hl 
2676 cd 90 10				call malloc 
2679				if DEBUG_FORTH_MALLOC_GUARD 
2679 f5					push af 
267a cd f2 0b				call ishlzero 
267d			;		ld a, l 
267d			;		add h 
267d			;		cp 0 
267d f1					pop af 
267e					 
267e cc 9f 45				call z,malloc_error 
2681				endif 
2681			 
2681 cd 04 1a				call forth_push_numhl 
2684					NEXTW 
2684 c3 6d 1d			jp macro_next 
2687				endm 
# End of macro NEXTW
2687			 
2687			.FREE: 
2687				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2687 57				db WORD_SYS_CORE+67             
2688 b8 26			dw .LIST            
268a 05				db 4 + 1 
268b .. 00			db "FREE",0              
2690				endm 
# End of macro CWHEAD
2690			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2690					if DEBUG_FORTH_WORDS_KEY 
2690						DMARK "FRE" 
2690 f5				push af  
2691 3a a5 26			ld a, (.dmark)  
2694 32 7a ee			ld (debug_mark),a  
2697 3a a6 26			ld a, (.dmark+1)  
269a 32 7b ee			ld (debug_mark+1),a  
269d 3a a7 26			ld a, (.dmark+2)  
26a0 32 7c ee			ld (debug_mark+2),a  
26a3 18 03			jr .pastdmark  
26a5 ..			.dmark: db "FRE"  
26a8 f1			.pastdmark: pop af  
26a9			endm  
# End of macro DMARK
26a9						CALLMONITOR 
26a9 cd 77 14			call break_point_state  
26ac				endm  
# End of macro CALLMONITOR
26ac					endif 
26ac					; get address 
26ac			 
26ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26ac cd fb 1b			call macro_dsp_valuehl 
26af				endm 
# End of macro FORTH_DSP_VALUEHL
26af			 
26af			;		push hl 
26af			 
26af					; destroy value TOS 
26af			 
26af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26af cd b3 1c			call macro_forth_dsp_pop 
26b2				endm 
# End of macro FORTH_DSP_POP
26b2			 
26b2			;		pop hl 
26b2			if FORTH_ENABLE_MALLOCFREE 
26b2 cd 5a 11				call free 
26b5			endif 
26b5					NEXTW 
26b5 c3 6d 1d			jp macro_next 
26b8				endm 
# End of macro NEXTW
26b8			.LIST: 
26b8				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
26b8 5c				db WORD_SYS_CORE+72             
26b9 a6 28			dw .FORGET            
26bb 05				db 4 + 1 
26bc .. 00			db "LIST",0              
26c1				endm 
# End of macro CWHEAD
26c1			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
26c1			; | | The quoted word must be in upper case. 
26c1				if DEBUG_FORTH_WORDS_KEY 
26c1					DMARK "LST" 
26c1 f5				push af  
26c2 3a d6 26			ld a, (.dmark)  
26c5 32 7a ee			ld (debug_mark),a  
26c8 3a d7 26			ld a, (.dmark+1)  
26cb 32 7b ee			ld (debug_mark+1),a  
26ce 3a d8 26			ld a, (.dmark+2)  
26d1 32 7c ee			ld (debug_mark+2),a  
26d4 18 03			jr .pastdmark  
26d6 ..			.dmark: db "LST"  
26d9 f1			.pastdmark: pop af  
26da			endm  
# End of macro DMARK
26da					CALLMONITOR 
26da cd 77 14			call break_point_state  
26dd				endm  
# End of macro CALLMONITOR
26dd				endif 
26dd			 
26dd					FORTH_DSP_VALUEHL 
26dd cd fb 1b			call macro_dsp_valuehl 
26e0				endm 
# End of macro FORTH_DSP_VALUEHL
26e0			 
26e0 e5					push hl 
26e1					FORTH_DSP_POP 
26e1 cd b3 1c			call macro_forth_dsp_pop 
26e4				endm 
# End of macro FORTH_DSP_POP
26e4 c1					pop bc 
26e5			 
26e5			; Start format of scratch string 
26e5			 
26e5 21 60 e3				ld hl, scratch 
26e8			 
26e8 3e 3a				ld a, ':' 
26ea 77					ld (hl),a 
26eb 23					inc hl 
26ec 3e 20				ld a, ' ' 
26ee 77					ld (hl), a 
26ef			 
26ef					; Get ptr to the word we need to look up 
26ef			 
26ef			;		FORTH_DSP_VALUEHL 
26ef					;v5 FORTH_DSP_VALUE 
26ef				; TODO type check 
26ef			;		inc hl    ; Skip type check  
26ef			;		push hl 
26ef			;		ex de, hl    ; put into DE 
26ef			 
26ef			 
26ef 21 42 59				ld hl, baseram 
26f2					;ld hl, baseusermem 
26f2			 
26f2 e5			push hl   ; sacreifical push 
26f3			 
26f3			.ldouscanm: 
26f3 e1				pop hl 
26f4			.ldouscan: 
26f4				if DEBUG_FORTH_WORDS 
26f4					DMARK "LSs" 
26f4 f5				push af  
26f5 3a 09 27			ld a, (.dmark)  
26f8 32 7a ee			ld (debug_mark),a  
26fb 3a 0a 27			ld a, (.dmark+1)  
26fe 32 7b ee			ld (debug_mark+1),a  
2701 3a 0b 27			ld a, (.dmark+2)  
2704 32 7c ee			ld (debug_mark+2),a  
2707 18 03			jr .pastdmark  
2709 ..			.dmark: db "LSs"  
270c f1			.pastdmark: pop af  
270d			endm  
# End of macro DMARK
270d					CALLMONITOR 
270d cd 77 14			call break_point_state  
2710				endm  
# End of macro CALLMONITOR
2710				endif 
2710				; skip dict stub 
2710 cd be 1e				call forth_tok_next 
2713			 
2713			 
2713			; while we have words to look for 
2713			 
2713 7e				ld a, (hl)      
2714				if DEBUG_FORTH_WORDS 
2714					DMARK "LSk" 
2714 f5				push af  
2715 3a 29 27			ld a, (.dmark)  
2718 32 7a ee			ld (debug_mark),a  
271b 3a 2a 27			ld a, (.dmark+1)  
271e 32 7b ee			ld (debug_mark+1),a  
2721 3a 2b 27			ld a, (.dmark+2)  
2724 32 7c ee			ld (debug_mark+2),a  
2727 18 03			jr .pastdmark  
2729 ..			.dmark: db "LSk"  
272c f1			.pastdmark: pop af  
272d			endm  
# End of macro DMARK
272d					CALLMONITOR 
272d cd 77 14			call break_point_state  
2730				endm  
# End of macro CALLMONITOR
2730				endif 
2730					;cp WORD_SYS_END 
2730					;jp z, .lunotfound 
2730			 
2730					; if we hit non uwords then gone too far 
2730 fe 01				cp WORD_SYS_UWORD 
2732 c2 62 28				jp nz, .lunotfound 
2735			 
2735				if DEBUG_FORTH_WORDS 
2735					DMARK "LSu" 
2735 f5				push af  
2736 3a 4a 27			ld a, (.dmark)  
2739 32 7a ee			ld (debug_mark),a  
273c 3a 4b 27			ld a, (.dmark+1)  
273f 32 7b ee			ld (debug_mark+1),a  
2742 3a 4c 27			ld a, (.dmark+2)  
2745 32 7c ee			ld (debug_mark+2),a  
2748 18 03			jr .pastdmark  
274a ..			.dmark: db "LSu"  
274d f1			.pastdmark: pop af  
274e			endm  
# End of macro DMARK
274e					CALLMONITOR 
274e cd 77 14			call break_point_state  
2751				endm  
# End of macro CALLMONITOR
2751				endif 
2751			 
2751					; found a uword but is it the one we want... 
2751			 
2751 c5					push bc     ; uword to find is on bc 
2752 d1					pop de 
2753			 
2753 e5					push hl  ; to save the ptr 
2754			 
2754					; skip opcode 
2754 23					inc hl  
2755					; skip next ptr 
2755 23					inc hl  
2756 23					inc hl 
2757					; skip len 
2757 23					inc hl 
2758			 
2758				if DEBUG_FORTH_WORDS 
2758					DMARK "LSc" 
2758 f5				push af  
2759 3a 6d 27			ld a, (.dmark)  
275c 32 7a ee			ld (debug_mark),a  
275f 3a 6e 27			ld a, (.dmark+1)  
2762 32 7b ee			ld (debug_mark+1),a  
2765 3a 6f 27			ld a, (.dmark+2)  
2768 32 7c ee			ld (debug_mark+2),a  
276b 18 03			jr .pastdmark  
276d ..			.dmark: db "LSc"  
2770 f1			.pastdmark: pop af  
2771			endm  
# End of macro DMARK
2771					CALLMONITOR 
2771 cd 77 14			call break_point_state  
2774				endm  
# End of macro CALLMONITOR
2774				endif 
2774 cd 5f 10				call strcmp 
2777 c2 f3 26				jp nz, .ldouscanm 
277a				 
277a			 
277a			 
277a					; we have a uword so push its name to the stack 
277a			 
277a			;	   	push hl  ; save so we can move to next dict block 
277a e1			pop hl 
277b			 
277b				if DEBUG_FORTH_WORDS 
277b					DMARK "LSm" 
277b f5				push af  
277c 3a 90 27			ld a, (.dmark)  
277f 32 7a ee			ld (debug_mark),a  
2782 3a 91 27			ld a, (.dmark+1)  
2785 32 7b ee			ld (debug_mark+1),a  
2788 3a 92 27			ld a, (.dmark+2)  
278b 32 7c ee			ld (debug_mark+2),a  
278e 18 03			jr .pastdmark  
2790 ..			.dmark: db "LSm"  
2793 f1			.pastdmark: pop af  
2794			endm  
# End of macro DMARK
2794					CALLMONITOR 
2794 cd 77 14			call break_point_state  
2797				endm  
# End of macro CALLMONITOR
2797				endif 
2797			 
2797					; skip opcode 
2797 23					inc hl  
2798					; skip next ptr 
2798 23					inc hl  
2799 23					inc hl 
279a					; skip len 
279a 7e					ld a, (hl)   ; save length to add 
279b				if DEBUG_FORTH_WORDS 
279b					DMARK "LS2" 
279b f5				push af  
279c 3a b0 27			ld a, (.dmark)  
279f 32 7a ee			ld (debug_mark),a  
27a2 3a b1 27			ld a, (.dmark+1)  
27a5 32 7b ee			ld (debug_mark+1),a  
27a8 3a b2 27			ld a, (.dmark+2)  
27ab 32 7c ee			ld (debug_mark+2),a  
27ae 18 03			jr .pastdmark  
27b0 ..			.dmark: db "LS2"  
27b3 f1			.pastdmark: pop af  
27b4			endm  
# End of macro DMARK
27b4					CALLMONITOR 
27b4 cd 77 14			call break_point_state  
27b7				endm  
# End of macro CALLMONITOR
27b7				endif 
27b7			 
27b7					; save this location 
27b7				 
27b7 e5					push hl 
27b8			 
27b8 23					inc hl 
27b9 11 62 e3				ld de, scratch+2 
27bc 4f					ld c, a 
27bd 06 00				ld b, 0 
27bf			 
27bf				if DEBUG_FORTH_WORDS 
27bf					DMARK "LSn" 
27bf f5				push af  
27c0 3a d4 27			ld a, (.dmark)  
27c3 32 7a ee			ld (debug_mark),a  
27c6 3a d5 27			ld a, (.dmark+1)  
27c9 32 7b ee			ld (debug_mark+1),a  
27cc 3a d6 27			ld a, (.dmark+2)  
27cf 32 7c ee			ld (debug_mark+2),a  
27d2 18 03			jr .pastdmark  
27d4 ..			.dmark: db "LSn"  
27d7 f1			.pastdmark: pop af  
27d8			endm  
# End of macro DMARK
27d8					CALLMONITOR 
27d8 cd 77 14			call break_point_state  
27db				endm  
# End of macro CALLMONITOR
27db				endif 
27db			 
27db					; copy uword name to scratch 
27db			 
27db ed b0				ldir 
27dd			 
27dd 1b					dec de 
27de 3e 20				ld a, ' '    ; change null to space 
27e0 12					ld (de), a 
27e1			 
27e1 13					inc de 
27e2			 
27e2 d5					push de 
27e3 c1					pop bc     ; move scratch pointer to end of word name and save it 
27e4			 
27e4 e1					pop hl 
27e5 7e					ld a, (hl) 
27e6					;inc hl 
27e6					; skip word string 
27e6 cd c9 0b				call addatohl 
27e9			 
27e9 23					inc hl 
27ea			 
27ea				if DEBUG_FORTH_WORDS 
27ea					DMARK "LS3" 
27ea f5				push af  
27eb 3a ff 27			ld a, (.dmark)  
27ee 32 7a ee			ld (debug_mark),a  
27f1 3a 00 28			ld a, (.dmark+1)  
27f4 32 7b ee			ld (debug_mark+1),a  
27f7 3a 01 28			ld a, (.dmark+2)  
27fa 32 7c ee			ld (debug_mark+2),a  
27fd 18 03			jr .pastdmark  
27ff ..			.dmark: db "LS3"  
2802 f1			.pastdmark: pop af  
2803			endm  
# End of macro DMARK
2803					CALLMONITOR 
2803 cd 77 14			call break_point_state  
2806				endm  
# End of macro CALLMONITOR
2806				endif 
2806					; should now be at the start of the machine code to setup the eval of the uword 
2806					; now locate the ptr to the string defintion 
2806			 
2806					; skip ld hl, 
2806					; then load the ptr 
2806			; TODO use get from hl ptr 
2806 23					inc hl 
2807 5e					ld e, (hl) 
2808 23					inc hl 
2809 56					ld d, (hl) 
280a eb					ex de, hl 
280b			 
280b			 
280b				if DEBUG_FORTH_WORDS 
280b					DMARK "LSt" 
280b f5				push af  
280c 3a 20 28			ld a, (.dmark)  
280f 32 7a ee			ld (debug_mark),a  
2812 3a 21 28			ld a, (.dmark+1)  
2815 32 7b ee			ld (debug_mark+1),a  
2818 3a 22 28			ld a, (.dmark+2)  
281b 32 7c ee			ld (debug_mark+2),a  
281e 18 03			jr .pastdmark  
2820 ..			.dmark: db "LSt"  
2823 f1			.pastdmark: pop af  
2824			endm  
# End of macro DMARK
2824					CALLMONITOR 
2824 cd 77 14			call break_point_state  
2827				endm  
# End of macro CALLMONITOR
2827				endif 
2827			 
2827			; cant push right now due to tokenised strings  
2827			 
2827			; get the destination of where to copy this definition to. 
2827			 
2827 c5					push bc 
2828 d1					pop de 
2829			 
2829 7e			.listl:         ld a,(hl) 
282a fe 00				cp 0 
282c 28 09				jr z, .lreplsp     ; replace zero with space 
282e					;cp FORTH_END_BUFFER 
282e fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2830 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2832				 
2832					; just copy this char as is then 
2832			 
2832 12					ld (de), a 
2833			 
2833 23			.listnxt:	inc hl 
2834 13					inc de 
2835 18 f2				jr .listl 
2837			 
2837 3e 20		.lreplsp:	ld a,' ' 
2839 12					ld (de), a 
283a 18 f7				jr .listnxt 
283c			 
283c			; close up uword def 
283c			 
283c			.listdone: 
283c 12					ld (de), a 
283d 13					inc de 
283e 3e 00				ld a, 0 
2840 12					ld (de), a 
2841			 
2841			; now have def so clean up and push to stack 
2841			 
2841 21 60 e3				ld hl, scratch 
2844				if DEBUG_FORTH_WORDS 
2844					DMARK "Ltp" 
2844 f5				push af  
2845 3a 59 28			ld a, (.dmark)  
2848 32 7a ee			ld (debug_mark),a  
284b 3a 5a 28			ld a, (.dmark+1)  
284e 32 7b ee			ld (debug_mark+1),a  
2851 3a 5b 28			ld a, (.dmark+2)  
2854 32 7c ee			ld (debug_mark+2),a  
2857 18 03			jr .pastdmark  
2859 ..			.dmark: db "Ltp"  
285c f1			.pastdmark: pop af  
285d			endm  
# End of macro DMARK
285d					CALLMONITOR 
285d cd 77 14			call break_point_state  
2860				endm  
# End of macro CALLMONITOR
2860				endif 
2860			 
2860 18 1f			jr .listpush 
2862			 
2862			;.lnuword:	pop hl 
2862			;		call forth_tok_next 
2862			;		jp .ldouscan  
2862			 
2862			.lunotfound:		  
2862			 
2862				if DEBUG_FORTH_WORDS 
2862					DMARK "LSn" 
2862 f5				push af  
2863 3a 77 28			ld a, (.dmark)  
2866 32 7a ee			ld (debug_mark),a  
2869 3a 78 28			ld a, (.dmark+1)  
286c 32 7b ee			ld (debug_mark+1),a  
286f 3a 79 28			ld a, (.dmark+2)  
2872 32 7c ee			ld (debug_mark+2),a  
2875 18 03			jr .pastdmark  
2877 ..			.dmark: db "LSn"  
287a f1			.pastdmark: pop af  
287b			endm  
# End of macro DMARK
287b					CALLMONITOR 
287b cd 77 14			call break_point_state  
287e				endm  
# End of macro CALLMONITOR
287e				endif 
287e			 
287e					 
287e			;		FORTH_DSP_POP 
287e			;		ld hl, .luno 
287e			 
287e					NEXTW			 
287e c3 6d 1d			jp macro_next 
2881				endm 
# End of macro NEXTW
2881			 
2881			.listpush: 
2881				if DEBUG_FORTH_WORDS 
2881					DMARK "LS>" 
2881 f5				push af  
2882 3a 96 28			ld a, (.dmark)  
2885 32 7a ee			ld (debug_mark),a  
2888 3a 97 28			ld a, (.dmark+1)  
288b 32 7b ee			ld (debug_mark+1),a  
288e 3a 98 28			ld a, (.dmark+2)  
2891 32 7c ee			ld (debug_mark+2),a  
2894 18 03			jr .pastdmark  
2896 ..			.dmark: db "LS>"  
2899 f1			.pastdmark: pop af  
289a			endm  
# End of macro DMARK
289a					CALLMONITOR 
289a cd 77 14			call break_point_state  
289d				endm  
# End of macro CALLMONITOR
289d				endif 
289d cd 72 1a				call forth_push_str 
28a0			 
28a0			 
28a0			 
28a0					NEXTW 
28a0 c3 6d 1d			jp macro_next 
28a3				endm 
# End of macro NEXTW
28a3			 
28a3			;.luno:    db "Word not found",0 
28a3			 
28a3			 
28a3			 
28a3			 
28a3			 
28a3			;		push hl   ; save pointer to start of uword def string 
28a3			; 
28a3			;; look for FORTH_EOL_LINE 
28a3			;		ld a, FORTH_END_BUFFER 
28a3			;		call strlent 
28a3			; 
28a3			;		inc hl		 ; space for coln def 
28a3			;		inc hl 
28a3			;		inc hl          ; space for terms 
28a3			;		inc hl 
28a3			; 
28a3			;		ld a, 20   ; TODO get actual length 
28a3			;		call addatohl    ; include a random amount of room for the uword name 
28a3			; 
28a3			;		 
28a3			;	if DEBUG_FORTH_WORDS 
28a3			;		DMARK "Lt1" 
28a3			;		CALLMONITOR 
28a3			;	endif 
28a3			;		 
28a3			; 
28a3			;; malloc space for the string because we cant change it 
28a3			; 
28a3			;		call malloc 
28a3			;	if DEBUG_FORTH_MALLOC_GUARD 
28a3			;		push af 
28a3			;		call ishlzero 
28a3			;		pop af 
28a3			;		 
28a3			;		call z,malloc_error 
28a3			;	endif 
28a3			; 
28a3			;	if DEBUG_FORTH_WORDS 
28a3			;		DMARK "Lt2" 
28a3			;		CALLMONITOR 
28a3			;	endif 
28a3			;		pop de 
28a3			;		push hl    ; push the malloc to release later 
28a3			;		push hl   ;  push back a copy for the later stack push 
28a3			;		 
28a3			;; copy the string swapping out the zero terms for spaces 
28a3			; 
28a3			;		; de has our source 
28a3			;		; hl has our dest 
28a3			; 
28a3			;; add the coln def 
28a3			; 
28a3			;		ld a, ':' 
28a3			;		ld (hl), a 
28a3			;		inc hl 
28a3			;		ld a, ' ' 
28a3			;		ld (hl), a 
28a3			;		inc hl 
28a3			; 
28a3			;; add the uname word 
28a3			;		push de   ; save our string for now 
28a3			;		ex de, hl 
28a3			; 
28a3			;		FORTH_DSP_VALUE 
28a3			;		;v5 FORTH_DSP_VALUE 
28a3			; 
28a3			;		inc hl   ; skip type but we know by now this is OK 
28a3			; 
28a3			;.luword:	ld a,(hl) 
28a3			;		cp 0 
28a3			;		jr z, .luword2 
28a3			;		ld (de), a 
28a3			;		inc de 
28a3			;		inc hl 
28a3			;		jr .luword 
28a3			; 
28a3			;.luword2:	ld a, ' ' 
28a3			;		ld (de), a 
28a3			;;		inc hl 
28a3			;;		inc de 
28a3			;;		ld (de), a 
28a3			;;		inc hl 
28a3			;		inc de 
28a3			; 
28a3			;		ex de, hl 
28a3			;		pop de 
28a3			;		 
28a3			;		 
28a3			; 
28a3			;; detoken that string and copy it 
28a3			; 
28a3			;	if DEBUG_FORTH_WORDS 
28a3			;		DMARK "Lt2" 
28a3			;		CALLMONITOR 
28a3			;	endif 
28a3			;.ldetok:	ld a, (de) 
28a3			;		cp FORTH_END_BUFFER 
28a3			;		jr z, .ldetokend 
28a3			;		; swap out any zero term for space 
28a3			;		cp 0 
28a3			;		jr nz, .ldetoknext 
28a3			;		ld a, ' ' 
28a3			; 
28a3			;	if DEBUG_FORTH_WORDS 
28a3			;		DMARK "LtS" 
28a3			;		CALLMONITOR 
28a3			;	endif 
28a3			;.ldetoknext:	ld (hl), a 
28a3			;		inc de 
28a3			;		inc hl 
28a3			;		jr .ldetok 
28a3			; 
28a3			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
28a3			;		ld (hl), a  
28a3			; 
28a3			;; free that temp malloc 
28a3			; 
28a3			;		pop hl    
28a3			; 
28a3			;	if DEBUG_FORTH_WORDS 
28a3			;		DMARK "Lt4" 
28a3			;		CALLMONITOR 
28a3			;	endif 
28a3			;		call forth_apushstrhl 
28a3			; 
28a3			;		; get rid of temp malloc area 
28a3			; 
28a3			;		pop hl 
28a3			;		call free 
28a3			; 
28a3			;		jr .ludone 
28a3			; 
28a3			;.lnuword:	pop hl 
28a3			;		call forth_tok_next 
28a3			;		jp .ldouscan  
28a3			; 
28a3			;.ludone:		 pop hl 
28a3			; 
28a3					NEXTW 
28a3 c3 6d 1d			jp macro_next 
28a6				endm 
# End of macro NEXTW
28a6			 
28a6			.FORGET: 
28a6				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
28a6 5d				db WORD_SYS_CORE+73             
28a7 1f 29			dw .NOP            
28a9 07				db 6 + 1 
28aa .. 00			db "FORGET",0              
28b1				endm 
# End of macro CWHEAD
28b1			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
28b1			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
28b1			; | |  
28b1			; | | e.g. "MORE" forget 
28b1					if DEBUG_FORTH_WORDS_KEY 
28b1						DMARK "FRG" 
28b1 f5				push af  
28b2 3a c6 28			ld a, (.dmark)  
28b5 32 7a ee			ld (debug_mark),a  
28b8 3a c7 28			ld a, (.dmark+1)  
28bb 32 7b ee			ld (debug_mark+1),a  
28be 3a c8 28			ld a, (.dmark+2)  
28c1 32 7c ee			ld (debug_mark+2),a  
28c4 18 03			jr .pastdmark  
28c6 ..			.dmark: db "FRG"  
28c9 f1			.pastdmark: pop af  
28ca			endm  
# End of macro DMARK
28ca						CALLMONITOR 
28ca cd 77 14			call break_point_state  
28cd				endm  
# End of macro CALLMONITOR
28cd					endif 
28cd			 
28cd				; find uword 
28cd			        ; update start of word with "_" 
28cd				; replace uword with deleted flag 
28cd			 
28cd			 
28cd			;	if DEBUG_FORTH_WORDS 
28cd			;		DMARK "FOG" 
28cd			;		CALLMONITOR 
28cd			;	endif 
28cd			 
28cd			 
28cd					; Get ptr to the word we need to look up 
28cd			 
28cd					FORTH_DSP_VALUEHL 
28cd cd fb 1b			call macro_dsp_valuehl 
28d0				endm 
# End of macro FORTH_DSP_VALUEHL
28d0					;v5 FORTH_DSP_VALUE 
28d0				; TODO type check 
28d0			;		inc hl    ; Skip type check  
28d0 e5					push hl 
28d1 c1					pop bc 
28d2			;		ex de, hl    ; put into DE 
28d2			 
28d2			 
28d2 21 42 59				ld hl, baseram 
28d5					;ld hl, baseusermem 
28d5			 
28d5				; skip dict stub 
28d5			;	call forth_tok_next 
28d5 e5			push hl   ; sacreifical push 
28d6			 
28d6			.fldouscanm: 
28d6 e1				pop hl 
28d7			.fldouscan: 
28d7			;	if DEBUG_FORTH_WORDS 
28d7			;		DMARK "LSs" 
28d7			;		CALLMONITOR 
28d7			;	endif 
28d7				; skip dict stub 
28d7 cd be 1e				call forth_tok_next 
28da			 
28da			 
28da			; while we have words to look for 
28da			 
28da 7e				ld a, (hl)      
28db			;	if DEBUG_FORTH_WORDS 
28db			;		DMARK "LSk" 
28db			;		CALLMONITOR 
28db			;	endif 
28db fe 00				cp WORD_SYS_END 
28dd ca 19 29				jp z, .flunotfound 
28e0 fe 01				cp WORD_SYS_UWORD 
28e2 c2 d7 28				jp nz, .fldouscan 
28e5			 
28e5			;	if DEBUG_FORTH_WORDS 
28e5			;		DMARK "LSu" 
28e5			;		CALLMONITOR 
28e5			;	endif 
28e5			 
28e5					; found a uword but is it the one we want... 
28e5			 
28e5 c5					push bc     ; uword to find is on bc 
28e6 d1					pop de 
28e7			 
28e7 e5					push hl  ; to save the ptr 
28e8			 
28e8					; skip opcode 
28e8 23					inc hl  
28e9					; skip next ptr 
28e9 23					inc hl  
28ea 23					inc hl 
28eb					; skip len 
28eb 23					inc hl 
28ec			 
28ec			;	if DEBUG_FORTH_WORDS 
28ec			;		DMARK "LSc" 
28ec			;		CALLMONITOR 
28ec			;	endif 
28ec cd 5f 10				call strcmp 
28ef c2 d6 28				jp nz, .fldouscanm 
28f2			; 
28f2			; 
28f2			;; while we have words to look for 
28f2			; 
28f2			;.fdouscan:	ld a, (hl)      
28f2			;	if DEBUG_FORTH_WORDS 
28f2			;		DMARK "LSs" 
28f2			;		CALLMONITOR 
28f2			;	endif 
28f2			;		cp WORD_SYS_END 
28f2			;		jp z, .fudone 
28f2			;		cp WORD_SYS_UWORD 
28f2			;		jp nz, .fnuword 
28f2			; 
28f2			;	if DEBUG_FORTH_WORDS 
28f2			;		DMARK "FGu" 
28f2			;		CALLMONITOR 
28f2			;	endif 
28f2			; 
28f2			;		; found a uword but is it the one we want... 
28f2			; 
28f2			; 
28f2			;	        pop de   ; get back the dsp name 
28f2			;		push de 
28f2			; 
28f2			;		push hl  ; to save the ptr 
28f2			; 
28f2			;		; skip opcode 
28f2			;		inc hl  
28f2			;		; skip next ptr 
28f2			;		inc hl  
28f2			;		inc hl 
28f2			;		; skip len 
28f2			;		inc hl 
28f2			; 
28f2			;	if DEBUG_FORTH_WORDS 
28f2			;		DMARK "FGc" 
28f2			;		CALLMONITOR 
28f2			;	endif 
28f2			;		call strcmp 
28f2			;		jp nz, .fnuword 
28f2			 
28f2			 
28f2 e1			pop hl 
28f3			 
28f3				 
28f3				if DEBUG_FORTH_WORDS 
28f3					DMARK "FGm" 
28f3 f5				push af  
28f4 3a 08 29			ld a, (.dmark)  
28f7 32 7a ee			ld (debug_mark),a  
28fa 3a 09 29			ld a, (.dmark+1)  
28fd 32 7b ee			ld (debug_mark+1),a  
2900 3a 0a 29			ld a, (.dmark+2)  
2903 32 7c ee			ld (debug_mark+2),a  
2906 18 03			jr .pastdmark  
2908 ..			.dmark: db "FGm"  
290b f1			.pastdmark: pop af  
290c			endm  
# End of macro DMARK
290c					CALLMONITOR 
290c cd 77 14			call break_point_state  
290f				endm  
# End of macro CALLMONITOR
290f				endif 
290f			 
290f			 
290f			 
290f					; we have a uword so push its name to the stack 
290f			 
290f			;	   	push hl  ; save so we can move to next dict block 
290f			;pop hl 
290f			 
290f					; update opcode to deleted 
290f 3e 03				ld a, WORD_SYS_DELETED 
2911 77					ld (hl), a 
2912			 
2912 23					inc hl  
2913					; skip next ptr 
2913 23					inc hl  
2914 23					inc hl 
2915					; skip len 
2915 23					inc hl 
2916			 
2916					; TODO change parser to skip deleted words but for now mark it out 
2916 3e 5f				ld a, "_" 
2918 77					ld  (hl),a 
2919			 
2919			;		jr .fudone 
2919			; 
2919			;.fnuword:	pop hl 
2919			;		call forth_tok_next 
2919			;		jp .fdouscan  
2919			 
2919			.flunotfound:		  
2919			 
2919			 
2919					 
2919					FORTH_DSP_POP 
2919 cd b3 1c			call macro_forth_dsp_pop 
291c				endm 
# End of macro FORTH_DSP_POP
291c			;		ld hl, .luno 
291c			;.fudone:		 pop hl 
291c					NEXTW 
291c c3 6d 1d			jp macro_next 
291f				endm 
# End of macro NEXTW
291f			.NOP: 
291f				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
291f 61				db WORD_SYS_CORE+77             
2920 46 29			dw .COMO            
2922 04				db 3 + 1 
2923 .. 00			db "NOP",0              
2927				endm 
# End of macro CWHEAD
2927			; | NOP (  --  ) Do nothing | DONE 
2927					if DEBUG_FORTH_WORDS_KEY 
2927						DMARK "NOP" 
2927 f5				push af  
2928 3a 3c 29			ld a, (.dmark)  
292b 32 7a ee			ld (debug_mark),a  
292e 3a 3d 29			ld a, (.dmark+1)  
2931 32 7b ee			ld (debug_mark+1),a  
2934 3a 3e 29			ld a, (.dmark+2)  
2937 32 7c ee			ld (debug_mark+2),a  
293a 18 03			jr .pastdmark  
293c ..			.dmark: db "NOP"  
293f f1			.pastdmark: pop af  
2940			endm  
# End of macro DMARK
2940						CALLMONITOR 
2940 cd 77 14			call break_point_state  
2943				endm  
# End of macro CALLMONITOR
2943					endif 
2943				       NEXTW 
2943 c3 6d 1d			jp macro_next 
2946				endm 
# End of macro NEXTW
2946			.COMO: 
2946				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2946 6e				db WORD_SYS_CORE+90             
2947 98 29			dw .COMC            
2949 02				db 1 + 1 
294a .. 00			db "(",0              
294c				endm 
# End of macro CWHEAD
294c			; | ( ( -- )  Start of comment | DONE 
294c			 
294c			 
294c 2a 61 e6				ld hl, ( os_tok_ptr) 
294f 11 93 29			ld de, .closepar 
2952					 
2952					if DEBUG_FORTH_WORDS 
2952						DMARK ").." 
2952 f5				push af  
2953 3a 67 29			ld a, (.dmark)  
2956 32 7a ee			ld (debug_mark),a  
2959 3a 68 29			ld a, (.dmark+1)  
295c 32 7b ee			ld (debug_mark+1),a  
295f 3a 69 29			ld a, (.dmark+2)  
2962 32 7c ee			ld (debug_mark+2),a  
2965 18 03			jr .pastdmark  
2967 ..			.dmark: db ").."  
296a f1			.pastdmark: pop af  
296b			endm  
# End of macro DMARK
296b						CALLMONITOR 
296b cd 77 14			call break_point_state  
296e				endm  
# End of macro CALLMONITOR
296e					endif 
296e cd 88 1e			call findnexttok  
2971			 
2971					if DEBUG_FORTH_WORDS 
2971						DMARK "IF5" 
2971 f5				push af  
2972 3a 86 29			ld a, (.dmark)  
2975 32 7a ee			ld (debug_mark),a  
2978 3a 87 29			ld a, (.dmark+1)  
297b 32 7b ee			ld (debug_mark+1),a  
297e 3a 88 29			ld a, (.dmark+2)  
2981 32 7c ee			ld (debug_mark+2),a  
2984 18 03			jr .pastdmark  
2986 ..			.dmark: db "IF5"  
2989 f1			.pastdmark: pop af  
298a			endm  
# End of macro DMARK
298a						CALLMONITOR 
298a cd 77 14			call break_point_state  
298d				endm  
# End of macro CALLMONITOR
298d					endif 
298d				; replace below with ) exec using tok_ptr 
298d 22 61 e6			ld (os_tok_ptr), hl 
2990 c3 fe 1d			jp exec1 
2993			 
2993 .. 00			.closepar:   db ")",0 
2995			 
2995				       NEXTW 
2995 c3 6d 1d			jp macro_next 
2998				endm 
# End of macro NEXTW
2998			.COMC: 
2998				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2998 6f				db WORD_SYS_CORE+91             
2999 a1 29			dw .SCRATCH            
299b 02				db 1 + 1 
299c .. 00			db ")",0              
299e				endm 
# End of macro CWHEAD
299e			; | ) ( -- )  End of comment |  DONE  
299e				       NEXTW 
299e c3 6d 1d			jp macro_next 
29a1				endm 
# End of macro NEXTW
29a1			 
29a1			.SCRATCH: 
29a1				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
29a1 6f				db WORD_SYS_CORE+91             
29a2 dc 29			dw .INC            
29a4 08				db 7 + 1 
29a5 .. 00			db "SCRATCH",0              
29ad				endm 
# End of macro CWHEAD
29ad			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
29ad			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
29ad			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
29ad			; | |  
29ad			; | | e.g.    : score $00 scratch ; 
29ad			; | |  
29ad			; | | $00 score ! 
29ad			; | | $01 score +! 
29ad			; | |  
29ad			; | | e.g.   : varword $0a scratch ;  
29ad			; | | 
29ad			; | | $8000 varword ! 
29ad					if DEBUG_FORTH_WORDS_KEY 
29ad						DMARK "SCR" 
29ad f5				push af  
29ae 3a c2 29			ld a, (.dmark)  
29b1 32 7a ee			ld (debug_mark),a  
29b4 3a c3 29			ld a, (.dmark+1)  
29b7 32 7b ee			ld (debug_mark+1),a  
29ba 3a c4 29			ld a, (.dmark+2)  
29bd 32 7c ee			ld (debug_mark+2),a  
29c0 18 03			jr .pastdmark  
29c2 ..			.dmark: db "SCR"  
29c5 f1			.pastdmark: pop af  
29c6			endm  
# End of macro DMARK
29c6						CALLMONITOR 
29c6 cd 77 14			call break_point_state  
29c9				endm  
# End of macro CALLMONITOR
29c9					endif 
29c9			 
29c9					FORTH_DSP_VALUEHL 
29c9 cd fb 1b			call macro_dsp_valuehl 
29cc				endm 
# End of macro FORTH_DSP_VALUEHL
29cc				 
29cc					FORTH_DSP_POP 
29cc cd b3 1c			call macro_forth_dsp_pop 
29cf				endm 
# End of macro FORTH_DSP_POP
29cf			 
29cf 7d					ld a, l 
29d0 21 85 e8				ld hl, os_var_array 
29d3 cd c9 0b				call addatohl 
29d6			 
29d6 cd 04 1a				call forth_push_numhl 
29d9			 
29d9				       NEXTW 
29d9 c3 6d 1d			jp macro_next 
29dc				endm 
# End of macro NEXTW
29dc			 
29dc			.INC: 
29dc				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
29dc 6f				db WORD_SYS_CORE+91             
29dd 30 2a			dw .DEC            
29df 03				db 2 + 1 
29e0 .. 00			db "+!",0              
29e3				endm 
# End of macro CWHEAD
29e3			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
29e3					if DEBUG_FORTH_WORDS_KEY 
29e3						DMARK "+s_" 
29e3 f5				push af  
29e4 3a f8 29			ld a, (.dmark)  
29e7 32 7a ee			ld (debug_mark),a  
29ea 3a f9 29			ld a, (.dmark+1)  
29ed 32 7b ee			ld (debug_mark+1),a  
29f0 3a fa 29			ld a, (.dmark+2)  
29f3 32 7c ee			ld (debug_mark+2),a  
29f6 18 03			jr .pastdmark  
29f8 ..			.dmark: db "+s_"  
29fb f1			.pastdmark: pop af  
29fc			endm  
# End of macro DMARK
29fc						CALLMONITOR 
29fc cd 77 14			call break_point_state  
29ff				endm  
# End of macro CALLMONITOR
29ff					endif 
29ff			 
29ff					FORTH_DSP_VALUEHL 
29ff cd fb 1b			call macro_dsp_valuehl 
2a02				endm 
# End of macro FORTH_DSP_VALUEHL
2a02			 
2a02 e5					push hl   ; save address 
2a03			 
2a03					FORTH_DSP_POP 
2a03 cd b3 1c			call macro_forth_dsp_pop 
2a06				endm 
# End of macro FORTH_DSP_POP
2a06			 
2a06					FORTH_DSP_VALUEHL 
2a06 cd fb 1b			call macro_dsp_valuehl 
2a09				endm 
# End of macro FORTH_DSP_VALUEHL
2a09			 
2a09					FORTH_DSP_POP 
2a09 cd b3 1c			call macro_forth_dsp_pop 
2a0c				endm 
# End of macro FORTH_DSP_POP
2a0c			 
2a0c					; hl contains value to add to byte at a 
2a0c				 
2a0c eb					ex de, hl 
2a0d			 
2a0d e1					pop hl 
2a0e			 
2a0e					if DEBUG_FORTH_WORDS 
2a0e						DMARK "INC" 
2a0e f5				push af  
2a0f 3a 23 2a			ld a, (.dmark)  
2a12 32 7a ee			ld (debug_mark),a  
2a15 3a 24 2a			ld a, (.dmark+1)  
2a18 32 7b ee			ld (debug_mark+1),a  
2a1b 3a 25 2a			ld a, (.dmark+2)  
2a1e 32 7c ee			ld (debug_mark+2),a  
2a21 18 03			jr .pastdmark  
2a23 ..			.dmark: db "INC"  
2a26 f1			.pastdmark: pop af  
2a27			endm  
# End of macro DMARK
2a27						CALLMONITOR 
2a27 cd 77 14			call break_point_state  
2a2a				endm  
# End of macro CALLMONITOR
2a2a					endif 
2a2a			 
2a2a 7e					ld a,(hl) 
2a2b 83					add e 
2a2c 77					ld (hl),a 
2a2d			 
2a2d			 
2a2d			 
2a2d				       NEXTW 
2a2d c3 6d 1d			jp macro_next 
2a30				endm 
# End of macro NEXTW
2a30			 
2a30			.DEC: 
2a30				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2a30 6f				db WORD_SYS_CORE+91             
2a31 81 2a			dw .INC2            
2a33 03				db 2 + 1 
2a34 .. 00			db "-!",0              
2a37				endm 
# End of macro CWHEAD
2a37			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2a37					if DEBUG_FORTH_WORDS_KEY 
2a37						DMARK "-s_" 
2a37 f5				push af  
2a38 3a 4c 2a			ld a, (.dmark)  
2a3b 32 7a ee			ld (debug_mark),a  
2a3e 3a 4d 2a			ld a, (.dmark+1)  
2a41 32 7b ee			ld (debug_mark+1),a  
2a44 3a 4e 2a			ld a, (.dmark+2)  
2a47 32 7c ee			ld (debug_mark+2),a  
2a4a 18 03			jr .pastdmark  
2a4c ..			.dmark: db "-s_"  
2a4f f1			.pastdmark: pop af  
2a50			endm  
# End of macro DMARK
2a50						CALLMONITOR 
2a50 cd 77 14			call break_point_state  
2a53				endm  
# End of macro CALLMONITOR
2a53					endif 
2a53			 
2a53					FORTH_DSP_VALUEHL 
2a53 cd fb 1b			call macro_dsp_valuehl 
2a56				endm 
# End of macro FORTH_DSP_VALUEHL
2a56			 
2a56 e5					push hl   ; save address 
2a57			 
2a57					FORTH_DSP_POP 
2a57 cd b3 1c			call macro_forth_dsp_pop 
2a5a				endm 
# End of macro FORTH_DSP_POP
2a5a			 
2a5a					FORTH_DSP_VALUEHL 
2a5a cd fb 1b			call macro_dsp_valuehl 
2a5d				endm 
# End of macro FORTH_DSP_VALUEHL
2a5d			 
2a5d					; hl contains value to add to byte at a 
2a5d				 
2a5d eb					ex de, hl 
2a5e			 
2a5e e1					pop hl 
2a5f			 
2a5f					if DEBUG_FORTH_WORDS 
2a5f						DMARK "DEC" 
2a5f f5				push af  
2a60 3a 74 2a			ld a, (.dmark)  
2a63 32 7a ee			ld (debug_mark),a  
2a66 3a 75 2a			ld a, (.dmark+1)  
2a69 32 7b ee			ld (debug_mark+1),a  
2a6c 3a 76 2a			ld a, (.dmark+2)  
2a6f 32 7c ee			ld (debug_mark+2),a  
2a72 18 03			jr .pastdmark  
2a74 ..			.dmark: db "DEC"  
2a77 f1			.pastdmark: pop af  
2a78			endm  
# End of macro DMARK
2a78						CALLMONITOR 
2a78 cd 77 14			call break_point_state  
2a7b				endm  
# End of macro CALLMONITOR
2a7b					endif 
2a7b			 
2a7b 7e					ld a,(hl) 
2a7c 93					sub e 
2a7d 77					ld (hl),a 
2a7e			 
2a7e			 
2a7e			 
2a7e				       NEXTW 
2a7e c3 6d 1d			jp macro_next 
2a81				endm 
# End of macro NEXTW
2a81			 
2a81			.INC2: 
2a81				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2a81 6f				db WORD_SYS_CORE+91             
2a82 2b 2b			dw .DEC2            
2a84 04				db 3 + 1 
2a85 .. 00			db "+2!",0              
2a89				endm 
# End of macro CWHEAD
2a89			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2a89			 
2a89					if DEBUG_FORTH_WORDS_KEY 
2a89						DMARK "+2s" 
2a89 f5				push af  
2a8a 3a 9e 2a			ld a, (.dmark)  
2a8d 32 7a ee			ld (debug_mark),a  
2a90 3a 9f 2a			ld a, (.dmark+1)  
2a93 32 7b ee			ld (debug_mark+1),a  
2a96 3a a0 2a			ld a, (.dmark+2)  
2a99 32 7c ee			ld (debug_mark+2),a  
2a9c 18 03			jr .pastdmark  
2a9e ..			.dmark: db "+2s"  
2aa1 f1			.pastdmark: pop af  
2aa2			endm  
# End of macro DMARK
2aa2						CALLMONITOR 
2aa2 cd 77 14			call break_point_state  
2aa5				endm  
# End of macro CALLMONITOR
2aa5					endif 
2aa5			 
2aa5					; Address 
2aa5			 
2aa5					FORTH_DSP_VALUEHL 
2aa5 cd fb 1b			call macro_dsp_valuehl 
2aa8				endm 
# End of macro FORTH_DSP_VALUEHL
2aa8			 
2aa8 e5					push hl    ; save address 
2aa9			 
2aa9					; load content into de 
2aa9			 
2aa9 5e					ld e,(hl) 
2aaa 23					inc hl 
2aab 56					ld d, (hl) 
2aac			 
2aac					if DEBUG_FORTH_WORDS 
2aac						DMARK "+2a" 
2aac f5				push af  
2aad 3a c1 2a			ld a, (.dmark)  
2ab0 32 7a ee			ld (debug_mark),a  
2ab3 3a c2 2a			ld a, (.dmark+1)  
2ab6 32 7b ee			ld (debug_mark+1),a  
2ab9 3a c3 2a			ld a, (.dmark+2)  
2abc 32 7c ee			ld (debug_mark+2),a  
2abf 18 03			jr .pastdmark  
2ac1 ..			.dmark: db "+2a"  
2ac4 f1			.pastdmark: pop af  
2ac5			endm  
# End of macro DMARK
2ac5						CALLMONITOR 
2ac5 cd 77 14			call break_point_state  
2ac8				endm  
# End of macro CALLMONITOR
2ac8					endif 
2ac8			 
2ac8					FORTH_DSP_POP 
2ac8 cd b3 1c			call macro_forth_dsp_pop 
2acb				endm 
# End of macro FORTH_DSP_POP
2acb			 
2acb					; Get value to add 
2acb			 
2acb					FORTH_DSP_VALUE 
2acb cd e4 1b			call macro_forth_dsp_value 
2ace				endm 
# End of macro FORTH_DSP_VALUE
2ace			 
2ace					if DEBUG_FORTH_WORDS 
2ace						DMARK "+2v" 
2ace f5				push af  
2acf 3a e3 2a			ld a, (.dmark)  
2ad2 32 7a ee			ld (debug_mark),a  
2ad5 3a e4 2a			ld a, (.dmark+1)  
2ad8 32 7b ee			ld (debug_mark+1),a  
2adb 3a e5 2a			ld a, (.dmark+2)  
2ade 32 7c ee			ld (debug_mark+2),a  
2ae1 18 03			jr .pastdmark  
2ae3 ..			.dmark: db "+2v"  
2ae6 f1			.pastdmark: pop af  
2ae7			endm  
# End of macro DMARK
2ae7						CALLMONITOR 
2ae7 cd 77 14			call break_point_state  
2aea				endm  
# End of macro CALLMONITOR
2aea					endif 
2aea			 
2aea 19					add hl, de 
2aeb			 
2aeb					if DEBUG_FORTH_WORDS 
2aeb						DMARK "+2+" 
2aeb f5				push af  
2aec 3a 00 2b			ld a, (.dmark)  
2aef 32 7a ee			ld (debug_mark),a  
2af2 3a 01 2b			ld a, (.dmark+1)  
2af5 32 7b ee			ld (debug_mark+1),a  
2af8 3a 02 2b			ld a, (.dmark+2)  
2afb 32 7c ee			ld (debug_mark+2),a  
2afe 18 03			jr .pastdmark  
2b00 ..			.dmark: db "+2+"  
2b03 f1			.pastdmark: pop af  
2b04			endm  
# End of macro DMARK
2b04						CALLMONITOR 
2b04 cd 77 14			call break_point_state  
2b07				endm  
# End of macro CALLMONITOR
2b07					endif 
2b07			 
2b07					; move result to de 
2b07			 
2b07 eb					ex de, hl 
2b08			 
2b08					; Address 
2b08			 
2b08 e1					pop hl 
2b09			 
2b09					; save it back 
2b09			 
2b09 73					ld (hl), e 
2b0a 23					inc hl 
2b0b 72					ld (hl), d 
2b0c			 
2b0c					if DEBUG_FORTH_WORDS 
2b0c						DMARK "+2e" 
2b0c f5				push af  
2b0d 3a 21 2b			ld a, (.dmark)  
2b10 32 7a ee			ld (debug_mark),a  
2b13 3a 22 2b			ld a, (.dmark+1)  
2b16 32 7b ee			ld (debug_mark+1),a  
2b19 3a 23 2b			ld a, (.dmark+2)  
2b1c 32 7c ee			ld (debug_mark+2),a  
2b1f 18 03			jr .pastdmark  
2b21 ..			.dmark: db "+2e"  
2b24 f1			.pastdmark: pop af  
2b25			endm  
# End of macro DMARK
2b25						CALLMONITOR 
2b25 cd 77 14			call break_point_state  
2b28				endm  
# End of macro CALLMONITOR
2b28					endif 
2b28			 
2b28			 
2b28			 
2b28			 
2b28			 
2b28				       NEXTW 
2b28 c3 6d 1d			jp macro_next 
2b2b				endm 
# End of macro NEXTW
2b2b			 
2b2b			.DEC2: 
2b2b				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2b2b 6f				db WORD_SYS_CORE+91             
2b2c d7 2b			dw .GET2            
2b2e 04				db 3 + 1 
2b2f .. 00			db "-2!",0              
2b33				endm 
# End of macro CWHEAD
2b33			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2b33			 
2b33			 
2b33					if DEBUG_FORTH_WORDS_KEY 
2b33						DMARK "-2s" 
2b33 f5				push af  
2b34 3a 48 2b			ld a, (.dmark)  
2b37 32 7a ee			ld (debug_mark),a  
2b3a 3a 49 2b			ld a, (.dmark+1)  
2b3d 32 7b ee			ld (debug_mark+1),a  
2b40 3a 4a 2b			ld a, (.dmark+2)  
2b43 32 7c ee			ld (debug_mark+2),a  
2b46 18 03			jr .pastdmark  
2b48 ..			.dmark: db "-2s"  
2b4b f1			.pastdmark: pop af  
2b4c			endm  
# End of macro DMARK
2b4c						CALLMONITOR 
2b4c cd 77 14			call break_point_state  
2b4f				endm  
# End of macro CALLMONITOR
2b4f					endif 
2b4f			 
2b4f					; Address 
2b4f			 
2b4f					FORTH_DSP_VALUEHL 
2b4f cd fb 1b			call macro_dsp_valuehl 
2b52				endm 
# End of macro FORTH_DSP_VALUEHL
2b52			 
2b52 e5					push hl    ; save address 
2b53			 
2b53					; load content into de 
2b53			 
2b53 5e					ld e,(hl) 
2b54 23					inc hl 
2b55 56					ld d, (hl) 
2b56			 
2b56					if DEBUG_FORTH_WORDS 
2b56						DMARK "-2a" 
2b56 f5				push af  
2b57 3a 6b 2b			ld a, (.dmark)  
2b5a 32 7a ee			ld (debug_mark),a  
2b5d 3a 6c 2b			ld a, (.dmark+1)  
2b60 32 7b ee			ld (debug_mark+1),a  
2b63 3a 6d 2b			ld a, (.dmark+2)  
2b66 32 7c ee			ld (debug_mark+2),a  
2b69 18 03			jr .pastdmark  
2b6b ..			.dmark: db "-2a"  
2b6e f1			.pastdmark: pop af  
2b6f			endm  
# End of macro DMARK
2b6f						CALLMONITOR 
2b6f cd 77 14			call break_point_state  
2b72				endm  
# End of macro CALLMONITOR
2b72					endif 
2b72			 
2b72					FORTH_DSP_POP 
2b72 cd b3 1c			call macro_forth_dsp_pop 
2b75				endm 
# End of macro FORTH_DSP_POP
2b75			 
2b75					; Get value to remove 
2b75			 
2b75					FORTH_DSP_VALUE 
2b75 cd e4 1b			call macro_forth_dsp_value 
2b78				endm 
# End of macro FORTH_DSP_VALUE
2b78			 
2b78					if DEBUG_FORTH_WORDS 
2b78						DMARK "-2v" 
2b78 f5				push af  
2b79 3a 8d 2b			ld a, (.dmark)  
2b7c 32 7a ee			ld (debug_mark),a  
2b7f 3a 8e 2b			ld a, (.dmark+1)  
2b82 32 7b ee			ld (debug_mark+1),a  
2b85 3a 8f 2b			ld a, (.dmark+2)  
2b88 32 7c ee			ld (debug_mark+2),a  
2b8b 18 03			jr .pastdmark  
2b8d ..			.dmark: db "-2v"  
2b90 f1			.pastdmark: pop af  
2b91			endm  
# End of macro DMARK
2b91						CALLMONITOR 
2b91 cd 77 14			call break_point_state  
2b94				endm  
# End of macro CALLMONITOR
2b94					endif 
2b94			 
2b94 eb					ex de, hl 
2b95 ed 52				sbc hl, de 
2b97			 
2b97					if DEBUG_FORTH_WORDS 
2b97						DMARK "-2d" 
2b97 f5				push af  
2b98 3a ac 2b			ld a, (.dmark)  
2b9b 32 7a ee			ld (debug_mark),a  
2b9e 3a ad 2b			ld a, (.dmark+1)  
2ba1 32 7b ee			ld (debug_mark+1),a  
2ba4 3a ae 2b			ld a, (.dmark+2)  
2ba7 32 7c ee			ld (debug_mark+2),a  
2baa 18 03			jr .pastdmark  
2bac ..			.dmark: db "-2d"  
2baf f1			.pastdmark: pop af  
2bb0			endm  
# End of macro DMARK
2bb0						CALLMONITOR 
2bb0 cd 77 14			call break_point_state  
2bb3				endm  
# End of macro CALLMONITOR
2bb3					endif 
2bb3			 
2bb3					; move result to de 
2bb3			 
2bb3 eb					ex de, hl 
2bb4			 
2bb4					; Address 
2bb4			 
2bb4 e1					pop hl 
2bb5			 
2bb5					; save it back 
2bb5			 
2bb5 73					ld (hl), e 
2bb6 23					inc hl 
2bb7 72					ld (hl), d 
2bb8			 
2bb8					if DEBUG_FORTH_WORDS 
2bb8						DMARK "-2e" 
2bb8 f5				push af  
2bb9 3a cd 2b			ld a, (.dmark)  
2bbc 32 7a ee			ld (debug_mark),a  
2bbf 3a ce 2b			ld a, (.dmark+1)  
2bc2 32 7b ee			ld (debug_mark+1),a  
2bc5 3a cf 2b			ld a, (.dmark+2)  
2bc8 32 7c ee			ld (debug_mark+2),a  
2bcb 18 03			jr .pastdmark  
2bcd ..			.dmark: db "-2e"  
2bd0 f1			.pastdmark: pop af  
2bd1			endm  
# End of macro DMARK
2bd1						CALLMONITOR 
2bd1 cd 77 14			call break_point_state  
2bd4				endm  
# End of macro CALLMONITOR
2bd4					endif 
2bd4			 
2bd4			 
2bd4			 
2bd4			 
2bd4			 
2bd4				       NEXTW 
2bd4 c3 6d 1d			jp macro_next 
2bd7				endm 
# End of macro NEXTW
2bd7			.GET2: 
2bd7				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2bd7 6f				db WORD_SYS_CORE+91             
2bd8 07 2c			dw .BANG2            
2bda 03				db 2 + 1 
2bdb .. 00			db "2@",0              
2bde				endm 
# End of macro CWHEAD
2bde			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2bde					if DEBUG_FORTH_WORDS_KEY 
2bde						DMARK "2A_" 
2bde f5				push af  
2bdf 3a f3 2b			ld a, (.dmark)  
2be2 32 7a ee			ld (debug_mark),a  
2be5 3a f4 2b			ld a, (.dmark+1)  
2be8 32 7b ee			ld (debug_mark+1),a  
2beb 3a f5 2b			ld a, (.dmark+2)  
2bee 32 7c ee			ld (debug_mark+2),a  
2bf1 18 03			jr .pastdmark  
2bf3 ..			.dmark: db "2A_"  
2bf6 f1			.pastdmark: pop af  
2bf7			endm  
# End of macro DMARK
2bf7						CALLMONITOR 
2bf7 cd 77 14			call break_point_state  
2bfa				endm  
# End of macro CALLMONITOR
2bfa					endif 
2bfa			 
2bfa					FORTH_DSP_VALUEHL 
2bfa cd fb 1b			call macro_dsp_valuehl 
2bfd				endm 
# End of macro FORTH_DSP_VALUEHL
2bfd			 
2bfd 5e					ld e, (hl) 
2bfe 23					inc hl 
2bff 56					ld d, (hl) 
2c00			 
2c00 eb					ex de, hl 
2c01			 
2c01 cd 04 1a				call forth_push_numhl 
2c04			 
2c04				       NEXTW 
2c04 c3 6d 1d			jp macro_next 
2c07				endm 
# End of macro NEXTW
2c07			.BANG2: 
2c07				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2c07 6f				db WORD_SYS_CORE+91             
2c08 3f 2c			dw .CONFIG            
2c0a 03				db 2 + 1 
2c0b .. 00			db "2!",0              
2c0e				endm 
# End of macro CWHEAD
2c0e			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2c0e					if DEBUG_FORTH_WORDS_KEY 
2c0e						DMARK "2S_" 
2c0e f5				push af  
2c0f 3a 23 2c			ld a, (.dmark)  
2c12 32 7a ee			ld (debug_mark),a  
2c15 3a 24 2c			ld a, (.dmark+1)  
2c18 32 7b ee			ld (debug_mark+1),a  
2c1b 3a 25 2c			ld a, (.dmark+2)  
2c1e 32 7c ee			ld (debug_mark+2),a  
2c21 18 03			jr .pastdmark  
2c23 ..			.dmark: db "2S_"  
2c26 f1			.pastdmark: pop af  
2c27			endm  
# End of macro DMARK
2c27						CALLMONITOR 
2c27 cd 77 14			call break_point_state  
2c2a				endm  
# End of macro CALLMONITOR
2c2a					endif 
2c2a			 
2c2a					FORTH_DSP_VALUEHL 
2c2a cd fb 1b			call macro_dsp_valuehl 
2c2d				endm 
# End of macro FORTH_DSP_VALUEHL
2c2d			 
2c2d e5					push hl   ; save address 
2c2e			 
2c2e			 
2c2e					FORTH_DSP_POP 
2c2e cd b3 1c			call macro_forth_dsp_pop 
2c31				endm 
# End of macro FORTH_DSP_POP
2c31			 
2c31					 
2c31					FORTH_DSP_VALUEHL 
2c31 cd fb 1b			call macro_dsp_valuehl 
2c34				endm 
# End of macro FORTH_DSP_VALUEHL
2c34			 
2c34					FORTH_DSP_POP 
2c34 cd b3 1c			call macro_forth_dsp_pop 
2c37				endm 
# End of macro FORTH_DSP_POP
2c37			 
2c37 eb					ex de, hl    ; value now in de 
2c38			 
2c38 e1					pop hl 
2c39			 
2c39 73					ld (hl), e 
2c3a			 
2c3a 23					inc hl 
2c3b			 
2c3b 72					ld (hl), d 
2c3c			 
2c3c			 
2c3c				       NEXTW 
2c3c c3 6d 1d			jp macro_next 
2c3f				endm 
# End of macro NEXTW
2c3f			.CONFIG: 
2c3f				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2c3f 6f				db WORD_SYS_CORE+91             
2c40 50 2c			dw .ENDCORE            
2c42 07				db 6 + 1 
2c43 .. 00			db "CONFIG",0              
2c4a				endm 
# End of macro CWHEAD
2c4a			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2c4a			 
2c4a cd 29 12				call config 
2c4d					NEXTW 
2c4d c3 6d 1d			jp macro_next 
2c50				endm 
# End of macro NEXTW
2c50			.ENDCORE: 
2c50			 
2c50			; eof 
2c50			 
2c50			 
# End of file forth_words_core.asm
2c50			include "forth_words_flow.asm" 
2c50			 
2c50			; | ## Program Flow Words 
2c50			 
2c50			.IF: 
2c50				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2c50 1e				db WORD_SYS_CORE+10             
2c51 45 2d			dw .THEN            
2c53 03				db 2 + 1 
2c54 .. 00			db "IF",0              
2c57				endm 
# End of macro CWHEAD
2c57			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2c57			; 
2c57					if DEBUG_FORTH_WORDS_KEY 
2c57						DMARK "IF." 
2c57 f5				push af  
2c58 3a 6c 2c			ld a, (.dmark)  
2c5b 32 7a ee			ld (debug_mark),a  
2c5e 3a 6d 2c			ld a, (.dmark+1)  
2c61 32 7b ee			ld (debug_mark+1),a  
2c64 3a 6e 2c			ld a, (.dmark+2)  
2c67 32 7c ee			ld (debug_mark+2),a  
2c6a 18 03			jr .pastdmark  
2c6c ..			.dmark: db "IF."  
2c6f f1			.pastdmark: pop af  
2c70			endm  
# End of macro DMARK
2c70						CALLMONITOR 
2c70 cd 77 14			call break_point_state  
2c73				endm  
# End of macro CALLMONITOR
2c73					endif 
2c73			; eval TOS 
2c73			 
2c73				FORTH_DSP_VALUEHL 
2c73 cd fb 1b			call macro_dsp_valuehl 
2c76				endm 
# End of macro FORTH_DSP_VALUEHL
2c76			 
2c76			;	push hl 
2c76				FORTH_DSP_POP 
2c76 cd b3 1c			call macro_forth_dsp_pop 
2c79				endm 
# End of macro FORTH_DSP_POP
2c79			;	pop hl 
2c79			 
2c79					if DEBUG_FORTH_WORDS 
2c79						DMARK "IF1" 
2c79 f5				push af  
2c7a 3a 8e 2c			ld a, (.dmark)  
2c7d 32 7a ee			ld (debug_mark),a  
2c80 3a 8f 2c			ld a, (.dmark+1)  
2c83 32 7b ee			ld (debug_mark+1),a  
2c86 3a 90 2c			ld a, (.dmark+2)  
2c89 32 7c ee			ld (debug_mark+2),a  
2c8c 18 03			jr .pastdmark  
2c8e ..			.dmark: db "IF1"  
2c91 f1			.pastdmark: pop af  
2c92			endm  
# End of macro DMARK
2c92						CALLMONITOR 
2c92 cd 77 14			call break_point_state  
2c95				endm  
# End of macro CALLMONITOR
2c95					endif 
2c95 b7				or a        ; clear carry flag 
2c96 11 00 00			ld de, 0 
2c99 eb				ex de,hl 
2c9a ed 52			sbc hl, de 
2c9c c2 26 2d			jp nz, .iftrue 
2c9f			 
2c9f					if DEBUG_FORTH_WORDS 
2c9f						DMARK "IF2" 
2c9f f5				push af  
2ca0 3a b4 2c			ld a, (.dmark)  
2ca3 32 7a ee			ld (debug_mark),a  
2ca6 3a b5 2c			ld a, (.dmark+1)  
2ca9 32 7b ee			ld (debug_mark+1),a  
2cac 3a b6 2c			ld a, (.dmark+2)  
2caf 32 7c ee			ld (debug_mark+2),a  
2cb2 18 03			jr .pastdmark  
2cb4 ..			.dmark: db "IF2"  
2cb7 f1			.pastdmark: pop af  
2cb8			endm  
# End of macro DMARK
2cb8						CALLMONITOR 
2cb8 cd 77 14			call break_point_state  
2cbb				endm  
# End of macro CALLMONITOR
2cbb					endif 
2cbb			 
2cbb			; if not true then skip to THEN 
2cbb			 
2cbb				; TODO get tok_ptr 
2cbb				; TODO consume toks until we get to THEN 
2cbb			 
2cbb 2a 61 e6			ld hl, (os_tok_ptr) 
2cbe					if DEBUG_FORTH_WORDS 
2cbe						DMARK "IF3" 
2cbe f5				push af  
2cbf 3a d3 2c			ld a, (.dmark)  
2cc2 32 7a ee			ld (debug_mark),a  
2cc5 3a d4 2c			ld a, (.dmark+1)  
2cc8 32 7b ee			ld (debug_mark+1),a  
2ccb 3a d5 2c			ld a, (.dmark+2)  
2cce 32 7c ee			ld (debug_mark+2),a  
2cd1 18 03			jr .pastdmark  
2cd3 ..			.dmark: db "IF3"  
2cd6 f1			.pastdmark: pop af  
2cd7			endm  
# End of macro DMARK
2cd7						CALLMONITOR 
2cd7 cd 77 14			call break_point_state  
2cda				endm  
# End of macro CALLMONITOR
2cda						 
2cda					endif 
2cda 11 21 2d			ld de, .ifthen 
2cdd					if DEBUG_FORTH_WORDS 
2cdd						DMARK "IF4" 
2cdd f5				push af  
2cde 3a f2 2c			ld a, (.dmark)  
2ce1 32 7a ee			ld (debug_mark),a  
2ce4 3a f3 2c			ld a, (.dmark+1)  
2ce7 32 7b ee			ld (debug_mark+1),a  
2cea 3a f4 2c			ld a, (.dmark+2)  
2ced 32 7c ee			ld (debug_mark+2),a  
2cf0 18 03			jr .pastdmark  
2cf2 ..			.dmark: db "IF4"  
2cf5 f1			.pastdmark: pop af  
2cf6			endm  
# End of macro DMARK
2cf6						CALLMONITOR 
2cf6 cd 77 14			call break_point_state  
2cf9				endm  
# End of macro CALLMONITOR
2cf9					endif 
2cf9 cd 88 1e			call findnexttok  
2cfc			 
2cfc					if DEBUG_FORTH_WORDS 
2cfc						DMARK "IF5" 
2cfc f5				push af  
2cfd 3a 11 2d			ld a, (.dmark)  
2d00 32 7a ee			ld (debug_mark),a  
2d03 3a 12 2d			ld a, (.dmark+1)  
2d06 32 7b ee			ld (debug_mark+1),a  
2d09 3a 13 2d			ld a, (.dmark+2)  
2d0c 32 7c ee			ld (debug_mark+2),a  
2d0f 18 03			jr .pastdmark  
2d11 ..			.dmark: db "IF5"  
2d14 f1			.pastdmark: pop af  
2d15			endm  
# End of macro DMARK
2d15						CALLMONITOR 
2d15 cd 77 14			call break_point_state  
2d18				endm  
# End of macro CALLMONITOR
2d18					endif 
2d18				; TODO replace below with ; exec using tok_ptr 
2d18 22 61 e6			ld (os_tok_ptr), hl 
2d1b c3 fe 1d			jp exec1 
2d1e				NEXTW 
2d1e c3 6d 1d			jp macro_next 
2d21				endm 
# End of macro NEXTW
2d21			 
2d21 .. 00		.ifthen:  db "THEN",0 
2d26			 
2d26			.iftrue:		 
2d26				; Exec next words normally 
2d26			 
2d26				; if true then exec following IF as normal 
2d26					if DEBUG_FORTH_WORDS 
2d26						DMARK "IFT" 
2d26 f5				push af  
2d27 3a 3b 2d			ld a, (.dmark)  
2d2a 32 7a ee			ld (debug_mark),a  
2d2d 3a 3c 2d			ld a, (.dmark+1)  
2d30 32 7b ee			ld (debug_mark+1),a  
2d33 3a 3d 2d			ld a, (.dmark+2)  
2d36 32 7c ee			ld (debug_mark+2),a  
2d39 18 03			jr .pastdmark  
2d3b ..			.dmark: db "IFT"  
2d3e f1			.pastdmark: pop af  
2d3f			endm  
# End of macro DMARK
2d3f						CALLMONITOR 
2d3f cd 77 14			call break_point_state  
2d42				endm  
# End of macro CALLMONITOR
2d42					endif 
2d42			 
2d42					NEXTW 
2d42 c3 6d 1d			jp macro_next 
2d45				endm 
# End of macro NEXTW
2d45			.THEN: 
2d45				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2d45 1f				db WORD_SYS_CORE+11             
2d46 6d 2d			dw .ELSE            
2d48 05				db 4 + 1 
2d49 .. 00			db "THEN",0              
2d4e				endm 
# End of macro CWHEAD
2d4e			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2d4e					if DEBUG_FORTH_WORDS_KEY 
2d4e						DMARK "THN" 
2d4e f5				push af  
2d4f 3a 63 2d			ld a, (.dmark)  
2d52 32 7a ee			ld (debug_mark),a  
2d55 3a 64 2d			ld a, (.dmark+1)  
2d58 32 7b ee			ld (debug_mark+1),a  
2d5b 3a 65 2d			ld a, (.dmark+2)  
2d5e 32 7c ee			ld (debug_mark+2),a  
2d61 18 03			jr .pastdmark  
2d63 ..			.dmark: db "THN"  
2d66 f1			.pastdmark: pop af  
2d67			endm  
# End of macro DMARK
2d67						CALLMONITOR 
2d67 cd 77 14			call break_point_state  
2d6a				endm  
# End of macro CALLMONITOR
2d6a					endif 
2d6a					NEXTW 
2d6a c3 6d 1d			jp macro_next 
2d6d				endm 
# End of macro NEXTW
2d6d			.ELSE: 
2d6d				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2d6d 20				db WORD_SYS_CORE+12             
2d6e 95 2d			dw .DO            
2d70 03				db 2 + 1 
2d71 .. 00			db "ELSE",0              
2d76				endm 
# End of macro CWHEAD
2d76			; | ELSE ( -- ) Not supported - does nothing | TODO 
2d76			 
2d76					if DEBUG_FORTH_WORDS_KEY 
2d76						DMARK "ELS" 
2d76 f5				push af  
2d77 3a 8b 2d			ld a, (.dmark)  
2d7a 32 7a ee			ld (debug_mark),a  
2d7d 3a 8c 2d			ld a, (.dmark+1)  
2d80 32 7b ee			ld (debug_mark+1),a  
2d83 3a 8d 2d			ld a, (.dmark+2)  
2d86 32 7c ee			ld (debug_mark+2),a  
2d89 18 03			jr .pastdmark  
2d8b ..			.dmark: db "ELS"  
2d8e f1			.pastdmark: pop af  
2d8f			endm  
# End of macro DMARK
2d8f						CALLMONITOR 
2d8f cd 77 14			call break_point_state  
2d92				endm  
# End of macro CALLMONITOR
2d92					endif 
2d92			 
2d92			 
2d92					NEXTW 
2d92 c3 6d 1d			jp macro_next 
2d95				endm 
# End of macro NEXTW
2d95			.DO: 
2d95				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2d95 21				db WORD_SYS_CORE+13             
2d96 bc 2e			dw .LOOP            
2d98 03				db 2 + 1 
2d99 .. 00			db "DO",0              
2d9c				endm 
# End of macro CWHEAD
2d9c			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2d9c			 
2d9c					if DEBUG_FORTH_WORDS_KEY 
2d9c						DMARK "DO." 
2d9c f5				push af  
2d9d 3a b1 2d			ld a, (.dmark)  
2da0 32 7a ee			ld (debug_mark),a  
2da3 3a b2 2d			ld a, (.dmark+1)  
2da6 32 7b ee			ld (debug_mark+1),a  
2da9 3a b3 2d			ld a, (.dmark+2)  
2dac 32 7c ee			ld (debug_mark+2),a  
2daf 18 03			jr .pastdmark  
2db1 ..			.dmark: db "DO."  
2db4 f1			.pastdmark: pop af  
2db5			endm  
# End of macro DMARK
2db5						CALLMONITOR 
2db5 cd 77 14			call break_point_state  
2db8				endm  
# End of macro CALLMONITOR
2db8					endif 
2db8			;  push pc to rsp stack past the DO 
2db8			 
2db8 2a 61 e6				ld hl, (os_tok_ptr) 
2dbb 23					inc hl   ; D 
2dbc 23					inc hl  ; O 
2dbd 23					inc hl   ; null 
2dbe					if DEBUG_FORTH_WORDS 
2dbe						DMARK "DO2" 
2dbe f5				push af  
2dbf 3a d3 2d			ld a, (.dmark)  
2dc2 32 7a ee			ld (debug_mark),a  
2dc5 3a d4 2d			ld a, (.dmark+1)  
2dc8 32 7b ee			ld (debug_mark+1),a  
2dcb 3a d5 2d			ld a, (.dmark+2)  
2dce 32 7c ee			ld (debug_mark+2),a  
2dd1 18 03			jr .pastdmark  
2dd3 ..			.dmark: db "DO2"  
2dd6 f1			.pastdmark: pop af  
2dd7			endm  
# End of macro DMARK
2dd7						CALLMONITOR 
2dd7 cd 77 14			call break_point_state  
2dda				endm  
# End of macro CALLMONITOR
2dda					endif 
2dda					FORTH_RSP_NEXT 
2dda cd ab 19			call macro_forth_rsp_next 
2ddd				endm 
# End of macro FORTH_RSP_NEXT
2ddd					if DEBUG_FORTH_WORDS 
2ddd						DMARK "DO3" 
2ddd f5				push af  
2dde 3a f2 2d			ld a, (.dmark)  
2de1 32 7a ee			ld (debug_mark),a  
2de4 3a f3 2d			ld a, (.dmark+1)  
2de7 32 7b ee			ld (debug_mark+1),a  
2dea 3a f4 2d			ld a, (.dmark+2)  
2ded 32 7c ee			ld (debug_mark+2),a  
2df0 18 03			jr .pastdmark  
2df2 ..			.dmark: db "DO3"  
2df5 f1			.pastdmark: pop af  
2df6			endm  
# End of macro DMARK
2df6						CALLMONITOR 
2df6 cd 77 14			call break_point_state  
2df9				endm  
# End of macro CALLMONITOR
2df9					endif 
2df9			 
2df9					;if DEBUG_FORTH_WORDS 
2df9				;		push hl 
2df9			;		endif  
2df9			 
2df9			; get counters from data stack 
2df9			 
2df9			 
2df9					FORTH_DSP_VALUEHL 
2df9 cd fb 1b			call macro_dsp_valuehl 
2dfc				endm 
# End of macro FORTH_DSP_VALUEHL
2dfc e5					push hl		 ; hl now has starting counter which needs to be tos 
2dfd			 
2dfd					if DEBUG_FORTH_WORDS 
2dfd						DMARK "DO4" 
2dfd f5				push af  
2dfe 3a 12 2e			ld a, (.dmark)  
2e01 32 7a ee			ld (debug_mark),a  
2e04 3a 13 2e			ld a, (.dmark+1)  
2e07 32 7b ee			ld (debug_mark+1),a  
2e0a 3a 14 2e			ld a, (.dmark+2)  
2e0d 32 7c ee			ld (debug_mark+2),a  
2e10 18 03			jr .pastdmark  
2e12 ..			.dmark: db "DO4"  
2e15 f1			.pastdmark: pop af  
2e16			endm  
# End of macro DMARK
2e16						CALLMONITOR 
2e16 cd 77 14			call break_point_state  
2e19				endm  
# End of macro CALLMONITOR
2e19					endif 
2e19					FORTH_DSP_POP 
2e19 cd b3 1c			call macro_forth_dsp_pop 
2e1c				endm 
# End of macro FORTH_DSP_POP
2e1c			 
2e1c					if DEBUG_FORTH_WORDS 
2e1c						DMARK "DO5" 
2e1c f5				push af  
2e1d 3a 31 2e			ld a, (.dmark)  
2e20 32 7a ee			ld (debug_mark),a  
2e23 3a 32 2e			ld a, (.dmark+1)  
2e26 32 7b ee			ld (debug_mark+1),a  
2e29 3a 33 2e			ld a, (.dmark+2)  
2e2c 32 7c ee			ld (debug_mark+2),a  
2e2f 18 03			jr .pastdmark  
2e31 ..			.dmark: db "DO5"  
2e34 f1			.pastdmark: pop af  
2e35			endm  
# End of macro DMARK
2e35						CALLMONITOR 
2e35 cd 77 14			call break_point_state  
2e38				endm  
# End of macro CALLMONITOR
2e38					endif 
2e38			 
2e38					FORTH_DSP_VALUEHL 
2e38 cd fb 1b			call macro_dsp_valuehl 
2e3b				endm 
# End of macro FORTH_DSP_VALUEHL
2e3b			;		push hl		 ; hl now has starting limit counter 
2e3b			 
2e3b					if DEBUG_FORTH_WORDS 
2e3b						DMARK "DO6" 
2e3b f5				push af  
2e3c 3a 50 2e			ld a, (.dmark)  
2e3f 32 7a ee			ld (debug_mark),a  
2e42 3a 51 2e			ld a, (.dmark+1)  
2e45 32 7b ee			ld (debug_mark+1),a  
2e48 3a 52 2e			ld a, (.dmark+2)  
2e4b 32 7c ee			ld (debug_mark+2),a  
2e4e 18 03			jr .pastdmark  
2e50 ..			.dmark: db "DO6"  
2e53 f1			.pastdmark: pop af  
2e54			endm  
# End of macro DMARK
2e54						CALLMONITOR 
2e54 cd 77 14			call break_point_state  
2e57				endm  
# End of macro CALLMONITOR
2e57					endif 
2e57					FORTH_DSP_POP 
2e57 cd b3 1c			call macro_forth_dsp_pop 
2e5a				endm 
# End of macro FORTH_DSP_POP
2e5a			 
2e5a			; put counters on the loop stack 
2e5a			 
2e5a			;		pop hl			 ; limit counter 
2e5a d1					pop de			; start counter 
2e5b			 
2e5b					; push limit counter 
2e5b			 
2e5b					if DEBUG_FORTH_WORDS 
2e5b						DMARK "DO7" 
2e5b f5				push af  
2e5c 3a 70 2e			ld a, (.dmark)  
2e5f 32 7a ee			ld (debug_mark),a  
2e62 3a 71 2e			ld a, (.dmark+1)  
2e65 32 7b ee			ld (debug_mark+1),a  
2e68 3a 72 2e			ld a, (.dmark+2)  
2e6b 32 7c ee			ld (debug_mark+2),a  
2e6e 18 03			jr .pastdmark  
2e70 ..			.dmark: db "DO7"  
2e73 f1			.pastdmark: pop af  
2e74			endm  
# End of macro DMARK
2e74						CALLMONITOR 
2e74 cd 77 14			call break_point_state  
2e77				endm  
# End of macro CALLMONITOR
2e77					endif 
2e77					FORTH_LOOP_NEXT 
2e77 cd 2c 1c			call macro_forth_loop_next 
2e7a				endm 
# End of macro FORTH_LOOP_NEXT
2e7a			 
2e7a					; push start counter 
2e7a			 
2e7a eb					ex de, hl 
2e7b					if DEBUG_FORTH_WORDS 
2e7b						DMARK "DO7" 
2e7b f5				push af  
2e7c 3a 90 2e			ld a, (.dmark)  
2e7f 32 7a ee			ld (debug_mark),a  
2e82 3a 91 2e			ld a, (.dmark+1)  
2e85 32 7b ee			ld (debug_mark+1),a  
2e88 3a 92 2e			ld a, (.dmark+2)  
2e8b 32 7c ee			ld (debug_mark+2),a  
2e8e 18 03			jr .pastdmark  
2e90 ..			.dmark: db "DO7"  
2e93 f1			.pastdmark: pop af  
2e94			endm  
# End of macro DMARK
2e94						CALLMONITOR 
2e94 cd 77 14			call break_point_state  
2e97				endm  
# End of macro CALLMONITOR
2e97					endif 
2e97					FORTH_LOOP_NEXT 
2e97 cd 2c 1c			call macro_forth_loop_next 
2e9a				endm 
# End of macro FORTH_LOOP_NEXT
2e9a			 
2e9a			 
2e9a					; init first round of I counter 
2e9a			 
2e9a 22 85 e6				ld (os_current_i), hl 
2e9d			 
2e9d					if DEBUG_FORTH_WORDS 
2e9d						DMARK "DO8" 
2e9d f5				push af  
2e9e 3a b2 2e			ld a, (.dmark)  
2ea1 32 7a ee			ld (debug_mark),a  
2ea4 3a b3 2e			ld a, (.dmark+1)  
2ea7 32 7b ee			ld (debug_mark+1),a  
2eaa 3a b4 2e			ld a, (.dmark+2)  
2ead 32 7c ee			ld (debug_mark+2),a  
2eb0 18 03			jr .pastdmark  
2eb2 ..			.dmark: db "DO8"  
2eb5 f1			.pastdmark: pop af  
2eb6			endm  
# End of macro DMARK
2eb6						CALLMONITOR 
2eb6 cd 77 14			call break_point_state  
2eb9				endm  
# End of macro CALLMONITOR
2eb9					endif 
2eb9			 
2eb9					NEXTW 
2eb9 c3 6d 1d			jp macro_next 
2ebc				endm 
# End of macro NEXTW
2ebc			.LOOP: 
2ebc				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2ebc 22				db WORD_SYS_CORE+14             
2ebd d4 2f			dw .I            
2ebf 05				db 4 + 1 
2ec0 .. 00			db "LOOP",0              
2ec5				endm 
# End of macro CWHEAD
2ec5			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2ec5			 
2ec5				; pop tos as current loop count to hl 
2ec5			 
2ec5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2ec5			 
2ec5				FORTH_LOOP_TOS 
2ec5 cd 5f 1c			call macro_forth_loop_tos 
2ec8				endm 
# End of macro FORTH_LOOP_TOS
2ec8 e5				push hl 
2ec9			 
2ec9					if DEBUG_FORTH_WORDS_KEY 
2ec9						DMARK "LOP" 
2ec9 f5				push af  
2eca 3a de 2e			ld a, (.dmark)  
2ecd 32 7a ee			ld (debug_mark),a  
2ed0 3a df 2e			ld a, (.dmark+1)  
2ed3 32 7b ee			ld (debug_mark+1),a  
2ed6 3a e0 2e			ld a, (.dmark+2)  
2ed9 32 7c ee			ld (debug_mark+2),a  
2edc 18 03			jr .pastdmark  
2ede ..			.dmark: db "LOP"  
2ee1 f1			.pastdmark: pop af  
2ee2			endm  
# End of macro DMARK
2ee2						CALLMONITOR 
2ee2 cd 77 14			call break_point_state  
2ee5				endm  
# End of macro CALLMONITOR
2ee5					endif 
2ee5				; next item on the stack is the limit. get it 
2ee5			 
2ee5			 
2ee5				FORTH_LOOP_POP 
2ee5 cd 69 1c			call macro_forth_loop_pop 
2ee8				endm 
# End of macro FORTH_LOOP_POP
2ee8			 
2ee8				FORTH_LOOP_TOS 
2ee8 cd 5f 1c			call macro_forth_loop_tos 
2eeb				endm 
# End of macro FORTH_LOOP_TOS
2eeb			 
2eeb d1				pop de		 ; de = i, hl = limit 
2eec			 
2eec					if DEBUG_FORTH_WORDS 
2eec						DMARK "LP1" 
2eec f5				push af  
2eed 3a 01 2f			ld a, (.dmark)  
2ef0 32 7a ee			ld (debug_mark),a  
2ef3 3a 02 2f			ld a, (.dmark+1)  
2ef6 32 7b ee			ld (debug_mark+1),a  
2ef9 3a 03 2f			ld a, (.dmark+2)  
2efc 32 7c ee			ld (debug_mark+2),a  
2eff 18 03			jr .pastdmark  
2f01 ..			.dmark: db "LP1"  
2f04 f1			.pastdmark: pop af  
2f05			endm  
# End of macro DMARK
2f05						CALLMONITOR 
2f05 cd 77 14			call break_point_state  
2f08				endm  
# End of macro CALLMONITOR
2f08					endif 
2f08			 
2f08				; go back to previous word 
2f08			 
2f08 d5				push de    ; save I for inc later 
2f09			 
2f09			 
2f09				; get limit 
2f09				;  is I at limit? 
2f09			 
2f09			 
2f09					if DEBUG_FORTH_WORDS 
2f09						DMARK "LP1" 
2f09 f5				push af  
2f0a 3a 1e 2f			ld a, (.dmark)  
2f0d 32 7a ee			ld (debug_mark),a  
2f10 3a 1f 2f			ld a, (.dmark+1)  
2f13 32 7b ee			ld (debug_mark+1),a  
2f16 3a 20 2f			ld a, (.dmark+2)  
2f19 32 7c ee			ld (debug_mark+2),a  
2f1c 18 03			jr .pastdmark  
2f1e ..			.dmark: db "LP1"  
2f21 f1			.pastdmark: pop af  
2f22			endm  
# End of macro DMARK
2f22						CALLMONITOR 
2f22 cd 77 14			call break_point_state  
2f25				endm  
# End of macro CALLMONITOR
2f25					endif 
2f25			 
2f25 ed 52			sbc hl, de 
2f27			 
2f27			 
2f27				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2f27			 
2f27 20 26				jr nz, .loopnotdone 
2f29			 
2f29 e1				pop hl   ; get rid of saved I 
2f2a				FORTH_LOOP_POP     ; get rid of limit 
2f2a cd 69 1c			call macro_forth_loop_pop 
2f2d				endm 
# End of macro FORTH_LOOP_POP
2f2d			 
2f2d				FORTH_RSP_POP     ; get rid of DO ptr 
2f2d cd cc 19			call macro_forth_rsp_pop 
2f30				endm 
# End of macro FORTH_RSP_POP
2f30			 
2f30			if DEBUG_FORTH_WORDS 
2f30						DMARK "LP>" 
2f30 f5				push af  
2f31 3a 45 2f			ld a, (.dmark)  
2f34 32 7a ee			ld (debug_mark),a  
2f37 3a 46 2f			ld a, (.dmark+1)  
2f3a 32 7b ee			ld (debug_mark+1),a  
2f3d 3a 47 2f			ld a, (.dmark+2)  
2f40 32 7c ee			ld (debug_mark+2),a  
2f43 18 03			jr .pastdmark  
2f45 ..			.dmark: db "LP>"  
2f48 f1			.pastdmark: pop af  
2f49			endm  
# End of macro DMARK
2f49				CALLMONITOR 
2f49 cd 77 14			call break_point_state  
2f4c				endm  
# End of macro CALLMONITOR
2f4c			endif 
2f4c			 
2f4c					NEXTW 
2f4c c3 6d 1d			jp macro_next 
2f4f				endm 
# End of macro NEXTW
2f4f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2f4f			 
2f4f			.loopnotdone: 
2f4f			 
2f4f e1				pop hl    ; get I 
2f50 23				inc hl 
2f51			 
2f51			   	; save new I 
2f51			 
2f51			 
2f51					; set I counter 
2f51			 
2f51 22 85 e6				ld (os_current_i), hl 
2f54			 
2f54					if DEBUG_FORTH_WORDS 
2f54						DMARK "LPN" 
2f54 f5				push af  
2f55 3a 69 2f			ld a, (.dmark)  
2f58 32 7a ee			ld (debug_mark),a  
2f5b 3a 6a 2f			ld a, (.dmark+1)  
2f5e 32 7b ee			ld (debug_mark+1),a  
2f61 3a 6b 2f			ld a, (.dmark+2)  
2f64 32 7c ee			ld (debug_mark+2),a  
2f67 18 03			jr .pastdmark  
2f69 ..			.dmark: db "LPN"  
2f6c f1			.pastdmark: pop af  
2f6d			endm  
# End of macro DMARK
2f6d					CALLMONITOR 
2f6d cd 77 14			call break_point_state  
2f70				endm  
# End of macro CALLMONITOR
2f70					endif 
2f70					 
2f70				FORTH_LOOP_NEXT 
2f70 cd 2c 1c			call macro_forth_loop_next 
2f73				endm 
# End of macro FORTH_LOOP_NEXT
2f73			 
2f73			 
2f73					if DEBUG_FORTH_WORDS 
2f73 eb						ex de,hl 
2f74					endif 
2f74			 
2f74			;	; get DO ptr 
2f74			; 
2f74					if DEBUG_FORTH_WORDS 
2f74						DMARK "LP7" 
2f74 f5				push af  
2f75 3a 89 2f			ld a, (.dmark)  
2f78 32 7a ee			ld (debug_mark),a  
2f7b 3a 8a 2f			ld a, (.dmark+1)  
2f7e 32 7b ee			ld (debug_mark+1),a  
2f81 3a 8b 2f			ld a, (.dmark+2)  
2f84 32 7c ee			ld (debug_mark+2),a  
2f87 18 03			jr .pastdmark  
2f89 ..			.dmark: db "LP7"  
2f8c f1			.pastdmark: pop af  
2f8d			endm  
# End of macro DMARK
2f8d					CALLMONITOR 
2f8d cd 77 14			call break_point_state  
2f90				endm  
# End of macro CALLMONITOR
2f90					endif 
2f90				FORTH_RSP_TOS 
2f90 cd c2 19			call macro_forth_rsp_tos 
2f93				endm 
# End of macro FORTH_RSP_TOS
2f93			 
2f93					if DEBUG_FORTH_WORDS 
2f93						DMARK "LP8" 
2f93 f5				push af  
2f94 3a a8 2f			ld a, (.dmark)  
2f97 32 7a ee			ld (debug_mark),a  
2f9a 3a a9 2f			ld a, (.dmark+1)  
2f9d 32 7b ee			ld (debug_mark+1),a  
2fa0 3a aa 2f			ld a, (.dmark+2)  
2fa3 32 7c ee			ld (debug_mark+2),a  
2fa6 18 03			jr .pastdmark  
2fa8 ..			.dmark: db "LP8"  
2fab f1			.pastdmark: pop af  
2fac			endm  
# End of macro DMARK
2fac					CALLMONITOR 
2fac cd 77 14			call break_point_state  
2faf				endm  
# End of macro CALLMONITOR
2faf					endif 
2faf				;push hl 
2faf			 
2faf				; not going to DO any more 
2faf				; get rid of the RSP pointer as DO will add it back in 
2faf				;FORTH_RSP_POP 
2faf				;pop hl 
2faf			 
2faf				;ld hl,(cli_ret_sp) 
2faf				;ld e, (hl) 
2faf				;inc hl 
2faf				;ld d, (hl) 
2faf				;ex de,hl 
2faf 22 61 e6			ld (os_tok_ptr), hl 
2fb2					if DEBUG_FORTH_WORDS 
2fb2						DMARK "LP<" 
2fb2 f5				push af  
2fb3 3a c7 2f			ld a, (.dmark)  
2fb6 32 7a ee			ld (debug_mark),a  
2fb9 3a c8 2f			ld a, (.dmark+1)  
2fbc 32 7b ee			ld (debug_mark+1),a  
2fbf 3a c9 2f			ld a, (.dmark+2)  
2fc2 32 7c ee			ld (debug_mark+2),a  
2fc5 18 03			jr .pastdmark  
2fc7 ..			.dmark: db "LP<"  
2fca f1			.pastdmark: pop af  
2fcb			endm  
# End of macro DMARK
2fcb					CALLMONITOR 
2fcb cd 77 14			call break_point_state  
2fce				endm  
# End of macro CALLMONITOR
2fce				endif 
2fce c3 fe 1d			jp exec1 
2fd1			 
2fd1					 
2fd1			 
2fd1			 
2fd1					NEXTW 
2fd1 c3 6d 1d			jp macro_next 
2fd4				endm 
# End of macro NEXTW
2fd4			.I:  
2fd4			 
2fd4				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2fd4 5e				db WORD_SYS_CORE+74             
2fd5 ff 2f			dw .DLOOP            
2fd7 02				db 1 + 1 
2fd8 .. 00			db "I",0              
2fda				endm 
# End of macro CWHEAD
2fda			; | I ( -- ) Current loop counter | DONE 
2fda					if DEBUG_FORTH_WORDS_KEY 
2fda						DMARK "I.." 
2fda f5				push af  
2fdb 3a ef 2f			ld a, (.dmark)  
2fde 32 7a ee			ld (debug_mark),a  
2fe1 3a f0 2f			ld a, (.dmark+1)  
2fe4 32 7b ee			ld (debug_mark+1),a  
2fe7 3a f1 2f			ld a, (.dmark+2)  
2fea 32 7c ee			ld (debug_mark+2),a  
2fed 18 03			jr .pastdmark  
2fef ..			.dmark: db "I.."  
2ff2 f1			.pastdmark: pop af  
2ff3			endm  
# End of macro DMARK
2ff3						CALLMONITOR 
2ff3 cd 77 14			call break_point_state  
2ff6				endm  
# End of macro CALLMONITOR
2ff6					endif 
2ff6			 
2ff6 2a 85 e6				ld hl,(os_current_i) 
2ff9 cd 04 1a				call forth_push_numhl 
2ffc			 
2ffc					NEXTW 
2ffc c3 6d 1d			jp macro_next 
2fff				endm 
# End of macro NEXTW
2fff			.DLOOP: 
2fff				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2fff 5f				db WORD_SYS_CORE+75             
3000 e0 30			dw .REPEAT            
3002 06				db 5 + 1 
3003 .. 00			db "-LOOP",0              
3009				endm 
# End of macro CWHEAD
3009			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3009				; pop tos as current loop count to hl 
3009					if DEBUG_FORTH_WORDS_KEY 
3009						DMARK "-LP" 
3009 f5				push af  
300a 3a 1e 30			ld a, (.dmark)  
300d 32 7a ee			ld (debug_mark),a  
3010 3a 1f 30			ld a, (.dmark+1)  
3013 32 7b ee			ld (debug_mark+1),a  
3016 3a 20 30			ld a, (.dmark+2)  
3019 32 7c ee			ld (debug_mark+2),a  
301c 18 03			jr .pastdmark  
301e ..			.dmark: db "-LP"  
3021 f1			.pastdmark: pop af  
3022			endm  
# End of macro DMARK
3022						CALLMONITOR 
3022 cd 77 14			call break_point_state  
3025				endm  
# End of macro CALLMONITOR
3025					endif 
3025			 
3025				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3025			 
3025				FORTH_LOOP_TOS 
3025 cd 5f 1c			call macro_forth_loop_tos 
3028				endm 
# End of macro FORTH_LOOP_TOS
3028 e5				push hl 
3029			 
3029					if DEBUG_FORTH_WORDS 
3029						DMARK "-LP" 
3029 f5				push af  
302a 3a 3e 30			ld a, (.dmark)  
302d 32 7a ee			ld (debug_mark),a  
3030 3a 3f 30			ld a, (.dmark+1)  
3033 32 7b ee			ld (debug_mark+1),a  
3036 3a 40 30			ld a, (.dmark+2)  
3039 32 7c ee			ld (debug_mark+2),a  
303c 18 03			jr .pastdmark  
303e ..			.dmark: db "-LP"  
3041 f1			.pastdmark: pop af  
3042			endm  
# End of macro DMARK
3042						CALLMONITOR 
3042 cd 77 14			call break_point_state  
3045				endm  
# End of macro CALLMONITOR
3045					endif 
3045				; next item on the stack is the limit. get it 
3045			 
3045			 
3045				FORTH_LOOP_POP 
3045 cd 69 1c			call macro_forth_loop_pop 
3048				endm 
# End of macro FORTH_LOOP_POP
3048			 
3048				FORTH_LOOP_TOS 
3048 cd 5f 1c			call macro_forth_loop_tos 
304b				endm 
# End of macro FORTH_LOOP_TOS
304b			 
304b d1				pop de		 ; de = i, hl = limit 
304c			 
304c					if DEBUG_FORTH_WORDS 
304c						DMARK "-L1" 
304c f5				push af  
304d 3a 61 30			ld a, (.dmark)  
3050 32 7a ee			ld (debug_mark),a  
3053 3a 62 30			ld a, (.dmark+1)  
3056 32 7b ee			ld (debug_mark+1),a  
3059 3a 63 30			ld a, (.dmark+2)  
305c 32 7c ee			ld (debug_mark+2),a  
305f 18 03			jr .pastdmark  
3061 ..			.dmark: db "-L1"  
3064 f1			.pastdmark: pop af  
3065			endm  
# End of macro DMARK
3065						CALLMONITOR 
3065 cd 77 14			call break_point_state  
3068				endm  
# End of macro CALLMONITOR
3068					endif 
3068			 
3068				; go back to previous word 
3068			 
3068 d5				push de    ; save I for inc later 
3069			 
3069			 
3069				; get limit 
3069				;  is I at limit? 
3069			 
3069			 
3069					if DEBUG_FORTH_WORDS 
3069						DMARK "-L1" 
3069 f5				push af  
306a 3a 7e 30			ld a, (.dmark)  
306d 32 7a ee			ld (debug_mark),a  
3070 3a 7f 30			ld a, (.dmark+1)  
3073 32 7b ee			ld (debug_mark+1),a  
3076 3a 80 30			ld a, (.dmark+2)  
3079 32 7c ee			ld (debug_mark+2),a  
307c 18 03			jr .pastdmark  
307e ..			.dmark: db "-L1"  
3081 f1			.pastdmark: pop af  
3082			endm  
# End of macro DMARK
3082						CALLMONITOR 
3082 cd 77 14			call break_point_state  
3085				endm  
# End of macro CALLMONITOR
3085					endif 
3085			 
3085 ed 52			sbc hl, de 
3087			 
3087			 
3087				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3087			 
3087 20 26				jr nz, .mloopnotdone 
3089			 
3089 e1				pop hl   ; get rid of saved I 
308a				FORTH_LOOP_POP     ; get rid of limit 
308a cd 69 1c			call macro_forth_loop_pop 
308d				endm 
# End of macro FORTH_LOOP_POP
308d			 
308d				FORTH_RSP_POP     ; get rid of DO ptr 
308d cd cc 19			call macro_forth_rsp_pop 
3090				endm 
# End of macro FORTH_RSP_POP
3090			 
3090			if DEBUG_FORTH_WORDS 
3090						DMARK "-L>" 
3090 f5				push af  
3091 3a a5 30			ld a, (.dmark)  
3094 32 7a ee			ld (debug_mark),a  
3097 3a a6 30			ld a, (.dmark+1)  
309a 32 7b ee			ld (debug_mark+1),a  
309d 3a a7 30			ld a, (.dmark+2)  
30a0 32 7c ee			ld (debug_mark+2),a  
30a3 18 03			jr .pastdmark  
30a5 ..			.dmark: db "-L>"  
30a8 f1			.pastdmark: pop af  
30a9			endm  
# End of macro DMARK
30a9				CALLMONITOR 
30a9 cd 77 14			call break_point_state  
30ac				endm  
# End of macro CALLMONITOR
30ac			endif 
30ac			 
30ac					NEXTW 
30ac c3 6d 1d			jp macro_next 
30af				endm 
# End of macro NEXTW
30af				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
30af			 
30af			.mloopnotdone: 
30af			 
30af e1				pop hl    ; get I 
30b0 2b				dec hl 
30b1			 
30b1			   	; save new I 
30b1			 
30b1			 
30b1					; set I counter 
30b1			 
30b1 22 85 e6				ld (os_current_i), hl 
30b4			 
30b4					 
30b4				FORTH_LOOP_NEXT 
30b4 cd 2c 1c			call macro_forth_loop_next 
30b7				endm 
# End of macro FORTH_LOOP_NEXT
30b7			 
30b7			 
30b7					if DEBUG_FORTH_WORDS 
30b7 eb						ex de,hl 
30b8					endif 
30b8			 
30b8			;	; get DO ptr 
30b8			; 
30b8				FORTH_RSP_TOS 
30b8 cd c2 19			call macro_forth_rsp_tos 
30bb				endm 
# End of macro FORTH_RSP_TOS
30bb			 
30bb				;push hl 
30bb			 
30bb				; not going to DO any more 
30bb				; get rid of the RSP pointer as DO will add it back in 
30bb				;FORTH_RSP_POP 
30bb				;pop hl 
30bb			 
30bb			 
30bb 22 61 e6			ld (os_tok_ptr), hl 
30be					if DEBUG_FORTH_WORDS 
30be						DMARK "-L<" 
30be f5				push af  
30bf 3a d3 30			ld a, (.dmark)  
30c2 32 7a ee			ld (debug_mark),a  
30c5 3a d4 30			ld a, (.dmark+1)  
30c8 32 7b ee			ld (debug_mark+1),a  
30cb 3a d5 30			ld a, (.dmark+2)  
30ce 32 7c ee			ld (debug_mark+2),a  
30d1 18 03			jr .pastdmark  
30d3 ..			.dmark: db "-L<"  
30d6 f1			.pastdmark: pop af  
30d7			endm  
# End of macro DMARK
30d7					CALLMONITOR 
30d7 cd 77 14			call break_point_state  
30da				endm  
# End of macro CALLMONITOR
30da				endif 
30da c3 fe 1d			jp exec1 
30dd			 
30dd					 
30dd			 
30dd			 
30dd			 
30dd				NEXTW 
30dd c3 6d 1d			jp macro_next 
30e0				endm 
# End of macro NEXTW
30e0			 
30e0			 
30e0			 
30e0			 
30e0			.REPEAT: 
30e0				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
30e0 71				db WORD_SYS_CORE+93             
30e1 33 31			dw .UNTIL            
30e3 06				db 5 + 1 
30e4 .. 00			db "REPEAT",0              
30eb				endm 
# End of macro CWHEAD
30eb			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
30eb			;  push pc to rsp stack past the REPEAT 
30eb					if DEBUG_FORTH_WORDS_KEY 
30eb						DMARK "REP" 
30eb f5				push af  
30ec 3a 00 31			ld a, (.dmark)  
30ef 32 7a ee			ld (debug_mark),a  
30f2 3a 01 31			ld a, (.dmark+1)  
30f5 32 7b ee			ld (debug_mark+1),a  
30f8 3a 02 31			ld a, (.dmark+2)  
30fb 32 7c ee			ld (debug_mark+2),a  
30fe 18 03			jr .pastdmark  
3100 ..			.dmark: db "REP"  
3103 f1			.pastdmark: pop af  
3104			endm  
# End of macro DMARK
3104						CALLMONITOR 
3104 cd 77 14			call break_point_state  
3107				endm  
# End of macro CALLMONITOR
3107					endif 
3107			 
3107 2a 61 e6				ld hl, (os_tok_ptr) 
310a 23					inc hl   ; R 
310b 23					inc hl  ; E 
310c 23					inc hl   ; P 
310d 23					inc hl   ; E 
310e 23					inc hl   ; A 
310f 23					inc hl   ; T 
3110 23					inc hl   ; zero 
3111					FORTH_RSP_NEXT 
3111 cd ab 19			call macro_forth_rsp_next 
3114				endm 
# End of macro FORTH_RSP_NEXT
3114			 
3114			 
3114					if DEBUG_FORTH_WORDS 
3114						DMARK "REP" 
3114 f5				push af  
3115 3a 29 31			ld a, (.dmark)  
3118 32 7a ee			ld (debug_mark),a  
311b 3a 2a 31			ld a, (.dmark+1)  
311e 32 7b ee			ld (debug_mark+1),a  
3121 3a 2b 31			ld a, (.dmark+2)  
3124 32 7c ee			ld (debug_mark+2),a  
3127 18 03			jr .pastdmark  
3129 ..			.dmark: db "REP"  
312c f1			.pastdmark: pop af  
312d			endm  
# End of macro DMARK
312d						;pop bc    ; TODO BUG ?????? what is this for???? 
312d						CALLMONITOR 
312d cd 77 14			call break_point_state  
3130				endm  
# End of macro CALLMONITOR
3130					endif 
3130			 
3130					NEXTW 
3130 c3 6d 1d			jp macro_next 
3133				endm 
# End of macro NEXTW
3133			;	       NEXTW 
3133			 
3133			.UNTIL: 
3133				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3133 72				db WORD_SYS_CORE+94             
3134 ca 31			dw .ENDFLOW            
3136 06				db 5 + 1 
3137 .. 00			db "UNTIL",0              
313d				endm 
# End of macro CWHEAD
313d			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
313d			 
313d				; pop tos as check 
313d			 
313d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
313d			 
313d				FORTH_DSP_VALUEHL 
313d cd fb 1b			call macro_dsp_valuehl 
3140				endm 
# End of macro FORTH_DSP_VALUEHL
3140			 
3140					if DEBUG_FORTH_WORDS_KEY 
3140						DMARK "UNT" 
3140 f5				push af  
3141 3a 55 31			ld a, (.dmark)  
3144 32 7a ee			ld (debug_mark),a  
3147 3a 56 31			ld a, (.dmark+1)  
314a 32 7b ee			ld (debug_mark+1),a  
314d 3a 57 31			ld a, (.dmark+2)  
3150 32 7c ee			ld (debug_mark+2),a  
3153 18 03			jr .pastdmark  
3155 ..			.dmark: db "UNT"  
3158 f1			.pastdmark: pop af  
3159			endm  
# End of macro DMARK
3159						CALLMONITOR 
3159 cd 77 14			call break_point_state  
315c				endm  
# End of macro CALLMONITOR
315c					endif 
315c			 
315c			;	push hl 
315c				FORTH_DSP_POP 
315c cd b3 1c			call macro_forth_dsp_pop 
315f				endm 
# End of macro FORTH_DSP_POP
315f			 
315f			;	pop hl 
315f			 
315f				; test if true 
315f			 
315f cd f2 0b			call ishlzero 
3162			;	ld a,l 
3162			;	add h 
3162			; 
3162			;	cp 0 
3162			 
3162 20 3e			jr nz, .untilnotdone 
3164			 
3164					if DEBUG_FORTH_WORDS 
3164						DMARK "UNf" 
3164 f5				push af  
3165 3a 79 31			ld a, (.dmark)  
3168 32 7a ee			ld (debug_mark),a  
316b 3a 7a 31			ld a, (.dmark+1)  
316e 32 7b ee			ld (debug_mark+1),a  
3171 3a 7b 31			ld a, (.dmark+2)  
3174 32 7c ee			ld (debug_mark+2),a  
3177 18 03			jr .pastdmark  
3179 ..			.dmark: db "UNf"  
317c f1			.pastdmark: pop af  
317d			endm  
# End of macro DMARK
317d						CALLMONITOR 
317d cd 77 14			call break_point_state  
3180				endm  
# End of macro CALLMONITOR
3180					endif 
3180			 
3180			 
3180			 
3180				FORTH_RSP_POP     ; get rid of DO ptr 
3180 cd cc 19			call macro_forth_rsp_pop 
3183				endm 
# End of macro FORTH_RSP_POP
3183			 
3183			if DEBUG_FORTH_WORDS 
3183						DMARK "UN>" 
3183 f5				push af  
3184 3a 98 31			ld a, (.dmark)  
3187 32 7a ee			ld (debug_mark),a  
318a 3a 99 31			ld a, (.dmark+1)  
318d 32 7b ee			ld (debug_mark+1),a  
3190 3a 9a 31			ld a, (.dmark+2)  
3193 32 7c ee			ld (debug_mark+2),a  
3196 18 03			jr .pastdmark  
3198 ..			.dmark: db "UN>"  
319b f1			.pastdmark: pop af  
319c			endm  
# End of macro DMARK
319c				CALLMONITOR 
319c cd 77 14			call break_point_state  
319f				endm  
# End of macro CALLMONITOR
319f			endif 
319f			 
319f					NEXTW 
319f c3 6d 1d			jp macro_next 
31a2				endm 
# End of macro NEXTW
31a2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31a2			 
31a2			.untilnotdone: 
31a2			 
31a2			 
31a2			;	; get DO ptr 
31a2			; 
31a2				FORTH_RSP_TOS 
31a2 cd c2 19			call macro_forth_rsp_tos 
31a5				endm 
# End of macro FORTH_RSP_TOS
31a5			 
31a5				;push hl 
31a5			 
31a5				; not going to DO any more 
31a5				; get rid of the RSP pointer as DO will add it back in 
31a5				;FORTH_RSP_POP 
31a5				;pop hl 
31a5			 
31a5			 
31a5 22 61 e6			ld (os_tok_ptr), hl 
31a8					if DEBUG_FORTH_WORDS 
31a8						DMARK "UN<" 
31a8 f5				push af  
31a9 3a bd 31			ld a, (.dmark)  
31ac 32 7a ee			ld (debug_mark),a  
31af 3a be 31			ld a, (.dmark+1)  
31b2 32 7b ee			ld (debug_mark+1),a  
31b5 3a bf 31			ld a, (.dmark+2)  
31b8 32 7c ee			ld (debug_mark+2),a  
31bb 18 03			jr .pastdmark  
31bd ..			.dmark: db "UN<"  
31c0 f1			.pastdmark: pop af  
31c1			endm  
# End of macro DMARK
31c1					CALLMONITOR 
31c1 cd 77 14			call break_point_state  
31c4				endm  
# End of macro CALLMONITOR
31c4				endif 
31c4 c3 fe 1d			jp exec1 
31c7			 
31c7					 
31c7			 
31c7			 
31c7					NEXTW 
31c7 c3 6d 1d			jp macro_next 
31ca				endm 
# End of macro NEXTW
31ca			 
31ca			 
31ca			.ENDFLOW: 
31ca			 
31ca			; eof 
31ca			 
# End of file forth_words_flow.asm
31ca			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
31ca			include "forth_words_logic.asm" 
31ca			 
31ca			; | ## Logic Words 
31ca			 
31ca			.NOT: 
31ca				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
31ca 2d				db WORD_SYS_CORE+25             
31cb 12 32			dw .IS            
31cd 04				db 3 + 1 
31ce .. 00			db "NOT",0              
31d2				endm 
# End of macro CWHEAD
31d2			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
31d2					if DEBUG_FORTH_WORDS_KEY 
31d2						DMARK "NOT" 
31d2 f5				push af  
31d3 3a e7 31			ld a, (.dmark)  
31d6 32 7a ee			ld (debug_mark),a  
31d9 3a e8 31			ld a, (.dmark+1)  
31dc 32 7b ee			ld (debug_mark+1),a  
31df 3a e9 31			ld a, (.dmark+2)  
31e2 32 7c ee			ld (debug_mark+2),a  
31e5 18 03			jr .pastdmark  
31e7 ..			.dmark: db "NOT"  
31ea f1			.pastdmark: pop af  
31eb			endm  
# End of macro DMARK
31eb						CALLMONITOR 
31eb cd 77 14			call break_point_state  
31ee				endm  
# End of macro CALLMONITOR
31ee					endif 
31ee					FORTH_DSP 
31ee cd c1 1b			call macro_forth_dsp 
31f1				endm 
# End of macro FORTH_DSP
31f1 7e					ld a,(hl)	; get type of value on TOS 
31f2 fe 02				cp DS_TYPE_INUM  
31f4 28 03				jr z, .noti 
31f6					NEXTW 
31f6 c3 6d 1d			jp macro_next 
31f9				endm 
# End of macro NEXTW
31f9			.noti:          FORTH_DSP_VALUEHL 
31f9 cd fb 1b			call macro_dsp_valuehl 
31fc				endm 
# End of macro FORTH_DSP_VALUEHL
31fc			;		push hl 
31fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31fc cd b3 1c			call macro_forth_dsp_pop 
31ff				endm 
# End of macro FORTH_DSP_POP
31ff			;		pop hl 
31ff 3e 00				ld a,0 
3201 bd					cp l 
3202 28 04				jr z, .not2t 
3204 2e 00				ld l, 0 
3206 18 02				jr .notip 
3208			 
3208 2e ff		.not2t:		ld l, 255 
320a			 
320a 26 00		.notip:		ld h, 0	 
320c			 
320c cd 04 1a				call forth_push_numhl 
320f					NEXTW 
320f c3 6d 1d			jp macro_next 
3212				endm 
# End of macro NEXTW
3212			 
3212			.IS: 
3212				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3212 2d				db WORD_SYS_CORE+25             
3213 38 32			dw .LZERO            
3215 03				db 2 + 1 
3216 .. 00			db "IS",0              
3219				endm 
# End of macro CWHEAD
3219			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3219					if DEBUG_FORTH_WORDS_KEY 
3219						DMARK "IS." 
3219 f5				push af  
321a 3a 2e 32			ld a, (.dmark)  
321d 32 7a ee			ld (debug_mark),a  
3220 3a 2f 32			ld a, (.dmark+1)  
3223 32 7b ee			ld (debug_mark+1),a  
3226 3a 30 32			ld a, (.dmark+2)  
3229 32 7c ee			ld (debug_mark+2),a  
322c 18 03			jr .pastdmark  
322e ..			.dmark: db "IS."  
3231 f1			.pastdmark: pop af  
3232			endm  
# End of macro DMARK
3232						CALLMONITOR 
3232 cd 77 14			call break_point_state  
3235				endm  
# End of macro CALLMONITOR
3235					endif 
3235					NEXTW 
3235 c3 6d 1d			jp macro_next 
3238				endm 
# End of macro NEXTW
3238			.LZERO: 
3238				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3238 2d				db WORD_SYS_CORE+25             
3239 42 32			dw .TZERO            
323b 03				db 2 + 1 
323c .. 00			db "0<",0              
323f				endm 
# End of macro CWHEAD
323f			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
323f					NEXTW 
323f c3 6d 1d			jp macro_next 
3242				endm 
# End of macro NEXTW
3242			.TZERO: 
3242				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3242 2e				db WORD_SYS_CORE+26             
3243 89 32			dw .LESS            
3245 03				db 2 + 1 
3246 .. 00			db "0=",0              
3249				endm 
# End of macro CWHEAD
3249			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3249				; TODO add floating point number detection 
3249					;v5 FORTH_DSP_VALUE 
3249					if DEBUG_FORTH_WORDS_KEY 
3249						DMARK "0=." 
3249 f5				push af  
324a 3a 5e 32			ld a, (.dmark)  
324d 32 7a ee			ld (debug_mark),a  
3250 3a 5f 32			ld a, (.dmark+1)  
3253 32 7b ee			ld (debug_mark+1),a  
3256 3a 60 32			ld a, (.dmark+2)  
3259 32 7c ee			ld (debug_mark+2),a  
325c 18 03			jr .pastdmark  
325e ..			.dmark: db "0=."  
3261 f1			.pastdmark: pop af  
3262			endm  
# End of macro DMARK
3262						CALLMONITOR 
3262 cd 77 14			call break_point_state  
3265				endm  
# End of macro CALLMONITOR
3265					endif 
3265					FORTH_DSP 
3265 cd c1 1b			call macro_forth_dsp 
3268				endm 
# End of macro FORTH_DSP
3268 7e					ld a,(hl)	; get type of value on TOS 
3269 fe 02				cp DS_TYPE_INUM  
326b 28 00				jr z, .tz_inum 
326d			 
326d				if FORTH_ENABLE_FLOATMATH 
326d					jr .tz_done 
326d			 
326d				endif 
326d					 
326d			 
326d			.tz_inum: 
326d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
326d cd fb 1b			call macro_dsp_valuehl 
3270				endm 
# End of macro FORTH_DSP_VALUEHL
3270			 
3270			;		push hl 
3270			 
3270					; destroy value TOS 
3270			 
3270					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3270 cd b3 1c			call macro_forth_dsp_pop 
3273				endm 
# End of macro FORTH_DSP_POP
3273			 
3273			;		pop hl 
3273			 
3273 3e 00				ld a,0 
3275			 
3275 bd					cp l 
3276 20 08				jr nz, .tz_notzero 
3278			 
3278 bc					cp h 
3279			 
3279 20 05				jr nz, .tz_notzero 
327b			 
327b			 
327b 21 01 00				ld hl, FORTH_TRUE 
327e 18 03				jr .tz_done 
3280			 
3280 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3283			 
3283					; push value back onto stack for another op etc 
3283			 
3283			.tz_done: 
3283 cd 04 1a				call forth_push_numhl 
3286			 
3286					NEXTW 
3286 c3 6d 1d			jp macro_next 
3289				endm 
# End of macro NEXTW
3289			.LESS: 
3289				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3289 2f				db WORD_SYS_CORE+27             
328a f2 32			dw .GT            
328c 02				db 1 + 1 
328d .. 00			db "<",0              
328f				endm 
# End of macro CWHEAD
328f			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
328f				; TODO add floating point number detection 
328f					if DEBUG_FORTH_WORDS_KEY 
328f						DMARK "LES" 
328f f5				push af  
3290 3a a4 32			ld a, (.dmark)  
3293 32 7a ee			ld (debug_mark),a  
3296 3a a5 32			ld a, (.dmark+1)  
3299 32 7b ee			ld (debug_mark+1),a  
329c 3a a6 32			ld a, (.dmark+2)  
329f 32 7c ee			ld (debug_mark+2),a  
32a2 18 03			jr .pastdmark  
32a4 ..			.dmark: db "LES"  
32a7 f1			.pastdmark: pop af  
32a8			endm  
# End of macro DMARK
32a8						CALLMONITOR 
32a8 cd 77 14			call break_point_state  
32ab				endm  
# End of macro CALLMONITOR
32ab					endif 
32ab					FORTH_DSP 
32ab cd c1 1b			call macro_forth_dsp 
32ae				endm 
# End of macro FORTH_DSP
32ae					;v5 FORTH_DSP_VALUE 
32ae 7e					ld a,(hl)	; get type of value on TOS 
32af fe 02				cp DS_TYPE_INUM  
32b1 28 00				jr z, .less_inum 
32b3			 
32b3				if FORTH_ENABLE_FLOATMATH 
32b3					jr .less_done 
32b3			 
32b3				endif 
32b3					 
32b3			 
32b3			.less_inum: 
32b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32b3 cd fb 1b			call macro_dsp_valuehl 
32b6				endm 
# End of macro FORTH_DSP_VALUEHL
32b6			 
32b6 e5					push hl  ; u2 
32b7			 
32b7					; destroy value TOS 
32b7			 
32b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32b7 cd b3 1c			call macro_forth_dsp_pop 
32ba				endm 
# End of macro FORTH_DSP_POP
32ba			 
32ba			 
32ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32ba cd fb 1b			call macro_dsp_valuehl 
32bd				endm 
# End of macro FORTH_DSP_VALUEHL
32bd			 
32bd e5					push hl    ; u1 
32be			 
32be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32be cd b3 1c			call macro_forth_dsp_pop 
32c1				endm 
# End of macro FORTH_DSP_POP
32c1			 
32c1			 
32c1 b7			 or a      ;clear carry flag 
32c2 01 00 00		 ld bc, FORTH_FALSE 
32c5 e1			  pop hl    ; u1 
32c6 d1			  pop de    ; u2 
32c7 ed 52		  sbc hl,de 
32c9 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
32cb			 
32cb 01 01 00		 ld bc, FORTH_TRUE 
32ce			.lscont:  
32ce c5					push bc 
32cf e1					pop hl 
32d0			 
32d0					if DEBUG_FORTH_WORDS 
32d0						DMARK "LT1" 
32d0 f5				push af  
32d1 3a e5 32			ld a, (.dmark)  
32d4 32 7a ee			ld (debug_mark),a  
32d7 3a e6 32			ld a, (.dmark+1)  
32da 32 7b ee			ld (debug_mark+1),a  
32dd 3a e7 32			ld a, (.dmark+2)  
32e0 32 7c ee			ld (debug_mark+2),a  
32e3 18 03			jr .pastdmark  
32e5 ..			.dmark: db "LT1"  
32e8 f1			.pastdmark: pop af  
32e9			endm  
# End of macro DMARK
32e9						CALLMONITOR 
32e9 cd 77 14			call break_point_state  
32ec				endm  
# End of macro CALLMONITOR
32ec					endif 
32ec cd 04 1a				call forth_push_numhl 
32ef			 
32ef					NEXTW 
32ef c3 6d 1d			jp macro_next 
32f2				endm 
# End of macro NEXTW
32f2			.GT: 
32f2				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
32f2 30				db WORD_SYS_CORE+28             
32f3 5b 33			dw .EQUAL            
32f5 02				db 1 + 1 
32f6 .. 00			db ">",0              
32f8				endm 
# End of macro CWHEAD
32f8			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
32f8				; TODO add floating point number detection 
32f8					if DEBUG_FORTH_WORDS_KEY 
32f8						DMARK "GRT" 
32f8 f5				push af  
32f9 3a 0d 33			ld a, (.dmark)  
32fc 32 7a ee			ld (debug_mark),a  
32ff 3a 0e 33			ld a, (.dmark+1)  
3302 32 7b ee			ld (debug_mark+1),a  
3305 3a 0f 33			ld a, (.dmark+2)  
3308 32 7c ee			ld (debug_mark+2),a  
330b 18 03			jr .pastdmark  
330d ..			.dmark: db "GRT"  
3310 f1			.pastdmark: pop af  
3311			endm  
# End of macro DMARK
3311						CALLMONITOR 
3311 cd 77 14			call break_point_state  
3314				endm  
# End of macro CALLMONITOR
3314					endif 
3314					FORTH_DSP 
3314 cd c1 1b			call macro_forth_dsp 
3317				endm 
# End of macro FORTH_DSP
3317					;FORTH_DSP_VALUE 
3317 7e					ld a,(hl)	; get type of value on TOS 
3318 fe 02				cp DS_TYPE_INUM  
331a 28 00				jr z, .gt_inum 
331c			 
331c				if FORTH_ENABLE_FLOATMATH 
331c					jr .gt_done 
331c			 
331c				endif 
331c					 
331c			 
331c			.gt_inum: 
331c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
331c cd fb 1b			call macro_dsp_valuehl 
331f				endm 
# End of macro FORTH_DSP_VALUEHL
331f			 
331f e5					push hl  ; u2 
3320			 
3320					; destroy value TOS 
3320			 
3320					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3320 cd b3 1c			call macro_forth_dsp_pop 
3323				endm 
# End of macro FORTH_DSP_POP
3323			 
3323			 
3323					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3323 cd fb 1b			call macro_dsp_valuehl 
3326				endm 
# End of macro FORTH_DSP_VALUEHL
3326			 
3326 e5					push hl    ; u1 
3327			 
3327					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3327 cd b3 1c			call macro_forth_dsp_pop 
332a				endm 
# End of macro FORTH_DSP_POP
332a			 
332a			 
332a b7			 or a      ;clear carry flag 
332b 01 00 00		 ld bc, FORTH_FALSE 
332e e1			  pop hl    ; u1 
332f d1			  pop de    ; u2 
3330 ed 52		  sbc hl,de 
3332 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3334			 
3334 01 01 00		 ld bc, FORTH_TRUE 
3337			.gtcont:  
3337 c5					push bc 
3338 e1					pop hl 
3339			 
3339					if DEBUG_FORTH_WORDS 
3339						DMARK "GT1" 
3339 f5				push af  
333a 3a 4e 33			ld a, (.dmark)  
333d 32 7a ee			ld (debug_mark),a  
3340 3a 4f 33			ld a, (.dmark+1)  
3343 32 7b ee			ld (debug_mark+1),a  
3346 3a 50 33			ld a, (.dmark+2)  
3349 32 7c ee			ld (debug_mark+2),a  
334c 18 03			jr .pastdmark  
334e ..			.dmark: db "GT1"  
3351 f1			.pastdmark: pop af  
3352			endm  
# End of macro DMARK
3352						CALLMONITOR 
3352 cd 77 14			call break_point_state  
3355				endm  
# End of macro CALLMONITOR
3355					endif 
3355 cd 04 1a				call forth_push_numhl 
3358			 
3358					NEXTW 
3358 c3 6d 1d			jp macro_next 
335b				endm 
# End of macro NEXTW
335b			.EQUAL: 
335b				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
335b 31				db WORD_SYS_CORE+29             
335c c6 33			dw .ENDLOGIC            
335e 02				db 1 + 1 
335f .. 00			db "=",0              
3361				endm 
# End of macro CWHEAD
3361			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3361				; TODO add floating point number detection 
3361					if DEBUG_FORTH_WORDS_KEY 
3361						DMARK "EQ." 
3361 f5				push af  
3362 3a 76 33			ld a, (.dmark)  
3365 32 7a ee			ld (debug_mark),a  
3368 3a 77 33			ld a, (.dmark+1)  
336b 32 7b ee			ld (debug_mark+1),a  
336e 3a 78 33			ld a, (.dmark+2)  
3371 32 7c ee			ld (debug_mark+2),a  
3374 18 03			jr .pastdmark  
3376 ..			.dmark: db "EQ."  
3379 f1			.pastdmark: pop af  
337a			endm  
# End of macro DMARK
337a						CALLMONITOR 
337a cd 77 14			call break_point_state  
337d				endm  
# End of macro CALLMONITOR
337d					endif 
337d					FORTH_DSP 
337d cd c1 1b			call macro_forth_dsp 
3380				endm 
# End of macro FORTH_DSP
3380					;v5 FORTH_DSP_VALUE 
3380 7e					ld a,(hl)	; get type of value on TOS 
3381 fe 02				cp DS_TYPE_INUM  
3383 28 00				jr z, .eq_inum 
3385			 
3385				if FORTH_ENABLE_FLOATMATH 
3385					jr .eq_done 
3385			 
3385				endif 
3385					 
3385			 
3385			.eq_inum: 
3385					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3385 cd fb 1b			call macro_dsp_valuehl 
3388				endm 
# End of macro FORTH_DSP_VALUEHL
3388			 
3388 e5					push hl 
3389			 
3389					; destroy value TOS 
3389			 
3389					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3389 cd b3 1c			call macro_forth_dsp_pop 
338c				endm 
# End of macro FORTH_DSP_POP
338c			 
338c			 
338c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
338c cd fb 1b			call macro_dsp_valuehl 
338f				endm 
# End of macro FORTH_DSP_VALUEHL
338f			 
338f					; one value on hl get other one back 
338f			 
338f e5					push hl 
3390			 
3390					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3390 cd b3 1c			call macro_forth_dsp_pop 
3393				endm 
# End of macro FORTH_DSP_POP
3393			 
3393 0e 00				ld c, FORTH_FALSE 
3395			 
3395 e1					pop hl 
3396 d1					pop de 
3397			 
3397 7b					ld a, e 
3398 bd					cp l 
3399			 
3399 20 06				jr nz, .eq_done 
339b			 
339b 7a					ld a, d 
339c bc					cp h 
339d			 
339d 20 02				jr nz, .eq_done 
339f			 
339f 0e 01				ld c, FORTH_TRUE 
33a1					 
33a1			 
33a1			 
33a1			.eq_done: 
33a1			 
33a1					; TODO push value back onto stack for another op etc 
33a1			 
33a1 26 00				ld h, 0 
33a3 69					ld l, c 
33a4					if DEBUG_FORTH_WORDS 
33a4						DMARK "EQ1" 
33a4 f5				push af  
33a5 3a b9 33			ld a, (.dmark)  
33a8 32 7a ee			ld (debug_mark),a  
33ab 3a ba 33			ld a, (.dmark+1)  
33ae 32 7b ee			ld (debug_mark+1),a  
33b1 3a bb 33			ld a, (.dmark+2)  
33b4 32 7c ee			ld (debug_mark+2),a  
33b7 18 03			jr .pastdmark  
33b9 ..			.dmark: db "EQ1"  
33bc f1			.pastdmark: pop af  
33bd			endm  
# End of macro DMARK
33bd						CALLMONITOR 
33bd cd 77 14			call break_point_state  
33c0				endm  
# End of macro CALLMONITOR
33c0					endif 
33c0 cd 04 1a				call forth_push_numhl 
33c3			 
33c3					NEXTW 
33c3 c3 6d 1d			jp macro_next 
33c6				endm 
# End of macro NEXTW
33c6			 
33c6			 
33c6			.ENDLOGIC: 
33c6			; eof 
33c6			 
33c6			 
# End of file forth_words_logic.asm
33c6			include "forth_words_maths.asm" 
33c6			 
33c6			; | ## Maths Words 
33c6			 
33c6			.PLUS:	 
33c6				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
33c6 15				db WORD_SYS_CORE+1             
33c7 08 34			dw .NEG            
33c9 02				db 1 + 1 
33ca .. 00			db "+",0              
33cc				endm 
# End of macro CWHEAD
33cc			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
33cc					if DEBUG_FORTH_WORDS_KEY 
33cc						DMARK "PLU" 
33cc f5				push af  
33cd 3a e1 33			ld a, (.dmark)  
33d0 32 7a ee			ld (debug_mark),a  
33d3 3a e2 33			ld a, (.dmark+1)  
33d6 32 7b ee			ld (debug_mark+1),a  
33d9 3a e3 33			ld a, (.dmark+2)  
33dc 32 7c ee			ld (debug_mark+2),a  
33df 18 03			jr .pastdmark  
33e1 ..			.dmark: db "PLU"  
33e4 f1			.pastdmark: pop af  
33e5			endm  
# End of macro DMARK
33e5						CALLMONITOR 
33e5 cd 77 14			call break_point_state  
33e8				endm  
# End of macro CALLMONITOR
33e8					endif 
33e8					; add top two values and push back result 
33e8			 
33e8					;for v5 FORTH_DSP_VALUE 
33e8					FORTH_DSP 
33e8 cd c1 1b			call macro_forth_dsp 
33eb				endm 
# End of macro FORTH_DSP
33eb 7e					ld a,(hl)	; get type of value on TOS 
33ec fe 02				cp DS_TYPE_INUM  
33ee 28 03				jr z, .dot_inum 
33f0			 
33f0					NEXTW 
33f0 c3 6d 1d			jp macro_next 
33f3				endm 
# End of macro NEXTW
33f3			 
33f3			; float maths 
33f3			 
33f3				if FORTH_ENABLE_FLOATMATH 
33f3						inc hl      ; now at start of numeric as string 
33f3			 
33f3					if DEBUG_FORTH_MATHS 
33f3						DMARK "ADD" 
33f3				CALLMONITOR 
33f3					endif 
33f3			 
33f3					;ld ix, hl 
33f3					call CON 
33f3			 
33f3			 
33f3					push hl 
33f3					 
33f3					 
33f3			 
33f3						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
33f3			 
33f3					; get next number 
33f3			 
33f3						FORTH_DSP_VALUE 
33f3			 
33f3						inc hl      ; now at start of numeric as string 
33f3			 
33f3					;ld ix, hl 
33f3					call CON 
33f3			 
33f3					push hl 
33f3			 
33f3			 
33f3						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33f3			 
33f3						; TODO do add 
33f3			 
33f3						call IADD 
33f3			 
33f3						; TODO get result back as ascii 
33f3			 
33f3						; TODO push result  
33f3			 
33f3			 
33f3			 
33f3						jr .dot_done 
33f3				endif 
33f3			 
33f3			.dot_inum: 
33f3			 
33f3			 
33f3					if DEBUG_FORTH_DOT 
33f3						DMARK "+IT" 
33f3				CALLMONITOR 
33f3					endif 
33f3			 
33f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33f3 cd fb 1b			call macro_dsp_valuehl 
33f6				endm 
# End of macro FORTH_DSP_VALUEHL
33f6			 
33f6				; TODO add floating point number detection 
33f6			 
33f6 e5					push hl 
33f7			 
33f7					; destroy value TOS 
33f7			 
33f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33f7 cd b3 1c			call macro_forth_dsp_pop 
33fa				endm 
# End of macro FORTH_DSP_POP
33fa			 
33fa			 
33fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33fa cd fb 1b			call macro_dsp_valuehl 
33fd				endm 
# End of macro FORTH_DSP_VALUEHL
33fd			 
33fd					; one value on hl get other one back 
33fd			 
33fd d1					pop de 
33fe			 
33fe					; do the add 
33fe			 
33fe 19					add hl,de 
33ff			 
33ff					; save it 
33ff			 
33ff			;		push hl	 
33ff			 
33ff					; 
33ff			 
33ff					; destroy value TOS 
33ff			 
33ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33ff cd b3 1c			call macro_forth_dsp_pop 
3402				endm 
# End of macro FORTH_DSP_POP
3402			 
3402					; TODO push value back onto stack for another op etc 
3402			 
3402			;		pop hl 
3402			 
3402			.dot_done: 
3402 cd 04 1a				call forth_push_numhl 
3405			 
3405					NEXTW 
3405 c3 6d 1d			jp macro_next 
3408				endm 
# End of macro NEXTW
3408			.NEG: 
3408			 
3408				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3408 17				db WORD_SYS_CORE+3             
3409 4b 34			dw .DIV            
340b 02				db 1 + 1 
340c .. 00			db "-",0              
340e				endm 
# End of macro CWHEAD
340e			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
340e					if DEBUG_FORTH_WORDS_KEY 
340e						DMARK "SUB" 
340e f5				push af  
340f 3a 23 34			ld a, (.dmark)  
3412 32 7a ee			ld (debug_mark),a  
3415 3a 24 34			ld a, (.dmark+1)  
3418 32 7b ee			ld (debug_mark+1),a  
341b 3a 25 34			ld a, (.dmark+2)  
341e 32 7c ee			ld (debug_mark+2),a  
3421 18 03			jr .pastdmark  
3423 ..			.dmark: db "SUB"  
3426 f1			.pastdmark: pop af  
3427			endm  
# End of macro DMARK
3427						CALLMONITOR 
3427 cd 77 14			call break_point_state  
342a				endm  
# End of macro CALLMONITOR
342a					endif 
342a			 
342a			 
342a				; TODO add floating point number detection 
342a					; v5 FORTH_DSP_VALUE 
342a					FORTH_DSP 
342a cd c1 1b			call macro_forth_dsp 
342d				endm 
# End of macro FORTH_DSP
342d 7e					ld a,(hl)	; get type of value on TOS 
342e fe 02				cp DS_TYPE_INUM  
3430 28 03				jr z, .neg_inum 
3432			 
3432					NEXTW 
3432 c3 6d 1d			jp macro_next 
3435				endm 
# End of macro NEXTW
3435			 
3435			; float maths 
3435			 
3435				if FORTH_ENABLE_FLOATMATH 
3435					jr .neg_done 
3435			 
3435				endif 
3435					 
3435			 
3435			.neg_inum: 
3435					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3435 cd fb 1b			call macro_dsp_valuehl 
3438				endm 
# End of macro FORTH_DSP_VALUEHL
3438			 
3438 e5					push hl 
3439			 
3439					; destroy value TOS 
3439			 
3439					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3439 cd b3 1c			call macro_forth_dsp_pop 
343c				endm 
# End of macro FORTH_DSP_POP
343c			 
343c			 
343c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
343c cd fb 1b			call macro_dsp_valuehl 
343f				endm 
# End of macro FORTH_DSP_VALUEHL
343f			 
343f					; one value on hl get other one back 
343f			 
343f d1					pop de 
3440			 
3440					; do the sub 
3440			;		ex de, hl 
3440			 
3440 ed 52				sbc hl,de 
3442			 
3442					; save it 
3442			 
3442			;		push hl	 
3442			 
3442					; 
3442			 
3442					; destroy value TOS 
3442			 
3442					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3442 cd b3 1c			call macro_forth_dsp_pop 
3445				endm 
# End of macro FORTH_DSP_POP
3445			 
3445					; TODO push value back onto stack for another op etc 
3445			 
3445			;		pop hl 
3445			 
3445 cd 04 1a				call forth_push_numhl 
3448			.neg_done: 
3448			 
3448					NEXTW 
3448 c3 6d 1d			jp macro_next 
344b				endm 
# End of macro NEXTW
344b			.DIV: 
344b				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
344b 18				db WORD_SYS_CORE+4             
344c 98 34			dw .MUL            
344e 02				db 1 + 1 
344f .. 00			db "/",0              
3451				endm 
# End of macro CWHEAD
3451			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3451					if DEBUG_FORTH_WORDS_KEY 
3451						DMARK "DIV" 
3451 f5				push af  
3452 3a 66 34			ld a, (.dmark)  
3455 32 7a ee			ld (debug_mark),a  
3458 3a 67 34			ld a, (.dmark+1)  
345b 32 7b ee			ld (debug_mark+1),a  
345e 3a 68 34			ld a, (.dmark+2)  
3461 32 7c ee			ld (debug_mark+2),a  
3464 18 03			jr .pastdmark  
3466 ..			.dmark: db "DIV"  
3469 f1			.pastdmark: pop af  
346a			endm  
# End of macro DMARK
346a						CALLMONITOR 
346a cd 77 14			call break_point_state  
346d				endm  
# End of macro CALLMONITOR
346d					endif 
346d				; TODO add floating point number detection 
346d					; v5 FORTH_DSP_VALUE 
346d					FORTH_DSP 
346d cd c1 1b			call macro_forth_dsp 
3470				endm 
# End of macro FORTH_DSP
3470 7e					ld a,(hl)	; get type of value on TOS 
3471 fe 02				cp DS_TYPE_INUM  
3473 28 03				jr z, .div_inum 
3475			 
3475				if FORTH_ENABLE_FLOATMATH 
3475					jr .div_done 
3475			 
3475				endif 
3475					NEXTW 
3475 c3 6d 1d			jp macro_next 
3478				endm 
# End of macro NEXTW
3478			.div_inum: 
3478			 
3478					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3478 cd fb 1b			call macro_dsp_valuehl 
347b				endm 
# End of macro FORTH_DSP_VALUEHL
347b			 
347b e5					push hl    ; to go to bc 
347c			 
347c					; destroy value TOS 
347c			 
347c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
347c cd b3 1c			call macro_forth_dsp_pop 
347f				endm 
# End of macro FORTH_DSP_POP
347f			 
347f			 
347f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
347f cd fb 1b			call macro_dsp_valuehl 
3482				endm 
# End of macro FORTH_DSP_VALUEHL
3482			 
3482					; hl to go to de 
3482			 
3482 e5					push hl 
3483			 
3483 c1					pop bc 
3484 d1					pop de		 
3485			 
3485			 
3485					if DEBUG_FORTH_MATHS 
3485						DMARK "DIV" 
3485				CALLMONITOR 
3485					endif 
3485					; one value on hl but move to a get other one back 
3485			 
3485			        
3485 cd 26 0b			call Div16 
3488			 
3488			;	push af	 
3488 e5				push hl 
3489 c5				push bc 
348a			 
348a					if DEBUG_FORTH_MATHS 
348a						DMARK "DI1" 
348a				CALLMONITOR 
348a					endif 
348a			 
348a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
348a cd b3 1c			call macro_forth_dsp_pop 
348d				endm 
# End of macro FORTH_DSP_POP
348d			 
348d			 
348d			 
348d e1					pop hl    ; result 
348e			 
348e cd 04 1a				call forth_push_numhl 
3491			 
3491 e1					pop hl    ; reminder 
3492			;		ld h,0 
3492			;		ld l,d 
3492			 
3492 cd 04 1a				call forth_push_numhl 
3495			.div_done: 
3495					NEXTW 
3495 c3 6d 1d			jp macro_next 
3498				endm 
# End of macro NEXTW
3498			.MUL: 
3498				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3498 19				db WORD_SYS_CORE+5             
3499 dd 34			dw .MIN            
349b 02				db 1 + 1 
349c .. 00			db "*",0              
349e				endm 
# End of macro CWHEAD
349e			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
349e				; TODO add floating point number detection 
349e					if DEBUG_FORTH_WORDS_KEY 
349e						DMARK "MUL" 
349e f5				push af  
349f 3a b3 34			ld a, (.dmark)  
34a2 32 7a ee			ld (debug_mark),a  
34a5 3a b4 34			ld a, (.dmark+1)  
34a8 32 7b ee			ld (debug_mark+1),a  
34ab 3a b5 34			ld a, (.dmark+2)  
34ae 32 7c ee			ld (debug_mark+2),a  
34b1 18 03			jr .pastdmark  
34b3 ..			.dmark: db "MUL"  
34b6 f1			.pastdmark: pop af  
34b7			endm  
# End of macro DMARK
34b7						CALLMONITOR 
34b7 cd 77 14			call break_point_state  
34ba				endm  
# End of macro CALLMONITOR
34ba					endif 
34ba					FORTH_DSP 
34ba cd c1 1b			call macro_forth_dsp 
34bd				endm 
# End of macro FORTH_DSP
34bd					; v5 FORTH_DSP_VALUE 
34bd 7e					ld a,(hl)	; get type of value on TOS 
34be fe 02				cp DS_TYPE_INUM  
34c0 28 03				jr z, .mul_inum 
34c2			 
34c2				if FORTH_ENABLE_FLOATMATH 
34c2					jr .mul_done 
34c2			 
34c2				endif 
34c2			 
34c2					NEXTW 
34c2 c3 6d 1d			jp macro_next 
34c5				endm 
# End of macro NEXTW
34c5			.mul_inum:	 
34c5			 
34c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34c5 cd fb 1b			call macro_dsp_valuehl 
34c8				endm 
# End of macro FORTH_DSP_VALUEHL
34c8			 
34c8 e5					push hl 
34c9			 
34c9					; destroy value TOS 
34c9			 
34c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34c9 cd b3 1c			call macro_forth_dsp_pop 
34cc				endm 
# End of macro FORTH_DSP_POP
34cc			 
34cc			 
34cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34cc cd fb 1b			call macro_dsp_valuehl 
34cf				endm 
# End of macro FORTH_DSP_VALUEHL
34cf			 
34cf					; one value on hl but move to a get other one back 
34cf			 
34cf 7d					ld a, l 
34d0			 
34d0 d1					pop de 
34d1			 
34d1					; do the mull 
34d1			;		ex de, hl 
34d1			 
34d1 cd 4c 0b				call Mult16 
34d4					; save it 
34d4			 
34d4			;		push hl	 
34d4			 
34d4					; 
34d4			 
34d4					; destroy value TOS 
34d4			 
34d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d4 cd b3 1c			call macro_forth_dsp_pop 
34d7				endm 
# End of macro FORTH_DSP_POP
34d7			 
34d7					; TODO push value back onto stack for another op etc 
34d7			 
34d7			;		pop hl 
34d7			 
34d7 cd 04 1a				call forth_push_numhl 
34da			 
34da			.mul_done: 
34da					NEXTW 
34da c3 6d 1d			jp macro_next 
34dd				endm 
# End of macro NEXTW
34dd			 
34dd			 
34dd			 
34dd			 
34dd			.MIN: 
34dd				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
34dd 49				db WORD_SYS_CORE+53             
34de 5e 35			dw .MAX            
34e0 04				db 3 + 1 
34e1 .. 00			db "MIN",0              
34e5				endm 
# End of macro CWHEAD
34e5			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
34e5					if DEBUG_FORTH_WORDS_KEY 
34e5						DMARK "MIN" 
34e5 f5				push af  
34e6 3a fa 34			ld a, (.dmark)  
34e9 32 7a ee			ld (debug_mark),a  
34ec 3a fb 34			ld a, (.dmark+1)  
34ef 32 7b ee			ld (debug_mark+1),a  
34f2 3a fc 34			ld a, (.dmark+2)  
34f5 32 7c ee			ld (debug_mark+2),a  
34f8 18 03			jr .pastdmark  
34fa ..			.dmark: db "MIN"  
34fd f1			.pastdmark: pop af  
34fe			endm  
# End of macro DMARK
34fe						CALLMONITOR 
34fe cd 77 14			call break_point_state  
3501				endm  
# End of macro CALLMONITOR
3501					endif 
3501					; get u2 
3501			 
3501					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3501 cd fb 1b			call macro_dsp_valuehl 
3504				endm 
# End of macro FORTH_DSP_VALUEHL
3504			 
3504 e5					push hl   ; u2 
3505			 
3505					; destroy value TOS 
3505			 
3505					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3505 cd b3 1c			call macro_forth_dsp_pop 
3508				endm 
# End of macro FORTH_DSP_POP
3508			 
3508					; get u1 
3508			 
3508					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3508 cd fb 1b			call macro_dsp_valuehl 
350b				endm 
# End of macro FORTH_DSP_VALUEHL
350b			 
350b e5					push hl  ; u1 
350c			 
350c					; destroy value TOS 
350c			 
350c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
350c cd b3 1c			call macro_forth_dsp_pop 
350f				endm 
# End of macro FORTH_DSP_POP
350f			 
350f b7			 or a      ;clear carry flag 
3510 e1			  pop hl    ; u1 
3511 d1			  pop de    ; u2 
3512 e5				push hl   ; saved in case hl is lowest 
3513 ed 52		  sbc hl,de 
3515 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3517			 
3517 e1				pop hl 
3518					if DEBUG_FORTH_WORDS 
3518						DMARK "MIN" 
3518 f5				push af  
3519 3a 2d 35			ld a, (.dmark)  
351c 32 7a ee			ld (debug_mark),a  
351f 3a 2e 35			ld a, (.dmark+1)  
3522 32 7b ee			ld (debug_mark+1),a  
3525 3a 2f 35			ld a, (.dmark+2)  
3528 32 7c ee			ld (debug_mark+2),a  
352b 18 03			jr .pastdmark  
352d ..			.dmark: db "MIN"  
3530 f1			.pastdmark: pop af  
3531			endm  
# End of macro DMARK
3531						CALLMONITOR 
3531 cd 77 14			call break_point_state  
3534				endm  
# End of macro CALLMONITOR
3534					endif 
3534 cd 04 1a				call forth_push_numhl 
3537			 
3537				       NEXTW 
3537 c3 6d 1d			jp macro_next 
353a				endm 
# End of macro NEXTW
353a			 
353a			.mincont:  
353a c1				pop bc   ; tidy up 
353b eb				ex de , hl  
353c					if DEBUG_FORTH_WORDS 
353c						DMARK "MI1" 
353c f5				push af  
353d 3a 51 35			ld a, (.dmark)  
3540 32 7a ee			ld (debug_mark),a  
3543 3a 52 35			ld a, (.dmark+1)  
3546 32 7b ee			ld (debug_mark+1),a  
3549 3a 53 35			ld a, (.dmark+2)  
354c 32 7c ee			ld (debug_mark+2),a  
354f 18 03			jr .pastdmark  
3551 ..			.dmark: db "MI1"  
3554 f1			.pastdmark: pop af  
3555			endm  
# End of macro DMARK
3555						CALLMONITOR 
3555 cd 77 14			call break_point_state  
3558				endm  
# End of macro CALLMONITOR
3558					endif 
3558 cd 04 1a				call forth_push_numhl 
355b			 
355b				       NEXTW 
355b c3 6d 1d			jp macro_next 
355e				endm 
# End of macro NEXTW
355e			.MAX: 
355e				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
355e 4a				db WORD_SYS_CORE+54             
355f df 35			dw .RND16            
3561 04				db 3 + 1 
3562 .. 00			db "MAX",0              
3566				endm 
# End of macro CWHEAD
3566			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3566					if DEBUG_FORTH_WORDS_KEY 
3566						DMARK "MAX" 
3566 f5				push af  
3567 3a 7b 35			ld a, (.dmark)  
356a 32 7a ee			ld (debug_mark),a  
356d 3a 7c 35			ld a, (.dmark+1)  
3570 32 7b ee			ld (debug_mark+1),a  
3573 3a 7d 35			ld a, (.dmark+2)  
3576 32 7c ee			ld (debug_mark+2),a  
3579 18 03			jr .pastdmark  
357b ..			.dmark: db "MAX"  
357e f1			.pastdmark: pop af  
357f			endm  
# End of macro DMARK
357f						CALLMONITOR 
357f cd 77 14			call break_point_state  
3582				endm  
# End of macro CALLMONITOR
3582					endif 
3582					; get u2 
3582			 
3582					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3582 cd fb 1b			call macro_dsp_valuehl 
3585				endm 
# End of macro FORTH_DSP_VALUEHL
3585			 
3585 e5					push hl   ; u2 
3586			 
3586					; destroy value TOS 
3586			 
3586					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3586 cd b3 1c			call macro_forth_dsp_pop 
3589				endm 
# End of macro FORTH_DSP_POP
3589			 
3589					; get u1 
3589			 
3589					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3589 cd fb 1b			call macro_dsp_valuehl 
358c				endm 
# End of macro FORTH_DSP_VALUEHL
358c			 
358c e5					push hl  ; u1 
358d			 
358d					; destroy value TOS 
358d			 
358d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
358d cd b3 1c			call macro_forth_dsp_pop 
3590				endm 
# End of macro FORTH_DSP_POP
3590			 
3590 b7			 or a      ;clear carry flag 
3591 e1			  pop hl    ; u1 
3592 d1			  pop de    ; u2 
3593 e5				push hl   ; saved in case hl is lowest 
3594 ed 52		  sbc hl,de 
3596 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3598			 
3598 e1				pop hl 
3599					if DEBUG_FORTH_WORDS 
3599						DMARK "MAX" 
3599 f5				push af  
359a 3a ae 35			ld a, (.dmark)  
359d 32 7a ee			ld (debug_mark),a  
35a0 3a af 35			ld a, (.dmark+1)  
35a3 32 7b ee			ld (debug_mark+1),a  
35a6 3a b0 35			ld a, (.dmark+2)  
35a9 32 7c ee			ld (debug_mark+2),a  
35ac 18 03			jr .pastdmark  
35ae ..			.dmark: db "MAX"  
35b1 f1			.pastdmark: pop af  
35b2			endm  
# End of macro DMARK
35b2						CALLMONITOR 
35b2 cd 77 14			call break_point_state  
35b5				endm  
# End of macro CALLMONITOR
35b5					endif 
35b5 cd 04 1a				call forth_push_numhl 
35b8			 
35b8				       NEXTW 
35b8 c3 6d 1d			jp macro_next 
35bb				endm 
# End of macro NEXTW
35bb			 
35bb			.maxcont:  
35bb c1				pop bc   ; tidy up 
35bc eb				ex de , hl  
35bd					if DEBUG_FORTH_WORDS 
35bd						DMARK "MA1" 
35bd f5				push af  
35be 3a d2 35			ld a, (.dmark)  
35c1 32 7a ee			ld (debug_mark),a  
35c4 3a d3 35			ld a, (.dmark+1)  
35c7 32 7b ee			ld (debug_mark+1),a  
35ca 3a d4 35			ld a, (.dmark+2)  
35cd 32 7c ee			ld (debug_mark+2),a  
35d0 18 03			jr .pastdmark  
35d2 ..			.dmark: db "MA1"  
35d5 f1			.pastdmark: pop af  
35d6			endm  
# End of macro DMARK
35d6						CALLMONITOR 
35d6 cd 77 14			call break_point_state  
35d9				endm  
# End of macro CALLMONITOR
35d9					endif 
35d9 cd 04 1a				call forth_push_numhl 
35dc				       NEXTW 
35dc c3 6d 1d			jp macro_next 
35df				endm 
# End of macro NEXTW
35df			 
35df			.RND16: 
35df				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
35df 4e				db WORD_SYS_CORE+58             
35e0 0e 36			dw .RND8            
35e2 06				db 5 + 1 
35e3 .. 00			db "RND16",0              
35e9				endm 
# End of macro CWHEAD
35e9			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
35e9					if DEBUG_FORTH_WORDS_KEY 
35e9						DMARK "R16" 
35e9 f5				push af  
35ea 3a fe 35			ld a, (.dmark)  
35ed 32 7a ee			ld (debug_mark),a  
35f0 3a ff 35			ld a, (.dmark+1)  
35f3 32 7b ee			ld (debug_mark+1),a  
35f6 3a 00 36			ld a, (.dmark+2)  
35f9 32 7c ee			ld (debug_mark+2),a  
35fc 18 03			jr .pastdmark  
35fe ..			.dmark: db "R16"  
3601 f1			.pastdmark: pop af  
3602			endm  
# End of macro DMARK
3602						CALLMONITOR 
3602 cd 77 14			call break_point_state  
3605				endm  
# End of macro CALLMONITOR
3605					endif 
3605 cd f0 0a				call prng16  
3608 cd 04 1a				call forth_push_numhl 
360b				       NEXTW 
360b c3 6d 1d			jp macro_next 
360e				endm 
# End of macro NEXTW
360e			.RND8: 
360e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
360e 60				db WORD_SYS_CORE+76             
360f 43 36			dw .RND            
3611 05				db 4 + 1 
3612 .. 00			db "RND8",0              
3617				endm 
# End of macro CWHEAD
3617			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3617					if DEBUG_FORTH_WORDS_KEY 
3617						DMARK "RN8" 
3617 f5				push af  
3618 3a 2c 36			ld a, (.dmark)  
361b 32 7a ee			ld (debug_mark),a  
361e 3a 2d 36			ld a, (.dmark+1)  
3621 32 7b ee			ld (debug_mark+1),a  
3624 3a 2e 36			ld a, (.dmark+2)  
3627 32 7c ee			ld (debug_mark+2),a  
362a 18 03			jr .pastdmark  
362c ..			.dmark: db "RN8"  
362f f1			.pastdmark: pop af  
3630			endm  
# End of macro DMARK
3630						CALLMONITOR 
3630 cd 77 14			call break_point_state  
3633				endm  
# End of macro CALLMONITOR
3633					endif 
3633 2a bb eb				ld hl,(xrandc) 
3636 23					inc hl 
3637 cd 0a 0b				call xrnd 
363a 6f					ld l,a	 
363b 26 00				ld h,0 
363d cd 04 1a				call forth_push_numhl 
3640				       NEXTW 
3640 c3 6d 1d			jp macro_next 
3643				endm 
# End of macro NEXTW
3643			.RND: 
3643				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3643 60				db WORD_SYS_CORE+76             
3644 49 37			dw .ENDMATHS            
3646 04				db 3 + 1 
3647 .. 00			db "RND",0              
364b				endm 
# End of macro CWHEAD
364b			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
364b			 
364b					if DEBUG_FORTH_WORDS_KEY 
364b						DMARK "RND" 
364b f5				push af  
364c 3a 60 36			ld a, (.dmark)  
364f 32 7a ee			ld (debug_mark),a  
3652 3a 61 36			ld a, (.dmark+1)  
3655 32 7b ee			ld (debug_mark+1),a  
3658 3a 62 36			ld a, (.dmark+2)  
365b 32 7c ee			ld (debug_mark+2),a  
365e 18 03			jr .pastdmark  
3660 ..			.dmark: db "RND"  
3663 f1			.pastdmark: pop af  
3664			endm  
# End of macro DMARK
3664						CALLMONITOR 
3664 cd 77 14			call break_point_state  
3667				endm  
# End of macro CALLMONITOR
3667					endif 
3667					 
3667					FORTH_DSP_VALUEHL    ; upper range 
3667 cd fb 1b			call macro_dsp_valuehl 
366a				endm 
# End of macro FORTH_DSP_VALUEHL
366a			 
366a 22 bf eb				ld (LFSRSeed), hl	 
366d			 
366d					if DEBUG_FORTH_WORDS 
366d						DMARK "RN1" 
366d f5				push af  
366e 3a 82 36			ld a, (.dmark)  
3671 32 7a ee			ld (debug_mark),a  
3674 3a 83 36			ld a, (.dmark+1)  
3677 32 7b ee			ld (debug_mark+1),a  
367a 3a 84 36			ld a, (.dmark+2)  
367d 32 7c ee			ld (debug_mark+2),a  
3680 18 03			jr .pastdmark  
3682 ..			.dmark: db "RN1"  
3685 f1			.pastdmark: pop af  
3686			endm  
# End of macro DMARK
3686						CALLMONITOR 
3686 cd 77 14			call break_point_state  
3689				endm  
# End of macro CALLMONITOR
3689					endif 
3689					FORTH_DSP_POP 
3689 cd b3 1c			call macro_forth_dsp_pop 
368c				endm 
# End of macro FORTH_DSP_POP
368c			 
368c					FORTH_DSP_VALUEHL    ; low range 
368c cd fb 1b			call macro_dsp_valuehl 
368f				endm 
# End of macro FORTH_DSP_VALUEHL
368f			 
368f					if DEBUG_FORTH_WORDS 
368f						DMARK "RN2" 
368f f5				push af  
3690 3a a4 36			ld a, (.dmark)  
3693 32 7a ee			ld (debug_mark),a  
3696 3a a5 36			ld a, (.dmark+1)  
3699 32 7b ee			ld (debug_mark+1),a  
369c 3a a6 36			ld a, (.dmark+2)  
369f 32 7c ee			ld (debug_mark+2),a  
36a2 18 03			jr .pastdmark  
36a4 ..			.dmark: db "RN2"  
36a7 f1			.pastdmark: pop af  
36a8			endm  
# End of macro DMARK
36a8						CALLMONITOR 
36a8 cd 77 14			call break_point_state  
36ab				endm  
# End of macro CALLMONITOR
36ab					endif 
36ab 22 c1 eb				ld (LFSRSeed+2), hl 
36ae			 
36ae					FORTH_DSP_POP 
36ae cd b3 1c			call macro_forth_dsp_pop 
36b1				endm 
# End of macro FORTH_DSP_POP
36b1			 
36b1 e5					push hl 
36b2			 
36b2 e1			.inrange:	pop hl 
36b3 cd f0 0a				call prng16  
36b6					if DEBUG_FORTH_WORDS 
36b6						DMARK "RN3" 
36b6 f5				push af  
36b7 3a cb 36			ld a, (.dmark)  
36ba 32 7a ee			ld (debug_mark),a  
36bd 3a cc 36			ld a, (.dmark+1)  
36c0 32 7b ee			ld (debug_mark+1),a  
36c3 3a cd 36			ld a, (.dmark+2)  
36c6 32 7c ee			ld (debug_mark+2),a  
36c9 18 03			jr .pastdmark  
36cb ..			.dmark: db "RN3"  
36ce f1			.pastdmark: pop af  
36cf			endm  
# End of macro DMARK
36cf						CALLMONITOR 
36cf cd 77 14			call break_point_state  
36d2				endm  
# End of macro CALLMONITOR
36d2					endif 
36d2					 
36d2					; if the range is 8bit knock out the high byte 
36d2			 
36d2 ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
36d6			 
36d6 3e 00				ld a, 0 
36d8 ba					cp d  
36d9 20 1e				jr nz, .hirange 
36db 26 00				ld h, 0   ; knock it down to 8bit 
36dd			 
36dd					if DEBUG_FORTH_WORDS 
36dd						DMARK "RNk" 
36dd f5				push af  
36de 3a f2 36			ld a, (.dmark)  
36e1 32 7a ee			ld (debug_mark),a  
36e4 3a f3 36			ld a, (.dmark+1)  
36e7 32 7b ee			ld (debug_mark+1),a  
36ea 3a f4 36			ld a, (.dmark+2)  
36ed 32 7c ee			ld (debug_mark+2),a  
36f0 18 03			jr .pastdmark  
36f2 ..			.dmark: db "RNk"  
36f5 f1			.pastdmark: pop af  
36f6			endm  
# End of macro DMARK
36f6						CALLMONITOR 
36f6 cd 77 14			call break_point_state  
36f9				endm  
# End of macro CALLMONITOR
36f9					endif 
36f9			.hirange:   
36f9 e5					push hl  
36fa b7					or a  
36fb ed 52		                sbc hl, de 
36fd			 
36fd					;call cmp16 
36fd			 
36fd 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
36ff e1					pop hl 
3700 e5					push hl 
3701			 
3701					if DEBUG_FORTH_WORDS 
3701						DMARK "RN4" 
3701 f5				push af  
3702 3a 16 37			ld a, (.dmark)  
3705 32 7a ee			ld (debug_mark),a  
3708 3a 17 37			ld a, (.dmark+1)  
370b 32 7b ee			ld (debug_mark+1),a  
370e 3a 18 37			ld a, (.dmark+2)  
3711 32 7c ee			ld (debug_mark+2),a  
3714 18 03			jr .pastdmark  
3716 ..			.dmark: db "RN4"  
3719 f1			.pastdmark: pop af  
371a			endm  
# End of macro DMARK
371a						CALLMONITOR 
371a cd 77 14			call break_point_state  
371d				endm  
# End of macro CALLMONITOR
371d					endif 
371d ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
3721					;call cmp16 
3721				 
3721 b7					or a  
3722 ed 52		                sbc hl, de 
3724 38 8c				jr c, .inrange 
3726			 
3726 e1					pop hl 
3727					 
3727					if DEBUG_FORTH_WORDS 
3727						DMARK "RNd" 
3727 f5				push af  
3728 3a 3c 37			ld a, (.dmark)  
372b 32 7a ee			ld (debug_mark),a  
372e 3a 3d 37			ld a, (.dmark+1)  
3731 32 7b ee			ld (debug_mark+1),a  
3734 3a 3e 37			ld a, (.dmark+2)  
3737 32 7c ee			ld (debug_mark+2),a  
373a 18 03			jr .pastdmark  
373c ..			.dmark: db "RNd"  
373f f1			.pastdmark: pop af  
3740			endm  
# End of macro DMARK
3740						CALLMONITOR 
3740 cd 77 14			call break_point_state  
3743				endm  
# End of macro CALLMONITOR
3743					endif 
3743			 
3743			 
3743 cd 04 1a				call forth_push_numhl 
3746				       NEXTW 
3746 c3 6d 1d			jp macro_next 
3749				endm 
# End of macro NEXTW
3749			 
3749			.ENDMATHS: 
3749			 
3749			; eof 
3749			 
# End of file forth_words_maths.asm
3749			include "forth_words_display.asm" 
3749			 
3749			; | ## Display Words 
3749			 
3749			.INFO: 
3749			 
3749				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3749 62				db WORD_SYS_CORE+78             
374a 66 37			dw .ATP            
374c 05				db 4 + 1 
374d .. 00			db "INFO",0              
3752				endm 
# End of macro CWHEAD
3752			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3752					FORTH_DSP_VALUEHL 
3752 cd fb 1b			call macro_dsp_valuehl 
3755				endm 
# End of macro FORTH_DSP_VALUEHL
3755			 
3755					FORTH_DSP_POP 
3755 cd b3 1c			call macro_forth_dsp_pop 
3758				endm 
# End of macro FORTH_DSP_POP
3758			 
3758 e5					push hl 
3759			 
3759					FORTH_DSP_VALUEHL 
3759 cd fb 1b			call macro_dsp_valuehl 
375c				endm 
# End of macro FORTH_DSP_VALUEHL
375c			 
375c					FORTH_DSP_POP 
375c cd b3 1c			call macro_forth_dsp_pop 
375f				endm 
# End of macro FORTH_DSP_POP
375f			 
375f d1					pop de 
3760			 
3760 cd 2d 09				call info_panel 
3763			 
3763			 
3763					NEXTW 
3763 c3 6d 1d			jp macro_next 
3766				endm 
# End of macro NEXTW
3766			.ATP: 
3766				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3766 62				db WORD_SYS_CORE+78             
3767 dd 37			dw .FB            
3769 04				db 3 + 1 
376a .. 00			db "AT?",0              
376e				endm 
# End of macro CWHEAD
376e			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
376e					if DEBUG_FORTH_WORDS_KEY 
376e						DMARK "AT?" 
376e f5				push af  
376f 3a 83 37			ld a, (.dmark)  
3772 32 7a ee			ld (debug_mark),a  
3775 3a 84 37			ld a, (.dmark+1)  
3778 32 7b ee			ld (debug_mark+1),a  
377b 3a 85 37			ld a, (.dmark+2)  
377e 32 7c ee			ld (debug_mark+2),a  
3781 18 03			jr .pastdmark  
3783 ..			.dmark: db "AT?"  
3786 f1			.pastdmark: pop af  
3787			endm  
# End of macro DMARK
3787						CALLMONITOR 
3787 cd 77 14			call break_point_state  
378a				endm  
# End of macro CALLMONITOR
378a					endif 
378a 3a 49 eb				ld a, (f_cursor_ptr) 
378d			 
378d			if DEBUG_FORTH_WORDS 
378d				DMARK "AT?" 
378d f5				push af  
378e 3a a2 37			ld a, (.dmark)  
3791 32 7a ee			ld (debug_mark),a  
3794 3a a3 37			ld a, (.dmark+1)  
3797 32 7b ee			ld (debug_mark+1),a  
379a 3a a4 37			ld a, (.dmark+2)  
379d 32 7c ee			ld (debug_mark+2),a  
37a0 18 03			jr .pastdmark  
37a2 ..			.dmark: db "AT?"  
37a5 f1			.pastdmark: pop af  
37a6			endm  
# End of macro DMARK
37a6				CALLMONITOR 
37a6 cd 77 14			call break_point_state  
37a9				endm  
# End of macro CALLMONITOR
37a9			endif	 
37a9					; count the number of rows 
37a9			 
37a9 06 00				ld b, 0 
37ab 4f			.atpr:		ld c, a    ; save in case we go below zero 
37ac d6 28				sub display_cols 
37ae f2 b4 37				jp p, .atprunder 
37b1 04					inc b 
37b2 18 f7				jr .atpr 
37b4			.atprunder:	 
37b4			if DEBUG_FORTH_WORDS 
37b4				DMARK "A?2" 
37b4 f5				push af  
37b5 3a c9 37			ld a, (.dmark)  
37b8 32 7a ee			ld (debug_mark),a  
37bb 3a ca 37			ld a, (.dmark+1)  
37be 32 7b ee			ld (debug_mark+1),a  
37c1 3a cb 37			ld a, (.dmark+2)  
37c4 32 7c ee			ld (debug_mark+2),a  
37c7 18 03			jr .pastdmark  
37c9 ..			.dmark: db "A?2"  
37cc f1			.pastdmark: pop af  
37cd			endm  
# End of macro DMARK
37cd				CALLMONITOR 
37cd cd 77 14			call break_point_state  
37d0				endm  
# End of macro CALLMONITOR
37d0			endif	 
37d0 26 00				ld h, 0 
37d2 69					ld l, c 
37d3 cd 04 1a				call forth_push_numhl 
37d6 68					ld l, b  
37d7 cd 04 1a				call forth_push_numhl 
37da			 
37da			 
37da				NEXTW 
37da c3 6d 1d			jp macro_next 
37dd				endm 
# End of macro NEXTW
37dd			 
37dd			.FB: 
37dd				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
37dd 1b				db WORD_SYS_CORE+7             
37de 2b 38			dw .EMIT            
37e0 03				db 2 + 1 
37e1 .. 00			db "FB",0              
37e4				endm 
# End of macro CWHEAD
37e4			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
37e4			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
37e4			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
37e4			; | | If automatic display is off then updates will not be shown until DRAW is used. 
37e4					if DEBUG_FORTH_WORDS_KEY 
37e4						DMARK "FB." 
37e4 f5				push af  
37e5 3a f9 37			ld a, (.dmark)  
37e8 32 7a ee			ld (debug_mark),a  
37eb 3a fa 37			ld a, (.dmark+1)  
37ee 32 7b ee			ld (debug_mark+1),a  
37f1 3a fb 37			ld a, (.dmark+2)  
37f4 32 7c ee			ld (debug_mark+2),a  
37f7 18 03			jr .pastdmark  
37f9 ..			.dmark: db "FB."  
37fc f1			.pastdmark: pop af  
37fd			endm  
# End of macro DMARK
37fd						CALLMONITOR 
37fd cd 77 14			call break_point_state  
3800				endm  
# End of macro CALLMONITOR
3800					endif 
3800			 
3800					FORTH_DSP_VALUEHL 
3800 cd fb 1b			call macro_dsp_valuehl 
3803				endm 
# End of macro FORTH_DSP_VALUEHL
3803			 
3803 7d					ld a, l 
3804 fe 01				cp 1 
3806 20 05				jr nz, .fbn1 
3808 21 1f ed				ld hl, display_fb1 
380b 18 15				jr .fbset 
380d fe 02		.fbn1:		cp 2 
380f 20 05				jr nz, .fbn2 
3811 21 dd eb				ld hl, display_fb2 
3814 18 0c				jr .fbset 
3816 fe 03		.fbn2:		cp 3 
3818 20 05				jr nz, .fbn3 
381a 21 7e ec				ld hl, display_fb3 
381d 18 03				jr .fbset 
381f			.fbn3:		 ; if invalid number select first 
381f 21 1f ed				ld hl, display_fb1 
3822 22 db eb		.fbset:		ld (display_fb_active), hl 
3825			 
3825					FORTH_DSP_POP 
3825 cd b3 1c			call macro_forth_dsp_pop 
3828				endm 
# End of macro FORTH_DSP_POP
3828			 
3828					NEXTW 
3828 c3 6d 1d			jp macro_next 
382b				endm 
# End of macro NEXTW
382b			 
382b			 
382b			.EMIT: 
382b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
382b 1b				db WORD_SYS_CORE+7             
382c 7c 38			dw .DOTH            
382e 05				db 4 + 1 
382f .. 00			db "EMIT",0              
3834				endm 
# End of macro CWHEAD
3834			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3834					; get value off TOS and display it 
3834			 
3834					if DEBUG_FORTH_WORDS_KEY 
3834						DMARK "EMT" 
3834 f5				push af  
3835 3a 49 38			ld a, (.dmark)  
3838 32 7a ee			ld (debug_mark),a  
383b 3a 4a 38			ld a, (.dmark+1)  
383e 32 7b ee			ld (debug_mark+1),a  
3841 3a 4b 38			ld a, (.dmark+2)  
3844 32 7c ee			ld (debug_mark+2),a  
3847 18 03			jr .pastdmark  
3849 ..			.dmark: db "EMT"  
384c f1			.pastdmark: pop af  
384d			endm  
# End of macro DMARK
384d						CALLMONITOR 
384d cd 77 14			call break_point_state  
3850				endm  
# End of macro CALLMONITOR
3850					endif 
3850			 
3850					FORTH_DSP_VALUEHL 
3850 cd fb 1b			call macro_dsp_valuehl 
3853				endm 
# End of macro FORTH_DSP_VALUEHL
3853			 
3853 7d					ld a,l 
3854			 
3854					; TODO write to display 
3854			 
3854 32 5e e5				ld (os_input), a 
3857 3e 00				ld a, 0 
3859 32 5f e5				ld (os_input+1), a 
385c					 
385c 3a 49 eb				ld a, (f_cursor_ptr) 
385f 11 5e e5				ld de, os_input 
3862 cd af 09				call str_at_display 
3865			 
3865			 
3865 3a 27 eb				ld a,(cli_autodisplay) 
3868 fe 00				cp 0 
386a 28 03				jr z, .enoupdate 
386c cd bf 09						call update_display 
386f					.enoupdate: 
386f			 
386f 3a 49 eb				ld a, (f_cursor_ptr) 
3872 3c					inc a 
3873 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
3876			 
3876			 
3876					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3876 cd b3 1c			call macro_forth_dsp_pop 
3879				endm 
# End of macro FORTH_DSP_POP
3879			  
3879			 
3879					NEXTW 
3879 c3 6d 1d			jp macro_next 
387c				endm 
# End of macro NEXTW
387c			.DOTH: 
387c				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
387c 1c				db WORD_SYS_CORE+8             
387d ac 38			dw .DOTF            
387f 03				db 2 + 1 
3880 .. 00			db ".-",0              
3883				endm 
# End of macro CWHEAD
3883			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3883					; get value off TOS and display it 
3883					if DEBUG_FORTH_WORDS_KEY 
3883						DMARK "DTD" 
3883 f5				push af  
3884 3a 98 38			ld a, (.dmark)  
3887 32 7a ee			ld (debug_mark),a  
388a 3a 99 38			ld a, (.dmark+1)  
388d 32 7b ee			ld (debug_mark+1),a  
3890 3a 9a 38			ld a, (.dmark+2)  
3893 32 7c ee			ld (debug_mark+2),a  
3896 18 03			jr .pastdmark  
3898 ..			.dmark: db "DTD"  
389b f1			.pastdmark: pop af  
389c			endm  
# End of macro DMARK
389c						CALLMONITOR 
389c cd 77 14			call break_point_state  
389f				endm  
# End of macro CALLMONITOR
389f					endif 
389f 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
38a1 3e 00			ld a, 0 
38a3 32 28 eb			ld (cli_mvdot), a 
38a6 c3 03 39			jp .dotgo 
38a9				NEXTW 
38a9 c3 6d 1d			jp macro_next 
38ac				endm 
# End of macro NEXTW
38ac			.DOTF: 
38ac				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
38ac 1c				db WORD_SYS_CORE+8             
38ad da 38			dw .DOT            
38af 03				db 2 + 1 
38b0 .. 00			db ".>",0              
38b3				endm 
# End of macro CWHEAD
38b3			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
38b3					; get value off TOS and display it 
38b3			        ; TODO BUG adds extra spaces 
38b3			        ; TODO BUG handle numerics? 
38b3					if DEBUG_FORTH_WORDS_KEY 
38b3						DMARK "DTC" 
38b3 f5				push af  
38b4 3a c8 38			ld a, (.dmark)  
38b7 32 7a ee			ld (debug_mark),a  
38ba 3a c9 38			ld a, (.dmark+1)  
38bd 32 7b ee			ld (debug_mark+1),a  
38c0 3a ca 38			ld a, (.dmark+2)  
38c3 32 7c ee			ld (debug_mark+2),a  
38c6 18 03			jr .pastdmark  
38c8 ..			.dmark: db "DTC"  
38cb f1			.pastdmark: pop af  
38cc			endm  
# End of macro DMARK
38cc						CALLMONITOR 
38cc cd 77 14			call break_point_state  
38cf				endm  
# End of macro CALLMONITOR
38cf					endif 
38cf 3e 01			ld a, 1 
38d1 32 28 eb			ld (cli_mvdot), a 
38d4 c3 03 39			jp .dotgo 
38d7				NEXTW 
38d7 c3 6d 1d			jp macro_next 
38da				endm 
# End of macro NEXTW
38da			 
38da			.DOT: 
38da				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
38da 1c				db WORD_SYS_CORE+8             
38db 66 39			dw .CLS            
38dd 02				db 1 + 1 
38de .. 00			db ".",0              
38e0				endm 
# End of macro CWHEAD
38e0			        ; | . ( u -- ) Display TOS | DONE 
38e0					; get value off TOS and display it 
38e0			 
38e0					if DEBUG_FORTH_WORDS_KEY 
38e0						DMARK "DOT" 
38e0 f5				push af  
38e1 3a f5 38			ld a, (.dmark)  
38e4 32 7a ee			ld (debug_mark),a  
38e7 3a f6 38			ld a, (.dmark+1)  
38ea 32 7b ee			ld (debug_mark+1),a  
38ed 3a f7 38			ld a, (.dmark+2)  
38f0 32 7c ee			ld (debug_mark+2),a  
38f3 18 03			jr .pastdmark  
38f5 ..			.dmark: db "DOT"  
38f8 f1			.pastdmark: pop af  
38f9			endm  
# End of macro DMARK
38f9						CALLMONITOR 
38f9 cd 77 14			call break_point_state  
38fc				endm  
# End of macro CALLMONITOR
38fc					endif 
38fc 3e 00			ld a, 0 
38fe 32 28 eb			ld (cli_mvdot), a 
3901 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3903				 
3903			 
3903			.dotgo: 
3903			 
3903			; move up type to on stack for parserv5 
3903					FORTH_DSP 
3903 cd c1 1b			call macro_forth_dsp 
3906				endm 
# End of macro FORTH_DSP
3906				;FORTH_DSP_VALUE  
3906			 
3906			if DEBUG_FORTH_DOT 
3906				DMARK "DOT" 
3906				CALLMONITOR 
3906			endif	 
3906			;		.print: 
3906			 
3906 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3907 23				inc hl   ; position to the actual value 
3908 fe 01			cp DS_TYPE_STR 
390a 20 06			jr nz, .dotnum1  
390c			 
390c			; display string 
390c				FORTH_DSP_VALUE  
390c cd e4 1b			call macro_forth_dsp_value 
390f				endm 
# End of macro FORTH_DSP_VALUE
390f eb				ex de,hl 
3910 18 11			jr .dotwrite 
3912			 
3912			.dotnum1: 
3912 fe 02			cp DS_TYPE_INUM 
3914 20 0c			jr nz, .dotflot 
3916			 
3916			 
3916			; display number 
3916			 
3916			;	push hl 
3916			;	call clear_display 
3916			;	pop hl 
3916			 
3916 5e				ld e, (hl) 
3917 23				inc hl 
3918 56				ld d, (hl) 
3919 21 60 e3			ld hl, scratch 
391c			if DEBUG_FORTH_DOT 
391c				DMARK "DT1" 
391c				CALLMONITOR 
391c			endif	 
391c			 
391c cd d6 0f			call uitoa_16 
391f eb				ex de,hl 
3920			 
3920			if DEBUG_FORTH_DOT 
3920				DMARK "DT2" 
3920				CALLMONITOR 
3920			endif	 
3920			 
3920			;	ld de, os_word_scratch 
3920 18 01			jr .dotwrite 
3922			 
3922 00			.dotflot:   nop 
3923			; TODO print floating point number 
3923			 
3923			.dotwrite:		 
3923			 
3923					; if c is set then set all '-' to spaces 
3923					; need to also take into account .>  
3923			 
3923 3e 01				ld a, 1 
3925 b9					cp c 
3926 20 13				jr nz, .nodashswap 
3928			 
3928					; DE has the string to write, working with HL 
3928			 
3928 06 ff				ld b, 255 
392a d5					push de 
392b e1					pop hl 
392c			 
392c			if DEBUG_FORTH_DOT 
392c				DMARK "DT-" 
392c				CALLMONITOR 
392c			endif	 
392c 7e			.dashscan:	ld a, (hl) 
392d fe 00				cp 0 
392f 28 0a				jr z, .nodashswap 
3931 fe 2d				cp '-' 
3933 20 03				jr nz, .dashskip 
3935 3e 20				ld a, ' ' 
3937 77					ld (hl), a 
3938 23			.dashskip:	inc hl 
3939			if DEBUG_FORTH_DOT 
3939				DMARK "D-2" 
3939				CALLMONITOR 
3939			endif	 
3939 10 f1				djnz .dashscan 
393b			 
393b			if DEBUG_FORTH_DOT 
393b				DMARK "D-1" 
393b				CALLMONITOR 
393b			endif	 
393b			 
393b			.nodashswap: 
393b			 
393b e5					push hl   ; save string start in case we need to advance print 
393c			 
393c 3a 49 eb				ld a, (f_cursor_ptr) 
393f cd af 09				call str_at_display 
3942 3a 27 eb				ld a,(cli_autodisplay) 
3945 fe 00				cp 0 
3947 28 03				jr z, .noupdate 
3949 cd bf 09						call update_display 
394c					.noupdate: 
394c			 
394c			 
394c					; see if we need to advance the print position 
394c			 
394c e1					pop hl   ; get back string 
394d			 
394d 3a 28 eb				ld a, (cli_mvdot) 
3950			if DEBUG_FORTH_DOT 
3950					ld e,a 
3950				DMARK "D>1" 
3950				CALLMONITOR 
3950			endif	 
3950 fe 00				cp 0 
3952 28 0c				jr z, .noadv 
3954					; yes, lets advance the print position 
3954 3e 00				ld a, 0 
3956 cd 32 10				call strlent 
3959 3a 49 eb				ld a, (f_cursor_ptr) 
395c 85					add a,l 
395d					;call addatohl 
395d					;ld a, l 
395d 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
3960			 
3960			if DEBUG_FORTH_DOT 
3960				DMARK "D->" 
3960				CALLMONITOR 
3960			endif	 
3960			 
3960			.noadv:	 
3960			 
3960					if DEBUG_FORTH_DOT_WAIT 
3960							call next_page_prompt 
3960					endif	 
3960			; TODO this pop off the stack causes a crash. i dont know why 
3960			 
3960			 
3960			if DEBUG_FORTH_DOT 
3960				DMARK "DTh" 
3960				CALLMONITOR 
3960			endif	 
3960			 
3960					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3960 cd b3 1c			call macro_forth_dsp_pop 
3963				endm 
# End of macro FORTH_DSP_POP
3963			 
3963			if DEBUG_FORTH_DOT 
3963				DMARK "DTi" 
3963				CALLMONITOR 
3963			endif	 
3963			 
3963			 
3963					NEXTW 
3963 c3 6d 1d			jp macro_next 
3966				endm 
# End of macro NEXTW
3966			 
3966			.CLS: 
3966				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3966 35				db WORD_SYS_CORE+33             
3967 93 39			dw .DRAW            
3969 04				db 3 + 1 
396a .. 00			db "CLS",0              
396e				endm 
# End of macro CWHEAD
396e			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
396e					if DEBUG_FORTH_WORDS_KEY 
396e						DMARK "CLS" 
396e f5				push af  
396f 3a 83 39			ld a, (.dmark)  
3972 32 7a ee			ld (debug_mark),a  
3975 3a 84 39			ld a, (.dmark+1)  
3978 32 7b ee			ld (debug_mark+1),a  
397b 3a 85 39			ld a, (.dmark+2)  
397e 32 7c ee			ld (debug_mark+2),a  
3981 18 03			jr .pastdmark  
3983 ..			.dmark: db "CLS"  
3986 f1			.pastdmark: pop af  
3987			endm  
# End of macro DMARK
3987						CALLMONITOR 
3987 cd 77 14			call break_point_state  
398a				endm  
# End of macro CALLMONITOR
398a					endif 
398a cd 9c 09				call clear_display 
398d c3 a1 3a				jp .home		; and home cursor 
3990					NEXTW 
3990 c3 6d 1d			jp macro_next 
3993				endm 
# End of macro NEXTW
3993			 
3993			.DRAW: 
3993				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3993 36				db WORD_SYS_CORE+34             
3994 be 39			dw .DUMP            
3996 05				db 4 + 1 
3997 .. 00			db "DRAW",0              
399c				endm 
# End of macro CWHEAD
399c			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
399c					if DEBUG_FORTH_WORDS_KEY 
399c						DMARK "DRW" 
399c f5				push af  
399d 3a b1 39			ld a, (.dmark)  
39a0 32 7a ee			ld (debug_mark),a  
39a3 3a b2 39			ld a, (.dmark+1)  
39a6 32 7b ee			ld (debug_mark+1),a  
39a9 3a b3 39			ld a, (.dmark+2)  
39ac 32 7c ee			ld (debug_mark+2),a  
39af 18 03			jr .pastdmark  
39b1 ..			.dmark: db "DRW"  
39b4 f1			.pastdmark: pop af  
39b5			endm  
# End of macro DMARK
39b5						CALLMONITOR 
39b5 cd 77 14			call break_point_state  
39b8				endm  
# End of macro CALLMONITOR
39b8					endif 
39b8 cd bf 09				call update_display 
39bb					NEXTW 
39bb c3 6d 1d			jp macro_next 
39be				endm 
# End of macro NEXTW
39be			 
39be			.DUMP: 
39be				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
39be 37				db WORD_SYS_CORE+35             
39bf f6 39			dw .CDUMP            
39c1 05				db 4 + 1 
39c2 .. 00			db "DUMP",0              
39c7				endm 
# End of macro CWHEAD
39c7			; | DUMP ( x -- ) With address x display dump   | DONE 
39c7			; TODO pop address to use off of the stack 
39c7					if DEBUG_FORTH_WORDS_KEY 
39c7						DMARK "DUM" 
39c7 f5				push af  
39c8 3a dc 39			ld a, (.dmark)  
39cb 32 7a ee			ld (debug_mark),a  
39ce 3a dd 39			ld a, (.dmark+1)  
39d1 32 7b ee			ld (debug_mark+1),a  
39d4 3a de 39			ld a, (.dmark+2)  
39d7 32 7c ee			ld (debug_mark+2),a  
39da 18 03			jr .pastdmark  
39dc ..			.dmark: db "DUM"  
39df f1			.pastdmark: pop af  
39e0			endm  
# End of macro DMARK
39e0						CALLMONITOR 
39e0 cd 77 14			call break_point_state  
39e3				endm  
# End of macro CALLMONITOR
39e3					endif 
39e3 cd 9c 09				call clear_display 
39e6			 
39e6					; get address 
39e6			 
39e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39e6 cd fb 1b			call macro_dsp_valuehl 
39e9				endm 
# End of macro FORTH_DSP_VALUEHL
39e9				 
39e9					; save it for cdump 
39e9			 
39e9 22 83 e6				ld (os_cur_ptr),hl 
39ec			 
39ec					; destroy value TOS 
39ec			 
39ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ec cd b3 1c			call macro_forth_dsp_pop 
39ef				endm 
# End of macro FORTH_DSP_POP
39ef			 
39ef cd 84 18				call dumpcont	; skip old style of param parsing	 
39f2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
39f3					NEXTW 
39f3 c3 6d 1d			jp macro_next 
39f6				endm 
# End of macro NEXTW
39f6			.CDUMP: 
39f6				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
39f6 38				db WORD_SYS_CORE+36             
39f7 26 3a			dw .DAT            
39f9 06				db 5 + 1 
39fa .. 00			db "CDUMP",0              
3a00				endm 
# End of macro CWHEAD
3a00			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3a00					if DEBUG_FORTH_WORDS_KEY 
3a00						DMARK "CDP" 
3a00 f5				push af  
3a01 3a 15 3a			ld a, (.dmark)  
3a04 32 7a ee			ld (debug_mark),a  
3a07 3a 16 3a			ld a, (.dmark+1)  
3a0a 32 7b ee			ld (debug_mark+1),a  
3a0d 3a 17 3a			ld a, (.dmark+2)  
3a10 32 7c ee			ld (debug_mark+2),a  
3a13 18 03			jr .pastdmark  
3a15 ..			.dmark: db "CDP"  
3a18 f1			.pastdmark: pop af  
3a19			endm  
# End of macro DMARK
3a19						CALLMONITOR 
3a19 cd 77 14			call break_point_state  
3a1c				endm  
# End of macro CALLMONITOR
3a1c					endif 
3a1c cd 9c 09				call clear_display 
3a1f cd 84 18				call dumpcont	 
3a22 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3a23					NEXTW 
3a23 c3 6d 1d			jp macro_next 
3a26				endm 
# End of macro NEXTW
3a26			 
3a26			 
3a26			 
3a26			 
3a26			.DAT: 
3a26				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3a26 3d				db WORD_SYS_CORE+41             
3a27 7c 3a			dw .HOME            
3a29 03				db 2 + 1 
3a2a .. 00			db "AT",0              
3a2d				endm 
# End of macro CWHEAD
3a2d			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3a2d					if DEBUG_FORTH_WORDS_KEY 
3a2d						DMARK "AT." 
3a2d f5				push af  
3a2e 3a 42 3a			ld a, (.dmark)  
3a31 32 7a ee			ld (debug_mark),a  
3a34 3a 43 3a			ld a, (.dmark+1)  
3a37 32 7b ee			ld (debug_mark+1),a  
3a3a 3a 44 3a			ld a, (.dmark+2)  
3a3d 32 7c ee			ld (debug_mark+2),a  
3a40 18 03			jr .pastdmark  
3a42 ..			.dmark: db "AT."  
3a45 f1			.pastdmark: pop af  
3a46			endm  
# End of macro DMARK
3a46						CALLMONITOR 
3a46 cd 77 14			call break_point_state  
3a49				endm  
# End of macro CALLMONITOR
3a49					endif 
3a49					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a49 cd fb 1b			call macro_dsp_valuehl 
3a4c				endm 
# End of macro FORTH_DSP_VALUEHL
3a4c			 
3a4c			 
3a4c					; TODO save cursor row 
3a4c 7d					ld a,l 
3a4d fe 02				cp 2 
3a4f 20 04				jr nz, .crow3 
3a51 3e 28				ld a, display_row_2 
3a53 18 12				jr .ccol1 
3a55 fe 03		.crow3:		cp 3 
3a57 20 04				jr nz, .crow4 
3a59 3e 50				ld a, display_row_3 
3a5b 18 0a				jr .ccol1 
3a5d fe 04		.crow4:		cp 4 
3a5f 20 04				jr nz, .crow1 
3a61 3e 78				ld a, display_row_4 
3a63 18 02				jr .ccol1 
3a65 3e 00		.crow1:		ld a,display_row_1 
3a67 f5			.ccol1:		push af			; got row offset 
3a68 6f					ld l,a 
3a69 26 00				ld h,0 
3a6b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a6b cd b3 1c			call macro_forth_dsp_pop 
3a6e				endm 
# End of macro FORTH_DSP_POP
3a6e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a6e cd fb 1b			call macro_dsp_valuehl 
3a71				endm 
# End of macro FORTH_DSP_VALUEHL
3a71					; TODO save cursor col 
3a71 f1					pop af 
3a72 85					add l		; add col offset 
3a73 32 49 eb				ld (f_cursor_ptr), a 
3a76					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a76 cd b3 1c			call macro_forth_dsp_pop 
3a79				endm 
# End of macro FORTH_DSP_POP
3a79			 
3a79					; calculate  
3a79			 
3a79					NEXTW 
3a79 c3 6d 1d			jp macro_next 
3a7c				endm 
# End of macro NEXTW
3a7c			 
3a7c			 
3a7c			.HOME: 
3a7c				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3a7c 41				db WORD_SYS_CORE+45             
3a7d a9 3a			dw .SPACE            
3a7f 05				db 4 + 1 
3a80 .. 00			db "HOME",0              
3a85				endm 
# End of macro CWHEAD
3a85			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3a85					if DEBUG_FORTH_WORDS_KEY 
3a85						DMARK "HOM" 
3a85 f5				push af  
3a86 3a 9a 3a			ld a, (.dmark)  
3a89 32 7a ee			ld (debug_mark),a  
3a8c 3a 9b 3a			ld a, (.dmark+1)  
3a8f 32 7b ee			ld (debug_mark+1),a  
3a92 3a 9c 3a			ld a, (.dmark+2)  
3a95 32 7c ee			ld (debug_mark+2),a  
3a98 18 03			jr .pastdmark  
3a9a ..			.dmark: db "HOM"  
3a9d f1			.pastdmark: pop af  
3a9e			endm  
# End of macro DMARK
3a9e						CALLMONITOR 
3a9e cd 77 14			call break_point_state  
3aa1				endm  
# End of macro CALLMONITOR
3aa1					endif 
3aa1 3e 00		.home:		ld a, 0		; and home cursor 
3aa3 32 49 eb				ld (f_cursor_ptr), a 
3aa6					NEXTW 
3aa6 c3 6d 1d			jp macro_next 
3aa9				endm 
# End of macro NEXTW
3aa9			 
3aa9			 
3aa9			.SPACE: 
3aa9				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3aa9 46				db WORD_SYS_CORE+50             
3aaa d7 3a			dw .SPACES            
3aac 03				db 2 + 1 
3aad .. 00			db "BL",0              
3ab0				endm 
# End of macro CWHEAD
3ab0			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3ab0					if DEBUG_FORTH_WORDS_KEY 
3ab0						DMARK "BL." 
3ab0 f5				push af  
3ab1 3a c5 3a			ld a, (.dmark)  
3ab4 32 7a ee			ld (debug_mark),a  
3ab7 3a c6 3a			ld a, (.dmark+1)  
3aba 32 7b ee			ld (debug_mark+1),a  
3abd 3a c7 3a			ld a, (.dmark+2)  
3ac0 32 7c ee			ld (debug_mark+2),a  
3ac3 18 03			jr .pastdmark  
3ac5 ..			.dmark: db "BL."  
3ac8 f1			.pastdmark: pop af  
3ac9			endm  
# End of macro DMARK
3ac9						CALLMONITOR 
3ac9 cd 77 14			call break_point_state  
3acc				endm  
# End of macro CALLMONITOR
3acc					endif 
3acc 21 d5 3a				ld hl, .blstr 
3acf cd 72 1a				call forth_push_str 
3ad2					 
3ad2				       NEXTW 
3ad2 c3 6d 1d			jp macro_next 
3ad5				endm 
# End of macro NEXTW
3ad5			 
3ad5 .. 00		.blstr: db " ", 0 
3ad7			 
3ad7			.SPACES: 
3ad7				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3ad7 47				db WORD_SYS_CORE+51             
3ad8 72 3b			dw .SCROLL            
3ada 07				db 6 + 1 
3adb .. 00			db "SPACES",0              
3ae2				endm 
# End of macro CWHEAD
3ae2			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3ae2					if DEBUG_FORTH_WORDS_KEY 
3ae2						DMARK "SPS" 
3ae2 f5				push af  
3ae3 3a f7 3a			ld a, (.dmark)  
3ae6 32 7a ee			ld (debug_mark),a  
3ae9 3a f8 3a			ld a, (.dmark+1)  
3aec 32 7b ee			ld (debug_mark+1),a  
3aef 3a f9 3a			ld a, (.dmark+2)  
3af2 32 7c ee			ld (debug_mark+2),a  
3af5 18 03			jr .pastdmark  
3af7 ..			.dmark: db "SPS"  
3afa f1			.pastdmark: pop af  
3afb			endm  
# End of macro DMARK
3afb						CALLMONITOR 
3afb cd 77 14			call break_point_state  
3afe				endm  
# End of macro CALLMONITOR
3afe					endif 
3afe			 
3afe			 
3afe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3afe cd fb 1b			call macro_dsp_valuehl 
3b01				endm 
# End of macro FORTH_DSP_VALUEHL
3b01			 
3b01			;		push hl    ; u 
3b01					if DEBUG_FORTH_WORDS 
3b01						DMARK "SPA" 
3b01 f5				push af  
3b02 3a 16 3b			ld a, (.dmark)  
3b05 32 7a ee			ld (debug_mark),a  
3b08 3a 17 3b			ld a, (.dmark+1)  
3b0b 32 7b ee			ld (debug_mark+1),a  
3b0e 3a 18 3b			ld a, (.dmark+2)  
3b11 32 7c ee			ld (debug_mark+2),a  
3b14 18 03			jr .pastdmark  
3b16 ..			.dmark: db "SPA"  
3b19 f1			.pastdmark: pop af  
3b1a			endm  
# End of macro DMARK
3b1a						CALLMONITOR 
3b1a cd 77 14			call break_point_state  
3b1d				endm  
# End of macro CALLMONITOR
3b1d					endif 
3b1d			 
3b1d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b1d cd b3 1c			call macro_forth_dsp_pop 
3b20				endm 
# End of macro FORTH_DSP_POP
3b20			;		pop hl 
3b20 4d					ld c, l 
3b21 06 00				ld b, 0 
3b23 21 60 e3				ld hl, scratch  
3b26			 
3b26					if DEBUG_FORTH_WORDS 
3b26						DMARK "SP2" 
3b26 f5				push af  
3b27 3a 3b 3b			ld a, (.dmark)  
3b2a 32 7a ee			ld (debug_mark),a  
3b2d 3a 3c 3b			ld a, (.dmark+1)  
3b30 32 7b ee			ld (debug_mark+1),a  
3b33 3a 3d 3b			ld a, (.dmark+2)  
3b36 32 7c ee			ld (debug_mark+2),a  
3b39 18 03			jr .pastdmark  
3b3b ..			.dmark: db "SP2"  
3b3e f1			.pastdmark: pop af  
3b3f			endm  
# End of macro DMARK
3b3f						CALLMONITOR 
3b3f cd 77 14			call break_point_state  
3b42				endm  
# End of macro CALLMONITOR
3b42					endif 
3b42 3e 20				ld a, ' ' 
3b44 c5			.spaces1:	push bc 
3b45 77					ld (hl),a 
3b46 23					inc hl 
3b47 c1					pop bc 
3b48 10 fa				djnz .spaces1 
3b4a 3e 00				ld a,0 
3b4c 77					ld (hl),a 
3b4d 21 60 e3				ld hl, scratch 
3b50					if DEBUG_FORTH_WORDS 
3b50						DMARK "SP3" 
3b50 f5				push af  
3b51 3a 65 3b			ld a, (.dmark)  
3b54 32 7a ee			ld (debug_mark),a  
3b57 3a 66 3b			ld a, (.dmark+1)  
3b5a 32 7b ee			ld (debug_mark+1),a  
3b5d 3a 67 3b			ld a, (.dmark+2)  
3b60 32 7c ee			ld (debug_mark+2),a  
3b63 18 03			jr .pastdmark  
3b65 ..			.dmark: db "SP3"  
3b68 f1			.pastdmark: pop af  
3b69			endm  
# End of macro DMARK
3b69						CALLMONITOR 
3b69 cd 77 14			call break_point_state  
3b6c				endm  
# End of macro CALLMONITOR
3b6c					endif 
3b6c cd 6d 1b				call forth_apush 
3b6f			 
3b6f				       NEXTW 
3b6f c3 6d 1d			jp macro_next 
3b72				endm 
# End of macro NEXTW
3b72			 
3b72			 
3b72			 
3b72			.SCROLL: 
3b72				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3b72 53				db WORD_SYS_CORE+63             
3b73 9f 3b			dw .SCROLLD            
3b75 07				db 6 + 1 
3b76 .. 00			db "SCROLL",0              
3b7d				endm 
# End of macro CWHEAD
3b7d			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3b7d					if DEBUG_FORTH_WORDS_KEY 
3b7d						DMARK "SCR" 
3b7d f5				push af  
3b7e 3a 92 3b			ld a, (.dmark)  
3b81 32 7a ee			ld (debug_mark),a  
3b84 3a 93 3b			ld a, (.dmark+1)  
3b87 32 7b ee			ld (debug_mark+1),a  
3b8a 3a 94 3b			ld a, (.dmark+2)  
3b8d 32 7c ee			ld (debug_mark+2),a  
3b90 18 03			jr .pastdmark  
3b92 ..			.dmark: db "SCR"  
3b95 f1			.pastdmark: pop af  
3b96			endm  
# End of macro DMARK
3b96						CALLMONITOR 
3b96 cd 77 14			call break_point_state  
3b99				endm  
# End of macro CALLMONITOR
3b99					endif 
3b99			 
3b99 cd 5e 09			call scroll_up 
3b9c			;	call update_display 
3b9c			 
3b9c					NEXTW 
3b9c c3 6d 1d			jp macro_next 
3b9f				endm 
# End of macro NEXTW
3b9f			 
3b9f			 
3b9f			 
3b9f			;		; get dir 
3b9f			; 
3b9f			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b9f			; 
3b9f			;		push hl 
3b9f			; 
3b9f			;		; destroy value TOS 
3b9f			; 
3b9f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b9f			; 
3b9f			;		; get count 
3b9f			; 
3b9f			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b9f			; 
3b9f			;		push hl 
3b9f			; 
3b9f			;		; destroy value TOS 
3b9f			; 
3b9f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b9f			; 
3b9f			;		; one value on hl get other one back 
3b9f			; 
3b9f			;		pop bc    ; count 
3b9f			; 
3b9f			;		pop de   ; dir 
3b9f			; 
3b9f			; 
3b9f			;		ld b, c 
3b9f			; 
3b9f			;.scrolldir:     push bc 
3b9f			;		push de 
3b9f			; 
3b9f			;		ld a, 0 
3b9f			;		cp e 
3b9f			;		jr z, .scrollup  
3b9f			;		call scroll_down 
3b9f			;		jr .scrollnext 
3b9f			;.scrollup:	call scroll_up 
3b9f			; 
3b9f			;		 
3b9f			;.scrollnext: 
3b9f			;		pop de 
3b9f			;		pop bc 
3b9f			;		djnz .scrolldir 
3b9f			; 
3b9f			; 
3b9f			; 
3b9f			; 
3b9f			; 
3b9f			;		NEXTW 
3b9f			 
3b9f			.SCROLLD: 
3b9f				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3b9f 53				db WORD_SYS_CORE+63             
3ba0 cd 3b			dw .ATQ            
3ba2 08				db 7 + 1 
3ba3 .. 00			db "SCROLLD",0              
3bab				endm 
# End of macro CWHEAD
3bab			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3bab					if DEBUG_FORTH_WORDS_KEY 
3bab						DMARK "SCD" 
3bab f5				push af  
3bac 3a c0 3b			ld a, (.dmark)  
3baf 32 7a ee			ld (debug_mark),a  
3bb2 3a c1 3b			ld a, (.dmark+1)  
3bb5 32 7b ee			ld (debug_mark+1),a  
3bb8 3a c2 3b			ld a, (.dmark+2)  
3bbb 32 7c ee			ld (debug_mark+2),a  
3bbe 18 03			jr .pastdmark  
3bc0 ..			.dmark: db "SCD"  
3bc3 f1			.pastdmark: pop af  
3bc4			endm  
# End of macro DMARK
3bc4						CALLMONITOR 
3bc4 cd 77 14			call break_point_state  
3bc7				endm  
# End of macro CALLMONITOR
3bc7					endif 
3bc7			 
3bc7 cd 82 09			call scroll_down 
3bca			;	call update_display 
3bca			 
3bca					NEXTW 
3bca c3 6d 1d			jp macro_next 
3bcd				endm 
# End of macro NEXTW
3bcd			 
3bcd			 
3bcd			.ATQ: 
3bcd				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3bcd 62				db WORD_SYS_CORE+78             
3bce 2b 3c			dw .AUTODSP            
3bd0 04				db 3 + 1 
3bd1 .. 00			db "AT@",0              
3bd5				endm 
# End of macro CWHEAD
3bd5			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3bd5					if DEBUG_FORTH_WORDS_KEY 
3bd5						DMARK "ATA" 
3bd5 f5				push af  
3bd6 3a ea 3b			ld a, (.dmark)  
3bd9 32 7a ee			ld (debug_mark),a  
3bdc 3a eb 3b			ld a, (.dmark+1)  
3bdf 32 7b ee			ld (debug_mark+1),a  
3be2 3a ec 3b			ld a, (.dmark+2)  
3be5 32 7c ee			ld (debug_mark+2),a  
3be8 18 03			jr .pastdmark  
3bea ..			.dmark: db "ATA"  
3bed f1			.pastdmark: pop af  
3bee			endm  
# End of macro DMARK
3bee						CALLMONITOR 
3bee cd 77 14			call break_point_state  
3bf1				endm  
# End of macro CALLMONITOR
3bf1					endif 
3bf1			 
3bf1			 
3bf1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bf1 cd fb 1b			call macro_dsp_valuehl 
3bf4				endm 
# End of macro FORTH_DSP_VALUEHL
3bf4			 
3bf4					; TODO save cursor row 
3bf4 7d					ld a,l 
3bf5 fe 02				cp 2 
3bf7 20 04				jr nz, .crow3aq 
3bf9 3e 28				ld a, display_row_2 
3bfb 18 12				jr .ccol1aq 
3bfd fe 03		.crow3aq:		cp 3 
3bff 20 04				jr nz, .crow4aq 
3c01 3e 50				ld a, display_row_3 
3c03 18 0a				jr .ccol1aq 
3c05 fe 04		.crow4aq:		cp 4 
3c07 20 04				jr nz, .crow1aq 
3c09 3e 78				ld a, display_row_4 
3c0b 18 02				jr .ccol1aq 
3c0d 3e 00		.crow1aq:		ld a,display_row_1 
3c0f f5			.ccol1aq:		push af			; got row offset 
3c10 6f					ld l,a 
3c11 26 00				ld h,0 
3c13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c13 cd b3 1c			call macro_forth_dsp_pop 
3c16				endm 
# End of macro FORTH_DSP_POP
3c16					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c16 cd fb 1b			call macro_dsp_valuehl 
3c19				endm 
# End of macro FORTH_DSP_VALUEHL
3c19					; TODO save cursor col 
3c19 f1					pop af 
3c1a 85					add l		; add col offset 
3c1b			 
3c1b					; add current frame buffer address 
3c1b 2a db eb				ld hl, (display_fb_active) 
3c1e cd c9 0b				call addatohl 
3c21			 
3c21			 
3c21			 
3c21			 
3c21					; get char frame buffer location offset in hl 
3c21			 
3c21 7e					ld a,(hl) 
3c22 26 00				ld h, 0 
3c24 6f					ld l, a 
3c25			 
3c25 cd 04 1a				call forth_push_numhl 
3c28			 
3c28			 
3c28					NEXTW 
3c28 c3 6d 1d			jp macro_next 
3c2b				endm 
# End of macro NEXTW
3c2b			 
3c2b			.AUTODSP: 
3c2b				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3c2b 63				db WORD_SYS_CORE+79             
3c2c 41 3c			dw .MENU            
3c2e 05				db 4 + 1 
3c2f .. 00			db "ADSP",0              
3c34				endm 
# End of macro CWHEAD
3c34			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3c34			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3c34			 
3c34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c34 cd fb 1b			call macro_dsp_valuehl 
3c37				endm 
# End of macro FORTH_DSP_VALUEHL
3c37			 
3c37			;		push hl 
3c37			 
3c37					; destroy value TOS 
3c37			 
3c37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c37 cd b3 1c			call macro_forth_dsp_pop 
3c3a				endm 
# End of macro FORTH_DSP_POP
3c3a			 
3c3a			;		pop hl 
3c3a			 
3c3a 7d					ld a,l 
3c3b 32 27 eb				ld (cli_autodisplay), a 
3c3e				       NEXTW 
3c3e c3 6d 1d			jp macro_next 
3c41				endm 
# End of macro NEXTW
3c41			 
3c41			.MENU: 
3c41				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3c41 70				db WORD_SYS_CORE+92             
3c42 ea 3c			dw .ENDDISPLAY            
3c44 05				db 4 + 1 
3c45 .. 00			db "MENU",0              
3c4a				endm 
# End of macro CWHEAD
3c4a			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3c4a			 
3c4a			;		; get number of items on the stack 
3c4a			; 
3c4a				 
3c4a					FORTH_DSP_VALUEHL 
3c4a cd fb 1b			call macro_dsp_valuehl 
3c4d				endm 
# End of macro FORTH_DSP_VALUEHL
3c4d				 
3c4d					if DEBUG_FORTH_WORDS_KEY 
3c4d						DMARK "MNU" 
3c4d f5				push af  
3c4e 3a 62 3c			ld a, (.dmark)  
3c51 32 7a ee			ld (debug_mark),a  
3c54 3a 63 3c			ld a, (.dmark+1)  
3c57 32 7b ee			ld (debug_mark+1),a  
3c5a 3a 64 3c			ld a, (.dmark+2)  
3c5d 32 7c ee			ld (debug_mark+2),a  
3c60 18 03			jr .pastdmark  
3c62 ..			.dmark: db "MNU"  
3c65 f1			.pastdmark: pop af  
3c66			endm  
# End of macro DMARK
3c66						CALLMONITOR 
3c66 cd 77 14			call break_point_state  
3c69				endm  
# End of macro CALLMONITOR
3c69					endif 
3c69			 
3c69 45					ld b, l	 
3c6a 05					dec b 
3c6b			 
3c6b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c6b cd b3 1c			call macro_forth_dsp_pop 
3c6e				endm 
# End of macro FORTH_DSP_POP
3c6e			 
3c6e			 
3c6e					; go directly through the stack to pluck out the string pointers and build an array 
3c6e			 
3c6e			;		FORTH_DSP 
3c6e			 
3c6e					; hl contains top most stack item 
3c6e				 
3c6e 11 60 e3				ld de, scratch 
3c71			 
3c71			.mbuild: 
3c71			 
3c71					FORTH_DSP_VALUEHL 
3c71 cd fb 1b			call macro_dsp_valuehl 
3c74				endm 
# End of macro FORTH_DSP_VALUEHL
3c74			 
3c74					if DEBUG_FORTH_WORDS 
3c74						DMARK "MN3" 
3c74 f5				push af  
3c75 3a 89 3c			ld a, (.dmark)  
3c78 32 7a ee			ld (debug_mark),a  
3c7b 3a 8a 3c			ld a, (.dmark+1)  
3c7e 32 7b ee			ld (debug_mark+1),a  
3c81 3a 8b 3c			ld a, (.dmark+2)  
3c84 32 7c ee			ld (debug_mark+2),a  
3c87 18 03			jr .pastdmark  
3c89 ..			.dmark: db "MN3"  
3c8c f1			.pastdmark: pop af  
3c8d			endm  
# End of macro DMARK
3c8d						CALLMONITOR 
3c8d cd 77 14			call break_point_state  
3c90				endm  
# End of macro CALLMONITOR
3c90					endif 
3c90 eb					ex de, hl 
3c91 73					ld (hl), e 
3c92 23					inc hl 
3c93 72					ld (hl), d 
3c94 23					inc hl 
3c95 eb					ex de, hl 
3c96			 
3c96					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c96 cd b3 1c			call macro_forth_dsp_pop 
3c99				endm 
# End of macro FORTH_DSP_POP
3c99			 
3c99 10 d6				djnz .mbuild 
3c9b			 
3c9b					; done add term 
3c9b			 
3c9b eb					ex de, hl 
3c9c 36 00				ld (hl), 0 
3c9e 23					inc hl 
3c9f 36 00				ld (hl), 0 
3ca1			 
3ca1				 
3ca1					 
3ca1 21 60 e3				ld hl, scratch 
3ca4			 
3ca4					if DEBUG_FORTH_WORDS 
3ca4						DMARK "MNx" 
3ca4 f5				push af  
3ca5 3a b9 3c			ld a, (.dmark)  
3ca8 32 7a ee			ld (debug_mark),a  
3cab 3a ba 3c			ld a, (.dmark+1)  
3cae 32 7b ee			ld (debug_mark+1),a  
3cb1 3a bb 3c			ld a, (.dmark+2)  
3cb4 32 7c ee			ld (debug_mark+2),a  
3cb7 18 03			jr .pastdmark  
3cb9 ..			.dmark: db "MNx"  
3cbc f1			.pastdmark: pop af  
3cbd			endm  
# End of macro DMARK
3cbd						CALLMONITOR 
3cbd cd 77 14			call break_point_state  
3cc0				endm  
# End of macro CALLMONITOR
3cc0					endif 
3cc0			 
3cc0			 
3cc0			 
3cc0 3e 00				ld a, 0 
3cc2 cd cd 09				call menu 
3cc5			 
3cc5			 
3cc5 6f					ld l, a 
3cc6 26 00				ld h, 0 
3cc8			 
3cc8					if DEBUG_FORTH_WORDS 
3cc8						DMARK "MNr" 
3cc8 f5				push af  
3cc9 3a dd 3c			ld a, (.dmark)  
3ccc 32 7a ee			ld (debug_mark),a  
3ccf 3a de 3c			ld a, (.dmark+1)  
3cd2 32 7b ee			ld (debug_mark+1),a  
3cd5 3a df 3c			ld a, (.dmark+2)  
3cd8 32 7c ee			ld (debug_mark+2),a  
3cdb 18 03			jr .pastdmark  
3cdd ..			.dmark: db "MNr"  
3ce0 f1			.pastdmark: pop af  
3ce1			endm  
# End of macro DMARK
3ce1						CALLMONITOR 
3ce1 cd 77 14			call break_point_state  
3ce4				endm  
# End of macro CALLMONITOR
3ce4					endif 
3ce4			 
3ce4 cd 04 1a				call forth_push_numhl 
3ce7			 
3ce7			 
3ce7			 
3ce7			 
3ce7				       NEXTW 
3ce7 c3 6d 1d			jp macro_next 
3cea				endm 
# End of macro NEXTW
3cea			 
3cea			 
3cea			.ENDDISPLAY: 
3cea			 
3cea			; eof 
# End of file forth_words_display.asm
3cea			include "forth_words_str.asm" 
3cea			 
3cea			; | ## String Words 
3cea			 
3cea			.PTR:   
3cea			 
3cea				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3cea 48				db WORD_SYS_CORE+52             
3ceb 17 3d			dw .STYPE            
3ced 04				db 3 + 1 
3cee .. 00			db "PTR",0              
3cf2				endm 
# End of macro CWHEAD
3cf2			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3cf2			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3cf2			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3cf2			 
3cf2					if DEBUG_FORTH_WORDS_KEY 
3cf2						DMARK "PTR" 
3cf2 f5				push af  
3cf3 3a 07 3d			ld a, (.dmark)  
3cf6 32 7a ee			ld (debug_mark),a  
3cf9 3a 08 3d			ld a, (.dmark+1)  
3cfc 32 7b ee			ld (debug_mark+1),a  
3cff 3a 09 3d			ld a, (.dmark+2)  
3d02 32 7c ee			ld (debug_mark+2),a  
3d05 18 03			jr .pastdmark  
3d07 ..			.dmark: db "PTR"  
3d0a f1			.pastdmark: pop af  
3d0b			endm  
# End of macro DMARK
3d0b						CALLMONITOR 
3d0b cd 77 14			call break_point_state  
3d0e				endm  
# End of macro CALLMONITOR
3d0e					endif 
3d0e					FORTH_DSP_VALUEHL 
3d0e cd fb 1b			call macro_dsp_valuehl 
3d11				endm 
# End of macro FORTH_DSP_VALUEHL
3d11 cd 04 1a				call forth_push_numhl 
3d14			 
3d14			 
3d14					NEXTW 
3d14 c3 6d 1d			jp macro_next 
3d17				endm 
# End of macro NEXTW
3d17			.STYPE: 
3d17				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3d17 48				db WORD_SYS_CORE+52             
3d18 66 3d			dw .UPPER            
3d1a 06				db 5 + 1 
3d1b .. 00			db "STYPE",0              
3d21				endm 
# End of macro CWHEAD
3d21			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3d21					if DEBUG_FORTH_WORDS_KEY 
3d21						DMARK "STY" 
3d21 f5				push af  
3d22 3a 36 3d			ld a, (.dmark)  
3d25 32 7a ee			ld (debug_mark),a  
3d28 3a 37 3d			ld a, (.dmark+1)  
3d2b 32 7b ee			ld (debug_mark+1),a  
3d2e 3a 38 3d			ld a, (.dmark+2)  
3d31 32 7c ee			ld (debug_mark+2),a  
3d34 18 03			jr .pastdmark  
3d36 ..			.dmark: db "STY"  
3d39 f1			.pastdmark: pop af  
3d3a			endm  
# End of macro DMARK
3d3a						CALLMONITOR 
3d3a cd 77 14			call break_point_state  
3d3d				endm  
# End of macro CALLMONITOR
3d3d					endif 
3d3d					FORTH_DSP 
3d3d cd c1 1b			call macro_forth_dsp 
3d40				endm 
# End of macro FORTH_DSP
3d40					;v5 FORTH_DSP_VALUE 
3d40			 
3d40 7e					ld a, (hl) 
3d41			 
3d41 f5					push af 
3d42			 
3d42			; Dont destroy TOS		FORTH_DSP_POP 
3d42			 
3d42 f1					pop af 
3d43			 
3d43 fe 01				cp DS_TYPE_STR 
3d45 28 09				jr z, .typestr 
3d47			 
3d47 fe 02				cp DS_TYPE_INUM 
3d49 28 0a				jr z, .typeinum 
3d4b			 
3d4b 21 64 3d				ld hl, .tna 
3d4e 18 0a				jr .tpush 
3d50			 
3d50 21 60 3d		.typestr:	ld hl, .tstr 
3d53 18 05				jr .tpush 
3d55 21 62 3d		.typeinum:	ld hl, .tinum 
3d58 18 00				jr .tpush 
3d5a			 
3d5a			.tpush: 
3d5a			 
3d5a cd 72 1a				call forth_push_str 
3d5d			 
3d5d					NEXTW 
3d5d c3 6d 1d			jp macro_next 
3d60				endm 
# End of macro NEXTW
3d60 .. 00		.tstr:	db "s",0 
3d62 .. 00		.tinum:  db "i",0 
3d64 .. 00		.tna:   db "?", 0 
3d66			 
3d66			 
3d66			.UPPER: 
3d66				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3d66 48				db WORD_SYS_CORE+52             
3d67 a1 3d			dw .LOWER            
3d69 06				db 5 + 1 
3d6a .. 00			db "UPPER",0              
3d70				endm 
# End of macro CWHEAD
3d70			; | UPPER ( s -- s ) Upper case string s  | DONE 
3d70					if DEBUG_FORTH_WORDS_KEY 
3d70						DMARK "UPR" 
3d70 f5				push af  
3d71 3a 85 3d			ld a, (.dmark)  
3d74 32 7a ee			ld (debug_mark),a  
3d77 3a 86 3d			ld a, (.dmark+1)  
3d7a 32 7b ee			ld (debug_mark+1),a  
3d7d 3a 87 3d			ld a, (.dmark+2)  
3d80 32 7c ee			ld (debug_mark+2),a  
3d83 18 03			jr .pastdmark  
3d85 ..			.dmark: db "UPR"  
3d88 f1			.pastdmark: pop af  
3d89			endm  
# End of macro DMARK
3d89						CALLMONITOR 
3d89 cd 77 14			call break_point_state  
3d8c				endm  
# End of macro CALLMONITOR
3d8c					endif 
3d8c			 
3d8c					FORTH_DSP 
3d8c cd c1 1b			call macro_forth_dsp 
3d8f				endm 
# End of macro FORTH_DSP
3d8f					 
3d8f			; TODO check is string type 
3d8f			 
3d8f					FORTH_DSP_VALUEHL 
3d8f cd fb 1b			call macro_dsp_valuehl 
3d92				endm 
# End of macro FORTH_DSP_VALUEHL
3d92			; get pointer to string in hl 
3d92			 
3d92 7e			.toup:		ld a, (hl) 
3d93 fe 00				cp 0 
3d95 28 07				jr z, .toupdone 
3d97			 
3d97 cd 36 0f				call to_upper 
3d9a			 
3d9a 77					ld (hl), a 
3d9b 23					inc hl 
3d9c 18 f4				jr .toup 
3d9e			 
3d9e					 
3d9e			 
3d9e			 
3d9e			; for each char convert to upper 
3d9e					 
3d9e			.toupdone: 
3d9e			 
3d9e			 
3d9e					NEXTW 
3d9e c3 6d 1d			jp macro_next 
3da1				endm 
# End of macro NEXTW
3da1			.LOWER: 
3da1				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3da1 48				db WORD_SYS_CORE+52             
3da2 dc 3d			dw .TCASE            
3da4 06				db 5 + 1 
3da5 .. 00			db "LOWER",0              
3dab				endm 
# End of macro CWHEAD
3dab			; | LOWER ( s -- s ) Lower case string s  | DONE 
3dab					if DEBUG_FORTH_WORDS_KEY 
3dab						DMARK "LWR" 
3dab f5				push af  
3dac 3a c0 3d			ld a, (.dmark)  
3daf 32 7a ee			ld (debug_mark),a  
3db2 3a c1 3d			ld a, (.dmark+1)  
3db5 32 7b ee			ld (debug_mark+1),a  
3db8 3a c2 3d			ld a, (.dmark+2)  
3dbb 32 7c ee			ld (debug_mark+2),a  
3dbe 18 03			jr .pastdmark  
3dc0 ..			.dmark: db "LWR"  
3dc3 f1			.pastdmark: pop af  
3dc4			endm  
# End of macro DMARK
3dc4						CALLMONITOR 
3dc4 cd 77 14			call break_point_state  
3dc7				endm  
# End of macro CALLMONITOR
3dc7					endif 
3dc7			 
3dc7					FORTH_DSP 
3dc7 cd c1 1b			call macro_forth_dsp 
3dca				endm 
# End of macro FORTH_DSP
3dca					 
3dca			; TODO check is string type 
3dca			 
3dca					FORTH_DSP_VALUEHL 
3dca cd fb 1b			call macro_dsp_valuehl 
3dcd				endm 
# End of macro FORTH_DSP_VALUEHL
3dcd			; get pointer to string in hl 
3dcd			 
3dcd 7e			.tolow:		ld a, (hl) 
3dce fe 00				cp 0 
3dd0 28 07				jr z, .tolowdone 
3dd2			 
3dd2 cd 3f 0f				call to_lower 
3dd5			 
3dd5 77					ld (hl), a 
3dd6 23					inc hl 
3dd7 18 f4				jr .tolow 
3dd9			 
3dd9					 
3dd9			 
3dd9			 
3dd9			; for each char convert to low 
3dd9					 
3dd9			.tolowdone: 
3dd9					NEXTW 
3dd9 c3 6d 1d			jp macro_next 
3ddc				endm 
# End of macro NEXTW
3ddc			.TCASE: 
3ddc				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3ddc 48				db WORD_SYS_CORE+52             
3ddd 12 3f			dw .SUBSTR            
3ddf 06				db 5 + 1 
3de0 .. 00			db "TCASE",0              
3de6				endm 
# End of macro CWHEAD
3de6			; | TCASE ( s -- s ) Title case string s  | DONE 
3de6					if DEBUG_FORTH_WORDS_KEY 
3de6						DMARK "TCS" 
3de6 f5				push af  
3de7 3a fb 3d			ld a, (.dmark)  
3dea 32 7a ee			ld (debug_mark),a  
3ded 3a fc 3d			ld a, (.dmark+1)  
3df0 32 7b ee			ld (debug_mark+1),a  
3df3 3a fd 3d			ld a, (.dmark+2)  
3df6 32 7c ee			ld (debug_mark+2),a  
3df9 18 03			jr .pastdmark  
3dfb ..			.dmark: db "TCS"  
3dfe f1			.pastdmark: pop af  
3dff			endm  
# End of macro DMARK
3dff						CALLMONITOR 
3dff cd 77 14			call break_point_state  
3e02				endm  
# End of macro CALLMONITOR
3e02					endif 
3e02			 
3e02					FORTH_DSP 
3e02 cd c1 1b			call macro_forth_dsp 
3e05				endm 
# End of macro FORTH_DSP
3e05					 
3e05			; TODO check is string type 
3e05			 
3e05					FORTH_DSP_VALUEHL 
3e05 cd fb 1b			call macro_dsp_valuehl 
3e08				endm 
# End of macro FORTH_DSP_VALUEHL
3e08			; get pointer to string in hl 
3e08			 
3e08					if DEBUG_FORTH_WORDS 
3e08						DMARK "TC1" 
3e08 f5				push af  
3e09 3a 1d 3e			ld a, (.dmark)  
3e0c 32 7a ee			ld (debug_mark),a  
3e0f 3a 1e 3e			ld a, (.dmark+1)  
3e12 32 7b ee			ld (debug_mark+1),a  
3e15 3a 1f 3e			ld a, (.dmark+2)  
3e18 32 7c ee			ld (debug_mark+2),a  
3e1b 18 03			jr .pastdmark  
3e1d ..			.dmark: db "TC1"  
3e20 f1			.pastdmark: pop af  
3e21			endm  
# End of macro DMARK
3e21						CALLMONITOR 
3e21 cd 77 14			call break_point_state  
3e24				endm  
# End of macro CALLMONITOR
3e24					endif 
3e24			 
3e24					; first time in turn to upper case first char 
3e24			 
3e24 7e					ld a, (hl) 
3e25 c3 af 3e				jp .totsiptou 
3e28			 
3e28			 
3e28 7e			.tot:		ld a, (hl) 
3e29 fe 00				cp 0 
3e2b ca f3 3e				jp z, .totdone 
3e2e			 
3e2e					if DEBUG_FORTH_WORDS 
3e2e						DMARK "TC2" 
3e2e f5				push af  
3e2f 3a 43 3e			ld a, (.dmark)  
3e32 32 7a ee			ld (debug_mark),a  
3e35 3a 44 3e			ld a, (.dmark+1)  
3e38 32 7b ee			ld (debug_mark+1),a  
3e3b 3a 45 3e			ld a, (.dmark+2)  
3e3e 32 7c ee			ld (debug_mark+2),a  
3e41 18 03			jr .pastdmark  
3e43 ..			.dmark: db "TC2"  
3e46 f1			.pastdmark: pop af  
3e47			endm  
# End of macro DMARK
3e47						CALLMONITOR 
3e47 cd 77 14			call break_point_state  
3e4a				endm  
# End of macro CALLMONITOR
3e4a					endif 
3e4a					; check to see if current char is a space 
3e4a			 
3e4a fe 20				cp ' ' 
3e4c 28 21				jr z, .totsp 
3e4e cd 3f 0f				call to_lower 
3e51					if DEBUG_FORTH_WORDS 
3e51						DMARK "TC3" 
3e51 f5				push af  
3e52 3a 66 3e			ld a, (.dmark)  
3e55 32 7a ee			ld (debug_mark),a  
3e58 3a 67 3e			ld a, (.dmark+1)  
3e5b 32 7b ee			ld (debug_mark+1),a  
3e5e 3a 68 3e			ld a, (.dmark+2)  
3e61 32 7c ee			ld (debug_mark+2),a  
3e64 18 03			jr .pastdmark  
3e66 ..			.dmark: db "TC3"  
3e69 f1			.pastdmark: pop af  
3e6a			endm  
# End of macro DMARK
3e6a						CALLMONITOR 
3e6a cd 77 14			call break_point_state  
3e6d				endm  
# End of macro CALLMONITOR
3e6d					endif 
3e6d 18 63				jr .totnxt 
3e6f			 
3e6f			.totsp:         ; on a space, find next char which should be upper 
3e6f			 
3e6f					if DEBUG_FORTH_WORDS 
3e6f						DMARK "TC4" 
3e6f f5				push af  
3e70 3a 84 3e			ld a, (.dmark)  
3e73 32 7a ee			ld (debug_mark),a  
3e76 3a 85 3e			ld a, (.dmark+1)  
3e79 32 7b ee			ld (debug_mark+1),a  
3e7c 3a 86 3e			ld a, (.dmark+2)  
3e7f 32 7c ee			ld (debug_mark+2),a  
3e82 18 03			jr .pastdmark  
3e84 ..			.dmark: db "TC4"  
3e87 f1			.pastdmark: pop af  
3e88			endm  
# End of macro DMARK
3e88						CALLMONITOR 
3e88 cd 77 14			call break_point_state  
3e8b				endm  
# End of macro CALLMONITOR
3e8b					endif 
3e8b					;; 
3e8b			 
3e8b fe 20				cp ' ' 
3e8d 20 20				jr nz, .totsiptou 
3e8f 23					inc hl 
3e90 7e					ld a, (hl) 
3e91					if DEBUG_FORTH_WORDS 
3e91						DMARK "TC5" 
3e91 f5				push af  
3e92 3a a6 3e			ld a, (.dmark)  
3e95 32 7a ee			ld (debug_mark),a  
3e98 3a a7 3e			ld a, (.dmark+1)  
3e9b 32 7b ee			ld (debug_mark+1),a  
3e9e 3a a8 3e			ld a, (.dmark+2)  
3ea1 32 7c ee			ld (debug_mark+2),a  
3ea4 18 03			jr .pastdmark  
3ea6 ..			.dmark: db "TC5"  
3ea9 f1			.pastdmark: pop af  
3eaa			endm  
# End of macro DMARK
3eaa						CALLMONITOR 
3eaa cd 77 14			call break_point_state  
3ead				endm  
# End of macro CALLMONITOR
3ead					endif 
3ead 18 c0				jr .totsp 
3eaf fe 00		.totsiptou:    cp 0 
3eb1 28 40				jr z, .totdone 
3eb3					; not space and not zero term so upper case it 
3eb3 cd 36 0f				call to_upper 
3eb6			 
3eb6					if DEBUG_FORTH_WORDS 
3eb6						DMARK "TC6" 
3eb6 f5				push af  
3eb7 3a cb 3e			ld a, (.dmark)  
3eba 32 7a ee			ld (debug_mark),a  
3ebd 3a cc 3e			ld a, (.dmark+1)  
3ec0 32 7b ee			ld (debug_mark+1),a  
3ec3 3a cd 3e			ld a, (.dmark+2)  
3ec6 32 7c ee			ld (debug_mark+2),a  
3ec9 18 03			jr .pastdmark  
3ecb ..			.dmark: db "TC6"  
3ece f1			.pastdmark: pop af  
3ecf			endm  
# End of macro DMARK
3ecf						CALLMONITOR 
3ecf cd 77 14			call break_point_state  
3ed2				endm  
# End of macro CALLMONITOR
3ed2					endif 
3ed2			 
3ed2			 
3ed2			.totnxt: 
3ed2			 
3ed2 77					ld (hl), a 
3ed3 23					inc hl 
3ed4					if DEBUG_FORTH_WORDS 
3ed4						DMARK "TC7" 
3ed4 f5				push af  
3ed5 3a e9 3e			ld a, (.dmark)  
3ed8 32 7a ee			ld (debug_mark),a  
3edb 3a ea 3e			ld a, (.dmark+1)  
3ede 32 7b ee			ld (debug_mark+1),a  
3ee1 3a eb 3e			ld a, (.dmark+2)  
3ee4 32 7c ee			ld (debug_mark+2),a  
3ee7 18 03			jr .pastdmark  
3ee9 ..			.dmark: db "TC7"  
3eec f1			.pastdmark: pop af  
3eed			endm  
# End of macro DMARK
3eed						CALLMONITOR 
3eed cd 77 14			call break_point_state  
3ef0				endm  
# End of macro CALLMONITOR
3ef0					endif 
3ef0 c3 28 3e				jp .tot 
3ef3			 
3ef3					 
3ef3			 
3ef3			 
3ef3			; for each char convert to low 
3ef3					 
3ef3			.totdone: 
3ef3					if DEBUG_FORTH_WORDS 
3ef3						DMARK "TCd" 
3ef3 f5				push af  
3ef4 3a 08 3f			ld a, (.dmark)  
3ef7 32 7a ee			ld (debug_mark),a  
3efa 3a 09 3f			ld a, (.dmark+1)  
3efd 32 7b ee			ld (debug_mark+1),a  
3f00 3a 0a 3f			ld a, (.dmark+2)  
3f03 32 7c ee			ld (debug_mark+2),a  
3f06 18 03			jr .pastdmark  
3f08 ..			.dmark: db "TCd"  
3f0b f1			.pastdmark: pop af  
3f0c			endm  
# End of macro DMARK
3f0c						CALLMONITOR 
3f0c cd 77 14			call break_point_state  
3f0f				endm  
# End of macro CALLMONITOR
3f0f					endif 
3f0f					NEXTW 
3f0f c3 6d 1d			jp macro_next 
3f12				endm 
# End of macro NEXTW
3f12			 
3f12			.SUBSTR: 
3f12				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3f12 48				db WORD_SYS_CORE+52             
3f13 70 3f			dw .LEFT            
3f15 07				db 6 + 1 
3f16 .. 00			db "SUBSTR",0              
3f1d				endm 
# End of macro CWHEAD
3f1d			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3f1d			 
3f1d					if DEBUG_FORTH_WORDS_KEY 
3f1d						DMARK "SST" 
3f1d f5				push af  
3f1e 3a 32 3f			ld a, (.dmark)  
3f21 32 7a ee			ld (debug_mark),a  
3f24 3a 33 3f			ld a, (.dmark+1)  
3f27 32 7b ee			ld (debug_mark+1),a  
3f2a 3a 34 3f			ld a, (.dmark+2)  
3f2d 32 7c ee			ld (debug_mark+2),a  
3f30 18 03			jr .pastdmark  
3f32 ..			.dmark: db "SST"  
3f35 f1			.pastdmark: pop af  
3f36			endm  
# End of macro DMARK
3f36						CALLMONITOR 
3f36 cd 77 14			call break_point_state  
3f39				endm  
# End of macro CALLMONITOR
3f39					endif 
3f39			; TODO check string type 
3f39					FORTH_DSP_VALUEHL 
3f39 cd fb 1b			call macro_dsp_valuehl 
3f3c				endm 
# End of macro FORTH_DSP_VALUEHL
3f3c			 
3f3c e5					push hl      ; string length 
3f3d			 
3f3d					FORTH_DSP_POP 
3f3d cd b3 1c			call macro_forth_dsp_pop 
3f40				endm 
# End of macro FORTH_DSP_POP
3f40			 
3f40					FORTH_DSP_VALUEHL 
3f40 cd fb 1b			call macro_dsp_valuehl 
3f43				endm 
# End of macro FORTH_DSP_VALUEHL
3f43			 
3f43 e5					push hl     ; start char 
3f44			 
3f44					FORTH_DSP_POP 
3f44 cd b3 1c			call macro_forth_dsp_pop 
3f47				endm 
# End of macro FORTH_DSP_POP
3f47			 
3f47			 
3f47					FORTH_DSP_VALUE 
3f47 cd e4 1b			call macro_forth_dsp_value 
3f4a				endm 
# End of macro FORTH_DSP_VALUE
3f4a			 
3f4a d1					pop de    ; get start post offset 
3f4b			 
3f4b 19					add hl, de    ; starting offset 
3f4c			 
3f4c c1					pop bc 
3f4d c5					push bc      ; grab size of string 
3f4e			 
3f4e e5					push hl    ; save string start  
3f4f			 
3f4f 26 00				ld h, 0 
3f51 69					ld l, c 
3f52 23					inc hl 
3f53 23					inc hl 
3f54			 
3f54 cd 90 10				call malloc 
3f57				if DEBUG_FORTH_MALLOC_GUARD 
3f57 cc 9f 45				call z,malloc_error 
3f5a				endif 
3f5a			 
3f5a eb					ex de, hl      ; save malloc area for string copy 
3f5b e1					pop hl    ; get back source 
3f5c c1					pop bc    ; get length of string back 
3f5d			 
3f5d d5					push de    ; save malloc area for after we push 
3f5e ed b0				ldir     ; copy substr 
3f60			 
3f60			 
3f60 eb					ex de, hl 
3f61 3e 00				ld a, 0 
3f63 77					ld (hl), a   ; term substr 
3f64			 
3f64					 
3f64 e1					pop hl    ; get malloc so we can push it 
3f65 e5					push hl   ; save so we can free it afterwards 
3f66			 
3f66 cd 72 1a				call forth_push_str 
3f69			 
3f69 e1					pop hl 
3f6a cd 5a 11				call free 
3f6d			 
3f6d					 
3f6d					 
3f6d			 
3f6d			 
3f6d					NEXTW 
3f6d c3 6d 1d			jp macro_next 
3f70				endm 
# End of macro NEXTW
3f70			 
3f70			.LEFT: 
3f70				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3f70 48				db WORD_SYS_CORE+52             
3f71 98 3f			dw .RIGHT            
3f73 05				db 4 + 1 
3f74 .. 00			db "LEFT",0              
3f79				endm 
# End of macro CWHEAD
3f79			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3f79					if DEBUG_FORTH_WORDS_KEY 
3f79						DMARK "LEF" 
3f79 f5				push af  
3f7a 3a 8e 3f			ld a, (.dmark)  
3f7d 32 7a ee			ld (debug_mark),a  
3f80 3a 8f 3f			ld a, (.dmark+1)  
3f83 32 7b ee			ld (debug_mark+1),a  
3f86 3a 90 3f			ld a, (.dmark+2)  
3f89 32 7c ee			ld (debug_mark+2),a  
3f8c 18 03			jr .pastdmark  
3f8e ..			.dmark: db "LEF"  
3f91 f1			.pastdmark: pop af  
3f92			endm  
# End of macro DMARK
3f92						CALLMONITOR 
3f92 cd 77 14			call break_point_state  
3f95				endm  
# End of macro CALLMONITOR
3f95					endif 
3f95			 
3f95					NEXTW 
3f95 c3 6d 1d			jp macro_next 
3f98				endm 
# End of macro NEXTW
3f98			.RIGHT: 
3f98				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3f98 48				db WORD_SYS_CORE+52             
3f99 c1 3f			dw .STR2NUM            
3f9b 06				db 5 + 1 
3f9c .. 00			db "RIGHT",0              
3fa2				endm 
# End of macro CWHEAD
3fa2			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3fa2					if DEBUG_FORTH_WORDS_KEY 
3fa2						DMARK "RIG" 
3fa2 f5				push af  
3fa3 3a b7 3f			ld a, (.dmark)  
3fa6 32 7a ee			ld (debug_mark),a  
3fa9 3a b8 3f			ld a, (.dmark+1)  
3fac 32 7b ee			ld (debug_mark+1),a  
3faf 3a b9 3f			ld a, (.dmark+2)  
3fb2 32 7c ee			ld (debug_mark+2),a  
3fb5 18 03			jr .pastdmark  
3fb7 ..			.dmark: db "RIG"  
3fba f1			.pastdmark: pop af  
3fbb			endm  
# End of macro DMARK
3fbb						CALLMONITOR 
3fbb cd 77 14			call break_point_state  
3fbe				endm  
# End of macro CALLMONITOR
3fbe					endif 
3fbe			 
3fbe					NEXTW 
3fbe c3 6d 1d			jp macro_next 
3fc1				endm 
# End of macro NEXTW
3fc1			 
3fc1			 
3fc1			.STR2NUM: 
3fc1				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3fc1 48				db WORD_SYS_CORE+52             
3fc2 4d 40			dw .NUM2STR            
3fc4 08				db 7 + 1 
3fc5 .. 00			db "STR2NUM",0              
3fcd				endm 
# End of macro CWHEAD
3fcd			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3fcd			 
3fcd			 
3fcd			; TODO STR type check to do 
3fcd					if DEBUG_FORTH_WORDS_KEY 
3fcd						DMARK "S2N" 
3fcd f5				push af  
3fce 3a e2 3f			ld a, (.dmark)  
3fd1 32 7a ee			ld (debug_mark),a  
3fd4 3a e3 3f			ld a, (.dmark+1)  
3fd7 32 7b ee			ld (debug_mark+1),a  
3fda 3a e4 3f			ld a, (.dmark+2)  
3fdd 32 7c ee			ld (debug_mark+2),a  
3fe0 18 03			jr .pastdmark  
3fe2 ..			.dmark: db "S2N"  
3fe5 f1			.pastdmark: pop af  
3fe6			endm  
# End of macro DMARK
3fe6						CALLMONITOR 
3fe6 cd 77 14			call break_point_state  
3fe9				endm  
# End of macro CALLMONITOR
3fe9					endif 
3fe9			 
3fe9					;FORTH_DSP 
3fe9					FORTH_DSP_VALUE 
3fe9 cd e4 1b			call macro_forth_dsp_value 
3fec				endm 
# End of macro FORTH_DSP_VALUE
3fec					;inc hl 
3fec			 
3fec eb					ex de, hl 
3fed					if DEBUG_FORTH_WORDS 
3fed						DMARK "S2a" 
3fed f5				push af  
3fee 3a 02 40			ld a, (.dmark)  
3ff1 32 7a ee			ld (debug_mark),a  
3ff4 3a 03 40			ld a, (.dmark+1)  
3ff7 32 7b ee			ld (debug_mark+1),a  
3ffa 3a 04 40			ld a, (.dmark+2)  
3ffd 32 7c ee			ld (debug_mark+2),a  
4000 18 03			jr .pastdmark  
4002 ..			.dmark: db "S2a"  
4005 f1			.pastdmark: pop af  
4006			endm  
# End of macro DMARK
4006						CALLMONITOR 
4006 cd 77 14			call break_point_state  
4009				endm  
# End of macro CALLMONITOR
4009					endif 
4009 cd be 0f				call string_to_uint16 
400c			 
400c					if DEBUG_FORTH_WORDS 
400c						DMARK "S2b" 
400c f5				push af  
400d 3a 21 40			ld a, (.dmark)  
4010 32 7a ee			ld (debug_mark),a  
4013 3a 22 40			ld a, (.dmark+1)  
4016 32 7b ee			ld (debug_mark+1),a  
4019 3a 23 40			ld a, (.dmark+2)  
401c 32 7c ee			ld (debug_mark+2),a  
401f 18 03			jr .pastdmark  
4021 ..			.dmark: db "S2b"  
4024 f1			.pastdmark: pop af  
4025			endm  
# End of macro DMARK
4025						CALLMONITOR 
4025 cd 77 14			call break_point_state  
4028				endm  
# End of macro CALLMONITOR
4028					endif 
4028			;		push hl 
4028					FORTH_DSP_POP 
4028 cd b3 1c			call macro_forth_dsp_pop 
402b				endm 
# End of macro FORTH_DSP_POP
402b			;		pop hl 
402b					 
402b					if DEBUG_FORTH_WORDS 
402b						DMARK "S2b" 
402b f5				push af  
402c 3a 40 40			ld a, (.dmark)  
402f 32 7a ee			ld (debug_mark),a  
4032 3a 41 40			ld a, (.dmark+1)  
4035 32 7b ee			ld (debug_mark+1),a  
4038 3a 42 40			ld a, (.dmark+2)  
403b 32 7c ee			ld (debug_mark+2),a  
403e 18 03			jr .pastdmark  
4040 ..			.dmark: db "S2b"  
4043 f1			.pastdmark: pop af  
4044			endm  
# End of macro DMARK
4044						CALLMONITOR 
4044 cd 77 14			call break_point_state  
4047				endm  
# End of macro CALLMONITOR
4047					endif 
4047 cd 04 1a				call forth_push_numhl	 
404a			 
404a				 
404a				       NEXTW 
404a c3 6d 1d			jp macro_next 
404d				endm 
# End of macro NEXTW
404d			.NUM2STR: 
404d				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
404d 48				db WORD_SYS_CORE+52             
404e 5c 40			dw .CONCAT            
4050 08				db 7 + 1 
4051 .. 00			db "NUM2STR",0              
4059				endm 
# End of macro CWHEAD
4059			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4059			 
4059			;		; malloc a string to target 
4059			;		ld hl, 10     ; TODO max string size should be fine 
4059			;		call malloc 
4059			;		push hl    ; save malloc location 
4059			; 
4059			; 
4059			;; TODO check int type 
4059			;		FORTH_DSP_VALUEHL 
4059			;		ld a, l 
4059			;		call DispAToASCII   
4059			;;TODO need to chage above call to dump into string 
4059			; 
4059			; 
4059			 
4059				       NEXTW 
4059 c3 6d 1d			jp macro_next 
405c				endm 
# End of macro NEXTW
405c			 
405c			.CONCAT: 
405c				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
405c 48				db WORD_SYS_CORE+52             
405d 0f 41			dw .FIND            
405f 07				db 6 + 1 
4060 .. 00			db "CONCAT",0              
4067				endm 
# End of macro CWHEAD
4067			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4067			 
4067			; TODO check string type 
4067			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4067			 
4067					if DEBUG_FORTH_WORDS_KEY 
4067						DMARK "CON" 
4067 f5				push af  
4068 3a 7c 40			ld a, (.dmark)  
406b 32 7a ee			ld (debug_mark),a  
406e 3a 7d 40			ld a, (.dmark+1)  
4071 32 7b ee			ld (debug_mark+1),a  
4074 3a 7e 40			ld a, (.dmark+2)  
4077 32 7c ee			ld (debug_mark+2),a  
407a 18 03			jr .pastdmark  
407c ..			.dmark: db "CON"  
407f f1			.pastdmark: pop af  
4080			endm  
# End of macro DMARK
4080						CALLMONITOR 
4080 cd 77 14			call break_point_state  
4083				endm  
# End of macro CALLMONITOR
4083					endif 
4083			 
4083			 
4083					FORTH_DSP_VALUE 
4083 cd e4 1b			call macro_forth_dsp_value 
4086				endm 
# End of macro FORTH_DSP_VALUE
4086 e5					push hl   ; s2 
4087			 
4087					FORTH_DSP_POP 
4087 cd b3 1c			call macro_forth_dsp_pop 
408a				endm 
# End of macro FORTH_DSP_POP
408a			 
408a					FORTH_DSP_VALUE 
408a cd e4 1b			call macro_forth_dsp_value 
408d				endm 
# End of macro FORTH_DSP_VALUE
408d			 
408d e5					push hl   ; s1 
408e			 
408e					FORTH_DSP_POP 
408e cd b3 1c			call macro_forth_dsp_pop 
4091				endm 
# End of macro FORTH_DSP_POP
4091					 
4091			 
4091					; copy s1 
4091			 
4091				 
4091					; save ptr 
4091 e1					pop hl  
4092 e5					push hl 
4093 3e 00				ld a, 0 
4095 cd 32 10				call strlent 
4098					;inc hl    ; zer0 
4098 06 00				ld b, 0 
409a 4d					ld c, l 
409b e1					pop hl		 
409c 11 60 e3				ld de, scratch	 
409f					if DEBUG_FORTH_WORDS 
409f						DMARK "CO1" 
409f f5				push af  
40a0 3a b4 40			ld a, (.dmark)  
40a3 32 7a ee			ld (debug_mark),a  
40a6 3a b5 40			ld a, (.dmark+1)  
40a9 32 7b ee			ld (debug_mark+1),a  
40ac 3a b6 40			ld a, (.dmark+2)  
40af 32 7c ee			ld (debug_mark+2),a  
40b2 18 03			jr .pastdmark  
40b4 ..			.dmark: db "CO1"  
40b7 f1			.pastdmark: pop af  
40b8			endm  
# End of macro DMARK
40b8						CALLMONITOR 
40b8 cd 77 14			call break_point_state  
40bb				endm  
# End of macro CALLMONITOR
40bb					endif 
40bb ed b0				ldir 
40bd			 
40bd e1					pop hl 
40be e5					push hl 
40bf d5					push de 
40c0			 
40c0			 
40c0 3e 00				ld a, 0 
40c2 cd 32 10				call strlent 
40c5 23					inc hl    ; zer0 
40c6 23					inc hl 
40c7 06 00				ld b, 0 
40c9 4d					ld c, l 
40ca d1					pop de 
40cb e1					pop hl		 
40cc					if DEBUG_FORTH_WORDS 
40cc						DMARK "CO2" 
40cc f5				push af  
40cd 3a e1 40			ld a, (.dmark)  
40d0 32 7a ee			ld (debug_mark),a  
40d3 3a e2 40			ld a, (.dmark+1)  
40d6 32 7b ee			ld (debug_mark+1),a  
40d9 3a e3 40			ld a, (.dmark+2)  
40dc 32 7c ee			ld (debug_mark+2),a  
40df 18 03			jr .pastdmark  
40e1 ..			.dmark: db "CO2"  
40e4 f1			.pastdmark: pop af  
40e5			endm  
# End of macro DMARK
40e5						CALLMONITOR 
40e5 cd 77 14			call break_point_state  
40e8				endm  
# End of macro CALLMONITOR
40e8					endif 
40e8 ed b0				ldir 
40ea			 
40ea			 
40ea			 
40ea 21 60 e3				ld hl, scratch 
40ed					if DEBUG_FORTH_WORDS 
40ed						DMARK "CO5" 
40ed f5				push af  
40ee 3a 02 41			ld a, (.dmark)  
40f1 32 7a ee			ld (debug_mark),a  
40f4 3a 03 41			ld a, (.dmark+1)  
40f7 32 7b ee			ld (debug_mark+1),a  
40fa 3a 04 41			ld a, (.dmark+2)  
40fd 32 7c ee			ld (debug_mark+2),a  
4100 18 03			jr .pastdmark  
4102 ..			.dmark: db "CO5"  
4105 f1			.pastdmark: pop af  
4106			endm  
# End of macro DMARK
4106						CALLMONITOR 
4106 cd 77 14			call break_point_state  
4109				endm  
# End of macro CALLMONITOR
4109					endif 
4109			 
4109 cd 72 1a				call forth_push_str 
410c			 
410c			 
410c			 
410c			 
410c				       NEXTW 
410c c3 6d 1d			jp macro_next 
410f				endm 
# End of macro NEXTW
410f			 
410f			 
410f			.FIND: 
410f				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
410f 4b				db WORD_SYS_CORE+55             
4110 cd 41			dw .LEN            
4112 05				db 4 + 1 
4113 .. 00			db "FIND",0              
4118				endm 
# End of macro CWHEAD
4118			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4118			 
4118					if DEBUG_FORTH_WORDS_KEY 
4118						DMARK "FND" 
4118 f5				push af  
4119 3a 2d 41			ld a, (.dmark)  
411c 32 7a ee			ld (debug_mark),a  
411f 3a 2e 41			ld a, (.dmark+1)  
4122 32 7b ee			ld (debug_mark+1),a  
4125 3a 2f 41			ld a, (.dmark+2)  
4128 32 7c ee			ld (debug_mark+2),a  
412b 18 03			jr .pastdmark  
412d ..			.dmark: db "FND"  
4130 f1			.pastdmark: pop af  
4131			endm  
# End of macro DMARK
4131						CALLMONITOR 
4131 cd 77 14			call break_point_state  
4134				endm  
# End of macro CALLMONITOR
4134					endif 
4134			 
4134			; TODO check string type 
4134					FORTH_DSP_VALUE 
4134 cd e4 1b			call macro_forth_dsp_value 
4137				endm 
# End of macro FORTH_DSP_VALUE
4137			 
4137 e5					push hl    
4138 7e					ld a,(hl)    ; char to find   
4139			; TODO change char to substr 
4139			 
4139 f5					push af 
413a					 
413a			 
413a			 
413a					if DEBUG_FORTH_WORDS 
413a						DMARK "FN1" 
413a f5				push af  
413b 3a 4f 41			ld a, (.dmark)  
413e 32 7a ee			ld (debug_mark),a  
4141 3a 50 41			ld a, (.dmark+1)  
4144 32 7b ee			ld (debug_mark+1),a  
4147 3a 51 41			ld a, (.dmark+2)  
414a 32 7c ee			ld (debug_mark+2),a  
414d 18 03			jr .pastdmark  
414f ..			.dmark: db "FN1"  
4152 f1			.pastdmark: pop af  
4153			endm  
# End of macro DMARK
4153						CALLMONITOR 
4153 cd 77 14			call break_point_state  
4156				endm  
# End of macro CALLMONITOR
4156					endif 
4156			 
4156					FORTH_DSP_POP 
4156 cd b3 1c			call macro_forth_dsp_pop 
4159				endm 
# End of macro FORTH_DSP_POP
4159			 
4159					; string to search 
4159			 
4159					FORTH_DSP_VALUE 
4159 cd e4 1b			call macro_forth_dsp_value 
415c				endm 
# End of macro FORTH_DSP_VALUE
415c			 
415c d1					pop de  ; d is char to find  
415d			 
415d					if DEBUG_FORTH_WORDS 
415d						DMARK "FN2" 
415d f5				push af  
415e 3a 72 41			ld a, (.dmark)  
4161 32 7a ee			ld (debug_mark),a  
4164 3a 73 41			ld a, (.dmark+1)  
4167 32 7b ee			ld (debug_mark+1),a  
416a 3a 74 41			ld a, (.dmark+2)  
416d 32 7c ee			ld (debug_mark+2),a  
4170 18 03			jr .pastdmark  
4172 ..			.dmark: db "FN2"  
4175 f1			.pastdmark: pop af  
4176			endm  
# End of macro DMARK
4176						CALLMONITOR 
4176 cd 77 14			call break_point_state  
4179				endm  
# End of macro CALLMONITOR
4179					endif 
4179					 
4179 01 00 00				ld bc, 0 
417c 7e			.findchar:      ld a,(hl) 
417d fe 00				cp 0   		 
417f 28 27				jr z, .finddone     
4181 ba					cp d 
4182 28 20				jr z, .foundchar 
4184 03					inc bc 
4185 23					inc hl 
4186					if DEBUG_FORTH_WORDS 
4186						DMARK "FN3" 
4186 f5				push af  
4187 3a 9b 41			ld a, (.dmark)  
418a 32 7a ee			ld (debug_mark),a  
418d 3a 9c 41			ld a, (.dmark+1)  
4190 32 7b ee			ld (debug_mark+1),a  
4193 3a 9d 41			ld a, (.dmark+2)  
4196 32 7c ee			ld (debug_mark+2),a  
4199 18 03			jr .pastdmark  
419b ..			.dmark: db "FN3"  
419e f1			.pastdmark: pop af  
419f			endm  
# End of macro DMARK
419f						CALLMONITOR 
419f cd 77 14			call break_point_state  
41a2				endm  
# End of macro CALLMONITOR
41a2					endif 
41a2 18 d8				jr .findchar 
41a4			 
41a4			 
41a4 c5			.foundchar:	push bc 
41a5 e1					pop hl 
41a6 18 03				jr .findexit 
41a8			 
41a8			 
41a8							 
41a8			 
41a8			.finddone:     ; got to end of string with no find 
41a8 21 00 00				ld hl, 0 
41ab			.findexit: 
41ab			 
41ab					if DEBUG_FORTH_WORDS 
41ab						DMARK "FNd" 
41ab f5				push af  
41ac 3a c0 41			ld a, (.dmark)  
41af 32 7a ee			ld (debug_mark),a  
41b2 3a c1 41			ld a, (.dmark+1)  
41b5 32 7b ee			ld (debug_mark+1),a  
41b8 3a c2 41			ld a, (.dmark+2)  
41bb 32 7c ee			ld (debug_mark+2),a  
41be 18 03			jr .pastdmark  
41c0 ..			.dmark: db "FNd"  
41c3 f1			.pastdmark: pop af  
41c4			endm  
# End of macro DMARK
41c4						CALLMONITOR 
41c4 cd 77 14			call break_point_state  
41c7				endm  
# End of macro CALLMONITOR
41c7					endif 
41c7 cd 04 1a			call forth_push_numhl 
41ca			 
41ca				       NEXTW 
41ca c3 6d 1d			jp macro_next 
41cd				endm 
# End of macro NEXTW
41cd			 
41cd			.LEN: 
41cd				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
41cd 4c				db WORD_SYS_CORE+56             
41ce 02 42			dw .CHAR            
41d0 06				db 5 + 1 
41d1 .. 00			db "COUNT",0              
41d7				endm 
# End of macro CWHEAD
41d7			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
41d7			 
41d7					if DEBUG_FORTH_WORDS_KEY 
41d7						DMARK "CNT" 
41d7 f5				push af  
41d8 3a ec 41			ld a, (.dmark)  
41db 32 7a ee			ld (debug_mark),a  
41de 3a ed 41			ld a, (.dmark+1)  
41e1 32 7b ee			ld (debug_mark+1),a  
41e4 3a ee 41			ld a, (.dmark+2)  
41e7 32 7c ee			ld (debug_mark+2),a  
41ea 18 03			jr .pastdmark  
41ec ..			.dmark: db "CNT"  
41ef f1			.pastdmark: pop af  
41f0			endm  
# End of macro DMARK
41f0						CALLMONITOR 
41f0 cd 77 14			call break_point_state  
41f3				endm  
# End of macro CALLMONITOR
41f3					endif 
41f3			; TODO check string type 
41f3					FORTH_DSP 
41f3 cd c1 1b			call macro_forth_dsp 
41f6				endm 
# End of macro FORTH_DSP
41f6					;v5FORTH_DSP_VALUE 
41f6			 
41f6 23					inc hl 
41f7			 
41f7 3e 00				ld a, 0 
41f9 cd 32 10				call strlent 
41fc			 
41fc cd 04 1a				call forth_push_numhl 
41ff			 
41ff			 
41ff			 
41ff				       NEXTW 
41ff c3 6d 1d			jp macro_next 
4202				endm 
# End of macro NEXTW
4202			.CHAR: 
4202				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4202 4d				db WORD_SYS_CORE+57             
4203 38 42			dw .ENDSTR            
4205 05				db 4 + 1 
4206 .. 00			db "CHAR",0              
420b				endm 
# End of macro CWHEAD
420b			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
420b					if DEBUG_FORTH_WORDS_KEY 
420b						DMARK "CHR" 
420b f5				push af  
420c 3a 20 42			ld a, (.dmark)  
420f 32 7a ee			ld (debug_mark),a  
4212 3a 21 42			ld a, (.dmark+1)  
4215 32 7b ee			ld (debug_mark+1),a  
4218 3a 22 42			ld a, (.dmark+2)  
421b 32 7c ee			ld (debug_mark+2),a  
421e 18 03			jr .pastdmark  
4220 ..			.dmark: db "CHR"  
4223 f1			.pastdmark: pop af  
4224			endm  
# End of macro DMARK
4224						CALLMONITOR 
4224 cd 77 14			call break_point_state  
4227				endm  
# End of macro CALLMONITOR
4227					endif 
4227					FORTH_DSP 
4227 cd c1 1b			call macro_forth_dsp 
422a				endm 
# End of macro FORTH_DSP
422a					;v5 FORTH_DSP_VALUE 
422a 23					inc hl      ; now at start of numeric as string 
422b			 
422b			;		push hl 
422b			 
422b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
422b cd b3 1c			call macro_forth_dsp_pop 
422e				endm 
# End of macro FORTH_DSP_POP
422e			 
422e			;		pop hl 
422e			 
422e					; push the content of a onto the stack as a value 
422e			 
422e 7e					ld a,(hl)   ; get char 
422f 26 00				ld h,0 
4231 6f					ld l,a 
4232 cd 04 1a				call forth_push_numhl 
4235			 
4235				       NEXTW 
4235 c3 6d 1d			jp macro_next 
4238				endm 
# End of macro NEXTW
4238			 
4238			 
4238			 
4238			 
4238			.ENDSTR: 
4238			; eof 
4238			 
# End of file forth_words_str.asm
4238			include "forth_words_key.asm" 
4238			 
4238			; | ## Keyboard Words 
4238			 
4238			.KEY: 
4238				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4238 3e				db WORD_SYS_CORE+42             
4239 68 42			dw .WAITK            
423b 04				db 3 + 1 
423c .. 00			db "KEY",0              
4240				endm 
# End of macro CWHEAD
4240			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4240			 
4240					if DEBUG_FORTH_WORDS_KEY 
4240						DMARK "KEY" 
4240 f5				push af  
4241 3a 55 42			ld a, (.dmark)  
4244 32 7a ee			ld (debug_mark),a  
4247 3a 56 42			ld a, (.dmark+1)  
424a 32 7b ee			ld (debug_mark+1),a  
424d 3a 57 42			ld a, (.dmark+2)  
4250 32 7c ee			ld (debug_mark+2),a  
4253 18 03			jr .pastdmark  
4255 ..			.dmark: db "KEY"  
4258 f1			.pastdmark: pop af  
4259			endm  
# End of macro DMARK
4259						CALLMONITOR 
4259 cd 77 14			call break_point_state  
425c				endm  
# End of macro CALLMONITOR
425c					endif 
425c			; TODO currently waits 
425c cd 29 59				call cin 
425f					;call cin_wait 
425f 6f					ld l, a 
4260 26 00				ld h, 0 
4262 cd 04 1a				call forth_push_numhl 
4265					NEXTW 
4265 c3 6d 1d			jp macro_next 
4268				endm 
# End of macro NEXTW
4268			.WAITK: 
4268				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4268 3f				db WORD_SYS_CORE+43             
4269 9a 42			dw .ACCEPT            
426b 06				db 5 + 1 
426c .. 00			db "WAITK",0              
4272				endm 
# End of macro CWHEAD
4272			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4272					if DEBUG_FORTH_WORDS_KEY 
4272						DMARK "WAI" 
4272 f5				push af  
4273 3a 87 42			ld a, (.dmark)  
4276 32 7a ee			ld (debug_mark),a  
4279 3a 88 42			ld a, (.dmark+1)  
427c 32 7b ee			ld (debug_mark+1),a  
427f 3a 89 42			ld a, (.dmark+2)  
4282 32 7c ee			ld (debug_mark+2),a  
4285 18 03			jr .pastdmark  
4287 ..			.dmark: db "WAI"  
428a f1			.pastdmark: pop af  
428b			endm  
# End of macro DMARK
428b						CALLMONITOR 
428b cd 77 14			call break_point_state  
428e				endm  
# End of macro CALLMONITOR
428e					endif 
428e cd 21 59				call cin_wait 
4291 6f					ld l, a 
4292 26 00				ld h, 0 
4294 cd 04 1a				call forth_push_numhl 
4297					NEXTW 
4297 c3 6d 1d			jp macro_next 
429a				endm 
# End of macro NEXTW
429a			.ACCEPT: 
429a				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
429a 40				db WORD_SYS_CORE+44             
429b f8 42			dw .EDIT            
429d 07				db 6 + 1 
429e .. 00			db "ACCEPT",0              
42a5				endm 
# End of macro CWHEAD
42a5			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
42a5					; TODO crashes on push 
42a5					if DEBUG_FORTH_WORDS_KEY 
42a5						DMARK "ACC" 
42a5 f5				push af  
42a6 3a ba 42			ld a, (.dmark)  
42a9 32 7a ee			ld (debug_mark),a  
42ac 3a bb 42			ld a, (.dmark+1)  
42af 32 7b ee			ld (debug_mark+1),a  
42b2 3a bc 42			ld a, (.dmark+2)  
42b5 32 7c ee			ld (debug_mark+2),a  
42b8 18 03			jr .pastdmark  
42ba ..			.dmark: db "ACC"  
42bd f1			.pastdmark: pop af  
42be			endm  
# End of macro DMARK
42be						CALLMONITOR 
42be cd 77 14			call break_point_state  
42c1				endm  
# End of macro CALLMONITOR
42c1					endif 
42c1 21 5e e5				ld hl, os_input 
42c4 3e 00				ld a, 0 
42c6 77					ld (hl),a 
42c7 3a 49 eb				ld a,(f_cursor_ptr) 
42ca 16 64				ld d, 100 
42cc 0e 00				ld c, 0 
42ce 1e 28				ld e, 40 
42d0 cd f6 0b				call input_str 
42d3					; TODO perhaps do a type check and wrap in quotes if not a number 
42d3 21 5e e5				ld hl, os_input 
42d6					if DEBUG_FORTH_WORDS 
42d6						DMARK "AC1" 
42d6 f5				push af  
42d7 3a eb 42			ld a, (.dmark)  
42da 32 7a ee			ld (debug_mark),a  
42dd 3a ec 42			ld a, (.dmark+1)  
42e0 32 7b ee			ld (debug_mark+1),a  
42e3 3a ed 42			ld a, (.dmark+2)  
42e6 32 7c ee			ld (debug_mark+2),a  
42e9 18 03			jr .pastdmark  
42eb ..			.dmark: db "AC1"  
42ee f1			.pastdmark: pop af  
42ef			endm  
# End of macro DMARK
42ef						CALLMONITOR 
42ef cd 77 14			call break_point_state  
42f2				endm  
# End of macro CALLMONITOR
42f2					endif 
42f2 cd 72 1a				call forth_push_str 
42f5					NEXTW 
42f5 c3 6d 1d			jp macro_next 
42f8				endm 
# End of macro NEXTW
42f8			 
42f8			.EDIT: 
42f8				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
42f8 40				db WORD_SYS_CORE+44             
42f9 9a 43			dw .ENDKEY            
42fb 05				db 4 + 1 
42fc .. 00			db "EDIT",0              
4301				endm 
# End of macro CWHEAD
4301			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4301			 
4301					; TODO does not copy from stack 
4301					if DEBUG_FORTH_WORDS_KEY 
4301						DMARK "EDT" 
4301 f5				push af  
4302 3a 16 43			ld a, (.dmark)  
4305 32 7a ee			ld (debug_mark),a  
4308 3a 17 43			ld a, (.dmark+1)  
430b 32 7b ee			ld (debug_mark+1),a  
430e 3a 18 43			ld a, (.dmark+2)  
4311 32 7c ee			ld (debug_mark+2),a  
4314 18 03			jr .pastdmark  
4316 ..			.dmark: db "EDT"  
4319 f1			.pastdmark: pop af  
431a			endm  
# End of macro DMARK
431a						CALLMONITOR 
431a cd 77 14			call break_point_state  
431d				endm  
# End of macro CALLMONITOR
431d					endif 
431d			 
431d					;FORTH_DSP 
431d					FORTH_DSP_VALUEHL 
431d cd fb 1b			call macro_dsp_valuehl 
4320				endm 
# End of macro FORTH_DSP_VALUEHL
4320			;		inc hl    ; TODO do type check 
4320			 
4320			;		call get_word_hl 
4320 e5					push hl 
4321					if DEBUG_FORTH_WORDS 
4321						DMARK "EDp" 
4321 f5				push af  
4322 3a 36 43			ld a, (.dmark)  
4325 32 7a ee			ld (debug_mark),a  
4328 3a 37 43			ld a, (.dmark+1)  
432b 32 7b ee			ld (debug_mark+1),a  
432e 3a 38 43			ld a, (.dmark+2)  
4331 32 7c ee			ld (debug_mark+2),a  
4334 18 03			jr .pastdmark  
4336 ..			.dmark: db "EDp"  
4339 f1			.pastdmark: pop af  
433a			endm  
# End of macro DMARK
433a						CALLMONITOR 
433a cd 77 14			call break_point_state  
433d				endm  
# End of macro CALLMONITOR
433d					endif 
433d				;	ld a, 0 
433d cd 27 10				call strlenz 
4340 23					inc hl 
4341			 
4341 06 00				ld b, 0 
4343 4d					ld c, l 
4344			 
4344 e1					pop hl 
4345 11 5e e5				ld de, os_input 
4348					if DEBUG_FORTH_WORDS_KEY 
4348						DMARK "EDc" 
4348 f5				push af  
4349 3a 5d 43			ld a, (.dmark)  
434c 32 7a ee			ld (debug_mark),a  
434f 3a 5e 43			ld a, (.dmark+1)  
4352 32 7b ee			ld (debug_mark+1),a  
4355 3a 5f 43			ld a, (.dmark+2)  
4358 32 7c ee			ld (debug_mark+2),a  
435b 18 03			jr .pastdmark  
435d ..			.dmark: db "EDc"  
4360 f1			.pastdmark: pop af  
4361			endm  
# End of macro DMARK
4361						CALLMONITOR 
4361 cd 77 14			call break_point_state  
4364				endm  
# End of macro CALLMONITOR
4364					endif 
4364 ed b0				ldir 
4366			 
4366			 
4366 21 5e e5				ld hl, os_input 
4369					;ld a, 0 
4369					;ld (hl),a 
4369 3a 49 eb				ld a,(f_cursor_ptr) 
436c 16 64				ld d, 100 
436e 0e 00				ld c, 0 
4370 1e 28				ld e, 40 
4372 cd f6 0b				call input_str 
4375					; TODO perhaps do a type check and wrap in quotes if not a number 
4375 21 5e e5				ld hl, os_input 
4378					if DEBUG_FORTH_WORDS 
4378						DMARK "ED1" 
4378 f5				push af  
4379 3a 8d 43			ld a, (.dmark)  
437c 32 7a ee			ld (debug_mark),a  
437f 3a 8e 43			ld a, (.dmark+1)  
4382 32 7b ee			ld (debug_mark+1),a  
4385 3a 8f 43			ld a, (.dmark+2)  
4388 32 7c ee			ld (debug_mark+2),a  
438b 18 03			jr .pastdmark  
438d ..			.dmark: db "ED1"  
4390 f1			.pastdmark: pop af  
4391			endm  
# End of macro DMARK
4391						CALLMONITOR 
4391 cd 77 14			call break_point_state  
4394				endm  
# End of macro CALLMONITOR
4394					endif 
4394 cd 72 1a				call forth_push_str 
4397					NEXTW 
4397 c3 6d 1d			jp macro_next 
439a				endm 
# End of macro NEXTW
439a			 
439a			 
439a			 
439a			.ENDKEY: 
439a			; eof 
439a			 
# End of file forth_words_key.asm
439a			 
439a			if STORAGE_SE 
439a			   	include "forth_words_storage.asm" 
439a			endif 
439a				include "forth_words_device.asm" 
439a			; Device related words 
439a			 
439a			; | ## Device Words 
439a			 
439a			if SOUND_ENABLE 
439a			.NOTE: 
439a				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
439a			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
439a					if DEBUG_FORTH_WORDS_KEY 
439a						DMARK "NTE" 
439a						CALLMONITOR 
439a					endif 
439a			 
439a				 
439a			 
439a					NEXTW 
439a			.AFTERSOUND: 
439a			endif 
439a			 
439a			 
439a			USE_GPIO: equ 0 
439a			 
439a			if USE_GPIO 
439a			.GP1: 
439a				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
439a			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
439a					NEXTW 
439a			.GP2: 
439a				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
439a			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
439a			 
439a					NEXTW 
439a			 
439a			.GP3: 
439a				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
439a			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
439a			 
439a					NEXTW 
439a			 
439a			.GP4: 
439a				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
439a			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
439a			 
439a					NEXTW 
439a			.SIN: 
439a			 
439a			 
439a			endif 
439a			 
439a			 
439a				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
439a 33				db WORD_SYS_CORE+31             
439b cf 43			dw .SOUT            
439d 03				db 2 + 1 
439e .. 00			db "IN",0              
43a1				endm 
# End of macro CWHEAD
43a1			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
43a1					if DEBUG_FORTH_WORDS_KEY 
43a1						DMARK "IN." 
43a1 f5				push af  
43a2 3a b6 43			ld a, (.dmark)  
43a5 32 7a ee			ld (debug_mark),a  
43a8 3a b7 43			ld a, (.dmark+1)  
43ab 32 7b ee			ld (debug_mark+1),a  
43ae 3a b8 43			ld a, (.dmark+2)  
43b1 32 7c ee			ld (debug_mark+2),a  
43b4 18 03			jr .pastdmark  
43b6 ..			.dmark: db "IN."  
43b9 f1			.pastdmark: pop af  
43ba			endm  
# End of macro DMARK
43ba						CALLMONITOR 
43ba cd 77 14			call break_point_state  
43bd				endm  
# End of macro CALLMONITOR
43bd					endif 
43bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43bd cd fb 1b			call macro_dsp_valuehl 
43c0				endm 
# End of macro FORTH_DSP_VALUEHL
43c0			 
43c0 e5					push hl 
43c1			 
43c1					; destroy value TOS 
43c1			 
43c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43c1 cd b3 1c			call macro_forth_dsp_pop 
43c4				endm 
# End of macro FORTH_DSP_POP
43c4			 
43c4					; one value on hl get other one back 
43c4			 
43c4 c1					pop bc 
43c5			 
43c5					; do the sub 
43c5			;		ex de, hl 
43c5			 
43c5 ed 68				in l,(c) 
43c7			 
43c7					; save it 
43c7			 
43c7 26 00				ld h,0 
43c9			 
43c9					; TODO push value back onto stack for another op etc 
43c9			 
43c9 cd 04 1a				call forth_push_numhl 
43cc					NEXTW 
43cc c3 6d 1d			jp macro_next 
43cf				endm 
# End of macro NEXTW
43cf			.SOUT: 
43cf				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
43cf 34				db WORD_SYS_CORE+32             
43d0 22 44			dw .SPIO            
43d2 04				db 3 + 1 
43d3 .. 00			db "OUT",0              
43d7				endm 
# End of macro CWHEAD
43d7			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
43d7					if DEBUG_FORTH_WORDS_KEY 
43d7						DMARK "OUT" 
43d7 f5				push af  
43d8 3a ec 43			ld a, (.dmark)  
43db 32 7a ee			ld (debug_mark),a  
43de 3a ed 43			ld a, (.dmark+1)  
43e1 32 7b ee			ld (debug_mark+1),a  
43e4 3a ee 43			ld a, (.dmark+2)  
43e7 32 7c ee			ld (debug_mark+2),a  
43ea 18 03			jr .pastdmark  
43ec ..			.dmark: db "OUT"  
43ef f1			.pastdmark: pop af  
43f0			endm  
# End of macro DMARK
43f0						CALLMONITOR 
43f0 cd 77 14			call break_point_state  
43f3				endm  
# End of macro CALLMONITOR
43f3					endif 
43f3			 
43f3					; get port 
43f3			 
43f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43f3 cd fb 1b			call macro_dsp_valuehl 
43f6				endm 
# End of macro FORTH_DSP_VALUEHL
43f6			 
43f6 e5					push hl 
43f7			 
43f7					; destroy value TOS 
43f7			 
43f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43f7 cd b3 1c			call macro_forth_dsp_pop 
43fa				endm 
# End of macro FORTH_DSP_POP
43fa			 
43fa					; get byte to send 
43fa			 
43fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43fa cd fb 1b			call macro_dsp_valuehl 
43fd				endm 
# End of macro FORTH_DSP_VALUEHL
43fd			 
43fd			;		push hl 
43fd			 
43fd					; destroy value TOS 
43fd			 
43fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43fd cd b3 1c			call macro_forth_dsp_pop 
4400				endm 
# End of macro FORTH_DSP_POP
4400			 
4400					; one value on hl get other one back 
4400			 
4400			;		pop hl 
4400			 
4400 c1					pop bc 
4401			 
4401					if DEBUG_FORTH_WORDS 
4401						DMARK "OUT" 
4401 f5				push af  
4402 3a 16 44			ld a, (.dmark)  
4405 32 7a ee			ld (debug_mark),a  
4408 3a 17 44			ld a, (.dmark+1)  
440b 32 7b ee			ld (debug_mark+1),a  
440e 3a 18 44			ld a, (.dmark+2)  
4411 32 7c ee			ld (debug_mark+2),a  
4414 18 03			jr .pastdmark  
4416 ..			.dmark: db "OUT"  
4419 f1			.pastdmark: pop af  
441a			endm  
# End of macro DMARK
441a						CALLMONITOR 
441a cd 77 14			call break_point_state  
441d				endm  
# End of macro CALLMONITOR
441d					endif 
441d			 
441d ed 69				out (c), l 
441f			 
441f					NEXTW 
441f c3 6d 1d			jp macro_next 
4422				endm 
# End of macro NEXTW
4422			 
4422			 
4422			.SPIO: 
4422			 
4422			if STORAGE_SE 
4422				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4422			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4422			 
4422					call spi_ce_low 
4422			    NEXTW 
4422			 
4422			.SPICEH: 
4422				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4422			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4422			 
4422					call spi_ce_high 
4422			    NEXTW 
4422			 
4422			 
4422			.SPIOb: 
4422			 
4422				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4422			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4422			 
4422					; get port 
4422			 
4422			 
4422					; get byte to send 
4422			 
4422					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4422			 
4422			;		push hl    ; u1  
4422			 
4422					; destroy value TOS 
4422			 
4422					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4422			 
4422					; one value on hl get other one back 
4422			 
4422			;		pop hl   ; u2 - addr 
4422			 
4422					; TODO Send SPI byte 
4422			 
4422					ld a, l 
4422					call spi_send_byte 
4422			 
4422					NEXTW 
4422			 
4422			.SPII: 
4422				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4422			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4422			 
4422					; TODO Get SPI byte 
4422			 
4422					call spi_read_byte 
4422			 
4422					ld h, 0 
4422					ld l, a 
4422					call forth_push_numhl 
4422			 
4422					NEXTW 
4422			 
4422			 
4422			 
4422			.SESEL: 
4422				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4422			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4422					if DEBUG_FORTH_WORDS_KEY 
4422						DMARK "BNK" 
4422						CALLMONITOR 
4422					endif 
4422			 
4422					ld a, 255 
4422					ld (spi_cartdev), a 
4422			 
4422					; get bank 
4422			 
4422					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4422			 
4422			;		push hl 
4422			 
4422					; destroy value TOS 
4422			 
4422					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4422			 
4422					; one value on hl get other one back 
4422			 
4422			;		pop hl 
4422			 
4422			 
4422					ld c, SPI_CE_HIGH 
4422					ld b, '0'    ; human readable bank number 
4422			 
4422					ld a, l 
4422			 
4422					if DEBUG_FORTH_WORDS 
4422						DMARK "BNK" 
4422						CALLMONITOR 
4422					endif 
4422			 
4422					; active low 
4422			 
4422					cp 0 
4422					jr z, .bset 
4422					cp 1 
4422					jr nz, .b2 
4422					res 0, c 
4422					ld b, '1'    ; human readable bank number 
4422			.b2:		cp 2 
4422					jr nz, .b3 
4422					res 1, c 
4422					ld b, '2'    ; human readable bank number 
4422			.b3:		cp 3 
4422					jr nz, .b4 
4422					res 2, c 
4422					ld b, '3'    ; human readable bank number 
4422			.b4:		cp 4 
4422					jr nz, .b5 
4422					res 3, c 
4422					ld b, '4'    ; human readable bank number 
4422			.b5:		cp 5 
4422					jr nz, .bset 
4422					res 4, c 
4422					ld b, '5'    ; human readable bank number 
4422			 
4422			.bset: 
4422					ld a, c 
4422					ld (spi_device),a 
4422					ld a, b 
4422					ld (spi_device_id),a 
4422					if DEBUG_FORTH_WORDS 
4422						DMARK "BN2" 
4422						CALLMONITOR 
4422					endif 
4422			 
4422					NEXTW 
4422			 
4422			.CARTDEV: 
4422				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4422			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4422					if DEBUG_FORTH_WORDS_KEY 
4422						DMARK "CDV" 
4422						CALLMONITOR 
4422					endif 
4422			 
4422					; disable se storage bank selection 
4422			 
4422					ld a, SPI_CE_HIGH		; ce high 
4422					ld (spi_device), a 
4422			 
4422					; get bank 
4422			 
4422					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4422			 
4422			;		push hl 
4422			 
4422					; destroy value TOS 
4422			 
4422					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4422			 
4422					; one value on hl get other one back 
4422			 
4422			;		pop hl 
4422			 
4422					; active low 
4422			 
4422					ld c, 255 
4422			 
4422					ld a, l 
4422					if DEBUG_FORTH_WORDS 
4422						DMARK "CDV" 
4422						CALLMONITOR 
4422					endif 
4422					cp 0 
4422					jr z, .cset 
4422					cp 1 
4422					jr nz, .c2 
4422					res 0, c 
4422			.c2:		cp 2 
4422					jr nz, .c3 
4422					res 1, c 
4422			.c3:		cp 3 
4422					jr nz, .c4 
4422					res 2, c 
4422			.c4:		cp 4 
4422					jr nz, .c5 
4422					res 3, c 
4422			.c5:		cp 5 
4422					jr nz, .c6 
4422					res 4, c 
4422			.c6:		cp 6 
4422					jr nz, .c7 
4422					res 5, c 
4422			.c7:		cp 7 
4422					jr nz, .c8 
4422					res 6, c 
4422			.c8:		cp 8 
4422					jr nz, .cset 
4422					res 7, c 
4422			.cset:		ld a, c 
4422					ld (spi_cartdev),a 
4422			 
4422					if DEBUG_FORTH_WORDS 
4422						DMARK "CD2" 
4422						CALLMONITOR 
4422					endif 
4422					NEXTW 
4422			endif 
4422			 
4422			.ENDDEVICE: 
4422			; eof 
4422			 
# End of file forth_words_device.asm
4422			 
4422			; var handler 
4422			 
4422			 
4422			.VARS: 
4422				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4422 78				db WORD_SYS_CORE+100             
4423 3a 44			dw .V0Q            
4425 04				db 3 + 1 
4426 .. 00			db "V0!",0              
442a				endm 
# End of macro CWHEAD
442a			;| V0! ( u1 -- )  Store value to v0  | DONE 
442a			 
442a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
442a cd fb 1b			call macro_dsp_valuehl 
442d				endm 
# End of macro FORTH_DSP_VALUEHL
442d			 
442d 11 13 eb				ld de, cli_var_array 
4430			 
4430 eb					ex de, hl 
4431 73					ld (hl), e 
4432 23					inc hl 
4433 72					ld (hl), d 
4434			 
4434					; destroy value TOS 
4434			 
4434					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4434 cd b3 1c			call macro_forth_dsp_pop 
4437				endm 
# End of macro FORTH_DSP_POP
4437			 
4437				       NEXTW 
4437 c3 6d 1d			jp macro_next 
443a				endm 
# End of macro NEXTW
443a			.V0Q: 
443a				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
443a 79				db WORD_SYS_CORE+101             
443b 4b 44			dw .V1S            
443d 04				db 3 + 1 
443e .. 00			db "V0@",0              
4442				endm 
# End of macro CWHEAD
4442			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4442 2a 13 eb				ld hl, (cli_var_array) 
4445 cd 04 1a				call forth_push_numhl 
4448			 
4448				       NEXTW 
4448 c3 6d 1d			jp macro_next 
444b				endm 
# End of macro NEXTW
444b			.V1S: 
444b				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
444b 7a				db WORD_SYS_CORE+102             
444c 63 44			dw .V1Q            
444e 04				db 3 + 1 
444f .. 00			db "V1!",0              
4453				endm 
# End of macro CWHEAD
4453			;| V1! ( u1 -- )  Store value to v1 | DONE 
4453					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4453 cd fb 1b			call macro_dsp_valuehl 
4456				endm 
# End of macro FORTH_DSP_VALUEHL
4456			 
4456 11 15 eb				ld de, cli_var_array+2 
4459				 
4459 eb					ex de, hl 
445a 73					ld (hl), e 
445b 23					inc hl 
445c 72					ld (hl), d 
445d			 
445d					; destroy value TOS 
445d			 
445d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
445d cd b3 1c			call macro_forth_dsp_pop 
4460				endm 
# End of macro FORTH_DSP_POP
4460				       NEXTW 
4460 c3 6d 1d			jp macro_next 
4463				endm 
# End of macro NEXTW
4463			.V1Q: 
4463				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4463 7b				db WORD_SYS_CORE+103             
4464 74 44			dw .V2S            
4466 04				db 3 + 1 
4467 .. 00			db "V1@",0              
446b				endm 
# End of macro CWHEAD
446b			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
446b 2a 15 eb				ld hl, (cli_var_array+2) 
446e cd 04 1a				call forth_push_numhl 
4471				       NEXTW 
4471 c3 6d 1d			jp macro_next 
4474				endm 
# End of macro NEXTW
4474			.V2S: 
4474				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4474 7c				db WORD_SYS_CORE+104             
4475 8c 44			dw .V2Q            
4477 04				db 3 + 1 
4478 .. 00			db "V2!",0              
447c				endm 
# End of macro CWHEAD
447c			;| V2! ( u1 -- )  Store value to v2 | DONE 
447c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
447c cd fb 1b			call macro_dsp_valuehl 
447f				endm 
# End of macro FORTH_DSP_VALUEHL
447f			 
447f 11 17 eb				ld de, cli_var_array+4 
4482				 
4482 eb					ex de, hl 
4483 73					ld (hl), e 
4484 23					inc hl 
4485 72					ld (hl), d 
4486			 
4486					; destroy value TOS 
4486			 
4486					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4486 cd b3 1c			call macro_forth_dsp_pop 
4489				endm 
# End of macro FORTH_DSP_POP
4489				       NEXTW 
4489 c3 6d 1d			jp macro_next 
448c				endm 
# End of macro NEXTW
448c			.V2Q: 
448c				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
448c 7d				db WORD_SYS_CORE+105             
448d 9d 44			dw .V3S            
448f 04				db 3 + 1 
4490 .. 00			db "V2@",0              
4494				endm 
# End of macro CWHEAD
4494			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4494 2a 17 eb				ld hl, (cli_var_array+4) 
4497 cd 04 1a				call forth_push_numhl 
449a				       NEXTW 
449a c3 6d 1d			jp macro_next 
449d				endm 
# End of macro NEXTW
449d			.V3S: 
449d				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
449d 7c				db WORD_SYS_CORE+104             
449e b5 44			dw .V3Q            
44a0 04				db 3 + 1 
44a1 .. 00			db "V3!",0              
44a5				endm 
# End of macro CWHEAD
44a5			;| V3! ( u1 -- )  Store value to v3 | DONE 
44a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44a5 cd fb 1b			call macro_dsp_valuehl 
44a8				endm 
# End of macro FORTH_DSP_VALUEHL
44a8			 
44a8 11 19 eb				ld de, cli_var_array+6 
44ab				 
44ab eb					ex de, hl 
44ac 73					ld (hl), e 
44ad 23					inc hl 
44ae 72					ld (hl), d 
44af			 
44af					; destroy value TOS 
44af			 
44af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44af cd b3 1c			call macro_forth_dsp_pop 
44b2				endm 
# End of macro FORTH_DSP_POP
44b2				       NEXTW 
44b2 c3 6d 1d			jp macro_next 
44b5				endm 
# End of macro NEXTW
44b5			.V3Q: 
44b5				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
44b5 7d				db WORD_SYS_CORE+105             
44b6 c6 44			dw .END            
44b8 04				db 3 + 1 
44b9 .. 00			db "V3@",0              
44bd				endm 
# End of macro CWHEAD
44bd			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
44bd 2a 19 eb				ld hl, (cli_var_array+6) 
44c0 cd 04 1a				call forth_push_numhl 
44c3				       NEXTW 
44c3 c3 6d 1d			jp macro_next 
44c6				endm 
# End of macro NEXTW
44c6			 
44c6			 
44c6			 
44c6			 
44c6			 
44c6			; end of dict marker 
44c6			 
44c6 00			.END:    db WORD_SYS_END 
44c7 00 00			dw 0 
44c9 00				db 0 
44ca			 
44ca			; use to jp here for user dict words to save on macro expansion  
44ca			 
44ca			user_dict_next: 
44ca				NEXTW 
44ca c3 6d 1d			jp macro_next 
44cd				endm 
# End of macro NEXTW
44cd			 
44cd			 
44cd			user_exec: 
44cd				;    ld hl, <word code> 
44cd				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
44cd				;    call forthexec 
44cd				;    jp user_dict_next   (NEXT) 
44cd			        ;    <word code bytes> 
44cd eb				ex de, hl 
44ce 2a 61 e6			ld hl,(os_tok_ptr) 
44d1				 
44d1				FORTH_RSP_NEXT 
44d1 cd ab 19			call macro_forth_rsp_next 
44d4				endm 
# End of macro FORTH_RSP_NEXT
44d4			 
44d4			if DEBUG_FORTH_UWORD 
44d4						DMARK "UEX" 
44d4 f5				push af  
44d5 3a e9 44			ld a, (.dmark)  
44d8 32 7a ee			ld (debug_mark),a  
44db 3a ea 44			ld a, (.dmark+1)  
44de 32 7b ee			ld (debug_mark+1),a  
44e1 3a eb 44			ld a, (.dmark+2)  
44e4 32 7c ee			ld (debug_mark+2),a  
44e7 18 03			jr .pastdmark  
44e9 ..			.dmark: db "UEX"  
44ec f1			.pastdmark: pop af  
44ed			endm  
# End of macro DMARK
44ed				CALLMONITOR 
44ed cd 77 14			call break_point_state  
44f0				endm  
# End of macro CALLMONITOR
44f0			endif 
44f0			 
44f0			 
44f0			 
44f0 eb				ex de, hl 
44f1 22 61 e6			ld (os_tok_ptr), hl 
44f4				 
44f4				; Don't use next - Skips the first word in uword. 
44f4			 
44f4 c3 fe 1d			jp exec1 
44f7			;	NEXT 
44f7			 
44f7			 
44f7			; eof 
# End of file forth_wordsv4.asm
44f7			endif 
44f7			;;;;;;;;;;;;;; Debug code 
44f7			 
44f7			 
44f7			;if DEBUG_FORTH_PARSE 
44f7 .. 00		.nowordfound: db "No match",0 
4500 .. 00		.compword:	db "Comparing word ",0 
4510 .. 00		.nextwordat:	db "Next word at",0 
451d .. 00		.charmatch:	db "Char match",0 
4528			;endif 
4528			if DEBUG_FORTH_JP 
4528			.foundword:	db "Word match. Exec..",0 
4528			endif 
4528			;if DEBUG_FORTH_PUSH 
4528 .. 00		.enddict:	db "Dict end. Push.",0 
4538 .. 00		.push_str:	db "Pushing string",0 
4547 .. 00		.push_num:	db "Pushing number",0 
4556 .. 00		.data_sp:	db "SP:",0 
455a .. 00		.wordinhl:	db "Word in HL (2/0):",0 
456c .. 00		.wordinde:	db "Word in DE (3/0):",0 
457e .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4590			;endif 
4590			;if DEBUG_FORTH_MALLOC 
4590 .. 00		.push_malloc:	db "Malloc address",0 
459f			;endif 
459f			 
459f			 
459f			 
459f			; display malloc address and current data stack pointer  
459f			 
459f			malloc_error: 
459f d5				push de 
45a0 f5				push af 
45a1 e5				push hl 
45a2 cd 9c 09			call clear_display 
45a5 11 c7 45			ld de, .mallocerr 
45a8 3e 00			ld a,0 
45aa			;	ld de,os_word_scratch 
45aa cd af 09			call str_at_display 
45ad 3e 11			ld a, display_row_1+17 
45af 11 7a ee			ld de, debug_mark 
45b2 cd af 09			call str_at_display 
45b5 cd bf 09			call update_display 
45b8				;call break_point_state 
45b8 cd 21 59			call cin_wait 
45bb			 
45bb 3e 20			ld a, ' ' 
45bd 32 51 e3			ld (os_view_disable), a 
45c0 e1				pop hl 
45c1 f1				pop af 
45c2 d1				pop de	 
45c3				CALLMONITOR 
45c3 cd 77 14			call break_point_state  
45c6				endm  
# End of macro CALLMONITOR
45c6 c9				ret 
45c7			 
45c7 .. 00		.mallocerr: 	db "Malloc Error",0 
45d4			;if DEBUG_FORTH_PUSH 
45d4			display_data_sp: 
45d4 f5				push af 
45d5			 
45d5				; see if disabled 
45d5			 
45d5 3a 51 e3			ld a, (os_view_disable) 
45d8 fe 2a			cp '*' 
45da 28 67			jr z, .skipdsp 
45dc			 
45dc e5				push hl 
45dd e5				push hl 
45de e5			push hl 
45df cd 9c 09			call clear_display 
45e2 e1			pop hl 
45e3 7c				ld a,h 
45e4 21 65 e6			ld hl, os_word_scratch 
45e7 cd ca 0e			call hexout 
45ea e1				pop hl 
45eb 7d				ld a,l 
45ec 21 67 e6			ld hl, os_word_scratch+2 
45ef cd ca 0e			call hexout 
45f2 21 69 e6			ld hl, os_word_scratch+4 
45f5 3e 00			ld a,0 
45f7 77				ld (hl),a 
45f8 11 65 e6			ld de,os_word_scratch 
45fb 3e 28				ld a, display_row_2 
45fd cd af 09				call str_at_display 
4600 11 5a 45			ld de, .wordinhl 
4603 3e 00			ld a, display_row_1 
4605			 
4605 cd af 09				call str_at_display 
4608 11 7a ee			ld de, debug_mark 
460b 3e 11			ld a, display_row_1+17 
460d			 
460d cd af 09				call str_at_display 
4610			 
4610				; display current data stack pointer 
4610 11 56 45			ld de,.data_sp 
4613 3e 30				ld a, display_row_2 + 8 
4615 cd af 09				call str_at_display 
4618			 
4618 2a 0d eb			ld hl,(cli_data_sp) 
461b e5				push hl 
461c 7c				ld a,h 
461d 21 65 e6			ld hl, os_word_scratch 
4620 cd ca 0e			call hexout 
4623 e1				pop hl 
4624 7d				ld a,l 
4625 21 67 e6			ld hl, os_word_scratch+2 
4628 cd ca 0e			call hexout 
462b 21 69 e6			ld hl, os_word_scratch+4 
462e 3e 00			ld a,0 
4630 77				ld (hl),a 
4631 11 65 e6			ld de,os_word_scratch 
4634 3e 33				ld a, display_row_2 + 11 
4636 cd af 09				call str_at_display 
4639			 
4639			 
4639 cd bf 09			call update_display 
463c cd 0e 09			call delay1s 
463f cd 0e 09			call delay1s 
4642 e1				pop hl 
4643			.skipdsp: 
4643 f1				pop af 
4644 c9				ret 
4645			 
4645			display_data_malloc: 
4645			 
4645 f5				push af 
4646 e5				push hl 
4647 e5				push hl 
4648 e5			push hl 
4649 cd 9c 09			call clear_display 
464c e1			pop hl 
464d 7c				ld a,h 
464e 21 65 e6			ld hl, os_word_scratch 
4651 cd ca 0e			call hexout 
4654 e1				pop hl 
4655 7d				ld a,l 
4656 21 67 e6			ld hl, os_word_scratch+2 
4659 cd ca 0e			call hexout 
465c 21 69 e6			ld hl, os_word_scratch+4 
465f 3e 00			ld a,0 
4661 77				ld (hl),a 
4662 11 65 e6			ld de,os_word_scratch 
4665 3e 28				ld a, display_row_2 
4667 cd af 09				call str_at_display 
466a 11 90 45			ld de, .push_malloc 
466d 3e 00			ld a, display_row_1 
466f			 
466f cd af 09				call str_at_display 
4672			 
4672				; display current data stack pointer 
4672 11 56 45			ld de,.data_sp 
4675 3e 30				ld a, display_row_2 + 8 
4677 cd af 09				call str_at_display 
467a			 
467a 2a 0d eb			ld hl,(cli_data_sp) 
467d e5				push hl 
467e 7c				ld a,h 
467f 21 65 e6			ld hl, os_word_scratch 
4682 cd ca 0e			call hexout 
4685 e1				pop hl 
4686 7d				ld a,l 
4687 21 67 e6			ld hl, os_word_scratch+2 
468a cd ca 0e			call hexout 
468d 21 69 e6			ld hl, os_word_scratch+4 
4690 3e 00			ld a,0 
4692 77				ld (hl),a 
4693 11 65 e6			ld de,os_word_scratch 
4696 3e 33				ld a, display_row_2 + 11 
4698 cd af 09				call str_at_display 
469b			 
469b cd bf 09			call update_display 
469e cd 0e 09			call delay1s 
46a1 cd 0e 09			call delay1s 
46a4 e1				pop hl 
46a5 f1				pop af 
46a6 c9				ret 
46a7			;endif 
46a7			 
46a7			include "forth_autostart.asm" 
46a7			; list of commands to perform at system start up 
46a7			 
46a7			startcmds: 
46a7			;	dw test11 
46a7			;	dw test12 
46a7			;	dw test13 
46a7			;	dw test14 
46a7			;	dw test15 
46a7			;	dw test16 
46a7			;	dw test17 
46a7			;	dw ifthtest1 
46a7			;	dw ifthtest2 
46a7			;	dw ifthtest3 
46a7			;	dw mmtest1 
46a7			;	dw mmtest2 
46a7			;	dw mmtest3 
46a7			;	dw mmtest4 
46a7			;	dw mmtest5 
46a7			;	dw mmtest6 
46a7			;	dw iftest1 
46a7			;	dw iftest2 
46a7			;	dw iftest3 
46a7			;	dw looptest1 
46a7			;	dw looptest2 
46a7			;	dw test1 
46a7			;	dw test2 
46a7			;	dw test3 
46a7			;	dw test4 
46a7			;	dw game2r 
46a7			;	dw game2b1 
46a7			;	dw game2b2 
46a7			 
46a7				; start up words that are actually useful 
46a7			 
46a7 05 47			dw clrstack 
46a9 38 47			dw type 
46ab f9 48			dw stest 
46ad 5c 47			dw strncpy 
46af 9a 48			dw list 
46b1 bd 47			dw start1 
46b3 cf 47			dw start2 
46b5			;	dw start3 
46b5 e2 47			dw start3b 
46b7 3a 48			dw start3c 
46b9			 
46b9				; (unit) testing words 
46b9			 
46b9 70 49			dw mtesta 
46bb 25 4a			dw mtestb 
46bd c8 4a			dw mtestc 
46bf 7d 4b			dw mtestd 
46c1 21 4c			dw mteste 
46c3			 
46c3				; demo/game words 
46c3			 
46c3 2d 53		        dw game3w 
46c5 5b 53		        dw game3p 
46c7 79 53		        dw game3sc 
46c9 aa 53		        dw game3vsi 
46cb d6 53		        dw game3vs 
46cd				 
46cd 20 51			dw game2b 
46cf 8e 51			dw game2bf 
46d1 d8 51			dw game2mba 
46d3 6e 52			dw game2mbas 
46d5 b0 52			dw game2mb 
46d7			 
46d7 e1 4d			dw game1 
46d9 f2 4d			dw game1a 
46db 54 4e			dw game1b 
46dd 89 4e			dw game1c 
46df bf 4e			dw game1d 
46e1 f0 4e			dw game1s 
46e3 04 4f			dw game1t 
46e5 19 4f			dw game1f 
46e7 4d 4f			dw game1z 
46e9 91 4f			dw game1zz 
46eb			 
46eb d7 4c			dw test5 
46ed 0f 4d			dw test6 
46ef 47 4d			dw test7 
46f1 5b 4d			dw test8 
46f3 87 4d			dw test9 
46f5 9d 4d			dw test10 
46f7				 
46f7 68 50		        dw ssv5 
46f9 4c 50		        dw ssv4 
46fb 30 50		        dw ssv3 
46fd fa 4f		        dw ssv2 
46ff 81 50		        dw ssv1 
4701 c9 50		        dw ssv1cpm 
4703			;	dw keyup 
4703			;	dw keydown 
4703			;	dw keyleft 
4703			;	dw keyright 
4703			;	dw 	keyf1 
4703			;	dw keyf2 
4703			;	dw keyf3 
4703			;	dw keyf4 
4703			;	dw keyf5 
4703			;	dw keyf6 
4703			;	dw keyf7 
4703			;	dw keyf8 
4703			;	dw keyf9 
4703			;	dw keyf10 
4703			;	dw keyf11 
4703			;	dw keyf12 
4703			;	dw keytab 
4703			;	dw keycr 
4703			;	dw keyhome 
4703			;	dw keyend 
4703			;	dw keybs 
4703 00 00			db 0, 0	 
4705			 
4705			 
4705			; clear stack  
4705			 
4705 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
4738			 
4738			; type ( addr count - ) 
4738 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
475c			 
475c			; some direct memory words 
475c			; strncpy ( len t f -- t ) 
475c			 
475c .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
47bd			 
47bd .. 00		start1:     	db ": bpon $0000 bp ;",0 
47cf .. 00		start2:     	db ": bpoff $0001 bp ;",0 
47e2			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
47e2 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
483a .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
489a			 
489a			 
489a			; a handy word to list items on the stack 
489a			 
489a .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
48f9			 
48f9			 
48f9			; test stack  
48f9			; rnd8 stest 
48f9			 
48f9 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4970			 
4970			; random malloc and free cycles 
4970			 
4970 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4a25			 
4a25			; fixed malloc and free cycles 
4a25			 
4a25 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4ac8			 
4ac8			; fixed double string push and drop cycle  
4ac8			 
4ac8 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4b7d			 
4b7d			; consistent fixed string push and drop cycle  
4b7d			 
4b7d .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4c21			 
4c21 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4cd7			 
4cd7			;test1:		db ": aa 1 2 3 ;", 0 
4cd7			;test2:     	db "111 aa 888 999",0 
4cd7			;test3:     	db ": bb 77 ;",0 
4cd7			;test4:     	db "$02 $01 do i . loop bb",0 
4cd7			 
4cd7 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4d0f .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4d47 .. 00		test7:     	db ": box hline vline ;",0 
4d5b .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4d87 .. 00		test9:     	db ": sw $01 adsp world ;",0 
4d9d .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4dc2 .. 00		test11:     	db "hello create .",0 
4dd1 .. 00		test12:     	db "hello2 create .",0 
4de1			 
4de1			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4de1			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4de1			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4de1			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4de1			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4de1			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4de1			 
4de1			;iftest1:     	db "$0001 IF cls .",0 
4de1			;iftest2:     	db "$0000 IF cls .",0 
4de1			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4de1			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4de1			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4de1			 
4de1			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4de1			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4de1			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4de1			 
4de1			 
4de1			 
4de1			; a small guess the number game 
4de1			 
4de1 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4df2 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4e54			 
4e54 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4e89 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4ebf .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4ef0 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
4f04 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4f19 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4f4d .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
4f91			 
4f91			; Using 'ga' save a high score across multiple runs using external storage 
4f91			 
4f91 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
4ffa			 
4ffa			 
4ffa			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
4ffa			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
4ffa			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
4ffa			 
4ffa			; simple screen saver to test code memory reuse to destruction 
4ffa			 
4ffa .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5030 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
504c .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5068 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5081 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
50c9 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5120			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5120			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5120			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5120			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5120			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5120			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5120			 
5120			 
5120			 
5120			; minesweeper/battleship finding game 
5120			; draws a game board of random ship/mine positions 
5120			; user enters coords to see if it hits on 
5120			; game ends when all are hit 
5120			; when hit or miss says how many may be in the area 
5120			 
5120			; setup the game board and then hide it 
5120 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
518e .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
51d8			; prompt for where to target 
51d8 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
526e .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5293			; TODO see if the entered coords hits or misses pushes char hit of miss 
5293 .. 00		game2mbht:      db ": mbckht nop ;",0 
52a2 .. 00		game2mbms:      db ": mbcms nop ;",0 
52b0			; TODO how many might be near by 
52b0 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
532d			 
532d			; Game 3 
532d			 
532d			; Vert scroller ski game - avoid the trees! 
532d			 
532d			; v0 score (ie turns) 
532d			; v1 player pos 
532d			; v2 left wall 
532d			; v3 right wall 
532d			 
532d			; Draw side walls randomly 
532d			 
532d .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
535b			 
535b			; Draw player 
535b .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5379			 
5379			; TODO Get Key 
5379			 
5379			; TODO Move left right 
5379			 
5379			; scroll and move walls a bit 
5379			 
5379 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
53aa			 
53aa			; main game loop 
53aa			 
53aa .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
53d6 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5415			 
5415			; key board defs 
5415			 
5415 .. 00		keyup:       db ": keyup $05 ;",0 
5423 .. 00		keydown:       db ": keydown $0a ;",0 
5433 .. 00		keyleft:       db ": keyleft $0b ;",0 
5443 .. 00		keyright:       db ": keyright $0c ;",0 
5454 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5462 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5470 .. 00		keyf3:       db ": keyf3 $12 ;",0 
547e .. 00		keyf4:       db ": keyf4 $13 ;",0 
548c .. 00		keyf5:       db ": keyf5 $14 ;",0 
549a .. 00		keyf6:       db ": keyf6 $15 ;",0 
54a8 .. 00		keyf7:       db ": keyf7 $16 ;",0 
54b6 .. 00		keyf8:       db ": keyf8 $17 ;",0 
54c4 .. 00		keyf9:       db ": keyf9 $18 ;",0 
54d2 .. 00		keyf10:       db ": keyf10 $19 ;",0 
54e1 .. 00		keyf11:       db ": keyf11 $1a ;",0 
54f0 .. 00		keyf12:       db ": keyf12 $1b ;",0 
54ff			 
54ff .. 00		keytab:       db ": keytab $09 ;",0 
550e .. 00		keycr:       db ": keycr $0d ;",0 
551c .. 00		keyhome:       db ": keyhome $0e ;",0 
552c .. 00		keyend:       db ": keyend $0f ;",0 
553b .. 00		keybs:       db ": keybs $08 ;",0 
5549			 
5549			   
5549			 
5549			 
5549			 
5549			; eof 
# End of file forth_autostart.asm
5549			 
5549 .. 00		sprompt1: db "Startup load...",0 
5559 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
556f			 
556f			 
556f			 
556f			 
556f			forth_startup: 
556f 21 a7 46			ld hl, startcmds 
5572 3e 00			ld a, 0 
5574 32 86 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5577			 
5577 e5			.start1:	push hl 
5578 cd 9c 09			call clear_display 
557b 11 49 55			ld de, sprompt1 
557e 3e 00		        ld a, display_row_1 
5580 cd af 09			call str_at_display 
5583 11 59 55			ld de, sprompt2 
5586 3e 28		        ld a, display_row_2 
5588 cd af 09			call str_at_display 
558b e1				pop hl 
558c e5				push hl 
558d 5e				ld e,(hl) 
558e 23				inc hl 
558f 56				ld d,(hl) 
5590 3e 50		        ld a, display_row_3 
5592 cd af 09			call str_at_display 
5595 cd bf 09			call update_display 
5598			 
5598			 
5598 3a 86 e7			ld a, (os_last_cmd) 
559b fe 00			cp 0 
559d 28 05			jr z, .startprompt 
559f cd 02 09			call delay250ms 
55a2 18 24			jr .startdo 
55a4				 
55a4				 
55a4			 
55a4			.startprompt: 
55a4			 
55a4 3e 9f			ld a,display_row_4 + display_cols - 1 
55a6 11 7a 19		        ld de, endprg 
55a9 cd af 09			call str_at_display 
55ac cd bf 09			call update_display 
55af cd 0e 09			call delay1s 
55b2 cd 21 59			call cin_wait 
55b5						 
55b5 fe 2a			cp '*' 
55b7 28 5e			jr z, .startupend1 
55b9 fe 23			cp '#' 
55bb 20 07			jr nz, .startno 
55bd 3e 01			ld a, 1 
55bf 32 86 e7			ld (os_last_cmd),a 
55c2 18 04			jr .startdo 
55c4 fe 31		.startno:	cp '1' 
55c6 28 3a			jr z,.startnxt  
55c8			 
55c8				; exec startup line 
55c8			.startdo:	 
55c8 e1				pop hl 
55c9 e5				push hl 
55ca				 
55ca 5e				ld e,(hl) 
55cb 23				inc hl 
55cc 56				ld d,(hl) 
55cd eb				ex de,hl 
55ce			 
55ce e5				push hl 
55cf			 
55cf 3e 00			ld a, 0 
55d1				;ld a, FORTH_END_BUFFER 
55d1 cd 32 10			call strlent 
55d4 23				inc hl   ; include zero term to copy 
55d5 06 00			ld b,0 
55d7 4d				ld c,l 
55d8 e1				pop hl 
55d9 11 60 e3			ld de, scratch 
55dc ed b0			ldir 
55de			 
55de			 
55de 21 60 e3			ld hl, scratch 
55e1 cd bb 1d			call forthparse 
55e4 cd fb 1d			call forthexec 
55e7 cd 12 1d			call forthexec_cleanup 
55ea			 
55ea 3e 78			ld a, display_row_4 
55ec 11 1e 17			ld de, endprog 
55ef			 
55ef cd bf 09			call update_display		 
55f2			 
55f2 3a 86 e7			ld a, (os_last_cmd) 
55f5 fe 00			cp 0 
55f7 20 09			jr nz, .startnxt 
55f9 cd 7c 19			call next_page_prompt 
55fc cd 9c 09		        call clear_display 
55ff cd bf 09			call update_display		 
5602			 
5602				; move onto next startup line? 
5602			.startnxt: 
5602			 
5602 cd 02 09			call delay250ms 
5605 e1				pop hl 
5606			 
5606 23				inc hl 
5607 23				inc hl 
5608			 
5608 e5				push hl 
5609 5e				ld e, (hl) 
560a 23				inc hl 
560b 56				ld d, (hl) 
560c e1				pop hl 
560d				; TODO replace 0 test 
560d			 
560d eb				ex de, hl 
560e cd f2 0b			call ishlzero 
5611			;	ld a,e 
5611			;	add d 
5611			;	cp 0    ; any left to do? 
5611 eb				ex de, hl 
5612 c2 77 55			jp nz, .start1 
5615 18 01			jr .startupend 
5617			 
5617 e1			.startupend1: pop hl 
5618			.startupend: 
5618			 
5618 cd 9c 09			call clear_display 
561b cd bf 09			call update_display 
561e c9				ret 
561f			 
561f			 
561f			; stack over and underflow checks 
561f			 
561f			; init the words to detect the under/overflow 
561f			 
561f			chk_stk_init: 
561f				; a vague random number to check so we dont get any "lucky" hits 
561f 3e 2d			ld a, 45 
5621 6f				ld l, a 
5622 00				nop 
5623 3e 17			ld a, 23 
5625 67				ld h, a 
5626			 
5626 22 47 e3			ld (chk_word), hl     ; the word we need to check against 
5629			 
5629			;	ld (chk_stund), hl	; stack points.... 
5629 22 00 ef			ld (chk_stovr), hl 
562c 22 0b eb			ld (chk_ret_und), hl 
562f 22 c9 ea			ld (chk_ret_ovr), hl 
5632 22 c7 e9			ld (chk_loop_ovr), hl 
5635 22 c5 e8			ld (chk_data_ovr), hl 
5638 c9				ret 
5639				 
5639			check_stacks: 
5639				; check all stack words 
5639			 
5639 e5				push hl 
563a d5				push de 
563b			 
563b			;	ld de,(chk_word) 
563b			;	ld hl, (chk_stund)	; stack points.... 
563b			;	if DEBUG_STK_FAULT 
563b			;		DMARK "FAa" 
563b			;		CALLMONITOR 
563b			;	endif 
563b			;	call cmp16 
563b			;	jp z, .chk_faulta 
563b			; 
563b			;	ld de, sfaultsu 
563b			;	jp .chk_fault 
563b			 
563b 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
563e ed 5b 47 e3		ld de,(chk_word) 
5642				if DEBUG_STK_FAULT 
5642					DMARK "FAb" 
5642					CALLMONITOR 
5642				endif 
5642 cd e7 0b			call cmp16 
5645 28 06			jr z, .chk_fault1 
5647 11 e8 56			ld de, sfaultso 
564a c3 9c 56			jp .chk_fault 
564d			.chk_fault1:  
564d 2a 0b eb			ld hl, (chk_ret_und) 
5650 ed 5b 47 e3		ld de,(chk_word) 
5654				if DEBUG_STK_FAULT 
5654					DMARK "FAU" 
5654					CALLMONITOR 
5654				endif 
5654 cd e7 0b			call cmp16 
5657 ca 60 56			jp z, .chk_fault2 
565a 11 f8 56			ld de, sfaultru 
565d c3 9c 56			jp .chk_fault 
5660			.chk_fault2:  
5660 2a c9 ea			ld hl, (chk_ret_ovr) 
5663 ed 5b 47 e3		ld de,(chk_word) 
5667				if DEBUG_STK_FAULT 
5667					DMARK "FA1" 
5667					CALLMONITOR 
5667				endif 
5667 cd e7 0b			call cmp16 
566a ca 73 56			jp z, .chk_fault3 
566d 11 06 57			ld de, sfaultro 
5670 c3 9c 56			jp .chk_fault 
5673			.chk_fault3:  
5673 2a c7 e9			ld hl, (chk_loop_ovr) 
5676 ed 5b 47 e3		ld de,(chk_word) 
567a				if DEBUG_STK_FAULT 
567a					DMARK "FA2" 
567a					CALLMONITOR 
567a				endif 
567a cd e7 0b			call cmp16 
567d ca 86 56			jp z, .chk_fault4 
5680 11 20 57			ld de, sfaultlo 
5683 c3 9c 56			jp .chk_fault 
5686			.chk_fault4:  
5686 2a c5 e8			ld hl, (chk_data_ovr) 
5689 ed 5b 47 e3		ld de,(chk_word) 
568d				if DEBUG_STK_FAULT 
568d					DMARK "FA3" 
568d					CALLMONITOR 
568d				endif 
568d cd e7 0b			call cmp16 
5690 ca 99 56			jp z, .chk_fault5 
5693 11 3a 57			ld de, sfaultdo 
5696 c3 9c 56			jp .chk_fault 
5699			 
5699			 
5699			.chk_fault5:  
5699 d1				pop de 
569a e1				pop hl 
569b			 
569b c9				ret 
569c			 
569c cd 9c 09		.chk_fault: 	call clear_display 
569f 3e 28				ld a, display_row_2 
56a1 cd af 09				call str_at_display 
56a4 11 ca 56				   ld de, .stackfault 
56a7 3e 00				ld a, display_row_1 
56a9 cd af 09				call str_at_display 
56ac 11 7a ee				    ld de, debug_mark 
56af 3e 11				ld a, display_row_1+17 
56b1 cd af 09				call str_at_display 
56b4 cd bf 09				call update_display 
56b7			 
56b7				; prompt before entering montior for investigating issue 
56b7			 
56b7 3e 78			ld a, display_row_4 
56b9 11 1e 17			ld de, endprog 
56bc			 
56bc cd bf 09			call update_display		 
56bf			 
56bf cd 7c 19			call next_page_prompt 
56c2			 
56c2 d1				pop de 
56c3 e1				pop hl 
56c4 cd 72 17				call monitor 
56c7 c3 6c 16				jp warmstart 
56ca					;jp 0 
56ca					;halt 
56ca			 
56ca			 
56ca			 
56ca .. 00		.stackfault: 	db "Stack fault:",0 
56d7			 
56d7 .. 00		sfaultsu: 	db	"Stack under flow",0 
56e8 .. 00		sfaultso: 	db	"Stack over flow",0 
56f8 .. 00		sfaultru:	db "RTS underflow",0 
5706 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5720 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
573a .. 00		sfaultdo:	db "DTS overflow", 0 
5747			 
5747			 
5747			fault_dsp_under: 
5747 11 59 57			ld de, .dsp_under 
574a c3 09 58			jp .show_fault 
574d			 
574d			fault_rsp_under: 
574d 11 67 57			ld de, .rsp_under 
5750 c3 09 58			jp .show_fault 
5753			fault_loop_under: 
5753 11 75 57			ld de, .loop_under 
5756 c3 09 58			jp .show_fault 
5759			 
5759 .. 00		.dsp_under: db "DSP Underflow",0 
5767 .. 00		.rsp_under: db "RSP Underflow",0 
5775 .. 00		.loop_under: db "LOOP Underflow",0 
5784			 
5784			 
5784 d5			type_faultn: 	push de 
5785 e5					push hl 
5786 cd 9c 09				call clear_display 
5789 11 b0 57				   ld de, .typefaultn 
578c 3e 00				ld a, display_row_1 
578e cd af 09				call str_at_display 
5791 11 7a ee				    ld de, debug_mark 
5794 3e 11				ld a, display_row_1+17 
5796 cd af 09				call str_at_display 
5799 cd bf 09				call update_display 
579c			 
579c				; prompt before entering montior for investigating issue 
579c			 
579c 3e 78			ld a, display_row_4 
579e 11 1e 17			ld de, endprog 
57a1			 
57a1 cd bf 09			call update_display		 
57a4			 
57a4 cd 7c 19			call next_page_prompt 
57a7			 
57a7 e5					push hl 
57a8 d5					push de 
57a9 cd 72 17				call monitor 
57ac c3 6c 16				jp warmstart 
57af 76					halt 
57b0			 
57b0			 
57b0 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
57c7			 
57c7 d5			type_faults: 	push de 
57c8 e5					push hl 
57c9 cd 9c 09				call clear_display 
57cc 11 f2 57				   ld de, .typefaults 
57cf 3e 00				ld a, display_row_1 
57d1 cd af 09				call str_at_display 
57d4 11 7a ee				    ld de, debug_mark 
57d7 3e 11				ld a, display_row_1+17 
57d9 cd af 09				call str_at_display 
57dc cd bf 09				call update_display 
57df			 
57df				; prompt before entering montior for investigating issue 
57df			 
57df 3e 78			ld a, display_row_4 
57e1 11 1e 17			ld de, endprog 
57e4			 
57e4 cd bf 09			call update_display		 
57e7			 
57e7 cd 7c 19			call next_page_prompt 
57ea			 
57ea e1					pop hl 
57eb d1					pop de 
57ec cd 72 17				call monitor 
57ef c3 6c 16				jp warmstart 
57f2			 
57f2			 
57f2 .. 00		.typefaults: db "STR Type Expected TOS!",0 
5809			 
5809			.show_fault: 	 
5809 d5					push de 
580a cd 9c 09				call clear_display 
580d d1					pop de 
580e 3e 00				ld a, display_row_1 
5810 cd af 09				call str_at_display 
5813 11 7a ee				    ld de, debug_mark 
5816 3e 11				ld a, display_row_1+17 
5818 cd af 09				call str_at_display 
581b cd bf 09				call update_display 
581e			 
581e				; prompt before entering montior for investigating issue 
581e			 
581e 3e 78			ld a, display_row_4 
5820 11 1e 17			ld de, endprog 
5823			 
5823 cd bf 09			call update_display		 
5826			 
5826 cd 7c 19			call next_page_prompt 
5829			 
5829 e1					pop hl 
582a d1					pop de 
582b cd 72 17				call monitor 
582e			; do a dump to cli and not warmstart so we preserve all of the uwords.  
582e			; TODO Make optional fault restart to cli or warm boot? 
582e					;jp warmstart 
582e c3 c4 16				jp cli 
5831 76					halt 
5832			 
5832			; handle the auto run of code from files in storage 
5832			 
5832			 
5832			if STORAGE_SE 
5832			 
5832			sprompt3: db "Loading from start-up file?:",0 
5832			sprompt4: db "(Y=Any key/N=No)",0 
5832			 
5832			 
5832			forth_autoload: 
5832			 
5832				; load block 0 of store 1 
5832				 
5832				ld a, $fe      ; bit 0 clear 
5832				ld (spi_device), a 
5832			 
5832				call storage_get_block_0 
5832			 
5832				ld a, (store_page+STORE_0_AUTOFILE) 
5832			 
5832				cp 0 
5832				ret z     ; auto start not enabled 
5832			 
5832				call clear_display 
5832			 
5832				; set bank 
5832			 
5832					ld a, (store_page+STORE_0_BANKRUN) 
5832					ld (spi_device), a 
5832			 
5832				; get file id to load from and get the file name to display 
5832			 
5832					ld a, (store_page+STORE_0_FILERUN) 
5832			 
5832					ld l, 0 
5832					ld h, a 
5832					ld de, store_page 
5832			 
5832					if DEBUG_FORTH_WORDS 
5832						DMARK "ASp" 
5832						CALLMONITOR 
5832					endif 
5832					call storage_read 
5832			 
5832					if DEBUG_FORTH_WORDS 
5832						DMARK "ASr" 
5832						CALLMONITOR 
5832					endif 
5832			 
5832					call ishlzero 
5832					ret z             ; file not found 
5832			 
5832					ld a, display_row_2 + 10 
5832					ld de, store_page+3 
5832					call str_at_display 
5832				 
5832			; 
5832			 
5832				ld a, display_row_1+5 
5832				ld de, sprompt3 
5832				call str_at_display 
5832				ld a, display_row_3+15 
5832				ld de, sprompt4 
5832				call str_at_display 
5832			 
5832				call update_display 
5832			 
5832				call cin_wait 
5832				cp 'n' 
5832				ret z 
5832				cp 'N' 
5832				ret z 
5832			 
5832				call delay1s 
5832			 
5832				ld a, (store_page+2) 
5832				ld (store_openmaxext), a    ; save count of ext 
5832				ld a, 1  
5832				ld (store_openext), a    ; save count of ext 
5832			 
5832			.autof:  
5832				ld l , a 
5832				 
5832				ld a, (store_page) 
5832				ld h, a	 
5832				ld de, store_page 
5832					if DEBUG_FORTH_WORDS 
5832						DMARK "ASl" 
5832						CALLMONITOR 
5832					endif 
5832					call storage_read 
5832				call ishlzero 
5832				ret z 
5832			;	jr z, .autoend 
5832			 
5832					if DEBUG_FORTH_WORDS 
5832						DMARK "ASc" 
5832						CALLMONITOR 
5832					endif 
5832				ld de, store_page+2 
5832				ld a, display_row_4 
5832				call str_at_display 
5832			 
5832				call update_display 
5832				call delay250ms 
5832			 
5832			 
5832			 
5832				ld hl, store_page+2 
5832				call forthparse 
5832				call forthexec 
5832				call forthexec_cleanup 
5832			 
5832				 
5832				ld a, (store_openext) 
5832				inc a 
5832				ld (store_openext), a    ; save count of ext 
5832			 
5832				jr .autof 
5832			;.autofdone: 
5832			; 
5832			;		if DEBUG_FORTH_WORDS 
5832			;			DMARK "ASx" 
5832			;			CALLMONITOR 
5832			;		endif 
5832			;;	call clear_display 
5832			;	ret 
5832			 
5832			 
5832			 
5832			endif 
5832			 
5832			 
5832			; eof 
# End of file forth_kernel.asm
5832			;include "nascombasic.asm" 
5832			 
5832			 
5832			; find out where the code ends if loaded into RAM (for SC114) 
5832			;endofcode:  
5832			;	nop 
5832			 
5832			 
5832			; eof 
5832			 
# End of file main.asm
5832			;include "firmware_lcd_4x40.asm" 
5832			;;include "firmware_lcd_4x20.asm" 
5832			include "firmware_cpm_display.asm" 
5832			 
5832			; Serial display interface for SC114 
5832			 
5832			 
5832			display_row_1: equ 0 
5832			display_row_2: equ display_row_1+display_cols 
5832			display_row_3: equ display_row_2 + display_cols 
5832			display_row_4: equ display_row_3 + display_cols 
5832			 
5832			kLCDWidth:  EQU display_cols             ;Width in characters 
5832			kLCD_Line1: EQU 0x00  
5832			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5832			; E1 
5832			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5832			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5832			 
5832			lcd_init: 
5832				; no init as handled by the SCM bios 
5832 c9				ret 
5833			 
5833			 
5833			; low level functions for direct screen writes 
5833			 
5833			; output char at pos? 
5833			fLCD_Str: 
5833			        ;out (SC114_SIO_1_OUT),a 
5833 c5				push bc 
5834 d5				push de 
5835 5f				ld e, a 
5836			; TODO Replace with CP/M BIOS call 
5836 0e 02			ld c, $02 
5838 cd 05 00			call 5 
583b d1				pop de 
583c c1				pop bc 
583d c9				ret 
583e			 
583e			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
583e			fLCD_Pos: 
583e				; use ASCII escape to position 
583e			        ;out (SC114_SIO_1_OUT),a 
583e c5				push bc 
583f d5				push de 
5840 5f				ld e, a 
5841 0e 02			ld c, $02 
5843			; TODO Replace with CP/M BIOS call 
5843 cd 05 00			call 5 
5846 d1				pop de 
5847 c1				pop bc 
5848			 
5848 c9				ret 
5849			 
5849			; output char at pos 
5849			fLCD_Data: 
5849			      ;  out (SC114_SIO_1_OUT),a 
5849 c5				push bc 
584a d5				push de 
584b 0e 02			ld c, $02 
584d 5f				ld e, a 
584e			; TODO Replace with CP/M BIOS call 
584e cd 05 00			call 5 
5851 d1				pop de 
5852 c1				pop bc 
5853			 
5853 c9				ret 
5854			 
5854			; ascii cls  
5854			 
5854 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
5858			 
5858 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
586f			;.clscpm: db 3, $3c,"$" 
586f			 
586f			; write the frame buffer given in hl to hardware  
586f			write_display: 
586f			 
586f			API: equ 0 
586f			 
586f			if API 
586f				push bc 
586f				ld b, 4 
586f			 
586f			        ld (display_write_tmp), hl 	  
586f			 
586f				; clear and home cursor 
586f			 
586f				ld c, 9 
586f				ld de, .cls 
586f			; TODO Replace with CP/M BIOS call 
586f				call 5 
586f			 
586f			 
586f			.writeln: 
586f			 
586f				ld de, (display_write_tmp) 
586f				ld c, 6 
586f			; TODO Replace with CP/M BIOS call 
586f				rst $30 
586f				ld c, 7 
586f				rst $30 
586f			 
586f				ld hl, (display_write_tmp) 
586f				ld de, display_cols 
586f				add hl,de 
586f				ld (display_write_tmp),hl 
586f			 
586f				djnz  .writeln 
586f			 
586f				pop bc 
586f			 
586f			 
586f				ret 
586f			endif 
586f e5				push hl 
5870 c5				push bc 
5871 d5				push de 
5872			 
5872			;	ld c, 2 
5872			;	;ld de, .cls 
5872			;	ld a, 27 
5872			;	rst $30 
5872			;	ld c, 2 
5872			;	;ld de, .cls 
5872			;	ld a, '[' 
5872			;	rst $30 
5872			; 
5872			;	ld c, 2 
5872			;	;ld de, .cls 
5872			;	ld a, 'H' 
5872			;	rst $30 
5872			; 
5872			 
5872			 
5872			; lots of CR/LF 
5872			;	ld c, 9 
5872			;	ld de, .clscpm 
5872			;	call 5 
5872			 
5872			; xterm cls 
5872 0e 02			ld c, 2 
5874 1e 1b			ld e, 27 
5876 cd 05 00			call 5 
5879			; cls causes too much flicker 
5879			;	ld c, 2 
5879			;	ld e, 'c' 
5879			;	call 5 
5879			 
5879			; use xterm home instead 
5879 0e 02			ld c, 2 
587b 1e 5b			ld e, '[' 
587d cd 05 00			call 5 
5880 0e 02			ld c, 2 
5882 1e 48			ld e, 'H' 
5884 cd 05 00			call 5 
5887			LLL: equ 0 
5887			 
5887			if LLL 
5887			 
5887				ld c, 2 
5887				;ld de, .cls 
5887				ld e, 27 
5887			; TODO Replace with CP/M BIOS call 
5887				call 5 
5887			 
5887			 
5887				ld c, 2 
5887				;ld de, .cls 
5887				ld e, '[' 
5887			; TODO Replace with CP/M BIOS call 
5887				call 5 
5887				ld c, 2 
5887				;ld de, .cls 
5887				ld e, '2' 
5887			; TODO Replace with CP/M BIOS call 
5887				call 5 
5887				ld c, 2 
5887				;ld de, .cls 
5887				ld e, 'J' 
5887			; TODO Replace with CP/M BIOS call 
5887				call 5 
5887			 
5887			endif 
5887			 
5887 d1				pop de 
5888 c1				pop bc 
5889 e1				pop hl 
588a			 
588a			 
588a 22 d8 eb		        ld (display_write_tmp), hl 	  
588d 3e 00			ld a, kLCD_Line1 
588f			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
588f 06 28			ld b, display_cols 
5891 ed 5b d8 eb		ld de, (display_write_tmp) 
5895 cd 18 59			call write_len_string 
5898				 
5898			 
5898 e5			push hl 
5899 d5			push de 
589a c5			push bc 
589b 0e 02			ld c, 2 
589d 1e 0a			ld e, 10 
589f cd 05 00			call 5 
58a2 0e 02			ld c, 2 
58a4 1e 0d			ld e, 13 
58a6 cd 05 00			call 5 
58a9			; TODO Replace with CP/M BIOS call 
58a9				;rst $30 
58a9 c1			pop bc 
58aa d1			pop de 
58ab e1			pop hl 
58ac			 
58ac				 
58ac 2a d8 eb			ld hl, (display_write_tmp) 
58af 11 28 00			ld de, display_cols 
58b2 19				add hl,de 
58b3 22 d8 eb			ld (display_write_tmp),hl 
58b6			 
58b6				 
58b6 3e 28			ld a, kLCD_Line2 
58b8			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
58b8 06 28			ld b, display_cols 
58ba ed 5b d8 eb		ld de, (display_write_tmp) 
58be cd 18 59			call write_len_string 
58c1				 
58c1 2a d8 eb			ld hl, (display_write_tmp) 
58c4 11 28 00			ld de, display_cols 
58c7 19				add hl,de 
58c8 22 d8 eb			ld (display_write_tmp),hl 
58cb			 
58cb e5			push hl 
58cc d5			push de 
58cd c5			push bc 
58ce 0e 07			ld c, 7 
58d0			; TODO Replace with CP/M BIOS call 
58d0				;rst $30 
58d0 0e 02			ld c, 2 
58d2 1e 0a			ld e, 10 
58d4 cd 05 00			call 5 
58d7 0e 02			ld c, 2 
58d9 1e 0d			ld e, 13 
58db cd 05 00			call 5 
58de c1			pop bc 
58df d1			pop de 
58e0 e1			pop hl 
58e1			 
58e1				 
58e1 3e 50			ld a, kLCD_Line3 
58e3			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
58e3 06 28			ld b, display_cols 
58e5 ed 5b d8 eb		ld de, (display_write_tmp) 
58e9 cd 18 59			call write_len_string 
58ec				 
58ec 2a d8 eb			ld hl, (display_write_tmp) 
58ef 11 28 00			ld de, display_cols 
58f2 19				add hl,de 
58f3 22 d8 eb			ld (display_write_tmp),hl 
58f6			 
58f6 e5			push hl 
58f7 d5			push de 
58f8 c5			push bc 
58f9 0e 07			ld c, 7 
58fb			; TODO Replace with CP/M BIOS call 
58fb				;rst $30 
58fb 0e 02			ld c, 2 
58fd 1e 0a			ld e, 10 
58ff cd 05 00			call 5 
5902 0e 02			ld c, 2 
5904 1e 0d			ld e, 13 
5906 cd 05 00			call 5 
5909 c1			pop bc 
590a d1			pop de 
590b e1			pop hl 
590c			 
590c				 
590c 3e 78			ld a, kLCD_Line4 
590e			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
590e 06 28			ld b, display_cols 
5910 ed 5b d8 eb		ld de, (display_write_tmp) 
5914 cd 18 59			call write_len_string 
5917 c9					ret 
5918			 
5918			 
5918				; write out a fixed length string given in b from de 
5918			 
5918 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
5919 cd 49 58		            CALL fLCD_Data      ;Write character to display 
591c 13				inc de 
591d 10 f9			djnz write_len_string 
591f c9				ret 
5920			 
5920			 
5920			; eof 
# End of file firmware_cpm_display.asm
5920			;include "firmware_key_5x10.asm" 
5920			;;include "firmware_key_4x10.asm" 
5920			include "firmware_key_cpm.asm" 
5920			; Serial keyboard interface for SC114 
5920			 
5920			 
5920			key_init: 
5920				; no init as handled by the SCM bios 
5920 c9				ret 
5921			 
5921			 
5921			cin_wait: 
5921			;	ld a, 0 
5921			;	ret 
5921			 
5921				;in a,(SC114_SIO_1_IN) 
5921			        ; Use SCM API to get from whatever console device we are using 
5921			 
5921			; TODO Replace with CP/M BIOS call 
5921 c5				push bc 
5922 0e 01			ld c, $01 
5924 cd 05 00			call 5 
5927 c1				pop bc 
5928 c9				ret 
5929			 
5929			cin: 
5929			 
5929			 
5929 c5				push bc 
592a			 
592a				; any key waiting to process? 
592a			; TODO Replace with CP/M BIOS call 
592a 0e 06			ld c, $06 
592c cd 05 00			call 5 
592f 28 0d			jr z, .cin_skip 
5931			 
5931				; yep, get it 
5931			 
5931 0e 01			ld c, $01 
5933			; TODO Replace with CP/M BIOS call 
5933 cd 05 00			call 5 
5936			 
5936 fe 7f			cp $7f     ; back space 
5938 20 02			jr nz, .skipbs 
593a 3e 08			ld a, KEY_BS 
593c			.skipbs: 
593c			 
593c c1				pop bc 
593d c9				ret 
593e			.cin_skip: 
593e 3e 00			ld a, 0 
5940 c1				pop bc 
5941 c9				ret 
5942			 
5942			 
5942			 
5942			 
# End of file firmware_key_cpm.asm
5942			endofcode:  
5942			baseram:  
5942 00				nop 
5943			 
5943			heap_start: equ baseram+15  ; Starting address of heap 
5943			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5943			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5943			;VDU:  EQU     endofcode           ; BASIC Work space 
5943			; eof 
5943			 
# End of file os_mega_cpm.asm
5943
