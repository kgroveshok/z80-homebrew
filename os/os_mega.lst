# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 4a 19			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 7d fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 1c fa				ld hl, display_fb1  
000b 22 d8 f8				ld (display_fb_active), hl  
000e			  
000e cd ec 0a				call clear_display  
0011			  
0011 21 da f8				ld hl, display_fb2  
0014 22 d8 f8				ld (display_fb_active), hl  
0017			  
0017 cd ec 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 bd fa				ld hl, display_fb0  
001d 22 d8 f8				ld (display_fb_active), hl  
0020			  
0020 cd ec 0a				call clear_display  
0023			  
0023			  
0023 cd ea 65				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 81 68			call key_init  
0029 cd cc 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd c3 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f cd 80 13				call sound_init  
0032				endif  
0032			  
0032				; lcd test sequence  
0032					  
0032 cd 0f 0b			call update_display  
0035 cd 69 0a			call delay1s  
0038 3e 2b			ld a,'+'  
003a cd f1 0a			call fill_display  
003d cd 0f 0b			call update_display  
0040 cd 69 0a			call delay1s  
0043 3e 2a			ld a,'*'  
0045 cd f1 0a			call fill_display  
0048 cd 0f 0b			call update_display  
004b cd 69 0a			call delay1s  
004e 3e 2d			ld a,'-'  
0050 cd f1 0a			call fill_display  
0053 cd 0f 0b			call update_display  
0056 cd 69 0a			call delay1s  
0059			  
0059			; boot splash screen  
0059			if display_cols == 20	  
0059			        ld a, display_row_1    
0059			else  
0059 3e 0a		        ld a, display_row_1 +10   
005b			endif  
005b 11 8c 00			ld de, bootmsg  
005e cd ff 0a			call str_at_display  
0061 cd 0f 0b			call update_display  
0064			  
0064			  
0064 cd 69 0a			call delay1s  
0067 cd 69 0a			call delay1s  
006a			if display_cols == 20	  
006a			            LD   A, display_row_3+2  
006a			else  
006a 3e 5c		            LD   A, display_row_3+12  
006c			endif  
006c 11 a1 00			ld de, bootmsg1  
006f cd ff 0a			call str_at_display  
0072 cd 0f 0b			call update_display  
0075 cd 69 0a			call delay1s  
0078 cd 69 0a			call delay1s  
007b			  
007b			;	ld a, display_row_4+3  
007b			;	ld de, bootmsg2  
007b			;	call str_at_display  
007b			;	call update_display  
007b			;	call delay1s  
007b			;	call delay1s  
007b			  
007b			; debug mark setup  
007b			  
007b 3e 5f		ld a, '_'  
007d 32 77 fb		ld (debug_mark),a  
0080 32 78 fb		ld (debug_mark+1),a  
0083 32 79 fb		ld (debug_mark+2),a  
0086 3e 00		ld a,0  
0088 32 7a fb		ld (debug_mark+3),a  
008b			  
008b c9					ret  
008c			  
008c			  
008c .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
00a1 .. 00		bootmsg1:	db "by Kevin Groves",0  
00b1			;bootmsg2:	db "Firmware v0.1",0  
00b1			  
00b1			; a 4x20 lcd  
00b1			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00b1			  
00b1			;if display_cols == 20  
00b1			;	include "firmware_lcd_4x20.asm"  
00b1			;endif  
00b1			  
00b1			;if display_cols == 40  
00b1			;	include "firmware_lcd_4x40.asm"  
00b1			;endif  
00b1			  
00b1			;  
00b1			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00b1			; TODO abstract the bit bang video out interface for dual display  
00b1			; TODO wire video out to tx pin on rc2014 bus  
00b1			  
00b1			; must supply cin, and cin_wait for low level hardware abstraction   
00b1			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00b1			; test scancode  
00b1			  
00b1			;;;;;  
00b1			;;;  
00b1			; Moved out to mini and maxi versions  
00b1			;  
00b1			; include "firmware_key_4x4.asm"  
00b1			; using existing 4 wire x 4 resistor array for input  
00b1			;include "firmware_key_4x10.asm"  
00b1			; need to mod the board for 5 rows due to resistor array  
00b1			;include "firmware_key_5x10.asm"  
00b1			  
00b1			; storage hardware interface  
00b1			  
00b1			; use microchip serial eeprom for storage  
00b1			  
00b1			  
00b1			if STORAGE_SE  
00b1				include "firmware_spi.asm"  
00b1			; my spi protocol (used by storage) 
00b1			 
00b1			; SPI pins 
00b1			 
00b1			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00b1			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00b1			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00b1			 
00b1			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00b1			; chip pin 4 gnd 
00b1			 
00b1			 
00b1			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00b1			SPI_CE1: equ 1      ;    port a1 pin 14  
00b1			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00b1			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00b1			SPI_CE4: equ 4      ; port a4     pin 10 
00b1			 
00b1			; active low AND masks 
00b1			 
00b1			;SPI_CE0_MASK: equ    255-1 
00b1			;SPI_CE1_MASK: equ   255-2 
00b1			;SPI_CE2_MASK: equ   255-4 
00b1			;SPI_CE3_MASK: equ   255-8 
00b1			;SPI_CE4_MASK: equ   255-16 
00b1			SPI_CE_HIGH:  equ 255 
00b1			 
00b1			 
00b1			 
00b1			 
00b1			; TODO store port id for spi device ie dev c 
00b1			; TODO store pin for SO 
00b1			; TODO store pin for SI 
00b1			; TODO store pin for SCLK 
00b1			 
00b1			; 
00b1			 
00b1			; ensure that spi bus is in a stable state with default pins  
00b1			 
00b1			se_stable_spi:   
00b1			 
00b1				 ; set DI high, CE high , SCLK low 
00b1				;ld a, SPI_DI | SPI_CE0 
00b1 3e 07			ld a, SPI_DI  
00b3 cd 87 01			call spi_ce_high 
00b6 d3 80			 out (storage_adata),a 
00b8 32 49 f8			ld (spi_portbyte),a 
00bb			 
00bb				if DEBUG_SPI 
00bb					push hl 
00bb					ld l, a 
00bb					DMARK "SPI" 
00bb					CALLMONITOR 
00bb					pop hl 
00bb				endif 
00bb c9				ret 
00bc			 
00bc			; byte to send in a 
00bc			 
00bc			spi_send_byte: 
00bc				; save byte to send for bit mask shift out 
00bc 4f			        ld c,a 
00bd 3a 49 f8			ld a,(spi_portbyte) 
00c0				  
00c0				; clock out	each bit of the byte msb first 
00c0			 
00c0 06 08			ld b, 8 
00c2			.ssb1: 
00c2				; clear so bit  
00c2 cb bf			res SPI_DI, a 
00c4 cb 11			rl c 
00c6				; if bit 7 is set then carry is set 
00c6 30 02			jr nc, .ssb2 
00c8 cb ff			set SPI_DI,a 
00ca			.ssb2:  ; output bit to ensure it is stable 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; clock bit high 
00cd cb ef			set SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2				; then low 
00d2 cb af			res SPI_SCLK,a 
00d4 d3 80			out (storage_adata),a 
00d6 00				nop 
00d7 10 e9			djnz .ssb1 
00d9			 
00d9 32 49 f8			ld (spi_portbyte),a 
00dc c9				ret 
00dd			 
00dd			; TODO low level get byte into A on spi 
00dd			 
00dd			spi_read_byte:  
00dd			 
00dd				; save byte to send for bit mask shift out 
00dd 0e 00		    ld c,0 
00df 3a 49 f8			ld a,(spi_portbyte) 
00e2				  
00e2				; clock out	each bit of the byte msb first 
00e2			 
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f9		    set 7,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b7 
00ef cb b9		    res 7,c 
00f1			.b7: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			     
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb f1		    set 6,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b6 
0103 cb b1		    res 6,c 
0105			.b6: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			 
010f			    ; read DO  
010f			 
010f cb e9		    set 5,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b5 
0117 cb a9		    res 5,c 
0119			.b5: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb e1		    set 4,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b4 
012b cb a1		    res 4,c 
012d			.b4: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d9		    set 3,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b3 
013f cb 99		    res 3,c 
0141			.b3: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb d1		    set 2,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b2 
0153 cb 91		    res 2,c 
0155			.b2: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c9		    set 1,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b1 
0167 cb 89		    res 1,c 
0169			.b1: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e				; clock bit high 
016e cb ef			set SPI_SCLK,a 
0170 d3 80			out (storage_adata),a 
0172 00				nop 
0173			 
0173			    ; read DO  
0173			 
0173 cb c1		    set 0,c 
0175 db 80			in a,(storage_adata) 
0177 cb 77		    bit SPI_DO,a 
0179 20 02		    jr nz, .b0 
017b cb 81		    res 0,c 
017d			.b0: 
017d				; then low 
017d cb af			res SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182			 
0182			 
0182 32 49 f8			ld (spi_portbyte),a 
0185			 
0185			    ; return byte 
0185 79			    ld a,c 
0186			 
0186			 
0186 c9				ret 
0187			 
0187			 
0187			 
0187			spi_ce_high: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187			 
0187 f5				push af 
0188			 
0188				; send direct ce to port b 
0188 3e ff			ld a, 255 
018a d3 81			out (storage_bdata), a 
018c			 
018c f1				pop af 
018d			 
018d				; for port a that shares with spi lines AND the mask 
018d			  
018d				if DEBUG_SPI 
018d					push hl 
018d					ld h, a 
018d				endif 
018d			;	ld c, SPI_CE_HIGH 
018d			;	and c 
018d cb c7			set SPI_CE0, a 
018f cb cf			set SPI_CE1, a 
0191 cb d7			set SPI_CE2, a 
0193 cb df			set SPI_CE3, a 
0195 cb e7			set SPI_CE4, a 
0197			 
0197				if DEBUG_SPI 
0197					ld l, a 
0197					DMARK "CEh" 
0197					CALLMONITOR 
0197					pop hl 
0197				endif 
0197 c9				ret 
0198			 
0198			 
0198			spi_ce_low: 
0198			 
0198				if DEBUG_SPI_HARD_CE0 
0198			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0198					ret 
0198			 
0198				endif 
0198			 
0198 c5				push bc 
0199 f5				push af 
019a			 
019a				; send direct ce to port b 
019a 3a 4b f8			ld a, (spi_cartdev) 
019d d3 81			out (storage_bdata), a 
019f			 
019f			 
019f			 
019f				; for port a that shares with spi lines AND the mask 
019f			 
019f 3a 48 f8			ld a, (spi_device)  
01a2 4f				ld c, a 
01a3			 
01a3 f1				pop af 
01a4			 
01a4				; detect CEx 
01a4			 
01a4				if DEBUG_SPI 
01a4					push hl 
01a4					ld h, a 
01a4				endif 
01a4			 
01a4 cb 41			bit SPI_CE0, c 
01a6 20 04			jr nz, .cel1 
01a8 cb 87			res SPI_CE0, a 
01aa 18 1e			jr .celn 
01ac			.cel1: 
01ac cb 49			bit SPI_CE1, c 
01ae 20 04			jr nz, .cel2 
01b0 cb 8f			res SPI_CE1, a 
01b2 18 16			jr .celn 
01b4			.cel2: 
01b4 cb 51			bit SPI_CE2, c 
01b6 20 04			jr nz, .cel3 
01b8 cb 97			res SPI_CE2, a 
01ba 18 0e			jr .celn 
01bc			.cel3: 
01bc cb 59			bit SPI_CE3, c 
01be 20 04			jr nz, .cel4 
01c0 cb 9f			res SPI_CE3, a 
01c2 18 06			jr .celn 
01c4			.cel4: 
01c4 cb 61			bit SPI_CE4, c 
01c6 20 02			jr nz, .celn 
01c8 cb a7			res SPI_CE4, a 
01ca			.celn: 
01ca			 
01ca			 
01ca			 
01ca			;	add c 
01ca			 
01ca				if DEBUG_SPI 
01ca					ld l, a 
01ca					DMARK "CEl" 
01ca					CALLMONITOR 
01ca					pop hl 
01ca				endif 
01ca c1				pop bc 
01cb c9				ret 
01cc			 
01cc			 
01cc			 
01cc			; eof 
01cc			 
01cc			 
01cc			 
01cc			 
01cc			 
# End of file firmware_spi.asm
01cc				include "firmware_seeprom.asm"  
01cc			; 
01cc			; persisent storage interface via microchip serial eeprom 
01cc			 
01cc			; port a pio 2 
01cc			; pa 7 - si 
01cc			; pa 6 - sclk  
01cc			; pa 5 - so 
01cc			; pa 4 - cs 
01cc			; pa 3 - cs 
01cc			; pa 2 - cs 
01cc			; pa 1 - cs 
01cc			; pa 0 - cs 
01cc			; 
01cc			; TODO get block 
01cc			; TODO save block 
01cc			; TODO load file 
01cc			; TODO save file 
01cc			; TODO get dir  
01cc			 
01cc			;  
01cc			storage_adata: equ Device_C    ; device c port a - onboard storage 
01cc			storage_actl: equ Device_C+2     ; device c port a 
01cc			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01cc			storage_bctl: equ Device_C+3     ; device c port b 
01cc			 
01cc			 
01cc			; TODO move these to hardware driver file 
01cc			 
01cc			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01cc			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01cc			; storage bank file system format 
01cc			; 
01cc			; first page of bank: 
01cc			; 	addr 0 - status check 
01cc			;       addr 1 - write protect flag 
01cc			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01cc			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01cc			;         TODO see if scanning whole of for available next file id is fast enough 
01cc			;	addr 4 > zero term string of bank label 
01cc			; 
01cc			;        
01cc			;  
01cc			; first page of any file: 
01cc			;      byte 0 - file id  
01cc			;      byte 1-17 - fixed file name  
01cc			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01cc			; 
01cc			; other pages of any file: 
01cc			;      byte 0 - file id 
01cc			;      byte 1> - file data 
01cc			; 
01cc			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01cc			;  
01cc			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01cc			 
01cc			 
01cc			;storage_so_bit: 5 
01cc			;storage_si_bit: 7 
01cc			;storage_sclk_bit: 6 
01cc			  
01cc			 
01cc			; init storage pio 
01cc			 
01cc			storage_init: 
01cc			 
01cc 3e cf		            LD   A, 11001111b 
01ce d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01d0 3e 00		            LD   A, 00000000b 
01d2 cb f7			set SPI_DO,a 
01d4			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d4 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d6			 
01d6 3e cf		            LD   A, 11001111b 
01d8 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01da 3e 00		            LD   A, 00000000b 
01dc d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01de			 
01de				; set all external spi devices off 
01de 3e 00			ld a, 0 
01e0 32 48 f8			ld (spi_device), a 
01e3 32 4b f8			ld (spi_cartdev), a 
01e6			 
01e6					; ensure the spi bus is in a default stable state 
01e6 cd b1 00				call se_stable_spi 
01e9			 
01e9			; TODO scan spi bus and gather which storage banks are present 
01e9			 
01e9			; populate store_bank_active  
01e9			; for each ce line activate and attempt to write first byte of bank and read back 
01e9			; if zero is returned then bank is empty 
01e9			;   
01e9			; 
01e9			 
01e9					; init file extent cache to save on slow reads 
01e9			 
01e9			;	ld hl, store_filecache 
01e9			;	ld de, 0 
01e9			;	ld hl,(de)	 
01e9			 
01e9			 
01e9 c9			    ret 
01ea			 
01ea			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01ea			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01ea			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01ea			 
01ea			; INSTRUCTION SET 
01ea			; READ 0000 0011 Read data from memory array beginning at selected address 
01ea			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01ea			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01ea			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01ea			; RDSR 0000 0101 Read STATUS register 
01ea			; WRSR 0000 0001 Write STATUS register 
01ea			; PE 0100 0010 Page Erase – erase one page in memory array 
01ea			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01ea			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01ea			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01ea			 
01ea			; TODO send byte steam for page without setting the address for every single byte 
01ea			; TODO read byte  
01ea			 
01ea			; byte in a 
01ea			; address in hl  
01ea			se_writebyte: 
01ea			        
01ea			    ;   ld c, a 
01ea f5			        push af 
01eb e5			        push hl 
01ec			 
01ec			    ; initi write mode 
01ec			    ; 
01ec			    ;CS low 
01ec			 
01ec 3a 49 f8		       ld a,(spi_portbyte) 
01ef cd 98 01			call spi_ce_low 
01f2			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f2 d3 80		       out (storage_adata),a 
01f4 32 49 f8		       ld (spi_portbyte), a 
01f7			 
01f7			    ;clock out wren instruction 
01f7			 
01f7 3e 06		    ld a, store_wren_ins 
01f9 cd bc 00		    call spi_send_byte  
01fc			 
01fc			    ;cs high to enable write latch 
01fc			 
01fc 3a 49 f8		       ld a,(spi_portbyte) 
01ff cd 87 01			call spi_ce_high 
0202			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202 d3 80		       out (storage_adata),a 
0204 32 49 f8		       ld (spi_portbyte), a 
0207			 
0207 00				nop 
0208			    ; 
0208			    ; intial write data 
0208			    ; 
0208			    ; cs low 
0208			     
0208 3a 49 f8		       ld a,(spi_portbyte) 
020b cd 98 01			call spi_ce_low 
020e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e d3 80		       out (storage_adata),a 
0210 32 49 f8		       ld (spi_portbyte), a 
0213			 
0213			    ; clock out write instruction 
0213			     
0213 3e 02		    ld a, store_write_ins  
0215 cd bc 00		    call spi_send_byte  
0218			 
0218			    ; clock out address (depending on address size) 
0218			     
0218 e1			    pop hl 
0219 7c			    ld a,h    ; address out msb first 
021a cd bc 00		    call spi_send_byte  
021d 7d			    ld a,l 
021e cd bc 00		    call spi_send_byte  
0221			 
0221			    ; clock out byte(s) for page 
0221			 
0221 f1			    pop af 
0222 cd bc 00		    call spi_send_byte  
0225			 
0225			    ; end write with ce high 
0225 3a 49 f8		       ld a,(spi_portbyte) 
0228			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0228 cd 87 01			call spi_ce_high 
022b d3 80		       out (storage_adata),a 
022d 32 49 f8		       ld (spi_portbyte), a 
0230			 
0230				; pause for internal write cycle 
0230 3e 0a			ld a, 10 
0232 cd 4e 0a			call aDelayInMS 
0235 c9			    ret 
0236			 
0236			; buffer to write in de 
0236			; address in hl  
0236			se_writepage: 
0236			        
0236			    ;   ld c, a 
0236 d5				push de 
0237 e5			        push hl 
0238			 
0238			    ; initi write mode 
0238			    ; 
0238			    ;CS low 
0238			 
0238 3a 49 f8		       ld a,(spi_portbyte) 
023b cd 98 01			call spi_ce_low 
023e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023e d3 80		       out (storage_adata),a 
0240 32 49 f8		       ld (spi_portbyte), a 
0243			 
0243			    ;clock out wren instruction 
0243			 
0243 3e 06		    ld a, store_wren_ins 
0245 cd bc 00		    call spi_send_byte  
0248			 
0248			    ;cs high to enable write latch 
0248			 
0248 3a 49 f8		       ld a,(spi_portbyte) 
024b cd 87 01			call spi_ce_high 
024e			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024e d3 80		       out (storage_adata),a 
0250 32 49 f8		       ld (spi_portbyte), a 
0253			 
0253 00				nop 
0254			    ; 
0254			    ; intial write data 
0254			    ; 
0254			    ; cs low 
0254			     
0254 3a 49 f8		       ld a,(spi_portbyte) 
0257			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0257 cd 98 01			call spi_ce_low 
025a d3 80		       out (storage_adata),a 
025c 32 49 f8		       ld (spi_portbyte), a 
025f			 
025f			    ; clock out write instruction 
025f			     
025f 3e 02		    ld a, store_write_ins  
0261 cd bc 00		    call spi_send_byte  
0264			 
0264			    ; clock out address (depending on address size) 
0264			     
0264 e1			    pop hl 
0265 7c			    ld a,h    ; address out msb first 
0266 cd bc 00		    call spi_send_byte  
0269 7d			    ld a,l 
026a cd bc 00		    call spi_send_byte  
026d			 
026d			    ; clock out byte(s) for page 
026d			 
026d e1				pop hl 
026e 06 40			ld b, STORE_BLOCK_PHY 
0270			.bytewrite: 
0270			 
0270 7e				ld a,(hl) 
0271 e5			    push hl 
0272 c5				push bc 
0273 cd bc 00		    call spi_send_byte  
0276 c1				pop bc 
0277 e1				pop hl 
0278			 
0278			    ; end write with ce high 
0278 3a 49 f8		       ld a,(spi_portbyte) 
027b cd 87 01			call spi_ce_high 
027e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027e d3 80		       out (storage_adata),a 
0280 32 49 f8		       ld (spi_portbyte), a 
0283			 
0283 23				inc hl 
0284 10 ea			djnz .bytewrite 
0286			 
0286				; pause for internal write cycle 
0286 3e 64			ld a, 100 
0288 cd 4e 0a			call aDelayInMS 
028b c9			    ret 
028c			; returns byte in a 
028c			; address in hl  
028c			se_readbyte: 
028c d5				push de 
028d c5				push bc 
028e			 
028e			    ;   ld c, a 
028e e5			        push hl 
028f			 
028f			    ; initi write mode 
028f			    ; 
028f			    ;CS low 
028f			 
028f 3a 49 f8		       ld a,(spi_portbyte) 
0292 cd 98 01			call spi_ce_low 
0295			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0295 d3 80		       out (storage_adata),a 
0297 32 49 f8		       ld (spi_portbyte), a 
029a			 
029a			    ;clock out wren instruction 
029a			 
029a 3e 03		    ld a, store_read_ins 
029c cd bc 00		    call spi_send_byte  
029f			 
029f			 
029f			    ; clock out address (depending on address size) 
029f			     
029f e1			    pop hl 
02a0 7c			    ld a,h    ; address out msb first 
02a1 cd bc 00		    call spi_send_byte  
02a4 7d			    ld a,l 
02a5 cd bc 00		    call spi_send_byte  
02a8			 
02a8			    ; clock in byte(s) for page 
02a8			 
02a8 cd dd 00		    call spi_read_byte  
02ab f5				push af 
02ac			 
02ac			    ; end write with ce high 
02ac 3a 49 f8		       ld a,(spi_portbyte) 
02af			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02af cd 87 01			call spi_ce_high 
02b2 d3 80		       out (storage_adata),a 
02b4 32 49 f8		       ld (spi_portbyte), a 
02b7			 
02b7 f1				pop af 
02b8			 
02b8 c1				pop bc 
02b9 d1				pop de 
02ba			 
02ba c9			    ret 
02bb			 
02bb			if DEBUG_STORESE 
02bb			 
02bb			storageput:  
02bb			 
02bb			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02bb			 
02bb 21 1f ee			ld hl,scratch+2 
02be cd d7 10			call get_word_hl 
02c1			 
02c1				; stuff it here for the moment as it will be overwritten later anyway 
02c1			 
02c1 22 40 f1			ld (os_cur_ptr),hl	 
02c4			 
02c4			 
02c4			; get pointer to start of string 
02c4			 
02c4 21 24 ee			ld hl, scratch+7 
02c7			 
02c7			; loop writing char of string to eeprom 
02c7			 
02c7 7e			.writestr:	ld a,(hl) 
02c8 fe 00				cp 0 
02ca 28 12				jr z, .wsdone		; done writing 
02cc e5					push hl 
02cd 2a 40 f1				ld hl,(os_cur_ptr) 
02d0 cd ea 01				call se_writebyte 
02d3			 
02d3 2a 40 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d6 23					inc hl 
02d7 22 40 f1				ld (os_cur_ptr),hl 
02da			 
02da					; restore string pointer and get next char 
02da			 
02da e1					pop hl 
02db 23					inc hl 
02dc 18 e9				jr .writestr 
02de			 
02de			 
02de			 
02de			.wsdone: 
02de			 
02de			 
02de			; when done load first page into a buffer  
02de			 
02de 21 00 80				ld hl,08000h		; start in ram 
02e1 22 40 f1				ld (os_cur_ptr),hl 
02e4 21 00 00				ld hl, 0		 ; start of page 
02e7 22 45 ee				ld (scratch+40),hl	; hang on to it 
02ea			 
02ea 06 80				ld b, 128		; actually get more then one page 
02ec c5			.wsload:	push bc 
02ed 2a 45 ee				ld hl,(scratch+40) 
02f0 e5					push hl 
02f1 cd 8c 02				call se_readbyte 
02f4			 
02f4					; a now as the byte 
02f4			 
02f4 2a 40 f1				ld hl,(os_cur_ptr) 
02f7 77					ld (hl),a 
02f8					; inc next buffer area 
02f8 23					inc hl 
02f9 22 40 f1				ld (os_cur_ptr),hl 
02fc			 
02fc					; get eeprom position, inc and save for next round 
02fc e1					pop hl		 
02fd 23					inc hl 
02fe 22 45 ee				ld (scratch+40),hl 
0301 c1					pop bc 
0302 10 e8				djnz .wsload 
0304			 
0304			; set 'd' pointer to start of buffer 
0304			 
0304 21 00 80				ld hl,08000h 
0307 22 40 f1				ld (os_cur_ptr),hl 
030a			 
030a			 
030a c9			ret 
030b			 
030b			 
030b c9			storageread: ret 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			endif 
030c			 
030c			 
030c			 
# End of file firmware_seeprom.asm
030c			else  
030c			   ; create some stubs for the labels  
030c			se_readbyte: ret  
030c			se_writebyte: ret  
030c			storage_init: ret  
030c			  
030c			endif  
030c			  
030c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
030c			;include "firmware_cf.asm"  
030c			  
030c			; load up high level storage hardward abstractions  
030c			include "firmware_storage.asm"  
030c			 
030c			; persisent storage hardware abstraction layer  
030c			 
030c			 
030c			 
030c			; Block 0 on storage is a config state 
030c			 
030c			 
030c			 
030c			; TODO add read phy block and write phy block functions 
030c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
030c			 
030c			; Abstraction layer  
030c			 
030c			; Logocial block size is same size as physical size - using tape concept 
030c			 
030c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
030c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
030c			 
030c			 
030c			 
030c			; Filesystem layout (Logical layout) 
030c			; 
030c			; Block 0 - Bank config  
030c			; 
030c			;      Byte - 0 file id counter 
030c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
030c			;      Byte - 3-20 zero terminated bank label 
030c			; 
030c			; Block 1 > File storage 
030c			; 
030c			;      Byte 0 file id    - block 0 file details 
030c			;      Byte 1 block id - block 0 is file  
030c			;            Byte 2-15 - File name 
030c			; 
030c			;       - to end of block data 
030c			; 
030c			 
030c			 
030c			; Read Block 
030c			; ---------- 
030c			; 
030c			; With current bank 
030c			;  
030c			; Get block number to read 
030c			; Load physical blocks starting at start block into buffer 
030c			 
030c			; de points to buffer to use 
030c			; hl holds logical block number  
030c			 
030c			storage_read_block: 
030c			 
030c				; TODO bank selection 
030c			 
030c				; for each of the physical blocks read it into the buffer 
030c 06 40			ld b, STORE_BLOCK_PHY 
030e			 
030e				if DEBUG_STORESE 
030e d5					push de 
030f				endif 
030f				 
030f			.rl1:    
030f			 
030f				; read physical block at hl into de 
030f			        ; increment hl and de to next read position on exit 
030f			 
030f e5				push hl 
0310 d5				push de	 
0311 c5				push bc 
0312			;	if DEBUG_STORESE 
0312			;		push af 
0312			;		ld a, 'R' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 cd 8c 02			call se_readbyte 
0315			;	if DEBUG_STORESE 
0315			;		ld a,(spi_portbyte) 
0315			;		ld l, a 
0315			;		push af 
0315			;		ld a, '1' 
0315			;		ld (debug_mark),a 
0315			;		pop af 
0315			;		CALLMONITOR 
0315			;	endif 
0315 c1				pop bc 
0316 d1				pop de 
0317 e1				pop hl 
0318 12				ld (de),a 
0319 23				inc hl 
031a 13				inc de 
031b			 
031b			;	if DEBUG_STORESE 
031b			;		push af 
031b			;		ld a, 'r' 
031b			;		ld (debug_mark),a 
031b			;		pop af 
031b			;		CALLMONITOR 
031b			;	endif 
031b			 
031b 10 f2			djnz .rl1 
031d			 
031d				if DEBUG_STORESE 
031d					DMARK "SRB" 
031d f5				push af  
031e 3a 32 03			ld a, (.dmark)  
0321 32 77 fb			ld (debug_mark),a  
0324 3a 33 03			ld a, (.dmark+1)  
0327 32 78 fb			ld (debug_mark+1),a  
032a 3a 34 03			ld a, (.dmark+2)  
032d 32 79 fb			ld (debug_mark+2),a  
0330 18 03			jr .pastdmark  
0332 ..			.dmark: db "SRB"  
0335 f1			.pastdmark: pop af  
0336			endm  
# End of macro DMARK
0336 d1					pop de 
0337			; 
0337			;		push af 
0337			;		ld a, 'R' 
0337			;		ld (debug_mark),a 
0337			;		pop af 
0337					CALLMONITOR 
0337 cd 74 17			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a c9				ret	 
033b				 
033b			 
033b			; File Size 
033b			; --------- 
033b			; 
033b			;   hl file id 
033b			; 
033b			;  returns in hl the number of blocks 
033b			 
033b			storage_file_size: 
033b 5d				ld e, l 
033c 16 00			ld d, 0 
033e 21 40 00			ld hl, STORE_BLOCK_PHY 
0341					if DEBUG_FORTH_WORDS 
0341						DMARK "SIZ" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 77 fb			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 78 fb			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 79 fb			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SIZ"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a						CALLMONITOR 
035a cd 74 17			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d					endif 
035d cd 31 06			call storage_findnextid 
0360			 
0360 cd 49 0d			call ishlzero 
0363			;	ld a, l 
0363			;	add h 
0363			;	cp 0 
0363 c8				ret z			; block not found so EOF 
0364			 
0364 11 62 f8			ld de, store_page 
0367 cd 0c 03			call storage_read_block 
036a			 
036a 3a 64 f8			ld a, (store_page+2)	 ; get extent count 
036d 6f				ld l, a 
036e 26 00			ld h, 0 
0370 c9			 	ret 
0371			 
0371			 
0371			; Write Block 
0371			; ----------- 
0371			; 
0371			; With current bank 
0371			;  
0371			; Get block number to write 
0371			; Write physical blocks starting at start block from buffer 
0371			  
0371			storage_write_block: 
0371				; TODO bank selection 
0371			 
0371				; for each of the physical blocks read it into the buffer 
0371 06 40			ld b, STORE_BLOCK_PHY 
0373			 
0373				if DEBUG_STORESE 
0373					DMARK "SWB" 
0373 f5				push af  
0374 3a 88 03			ld a, (.dmark)  
0377 32 77 fb			ld (debug_mark),a  
037a 3a 89 03			ld a, (.dmark+1)  
037d 32 78 fb			ld (debug_mark+1),a  
0380 3a 8a 03			ld a, (.dmark+2)  
0383 32 79 fb			ld (debug_mark+2),a  
0386 18 03			jr .pastdmark  
0388 ..			.dmark: db "SWB"  
038b f1			.pastdmark: pop af  
038c			endm  
# End of macro DMARK
038c			 
038c					;push af 
038c					;ld a, 'W' 
038c					;ld (debug_mark),a 
038c					;pop af 
038c					CALLMONITOR 
038c cd 74 17			call break_point_state  
038f				endm  
# End of macro CALLMONITOR
038f				endif 
038f			 
038f			; might not be working 
038f			;	call se_writepage 
038f			 
038f			;	ret 
038f			; 
038f			 
038f			 
038f			 
038f			.wl1:    
038f			 
038f				; read physical block at hl into de 
038f			        ; increment hl and de to next read position on exit 
038f			 
038f e5				push hl 
0390 d5				push de	 
0391 c5				push bc 
0392 1a				ld a,(de) 
0393				;if DEBUG_STORESE 
0393			;		push af 
0393			;		ld a, 'W' 
0393			;		ld (debug_mark),a 
0393			;		pop af 
0393			;		CALLMONITOR 
0393			;	endif 
0393 cd ea 01			call se_writebyte 
0396			;	call delay250ms 
0396 00				nop 
0397 00				nop 
0398 00				nop 
0399			;	if DEBUG_STORESE 
0399			;		push af 
0399			;		ld a, 'w' 
0399			;		ld (debug_mark),a 
0399			;		pop af 
0399			;		CALLMONITOR 
0399			;	endif 
0399 c1				pop bc 
039a d1				pop de 
039b e1				pop hl 
039c 23				inc hl 
039d 13				inc de 
039e			 
039e			 
039e 10 ef			djnz .wl1 
03a0			 
03a0				if DEBUG_STORESE 
03a0					DMARK "SW2" 
03a0 f5				push af  
03a1 3a b5 03			ld a, (.dmark)  
03a4 32 77 fb			ld (debug_mark),a  
03a7 3a b6 03			ld a, (.dmark+1)  
03aa 32 78 fb			ld (debug_mark+1),a  
03ad 3a b7 03			ld a, (.dmark+2)  
03b0 32 79 fb			ld (debug_mark+2),a  
03b3 18 03			jr .pastdmark  
03b5 ..			.dmark: db "SW2"  
03b8 f1			.pastdmark: pop af  
03b9			endm  
# End of macro DMARK
03b9			 
03b9					;push af 
03b9					;ld a, 'W' 
03b9					;ld (debug_mark),a 
03b9					;pop af 
03b9					CALLMONITOR 
03b9 cd 74 17			call break_point_state  
03bc				endm  
# End of macro CALLMONITOR
03bc				endif 
03bc c9				ret	 
03bd			 
03bd			; Init bank 
03bd			; --------- 
03bd			; 
03bd			; With current bank 
03bd			; 
03bd			; Setup block 0 config 
03bd			;     Set 0 file id counter 
03bd			;     Set formatted byte pattern 
03bd			;     Zero out bank label 
03bd			;      
03bd			; For every logical block write 0-1 byte as null 
03bd			 
03bd			storage_get_block_0: 
03bd			 
03bd				; TODO check presence 
03bd			 
03bd				; get block 0 config 
03bd			 
03bd 21 00 00			ld hl, 0 
03c0 11 62 f8			ld de, store_page 
03c3 cd 0c 03			call storage_read_block 
03c6			 
03c6				if DEBUG_STORESE 
03c6					DMARK "SB0" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 77 fb			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 78 fb			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 79 fb			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "SB0"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df 11 62 f8				ld de, store_page 
03e2			;		push af 
03e2			;		ld a, 'i' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 74 17			call break_point_state  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5			 
03e5				; is this area formatted? 
03e5			 
03e5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e5 2a 63 f8			ld hl, (store_page+1) 
03e8 3e 80			ld a,0x80 
03ea bd				cp l 
03eb 20 22			jr nz, .ininotformatted 
03ed				; do a double check 
03ed 3e 27			ld a, 0x27 
03ef bc				cp h 
03f0 20 1d			jr nz, .ininotformatted 
03f2			 
03f2				; formatted then 
03f2			 
03f2				if DEBUG_STORESE 
03f2					DMARK "SB1" 
03f2 f5				push af  
03f3 3a 07 04			ld a, (.dmark)  
03f6 32 77 fb			ld (debug_mark),a  
03f9 3a 08 04			ld a, (.dmark+1)  
03fc 32 78 fb			ld (debug_mark+1),a  
03ff 3a 09 04			ld a, (.dmark+2)  
0402 32 79 fb			ld (debug_mark+2),a  
0405 18 03			jr .pastdmark  
0407 ..			.dmark: db "SB1"  
040a f1			.pastdmark: pop af  
040b			endm  
# End of macro DMARK
040b					;push af 
040b					;ld a, 'I' 
040b					;ld (debug_mark),a 
040b					;pop af 
040b					CALLMONITOR 
040b cd 74 17			call break_point_state  
040e				endm  
# End of macro CALLMONITOR
040e				endif 
040e c9				ret 
040f			 
040f			.ininotformatted: 
040f				; bank not formatted so poke various bits to make sure 
040f			 
040f				if DEBUG_STORESE 
040f					DMARK "SB2" 
040f f5				push af  
0410 3a 24 04			ld a, (.dmark)  
0413 32 77 fb			ld (debug_mark),a  
0416 3a 25 04			ld a, (.dmark+1)  
0419 32 78 fb			ld (debug_mark+1),a  
041c 3a 26 04			ld a, (.dmark+2)  
041f 32 79 fb			ld (debug_mark+2),a  
0422 18 03			jr .pastdmark  
0424 ..			.dmark: db "SB2"  
0427 f1			.pastdmark: pop af  
0428			endm  
# End of macro DMARK
0428					;push af 
0428					;ld a, 'f' 
0428					;ld (debug_mark),a 
0428					;pop af 
0428					CALLMONITOR 
0428 cd 74 17			call break_point_state  
042b				endm  
# End of macro CALLMONITOR
042b				endif 
042b			 
042b cd 2c 0a			call storage_clear_page 
042e			 
042e 21 62 f8			ld hl, store_page 
0431 3e 00			ld a, 0 
0433				 
0433 77				ld (hl),a   ; reset file counter 
0434			 
0434 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0437 22 63 f8		 	ld (store_page+1), hl	 
043a			 
043a				; set default label 
043a			 
043a 21 d6 04			ld hl, .defaultbanklabl 
043d 11 65 f8		 	ld de, store_page+3 
0440 01 0f 00			ld bc, 15 
0443 ed b0			ldir 
0445			 
0445				; Append the current bank id 
0445 21 6e f8			ld hl, store_page+3+9 
0448 3a 47 f8			ld a, (spi_device_id) 
044b 77				ld (hl), a 
044c			 
044c				; save default page 0 
044c			 
044c 21 00 00			ld hl, 0 
044f 11 62 f8			ld de, store_page 
0452				if DEBUG_STORESE 
0452					DMARK "SB3" 
0452 f5				push af  
0453 3a 67 04			ld a, (.dmark)  
0456 32 77 fb			ld (debug_mark),a  
0459 3a 68 04			ld a, (.dmark+1)  
045c 32 78 fb			ld (debug_mark+1),a  
045f 3a 69 04			ld a, (.dmark+2)  
0462 32 79 fb			ld (debug_mark+2),a  
0465 18 03			jr .pastdmark  
0467 ..			.dmark: db "SB3"  
046a f1			.pastdmark: pop af  
046b			endm  
# End of macro DMARK
046b			;		push af 
046b			;		ld a, 'F' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b					CALLMONITOR 
046b cd 74 17			call break_point_state  
046e				endm  
# End of macro CALLMONITOR
046e				endif 
046e cd 71 03			call storage_write_block 
0471				if DEBUG_STORESE 
0471					DMARK "SB4" 
0471 f5				push af  
0472 3a 86 04			ld a, (.dmark)  
0475 32 77 fb			ld (debug_mark),a  
0478 3a 87 04			ld a, (.dmark+1)  
047b 32 78 fb			ld (debug_mark+1),a  
047e 3a 88 04			ld a, (.dmark+2)  
0481 32 79 fb			ld (debug_mark+2),a  
0484 18 03			jr .pastdmark  
0486 ..			.dmark: db "SB4"  
0489 f1			.pastdmark: pop af  
048a			endm  
# End of macro DMARK
048a			;		push af 
048a			;		ld a, '>' 
048a			;		ld (debug_mark),a 
048a			;		pop af 
048a					CALLMONITOR 
048a cd 74 17			call break_point_state  
048d				endm  
# End of macro CALLMONITOR
048d				endif 
048d			 
048d 00				nop 
048e 00				nop 
048f 00				nop 
0490			 
0490				; now set 0 in every page to mark as a free block 
0490			 
0490 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0492 21 40 00			ld hl, STORE_BLOCK_PHY 
0495			 
0495 3e 00		.setmark1:   	ld a,0 
0497 e5					push hl 
0498 c5					push bc 
0499 cd ea 01				call se_writebyte 
049c 3e 0a			ld a, 10 
049e cd 4e 0a			call aDelayInMS 
04a1 23				inc hl 
04a2 cd ea 01				call se_writebyte 
04a5 3e 0a			ld a, 10 
04a7 cd 4e 0a			call aDelayInMS 
04aa 2b				dec hl 
04ab c1					pop bc 
04ac e1					pop hl 
04ad 3e 40				ld a, STORE_BLOCK_PHY 
04af cd 20 0d				call addatohl 
04b2 10 e1				djnz .setmark1 
04b4			 
04b4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b6 3e 00		.setmark2:   	ld a,0 
04b8 e5					push hl 
04b9 c5					push bc 
04ba cd ea 01				call se_writebyte 
04bd 3e 0a			ld a, 10 
04bf cd 4e 0a			call aDelayInMS 
04c2 23				inc hl 
04c3 cd ea 01				call se_writebyte 
04c6 3e 0a			ld a, 10 
04c8 cd 4e 0a			call aDelayInMS 
04cb 2b				dec hl 
04cc c1					pop bc 
04cd e1					pop hl 
04ce 3e 40				ld a, STORE_BLOCK_PHY 
04d0 cd 20 0d				call addatohl 
04d3 10 e1				djnz .setmark2 
04d5			 
04d5					 
04d5			 
04d5			 
04d5 c9				ret 
04d6			 
04d6			 
04d6			 
04d6			 
04d6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04e1			 
04e1			 
04e1			 
04e1			; Label Bank 
04e1			; ---------- 
04e1			; 
04e1			; With current bank 
04e1			; Read block 0 
04e1			; Set label 
04e1			; Write block 0 
04e1			 
04e1			; label str pointer in hl 
04e1			 
04e1			storage_label:     
04e1			 
04e1				if DEBUG_STORESE 
04e1					DMARK "LBL" 
04e1 f5				push af  
04e2 3a f6 04			ld a, (.dmark)  
04e5 32 77 fb			ld (debug_mark),a  
04e8 3a f7 04			ld a, (.dmark+1)  
04eb 32 78 fb			ld (debug_mark+1),a  
04ee 3a f8 04			ld a, (.dmark+2)  
04f1 32 79 fb			ld (debug_mark+2),a  
04f4 18 03			jr .pastdmark  
04f6 ..			.dmark: db "LBL"  
04f9 f1			.pastdmark: pop af  
04fa			endm  
# End of macro DMARK
04fa					CALLMONITOR 
04fa cd 74 17			call break_point_state  
04fd				endm  
# End of macro CALLMONITOR
04fd				endif 
04fd			 
04fd e5				push hl 
04fe			 
04fe cd bd 03			call storage_get_block_0 
0501			 
0501				; set default label 
0501			 
0501 e1				pop hl 
0502			 
0502 11 65 f8		 	ld de, store_page+3 
0505 01 0f 00			ld bc, 15 
0508				if DEBUG_STORESE 
0508					DMARK "LB3" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 77 fb			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 78 fb			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 79 fb			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "LB3"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521					CALLMONITOR 
0521 cd 74 17			call break_point_state  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 ed b0			ldir 
0526				; save default page 0 
0526			 
0526 21 00 00			ld hl, 0 
0529 11 62 f8			ld de, store_page 
052c				if DEBUG_STORESE 
052c					DMARK "LBW" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 77 fb			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 78 fb			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 79 fb			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "LBW"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545					CALLMONITOR 
0545 cd 74 17			call break_point_state  
0548				endm  
# End of macro CALLMONITOR
0548				endif 
0548 cd 71 03			call storage_write_block 
054b			 
054b c9				ret 
054c			 
054c			 
054c			 
054c			; Read Block 0 - Config 
054c			; --------------------- 
054c			; 
054c			; With current bank 
054c			; Call presence test 
054c			;    If not present format/init bank  
054c			; Read block 0  
054c			;  
054c			 
054c			 
054c			; Dir 
054c			; --- 
054c			; 
054c			; With current bank 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block read byte 2 
054c			;      if first block of file 
054c			;         Display file name 
054c			;         Display type flags for file 
054c			;        
054c			 
054c			; moving to words as this requires stack control 
054c			 
054c			 
054c			; Delete File 
054c			; ----------- 
054c			; 
054c			; With current bank 
054c			; 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block file id 
054c			;      If first block of file and dont have file id 
054c			;         if file to delete 
054c			;         Save file id 
054c			;         Null file id 
054c			;         Write this block back 
054c			;      If file id is one saved 
054c			;         Null file id 
054c			;         Write this block back 
054c			 
054c			storage_erase: 
054c			 
054c				; hl contains the file id 
054c			 
054c 5d				ld e, l 
054d 16 00			ld d, 0 
054f 21 40 00			ld hl, STORE_BLOCK_PHY 
0552					if DEBUG_FORTH_WORDS 
0552						DMARK "ERA" 
0552 f5				push af  
0553 3a 67 05			ld a, (.dmark)  
0556 32 77 fb			ld (debug_mark),a  
0559 3a 68 05			ld a, (.dmark+1)  
055c 32 78 fb			ld (debug_mark+1),a  
055f 3a 69 05			ld a, (.dmark+2)  
0562 32 79 fb			ld (debug_mark+2),a  
0565 18 03			jr .pastdmark  
0567 ..			.dmark: db "ERA"  
056a f1			.pastdmark: pop af  
056b			endm  
# End of macro DMARK
056b						CALLMONITOR 
056b cd 74 17			call break_point_state  
056e				endm  
# End of macro CALLMONITOR
056e					endif 
056e cd 31 06			call storage_findnextid 
0571 cd 49 0d			call ishlzero 
0574 c8				ret z 
0575			 
0575 e5				push hl 
0576			 
0576				; TODO check file not found 
0576			 
0576 11 62 f8			ld de, store_page 
0579 cd 0c 03			call storage_read_block 
057c			 
057c					if DEBUG_FORTH_WORDS 
057c						DMARK "ER1" 
057c f5				push af  
057d 3a 91 05			ld a, (.dmark)  
0580 32 77 fb			ld (debug_mark),a  
0583 3a 92 05			ld a, (.dmark+1)  
0586 32 78 fb			ld (debug_mark+1),a  
0589 3a 93 05			ld a, (.dmark+2)  
058c 32 79 fb			ld (debug_mark+2),a  
058f 18 03			jr .pastdmark  
0591 ..			.dmark: db "ER1"  
0594 f1			.pastdmark: pop af  
0595			endm  
# End of macro DMARK
0595						CALLMONITOR 
0595 cd 74 17			call break_point_state  
0598				endm  
# End of macro CALLMONITOR
0598					endif 
0598 3a 62 f8			ld a, (store_page)	; get file id 
059b 32 5b f8			ld (store_tmpid), a 
059e			 
059e 3a 64 f8			ld a, (store_page+2)    ; get count of extends 
05a1 32 5a f8			ld (store_tmpext), a 
05a4			 
05a4				; wipe file header 
05a4			 
05a4 e1				pop hl 
05a5 3e 00			ld a, 0 
05a7 32 62 f8			ld (store_page), a 
05aa 32 63 f8			ld (store_page+1),a 
05ad 11 62 f8			ld de, store_page 
05b0					if DEBUG_FORTH_WORDS 
05b0						DMARK "ER2" 
05b0 f5				push af  
05b1 3a c5 05			ld a, (.dmark)  
05b4 32 77 fb			ld (debug_mark),a  
05b7 3a c6 05			ld a, (.dmark+1)  
05ba 32 78 fb			ld (debug_mark+1),a  
05bd 3a c7 05			ld a, (.dmark+2)  
05c0 32 79 fb			ld (debug_mark+2),a  
05c3 18 03			jr .pastdmark  
05c5 ..			.dmark: db "ER2"  
05c8 f1			.pastdmark: pop af  
05c9			endm  
# End of macro DMARK
05c9						CALLMONITOR 
05c9 cd 74 17			call break_point_state  
05cc				endm  
# End of macro CALLMONITOR
05cc					endif 
05cc cd 71 03			call storage_write_block 
05cf			 
05cf			 
05cf				; wipe file extents 
05cf			 
05cf 3a 5a f8			ld a, (store_tmpext) 
05d2 47				ld b, a 
05d3			 
05d3			.eraext:	  
05d3 c5				push bc 
05d4			 
05d4 21 40 00			ld hl, STORE_BLOCK_PHY 
05d7 3a 5b f8			ld a,(store_tmpid) 
05da 5f				ld e, a 
05db 50				ld d, b	 
05dc					if DEBUG_FORTH_WORDS 
05dc						DMARK "ER3" 
05dc f5				push af  
05dd 3a f1 05			ld a, (.dmark)  
05e0 32 77 fb			ld (debug_mark),a  
05e3 3a f2 05			ld a, (.dmark+1)  
05e6 32 78 fb			ld (debug_mark+1),a  
05e9 3a f3 05			ld a, (.dmark+2)  
05ec 32 79 fb			ld (debug_mark+2),a  
05ef 18 03			jr .pastdmark  
05f1 ..			.dmark: db "ER3"  
05f4 f1			.pastdmark: pop af  
05f5			endm  
# End of macro DMARK
05f5						CALLMONITOR 
05f5 cd 74 17			call break_point_state  
05f8				endm  
# End of macro CALLMONITOR
05f8					endif 
05f8 cd 31 06			call storage_findnextid 
05fb			 
05fb e5				push hl 
05fc 11 62 f8			ld de, store_page 
05ff cd 0c 03			call storage_read_block 
0602			 
0602				; free block	 
0602			 
0602 3e 00			ld a, 0 
0604 32 62 f8			ld (store_page), a 
0607 32 63 f8			ld (store_page+1),a 
060a 11 62 f8			ld de, store_page 
060d e1				pop hl 
060e					if DEBUG_FORTH_WORDS 
060e						DMARK "ER4" 
060e f5				push af  
060f 3a 23 06			ld a, (.dmark)  
0612 32 77 fb			ld (debug_mark),a  
0615 3a 24 06			ld a, (.dmark+1)  
0618 32 78 fb			ld (debug_mark+1),a  
061b 3a 25 06			ld a, (.dmark+2)  
061e 32 79 fb			ld (debug_mark+2),a  
0621 18 03			jr .pastdmark  
0623 ..			.dmark: db "ER4"  
0626 f1			.pastdmark: pop af  
0627			endm  
# End of macro DMARK
0627						CALLMONITOR 
0627 cd 74 17			call break_point_state  
062a				endm  
# End of macro CALLMONITOR
062a					endif 
062a cd 71 03			call storage_write_block 
062d			 
062d c1				pop bc 
062e 10 a3			djnz .eraext 
0630			 
0630 c9				ret 
0631			 
0631			 
0631			; Find Free Block 
0631			; --------------- 
0631			; 
0631			; With current bank 
0631			;  
0631			; From given starting logical block 
0631			;    Read block  
0631			;    If no file id 
0631			;         Return block id 
0631			 
0631			 
0631			; hl starting page number 
0631			; hl contains free page number or zero if no pages free 
0631			; e contains the file id to locate 
0631			; d contains the block number 
0631			 
0631			; TODO change to find file id and use zero for free block 
0631			 
0631			storage_findnextid: 
0631			 
0631				; now locate first 0 page to mark as a free block 
0631			 
0631 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0633			;	ld hl, STORE_BLOCK_PHY 
0633			 
0633					if DEBUG_FORTH_WORDS 
0633					DMARK "FNI" 
0633 f5				push af  
0634 3a 48 06			ld a, (.dmark)  
0637 32 77 fb			ld (debug_mark),a  
063a 3a 49 06			ld a, (.dmark+1)  
063d 32 78 fb			ld (debug_mark+1),a  
0640 3a 4a 06			ld a, (.dmark+2)  
0643 32 79 fb			ld (debug_mark+2),a  
0646 18 03			jr .pastdmark  
0648 ..			.dmark: db "FNI"  
064b f1			.pastdmark: pop af  
064c			endm  
# End of macro DMARK
064c						CALLMONITOR 
064c cd 74 17			call break_point_state  
064f				endm  
# End of macro CALLMONITOR
064f					endif 
064f			.ff1:   	 
064f e5					push hl 
0650 c5					push bc 
0651 d5					push de 
0652 cd 8c 02				call se_readbyte 
0655 5f					ld e,a 
0656 23					inc hl 
0657 cd 8c 02				call se_readbyte 
065a 57					ld d, a 
065b e1					pop hl 
065c e5					push hl 
065d cd 3e 0d				call cmp16 
0660 28 49				jr z, .fffound 
0662			 
0662 d1					pop de 
0663 c1					pop bc 
0664 e1					pop hl 
0665			 
0665					; is found? 
0665					;cp e 
0665					;ret z 
0665			 
0665 3e 40				ld a, STORE_BLOCK_PHY 
0667 cd 20 0d				call addatohl 
066a 10 e3				djnz .ff1 
066c			 
066c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
066e			.ff2:   	 
066e			 
066e e5					push hl 
066f c5					push bc 
0670 d5					push de 
0671 cd 8c 02				call se_readbyte 
0674 5f					ld e,a 
0675 23					inc hl 
0676 cd 8c 02				call se_readbyte 
0679 57					ld d, a 
067a			 
067a e1					pop hl 
067b e5					push hl 
067c cd 3e 0d				call cmp16 
067f 28 2a				jr z, .fffound 
0681			 
0681 d1					pop de 
0682 c1					pop bc 
0683 e1					pop hl 
0684					; is found? 
0684					;cp e 
0684					;ret z 
0684			 
0684 3e 40				ld a, STORE_BLOCK_PHY 
0686 cd 20 0d				call addatohl 
0689 10 e3				djnz .ff2 
068b			 
068b			 
068b					if DEBUG_FORTH_WORDS 
068b					DMARK "FN-" 
068b f5				push af  
068c 3a a0 06			ld a, (.dmark)  
068f 32 77 fb			ld (debug_mark),a  
0692 3a a1 06			ld a, (.dmark+1)  
0695 32 78 fb			ld (debug_mark+1),a  
0698 3a a2 06			ld a, (.dmark+2)  
069b 32 79 fb			ld (debug_mark+2),a  
069e 18 03			jr .pastdmark  
06a0 ..			.dmark: db "FN-"  
06a3 f1			.pastdmark: pop af  
06a4			endm  
# End of macro DMARK
06a4					;	push af 
06a4					;	ld a, 'n' 
06a4					;	ld (debug_mark),a 
06a4					;	pop af 
06a4						CALLMONITOR 
06a4 cd 74 17			call break_point_state  
06a7				endm  
# End of macro CALLMONITOR
06a7					endif 
06a7				; no free marks! 
06a7 21 00 00				ld hl, 0 
06aa c9				ret 
06ab			.fffound: 
06ab				 
06ab			 
06ab d1					pop de 
06ac c1					pop bc 
06ad e1					pop hl 
06ae					if DEBUG_FORTH_WORDS 
06ae					DMARK "FNF" 
06ae f5				push af  
06af 3a c3 06			ld a, (.dmark)  
06b2 32 77 fb			ld (debug_mark),a  
06b5 3a c4 06			ld a, (.dmark+1)  
06b8 32 78 fb			ld (debug_mark+1),a  
06bb 3a c5 06			ld a, (.dmark+2)  
06be 32 79 fb			ld (debug_mark+2),a  
06c1 18 03			jr .pastdmark  
06c3 ..			.dmark: db "FNF"  
06c6 f1			.pastdmark: pop af  
06c7			endm  
# End of macro DMARK
06c7					;	push af 
06c7					;	ld a, 'n' 
06c7					;	ld (debug_mark),a 
06c7					;	pop af 
06c7						CALLMONITOR 
06c7 cd 74 17			call break_point_state  
06ca				endm  
# End of macro CALLMONITOR
06ca					endif 
06ca c9				ret 
06cb			 
06cb			 
06cb			 
06cb			; Free Space 
06cb			; ---------- 
06cb			; 
06cb			; With current bank 
06cb			; 
06cb			; Set block count to zero 
06cb			; Starting with first logical block 
06cb			;      Find free block  
06cb			;      If block id given, increment block count 
06cb			; 
06cb			;  
06cb			 
06cb			 
06cb			; hl contains count of free blocks 
06cb			 
06cb			storage_freeblocks: 
06cb			 
06cb				; now locate first 0 page to mark as a free block 
06cb			 
06cb 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06cd 21 40 00			ld hl, STORE_BLOCK_PHY 
06d0 11 00 00			ld de, 0 
06d3			 
06d3			.fb1:   	 
06d3 e5					push hl 
06d4 c5					push bc 
06d5 d5					push de 
06d6 cd 8c 02				call se_readbyte 
06d9 d1					pop de 
06da c1					pop bc 
06db e1					pop hl 
06dc			 
06dc					; is free? 
06dc fe 00				cp 0 
06de 20 01				jr nz, .ff1cont 
06e0 13					inc de 
06e1			 
06e1			.ff1cont: 
06e1			 
06e1			 
06e1 3e 40				ld a, STORE_BLOCK_PHY 
06e3 cd 20 0d				call addatohl 
06e6 10 eb				djnz .fb1 
06e8			 
06e8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06ea			.fb2:   	 
06ea e5					push hl 
06eb c5					push bc 
06ec d5					push de 
06ed cd 8c 02				call se_readbyte 
06f0 d1					pop de 
06f1 c1					pop bc 
06f2 e1					pop hl 
06f3			 
06f3					; is free? 
06f3 fe 00				cp 0 
06f5 20 01				jr nz, .ff2cont 
06f7 13					inc de 
06f8			 
06f8			.ff2cont: 
06f8			 
06f8 3e 40				ld a, STORE_BLOCK_PHY 
06fa cd 20 0d				call addatohl 
06fd 10 eb				djnz .fb2 
06ff			 
06ff eb				ex de, hl 
0700 c9				ret 
0701			 
0701			; Get File ID 
0701			; ----------- 
0701			; 
0701			; With current bank 
0701			;  
0701			; Load Block 0 Config 
0701			; Get max file id number 
0701			; For each logical block 
0701			;    Read block file id 
0701			;      If first block of file and dont have file id 
0701			;         if file get id and exit 
0701			 
0701			 
0701			 
0701			 
0701			; Create File 
0701			; ----------- 
0701			; 
0701			; With current bank  
0701			; Load Block 0 Config 
0701			; Get max file id number 
0701			; Increment file id number 
0701			; Save Config 
0701			; Find free block 
0701			; Set buffer with file name and file id 
0701			; Write buffer to free block  
0701			 
0701			 
0701			; hl point to file name 
0701			; hl returns file id 
0701			 
0701			; file format: 
0701			; byte 0 - file id 
0701			; byte 1 - extent number 
0701			; byte 2-> data 
0701			 
0701			; format for extent number 0: 
0701			; 
0701			; byte 0 - file id 
0701			; byte 1 - extent 0 
0701			; byte 2 - extent count 
0701			; byte 3 -> file name and meta data 
0701			 
0701			 
0701			storage_create: 
0701				if DEBUG_STORESE 
0701					DMARK "SCR" 
0701 f5				push af  
0702 3a 16 07			ld a, (.dmark)  
0705 32 77 fb			ld (debug_mark),a  
0708 3a 17 07			ld a, (.dmark+1)  
070b 32 78 fb			ld (debug_mark+1),a  
070e 3a 18 07			ld a, (.dmark+2)  
0711 32 79 fb			ld (debug_mark+2),a  
0714 18 03			jr .pastdmark  
0716 ..			.dmark: db "SCR"  
0719 f1			.pastdmark: pop af  
071a			endm  
# End of macro DMARK
071a					CALLMONITOR 
071a cd 74 17			call break_point_state  
071d				endm  
# End of macro CALLMONITOR
071d				endif 
071d			 
071d e5				push hl		; save file name pointer 
071e			 
071e cd bd 03			call storage_get_block_0 
0721			 
0721 3a 62 f8			ld a,(store_page)	; get current file id 
0724 3c				inc a 
0725 32 62 f8			ld (store_page),a 
0728				 
0728 32 5b f8			ld (store_tmpid),a			; save id 
072b			 
072b 21 00 00			ld hl, 0 
072e 11 62 f8			ld de, store_page 
0731				if DEBUG_STORESE 
0731					DMARK "SCw" 
0731 f5				push af  
0732 3a 46 07			ld a, (.dmark)  
0735 32 77 fb			ld (debug_mark),a  
0738 3a 47 07			ld a, (.dmark+1)  
073b 32 78 fb			ld (debug_mark+1),a  
073e 3a 48 07			ld a, (.dmark+2)  
0741 32 79 fb			ld (debug_mark+2),a  
0744 18 03			jr .pastdmark  
0746 ..			.dmark: db "SCw"  
0749 f1			.pastdmark: pop af  
074a			endm  
# End of macro DMARK
074a					CALLMONITOR 
074a cd 74 17			call break_point_state  
074d				endm  
# End of macro CALLMONITOR
074d				endif 
074d cd 71 03			call storage_write_block	 ; save update 
0750			 
0750				if DEBUG_STORESE 
0750 11 62 f8				ld de, store_page 
0753					DMARK "SCC" 
0753 f5				push af  
0754 3a 68 07			ld a, (.dmark)  
0757 32 77 fb			ld (debug_mark),a  
075a 3a 69 07			ld a, (.dmark+1)  
075d 32 78 fb			ld (debug_mark+1),a  
0760 3a 6a 07			ld a, (.dmark+2)  
0763 32 79 fb			ld (debug_mark+2),a  
0766 18 03			jr .pastdmark  
0768 ..			.dmark: db "SCC"  
076b f1			.pastdmark: pop af  
076c			endm  
# End of macro DMARK
076c					CALLMONITOR 
076c cd 74 17			call break_point_state  
076f				endm  
# End of macro CALLMONITOR
076f				endif 
076f				;  
076f				 
076f 21 40 00			ld hl, STORE_BLOCK_PHY 
0772 11 00 00			ld de, 0 
0775 cd 31 06			call storage_findnextid 
0778			 
0778 22 4c f8			ld (store_tmppageid), hl    ; save page to use  
077b			 
077b				; TODO detect 0 = no spare blocks 
077b			 
077b				; hl now contains the free page to use for the file header page 
077b			 
077b				if DEBUG_STORESE 
077b				DMARK "SCF" 
077b f5				push af  
077c 3a 90 07			ld a, (.dmark)  
077f 32 77 fb			ld (debug_mark),a  
0782 3a 91 07			ld a, (.dmark+1)  
0785 32 78 fb			ld (debug_mark+1),a  
0788 3a 92 07			ld a, (.dmark+2)  
078b 32 79 fb			ld (debug_mark+2),a  
078e 18 03			jr .pastdmark  
0790 ..			.dmark: db "SCF"  
0793 f1			.pastdmark: pop af  
0794			endm  
# End of macro DMARK
0794					CALLMONITOR 
0794 cd 74 17			call break_point_state  
0797				endm  
# End of macro CALLMONITOR
0797				endif 
0797			 
0797 22 4c f8			ld (store_tmppageid), hl 
079a				 
079a 3a 5b f8			ld a,(store_tmpid)    ; get file id 
079d			;	ld a, (store_filecache)			; save to cache 
079d			 
079d 32 62 f8			ld (store_page),a    ; set page id 
07a0 3e 00			ld a, 0			 ; extent 0 is file header 
07a2 32 63 f8			ld (store_page+1), a   ; set file extent 
07a5			 
07a5 32 64 f8			ld (store_page+2), a   ; extent count for the file 
07a8			 
07a8			;	inc hl 		; init block 0 of file 
07a8			;	inc hl   		; skip file and extent id 
07a8			 ;       ld a, 0 
07a8			;	ld (hl),a 
07a8			;	ld a, (store_filecache+1)  	; save to cache 
07a8			 
07a8			;	inc hl    ; file name 
07a8				 
07a8				 
07a8 11 65 f8			ld de, store_page+3    ; get buffer for term string to use as file name 
07ab				if DEBUG_STORESE 
07ab					DMARK "SCc" 
07ab f5				push af  
07ac 3a c0 07			ld a, (.dmark)  
07af 32 77 fb			ld (debug_mark),a  
07b2 3a c1 07			ld a, (.dmark+1)  
07b5 32 78 fb			ld (debug_mark+1),a  
07b8 3a c2 07			ld a, (.dmark+2)  
07bb 32 79 fb			ld (debug_mark+2),a  
07be 18 03			jr .pastdmark  
07c0 ..			.dmark: db "SCc"  
07c3 f1			.pastdmark: pop af  
07c4			endm  
# End of macro DMARK
07c4					CALLMONITOR 
07c4 cd 74 17			call break_point_state  
07c7				endm  
# End of macro CALLMONITOR
07c7				endif 
07c7 e1				pop hl    ; get zero term string 
07c8 e5				push hl 
07c9 3e 00			ld a, 0 
07cb cd 89 11			call strlent 
07ce 23				inc hl   ; cover zero term 
07cf 06 00			ld b,0 
07d1 4d				ld c,l 
07d2 e1				pop hl 
07d3				;ex de, hl 
07d3				if DEBUG_STORESE 
07d3					DMARK "SCa" 
07d3 f5				push af  
07d4 3a e8 07			ld a, (.dmark)  
07d7 32 77 fb			ld (debug_mark),a  
07da 3a e9 07			ld a, (.dmark+1)  
07dd 32 78 fb			ld (debug_mark+1),a  
07e0 3a ea 07			ld a, (.dmark+2)  
07e3 32 79 fb			ld (debug_mark+2),a  
07e6 18 03			jr .pastdmark  
07e8 ..			.dmark: db "SCa"  
07eb f1			.pastdmark: pop af  
07ec			endm  
# End of macro DMARK
07ec					;push af 
07ec					;ld a, 'a' 
07ec					;ld (debug_mark),a 
07ec					;pop af 
07ec					CALLMONITOR 
07ec cd 74 17			call break_point_state  
07ef				endm  
# End of macro CALLMONITOR
07ef				endif 
07ef ed b0			ldir    ; copy zero term string 
07f1				if DEBUG_STORESE 
07f1					DMARK "SCA" 
07f1 f5				push af  
07f2 3a 06 08			ld a, (.dmark)  
07f5 32 77 fb			ld (debug_mark),a  
07f8 3a 07 08			ld a, (.dmark+1)  
07fb 32 78 fb			ld (debug_mark+1),a  
07fe 3a 08 08			ld a, (.dmark+2)  
0801 32 79 fb			ld (debug_mark+2),a  
0804 18 03			jr .pastdmark  
0806 ..			.dmark: db "SCA"  
0809 f1			.pastdmark: pop af  
080a			endm  
# End of macro DMARK
080a					CALLMONITOR 
080a cd 74 17			call break_point_state  
080d				endm  
# End of macro CALLMONITOR
080d				endif 
080d			 
080d				; write file header page 
080d			 
080d 2a 4c f8			ld hl,(store_tmppageid) 
0810 11 62 f8			ld de, store_page 
0813				if DEBUG_STORESE 
0813					DMARK "SCb" 
0813 f5				push af  
0814 3a 28 08			ld a, (.dmark)  
0817 32 77 fb			ld (debug_mark),a  
081a 3a 29 08			ld a, (.dmark+1)  
081d 32 78 fb			ld (debug_mark+1),a  
0820 3a 2a 08			ld a, (.dmark+2)  
0823 32 79 fb			ld (debug_mark+2),a  
0826 18 03			jr .pastdmark  
0828 ..			.dmark: db "SCb"  
082b f1			.pastdmark: pop af  
082c			endm  
# End of macro DMARK
082c					;push af 
082c					;ld a, 'b' 
082c					;ld (debug_mark),a 
082c					;pop af 
082c					CALLMONITOR 
082c cd 74 17			call break_point_state  
082f				endm  
# End of macro CALLMONITOR
082f				endif 
082f cd 71 03			call storage_write_block 
0832			 
0832 3a 5b f8			ld a, (store_tmpid) 
0835 6f				ld l, a 
0836 26 00			ld h,0 
0838				if DEBUG_STORESE 
0838					DMARK "SCz" 
0838 f5				push af  
0839 3a 4d 08			ld a, (.dmark)  
083c 32 77 fb			ld (debug_mark),a  
083f 3a 4e 08			ld a, (.dmark+1)  
0842 32 78 fb			ld (debug_mark+1),a  
0845 3a 4f 08			ld a, (.dmark+2)  
0848 32 79 fb			ld (debug_mark+2),a  
084b 18 03			jr .pastdmark  
084d ..			.dmark: db "SCz"  
0850 f1			.pastdmark: pop af  
0851			endm  
# End of macro DMARK
0851					CALLMONITOR 
0851 cd 74 17			call break_point_state  
0854				endm  
# End of macro CALLMONITOR
0854				endif 
0854 c9				ret 
0855				 
0855			 
0855			 
0855			; 
0855			; Read File 
0855			; 
0855			; h - file id to locate 
0855			; l - extent to locate 
0855			; de - pointer to string to read into 
0855			; 
0855			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0855			 
0855			.sr_fail: 
0855 d1				pop de 
0856 c9				ret 
0857			 
0857			storage_read: 
0857 d5				push de 
0858			 
0858			; TODO BUG the above push is it popped before the RET Z? 
0858			 
0858			; TODO how to handle multiple part blocks 
0858			 
0858				; locate file extent to read 
0858			 
0858 5c				ld e, h 
0859 55				ld d, l 
085a 21 40 00			ld hl, STORE_BLOCK_PHY 
085d				if DEBUG_STORESE 
085d					DMARK "SRE" 
085d f5				push af  
085e 3a 72 08			ld a, (.dmark)  
0861 32 77 fb			ld (debug_mark),a  
0864 3a 73 08			ld a, (.dmark+1)  
0867 32 78 fb			ld (debug_mark+1),a  
086a 3a 74 08			ld a, (.dmark+2)  
086d 32 79 fb			ld (debug_mark+2),a  
0870 18 03			jr .pastdmark  
0872 ..			.dmark: db "SRE"  
0875 f1			.pastdmark: pop af  
0876			endm  
# End of macro DMARK
0876					CALLMONITOR 
0876 cd 74 17			call break_point_state  
0879				endm  
# End of macro CALLMONITOR
0879				endif 
0879 cd 31 06			call storage_findnextid 
087c			 
087c				if DEBUG_STORESE 
087c					DMARK "SRf" 
087c f5				push af  
087d 3a 91 08			ld a, (.dmark)  
0880 32 77 fb			ld (debug_mark),a  
0883 3a 92 08			ld a, (.dmark+1)  
0886 32 78 fb			ld (debug_mark+1),a  
0889 3a 93 08			ld a, (.dmark+2)  
088c 32 79 fb			ld (debug_mark+2),a  
088f 18 03			jr .pastdmark  
0891 ..			.dmark: db "SRf"  
0894 f1			.pastdmark: pop af  
0895			endm  
# End of macro DMARK
0895					CALLMONITOR 
0895 cd 74 17			call break_point_state  
0898				endm  
# End of macro CALLMONITOR
0898				endif 
0898 cd 49 0d			call ishlzero 
089b			;	ld a, l 
089b			;	add h 
089b			;	cp 0 
089b 28 b8			jr z,.sr_fail			; block not found so EOF 
089d			 
089d				; hl contains page number to load 
089d d1				pop de   ; get storage 
089e d5				push de 
089f				if DEBUG_STORESE 
089f					DMARK "SRg" 
089f f5				push af  
08a0 3a b4 08			ld a, (.dmark)  
08a3 32 77 fb			ld (debug_mark),a  
08a6 3a b5 08			ld a, (.dmark+1)  
08a9 32 78 fb			ld (debug_mark+1),a  
08ac 3a b6 08			ld a, (.dmark+2)  
08af 32 79 fb			ld (debug_mark+2),a  
08b2 18 03			jr .pastdmark  
08b4 ..			.dmark: db "SRg"  
08b7 f1			.pastdmark: pop af  
08b8			endm  
# End of macro DMARK
08b8					CALLMONITOR 
08b8 cd 74 17			call break_point_state  
08bb				endm  
# End of macro CALLMONITOR
08bb				endif 
08bb cd 0c 03			call storage_read_block 
08be			 
08be			 
08be			; TODO if block has no zeros then need to read next block  
08be			 
08be			 
08be					 
08be e1				pop hl 		 ; return start of data to show as not EOF 
08bf 23				inc hl   ; past file id 
08c0 23				inc hl   ; past ext 
08c1				if DEBUG_STORESE 
08c1					DMARK "SRe" 
08c1 f5				push af  
08c2 3a d6 08			ld a, (.dmark)  
08c5 32 77 fb			ld (debug_mark),a  
08c8 3a d7 08			ld a, (.dmark+1)  
08cb 32 78 fb			ld (debug_mark+1),a  
08ce 3a d8 08			ld a, (.dmark+2)  
08d1 32 79 fb			ld (debug_mark+2),a  
08d4 18 03			jr .pastdmark  
08d6 ..			.dmark: db "SRe"  
08d9 f1			.pastdmark: pop af  
08da			endm  
# End of macro DMARK
08da					CALLMONITOR 
08da cd 74 17			call break_point_state  
08dd				endm  
# End of macro CALLMONITOR
08dd				endif 
08dd c9					ret 
08de			 
08de			 
08de			 
08de			; 
08de			; Append File 
08de			; 
08de			; hl - file id to locate 
08de			; de - pointer to (multi block) string to write 
08de			 
08de			.sa_notfound: 
08de d1				pop de 
08df c9				ret 
08e0			 
08e0			 
08e0			storage_append: 
08e0				; hl -  file id to append to 
08e0				; de - string to append 
08e0			 
08e0 d5				push de 
08e1				 
08e1				if DEBUG_STORESE 
08e1					DMARK "AP1" 
08e1 f5				push af  
08e2 3a f6 08			ld a, (.dmark)  
08e5 32 77 fb			ld (debug_mark),a  
08e8 3a f7 08			ld a, (.dmark+1)  
08eb 32 78 fb			ld (debug_mark+1),a  
08ee 3a f8 08			ld a, (.dmark+2)  
08f1 32 79 fb			ld (debug_mark+2),a  
08f4 18 03			jr .pastdmark  
08f6 ..			.dmark: db "AP1"  
08f9 f1			.pastdmark: pop af  
08fa			endm  
# End of macro DMARK
08fa					CALLMONITOR 
08fa cd 74 17			call break_point_state  
08fd				endm  
# End of macro CALLMONITOR
08fd				endif 
08fd			 
08fd 7d				ld a, l 
08fe 32 5b f8			ld (store_tmpid), a 
0901			 
0901				; get file header  
0901			 
0901 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0903 3a 5b f8			ld a, (store_tmpid) 
0906 5f				ld e, a 
0907			 
0907 21 40 00				ld hl, STORE_BLOCK_PHY 
090a cd 31 06				call storage_findnextid 
090d			 
090d cd 49 0d			call ishlzero 
0910 28 cc			jr z, .sa_notfound 
0912			 
0912 22 4c f8			ld (store_tmppageid), hl 
0915			 
0915				; TODO handle file id not found 
0915			 
0915				if DEBUG_STORESE 
0915					DMARK "AP2" 
0915 f5				push af  
0916 3a 2a 09			ld a, (.dmark)  
0919 32 77 fb			ld (debug_mark),a  
091c 3a 2b 09			ld a, (.dmark+1)  
091f 32 78 fb			ld (debug_mark+1),a  
0922 3a 2c 09			ld a, (.dmark+2)  
0925 32 79 fb			ld (debug_mark+2),a  
0928 18 03			jr .pastdmark  
092a ..			.dmark: db "AP2"  
092d f1			.pastdmark: pop af  
092e			endm  
# End of macro DMARK
092e					CALLMONITOR 
092e cd 74 17			call break_point_state  
0931				endm  
# End of macro CALLMONITOR
0931				endif 
0931			 
0931				; update file extent count 
0931			 
0931 11 62 f8			ld de, store_page 
0934			 
0934 cd 0c 03			call storage_read_block 
0937			 
0937				if DEBUG_STORESE 
0937					DMARK "AP3" 
0937 f5				push af  
0938 3a 4c 09			ld a, (.dmark)  
093b 32 77 fb			ld (debug_mark),a  
093e 3a 4d 09			ld a, (.dmark+1)  
0941 32 78 fb			ld (debug_mark+1),a  
0944 3a 4e 09			ld a, (.dmark+2)  
0947 32 79 fb			ld (debug_mark+2),a  
094a 18 03			jr .pastdmark  
094c ..			.dmark: db "AP3"  
094f f1			.pastdmark: pop af  
0950			endm  
# End of macro DMARK
0950					CALLMONITOR 
0950 cd 74 17			call break_point_state  
0953				endm  
# End of macro CALLMONITOR
0953				endif 
0953			;	ld (store_tmppageid), hl 
0953			 
0953 3a 64 f8			ld a, (store_page+2) 
0956 3c				inc a 
0957 32 64 f8			ld (store_page+2), a 
095a 32 5a f8			ld (store_tmpext), a 
095d				 
095d				if DEBUG_STORESE 
095d					DMARK "AP3" 
095d f5				push af  
095e 3a 72 09			ld a, (.dmark)  
0961 32 77 fb			ld (debug_mark),a  
0964 3a 73 09			ld a, (.dmark+1)  
0967 32 78 fb			ld (debug_mark+1),a  
096a 3a 74 09			ld a, (.dmark+2)  
096d 32 79 fb			ld (debug_mark+2),a  
0970 18 03			jr .pastdmark  
0972 ..			.dmark: db "AP3"  
0975 f1			.pastdmark: pop af  
0976			endm  
# End of macro DMARK
0976					CALLMONITOR 
0976 cd 74 17			call break_point_state  
0979				endm  
# End of macro CALLMONITOR
0979				endif 
0979 2a 4c f8			ld hl, (store_tmppageid) 
097c 11 62 f8			ld de, store_page 
097f cd 71 03			call storage_write_block 
0982			 
0982				; find free block 
0982			 
0982 11 00 00			ld de, 0			 ; file extent to locate 
0985			 
0985 21 40 00				ld hl, STORE_BLOCK_PHY 
0988 cd 31 06				call storage_findnextid 
098b cd 49 0d			call ishlzero 
098e ca de 08			jp z, .sa_notfound 
0991			 
0991					; TODO handle no space left 
0991					 
0991 22 4c f8				ld (store_tmppageid), hl 
0994			 
0994				if DEBUG_STORESE 
0994					DMARK "AP4" 
0994 f5				push af  
0995 3a a9 09			ld a, (.dmark)  
0998 32 77 fb			ld (debug_mark),a  
099b 3a aa 09			ld a, (.dmark+1)  
099e 32 78 fb			ld (debug_mark+1),a  
09a1 3a ab 09			ld a, (.dmark+2)  
09a4 32 79 fb			ld (debug_mark+2),a  
09a7 18 03			jr .pastdmark  
09a9 ..			.dmark: db "AP4"  
09ac f1			.pastdmark: pop af  
09ad			endm  
# End of macro DMARK
09ad					CALLMONITOR 
09ad cd 74 17			call break_point_state  
09b0				endm  
# End of macro CALLMONITOR
09b0				endif 
09b0					; init the buffer with zeros so we can id if the buffer is full or not 
09b0			 
09b0 e5					push hl 
09b1 c5					push bc 
09b2			 
09b2 21 62 f8				ld hl, store_page 
09b5 06 40				ld b, STORE_BLOCK_PHY 
09b7 3e 00				ld a, 0 
09b9 77			.zeroblock:	ld (hl), a 
09ba 23					inc hl 
09bb 10 fc				djnz .zeroblock 
09bd			 
09bd c1					pop bc 
09be e1					pop hl 
09bf			 
09bf					; construct block 
09bf			 
09bf 3a 5b f8				ld a, (store_tmpid) 
09c2 32 62 f8				ld (store_page), a   ; file id 
09c5 3a 5a f8				ld a, (store_tmpext)   ; extent for this block 
09c8 32 63 f8				ld (store_page+1), a 
09cb			 
09cb e1					pop hl    ; get string to write 
09cc 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09ce 11 64 f8				ld de, store_page+2 
09d1			 
09d1				if DEBUG_STORESE 
09d1					DMARK "AP5" 
09d1 f5				push af  
09d2 3a e6 09			ld a, (.dmark)  
09d5 32 77 fb			ld (debug_mark),a  
09d8 3a e7 09			ld a, (.dmark+1)  
09db 32 78 fb			ld (debug_mark+1),a  
09de 3a e8 09			ld a, (.dmark+2)  
09e1 32 79 fb			ld (debug_mark+2),a  
09e4 18 03			jr .pastdmark  
09e6 ..			.dmark: db "AP5"  
09e9 f1			.pastdmark: pop af  
09ea			endm  
# End of macro DMARK
09ea					CALLMONITOR 
09ea cd 74 17			call break_point_state  
09ed				endm  
# End of macro CALLMONITOR
09ed				endif 
09ed			 
09ed			 
09ed			 
09ed					; fill buffer with data until end of string or full block 
09ed			 
09ed 7e			.appd:		ld a, (hl) 
09ee 12					ld (de), a 
09ef fe 00				cp 0 
09f1 28 04				jr z, .appdone 
09f3 23					inc hl 
09f4 13					inc de 
09f5 10 f6				djnz .appd 
09f7			 
09f7 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09f8 f5					push af   		; save last byte dumped 
09f9			 
09f9			 
09f9 2a 4c f8			ld hl, (store_tmppageid) 
09fc 11 62 f8			ld de, store_page 
09ff				if DEBUG_STORESE 
09ff					DMARK "AP6" 
09ff f5				push af  
0a00 3a 14 0a			ld a, (.dmark)  
0a03 32 77 fb			ld (debug_mark),a  
0a06 3a 15 0a			ld a, (.dmark+1)  
0a09 32 78 fb			ld (debug_mark+1),a  
0a0c 3a 16 0a			ld a, (.dmark+2)  
0a0f 32 79 fb			ld (debug_mark+2),a  
0a12 18 03			jr .pastdmark  
0a14 ..			.dmark: db "AP6"  
0a17 f1			.pastdmark: pop af  
0a18			endm  
# End of macro DMARK
0a18					CALLMONITOR 
0a18 cd 74 17			call break_point_state  
0a1b				endm  
# End of macro CALLMONITOR
0a1b				endif 
0a1b cd 71 03				call storage_write_block 
0a1e			 
0a1e			 
0a1e				; was that a full block of data written? 
0a1e				; any more to write out? 
0a1e			 
0a1e				; if yes then set vars and jump to start of function again 
0a1e			 
0a1e f1					pop af 
0a1f d1					pop de 
0a20			 
0a20 fe 00				cp 0		 ; no, string was fully written 
0a22 c8					ret z 
0a23			 
0a23					; setup vars for next cycle 
0a23			 
0a23 3a 5b f8				ld a, (store_tmpid) 
0a26 6f					ld l, a 
0a27 26 00				ld h, 0 
0a29			 
0a29 c3 e0 08			 	jp storage_append	 ; yes, need to write out some more 
0a2c			 
0a2c			 
0a2c			 
0a2c			 
0a2c			 
0a2c			 
0a2c			 
0a2c			if DEBUG_STORECF 
0a2c			storageput:	 
0a2c					ret 
0a2c			storageread: 
0a2c					ld hl, store_page 
0a2c					ld b, 200 
0a2c					ld a,0 
0a2c			.src:		ld (hl),a 
0a2c					inc hl 
0a2c					djnz .src 
0a2c					 
0a2c			 
0a2c					ld de, 0 
0a2c					ld bc, 1 
0a2c					ld hl, store_page 
0a2c					call cfRead 
0a2c			 
0a2c				call cfGetError 
0a2c				ld hl,scratch 
0a2c				call hexout 
0a2c				ld hl, scratch+2 
0a2c				ld a, 0 
0a2c				ld (hl),a 
0a2c				ld de, scratch 
0a2c				ld a,display_row_1 
0a2c				call str_at_display 
0a2c				call update_display 
0a2c			 
0a2c					ld hl, store_page 
0a2c					ld (os_cur_ptr),hl 
0a2c			 
0a2c					ret 
0a2c			endif 
0a2c			 
0a2c			 
0a2c			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a2c			 
0a2c			storage_clear_page: 
0a2c e5				push hl 
0a2d d5				push de 
0a2e c5				push bc 
0a2f 21 62 f8			ld hl, store_page 
0a32 3e 00			ld a, 0 
0a34 77				ld (hl), a 
0a35			 
0a35 11 63 f8			ld de, store_page+1 
0a38 01 40 00			ld bc, STORE_BLOCK_PHY 
0a3b			 
0a3b ed b0			ldir 
0a3d				 
0a3d c1				pop bc 
0a3e d1				pop de 
0a3f e1				pop hl 
0a40 c9				ret 
0a41			 
0a41			; eof 
# End of file firmware_storage.asm
0a41			  
0a41			; support routines for above hardware abstraction layer  
0a41			  
0a41			include "firmware_general.asm"        ; general support functions  
0a41			 
0a41			; word look up 
0a41			 
0a41			; in 
0a41			; a is the index 
0a41			; hl is pointer start of array 
0a41			; 
0a41			; returns 
0a41			; hl to the word 
0a41			; 
0a41			 
0a41			table_lookup:  
0a41 d5					push de 
0a42 eb					ex de, hl 
0a43			 
0a43 6f					ld l, a 
0a44 26 00				ld h, 0 
0a46 29					add hl, hl 
0a47 19					add hl, de 
0a48 7e					ld a, (hl) 
0a49 23					inc hl 
0a4a 66					ld h,(hl) 
0a4b 6f					ld l, a 
0a4c			 
0a4c d1					pop de 
0a4d c9					ret 
0a4e			 
0a4e			; Delay loops 
0a4e			 
0a4e			 
0a4e			 
0a4e			aDelayInMS: 
0a4e c5				push bc 
0a4f 47				ld b,a 
0a50			msdelay: 
0a50 c5				push bc 
0a51				 
0a51			 
0a51 01 41 00			ld bc,041h 
0a54 cd 6c 0a			call delayloop 
0a57 c1				pop bc 
0a58 05				dec b 
0a59 20 f5			jr nz,msdelay 
0a5b			 
0a5b			;if CPU_CLOCK_8MHZ 
0a5b			;msdelay8: 
0a5b			;	push bc 
0a5b			;	 
0a5b			; 
0a5b			;	ld bc,041h 
0a5b			;	call delayloop 
0a5b			;	pop bc 
0a5b			;	dec b 
0a5b			;	jr nz,msdelay8 
0a5b			;endif 
0a5b			 
0a5b			 
0a5b c1				pop bc 
0a5c c9				ret 
0a5d			 
0a5d			 
0a5d			delay250ms: 
0a5d				;push de 
0a5d 01 00 40			ld bc, 04000h 
0a60 c3 6c 0a			jp delayloop 
0a63			delay500ms: 
0a63				;push de 
0a63 01 00 80			ld bc, 08000h 
0a66 c3 6c 0a			jp delayloop 
0a69			delay1s: 
0a69				;push bc 
0a69			   ; Clobbers A, d and e 
0a69 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a6c			delayloop: 
0a6c c5			    push bc 
0a6d			 
0a6d			if BASE_CPM 
0a6d				ld bc, CPM_DELAY_TUNE 
0a6d			.cpmloop: 
0a6d				push bc 
0a6d			 
0a6d			endif 
0a6d			 
0a6d			 
0a6d			 
0a6d			delayloopi: 
0a6d			;	push bc 
0a6d			;.dl: 
0a6d cb 47		    bit     0,a    	; 8 
0a6f cb 47		    bit     0,a    	; 8 
0a71 cb 47		    bit     0,a    	; 8 
0a73 e6 ff		    and     255  	; 7 
0a75 0b			    dec     bc      	; 6 
0a76 79			    ld      a,c     	; 4 
0a77 b0			    or      b     	; 4 
0a78 c2 6d 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a7b			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a7b				;pop de 
0a7b			;pop bc 
0a7b			 
0a7b			if BASE_CPM 
0a7b				pop bc 
0a7b				 
0a7b			    dec     bc      	; 6 
0a7b			    ld      a,c     	; 4 
0a7b			    or      b     	; 4 
0a7b			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a7b				 
0a7b			 
0a7b			endif 
0a7b			;if CPU_CLOCK_8MHZ 
0a7b			;    pop bc 
0a7b			;    push bc 
0a7b			;.dl8: 
0a7b			;    bit     0,a    	; 8 
0a7b			;    bit     0,a    	; 8 
0a7b			;    bit     0,a    	; 8 
0a7b			;    and     255  	; 7 
0a7b			;    dec     bc      	; 6 
0a7b			;    ld      a,c     	; 4 
0a7b			;    or      b     	; 4 
0a7b			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a7b			;endif 
0a7b			 
0a7b			;if CPU_CLOCK_10MHZ 
0a7b			;    pop bc 
0a7b			;    push bc 
0a7b			;.dl8: 
0a7b			;    bit     0,a    	; 8 
0a7b			;    bit     0,a    	; 8 
0a7b			;    bit     0,a    	; 8 
0a7b			;    and     255  	; 7 
0a7b			;    dec     bc      	; 6 
0a7b			;    ld      a,c     	; 4 
0a7b			;    or      b     	; 4 
0a7b			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a7b			;endif 
0a7b c1			    pop bc 
0a7c			 
0a7c c9				ret 
0a7d			 
0a7d			 
0a7d			 
0a7d			; eof 
# End of file firmware_general.asm
0a7d			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a7d			; display routines that use the physical hardware abstraction layer 
0a7d			 
0a7d			 
0a7d			; information window 
0a7d			 
0a7d			; pass hl with 1st string to display 
0a7d			; pass de with 2nd string to display 
0a7d			 
0a7d			info_panel: 
0a7d e5				push hl 
0a7e			 
0a7e 2a d8 f8			ld hl, (display_fb_active) 
0a81 e5				push hl    ; future de destination 
0a82 21 bd fa				ld hl, display_fb0 
0a85 22 d8 f8				ld (display_fb_active), hl 
0a88			 
0a88			;	call clear_display 
0a88			 
0a88				if BASE_CPM 
0a88				ld a, '.' 
0a88				else 
0a88 3e a5			ld a, 165 
0a8a				endif 
0a8a cd f1 0a			call fill_display 
0a8d			 
0a8d			 
0a8d 3e 55			ld a, display_row_3 + 5 
0a8f cd ff 0a			call str_at_display 
0a92			 
0a92 e1				pop hl 
0a93 d1				pop de 
0a94			 
0a94 e5				push hl 
0a95			 
0a95			 
0a95 3e 2d			ld a, display_row_2 + 5 
0a97 cd ff 0a			call str_at_display 
0a9a			 
0a9a			 
0a9a cd 0f 0b			call update_display 
0a9d cd 7c 1c			call next_page_prompt 
0aa0 cd ec 0a			call clear_display 
0aa3			 
0aa3				 
0aa3 21 1c fa				ld hl, display_fb1 
0aa6 22 d8 f8				ld (display_fb_active), hl 
0aa9 cd 0f 0b			call update_display 
0aac			 
0aac e1				pop hl 
0aad			 
0aad c9				ret 
0aae			 
0aae			 
0aae			 
0aae			 
0aae			; TODO windowing? 
0aae			 
0aae			; TODO scroll line up 
0aae			 
0aae			scroll_up: 
0aae			 
0aae e5				push hl 
0aaf d5				push de 
0ab0 c5				push bc 
0ab1			 
0ab1				; get frame buffer  
0ab1			 
0ab1 2a d8 f8			ld hl, (display_fb_active) 
0ab4 e5				push hl    ; future de destination 
0ab5			 
0ab5 11 28 00			ld  de, display_cols 
0ab8 19				add hl, de 
0ab9			 
0ab9 d1				pop de 
0aba			 
0aba				;ex de, hl 
0aba 01 9f 00			ld bc, display_fb_len -1  
0abd			;if DEBUG_FORTH_WORDS 
0abd			;	DMARK "SCL" 
0abd			;	CALLMONITOR 
0abd			;endif	 
0abd ed b0			ldir 
0abf			 
0abf				; wipe bottom row 
0abf			 
0abf			 
0abf 2a d8 f8			ld hl, (display_fb_active) 
0ac2 11 a0 00			ld de, display_cols*display_rows 
0ac5 19				add hl, de 
0ac6 06 28			ld b, display_cols 
0ac8 3e 20			ld a, ' ' 
0aca			.scwipe: 
0aca 77				ld (hl), a 
0acb 2b				dec hl 
0acc 10 fc			djnz .scwipe 
0ace			 
0ace				;pop hl 
0ace			 
0ace c1				pop bc 
0acf d1				pop de 
0ad0 e1				pop hl 
0ad1			 
0ad1 c9				ret 
0ad2			 
0ad2			 
0ad2			;scroll_upo: 
0ad2			;	ld de, display_row_1 
0ad2			 ;	ld hl, display_row_2 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;	ld de, display_row_2 
0ad2			 ;	ld hl, display_row_3 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;	ld de, display_row_3 
0ad2			 ;	ld hl, display_row_4 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			 
0ad2			; TODO clear row 4 
0ad2			 
0ad2			;	ret 
0ad2			 
0ad2				 
0ad2			scroll_down: 
0ad2			 
0ad2 e5				push hl 
0ad3 d5				push de 
0ad4 c5				push bc 
0ad5			 
0ad5				; get frame buffer  
0ad5			 
0ad5 2a d8 f8			ld hl, (display_fb_active) 
0ad8			 
0ad8 11 9f 00			ld de, display_fb_len - 1 
0adb 19				add hl, de 
0adc			 
0adc e5			push hl    ; future de destination 
0add			 
0add 11 28 00			ld  de, display_cols 
0ae0 ed 52			sbc hl, de 
0ae2			 
0ae2			 
0ae2 d1				pop de 
0ae3			 
0ae3			;	ex de, hl 
0ae3 01 9f 00			ld bc, display_fb_len -1  
0ae6			 
0ae6			 
0ae6				 
0ae6			 
0ae6 ed b0			ldir 
0ae8			 
0ae8				; wipe bottom row 
0ae8			 
0ae8			 
0ae8			;	ld hl, (display_fb_active) 
0ae8			;;	ld de, display_cols*display_rows 
0ae8			;;	add hl, de 
0ae8			;	ld b, display_cols 
0ae8			;	ld a, ' ' 
0ae8			;.scwiped: 
0ae8			;	ld (hl), a 
0ae8			;	dec hl 
0ae8			;	djnz .scwiped 
0ae8			 
0ae8				;pop hl 
0ae8			 
0ae8 c1				pop bc 
0ae9 d1				pop de 
0aea e1				pop hl 
0aeb			 
0aeb c9				ret 
0aec			;scroll_down: 
0aec			;	ld de, display_row_4 
0aec			;	ld hl, display_row_3 
0aec			;	ld bc, display_cols 
0aec			;	ldir 
0aec			;	ld de, display_row_3 
0aec			; 	ld hl, display_row_2 
0aec			;	ld bc, display_cols 
0aec			;	ldir 
0aec			;	ld de, display_row_2 
0aec			;	ld hl, display_row_1 
0aec			;	ld bc, display_cols 
0aec			;	ldir 
0aec			;;; TODO clear row 1 
0aec			;	ret 
0aec			 
0aec			 
0aec			 
0aec			 
0aec			 
0aec			; clear active frame buffer 
0aec			 
0aec			clear_display: 
0aec 3e 20			ld a, ' ' 
0aee c3 f1 0a			jp fill_display 
0af1			 
0af1			; fill active frame buffer with a char in A 
0af1			 
0af1			fill_display: 
0af1 06 a0			ld b,display_fb_len 
0af3 2a d8 f8			ld hl, (display_fb_active) 
0af6 77			.fd1:	ld (hl),a 
0af7 23				inc hl 
0af8 10 fc			djnz .fd1 
0afa 23				inc hl 
0afb 3e 00			ld a,0 
0afd 77				ld (hl),a 
0afe			 
0afe			 
0afe c9				ret 
0aff			; Write string (DE) at pos (A) to active frame buffer 
0aff			 
0aff 2a d8 f8		str_at_display:    ld hl,(display_fb_active) 
0b02 06 00					ld b,0 
0b04 4f					ld c,a 
0b05 09					add hl,bc 
0b06 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0b07 b7			            OR   A              ;Null terminator? 
0b08 c8			            RET  Z              ;Yes, so finished 
0b09 77					ld (hl),a 
0b0a 23				inc hl 
0b0b 13			            INC  DE             ;Point to next character 
0b0c 18 f8		            JR   .sad1     ;Repeat 
0b0e c9					ret 
0b0f			 
0b0f			; using current frame buffer write to physical display 
0b0f			 
0b0f			update_display: 
0b0f e5				push hl 
0b10 2a d8 f8			ld hl, (display_fb_active) 
0b13 cd 16 66			call write_display 
0b16 e1				pop hl 
0b17 c9				ret 
0b18			 
0b18			; TODO scrolling 
0b18			 
0b18			 
0b18			; move cursor right one char 
0b18			cursor_right: 
0b18			 
0b18				; TODO shift right 
0b18				; TODO if beyond max col 
0b18				; TODO       cursor_next_line 
0b18			 
0b18 c9				ret 
0b19			 
0b19			 
0b19			cursor_next_line: 
0b19				; TODO first char 
0b19				; TODO line down 
0b19				; TODO if past last row 
0b19				; TODO    scroll up 
0b19			 
0b19 c9				ret 
0b1a			 
0b1a			cursor_left: 
0b1a				; TODO shift left 
0b1a				; TODO if beyond left  
0b1a				; TODO     cursor prev line 
0b1a				 
0b1a c9				ret 
0b1b			 
0b1b			cursor_prev_line: 
0b1b				; TODO last char 
0b1b				; TODO line up 
0b1b				; TODO if past first row 
0b1b				; TODO   scroll down 
0b1b			 
0b1b c9				ret 
0b1c			 
0b1c			 
0b1c			cout: 
0b1c				; A - char 
0b1c c9				ret 
0b1d			 
0b1d			 
0b1d			; Display a menu and allow item selection (optional toggle items) 
0b1d			; 
0b1d			; format: 
0b1d			; hl pointer to word array with zero term for items 
0b1d			; e.g.    db item1 
0b1d			;         db .... 
0b1d			;         db 0 
0b1d			; 
0b1d			; a = starting menu item  
0b1d			; 
0b1d			; de = pointer item toggle array   (todo) 
0b1d			; 
0b1d			; returns item selected in a 1-... 
0b1d			; returns 0 if back button pressed 
0b1d			; 
0b1d			; NOTE: Uses system frame buffer to display 
0b1d			; 
0b1d			; LEFT, Q = go back 
0b1d			; RIGHT, SPACE, CR = select 
0b1d			; UP, A - Up 
0b1d			; DOWN, Z - Down 
0b1d			 
0b1d			 
0b1d			 
0b1d			 
0b1d			 
0b1d			menu: 
0b1d			 
0b1d					; keep array pointer 
0b1d			 
0b1d 22 60 f8				ld (store_tmp1), hl 
0b20 32 5e f8				ld (store_tmp2), a 
0b23			 
0b23					; check for key bounce 
0b23			 
0b23			if BASE_KEV 
0b23			 
0b23 cd 61 69		.mbounce:	call cin 
0b26 fe 00				cp 0 
0b28 20 f9				jr nz, .mbounce 
0b2a			endif 
0b2a					; for ease use ex 
0b2a			 
0b2a					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b2a 21 bd fa				ld hl, display_fb0 
0b2d 22 d8 f8				ld (display_fb_active), hl 
0b30			 
0b30 cd ec 0a		.mloop:		call clear_display 
0b33 cd 0f 0b				call update_display 
0b36			 
0b36					; draw selection id '>' at 1 
0b36			 
0b36					; init start of list display 
0b36			 
0b36 3e 05				ld a, 5 
0b38 32 5c f8				ld (store_tmp3), a   ; display row count 
0b3b 3a 5e f8				ld a,( store_tmp2) 
0b3e 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b41			 
0b41					 
0b41			.mitem:	 
0b41			 
0b41			 
0b41 3a 5f f8				ld a,(store_tmp2+1) 
0b44 6f					ld l, a 
0b45 26 00				ld h, 0 
0b47 29					add hl, hl 
0b48 ed 5b 60 f8			ld de, (store_tmp1) 
0b4c 19					add hl, de 
0b4d 7e					ld a, (hl) 
0b4e 23					inc hl 
0b4f 66					ld h,(hl) 
0b50 6f					ld l, a 
0b51			 
0b51 cd 49 0d				call ishlzero 
0b54 28 1a				jr z, .mdone 
0b56			 
0b56 eb					ex de, hl 
0b57 3a 5c f8				ld a, (store_tmp3) 
0b5a cd ff 0a				call str_at_display 
0b5d					 
0b5d			 
0b5d					; next item 
0b5d 3a 5f f8				ld a, (store_tmp2+1) 
0b60 3c					inc a 
0b61 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b64			 
0b64			 		; next row 
0b64			 
0b64 3a 5c f8				ld a, (store_tmp3) 
0b67 c6 28				add display_cols 
0b69 32 5c f8				ld (store_tmp3), a 
0b6c			 
0b6c					; at end of screen? 
0b6c			 
0b6c fe 10				cp display_rows*4 
0b6e 20 d1				jr nz, .mitem 
0b70			 
0b70			 
0b70			.mdone: 
0b70 cd 49 0d				call ishlzero 
0b73 28 08				jr z, .nodn 
0b75			 
0b75 3e 78				ld a, display_row_4 
0b77 11 f6 0b				ld de, .mdown 
0b7a cd ff 0a				call str_at_display 
0b7d			 
0b7d					; draw options to fill the screens with active item on line 1 
0b7d					; if current option is 2 or more then display ^ in top 
0b7d			 
0b7d 3a 5e f8		.nodn:		ld a, (store_tmp2) 
0b80 fe 00				cp 0 
0b82 28 08				jr z, .noup 
0b84			 
0b84 3e 00				ld a, 0 
0b86 11 f4 0b				ld de, .mup 
0b89 cd ff 0a				call str_at_display 
0b8c			 
0b8c 3e 02		.noup:		ld a, 2 
0b8e 11 f2 0b				ld de, .msel 
0b91 cd ff 0a				call str_at_display 
0b94			 
0b94					; if current option + 1 is not null then display V in bottom 
0b94					; get key 
0b94 cd 0f 0b				call update_display 
0b97			 
0b97			 
0b97					; handle key 
0b97			 
0b97 cd 50 69				call cin_wait 
0b9a			 
0b9a fe 05				cp KEY_UP 
0b9c 28 2b				jr z, .mgoup 
0b9e fe 61				cp 'a' 
0ba0 28 27				jr z, .mgoup 
0ba2 fe 0a				cp KEY_DOWN 
0ba4 28 32				jr z, .mgod 
0ba6 fe 7a				cp 'z' 
0ba8 28 2e				jr z, .mgod 
0baa fe 20				cp ' ' 
0bac 28 34				jr z, .goend 
0bae fe 0c				cp KEY_RIGHT 
0bb0 28 30				jr z, .goend 
0bb2 fe 0d				cp KEY_CR 
0bb4 28 2c				jr z, .goend 
0bb6 fe 71				cp 'q' 
0bb8 28 0b				jr z, .goback 
0bba			 
0bba fe 0b				cp KEY_LEFT 
0bbc 28 07				jr z, .goback 
0bbe fe 08				cp KEY_BS 
0bc0 28 03				jr z, .goback 
0bc2 c3 30 0b				jp .mloop 
0bc5			 
0bc5			.goback: 
0bc5 3e 00			ld a, 0 
0bc7 18 1d			jr .goend2 
0bc9			 
0bc9				; move up one 
0bc9			.mgoup: 
0bc9 3a 5e f8				ld a, (store_tmp2) 
0bcc fe 00				cp 0 
0bce ca 30 0b				jp z, .mloop 
0bd1 3d					dec a 
0bd2 32 5e f8				ld (store_tmp2), a 
0bd5 c3 30 0b				jp .mloop 
0bd8			 
0bd8				; move down one 
0bd8			.mgod: 
0bd8 3a 5e f8				ld a, (store_tmp2) 
0bdb 3c					inc a 
0bdc 32 5e f8				ld (store_tmp2), a 
0bdf c3 30 0b				jp .mloop 
0be2			 
0be2			 
0be2			.goend: 
0be2					; get selected item number 
0be2			 
0be2 3a 5e f8				ld a, (store_tmp2) 
0be5 3c					inc a 
0be6			 
0be6			.goend2: 
0be6 f5					push af 
0be7			 
0be7					; restore active fb 
0be7					; TODO BUG assumes fb1 
0be7			 
0be7 21 1c fa				ld hl, display_fb1 
0bea 22 d8 f8				ld (display_fb_active), hl 
0bed			 
0bed					; restore main regs 
0bed			 
0bed			 
0bed cd 0f 0b				call update_display 
0bf0			 
0bf0 f1					pop af 
0bf1			 
0bf1 c9				ret 
0bf2			 
0bf2 .. 00		.msel:   db ">",0 
0bf4 .. 00		.mup:   db "^",0 
0bf6 .. 00		.mdown:   db "v",0 
0bf8			 
0bf8			 
0bf8			; eof 
0bf8			 
# End of file firmware_display.asm
0bf8			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0bf8			; random number generators 
0bf8			 
0bf8			 
0bf8			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0bf8			 
0bf8			 
0bf8			;-----> Generate a random number 
0bf8			; output a=answer 0<=a<=255 
0bf8			; all registers are preserved except: af 
0bf8			random: 
0bf8 e5			        push    hl 
0bf9 d5			        push    de 
0bfa 2a ba f8		        ld      hl,(randData) 
0bfd ed 5f		        ld      a,r 
0bff 57			        ld      d,a 
0c00 5e			        ld      e,(hl) 
0c01 19			        add     hl,de 
0c02 85			        add     a,l 
0c03 ac			        xor     h 
0c04 22 ba f8		        ld      (randData),hl 
0c07 d1			        pop     de 
0c08 e1			        pop     hl 
0c09 c9			        ret 
0c0a			 
0c0a			 
0c0a			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0c0a			 
0c0a			 
0c0a			 
0c0a			;------LFSR------ 
0c0a			;James Montelongo 
0c0a			;optimized by Spencer Putt 
0c0a			;out: 
0c0a			; a = 8 bit random number 
0c0a			RandLFSR: 
0c0a 21 c0 f8		        ld hl,LFSRSeed+4 
0c0d 5e			        ld e,(hl) 
0c0e 23			        inc hl 
0c0f 56			        ld d,(hl) 
0c10 23			        inc hl 
0c11 4e			        ld c,(hl) 
0c12 23			        inc hl 
0c13 7e			        ld a,(hl) 
0c14 47			        ld b,a 
0c15 cb 13		        rl e  
0c17 cb 12			rl d 
0c19 cb 11		        rl c  
0c1b 17				rla 
0c1c cb 13		        rl e  
0c1e cb 12			rl d 
0c20 cb 11		        rl c  
0c22 17				rla 
0c23 cb 13		        rl e  
0c25 cb 12			rl d 
0c27 cb 11		        rl c  
0c29 17				rla 
0c2a 67			        ld h,a 
0c2b cb 13		        rl e  
0c2d cb 12			rl d 
0c2f cb 11		        rl c  
0c31 17				rla 
0c32 a8			        xor b 
0c33 cb 13		        rl e  
0c35 cb 12			rl d 
0c37 ac			        xor h 
0c38 a9			        xor c 
0c39 aa			        xor d 
0c3a 21 c2 f8		        ld hl,LFSRSeed+6 
0c3d 11 c3 f8		        ld de,LFSRSeed+7 
0c40 01 07 00		        ld bc,7 
0c43 ed b8		        lddr 
0c45 12			        ld (de),a 
0c46 c9			        ret 
0c47			 
0c47			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c47			 
0c47			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c47			 
0c47			 
0c47			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c47			 
0c47			prng16: 
0c47			;Inputs: 
0c47			;   (seed1) contains a 16-bit seed value 
0c47			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c47			;Outputs: 
0c47			;   HL is the result 
0c47			;   BC is the result of the LCG, so not that great of quality 
0c47			;   DE is preserved 
0c47			;Destroys: 
0c47			;   AF 
0c47			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c47			;160cc 
0c47			;26 bytes 
0c47 2a b4 f8		    ld hl,(seed1) 
0c4a 44			    ld b,h 
0c4b 4d			    ld c,l 
0c4c 29			    add hl,hl 
0c4d 29			    add hl,hl 
0c4e 2c			    inc l 
0c4f 09			    add hl,bc 
0c50 22 b4 f8		    ld (seed1),hl 
0c53 2a b2 f8		    ld hl,(seed2) 
0c56 29			    add hl,hl 
0c57 9f			    sbc a,a 
0c58 e6 2d		    and %00101101 
0c5a ad			    xor l 
0c5b 6f			    ld l,a 
0c5c 22 b2 f8		    ld (seed2),hl 
0c5f 09			    add hl,bc 
0c60 c9			    ret 
0c61			 
0c61			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c61			 
0c61			rand32: 
0c61			;Inputs: 
0c61			;   (seed1_0) holds the lower 16 bits of the first seed 
0c61			;   (seed1_1) holds the upper 16 bits of the first seed 
0c61			;   (seed2_0) holds the lower 16 bits of the second seed 
0c61			;   (seed2_1) holds the upper 16 bits of the second seed 
0c61			;   **NOTE: seed2 must be non-zero 
0c61			;Outputs: 
0c61			;   HL is the result 
0c61			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c61			;Destroys: 
0c61			;   AF 
0c61			;Tested and passes all CAcert tests 
0c61			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c61			;it has a period of 18,446,744,069,414,584,320 
0c61			;roughly 18.4 quintillion. 
0c61			;LFSR taps: 0,2,6,7  = 11000101 
0c61			;291cc 
0c61			;seed1_0=$+1 
0c61			;    ld hl,12345 
0c61			;seed1_1=$+1 
0c61			;    ld de,6789 
0c61			;    ld b,h 
0c61			;    ld c,l 
0c61			;    add hl,hl \ rl e \ rl d 
0c61			;    add hl,hl \ rl e \ rl d 
0c61			;    inc l 
0c61			;    add hl,bc 
0c61			;    ld (seed1_0),hl 
0c61			;    ld hl,(seed1_1) 
0c61			;    adc hl,de 
0c61			;    ld (seed1_1),hl 
0c61			;    ex de,hl 
0c61			;seed2_0=$+1 
0c61			;    ld hl,9876 
0c61			;seed2_1=$+1 
0c61			;    ld bc,54321 
0c61			;    add hl,hl \ rl c \ rl b 
0c61			;    ld (seed2_1),bc 
0c61			;    sbc a,a 
0c61			;    and %11000101 
0c61			;    xor l 
0c61			;    ld l,a 
0c61			;    ld (seed2_0),hl 
0c61			;    ex de,hl 
0c61			;    add hl,bc 
0c61			;    ret 
0c61			; 
0c61			 
0c61			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c61			; 20 bytes, 86 cycles (excluding ret) 
0c61			 
0c61			; returns   hl = pseudorandom number 
0c61			; corrupts   a 
0c61			 
0c61			; generates 16-bit pseudorandom numbers with a period of 65535 
0c61			; using the xorshift method: 
0c61			 
0c61			; hl ^= hl << 7 
0c61			; hl ^= hl >> 9 
0c61			; hl ^= hl << 8 
0c61			 
0c61			; some alternative shift triplets which also perform well are: 
0c61			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c61			 
0c61			;  org 32768 
0c61			 
0c61			xrnd: 
0c61 2a b8 f8		  ld hl,(xrandc)       ; seed must not be 0 
0c64 3e 00		  ld a,0 
0c66 bd			  cp l 
0c67 20 02		  jr nz, .xrnd1 
0c69 2e 01		  ld l, 1 
0c6b			.xrnd1: 
0c6b			 
0c6b 7c			  ld a,h 
0c6c 1f			  rra 
0c6d 7d			  ld a,l 
0c6e 1f			  rra 
0c6f ac			  xor h 
0c70 67			  ld h,a 
0c71 7d			  ld a,l 
0c72 1f			  rra 
0c73 7c			  ld a,h 
0c74 1f			  rra 
0c75 ad			  xor l 
0c76 6f			  ld l,a 
0c77 ac			  xor h 
0c78 67			  ld h,a 
0c79			 
0c79 22 b8 f8		  ld (xrandc),hl 
0c7c			 
0c7c c9			  ret 
0c7d			;  
0c7d			 
0c7d			 
0c7d			;;;; int maths 
0c7d			 
0c7d			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c7d			; Divide 16-bit values (with 16-bit result) 
0c7d			; In: Divide BC by divider DE 
0c7d			; Out: BC = result, HL = rest 
0c7d			; 
0c7d			Div16: 
0c7d 21 00 00		    ld hl,0 
0c80 78			    ld a,b 
0c81 06 08		    ld b,8 
0c83			Div16_Loop1: 
0c83 17			    rla 
0c84 ed 6a		    adc hl,hl 
0c86 ed 52		    sbc hl,de 
0c88 30 01		    jr nc,Div16_NoAdd1 
0c8a 19			    add hl,de 
0c8b			Div16_NoAdd1: 
0c8b 10 f6		    djnz Div16_Loop1 
0c8d 17			    rla 
0c8e 2f			    cpl 
0c8f 47			    ld b,a 
0c90 79			    ld a,c 
0c91 48			    ld c,b 
0c92 06 08		    ld b,8 
0c94			Div16_Loop2: 
0c94 17			    rla 
0c95 ed 6a		    adc hl,hl 
0c97 ed 52		    sbc hl,de 
0c99 30 01		    jr nc,Div16_NoAdd2 
0c9b 19			    add hl,de 
0c9c			Div16_NoAdd2: 
0c9c 10 f6		    djnz Div16_Loop2 
0c9e 17			    rla 
0c9f 2f			    cpl 
0ca0 41			    ld b,c 
0ca1 4f			    ld c,a 
0ca2 c9			ret 
0ca3			 
0ca3			 
0ca3			;http://z80-heaven.wikidot.com/math 
0ca3			; 
0ca3			;Inputs: 
0ca3			;     DE and A are factors 
0ca3			;Outputs: 
0ca3			;     A is not changed 
0ca3			;     B is 0 
0ca3			;     C is not changed 
0ca3			;     DE is not changed 
0ca3			;     HL is the product 
0ca3			;Time: 
0ca3			;     342+6x 
0ca3			; 
0ca3			Mult16: 
0ca3			 
0ca3 06 08		     ld b,8          ;7           7 
0ca5 21 00 00		     ld hl,0         ;10         10 
0ca8 29			       add hl,hl     ;11*8       88 
0ca9 07			       rlca          ;4*8        32 
0caa 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0cac 19			         add hl,de   ;--         -- 
0cad 10 f9		       djnz $-5      ;13*7+8     99 
0caf c9			ret 
0cb0			 
0cb0			; 
0cb0			; Square root of 16-bit value 
0cb0			; In:  HL = value 
0cb0			; Out:  D = result (rounded down) 
0cb0			; 
0cb0			;Sqr16: 
0cb0			;    ld de,#0040 
0cb0			;    ld a,l 
0cb0			;    ld l,h 
0cb0			;    ld h,d 
0cb0			;    or a 
0cb0			;    ld b,8 
0cb0			;Sqr16_Loop: 
0cb0			;    sbc hl,de 
0cb0			;    jr nc,Sqr16_Skip 
0cb0			;    add hl,de 
0cb0			;Sqr16_Skip: 
0cb0			;    ccf 
0cb0			;    rl d 
0cb0			;    add a,a 
0cb0			;    adc hl,hl 
0cb0			;    add a,a 
0cb0			;    adc hl,hl 
0cb0			;    djnz Sqr16_Loop 
0cb0			;    ret 
0cb0			; 
0cb0			; 
0cb0			; Divide 8-bit values 
0cb0			; In: Divide E by divider C 
0cb0			; Out: A = result, B = rest 
0cb0			; 
0cb0			Div8: 
0cb0 af			    xor a 
0cb1 06 08		    ld b,8 
0cb3			Div8_Loop: 
0cb3 cb 13		    rl e 
0cb5 17			    rla 
0cb6 91			    sub c 
0cb7 30 01		    jr nc,Div8_NoAdd 
0cb9 81			    add a,c 
0cba			Div8_NoAdd: 
0cba 10 f7		    djnz Div8_Loop 
0cbc 47			    ld b,a 
0cbd 7b			    ld a,e 
0cbe 17			    rla 
0cbf 2f			    cpl 
0cc0 c9			    ret 
0cc1			 
0cc1			; 
0cc1			; Multiply 8-bit value with a 16-bit value (unrolled) 
0cc1			; In: Multiply A with DE 
0cc1			; Out: HL = result 
0cc1			; 
0cc1			Mult12U: 
0cc1 2e 00		    ld l,0 
0cc3 87			    add a,a 
0cc4 30 01		    jr nc,Mult12U_NoAdd0 
0cc6 19			    add hl,de 
0cc7			Mult12U_NoAdd0: 
0cc7 29			    add hl,hl 
0cc8 87			    add a,a 
0cc9 30 01		    jr nc,Mult12U_NoAdd1 
0ccb 19			    add hl,de 
0ccc			Mult12U_NoAdd1: 
0ccc 29			    add hl,hl 
0ccd 87			    add a,a 
0cce 30 01		    jr nc,Mult12U_NoAdd2 
0cd0 19			    add hl,de 
0cd1			Mult12U_NoAdd2: 
0cd1 29			    add hl,hl 
0cd2 87			    add a,a 
0cd3 30 01		    jr nc,Mult12U_NoAdd3 
0cd5 19			    add hl,de 
0cd6			Mult12U_NoAdd3: 
0cd6 29			    add hl,hl 
0cd7 87			    add a,a 
0cd8 30 01		    jr nc,Mult12U_NoAdd4 
0cda 19			    add hl,de 
0cdb			Mult12U_NoAdd4: 
0cdb 29			    add hl,hl 
0cdc 87			    add a,a 
0cdd 30 01		    jr nc,Mult12U_NoAdd5 
0cdf 19			    add hl,de 
0ce0			Mult12U_NoAdd5: 
0ce0 29			    add hl,hl 
0ce1 87			    add a,a 
0ce2 30 01		    jr nc,Mult12U_NoAdd6 
0ce4 19			    add hl,de 
0ce5			Mult12U_NoAdd6: 
0ce5 29			    add hl,hl 
0ce6 87			    add a,a 
0ce7 d0			    ret nc 
0ce8 19			    add hl,de 
0ce9 c9			    ret 
0cea			 
0cea			; 
0cea			; Multiply 8-bit value with a 16-bit value (right rotating) 
0cea			; In: Multiply A with DE 
0cea			;      Put lowest value in A for most efficient calculation 
0cea			; Out: HL = result 
0cea			; 
0cea			Mult12R: 
0cea 21 00 00		    ld hl,0 
0ced			Mult12R_Loop: 
0ced cb 3f		    srl a 
0cef 30 01		    jr nc,Mult12R_NoAdd 
0cf1 19			    add hl,de 
0cf2			Mult12R_NoAdd: 
0cf2 cb 23		    sla e 
0cf4 cb 12		    rl d 
0cf6 b7			    or a 
0cf7 c2 ed 0c		    jp nz,Mult12R_Loop 
0cfa c9			    ret 
0cfb			 
0cfb			; 
0cfb			; Multiply 16-bit values (with 32-bit result) 
0cfb			; In: Multiply BC with DE 
0cfb			; Out: BCHL = result 
0cfb			; 
0cfb			Mult32: 
0cfb 79			    ld a,c 
0cfc 48			    ld c,b 
0cfd 21 00 00		    ld hl,0 
0d00 06 10		    ld b,16 
0d02			Mult32_Loop: 
0d02 29			    add hl,hl 
0d03 17			    rla 
0d04 cb 11		    rl c 
0d06 30 07		    jr nc,Mult32_NoAdd 
0d08 19			    add hl,de 
0d09 ce 00		    adc a,0 
0d0b d2 0f 0d		    jp nc,Mult32_NoAdd 
0d0e 0c			    inc c 
0d0f			Mult32_NoAdd: 
0d0f 10 f1		    djnz Mult32_Loop 
0d11 41			    ld b,c 
0d12 4f			    ld c,a 
0d13 c9			    ret 
0d14			 
0d14			 
0d14			 
0d14			; 
0d14			; Multiply 8-bit values 
0d14			; In:  Multiply H with E 
0d14			; Out: HL = result 
0d14			; 
0d14			Mult8: 
0d14 16 00		    ld d,0 
0d16 6a			    ld l,d 
0d17 06 08		    ld b,8 
0d19			Mult8_Loop: 
0d19 29			    add hl,hl 
0d1a 30 01		    jr nc,Mult8_NoAdd 
0d1c 19			    add hl,de 
0d1d			Mult8_NoAdd: 
0d1d 10 fa		    djnz Mult8_Loop 
0d1f c9			    ret 
0d20			 
0d20			 
0d20			 
0d20			 
0d20			 
0d20			 
0d20			 
0d20			 
0d20			;;http://z80-heaven.wikidot.com/math 
0d20			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d20			; 
0d20			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d20			;     ld a,16        ;7 
0d20			;     ld hl,0        ;10 
0d20			;     jp $+5         ;10 
0d20			;.DivLoop: 
0d20			;       add hl,bc    ;-- 
0d20			;       dec a        ;64 
0d20			;       jr z,.DivLoopEnd        ;86 
0d20			; 
0d20			;       sla e        ;128 
0d20			;       rl d         ;128 
0d20			;       adc hl,hl    ;240 
0d20			;       sbc hl,bc    ;240 
0d20			;       jr nc,.DivLoop ;23|21 
0d20			;       inc e        ;-- 
0d20			;       jp .DivLoop+1 
0d20			; 
0d20			;.DivLoopEnd: 
0d20			 
0d20			;HL_Div_C: 
0d20			;Inputs: 
0d20			;     HL is the numerator 
0d20			;     C is the denominator 
0d20			;Outputs: 
0d20			;     A is the remainder 
0d20			;     B is 0 
0d20			;     C is not changed 
0d20			;     DE is not changed 
0d20			;     HL is the quotient 
0d20			; 
0d20			;       ld b,16 
0d20			;       xor a 
0d20			;         add hl,hl 
0d20			;         rla 
0d20			;         cp c 
0d20			;         jr c,$+4 
0d20			;           inc l 
0d20			;           sub c 
0d20			;         djnz $-7 
0d20			 
0d20			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d20			 
0d20			addatohl: 
0d20 85			    add   a, l    ; A = A+L 
0d21 6f			    ld    l, a    ; L = A+L 
0d22 8c			    adc   a, h    ; A = A+L+H+carry 
0d23 95			    sub   l       ; A = H+carry 
0d24 67			    ld    h, a    ; H = H+carry 
0d25 c9			ret 
0d26			 
0d26			addatode: 
0d26 83			    add   a, e    ; A = A+L 
0d27 5f			    ld    e, a    ; L = A+L 
0d28 8a			    adc   a, d    ; A = A+L+H+carry 
0d29 93			    sub   e       ; A = H+carry 
0d2a 57			    ld    d, a    ; H = H+carry 
0d2b c9			ret 
0d2c			 
0d2c			 
0d2c			addatobc: 
0d2c 81			    add   a, c    ; A = A+L 
0d2d 4f			    ld    c, a    ; L = A+L 
0d2e 88			    adc   a, b    ; A = A+L+H+carry 
0d2f 91			    sub   c       ; A = H+carry 
0d30 47			    ld    b, a    ; H = H+carry 
0d31 c9			ret 
0d32			 
0d32			subafromhl: 
0d32			   ; If A=0 do nothing 
0d32			    ; Otherwise flip A's sign. Since 
0d32			    ; the upper byte becomes -1, also 
0d32			    ; substract 1 from H. 
0d32 ed 44		    neg 
0d34 ca 3d 0d		    jp    z, Skip 
0d37 25			    dec   h 
0d38			     
0d38			    ; Now add the low byte as usual 
0d38			    ; Two's complement takes care of 
0d38			    ; ensuring the result is correct 
0d38 85			    add   a, l 
0d39 6f			    ld    l, a 
0d3a 8c			    adc   a, h 
0d3b 95			    sub   l 
0d3c 67			    ld    h, a 
0d3d			Skip: 
0d3d c9				ret 
0d3e			 
0d3e			 
0d3e			; compare hl and de 
0d3e			; returns:  
0d3e			; if hl = de, z=1, s=0, c0=0 
0d3e			; if hl > de, z=0, s=0, c=0 
0d3e			; if hl < de, z=0, s=1, c=1 
0d3e			cmp16:	 
0d3e b7				or a 
0d3f ed 52			sbc hl,de 
0d41 e0				ret po 
0d42 7c				ld a,h 
0d43 1f				rra 
0d44 ee 40			xor 01000000B 
0d46 37				scf 
0d47 8f				adc a,a 
0d48 c9				ret 
0d49			 
0d49			 
0d49			; test if hl contains zero   - A is destroyed 
0d49			 
0d49			ishlzero:    
0d49 b7				or a     ; reset flags 
0d4a 7c				ld a, h 
0d4b b5				or l        	 
0d4c			 
0d4c c9				ret 
0d4d			 
0d4d			 
0d4d			 
0d4d			 
0d4d			if FORTH_ENABLE_FLOATMATH 
0d4d			;include "float/bbcmath.z80" 
0d4d			include "float/lpfpcalc.asm" 
0d4d			endif 
0d4d			 
0d4d			 
0d4d			; eof 
0d4d			 
# End of file firmware_maths.asm
0d4d			include "firmware_strings.asm"   ; string handling  
0d4d			 
0d4d			 
0d4d			; TODO string len 
0d4d			; input text string, end on cr with zero term 
0d4d			; a offset into frame buffer to start prompt 
0d4d			; d is max length 
0d4d			; e is display size TODO 
0d4d			; c is current cursor position 
0d4d			; hl is ptr to where string will be stored 
0d4d			 
0d4d			 
0d4d			; TODO check limit of buffer for new inserts 
0d4d			; TODO check insert does not push beyond buffer 
0d4d			; TODO scroll in a limited display area 
0d4d			; TODO scroll whole screen on page wrap 
0d4d			 
0d4d			 
0d4d			; TODO handle KEY_PREVWORD 
0d4d			; TODO handle KEY_NEXTWORD 
0d4d			; TODO handle KEY_HOME 
0d4d			; TODO handle KEY_END 
0d4d			; TODO use LCD cursor? 
0d4d			 
0d4d 32 70 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d50 81					add c 
0d51 32 6e fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d54 22 73 fb				ld (input_start), hl     ; save ptr to buffer 
0d57 79					ld a, c 
0d58 cd 20 0d				call addatohl 
0d5b 22 75 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d5e 7a					ld a,d 
0d5f 32 72 fb			        ld (input_size), a       ; save length of input area 
0d62 79					ld a, c 
0d63 32 61 fb				ld (input_cursor),a      ; init cursor start position  
0d66 7b					ld a,e 
0d67 32 71 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d6a					 
0d6a					 
0d6a			 
0d6a			;		ld a,(input_ptr) 
0d6a			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d6a			 
0d6a			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d6a					; init cursor shape if not set by the cin routines 
0d6a 21 d0 f8				ld hl, cursor_shape 
0d6d 3e ff				ld a, 255 
0d6f 77					ld (hl), a 
0d70 23					inc hl 
0d71 3e 00				ld a, 0 
0d73 77					ld (hl), a 
0d74			 
0d74 3e 0f				ld a, CUR_BLINK_RATE 
0d76 32 6c fb				ld (input_cur_flash), a 
0d79 3e 01				ld a, 1 
0d7b 32 6b fb				ld (input_cur_onoff),a 
0d7e			 
0d7e			;	if DEBUG_INPUT 
0d7e			;		push af 
0d7e			;		ld a, 'I' 
0d7e			;		ld (debug_mark),a 
0d7e			;		pop af 
0d7e			;		CALLMONITOR 
0d7e			;	endif 
0d7e			.is1:		; main entry loop 
0d7e			 
0d7e			 
0d7e			 
0d7e					; pause 1ms 
0d7e			 
0d7e 3e 01				ld a, 1 
0d80 cd 4e 0a				call aDelayInMS 
0d83			 
0d83					; dec flash counter 
0d83 3a 6c fb				ld a, (input_cur_flash) 
0d86 3d					dec a 
0d87 32 6c fb				ld (input_cur_flash), a 
0d8a fe 00				cp 0 
0d8c 20 0d				jr nz, .nochgstate 
0d8e			 
0d8e			 
0d8e					; change state 
0d8e 3a 6b fb				ld a,(input_cur_onoff) 
0d91 ed 44				neg 
0d93 32 6b fb				ld (input_cur_onoff),a 
0d96			 
0d96			 
0d96					; reset on change of state 
0d96 3e 0f				ld a, CUR_BLINK_RATE 
0d98 32 6c fb				ld (input_cur_flash), a 
0d9b			 
0d9b			.nochgstate: 
0d9b					 
0d9b					 
0d9b			 
0d9b					; display cursor  
0d9b			 
0d9b			;		ld hl, (input_start) 
0d9b			;		ld a, (input_cursor) 
0d9b			;		call addatohl 
0d9b			 
0d9b					; get char under cursor and replace with cursor 
0d9b 2a 75 fb		ld hl, (input_ptr) 
0d9e			;		ld a, (hl) 
0d9e			;		ld (input_under_cursor),a 
0d9e			;		ld a, '_' 
0d9e			;		ld (hl), a 
0d9e			 
0d9e					; display string 
0d9e			 
0d9e ed 5b 73 fb			ld de, (input_start) 
0da2 3a 70 fb				ld a, (input_at_pos) 
0da5 cd ff 0a				call str_at_display 
0da8			;	        call update_display 
0da8			 
0da8					; find place to put the cursor 
0da8			;		add h 
0da8			;		ld l, display_row_1 
0da8			;		sub l 
0da8			; (input_at_pos) 
0da8					;ld c, a 
0da8			;		ld a, (input_cursor) 
0da8			;		ld l, (input_at_pos) 
0da8			;		;ld b, h 
0da8			;		add l 
0da8			;		ld (input_at_cursor),a 
0da8					;ld l,h 
0da8			 
0da8			;		ld h, 0 
0da8			;		ld l,(input_at_pos) 
0da8			;		ld a, (input_cursor) 
0da8			;		call addatohl 
0da8			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0da8			;		call subafromhl 
0da8			;		ld a,l 
0da8			;		ld (input_at_cursor), a 
0da8			 
0da8				if DEBUG_INPUT 
0da8					ld a, (hardware_diag) 
0da8					cp 0 
0da8					jr z, .skip_input_diag 
0da8			 
0da8					ld a,(input_at_pos) 
0da8					ld hl, LFSRSeed 
0da8					call hexout 
0da8					ld a, (input_cursor) 
0da8					ld hl, LFSRSeed+2 
0da8					call hexout 
0da8					ld a,(input_at_cursor) 
0da8					ld hl, LFSRSeed+4 
0da8					call hexout 
0da8			 
0da8					ld a,(input_cur_onoff) 
0da8					ld hl, LFSRSeed+6 
0da8					call hexout 
0da8			 
0da8					ld a,(input_cur_flash) 
0da8					ld hl, LFSRSeed+8 
0da8					call hexout 
0da8			 
0da8					ld a,(input_len) 
0da8					ld hl, LFSRSeed+10 
0da8					call hexout 
0da8					ld hl, LFSRSeed+12 
0da8					ld a, 0 
0da8					ld (hl),a 
0da8					ld a, display_row_4 
0da8					ld de, LFSRSeed 
0da8					call str_at_display 
0da8					.skip_input_diag: 
0da8				endif 
0da8			 
0da8					; decide on if we are showing the cursor this time round 
0da8			 
0da8 3a 6b fb				ld a, (input_cur_onoff) 
0dab fe ff				cp 255 
0dad 28 13				jr z, .skipcur 
0daf			 
0daf			 
0daf 3a 6e fb				ld a,(input_at_cursor) 
0db2 11 d0 f8				ld de, cursor_shape 
0db5 cd ff 0a				call str_at_display 
0db8			 
0db8					; save length of current input string 
0db8 2a 73 fb				ld hl, (input_start) 
0dbb cd 7e 11				call strlenz 
0dbe 7d					ld a,l 
0dbf 32 66 fb				ld (input_len),a 
0dc2			 
0dc2			.skipcur: 
0dc2			 
0dc2 cd 0f 0b			        call update_display 
0dc5					 
0dc5			 
0dc5			 
0dc5					; wait 
0dc5				 
0dc5					; TODO loop without wait to flash the cursor and char under cursor	 
0dc5 cd 61 69				call cin    ; _wait 
0dc8			 
0dc8 fe 00				cp 0 
0dca ca 7e 0d				jp z, .is1 
0dcd			 
0dcd					; get ptr to char to input into 
0dcd			 
0dcd 4f					ld c,a 
0dce 2a 73 fb				ld hl, (input_start) 
0dd1 3a 61 fb				ld a, (input_cursor) 
0dd4 cd 20 0d				call addatohl 
0dd7 22 75 fb				ld (input_ptr), hl 
0dda 79					ld a,c 
0ddb			 
0ddb					; replace char under cursor 
0ddb			 
0ddb			;		ld hl, (input_ptr) 
0ddb			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ddb			;		ld (hl), a 
0ddb			 
0ddb			;	if DEBUG_INPUT 
0ddb			;		push af 
0ddb			;		ld a, 'i' 
0ddb			;		ld (debug_mark),a 
0ddb			;		pop af 
0ddb			;		CALLMONITOR 
0ddb			;	endif 
0ddb fe 0e				cp KEY_HOME 
0ddd 20 0e				jr nz, .iske 
0ddf			 
0ddf 3a 70 fb				ld a, (input_at_pos) 
0de2 32 6e fb				ld (input_at_cursor),a 
0de5 3e 00				ld a, 0 
0de7 32 61 fb				ld (input_cursor), a 
0dea c3 7e 0d				jp .is1 
0ded					 
0ded fe 0f		.iske:		cp KEY_END 
0def 20 03				jr nz, .isknw 
0df1 c3 7e 0d				jp .is1 
0df4			 
0df4 fe 06		.isknw:		cp KEY_NEXTWORD 
0df6 20 1b				jr nz, .iskpw 
0df8			 
0df8 2a 75 fb		.isknwm:	ld hl, (input_ptr) 
0dfb 7e					ld a,(hl)	 
0dfc fe 00				cp 0 
0dfe ca 7e 0d				jp z, .is1    ; end of string 
0e01 fe 20				cp ' ' 
0e03 ca 7e 0d				jp z, .is1    ; end of word 
0e06 23					inc hl 
0e07 22 75 fb				ld (input_ptr), hl 
0e0a 3a 6e fb				ld a, (input_at_cursor) 
0e0d 3c					inc a 
0e0e 32 6e fb				ld (input_at_cursor), a 
0e11 18 e5				jr .isknwm 
0e13			 
0e13 fe 07		.iskpw:		cp KEY_PREVWORD 
0e15 20 1b				jr nz, .iskl 
0e17			.iskpwm:	 
0e17 2a 75 fb				ld hl, (input_ptr) 
0e1a 7e					ld a,(hl)	 
0e1b fe 00				cp 0  
0e1d ca 7e 0d				jp z, .is1    ; end of string 
0e20 fe 20				cp ' ' 
0e22 ca 7e 0d				jp z, .is1    ; end of word 
0e25 2b					dec hl 
0e26 22 75 fb				ld (input_ptr), hl 
0e29 3a 6e fb				ld a, (input_at_cursor) 
0e2c 3d					dec a 
0e2d 32 6e fb				ld (input_at_cursor), a 
0e30 18 e5				jr .iskpwm 
0e32			 
0e32			 
0e32 fe 0b		.iskl:		cp KEY_LEFT 
0e34 20 27				jr nz, .isk1 
0e36			 
0e36 3a 61 fb				ld a, (input_cursor) 
0e39			 
0e39 fe 00				cp 0 
0e3b ca 7e 0d				jp z, .is1 		; at start of line to ignore  
0e3e			 
0e3e 3d					dec  a 		; TODO check underflow 
0e3f 32 61 fb				ld (input_cursor), a 
0e42			 
0e42 2a 75 fb				ld hl, (input_ptr) 
0e45 2b					dec hl 
0e46 22 75 fb				ld (input_ptr), hl 
0e49					 
0e49 3a 6e fb				ld a, (input_at_cursor) 
0e4c 3d					dec a 
0e4d 32 6e fb				ld (input_at_cursor), a 
0e50			 
0e50 3e 01				ld a, 1		; show cursor moving 
0e52 32 6b fb				ld (input_cur_onoff),a 
0e55 3e 0f				ld a, CUR_BLINK_RATE 
0e57 32 6c fb				ld (input_cur_flash), a 
0e5a			 
0e5a c3 7e 0d				jp .is1 
0e5d			 
0e5d fe 0c		.isk1:		cp KEY_RIGHT 
0e5f 20 2a				jr nz, .isk2 
0e61			 
0e61 3a 66 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e64 5f					ld e,a 
0e65 3a 61 fb				ld a, (input_cursor) 
0e68 bb					cp e 
0e69 ca 7e 0d				jp z, .is1		; at the end of string so dont go right 
0e6c			 
0e6c 3c					inc  a 		; TODO check overflow 
0e6d 32 61 fb				ld (input_cursor), a 
0e70			 
0e70 3a 6e fb				ld a, (input_at_cursor) 
0e73 3c					inc a 
0e74 32 6e fb				ld (input_at_cursor), a 
0e77			 
0e77 2a 75 fb				ld hl, (input_ptr) 
0e7a 23					inc hl 
0e7b 22 75 fb				ld (input_ptr), hl 
0e7e			 
0e7e 3e 01				ld a, 1		; show cursor moving 
0e80 32 6b fb				ld (input_cur_onoff),a 
0e83 3e 0f				ld a, CUR_BLINK_RATE 
0e85 32 6c fb				ld (input_cur_flash), a 
0e88			 
0e88 c3 7e 0d				jp .is1 
0e8b			 
0e8b fe 05		.isk2:		cp KEY_UP 
0e8d			 
0e8d 20 26				jr nz, .isk3 
0e8f			 
0e8f					; swap last command with the current on 
0e8f			 
0e8f					; move cursor to start of string 
0e8f 2a 73 fb				ld hl, (input_start) 
0e92 22 75 fb				ld (input_ptr), hl 
0e95			 
0e95 3a 70 fb				ld a, (input_at_pos) 
0e98 32 6e fb				ld (input_at_cursor), a 
0e9b			 
0e9b 3e 00				ld a, 0 
0e9d 32 61 fb				ld (input_cursor), a 
0ea0					 
0ea0					; swap input and last command buffers 
0ea0			 
0ea0 21 44 f1				ld hl, os_cli_cmd 
0ea3 11 43 f2				ld de, os_last_cmd 
0ea6 06 ff				ld b, 255 
0ea8 7e			.swap1:		ld a, (hl) 
0ea9 4f					ld c,a 
0eaa 1a					ld a, (de) 
0eab 77					ld (hl), a 
0eac 79					ld a,c 
0ead 12					ld (de),a 
0eae 23					inc hl 
0eaf 13					inc de 
0eb0 10 f6				djnz .swap1 
0eb2			 
0eb2			 
0eb2			 
0eb2			 
0eb2			 
0eb2 c3 7e 0d				jp .is1 
0eb5			 
0eb5 fe 08		.isk3:		cp KEY_BS 
0eb7 20 3c				jr nz, .isk4 
0eb9			 
0eb9 3a 61 fb				ld a, (input_cursor) 
0ebc			 
0ebc fe 00				cp 0 
0ebe ca 7e 0d				jp z, .is1 		; at start of line to ignore  
0ec1			 
0ec1 3d					dec  a 		; TODO check underflow 
0ec2 32 61 fb				ld (input_cursor), a 
0ec5			 
0ec5					; hl is source 
0ec5					; de needs to be source - 1 
0ec5			 
0ec5			;		ld a, 0 
0ec5			;		dec hl 
0ec5			;		ld (hl), a 
0ec5			 
0ec5 2a 75 fb				ld hl, (input_ptr) 
0ec8 2b					dec hl 
0ec9 22 75 fb				ld (input_ptr), hl 
0ecc			 
0ecc					; shift all data 
0ecc			 
0ecc e5					push hl 
0ecd 23					inc hl 
0ece d1					pop de 
0ecf 3a 66 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ed2 4f					ld c,a 
0ed3 06 00				ld b,0 
0ed5 ed b0				ldir  
0ed7			 
0ed7			 
0ed7			 
0ed7			 
0ed7 3a 6e fb				ld a, (input_at_cursor) 
0eda 3d					dec a 
0edb 32 6e fb				ld (input_at_cursor), a 
0ede			 
0ede			 
0ede 3e 01				ld a, 1		; show cursor moving 
0ee0 32 6b fb				ld (input_cur_onoff),a 
0ee3 3e 0f				ld a, CUR_BLINK_RATE 
0ee5 32 6c fb				ld (input_cur_flash), a 
0ee8			 
0ee8					; remove char 
0ee8 3a 6e fb				ld a, (input_at_cursor) 
0eeb 3c					inc a 
0eec 11 76 0f				ld de,.iblank 
0eef cd ff 0a				call str_at_display 
0ef2			 
0ef2 c3 7e 0d				jp .is1 
0ef5			 
0ef5 fe 0d		.isk4:		cp KEY_CR 
0ef7 28 6c				jr z, .endinput 
0ef9			 
0ef9					; else add the key press to the end 
0ef9			 
0ef9 4f					ld c, a			; save key pressed 
0efa			 
0efa 7e					ld a,(hl)		; get what is currently under char 
0efb			 
0efb fe 00				cp 0			; we are at the end of the string 
0efd 20 2f				jr nz, .onchar 
0eff					 
0eff					; add a char to the end of the string 
0eff				 
0eff 71					ld (hl),c 
0f00 23					inc hl 
0f01			;		ld a,' ' 
0f01			;		ld (hl),a 
0f01			;		inc hl 
0f01 3e 00				ld a,0 
0f03 77					ld (hl),a 
0f04 2b					dec hl 
0f05			 
0f05 3a 61 fb				ld a, (input_cursor) 
0f08 3c					inc a				; TODO check max string length and scroll  
0f09 32 61 fb				ld (input_cursor), a		; inc cursor pos 
0f0c							 
0f0c 3a 6e fb				ld a, (input_at_cursor) 
0f0f 3c					inc a 
0f10 32 6e fb				ld (input_at_cursor), a 
0f13			 
0f13 2a 75 fb				ld hl, (input_ptr) 
0f16 23					inc hl 
0f17 22 75 fb				ld (input_ptr), hl 
0f1a			 
0f1a 2a 75 fb				ld hl, (input_ptr) 
0f1d 23					inc hl 
0f1e 22 75 fb				ld (input_ptr), hl 
0f21			;	if DEBUG_INPUT 
0f21			;		push af 
0f21			;		ld a, '+' 
0f21			;		ld (debug_mark),a 
0f21			;		pop af 
0f21			;		CALLMONITOR 
0f21			;	endif 
0f21 3e 01				ld a, 1		; show cursor moving 
0f23 32 6b fb				ld (input_cur_onoff),a 
0f26 3e 0f				ld a, CUR_BLINK_RATE 
0f28 32 6c fb				ld (input_cur_flash), a 
0f2b c3 7e 0d				jp .is1 
0f2e					 
0f2e			 
0f2e			 
0f2e					; if on a char then insert 
0f2e			.onchar: 
0f2e			 
0f2e					; TODO over flow check: make sure insert does not blow out buffer 
0f2e			 
0f2e					; need to do some maths to use lddr 
0f2e			 
0f2e e5					push hl   ; save char pos 
0f2f c5					push bc 
0f30			 
0f30 2a 73 fb				ld hl, (input_start) 
0f33 3a 66 fb				ld a, (input_len) 
0f36 cd 20 0d				call addatohl  		; end of string 
0f39 23					inc hl 
0f3a 23					inc hl		; past zero term 
0f3b e5					push hl 
0f3c 23					inc hl 
0f3d e5					push hl  
0f3e			 
0f3e								; start and end of lddr set, now how much to move? 
0f3e			 
0f3e							 
0f3e 3a 61 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f41 47					ld b,a 
0f42 3a 66 fb				ld a,(input_len) 
0f45 5f					ld e,a 
0f46 90					sub b 
0f47 3c					inc a		;?? 
0f48 3c					inc a		;?? 
0f49 3c					inc a		;?? 
0f4a			 
0f4a 06 00				ld b,0 
0f4c 4f					ld c,a 
0f4d			 
0f4d				if DEBUG_INPUT 
0f4d					push af 
0f4d					ld a, 'i' 
0f4d					ld (debug_mark),a 
0f4d					pop af 
0f4d			;		CALLMONITOR 
0f4d				endif 
0f4d d1					pop de 
0f4e e1					pop hl 
0f4f				if DEBUG_INPUT 
0f4f					push af 
0f4f					ld a, 'I' 
0f4f					ld (debug_mark),a 
0f4f					pop af 
0f4f			;		CALLMONITOR 
0f4f				endif 
0f4f ed b8				lddr 
0f51				 
0f51			 
0f51			 
0f51					; TODO have a key for insert/overwrite mode???? 
0f51 c1					pop bc 
0f52 e1					pop hl 
0f53 71					ld (hl), c		; otherwise overwrite current char 
0f54					 
0f54			 
0f54			 
0f54			 
0f54 3a 61 fb				ld a, (input_cursor) 
0f57 3c					inc  a 		; TODO check overflow 
0f58 32 61 fb				ld (input_cursor), a 
0f5b			 
0f5b 3a 6e fb				ld a, (input_at_cursor) 
0f5e 3c					inc a 
0f5f 32 6e fb				ld (input_at_cursor), a 
0f62			 
0f62 c3 7e 0d				jp .is1 
0f65			 
0f65			.endinput:	; TODO look for end of string 
0f65			 
0f65					; add trailing space for end of token 
0f65			 
0f65 2a 73 fb				ld hl, (input_start) 
0f68 3a 66 fb				ld a,(input_len) 
0f6b cd 20 0d				call addatohl 
0f6e 3e 20				ld a, ' ' 
0f70 77					ld (hl),a 
0f71					; TODO eof of parse marker 
0f71			 
0f71 23					inc hl 
0f72 3e 00				ld a, 0 
0f74 77					ld (hl),a 
0f75			 
0f75			 
0f75 c9					ret 
0f76			 
0f76 .. 00		.iblank: db " ",0 
0f78			 
0f78			 
0f78 32 70 fb		input_str_prev:	ld (input_at_pos), a 
0f7b 22 73 fb				ld (input_start), hl 
0f7e 3e 01				ld a,1			; add cursor 
0f80 77					ld (hl),a 
0f81 23					inc hl 
0f82 3e 00				ld a,0 
0f84 77					ld (hl),a 
0f85 22 75 fb				ld (input_ptr), hl 
0f88 7a					ld a,d 
0f89 32 72 fb				ld (input_size), a 
0f8c 3e 00				ld a,0 
0f8e 32 61 fb				ld (input_cursor),a 
0f91			.instr1:	 
0f91			 
0f91					; TODO do block cursor 
0f91					; TODO switch cursor depending on the modifer key 
0f91			 
0f91					; update cursor shape change on key hold 
0f91			 
0f91 2a 75 fb				ld hl, (input_ptr) 
0f94 2b					dec hl 
0f95 3a d0 f8				ld a,(cursor_shape) 
0f98 77					ld (hl), a 
0f99			 
0f99					; display entered text 
0f99 3a 70 fb				ld a,(input_at_pos) 
0f9c cd 25 67		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f9f ed 5b 73 fb	            	LD   de, (input_start) 
0fa3 cd 47 67		            	CALL fLCD_Str       ;Display string pointed to by DE 
0fa6			 
0fa6 cd 61 69				call cin 
0fa9 fe 00				cp 0 
0fab 28 e4				jr z, .instr1 
0fad			 
0fad					; proecess keyboard controls first 
0fad			 
0fad 2a 75 fb				ld hl,(input_ptr) 
0fb0			 
0fb0 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0fb2 28 5a				jr z, .instrcr 
0fb4			 
0fb4 fe 08				cp KEY_BS 	; back space 
0fb6 20 0f				jr nz, .instr2 
0fb8					; process back space 
0fb8			 
0fb8					; TODO stop back space if at start of string 
0fb8 2b					dec hl 
0fb9 2b					dec hl ; to over write cursor 
0fba 3a d0 f8				ld a,(cursor_shape) 
0fbd					;ld a,0 
0fbd 77					ld (hl),a 
0fbe 23					inc hl 
0fbf 3e 20				ld a," " 
0fc1 77					ld (hl),a 
0fc2 22 75 fb				ld (input_ptr),hl 
0fc5					 
0fc5			 
0fc5 18 ca				jr .instr1 
0fc7			 
0fc7 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0fc9 20 06				jr nz, .instr3 
0fcb 2b					dec hl 
0fcc 22 75 fb				ld (input_ptr),hl 
0fcf 18 c0				jr .instr1 
0fd1				 
0fd1 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fd3 20 06				jr nz, .instr4 
0fd5 23					inc hl 
0fd6 22 75 fb				ld (input_ptr),hl 
0fd9 18 b6				jr .instr1 
0fdb			 
0fdb fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fdd 20 06				jr nz, .instr5 
0fdf 2b					dec hl 
0fe0 22 75 fb				ld (input_ptr),hl 
0fe3 18 ac				jr .instr1 
0fe5			 
0fe5 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fe7 20 06				jr nz, .instr6 
0fe9 2b					dec hl 
0fea 22 75 fb				ld (input_ptr),hl 
0fed 18 a2				jr .instr1 
0fef fe 05		.instr6:        cp KEY_UP      ; recall last command 
0ff1 20 0b				jr nz, .instrnew 
0ff3			 
0ff3 21 1d ee			ld hl, scratch 
0ff6 11 43 f2			ld de, os_last_cmd 
0ff9 cd 17 10			call strcpy 
0ffc 18 93				jr .instr1 
0ffe			 
0ffe			 
0ffe			.instrnew:	; no special key pressed to see if we have room to store it 
0ffe			 
0ffe					; TODO do string size test 
0ffe			 
0ffe 2b					dec hl ; to over write cursor 
0fff 77					ld (hl),a 
1000 23					inc hl 
1001 3a d0 f8				ld a,(cursor_shape) 
1004 77					ld (hl),a 
1005 23					inc hl 
1006 3e 00				ld a,0 
1008 77					ld (hl),a 
1009			 
1009 22 75 fb				ld (input_ptr),hl 
100c					 
100c 18 83				jr .instr1 
100e 2b			.instrcr:	dec hl		; remove cursor 
100f 3e 20				ld a,' '	; TODO add a trailing space for safety 
1011 77					ld (hl),a 
1012 23					inc hl 
1013 3e 00				ld a,0 
1015 77					ld (hl),a 
1016			 
1016			 
1016					; if at end of line scroll up    
1016					; TODO detecting only end of line 4 for scroll up  
1016			 
1016					;ld   
1016			 
1016 c9					ret 
1017			 
1017			 
1017			; strcpy hl = dest, de source 
1017			 
1017 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1018 b7			            OR   A              ;Null terminator? 
1019 c8			            RET  Z              ;Yes, so finished 
101a 1a					ld a,(de) 
101b 77					ld (hl),a 
101c 13			            INC  DE             ;Point to next character 
101d 23					inc hl 
101e 18 f7		            JR   strcpy       ;Repeat 
1020 c9					ret 
1021			 
1021			 
1021			; TODO string_at  
1021			; pass string which starts with lcd offset address and then null term string 
1021			 
1021			; TODO string to dec 
1021			; TODO string to hex 
1021			; TODO byte to string hex 
1021			; TODO byte to string dec 
1021			 
1021			 
1021			 
1021			; from z80uartmonitor 
1021			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1021			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1021			; pass hl for where to put the text 
1021			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1021 c5			hexout:	PUSH BC 
1022 f5					PUSH AF 
1023 47					LD B, A 
1024					; Upper nybble 
1024 cb 3f				SRL A 
1026 cb 3f				SRL A 
1028 cb 3f				SRL A 
102a cb 3f				SRL A 
102c cd 3c 10				CALL tohex 
102f 77					ld (hl),a 
1030 23					inc hl	 
1031					 
1031					; Lower nybble 
1031 78					LD A, B 
1032 e6 0f				AND 0FH 
1034 cd 3c 10				CALL tohex 
1037 77					ld (hl),a 
1038 23					inc hl	 
1039					 
1039 f1					POP AF 
103a c1					POP BC 
103b c9					RET 
103c					 
103c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
103c			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
103c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
103c			tohex: 
103c e5					PUSH HL 
103d d5					PUSH DE 
103e 16 00				LD D, 0 
1040 5f					LD E, A 
1041 21 49 10				LD HL, .DATA 
1044 19					ADD HL, DE 
1045 7e					LD A, (HL) 
1046 d1					POP DE 
1047 e1					POP HL 
1048 c9					RET 
1049			 
1049			.DATA: 
1049 30					DEFB	30h	; 0 
104a 31					DEFB	31h	; 1 
104b 32					DEFB	32h	; 2 
104c 33					DEFB	33h	; 3 
104d 34					DEFB	34h	; 4 
104e 35					DEFB	35h	; 5 
104f 36					DEFB	36h	; 6 
1050 37					DEFB	37h	; 7 
1051 38					DEFB	38h	; 8 
1052 39					DEFB	39h	; 9 
1053 41					DEFB	41h	; A 
1054 42					DEFB	42h	; B 
1055 43					DEFB	43h	; C 
1056 44					DEFB	44h	; D 
1057 45					DEFB	45h	; E 
1058 46					DEFB	46h	; F 
1059			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1059			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1059			;;    subtract $30, if result > 9 then subtract $7 more 
1059			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1059			atohex: 
1059 d6 30				SUB $30 
105b fe 0a				CP 10 
105d f8					RET M		; If result negative it was 0-9 so we're done 
105e d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1060 c9					RET		 
1061			 
1061			 
1061			 
1061			 
1061			; Get 2 ASCII characters as hex byte from pointer in hl 
1061			 
1061			BYTERD: 
1061 16 00			LD	D,00h		;Set up 
1063 cd 6b 10			CALL	HEXCON		;Get byte and convert to hex 
1066 87				ADD	A,A		;First nibble so 
1067 87				ADD	A,A		;multiply by 16 
1068 87				ADD	A,A		; 
1069 87				ADD	A,A		; 
106a 57				LD	D,A		;Save hi nibble in D 
106b			HEXCON: 
106b 7e				ld a, (hl)		;Get next chr 
106c 23				inc hl 
106d d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
106f fe 0a			CP	00Ah		;Is it 0-9 ? 
1071 38 02			JR	C,NALPHA	;If so miss next bit 
1073 d6 07			SUB	007h		;Else convert alpha 
1075			NALPHA: 
1075 b2				OR	D		;Add hi nibble back 
1076 c9				RET			; 
1077			 
1077			 
1077			; 
1077			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1077			; Since the routines get_byte and therefore get_nibble are called, only valid 
1077			; characters (0-9a-f) are accepted. 
1077			; 
1077			;get_word        push    af 
1077			;                call    get_byte        ; Get the upper byte 
1077			;                ld      h, a 
1077			;                call    get_byte        ; Get the lower byte 
1077			;                ld      l, a 
1077			;                pop     af 
1077			;                ret 
1077			; 
1077			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1077			; the routine get_nibble is used only valid characters are accepted - the  
1077			; input routine only accepts characters 0-9a-f. 
1077			; 
1077 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1078 7e					ld a,(hl) 
1079 23					inc hl 
107a cd 9f 10		                call    nibble2val      ; Get upper nibble 
107d cb 07		                rlc     a 
107f cb 07		                rlc     a 
1081 cb 07		                rlc     a 
1083 cb 07		                rlc     a 
1085 47			                ld      b, a            ; Save upper four bits 
1086 7e					ld a,(hl) 
1087 cd 9f 10		                call    nibble2val      ; Get lower nibble 
108a b0			                or      b               ; Combine both nibbles 
108b c1			                pop     bc              ; Restore B (and C) 
108c c9			                ret 
108d			; 
108d			; Get a hexadecimal digit from the serial line. This routine blocks until 
108d			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
108d			; to the serial line interface. The lower 4 bits of A contain the value of  
108d			; that particular digit. 
108d			; 
108d			;get_nibble      ld a,(hl)           ; Read a character 
108d			;                call    to_upper        ; Convert to upper case 
108d			;                call    is_hex          ; Was it a hex digit? 
108d			;                jr      nc, get_nibble  ; No, get another character 
108d			 ;               call    nibble2val      ; Convert nibble to value 
108d			 ;               call    print_nibble 
108d			 ;               ret 
108d			; 
108d			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
108d			; A valid hexadecimal digit is denoted by a set C flag. 
108d			; 
108d			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
108d			;                ret     nc              ; Yes 
108d			;                cp      '0'             ; Less than '0'? 
108d			;                jr      nc, is_hex_1    ; No, continue 
108d			;                ccf                     ; Complement carry (i.e. clear it) 
108d			;                ret 
108d			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
108d			;                ret     c               ; Yes 
108d			;                cp      'A'             ; Less than 'A'? 
108d			;                jr      nc, is_hex_2    ; No, continue 
108d			;                ccf                     ; Yes - clear carry and return 
108d			;                ret 
108d			;is_hex_2        scf                     ; Set carry 
108d			;                ret 
108d			; 
108d			; Convert a single character contained in A to upper case: 
108d			; 
108d fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
108f d8			                ret     c 
1090 fe 7b		                cp      'z' + 1         ; > 'z'? 
1092 d0			                ret     nc              ; Nothing to do, either 
1093 e6 5f		                and     $5f             ; Convert to upper case 
1095 c9			                ret 
1096			 
1096			 
1096			to_lower: 
1096			 
1096			   ; if char is in [A-Z] make it lower case 
1096			 
1096			   ; enter : a = char 
1096			   ; exit  : a = lower case char 
1096			   ; uses  : af 
1096			 
1096 fe 41		   cp 'A' 
1098 d8			   ret c 
1099			    
1099 fe 5b		   cp 'Z'+1 
109b d0			   ret nc 
109c			    
109c f6 20		   or $20 
109e c9			   ret 
109f			 
109f			; 
109f			; Expects a hexadecimal digit (upper case!) in A and returns the 
109f			; corresponding value in A. 
109f			; 
109f fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
10a1 38 02		                jr      c, nibble2val_1 ; Yes 
10a3 d6 07		                sub     7               ; Adjust for A-F 
10a5 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
10a7 e6 0f		                and     $f              ; Only return lower 4 bits 
10a9 c9			                ret 
10aa			; 
10aa			; Print_nibble prints a single hex nibble which is contained in the lower  
10aa			; four bits of A: 
10aa			; 
10aa			;print_nibble    push    af              ; We won't destroy the contents of A 
10aa			;                and     $f              ; Just in case... 
10aa			;                add     a, '0'             ; If we have a digit we are done here. 
10aa			;                cp      '9' + 1         ; Is the result > 9? 
10aa			;                jr      c, print_nibble_1 
10aa			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
10aa			;print_nibble_1  call    putc            ; Print the nibble and 
10aa			;                pop     af              ; restore the original value of A 
10aa			;                ret 
10aa			;; 
10aa			;; Send a CR/LF pair: 
10aa			; 
10aa			;crlf            push    af 
10aa			;                ld      a, cr 
10aa			;                call    putc 
10aa			;                ld      a, lf 
10aa			;                call    putc 
10aa			;                pop     af 
10aa			;                ret 
10aa			; 
10aa			; Print_word prints the four hex digits of a word to the serial line. The  
10aa			; word is expected to be in HL. 
10aa			; 
10aa			;print_word      push    hl 
10aa			;                push    af 
10aa			;                ld      a, h 
10aa			;                call    print_byte 
10aa			;                ld      a, l 
10aa			;                call    print_byte 
10aa			;                pop     af 
10aa			;                pop     hl 
10aa			;                ret 
10aa			; 
10aa			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
10aa			; The byte to be printed is expected to be in A. 
10aa			; 
10aa			;print_byte      push    af              ; Save the contents of the registers 
10aa			;                push    bc 
10aa			;                ld      b, a 
10aa			;                rrca 
10aa			;                rrca 
10aa			;                rrca 
10aa			;                rrca 
10aa			;                call    print_nibble    ; Print high nibble 
10aa			;                ld      a, b 
10aa			;                call    print_nibble    ; Print low nibble 
10aa			;                pop     bc              ; Restore original register contents 
10aa			;                pop     af 
10aa			;                ret 
10aa			 
10aa			 
10aa			 
10aa			 
10aa			 
10aa			fourehexhl:  
10aa 7e				ld a,(hl) 
10ab cd 59 10			call atohex 
10ae cb 3f				SRL A 
10b0 cb 3f				SRL A 
10b2 cb 3f				SRL A 
10b4 cb 3f				SRL A 
10b6 47				ld b, a 
10b7 23				inc hl 
10b8 7e				ld a,(hl) 
10b9 23				inc hl 
10ba cd 59 10			call atohex 
10bd 80				add b 
10be 57				ld d,a 
10bf 7e				ld a,(hl) 
10c0 cd 59 10			call atohex 
10c3 cb 3f				SRL A 
10c5 cb 3f				SRL A 
10c7 cb 3f				SRL A 
10c9 cb 3f				SRL A 
10cb 47				ld b, a 
10cc 23				inc hl 
10cd 7e				ld a,(hl) 
10ce 23				inc hl 
10cf cd 59 10			call atohex 
10d2 80				add b 
10d3 5f				ld e, a 
10d4 d5				push de 
10d5 e1				pop hl 
10d6 c9				ret 
10d7			 
10d7			; pass hl. returns z set if the byte at hl is a digit 
10d7			;isdigithl:  
10d7			;	push bc 
10d7			;	ld a,(hl) 
10d7			;	cp ':' 
10d7			;	jr nc, .isdf 		; > 
10d7			;	cp '0' 
10d7			;	jr c, .isdf		; < 
10d7			; 
10d7			;	; TODO find a better way to set z 
10d7			; 
10d7			;	ld b,a 
10d7			;	cp b 
10d7			;	pop bc 
10d7			;	ret 
10d7			; 
10d7			;.isdf:	; not digit so clear z 
10d7			; 
10d7			;	; TODO find a better way to unset z 
10d7			; 
10d7			;	ld b,a 
10d7			;	inc b 
10d7			;	cp b 
10d7			; 
10d7			;	pop bc 
10d7			;	ret 
10d7				 
10d7				 
10d7			 
10d7			 
10d7			; pass hl as the four byte address to load 
10d7			 
10d7			get_word_hl:  
10d7 e5				push hl 
10d8 cd 77 10			call get_byte 
10db				 
10db 47				ld b, a 
10dc			 
10dc e1				pop hl 
10dd 23				inc hl 
10de 23				inc hl 
10df			 
10df			; TODO not able to handle a-f  
10df 7e				ld a,(hl) 
10e0			;	;cp ':' 
10e0			;	cp 'g' 
10e0			;	jr nc, .single_byte_hl 		; > 
10e0			;	cp 'G' 
10e0			;	jr nc, .single_byte_hl 		; > 
10e0			;	cp '0' 
10e0			;	jr c, .single_byte_hl		; < 
10e0			 
10e0				;call isdigithl 
10e0 fe 00			cp 0 
10e2 28 06			jr z, .single_byte_hl 
10e4			 
10e4			.getwhln:   ; hex word so get next byte 
10e4			 
10e4 cd 77 10			call get_byte 
10e7 6f				ld l, a 
10e8 60				ld h,b 
10e9 c9				ret 
10ea 68			.single_byte_hl:   ld l,b 
10eb 26 00				ld h,0 
10ed c9					ret 
10ee			 
10ee			 
10ee			 
10ee			 
10ee 21 1b 1a			ld hl,asc+1 
10f1			;	ld a, (hl) 
10f1			;	call nibble2val 
10f1 cd 77 10			call get_byte 
10f4			 
10f4			;	call fourehexhl 
10f4 32 51 ee			ld (scratch+52),a 
10f7				 
10f7 21 4f ee			ld hl,scratch+50 
10fa 22 40 f1			ld (os_cur_ptr),hl 
10fd			 
10fd c9				ret 
10fe			 
10fe			 
10fe			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10fe			 
10fe			; Decimal Unsigned Version 
10fe			 
10fe			;Number in a to decimal ASCII 
10fe			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10fe			;Example: display a=56 as "056" 
10fe			;input: a = number 
10fe			;Output: a=0,value of a in the screen 
10fe			;destroys af,bc (don't know about hl and de) 
10fe			DispAToASCII: 
10fe 0e 9c			ld	c,-100 
1100 cd 0a 11			call	.Na1 
1103 0e f6			ld	c,-10 
1105 cd 0a 11			call	.Na1 
1108 0e ff			ld	c,-1 
110a 06 2f		.Na1:	ld	b,'0'-1 
110c 04			.Na2:	inc	b 
110d 81				add	a,c 
110e 38 fc			jr	c,.Na2 
1110 91				sub	c		;works as add 100/10/1 
1111 f5				push af		;safer than ld c,a 
1112 78				ld	a,b		;char is in b 
1113			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1113 f1				pop af		;safer than ld a,c 
1114 c9				ret 
1115			 
1115			; Decimal Signed Version 
1115			 
1115			; DispA 
1115			; -------------------------------------------------------------- 
1115			; Converts a signed integer value to a zero-terminated ASCII 
1115			; string representative of that value (using radix 10). 
1115			; -------------------------------------------------------------- 
1115			; INPUTS: 
1115			;     HL     Value to convert (two's complement integer). 
1115			;     DE     Base address of string destination. (pointer). 
1115			; -------------------------------------------------------------- 
1115			; OUTPUTS: 
1115			;     None 
1115			; -------------------------------------------------------------- 
1115			; REGISTERS/MEMORY DESTROYED 
1115			; AF HL 
1115			; -------------------------------------------------------------- 
1115			 
1115			;DispHLToASCII: 
1115			;   push    de 
1115			;   push    bc 
1115			; 
1115			;; Detect sign of HL. 
1115			;    bit    7, h 
1115			;    jr     z, ._DoConvert 
1115			; 
1115			;; HL is negative. Output '-' to string and negate HL. 
1115			;    ld     a, '-' 
1115			;    ld     (de), a 
1115			;    inc    de 
1115			; 
1115			;; Negate HL (using two's complement) 
1115			;    xor    a 
1115			;    sub    l 
1115			;    ld     l, a 
1115			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1115			;    sbc    a, h 
1115			;    ld     h, a 
1115			; 
1115			;; Convert HL to digit characters 
1115			;._DoConvert: 
1115			;    ld     b, 0     ; B will count character length of number 
1115			;-   ld     a, 10 
1115			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1115			;    push   af 
1115			;    inc    b 
1115			;    ld     a, h 
1115			;    or     l 
1115			;    jr     nz, - 
1115			; 
1115			;; Retrieve digits from stack 
1115			;-   pop    af 
1115			;    or     $30 
1115			;    ld     (de), a 
1115			;    inc    de 
1115			;    djnz   - 
1115			; 
1115			;; Terminate string with NULL 
1115			;    xor    a 
1115			;    ld     (de), a 
1115			; 
1115			;    pop    bc 
1115			;    pop    de 
1115			;    ret 
1115			 
1115			;Comments 
1115			; 
1115			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1115			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1115			;    Note that the output string will not be fixed-width. 
1115			; 
1115			;Example Usage 
1115			; 
1115			;    ld    hl, -1004 
1115			;    ld    de, OP1 
1115			;    call  DispA 
1115			;    ld    hl, OP1 
1115			;    syscall  PutS 
1115			 
1115			 
1115			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1115			 
1115			 
1115			;Converts an ASCII string to an unsigned 16-bit integer 
1115			;Quits when it reaches a non-decimal digit 
1115			 
1115			string_to_uint16: 
1115			atoui_16: 
1115			;Input: 
1115			;     DE points to the string 
1115			;Outputs: 
1115			;     HL is the result 
1115			;     A is the 8-bit value of the number 
1115			;     DE points to the byte after the number 
1115			;Destroys: 
1115			;     BC 
1115			;       if the string is non-empty, BC is HL/10 
1115			;Size:  24 bytes 
1115			;Speed: 42+d(104+{0,9}) 
1115			;       d is the number of digits in the number 
1115			;       max is 640 cycles for a 5 digit number 
1115			;Assuming no leading zeros: 
1115			;1 digit:  146cc 
1115			;2 digit:  250cc 
1115			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1115			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1115			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1115			;avg: 544.81158447265625cc (544+13297/16384) 
1115			;=============================================================== 
1115 21 00 00		  ld hl,0 
1118			.u16a: 
1118 1a			  ld a,(de) 
1119 d6 30		  sub 30h 
111b fe 0a		  cp 10 
111d d0			  ret nc 
111e 13			  inc de 
111f 44			  ld b,h 
1120 4d			  ld c,l 
1121 29			  add hl,hl 
1122 29			  add hl,hl 
1123 09			  add hl,bc 
1124 29			  add hl,hl 
1125 85			  add a,l 
1126 6f			  ld l,a 
1127 30 ef		  jr nc,.u16a 
1129 24			  inc h 
112a c3 18 11		  jp .u16a 
112d			 
112d			 
112d			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
112d			 
112d			;written by Zeda 
112d			;Converts a 16-bit unsigned integer to an ASCII string. 
112d			 
112d			uitoa_16: 
112d			;Input: 
112d			;   DE is the number to convert 
112d			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
112d			;Output: 
112d			;   HL points to the null-terminated ASCII string 
112d			;      NOTE: This isn't necessarily the same as the input HL. 
112d d5			  push de 
112e c5			  push bc 
112f f5			  push af 
1130 eb			  ex de,hl 
1131			 
1131 01 f0 d8		  ld bc,-10000 
1134 3e 2f		  ld a,'0'-1 
1136 3c			  inc a 
1137 09			  add hl,bc  
1138 38 fc		   jr c,$-2 
113a 12			  ld (de),a 
113b 13			  inc de 
113c			 
113c 01 e8 03		  ld bc,1000 
113f 3e 3a		  ld a,'9'+1 
1141 3d			  dec a  
1142 09			  add hl,bc  
1143 30 fc		   jr nc,$-2 
1145 12			  ld (de),a 
1146 13			  inc de 
1147			 
1147 01 9c ff		  ld bc,-100 
114a 3e 2f		  ld a,'0'-1 
114c 3c			  inc a  
114d 09			  add hl,bc  
114e 38 fc		   jr c,$-2 
1150 12			  ld (de),a 
1151 13			  inc de 
1152			 
1152 7d			  ld a,l 
1153 26 3a		  ld h,'9'+1 
1155 25			  dec h  
1156 c6 0a		  add a,10  
1158 30 fb		   jr nc,$-3 
115a c6 30		  add a,'0' 
115c eb			  ex de,hl 
115d 72			  ld (hl),d 
115e 23			  inc hl 
115f 77			  ld (hl),a 
1160 23			  inc hl 
1161 36 00		  ld (hl),0 
1163			 
1163			;Now strip the leading zeros 
1163 0e fa		  ld c,-6 
1165 09			  add hl,bc 
1166 3e 30		  ld a,'0' 
1168 23			  inc hl  
1169 be			  cp (hl)  
116a 28 fc		  jr z,$-2 
116c			 
116c			;Make sure that the string is non-empty! 
116c 7e			  ld a,(hl) 
116d b7			  or a 
116e 20 01		  jr nz,.atoub 
1170 2b			  dec hl 
1171			.atoub: 
1171			 
1171 f1			  pop af 
1172 c1			  pop bc 
1173 d1			  pop de 
1174 c9			  ret 
1175			 
1175			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1175			 
1175			toUpper: 
1175			;A is the char. 
1175			;If A is a lowercase letter, this sets it to the matching uppercase 
1175			;18cc or 30cc or 41cc 
1175			;avg: 26.75cc 
1175 fe 61		  cp 'a' 
1177 d8			  ret c 
1178 fe 7b		  cp 'z'+1 
117a d0			  ret nc 
117b d6 20		  sub 'a'-'A' 
117d c9			  ret 
117e			 
117e			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
117e			 
117e			; String Length 
117e			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
117e			 
117e			; Get the length of the null-terminated string starting at $8000 hl 
117e			;    LD     HL, $8000 
117e			 
117e			strlenz: 
117e			 
117e af			    XOR    A               ; Zero is the value we are looking for. 
117f 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1180 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1181			                           ; 65, 536 bytes (the entire addressable memory space). 
1181 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1183			 
1183			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1183 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1184 6f			    LD     L, A             ; number of bytes 
1185 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1187 2b			    DEC    HL              ; Compensate for null. 
1188 c9				ret 
1189			 
1189			; Get the length of the A terminated string starting at $8000 hl 
1189			;    LD     HL, $8000 
1189			 
1189			strlent: 
1189			 
1189			                  ; A is the value we are looking for. 
1189 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
118b 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
118d			                           ; 65, 536 bytes (the entire addressable memory space). 
118d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
118f			 
118f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
118f 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1191 2e 00		    LD     L, 0             ; number of bytes 
1193 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1195 2b			    DEC    HL              ; Compensate for null. 
1196 c9				ret 
1197			 
1197			 
1197			;Comparing Strings 
1197			 
1197			;IN    HL     Address of string1. 
1197			;      DE     Address of string2. 
1197			 
1197			; doc given but wrong??? 
1197			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1197			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1197			; tested 
1197			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1197			 
1197			strcmp_old: 
1197 e5			    PUSH   HL 
1198 d5			    PUSH   DE 
1199			 
1199 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
119a be			    CP     (HL)            ; (want to minimize work). 
119b 38 01		    JR     C, Str1IsBigger 
119d 7e			    LD     A, (HL) 
119e			 
119e			Str1IsBigger: 
119e 4f			    LD     C, A             ; Put length in BC 
119f 06 00		    LD     B, 0 
11a1 13			    INC    DE              ; Increment pointers to meat of string. 
11a2 23			    INC    HL 
11a3			 
11a3			CmpLoop: 
11a3 1a			    LD     A, (DE)          ; Compare bytes. 
11a4 ed a1		    CPI 
11a6 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
11a8 13			    INC    DE              ; Update pointer. 
11a9 ea a3 11		    JP     PE, CmpLoop 
11ac			 
11ac d1			    POP    DE 
11ad e1			    POP    HL 
11ae 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
11af be			    CP     (HL) 
11b0 c9			    RET 
11b1			 
11b1			NoMatch: 
11b1 2b			    DEC    HL 
11b2 be			    CP     (HL)            ; Compare again to affect carry. 
11b3 d1			    POP    DE 
11b4 e1			    POP    HL 
11b5 c9			    RET 
11b6			 
11b6			;; test strmp 
11b6			; 
11b6			;ld de, .str1 
11b6			;ld hl, .str2 
11b6			;call strcmp 
11b6			;jr z, .z1 
11b6			;;this 
11b6			;	if DEBUG_FORTH_WORDS 
11b6			;		DMARK "NZ1" 
11b6			;		CALLMONITOR 
11b6			;	endif 
11b6			;.z1: 
11b6			; 
11b6			;	if DEBUG_FORTH_WORDS 
11b6			;		DMARK "ZZ1" 
11b6			;		CALLMONITOR 
11b6			;	endif 
11b6			; 
11b6			;ld de, .str1 
11b6			;ld hl, .str1 
11b6			;call strcmp 
11b6			;jr z, .z2 
11b6			;;this 
11b6			;	if DEBUG_FORTH_WORDS 
11b6			;		DMARK "NZ2" 
11b6			;		CALLMONITOR 
11b6			;	endif 
11b6			;.z2: 
11b6			; 
11b6			;	if DEBUG_FORTH_WORDS 
11b6			;		DMARK "ZZ2" 
11b6			;		CALLMONITOR 
11b6			;	endif 
11b6			; 
11b6			;ld de, .str1 
11b6			;ld hl, .str2 
11b6			;call strcmp 
11b6			;jr c, .c1 
11b6			; 
11b6			;	if DEBUG_FORTH_WORDS 
11b6			;		DMARK "Nc1" 
11b6			;		CALLMONITOR 
11b6			;	endif 
11b6			;.c1: 
11b6			;;this 
11b6			;	if DEBUG_FORTH_WORDS 
11b6			;		DMARK "cc1" 
11b6			;		CALLMONITOR 
11b6			;	endif 
11b6			; 
11b6			;ld de, .str1 
11b6			;ld hl, .str1 
11b6			;call strcmp 
11b6			;jr c, .c2 
11b6			;;this 
11b6			;	if DEBUG_FORTH_WORDS 
11b6			;		DMARK "Nc2" 
11b6			;		CALLMONITOR 
11b6			;	endif 
11b6			;.c2: 
11b6			; 
11b6			;	if DEBUG_FORTH_WORDS 
11b6			;		DMARK "cc2" 
11b6			;		CALLMONITOR 
11b6			;	endif 
11b6			;	NEXTW 
11b6			;.str1:   db "string1",0 
11b6			;.str2:   db "string2",0 
11b6			 
11b6			; only care about direct match or not 
11b6			; hl and de strings 
11b6			; zero set if the same 
11b6			 
11b6			strcmp: 
11b6 1a				ld a, (de) 
11b7 be				cp (hl) 
11b8 28 02			jr z, .ssame 
11ba b7				or a 
11bb c9				ret 
11bc			 
11bc			.ssame:  
11bc fe 00			cp 0 
11be c8				ret z 
11bf			 
11bf 23				inc hl 
11c0 13				inc de 
11c1 18 f3			jr strcmp 
11c3				 
11c3				 
11c3			 
11c3			 
11c3			 
11c3			 
11c3			; eof 
11c3			 
11c3			 
11c3			 
11c3			 
11c3			 
11c3			 
# End of file firmware_strings.asm
11c3			include "firmware_memory.asm"   ; malloc and free  
11c3			 
11c3			if DEBUG_FORTH_MALLOC_HIGH 
11c3			.mallocsize: db "Wants malloc >256",0 
11c3			.mallocasize: db "MALLOC gives >256",0 
11c3			.malloczero: db "MALLOC gives zero",0 
11c3			 
11c3			malloc_guard_zerolen: 
11c3				push hl 
11c3				push de 
11c3				push af 
11c3			 
11c3				ld de, 0 
11c3			        call cmp16 
11c3				jr nz, .lowalloz 
11c3			 
11c3				push hl 
11c3				push de 
11c3					ld hl, display_fb0 
11c3					ld (display_fb_active), hl 
11c3				call clear_display 
11c3				ld a, 0 
11c3				ld de, .malloczero 
11c3				call str_at_display 
11c3				call update_display 
11c3				call delay1s 
11c3				call delay1s 
11c3				ld a, 0 
11c3				ld (os_view_disable), a 
11c3			 
11c3				pop de 
11c3				pop hl 
11c3			 
11c3				 
11c3			 
11c3				CALLMONITOR 
11c3			.lowalloz: 
11c3			 
11c3			 
11c3				pop af 
11c3				pop de 
11c3				pop hl 
11c3			ret 
11c3			 
11c3			malloc_guard_entry: 
11c3				push hl 
11c3				push de 
11c3				push af 
11c3			 
11c3			 	or a      ;clear carry flag 
11c3				push hl 
11c3				ld de, 255 
11c3				sbc hl, de 
11c3				jr c, .lowalloc 
11c3			 
11c3				push de 
11c3					ld hl, display_fb0 
11c3					ld (display_fb_active), hl 
11c3				call clear_display 
11c3				ld a, 0 
11c3				ld de, .mallocsize 
11c3				call str_at_display 
11c3				call update_display 
11c3				call delay1s 
11c3				call delay1s 
11c3				ld a, 0 
11c3				ld (os_view_disable), a 
11c3			 
11c3				pop de 
11c3				pop hl 
11c3			 
11c3				 
11c3			 
11c3				CALLMONITOR 
11c3				jr .lowdone 
11c3			.lowalloc: 
11c3			 
11c3			 
11c3				pop hl 
11c3			.lowdone:	pop af 
11c3				pop de 
11c3				pop hl 
11c3			ret 
11c3			 
11c3			malloc_guard_exit: 
11c3				push hl 
11c3				push de 
11c3				push af 
11c3			 
11c3			 	or a      ;clear carry flag 
11c3				push hl 
11c3				ld de, 255 
11c3				sbc hl, de 
11c3				jr c, .lowallocx 
11c3			 
11c3				push de 
11c3					ld hl, display_fb0 
11c3					ld (display_fb_active), hl 
11c3				call clear_display 
11c3				ld a, 0 
11c3				ld de, .mallocasize 
11c3				call str_at_display 
11c3				call update_display 
11c3				call delay1s 
11c3				call delay1s 
11c3				ld a, 0 
11c3				ld (os_view_disable), a 
11c3				pop de 
11c3				pop hl 
11c3			 
11c3				CALLMONITOR 
11c3				jr .lowdonex 
11c3			.lowallocx: 
11c3			 
11c3				pop hl 
11c3			.lowdonex:	pop af 
11c3				pop de 
11c3				pop hl 
11c3			ret 
11c3			endif 
11c3			 
11c3			if MALLOC_2 
11c3			; Z80 Malloc and Free Functions 
11c3			 
11c3			; Malloc Function: 
11c3			; Input: 
11c3			;   HL: Size of block to allocate 
11c3			; Output: 
11c3			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11c3			 
11c3			malloc: 
11c3				 
11c3			if DEBUG_FORTH_MALLOC_HIGH 
11c3			call malloc_guard_entry 
11c3			endif 
11c3			 
11c3			 
11c3			 
11c3			 
11c3					if DEBUG_FORTH_MALLOC 
11c3						DMARK "mal" 
11c3						CALLMONITOR 
11c3					endif 
11c3			    push af            ; Save AF register 
11c3			    ld a, l            ; Load low byte of size into A 
11c3			    or h               ; Check if size is zero 
11c3			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11c3			 
11c3			    ; Allocate memory 
11c3			    ld hl, (heap_start) ; Load start of heap into HL 
11c3					if DEBUG_FORTH_MALLOC 
11c3						DMARK "ma1" 
11c3						CALLMONITOR 
11c3					endif 
11c3			    call malloc_internal ; Call internal malloc function 
11c3			    pop af             ; Restore AF register 
11c3			if DEBUG_FORTH_MALLOC_HIGH 
11c3			call malloc_guard_exit 
11c3			call malloc_guard_zerolen 
11c3			endif 
11c3			    ret                ; Return 
11c3			 
11c3			; Free Function: 
11c3			; Input: 
11c3			;   HL: Pointer to memory block to free 
11c3			; Output: 
11c3			;   None 
11c3			 
11c3			free: 
11c3			    push af            ; Save AF register 
11c3			    ld a, l            ; Load low byte of pointer into A 
11c3			    or h               ; Check if pointer is NULL 
11c3			    jp z, free_exit    ; If pointer is NULL, exit 
11c3			 
11c3			    ; Free memory 
11c3			    ld hl, (heap_start) ; Load start of heap into HL 
11c3			    call free_internal  ; Call internal free function 
11c3			    pop af             ; Restore AF register 
11c3			    ret                ; Return 
11c3			 
11c3			; Internal Malloc Function: 
11c3			; Input: 
11c3			;   HL: Size of block to allocate 
11c3			; Output: 
11c3			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11c3			 
11c3			malloc_internal: 
11c3			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11c3			    add hl, bc         ; Add management overhead to requested size 
11c3			    ex de, hl          ; Save total size in DE, and keep it in HL 
11c3					if DEBUG_FORTH_MALLOC 
11c3						DMARK "ma2" 
11c3						CALLMONITOR 
11c3					endif 
11c3			 
11c3			    ; Search for free memory block 
11c3			    ld de, (heap_end)  ; Load end of heap into DE 
11c3			    ld bc, 0           ; Initialize counter 
11c3			 
11c3					if DEBUG_FORTH_MALLOC 
11c3						DMARK "ma2" 
11c3						CALLMONITOR 
11c3					endif 
11c3			malloc_search_loop: 
11c3			    ; Check if current block is free 
11c3			    ld a, (hl)         ; Load current block's status (free or used) 
11c3			    cp 0               ; Compare with zero (free) 
11c3			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11c3			 
11c3			    ; Check if current block is large enough 
11c3			    ld a, (hl+1)       ; Load high byte of block size 
11c3			    cp l               ; Compare with low byte of requested size 
11c3			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11c3			 
11c3			    ld a, (hl+2)       ; Load low byte of block size 
11c3			    cp h               ; Compare with high byte of requested size 
11c3			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11c3			 
11c3			    ; Mark block as used 
11c3			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11c3			 
11c3			    ; Calculate remaining space in block 
11c3			    ld bc, 0           ; Clear BC 
11c3			    add hl, bc         ; Increment HL to point to start of data block 
11c3			    add hl, de         ; HL = HL + DE (total size) 
11c3			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11c3			    add hl, bc         ; Add management overhead to start of data block 
11c3			 
11c3			    ; Save pointer to allocated block in HL 
11c3			if DEBUG_FORTH_MALLOC_HIGH 
11c3						DMARK "ma5" 
11c3			call malloc_guard_exit 
11c3			call malloc_guard_zerolen 
11c3			endif 
11c3			    ret 
11c3			 
11c3			malloc_skip_block_check: 
11c3			    ; Move to the next block 
11c3			    ld bc, 3           ; Size of management overhead 
11c3			    add hl, bc         ; Move to the next block 
11c3			    inc de             ; Increment counter 
11c3			 
11c3			    ; Check if we have reached the end of heap 
11c3			    ld a, e            ; Load low byte of heap end address 
11c3			    cp (hl)            ; Compare with low byte of current address 
11c3			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11c3			    ld a, d            ; Load high byte of heap end address 
11c3			    cp 0               ; Check if it's zero (end of memory) 
11c3			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11c3			 
11c3			    ; If we reached here, allocation failed 
11c3			    xor a              ; Set result to NULL 
11c3			if DEBUG_FORTH_MALLOC_HIGH 
11c3						DMARK "ma6" 
11c3			call malloc_guard_exit 
11c3			call malloc_guard_zerolen 
11c3			endif 
11c3			    ret 
11c3			malloc_exit: 
11c3			if DEBUG_FORTH_MALLOC_HIGH 
11c3						DMARK "ma7" 
11c3			call malloc_guard_exit 
11c3			call malloc_guard_zerolen 
11c3			endif 
11c3			    ret 
11c3			 
11c3			; Internal Free Function: 
11c3			; Input: 
11c3			;   HL: Pointer to memory block to free 
11c3			; Output: 
11c3			;   None 
11c3			 
11c3			free_internal: 
11c3			    ld de, (heap_start) ; Load start of heap into DE 
11c3			    ld bc, 0            ; Initialize counter 
11c3			 
11c3			free_search_loop: 
11c3			    ; Check if current block contains the pointer 
11c3			    ld a, l             ; Load low byte of pointer 
11c3			    cp (hl+1)           ; Compare with high byte of current block's address 
11c3			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11c3			    ld a, h             ; Load high byte of pointer 
11c3			    cp (hl+2)           ; Compare with low byte of current block's address 
11c3			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11c3			 
11c3			    ; Mark block as free 
11c3			    ld (hl), 0          ; Set status byte to indicate free block 
11c3			    ret                 ; Return 
11c3			 
11c3			free_skip_block_check: 
11c3			    ; Move to the next block 
11c3			    ld bc, 3            ; Size of management overhead 
11c3			    add hl, bc          ; Move to the next block 
11c3			    inc de              ; Increment counter 
11c3			 
11c3			    ; Check if we have reached the end of heap 
11c3			    ld a, e             ; Load low byte of heap end address 
11c3			    cp (hl)             ; Compare with low byte of current address 
11c3			    jr nz, free_search_loop  ; If not equal, continue searching 
11c3			    ld a, d             ; Load high byte of heap end address 
11c3			    cp 0                ; Check if it's zero (end of memory) 
11c3			    jr nz, free_search_loop  ; If not zero, continue searching 
11c3			 
11c3			    ; If we reached here, pointer is not found in heap 
11c3			    ret 
11c3			 
11c3			free_exit: 
11c3			    ret                 ; Return 
11c3			 
11c3			; Define heap start and end addresses 
11c3			;heap_start:    .dw 0xC000   ; Start of heap 
11c3			;heap_end:      .dw 0xE000   ; End of heap 
11c3			 
11c3			endif 
11c3			 
11c3			 
11c3			if MALLOC_1 
11c3			 
11c3			 
11c3			 
11c3			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11c3			 
11c3			;moved to firmware.asm 
11c3			;heap_start        .equ  0x9000      ; Starting address of heap 
11c3			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11c3			 
11c3			;      .org 0 
11c3			;      jp    main 
11c3			 
11c3			 
11c3			;      .org  0x100 
11c3			;main: 
11c3			;      ld    HL, 0x8100 
11c3			;      ld    SP, HL 
11c3			; 
11c3			;      call  heap_init 
11c3			; 
11c3			;      ; Make some allocations 
11c3			;      ld    HL, 12 
11c3			;      call  malloc            ; Allocates 0x9004 
11c3			; 
11c3			;      ld    HL, 12 
11c3			;      call  malloc            ; Allocates 0x9014 
11c3			; 
11c3			;      ld    HL, 12 
11c3			;      call  malloc            ; Allocates 0x9024 
11c3			; 
11c3			;      ; Free some allocations 
11c3			;      ld    HL, 0x9014 
11c3			;      call  free 
11c3			; 
11c3			;      ld    HL, 0x9004 
11c3			;      call  free 
11c3			; 
11c3			;      ld    HL, 0x9024 
11c3			;      call  free 
11c3			; 
11c3			; 
11c3			;      halt 
11c3			 
11c3			 
11c3			;------------------------------------------------------------------------------ 
11c3			;     heap_init                                                               : 
11c3			;                                                                             : 
11c3			; Description                                                                 : 
11c3			;     Initialise the heap and make it ready for malloc and free operations.   : 
11c3			;                                                                             : 
11c3			;     The heap is maintained as a linked list, starting with an initial       : 
11c3			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11c3			;     the first free block in the heap. Each block then points to the next    : 
11c3			;     free block within the heap, and the free list ends at the first block   : 
11c3			;     with a null pointer to the next free block.                             : 
11c3			;                                                                             : 
11c3			; Parameters                                                                  : 
11c3			;     Inputs are compile-time only. Two defines which specify the starting    : 
11c3			;     address of the heap and its size are required, along with a memory      : 
11c3			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11c3			;     principally stores a pointer to the first free block in the heap.       : 
11c3			;                                                                             : 
11c3			; Returns                                                                     : 
11c3			;     Nothing                                                                 : 
11c3			;------------------------------------------------------------------------------ 
11c3			heap_init: 
11c3 e5			      push  HL 
11c4			 
11c4			      ; Initialise free list struct 
11c4 21 0e 80		      ld    HL, heap_start 
11c7 22 0a 80		      ld    (free_list), HL 
11ca 21 00 00		      ld    HL, 0 
11cd 22 0c 80		      ld    (free_list+2), HL 
11d0			 
11d0			      ; Insert first free block at bottom of heap, consumes entire heap 
11d0 21 ff ed		      ld    HL, heap_start+heap_size-4 
11d3 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11d6 21 f1 6d		      ld    HL, heap_size-4 
11d9 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11dc			 
11dc			      ; Insert end of free list block at top of heap - two null words will 
11dc			      ; terminate the free list 
11dc 21 00 00		      ld    HL, 0 
11df 22 01 ee		      ld    (heap_start+heap_size-2), HL 
11e2 22 ff ed		      ld    (heap_start+heap_size-4), HL 
11e5			 
11e5 e1			      pop   HL 
11e6			 
11e6 c9			      ret 
11e7			 
11e7			 
11e7			;------------------------------------------------------------------------------ 
11e7			;     malloc                                                                  : 
11e7			;                                                                             : 
11e7			; Description                                                                 : 
11e7			;     Allocates the wanted space from the heap and returns the address of the : 
11e7			;     first useable byte of the allocation.                                   : 
11e7			;                                                                             : 
11e7			;     Allocations can happen in one of two ways:                              : 
11e7			;                                                                             : 
11e7			;     1. A free block may be found which is the exact size wanted. In this    : 
11e7			;        case the block is removed from the free list and retuedn to the      : 
11e7			;        caller.                                                              : 
11e7			;     2. A free block may be found which is larger than the size wanted. In   : 
11e7			;        this case, the larger block is split into two. The first portion of  : 
11e7			;        this block will become the requested space by the malloc call and    : 
11e7			;        is returned to the caller. The second portion becomes a new free     : 
11e7			;        block, and the free list is adjusted to maintain continuity via this : 
11e7			;        newly created block.                                                 : 
11e7			;                                                                             : 
11e7			;     malloc does not set any initial value in the allocated space, the       : 
11e7			;     caller is required to do this as required.                              : 
11e7			;                                                                             : 
11e7			;     This implementation of malloc uses the stack exclusively, and is        : 
11e7			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11e7			;     advisable to disable interrupts before calling malloc, and recommended  : 
11e7			;     to avoid the use of malloc inside ISRs in general.                      : 
11e7			;                                                                             : 
11e7			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11e7			;                                                                             : 
11e7			; Parameters                                                                  : 
11e7			;     HL  Number of bytes wanted                                              : 
11e7			;                                                                             : 
11e7			; Returns                                                                     : 
11e7			;     HL  Address of the first useable byte of the allocation                 : 
11e7			;                                                                             : 
11e7			; Flags                                                                       : 
11e7			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11e7			;                                                                             : 
11e7			; Stack frame                                                                 : 
11e7			;       |             |                                                       : 
11e7			;       +-------------+                                                       : 
11e7			;       |     BC      |                                                       : 
11e7			;       +-------------+                                                       : 
11e7			;       |     DE      |                                                       : 
11e7			;       +-------------+                                                       : 
11e7			;       |     IX      |                                                       : 
11e7			;       +-------------+                                                       : 
11e7			;       |  prev_free  |                                                       : 
11e7			;   +4  +-------------+                                                       : 
11e7			;       |  this_free  |                                                       : 
11e7			;   +2  +-------------+                                                       : 
11e7			;       |  next_free  |                                                       : 
11e7			;   +0  +-------------+                                                       : 
11e7			;       |             |                                                       : 
11e7			;                                                                             : 
11e7			;------------------------------------------------------------------------------ 
11e7			 
11e7			 
11e7			;malloc: 
11e7			; 
11e7			;	SAVESP ON 1 
11e7			; 
11e7			;	call malloc_code 
11e7			; 
11e7			;	CHECKSP ON 1 
11e7			;	ret 
11e7			 
11e7			 
11e7			malloc: 
11e7 c5			      push  BC 
11e8 d5			      push  DE 
11e9 dd e5		      push  IX 
11eb			if DEBUG_FORTH_MALLOC_HIGH 
11eb			call malloc_guard_entry 
11eb			endif 
11eb			 
11eb					if DEBUG_FORTH_MALLOC 
11eb						DMARK "mal" 
11eb						CALLMONITOR 
11eb					endif 
11eb 7c			      ld    A, H                    ; Exit if no space requested 
11ec b5			      or    L 
11ed ca ac 12		      jp    Z, malloc_early_exit 
11f0			 
11f0			;inc hl 
11f0			;inc hl 
11f0			;inc hl 
11f0			; 
11f0			;inc hl 
11f0			;inc hl 
11f0			;inc hl 
11f0			;inc hl 
11f0			;inc hl 
11f0			;inc hl 
11f0			;inc hl 
11f0			;inc hl 
11f0			;inc hl 
11f0			 
11f0			 
11f0			 
11f0			 
11f0					if DEBUG_FORTH_MALLOC 
11f0						DMARK "maA" 
11f0						CALLMONITOR 
11f0					endif 
11f0			      ; Set up stack frame 
11f0 eb			      ex    DE, HL 
11f1 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11f4 39			      add   HL, SP 
11f5 f9			      ld    SP, HL 
11f6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11fa dd 39		      add   IX, SP 
11fc			 
11fc			      ; Setup initial state 
11fc 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11ff 19			      add   HL, DE 
1200			 
1200 44			      ld    B, H                    ; Move want to BC 
1201 4d			      ld    C, L 
1202			 
1202 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
1205 dd 75 04		      ld    (IX+4), L 
1208 dd 74 05		      ld    (IX+5), H 
120b			 
120b 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
120c 23			      inc   HL 
120d 56			      ld    D, (HL) 
120e dd 73 02		      ld    (IX+2), E 
1211 dd 72 03		      ld    (IX+3), D 
1214 eb			      ex    DE, HL                  ; this_free ptr into HL 
1215			 
1215					if DEBUG_FORTH_MALLOC 
1215						DMARK "maB" 
1215						CALLMONITOR 
1215					endif 
1215			      ; Loop through free block list to find some space 
1215			malloc_find_space: 
1215 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1216 23			      inc   HL 
1217 56			      ld    D, (HL) 
1218			 
1218 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1219 b3			      or    E 
121a ca a6 12		      jp    Z, malloc_no_space 
121d			 
121d dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1220 dd 72 01		      ld    (IX+1), D 
1223			 
1223			      ; Does this block have enough space to make the allocation? 
1223 23			      inc   HL                      ; Load free block size into DE 
1224 5e			      ld    E, (HL) 
1225 23			      inc   HL 
1226 56			      ld    D, (HL) 
1227			 
1227 eb			      ex    DE, HL                  ; Check size of block against want 
1228 b7			      or    A                       ; Ensure carry flag clear 
1229 ed 42		      sbc   HL, BC 
122b e5			      push  HL                      ; Store the result for later (new block size) 
122c			 
122c ca 7b 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
122f 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1231			 
1231			      ; this_free block is not big enough, setup ptrs to test next free block 
1231 e1			      pop   HL                      ; Discard previous result 
1232			 
1232 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1235 dd 66 03		      ld    H, (IX+3) 
1238 dd 75 04		      ld    (IX+4), L 
123b dd 74 05		      ld    (IX+5), H 
123e			 
123e dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1241 dd 66 01		      ld    H, (IX+1) 
1244 dd 75 02		      ld    (IX+2), L 
1247 dd 74 03		      ld    (IX+3), H 
124a			 
124a					if DEBUG_FORTH_MALLOC 
124a						DMARK "MA>" 
124a						CALLMONITOR 
124a					endif 
124a 18 c9		      jr    malloc_find_space 
124c			 
124c			      ; split a bigger block into two - requested size and remaining size 
124c			malloc_alloc_split: 
124c					if DEBUG_FORTH_MALLOC 
124c						DMARK "MAs" 
124c						CALLMONITOR 
124c					endif 
124c eb			      ex    DE, HL                  ; Calculate address of new free block 
124d 2b			      dec   HL 
124e 2b			      dec   HL 
124f 2b			      dec   HL 
1250 09			      add   HL, BC 
1251			 
1251			      ; Create a new block and point it at next_free 
1251 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1254 dd 56 01		      ld    D, (IX+1) 
1257			 
1257 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1258 23			      inc   HL 
1259 72			      ld    (HL), D 
125a			 
125a d1			      pop   DE                      ; Store size of new block into new block 
125b 23			      inc   HL 
125c 73			      ld    (HL), E 
125d 23			      inc   HL 
125e 72			      ld    (HL), D 
125f			 
125f			      ; Update this_free ptr to point to new block 
125f 2b			      dec   HL 
1260 2b			      dec   HL 
1261 2b			      dec   HL 
1262			 
1262 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1265 dd 56 03		      ld    D, (IX+3) 
1268			 
1268 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
126b dd 74 03		      ld    (IX+3), H 
126e			 
126e			      ; Modify this_free block to be allocation 
126e eb			      ex    DE, HL 
126f af			      xor   A                       ; Null the next block ptr of allocated block 
1270 77			      ld    (HL), A 
1271 23			      inc   HL 
1272 77			      ld    (HL), A 
1273			 
1273 23			      inc   HL                      ; Store want size into allocated block 
1274 71			      ld    (HL), C 
1275 23			      inc   HL 
1276 70			      ld    (HL), B 
1277 23			      inc   HL 
1278 e5			      push  HL                      ; Address of allocation to return 
1279			 
1279 18 19		      jr    malloc_update_links 
127b			 
127b			malloc_alloc_fit: 
127b e1			      pop   HL                      ; Dont need new block size, want is exact fit 
127c			 
127c					if DEBUG_FORTH_MALLOC 
127c						DMARK "MAf" 
127c						CALLMONITOR 
127c					endif 
127c			      ; Modify this_free block to be allocation 
127c eb			      ex    DE, HL 
127d 2b			      dec   HL 
127e 2b			      dec   HL 
127f 2b			      dec   HL 
1280			 
1280 af			      xor   A                       ; Null the next block ptr of allocated block 
1281 77			      ld    (HL), A 
1282 23			      inc   HL 
1283 77			      ld    (HL), A 
1284			 
1284 23			      inc   HL                      ; Store address of allocation to return 
1285 23			      inc   HL 
1286 23			      inc   HL 
1287 e5			      push  HL 
1288			 
1288			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1288 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
128b dd 66 01		      ld    H, (IX+1) 
128e			 
128e dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1291 dd 74 03		      ld    (IX+3), H 
1294			 
1294			 
1294			malloc_update_links: 
1294			      ; Update prev_free ptr to point to this_free 
1294 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1297 dd 66 05		      ld    H, (IX+5) 
129a			 
129a dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
129d dd 56 03		      ld    D, (IX+3) 
12a0			 
12a0 73			      ld    (HL), E                 ; this_free ptr into prev_free 
12a1 23			      inc   HL 
12a2 72			      ld    (HL), D 
12a3			 
12a3					if DEBUG_FORTH_MALLOC 
12a3						DMARK "Mul" 
12a3						CALLMONITOR 
12a3					endif 
12a3			      ; Clear the Z flag to indicate successful allocation 
12a3 7a			      ld    A, D 
12a4 b3			      or    E 
12a5			 
12a5 d1			      pop   DE                      ; Address of allocation 
12a6					if DEBUG_FORTH_MALLOC 
12a6						DMARK "MAu" 
12a6						CALLMONITOR 
12a6					endif 
12a6			 
12a6			malloc_no_space: 
12a6 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
12a9 39			      add   HL, SP 
12aa f9			      ld    SP, HL 
12ab			 
12ab eb			      ex    DE, HL                  ; Alloc addr into HL for return 
12ac					if DEBUG_FORTH_MALLOC 
12ac						DMARK "MAN" 
12ac						CALLMONITOR 
12ac					endif 
12ac			 
12ac			malloc_early_exit: 
12ac					if DEBUG_FORTH_MALLOC 
12ac						DMARK "MAx" 
12ac						CALLMONITOR 
12ac					endif 
12ac dd e1		      pop   IX 
12ae d1			      pop   DE 
12af c1			      pop   BC 
12b0			 
12b0			if DEBUG_FORTH_MALLOC_HIGH 
12b0			call malloc_guard_exit 
12b0			call malloc_guard_zerolen 
12b0			endif 
12b0 c9			      ret 
12b1			 
12b1			 
12b1			;------------------------------------------------------------------------------ 
12b1			;     free                                                                    : 
12b1			;                                                                             : 
12b1			; Description                                                                 : 
12b1			;     Return the space pointed to by HL to the heap. HL must be an address as : 
12b1			;     returned by malloc, otherwise the behaviour is undefined.               : 
12b1			;                                                                             : 
12b1			;     Where possible, directly adjacent free blocks will be merged together   : 
12b1			;     into larger blocks to help ensure that the heap does not become         : 
12b1			;     excessively fragmented.                                                 : 
12b1			;                                                                             : 
12b1			;     free does not clear or set any other value into the freed space, and    : 
12b1			;     therefore its contents may be visible through subsequent malloc's. The  : 
12b1			;     caller should clear the freed space as required.                        : 
12b1			;                                                                             : 
12b1			;     This implementation of free uses the stack exclusively, and is          : 
12b1			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12b1			;     advisable to disable interrupts before calling free, and recommended    : 
12b1			;     to avoid the use of free inside ISRs in general.                        : 
12b1			;                                                                             : 
12b1			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12b1			;                                                                             : 
12b1			; Parameters                                                                  : 
12b1			;     HL  Pointer to address of first byte of allocation to be freed          : 
12b1			;                                                                             : 
12b1			; Returns                                                                     : 
12b1			;     Nothing                                                                 : 
12b1			;                                                                             : 
12b1			; Stack frame                                                                 : 
12b1			;       |             |                                                       : 
12b1			;       +-------------+                                                       : 
12b1			;       |     BC      |                                                       : 
12b1			;       +-------------+                                                       : 
12b1			;       |     DE      |                                                       : 
12b1			;       +-------------+                                                       : 
12b1			;       |     IX      |                                                       : 
12b1			;       +-------------+                                                       : 
12b1			;       |  prev_free  |                                                       : 
12b1			;   +2  +-------------+                                                       : 
12b1			;       |  next_free  |                                                       : 
12b1			;   +0  +-------------+                                                       : 
12b1			;       |             |                                                       : 
12b1			;                                                                             : 
12b1			;------------------------------------------------------------------------------ 
12b1			free: 
12b1 c5			      push  BC 
12b2 d5			      push  DE 
12b3 dd e5		      push  IX 
12b5			 
12b5 7c			      ld    A, H                    ; Exit if ptr is null 
12b6 b5			      or    L 
12b7 ca 7b 13		      jp    Z, free_early_exit 
12ba			 
12ba			      ; Set up stack frame 
12ba eb			      ex    DE, HL 
12bb 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12be 39			      add   HL, SP 
12bf f9			      ld    SP, HL 
12c0 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12c4 dd 39		      add   IX, SP 
12c6			 
12c6			      ; The address in HL points to the start of the useable allocated space, 
12c6			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12c6			      ; address of the block itself. 
12c6 eb			      ex    DE, HL 
12c7 11 fc ff		      ld    DE, -4 
12ca 19			      add   HL, DE 
12cb			 
12cb			      ; An allocated block must have a null next block pointer in it 
12cb 7e			      ld    A, (HL) 
12cc 23			      inc   HL 
12cd b6			      or    (HL) 
12ce c2 76 13		      jp    NZ, free_done 
12d1			 
12d1 2b			      dec   HL 
12d2			 
12d2 44			      ld    B, H                    ; Copy HL to BC 
12d3 4d			      ld    C, L 
12d4			 
12d4			      ; Loop through the free list to find the first block with an address 
12d4			      ; higher than the block being freed 
12d4 21 0a 80		      ld    HL, free_list 
12d7			 
12d7			free_find_higher_block: 
12d7 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12d8 23			      inc   HL 
12d9 56			      ld    D, (HL) 
12da 2b			      dec   HL 
12db			 
12db dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12de dd 72 01		      ld    (IX+1), D 
12e1 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12e4 dd 74 03		      ld    (IX+3), H 
12e7			 
12e7 78			      ld    A, B                    ; Check if DE is greater than BC 
12e8 ba			      cp    D                       ; Compare MSB first 
12e9 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12eb 30 04		      jr    NC, free_find_higher_block_skip 
12ed 79			      ld    A, C 
12ee bb			      cp    E                       ; Then compare LSB 
12ef 38 08		      jr    C, free_found_higher_block 
12f1			 
12f1			free_find_higher_block_skip: 
12f1 7a			      ld    A, D                    ; Reached the end of the free list? 
12f2 b3			      or    E 
12f3 ca 76 13		      jp    Z, free_done 
12f6			 
12f6 eb			      ex    DE, HL 
12f7			 
12f7 18 de		      jr    free_find_higher_block 
12f9			 
12f9			free_found_higher_block: 
12f9			      ; Insert freed block between prev and next free blocks 
12f9 71			      ld    (HL), C                 ; Point prev free block to freed block 
12fa 23			      inc   HL 
12fb 70			      ld    (HL), B 
12fc			 
12fc 60			      ld    H, B                    ; Point freed block at next free block 
12fd 69			      ld    L, C 
12fe 73			      ld    (HL), E 
12ff 23			      inc   HL 
1300 72			      ld    (HL), D 
1301			 
1301			      ; Check if the freed block is adjacent to the next free block 
1301 23			      inc   HL                      ; Load size of freed block into HL 
1302 5e			      ld    E, (HL) 
1303 23			      inc   HL 
1304 56			      ld    D, (HL) 
1305 eb			      ex    DE, HL 
1306			 
1306 09			      add   HL, BC                  ; Add addr of freed block and its size 
1307			 
1307 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
130a dd 56 01		      ld    D, (IX+1) 
130d			 
130d b7			      or    A                       ; Clear the carry flag 
130e ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1310 20 22		      jr    NZ, free_check_adjacent_to_prev 
1312			 
1312			      ; Freed block is adjacent to next, merge into one bigger block 
1312 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1313 5e			      ld    E, (HL) 
1314 23			      inc   HL 
1315 56			      ld    D, (HL) 
1316 e5			      push  HL                      ; Save ptr to next block for later 
1317			 
1317 60			      ld    H, B                    ; Store ptr from next block into freed block 
1318 69			      ld    L, C 
1319 73			      ld    (HL), E 
131a 23			      inc   HL 
131b 72			      ld    (HL), D 
131c			 
131c e1			      pop   HL                      ; Restore ptr to next block 
131d 23			      inc   HL                      ; Load size of next block into DE 
131e 5e			      ld    E, (HL) 
131f 23			      inc   HL 
1320 56			      ld    D, (HL) 
1321 d5			      push  DE                      ; Save next block size for later 
1322			 
1322 60			      ld    H, B                    ; Load size of freed block into HL 
1323 69			      ld    L, C 
1324 23			      inc   HL 
1325 23			      inc   HL 
1326 5e			      ld    E, (HL) 
1327 23			      inc   HL 
1328 56			      ld    D, (HL) 
1329 eb			      ex    DE, HL 
132a			 
132a d1			      pop   DE                      ; Restore size of next block 
132b 19			      add   HL, DE                  ; Add sizes of both blocks 
132c eb			      ex    DE, HL 
132d			 
132d 60			      ld    H, B                    ; Store new bigger size into freed block 
132e 69			      ld    L, C 
132f 23			      inc   HL 
1330 23			      inc   HL 
1331 73			      ld    (HL), E 
1332 23			      inc   HL 
1333 72			      ld    (HL), D 
1334			 
1334			free_check_adjacent_to_prev: 
1334			      ; Check if the freed block is adjacent to the prev free block 
1334 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1337 dd 66 03		      ld    H, (IX+3) 
133a			 
133a 23			      inc   HL                      ; Size of prev free block into DE 
133b 23			      inc   HL 
133c 5e			      ld    E, (HL) 
133d 23			      inc   HL 
133e 56			      ld    D, (HL) 
133f 2b			      dec   HL 
1340 2b			      dec   HL 
1341 2b			      dec   HL 
1342			 
1342 19			      add   HL, DE                  ; Add prev block addr and size 
1343			 
1343 b7			      or    A                       ; Clear the carry flag 
1344 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1346 20 2e		      jr    NZ, free_done 
1348			 
1348			      ; Freed block is adjacent to prev, merge into one bigger block 
1348 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1349 69			      ld    L, C 
134a 5e			      ld    E, (HL) 
134b 23			      inc   HL 
134c 56			      ld    D, (HL) 
134d e5			      push  HL                      ; Save freed block ptr for later 
134e			 
134e dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1351 dd 66 03		      ld    H, (IX+3) 
1354 73			      ld    (HL), E 
1355 23			      inc   HL 
1356 72			      ld    (HL), D 
1357			 
1357 e1			      pop   HL                      ; Restore freed block ptr 
1358 23			      inc   HL                      ; Load size of freed block into DE 
1359 5e			      ld    E, (HL) 
135a 23			      inc   HL 
135b 56			      ld    D, (HL) 
135c d5			      push  DE                      ; Save freed block size for later 
135d			 
135d dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1360 dd 66 03		      ld    H, (IX+3) 
1363 23			      inc   HL 
1364 23			      inc   HL 
1365 5e			      ld    E, (HL) 
1366 23			      inc   HL 
1367 56			      ld    D, (HL) 
1368			 
1368 e1			      pop   HL                      ; Add sizes of both blocks 
1369 19			      add   HL, DE 
136a eb			      ex    DE, HL 
136b			 
136b dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
136e dd 66 03		      ld    H, (IX+3) 
1371 23			      inc   HL 
1372 23			      inc   HL 
1373 73			      ld    (HL), E 
1374 23			      inc   HL 
1375 72			      ld    (HL), D 
1376			 
1376			free_done: 
1376 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1379 39			      add   HL, SP 
137a f9			      ld    SP, HL 
137b			 
137b			free_early_exit: 
137b dd e1		      pop   IX 
137d d1			      pop   DE 
137e c1			      pop   BC 
137f			 
137f c9			      ret 
1380			 
1380			; moved to firmware.asm 
1380			; 
1380			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1380			;                  .dw   0 
1380			 
1380			 
1380			endif 
1380			 
1380			 
1380			if MALLOC_3 
1380			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1380			;heap_start        .equ  0x9000      ; Starting address of heap 
1380			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1380			; 
1380			 ;     .org 0 
1380			  ;    jp    main 
1380			; 
1380			; 
1380			 ;     .org  0x100 
1380			;main: 
1380			 ;     ld    HL, 0x8100 
1380			  ;    ld    SP, HL 
1380			; 
1380			;      call  heap_init 
1380			 
1380			      ; Make some allocations 
1380			;      ld    HL, 12 
1380			;      call  malloc            ; Allocates 0x9004 
1380			; 
1380			 ;     ld    HL, 12 
1380			;      call  malloc            ; Allocates 0x9014 
1380			 
1380			;      ld    HL, 12 
1380			;      call  malloc            ; Allocates 0x9024 
1380			 
1380			      ; Free some allocations 
1380			;      ld    HL, 0x9014 
1380			;      call  free 
1380			 
1380			;      ld    HL, 0x9004 
1380			;      call  free 
1380			; 
1380			;      ld    HL, 0x9024 
1380			;      call  free 
1380			 
1380			 
1380			 ;     halt 
1380			 
1380			 
1380			;------------------------------------------------------------------------------ 
1380			;     heap_init                                                               : 
1380			;                                                                             : 
1380			; Description                                                                 : 
1380			;     Initialise the heap and make it ready for malloc and free operations.   : 
1380			;                                                                             : 
1380			;     The heap is maintained as a linked list, starting with an initial       : 
1380			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1380			;     the first free block in the heap. Each block then points to the next    : 
1380			;     free block within the heap, and the free list ends at the first block   : 
1380			;     with a null pointer to the next free block.                             : 
1380			;                                                                             : 
1380			; Parameters                                                                  : 
1380			;     Inputs are compile-time only. Two defines which specify the starting    : 
1380			;     address of the heap and its size are required, along with a memory      : 
1380			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1380			;     principally stores a pointer to the first free block in the heap.       : 
1380			;                                                                             : 
1380			; Returns                                                                     : 
1380			;     Nothing                                                                 : 
1380			;------------------------------------------------------------------------------ 
1380			heap_init: 
1380			      push  HL 
1380			 
1380			      ; Initialise free list struct 
1380			      ld    HL, heap_start 
1380			      ld    (free_list), HL 
1380			      ld    HL, 0 
1380			      ld    (free_list+2), HL 
1380			 
1380			      ; Insert first free block at bottom of heap, consumes entire heap 
1380			      ld    HL, heap_start+heap_size-4 
1380			      ld    (heap_start), HL        ; Next block (end of free list) 
1380			      ld    HL, heap_size-4 
1380			      ld    (heap_start+2), HL      ; Block size 
1380			 
1380			      ; Insert end of free list block at top of heap - two null words will 
1380			      ; terminate the free list 
1380			      ld    HL, 0 
1380			      ld    (heap_start+heap_size-2), HL 
1380			      ld    (heap_start+heap_size-4), HL 
1380			 
1380			      pop   HL 
1380			 
1380			      ret 
1380			 
1380			 
1380			;------------------------------------------------------------------------------ 
1380			;     malloc                                                                  : 
1380			;                                                                             : 
1380			; Description                                                                 : 
1380			;     Allocates the wanted space from the heap and returns the address of the : 
1380			;     first useable byte of the allocation.                                   : 
1380			;                                                                             : 
1380			;     Allocations can happen in one of two ways:                              : 
1380			;                                                                             : 
1380			;     1. A free block may be found which is the exact size wanted. In this    : 
1380			;        case the block is removed from the free list and retuedn to the      : 
1380			;        caller.                                                              : 
1380			;     2. A free block may be found which is larger than the size wanted. In   : 
1380			;        this case, the larger block is split into two. The first portion of  : 
1380			;        this block will become the requested space by the malloc call and    : 
1380			;        is returned to the caller. The second portion becomes a new free     : 
1380			;        block, and the free list is adjusted to maintain continuity via this : 
1380			;        newly created block.                                                 : 
1380			;                                                                             : 
1380			;     malloc does not set any initial value in the allocated space, the       : 
1380			;     caller is required to do this as required.                              : 
1380			;                                                                             : 
1380			;     This implementation of malloc uses the stack exclusively, and is        : 
1380			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1380			;     advisable to disable interrupts before calling malloc, and recommended  : 
1380			;     to avoid the use of malloc inside ISRs in general.                      : 
1380			;                                                                             : 
1380			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1380			;                                                                             : 
1380			; Parameters                                                                  : 
1380			;     HL  Number of bytes wanted                                              : 
1380			;                                                                             : 
1380			; Returns                                                                     : 
1380			;     HL  Address of the first useable byte of the allocation                 : 
1380			;                                                                             : 
1380			; Flags                                                                       : 
1380			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1380			;                                                                             : 
1380			; Stack frame                                                                 : 
1380			;       |             |                                                       : 
1380			;       +-------------+                                                       : 
1380			;       |     BC      |                                                       : 
1380			;       +-------------+                                                       : 
1380			;       |     DE      |                                                       : 
1380			;       +-------------+                                                       : 
1380			;       |     IX      |                                                       : 
1380			;       +-------------+                                                       : 
1380			;       |  prev_free  |                                                       : 
1380			;   +4  +-------------+                                                       : 
1380			;       |  this_free  |                                                       : 
1380			;   +2  +-------------+                                                       : 
1380			;       |  next_free  |                                                       : 
1380			;   +0  +-------------+                                                       : 
1380			;       |             |                                                       : 
1380			;                                                                             : 
1380			;------------------------------------------------------------------------------ 
1380			malloc: 
1380			      push  BC 
1380			      push  DE 
1380			      push  IX 
1380			 
1380			      ld    A, H                    ; Exit if no space requested 
1380			      or    L 
1380			      jp    Z, malloc_early_exit 
1380			 
1380			      ; Set up stack frame 
1380			      ex    DE, HL 
1380			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1380			      add   HL, SP 
1380			      ld    SP, HL 
1380			      ld    IX, 0                   ; Use IX as a frame pointer 
1380			      add   IX, SP 
1380			 
1380			      ; Setup initial state 
1380			      ld    HL, 4                   ; want must also include space used by block struct 
1380			      add   HL, DE 
1380			 
1380			      ld    B, H                    ; Move want to BC 
1380			      ld    C, L 
1380			 
1380			      ld    HL, free_list           ; Store prev_free ptr to stack 
1380			      ld    (IX+4), L 
1380			      ld    (IX+5), H 
1380			 
1380			      ld    E, (HL)                 ; Store this_free ptr to stack 
1380			      inc   HL 
1380			      ld    D, (HL) 
1380			      ld    (IX+2), E 
1380			      ld    (IX+3), D 
1380			      ex    DE, HL                  ; this_free ptr into HL 
1380			 
1380			      ; Loop through free block list to find some space 
1380			malloc_find_space: 
1380			      ld    E, (HL)                 ; Load next_free ptr into DE 
1380			      inc   HL 
1380			      ld    D, (HL) 
1380			 
1380			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1380			      or    E 
1380			      jp    Z, malloc_no_space 
1380			 
1380			      ld    (IX+0), E               ; Store next_free ptr to stack 
1380			      ld    (IX+1), D 
1380			 
1380			      ; Does this block have enough space to make the allocation? 
1380			      inc   HL                      ; Load free block size into DE 
1380			      ld    E, (HL) 
1380			      inc   HL 
1380			      ld    D, (HL) 
1380			 
1380			      ex    DE, HL                  ; Check size of block against want 
1380			      or    A                       ; Ensure carry flag clear 
1380			      sbc   HL, BC 
1380			      push  HL                      ; Store the result for later (new block size) 
1380			 
1380			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1380			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1380			 
1380			      ; this_free block is not big enough, setup ptrs to test next free block 
1380			      pop   HL                      ; Discard previous result 
1380			 
1380			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1380			      ld    H, (IX+3) 
1380			      ld    (IX+4), L 
1380			      ld    (IX+5), H 
1380			 
1380			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1380			      ld    H, (IX+1) 
1380			      ld    (IX+2), L 
1380			      ld    (IX+3), H 
1380			 
1380			      jr    malloc_find_space 
1380			 
1380			      ; split a bigger block into two - requested size and remaining size 
1380			malloc_alloc_split: 
1380			      ex    DE, HL                  ; Calculate address of new free block 
1380			      dec   HL 
1380			      dec   HL 
1380			      dec   HL 
1380			      add   HL, BC 
1380			 
1380			      ; Create a new block and point it at next_free 
1380			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1380			      ld    D, (IX+1) 
1380			 
1380			      ld    (HL), E                 ; Store next_free ptr into new block 
1380			      inc   HL 
1380			      ld    (HL), D 
1380			 
1380			      pop   DE                      ; Store size of new block into new block 
1380			      inc   HL 
1380			      ld    (HL), E 
1380			      inc   HL 
1380			      ld    (HL), D 
1380			 
1380			      ; Update this_free ptr to point to new block 
1380			      dec   HL 
1380			      dec   HL 
1380			      dec   HL 
1380			 
1380			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1380			      ld    D, (IX+3) 
1380			 
1380			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1380			      ld    (IX+3), H 
1380			 
1380			      ; Modify this_free block to be allocation 
1380			      ex    DE, HL 
1380			      xor   A                       ; Null the next block ptr of allocated block 
1380			      ld    (HL), A 
1380			      inc   HL 
1380			      ld    (HL), A 
1380			 
1380			      inc   HL                      ; Store want size into allocated block 
1380			      ld    (HL), C 
1380			      inc   HL 
1380			      ld    (HL), B 
1380			      inc   HL 
1380			      push  HL                      ; Address of allocation to return 
1380			 
1380			      jr    malloc_update_links 
1380			 
1380			malloc_alloc_fit: 
1380			      pop   HL                      ; Dont need new block size, want is exact fit 
1380			 
1380			      ; Modify this_free block to be allocation 
1380			      ex    DE, HL 
1380			      dec   HL 
1380			      dec   HL 
1380			      dec   HL 
1380			 
1380			      xor   A                       ; Null the next block ptr of allocated block 
1380			      ld    (HL), A 
1380			      inc   HL 
1380			      ld    (HL), A 
1380			 
1380			      inc   HL                      ; Store address of allocation to return 
1380			      inc   HL 
1380			      inc   HL 
1380			      push  HL 
1380			 
1380			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1380			      ld    L, (IX+0)               ; next_free to HL 
1380			      ld    H, (IX+1) 
1380			 
1380			      ld    (IX+2), L               ; HL to this_free 
1380			      ld    (IX+3), H 
1380			 
1380			 
1380			malloc_update_links: 
1380			      ; Update prev_free ptr to point to this_free 
1380			      ld    L, (IX+4)               ; prev_free ptr to HL 
1380			      ld    H, (IX+5) 
1380			 
1380			      ld    E, (IX+2)               ; this_free ptr to DE 
1380			      ld    D, (IX+3) 
1380			 
1380			      ld    (HL), E                 ; this_free ptr into prev_free 
1380			      inc   HL 
1380			      ld    (HL), D 
1380			 
1380			      ; Clear the Z flag to indicate successful allocation 
1380			      ld    A, D 
1380			      or    E 
1380			 
1380			      pop   DE                      ; Address of allocation 
1380			 
1380			malloc_no_space: 
1380			      ld    HL, 6                   ; Clean up stack frame 
1380			      add   HL, SP 
1380			      ld    SP, HL 
1380			 
1380			      ex    DE, HL                  ; Alloc addr into HL for return 
1380			 
1380			malloc_early_exit: 
1380			      pop   IX 
1380			      pop   DE 
1380			      pop   BC 
1380			 
1380			      ret 
1380			 
1380			 
1380			;------------------------------------------------------------------------------ 
1380			;     free                                                                    : 
1380			;                                                                             : 
1380			; Description                                                                 : 
1380			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1380			;     returned by malloc, otherwise the behaviour is undefined.               : 
1380			;                                                                             : 
1380			;     Where possible, directly adjacent free blocks will be merged together   : 
1380			;     into larger blocks to help ensure that the heap does not become         : 
1380			;     excessively fragmented.                                                 : 
1380			;                                                                             : 
1380			;     free does not clear or set any other value into the freed space, and    : 
1380			;     therefore its contents may be visible through subsequent malloc's. The  : 
1380			;     caller should clear the freed space as required.                        : 
1380			;                                                                             : 
1380			;     This implementation of free uses the stack exclusively, and is          : 
1380			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1380			;     advisable to disable interrupts before calling free, and recommended    : 
1380			;     to avoid the use of free inside ISRs in general.                        : 
1380			;                                                                             : 
1380			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1380			;                                                                             : 
1380			; Parameters                                                                  : 
1380			;     HL  Pointer to address of first byte of allocation to be freed          : 
1380			;                                                                             : 
1380			; Returns                                                                     : 
1380			;     Nothing                                                                 : 
1380			;                                                                             : 
1380			; Stack frame                                                                 : 
1380			;       |             |                                                       : 
1380			;       +-------------+                                                       : 
1380			;       |     BC      |                                                       : 
1380			;       +-------------+                                                       : 
1380			;       |     DE      |                                                       : 
1380			;       +-------------+                                                       : 
1380			;       |     IX      |                                                       : 
1380			;       +-------------+                                                       : 
1380			;       |  prev_free  |                                                       : 
1380			;   +2  +-------------+                                                       : 
1380			;       |  next_free  |                                                       : 
1380			;   +0  +-------------+                                                       : 
1380			;       |             |                                                       : 
1380			;                                                                             : 
1380			;------------------------------------------------------------------------------ 
1380			free: 
1380			      push  BC 
1380			      push  DE 
1380			      push  IX 
1380			 
1380			      ld    A, H                    ; Exit if ptr is null 
1380			      or    L 
1380			      jp    Z, free_early_exit 
1380			 
1380			      ; Set up stack frame 
1380			      ex    DE, HL 
1380			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1380			      add   HL, SP 
1380			      ld    SP, HL 
1380			      ld    IX, 0                   ; Use IX as a frame pointer 
1380			      add   IX, SP 
1380			 
1380			      ; The address in HL points to the start of the useable allocated space, 
1380			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1380			      ; address of the block itself. 
1380			      ex    DE, HL 
1380			      ld    DE, -4 
1380			      add   HL, DE 
1380			 
1380			      ; An allocated block must have a null next block pointer in it 
1380			      ld    A, (HL) 
1380			      inc   HL 
1380			      or    (HL) 
1380			      jp    NZ, free_done 
1380			 
1380			      dec   HL 
1380			 
1380			      ld    B, H                    ; Copy HL to BC 
1380			      ld    C, L 
1380			 
1380			      ; Loop through the free list to find the first block with an address 
1380			      ; higher than the block being freed 
1380			      ld    HL, free_list 
1380			 
1380			free_find_higher_block: 
1380			      ld    E, (HL)                 ; Load next ptr from free block 
1380			      inc   HL 
1380			      ld    D, (HL) 
1380			      dec   HL 
1380			 
1380			      ld    (IX+0), E               ; Save ptr to next free block 
1380			      ld    (IX+1), D 
1380			      ld    (IX+2), L               ; Save ptr to prev free block 
1380			      ld    (IX+3), H 
1380			 
1380			      ld    A, B                    ; Check if DE is greater than BC 
1380			      cp    D                       ; Compare MSB first 
1380			      jr    Z, $+4                  ; MSB the same, compare LSB 
1380			      jr    NC, free_find_higher_block_skip 
1380			      ld    A, C 
1380			      cp    E                       ; Then compare LSB 
1380			      jr    C, free_found_higher_block 
1380			 
1380			free_find_higher_block_skip: 
1380			      ld    A, D                    ; Reached the end of the free list? 
1380			      or    E 
1380			      jp    Z, free_done 
1380			 
1380			      ex    DE, HL 
1380			 
1380			      jr    free_find_higher_block 
1380			 
1380			free_found_higher_block: 
1380			      ; Insert freed block between prev and next free blocks 
1380			      ld    (HL), C                 ; Point prev free block to freed block 
1380			      inc   HL 
1380			      ld    (HL), B 
1380			 
1380			      ld    H, B                    ; Point freed block at next free block 
1380			      ld    L, C 
1380			      ld    (HL), E 
1380			      inc   HL 
1380			      ld    (HL), D 
1380			 
1380			      ; Check if the freed block is adjacent to the next free block 
1380			      inc   HL                      ; Load size of freed block into HL 
1380			      ld    E, (HL) 
1380			      inc   HL 
1380			      ld    D, (HL) 
1380			      ex    DE, HL 
1380			 
1380			      add   HL, BC                  ; Add addr of freed block and its size 
1380			 
1380			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1380			      ld    D, (IX+1) 
1380			 
1380			      or    A                       ; Clear the carry flag 
1380			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1380			      jr    NZ, free_check_adjacent_to_prev 
1380			 
1380			      ; Freed block is adjacent to next, merge into one bigger block 
1380			      ex    DE, HL                  ; Load next ptr from next block into DE 
1380			      ld    E, (HL) 
1380			      inc   HL 
1380			      ld    D, (HL) 
1380			      push  HL                      ; Save ptr to next block for later 
1380			 
1380			      ld    H, B                    ; Store ptr from next block into freed block 
1380			      ld    L, C 
1380			      ld    (HL), E 
1380			      inc   HL 
1380			      ld    (HL), D 
1380			 
1380			      pop   HL                      ; Restore ptr to next block 
1380			      inc   HL                      ; Load size of next block into DE 
1380			      ld    E, (HL) 
1380			      inc   HL 
1380			      ld    D, (HL) 
1380			      push  DE                      ; Save next block size for later 
1380			 
1380			      ld    H, B                    ; Load size of freed block into HL 
1380			      ld    L, C 
1380			      inc   HL 
1380			      inc   HL 
1380			      ld    E, (HL) 
1380			      inc   HL 
1380			      ld    D, (HL) 
1380			      ex    DE, HL 
1380			 
1380			      pop   DE                      ; Restore size of next block 
1380			      add   HL, DE                  ; Add sizes of both blocks 
1380			      ex    DE, HL 
1380			 
1380			      ld    H, B                    ; Store new bigger size into freed block 
1380			      ld    L, C 
1380			      inc   HL 
1380			      inc   HL 
1380			      ld    (HL), E 
1380			      inc   HL 
1380			      ld    (HL), D 
1380			 
1380			free_check_adjacent_to_prev: 
1380			      ; Check if the freed block is adjacent to the prev free block 
1380			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1380			      ld    H, (IX+3) 
1380			 
1380			      inc   HL                      ; Size of prev free block into DE 
1380			      inc   HL 
1380			      ld    E, (HL) 
1380			      inc   HL 
1380			      ld    D, (HL) 
1380			      dec   HL 
1380			      dec   HL 
1380			      dec   HL 
1380			 
1380			      add   HL, DE                  ; Add prev block addr and size 
1380			 
1380			      or    A                       ; Clear the carry flag 
1380			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1380			      jr    NZ, free_done 
1380			 
1380			      ; Freed block is adjacent to prev, merge into one bigger block 
1380			      ld    H, B                    ; Load next ptr from freed block into DE 
1380			      ld    L, C 
1380			      ld    E, (HL) 
1380			      inc   HL 
1380			      ld    D, (HL) 
1380			      push  HL                      ; Save freed block ptr for later 
1380			 
1380			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1380			      ld    H, (IX+3) 
1380			      ld    (HL), E 
1380			      inc   HL 
1380			      ld    (HL), D 
1380			 
1380			      pop   HL                      ; Restore freed block ptr 
1380			      inc   HL                      ; Load size of freed block into DE 
1380			      ld    E, (HL) 
1380			      inc   HL 
1380			      ld    D, (HL) 
1380			      push  DE                      ; Save freed block size for later 
1380			 
1380			      ld    L, (IX+2)               ; Load size of prev block into DE 
1380			      ld    H, (IX+3) 
1380			      inc   HL 
1380			      inc   HL 
1380			      ld    E, (HL) 
1380			      inc   HL 
1380			      ld    D, (HL) 
1380			 
1380			      pop   HL                      ; Add sizes of both blocks 
1380			      add   HL, DE 
1380			      ex    DE, HL 
1380			 
1380			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1380			      ld    H, (IX+3) 
1380			      inc   HL 
1380			      inc   HL 
1380			      ld    (HL), E 
1380			      inc   HL 
1380			      ld    (HL), D 
1380			 
1380			free_done: 
1380			      ld    HL, 4                   ; Clean up stack frame 
1380			      add   HL, SP 
1380			      ld    SP, HL 
1380			 
1380			free_early_exit: 
1380			      pop   IX 
1380			      pop   DE 
1380			      pop   BC 
1380			 
1380			      ret 
1380			 
1380			 
1380			;      .org 0x8000 
1380			; 
1380			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1380			 ;                 .dw   0 
1380			 
1380			endif 
1380			 
1380			 
1380			if MALLOC_4 
1380			 
1380			; My memory allocation code. Very very simple.... 
1380			; allocate space under 250 chars 
1380			 
1380			heap_init: 
1380				; init start of heap as zero 
1380				;  
1380			 
1380				ld hl, heap_start 
1380				ld a, 0 
1380				ld (hl), a      ; empty block 
1380				inc hl 
1380				ld a, 0 
1380				ld (hl), a      ; length of block 
1380				; write end of list 
1380				inc hl 
1380				ld a,(hl) 
1380				inc hl 
1380				ld a,(hl) 
1380				 
1380			 
1380				; init some malloc vars 
1380			 
1380				ld hl, 0 
1380				ld (free_list), hl       ; store last malloc location 
1380			 
1380				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1380				ld a, 0 
1380				ld (hl), a 
1380			 
1380			 
1380				ld hl, heap_start 
1380				;  
1380				  
1380				ret 
1380			 
1380			 
1380			;    free block marker 
1380			;    requested size  
1380			;    pointer to next block 
1380			;    .... 
1380			;    next block marker 
1380			 
1380			 
1380			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1380			; 
1380			 
1380			 
1380			malloc:  
1380				push de 
1380				push bc 
1380				push af 
1380			 
1380				; hl space required 
1380				 
1380				ld c, l    ; hold space   (TODO only a max of 255) 
1380			 
1380			;	inc c     ; TODO BUG need to fix memory leak on push str 
1380			;	inc c 
1380			;	inc c 
1380			;	inc c 
1380			;	inc c 
1380			;	inc c 
1380			;	inc c 
1380			 
1380			 
1380			 
1380				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1380			 
1380				ld a, (free_list+3) 
1380				cp 0 
1380				jr z, .contheap 
1380			 
1380				ld hl, (free_list)     ; get last alloc 
1380					if DEBUG_FORTH_MALLOC_INT 
1380						DMARK "mrs" 
1380						CALLMONITOR 
1380					endif 
1380				jr .startalloc 
1380			 
1380			.contheap: 
1380				ld hl, heap_start 
1380			 
1380			.startalloc: 
1380			 
1380					if DEBUG_FORTH_MALLOC_INT 
1380						DMARK "mym" 
1380						CALLMONITOR 
1380					endif 
1380			.findblock: 
1380					if DEBUG_FORTH_MALLOC_INT 
1380						DMARK "mmf" 
1380						CALLMONITOR 
1380					endif 
1380			 
1380				ld a,(hl)  
1380				; if byte is zero then clear to use 
1380			 
1380				cp 0 
1380				jr z, .foundemptyblock 
1380			 
1380				; if byte is not clear 
1380				;     then byte is offset to next block 
1380			 
1380				inc hl 
1380				ld a, (hl) ; get size 
1380			.nextblock:	inc hl 
1380					ld e, (hl) 
1380					inc hl 
1380					ld d, (hl) 
1380					ex de, hl 
1380			;	inc hl  ; move past the store space 
1380			;	inc hl  ; move past zero index  
1380			 
1380				; TODO detect no more space 
1380			 
1380				push hl 
1380				ld de, heap_end 
1380				call cmp16 
1380				pop hl 
1380				jr nc, .nospace 
1380			 
1380				jr .findblock 
1380			 
1380			.nospace: ld hl, 0 
1380				jp .exit 
1380			 
1380			 
1380			.foundemptyblock:	 
1380					if DEBUG_FORTH_MALLOC_INT 
1380						DMARK "mme" 
1380						CALLMONITOR 
1380					endif 
1380			 
1380			; TODO has block enough space if reusing??? 
1380			 
1380				;  
1380			 
1380			; see if this block has been previously used 
1380				inc hl 
1380				ld a, (hl) 
1380				dec hl 
1380				cp 0 
1380				jr z, .newblock 
1380			 
1380					if DEBUG_FORTH_MALLOC_INT 
1380						DMARK "meR" 
1380						CALLMONITOR 
1380					endif 
1380			 
1380			; no reusing previously allocated block 
1380			 
1380			; is it smaller than previously used? 
1380				 
1380				inc hl    ; move to size 
1380				ld a, c 
1380				sub (hl)        ; we want c < (hl) 
1380				dec hl    ; move back to marker 
1380			        jr z, .findblock 
1380			 
1380				; update with the new size which should be lower 
1380			 
1380			        ;inc  hl   ; negate next move. move back to size  
1380			 
1380			.newblock: 
1380				; need to be at marker here 
1380			 
1380					if DEBUG_FORTH_MALLOC_INT 
1380						DMARK "meN" 
1380						CALLMONITOR 
1380					endif 
1380			 
1380			 
1380				ld a, c 
1380			 
1380				ld (free_list+3), a	 ; flag resume from last malloc  
1380				ld (free_list), hl    ; save out last location 
1380			 
1380			 
1380				;inc a     ; space for length byte 
1380				ld (hl), a     ; save block in use marker 
1380			 
1380				inc hl   ; move to space marker 
1380				ld (hl), a    ; save new space 
1380			 
1380				inc hl   ; move to start of allocated area 
1380				 
1380			;	push hl     ; save where we are - 1  
1380			 
1380			;	inc hl  ; move past zero index  
1380				; skip space to set down new marker 
1380			 
1380				; provide some extra space for now 
1380			 
1380				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1380				inc a 
1380				inc a 
1380			 
1380				push hl   ; save where we are in the node block 
1380			 
1380				call addatohl 
1380			 
1380				; write linked list point 
1380			 
1380				pop de     ; get our node position 
1380				ex de, hl 
1380			 
1380				ld (hl), e 
1380				inc hl 
1380				ld (hl), d 
1380			 
1380				inc hl 
1380			 
1380				; now at start of allocated data so save pointer 
1380			 
1380				push hl 
1380			 
1380				; jump to position of next node and setup empty header in DE 
1380			 
1380				ex de, hl 
1380			 
1380			;	inc hl ; move past end of block 
1380			 
1380				ld a, 0 
1380				ld (hl), a   ; empty marker 
1380				inc hl 
1380				ld (hl), a   ; size 
1380				inc hl  
1380				ld (hl), a   ; ptr 
1380				inc hl 
1380				ld (hl), a   ; ptr 
1380			 
1380			 
1380				pop hl 
1380			 
1380					if DEBUG_FORTH_MALLOC_INT 
1380						DMARK "mmr" 
1380						CALLMONITOR 
1380					endif 
1380			 
1380			.exit: 
1380				pop af 
1380				pop bc 
1380				pop de  
1380				ret 
1380			 
1380			 
1380			 
1380			 
1380			free:  
1380				push hl 
1380				push af 
1380				; get address in hl 
1380			 
1380					if DEBUG_FORTH_MALLOC_INT 
1380						DMARK "fre" 
1380						CALLMONITOR 
1380					endif 
1380				; data is at hl - move to block count 
1380				dec hl 
1380				dec hl    ; get past pointer 
1380				dec hl 
1380			 
1380				ld a, (hl)    ; need this for a validation check 
1380			 
1380				dec hl    ; move to block marker 
1380			 
1380				; now check that the block count and block marker are the same  
1380			        ; this checks that we are on a malloc node and not random memory 
1380			        ; OK a faint chance this could be a problem but rare - famous last words! 
1380			 
1380				ld c, a 
1380				ld a, (hl)    
1380			 
1380				cp c 
1380				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1380			 
1380				; yes good chance we are on a malloc node 
1380			 
1380				ld a, 0      
1380				ld (hl), a   ; mark as free 
1380			 
1380				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1380			 
1380			.freeignore:  
1380			 
1380				pop af 
1380				pop hl 
1380			 
1380				ret 
1380			 
1380			 
1380			 
1380			endif 
1380			 
1380			; eof 
# End of file firmware_memory.asm
1380			  
1380			; device C  
1380			if SOUND_ENABLE  
1380				include "firmware_sound.asm"  
1380			; Sound abstraction layer 
1380			 
1380			; support different sound chips through common interface 
1380			 
1380			SOUND_DEVICE_AY: equ 0 
1380			 
1380			SOUND_DEVICE: equ Device_A 
1380			 
1380			 
1380			 
1380			if SOUND_DEVICE_AY 
1380				include "firmware_sound_ay38910.asm" 
1380			else 
1380				include "firmware_sound_sn76489an.asm" 
1380			 
1380			; Device support for SN76489AN sound chip 
1380			 
1380			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
1380			; http://danceswithferrets.org/geekblog/?p=93 
1380			; https://www.smspower.org/Development/SN76489 
1380			 
1380			; D0 [ 3] 
1380			; D1 [ 2] 
1380			; D2 [ 1] 
1380			; D3 [15] 
1380			; D4 [13] 
1380			; D5 [12] 
1380			; D6 [11] 
1380			; D7 [10] 
1380			; /WE [ 5] 
1380			; CLK [14] 
1380			; /OE [ 6] 
1380			; AUDIO [ 7] 
1380			; GND 8 
1380			; +5 16 
1380			; 
1380			 
1380			; Write sequence: 
1380			; CE low 
1380			; Data bus 
1380			; WE low then high 
1380			; 32 clock cycles / 8ns write time at 4mhz 
1380			; 
1380			; https://github.com/jblang/SN76489 
1380			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
1380			; Tried: 
1380			; 
1380			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
1380			; 
1380			; Connected WE to OR too 
1380			;  
1380			; That enabled the clock when required 
1380			; However still random bus corruption. Need further investigation 
1380			 
1380			 
1380			SOUND_LATCH: equ 10000000B 
1380			SOUND_DATA: equ 0B 
1380			SOUND_CH0:  equ 0B    ; Tone 
1380			SOUND_CH1: equ 0100000B        ; Tone 
1380			SOUND_CH2: equ 1000000B   ; Tone 
1380			SOUND_CH3: equ 1100000B    ; Noise 
1380			SOUND_VOL: equ 10000B 
1380			SOUND_TONE: equ 0B 
1380			 
1380			 
1380			sound_init: 
1380 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
1382 cd 97 13			call note_send_byte 
1385 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1387 cd 97 13			call note_send_byte 
138a cd 5d 0a			call delay250ms 
138d 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
138f cd 97 13			call note_send_byte 
1392 cd 5d 0a			call delay250ms 
1395 c9				ret 
1396			 
1396			; Play a note 
1396			; h = note 
1396			; l = duration 
1396			; a = channel 
1396			 
1396			 
1396			;  frequ = clock / ( 2 x reg valu x 32 )  
1396			 
1396			note:  
1396				 
1396			 
1396 c9				ret 
1397			 
1397			note_send_byte: 
1397				; byte in a 
1397			 
1397				; we high 
1397 d3 40			out (Device_B), a 
1399			;	ld a, 1 
1399			;	call aDelayInMS 
1399 00				nop  
139a 00				nop  
139b 00				nop  
139c 00				nop  
139d				; we low 
139d d3 40			out (Device_B), a 
139f			;	ld a, 1 
139f			;	call aDelayInMS 
139f 00				nop  
13a0 00				nop  
13a1 00				nop  
13a2 00				nop  
13a3				; we high 
13a3 d3 40			out (Device_B), a 
13a5			;	ld a, 1 
13a5			;	call aDelayInMS 
13a5 00				nop  
13a6 00				nop  
13a7 00				nop  
13a8 00				nop  
13a9			 
13a9			 
13a9 c9				ret 
13aa			 
13aa			;void SilenceAllChannels() 
13aa			;{ 
13aa			;  SendByte(0x9f); 
13aa			;  SendByte(0xbf); 
13aa			;  SendByte(0xdf); 
13aa			;  SendByte(0xff); 
13aa			;} 
13aa			 
13aa			 
13aa			; eof 
13aa			 
# End of file firmware_sound_sn76489an.asm
13aa			endif 
13aa			 
13aa			 
13aa			; Abstraction entry points 
13aa			 
13aa			; init  
13aa			 
13aa			; sound_init in specific hardware files 
13aa			 
13aa			; Play a note 
13aa			; h = note 
13aa			; l = duration 
13aa			; a = channel 
13aa			 
13aa			;note:     
13aa			;	ret 
13aa			 
13aa			 
13aa			 
13aa			 
13aa			; eof 
13aa			 
# End of file firmware_sound.asm
13aa			endif  
13aa			  
13aa			include "firmware_diags.asm"  
13aa			; Hardware diags menu 
13aa			 
13aa			 
13aa			config: 
13aa			 
13aa 3e 00			ld a, 0 
13ac 21 da 13			ld hl, .configmn 
13af cd 1d 0b			call menu 
13b2			 
13b2 fe 00			cp 0 
13b4 c8				ret z 
13b5			 
13b5 fe 01			cp 1 
13b7 cc 44 15			call z, .savetostore 
13ba			 
13ba fe 02			cp 2 
13bc cc 92 14			call z, .selautoload 
13bf fe 03			cp 3 
13c1 cc 7b 14			call z, .disautoload 
13c4 fe 04			cp 4 
13c6 cc 42 15			call z, .selbank 
13c9 fe 05			cp 5 
13cb cc 36 16			call z, .debug_tog 
13ce fe 06			cp 6 
13d0 cc 7e 17			call z, .bpsgo 
13d3 fe 07			cp 7 
13d5 cc 5c 16			call z, hardware_diags 
13d8			 
13d8 18 d0			jr config 
13da			 
13da			.configmn: 
13da ea 13			dw .c3 
13dc 01 14			dw .c2 
13de 16 14			dw .c2a 
13e0 2c 14			dw .c2b 
13e2			;	dw .c4 
13e2 49 14			dw .m4 
13e4 64 14			dw .m4b 
13e6 6c 14			dw .c1 
13e8 00 00			dw 0 
13ea				 
13ea			 
13ea .. 00		.c3: db "Add Dictionary To File",0 
1401 .. 00		.c2: db "Select Autoload File",0 
1416 .. 00		.c2a: db "Disable Autoload File", 0 
142c .. 00		.c2b: db "Select Storage Bank",0 
1440 .. 00		.c4: db "Settings",0 
1449 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1464 .. 00		.m4b:   db "Monitor",0 
146c .. 00		.c1: db "Hardware Diags",0 
147b			 
147b			 
147b			.disautoload: 
147b				if STORAGE_SE 
147b 3e fe			ld a, $fe      ; bit 0 clear 
147d 32 48 f8			ld (spi_device), a 
1480			 
1480 cd bd 03			call storage_get_block_0 
1483			 
1483 3e 00			ld a, 0 
1485 32 83 f8			ld (store_page+STORE_0_AUTOFILE), a 
1488			 
1488 21 00 00				ld hl, 0 
148b 11 62 f8				ld de, store_page 
148e cd 71 03			call storage_write_block	 ; save update 
1491				else 
1491			 
1491				ld hl, .notav 
1491				ld de, .empty 
1491				call info_panel 
1491				endif 
1491			 
1491			 
1491 c9				ret 
1492			 
1492			 
1492			 
1492			; Select auto start 
1492			 
1492			.selautoload: 
1492			 
1492				 
1492				if STORAGE_SE 
1492			 
1492 cd 80 15				call config_dir 
1495 21 1d ee			        ld hl, scratch 
1498 3e 00				ld a, 0 
149a cd 1d 0b				call menu 
149d			 
149d fe 00				cp 0 
149f c8					ret z 
14a0			 
14a0 3d					dec a 
14a1			 
14a1			 
14a1					; locate menu option 
14a1			 
14a1 21 1d ee				ld hl, scratch 
14a4 cd 41 0a				call table_lookup 
14a7			 
14a7					if DEBUG_FORTH_WORDS 
14a7						DMARK "ALl" 
14a7 f5				push af  
14a8 3a bc 14			ld a, (.dmark)  
14ab 32 77 fb			ld (debug_mark),a  
14ae 3a bd 14			ld a, (.dmark+1)  
14b1 32 78 fb			ld (debug_mark+1),a  
14b4 3a be 14			ld a, (.dmark+2)  
14b7 32 79 fb			ld (debug_mark+2),a  
14ba 18 03			jr .pastdmark  
14bc ..			.dmark: db "ALl"  
14bf f1			.pastdmark: pop af  
14c0			endm  
# End of macro DMARK
14c0						CALLMONITOR 
14c0 cd 74 17			call break_point_state  
14c3				endm  
# End of macro CALLMONITOR
14c3					endif 
14c3					; with the pointer to the menu it, the byte following the zero term is the file id 
14c3			 
14c3 3e 00				ld a, 0 
14c5 01 32 00				ld bc, 50   ; max of bytes to look at 
14c8 ed b1				cpir  
14ca			 
14ca					if DEBUG_FORTH_WORDS 
14ca						DMARK "ALb" 
14ca f5				push af  
14cb 3a df 14			ld a, (.dmark)  
14ce 32 77 fb			ld (debug_mark),a  
14d1 3a e0 14			ld a, (.dmark+1)  
14d4 32 78 fb			ld (debug_mark+1),a  
14d7 3a e1 14			ld a, (.dmark+2)  
14da 32 79 fb			ld (debug_mark+2),a  
14dd 18 03			jr .pastdmark  
14df ..			.dmark: db "ALb"  
14e2 f1			.pastdmark: pop af  
14e3			endm  
# End of macro DMARK
14e3						CALLMONITOR 
14e3 cd 74 17			call break_point_state  
14e6				endm  
# End of macro CALLMONITOR
14e6					endif 
14e6					;inc hl 
14e6			 
14e6 7e					ld a, (hl)   ; file id 
14e7					 
14e7				        ; save bank and file ids 
14e7			 
14e7 f5					push af 
14e8			 
14e8			; TODO need to save to block 0 on bank 1	 
14e8			 
14e8 cd bd 03				call storage_get_block_0 
14eb			 
14eb					if DEBUG_FORTH_WORDS 
14eb						DMARK "AL0" 
14eb f5				push af  
14ec 3a 00 15			ld a, (.dmark)  
14ef 32 77 fb			ld (debug_mark),a  
14f2 3a 01 15			ld a, (.dmark+1)  
14f5 32 78 fb			ld (debug_mark+1),a  
14f8 3a 02 15			ld a, (.dmark+2)  
14fb 32 79 fb			ld (debug_mark+2),a  
14fe 18 03			jr .pastdmark  
1500 ..			.dmark: db "AL0"  
1503 f1			.pastdmark: pop af  
1504			endm  
# End of macro DMARK
1504						CALLMONITOR 
1504 cd 74 17			call break_point_state  
1507				endm  
# End of macro CALLMONITOR
1507					endif 
1507 f1					pop af 
1508			 
1508 32 86 f8				ld (store_page+STORE_0_FILERUN),a 
150b					 
150b					; save bank id 
150b			 
150b 3a 48 f8				ld a,(spi_device) 
150e 32 85 f8				ld (store_page+STORE_0_BANKRUN),a 
1511			 
1511					; enable auto run of store file 
1511			 
1511 3e 01				ld a, 1 
1513 32 83 f8				ld (store_page+STORE_0_AUTOFILE),a 
1516			 
1516					; save buffer 
1516			 
1516 21 00 00				ld hl, 0 
1519 11 62 f8				ld de, store_page 
151c					if DEBUG_FORTH_WORDS 
151c						DMARK "ALw" 
151c f5				push af  
151d 3a 31 15			ld a, (.dmark)  
1520 32 77 fb			ld (debug_mark),a  
1523 3a 32 15			ld a, (.dmark+1)  
1526 32 78 fb			ld (debug_mark+1),a  
1529 3a 33 15			ld a, (.dmark+2)  
152c 32 79 fb			ld (debug_mark+2),a  
152f 18 03			jr .pastdmark  
1531 ..			.dmark: db "ALw"  
1534 f1			.pastdmark: pop af  
1535			endm  
# End of macro DMARK
1535						CALLMONITOR 
1535 cd 74 17			call break_point_state  
1538				endm  
# End of macro CALLMONITOR
1538					endif 
1538 cd 71 03			call storage_write_block	 ; save update 
153b			  
153b			 
153b			 
153b			 
153b 21 1d ee				ld hl, scratch 
153e cd 6d 15				call config_fdir 
1541			 
1541				else 
1541			 
1541				ld hl, .notav 
1541				ld de, .empty 
1541				call info_panel 
1541			 
1541				endif 
1541 c9				ret 
1542			 
1542			 
1542			 
1542			; Select storage bank 
1542			 
1542			.selbank: 
1542			 
1542				if STORAGE_SE 
1542				else 
1542			 
1542				ld hl, .notav 
1542				ld de, .empty 
1542				call info_panel 
1542				endif 
1542				 
1542 c9				ret 
1543			 
1543			if STORAGE_SE 
1543			 
1543			.config_ldir:   
1543				; Load storage bank labels into menu array 
1543			 
1543				 
1543			 
1543			 
1543 c9				ret 
1544			 
1544			 
1544			endif 
1544			 
1544			 
1544			; Save user words to storage 
1544			 
1544			.savetostore: 
1544			 
1544				if STORAGE_SE 
1544			 
1544 cd 80 15				call config_dir 
1547 21 1d ee			        ld hl, scratch 
154a 3e 00				ld a, 0 
154c cd 1d 0b				call menu 
154f					 
154f 21 1d ee				ld hl, scratch 
1552 cd 6d 15				call config_fdir 
1555			 
1555				else 
1555			 
1555				ld hl, .notav 
1555				ld de, .empty 
1555				call info_panel 
1555			 
1555				endif 
1555			 
1555 c9				ret 
1556 .. 00		.notav:    db "Feature not available",0 
156c .. 00		.empty:    db "",0 
156d			 
156d			 
156d			 
156d			if STORAGE_SE 
156d			 
156d			config_fdir: 
156d				; using the scratch dir go through and release the memory allocated for each string 
156d				 
156d 21 1d ee			ld hl, scratch 
1570 5e			.cfdir:	ld e,(hl) 
1571 23				inc hl 
1572 56				ld d,(hl) 
1573 23				inc hl 
1574			 
1574 eb				ex de, hl 
1575 cd 49 0d			call ishlzero 
1578 c8				ret z     ; return on null pointer 
1579 cd b1 12			call free 
157c eb				ex de, hl 
157d 18 f1			jr .cfdir 
157f			 
157f			 
157f c9				ret 
1580			 
1580			 
1580			config_dir: 
1580			 
1580				; for the config menus that need to build a directory of storage call this routine 
1580				; it will construct a menu in scratch to pass to menu 
1580			 
1580				; open storage device 
1580			 
1580				; execute DIR to build a list of files and their ids into scratch in menu format 
1580				; once the menu has finished then will need to call config_fdir to release the strings 
1580				 
1580				; c = number items 
1580			 
1580				 
1580 cd bd 03			call storage_get_block_0 
1583			 
1583 21 62 f8			ld hl, store_page     ; get current id count 
1586 46				ld b, (hl) 
1587 0e 00			ld c, 0    ; count of files   
1589			 
1589			 
1589 21 1d ee			ld hl, scratch 
158c 22 5e f8			ld (store_tmp2), hl    ; location to poke strings 
158f			 
158f				; check for empty drive 
158f			 
158f 3e 00			ld a, 0 
1591 b8				cp b 
1592 ca 2c 16			jp z, .dirdone 
1595			 
1595				 
1595					if DEBUG_FORTH_WORDS 
1595						DMARK "Cdc" 
1595 f5				push af  
1596 3a aa 15			ld a, (.dmark)  
1599 32 77 fb			ld (debug_mark),a  
159c 3a ab 15			ld a, (.dmark+1)  
159f 32 78 fb			ld (debug_mark+1),a  
15a2 3a ac 15			ld a, (.dmark+2)  
15a5 32 79 fb			ld (debug_mark+2),a  
15a8 18 03			jr .pastdmark  
15aa ..			.dmark: db "Cdc"  
15ad f1			.pastdmark: pop af  
15ae			endm  
# End of macro DMARK
15ae						CALLMONITOR 
15ae cd 74 17			call break_point_state  
15b1				endm  
# End of macro CALLMONITOR
15b1					endif 
15b1			 
15b1			 
15b1			.diritem:	 
15b1 c5				push bc 
15b2				; for each of the current ids do a search for them and if found push to stack 
15b2			 
15b2 21 40 00				ld hl, STORE_BLOCK_PHY 
15b5 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
15b7 58					ld e,b 
15b8			 
15b8 cd 31 06				call storage_findnextid 
15bb			 
15bb			 
15bb					; if found hl will be non zero 
15bb			 
15bb cd 49 0d				call ishlzero 
15be 28 69				jr z, .dirnotfound 
15c0			 
15c0					; increase count 
15c0			 
15c0 c1					pop bc	 
15c1 0c					inc c 
15c2 c5					push bc 
15c3					 
15c3			 
15c3					; get file header and push the file name 
15c3			 
15c3 11 62 f8				ld de, store_page 
15c6 cd 0c 03				call storage_read_block 
15c9			 
15c9					; push file id to stack 
15c9				 
15c9 3a 62 f8				ld a, (store_page) 
15cc 26 00				ld h, 0 
15ce 6f					ld l, a 
15cf			 
15cf					;call forth_push_numhl 
15cf					; TODO store id 
15cf			 
15cf e5					push hl 
15d0			 
15d0					; push extent count to stack  
15d0				 
15d0 21 65 f8				ld hl, store_page+3 
15d3			 
15d3					; get file name length 
15d3			 
15d3 cd 7e 11				call strlenz   
15d6			 
15d6 23					inc hl   ; cover zero term 
15d7 23					inc hl  ; stick the id at the end of the area 
15d8			 
15d8 e5					push hl 
15d9 c1					pop bc    ; move length to bc 
15da			 
15da cd e7 11				call malloc 
15dd			 
15dd					; TODO save malloc area to scratch 
15dd			 
15dd eb					ex de, hl 
15de 2a 5e f8				ld hl, (store_tmp2) 
15e1 73					ld (hl), e 
15e2 23					inc hl 
15e3 72					ld (hl), d 
15e4 23					inc hl 
15e5 22 5e f8				ld (store_tmp2), hl 
15e8			 
15e8					 
15e8			 
15e8					;pop hl   ; get source 
15e8			;		ex de, hl    ; swap aronund	 
15e8			 
15e8 21 65 f8				ld hl, store_page+3 
15eb					if DEBUG_FORTH_WORDS 
15eb						DMARK "CFd" 
15eb f5				push af  
15ec 3a 00 16			ld a, (.dmark)  
15ef 32 77 fb			ld (debug_mark),a  
15f2 3a 01 16			ld a, (.dmark+1)  
15f5 32 78 fb			ld (debug_mark+1),a  
15f8 3a 02 16			ld a, (.dmark+2)  
15fb 32 79 fb			ld (debug_mark+2),a  
15fe 18 03			jr .pastdmark  
1600 ..			.dmark: db "CFd"  
1603 f1			.pastdmark: pop af  
1604			endm  
# End of macro DMARK
1604						CALLMONITOR 
1604 cd 74 17			call break_point_state  
1607				endm  
# End of macro CALLMONITOR
1607					endif 
1607 ed b0				ldir 
1609			 
1609					; de is past string, move back one and store id 
1609					 
1609 1b					dec de 
160a			 
160a					; store file id 
160a			 
160a e1					pop hl 
160b eb					ex de,hl 
160c 73					ld (hl), e 
160d			 
160d					if DEBUG_FORTH_WORDS 
160d						DMARK "Cdi" 
160d f5				push af  
160e 3a 22 16			ld a, (.dmark)  
1611 32 77 fb			ld (debug_mark),a  
1614 3a 23 16			ld a, (.dmark+1)  
1617 32 78 fb			ld (debug_mark+1),a  
161a 3a 24 16			ld a, (.dmark+2)  
161d 32 79 fb			ld (debug_mark+2),a  
1620 18 03			jr .pastdmark  
1622 ..			.dmark: db "Cdi"  
1625 f1			.pastdmark: pop af  
1626			endm  
# End of macro DMARK
1626						CALLMONITOR 
1626 cd 74 17			call break_point_state  
1629				endm  
# End of macro CALLMONITOR
1629					endif 
1629					 
1629			.dirnotfound: 
1629 c1					pop bc     
162a 10 85				djnz .diritem 
162c				 
162c			.dirdone:	 
162c			 
162c 3e 00				ld a, 0 
162e 2a 5e f8				ld hl, (store_tmp2) 
1631 77					ld (hl), a 
1632 23					inc hl 
1633 77					ld (hl), a 
1634 23					inc hl 
1635					; push a count of the dir items found 
1635			 
1635			;		ld h, 0 
1635			;		ld l, c 
1635			 
1635 c9				ret 
1636			 
1636			endif 
1636			 
1636			 
1636			; Settings 
1636			; Run  
1636			 
1636			 
1636			 
1636			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1636			;;hd_menu2:   db "        2: Editor",0   
1636			;hd_menu2:   db "        2: Editor       6: Menu",0   
1636			;hd_menu3:   db "        3: Storage",0 
1636			;hd_menu4:   db "0=quit  4: Debug",0 
1636			;hd_don:     db "ON",0 
1636			;hd_doff:     db "OFF",0 
1636			; 
1636			; 
1636			; 
1636			;hardware_diags_old:       
1636			; 
1636			;.diagmenu: 
1636			;	call clear_display 
1636			;	ld a, display_row_1 
1636			;	ld de, hd_menu1 
1636			;	call str_at_display 
1636			; 
1636			;	ld a, display_row_2 
1636			;	ld de, hd_menu2 
1636			;	call str_at_display 
1636			; 
1636			;	ld a, display_row_3 
1636			;	ld de, hd_menu3 
1636			;	call str_at_display 
1636			; 
1636			;	ld a,  display_row_4 
1636			;	ld de, hd_menu4 
1636			;	call str_at_display 
1636			; 
1636			;	; display debug state 
1636			; 
1636			;	ld de, hd_don 
1636			;	ld a, (os_view_disable) 
1636			;	cp 0 
1636			;	jr z, .distog 
1636			;	ld de, hd_doff 
1636			;.distog: ld a, display_row_4+17 
1636			;	call str_at_display 
1636			; 
1636			;	call update_display 
1636			; 
1636			;	call cin_wait 
1636			; 
1636			; 
1636			; 
1636			;	cp '4' 
1636			;	jr nz, .diagn1 
1636			; 
1636			;	; debug toggle 
1636			; 
1636			;	ld a, (os_view_disable) 
1636			;	ld b, '*' 
1636			;	cp 0 
1636			;	jr z, .debtog 
1636			;	ld b, 0 
1636			;.debtog:	 
1636			;	ld a,b 
1636			;	ld (os_view_disable),a 
1636			; 
1636			;.diagn1: cp '0' 
1636			;	 ret z 
1636			; 
1636			;;	cp '1' 
1636			;;       jp z, matrix	 
1636			;;   TODO keyboard matrix test 
1636			; 
1636			;	cp '2' 
1636			;	jp z, .diagedit 
1636			; 
1636			;;	cp '6' 
1636			;;	jp z, .menutest 
1636			;;if ENABLE_BASIC 
1636			;;	cp '6' 
1636			;;	jp z, basic 
1636			;;endif 
1636			 ; 
1636			;	jp .diagmenu 
1636			; 
1636			; 
1636			;	ret 
1636			 
1636			 
1636			.debug_tog: 
1636 21 7d 16			ld hl, .menudebug 
1639				 
1639 3a 0e ee			ld a, (os_view_disable) 
163c fe 2a			cp '*' 
163e 20 04			jr nz,.tdon  
1640 3e 01			ld a, 1 
1642 18 02			jr .tog1 
1644 3e 00		.tdon: ld a, 0 
1646			 
1646			.tog1: 
1646 cd 1d 0b			call menu 
1649 fe 00			cp 0 
164b c8				ret z 
164c fe 01			cp 1    ; disable debug 
164e 28 04			jr z, .dtog0 
1650 3e 2a			ld a, '*' 
1652 18 02			jr .dtogset 
1654 3e 00		.dtog0: ld a, 0 
1656 32 0e ee		.dtogset:  ld (os_view_disable), a 
1659 c3 36 16			jp .debug_tog 
165c			 
165c			 
165c			hardware_diags:       
165c			 
165c			.diagm: 
165c 21 6f 16			ld hl, .menuitems 
165f 3e 00			ld a, 0 
1661 cd 1d 0b			call menu 
1664			 
1664 fe 00		         cp 0 
1666 c8				 ret z 
1667			 
1667 fe 02			cp 2 
1669 ca c8 16			jp z, .diagedit 
166c			 
166c			;	cp '6' 
166c			;	jp z, .menutest 
166c			;if ENABLE_BASIC 
166c			;	cp '6' 
166c			;	jp z, basic 
166c			;endif 
166c			  
166c c3 5c 16			jp .diagm 
166f			 
166f				 
166f 83 16		.menuitems:   	dw .m1 
1671 8e 16				dw .m2 
1673 95 16				dw .m3 
1675 9d 16				dw .m5 
1677 a3 16				dw .m5a 
1679 ac 16				dw .m5b 
167b 00 00				dw 0 
167d			 
167d			.menudebug: 
167d b5 16				dw .m6 
167f be 16				dw .m7 
1681 00 00				dw 0 
1683			 
1683 .. 00		.m1:   db "Key Matrix",0 
168e .. 00		.m2:   db "Editor",0 
1695 .. 00		.m3:   db "Storage",0 
169d .. 00		.m5:   db "Sound",0 
16a3 .. 00		.m5a:  db "RAM Test",0 
16ac .. 00		.m5b:  db "LCD Test",0 
16b5			 
16b5 .. 00		.m6:   db "Debug ON",0 
16be .. 00		.m7:   db "Debug OFF",0 
16c8			 
16c8			; debug editor 
16c8			 
16c8			.diagedit: 
16c8			 
16c8 21 1d ee			ld hl, scratch 
16cb			;	ld bc, 250 
16cb			;	ldir 
16cb				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
16cb 3e 00			ld a, 0 
16cd 77				ld (hl), a 
16ce 23				inc hl 
16cf 77				ld (hl), a 
16d0 23				inc hl 
16d1 77				ld (hl), a 
16d2			 
16d2 cd ec 0a		        call clear_display 
16d5 cd 0f 0b			call update_display 
16d8 3e 01			ld a, 1 
16da 32 7d fb			ld (hardware_diag), a 
16dd			.diloop: 
16dd 3e 00			ld a, display_row_1 
16df 0e 00			ld c, 0 
16e1 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16e3 1e 28			ld e, 40 
16e5			 
16e5 21 1d ee			ld hl, scratch	 
16e8 cd 4d 0d			call input_str 
16eb			 
16eb 3e 28			ld a, display_row_2 
16ed 11 1d ee			ld de, scratch 
16f0 cd ff 0a			call str_at_display 
16f3 cd 0f 0b			call update_display 
16f6			 
16f6 c3 dd 16			jp .diloop 
16f9			 
16f9			 
16f9			; pass word in hl 
16f9			; a has display location 
16f9			display_word_at: 
16f9 f5				push af 
16fa e5				push hl 
16fb 7c				ld a,h 
16fc 21 22 f1			ld hl, os_word_scratch 
16ff cd 21 10			call hexout 
1702 e1				pop hl 
1703 7d				ld a,l 
1704 21 24 f1			ld hl, os_word_scratch+2 
1707 cd 21 10			call hexout 
170a 21 26 f1			ld hl, os_word_scratch+4 
170d 3e 00			ld a,0 
170f 77				ld (hl),a 
1710 11 22 f1			ld de,os_word_scratch 
1713 f1				pop af 
1714 cd ff 0a				call str_at_display 
1717 c9				ret 
1718			 
1718			display_ptr_state: 
1718			 
1718				; to restore afterwards 
1718			 
1718 d5				push de 
1719 c5				push bc 
171a e5				push hl 
171b f5				push af 
171c			 
171c				; for use in here 
171c			 
171c			;	push bc 
171c			;	push de 
171c			;	push hl 
171c			;	push af 
171c			 
171c cd ec 0a			call clear_display 
171f			 
171f 11 f2 18			ld de, .ptrstate 
1722 3e 00			ld a, display_row_1 
1724 cd ff 0a			call str_at_display 
1727			 
1727				; display debug step 
1727			 
1727			 
1727 11 77 fb			ld de, debug_mark 
172a 3e 26			ld a, display_row_1+display_cols-2 
172c cd ff 0a			call str_at_display 
172f			 
172f				; display a 
172f 11 fc 18			ld de, .ptrcliptr 
1732 3e 28			ld a, display_row_2 
1734 cd ff 0a			call str_at_display 
1737			 
1737 f1				pop af 
1738 2a 28 f8			ld hl,(cli_ptr) 
173b 3e 30			ld a, display_row_2+8 
173d cd f9 16			call display_word_at 
1740			 
1740			 
1740				; display hl 
1740			 
1740			 
1740 11 04 19			ld de, .ptrclioptr 
1743 3e 32			ld a, display_row_2+10 
1745 cd ff 0a			call str_at_display 
1748			; 
1748			;	pop hl 
1748 3e 35			ld a, display_row_2+13 
174a 2a 26 f8			ld hl,(cli_origptr) 
174d cd f9 16			call display_word_at 
1750			; 
1750			;	 
1750			;	; display de 
1750			 
1750			;	ld de, .regstatede 
1750			;	ld a, display_row_3 
1750			;	call str_at_display 
1750			 
1750			;	pop de 
1750			;	ld h,d 
1750			;	ld l, e 
1750			;	ld a, display_row_3+3 
1750			;	call display_word_at 
1750			 
1750			 
1750				; display bc 
1750			 
1750			;	ld de, .regstatebc 
1750			;	ld a, display_row_3+10 
1750			;	call str_at_display 
1750			 
1750			;	pop bc 
1750			;	ld h,b 
1750			;	ld l, c 
1750			;	ld a, display_row_3+13 
1750			;	call display_word_at 
1750			 
1750			 
1750				; display dsp 
1750			 
1750			;	ld de, .regstatedsp 
1750			;	ld a, display_row_4 
1750			;	call str_at_display 
1750			 
1750				 
1750			;	ld hl,(cli_data_sp) 
1750			;	ld a, display_row_4+4 
1750			;	call display_word_at 
1750			 
1750				; display rsp 
1750			 
1750 11 33 19			ld de, .regstatersp 
1753 3e 82			ld a, display_row_4+10 
1755 cd ff 0a			call str_at_display 
1758			 
1758				 
1758 2a 0e f8			ld hl,(cli_ret_sp) 
175b 3e 86			ld a, display_row_4+14 
175d cd f9 16			call display_word_at 
1760			 
1760 cd 0f 0b			call update_display 
1763			 
1763 cd 69 0a			call delay1s 
1766 cd 69 0a			call delay1s 
1769 cd 69 0a			call delay1s 
176c			 
176c			 
176c cd 7c 1c			call next_page_prompt 
176f			 
176f				; restore  
176f			 
176f f1				pop af 
1770 e1				pop hl 
1771 c1				pop bc 
1772 d1				pop de 
1773 c9				ret 
1774			 
1774			break_point_state: 
1774 f5				push af 
1775			 
1775				; see if disabled 
1775			 
1775 3a 0e ee			ld a, (os_view_disable) 
1778 fe 2a			cp '*' 
177a 20 02			jr nz, .bpsgo 
177c f1				pop af 
177d c9				ret 
177e			 
177e			.bpsgo: 
177e f1				pop af 
177f f5				push af 
1780 22 0a ee			ld (os_view_hl), hl 
1783 ed 53 08 ee		ld (os_view_de), de 
1787 ed 43 06 ee		ld (os_view_bc), bc 
178b e5				push hl 
178c 6f				ld l, a 
178d 26 00			ld h, 0 
178f 22 0c ee			ld (os_view_af),hl 
1792			 
1792 21 bd fa				ld hl, display_fb0 
1795 22 d8 f8				ld (display_fb_active), hl 
1798 e1				pop hl	 
1799			 
1799 3e 31			ld a, '1' 
179b fe 2a		.bps1:  cp '*' 
179d 20 03			jr nz, .bps1b 
179f 32 0e ee			ld (os_view_disable),a 
17a2 fe 31		.bps1b:  cp '1' 
17a4 20 14			jr nz, .bps2 
17a6			 
17a6				; display reg 
17a6			 
17a6				 
17a6			 
17a6 3a 0c ee			ld a, (os_view_af) 
17a9 2a 0a ee			ld hl, (os_view_hl) 
17ac ed 5b 08 ee		ld de, (os_view_de) 
17b0 ed 4b 06 ee		ld bc, (os_view_bc) 
17b4 cd 4e 18			call display_reg_state 
17b7 c3 3a 18			jp .bpschk 
17ba			 
17ba fe 32		.bps2:  cp '2' 
17bc 20 08			jr nz, .bps3 
17be				 
17be				; display hl 
17be 2a 0a ee			ld hl, (os_view_hl) 
17c1 cd 38 19			call display_dump_at_hl 
17c4			 
17c4 18 74			jr .bpschk 
17c6			 
17c6 fe 33		.bps3:  cp '3' 
17c8 20 08			jr nz, .bps4 
17ca			 
17ca			        ; display de 
17ca 2a 08 ee			ld hl, (os_view_de) 
17cd cd 38 19			call display_dump_at_hl 
17d0			 
17d0 18 68			jr .bpschk 
17d2 fe 34		.bps4:  cp '4' 
17d4 20 08			jr nz, .bps5 
17d6			 
17d6			        ; display bc 
17d6 2a 06 ee			ld hl, (os_view_bc) 
17d9 cd 38 19			call display_dump_at_hl 
17dc			 
17dc 18 5c			jr .bpschk 
17de fe 35		.bps5:  cp '5' 
17e0 20 08		        jr nz, .bps7 
17e2			 
17e2				; display cur ptr 
17e2 2a 28 f8			ld hl, (cli_ptr) 
17e5 cd 38 19			call display_dump_at_hl 
17e8			 
17e8 18 50			jr .bpschk 
17ea fe 36		.bps7:  cp '6' 
17ec 20 08			jr nz, .bps8b 
17ee				 
17ee				; display cur orig ptr 
17ee 2a 26 f8			ld hl, (cli_origptr) 
17f1 cd 38 19			call display_dump_at_hl 
17f4 18 44			jr .bpschk 
17f6 fe 37		.bps8b:  cp '7' 
17f8 20 08			jr nz, .bps9 
17fa				 
17fa				; display dsp 
17fa 2a 0a f8			ld hl, (cli_data_sp) 
17fd cd 38 19			call display_dump_at_hl 
1800			 
1800 18 38			jr .bpschk 
1802 fe 39		.bps9:  cp '9' 
1804 20 05			jr nz, .bps8c 
1806				 
1806				; display SP 
1806			;	ld hl, sp 
1806 cd 38 19			call display_dump_at_hl 
1809			 
1809 18 2f			jr .bpschk 
180b fe 38		.bps8c:  cp '8' 
180d 20 08			jr nz, .bps8d 
180f				 
180f				; display rsp 
180f 2a 0e f8			ld hl, (cli_ret_sp) 
1812 cd 38 19			call display_dump_at_hl 
1815			 
1815 18 23			jr .bpschk 
1817 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1819 20 05			jr nz, .bps8 
181b cd 72 1a			call monitor 
181e			 
181e 18 1a			jr .bpschk 
1820 fe 30		.bps8:  cp '0' 
1822 20 16			jr nz, .bpschk 
1824			 
1824 21 1c fa				ld hl, display_fb1 
1827 22 d8 f8				ld (display_fb_active), hl 
182a cd 0f 0b				call update_display 
182d			 
182d				;ld a, (os_view_af) 
182d 2a 0a ee			ld hl, (os_view_hl) 
1830 ed 5b 08 ee		ld de, (os_view_de) 
1834 ed 4b 06 ee		ld bc, (os_view_bc) 
1838 f1				pop af 
1839 c9				ret 
183a			 
183a			.bpschk:   
183a cd 69 0a			call delay1s 
183d 3e 9f		ld a,display_row_4 + display_cols - 1 
183f 11 7a 1c		        ld de, endprg 
1842 cd ff 0a			call str_at_display 
1845 cd 0f 0b			call update_display 
1848 cd 50 69			call cin_wait 
184b			 
184b c3 9b 17			jp .bps1 
184e			 
184e			 
184e			display_reg_state: 
184e			 
184e				; to restore afterwards 
184e			 
184e d5				push de 
184f c5				push bc 
1850 e5				push hl 
1851 f5				push af 
1852			 
1852				; for use in here 
1852			 
1852 c5				push bc 
1853 d5				push de 
1854 e5				push hl 
1855 f5				push af 
1856			 
1856 cd ec 0a			call clear_display 
1859			 
1859 11 0e 19			ld de, .regstate 
185c 3e 00			ld a, display_row_1 
185e cd ff 0a			call str_at_display 
1861			 
1861				; display debug step 
1861			 
1861			 
1861 11 77 fb			ld de, debug_mark 
1864 3e 25			ld a, display_row_1+display_cols-3 
1866 cd ff 0a			call str_at_display 
1869			 
1869				; display a 
1869 11 2a 19			ld de, .regstatea 
186c 3e 28			ld a, display_row_2 
186e cd ff 0a			call str_at_display 
1871			 
1871 e1				pop hl 
1872			;	ld h,0 
1872			;	ld l, a 
1872 3e 2b			ld a, display_row_2+3 
1874 cd f9 16			call display_word_at 
1877			 
1877			 
1877				; display hl 
1877			 
1877			 
1877 11 1e 19			ld de, .regstatehl 
187a 3e 32			ld a, display_row_2+10 
187c cd ff 0a			call str_at_display 
187f			 
187f e1				pop hl 
1880 3e 35			ld a, display_row_2+13 
1882 cd f9 16			call display_word_at 
1885			 
1885				 
1885				; display de 
1885			 
1885 11 22 19			ld de, .regstatede 
1888 3e 50			ld a, display_row_3 
188a cd ff 0a			call str_at_display 
188d			 
188d e1				pop hl 
188e			;	ld h,d 
188e			;	ld l, e 
188e 3e 53			ld a, display_row_3+3 
1890 cd f9 16			call display_word_at 
1893			 
1893			 
1893				; display bc 
1893			 
1893 11 26 19			ld de, .regstatebc 
1896 3e 5a			ld a, display_row_3+10 
1898 cd ff 0a			call str_at_display 
189b			 
189b e1				pop hl 
189c			;	ld h,b 
189c			;	ld l, c 
189c 3e 5d			ld a, display_row_3+13 
189e cd f9 16			call display_word_at 
18a1			 
18a1			 
18a1				; display dsp 
18a1			 
18a1 11 2e 19			ld de, .regstatedsp 
18a4 3e 78			ld a, display_row_4 
18a6 cd ff 0a			call str_at_display 
18a9			 
18a9				 
18a9 2a 0a f8			ld hl,(cli_data_sp) 
18ac 3e 7c			ld a, display_row_4+4 
18ae cd f9 16			call display_word_at 
18b1			 
18b1				; display rsp 
18b1			 
18b1 11 33 19			ld de, .regstatersp 
18b4 3e 82			ld a, display_row_4+10 
18b6 cd ff 0a			call str_at_display 
18b9			 
18b9				 
18b9 2a 0e f8			ld hl,(cli_ret_sp) 
18bc 3e 86			ld a, display_row_4+14 
18be cd f9 16			call display_word_at 
18c1			 
18c1 cd 0f 0b			call update_display 
18c4			 
18c4			;	call delay1s 
18c4			;	call delay1s 
18c4			;	call delay1s 
18c4			 
18c4			 
18c4			;	call next_page_prompt 
18c4			 
18c4				; restore  
18c4			 
18c4 f1				pop af 
18c5 e1				pop hl 
18c6 c1				pop bc 
18c7 d1				pop de 
18c8 c9				ret 
18c9			 
18c9 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
18dd .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
18f2 .. 00		.ptrstate:	db "Ptr State",0 
18fc .. 00		.ptrcliptr:     db "cli_ptr",0 
1904 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
190e .. 00		.regstate:	db "Reg State (1/0)",0 
191e .. 00		.regstatehl:	db "HL:",0 
1922 .. 00		.regstatede:	db "DE:",0 
1926 .. 00		.regstatebc:	db "BC:",0 
192a .. 00		.regstatea:	db "A :",0 
192e .. 00		.regstatedsp:	db "DSP:",0 
1933 .. 00		.regstatersp:	db "RSP:",0 
1938			 
1938			display_dump_at_hl: 
1938 e5				push hl 
1939 d5				push de 
193a c5				push bc 
193b f5				push af 
193c			 
193c 22 40 f1			ld (os_cur_ptr),hl	 
193f cd ec 0a			call clear_display 
1942 cd 84 1b			call dumpcont 
1945			;	call delay1s 
1945			;	call next_page_prompt 
1945			 
1945			 
1945 f1				pop af 
1946 c1				pop bc 
1947 d1				pop de 
1948 e1				pop hl 
1949 c9				ret 
194a			 
194a			;if ENABLE_BASIC 
194a			;	include "nascombasic.asm" 
194a			;	basic: 
194a			;	include "forth/FORTH.ASM" 
194a			;endif 
194a			 
194a			; eof 
194a			 
194a			 
# End of file firmware_diags.asm
194a			  
194a			  
194a			  
194a			  
194a			; eof  
194a			  
# End of file firmware.asm
194a			 
194a			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
194a			;if BASE_KEV  
194a			;baseram: equ 08000h 
194a			;endif 
194a			 
194a			;if BASE_SC114 
194a			;baseram:     equ    endofcode 
194a			;endif 
194a			 
194a			 
194a			; start system 
194a			 
194a			coldstart: 
194a				; set sp 
194a				; di/ei 
194a			 
194a f3				di 
194b 31 fd ff			ld sp, tos 
194e			;	ei 
194e			 
194e			 
194e				; disable breakpoint by default 
194e			 
194e 3e 2a			ld a,'*' 
1950 32 0e ee			ld (os_view_disable),a 
1953			 
1953				; init hardware 
1953			 
1953				; init keyboard and screen hardware 
1953			 
1953 cd 03 00			call hardware_init 
1956			 
1956			 
1956				; detect if any keys are held down to enable breakpoints at start up 
1956			 
1956 cd 61 69			call cin  
1959 fe 00			cp 0 
195b 28 03			jr z, .nokeys 
195d			 
195d				;call hardware_diags 
195d cd aa 13			call config 
1960			 
1960			;	ld de, .bpen 
1960			;	ld a, display_row_4 
1960			;	call str_at_display 
1960			;	call update_display 
1960			; 
1960			;	ld a,0 
1960			;	ld (os_view_disable),a 
1960			; 
1960			;.bpwait: 
1960			;	call cin 
1960			;	cp 0 
1960			;	jr z, .bpwait 
1960			;	jr .nokeys 
1960			; 
1960			; 
1960			;.bpen:  db "Break points enabled!",0 
1960			 
1960			 
1960			 
1960			 
1960			 
1960			 
1960			.nokeys: 
1960			 
1960			 
1960				 
1960			 
1960			;jp  testkey 
1960			 
1960			;call storage_get_block_0 
1960			; 
1960			;ld hl, 0 
1960			;ld de, store_page 
1960			;call storage_read_block 
1960			 
1960				 
1960			;ld hl, 10 
1960			;ld de, store_page 
1960			;call storage_read_block 
1960			 
1960			 
1960			 
1960			 
1960			 
1960			;stop:	nop 
1960			;	jp stop 
1960			 
1960			 
1960			 
1960			main: 
1960 cd ec 0a			call clear_display 
1963 cd 0f 0b			call update_display 
1966			 
1966			 
1966			 
1966			;	call testlcd 
1966			 
1966			 
1966			 
1966 cd 42 20			call forth_init 
1969			 
1969			 
1969			warmstart: 
1969 cd 18 20			call forth_warmstart 
196c			 
196c				; run startup word load 
196c			        ; TODO prevent this running at warmstart after crash  
196c			 
196c				if STARTUP_ENABLE 
196c					if STORAGE_SE 
196c cd ef 64					call forth_autoload 
196f					endif 
196f cd fe 61				call forth_startup 
1972			 
1972			 
1972				endif 
1972			 
1972				; show free memory after boot 
1972 11 0c 1a			ld de, freeram 
1975 3e 00			ld a, display_row_1 
1977 cd ff 0a			call str_at_display 
197a			 
197a			; Or use heap_size word???? 
197a 21 03 ee			ld hl, heap_end 
197d 11 0e 80			ld de, heap_start 
1980 ed 52			sbc hl, de 
1982 e5				push hl 
1983 7c				ld a,h	         	 
1984 21 22 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1987 cd 21 10			call hexout 
198a e1			   	pop hl 
198b			 
198b 7d				ld a,l 
198c 21 24 f1			ld hl, os_word_scratch+2 
198f cd 21 10			call hexout 
1992 21 26 f1			ld hl, os_word_scratch+4 
1995 3e 00			ld a, 0 
1997 77				ld (hl),a 
1998 11 22 f1			ld de, os_word_scratch 
199b 3e 0d			ld a, display_row_1 + 13 
199d cd ff 0a			call str_at_display 
19a0 cd 0f 0b			call update_display 
19a3			 
19a3			 
19a3				;call demo 
19a3			 
19a3			 
19a3				; init scratch input area for cli commands 
19a3			 
19a3 21 44 f1			ld hl, os_cli_cmd 
19a6 3e 00			ld a,0 
19a8 77				ld (hl),a 
19a9 23				inc hl 
19aa 77				ld (hl),a 
19ab			 
19ab 3e 00			ld a,0 
19ad 32 43 f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
19b0			 
19b0 32 40 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
19b3 32 41 f1			ld (os_cur_ptr+1),a	 
19b6			 
19b6 32 22 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
19b9 32 23 f1			ld (os_word_scratch+1),a	 
19bc				 
19bc			 
19bc				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19bc 21 44 f1			ld hl, os_cli_cmd 
19bf			 
19bf 3e 00			ld a, 0		 ; init cli input 
19c1 77				ld (hl), a 
19c2 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19c4			cli: 
19c4				; show cli prompt 
19c4				;push af 
19c4				;ld a, 0 
19c4				;ld de, prompt 
19c4				;call str_at_display 
19c4			 
19c4				;call update_display 
19c4				;pop af 
19c4				;inc a 
19c4				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
19c4 0e 00			ld c, 0 
19c6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
19c8 1e 28			ld e, 40 
19ca			 
19ca 21 44 f1			ld hl, os_cli_cmd 
19cd			 
19cd				STACKFRAME OFF $fefe $9f9f 
19cd				if DEBUG_STACK_IMB 
19cd					if OFF 
19cd						exx 
19cd						ld de, $fefe 
19cd						ld a, d 
19cd						ld hl, curframe 
19cd						call hexout 
19cd						ld a, e 
19cd						ld hl, curframe+2 
19cd						call hexout 
19cd						ld hl, $fefe 
19cd						push hl 
19cd						ld hl, $9f9f 
19cd						push hl 
19cd						exx 
19cd					endif 
19cd				endif 
19cd			endm 
# End of macro STACKFRAME
19cd			 
19cd cd 4d 0d			call input_str 
19d0			 
19d0				STACKFRAMECHK OFF $fefe $9f9f 
19d0				if DEBUG_STACK_IMB 
19d0					if OFF 
19d0						exx 
19d0						ld hl, $9f9f 
19d0						pop de   ; $9f9f 
19d0						call cmp16 
19d0						jr nz, .spnosame 
19d0						ld hl, $fefe 
19d0						pop de   ; $fefe 
19d0						call cmp16 
19d0						jr z, .spfrsame 
19d0						.spnosame: call showsperror 
19d0						.spfrsame: nop 
19d0						exx 
19d0					endif 
19d0				endif 
19d0			endm 
# End of macro STACKFRAMECHK
19d0			 
19d0				; copy input to last command 
19d0			 
19d0 21 44 f1			ld hl, os_cli_cmd 
19d3 11 43 f2			ld de, os_last_cmd 
19d6 01 ff 00			ld bc, 255 
19d9 ed b0			ldir 
19db			 
19db				; wipe current buffer 
19db			 
19db			;	ld a, 0 
19db			;	ld hl, os_cli_cmd 
19db			;	ld de, os_cli_cmd+1 
19db			;	ld bc, 254 
19db			;	ldir 
19db				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
19db			;	call strcpy 
19db			;	ld a, 0 
19db			;	ld (hl), a 
19db			;	inc hl 
19db			;	ld (hl), a 
19db			;	inc hl 
19db			;	ld (hl), a 
19db			 
19db				; switch frame buffer to program  
19db			 
19db 21 1c fa				ld hl, display_fb1 
19de 22 d8 f8				ld (display_fb_active), hl 
19e1			 
19e1			;	nop 
19e1				STACKFRAME ON $fbfe $8f9f 
19e1				if DEBUG_STACK_IMB 
19e1					if ON 
19e1						exx 
19e1						ld de, $fbfe 
19e1						ld a, d 
19e1						ld hl, curframe 
19e1						call hexout 
19e1						ld a, e 
19e1						ld hl, curframe+2 
19e1						call hexout 
19e1						ld hl, $fbfe 
19e1						push hl 
19e1						ld hl, $8f9f 
19e1						push hl 
19e1						exx 
19e1					endif 
19e1				endif 
19e1			endm 
# End of macro STACKFRAME
19e1				; first time into the parser so pass over the current scratch pad 
19e1 21 44 f1			ld hl,os_cli_cmd 
19e4				; tokenise the entered statement(s) in HL 
19e4 cd bb 20			call forthparse 
19e7			        ; exec forth statements in top of return stack 
19e7 cd fb 20			call forthexec 
19ea				;call forthexec_cleanup 
19ea			;	call parsenext 
19ea			 
19ea				STACKFRAMECHK ON $fbfe $8f9f 
19ea				if DEBUG_STACK_IMB 
19ea					if ON 
19ea						exx 
19ea						ld hl, $8f9f 
19ea						pop de   ; $8f9f 
19ea						call cmp16 
19ea						jr nz, .spnosame 
19ea						ld hl, $fbfe 
19ea						pop de   ; $fbfe 
19ea						call cmp16 
19ea						jr z, .spfrsame 
19ea						.spnosame: call showsperror 
19ea						.spfrsame: nop 
19ea						exx 
19ea					endif 
19ea				endif 
19ea			endm 
# End of macro STACKFRAMECHK
19ea				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
19ea			 
19ea 3e 78			ld a, display_row_4 
19ec 11 1e 1a			ld de, endprog 
19ef			 
19ef cd 0f 0b			call update_display		 
19f2			 
19f2 cd 7c 1c			call next_page_prompt 
19f5			 
19f5				; switch frame buffer to cli 
19f5			 
19f5 21 bd fa				ld hl, display_fb0 
19f8 22 d8 f8				ld (display_fb_active), hl 
19fb			 
19fb			 
19fb cd ec 0a		        call clear_display 
19fe cd 0f 0b			call update_display		 
1a01			 
1a01 21 44 f1			ld hl, os_cli_cmd 
1a04			 
1a04 3e 00			ld a, 0		 ; init cli input 
1a06 77				ld (hl), a 
1a07			 
1a07				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1a07			 
1a07				; now on last line 
1a07			 
1a07				; TODO scroll screen up 
1a07			 
1a07				; TODO instead just clear screen and place at top of screen 
1a07			 
1a07			;	ld a, 0 
1a07			;	ld (f_cursor_ptr),a 
1a07			 
1a07				;call clear_display 
1a07				;call update_display 
1a07			 
1a07				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1a07 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1a09 c3 c4 19			jp cli 
1a0c			 
1a0c .. 00		freeram: db "Free bytes: $",0 
1a1a ..			asc: db "1A2F" 
1a1e .. 00		endprog: db "End prog...",0 
1a2a			 
1a2a			testenter2:   
1a2a 21 4f ee			ld hl,scratch+50 
1a2d 22 40 f1			ld (os_cur_ptr),hl 
1a30 c3 c4 19			jp cli 
1a33			 
1a33			testenter:  
1a33			 
1a33 21 1a 1a			ld hl,asc 
1a36			;	ld a,(hl) 
1a36			;	call nibble2val 
1a36 cd 77 10			call get_byte 
1a39			 
1a39			 
1a39			;	ld a,(hl) 
1a39			;	call atohex 
1a39			 
1a39			;	call fourehexhl 
1a39 32 4f ee			ld (scratch+50),a 
1a3c			 
1a3c			 
1a3c			 
1a3c 21 1c 1a			ld hl,asc+2 
1a3f			;	ld a, (hl) 
1a3f			;	call nibble2val 
1a3f cd 77 10			call get_byte 
1a42			 
1a42			;	call fourehexhl 
1a42 32 51 ee			ld (scratch+52),a 
1a45				 
1a45 21 4f ee			ld hl,scratch+50 
1a48 22 40 f1			ld (os_cur_ptr),hl 
1a4b c3 c4 19			jp cli 
1a4e			 
1a4e			enter:	 
1a4e 3a 21 ee			ld a,(scratch+4) 
1a51 fe 00			cp 0 
1a53 28 0c			jr z, .entercont 
1a55				; no, not a null term line so has an address to work out.... 
1a55			 
1a55 21 1f ee			ld hl,scratch+2 
1a58 cd d7 10			call get_word_hl 
1a5b			 
1a5b 22 40 f1			ld (os_cur_ptr),hl	 
1a5e c3 c4 19			jp cli 
1a61			 
1a61			 
1a61			.entercont:  
1a61			 
1a61 21 1f ee			ld hl, scratch+2 
1a64 cd 77 10			call get_byte 
1a67			 
1a67 2a 40 f1		   	ld hl,(os_cur_ptr) 
1a6a 77					ld (hl),a 
1a6b 23					inc hl 
1a6c 22 40 f1				ld (os_cur_ptr),hl 
1a6f				 
1a6f			; get byte  
1a6f			 
1a6f			 
1a6f c3 c4 19			jp cli 
1a72			 
1a72			 
1a72			; basic monitor support 
1a72			 
1a72			monitor: 
1a72				;  
1a72 cd ec 0a			call clear_display 
1a75 3e 00			ld a, 0 
1a77 11 bf 1a			ld de, .monprompt 
1a7a cd ff 0a			call str_at_display 
1a7d cd 0f 0b			call update_display 
1a80			 
1a80				; get a monitor command 
1a80			 
1a80 0e 00			ld c, 0     ; entry at top left 
1a82 16 64			ld d, 100   ; max buffer size 
1a84 1e 0f			ld e, 15    ; input scroll area 
1a86 3e 00			ld a, 0     ; init string 
1a88 21 1b f0			ld hl, os_input 
1a8b 77				ld (hl), a 
1a8c 23				inc hl 
1a8d 77				ld (hl), a 
1a8e 21 1b f0			ld hl, os_input 
1a91 3e 01			ld a, 1     ; init string 
1a93 cd 4d 0d			call input_str 
1a96			 
1a96 cd ec 0a		        call clear_display 
1a99 cd 0f 0b			call update_display		 
1a9c			 
1a9c 3a 1b f0			ld a, (os_input) 
1a9f cd 75 11			call toUpper 
1aa2 fe 48		        cp 'H' 
1aa4 28 6f		        jr z, .monhelp 
1aa6 fe 44			cp 'D'		; dump 
1aa8 ca 36 1b			jp z, .mondump	 
1aab fe 43			cp 'C'		; dump 
1aad ca 50 1b			jp z, .moncdump	 
1ab0 fe 4d			cp 'M'		; dump 
1ab2 ca c1 1a			jp z, .moneditstart 
1ab5 fe 55			cp 'U'		; dump 
1ab7 28 14			jr z, .monedit	 
1ab9 fe 51			cp 'Q'		; dump 
1abb c8				ret z	 
1abc			 
1abc			 
1abc				; TODO "S" to access symbol by name and not need the address 
1abc				; TODO "F" to find a string in memory 
1abc			 
1abc c3 72 1a			jp monitor 
1abf			 
1abf .. 00		.monprompt: db ">", 0 
1ac1			 
1ac1			.moneditstart: 
1ac1				; get starting address 
1ac1			 
1ac1 21 1d f0			ld hl,os_input+2 
1ac4 cd d7 10			call get_word_hl 
1ac7			 
1ac7 22 40 f1			ld (os_cur_ptr),hl	 
1aca			 
1aca c3 72 1a			jp monitor 
1acd			 
1acd			.monedit: 
1acd				; get byte to load 
1acd			 
1acd 21 1d f0			ld hl,os_input+2 
1ad0 cd 77 10			call get_byte 
1ad3			 
1ad3				; get address to update 
1ad3 2a 40 f1			ld hl, (os_cur_ptr) 
1ad6			 
1ad6				; update byte 
1ad6			 
1ad6 77				ld (hl), a 
1ad7			 
1ad7				; move to next address and save it 
1ad7			 
1ad7 23				inc hl 
1ad8 22 40 f1			ld (os_cur_ptr),hl	 
1adb			 
1adb c3 72 1a			jp monitor 
1ade			 
1ade			 
1ade .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1af2 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1b0e .. 00		.monhelptext3:  db "Q-Quit",0 
1b15			        
1b15			.monhelp: 
1b15 3e 00			ld a, display_row_1 
1b17 11 de 1a		        ld de, .monhelptext1 
1b1a			 
1b1a cd ff 0a			call str_at_display 
1b1d 3e 28			ld a, display_row_2 
1b1f 11 f2 1a		        ld de, .monhelptext2 
1b22					 
1b22 cd ff 0a			call str_at_display 
1b25 3e 50			ld a, display_row_3 
1b27 11 0e 1b		        ld de, .monhelptext3 
1b2a					 
1b2a cd ff 0a			call str_at_display 
1b2d cd 0f 0b			call update_display		 
1b30			 
1b30 cd 7c 1c			call next_page_prompt 
1b33 c3 72 1a			jp monitor 
1b36			 
1b36			.mondump:    
1b36 21 1d f0			ld hl,os_input+2 
1b39 cd d7 10			call get_word_hl 
1b3c			 
1b3c 22 40 f1			ld (os_cur_ptr),hl	 
1b3f cd 84 1b			call dumpcont 
1b42 3e 78			ld a, display_row_4 
1b44 11 1e 1a			ld de, endprog 
1b47			 
1b47 cd 0f 0b			call update_display		 
1b4a			 
1b4a cd 7c 1c			call next_page_prompt 
1b4d c3 72 1a			jp monitor 
1b50			.moncdump: 
1b50 cd 84 1b			call dumpcont 
1b53 3e 78			ld a, display_row_4 
1b55 11 1e 1a			ld de, endprog 
1b58			 
1b58 cd 0f 0b			call update_display		 
1b5b			 
1b5b cd 7c 1c			call next_page_prompt 
1b5e c3 72 1a			jp monitor 
1b61			 
1b61			 
1b61			; TODO symbol access  
1b61			 
1b61			.symbols:     ;; A list of symbols that can be called up  
1b61 bd fa			dw display_fb0 
1b63 .. 00			db "fb0",0  
1b67 62 f8		     	dw store_page 
1b69 .. 00			db "store_page",0 
1b74			 
1b74			 
1b74			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1b74			 
1b74 3a 1e ee			ld a,(scratch+1) 
1b77 fe 00			cp 0 
1b79 28 09			jr z, dumpcont 
1b7b			 
1b7b				; no, not a null term line so has an address to work out.... 
1b7b			 
1b7b 21 1f ee			ld hl,scratch+2 
1b7e cd d7 10			call get_word_hl 
1b81			 
1b81 22 40 f1			ld (os_cur_ptr),hl	 
1b84			 
1b84			 
1b84			 
1b84			dumpcont: 
1b84			 
1b84				; dump bytes at ptr 
1b84			 
1b84			 
1b84 3e 00			ld a, display_row_1 
1b86 2a d8 f8			ld hl, (display_fb_active) 
1b89 cd 20 0d			call addatohl 
1b8c cd b4 1b			call .dumpbyterow 
1b8f			 
1b8f 3e 28			ld a, display_row_2 
1b91 2a d8 f8			ld hl, (display_fb_active) 
1b94 cd 20 0d			call addatohl 
1b97 cd b4 1b			call .dumpbyterow 
1b9a			 
1b9a			 
1b9a 3e 50			ld a, display_row_3 
1b9c 2a d8 f8			ld hl, (display_fb_active) 
1b9f cd 20 0d			call addatohl 
1ba2 cd b4 1b			call .dumpbyterow 
1ba5			 
1ba5 3e 78			ld a, display_row_4 
1ba7 2a d8 f8			ld hl, (display_fb_active) 
1baa cd 20 0d			call addatohl 
1bad cd b4 1b			call .dumpbyterow 
1bb0			 
1bb0 cd 0f 0b			call update_display 
1bb3			;		jp cli 
1bb3 c9				ret 
1bb4			 
1bb4			.dumpbyterow: 
1bb4			 
1bb4				;push af 
1bb4			 
1bb4 e5				push hl 
1bb5			 
1bb5				; calc where to poke the ascii 
1bb5			if display_cols == 20 
1bb5				ld a, 16 
1bb5			else 
1bb5 3e 1f			ld a, 31 
1bb7			endif 
1bb7			 
1bb7 cd 20 0d			call addatohl 
1bba 22 22 f1			ld (os_word_scratch),hl  		; save pos for later 
1bbd			 
1bbd			 
1bbd			; display decoding address 
1bbd 2a 40 f1		   	ld hl,(os_cur_ptr) 
1bc0			 
1bc0 7c				ld a,h 
1bc1 e1				pop hl 
1bc2 e5				push hl 
1bc3			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1bc3 cd 21 10			call hexout 
1bc6 2a 40 f1		   	ld hl,(os_cur_ptr) 
1bc9			 
1bc9 7d				ld a,l 
1bca e1				pop hl 
1bcb 23				inc hl 
1bcc 23				inc hl 
1bcd e5				push hl 
1bce			;	ld hl, os_word_scratch+2 
1bce cd 21 10			call hexout 
1bd1 e1				pop hl 
1bd2 23				inc hl 
1bd3 23				inc hl 
1bd4				;ld hl, os_word_scratch+4 
1bd4 3e 3a			ld a, ':' 
1bd6 77				ld (hl),a 
1bd7 23				inc hl 
1bd8				;ld a, 0 
1bd8				;ld (hl),a 
1bd8				;ld de, os_word_scratch 
1bd8				;pop af 
1bd8				;push af 
1bd8			;		ld a, display_row_2 
1bd8			;		call str_at_display 
1bd8			;		call update_display 
1bd8			 
1bd8			 
1bd8			;pop af 
1bd8			;	add 5 
1bd8			 
1bd8			if display_cols == 20 
1bd8				ld b, 4 
1bd8			else 
1bd8 06 08			ld b, 8 
1bda			endif	 
1bda			 
1bda			.dumpbyte: 
1bda c5				push bc 
1bdb e5				push hl 
1bdc			 
1bdc			 
1bdc 2a 40 f1		   	ld hl,(os_cur_ptr) 
1bdf 7e					ld a,(hl) 
1be0			 
1be0					; poke the ascii to display 
1be0 2a 22 f1				ld hl,(os_word_scratch) 
1be3 77					ld (hl),a 
1be4 23					inc hl 
1be5 22 22 f1				ld (os_word_scratch),hl 
1be8			 
1be8					 
1be8			 
1be8			 
1be8 e1					pop hl 
1be9 e5					push hl 
1bea			 
1bea cd 21 10				call hexout 
1bed			 
1bed					 
1bed 2a 40 f1		   	ld hl,(os_cur_ptr) 
1bf0 23				inc hl 
1bf1 22 40 f1		   	ld (os_cur_ptr),hl 
1bf4			 
1bf4 e1					pop hl 
1bf5 23					inc hl 
1bf6 23					inc hl 
1bf7 23					inc hl 
1bf8			 
1bf8			 
1bf8			 
1bf8					;ld a,0 
1bf8					;ld (os_word_scratch+2),a 
1bf8					;pop af 
1bf8					;push af 
1bf8			 
1bf8					;ld de, os_word_scratch 
1bf8					;call str_at_display 
1bf8			;		call update_display 
1bf8			;		pop af 
1bf8 c1					pop bc 
1bf9 c6 03				add 3 
1bfb 10 dd			djnz .dumpbyte 
1bfd			 
1bfd				 
1bfd			 
1bfd c9				ret 
1bfe			 
1bfe			jump:	 
1bfe			 
1bfe 21 1f ee			ld hl,scratch+2 
1c01 cd d7 10			call get_word_hl 
1c04				;ld hl,(scratch+2) 
1c04				;call fourehexhl 
1c04			 
1c04 22 40 f1			ld (os_cur_ptr),hl	 
1c07			 
1c07 e9				jp (hl) 
1c08			 
1c08			 
1c08			 
1c08			; TODO implement a basic monitor mode to start with 
1c08			 
1c08			 
1c08			 
1c08			 
1c08			 
1c08			 
1c08			 
1c08			 
1c08			 
1c08			; testing and demo code during development 
1c08			 
1c08			 
1c08 .. 00		str1: db "Enter some text...",0 
1c1b .. 00		clear: db "                    ",0 
1c30			 
1c30			demo: 
1c30			 
1c30			 
1c30			 
1c30			;	call update_display 
1c30			 
1c30				; init scratch input area for testing 
1c30 21 1d ee			ld hl, scratch	 
1c33 3e 00			ld a,0 
1c35 77				ld (hl),a 
1c36			 
1c36			 
1c36 3e 28		            LD   A, display_row_2 
1c38			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c38 11 08 1c		            LD   DE, str1 
1c3b cd ff 0a			call str_at_display 
1c3e			 
1c3e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c3e			cloop:	 
1c3e 3e 50		            LD   A, display_row_3 
1c40			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c40 11 1b 1c		            LD   DE, clear 
1c43			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1c43 cd ff 0a				call str_at_display 
1c46 3e 78			ld a, display_row_4 
1c48 11 78 1c			ld de, prompt 
1c4b			 
1c4b cd ff 0a				call str_at_display 
1c4e cd 0f 0b			call update_display 
1c51			 
1c51 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c53 16 0a			ld d, 10 
1c55 21 1d ee			ld hl, scratch	 
1c58 cd 4d 0d			call input_str 
1c5b			 
1c5b			;	call clear_display 
1c5b			;'	call update_display 
1c5b			 
1c5b 3e 00		            LD   A, display_row_1 
1c5d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c5d 11 1b 1c		            LD   DE, clear 
1c60 cd ff 0a				call str_at_display 
1c63			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c63 3e 00		            LD   A, display_row_1 
1c65			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c65 11 1d ee		            LD   DE, scratch 
1c68			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c68 cd ff 0a				call str_at_display 
1c6b cd 0f 0b			call update_display 
1c6e			 
1c6e 3e 00				ld a,0 
1c70 21 1d ee			ld hl, scratch 
1c73 77				ld (hl),a 
1c74			 
1c74 00				nop 
1c75 c3 3e 1c			jp cloop 
1c78			 
1c78			 
1c78			 
1c78			; OS Prompt 
1c78			 
1c78 .. 00		prompt: db ">",0 
1c7a .. 00		endprg: db "?",0 
1c7c			 
1c7c			 
1c7c			; handy next page prompt 
1c7c			next_page_prompt: 
1c7c e5				push hl 
1c7d d5				push de 
1c7e f5				push af 
1c7f c5				push bc 
1c80			 
1c80 3e 9f			ld a,display_row_4 + display_cols - 1 
1c82 11 7a 1c		        ld de, endprg 
1c85 cd ff 0a			call str_at_display 
1c88 cd 0f 0b			call update_display 
1c8b cd 50 69			call cin_wait 
1c8e c1				pop bc 
1c8f f1				pop af 
1c90 d1				pop de 
1c91 e1				pop hl 
1c92			 
1c92			 
1c92 c9				ret 
1c93			 
1c93			 
1c93			; forth parser 
1c93			 
1c93			; My forth kernel 
1c93			include "forth_kernel.asm" 
1c93			; 
1c93			; kernel to the forth OS 
1c93			 
1c93			DS_TYPE_STR: equ 1     ; string type 
1c93			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c93			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c93			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c93			 
1c93			FORTH_PARSEV1: equ 0 
1c93			FORTH_PARSEV2: equ 0 
1c93			FORTH_PARSEV3: equ 0 
1c93			FORTH_PARSEV4: equ 0 
1c93			FORTH_PARSEV5: equ 1 
1c93			 
1c93			;if FORTH_PARSEV5 
1c93			;	FORTH_END_BUFFER: equ 0 
1c93			;else 
1c93			FORTH_END_BUFFER: equ 127 
1c93			;endif 
1c93			 
1c93			FORTH_TRUE: equ 1 
1c93			FORTH_FALSE: equ 0 
1c93			 
1c93			if FORTH_PARSEV4 
1c93			include "forth_stackops.asm" 
1c93			endif 
1c93			 
1c93			if FORTH_PARSEV5 
1c93			include "forth_stackopsv5.asm" 
1c93			 
1c93			; Stack operations for v5 parser on wards 
1c93			; * DATA stack 
1c93			; * LOOP stack 
1c93			; * RETURN stack 
1c93			 
1c93			 
1c93			 
1c93			FORTH_CHK_DSP_UNDER: macro 
1c93				push hl 
1c93				push de 
1c93				ld hl,(cli_data_sp) 
1c93				ld de, cli_data_stack 
1c93				call cmp16 
1c93				jp c, fault_dsp_under 
1c93				pop de 
1c93				pop hl 
1c93				endm 
1c93			 
1c93			 
1c93			FORTH_CHK_RSP_UNDER: macro 
1c93				push hl 
1c93				push de 
1c93				ld hl,(cli_ret_sp) 
1c93				ld de, cli_ret_stack 
1c93				call cmp16 
1c93				jp c, fault_rsp_under 
1c93				pop de 
1c93				pop hl 
1c93				endm 
1c93			 
1c93			FORTH_CHK_LOOP_UNDER: macro 
1c93				push hl 
1c93				push de 
1c93				ld hl,(cli_loop_sp) 
1c93				ld de, cli_loop_stack 
1c93				call cmp16 
1c93				jp c, fault_loop_under 
1c93				pop de 
1c93				pop hl 
1c93				endm 
1c93			 
1c93			FORTH_ERR_TOS_NOTSTR: macro 
1c93				; TOSO might need more for checks when used 
1c93				push af 
1c93				ld a,(hl) 
1c93				cp DS_TYPE_STR 
1c93				jp nz, type_faultn   
1c93				pop af 
1c93				endm 
1c93			 
1c93			FORTH_ERR_TOS_NOTNUM: macro 
1c93				push af 
1c93				ld a,(hl) 
1c93				cp DS_TYPE_INUM 
1c93				jp nz, type_faultn   
1c93				pop af 
1c93				endm 
1c93			 
1c93			 
1c93			; increase data stack pointer and save hl to it 
1c93				 
1c93			FORTH_DSP_NEXT: macro 
1c93				call macro_forth_dsp_next 
1c93				endm 
1c93			 
1c93			 
1c93			macro_forth_dsp_next: 
1c93				if DEBUG_FORTH_STACK_GUARD 
1c93 cd c8 62				call check_stacks 
1c96				endif 
1c96 e5				push hl 
1c97 d5				push de 
1c98 eb				ex de,hl 
1c99 2a 0a f8			ld hl,(cli_data_sp) 
1c9c 23				inc hl 
1c9d 23				inc hl 
1c9e			 
1c9e			; PARSEV5 
1c9e 23				inc hl 
1c9f 22 0a f8			ld (cli_data_sp),hl 
1ca2 73				ld (hl), e 
1ca3 23				inc hl 
1ca4 72				ld (hl), d 
1ca5 d1				pop de 
1ca6 e1				pop hl 
1ca7				if DEBUG_FORTH_STACK_GUARD 
1ca7 cd c8 62				call check_stacks 
1caa				endif 
1caa c9				ret 
1cab			 
1cab			 
1cab			; increase ret stack pointer and save hl to it 
1cab				 
1cab			FORTH_RSP_NEXT: macro 
1cab				call macro_forth_rsp_next 
1cab				endm 
1cab			 
1cab			macro_forth_rsp_next: 
1cab				if DEBUG_FORTH_STACK_GUARD 
1cab cd c8 62				call check_stacks 
1cae				endif 
1cae e5				push hl 
1caf d5				push de 
1cb0 eb				ex de,hl 
1cb1 2a 0e f8			ld hl,(cli_ret_sp) 
1cb4 23				inc hl 
1cb5 23				inc hl 
1cb6 22 0e f8			ld (cli_ret_sp),hl 
1cb9 73				ld (hl), e 
1cba 23				inc hl 
1cbb 72				ld (hl), d 
1cbc d1				pop de 
1cbd e1				pop hl 
1cbe				if DEBUG_FORTH_STACK_GUARD 
1cbe cd c8 62				call check_stacks 
1cc1				endif 
1cc1 c9				ret 
1cc2			 
1cc2			; get current ret stack pointer and save to hl  
1cc2				 
1cc2			FORTH_RSP_TOS: macro 
1cc2				call macro_forth_rsp_tos 
1cc2				endm 
1cc2			 
1cc2			macro_forth_rsp_tos: 
1cc2				;push de 
1cc2 2a 0e f8			ld hl,(cli_ret_sp) 
1cc5 cd fd 1c			call loadhlptrtohl 
1cc8				;ld e, (hl) 
1cc8				;inc hl 
1cc8				;ld d, (hl) 
1cc8				;ex de, hl 
1cc8					if DEBUG_FORTH_WORDS 
1cc8			;			DMARK "RST" 
1cc8						CALLMONITOR 
1cc8 cd 74 17			call break_point_state  
1ccb				endm  
# End of macro CALLMONITOR
1ccb					endif 
1ccb				;pop de 
1ccb c9				ret 
1ccc			 
1ccc			; pop ret stack pointer 
1ccc				 
1ccc			FORTH_RSP_POP: macro 
1ccc				call macro_forth_rsp_pop 
1ccc				endm 
1ccc			 
1ccc			 
1ccc			macro_forth_rsp_pop: 
1ccc				if DEBUG_FORTH_STACK_GUARD 
1ccc			;		DMARK "RPP" 
1ccc cd c8 62				call check_stacks 
1ccf					FORTH_CHK_RSP_UNDER 
1ccf e5				push hl 
1cd0 d5				push de 
1cd1 2a 0e f8			ld hl,(cli_ret_sp) 
1cd4 11 88 f7			ld de, cli_ret_stack 
1cd7 cd 3e 0d			call cmp16 
1cda da dc 63			jp c, fault_rsp_under 
1cdd d1				pop de 
1cde e1				pop hl 
1cdf				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cdf				endif 
1cdf e5				push hl 
1ce0 2a 0e f8			ld hl,(cli_ret_sp) 
1ce3			 
1ce3			 
1ce3				if FORTH_ENABLE_FREE 
1ce3			 
1ce3					; get pointer 
1ce3			 
1ce3					push de 
1ce3					push hl 
1ce3			 
1ce3					ld e, (hl) 
1ce3					inc hl 
1ce3					ld d, (hl) 
1ce3			 
1ce3					ex de, hl 
1ce3					call free 
1ce3			 
1ce3					pop hl 
1ce3					pop de 
1ce3			 
1ce3			 
1ce3				endif 
1ce3			 
1ce3			 
1ce3 2b				dec hl 
1ce4 2b				dec hl 
1ce5 22 0e f8			ld (cli_ret_sp), hl 
1ce8				; do stack underflow checks 
1ce8 e1				pop hl 
1ce9				if DEBUG_FORTH_STACK_GUARD 
1ce9 cd c8 62				call check_stacks 
1cec					FORTH_CHK_RSP_UNDER 
1cec e5				push hl 
1ced d5				push de 
1cee 2a 0e f8			ld hl,(cli_ret_sp) 
1cf1 11 88 f7			ld de, cli_ret_stack 
1cf4 cd 3e 0d			call cmp16 
1cf7 da dc 63			jp c, fault_rsp_under 
1cfa d1				pop de 
1cfb e1				pop hl 
1cfc				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cfc				endif 
1cfc c9				ret 
1cfd			 
1cfd			 
1cfd			 
1cfd			; routine to load word pointed to by hl into hl 
1cfd			 
1cfd			loadhlptrtohl: 
1cfd			 
1cfd d5				push de 
1cfe 5e				ld e, (hl) 
1cff 23				inc hl 
1d00 56				ld d, (hl) 
1d01 eb				ex de, hl 
1d02 d1				pop de 
1d03			 
1d03 c9				ret 
1d04			 
1d04			 
1d04			 
1d04			 
1d04			 
1d04			; push a number held in HL onto the data stack 
1d04			; entry point for pushing a value when already in hl used in function above 
1d04			 
1d04			forth_push_numhl: 
1d04			 
1d04 e5				push hl    ; save value to push 
1d05			 
1d05			if DEBUG_FORTH_PUSH 
1d05				; see if disabled 
1d05			 
1d05			 
1d05 f5				push af 
1d06 3a 0e ee			ld a, (os_view_disable) 
1d09 fe 2a			cp '*' 
1d0b 28 34			jr z, .pskip2 
1d0d e5				push hl 
1d0e e5			push hl 
1d0f cd ec 0a			call clear_display 
1d12 e1			pop hl 
1d13 7c				ld a,h 
1d14 21 22 f1			ld hl, os_word_scratch 
1d17 cd 21 10			call hexout 
1d1a e1				pop hl 
1d1b 7d				ld a,l 
1d1c 21 24 f1			ld hl, os_word_scratch+2 
1d1f cd 21 10			call hexout 
1d22			 
1d22 21 26 f1			ld hl, os_word_scratch+4 
1d25 3e 00			ld a,0 
1d27 77				ld (hl),a 
1d28 11 22 f1			ld de,os_word_scratch 
1d2b 3e 28				ld a, display_row_2 
1d2d cd ff 0a				call str_at_display 
1d30 11 d6 51			ld de, .push_num 
1d33 3e 00			ld a, display_row_1 
1d35			 
1d35 cd ff 0a				call str_at_display 
1d38			 
1d38			 
1d38 cd 0f 0b			call update_display 
1d3b cd 69 0a			call delay1s 
1d3e cd 69 0a			call delay1s 
1d41			.pskip2:  
1d41			 
1d41 f1				pop af 
1d42			endif	 
1d42			 
1d42			 
1d42				FORTH_DSP_NEXT 
1d42 cd 93 1c			call macro_forth_dsp_next 
1d45				endm 
# End of macro FORTH_DSP_NEXT
1d45			 
1d45 2a 0a f8			ld hl, (cli_data_sp) 
1d48			 
1d48				; save item type 
1d48 3e 02			ld a,  DS_TYPE_INUM 
1d4a 77				ld (hl), a 
1d4b 23				inc hl 
1d4c			 
1d4c				; get word off stack 
1d4c d1				pop de 
1d4d 7b				ld a,e 
1d4e 77				ld (hl), a 
1d4f 23				inc hl 
1d50 7a				ld a,d 
1d51 77				ld (hl), a 
1d52			 
1d52			if DEBUG_FORTH_PUSH 
1d52 2b				dec hl 
1d53 2b				dec hl 
1d54 2b				dec hl 
1d55						DMARK "PH5" 
1d55 f5				push af  
1d56 3a 6a 1d			ld a, (.dmark)  
1d59 32 77 fb			ld (debug_mark),a  
1d5c 3a 6b 1d			ld a, (.dmark+1)  
1d5f 32 78 fb			ld (debug_mark+1),a  
1d62 3a 6c 1d			ld a, (.dmark+2)  
1d65 32 79 fb			ld (debug_mark+2),a  
1d68 18 03			jr .pastdmark  
1d6a ..			.dmark: db "PH5"  
1d6d f1			.pastdmark: pop af  
1d6e			endm  
# End of macro DMARK
1d6e				CALLMONITOR 
1d6e cd 74 17			call break_point_state  
1d71				endm  
# End of macro CALLMONITOR
1d71			endif	 
1d71			 
1d71 c9				ret 
1d72			 
1d72			 
1d72			; Push a string to stack pointed to by hl 
1d72			 
1d72			forth_push_str: 
1d72			 
1d72			if DEBUG_FORTH_PUSH 
1d72						DMARK "PSQ" 
1d72 f5				push af  
1d73 3a 87 1d			ld a, (.dmark)  
1d76 32 77 fb			ld (debug_mark),a  
1d79 3a 88 1d			ld a, (.dmark+1)  
1d7c 32 78 fb			ld (debug_mark+1),a  
1d7f 3a 89 1d			ld a, (.dmark+2)  
1d82 32 79 fb			ld (debug_mark+2),a  
1d85 18 03			jr .pastdmark  
1d87 ..			.dmark: db "PSQ"  
1d8a f1			.pastdmark: pop af  
1d8b			endm  
# End of macro DMARK
1d8b				CALLMONITOR 
1d8b cd 74 17			call break_point_state  
1d8e				endm  
# End of macro CALLMONITOR
1d8e			endif	 
1d8e			    
1d8e e5				push hl 
1d8f e5				push hl 
1d90			 
1d90			;	ld a, 0   ; find end of string 
1d90 cd 7e 11			call strlenz 
1d93			if DEBUG_FORTH_PUSH 
1d93						DMARK "PQ2" 
1d93 f5				push af  
1d94 3a a8 1d			ld a, (.dmark)  
1d97 32 77 fb			ld (debug_mark),a  
1d9a 3a a9 1d			ld a, (.dmark+1)  
1d9d 32 78 fb			ld (debug_mark+1),a  
1da0 3a aa 1d			ld a, (.dmark+2)  
1da3 32 79 fb			ld (debug_mark+2),a  
1da6 18 03			jr .pastdmark  
1da8 ..			.dmark: db "PQ2"  
1dab f1			.pastdmark: pop af  
1dac			endm  
# End of macro DMARK
1dac				CALLMONITOR 
1dac cd 74 17			call break_point_state  
1daf				endm  
# End of macro CALLMONITOR
1daf			endif	 
1daf eb				ex de, hl 
1db0 e1				pop hl   ; get ptr to start of string 
1db1			if DEBUG_FORTH_PUSH 
1db1						DMARK "PQ3" 
1db1 f5				push af  
1db2 3a c6 1d			ld a, (.dmark)  
1db5 32 77 fb			ld (debug_mark),a  
1db8 3a c7 1d			ld a, (.dmark+1)  
1dbb 32 78 fb			ld (debug_mark+1),a  
1dbe 3a c8 1d			ld a, (.dmark+2)  
1dc1 32 79 fb			ld (debug_mark+2),a  
1dc4 18 03			jr .pastdmark  
1dc6 ..			.dmark: db "PQ3"  
1dc9 f1			.pastdmark: pop af  
1dca			endm  
# End of macro DMARK
1dca				CALLMONITOR 
1dca cd 74 17			call break_point_state  
1dcd				endm  
# End of macro CALLMONITOR
1dcd			endif	 
1dcd 19				add hl,de 
1dce			if DEBUG_FORTH_PUSH 
1dce						DMARK "PQE" 
1dce f5				push af  
1dcf 3a e3 1d			ld a, (.dmark)  
1dd2 32 77 fb			ld (debug_mark),a  
1dd5 3a e4 1d			ld a, (.dmark+1)  
1dd8 32 78 fb			ld (debug_mark+1),a  
1ddb 3a e5 1d			ld a, (.dmark+2)  
1dde 32 79 fb			ld (debug_mark+2),a  
1de1 18 03			jr .pastdmark  
1de3 ..			.dmark: db "PQE"  
1de6 f1			.pastdmark: pop af  
1de7			endm  
# End of macro DMARK
1de7				CALLMONITOR 
1de7 cd 74 17			call break_point_state  
1dea				endm  
# End of macro CALLMONITOR
1dea			endif	 
1dea			 
1dea 2b				dec hl    ; see if there is an optional trailing double quote 
1deb 7e				ld a,(hl) 
1dec fe 22			cp '"' 
1dee 20 03			jr nz, .strnoq 
1df0 3e 00			ld a, 0      ; get rid of double quote 
1df2 77				ld (hl), a 
1df3 23			.strnoq: inc hl 
1df4			 
1df4 3e 00			ld a, 0 
1df6 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1df7			 
1df7 13				inc de ; add one for the type string 
1df8 13				inc de ; add one for null term??? 
1df9			 
1df9				; tos is get string pointer again 
1df9				; de contains space to allocate 
1df9				 
1df9 d5				push de 
1dfa			 
1dfa eb				ex de, hl 
1dfb			 
1dfb				;push af 
1dfb			 
1dfb			if DEBUG_FORTH_PUSH 
1dfb						DMARK "PHm" 
1dfb f5				push af  
1dfc 3a 10 1e			ld a, (.dmark)  
1dff 32 77 fb			ld (debug_mark),a  
1e02 3a 11 1e			ld a, (.dmark+1)  
1e05 32 78 fb			ld (debug_mark+1),a  
1e08 3a 12 1e			ld a, (.dmark+2)  
1e0b 32 79 fb			ld (debug_mark+2),a  
1e0e 18 03			jr .pastdmark  
1e10 ..			.dmark: db "PHm"  
1e13 f1			.pastdmark: pop af  
1e14			endm  
# End of macro DMARK
1e14				CALLMONITOR 
1e14 cd 74 17			call break_point_state  
1e17				endm  
# End of macro CALLMONITOR
1e17			endif	 
1e17 cd e7 11			call malloc	; on ret hl now contains allocated memory 
1e1a				if DEBUG_FORTH_MALLOC_GUARD 
1e1a cc 2e 52				call z,malloc_error 
1e1d				endif 
1e1d			 
1e1d				 
1e1d c1				pop bc    ; get length 
1e1e d1				pop de   ;  get string start    
1e1f			 
1e1f				; hl has destination from malloc 
1e1f			 
1e1f eb				ex de, hl    ; prep for ldir 
1e20			 
1e20 d5				push de   ; save malloc area for DSP later 
1e21				;push hl   ; save malloc area for DSP later 
1e21			 
1e21			if DEBUG_FORTH_PUSH 
1e21						DMARK "PHc" 
1e21 f5				push af  
1e22 3a 36 1e			ld a, (.dmark)  
1e25 32 77 fb			ld (debug_mark),a  
1e28 3a 37 1e			ld a, (.dmark+1)  
1e2b 32 78 fb			ld (debug_mark+1),a  
1e2e 3a 38 1e			ld a, (.dmark+2)  
1e31 32 79 fb			ld (debug_mark+2),a  
1e34 18 03			jr .pastdmark  
1e36 ..			.dmark: db "PHc"  
1e39 f1			.pastdmark: pop af  
1e3a			endm  
# End of macro DMARK
1e3a				CALLMONITOR 
1e3a cd 74 17			call break_point_state  
1e3d				endm  
# End of macro CALLMONITOR
1e3d			endif	 
1e3d			 
1e3d			 
1e3d ed b0			ldir 
1e3f			 
1e3f			 
1e3f				; push malloc to data stack     macro?????  
1e3f			 
1e3f				FORTH_DSP_NEXT 
1e3f cd 93 1c			call macro_forth_dsp_next 
1e42				endm 
# End of macro FORTH_DSP_NEXT
1e42			 
1e42				; save value and type 
1e42			 
1e42 2a 0a f8			ld hl, (cli_data_sp) 
1e45			 
1e45				; save item type 
1e45 3e 01			ld a,  DS_TYPE_STR 
1e47 77				ld (hl), a 
1e48 23				inc hl 
1e49			 
1e49				; get malloc word off stack 
1e49 d1				pop de 
1e4a 73				ld (hl), e 
1e4b 23				inc hl 
1e4c 72				ld (hl), d 
1e4d			 
1e4d			 
1e4d			 
1e4d			if DEBUG_FORTH_PUSH 
1e4d 2a 0a f8			ld hl, (cli_data_sp) 
1e50						DMARK "PHS" 
1e50 f5				push af  
1e51 3a 65 1e			ld a, (.dmark)  
1e54 32 77 fb			ld (debug_mark),a  
1e57 3a 66 1e			ld a, (.dmark+1)  
1e5a 32 78 fb			ld (debug_mark+1),a  
1e5d 3a 67 1e			ld a, (.dmark+2)  
1e60 32 79 fb			ld (debug_mark+2),a  
1e63 18 03			jr .pastdmark  
1e65 ..			.dmark: db "PHS"  
1e68 f1			.pastdmark: pop af  
1e69			endm  
# End of macro DMARK
1e69				CALLMONITOR 
1e69 cd 74 17			call break_point_state  
1e6c				endm  
# End of macro CALLMONITOR
1e6c			;	ex de,hl 
1e6c			endif	 
1e6c				; in case of spaces, skip the ptr past the copied string 
1e6c				;pop af 
1e6c				;ld (cli_origptr),hl 
1e6c			 
1e6c c9				ret 
1e6d			 
1e6d			 
1e6d			 
1e6d			; TODO ascii push input onto stack given hl to start of input 
1e6d			 
1e6d			; identify type 
1e6d			; if starts with a " then a string 
1e6d			; otherwise it is a number 
1e6d			;  
1e6d			; if a string 
1e6d			;     scan for ending " to get length of string to malloc for + 1 
1e6d			;     malloc 
1e6d			;     put pointer to string on stack first byte flags as string 
1e6d			; 
1e6d			; else a number 
1e6d			;    look for number format identifier 
1e6d			;    $xx hex 
1e6d			;    %xxxxx bin 
1e6d			;    xxxxx decimal 
1e6d			;    convert number to 16bit word.  
1e6d			;    malloc word + 1 with flag to identiy as num 
1e6d			;    put pointer to number on stack 
1e6d			;   
1e6d			;  
1e6d			  
1e6d			forth_apush: 
1e6d				; kernel push 
1e6d			 
1e6d			if DEBUG_FORTH_PUSH 
1e6d						DMARK "PSH" 
1e6d f5				push af  
1e6e 3a 82 1e			ld a, (.dmark)  
1e71 32 77 fb			ld (debug_mark),a  
1e74 3a 83 1e			ld a, (.dmark+1)  
1e77 32 78 fb			ld (debug_mark+1),a  
1e7a 3a 84 1e			ld a, (.dmark+2)  
1e7d 32 79 fb			ld (debug_mark+2),a  
1e80 18 03			jr .pastdmark  
1e82 ..			.dmark: db "PSH"  
1e85 f1			.pastdmark: pop af  
1e86			endm  
# End of macro DMARK
1e86				CALLMONITOR 
1e86 cd 74 17			call break_point_state  
1e89				endm  
# End of macro CALLMONITOR
1e89			endif	 
1e89				; identify input type 
1e89			 
1e89 7e				ld a,(hl) 
1e8a fe 22			cp '"' 
1e8c 28 0a			jr z, .fapstr 
1e8e fe 24			cp '$' 
1e90 ca b8 1e			jp z, .faphex 
1e93 fe 25			cp '%' 
1e95 ca a0 1e			jp z, .fapbin 
1e98			;	cp 'b' 
1e98			;	jp z, .fabin 
1e98				; else decimal 
1e98			 
1e98				; TODO do decimal conversion 
1e98				; decimal is stored as a 16bit word 
1e98			 
1e98				; by default everything is a string if type is not detected 
1e98			.fapstr: ; 
1e98 fe 22			cp '"' 
1e9a 20 01			jr nz, .strnoqu 
1e9c 23				inc hl 
1e9d			.strnoqu: 
1e9d c3 72 1d			jp forth_push_str 
1ea0			 
1ea0			 
1ea0			 
1ea0			.fapbin:    ; push a binary string.  
1ea0 11 00 00			ld de, 0   ; hold a 16bit value 
1ea3			 
1ea3 23			.fapbinshift:	inc hl  
1ea4 7e				ld a,(hl) 
1ea5 fe 00			cp 0     ; done scanning  
1ea7 28 0b			jr z, .fapbdone  	; got it in HL so push  
1ea9			 
1ea9				; left shift de 
1ea9 eb				ex de, hl	 
1eaa 29				add hl, hl 
1eab			 
1eab				; is 1 
1eab fe 31			cp '1' 
1ead 20 02			jr nz, .binzero 
1eaf cb 4d			bit 1, l 
1eb1			.binzero: 
1eb1 eb				ex de, hl	 ; save current de 
1eb2 18 ef			jr .fapbinshift 
1eb4			 
1eb4			.fapbdone: 
1eb4 eb				ex de, hl 
1eb5 c3 04 1d			jp forth_push_numhl 
1eb8			 
1eb8			 
1eb8			.faphex:   ; hex is always stored as a 16bit word 
1eb8				; skip number prefix 
1eb8 23				inc hl 
1eb9				; turn ascii into number 
1eb9 cd d7 10			call get_word_hl	; ret 16bit word in hl 
1ebc			 
1ebc c3 04 1d			jp forth_push_numhl 
1ebf			 
1ebf 00				 nop 
1ec0			 
1ec0			.fabin:   ; TODO bin conversion 
1ec0			 
1ec0			 
1ec0 c9				ret 
1ec1			 
1ec1			 
1ec1			; get either a string ptr or a 16bit word from the data stack 
1ec1			 
1ec1			FORTH_DSP: macro 
1ec1				call macro_forth_dsp 
1ec1				endm 
1ec1			 
1ec1			macro_forth_dsp: 
1ec1				; data stack pointer points to current word on tos 
1ec1			 
1ec1 2a 0a f8			ld hl,(cli_data_sp) 
1ec4			 
1ec4				if DEBUG_FORTH_PUSH 
1ec4						DMARK "DSP" 
1ec4 f5				push af  
1ec5 3a d9 1e			ld a, (.dmark)  
1ec8 32 77 fb			ld (debug_mark),a  
1ecb 3a da 1e			ld a, (.dmark+1)  
1ece 32 78 fb			ld (debug_mark+1),a  
1ed1 3a db 1e			ld a, (.dmark+2)  
1ed4 32 79 fb			ld (debug_mark+2),a  
1ed7 18 03			jr .pastdmark  
1ed9 ..			.dmark: db "DSP"  
1edc f1			.pastdmark: pop af  
1edd			endm  
# End of macro DMARK
1edd			 
1edd cd 63 52				call display_data_sp 
1ee0				;call break_point_state 
1ee0				;rst 030h 
1ee0				CALLMONITOR 
1ee0 cd 74 17			call break_point_state  
1ee3				endm  
# End of macro CALLMONITOR
1ee3				endif 
1ee3			 
1ee3 c9				ret 
1ee4			 
1ee4			; return hl to start of value on stack 
1ee4			 
1ee4			FORTH_DSP_VALUE: macro 
1ee4				call macro_forth_dsp_value 
1ee4				endm 
1ee4			 
1ee4			macro_forth_dsp_value: 
1ee4			 
1ee4				FORTH_DSP 
1ee4 cd c1 1e			call macro_forth_dsp 
1ee7				endm 
# End of macro FORTH_DSP
1ee7			 
1ee7 d5				push de 
1ee8			 
1ee8 23				inc hl ; skip type 
1ee9			 
1ee9 5e				ld e, (hl) 
1eea 23				inc hl 
1eeb 56				ld d, (hl) 
1eec eb				ex de,hl  
1eed			 
1eed d1				pop de 
1eee			 
1eee c9				ret 
1eef			 
1eef			; return hl to start of value to second item on stack 
1eef			 
1eef			FORTH_DSP_VALUEM1: macro 
1eef				call macro_forth_dsp_value_m1 
1eef				endm 
1eef			 
1eef			macro_forth_dsp_value_m1: 
1eef			 
1eef				FORTH_DSP 
1eef cd c1 1e			call macro_forth_dsp 
1ef2				endm 
# End of macro FORTH_DSP
1ef2			 
1ef2 2b				dec hl 
1ef3 2b				dec hl 
1ef4			;	dec hl 
1ef4			 
1ef4 d5				push de 
1ef5			 
1ef5 5e				ld e, (hl) 
1ef6 23				inc hl 
1ef7 56				ld d, (hl) 
1ef8 eb				ex de,hl  
1ef9			 
1ef9 d1				pop de 
1efa			 
1efa c9				ret 
1efb			 
1efb				 
1efb			 
1efb			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1efb			 
1efb			FORTH_DSP_POP: macro 
1efb				call macro_forth_dsp_pop 
1efb				endm 
1efb			 
1efb			 
1efb			; get the tos data type 
1efb			 
1efb			FORTH_DSP_TYPE:   macro 
1efb			 
1efb				;FORTH_DSP_VALUE 
1efb				FORTH_DSP 
1efb				 
1efb				; hl points to value 
1efb				; check type 
1efb			 
1efb				ld a,(hl) 
1efb			 
1efb				endm 
1efb			 
1efb			; load the tos value into hl 
1efb			 
1efb			 
1efb			FORTH_DSP_VALUEHL:  macro 
1efb				call macro_dsp_valuehl 
1efb				endm 
1efb			 
1efb			 
1efb			 
1efb			macro_dsp_valuehl: 
1efb				FORTH_DSP_VALUE 
1efb cd e4 1e			call macro_forth_dsp_value 
1efe				endm 
# End of macro FORTH_DSP_VALUE
1efe			 
1efe				;FORTH_ERR_TOS_NOTNUM 
1efe			 
1efe				;inc hl   ; skip type id 
1efe			 
1efe			;	push de 
1efe			; 
1efe			;	ld e, (hl) 
1efe			;	inc hl 
1efe			;	ld d, (hl) 
1efe			;	ex de,hl  
1efe			 
1efe			;	pop de 
1efe			 
1efe				if DEBUG_FORTH_PUSH 
1efe						DMARK "DVL" 
1efe f5				push af  
1eff 3a 13 1f			ld a, (.dmark)  
1f02 32 77 fb			ld (debug_mark),a  
1f05 3a 14 1f			ld a, (.dmark+1)  
1f08 32 78 fb			ld (debug_mark+1),a  
1f0b 3a 15 1f			ld a, (.dmark+2)  
1f0e 32 79 fb			ld (debug_mark+2),a  
1f11 18 03			jr .pastdmark  
1f13 ..			.dmark: db "DVL"  
1f16 f1			.pastdmark: pop af  
1f17			endm  
# End of macro DMARK
1f17				CALLMONITOR 
1f17 cd 74 17			call break_point_state  
1f1a				endm  
# End of macro CALLMONITOR
1f1a				endif 
1f1a c9				ret 
1f1b			 
1f1b			forth_apushstrhl:      
1f1b				; push of string requires use of cli_origptr 
1f1b				; bodge use 
1f1b			 
1f1b				; get current cli_origptr, save, update with temp pointer  
1f1b ed 5b 26 f8		ld de, (cli_origptr) 
1f1f 22 26 f8			ld (cli_origptr), hl 
1f22 d5				push de 
1f23 cd 6d 1e			call forth_apush 
1f26 d1				pop de 
1f27 ed 53 26 f8		ld (cli_origptr), de 
1f2b c9			        ret	 
1f2c			 
1f2c			 
1f2c			; increase loop stack pointer and save hl to it 
1f2c				 
1f2c			FORTH_LOOP_NEXT: macro 
1f2c				call macro_forth_loop_next 
1f2c				;nop 
1f2c				endm 
1f2c			 
1f2c			macro_forth_loop_next: 
1f2c				if DEBUG_FORTH_STACK_GUARD 
1f2c cd c8 62				call check_stacks 
1f2f				endif 
1f2f e5				push hl 
1f30 d5				push de 
1f31 eb				ex de,hl 
1f32 2a 0c f8			ld hl,(cli_loop_sp) 
1f35 23				inc hl 
1f36 23				inc hl 
1f37					if DEBUG_FORTH_WORDS 
1f37						DMARK "LNX" 
1f37 f5				push af  
1f38 3a 4c 1f			ld a, (.dmark)  
1f3b 32 77 fb			ld (debug_mark),a  
1f3e 3a 4d 1f			ld a, (.dmark+1)  
1f41 32 78 fb			ld (debug_mark+1),a  
1f44 3a 4e 1f			ld a, (.dmark+2)  
1f47 32 79 fb			ld (debug_mark+2),a  
1f4a 18 03			jr .pastdmark  
1f4c ..			.dmark: db "LNX"  
1f4f f1			.pastdmark: pop af  
1f50			endm  
# End of macro DMARK
1f50						CALLMONITOR 
1f50 cd 74 17			call break_point_state  
1f53				endm  
# End of macro CALLMONITOR
1f53					endif 
1f53 22 0c f8			ld (cli_loop_sp),hl 
1f56 73				ld (hl), e 
1f57 23				inc hl 
1f58 72				ld (hl), d 
1f59 d1				pop de    ; been reversed so save a swap on restore 
1f5a e1				pop hl 
1f5b				if DEBUG_FORTH_STACK_GUARD 
1f5b cd c8 62				call check_stacks 
1f5e				endif 
1f5e c9				ret 
1f5f			 
1f5f			; get current ret stack pointer and save to hl  
1f5f				 
1f5f			FORTH_LOOP_TOS: macro 
1f5f				call macro_forth_loop_tos 
1f5f				endm 
1f5f			 
1f5f			macro_forth_loop_tos: 
1f5f d5				push de 
1f60 2a 0c f8			ld hl,(cli_loop_sp) 
1f63 5e				ld e, (hl) 
1f64 23				inc hl 
1f65 56				ld d, (hl) 
1f66 eb				ex de, hl 
1f67 d1				pop de 
1f68 c9				ret 
1f69			 
1f69			; pop loop stack pointer 
1f69				 
1f69			FORTH_LOOP_POP: macro 
1f69				call macro_forth_loop_pop 
1f69				endm 
1f69			 
1f69			 
1f69			macro_forth_loop_pop: 
1f69				if DEBUG_FORTH_STACK_GUARD 
1f69					DMARK "LPP" 
1f69 f5				push af  
1f6a 3a 7e 1f			ld a, (.dmark)  
1f6d 32 77 fb			ld (debug_mark),a  
1f70 3a 7f 1f			ld a, (.dmark+1)  
1f73 32 78 fb			ld (debug_mark+1),a  
1f76 3a 80 1f			ld a, (.dmark+2)  
1f79 32 79 fb			ld (debug_mark+2),a  
1f7c 18 03			jr .pastdmark  
1f7e ..			.dmark: db "LPP"  
1f81 f1			.pastdmark: pop af  
1f82			endm  
# End of macro DMARK
1f82 cd c8 62				call check_stacks 
1f85					FORTH_CHK_LOOP_UNDER 
1f85 e5				push hl 
1f86 d5				push de 
1f87 2a 0c f8			ld hl,(cli_loop_sp) 
1f8a 11 86 f5			ld de, cli_loop_stack 
1f8d cd 3e 0d			call cmp16 
1f90 da e2 63			jp c, fault_loop_under 
1f93 d1				pop de 
1f94 e1				pop hl 
1f95				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f95				endif 
1f95 e5				push hl 
1f96 2a 0c f8			ld hl,(cli_loop_sp) 
1f99 2b				dec hl 
1f9a 2b				dec hl 
1f9b 22 0c f8			ld (cli_loop_sp), hl 
1f9e				; TODO do stack underflow checks 
1f9e e1				pop hl 
1f9f				if DEBUG_FORTH_STACK_GUARD 
1f9f cd c8 62				call check_stacks 
1fa2					FORTH_CHK_LOOP_UNDER 
1fa2 e5				push hl 
1fa3 d5				push de 
1fa4 2a 0c f8			ld hl,(cli_loop_sp) 
1fa7 11 86 f5			ld de, cli_loop_stack 
1faa cd 3e 0d			call cmp16 
1fad da e2 63			jp c, fault_loop_under 
1fb0 d1				pop de 
1fb1 e1				pop hl 
1fb2				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1fb2				endif 
1fb2 c9				ret 
1fb3			 
1fb3			macro_forth_dsp_pop: 
1fb3			 
1fb3 e5				push hl 
1fb4			 
1fb4				; release malloc data 
1fb4			 
1fb4				if DEBUG_FORTH_STACK_GUARD 
1fb4 cd c8 62				call check_stacks 
1fb7					FORTH_CHK_DSP_UNDER 
1fb7 e5				push hl 
1fb8 d5				push de 
1fb9 2a 0a f8			ld hl,(cli_data_sp) 
1fbc 11 84 f3			ld de, cli_data_stack 
1fbf cd 3e 0d			call cmp16 
1fc2 da d6 63			jp c, fault_dsp_under 
1fc5 d1				pop de 
1fc6 e1				pop hl 
1fc7				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fc7				endif 
1fc7				;ld hl,(cli_data_sp) 
1fc7			if DEBUG_FORTH_DOT 
1fc7				DMARK "DPP" 
1fc7				CALLMONITOR 
1fc7			endif	 
1fc7			 
1fc7			 
1fc7			if FORTH_ENABLE_DSPPOPFREE 
1fc7			 
1fc7				FORTH_DSP 
1fc7 cd c1 1e			call macro_forth_dsp 
1fca				endm 
# End of macro FORTH_DSP
1fca			 
1fca 7e				ld a, (hl) 
1fcb fe 01			cp DS_TYPE_STR 
1fcd 20 07			jr nz, .skippopfree 
1fcf			 
1fcf				FORTH_DSP_VALUEHL 
1fcf cd fb 1e			call macro_dsp_valuehl 
1fd2				endm 
# End of macro FORTH_DSP_VALUEHL
1fd2 00				nop 
1fd3			if DEBUG_FORTH_DOT 
1fd3				DMARK "DPf" 
1fd3				CALLMONITOR 
1fd3			endif	 
1fd3 cd b1 12			call free 
1fd6			.skippopfree: 
1fd6				 
1fd6			 
1fd6			endif 
1fd6			 
1fd6			if DEBUG_FORTH_DOT_KEY 
1fd6				DMARK "DP2" 
1fd6				CALLMONITOR 
1fd6			endif	 
1fd6			 
1fd6				; move pointer down 
1fd6			 
1fd6 2a 0a f8			ld hl,(cli_data_sp) 
1fd9 2b				dec hl 
1fda 2b				dec hl 
1fdb			; PARSEV5 
1fdb 2b				dec hl 
1fdc 22 0a f8			ld (cli_data_sp), hl 
1fdf			 
1fdf				if DEBUG_FORTH_STACK_GUARD 
1fdf cd c8 62				call check_stacks 
1fe2					FORTH_CHK_DSP_UNDER 
1fe2 e5				push hl 
1fe3 d5				push de 
1fe4 2a 0a f8			ld hl,(cli_data_sp) 
1fe7 11 84 f3			ld de, cli_data_stack 
1fea cd 3e 0d			call cmp16 
1fed da d6 63			jp c, fault_dsp_under 
1ff0 d1				pop de 
1ff1 e1				pop hl 
1ff2				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ff2				endif 
1ff2			 
1ff2 e1				pop hl 
1ff3			 
1ff3 c9				ret 
1ff4			 
1ff4			getwordathl: 
1ff4				; hl points to an address 
1ff4				; load hl with the word at that address 
1ff4			 
1ff4 d5				push de 
1ff5			 
1ff5 5e				ld e, (hl) 
1ff6 23				inc hl 
1ff7 56				ld d, (hl) 
1ff8 eb				ex de, hl 
1ff9			 
1ff9 d1				pop de 
1ffa c9				ret 
1ffb			 
1ffb			 
1ffb			 
1ffb			 
1ffb			 
1ffb			; eof 
1ffb			 
# End of file forth_stackopsv5.asm
1ffb			endif 
1ffb			 
1ffb			user_word_eol:  
1ffb				; hl contains the pointer to where to create a linked list item from the end 
1ffb				; of the user dict to continue on at the system word dict 
1ffb				 
1ffb				; poke the stub of the word list linked list to repoint to rom words 
1ffb			 
1ffb				; stub format 
1ffb				; db   word id 
1ffb				; dw    link to next word 
1ffb			        ; db char length of token 
1ffb				; db string + 0 term 
1ffb				; db exec code....  
1ffb			 
1ffb 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1ffd 77				ld (hl), a		; word id 
1ffe 23				inc hl 
1fff			 
1fff 11 c5 21			ld de, sysdict 
2002 73				ld (hl), e		; next word link ie system dict 
2003 23				inc hl 
2004 72				ld (hl), d		; next word link ie system dict 
2005 23				inc hl	 
2006			 
2006			;	ld (hl), sysdict		; next word link ie system dict 
2006			;	inc hl 
2006			;	inc hl 
2006			 
2006			;	inc hl 
2006			;	inc hl 
2006			 
2006 3e 02			ld a, 2			; word length is 0 
2008 77				ld (hl), a	 
2009 23				inc hl 
200a			 
200a 3e 7e			ld a, '~'			; word length is 0 
200c 77				ld (hl), a	 
200d 23				inc hl 
200e 3e 00			ld a, 0			; save empty word 
2010 77				ld (hl), a 
2011			 
2011 c9				ret 
2012			 
2012				 
2012			 
2012			forthexec_cleanup: 
2012				FORTH_RSP_POP 
2012 cd cc 1c			call macro_forth_rsp_pop 
2015				endm 
# End of macro FORTH_RSP_POP
2015 c9				ret 
2016			 
2016			forth_call_hl: 
2016				; taking hl 
2016 e5				push hl 
2017 c9				ret 
2018			 
2018			; this is called to reset Forth system but keep existing uwords etc 
2018			 
2018			forth_warmstart: 
2018				; setup stack over/under flow checks 
2018				if DEBUG_FORTH_STACK_GUARD 
2018 cd ae 62				call chk_stk_init 
201b				endif 
201b			 
201b				; init stack pointers  - * these stacks go upwards *  
201b 21 88 f7			ld hl, cli_ret_stack 
201e 22 0e f8			ld (cli_ret_sp), hl	 
2021				; set bottom of stack 
2021 3e 00			ld a,0 
2023 77				ld (hl),a 
2024 23				inc hl 
2025 77				ld (hl),a 
2026			 
2026 21 84 f3			ld hl, cli_data_stack 
2029 22 0a f8			ld (cli_data_sp), hl	 
202c				; set bottom of stack 
202c 3e 00			ld a,0 
202e 77				ld (hl),a 
202f 23				inc hl 
2030 77				ld (hl),a 
2031			 
2031 21 86 f5			ld hl, cli_loop_stack 
2034 22 0c f8			ld (cli_loop_sp), hl	 
2037				; set bottom of stack 
2037 3e 00			ld a,0 
2039 77				ld (hl),a 
203a 23				inc hl 
203b 77				ld (hl),a 
203c			 
203c				; init extent of current open file 
203c			 
203c 3e 00			ld a, 0 
203e 32 59 f8			ld (store_openext), a 
2041			 
2041 c9				ret 
2042			 
2042			 
2042			; Cold Start - this is called to setup the whole Forth system 
2042			 
2042			forth_init: 
2042			 
2042				; setup stack over/under flow checks 
2042			 
2042			;	if DEBUG_FORTH_STACK_GUARD 
2042			;		call chk_stk_init 
2042			;	endif 
2042			 
2042				; enable auto display updates (slow.....) 
2042			 
2042 3e 01			ld a, 1 
2044 32 24 f8			ld (cli_autodisplay), a 
2047			 
2047			 
2047			 
2047				; show start up screen 
2047			 
2047 cd ec 0a			call clear_display 
204a			 
204a 3e 00			ld a,0 
204c 32 46 f8			ld (f_cursor_ptr), a 
204f			 
204f				; set start of word list in start of ram - for use when creating user words 
204f			 
204f 21 00 80			ld hl, baseram 
2052 22 1a f1			ld (os_last_new_uword), hl 
2055 cd fb 1f			call user_word_eol 
2058				 
2058			;		call display_data_sp 
2058			;		call next_page_prompt 
2058			 
2058			 
2058			 
2058			 
2058 c9				ret 
2059			 
2059 .. 00		.bootforth: db " Forth Kernel Init ",0 
206d			 
206d			; TODO push to stack 
206d			 
206d			;  
206d			 
206d			if FORTH_PARSEV2 
206d			 
206d			 
206d				include "forth_parserv2.asm" 
206d			 
206d			endif 
206d			 
206d			 
206d			; parse cli version 1 
206d			 
206d			if FORTH_PARSEV1 
206d			 
206d			 
206d			 
206d			      include "forth_parserv1.asm" 
206d			endif 
206d				 
206d			if FORTH_PARSEV3 
206d			 
206d			 
206d			 
206d			      include "forth_parserv3.asm" 
206d				include "forth_wordsv3.asm" 
206d			endif 
206d			 
206d			if FORTH_PARSEV4 
206d			 
206d			 
206d			 
206d			      include "forth_parserv4.asm" 
206d				include "forth_wordsv4.asm" 
206d			endif 
206d			 
206d			if FORTH_PARSEV5 
206d			 
206d			 
206d			 
206d			      include "forth_parserv5.asm" 
206d			 
206d			 
206d			; A better parser without using malloc and string copies all over the place.  
206d			; Exec in situ should be faster 
206d			 
206d			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
206d			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
206d			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
206d			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
206d			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
206d			WORD_SYS_END: equ 0   ; Opcode for all user words 
206d			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
206d			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
206d			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
206d			 
206d			; Core word preamble macro 
206d			 
206d			CWHEAD:   macro nxtword opcode lit len opflags 
206d				db WORD_SYS_CORE+opcode             
206d				; internal op code number 
206d				dw nxtword            
206d				; link to next dict word block 
206d				db len + 1 
206d				; literal length of dict word inc zero term 
206d				db lit,0              
206d				; literal dict word 
206d			        ; TODO db opflags        
206d				endm 
206d			 
206d			 
206d			NEXTW: macro  
206d				jp macro_next 
206d				endm 
206d			 
206d			macro_next: 
206d			if DEBUG_FORTH_PARSE_KEY 
206d				DMARK "NXT" 
206d				CALLMONITOR 
206d			endif	 
206d			;	inc hl  ; skip token null term  
206d ed 4b 28 f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2071 ed 5b 26 f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2075 2a 1e f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2078			if DEBUG_FORTH_PARSE_KEY 
2078				DMARK "}AA" 
2078				CALLMONITOR 
2078			endif	 
2078 c3 7b 21			jp execnext 
207b				;jp exec1 
207b			       
207b			 
207b			 
207b			; Another go at the parser to compile  
207b			 
207b			 
207b			; TODO rework parser to change all of the string words to byte tokens 
207b			; TODO do a search for  
207b			 
207b			; TODO first run normal parser to zero term sections 
207b			; TODO for each word do a token look up to get the op code 
207b			; TODO need some means to flag to the exec that this is a byte code form    
207b			 
207b			 
207b			forthcompile: 
207b			 
207b			; 
207b			; line parse: 
207b			;       parse raw input buffer 
207b			;       tokenise the words 
207b			;       malloc new copy (for looping etc) 
207b			;       copy to malloc + current pc in line to start of string and add line term 
207b			;       save on new rsp 
207b			; 
207b			 
207b			; hl to point to the line to tokenise 
207b			 
207b			;	push hl 
207b 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
207e			 
207e			;	ld a,0		; string term on input 
207e			;	call strlent 
207e			 
207e			;	ld (os_tok_len), hl	 ; save string length 
207e			 
207e			;if DEBUG_FORTH_TOK 
207e			;	ex de,hl		 
207e			;endif 
207e			 
207e			;	pop hl 		; get back string pointer 
207e			 
207e			if DEBUG_FORTH_TOK 
207e						DMARK "TOc" 
207e				CALLMONITOR 
207e			endif 
207e 7e			.cptoken2:    ld a,(hl) 
207f 23				inc hl 
2080 fe 7f			cp FORTH_END_BUFFER 
2082 28 29			jr z, .cptokendone2 
2084 fe 00			cp 0 
2086 28 25			jr z, .cptokendone2 
2088 fe 22			cp '"' 
208a 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
208c fe 20			cp ' ' 
208e 20 ee			jr nz,  .cptoken2 
2090			 
2090			; TODO consume comments held between ( and ) 
2090			 
2090				; we have a space so change to zero term for dict match later 
2090 2b				dec hl 
2091 3e 00			ld a,0 
2093 77				ld (hl), a 
2094 23				inc hl 
2095 18 e7			jr .cptoken2 
2097				 
2097			 
2097			.cptokenstr2: 
2097				; skip all white space until either eol (because forgot to term) or end double quote 
2097			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2097				;inc hl ; skip current double quote 
2097 7e				ld a,(hl) 
2098 23				inc hl 
2099 fe 22			cp '"' 
209b 28 e1			jr z, .cptoken2 
209d fe 7f			cp FORTH_END_BUFFER 
209f 28 0c			jr z, .cptokendone2 
20a1 fe 00			cp 0 
20a3 28 08			jr z, .cptokendone2 
20a5 fe 20			cp ' ' 
20a7 28 02			jr z, .cptmp2 
20a9 18 ec			jr .cptokenstr2 
20ab			 
20ab			.cptmp2:	; we have a space so change to zero term for dict match later 
20ab				;dec hl 
20ab				;ld a,"-"	; TODO remove this when working 
20ab				;ld (hl), a 
20ab				;inc hl 
20ab 18 ea			jr .cptokenstr2 
20ad			 
20ad			.cptokendone2: 
20ad				;inc hl 
20ad 3e 7f			ld a, FORTH_END_BUFFER 
20af 77				ld (hl),a 
20b0 23				inc hl 
20b1 3e 21			ld a, '!' 
20b3 77				ld (hl),a 
20b4			 
20b4 2a 1e f1			ld hl,(os_tok_ptr) 
20b7			         
20b7			if DEBUG_FORTH_TOK 
20b7						DMARK "Tc1" 
20b7				CALLMONITOR 
20b7			endif 
20b7			 
20b7				; push exec string to top of return stack 
20b7				FORTH_RSP_NEXT 
20b7 cd ab 1c			call macro_forth_rsp_next 
20ba				endm 
# End of macro FORTH_RSP_NEXT
20ba c9				ret 
20bb			 
20bb			; Another go at the parser need to simplify the process 
20bb			 
20bb			forthparse: 
20bb			 
20bb			; 
20bb			; line parse: 
20bb			;       parse raw input buffer 
20bb			;       tokenise the words 
20bb			;       malloc new copy (for looping etc) 
20bb			;       copy to malloc + current pc in line to start of string and add line term 
20bb			;       save on new rsp 
20bb			; 
20bb			 
20bb			; hl to point to the line to tokenise 
20bb			 
20bb			;	push hl 
20bb 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
20be			 
20be			;	ld a,0		; string term on input 
20be			;	call strlent 
20be			 
20be			;	ld (os_tok_len), hl	 ; save string length 
20be			 
20be			;if DEBUG_FORTH_TOK 
20be			;	ex de,hl		 
20be			;endif 
20be			 
20be			;	pop hl 		; get back string pointer 
20be			 
20be			if DEBUG_FORTH_TOK 
20be						DMARK "TOK" 
20be				CALLMONITOR 
20be			endif 
20be 7e			.ptoken2:    ld a,(hl) 
20bf 23				inc hl 
20c0 fe 7f			cp FORTH_END_BUFFER 
20c2 28 29			jr z, .ptokendone2 
20c4 fe 00			cp 0 
20c6 28 25			jr z, .ptokendone2 
20c8 fe 22			cp '"' 
20ca 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
20cc fe 20			cp ' ' 
20ce 20 ee			jr nz,  .ptoken2 
20d0			 
20d0			; TODO consume comments held between ( and ) 
20d0			 
20d0				; we have a space so change to zero term for dict match later 
20d0 2b				dec hl 
20d1 3e 00			ld a,0 
20d3 77				ld (hl), a 
20d4 23				inc hl 
20d5 18 e7			jr .ptoken2 
20d7				 
20d7			 
20d7			.ptokenstr2: 
20d7				; skip all white space until either eol (because forgot to term) or end double quote 
20d7			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
20d7				;inc hl ; skip current double quote 
20d7 7e				ld a,(hl) 
20d8 23				inc hl 
20d9 fe 22			cp '"' 
20db 28 e1			jr z, .ptoken2 
20dd fe 7f			cp FORTH_END_BUFFER 
20df 28 0c			jr z, .ptokendone2 
20e1 fe 00			cp 0 
20e3 28 08			jr z, .ptokendone2 
20e5 fe 20			cp ' ' 
20e7 28 02			jr z, .ptmp2 
20e9 18 ec			jr .ptokenstr2 
20eb			 
20eb			.ptmp2:	; we have a space so change to zero term for dict match later 
20eb				;dec hl 
20eb				;ld a,"-"	; TODO remove this when working 
20eb				;ld (hl), a 
20eb				;inc hl 
20eb 18 ea			jr .ptokenstr2 
20ed			 
20ed			.ptokendone2: 
20ed				;inc hl 
20ed 3e 7f			ld a, FORTH_END_BUFFER 
20ef 77				ld (hl),a 
20f0 23				inc hl 
20f1 3e 21			ld a, '!' 
20f3 77				ld (hl),a 
20f4			 
20f4 2a 1e f1			ld hl,(os_tok_ptr) 
20f7			         
20f7			if DEBUG_FORTH_TOK 
20f7						DMARK "TK1" 
20f7				CALLMONITOR 
20f7			endif 
20f7			 
20f7				; push exec string to top of return stack 
20f7				FORTH_RSP_NEXT 
20f7 cd ab 1c			call macro_forth_rsp_next 
20fa				endm 
# End of macro FORTH_RSP_NEXT
20fa c9				ret 
20fb			 
20fb			; 
20fb			;	; malloc size + buffer pointer + if is loop flag 
20fb			;	ld hl,(os_tok_len) 		 ; get string length 
20fb			; 
20fb			;	ld a,l 
20fb			; 
20fb			;	cp 0			; we dont want to use a null string 
20fb			;	ret z 
20fb			; 
20fb			;;	add 3    ; prefix malloc with buffer for current word ptr 
20fb			; 
20fb			;	add 5     ; TODO when certain not over writing memory remove 
20fb			; 
20fb			;		 
20fb			; 
20fb			;if DEBUG_FORTH_TOK 
20fb			;			DMARK "TKE" 
20fb			;	CALLMONITOR 
20fb			;endif 
20fb			; 
20fb			;	ld l,a 
20fb			;	ld h,0 
20fb			;;	push hl   ; save required space for the copy later 
20fb			;	call malloc 
20fb			;if DEBUG_FORTH_TOK 
20fb			;			DMARK "TKM" 
20fb			;	CALLMONITOR 
20fb			;endif 
20fb			;	if DEBUG_FORTH_MALLOC_GUARD 
20fb			;		push af 
20fb			;		call ishlzero 
20fb			;;		ld a, l 
20fb			;;		add h 
20fb			;;		cp 0 
20fb			;		pop af 
20fb			;		 
20fb			;		call z,malloc_error 
20fb			;	endif 
20fb			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20fb			; 
20fb			; 
20fb			;if DEBUG_FORTH_TOK 
20fb			;			DMARK "TKR" 
20fb			;	CALLMONITOR 
20fb			;endif 
20fb			; 
20fb			;	FORTH_RSP_NEXT 
20fb			; 
20fb			;	;inc hl	 ; go past current buffer pointer 
20fb			;	;inc hl 
20fb			;	;inc hl   ; and past if loop flag 
20fb			;		; TODO Need to set flag  
20fb			; 
20fb			;	 
20fb			;	 
20fb			;	ex de,hl	; malloc is dest 
20fb			;	ld hl, (os_tok_len) 
20fb			;;	pop bc 
20fb			;	ld c, l                
20fb			;	ld b,0 
20fb			;	ld hl, (os_tok_ptr) 
20fb			; 
20fb			;if DEBUG_FORTH_TOK 
20fb			;			DMARK "TKT" 
20fb			;	CALLMONITOR 
20fb			;endif 
20fb			; 
20fb			;	; do str cpy 
20fb			; 
20fb			;	ldir      ; copy byte in hl to de 
20fb			; 
20fb			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20fb			; 
20fb			;if DEBUG_FORTH_TOK 
20fb			; 
20fb			;			DMARK "TKY" 
20fb			;	CALLMONITOR 
20fb			;endif 
20fb			;	;ld a,0 
20fb			;	;ld a,FORTH_END_BUFFER 
20fb			;	ex de, hl 
20fb			;	;dec hl			 ; go back over the space delim at the end of word 
20fb			;	;ld (hl),a 
20fb			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20fb			;	ld a,FORTH_END_BUFFER 
20fb			;	ld (hl),a 
20fb			;	inc hl 
20fb			;	ld a,FORTH_END_BUFFER 
20fb			;	ld (hl),a 
20fb			; 
20fb			;	; init the malloc area data 
20fb			;	; set pc for in current area 
20fb			;	;ld hl, (os_tok_malloc) 
20fb			;	;inc hl 
20fb			;	;inc hl 
20fb			;	;inc hl 
20fb			;	;ex de,hl 
20fb			;	;ld hl, (os_tok_malloc) 
20fb			;	;ld (hl),e 
20fb			;	;inc hl 
20fb			;	;ld (hl),d 
20fb			; 
20fb			; 
20fb			;	ld hl,(os_tok_malloc) 
20fb			;if DEBUG_FORTH_PARSE_KEY 
20fb			;			DMARK "TKU" 
20fb			;	CALLMONITOR 
20fb			;endif 
20fb			; 
20fb			;	ret 
20fb			 
20fb			forthexec: 
20fb			 
20fb			; line exec: 
20fb			; forth parser 
20fb			 
20fb			; 
20fb			;       get current exec line on rsp 
20fb			 
20fb				FORTH_RSP_TOS 
20fb cd c2 1c			call macro_forth_rsp_tos 
20fe				endm 
# End of macro FORTH_RSP_TOS
20fe			 
20fe			;       restore current pc - hl points to malloc of data 
20fe			 
20fe				;ld e, (hl) 
20fe				;inc hl 
20fe				;ld d, (hl) 
20fe				;ex de,hl 
20fe			 
20fe			 
20fe			exec1: 
20fe 22 1e f1			ld (os_tok_ptr), hl 
2101			 
2101				; copy our PC to working vars  
2101 22 28 f8			ld (cli_ptr), hl 
2104 22 26 f8			ld (cli_origptr), hl 
2107			 
2107 7e				ld a,(hl) 
2108 fe 7f			cp FORTH_END_BUFFER 
210a c8				ret z 
210b			 
210b				; skip any nulls 
210b			 
210b fe 00			cp 0 
210d 20 03			jr nz, .execword 
210f 23				inc hl 
2110 18 ec			jr exec1 
2112			 
2112			 
2112			.execword: 
2112			 
2112			 
2112			 
2112			if DEBUG_FORTH_PARSE_KEY 
2112						DMARK "KYQ" 
2112				CALLMONITOR 
2112			endif 
2112			;       while at start of word: 
2112			; get start of dict (in user area first) 
2112			 
2112 21 00 80		ld hl, baseram 
2115			;ld hl, sysdict 
2115 22 2a f8		ld (cli_nextword),hl 
2118			;           match word at pc 
2118			;           exec word 
2118			;           or push to dsp 
2118			;           forward to next token 
2118			;           if line term pop rsp and exit 
2118			;        
2118			 
2118			if DEBUG_FORTH_PARSE_KEY 
2118						DMARK "KYq" 
2118				CALLMONITOR 
2118			endif 
2118			 
2118			; 
2118			; word comp 
2118			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2118			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2118			;    move to start of word  
2118			;    compare word to cli_token 
2118			 
2118			.execpnword:	; HL at start of a word in the dictionary to check 
2118			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2118			;	ld (cli_ptr), hl 
2118			 
2118 2a 2a f8			ld hl,(cli_nextword) 
211b			 
211b cd be 21			call forth_tok_next 
211e			; tok next start here 
211e			;	; TODO skip compiled symbol for now 
211e			;	inc hl 
211e			; 
211e			;	; save pointer to next word 
211e			; 
211e			;	; hl now points to the address of the next word pointer  
211e			;	ld e, (hl) 
211e			;	inc hl 
211e			;	ld d, (hl) 
211e			;	inc l 
211e			; 
211e			;	ex de,hl 
211e			;if DEBUG_FORTH_PARSE_NEXTWORD 
211e			;	push bc 
211e			;	ld bc, (cli_nextword) 
211e			;			DMARK "NXW" 
211e			;	CALLMONITOR 
211e			;	pop bc 
211e			;endif 
211e			; tok next end here 
211e 22 2a f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
2121 eb				ex de, hl 
2122			 
2122			 
2122				; save the pointer of the current token - 1 to check against 
2122				 
2122 22 2e f8			ld (cli_token), hl   
2125				; TODO maybe remove below save if no debug 
2125				; save token string ptr for any debug later 
2125 23				inc hl  
2126 22 30 f8			ld (cli_origtoken), hl 
2129 2b				dec hl 
212a				; save pointer to the start of the next dictionay word 
212a 7e				ld a,(hl)   ; get string length 
212b 47				ld b,a 
212c			.execpnwordinc:  
212c 23				inc hl 
212d 10 fd			djnz .execpnwordinc 
212f 22 2c f8			ld (cli_execword), hl      ; save start of this words code 
2132			 
2132				; now check the word token against the string being parsed 
2132			 
2132 2a 2e f8			ld hl,(cli_token) 
2135 23				inc hl     ; skip string length (use zero term instead to end) 
2136 22 2e f8			ld (cli_token), hl 
2139			 
2139			if DEBUG_FORTH_PARSE_KEY 
2139						DMARK "KY2" 
2139			endif 
2139			if DEBUG_FORTH_PARSE_EXEC 
2139				; see if disabled 
2139			 
2139				ld a, (os_view_disable) 
2139				cp '*' 
2139				jr z, .skip 
2139			 
2139				push hl 
2139				push hl 
2139				call clear_display 
2139				ld de, .compword 
2139				ld a, display_row_1 
2139				call str_at_display 
2139				pop de 
2139				ld a, display_row_2 
2139				call str_at_display 
2139				ld hl,(cli_ptr) 
2139				ld a,(hl) 
2139			        ld hl, os_word_scratch 
2139				ld (hl),a 
2139				ld a,0 
2139				inc hl 
2139				ld (hl),a 	 
2139				ld de, os_word_scratch 
2139				ld a, display_row_2+10 
2139				call str_at_display 
2139				call update_display 
2139				ld a, 100 
2139				call aDelayInMS 
2139				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2139				call delay250ms 
2139				endif 
2139				pop hl 
2139			.skip:  
2139			endif	 
2139			.execpnchar:    ; compare char between token and string to parse 
2139			 
2139			if DEBUG_FORTH_PARSE_KEY 
2139						DMARK "Ky3" 
2139			endif 
2139			if DEBUG_FORTH_PARSE_EXEC 
2139				; see if disabled 
2139			 
2139				ld a, (os_view_disable) 
2139				cp '*' 
2139				jr z, .skip2 
2139			 
2139			;	call clear_display 
2139			ld hl,(cli_token) 
2139			ld a,(hl) 
2139			ld (os_word_scratch),a 
2139				ld hl,(cli_ptr) 
2139			ld a,(hl) 
2139				ld (os_word_scratch+1),a 
2139				ld a,0 
2139				ld (os_word_scratch+2),a 
2139				ld de,os_word_scratch 
2139				ld a,display_row_4 
2139				call str_at_display 
2139				call update_display 
2139			.skip2:  
2139			endif 
2139 2a 2e f8			ld hl,(cli_token) 
213c 7e				ld a, (hl)	 ; char in word token 
213d 23				inc hl 		; move to next char 
213e 22 2e f8			ld (cli_token), hl ; and save it 
2141 47				ld b,a 
2142			 
2142 2a 28 f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
2145 7e				ld a,(hl) 
2146 23				inc hl 
2147 22 28 f8			ld (cli_ptr), hl		; move to next char 
214a cd 75 11			call toUpper 		; make sure the input string matches case 
214d			 
214d			if DEBUG_FORTH_PARSE 
214d			endif 
214d			 
214d				; input stream end of token is a space so get rid of it 
214d			 
214d			;	cp ' ' 
214d			;	jr nz, .pnskipspace 
214d			; 
214d			;	ld a, 0		; make same term as word token term 
214d			; 
214d			;.pnskipspace: 
214d			 
214d			if DEBUG_FORTH_PARSE_KEY 
214d						DMARK "KY7" 
214d			endif 
214d b8				cp b 
214e c2 64 21			jp nz, .execpnskipword	 ; no match so move to next word 
2151				 
2151			;    if same 
2151			;       scan for string terms 0 for token and 32 for input 
2151			 
2151				 
2151			if DEBUG_FORTH_PARSE_KEY 
2151						DMARK "KY8" 
2151			endif 
2151			 
2151 80				add b			 
2152 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2154							; TODO need to make sure last word in zero term string is accounted for 
2154 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2156			 
2156			 
2156				; at end of both strings so both are exact match 
2156			 
2156			;       skip ptr for next word 
2156			 
2156 2a 28 f8			ld hl,(cli_ptr) 	; at input string term 
2159 23				inc hl			 ; at next char 
215a 22 28 f8			ld (cli_ptr), hl     ; save for next round of the parser 
215d 22 26 f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2160				 
2160				 
2160			if DEBUG_FORTH_PARSE_KEY 
2160						DMARK "KY3" 
2160			endif 
2160			 
2160			 
2160			 
2160			;       exec code block 
2160			if DEBUG_FORTH_JP 
2160				call clear_display 
2160				call update_display 
2160				call delay1s 
2160				ld hl, (cli_execword)     ; save for next check if no match on this word 
2160				ld a,h 
2160				ld hl, os_word_scratch 
2160				call hexout 
2160				ld hl, (cli_execword)     ; save for next check if no match on this word 
2160				ld a,l 
2160				ld hl, os_word_scratch+2 
2160				call hexout 
2160				ld hl, os_word_scratch+4 
2160				ld a,0 
2160				ld (hl),a 
2160				ld de,os_word_scratch 
2160				call str_at_display 
2160					ld a, display_row_2 
2160					call str_at_display 
2160				ld de, (cli_origtoken) 
2160				ld a, display_row_1+10 
2160					call str_at_display 
2160			 
2160				ld a,display_row_1 
2160				ld de, .foundword 
2160				ld a, display_row_3 
2160				call str_at_display 
2160				call update_display 
2160				call delay1s 
2160				call delay1s 
2160				call delay1s 
2160			endif 
2160			 
2160			if DEBUG_FORTH_PARSE_KEY 
2160						DMARK "KYj" 
2160			endif 
2160				; TODO save the word pointer in this exec 
2160			 
2160 2a 2c f8			ld hl,(cli_execword) 
2163 e9				jp (hl) 
2164			 
2164			 
2164			;    if not same 
2164			;	scan for zero term 
2164			;	get ptr for next word 
2164			;	goto word comp 
2164			 
2164			.execpnskipword:	; get pointer to next word 
2164 2a 2a f8			ld hl,(cli_nextword) 
2167			 
2167 7e				ld a,(hl) 
2168 fe 00			cp WORD_SYS_END 
216a			;	cp 0 
216a 28 09			jr z, .execendofdict			 ; at end of words 
216c			 
216c			if DEBUG_FORTH_PARSE_KEY 
216c						DMARK "KY4" 
216c			endif 
216c			if DEBUG_FORTH_PARSE_EXEC 
216c			 
216c				; see if disabled 
216c			 
216c				ld a, (os_view_disable) 
216c				cp '*' 
216c				jr z, .noskip 
216c			 
216c			 
216c				ld de, .nowordfound 
216c				ld a, display_row_3 
216c				call str_at_display 
216c				call update_display 
216c				ld a, 100 
216c				call aDelayInMS 
216c				 
216c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
216c					call delay250ms 
216c				endif 
216c			.noskip:  
216c			 
216c			endif	 
216c			 
216c 2a 26 f8			ld hl,(cli_origptr) 
216f 22 28 f8			ld (cli_ptr),hl 
2172			 
2172			if DEBUG_FORTH_PARSE_KEY 
2172						DMARK "KY5" 
2172			endif 
2172 c3 18 21			jp .execpnword			; else go to next word 
2175			 
2175			.execendofdict:  
2175			 
2175			if DEBUG_FORTH_PARSE_KEY 
2175						DMARK "KYe" 
2175			endif 
2175			if DEBUG_FORTH_PARSE_EXEC 
2175				; see if disabled 
2175			 
2175				ld a, (os_view_disable) 
2175				cp '*' 
2175				jr z, .ispskip 
2175			 
2175				call clear_display 
2175				call update_display 
2175				call delay1s 
2175				ld de, (cli_origptr) 
2175				ld a, display_row_1 
2175				call str_at_display 
2175				 
2175				ld de, .enddict 
2175				ld a, display_row_3 
2175				call str_at_display 
2175				call update_display 
2175				ld a, 100 
2175				call aDelayInMS 
2175				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2175				call delay1s 
2175				call delay1s 
2175				call delay1s 
2175				endif 
2175			.ispskip:  
2175				 
2175			endif	 
2175			 
2175			 
2175			 
2175				; if the word is not a keyword then must be a literal so push it to stack 
2175			 
2175			; push token to stack to end of word 
2175			 
2175				STACKFRAME ON $1efe $2f9f 
2175				if DEBUG_STACK_IMB 
2175					if ON 
2175						exx 
2175						ld de, $1efe 
2175						ld a, d 
2175						ld hl, curframe 
2175						call hexout 
2175						ld a, e 
2175						ld hl, curframe+2 
2175						call hexout 
2175						ld hl, $1efe 
2175						push hl 
2175						ld hl, $2f9f 
2175						push hl 
2175						exx 
2175					endif 
2175				endif 
2175			endm 
# End of macro STACKFRAME
2175			 
2175 2a 1e f1		ld hl,(os_tok_ptr) 
2178 cd 6d 1e		call forth_apush 
217b			 
217b				STACKFRAMECHK ON $1efe $2f9f 
217b				if DEBUG_STACK_IMB 
217b					if ON 
217b						exx 
217b						ld hl, $2f9f 
217b						pop de   ; $2f9f 
217b						call cmp16 
217b						jr nz, .spnosame 
217b						ld hl, $1efe 
217b						pop de   ; $1efe 
217b						call cmp16 
217b						jr z, .spfrsame 
217b						.spnosame: call showsperror 
217b						.spfrsame: nop 
217b						exx 
217b					endif 
217b				endif 
217b			endm 
# End of macro STACKFRAMECHK
217b			 
217b			execnext: 
217b			 
217b			if DEBUG_FORTH_PARSE_KEY 
217b						DMARK "KY>" 
217b			endif 
217b			; move past token to next word 
217b			 
217b 2a 1e f1		ld hl, (os_tok_ptr) 
217e 3e 00		ld a, 0 
2180 01 ff 00		ld bc, 255     ; input buffer size 
2183 ed b1		cpir 
2185			 
2185			if DEBUG_FORTH_PARSE_KEY 
2185						DMARK "KY!" 
2185				CALLMONITOR 
2185			endif	 
2185			; TODO this might place hl on the null, so will need to forward on??? 
2185			;inc hl   ; see if this gets onto the next item 
2185			 
2185			 
2185			; TODO pass a pointer to the buffer to push 
2185			; TODO call function to push 
2185			 
2185			; look for end of input 
2185			 
2185			;inc hl 
2185			;ld a,(hl) 
2185			;cp FORTH_END_BUFFER 
2185			;ret z 
2185			 
2185			 
2185 c3 fe 20		jp exec1 
2188			 
2188			 
2188			 
2188			 
2188			 
2188			 
2188			 
2188			 
2188			 
2188			findnexttok: 
2188			 
2188				; hl is pointer to move 
2188				; de is the token to locate 
2188			 
2188					if DEBUG_FORTH 
2188						DMARK "NTK" 
2188						CALLMONITOR 
2188					endif 
2188 d5				push de 
2189			 
2189			.fnt1:	 
2189				; find first char of token to locate 
2189			 
2189 1a				ld a, (de) 
218a 4f				ld c,a 
218b 7e				ld a,(hl) 
218c cd 75 11			call toUpper 
218f					if DEBUG_FORTH 
218f						DMARK "NT1" 
218f						CALLMONITOR 
218f					endif 
218f b9				cp c 
2190			 
2190 28 03			jr z, .fnt2cmpmorefirst	 
2192			 
2192				; first char not found move to next char 
2192			 
2192 23				inc hl 
2193 18 f4			jr .fnt1 
2195			 
2195			.fnt2cmpmorefirst:	 
2195				; first char of token found.  
2195			 
2195 e5				push hl     ; save start of token just in case it is the right one 
2196 d9				exx 
2197 e1				pop hl        ; save it to hl' 
2198 d9				exx 
2199			 
2199			 
2199			.fnt2cmpmore:	 
2199				; compare the rest 
2199				 
2199 23				inc hl 
219a 13				inc de 
219b				 
219b 1a				ld a, (de) 
219c 4f				ld c,a 
219d 7e				ld a,(hl) 
219e cd 75 11			call toUpper 
21a1			 
21a1					if DEBUG_FORTH 
21a1						DMARK "NT2" 
21a1						CALLMONITOR 
21a1					endif 
21a1				; c has the token to find char 
21a1				; a has the mem to scan char 
21a1			 
21a1 b9				cp c 
21a2 28 04			jr z,.fntmatch1 
21a4			 
21a4				; they are not the same 
21a4			 
21a4					if DEBUG_FORTH 
21a4						DMARK "NT3" 
21a4						CALLMONITOR 
21a4					endif 
21a4 d1				pop de	; reset de token to look for 
21a5 d5				push de 
21a6 18 e1			jr .fnt1 
21a8				 
21a8			.fntmatch1: 
21a8			 
21a8				; is the same char a null which means we might have a full hit? 
21a8					if DEBUG_FORTH 
21a8						DMARK "NT4" 
21a8						CALLMONITOR 
21a8					endif 
21a8			 
21a8 fe 00			cp 0 
21aa 28 0b			jr z, .fntmatchyes 
21ac			 
21ac				; are we at the end of the token to find? 
21ac			 
21ac					if DEBUG_FORTH 
21ac						DMARK "NT5" 
21ac						CALLMONITOR 
21ac					endif 
21ac 3e 00			ld a, 0 
21ae b9				cp c 
21af			 
21af c2 99 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
21b2			 
21b2					if DEBUG_FORTH 
21b2						DMARK "NT6" 
21b2						CALLMONITOR 
21b2					endif 
21b2				; token to find is exhusted but no match to stream 
21b2			 
21b2				; restore tok pointer and continue on 
21b2 d1				pop de 
21b3 d5				push de 
21b4 c3 89 21			jp .fnt1 
21b7			 
21b7			 
21b7			.fntmatchyes: 
21b7			 
21b7				; hl now contains the end of the found token 
21b7			 
21b7				; get rid of saved token pointer to find 
21b7			 
21b7 d1				pop de 
21b8			 
21b8					if DEBUG_FORTH 
21b8						DMARK "NT9" 
21b8						CALLMONITOR 
21b8					endif 
21b8			 
21b8				; hl will be on the null term so forward on 
21b8			 
21b8				; get back the saved start of the token 
21b8			 
21b8 d9				exx 
21b9 e5				push hl     ; save start of token just in case it is the right one 
21ba d9				exx 
21bb e1				pop hl        ; save it to hl 
21bc			 
21bc c9				ret 
21bd			 
21bd			 
21bd			; LIST needs to find a specific token   
21bd			; FORGET needs to find a spefici token 
21bd			 
21bd			; SAVE needs to find all tokens by flag 
21bd			; WORDS just needs to scan through all  by flag 
21bd			; UWORDS needs to scan through all by flag 
21bd			 
21bd			 
21bd			; given hl as pointer to start of dict look up string 
21bd			; return hl as pointer to start of word block 
21bd			; or 0 if not found 
21bd			 
21bd			forth_find_tok: 
21bd c9				ret 
21be			 
21be			; given hl as pointer to dict structure 
21be			; move to the next dict block structure 
21be			 
21be			forth_tok_next: 
21be				; hl now points to the address of the next word pointer  
21be				; TODO skip compiled symbol for now 
21be			;	push de 
21be 23				inc hl 
21bf 5e				ld e, (hl) 
21c0 23				inc hl 
21c1 56				ld d, (hl) 
21c2 23				inc hl 
21c3			 
21c3 eb				ex de,hl 
21c4			if DEBUG_FORTH_PARSE_NEXTWORD 
21c4				push bc 
21c4				ld bc, (cli_nextword) 
21c4						DMARK "NXW" 
21c4				CALLMONITOR 
21c4				pop bc 
21c4			endif 
21c4			;	pop de	 
21c4 c9				ret 
21c5			 
21c5			 
21c5			 
21c5			; eof 
# End of file forth_parserv5.asm
21c5				include "forth_wordsv4.asm" 
21c5			 
21c5			; the core word dictionary v4 
21c5			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
21c5			 
21c5			; this is a linked list for each of the system words used 
21c5			; user defined words will follow the same format but will be in ram 
21c5			 
21c5			 
21c5			; 
21c5			; 
21c5			; define linked list: 
21c5			; 
21c5			; 1. compiled byte op code 
21c5			; 2. len of text word 
21c5			; 3. text word 
21c5			; 4. ptr to next dictionary word 
21c5			; 5. asm, calls etc for the word 
21c5			; 
21c5			;  if 1 == 0 then last word in dict  
21c5			;   
21c5			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
21c5			;  
21c5			;  
21c5			; create basic standard set of words 
21c5			; 
21c5			;  
21c5			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
21c5			; 2DUP 2DROP 2SWAP  
21c5			; @ C@ - get byte  
21c5			; ! C! - store byte 
21c5			; 0< true if less than zero 
21c5			; 0= true if zero 
21c5			; < >  
21c5			; = true if same 
21c5			; variables 
21c5			 
21c5			 
21c5			; Hardware specific words I may need 
21c5			; 
21c5			; IN OUT  
21c5			; calls to key util functions 
21c5			; calls to hardward abstraction stuff 
21c5			; easy control of frame buffers and lcd i/o 
21c5			; keyboard  
21c5			 
21c5			 
21c5			;DICT: macro 
21c5			; op_code, len, word, next 
21c5			;    word: 
21c5			;    db op_code 
21c5			;    ds word zero term 
21c5			;    dw next 
21c5			;    endm 
21c5			 
21c5			 
21c5			 
21c5			 
21c5			; op code 1 is a flag for user define words which are to be handled differently 
21c5			 
21c5			 
21c5			; 
21c5			; 
21c5			;    TODO on entry to a word this should be the expected environment 
21c5			;    hl - tos value if number then held, if string this is the ptr 
21c5			;    de -  
21c5			 
21c5			 
21c5			; opcode ranges 
21c5			; 0 - end of word dict 
21c5			; 255 - user define words 
21c5			 
21c5			sysdict: 
21c5			include "forth_opcodes.asm" 
21c5			; op codes for forth keywords 
21c5			; free to use code 0  
21c5				OPCODE_HEAP: equ  1 
21c5				OPCODE_EXEC: equ 2 
21c5				OPCODE_DUP: equ 3 
21c5				OPCODE_SWAP: equ 4 
21c5				OPCODE_COLN: equ 5 
21c5				OPCODE_SCOLN: equ 6 
21c5				OPCODE_DROP: equ 7 
21c5				OPCODE_DUP2: equ 8 
21c5				OPCODE_DROP2: equ 9 
21c5				OPCODE_SWAP2: equ 10 
21c5				OPCODE_AT: equ 11 
21c5				OPCODE_CAT: equ 12 
21c5				OPCODE_BANG: equ 13 
21c5				OPCODE_CBANG: equ 14 
21c5				OPCODE_SCALL: equ 15 
21c5				OPCODE_DEPTH: equ 16 
21c5				OPCODE_OVER: equ 17 
21c5				OPCODE_PAUSE: equ 18 
21c5				OPCODE_PAUSES: equ 19 
21c5				OPCODE_ROT: equ 20 
21c5			;free to reuse	OPCODE_WORDS: equ 21 
21c5			        OPCODE_NOT: equ 21 
21c5				OPCODE_UWORDS: equ 22 
21c5				OPCODE_BP: equ 23 
21c5				OPCODE_MONITOR: equ 24  
21c5				OPCODE_MALLOC: equ 25 
21c5				OPCODE_FREE: equ 26 
21c5				OPCODE_LIST: equ 27 
21c5				OPCODE_FORGET: equ 28 
21c5				OPCODE_NOP: equ 29 
21c5				OPCODE_COMO: equ 30 
21c5				OPCODE_COMC: equ 31 
21c5			;free to reuse	OPCODE_ENDCORE: equ 32 
21c5				OPCODE_AFTERSOUND: equ 33 
21c5				OPCODE_GP2: equ 34 
21c5				OPCODE_GP3: equ 35 
21c5				OPCODE_GP4: equ 36 
21c5				OPCODE_SIN: equ 37 
21c5				OPCODE_SOUT: equ 38 
21c5				OPCODE_SPIO: equ 39 
21c5				OPCODE_SPICEH: equ 40 
21c5				OPCODE_SPIOb: equ 41 
21c5				OPCODE_SPII: equ 42 
21c5				OPCODE_SESEL: equ 43 
21c5				OPCODE_CARTDEV: equ 44 
21c5			; free to reuse	OPCODE_ENDDEVICE: equ 45 
21c5				OPCODE_FB: equ 46 
21c5				OPCODE_EMIT: equ 47 
21c5				OPCODE_DOTH: equ 48 
21c5				OPCODE_DOTF: equ 49 
21c5				OPCODE_DOT: equ 50 
21c5				OPCODE_CLS: equ 51 
21c5				OPCODE_DRAW: equ 52 
21c5				OPCODE_DUMP: equ 53 
21c5				OPCODE_CDUMP: equ 54 
21c5				OPCODE_DAT: equ 55 
21c5				OPCODE_HOME: equ 56 
21c5				OPCODE_SPACE: equ 57 
21c5				OPCODE_SPACES: equ 58 
21c5				OPCODE_SCROLL: equ 59 
21c5				OPCODE_ATQ: equ 60 
21c5				OPCODE_AUTODSP: equ 61 
21c5				OPCODE_MENU: equ 62 
21c5			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
21c5				OPCODE_THEN: equ 64 
21c5				OPCODE_ELSE: equ 65 
21c5				OPCODE_DO: equ 66 
21c5				OPCODE_LOOP: equ 67 
21c5				OPCODE_I: equ 68 
21c5				OPCODE_DLOOP: equ 69  
21c5				OPCODE_REPEAT: equ 70  
21c5				OPCODE_UNTIL: equ 71 
21c5				OPCODE_ENDFLOW: equ 72 
21c5				OPCODE_WAITK: equ 73 
21c5				OPCODE_ACCEPT: equ 74 
21c5				OPCODE_EDIT: equ 75 
21c5			;free to reuse	OPCODE_ENDKEY: equ 76 
21c5				OPCODE_LZERO: equ 77 
21c5				OPCODE_TZERO: equ 78 
21c5				OPCODE_LESS: equ 79 
21c5				OPCODE_GT: equ 80 
21c5				OPCODE_EQUAL: equ 81  
21c5			;free to reuse	OPCODE_ENDLOGIC: equ 82 
21c5				OPCODE_NEG: equ 83 
21c5				OPCODE_DIV: equ 84 
21c5				OPCODE_MUL: equ 85 
21c5				OPCODE_MIN: equ 86 
21c5				OPCODE_MAX: equ 87 
21c5				OPCODE_RND16: equ 88 
21c5				OPCODE_RND8: equ 89 
21c5				OPCODE_RND: equ 90 
21c5			;free to reuse	OPCODE_ENDMATHS: equ 91  
21c5				OPCODE_BYNAME: equ 92 
21c5				OPCODE_DIR: equ 93 
21c5				OPCODE_SAVE: equ 94 
21c5				OPCODE_LOAD: equ 95 
21c5				OPCODE_BSAVE: equ 96 
21c5				OPCODE_BLOAD: equ 97 
21c5				OPCODE_SEO: equ 98  
21c5				OPCODE_SEI: equ 99 
21c5				OPCODE_SFREE: equ 100 
21c5				OPCODE_SIZE: equ 101 
21c5				OPCODE_CREATE: equ 102 
21c5				OPCODE_APPEND: equ 103 
21c5				OPCODE_SDEL: equ 104 
21c5				OPCODE_OPEN: equ 105 
21c5				OPCODE_READ: equ 106 
21c5				OPCODE_EOF: equ 106 
21c5				OPCODE_FORMAT: equ 107 
21c5				OPCODE_LABEL: equ 108 
21c5				OPCODE_LABELS: equ 109 
21c5			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
21c5				OPCODE_UPPER: equ 111 
21c5				OPCODE_LOWER: equ 112 
21c5				OPCODE_SUBSTR: equ 113 
21c5				OPCODE_LEFT: equ 114 
21c5				OPCODE_RIGHT: equ 115 
21c5				OPCODE_STR2NUM: equ 116 
21c5				OPCODE_NUM2STR: equ 117 
21c5				OPCODE_CONCAT: equ 118 
21c5				OPCODE_FIND: equ 119 
21c5				OPCODE_LEN: equ 120 
21c5				OPCODE_CHAR: equ 121 
21c5			; free to reuse	OPCODE_STRLEN: equ 122 
21c5			; free to reuse	OPCODE_ENDSTR: equ 123 
21c5				OPCODE_V0S: equ 124 
21c5				OPCODE_V0Q: equ 125 
21c5				OPCODE_V1S: equ 126 
21c5				OPCODE_V1Q: equ 127 
21c5				OPCODE_V2S: equ 128 
21c5				OPCODE_V2Q: equ 129 
21c5				OPCODE_V3S: equ 130 
21c5				OPCODE_V3Q: equ 131 
21c5			;free to reuse	OPCODE_END: equ 132 
21c5				OPCODE_ZDUP: equ 133 
21c5			 
21c5			; eof 
# End of file forth_opcodes.asm
21c5			 
21c5			include "forth_words_core.asm" 
21c5			 
21c5			; | ## Core Words 
21c5			 
21c5			;if MALLOC_4 
21c5			 
21c5			.HEAP: 
21c5				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
21c5 15				db WORD_SYS_CORE+OPCODE_HEAP             
21c6 04 22			dw .EXEC            
21c8 05				db 4 + 1 
21c9 .. 00			db "HEAP",0              
21ce				endm 
# End of macro CWHEAD
21ce			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
21ce			; | | u1 - Current number of bytes in the heap 
21ce			; | | u2 - Remaining bytes left on the heap 
21ce			; | |  
21ce			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
21ce			 
21ce			 
21ce					if DEBUG_FORTH_WORDS_KEY 
21ce						DMARK "HEP" 
21ce f5				push af  
21cf 3a e3 21			ld a, (.dmark)  
21d2 32 77 fb			ld (debug_mark),a  
21d5 3a e4 21			ld a, (.dmark+1)  
21d8 32 78 fb			ld (debug_mark+1),a  
21db 3a e5 21			ld a, (.dmark+2)  
21de 32 79 fb			ld (debug_mark+2),a  
21e1 18 03			jr .pastdmark  
21e3 ..			.dmark: db "HEP"  
21e6 f1			.pastdmark: pop af  
21e7			endm  
# End of macro DMARK
21e7						CALLMONITOR 
21e7 cd 74 17			call break_point_state  
21ea				endm  
# End of macro CALLMONITOR
21ea					endif 
21ea 2a 0a 80				ld hl, (free_list )      
21ed 11 0e 80				ld de, heap_start 
21f0			 
21f0 ed 52				sbc hl, de  
21f2			 
21f2 cd 04 1d				call forth_push_numhl 
21f5			 
21f5			 
21f5 ed 5b 0a 80			ld de, (free_list )      
21f9 21 03 ee				ld hl, heap_end 
21fc			 
21fc ed 52				sbc hl, de 
21fe			 
21fe cd 04 1d				call forth_push_numhl 
2201					 
2201			 
2201					 
2201			 
2201			 
2201			 
2201					NEXTW 
2201 c3 6d 20			jp macro_next 
2204				endm 
# End of macro NEXTW
2204			;endif 
2204			 
2204			.EXEC: 
2204			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2204			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2204			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2204			;; > > 
2204			;; > >   
2204			;	STACKFRAME OFF $5efe $5f9f 
2204			; 
2204			;		if DEBUG_FORTH_WORDS_KEY 
2204			;			DMARK "EXE" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			; 
2204			;	FORTH_DSP_VALUEHL 
2204			; 
2204			;	FORTH_DSP_POP 
2204			; 
2204			;		if DEBUG_FORTH_WORDS 
2204			;			DMARK "EX1" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			;;	ld e,(hl) 
2204			;;	inc hl 
2204			;;	ld d,(hl) 
2204			;;	ex de,hl 
2204			; 
2204			;;		if DEBUG_FORTH_WORDS 
2204			;;			DMARK "EX2" 
2204			;;			CALLMONITOR 
2204			;;		endif 
2204			;	push hl 
2204			; 
2204			;	;ld a, 0 
2204			;	;ld a, FORTH_END_BUFFER 
2204			;	call strlenz 
2204			;	inc hl   ; include zero term to copy 
2204			;	inc hl   ; include term 
2204			;	inc hl   ; include term 
2204			;	ld b,0 
2204			;	ld c,l 
2204			;	pop hl 
2204			;	ld de, execscratch 
2204			;		if DEBUG_FORTH_WORDS 
2204			;			DMARK "EX3" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			;	ldir 
2204			; 
2204			; 
2204			;	ld hl, execscratch 
2204			; 
2204			;		if DEBUG_FORTH_WORDS 
2204			;			DMARK "EXe" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			; 
2204			;	call forthparse 
2204			;	call forthexec 
2204			;;	call forthexec_cleanup 
2204			;;	call forthparse 
2204			;;	call forthexec 
2204			; 
2204			;	STACKFRAMECHK OFF $5efe $5f9f 
2204			; 
2204			;	; an immediate word so no need to process any more words 
2204			;	ret 
2204			;	NEXTW 
2204			 
2204			; dead code - old version  
2204			;	FORTH_RSP_NEXT 
2204			 
2204			;  
2204			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2204			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2204			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2204			;	push hl 
2204			;	push de 
2204			;	push bc 
2204			; 
2204			; 
2204			;		if DEBUG_FORTH_WORDS_KEY 
2204			;			DMARK "EXR" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			; 
2204			; 
2204			; 
2204			;	;v5 FORTH_DSP_VALUE 
2204			;	FORTH_DSP_VALUEHL 
2204			; 
2204			;	; TODO do string type checks 
2204			; 
2204			;;v5	inc hl   ; skip type 
2204			; 
2204			;	push hl  ; source code  
2204			;		if DEBUG_FORTH_WORDS 
2204			;			DMARK "EX1" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			;	ld a, 0 
2204			;	call strlent 
2204			; 
2204			;	inc hl 
2204			;	inc hl 
2204			;	inc hl 
2204			;	inc hl 
2204			; 
2204			;	push hl    ; size 
2204			; 
2204			;		if DEBUG_FORTH_WORDS 
2204			;			DMARK "EX2" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			;	call malloc 
2204			; 
2204			;	ex de, hl    ; de now contains malloc area 
2204			;	pop bc   	; get byte count 
2204			;	pop hl      ; get string to copy 
2204			; 
2204			;	push de     ; save malloc for free later 
2204			; 
2204			;		if DEBUG_FORTH_WORDS 
2204			;			DMARK "EX3" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			;	ldir       ; duplicate string 
2204			; 
2204			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2204			;	 
2204			;	; TODO fix the parse would be better than this...  
2204			;	ex de, hl 
2204			;	dec hl 
2204			;	ld a, 0 
2204			;	ld (hl), a 
2204			;	dec hl 
2204			;	ld a, ' ' 
2204			;	ld (hl), a 
2204			;	dec hl 
2204			;	ld (hl), a 
2204			; 
2204			;	dec hl 
2204			;	ld (hl), a 
2204			; 
2204			; 
2204			;	FORTH_DSP_POP  
2204			; 
2204			;	pop hl     
2204			;	push hl    ; save malloc area 
2204			; 
2204			;		if DEBUG_FORTH_WORDS 
2204			;			DMARK "EX4" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			; 
2204			;	call forthparse 
2204			;	call forthexec 
2204			;	 
2204			;	pop hl 
2204			;	if DEBUG_FORTH_WORDS 
2204			;		DMARK "EX5" 
2204			;		CALLMONITOR 
2204			;	endif 
2204			; 
2204			;	if FORTH_ENABLE_FREE 
2204			;	call free 
2204			;	endif 
2204			; 
2204			;	if DEBUG_FORTH_WORDS 
2204			;		DMARK "EX6" 
2204			;		CALLMONITOR 
2204			;	endif 
2204			; 
2204			;	pop bc 
2204			;	pop de 
2204			;	pop hl 
2204			;;	FORTH_RSP_POP	  
2204			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2204			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2204			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2204			; 
2204			;	if DEBUG_FORTH_WORDS 
2204			;		DMARK "EX7" 
2204			;		CALLMONITOR 
2204			;	endif 
2204			;	NEXTW 
2204			 
2204			;.STKEXEC: 
2204			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2204			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2204			; 
2204			; 
2204			;		if DEBUG_FORTH_WORDS_KEY 
2204			;			DMARK "STX" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			; 
2204			;	FORTH_DSP_VALUEHL 
2204			; 
2204			;	ld (store_tmp1), hl    ; count 
2204			; 
2204			;	FORTH_DSP_POP 
2204			;.stkexec1: 
2204			;	ld hl, (store_tmp1)   ; count 
2204			;	ld a, 0 
2204			;	cp l 
2204			;	ret z 
2204			; 
2204			;	dec hl 
2204			;	ld (store_tmp1), hl    ; count 
2204			;	 
2204			;	FORTH_DSP_VALUEHL 
2204			;	push hl 
2204			;	 
2204			;		if DEBUG_FORTH_WORDS 
2204			;			DMARK "EXp" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			;	FORTH_DSP_POP 
2204			; 
2204			;	call strlenz 
2204			;	inc hl   ; include zero term to copy 
2204			;	inc hl   ; include zero term to copy 
2204			;	inc hl   ; include zero term to copy 
2204			;	ld b,0 
2204			;	ld c,l 
2204			;	pop hl 
2204			;	ld de, execscratch 
2204			;		if DEBUG_FORTH_WORDS 
2204			;			DMARK "EX3" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			;	ldir 
2204			; 
2204			; 
2204			;	ld hl, execscratch 
2204			; 
2204			;		if DEBUG_FORTH_WORDS 
2204			;			DMARK "EXP" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			; 
2204			;	call forthparse 
2204			;	ld hl, execscratch 
2204			;		if DEBUG_FORTH_WORDS 
2204			;			DMARK "EXx" 
2204			;			CALLMONITOR 
2204			;		endif 
2204			;	call forthexec 
2204			; 
2204			;	jp .stkexec1 
2204			; 
2204			;	ret 
2204			 
2204			 
2204			.DUP: 
2204				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2204 17				db WORD_SYS_CORE+OPCODE_DUP             
2205 7a 22			dw .ZDUP            
2207 04				db 3 + 1 
2208 .. 00			db "DUP",0              
220c				endm 
# End of macro CWHEAD
220c			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
220c			 
220c					if DEBUG_FORTH_WORDS_KEY 
220c						DMARK "DUP" 
220c f5				push af  
220d 3a 21 22			ld a, (.dmark)  
2210 32 77 fb			ld (debug_mark),a  
2213 3a 22 22			ld a, (.dmark+1)  
2216 32 78 fb			ld (debug_mark+1),a  
2219 3a 23 22			ld a, (.dmark+2)  
221c 32 79 fb			ld (debug_mark+2),a  
221f 18 03			jr .pastdmark  
2221 ..			.dmark: db "DUP"  
2224 f1			.pastdmark: pop af  
2225			endm  
# End of macro DMARK
2225						CALLMONITOR 
2225 cd 74 17			call break_point_state  
2228				endm  
# End of macro CALLMONITOR
2228					endif 
2228			 
2228					FORTH_DSP 
2228 cd c1 1e			call macro_forth_dsp 
222b				endm 
# End of macro FORTH_DSP
222b			 
222b 7e					ld a, (HL) 
222c fe 01				cp DS_TYPE_STR 
222e 20 25				jr nz, .dupinum 
2230			 
2230					; push another string 
2230			 
2230					FORTH_DSP_VALUEHL     		 
2230 cd fb 1e			call macro_dsp_valuehl 
2233				endm 
# End of macro FORTH_DSP_VALUEHL
2233			 
2233				if DEBUG_FORTH_WORDS 
2233					DMARK "DUs" 
2233 f5				push af  
2234 3a 48 22			ld a, (.dmark)  
2237 32 77 fb			ld (debug_mark),a  
223a 3a 49 22			ld a, (.dmark+1)  
223d 32 78 fb			ld (debug_mark+1),a  
2240 3a 4a 22			ld a, (.dmark+2)  
2243 32 79 fb			ld (debug_mark+2),a  
2246 18 03			jr .pastdmark  
2248 ..			.dmark: db "DUs"  
224b f1			.pastdmark: pop af  
224c			endm  
# End of macro DMARK
224c					CALLMONITOR 
224c cd 74 17			call break_point_state  
224f				endm  
# End of macro CALLMONITOR
224f				endif 
224f cd 72 1d				call forth_push_str 
2252			 
2252					NEXTW 
2252 c3 6d 20			jp macro_next 
2255				endm 
# End of macro NEXTW
2255			 
2255			 
2255			.dupinum: 
2255					 
2255			 
2255			 
2255					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2255 cd fb 1e			call macro_dsp_valuehl 
2258				endm 
# End of macro FORTH_DSP_VALUEHL
2258			 
2258				; TODO add floating point number detection 
2258			 
2258				if DEBUG_FORTH_WORDS 
2258					DMARK "DUi" 
2258 f5				push af  
2259 3a 6d 22			ld a, (.dmark)  
225c 32 77 fb			ld (debug_mark),a  
225f 3a 6e 22			ld a, (.dmark+1)  
2262 32 78 fb			ld (debug_mark+1),a  
2265 3a 6f 22			ld a, (.dmark+2)  
2268 32 79 fb			ld (debug_mark+2),a  
226b 18 03			jr .pastdmark  
226d ..			.dmark: db "DUi"  
2270 f1			.pastdmark: pop af  
2271			endm  
# End of macro DMARK
2271					CALLMONITOR 
2271 cd 74 17			call break_point_state  
2274				endm  
# End of macro CALLMONITOR
2274				endif 
2274			 
2274 cd 04 1d				call forth_push_numhl 
2277					NEXTW 
2277 c3 6d 20			jp macro_next 
227a				endm 
# End of macro NEXTW
227a			.ZDUP: 
227a				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
227a 99				db WORD_SYS_CORE+OPCODE_ZDUP             
227b b2 22			dw .SWAP            
227d 05				db 4 + 1 
227e .. 00			db "?DUP",0              
2283				endm 
# End of macro CWHEAD
2283			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2283			 
2283					if DEBUG_FORTH_WORDS_KEY 
2283						DMARK "qDU" 
2283 f5				push af  
2284 3a 98 22			ld a, (.dmark)  
2287 32 77 fb			ld (debug_mark),a  
228a 3a 99 22			ld a, (.dmark+1)  
228d 32 78 fb			ld (debug_mark+1),a  
2290 3a 9a 22			ld a, (.dmark+2)  
2293 32 79 fb			ld (debug_mark+2),a  
2296 18 03			jr .pastdmark  
2298 ..			.dmark: db "qDU"  
229b f1			.pastdmark: pop af  
229c			endm  
# End of macro DMARK
229c						CALLMONITOR 
229c cd 74 17			call break_point_state  
229f				endm  
# End of macro CALLMONITOR
229f					endif 
229f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
229f cd fb 1e			call macro_dsp_valuehl 
22a2				endm 
# End of macro FORTH_DSP_VALUEHL
22a2			 
22a2 e5					push hl 
22a3			 
22a3					; is it a zero? 
22a3			 
22a3 3e 00				ld a, 0 
22a5 84					add h 
22a6 85					add l 
22a7			 
22a7 e1					pop hl 
22a8			 
22a8 fe 00				cp 0 
22aa 28 03				jr z, .dup2orig 
22ac			 
22ac			 
22ac cd 04 1d				call forth_push_numhl 
22af			 
22af			 
22af				; TODO add floating point number detection 
22af			 
22af			.dup2orig: 
22af			 
22af					NEXTW 
22af c3 6d 20			jp macro_next 
22b2				endm 
# End of macro NEXTW
22b2			.SWAP: 
22b2				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
22b2 18				db WORD_SYS_CORE+OPCODE_SWAP             
22b3 f1 22			dw .COLN            
22b5 05				db 4 + 1 
22b6 .. 00			db "SWAP",0              
22bb				endm 
# End of macro CWHEAD
22bb			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
22bb					if DEBUG_FORTH_WORDS_KEY 
22bb						DMARK "SWP" 
22bb f5				push af  
22bc 3a d0 22			ld a, (.dmark)  
22bf 32 77 fb			ld (debug_mark),a  
22c2 3a d1 22			ld a, (.dmark+1)  
22c5 32 78 fb			ld (debug_mark+1),a  
22c8 3a d2 22			ld a, (.dmark+2)  
22cb 32 79 fb			ld (debug_mark+2),a  
22ce 18 03			jr .pastdmark  
22d0 ..			.dmark: db "SWP"  
22d3 f1			.pastdmark: pop af  
22d4			endm  
# End of macro DMARK
22d4						CALLMONITOR 
22d4 cd 74 17			call break_point_state  
22d7				endm  
# End of macro CALLMONITOR
22d7					endif 
22d7			 
22d7					FORTH_DSP_VALUEHL 
22d7 cd fb 1e			call macro_dsp_valuehl 
22da				endm 
# End of macro FORTH_DSP_VALUEHL
22da e5					push hl     ; w2 
22db			 
22db					FORTH_DSP_POP 
22db cd b3 1f			call macro_forth_dsp_pop 
22de				endm 
# End of macro FORTH_DSP_POP
22de			 
22de					FORTH_DSP_VALUEHL 
22de cd fb 1e			call macro_dsp_valuehl 
22e1				endm 
# End of macro FORTH_DSP_VALUEHL
22e1			 
22e1					FORTH_DSP_POP 
22e1 cd b3 1f			call macro_forth_dsp_pop 
22e4				endm 
# End of macro FORTH_DSP_POP
22e4			 
22e4 d1					pop de     ; w2	, hl = w1 
22e5			 
22e5 eb					ex de, hl 
22e6 d5					push de 
22e7			 
22e7 cd 04 1d				call forth_push_numhl 
22ea			 
22ea e1					pop hl 
22eb			 
22eb cd 04 1d				call forth_push_numhl 
22ee					 
22ee			 
22ee					NEXTW 
22ee c3 6d 20			jp macro_next 
22f1				endm 
# End of macro NEXTW
22f1			.COLN: 
22f1				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22f1 19				db WORD_SYS_CORE+OPCODE_COLN             
22f2 7d 24			dw .SCOLN            
22f4 02				db 1 + 1 
22f5 .. 00			db ":",0              
22f7				endm 
# End of macro CWHEAD
22f7			; | : ( -- )         Create new word | DONE 
22f7			 
22f7					if DEBUG_FORTH_WORDS_KEY 
22f7						DMARK "CLN" 
22f7 f5				push af  
22f8 3a 0c 23			ld a, (.dmark)  
22fb 32 77 fb			ld (debug_mark),a  
22fe 3a 0d 23			ld a, (.dmark+1)  
2301 32 78 fb			ld (debug_mark+1),a  
2304 3a 0e 23			ld a, (.dmark+2)  
2307 32 79 fb			ld (debug_mark+2),a  
230a 18 03			jr .pastdmark  
230c ..			.dmark: db "CLN"  
230f f1			.pastdmark: pop af  
2310			endm  
# End of macro DMARK
2310						CALLMONITOR 
2310 cd 74 17			call break_point_state  
2313				endm  
# End of macro CALLMONITOR
2313					endif 
2313				STACKFRAME OFF $8efe $989f 
2313				if DEBUG_STACK_IMB 
2313					if OFF 
2313						exx 
2313						ld de, $8efe 
2313						ld a, d 
2313						ld hl, curframe 
2313						call hexout 
2313						ld a, e 
2313						ld hl, curframe+2 
2313						call hexout 
2313						ld hl, $8efe 
2313						push hl 
2313						ld hl, $989f 
2313						push hl 
2313						exx 
2313					endif 
2313				endif 
2313			endm 
# End of macro STACKFRAME
2313				; get parser buffer length  of new word 
2313			 
2313				 
2313			 
2313					; move tok past this to start of name defintition 
2313					; TODO get word to define 
2313					; TODO Move past word token 
2313					; TODO get length of string up to the ';' 
2313			 
2313 2a 1e f1			ld hl, (os_tok_ptr) 
2316 23				inc hl 
2317 23				inc hl 
2318			 
2318 3e 3b			ld a, ';' 
231a cd 89 11			call strlent 
231d			 
231d 7d				ld a,l 
231e 32 19 ee			ld (os_new_parse_len), a 
2321			 
2321			 
2321			if DEBUG_FORTH_UWORD 
2321 ed 5b 1e f1		ld de, (os_tok_ptr) 
2325						DMARK ":01" 
2325 f5				push af  
2326 3a 3a 23			ld a, (.dmark)  
2329 32 77 fb			ld (debug_mark),a  
232c 3a 3b 23			ld a, (.dmark+1)  
232f 32 78 fb			ld (debug_mark+1),a  
2332 3a 3c 23			ld a, (.dmark+2)  
2335 32 79 fb			ld (debug_mark+2),a  
2338 18 03			jr .pastdmark  
233a ..			.dmark: db ":01"  
233d f1			.pastdmark: pop af  
233e			endm  
# End of macro DMARK
233e				CALLMONITOR 
233e cd 74 17			call break_point_state  
2341				endm  
# End of macro CALLMONITOR
2341			endif 
2341			 
2341			; 
2341			;  new word memory layout: 
2341			;  
2341			;    : adg 6666 ;  
2341			; 
2341			;    db   1     ; user defined word  
2341 23				inc hl    
2342			;    dw   sysdict 
2342 23				inc hl 
2343 23				inc hl 
2344			;    db <word len>+1 (for null) 
2344 23				inc hl 
2345			;    db .... <word> 
2345			; 
2345			 
2345 23				inc hl    ; some extras for the word preamble before the above 
2346 23				inc hl 
2347 23				inc hl 
2348 23				inc hl 
2349 23				inc hl 
234a 23				inc hl 
234b 23				inc hl  
234c 23				inc hl 
234d 23				inc hl 
234e 23				inc hl 
234f 23				inc hl 
2350 23				inc hl 
2351 23				inc hl 
2352 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2353			;       exec word buffer 
2353			;	<ptr word>   
2353 23				inc hl 
2354 23				inc hl 
2355			;       <word list><null term> 7F final term 
2355			 
2355			 
2355			if DEBUG_FORTH_UWORD 
2355						DMARK ":02" 
2355 f5				push af  
2356 3a 6a 23			ld a, (.dmark)  
2359 32 77 fb			ld (debug_mark),a  
235c 3a 6b 23			ld a, (.dmark+1)  
235f 32 78 fb			ld (debug_mark+1),a  
2362 3a 6c 23			ld a, (.dmark+2)  
2365 32 79 fb			ld (debug_mark+2),a  
2368 18 03			jr .pastdmark  
236a ..			.dmark: db ":02"  
236d f1			.pastdmark: pop af  
236e			endm  
# End of macro DMARK
236e				CALLMONITOR 
236e cd 74 17			call break_point_state  
2371				endm  
# End of macro CALLMONITOR
2371			endif 
2371			 
2371				 
2371					; malloc the size 
2371			 
2371 cd e7 11				call malloc 
2374 22 1b ee				ld (os_new_malloc), hl     ; save malloc start 
2377			 
2377			;    db   1     ; user defined word  
2377 3e 01				ld a, WORD_SYS_UWORD  
2379 77					ld (hl), a 
237a				 
237a 23				inc hl    
237b			;    dw   sysdict 
237b 11 c5 21			ld de, sysdict       ; continue on with the scan to the system dict 
237e 73				ld (hl), e 
237f 23				inc hl 
2380 72				ld (hl), d 
2381 23				inc hl 
2382			 
2382			 
2382			;    Setup dict word 
2382			 
2382 23				inc hl 
2383 22 15 ee			ld (os_new_work_ptr), hl     ; save start of dict word  
2386			 
2386				; 1. get length of dict word 
2386			 
2386			 
2386 2a 1e f1			ld hl, (os_tok_ptr) 
2389 23				inc hl 
238a 23				inc hl    ; position to start of dict word 
238b 3e 00			ld a, 0 
238d cd 89 11			call strlent 
2390			 
2390			 
2390 23				inc hl    ; to include null??? 
2391			 
2391				; write length of dict word 
2391			 
2391 ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2395 1b				dec de 
2396 eb				ex de, hl 
2397 73				ld (hl), e 
2398 eb				ex de, hl 
2399			 
2399				 
2399			 
2399				; copy  
2399 4d				ld c, l 
239a 06 00			ld b, 0 
239c ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
23a0 2a 1e f1			ld hl, (os_tok_ptr) 
23a3 23				inc hl 
23a4 23				inc hl    ; position to start of dict word 
23a5				 
23a5			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
23a5				 
23a5				; TODO need to convert word to upper case 
23a5			 
23a5			ucasetok:	 
23a5 7e				ld a,(hl) 
23a6 cd 75 11			call toUpper 
23a9 77				ld (hl),a 
23aa ed a0			ldi 
23ac f2 a5 23		 	jp p, ucasetok 
23af			 
23af			 
23af			 
23af				; de now points to start of where the word body code should be placed 
23af ed 53 15 ee		ld (os_new_work_ptr), de 
23b3				; hl now points to the words to throw at forthexec which needs to be copied 
23b3 22 13 ee			ld (os_new_src_ptr), hl 
23b6			 
23b6				; TODO add 'call to forthexec' 
23b6			 
23b6			if DEBUG_FORTH_UWORD 
23b6 c5				push bc 
23b7 ed 4b 1b ee		ld bc, (os_new_malloc) 
23bb						DMARK ":0x" 
23bb f5				push af  
23bc 3a d0 23			ld a, (.dmark)  
23bf 32 77 fb			ld (debug_mark),a  
23c2 3a d1 23			ld a, (.dmark+1)  
23c5 32 78 fb			ld (debug_mark+1),a  
23c8 3a d2 23			ld a, (.dmark+2)  
23cb 32 79 fb			ld (debug_mark+2),a  
23ce 18 03			jr .pastdmark  
23d0 ..			.dmark: db ":0x"  
23d3 f1			.pastdmark: pop af  
23d4			endm  
# End of macro DMARK
23d4				CALLMONITOR 
23d4 cd 74 17			call break_point_state  
23d7				endm  
# End of macro CALLMONITOR
23d7 c1				pop bc 
23d8			endif 
23d8			 
23d8			 
23d8				; create word preamble which should be: 
23d8			 
23d8			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
23d8			 
23d8				;    ld hl, <word code> 
23d8				;    jp user_exec 
23d8			        ;    <word code bytes> 
23d8			 
23d8			 
23d8			;	inc de     ; TODO ??? or are we already past the word's null 
23d8 eb				ex de, hl 
23d9			 
23d9 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
23db			 
23db 23				inc hl 
23dc 22 0f ee			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
23df 23				inc hl 
23e0			 
23e0 23				inc hl 
23e1 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
23e3			 
23e3 01 5c 51			ld bc, user_exec 
23e6 23				inc hl 
23e7 71				ld (hl), c     ; poke address of user_exec 
23e8 23				inc hl 
23e9 70				ld (hl), b     
23ea			 ; 
23ea			;	inc hl 
23ea			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23ea			; 
23ea			; 
23ea			;	ld bc, macro_forth_rsp_next 
23ea			;	inc hl 
23ea			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23ea			;	inc hl 
23ea			;	ld (hl), b     
23ea			 ; 
23ea			;	inc hl 
23ea			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23ea			; 
23ea			; 
23ea			;	inc hl 
23ea			;	ld bc, forthexec 
23ea			;	ld (hl), c     ; poke address of forthexec 
23ea			;	inc hl 
23ea			;	ld (hl), b      
23ea			; 
23ea			;	inc hl 
23ea			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23ea			; 
23ea			;	ld bc, user_dict_next 
23ea			;	inc hl 
23ea			;	ld (hl), c     ; poke address of forthexec 
23ea			;	inc hl 
23ea			;	ld (hl), b      
23ea			 
23ea				; hl is now where we need to copy the word byte data to save this 
23ea			 
23ea 23				inc hl 
23eb 22 11 ee			ld (os_new_exec), hl 
23ee				 
23ee				; copy definition 
23ee			 
23ee eb				ex de, hl 
23ef			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23ef			;	inc de    ; skip the PC for this parse 
23ef 3a 19 ee			ld a, (os_new_parse_len) 
23f2 4f				ld c, a 
23f3 06 00			ld b, 0 
23f5 ed b0			ldir		 ; copy defintion 
23f7			 
23f7			 
23f7				; poke the address of where the new word bytes live for forthexec 
23f7			 
23f7 2a 0f ee			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23fa			 
23fa ed 5b 11 ee		ld de, (os_new_exec)      
23fe				 
23fe 73				ld (hl), e 
23ff 23				inc hl 
2400 72				ld (hl), d 
2401			 
2401					; TODO copy last user dict word next link to this word 
2401					; TODO update last user dict word to point to this word 
2401			; 
2401			; hl f923 de 812a ; bc 811a 
2401			 
2401			if DEBUG_FORTH_UWORD 
2401 c5				push bc 
2402 ed 4b 1b ee		ld bc, (os_new_malloc) 
2406						DMARK ":0A" 
2406 f5				push af  
2407 3a 1b 24			ld a, (.dmark)  
240a 32 77 fb			ld (debug_mark),a  
240d 3a 1c 24			ld a, (.dmark+1)  
2410 32 78 fb			ld (debug_mark+1),a  
2413 3a 1d 24			ld a, (.dmark+2)  
2416 32 79 fb			ld (debug_mark+2),a  
2419 18 03			jr .pastdmark  
241b ..			.dmark: db ":0A"  
241e f1			.pastdmark: pop af  
241f			endm  
# End of macro DMARK
241f				CALLMONITOR 
241f cd 74 17			call break_point_state  
2422				endm  
# End of macro CALLMONITOR
2422 c1				pop bc 
2423			endif 
2423			if DEBUG_FORTH_UWORD 
2423 c5				push bc 
2424 ed 4b 1b ee		ld bc, (os_new_malloc) 
2428 03				inc bc 
2429 03				inc bc 
242a 03				inc bc 
242b 03				inc bc 
242c 03				inc bc 
242d 03				inc bc 
242e 03				inc bc 
242f 03				inc bc 
2430			 
2430						DMARK ":0B" 
2430 f5				push af  
2431 3a 45 24			ld a, (.dmark)  
2434 32 77 fb			ld (debug_mark),a  
2437 3a 46 24			ld a, (.dmark+1)  
243a 32 78 fb			ld (debug_mark+1),a  
243d 3a 47 24			ld a, (.dmark+2)  
2440 32 79 fb			ld (debug_mark+2),a  
2443 18 03			jr .pastdmark  
2445 ..			.dmark: db ":0B"  
2448 f1			.pastdmark: pop af  
2449			endm  
# End of macro DMARK
2449				CALLMONITOR 
2449 cd 74 17			call break_point_state  
244c				endm  
# End of macro CALLMONITOR
244c c1				pop bc 
244d			endif 
244d			 
244d			; update word dict linked list for new word 
244d			 
244d			 
244d 2a 1a f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2450 23			inc hl     ; move to next work linked list ptr 
2451			 
2451 ed 5b 1b ee	ld de, (os_new_malloc)		 ; new next word 
2455 73			ld (hl), e 
2456 23			inc hl 
2457 72			ld (hl), d 
2458			 
2458			if DEBUG_FORTH_UWORD 
2458 ed 4b 1a f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
245c			endif 
245c			 
245c ed 53 1a f1	ld (os_last_new_uword), de      ; update last new uword ptr 
2460			 
2460			 
2460			if DEBUG_FORTH_UWORD 
2460						DMARK ":0+" 
2460 f5				push af  
2461 3a 75 24			ld a, (.dmark)  
2464 32 77 fb			ld (debug_mark),a  
2467 3a 76 24			ld a, (.dmark+1)  
246a 32 78 fb			ld (debug_mark+1),a  
246d 3a 77 24			ld a, (.dmark+2)  
2470 32 79 fb			ld (debug_mark+2),a  
2473 18 03			jr .pastdmark  
2475 ..			.dmark: db ":0+"  
2478 f1			.pastdmark: pop af  
2479			endm  
# End of macro DMARK
2479				CALLMONITOR 
2479 cd 74 17			call break_point_state  
247c				endm  
# End of macro CALLMONITOR
247c			endif 
247c			 
247c				STACKFRAMECHK OFF $8efe $989f 
247c				if DEBUG_STACK_IMB 
247c					if OFF 
247c						exx 
247c						ld hl, $989f 
247c						pop de   ; $989f 
247c						call cmp16 
247c						jr nz, .spnosame 
247c						ld hl, $8efe 
247c						pop de   ; $8efe 
247c						call cmp16 
247c						jr z, .spfrsame 
247c						.spnosame: call showsperror 
247c						.spfrsame: nop 
247c						exx 
247c					endif 
247c				endif 
247c			endm 
# End of macro STACKFRAMECHK
247c			 
247c c9			ret    ; dont process any remaining parser tokens as they form new word 
247d			 
247d			 
247d			 
247d			 
247d			;		NEXT 
247d			.SCOLN: 
247d			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
247d 06				db OPCODE_SCOLN 
247e c9 24			dw .DROP 
2480 02				db 2 
2481 .. 00			db ";",0           
2483			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2483					if DEBUG_FORTH_WORDS_KEY 
2483						DMARK "SCN" 
2483 f5				push af  
2484 3a 98 24			ld a, (.dmark)  
2487 32 77 fb			ld (debug_mark),a  
248a 3a 99 24			ld a, (.dmark+1)  
248d 32 78 fb			ld (debug_mark+1),a  
2490 3a 9a 24			ld a, (.dmark+2)  
2493 32 79 fb			ld (debug_mark+2),a  
2496 18 03			jr .pastdmark  
2498 ..			.dmark: db "SCN"  
249b f1			.pastdmark: pop af  
249c			endm  
# End of macro DMARK
249c						CALLMONITOR 
249c cd 74 17			call break_point_state  
249f				endm  
# End of macro CALLMONITOR
249f					endif 
249f					FORTH_RSP_TOS 
249f cd c2 1c			call macro_forth_rsp_tos 
24a2				endm 
# End of macro FORTH_RSP_TOS
24a2 e5					push hl 
24a3					FORTH_RSP_POP 
24a3 cd cc 1c			call macro_forth_rsp_pop 
24a6				endm 
# End of macro FORTH_RSP_POP
24a6 e1					pop hl 
24a7			;		ex de,hl 
24a7 22 1e f1				ld (os_tok_ptr),hl 
24aa			 
24aa			if DEBUG_FORTH_UWORD 
24aa						DMARK "SCL" 
24aa f5				push af  
24ab 3a bf 24			ld a, (.dmark)  
24ae 32 77 fb			ld (debug_mark),a  
24b1 3a c0 24			ld a, (.dmark+1)  
24b4 32 78 fb			ld (debug_mark+1),a  
24b7 3a c1 24			ld a, (.dmark+2)  
24ba 32 79 fb			ld (debug_mark+2),a  
24bd 18 03			jr .pastdmark  
24bf ..			.dmark: db "SCL"  
24c2 f1			.pastdmark: pop af  
24c3			endm  
# End of macro DMARK
24c3				CALLMONITOR 
24c3 cd 74 17			call break_point_state  
24c6				endm  
# End of macro CALLMONITOR
24c6			endif 
24c6					NEXTW 
24c6 c3 6d 20			jp macro_next 
24c9				endm 
# End of macro NEXTW
24c9			 
24c9			.DROP: 
24c9				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
24c9 1b				db WORD_SYS_CORE+OPCODE_DROP             
24ca f4 24			dw .DUP2            
24cc 05				db 4 + 1 
24cd .. 00			db "DROP",0              
24d2				endm 
# End of macro CWHEAD
24d2			; | DROP ( w -- )   drop the TOS item   | DONE 
24d2					if DEBUG_FORTH_WORDS_KEY 
24d2						DMARK "DRP" 
24d2 f5				push af  
24d3 3a e7 24			ld a, (.dmark)  
24d6 32 77 fb			ld (debug_mark),a  
24d9 3a e8 24			ld a, (.dmark+1)  
24dc 32 78 fb			ld (debug_mark+1),a  
24df 3a e9 24			ld a, (.dmark+2)  
24e2 32 79 fb			ld (debug_mark+2),a  
24e5 18 03			jr .pastdmark  
24e7 ..			.dmark: db "DRP"  
24ea f1			.pastdmark: pop af  
24eb			endm  
# End of macro DMARK
24eb						CALLMONITOR 
24eb cd 74 17			call break_point_state  
24ee				endm  
# End of macro CALLMONITOR
24ee					endif 
24ee					FORTH_DSP_POP 
24ee cd b3 1f			call macro_forth_dsp_pop 
24f1				endm 
# End of macro FORTH_DSP_POP
24f1					NEXTW 
24f1 c3 6d 20			jp macro_next 
24f4				endm 
# End of macro NEXTW
24f4			.DUP2: 
24f4				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24f4 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24f5 39 25			dw .DROP2            
24f7 05				db 4 + 1 
24f8 .. 00			db "2DUP",0              
24fd				endm 
# End of macro CWHEAD
24fd			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
24fd					if DEBUG_FORTH_WORDS_KEY 
24fd						DMARK "2DU" 
24fd f5				push af  
24fe 3a 12 25			ld a, (.dmark)  
2501 32 77 fb			ld (debug_mark),a  
2504 3a 13 25			ld a, (.dmark+1)  
2507 32 78 fb			ld (debug_mark+1),a  
250a 3a 14 25			ld a, (.dmark+2)  
250d 32 79 fb			ld (debug_mark+2),a  
2510 18 03			jr .pastdmark  
2512 ..			.dmark: db "2DU"  
2515 f1			.pastdmark: pop af  
2516			endm  
# End of macro DMARK
2516						CALLMONITOR 
2516 cd 74 17			call break_point_state  
2519				endm  
# End of macro CALLMONITOR
2519					endif 
2519					FORTH_DSP_VALUEHL 
2519 cd fb 1e			call macro_dsp_valuehl 
251c				endm 
# End of macro FORTH_DSP_VALUEHL
251c e5					push hl      ; 2 
251d			 
251d					FORTH_DSP_POP 
251d cd b3 1f			call macro_forth_dsp_pop 
2520				endm 
# End of macro FORTH_DSP_POP
2520					 
2520					FORTH_DSP_VALUEHL 
2520 cd fb 1e			call macro_dsp_valuehl 
2523				endm 
# End of macro FORTH_DSP_VALUEHL
2523			;		push hl      ; 1 
2523			 
2523					FORTH_DSP_POP 
2523 cd b3 1f			call macro_forth_dsp_pop 
2526				endm 
# End of macro FORTH_DSP_POP
2526			 
2526			;		pop hl       ; 1 
2526 d1					pop de       ; 2 
2527			 
2527 cd 04 1d				call forth_push_numhl 
252a eb					ex de, hl 
252b cd 04 1d				call forth_push_numhl 
252e			 
252e					 
252e eb					ex de, hl 
252f			 
252f cd 04 1d				call forth_push_numhl 
2532 eb					ex de, hl 
2533 cd 04 1d				call forth_push_numhl 
2536			 
2536			 
2536					NEXTW 
2536 c3 6d 20			jp macro_next 
2539				endm 
# End of macro NEXTW
2539			.DROP2: 
2539				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2539 1d				db WORD_SYS_CORE+OPCODE_DROP2             
253a 68 25			dw .SWAP2            
253c 06				db 5 + 1 
253d .. 00			db "2DROP",0              
2543				endm 
# End of macro CWHEAD
2543			; | 2DROP ( w w -- )    Double drop | DONE 
2543					if DEBUG_FORTH_WORDS_KEY 
2543						DMARK "2DR" 
2543 f5				push af  
2544 3a 58 25			ld a, (.dmark)  
2547 32 77 fb			ld (debug_mark),a  
254a 3a 59 25			ld a, (.dmark+1)  
254d 32 78 fb			ld (debug_mark+1),a  
2550 3a 5a 25			ld a, (.dmark+2)  
2553 32 79 fb			ld (debug_mark+2),a  
2556 18 03			jr .pastdmark  
2558 ..			.dmark: db "2DR"  
255b f1			.pastdmark: pop af  
255c			endm  
# End of macro DMARK
255c						CALLMONITOR 
255c cd 74 17			call break_point_state  
255f				endm  
# End of macro CALLMONITOR
255f					endif 
255f					FORTH_DSP_POP 
255f cd b3 1f			call macro_forth_dsp_pop 
2562				endm 
# End of macro FORTH_DSP_POP
2562					FORTH_DSP_POP 
2562 cd b3 1f			call macro_forth_dsp_pop 
2565				endm 
# End of macro FORTH_DSP_POP
2565					NEXTW 
2565 c3 6d 20			jp macro_next 
2568				endm 
# End of macro NEXTW
2568			.SWAP2: 
2568				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2568 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2569 91 25			dw .AT            
256b 06				db 5 + 1 
256c .. 00			db "2SWAP",0              
2572				endm 
# End of macro CWHEAD
2572			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2572					if DEBUG_FORTH_WORDS_KEY 
2572						DMARK "2SW" 
2572 f5				push af  
2573 3a 87 25			ld a, (.dmark)  
2576 32 77 fb			ld (debug_mark),a  
2579 3a 88 25			ld a, (.dmark+1)  
257c 32 78 fb			ld (debug_mark+1),a  
257f 3a 89 25			ld a, (.dmark+2)  
2582 32 79 fb			ld (debug_mark+2),a  
2585 18 03			jr .pastdmark  
2587 ..			.dmark: db "2SW"  
258a f1			.pastdmark: pop af  
258b			endm  
# End of macro DMARK
258b						CALLMONITOR 
258b cd 74 17			call break_point_state  
258e				endm  
# End of macro CALLMONITOR
258e					endif 
258e					NEXTW 
258e c3 6d 20			jp macro_next 
2591				endm 
# End of macro NEXTW
2591			.AT: 
2591				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2591 1f				db WORD_SYS_CORE+OPCODE_AT             
2592 c3 25			dw .CAT            
2594 02				db 1 + 1 
2595 .. 00			db "@",0              
2597				endm 
# End of macro CWHEAD
2597			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2597			 
2597					if DEBUG_FORTH_WORDS_KEY 
2597						DMARK "AT." 
2597 f5				push af  
2598 3a ac 25			ld a, (.dmark)  
259b 32 77 fb			ld (debug_mark),a  
259e 3a ad 25			ld a, (.dmark+1)  
25a1 32 78 fb			ld (debug_mark+1),a  
25a4 3a ae 25			ld a, (.dmark+2)  
25a7 32 79 fb			ld (debug_mark+2),a  
25aa 18 03			jr .pastdmark  
25ac ..			.dmark: db "AT."  
25af f1			.pastdmark: pop af  
25b0			endm  
# End of macro DMARK
25b0						CALLMONITOR 
25b0 cd 74 17			call break_point_state  
25b3				endm  
# End of macro CALLMONITOR
25b3					endif 
25b3			.getbyteat:	 
25b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25b3 cd fb 1e			call macro_dsp_valuehl 
25b6				endm 
# End of macro FORTH_DSP_VALUEHL
25b6					 
25b6			;		push hl 
25b6				 
25b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25b6 cd b3 1f			call macro_forth_dsp_pop 
25b9				endm 
# End of macro FORTH_DSP_POP
25b9			 
25b9			;		pop hl 
25b9			 
25b9 7e					ld a, (hl) 
25ba			 
25ba 6f					ld l, a 
25bb 26 00				ld h, 0 
25bd cd 04 1d				call forth_push_numhl 
25c0			 
25c0					NEXTW 
25c0 c3 6d 20			jp macro_next 
25c3				endm 
# End of macro NEXTW
25c3			.CAT: 
25c3				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
25c3 20				db WORD_SYS_CORE+OPCODE_CAT             
25c4 ec 25			dw .BANG            
25c6 03				db 2 + 1 
25c7 .. 00			db "C@",0              
25ca				endm 
# End of macro CWHEAD
25ca			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
25ca					if DEBUG_FORTH_WORDS_KEY 
25ca						DMARK "CAA" 
25ca f5				push af  
25cb 3a df 25			ld a, (.dmark)  
25ce 32 77 fb			ld (debug_mark),a  
25d1 3a e0 25			ld a, (.dmark+1)  
25d4 32 78 fb			ld (debug_mark+1),a  
25d7 3a e1 25			ld a, (.dmark+2)  
25da 32 79 fb			ld (debug_mark+2),a  
25dd 18 03			jr .pastdmark  
25df ..			.dmark: db "CAA"  
25e2 f1			.pastdmark: pop af  
25e3			endm  
# End of macro DMARK
25e3						CALLMONITOR 
25e3 cd 74 17			call break_point_state  
25e6				endm  
# End of macro CALLMONITOR
25e6					endif 
25e6 c3 b3 25				jp .getbyteat 
25e9					NEXTW 
25e9 c3 6d 20			jp macro_next 
25ec				endm 
# End of macro NEXTW
25ec			.BANG: 
25ec				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25ec 21				db WORD_SYS_CORE+OPCODE_BANG             
25ed 22 26			dw .CBANG            
25ef 02				db 1 + 1 
25f0 .. 00			db "!",0              
25f2				endm 
# End of macro CWHEAD
25f2			; | ! ( x w -- ) Store x at address w      | DONE 
25f2					if DEBUG_FORTH_WORDS_KEY 
25f2						DMARK "BNG" 
25f2 f5				push af  
25f3 3a 07 26			ld a, (.dmark)  
25f6 32 77 fb			ld (debug_mark),a  
25f9 3a 08 26			ld a, (.dmark+1)  
25fc 32 78 fb			ld (debug_mark+1),a  
25ff 3a 09 26			ld a, (.dmark+2)  
2602 32 79 fb			ld (debug_mark+2),a  
2605 18 03			jr .pastdmark  
2607 ..			.dmark: db "BNG"  
260a f1			.pastdmark: pop af  
260b			endm  
# End of macro DMARK
260b						CALLMONITOR 
260b cd 74 17			call break_point_state  
260e				endm  
# End of macro CALLMONITOR
260e					endif 
260e			 
260e			.storebyteat:		 
260e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
260e cd fb 1e			call macro_dsp_valuehl 
2611				endm 
# End of macro FORTH_DSP_VALUEHL
2611					 
2611 e5					push hl 
2612				 
2612					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2612 cd b3 1f			call macro_forth_dsp_pop 
2615				endm 
# End of macro FORTH_DSP_POP
2615			 
2615					; get byte to poke 
2615			 
2615					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2615 cd fb 1e			call macro_dsp_valuehl 
2618				endm 
# End of macro FORTH_DSP_VALUEHL
2618 e5					push hl 
2619			 
2619			 
2619					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2619 cd b3 1f			call macro_forth_dsp_pop 
261c				endm 
# End of macro FORTH_DSP_POP
261c			 
261c			 
261c d1					pop de 
261d e1					pop hl 
261e			 
261e 73					ld (hl),e 
261f			 
261f			 
261f					NEXTW 
261f c3 6d 20			jp macro_next 
2622				endm 
# End of macro NEXTW
2622			.CBANG: 
2622				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2622 22				db WORD_SYS_CORE+OPCODE_CBANG             
2623 4b 26			dw .SCALL            
2625 03				db 2 + 1 
2626 .. 00			db "C!",0              
2629				endm 
# End of macro CWHEAD
2629			; | C!  ( x w -- ) Store x at address w  | DONE 
2629					if DEBUG_FORTH_WORDS_KEY 
2629						DMARK "CBA" 
2629 f5				push af  
262a 3a 3e 26			ld a, (.dmark)  
262d 32 77 fb			ld (debug_mark),a  
2630 3a 3f 26			ld a, (.dmark+1)  
2633 32 78 fb			ld (debug_mark+1),a  
2636 3a 40 26			ld a, (.dmark+2)  
2639 32 79 fb			ld (debug_mark+2),a  
263c 18 03			jr .pastdmark  
263e ..			.dmark: db "CBA"  
2641 f1			.pastdmark: pop af  
2642			endm  
# End of macro DMARK
2642						CALLMONITOR 
2642 cd 74 17			call break_point_state  
2645				endm  
# End of macro CALLMONITOR
2645					endif 
2645 c3 0e 26				jp .storebyteat 
2648					NEXTW 
2648 c3 6d 20			jp macro_next 
264b				endm 
# End of macro NEXTW
264b			.SCALL: 
264b				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
264b 23				db WORD_SYS_CORE+OPCODE_SCALL             
264c 7f 26			dw .DEPTH            
264e 05				db 4 + 1 
264f .. 00			db "CALL",0              
2654				endm 
# End of macro CWHEAD
2654			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2654					if DEBUG_FORTH_WORDS_KEY 
2654						DMARK "CLL" 
2654 f5				push af  
2655 3a 69 26			ld a, (.dmark)  
2658 32 77 fb			ld (debug_mark),a  
265b 3a 6a 26			ld a, (.dmark+1)  
265e 32 78 fb			ld (debug_mark+1),a  
2661 3a 6b 26			ld a, (.dmark+2)  
2664 32 79 fb			ld (debug_mark+2),a  
2667 18 03			jr .pastdmark  
2669 ..			.dmark: db "CLL"  
266c f1			.pastdmark: pop af  
266d			endm  
# End of macro DMARK
266d						CALLMONITOR 
266d cd 74 17			call break_point_state  
2670				endm  
# End of macro CALLMONITOR
2670					endif 
2670			 
2670					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2670 cd fb 1e			call macro_dsp_valuehl 
2673				endm 
# End of macro FORTH_DSP_VALUEHL
2673			 
2673			;		push hl 
2673			 
2673					; destroy value TOS 
2673			 
2673					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2673 cd b3 1f			call macro_forth_dsp_pop 
2676				endm 
# End of macro FORTH_DSP_POP
2676			 
2676						 
2676			;		pop hl 
2676			 
2676					; how to do a call with hl???? save SP? 
2676 cd 16 20				call forth_call_hl 
2679			 
2679			 
2679					; TODO push value back onto stack for another op etc 
2679			 
2679 cd 04 1d				call forth_push_numhl 
267c					NEXTW 
267c c3 6d 20			jp macro_next 
267f				endm 
# End of macro NEXTW
267f			.DEPTH: 
267f				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
267f 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2680 bc 26			dw .OVER            
2682 06				db 5 + 1 
2683 .. 00			db "DEPTH",0              
2689				endm 
# End of macro CWHEAD
2689			; | DEPTH ( -- u ) Push count of stack | DONE 
2689					; take current TOS and remove from base value div by two to get count 
2689					if DEBUG_FORTH_WORDS_KEY 
2689						DMARK "DEP" 
2689 f5				push af  
268a 3a 9e 26			ld a, (.dmark)  
268d 32 77 fb			ld (debug_mark),a  
2690 3a 9f 26			ld a, (.dmark+1)  
2693 32 78 fb			ld (debug_mark+1),a  
2696 3a a0 26			ld a, (.dmark+2)  
2699 32 79 fb			ld (debug_mark+2),a  
269c 18 03			jr .pastdmark  
269e ..			.dmark: db "DEP"  
26a1 f1			.pastdmark: pop af  
26a2			endm  
# End of macro DMARK
26a2						CALLMONITOR 
26a2 cd 74 17			call break_point_state  
26a5				endm  
# End of macro CALLMONITOR
26a5					endif 
26a5			 
26a5			 
26a5 2a 0a f8			ld hl, (cli_data_sp) 
26a8 11 84 f3			ld de, cli_data_stack 
26ab ed 52			sbc hl,de 
26ad				 
26ad				; div by size of stack item 
26ad			 
26ad 5d				ld e,l 
26ae 0e 03			ld c, 3 
26b0 cd b0 0c			call Div8 
26b3			 
26b3 6f				ld l,a 
26b4 26 00			ld h,0 
26b6			 
26b6				;srl h 
26b6				;rr l 
26b6			 
26b6 cd 04 1d				call forth_push_numhl 
26b9					NEXTW 
26b9 c3 6d 20			jp macro_next 
26bc				endm 
# End of macro NEXTW
26bc			.OVER: 
26bc				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
26bc 42				db WORD_SYS_CORE+46             
26bd 03 27			dw .PAUSE            
26bf 05				db 4 + 1 
26c0 .. 00			db "OVER",0              
26c5				endm 
# End of macro CWHEAD
26c5			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
26c5					if DEBUG_FORTH_WORDS_KEY 
26c5						DMARK "OVR" 
26c5 f5				push af  
26c6 3a da 26			ld a, (.dmark)  
26c9 32 77 fb			ld (debug_mark),a  
26cc 3a db 26			ld a, (.dmark+1)  
26cf 32 78 fb			ld (debug_mark+1),a  
26d2 3a dc 26			ld a, (.dmark+2)  
26d5 32 79 fb			ld (debug_mark+2),a  
26d8 18 03			jr .pastdmark  
26da ..			.dmark: db "OVR"  
26dd f1			.pastdmark: pop af  
26de			endm  
# End of macro DMARK
26de						CALLMONITOR 
26de cd 74 17			call break_point_state  
26e1				endm  
# End of macro CALLMONITOR
26e1					endif 
26e1			 
26e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e1 cd fb 1e			call macro_dsp_valuehl 
26e4				endm 
# End of macro FORTH_DSP_VALUEHL
26e4 e5					push hl    ; n2 
26e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26e5 cd b3 1f			call macro_forth_dsp_pop 
26e8				endm 
# End of macro FORTH_DSP_POP
26e8			 
26e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e8 cd fb 1e			call macro_dsp_valuehl 
26eb				endm 
# End of macro FORTH_DSP_VALUEHL
26eb e5					push hl    ; n1 
26ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26ec cd b3 1f			call macro_forth_dsp_pop 
26ef				endm 
# End of macro FORTH_DSP_POP
26ef			 
26ef d1					pop de     ; n1 
26f0 e1					pop hl     ; n2 
26f1			 
26f1 d5					push de 
26f2 e5					push hl 
26f3 d5					push de 
26f4			 
26f4					; push back  
26f4			 
26f4 e1					pop hl 
26f5 cd 04 1d				call forth_push_numhl 
26f8 e1					pop hl 
26f9 cd 04 1d				call forth_push_numhl 
26fc e1					pop hl 
26fd cd 04 1d				call forth_push_numhl 
2700					NEXTW 
2700 c3 6d 20			jp macro_next 
2703				endm 
# End of macro NEXTW
2703			 
2703			.PAUSE: 
2703				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2703 43				db WORD_SYS_CORE+47             
2704 38 27			dw .PAUSES            
2706 08				db 7 + 1 
2707 .. 00			db "PAUSEMS",0              
270f				endm 
# End of macro CWHEAD
270f			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
270f					if DEBUG_FORTH_WORDS_KEY 
270f						DMARK "PMS" 
270f f5				push af  
2710 3a 24 27			ld a, (.dmark)  
2713 32 77 fb			ld (debug_mark),a  
2716 3a 25 27			ld a, (.dmark+1)  
2719 32 78 fb			ld (debug_mark+1),a  
271c 3a 26 27			ld a, (.dmark+2)  
271f 32 79 fb			ld (debug_mark+2),a  
2722 18 03			jr .pastdmark  
2724 ..			.dmark: db "PMS"  
2727 f1			.pastdmark: pop af  
2728			endm  
# End of macro DMARK
2728						CALLMONITOR 
2728 cd 74 17			call break_point_state  
272b				endm  
# End of macro CALLMONITOR
272b					endif 
272b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
272b cd fb 1e			call macro_dsp_valuehl 
272e				endm 
# End of macro FORTH_DSP_VALUEHL
272e			;		push hl    ; n2 
272e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
272e cd b3 1f			call macro_forth_dsp_pop 
2731				endm 
# End of macro FORTH_DSP_POP
2731			;		pop hl 
2731			 
2731 7d					ld a, l 
2732 cd 4e 0a				call aDelayInMS 
2735				       NEXTW 
2735 c3 6d 20			jp macro_next 
2738				endm 
# End of macro NEXTW
2738			.PAUSES:  
2738				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2738 44				db WORD_SYS_CORE+48             
2739 a7 27			dw .ROT            
273b 06				db 5 + 1 
273c .. 00			db "PAUSE",0              
2742				endm 
# End of macro CWHEAD
2742			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2742					if DEBUG_FORTH_WORDS_KEY 
2742						DMARK "PAU" 
2742 f5				push af  
2743 3a 57 27			ld a, (.dmark)  
2746 32 77 fb			ld (debug_mark),a  
2749 3a 58 27			ld a, (.dmark+1)  
274c 32 78 fb			ld (debug_mark+1),a  
274f 3a 59 27			ld a, (.dmark+2)  
2752 32 79 fb			ld (debug_mark+2),a  
2755 18 03			jr .pastdmark  
2757 ..			.dmark: db "PAU"  
275a f1			.pastdmark: pop af  
275b			endm  
# End of macro DMARK
275b						CALLMONITOR 
275b cd 74 17			call break_point_state  
275e				endm  
# End of macro CALLMONITOR
275e					endif 
275e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
275e cd fb 1e			call macro_dsp_valuehl 
2761				endm 
# End of macro FORTH_DSP_VALUEHL
2761			;		push hl    ; n2 
2761					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2761 cd b3 1f			call macro_forth_dsp_pop 
2764				endm 
# End of macro FORTH_DSP_POP
2764			;		pop hl 
2764 45					ld b, l 
2765					if DEBUG_FORTH_WORDS 
2765						DMARK "PAU" 
2765 f5				push af  
2766 3a 7a 27			ld a, (.dmark)  
2769 32 77 fb			ld (debug_mark),a  
276c 3a 7b 27			ld a, (.dmark+1)  
276f 32 78 fb			ld (debug_mark+1),a  
2772 3a 7c 27			ld a, (.dmark+2)  
2775 32 79 fb			ld (debug_mark+2),a  
2778 18 03			jr .pastdmark  
277a ..			.dmark: db "PAU"  
277d f1			.pastdmark: pop af  
277e			endm  
# End of macro DMARK
277e						CALLMONITOR 
277e cd 74 17			call break_point_state  
2781				endm  
# End of macro CALLMONITOR
2781					endif 
2781 c5			.pauses1:	push bc 
2782 cd 69 0a				call delay1s 
2785 c1					pop bc 
2786					if DEBUG_FORTH_WORDS 
2786						DMARK "PA1" 
2786 f5				push af  
2787 3a 9b 27			ld a, (.dmark)  
278a 32 77 fb			ld (debug_mark),a  
278d 3a 9c 27			ld a, (.dmark+1)  
2790 32 78 fb			ld (debug_mark+1),a  
2793 3a 9d 27			ld a, (.dmark+2)  
2796 32 79 fb			ld (debug_mark+2),a  
2799 18 03			jr .pastdmark  
279b ..			.dmark: db "PA1"  
279e f1			.pastdmark: pop af  
279f			endm  
# End of macro DMARK
279f						CALLMONITOR 
279f cd 74 17			call break_point_state  
27a2				endm  
# End of macro CALLMONITOR
27a2					endif 
27a2 10 dd				djnz .pauses1 
27a4			 
27a4				       NEXTW 
27a4 c3 6d 20			jp macro_next 
27a7				endm 
# End of macro NEXTW
27a7			.ROT: 
27a7				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
27a7 45				db WORD_SYS_CORE+49             
27a8 f5 27			dw .UWORDS            
27aa 04				db 3 + 1 
27ab .. 00			db "ROT",0              
27af				endm 
# End of macro CWHEAD
27af			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
27af					if DEBUG_FORTH_WORDS_KEY 
27af						DMARK "ROT" 
27af f5				push af  
27b0 3a c4 27			ld a, (.dmark)  
27b3 32 77 fb			ld (debug_mark),a  
27b6 3a c5 27			ld a, (.dmark+1)  
27b9 32 78 fb			ld (debug_mark+1),a  
27bc 3a c6 27			ld a, (.dmark+2)  
27bf 32 79 fb			ld (debug_mark+2),a  
27c2 18 03			jr .pastdmark  
27c4 ..			.dmark: db "ROT"  
27c7 f1			.pastdmark: pop af  
27c8			endm  
# End of macro DMARK
27c8						CALLMONITOR 
27c8 cd 74 17			call break_point_state  
27cb				endm  
# End of macro CALLMONITOR
27cb					endif 
27cb			 
27cb					FORTH_DSP_VALUEHL 
27cb cd fb 1e			call macro_dsp_valuehl 
27ce				endm 
# End of macro FORTH_DSP_VALUEHL
27ce e5					push hl    ; u3  
27cf			 
27cf					FORTH_DSP_POP 
27cf cd b3 1f			call macro_forth_dsp_pop 
27d2				endm 
# End of macro FORTH_DSP_POP
27d2			   
27d2					FORTH_DSP_VALUEHL 
27d2 cd fb 1e			call macro_dsp_valuehl 
27d5				endm 
# End of macro FORTH_DSP_VALUEHL
27d5 e5					push hl     ; u2 
27d6			 
27d6					FORTH_DSP_POP 
27d6 cd b3 1f			call macro_forth_dsp_pop 
27d9				endm 
# End of macro FORTH_DSP_POP
27d9			 
27d9					FORTH_DSP_VALUEHL 
27d9 cd fb 1e			call macro_dsp_valuehl 
27dc				endm 
# End of macro FORTH_DSP_VALUEHL
27dc e5					push hl     ; u1 
27dd			 
27dd					FORTH_DSP_POP 
27dd cd b3 1f			call macro_forth_dsp_pop 
27e0				endm 
# End of macro FORTH_DSP_POP
27e0			 
27e0 c1					pop bc      ; u1 
27e1 e1					pop hl      ; u2 
27e2 d1					pop de      ; u3 
27e3			 
27e3			 
27e3 c5					push bc 
27e4 d5					push de 
27e5 e5					push hl 
27e6			 
27e6			 
27e6 e1					pop hl 
27e7 cd 04 1d				call forth_push_numhl 
27ea			 
27ea e1					pop hl 
27eb cd 04 1d				call forth_push_numhl 
27ee			 
27ee e1					pop hl 
27ef cd 04 1d				call forth_push_numhl 
27f2					 
27f2			 
27f2			 
27f2			 
27f2			 
27f2			 
27f2				       NEXTW 
27f2 c3 6d 20			jp macro_next 
27f5				endm 
# End of macro NEXTW
27f5			 
27f5			.UWORDS: 
27f5				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
27f5 50				db WORD_SYS_CORE+60             
27f6 b7 28			dw .BP            
27f8 07				db 6 + 1 
27f9 .. 00			db "UWORDS",0              
2800				endm 
# End of macro CWHEAD
2800			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2800			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2800			; | | Following the count are the individual words. 
2800			; | | 
2800			; | | e.g. UWORDS 
2800			; | | BOX DIRLIST 2 
2800			; | |  
2800			; | | Can be used to save the words to storage via: 
2800			; | | UWORDS $01 DO $01 APPEND LOOP 
2800				if DEBUG_FORTH_WORDS_KEY 
2800					DMARK "UWR" 
2800 f5				push af  
2801 3a 15 28			ld a, (.dmark)  
2804 32 77 fb			ld (debug_mark),a  
2807 3a 16 28			ld a, (.dmark+1)  
280a 32 78 fb			ld (debug_mark+1),a  
280d 3a 17 28			ld a, (.dmark+2)  
2810 32 79 fb			ld (debug_mark+2),a  
2813 18 03			jr .pastdmark  
2815 ..			.dmark: db "UWR"  
2818 f1			.pastdmark: pop af  
2819			endm  
# End of macro DMARK
2819					CALLMONITOR 
2819 cd 74 17			call break_point_state  
281c				endm  
# End of macro CALLMONITOR
281c				endif 
281c 21 00 80				ld hl, baseram 
281f					;ld hl, baseusermem 
281f 01 00 00				ld bc, 0    ; start a counter 
2822			 
2822				; skip dict stub 
2822			 
2822 cd be 21				call forth_tok_next 
2825			 
2825			 
2825			; while we have words to look for 
2825			 
2825 7e			.douscan:	ld a, (hl)      
2826				if DEBUG_FORTH_WORDS 
2826					DMARK "UWs" 
2826 f5				push af  
2827 3a 3b 28			ld a, (.dmark)  
282a 32 77 fb			ld (debug_mark),a  
282d 3a 3c 28			ld a, (.dmark+1)  
2830 32 78 fb			ld (debug_mark+1),a  
2833 3a 3d 28			ld a, (.dmark+2)  
2836 32 79 fb			ld (debug_mark+2),a  
2839 18 03			jr .pastdmark  
283b ..			.dmark: db "UWs"  
283e f1			.pastdmark: pop af  
283f			endm  
# End of macro DMARK
283f					CALLMONITOR 
283f cd 74 17			call break_point_state  
2842				endm  
# End of macro CALLMONITOR
2842				endif 
2842 fe 00				cp WORD_SYS_END 
2844 28 4d				jr z, .udone 
2846 fe 01				cp WORD_SYS_UWORD 
2848 20 44				jr nz, .nuword 
284a			 
284a				if DEBUG_FORTH_WORDS 
284a					DMARK "UWu" 
284a f5				push af  
284b 3a 5f 28			ld a, (.dmark)  
284e 32 77 fb			ld (debug_mark),a  
2851 3a 60 28			ld a, (.dmark+1)  
2854 32 78 fb			ld (debug_mark+1),a  
2857 3a 61 28			ld a, (.dmark+2)  
285a 32 79 fb			ld (debug_mark+2),a  
285d 18 03			jr .pastdmark  
285f ..			.dmark: db "UWu"  
2862 f1			.pastdmark: pop af  
2863			endm  
# End of macro DMARK
2863					CALLMONITOR 
2863 cd 74 17			call break_point_state  
2866				endm  
# End of macro CALLMONITOR
2866				endif 
2866					; we have a uword so push its name to the stack 
2866			 
2866 e5				   	push hl  ; save so we can move to next dict block 
2867			 
2867					; skip opcode 
2867 23					inc hl  
2868					; skip next ptr 
2868 23					inc hl  
2869 23					inc hl 
286a					; skip len 
286a 23					inc hl 
286b				if DEBUG_FORTH_WORDS 
286b					DMARK "UWt" 
286b f5				push af  
286c 3a 80 28			ld a, (.dmark)  
286f 32 77 fb			ld (debug_mark),a  
2872 3a 81 28			ld a, (.dmark+1)  
2875 32 78 fb			ld (debug_mark+1),a  
2878 3a 82 28			ld a, (.dmark+2)  
287b 32 79 fb			ld (debug_mark+2),a  
287e 18 03			jr .pastdmark  
2880 ..			.dmark: db "UWt"  
2883 f1			.pastdmark: pop af  
2884			endm  
# End of macro DMARK
2884					CALLMONITOR 
2884 cd 74 17			call break_point_state  
2887				endm  
# End of macro CALLMONITOR
2887				endif 
2887 03					inc bc 
2888			 
2888 c5					push bc 
2889 cd 72 1d				call forth_push_str 
288c c1					pop bc 
288d			 
288d e1					pop hl 	 
288e			 
288e cd be 21		.nuword:	call forth_tok_next 
2891 18 92				jr .douscan  
2893			 
2893			.udone:		 ; push count of uwords found 
2893 c5					push bc 
2894 e1					pop hl 
2895			 
2895				if DEBUG_FORTH_WORDS 
2895					DMARK "UWc" 
2895 f5				push af  
2896 3a aa 28			ld a, (.dmark)  
2899 32 77 fb			ld (debug_mark),a  
289c 3a ab 28			ld a, (.dmark+1)  
289f 32 78 fb			ld (debug_mark+1),a  
28a2 3a ac 28			ld a, (.dmark+2)  
28a5 32 79 fb			ld (debug_mark+2),a  
28a8 18 03			jr .pastdmark  
28aa ..			.dmark: db "UWc"  
28ad f1			.pastdmark: pop af  
28ae			endm  
# End of macro DMARK
28ae					CALLMONITOR 
28ae cd 74 17			call break_point_state  
28b1				endm  
# End of macro CALLMONITOR
28b1				endif 
28b1 cd 04 1d				call forth_push_numhl 
28b4			 
28b4			 
28b4				       NEXTW 
28b4 c3 6d 20			jp macro_next 
28b7				endm 
# End of macro NEXTW
28b7			 
28b7			.BP: 
28b7				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
28b7 54				db WORD_SYS_CORE+64             
28b8 ed 28			dw .MONITOR            
28ba 03				db 2 + 1 
28bb .. 00			db "BP",0              
28be				endm 
# End of macro CWHEAD
28be			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
28be			; | | $00 Will enable the break points within specific code paths 
28be			; | | $01 Will disable break points 
28be			; | |  
28be			; | | By default break points are off. Either the above can be used to enable them 
28be			; | | or if a key is held down during start up the spashscreen will appear to freeze 
28be			; | | and on release of the pressed key a message will be disaplayed to notify 
28be			; | | that break points are enabled. Pressing any key will then continue boot process. 
28be					; get byte count 
28be					if DEBUG_FORTH_WORDS_KEY 
28be						DMARK "BP." 
28be f5				push af  
28bf 3a d3 28			ld a, (.dmark)  
28c2 32 77 fb			ld (debug_mark),a  
28c5 3a d4 28			ld a, (.dmark+1)  
28c8 32 78 fb			ld (debug_mark+1),a  
28cb 3a d5 28			ld a, (.dmark+2)  
28ce 32 79 fb			ld (debug_mark+2),a  
28d1 18 03			jr .pastdmark  
28d3 ..			.dmark: db "BP."  
28d6 f1			.pastdmark: pop af  
28d7			endm  
# End of macro DMARK
28d7						CALLMONITOR 
28d7 cd 74 17			call break_point_state  
28da				endm  
# End of macro CALLMONITOR
28da					endif 
28da			 
28da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28da cd fb 1e			call macro_dsp_valuehl 
28dd				endm 
# End of macro FORTH_DSP_VALUEHL
28dd			 
28dd			;		push hl 
28dd			 
28dd					; destroy value TOS 
28dd			 
28dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28dd cd b3 1f			call macro_forth_dsp_pop 
28e0				endm 
# End of macro FORTH_DSP_POP
28e0			 
28e0			;		pop hl 
28e0			 
28e0 3e 00				ld a,0 
28e2 bd					cp l 
28e3 28 02				jr z, .bpset 
28e5 3e 2a				ld a, '*' 
28e7			 
28e7 32 0e ee		.bpset:		ld (os_view_disable), a 
28ea			 
28ea			 
28ea					NEXTW 
28ea c3 6d 20			jp macro_next 
28ed				endm 
# End of macro NEXTW
28ed			 
28ed			 
28ed			.MONITOR: 
28ed				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
28ed 55				db WORD_SYS_CORE+65             
28ee 20 29			dw .MALLOC            
28f0 08				db 7 + 1 
28f1 .. 00			db "MONITOR",0              
28f9				endm 
# End of macro CWHEAD
28f9			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28f9			; | | At start the current various registers will be displayed with contents. 
28f9			; | | Top right corner will show the most recent debug marker seen. 
28f9			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28f9			; | | and the return stack pointer (RSP). 
28f9			; | | Pressing: 
28f9			; | |    1 - Initial screen 
28f9			; | |    2 - Display a data dump of HL 
28f9			; | |    3 - Display a data dump of DE 
28f9			; | |    4 - Display a data dump of BC 
28f9			; | |    5 - Display a data dump of HL 
28f9			; | |    6 - Display a data dump of DSP 
28f9			; | |    7 - Display a data dump of RSP 
28f9			; | |    8 - Display a data dump of what is at DSP 
28f9			; | |    9 - Display a data dump of what is at RSP 
28f9			; | |    0 - Exit monitor and continue running. This will also enable break points 
28f9			; | |    * - Disable break points 
28f9			; | |    # - Enter traditional monitor mode 
28f9			; | | 
28f9			; | | Monitor Mode 
28f9			; | | ------------ 
28f9			; | | A prompt of '>' will be shown for various commands: 
28f9			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28f9			; | |    C - Continue display a data dump from the last set address 
28f9			; | |    M xxxx - Set start of memory edit at address xx 
28f9			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28f9			; | |    Q - Return to previous 
28f9					if DEBUG_FORTH_WORDS_KEY 
28f9						DMARK "MON" 
28f9 f5				push af  
28fa 3a 0e 29			ld a, (.dmark)  
28fd 32 77 fb			ld (debug_mark),a  
2900 3a 0f 29			ld a, (.dmark+1)  
2903 32 78 fb			ld (debug_mark+1),a  
2906 3a 10 29			ld a, (.dmark+2)  
2909 32 79 fb			ld (debug_mark+2),a  
290c 18 03			jr .pastdmark  
290e ..			.dmark: db "MON"  
2911 f1			.pastdmark: pop af  
2912			endm  
# End of macro DMARK
2912						CALLMONITOR 
2912 cd 74 17			call break_point_state  
2915				endm  
# End of macro CALLMONITOR
2915					endif 
2915 3e 00				ld a, 0 
2917 32 0e ee				ld (os_view_disable), a 
291a			 
291a					CALLMONITOR 
291a cd 74 17			call break_point_state  
291d				endm  
# End of macro CALLMONITOR
291d			 
291d			;	call monitor 
291d			 
291d					NEXTW 
291d c3 6d 20			jp macro_next 
2920				endm 
# End of macro NEXTW
2920			 
2920			 
2920			.MALLOC: 
2920				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2920 56				db WORD_SYS_CORE+66             
2921 49 29			dw .MALLOC2            
2923 06				db 5 + 1 
2924 .. 00			db "ALLOT",0              
292a				endm 
# End of macro CWHEAD
292a			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
292a					if DEBUG_FORTH_WORDS_KEY 
292a						DMARK "ALL" 
292a f5				push af  
292b 3a 3f 29			ld a, (.dmark)  
292e 32 77 fb			ld (debug_mark),a  
2931 3a 40 29			ld a, (.dmark+1)  
2934 32 78 fb			ld (debug_mark+1),a  
2937 3a 41 29			ld a, (.dmark+2)  
293a 32 79 fb			ld (debug_mark+2),a  
293d 18 03			jr .pastdmark  
293f ..			.dmark: db "ALL"  
2942 f1			.pastdmark: pop af  
2943			endm  
# End of macro DMARK
2943						CALLMONITOR 
2943 cd 74 17			call break_point_state  
2946				endm  
# End of macro CALLMONITOR
2946					endif 
2946 c3 70 29				jp .mallocc 
2949			.MALLOC2: 
2949				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2949 56				db WORD_SYS_CORE+66             
294a 87 29			dw .FREE            
294c 07				db 6 + 1 
294d .. 00			db "MALLOC",0              
2954				endm 
# End of macro CWHEAD
2954			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2954					; get byte count 
2954					if DEBUG_FORTH_WORDS_KEY 
2954						DMARK "MAL" 
2954 f5				push af  
2955 3a 69 29			ld a, (.dmark)  
2958 32 77 fb			ld (debug_mark),a  
295b 3a 6a 29			ld a, (.dmark+1)  
295e 32 78 fb			ld (debug_mark+1),a  
2961 3a 6b 29			ld a, (.dmark+2)  
2964 32 79 fb			ld (debug_mark+2),a  
2967 18 03			jr .pastdmark  
2969 ..			.dmark: db "MAL"  
296c f1			.pastdmark: pop af  
296d			endm  
# End of macro DMARK
296d						CALLMONITOR 
296d cd 74 17			call break_point_state  
2970				endm  
# End of macro CALLMONITOR
2970					endif 
2970			.mallocc: 
2970					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2970 cd fb 1e			call macro_dsp_valuehl 
2973				endm 
# End of macro FORTH_DSP_VALUEHL
2973			 
2973			;		push hl 
2973			 
2973					; destroy value TOS 
2973			 
2973					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2973 cd b3 1f			call macro_forth_dsp_pop 
2976				endm 
# End of macro FORTH_DSP_POP
2976			 
2976			;		pop hl 
2976 cd e7 11				call malloc 
2979				if DEBUG_FORTH_MALLOC_GUARD 
2979 f5					push af 
297a cd 49 0d				call ishlzero 
297d			;		ld a, l 
297d			;		add h 
297d			;		cp 0 
297d f1					pop af 
297e					 
297e cc 2e 52				call z,malloc_error 
2981				endif 
2981			 
2981 cd 04 1d				call forth_push_numhl 
2984					NEXTW 
2984 c3 6d 20			jp macro_next 
2987				endm 
# End of macro NEXTW
2987			 
2987			.FREE: 
2987				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2987 57				db WORD_SYS_CORE+67             
2988 b8 29			dw .LIST            
298a 05				db 4 + 1 
298b .. 00			db "FREE",0              
2990				endm 
# End of macro CWHEAD
2990			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2990					if DEBUG_FORTH_WORDS_KEY 
2990						DMARK "FRE" 
2990 f5				push af  
2991 3a a5 29			ld a, (.dmark)  
2994 32 77 fb			ld (debug_mark),a  
2997 3a a6 29			ld a, (.dmark+1)  
299a 32 78 fb			ld (debug_mark+1),a  
299d 3a a7 29			ld a, (.dmark+2)  
29a0 32 79 fb			ld (debug_mark+2),a  
29a3 18 03			jr .pastdmark  
29a5 ..			.dmark: db "FRE"  
29a8 f1			.pastdmark: pop af  
29a9			endm  
# End of macro DMARK
29a9						CALLMONITOR 
29a9 cd 74 17			call break_point_state  
29ac				endm  
# End of macro CALLMONITOR
29ac					endif 
29ac					; get address 
29ac			 
29ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29ac cd fb 1e			call macro_dsp_valuehl 
29af				endm 
# End of macro FORTH_DSP_VALUEHL
29af			 
29af			;		push hl 
29af			 
29af					; destroy value TOS 
29af			 
29af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29af cd b3 1f			call macro_forth_dsp_pop 
29b2				endm 
# End of macro FORTH_DSP_POP
29b2			 
29b2			;		pop hl 
29b2			if FORTH_ENABLE_MALLOCFREE 
29b2 cd b1 12				call free 
29b5			endif 
29b5					NEXTW 
29b5 c3 6d 20			jp macro_next 
29b8				endm 
# End of macro NEXTW
29b8			.LIST: 
29b8				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
29b8 5c				db WORD_SYS_CORE+72             
29b9 a6 2b			dw .FORGET            
29bb 05				db 4 + 1 
29bc .. 00			db "LIST",0              
29c1				endm 
# End of macro CWHEAD
29c1			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
29c1			; | | The quoted word must be in upper case. 
29c1				if DEBUG_FORTH_WORDS_KEY 
29c1					DMARK "LST" 
29c1 f5				push af  
29c2 3a d6 29			ld a, (.dmark)  
29c5 32 77 fb			ld (debug_mark),a  
29c8 3a d7 29			ld a, (.dmark+1)  
29cb 32 78 fb			ld (debug_mark+1),a  
29ce 3a d8 29			ld a, (.dmark+2)  
29d1 32 79 fb			ld (debug_mark+2),a  
29d4 18 03			jr .pastdmark  
29d6 ..			.dmark: db "LST"  
29d9 f1			.pastdmark: pop af  
29da			endm  
# End of macro DMARK
29da					CALLMONITOR 
29da cd 74 17			call break_point_state  
29dd				endm  
# End of macro CALLMONITOR
29dd				endif 
29dd			 
29dd					FORTH_DSP_VALUEHL 
29dd cd fb 1e			call macro_dsp_valuehl 
29e0				endm 
# End of macro FORTH_DSP_VALUEHL
29e0			 
29e0 e5					push hl 
29e1					FORTH_DSP_POP 
29e1 cd b3 1f			call macro_forth_dsp_pop 
29e4				endm 
# End of macro FORTH_DSP_POP
29e4 c1					pop bc 
29e5			 
29e5			; Start format of scratch string 
29e5			 
29e5 21 1d ee				ld hl, scratch 
29e8			 
29e8 3e 3a				ld a, ':' 
29ea 77					ld (hl),a 
29eb 23					inc hl 
29ec 3e 20				ld a, ' ' 
29ee 77					ld (hl), a 
29ef			 
29ef					; Get ptr to the word we need to look up 
29ef			 
29ef			;		FORTH_DSP_VALUEHL 
29ef					;v5 FORTH_DSP_VALUE 
29ef				; TODO type check 
29ef			;		inc hl    ; Skip type check  
29ef			;		push hl 
29ef			;		ex de, hl    ; put into DE 
29ef			 
29ef			 
29ef 21 00 80				ld hl, baseram 
29f2					;ld hl, baseusermem 
29f2			 
29f2 e5			push hl   ; sacreifical push 
29f3			 
29f3			.ldouscanm: 
29f3 e1				pop hl 
29f4			.ldouscan: 
29f4				if DEBUG_FORTH_WORDS 
29f4					DMARK "LSs" 
29f4 f5				push af  
29f5 3a 09 2a			ld a, (.dmark)  
29f8 32 77 fb			ld (debug_mark),a  
29fb 3a 0a 2a			ld a, (.dmark+1)  
29fe 32 78 fb			ld (debug_mark+1),a  
2a01 3a 0b 2a			ld a, (.dmark+2)  
2a04 32 79 fb			ld (debug_mark+2),a  
2a07 18 03			jr .pastdmark  
2a09 ..			.dmark: db "LSs"  
2a0c f1			.pastdmark: pop af  
2a0d			endm  
# End of macro DMARK
2a0d					CALLMONITOR 
2a0d cd 74 17			call break_point_state  
2a10				endm  
# End of macro CALLMONITOR
2a10				endif 
2a10				; skip dict stub 
2a10 cd be 21				call forth_tok_next 
2a13			 
2a13			 
2a13			; while we have words to look for 
2a13			 
2a13 7e				ld a, (hl)      
2a14				if DEBUG_FORTH_WORDS 
2a14					DMARK "LSk" 
2a14 f5				push af  
2a15 3a 29 2a			ld a, (.dmark)  
2a18 32 77 fb			ld (debug_mark),a  
2a1b 3a 2a 2a			ld a, (.dmark+1)  
2a1e 32 78 fb			ld (debug_mark+1),a  
2a21 3a 2b 2a			ld a, (.dmark+2)  
2a24 32 79 fb			ld (debug_mark+2),a  
2a27 18 03			jr .pastdmark  
2a29 ..			.dmark: db "LSk"  
2a2c f1			.pastdmark: pop af  
2a2d			endm  
# End of macro DMARK
2a2d					CALLMONITOR 
2a2d cd 74 17			call break_point_state  
2a30				endm  
# End of macro CALLMONITOR
2a30				endif 
2a30					;cp WORD_SYS_END 
2a30					;jp z, .lunotfound 
2a30			 
2a30					; if we hit non uwords then gone too far 
2a30 fe 01				cp WORD_SYS_UWORD 
2a32 c2 62 2b				jp nz, .lunotfound 
2a35			 
2a35				if DEBUG_FORTH_WORDS 
2a35					DMARK "LSu" 
2a35 f5				push af  
2a36 3a 4a 2a			ld a, (.dmark)  
2a39 32 77 fb			ld (debug_mark),a  
2a3c 3a 4b 2a			ld a, (.dmark+1)  
2a3f 32 78 fb			ld (debug_mark+1),a  
2a42 3a 4c 2a			ld a, (.dmark+2)  
2a45 32 79 fb			ld (debug_mark+2),a  
2a48 18 03			jr .pastdmark  
2a4a ..			.dmark: db "LSu"  
2a4d f1			.pastdmark: pop af  
2a4e			endm  
# End of macro DMARK
2a4e					CALLMONITOR 
2a4e cd 74 17			call break_point_state  
2a51				endm  
# End of macro CALLMONITOR
2a51				endif 
2a51			 
2a51					; found a uword but is it the one we want... 
2a51			 
2a51 c5					push bc     ; uword to find is on bc 
2a52 d1					pop de 
2a53			 
2a53 e5					push hl  ; to save the ptr 
2a54			 
2a54					; skip opcode 
2a54 23					inc hl  
2a55					; skip next ptr 
2a55 23					inc hl  
2a56 23					inc hl 
2a57					; skip len 
2a57 23					inc hl 
2a58			 
2a58				if DEBUG_FORTH_WORDS 
2a58					DMARK "LSc" 
2a58 f5				push af  
2a59 3a 6d 2a			ld a, (.dmark)  
2a5c 32 77 fb			ld (debug_mark),a  
2a5f 3a 6e 2a			ld a, (.dmark+1)  
2a62 32 78 fb			ld (debug_mark+1),a  
2a65 3a 6f 2a			ld a, (.dmark+2)  
2a68 32 79 fb			ld (debug_mark+2),a  
2a6b 18 03			jr .pastdmark  
2a6d ..			.dmark: db "LSc"  
2a70 f1			.pastdmark: pop af  
2a71			endm  
# End of macro DMARK
2a71					CALLMONITOR 
2a71 cd 74 17			call break_point_state  
2a74				endm  
# End of macro CALLMONITOR
2a74				endif 
2a74 cd b6 11				call strcmp 
2a77 c2 f3 29				jp nz, .ldouscanm 
2a7a				 
2a7a			 
2a7a			 
2a7a					; we have a uword so push its name to the stack 
2a7a			 
2a7a			;	   	push hl  ; save so we can move to next dict block 
2a7a e1			pop hl 
2a7b			 
2a7b				if DEBUG_FORTH_WORDS 
2a7b					DMARK "LSm" 
2a7b f5				push af  
2a7c 3a 90 2a			ld a, (.dmark)  
2a7f 32 77 fb			ld (debug_mark),a  
2a82 3a 91 2a			ld a, (.dmark+1)  
2a85 32 78 fb			ld (debug_mark+1),a  
2a88 3a 92 2a			ld a, (.dmark+2)  
2a8b 32 79 fb			ld (debug_mark+2),a  
2a8e 18 03			jr .pastdmark  
2a90 ..			.dmark: db "LSm"  
2a93 f1			.pastdmark: pop af  
2a94			endm  
# End of macro DMARK
2a94					CALLMONITOR 
2a94 cd 74 17			call break_point_state  
2a97				endm  
# End of macro CALLMONITOR
2a97				endif 
2a97			 
2a97					; skip opcode 
2a97 23					inc hl  
2a98					; skip next ptr 
2a98 23					inc hl  
2a99 23					inc hl 
2a9a					; skip len 
2a9a 7e					ld a, (hl)   ; save length to add 
2a9b				if DEBUG_FORTH_WORDS 
2a9b					DMARK "LS2" 
2a9b f5				push af  
2a9c 3a b0 2a			ld a, (.dmark)  
2a9f 32 77 fb			ld (debug_mark),a  
2aa2 3a b1 2a			ld a, (.dmark+1)  
2aa5 32 78 fb			ld (debug_mark+1),a  
2aa8 3a b2 2a			ld a, (.dmark+2)  
2aab 32 79 fb			ld (debug_mark+2),a  
2aae 18 03			jr .pastdmark  
2ab0 ..			.dmark: db "LS2"  
2ab3 f1			.pastdmark: pop af  
2ab4			endm  
# End of macro DMARK
2ab4					CALLMONITOR 
2ab4 cd 74 17			call break_point_state  
2ab7				endm  
# End of macro CALLMONITOR
2ab7				endif 
2ab7			 
2ab7					; save this location 
2ab7				 
2ab7 e5					push hl 
2ab8			 
2ab8 23					inc hl 
2ab9 11 1f ee				ld de, scratch+2 
2abc 4f					ld c, a 
2abd 06 00				ld b, 0 
2abf			 
2abf				if DEBUG_FORTH_WORDS 
2abf					DMARK "LSn" 
2abf f5				push af  
2ac0 3a d4 2a			ld a, (.dmark)  
2ac3 32 77 fb			ld (debug_mark),a  
2ac6 3a d5 2a			ld a, (.dmark+1)  
2ac9 32 78 fb			ld (debug_mark+1),a  
2acc 3a d6 2a			ld a, (.dmark+2)  
2acf 32 79 fb			ld (debug_mark+2),a  
2ad2 18 03			jr .pastdmark  
2ad4 ..			.dmark: db "LSn"  
2ad7 f1			.pastdmark: pop af  
2ad8			endm  
# End of macro DMARK
2ad8					CALLMONITOR 
2ad8 cd 74 17			call break_point_state  
2adb				endm  
# End of macro CALLMONITOR
2adb				endif 
2adb			 
2adb					; copy uword name to scratch 
2adb			 
2adb ed b0				ldir 
2add			 
2add 1b					dec de 
2ade 3e 20				ld a, ' '    ; change null to space 
2ae0 12					ld (de), a 
2ae1			 
2ae1 13					inc de 
2ae2			 
2ae2 d5					push de 
2ae3 c1					pop bc     ; move scratch pointer to end of word name and save it 
2ae4			 
2ae4 e1					pop hl 
2ae5 7e					ld a, (hl) 
2ae6					;inc hl 
2ae6					; skip word string 
2ae6 cd 20 0d				call addatohl 
2ae9			 
2ae9 23					inc hl 
2aea			 
2aea				if DEBUG_FORTH_WORDS 
2aea					DMARK "LS3" 
2aea f5				push af  
2aeb 3a ff 2a			ld a, (.dmark)  
2aee 32 77 fb			ld (debug_mark),a  
2af1 3a 00 2b			ld a, (.dmark+1)  
2af4 32 78 fb			ld (debug_mark+1),a  
2af7 3a 01 2b			ld a, (.dmark+2)  
2afa 32 79 fb			ld (debug_mark+2),a  
2afd 18 03			jr .pastdmark  
2aff ..			.dmark: db "LS3"  
2b02 f1			.pastdmark: pop af  
2b03			endm  
# End of macro DMARK
2b03					CALLMONITOR 
2b03 cd 74 17			call break_point_state  
2b06				endm  
# End of macro CALLMONITOR
2b06				endif 
2b06					; should now be at the start of the machine code to setup the eval of the uword 
2b06					; now locate the ptr to the string defintion 
2b06			 
2b06					; skip ld hl, 
2b06					; then load the ptr 
2b06			; TODO use get from hl ptr 
2b06 23					inc hl 
2b07 5e					ld e, (hl) 
2b08 23					inc hl 
2b09 56					ld d, (hl) 
2b0a eb					ex de, hl 
2b0b			 
2b0b			 
2b0b				if DEBUG_FORTH_WORDS 
2b0b					DMARK "LSt" 
2b0b f5				push af  
2b0c 3a 20 2b			ld a, (.dmark)  
2b0f 32 77 fb			ld (debug_mark),a  
2b12 3a 21 2b			ld a, (.dmark+1)  
2b15 32 78 fb			ld (debug_mark+1),a  
2b18 3a 22 2b			ld a, (.dmark+2)  
2b1b 32 79 fb			ld (debug_mark+2),a  
2b1e 18 03			jr .pastdmark  
2b20 ..			.dmark: db "LSt"  
2b23 f1			.pastdmark: pop af  
2b24			endm  
# End of macro DMARK
2b24					CALLMONITOR 
2b24 cd 74 17			call break_point_state  
2b27				endm  
# End of macro CALLMONITOR
2b27				endif 
2b27			 
2b27			; cant push right now due to tokenised strings  
2b27			 
2b27			; get the destination of where to copy this definition to. 
2b27			 
2b27 c5					push bc 
2b28 d1					pop de 
2b29			 
2b29 7e			.listl:         ld a,(hl) 
2b2a fe 00				cp 0 
2b2c 28 09				jr z, .lreplsp     ; replace zero with space 
2b2e					;cp FORTH_END_BUFFER 
2b2e fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2b30 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2b32				 
2b32					; just copy this char as is then 
2b32			 
2b32 12					ld (de), a 
2b33			 
2b33 23			.listnxt:	inc hl 
2b34 13					inc de 
2b35 18 f2				jr .listl 
2b37			 
2b37 3e 20		.lreplsp:	ld a,' ' 
2b39 12					ld (de), a 
2b3a 18 f7				jr .listnxt 
2b3c			 
2b3c			; close up uword def 
2b3c			 
2b3c			.listdone: 
2b3c 12					ld (de), a 
2b3d 13					inc de 
2b3e 3e 00				ld a, 0 
2b40 12					ld (de), a 
2b41			 
2b41			; now have def so clean up and push to stack 
2b41			 
2b41 21 1d ee				ld hl, scratch 
2b44				if DEBUG_FORTH_WORDS 
2b44					DMARK "Ltp" 
2b44 f5				push af  
2b45 3a 59 2b			ld a, (.dmark)  
2b48 32 77 fb			ld (debug_mark),a  
2b4b 3a 5a 2b			ld a, (.dmark+1)  
2b4e 32 78 fb			ld (debug_mark+1),a  
2b51 3a 5b 2b			ld a, (.dmark+2)  
2b54 32 79 fb			ld (debug_mark+2),a  
2b57 18 03			jr .pastdmark  
2b59 ..			.dmark: db "Ltp"  
2b5c f1			.pastdmark: pop af  
2b5d			endm  
# End of macro DMARK
2b5d					CALLMONITOR 
2b5d cd 74 17			call break_point_state  
2b60				endm  
# End of macro CALLMONITOR
2b60				endif 
2b60			 
2b60 18 1f			jr .listpush 
2b62			 
2b62			;.lnuword:	pop hl 
2b62			;		call forth_tok_next 
2b62			;		jp .ldouscan  
2b62			 
2b62			.lunotfound:		  
2b62			 
2b62				if DEBUG_FORTH_WORDS 
2b62					DMARK "LSn" 
2b62 f5				push af  
2b63 3a 77 2b			ld a, (.dmark)  
2b66 32 77 fb			ld (debug_mark),a  
2b69 3a 78 2b			ld a, (.dmark+1)  
2b6c 32 78 fb			ld (debug_mark+1),a  
2b6f 3a 79 2b			ld a, (.dmark+2)  
2b72 32 79 fb			ld (debug_mark+2),a  
2b75 18 03			jr .pastdmark  
2b77 ..			.dmark: db "LSn"  
2b7a f1			.pastdmark: pop af  
2b7b			endm  
# End of macro DMARK
2b7b					CALLMONITOR 
2b7b cd 74 17			call break_point_state  
2b7e				endm  
# End of macro CALLMONITOR
2b7e				endif 
2b7e			 
2b7e					 
2b7e			;		FORTH_DSP_POP 
2b7e			;		ld hl, .luno 
2b7e			 
2b7e					NEXTW			 
2b7e c3 6d 20			jp macro_next 
2b81				endm 
# End of macro NEXTW
2b81			 
2b81			.listpush: 
2b81				if DEBUG_FORTH_WORDS 
2b81					DMARK "LS>" 
2b81 f5				push af  
2b82 3a 96 2b			ld a, (.dmark)  
2b85 32 77 fb			ld (debug_mark),a  
2b88 3a 97 2b			ld a, (.dmark+1)  
2b8b 32 78 fb			ld (debug_mark+1),a  
2b8e 3a 98 2b			ld a, (.dmark+2)  
2b91 32 79 fb			ld (debug_mark+2),a  
2b94 18 03			jr .pastdmark  
2b96 ..			.dmark: db "LS>"  
2b99 f1			.pastdmark: pop af  
2b9a			endm  
# End of macro DMARK
2b9a					CALLMONITOR 
2b9a cd 74 17			call break_point_state  
2b9d				endm  
# End of macro CALLMONITOR
2b9d				endif 
2b9d cd 72 1d				call forth_push_str 
2ba0			 
2ba0			 
2ba0			 
2ba0					NEXTW 
2ba0 c3 6d 20			jp macro_next 
2ba3				endm 
# End of macro NEXTW
2ba3			 
2ba3			;.luno:    db "Word not found",0 
2ba3			 
2ba3			 
2ba3			 
2ba3			 
2ba3			 
2ba3			;		push hl   ; save pointer to start of uword def string 
2ba3			; 
2ba3			;; look for FORTH_EOL_LINE 
2ba3			;		ld a, FORTH_END_BUFFER 
2ba3			;		call strlent 
2ba3			; 
2ba3			;		inc hl		 ; space for coln def 
2ba3			;		inc hl 
2ba3			;		inc hl          ; space for terms 
2ba3			;		inc hl 
2ba3			; 
2ba3			;		ld a, 20   ; TODO get actual length 
2ba3			;		call addatohl    ; include a random amount of room for the uword name 
2ba3			; 
2ba3			;		 
2ba3			;	if DEBUG_FORTH_WORDS 
2ba3			;		DMARK "Lt1" 
2ba3			;		CALLMONITOR 
2ba3			;	endif 
2ba3			;		 
2ba3			; 
2ba3			;; malloc space for the string because we cant change it 
2ba3			; 
2ba3			;		call malloc 
2ba3			;	if DEBUG_FORTH_MALLOC_GUARD 
2ba3			;		push af 
2ba3			;		call ishlzero 
2ba3			;		pop af 
2ba3			;		 
2ba3			;		call z,malloc_error 
2ba3			;	endif 
2ba3			; 
2ba3			;	if DEBUG_FORTH_WORDS 
2ba3			;		DMARK "Lt2" 
2ba3			;		CALLMONITOR 
2ba3			;	endif 
2ba3			;		pop de 
2ba3			;		push hl    ; push the malloc to release later 
2ba3			;		push hl   ;  push back a copy for the later stack push 
2ba3			;		 
2ba3			;; copy the string swapping out the zero terms for spaces 
2ba3			; 
2ba3			;		; de has our source 
2ba3			;		; hl has our dest 
2ba3			; 
2ba3			;; add the coln def 
2ba3			; 
2ba3			;		ld a, ':' 
2ba3			;		ld (hl), a 
2ba3			;		inc hl 
2ba3			;		ld a, ' ' 
2ba3			;		ld (hl), a 
2ba3			;		inc hl 
2ba3			; 
2ba3			;; add the uname word 
2ba3			;		push de   ; save our string for now 
2ba3			;		ex de, hl 
2ba3			; 
2ba3			;		FORTH_DSP_VALUE 
2ba3			;		;v5 FORTH_DSP_VALUE 
2ba3			; 
2ba3			;		inc hl   ; skip type but we know by now this is OK 
2ba3			; 
2ba3			;.luword:	ld a,(hl) 
2ba3			;		cp 0 
2ba3			;		jr z, .luword2 
2ba3			;		ld (de), a 
2ba3			;		inc de 
2ba3			;		inc hl 
2ba3			;		jr .luword 
2ba3			; 
2ba3			;.luword2:	ld a, ' ' 
2ba3			;		ld (de), a 
2ba3			;;		inc hl 
2ba3			;;		inc de 
2ba3			;;		ld (de), a 
2ba3			;;		inc hl 
2ba3			;		inc de 
2ba3			; 
2ba3			;		ex de, hl 
2ba3			;		pop de 
2ba3			;		 
2ba3			;		 
2ba3			; 
2ba3			;; detoken that string and copy it 
2ba3			; 
2ba3			;	if DEBUG_FORTH_WORDS 
2ba3			;		DMARK "Lt2" 
2ba3			;		CALLMONITOR 
2ba3			;	endif 
2ba3			;.ldetok:	ld a, (de) 
2ba3			;		cp FORTH_END_BUFFER 
2ba3			;		jr z, .ldetokend 
2ba3			;		; swap out any zero term for space 
2ba3			;		cp 0 
2ba3			;		jr nz, .ldetoknext 
2ba3			;		ld a, ' ' 
2ba3			; 
2ba3			;	if DEBUG_FORTH_WORDS 
2ba3			;		DMARK "LtS" 
2ba3			;		CALLMONITOR 
2ba3			;	endif 
2ba3			;.ldetoknext:	ld (hl), a 
2ba3			;		inc de 
2ba3			;		inc hl 
2ba3			;		jr .ldetok 
2ba3			; 
2ba3			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2ba3			;		ld (hl), a  
2ba3			; 
2ba3			;; free that temp malloc 
2ba3			; 
2ba3			;		pop hl    
2ba3			; 
2ba3			;	if DEBUG_FORTH_WORDS 
2ba3			;		DMARK "Lt4" 
2ba3			;		CALLMONITOR 
2ba3			;	endif 
2ba3			;		call forth_apushstrhl 
2ba3			; 
2ba3			;		; get rid of temp malloc area 
2ba3			; 
2ba3			;		pop hl 
2ba3			;		call free 
2ba3			; 
2ba3			;		jr .ludone 
2ba3			; 
2ba3			;.lnuword:	pop hl 
2ba3			;		call forth_tok_next 
2ba3			;		jp .ldouscan  
2ba3			; 
2ba3			;.ludone:		 pop hl 
2ba3			; 
2ba3					NEXTW 
2ba3 c3 6d 20			jp macro_next 
2ba6				endm 
# End of macro NEXTW
2ba6			 
2ba6			.FORGET: 
2ba6				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2ba6 5d				db WORD_SYS_CORE+73             
2ba7 1f 2c			dw .NOP            
2ba9 07				db 6 + 1 
2baa .. 00			db "FORGET",0              
2bb1				endm 
# End of macro CWHEAD
2bb1			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2bb1			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2bb1			; | |  
2bb1			; | | e.g. "MORE" forget 
2bb1					if DEBUG_FORTH_WORDS_KEY 
2bb1						DMARK "FRG" 
2bb1 f5				push af  
2bb2 3a c6 2b			ld a, (.dmark)  
2bb5 32 77 fb			ld (debug_mark),a  
2bb8 3a c7 2b			ld a, (.dmark+1)  
2bbb 32 78 fb			ld (debug_mark+1),a  
2bbe 3a c8 2b			ld a, (.dmark+2)  
2bc1 32 79 fb			ld (debug_mark+2),a  
2bc4 18 03			jr .pastdmark  
2bc6 ..			.dmark: db "FRG"  
2bc9 f1			.pastdmark: pop af  
2bca			endm  
# End of macro DMARK
2bca						CALLMONITOR 
2bca cd 74 17			call break_point_state  
2bcd				endm  
# End of macro CALLMONITOR
2bcd					endif 
2bcd			 
2bcd				; find uword 
2bcd			        ; update start of word with "_" 
2bcd				; replace uword with deleted flag 
2bcd			 
2bcd			 
2bcd			;	if DEBUG_FORTH_WORDS 
2bcd			;		DMARK "FOG" 
2bcd			;		CALLMONITOR 
2bcd			;	endif 
2bcd			 
2bcd			 
2bcd					; Get ptr to the word we need to look up 
2bcd			 
2bcd					FORTH_DSP_VALUEHL 
2bcd cd fb 1e			call macro_dsp_valuehl 
2bd0				endm 
# End of macro FORTH_DSP_VALUEHL
2bd0					;v5 FORTH_DSP_VALUE 
2bd0				; TODO type check 
2bd0			;		inc hl    ; Skip type check  
2bd0 e5					push hl 
2bd1 c1					pop bc 
2bd2			;		ex de, hl    ; put into DE 
2bd2			 
2bd2			 
2bd2 21 00 80				ld hl, baseram 
2bd5					;ld hl, baseusermem 
2bd5			 
2bd5				; skip dict stub 
2bd5			;	call forth_tok_next 
2bd5 e5			push hl   ; sacreifical push 
2bd6			 
2bd6			.fldouscanm: 
2bd6 e1				pop hl 
2bd7			.fldouscan: 
2bd7			;	if DEBUG_FORTH_WORDS 
2bd7			;		DMARK "LSs" 
2bd7			;		CALLMONITOR 
2bd7			;	endif 
2bd7				; skip dict stub 
2bd7 cd be 21				call forth_tok_next 
2bda			 
2bda			 
2bda			; while we have words to look for 
2bda			 
2bda 7e				ld a, (hl)      
2bdb			;	if DEBUG_FORTH_WORDS 
2bdb			;		DMARK "LSk" 
2bdb			;		CALLMONITOR 
2bdb			;	endif 
2bdb fe 00				cp WORD_SYS_END 
2bdd ca 19 2c				jp z, .flunotfound 
2be0 fe 01				cp WORD_SYS_UWORD 
2be2 c2 d7 2b				jp nz, .fldouscan 
2be5			 
2be5			;	if DEBUG_FORTH_WORDS 
2be5			;		DMARK "LSu" 
2be5			;		CALLMONITOR 
2be5			;	endif 
2be5			 
2be5					; found a uword but is it the one we want... 
2be5			 
2be5 c5					push bc     ; uword to find is on bc 
2be6 d1					pop de 
2be7			 
2be7 e5					push hl  ; to save the ptr 
2be8			 
2be8					; skip opcode 
2be8 23					inc hl  
2be9					; skip next ptr 
2be9 23					inc hl  
2bea 23					inc hl 
2beb					; skip len 
2beb 23					inc hl 
2bec			 
2bec			;	if DEBUG_FORTH_WORDS 
2bec			;		DMARK "LSc" 
2bec			;		CALLMONITOR 
2bec			;	endif 
2bec cd b6 11				call strcmp 
2bef c2 d6 2b				jp nz, .fldouscanm 
2bf2			; 
2bf2			; 
2bf2			;; while we have words to look for 
2bf2			; 
2bf2			;.fdouscan:	ld a, (hl)      
2bf2			;	if DEBUG_FORTH_WORDS 
2bf2			;		DMARK "LSs" 
2bf2			;		CALLMONITOR 
2bf2			;	endif 
2bf2			;		cp WORD_SYS_END 
2bf2			;		jp z, .fudone 
2bf2			;		cp WORD_SYS_UWORD 
2bf2			;		jp nz, .fnuword 
2bf2			; 
2bf2			;	if DEBUG_FORTH_WORDS 
2bf2			;		DMARK "FGu" 
2bf2			;		CALLMONITOR 
2bf2			;	endif 
2bf2			; 
2bf2			;		; found a uword but is it the one we want... 
2bf2			; 
2bf2			; 
2bf2			;	        pop de   ; get back the dsp name 
2bf2			;		push de 
2bf2			; 
2bf2			;		push hl  ; to save the ptr 
2bf2			; 
2bf2			;		; skip opcode 
2bf2			;		inc hl  
2bf2			;		; skip next ptr 
2bf2			;		inc hl  
2bf2			;		inc hl 
2bf2			;		; skip len 
2bf2			;		inc hl 
2bf2			; 
2bf2			;	if DEBUG_FORTH_WORDS 
2bf2			;		DMARK "FGc" 
2bf2			;		CALLMONITOR 
2bf2			;	endif 
2bf2			;		call strcmp 
2bf2			;		jp nz, .fnuword 
2bf2			 
2bf2			 
2bf2 e1			pop hl 
2bf3			 
2bf3				 
2bf3				if DEBUG_FORTH_WORDS 
2bf3					DMARK "FGm" 
2bf3 f5				push af  
2bf4 3a 08 2c			ld a, (.dmark)  
2bf7 32 77 fb			ld (debug_mark),a  
2bfa 3a 09 2c			ld a, (.dmark+1)  
2bfd 32 78 fb			ld (debug_mark+1),a  
2c00 3a 0a 2c			ld a, (.dmark+2)  
2c03 32 79 fb			ld (debug_mark+2),a  
2c06 18 03			jr .pastdmark  
2c08 ..			.dmark: db "FGm"  
2c0b f1			.pastdmark: pop af  
2c0c			endm  
# End of macro DMARK
2c0c					CALLMONITOR 
2c0c cd 74 17			call break_point_state  
2c0f				endm  
# End of macro CALLMONITOR
2c0f				endif 
2c0f			 
2c0f			 
2c0f			 
2c0f					; we have a uword so push its name to the stack 
2c0f			 
2c0f			;	   	push hl  ; save so we can move to next dict block 
2c0f			;pop hl 
2c0f			 
2c0f					; update opcode to deleted 
2c0f 3e 03				ld a, WORD_SYS_DELETED 
2c11 77					ld (hl), a 
2c12			 
2c12 23					inc hl  
2c13					; skip next ptr 
2c13 23					inc hl  
2c14 23					inc hl 
2c15					; skip len 
2c15 23					inc hl 
2c16			 
2c16					; TODO change parser to skip deleted words but for now mark it out 
2c16 3e 5f				ld a, "_" 
2c18 77					ld  (hl),a 
2c19			 
2c19			;		jr .fudone 
2c19			; 
2c19			;.fnuword:	pop hl 
2c19			;		call forth_tok_next 
2c19			;		jp .fdouscan  
2c19			 
2c19			.flunotfound:		  
2c19			 
2c19			 
2c19					 
2c19					FORTH_DSP_POP 
2c19 cd b3 1f			call macro_forth_dsp_pop 
2c1c				endm 
# End of macro FORTH_DSP_POP
2c1c			;		ld hl, .luno 
2c1c			;.fudone:		 pop hl 
2c1c					NEXTW 
2c1c c3 6d 20			jp macro_next 
2c1f				endm 
# End of macro NEXTW
2c1f			.NOP: 
2c1f				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2c1f 61				db WORD_SYS_CORE+77             
2c20 46 2c			dw .COMO            
2c22 04				db 3 + 1 
2c23 .. 00			db "NOP",0              
2c27				endm 
# End of macro CWHEAD
2c27			; | NOP (  --  ) Do nothing | DONE 
2c27					if DEBUG_FORTH_WORDS_KEY 
2c27						DMARK "NOP" 
2c27 f5				push af  
2c28 3a 3c 2c			ld a, (.dmark)  
2c2b 32 77 fb			ld (debug_mark),a  
2c2e 3a 3d 2c			ld a, (.dmark+1)  
2c31 32 78 fb			ld (debug_mark+1),a  
2c34 3a 3e 2c			ld a, (.dmark+2)  
2c37 32 79 fb			ld (debug_mark+2),a  
2c3a 18 03			jr .pastdmark  
2c3c ..			.dmark: db "NOP"  
2c3f f1			.pastdmark: pop af  
2c40			endm  
# End of macro DMARK
2c40						CALLMONITOR 
2c40 cd 74 17			call break_point_state  
2c43				endm  
# End of macro CALLMONITOR
2c43					endif 
2c43				       NEXTW 
2c43 c3 6d 20			jp macro_next 
2c46				endm 
# End of macro NEXTW
2c46			.COMO: 
2c46				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2c46 6e				db WORD_SYS_CORE+90             
2c47 98 2c			dw .COMC            
2c49 02				db 1 + 1 
2c4a .. 00			db "(",0              
2c4c				endm 
# End of macro CWHEAD
2c4c			; | ( ( -- )  Start of comment | DONE 
2c4c			 
2c4c			 
2c4c 2a 1e f1				ld hl, ( os_tok_ptr) 
2c4f 11 93 2c			ld de, .closepar 
2c52					 
2c52					if DEBUG_FORTH_WORDS 
2c52						DMARK ").." 
2c52 f5				push af  
2c53 3a 67 2c			ld a, (.dmark)  
2c56 32 77 fb			ld (debug_mark),a  
2c59 3a 68 2c			ld a, (.dmark+1)  
2c5c 32 78 fb			ld (debug_mark+1),a  
2c5f 3a 69 2c			ld a, (.dmark+2)  
2c62 32 79 fb			ld (debug_mark+2),a  
2c65 18 03			jr .pastdmark  
2c67 ..			.dmark: db ").."  
2c6a f1			.pastdmark: pop af  
2c6b			endm  
# End of macro DMARK
2c6b						CALLMONITOR 
2c6b cd 74 17			call break_point_state  
2c6e				endm  
# End of macro CALLMONITOR
2c6e					endif 
2c6e cd 88 21			call findnexttok  
2c71			 
2c71					if DEBUG_FORTH_WORDS 
2c71						DMARK "IF5" 
2c71 f5				push af  
2c72 3a 86 2c			ld a, (.dmark)  
2c75 32 77 fb			ld (debug_mark),a  
2c78 3a 87 2c			ld a, (.dmark+1)  
2c7b 32 78 fb			ld (debug_mark+1),a  
2c7e 3a 88 2c			ld a, (.dmark+2)  
2c81 32 79 fb			ld (debug_mark+2),a  
2c84 18 03			jr .pastdmark  
2c86 ..			.dmark: db "IF5"  
2c89 f1			.pastdmark: pop af  
2c8a			endm  
# End of macro DMARK
2c8a						CALLMONITOR 
2c8a cd 74 17			call break_point_state  
2c8d				endm  
# End of macro CALLMONITOR
2c8d					endif 
2c8d				; replace below with ) exec using tok_ptr 
2c8d 22 1e f1			ld (os_tok_ptr), hl 
2c90 c3 fe 20			jp exec1 
2c93			 
2c93 .. 00			.closepar:   db ")",0 
2c95			 
2c95				       NEXTW 
2c95 c3 6d 20			jp macro_next 
2c98				endm 
# End of macro NEXTW
2c98			.COMC: 
2c98				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c98 6f				db WORD_SYS_CORE+91             
2c99 a1 2c			dw .SCRATCH            
2c9b 02				db 1 + 1 
2c9c .. 00			db ")",0              
2c9e				endm 
# End of macro CWHEAD
2c9e			; | ) ( -- )  End of comment |  DONE  
2c9e				       NEXTW 
2c9e c3 6d 20			jp macro_next 
2ca1				endm 
# End of macro NEXTW
2ca1			 
2ca1			.SCRATCH: 
2ca1				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2ca1 6f				db WORD_SYS_CORE+91             
2ca2 dc 2c			dw .INC            
2ca4 08				db 7 + 1 
2ca5 .. 00			db "SCRATCH",0              
2cad				endm 
# End of macro CWHEAD
2cad			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2cad			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2cad			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2cad			; | |  
2cad			; | | e.g.    : score $00 scratch ; 
2cad			; | |  
2cad			; | | $00 score ! 
2cad			; | | $01 score +! 
2cad			; | |  
2cad			; | | e.g.   : varword $0a scratch ;  
2cad			; | | 
2cad			; | | $8000 varword ! 
2cad					if DEBUG_FORTH_WORDS_KEY 
2cad						DMARK "SCR" 
2cad f5				push af  
2cae 3a c2 2c			ld a, (.dmark)  
2cb1 32 77 fb			ld (debug_mark),a  
2cb4 3a c3 2c			ld a, (.dmark+1)  
2cb7 32 78 fb			ld (debug_mark+1),a  
2cba 3a c4 2c			ld a, (.dmark+2)  
2cbd 32 79 fb			ld (debug_mark+2),a  
2cc0 18 03			jr .pastdmark  
2cc2 ..			.dmark: db "SCR"  
2cc5 f1			.pastdmark: pop af  
2cc6			endm  
# End of macro DMARK
2cc6						CALLMONITOR 
2cc6 cd 74 17			call break_point_state  
2cc9				endm  
# End of macro CALLMONITOR
2cc9					endif 
2cc9			 
2cc9					FORTH_DSP_VALUEHL 
2cc9 cd fb 1e			call macro_dsp_valuehl 
2ccc				endm 
# End of macro FORTH_DSP_VALUEHL
2ccc				 
2ccc					FORTH_DSP_POP 
2ccc cd b3 1f			call macro_forth_dsp_pop 
2ccf				endm 
# End of macro FORTH_DSP_POP
2ccf			 
2ccf 7d					ld a, l 
2cd0 21 42 f3				ld hl, os_var_array 
2cd3 cd 20 0d				call addatohl 
2cd6			 
2cd6 cd 04 1d				call forth_push_numhl 
2cd9			 
2cd9				       NEXTW 
2cd9 c3 6d 20			jp macro_next 
2cdc				endm 
# End of macro NEXTW
2cdc			 
2cdc			.INC: 
2cdc				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2cdc 6f				db WORD_SYS_CORE+91             
2cdd 30 2d			dw .DEC            
2cdf 03				db 2 + 1 
2ce0 .. 00			db "+!",0              
2ce3				endm 
# End of macro CWHEAD
2ce3			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2ce3					if DEBUG_FORTH_WORDS_KEY 
2ce3						DMARK "+s_" 
2ce3 f5				push af  
2ce4 3a f8 2c			ld a, (.dmark)  
2ce7 32 77 fb			ld (debug_mark),a  
2cea 3a f9 2c			ld a, (.dmark+1)  
2ced 32 78 fb			ld (debug_mark+1),a  
2cf0 3a fa 2c			ld a, (.dmark+2)  
2cf3 32 79 fb			ld (debug_mark+2),a  
2cf6 18 03			jr .pastdmark  
2cf8 ..			.dmark: db "+s_"  
2cfb f1			.pastdmark: pop af  
2cfc			endm  
# End of macro DMARK
2cfc						CALLMONITOR 
2cfc cd 74 17			call break_point_state  
2cff				endm  
# End of macro CALLMONITOR
2cff					endif 
2cff			 
2cff					FORTH_DSP_VALUEHL 
2cff cd fb 1e			call macro_dsp_valuehl 
2d02				endm 
# End of macro FORTH_DSP_VALUEHL
2d02			 
2d02 e5					push hl   ; save address 
2d03			 
2d03					FORTH_DSP_POP 
2d03 cd b3 1f			call macro_forth_dsp_pop 
2d06				endm 
# End of macro FORTH_DSP_POP
2d06			 
2d06					FORTH_DSP_VALUEHL 
2d06 cd fb 1e			call macro_dsp_valuehl 
2d09				endm 
# End of macro FORTH_DSP_VALUEHL
2d09			 
2d09					FORTH_DSP_POP 
2d09 cd b3 1f			call macro_forth_dsp_pop 
2d0c				endm 
# End of macro FORTH_DSP_POP
2d0c			 
2d0c					; hl contains value to add to byte at a 
2d0c				 
2d0c eb					ex de, hl 
2d0d			 
2d0d e1					pop hl 
2d0e			 
2d0e					if DEBUG_FORTH_WORDS 
2d0e						DMARK "INC" 
2d0e f5				push af  
2d0f 3a 23 2d			ld a, (.dmark)  
2d12 32 77 fb			ld (debug_mark),a  
2d15 3a 24 2d			ld a, (.dmark+1)  
2d18 32 78 fb			ld (debug_mark+1),a  
2d1b 3a 25 2d			ld a, (.dmark+2)  
2d1e 32 79 fb			ld (debug_mark+2),a  
2d21 18 03			jr .pastdmark  
2d23 ..			.dmark: db "INC"  
2d26 f1			.pastdmark: pop af  
2d27			endm  
# End of macro DMARK
2d27						CALLMONITOR 
2d27 cd 74 17			call break_point_state  
2d2a				endm  
# End of macro CALLMONITOR
2d2a					endif 
2d2a			 
2d2a 7e					ld a,(hl) 
2d2b 83					add e 
2d2c 77					ld (hl),a 
2d2d			 
2d2d			 
2d2d			 
2d2d				       NEXTW 
2d2d c3 6d 20			jp macro_next 
2d30				endm 
# End of macro NEXTW
2d30			 
2d30			.DEC: 
2d30				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2d30 6f				db WORD_SYS_CORE+91             
2d31 81 2d			dw .INC2            
2d33 03				db 2 + 1 
2d34 .. 00			db "-!",0              
2d37				endm 
# End of macro CWHEAD
2d37			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2d37					if DEBUG_FORTH_WORDS_KEY 
2d37						DMARK "-s_" 
2d37 f5				push af  
2d38 3a 4c 2d			ld a, (.dmark)  
2d3b 32 77 fb			ld (debug_mark),a  
2d3e 3a 4d 2d			ld a, (.dmark+1)  
2d41 32 78 fb			ld (debug_mark+1),a  
2d44 3a 4e 2d			ld a, (.dmark+2)  
2d47 32 79 fb			ld (debug_mark+2),a  
2d4a 18 03			jr .pastdmark  
2d4c ..			.dmark: db "-s_"  
2d4f f1			.pastdmark: pop af  
2d50			endm  
# End of macro DMARK
2d50						CALLMONITOR 
2d50 cd 74 17			call break_point_state  
2d53				endm  
# End of macro CALLMONITOR
2d53					endif 
2d53			 
2d53					FORTH_DSP_VALUEHL 
2d53 cd fb 1e			call macro_dsp_valuehl 
2d56				endm 
# End of macro FORTH_DSP_VALUEHL
2d56			 
2d56 e5					push hl   ; save address 
2d57			 
2d57					FORTH_DSP_POP 
2d57 cd b3 1f			call macro_forth_dsp_pop 
2d5a				endm 
# End of macro FORTH_DSP_POP
2d5a			 
2d5a					FORTH_DSP_VALUEHL 
2d5a cd fb 1e			call macro_dsp_valuehl 
2d5d				endm 
# End of macro FORTH_DSP_VALUEHL
2d5d			 
2d5d					; hl contains value to add to byte at a 
2d5d				 
2d5d eb					ex de, hl 
2d5e			 
2d5e e1					pop hl 
2d5f			 
2d5f					if DEBUG_FORTH_WORDS 
2d5f						DMARK "DEC" 
2d5f f5				push af  
2d60 3a 74 2d			ld a, (.dmark)  
2d63 32 77 fb			ld (debug_mark),a  
2d66 3a 75 2d			ld a, (.dmark+1)  
2d69 32 78 fb			ld (debug_mark+1),a  
2d6c 3a 76 2d			ld a, (.dmark+2)  
2d6f 32 79 fb			ld (debug_mark+2),a  
2d72 18 03			jr .pastdmark  
2d74 ..			.dmark: db "DEC"  
2d77 f1			.pastdmark: pop af  
2d78			endm  
# End of macro DMARK
2d78						CALLMONITOR 
2d78 cd 74 17			call break_point_state  
2d7b				endm  
# End of macro CALLMONITOR
2d7b					endif 
2d7b			 
2d7b 7e					ld a,(hl) 
2d7c 93					sub e 
2d7d 77					ld (hl),a 
2d7e			 
2d7e			 
2d7e			 
2d7e				       NEXTW 
2d7e c3 6d 20			jp macro_next 
2d81				endm 
# End of macro NEXTW
2d81			 
2d81			.INC2: 
2d81				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d81 6f				db WORD_SYS_CORE+91             
2d82 2b 2e			dw .DEC2            
2d84 04				db 3 + 1 
2d85 .. 00			db "+2!",0              
2d89				endm 
# End of macro CWHEAD
2d89			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d89			 
2d89					if DEBUG_FORTH_WORDS_KEY 
2d89						DMARK "+2s" 
2d89 f5				push af  
2d8a 3a 9e 2d			ld a, (.dmark)  
2d8d 32 77 fb			ld (debug_mark),a  
2d90 3a 9f 2d			ld a, (.dmark+1)  
2d93 32 78 fb			ld (debug_mark+1),a  
2d96 3a a0 2d			ld a, (.dmark+2)  
2d99 32 79 fb			ld (debug_mark+2),a  
2d9c 18 03			jr .pastdmark  
2d9e ..			.dmark: db "+2s"  
2da1 f1			.pastdmark: pop af  
2da2			endm  
# End of macro DMARK
2da2						CALLMONITOR 
2da2 cd 74 17			call break_point_state  
2da5				endm  
# End of macro CALLMONITOR
2da5					endif 
2da5			 
2da5					; Address 
2da5			 
2da5					FORTH_DSP_VALUEHL 
2da5 cd fb 1e			call macro_dsp_valuehl 
2da8				endm 
# End of macro FORTH_DSP_VALUEHL
2da8			 
2da8 e5					push hl    ; save address 
2da9			 
2da9					; load content into de 
2da9			 
2da9 5e					ld e,(hl) 
2daa 23					inc hl 
2dab 56					ld d, (hl) 
2dac			 
2dac					if DEBUG_FORTH_WORDS 
2dac						DMARK "+2a" 
2dac f5				push af  
2dad 3a c1 2d			ld a, (.dmark)  
2db0 32 77 fb			ld (debug_mark),a  
2db3 3a c2 2d			ld a, (.dmark+1)  
2db6 32 78 fb			ld (debug_mark+1),a  
2db9 3a c3 2d			ld a, (.dmark+2)  
2dbc 32 79 fb			ld (debug_mark+2),a  
2dbf 18 03			jr .pastdmark  
2dc1 ..			.dmark: db "+2a"  
2dc4 f1			.pastdmark: pop af  
2dc5			endm  
# End of macro DMARK
2dc5						CALLMONITOR 
2dc5 cd 74 17			call break_point_state  
2dc8				endm  
# End of macro CALLMONITOR
2dc8					endif 
2dc8			 
2dc8					FORTH_DSP_POP 
2dc8 cd b3 1f			call macro_forth_dsp_pop 
2dcb				endm 
# End of macro FORTH_DSP_POP
2dcb			 
2dcb					; Get value to add 
2dcb			 
2dcb					FORTH_DSP_VALUE 
2dcb cd e4 1e			call macro_forth_dsp_value 
2dce				endm 
# End of macro FORTH_DSP_VALUE
2dce			 
2dce					if DEBUG_FORTH_WORDS 
2dce						DMARK "+2v" 
2dce f5				push af  
2dcf 3a e3 2d			ld a, (.dmark)  
2dd2 32 77 fb			ld (debug_mark),a  
2dd5 3a e4 2d			ld a, (.dmark+1)  
2dd8 32 78 fb			ld (debug_mark+1),a  
2ddb 3a e5 2d			ld a, (.dmark+2)  
2dde 32 79 fb			ld (debug_mark+2),a  
2de1 18 03			jr .pastdmark  
2de3 ..			.dmark: db "+2v"  
2de6 f1			.pastdmark: pop af  
2de7			endm  
# End of macro DMARK
2de7						CALLMONITOR 
2de7 cd 74 17			call break_point_state  
2dea				endm  
# End of macro CALLMONITOR
2dea					endif 
2dea			 
2dea 19					add hl, de 
2deb			 
2deb					if DEBUG_FORTH_WORDS 
2deb						DMARK "+2+" 
2deb f5				push af  
2dec 3a 00 2e			ld a, (.dmark)  
2def 32 77 fb			ld (debug_mark),a  
2df2 3a 01 2e			ld a, (.dmark+1)  
2df5 32 78 fb			ld (debug_mark+1),a  
2df8 3a 02 2e			ld a, (.dmark+2)  
2dfb 32 79 fb			ld (debug_mark+2),a  
2dfe 18 03			jr .pastdmark  
2e00 ..			.dmark: db "+2+"  
2e03 f1			.pastdmark: pop af  
2e04			endm  
# End of macro DMARK
2e04						CALLMONITOR 
2e04 cd 74 17			call break_point_state  
2e07				endm  
# End of macro CALLMONITOR
2e07					endif 
2e07			 
2e07					; move result to de 
2e07			 
2e07 eb					ex de, hl 
2e08			 
2e08					; Address 
2e08			 
2e08 e1					pop hl 
2e09			 
2e09					; save it back 
2e09			 
2e09 73					ld (hl), e 
2e0a 23					inc hl 
2e0b 72					ld (hl), d 
2e0c			 
2e0c					if DEBUG_FORTH_WORDS 
2e0c						DMARK "+2e" 
2e0c f5				push af  
2e0d 3a 21 2e			ld a, (.dmark)  
2e10 32 77 fb			ld (debug_mark),a  
2e13 3a 22 2e			ld a, (.dmark+1)  
2e16 32 78 fb			ld (debug_mark+1),a  
2e19 3a 23 2e			ld a, (.dmark+2)  
2e1c 32 79 fb			ld (debug_mark+2),a  
2e1f 18 03			jr .pastdmark  
2e21 ..			.dmark: db "+2e"  
2e24 f1			.pastdmark: pop af  
2e25			endm  
# End of macro DMARK
2e25						CALLMONITOR 
2e25 cd 74 17			call break_point_state  
2e28				endm  
# End of macro CALLMONITOR
2e28					endif 
2e28			 
2e28			 
2e28			 
2e28			 
2e28			 
2e28				       NEXTW 
2e28 c3 6d 20			jp macro_next 
2e2b				endm 
# End of macro NEXTW
2e2b			 
2e2b			.DEC2: 
2e2b				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2e2b 6f				db WORD_SYS_CORE+91             
2e2c d7 2e			dw .GET2            
2e2e 04				db 3 + 1 
2e2f .. 00			db "-2!",0              
2e33				endm 
# End of macro CWHEAD
2e33			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2e33			 
2e33			 
2e33					if DEBUG_FORTH_WORDS_KEY 
2e33						DMARK "-2s" 
2e33 f5				push af  
2e34 3a 48 2e			ld a, (.dmark)  
2e37 32 77 fb			ld (debug_mark),a  
2e3a 3a 49 2e			ld a, (.dmark+1)  
2e3d 32 78 fb			ld (debug_mark+1),a  
2e40 3a 4a 2e			ld a, (.dmark+2)  
2e43 32 79 fb			ld (debug_mark+2),a  
2e46 18 03			jr .pastdmark  
2e48 ..			.dmark: db "-2s"  
2e4b f1			.pastdmark: pop af  
2e4c			endm  
# End of macro DMARK
2e4c						CALLMONITOR 
2e4c cd 74 17			call break_point_state  
2e4f				endm  
# End of macro CALLMONITOR
2e4f					endif 
2e4f			 
2e4f					; Address 
2e4f			 
2e4f					FORTH_DSP_VALUEHL 
2e4f cd fb 1e			call macro_dsp_valuehl 
2e52				endm 
# End of macro FORTH_DSP_VALUEHL
2e52			 
2e52 e5					push hl    ; save address 
2e53			 
2e53					; load content into de 
2e53			 
2e53 5e					ld e,(hl) 
2e54 23					inc hl 
2e55 56					ld d, (hl) 
2e56			 
2e56					if DEBUG_FORTH_WORDS 
2e56						DMARK "-2a" 
2e56 f5				push af  
2e57 3a 6b 2e			ld a, (.dmark)  
2e5a 32 77 fb			ld (debug_mark),a  
2e5d 3a 6c 2e			ld a, (.dmark+1)  
2e60 32 78 fb			ld (debug_mark+1),a  
2e63 3a 6d 2e			ld a, (.dmark+2)  
2e66 32 79 fb			ld (debug_mark+2),a  
2e69 18 03			jr .pastdmark  
2e6b ..			.dmark: db "-2a"  
2e6e f1			.pastdmark: pop af  
2e6f			endm  
# End of macro DMARK
2e6f						CALLMONITOR 
2e6f cd 74 17			call break_point_state  
2e72				endm  
# End of macro CALLMONITOR
2e72					endif 
2e72			 
2e72					FORTH_DSP_POP 
2e72 cd b3 1f			call macro_forth_dsp_pop 
2e75				endm 
# End of macro FORTH_DSP_POP
2e75			 
2e75					; Get value to remove 
2e75			 
2e75					FORTH_DSP_VALUE 
2e75 cd e4 1e			call macro_forth_dsp_value 
2e78				endm 
# End of macro FORTH_DSP_VALUE
2e78			 
2e78					if DEBUG_FORTH_WORDS 
2e78						DMARK "-2v" 
2e78 f5				push af  
2e79 3a 8d 2e			ld a, (.dmark)  
2e7c 32 77 fb			ld (debug_mark),a  
2e7f 3a 8e 2e			ld a, (.dmark+1)  
2e82 32 78 fb			ld (debug_mark+1),a  
2e85 3a 8f 2e			ld a, (.dmark+2)  
2e88 32 79 fb			ld (debug_mark+2),a  
2e8b 18 03			jr .pastdmark  
2e8d ..			.dmark: db "-2v"  
2e90 f1			.pastdmark: pop af  
2e91			endm  
# End of macro DMARK
2e91						CALLMONITOR 
2e91 cd 74 17			call break_point_state  
2e94				endm  
# End of macro CALLMONITOR
2e94					endif 
2e94			 
2e94 eb					ex de, hl 
2e95 ed 52				sbc hl, de 
2e97			 
2e97					if DEBUG_FORTH_WORDS 
2e97						DMARK "-2d" 
2e97 f5				push af  
2e98 3a ac 2e			ld a, (.dmark)  
2e9b 32 77 fb			ld (debug_mark),a  
2e9e 3a ad 2e			ld a, (.dmark+1)  
2ea1 32 78 fb			ld (debug_mark+1),a  
2ea4 3a ae 2e			ld a, (.dmark+2)  
2ea7 32 79 fb			ld (debug_mark+2),a  
2eaa 18 03			jr .pastdmark  
2eac ..			.dmark: db "-2d"  
2eaf f1			.pastdmark: pop af  
2eb0			endm  
# End of macro DMARK
2eb0						CALLMONITOR 
2eb0 cd 74 17			call break_point_state  
2eb3				endm  
# End of macro CALLMONITOR
2eb3					endif 
2eb3			 
2eb3					; move result to de 
2eb3			 
2eb3 eb					ex de, hl 
2eb4			 
2eb4					; Address 
2eb4			 
2eb4 e1					pop hl 
2eb5			 
2eb5					; save it back 
2eb5			 
2eb5 73					ld (hl), e 
2eb6 23					inc hl 
2eb7 72					ld (hl), d 
2eb8			 
2eb8					if DEBUG_FORTH_WORDS 
2eb8						DMARK "-2e" 
2eb8 f5				push af  
2eb9 3a cd 2e			ld a, (.dmark)  
2ebc 32 77 fb			ld (debug_mark),a  
2ebf 3a ce 2e			ld a, (.dmark+1)  
2ec2 32 78 fb			ld (debug_mark+1),a  
2ec5 3a cf 2e			ld a, (.dmark+2)  
2ec8 32 79 fb			ld (debug_mark+2),a  
2ecb 18 03			jr .pastdmark  
2ecd ..			.dmark: db "-2e"  
2ed0 f1			.pastdmark: pop af  
2ed1			endm  
# End of macro DMARK
2ed1						CALLMONITOR 
2ed1 cd 74 17			call break_point_state  
2ed4				endm  
# End of macro CALLMONITOR
2ed4					endif 
2ed4			 
2ed4			 
2ed4			 
2ed4			 
2ed4			 
2ed4				       NEXTW 
2ed4 c3 6d 20			jp macro_next 
2ed7				endm 
# End of macro NEXTW
2ed7			.GET2: 
2ed7				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2ed7 6f				db WORD_SYS_CORE+91             
2ed8 07 2f			dw .BANG2            
2eda 03				db 2 + 1 
2edb .. 00			db "2@",0              
2ede				endm 
# End of macro CWHEAD
2ede			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2ede					if DEBUG_FORTH_WORDS_KEY 
2ede						DMARK "2A_" 
2ede f5				push af  
2edf 3a f3 2e			ld a, (.dmark)  
2ee2 32 77 fb			ld (debug_mark),a  
2ee5 3a f4 2e			ld a, (.dmark+1)  
2ee8 32 78 fb			ld (debug_mark+1),a  
2eeb 3a f5 2e			ld a, (.dmark+2)  
2eee 32 79 fb			ld (debug_mark+2),a  
2ef1 18 03			jr .pastdmark  
2ef3 ..			.dmark: db "2A_"  
2ef6 f1			.pastdmark: pop af  
2ef7			endm  
# End of macro DMARK
2ef7						CALLMONITOR 
2ef7 cd 74 17			call break_point_state  
2efa				endm  
# End of macro CALLMONITOR
2efa					endif 
2efa			 
2efa					FORTH_DSP_VALUEHL 
2efa cd fb 1e			call macro_dsp_valuehl 
2efd				endm 
# End of macro FORTH_DSP_VALUEHL
2efd			 
2efd 5e					ld e, (hl) 
2efe 23					inc hl 
2eff 56					ld d, (hl) 
2f00			 
2f00 eb					ex de, hl 
2f01			 
2f01 cd 04 1d				call forth_push_numhl 
2f04			 
2f04				       NEXTW 
2f04 c3 6d 20			jp macro_next 
2f07				endm 
# End of macro NEXTW
2f07			.BANG2: 
2f07				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2f07 6f				db WORD_SYS_CORE+91             
2f08 3f 2f			dw .CONFIG            
2f0a 03				db 2 + 1 
2f0b .. 00			db "2!",0              
2f0e				endm 
# End of macro CWHEAD
2f0e			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2f0e					if DEBUG_FORTH_WORDS_KEY 
2f0e						DMARK "2S_" 
2f0e f5				push af  
2f0f 3a 23 2f			ld a, (.dmark)  
2f12 32 77 fb			ld (debug_mark),a  
2f15 3a 24 2f			ld a, (.dmark+1)  
2f18 32 78 fb			ld (debug_mark+1),a  
2f1b 3a 25 2f			ld a, (.dmark+2)  
2f1e 32 79 fb			ld (debug_mark+2),a  
2f21 18 03			jr .pastdmark  
2f23 ..			.dmark: db "2S_"  
2f26 f1			.pastdmark: pop af  
2f27			endm  
# End of macro DMARK
2f27						CALLMONITOR 
2f27 cd 74 17			call break_point_state  
2f2a				endm  
# End of macro CALLMONITOR
2f2a					endif 
2f2a			 
2f2a					FORTH_DSP_VALUEHL 
2f2a cd fb 1e			call macro_dsp_valuehl 
2f2d				endm 
# End of macro FORTH_DSP_VALUEHL
2f2d			 
2f2d e5					push hl   ; save address 
2f2e			 
2f2e			 
2f2e					FORTH_DSP_POP 
2f2e cd b3 1f			call macro_forth_dsp_pop 
2f31				endm 
# End of macro FORTH_DSP_POP
2f31			 
2f31					 
2f31					FORTH_DSP_VALUEHL 
2f31 cd fb 1e			call macro_dsp_valuehl 
2f34				endm 
# End of macro FORTH_DSP_VALUEHL
2f34			 
2f34					FORTH_DSP_POP 
2f34 cd b3 1f			call macro_forth_dsp_pop 
2f37				endm 
# End of macro FORTH_DSP_POP
2f37			 
2f37 eb					ex de, hl    ; value now in de 
2f38			 
2f38 e1					pop hl 
2f39			 
2f39 73					ld (hl), e 
2f3a			 
2f3a 23					inc hl 
2f3b			 
2f3b 72					ld (hl), d 
2f3c			 
2f3c			 
2f3c				       NEXTW 
2f3c c3 6d 20			jp macro_next 
2f3f				endm 
# End of macro NEXTW
2f3f			.CONFIG: 
2f3f				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2f3f 6f				db WORD_SYS_CORE+91             
2f40 50 2f			dw .ENDCORE            
2f42 07				db 6 + 1 
2f43 .. 00			db "CONFIG",0              
2f4a				endm 
# End of macro CWHEAD
2f4a			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2f4a			 
2f4a cd aa 13				call config 
2f4d					NEXTW 
2f4d c3 6d 20			jp macro_next 
2f50				endm 
# End of macro NEXTW
2f50			.ENDCORE: 
2f50			 
2f50			; eof 
2f50			 
2f50			 
# End of file forth_words_core.asm
2f50			include "forth_words_flow.asm" 
2f50			 
2f50			; | ## Program Flow Words 
2f50			 
2f50			.IF: 
2f50				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f50 1e				db WORD_SYS_CORE+10             
2f51 45 30			dw .THEN            
2f53 03				db 2 + 1 
2f54 .. 00			db "IF",0              
2f57				endm 
# End of macro CWHEAD
2f57			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f57			; 
2f57					if DEBUG_FORTH_WORDS_KEY 
2f57						DMARK "IF." 
2f57 f5				push af  
2f58 3a 6c 2f			ld a, (.dmark)  
2f5b 32 77 fb			ld (debug_mark),a  
2f5e 3a 6d 2f			ld a, (.dmark+1)  
2f61 32 78 fb			ld (debug_mark+1),a  
2f64 3a 6e 2f			ld a, (.dmark+2)  
2f67 32 79 fb			ld (debug_mark+2),a  
2f6a 18 03			jr .pastdmark  
2f6c ..			.dmark: db "IF."  
2f6f f1			.pastdmark: pop af  
2f70			endm  
# End of macro DMARK
2f70						CALLMONITOR 
2f70 cd 74 17			call break_point_state  
2f73				endm  
# End of macro CALLMONITOR
2f73					endif 
2f73			; eval TOS 
2f73			 
2f73				FORTH_DSP_VALUEHL 
2f73 cd fb 1e			call macro_dsp_valuehl 
2f76				endm 
# End of macro FORTH_DSP_VALUEHL
2f76			 
2f76			;	push hl 
2f76				FORTH_DSP_POP 
2f76 cd b3 1f			call macro_forth_dsp_pop 
2f79				endm 
# End of macro FORTH_DSP_POP
2f79			;	pop hl 
2f79			 
2f79					if DEBUG_FORTH_WORDS 
2f79						DMARK "IF1" 
2f79 f5				push af  
2f7a 3a 8e 2f			ld a, (.dmark)  
2f7d 32 77 fb			ld (debug_mark),a  
2f80 3a 8f 2f			ld a, (.dmark+1)  
2f83 32 78 fb			ld (debug_mark+1),a  
2f86 3a 90 2f			ld a, (.dmark+2)  
2f89 32 79 fb			ld (debug_mark+2),a  
2f8c 18 03			jr .pastdmark  
2f8e ..			.dmark: db "IF1"  
2f91 f1			.pastdmark: pop af  
2f92			endm  
# End of macro DMARK
2f92						CALLMONITOR 
2f92 cd 74 17			call break_point_state  
2f95				endm  
# End of macro CALLMONITOR
2f95					endif 
2f95 b7				or a        ; clear carry flag 
2f96 11 00 00			ld de, 0 
2f99 eb				ex de,hl 
2f9a ed 52			sbc hl, de 
2f9c c2 26 30			jp nz, .iftrue 
2f9f			 
2f9f					if DEBUG_FORTH_WORDS 
2f9f						DMARK "IF2" 
2f9f f5				push af  
2fa0 3a b4 2f			ld a, (.dmark)  
2fa3 32 77 fb			ld (debug_mark),a  
2fa6 3a b5 2f			ld a, (.dmark+1)  
2fa9 32 78 fb			ld (debug_mark+1),a  
2fac 3a b6 2f			ld a, (.dmark+2)  
2faf 32 79 fb			ld (debug_mark+2),a  
2fb2 18 03			jr .pastdmark  
2fb4 ..			.dmark: db "IF2"  
2fb7 f1			.pastdmark: pop af  
2fb8			endm  
# End of macro DMARK
2fb8						CALLMONITOR 
2fb8 cd 74 17			call break_point_state  
2fbb				endm  
# End of macro CALLMONITOR
2fbb					endif 
2fbb			 
2fbb			; if not true then skip to THEN 
2fbb			 
2fbb				; TODO get tok_ptr 
2fbb				; TODO consume toks until we get to THEN 
2fbb			 
2fbb 2a 1e f1			ld hl, (os_tok_ptr) 
2fbe					if DEBUG_FORTH_WORDS 
2fbe						DMARK "IF3" 
2fbe f5				push af  
2fbf 3a d3 2f			ld a, (.dmark)  
2fc2 32 77 fb			ld (debug_mark),a  
2fc5 3a d4 2f			ld a, (.dmark+1)  
2fc8 32 78 fb			ld (debug_mark+1),a  
2fcb 3a d5 2f			ld a, (.dmark+2)  
2fce 32 79 fb			ld (debug_mark+2),a  
2fd1 18 03			jr .pastdmark  
2fd3 ..			.dmark: db "IF3"  
2fd6 f1			.pastdmark: pop af  
2fd7			endm  
# End of macro DMARK
2fd7						CALLMONITOR 
2fd7 cd 74 17			call break_point_state  
2fda				endm  
# End of macro CALLMONITOR
2fda						 
2fda					endif 
2fda 11 21 30			ld de, .ifthen 
2fdd					if DEBUG_FORTH_WORDS 
2fdd						DMARK "IF4" 
2fdd f5				push af  
2fde 3a f2 2f			ld a, (.dmark)  
2fe1 32 77 fb			ld (debug_mark),a  
2fe4 3a f3 2f			ld a, (.dmark+1)  
2fe7 32 78 fb			ld (debug_mark+1),a  
2fea 3a f4 2f			ld a, (.dmark+2)  
2fed 32 79 fb			ld (debug_mark+2),a  
2ff0 18 03			jr .pastdmark  
2ff2 ..			.dmark: db "IF4"  
2ff5 f1			.pastdmark: pop af  
2ff6			endm  
# End of macro DMARK
2ff6						CALLMONITOR 
2ff6 cd 74 17			call break_point_state  
2ff9				endm  
# End of macro CALLMONITOR
2ff9					endif 
2ff9 cd 88 21			call findnexttok  
2ffc			 
2ffc					if DEBUG_FORTH_WORDS 
2ffc						DMARK "IF5" 
2ffc f5				push af  
2ffd 3a 11 30			ld a, (.dmark)  
3000 32 77 fb			ld (debug_mark),a  
3003 3a 12 30			ld a, (.dmark+1)  
3006 32 78 fb			ld (debug_mark+1),a  
3009 3a 13 30			ld a, (.dmark+2)  
300c 32 79 fb			ld (debug_mark+2),a  
300f 18 03			jr .pastdmark  
3011 ..			.dmark: db "IF5"  
3014 f1			.pastdmark: pop af  
3015			endm  
# End of macro DMARK
3015						CALLMONITOR 
3015 cd 74 17			call break_point_state  
3018				endm  
# End of macro CALLMONITOR
3018					endif 
3018				; TODO replace below with ; exec using tok_ptr 
3018 22 1e f1			ld (os_tok_ptr), hl 
301b c3 fe 20			jp exec1 
301e				NEXTW 
301e c3 6d 20			jp macro_next 
3021				endm 
# End of macro NEXTW
3021			 
3021 .. 00		.ifthen:  db "THEN",0 
3026			 
3026			.iftrue:		 
3026				; Exec next words normally 
3026			 
3026				; if true then exec following IF as normal 
3026					if DEBUG_FORTH_WORDS 
3026						DMARK "IFT" 
3026 f5				push af  
3027 3a 3b 30			ld a, (.dmark)  
302a 32 77 fb			ld (debug_mark),a  
302d 3a 3c 30			ld a, (.dmark+1)  
3030 32 78 fb			ld (debug_mark+1),a  
3033 3a 3d 30			ld a, (.dmark+2)  
3036 32 79 fb			ld (debug_mark+2),a  
3039 18 03			jr .pastdmark  
303b ..			.dmark: db "IFT"  
303e f1			.pastdmark: pop af  
303f			endm  
# End of macro DMARK
303f						CALLMONITOR 
303f cd 74 17			call break_point_state  
3042				endm  
# End of macro CALLMONITOR
3042					endif 
3042			 
3042					NEXTW 
3042 c3 6d 20			jp macro_next 
3045				endm 
# End of macro NEXTW
3045			.THEN: 
3045				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3045 1f				db WORD_SYS_CORE+11             
3046 6d 30			dw .ELSE            
3048 05				db 4 + 1 
3049 .. 00			db "THEN",0              
304e				endm 
# End of macro CWHEAD
304e			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
304e					if DEBUG_FORTH_WORDS_KEY 
304e						DMARK "THN" 
304e f5				push af  
304f 3a 63 30			ld a, (.dmark)  
3052 32 77 fb			ld (debug_mark),a  
3055 3a 64 30			ld a, (.dmark+1)  
3058 32 78 fb			ld (debug_mark+1),a  
305b 3a 65 30			ld a, (.dmark+2)  
305e 32 79 fb			ld (debug_mark+2),a  
3061 18 03			jr .pastdmark  
3063 ..			.dmark: db "THN"  
3066 f1			.pastdmark: pop af  
3067			endm  
# End of macro DMARK
3067						CALLMONITOR 
3067 cd 74 17			call break_point_state  
306a				endm  
# End of macro CALLMONITOR
306a					endif 
306a					NEXTW 
306a c3 6d 20			jp macro_next 
306d				endm 
# End of macro NEXTW
306d			.ELSE: 
306d				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
306d 20				db WORD_SYS_CORE+12             
306e 95 30			dw .DO            
3070 03				db 2 + 1 
3071 .. 00			db "ELSE",0              
3076				endm 
# End of macro CWHEAD
3076			; | ELSE ( -- ) Not supported - does nothing | TODO 
3076			 
3076					if DEBUG_FORTH_WORDS_KEY 
3076						DMARK "ELS" 
3076 f5				push af  
3077 3a 8b 30			ld a, (.dmark)  
307a 32 77 fb			ld (debug_mark),a  
307d 3a 8c 30			ld a, (.dmark+1)  
3080 32 78 fb			ld (debug_mark+1),a  
3083 3a 8d 30			ld a, (.dmark+2)  
3086 32 79 fb			ld (debug_mark+2),a  
3089 18 03			jr .pastdmark  
308b ..			.dmark: db "ELS"  
308e f1			.pastdmark: pop af  
308f			endm  
# End of macro DMARK
308f						CALLMONITOR 
308f cd 74 17			call break_point_state  
3092				endm  
# End of macro CALLMONITOR
3092					endif 
3092			 
3092			 
3092					NEXTW 
3092 c3 6d 20			jp macro_next 
3095				endm 
# End of macro NEXTW
3095			.DO: 
3095				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3095 21				db WORD_SYS_CORE+13             
3096 bc 31			dw .LOOP            
3098 03				db 2 + 1 
3099 .. 00			db "DO",0              
309c				endm 
# End of macro CWHEAD
309c			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
309c			 
309c					if DEBUG_FORTH_WORDS_KEY 
309c						DMARK "DO." 
309c f5				push af  
309d 3a b1 30			ld a, (.dmark)  
30a0 32 77 fb			ld (debug_mark),a  
30a3 3a b2 30			ld a, (.dmark+1)  
30a6 32 78 fb			ld (debug_mark+1),a  
30a9 3a b3 30			ld a, (.dmark+2)  
30ac 32 79 fb			ld (debug_mark+2),a  
30af 18 03			jr .pastdmark  
30b1 ..			.dmark: db "DO."  
30b4 f1			.pastdmark: pop af  
30b5			endm  
# End of macro DMARK
30b5						CALLMONITOR 
30b5 cd 74 17			call break_point_state  
30b8				endm  
# End of macro CALLMONITOR
30b8					endif 
30b8			;  push pc to rsp stack past the DO 
30b8			 
30b8 2a 1e f1				ld hl, (os_tok_ptr) 
30bb 23					inc hl   ; D 
30bc 23					inc hl  ; O 
30bd 23					inc hl   ; null 
30be					if DEBUG_FORTH_WORDS 
30be						DMARK "DO2" 
30be f5				push af  
30bf 3a d3 30			ld a, (.dmark)  
30c2 32 77 fb			ld (debug_mark),a  
30c5 3a d4 30			ld a, (.dmark+1)  
30c8 32 78 fb			ld (debug_mark+1),a  
30cb 3a d5 30			ld a, (.dmark+2)  
30ce 32 79 fb			ld (debug_mark+2),a  
30d1 18 03			jr .pastdmark  
30d3 ..			.dmark: db "DO2"  
30d6 f1			.pastdmark: pop af  
30d7			endm  
# End of macro DMARK
30d7						CALLMONITOR 
30d7 cd 74 17			call break_point_state  
30da				endm  
# End of macro CALLMONITOR
30da					endif 
30da					FORTH_RSP_NEXT 
30da cd ab 1c			call macro_forth_rsp_next 
30dd				endm 
# End of macro FORTH_RSP_NEXT
30dd					if DEBUG_FORTH_WORDS 
30dd						DMARK "DO3" 
30dd f5				push af  
30de 3a f2 30			ld a, (.dmark)  
30e1 32 77 fb			ld (debug_mark),a  
30e4 3a f3 30			ld a, (.dmark+1)  
30e7 32 78 fb			ld (debug_mark+1),a  
30ea 3a f4 30			ld a, (.dmark+2)  
30ed 32 79 fb			ld (debug_mark+2),a  
30f0 18 03			jr .pastdmark  
30f2 ..			.dmark: db "DO3"  
30f5 f1			.pastdmark: pop af  
30f6			endm  
# End of macro DMARK
30f6						CALLMONITOR 
30f6 cd 74 17			call break_point_state  
30f9				endm  
# End of macro CALLMONITOR
30f9					endif 
30f9			 
30f9					;if DEBUG_FORTH_WORDS 
30f9				;		push hl 
30f9			;		endif  
30f9			 
30f9			; get counters from data stack 
30f9			 
30f9			 
30f9					FORTH_DSP_VALUEHL 
30f9 cd fb 1e			call macro_dsp_valuehl 
30fc				endm 
# End of macro FORTH_DSP_VALUEHL
30fc e5					push hl		 ; hl now has starting counter which needs to be tos 
30fd			 
30fd					if DEBUG_FORTH_WORDS 
30fd						DMARK "DO4" 
30fd f5				push af  
30fe 3a 12 31			ld a, (.dmark)  
3101 32 77 fb			ld (debug_mark),a  
3104 3a 13 31			ld a, (.dmark+1)  
3107 32 78 fb			ld (debug_mark+1),a  
310a 3a 14 31			ld a, (.dmark+2)  
310d 32 79 fb			ld (debug_mark+2),a  
3110 18 03			jr .pastdmark  
3112 ..			.dmark: db "DO4"  
3115 f1			.pastdmark: pop af  
3116			endm  
# End of macro DMARK
3116						CALLMONITOR 
3116 cd 74 17			call break_point_state  
3119				endm  
# End of macro CALLMONITOR
3119					endif 
3119					FORTH_DSP_POP 
3119 cd b3 1f			call macro_forth_dsp_pop 
311c				endm 
# End of macro FORTH_DSP_POP
311c			 
311c					if DEBUG_FORTH_WORDS 
311c						DMARK "DO5" 
311c f5				push af  
311d 3a 31 31			ld a, (.dmark)  
3120 32 77 fb			ld (debug_mark),a  
3123 3a 32 31			ld a, (.dmark+1)  
3126 32 78 fb			ld (debug_mark+1),a  
3129 3a 33 31			ld a, (.dmark+2)  
312c 32 79 fb			ld (debug_mark+2),a  
312f 18 03			jr .pastdmark  
3131 ..			.dmark: db "DO5"  
3134 f1			.pastdmark: pop af  
3135			endm  
# End of macro DMARK
3135						CALLMONITOR 
3135 cd 74 17			call break_point_state  
3138				endm  
# End of macro CALLMONITOR
3138					endif 
3138			 
3138					FORTH_DSP_VALUEHL 
3138 cd fb 1e			call macro_dsp_valuehl 
313b				endm 
# End of macro FORTH_DSP_VALUEHL
313b			;		push hl		 ; hl now has starting limit counter 
313b			 
313b					if DEBUG_FORTH_WORDS 
313b						DMARK "DO6" 
313b f5				push af  
313c 3a 50 31			ld a, (.dmark)  
313f 32 77 fb			ld (debug_mark),a  
3142 3a 51 31			ld a, (.dmark+1)  
3145 32 78 fb			ld (debug_mark+1),a  
3148 3a 52 31			ld a, (.dmark+2)  
314b 32 79 fb			ld (debug_mark+2),a  
314e 18 03			jr .pastdmark  
3150 ..			.dmark: db "DO6"  
3153 f1			.pastdmark: pop af  
3154			endm  
# End of macro DMARK
3154						CALLMONITOR 
3154 cd 74 17			call break_point_state  
3157				endm  
# End of macro CALLMONITOR
3157					endif 
3157					FORTH_DSP_POP 
3157 cd b3 1f			call macro_forth_dsp_pop 
315a				endm 
# End of macro FORTH_DSP_POP
315a			 
315a			; put counters on the loop stack 
315a			 
315a			;		pop hl			 ; limit counter 
315a d1					pop de			; start counter 
315b			 
315b					; push limit counter 
315b			 
315b					if DEBUG_FORTH_WORDS 
315b						DMARK "DO7" 
315b f5				push af  
315c 3a 70 31			ld a, (.dmark)  
315f 32 77 fb			ld (debug_mark),a  
3162 3a 71 31			ld a, (.dmark+1)  
3165 32 78 fb			ld (debug_mark+1),a  
3168 3a 72 31			ld a, (.dmark+2)  
316b 32 79 fb			ld (debug_mark+2),a  
316e 18 03			jr .pastdmark  
3170 ..			.dmark: db "DO7"  
3173 f1			.pastdmark: pop af  
3174			endm  
# End of macro DMARK
3174						CALLMONITOR 
3174 cd 74 17			call break_point_state  
3177				endm  
# End of macro CALLMONITOR
3177					endif 
3177					FORTH_LOOP_NEXT 
3177 cd 2c 1f			call macro_forth_loop_next 
317a				endm 
# End of macro FORTH_LOOP_NEXT
317a			 
317a					; push start counter 
317a			 
317a eb					ex de, hl 
317b					if DEBUG_FORTH_WORDS 
317b						DMARK "DO7" 
317b f5				push af  
317c 3a 90 31			ld a, (.dmark)  
317f 32 77 fb			ld (debug_mark),a  
3182 3a 91 31			ld a, (.dmark+1)  
3185 32 78 fb			ld (debug_mark+1),a  
3188 3a 92 31			ld a, (.dmark+2)  
318b 32 79 fb			ld (debug_mark+2),a  
318e 18 03			jr .pastdmark  
3190 ..			.dmark: db "DO7"  
3193 f1			.pastdmark: pop af  
3194			endm  
# End of macro DMARK
3194						CALLMONITOR 
3194 cd 74 17			call break_point_state  
3197				endm  
# End of macro CALLMONITOR
3197					endif 
3197					FORTH_LOOP_NEXT 
3197 cd 2c 1f			call macro_forth_loop_next 
319a				endm 
# End of macro FORTH_LOOP_NEXT
319a			 
319a			 
319a					; init first round of I counter 
319a			 
319a 22 42 f1				ld (os_current_i), hl 
319d			 
319d					if DEBUG_FORTH_WORDS 
319d						DMARK "DO8" 
319d f5				push af  
319e 3a b2 31			ld a, (.dmark)  
31a1 32 77 fb			ld (debug_mark),a  
31a4 3a b3 31			ld a, (.dmark+1)  
31a7 32 78 fb			ld (debug_mark+1),a  
31aa 3a b4 31			ld a, (.dmark+2)  
31ad 32 79 fb			ld (debug_mark+2),a  
31b0 18 03			jr .pastdmark  
31b2 ..			.dmark: db "DO8"  
31b5 f1			.pastdmark: pop af  
31b6			endm  
# End of macro DMARK
31b6						CALLMONITOR 
31b6 cd 74 17			call break_point_state  
31b9				endm  
# End of macro CALLMONITOR
31b9					endif 
31b9			 
31b9					NEXTW 
31b9 c3 6d 20			jp macro_next 
31bc				endm 
# End of macro NEXTW
31bc			.LOOP: 
31bc				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31bc 22				db WORD_SYS_CORE+14             
31bd d4 32			dw .I            
31bf 05				db 4 + 1 
31c0 .. 00			db "LOOP",0              
31c5				endm 
# End of macro CWHEAD
31c5			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31c5			 
31c5				; pop tos as current loop count to hl 
31c5			 
31c5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31c5			 
31c5				FORTH_LOOP_TOS 
31c5 cd 5f 1f			call macro_forth_loop_tos 
31c8				endm 
# End of macro FORTH_LOOP_TOS
31c8 e5				push hl 
31c9			 
31c9					if DEBUG_FORTH_WORDS_KEY 
31c9						DMARK "LOP" 
31c9 f5				push af  
31ca 3a de 31			ld a, (.dmark)  
31cd 32 77 fb			ld (debug_mark),a  
31d0 3a df 31			ld a, (.dmark+1)  
31d3 32 78 fb			ld (debug_mark+1),a  
31d6 3a e0 31			ld a, (.dmark+2)  
31d9 32 79 fb			ld (debug_mark+2),a  
31dc 18 03			jr .pastdmark  
31de ..			.dmark: db "LOP"  
31e1 f1			.pastdmark: pop af  
31e2			endm  
# End of macro DMARK
31e2						CALLMONITOR 
31e2 cd 74 17			call break_point_state  
31e5				endm  
# End of macro CALLMONITOR
31e5					endif 
31e5				; next item on the stack is the limit. get it 
31e5			 
31e5			 
31e5				FORTH_LOOP_POP 
31e5 cd 69 1f			call macro_forth_loop_pop 
31e8				endm 
# End of macro FORTH_LOOP_POP
31e8			 
31e8				FORTH_LOOP_TOS 
31e8 cd 5f 1f			call macro_forth_loop_tos 
31eb				endm 
# End of macro FORTH_LOOP_TOS
31eb			 
31eb d1				pop de		 ; de = i, hl = limit 
31ec			 
31ec					if DEBUG_FORTH_WORDS 
31ec						DMARK "LP1" 
31ec f5				push af  
31ed 3a 01 32			ld a, (.dmark)  
31f0 32 77 fb			ld (debug_mark),a  
31f3 3a 02 32			ld a, (.dmark+1)  
31f6 32 78 fb			ld (debug_mark+1),a  
31f9 3a 03 32			ld a, (.dmark+2)  
31fc 32 79 fb			ld (debug_mark+2),a  
31ff 18 03			jr .pastdmark  
3201 ..			.dmark: db "LP1"  
3204 f1			.pastdmark: pop af  
3205			endm  
# End of macro DMARK
3205						CALLMONITOR 
3205 cd 74 17			call break_point_state  
3208				endm  
# End of macro CALLMONITOR
3208					endif 
3208			 
3208				; go back to previous word 
3208			 
3208 d5				push de    ; save I for inc later 
3209			 
3209			 
3209				; get limit 
3209				;  is I at limit? 
3209			 
3209			 
3209					if DEBUG_FORTH_WORDS 
3209						DMARK "LP1" 
3209 f5				push af  
320a 3a 1e 32			ld a, (.dmark)  
320d 32 77 fb			ld (debug_mark),a  
3210 3a 1f 32			ld a, (.dmark+1)  
3213 32 78 fb			ld (debug_mark+1),a  
3216 3a 20 32			ld a, (.dmark+2)  
3219 32 79 fb			ld (debug_mark+2),a  
321c 18 03			jr .pastdmark  
321e ..			.dmark: db "LP1"  
3221 f1			.pastdmark: pop af  
3222			endm  
# End of macro DMARK
3222						CALLMONITOR 
3222 cd 74 17			call break_point_state  
3225				endm  
# End of macro CALLMONITOR
3225					endif 
3225			 
3225 ed 52			sbc hl, de 
3227			 
3227			 
3227				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3227			 
3227 20 26				jr nz, .loopnotdone 
3229			 
3229 e1				pop hl   ; get rid of saved I 
322a				FORTH_LOOP_POP     ; get rid of limit 
322a cd 69 1f			call macro_forth_loop_pop 
322d				endm 
# End of macro FORTH_LOOP_POP
322d			 
322d				FORTH_RSP_POP     ; get rid of DO ptr 
322d cd cc 1c			call macro_forth_rsp_pop 
3230				endm 
# End of macro FORTH_RSP_POP
3230			 
3230			if DEBUG_FORTH_WORDS 
3230						DMARK "LP>" 
3230 f5				push af  
3231 3a 45 32			ld a, (.dmark)  
3234 32 77 fb			ld (debug_mark),a  
3237 3a 46 32			ld a, (.dmark+1)  
323a 32 78 fb			ld (debug_mark+1),a  
323d 3a 47 32			ld a, (.dmark+2)  
3240 32 79 fb			ld (debug_mark+2),a  
3243 18 03			jr .pastdmark  
3245 ..			.dmark: db "LP>"  
3248 f1			.pastdmark: pop af  
3249			endm  
# End of macro DMARK
3249				CALLMONITOR 
3249 cd 74 17			call break_point_state  
324c				endm  
# End of macro CALLMONITOR
324c			endif 
324c			 
324c					NEXTW 
324c c3 6d 20			jp macro_next 
324f				endm 
# End of macro NEXTW
324f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
324f			 
324f			.loopnotdone: 
324f			 
324f e1				pop hl    ; get I 
3250 23				inc hl 
3251			 
3251			   	; save new I 
3251			 
3251			 
3251					; set I counter 
3251			 
3251 22 42 f1				ld (os_current_i), hl 
3254			 
3254					if DEBUG_FORTH_WORDS 
3254						DMARK "LPN" 
3254 f5				push af  
3255 3a 69 32			ld a, (.dmark)  
3258 32 77 fb			ld (debug_mark),a  
325b 3a 6a 32			ld a, (.dmark+1)  
325e 32 78 fb			ld (debug_mark+1),a  
3261 3a 6b 32			ld a, (.dmark+2)  
3264 32 79 fb			ld (debug_mark+2),a  
3267 18 03			jr .pastdmark  
3269 ..			.dmark: db "LPN"  
326c f1			.pastdmark: pop af  
326d			endm  
# End of macro DMARK
326d					CALLMONITOR 
326d cd 74 17			call break_point_state  
3270				endm  
# End of macro CALLMONITOR
3270					endif 
3270					 
3270				FORTH_LOOP_NEXT 
3270 cd 2c 1f			call macro_forth_loop_next 
3273				endm 
# End of macro FORTH_LOOP_NEXT
3273			 
3273			 
3273					if DEBUG_FORTH_WORDS 
3273 eb						ex de,hl 
3274					endif 
3274			 
3274			;	; get DO ptr 
3274			; 
3274					if DEBUG_FORTH_WORDS 
3274						DMARK "LP7" 
3274 f5				push af  
3275 3a 89 32			ld a, (.dmark)  
3278 32 77 fb			ld (debug_mark),a  
327b 3a 8a 32			ld a, (.dmark+1)  
327e 32 78 fb			ld (debug_mark+1),a  
3281 3a 8b 32			ld a, (.dmark+2)  
3284 32 79 fb			ld (debug_mark+2),a  
3287 18 03			jr .pastdmark  
3289 ..			.dmark: db "LP7"  
328c f1			.pastdmark: pop af  
328d			endm  
# End of macro DMARK
328d					CALLMONITOR 
328d cd 74 17			call break_point_state  
3290				endm  
# End of macro CALLMONITOR
3290					endif 
3290				FORTH_RSP_TOS 
3290 cd c2 1c			call macro_forth_rsp_tos 
3293				endm 
# End of macro FORTH_RSP_TOS
3293			 
3293					if DEBUG_FORTH_WORDS 
3293						DMARK "LP8" 
3293 f5				push af  
3294 3a a8 32			ld a, (.dmark)  
3297 32 77 fb			ld (debug_mark),a  
329a 3a a9 32			ld a, (.dmark+1)  
329d 32 78 fb			ld (debug_mark+1),a  
32a0 3a aa 32			ld a, (.dmark+2)  
32a3 32 79 fb			ld (debug_mark+2),a  
32a6 18 03			jr .pastdmark  
32a8 ..			.dmark: db "LP8"  
32ab f1			.pastdmark: pop af  
32ac			endm  
# End of macro DMARK
32ac					CALLMONITOR 
32ac cd 74 17			call break_point_state  
32af				endm  
# End of macro CALLMONITOR
32af					endif 
32af				;push hl 
32af			 
32af				; not going to DO any more 
32af				; get rid of the RSP pointer as DO will add it back in 
32af				;FORTH_RSP_POP 
32af				;pop hl 
32af			 
32af				;ld hl,(cli_ret_sp) 
32af				;ld e, (hl) 
32af				;inc hl 
32af				;ld d, (hl) 
32af				;ex de,hl 
32af 22 1e f1			ld (os_tok_ptr), hl 
32b2					if DEBUG_FORTH_WORDS 
32b2						DMARK "LP<" 
32b2 f5				push af  
32b3 3a c7 32			ld a, (.dmark)  
32b6 32 77 fb			ld (debug_mark),a  
32b9 3a c8 32			ld a, (.dmark+1)  
32bc 32 78 fb			ld (debug_mark+1),a  
32bf 3a c9 32			ld a, (.dmark+2)  
32c2 32 79 fb			ld (debug_mark+2),a  
32c5 18 03			jr .pastdmark  
32c7 ..			.dmark: db "LP<"  
32ca f1			.pastdmark: pop af  
32cb			endm  
# End of macro DMARK
32cb					CALLMONITOR 
32cb cd 74 17			call break_point_state  
32ce				endm  
# End of macro CALLMONITOR
32ce				endif 
32ce c3 fe 20			jp exec1 
32d1			 
32d1					 
32d1			 
32d1			 
32d1					NEXTW 
32d1 c3 6d 20			jp macro_next 
32d4				endm 
# End of macro NEXTW
32d4			.I:  
32d4			 
32d4				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
32d4 5e				db WORD_SYS_CORE+74             
32d5 ff 32			dw .DLOOP            
32d7 02				db 1 + 1 
32d8 .. 00			db "I",0              
32da				endm 
# End of macro CWHEAD
32da			; | I ( -- ) Current loop counter | DONE 
32da					if DEBUG_FORTH_WORDS_KEY 
32da						DMARK "I.." 
32da f5				push af  
32db 3a ef 32			ld a, (.dmark)  
32de 32 77 fb			ld (debug_mark),a  
32e1 3a f0 32			ld a, (.dmark+1)  
32e4 32 78 fb			ld (debug_mark+1),a  
32e7 3a f1 32			ld a, (.dmark+2)  
32ea 32 79 fb			ld (debug_mark+2),a  
32ed 18 03			jr .pastdmark  
32ef ..			.dmark: db "I.."  
32f2 f1			.pastdmark: pop af  
32f3			endm  
# End of macro DMARK
32f3						CALLMONITOR 
32f3 cd 74 17			call break_point_state  
32f6				endm  
# End of macro CALLMONITOR
32f6					endif 
32f6			 
32f6 2a 42 f1				ld hl,(os_current_i) 
32f9 cd 04 1d				call forth_push_numhl 
32fc			 
32fc					NEXTW 
32fc c3 6d 20			jp macro_next 
32ff				endm 
# End of macro NEXTW
32ff			.DLOOP: 
32ff				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32ff 5f				db WORD_SYS_CORE+75             
3300 e0 33			dw .REPEAT            
3302 06				db 5 + 1 
3303 .. 00			db "-LOOP",0              
3309				endm 
# End of macro CWHEAD
3309			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3309				; pop tos as current loop count to hl 
3309					if DEBUG_FORTH_WORDS_KEY 
3309						DMARK "-LP" 
3309 f5				push af  
330a 3a 1e 33			ld a, (.dmark)  
330d 32 77 fb			ld (debug_mark),a  
3310 3a 1f 33			ld a, (.dmark+1)  
3313 32 78 fb			ld (debug_mark+1),a  
3316 3a 20 33			ld a, (.dmark+2)  
3319 32 79 fb			ld (debug_mark+2),a  
331c 18 03			jr .pastdmark  
331e ..			.dmark: db "-LP"  
3321 f1			.pastdmark: pop af  
3322			endm  
# End of macro DMARK
3322						CALLMONITOR 
3322 cd 74 17			call break_point_state  
3325				endm  
# End of macro CALLMONITOR
3325					endif 
3325			 
3325				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3325			 
3325				FORTH_LOOP_TOS 
3325 cd 5f 1f			call macro_forth_loop_tos 
3328				endm 
# End of macro FORTH_LOOP_TOS
3328 e5				push hl 
3329			 
3329					if DEBUG_FORTH_WORDS 
3329						DMARK "-LP" 
3329 f5				push af  
332a 3a 3e 33			ld a, (.dmark)  
332d 32 77 fb			ld (debug_mark),a  
3330 3a 3f 33			ld a, (.dmark+1)  
3333 32 78 fb			ld (debug_mark+1),a  
3336 3a 40 33			ld a, (.dmark+2)  
3339 32 79 fb			ld (debug_mark+2),a  
333c 18 03			jr .pastdmark  
333e ..			.dmark: db "-LP"  
3341 f1			.pastdmark: pop af  
3342			endm  
# End of macro DMARK
3342						CALLMONITOR 
3342 cd 74 17			call break_point_state  
3345				endm  
# End of macro CALLMONITOR
3345					endif 
3345				; next item on the stack is the limit. get it 
3345			 
3345			 
3345				FORTH_LOOP_POP 
3345 cd 69 1f			call macro_forth_loop_pop 
3348				endm 
# End of macro FORTH_LOOP_POP
3348			 
3348				FORTH_LOOP_TOS 
3348 cd 5f 1f			call macro_forth_loop_tos 
334b				endm 
# End of macro FORTH_LOOP_TOS
334b			 
334b d1				pop de		 ; de = i, hl = limit 
334c			 
334c					if DEBUG_FORTH_WORDS 
334c						DMARK "-L1" 
334c f5				push af  
334d 3a 61 33			ld a, (.dmark)  
3350 32 77 fb			ld (debug_mark),a  
3353 3a 62 33			ld a, (.dmark+1)  
3356 32 78 fb			ld (debug_mark+1),a  
3359 3a 63 33			ld a, (.dmark+2)  
335c 32 79 fb			ld (debug_mark+2),a  
335f 18 03			jr .pastdmark  
3361 ..			.dmark: db "-L1"  
3364 f1			.pastdmark: pop af  
3365			endm  
# End of macro DMARK
3365						CALLMONITOR 
3365 cd 74 17			call break_point_state  
3368				endm  
# End of macro CALLMONITOR
3368					endif 
3368			 
3368				; go back to previous word 
3368			 
3368 d5				push de    ; save I for inc later 
3369			 
3369			 
3369				; get limit 
3369				;  is I at limit? 
3369			 
3369			 
3369					if DEBUG_FORTH_WORDS 
3369						DMARK "-L1" 
3369 f5				push af  
336a 3a 7e 33			ld a, (.dmark)  
336d 32 77 fb			ld (debug_mark),a  
3370 3a 7f 33			ld a, (.dmark+1)  
3373 32 78 fb			ld (debug_mark+1),a  
3376 3a 80 33			ld a, (.dmark+2)  
3379 32 79 fb			ld (debug_mark+2),a  
337c 18 03			jr .pastdmark  
337e ..			.dmark: db "-L1"  
3381 f1			.pastdmark: pop af  
3382			endm  
# End of macro DMARK
3382						CALLMONITOR 
3382 cd 74 17			call break_point_state  
3385				endm  
# End of macro CALLMONITOR
3385					endif 
3385			 
3385 ed 52			sbc hl, de 
3387			 
3387			 
3387				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3387			 
3387 20 26				jr nz, .mloopnotdone 
3389			 
3389 e1				pop hl   ; get rid of saved I 
338a				FORTH_LOOP_POP     ; get rid of limit 
338a cd 69 1f			call macro_forth_loop_pop 
338d				endm 
# End of macro FORTH_LOOP_POP
338d			 
338d				FORTH_RSP_POP     ; get rid of DO ptr 
338d cd cc 1c			call macro_forth_rsp_pop 
3390				endm 
# End of macro FORTH_RSP_POP
3390			 
3390			if DEBUG_FORTH_WORDS 
3390						DMARK "-L>" 
3390 f5				push af  
3391 3a a5 33			ld a, (.dmark)  
3394 32 77 fb			ld (debug_mark),a  
3397 3a a6 33			ld a, (.dmark+1)  
339a 32 78 fb			ld (debug_mark+1),a  
339d 3a a7 33			ld a, (.dmark+2)  
33a0 32 79 fb			ld (debug_mark+2),a  
33a3 18 03			jr .pastdmark  
33a5 ..			.dmark: db "-L>"  
33a8 f1			.pastdmark: pop af  
33a9			endm  
# End of macro DMARK
33a9				CALLMONITOR 
33a9 cd 74 17			call break_point_state  
33ac				endm  
# End of macro CALLMONITOR
33ac			endif 
33ac			 
33ac					NEXTW 
33ac c3 6d 20			jp macro_next 
33af				endm 
# End of macro NEXTW
33af				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33af			 
33af			.mloopnotdone: 
33af			 
33af e1				pop hl    ; get I 
33b0 2b				dec hl 
33b1			 
33b1			   	; save new I 
33b1			 
33b1			 
33b1					; set I counter 
33b1			 
33b1 22 42 f1				ld (os_current_i), hl 
33b4			 
33b4					 
33b4				FORTH_LOOP_NEXT 
33b4 cd 2c 1f			call macro_forth_loop_next 
33b7				endm 
# End of macro FORTH_LOOP_NEXT
33b7			 
33b7			 
33b7					if DEBUG_FORTH_WORDS 
33b7 eb						ex de,hl 
33b8					endif 
33b8			 
33b8			;	; get DO ptr 
33b8			; 
33b8				FORTH_RSP_TOS 
33b8 cd c2 1c			call macro_forth_rsp_tos 
33bb				endm 
# End of macro FORTH_RSP_TOS
33bb			 
33bb				;push hl 
33bb			 
33bb				; not going to DO any more 
33bb				; get rid of the RSP pointer as DO will add it back in 
33bb				;FORTH_RSP_POP 
33bb				;pop hl 
33bb			 
33bb			 
33bb 22 1e f1			ld (os_tok_ptr), hl 
33be					if DEBUG_FORTH_WORDS 
33be						DMARK "-L<" 
33be f5				push af  
33bf 3a d3 33			ld a, (.dmark)  
33c2 32 77 fb			ld (debug_mark),a  
33c5 3a d4 33			ld a, (.dmark+1)  
33c8 32 78 fb			ld (debug_mark+1),a  
33cb 3a d5 33			ld a, (.dmark+2)  
33ce 32 79 fb			ld (debug_mark+2),a  
33d1 18 03			jr .pastdmark  
33d3 ..			.dmark: db "-L<"  
33d6 f1			.pastdmark: pop af  
33d7			endm  
# End of macro DMARK
33d7					CALLMONITOR 
33d7 cd 74 17			call break_point_state  
33da				endm  
# End of macro CALLMONITOR
33da				endif 
33da c3 fe 20			jp exec1 
33dd			 
33dd					 
33dd			 
33dd			 
33dd			 
33dd				NEXTW 
33dd c3 6d 20			jp macro_next 
33e0				endm 
# End of macro NEXTW
33e0			 
33e0			 
33e0			 
33e0			 
33e0			.REPEAT: 
33e0				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33e0 71				db WORD_SYS_CORE+93             
33e1 33 34			dw .UNTIL            
33e3 06				db 5 + 1 
33e4 .. 00			db "REPEAT",0              
33eb				endm 
# End of macro CWHEAD
33eb			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33eb			;  push pc to rsp stack past the REPEAT 
33eb					if DEBUG_FORTH_WORDS_KEY 
33eb						DMARK "REP" 
33eb f5				push af  
33ec 3a 00 34			ld a, (.dmark)  
33ef 32 77 fb			ld (debug_mark),a  
33f2 3a 01 34			ld a, (.dmark+1)  
33f5 32 78 fb			ld (debug_mark+1),a  
33f8 3a 02 34			ld a, (.dmark+2)  
33fb 32 79 fb			ld (debug_mark+2),a  
33fe 18 03			jr .pastdmark  
3400 ..			.dmark: db "REP"  
3403 f1			.pastdmark: pop af  
3404			endm  
# End of macro DMARK
3404						CALLMONITOR 
3404 cd 74 17			call break_point_state  
3407				endm  
# End of macro CALLMONITOR
3407					endif 
3407			 
3407 2a 1e f1				ld hl, (os_tok_ptr) 
340a 23					inc hl   ; R 
340b 23					inc hl  ; E 
340c 23					inc hl   ; P 
340d 23					inc hl   ; E 
340e 23					inc hl   ; A 
340f 23					inc hl   ; T 
3410 23					inc hl   ; zero 
3411					FORTH_RSP_NEXT 
3411 cd ab 1c			call macro_forth_rsp_next 
3414				endm 
# End of macro FORTH_RSP_NEXT
3414			 
3414			 
3414					if DEBUG_FORTH_WORDS 
3414						DMARK "REP" 
3414 f5				push af  
3415 3a 29 34			ld a, (.dmark)  
3418 32 77 fb			ld (debug_mark),a  
341b 3a 2a 34			ld a, (.dmark+1)  
341e 32 78 fb			ld (debug_mark+1),a  
3421 3a 2b 34			ld a, (.dmark+2)  
3424 32 79 fb			ld (debug_mark+2),a  
3427 18 03			jr .pastdmark  
3429 ..			.dmark: db "REP"  
342c f1			.pastdmark: pop af  
342d			endm  
# End of macro DMARK
342d						;pop bc    ; TODO BUG ?????? what is this for???? 
342d						CALLMONITOR 
342d cd 74 17			call break_point_state  
3430				endm  
# End of macro CALLMONITOR
3430					endif 
3430			 
3430					NEXTW 
3430 c3 6d 20			jp macro_next 
3433				endm 
# End of macro NEXTW
3433			;	       NEXTW 
3433			 
3433			.UNTIL: 
3433				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3433 72				db WORD_SYS_CORE+94             
3434 ca 34			dw .ENDFLOW            
3436 06				db 5 + 1 
3437 .. 00			db "UNTIL",0              
343d				endm 
# End of macro CWHEAD
343d			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
343d			 
343d				; pop tos as check 
343d			 
343d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
343d			 
343d				FORTH_DSP_VALUEHL 
343d cd fb 1e			call macro_dsp_valuehl 
3440				endm 
# End of macro FORTH_DSP_VALUEHL
3440			 
3440					if DEBUG_FORTH_WORDS_KEY 
3440						DMARK "UNT" 
3440 f5				push af  
3441 3a 55 34			ld a, (.dmark)  
3444 32 77 fb			ld (debug_mark),a  
3447 3a 56 34			ld a, (.dmark+1)  
344a 32 78 fb			ld (debug_mark+1),a  
344d 3a 57 34			ld a, (.dmark+2)  
3450 32 79 fb			ld (debug_mark+2),a  
3453 18 03			jr .pastdmark  
3455 ..			.dmark: db "UNT"  
3458 f1			.pastdmark: pop af  
3459			endm  
# End of macro DMARK
3459						CALLMONITOR 
3459 cd 74 17			call break_point_state  
345c				endm  
# End of macro CALLMONITOR
345c					endif 
345c			 
345c			;	push hl 
345c				FORTH_DSP_POP 
345c cd b3 1f			call macro_forth_dsp_pop 
345f				endm 
# End of macro FORTH_DSP_POP
345f			 
345f			;	pop hl 
345f			 
345f				; test if true 
345f			 
345f cd 49 0d			call ishlzero 
3462			;	ld a,l 
3462			;	add h 
3462			; 
3462			;	cp 0 
3462			 
3462 20 3e			jr nz, .untilnotdone 
3464			 
3464					if DEBUG_FORTH_WORDS 
3464						DMARK "UNf" 
3464 f5				push af  
3465 3a 79 34			ld a, (.dmark)  
3468 32 77 fb			ld (debug_mark),a  
346b 3a 7a 34			ld a, (.dmark+1)  
346e 32 78 fb			ld (debug_mark+1),a  
3471 3a 7b 34			ld a, (.dmark+2)  
3474 32 79 fb			ld (debug_mark+2),a  
3477 18 03			jr .pastdmark  
3479 ..			.dmark: db "UNf"  
347c f1			.pastdmark: pop af  
347d			endm  
# End of macro DMARK
347d						CALLMONITOR 
347d cd 74 17			call break_point_state  
3480				endm  
# End of macro CALLMONITOR
3480					endif 
3480			 
3480			 
3480			 
3480				FORTH_RSP_POP     ; get rid of DO ptr 
3480 cd cc 1c			call macro_forth_rsp_pop 
3483				endm 
# End of macro FORTH_RSP_POP
3483			 
3483			if DEBUG_FORTH_WORDS 
3483						DMARK "UN>" 
3483 f5				push af  
3484 3a 98 34			ld a, (.dmark)  
3487 32 77 fb			ld (debug_mark),a  
348a 3a 99 34			ld a, (.dmark+1)  
348d 32 78 fb			ld (debug_mark+1),a  
3490 3a 9a 34			ld a, (.dmark+2)  
3493 32 79 fb			ld (debug_mark+2),a  
3496 18 03			jr .pastdmark  
3498 ..			.dmark: db "UN>"  
349b f1			.pastdmark: pop af  
349c			endm  
# End of macro DMARK
349c				CALLMONITOR 
349c cd 74 17			call break_point_state  
349f				endm  
# End of macro CALLMONITOR
349f			endif 
349f			 
349f					NEXTW 
349f c3 6d 20			jp macro_next 
34a2				endm 
# End of macro NEXTW
34a2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34a2			 
34a2			.untilnotdone: 
34a2			 
34a2			 
34a2			;	; get DO ptr 
34a2			; 
34a2				FORTH_RSP_TOS 
34a2 cd c2 1c			call macro_forth_rsp_tos 
34a5				endm 
# End of macro FORTH_RSP_TOS
34a5			 
34a5				;push hl 
34a5			 
34a5				; not going to DO any more 
34a5				; get rid of the RSP pointer as DO will add it back in 
34a5				;FORTH_RSP_POP 
34a5				;pop hl 
34a5			 
34a5			 
34a5 22 1e f1			ld (os_tok_ptr), hl 
34a8					if DEBUG_FORTH_WORDS 
34a8						DMARK "UN<" 
34a8 f5				push af  
34a9 3a bd 34			ld a, (.dmark)  
34ac 32 77 fb			ld (debug_mark),a  
34af 3a be 34			ld a, (.dmark+1)  
34b2 32 78 fb			ld (debug_mark+1),a  
34b5 3a bf 34			ld a, (.dmark+2)  
34b8 32 79 fb			ld (debug_mark+2),a  
34bb 18 03			jr .pastdmark  
34bd ..			.dmark: db "UN<"  
34c0 f1			.pastdmark: pop af  
34c1			endm  
# End of macro DMARK
34c1					CALLMONITOR 
34c1 cd 74 17			call break_point_state  
34c4				endm  
# End of macro CALLMONITOR
34c4				endif 
34c4 c3 fe 20			jp exec1 
34c7			 
34c7					 
34c7			 
34c7			 
34c7					NEXTW 
34c7 c3 6d 20			jp macro_next 
34ca				endm 
# End of macro NEXTW
34ca			 
34ca			 
34ca			.ENDFLOW: 
34ca			 
34ca			; eof 
34ca			 
# End of file forth_words_flow.asm
34ca			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
34ca			include "forth_words_logic.asm" 
34ca			 
34ca			; | ## Logic Words 
34ca			 
34ca			.NOT: 
34ca				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
34ca 2d				db WORD_SYS_CORE+25             
34cb 12 35			dw .IS            
34cd 04				db 3 + 1 
34ce .. 00			db "NOT",0              
34d2				endm 
# End of macro CWHEAD
34d2			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
34d2					if DEBUG_FORTH_WORDS_KEY 
34d2						DMARK "NOT" 
34d2 f5				push af  
34d3 3a e7 34			ld a, (.dmark)  
34d6 32 77 fb			ld (debug_mark),a  
34d9 3a e8 34			ld a, (.dmark+1)  
34dc 32 78 fb			ld (debug_mark+1),a  
34df 3a e9 34			ld a, (.dmark+2)  
34e2 32 79 fb			ld (debug_mark+2),a  
34e5 18 03			jr .pastdmark  
34e7 ..			.dmark: db "NOT"  
34ea f1			.pastdmark: pop af  
34eb			endm  
# End of macro DMARK
34eb						CALLMONITOR 
34eb cd 74 17			call break_point_state  
34ee				endm  
# End of macro CALLMONITOR
34ee					endif 
34ee					FORTH_DSP 
34ee cd c1 1e			call macro_forth_dsp 
34f1				endm 
# End of macro FORTH_DSP
34f1 7e					ld a,(hl)	; get type of value on TOS 
34f2 fe 02				cp DS_TYPE_INUM  
34f4 28 03				jr z, .noti 
34f6					NEXTW 
34f6 c3 6d 20			jp macro_next 
34f9				endm 
# End of macro NEXTW
34f9			.noti:          FORTH_DSP_VALUEHL 
34f9 cd fb 1e			call macro_dsp_valuehl 
34fc				endm 
# End of macro FORTH_DSP_VALUEHL
34fc			;		push hl 
34fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34fc cd b3 1f			call macro_forth_dsp_pop 
34ff				endm 
# End of macro FORTH_DSP_POP
34ff			;		pop hl 
34ff 3e 00				ld a,0 
3501 bd					cp l 
3502 28 04				jr z, .not2t 
3504 2e 00				ld l, 0 
3506 18 02				jr .notip 
3508			 
3508 2e ff		.not2t:		ld l, 255 
350a			 
350a 26 00		.notip:		ld h, 0	 
350c			 
350c cd 04 1d				call forth_push_numhl 
350f					NEXTW 
350f c3 6d 20			jp macro_next 
3512				endm 
# End of macro NEXTW
3512			 
3512			.IS: 
3512				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3512 2d				db WORD_SYS_CORE+25             
3513 38 35			dw .LZERO            
3515 03				db 2 + 1 
3516 .. 00			db "IS",0              
3519				endm 
# End of macro CWHEAD
3519			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3519					if DEBUG_FORTH_WORDS_KEY 
3519						DMARK "IS." 
3519 f5				push af  
351a 3a 2e 35			ld a, (.dmark)  
351d 32 77 fb			ld (debug_mark),a  
3520 3a 2f 35			ld a, (.dmark+1)  
3523 32 78 fb			ld (debug_mark+1),a  
3526 3a 30 35			ld a, (.dmark+2)  
3529 32 79 fb			ld (debug_mark+2),a  
352c 18 03			jr .pastdmark  
352e ..			.dmark: db "IS."  
3531 f1			.pastdmark: pop af  
3532			endm  
# End of macro DMARK
3532						CALLMONITOR 
3532 cd 74 17			call break_point_state  
3535				endm  
# End of macro CALLMONITOR
3535					endif 
3535					NEXTW 
3535 c3 6d 20			jp macro_next 
3538				endm 
# End of macro NEXTW
3538			.LZERO: 
3538				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3538 2d				db WORD_SYS_CORE+25             
3539 42 35			dw .TZERO            
353b 03				db 2 + 1 
353c .. 00			db "0<",0              
353f				endm 
# End of macro CWHEAD
353f			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
353f					NEXTW 
353f c3 6d 20			jp macro_next 
3542				endm 
# End of macro NEXTW
3542			.TZERO: 
3542				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3542 2e				db WORD_SYS_CORE+26             
3543 89 35			dw .LESS            
3545 03				db 2 + 1 
3546 .. 00			db "0=",0              
3549				endm 
# End of macro CWHEAD
3549			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3549				; TODO add floating point number detection 
3549					;v5 FORTH_DSP_VALUE 
3549					if DEBUG_FORTH_WORDS_KEY 
3549						DMARK "0=." 
3549 f5				push af  
354a 3a 5e 35			ld a, (.dmark)  
354d 32 77 fb			ld (debug_mark),a  
3550 3a 5f 35			ld a, (.dmark+1)  
3553 32 78 fb			ld (debug_mark+1),a  
3556 3a 60 35			ld a, (.dmark+2)  
3559 32 79 fb			ld (debug_mark+2),a  
355c 18 03			jr .pastdmark  
355e ..			.dmark: db "0=."  
3561 f1			.pastdmark: pop af  
3562			endm  
# End of macro DMARK
3562						CALLMONITOR 
3562 cd 74 17			call break_point_state  
3565				endm  
# End of macro CALLMONITOR
3565					endif 
3565					FORTH_DSP 
3565 cd c1 1e			call macro_forth_dsp 
3568				endm 
# End of macro FORTH_DSP
3568 7e					ld a,(hl)	; get type of value on TOS 
3569 fe 02				cp DS_TYPE_INUM  
356b 28 00				jr z, .tz_inum 
356d			 
356d				if FORTH_ENABLE_FLOATMATH 
356d					jr .tz_done 
356d			 
356d				endif 
356d					 
356d			 
356d			.tz_inum: 
356d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
356d cd fb 1e			call macro_dsp_valuehl 
3570				endm 
# End of macro FORTH_DSP_VALUEHL
3570			 
3570			;		push hl 
3570			 
3570					; destroy value TOS 
3570			 
3570					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3570 cd b3 1f			call macro_forth_dsp_pop 
3573				endm 
# End of macro FORTH_DSP_POP
3573			 
3573			;		pop hl 
3573			 
3573 3e 00				ld a,0 
3575			 
3575 bd					cp l 
3576 20 08				jr nz, .tz_notzero 
3578			 
3578 bc					cp h 
3579			 
3579 20 05				jr nz, .tz_notzero 
357b			 
357b			 
357b 21 01 00				ld hl, FORTH_TRUE 
357e 18 03				jr .tz_done 
3580			 
3580 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3583			 
3583					; push value back onto stack for another op etc 
3583			 
3583			.tz_done: 
3583 cd 04 1d				call forth_push_numhl 
3586			 
3586					NEXTW 
3586 c3 6d 20			jp macro_next 
3589				endm 
# End of macro NEXTW
3589			.LESS: 
3589				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3589 2f				db WORD_SYS_CORE+27             
358a f2 35			dw .GT            
358c 02				db 1 + 1 
358d .. 00			db "<",0              
358f				endm 
# End of macro CWHEAD
358f			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
358f				; TODO add floating point number detection 
358f					if DEBUG_FORTH_WORDS_KEY 
358f						DMARK "LES" 
358f f5				push af  
3590 3a a4 35			ld a, (.dmark)  
3593 32 77 fb			ld (debug_mark),a  
3596 3a a5 35			ld a, (.dmark+1)  
3599 32 78 fb			ld (debug_mark+1),a  
359c 3a a6 35			ld a, (.dmark+2)  
359f 32 79 fb			ld (debug_mark+2),a  
35a2 18 03			jr .pastdmark  
35a4 ..			.dmark: db "LES"  
35a7 f1			.pastdmark: pop af  
35a8			endm  
# End of macro DMARK
35a8						CALLMONITOR 
35a8 cd 74 17			call break_point_state  
35ab				endm  
# End of macro CALLMONITOR
35ab					endif 
35ab					FORTH_DSP 
35ab cd c1 1e			call macro_forth_dsp 
35ae				endm 
# End of macro FORTH_DSP
35ae					;v5 FORTH_DSP_VALUE 
35ae 7e					ld a,(hl)	; get type of value on TOS 
35af fe 02				cp DS_TYPE_INUM  
35b1 28 00				jr z, .less_inum 
35b3			 
35b3				if FORTH_ENABLE_FLOATMATH 
35b3					jr .less_done 
35b3			 
35b3				endif 
35b3					 
35b3			 
35b3			.less_inum: 
35b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35b3 cd fb 1e			call macro_dsp_valuehl 
35b6				endm 
# End of macro FORTH_DSP_VALUEHL
35b6			 
35b6 e5					push hl  ; u2 
35b7			 
35b7					; destroy value TOS 
35b7			 
35b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35b7 cd b3 1f			call macro_forth_dsp_pop 
35ba				endm 
# End of macro FORTH_DSP_POP
35ba			 
35ba			 
35ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35ba cd fb 1e			call macro_dsp_valuehl 
35bd				endm 
# End of macro FORTH_DSP_VALUEHL
35bd			 
35bd e5					push hl    ; u1 
35be			 
35be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35be cd b3 1f			call macro_forth_dsp_pop 
35c1				endm 
# End of macro FORTH_DSP_POP
35c1			 
35c1			 
35c1 b7			 or a      ;clear carry flag 
35c2 01 00 00		 ld bc, FORTH_FALSE 
35c5 e1			  pop hl    ; u1 
35c6 d1			  pop de    ; u2 
35c7 ed 52		  sbc hl,de 
35c9 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
35cb			 
35cb 01 01 00		 ld bc, FORTH_TRUE 
35ce			.lscont:  
35ce c5					push bc 
35cf e1					pop hl 
35d0			 
35d0					if DEBUG_FORTH_WORDS 
35d0						DMARK "LT1" 
35d0 f5				push af  
35d1 3a e5 35			ld a, (.dmark)  
35d4 32 77 fb			ld (debug_mark),a  
35d7 3a e6 35			ld a, (.dmark+1)  
35da 32 78 fb			ld (debug_mark+1),a  
35dd 3a e7 35			ld a, (.dmark+2)  
35e0 32 79 fb			ld (debug_mark+2),a  
35e3 18 03			jr .pastdmark  
35e5 ..			.dmark: db "LT1"  
35e8 f1			.pastdmark: pop af  
35e9			endm  
# End of macro DMARK
35e9						CALLMONITOR 
35e9 cd 74 17			call break_point_state  
35ec				endm  
# End of macro CALLMONITOR
35ec					endif 
35ec cd 04 1d				call forth_push_numhl 
35ef			 
35ef					NEXTW 
35ef c3 6d 20			jp macro_next 
35f2				endm 
# End of macro NEXTW
35f2			.GT: 
35f2				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35f2 30				db WORD_SYS_CORE+28             
35f3 5b 36			dw .EQUAL            
35f5 02				db 1 + 1 
35f6 .. 00			db ">",0              
35f8				endm 
# End of macro CWHEAD
35f8			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35f8				; TODO add floating point number detection 
35f8					if DEBUG_FORTH_WORDS_KEY 
35f8						DMARK "GRT" 
35f8 f5				push af  
35f9 3a 0d 36			ld a, (.dmark)  
35fc 32 77 fb			ld (debug_mark),a  
35ff 3a 0e 36			ld a, (.dmark+1)  
3602 32 78 fb			ld (debug_mark+1),a  
3605 3a 0f 36			ld a, (.dmark+2)  
3608 32 79 fb			ld (debug_mark+2),a  
360b 18 03			jr .pastdmark  
360d ..			.dmark: db "GRT"  
3610 f1			.pastdmark: pop af  
3611			endm  
# End of macro DMARK
3611						CALLMONITOR 
3611 cd 74 17			call break_point_state  
3614				endm  
# End of macro CALLMONITOR
3614					endif 
3614					FORTH_DSP 
3614 cd c1 1e			call macro_forth_dsp 
3617				endm 
# End of macro FORTH_DSP
3617					;FORTH_DSP_VALUE 
3617 7e					ld a,(hl)	; get type of value on TOS 
3618 fe 02				cp DS_TYPE_INUM  
361a 28 00				jr z, .gt_inum 
361c			 
361c				if FORTH_ENABLE_FLOATMATH 
361c					jr .gt_done 
361c			 
361c				endif 
361c					 
361c			 
361c			.gt_inum: 
361c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
361c cd fb 1e			call macro_dsp_valuehl 
361f				endm 
# End of macro FORTH_DSP_VALUEHL
361f			 
361f e5					push hl  ; u2 
3620			 
3620					; destroy value TOS 
3620			 
3620					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3620 cd b3 1f			call macro_forth_dsp_pop 
3623				endm 
# End of macro FORTH_DSP_POP
3623			 
3623			 
3623					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3623 cd fb 1e			call macro_dsp_valuehl 
3626				endm 
# End of macro FORTH_DSP_VALUEHL
3626			 
3626 e5					push hl    ; u1 
3627			 
3627					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3627 cd b3 1f			call macro_forth_dsp_pop 
362a				endm 
# End of macro FORTH_DSP_POP
362a			 
362a			 
362a b7			 or a      ;clear carry flag 
362b 01 00 00		 ld bc, FORTH_FALSE 
362e e1			  pop hl    ; u1 
362f d1			  pop de    ; u2 
3630 ed 52		  sbc hl,de 
3632 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3634			 
3634 01 01 00		 ld bc, FORTH_TRUE 
3637			.gtcont:  
3637 c5					push bc 
3638 e1					pop hl 
3639			 
3639					if DEBUG_FORTH_WORDS 
3639						DMARK "GT1" 
3639 f5				push af  
363a 3a 4e 36			ld a, (.dmark)  
363d 32 77 fb			ld (debug_mark),a  
3640 3a 4f 36			ld a, (.dmark+1)  
3643 32 78 fb			ld (debug_mark+1),a  
3646 3a 50 36			ld a, (.dmark+2)  
3649 32 79 fb			ld (debug_mark+2),a  
364c 18 03			jr .pastdmark  
364e ..			.dmark: db "GT1"  
3651 f1			.pastdmark: pop af  
3652			endm  
# End of macro DMARK
3652						CALLMONITOR 
3652 cd 74 17			call break_point_state  
3655				endm  
# End of macro CALLMONITOR
3655					endif 
3655 cd 04 1d				call forth_push_numhl 
3658			 
3658					NEXTW 
3658 c3 6d 20			jp macro_next 
365b				endm 
# End of macro NEXTW
365b			.EQUAL: 
365b				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
365b 31				db WORD_SYS_CORE+29             
365c c6 36			dw .ENDLOGIC            
365e 02				db 1 + 1 
365f .. 00			db "=",0              
3661				endm 
# End of macro CWHEAD
3661			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3661				; TODO add floating point number detection 
3661					if DEBUG_FORTH_WORDS_KEY 
3661						DMARK "EQ." 
3661 f5				push af  
3662 3a 76 36			ld a, (.dmark)  
3665 32 77 fb			ld (debug_mark),a  
3668 3a 77 36			ld a, (.dmark+1)  
366b 32 78 fb			ld (debug_mark+1),a  
366e 3a 78 36			ld a, (.dmark+2)  
3671 32 79 fb			ld (debug_mark+2),a  
3674 18 03			jr .pastdmark  
3676 ..			.dmark: db "EQ."  
3679 f1			.pastdmark: pop af  
367a			endm  
# End of macro DMARK
367a						CALLMONITOR 
367a cd 74 17			call break_point_state  
367d				endm  
# End of macro CALLMONITOR
367d					endif 
367d					FORTH_DSP 
367d cd c1 1e			call macro_forth_dsp 
3680				endm 
# End of macro FORTH_DSP
3680					;v5 FORTH_DSP_VALUE 
3680 7e					ld a,(hl)	; get type of value on TOS 
3681 fe 02				cp DS_TYPE_INUM  
3683 28 00				jr z, .eq_inum 
3685			 
3685				if FORTH_ENABLE_FLOATMATH 
3685					jr .eq_done 
3685			 
3685				endif 
3685					 
3685			 
3685			.eq_inum: 
3685					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3685 cd fb 1e			call macro_dsp_valuehl 
3688				endm 
# End of macro FORTH_DSP_VALUEHL
3688			 
3688 e5					push hl 
3689			 
3689					; destroy value TOS 
3689			 
3689					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3689 cd b3 1f			call macro_forth_dsp_pop 
368c				endm 
# End of macro FORTH_DSP_POP
368c			 
368c			 
368c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
368c cd fb 1e			call macro_dsp_valuehl 
368f				endm 
# End of macro FORTH_DSP_VALUEHL
368f			 
368f					; one value on hl get other one back 
368f			 
368f e5					push hl 
3690			 
3690					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3690 cd b3 1f			call macro_forth_dsp_pop 
3693				endm 
# End of macro FORTH_DSP_POP
3693			 
3693 0e 00				ld c, FORTH_FALSE 
3695			 
3695 e1					pop hl 
3696 d1					pop de 
3697			 
3697 7b					ld a, e 
3698 bd					cp l 
3699			 
3699 20 06				jr nz, .eq_done 
369b			 
369b 7a					ld a, d 
369c bc					cp h 
369d			 
369d 20 02				jr nz, .eq_done 
369f			 
369f 0e 01				ld c, FORTH_TRUE 
36a1					 
36a1			 
36a1			 
36a1			.eq_done: 
36a1			 
36a1					; TODO push value back onto stack for another op etc 
36a1			 
36a1 26 00				ld h, 0 
36a3 69					ld l, c 
36a4					if DEBUG_FORTH_WORDS 
36a4						DMARK "EQ1" 
36a4 f5				push af  
36a5 3a b9 36			ld a, (.dmark)  
36a8 32 77 fb			ld (debug_mark),a  
36ab 3a ba 36			ld a, (.dmark+1)  
36ae 32 78 fb			ld (debug_mark+1),a  
36b1 3a bb 36			ld a, (.dmark+2)  
36b4 32 79 fb			ld (debug_mark+2),a  
36b7 18 03			jr .pastdmark  
36b9 ..			.dmark: db "EQ1"  
36bc f1			.pastdmark: pop af  
36bd			endm  
# End of macro DMARK
36bd						CALLMONITOR 
36bd cd 74 17			call break_point_state  
36c0				endm  
# End of macro CALLMONITOR
36c0					endif 
36c0 cd 04 1d				call forth_push_numhl 
36c3			 
36c3					NEXTW 
36c3 c3 6d 20			jp macro_next 
36c6				endm 
# End of macro NEXTW
36c6			 
36c6			 
36c6			.ENDLOGIC: 
36c6			; eof 
36c6			 
36c6			 
# End of file forth_words_logic.asm
36c6			include "forth_words_maths.asm" 
36c6			 
36c6			; | ## Maths Words 
36c6			 
36c6			.PLUS:	 
36c6				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36c6 15				db WORD_SYS_CORE+1             
36c7 08 37			dw .NEG            
36c9 02				db 1 + 1 
36ca .. 00			db "+",0              
36cc				endm 
# End of macro CWHEAD
36cc			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
36cc					if DEBUG_FORTH_WORDS_KEY 
36cc						DMARK "PLU" 
36cc f5				push af  
36cd 3a e1 36			ld a, (.dmark)  
36d0 32 77 fb			ld (debug_mark),a  
36d3 3a e2 36			ld a, (.dmark+1)  
36d6 32 78 fb			ld (debug_mark+1),a  
36d9 3a e3 36			ld a, (.dmark+2)  
36dc 32 79 fb			ld (debug_mark+2),a  
36df 18 03			jr .pastdmark  
36e1 ..			.dmark: db "PLU"  
36e4 f1			.pastdmark: pop af  
36e5			endm  
# End of macro DMARK
36e5						CALLMONITOR 
36e5 cd 74 17			call break_point_state  
36e8				endm  
# End of macro CALLMONITOR
36e8					endif 
36e8					; add top two values and push back result 
36e8			 
36e8					;for v5 FORTH_DSP_VALUE 
36e8					FORTH_DSP 
36e8 cd c1 1e			call macro_forth_dsp 
36eb				endm 
# End of macro FORTH_DSP
36eb 7e					ld a,(hl)	; get type of value on TOS 
36ec fe 02				cp DS_TYPE_INUM  
36ee 28 03				jr z, .dot_inum 
36f0			 
36f0					NEXTW 
36f0 c3 6d 20			jp macro_next 
36f3				endm 
# End of macro NEXTW
36f3			 
36f3			; float maths 
36f3			 
36f3				if FORTH_ENABLE_FLOATMATH 
36f3						inc hl      ; now at start of numeric as string 
36f3			 
36f3					if DEBUG_FORTH_MATHS 
36f3						DMARK "ADD" 
36f3				CALLMONITOR 
36f3					endif 
36f3			 
36f3					;ld ix, hl 
36f3					call CON 
36f3			 
36f3			 
36f3					push hl 
36f3					 
36f3					 
36f3			 
36f3						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36f3			 
36f3					; get next number 
36f3			 
36f3						FORTH_DSP_VALUE 
36f3			 
36f3						inc hl      ; now at start of numeric as string 
36f3			 
36f3					;ld ix, hl 
36f3					call CON 
36f3			 
36f3					push hl 
36f3			 
36f3			 
36f3						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f3			 
36f3						; TODO do add 
36f3			 
36f3						call IADD 
36f3			 
36f3						; TODO get result back as ascii 
36f3			 
36f3						; TODO push result  
36f3			 
36f3			 
36f3			 
36f3						jr .dot_done 
36f3				endif 
36f3			 
36f3			.dot_inum: 
36f3			 
36f3			 
36f3					if DEBUG_FORTH_DOT 
36f3						DMARK "+IT" 
36f3				CALLMONITOR 
36f3					endif 
36f3			 
36f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f3 cd fb 1e			call macro_dsp_valuehl 
36f6				endm 
# End of macro FORTH_DSP_VALUEHL
36f6			 
36f6				; TODO add floating point number detection 
36f6			 
36f6 e5					push hl 
36f7			 
36f7					; destroy value TOS 
36f7			 
36f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f7 cd b3 1f			call macro_forth_dsp_pop 
36fa				endm 
# End of macro FORTH_DSP_POP
36fa			 
36fa			 
36fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36fa cd fb 1e			call macro_dsp_valuehl 
36fd				endm 
# End of macro FORTH_DSP_VALUEHL
36fd			 
36fd					; one value on hl get other one back 
36fd			 
36fd d1					pop de 
36fe			 
36fe					; do the add 
36fe			 
36fe 19					add hl,de 
36ff			 
36ff					; save it 
36ff			 
36ff			;		push hl	 
36ff			 
36ff					; 
36ff			 
36ff					; destroy value TOS 
36ff			 
36ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ff cd b3 1f			call macro_forth_dsp_pop 
3702				endm 
# End of macro FORTH_DSP_POP
3702			 
3702					; TODO push value back onto stack for another op etc 
3702			 
3702			;		pop hl 
3702			 
3702			.dot_done: 
3702 cd 04 1d				call forth_push_numhl 
3705			 
3705					NEXTW 
3705 c3 6d 20			jp macro_next 
3708				endm 
# End of macro NEXTW
3708			.NEG: 
3708			 
3708				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3708 17				db WORD_SYS_CORE+3             
3709 4b 37			dw .DIV            
370b 02				db 1 + 1 
370c .. 00			db "-",0              
370e				endm 
# End of macro CWHEAD
370e			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
370e					if DEBUG_FORTH_WORDS_KEY 
370e						DMARK "SUB" 
370e f5				push af  
370f 3a 23 37			ld a, (.dmark)  
3712 32 77 fb			ld (debug_mark),a  
3715 3a 24 37			ld a, (.dmark+1)  
3718 32 78 fb			ld (debug_mark+1),a  
371b 3a 25 37			ld a, (.dmark+2)  
371e 32 79 fb			ld (debug_mark+2),a  
3721 18 03			jr .pastdmark  
3723 ..			.dmark: db "SUB"  
3726 f1			.pastdmark: pop af  
3727			endm  
# End of macro DMARK
3727						CALLMONITOR 
3727 cd 74 17			call break_point_state  
372a				endm  
# End of macro CALLMONITOR
372a					endif 
372a			 
372a			 
372a				; TODO add floating point number detection 
372a					; v5 FORTH_DSP_VALUE 
372a					FORTH_DSP 
372a cd c1 1e			call macro_forth_dsp 
372d				endm 
# End of macro FORTH_DSP
372d 7e					ld a,(hl)	; get type of value on TOS 
372e fe 02				cp DS_TYPE_INUM  
3730 28 03				jr z, .neg_inum 
3732			 
3732					NEXTW 
3732 c3 6d 20			jp macro_next 
3735				endm 
# End of macro NEXTW
3735			 
3735			; float maths 
3735			 
3735				if FORTH_ENABLE_FLOATMATH 
3735					jr .neg_done 
3735			 
3735				endif 
3735					 
3735			 
3735			.neg_inum: 
3735					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3735 cd fb 1e			call macro_dsp_valuehl 
3738				endm 
# End of macro FORTH_DSP_VALUEHL
3738			 
3738 e5					push hl 
3739			 
3739					; destroy value TOS 
3739			 
3739					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3739 cd b3 1f			call macro_forth_dsp_pop 
373c				endm 
# End of macro FORTH_DSP_POP
373c			 
373c			 
373c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
373c cd fb 1e			call macro_dsp_valuehl 
373f				endm 
# End of macro FORTH_DSP_VALUEHL
373f			 
373f					; one value on hl get other one back 
373f			 
373f d1					pop de 
3740			 
3740					; do the sub 
3740			;		ex de, hl 
3740			 
3740 ed 52				sbc hl,de 
3742			 
3742					; save it 
3742			 
3742			;		push hl	 
3742			 
3742					; 
3742			 
3742					; destroy value TOS 
3742			 
3742					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3742 cd b3 1f			call macro_forth_dsp_pop 
3745				endm 
# End of macro FORTH_DSP_POP
3745			 
3745					; TODO push value back onto stack for another op etc 
3745			 
3745			;		pop hl 
3745			 
3745 cd 04 1d				call forth_push_numhl 
3748			.neg_done: 
3748			 
3748					NEXTW 
3748 c3 6d 20			jp macro_next 
374b				endm 
# End of macro NEXTW
374b			.DIV: 
374b				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
374b 18				db WORD_SYS_CORE+4             
374c 98 37			dw .MUL            
374e 02				db 1 + 1 
374f .. 00			db "/",0              
3751				endm 
# End of macro CWHEAD
3751			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3751					if DEBUG_FORTH_WORDS_KEY 
3751						DMARK "DIV" 
3751 f5				push af  
3752 3a 66 37			ld a, (.dmark)  
3755 32 77 fb			ld (debug_mark),a  
3758 3a 67 37			ld a, (.dmark+1)  
375b 32 78 fb			ld (debug_mark+1),a  
375e 3a 68 37			ld a, (.dmark+2)  
3761 32 79 fb			ld (debug_mark+2),a  
3764 18 03			jr .pastdmark  
3766 ..			.dmark: db "DIV"  
3769 f1			.pastdmark: pop af  
376a			endm  
# End of macro DMARK
376a						CALLMONITOR 
376a cd 74 17			call break_point_state  
376d				endm  
# End of macro CALLMONITOR
376d					endif 
376d				; TODO add floating point number detection 
376d					; v5 FORTH_DSP_VALUE 
376d					FORTH_DSP 
376d cd c1 1e			call macro_forth_dsp 
3770				endm 
# End of macro FORTH_DSP
3770 7e					ld a,(hl)	; get type of value on TOS 
3771 fe 02				cp DS_TYPE_INUM  
3773 28 03				jr z, .div_inum 
3775			 
3775				if FORTH_ENABLE_FLOATMATH 
3775					jr .div_done 
3775			 
3775				endif 
3775					NEXTW 
3775 c3 6d 20			jp macro_next 
3778				endm 
# End of macro NEXTW
3778			.div_inum: 
3778			 
3778					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3778 cd fb 1e			call macro_dsp_valuehl 
377b				endm 
# End of macro FORTH_DSP_VALUEHL
377b			 
377b e5					push hl    ; to go to bc 
377c			 
377c					; destroy value TOS 
377c			 
377c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
377c cd b3 1f			call macro_forth_dsp_pop 
377f				endm 
# End of macro FORTH_DSP_POP
377f			 
377f			 
377f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377f cd fb 1e			call macro_dsp_valuehl 
3782				endm 
# End of macro FORTH_DSP_VALUEHL
3782			 
3782					; hl to go to de 
3782			 
3782 e5					push hl 
3783			 
3783 c1					pop bc 
3784 d1					pop de		 
3785			 
3785			 
3785					if DEBUG_FORTH_MATHS 
3785						DMARK "DIV" 
3785				CALLMONITOR 
3785					endif 
3785					; one value on hl but move to a get other one back 
3785			 
3785			        
3785 cd 7d 0c			call Div16 
3788			 
3788			;	push af	 
3788 e5				push hl 
3789 c5				push bc 
378a			 
378a					if DEBUG_FORTH_MATHS 
378a						DMARK "DI1" 
378a				CALLMONITOR 
378a					endif 
378a			 
378a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378a cd b3 1f			call macro_forth_dsp_pop 
378d				endm 
# End of macro FORTH_DSP_POP
378d			 
378d			 
378d			 
378d e1					pop hl    ; result 
378e			 
378e cd 04 1d				call forth_push_numhl 
3791			 
3791 e1					pop hl    ; reminder 
3792			;		ld h,0 
3792			;		ld l,d 
3792			 
3792 cd 04 1d				call forth_push_numhl 
3795			.div_done: 
3795					NEXTW 
3795 c3 6d 20			jp macro_next 
3798				endm 
# End of macro NEXTW
3798			.MUL: 
3798				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3798 19				db WORD_SYS_CORE+5             
3799 dd 37			dw .MIN            
379b 02				db 1 + 1 
379c .. 00			db "*",0              
379e				endm 
# End of macro CWHEAD
379e			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
379e				; TODO add floating point number detection 
379e					if DEBUG_FORTH_WORDS_KEY 
379e						DMARK "MUL" 
379e f5				push af  
379f 3a b3 37			ld a, (.dmark)  
37a2 32 77 fb			ld (debug_mark),a  
37a5 3a b4 37			ld a, (.dmark+1)  
37a8 32 78 fb			ld (debug_mark+1),a  
37ab 3a b5 37			ld a, (.dmark+2)  
37ae 32 79 fb			ld (debug_mark+2),a  
37b1 18 03			jr .pastdmark  
37b3 ..			.dmark: db "MUL"  
37b6 f1			.pastdmark: pop af  
37b7			endm  
# End of macro DMARK
37b7						CALLMONITOR 
37b7 cd 74 17			call break_point_state  
37ba				endm  
# End of macro CALLMONITOR
37ba					endif 
37ba					FORTH_DSP 
37ba cd c1 1e			call macro_forth_dsp 
37bd				endm 
# End of macro FORTH_DSP
37bd					; v5 FORTH_DSP_VALUE 
37bd 7e					ld a,(hl)	; get type of value on TOS 
37be fe 02				cp DS_TYPE_INUM  
37c0 28 03				jr z, .mul_inum 
37c2			 
37c2				if FORTH_ENABLE_FLOATMATH 
37c2					jr .mul_done 
37c2			 
37c2				endif 
37c2			 
37c2					NEXTW 
37c2 c3 6d 20			jp macro_next 
37c5				endm 
# End of macro NEXTW
37c5			.mul_inum:	 
37c5			 
37c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37c5 cd fb 1e			call macro_dsp_valuehl 
37c8				endm 
# End of macro FORTH_DSP_VALUEHL
37c8			 
37c8 e5					push hl 
37c9			 
37c9					; destroy value TOS 
37c9			 
37c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37c9 cd b3 1f			call macro_forth_dsp_pop 
37cc				endm 
# End of macro FORTH_DSP_POP
37cc			 
37cc			 
37cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37cc cd fb 1e			call macro_dsp_valuehl 
37cf				endm 
# End of macro FORTH_DSP_VALUEHL
37cf			 
37cf					; one value on hl but move to a get other one back 
37cf			 
37cf 7d					ld a, l 
37d0			 
37d0 d1					pop de 
37d1			 
37d1					; do the mull 
37d1			;		ex de, hl 
37d1			 
37d1 cd a3 0c				call Mult16 
37d4					; save it 
37d4			 
37d4			;		push hl	 
37d4			 
37d4					; 
37d4			 
37d4					; destroy value TOS 
37d4			 
37d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d4 cd b3 1f			call macro_forth_dsp_pop 
37d7				endm 
# End of macro FORTH_DSP_POP
37d7			 
37d7					; TODO push value back onto stack for another op etc 
37d7			 
37d7			;		pop hl 
37d7			 
37d7 cd 04 1d				call forth_push_numhl 
37da			 
37da			.mul_done: 
37da					NEXTW 
37da c3 6d 20			jp macro_next 
37dd				endm 
# End of macro NEXTW
37dd			 
37dd			 
37dd			 
37dd			 
37dd			.MIN: 
37dd				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37dd 49				db WORD_SYS_CORE+53             
37de 5e 38			dw .MAX            
37e0 04				db 3 + 1 
37e1 .. 00			db "MIN",0              
37e5				endm 
# End of macro CWHEAD
37e5			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37e5					if DEBUG_FORTH_WORDS_KEY 
37e5						DMARK "MIN" 
37e5 f5				push af  
37e6 3a fa 37			ld a, (.dmark)  
37e9 32 77 fb			ld (debug_mark),a  
37ec 3a fb 37			ld a, (.dmark+1)  
37ef 32 78 fb			ld (debug_mark+1),a  
37f2 3a fc 37			ld a, (.dmark+2)  
37f5 32 79 fb			ld (debug_mark+2),a  
37f8 18 03			jr .pastdmark  
37fa ..			.dmark: db "MIN"  
37fd f1			.pastdmark: pop af  
37fe			endm  
# End of macro DMARK
37fe						CALLMONITOR 
37fe cd 74 17			call break_point_state  
3801				endm  
# End of macro CALLMONITOR
3801					endif 
3801					; get u2 
3801			 
3801					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3801 cd fb 1e			call macro_dsp_valuehl 
3804				endm 
# End of macro FORTH_DSP_VALUEHL
3804			 
3804 e5					push hl   ; u2 
3805			 
3805					; destroy value TOS 
3805			 
3805					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3805 cd b3 1f			call macro_forth_dsp_pop 
3808				endm 
# End of macro FORTH_DSP_POP
3808			 
3808					; get u1 
3808			 
3808					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3808 cd fb 1e			call macro_dsp_valuehl 
380b				endm 
# End of macro FORTH_DSP_VALUEHL
380b			 
380b e5					push hl  ; u1 
380c			 
380c					; destroy value TOS 
380c			 
380c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
380c cd b3 1f			call macro_forth_dsp_pop 
380f				endm 
# End of macro FORTH_DSP_POP
380f			 
380f b7			 or a      ;clear carry flag 
3810 e1			  pop hl    ; u1 
3811 d1			  pop de    ; u2 
3812 e5				push hl   ; saved in case hl is lowest 
3813 ed 52		  sbc hl,de 
3815 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3817			 
3817 e1				pop hl 
3818					if DEBUG_FORTH_WORDS 
3818						DMARK "MIN" 
3818 f5				push af  
3819 3a 2d 38			ld a, (.dmark)  
381c 32 77 fb			ld (debug_mark),a  
381f 3a 2e 38			ld a, (.dmark+1)  
3822 32 78 fb			ld (debug_mark+1),a  
3825 3a 2f 38			ld a, (.dmark+2)  
3828 32 79 fb			ld (debug_mark+2),a  
382b 18 03			jr .pastdmark  
382d ..			.dmark: db "MIN"  
3830 f1			.pastdmark: pop af  
3831			endm  
# End of macro DMARK
3831						CALLMONITOR 
3831 cd 74 17			call break_point_state  
3834				endm  
# End of macro CALLMONITOR
3834					endif 
3834 cd 04 1d				call forth_push_numhl 
3837			 
3837				       NEXTW 
3837 c3 6d 20			jp macro_next 
383a				endm 
# End of macro NEXTW
383a			 
383a			.mincont:  
383a c1				pop bc   ; tidy up 
383b eb				ex de , hl  
383c					if DEBUG_FORTH_WORDS 
383c						DMARK "MI1" 
383c f5				push af  
383d 3a 51 38			ld a, (.dmark)  
3840 32 77 fb			ld (debug_mark),a  
3843 3a 52 38			ld a, (.dmark+1)  
3846 32 78 fb			ld (debug_mark+1),a  
3849 3a 53 38			ld a, (.dmark+2)  
384c 32 79 fb			ld (debug_mark+2),a  
384f 18 03			jr .pastdmark  
3851 ..			.dmark: db "MI1"  
3854 f1			.pastdmark: pop af  
3855			endm  
# End of macro DMARK
3855						CALLMONITOR 
3855 cd 74 17			call break_point_state  
3858				endm  
# End of macro CALLMONITOR
3858					endif 
3858 cd 04 1d				call forth_push_numhl 
385b			 
385b				       NEXTW 
385b c3 6d 20			jp macro_next 
385e				endm 
# End of macro NEXTW
385e			.MAX: 
385e				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
385e 4a				db WORD_SYS_CORE+54             
385f df 38			dw .RND16            
3861 04				db 3 + 1 
3862 .. 00			db "MAX",0              
3866				endm 
# End of macro CWHEAD
3866			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3866					if DEBUG_FORTH_WORDS_KEY 
3866						DMARK "MAX" 
3866 f5				push af  
3867 3a 7b 38			ld a, (.dmark)  
386a 32 77 fb			ld (debug_mark),a  
386d 3a 7c 38			ld a, (.dmark+1)  
3870 32 78 fb			ld (debug_mark+1),a  
3873 3a 7d 38			ld a, (.dmark+2)  
3876 32 79 fb			ld (debug_mark+2),a  
3879 18 03			jr .pastdmark  
387b ..			.dmark: db "MAX"  
387e f1			.pastdmark: pop af  
387f			endm  
# End of macro DMARK
387f						CALLMONITOR 
387f cd 74 17			call break_point_state  
3882				endm  
# End of macro CALLMONITOR
3882					endif 
3882					; get u2 
3882			 
3882					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3882 cd fb 1e			call macro_dsp_valuehl 
3885				endm 
# End of macro FORTH_DSP_VALUEHL
3885			 
3885 e5					push hl   ; u2 
3886			 
3886					; destroy value TOS 
3886			 
3886					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3886 cd b3 1f			call macro_forth_dsp_pop 
3889				endm 
# End of macro FORTH_DSP_POP
3889			 
3889					; get u1 
3889			 
3889					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3889 cd fb 1e			call macro_dsp_valuehl 
388c				endm 
# End of macro FORTH_DSP_VALUEHL
388c			 
388c e5					push hl  ; u1 
388d			 
388d					; destroy value TOS 
388d			 
388d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
388d cd b3 1f			call macro_forth_dsp_pop 
3890				endm 
# End of macro FORTH_DSP_POP
3890			 
3890 b7			 or a      ;clear carry flag 
3891 e1			  pop hl    ; u1 
3892 d1			  pop de    ; u2 
3893 e5				push hl   ; saved in case hl is lowest 
3894 ed 52		  sbc hl,de 
3896 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3898			 
3898 e1				pop hl 
3899					if DEBUG_FORTH_WORDS 
3899						DMARK "MAX" 
3899 f5				push af  
389a 3a ae 38			ld a, (.dmark)  
389d 32 77 fb			ld (debug_mark),a  
38a0 3a af 38			ld a, (.dmark+1)  
38a3 32 78 fb			ld (debug_mark+1),a  
38a6 3a b0 38			ld a, (.dmark+2)  
38a9 32 79 fb			ld (debug_mark+2),a  
38ac 18 03			jr .pastdmark  
38ae ..			.dmark: db "MAX"  
38b1 f1			.pastdmark: pop af  
38b2			endm  
# End of macro DMARK
38b2						CALLMONITOR 
38b2 cd 74 17			call break_point_state  
38b5				endm  
# End of macro CALLMONITOR
38b5					endif 
38b5 cd 04 1d				call forth_push_numhl 
38b8			 
38b8				       NEXTW 
38b8 c3 6d 20			jp macro_next 
38bb				endm 
# End of macro NEXTW
38bb			 
38bb			.maxcont:  
38bb c1				pop bc   ; tidy up 
38bc eb				ex de , hl  
38bd					if DEBUG_FORTH_WORDS 
38bd						DMARK "MA1" 
38bd f5				push af  
38be 3a d2 38			ld a, (.dmark)  
38c1 32 77 fb			ld (debug_mark),a  
38c4 3a d3 38			ld a, (.dmark+1)  
38c7 32 78 fb			ld (debug_mark+1),a  
38ca 3a d4 38			ld a, (.dmark+2)  
38cd 32 79 fb			ld (debug_mark+2),a  
38d0 18 03			jr .pastdmark  
38d2 ..			.dmark: db "MA1"  
38d5 f1			.pastdmark: pop af  
38d6			endm  
# End of macro DMARK
38d6						CALLMONITOR 
38d6 cd 74 17			call break_point_state  
38d9				endm  
# End of macro CALLMONITOR
38d9					endif 
38d9 cd 04 1d				call forth_push_numhl 
38dc				       NEXTW 
38dc c3 6d 20			jp macro_next 
38df				endm 
# End of macro NEXTW
38df			 
38df			.RND16: 
38df				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38df 4e				db WORD_SYS_CORE+58             
38e0 0e 39			dw .RND8            
38e2 06				db 5 + 1 
38e3 .. 00			db "RND16",0              
38e9				endm 
# End of macro CWHEAD
38e9			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38e9					if DEBUG_FORTH_WORDS_KEY 
38e9						DMARK "R16" 
38e9 f5				push af  
38ea 3a fe 38			ld a, (.dmark)  
38ed 32 77 fb			ld (debug_mark),a  
38f0 3a ff 38			ld a, (.dmark+1)  
38f3 32 78 fb			ld (debug_mark+1),a  
38f6 3a 00 39			ld a, (.dmark+2)  
38f9 32 79 fb			ld (debug_mark+2),a  
38fc 18 03			jr .pastdmark  
38fe ..			.dmark: db "R16"  
3901 f1			.pastdmark: pop af  
3902			endm  
# End of macro DMARK
3902						CALLMONITOR 
3902 cd 74 17			call break_point_state  
3905				endm  
# End of macro CALLMONITOR
3905					endif 
3905 cd 47 0c				call prng16  
3908 cd 04 1d				call forth_push_numhl 
390b				       NEXTW 
390b c3 6d 20			jp macro_next 
390e				endm 
# End of macro NEXTW
390e			.RND8: 
390e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
390e 60				db WORD_SYS_CORE+76             
390f 43 39			dw .RND            
3911 05				db 4 + 1 
3912 .. 00			db "RND8",0              
3917				endm 
# End of macro CWHEAD
3917			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3917					if DEBUG_FORTH_WORDS_KEY 
3917						DMARK "RN8" 
3917 f5				push af  
3918 3a 2c 39			ld a, (.dmark)  
391b 32 77 fb			ld (debug_mark),a  
391e 3a 2d 39			ld a, (.dmark+1)  
3921 32 78 fb			ld (debug_mark+1),a  
3924 3a 2e 39			ld a, (.dmark+2)  
3927 32 79 fb			ld (debug_mark+2),a  
392a 18 03			jr .pastdmark  
392c ..			.dmark: db "RN8"  
392f f1			.pastdmark: pop af  
3930			endm  
# End of macro DMARK
3930						CALLMONITOR 
3930 cd 74 17			call break_point_state  
3933				endm  
# End of macro CALLMONITOR
3933					endif 
3933 2a b8 f8				ld hl,(xrandc) 
3936 23					inc hl 
3937 cd 61 0c				call xrnd 
393a 6f					ld l,a	 
393b 26 00				ld h,0 
393d cd 04 1d				call forth_push_numhl 
3940				       NEXTW 
3940 c3 6d 20			jp macro_next 
3943				endm 
# End of macro NEXTW
3943			.RND: 
3943				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3943 60				db WORD_SYS_CORE+76             
3944 49 3a			dw .ENDMATHS            
3946 04				db 3 + 1 
3947 .. 00			db "RND",0              
394b				endm 
# End of macro CWHEAD
394b			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
394b			 
394b					if DEBUG_FORTH_WORDS_KEY 
394b						DMARK "RND" 
394b f5				push af  
394c 3a 60 39			ld a, (.dmark)  
394f 32 77 fb			ld (debug_mark),a  
3952 3a 61 39			ld a, (.dmark+1)  
3955 32 78 fb			ld (debug_mark+1),a  
3958 3a 62 39			ld a, (.dmark+2)  
395b 32 79 fb			ld (debug_mark+2),a  
395e 18 03			jr .pastdmark  
3960 ..			.dmark: db "RND"  
3963 f1			.pastdmark: pop af  
3964			endm  
# End of macro DMARK
3964						CALLMONITOR 
3964 cd 74 17			call break_point_state  
3967				endm  
# End of macro CALLMONITOR
3967					endif 
3967					 
3967					FORTH_DSP_VALUEHL    ; upper range 
3967 cd fb 1e			call macro_dsp_valuehl 
396a				endm 
# End of macro FORTH_DSP_VALUEHL
396a			 
396a 22 bc f8				ld (LFSRSeed), hl	 
396d			 
396d					if DEBUG_FORTH_WORDS 
396d						DMARK "RN1" 
396d f5				push af  
396e 3a 82 39			ld a, (.dmark)  
3971 32 77 fb			ld (debug_mark),a  
3974 3a 83 39			ld a, (.dmark+1)  
3977 32 78 fb			ld (debug_mark+1),a  
397a 3a 84 39			ld a, (.dmark+2)  
397d 32 79 fb			ld (debug_mark+2),a  
3980 18 03			jr .pastdmark  
3982 ..			.dmark: db "RN1"  
3985 f1			.pastdmark: pop af  
3986			endm  
# End of macro DMARK
3986						CALLMONITOR 
3986 cd 74 17			call break_point_state  
3989				endm  
# End of macro CALLMONITOR
3989					endif 
3989					FORTH_DSP_POP 
3989 cd b3 1f			call macro_forth_dsp_pop 
398c				endm 
# End of macro FORTH_DSP_POP
398c			 
398c					FORTH_DSP_VALUEHL    ; low range 
398c cd fb 1e			call macro_dsp_valuehl 
398f				endm 
# End of macro FORTH_DSP_VALUEHL
398f			 
398f					if DEBUG_FORTH_WORDS 
398f						DMARK "RN2" 
398f f5				push af  
3990 3a a4 39			ld a, (.dmark)  
3993 32 77 fb			ld (debug_mark),a  
3996 3a a5 39			ld a, (.dmark+1)  
3999 32 78 fb			ld (debug_mark+1),a  
399c 3a a6 39			ld a, (.dmark+2)  
399f 32 79 fb			ld (debug_mark+2),a  
39a2 18 03			jr .pastdmark  
39a4 ..			.dmark: db "RN2"  
39a7 f1			.pastdmark: pop af  
39a8			endm  
# End of macro DMARK
39a8						CALLMONITOR 
39a8 cd 74 17			call break_point_state  
39ab				endm  
# End of macro CALLMONITOR
39ab					endif 
39ab 22 be f8				ld (LFSRSeed+2), hl 
39ae			 
39ae					FORTH_DSP_POP 
39ae cd b3 1f			call macro_forth_dsp_pop 
39b1				endm 
# End of macro FORTH_DSP_POP
39b1			 
39b1 e5					push hl 
39b2			 
39b2 e1			.inrange:	pop hl 
39b3 cd 47 0c				call prng16  
39b6					if DEBUG_FORTH_WORDS 
39b6						DMARK "RN3" 
39b6 f5				push af  
39b7 3a cb 39			ld a, (.dmark)  
39ba 32 77 fb			ld (debug_mark),a  
39bd 3a cc 39			ld a, (.dmark+1)  
39c0 32 78 fb			ld (debug_mark+1),a  
39c3 3a cd 39			ld a, (.dmark+2)  
39c6 32 79 fb			ld (debug_mark+2),a  
39c9 18 03			jr .pastdmark  
39cb ..			.dmark: db "RN3"  
39ce f1			.pastdmark: pop af  
39cf			endm  
# End of macro DMARK
39cf						CALLMONITOR 
39cf cd 74 17			call break_point_state  
39d2				endm  
# End of macro CALLMONITOR
39d2					endif 
39d2					 
39d2					; if the range is 8bit knock out the high byte 
39d2			 
39d2 ed 5b bc f8			ld de, (LFSRSeed)     ; check high level 
39d6			 
39d6 3e 00				ld a, 0 
39d8 ba					cp d  
39d9 20 1e				jr nz, .hirange 
39db 26 00				ld h, 0   ; knock it down to 8bit 
39dd			 
39dd					if DEBUG_FORTH_WORDS 
39dd						DMARK "RNk" 
39dd f5				push af  
39de 3a f2 39			ld a, (.dmark)  
39e1 32 77 fb			ld (debug_mark),a  
39e4 3a f3 39			ld a, (.dmark+1)  
39e7 32 78 fb			ld (debug_mark+1),a  
39ea 3a f4 39			ld a, (.dmark+2)  
39ed 32 79 fb			ld (debug_mark+2),a  
39f0 18 03			jr .pastdmark  
39f2 ..			.dmark: db "RNk"  
39f5 f1			.pastdmark: pop af  
39f6			endm  
# End of macro DMARK
39f6						CALLMONITOR 
39f6 cd 74 17			call break_point_state  
39f9				endm  
# End of macro CALLMONITOR
39f9					endif 
39f9			.hirange:   
39f9 e5					push hl  
39fa b7					or a  
39fb ed 52		                sbc hl, de 
39fd			 
39fd					;call cmp16 
39fd			 
39fd 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39ff e1					pop hl 
3a00 e5					push hl 
3a01			 
3a01					if DEBUG_FORTH_WORDS 
3a01						DMARK "RN4" 
3a01 f5				push af  
3a02 3a 16 3a			ld a, (.dmark)  
3a05 32 77 fb			ld (debug_mark),a  
3a08 3a 17 3a			ld a, (.dmark+1)  
3a0b 32 78 fb			ld (debug_mark+1),a  
3a0e 3a 18 3a			ld a, (.dmark+2)  
3a11 32 79 fb			ld (debug_mark+2),a  
3a14 18 03			jr .pastdmark  
3a16 ..			.dmark: db "RN4"  
3a19 f1			.pastdmark: pop af  
3a1a			endm  
# End of macro DMARK
3a1a						CALLMONITOR 
3a1a cd 74 17			call break_point_state  
3a1d				endm  
# End of macro CALLMONITOR
3a1d					endif 
3a1d ed 5b be f8			ld de, (LFSRSeed+2)   ; check low range 
3a21					;call cmp16 
3a21				 
3a21 b7					or a  
3a22 ed 52		                sbc hl, de 
3a24 38 8c				jr c, .inrange 
3a26			 
3a26 e1					pop hl 
3a27					 
3a27					if DEBUG_FORTH_WORDS 
3a27						DMARK "RNd" 
3a27 f5				push af  
3a28 3a 3c 3a			ld a, (.dmark)  
3a2b 32 77 fb			ld (debug_mark),a  
3a2e 3a 3d 3a			ld a, (.dmark+1)  
3a31 32 78 fb			ld (debug_mark+1),a  
3a34 3a 3e 3a			ld a, (.dmark+2)  
3a37 32 79 fb			ld (debug_mark+2),a  
3a3a 18 03			jr .pastdmark  
3a3c ..			.dmark: db "RNd"  
3a3f f1			.pastdmark: pop af  
3a40			endm  
# End of macro DMARK
3a40						CALLMONITOR 
3a40 cd 74 17			call break_point_state  
3a43				endm  
# End of macro CALLMONITOR
3a43					endif 
3a43			 
3a43			 
3a43 cd 04 1d				call forth_push_numhl 
3a46				       NEXTW 
3a46 c3 6d 20			jp macro_next 
3a49				endm 
# End of macro NEXTW
3a49			 
3a49			.ENDMATHS: 
3a49			 
3a49			; eof 
3a49			 
# End of file forth_words_maths.asm
3a49			include "forth_words_display.asm" 
3a49			 
3a49			; | ## Display Words 
3a49			 
3a49			.INFO: 
3a49			 
3a49				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a49 62				db WORD_SYS_CORE+78             
3a4a 66 3a			dw .ATP            
3a4c 05				db 4 + 1 
3a4d .. 00			db "INFO",0              
3a52				endm 
# End of macro CWHEAD
3a52			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a52					FORTH_DSP_VALUEHL 
3a52 cd fb 1e			call macro_dsp_valuehl 
3a55				endm 
# End of macro FORTH_DSP_VALUEHL
3a55			 
3a55					FORTH_DSP_POP 
3a55 cd b3 1f			call macro_forth_dsp_pop 
3a58				endm 
# End of macro FORTH_DSP_POP
3a58			 
3a58 e5					push hl 
3a59			 
3a59					FORTH_DSP_VALUEHL 
3a59 cd fb 1e			call macro_dsp_valuehl 
3a5c				endm 
# End of macro FORTH_DSP_VALUEHL
3a5c			 
3a5c					FORTH_DSP_POP 
3a5c cd b3 1f			call macro_forth_dsp_pop 
3a5f				endm 
# End of macro FORTH_DSP_POP
3a5f			 
3a5f d1					pop de 
3a60			 
3a60 cd 7d 0a				call info_panel 
3a63			 
3a63			 
3a63					NEXTW 
3a63 c3 6d 20			jp macro_next 
3a66				endm 
# End of macro NEXTW
3a66			.ATP: 
3a66				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a66 62				db WORD_SYS_CORE+78             
3a67 dd 3a			dw .FB            
3a69 04				db 3 + 1 
3a6a .. 00			db "AT?",0              
3a6e				endm 
# End of macro CWHEAD
3a6e			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a6e					if DEBUG_FORTH_WORDS_KEY 
3a6e						DMARK "AT?" 
3a6e f5				push af  
3a6f 3a 83 3a			ld a, (.dmark)  
3a72 32 77 fb			ld (debug_mark),a  
3a75 3a 84 3a			ld a, (.dmark+1)  
3a78 32 78 fb			ld (debug_mark+1),a  
3a7b 3a 85 3a			ld a, (.dmark+2)  
3a7e 32 79 fb			ld (debug_mark+2),a  
3a81 18 03			jr .pastdmark  
3a83 ..			.dmark: db "AT?"  
3a86 f1			.pastdmark: pop af  
3a87			endm  
# End of macro DMARK
3a87						CALLMONITOR 
3a87 cd 74 17			call break_point_state  
3a8a				endm  
# End of macro CALLMONITOR
3a8a					endif 
3a8a 3a 46 f8				ld a, (f_cursor_ptr) 
3a8d			 
3a8d			if DEBUG_FORTH_WORDS 
3a8d				DMARK "AT?" 
3a8d f5				push af  
3a8e 3a a2 3a			ld a, (.dmark)  
3a91 32 77 fb			ld (debug_mark),a  
3a94 3a a3 3a			ld a, (.dmark+1)  
3a97 32 78 fb			ld (debug_mark+1),a  
3a9a 3a a4 3a			ld a, (.dmark+2)  
3a9d 32 79 fb			ld (debug_mark+2),a  
3aa0 18 03			jr .pastdmark  
3aa2 ..			.dmark: db "AT?"  
3aa5 f1			.pastdmark: pop af  
3aa6			endm  
# End of macro DMARK
3aa6				CALLMONITOR 
3aa6 cd 74 17			call break_point_state  
3aa9				endm  
# End of macro CALLMONITOR
3aa9			endif	 
3aa9					; count the number of rows 
3aa9			 
3aa9 06 00				ld b, 0 
3aab 4f			.atpr:		ld c, a    ; save in case we go below zero 
3aac d6 28				sub display_cols 
3aae f2 b4 3a				jp p, .atprunder 
3ab1 04					inc b 
3ab2 18 f7				jr .atpr 
3ab4			.atprunder:	 
3ab4			if DEBUG_FORTH_WORDS 
3ab4				DMARK "A?2" 
3ab4 f5				push af  
3ab5 3a c9 3a			ld a, (.dmark)  
3ab8 32 77 fb			ld (debug_mark),a  
3abb 3a ca 3a			ld a, (.dmark+1)  
3abe 32 78 fb			ld (debug_mark+1),a  
3ac1 3a cb 3a			ld a, (.dmark+2)  
3ac4 32 79 fb			ld (debug_mark+2),a  
3ac7 18 03			jr .pastdmark  
3ac9 ..			.dmark: db "A?2"  
3acc f1			.pastdmark: pop af  
3acd			endm  
# End of macro DMARK
3acd				CALLMONITOR 
3acd cd 74 17			call break_point_state  
3ad0				endm  
# End of macro CALLMONITOR
3ad0			endif	 
3ad0 26 00				ld h, 0 
3ad2 69					ld l, c 
3ad3 cd 04 1d				call forth_push_numhl 
3ad6 68					ld l, b  
3ad7 cd 04 1d				call forth_push_numhl 
3ada			 
3ada			 
3ada				NEXTW 
3ada c3 6d 20			jp macro_next 
3add				endm 
# End of macro NEXTW
3add			 
3add			.FB: 
3add				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3add 1b				db WORD_SYS_CORE+7             
3ade 2b 3b			dw .EMIT            
3ae0 03				db 2 + 1 
3ae1 .. 00			db "FB",0              
3ae4				endm 
# End of macro CWHEAD
3ae4			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ae4			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ae4			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ae4			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ae4					if DEBUG_FORTH_WORDS_KEY 
3ae4						DMARK "FB." 
3ae4 f5				push af  
3ae5 3a f9 3a			ld a, (.dmark)  
3ae8 32 77 fb			ld (debug_mark),a  
3aeb 3a fa 3a			ld a, (.dmark+1)  
3aee 32 78 fb			ld (debug_mark+1),a  
3af1 3a fb 3a			ld a, (.dmark+2)  
3af4 32 79 fb			ld (debug_mark+2),a  
3af7 18 03			jr .pastdmark  
3af9 ..			.dmark: db "FB."  
3afc f1			.pastdmark: pop af  
3afd			endm  
# End of macro DMARK
3afd						CALLMONITOR 
3afd cd 74 17			call break_point_state  
3b00				endm  
# End of macro CALLMONITOR
3b00					endif 
3b00			 
3b00					FORTH_DSP_VALUEHL 
3b00 cd fb 1e			call macro_dsp_valuehl 
3b03				endm 
# End of macro FORTH_DSP_VALUEHL
3b03			 
3b03 7d					ld a, l 
3b04 fe 01				cp 1 
3b06 20 05				jr nz, .fbn1 
3b08 21 1c fa				ld hl, display_fb1 
3b0b 18 15				jr .fbset 
3b0d fe 02		.fbn1:		cp 2 
3b0f 20 05				jr nz, .fbn2 
3b11 21 da f8				ld hl, display_fb2 
3b14 18 0c				jr .fbset 
3b16 fe 03		.fbn2:		cp 3 
3b18 20 05				jr nz, .fbn3 
3b1a 21 7b f9				ld hl, display_fb3 
3b1d 18 03				jr .fbset 
3b1f			.fbn3:		 ; if invalid number select first 
3b1f 21 1c fa				ld hl, display_fb1 
3b22 22 d8 f8		.fbset:		ld (display_fb_active), hl 
3b25			 
3b25					FORTH_DSP_POP 
3b25 cd b3 1f			call macro_forth_dsp_pop 
3b28				endm 
# End of macro FORTH_DSP_POP
3b28			 
3b28					NEXTW 
3b28 c3 6d 20			jp macro_next 
3b2b				endm 
# End of macro NEXTW
3b2b			 
3b2b			 
3b2b			.EMIT: 
3b2b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b2b 1b				db WORD_SYS_CORE+7             
3b2c 7c 3b			dw .DOTH            
3b2e 05				db 4 + 1 
3b2f .. 00			db "EMIT",0              
3b34				endm 
# End of macro CWHEAD
3b34			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b34					; get value off TOS and display it 
3b34			 
3b34					if DEBUG_FORTH_WORDS_KEY 
3b34						DMARK "EMT" 
3b34 f5				push af  
3b35 3a 49 3b			ld a, (.dmark)  
3b38 32 77 fb			ld (debug_mark),a  
3b3b 3a 4a 3b			ld a, (.dmark+1)  
3b3e 32 78 fb			ld (debug_mark+1),a  
3b41 3a 4b 3b			ld a, (.dmark+2)  
3b44 32 79 fb			ld (debug_mark+2),a  
3b47 18 03			jr .pastdmark  
3b49 ..			.dmark: db "EMT"  
3b4c f1			.pastdmark: pop af  
3b4d			endm  
# End of macro DMARK
3b4d						CALLMONITOR 
3b4d cd 74 17			call break_point_state  
3b50				endm  
# End of macro CALLMONITOR
3b50					endif 
3b50			 
3b50					FORTH_DSP_VALUEHL 
3b50 cd fb 1e			call macro_dsp_valuehl 
3b53				endm 
# End of macro FORTH_DSP_VALUEHL
3b53			 
3b53 7d					ld a,l 
3b54			 
3b54					; TODO write to display 
3b54			 
3b54 32 1b f0				ld (os_input), a 
3b57 3e 00				ld a, 0 
3b59 32 1c f0				ld (os_input+1), a 
3b5c					 
3b5c 3a 46 f8				ld a, (f_cursor_ptr) 
3b5f 11 1b f0				ld de, os_input 
3b62 cd ff 0a				call str_at_display 
3b65			 
3b65			 
3b65 3a 24 f8				ld a,(cli_autodisplay) 
3b68 fe 00				cp 0 
3b6a 28 03				jr z, .enoupdate 
3b6c cd 0f 0b						call update_display 
3b6f					.enoupdate: 
3b6f			 
3b6f 3a 46 f8				ld a, (f_cursor_ptr) 
3b72 3c					inc a 
3b73 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3b76			 
3b76			 
3b76					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b76 cd b3 1f			call macro_forth_dsp_pop 
3b79				endm 
# End of macro FORTH_DSP_POP
3b79			  
3b79			 
3b79					NEXTW 
3b79 c3 6d 20			jp macro_next 
3b7c				endm 
# End of macro NEXTW
3b7c			.DOTH: 
3b7c				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b7c 1c				db WORD_SYS_CORE+8             
3b7d ac 3b			dw .DOTF            
3b7f 03				db 2 + 1 
3b80 .. 00			db ".-",0              
3b83				endm 
# End of macro CWHEAD
3b83			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b83					; get value off TOS and display it 
3b83					if DEBUG_FORTH_WORDS_KEY 
3b83						DMARK "DTD" 
3b83 f5				push af  
3b84 3a 98 3b			ld a, (.dmark)  
3b87 32 77 fb			ld (debug_mark),a  
3b8a 3a 99 3b			ld a, (.dmark+1)  
3b8d 32 78 fb			ld (debug_mark+1),a  
3b90 3a 9a 3b			ld a, (.dmark+2)  
3b93 32 79 fb			ld (debug_mark+2),a  
3b96 18 03			jr .pastdmark  
3b98 ..			.dmark: db "DTD"  
3b9b f1			.pastdmark: pop af  
3b9c			endm  
# End of macro DMARK
3b9c						CALLMONITOR 
3b9c cd 74 17			call break_point_state  
3b9f				endm  
# End of macro CALLMONITOR
3b9f					endif 
3b9f 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3ba1 3e 00			ld a, 0 
3ba3 32 25 f8			ld (cli_mvdot), a 
3ba6 c3 03 3c			jp .dotgo 
3ba9				NEXTW 
3ba9 c3 6d 20			jp macro_next 
3bac				endm 
# End of macro NEXTW
3bac			.DOTF: 
3bac				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3bac 1c				db WORD_SYS_CORE+8             
3bad da 3b			dw .DOT            
3baf 03				db 2 + 1 
3bb0 .. 00			db ".>",0              
3bb3				endm 
# End of macro CWHEAD
3bb3			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3bb3					; get value off TOS and display it 
3bb3			        ; TODO BUG adds extra spaces 
3bb3			        ; TODO BUG handle numerics? 
3bb3					if DEBUG_FORTH_WORDS_KEY 
3bb3						DMARK "DTC" 
3bb3 f5				push af  
3bb4 3a c8 3b			ld a, (.dmark)  
3bb7 32 77 fb			ld (debug_mark),a  
3bba 3a c9 3b			ld a, (.dmark+1)  
3bbd 32 78 fb			ld (debug_mark+1),a  
3bc0 3a ca 3b			ld a, (.dmark+2)  
3bc3 32 79 fb			ld (debug_mark+2),a  
3bc6 18 03			jr .pastdmark  
3bc8 ..			.dmark: db "DTC"  
3bcb f1			.pastdmark: pop af  
3bcc			endm  
# End of macro DMARK
3bcc						CALLMONITOR 
3bcc cd 74 17			call break_point_state  
3bcf				endm  
# End of macro CALLMONITOR
3bcf					endif 
3bcf 3e 01			ld a, 1 
3bd1 32 25 f8			ld (cli_mvdot), a 
3bd4 c3 03 3c			jp .dotgo 
3bd7				NEXTW 
3bd7 c3 6d 20			jp macro_next 
3bda				endm 
# End of macro NEXTW
3bda			 
3bda			.DOT: 
3bda				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3bda 1c				db WORD_SYS_CORE+8             
3bdb 66 3c			dw .CLS            
3bdd 02				db 1 + 1 
3bde .. 00			db ".",0              
3be0				endm 
# End of macro CWHEAD
3be0			        ; | . ( u -- ) Display TOS | DONE 
3be0					; get value off TOS and display it 
3be0			 
3be0					if DEBUG_FORTH_WORDS_KEY 
3be0						DMARK "DOT" 
3be0 f5				push af  
3be1 3a f5 3b			ld a, (.dmark)  
3be4 32 77 fb			ld (debug_mark),a  
3be7 3a f6 3b			ld a, (.dmark+1)  
3bea 32 78 fb			ld (debug_mark+1),a  
3bed 3a f7 3b			ld a, (.dmark+2)  
3bf0 32 79 fb			ld (debug_mark+2),a  
3bf3 18 03			jr .pastdmark  
3bf5 ..			.dmark: db "DOT"  
3bf8 f1			.pastdmark: pop af  
3bf9			endm  
# End of macro DMARK
3bf9						CALLMONITOR 
3bf9 cd 74 17			call break_point_state  
3bfc				endm  
# End of macro CALLMONITOR
3bfc					endif 
3bfc 3e 00			ld a, 0 
3bfe 32 25 f8			ld (cli_mvdot), a 
3c01 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c03				 
3c03			 
3c03			.dotgo: 
3c03			 
3c03			; move up type to on stack for parserv5 
3c03					FORTH_DSP 
3c03 cd c1 1e			call macro_forth_dsp 
3c06				endm 
# End of macro FORTH_DSP
3c06				;FORTH_DSP_VALUE  
3c06			 
3c06			if DEBUG_FORTH_DOT 
3c06				DMARK "DOT" 
3c06				CALLMONITOR 
3c06			endif	 
3c06			;		.print: 
3c06			 
3c06 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c07 23				inc hl   ; position to the actual value 
3c08 fe 01			cp DS_TYPE_STR 
3c0a 20 06			jr nz, .dotnum1  
3c0c			 
3c0c			; display string 
3c0c				FORTH_DSP_VALUE  
3c0c cd e4 1e			call macro_forth_dsp_value 
3c0f				endm 
# End of macro FORTH_DSP_VALUE
3c0f eb				ex de,hl 
3c10 18 11			jr .dotwrite 
3c12			 
3c12			.dotnum1: 
3c12 fe 02			cp DS_TYPE_INUM 
3c14 20 0c			jr nz, .dotflot 
3c16			 
3c16			 
3c16			; display number 
3c16			 
3c16			;	push hl 
3c16			;	call clear_display 
3c16			;	pop hl 
3c16			 
3c16 5e				ld e, (hl) 
3c17 23				inc hl 
3c18 56				ld d, (hl) 
3c19 21 1d ee			ld hl, scratch 
3c1c			if DEBUG_FORTH_DOT 
3c1c				DMARK "DT1" 
3c1c				CALLMONITOR 
3c1c			endif	 
3c1c			 
3c1c cd 2d 11			call uitoa_16 
3c1f eb				ex de,hl 
3c20			 
3c20			if DEBUG_FORTH_DOT 
3c20				DMARK "DT2" 
3c20				CALLMONITOR 
3c20			endif	 
3c20			 
3c20			;	ld de, os_word_scratch 
3c20 18 01			jr .dotwrite 
3c22			 
3c22 00			.dotflot:   nop 
3c23			; TODO print floating point number 
3c23			 
3c23			.dotwrite:		 
3c23			 
3c23					; if c is set then set all '-' to spaces 
3c23					; need to also take into account .>  
3c23			 
3c23 3e 01				ld a, 1 
3c25 b9					cp c 
3c26 20 13				jr nz, .nodashswap 
3c28			 
3c28					; DE has the string to write, working with HL 
3c28			 
3c28 06 ff				ld b, 255 
3c2a d5					push de 
3c2b e1					pop hl 
3c2c			 
3c2c			if DEBUG_FORTH_DOT 
3c2c				DMARK "DT-" 
3c2c				CALLMONITOR 
3c2c			endif	 
3c2c 7e			.dashscan:	ld a, (hl) 
3c2d fe 00				cp 0 
3c2f 28 0a				jr z, .nodashswap 
3c31 fe 2d				cp '-' 
3c33 20 03				jr nz, .dashskip 
3c35 3e 20				ld a, ' ' 
3c37 77					ld (hl), a 
3c38 23			.dashskip:	inc hl 
3c39			if DEBUG_FORTH_DOT 
3c39				DMARK "D-2" 
3c39				CALLMONITOR 
3c39			endif	 
3c39 10 f1				djnz .dashscan 
3c3b			 
3c3b			if DEBUG_FORTH_DOT 
3c3b				DMARK "D-1" 
3c3b				CALLMONITOR 
3c3b			endif	 
3c3b			 
3c3b			.nodashswap: 
3c3b			 
3c3b e5					push hl   ; save string start in case we need to advance print 
3c3c			 
3c3c 3a 46 f8				ld a, (f_cursor_ptr) 
3c3f cd ff 0a				call str_at_display 
3c42 3a 24 f8				ld a,(cli_autodisplay) 
3c45 fe 00				cp 0 
3c47 28 03				jr z, .noupdate 
3c49 cd 0f 0b						call update_display 
3c4c					.noupdate: 
3c4c			 
3c4c			 
3c4c					; see if we need to advance the print position 
3c4c			 
3c4c e1					pop hl   ; get back string 
3c4d			 
3c4d 3a 25 f8				ld a, (cli_mvdot) 
3c50			if DEBUG_FORTH_DOT 
3c50					ld e,a 
3c50				DMARK "D>1" 
3c50				CALLMONITOR 
3c50			endif	 
3c50 fe 00				cp 0 
3c52 28 0c				jr z, .noadv 
3c54					; yes, lets advance the print position 
3c54 3e 00				ld a, 0 
3c56 cd 89 11				call strlent 
3c59 3a 46 f8				ld a, (f_cursor_ptr) 
3c5c 85					add a,l 
3c5d					;call addatohl 
3c5d					;ld a, l 
3c5d 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3c60			 
3c60			if DEBUG_FORTH_DOT 
3c60				DMARK "D->" 
3c60				CALLMONITOR 
3c60			endif	 
3c60			 
3c60			.noadv:	 
3c60			 
3c60					if DEBUG_FORTH_DOT_WAIT 
3c60							call next_page_prompt 
3c60					endif	 
3c60			; TODO this pop off the stack causes a crash. i dont know why 
3c60			 
3c60			 
3c60			if DEBUG_FORTH_DOT 
3c60				DMARK "DTh" 
3c60				CALLMONITOR 
3c60			endif	 
3c60			 
3c60					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c60 cd b3 1f			call macro_forth_dsp_pop 
3c63				endm 
# End of macro FORTH_DSP_POP
3c63			 
3c63			if DEBUG_FORTH_DOT 
3c63				DMARK "DTi" 
3c63				CALLMONITOR 
3c63			endif	 
3c63			 
3c63			 
3c63					NEXTW 
3c63 c3 6d 20			jp macro_next 
3c66				endm 
# End of macro NEXTW
3c66			 
3c66			.CLS: 
3c66				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3c66 35				db WORD_SYS_CORE+33             
3c67 93 3c			dw .DRAW            
3c69 04				db 3 + 1 
3c6a .. 00			db "CLS",0              
3c6e				endm 
# End of macro CWHEAD
3c6e			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3c6e					if DEBUG_FORTH_WORDS_KEY 
3c6e						DMARK "CLS" 
3c6e f5				push af  
3c6f 3a 83 3c			ld a, (.dmark)  
3c72 32 77 fb			ld (debug_mark),a  
3c75 3a 84 3c			ld a, (.dmark+1)  
3c78 32 78 fb			ld (debug_mark+1),a  
3c7b 3a 85 3c			ld a, (.dmark+2)  
3c7e 32 79 fb			ld (debug_mark+2),a  
3c81 18 03			jr .pastdmark  
3c83 ..			.dmark: db "CLS"  
3c86 f1			.pastdmark: pop af  
3c87			endm  
# End of macro DMARK
3c87						CALLMONITOR 
3c87 cd 74 17			call break_point_state  
3c8a				endm  
# End of macro CALLMONITOR
3c8a					endif 
3c8a cd ec 0a				call clear_display 
3c8d c3 a1 3d				jp .home		; and home cursor 
3c90					NEXTW 
3c90 c3 6d 20			jp macro_next 
3c93				endm 
# End of macro NEXTW
3c93			 
3c93			.DRAW: 
3c93				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3c93 36				db WORD_SYS_CORE+34             
3c94 be 3c			dw .DUMP            
3c96 05				db 4 + 1 
3c97 .. 00			db "DRAW",0              
3c9c				endm 
# End of macro CWHEAD
3c9c			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3c9c					if DEBUG_FORTH_WORDS_KEY 
3c9c						DMARK "DRW" 
3c9c f5				push af  
3c9d 3a b1 3c			ld a, (.dmark)  
3ca0 32 77 fb			ld (debug_mark),a  
3ca3 3a b2 3c			ld a, (.dmark+1)  
3ca6 32 78 fb			ld (debug_mark+1),a  
3ca9 3a b3 3c			ld a, (.dmark+2)  
3cac 32 79 fb			ld (debug_mark+2),a  
3caf 18 03			jr .pastdmark  
3cb1 ..			.dmark: db "DRW"  
3cb4 f1			.pastdmark: pop af  
3cb5			endm  
# End of macro DMARK
3cb5						CALLMONITOR 
3cb5 cd 74 17			call break_point_state  
3cb8				endm  
# End of macro CALLMONITOR
3cb8					endif 
3cb8 cd 0f 0b				call update_display 
3cbb					NEXTW 
3cbb c3 6d 20			jp macro_next 
3cbe				endm 
# End of macro NEXTW
3cbe			 
3cbe			.DUMP: 
3cbe				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3cbe 37				db WORD_SYS_CORE+35             
3cbf f6 3c			dw .CDUMP            
3cc1 05				db 4 + 1 
3cc2 .. 00			db "DUMP",0              
3cc7				endm 
# End of macro CWHEAD
3cc7			; | DUMP ( x -- ) With address x display dump   | DONE 
3cc7			; TODO pop address to use off of the stack 
3cc7					if DEBUG_FORTH_WORDS_KEY 
3cc7						DMARK "DUM" 
3cc7 f5				push af  
3cc8 3a dc 3c			ld a, (.dmark)  
3ccb 32 77 fb			ld (debug_mark),a  
3cce 3a dd 3c			ld a, (.dmark+1)  
3cd1 32 78 fb			ld (debug_mark+1),a  
3cd4 3a de 3c			ld a, (.dmark+2)  
3cd7 32 79 fb			ld (debug_mark+2),a  
3cda 18 03			jr .pastdmark  
3cdc ..			.dmark: db "DUM"  
3cdf f1			.pastdmark: pop af  
3ce0			endm  
# End of macro DMARK
3ce0						CALLMONITOR 
3ce0 cd 74 17			call break_point_state  
3ce3				endm  
# End of macro CALLMONITOR
3ce3					endif 
3ce3 cd ec 0a				call clear_display 
3ce6			 
3ce6					; get address 
3ce6			 
3ce6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ce6 cd fb 1e			call macro_dsp_valuehl 
3ce9				endm 
# End of macro FORTH_DSP_VALUEHL
3ce9				 
3ce9					; save it for cdump 
3ce9			 
3ce9 22 40 f1				ld (os_cur_ptr),hl 
3cec			 
3cec					; destroy value TOS 
3cec			 
3cec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cec cd b3 1f			call macro_forth_dsp_pop 
3cef				endm 
# End of macro FORTH_DSP_POP
3cef			 
3cef cd 84 1b				call dumpcont	; skip old style of param parsing	 
3cf2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3cf3					NEXTW 
3cf3 c3 6d 20			jp macro_next 
3cf6				endm 
# End of macro NEXTW
3cf6			.CDUMP: 
3cf6				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3cf6 38				db WORD_SYS_CORE+36             
3cf7 26 3d			dw .DAT            
3cf9 06				db 5 + 1 
3cfa .. 00			db "CDUMP",0              
3d00				endm 
# End of macro CWHEAD
3d00			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3d00					if DEBUG_FORTH_WORDS_KEY 
3d00						DMARK "CDP" 
3d00 f5				push af  
3d01 3a 15 3d			ld a, (.dmark)  
3d04 32 77 fb			ld (debug_mark),a  
3d07 3a 16 3d			ld a, (.dmark+1)  
3d0a 32 78 fb			ld (debug_mark+1),a  
3d0d 3a 17 3d			ld a, (.dmark+2)  
3d10 32 79 fb			ld (debug_mark+2),a  
3d13 18 03			jr .pastdmark  
3d15 ..			.dmark: db "CDP"  
3d18 f1			.pastdmark: pop af  
3d19			endm  
# End of macro DMARK
3d19						CALLMONITOR 
3d19 cd 74 17			call break_point_state  
3d1c				endm  
# End of macro CALLMONITOR
3d1c					endif 
3d1c cd ec 0a				call clear_display 
3d1f cd 84 1b				call dumpcont	 
3d22 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3d23					NEXTW 
3d23 c3 6d 20			jp macro_next 
3d26				endm 
# End of macro NEXTW
3d26			 
3d26			 
3d26			 
3d26			 
3d26			.DAT: 
3d26				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3d26 3d				db WORD_SYS_CORE+41             
3d27 7c 3d			dw .HOME            
3d29 03				db 2 + 1 
3d2a .. 00			db "AT",0              
3d2d				endm 
# End of macro CWHEAD
3d2d			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3d2d					if DEBUG_FORTH_WORDS_KEY 
3d2d						DMARK "AT." 
3d2d f5				push af  
3d2e 3a 42 3d			ld a, (.dmark)  
3d31 32 77 fb			ld (debug_mark),a  
3d34 3a 43 3d			ld a, (.dmark+1)  
3d37 32 78 fb			ld (debug_mark+1),a  
3d3a 3a 44 3d			ld a, (.dmark+2)  
3d3d 32 79 fb			ld (debug_mark+2),a  
3d40 18 03			jr .pastdmark  
3d42 ..			.dmark: db "AT."  
3d45 f1			.pastdmark: pop af  
3d46			endm  
# End of macro DMARK
3d46						CALLMONITOR 
3d46 cd 74 17			call break_point_state  
3d49				endm  
# End of macro CALLMONITOR
3d49					endif 
3d49					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d49 cd fb 1e			call macro_dsp_valuehl 
3d4c				endm 
# End of macro FORTH_DSP_VALUEHL
3d4c			 
3d4c			 
3d4c					; TODO save cursor row 
3d4c 7d					ld a,l 
3d4d fe 02				cp 2 
3d4f 20 04				jr nz, .crow3 
3d51 3e 28				ld a, display_row_2 
3d53 18 12				jr .ccol1 
3d55 fe 03		.crow3:		cp 3 
3d57 20 04				jr nz, .crow4 
3d59 3e 50				ld a, display_row_3 
3d5b 18 0a				jr .ccol1 
3d5d fe 04		.crow4:		cp 4 
3d5f 20 04				jr nz, .crow1 
3d61 3e 78				ld a, display_row_4 
3d63 18 02				jr .ccol1 
3d65 3e 00		.crow1:		ld a,display_row_1 
3d67 f5			.ccol1:		push af			; got row offset 
3d68 6f					ld l,a 
3d69 26 00				ld h,0 
3d6b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d6b cd b3 1f			call macro_forth_dsp_pop 
3d6e				endm 
# End of macro FORTH_DSP_POP
3d6e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d6e cd fb 1e			call macro_dsp_valuehl 
3d71				endm 
# End of macro FORTH_DSP_VALUEHL
3d71					; TODO save cursor col 
3d71 f1					pop af 
3d72 85					add l		; add col offset 
3d73 32 46 f8				ld (f_cursor_ptr), a 
3d76					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d76 cd b3 1f			call macro_forth_dsp_pop 
3d79				endm 
# End of macro FORTH_DSP_POP
3d79			 
3d79					; calculate  
3d79			 
3d79					NEXTW 
3d79 c3 6d 20			jp macro_next 
3d7c				endm 
# End of macro NEXTW
3d7c			 
3d7c			 
3d7c			.HOME: 
3d7c				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d7c 41				db WORD_SYS_CORE+45             
3d7d a9 3d			dw .SPACE            
3d7f 05				db 4 + 1 
3d80 .. 00			db "HOME",0              
3d85				endm 
# End of macro CWHEAD
3d85			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d85					if DEBUG_FORTH_WORDS_KEY 
3d85						DMARK "HOM" 
3d85 f5				push af  
3d86 3a 9a 3d			ld a, (.dmark)  
3d89 32 77 fb			ld (debug_mark),a  
3d8c 3a 9b 3d			ld a, (.dmark+1)  
3d8f 32 78 fb			ld (debug_mark+1),a  
3d92 3a 9c 3d			ld a, (.dmark+2)  
3d95 32 79 fb			ld (debug_mark+2),a  
3d98 18 03			jr .pastdmark  
3d9a ..			.dmark: db "HOM"  
3d9d f1			.pastdmark: pop af  
3d9e			endm  
# End of macro DMARK
3d9e						CALLMONITOR 
3d9e cd 74 17			call break_point_state  
3da1				endm  
# End of macro CALLMONITOR
3da1					endif 
3da1 3e 00		.home:		ld a, 0		; and home cursor 
3da3 32 46 f8				ld (f_cursor_ptr), a 
3da6					NEXTW 
3da6 c3 6d 20			jp macro_next 
3da9				endm 
# End of macro NEXTW
3da9			 
3da9			 
3da9			.SPACE: 
3da9				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3da9 46				db WORD_SYS_CORE+50             
3daa d7 3d			dw .SPACES            
3dac 03				db 2 + 1 
3dad .. 00			db "BL",0              
3db0				endm 
# End of macro CWHEAD
3db0			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3db0					if DEBUG_FORTH_WORDS_KEY 
3db0						DMARK "BL." 
3db0 f5				push af  
3db1 3a c5 3d			ld a, (.dmark)  
3db4 32 77 fb			ld (debug_mark),a  
3db7 3a c6 3d			ld a, (.dmark+1)  
3dba 32 78 fb			ld (debug_mark+1),a  
3dbd 3a c7 3d			ld a, (.dmark+2)  
3dc0 32 79 fb			ld (debug_mark+2),a  
3dc3 18 03			jr .pastdmark  
3dc5 ..			.dmark: db "BL."  
3dc8 f1			.pastdmark: pop af  
3dc9			endm  
# End of macro DMARK
3dc9						CALLMONITOR 
3dc9 cd 74 17			call break_point_state  
3dcc				endm  
# End of macro CALLMONITOR
3dcc					endif 
3dcc 21 d5 3d				ld hl, .blstr 
3dcf cd 72 1d				call forth_push_str 
3dd2					 
3dd2				       NEXTW 
3dd2 c3 6d 20			jp macro_next 
3dd5				endm 
# End of macro NEXTW
3dd5			 
3dd5 .. 00		.blstr: db " ", 0 
3dd7			 
3dd7			.SPACES: 
3dd7				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3dd7 47				db WORD_SYS_CORE+51             
3dd8 72 3e			dw .SCROLL            
3dda 07				db 6 + 1 
3ddb .. 00			db "SPACES",0              
3de2				endm 
# End of macro CWHEAD
3de2			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3de2					if DEBUG_FORTH_WORDS_KEY 
3de2						DMARK "SPS" 
3de2 f5				push af  
3de3 3a f7 3d			ld a, (.dmark)  
3de6 32 77 fb			ld (debug_mark),a  
3de9 3a f8 3d			ld a, (.dmark+1)  
3dec 32 78 fb			ld (debug_mark+1),a  
3def 3a f9 3d			ld a, (.dmark+2)  
3df2 32 79 fb			ld (debug_mark+2),a  
3df5 18 03			jr .pastdmark  
3df7 ..			.dmark: db "SPS"  
3dfa f1			.pastdmark: pop af  
3dfb			endm  
# End of macro DMARK
3dfb						CALLMONITOR 
3dfb cd 74 17			call break_point_state  
3dfe				endm  
# End of macro CALLMONITOR
3dfe					endif 
3dfe			 
3dfe			 
3dfe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dfe cd fb 1e			call macro_dsp_valuehl 
3e01				endm 
# End of macro FORTH_DSP_VALUEHL
3e01			 
3e01			;		push hl    ; u 
3e01					if DEBUG_FORTH_WORDS 
3e01						DMARK "SPA" 
3e01 f5				push af  
3e02 3a 16 3e			ld a, (.dmark)  
3e05 32 77 fb			ld (debug_mark),a  
3e08 3a 17 3e			ld a, (.dmark+1)  
3e0b 32 78 fb			ld (debug_mark+1),a  
3e0e 3a 18 3e			ld a, (.dmark+2)  
3e11 32 79 fb			ld (debug_mark+2),a  
3e14 18 03			jr .pastdmark  
3e16 ..			.dmark: db "SPA"  
3e19 f1			.pastdmark: pop af  
3e1a			endm  
# End of macro DMARK
3e1a						CALLMONITOR 
3e1a cd 74 17			call break_point_state  
3e1d				endm  
# End of macro CALLMONITOR
3e1d					endif 
3e1d			 
3e1d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e1d cd b3 1f			call macro_forth_dsp_pop 
3e20				endm 
# End of macro FORTH_DSP_POP
3e20			;		pop hl 
3e20 4d					ld c, l 
3e21 06 00				ld b, 0 
3e23 21 1d ee				ld hl, scratch  
3e26			 
3e26					if DEBUG_FORTH_WORDS 
3e26						DMARK "SP2" 
3e26 f5				push af  
3e27 3a 3b 3e			ld a, (.dmark)  
3e2a 32 77 fb			ld (debug_mark),a  
3e2d 3a 3c 3e			ld a, (.dmark+1)  
3e30 32 78 fb			ld (debug_mark+1),a  
3e33 3a 3d 3e			ld a, (.dmark+2)  
3e36 32 79 fb			ld (debug_mark+2),a  
3e39 18 03			jr .pastdmark  
3e3b ..			.dmark: db "SP2"  
3e3e f1			.pastdmark: pop af  
3e3f			endm  
# End of macro DMARK
3e3f						CALLMONITOR 
3e3f cd 74 17			call break_point_state  
3e42				endm  
# End of macro CALLMONITOR
3e42					endif 
3e42 3e 20				ld a, ' ' 
3e44 c5			.spaces1:	push bc 
3e45 77					ld (hl),a 
3e46 23					inc hl 
3e47 c1					pop bc 
3e48 10 fa				djnz .spaces1 
3e4a 3e 00				ld a,0 
3e4c 77					ld (hl),a 
3e4d 21 1d ee				ld hl, scratch 
3e50					if DEBUG_FORTH_WORDS 
3e50						DMARK "SP3" 
3e50 f5				push af  
3e51 3a 65 3e			ld a, (.dmark)  
3e54 32 77 fb			ld (debug_mark),a  
3e57 3a 66 3e			ld a, (.dmark+1)  
3e5a 32 78 fb			ld (debug_mark+1),a  
3e5d 3a 67 3e			ld a, (.dmark+2)  
3e60 32 79 fb			ld (debug_mark+2),a  
3e63 18 03			jr .pastdmark  
3e65 ..			.dmark: db "SP3"  
3e68 f1			.pastdmark: pop af  
3e69			endm  
# End of macro DMARK
3e69						CALLMONITOR 
3e69 cd 74 17			call break_point_state  
3e6c				endm  
# End of macro CALLMONITOR
3e6c					endif 
3e6c cd 6d 1e				call forth_apush 
3e6f			 
3e6f				       NEXTW 
3e6f c3 6d 20			jp macro_next 
3e72				endm 
# End of macro NEXTW
3e72			 
3e72			 
3e72			 
3e72			.SCROLL: 
3e72				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e72 53				db WORD_SYS_CORE+63             
3e73 9f 3e			dw .SCROLLD            
3e75 07				db 6 + 1 
3e76 .. 00			db "SCROLL",0              
3e7d				endm 
# End of macro CWHEAD
3e7d			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e7d					if DEBUG_FORTH_WORDS_KEY 
3e7d						DMARK "SCR" 
3e7d f5				push af  
3e7e 3a 92 3e			ld a, (.dmark)  
3e81 32 77 fb			ld (debug_mark),a  
3e84 3a 93 3e			ld a, (.dmark+1)  
3e87 32 78 fb			ld (debug_mark+1),a  
3e8a 3a 94 3e			ld a, (.dmark+2)  
3e8d 32 79 fb			ld (debug_mark+2),a  
3e90 18 03			jr .pastdmark  
3e92 ..			.dmark: db "SCR"  
3e95 f1			.pastdmark: pop af  
3e96			endm  
# End of macro DMARK
3e96						CALLMONITOR 
3e96 cd 74 17			call break_point_state  
3e99				endm  
# End of macro CALLMONITOR
3e99					endif 
3e99			 
3e99 cd ae 0a			call scroll_up 
3e9c			;	call update_display 
3e9c			 
3e9c					NEXTW 
3e9c c3 6d 20			jp macro_next 
3e9f				endm 
# End of macro NEXTW
3e9f			 
3e9f			 
3e9f			 
3e9f			;		; get dir 
3e9f			; 
3e9f			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e9f			; 
3e9f			;		push hl 
3e9f			; 
3e9f			;		; destroy value TOS 
3e9f			; 
3e9f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e9f			; 
3e9f			;		; get count 
3e9f			; 
3e9f			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e9f			; 
3e9f			;		push hl 
3e9f			; 
3e9f			;		; destroy value TOS 
3e9f			; 
3e9f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e9f			; 
3e9f			;		; one value on hl get other one back 
3e9f			; 
3e9f			;		pop bc    ; count 
3e9f			; 
3e9f			;		pop de   ; dir 
3e9f			; 
3e9f			; 
3e9f			;		ld b, c 
3e9f			; 
3e9f			;.scrolldir:     push bc 
3e9f			;		push de 
3e9f			; 
3e9f			;		ld a, 0 
3e9f			;		cp e 
3e9f			;		jr z, .scrollup  
3e9f			;		call scroll_down 
3e9f			;		jr .scrollnext 
3e9f			;.scrollup:	call scroll_up 
3e9f			; 
3e9f			;		 
3e9f			;.scrollnext: 
3e9f			;		pop de 
3e9f			;		pop bc 
3e9f			;		djnz .scrolldir 
3e9f			; 
3e9f			; 
3e9f			; 
3e9f			; 
3e9f			; 
3e9f			;		NEXTW 
3e9f			 
3e9f			.SCROLLD: 
3e9f				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3e9f 53				db WORD_SYS_CORE+63             
3ea0 cd 3e			dw .ATQ            
3ea2 08				db 7 + 1 
3ea3 .. 00			db "SCROLLD",0              
3eab				endm 
# End of macro CWHEAD
3eab			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3eab					if DEBUG_FORTH_WORDS_KEY 
3eab						DMARK "SCD" 
3eab f5				push af  
3eac 3a c0 3e			ld a, (.dmark)  
3eaf 32 77 fb			ld (debug_mark),a  
3eb2 3a c1 3e			ld a, (.dmark+1)  
3eb5 32 78 fb			ld (debug_mark+1),a  
3eb8 3a c2 3e			ld a, (.dmark+2)  
3ebb 32 79 fb			ld (debug_mark+2),a  
3ebe 18 03			jr .pastdmark  
3ec0 ..			.dmark: db "SCD"  
3ec3 f1			.pastdmark: pop af  
3ec4			endm  
# End of macro DMARK
3ec4						CALLMONITOR 
3ec4 cd 74 17			call break_point_state  
3ec7				endm  
# End of macro CALLMONITOR
3ec7					endif 
3ec7			 
3ec7 cd d2 0a			call scroll_down 
3eca			;	call update_display 
3eca			 
3eca					NEXTW 
3eca c3 6d 20			jp macro_next 
3ecd				endm 
# End of macro NEXTW
3ecd			 
3ecd			 
3ecd			.ATQ: 
3ecd				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3ecd 62				db WORD_SYS_CORE+78             
3ece 2b 3f			dw .AUTODSP            
3ed0 04				db 3 + 1 
3ed1 .. 00			db "AT@",0              
3ed5				endm 
# End of macro CWHEAD
3ed5			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3ed5					if DEBUG_FORTH_WORDS_KEY 
3ed5						DMARK "ATA" 
3ed5 f5				push af  
3ed6 3a ea 3e			ld a, (.dmark)  
3ed9 32 77 fb			ld (debug_mark),a  
3edc 3a eb 3e			ld a, (.dmark+1)  
3edf 32 78 fb			ld (debug_mark+1),a  
3ee2 3a ec 3e			ld a, (.dmark+2)  
3ee5 32 79 fb			ld (debug_mark+2),a  
3ee8 18 03			jr .pastdmark  
3eea ..			.dmark: db "ATA"  
3eed f1			.pastdmark: pop af  
3eee			endm  
# End of macro DMARK
3eee						CALLMONITOR 
3eee cd 74 17			call break_point_state  
3ef1				endm  
# End of macro CALLMONITOR
3ef1					endif 
3ef1			 
3ef1			 
3ef1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ef1 cd fb 1e			call macro_dsp_valuehl 
3ef4				endm 
# End of macro FORTH_DSP_VALUEHL
3ef4			 
3ef4					; TODO save cursor row 
3ef4 7d					ld a,l 
3ef5 fe 02				cp 2 
3ef7 20 04				jr nz, .crow3aq 
3ef9 3e 28				ld a, display_row_2 
3efb 18 12				jr .ccol1aq 
3efd fe 03		.crow3aq:		cp 3 
3eff 20 04				jr nz, .crow4aq 
3f01 3e 50				ld a, display_row_3 
3f03 18 0a				jr .ccol1aq 
3f05 fe 04		.crow4aq:		cp 4 
3f07 20 04				jr nz, .crow1aq 
3f09 3e 78				ld a, display_row_4 
3f0b 18 02				jr .ccol1aq 
3f0d 3e 00		.crow1aq:		ld a,display_row_1 
3f0f f5			.ccol1aq:		push af			; got row offset 
3f10 6f					ld l,a 
3f11 26 00				ld h,0 
3f13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f13 cd b3 1f			call macro_forth_dsp_pop 
3f16				endm 
# End of macro FORTH_DSP_POP
3f16					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f16 cd fb 1e			call macro_dsp_valuehl 
3f19				endm 
# End of macro FORTH_DSP_VALUEHL
3f19					; TODO save cursor col 
3f19 f1					pop af 
3f1a 85					add l		; add col offset 
3f1b			 
3f1b					; add current frame buffer address 
3f1b 2a d8 f8				ld hl, (display_fb_active) 
3f1e cd 20 0d				call addatohl 
3f21			 
3f21			 
3f21			 
3f21			 
3f21					; get char frame buffer location offset in hl 
3f21			 
3f21 7e					ld a,(hl) 
3f22 26 00				ld h, 0 
3f24 6f					ld l, a 
3f25			 
3f25 cd 04 1d				call forth_push_numhl 
3f28			 
3f28			 
3f28					NEXTW 
3f28 c3 6d 20			jp macro_next 
3f2b				endm 
# End of macro NEXTW
3f2b			 
3f2b			.AUTODSP: 
3f2b				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3f2b 63				db WORD_SYS_CORE+79             
3f2c 41 3f			dw .MENU            
3f2e 05				db 4 + 1 
3f2f .. 00			db "ADSP",0              
3f34				endm 
# End of macro CWHEAD
3f34			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3f34			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3f34			 
3f34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f34 cd fb 1e			call macro_dsp_valuehl 
3f37				endm 
# End of macro FORTH_DSP_VALUEHL
3f37			 
3f37			;		push hl 
3f37			 
3f37					; destroy value TOS 
3f37			 
3f37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f37 cd b3 1f			call macro_forth_dsp_pop 
3f3a				endm 
# End of macro FORTH_DSP_POP
3f3a			 
3f3a			;		pop hl 
3f3a			 
3f3a 7d					ld a,l 
3f3b 32 24 f8				ld (cli_autodisplay), a 
3f3e				       NEXTW 
3f3e c3 6d 20			jp macro_next 
3f41				endm 
# End of macro NEXTW
3f41			 
3f41			.MENU: 
3f41				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3f41 70				db WORD_SYS_CORE+92             
3f42 ea 3f			dw .ENDDISPLAY            
3f44 05				db 4 + 1 
3f45 .. 00			db "MENU",0              
3f4a				endm 
# End of macro CWHEAD
3f4a			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3f4a			 
3f4a			;		; get number of items on the stack 
3f4a			; 
3f4a				 
3f4a					FORTH_DSP_VALUEHL 
3f4a cd fb 1e			call macro_dsp_valuehl 
3f4d				endm 
# End of macro FORTH_DSP_VALUEHL
3f4d				 
3f4d					if DEBUG_FORTH_WORDS_KEY 
3f4d						DMARK "MNU" 
3f4d f5				push af  
3f4e 3a 62 3f			ld a, (.dmark)  
3f51 32 77 fb			ld (debug_mark),a  
3f54 3a 63 3f			ld a, (.dmark+1)  
3f57 32 78 fb			ld (debug_mark+1),a  
3f5a 3a 64 3f			ld a, (.dmark+2)  
3f5d 32 79 fb			ld (debug_mark+2),a  
3f60 18 03			jr .pastdmark  
3f62 ..			.dmark: db "MNU"  
3f65 f1			.pastdmark: pop af  
3f66			endm  
# End of macro DMARK
3f66						CALLMONITOR 
3f66 cd 74 17			call break_point_state  
3f69				endm  
# End of macro CALLMONITOR
3f69					endif 
3f69			 
3f69 45					ld b, l	 
3f6a 05					dec b 
3f6b			 
3f6b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f6b cd b3 1f			call macro_forth_dsp_pop 
3f6e				endm 
# End of macro FORTH_DSP_POP
3f6e			 
3f6e			 
3f6e					; go directly through the stack to pluck out the string pointers and build an array 
3f6e			 
3f6e			;		FORTH_DSP 
3f6e			 
3f6e					; hl contains top most stack item 
3f6e				 
3f6e 11 1d ee				ld de, scratch 
3f71			 
3f71			.mbuild: 
3f71			 
3f71					FORTH_DSP_VALUEHL 
3f71 cd fb 1e			call macro_dsp_valuehl 
3f74				endm 
# End of macro FORTH_DSP_VALUEHL
3f74			 
3f74					if DEBUG_FORTH_WORDS 
3f74						DMARK "MN3" 
3f74 f5				push af  
3f75 3a 89 3f			ld a, (.dmark)  
3f78 32 77 fb			ld (debug_mark),a  
3f7b 3a 8a 3f			ld a, (.dmark+1)  
3f7e 32 78 fb			ld (debug_mark+1),a  
3f81 3a 8b 3f			ld a, (.dmark+2)  
3f84 32 79 fb			ld (debug_mark+2),a  
3f87 18 03			jr .pastdmark  
3f89 ..			.dmark: db "MN3"  
3f8c f1			.pastdmark: pop af  
3f8d			endm  
# End of macro DMARK
3f8d						CALLMONITOR 
3f8d cd 74 17			call break_point_state  
3f90				endm  
# End of macro CALLMONITOR
3f90					endif 
3f90 eb					ex de, hl 
3f91 73					ld (hl), e 
3f92 23					inc hl 
3f93 72					ld (hl), d 
3f94 23					inc hl 
3f95 eb					ex de, hl 
3f96			 
3f96					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f96 cd b3 1f			call macro_forth_dsp_pop 
3f99				endm 
# End of macro FORTH_DSP_POP
3f99			 
3f99 10 d6				djnz .mbuild 
3f9b			 
3f9b					; done add term 
3f9b			 
3f9b eb					ex de, hl 
3f9c 36 00				ld (hl), 0 
3f9e 23					inc hl 
3f9f 36 00				ld (hl), 0 
3fa1			 
3fa1				 
3fa1					 
3fa1 21 1d ee				ld hl, scratch 
3fa4			 
3fa4					if DEBUG_FORTH_WORDS 
3fa4						DMARK "MNx" 
3fa4 f5				push af  
3fa5 3a b9 3f			ld a, (.dmark)  
3fa8 32 77 fb			ld (debug_mark),a  
3fab 3a ba 3f			ld a, (.dmark+1)  
3fae 32 78 fb			ld (debug_mark+1),a  
3fb1 3a bb 3f			ld a, (.dmark+2)  
3fb4 32 79 fb			ld (debug_mark+2),a  
3fb7 18 03			jr .pastdmark  
3fb9 ..			.dmark: db "MNx"  
3fbc f1			.pastdmark: pop af  
3fbd			endm  
# End of macro DMARK
3fbd						CALLMONITOR 
3fbd cd 74 17			call break_point_state  
3fc0				endm  
# End of macro CALLMONITOR
3fc0					endif 
3fc0			 
3fc0			 
3fc0			 
3fc0 3e 00				ld a, 0 
3fc2 cd 1d 0b				call menu 
3fc5			 
3fc5			 
3fc5 6f					ld l, a 
3fc6 26 00				ld h, 0 
3fc8			 
3fc8					if DEBUG_FORTH_WORDS 
3fc8						DMARK "MNr" 
3fc8 f5				push af  
3fc9 3a dd 3f			ld a, (.dmark)  
3fcc 32 77 fb			ld (debug_mark),a  
3fcf 3a de 3f			ld a, (.dmark+1)  
3fd2 32 78 fb			ld (debug_mark+1),a  
3fd5 3a df 3f			ld a, (.dmark+2)  
3fd8 32 79 fb			ld (debug_mark+2),a  
3fdb 18 03			jr .pastdmark  
3fdd ..			.dmark: db "MNr"  
3fe0 f1			.pastdmark: pop af  
3fe1			endm  
# End of macro DMARK
3fe1						CALLMONITOR 
3fe1 cd 74 17			call break_point_state  
3fe4				endm  
# End of macro CALLMONITOR
3fe4					endif 
3fe4			 
3fe4 cd 04 1d				call forth_push_numhl 
3fe7			 
3fe7			 
3fe7			 
3fe7			 
3fe7				       NEXTW 
3fe7 c3 6d 20			jp macro_next 
3fea				endm 
# End of macro NEXTW
3fea			 
3fea			 
3fea			.ENDDISPLAY: 
3fea			 
3fea			; eof 
# End of file forth_words_display.asm
3fea			include "forth_words_str.asm" 
3fea			 
3fea			; | ## String Words 
3fea			 
3fea			.PTR:   
3fea			 
3fea				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3fea 48				db WORD_SYS_CORE+52             
3feb 17 40			dw .STYPE            
3fed 04				db 3 + 1 
3fee .. 00			db "PTR",0              
3ff2				endm 
# End of macro CWHEAD
3ff2			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3ff2			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3ff2			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3ff2			 
3ff2					if DEBUG_FORTH_WORDS_KEY 
3ff2						DMARK "PTR" 
3ff2 f5				push af  
3ff3 3a 07 40			ld a, (.dmark)  
3ff6 32 77 fb			ld (debug_mark),a  
3ff9 3a 08 40			ld a, (.dmark+1)  
3ffc 32 78 fb			ld (debug_mark+1),a  
3fff 3a 09 40			ld a, (.dmark+2)  
4002 32 79 fb			ld (debug_mark+2),a  
4005 18 03			jr .pastdmark  
4007 ..			.dmark: db "PTR"  
400a f1			.pastdmark: pop af  
400b			endm  
# End of macro DMARK
400b						CALLMONITOR 
400b cd 74 17			call break_point_state  
400e				endm  
# End of macro CALLMONITOR
400e					endif 
400e					FORTH_DSP_VALUEHL 
400e cd fb 1e			call macro_dsp_valuehl 
4011				endm 
# End of macro FORTH_DSP_VALUEHL
4011 cd 04 1d				call forth_push_numhl 
4014			 
4014			 
4014					NEXTW 
4014 c3 6d 20			jp macro_next 
4017				endm 
# End of macro NEXTW
4017			.STYPE: 
4017				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4017 48				db WORD_SYS_CORE+52             
4018 66 40			dw .UPPER            
401a 06				db 5 + 1 
401b .. 00			db "STYPE",0              
4021				endm 
# End of macro CWHEAD
4021			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4021					if DEBUG_FORTH_WORDS_KEY 
4021						DMARK "STY" 
4021 f5				push af  
4022 3a 36 40			ld a, (.dmark)  
4025 32 77 fb			ld (debug_mark),a  
4028 3a 37 40			ld a, (.dmark+1)  
402b 32 78 fb			ld (debug_mark+1),a  
402e 3a 38 40			ld a, (.dmark+2)  
4031 32 79 fb			ld (debug_mark+2),a  
4034 18 03			jr .pastdmark  
4036 ..			.dmark: db "STY"  
4039 f1			.pastdmark: pop af  
403a			endm  
# End of macro DMARK
403a						CALLMONITOR 
403a cd 74 17			call break_point_state  
403d				endm  
# End of macro CALLMONITOR
403d					endif 
403d					FORTH_DSP 
403d cd c1 1e			call macro_forth_dsp 
4040				endm 
# End of macro FORTH_DSP
4040					;v5 FORTH_DSP_VALUE 
4040			 
4040 7e					ld a, (hl) 
4041			 
4041 f5					push af 
4042			 
4042			; Dont destroy TOS		FORTH_DSP_POP 
4042			 
4042 f1					pop af 
4043			 
4043 fe 01				cp DS_TYPE_STR 
4045 28 09				jr z, .typestr 
4047			 
4047 fe 02				cp DS_TYPE_INUM 
4049 28 0a				jr z, .typeinum 
404b			 
404b 21 64 40				ld hl, .tna 
404e 18 0a				jr .tpush 
4050			 
4050 21 60 40		.typestr:	ld hl, .tstr 
4053 18 05				jr .tpush 
4055 21 62 40		.typeinum:	ld hl, .tinum 
4058 18 00				jr .tpush 
405a			 
405a			.tpush: 
405a			 
405a cd 72 1d				call forth_push_str 
405d			 
405d					NEXTW 
405d c3 6d 20			jp macro_next 
4060				endm 
# End of macro NEXTW
4060 .. 00		.tstr:	db "s",0 
4062 .. 00		.tinum:  db "i",0 
4064 .. 00		.tna:   db "?", 0 
4066			 
4066			 
4066			.UPPER: 
4066				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4066 48				db WORD_SYS_CORE+52             
4067 a1 40			dw .LOWER            
4069 06				db 5 + 1 
406a .. 00			db "UPPER",0              
4070				endm 
# End of macro CWHEAD
4070			; | UPPER ( s -- s ) Upper case string s  | DONE 
4070					if DEBUG_FORTH_WORDS_KEY 
4070						DMARK "UPR" 
4070 f5				push af  
4071 3a 85 40			ld a, (.dmark)  
4074 32 77 fb			ld (debug_mark),a  
4077 3a 86 40			ld a, (.dmark+1)  
407a 32 78 fb			ld (debug_mark+1),a  
407d 3a 87 40			ld a, (.dmark+2)  
4080 32 79 fb			ld (debug_mark+2),a  
4083 18 03			jr .pastdmark  
4085 ..			.dmark: db "UPR"  
4088 f1			.pastdmark: pop af  
4089			endm  
# End of macro DMARK
4089						CALLMONITOR 
4089 cd 74 17			call break_point_state  
408c				endm  
# End of macro CALLMONITOR
408c					endif 
408c			 
408c					FORTH_DSP 
408c cd c1 1e			call macro_forth_dsp 
408f				endm 
# End of macro FORTH_DSP
408f					 
408f			; TODO check is string type 
408f			 
408f					FORTH_DSP_VALUEHL 
408f cd fb 1e			call macro_dsp_valuehl 
4092				endm 
# End of macro FORTH_DSP_VALUEHL
4092			; get pointer to string in hl 
4092			 
4092 7e			.toup:		ld a, (hl) 
4093 fe 00				cp 0 
4095 28 07				jr z, .toupdone 
4097			 
4097 cd 8d 10				call to_upper 
409a			 
409a 77					ld (hl), a 
409b 23					inc hl 
409c 18 f4				jr .toup 
409e			 
409e					 
409e			 
409e			 
409e			; for each char convert to upper 
409e					 
409e			.toupdone: 
409e			 
409e			 
409e					NEXTW 
409e c3 6d 20			jp macro_next 
40a1				endm 
# End of macro NEXTW
40a1			.LOWER: 
40a1				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
40a1 48				db WORD_SYS_CORE+52             
40a2 dc 40			dw .TCASE            
40a4 06				db 5 + 1 
40a5 .. 00			db "LOWER",0              
40ab				endm 
# End of macro CWHEAD
40ab			; | LOWER ( s -- s ) Lower case string s  | DONE 
40ab					if DEBUG_FORTH_WORDS_KEY 
40ab						DMARK "LWR" 
40ab f5				push af  
40ac 3a c0 40			ld a, (.dmark)  
40af 32 77 fb			ld (debug_mark),a  
40b2 3a c1 40			ld a, (.dmark+1)  
40b5 32 78 fb			ld (debug_mark+1),a  
40b8 3a c2 40			ld a, (.dmark+2)  
40bb 32 79 fb			ld (debug_mark+2),a  
40be 18 03			jr .pastdmark  
40c0 ..			.dmark: db "LWR"  
40c3 f1			.pastdmark: pop af  
40c4			endm  
# End of macro DMARK
40c4						CALLMONITOR 
40c4 cd 74 17			call break_point_state  
40c7				endm  
# End of macro CALLMONITOR
40c7					endif 
40c7			 
40c7					FORTH_DSP 
40c7 cd c1 1e			call macro_forth_dsp 
40ca				endm 
# End of macro FORTH_DSP
40ca					 
40ca			; TODO check is string type 
40ca			 
40ca					FORTH_DSP_VALUEHL 
40ca cd fb 1e			call macro_dsp_valuehl 
40cd				endm 
# End of macro FORTH_DSP_VALUEHL
40cd			; get pointer to string in hl 
40cd			 
40cd 7e			.tolow:		ld a, (hl) 
40ce fe 00				cp 0 
40d0 28 07				jr z, .tolowdone 
40d2			 
40d2 cd 96 10				call to_lower 
40d5			 
40d5 77					ld (hl), a 
40d6 23					inc hl 
40d7 18 f4				jr .tolow 
40d9			 
40d9					 
40d9			 
40d9			 
40d9			; for each char convert to low 
40d9					 
40d9			.tolowdone: 
40d9					NEXTW 
40d9 c3 6d 20			jp macro_next 
40dc				endm 
# End of macro NEXTW
40dc			.TCASE: 
40dc				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
40dc 48				db WORD_SYS_CORE+52             
40dd 12 42			dw .SUBSTR            
40df 06				db 5 + 1 
40e0 .. 00			db "TCASE",0              
40e6				endm 
# End of macro CWHEAD
40e6			; | TCASE ( s -- s ) Title case string s  | DONE 
40e6					if DEBUG_FORTH_WORDS_KEY 
40e6						DMARK "TCS" 
40e6 f5				push af  
40e7 3a fb 40			ld a, (.dmark)  
40ea 32 77 fb			ld (debug_mark),a  
40ed 3a fc 40			ld a, (.dmark+1)  
40f0 32 78 fb			ld (debug_mark+1),a  
40f3 3a fd 40			ld a, (.dmark+2)  
40f6 32 79 fb			ld (debug_mark+2),a  
40f9 18 03			jr .pastdmark  
40fb ..			.dmark: db "TCS"  
40fe f1			.pastdmark: pop af  
40ff			endm  
# End of macro DMARK
40ff						CALLMONITOR 
40ff cd 74 17			call break_point_state  
4102				endm  
# End of macro CALLMONITOR
4102					endif 
4102			 
4102					FORTH_DSP 
4102 cd c1 1e			call macro_forth_dsp 
4105				endm 
# End of macro FORTH_DSP
4105					 
4105			; TODO check is string type 
4105			 
4105					FORTH_DSP_VALUEHL 
4105 cd fb 1e			call macro_dsp_valuehl 
4108				endm 
# End of macro FORTH_DSP_VALUEHL
4108			; get pointer to string in hl 
4108			 
4108					if DEBUG_FORTH_WORDS 
4108						DMARK "TC1" 
4108 f5				push af  
4109 3a 1d 41			ld a, (.dmark)  
410c 32 77 fb			ld (debug_mark),a  
410f 3a 1e 41			ld a, (.dmark+1)  
4112 32 78 fb			ld (debug_mark+1),a  
4115 3a 1f 41			ld a, (.dmark+2)  
4118 32 79 fb			ld (debug_mark+2),a  
411b 18 03			jr .pastdmark  
411d ..			.dmark: db "TC1"  
4120 f1			.pastdmark: pop af  
4121			endm  
# End of macro DMARK
4121						CALLMONITOR 
4121 cd 74 17			call break_point_state  
4124				endm  
# End of macro CALLMONITOR
4124					endif 
4124			 
4124					; first time in turn to upper case first char 
4124			 
4124 7e					ld a, (hl) 
4125 c3 af 41				jp .totsiptou 
4128			 
4128			 
4128 7e			.tot:		ld a, (hl) 
4129 fe 00				cp 0 
412b ca f3 41				jp z, .totdone 
412e			 
412e					if DEBUG_FORTH_WORDS 
412e						DMARK "TC2" 
412e f5				push af  
412f 3a 43 41			ld a, (.dmark)  
4132 32 77 fb			ld (debug_mark),a  
4135 3a 44 41			ld a, (.dmark+1)  
4138 32 78 fb			ld (debug_mark+1),a  
413b 3a 45 41			ld a, (.dmark+2)  
413e 32 79 fb			ld (debug_mark+2),a  
4141 18 03			jr .pastdmark  
4143 ..			.dmark: db "TC2"  
4146 f1			.pastdmark: pop af  
4147			endm  
# End of macro DMARK
4147						CALLMONITOR 
4147 cd 74 17			call break_point_state  
414a				endm  
# End of macro CALLMONITOR
414a					endif 
414a					; check to see if current char is a space 
414a			 
414a fe 20				cp ' ' 
414c 28 21				jr z, .totsp 
414e cd 96 10				call to_lower 
4151					if DEBUG_FORTH_WORDS 
4151						DMARK "TC3" 
4151 f5				push af  
4152 3a 66 41			ld a, (.dmark)  
4155 32 77 fb			ld (debug_mark),a  
4158 3a 67 41			ld a, (.dmark+1)  
415b 32 78 fb			ld (debug_mark+1),a  
415e 3a 68 41			ld a, (.dmark+2)  
4161 32 79 fb			ld (debug_mark+2),a  
4164 18 03			jr .pastdmark  
4166 ..			.dmark: db "TC3"  
4169 f1			.pastdmark: pop af  
416a			endm  
# End of macro DMARK
416a						CALLMONITOR 
416a cd 74 17			call break_point_state  
416d				endm  
# End of macro CALLMONITOR
416d					endif 
416d 18 63				jr .totnxt 
416f			 
416f			.totsp:         ; on a space, find next char which should be upper 
416f			 
416f					if DEBUG_FORTH_WORDS 
416f						DMARK "TC4" 
416f f5				push af  
4170 3a 84 41			ld a, (.dmark)  
4173 32 77 fb			ld (debug_mark),a  
4176 3a 85 41			ld a, (.dmark+1)  
4179 32 78 fb			ld (debug_mark+1),a  
417c 3a 86 41			ld a, (.dmark+2)  
417f 32 79 fb			ld (debug_mark+2),a  
4182 18 03			jr .pastdmark  
4184 ..			.dmark: db "TC4"  
4187 f1			.pastdmark: pop af  
4188			endm  
# End of macro DMARK
4188						CALLMONITOR 
4188 cd 74 17			call break_point_state  
418b				endm  
# End of macro CALLMONITOR
418b					endif 
418b					;; 
418b			 
418b fe 20				cp ' ' 
418d 20 20				jr nz, .totsiptou 
418f 23					inc hl 
4190 7e					ld a, (hl) 
4191					if DEBUG_FORTH_WORDS 
4191						DMARK "TC5" 
4191 f5				push af  
4192 3a a6 41			ld a, (.dmark)  
4195 32 77 fb			ld (debug_mark),a  
4198 3a a7 41			ld a, (.dmark+1)  
419b 32 78 fb			ld (debug_mark+1),a  
419e 3a a8 41			ld a, (.dmark+2)  
41a1 32 79 fb			ld (debug_mark+2),a  
41a4 18 03			jr .pastdmark  
41a6 ..			.dmark: db "TC5"  
41a9 f1			.pastdmark: pop af  
41aa			endm  
# End of macro DMARK
41aa						CALLMONITOR 
41aa cd 74 17			call break_point_state  
41ad				endm  
# End of macro CALLMONITOR
41ad					endif 
41ad 18 c0				jr .totsp 
41af fe 00		.totsiptou:    cp 0 
41b1 28 40				jr z, .totdone 
41b3					; not space and not zero term so upper case it 
41b3 cd 8d 10				call to_upper 
41b6			 
41b6					if DEBUG_FORTH_WORDS 
41b6						DMARK "TC6" 
41b6 f5				push af  
41b7 3a cb 41			ld a, (.dmark)  
41ba 32 77 fb			ld (debug_mark),a  
41bd 3a cc 41			ld a, (.dmark+1)  
41c0 32 78 fb			ld (debug_mark+1),a  
41c3 3a cd 41			ld a, (.dmark+2)  
41c6 32 79 fb			ld (debug_mark+2),a  
41c9 18 03			jr .pastdmark  
41cb ..			.dmark: db "TC6"  
41ce f1			.pastdmark: pop af  
41cf			endm  
# End of macro DMARK
41cf						CALLMONITOR 
41cf cd 74 17			call break_point_state  
41d2				endm  
# End of macro CALLMONITOR
41d2					endif 
41d2			 
41d2			 
41d2			.totnxt: 
41d2			 
41d2 77					ld (hl), a 
41d3 23					inc hl 
41d4					if DEBUG_FORTH_WORDS 
41d4						DMARK "TC7" 
41d4 f5				push af  
41d5 3a e9 41			ld a, (.dmark)  
41d8 32 77 fb			ld (debug_mark),a  
41db 3a ea 41			ld a, (.dmark+1)  
41de 32 78 fb			ld (debug_mark+1),a  
41e1 3a eb 41			ld a, (.dmark+2)  
41e4 32 79 fb			ld (debug_mark+2),a  
41e7 18 03			jr .pastdmark  
41e9 ..			.dmark: db "TC7"  
41ec f1			.pastdmark: pop af  
41ed			endm  
# End of macro DMARK
41ed						CALLMONITOR 
41ed cd 74 17			call break_point_state  
41f0				endm  
# End of macro CALLMONITOR
41f0					endif 
41f0 c3 28 41				jp .tot 
41f3			 
41f3					 
41f3			 
41f3			 
41f3			; for each char convert to low 
41f3					 
41f3			.totdone: 
41f3					if DEBUG_FORTH_WORDS 
41f3						DMARK "TCd" 
41f3 f5				push af  
41f4 3a 08 42			ld a, (.dmark)  
41f7 32 77 fb			ld (debug_mark),a  
41fa 3a 09 42			ld a, (.dmark+1)  
41fd 32 78 fb			ld (debug_mark+1),a  
4200 3a 0a 42			ld a, (.dmark+2)  
4203 32 79 fb			ld (debug_mark+2),a  
4206 18 03			jr .pastdmark  
4208 ..			.dmark: db "TCd"  
420b f1			.pastdmark: pop af  
420c			endm  
# End of macro DMARK
420c						CALLMONITOR 
420c cd 74 17			call break_point_state  
420f				endm  
# End of macro CALLMONITOR
420f					endif 
420f					NEXTW 
420f c3 6d 20			jp macro_next 
4212				endm 
# End of macro NEXTW
4212			 
4212			.SUBSTR: 
4212				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4212 48				db WORD_SYS_CORE+52             
4213 70 42			dw .LEFT            
4215 07				db 6 + 1 
4216 .. 00			db "SUBSTR",0              
421d				endm 
# End of macro CWHEAD
421d			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
421d			 
421d					if DEBUG_FORTH_WORDS_KEY 
421d						DMARK "SST" 
421d f5				push af  
421e 3a 32 42			ld a, (.dmark)  
4221 32 77 fb			ld (debug_mark),a  
4224 3a 33 42			ld a, (.dmark+1)  
4227 32 78 fb			ld (debug_mark+1),a  
422a 3a 34 42			ld a, (.dmark+2)  
422d 32 79 fb			ld (debug_mark+2),a  
4230 18 03			jr .pastdmark  
4232 ..			.dmark: db "SST"  
4235 f1			.pastdmark: pop af  
4236			endm  
# End of macro DMARK
4236						CALLMONITOR 
4236 cd 74 17			call break_point_state  
4239				endm  
# End of macro CALLMONITOR
4239					endif 
4239			; TODO check string type 
4239					FORTH_DSP_VALUEHL 
4239 cd fb 1e			call macro_dsp_valuehl 
423c				endm 
# End of macro FORTH_DSP_VALUEHL
423c			 
423c e5					push hl      ; string length 
423d			 
423d					FORTH_DSP_POP 
423d cd b3 1f			call macro_forth_dsp_pop 
4240				endm 
# End of macro FORTH_DSP_POP
4240			 
4240					FORTH_DSP_VALUEHL 
4240 cd fb 1e			call macro_dsp_valuehl 
4243				endm 
# End of macro FORTH_DSP_VALUEHL
4243			 
4243 e5					push hl     ; start char 
4244			 
4244					FORTH_DSP_POP 
4244 cd b3 1f			call macro_forth_dsp_pop 
4247				endm 
# End of macro FORTH_DSP_POP
4247			 
4247			 
4247					FORTH_DSP_VALUE 
4247 cd e4 1e			call macro_forth_dsp_value 
424a				endm 
# End of macro FORTH_DSP_VALUE
424a			 
424a d1					pop de    ; get start post offset 
424b			 
424b 19					add hl, de    ; starting offset 
424c			 
424c c1					pop bc 
424d c5					push bc      ; grab size of string 
424e			 
424e e5					push hl    ; save string start  
424f			 
424f 26 00				ld h, 0 
4251 69					ld l, c 
4252 23					inc hl 
4253 23					inc hl 
4254			 
4254 cd e7 11				call malloc 
4257				if DEBUG_FORTH_MALLOC_GUARD 
4257 cc 2e 52				call z,malloc_error 
425a				endif 
425a			 
425a eb					ex de, hl      ; save malloc area for string copy 
425b e1					pop hl    ; get back source 
425c c1					pop bc    ; get length of string back 
425d			 
425d d5					push de    ; save malloc area for after we push 
425e ed b0				ldir     ; copy substr 
4260			 
4260			 
4260 eb					ex de, hl 
4261 3e 00				ld a, 0 
4263 77					ld (hl), a   ; term substr 
4264			 
4264					 
4264 e1					pop hl    ; get malloc so we can push it 
4265 e5					push hl   ; save so we can free it afterwards 
4266			 
4266 cd 72 1d				call forth_push_str 
4269			 
4269 e1					pop hl 
426a cd b1 12				call free 
426d			 
426d					 
426d					 
426d			 
426d			 
426d					NEXTW 
426d c3 6d 20			jp macro_next 
4270				endm 
# End of macro NEXTW
4270			 
4270			.LEFT: 
4270				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4270 48				db WORD_SYS_CORE+52             
4271 98 42			dw .RIGHT            
4273 05				db 4 + 1 
4274 .. 00			db "LEFT",0              
4279				endm 
# End of macro CWHEAD
4279			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4279					if DEBUG_FORTH_WORDS_KEY 
4279						DMARK "LEF" 
4279 f5				push af  
427a 3a 8e 42			ld a, (.dmark)  
427d 32 77 fb			ld (debug_mark),a  
4280 3a 8f 42			ld a, (.dmark+1)  
4283 32 78 fb			ld (debug_mark+1),a  
4286 3a 90 42			ld a, (.dmark+2)  
4289 32 79 fb			ld (debug_mark+2),a  
428c 18 03			jr .pastdmark  
428e ..			.dmark: db "LEF"  
4291 f1			.pastdmark: pop af  
4292			endm  
# End of macro DMARK
4292						CALLMONITOR 
4292 cd 74 17			call break_point_state  
4295				endm  
# End of macro CALLMONITOR
4295					endif 
4295			 
4295					NEXTW 
4295 c3 6d 20			jp macro_next 
4298				endm 
# End of macro NEXTW
4298			.RIGHT: 
4298				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4298 48				db WORD_SYS_CORE+52             
4299 c1 42			dw .STR2NUM            
429b 06				db 5 + 1 
429c .. 00			db "RIGHT",0              
42a2				endm 
# End of macro CWHEAD
42a2			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
42a2					if DEBUG_FORTH_WORDS_KEY 
42a2						DMARK "RIG" 
42a2 f5				push af  
42a3 3a b7 42			ld a, (.dmark)  
42a6 32 77 fb			ld (debug_mark),a  
42a9 3a b8 42			ld a, (.dmark+1)  
42ac 32 78 fb			ld (debug_mark+1),a  
42af 3a b9 42			ld a, (.dmark+2)  
42b2 32 79 fb			ld (debug_mark+2),a  
42b5 18 03			jr .pastdmark  
42b7 ..			.dmark: db "RIG"  
42ba f1			.pastdmark: pop af  
42bb			endm  
# End of macro DMARK
42bb						CALLMONITOR 
42bb cd 74 17			call break_point_state  
42be				endm  
# End of macro CALLMONITOR
42be					endif 
42be			 
42be					NEXTW 
42be c3 6d 20			jp macro_next 
42c1				endm 
# End of macro NEXTW
42c1			 
42c1			 
42c1			.STR2NUM: 
42c1				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
42c1 48				db WORD_SYS_CORE+52             
42c2 4d 43			dw .NUM2STR            
42c4 08				db 7 + 1 
42c5 .. 00			db "STR2NUM",0              
42cd				endm 
# End of macro CWHEAD
42cd			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
42cd			 
42cd			 
42cd			; TODO STR type check to do 
42cd					if DEBUG_FORTH_WORDS_KEY 
42cd						DMARK "S2N" 
42cd f5				push af  
42ce 3a e2 42			ld a, (.dmark)  
42d1 32 77 fb			ld (debug_mark),a  
42d4 3a e3 42			ld a, (.dmark+1)  
42d7 32 78 fb			ld (debug_mark+1),a  
42da 3a e4 42			ld a, (.dmark+2)  
42dd 32 79 fb			ld (debug_mark+2),a  
42e0 18 03			jr .pastdmark  
42e2 ..			.dmark: db "S2N"  
42e5 f1			.pastdmark: pop af  
42e6			endm  
# End of macro DMARK
42e6						CALLMONITOR 
42e6 cd 74 17			call break_point_state  
42e9				endm  
# End of macro CALLMONITOR
42e9					endif 
42e9			 
42e9					;FORTH_DSP 
42e9					FORTH_DSP_VALUE 
42e9 cd e4 1e			call macro_forth_dsp_value 
42ec				endm 
# End of macro FORTH_DSP_VALUE
42ec					;inc hl 
42ec			 
42ec eb					ex de, hl 
42ed					if DEBUG_FORTH_WORDS 
42ed						DMARK "S2a" 
42ed f5				push af  
42ee 3a 02 43			ld a, (.dmark)  
42f1 32 77 fb			ld (debug_mark),a  
42f4 3a 03 43			ld a, (.dmark+1)  
42f7 32 78 fb			ld (debug_mark+1),a  
42fa 3a 04 43			ld a, (.dmark+2)  
42fd 32 79 fb			ld (debug_mark+2),a  
4300 18 03			jr .pastdmark  
4302 ..			.dmark: db "S2a"  
4305 f1			.pastdmark: pop af  
4306			endm  
# End of macro DMARK
4306						CALLMONITOR 
4306 cd 74 17			call break_point_state  
4309				endm  
# End of macro CALLMONITOR
4309					endif 
4309 cd 15 11				call string_to_uint16 
430c			 
430c					if DEBUG_FORTH_WORDS 
430c						DMARK "S2b" 
430c f5				push af  
430d 3a 21 43			ld a, (.dmark)  
4310 32 77 fb			ld (debug_mark),a  
4313 3a 22 43			ld a, (.dmark+1)  
4316 32 78 fb			ld (debug_mark+1),a  
4319 3a 23 43			ld a, (.dmark+2)  
431c 32 79 fb			ld (debug_mark+2),a  
431f 18 03			jr .pastdmark  
4321 ..			.dmark: db "S2b"  
4324 f1			.pastdmark: pop af  
4325			endm  
# End of macro DMARK
4325						CALLMONITOR 
4325 cd 74 17			call break_point_state  
4328				endm  
# End of macro CALLMONITOR
4328					endif 
4328			;		push hl 
4328					FORTH_DSP_POP 
4328 cd b3 1f			call macro_forth_dsp_pop 
432b				endm 
# End of macro FORTH_DSP_POP
432b			;		pop hl 
432b					 
432b					if DEBUG_FORTH_WORDS 
432b						DMARK "S2b" 
432b f5				push af  
432c 3a 40 43			ld a, (.dmark)  
432f 32 77 fb			ld (debug_mark),a  
4332 3a 41 43			ld a, (.dmark+1)  
4335 32 78 fb			ld (debug_mark+1),a  
4338 3a 42 43			ld a, (.dmark+2)  
433b 32 79 fb			ld (debug_mark+2),a  
433e 18 03			jr .pastdmark  
4340 ..			.dmark: db "S2b"  
4343 f1			.pastdmark: pop af  
4344			endm  
# End of macro DMARK
4344						CALLMONITOR 
4344 cd 74 17			call break_point_state  
4347				endm  
# End of macro CALLMONITOR
4347					endif 
4347 cd 04 1d				call forth_push_numhl	 
434a			 
434a				 
434a				       NEXTW 
434a c3 6d 20			jp macro_next 
434d				endm 
# End of macro NEXTW
434d			.NUM2STR: 
434d				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
434d 48				db WORD_SYS_CORE+52             
434e 5c 43			dw .CONCAT            
4350 08				db 7 + 1 
4351 .. 00			db "NUM2STR",0              
4359				endm 
# End of macro CWHEAD
4359			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4359			 
4359			;		; malloc a string to target 
4359			;		ld hl, 10     ; TODO max string size should be fine 
4359			;		call malloc 
4359			;		push hl    ; save malloc location 
4359			; 
4359			; 
4359			;; TODO check int type 
4359			;		FORTH_DSP_VALUEHL 
4359			;		ld a, l 
4359			;		call DispAToASCII   
4359			;;TODO need to chage above call to dump into string 
4359			; 
4359			; 
4359			 
4359				       NEXTW 
4359 c3 6d 20			jp macro_next 
435c				endm 
# End of macro NEXTW
435c			 
435c			.CONCAT: 
435c				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
435c 48				db WORD_SYS_CORE+52             
435d 0f 44			dw .FIND            
435f 07				db 6 + 1 
4360 .. 00			db "CONCAT",0              
4367				endm 
# End of macro CWHEAD
4367			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4367			 
4367			; TODO check string type 
4367			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4367			 
4367					if DEBUG_FORTH_WORDS_KEY 
4367						DMARK "CON" 
4367 f5				push af  
4368 3a 7c 43			ld a, (.dmark)  
436b 32 77 fb			ld (debug_mark),a  
436e 3a 7d 43			ld a, (.dmark+1)  
4371 32 78 fb			ld (debug_mark+1),a  
4374 3a 7e 43			ld a, (.dmark+2)  
4377 32 79 fb			ld (debug_mark+2),a  
437a 18 03			jr .pastdmark  
437c ..			.dmark: db "CON"  
437f f1			.pastdmark: pop af  
4380			endm  
# End of macro DMARK
4380						CALLMONITOR 
4380 cd 74 17			call break_point_state  
4383				endm  
# End of macro CALLMONITOR
4383					endif 
4383			 
4383			 
4383					FORTH_DSP_VALUE 
4383 cd e4 1e			call macro_forth_dsp_value 
4386				endm 
# End of macro FORTH_DSP_VALUE
4386 e5					push hl   ; s2 
4387			 
4387					FORTH_DSP_POP 
4387 cd b3 1f			call macro_forth_dsp_pop 
438a				endm 
# End of macro FORTH_DSP_POP
438a			 
438a					FORTH_DSP_VALUE 
438a cd e4 1e			call macro_forth_dsp_value 
438d				endm 
# End of macro FORTH_DSP_VALUE
438d			 
438d e5					push hl   ; s1 
438e			 
438e					FORTH_DSP_POP 
438e cd b3 1f			call macro_forth_dsp_pop 
4391				endm 
# End of macro FORTH_DSP_POP
4391					 
4391			 
4391					; copy s1 
4391			 
4391				 
4391					; save ptr 
4391 e1					pop hl  
4392 e5					push hl 
4393 3e 00				ld a, 0 
4395 cd 89 11				call strlent 
4398					;inc hl    ; zer0 
4398 06 00				ld b, 0 
439a 4d					ld c, l 
439b e1					pop hl		 
439c 11 1d ee				ld de, scratch	 
439f					if DEBUG_FORTH_WORDS 
439f						DMARK "CO1" 
439f f5				push af  
43a0 3a b4 43			ld a, (.dmark)  
43a3 32 77 fb			ld (debug_mark),a  
43a6 3a b5 43			ld a, (.dmark+1)  
43a9 32 78 fb			ld (debug_mark+1),a  
43ac 3a b6 43			ld a, (.dmark+2)  
43af 32 79 fb			ld (debug_mark+2),a  
43b2 18 03			jr .pastdmark  
43b4 ..			.dmark: db "CO1"  
43b7 f1			.pastdmark: pop af  
43b8			endm  
# End of macro DMARK
43b8						CALLMONITOR 
43b8 cd 74 17			call break_point_state  
43bb				endm  
# End of macro CALLMONITOR
43bb					endif 
43bb ed b0				ldir 
43bd			 
43bd e1					pop hl 
43be e5					push hl 
43bf d5					push de 
43c0			 
43c0			 
43c0 3e 00				ld a, 0 
43c2 cd 89 11				call strlent 
43c5 23					inc hl    ; zer0 
43c6 23					inc hl 
43c7 06 00				ld b, 0 
43c9 4d					ld c, l 
43ca d1					pop de 
43cb e1					pop hl		 
43cc					if DEBUG_FORTH_WORDS 
43cc						DMARK "CO2" 
43cc f5				push af  
43cd 3a e1 43			ld a, (.dmark)  
43d0 32 77 fb			ld (debug_mark),a  
43d3 3a e2 43			ld a, (.dmark+1)  
43d6 32 78 fb			ld (debug_mark+1),a  
43d9 3a e3 43			ld a, (.dmark+2)  
43dc 32 79 fb			ld (debug_mark+2),a  
43df 18 03			jr .pastdmark  
43e1 ..			.dmark: db "CO2"  
43e4 f1			.pastdmark: pop af  
43e5			endm  
# End of macro DMARK
43e5						CALLMONITOR 
43e5 cd 74 17			call break_point_state  
43e8				endm  
# End of macro CALLMONITOR
43e8					endif 
43e8 ed b0				ldir 
43ea			 
43ea			 
43ea			 
43ea 21 1d ee				ld hl, scratch 
43ed					if DEBUG_FORTH_WORDS 
43ed						DMARK "CO5" 
43ed f5				push af  
43ee 3a 02 44			ld a, (.dmark)  
43f1 32 77 fb			ld (debug_mark),a  
43f4 3a 03 44			ld a, (.dmark+1)  
43f7 32 78 fb			ld (debug_mark+1),a  
43fa 3a 04 44			ld a, (.dmark+2)  
43fd 32 79 fb			ld (debug_mark+2),a  
4400 18 03			jr .pastdmark  
4402 ..			.dmark: db "CO5"  
4405 f1			.pastdmark: pop af  
4406			endm  
# End of macro DMARK
4406						CALLMONITOR 
4406 cd 74 17			call break_point_state  
4409				endm  
# End of macro CALLMONITOR
4409					endif 
4409			 
4409 cd 72 1d				call forth_push_str 
440c			 
440c			 
440c			 
440c			 
440c				       NEXTW 
440c c3 6d 20			jp macro_next 
440f				endm 
# End of macro NEXTW
440f			 
440f			 
440f			.FIND: 
440f				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
440f 4b				db WORD_SYS_CORE+55             
4410 cd 44			dw .LEN            
4412 05				db 4 + 1 
4413 .. 00			db "FIND",0              
4418				endm 
# End of macro CWHEAD
4418			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4418			 
4418					if DEBUG_FORTH_WORDS_KEY 
4418						DMARK "FND" 
4418 f5				push af  
4419 3a 2d 44			ld a, (.dmark)  
441c 32 77 fb			ld (debug_mark),a  
441f 3a 2e 44			ld a, (.dmark+1)  
4422 32 78 fb			ld (debug_mark+1),a  
4425 3a 2f 44			ld a, (.dmark+2)  
4428 32 79 fb			ld (debug_mark+2),a  
442b 18 03			jr .pastdmark  
442d ..			.dmark: db "FND"  
4430 f1			.pastdmark: pop af  
4431			endm  
# End of macro DMARK
4431						CALLMONITOR 
4431 cd 74 17			call break_point_state  
4434				endm  
# End of macro CALLMONITOR
4434					endif 
4434			 
4434			; TODO check string type 
4434					FORTH_DSP_VALUE 
4434 cd e4 1e			call macro_forth_dsp_value 
4437				endm 
# End of macro FORTH_DSP_VALUE
4437			 
4437 e5					push hl    
4438 7e					ld a,(hl)    ; char to find   
4439			; TODO change char to substr 
4439			 
4439 f5					push af 
443a					 
443a			 
443a			 
443a					if DEBUG_FORTH_WORDS 
443a						DMARK "FN1" 
443a f5				push af  
443b 3a 4f 44			ld a, (.dmark)  
443e 32 77 fb			ld (debug_mark),a  
4441 3a 50 44			ld a, (.dmark+1)  
4444 32 78 fb			ld (debug_mark+1),a  
4447 3a 51 44			ld a, (.dmark+2)  
444a 32 79 fb			ld (debug_mark+2),a  
444d 18 03			jr .pastdmark  
444f ..			.dmark: db "FN1"  
4452 f1			.pastdmark: pop af  
4453			endm  
# End of macro DMARK
4453						CALLMONITOR 
4453 cd 74 17			call break_point_state  
4456				endm  
# End of macro CALLMONITOR
4456					endif 
4456			 
4456					FORTH_DSP_POP 
4456 cd b3 1f			call macro_forth_dsp_pop 
4459				endm 
# End of macro FORTH_DSP_POP
4459			 
4459					; string to search 
4459			 
4459					FORTH_DSP_VALUE 
4459 cd e4 1e			call macro_forth_dsp_value 
445c				endm 
# End of macro FORTH_DSP_VALUE
445c			 
445c d1					pop de  ; d is char to find  
445d			 
445d					if DEBUG_FORTH_WORDS 
445d						DMARK "FN2" 
445d f5				push af  
445e 3a 72 44			ld a, (.dmark)  
4461 32 77 fb			ld (debug_mark),a  
4464 3a 73 44			ld a, (.dmark+1)  
4467 32 78 fb			ld (debug_mark+1),a  
446a 3a 74 44			ld a, (.dmark+2)  
446d 32 79 fb			ld (debug_mark+2),a  
4470 18 03			jr .pastdmark  
4472 ..			.dmark: db "FN2"  
4475 f1			.pastdmark: pop af  
4476			endm  
# End of macro DMARK
4476						CALLMONITOR 
4476 cd 74 17			call break_point_state  
4479				endm  
# End of macro CALLMONITOR
4479					endif 
4479					 
4479 01 00 00				ld bc, 0 
447c 7e			.findchar:      ld a,(hl) 
447d fe 00				cp 0   		 
447f 28 27				jr z, .finddone     
4481 ba					cp d 
4482 28 20				jr z, .foundchar 
4484 03					inc bc 
4485 23					inc hl 
4486					if DEBUG_FORTH_WORDS 
4486						DMARK "FN3" 
4486 f5				push af  
4487 3a 9b 44			ld a, (.dmark)  
448a 32 77 fb			ld (debug_mark),a  
448d 3a 9c 44			ld a, (.dmark+1)  
4490 32 78 fb			ld (debug_mark+1),a  
4493 3a 9d 44			ld a, (.dmark+2)  
4496 32 79 fb			ld (debug_mark+2),a  
4499 18 03			jr .pastdmark  
449b ..			.dmark: db "FN3"  
449e f1			.pastdmark: pop af  
449f			endm  
# End of macro DMARK
449f						CALLMONITOR 
449f cd 74 17			call break_point_state  
44a2				endm  
# End of macro CALLMONITOR
44a2					endif 
44a2 18 d8				jr .findchar 
44a4			 
44a4			 
44a4 c5			.foundchar:	push bc 
44a5 e1					pop hl 
44a6 18 03				jr .findexit 
44a8			 
44a8			 
44a8							 
44a8			 
44a8			.finddone:     ; got to end of string with no find 
44a8 21 00 00				ld hl, 0 
44ab			.findexit: 
44ab			 
44ab					if DEBUG_FORTH_WORDS 
44ab						DMARK "FNd" 
44ab f5				push af  
44ac 3a c0 44			ld a, (.dmark)  
44af 32 77 fb			ld (debug_mark),a  
44b2 3a c1 44			ld a, (.dmark+1)  
44b5 32 78 fb			ld (debug_mark+1),a  
44b8 3a c2 44			ld a, (.dmark+2)  
44bb 32 79 fb			ld (debug_mark+2),a  
44be 18 03			jr .pastdmark  
44c0 ..			.dmark: db "FNd"  
44c3 f1			.pastdmark: pop af  
44c4			endm  
# End of macro DMARK
44c4						CALLMONITOR 
44c4 cd 74 17			call break_point_state  
44c7				endm  
# End of macro CALLMONITOR
44c7					endif 
44c7 cd 04 1d			call forth_push_numhl 
44ca			 
44ca				       NEXTW 
44ca c3 6d 20			jp macro_next 
44cd				endm 
# End of macro NEXTW
44cd			 
44cd			.LEN: 
44cd				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
44cd 4c				db WORD_SYS_CORE+56             
44ce 02 45			dw .CHAR            
44d0 06				db 5 + 1 
44d1 .. 00			db "COUNT",0              
44d7				endm 
# End of macro CWHEAD
44d7			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
44d7			 
44d7					if DEBUG_FORTH_WORDS_KEY 
44d7						DMARK "CNT" 
44d7 f5				push af  
44d8 3a ec 44			ld a, (.dmark)  
44db 32 77 fb			ld (debug_mark),a  
44de 3a ed 44			ld a, (.dmark+1)  
44e1 32 78 fb			ld (debug_mark+1),a  
44e4 3a ee 44			ld a, (.dmark+2)  
44e7 32 79 fb			ld (debug_mark+2),a  
44ea 18 03			jr .pastdmark  
44ec ..			.dmark: db "CNT"  
44ef f1			.pastdmark: pop af  
44f0			endm  
# End of macro DMARK
44f0						CALLMONITOR 
44f0 cd 74 17			call break_point_state  
44f3				endm  
# End of macro CALLMONITOR
44f3					endif 
44f3			; TODO check string type 
44f3					FORTH_DSP 
44f3 cd c1 1e			call macro_forth_dsp 
44f6				endm 
# End of macro FORTH_DSP
44f6					;v5FORTH_DSP_VALUE 
44f6			 
44f6 23					inc hl 
44f7			 
44f7 3e 00				ld a, 0 
44f9 cd 89 11				call strlent 
44fc			 
44fc cd 04 1d				call forth_push_numhl 
44ff			 
44ff			 
44ff			 
44ff				       NEXTW 
44ff c3 6d 20			jp macro_next 
4502				endm 
# End of macro NEXTW
4502			.CHAR: 
4502				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4502 4d				db WORD_SYS_CORE+57             
4503 38 45			dw .ENDSTR            
4505 05				db 4 + 1 
4506 .. 00			db "CHAR",0              
450b				endm 
# End of macro CWHEAD
450b			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
450b					if DEBUG_FORTH_WORDS_KEY 
450b						DMARK "CHR" 
450b f5				push af  
450c 3a 20 45			ld a, (.dmark)  
450f 32 77 fb			ld (debug_mark),a  
4512 3a 21 45			ld a, (.dmark+1)  
4515 32 78 fb			ld (debug_mark+1),a  
4518 3a 22 45			ld a, (.dmark+2)  
451b 32 79 fb			ld (debug_mark+2),a  
451e 18 03			jr .pastdmark  
4520 ..			.dmark: db "CHR"  
4523 f1			.pastdmark: pop af  
4524			endm  
# End of macro DMARK
4524						CALLMONITOR 
4524 cd 74 17			call break_point_state  
4527				endm  
# End of macro CALLMONITOR
4527					endif 
4527					FORTH_DSP 
4527 cd c1 1e			call macro_forth_dsp 
452a				endm 
# End of macro FORTH_DSP
452a					;v5 FORTH_DSP_VALUE 
452a 23					inc hl      ; now at start of numeric as string 
452b			 
452b			;		push hl 
452b			 
452b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
452b cd b3 1f			call macro_forth_dsp_pop 
452e				endm 
# End of macro FORTH_DSP_POP
452e			 
452e			;		pop hl 
452e			 
452e					; push the content of a onto the stack as a value 
452e			 
452e 7e					ld a,(hl)   ; get char 
452f 26 00				ld h,0 
4531 6f					ld l,a 
4532 cd 04 1d				call forth_push_numhl 
4535			 
4535				       NEXTW 
4535 c3 6d 20			jp macro_next 
4538				endm 
# End of macro NEXTW
4538			 
4538			 
4538			 
4538			 
4538			.ENDSTR: 
4538			; eof 
4538			 
# End of file forth_words_str.asm
4538			include "forth_words_key.asm" 
4538			 
4538			; | ## Keyboard Words 
4538			 
4538			.KEY: 
4538				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4538 3e				db WORD_SYS_CORE+42             
4539 68 45			dw .WAITK            
453b 04				db 3 + 1 
453c .. 00			db "KEY",0              
4540				endm 
# End of macro CWHEAD
4540			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4540			 
4540					if DEBUG_FORTH_WORDS_KEY 
4540						DMARK "KEY" 
4540 f5				push af  
4541 3a 55 45			ld a, (.dmark)  
4544 32 77 fb			ld (debug_mark),a  
4547 3a 56 45			ld a, (.dmark+1)  
454a 32 78 fb			ld (debug_mark+1),a  
454d 3a 57 45			ld a, (.dmark+2)  
4550 32 79 fb			ld (debug_mark+2),a  
4553 18 03			jr .pastdmark  
4555 ..			.dmark: db "KEY"  
4558 f1			.pastdmark: pop af  
4559			endm  
# End of macro DMARK
4559						CALLMONITOR 
4559 cd 74 17			call break_point_state  
455c				endm  
# End of macro CALLMONITOR
455c					endif 
455c			; TODO currently waits 
455c cd 61 69				call cin 
455f					;call cin_wait 
455f 6f					ld l, a 
4560 26 00				ld h, 0 
4562 cd 04 1d				call forth_push_numhl 
4565					NEXTW 
4565 c3 6d 20			jp macro_next 
4568				endm 
# End of macro NEXTW
4568			.WAITK: 
4568				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4568 3f				db WORD_SYS_CORE+43             
4569 9a 45			dw .ACCEPT            
456b 06				db 5 + 1 
456c .. 00			db "WAITK",0              
4572				endm 
# End of macro CWHEAD
4572			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4572					if DEBUG_FORTH_WORDS_KEY 
4572						DMARK "WAI" 
4572 f5				push af  
4573 3a 87 45			ld a, (.dmark)  
4576 32 77 fb			ld (debug_mark),a  
4579 3a 88 45			ld a, (.dmark+1)  
457c 32 78 fb			ld (debug_mark+1),a  
457f 3a 89 45			ld a, (.dmark+2)  
4582 32 79 fb			ld (debug_mark+2),a  
4585 18 03			jr .pastdmark  
4587 ..			.dmark: db "WAI"  
458a f1			.pastdmark: pop af  
458b			endm  
# End of macro DMARK
458b						CALLMONITOR 
458b cd 74 17			call break_point_state  
458e				endm  
# End of macro CALLMONITOR
458e					endif 
458e cd 50 69				call cin_wait 
4591 6f					ld l, a 
4592 26 00				ld h, 0 
4594 cd 04 1d				call forth_push_numhl 
4597					NEXTW 
4597 c3 6d 20			jp macro_next 
459a				endm 
# End of macro NEXTW
459a			.ACCEPT: 
459a				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
459a 40				db WORD_SYS_CORE+44             
459b f8 45			dw .EDIT            
459d 07				db 6 + 1 
459e .. 00			db "ACCEPT",0              
45a5				endm 
# End of macro CWHEAD
45a5			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
45a5					; TODO crashes on push 
45a5					if DEBUG_FORTH_WORDS_KEY 
45a5						DMARK "ACC" 
45a5 f5				push af  
45a6 3a ba 45			ld a, (.dmark)  
45a9 32 77 fb			ld (debug_mark),a  
45ac 3a bb 45			ld a, (.dmark+1)  
45af 32 78 fb			ld (debug_mark+1),a  
45b2 3a bc 45			ld a, (.dmark+2)  
45b5 32 79 fb			ld (debug_mark+2),a  
45b8 18 03			jr .pastdmark  
45ba ..			.dmark: db "ACC"  
45bd f1			.pastdmark: pop af  
45be			endm  
# End of macro DMARK
45be						CALLMONITOR 
45be cd 74 17			call break_point_state  
45c1				endm  
# End of macro CALLMONITOR
45c1					endif 
45c1 21 1b f0				ld hl, os_input 
45c4 3e 00				ld a, 0 
45c6 77					ld (hl),a 
45c7 3a 46 f8				ld a,(f_cursor_ptr) 
45ca 16 64				ld d, 100 
45cc 0e 00				ld c, 0 
45ce 1e 28				ld e, 40 
45d0 cd 4d 0d				call input_str 
45d3					; TODO perhaps do a type check and wrap in quotes if not a number 
45d3 21 1b f0				ld hl, os_input 
45d6					if DEBUG_FORTH_WORDS 
45d6						DMARK "AC1" 
45d6 f5				push af  
45d7 3a eb 45			ld a, (.dmark)  
45da 32 77 fb			ld (debug_mark),a  
45dd 3a ec 45			ld a, (.dmark+1)  
45e0 32 78 fb			ld (debug_mark+1),a  
45e3 3a ed 45			ld a, (.dmark+2)  
45e6 32 79 fb			ld (debug_mark+2),a  
45e9 18 03			jr .pastdmark  
45eb ..			.dmark: db "AC1"  
45ee f1			.pastdmark: pop af  
45ef			endm  
# End of macro DMARK
45ef						CALLMONITOR 
45ef cd 74 17			call break_point_state  
45f2				endm  
# End of macro CALLMONITOR
45f2					endif 
45f2 cd 72 1d				call forth_push_str 
45f5					NEXTW 
45f5 c3 6d 20			jp macro_next 
45f8				endm 
# End of macro NEXTW
45f8			 
45f8			.EDIT: 
45f8				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
45f8 40				db WORD_SYS_CORE+44             
45f9 9a 46			dw .ENDKEY            
45fb 05				db 4 + 1 
45fc .. 00			db "EDIT",0              
4601				endm 
# End of macro CWHEAD
4601			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4601			 
4601					; TODO does not copy from stack 
4601					if DEBUG_FORTH_WORDS_KEY 
4601						DMARK "EDT" 
4601 f5				push af  
4602 3a 16 46			ld a, (.dmark)  
4605 32 77 fb			ld (debug_mark),a  
4608 3a 17 46			ld a, (.dmark+1)  
460b 32 78 fb			ld (debug_mark+1),a  
460e 3a 18 46			ld a, (.dmark+2)  
4611 32 79 fb			ld (debug_mark+2),a  
4614 18 03			jr .pastdmark  
4616 ..			.dmark: db "EDT"  
4619 f1			.pastdmark: pop af  
461a			endm  
# End of macro DMARK
461a						CALLMONITOR 
461a cd 74 17			call break_point_state  
461d				endm  
# End of macro CALLMONITOR
461d					endif 
461d			 
461d					;FORTH_DSP 
461d					FORTH_DSP_VALUEHL 
461d cd fb 1e			call macro_dsp_valuehl 
4620				endm 
# End of macro FORTH_DSP_VALUEHL
4620			;		inc hl    ; TODO do type check 
4620			 
4620			;		call get_word_hl 
4620 e5					push hl 
4621					if DEBUG_FORTH_WORDS 
4621						DMARK "EDp" 
4621 f5				push af  
4622 3a 36 46			ld a, (.dmark)  
4625 32 77 fb			ld (debug_mark),a  
4628 3a 37 46			ld a, (.dmark+1)  
462b 32 78 fb			ld (debug_mark+1),a  
462e 3a 38 46			ld a, (.dmark+2)  
4631 32 79 fb			ld (debug_mark+2),a  
4634 18 03			jr .pastdmark  
4636 ..			.dmark: db "EDp"  
4639 f1			.pastdmark: pop af  
463a			endm  
# End of macro DMARK
463a						CALLMONITOR 
463a cd 74 17			call break_point_state  
463d				endm  
# End of macro CALLMONITOR
463d					endif 
463d				;	ld a, 0 
463d cd 7e 11				call strlenz 
4640 23					inc hl 
4641			 
4641 06 00				ld b, 0 
4643 4d					ld c, l 
4644			 
4644 e1					pop hl 
4645 11 1b f0				ld de, os_input 
4648					if DEBUG_FORTH_WORDS_KEY 
4648						DMARK "EDc" 
4648 f5				push af  
4649 3a 5d 46			ld a, (.dmark)  
464c 32 77 fb			ld (debug_mark),a  
464f 3a 5e 46			ld a, (.dmark+1)  
4652 32 78 fb			ld (debug_mark+1),a  
4655 3a 5f 46			ld a, (.dmark+2)  
4658 32 79 fb			ld (debug_mark+2),a  
465b 18 03			jr .pastdmark  
465d ..			.dmark: db "EDc"  
4660 f1			.pastdmark: pop af  
4661			endm  
# End of macro DMARK
4661						CALLMONITOR 
4661 cd 74 17			call break_point_state  
4664				endm  
# End of macro CALLMONITOR
4664					endif 
4664 ed b0				ldir 
4666			 
4666			 
4666 21 1b f0				ld hl, os_input 
4669					;ld a, 0 
4669					;ld (hl),a 
4669 3a 46 f8				ld a,(f_cursor_ptr) 
466c 16 64				ld d, 100 
466e 0e 00				ld c, 0 
4670 1e 28				ld e, 40 
4672 cd 4d 0d				call input_str 
4675					; TODO perhaps do a type check and wrap in quotes if not a number 
4675 21 1b f0				ld hl, os_input 
4678					if DEBUG_FORTH_WORDS 
4678						DMARK "ED1" 
4678 f5				push af  
4679 3a 8d 46			ld a, (.dmark)  
467c 32 77 fb			ld (debug_mark),a  
467f 3a 8e 46			ld a, (.dmark+1)  
4682 32 78 fb			ld (debug_mark+1),a  
4685 3a 8f 46			ld a, (.dmark+2)  
4688 32 79 fb			ld (debug_mark+2),a  
468b 18 03			jr .pastdmark  
468d ..			.dmark: db "ED1"  
4690 f1			.pastdmark: pop af  
4691			endm  
# End of macro DMARK
4691						CALLMONITOR 
4691 cd 74 17			call break_point_state  
4694				endm  
# End of macro CALLMONITOR
4694					endif 
4694 cd 72 1d				call forth_push_str 
4697					NEXTW 
4697 c3 6d 20			jp macro_next 
469a				endm 
# End of macro NEXTW
469a			 
469a			 
469a			 
469a			.ENDKEY: 
469a			; eof 
469a			 
# End of file forth_words_key.asm
469a			 
469a			if STORAGE_SE 
469a			   	include "forth_words_storage.asm" 
469a			 
469a			; | ## Fixed Storage Words 
469a			 
469a			 
469a			.BREAD: 
469a			  
469a				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
469a 3a				db WORD_SYS_CORE+38             
469b 1d 47			dw .BWRITE            
469d 06				db 5 + 1 
469e .. 00			db "BREAD",0              
46a4				endm 
# End of macro CWHEAD
46a4			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
46a4				 
46a4					if DEBUG_FORTH_WORDS_KEY 
46a4						DMARK "BRD" 
46a4 f5				push af  
46a5 3a b9 46			ld a, (.dmark)  
46a8 32 77 fb			ld (debug_mark),a  
46ab 3a ba 46			ld a, (.dmark+1)  
46ae 32 78 fb			ld (debug_mark+1),a  
46b1 3a bb 46			ld a, (.dmark+2)  
46b4 32 79 fb			ld (debug_mark+2),a  
46b7 18 03			jr .pastdmark  
46b9 ..			.dmark: db "BRD"  
46bc f1			.pastdmark: pop af  
46bd			endm  
# End of macro DMARK
46bd						CALLMONITOR 
46bd cd 74 17			call break_point_state  
46c0				endm  
# End of macro CALLMONITOR
46c0					endif 
46c0			 
46c0				FORTH_DSP_VALUEHL 
46c0 cd fb 1e			call macro_dsp_valuehl 
46c3				endm 
# End of macro FORTH_DSP_VALUEHL
46c3			 
46c3				FORTH_DSP_POP 
46c3 cd b3 1f			call macro_forth_dsp_pop 
46c6				endm 
# End of macro FORTH_DSP_POP
46c6			 
46c6				; calc block address 
46c6			 
46c6 eb				ex de, hl 
46c7 3e 40			ld a, STORE_BLOCK_PHY 
46c9 cd a3 0c			call Mult16 
46cc			 
46cc			 
46cc 11 62 f8			ld de, store_page 
46cf			 
46cf					if DEBUG_FORTH_WORDS 
46cf						DMARK "BR1" 
46cf f5				push af  
46d0 3a e4 46			ld a, (.dmark)  
46d3 32 77 fb			ld (debug_mark),a  
46d6 3a e5 46			ld a, (.dmark+1)  
46d9 32 78 fb			ld (debug_mark+1),a  
46dc 3a e6 46			ld a, (.dmark+2)  
46df 32 79 fb			ld (debug_mark+2),a  
46e2 18 03			jr .pastdmark  
46e4 ..			.dmark: db "BR1"  
46e7 f1			.pastdmark: pop af  
46e8			endm  
# End of macro DMARK
46e8						CALLMONITOR 
46e8 cd 74 17			call break_point_state  
46eb				endm  
# End of macro CALLMONITOR
46eb					endif 
46eb			 
46eb cd 0c 03			call storage_read_block 
46ee			 
46ee cd 49 0d			call ishlzero 
46f1 20 05			jr nz, .brfound 
46f3			 
46f3 cd 04 1d			call forth_push_numhl 
46f6 18 22			jr .brdone 
46f8			 
46f8			 
46f8			.brfound: 
46f8 21 64 f8		        ld hl, store_page+2 
46fb			 
46fb					if DEBUG_FORTH_WORDS 
46fb						DMARK "BR2" 
46fb f5				push af  
46fc 3a 10 47			ld a, (.dmark)  
46ff 32 77 fb			ld (debug_mark),a  
4702 3a 11 47			ld a, (.dmark+1)  
4705 32 78 fb			ld (debug_mark+1),a  
4708 3a 12 47			ld a, (.dmark+2)  
470b 32 79 fb			ld (debug_mark+2),a  
470e 18 03			jr .pastdmark  
4710 ..			.dmark: db "BR2"  
4713 f1			.pastdmark: pop af  
4714			endm  
# End of macro DMARK
4714						CALLMONITOR 
4714 cd 74 17			call break_point_state  
4717				endm  
# End of macro CALLMONITOR
4717					endif 
4717			 
4717 cd 72 1d			call forth_push_str 
471a			 
471a			 
471a			.brdone: 
471a			 
471a					NEXTW 
471a c3 6d 20			jp macro_next 
471d				endm 
# End of macro NEXTW
471d			.BWRITE: 
471d				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
471d 3a				db WORD_SYS_CORE+38             
471e b2 47			dw .BUPD            
4720 07				db 6 + 1 
4721 .. 00			db "BWRITE",0              
4728				endm 
# End of macro CWHEAD
4728			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
4728			 
4728					if DEBUG_FORTH_WORDS_KEY 
4728						DMARK "BWR" 
4728 f5				push af  
4729 3a 3d 47			ld a, (.dmark)  
472c 32 77 fb			ld (debug_mark),a  
472f 3a 3e 47			ld a, (.dmark+1)  
4732 32 78 fb			ld (debug_mark+1),a  
4735 3a 3f 47			ld a, (.dmark+2)  
4738 32 79 fb			ld (debug_mark+2),a  
473b 18 03			jr .pastdmark  
473d ..			.dmark: db "BWR"  
4740 f1			.pastdmark: pop af  
4741			endm  
# End of macro DMARK
4741						CALLMONITOR 
4741 cd 74 17			call break_point_state  
4744				endm  
# End of macro CALLMONITOR
4744					endif 
4744			 
4744				FORTH_DSP_VALUEHL 
4744 cd fb 1e			call macro_dsp_valuehl 
4747				endm 
# End of macro FORTH_DSP_VALUEHL
4747			 
4747				; calc block address 
4747			 
4747 eb				ex de, hl 
4748 3e 40			ld a, STORE_BLOCK_PHY 
474a cd a3 0c			call Mult16 
474d			 
474d e5				push hl         ; address 
474e			 
474e				FORTH_DSP_POP 
474e cd b3 1f			call macro_forth_dsp_pop 
4751				endm 
# End of macro FORTH_DSP_POP
4751			 
4751				FORTH_DSP_VALUEHL 
4751 cd fb 1e			call macro_dsp_valuehl 
4754				endm 
# End of macro FORTH_DSP_VALUEHL
4754			 
4754				FORTH_DSP_POP 
4754 cd b3 1f			call macro_forth_dsp_pop 
4757				endm 
# End of macro FORTH_DSP_POP
4757			 
4757 cd 2c 0a			call storage_clear_page 
475a			 
475a				; copy string to store page 
475a			 
475a e5				push hl     ; save string address 
475b			 
475b 3e 00			ld a, 0 
475d cd 89 11			call strlent 
4760			 
4760 23				inc hl 
4761			 
4761 4d				ld c, l 
4762 06 00			ld b, 0 
4764			 
4764 e1				pop hl 
4765 11 64 f8			ld de, store_page + 2 
4768					if DEBUG_FORTH_WORDS 
4768						DMARK "BW1" 
4768 f5				push af  
4769 3a 7d 47			ld a, (.dmark)  
476c 32 77 fb			ld (debug_mark),a  
476f 3a 7e 47			ld a, (.dmark+1)  
4772 32 78 fb			ld (debug_mark+1),a  
4775 3a 7f 47			ld a, (.dmark+2)  
4778 32 79 fb			ld (debug_mark+2),a  
477b 18 03			jr .pastdmark  
477d ..			.dmark: db "BW1"  
4780 f1			.pastdmark: pop af  
4781			endm  
# End of macro DMARK
4781						CALLMONITOR 
4781 cd 74 17			call break_point_state  
4784				endm  
# End of macro CALLMONITOR
4784					endif 
4784 ed b0			ldir 
4786			 
4786			 
4786				; poke the start of the block with flags to prevent high level file ops hitting the block 
4786			 
4786 21 ff ff			ld hl, $ffff 
4789			 
4789 22 62 f8			ld (store_page), hl	 
478c				 
478c e1				pop hl    ; get address 
478d 11 62 f8			ld de, store_page 
4790			 
4790					if DEBUG_FORTH_WORDS 
4790						DMARK "BW2" 
4790 f5				push af  
4791 3a a5 47			ld a, (.dmark)  
4794 32 77 fb			ld (debug_mark),a  
4797 3a a6 47			ld a, (.dmark+1)  
479a 32 78 fb			ld (debug_mark+1),a  
479d 3a a7 47			ld a, (.dmark+2)  
47a0 32 79 fb			ld (debug_mark+2),a  
47a3 18 03			jr .pastdmark  
47a5 ..			.dmark: db "BW2"  
47a8 f1			.pastdmark: pop af  
47a9			endm  
# End of macro DMARK
47a9						CALLMONITOR 
47a9 cd 74 17			call break_point_state  
47ac				endm  
# End of macro CALLMONITOR
47ac					endif 
47ac			 
47ac cd 71 03			call storage_write_block 
47af			 
47af					NEXTW 
47af c3 6d 20			jp macro_next 
47b2				endm 
# End of macro NEXTW
47b2			 
47b2			.BUPD: 
47b2				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
47b2 3a				db WORD_SYS_CORE+38             
47b3 08 48			dw .BYID            
47b5 05				db 4 + 1 
47b6 .. 00			db "BUPD",0              
47bb				endm 
# End of macro CWHEAD
47bb			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
47bb			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
47bb			; | | or completely different file system structure. 
47bb			 
47bb					if DEBUG_FORTH_WORDS_KEY 
47bb						DMARK "BUD" 
47bb f5				push af  
47bc 3a d0 47			ld a, (.dmark)  
47bf 32 77 fb			ld (debug_mark),a  
47c2 3a d1 47			ld a, (.dmark+1)  
47c5 32 78 fb			ld (debug_mark+1),a  
47c8 3a d2 47			ld a, (.dmark+2)  
47cb 32 79 fb			ld (debug_mark+2),a  
47ce 18 03			jr .pastdmark  
47d0 ..			.dmark: db "BUD"  
47d3 f1			.pastdmark: pop af  
47d4			endm  
# End of macro DMARK
47d4						CALLMONITOR 
47d4 cd 74 17			call break_point_state  
47d7				endm  
# End of macro CALLMONITOR
47d7					endif 
47d7			 
47d7				FORTH_DSP_VALUEHL 
47d7 cd fb 1e			call macro_dsp_valuehl 
47da				endm 
# End of macro FORTH_DSP_VALUEHL
47da			 
47da				; calc block address 
47da			 
47da eb				ex de, hl 
47db 3e 40			ld a, STORE_BLOCK_PHY 
47dd cd a3 0c			call Mult16 
47e0			 
47e0				FORTH_DSP_POP 
47e0 cd b3 1f			call macro_forth_dsp_pop 
47e3				endm 
# End of macro FORTH_DSP_POP
47e3			 
47e3			 
47e3 11 62 f8			ld de, store_page 
47e6			 
47e6					if DEBUG_FORTH_WORDS 
47e6						DMARK "BUe" 
47e6 f5				push af  
47e7 3a fb 47			ld a, (.dmark)  
47ea 32 77 fb			ld (debug_mark),a  
47ed 3a fc 47			ld a, (.dmark+1)  
47f0 32 78 fb			ld (debug_mark+1),a  
47f3 3a fd 47			ld a, (.dmark+2)  
47f6 32 79 fb			ld (debug_mark+2),a  
47f9 18 03			jr .pastdmark  
47fb ..			.dmark: db "BUe"  
47fe f1			.pastdmark: pop af  
47ff			endm  
# End of macro DMARK
47ff						CALLMONITOR 
47ff cd 74 17			call break_point_state  
4802				endm  
# End of macro CALLMONITOR
4802					endif 
4802			 
4802 cd 71 03			call storage_write_block 
4805			 
4805					NEXTW 
4805 c3 6d 20			jp macro_next 
4808				endm 
# End of macro NEXTW
4808			 
4808			.BYID: 
4808			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4808			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4808			; 
4808			;		 
4808			;		if DEBUG_FORTH_WORDS_KEY 
4808			;			DMARK "BYID" 
4808			;			CALLMONITOR 
4808			;		endif 
4808			; 
4808			;		; get direct address 
4808			; 
4808			;		FORTH_DSP_VALUEHL 
4808			; 
4808			;		FORTH_DSP_POP 
4808			; 
4808			;	; calc block address 
4808			; 
4808			;	ex de, hl 
4808			;	ld a, STORE_BLOCK_PHY 
4808			;	call Mult16 
4808			;	;	do BREAD with number as param 
4808			;	; push the file name	 
4808			;	ld de, store_page 
4808			;	call storage_read_block 
4808			 ;       ld hl, store_page+2 
4808			; 
4808			; 
4808			;		NEXTW 
4808			;.BYNAME: 
4808			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
4808			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
4808			;		NEXTW 
4808			; 
4808			.DIR: 
4808				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4808 3a				db WORD_SYS_CORE+38             
4809 0c 49			dw .SAVE            
480b 04				db 3 + 1 
480c .. 00			db "DIR",0              
4810				endm 
# End of macro CWHEAD
4810			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4810			 
4810					if DEBUG_FORTH_WORDS_KEY 
4810						DMARK "DIR" 
4810 f5				push af  
4811 3a 25 48			ld a, (.dmark)  
4814 32 77 fb			ld (debug_mark),a  
4817 3a 26 48			ld a, (.dmark+1)  
481a 32 78 fb			ld (debug_mark+1),a  
481d 3a 27 48			ld a, (.dmark+2)  
4820 32 79 fb			ld (debug_mark+2),a  
4823 18 03			jr .pastdmark  
4825 ..			.dmark: db "DIR"  
4828 f1			.pastdmark: pop af  
4829			endm  
# End of macro DMARK
4829						CALLMONITOR 
4829 cd 74 17			call break_point_state  
482c				endm  
# End of macro CALLMONITOR
482c					endif 
482c cd bd 03			call storage_get_block_0 
482f			 
482f 21 62 f8			ld hl, store_page     ; get current id count 
4832 46				ld b, (hl) 
4833 0e 00			ld c, 0    ; count of files   
4835					if DEBUG_FORTH_WORDS 
4835						DMARK "DI1" 
4835 f5				push af  
4836 3a 4a 48			ld a, (.dmark)  
4839 32 77 fb			ld (debug_mark),a  
483c 3a 4b 48			ld a, (.dmark+1)  
483f 32 78 fb			ld (debug_mark+1),a  
4842 3a 4c 48			ld a, (.dmark+2)  
4845 32 79 fb			ld (debug_mark+2),a  
4848 18 03			jr .pastdmark  
484a ..			.dmark: db "DI1"  
484d f1			.pastdmark: pop af  
484e			endm  
# End of macro DMARK
484e						CALLMONITOR 
484e cd 74 17			call break_point_state  
4851				endm  
# End of macro CALLMONITOR
4851					endif 
4851			 
4851				; check for empty drive 
4851			 
4851 3e 00			ld a, 0 
4853 b8				cp b 
4854 ca c2 48			jp z, .dirdone 
4857			 
4857				; for each of the current ids do a search for them and if found push to stack 
4857			 
4857 c5			.diritem:	push bc 
4858 21 40 00				ld hl, STORE_BLOCK_PHY 
485b 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
485d 58					ld e,b 
485e			 
485e			;		if DEBUG_FORTH_WORDS 
485e			;			DMARK "DI2" 
485e			;			CALLMONITOR 
485e			;		endif 
485e			 
485e cd 31 06				call storage_findnextid 
4861			 
4861			;		if DEBUG_FORTH_WORDS 
4861			;			DMARK "DI3" 
4861			;			CALLMONITOR 
4861			;		endif 
4861			 
4861					; if found hl will be non zero 
4861			 
4861 cd 49 0d				call ishlzero 
4864			;		ld a, l 
4864			;		add h 
4864			; 
4864			;		cp 0 
4864 28 59				jr z, .dirnotfound 
4866			 
4866					; increase count 
4866			 
4866 c1					pop bc	 
4867 0c					inc c 
4868 c5					push bc 
4869					 
4869			 
4869					; get file header and push the file name 
4869			 
4869 11 62 f8				ld de, store_page 
486c cd 0c 03				call storage_read_block 
486f			 
486f					; push file id to stack 
486f				 
486f 3a 62 f8				ld a, (store_page) 
4872 26 00				ld h, 0 
4874 6f					ld l, a 
4875 cd 04 1d				call forth_push_numhl 
4878			 
4878					; push extent count to stack  
4878				 
4878 3a 64 f8				ld a, (store_page+2) 
487b 26 00				ld h, 0 
487d 6f					ld l, a 
487e cd 04 1d				call forth_push_numhl 
4881			 
4881					; push file name 
4881			 
4881 21 65 f8				ld hl, store_page+3 
4884					if DEBUG_FORTH_WORDS 
4884						DMARK "DI5" 
4884 f5				push af  
4885 3a 99 48			ld a, (.dmark)  
4888 32 77 fb			ld (debug_mark),a  
488b 3a 9a 48			ld a, (.dmark+1)  
488e 32 78 fb			ld (debug_mark+1),a  
4891 3a 9b 48			ld a, (.dmark+2)  
4894 32 79 fb			ld (debug_mark+2),a  
4897 18 03			jr .pastdmark  
4899 ..			.dmark: db "DI5"  
489c f1			.pastdmark: pop af  
489d			endm  
# End of macro DMARK
489d						CALLMONITOR 
489d cd 74 17			call break_point_state  
48a0				endm  
# End of macro CALLMONITOR
48a0					endif 
48a0 cd 72 1d				call forth_push_str 
48a3					if DEBUG_FORTH_WORDS 
48a3						DMARK "DI6" 
48a3 f5				push af  
48a4 3a b8 48			ld a, (.dmark)  
48a7 32 77 fb			ld (debug_mark),a  
48aa 3a b9 48			ld a, (.dmark+1)  
48ad 32 78 fb			ld (debug_mark+1),a  
48b0 3a ba 48			ld a, (.dmark+2)  
48b3 32 79 fb			ld (debug_mark+2),a  
48b6 18 03			jr .pastdmark  
48b8 ..			.dmark: db "DI6"  
48bb f1			.pastdmark: pop af  
48bc			endm  
# End of macro DMARK
48bc						CALLMONITOR 
48bc cd 74 17			call break_point_state  
48bf				endm  
# End of macro CALLMONITOR
48bf					endif 
48bf			.dirnotfound: 
48bf c1					pop bc     
48c0 10 95				djnz .diritem 
48c2				 
48c2			.dirdone:	 
48c2					if DEBUG_FORTH_WORDS 
48c2						DMARK "DI7" 
48c2 f5				push af  
48c3 3a d7 48			ld a, (.dmark)  
48c6 32 77 fb			ld (debug_mark),a  
48c9 3a d8 48			ld a, (.dmark+1)  
48cc 32 78 fb			ld (debug_mark+1),a  
48cf 3a d9 48			ld a, (.dmark+2)  
48d2 32 79 fb			ld (debug_mark+2),a  
48d5 18 03			jr .pastdmark  
48d7 ..			.dmark: db "DI7"  
48da f1			.pastdmark: pop af  
48db			endm  
# End of macro DMARK
48db						CALLMONITOR 
48db cd 74 17			call break_point_state  
48de				endm  
# End of macro CALLMONITOR
48de					endif 
48de			 
48de					; push a count of the dir items found 
48de			 
48de 26 00				ld h, 0 
48e0 69					ld l, c 
48e1 cd 04 1d				call forth_push_numhl 
48e4			 
48e4					; push the bank label 
48e4			 
48e4 cd bd 03				call storage_get_block_0 
48e7			 
48e7				 
48e7 21 65 f8		 		ld hl, store_page+3 
48ea			 
48ea					if DEBUG_FORTH_WORDS 
48ea						DMARK "DI8" 
48ea f5				push af  
48eb 3a ff 48			ld a, (.dmark)  
48ee 32 77 fb			ld (debug_mark),a  
48f1 3a 00 49			ld a, (.dmark+1)  
48f4 32 78 fb			ld (debug_mark+1),a  
48f7 3a 01 49			ld a, (.dmark+2)  
48fa 32 79 fb			ld (debug_mark+2),a  
48fd 18 03			jr .pastdmark  
48ff ..			.dmark: db "DI8"  
4902 f1			.pastdmark: pop af  
4903			endm  
# End of macro DMARK
4903						CALLMONITOR 
4903 cd 74 17			call break_point_state  
4906				endm  
# End of macro CALLMONITOR
4906					endif 
4906 cd 72 1d				call forth_push_str 
4909			 
4909			 
4909				 
4909					NEXTW 
4909 c3 6d 20			jp macro_next 
490c				endm 
# End of macro NEXTW
490c			.SAVE: 
490c			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
490c			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
490c			;		NEXTW 
490c			;.LOAD: 
490c			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
490c			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
490c			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
490c			;; > > The LOAD command can not be used in any user words or compound lines. 
490c			; 
490c			;		; store_openext use it. If zero it is EOF 
490c			; 
490c			;		; read block from current stream id 
490c			;		; if the block does not contain zero term keep reading blocks until zero found 
490c			;		; push the block to stack 
490c			;		; save the block id to stream 
490c			; 
490c			; 
490c			;		FORTH_DSP_VALUEHL 
490c			; 
490c			;;		push hl 
490c			; 
490c			;	if DEBUG_STORESE 
490c			;		DMARK "LOA" 
490c			;		CALLMONITOR 
490c			;	endif 
490c			;		FORTH_DSP_POP 
490c			; 
490c			;;		pop hl 
490c			; 
490c			;		ld h, l 
490c			;		ld l, 0 
490c			; 
490c			;		push hl     ; stack holds current file id and extent to work with 
490c			; 
490c			; 
490c			;		ld de, store_page      ; get block zero of file 
490c			;	if DEBUG_STORESE 
490c			;		DMARK "LO0" 
490c			;		CALLMONITOR 
490c			;	endif 
490c			;		call storage_read 
490c			; 
490c			;		ld a, (store_page+2)    ; max extents for this file 
490c			;		ld  (store_openmaxext),a   ; get our limit 
490c			; 
490c			;	if DEBUG_STORESE 
490c			;		DMARK "LOE" 
490c			;		CALLMONITOR 
490c			;	endif 
490c			; 
490c			;; TODO dont know why max extents are not present 
490c			;;		cp 0 
490c			;;		jp z, .loadeof     ; dont read past eof 
490c			; 
490c			;;		ld a, 1   ; start from the head of the file 
490c			; 
490c			;.loadline:	pop hl 
490c			;		inc hl 
490c			;		ld  a, (store_openmaxext)   ; get our limit 
490c			;	if DEBUG_STORESE 
490c			;		DMARK "LOx" 
490c			;		CALLMONITOR 
490c			;	endif 
490c			;		inc a 
490c			;		cp l 
490c			;		jp z, .loadeof 
490c			;		push hl    ; save current extent 
490c			; 
490c			;		ld de, store_page 
490c			; 
490c			;	if DEBUG_STORESE 
490c			;		DMARK "LO1" 
490c			;		CALLMONITOR 
490c			;	endif 
490c			;		call storage_read 
490c			; 
490c			;	if DEBUG_STORESE 
490c			;		DMARK "LO2" 
490c			;		CALLMONITOR 
490c			;	endif 
490c			;	call ishlzero 
490c			;	ld a, l 
490c			;	add h 
490c			;	cp 0 
490c			;	jr z, .loadeof 
490c			; 
490c			;	; not eof so hl should point to data to exec 
490c			; 
490c			;	; will need to add the FORTH_END_BUFFER flag 
490c			 ; 
490c			;	ld hl, store_page+2 
490c			;	ld bc, 255 
490c			;	ld a, 0 
490c			;	cpir 
490c			;	if DEBUG_STORESE 
490c			;		DMARK "LOt" 
490c			;		CALLMONITOR 
490c			;	endif 
490c			;	dec hl 
490c			;	ld a, ' ' 
490c			;	ld (hl), a 
490c			;	inc hl 
490c			;	ld (hl), a 
490c			;	inc hl 
490c			;	ld (hl), a 
490c			;	inc hl 
490c			;	ld a, FORTH_END_BUFFER 
490c			;	ld (hl), a 
490c			; 
490c			;	; TODO handle more than a single block read 
490c			; 
490c			; 
490c			;	ld hl, store_page+2 
490c			; 
490c			;	ld (os_tok_ptr), hl 
490c			; 
490c			;	if DEBUG_STORESE 
490c			;		DMARK "LO3" 
490c			;		CALLMONITOR 
490c			;	endif 
490c			; 
490c			;	call forthparse 
490c			;	call forthexec 
490c			;	call forthexec_cleanup 
490c			; 
490c			;	; go to next extent 
490c			; 
490c			;	; get next block  or mark as eof 
490c			;	jp .loadline 
490c			; 
490c			; 
490c			; 
490c			;	       NEXTW 
490c			;.loadeof:	ld a, 0 
490c			;		ld (store_openext), a 
490c			; 
490c			;	if DEBUG_STORESE 
490c			;		DMARK "LOF" 
490c			;		CALLMONITOR 
490c			;	endif 
490c			;		ret 
490c			;		;NEXTW 
490c			;.BSAVE:   
490c			; 
490c			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
490c			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
490c			;		NEXTW 
490c			;.BLOAD: 
490c			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
490c			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
490c			;		NEXTW 
490c			;;;; counter gap 
490c			 
490c			 
490c			.SEO: 
490c				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
490c 64				db WORD_SYS_CORE+80             
490d 2b 49			dw .SEI            
490f 04				db 3 + 1 
4910 .. 00			db "SEO",0              
4914				endm 
# End of macro CWHEAD
4914			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4914			 
4914					; get port 
4914			 
4914					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4914 cd fb 1e			call macro_dsp_valuehl 
4917				endm 
# End of macro FORTH_DSP_VALUEHL
4917			 
4917 e5					push hl    ; u2 - byte 
4918			 
4918					; destroy value TOS 
4918			 
4918					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4918 cd b3 1f			call macro_forth_dsp_pop 
491b				endm 
# End of macro FORTH_DSP_POP
491b			 
491b					; get byte to send 
491b			 
491b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
491b cd fb 1e			call macro_dsp_valuehl 
491e				endm 
# End of macro FORTH_DSP_VALUEHL
491e			 
491e e5					push hl    ; u1 - addr 
491f			 
491f					; destroy value TOS 
491f			 
491f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
491f cd b3 1f			call macro_forth_dsp_pop 
4922				endm 
# End of macro FORTH_DSP_POP
4922			 
4922					; one value on hl get other one back 
4922			 
4922 d1					pop de   ; u1 - byte 
4923			 
4923 e1					pop hl   ; u2 - addr 
4924			 
4924					; TODO Send SPI byte 
4924			 
4924			 
4924 7b					ld a, e 
4925 cd ea 01				call se_writebyte 
4928			 
4928					 
4928			 
4928					NEXTW 
4928 c3 6d 20			jp macro_next 
492b				endm 
# End of macro NEXTW
492b			 
492b			.SEI: 
492b				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
492b 65				db WORD_SYS_CORE+81             
492c 45 49			dw .SFREE            
492e 04				db 3 + 1 
492f .. 00			db "SEI",0              
4933				endm 
# End of macro CWHEAD
4933			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4933			 
4933					; get port 
4933			 
4933					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4933 cd fb 1e			call macro_dsp_valuehl 
4936				endm 
# End of macro FORTH_DSP_VALUEHL
4936			 
4936			;		push hl 
4936			 
4936					; destroy value TOS 
4936			 
4936					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4936 cd b3 1f			call macro_forth_dsp_pop 
4939				endm 
# End of macro FORTH_DSP_POP
4939			 
4939					; one value on hl get other one back 
4939			 
4939			;		pop hl 
4939			 
4939			 
4939					; TODO Get SPI byte 
4939			 
4939 cd 8c 02				call se_readbyte 
493c			 
493c 26 00				ld h, 0 
493e 6f					ld l, a 
493f cd 04 1d				call forth_push_numhl 
4942			 
4942					NEXTW 
4942 c3 6d 20			jp macro_next 
4945				endm 
# End of macro NEXTW
4945			 
4945			.SFREE: 
4945				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4945 67				db WORD_SYS_CORE+83             
4946 74 49			dw .SIZE            
4948 06				db 5 + 1 
4949 .. 00			db "FFREE",0              
494f				endm 
# End of macro CWHEAD
494f			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
494f					if DEBUG_FORTH_WORDS_KEY 
494f						DMARK "FFR" 
494f f5				push af  
4950 3a 64 49			ld a, (.dmark)  
4953 32 77 fb			ld (debug_mark),a  
4956 3a 65 49			ld a, (.dmark+1)  
4959 32 78 fb			ld (debug_mark+1),a  
495c 3a 66 49			ld a, (.dmark+2)  
495f 32 79 fb			ld (debug_mark+2),a  
4962 18 03			jr .pastdmark  
4964 ..			.dmark: db "FFR"  
4967 f1			.pastdmark: pop af  
4968			endm  
# End of macro DMARK
4968						CALLMONITOR 
4968 cd 74 17			call break_point_state  
496b				endm  
# End of macro CALLMONITOR
496b					endif 
496b			 
496b cd cb 06				call storage_freeblocks 
496e			 
496e cd 04 1d				call forth_push_numhl 
4971			 
4971				       NEXTW 
4971 c3 6d 20			jp macro_next 
4974				endm 
# End of macro NEXTW
4974			.SIZE: 
4974				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4974 67				db WORD_SYS_CORE+83             
4975 a8 49			dw .CREATE            
4977 05				db 4 + 1 
4978 .. 00			db "SIZE",0              
497d				endm 
# End of macro CWHEAD
497d			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
497d					if DEBUG_FORTH_WORDS_KEY 
497d						DMARK "SIZ" 
497d f5				push af  
497e 3a 92 49			ld a, (.dmark)  
4981 32 77 fb			ld (debug_mark),a  
4984 3a 93 49			ld a, (.dmark+1)  
4987 32 78 fb			ld (debug_mark+1),a  
498a 3a 94 49			ld a, (.dmark+2)  
498d 32 79 fb			ld (debug_mark+2),a  
4990 18 03			jr .pastdmark  
4992 ..			.dmark: db "SIZ"  
4995 f1			.pastdmark: pop af  
4996			endm  
# End of macro DMARK
4996						CALLMONITOR 
4996 cd 74 17			call break_point_state  
4999				endm  
# End of macro CALLMONITOR
4999					endif 
4999			 
4999					FORTH_DSP_VALUEHL 
4999 cd fb 1e			call macro_dsp_valuehl 
499c				endm 
# End of macro FORTH_DSP_VALUEHL
499c			;		push hl 
499c					FORTH_DSP_POP 
499c cd b3 1f			call macro_forth_dsp_pop 
499f				endm 
# End of macro FORTH_DSP_POP
499f			;		pop hl 
499f cd 3b 03				call storage_file_size 
49a2			 
49a2 cd 04 1d				call forth_push_numhl 
49a5			  
49a5			 
49a5				       NEXTW 
49a5 c3 6d 20			jp macro_next 
49a8				endm 
# End of macro NEXTW
49a8			 
49a8			.CREATE: 
49a8				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
49a8 68				db WORD_SYS_CORE+84             
49a9 16 4a			dw .APPEND            
49ab 07				db 6 + 1 
49ac .. 00			db "CREATE",0              
49b3				endm 
# End of macro CWHEAD
49b3			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
49b3			; | | e.g.  
49b3			; | | TestProgram CREATE 
49b3			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
49b3			; | |  
49b3			; | | Max file IDs are 255. 
49b3			; | |  
49b3					 
49b3					if DEBUG_FORTH_WORDS_KEY 
49b3						DMARK "CRT" 
49b3 f5				push af  
49b4 3a c8 49			ld a, (.dmark)  
49b7 32 77 fb			ld (debug_mark),a  
49ba 3a c9 49			ld a, (.dmark+1)  
49bd 32 78 fb			ld (debug_mark+1),a  
49c0 3a ca 49			ld a, (.dmark+2)  
49c3 32 79 fb			ld (debug_mark+2),a  
49c6 18 03			jr .pastdmark  
49c8 ..			.dmark: db "CRT"  
49cb f1			.pastdmark: pop af  
49cc			endm  
# End of macro DMARK
49cc						CALLMONITOR 
49cc cd 74 17			call break_point_state  
49cf				endm  
# End of macro CALLMONITOR
49cf					endif 
49cf			;		call storage_get_block_0 
49cf			 
49cf					; TODO pop hl 
49cf			 
49cf					;v5 FORTH_DSP_VALUE 
49cf					FORTH_DSP_VALUE 
49cf cd e4 1e			call macro_forth_dsp_value 
49d2				endm 
# End of macro FORTH_DSP_VALUE
49d2			 
49d2				if DEBUG_STORESE 
49d2					DMARK "CR1" 
49d2 f5				push af  
49d3 3a e7 49			ld a, (.dmark)  
49d6 32 77 fb			ld (debug_mark),a  
49d9 3a e8 49			ld a, (.dmark+1)  
49dc 32 78 fb			ld (debug_mark+1),a  
49df 3a e9 49			ld a, (.dmark+2)  
49e2 32 79 fb			ld (debug_mark+2),a  
49e5 18 03			jr .pastdmark  
49e7 ..			.dmark: db "CR1"  
49ea f1			.pastdmark: pop af  
49eb			endm  
# End of macro DMARK
49eb					CALLMONITOR 
49eb cd 74 17			call break_point_state  
49ee				endm  
# End of macro CALLMONITOR
49ee				endif 
49ee			;		push hl 
49ee			;		FORTH_DSP_POP 
49ee			;		pop hl 
49ee			 
49ee			;		inc hl   ; move past the type marker 
49ee			 
49ee cd 01 07				call storage_create 
49f1			 
49f1				if DEBUG_STORESE 
49f1					DMARK "CT1" 
49f1 f5				push af  
49f2 3a 06 4a			ld a, (.dmark)  
49f5 32 77 fb			ld (debug_mark),a  
49f8 3a 07 4a			ld a, (.dmark+1)  
49fb 32 78 fb			ld (debug_mark+1),a  
49fe 3a 08 4a			ld a, (.dmark+2)  
4a01 32 79 fb			ld (debug_mark+2),a  
4a04 18 03			jr .pastdmark  
4a06 ..			.dmark: db "CT1"  
4a09 f1			.pastdmark: pop af  
4a0a			endm  
# End of macro DMARK
4a0a					CALLMONITOR 
4a0a cd 74 17			call break_point_state  
4a0d				endm  
# End of macro CALLMONITOR
4a0d				endif 
4a0d			;		push hl 
4a0d					FORTH_DSP_POP 
4a0d cd b3 1f			call macro_forth_dsp_pop 
4a10				endm 
# End of macro FORTH_DSP_POP
4a10			;		pop hl 
4a10					; push file id to stack 
4a10 cd 04 1d				call forth_push_numhl 
4a13			 
4a13			 
4a13			 
4a13				       NEXTW 
4a13 c3 6d 20			jp macro_next 
4a16				endm 
# End of macro NEXTW
4a16			 
4a16			.APPEND: 
4a16				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4a16 69				db WORD_SYS_CORE+85             
4a17 a7 4a			dw .SDEL            
4a19 07				db 6 + 1 
4a1a .. 00			db "APPEND",0              
4a21				endm 
# End of macro CWHEAD
4a21			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4a21			; | | e.g. 
4a21			; | | Test CREATE      -> $01 
4a21			; | | "A string to add to file" $01 APPEND 
4a21			; | |  
4a21			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4a21					if DEBUG_FORTH_WORDS_KEY 
4a21						DMARK "APP" 
4a21 f5				push af  
4a22 3a 36 4a			ld a, (.dmark)  
4a25 32 77 fb			ld (debug_mark),a  
4a28 3a 37 4a			ld a, (.dmark+1)  
4a2b 32 78 fb			ld (debug_mark+1),a  
4a2e 3a 38 4a			ld a, (.dmark+2)  
4a31 32 79 fb			ld (debug_mark+2),a  
4a34 18 03			jr .pastdmark  
4a36 ..			.dmark: db "APP"  
4a39 f1			.pastdmark: pop af  
4a3a			endm  
# End of macro DMARK
4a3a						CALLMONITOR 
4a3a cd 74 17			call break_point_state  
4a3d				endm  
# End of macro CALLMONITOR
4a3d					endif 
4a3d			 
4a3d					FORTH_DSP_VALUEHL 
4a3d cd fb 1e			call macro_dsp_valuehl 
4a40				endm 
# End of macro FORTH_DSP_VALUEHL
4a40 e5					push hl 	; save file id 
4a41			 
4a41				if DEBUG_STORESE 
4a41					DMARK "AP1" 
4a41 f5				push af  
4a42 3a 56 4a			ld a, (.dmark)  
4a45 32 77 fb			ld (debug_mark),a  
4a48 3a 57 4a			ld a, (.dmark+1)  
4a4b 32 78 fb			ld (debug_mark+1),a  
4a4e 3a 58 4a			ld a, (.dmark+2)  
4a51 32 79 fb			ld (debug_mark+2),a  
4a54 18 03			jr .pastdmark  
4a56 ..			.dmark: db "AP1"  
4a59 f1			.pastdmark: pop af  
4a5a			endm  
# End of macro DMARK
4a5a					CALLMONITOR 
4a5a cd 74 17			call break_point_state  
4a5d				endm  
# End of macro CALLMONITOR
4a5d				endif 
4a5d					FORTH_DSP_POP 
4a5d cd b3 1f			call macro_forth_dsp_pop 
4a60				endm 
# End of macro FORTH_DSP_POP
4a60			 
4a60					FORTH_DSP_VALUEHL 
4a60 cd fb 1e			call macro_dsp_valuehl 
4a63				endm 
# End of macro FORTH_DSP_VALUEHL
4a63					;v5 FORTH_DSP_VALUE 
4a63 e5					push hl 	; save ptr to string to save 
4a64			 
4a64				if DEBUG_STORESE 
4a64					DMARK "AP1" 
4a64 f5				push af  
4a65 3a 79 4a			ld a, (.dmark)  
4a68 32 77 fb			ld (debug_mark),a  
4a6b 3a 7a 4a			ld a, (.dmark+1)  
4a6e 32 78 fb			ld (debug_mark+1),a  
4a71 3a 7b 4a			ld a, (.dmark+2)  
4a74 32 79 fb			ld (debug_mark+2),a  
4a77 18 03			jr .pastdmark  
4a79 ..			.dmark: db "AP1"  
4a7c f1			.pastdmark: pop af  
4a7d			endm  
# End of macro DMARK
4a7d					CALLMONITOR 
4a7d cd 74 17			call break_point_state  
4a80				endm  
# End of macro CALLMONITOR
4a80				endif 
4a80					FORTH_DSP_POP 
4a80 cd b3 1f			call macro_forth_dsp_pop 
4a83				endm 
# End of macro FORTH_DSP_POP
4a83			 
4a83 d1					pop de 
4a84 e1					pop hl 
4a85				if DEBUG_STORESE 
4a85					DMARK "AP2" 
4a85 f5				push af  
4a86 3a 9a 4a			ld a, (.dmark)  
4a89 32 77 fb			ld (debug_mark),a  
4a8c 3a 9b 4a			ld a, (.dmark+1)  
4a8f 32 78 fb			ld (debug_mark+1),a  
4a92 3a 9c 4a			ld a, (.dmark+2)  
4a95 32 79 fb			ld (debug_mark+2),a  
4a98 18 03			jr .pastdmark  
4a9a ..			.dmark: db "AP2"  
4a9d f1			.pastdmark: pop af  
4a9e			endm  
# End of macro DMARK
4a9e					CALLMONITOR 
4a9e cd 74 17			call break_point_state  
4aa1				endm  
# End of macro CALLMONITOR
4aa1				endif 
4aa1					;inc de ; skip var type indicator 
4aa1			 
4aa1					; TODO how to append numerics???? 
4aa1			 
4aa1 cd e0 08				call storage_append		 
4aa4			 
4aa4				       NEXTW 
4aa4 c3 6d 20			jp macro_next 
4aa7				endm 
# End of macro NEXTW
4aa7			.SDEL: 
4aa7				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4aa7 6a				db WORD_SYS_CORE+86             
4aa8 f3 4a			dw .OPEN            
4aaa 05				db 4 + 1 
4aab .. 00			db "ERA",0              
4aaf				endm 
# End of macro CWHEAD
4aaf			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4aaf					FORTH_DSP_VALUEHL 
4aaf cd fb 1e			call macro_dsp_valuehl 
4ab2				endm 
# End of macro FORTH_DSP_VALUEHL
4ab2			;		push hl 	; save file id 
4ab2			 
4ab2					if DEBUG_FORTH_WORDS_KEY 
4ab2						DMARK "ERA" 
4ab2 f5				push af  
4ab3 3a c7 4a			ld a, (.dmark)  
4ab6 32 77 fb			ld (debug_mark),a  
4ab9 3a c8 4a			ld a, (.dmark+1)  
4abc 32 78 fb			ld (debug_mark+1),a  
4abf 3a c9 4a			ld a, (.dmark+2)  
4ac2 32 79 fb			ld (debug_mark+2),a  
4ac5 18 03			jr .pastdmark  
4ac7 ..			.dmark: db "ERA"  
4aca f1			.pastdmark: pop af  
4acb			endm  
# End of macro DMARK
4acb						CALLMONITOR 
4acb cd 74 17			call break_point_state  
4ace				endm  
# End of macro CALLMONITOR
4ace					endif 
4ace				if DEBUG_STORESE 
4ace					DMARK "ER1" 
4ace f5				push af  
4acf 3a e3 4a			ld a, (.dmark)  
4ad2 32 77 fb			ld (debug_mark),a  
4ad5 3a e4 4a			ld a, (.dmark+1)  
4ad8 32 78 fb			ld (debug_mark+1),a  
4adb 3a e5 4a			ld a, (.dmark+2)  
4ade 32 79 fb			ld (debug_mark+2),a  
4ae1 18 03			jr .pastdmark  
4ae3 ..			.dmark: db "ER1"  
4ae6 f1			.pastdmark: pop af  
4ae7			endm  
# End of macro DMARK
4ae7					CALLMONITOR 
4ae7 cd 74 17			call break_point_state  
4aea				endm  
# End of macro CALLMONITOR
4aea				endif 
4aea					FORTH_DSP_POP 
4aea cd b3 1f			call macro_forth_dsp_pop 
4aed				endm 
# End of macro FORTH_DSP_POP
4aed			 
4aed			;		pop hl 
4aed			 
4aed cd 4c 05				call storage_erase 
4af0				       NEXTW 
4af0 c3 6d 20			jp macro_next 
4af3				endm 
# End of macro NEXTW
4af3			 
4af3			.OPEN: 
4af3				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4af3 6b				db WORD_SYS_CORE+87             
4af4 83 4b			dw .READ            
4af6 05				db 4 + 1 
4af7 .. 00			db "OPEN",0              
4afc				endm 
# End of macro CWHEAD
4afc			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4afc			; | | e.g. 
4afc			; | | $01 OPEN $01 DO $01 READ . LOOP 
4afc			; | | 
4afc			; | | Will return with 255 blocks if the file does not exist 
4afc			 
4afc					if DEBUG_FORTH_WORDS_KEY 
4afc						DMARK "OPN" 
4afc f5				push af  
4afd 3a 11 4b			ld a, (.dmark)  
4b00 32 77 fb			ld (debug_mark),a  
4b03 3a 12 4b			ld a, (.dmark+1)  
4b06 32 78 fb			ld (debug_mark+1),a  
4b09 3a 13 4b			ld a, (.dmark+2)  
4b0c 32 79 fb			ld (debug_mark+2),a  
4b0f 18 03			jr .pastdmark  
4b11 ..			.dmark: db "OPN"  
4b14 f1			.pastdmark: pop af  
4b15			endm  
# End of macro DMARK
4b15						CALLMONITOR 
4b15 cd 74 17			call break_point_state  
4b18				endm  
# End of macro CALLMONITOR
4b18					endif 
4b18					; TODO handle multiple file opens 
4b18			 
4b18 3e 01			       	ld a, 1 
4b1a 32 59 f8				ld (store_openext), a 
4b1d			 
4b1d					; get max extents for this file 
4b1d				 
4b1d								 
4b1d					FORTH_DSP_VALUEHL 
4b1d cd fb 1e			call macro_dsp_valuehl 
4b20				endm 
# End of macro FORTH_DSP_VALUEHL
4b20			 
4b20 65					ld h, l 
4b21 2e 00				ld l, 0 
4b23			 
4b23				if DEBUG_STORESE 
4b23					DMARK "OPN" 
4b23 f5				push af  
4b24 3a 38 4b			ld a, (.dmark)  
4b27 32 77 fb			ld (debug_mark),a  
4b2a 3a 39 4b			ld a, (.dmark+1)  
4b2d 32 78 fb			ld (debug_mark+1),a  
4b30 3a 3a 4b			ld a, (.dmark+2)  
4b33 32 79 fb			ld (debug_mark+2),a  
4b36 18 03			jr .pastdmark  
4b38 ..			.dmark: db "OPN"  
4b3b f1			.pastdmark: pop af  
4b3c			endm  
# End of macro DMARK
4b3c					CALLMONITOR 
4b3c cd 74 17			call break_point_state  
4b3f				endm  
# End of macro CALLMONITOR
4b3f				endif 
4b3f			;		push hl 
4b3f					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4b3f cd b3 1f			call macro_forth_dsp_pop 
4b42				endm 
# End of macro FORTH_DSP_POP
4b42			;		pop hl 
4b42						 
4b42 11 62 f8				ld de, store_page      ; get block zero of file 
4b45 cd 57 08				call storage_read 
4b48 cd 49 0d			call ishlzero 
4b4b 20 04			jr nz, .opfound 
4b4d			 
4b4d				; file does not exist so indicate with 255 extents in use 
4b4d			 
4b4d 3e ff			ld a, 255 
4b4f 18 29			jr .skipopeneof 
4b51			 
4b51			 
4b51			.opfound: 
4b51			 
4b51			 
4b51 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
4b54 32 58 f8				ld  (store_openmaxext), a   ; get our limit and push 
4b57					 
4b57				if DEBUG_STORESE 
4b57					DMARK "OPx" 
4b57 f5				push af  
4b58 3a 6c 4b			ld a, (.dmark)  
4b5b 32 77 fb			ld (debug_mark),a  
4b5e 3a 6d 4b			ld a, (.dmark+1)  
4b61 32 78 fb			ld (debug_mark+1),a  
4b64 3a 6e 4b			ld a, (.dmark+2)  
4b67 32 79 fb			ld (debug_mark+2),a  
4b6a 18 03			jr .pastdmark  
4b6c ..			.dmark: db "OPx"  
4b6f f1			.pastdmark: pop af  
4b70			endm  
# End of macro DMARK
4b70					CALLMONITOR 
4b70 cd 74 17			call break_point_state  
4b73				endm  
# End of macro CALLMONITOR
4b73				endif 
4b73 fe 00				cp 0 
4b75 20 03				jr nz, .skipopeneof 
4b77					; have opened an empty file 
4b77					 
4b77 32 59 f8				ld (store_openext), a 
4b7a			 
4b7a			.skipopeneof: 
4b7a			 
4b7a 6f					ld l, a 
4b7b 26 00				ld h, 0 
4b7d cd 04 1d				call forth_push_numhl 
4b80			 
4b80			 
4b80				       NEXTW 
4b80 c3 6d 20			jp macro_next 
4b83				endm 
# End of macro NEXTW
4b83			.READ: 
4b83				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4b83 6c				db WORD_SYS_CORE+88             
4b84 ca 4c			dw .EOF            
4b86 05				db 4 + 1 
4b87 .. 00			db "READ",0              
4b8c				endm 
# End of macro CWHEAD
4b8c			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4b8c			; | | e.g. 
4b8c			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b8c			 
4b8c					if DEBUG_FORTH_WORDS_KEY 
4b8c						DMARK "REA" 
4b8c f5				push af  
4b8d 3a a1 4b			ld a, (.dmark)  
4b90 32 77 fb			ld (debug_mark),a  
4b93 3a a2 4b			ld a, (.dmark+1)  
4b96 32 78 fb			ld (debug_mark+1),a  
4b99 3a a3 4b			ld a, (.dmark+2)  
4b9c 32 79 fb			ld (debug_mark+2),a  
4b9f 18 03			jr .pastdmark  
4ba1 ..			.dmark: db "REA"  
4ba4 f1			.pastdmark: pop af  
4ba5			endm  
# End of macro DMARK
4ba5						CALLMONITOR 
4ba5 cd 74 17			call break_point_state  
4ba8				endm  
# End of macro CALLMONITOR
4ba8					endif 
4ba8					; store_openext use it. If zero it is EOF 
4ba8			 
4ba8					; read block from current stream id 
4ba8					; if the block does not contain zero term keep reading blocks until zero found 
4ba8					; push the block to stack 
4ba8					; save the block id to stream 
4ba8			 
4ba8			 
4ba8					FORTH_DSP_VALUEHL 
4ba8 cd fb 1e			call macro_dsp_valuehl 
4bab				endm 
# End of macro FORTH_DSP_VALUEHL
4bab			 
4bab			;		push hl 
4bab			 
4bab				if DEBUG_STORESE 
4bab					DMARK "REA" 
4bab f5				push af  
4bac 3a c0 4b			ld a, (.dmark)  
4baf 32 77 fb			ld (debug_mark),a  
4bb2 3a c1 4b			ld a, (.dmark+1)  
4bb5 32 78 fb			ld (debug_mark+1),a  
4bb8 3a c2 4b			ld a, (.dmark+2)  
4bbb 32 79 fb			ld (debug_mark+2),a  
4bbe 18 03			jr .pastdmark  
4bc0 ..			.dmark: db "REA"  
4bc3 f1			.pastdmark: pop af  
4bc4			endm  
# End of macro DMARK
4bc4					CALLMONITOR 
4bc4 cd 74 17			call break_point_state  
4bc7				endm  
# End of macro CALLMONITOR
4bc7				endif 
4bc7					FORTH_DSP_POP 
4bc7 cd b3 1f			call macro_forth_dsp_pop 
4bca				endm 
# End of macro FORTH_DSP_POP
4bca			 
4bca			;		pop hl 
4bca				 
4bca 65					ld h,l 
4bcb			 
4bcb 3a 59 f8				ld a, (store_openext) 
4bce 6f					ld l, a 
4bcf					 
4bcf fe 00				cp 0 
4bd1 ca 9c 4c				jp z, .ateof     ; dont read past eof 
4bd4			 
4bd4			 
4bd4 11 62 f8				ld de, store_page 
4bd7				if DEBUG_STORESE 
4bd7					DMARK "RE1" 
4bd7 f5				push af  
4bd8 3a ec 4b			ld a, (.dmark)  
4bdb 32 77 fb			ld (debug_mark),a  
4bde 3a ed 4b			ld a, (.dmark+1)  
4be1 32 78 fb			ld (debug_mark+1),a  
4be4 3a ee 4b			ld a, (.dmark+2)  
4be7 32 79 fb			ld (debug_mark+2),a  
4bea 18 03			jr .pastdmark  
4bec ..			.dmark: db "RE1"  
4bef f1			.pastdmark: pop af  
4bf0			endm  
# End of macro DMARK
4bf0					CALLMONITOR 
4bf0 cd 74 17			call break_point_state  
4bf3				endm  
# End of macro CALLMONITOR
4bf3				endif 
4bf3 cd 57 08				call storage_read 
4bf6			 
4bf6				if DEBUG_STORESE 
4bf6					DMARK "RE2" 
4bf6 f5				push af  
4bf7 3a 0b 4c			ld a, (.dmark)  
4bfa 32 77 fb			ld (debug_mark),a  
4bfd 3a 0c 4c			ld a, (.dmark+1)  
4c00 32 78 fb			ld (debug_mark+1),a  
4c03 3a 0d 4c			ld a, (.dmark+2)  
4c06 32 79 fb			ld (debug_mark+2),a  
4c09 18 03			jr .pastdmark  
4c0b ..			.dmark: db "RE2"  
4c0e f1			.pastdmark: pop af  
4c0f			endm  
# End of macro DMARK
4c0f					CALLMONITOR 
4c0f cd 74 17			call break_point_state  
4c12				endm  
# End of macro CALLMONITOR
4c12				endif 
4c12 cd 49 0d			call ishlzero 
4c15			;	ld a, l 
4c15			;	add h 
4c15			;	cp 0 
4c15 ca a2 4c			jp z, .readeof 
4c18			 
4c18				; not eof so hl should point to data to push to stack 
4c18			 
4c18				if DEBUG_STORESE 
4c18					DMARK "RE3" 
4c18 f5				push af  
4c19 3a 2d 4c			ld a, (.dmark)  
4c1c 32 77 fb			ld (debug_mark),a  
4c1f 3a 2e 4c			ld a, (.dmark+1)  
4c22 32 78 fb			ld (debug_mark+1),a  
4c25 3a 2f 4c			ld a, (.dmark+2)  
4c28 32 79 fb			ld (debug_mark+2),a  
4c2b 18 03			jr .pastdmark  
4c2d ..			.dmark: db "RE3"  
4c30 f1			.pastdmark: pop af  
4c31			endm  
# End of macro DMARK
4c31					CALLMONITOR 
4c31 cd 74 17			call break_point_state  
4c34				endm  
# End of macro CALLMONITOR
4c34				endif 
4c34 cd 72 1d			call forth_push_str 
4c37			 
4c37				if DEBUG_STORESE 
4c37					DMARK "RE4" 
4c37 f5				push af  
4c38 3a 4c 4c			ld a, (.dmark)  
4c3b 32 77 fb			ld (debug_mark),a  
4c3e 3a 4d 4c			ld a, (.dmark+1)  
4c41 32 78 fb			ld (debug_mark+1),a  
4c44 3a 4e 4c			ld a, (.dmark+2)  
4c47 32 79 fb			ld (debug_mark+2),a  
4c4a 18 03			jr .pastdmark  
4c4c ..			.dmark: db "RE4"  
4c4f f1			.pastdmark: pop af  
4c50			endm  
# End of macro DMARK
4c50					CALLMONITOR 
4c50 cd 74 17			call break_point_state  
4c53				endm  
# End of macro CALLMONITOR
4c53				endif 
4c53				; get next block  or mark as eof 
4c53			 
4c53 3a 58 f8			ld a, (store_openmaxext)   ; get our limit 
4c56 4f				ld c, a	 
4c57 3a 59 f8			ld a, (store_openext) 
4c5a			 
4c5a				if DEBUG_STORESE 
4c5a					DMARK "RE5" 
4c5a f5				push af  
4c5b 3a 6f 4c			ld a, (.dmark)  
4c5e 32 77 fb			ld (debug_mark),a  
4c61 3a 70 4c			ld a, (.dmark+1)  
4c64 32 78 fb			ld (debug_mark+1),a  
4c67 3a 71 4c			ld a, (.dmark+2)  
4c6a 32 79 fb			ld (debug_mark+2),a  
4c6d 18 03			jr .pastdmark  
4c6f ..			.dmark: db "RE5"  
4c72 f1			.pastdmark: pop af  
4c73			endm  
# End of macro DMARK
4c73					CALLMONITOR 
4c73 cd 74 17			call break_point_state  
4c76				endm  
# End of macro CALLMONITOR
4c76				endif 
4c76 b9				cp c 
4c77 28 29			jr z, .readeof     ; at last extent 
4c79			 
4c79 3c					inc a 
4c7a 32 59 f8				ld (store_openext), a 
4c7d			 
4c7d				if DEBUG_STORESE 
4c7d					DMARK "RE6" 
4c7d f5				push af  
4c7e 3a 92 4c			ld a, (.dmark)  
4c81 32 77 fb			ld (debug_mark),a  
4c84 3a 93 4c			ld a, (.dmark+1)  
4c87 32 78 fb			ld (debug_mark+1),a  
4c8a 3a 94 4c			ld a, (.dmark+2)  
4c8d 32 79 fb			ld (debug_mark+2),a  
4c90 18 03			jr .pastdmark  
4c92 ..			.dmark: db "RE6"  
4c95 f1			.pastdmark: pop af  
4c96			endm  
# End of macro DMARK
4c96					CALLMONITOR 
4c96 cd 74 17			call break_point_state  
4c99				endm  
# End of macro CALLMONITOR
4c99				endif 
4c99			 
4c99			 
4c99				       NEXTW 
4c99 c3 6d 20			jp macro_next 
4c9c				endm 
# End of macro NEXTW
4c9c			.ateof: 
4c9c 21 c6 4c				ld hl, .showeof 
4c9f cd 72 1d				call forth_push_str 
4ca2 3e 00		.readeof:	ld a, 0 
4ca4 32 59 f8				ld (store_openext), a 
4ca7			 
4ca7					 
4ca7				if DEBUG_STORESE 
4ca7					DMARK "REF" 
4ca7 f5				push af  
4ca8 3a bc 4c			ld a, (.dmark)  
4cab 32 77 fb			ld (debug_mark),a  
4cae 3a bd 4c			ld a, (.dmark+1)  
4cb1 32 78 fb			ld (debug_mark+1),a  
4cb4 3a be 4c			ld a, (.dmark+2)  
4cb7 32 79 fb			ld (debug_mark+2),a  
4cba 18 03			jr .pastdmark  
4cbc ..			.dmark: db "REF"  
4cbf f1			.pastdmark: pop af  
4cc0			endm  
# End of macro DMARK
4cc0					CALLMONITOR 
4cc0 cd 74 17			call break_point_state  
4cc3				endm  
# End of macro CALLMONITOR
4cc3				endif 
4cc3				       NEXTW 
4cc3 c3 6d 20			jp macro_next 
4cc6				endm 
# End of macro NEXTW
4cc6			 
4cc6 .. 00		.showeof:   db "eof", 0 
4cca			 
4cca			 
4cca			.EOF: 
4cca				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4cca 6d				db WORD_SYS_CORE+89             
4ccb 0b 4d			dw .FORMAT            
4ccd 04				db 3 + 1 
4cce .. 00			db "EOF",0              
4cd2				endm 
# End of macro CWHEAD
4cd2			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4cd2			; | | e.g. 
4cd2			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4cd2					; TODO if current block id for stream is zero then push true else false 
4cd2			 
4cd2					if DEBUG_FORTH_WORDS_KEY 
4cd2						DMARK "EOF" 
4cd2 f5				push af  
4cd3 3a e7 4c			ld a, (.dmark)  
4cd6 32 77 fb			ld (debug_mark),a  
4cd9 3a e8 4c			ld a, (.dmark+1)  
4cdc 32 78 fb			ld (debug_mark+1),a  
4cdf 3a e9 4c			ld a, (.dmark+2)  
4ce2 32 79 fb			ld (debug_mark+2),a  
4ce5 18 03			jr .pastdmark  
4ce7 ..			.dmark: db "EOF"  
4cea f1			.pastdmark: pop af  
4ceb			endm  
# End of macro DMARK
4ceb						CALLMONITOR 
4ceb cd 74 17			call break_point_state  
4cee				endm  
# End of macro CALLMONITOR
4cee					endif 
4cee			 
4cee					; TODO handlue multiple file streams 
4cee			 
4cee					FORTH_DSP_POP     ; for now just get rid of stream id 
4cee cd b3 1f			call macro_forth_dsp_pop 
4cf1				endm 
# End of macro FORTH_DSP_POP
4cf1			 
4cf1 2e 01				ld l, 1 
4cf3 3a 58 f8				ld a, (store_openmaxext) 
4cf6 fe 00				cp 0 
4cf8 28 09				jr  z, .eofdone   ; empty file 
4cfa 3a 59 f8				ld a, (store_openext) 
4cfd fe 00				cp 0 
4cff 28 02				jr  z, .eofdone 
4d01 2e 00				ld l, 0 
4d03 26 00		.eofdone:	ld h, 0 
4d05 cd 04 1d				call forth_push_numhl 
4d08			 
4d08			 
4d08				       NEXTW 
4d08 c3 6d 20			jp macro_next 
4d0b				endm 
# End of macro NEXTW
4d0b			 
4d0b			.FORMAT: 
4d0b				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4d0b 6d				db WORD_SYS_CORE+89             
4d0c 5c 4d			dw .LABEL            
4d0e 07				db 6 + 1 
4d0f .. 00			db "FORMAT",0              
4d16				endm 
# End of macro CWHEAD
4d16			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4d16					; TODO if current block id for stream is zero then push true else false 
4d16				 
4d16				if DEBUG_STORESE 
4d16					DMARK "FOR" 
4d16 f5				push af  
4d17 3a 2b 4d			ld a, (.dmark)  
4d1a 32 77 fb			ld (debug_mark),a  
4d1d 3a 2c 4d			ld a, (.dmark+1)  
4d20 32 78 fb			ld (debug_mark+1),a  
4d23 3a 2d 4d			ld a, (.dmark+2)  
4d26 32 79 fb			ld (debug_mark+2),a  
4d29 18 03			jr .pastdmark  
4d2b ..			.dmark: db "FOR"  
4d2e f1			.pastdmark: pop af  
4d2f			endm  
# End of macro DMARK
4d2f					CALLMONITOR 
4d2f cd 74 17			call break_point_state  
4d32				endm  
# End of macro CALLMONITOR
4d32				endif 
4d32					; Wipes the bank check flags to cause a reformat on next block 0 read 
4d32			 
4d32 21 01 00				ld hl, 1 
4d35 3e 00				ld a, 0 
4d37 cd ea 01				call se_writebyte 
4d3a			 
4d3a				if DEBUG_STORESE 
4d3a					DMARK "FO0" 
4d3a f5				push af  
4d3b 3a 4f 4d			ld a, (.dmark)  
4d3e 32 77 fb			ld (debug_mark),a  
4d41 3a 50 4d			ld a, (.dmark+1)  
4d44 32 78 fb			ld (debug_mark+1),a  
4d47 3a 51 4d			ld a, (.dmark+2)  
4d4a 32 79 fb			ld (debug_mark+2),a  
4d4d 18 03			jr .pastdmark  
4d4f ..			.dmark: db "FO0"  
4d52 f1			.pastdmark: pop af  
4d53			endm  
# End of macro DMARK
4d53					CALLMONITOR 
4d53 cd 74 17			call break_point_state  
4d56				endm  
# End of macro CALLMONITOR
4d56				endif 
4d56					; force bank init 
4d56			 
4d56 cd bd 03				call storage_get_block_0 
4d59					 
4d59				       NEXTW 
4d59 c3 6d 20			jp macro_next 
4d5c				endm 
# End of macro NEXTW
4d5c			.LABEL: 
4d5c				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4d5c 6d				db WORD_SYS_CORE+89             
4d5d aa 4d			dw .STOREPAGE            
4d5f 06				db 5 + 1 
4d60 .. 00			db "LABEL",0              
4d66				endm 
# End of macro CWHEAD
4d66			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d66					; TODO test to see if bank is selected 
4d66				 
4d66					if DEBUG_FORTH_WORDS_KEY 
4d66						DMARK "LBL" 
4d66 f5				push af  
4d67 3a 7b 4d			ld a, (.dmark)  
4d6a 32 77 fb			ld (debug_mark),a  
4d6d 3a 7c 4d			ld a, (.dmark+1)  
4d70 32 78 fb			ld (debug_mark+1),a  
4d73 3a 7d 4d			ld a, (.dmark+2)  
4d76 32 79 fb			ld (debug_mark+2),a  
4d79 18 03			jr .pastdmark  
4d7b ..			.dmark: db "LBL"  
4d7e f1			.pastdmark: pop af  
4d7f			endm  
# End of macro DMARK
4d7f						CALLMONITOR 
4d7f cd 74 17			call break_point_state  
4d82				endm  
# End of macro CALLMONITOR
4d82					endif 
4d82			;	if DEBUG_STORESE 
4d82			;		DMARK "LBL" 
4d82			;		CALLMONITOR 
4d82			;	endif 
4d82					FORTH_DSP_VALUEHL 
4d82 cd fb 1e			call macro_dsp_valuehl 
4d85				endm 
# End of macro FORTH_DSP_VALUEHL
4d85					;v5FORTH_DSP_VALUE 
4d85					 
4d85			;		push hl 
4d85					FORTH_DSP_POP 
4d85 cd b3 1f			call macro_forth_dsp_pop 
4d88				endm 
# End of macro FORTH_DSP_POP
4d88			;		pop hl 
4d88			 
4d88			;v5		inc hl   ; move past the type marker 
4d88			 
4d88				if DEBUG_STORESE 
4d88					DMARK "LBl" 
4d88 f5				push af  
4d89 3a 9d 4d			ld a, (.dmark)  
4d8c 32 77 fb			ld (debug_mark),a  
4d8f 3a 9e 4d			ld a, (.dmark+1)  
4d92 32 78 fb			ld (debug_mark+1),a  
4d95 3a 9f 4d			ld a, (.dmark+2)  
4d98 32 79 fb			ld (debug_mark+2),a  
4d9b 18 03			jr .pastdmark  
4d9d ..			.dmark: db "LBl"  
4da0 f1			.pastdmark: pop af  
4da1			endm  
# End of macro DMARK
4da1					CALLMONITOR 
4da1 cd 74 17			call break_point_state  
4da4				endm  
# End of macro CALLMONITOR
4da4				endif 
4da4 cd e1 04				call storage_label 
4da7			 
4da7				       NEXTW 
4da7 c3 6d 20			jp macro_next 
4daa				endm 
# End of macro NEXTW
4daa			.STOREPAGE: 
4daa				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4daa 6d				db WORD_SYS_CORE+89             
4dab dd 4d			dw .LABELS            
4dad 0a				db 9 + 1 
4dae .. 00			db "STOREPAGE",0              
4db8				endm 
# End of macro CWHEAD
4db8			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4db8					; TODO test to see if bank is selected 
4db8				 
4db8					if DEBUG_FORTH_WORDS_KEY 
4db8						DMARK "STP" 
4db8 f5				push af  
4db9 3a cd 4d			ld a, (.dmark)  
4dbc 32 77 fb			ld (debug_mark),a  
4dbf 3a ce 4d			ld a, (.dmark+1)  
4dc2 32 78 fb			ld (debug_mark+1),a  
4dc5 3a cf 4d			ld a, (.dmark+2)  
4dc8 32 79 fb			ld (debug_mark+2),a  
4dcb 18 03			jr .pastdmark  
4dcd ..			.dmark: db "STP"  
4dd0 f1			.pastdmark: pop af  
4dd1			endm  
# End of macro DMARK
4dd1						CALLMONITOR 
4dd1 cd 74 17			call break_point_state  
4dd4				endm  
# End of macro CALLMONITOR
4dd4					endif 
4dd4			;	if DEBUG_STORESE 
4dd4			;		DMARK "STP" 
4dd4			;		CALLMONITOR 
4dd4			;	endif 
4dd4			 
4dd4 21 62 f8			ld hl, store_page 
4dd7 cd 04 1d			call forth_push_numhl 
4dda			 
4dda			 
4dda				       NEXTW 
4dda c3 6d 20			jp macro_next 
4ddd				endm 
# End of macro NEXTW
4ddd			.LABELS: 
4ddd				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4ddd 6d				db WORD_SYS_CORE+89             
4dde 67 4e			dw .ENDSTORAGE            
4de0 07				db 6 + 1 
4de1 .. 00			db "LABELS",0              
4de8				endm 
# End of macro CWHEAD
4de8			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4de8					;  
4de8			 
4de8					; save the current device selected to restore afterwards 
4de8				 
4de8 3a 48 f8				ld a, (spi_device) 
4deb f5					push af 
4dec			 
4dec			 
4dec					; run through each of the banks 
4dec			 
4dec 21 01 00				ld hl, 1 
4def cd 04 1d				call forth_push_numhl 
4df2 3e ff				ld a, SPI_CE_HIGH 
4df4 cb 87				res SPI_CE0, a 
4df6 32 48 f8				ld (spi_device), a 
4df9 cd bd 03				call storage_get_block_0 
4dfc 21 65 f8				ld hl, store_page+3 
4dff cd 72 1d				call forth_push_str 
4e02			 
4e02					 
4e02 21 02 00				ld hl, 2 
4e05 cd 04 1d				call forth_push_numhl 
4e08 3e ff				ld a, SPI_CE_HIGH 
4e0a cb 8f				res SPI_CE1, a 
4e0c 32 48 f8				ld (spi_device), a 
4e0f cd bd 03				call storage_get_block_0 
4e12 21 65 f8				ld hl, store_page+3 
4e15 cd 72 1d				call forth_push_str 
4e18			 
4e18					 
4e18 21 03 00				ld hl, 3 
4e1b cd 04 1d				call forth_push_numhl 
4e1e 3e ff				ld a, SPI_CE_HIGH 
4e20 cb 97				res SPI_CE2, a 
4e22 32 48 f8				ld (spi_device), a 
4e25 cd bd 03				call storage_get_block_0 
4e28 21 65 f8				ld hl, store_page+3 
4e2b cd 72 1d				call forth_push_str 
4e2e			 
4e2e			 
4e2e 21 04 00				ld hl, 4 
4e31 cd 04 1d				call forth_push_numhl 
4e34 3e ff				ld a, SPI_CE_HIGH 
4e36 cb 9f				res SPI_CE3, a 
4e38 32 48 f8				ld (spi_device), a 
4e3b cd bd 03				call storage_get_block_0 
4e3e 21 65 f8				ld hl, store_page+3 
4e41 cd 72 1d				call forth_push_str 
4e44			 
4e44					 
4e44			 
4e44 21 05 00				ld hl, 5 
4e47 cd 04 1d				call forth_push_numhl 
4e4a 3e ff				ld a, SPI_CE_HIGH 
4e4c cb a7				res SPI_CE4, a 
4e4e 32 48 f8				ld (spi_device), a 
4e51 cd bd 03				call storage_get_block_0 
4e54 21 65 f8				ld hl, store_page+3 
4e57 cd 72 1d				call forth_push_str 
4e5a			 
4e5a					 
4e5a					; push fixed count of storage devices (on board) for now 
4e5a			 
4e5a 21 05 00				ld hl, 5 
4e5d cd 04 1d				call forth_push_numhl 
4e60			 
4e60					; restore selected device  
4e60				 
4e60 f1					pop af 
4e61 32 48 f8				ld (spi_device), a 
4e64			 
4e64				       NEXTW 
4e64 c3 6d 20			jp macro_next 
4e67				endm 
# End of macro NEXTW
4e67			 
4e67			.ENDSTORAGE: 
4e67			; eof 
# End of file forth_words_storage.asm
4e67			endif 
4e67				include "forth_words_device.asm" 
4e67			; Device related words 
4e67			 
4e67			; | ## Device Words 
4e67			 
4e67			if SOUND_ENABLE 
4e67			.NOTE: 
4e67				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e67 33				db WORD_SYS_CORE+31             
4e68 8f 4e			dw .AFTERSOUND            
4e6a 05				db 4 + 1 
4e6b .. 00			db "NOTE",0              
4e70				endm 
# End of macro CWHEAD
4e70			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e70					if DEBUG_FORTH_WORDS_KEY 
4e70						DMARK "NTE" 
4e70 f5				push af  
4e71 3a 85 4e			ld a, (.dmark)  
4e74 32 77 fb			ld (debug_mark),a  
4e77 3a 86 4e			ld a, (.dmark+1)  
4e7a 32 78 fb			ld (debug_mark+1),a  
4e7d 3a 87 4e			ld a, (.dmark+2)  
4e80 32 79 fb			ld (debug_mark+2),a  
4e83 18 03			jr .pastdmark  
4e85 ..			.dmark: db "NTE"  
4e88 f1			.pastdmark: pop af  
4e89			endm  
# End of macro DMARK
4e89						CALLMONITOR 
4e89 cd 74 17			call break_point_state  
4e8c				endm  
# End of macro CALLMONITOR
4e8c					endif 
4e8c			 
4e8c				 
4e8c			 
4e8c					NEXTW 
4e8c c3 6d 20			jp macro_next 
4e8f				endm 
# End of macro NEXTW
4e8f			.AFTERSOUND: 
4e8f			endif 
4e8f			 
4e8f			 
4e8f			USE_GPIO: equ 0 
4e8f			 
4e8f			if USE_GPIO 
4e8f			.GP1: 
4e8f				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4e8f			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4e8f					NEXTW 
4e8f			.GP2: 
4e8f				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4e8f			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4e8f			 
4e8f					NEXTW 
4e8f			 
4e8f			.GP3: 
4e8f				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4e8f			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4e8f			 
4e8f					NEXTW 
4e8f			 
4e8f			.GP4: 
4e8f				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4e8f			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4e8f			 
4e8f					NEXTW 
4e8f			.SIN: 
4e8f			 
4e8f			 
4e8f			endif 
4e8f			 
4e8f			 
4e8f				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4e8f 33				db WORD_SYS_CORE+31             
4e90 c4 4e			dw .SOUT            
4e92 03				db 2 + 1 
4e93 .. 00			db "IN",0              
4e96				endm 
# End of macro CWHEAD
4e96			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4e96					if DEBUG_FORTH_WORDS_KEY 
4e96						DMARK "IN." 
4e96 f5				push af  
4e97 3a ab 4e			ld a, (.dmark)  
4e9a 32 77 fb			ld (debug_mark),a  
4e9d 3a ac 4e			ld a, (.dmark+1)  
4ea0 32 78 fb			ld (debug_mark+1),a  
4ea3 3a ad 4e			ld a, (.dmark+2)  
4ea6 32 79 fb			ld (debug_mark+2),a  
4ea9 18 03			jr .pastdmark  
4eab ..			.dmark: db "IN."  
4eae f1			.pastdmark: pop af  
4eaf			endm  
# End of macro DMARK
4eaf						CALLMONITOR 
4eaf cd 74 17			call break_point_state  
4eb2				endm  
# End of macro CALLMONITOR
4eb2					endif 
4eb2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4eb2 cd fb 1e			call macro_dsp_valuehl 
4eb5				endm 
# End of macro FORTH_DSP_VALUEHL
4eb5			 
4eb5 e5					push hl 
4eb6			 
4eb6					; destroy value TOS 
4eb6			 
4eb6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eb6 cd b3 1f			call macro_forth_dsp_pop 
4eb9				endm 
# End of macro FORTH_DSP_POP
4eb9			 
4eb9					; one value on hl get other one back 
4eb9			 
4eb9 c1					pop bc 
4eba			 
4eba					; do the sub 
4eba			;		ex de, hl 
4eba			 
4eba ed 68				in l,(c) 
4ebc			 
4ebc					; save it 
4ebc			 
4ebc 26 00				ld h,0 
4ebe			 
4ebe					; TODO push value back onto stack for another op etc 
4ebe			 
4ebe cd 04 1d				call forth_push_numhl 
4ec1					NEXTW 
4ec1 c3 6d 20			jp macro_next 
4ec4				endm 
# End of macro NEXTW
4ec4			.SOUT: 
4ec4				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4ec4 34				db WORD_SYS_CORE+32             
4ec5 17 4f			dw .SPIO            
4ec7 04				db 3 + 1 
4ec8 .. 00			db "OUT",0              
4ecc				endm 
# End of macro CWHEAD
4ecc			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4ecc					if DEBUG_FORTH_WORDS_KEY 
4ecc						DMARK "OUT" 
4ecc f5				push af  
4ecd 3a e1 4e			ld a, (.dmark)  
4ed0 32 77 fb			ld (debug_mark),a  
4ed3 3a e2 4e			ld a, (.dmark+1)  
4ed6 32 78 fb			ld (debug_mark+1),a  
4ed9 3a e3 4e			ld a, (.dmark+2)  
4edc 32 79 fb			ld (debug_mark+2),a  
4edf 18 03			jr .pastdmark  
4ee1 ..			.dmark: db "OUT"  
4ee4 f1			.pastdmark: pop af  
4ee5			endm  
# End of macro DMARK
4ee5						CALLMONITOR 
4ee5 cd 74 17			call break_point_state  
4ee8				endm  
# End of macro CALLMONITOR
4ee8					endif 
4ee8			 
4ee8					; get port 
4ee8			 
4ee8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ee8 cd fb 1e			call macro_dsp_valuehl 
4eeb				endm 
# End of macro FORTH_DSP_VALUEHL
4eeb			 
4eeb e5					push hl 
4eec			 
4eec					; destroy value TOS 
4eec			 
4eec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eec cd b3 1f			call macro_forth_dsp_pop 
4eef				endm 
# End of macro FORTH_DSP_POP
4eef			 
4eef					; get byte to send 
4eef			 
4eef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4eef cd fb 1e			call macro_dsp_valuehl 
4ef2				endm 
# End of macro FORTH_DSP_VALUEHL
4ef2			 
4ef2			;		push hl 
4ef2			 
4ef2					; destroy value TOS 
4ef2			 
4ef2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ef2 cd b3 1f			call macro_forth_dsp_pop 
4ef5				endm 
# End of macro FORTH_DSP_POP
4ef5			 
4ef5					; one value on hl get other one back 
4ef5			 
4ef5			;		pop hl 
4ef5			 
4ef5 c1					pop bc 
4ef6			 
4ef6					if DEBUG_FORTH_WORDS 
4ef6						DMARK "OUT" 
4ef6 f5				push af  
4ef7 3a 0b 4f			ld a, (.dmark)  
4efa 32 77 fb			ld (debug_mark),a  
4efd 3a 0c 4f			ld a, (.dmark+1)  
4f00 32 78 fb			ld (debug_mark+1),a  
4f03 3a 0d 4f			ld a, (.dmark+2)  
4f06 32 79 fb			ld (debug_mark+2),a  
4f09 18 03			jr .pastdmark  
4f0b ..			.dmark: db "OUT"  
4f0e f1			.pastdmark: pop af  
4f0f			endm  
# End of macro DMARK
4f0f						CALLMONITOR 
4f0f cd 74 17			call break_point_state  
4f12				endm  
# End of macro CALLMONITOR
4f12					endif 
4f12			 
4f12 ed 69				out (c), l 
4f14			 
4f14					NEXTW 
4f14 c3 6d 20			jp macro_next 
4f17				endm 
# End of macro NEXTW
4f17			 
4f17			 
4f17			.SPIO: 
4f17			 
4f17			if STORAGE_SE 
4f17				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4f17 51				db WORD_SYS_CORE+61             
4f18 28 4f			dw .SPICEH            
4f1a 07				db 6 + 1 
4f1b .. 00			db "SPICEL",0              
4f22				endm 
# End of macro CWHEAD
4f22			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4f22			 
4f22 cd 98 01				call spi_ce_low 
4f25			    NEXTW 
4f25 c3 6d 20			jp macro_next 
4f28				endm 
# End of macro NEXTW
4f28			 
4f28			.SPICEH: 
4f28				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4f28 51				db WORD_SYS_CORE+61             
4f29 39 4f			dw .SPIOb            
4f2b 07				db 6 + 1 
4f2c .. 00			db "SPICEH",0              
4f33				endm 
# End of macro CWHEAD
4f33			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4f33			 
4f33 cd 87 01				call spi_ce_high 
4f36			    NEXTW 
4f36 c3 6d 20			jp macro_next 
4f39				endm 
# End of macro NEXTW
4f39			 
4f39			 
4f39			.SPIOb: 
4f39			 
4f39				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4f39 51				db WORD_SYS_CORE+61             
4f3a 4f 4f			dw .SPII            
4f3c 05				db 4 + 1 
4f3d .. 00			db "SPIO",0              
4f42				endm 
# End of macro CWHEAD
4f42			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4f42			 
4f42					; get port 
4f42			 
4f42			 
4f42					; get byte to send 
4f42			 
4f42					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f42 cd fb 1e			call macro_dsp_valuehl 
4f45				endm 
# End of macro FORTH_DSP_VALUEHL
4f45			 
4f45			;		push hl    ; u1  
4f45			 
4f45					; destroy value TOS 
4f45			 
4f45					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f45 cd b3 1f			call macro_forth_dsp_pop 
4f48				endm 
# End of macro FORTH_DSP_POP
4f48			 
4f48					; one value on hl get other one back 
4f48			 
4f48			;		pop hl   ; u2 - addr 
4f48			 
4f48					; TODO Send SPI byte 
4f48			 
4f48 7d					ld a, l 
4f49 cd bc 00				call spi_send_byte 
4f4c			 
4f4c					NEXTW 
4f4c c3 6d 20			jp macro_next 
4f4f				endm 
# End of macro NEXTW
4f4f			 
4f4f			.SPII: 
4f4f				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4f4f 52				db WORD_SYS_CORE+62             
4f50 64 4f			dw .SESEL            
4f52 06				db 5 + 1 
4f53 .. 00			db "SPII",0              
4f58				endm 
# End of macro CWHEAD
4f58			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4f58			 
4f58					; TODO Get SPI byte 
4f58			 
4f58 cd dd 00				call spi_read_byte 
4f5b			 
4f5b 26 00				ld h, 0 
4f5d 6f					ld l, a 
4f5e cd 04 1d				call forth_push_numhl 
4f61			 
4f61					NEXTW 
4f61 c3 6d 20			jp macro_next 
4f64				endm 
# End of macro NEXTW
4f64			 
4f64			 
4f64			 
4f64			.SESEL: 
4f64				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4f64 66				db WORD_SYS_CORE+82             
4f65 08 50			dw .CARTDEV            
4f67 05				db 4 + 1 
4f68 .. 00			db "BANK",0              
4f6d				endm 
# End of macro CWHEAD
4f6d			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4f6d					if DEBUG_FORTH_WORDS_KEY 
4f6d						DMARK "BNK" 
4f6d f5				push af  
4f6e 3a 82 4f			ld a, (.dmark)  
4f71 32 77 fb			ld (debug_mark),a  
4f74 3a 83 4f			ld a, (.dmark+1)  
4f77 32 78 fb			ld (debug_mark+1),a  
4f7a 3a 84 4f			ld a, (.dmark+2)  
4f7d 32 79 fb			ld (debug_mark+2),a  
4f80 18 03			jr .pastdmark  
4f82 ..			.dmark: db "BNK"  
4f85 f1			.pastdmark: pop af  
4f86			endm  
# End of macro DMARK
4f86						CALLMONITOR 
4f86 cd 74 17			call break_point_state  
4f89				endm  
# End of macro CALLMONITOR
4f89					endif 
4f89			 
4f89 3e ff				ld a, 255 
4f8b 32 4b f8				ld (spi_cartdev), a 
4f8e			 
4f8e					; get bank 
4f8e			 
4f8e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f8e cd fb 1e			call macro_dsp_valuehl 
4f91				endm 
# End of macro FORTH_DSP_VALUEHL
4f91			 
4f91			;		push hl 
4f91			 
4f91					; destroy value TOS 
4f91			 
4f91					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f91 cd b3 1f			call macro_forth_dsp_pop 
4f94				endm 
# End of macro FORTH_DSP_POP
4f94			 
4f94					; one value on hl get other one back 
4f94			 
4f94			;		pop hl 
4f94			 
4f94			 
4f94 0e ff				ld c, SPI_CE_HIGH 
4f96 06 30				ld b, '0'    ; human readable bank number 
4f98			 
4f98 7d					ld a, l 
4f99			 
4f99					if DEBUG_FORTH_WORDS 
4f99						DMARK "BNK" 
4f99 f5				push af  
4f9a 3a ae 4f			ld a, (.dmark)  
4f9d 32 77 fb			ld (debug_mark),a  
4fa0 3a af 4f			ld a, (.dmark+1)  
4fa3 32 78 fb			ld (debug_mark+1),a  
4fa6 3a b0 4f			ld a, (.dmark+2)  
4fa9 32 79 fb			ld (debug_mark+2),a  
4fac 18 03			jr .pastdmark  
4fae ..			.dmark: db "BNK"  
4fb1 f1			.pastdmark: pop af  
4fb2			endm  
# End of macro DMARK
4fb2						CALLMONITOR 
4fb2 cd 74 17			call break_point_state  
4fb5				endm  
# End of macro CALLMONITOR
4fb5					endif 
4fb5			 
4fb5					; active low 
4fb5			 
4fb5 fe 00				cp 0 
4fb7 28 28				jr z, .bset 
4fb9 fe 01				cp 1 
4fbb 20 04				jr nz, .b2 
4fbd cb 81				res 0, c 
4fbf 06 31				ld b, '1'    ; human readable bank number 
4fc1 fe 02		.b2:		cp 2 
4fc3 20 04				jr nz, .b3 
4fc5 cb 89				res 1, c 
4fc7 06 32				ld b, '2'    ; human readable bank number 
4fc9 fe 03		.b3:		cp 3 
4fcb 20 04				jr nz, .b4 
4fcd cb 91				res 2, c 
4fcf 06 33				ld b, '3'    ; human readable bank number 
4fd1 fe 04		.b4:		cp 4 
4fd3 20 04				jr nz, .b5 
4fd5 cb 99				res 3, c 
4fd7 06 34				ld b, '4'    ; human readable bank number 
4fd9 fe 05		.b5:		cp 5 
4fdb 20 04				jr nz, .bset 
4fdd cb a1				res 4, c 
4fdf 06 35				ld b, '5'    ; human readable bank number 
4fe1			 
4fe1			.bset: 
4fe1 79					ld a, c 
4fe2 32 48 f8				ld (spi_device),a 
4fe5 78					ld a, b 
4fe6 32 47 f8				ld (spi_device_id),a 
4fe9					if DEBUG_FORTH_WORDS 
4fe9						DMARK "BN2" 
4fe9 f5				push af  
4fea 3a fe 4f			ld a, (.dmark)  
4fed 32 77 fb			ld (debug_mark),a  
4ff0 3a ff 4f			ld a, (.dmark+1)  
4ff3 32 78 fb			ld (debug_mark+1),a  
4ff6 3a 00 50			ld a, (.dmark+2)  
4ff9 32 79 fb			ld (debug_mark+2),a  
4ffc 18 03			jr .pastdmark  
4ffe ..			.dmark: db "BN2"  
5001 f1			.pastdmark: pop af  
5002			endm  
# End of macro DMARK
5002						CALLMONITOR 
5002 cd 74 17			call break_point_state  
5005				endm  
# End of macro CALLMONITOR
5005					endif 
5005			 
5005					NEXTW 
5005 c3 6d 20			jp macro_next 
5008				endm 
# End of macro NEXTW
5008			 
5008			.CARTDEV: 
5008				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5008 66				db WORD_SYS_CORE+82             
5009 b1 50			dw .ENDDEVICE            
500b 08				db 7 + 1 
500c .. 00			db "CARTDEV",0              
5014				endm 
# End of macro CWHEAD
5014			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5014					if DEBUG_FORTH_WORDS_KEY 
5014						DMARK "CDV" 
5014 f5				push af  
5015 3a 29 50			ld a, (.dmark)  
5018 32 77 fb			ld (debug_mark),a  
501b 3a 2a 50			ld a, (.dmark+1)  
501e 32 78 fb			ld (debug_mark+1),a  
5021 3a 2b 50			ld a, (.dmark+2)  
5024 32 79 fb			ld (debug_mark+2),a  
5027 18 03			jr .pastdmark  
5029 ..			.dmark: db "CDV"  
502c f1			.pastdmark: pop af  
502d			endm  
# End of macro DMARK
502d						CALLMONITOR 
502d cd 74 17			call break_point_state  
5030				endm  
# End of macro CALLMONITOR
5030					endif 
5030			 
5030					; disable se storage bank selection 
5030			 
5030 3e ff				ld a, SPI_CE_HIGH		; ce high 
5032 32 48 f8				ld (spi_device), a 
5035			 
5035					; get bank 
5035			 
5035					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5035 cd fb 1e			call macro_dsp_valuehl 
5038				endm 
# End of macro FORTH_DSP_VALUEHL
5038			 
5038			;		push hl 
5038			 
5038					; destroy value TOS 
5038			 
5038					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5038 cd b3 1f			call macro_forth_dsp_pop 
503b				endm 
# End of macro FORTH_DSP_POP
503b			 
503b					; one value on hl get other one back 
503b			 
503b			;		pop hl 
503b			 
503b					; active low 
503b			 
503b 0e ff				ld c, 255 
503d			 
503d 7d					ld a, l 
503e					if DEBUG_FORTH_WORDS 
503e						DMARK "CDV" 
503e f5				push af  
503f 3a 53 50			ld a, (.dmark)  
5042 32 77 fb			ld (debug_mark),a  
5045 3a 54 50			ld a, (.dmark+1)  
5048 32 78 fb			ld (debug_mark+1),a  
504b 3a 55 50			ld a, (.dmark+2)  
504e 32 79 fb			ld (debug_mark+2),a  
5051 18 03			jr .pastdmark  
5053 ..			.dmark: db "CDV"  
5056 f1			.pastdmark: pop af  
5057			endm  
# End of macro DMARK
5057						CALLMONITOR 
5057 cd 74 17			call break_point_state  
505a				endm  
# End of macro CALLMONITOR
505a					endif 
505a fe 00				cp 0 
505c 28 30				jr z, .cset 
505e fe 01				cp 1 
5060 20 02				jr nz, .c2 
5062 cb 81				res 0, c 
5064 fe 02		.c2:		cp 2 
5066 20 02				jr nz, .c3 
5068 cb 89				res 1, c 
506a fe 03		.c3:		cp 3 
506c 20 02				jr nz, .c4 
506e cb 91				res 2, c 
5070 fe 04		.c4:		cp 4 
5072 20 02				jr nz, .c5 
5074 cb 99				res 3, c 
5076 fe 05		.c5:		cp 5 
5078 20 02				jr nz, .c6 
507a cb a1				res 4, c 
507c fe 06		.c6:		cp 6 
507e 20 02				jr nz, .c7 
5080 cb a9				res 5, c 
5082 fe 07		.c7:		cp 7 
5084 20 02				jr nz, .c8 
5086 cb b1				res 6, c 
5088 fe 08		.c8:		cp 8 
508a 20 02				jr nz, .cset 
508c cb b9				res 7, c 
508e 79			.cset:		ld a, c 
508f 32 4b f8				ld (spi_cartdev),a 
5092			 
5092					if DEBUG_FORTH_WORDS 
5092						DMARK "CD2" 
5092 f5				push af  
5093 3a a7 50			ld a, (.dmark)  
5096 32 77 fb			ld (debug_mark),a  
5099 3a a8 50			ld a, (.dmark+1)  
509c 32 78 fb			ld (debug_mark+1),a  
509f 3a a9 50			ld a, (.dmark+2)  
50a2 32 79 fb			ld (debug_mark+2),a  
50a5 18 03			jr .pastdmark  
50a7 ..			.dmark: db "CD2"  
50aa f1			.pastdmark: pop af  
50ab			endm  
# End of macro DMARK
50ab						CALLMONITOR 
50ab cd 74 17			call break_point_state  
50ae				endm  
# End of macro CALLMONITOR
50ae					endif 
50ae					NEXTW 
50ae c3 6d 20			jp macro_next 
50b1				endm 
# End of macro NEXTW
50b1			endif 
50b1			 
50b1			.ENDDEVICE: 
50b1			; eof 
50b1			 
# End of file forth_words_device.asm
50b1			 
50b1			; var handler 
50b1			 
50b1			 
50b1			.VARS: 
50b1				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
50b1 78				db WORD_SYS_CORE+100             
50b2 c9 50			dw .V0Q            
50b4 04				db 3 + 1 
50b5 .. 00			db "V0!",0              
50b9				endm 
# End of macro CWHEAD
50b9			;| V0! ( u1 -- )  Store value to v0  | DONE 
50b9			 
50b9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50b9 cd fb 1e			call macro_dsp_valuehl 
50bc				endm 
# End of macro FORTH_DSP_VALUEHL
50bc			 
50bc 11 10 f8				ld de, cli_var_array 
50bf			 
50bf eb					ex de, hl 
50c0 73					ld (hl), e 
50c1 23					inc hl 
50c2 72					ld (hl), d 
50c3			 
50c3					; destroy value TOS 
50c3			 
50c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50c3 cd b3 1f			call macro_forth_dsp_pop 
50c6				endm 
# End of macro FORTH_DSP_POP
50c6			 
50c6				       NEXTW 
50c6 c3 6d 20			jp macro_next 
50c9				endm 
# End of macro NEXTW
50c9			.V0Q: 
50c9				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
50c9 79				db WORD_SYS_CORE+101             
50ca da 50			dw .V1S            
50cc 04				db 3 + 1 
50cd .. 00			db "V0@",0              
50d1				endm 
# End of macro CWHEAD
50d1			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
50d1 2a 10 f8				ld hl, (cli_var_array) 
50d4 cd 04 1d				call forth_push_numhl 
50d7			 
50d7				       NEXTW 
50d7 c3 6d 20			jp macro_next 
50da				endm 
# End of macro NEXTW
50da			.V1S: 
50da				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
50da 7a				db WORD_SYS_CORE+102             
50db f2 50			dw .V1Q            
50dd 04				db 3 + 1 
50de .. 00			db "V1!",0              
50e2				endm 
# End of macro CWHEAD
50e2			;| V1! ( u1 -- )  Store value to v1 | DONE 
50e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50e2 cd fb 1e			call macro_dsp_valuehl 
50e5				endm 
# End of macro FORTH_DSP_VALUEHL
50e5			 
50e5 11 12 f8				ld de, cli_var_array+2 
50e8				 
50e8 eb					ex de, hl 
50e9 73					ld (hl), e 
50ea 23					inc hl 
50eb 72					ld (hl), d 
50ec			 
50ec					; destroy value TOS 
50ec			 
50ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50ec cd b3 1f			call macro_forth_dsp_pop 
50ef				endm 
# End of macro FORTH_DSP_POP
50ef				       NEXTW 
50ef c3 6d 20			jp macro_next 
50f2				endm 
# End of macro NEXTW
50f2			.V1Q: 
50f2				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
50f2 7b				db WORD_SYS_CORE+103             
50f3 03 51			dw .V2S            
50f5 04				db 3 + 1 
50f6 .. 00			db "V1@",0              
50fa				endm 
# End of macro CWHEAD
50fa			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
50fa 2a 12 f8				ld hl, (cli_var_array+2) 
50fd cd 04 1d				call forth_push_numhl 
5100				       NEXTW 
5100 c3 6d 20			jp macro_next 
5103				endm 
# End of macro NEXTW
5103			.V2S: 
5103				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5103 7c				db WORD_SYS_CORE+104             
5104 1b 51			dw .V2Q            
5106 04				db 3 + 1 
5107 .. 00			db "V2!",0              
510b				endm 
# End of macro CWHEAD
510b			;| V2! ( u1 -- )  Store value to v2 | DONE 
510b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
510b cd fb 1e			call macro_dsp_valuehl 
510e				endm 
# End of macro FORTH_DSP_VALUEHL
510e			 
510e 11 14 f8				ld de, cli_var_array+4 
5111				 
5111 eb					ex de, hl 
5112 73					ld (hl), e 
5113 23					inc hl 
5114 72					ld (hl), d 
5115			 
5115					; destroy value TOS 
5115			 
5115					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5115 cd b3 1f			call macro_forth_dsp_pop 
5118				endm 
# End of macro FORTH_DSP_POP
5118				       NEXTW 
5118 c3 6d 20			jp macro_next 
511b				endm 
# End of macro NEXTW
511b			.V2Q: 
511b				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
511b 7d				db WORD_SYS_CORE+105             
511c 2c 51			dw .V3S            
511e 04				db 3 + 1 
511f .. 00			db "V2@",0              
5123				endm 
# End of macro CWHEAD
5123			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5123 2a 14 f8				ld hl, (cli_var_array+4) 
5126 cd 04 1d				call forth_push_numhl 
5129				       NEXTW 
5129 c3 6d 20			jp macro_next 
512c				endm 
# End of macro NEXTW
512c			.V3S: 
512c				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
512c 7c				db WORD_SYS_CORE+104             
512d 44 51			dw .V3Q            
512f 04				db 3 + 1 
5130 .. 00			db "V3!",0              
5134				endm 
# End of macro CWHEAD
5134			;| V3! ( u1 -- )  Store value to v3 | DONE 
5134					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5134 cd fb 1e			call macro_dsp_valuehl 
5137				endm 
# End of macro FORTH_DSP_VALUEHL
5137			 
5137 11 16 f8				ld de, cli_var_array+6 
513a				 
513a eb					ex de, hl 
513b 73					ld (hl), e 
513c 23					inc hl 
513d 72					ld (hl), d 
513e			 
513e					; destroy value TOS 
513e			 
513e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
513e cd b3 1f			call macro_forth_dsp_pop 
5141				endm 
# End of macro FORTH_DSP_POP
5141				       NEXTW 
5141 c3 6d 20			jp macro_next 
5144				endm 
# End of macro NEXTW
5144			.V3Q: 
5144				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5144 7d				db WORD_SYS_CORE+105             
5145 55 51			dw .END            
5147 04				db 3 + 1 
5148 .. 00			db "V3@",0              
514c				endm 
# End of macro CWHEAD
514c			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
514c 2a 16 f8				ld hl, (cli_var_array+6) 
514f cd 04 1d				call forth_push_numhl 
5152				       NEXTW 
5152 c3 6d 20			jp macro_next 
5155				endm 
# End of macro NEXTW
5155			 
5155			 
5155			 
5155			 
5155			 
5155			; end of dict marker 
5155			 
5155 00			.END:    db WORD_SYS_END 
5156 00 00			dw 0 
5158 00				db 0 
5159			 
5159			; use to jp here for user dict words to save on macro expansion  
5159			 
5159			user_dict_next: 
5159				NEXTW 
5159 c3 6d 20			jp macro_next 
515c				endm 
# End of macro NEXTW
515c			 
515c			 
515c			user_exec: 
515c				;    ld hl, <word code> 
515c				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
515c				;    call forthexec 
515c				;    jp user_dict_next   (NEXT) 
515c			        ;    <word code bytes> 
515c eb				ex de, hl 
515d 2a 1e f1			ld hl,(os_tok_ptr) 
5160				 
5160				FORTH_RSP_NEXT 
5160 cd ab 1c			call macro_forth_rsp_next 
5163				endm 
# End of macro FORTH_RSP_NEXT
5163			 
5163			if DEBUG_FORTH_UWORD 
5163						DMARK "UEX" 
5163 f5				push af  
5164 3a 78 51			ld a, (.dmark)  
5167 32 77 fb			ld (debug_mark),a  
516a 3a 79 51			ld a, (.dmark+1)  
516d 32 78 fb			ld (debug_mark+1),a  
5170 3a 7a 51			ld a, (.dmark+2)  
5173 32 79 fb			ld (debug_mark+2),a  
5176 18 03			jr .pastdmark  
5178 ..			.dmark: db "UEX"  
517b f1			.pastdmark: pop af  
517c			endm  
# End of macro DMARK
517c				CALLMONITOR 
517c cd 74 17			call break_point_state  
517f				endm  
# End of macro CALLMONITOR
517f			endif 
517f			 
517f			 
517f			 
517f eb				ex de, hl 
5180 22 1e f1			ld (os_tok_ptr), hl 
5183				 
5183				; Don't use next - Skips the first word in uword. 
5183			 
5183 c3 fe 20			jp exec1 
5186			;	NEXT 
5186			 
5186			 
5186			; eof 
# End of file forth_wordsv4.asm
5186			endif 
5186			;;;;;;;;;;;;;; Debug code 
5186			 
5186			 
5186			;if DEBUG_FORTH_PARSE 
5186 .. 00		.nowordfound: db "No match",0 
518f .. 00		.compword:	db "Comparing word ",0 
519f .. 00		.nextwordat:	db "Next word at",0 
51ac .. 00		.charmatch:	db "Char match",0 
51b7			;endif 
51b7			if DEBUG_FORTH_JP 
51b7			.foundword:	db "Word match. Exec..",0 
51b7			endif 
51b7			;if DEBUG_FORTH_PUSH 
51b7 .. 00		.enddict:	db "Dict end. Push.",0 
51c7 .. 00		.push_str:	db "Pushing string",0 
51d6 .. 00		.push_num:	db "Pushing number",0 
51e5 .. 00		.data_sp:	db "SP:",0 
51e9 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
51fb .. 00		.wordinde:	db "Word in DE (3/0):",0 
520d .. 00		.wordinbc:	db "Word in BC (4/0):",0 
521f			;endif 
521f			;if DEBUG_FORTH_MALLOC 
521f .. 00		.push_malloc:	db "Malloc address",0 
522e			;endif 
522e			 
522e			 
522e			 
522e			; display malloc address and current data stack pointer  
522e			 
522e			malloc_error: 
522e d5				push de 
522f f5				push af 
5230 e5				push hl 
5231 cd ec 0a			call clear_display 
5234 11 56 52			ld de, .mallocerr 
5237 3e 00			ld a,0 
5239			;	ld de,os_word_scratch 
5239 cd ff 0a			call str_at_display 
523c 3e 11			ld a, display_row_1+17 
523e 11 77 fb			ld de, debug_mark 
5241 cd ff 0a			call str_at_display 
5244 cd 0f 0b			call update_display 
5247				;call break_point_state 
5247 cd 50 69			call cin_wait 
524a			 
524a 3e 20			ld a, ' ' 
524c 32 0e ee			ld (os_view_disable), a 
524f e1				pop hl 
5250 f1				pop af 
5251 d1				pop de	 
5252				CALLMONITOR 
5252 cd 74 17			call break_point_state  
5255				endm  
# End of macro CALLMONITOR
5255 c9				ret 
5256			 
5256 .. 00		.mallocerr: 	db "Malloc Error",0 
5263			;if DEBUG_FORTH_PUSH 
5263			display_data_sp: 
5263 f5				push af 
5264			 
5264				; see if disabled 
5264			 
5264 3a 0e ee			ld a, (os_view_disable) 
5267 fe 2a			cp '*' 
5269 28 67			jr z, .skipdsp 
526b			 
526b e5				push hl 
526c e5				push hl 
526d e5			push hl 
526e cd ec 0a			call clear_display 
5271 e1			pop hl 
5272 7c				ld a,h 
5273 21 22 f1			ld hl, os_word_scratch 
5276 cd 21 10			call hexout 
5279 e1				pop hl 
527a 7d				ld a,l 
527b 21 24 f1			ld hl, os_word_scratch+2 
527e cd 21 10			call hexout 
5281 21 26 f1			ld hl, os_word_scratch+4 
5284 3e 00			ld a,0 
5286 77				ld (hl),a 
5287 11 22 f1			ld de,os_word_scratch 
528a 3e 28				ld a, display_row_2 
528c cd ff 0a				call str_at_display 
528f 11 e9 51			ld de, .wordinhl 
5292 3e 00			ld a, display_row_1 
5294			 
5294 cd ff 0a				call str_at_display 
5297 11 77 fb			ld de, debug_mark 
529a 3e 11			ld a, display_row_1+17 
529c			 
529c cd ff 0a				call str_at_display 
529f			 
529f				; display current data stack pointer 
529f 11 e5 51			ld de,.data_sp 
52a2 3e 30				ld a, display_row_2 + 8 
52a4 cd ff 0a				call str_at_display 
52a7			 
52a7 2a 0a f8			ld hl,(cli_data_sp) 
52aa e5				push hl 
52ab 7c				ld a,h 
52ac 21 22 f1			ld hl, os_word_scratch 
52af cd 21 10			call hexout 
52b2 e1				pop hl 
52b3 7d				ld a,l 
52b4 21 24 f1			ld hl, os_word_scratch+2 
52b7 cd 21 10			call hexout 
52ba 21 26 f1			ld hl, os_word_scratch+4 
52bd 3e 00			ld a,0 
52bf 77				ld (hl),a 
52c0 11 22 f1			ld de,os_word_scratch 
52c3 3e 33				ld a, display_row_2 + 11 
52c5 cd ff 0a				call str_at_display 
52c8			 
52c8			 
52c8 cd 0f 0b			call update_display 
52cb cd 69 0a			call delay1s 
52ce cd 69 0a			call delay1s 
52d1 e1				pop hl 
52d2			.skipdsp: 
52d2 f1				pop af 
52d3 c9				ret 
52d4			 
52d4			display_data_malloc: 
52d4			 
52d4 f5				push af 
52d5 e5				push hl 
52d6 e5				push hl 
52d7 e5			push hl 
52d8 cd ec 0a			call clear_display 
52db e1			pop hl 
52dc 7c				ld a,h 
52dd 21 22 f1			ld hl, os_word_scratch 
52e0 cd 21 10			call hexout 
52e3 e1				pop hl 
52e4 7d				ld a,l 
52e5 21 24 f1			ld hl, os_word_scratch+2 
52e8 cd 21 10			call hexout 
52eb 21 26 f1			ld hl, os_word_scratch+4 
52ee 3e 00			ld a,0 
52f0 77				ld (hl),a 
52f1 11 22 f1			ld de,os_word_scratch 
52f4 3e 28				ld a, display_row_2 
52f6 cd ff 0a				call str_at_display 
52f9 11 1f 52			ld de, .push_malloc 
52fc 3e 00			ld a, display_row_1 
52fe			 
52fe cd ff 0a				call str_at_display 
5301			 
5301				; display current data stack pointer 
5301 11 e5 51			ld de,.data_sp 
5304 3e 30				ld a, display_row_2 + 8 
5306 cd ff 0a				call str_at_display 
5309			 
5309 2a 0a f8			ld hl,(cli_data_sp) 
530c e5				push hl 
530d 7c				ld a,h 
530e 21 22 f1			ld hl, os_word_scratch 
5311 cd 21 10			call hexout 
5314 e1				pop hl 
5315 7d				ld a,l 
5316 21 24 f1			ld hl, os_word_scratch+2 
5319 cd 21 10			call hexout 
531c 21 26 f1			ld hl, os_word_scratch+4 
531f 3e 00			ld a,0 
5321 77				ld (hl),a 
5322 11 22 f1			ld de,os_word_scratch 
5325 3e 33				ld a, display_row_2 + 11 
5327 cd ff 0a				call str_at_display 
532a			 
532a cd 0f 0b			call update_display 
532d cd 69 0a			call delay1s 
5330 cd 69 0a			call delay1s 
5333 e1				pop hl 
5334 f1				pop af 
5335 c9				ret 
5336			;endif 
5336			 
5336			include "forth_autostart.asm" 
5336			; list of commands to perform at system start up 
5336			 
5336			startcmds: 
5336			;	dw test11 
5336			;	dw test12 
5336			;	dw test13 
5336			;	dw test14 
5336			;	dw test15 
5336			;	dw test16 
5336			;	dw test17 
5336			;	dw ifthtest1 
5336			;	dw ifthtest2 
5336			;	dw ifthtest3 
5336			;	dw mmtest1 
5336			;	dw mmtest2 
5336			;	dw mmtest3 
5336			;	dw mmtest4 
5336			;	dw mmtest5 
5336			;	dw mmtest6 
5336			;	dw iftest1 
5336			;	dw iftest2 
5336			;	dw iftest3 
5336			;	dw looptest1 
5336			;	dw looptest2 
5336			;	dw test1 
5336			;	dw test2 
5336			;	dw test3 
5336			;	dw test4 
5336			;	dw game2r 
5336			;	dw game2b1 
5336			;	dw game2b2 
5336			 
5336				; start up words that are actually useful 
5336			 
5336 94 53			dw clrstack 
5338 c7 53			dw type 
533a 88 55			dw stest 
533c eb 53			dw strncpy 
533e 29 55			dw list 
5340 4c 54			dw start1 
5342 5e 54			dw start2 
5344			;	dw start3 
5344 71 54			dw start3b 
5346 c9 54			dw start3c 
5348			 
5348				; (unit) testing words 
5348			 
5348 ff 55			dw mtesta 
534a b4 56			dw mtestb 
534c 57 57			dw mtestc 
534e 0c 58			dw mtestd 
5350 b0 58			dw mteste 
5352			 
5352				; demo/game words 
5352			 
5352 bc 5f		        dw game3w 
5354 ea 5f		        dw game3p 
5356 08 60		        dw game3sc 
5358 39 60		        dw game3vsi 
535a 65 60		        dw game3vs 
535c				 
535c af 5d			dw game2b 
535e 1d 5e			dw game2bf 
5360 67 5e			dw game2mba 
5362 fd 5e			dw game2mbas 
5364 3f 5f			dw game2mb 
5366			 
5366 70 5a			dw game1 
5368 81 5a			dw game1a 
536a e3 5a			dw game1b 
536c 18 5b			dw game1c 
536e 4e 5b			dw game1d 
5370 7f 5b			dw game1s 
5372 93 5b			dw game1t 
5374 a8 5b			dw game1f 
5376 dc 5b			dw game1z 
5378 20 5c			dw game1zz 
537a			 
537a 66 59			dw test5 
537c 9e 59			dw test6 
537e d6 59			dw test7 
5380 ea 59			dw test8 
5382 16 5a			dw test9 
5384 2c 5a			dw test10 
5386				 
5386 f7 5c		        dw ssv5 
5388 db 5c		        dw ssv4 
538a bf 5c		        dw ssv3 
538c 89 5c		        dw ssv2 
538e 10 5d		        dw ssv1 
5390 58 5d		        dw ssv1cpm 
5392			;	dw keyup 
5392			;	dw keydown 
5392			;	dw keyleft 
5392			;	dw keyright 
5392			;	dw 	keyf1 
5392			;	dw keyf2 
5392			;	dw keyf3 
5392			;	dw keyf4 
5392			;	dw keyf5 
5392			;	dw keyf6 
5392			;	dw keyf7 
5392			;	dw keyf8 
5392			;	dw keyf9 
5392			;	dw keyf10 
5392			;	dw keyf11 
5392			;	dw keyf12 
5392			;	dw keytab 
5392			;	dw keycr 
5392			;	dw keyhome 
5392			;	dw keyend 
5392			;	dw keybs 
5392 00 00			db 0, 0	 
5394			 
5394			 
5394			; clear stack  
5394			 
5394 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
53c7			 
53c7			; type ( addr count - ) 
53c7 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
53eb			 
53eb			; some direct memory words 
53eb			; strncpy ( len t f -- t ) 
53eb			 
53eb .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
544c			 
544c .. 00		start1:     	db ": bpon $0000 bp ;",0 
545e .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5471			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
5471 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
54c9 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5529			 
5529			 
5529			; a handy word to list items on the stack 
5529			 
5529 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5588			 
5588			 
5588			; test stack  
5588			; rnd8 stest 
5588			 
5588 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
55ff			 
55ff			; random malloc and free cycles 
55ff			 
55ff .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
56b4			 
56b4			; fixed malloc and free cycles 
56b4			 
56b4 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5757			 
5757			; fixed double string push and drop cycle  
5757			 
5757 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
580c			 
580c			; consistent fixed string push and drop cycle  
580c			 
580c .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
58b0			 
58b0 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5966			 
5966			;test1:		db ": aa 1 2 3 ;", 0 
5966			;test2:     	db "111 aa 888 999",0 
5966			;test3:     	db ": bb 77 ;",0 
5966			;test4:     	db "$02 $01 do i . loop bb",0 
5966			 
5966 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
599e .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
59d6 .. 00		test7:     	db ": box hline vline ;",0 
59ea .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5a16 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5a2c .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5a51 .. 00		test11:     	db "hello create .",0 
5a60 .. 00		test12:     	db "hello2 create .",0 
5a70			 
5a70			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5a70			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5a70			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5a70			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5a70			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5a70			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5a70			 
5a70			;iftest1:     	db "$0001 IF cls .",0 
5a70			;iftest2:     	db "$0000 IF cls .",0 
5a70			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5a70			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5a70			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5a70			 
5a70			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a70			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a70			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a70			 
5a70			 
5a70			 
5a70			; a small guess the number game 
5a70			 
5a70 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a81 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5ae3			 
5ae3 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5b18 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5b4e .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b7f .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b93 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5ba8 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5bdc .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5c20			 
5c20			; Using 'ga' save a high score across multiple runs using external storage 
5c20			 
5c20 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c89			 
5c89			 
5c89			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c89			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c89			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c89			 
5c89			; simple screen saver to test code memory reuse to destruction 
5c89			 
5c89 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5cbf .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5cdb .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5cf7 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5d10 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d58 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5daf			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5daf			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5daf			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5daf			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5daf			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5daf			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5daf			 
5daf			 
5daf			 
5daf			; minesweeper/battleship finding game 
5daf			; draws a game board of random ship/mine positions 
5daf			; user enters coords to see if it hits on 
5daf			; game ends when all are hit 
5daf			; when hit or miss says how many may be in the area 
5daf			 
5daf			; setup the game board and then hide it 
5daf .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5e1d .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e67			; prompt for where to target 
5e67 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5efd .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5f22			; TODO see if the entered coords hits or misses pushes char hit of miss 
5f22 .. 00		game2mbht:      db ": mbckht nop ;",0 
5f31 .. 00		game2mbms:      db ": mbcms nop ;",0 
5f3f			; TODO how many might be near by 
5f3f .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5fbc			 
5fbc			; Game 3 
5fbc			 
5fbc			; Vert scroller ski game - avoid the trees! 
5fbc			 
5fbc			; v0 score (ie turns) 
5fbc			; v1 player pos 
5fbc			; v2 left wall 
5fbc			; v3 right wall 
5fbc			 
5fbc			; Draw side walls randomly 
5fbc			 
5fbc .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5fea			 
5fea			; Draw player 
5fea .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6008			 
6008			; TODO Get Key 
6008			 
6008			; TODO Move left right 
6008			 
6008			; scroll and move walls a bit 
6008			 
6008 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6039			 
6039			; main game loop 
6039			 
6039 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6065 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
60a4			 
60a4			; key board defs 
60a4			 
60a4 .. 00		keyup:       db ": keyup $05 ;",0 
60b2 .. 00		keydown:       db ": keydown $0a ;",0 
60c2 .. 00		keyleft:       db ": keyleft $0b ;",0 
60d2 .. 00		keyright:       db ": keyright $0c ;",0 
60e3 .. 00		keyf1:       db ": keyf1 $10 ;",0 
60f1 .. 00		keyf2:       db ": keyf2 $11 ;",0 
60ff .. 00		keyf3:       db ": keyf3 $12 ;",0 
610d .. 00		keyf4:       db ": keyf4 $13 ;",0 
611b .. 00		keyf5:       db ": keyf5 $14 ;",0 
6129 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6137 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6145 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6153 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6161 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6170 .. 00		keyf11:       db ": keyf11 $1a ;",0 
617f .. 00		keyf12:       db ": keyf12 $1b ;",0 
618e			 
618e .. 00		keytab:       db ": keytab $09 ;",0 
619d .. 00		keycr:       db ": keycr $0d ;",0 
61ab .. 00		keyhome:       db ": keyhome $0e ;",0 
61bb .. 00		keyend:       db ": keyend $0f ;",0 
61ca .. 00		keybs:       db ": keybs $08 ;",0 
61d8			 
61d8			   
61d8			 
61d8			 
61d8			 
61d8			; eof 
# End of file forth_autostart.asm
61d8			 
61d8 .. 00		sprompt1: db "Startup load...",0 
61e8 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
61fe			 
61fe			 
61fe			 
61fe			 
61fe			forth_startup: 
61fe 21 36 53			ld hl, startcmds 
6201 3e 00			ld a, 0 
6203 32 43 f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6206			 
6206 e5			.start1:	push hl 
6207 cd ec 0a			call clear_display 
620a 11 d8 61			ld de, sprompt1 
620d 3e 00		        ld a, display_row_1 
620f cd ff 0a			call str_at_display 
6212 11 e8 61			ld de, sprompt2 
6215 3e 28		        ld a, display_row_2 
6217 cd ff 0a			call str_at_display 
621a e1				pop hl 
621b e5				push hl 
621c 5e				ld e,(hl) 
621d 23				inc hl 
621e 56				ld d,(hl) 
621f 3e 50		        ld a, display_row_3 
6221 cd ff 0a			call str_at_display 
6224 cd 0f 0b			call update_display 
6227			 
6227			 
6227 3a 43 f2			ld a, (os_last_cmd) 
622a fe 00			cp 0 
622c 28 05			jr z, .startprompt 
622e cd 5d 0a			call delay250ms 
6231 18 24			jr .startdo 
6233				 
6233				 
6233			 
6233			.startprompt: 
6233			 
6233 3e 9f			ld a,display_row_4 + display_cols - 1 
6235 11 7a 1c		        ld de, endprg 
6238 cd ff 0a			call str_at_display 
623b cd 0f 0b			call update_display 
623e cd 69 0a			call delay1s 
6241 cd 50 69			call cin_wait 
6244						 
6244 fe 2a			cp '*' 
6246 28 5e			jr z, .startupend1 
6248 fe 23			cp '#' 
624a 20 07			jr nz, .startno 
624c 3e 01			ld a, 1 
624e 32 43 f2			ld (os_last_cmd),a 
6251 18 04			jr .startdo 
6253 fe 31		.startno:	cp '1' 
6255 28 3a			jr z,.startnxt  
6257			 
6257				; exec startup line 
6257			.startdo:	 
6257 e1				pop hl 
6258 e5				push hl 
6259				 
6259 5e				ld e,(hl) 
625a 23				inc hl 
625b 56				ld d,(hl) 
625c eb				ex de,hl 
625d			 
625d e5				push hl 
625e			 
625e 3e 00			ld a, 0 
6260				;ld a, FORTH_END_BUFFER 
6260 cd 89 11			call strlent 
6263 23				inc hl   ; include zero term to copy 
6264 06 00			ld b,0 
6266 4d				ld c,l 
6267 e1				pop hl 
6268 11 1d ee			ld de, scratch 
626b ed b0			ldir 
626d			 
626d			 
626d 21 1d ee			ld hl, scratch 
6270 cd bb 20			call forthparse 
6273 cd fb 20			call forthexec 
6276 cd 12 20			call forthexec_cleanup 
6279			 
6279 3e 78			ld a, display_row_4 
627b 11 1e 1a			ld de, endprog 
627e			 
627e cd 0f 0b			call update_display		 
6281			 
6281 3a 43 f2			ld a, (os_last_cmd) 
6284 fe 00			cp 0 
6286 20 09			jr nz, .startnxt 
6288 cd 7c 1c			call next_page_prompt 
628b cd ec 0a		        call clear_display 
628e cd 0f 0b			call update_display		 
6291			 
6291				; move onto next startup line? 
6291			.startnxt: 
6291			 
6291 cd 5d 0a			call delay250ms 
6294 e1				pop hl 
6295			 
6295 23				inc hl 
6296 23				inc hl 
6297			 
6297 e5				push hl 
6298 5e				ld e, (hl) 
6299 23				inc hl 
629a 56				ld d, (hl) 
629b e1				pop hl 
629c				; TODO replace 0 test 
629c			 
629c eb				ex de, hl 
629d cd 49 0d			call ishlzero 
62a0			;	ld a,e 
62a0			;	add d 
62a0			;	cp 0    ; any left to do? 
62a0 eb				ex de, hl 
62a1 c2 06 62			jp nz, .start1 
62a4 18 01			jr .startupend 
62a6			 
62a6 e1			.startupend1: pop hl 
62a7			.startupend: 
62a7			 
62a7 cd ec 0a			call clear_display 
62aa cd 0f 0b			call update_display 
62ad c9				ret 
62ae			 
62ae			 
62ae			; stack over and underflow checks 
62ae			 
62ae			; init the words to detect the under/overflow 
62ae			 
62ae			chk_stk_init: 
62ae				; a vague random number to check so we dont get any "lucky" hits 
62ae 3e 2d			ld a, 45 
62b0 6f				ld l, a 
62b1 00				nop 
62b2 3e 17			ld a, 23 
62b4 67				ld h, a 
62b5			 
62b5 22 04 ee			ld (chk_word), hl     ; the word we need to check against 
62b8			 
62b8			;	ld (chk_stund), hl	; stack points.... 
62b8 22 fd fb			ld (chk_stovr), hl 
62bb 22 08 f8			ld (chk_ret_und), hl 
62be 22 86 f7			ld (chk_ret_ovr), hl 
62c1 22 84 f5			ld (chk_loop_ovr), hl 
62c4 22 82 f3			ld (chk_data_ovr), hl 
62c7 c9				ret 
62c8				 
62c8			check_stacks: 
62c8				; check all stack words 
62c8			 
62c8 e5				push hl 
62c9 d5				push de 
62ca			 
62ca			;	ld de,(chk_word) 
62ca			;	ld hl, (chk_stund)	; stack points.... 
62ca			;	if DEBUG_STK_FAULT 
62ca			;		DMARK "FAa" 
62ca			;		CALLMONITOR 
62ca			;	endif 
62ca			;	call cmp16 
62ca			;	jp z, .chk_faulta 
62ca			; 
62ca			;	ld de, sfaultsu 
62ca			;	jp .chk_fault 
62ca			 
62ca 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
62cd ed 5b 04 ee		ld de,(chk_word) 
62d1				if DEBUG_STK_FAULT 
62d1					DMARK "FAb" 
62d1					CALLMONITOR 
62d1				endif 
62d1 cd 3e 0d			call cmp16 
62d4 28 06			jr z, .chk_fault1 
62d6 11 77 63			ld de, sfaultso 
62d9 c3 2b 63			jp .chk_fault 
62dc			.chk_fault1:  
62dc 2a 08 f8			ld hl, (chk_ret_und) 
62df ed 5b 04 ee		ld de,(chk_word) 
62e3				if DEBUG_STK_FAULT 
62e3					DMARK "FAU" 
62e3					CALLMONITOR 
62e3				endif 
62e3 cd 3e 0d			call cmp16 
62e6 ca ef 62			jp z, .chk_fault2 
62e9 11 87 63			ld de, sfaultru 
62ec c3 2b 63			jp .chk_fault 
62ef			.chk_fault2:  
62ef 2a 86 f7			ld hl, (chk_ret_ovr) 
62f2 ed 5b 04 ee		ld de,(chk_word) 
62f6				if DEBUG_STK_FAULT 
62f6					DMARK "FA1" 
62f6					CALLMONITOR 
62f6				endif 
62f6 cd 3e 0d			call cmp16 
62f9 ca 02 63			jp z, .chk_fault3 
62fc 11 95 63			ld de, sfaultro 
62ff c3 2b 63			jp .chk_fault 
6302			.chk_fault3:  
6302 2a 84 f5			ld hl, (chk_loop_ovr) 
6305 ed 5b 04 ee		ld de,(chk_word) 
6309				if DEBUG_STK_FAULT 
6309					DMARK "FA2" 
6309					CALLMONITOR 
6309				endif 
6309 cd 3e 0d			call cmp16 
630c ca 15 63			jp z, .chk_fault4 
630f 11 af 63			ld de, sfaultlo 
6312 c3 2b 63			jp .chk_fault 
6315			.chk_fault4:  
6315 2a 82 f3			ld hl, (chk_data_ovr) 
6318 ed 5b 04 ee		ld de,(chk_word) 
631c				if DEBUG_STK_FAULT 
631c					DMARK "FA3" 
631c					CALLMONITOR 
631c				endif 
631c cd 3e 0d			call cmp16 
631f ca 28 63			jp z, .chk_fault5 
6322 11 c9 63			ld de, sfaultdo 
6325 c3 2b 63			jp .chk_fault 
6328			 
6328			 
6328			.chk_fault5:  
6328 d1				pop de 
6329 e1				pop hl 
632a			 
632a c9				ret 
632b			 
632b cd ec 0a		.chk_fault: 	call clear_display 
632e 3e 28				ld a, display_row_2 
6330 cd ff 0a				call str_at_display 
6333 11 59 63				   ld de, .stackfault 
6336 3e 00				ld a, display_row_1 
6338 cd ff 0a				call str_at_display 
633b 11 77 fb				    ld de, debug_mark 
633e 3e 11				ld a, display_row_1+17 
6340 cd ff 0a				call str_at_display 
6343 cd 0f 0b				call update_display 
6346			 
6346				; prompt before entering montior for investigating issue 
6346			 
6346 3e 78			ld a, display_row_4 
6348 11 1e 1a			ld de, endprog 
634b			 
634b cd 0f 0b			call update_display		 
634e			 
634e cd 7c 1c			call next_page_prompt 
6351			 
6351 d1				pop de 
6352 e1				pop hl 
6353 cd 72 1a				call monitor 
6356 c3 69 19				jp warmstart 
6359					;jp 0 
6359					;halt 
6359			 
6359			 
6359			 
6359 .. 00		.stackfault: 	db "Stack fault:",0 
6366			 
6366 .. 00		sfaultsu: 	db	"Stack under flow",0 
6377 .. 00		sfaultso: 	db	"Stack over flow",0 
6387 .. 00		sfaultru:	db "RTS underflow",0 
6395 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
63af .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
63c9 .. 00		sfaultdo:	db "DTS overflow", 0 
63d6			 
63d6			 
63d6			fault_dsp_under: 
63d6 11 e8 63			ld de, .dsp_under 
63d9 c3 98 64			jp .show_fault 
63dc			 
63dc			fault_rsp_under: 
63dc 11 f6 63			ld de, .rsp_under 
63df c3 98 64			jp .show_fault 
63e2			fault_loop_under: 
63e2 11 04 64			ld de, .loop_under 
63e5 c3 98 64			jp .show_fault 
63e8			 
63e8 .. 00		.dsp_under: db "DSP Underflow",0 
63f6 .. 00		.rsp_under: db "RSP Underflow",0 
6404 .. 00		.loop_under: db "LOOP Underflow",0 
6413			 
6413			 
6413 d5			type_faultn: 	push de 
6414 e5					push hl 
6415 cd ec 0a				call clear_display 
6418 11 3f 64				   ld de, .typefaultn 
641b 3e 00				ld a, display_row_1 
641d cd ff 0a				call str_at_display 
6420 11 77 fb				    ld de, debug_mark 
6423 3e 11				ld a, display_row_1+17 
6425 cd ff 0a				call str_at_display 
6428 cd 0f 0b				call update_display 
642b			 
642b				; prompt before entering montior for investigating issue 
642b			 
642b 3e 78			ld a, display_row_4 
642d 11 1e 1a			ld de, endprog 
6430			 
6430 cd 0f 0b			call update_display		 
6433			 
6433 cd 7c 1c			call next_page_prompt 
6436			 
6436 e5					push hl 
6437 d5					push de 
6438 cd 72 1a				call monitor 
643b c3 69 19				jp warmstart 
643e 76					halt 
643f			 
643f			 
643f .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6456			 
6456 d5			type_faults: 	push de 
6457 e5					push hl 
6458 cd ec 0a				call clear_display 
645b 11 81 64				   ld de, .typefaults 
645e 3e 00				ld a, display_row_1 
6460 cd ff 0a				call str_at_display 
6463 11 77 fb				    ld de, debug_mark 
6466 3e 11				ld a, display_row_1+17 
6468 cd ff 0a				call str_at_display 
646b cd 0f 0b				call update_display 
646e			 
646e				; prompt before entering montior for investigating issue 
646e			 
646e 3e 78			ld a, display_row_4 
6470 11 1e 1a			ld de, endprog 
6473			 
6473 cd 0f 0b			call update_display		 
6476			 
6476 cd 7c 1c			call next_page_prompt 
6479			 
6479 e1					pop hl 
647a d1					pop de 
647b cd 72 1a				call monitor 
647e c3 69 19				jp warmstart 
6481			 
6481			 
6481 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6498			 
6498			.show_fault: 	 
6498 d5					push de 
6499 cd ec 0a				call clear_display 
649c d1					pop de 
649d 3e 00				ld a, display_row_1 
649f cd ff 0a				call str_at_display 
64a2 11 77 fb				    ld de, debug_mark 
64a5 3e 11				ld a, display_row_1+17 
64a7 cd ff 0a				call str_at_display 
64aa cd 0f 0b				call update_display 
64ad			 
64ad				; prompt before entering montior for investigating issue 
64ad			 
64ad 3e 78			ld a, display_row_4 
64af 11 1e 1a			ld de, endprog 
64b2			 
64b2 cd 0f 0b			call update_display		 
64b5			 
64b5 cd 7c 1c			call next_page_prompt 
64b8			 
64b8 e1					pop hl 
64b9 d1					pop de 
64ba cd 72 1a				call monitor 
64bd			; do a dump to cli and not warmstart so we preserve all of the uwords.  
64bd			; TODO Make optional fault restart to cli or warm boot? 
64bd					;jp warmstart 
64bd c3 c4 19				jp cli 
64c0 76					halt 
64c1			 
64c1			; handle the auto run of code from files in storage 
64c1			 
64c1			 
64c1			if STORAGE_SE 
64c1			 
64c1 .. 00		sprompt3: db "Loading from start-up file?:",0 
64de .. 00		sprompt4: db "(Y=Any key/N=No)",0 
64ef			 
64ef			 
64ef			forth_autoload: 
64ef			 
64ef				; load block 0 of store 1 
64ef				 
64ef 3e fe			ld a, $fe      ; bit 0 clear 
64f1 32 48 f8			ld (spi_device), a 
64f4			 
64f4 cd bd 03			call storage_get_block_0 
64f7			 
64f7 3a 83 f8			ld a, (store_page+STORE_0_AUTOFILE) 
64fa			 
64fa fe 00			cp 0 
64fc c8				ret z     ; auto start not enabled 
64fd			 
64fd cd ec 0a			call clear_display 
6500			 
6500				; set bank 
6500			 
6500 3a 85 f8				ld a, (store_page+STORE_0_BANKRUN) 
6503 32 48 f8				ld (spi_device), a 
6506			 
6506				; get file id to load from and get the file name to display 
6506			 
6506 3a 86 f8				ld a, (store_page+STORE_0_FILERUN) 
6509			 
6509 2e 00				ld l, 0 
650b 67					ld h, a 
650c 11 62 f8				ld de, store_page 
650f			 
650f					if DEBUG_FORTH_WORDS 
650f						DMARK "ASp" 
650f f5				push af  
6510 3a 24 65			ld a, (.dmark)  
6513 32 77 fb			ld (debug_mark),a  
6516 3a 25 65			ld a, (.dmark+1)  
6519 32 78 fb			ld (debug_mark+1),a  
651c 3a 26 65			ld a, (.dmark+2)  
651f 32 79 fb			ld (debug_mark+2),a  
6522 18 03			jr .pastdmark  
6524 ..			.dmark: db "ASp"  
6527 f1			.pastdmark: pop af  
6528			endm  
# End of macro DMARK
6528						CALLMONITOR 
6528 cd 74 17			call break_point_state  
652b				endm  
# End of macro CALLMONITOR
652b					endif 
652b cd 57 08				call storage_read 
652e			 
652e					if DEBUG_FORTH_WORDS 
652e						DMARK "ASr" 
652e f5				push af  
652f 3a 43 65			ld a, (.dmark)  
6532 32 77 fb			ld (debug_mark),a  
6535 3a 44 65			ld a, (.dmark+1)  
6538 32 78 fb			ld (debug_mark+1),a  
653b 3a 45 65			ld a, (.dmark+2)  
653e 32 79 fb			ld (debug_mark+2),a  
6541 18 03			jr .pastdmark  
6543 ..			.dmark: db "ASr"  
6546 f1			.pastdmark: pop af  
6547			endm  
# End of macro DMARK
6547						CALLMONITOR 
6547 cd 74 17			call break_point_state  
654a				endm  
# End of macro CALLMONITOR
654a					endif 
654a			 
654a cd 49 0d				call ishlzero 
654d c8					ret z             ; file not found 
654e			 
654e 3e 32				ld a, display_row_2 + 10 
6550 11 65 f8				ld de, store_page+3 
6553 cd ff 0a				call str_at_display 
6556				 
6556			; 
6556			 
6556 3e 05			ld a, display_row_1+5 
6558 11 c1 64			ld de, sprompt3 
655b cd ff 0a			call str_at_display 
655e 3e 5f			ld a, display_row_3+15 
6560 11 de 64			ld de, sprompt4 
6563 cd ff 0a			call str_at_display 
6566			 
6566 cd 0f 0b			call update_display 
6569			 
6569 cd 50 69			call cin_wait 
656c fe 6e			cp 'n' 
656e c8				ret z 
656f fe 4e			cp 'N' 
6571 c8				ret z 
6572			 
6572 cd 69 0a			call delay1s 
6575			 
6575 3a 64 f8			ld a, (store_page+2) 
6578 32 58 f8			ld (store_openmaxext), a    ; save count of ext 
657b 3e 01			ld a, 1  
657d 32 59 f8			ld (store_openext), a    ; save count of ext 
6580			 
6580			.autof:  
6580 6f				ld l , a 
6581				 
6581 3a 62 f8			ld a, (store_page) 
6584 67				ld h, a	 
6585 11 62 f8			ld de, store_page 
6588					if DEBUG_FORTH_WORDS 
6588						DMARK "ASl" 
6588 f5				push af  
6589 3a 9d 65			ld a, (.dmark)  
658c 32 77 fb			ld (debug_mark),a  
658f 3a 9e 65			ld a, (.dmark+1)  
6592 32 78 fb			ld (debug_mark+1),a  
6595 3a 9f 65			ld a, (.dmark+2)  
6598 32 79 fb			ld (debug_mark+2),a  
659b 18 03			jr .pastdmark  
659d ..			.dmark: db "ASl"  
65a0 f1			.pastdmark: pop af  
65a1			endm  
# End of macro DMARK
65a1						CALLMONITOR 
65a1 cd 74 17			call break_point_state  
65a4				endm  
# End of macro CALLMONITOR
65a4					endif 
65a4 cd 57 08				call storage_read 
65a7 cd 49 0d			call ishlzero 
65aa c8				ret z 
65ab			;	jr z, .autoend 
65ab			 
65ab					if DEBUG_FORTH_WORDS 
65ab						DMARK "ASc" 
65ab f5				push af  
65ac 3a c0 65			ld a, (.dmark)  
65af 32 77 fb			ld (debug_mark),a  
65b2 3a c1 65			ld a, (.dmark+1)  
65b5 32 78 fb			ld (debug_mark+1),a  
65b8 3a c2 65			ld a, (.dmark+2)  
65bb 32 79 fb			ld (debug_mark+2),a  
65be 18 03			jr .pastdmark  
65c0 ..			.dmark: db "ASc"  
65c3 f1			.pastdmark: pop af  
65c4			endm  
# End of macro DMARK
65c4						CALLMONITOR 
65c4 cd 74 17			call break_point_state  
65c7				endm  
# End of macro CALLMONITOR
65c7					endif 
65c7 11 64 f8			ld de, store_page+2 
65ca 3e 78			ld a, display_row_4 
65cc cd ff 0a			call str_at_display 
65cf			 
65cf cd 0f 0b			call update_display 
65d2 cd 5d 0a			call delay250ms 
65d5			 
65d5			 
65d5			 
65d5 21 64 f8			ld hl, store_page+2 
65d8 cd bb 20			call forthparse 
65db cd fb 20			call forthexec 
65de cd 12 20			call forthexec_cleanup 
65e1			 
65e1				 
65e1 3a 59 f8			ld a, (store_openext) 
65e4 3c				inc a 
65e5 32 59 f8			ld (store_openext), a    ; save count of ext 
65e8			 
65e8 18 96			jr .autof 
65ea			;.autofdone: 
65ea			; 
65ea			;		if DEBUG_FORTH_WORDS 
65ea			;			DMARK "ASx" 
65ea			;			CALLMONITOR 
65ea			;		endif 
65ea			;;	call clear_display 
65ea			;	ret 
65ea			 
65ea			 
65ea			 
65ea			endif 
65ea			 
65ea			 
65ea			; eof 
# End of file forth_kernel.asm
65ea			;include "nascombasic.asm" 
65ea			 
65ea			 
65ea			; find out where the code ends if loaded into RAM (for SC114) 
65ea			;endofcode:  
65ea			;	nop 
65ea			 
65ea			 
65ea			; eof 
65ea			 
# End of file main.asm
65ea			include "firmware_lcd_4x40.asm" 
65ea			; **********************************************************************  
65ea			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
65ea			; **********************************************************************  
65ea			;  
65ea			; **  Written as a Small Computer Monitor App  
65ea			; **  www.scc.me.uk  
65ea			;  
65ea			; History  
65ea			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
65ea			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
65ea			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
65ea			;  
65ea			; **********************************************************************  
65ea			;  
65ea			; This program is an example of one of the methods of interfacing an   
65ea			; alphanumeric LCD module.   
65ea			;  
65ea			; In this example the display is connected to either a Z80 PIO or a   
65ea			; simple 8-bit output port.   
65ea			;  
65ea			; This interfacing method uses 4-bit data mode and uses time delays  
65ea			; rather than polling the display's ready status. As a result the   
65ea			; interface only requires 6 simple output lines:  
65ea			;   Output bit 0 = not used  
65ea			;   Output bit 1 = not used  
65ea			;   Output bit 2 = RS         High = data, Low = instruction  
65ea			;   Output bit 3 = E          Active high  
65ea			;   Output bit 4 = DB4  
65ea			;   Output bit 5 = DB5  
65ea			;   Output bit 6 = DB6  
65ea			;   Output bit 7 = DB7  
65ea			; Display's R/W is connected to 0v so it is always in write mode  
65ea			;  
65ea			; This set up should work with any system supporting the RC2014 bus  
65ea			  
65ea			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
65ea			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
65ea			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
65ea			;  
65ea			; **********************************************************************  
65ea			  
65ea			; Additonal for 4x40. E1 and E2 instead of just E   
65ea			; TODO swipe vidout signal on port a to activate E2  
65ea			  
65ea			; **********************************************************************  
65ea			; **  Constants  
65ea			; **********************************************************************  
65ea			; LCD constants required by LCD support module  
65ea			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
65ea			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
65ea			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
65ea			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
65ea			; TODO Decide which E is being set  
65ea			kLCDWidth:  EQU display_cols             ;Width in characters  
65ea			  
65ea			; **********************************************************************  
65ea			; **  Code library usage  
65ea			; **********************************************************************  
65ea			  
65ea			; send character to current cursor position  
65ea			; wraps and/or scrolls screen automatically  
65ea			  
65ea			  
65ea			  
65ea			lcd_init:  
65ea			  
65ea			; SCMonAPI functions used  
65ea			  
65ea			; Alphanumeric LCD functions used  
65ea			; no need to specify specific functions for this module  
65ea			  
65ea 3e cf		            LD   A, 11001111b  
65ec d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
65ee 3e 00		            LD   A, 00000000b  
65f0 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
65f2			  
65f2			; Initialise alphanumeric LCD module  
65f2 3e 00				ld a, 0  
65f4 32 d7 f8				ld (display_lcde1e2), a  
65f7 cd 78 66		            CALL fLCD_Init      ;Initialise LCD module  
65fa 3e 01				ld a, 1  
65fc 32 d7 f8				ld (display_lcde1e2), a  
65ff cd 78 66		            CALL fLCD_Init      ;Initialise LCD module  
6602			  
6602 c9				ret  
6603			  
6603			;  
6603			;;  
6603			; lcd functions  
6603			;  
6603			;  
6603			  
6603			; what is at cursor position   
6603			  
6603			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6603			;		call curptr  
6603			;		ret  
6603			  
6603			  
6603			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6603			  
6603			curptr:  
6603 c5				push bc  
6604 21 bd fa			ld hl, display_fb0  
6607			cpr:	  
6607				; loop for cursor whole row  
6607 0e 28			ld c, display_cols  
6609 23			cpr1:	inc hl  
660a 0d				dec c  
660b 20 fc			jr nz, cpr1  
660d 05				dec b  
660e 20 f7			jr nz, cpr  
6610			  
6610				; add col	  
6610			  
6610 23			cpr2:	inc hl  
6611 1d				dec e  
6612 20 fc			jr nz, cpr2  
6614			  
6614 c1				pop bc  
6615 c9				ret  
6616				  
6616			  
6616			  
6616			  
6616			  
6616			; write the frame buffer given in hl to hardware   
6616 22 d5 f8		write_display: ld (display_write_tmp), hl 	   
6619 3e 00			ld a, kLCD_Line1  
661b cd 25 67		            CALL fLCD_Pos       ;Position cursor to location in A  
661e 06 28			ld b, display_cols  
6620 ed 5b d5 f8		ld de, (display_write_tmp)  
6624 cd 70 66			call write_len_string  
6627				  
6627				  
6627 2a d5 f8			ld hl, (display_write_tmp)  
662a 11 28 00			ld de, display_cols  
662d 19				add hl,de  
662e 22 d5 f8			ld (display_write_tmp),hl  
6631			  
6631				  
6631 3e 28			ld a, kLCD_Line2  
6633 cd 25 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6636 06 28			ld b, display_cols  
6638 ed 5b d5 f8		ld de, (display_write_tmp)  
663c cd 70 66			call write_len_string  
663f				  
663f 2a d5 f8			ld hl, (display_write_tmp)  
6642 11 28 00			ld de, display_cols  
6645 19				add hl,de  
6646 22 d5 f8			ld (display_write_tmp),hl  
6649			  
6649				  
6649 3e 50			ld a, kLCD_Line3  
664b cd 25 67		            CALL fLCD_Pos       ;Position cursor to location in A  
664e 06 28			ld b, display_cols  
6650 ed 5b d5 f8		ld de, (display_write_tmp)  
6654 cd 70 66			call write_len_string  
6657				  
6657 2a d5 f8			ld hl, (display_write_tmp)  
665a 11 28 00			ld de, display_cols  
665d 19				add hl,de  
665e 22 d5 f8			ld (display_write_tmp),hl  
6661			  
6661				  
6661 3e 78			ld a, kLCD_Line4  
6663 cd 25 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6666 06 28			ld b, display_cols  
6668 ed 5b d5 f8		ld de, (display_write_tmp)  
666c cd 70 66			call write_len_string  
666f c9					ret  
6670				  
6670				; write out a fixed length string given in b from de  
6670			  
6670 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6671 cd dd 66		            CALL fLCD_Data      ;Write character to display  
6674 13				inc de  
6675 10 f9			djnz write_len_string  
6677 c9				ret  
6678			  
6678			; Some other things to do  
6678			;            LD   A, kLCD_Clear ;Display clear  
6678			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6678			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6678			;            LD   A, kLCD_On     ;Display on with no cursor  
6678			;            ;LD   A, kLCD_Off   ;Display off  
6678			;            CALL fLCD_Inst      ;Send instruction to display  
6678			;  
6678			;  
6678			;            halt  
6678			;  
6678			;  
6678			;MsgHello:   DB  "Hello World!",0  
6678			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6678			  
6678			; Custom characters 5 pixels wide by 8 pixels high  
6678			; Up to 8 custom characters can be defined  
6678			;BitMaps:      
6678			;; Character 0x00 = Battery icon  
6678			;            DB  01110b  
6678			;            DB  11011b  
6678			;            DB  10001b  
6678			;            DB  10001b  
6678			;            DB  11111b  
6678			;            DB  11111b  
6678			;            DB  11111b  
6678			;            DB  11111b  
6678			;; Character 0x01 = Bluetooth icon  
6678			;            DB  01100b  
6678			;            DB  01010b  
6678			;            DB  11100b  
6678			;            DB  01000b  
6678			;            DB  11100b  
6678			;            DB  01010b  
6678			;            DB  01100b  
6678			;            DB  00000b  
6678			;  
6678			  
6678			  
6678			; **********************************************************************  
6678			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6678			; **********************************************************************  
6678			;  
6678			; **  Written as a Small Computer Monitor App   
6678			; **  Version 0.1 SCC 2018-05-16  
6678			; **  www.scc.me.uk  
6678			;  
6678			; **********************************************************************  
6678			;  
6678			; This module provides support for alphanumeric LCD modules using with  
6678			; *  HD44780 (or compatible) controller  
6678			; *  5 x 7 pixel fonts  
6678			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6678			; *  Interface via six digital outputs to the display (see below)  
6678			;  
6678			; LCD module pinout:  
6678			;   1  Vss   0v supply  
6678			;   2  Vdd   5v supply  
6678			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6678			;   4  RS    High = data, Low = instruction  
6678			;   5  R/W   High = Read, Low = Write  
6678			;   6  E     Enable signal (active high)  
6678			;   7  DB0   Data bit 0  
6678			;   8  DB1   Data bit 1  
6678			;   9  DB2   Data bit 2  
6678			;  10  DB3   Data bit 3  
6678			;  11  DB4   Data bit 4  
6678			;  12  DB5   Data bit 5  
6678			;  13  DB6   Data bit 6  
6678			;  14  DB7   Data bit 7  
6678			;  15  A     Backlight anode (+)  
6678			;  16  K     Backlight cathode (-)  
6678			;  
6678			; This interfacing method uses 4-bit data mode and uses time delays  
6678			; rather than polling the display's ready status. As a result the   
6678			; interface only requires 6 simple output lines:  
6678			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6678			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6678			;   LCD DB4 = Microcomputer output port bit 4  
6678			;   LCD DB5 = Microcomputer output port bit 5  
6678			;   LCD DB6 = Microcomputer output port bit 6  
6678			;   LCD DB7 = Microcomputer output port bit 7  
6678			; Display's R/W is connected to 0v so it is always in write mode  
6678			; All 6 connections must be on the same port address <kLCDPrt>  
6678			; This method also allows a decent length of cable from micro to LCD  
6678			;  
6678			; **********************************************************************  
6678			;  
6678			; To include the code for any given function provided by this module,   
6678			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6678			; the parent source file.  
6678			; For example:  #REQUIRES   uHexPrefix  
6678			;  
6678			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6678			; in the parent source file.  
6678			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6678			;  
6678			; These are the function names provided by this module:  
6678			; fLCD_Init                     ;Initialise LCD  
6678			; fLCD_Inst                     ;Send instruction to LCD  
6678			; fLCD_Data                     ;Send data byte to LCD  
6678			; fLCD_Pos                      ;Position cursor  
6678			; fLCD_Str                      ;Display string  
6678			; fLCD_Def                      ;Define custom character  
6678			;  
6678			; **********************************************************************  
6678			;  
6678			; Requires SCMonAPI.asm to also be included in the project  
6678			;  
6678			  
6678			  
6678			; **********************************************************************  
6678			; **  Constants  
6678			; **********************************************************************  
6678			  
6678			; Constants that must be defined externally  
6678			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6678			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6678			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6678			;kLCDWidth: EQU 20             ;Width in characters  
6678			  
6678			; general line offsets in any frame buffer  
6678			  
6678			  
6678			display_row_1: equ 0  
6678			display_row_2: equ display_row_1+display_cols  
6678			display_row_3: equ display_row_2 + display_cols  
6678			display_row_4: equ display_row_3 + display_cols  
6678			;display_row_4_eol:   
6678			  
6678			  
6678			; Cursor position values for the start of each line  
6678			  
6678			; E  
6678			kLCD_Line1: EQU 0x00   
6678			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
6678			; E1  
6678			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
6678			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
6678			  
6678			; Instructions to send as A register to fLCD_Inst  
6678			kLCD_Clear: EQU 00000001b     ;LCD clear  
6678			kLCD_Off:   EQU 00001000b     ;LCD off  
6678			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6678			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6678			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6678			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6678			  
6678			; Constants used by this code module  
6678			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6678			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6678			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6678			  
6678			  
6678			  
6678			; **********************************************************************  
6678			; **  LCD support functions  
6678			; **********************************************************************  
6678			  
6678			; Initialise alphanumeric LCD module  
6678			; LCD control register codes:  
6678			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6678			;   N    0 = 1-line mode       1 = 2-line mode  
6678			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6678			;   D    0 = Display off       1 = Display on  
6678			;   C    0 = Cursor off        1 = Cursor on  
6678			;   B    0 = Blinking off      1 = Blinking on  
6678			;   ID   0 = Decrement mode    1 = Increment mode  
6678			;   SH   0 = Entire shift off  1 = Entire shift on  
6678 3e 28		fLCD_Init:  LD   A, 40  
667a cd 9f 67		            CALL LCDDelay       ;Delay 40ms after power up  
667d			; For reliable reset set 8-bit mode - 3 times  
667d cd 6f 67		            CALL WrFn8bit       ;Function = 8-bit mode  
6680 cd 6f 67		            CALL WrFn8bit       ;Function = 8-bit mode  
6683 cd 6f 67		            CALL WrFn8bit       ;Function = 8-bit mode  
6686			; Set 4-bit mode  
6686 cd 6b 67		            CALL WrFn4bit       ;Function = 4-bit mode  
6689 cd 9d 67		            CALL LCDDelay1      ;Delay 37 us or more  
668c			; Function set  
668c 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
668e cd a1 66		            CALL fLCD_Inst      ;2 line, display on  
6691			; Display On/Off control  
6691 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6693 cd a1 66		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6696			; Display Clear  
6696 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6698 cd a1 66		            CALL fLCD_Inst      ;Clear display  
669b			; Entry mode  
669b 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
669d cd a1 66		            CALL fLCD_Inst      ;Increment mode, shift off  
66a0			; Display module now initialised  
66a0 c9			            RET  
66a1			; ok to here  
66a1			  
66a1			; Write instruction to LCD  
66a1			;   On entry: A = Instruction byte to be written  
66a1			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66a1 f5			fLCD_Inst:  PUSH AF  
66a2 f5			            PUSH AF  
66a3 cd b5 66		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
66a6 f1			            POP  AF  
66a7 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
66a8 17			            RLA  
66a9 17			            RLA  
66aa 17			            RLA  
66ab cd b5 66		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
66ae 3e 02		            LD   A, 2  
66b0 cd 9f 67		            CALL LCDDelay       ;Delay 2 ms to complete   
66b3 f1			            POP  AF  
66b4 c9			            RET  
66b5			Wr4bits:   
66b5 f5					push af  
66b6 3a d7 f8				ld a, (display_lcde1e2)  
66b9 fe 00				cp 0     ; e  
66bb 20 10				jr nz, .wea2	  
66bd f1					pop af  
66be e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
66c0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66c2 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
66c4 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
66c6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66c8 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
66ca d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66cc c9			            RET  
66cd f1			.wea2:		pop af  
66ce e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
66d0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66d2 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
66d4 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
66d6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66d8 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
66da d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66dc c9			            RET  
66dd			  
66dd			  
66dd			; Write data to LCD  
66dd			;   On entry: A = Data byte to be written  
66dd			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66dd f5			fLCD_Data:  PUSH AF  
66de f5			            PUSH AF  
66df cd f1 66		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
66e2 f1			            POP  AF  
66e3 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
66e4 17			            RLA  
66e5 17			            RLA  
66e6 17			            RLA  
66e7 cd f1 66		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
66ea 3e 96		            LD   A, 150  
66ec 3d			Wait:      DEC  A              ;Wait a while to allow data   
66ed 20 fd		            JR   NZ, Wait      ;  write to complete  
66ef f1			            POP  AF  
66f0 c9			            RET  
66f1			Wr4bitsa:     
66f1 f5					push af  
66f2 3a d7 f8				ld a, (display_lcde1e2)  
66f5 fe 00				cp 0     ; e1  
66f7 20 16				jr nz, .we2	  
66f9 f1					pop af  
66fa e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
66fc cb d7		            SET  kLCDBitRS, A  
66fe d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6700 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
6702 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
6704 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6706 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
6708 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
670a cb 97		            RES  kLCDBitRS, A  
670c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
670e c9			            RET  
670f f1			.we2:		pop af  
6710 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6712 cb d7		            SET  kLCDBitRS, A  
6714 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6716 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
6718 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
671a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
671c cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
671e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6720 cb 97		            RES  kLCDBitRS, A  
6722 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6724 c9			            RET  
6725			  
6725			  
6725			; Position cursor to specified location  
6725			;   On entry: A = Cursor position  
6725			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6725 f5			fLCD_Pos:   PUSH AF  
6726					; at this point set the E1 or E2 flag depending on position  
6726			  
6726 c5					push bc  
6727			;		push af  
6727 06 00				ld b, 0  
6729 4f					ld c, a  
672a 3e 4f				ld a, kLCD_Line3-1  
672c b7			 		or a      ;clear carry flag  
672d 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
672e 38 04				jr c, .pe1  
6730			  
6730					; E selection  
6730 cb 80				res 0, b         ; bit 0 unset e  
6732			;		pop af    ; before line 3 so recover orig pos  
6732			;		ld c, a    ; save for poking back  
6732 18 06				jr .peset	          
6734			.pe1:          	; E2 selection  
6734 cb c0				set 0, b         ; bit 0 set e1  
6736 79					ld a, c  
6737 de 4f				sbc a, kLCD_Line3-1  
6739 4f					ld c, a	         ; save caculated offset  
673a			;		pop af     ; bin this original value now we have calculated form  
673a			  
673a			.peset:		; set bit  
673a 78					ld a, b  
673b 32 d7 f8				ld (display_lcde1e2), a 	  
673e 79					ld a, c  
673f c1					pop bc  
6740			  
6740 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6742 cd a1 66		            CALL fLCD_Inst      ;Write instruction to LCD  
6745 f1			            POP  AF  
6746 c9			            RET  
6747			  
6747			  
6747			; Output text string to LCD  
6747			;   On entry: DE = Pointer to null terminated text string  
6747			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6747 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6748 b7			            OR   A              ;Null terminator?  
6749 c8			            RET  Z              ;Yes, so finished  
674a cd dd 66		            CALL fLCD_Data      ;Write character to display  
674d 13			            INC  DE             ;Point to next character  
674e 18 f7		            JR   fLCD_Str       ;Repeat  
6750 c9					ret  
6751			  
6751			; Define custom character  
6751			;   On entry: A = Character number (0 to 7)  
6751			;             DE = Pointer to character bitmap data  
6751			;   On exit:  A = Next character number  
6751			;             DE = Next location following bitmap  
6751			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6751			; Character is   
6751 c5			fLCD_Def:   PUSH BC  
6752 f5			            PUSH AF  
6753 07			            RLCA                ;Calculate location  
6754 07			            RLCA                ;  for bitmap data  
6755 07			            RLCA                ;  = 8 x CharacterNumber  
6756 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6758 cd a1 66		            CALL fLCD_Inst      ;Write instruction to LCD  
675b 06 00		            LD   B, 0  
675d 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
675e cd dd 66		            CALL fLCD_Data      ;Write byte to display  
6761 13			            INC  DE             ;Point to next byte  
6762 04			            INC  B              ;Count bytes  
6763 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6765 28 f6		            JR   Z, Loop       ;No, so repeat  
6767 f1			            POP  AF  
6768 3c			            INC  A              ;Increment character number  
6769 c1			            POP  BC  
676a c9			            RET  
676b			  
676b			  
676b			; **********************************************************************  
676b			; **  Private functions  
676b			; **********************************************************************  
676b			  
676b			; Write function to LCD  
676b			;   On entry: A = Function byte to be written  
676b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
676b 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
676d 18 02		            JR   WrFunc  
676f 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6771 f5			WrFunc:     PUSH AF  
6772 f5					push af  
6773 3a d7 f8				ld a, (display_lcde1e2)  
6776 fe 00				cp 0     ; e1  
6778 20 0f				jr nz, .wfea2	  
677a f1					pop af  
677b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
677d cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
677f cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6781 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6783 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6785 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6787 18 0d			jr .wfskip  
6789 f1			.wfea2:		pop af  
678a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
678c cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
678e cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6790 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6792 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6794 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6796 3e 05		.wfskip:            LD  A, 5  
6798 cd 9f 67		            CALL LCDDelay       ;Delay 5 ms to complete  
679b f1			            POP  AF  
679c c9			            RET  
679d			  
679d			  
679d			; Delay in milliseconds  
679d			;   On entry: A = Number of milliseconds delay  
679d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
679d 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
679f d5			LCDDelay:   PUSH DE  
67a0 5f			            LD   E, A           ;Delay by 'A' ms  
67a1 16 00		            LD   D, 0  
67a3 cd 4e 0a		            CALL aDelayInMS  
67a6 d1			            POP  DE  
67a7 c9			            RET  
67a8			  
67a8			  
67a8			testlcd:  
67a8 3e 00			ld a, kLCD_Line1  
67aa cd 25 67			call fLCD_Pos  
67ad 06 28			ld b, 40  
67af 11 dd 67			ld de, .ttext1  
67b2 cd 70 66			call write_len_string  
67b5			  
67b5 3e 28			ld a, kLCD_Line2  
67b7 cd 25 67			call fLCD_Pos  
67ba 06 28			ld b, 40  
67bc 11 06 68			ld de, .ttext2  
67bf cd 70 66			call write_len_string  
67c2 3e 50			ld a, kLCD_Line3  
67c4 cd 25 67			call fLCD_Pos  
67c7 06 28			ld b, 40  
67c9 11 2f 68			ld de, .ttext3  
67cc cd 70 66			call write_len_string  
67cf 3e 78			ld a, kLCD_Line4  
67d1 cd 25 67			call fLCD_Pos  
67d4 06 28			ld b, 40  
67d6 11 58 68			ld de, .ttext4  
67d9 cd 70 66			call write_len_string  
67dc			  
67dc 76				halt  
67dd			  
67dd			  
67dd .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
6806 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
682f .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
6858 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
6881			   
6881			  
6881			  
6881			; eof  
6881			  
# End of file firmware_lcd_4x40.asm
6881			;include "firmware_lcd_4x20.asm" 
6881			include "firmware_key_5x10.asm" 
6881			; 5 x 10 decade counter scanner  
6881			  
6881			  
6881			; TODO do cursor shape change for shift keys  
6881			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
6881			  
6881			  
6881			; bit mask for each scan column and row for teing the matrix  
6881			  
6881			  
6881			key_init:  
6881			  
6881			; SCMonAPI functions used  
6881			  
6881			; Alphanumeric LCD functions used  
6881			; no need to specify specific functions for this module  
6881			  
6881			  
6881 3e cf		            LD   A, 11001111b  
6883 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6885			;            LD   A, 00000000b  
6885 3e 1f		            LD   A, 00011111b  
6887 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6889			  
6889			  
6889				; TODO Configure cursor shapes  
6889			  
6889				; Load cursor shapes   
6889 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
688b 11 9b 68		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
688e 06 02		            LD   B, 2           ;Number of characters to define  
6890 cd 51 67		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6893 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6895			  
6895 3e 01				ld a, 1  
6897 32 d0 f8			ld (cursor_shape),a  
689a c9				ret  
689b			  
689b			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
689b			; Up to 8 custom characters can be defined  
689b			.cursor_shapes:      
689b			;; Character 0x00 = Normal  
689b 1f			            DB  11111b  
689c 1f			            DB  11111b  
689d 1f			            DB  11111b  
689e 1f			            DB  11111b  
689f 1f			            DB  11111b  
68a0 1f			            DB  11111b  
68a1 1f			            DB  11111b  
68a2 1f			            DB  11111b  
68a3			;; Character 0x01 = Modifier  
68a3 1f			            DB  11111b  
68a4 1b			            DB  11011b  
68a5 1b			            DB  11011b  
68a6 1b			            DB  11011b  
68a7 1b			            DB  11011b  
68a8 1f			            DB  11111b  
68a9 1b			            DB  11011b  
68aa 1f			            DB  11111b  
68ab			  
68ab			  
68ab			  
68ab			  
68ab			; Display custom character 0  
68ab			;            LD   A, kLCD_Line1+14  
68ab			;            CALL fLCD_Pos       ;Position cursor to location in A  
68ab			;            LD   A, 0  
68ab			;            CALL fLCD_Data      ;Write character in A at cursor  
68ab			  
68ab			; Display custom character 1  
68ab			;            LD   A, kLCD_Line2+14  
68ab			;            CALL fLCD_Pos      ;Position cursor to location in A  
68ab			;            LD   A, 1  
68ab			;            CALL fLCD_Data     ;Write character in A at cursor  
68ab			  
68ab			; keyboard scanning   
68ab			  
68ab			; character in from keyboard  
68ab			  
68ab			; mapping for the pcb layout  
68ab			  
68ab			.matrix_to_char:  
68ab .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
68b6 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
68c1 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
68cc 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
68d7 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
68e2			.matrix_to_shift:  
68e2			  
68e2 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
68ed .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
68f8 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
6903 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
690e .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
6919			  
6919			.matrix_to_symbolshift:  
6919			  
6919 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
6924 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
692f 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
693a			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
693a 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
6945 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
6950			  
6950			  
6950			  
6950			; mapping for a simple straight through breadboard layout  
6950			  
6950			;.matrix_to_char:  
6950			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6950			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
6950			;		db "asdfghjkl",KEY_CR,0  
6950			;		db "qwertyuiop",0  
6950			;		 db "1234567890",0  
6950			;.matrix_to_shift:  
6950			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
6950			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
6950			;		db "ASDFGHJKL",KEY_CR,0  
6950			;		db "QWERTYUIOP",0  
6950			;		 db "!",'"',"#$%^&*()",0  
6950			;.matrix_to_symbolshift:  
6950			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6950			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
6950			;		db "_?*fghjk=",KEY_CR,0  
6950			;		db "-/+*[]{}@#",0  
6950			;		 db "1234567890",0  
6950			  
6950			;.matrix_to_char: db "D#0*C987B654A321"  
6950			  
6950			  
6950				  
6950			  
6950			; add cin and cin_wait  
6950			  
6950 cd 61 69		cin_wait: 	call cin  
6953						if DEBUG_KEYCINWAIT  
6953							push af  
6953							  
6953							ld hl,key_repeat_ct  
6953							ld (hl),a  
6953							inc hl  
6953							call hexout  
6953							ld hl,key_repeat_ct+3  
6953							ld a,0  
6953							ld (hl),a  
6953			  
6953							    LD   A, kLCD_Line1+11  
6953							    CALL fLCD_Pos       ;Position cursor to location in A  
6953							    LD   DE, key_repeat_ct  
6953							    ;LD   DE, MsgHello  
6953							    CALL fLCD_Str       ;Display string pointed to by DE  
6953			  
6953			  
6953			  
6953							pop af  
6953						endif  
6953 fe 00			cp 0  
6955 28 f9			jr z, cin_wait   ; block until key press  
6957			  
6957							if DEBUG_KEYCINWAIT  
6957								push af  
6957			  
6957								ld a, 'A'	  
6957								ld hl,key_repeat_ct  
6957								ld (hl),a  
6957								inc hl  
6957								ld a,0  
6957								ld (hl),a  
6957			  
6957								    LD   A, kLCD_Line2+11  
6957								    CALL fLCD_Pos       ;Position cursor to location in A  
6957								    LD   DE, key_repeat_ct  
6957								    ;LD   DE, MsgHello  
6957								    CALL fLCD_Str       ;Display string pointed to by DE  
6957			  
6957							call delay500ms  
6957			  
6957								pop af  
6957							endif  
6957 f5				push af   ; save key pressed  
6958			  
6958			.cin_wait1:	  
6958							if DEBUG_KEYCINWAIT  
6958								push af  
6958			  
6958								ld a, 'b'	  
6958								ld hl,key_repeat_ct  
6958								ld (hl),a  
6958								inc hl  
6958								ld a,0  
6958								ld (hl),a  
6958			  
6958								    LD   A, kLCD_Line2+11  
6958								    CALL fLCD_Pos       ;Position cursor to location in A  
6958								    LD   DE, key_repeat_ct  
6958								    ;LD   DE, MsgHello  
6958								    CALL fLCD_Str       ;Display string pointed to by DE  
6958			  
6958			  
6958							call delay500ms  
6958			  
6958								pop af  
6958							endif  
6958			  
6958 cd 61 69		call cin  
695b fe 00			cp 0  
695d 20 f9			jr nz, .cin_wait1  	; wait for key release  
695f			if DEBUG_KEYCINWAIT  
695f				push af  
695f			  
695f				ld a, '3'	  
695f				ld hl,key_repeat_ct  
695f				ld (hl),a  
695f				inc hl  
695f				ld a,0  
695f				ld (hl),a  
695f			  
695f			            LD   A, kLCD_Line2+11  
695f			            CALL fLCD_Pos       ;Position cursor to location in A  
695f			            LD   DE, key_repeat_ct  
695f			            ;LD   DE, MsgHello  
695f			            CALL fLCD_Str       ;Display string pointed to by DE  
695f			  
695f			  
695f			call delay500ms  
695f			  
695f				pop af  
695f			endif  
695f			  
695f f1				pop af   ; get key  
6960 c9				ret  
6961			  
6961			  
6961 cd 75 69		cin: 	call .mtoc  
6964			  
6964			if DEBUG_KEYCIN  
6964				push af  
6964				  
6964				ld hl,key_repeat_ct  
6964				ld (hl),a  
6964				inc hl  
6964				call hexout  
6964				ld hl,key_repeat_ct+3  
6964				ld a,0  
6964				ld (hl),a  
6964			  
6964			            LD   A, kLCD_Line3+15  
6964			            CALL fLCD_Pos       ;Position cursor to location in A  
6964			            LD   DE, key_repeat_ct  
6964			            ;LD   DE, MsgHello  
6964			            CALL fLCD_Str       ;Display string pointed to by DE  
6964			  
6964			  
6964			call delay500ms  
6964			  
6964				pop af  
6964			endif  
6964			  
6964			  
6964				; no key held  
6964 fe 00			cp 0  
6966 c8				ret z  
6967			  
6967			if DEBUG_KEYCIN  
6967				push af  
6967			  
6967				ld a, '1'	  
6967				ld hl,key_repeat_ct  
6967				ld (hl),a  
6967				inc hl  
6967				ld a,0  
6967				ld (hl),a  
6967			  
6967			            LD   A, kLCD_Line4+15  
6967			            CALL fLCD_Pos       ;Position cursor to location in A  
6967			            LD   DE, key_repeat_ct  
6967			            ;LD   DE, MsgHello  
6967			            CALL fLCD_Str       ;Display string pointed to by DE  
6967			  
6967			  
6967			call delay500ms  
6967			  
6967				pop af  
6967			endif  
6967			  
6967				; stop key bounce  
6967			  
6967 32 88 fb			ld (key_held),a		 ; save it  
696a 47				ld b, a  
696b			  
696b c5			.cina1:	push bc  
696c			if DEBUG_KEYCIN  
696c				push af  
696c			  
696c				ld hl,key_repeat_ct  
696c				inc hl  
696c				call hexout  
696c				ld hl,key_repeat_ct+3  
696c				ld a,0  
696c				ld (hl),a  
696c				ld hl,key_repeat_ct  
696c				ld a, '2'	  
696c				ld (hl),a  
696c			  
696c			            LD   A, kLCD_Line4+15  
696c			            CALL fLCD_Pos       ;Position cursor to location in A  
696c			            LD   DE, key_repeat_ct  
696c			            ;LD   DE, MsgHello  
696c			            CALL fLCD_Str       ;Display string pointed to by DE  
696c			  
696c				pop af  
696c			endif  
696c cd 75 69			call .mtoc  
696f c1				pop bc  
6970 b8				cp b  
6971 28 f8			jr z, .cina1  
6973 78				ld a,b		  
6974			if DEBUG_KEYCIN  
6974				push af  
6974			  
6974				ld hl,key_repeat_ct  
6974				inc hl  
6974				call hexout  
6974				ld hl,key_repeat_ct+3  
6974				ld a,0  
6974				ld (hl),a  
6974				ld hl,key_repeat_ct  
6974				ld a, '3'	  
6974				ld (hl),a  
6974			  
6974			            LD   A, kLCD_Line4+15  
6974			            CALL fLCD_Pos       ;Position cursor to location in A  
6974			            LD   DE, key_repeat_ct  
6974			            ;LD   DE, MsgHello  
6974			            CALL fLCD_Str       ;Display string pointed to by DE  
6974			  
6974				pop af  
6974			endif  
6974 c9				ret  
6975			  
6975			; detect keyboard modifier key press and apply new overlay to the face key held  
6975			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6975			  
6975			;.cin_map_modifier:   
6975			;	ld a, (hl)  
6975			;	and 255  
6975			;	ret NZ		; modifier key not flagged  
6975			;  
6975			;	; get key face  
6975			;  
6975			;	ld b,(key_face_held)  
6975			;  
6975			;	ld b, key_cols * key_rows  
6975			;  
6975			;	push de  
6975			;	pop hl  
6975			;  
6975			;.mmod1: ld a,(hl)   ; get map test  
6975			;	cp b  
6975			;	jr z, .mmod2  
6975			;  
6975			;  
6975			;  
6975			;.mmod2: inc hl    ;   
6975			;  
6975			;	  
6975			;  
6975			;	  
6975			;  
6975			;	ld hl,key_actual_pressed  
6975			;	ld (hl),a,  
6975			;	ret  
6975			  
6975			; map matrix key held to char on face of key  
6975			  
6975			.mtoc:  
6975			  
6975			; test decade counter strobes  
6975			  
6975			;.decadetest1:  
6975			  
6975			; reset counter  
6975			;ld a, 128  
6975			;out (portbdata),a  
6975			  
6975			  
6975			;ld b, 5  
6975			;.dec1:  
6975			;ld a, 0  
6975			;out (portbdata),a  
6975			;call delay1s  
6975			  
6975			;ld a, 32  
6975			;out (portbdata),a  
6975			;call delay1s  
6975			;call delay1s  
6975			;call delay1s  
6975			;  
6975			;ld a, 64+32  
6975			;out (portbdata),a  
6975			;call delay1s  
6975			;;djnz .dec1  
6975			;  
6975			;jp .decadetest1  
6975			  
6975			  
6975			  
6975			  
6975			  
6975			  
6975			  
6975			  
6975			  
6975			  
6975				; scan keyboard matrix and generate raw scan map  
6975 cd 08 6a			call matrix  
6978			  
6978				; reuse c bit 0 left modifer button - ie shift  
6978			        ; reuse c bit 1 for right modifer button - ie symbol shift  
6978				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
6978			  
6978 0e 00			ld c, 0  
697a			  
697a				; TODO set flags for modifer key presses   
697a				; TODO do a search for modifer key...  
697a			  
697a				;ld hl,keyscan_table_row4  
697a 21 e7 fb			ld hl,keyscan_table_row2  
697d			  
697d 7e				ld a, (hl)  
697e fe 23			cp '#'  
6980 20 07			jr nz, .nextmodcheck  
6982 cb c1			set 0, c  
6984 21 e2 68			ld hl, .matrix_to_shift  
6987 18 21			jr .dokeymap  
6989				; TODO for now igonre  
6989			.nextmodcheck:  
6989 21 dc fb			ld hl,keyscan_table_row3  
698c			  
698c 7e				ld a, (hl)  
698d fe 23			cp '#'  
698f 20 07			jr nz, .nextmodcheck2  
6991 cb c9			set 1, c   
6993 21 19 69			ld hl, .matrix_to_symbolshift  
6996 18 12			jr .dokeymap  
6998			.nextmodcheck2:  
6998 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
699b			  
699b 7e				ld a, (hl)  
699c fe 23			cp '#'  
699e 20 07			jr nz, .donemodcheck  
69a0 cb c9			set 1, c   
69a2 21 e2 68			ld hl, .matrix_to_shift  
69a5 18 03			jr .dokeymap  
69a7			  
69a7				; no modifer found so just map to normal keys  
69a7				; get mtoc map matrix to respective keys  
69a7			;	ld hl, .matrix_to_char  
69a7			;	ld hl, .matrix_to_char  
69a7			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
69a7			;	ld a, KEY_SHIFT  
69a7			;	call findchar  
69a7			;  
69a7			;	; got offset to key modifer in b  
69a7			;  
69a7			;	ld hl,keyscan_table_row5  
69a7			;  
69a7			;	ld a,b  
69a7			;	call addatohl  
69a7			;	ld a,(hl)  
69a7			;  
69a7			;	cp '#'  
69a7			;	jr nz, .nextmodcheck  
69a7			;	set 0, c  
69a7			;	ld hl, .matrix_to_char  
69a7			;	jr .dokeymap  
69a7			;	; TODO for now igonre  
69a7			;.nextmodcheck:  
69a7			;	ld hl, .matrix_to_symbolshift  
69a7			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
69a7			;	ld a, KEY_SYMBOLSHIFT  
69a7			;	call findchar  
69a7			;  
69a7			;  
69a7			;	; got offset to key modifer in b  
69a7			;  
69a7			;	ld hl,keyscan_table_row5  
69a7			;  
69a7			;	ld a,b  
69a7			;	call addatohl  
69a7			;	ld a,(hl)  
69a7			;  
69a7			;	cp '#'  
69a7			;	jr nz, .donemodcheck  
69a7			;	set 1, c   
69a7			;	ld hl, .matrix_to_symbolshift  
69a7			;	jr .dokeymap  
69a7			  
69a7			  
69a7			  
69a7			.donemodcheck:  
69a7				; no modifer found so just map to normal keys  
69a7				; get mtoc map matrix to respective keys  
69a7 21 ab 68			ld hl, .matrix_to_char  
69aa			  
69aa			.dokeymap:  
69aa				;ld (key_fa), c   
69aa cd c3 69			call .mapkeys  
69ad			  
69ad			  
69ad			if DEBUG_KEY  
69ad			  
69ad			; Display text on first line  
69ad			            LD   A, kLCD_Line1  
69ad			            CALL fLCD_Pos       ;Position cursor to location in A  
69ad			            LD   DE, keyscan_table_row1  
69ad			            ;LD   DE, MsgHello  
69ad			            CALL fLCD_Str       ;Display string pointed to by DE  
69ad			  
69ad			; Display text on second line  
69ad			            LD   A, kLCD_Line2  
69ad			            CALL fLCD_Pos       ;Position cursor to location in A  
69ad			            LD   DE, keyscan_table_row2  
69ad			            CALL fLCD_Str       ;Display string pointed to by DE  
69ad			            LD   A, kLCD_Line3  
69ad			            CALL fLCD_Pos       ;Position cursor to location in A  
69ad			            LD   DE, keyscan_table_row3  
69ad			            CALL fLCD_Str       ;Display string pointed to by DE  
69ad			            LD   A, kLCD_Line4  
69ad			            CALL fLCD_Pos       ;Position cursor to location in A  
69ad			            LD   DE, keyscan_table_row4  
69ad			            CALL fLCD_Str       ;Display string pointed to by DE  
69ad			            LD   A, kLCD_Line1+10  
69ad			            CALL fLCD_Pos       ;Position cursor to location in A  
69ad			            LD   DE, keyscan_table_row5  
69ad			            CALL fLCD_Str       ;Display string pointed to by DE  
69ad			  
69ad				;call delay250ms  
69ad			endif  
69ad			;	jp testkey  
69ad			  
69ad			; get first char reported  
69ad			  
69ad 21 c6 fb			ld hl,keyscan_table_row5  
69b0			  
69b0				;ld b, 46   ; 30 keys to remap + 8 nulls   
69b0 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
69b2			.findkey:  
69b2 7e				ld a,(hl)  
69b3 fe 00			cp 0  
69b5 28 04			jr z, .nextkey  
69b7 fe 7e			cp KEY_MATRIX_NO_PRESS  
69b9 20 06			jr nz, .foundkey  
69bb			.nextkey:  
69bb 23				inc hl  
69bc 10 f4			djnz .findkey  
69be 3e 00			ld a,0  
69c0 c9				ret  
69c1			.foundkey:  
69c1 7e				ld a,(hl)  
69c2 c9				ret  
69c3				  
69c3			  
69c3			; convert the raw key map given hl for destination key  
69c3			.mapkeys:  
69c3 11 c6 fb			ld de,keyscan_table_row5  
69c6			  
69c6 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
69c8			.remap:  
69c8 1a				ld a,(de)  
69c9 fe 23			cp '#'  
69cb 20 02			jr nz, .remapnext  
69cd				;CALLMONITOR  
69cd 7e				ld a,(hl)  
69ce 12				ld (de),a  
69cf			  
69cf			  
69cf			  
69cf			.remapnext:  
69cf 23				inc hl  
69d0 13				inc de  
69d1 10 f5			djnz .remap  
69d3				  
69d3 c9				ret  
69d4			  
69d4			  
69d4			  
69d4			.mtocold2:  
69d4			  
69d4			;	; flag if key D is held down and remove from reporting  
69d4			;	ld bc, .key_map_fd    
69d4			;	ld hl, keyscan_table  
69d4			;	ld de, key_fd  
69d4			;	call .key_shift_hold  
69d4			;	cp 255  
69d4			;	jr z, .cinmap  
69d4			;	; flag if key C is held down and remove from reporting  
69d4			;	ld bc, .key_map_fc    
69d4			;	ld hl, keyscan_table+key_cols  
69d4			;	ld de, key_fc  
69d4			;	call .key_shift_hold  
69d4			;	cp 255  
69d4			;	jr z, .cinmap  
69d4			;	; flag if key B is held down and remove from reporting  
69d4			;	ld bc, .key_map_fb    
69d4			;	ld hl, keyscan_table+(key_cols*2)  
69d4			;	ld de, key_fb  
69d4			;	call .key_shift_hold  
69d4			;	cp 255  
69d4			;	jr z, .cinmap  
69d4			;	; flag if key A is held down and remove from reporting  
69d4			;	ld bc, .key_map_fa    
69d4			;	ld hl, keyscan_table+(key_cols*3)  
69d4			;	ld de, key_fa  
69d4			;	call .key_shift_hold  
69d4			;	cp 255  
69d4			;	jr z, .cinmap  
69d4			  
69d4 11 ab 68			ld de, .matrix_to_char  
69d7			  
69d7			  
69d7			.cinmap1:   
69d7				if DEBUG_KEY  
69d7			            LD   A, kLCD_Line4  
69d7			            CALL fLCD_Pos       ;Position cursor to location in A  
69d7					push de  
69d7			            LD   DE, keyscan_table  
69d7			            CALL fLCD_Str       ;Display string pointed to by DE  
69d7					pop de  
69d7				endif  
69d7			  
69d7				; scan key matrix table for any held key  
69d7			  
69d7				; de holds either the default matrix or one selected above  
69d7			  
69d7 21 93 fb			ld hl, keyscan_table  
69da 06 32			ld b,key_cols*key_rows  
69dc			  
69dc 7e			.cin11:	ld a,(hl)  
69dd fe 23			cp '#'  
69df 28 08			jr z, .cinhit1  
69e1 23				inc hl  
69e2 13				inc de  
69e3 05				dec b  
69e4 20 f6			jr nz, .cin11  
69e6				; no key found held  
69e6 3e 00			ld a,0  
69e8 c9				ret  
69e9 d5			.cinhit1: push de  
69ea e1				pop hl  
69eb 7e				ld a,(hl)  
69ec c9				ret  
69ed			  
69ed			; flag a control key is held   
69ed			; hl is key pin, de is flag indicator  
69ed			  
69ed			.key_shift_hold1:  
69ed c5				push bc  
69ee 3e 01			ld a, 1  
69f0 32 d0 f8			ld (cursor_shape),a  
69f3 06 00			ld b, 0  
69f5 7e				ld a, (hl)  
69f6 fe 2e			cp '.'  
69f8 28 0a			jr z, .key_shift11  
69fa 06 ff			ld b, 255  
69fc 3e 2b			ld a, '+'    ; hide key from later scans  
69fe 77				ld (hl),a  
69ff 3e 02			ld a, 2  
6a01 32 d0 f8			ld (cursor_shape),a  
6a04			.key_shift11:  
6a04				; write flag indicator  
6a04 78				ld a,b  
6a05 12				ld (de),a  
6a06			  
6a06 d1				pop de    ; de now holds the key map ptr  
6a07 c9				ret  
6a08			  
6a08				  
6a08			  
6a08			; scans keyboard matrix and flags key press in memory array	  
6a08				  
6a08			matrix:  
6a08				;call matrix  
6a08				; TODO optimise the code....  
6a08			  
6a08			  
6a08			;ld hl, keyscan_table_row1  
6a08			;ld de, keyscan_table_row1+1  
6a08			;ld bc,46  
6a08			;ld a,KEY_MATRIX_NO_PRESS  
6a08			;ldir  
6a08			  
6a08			  
6a08			  
6a08			; reset counter  
6a08 3e 80		ld a, 128  
6a0a d3 c1		out (portbdata),a  
6a0c			  
6a0c 06 0a		ld b, 10  
6a0e 0e 00		ld c, 0       ; current clock toggle  
6a10			  
6a10			.colscan:  
6a10			  
6a10			; set current column  
6a10			; disable clock enable and set clock low  
6a10			  
6a10			;ld a, 0  
6a10			;out (portbdata),a  
6a10			  
6a10			; For each column scan for switches  
6a10			  
6a10 c5			push bc  
6a11 21 89 fb		ld hl, keyscan_scancol  
6a14 cd 1d 6b		call .rowscan  
6a17 c1			pop bc  
6a18			  
6a18			  
6a18			; get back current column  
6a18			  
6a18			; translate the row scan  
6a18			  
6a18			;   
6a18			; row 1  
6a18			  
6a18 78			ld a,b  
6a19			  
6a19 21 fc fb		LD   hl, keyscan_table_row1+10  
6a1c			  
6a1c cd 32 0d		call subafromhl  
6a1f			;call addatohl  
6a1f			  
6a1f 11 89 fb		ld de, keyscan_scancol  
6a22			  
6a22 1a			ld a,(de)  
6a23 77			ld (hl),a  
6a24			  
6a24			  
6a24			  
6a24			  
6a24			; row 2  
6a24			  
6a24 78			ld a,b  
6a25			  
6a25 21 f1 fb		LD   hl, keyscan_table_row2+10  
6a28			  
6a28			;call addatohl  
6a28 cd 32 0d		call subafromhl  
6a2b			  
6a2b			  
6a2b 11 8a fb		ld de, keyscan_scancol+1  
6a2e			  
6a2e 1a			ld a,(de)  
6a2f 77			ld (hl),a  
6a30			  
6a30			  
6a30			; row 3  
6a30			  
6a30 78			ld a,b  
6a31			  
6a31 21 e6 fb		LD   hl, keyscan_table_row3+10  
6a34			  
6a34			;call addatohl  
6a34 cd 32 0d		call subafromhl  
6a37			  
6a37 11 8b fb		ld de, keyscan_scancol+2  
6a3a			  
6a3a 1a			ld a,(de)  
6a3b 77			ld (hl),a  
6a3c			  
6a3c			  
6a3c			  
6a3c			; row 4  
6a3c			  
6a3c 78			ld a,b  
6a3d			  
6a3d 21 db fb		LD   hl, keyscan_table_row4+10  
6a40			  
6a40			;call addatohl  
6a40 cd 32 0d		call subafromhl  
6a43			  
6a43 11 8c fb		ld de, keyscan_scancol+3  
6a46			  
6a46 1a			ld a,(de)  
6a47 77			ld (hl),a  
6a48			  
6a48			; row 5  
6a48			  
6a48 78			ld a,b  
6a49			  
6a49 21 d0 fb		LD   hl, keyscan_table_row5+10  
6a4c			  
6a4c			;call addatohl  
6a4c cd 32 0d		call subafromhl  
6a4f			  
6a4f 11 8d fb		ld de, keyscan_scancol+4  
6a52			  
6a52 1a			ld a,(de)  
6a53 77			ld (hl),a  
6a54			  
6a54			; handshake next column  
6a54			  
6a54			  
6a54 3e 40		ld a, 64  
6a56 d3 c1		out (portbdata),a  
6a58			  
6a58 3e 00		ld a, 0  
6a5a d3 c1		out (portbdata),a  
6a5c			  
6a5c			; toggle clk and move to next column  
6a5c			;ld a, 64  
6a5c			;cp c  
6a5c			;  
6a5c			;jr z, .coltoglow  
6a5c			;ld c, a  
6a5c			;jr .coltog  
6a5c			;.coltoglow:  
6a5c			;ld c, 0  
6a5c			;.coltog:  
6a5c			;ld a, c  
6a5c			;out (portbdata),a  
6a5c			  
6a5c 10 b2		djnz .colscan  
6a5e			  
6a5e 3e 0a		ld a,10  
6a60 21 f2 fb		LD   hl, keyscan_table_row1  
6a63 cd 20 0d		call addatohl  
6a66 3e 00		ld a, 0  
6a68 77			ld (hl), a  
6a69			  
6a69			  
6a69 3e 0a		ld a,10  
6a6b 21 e7 fb		LD   hl, keyscan_table_row2  
6a6e cd 20 0d		call addatohl  
6a71 3e 00		ld a, 0  
6a73 77			ld (hl), a  
6a74			  
6a74 3e 0a		ld a,10  
6a76 21 dc fb		LD   hl, keyscan_table_row3  
6a79 cd 20 0d		call addatohl  
6a7c 3e 00		ld a, 0  
6a7e 77			ld (hl), a  
6a7f			  
6a7f 3e 0a		ld a,10  
6a81 21 d1 fb		LD   hl, keyscan_table_row4  
6a84 cd 20 0d		call addatohl  
6a87 3e 00		ld a, 0  
6a89 77			ld (hl), a  
6a8a			  
6a8a 3e 0a		ld a,10  
6a8c 21 c6 fb		LD   hl, keyscan_table_row5  
6a8f cd 20 0d		call addatohl  
6a92 3e 00		ld a, 0  
6a94 77			ld (hl), a  
6a95			  
6a95			if DEBUG_KEY_MATRIX  
6a95			  
6a95			; Display text on first line  
6a95			            LD   A, kLCD_Line1  
6a95			            CALL fLCD_Pos       ;Position cursor to location in A  
6a95			            LD   DE, keyscan_table_row1  
6a95			            ;LD   DE, MsgHello  
6a95			            CALL fLCD_Str       ;Display string pointed to by DE  
6a95			  
6a95			; Display text on second line  
6a95			            LD   A, kLCD_Line2  
6a95			            CALL fLCD_Pos       ;Position cursor to location in A  
6a95			            LD   DE, keyscan_table_row2  
6a95			            CALL fLCD_Str       ;Display string pointed to by DE  
6a95			            LD   A, kLCD_Line3  
6a95			            CALL fLCD_Pos       ;Position cursor to location in A  
6a95			            LD   DE, keyscan_table_row3  
6a95			            CALL fLCD_Str       ;Display string pointed to by DE  
6a95			            LD   A, kLCD_Line4  
6a95			            CALL fLCD_Pos       ;Position cursor to location in A  
6a95			            LD   DE, keyscan_table_row4  
6a95			            CALL fLCD_Str       ;Display string pointed to by DE  
6a95			            LD   A, kLCD_Line4+10  
6a95			            CALL fLCD_Pos       ;Position cursor to location in A  
6a95			            LD   DE, keyscan_table_row5  
6a95			            CALL fLCD_Str       ;Display string pointed to by DE  
6a95			  
6a95			;call delay250ms  
6a95				jp matrix  
6a95			endif  
6a95 c9			ret  
6a96			  
6a96			; using decade counter....  
6a96			  
6a96			  
6a96			; TODO reset decade counter to start of scan  
6a96			  
6a96			; reset 15  
6a96			; clock 14  
6a96			; ce 13  
6a96			  
6a96			; 1 - q5  
6a96			; 2 - q1  
6a96			; 3 - q0  
6a96			; 4 - q2  
6a96			; 5 - q6  
6a96			; 6 - q7  
6a96			; 7 - q3  
6a96			; 8 - vss  
6a96			; 9 - q8  
6a96			; 10 - q4  
6a96			; 11 - q9  
6a96			; 12 - cout  
6a96			; 16 - vdd  
6a96			  
6a96			; clock      ce       reset     output  
6a96			; 0          x        0         n  
6a96			; x          1        0         n  
6a96			; x          x        1         q0  
6a96			; rising     0        0         n+1  
6a96			; falling    x        0         n  
6a96			; x          rising   0         n  
6a96			; 1          falling  0         x+1  
6a96			;  
6a96			; x = dont care, if n < 5 carry = 1 otherwise 0  
6a96			  
6a96			;   
6a96			; reset   
6a96			; 13=0, 14=0, 15=1 .. 15=0  
6a96			;  
6a96			; handshake line  
6a96			; 14=1.... read line 14=0  
6a96			  
6a96			  
6a96			  
6a96			  
6a96			  
6a96			; TODO hand shake clock for next column scan  
6a96			; TODO detect each row  
6a96			  
6a96			  
6a96			  
6a96			  
6a96			; reset 128  
6a96			; clock 64  
6a96			; ce 32  
6a96			  
6a96			  
6a96			.cyclestart:  
6a96			  
6a96			; reset counter  
6a96 3e 80		ld a, 128  
6a98 d3 c1		out (portbdata),a  
6a9a			  
6a9a			; loop leds  
6a9a 06 0a		ld b,10  
6a9c			  
6a9c			.cycle1:  
6a9c c5			push bc  
6a9d 3e 00		ld a, 0  
6a9f d3 c1		out (portbdata),a  
6aa1 cd 5d 0a		call delay250ms  
6aa4			  
6aa4 3e 40		ld a, 64  
6aa6 d3 c1		out (portbdata),a  
6aa8 cd 5d 0a		call delay250ms  
6aab			  
6aab 3e 00		ld a, 0  
6aad d3 c1		out (portbdata),a  
6aaf cd 5d 0a		call delay250ms  
6ab2			  
6ab2 c1			pop bc  
6ab3 10 e7		djnz .cycle1  
6ab5			  
6ab5			  
6ab5 18 df		jr .cyclestart  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			; map matrix key held to char on face of key  
6ab7			  
6ab7			;.mtocold:  
6ab7			;  
6ab7			;  
6ab7			;; reset counter  
6ab7			;ld a, 128  
6ab7			;out (portbdata),a  
6ab7			;  
6ab7			;  
6ab7			;; scan keyboard row 1  
6ab7			;ld a, 0  
6ab7			;out (portbdata),a  
6ab7			;;ld a, 64  
6ab7			;;out (portbdata),a  
6ab7			;  
6ab7			;  
6ab7			;	ld a, 128  
6ab7			;	ld hl, keyscan_table  
6ab7			;	call .rowscan  
6ab7			;  
6ab7			;;ld a, 0  
6ab7			;;out (portbdata),a  
6ab7			;ld a, 64  
6ab7			;out (portbdata),a  
6ab7			;  
6ab7			;	ld a, 64  
6ab7			;	ld hl, keyscan_table+key_cols  
6ab7			;	call .rowscan  
6ab7			;  
6ab7			;ld a, 0  
6ab7			;out (portbdata),a  
6ab7			;;ld a, 64  
6ab7			;;out (portbdata),a  
6ab7			;	ld a, 32  
6ab7			;	ld hl, keyscan_table+(key_cols*2)  
6ab7			;	call .rowscan  
6ab7			;  
6ab7			;  
6ab7			;;ld a, 0  
6ab7			;;out (portbdata),a  
6ab7			;ld a, 64  
6ab7			;out (portbdata),a  
6ab7			;  
6ab7			;	ld a, 16  
6ab7			;	ld hl, keyscan_table+(key_cols*3)  
6ab7			;	call .rowscan  
6ab7			;  
6ab7			;  
6ab7			;	; flag if key D is held down and remove from reporting  
6ab7			;	ld bc, .key_map_fd    
6ab7			;	ld hl, keyscan_table  
6ab7			;	ld de, key_fd  
6ab7			;	call .key_shift_hold  
6ab7			;	cp 255  
6ab7			;	jr z, .cinmap  
6ab7			;	; flag if key C is held down and remove from reporting  
6ab7			;	ld bc, .key_map_fc    
6ab7			;	ld hl, keyscan_table+key_cols  
6ab7			;	ld de, key_fc  
6ab7			;	call .key_shift_hold  
6ab7			;	cp 255  
6ab7			;	jr z, .cinmap  
6ab7			;	; flag if key B is held down and remove from reporting  
6ab7			;	ld bc, .key_map_fb    
6ab7			;	ld hl, keyscan_table+(key_cols*2)  
6ab7			;	ld de, key_fb  
6ab7			;	call .key_shift_hold  
6ab7			;	cp 255  
6ab7			;	jr z, .cinmap  
6ab7			;	; flag if key A is held down and remove from reporting  
6ab7			;	ld bc, .key_map_fa    
6ab7			;	ld hl, keyscan_table+(key_cols*3)  
6ab7			;	ld de, key_fa  
6ab7			;	call .key_shift_hold  
6ab7			;	cp 255  
6ab7			;	jr z, .cinmap  
6ab7			;  
6ab7			;	ld de, .matrix_to_char  
6ab7			;  
6ab7			;  
6ab7			;.cinmap:   
6ab7			;	if DEBUG_KEY  
6ab7			;            LD   A, kLCD_Line4  
6ab7			;            CALL fLCD_Pos       ;Position cursor to location in A  
6ab7			;		push de  
6ab7			;            LD   DE, keyscan_table  
6ab7			;            CALL fLCD_Str       ;Display string pointed to by DE  
6ab7			;		pop de  
6ab7			;	endif  
6ab7			  
6ab7				; scan key matrix table for any held key  
6ab7			  
6ab7				; de holds either the default matrix or one selected above  
6ab7			  
6ab7			;	ld hl, keyscan_table  
6ab7			;	ld b,key_cols*key_rows  
6ab7			;  
6ab7			;.cin1:	ld a,(hl)  
6ab7			;	cp '#'  
6ab7			;	jr z, .cinhit  
6ab7			;	inc hl  
6ab7			;	inc de  
6ab7			;	dec b  
6ab7			;	jr nz, .cin1  
6ab7			;	; no key found held  
6ab7			;	ld a,0  
6ab7			;	ret  
6ab7			;.cinhit: push de  
6ab7			;	pop hl  
6ab7			;	ld a,(hl)  
6ab7			;	ret  
6ab7			  
6ab7			; flag a control key is held   
6ab7			; hl is key pin, de is flag indicator  
6ab7			  
6ab7			;.key_shift_hold:  
6ab7			;	push bc  
6ab7			;	ld a, 1  
6ab7			;	ld (cursor_shape),a  
6ab7			;	ld b, 0  
6ab7			;	ld a, (hl)  
6ab7			;	cp '.'  
6ab7			;	jr z, .key_shift1  
6ab7			;	ld b, 255  
6ab7			;	ld a, '+'    ; hide key from later scans  
6ab7			;	ld (hl),a  
6ab7			;	ld a, 2  
6ab7			;	ld (cursor_shape),a  
6ab7			;.key_shift1:  
6ab7			;	; write flag indicator  
6ab7			;	ld a,b  
6ab7			;	ld (de),a  
6ab7			;  
6ab7			;	pop de    ; de now holds the key map ptr  
6ab7			;	ret  
6ab7			  
6ab7				  
6ab7				  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			;	push hl  
6ab7			;	push de  
6ab7			;	push bc  
6ab7			;	call keyscan  
6ab7			;	; map key matrix to ascii value of key face  
6ab7			;  
6ab7			;	ld hl, key_face_map  
6ab7			;	ld de, keyscan_table  
6ab7			;  
6ab7			;	; get how many keys to look at  
6ab7			;	ld b, keyscan_table_len  
6ab7			;	  
6ab7			;  
6ab7			;	; at this stage fall out on first key hit  
6ab7			;	; TODO handle multiple key press  
6ab7			;  
6ab7			;map1:	ld a,(hl)  
6ab7			;	cp '#'  
6ab7			;	jr z, keyhit  
6ab7			;	inc hl  
6ab7			;	inc de  
6ab7			;	dec b  
6ab7			;	jr nz, map1  
6ab7			;nohit:	ld a, 0  
6ab7			;	jr keydone  
6ab7			;keyhit: push de  
6ab7			;	pop hl  
6ab7			;	ld a,(hl)  
6ab7			;keydone:  
6ab7			;	push bc  
6ab7			;	push de  
6ab7			; 	push hl  
6ab7			;	ret   
6ab7			;  
6ab7			  
6ab7			  
6ab7			  
6ab7			  
6ab7			; scan physical key matrix  
6ab7			  
6ab7			  
6ab7			;keyscan:  
6ab7			;  
6ab7			;; for each key_row use keyscanr bit mask for out  
6ab7			;; then read in for keyscanc bitmask  
6ab7			;; save result of row scan to keyscantable  
6ab7			;  
6ab7			;; scan keyboard row 1  
6ab7			;  
6ab7			;	ld b, key_rows  
6ab7			;	ld hl, key_scanr  
6ab7			;	ld de, keyscan_table  
6ab7			;  
6ab7			;rowloop:  
6ab7			;  
6ab7			;	ld a,(hl)		; out bit mask to energise keyboard row  
6ab7			;	call rowscan  
6ab7			;	inc hl  
6ab7			;	dec b  
6ab7			;	jr nz, rowloop  
6ab7			;  
6ab7			;	ret  
6ab7			;  
6ab7			;  
6ab7			;; pass a out bitmask, b row number  
6ab7			;arowscan:   
6ab7			;	push bc  
6ab7			;  
6ab7			;	ld d, b  
6ab7			;  
6ab7			;	; calculate buffer location for this row  
6ab7			;  
6ab7			;	ld hl, keyscan_table	  
6ab7			;kbufr:  ld e, key_cols  
6ab7			;kbufc:	inc hl  
6ab7			;	dec e  
6ab7			;	jr nz, kbufc  
6ab7			;	dec d  
6ab7			;	jr nz, kbufr  
6ab7			;  
6ab7			;	; energise row and read columns  
6ab7			;  
6ab7			;	out (portbdata),a  
6ab7			;	in a,(portbdata)  
6ab7			;	ld c,a  
6ab7			;  
6ab7			;  
6ab7			;	; save buffer loc  
6ab7			;  
6ab7			;	ld (keybufptr), hl  
6ab7			;  
6ab7			;	ld hl, key_scanc  
6ab7			;	ld d, key_cols  
6ab7			;  
6ab7			;	; for each column check each bit mask  
6ab7			;  
6ab7			;colloop:  
6ab7			;	  
6ab7			;  
6ab7			;	; reset flags for the row   
6ab7			;  
6ab7			;	ld b,'.'  
6ab7			;	and (hl)  
6ab7			;	jr z, maskskip  
6ab7			;	ld b,'#'  
6ab7			;maskskip:  
6ab7			;	; save  key state  
6ab7			;	push hl  
6ab7			;	ld hl, (keybufptr)  
6ab7			;	ld (hl), b  
6ab7			;	inc hl  
6ab7			;	ld (keybufptr), hl  
6ab7			;  
6ab7			;	; move to next bit mask  
6ab7			;	pop hl  
6ab7			;	inc hl  
6ab7			;  
6ab7			;	dec d  
6ab7			;	jr nz, colloop  
6ab7			;  
6ab7			;	ret  
6ab7			;  
6ab7			;  
6ab7			;;  
6ab7			; lcd functions  
6ab7			;  
6ab7			;  
6ab7			  
6ab7			;if DEBUG_KEY_MATRIX  
6ab7			  
6ab7			; test function to display hardware view of matrix state  
6ab7			  
6ab7			matrixold:  
6ab7			  
6ab7			  
6ab7			  
6ab7			; reset counter  
6ab7 3e 80		ld a, 128  
6ab9 d3 c1		out (portbdata),a  
6abb			; scan keyboard row 1  
6abb 3e 00		ld a, 0  
6abd d3 c1		out (portbdata),a  
6abf			;ld a, 64  
6abf			;out (portbdata),a  
6abf 3e 80			ld a, 128  
6ac1 21 f2 fb			ld hl, keyscan_table_row1  
6ac4 cd 1d 6b			call .rowscan  
6ac7			  
6ac7			;ld a, 0  
6ac7			;out (portbdata),a  
6ac7 3e 40		ld a, 64  
6ac9 d3 c1		out (portbdata),a  
6acb 3e 40			ld a, 64  
6acd 21 e7 fb			ld hl, keyscan_table_row2  
6ad0 cd 1d 6b			call .rowscan  
6ad3			  
6ad3 3e 00		ld a, 0  
6ad5 d3 c1		out (portbdata),a  
6ad7			;ld a, 64  
6ad7			;out (portbdata),a  
6ad7 3e 20			ld a, 32  
6ad9 21 dc fb			ld hl, keyscan_table_row3  
6adc cd 1d 6b			call .rowscan  
6adf			  
6adf			;ld a, 0  
6adf			;out (portbdata),a  
6adf 3e 40		ld a, 64  
6ae1 d3 c1		out (portbdata),a  
6ae3 3e 10			ld a, 16  
6ae5 21 d1 fb			ld hl, keyscan_table_row4  
6ae8 cd 1d 6b			call .rowscan  
6aeb			  
6aeb			; Display text on first line  
6aeb 3e 00		            LD   A, kLCD_Line1  
6aed cd 25 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6af0 11 f2 fb		            LD   DE, keyscan_table_row1  
6af3			            ;LD   DE, MsgHello  
6af3 cd 47 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6af6			  
6af6			; Display text on second line  
6af6 3e 28		            LD   A, kLCD_Line2  
6af8 cd 25 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6afb 11 e7 fb		            LD   DE, keyscan_table_row2  
6afe cd 47 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6b01 3e 50		            LD   A, kLCD_Line3  
6b03 cd 25 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6b06 11 dc fb		            LD   DE, keyscan_table_row3  
6b09 cd 47 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6b0c 3e 78		            LD   A, kLCD_Line4  
6b0e cd 25 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6b11 11 d1 fb		            LD   DE, keyscan_table_row4  
6b14 cd 47 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6b17			  
6b17 cd 5d 0a			call delay250ms  
6b1a c3 08 6a			jp matrix  
6b1d			  
6b1d			; pass de as row display flags  
6b1d			.rowscan:   
6b1d			;	out (portbdata),a  
6b1d db c1			in a,(portbdata)  
6b1f 4f				ld c,a  
6b20				; reset flags for the row   
6b20 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b22 e6 01			and 1  
6b24 28 02			jr z, .p1on  
6b26 06 23			ld b,'#'  
6b28			.p1on:  
6b28 70				ld (hl), b  
6b29 23				inc hl  
6b2a			  
6b2a 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b2c 79				ld a,c  
6b2d e6 02			and 2  
6b2f			;	bit 0,a  
6b2f 28 02			jr z, .p2on  
6b31 06 23			ld b,'#'  
6b33			.p2on:  
6b33 70				ld (hl), b  
6b34 23				inc hl  
6b35			;  
6b35 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b37 79				ld a,c  
6b38 e6 04			and 4  
6b3a			;;	bit 0,a  
6b3a 28 02			jr z, .p3on  
6b3c 06 23			ld b,'#'  
6b3e			.p3on:  
6b3e 70				ld (hl), b  
6b3f 23				inc hl  
6b40			;;  
6b40 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b42			;;	bit 0,a  
6b42 79				ld a,c  
6b43 e6 08			and 8  
6b45 28 02			jr z, .p4on  
6b47 06 23			ld b,'#'  
6b49			.p4on:  
6b49 70				ld (hl), b  
6b4a 23				inc hl  
6b4b			  
6b4b 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b4d			;;	bit 0,a  
6b4d 79				ld a,c  
6b4e e6 10			and 16  
6b50 28 02			jr z, .p5on  
6b52 06 23			ld b,'#'  
6b54			.p5on:  
6b54 70				ld (hl), b  
6b55 23				inc hl  
6b56			; zero term  
6b56 06 00			ld b,0  
6b58 70				ld (hl), b  
6b59			  
6b59 c9			.rscandone: ret  
6b5a			  
6b5a			;addatohl:  
6b5a			;  
6b5a			 ;add   a, l    ; A = A+L  
6b5a			  ;  ld    l, a    ; L = A+L  
6b5a			   ; adc   a, h    ; A = A+L+H+carry  
6b5a			   ; sub   l       ; A = H+carry  
6b5a			   ; ld    h, a    ; H = H+carry  
6b5a			  
6b5a			;ret  
6b5a			; eof  
# End of file firmware_key_5x10.asm
6b5a			;include "firmware_key_4x10.asm" 
6b5a			 
6b5a			heap_size:    equ heap_end - heap_start 
6b5a			;eof 
# End of file os_mega.asm
6b5a
