# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 34 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-09-05 21:49' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
001f			 
001f			 
001f			 
001f			;        nop  
001f			;        nop 
001f			;;	org 05h		; null out bdos call 
001f			; 
001f			;        nop  
001f			;        nop  
001f			;        nop 
001f			;;	org 08h 
001f			;;; 
001f			;;	jp cin		; rst 8 - char in 
001f			;;; 
001f			; 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;	org 010h 
001f			;; 
001f			;	jp cout		; rest 010h  - char out 
001f			;; 
001f			;	org 01bh   
001f			; 
001f			;	;jp  		; rst 01bh   - write string to display 
001f			;	jp str_at_display 
001f			; 
001f			; 
001f			;	org 020h 
001f			; 
001f			;	; jp		 ; rst 020h - read char at screen location 
001f			; 
001f			;	org 028h 
001f			 
001f				; jp		 ; rst 028h  - storage i/o 
001f			 
001f			; 	org 030h 
001f			;	jp break_point_state 
001f			  
001f			; $30  
001f			; org 038h 
001f			; $38 
001f			 
001f			; TODO any more important entry points to add to jump table for easier coding use? 
001f			 
001f			if BASE_KEV = 1  
001f			 
001f				; need to be at $66 for nmi support 
001f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0025 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0031 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0037 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0043 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0049 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0055 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0061 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0067 00 ff			db 0,255 
0069 c3 78 72			jp nmi 
006c			endif 
006c			 
006c			include "firmware.asm" 
006c			  
006c			; main constants (used here and in firmware)  
006c			  
006c			; TODO have page 0 of storage as bios  
006c			  
006c			Device_A: equ 0h  
006c			Device_B: equ 040h          ; Sound  
006c			  
006c			if BASE_KEV  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_SC114  
006c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			; TODO fixup for CPM  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			Device_D: equ 0c0h             ; Keyboard and LCD  
006c			  
006c			; Odd specific debug points for testing hardware dev  
006c			  
006c			;if DEBUG_LEVEL0  
006c			;	include "debug_level0.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL1  
006c			;	include "debug_level1.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL2  
006c			;	include "debug_level2.asm"  
006c			;endif  
006c			  
006c			  
006c			CALLMONITOR: macro  
006c			;	call break_point_state  
006c			; now use the break point debug vector  
006c				call debug_vector  
006c				endm  
006c			  
006c			MALLOC_1: equ 1        ; from dk88   
006c			MALLOC_2: equ 0           ; broke  
006c			MALLOC_3: equ 0           ; really broke  
006c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
006c			  
006c			if BASE_KEV   
006c			;stacksize: equ 256  
006c			; each stack entry is three bytes (type + word)  
006c			stacksize: equ 3*150  
006c			  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 512  
006c			endif  
006c			if BASE_SC114  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			;if STORAGE_SE == 0  
006c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
006c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
006c			;endif  
006c			  
006c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
006c			  
006c			STORE_0_AUTORUN: equ $20  
006c			  
006c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
006c			  
006c			STORE_0_AUTOFILE: equ $21  
006c			STORE_0_BANKRUN: equ $23  
006c			STORE_0_FILERUN: equ $24  
006c			  
006c			; Block 0 offsets for settings  
006c			  
006c			; if set then skip prompt for start up and accept all  
006c			  
006c			STORE_0_QUICKSTART: equ $25  
006c			  
006c			; Blocks where directory table is held  
006c			  
006c			; Reducing the number of entries increases the max file size  
006c			  
006c			;STORE_DIR_START: equ 1  
006c			;STORE_DIR_END: equ 33  
006c			  
006c			; Blocks from where file data is stored  
006c			  
006c			;STORE_DATA_START: equ STORE_DIR_END + 1  
006c			  
006c			; Block indicators (<32 are data files)  
006c			  
006c			;STORE_BLOCK_CFG: equ $8f       ; config block  
006c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
006c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
006c			;STORE_BLOCK_FREE: equ $85       ; data block free  
006c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
006c			  
006c			  
006c			  
006c			; Directory entry flags  
006c			  
006c			;STORE_DIR_FREE: equ 0  
006c			;STORE_DIR_FILE:  equ 1  
006c			  
006c			; Structure offsets to directory entries  
006c			;STORE_DE_FLAG: equ 0  
006c			;STORE_DE_MAXEXT: equ 1  
006c			;STORE_DE_FILENAME: equ 2  
006c			  
006c			; Structure offsets to block 0  
006c			  
006c			;STORE_BK0_ISFOR: equ 1  
006c			;STORE_BK0_LABEL: equ 3  
006c			  
006c			; memory allocation   
006c			  
006c			chk_stund: equ tos+2           ; underflow check word  
006c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
006c			  
006c			; keyscan table needs rows x cols buffer  
006c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
006c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
006c			  
006c			keyscan_table_row1: equ chk_stovr -key_cols-1  
006c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
006c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
006c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
006c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
006c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
006c			keyscan_scancol: equ keyscan_table-key_cols  
006c			;keyscan_table_len: equ key_rows*key_cols  
006c			;keybufptr: equ keyscan_table - 2  
006c			;keysymbol: equ keybufptr - 1  
006c			key_held: equ keyscan_scancol-1	; currently held  
006c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
006c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
006c			key_fa: equ key_repeat_ct -1 ;  
006c			key_fb: equ key_fa -1 ;  
006c			key_fc: equ key_fb -1 ;  
006c			key_fd: equ key_fc -1 ;  
006c			key_face_held: equ key_fd - 1   
006c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
006c			  
006c			hardware_config: equ key_face_held - 10  
006c			  
006c			; hardware config switches  
006c			; TODO add bitmasks on includes for hardware  
006c			; high byte for expansion ids  
006c			;     0000 0000  no card inserted  
006c			;     0000 0001  storage card inserted  
006c			;     0000 0010  spi sd card active  
006c			  
006c			;       
006c			; low byte:  
006c			;     0000 0001   4x4 keypad  
006c			;     0000 0010   full keyboard  
006c			;     0000 0011   spi/ext keyboard  
006c			;     0000 0100   20x4 lcd  
006c			;     0000 1000   40x4 lcd  
006c			;     0000 1100   spi/ext display  
006c			;     0001 0000   ide interface available  
006c			  
006c			hardware_word: equ hardware_config - 2  
006c			  
006c			; debug marker - optional display of debug point on the debug screens  
006c			  
006c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
006c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
006c			  
006c			debug_umark: equ debug_vector - 6  ; current user mark  
006c			debug_mark: equ debug_umark - 4    ; internal word debug points  
006c			  
006c			; input_str vars  
006c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
006c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
006c			input_size: equ input_start -1  ; number of chars  
006c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
006c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
006c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
006c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
006c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
006c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
006c			input_len: equ input_cur_onoff - 5 ; length of current input  
006c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
006c			  
006c			; cursor blink rate  
006c			CUR_BLINK_RATE: equ $09  
006c			;CUR_BLINK_RATE: equ 15  
006c			  
006c			key_actual_pressed: equ input_cursor - 1   
006c			key_symbol: equ key_actual_pressed - 1   
006c			key_shift: equ key_symbol - 1   
006c			  
006c			; Display allocation  
006c			  
006c			;display_rows: equ 4     ; move out to mini and mega files  
006c			;display_cols: equ 20  
006c			  
006c			display_fb_len: equ display_rows*display_cols  
006c			  
006c			; primary frame buffer     
006c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
006c			; working frame buffers  
006c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
006c			display_fb3: equ  display_fb1-display_fb_len - 1  
006c			display_fb2: equ  display_fb3-display_fb_len - 1  
006c			;  
006c			; pointer to active frame buffer  
006c			display_fb_active: equ display_fb2 - 2  
006c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
006c			display_write_tmp: equ display_lcde1e2 - 2  
006c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
006c			  
006c			;  
006c			  
006c			;; can load into de directory  
006c			cursor_col: equ display_active-1  
006c			cursor_row: equ cursor_col-1  
006c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
006c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
006c			  
006c			; maths vars  
006c			  
006c			LFSRSeed: equ cursor_shape -20   
006c			randData: equ LFSRSeed - 2  
006c			xrandc: equ randData - 2  
006c			stackstore: equ xrandc - 2  
006c			seed1: equ  stackstore -2   
006c			seed2: equ seed1 - 2  
006c			  
006c			; cf storage vars  
006c			  
006c			iErrorNum:  equ seed2-1         ;Error number  
006c			iErrorReg:  equ iErrorNum -1              ;Error register  
006c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
006c			  
006c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
006c			  
006c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
006c			  
006c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
006c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
006c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
006c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
006c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
006c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
006c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
006c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
006c			store_tmpid: equ store_tmp3 - 1		; page temp id  
006c			store_tmpext: equ store_tmpid - 1		; file extent temp  
006c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
006c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
006c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
006c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
006c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
006c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
006c			;  
006c			; spi vars  
006c			  
006c			  
006c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
006c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
006c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
006c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
006c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
006c			spi_device_id: equ spi_device - 1    ; human readable bank number  
006c			  
006c			;;;;; forth cli params  
006c			  
006c			; TODO use a different frame buffer for forth???  
006c			  
006c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
006c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
006c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
006c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
006c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
006c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
006c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
006c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
006c			  
006c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
006c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
006c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
006c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
006c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
006c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
006c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
006c			  
006c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
006c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
006c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
006c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
006c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
006c			  
006c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
006c			  
006c			; os/forth token vars  
006c			  
006c			os_last_cmd: equ os_var_array-255  
006c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
006c			os_current_i: equ os_cli_cmd-2  
006c			os_cur_ptr: equ os_current_i-2  
006c			os_word_scratch: equ os_cur_ptr-30  
006c			os_tok_len: equ os_word_scratch - 2  
006c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
006c			os_tok_malloc: equ os_tok_ptr - 2  
006c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
006c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
006c			execscratch: equ os_input-255        ; exec cmd eval buffer  
006c			scratch: equ execscratch-255  
006c			  
006c			os_stack_1: equ scratch - 3       ; stack holding area 1  
006c			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
006c			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
006c			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
006c			  
006c			  
006c			; temp locations for new word processing to save on adding more   
006c			  
006c			os_new_malloc: equ os_stack_4-2  
006c			os_new_parse_len: equ os_new_malloc - 2  
006c			os_new_word_len: equ os_new_parse_len - 2  
006c			os_new_work_ptr: equ os_new_word_len - 2  
006c			os_new_src_ptr: equ os_new_work_ptr - 2  
006c			os_new_exec: equ os_new_src_ptr - 2  
006c			os_new_exec_ptr: equ os_new_exec - 2  
006c			  
006c			; resume memory alloocations....  
006c			  
006c			;os_view_disable: equ os_new_exec_ptr - 1  
006c			os_view_af: equ os_new_exec_ptr - 2  
006c			os_view_hl: equ os_view_af -2  
006c			os_view_de: equ os_view_hl - 2  
006c			os_view_bc: equ os_view_de - 2  
006c			  
006c			; stack checksum word  
006c			if DEBUG_STACK_IMB  
006c				curframe: equ  os_view_de - 5  
006c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
006c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			else  
006c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			endif  
006c			  
006c			; with data stack could see memory filled with junk. need some memory management   
006c			; malloc and free entry points added  
006c			  
006c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
006c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			;heap_end: equ free_list-1  ; Starting address of heap  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			heap_end: equ chk_word-1  ; Starting address of heap  
006c			  
006c			  
006c			;if BASE_KEV   
006c			;heap_start: equ 0800eh  ; Starting address of heap  
006c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;heap_start: equ baseram+15  ; Starting address of heap  
006c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;endif  
006c			  
006c			  
006c			;;;;  
006c			  
006c			  
006c			; change below to point to last memory alloc above  
006c			topusermem:  equ   heap_start  
006c			  
006c			;if BASE_KEV   
006c			;baseusermem: equ 08000h  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;;aseusermem:     equ    12  
006c			;baseusermem:     equ    prompt  
006c			;;baseusermem:     equ    endofcode  
006c			;endif  
006c			  
006c			  
006c			; **********************************************************************  
006c			; **  Constants  
006c			; **********************************************************************  
006c			  
006c			; Constants used by this code module  
006c			kDataReg:   EQU Device_D           ;PIO port A data register  
006c			kContReg:   EQU Device_D+2           ;PIO port A control register  
006c			  
006c			  
006c			portbdata:  equ Device_D+1    ; port b data  
006c			portbctl:   equ Device_D+3    ; port b control  
006c			  
006c			  
006c			;KEY_SHIFT:   equ 5  
006c			;KEY_SYMBOLSHIFT:  equ 6  
006c			  
006c			KEY_SHIFTLOCK: equ 4  
006c			  
006c			  
006c			KEY_UP: equ 5  
006c			KEY_NEXTWORD: equ 6  
006c			KEY_PREVWORD: equ 7  
006c			KEY_BS: equ 8  
006c			KEY_TAB:  equ 9  
006c			KEY_DOWN: equ 10  
006c			KEY_LEFT: equ 11  
006c			KEY_RIGHT: equ 12  
006c			KEY_CR:   equ 13  
006c			KEY_HOME: equ 14  
006c			KEY_END: equ 15  
006c			  
006c			KEY_F1: equ 16  
006c			KEY_F2: equ 17  
006c			KEY_F3: equ 18  
006c			KEY_F4: equ 19  
006c			  
006c			KEY_F5: equ 20  
006c			KEY_F6: equ 21  
006c			KEY_F7: equ 22  
006c			KEY_F8: equ 23  
006c			  
006c			KEY_F9: equ 24  
006c			KEY_F10: equ 25  
006c			KEY_F11: equ 26  
006c			KEY_F12: equ 27  
006c			  
006c			;if DEBUG_KEY  
006c			;	KEY_MATRIX_NO_PRESS: equ '.'  
006c			;	KEY_SHIFT:   equ '.'  
006c			;	KEY_SYMBOLSHIFT:  equ '.'  
006c			;else  
006c				KEY_SHIFT:   equ '~'  
006c				KEY_SYMBOLSHIFT:  equ '~'  
006c				KEY_MATRIX_NO_PRESS: equ '~'  
006c			;endi  
006c			  
006c			  
006c			  
006c			  
006c			; Macro to make adding debug marks easier  
006c			  
006c			DMARK: macro str  
006c				push af  
006c				ld a, (.dmark)  
006c				ld (debug_mark),a  
006c				ld a, (.dmark+1)  
006c				ld (debug_mark+1),a  
006c				ld a, (.dmark+2)  
006c				ld (debug_mark+2),a  
006c				jr .pastdmark  
006c			.dmark: db str  
006c			.pastdmark: pop af  
006c			  
006c			endm  
006c			  
006c			  
006c			; macro to detect for stack imbalances  
006c			  
006c			include "stackimbal.asm"  
006c			; Macro and code to detect stock imbalances 
006c			 
006c			SPPUSH: equ 0 
006c			 
006c			; Add a stack frame which can be checked before return 
006c			 
006c			STACKFRAME: macro onoff frame1 frame2 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c						exx 
006c			 
006c						ld de, frame1 
006c						ld a, d 
006c						ld hl, curframe 
006c						call hexout 
006c						ld a, e 
006c						ld hl, curframe+2 
006c						call hexout 
006c			  
006c						ld hl, frame1 
006c						push hl 
006c						ld hl, frame2 
006c						push hl 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			endm 
006c			 
006c			STACKFRAMECHK: macro onoff frame1 frame2 
006c			 
006c					 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						exx 
006c						; check stack frame SP 
006c			 
006c						ld hl, frame2 
006c						pop de   ; frame2 
006c			 
006c						call cmp16 
006c						jr nz, .spnosame 
006c						 
006c			 
006c						ld hl, frame1 
006c						pop de   ; frame1 
006c			 
006c						call cmp16 
006c						jr z, .spfrsame 
006c			 
006c						.spnosame: call showsperror 
006c			 
006c						.spfrsame: nop 
006c			 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			 
006c			 
006c			endm 
006c			 
006c			 
006c			; for a sub routine, wrap SP collection and comparisons 
006c			 
006c			; Usage: 
006c			; 
006c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
006c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
006c			 
006c			SAVESP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c			 
006c						ld (store_sp+(storeword*4)), sp 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			CHECKSP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c			 
006c						; save SP after last save 
006c				 
006c						ld (store_sp+(storeword*4)+2), sp 
006c			 
006c						push hl 
006c						ld hl, store_sp+(storeword*4) 
006c						call check_stack_sp  
006c						pop hl 
006c			 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			if DEBUG_STACK_IMB 
006c			 
006c			check_stack_sp: 
006c					push de 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					push de 
006c			 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					pop hl 
006c			 
006c			 
006c					; check to see if the same 
006c			 
006c					call cmp16 
006c					jr z, .spsame 
006c			 
006c					; not same 
006c			 
006c					call showsperror 
006c			.spsame: 
006c			 
006c					pop de 
006c			 
006c					ret 
006c			 
006c			.sperr:  db "Stack imbalance",0 
006c			 
006c			 
006c			showsperror: 
006c			 
006c			 
006c				push hl 
006c				push af 
006c				push de 
006c				call clear_display 
006c				ld de, .sperr 
006c				ld a,0 
006c			;	ld de,os_word_scratch 
006c				call str_at_display 
006c				ld a, display_row_1+17 
006c				ld de, debug_mark 
006c				call str_at_display 
006c				ld a, 0 
006c				ld (curframe+4),a 
006c				ld hl, curframe 
006c				ld de, os_word_scratch 
006c				ld a, display_row_4 
006c				call str_at_display 
006c				call update_display 
006c				;call break_point_state 
006c				call cin_wait 
006c			 
006c			;	ld a, ' ' 
006c			;	ld (os_view_disable), a 
006c				call bp_on 
006c				pop de	 
006c				pop af 
006c				pop hl 
006c				CALLMONITOR 
006c				ret 
006c			 
006c			endif 
006c			 
006c			 
006c			 
006c			; eof 
# End of file stackimbal.asm
006c			  
006c			;TODO macro to calc col and row offset into screen  
006c			  
006c			  
006c			  
006c			hardware_init:  
006c			  
006c				  
006c			  
006c					;ld a, 0  
006c					;ld (hardware_diag), a  
006c			  
006c					; clear all the buffers  
006c			  
006c 21 45 fc				ld hl, display_fb1  
006f 22 01 fb				ld (display_fb_active), hl  
0072			  
0072 cd aa 0d				call clear_display  
0075			  
0075 21 03 fb				ld hl, display_fb2  
0078 22 01 fb				ld (display_fb_active), hl  
007b			  
007b cd aa 0d				call clear_display  
007e			  
007e					; init primary frame buffer area  
007e 21 e6 fc				ld hl, display_fb0  
0081 22 01 fb				ld (display_fb_active), hl  
0084			  
0084 cd aa 0d				call clear_display  
0087			  
0087			  
0087 cd 85 72				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
008a			  
008a cd 1c 75			call key_init  
008d cd 56 02			call storage_init  
0090			  
0090				; setup malloc functions  
0090			  
0090				if MALLOC_1  
0090 cd 95 13				call  heap_init  
0093				endif  
0093				if MALLOC_4  
0093					call  heap_init  
0093				endif  
0093			  
0093				; init sound hardware if present  
0093			  
0093				if SOUND_ENABLE  
0093					call sound_init  
0093				endif  
0093			  
0093				; lcd test sequence  
0093					  
0093 cd cd 0d			call update_display  
0096 cd ed 0c			call delay1s  
0099 3e 2b			ld a,'+'  
009b cd af 0d			call fill_display  
009e cd cd 0d			call update_display  
00a1 cd ed 0c			call delay1s  
00a4 3e 2a			ld a,'*'  
00a6 cd af 0d			call fill_display  
00a9 cd cd 0d			call update_display  
00ac cd ed 0c			call delay1s  
00af 3e 2d			ld a,'-'  
00b1 cd af 0d			call fill_display  
00b4 cd cd 0d			call update_display  
00b7 cd ed 0c			call delay1s  
00ba			  
00ba			; boot splash screen  
00ba			if display_cols == 20	  
00ba			        ld a, display_row_1    
00ba			else  
00ba 3e 0a		        ld a, display_row_1 +10   
00bc			endif  
00bc 11 24 1b			ld de, prom_bootmsg  
00bf cd bd 0d			call str_at_display  
00c2 cd cd 0d			call update_display  
00c5			  
00c5			  
00c5 cd ed 0c			call delay1s  
00c8 cd ed 0c			call delay1s  
00cb			if display_cols == 20	  
00cb			            LD   A, display_row_3+2  
00cb			else  
00cb 3e 5c		            LD   A, display_row_3+12  
00cd			endif  
00cd 11 39 1b			ld de, prom_bootmsg1  
00d0 cd bd 0d			call str_at_display  
00d3			; display debug level  
00d3 3e 78		            LD   A, display_row_4  
00d5 11 1b 00			ld de, debuglevel  
00d8 cd bd 0d			call str_at_display  
00db			  
00db cd cd 0d			call update_display  
00de cd ed 0c			call delay1s  
00e1 cd ed 0c			call delay1s  
00e4			  
00e4			;	ld a, display_row_4+3  
00e4			;	ld de, bootmsg2  
00e4			;	call str_at_display  
00e4			;	call update_display  
00e4			;	call delay1s  
00e4			;	call delay1s  
00e4			  
00e4			; debug mark setup  
00e4			  
00e4 3e 5f		ld a, '_'  
00e6 32 a0 fd		ld (debug_mark),a  
00e9 32 a1 fd		ld (debug_mark+1),a  
00ec 32 a2 fd		ld (debug_mark+2),a  
00ef 3e 00		ld a,0  
00f1 32 a3 fd		ld (debug_mark+3),a  
00f4 32 a4 fd		ld (debug_umark),a  
00f7			  
00f7 c9					ret  
00f8			  
00f8			  
00f8			;bootmsg2:	db "Firmware v0.1",0  
00f8			  
00f8			; a 4x20 lcd  
00f8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00f8			  
00f8			;if display_cols == 20  
00f8			;	include "firmware_lcd_4x20.asm"  
00f8			;endif  
00f8			  
00f8			;if display_cols == 40  
00f8			;	include "firmware_lcd_4x40.asm"  
00f8			;endif  
00f8			  
00f8			;  
00f8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00f8			; TODO abstract the bit bang video out interface for dual display  
00f8			; TODO wire video out to tx pin on rc2014 bus  
00f8			  
00f8			; must supply cin, and cin_wait for low level hardware abstraction   
00f8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00f8			; test scancode  
00f8			  
00f8			;;;;;  
00f8			;;;  
00f8			; Moved out to mini and maxi versions  
00f8			;  
00f8			; include "firmware_key_4x4.asm"  
00f8			; using existing 4 wire x 4 resistor array for input  
00f8			;include "firmware_key_4x10.asm"  
00f8			; need to mod the board for 5 rows due to resistor array  
00f8			;include "firmware_key_5x10.asm"  
00f8			  
00f8			; storage hardware interface  
00f8			  
00f8			; use microchip serial eeprom for storage  
00f8			  
00f8			  
00f8			if STORAGE_SE  
00f8				include "firmware_spi.asm"  
00f8			; my spi protocol (used by storage) 
00f8			 
00f8			; SPI pins 
00f8			 
00f8			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00f8			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00f8			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00f8			 
00f8			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00f8			; chip pin 4 gnd 
00f8			 
00f8			 
00f8			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00f8			SPI_CE1: equ 1      ;    port a1 pin 14  
00f8			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00f8			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00f8			SPI_CE4: equ 4      ; port a4     pin 10 
00f8			 
00f8			; active low AND masks 
00f8			 
00f8			;SPI_CE0_MASK: equ    255-1 
00f8			;SPI_CE1_MASK: equ   255-2 
00f8			;SPI_CE2_MASK: equ   255-4 
00f8			;SPI_CE3_MASK: equ   255-8 
00f8			;SPI_CE4_MASK: equ   255-16 
00f8			SPI_CE_HIGH:  equ 255 
00f8			 
00f8			 
00f8			 
00f8			;  Perform SCLK wait pulse 
00f8			 
00f8			spi_clk: 
00f8 f5				push af 
00f9 3a 99 f9			ld a, (spi_clktime) 
00fc fe 00			cp 0 
00fe 28 03			jr z, .scskip 
0100 cd d2 0c			call aDelayInMS 
0103			.scskip: 
0103 f1				pop af 
0104 c9				ret 
0105			 
0105			 
0105			 
0105			; TODO store port id for spi device ie dev c 
0105			; TODO store pin for SO 
0105			; TODO store pin for SI 
0105			; TODO store pin for SCLK 
0105			 
0105			; 
0105			 
0105			; ensure that spi bus is in a stable state with default pins  
0105			 
0105			se_stable_spi:   
0105			 
0105				 ; set DI high, CE high , SCLK low 
0105				;ld a, SPI_DI | SPI_CE0 
0105 3e 07			ld a, SPI_DI  
0107 cd 11 02			call spi_ce_high 
010a d3 80			 out (storage_adata),a 
010c 32 96 f9			ld (spi_portbyte),a 
010f			 
010f				if DEBUG_SPI 
010f					push hl 
010f					ld l, a 
010f					DMARK "SPI" 
010f					CALLMONITOR 
010f					pop hl 
010f				endif 
010f c9				ret 
0110			 
0110			; byte to send in a 
0110			 
0110			spi_send_byte: 
0110				; save byte to send for bit mask shift out 
0110 4f			        ld c,a 
0111 3a 96 f9			ld a,(spi_portbyte) 
0114				  
0114				; clock out	each bit of the byte msb first 
0114			 
0114 06 08			ld b, 8 
0116			.ssb1: 
0116				; clear so bit  
0116 cb bf			res SPI_DI, a 
0118 cb 11			rl c 
011a				; if bit 7 is set then carry is set 
011a 30 02			jr nc, .ssb2 
011c cb ff			set SPI_DI,a 
011e			.ssb2:  ; output bit to ensure it is stable 
011e d3 80			out (storage_adata),a 
0120 00				nop 
0121				; clock bit high 
0121 cb ef			set SPI_SCLK,a 
0123 d3 80			out (storage_adata),a 
0125 00				nop 
0126 cd f8 00			call spi_clk 
0129				; then low 
0129 cb af			res SPI_SCLK,a 
012b d3 80			out (storage_adata),a 
012d 00				nop 
012e cd f8 00			call spi_clk 
0131 10 e3			djnz .ssb1 
0133			 
0133 32 96 f9			ld (spi_portbyte),a 
0136 c9				ret 
0137			 
0137			; TODO low level get byte into A on spi 
0137			 
0137			spi_read_byte:  
0137			 
0137				; save byte to send for bit mask shift out 
0137 0e 00		    ld c,0 
0139 3a 96 f9			ld a,(spi_portbyte) 
013c				  
013c				; clock out	each bit of the byte msb first 
013c			 
013c			 
013c				; clock bit high 
013c cb ef			set SPI_SCLK,a 
013e d3 80			out (storage_adata),a 
0140 00				nop 
0141 cd f8 00			call spi_clk 
0144			 
0144			    ; read DO  
0144			 
0144 cb f9		    set 7,c 
0146 db 80			in a,(storage_adata) 
0148 cb 77		    bit SPI_DO,a 
014a 20 02		    jr nz, .b7 
014c cb b9		    res 7,c 
014e			.b7: 
014e				; then low 
014e cb af			res SPI_SCLK,a 
0150 d3 80			out (storage_adata),a 
0152 00				nop 
0153 cd f8 00			call spi_clk 
0156			     
0156			 
0156				; clock bit high 
0156 cb ef			set SPI_SCLK,a 
0158 d3 80			out (storage_adata),a 
015a 00				nop 
015b cd f8 00			call spi_clk 
015e			 
015e			    ; read DO  
015e			 
015e cb f1		    set 6,c 
0160 db 80			in a,(storage_adata) 
0162 cb 77		    bit SPI_DO,a 
0164 20 02		    jr nz, .b6 
0166 cb b1		    res 6,c 
0168			.b6: 
0168				; then low 
0168 cb af			res SPI_SCLK,a 
016a d3 80			out (storage_adata),a 
016c 00				nop 
016d cd f8 00			call spi_clk 
0170			 
0170				; clock bit high 
0170 cb ef			set SPI_SCLK,a 
0172 d3 80			out (storage_adata),a 
0174 00				nop 
0175 cd f8 00			call spi_clk 
0178			 
0178			 
0178			    ; read DO  
0178			 
0178 cb e9		    set 5,c 
017a db 80			in a,(storage_adata) 
017c cb 77		    bit SPI_DO,a 
017e 20 02		    jr nz, .b5 
0180 cb a9		    res 5,c 
0182			.b5: 
0182				; then low 
0182 cb af			res SPI_SCLK,a 
0184 d3 80			out (storage_adata),a 
0186 00				nop 
0187 cd f8 00			call spi_clk 
018a				; clock bit high 
018a cb ef			set SPI_SCLK,a 
018c d3 80			out (storage_adata),a 
018e 00				nop 
018f cd f8 00			call spi_clk 
0192			 
0192			    ; read DO  
0192			 
0192 cb e1		    set 4,c 
0194 db 80			in a,(storage_adata) 
0196 cb 77		    bit SPI_DO,a 
0198 20 02		    jr nz, .b4 
019a cb a1		    res 4,c 
019c			.b4: 
019c				; then low 
019c cb af			res SPI_SCLK,a 
019e d3 80			out (storage_adata),a 
01a0 00				nop 
01a1 cd f8 00			call spi_clk 
01a4				; clock bit high 
01a4 cb ef			set SPI_SCLK,a 
01a6 d3 80			out (storage_adata),a 
01a8 00				nop 
01a9 cd f8 00			call spi_clk 
01ac			 
01ac			    ; read DO  
01ac			 
01ac cb d9		    set 3,c 
01ae db 80			in a,(storage_adata) 
01b0 cb 77		    bit SPI_DO,a 
01b2 20 02		    jr nz, .b3 
01b4 cb 99		    res 3,c 
01b6			.b3: 
01b6				; then low 
01b6 cb af			res SPI_SCLK,a 
01b8 d3 80			out (storage_adata),a 
01ba 00				nop 
01bb cd f8 00			call spi_clk 
01be				; clock bit high 
01be cb ef			set SPI_SCLK,a 
01c0 d3 80			out (storage_adata),a 
01c2 00				nop 
01c3 cd f8 00			call spi_clk 
01c6			 
01c6			    ; read DO  
01c6			 
01c6 cb d1		    set 2,c 
01c8 db 80			in a,(storage_adata) 
01ca cb 77		    bit SPI_DO,a 
01cc 20 02		    jr nz, .b2 
01ce cb 91		    res 2,c 
01d0			.b2: 
01d0				; then low 
01d0 cb af			res SPI_SCLK,a 
01d2 d3 80			out (storage_adata),a 
01d4 00				nop 
01d5 cd f8 00			call spi_clk 
01d8				; clock bit high 
01d8 cb ef			set SPI_SCLK,a 
01da d3 80			out (storage_adata),a 
01dc 00				nop 
01dd cd f8 00			call spi_clk 
01e0			 
01e0			    ; read DO  
01e0			 
01e0 cb c9		    set 1,c 
01e2 db 80			in a,(storage_adata) 
01e4 cb 77		    bit SPI_DO,a 
01e6 20 02		    jr nz, .b1 
01e8 cb 89		    res 1,c 
01ea			.b1: 
01ea				; then low 
01ea cb af			res SPI_SCLK,a 
01ec d3 80			out (storage_adata),a 
01ee 00				nop 
01ef cd f8 00			call spi_clk 
01f2				; clock bit high 
01f2 cb ef			set SPI_SCLK,a 
01f4 d3 80			out (storage_adata),a 
01f6 00				nop 
01f7 cd f8 00			call spi_clk 
01fa			 
01fa			    ; read DO  
01fa			 
01fa cb c1		    set 0,c 
01fc db 80			in a,(storage_adata) 
01fe cb 77		    bit SPI_DO,a 
0200 20 02		    jr nz, .b0 
0202 cb 81		    res 0,c 
0204			.b0: 
0204				; then low 
0204 cb af			res SPI_SCLK,a 
0206 d3 80			out (storage_adata),a 
0208 00				nop 
0209 cd f8 00			call spi_clk 
020c			 
020c			 
020c 32 96 f9			ld (spi_portbyte),a 
020f			 
020f			    ; return byte 
020f 79			    ld a,c 
0210			 
0210			 
0210 c9				ret 
0211			 
0211			 
0211			 
0211			spi_ce_high: 
0211			 
0211				if DEBUG_SPI_HARD_CE0 
0211			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0211					ret 
0211			 
0211				endif 
0211			 
0211			 
0211 f5				push af 
0212			 
0212				; send direct ce to port b 
0212 3e ff			ld a, 255 
0214 d3 81			out (storage_bdata), a 
0216			 
0216 f1				pop af 
0217			 
0217				; for port a that shares with spi lines AND the mask 
0217			  
0217				if DEBUG_SPI 
0217					push hl 
0217					ld h, a 
0217				endif 
0217			;	ld c, SPI_CE_HIGH 
0217			;	and c 
0217 cb c7			set SPI_CE0, a 
0219 cb cf			set SPI_CE1, a 
021b cb d7			set SPI_CE2, a 
021d cb df			set SPI_CE3, a 
021f cb e7			set SPI_CE4, a 
0221			 
0221				if DEBUG_SPI 
0221					ld l, a 
0221					DMARK "CEh" 
0221					CALLMONITOR 
0221					pop hl 
0221				endif 
0221 c9				ret 
0222			 
0222			 
0222			spi_ce_low: 
0222			 
0222				if DEBUG_SPI_HARD_CE0 
0222			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0222					ret 
0222			 
0222				endif 
0222			 
0222 c5				push bc 
0223 f5				push af 
0224			 
0224				; send direct ce to port b 
0224 3a 98 f9			ld a, (spi_cartdev) 
0227 d3 81			out (storage_bdata), a 
0229			 
0229			 
0229			 
0229				; for port a that shares with spi lines AND the mask 
0229			 
0229 3a 95 f9			ld a, (spi_device)  
022c 4f				ld c, a 
022d			 
022d f1				pop af 
022e			 
022e				; detect CEx 
022e			 
022e				if DEBUG_SPI 
022e					push hl 
022e					ld h, a 
022e				endif 
022e			 
022e cb 41			bit SPI_CE0, c 
0230 20 04			jr nz, .cel1 
0232 cb 87			res SPI_CE0, a 
0234 18 1e			jr .celn 
0236			.cel1: 
0236 cb 49			bit SPI_CE1, c 
0238 20 04			jr nz, .cel2 
023a cb 8f			res SPI_CE1, a 
023c 18 16			jr .celn 
023e			.cel2: 
023e cb 51			bit SPI_CE2, c 
0240 20 04			jr nz, .cel3 
0242 cb 97			res SPI_CE2, a 
0244 18 0e			jr .celn 
0246			.cel3: 
0246 cb 59			bit SPI_CE3, c 
0248 20 04			jr nz, .cel4 
024a cb 9f			res SPI_CE3, a 
024c 18 06			jr .celn 
024e			.cel4: 
024e cb 61			bit SPI_CE4, c 
0250 20 02			jr nz, .celn 
0252 cb a7			res SPI_CE4, a 
0254			.celn: 
0254			 
0254			 
0254			 
0254			;	add c 
0254			 
0254				if DEBUG_SPI 
0254					ld l, a 
0254					DMARK "CEl" 
0254					CALLMONITOR 
0254					pop hl 
0254				endif 
0254 c1				pop bc 
0255 c9				ret 
0256			 
0256			 
0256			 
0256			; eof 
0256			 
0256			 
0256			 
0256			 
0256			 
# End of file firmware_spi.asm
0256				include "firmware_seeprom.asm"  
0256			; 
0256			; persisent storage interface via microchip serial eeprom 
0256			 
0256			; port a pio 2 
0256			; pa 7 - si 
0256			; pa 6 - sclk  
0256			; pa 5 - so 
0256			; pa 4 - cs 
0256			; pa 3 - cs 
0256			; pa 2 - cs 
0256			; pa 1 - cs 
0256			; pa 0 - cs 
0256			; 
0256			; TODO get block 
0256			; TODO save block 
0256			; TODO load file 
0256			; TODO save file 
0256			; TODO get dir  
0256			 
0256			;  
0256			storage_adata: equ Device_C    ; device c port a - onboard storage 
0256			storage_actl: equ Device_C+2     ; device c port a 
0256			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0256			storage_bctl: equ Device_C+3     ; device c port b 
0256			 
0256			 
0256			; TODO move these to hardware driver file 
0256			 
0256			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0256			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0256			; storage bank file system format 
0256			; 
0256			; first page of bank: 
0256			; 	addr 0 - status check 
0256			;       addr 1 - write protect flag 
0256			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0256			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0256			;         TODO see if scanning whole of for available next file id is fast enough 
0256			;	addr 4 > zero term string of bank label 
0256			; 
0256			;        
0256			;  
0256			; first page of any file: 
0256			;      byte 0 - file id  
0256			;      byte 1-17 - fixed file name  
0256			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0256			; 
0256			; other pages of any file: 
0256			;      byte 0 - file id 
0256			;      byte 1> - file data 
0256			; 
0256			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0256			;  
0256			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0256			 
0256			 
0256			;storage_so_bit: 5 
0256			;storage_si_bit: 7 
0256			;storage_sclk_bit: 6 
0256			  
0256			 
0256			; init storage pio 
0256			 
0256			storage_init: 
0256			 
0256			 
0256					; set default SPI clk pulse time as disabled 
0256			 
0256 3e 00				ld a, 0 
0258 32 99 f9				ld (spi_clktime), a 
025b			 
025b					; init hardware 
025b			 
025b 3e cf		            LD   A, 11001111b 
025d d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
025f 3e 00		            LD   A, 00000000b 
0261 cb f7			set SPI_DO,a 
0263			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0263 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0265			 
0265 3e cf		            LD   A, 11001111b 
0267 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0269 3e 00		            LD   A, 00000000b 
026b d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
026d			 
026d				; set all external spi devices off  
026d 3e ff			ld a, 255 
026f 32 95 f9			ld (spi_device), a 
0272 32 98 f9			ld (spi_cartdev), a 
0275			 
0275					; ensure the spi bus is in a default stable state 
0275 cd 05 01				call se_stable_spi 
0278			 
0278			; TODO scan spi bus and gather which storage banks are present 
0278			 
0278			; populate store_bank_active  
0278			; for each ce line activate and attempt to write first byte of bank and read back 
0278			; if zero is returned then bank is empty 
0278			;   
0278			; 
0278			 
0278					; init file extent cache to save on slow reads 
0278			 
0278			;	ld hl, store_filecache 
0278			;	ld de, 0 
0278			;	ld hl,(de)	 
0278			 
0278			 
0278 c9			    ret 
0279			 
0279			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0279			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0279			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0279			 
0279			; INSTRUCTION SET 
0279			; READ 0000 0011 Read data from memory array beginning at selected address 
0279			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0279			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0279			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0279			; RDSR 0000 0101 Read STATUS register 
0279			; WRSR 0000 0001 Write STATUS register 
0279			; PE 0100 0010 Page Erase – erase one page in memory array 
0279			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0279			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0279			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0279			 
0279			; TODO send byte steam for page without setting the address for every single byte 
0279			; TODO read byte  
0279			 
0279			; byte in a 
0279			; address in hl  
0279			se_writebyte: 
0279			        
0279			    ;   ld c, a 
0279 f5			        push af 
027a e5			        push hl 
027b			 
027b			    ; initi write mode 
027b			    ; 
027b			    ;CS low 
027b			 
027b 3a 96 f9		       ld a,(spi_portbyte) 
027e cd 22 02			call spi_ce_low 
0281			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0281 d3 80		       out (storage_adata),a 
0283 32 96 f9		       ld (spi_portbyte), a 
0286			 
0286			    ;clock out wren instruction 
0286			 
0286 3e 06		    ld a, store_wren_ins 
0288 cd 10 01		    call spi_send_byte  
028b			 
028b			    ;cs high to enable write latch 
028b			 
028b 3a 96 f9		       ld a,(spi_portbyte) 
028e cd 11 02			call spi_ce_high 
0291			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0291 d3 80		       out (storage_adata),a 
0293 32 96 f9		       ld (spi_portbyte), a 
0296			 
0296 00				nop 
0297			    ; 
0297			    ; intial write data 
0297			    ; 
0297			    ; cs low 
0297			     
0297 3a 96 f9		       ld a,(spi_portbyte) 
029a cd 22 02			call spi_ce_low 
029d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
029d d3 80		       out (storage_adata),a 
029f 32 96 f9		       ld (spi_portbyte), a 
02a2			 
02a2			    ; clock out write instruction 
02a2			     
02a2 3e 02		    ld a, store_write_ins  
02a4 cd 10 01		    call spi_send_byte  
02a7			 
02a7			    ; clock out address (depending on address size) 
02a7			     
02a7 e1			    pop hl 
02a8 7c			    ld a,h    ; address out msb first 
02a9 cd 10 01		    call spi_send_byte  
02ac 7d			    ld a,l 
02ad cd 10 01		    call spi_send_byte  
02b0			 
02b0			    ; clock out byte(s) for page 
02b0			 
02b0 f1			    pop af 
02b1 cd 10 01		    call spi_send_byte  
02b4			 
02b4			    ; end write with ce high 
02b4 3a 96 f9		       ld a,(spi_portbyte) 
02b7			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b7 cd 11 02			call spi_ce_high 
02ba d3 80		       out (storage_adata),a 
02bc 32 96 f9		       ld (spi_portbyte), a 
02bf			 
02bf				; pause for internal write cycle 
02bf 3e 0a			ld a, 10 
02c1 cd d2 0c			call aDelayInMS 
02c4 c9			    ret 
02c5			 
02c5			; buffer to write in de 
02c5			; address in hl  
02c5			se_writepage: 
02c5			        
02c5			    ;   ld c, a 
02c5 d5				push de 
02c6 e5			        push hl 
02c7			 
02c7			    ; initi write mode 
02c7			    ; 
02c7			    ;CS low 
02c7			 
02c7 3a 96 f9		       ld a,(spi_portbyte) 
02ca cd 22 02			call spi_ce_low 
02cd			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cd d3 80		       out (storage_adata),a 
02cf 32 96 f9		       ld (spi_portbyte), a 
02d2			 
02d2			    ;clock out wren instruction 
02d2			 
02d2 3e 06		    ld a, store_wren_ins 
02d4 cd 10 01		    call spi_send_byte  
02d7			 
02d7			    ;cs high to enable write latch 
02d7			 
02d7 3a 96 f9		       ld a,(spi_portbyte) 
02da cd 11 02			call spi_ce_high 
02dd			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02dd d3 80		       out (storage_adata),a 
02df 32 96 f9		       ld (spi_portbyte), a 
02e2			 
02e2 00				nop 
02e3			    ; 
02e3			    ; intial write data 
02e3			    ; 
02e3			    ; cs low 
02e3			     
02e3 3a 96 f9		       ld a,(spi_portbyte) 
02e6			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02e6 cd 22 02			call spi_ce_low 
02e9 d3 80		       out (storage_adata),a 
02eb 32 96 f9		       ld (spi_portbyte), a 
02ee			 
02ee			    ; clock out write instruction 
02ee			     
02ee 3e 02		    ld a, store_write_ins  
02f0 cd 10 01		    call spi_send_byte  
02f3			 
02f3			    ; clock out address (depending on address size) 
02f3			     
02f3 e1			    pop hl 
02f4 7c			    ld a,h    ; address out msb first 
02f5 cd 10 01		    call spi_send_byte  
02f8 7d			    ld a,l 
02f9 cd 10 01		    call spi_send_byte  
02fc			 
02fc			    ; clock out byte(s) for page 
02fc			 
02fc e1				pop hl 
02fd 06 40			ld b, STORE_BLOCK_PHY 
02ff			.bytewrite: 
02ff			 
02ff 7e				ld a,(hl) 
0300 e5			    push hl 
0301 c5				push bc 
0302 cd 10 01		    call spi_send_byte  
0305 c1				pop bc 
0306 e1				pop hl 
0307			 
0307			    ; end write with ce high 
0307 3a 96 f9		       ld a,(spi_portbyte) 
030a cd 11 02			call spi_ce_high 
030d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
030d d3 80		       out (storage_adata),a 
030f 32 96 f9		       ld (spi_portbyte), a 
0312			 
0312 23				inc hl 
0313 10 ea			djnz .bytewrite 
0315			 
0315				; pause for internal write cycle 
0315 3e 64			ld a, 100 
0317 cd d2 0c			call aDelayInMS 
031a c9			    ret 
031b			; returns byte in a 
031b			; address in hl  
031b			se_readbyte: 
031b d5				push de 
031c c5				push bc 
031d			 
031d			    ;   ld c, a 
031d e5			        push hl 
031e			 
031e			    ; initi write mode 
031e			    ; 
031e			    ;CS low 
031e			 
031e 3a 96 f9		       ld a,(spi_portbyte) 
0321 cd 22 02			call spi_ce_low 
0324			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0324 d3 80		       out (storage_adata),a 
0326 32 96 f9		       ld (spi_portbyte), a 
0329			 
0329			    ;clock out wren instruction 
0329			 
0329 3e 03		    ld a, store_read_ins 
032b cd 10 01		    call spi_send_byte  
032e			 
032e			 
032e			    ; clock out address (depending on address size) 
032e			     
032e e1			    pop hl 
032f 7c			    ld a,h    ; address out msb first 
0330 cd 10 01		    call spi_send_byte  
0333 7d			    ld a,l 
0334 cd 10 01		    call spi_send_byte  
0337			 
0337			    ; clock in byte(s) for page 
0337			 
0337 cd 37 01		    call spi_read_byte  
033a f5				push af 
033b			 
033b			    ; end write with ce high 
033b 3a 96 f9		       ld a,(spi_portbyte) 
033e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
033e cd 11 02			call spi_ce_high 
0341 d3 80		       out (storage_adata),a 
0343 32 96 f9		       ld (spi_portbyte), a 
0346			 
0346 f1				pop af 
0347			 
0347 c1				pop bc 
0348 d1				pop de 
0349			 
0349 c9			    ret 
034a			 
034a			if DEBUG_STORESE 
034a			 
034a			storageput:  
034a			 
034a			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
034a			 
034a 21 f8 f0			ld hl,scratch+2 
034d cd 9d 12			call get_word_hl 
0350			 
0350				; stuff it here for the moment as it will be overwritten later anyway 
0350			 
0350 22 19 f4			ld (os_cur_ptr),hl	 
0353			 
0353			 
0353			; get pointer to start of string 
0353			 
0353 21 fd f0			ld hl, scratch+7 
0356			 
0356			; loop writing char of string to eeprom 
0356			 
0356 7e			.writestr:	ld a,(hl) 
0357 fe 00				cp 0 
0359 28 12				jr z, .wsdone		; done writing 
035b e5					push hl 
035c 2a 19 f4				ld hl,(os_cur_ptr) 
035f cd 79 02				call se_writebyte 
0362			 
0362 2a 19 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0365 23					inc hl 
0366 22 19 f4				ld (os_cur_ptr),hl 
0369			 
0369					; restore string pointer and get next char 
0369			 
0369 e1					pop hl 
036a 23					inc hl 
036b 18 e9				jr .writestr 
036d			 
036d			 
036d			 
036d			.wsdone: 
036d			 
036d			 
036d			; when done load first page into a buffer  
036d			 
036d 21 00 80				ld hl,08000h		; start in ram 
0370 22 19 f4				ld (os_cur_ptr),hl 
0373 21 00 00				ld hl, 0		 ; start of page 
0376 22 1e f1				ld (scratch+40),hl	; hang on to it 
0379			 
0379 06 80				ld b, 128		; actually get more then one page 
037b c5			.wsload:	push bc 
037c 2a 1e f1				ld hl,(scratch+40) 
037f e5					push hl 
0380 cd 1b 03				call se_readbyte 
0383			 
0383					; a now as the byte 
0383			 
0383 2a 19 f4				ld hl,(os_cur_ptr) 
0386 77					ld (hl),a 
0387					; inc next buffer area 
0387 23					inc hl 
0388 22 19 f4				ld (os_cur_ptr),hl 
038b			 
038b					; get eeprom position, inc and save for next round 
038b e1					pop hl		 
038c 23					inc hl 
038d 22 1e f1				ld (scratch+40),hl 
0390 c1					pop bc 
0391 10 e8				djnz .wsload 
0393			 
0393			; set 'd' pointer to start of buffer 
0393			 
0393 21 00 80				ld hl,08000h 
0396 22 19 f4				ld (os_cur_ptr),hl 
0399			 
0399			 
0399 c9			ret 
039a			 
039a			 
039a c9			storageread: ret 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			endif 
039b			 
039b			 
039b			 
# End of file firmware_seeprom.asm
039b			else  
039b			   ; create some stubs for the labels  
039b			se_readbyte: ret  
039b			se_writebyte: ret  
039b			storage_init: ret  
039b			  
039b			endif  
039b			  
039b			; use cf card for storage - throwing timeout errors. Hardware or software?????  
039b			;include "firmware_cf.asm"  
039b			  
039b			; load up high level storage hardward abstractions  
039b			include "firmware_storage.asm"  
039b			 
039b			; persisent storage hardware abstraction layer  
039b			 
039b			 
039b			 
039b			; Block 0 on storage is a config state 
039b			 
039b			 
039b			 
039b			; TODO add read phy block and write phy block functions 
039b			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
039b			 
039b			; Abstraction layer  
039b			 
039b			; Logocial block size is same size as physical size - using tape concept 
039b			 
039b			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
039b			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
039b			 
039b			 
039b			 
039b			; Filesystem layout (Logical layout) 
039b			; 
039b			; Block 0 - Bank config  
039b			; 
039b			;      Byte - 0 file id counter 
039b			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
039b			;      Byte - 3-20 zero terminated bank label 
039b			; 
039b			; Block 1 > File storage 
039b			; 
039b			;      Byte 0 file id    - block 0 file details 
039b			;      Byte 1 block id - block 0 is file  
039b			;            Byte 2-15 - File name 
039b			; 
039b			;       - to end of block data 
039b			; 
039b			 
039b			; Get ID for the file named in pointer held HL 
039b			; Returns ID in HL = 255 if no file found 
039b			 
039b			storage_getid: 
039b			 
039b 22 a8 f9			ld (store_tmp1), hl 
039e			 
039e				if DEBUG_STORESE 
039e					DMARK "SGI" 
039e f5				push af  
039f 3a b3 03			ld a, (.dmark)  
03a2 32 a0 fd			ld (debug_mark),a  
03a5 3a b4 03			ld a, (.dmark+1)  
03a8 32 a1 fd			ld (debug_mark+1),a  
03ab 3a b5 03			ld a, (.dmark+2)  
03ae 32 a2 fd			ld (debug_mark+2),a  
03b1 18 03			jr .pastdmark  
03b3 ..			.dmark: db "SGI"  
03b6 f1			.pastdmark: pop af  
03b7			endm  
# End of macro DMARK
03b7					CALLMONITOR 
03b7 cd aa fd			call debug_vector  
03ba				endm  
# End of macro CALLMONITOR
03ba				endif 
03ba				; get block 0 and set counter for number of files to scan 
03ba			 
03ba cd 25 05			call storage_get_block_0 
03bd			 
03bd 3a af f9			ld a, (store_page) 
03c0 47				ld b, a 
03c1			 
03c1				; get extent 0 of each file id 
03c1			 
03c1				if DEBUG_STORESE 
03c1					DMARK "SGc" 
03c1 f5				push af  
03c2 3a d6 03			ld a, (.dmark)  
03c5 32 a0 fd			ld (debug_mark),a  
03c8 3a d7 03			ld a, (.dmark+1)  
03cb 32 a1 fd			ld (debug_mark+1),a  
03ce 3a d8 03			ld a, (.dmark+2)  
03d1 32 a2 fd			ld (debug_mark+2),a  
03d4 18 03			jr .pastdmark  
03d6 ..			.dmark: db "SGc"  
03d9 f1			.pastdmark: pop af  
03da			endm  
# End of macro DMARK
03da					CALLMONITOR 
03da cd aa fd			call debug_vector  
03dd				endm  
# End of macro CALLMONITOR
03dd				endif 
03dd 60			.getloop:	ld h, b 
03de 2e 00				ld l, 0 
03e0 c5					push bc 
03e1			 
03e1 11 af f9				ld de, store_page 
03e4				if DEBUG_STORESE 
03e4					DMARK "SGr" 
03e4 f5				push af  
03e5 3a f9 03			ld a, (.dmark)  
03e8 32 a0 fd			ld (debug_mark),a  
03eb 3a fa 03			ld a, (.dmark+1)  
03ee 32 a1 fd			ld (debug_mark+1),a  
03f1 3a fb 03			ld a, (.dmark+2)  
03f4 32 a2 fd			ld (debug_mark+2),a  
03f7 18 03			jr .pastdmark  
03f9 ..			.dmark: db "SGr"  
03fc f1			.pastdmark: pop af  
03fd			endm  
# End of macro DMARK
03fd					CALLMONITOR 
03fd cd aa fd			call debug_vector  
0400				endm  
# End of macro CALLMONITOR
0400				endif 
0400 cd cd 09				call storage_read 
0403 cd 07 10				call ishlzero 
0406 28 2d				jr z, .gap 
0408					 
0408					; have a file name read. Is it one we want. 
0408			 
0408 2a a8 f9				ld hl, (store_tmp1) 
040b 11 b2 f9				ld de, store_page+3   ; file name 
040e			 
040e				if DEBUG_STORESE 
040e					DMARK "SGc" 
040e f5				push af  
040f 3a 23 04			ld a, (.dmark)  
0412 32 a0 fd			ld (debug_mark),a  
0415 3a 24 04			ld a, (.dmark+1)  
0418 32 a1 fd			ld (debug_mark+1),a  
041b 3a 25 04			ld a, (.dmark+2)  
041e 32 a2 fd			ld (debug_mark+2),a  
0421 18 03			jr .pastdmark  
0423 ..			.dmark: db "SGc"  
0426 f1			.pastdmark: pop af  
0427			endm  
# End of macro DMARK
0427					CALLMONITOR 
0427 cd aa fd			call debug_vector  
042a				endm  
# End of macro CALLMONITOR
042a				endif 
042a cd 7c 13				call strcmp 
042d 20 06				jr nz, .gap   ; not this one 
042f			 
042f c1				        pop bc 
0430			 
0430 26 00				ld h, 0 
0432 68					ld l, b 
0433 18 22				jr .getdone 
0435						 
0435			 
0435			 
0435			 
0435			.gap: 
0435				if DEBUG_STORESE 
0435					DMARK "SGg" 
0435 f5				push af  
0436 3a 4a 04			ld a, (.dmark)  
0439 32 a0 fd			ld (debug_mark),a  
043c 3a 4b 04			ld a, (.dmark+1)  
043f 32 a1 fd			ld (debug_mark+1),a  
0442 3a 4c 04			ld a, (.dmark+2)  
0445 32 a2 fd			ld (debug_mark+2),a  
0448 18 03			jr .pastdmark  
044a ..			.dmark: db "SGg"  
044d f1			.pastdmark: pop af  
044e			endm  
# End of macro DMARK
044e					CALLMONITOR 
044e cd aa fd			call debug_vector  
0451				endm  
# End of macro CALLMONITOR
0451				endif 
0451			 
0451 c1					pop bc 
0452 10 89				djnz .getloop 
0454 21 ff 00				ld hl, 255 
0457			.getdone: 
0457			 
0457				if DEBUG_STORESE 
0457					DMARK "SGe" 
0457 f5				push af  
0458 3a 6c 04			ld a, (.dmark)  
045b 32 a0 fd			ld (debug_mark),a  
045e 3a 6d 04			ld a, (.dmark+1)  
0461 32 a1 fd			ld (debug_mark+1),a  
0464 3a 6e 04			ld a, (.dmark+2)  
0467 32 a2 fd			ld (debug_mark+2),a  
046a 18 03			jr .pastdmark  
046c ..			.dmark: db "SGe"  
046f f1			.pastdmark: pop af  
0470			endm  
# End of macro DMARK
0470					CALLMONITOR 
0470 cd aa fd			call debug_vector  
0473				endm  
# End of macro CALLMONITOR
0473				endif 
0473			 
0473 c9				ret 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			; Read Block 
0474			; ---------- 
0474			; 
0474			; With current bank 
0474			;  
0474			; Get block number to read 
0474			; Load physical blocks starting at start block into buffer 
0474			 
0474			; de points to buffer to use 
0474			; hl holds logical block number  
0474			 
0474			storage_read_block: 
0474			 
0474				; TODO bank selection 
0474			 
0474				; for each of the physical blocks read it into the buffer 
0474 06 40			ld b, STORE_BLOCK_PHY 
0476			 
0476				if DEBUG_STORESE 
0476 d5					push de 
0477				endif 
0477				 
0477			.rl1:    
0477			 
0477				; read physical block at hl into de 
0477			        ; increment hl and de to next read position on exit 
0477			 
0477 e5				push hl 
0478 d5				push de	 
0479 c5				push bc 
047a			;	if DEBUG_STORESE 
047a			;		push af 
047a			;		ld a, 'R' 
047a			;		ld (debug_mark),a 
047a			;		pop af 
047a			;		CALLMONITOR 
047a			;	endif 
047a cd 1b 03			call se_readbyte 
047d			;	if DEBUG_STORESE 
047d			;		ld a,(spi_portbyte) 
047d			;		ld l, a 
047d			;		push af 
047d			;		ld a, '1' 
047d			;		ld (debug_mark),a 
047d			;		pop af 
047d			;		CALLMONITOR 
047d			;	endif 
047d c1				pop bc 
047e d1				pop de 
047f e1				pop hl 
0480 12				ld (de),a 
0481 23				inc hl 
0482 13				inc de 
0483			 
0483			;	if DEBUG_STORESE 
0483			;		push af 
0483			;		ld a, 'r' 
0483			;		ld (debug_mark),a 
0483			;		pop af 
0483			;		CALLMONITOR 
0483			;	endif 
0483			 
0483 10 f2			djnz .rl1 
0485			 
0485				if DEBUG_STORESE 
0485					DMARK "SRB" 
0485 f5				push af  
0486 3a 9a 04			ld a, (.dmark)  
0489 32 a0 fd			ld (debug_mark),a  
048c 3a 9b 04			ld a, (.dmark+1)  
048f 32 a1 fd			ld (debug_mark+1),a  
0492 3a 9c 04			ld a, (.dmark+2)  
0495 32 a2 fd			ld (debug_mark+2),a  
0498 18 03			jr .pastdmark  
049a ..			.dmark: db "SRB"  
049d f1			.pastdmark: pop af  
049e			endm  
# End of macro DMARK
049e d1					pop de 
049f			; 
049f			;		push af 
049f			;		ld a, 'R' 
049f			;		ld (debug_mark),a 
049f			;		pop af 
049f					CALLMONITOR 
049f cd aa fd			call debug_vector  
04a2				endm  
# End of macro CALLMONITOR
04a2				endif 
04a2 c9				ret	 
04a3				 
04a3			 
04a3			; File Size 
04a3			; --------- 
04a3			; 
04a3			;   hl file id 
04a3			; 
04a3			;  returns in hl the number of blocks 
04a3			 
04a3			storage_file_size: 
04a3 5d				ld e, l 
04a4 16 00			ld d, 0 
04a6 21 40 00			ld hl, STORE_BLOCK_PHY 
04a9					if DEBUG_FORTH_WORDS 
04a9						DMARK "SIZ" 
04a9 f5				push af  
04aa 3a be 04			ld a, (.dmark)  
04ad 32 a0 fd			ld (debug_mark),a  
04b0 3a bf 04			ld a, (.dmark+1)  
04b3 32 a1 fd			ld (debug_mark+1),a  
04b6 3a c0 04			ld a, (.dmark+2)  
04b9 32 a2 fd			ld (debug_mark+2),a  
04bc 18 03			jr .pastdmark  
04be ..			.dmark: db "SIZ"  
04c1 f1			.pastdmark: pop af  
04c2			endm  
# End of macro DMARK
04c2						CALLMONITOR 
04c2 cd aa fd			call debug_vector  
04c5				endm  
# End of macro CALLMONITOR
04c5					endif 
04c5 cd a7 07			call storage_findnextid 
04c8			 
04c8 cd 07 10			call ishlzero 
04cb			;	ld a, l 
04cb			;	add h 
04cb			;	cp 0 
04cb c8				ret z			; block not found so EOF 
04cc			 
04cc 11 af f9			ld de, store_page 
04cf cd 74 04			call storage_read_block 
04d2			 
04d2 3a b1 f9			ld a, (store_page+2)	 ; get extent count 
04d5 6f				ld l, a 
04d6 26 00			ld h, 0 
04d8 c9			 	ret 
04d9			 
04d9			 
04d9			; Write Block 
04d9			; ----------- 
04d9			; 
04d9			; With current bank 
04d9			;  
04d9			; Get block number to write 
04d9			; Write physical blocks starting at start block from buffer 
04d9			  
04d9			storage_write_block: 
04d9				; TODO bank selection 
04d9			 
04d9				; for each of the physical blocks read it into the buffer 
04d9 06 40			ld b, STORE_BLOCK_PHY 
04db			 
04db				if DEBUG_STORESE 
04db					DMARK "SWB" 
04db f5				push af  
04dc 3a f0 04			ld a, (.dmark)  
04df 32 a0 fd			ld (debug_mark),a  
04e2 3a f1 04			ld a, (.dmark+1)  
04e5 32 a1 fd			ld (debug_mark+1),a  
04e8 3a f2 04			ld a, (.dmark+2)  
04eb 32 a2 fd			ld (debug_mark+2),a  
04ee 18 03			jr .pastdmark  
04f0 ..			.dmark: db "SWB"  
04f3 f1			.pastdmark: pop af  
04f4			endm  
# End of macro DMARK
04f4			 
04f4					;push af 
04f4					;ld a, 'W' 
04f4					;ld (debug_mark),a 
04f4					;pop af 
04f4					CALLMONITOR 
04f4 cd aa fd			call debug_vector  
04f7				endm  
# End of macro CALLMONITOR
04f7				endif 
04f7			 
04f7			; might not be working 
04f7			;	call se_writepage 
04f7			 
04f7			;	ret 
04f7			; 
04f7			 
04f7			 
04f7			 
04f7			.wl1:    
04f7			 
04f7				; read physical block at hl into de 
04f7			        ; increment hl and de to next read position on exit 
04f7			 
04f7 e5				push hl 
04f8 d5				push de	 
04f9 c5				push bc 
04fa 1a				ld a,(de) 
04fb				;if DEBUG_STORESE 
04fb			;		push af 
04fb			;		ld a, 'W' 
04fb			;		ld (debug_mark),a 
04fb			;		pop af 
04fb			;		CALLMONITOR 
04fb			;	endif 
04fb cd 79 02			call se_writebyte 
04fe			;	call delay250ms 
04fe 00				nop 
04ff 00				nop 
0500 00				nop 
0501			;	if DEBUG_STORESE 
0501			;		push af 
0501			;		ld a, 'w' 
0501			;		ld (debug_mark),a 
0501			;		pop af 
0501			;		CALLMONITOR 
0501			;	endif 
0501 c1				pop bc 
0502 d1				pop de 
0503 e1				pop hl 
0504 23				inc hl 
0505 13				inc de 
0506			 
0506			 
0506 10 ef			djnz .wl1 
0508			 
0508				if DEBUG_STORESE 
0508					DMARK "SW2" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 a0 fd			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 a1 fd			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 a2 fd			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "SW2"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521			 
0521					;push af 
0521					;ld a, 'W' 
0521					;ld (debug_mark),a 
0521					;pop af 
0521					CALLMONITOR 
0521 cd aa fd			call debug_vector  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 c9				ret	 
0525			 
0525			; Init bank 
0525			; --------- 
0525			; 
0525			; With current bank 
0525			; 
0525			; Setup block 0 config 
0525			;     Set 0 file id counter 
0525			;     Set formatted byte pattern 
0525			;     Zero out bank label 
0525			;      
0525			; For every logical block write 0-1 byte as null 
0525			 
0525			storage_get_block_0: 
0525			 
0525				; TODO check presence 
0525			 
0525				; get block 0 config 
0525			 
0525 21 00 00			ld hl, 0 
0528 11 af f9			ld de, store_page 
052b cd 74 04			call storage_read_block 
052e			 
052e				if DEBUG_STORESE 
052e					DMARK "SB0" 
052e f5				push af  
052f 3a 43 05			ld a, (.dmark)  
0532 32 a0 fd			ld (debug_mark),a  
0535 3a 44 05			ld a, (.dmark+1)  
0538 32 a1 fd			ld (debug_mark+1),a  
053b 3a 45 05			ld a, (.dmark+2)  
053e 32 a2 fd			ld (debug_mark+2),a  
0541 18 03			jr .pastdmark  
0543 ..			.dmark: db "SB0"  
0546 f1			.pastdmark: pop af  
0547			endm  
# End of macro DMARK
0547 11 af f9				ld de, store_page 
054a			;		push af 
054a			;		ld a, 'i' 
054a			;		ld (debug_mark),a 
054a			;		pop af 
054a					CALLMONITOR 
054a cd aa fd			call debug_vector  
054d				endm  
# End of macro CALLMONITOR
054d				endif 
054d			 
054d				; is this area formatted? 
054d			 
054d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
054d 2a b0 f9			ld hl, (store_page+1) 
0550 3e 80			ld a,0x80 
0552 bd				cp l 
0553 20 22			jr nz, .ininotformatted 
0555				; do a double check 
0555 3e 27			ld a, 0x27 
0557 bc				cp h 
0558 20 1d			jr nz, .ininotformatted 
055a			 
055a				; formatted then 
055a			 
055a				if DEBUG_STORESE 
055a					DMARK "SB1" 
055a f5				push af  
055b 3a 6f 05			ld a, (.dmark)  
055e 32 a0 fd			ld (debug_mark),a  
0561 3a 70 05			ld a, (.dmark+1)  
0564 32 a1 fd			ld (debug_mark+1),a  
0567 3a 71 05			ld a, (.dmark+2)  
056a 32 a2 fd			ld (debug_mark+2),a  
056d 18 03			jr .pastdmark  
056f ..			.dmark: db "SB1"  
0572 f1			.pastdmark: pop af  
0573			endm  
# End of macro DMARK
0573					;push af 
0573					;ld a, 'I' 
0573					;ld (debug_mark),a 
0573					;pop af 
0573					CALLMONITOR 
0573 cd aa fd			call debug_vector  
0576				endm  
# End of macro CALLMONITOR
0576				endif 
0576 c9				ret 
0577			 
0577			.ininotformatted: 
0577				; bank not formatted so poke various bits to make sure 
0577			 
0577				if DEBUG_STORESE 
0577					DMARK "SB2" 
0577 f5				push af  
0578 3a 8c 05			ld a, (.dmark)  
057b 32 a0 fd			ld (debug_mark),a  
057e 3a 8d 05			ld a, (.dmark+1)  
0581 32 a1 fd			ld (debug_mark+1),a  
0584 3a 8e 05			ld a, (.dmark+2)  
0587 32 a2 fd			ld (debug_mark+2),a  
058a 18 03			jr .pastdmark  
058c ..			.dmark: db "SB2"  
058f f1			.pastdmark: pop af  
0590			endm  
# End of macro DMARK
0590					;push af 
0590					;ld a, 'f' 
0590					;ld (debug_mark),a 
0590					;pop af 
0590					CALLMONITOR 
0590 cd aa fd			call debug_vector  
0593				endm  
# End of macro CALLMONITOR
0593				endif 
0593			 
0593 cd b0 0c			call storage_clear_page 
0596			 
0596 21 af f9			ld hl, store_page 
0599 3e 00			ld a, 0 
059b				 
059b 77				ld (hl),a   ; reset file counter 
059c			 
059c 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
059f 22 b0 f9		 	ld (store_page+1), hl	 
05a2			 
05a2				; set default label 
05a2			 
05a2 21 3e 06			ld hl, .defaultbanklabl 
05a5 11 b2 f9		 	ld de, store_page+3 
05a8 01 0f 00			ld bc, 15 
05ab ed b0			ldir 
05ad			 
05ad				; Append the current bank id 
05ad 21 bb f9			ld hl, store_page+3+9 
05b0 3a 94 f9			ld a, (spi_device_id) 
05b3 77				ld (hl), a 
05b4			 
05b4				; save default page 0 
05b4			 
05b4 21 00 00			ld hl, 0 
05b7 11 af f9			ld de, store_page 
05ba				if DEBUG_STORESE 
05ba					DMARK "SB3" 
05ba f5				push af  
05bb 3a cf 05			ld a, (.dmark)  
05be 32 a0 fd			ld (debug_mark),a  
05c1 3a d0 05			ld a, (.dmark+1)  
05c4 32 a1 fd			ld (debug_mark+1),a  
05c7 3a d1 05			ld a, (.dmark+2)  
05ca 32 a2 fd			ld (debug_mark+2),a  
05cd 18 03			jr .pastdmark  
05cf ..			.dmark: db "SB3"  
05d2 f1			.pastdmark: pop af  
05d3			endm  
# End of macro DMARK
05d3			;		push af 
05d3			;		ld a, 'F' 
05d3			;		ld (debug_mark),a 
05d3			;		pop af 
05d3					CALLMONITOR 
05d3 cd aa fd			call debug_vector  
05d6				endm  
# End of macro CALLMONITOR
05d6				endif 
05d6 cd d9 04			call storage_write_block 
05d9				if DEBUG_STORESE 
05d9					DMARK "SB4" 
05d9 f5				push af  
05da 3a ee 05			ld a, (.dmark)  
05dd 32 a0 fd			ld (debug_mark),a  
05e0 3a ef 05			ld a, (.dmark+1)  
05e3 32 a1 fd			ld (debug_mark+1),a  
05e6 3a f0 05			ld a, (.dmark+2)  
05e9 32 a2 fd			ld (debug_mark+2),a  
05ec 18 03			jr .pastdmark  
05ee ..			.dmark: db "SB4"  
05f1 f1			.pastdmark: pop af  
05f2			endm  
# End of macro DMARK
05f2			;		push af 
05f2			;		ld a, '>' 
05f2			;		ld (debug_mark),a 
05f2			;		pop af 
05f2					CALLMONITOR 
05f2 cd aa fd			call debug_vector  
05f5				endm  
# End of macro CALLMONITOR
05f5				endif 
05f5			 
05f5 00				nop 
05f6 00				nop 
05f7 00				nop 
05f8			 
05f8				; now set 0 in every page to mark as a free block 
05f8			 
05f8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05fa 21 40 00			ld hl, STORE_BLOCK_PHY 
05fd			 
05fd 3e 00		.setmark1:   	ld a,0 
05ff e5					push hl 
0600 c5					push bc 
0601 cd 79 02				call se_writebyte 
0604 3e 0a			ld a, 10 
0606 cd d2 0c			call aDelayInMS 
0609 23				inc hl 
060a cd 79 02				call se_writebyte 
060d 3e 0a			ld a, 10 
060f cd d2 0c			call aDelayInMS 
0612 2b				dec hl 
0613 c1					pop bc 
0614 e1					pop hl 
0615 3e 40				ld a, STORE_BLOCK_PHY 
0617 cd de 0f				call addatohl 
061a 10 e1				djnz .setmark1 
061c			 
061c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
061e 3e 00		.setmark2:   	ld a,0 
0620 e5					push hl 
0621 c5					push bc 
0622 cd 79 02				call se_writebyte 
0625 3e 0a			ld a, 10 
0627 cd d2 0c			call aDelayInMS 
062a 23				inc hl 
062b cd 79 02				call se_writebyte 
062e 3e 0a			ld a, 10 
0630 cd d2 0c			call aDelayInMS 
0633 2b				dec hl 
0634 c1					pop bc 
0635 e1					pop hl 
0636 3e 40				ld a, STORE_BLOCK_PHY 
0638 cd de 0f				call addatohl 
063b 10 e1				djnz .setmark2 
063d			 
063d					 
063d			 
063d			 
063d c9				ret 
063e			 
063e			 
063e			 
063e			 
063e .. 00		.defaultbanklabl:   db "BankLabel_",0 
0649			 
0649			 
0649			 
0649			; Label Bank 
0649			; ---------- 
0649			; 
0649			; With current bank 
0649			; Read block 0 
0649			; Set label 
0649			; Write block 0 
0649			 
0649			; label str pointer in hl 
0649			 
0649			storage_label:     
0649			 
0649				if DEBUG_STORESE 
0649					DMARK "LBL" 
0649 f5				push af  
064a 3a 5e 06			ld a, (.dmark)  
064d 32 a0 fd			ld (debug_mark),a  
0650 3a 5f 06			ld a, (.dmark+1)  
0653 32 a1 fd			ld (debug_mark+1),a  
0656 3a 60 06			ld a, (.dmark+2)  
0659 32 a2 fd			ld (debug_mark+2),a  
065c 18 03			jr .pastdmark  
065e ..			.dmark: db "LBL"  
0661 f1			.pastdmark: pop af  
0662			endm  
# End of macro DMARK
0662					CALLMONITOR 
0662 cd aa fd			call debug_vector  
0665				endm  
# End of macro CALLMONITOR
0665				endif 
0665			 
0665 e5				push hl 
0666			 
0666 cd 25 05			call storage_get_block_0 
0669			 
0669				; set default label 
0669			 
0669 e1				pop hl 
066a			 
066a 11 b2 f9		 	ld de, store_page+3 
066d 01 0f 00			ld bc, 15 
0670				if DEBUG_STORESE 
0670					DMARK "LB3" 
0670 f5				push af  
0671 3a 85 06			ld a, (.dmark)  
0674 32 a0 fd			ld (debug_mark),a  
0677 3a 86 06			ld a, (.dmark+1)  
067a 32 a1 fd			ld (debug_mark+1),a  
067d 3a 87 06			ld a, (.dmark+2)  
0680 32 a2 fd			ld (debug_mark+2),a  
0683 18 03			jr .pastdmark  
0685 ..			.dmark: db "LB3"  
0688 f1			.pastdmark: pop af  
0689			endm  
# End of macro DMARK
0689					CALLMONITOR 
0689 cd aa fd			call debug_vector  
068c				endm  
# End of macro CALLMONITOR
068c				endif 
068c ed b0			ldir 
068e				; save default page 0 
068e			 
068e 21 00 00			ld hl, 0 
0691 11 af f9			ld de, store_page 
0694				if DEBUG_STORESE 
0694					DMARK "LBW" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 a0 fd			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 a1 fd			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 a2 fd			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "LBW"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad					CALLMONITOR 
06ad cd aa fd			call debug_vector  
06b0				endm  
# End of macro CALLMONITOR
06b0				endif 
06b0 cd d9 04			call storage_write_block 
06b3			 
06b3 c9				ret 
06b4			 
06b4			 
06b4			 
06b4			; Read Block 0 - Config 
06b4			; --------------------- 
06b4			; 
06b4			; With current bank 
06b4			; Call presence test 
06b4			;    If not present format/init bank  
06b4			; Read block 0  
06b4			;  
06b4			 
06b4			 
06b4			; Dir 
06b4			; --- 
06b4			; 
06b4			; With current bank 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block read byte 2 
06b4			;      if first block of file 
06b4			;         Display file name 
06b4			;         Display type flags for file 
06b4			;        
06b4			 
06b4			; moving to words as this requires stack control 
06b4			 
06b4			 
06b4			; Delete File 
06b4			; ----------- 
06b4			; 
06b4			; With current bank 
06b4			; 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block file id 
06b4			;      If first block of file and dont have file id 
06b4			;         if file to delete 
06b4			;         Save file id 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			;      If file id is one saved 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			 
06b4			 
06b4			.se_done: 
06b4 e1				pop hl 
06b5 c9				ret 
06b6			 
06b6			storage_erase: 
06b6			 
06b6				; hl contains the file id 
06b6			 
06b6 5d				ld e, l 
06b7 16 00			ld d, 0 
06b9 21 40 00			ld hl, STORE_BLOCK_PHY 
06bc					if DEBUG_FORTH_WORDS 
06bc						DMARK "ERA" 
06bc f5				push af  
06bd 3a d1 06			ld a, (.dmark)  
06c0 32 a0 fd			ld (debug_mark),a  
06c3 3a d2 06			ld a, (.dmark+1)  
06c6 32 a1 fd			ld (debug_mark+1),a  
06c9 3a d3 06			ld a, (.dmark+2)  
06cc 32 a2 fd			ld (debug_mark+2),a  
06cf 18 03			jr .pastdmark  
06d1 ..			.dmark: db "ERA"  
06d4 f1			.pastdmark: pop af  
06d5			endm  
# End of macro DMARK
06d5						CALLMONITOR 
06d5 cd aa fd			call debug_vector  
06d8				endm  
# End of macro CALLMONITOR
06d8					endif 
06d8 cd a7 07			call storage_findnextid 
06db cd 07 10			call ishlzero 
06de c8				ret z 
06df			 
06df e5				push hl 
06e0			 
06e0				; TODO check file not found 
06e0			 
06e0 11 af f9			ld de, store_page 
06e3 cd 74 04			call storage_read_block 
06e6			 
06e6 cd 07 10			call ishlzero 
06e9 ca b4 06			jp z,.se_done 
06ec			 
06ec					if DEBUG_FORTH_WORDS 
06ec						DMARK "ER1" 
06ec f5				push af  
06ed 3a 01 07			ld a, (.dmark)  
06f0 32 a0 fd			ld (debug_mark),a  
06f3 3a 02 07			ld a, (.dmark+1)  
06f6 32 a1 fd			ld (debug_mark+1),a  
06f9 3a 03 07			ld a, (.dmark+2)  
06fc 32 a2 fd			ld (debug_mark+2),a  
06ff 18 03			jr .pastdmark  
0701 ..			.dmark: db "ER1"  
0704 f1			.pastdmark: pop af  
0705			endm  
# End of macro DMARK
0705						CALLMONITOR 
0705 cd aa fd			call debug_vector  
0708				endm  
# End of macro CALLMONITOR
0708					endif 
0708 3a af f9			ld a, (store_page)	; get file id 
070b 32 a3 f9			ld (store_tmpid), a 
070e			 
070e 3a b1 f9			ld a, (store_page+2)    ; get count of extends 
0711 32 a2 f9			ld (store_tmpext), a 
0714			 
0714				; wipe file header 
0714			 
0714 e1				pop hl 
0715 3e 00			ld a, 0 
0717 32 af f9			ld (store_page), a 
071a 32 b0 f9			ld (store_page+1),a 
071d 11 af f9			ld de, store_page 
0720					if DEBUG_FORTH_WORDS 
0720						DMARK "ER2" 
0720 f5				push af  
0721 3a 35 07			ld a, (.dmark)  
0724 32 a0 fd			ld (debug_mark),a  
0727 3a 36 07			ld a, (.dmark+1)  
072a 32 a1 fd			ld (debug_mark+1),a  
072d 3a 37 07			ld a, (.dmark+2)  
0730 32 a2 fd			ld (debug_mark+2),a  
0733 18 03			jr .pastdmark  
0735 ..			.dmark: db "ER2"  
0738 f1			.pastdmark: pop af  
0739			endm  
# End of macro DMARK
0739						CALLMONITOR 
0739 cd aa fd			call debug_vector  
073c				endm  
# End of macro CALLMONITOR
073c					endif 
073c cd d9 04			call storage_write_block 
073f			 
073f			 
073f				; wipe file extents 
073f			 
073f 3a a2 f9			ld a, (store_tmpext) 
0742 47				ld b, a 
0743			 
0743			.eraext:	  
0743 c5				push bc 
0744			 
0744 21 40 00			ld hl, STORE_BLOCK_PHY 
0747 3a a3 f9			ld a,(store_tmpid) 
074a 5f				ld e, a 
074b 50				ld d, b	 
074c					if DEBUG_FORTH_WORDS 
074c						DMARK "ER3" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 a0 fd			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 a1 fd			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 a2 fd			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "ER3"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765						CALLMONITOR 
0765 cd aa fd			call debug_vector  
0768				endm  
# End of macro CALLMONITOR
0768					endif 
0768 cd a7 07			call storage_findnextid 
076b cd 07 10			call ishlzero 
076e ca b4 06			jp z,.se_done 
0771			 
0771 e5				push hl 
0772 11 af f9			ld de, store_page 
0775 cd 74 04			call storage_read_block 
0778			 
0778				; free block	 
0778			 
0778 3e 00			ld a, 0 
077a 32 af f9			ld (store_page), a 
077d 32 b0 f9			ld (store_page+1),a 
0780 11 af f9			ld de, store_page 
0783 e1				pop hl 
0784					if DEBUG_FORTH_WORDS 
0784						DMARK "ER4" 
0784 f5				push af  
0785 3a 99 07			ld a, (.dmark)  
0788 32 a0 fd			ld (debug_mark),a  
078b 3a 9a 07			ld a, (.dmark+1)  
078e 32 a1 fd			ld (debug_mark+1),a  
0791 3a 9b 07			ld a, (.dmark+2)  
0794 32 a2 fd			ld (debug_mark+2),a  
0797 18 03			jr .pastdmark  
0799 ..			.dmark: db "ER4"  
079c f1			.pastdmark: pop af  
079d			endm  
# End of macro DMARK
079d						CALLMONITOR 
079d cd aa fd			call debug_vector  
07a0				endm  
# End of macro CALLMONITOR
07a0					endif 
07a0 cd d9 04			call storage_write_block 
07a3			 
07a3 c1				pop bc 
07a4 10 9d			djnz .eraext 
07a6			 
07a6 c9				ret 
07a7			 
07a7			 
07a7			; Find Free Block 
07a7			; --------------- 
07a7			; 
07a7			; With current bank 
07a7			;  
07a7			; From given starting logical block 
07a7			;    Read block  
07a7			;    If no file id 
07a7			;         Return block id 
07a7			 
07a7			 
07a7			; hl starting page number 
07a7			; hl contains free page number or zero if no pages free 
07a7			; e contains the file id to locate 
07a7			; d contains the block number 
07a7			 
07a7			; TODO change to find file id and use zero for free block 
07a7			 
07a7			storage_findnextid: 
07a7			 
07a7				; now locate first 0 page to mark as a free block 
07a7			 
07a7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a9			;	ld hl, STORE_BLOCK_PHY 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FNI" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 a0 fd			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 a1 fd			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 a2 fd			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FNI"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2						CALLMONITOR 
07c2 cd aa fd			call debug_vector  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5			.ff1:   	 
07c5 e5					push hl 
07c6 c5					push bc 
07c7 d5					push de 
07c8 cd 1b 03				call se_readbyte 
07cb 5f					ld e,a 
07cc 23					inc hl 
07cd cd 1b 03				call se_readbyte 
07d0 57					ld d, a 
07d1 e1					pop hl 
07d2 e5					push hl 
07d3 cd fc 0f				call cmp16 
07d6 28 49				jr z, .fffound 
07d8			 
07d8 d1					pop de 
07d9 c1					pop bc 
07da e1					pop hl 
07db			 
07db					; is found? 
07db					;cp e 
07db					;ret z 
07db			 
07db 3e 40				ld a, STORE_BLOCK_PHY 
07dd cd de 0f				call addatohl 
07e0 10 e3				djnz .ff1 
07e2			 
07e2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07e4			.ff2:   	 
07e4			 
07e4 e5					push hl 
07e5 c5					push bc 
07e6 d5					push de 
07e7 cd 1b 03				call se_readbyte 
07ea 5f					ld e,a 
07eb 23					inc hl 
07ec cd 1b 03				call se_readbyte 
07ef 57					ld d, a 
07f0			 
07f0 e1					pop hl 
07f1 e5					push hl 
07f2 cd fc 0f				call cmp16 
07f5 28 2a				jr z, .fffound 
07f7			 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa					; is found? 
07fa					;cp e 
07fa					;ret z 
07fa			 
07fa 3e 40				ld a, STORE_BLOCK_PHY 
07fc cd de 0f				call addatohl 
07ff 10 e3				djnz .ff2 
0801			 
0801			 
0801					if DEBUG_FORTH_WORDS 
0801					DMARK "FN-" 
0801 f5				push af  
0802 3a 16 08			ld a, (.dmark)  
0805 32 a0 fd			ld (debug_mark),a  
0808 3a 17 08			ld a, (.dmark+1)  
080b 32 a1 fd			ld (debug_mark+1),a  
080e 3a 18 08			ld a, (.dmark+2)  
0811 32 a2 fd			ld (debug_mark+2),a  
0814 18 03			jr .pastdmark  
0816 ..			.dmark: db "FN-"  
0819 f1			.pastdmark: pop af  
081a			endm  
# End of macro DMARK
081a					;	push af 
081a					;	ld a, 'n' 
081a					;	ld (debug_mark),a 
081a					;	pop af 
081a						CALLMONITOR 
081a cd aa fd			call debug_vector  
081d				endm  
# End of macro CALLMONITOR
081d					endif 
081d				; no free marks! 
081d 21 00 00				ld hl, 0 
0820 c9				ret 
0821			.fffound: 
0821				 
0821			 
0821 d1					pop de 
0822 c1					pop bc 
0823 e1					pop hl 
0824					if DEBUG_FORTH_WORDS 
0824					DMARK "FNF" 
0824 f5				push af  
0825 3a 39 08			ld a, (.dmark)  
0828 32 a0 fd			ld (debug_mark),a  
082b 3a 3a 08			ld a, (.dmark+1)  
082e 32 a1 fd			ld (debug_mark+1),a  
0831 3a 3b 08			ld a, (.dmark+2)  
0834 32 a2 fd			ld (debug_mark+2),a  
0837 18 03			jr .pastdmark  
0839 ..			.dmark: db "FNF"  
083c f1			.pastdmark: pop af  
083d			endm  
# End of macro DMARK
083d					;	push af 
083d					;	ld a, 'n' 
083d					;	ld (debug_mark),a 
083d					;	pop af 
083d						CALLMONITOR 
083d cd aa fd			call debug_vector  
0840				endm  
# End of macro CALLMONITOR
0840					endif 
0840 c9				ret 
0841			 
0841			 
0841			 
0841			; Free Space 
0841			; ---------- 
0841			; 
0841			; With current bank 
0841			; 
0841			; Set block count to zero 
0841			; Starting with first logical block 
0841			;      Find free block  
0841			;      If block id given, increment block count 
0841			; 
0841			;  
0841			 
0841			 
0841			; hl contains count of free blocks 
0841			 
0841			storage_freeblocks: 
0841			 
0841				; now locate first 0 page to mark as a free block 
0841			 
0841 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0843 21 40 00			ld hl, STORE_BLOCK_PHY 
0846 11 00 00			ld de, 0 
0849			 
0849			.fb1:   	 
0849 e5					push hl 
084a c5					push bc 
084b d5					push de 
084c cd 1b 03				call se_readbyte 
084f d1					pop de 
0850 c1					pop bc 
0851 e1					pop hl 
0852			 
0852					; is free? 
0852 fe 00				cp 0 
0854 20 01				jr nz, .ff1cont 
0856 13					inc de 
0857			 
0857			.ff1cont: 
0857			 
0857			 
0857 3e 40				ld a, STORE_BLOCK_PHY 
0859 cd de 0f				call addatohl 
085c 10 eb				djnz .fb1 
085e			 
085e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0860			.fb2:   	 
0860 e5					push hl 
0861 c5					push bc 
0862 d5					push de 
0863 cd 1b 03				call se_readbyte 
0866 d1					pop de 
0867 c1					pop bc 
0868 e1					pop hl 
0869			 
0869					; is free? 
0869 fe 00				cp 0 
086b 20 01				jr nz, .ff2cont 
086d 13					inc de 
086e			 
086e			.ff2cont: 
086e			 
086e 3e 40				ld a, STORE_BLOCK_PHY 
0870 cd de 0f				call addatohl 
0873 10 eb				djnz .fb2 
0875			 
0875 eb				ex de, hl 
0876 c9				ret 
0877			 
0877			; Get File ID 
0877			; ----------- 
0877			; 
0877			; With current bank 
0877			;  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; For each logical block 
0877			;    Read block file id 
0877			;      If first block of file and dont have file id 
0877			;         if file get id and exit 
0877			 
0877			 
0877			 
0877			 
0877			; Create File 
0877			; ----------- 
0877			; 
0877			; With current bank  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; Increment file id number 
0877			; Save Config 
0877			; Find free block 
0877			; Set buffer with file name and file id 
0877			; Write buffer to free block  
0877			 
0877			 
0877			; hl point to file name 
0877			; hl returns file id 
0877			 
0877			; file format: 
0877			; byte 0 - file id 
0877			; byte 1 - extent number 
0877			; byte 2-> data 
0877			 
0877			; format for extent number 0: 
0877			; 
0877			; byte 0 - file id 
0877			; byte 1 - extent 0 
0877			; byte 2 - extent count 
0877			; byte 3 -> file name and meta data 
0877			 
0877			 
0877			storage_create: 
0877				if DEBUG_STORESE 
0877					DMARK "SCR" 
0877 f5				push af  
0878 3a 8c 08			ld a, (.dmark)  
087b 32 a0 fd			ld (debug_mark),a  
087e 3a 8d 08			ld a, (.dmark+1)  
0881 32 a1 fd			ld (debug_mark+1),a  
0884 3a 8e 08			ld a, (.dmark+2)  
0887 32 a2 fd			ld (debug_mark+2),a  
088a 18 03			jr .pastdmark  
088c ..			.dmark: db "SCR"  
088f f1			.pastdmark: pop af  
0890			endm  
# End of macro DMARK
0890					CALLMONITOR 
0890 cd aa fd			call debug_vector  
0893				endm  
# End of macro CALLMONITOR
0893				endif 
0893			 
0893 e5				push hl		; save file name pointer 
0894			 
0894 cd 25 05			call storage_get_block_0 
0897			 
0897 3a af f9			ld a,(store_page)	; get current file id 
089a 3c				inc a 
089b 32 af f9			ld (store_page),a 
089e				 
089e 32 a3 f9			ld (store_tmpid),a			; save id 
08a1			 
08a1 21 00 00			ld hl, 0 
08a4 11 af f9			ld de, store_page 
08a7				if DEBUG_STORESE 
08a7					DMARK "SCw" 
08a7 f5				push af  
08a8 3a bc 08			ld a, (.dmark)  
08ab 32 a0 fd			ld (debug_mark),a  
08ae 3a bd 08			ld a, (.dmark+1)  
08b1 32 a1 fd			ld (debug_mark+1),a  
08b4 3a be 08			ld a, (.dmark+2)  
08b7 32 a2 fd			ld (debug_mark+2),a  
08ba 18 03			jr .pastdmark  
08bc ..			.dmark: db "SCw"  
08bf f1			.pastdmark: pop af  
08c0			endm  
# End of macro DMARK
08c0					CALLMONITOR 
08c0 cd aa fd			call debug_vector  
08c3				endm  
# End of macro CALLMONITOR
08c3				endif 
08c3 cd d9 04			call storage_write_block	 ; save update 
08c6			 
08c6				if DEBUG_STORESE 
08c6 11 af f9				ld de, store_page 
08c9					DMARK "SCC" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 a0 fd			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 a1 fd			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 a2 fd			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCC"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd aa fd			call debug_vector  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5				;  
08e5				 
08e5 21 40 00			ld hl, STORE_BLOCK_PHY 
08e8 11 00 00			ld de, 0 
08eb cd a7 07			call storage_findnextid 
08ee			 
08ee 22 9a f9			ld (store_tmppageid), hl    ; save page to use  
08f1			 
08f1				; TODO detect 0 = no spare blocks 
08f1			 
08f1				; hl now contains the free page to use for the file header page 
08f1			 
08f1				if DEBUG_STORESE 
08f1				DMARK "SCF" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 a0 fd			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 a1 fd			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 a2 fd			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCF"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					CALLMONITOR 
090a cd aa fd			call debug_vector  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d			 
090d 22 9a f9			ld (store_tmppageid), hl 
0910				 
0910 3a a3 f9			ld a,(store_tmpid)    ; get file id 
0913			;	ld a, (store_filecache)			; save to cache 
0913			 
0913 32 af f9			ld (store_page),a    ; set page id 
0916 3e 00			ld a, 0			 ; extent 0 is file header 
0918 32 b0 f9			ld (store_page+1), a   ; set file extent 
091b			 
091b 32 b1 f9			ld (store_page+2), a   ; extent count for the file 
091e			 
091e			;	inc hl 		; init block 0 of file 
091e			;	inc hl   		; skip file and extent id 
091e			 ;       ld a, 0 
091e			;	ld (hl),a 
091e			;	ld a, (store_filecache+1)  	; save to cache 
091e			 
091e			;	inc hl    ; file name 
091e				 
091e				 
091e 11 b2 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0921				if DEBUG_STORESE 
0921					DMARK "SCc" 
0921 f5				push af  
0922 3a 36 09			ld a, (.dmark)  
0925 32 a0 fd			ld (debug_mark),a  
0928 3a 37 09			ld a, (.dmark+1)  
092b 32 a1 fd			ld (debug_mark+1),a  
092e 3a 38 09			ld a, (.dmark+2)  
0931 32 a2 fd			ld (debug_mark+2),a  
0934 18 03			jr .pastdmark  
0936 ..			.dmark: db "SCc"  
0939 f1			.pastdmark: pop af  
093a			endm  
# End of macro DMARK
093a					CALLMONITOR 
093a cd aa fd			call debug_vector  
093d				endm  
# End of macro CALLMONITOR
093d				endif 
093d e1				pop hl    ; get zero term string 
093e e5				push hl 
093f 3e 00			ld a, 0 
0941 cd 4f 13			call strlent 
0944 23				inc hl   ; cover zero term 
0945 06 00			ld b,0 
0947 4d				ld c,l 
0948 e1				pop hl 
0949				;ex de, hl 
0949				if DEBUG_STORESE 
0949					DMARK "SCa" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 a0 fd			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 a1 fd			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 a2 fd			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SCa"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					;push af 
0962					;ld a, 'a' 
0962					;ld (debug_mark),a 
0962					;pop af 
0962					CALLMONITOR 
0962 cd aa fd			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 ed b0			ldir    ; copy zero term string 
0967				if DEBUG_STORESE 
0967					DMARK "SCA" 
0967 f5				push af  
0968 3a 7c 09			ld a, (.dmark)  
096b 32 a0 fd			ld (debug_mark),a  
096e 3a 7d 09			ld a, (.dmark+1)  
0971 32 a1 fd			ld (debug_mark+1),a  
0974 3a 7e 09			ld a, (.dmark+2)  
0977 32 a2 fd			ld (debug_mark+2),a  
097a 18 03			jr .pastdmark  
097c ..			.dmark: db "SCA"  
097f f1			.pastdmark: pop af  
0980			endm  
# End of macro DMARK
0980					CALLMONITOR 
0980 cd aa fd			call debug_vector  
0983				endm  
# End of macro CALLMONITOR
0983				endif 
0983			 
0983				; write file header page 
0983			 
0983 2a 9a f9			ld hl,(store_tmppageid) 
0986 11 af f9			ld de, store_page 
0989				if DEBUG_STORESE 
0989					DMARK "SCb" 
0989 f5				push af  
098a 3a 9e 09			ld a, (.dmark)  
098d 32 a0 fd			ld (debug_mark),a  
0990 3a 9f 09			ld a, (.dmark+1)  
0993 32 a1 fd			ld (debug_mark+1),a  
0996 3a a0 09			ld a, (.dmark+2)  
0999 32 a2 fd			ld (debug_mark+2),a  
099c 18 03			jr .pastdmark  
099e ..			.dmark: db "SCb"  
09a1 f1			.pastdmark: pop af  
09a2			endm  
# End of macro DMARK
09a2					;push af 
09a2					;ld a, 'b' 
09a2					;ld (debug_mark),a 
09a2					;pop af 
09a2					CALLMONITOR 
09a2 cd aa fd			call debug_vector  
09a5				endm  
# End of macro CALLMONITOR
09a5				endif 
09a5 cd d9 04			call storage_write_block 
09a8			 
09a8 3a a3 f9			ld a, (store_tmpid) 
09ab 6f				ld l, a 
09ac 26 00			ld h,0 
09ae				if DEBUG_STORESE 
09ae					DMARK "SCz" 
09ae f5				push af  
09af 3a c3 09			ld a, (.dmark)  
09b2 32 a0 fd			ld (debug_mark),a  
09b5 3a c4 09			ld a, (.dmark+1)  
09b8 32 a1 fd			ld (debug_mark+1),a  
09bb 3a c5 09			ld a, (.dmark+2)  
09be 32 a2 fd			ld (debug_mark+2),a  
09c1 18 03			jr .pastdmark  
09c3 ..			.dmark: db "SCz"  
09c6 f1			.pastdmark: pop af  
09c7			endm  
# End of macro DMARK
09c7					CALLMONITOR 
09c7 cd aa fd			call debug_vector  
09ca				endm  
# End of macro CALLMONITOR
09ca				endif 
09ca c9				ret 
09cb				 
09cb			 
09cb			 
09cb			; 
09cb			; Read File 
09cb			; 
09cb			; h - file id to locate 
09cb			; l - extent to locate 
09cb			; de - pointer to string to read into 
09cb			; 
09cb			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09cb			 
09cb			.sr_fail: 
09cb d1				pop de 
09cc c9				ret 
09cd			 
09cd			storage_read: 
09cd			 
09cd			 
09cd d5				push de 
09ce			 
09ce			; TODO BUG the above push is it popped before the RET Z? 
09ce			 
09ce			; TODO how to handle multiple part blocks 
09ce			 
09ce				; locate file extent to read 
09ce			 
09ce 5c				ld e, h 
09cf 55				ld d, l 
09d0			 
09d0			.srext: 
09d0 22 ad f9			ld (store_readptr), hl     ; save the current extent to load 
09d3 ed 53 ab f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09d7			 
09d7 21 40 00			ld hl, STORE_BLOCK_PHY 
09da				if DEBUG_STORESE 
09da					DMARK "sre" 
09da f5				push af  
09db 3a ef 09			ld a, (.dmark)  
09de 32 a0 fd			ld (debug_mark),a  
09e1 3a f0 09			ld a, (.dmark+1)  
09e4 32 a1 fd			ld (debug_mark+1),a  
09e7 3a f1 09			ld a, (.dmark+2)  
09ea 32 a2 fd			ld (debug_mark+2),a  
09ed 18 03			jr .pastdmark  
09ef ..			.dmark: db "sre"  
09f2 f1			.pastdmark: pop af  
09f3			endm  
# End of macro DMARK
09f3					CALLMONITOR 
09f3 cd aa fd			call debug_vector  
09f6				endm  
# End of macro CALLMONITOR
09f6				endif 
09f6 cd a7 07			call storage_findnextid 
09f9			 
09f9				if DEBUG_STORESE 
09f9					DMARK "srf" 
09f9 f5				push af  
09fa 3a 0e 0a			ld a, (.dmark)  
09fd 32 a0 fd			ld (debug_mark),a  
0a00 3a 0f 0a			ld a, (.dmark+1)  
0a03 32 a1 fd			ld (debug_mark+1),a  
0a06 3a 10 0a			ld a, (.dmark+2)  
0a09 32 a2 fd			ld (debug_mark+2),a  
0a0c 18 03			jr .pastdmark  
0a0e ..			.dmark: db "srf"  
0a11 f1			.pastdmark: pop af  
0a12			endm  
# End of macro DMARK
0a12					CALLMONITOR 
0a12 cd aa fd			call debug_vector  
0a15				endm  
# End of macro CALLMONITOR
0a15				endif 
0a15 cd 07 10			call ishlzero 
0a18			;	ld a, l 
0a18			;	add h 
0a18			;	cp 0 
0a18 28 b1			jr z,.sr_fail			; block not found so EOF 
0a1a			 
0a1a				; save current address for use by higher level words etc 
0a1a			 
0a1a 22 a0 f9			ld (store_openaddr),hl 
0a1d			 
0a1d			 
0a1d				; hl contains page number to load 
0a1d d1				pop de   ; get storage 
0a1e ed 53 ab f9		ld (store_readbuf), de     ; current buffer to load in to 
0a22 d5				push de 
0a23				if DEBUG_STORESE 
0a23					DMARK "srg" 
0a23 f5				push af  
0a24 3a 38 0a			ld a, (.dmark)  
0a27 32 a0 fd			ld (debug_mark),a  
0a2a 3a 39 0a			ld a, (.dmark+1)  
0a2d 32 a1 fd			ld (debug_mark+1),a  
0a30 3a 3a 0a			ld a, (.dmark+2)  
0a33 32 a2 fd			ld (debug_mark+2),a  
0a36 18 03			jr .pastdmark  
0a38 ..			.dmark: db "srg"  
0a3b f1			.pastdmark: pop af  
0a3c			endm  
# End of macro DMARK
0a3c					CALLMONITOR 
0a3c cd aa fd			call debug_vector  
0a3f				endm  
# End of macro CALLMONITOR
0a3f				endif 
0a3f cd 74 04			call storage_read_block 
0a42			 
0a42				; if this a continuation read??? 
0a42			 
0a42 2a ab f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a45			 
0a45 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a47 cd de 0f			call addatohl 
0a4a 7e				ld a,(hl) 
0a4b fe 00			cp 0 
0a4d 28 02			jr z, .markiscont 
0a4f 3e ff			ld a, 255 
0a51			 
0a51			.markiscont: 
0a51 32 a2 f9			ld (store_readcont), a 
0a54			 
0a54				if DEBUG_STORESE 
0a54					DMARK "srC" 
0a54 f5				push af  
0a55 3a 69 0a			ld a, (.dmark)  
0a58 32 a0 fd			ld (debug_mark),a  
0a5b 3a 6a 0a			ld a, (.dmark+1)  
0a5e 32 a1 fd			ld (debug_mark+1),a  
0a61 3a 6b 0a			ld a, (.dmark+2)  
0a64 32 a2 fd			ld (debug_mark+2),a  
0a67 18 03			jr .pastdmark  
0a69 ..			.dmark: db "srC"  
0a6c f1			.pastdmark: pop af  
0a6d			endm  
# End of macro DMARK
0a6d					CALLMONITOR 
0a6d cd aa fd			call debug_vector  
0a70				endm  
# End of macro CALLMONITOR
0a70				endif 
0a70				; only short reads enabled 
0a70			 
0a70 3a aa f9			ld a, (store_longread) 
0a73 fe 00			cp 0 
0a75 ca 42 0b			jp z, .readdone 
0a78			 
0a78			; TODO if block has no zeros then need to read next block  
0a78			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a78			; check last byte of physical block. 
0a78			; if not zero then the next block needs to be loaded 
0a78			 
0a78			 
0a78 2a ab f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a7b			 
0a7b 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a7d cd de 0f			call addatohl 
0a80				;dec hl 
0a80 7e				ld a,(hl) 
0a81				if DEBUG_STORESE 
0a81					DMARK "sr?" 
0a81 f5				push af  
0a82 3a 96 0a			ld a, (.dmark)  
0a85 32 a0 fd			ld (debug_mark),a  
0a88 3a 97 0a			ld a, (.dmark+1)  
0a8b 32 a1 fd			ld (debug_mark+1),a  
0a8e 3a 98 0a			ld a, (.dmark+2)  
0a91 32 a2 fd			ld (debug_mark+2),a  
0a94 18 03			jr .pastdmark  
0a96 ..			.dmark: db "sr?"  
0a99 f1			.pastdmark: pop af  
0a9a			endm  
# End of macro DMARK
0a9a					CALLMONITOR 
0a9a cd aa fd			call debug_vector  
0a9d				endm  
# End of macro CALLMONITOR
0a9d				endif 
0a9d fe 00			cp 0 
0a9f ca 42 0b			jp z, .readdone 
0aa2			 
0aa2				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0aa2			 
0aa2 23				inc hl 
0aa3			 
0aa3 22 ab f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0aa6			 
0aa6 ed 5b ad f9		ld de, (store_readptr)     ; save the current extent to load 
0aaa			 
0aaa eb				ex de, hl 
0aab			 
0aab				; next ext 
0aab			 
0aab 23				inc hl 
0aac 22 ad f9			ld  (store_readptr), hl     ; save the current extent to load 
0aaf			 
0aaf				if DEBUG_STORESE 
0aaf					DMARK "sF2" 
0aaf f5				push af  
0ab0 3a c4 0a			ld a, (.dmark)  
0ab3 32 a0 fd			ld (debug_mark),a  
0ab6 3a c5 0a			ld a, (.dmark+1)  
0ab9 32 a1 fd			ld (debug_mark+1),a  
0abc 3a c6 0a			ld a, (.dmark+2)  
0abf 32 a2 fd			ld (debug_mark+2),a  
0ac2 18 03			jr .pastdmark  
0ac4 ..			.dmark: db "sF2"  
0ac7 f1			.pastdmark: pop af  
0ac8			endm  
# End of macro DMARK
0ac8					CALLMONITOR 
0ac8 cd aa fd			call debug_vector  
0acb				endm  
# End of macro CALLMONITOR
0acb				endif 
0acb			 
0acb				; get and load block 
0acb			 
0acb cd a7 07			call storage_findnextid 
0ace			 
0ace				if DEBUG_STORESE 
0ace					DMARK "sf2" 
0ace f5				push af  
0acf 3a e3 0a			ld a, (.dmark)  
0ad2 32 a0 fd			ld (debug_mark),a  
0ad5 3a e4 0a			ld a, (.dmark+1)  
0ad8 32 a1 fd			ld (debug_mark+1),a  
0adb 3a e5 0a			ld a, (.dmark+2)  
0ade 32 a2 fd			ld (debug_mark+2),a  
0ae1 18 03			jr .pastdmark  
0ae3 ..			.dmark: db "sf2"  
0ae6 f1			.pastdmark: pop af  
0ae7			endm  
# End of macro DMARK
0ae7					CALLMONITOR 
0ae7 cd aa fd			call debug_vector  
0aea				endm  
# End of macro CALLMONITOR
0aea				endif 
0aea cd 07 10			call ishlzero 
0aed			;	ld a, l 
0aed			;	add h 
0aed			;	cp 0 
0aed ca cb 09			jp z,.sr_fail			; block not found so EOF 
0af0				 
0af0				; save current address for use by higher level words etc 
0af0			 
0af0 22 a0 f9			ld (store_openaddr),hl 
0af3			 
0af3 cd 74 04			call storage_read_block 
0af6			 
0af6				; on a continuation block, we now have the file id and ext in the middle of the block 
0af6				; we need to pull everything back  
0af6			 
0af6 ed 5b ab f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0afa 2a ab f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0afd 23				inc hl 
0afe 23				inc hl     ; skip id and ext 
0aff 01 40 00			ld bc, STORE_BLOCK_PHY 
0b02				if DEBUG_STORESE 
0b02					DMARK "SR<" 
0b02 f5				push af  
0b03 3a 17 0b			ld a, (.dmark)  
0b06 32 a0 fd			ld (debug_mark),a  
0b09 3a 18 0b			ld a, (.dmark+1)  
0b0c 32 a1 fd			ld (debug_mark+1),a  
0b0f 3a 19 0b			ld a, (.dmark+2)  
0b12 32 a2 fd			ld (debug_mark+2),a  
0b15 18 03			jr .pastdmark  
0b17 ..			.dmark: db "SR<"  
0b1a f1			.pastdmark: pop af  
0b1b			endm  
# End of macro DMARK
0b1b					CALLMONITOR 
0b1b cd aa fd			call debug_vector  
0b1e				endm  
# End of macro CALLMONITOR
0b1e				endif 
0b1e ed b0			ldir     ; copy data 
0b20			 
0b20				; move the pointer back and pretend we have a full buffer for next recheck 
0b20			 
0b20 1b				dec de 
0b21 1b				dec de 
0b22			 
0b22			; TODO do pop below now short circuit loop????? 
0b22 c1				pop bc     ; get rid of spare de on stack 
0b23				if DEBUG_STORESE 
0b23					DMARK "SR>" 
0b23 f5				push af  
0b24 3a 38 0b			ld a, (.dmark)  
0b27 32 a0 fd			ld (debug_mark),a  
0b2a 3a 39 0b			ld a, (.dmark+1)  
0b2d 32 a1 fd			ld (debug_mark+1),a  
0b30 3a 3a 0b			ld a, (.dmark+2)  
0b33 32 a2 fd			ld (debug_mark+2),a  
0b36 18 03			jr .pastdmark  
0b38 ..			.dmark: db "SR>"  
0b3b f1			.pastdmark: pop af  
0b3c			endm  
# End of macro DMARK
0b3c					CALLMONITOR 
0b3c cd aa fd			call debug_vector  
0b3f				endm  
# End of macro CALLMONITOR
0b3f				endif 
0b3f c3 d0 09			jp .srext 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			.readdone:		 
0b42 e1				pop hl 		 ; return start of data to show as not EOF 
0b43 23				inc hl   ; past file id 
0b44 23				inc hl   ; past ext 
0b45				if DEBUG_STORESE 
0b45					DMARK "SRe" 
0b45 f5				push af  
0b46 3a 5a 0b			ld a, (.dmark)  
0b49 32 a0 fd			ld (debug_mark),a  
0b4c 3a 5b 0b			ld a, (.dmark+1)  
0b4f 32 a1 fd			ld (debug_mark+1),a  
0b52 3a 5c 0b			ld a, (.dmark+2)  
0b55 32 a2 fd			ld (debug_mark+2),a  
0b58 18 03			jr .pastdmark  
0b5a ..			.dmark: db "SRe"  
0b5d f1			.pastdmark: pop af  
0b5e			endm  
# End of macro DMARK
0b5e					CALLMONITOR 
0b5e cd aa fd			call debug_vector  
0b61				endm  
# End of macro CALLMONITOR
0b61				endif 
0b61 c9					ret 
0b62			 
0b62			 
0b62			 
0b62			; 
0b62			; Append File 
0b62			; 
0b62			; hl - file id to locate 
0b62			; de - pointer to (multi block) string to write 
0b62			 
0b62			.sa_notfound: 
0b62 d1				pop de 
0b63 c9				ret 
0b64			 
0b64			 
0b64			storage_append: 
0b64				; hl -  file id to append to 
0b64				; de - string to append 
0b64			 
0b64 d5				push de 
0b65				 
0b65				if DEBUG_STORESE 
0b65					DMARK "AP1" 
0b65 f5				push af  
0b66 3a 7a 0b			ld a, (.dmark)  
0b69 32 a0 fd			ld (debug_mark),a  
0b6c 3a 7b 0b			ld a, (.dmark+1)  
0b6f 32 a1 fd			ld (debug_mark+1),a  
0b72 3a 7c 0b			ld a, (.dmark+2)  
0b75 32 a2 fd			ld (debug_mark+2),a  
0b78 18 03			jr .pastdmark  
0b7a ..			.dmark: db "AP1"  
0b7d f1			.pastdmark: pop af  
0b7e			endm  
# End of macro DMARK
0b7e					CALLMONITOR 
0b7e cd aa fd			call debug_vector  
0b81				endm  
# End of macro CALLMONITOR
0b81				endif 
0b81			 
0b81 7d				ld a, l 
0b82 32 a3 f9			ld (store_tmpid), a 
0b85			 
0b85				; get file header  
0b85			 
0b85 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b87 3a a3 f9			ld a, (store_tmpid) 
0b8a 5f				ld e, a 
0b8b			 
0b8b 21 40 00				ld hl, STORE_BLOCK_PHY 
0b8e cd a7 07				call storage_findnextid 
0b91			 
0b91 cd 07 10			call ishlzero 
0b94 28 cc			jr z, .sa_notfound 
0b96			 
0b96 22 9a f9			ld (store_tmppageid), hl 
0b99			 
0b99				; TODO handle file id not found 
0b99			 
0b99				if DEBUG_STORESE 
0b99					DMARK "AP2" 
0b99 f5				push af  
0b9a 3a ae 0b			ld a, (.dmark)  
0b9d 32 a0 fd			ld (debug_mark),a  
0ba0 3a af 0b			ld a, (.dmark+1)  
0ba3 32 a1 fd			ld (debug_mark+1),a  
0ba6 3a b0 0b			ld a, (.dmark+2)  
0ba9 32 a2 fd			ld (debug_mark+2),a  
0bac 18 03			jr .pastdmark  
0bae ..			.dmark: db "AP2"  
0bb1 f1			.pastdmark: pop af  
0bb2			endm  
# End of macro DMARK
0bb2					CALLMONITOR 
0bb2 cd aa fd			call debug_vector  
0bb5				endm  
# End of macro CALLMONITOR
0bb5				endif 
0bb5			 
0bb5				; update file extent count 
0bb5			 
0bb5 11 af f9			ld de, store_page 
0bb8			 
0bb8 cd 74 04			call storage_read_block 
0bbb			 
0bbb				if DEBUG_STORESE 
0bbb					DMARK "AP3" 
0bbb f5				push af  
0bbc 3a d0 0b			ld a, (.dmark)  
0bbf 32 a0 fd			ld (debug_mark),a  
0bc2 3a d1 0b			ld a, (.dmark+1)  
0bc5 32 a1 fd			ld (debug_mark+1),a  
0bc8 3a d2 0b			ld a, (.dmark+2)  
0bcb 32 a2 fd			ld (debug_mark+2),a  
0bce 18 03			jr .pastdmark  
0bd0 ..			.dmark: db "AP3"  
0bd3 f1			.pastdmark: pop af  
0bd4			endm  
# End of macro DMARK
0bd4					CALLMONITOR 
0bd4 cd aa fd			call debug_vector  
0bd7				endm  
# End of macro CALLMONITOR
0bd7				endif 
0bd7			;	ld (store_tmppageid), hl 
0bd7			 
0bd7 3a b1 f9			ld a, (store_page+2) 
0bda 3c				inc a 
0bdb 32 b1 f9			ld (store_page+2), a 
0bde 32 a2 f9			ld (store_tmpext), a 
0be1				 
0be1				if DEBUG_STORESE 
0be1					DMARK "AP3" 
0be1 f5				push af  
0be2 3a f6 0b			ld a, (.dmark)  
0be5 32 a0 fd			ld (debug_mark),a  
0be8 3a f7 0b			ld a, (.dmark+1)  
0beb 32 a1 fd			ld (debug_mark+1),a  
0bee 3a f8 0b			ld a, (.dmark+2)  
0bf1 32 a2 fd			ld (debug_mark+2),a  
0bf4 18 03			jr .pastdmark  
0bf6 ..			.dmark: db "AP3"  
0bf9 f1			.pastdmark: pop af  
0bfa			endm  
# End of macro DMARK
0bfa					CALLMONITOR 
0bfa cd aa fd			call debug_vector  
0bfd				endm  
# End of macro CALLMONITOR
0bfd				endif 
0bfd 2a 9a f9			ld hl, (store_tmppageid) 
0c00 11 af f9			ld de, store_page 
0c03 cd d9 04			call storage_write_block 
0c06			 
0c06				; find free block 
0c06			 
0c06 11 00 00			ld de, 0			 ; file extent to locate 
0c09			 
0c09 21 40 00				ld hl, STORE_BLOCK_PHY 
0c0c cd a7 07				call storage_findnextid 
0c0f cd 07 10			call ishlzero 
0c12 ca 62 0b			jp z, .sa_notfound 
0c15			 
0c15					; TODO handle no space left 
0c15					 
0c15 22 9a f9				ld (store_tmppageid), hl 
0c18			 
0c18				if DEBUG_STORESE 
0c18					DMARK "AP4" 
0c18 f5				push af  
0c19 3a 2d 0c			ld a, (.dmark)  
0c1c 32 a0 fd			ld (debug_mark),a  
0c1f 3a 2e 0c			ld a, (.dmark+1)  
0c22 32 a1 fd			ld (debug_mark+1),a  
0c25 3a 2f 0c			ld a, (.dmark+2)  
0c28 32 a2 fd			ld (debug_mark+2),a  
0c2b 18 03			jr .pastdmark  
0c2d ..			.dmark: db "AP4"  
0c30 f1			.pastdmark: pop af  
0c31			endm  
# End of macro DMARK
0c31					CALLMONITOR 
0c31 cd aa fd			call debug_vector  
0c34				endm  
# End of macro CALLMONITOR
0c34				endif 
0c34					; init the buffer with zeros so we can id if the buffer is full or not 
0c34			 
0c34 e5					push hl 
0c35 c5					push bc 
0c36			 
0c36 21 af f9				ld hl, store_page 
0c39 06 40				ld b, STORE_BLOCK_PHY 
0c3b 3e 00				ld a, 0 
0c3d 77			.zeroblock:	ld (hl), a 
0c3e 23					inc hl 
0c3f 10 fc				djnz .zeroblock 
0c41			 
0c41 c1					pop bc 
0c42 e1					pop hl 
0c43			 
0c43					; construct block 
0c43			 
0c43 3a a3 f9				ld a, (store_tmpid) 
0c46 32 af f9				ld (store_page), a   ; file id 
0c49 3a a2 f9				ld a, (store_tmpext)   ; extent for this block 
0c4c 32 b0 f9				ld (store_page+1), a 
0c4f			 
0c4f e1					pop hl    ; get string to write 
0c50 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c52 11 b1 f9				ld de, store_page+2 
0c55			 
0c55				if DEBUG_STORESE 
0c55					DMARK "AP5" 
0c55 f5				push af  
0c56 3a 6a 0c			ld a, (.dmark)  
0c59 32 a0 fd			ld (debug_mark),a  
0c5c 3a 6b 0c			ld a, (.dmark+1)  
0c5f 32 a1 fd			ld (debug_mark+1),a  
0c62 3a 6c 0c			ld a, (.dmark+2)  
0c65 32 a2 fd			ld (debug_mark+2),a  
0c68 18 03			jr .pastdmark  
0c6a ..			.dmark: db "AP5"  
0c6d f1			.pastdmark: pop af  
0c6e			endm  
# End of macro DMARK
0c6e					CALLMONITOR 
0c6e cd aa fd			call debug_vector  
0c71				endm  
# End of macro CALLMONITOR
0c71				endif 
0c71			 
0c71			 
0c71			 
0c71					; fill buffer with data until end of string or full block 
0c71			 
0c71 7e			.appd:		ld a, (hl) 
0c72 12					ld (de), a 
0c73 fe 00				cp 0 
0c75 28 04				jr z, .appdone 
0c77 23					inc hl 
0c78 13					inc de 
0c79 10 f6				djnz .appd 
0c7b			 
0c7b e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c7c f5					push af   		; save last byte dumped 
0c7d			 
0c7d			 
0c7d 2a 9a f9			ld hl, (store_tmppageid) 
0c80 11 af f9			ld de, store_page 
0c83				if DEBUG_STORESE 
0c83					DMARK "AP6" 
0c83 f5				push af  
0c84 3a 98 0c			ld a, (.dmark)  
0c87 32 a0 fd			ld (debug_mark),a  
0c8a 3a 99 0c			ld a, (.dmark+1)  
0c8d 32 a1 fd			ld (debug_mark+1),a  
0c90 3a 9a 0c			ld a, (.dmark+2)  
0c93 32 a2 fd			ld (debug_mark+2),a  
0c96 18 03			jr .pastdmark  
0c98 ..			.dmark: db "AP6"  
0c9b f1			.pastdmark: pop af  
0c9c			endm  
# End of macro DMARK
0c9c					CALLMONITOR 
0c9c cd aa fd			call debug_vector  
0c9f				endm  
# End of macro CALLMONITOR
0c9f				endif 
0c9f cd d9 04				call storage_write_block 
0ca2			 
0ca2			 
0ca2				; was that a full block of data written? 
0ca2				; any more to write out? 
0ca2			 
0ca2				; if yes then set vars and jump to start of function again 
0ca2			 
0ca2 f1					pop af 
0ca3 d1					pop de 
0ca4			 
0ca4 fe 00				cp 0		 ; no, string was fully written 
0ca6 c8					ret z 
0ca7			 
0ca7					; setup vars for next cycle 
0ca7			 
0ca7 3a a3 f9				ld a, (store_tmpid) 
0caa 6f					ld l, a 
0cab 26 00				ld h, 0 
0cad			 
0cad c3 64 0b			 	jp storage_append	 ; yes, need to write out some more 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			if DEBUG_STORECF 
0cb0			storageput:	 
0cb0					ret 
0cb0			storageread: 
0cb0					ld hl, store_page 
0cb0					ld b, 200 
0cb0					ld a,0 
0cb0			.src:		ld (hl),a 
0cb0					inc hl 
0cb0					djnz .src 
0cb0					 
0cb0			 
0cb0					ld de, 0 
0cb0					ld bc, 1 
0cb0					ld hl, store_page 
0cb0					call cfRead 
0cb0			 
0cb0				call cfGetError 
0cb0				ld hl,scratch 
0cb0				call hexout 
0cb0				ld hl, scratch+2 
0cb0				ld a, 0 
0cb0				ld (hl),a 
0cb0				ld de, scratch 
0cb0				ld a,display_row_1 
0cb0				call str_at_display 
0cb0				call update_display 
0cb0			 
0cb0					ld hl, store_page 
0cb0					ld (os_cur_ptr),hl 
0cb0			 
0cb0					ret 
0cb0			endif 
0cb0			 
0cb0			 
0cb0			; Clear out the main buffer store (used to remove junk before writing a new block) 
0cb0			 
0cb0			storage_clear_page: 
0cb0 e5				push hl 
0cb1 d5				push de 
0cb2 c5				push bc 
0cb3 21 af f9			ld hl, store_page 
0cb6 3e 00			ld a, 0 
0cb8 77				ld (hl), a 
0cb9			 
0cb9 11 b0 f9			ld de, store_page+1 
0cbc 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cbf			 
0cbf ed b0			ldir 
0cc1				 
0cc1 c1				pop bc 
0cc2 d1				pop de 
0cc3 e1				pop hl 
0cc4 c9				ret 
0cc5			 
0cc5			; eof 
# End of file firmware_storage.asm
0cc5			  
0cc5			; support routines for above hardware abstraction layer  
0cc5			  
0cc5			include "firmware_general.asm"        ; general support functions  
0cc5			 
0cc5			; word look up 
0cc5			 
0cc5			; in 
0cc5			; a is the index 
0cc5			; hl is pointer start of array 
0cc5			; 
0cc5			; returns 
0cc5			; hl to the word 
0cc5			; 
0cc5			 
0cc5			table_lookup:  
0cc5 d5					push de 
0cc6 eb					ex de, hl 
0cc7			 
0cc7 6f					ld l, a 
0cc8 26 00				ld h, 0 
0cca 29					add hl, hl 
0ccb 19					add hl, de 
0ccc 7e					ld a, (hl) 
0ccd 23					inc hl 
0cce 66					ld h,(hl) 
0ccf 6f					ld l, a 
0cd0			 
0cd0 d1					pop de 
0cd1 c9					ret 
0cd2			 
0cd2			; Delay loops 
0cd2			 
0cd2			 
0cd2			 
0cd2			aDelayInMS: 
0cd2 c5				push bc 
0cd3 47				ld b,a 
0cd4			msdelay: 
0cd4 c5				push bc 
0cd5				 
0cd5			 
0cd5 01 41 00			ld bc,041h 
0cd8 cd f0 0c			call delayloop 
0cdb c1				pop bc 
0cdc 05				dec b 
0cdd 20 f5			jr nz,msdelay 
0cdf			 
0cdf			;if CPU_CLOCK_8MHZ 
0cdf			;msdelay8: 
0cdf			;	push bc 
0cdf			;	 
0cdf			; 
0cdf			;	ld bc,041h 
0cdf			;	call delayloop 
0cdf			;	pop bc 
0cdf			;	dec b 
0cdf			;	jr nz,msdelay8 
0cdf			;endif 
0cdf			 
0cdf			 
0cdf c1				pop bc 
0ce0 c9				ret 
0ce1			 
0ce1			 
0ce1			delay250ms: 
0ce1				;push de 
0ce1 01 00 40			ld bc, 04000h 
0ce4 c3 f0 0c			jp delayloop 
0ce7			delay500ms: 
0ce7				;push de 
0ce7 01 00 80			ld bc, 08000h 
0cea c3 f0 0c			jp delayloop 
0ced			delay1s: 
0ced				;push bc 
0ced			   ; Clobbers A, d and e 
0ced 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0cf0			delayloop: 
0cf0 c5			    push bc 
0cf1			 
0cf1			if BASE_CPM 
0cf1				ld bc, CPM_DELAY_TUNE 
0cf1			.cpmloop: 
0cf1				push bc 
0cf1			 
0cf1			endif 
0cf1			 
0cf1			 
0cf1			 
0cf1			delayloopi: 
0cf1			;	push bc 
0cf1			;.dl: 
0cf1 cb 47		    bit     0,a    	; 8 
0cf3 cb 47		    bit     0,a    	; 8 
0cf5 cb 47		    bit     0,a    	; 8 
0cf7 e6 ff		    and     255  	; 7 
0cf9 0b			    dec     bc      	; 6 
0cfa 79			    ld      a,c     	; 4 
0cfb b0			    or      b     	; 4 
0cfc c2 f1 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cff			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cff				;pop de 
0cff			;pop bc 
0cff			 
0cff			if BASE_CPM 
0cff				pop bc 
0cff				 
0cff			    dec     bc      	; 6 
0cff			    ld      a,c     	; 4 
0cff			    or      b     	; 4 
0cff			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cff				 
0cff			 
0cff			endif 
0cff			;if CPU_CLOCK_8MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff			 
0cff			;if CPU_CLOCK_10MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff c1			    pop bc 
0d00			 
0d00 c9				ret 
0d01			 
0d01			 
0d01			 
0d01			; eof 
# End of file firmware_general.asm
0d01			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0d01			; display routines that use the physical hardware abstraction layer 
0d01			 
0d01			 
0d01			; Display an activity indicator 
0d01			; Each call returns the new char pointed to in hl 
0d01			 
0d01			active: 
0d01 3a fb fa			ld a, (display_active) 
0d04 fe 06			cp 6 
0d06			 
0d06 20 02			jr nz, .sne 
0d08				; gone past the last one reset sequence 
0d08 3e ff			ld a, 255 
0d0a			 
0d0a			.sne:   
0d0a				; get the next char in seq 
0d0a 3c				inc a 
0d0b 32 fb fa			ld (display_active), a 
0d0e			 
0d0e				; look up the string in the table 
0d0e 21 25 0d			ld hl, actseq 
0d11 cb 27			sla a 
0d13 cd de 0f			call addatohl 
0d16 cd bb 23			call loadwordinhl 
0d19			 
0d19				; forth will write the to string when pushing so move from rom to ram 
0d19			 
0d19 11 fc fa			ld de, display_active+1 
0d1c 01 02 00			ld bc, 2 
0d1f ed b0			ldir 
0d21			 
0d21 21 fc fa			ld hl, display_active+1 
0d24 c9				ret 
0d25				 
0d25				 
0d25			 
0d25			 
0d25			;db "|/-\|-\" 
0d25			 
0d25			actseq: 
0d25			 
0d25 33 0d		dw spin0 
0d27 35 0d		dw spin1 
0d29 37 0d		dw spin2 
0d2b 39 0d		dw spin3 
0d2d 37 0d		dw spin2 
0d2f 35 0d		dw spin1 
0d31 33 0d		dw spin0 
0d33			 
0d33 .. 00		spin0: db " ", 0 
0d35 .. 00		spin1: db "-", 0 
0d37 .. 00		spin2: db "+", 0 
0d39 .. 00		spin3: db "#", 0 
0d3b			 
0d3b			 
0d3b			; information window 
0d3b			 
0d3b			; pass hl with 1st string to display 
0d3b			; pass de with 2nd string to display 
0d3b			 
0d3b			info_panel: 
0d3b e5				push hl 
0d3c			 
0d3c 2a 01 fb			ld hl, (display_fb_active) 
0d3f e5				push hl    ; future de destination 
0d40 21 e6 fc				ld hl, display_fb0 
0d43 22 01 fb				ld (display_fb_active), hl 
0d46			 
0d46			;	call clear_display 
0d46			 
0d46				if BASE_CPM 
0d46				ld a, '.' 
0d46				else 
0d46 3e a5			ld a, 165 
0d48				endif 
0d48 cd af 0d			call fill_display 
0d4b			 
0d4b			 
0d4b 3e 55			ld a, display_row_3 + 5 
0d4d cd bd 0d			call str_at_display 
0d50			 
0d50 e1				pop hl 
0d51 d1				pop de 
0d52			 
0d52 e5				push hl 
0d53			 
0d53			 
0d53 3e 2d			ld a, display_row_2 + 5 
0d55 cd bd 0d			call str_at_display 
0d58			 
0d58			 
0d58 cd cd 0d			call update_display 
0d5b cd c0 1f			call next_page_prompt 
0d5e cd aa 0d			call clear_display 
0d61			 
0d61				 
0d61 21 45 fc				ld hl, display_fb1 
0d64 22 01 fb				ld (display_fb_active), hl 
0d67 cd cd 0d			call update_display 
0d6a			 
0d6a e1				pop hl 
0d6b			 
0d6b c9				ret 
0d6c			 
0d6c			 
0d6c			 
0d6c			 
0d6c			; TODO windowing? 
0d6c			 
0d6c			; TODO scroll line up 
0d6c			 
0d6c			scroll_up: 
0d6c			 
0d6c e5				push hl 
0d6d d5				push de 
0d6e c5				push bc 
0d6f			 
0d6f				; get frame buffer  
0d6f			 
0d6f 2a 01 fb			ld hl, (display_fb_active) 
0d72 e5				push hl    ; future de destination 
0d73			 
0d73 11 28 00			ld  de, display_cols 
0d76 19				add hl, de 
0d77			 
0d77 d1				pop de 
0d78			 
0d78				;ex de, hl 
0d78 01 9f 00			ld bc, display_fb_len -1  
0d7b			;if DEBUG_FORTH_WORDS 
0d7b			;	DMARK "SCL" 
0d7b			;	CALLMONITOR 
0d7b			;endif	 
0d7b ed b0			ldir 
0d7d			 
0d7d				; wipe bottom row 
0d7d			 
0d7d			 
0d7d 2a 01 fb			ld hl, (display_fb_active) 
0d80 11 a0 00			ld de, display_cols*display_rows 
0d83 19				add hl, de 
0d84 06 28			ld b, display_cols 
0d86 3e 20			ld a, ' ' 
0d88			.scwipe: 
0d88 77				ld (hl), a 
0d89 2b				dec hl 
0d8a 10 fc			djnz .scwipe 
0d8c			 
0d8c				;pop hl 
0d8c			 
0d8c c1				pop bc 
0d8d d1				pop de 
0d8e e1				pop hl 
0d8f			 
0d8f c9				ret 
0d90			 
0d90			 
0d90			;scroll_upo: 
0d90			;	ld de, display_row_1 
0d90			 ;	ld hl, display_row_2 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_2 
0d90			 ;	ld hl, display_row_3 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_3 
0d90			 ;	ld hl, display_row_4 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			 
0d90			; TODO clear row 4 
0d90			 
0d90			;	ret 
0d90			 
0d90				 
0d90			scroll_down: 
0d90			 
0d90 e5				push hl 
0d91 d5				push de 
0d92 c5				push bc 
0d93			 
0d93				; get frame buffer  
0d93			 
0d93 2a 01 fb			ld hl, (display_fb_active) 
0d96			 
0d96 11 9f 00			ld de, display_fb_len - 1 
0d99 19				add hl, de 
0d9a			 
0d9a e5			push hl    ; future de destination 
0d9b			 
0d9b 11 28 00			ld  de, display_cols 
0d9e ed 52			sbc hl, de 
0da0			 
0da0			 
0da0 d1				pop de 
0da1			 
0da1			;	ex de, hl 
0da1 01 9f 00			ld bc, display_fb_len -1  
0da4			 
0da4			 
0da4				 
0da4			 
0da4 ed b0			ldir 
0da6			 
0da6				; wipe bottom row 
0da6			 
0da6			 
0da6			;	ld hl, (display_fb_active) 
0da6			;;	ld de, display_cols*display_rows 
0da6			;;	add hl, de 
0da6			;	ld b, display_cols 
0da6			;	ld a, ' ' 
0da6			;.scwiped: 
0da6			;	ld (hl), a 
0da6			;	dec hl 
0da6			;	djnz .scwiped 
0da6			 
0da6				;pop hl 
0da6			 
0da6 c1				pop bc 
0da7 d1				pop de 
0da8 e1				pop hl 
0da9			 
0da9 c9				ret 
0daa			;scroll_down: 
0daa			;	ld de, display_row_4 
0daa			;	ld hl, display_row_3 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_3 
0daa			; 	ld hl, display_row_2 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_2 
0daa			;	ld hl, display_row_1 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;;; TODO clear row 1 
0daa			;	ret 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			; clear active frame buffer 
0daa			 
0daa			clear_display: 
0daa 3e 20			ld a, ' ' 
0dac c3 af 0d			jp fill_display 
0daf			 
0daf			; fill active frame buffer with a char in A 
0daf			 
0daf			fill_display: 
0daf 06 a0			ld b,display_fb_len 
0db1 2a 01 fb			ld hl, (display_fb_active) 
0db4 77			.fd1:	ld (hl),a 
0db5 23				inc hl 
0db6 10 fc			djnz .fd1 
0db8 23				inc hl 
0db9 3e 00			ld a,0 
0dbb 77				ld (hl),a 
0dbc			 
0dbc			 
0dbc c9				ret 
0dbd			; Write string (DE) at pos (A) to active frame buffer 
0dbd			 
0dbd 2a 01 fb		str_at_display:    ld hl,(display_fb_active) 
0dc0 06 00					ld b,0 
0dc2 4f					ld c,a 
0dc3 09					add hl,bc 
0dc4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0dc5 b7			            OR   A              ;Null terminator? 
0dc6 c8			            RET  Z              ;Yes, so finished 
0dc7 77					ld (hl),a 
0dc8 23				inc hl 
0dc9 13			            INC  DE             ;Point to next character 
0dca 18 f8		            JR   .sad1     ;Repeat 
0dcc c9					ret 
0dcd			 
0dcd			; using current frame buffer write to physical display 
0dcd			 
0dcd			update_display: 
0dcd e5				push hl 
0dce 2a 01 fb			ld hl, (display_fb_active) 
0dd1 cd b1 72			call write_display 
0dd4 e1				pop hl 
0dd5 c9				ret 
0dd6			 
0dd6			; TODO scrolling 
0dd6			 
0dd6			 
0dd6			; move cursor right one char 
0dd6			cursor_right: 
0dd6			 
0dd6				; TODO shift right 
0dd6				; TODO if beyond max col 
0dd6				; TODO       cursor_next_line 
0dd6			 
0dd6 c9				ret 
0dd7			 
0dd7			 
0dd7			cursor_next_line: 
0dd7				; TODO first char 
0dd7				; TODO line down 
0dd7				; TODO if past last row 
0dd7				; TODO    scroll up 
0dd7			 
0dd7 c9				ret 
0dd8			 
0dd8			cursor_left: 
0dd8				; TODO shift left 
0dd8				; TODO if beyond left  
0dd8				; TODO     cursor prev line 
0dd8				 
0dd8 c9				ret 
0dd9			 
0dd9			cursor_prev_line: 
0dd9				; TODO last char 
0dd9				; TODO line up 
0dd9				; TODO if past first row 
0dd9				; TODO   scroll down 
0dd9			 
0dd9 c9				ret 
0dda			 
0dda			 
0dda			cout: 
0dda				; A - char 
0dda c9				ret 
0ddb			 
0ddb			 
0ddb			; Display a menu and allow item selection (optional toggle items) 
0ddb			; 
0ddb			; format: 
0ddb			; hl pointer to word array with zero term for items 
0ddb			; e.g.    db item1 
0ddb			;         db .... 
0ddb			;         db 0 
0ddb			; 
0ddb			; a = starting menu item  
0ddb			; 
0ddb			; de = pointer item toggle array   (todo) 
0ddb			; 
0ddb			; returns item selected in a 1-... 
0ddb			; returns 0 if back button pressed 
0ddb			; 
0ddb			; NOTE: Uses system frame buffer to display 
0ddb			; 
0ddb			; LEFT, Q = go back 
0ddb			; RIGHT, SPACE, CR = select 
0ddb			; UP, A - Up 
0ddb			; DOWN, Z - Down 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			menu: 
0ddb			 
0ddb					; keep array pointer 
0ddb			 
0ddb 22 a8 f9				ld (store_tmp1), hl 
0dde 32 a6 f9				ld (store_tmp2), a 
0de1			 
0de1					; check for key bounce 
0de1			 
0de1			if BASE_KEV 
0de1			 
0de1 cd fc 75		.mbounce:	call cin 
0de4 fe 00				cp 0 
0de6 20 f9				jr nz, .mbounce 
0de8			endif 
0de8					; for ease use ex 
0de8			 
0de8					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0de8 21 e6 fc				ld hl, display_fb0 
0deb 22 01 fb				ld (display_fb_active), hl 
0dee			 
0dee cd aa 0d		.mloop:		call clear_display 
0df1 cd cd 0d				call update_display 
0df4			 
0df4					; draw selection id '>' at 1 
0df4			 
0df4					; init start of list display 
0df4			 
0df4 3e 05				ld a, 5 
0df6 32 a4 f9				ld (store_tmp3), a   ; display row count 
0df9 3a a6 f9				ld a,( store_tmp2) 
0dfc 32 a7 f9				ld (store_tmp2+1), a   ; display item count 
0dff			 
0dff					 
0dff			.mitem:	 
0dff			 
0dff			 
0dff 3a a7 f9				ld a,(store_tmp2+1) 
0e02 6f					ld l, a 
0e03 26 00				ld h, 0 
0e05 29					add hl, hl 
0e06 ed 5b a8 f9			ld de, (store_tmp1) 
0e0a 19					add hl, de 
0e0b 7e					ld a, (hl) 
0e0c 23					inc hl 
0e0d 66					ld h,(hl) 
0e0e 6f					ld l, a 
0e0f			 
0e0f cd 07 10				call ishlzero 
0e12 28 1a				jr z, .mdone 
0e14			 
0e14 eb					ex de, hl 
0e15 3a a4 f9				ld a, (store_tmp3) 
0e18 cd bd 0d				call str_at_display 
0e1b					 
0e1b			 
0e1b					; next item 
0e1b 3a a7 f9				ld a, (store_tmp2+1) 
0e1e 3c					inc a 
0e1f 32 a7 f9				ld (store_tmp2+1), a   ; display item count 
0e22			 
0e22			 		; next row 
0e22			 
0e22 3a a4 f9				ld a, (store_tmp3) 
0e25 c6 28				add display_cols 
0e27 32 a4 f9				ld (store_tmp3), a 
0e2a			 
0e2a					; at end of screen? 
0e2a			 
0e2a fe 10				cp display_rows*4 
0e2c 20 d1				jr nz, .mitem 
0e2e			 
0e2e			 
0e2e			.mdone: 
0e2e cd 07 10				call ishlzero 
0e31 28 08				jr z, .nodn 
0e33			 
0e33 3e 78				ld a, display_row_4 
0e35 11 b4 0e				ld de, .mdown 
0e38 cd bd 0d				call str_at_display 
0e3b			 
0e3b					; draw options to fill the screens with active item on line 1 
0e3b					; if current option is 2 or more then display ^ in top 
0e3b			 
0e3b 3a a6 f9		.nodn:		ld a, (store_tmp2) 
0e3e fe 00				cp 0 
0e40 28 08				jr z, .noup 
0e42			 
0e42 3e 00				ld a, 0 
0e44 11 b2 0e				ld de, .mup 
0e47 cd bd 0d				call str_at_display 
0e4a			 
0e4a 3e 02		.noup:		ld a, 2 
0e4c 11 b0 0e				ld de, .msel 
0e4f cd bd 0d				call str_at_display 
0e52			 
0e52					; if current option + 1 is not null then display V in bottom 
0e52					; get key 
0e52 cd cd 0d				call update_display 
0e55			 
0e55			 
0e55					; handle key 
0e55			 
0e55 cd eb 75				call cin_wait 
0e58			 
0e58 fe 05				cp KEY_UP 
0e5a 28 2b				jr z, .mgoup 
0e5c fe 61				cp 'a' 
0e5e 28 27				jr z, .mgoup 
0e60 fe 0a				cp KEY_DOWN 
0e62 28 32				jr z, .mgod 
0e64 fe 7a				cp 'z' 
0e66 28 2e				jr z, .mgod 
0e68 fe 20				cp ' ' 
0e6a 28 34				jr z, .goend 
0e6c fe 0c				cp KEY_RIGHT 
0e6e 28 30				jr z, .goend 
0e70 fe 0d				cp KEY_CR 
0e72 28 2c				jr z, .goend 
0e74 fe 71				cp 'q' 
0e76 28 0b				jr z, .goback 
0e78			 
0e78 fe 0b				cp KEY_LEFT 
0e7a 28 07				jr z, .goback 
0e7c fe 08				cp KEY_BS 
0e7e 28 03				jr z, .goback 
0e80 c3 ee 0d				jp .mloop 
0e83			 
0e83			.goback: 
0e83 3e 00			ld a, 0 
0e85 18 1d			jr .goend2 
0e87			 
0e87				; move up one 
0e87			.mgoup: 
0e87 3a a6 f9				ld a, (store_tmp2) 
0e8a fe 00				cp 0 
0e8c ca ee 0d				jp z, .mloop 
0e8f 3d					dec a 
0e90 32 a6 f9				ld (store_tmp2), a 
0e93 c3 ee 0d				jp .mloop 
0e96			 
0e96				; move down one 
0e96			.mgod: 
0e96 3a a6 f9				ld a, (store_tmp2) 
0e99 3c					inc a 
0e9a 32 a6 f9				ld (store_tmp2), a 
0e9d c3 ee 0d				jp .mloop 
0ea0			 
0ea0			 
0ea0			.goend: 
0ea0					; get selected item number 
0ea0			 
0ea0 3a a6 f9				ld a, (store_tmp2) 
0ea3 3c					inc a 
0ea4			 
0ea4			.goend2: 
0ea4 f5					push af 
0ea5			 
0ea5					; restore active fb 
0ea5					; TODO BUG assumes fb1 
0ea5			 
0ea5 21 45 fc				ld hl, display_fb1 
0ea8 22 01 fb				ld (display_fb_active), hl 
0eab			 
0eab					; restore main regs 
0eab			 
0eab			 
0eab cd cd 0d				call update_display 
0eae			 
0eae f1					pop af 
0eaf			 
0eaf c9				ret 
0eb0			 
0eb0 .. 00		.msel:   db ">",0 
0eb2 .. 00		.mup:   db "^",0 
0eb4 .. 00		.mdown:   db "v",0 
0eb6			 
0eb6			 
0eb6			; eof 
0eb6			 
# End of file firmware_display.asm
0eb6			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0eb6			; random number generators 
0eb6			 
0eb6			 
0eb6			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0eb6			 
0eb6			 
0eb6			;-----> Generate a random number 
0eb6			; output a=answer 0<=a<=255 
0eb6			; all registers are preserved except: af 
0eb6			random: 
0eb6 e5			        push    hl 
0eb7 d5			        push    de 
0eb8 2a e0 fa		        ld      hl,(randData) 
0ebb ed 5f		        ld      a,r 
0ebd 57			        ld      d,a 
0ebe 5e			        ld      e,(hl) 
0ebf 19			        add     hl,de 
0ec0 85			        add     a,l 
0ec1 ac			        xor     h 
0ec2 22 e0 fa		        ld      (randData),hl 
0ec5 d1			        pop     de 
0ec6 e1			        pop     hl 
0ec7 c9			        ret 
0ec8			 
0ec8			 
0ec8			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ec8			 
0ec8			 
0ec8			 
0ec8			;------LFSR------ 
0ec8			;James Montelongo 
0ec8			;optimized by Spencer Putt 
0ec8			;out: 
0ec8			; a = 8 bit random number 
0ec8			RandLFSR: 
0ec8 21 e6 fa		        ld hl,LFSRSeed+4 
0ecb 5e			        ld e,(hl) 
0ecc 23			        inc hl 
0ecd 56			        ld d,(hl) 
0ece 23			        inc hl 
0ecf 4e			        ld c,(hl) 
0ed0 23			        inc hl 
0ed1 7e			        ld a,(hl) 
0ed2 47			        ld b,a 
0ed3 cb 13		        rl e  
0ed5 cb 12			rl d 
0ed7 cb 11		        rl c  
0ed9 17				rla 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 cb 13		        rl e  
0ee3 cb 12			rl d 
0ee5 cb 11		        rl c  
0ee7 17				rla 
0ee8 67			        ld h,a 
0ee9 cb 13		        rl e  
0eeb cb 12			rl d 
0eed cb 11		        rl c  
0eef 17				rla 
0ef0 a8			        xor b 
0ef1 cb 13		        rl e  
0ef3 cb 12			rl d 
0ef5 ac			        xor h 
0ef6 a9			        xor c 
0ef7 aa			        xor d 
0ef8 21 e8 fa		        ld hl,LFSRSeed+6 
0efb 11 e9 fa		        ld de,LFSRSeed+7 
0efe 01 07 00		        ld bc,7 
0f01 ed b8		        lddr 
0f03 12			        ld (de),a 
0f04 c9			        ret 
0f05			 
0f05			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0f05			 
0f05			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0f05			 
0f05			 
0f05			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0f05			 
0f05			prng16: 
0f05			;Inputs: 
0f05			;   (seed1) contains a 16-bit seed value 
0f05			;   (seed2) contains a NON-ZERO 16-bit seed value 
0f05			;Outputs: 
0f05			;   HL is the result 
0f05			;   BC is the result of the LCG, so not that great of quality 
0f05			;   DE is preserved 
0f05			;Destroys: 
0f05			;   AF 
0f05			;cycle: 4,294,901,760 (almost 4.3 billion) 
0f05			;160cc 
0f05			;26 bytes 
0f05 2a da fa		    ld hl,(seed1) 
0f08 44			    ld b,h 
0f09 4d			    ld c,l 
0f0a 29			    add hl,hl 
0f0b 29			    add hl,hl 
0f0c 2c			    inc l 
0f0d 09			    add hl,bc 
0f0e 22 da fa		    ld (seed1),hl 
0f11 2a d8 fa		    ld hl,(seed2) 
0f14 29			    add hl,hl 
0f15 9f			    sbc a,a 
0f16 e6 2d		    and %00101101 
0f18 ad			    xor l 
0f19 6f			    ld l,a 
0f1a 22 d8 fa		    ld (seed2),hl 
0f1d 09			    add hl,bc 
0f1e c9			    ret 
0f1f			 
0f1f			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f1f			 
0f1f			rand32: 
0f1f			;Inputs: 
0f1f			;   (seed1_0) holds the lower 16 bits of the first seed 
0f1f			;   (seed1_1) holds the upper 16 bits of the first seed 
0f1f			;   (seed2_0) holds the lower 16 bits of the second seed 
0f1f			;   (seed2_1) holds the upper 16 bits of the second seed 
0f1f			;   **NOTE: seed2 must be non-zero 
0f1f			;Outputs: 
0f1f			;   HL is the result 
0f1f			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f1f			;Destroys: 
0f1f			;   AF 
0f1f			;Tested and passes all CAcert tests 
0f1f			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f1f			;it has a period of 18,446,744,069,414,584,320 
0f1f			;roughly 18.4 quintillion. 
0f1f			;LFSR taps: 0,2,6,7  = 11000101 
0f1f			;291cc 
0f1f			;seed1_0=$+1 
0f1f			;    ld hl,12345 
0f1f			;seed1_1=$+1 
0f1f			;    ld de,6789 
0f1f			;    ld b,h 
0f1f			;    ld c,l 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    inc l 
0f1f			;    add hl,bc 
0f1f			;    ld (seed1_0),hl 
0f1f			;    ld hl,(seed1_1) 
0f1f			;    adc hl,de 
0f1f			;    ld (seed1_1),hl 
0f1f			;    ex de,hl 
0f1f			;seed2_0=$+1 
0f1f			;    ld hl,9876 
0f1f			;seed2_1=$+1 
0f1f			;    ld bc,54321 
0f1f			;    add hl,hl \ rl c \ rl b 
0f1f			;    ld (seed2_1),bc 
0f1f			;    sbc a,a 
0f1f			;    and %11000101 
0f1f			;    xor l 
0f1f			;    ld l,a 
0f1f			;    ld (seed2_0),hl 
0f1f			;    ex de,hl 
0f1f			;    add hl,bc 
0f1f			;    ret 
0f1f			; 
0f1f			 
0f1f			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f1f			; 20 bytes, 86 cycles (excluding ret) 
0f1f			 
0f1f			; returns   hl = pseudorandom number 
0f1f			; corrupts   a 
0f1f			 
0f1f			; generates 16-bit pseudorandom numbers with a period of 65535 
0f1f			; using the xorshift method: 
0f1f			 
0f1f			; hl ^= hl << 7 
0f1f			; hl ^= hl >> 9 
0f1f			; hl ^= hl << 8 
0f1f			 
0f1f			; some alternative shift triplets which also perform well are: 
0f1f			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f1f			 
0f1f			;  org 32768 
0f1f			 
0f1f			xrnd: 
0f1f 2a de fa		  ld hl,(xrandc)       ; seed must not be 0 
0f22 3e 00		  ld a,0 
0f24 bd			  cp l 
0f25 20 02		  jr nz, .xrnd1 
0f27 2e 01		  ld l, 1 
0f29			.xrnd1: 
0f29			 
0f29 7c			  ld a,h 
0f2a 1f			  rra 
0f2b 7d			  ld a,l 
0f2c 1f			  rra 
0f2d ac			  xor h 
0f2e 67			  ld h,a 
0f2f 7d			  ld a,l 
0f30 1f			  rra 
0f31 7c			  ld a,h 
0f32 1f			  rra 
0f33 ad			  xor l 
0f34 6f			  ld l,a 
0f35 ac			  xor h 
0f36 67			  ld h,a 
0f37			 
0f37 22 de fa		  ld (xrandc),hl 
0f3a			 
0f3a c9			  ret 
0f3b			;  
0f3b			 
0f3b			 
0f3b			;;;; int maths 
0f3b			 
0f3b			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f3b			; Divide 16-bit values (with 16-bit result) 
0f3b			; In: Divide BC by divider DE 
0f3b			; Out: BC = result, HL = rest 
0f3b			; 
0f3b			Div16: 
0f3b 21 00 00		    ld hl,0 
0f3e 78			    ld a,b 
0f3f 06 08		    ld b,8 
0f41			Div16_Loop1: 
0f41 17			    rla 
0f42 ed 6a		    adc hl,hl 
0f44 ed 52		    sbc hl,de 
0f46 30 01		    jr nc,Div16_NoAdd1 
0f48 19			    add hl,de 
0f49			Div16_NoAdd1: 
0f49 10 f6		    djnz Div16_Loop1 
0f4b 17			    rla 
0f4c 2f			    cpl 
0f4d 47			    ld b,a 
0f4e 79			    ld a,c 
0f4f 48			    ld c,b 
0f50 06 08		    ld b,8 
0f52			Div16_Loop2: 
0f52 17			    rla 
0f53 ed 6a		    adc hl,hl 
0f55 ed 52		    sbc hl,de 
0f57 30 01		    jr nc,Div16_NoAdd2 
0f59 19			    add hl,de 
0f5a			Div16_NoAdd2: 
0f5a 10 f6		    djnz Div16_Loop2 
0f5c 17			    rla 
0f5d 2f			    cpl 
0f5e 41			    ld b,c 
0f5f 4f			    ld c,a 
0f60 c9			ret 
0f61			 
0f61			 
0f61			;http://z80-heaven.wikidot.com/math 
0f61			; 
0f61			;Inputs: 
0f61			;     DE and A are factors 
0f61			;Outputs: 
0f61			;     A is not changed 
0f61			;     B is 0 
0f61			;     C is not changed 
0f61			;     DE is not changed 
0f61			;     HL is the product 
0f61			;Time: 
0f61			;     342+6x 
0f61			; 
0f61			Mult16: 
0f61			 
0f61 06 08		     ld b,8          ;7           7 
0f63 21 00 00		     ld hl,0         ;10         10 
0f66 29			       add hl,hl     ;11*8       88 
0f67 07			       rlca          ;4*8        32 
0f68 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f6a 19			         add hl,de   ;--         -- 
0f6b 10 f9		       djnz $-5      ;13*7+8     99 
0f6d c9			ret 
0f6e			 
0f6e			; 
0f6e			; Square root of 16-bit value 
0f6e			; In:  HL = value 
0f6e			; Out:  D = result (rounded down) 
0f6e			; 
0f6e			;Sqr16: 
0f6e			;    ld de,#0040 
0f6e			;    ld a,l 
0f6e			;    ld l,h 
0f6e			;    ld h,d 
0f6e			;    or a 
0f6e			;    ld b,8 
0f6e			;Sqr16_Loop: 
0f6e			;    sbc hl,de 
0f6e			;    jr nc,Sqr16_Skip 
0f6e			;    add hl,de 
0f6e			;Sqr16_Skip: 
0f6e			;    ccf 
0f6e			;    rl d 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    djnz Sqr16_Loop 
0f6e			;    ret 
0f6e			; 
0f6e			; 
0f6e			; Divide 8-bit values 
0f6e			; In: Divide E by divider C 
0f6e			; Out: A = result, B = rest 
0f6e			; 
0f6e			Div8: 
0f6e af			    xor a 
0f6f 06 08		    ld b,8 
0f71			Div8_Loop: 
0f71 cb 13		    rl e 
0f73 17			    rla 
0f74 91			    sub c 
0f75 30 01		    jr nc,Div8_NoAdd 
0f77 81			    add a,c 
0f78			Div8_NoAdd: 
0f78 10 f7		    djnz Div8_Loop 
0f7a 47			    ld b,a 
0f7b 7b			    ld a,e 
0f7c 17			    rla 
0f7d 2f			    cpl 
0f7e c9			    ret 
0f7f			 
0f7f			; 
0f7f			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f7f			; In: Multiply A with DE 
0f7f			; Out: HL = result 
0f7f			; 
0f7f			Mult12U: 
0f7f 2e 00		    ld l,0 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd0 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd0: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd1 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd1: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd2 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd2: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd3 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd3: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 30 01		    jr nc,Mult12U_NoAdd4 
0f98 19			    add hl,de 
0f99			Mult12U_NoAdd4: 
0f99 29			    add hl,hl 
0f9a 87			    add a,a 
0f9b 30 01		    jr nc,Mult12U_NoAdd5 
0f9d 19			    add hl,de 
0f9e			Mult12U_NoAdd5: 
0f9e 29			    add hl,hl 
0f9f 87			    add a,a 
0fa0 30 01		    jr nc,Mult12U_NoAdd6 
0fa2 19			    add hl,de 
0fa3			Mult12U_NoAdd6: 
0fa3 29			    add hl,hl 
0fa4 87			    add a,a 
0fa5 d0			    ret nc 
0fa6 19			    add hl,de 
0fa7 c9			    ret 
0fa8			 
0fa8			; 
0fa8			; Multiply 8-bit value with a 16-bit value (right rotating) 
0fa8			; In: Multiply A with DE 
0fa8			;      Put lowest value in A for most efficient calculation 
0fa8			; Out: HL = result 
0fa8			; 
0fa8			Mult12R: 
0fa8 21 00 00		    ld hl,0 
0fab			Mult12R_Loop: 
0fab cb 3f		    srl a 
0fad 30 01		    jr nc,Mult12R_NoAdd 
0faf 19			    add hl,de 
0fb0			Mult12R_NoAdd: 
0fb0 cb 23		    sla e 
0fb2 cb 12		    rl d 
0fb4 b7			    or a 
0fb5 c2 ab 0f		    jp nz,Mult12R_Loop 
0fb8 c9			    ret 
0fb9			 
0fb9			; 
0fb9			; Multiply 16-bit values (with 32-bit result) 
0fb9			; In: Multiply BC with DE 
0fb9			; Out: BCHL = result 
0fb9			; 
0fb9			Mult32: 
0fb9 79			    ld a,c 
0fba 48			    ld c,b 
0fbb 21 00 00		    ld hl,0 
0fbe 06 10		    ld b,16 
0fc0			Mult32_Loop: 
0fc0 29			    add hl,hl 
0fc1 17			    rla 
0fc2 cb 11		    rl c 
0fc4 30 07		    jr nc,Mult32_NoAdd 
0fc6 19			    add hl,de 
0fc7 ce 00		    adc a,0 
0fc9 d2 cd 0f		    jp nc,Mult32_NoAdd 
0fcc 0c			    inc c 
0fcd			Mult32_NoAdd: 
0fcd 10 f1		    djnz Mult32_Loop 
0fcf 41			    ld b,c 
0fd0 4f			    ld c,a 
0fd1 c9			    ret 
0fd2			 
0fd2			 
0fd2			 
0fd2			; 
0fd2			; Multiply 8-bit values 
0fd2			; In:  Multiply H with E 
0fd2			; Out: HL = result 
0fd2			; 
0fd2			Mult8: 
0fd2 16 00		    ld d,0 
0fd4 6a			    ld l,d 
0fd5 06 08		    ld b,8 
0fd7			Mult8_Loop: 
0fd7 29			    add hl,hl 
0fd8 30 01		    jr nc,Mult8_NoAdd 
0fda 19			    add hl,de 
0fdb			Mult8_NoAdd: 
0fdb 10 fa		    djnz Mult8_Loop 
0fdd c9			    ret 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			;;http://z80-heaven.wikidot.com/math 
0fde			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fde			; 
0fde			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fde			;     ld a,16        ;7 
0fde			;     ld hl,0        ;10 
0fde			;     jp $+5         ;10 
0fde			;.DivLoop: 
0fde			;       add hl,bc    ;-- 
0fde			;       dec a        ;64 
0fde			;       jr z,.DivLoopEnd        ;86 
0fde			; 
0fde			;       sla e        ;128 
0fde			;       rl d         ;128 
0fde			;       adc hl,hl    ;240 
0fde			;       sbc hl,bc    ;240 
0fde			;       jr nc,.DivLoop ;23|21 
0fde			;       inc e        ;-- 
0fde			;       jp .DivLoop+1 
0fde			; 
0fde			;.DivLoopEnd: 
0fde			 
0fde			;HL_Div_C: 
0fde			;Inputs: 
0fde			;     HL is the numerator 
0fde			;     C is the denominator 
0fde			;Outputs: 
0fde			;     A is the remainder 
0fde			;     B is 0 
0fde			;     C is not changed 
0fde			;     DE is not changed 
0fde			;     HL is the quotient 
0fde			; 
0fde			;       ld b,16 
0fde			;       xor a 
0fde			;         add hl,hl 
0fde			;         rla 
0fde			;         cp c 
0fde			;         jr c,$+4 
0fde			;           inc l 
0fde			;           sub c 
0fde			;         djnz $-7 
0fde			 
0fde			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fde			 
0fde			addatohl: 
0fde 85			    add   a, l    ; A = A+L 
0fdf 6f			    ld    l, a    ; L = A+L 
0fe0 8c			    adc   a, h    ; A = A+L+H+carry 
0fe1 95			    sub   l       ; A = H+carry 
0fe2 67			    ld    h, a    ; H = H+carry 
0fe3 c9			ret 
0fe4			 
0fe4			addatode: 
0fe4 83			    add   a, e    ; A = A+L 
0fe5 5f			    ld    e, a    ; L = A+L 
0fe6 8a			    adc   a, d    ; A = A+L+H+carry 
0fe7 93			    sub   e       ; A = H+carry 
0fe8 57			    ld    d, a    ; H = H+carry 
0fe9 c9			ret 
0fea			 
0fea			 
0fea			addatobc: 
0fea 81			    add   a, c    ; A = A+L 
0feb 4f			    ld    c, a    ; L = A+L 
0fec 88			    adc   a, b    ; A = A+L+H+carry 
0fed 91			    sub   c       ; A = H+carry 
0fee 47			    ld    b, a    ; H = H+carry 
0fef c9			ret 
0ff0			 
0ff0			subafromhl: 
0ff0			   ; If A=0 do nothing 
0ff0			    ; Otherwise flip A's sign. Since 
0ff0			    ; the upper byte becomes -1, also 
0ff0			    ; substract 1 from H. 
0ff0 ed 44		    neg 
0ff2 ca fb 0f		    jp    z, Skip 
0ff5 25			    dec   h 
0ff6			     
0ff6			    ; Now add the low byte as usual 
0ff6			    ; Two's complement takes care of 
0ff6			    ; ensuring the result is correct 
0ff6 85			    add   a, l 
0ff7 6f			    ld    l, a 
0ff8 8c			    adc   a, h 
0ff9 95			    sub   l 
0ffa 67			    ld    h, a 
0ffb			Skip: 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			; compare hl and de 
0ffc			; returns:  
0ffc			; if hl = de, z=1, s=0, c0=0 
0ffc			; if hl > de, z=0, s=0, c=0 
0ffc			; if hl < de, z=0, s=1, c=1 
0ffc			cmp16:	 
0ffc b7				or a 
0ffd ed 52			sbc hl,de 
0fff e0				ret po 
1000 7c				ld a,h 
1001 1f				rra 
1002 ee 40			xor 01000000B 
1004 37				scf 
1005 8f				adc a,a 
1006 c9				ret 
1007			 
1007			 
1007			; test if hl contains zero   - A is destroyed 
1007			 
1007			ishlzero:    
1007 b7				or a     ; reset flags 
1008 7c				ld a, h 
1009 b5				or l        	 
100a			 
100a c9				ret 
100b			 
100b			 
100b			 
100b			 
100b			if FORTH_ENABLE_FLOATMATH 
100b			;include "float/bbcmath.z80" 
100b			include "float/lpfpcalc.asm" 
100b			endif 
100b			 
100b			 
100b			; eof 
100b			 
# End of file firmware_maths.asm
100b			include "firmware_strings.asm"   ; string handling  
100b			 
100b			 
100b			; TODO string len 
100b			; input text string, end on cr with zero term 
100b			; a offset into frame buffer to start prompt 
100b			; d is max length 
100b			; e is display size TODO 
100b			; c is current cursor position 
100b			; hl is ptr to where string will be stored and edited directly 
100b			 
100b			 
100b			; TODO check limit of buffer for new inserts 
100b			; TODO check insert does not push beyond buffer 
100b			; TODO scroll in a limited display area 
100b			; TODO scroll whole screen on page wrap 
100b			 
100b			 
100b			; TODO use LCD cursor? 
100b			 
100b			EDIT_V1: equ 0 
100b			EDIT_V2: equ 1 
100b			 
100b			 
100b			 
100b			if EDIT_V2 
100b			input_str: 
100b			 
100b 32 99 fd			    	ld (input_at_pos),a      ; save display position to start 
100e			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
100e 22 9c fd				ld (input_start), hl     ; save ptr to buffer 
1011			;		ld a, c 
1011			;		call addatohl 
1011			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
1011 7a					ld a,d 
1012 32 9b fd			        ld (input_size), a       ; save length of input area 
1015 79					ld a, c 
1016 32 8a fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
1019 7b					ld a,e 
101a 32 9a fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
101d			 
101d			 
101d					; add a trailing space to make screen refresh nicer 
101d			 
101d					;ld hl, (input_start) 
101d					;push hl 
101d					;ld a, 0 
101d					;call strlent 
101d					;ld a, l 
101d					;pop hl 
101d					;call addatohl 
101d					;dec hl 
101d					;ld a, ' ' 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld a, 0 
101d					;ld (hl), a 
101d			 
101d			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
101d					; init cursor shape if not set by the cin routines 
101d 21 f6 fa				ld hl, cursor_shape 
1020			if BASE_KEV 
1020 3e ff				ld a, 255 
1022			else 
1022					ld a, '#' 
1022			endif 
1022 77					ld (hl), a 
1023 23					inc hl 
1024 3e 00				ld a, 0 
1026 77					ld (hl), a 
1027			 
1027 3e 09				ld a, CUR_BLINK_RATE 
1029 32 95 fd				ld (input_cur_flash), a 
102c 3e 01				ld a, 1 
102e 32 94 fd				ld (input_cur_onoff),a 
1031			.inmain:	 
1031			 
1031 cd 59 11				call input_disp_ref 
1034			 
1034					; save current length of string 
1034			 
1034 2a 9c fd				ld hl, (input_start) 
1037 3e 00				ld a, 0 
1039 cd 4f 13				call strlent 
103c 7d					ld a,l 
103d 32 8f fd				ld (input_len), a 
1040			 
1040					;call input_disp_oncur 
1040			 
1040					; display current state of input buffer 
1040			 
1040					; clean any backspace chars 
1040			 
1040 3e 20				ld a, " " 
1042 32 f6 f0				ld (scratch),a 
1045 3e 00				ld a, 0 
1047 32 f7 f0				ld (scratch+1),a 
104a 3a 99 fd				ld a,(input_at_pos) 
104d 85					add l 
104e 11 f6 f0				ld de, scratch 
1051 cd bd 0d				call str_at_display 
1054			 
1054					; pause 1ms 
1054			 
1054 3e 01				ld a, 1 
1056 cd d2 0c				call aDelayInMS 
1059			 
1059			; display cursor if visible on this cycle 
1059			 
1059					; dec flash counter 
1059 3a 95 fd				ld a, (input_cur_flash) 
105c 3d					dec a 
105d 32 95 fd				ld (input_cur_flash), a 
1060 fe 00				cp 0 
1062 20 0d				jr nz, .inochgstate 
1064			 
1064			 
1064					; reset on change of state 
1064 3e 09				ld a, CUR_BLINK_RATE 
1066 32 95 fd				ld (input_cur_flash), a 
1069			 
1069					; change state 
1069 3a 94 fd				ld a,(input_cur_onoff) 
106c ed 44				neg 
106e 32 94 fd				ld (input_cur_onoff),a 
1071			 
1071			 
1071			 
1071			 
1071					; TODO is cursor visible? 
1071					; TODO if so then over write the char at curspos pos with the cursor shape 
1071			 
1071								 
1071			 
1071			.inochgstate: 
1071 3a 94 fd				ld a,(input_cur_onoff) 
1074 fe ff				cp 255 
1076 28 0e				jr z, .skipcursor 
1078 3a 99 fd				ld a, (input_at_pos) 
107b 47					ld b, a 
107c 3a 8a fd				ld a, (input_cursor) 
107f 80					add b 
1080 11 f6 fa				ld de, cursor_shape 
1083					 
1083 cd bd 0d				call str_at_display 
1086			 
1086			.skipcursor: 
1086				if DEBUG_INPUTV2 
1086			 
1086					ld a,(input_at_pos) 
1086					ld hl, LFSRSeed 
1086					call hexout 
1086					ld a, (input_cursor) 
1086					ld hl, LFSRSeed+2 
1086					call hexout 
1086					ld a,(input_size) 
1086					ld hl, LFSRSeed+4 
1086					call hexout 
1086			 
1086					ld a,(input_cur_onoff) 
1086					ld hl, LFSRSeed+6 
1086					call hexout 
1086			 
1086					ld a,(input_cur_flash) 
1086					ld hl, LFSRSeed+8 
1086					call hexout 
1086			 
1086					ld a,(input_len) 
1086					ld hl, LFSRSeed+10 
1086					call hexout 
1086					ld hl, LFSRSeed+12 
1086					ld a, 0 
1086					ld (hl),a 
1086					ld a, display_row_4 
1086					ld de, LFSRSeed 
1086					call str_at_display 
1086				endif 
1086 cd cd 0d				call update_display 
1089			 
1089					; TODO keyboard processing 
1089			 
1089			if BASE_CPM 
1089					call cin_wait 
1089			else 
1089 cd fc 75				call cin    ; _wait 
108c			endif 
108c fe 00				cp 0 
108e ca 31 10				jp z, .inmain 
1091			 
1091 fe 0b				cp KEY_LEFT    ; cursor left 
1093 ca 4b 11				jp z, input_left 
1096				 
1096 fe 0c				cp KEY_RIGHT      ; cursor right 
1098 ca 52 11				jp z, input_right 
109b			 
109b fe 0d				cp KEY_CR 
109d c8					ret z 
109e			 
109e fe 08				cp KEY_BS 
10a0 ca c0 11				jp z, input_delchar 
10a3			 
10a3 fe 06				cp KEY_NEXTWORD 
10a5 ca cc 10				jp z, input_nxtword 
10a8			 
10a8 fe 07				cp KEY_PREVWORD 
10aa ca f3 10				jp z, input_prvword 
10ad			 
10ad fe 0e				cp KEY_HOME    ; jump to start of line 
10af 20 08				jr nz, .ikh 
10b1 3e 00				ld a, 0 
10b3 32 8a fd				ld (input_cursor), a 
10b6 ca 31 10				jp z, .inmain 
10b9			.ikh: 
10b9			 
10b9 fe 0f				cp KEY_END     ; jump to end of line 
10bb 20 09				jr nz, .ike 
10bd 3a 8f fd				ld a, (input_len) 
10c0 32 8a fd				ld (input_cursor),a 
10c3 ca 31 10				jp z, .inmain 
10c6			.ike: 
10c6 fe 05			        cp KEY_UP      ; recall last command 
10c8 c8					ret z 
10c9			;jr nz, .irec 
10c9			; TODO next word 
10c9			; TODO prev word 
10c9			;  
10c9			; 
10c9			;	ld hl, scratch 
10c9			;	ld de, os_last_cmd 
10c9			;	call strcpy 
10c9			;		jp  .inmain 
10c9			.irec: 
10c9			;		jr .instr1 
10c9			 
10c9			 
10c9			 
10c9					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
10c9			 
10c9			; TODO return if any special keys are given 
10c9			;		ld l, a 
10c9			;		ld a, 28 ; KEY_F12   ; 27 
10c9			;		sub l 
10c9			;		ret m 
10c9			;		ld a, l 
10c9					; if no special key then insert as a char 
10c9			 
10c9 c3 92 11				jp input_inschr 
10cc			 
10cc				 
10cc			input_nxtword: 
10cc				; jump to start next word after the cursor 
10cc			 
10cc			.insknwn:	 
10cc cd 88 11				call input_curptr	 
10cf 7e					ld a,(hl)	 
10d0 fe 00				cp 0 
10d2 ca 31 10				jp z, .inmain    ; end of string 
10d5			 
10d5			; if we are on a word, then move off of it 
10d5			 
10d5 fe 20				cp ' ' 
10d7 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10d9 21 8a fd				ld hl, input_cursor 
10dc 34					inc (hl) 
10dd 18 ed				jr .insknwn 
10df			 
10df			.inspace: 
10df			 
10df cd 88 11				call input_curptr	 
10e2 7e					ld a,(hl)	 
10e3 fe 00				cp 0 
10e5 ca 31 10				jp z, .inmain    ; end of string 
10e8			 
10e8			; if we are on a word, then move off of it 
10e8			 
10e8 fe 20				cp ' ' 
10ea c2 31 10				jp nz, .inmain     ; we are on non space so at next word 
10ed 21 8a fd				ld hl, input_cursor 
10f0 34					inc (hl) 
10f1 18 ec				jr .inspace 
10f3			 
10f3			 
10f3			 
10f3			 
10f3			input_prvword: 
10f3				; jump to the start of previous word before the cursor 
10f3			 
10f3			; where are we to start with currently? 
10f3			 
10f3 cd 88 11				call input_curptr	 
10f6 7e					ld a, (hl) 
10f7 fe 20				cp ' ' 
10f9 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10fb			 
10fb			 
10fb			 
10fb			.inskpwn:	 
10fb 3a 8a fd				ld a,(input_cursor) 
10fe fe 00				cp 0 
1100 ca 31 10				jp z, .inmain    ; start of string 
1103			 
1103			;if we are on a word, then move off of it 
1103			 
1103 cd 88 11				call input_curptr	 
1106 7e					ld a, (hl) 
1107 fe 20				cp ' ' 
1109 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
110b					;jp z, .inmain    ; start of string 
110b 21 8a fd				ld hl, input_cursor 
110e 35					dec (hl) 
110f 18 ea				jr .inskpwn 
1111			.iwstart: 
1111 21 8a fd				ld hl, input_cursor 
1114 34					inc (hl) 
1115 c3 31 10				jp .inmain 
1118					 
1118			 
1118			.inspacep: 
1118			 
1118					;jp .inmain    ; start of string 
1118			 
1118			 
1118			 
1118 3a 8a fd				ld a,(input_cursor) 
111b fe 00				cp 0 
111d ca 31 10				jp z, .inmain    ; start of string 
1120			 
1120			; if we are on a word, then move off of it 
1120			 
1120 cd 88 11				call input_curptr	 
1123 7e					ld a, (hl) 
1124 fe 20				cp ' ' 
1126 c2 2f 11				jp nz, .incharp     ; we are on non space so at end of prev word 
1129 21 8a fd				ld hl, input_cursor 
112c 35					dec (hl) 
112d 18 e9				jr .inspacep 
112f			 
112f			 
112f			.incharp:	 
112f					; eat the word to get to the start 
112f 3a 8a fd				ld a,(input_cursor) 
1132 fe 00				cp 0 
1134 ca 31 10				jp z, .inmain    ; start of string 
1137			 
1137			; if we are on a word, then move off of it 
1137			 
1137 cd 88 11				call input_curptr	 
113a 7e					ld a, (hl) 
113b fe 20				cp ' ' 
113d 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
113f 21 8a fd				ld hl, input_cursor 
1142 35					dec (hl) 
1143 18 ea				jr .incharp 
1145			.ipwordst: 
1145					; at space before the prev word so reposition over it 
1145 21 8a fd				ld hl, input_cursor 
1148 34					inc (hl) 
1149 18 b0				jr .inskpwn 
114b					 
114b			 
114b			 
114b			input_left: 
114b				; move cursor left 
114b 21 8a fd			ld hl, input_cursor 
114e 35				dec (hl) 
114f			;	cp 0 
114f			;	jp z, .inmain    ; ignore left as at the start of the string 
114f c3 31 10			jp .inmain 
1152			 
1152			input_right: 
1152				; move cursor right 
1152				 
1152				;ld a, (input_size) 
1152				;ld b, a 
1152 21 8a fd			ld hl, input_cursor 
1155 34				inc (hl) 
1156				;dec b 
1156				;cp 0 
1156				;jp z, .inmain   ; ignore as at end of the string buffer 
1156				;ld a, b 
1156				;inc a 
1156				;ld (input_cursor), a 
1156 c3 31 10			jp .inmain 
1159			 
1159			 
1159			 
1159			input_disp_ref: 
1159				; display the text from start of buffer (ie full refresh) 
1159 3a 99 fd			ld a, (input_at_pos) 
115c 2a 9c fd			ld hl,(input_start) 
115f eb				ex de, hl 
1160 cd bd 0d			call str_at_display  
1163 c9				ret 
1164			input_disp_oncur: 
1164				; display the text from cursor position to end of buffer 
1164				; TODO position start of string at cursor position on screen 
1164				; TODO draw from that point on 
1164 3a 8a fd			ld a, (input_cursor) 
1167 47				ld b, a 
1168 3a 99 fd			ld a, (input_at_pos) 
116b 80				add b 
116c 48				ld c, b     ; save a 
116d 78				ld a, b     ; inc string start for cursor 
116e 2a 9c fd			ld hl,(input_start) 
1171 cd de 0f			call addatohl 
1174 eb				ex de, hl 
1175 79				ld a, c 
1176 cd bd 0d			call str_at_display  
1179 c9				ret 
117a			 
117a			input_nxtw: 
117a				; Find next word 
117a c9				ret 
117b			 
117b			input_prvw: 
117b				; Find previous word 
117b c9				ret 
117c			 
117c			input_lenrem:   
117c				; Calculate the length of string remaining from current cursor 
117c				; position to end of buffer (exc null term) 
117c				 
117c 3a 8a fd			ld a, (input_cursor) 
117f 4f				ld c, a 
1180 3a 9b fd			ld a, (input_size) 
1183 91				sub c 
1184 06 00			ld b, 0 
1186 0d				dec c 
1187 c9				ret	 
1188			 
1188			input_curptr: 
1188				; calc address of the character under the cursor 
1188				 
1188 2a 9c fd			ld hl, (input_start) 
118b 3a 8a fd			ld a, (input_cursor) 
118e cd de 0f			call addatohl 
1191 c9				ret 
1192			 
1192			input_inschr: 
1192				; Insert char at cursor position 
1192 f5				push af   ; save char 
1193				;call input_lenrem    ; get bc length of remaining string 
1193			 
1193				 
1193 cd 88 11			call input_curptr 
1196			;	ld hl, (input_start) 
1196			;	ld a, (input_cursor) 
1196			;	call addatohl 
1196				;push hl   ; save to come back to 
1196			 
1196				; shift everything up one to end of buffer 
1196			 
1196				;push hl 
1196				;dec de 
1196				;inc de 
1196			;	ldir 
1196				 
1196				;pop hl 
1196			 
1196				; are we adding to the end of line? 
1196			 
1196 3a 8a fd			ld a, (input_cursor) 
1199 47				ld b, a 
119a 3a 8f fd			ld a, (input_len) 
119d b8				cp b 
119e 20 09			jr nz, .insmid   ; no, insert in middle of text 
11a0			 
11a0				; tack on the end of the line 
11a0 f1				pop af 
11a1 77				ld (hl), a   ; save new char 
11a2 23				inc hl 
11a3 3e 00			ld a, 0 
11a5 77				ld (hl), a 
11a6 c3 52 11			jp input_right 
11a9				 
11a9			.insmid: 
11a9				; hl has insertion point so move everything up one to allow for insertion 
11a9				;call input_shiftright 
11a9 f1				pop af 
11aa			 
11aa			.shufinsmid: 
11aa 47				ld b, a     ; b contains new char, c prev char at this position  
11ab 7e				ld a, (hl) 
11ac			 
11ac fe 00			cp 0    ; at end of string need to then dump new char and add term 
11ae 28 07			jr z, .endinsmid 
11b0 4f				ld c, a 
11b1 78				ld a, b 
11b2 77				ld (hl), a 
11b3 23				inc hl 
11b4 79				ld a, c 
11b5 18 f3			jr .shufinsmid 
11b7				 
11b7			 
11b7			 
11b7			 
11b7			.endinsmid: 
11b7 78				ld a, b 
11b8 77				ld (hl), a 
11b9 23				inc hl 
11ba 3e 00			ld a, 0 
11bc 77				ld (hl), a 
11bd			 
11bd			 
11bd			;	ld (hl), a   ; save new char 
11bd			 
11bd c3 52 11			jp input_right 
11c0			 
11c0			;input_shiftright: 
11c0			;	; shift text right at cursor, hl has shift start 
11c0			;	push hl 
11c0			;	push de 
11c0			;	push bc 
11c0			; 
11c0			; 
11c0			;	; move to end of string past zero term 
11c0			;	ld hl,(input_start) 
11c0			;	ld a, (input_len) 
11c0			;	call addatohl 
11c0			;	inc hl 
11c0			;;	inc hl 
11c0			;;	inc hl 
11c0			;	ld a, 0 
11c0			;	ld (hl), a 
11c0			;;	dec hl 
11c0			;	 
11c0			;;	ld (hl), a 
11c0			;;	dec hl 
11c0			; 
11c0			;	push hl 
11c0			;	pop de 
11c0			;	inc de 
11c0			;	 
11c0			; 
11c0			;;	ld hl,(input_start) 
11c0			;;	ld a, (input_cursor) 
11c0			;;	call addatohl 
11c0			; 
11c0			; 
11c0			;	; calc how many bytes from cursor pos to end of string we need to shift 
11c0			;	call input_lenrem    ; get bc length of remaining string 
11c0			;	;ld a, (input_cursor) 
11c0			;	;ld c, a 
11c0			;	ld a, (input_len) 
11c0			;	cp 2 
11c0			;	jr z, .iskipzero	 
11c0			;	;sub c 
11c0			;	;inc a 
11c0			;	;ld c, a 
11c0			;	;ld b, 0 
11c0			;	inc c 
11c0			;	inc c 
11c0			;	; move data 
11c0			;	lddr 
11c0			;.iskipzero: 
11c0			; 
11c0			;	pop bc 
11c0			;	pop de 
11c0			;	pop hl 
11c0			;	ret	 
11c0			 
11c0			input_delchar: 
11c0				; Delete char at cursor position 
11c0 cd 7c 11			call input_lenrem    ; get bc length of remaining string 
11c3 2a 9c fd			ld hl, (input_start) 
11c6 3a 8a fd			ld a, (input_cursor) 
11c9 cd de 0f			call addatohl 
11cc			 
11cc e5				push hl 
11cd d1				pop de 
11ce 1b				dec de 
11cf			 
11cf			.dl:	 
11cf ed a0			ldi  
11d1 7e				ld a, (hl) 
11d2 fe 00			cp 0 
11d4 28 02			jr z, .dldone 
11d6 18 f7			jr .dl 
11d8			.dldone: 
11d8 ed a0			ldi 
11da			 
11da c3 4b 11			jp input_left 
11dd			 
11dd			 
11dd			endif 
11dd			 
11dd			 
11dd			 
11dd			if EDIT_V1 
11dd			input_str: 
11dd			 
11dd				    	ld (input_at_pos),a      ; save display position to start 
11dd					add c 
11dd					ld (input_at_cursor),a	; save draw pos of cursor 
11dd					ld (input_start), hl     ; save ptr to buffer 
11dd					ld a, c 
11dd					call addatohl 
11dd					ld (input_ptr), hl     ; save ptr to point under the cursor 
11dd					ld a,d 
11dd				        ld (input_size), a       ; save length of input area 
11dd					ld a, c 
11dd					ld (input_cursor),a      ; init cursor start position  
11dd					ld a,e 
11dd				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
11dd					 
11dd					 
11dd			 
11dd			;		ld a,(input_ptr) 
11dd			;		ld (input_under_cursor),a 	; save what is under the cursor 
11dd			 
11dd			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
11dd					; init cursor shape if not set by the cin routines 
11dd					ld hl, cursor_shape 
11dd			if BASE_KEV 
11dd					ld a, 255 
11dd			else 
11dd					ld a, '#' 
11dd			endif 
11dd					ld (hl), a 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl), a 
11dd			 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					ld a, 1 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'I' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd			.is1:		; main entry loop 
11dd			 
11dd			 
11dd			 
11dd					; pause 1ms 
11dd			 
11dd					ld a, 1 
11dd					call aDelayInMS 
11dd			 
11dd					; dec flash counter 
11dd					ld a, (input_cur_flash) 
11dd					dec a 
11dd					ld (input_cur_flash), a 
11dd					cp 0 
11dd					jr nz, .nochgstate 
11dd			 
11dd			 
11dd					; change state 
11dd					ld a,(input_cur_onoff) 
11dd					neg 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			 
11dd					; reset on change of state 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd			.nochgstate: 
11dd					 
11dd					 
11dd			 
11dd					; display cursor  
11dd			 
11dd			;		ld hl, (input_start) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			 
11dd					; get char under cursor and replace with cursor 
11dd			ld hl, (input_ptr) 
11dd			;		ld a, (hl) 
11dd			;		ld (input_under_cursor),a 
11dd			;		ld a, '_' 
11dd			;		ld (hl), a 
11dd			 
11dd					; display string 
11dd			 
11dd					ld de, (input_start) 
11dd					ld a, (input_at_pos) 
11dd					call str_at_display 
11dd			;	        call update_display 
11dd			 
11dd					; find place to put the cursor 
11dd			;		add h 
11dd			;		ld l, display_row_1 
11dd			;		sub l 
11dd			; (input_at_pos) 
11dd					;ld c, a 
11dd			;		ld a, (input_cursor) 
11dd			;		ld l, (input_at_pos) 
11dd			;		;ld b, h 
11dd			;		add l 
11dd			;		ld (input_at_cursor),a 
11dd					;ld l,h 
11dd			 
11dd			;		ld h, 0 
11dd			;		ld l,(input_at_pos) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
11dd			;		call subafromhl 
11dd			;		ld a,l 
11dd			;		ld (input_at_cursor), a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					ld a, (hardware_diag) 
11dd					cp 0 
11dd					jr z, .skip_input_diag 
11dd			 
11dd					ld a,(input_at_pos) 
11dd					ld hl, LFSRSeed 
11dd					call hexout 
11dd					ld a, (input_cursor) 
11dd					ld hl, LFSRSeed+2 
11dd					call hexout 
11dd					ld a,(input_at_cursor) 
11dd					ld hl, LFSRSeed+4 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_onoff) 
11dd					ld hl, LFSRSeed+6 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_flash) 
11dd					ld hl, LFSRSeed+8 
11dd					call hexout 
11dd			 
11dd					ld a,(input_len) 
11dd					ld hl, LFSRSeed+10 
11dd					call hexout 
11dd					ld hl, LFSRSeed+12 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd					ld a, display_row_4 
11dd					ld de, LFSRSeed 
11dd					call str_at_display 
11dd					.skip_input_diag: 
11dd				endif 
11dd			 
11dd					; decide on if we are showing the cursor this time round 
11dd			 
11dd					ld a, (input_cur_onoff) 
11dd					cp 255 
11dd					jr z, .skipcur 
11dd			 
11dd			 
11dd					ld a,(input_at_cursor) 
11dd					ld de, cursor_shape 
11dd					call str_at_display 
11dd			 
11dd					; save length of current input string 
11dd					ld hl, (input_start) 
11dd					ld a, 0 
11dd					call strlent 
11dd					ld a,l 
11dd					ld (input_len),a 
11dd			 
11dd			.skipcur: 
11dd			 
11dd				        call update_display 
11dd					 
11dd			 
11dd			 
11dd					; wait 
11dd				 
11dd					; TODO loop without wait to flash the cursor and char under cursor	 
11dd					call cin    ; _wait 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 
11dd			 
11dd					; get ptr to char to input into 
11dd			 
11dd					ld c,a 
11dd					ld hl, (input_start) 
11dd					ld a, (input_cursor) 
11dd					call addatohl 
11dd					ld (input_ptr), hl 
11dd					ld a,c 
11dd			 
11dd					; replace char under cursor 
11dd			 
11dd			;		ld hl, (input_ptr) 
11dd			;		ld a, (input_under_cursor) 	; get what is under the cursor 
11dd			;		ld (hl), a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'i' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					cp KEY_HOME 
11dd					jr nz, .iske 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor),a 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					jp .is1 
11dd					 
11dd			.iske:		cp KEY_END 
11dd					jr nz, .isknw 
11dd					jp .is1 
11dd			 
11dd			.isknw:		cp KEY_NEXTWORD 
11dd					jr nz, .iskpw 
11dd			 
11dd			.isknwm:	ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0 
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd					jr .isknwm 
11dd			 
11dd			.iskpw:		cp KEY_PREVWORD 
11dd					jr nz, .iskl 
11dd			.iskpwm:	 
11dd					ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0  
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd					jr .iskpwm 
11dd			 
11dd			 
11dd			.iskl:		cp KEY_LEFT 
11dd					jr nz, .isk1 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk1:		cp KEY_RIGHT 
11dd					jr nz, .isk2 
11dd			 
11dd					ld a,(input_len)		; TODO BUG why cant i load e direct? 
11dd					ld e,a 
11dd					ld a, (input_cursor) 
11dd					cp e 
11dd					jp z, .is1		; at the end of string so dont go right 
11dd			 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk2:		cp KEY_UP 
11dd			 
11dd					jr nz, .isk3 
11dd			 
11dd					; swap last command with the current on 
11dd			 
11dd					; move cursor to start of string 
11dd					ld hl, (input_start) 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					 
11dd					; swap input and last command buffers 
11dd			 
11dd					ld hl, os_cli_cmd 
11dd					ld de, os_last_cmd 
11dd					ld b, 255 
11dd			.swap1:		ld a, (hl) 
11dd					ld c,a 
11dd					ld a, (de) 
11dd					ld (hl), a 
11dd					ld a,c 
11dd					ld (de),a 
11dd					inc hl 
11dd					inc de 
11dd					djnz .swap1 
11dd			 
11dd			 
11dd			 
11dd			 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk3:		cp KEY_BS 
11dd					jr nz, .isk4 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					; hl is source 
11dd					; de needs to be source - 1 
11dd			 
11dd			;		ld a, 0 
11dd			;		dec hl 
11dd			;		ld (hl), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					; shift all data 
11dd			 
11dd					push hl 
11dd					inc hl 
11dd					pop de 
11dd					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
11dd					ld c,a 
11dd					ld b,0 
11dd					ldir  
11dd			 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					; remove char 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld de,.iblank 
11dd					call str_at_display 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk4:		cp KEY_CR 
11dd					jr z, .endinput 
11dd			 
11dd					; else add the key press to the end 
11dd			 
11dd					ld c, a			; save key pressed 
11dd			 
11dd					ld a,(hl)		; get what is currently under char 
11dd			 
11dd					cp 0			; we are at the end of the string 
11dd					jr nz, .onchar 
11dd					 
11dd					; add a char to the end of the string 
11dd				 
11dd					ld (hl),c 
11dd					inc hl 
11dd			;		ld a,' ' 
11dd			;		ld (hl),a 
11dd			;		inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					dec hl 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc a				; TODO check max string length and scroll  
11dd					ld (input_cursor), a		; inc cursor pos 
11dd							 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, '+' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					jp .is1 
11dd					 
11dd			 
11dd			 
11dd					; if on a char then insert 
11dd			.onchar: 
11dd			 
11dd					; TODO over flow check: make sure insert does not blow out buffer 
11dd			 
11dd					; need to do some maths to use lddr 
11dd			 
11dd					push hl   ; save char pos 
11dd					push bc 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a, (input_len) 
11dd					call addatohl  		; end of string 
11dd					inc hl 
11dd					inc hl		; past zero term 
11dd					push hl 
11dd					inc hl 
11dd					push hl  
11dd			 
11dd								; start and end of lddr set, now how much to move? 
11dd			 
11dd							 
11dd					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11dd					ld b,a 
11dd					ld a,(input_len) 
11dd					ld e,a 
11dd					sub b 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd			 
11dd					ld b,0 
11dd					ld c,a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'i' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					pop de 
11dd					pop hl 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'I' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					lddr 
11dd				 
11dd			 
11dd			 
11dd					; TODO have a key for insert/overwrite mode???? 
11dd					pop bc 
11dd					pop hl 
11dd					ld (hl), c		; otherwise overwrite current char 
11dd					 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.endinput:	; TODO look for end of string 
11dd			 
11dd					; add trailing space for end of token 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a,(input_len) 
11dd					call addatohl 
11dd					ld a, ' ' 
11dd					ld (hl),a 
11dd					; TODO eof of parse marker 
11dd			 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					ret 
11dd			 
11dd			.iblank: db " ",0 
11dd			 
11dd			 
11dd			input_str_prev:	ld (input_at_pos), a 
11dd					ld (input_start), hl 
11dd					ld a,1			; add cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					ld (input_ptr), hl 
11dd					ld a,d 
11dd					ld (input_size), a 
11dd					ld a,0 
11dd					ld (input_cursor),a 
11dd			.instr1:	 
11dd			 
11dd					; TODO do block cursor 
11dd					; TODO switch cursor depending on the modifer key 
11dd			 
11dd					; update cursor shape change on key hold 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl), a 
11dd			 
11dd					; display entered text 
11dd					ld a,(input_at_pos) 
11dd			            	CALL fLCD_Pos       ;Position cursor to location in A 
11dd			            	LD   de, (input_start) 
11dd			            	CALL fLCD_Str       ;Display string pointed to by DE 
11dd			 
11dd					call cin 
11dd					cp 0 
11dd					jr z, .instr1 
11dd			 
11dd					; proecess keyboard controls first 
11dd			 
11dd					ld hl,(input_ptr) 
11dd			 
11dd					cp KEY_CR	 ; pressing enter ends input 
11dd					jr z, .instrcr 
11dd			 
11dd					cp KEY_BS 	; back space 
11dd					jr nz, .instr2 
11dd					; process back space 
11dd			 
11dd					; TODO stop back space if at start of string 
11dd					dec hl 
11dd					dec hl ; to over write cursor 
11dd					ld a,(cursor_shape) 
11dd					;ld a,0 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a," " 
11dd					ld (hl),a 
11dd					ld (input_ptr),hl 
11dd					 
11dd			 
11dd					jr .instr1 
11dd			 
11dd			.instr2:	cp KEY_LEFT    ; cursor left 
11dd					jr nz, .instr3 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd				 
11dd			.instr3:	cp KEY_RIGHT      ; cursor right 
11dd					jr nz, .instr4 
11dd					inc hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr4:	cp KEY_HOME    ; jump to start of line 
11dd					jr nz, .instr5 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr5:	cp KEY_END     ; jump to end of line 
11dd					jr nz, .instr6 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			.instr6:        cp KEY_UP      ; recall last command 
11dd					jr nz, .instrnew 
11dd			 
11dd				ld hl, scratch 
11dd				ld de, os_last_cmd 
11dd				call strcpy 
11dd					jr .instr1 
11dd			 
11dd			 
11dd			.instrnew:	; no special key pressed to see if we have room to store it 
11dd			 
11dd					; TODO do string size test 
11dd			 
11dd					dec hl ; to over write cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd					ld (input_ptr),hl 
11dd					 
11dd					jr .instr1 
11dd			.instrcr:	dec hl		; remove cursor 
11dd					ld a,' '	; TODO add a trailing space for safety 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					; if at end of line scroll up    
11dd					; TODO detecting only end of line 4 for scroll up  
11dd			 
11dd					;ld   
11dd			 
11dd					ret 
11dd			 
11dd			 
11dd			endif 
11dd			; strcpy hl = dest, de source 
11dd			 
11dd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11de b7			            OR   A              ;Null terminator? 
11df c8			            RET  Z              ;Yes, so finished 
11e0 1a					ld a,(de) 
11e1 77					ld (hl),a 
11e2 13			            INC  DE             ;Point to next character 
11e3 23					inc hl 
11e4 18 f7		            JR   strcpy       ;Repeat 
11e6 c9					ret 
11e7			 
11e7			 
11e7			; TODO string_at  
11e7			; pass string which starts with lcd offset address and then null term string 
11e7			 
11e7			; TODO string to dec 
11e7			; TODO string to hex 
11e7			; TODO byte to string hex 
11e7			; TODO byte to string dec 
11e7			 
11e7			 
11e7			 
11e7			; from z80uartmonitor 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11e7			; pass hl for where to put the text 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7 c5			hexout:	PUSH BC 
11e8 f5					PUSH AF 
11e9 47					LD B, A 
11ea					; Upper nybble 
11ea cb 3f				SRL A 
11ec cb 3f				SRL A 
11ee cb 3f				SRL A 
11f0 cb 3f				SRL A 
11f2 cd 02 12				CALL tohex 
11f5 77					ld (hl),a 
11f6 23					inc hl	 
11f7					 
11f7					; Lower nybble 
11f7 78					LD A, B 
11f8 e6 0f				AND 0FH 
11fa cd 02 12				CALL tohex 
11fd 77					ld (hl),a 
11fe 23					inc hl	 
11ff					 
11ff f1					POP AF 
1200 c1					POP BC 
1201 c9					RET 
1202					 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			tohex: 
1202 e5					PUSH HL 
1203 d5					PUSH DE 
1204 16 00				LD D, 0 
1206 5f					LD E, A 
1207 21 0f 12				LD HL, .DATA 
120a 19					ADD HL, DE 
120b 7e					LD A, (HL) 
120c d1					POP DE 
120d e1					POP HL 
120e c9					RET 
120f			 
120f			.DATA: 
120f 30					DEFB	30h	; 0 
1210 31					DEFB	31h	; 1 
1211 32					DEFB	32h	; 2 
1212 33					DEFB	33h	; 3 
1213 34					DEFB	34h	; 4 
1214 35					DEFB	35h	; 5 
1215 36					DEFB	36h	; 6 
1216 37					DEFB	37h	; 7 
1217 38					DEFB	38h	; 8 
1218 39					DEFB	39h	; 9 
1219 41					DEFB	41h	; A 
121a 42					DEFB	42h	; B 
121b 43					DEFB	43h	; C 
121c 44					DEFB	44h	; D 
121d 45					DEFB	45h	; E 
121e 46					DEFB	46h	; F 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
121f			;;    subtract $30, if result > 9 then subtract $7 more 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			atohex: 
121f d6 30				SUB $30 
1221 fe 0a				CP 10 
1223 f8					RET M		; If result negative it was 0-9 so we're done 
1224 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1226 c9					RET		 
1227			 
1227			 
1227			 
1227			 
1227			; Get 2 ASCII characters as hex byte from pointer in hl 
1227			 
1227			BYTERD: 
1227 16 00			LD	D,00h		;Set up 
1229 cd 31 12			CALL	HEXCON		;Get byte and convert to hex 
122c 87				ADD	A,A		;First nibble so 
122d 87				ADD	A,A		;multiply by 16 
122e 87				ADD	A,A		; 
122f 87				ADD	A,A		; 
1230 57				LD	D,A		;Save hi nibble in D 
1231			HEXCON: 
1231 7e				ld a, (hl)		;Get next chr 
1232 23				inc hl 
1233 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1235 fe 0a			CP	00Ah		;Is it 0-9 ? 
1237 38 02			JR	C,NALPHA	;If so miss next bit 
1239 d6 07			SUB	007h		;Else convert alpha 
123b			NALPHA: 
123b b2				OR	D		;Add hi nibble back 
123c c9				RET			; 
123d			 
123d			 
123d			; 
123d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
123d			; Since the routines get_byte and therefore get_nibble are called, only valid 
123d			; characters (0-9a-f) are accepted. 
123d			; 
123d			;get_word        push    af 
123d			;                call    get_byte        ; Get the upper byte 
123d			;                ld      h, a 
123d			;                call    get_byte        ; Get the lower byte 
123d			;                ld      l, a 
123d			;                pop     af 
123d			;                ret 
123d			; 
123d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
123d			; the routine get_nibble is used only valid characters are accepted - the  
123d			; input routine only accepts characters 0-9a-f. 
123d			; 
123d c5			get_byte:        push    bc              ; Save contents of B (and C) 
123e 7e					ld a,(hl) 
123f 23					inc hl 
1240 cd 65 12		                call    nibble2val      ; Get upper nibble 
1243 cb 07		                rlc     a 
1245 cb 07		                rlc     a 
1247 cb 07		                rlc     a 
1249 cb 07		                rlc     a 
124b 47			                ld      b, a            ; Save upper four bits 
124c 7e					ld a,(hl) 
124d cd 65 12		                call    nibble2val      ; Get lower nibble 
1250 b0			                or      b               ; Combine both nibbles 
1251 c1			                pop     bc              ; Restore B (and C) 
1252 c9			                ret 
1253			; 
1253			; Get a hexadecimal digit from the serial line. This routine blocks until 
1253			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1253			; to the serial line interface. The lower 4 bits of A contain the value of  
1253			; that particular digit. 
1253			; 
1253			;get_nibble      ld a,(hl)           ; Read a character 
1253			;                call    to_upper        ; Convert to upper case 
1253			;                call    is_hex          ; Was it a hex digit? 
1253			;                jr      nc, get_nibble  ; No, get another character 
1253			 ;               call    nibble2val      ; Convert nibble to value 
1253			 ;               call    print_nibble 
1253			 ;               ret 
1253			; 
1253			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1253			; A valid hexadecimal digit is denoted by a set C flag. 
1253			; 
1253			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1253			;                ret     nc              ; Yes 
1253			;                cp      '0'             ; Less than '0'? 
1253			;                jr      nc, is_hex_1    ; No, continue 
1253			;                ccf                     ; Complement carry (i.e. clear it) 
1253			;                ret 
1253			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1253			;                ret     c               ; Yes 
1253			;                cp      'A'             ; Less than 'A'? 
1253			;                jr      nc, is_hex_2    ; No, continue 
1253			;                ccf                     ; Yes - clear carry and return 
1253			;                ret 
1253			;is_hex_2        scf                     ; Set carry 
1253			;                ret 
1253			; 
1253			; Convert a single character contained in A to upper case: 
1253			; 
1253 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1255 d8			                ret     c 
1256 fe 7b		                cp      'z' + 1         ; > 'z'? 
1258 d0			                ret     nc              ; Nothing to do, either 
1259 e6 5f		                and     $5f             ; Convert to upper case 
125b c9			                ret 
125c			 
125c			 
125c			to_lower: 
125c			 
125c			   ; if char is in [A-Z] make it lower case 
125c			 
125c			   ; enter : a = char 
125c			   ; exit  : a = lower case char 
125c			   ; uses  : af 
125c			 
125c fe 41		   cp 'A' 
125e d8			   ret c 
125f			    
125f fe 5b		   cp 'Z'+1 
1261 d0			   ret nc 
1262			    
1262 f6 20		   or $20 
1264 c9			   ret 
1265			 
1265			; 
1265			; Expects a hexadecimal digit (upper case!) in A and returns the 
1265			; corresponding value in A. 
1265			; 
1265 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1267 38 02		                jr      c, nibble2val_1 ; Yes 
1269 d6 07		                sub     7               ; Adjust for A-F 
126b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
126d e6 0f		                and     $f              ; Only return lower 4 bits 
126f c9			                ret 
1270			; 
1270			; Print_nibble prints a single hex nibble which is contained in the lower  
1270			; four bits of A: 
1270			; 
1270			;print_nibble    push    af              ; We won't destroy the contents of A 
1270			;                and     $f              ; Just in case... 
1270			;                add     a, '0'             ; If we have a digit we are done here. 
1270			;                cp      '9' + 1         ; Is the result > 9? 
1270			;                jr      c, print_nibble_1 
1270			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1270			;print_nibble_1  call    putc            ; Print the nibble and 
1270			;                pop     af              ; restore the original value of A 
1270			;                ret 
1270			;; 
1270			;; Send a CR/LF pair: 
1270			; 
1270			;crlf            push    af 
1270			;                ld      a, cr 
1270			;                call    putc 
1270			;                ld      a, lf 
1270			;                call    putc 
1270			;                pop     af 
1270			;                ret 
1270			; 
1270			; Print_word prints the four hex digits of a word to the serial line. The  
1270			; word is expected to be in HL. 
1270			; 
1270			;print_word      push    hl 
1270			;                push    af 
1270			;                ld      a, h 
1270			;                call    print_byte 
1270			;                ld      a, l 
1270			;                call    print_byte 
1270			;                pop     af 
1270			;                pop     hl 
1270			;                ret 
1270			; 
1270			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1270			; The byte to be printed is expected to be in A. 
1270			; 
1270			;print_byte      push    af              ; Save the contents of the registers 
1270			;                push    bc 
1270			;                ld      b, a 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                call    print_nibble    ; Print high nibble 
1270			;                ld      a, b 
1270			;                call    print_nibble    ; Print low nibble 
1270			;                pop     bc              ; Restore original register contents 
1270			;                pop     af 
1270			;                ret 
1270			 
1270			 
1270			 
1270			 
1270			 
1270			fourehexhl:  
1270 7e				ld a,(hl) 
1271 cd 1f 12			call atohex 
1274 cb 3f				SRL A 
1276 cb 3f				SRL A 
1278 cb 3f				SRL A 
127a cb 3f				SRL A 
127c 47				ld b, a 
127d 23				inc hl 
127e 7e				ld a,(hl) 
127f 23				inc hl 
1280 cd 1f 12			call atohex 
1283 80				add b 
1284 57				ld d,a 
1285 7e				ld a,(hl) 
1286 cd 1f 12			call atohex 
1289 cb 3f				SRL A 
128b cb 3f				SRL A 
128d cb 3f				SRL A 
128f cb 3f				SRL A 
1291 47				ld b, a 
1292 23				inc hl 
1293 7e				ld a,(hl) 
1294 23				inc hl 
1295 cd 1f 12			call atohex 
1298 80				add b 
1299 5f				ld e, a 
129a d5				push de 
129b e1				pop hl 
129c c9				ret 
129d			 
129d			; pass hl. returns z set if the byte at hl is a digit 
129d			;isdigithl:  
129d			;	push bc 
129d			;	ld a,(hl) 
129d			;	cp ':' 
129d			;	jr nc, .isdf 		; > 
129d			;	cp '0' 
129d			;	jr c, .isdf		; < 
129d			; 
129d			;	; TODO find a better way to set z 
129d			; 
129d			;	ld b,a 
129d			;	cp b 
129d			;	pop bc 
129d			;	ret 
129d			; 
129d			;.isdf:	; not digit so clear z 
129d			; 
129d			;	; TODO find a better way to unset z 
129d			; 
129d			;	ld b,a 
129d			;	inc b 
129d			;	cp b 
129d			; 
129d			;	pop bc 
129d			;	ret 
129d				 
129d				 
129d			 
129d			 
129d			; pass hl as the four byte address to load 
129d			 
129d			get_word_hl:  
129d e5				push hl 
129e cd 3d 12			call get_byte 
12a1				 
12a1 47				ld b, a 
12a2			 
12a2 e1				pop hl 
12a3 23				inc hl 
12a4 23				inc hl 
12a5			 
12a5			; TODO not able to handle a-f  
12a5 7e				ld a,(hl) 
12a6			;	;cp ':' 
12a6			;	cp 'g' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp 'G' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp '0' 
12a6			;	jr c, .single_byte_hl		; < 
12a6			 
12a6				;call isdigithl 
12a6 fe 00			cp 0 
12a8 28 06			jr z, .single_byte_hl 
12aa			 
12aa			.getwhln:   ; hex word so get next byte 
12aa			 
12aa cd 3d 12			call get_byte 
12ad 6f				ld l, a 
12ae 60				ld h,b 
12af c9				ret 
12b0 68			.single_byte_hl:   ld l,b 
12b1 26 00				ld h,0 
12b3 c9					ret 
12b4			 
12b4			 
12b4			 
12b4			 
12b4 21 23 1d			ld hl,asc+1 
12b7			;	ld a, (hl) 
12b7			;	call nibble2val 
12b7 cd 3d 12			call get_byte 
12ba			 
12ba			;	call fourehexhl 
12ba 32 2a f1			ld (scratch+52),a 
12bd				 
12bd 21 28 f1			ld hl,scratch+50 
12c0 22 19 f4			ld (os_cur_ptr),hl 
12c3			 
12c3 c9				ret 
12c4			 
12c4			 
12c4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12c4			 
12c4			; Decimal Unsigned Version 
12c4			 
12c4			;Number in a to decimal ASCII 
12c4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12c4			;Example: display a=56 as "056" 
12c4			;input: a = number 
12c4			;Output: a=0,value of a in the screen 
12c4			;destroys af,bc (don't know about hl and de) 
12c4			DispAToASCII: 
12c4 0e 9c			ld	c,-100 
12c6 cd d0 12			call	.Na1 
12c9 0e f6			ld	c,-10 
12cb cd d0 12			call	.Na1 
12ce 0e ff			ld	c,-1 
12d0 06 2f		.Na1:	ld	b,'0'-1 
12d2 04			.Na2:	inc	b 
12d3 81				add	a,c 
12d4 38 fc			jr	c,.Na2 
12d6 91				sub	c		;works as add 100/10/1 
12d7 f5				push af		;safer than ld c,a 
12d8 78				ld	a,b		;char is in b 
12d9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12d9 f1				pop af		;safer than ld a,c 
12da c9				ret 
12db			 
12db			; Decimal Signed Version 
12db			 
12db			; DispA 
12db			; -------------------------------------------------------------- 
12db			; Converts a signed integer value to a zero-terminated ASCII 
12db			; string representative of that value (using radix 10). 
12db			; -------------------------------------------------------------- 
12db			; INPUTS: 
12db			;     HL     Value to convert (two's complement integer). 
12db			;     DE     Base address of string destination. (pointer). 
12db			; -------------------------------------------------------------- 
12db			; OUTPUTS: 
12db			;     None 
12db			; -------------------------------------------------------------- 
12db			; REGISTERS/MEMORY DESTROYED 
12db			; AF HL 
12db			; -------------------------------------------------------------- 
12db			 
12db			;DispHLToASCII: 
12db			;   push    de 
12db			;   push    bc 
12db			; 
12db			;; Detect sign of HL. 
12db			;    bit    7, h 
12db			;    jr     z, ._DoConvert 
12db			; 
12db			;; HL is negative. Output '-' to string and negate HL. 
12db			;    ld     a, '-' 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			; 
12db			;; Negate HL (using two's complement) 
12db			;    xor    a 
12db			;    sub    l 
12db			;    ld     l, a 
12db			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12db			;    sbc    a, h 
12db			;    ld     h, a 
12db			; 
12db			;; Convert HL to digit characters 
12db			;._DoConvert: 
12db			;    ld     b, 0     ; B will count character length of number 
12db			;-   ld     a, 10 
12db			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12db			;    push   af 
12db			;    inc    b 
12db			;    ld     a, h 
12db			;    or     l 
12db			;    jr     nz, - 
12db			; 
12db			;; Retrieve digits from stack 
12db			;-   pop    af 
12db			;    or     $30 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			;    djnz   - 
12db			; 
12db			;; Terminate string with NULL 
12db			;    xor    a 
12db			;    ld     (de), a 
12db			; 
12db			;    pop    bc 
12db			;    pop    de 
12db			;    ret 
12db			 
12db			;Comments 
12db			; 
12db			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12db			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12db			;    Note that the output string will not be fixed-width. 
12db			; 
12db			;Example Usage 
12db			; 
12db			;    ld    hl, -1004 
12db			;    ld    de, OP1 
12db			;    call  DispA 
12db			;    ld    hl, OP1 
12db			;    syscall  PutS 
12db			 
12db			 
12db			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12db			 
12db			 
12db			;Converts an ASCII string to an unsigned 16-bit integer 
12db			;Quits when it reaches a non-decimal digit 
12db			 
12db			string_to_uint16: 
12db			atoui_16: 
12db			;Input: 
12db			;     DE points to the string 
12db			;Outputs: 
12db			;     HL is the result 
12db			;     A is the 8-bit value of the number 
12db			;     DE points to the byte after the number 
12db			;Destroys: 
12db			;     BC 
12db			;       if the string is non-empty, BC is HL/10 
12db			;Size:  24 bytes 
12db			;Speed: 42+d(104+{0,9}) 
12db			;       d is the number of digits in the number 
12db			;       max is 640 cycles for a 5 digit number 
12db			;Assuming no leading zeros: 
12db			;1 digit:  146cc 
12db			;2 digit:  250cc 
12db			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12db			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12db			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12db			;avg: 544.81158447265625cc (544+13297/16384) 
12db			;=============================================================== 
12db 21 00 00		  ld hl,0 
12de			.u16a: 
12de 1a			  ld a,(de) 
12df d6 30		  sub 30h 
12e1 fe 0a		  cp 10 
12e3 d0			  ret nc 
12e4 13			  inc de 
12e5 44			  ld b,h 
12e6 4d			  ld c,l 
12e7 29			  add hl,hl 
12e8 29			  add hl,hl 
12e9 09			  add hl,bc 
12ea 29			  add hl,hl 
12eb 85			  add a,l 
12ec 6f			  ld l,a 
12ed 30 ef		  jr nc,.u16a 
12ef 24			  inc h 
12f0 c3 de 12		  jp .u16a 
12f3			 
12f3			 
12f3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12f3			 
12f3			;written by Zeda 
12f3			;Converts a 16-bit unsigned integer to an ASCII string. 
12f3			 
12f3			uitoa_16: 
12f3			;Input: 
12f3			;   DE is the number to convert 
12f3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12f3			;Output: 
12f3			;   HL points to the null-terminated ASCII string 
12f3			;      NOTE: This isn't necessarily the same as the input HL. 
12f3 d5			  push de 
12f4 c5			  push bc 
12f5 f5			  push af 
12f6 eb			  ex de,hl 
12f7			 
12f7 01 f0 d8		  ld bc,-10000 
12fa 3e 2f		  ld a,'0'-1 
12fc 3c			  inc a 
12fd 09			  add hl,bc  
12fe 38 fc		   jr c,$-2 
1300 12			  ld (de),a 
1301 13			  inc de 
1302			 
1302 01 e8 03		  ld bc,1000 
1305 3e 3a		  ld a,'9'+1 
1307 3d			  dec a  
1308 09			  add hl,bc  
1309 30 fc		   jr nc,$-2 
130b 12			  ld (de),a 
130c 13			  inc de 
130d			 
130d 01 9c ff		  ld bc,-100 
1310 3e 2f		  ld a,'0'-1 
1312 3c			  inc a  
1313 09			  add hl,bc  
1314 38 fc		   jr c,$-2 
1316 12			  ld (de),a 
1317 13			  inc de 
1318			 
1318 7d			  ld a,l 
1319 26 3a		  ld h,'9'+1 
131b 25			  dec h  
131c c6 0a		  add a,10  
131e 30 fb		   jr nc,$-3 
1320 c6 30		  add a,'0' 
1322 eb			  ex de,hl 
1323 72			  ld (hl),d 
1324 23			  inc hl 
1325 77			  ld (hl),a 
1326 23			  inc hl 
1327 36 00		  ld (hl),0 
1329			 
1329			;Now strip the leading zeros 
1329 0e fa		  ld c,-6 
132b 09			  add hl,bc 
132c 3e 30		  ld a,'0' 
132e 23			  inc hl  
132f be			  cp (hl)  
1330 28 fc		  jr z,$-2 
1332			 
1332			;Make sure that the string is non-empty! 
1332 7e			  ld a,(hl) 
1333 b7			  or a 
1334 20 01		  jr nz,.atoub 
1336 2b			  dec hl 
1337			.atoub: 
1337			 
1337 f1			  pop af 
1338 c1			  pop bc 
1339 d1			  pop de 
133a c9			  ret 
133b			 
133b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
133b			 
133b			toUpper: 
133b			;A is the char. 
133b			;If A is a lowercase letter, this sets it to the matching uppercase 
133b			;18cc or 30cc or 41cc 
133b			;avg: 26.75cc 
133b fe 61		  cp 'a' 
133d d8			  ret c 
133e fe 7b		  cp 'z'+1 
1340 d0			  ret nc 
1341 d6 20		  sub 'a'-'A' 
1343 c9			  ret 
1344			 
1344			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1344			 
1344			; String Length 
1344			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1344			 
1344			; Get the length of the null-terminated string starting at $8000 hl 
1344			;    LD     HL, $8000 
1344			 
1344			strlenz: 
1344			 
1344 af			    XOR    A               ; Zero is the value we are looking for. 
1345 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1346 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1347			                           ; 65, 536 bytes (the entire addressable memory space). 
1347 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1349			 
1349			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1349 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
134a 6f			    LD     L, A             ; number of bytes 
134b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
134d 2b			    DEC    HL              ; Compensate for null. 
134e c9				ret 
134f			 
134f			; Get the length of the A terminated string starting at $8000 hl 
134f			;    LD     HL, $8000 
134f			 
134f			strlent: 
134f			 
134f			                  ; A is the value we are looking for. 
134f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1351 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1353			                           ; 65, 536 bytes (the entire addressable memory space). 
1353 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1355			 
1355			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1355 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1357 2e 00		    LD     L, 0             ; number of bytes 
1359 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
135b 2b			    DEC    HL              ; Compensate for null. 
135c c9				ret 
135d			 
135d			 
135d			;Comparing Strings 
135d			 
135d			;IN    HL     Address of string1. 
135d			;      DE     Address of string2. 
135d			 
135d			; doc given but wrong??? 
135d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
135d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
135d			; tested 
135d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
135d			 
135d			strcmp_old: 
135d e5			    PUSH   HL 
135e d5			    PUSH   DE 
135f			 
135f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1360 be			    CP     (HL)            ; (want to minimize work). 
1361 38 01		    JR     C, Str1IsBigger 
1363 7e			    LD     A, (HL) 
1364			 
1364			Str1IsBigger: 
1364 4f			    LD     C, A             ; Put length in BC 
1365 06 00		    LD     B, 0 
1367 13			    INC    DE              ; Increment pointers to meat of string. 
1368 23			    INC    HL 
1369			 
1369			CmpLoop: 
1369 1a			    LD     A, (DE)          ; Compare bytes. 
136a ed a1		    CPI 
136c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
136e 13			    INC    DE              ; Update pointer. 
136f ea 69 13		    JP     PE, CmpLoop 
1372			 
1372 d1			    POP    DE 
1373 e1			    POP    HL 
1374 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1375 be			    CP     (HL) 
1376 c9			    RET 
1377			 
1377			NoMatch: 
1377 2b			    DEC    HL 
1378 be			    CP     (HL)            ; Compare again to affect carry. 
1379 d1			    POP    DE 
137a e1			    POP    HL 
137b c9			    RET 
137c			 
137c			;; test strmp 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr z, .z1 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z1: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr z, .z2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr c, .c1 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c1: 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr c, .c2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;	NEXTW 
137c			;.str1:   db "string1",0 
137c			;.str2:   db "string2",0 
137c			 
137c			; only care about direct match or not 
137c			; hl and de strings 
137c			; zero set if the same 
137c			 
137c			strcmp: 
137c 1a				ld a, (de) 
137d be				cp (hl) 
137e 28 02			jr z, .ssame 
1380 b7				or a 
1381 c9				ret 
1382			 
1382			.ssame:  
1382 fe 00			cp 0 
1384 c8				ret z 
1385			 
1385 23				inc hl 
1386 13				inc de 
1387 18 f3			jr strcmp 
1389				 
1389				 
1389			 
1389			;Copyright (c) 2014, Luke Maurits 
1389			;All rights reserved. 
1389			; 
1389			;Redistribution and use in source and binary forms, with or without 
1389			;modification, are permitted provided that the following conditions are met: 
1389			; 
1389			;* Redistributions of source code must retain the above copyright notice, this 
1389			;  list of conditions and the following disclaimer. 
1389			; 
1389			;* Redistributions in binary form must reproduce the above copyright notice, 
1389			;  this list of conditions and the following disclaimer in the documentation 
1389			;  and/or other materials provided with the distribution. 
1389			; 
1389			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1389			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1389			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1389			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1389			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1389			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1389			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1389			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1389			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1389			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1389			 
1389			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1389			 
1389			StrictStrCmp: 
1389				; Load next chars of each string 
1389 1a				ld a, (de) 
138a 47				ld b, a 
138b 7e				ld a, (hl) 
138c				; Compare 
138c b8				cp b 
138d				; Return non-zero if chars don't match 
138d c0				ret nz 
138e				; Check for end of both strings 
138e fe 00			cp "\0" 
1390				; Return if strings have ended 
1390 c8				ret z 
1391				; Otherwise, advance to next chars 
1391 23				inc hl 
1392 13				inc de 
1393 18 f4			jr StrictStrCmp 
1395			 
1395			;end 
1395			; eof 
1395			 
1395			 
1395			 
1395			 
1395			 
1395			 
# End of file firmware_strings.asm
1395			include "firmware_memory.asm"   ; malloc and free  
1395			 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			.mallocsize: db "Wants malloc >256",0 
1395			.mallocasize: db "MALLOC gives >256",0 
1395			.malloczero: db "MALLOC gives zero",0 
1395			 
1395			malloc_guard_zerolen: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395				ld de, 0 
1395			        call cmp16 
1395				jr nz, .lowalloz 
1395			 
1395				push hl 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .malloczero 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395				call bp_on 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395			.lowalloz: 
1395			 
1395			 
1395				pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_entry: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowalloc 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocsize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395				jr .lowdone 
1395			.lowalloc: 
1395			 
1395			 
1395				pop hl 
1395			.lowdone:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_exit: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowallocx 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocasize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395				pop de 
1395				pop hl 
1395			 
1395				CALLMONITOR 
1395				jr .lowdonex 
1395			.lowallocx: 
1395			 
1395				pop hl 
1395			.lowdonex:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			endif 
1395			 
1395			if MALLOC_2 
1395			; Z80 Malloc and Free Functions 
1395			 
1395			; Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc: 
1395				 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_entry 
1395			endif 
1395			 
1395			 
1395			 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "mal" 
1395						CALLMONITOR 
1395					endif 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of size into A 
1395			    or h               ; Check if size is zero 
1395			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1395			 
1395			    ; Allocate memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma1" 
1395						CALLMONITOR 
1395					endif 
1395			    call malloc_internal ; Call internal malloc function 
1395			    pop af             ; Restore AF register 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret                ; Return 
1395			 
1395			; Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free: 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of pointer into A 
1395			    or h               ; Check if pointer is NULL 
1395			    jp z, free_exit    ; If pointer is NULL, exit 
1395			 
1395			    ; Free memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395			    call free_internal  ; Call internal free function 
1395			    pop af             ; Restore AF register 
1395			    ret                ; Return 
1395			 
1395			; Internal Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc_internal: 
1395			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to requested size 
1395			    ex de, hl          ; Save total size in DE, and keep it in HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			 
1395			    ; Search for free memory block 
1395			    ld de, (heap_end)  ; Load end of heap into DE 
1395			    ld bc, 0           ; Initialize counter 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			malloc_search_loop: 
1395			    ; Check if current block is free 
1395			    ld a, (hl)         ; Load current block's status (free or used) 
1395			    cp 0               ; Compare with zero (free) 
1395			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1395			 
1395			    ; Check if current block is large enough 
1395			    ld a, (hl+1)       ; Load high byte of block size 
1395			    cp l               ; Compare with low byte of requested size 
1395			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1395			 
1395			    ld a, (hl+2)       ; Load low byte of block size 
1395			    cp h               ; Compare with high byte of requested size 
1395			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1395			 
1395			    ; Mark block as used 
1395			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1395			 
1395			    ; Calculate remaining space in block 
1395			    ld bc, 0           ; Clear BC 
1395			    add hl, bc         ; Increment HL to point to start of data block 
1395			    add hl, de         ; HL = HL + DE (total size) 
1395			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to start of data block 
1395			 
1395			    ; Save pointer to allocated block in HL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma5" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			malloc_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3           ; Size of management overhead 
1395			    add hl, bc         ; Move to the next block 
1395			    inc de             ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e            ; Load low byte of heap end address 
1395			    cp (hl)            ; Compare with low byte of current address 
1395			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1395			    ld a, d            ; Load high byte of heap end address 
1395			    cp 0               ; Check if it's zero (end of memory) 
1395			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, allocation failed 
1395			    xor a              ; Set result to NULL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma6" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			malloc_exit: 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma7" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			; Internal Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free_internal: 
1395			    ld de, (heap_start) ; Load start of heap into DE 
1395			    ld bc, 0            ; Initialize counter 
1395			 
1395			free_search_loop: 
1395			    ; Check if current block contains the pointer 
1395			    ld a, l             ; Load low byte of pointer 
1395			    cp (hl+1)           ; Compare with high byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			    ld a, h             ; Load high byte of pointer 
1395			    cp (hl+2)           ; Compare with low byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			 
1395			    ; Mark block as free 
1395			    ld (hl), 0          ; Set status byte to indicate free block 
1395			    ret                 ; Return 
1395			 
1395			free_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3            ; Size of management overhead 
1395			    add hl, bc          ; Move to the next block 
1395			    inc de              ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e             ; Load low byte of heap end address 
1395			    cp (hl)             ; Compare with low byte of current address 
1395			    jr nz, free_search_loop  ; If not equal, continue searching 
1395			    ld a, d             ; Load high byte of heap end address 
1395			    cp 0                ; Check if it's zero (end of memory) 
1395			    jr nz, free_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, pointer is not found in heap 
1395			    ret 
1395			 
1395			free_exit: 
1395			    ret                 ; Return 
1395			 
1395			; Define heap start and end addresses 
1395			;heap_start:    .dw 0xC000   ; Start of heap 
1395			;heap_end:      .dw 0xE000   ; End of heap 
1395			 
1395			endif 
1395			 
1395			 
1395			if MALLOC_1 
1395			 
1395			 
1395			 
1395			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1395			 
1395			;moved to firmware.asm 
1395			;heap_start        .equ  0x9000      ; Starting address of heap 
1395			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1395			 
1395			;      .org 0 
1395			;      jp    main 
1395			 
1395			 
1395			;      .org  0x100 
1395			;main: 
1395			;      ld    HL, 0x8100 
1395			;      ld    SP, HL 
1395			; 
1395			;      call  heap_init 
1395			; 
1395			;      ; Make some allocations 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9004 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9014 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9024 
1395			; 
1395			;      ; Free some allocations 
1395			;      ld    HL, 0x9014 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9004 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9024 
1395			;      call  free 
1395			; 
1395			; 
1395			;      halt 
1395			 
1395			 
1395			;------------------------------------------------------------------------------ 
1395			;     heap_init                                                               : 
1395			;                                                                             : 
1395			; Description                                                                 : 
1395			;     Initialise the heap and make it ready for malloc and free operations.   : 
1395			;                                                                             : 
1395			;     The heap is maintained as a linked list, starting with an initial       : 
1395			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1395			;     the first free block in the heap. Each block then points to the next    : 
1395			;     free block within the heap, and the free list ends at the first block   : 
1395			;     with a null pointer to the next free block.                             : 
1395			;                                                                             : 
1395			; Parameters                                                                  : 
1395			;     Inputs are compile-time only. Two defines which specify the starting    : 
1395			;     address of the heap and its size are required, along with a memory      : 
1395			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1395			;     principally stores a pointer to the first free block in the heap.       : 
1395			;                                                                             : 
1395			; Returns                                                                     : 
1395			;     Nothing                                                                 : 
1395			;------------------------------------------------------------------------------ 
1395			heap_init: 
1395 e5			      push  HL 
1396			 
1396			      ; Initialise free list struct 
1396 21 0e 80		      ld    HL, heap_start 
1399 22 0a 80		      ld    (free_list), HL 
139c 21 00 00		      ld    HL, 0 
139f 22 0c 80		      ld    (free_list+2), HL 
13a2			 
13a2			      ; Insert first free block at bottom of heap, consumes entire heap 
13a2 21 cd f0		      ld    HL, heap_start+heap_size-4 
13a5 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13a8 21 bf 70		      ld    HL, heap_size-4 
13ab 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13ae			 
13ae			      ; Insert end of free list block at top of heap - two null words will 
13ae			      ; terminate the free list 
13ae 21 00 00		      ld    HL, 0 
13b1 22 cf f0		      ld    (heap_start+heap_size-2), HL 
13b4 22 cd f0		      ld    (heap_start+heap_size-4), HL 
13b7			 
13b7 e1			      pop   HL 
13b8			 
13b8 c9			      ret 
13b9			 
13b9			 
13b9			;------------------------------------------------------------------------------ 
13b9			;     malloc                                                                  : 
13b9			;                                                                             : 
13b9			; Description                                                                 : 
13b9			;     Allocates the wanted space from the heap and returns the address of the : 
13b9			;     first useable byte of the allocation.                                   : 
13b9			;                                                                             : 
13b9			;     Allocations can happen in one of two ways:                              : 
13b9			;                                                                             : 
13b9			;     1. A free block may be found which is the exact size wanted. In this    : 
13b9			;        case the block is removed from the free list and retuedn to the      : 
13b9			;        caller.                                                              : 
13b9			;     2. A free block may be found which is larger than the size wanted. In   : 
13b9			;        this case, the larger block is split into two. The first portion of  : 
13b9			;        this block will become the requested space by the malloc call and    : 
13b9			;        is returned to the caller. The second portion becomes a new free     : 
13b9			;        block, and the free list is adjusted to maintain continuity via this : 
13b9			;        newly created block.                                                 : 
13b9			;                                                                             : 
13b9			;     malloc does not set any initial value in the allocated space, the       : 
13b9			;     caller is required to do this as required.                              : 
13b9			;                                                                             : 
13b9			;     This implementation of malloc uses the stack exclusively, and is        : 
13b9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13b9			;     advisable to disable interrupts before calling malloc, and recommended  : 
13b9			;     to avoid the use of malloc inside ISRs in general.                      : 
13b9			;                                                                             : 
13b9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13b9			;                                                                             : 
13b9			; Parameters                                                                  : 
13b9			;     HL  Number of bytes wanted                                              : 
13b9			;                                                                             : 
13b9			; Returns                                                                     : 
13b9			;     HL  Address of the first useable byte of the allocation                 : 
13b9			;                                                                             : 
13b9			; Flags                                                                       : 
13b9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13b9			;                                                                             : 
13b9			; Stack frame                                                                 : 
13b9			;       |             |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     BC      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     DE      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     IX      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |  prev_free  |                                                       : 
13b9			;   +4  +-------------+                                                       : 
13b9			;       |  this_free  |                                                       : 
13b9			;   +2  +-------------+                                                       : 
13b9			;       |  next_free  |                                                       : 
13b9			;   +0  +-------------+                                                       : 
13b9			;       |             |                                                       : 
13b9			;                                                                             : 
13b9			;------------------------------------------------------------------------------ 
13b9			 
13b9			 
13b9			;malloc: 
13b9			; 
13b9			;	SAVESP ON 1 
13b9			; 
13b9			;	call malloc_code 
13b9			; 
13b9			;	CHECKSP ON 1 
13b9			;	ret 
13b9			 
13b9			 
13b9			malloc: 
13b9 c5			      push  BC 
13ba d5			      push  DE 
13bb dd e5		      push  IX 
13bd			if DEBUG_FORTH_MALLOC_HIGH 
13bd			call malloc_guard_entry 
13bd			endif 
13bd			 
13bd					if DEBUG_FORTH_MALLOC 
13bd						DMARK "mal" 
13bd						CALLMONITOR 
13bd					endif 
13bd 7c			      ld    A, H                    ; Exit if no space requested 
13be b5			      or    L 
13bf ca 7e 14		      jp    Z, malloc_early_exit 
13c2			 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			; 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			 
13c2			 
13c2			 
13c2			 
13c2					if DEBUG_FORTH_MALLOC 
13c2						DMARK "maA" 
13c2						CALLMONITOR 
13c2					endif 
13c2			      ; Set up stack frame 
13c2 eb			      ex    DE, HL 
13c3 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13c6 39			      add   HL, SP 
13c7 f9			      ld    SP, HL 
13c8 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13cc dd 39		      add   IX, SP 
13ce			 
13ce			      ; Setup initial state 
13ce 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13d1 19			      add   HL, DE 
13d2			 
13d2 44			      ld    B, H                    ; Move want to BC 
13d3 4d			      ld    C, L 
13d4			 
13d4 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13d7 dd 75 04		      ld    (IX+4), L 
13da dd 74 05		      ld    (IX+5), H 
13dd			 
13dd 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13de 23			      inc   HL 
13df 56			      ld    D, (HL) 
13e0 dd 73 02		      ld    (IX+2), E 
13e3 dd 72 03		      ld    (IX+3), D 
13e6 eb			      ex    DE, HL                  ; this_free ptr into HL 
13e7			 
13e7					if DEBUG_FORTH_MALLOC 
13e7						DMARK "maB" 
13e7						CALLMONITOR 
13e7					endif 
13e7			      ; Loop through free block list to find some space 
13e7			malloc_find_space: 
13e7 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13e8 23			      inc   HL 
13e9 56			      ld    D, (HL) 
13ea			 
13ea 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13eb b3			      or    E 
13ec ca 78 14		      jp    Z, malloc_no_space 
13ef			 
13ef dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13f2 dd 72 01		      ld    (IX+1), D 
13f5			 
13f5			      ; Does this block have enough space to make the allocation? 
13f5 23			      inc   HL                      ; Load free block size into DE 
13f6 5e			      ld    E, (HL) 
13f7 23			      inc   HL 
13f8 56			      ld    D, (HL) 
13f9			 
13f9 eb			      ex    DE, HL                  ; Check size of block against want 
13fa b7			      or    A                       ; Ensure carry flag clear 
13fb ed 42		      sbc   HL, BC 
13fd e5			      push  HL                      ; Store the result for later (new block size) 
13fe			 
13fe ca 4d 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1401 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1403			 
1403			      ; this_free block is not big enough, setup ptrs to test next free block 
1403 e1			      pop   HL                      ; Discard previous result 
1404			 
1404 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1407 dd 66 03		      ld    H, (IX+3) 
140a dd 75 04		      ld    (IX+4), L 
140d dd 74 05		      ld    (IX+5), H 
1410			 
1410 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1413 dd 66 01		      ld    H, (IX+1) 
1416 dd 75 02		      ld    (IX+2), L 
1419 dd 74 03		      ld    (IX+3), H 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "MA>" 
141c						CALLMONITOR 
141c					endif 
141c 18 c9		      jr    malloc_find_space 
141e			 
141e			      ; split a bigger block into two - requested size and remaining size 
141e			malloc_alloc_split: 
141e					if DEBUG_FORTH_MALLOC 
141e						DMARK "MAs" 
141e						CALLMONITOR 
141e					endif 
141e eb			      ex    DE, HL                  ; Calculate address of new free block 
141f 2b			      dec   HL 
1420 2b			      dec   HL 
1421 2b			      dec   HL 
1422 09			      add   HL, BC 
1423			 
1423			      ; Create a new block and point it at next_free 
1423 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1426 dd 56 01		      ld    D, (IX+1) 
1429			 
1429 73			      ld    (HL), E                 ; Store next_free ptr into new block 
142a 23			      inc   HL 
142b 72			      ld    (HL), D 
142c			 
142c d1			      pop   DE                      ; Store size of new block into new block 
142d 23			      inc   HL 
142e 73			      ld    (HL), E 
142f 23			      inc   HL 
1430 72			      ld    (HL), D 
1431			 
1431			      ; Update this_free ptr to point to new block 
1431 2b			      dec   HL 
1432 2b			      dec   HL 
1433 2b			      dec   HL 
1434			 
1434 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1437 dd 56 03		      ld    D, (IX+3) 
143a			 
143a dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
143d dd 74 03		      ld    (IX+3), H 
1440			 
1440			      ; Modify this_free block to be allocation 
1440 eb			      ex    DE, HL 
1441 af			      xor   A                       ; Null the next block ptr of allocated block 
1442 77			      ld    (HL), A 
1443 23			      inc   HL 
1444 77			      ld    (HL), A 
1445			 
1445 23			      inc   HL                      ; Store want size into allocated block 
1446 71			      ld    (HL), C 
1447 23			      inc   HL 
1448 70			      ld    (HL), B 
1449 23			      inc   HL 
144a e5			      push  HL                      ; Address of allocation to return 
144b			 
144b 18 19		      jr    malloc_update_links 
144d			 
144d			malloc_alloc_fit: 
144d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
144e			 
144e					if DEBUG_FORTH_MALLOC 
144e						DMARK "MAf" 
144e						CALLMONITOR 
144e					endif 
144e			      ; Modify this_free block to be allocation 
144e eb			      ex    DE, HL 
144f 2b			      dec   HL 
1450 2b			      dec   HL 
1451 2b			      dec   HL 
1452			 
1452 af			      xor   A                       ; Null the next block ptr of allocated block 
1453 77			      ld    (HL), A 
1454 23			      inc   HL 
1455 77			      ld    (HL), A 
1456			 
1456 23			      inc   HL                      ; Store address of allocation to return 
1457 23			      inc   HL 
1458 23			      inc   HL 
1459 e5			      push  HL 
145a			 
145a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
145a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
145d dd 66 01		      ld    H, (IX+1) 
1460			 
1460 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1463 dd 74 03		      ld    (IX+3), H 
1466			 
1466			 
1466			malloc_update_links: 
1466			      ; Update prev_free ptr to point to this_free 
1466 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1469 dd 66 05		      ld    H, (IX+5) 
146c			 
146c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
146f dd 56 03		      ld    D, (IX+3) 
1472			 
1472 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1473 23			      inc   HL 
1474 72			      ld    (HL), D 
1475			 
1475					if DEBUG_FORTH_MALLOC 
1475						DMARK "Mul" 
1475						CALLMONITOR 
1475					endif 
1475			      ; Clear the Z flag to indicate successful allocation 
1475 7a			      ld    A, D 
1476 b3			      or    E 
1477			 
1477 d1			      pop   DE                      ; Address of allocation 
1478					if DEBUG_FORTH_MALLOC 
1478						DMARK "MAu" 
1478						CALLMONITOR 
1478					endif 
1478			 
1478			malloc_no_space: 
1478 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
147b 39			      add   HL, SP 
147c f9			      ld    SP, HL 
147d			 
147d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAN" 
147e						CALLMONITOR 
147e					endif 
147e			 
147e			malloc_early_exit: 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAx" 
147e						CALLMONITOR 
147e					endif 
147e dd e1		      pop   IX 
1480 d1			      pop   DE 
1481 c1			      pop   BC 
1482			 
1482			if DEBUG_FORTH_MALLOC_HIGH 
1482			call malloc_guard_exit 
1482			call malloc_guard_zerolen 
1482			endif 
1482 c9			      ret 
1483			 
1483			 
1483			;------------------------------------------------------------------------------ 
1483			;     free                                                                    : 
1483			;                                                                             : 
1483			; Description                                                                 : 
1483			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1483			;     returned by malloc, otherwise the behaviour is undefined.               : 
1483			;                                                                             : 
1483			;     Where possible, directly adjacent free blocks will be merged together   : 
1483			;     into larger blocks to help ensure that the heap does not become         : 
1483			;     excessively fragmented.                                                 : 
1483			;                                                                             : 
1483			;     free does not clear or set any other value into the freed space, and    : 
1483			;     therefore its contents may be visible through subsequent malloc's. The  : 
1483			;     caller should clear the freed space as required.                        : 
1483			;                                                                             : 
1483			;     This implementation of free uses the stack exclusively, and is          : 
1483			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1483			;     advisable to disable interrupts before calling free, and recommended    : 
1483			;     to avoid the use of free inside ISRs in general.                        : 
1483			;                                                                             : 
1483			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1483			;                                                                             : 
1483			; Parameters                                                                  : 
1483			;     HL  Pointer to address of first byte of allocation to be freed          : 
1483			;                                                                             : 
1483			; Returns                                                                     : 
1483			;     Nothing                                                                 : 
1483			;                                                                             : 
1483			; Stack frame                                                                 : 
1483			;       |             |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     BC      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     DE      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     IX      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |  prev_free  |                                                       : 
1483			;   +2  +-------------+                                                       : 
1483			;       |  next_free  |                                                       : 
1483			;   +0  +-------------+                                                       : 
1483			;       |             |                                                       : 
1483			;                                                                             : 
1483			;------------------------------------------------------------------------------ 
1483			free: 
1483 c5			      push  BC 
1484 d5			      push  DE 
1485 dd e5		      push  IX 
1487			 
1487 7c			      ld    A, H                    ; Exit if ptr is null 
1488 b5			      or    L 
1489 ca 4d 15		      jp    Z, free_early_exit 
148c			 
148c			      ; Set up stack frame 
148c eb			      ex    DE, HL 
148d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1490 39			      add   HL, SP 
1491 f9			      ld    SP, HL 
1492 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1496 dd 39		      add   IX, SP 
1498			 
1498			      ; The address in HL points to the start of the useable allocated space, 
1498			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1498			      ; address of the block itself. 
1498 eb			      ex    DE, HL 
1499 11 fc ff		      ld    DE, -4 
149c 19			      add   HL, DE 
149d			 
149d			      ; An allocated block must have a null next block pointer in it 
149d 7e			      ld    A, (HL) 
149e 23			      inc   HL 
149f b6			      or    (HL) 
14a0 c2 48 15		      jp    NZ, free_done 
14a3			 
14a3 2b			      dec   HL 
14a4			 
14a4 44			      ld    B, H                    ; Copy HL to BC 
14a5 4d			      ld    C, L 
14a6			 
14a6			      ; Loop through the free list to find the first block with an address 
14a6			      ; higher than the block being freed 
14a6 21 0a 80		      ld    HL, free_list 
14a9			 
14a9			free_find_higher_block: 
14a9 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14aa 23			      inc   HL 
14ab 56			      ld    D, (HL) 
14ac 2b			      dec   HL 
14ad			 
14ad dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14b0 dd 72 01		      ld    (IX+1), D 
14b3 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14b6 dd 74 03		      ld    (IX+3), H 
14b9			 
14b9 78			      ld    A, B                    ; Check if DE is greater than BC 
14ba ba			      cp    D                       ; Compare MSB first 
14bb 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14bd 30 04		      jr    NC, free_find_higher_block_skip 
14bf 79			      ld    A, C 
14c0 bb			      cp    E                       ; Then compare LSB 
14c1 38 08		      jr    C, free_found_higher_block 
14c3			 
14c3			free_find_higher_block_skip: 
14c3 7a			      ld    A, D                    ; Reached the end of the free list? 
14c4 b3			      or    E 
14c5 ca 48 15		      jp    Z, free_done 
14c8			 
14c8 eb			      ex    DE, HL 
14c9			 
14c9 18 de		      jr    free_find_higher_block 
14cb			 
14cb			free_found_higher_block: 
14cb			      ; Insert freed block between prev and next free blocks 
14cb 71			      ld    (HL), C                 ; Point prev free block to freed block 
14cc 23			      inc   HL 
14cd 70			      ld    (HL), B 
14ce			 
14ce 60			      ld    H, B                    ; Point freed block at next free block 
14cf 69			      ld    L, C 
14d0 73			      ld    (HL), E 
14d1 23			      inc   HL 
14d2 72			      ld    (HL), D 
14d3			 
14d3			      ; Check if the freed block is adjacent to the next free block 
14d3 23			      inc   HL                      ; Load size of freed block into HL 
14d4 5e			      ld    E, (HL) 
14d5 23			      inc   HL 
14d6 56			      ld    D, (HL) 
14d7 eb			      ex    DE, HL 
14d8			 
14d8 09			      add   HL, BC                  ; Add addr of freed block and its size 
14d9			 
14d9 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14dc dd 56 01		      ld    D, (IX+1) 
14df			 
14df b7			      or    A                       ; Clear the carry flag 
14e0 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14e2 20 22		      jr    NZ, free_check_adjacent_to_prev 
14e4			 
14e4			      ; Freed block is adjacent to next, merge into one bigger block 
14e4 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14e5 5e			      ld    E, (HL) 
14e6 23			      inc   HL 
14e7 56			      ld    D, (HL) 
14e8 e5			      push  HL                      ; Save ptr to next block for later 
14e9			 
14e9 60			      ld    H, B                    ; Store ptr from next block into freed block 
14ea 69			      ld    L, C 
14eb 73			      ld    (HL), E 
14ec 23			      inc   HL 
14ed 72			      ld    (HL), D 
14ee			 
14ee e1			      pop   HL                      ; Restore ptr to next block 
14ef 23			      inc   HL                      ; Load size of next block into DE 
14f0 5e			      ld    E, (HL) 
14f1 23			      inc   HL 
14f2 56			      ld    D, (HL) 
14f3 d5			      push  DE                      ; Save next block size for later 
14f4			 
14f4 60			      ld    H, B                    ; Load size of freed block into HL 
14f5 69			      ld    L, C 
14f6 23			      inc   HL 
14f7 23			      inc   HL 
14f8 5e			      ld    E, (HL) 
14f9 23			      inc   HL 
14fa 56			      ld    D, (HL) 
14fb eb			      ex    DE, HL 
14fc			 
14fc d1			      pop   DE                      ; Restore size of next block 
14fd 19			      add   HL, DE                  ; Add sizes of both blocks 
14fe eb			      ex    DE, HL 
14ff			 
14ff 60			      ld    H, B                    ; Store new bigger size into freed block 
1500 69			      ld    L, C 
1501 23			      inc   HL 
1502 23			      inc   HL 
1503 73			      ld    (HL), E 
1504 23			      inc   HL 
1505 72			      ld    (HL), D 
1506			 
1506			free_check_adjacent_to_prev: 
1506			      ; Check if the freed block is adjacent to the prev free block 
1506 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1509 dd 66 03		      ld    H, (IX+3) 
150c			 
150c 23			      inc   HL                      ; Size of prev free block into DE 
150d 23			      inc   HL 
150e 5e			      ld    E, (HL) 
150f 23			      inc   HL 
1510 56			      ld    D, (HL) 
1511 2b			      dec   HL 
1512 2b			      dec   HL 
1513 2b			      dec   HL 
1514			 
1514 19			      add   HL, DE                  ; Add prev block addr and size 
1515			 
1515 b7			      or    A                       ; Clear the carry flag 
1516 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1518 20 2e		      jr    NZ, free_done 
151a			 
151a			      ; Freed block is adjacent to prev, merge into one bigger block 
151a 60			      ld    H, B                    ; Load next ptr from freed block into DE 
151b 69			      ld    L, C 
151c 5e			      ld    E, (HL) 
151d 23			      inc   HL 
151e 56			      ld    D, (HL) 
151f e5			      push  HL                      ; Save freed block ptr for later 
1520			 
1520 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1523 dd 66 03		      ld    H, (IX+3) 
1526 73			      ld    (HL), E 
1527 23			      inc   HL 
1528 72			      ld    (HL), D 
1529			 
1529 e1			      pop   HL                      ; Restore freed block ptr 
152a 23			      inc   HL                      ; Load size of freed block into DE 
152b 5e			      ld    E, (HL) 
152c 23			      inc   HL 
152d 56			      ld    D, (HL) 
152e d5			      push  DE                      ; Save freed block size for later 
152f			 
152f dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1532 dd 66 03		      ld    H, (IX+3) 
1535 23			      inc   HL 
1536 23			      inc   HL 
1537 5e			      ld    E, (HL) 
1538 23			      inc   HL 
1539 56			      ld    D, (HL) 
153a			 
153a e1			      pop   HL                      ; Add sizes of both blocks 
153b 19			      add   HL, DE 
153c eb			      ex    DE, HL 
153d			 
153d dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1540 dd 66 03		      ld    H, (IX+3) 
1543 23			      inc   HL 
1544 23			      inc   HL 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548			free_done: 
1548 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
154b 39			      add   HL, SP 
154c f9			      ld    SP, HL 
154d			 
154d			free_early_exit: 
154d dd e1		      pop   IX 
154f d1			      pop   DE 
1550 c1			      pop   BC 
1551			 
1551 c9			      ret 
1552			 
1552			; moved to firmware.asm 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			;                  .dw   0 
1552			 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_3 
1552			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1552			;heap_start        .equ  0x9000      ; Starting address of heap 
1552			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1552			; 
1552			 ;     .org 0 
1552			  ;    jp    main 
1552			; 
1552			; 
1552			 ;     .org  0x100 
1552			;main: 
1552			 ;     ld    HL, 0x8100 
1552			  ;    ld    SP, HL 
1552			; 
1552			;      call  heap_init 
1552			 
1552			      ; Make some allocations 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9004 
1552			; 
1552			 ;     ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9014 
1552			 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9024 
1552			 
1552			      ; Free some allocations 
1552			;      ld    HL, 0x9014 
1552			;      call  free 
1552			 
1552			;      ld    HL, 0x9004 
1552			;      call  free 
1552			; 
1552			;      ld    HL, 0x9024 
1552			;      call  free 
1552			 
1552			 
1552			 ;     halt 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     heap_init                                                               : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Initialise the heap and make it ready for malloc and free operations.   : 
1552			;                                                                             : 
1552			;     The heap is maintained as a linked list, starting with an initial       : 
1552			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1552			;     the first free block in the heap. Each block then points to the next    : 
1552			;     free block within the heap, and the free list ends at the first block   : 
1552			;     with a null pointer to the next free block.                             : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     Inputs are compile-time only. Two defines which specify the starting    : 
1552			;     address of the heap and its size are required, along with a memory      : 
1552			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1552			;     principally stores a pointer to the first free block in the heap.       : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;------------------------------------------------------------------------------ 
1552			heap_init: 
1552			      push  HL 
1552			 
1552			      ; Initialise free list struct 
1552			      ld    HL, heap_start 
1552			      ld    (free_list), HL 
1552			      ld    HL, 0 
1552			      ld    (free_list+2), HL 
1552			 
1552			      ; Insert first free block at bottom of heap, consumes entire heap 
1552			      ld    HL, heap_start+heap_size-4 
1552			      ld    (heap_start), HL        ; Next block (end of free list) 
1552			      ld    HL, heap_size-4 
1552			      ld    (heap_start+2), HL      ; Block size 
1552			 
1552			      ; Insert end of free list block at top of heap - two null words will 
1552			      ; terminate the free list 
1552			      ld    HL, 0 
1552			      ld    (heap_start+heap_size-2), HL 
1552			      ld    (heap_start+heap_size-4), HL 
1552			 
1552			      pop   HL 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     malloc                                                                  : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Allocates the wanted space from the heap and returns the address of the : 
1552			;     first useable byte of the allocation.                                   : 
1552			;                                                                             : 
1552			;     Allocations can happen in one of two ways:                              : 
1552			;                                                                             : 
1552			;     1. A free block may be found which is the exact size wanted. In this    : 
1552			;        case the block is removed from the free list and retuedn to the      : 
1552			;        caller.                                                              : 
1552			;     2. A free block may be found which is larger than the size wanted. In   : 
1552			;        this case, the larger block is split into two. The first portion of  : 
1552			;        this block will become the requested space by the malloc call and    : 
1552			;        is returned to the caller. The second portion becomes a new free     : 
1552			;        block, and the free list is adjusted to maintain continuity via this : 
1552			;        newly created block.                                                 : 
1552			;                                                                             : 
1552			;     malloc does not set any initial value in the allocated space, the       : 
1552			;     caller is required to do this as required.                              : 
1552			;                                                                             : 
1552			;     This implementation of malloc uses the stack exclusively, and is        : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling malloc, and recommended  : 
1552			;     to avoid the use of malloc inside ISRs in general.                      : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Number of bytes wanted                                              : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     HL  Address of the first useable byte of the allocation                 : 
1552			;                                                                             : 
1552			; Flags                                                                       : 
1552			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +4  +-------------+                                                       : 
1552			;       |  this_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			malloc: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if no space requested 
1552			      or    L 
1552			      jp    Z, malloc_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; Setup initial state 
1552			      ld    HL, 4                   ; want must also include space used by block struct 
1552			      add   HL, DE 
1552			 
1552			      ld    B, H                    ; Move want to BC 
1552			      ld    C, L 
1552			 
1552			      ld    HL, free_list           ; Store prev_free ptr to stack 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    E, (HL)                 ; Store this_free ptr to stack 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ld    (IX+2), E 
1552			      ld    (IX+3), D 
1552			      ex    DE, HL                  ; this_free ptr into HL 
1552			 
1552			      ; Loop through free block list to find some space 
1552			malloc_find_space: 
1552			      ld    E, (HL)                 ; Load next_free ptr into DE 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1552			      or    E 
1552			      jp    Z, malloc_no_space 
1552			 
1552			      ld    (IX+0), E               ; Store next_free ptr to stack 
1552			      ld    (IX+1), D 
1552			 
1552			      ; Does this block have enough space to make the allocation? 
1552			      inc   HL                      ; Load free block size into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ex    DE, HL                  ; Check size of block against want 
1552			      or    A                       ; Ensure carry flag clear 
1552			      sbc   HL, BC 
1552			      push  HL                      ; Store the result for later (new block size) 
1552			 
1552			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1552			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1552			 
1552			      ; this_free block is not big enough, setup ptrs to test next free block 
1552			      pop   HL                      ; Discard previous result 
1552			 
1552			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1552			      ld    H, (IX+3) 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1552			      ld    H, (IX+1) 
1552			      ld    (IX+2), L 
1552			      ld    (IX+3), H 
1552			 
1552			      jr    malloc_find_space 
1552			 
1552			      ; split a bigger block into two - requested size and remaining size 
1552			malloc_alloc_split: 
1552			      ex    DE, HL                  ; Calculate address of new free block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      add   HL, BC 
1552			 
1552			      ; Create a new block and point it at next_free 
1552			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      ld    (HL), E                 ; Store next_free ptr into new block 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   DE                      ; Store size of new block into new block 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Update this_free ptr to point to new block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1552			      ld    (IX+3), H 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store want size into allocated block 
1552			      ld    (HL), C 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			      inc   HL 
1552			      push  HL                      ; Address of allocation to return 
1552			 
1552			      jr    malloc_update_links 
1552			 
1552			malloc_alloc_fit: 
1552			      pop   HL                      ; Dont need new block size, want is exact fit 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store address of allocation to return 
1552			      inc   HL 
1552			      inc   HL 
1552			      push  HL 
1552			 
1552			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1552			      ld    L, (IX+0)               ; next_free to HL 
1552			      ld    H, (IX+1) 
1552			 
1552			      ld    (IX+2), L               ; HL to this_free 
1552			      ld    (IX+3), H 
1552			 
1552			 
1552			malloc_update_links: 
1552			      ; Update prev_free ptr to point to this_free 
1552			      ld    L, (IX+4)               ; prev_free ptr to HL 
1552			      ld    H, (IX+5) 
1552			 
1552			      ld    E, (IX+2)               ; this_free ptr to DE 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (HL), E                 ; this_free ptr into prev_free 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Clear the Z flag to indicate successful allocation 
1552			      ld    A, D 
1552			      or    E 
1552			 
1552			      pop   DE                      ; Address of allocation 
1552			 
1552			malloc_no_space: 
1552			      ld    HL, 6                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			      ex    DE, HL                  ; Alloc addr into HL for return 
1552			 
1552			malloc_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     free                                                                    : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1552			;     returned by malloc, otherwise the behaviour is undefined.               : 
1552			;                                                                             : 
1552			;     Where possible, directly adjacent free blocks will be merged together   : 
1552			;     into larger blocks to help ensure that the heap does not become         : 
1552			;     excessively fragmented.                                                 : 
1552			;                                                                             : 
1552			;     free does not clear or set any other value into the freed space, and    : 
1552			;     therefore its contents may be visible through subsequent malloc's. The  : 
1552			;     caller should clear the freed space as required.                        : 
1552			;                                                                             : 
1552			;     This implementation of free uses the stack exclusively, and is          : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling free, and recommended    : 
1552			;     to avoid the use of free inside ISRs in general.                        : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Pointer to address of first byte of allocation to be freed          : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			free: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if ptr is null 
1552			      or    L 
1552			      jp    Z, free_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; The address in HL points to the start of the useable allocated space, 
1552			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1552			      ; address of the block itself. 
1552			      ex    DE, HL 
1552			      ld    DE, -4 
1552			      add   HL, DE 
1552			 
1552			      ; An allocated block must have a null next block pointer in it 
1552			      ld    A, (HL) 
1552			      inc   HL 
1552			      or    (HL) 
1552			      jp    NZ, free_done 
1552			 
1552			      dec   HL 
1552			 
1552			      ld    B, H                    ; Copy HL to BC 
1552			      ld    C, L 
1552			 
1552			      ; Loop through the free list to find the first block with an address 
1552			      ; higher than the block being freed 
1552			      ld    HL, free_list 
1552			 
1552			free_find_higher_block: 
1552			      ld    E, (HL)                 ; Load next ptr from free block 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			 
1552			      ld    (IX+0), E               ; Save ptr to next free block 
1552			      ld    (IX+1), D 
1552			      ld    (IX+2), L               ; Save ptr to prev free block 
1552			      ld    (IX+3), H 
1552			 
1552			      ld    A, B                    ; Check if DE is greater than BC 
1552			      cp    D                       ; Compare MSB first 
1552			      jr    Z, $+4                  ; MSB the same, compare LSB 
1552			      jr    NC, free_find_higher_block_skip 
1552			      ld    A, C 
1552			      cp    E                       ; Then compare LSB 
1552			      jr    C, free_found_higher_block 
1552			 
1552			free_find_higher_block_skip: 
1552			      ld    A, D                    ; Reached the end of the free list? 
1552			      or    E 
1552			      jp    Z, free_done 
1552			 
1552			      ex    DE, HL 
1552			 
1552			      jr    free_find_higher_block 
1552			 
1552			free_found_higher_block: 
1552			      ; Insert freed block between prev and next free blocks 
1552			      ld    (HL), C                 ; Point prev free block to freed block 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			 
1552			      ld    H, B                    ; Point freed block at next free block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Check if the freed block is adjacent to the next free block 
1552			      inc   HL                      ; Load size of freed block into HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      add   HL, BC                  ; Add addr of freed block and its size 
1552			 
1552			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_check_adjacent_to_prev 
1552			 
1552			      ; Freed block is adjacent to next, merge into one bigger block 
1552			      ex    DE, HL                  ; Load next ptr from next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save ptr to next block for later 
1552			 
1552			      ld    H, B                    ; Store ptr from next block into freed block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore ptr to next block 
1552			      inc   HL                      ; Load size of next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save next block size for later 
1552			 
1552			      ld    H, B                    ; Load size of freed block into HL 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      pop   DE                      ; Restore size of next block 
1552			      add   HL, DE                  ; Add sizes of both blocks 
1552			      ex    DE, HL 
1552			 
1552			      ld    H, B                    ; Store new bigger size into freed block 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_check_adjacent_to_prev: 
1552			      ; Check if the freed block is adjacent to the prev free block 
1552			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1552			      ld    H, (IX+3) 
1552			 
1552			      inc   HL                      ; Size of prev free block into DE 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      add   HL, DE                  ; Add prev block addr and size 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_done 
1552			 
1552			      ; Freed block is adjacent to prev, merge into one bigger block 
1552			      ld    H, B                    ; Load next ptr from freed block into DE 
1552			      ld    L, C 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save freed block ptr for later 
1552			 
1552			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1552			      ld    H, (IX+3) 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore freed block ptr 
1552			      inc   HL                      ; Load size of freed block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save freed block size for later 
1552			 
1552			      ld    L, (IX+2)               ; Load size of prev block into DE 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      pop   HL                      ; Add sizes of both blocks 
1552			      add   HL, DE 
1552			      ex    DE, HL 
1552			 
1552			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_done: 
1552			      ld    HL, 4                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			free_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;      .org 0x8000 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			 ;                 .dw   0 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_4 
1552			 
1552			; My memory allocation code. Very very simple.... 
1552			; allocate space under 250 chars 
1552			 
1552			heap_init: 
1552				; init start of heap as zero 
1552				;  
1552			 
1552				ld hl, heap_start 
1552				ld a, 0 
1552				ld (hl), a      ; empty block 
1552				inc hl 
1552				ld a, 0 
1552				ld (hl), a      ; length of block 
1552				; write end of list 
1552				inc hl 
1552				ld a,(hl) 
1552				inc hl 
1552				ld a,(hl) 
1552				 
1552			 
1552				; init some malloc vars 
1552			 
1552				ld hl, 0 
1552				ld (free_list), hl       ; store last malloc location 
1552			 
1552				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1552				ld a, 0 
1552				ld (hl), a 
1552			 
1552			 
1552				ld hl, heap_start 
1552				;  
1552				  
1552				ret 
1552			 
1552			 
1552			;    free block marker 
1552			;    requested size  
1552			;    pointer to next block 
1552			;    .... 
1552			;    next block marker 
1552			 
1552			 
1552			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1552			; 
1552			 
1552			 
1552			malloc:  
1552				push de 
1552				push bc 
1552				push af 
1552			 
1552				; hl space required 
1552				 
1552				ld c, l    ; hold space   (TODO only a max of 255) 
1552			 
1552			;	inc c     ; TODO BUG need to fix memory leak on push str 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			 
1552			 
1552			 
1552				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1552			 
1552				ld a, (free_list+3) 
1552				cp 0 
1552				jr z, .contheap 
1552			 
1552				ld hl, (free_list)     ; get last alloc 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mrs" 
1552						CALLMONITOR 
1552					endif 
1552				jr .startalloc 
1552			 
1552			.contheap: 
1552				ld hl, heap_start 
1552			 
1552			.startalloc: 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mym" 
1552						CALLMONITOR 
1552					endif 
1552			.findblock: 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmf" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552				ld a,(hl)  
1552				; if byte is zero then clear to use 
1552			 
1552				cp 0 
1552				jr z, .foundemptyblock 
1552			 
1552				; if byte is not clear 
1552				;     then byte is offset to next block 
1552			 
1552				inc hl 
1552				ld a, (hl) ; get size 
1552			.nextblock:	inc hl 
1552					ld e, (hl) 
1552					inc hl 
1552					ld d, (hl) 
1552					ex de, hl 
1552			;	inc hl  ; move past the store space 
1552			;	inc hl  ; move past zero index  
1552			 
1552				; TODO detect no more space 
1552			 
1552				push hl 
1552				ld de, heap_end 
1552				call cmp16 
1552				pop hl 
1552				jr nc, .nospace 
1552			 
1552				jr .findblock 
1552			 
1552			.nospace: ld hl, 0 
1552				jp .exit 
1552			 
1552			 
1552			.foundemptyblock:	 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mme" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; TODO has block enough space if reusing??? 
1552			 
1552				;  
1552			 
1552			; see if this block has been previously used 
1552				inc hl 
1552				ld a, (hl) 
1552				dec hl 
1552				cp 0 
1552				jr z, .newblock 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meR" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; no reusing previously allocated block 
1552			 
1552			; is it smaller than previously used? 
1552				 
1552				inc hl    ; move to size 
1552				ld a, c 
1552				sub (hl)        ; we want c < (hl) 
1552				dec hl    ; move back to marker 
1552			        jr z, .findblock 
1552			 
1552				; update with the new size which should be lower 
1552			 
1552			        ;inc  hl   ; negate next move. move back to size  
1552			 
1552			.newblock: 
1552				; need to be at marker here 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meN" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			 
1552				ld a, c 
1552			 
1552				ld (free_list+3), a	 ; flag resume from last malloc  
1552				ld (free_list), hl    ; save out last location 
1552			 
1552			 
1552				;inc a     ; space for length byte 
1552				ld (hl), a     ; save block in use marker 
1552			 
1552				inc hl   ; move to space marker 
1552				ld (hl), a    ; save new space 
1552			 
1552				inc hl   ; move to start of allocated area 
1552				 
1552			;	push hl     ; save where we are - 1  
1552			 
1552			;	inc hl  ; move past zero index  
1552				; skip space to set down new marker 
1552			 
1552				; provide some extra space for now 
1552			 
1552				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1552				inc a 
1552				inc a 
1552			 
1552				push hl   ; save where we are in the node block 
1552			 
1552				call addatohl 
1552			 
1552				; write linked list point 
1552			 
1552				pop de     ; get our node position 
1552				ex de, hl 
1552			 
1552				ld (hl), e 
1552				inc hl 
1552				ld (hl), d 
1552			 
1552				inc hl 
1552			 
1552				; now at start of allocated data so save pointer 
1552			 
1552				push hl 
1552			 
1552				; jump to position of next node and setup empty header in DE 
1552			 
1552				ex de, hl 
1552			 
1552			;	inc hl ; move past end of block 
1552			 
1552				ld a, 0 
1552				ld (hl), a   ; empty marker 
1552				inc hl 
1552				ld (hl), a   ; size 
1552				inc hl  
1552				ld (hl), a   ; ptr 
1552				inc hl 
1552				ld (hl), a   ; ptr 
1552			 
1552			 
1552				pop hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmr" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			.exit: 
1552				pop af 
1552				pop bc 
1552				pop de  
1552				ret 
1552			 
1552			 
1552			 
1552			 
1552			free:  
1552				push hl 
1552				push af 
1552				; get address in hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "fre" 
1552						CALLMONITOR 
1552					endif 
1552				; data is at hl - move to block count 
1552				dec hl 
1552				dec hl    ; get past pointer 
1552				dec hl 
1552			 
1552				ld a, (hl)    ; need this for a validation check 
1552			 
1552				dec hl    ; move to block marker 
1552			 
1552				; now check that the block count and block marker are the same  
1552			        ; this checks that we are on a malloc node and not random memory 
1552			        ; OK a faint chance this could be a problem but rare - famous last words! 
1552			 
1552				ld c, a 
1552				ld a, (hl)    
1552			 
1552				cp c 
1552				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1552			 
1552				; yes good chance we are on a malloc node 
1552			 
1552				ld a, 0      
1552				ld (hl), a   ; mark as free 
1552			 
1552				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1552			 
1552			.freeignore:  
1552			 
1552				pop af 
1552				pop hl 
1552			 
1552				ret 
1552			 
1552			 
1552			 
1552			endif 
1552			 
1552			; eof 
# End of file firmware_memory.asm
1552			  
1552			; device C  
1552			; Now handled by SPI  
1552			;if SOUND_ENABLE  
1552			;	include "firmware_sound.asm"  
1552			;endif  
1552			  
1552			include "firmware_diags.asm"  
1552			; Hardware diags menu 
1552			 
1552			 
1552			config: 
1552			 
1552 3e 00			ld a, 0 
1554 21 7d 15			ld hl, .configmn 
1557 cd db 0d			call menu 
155a			 
155a fe 00			cp 0 
155c c8				ret z 
155d			 
155d			;	cp 1 
155d			;	call z, .savetostore 
155d			 
155d fe 01			cp 1 
155f			if STARTUP_V1 
155f				call z, .selautoload 
155f			endif 
155f			 
155f			if STARTUP_V2 
155f cc 8b 15			call z, .enautoload 
1562			endif 
1562 fe 02			cp 2 
1564 cc a2 15			call z, .disautoload 
1567			;	cp 3 
1567			;	call z, .selbank 
1567 fe 03			cp 3 
1569 cc 0d 18			call z, .debug_tog 
156c fe 04			cp 4 
156e cc 5b 19			call z, .bpsgo 
1571 fe 05			cp 5 
1573 cc 36 18			call z, hardware_diags 
1576			if STARTUP_V2 
1576 fe 06			cp 6 
1578 cc ce 15			call z, create_startup 
157b			endif 
157b 18 d5			jr config 
157d			 
157d			.configmn: 
157d			;	dw prom_c3 
157d 49 1b			dw prom_c2 
157f 5f 1b			dw prom_c2a 
1581			;	dw prom_c2b 
1581			;	dw prom_c4 
1581 d6 1b			dw prom_m4 
1583 f1 1b			dw prom_m4b 
1585 f9 1b			dw prom_c1 
1587			if STARTUP_V2 
1587 08 1c			dw prom_c9 
1589			endif 
1589 00 00			dw 0 
158b				 
158b			 
158b			if STARTUP_V2 
158b			.enautoload: 
158b				if STORAGE_SE 
158b 3e fe			ld a, $fe      ; bit 0 clear 
158d 32 95 f9			ld (spi_device), a 
1590			 
1590 cd 25 05			call storage_get_block_0 
1593			 
1593 3e 01			ld a, 1 
1595 32 d0 f9			ld (store_page+STORE_0_AUTOFILE), a 
1598			 
1598 21 00 00				ld hl, 0 
159b 11 af f9				ld de, store_page 
159e cd d9 04			call storage_write_block	 ; save update 
15a1				else 
15a1			 
15a1				ld hl, prom_notav 
15a1				ld de, prom_empty 
15a1				call info_panel 
15a1				endif 
15a1			 
15a1			 
15a1 c9				ret 
15a2			endif 
15a2			 
15a2			.disautoload: 
15a2				if STORAGE_SE 
15a2 3e fe			ld a, $fe      ; bit 0 clear 
15a4 32 95 f9			ld (spi_device), a 
15a7			 
15a7 cd 25 05			call storage_get_block_0 
15aa			 
15aa 3e 00			ld a, 0 
15ac 32 d0 f9			ld (store_page+STORE_0_AUTOFILE), a 
15af			 
15af 21 00 00				ld hl, 0 
15b2 11 af f9				ld de, store_page 
15b5 cd d9 04			call storage_write_block	 ; save update 
15b8				else 
15b8			 
15b8				ld hl, prom_notav 
15b8				ld de, prom_empty 
15b8				call info_panel 
15b8				endif 
15b8			 
15b8			 
15b8 c9				ret 
15b9			 
15b9			if STARTUP_V1 
15b9			 
15b9			; Select auto start 
15b9			 
15b9			.selautoload: 
15b9			 
15b9				 
15b9				if STORAGE_SE 
15b9			 
15b9					call config_dir 
15b9				        ld hl, scratch 
15b9					ld a, 0 
15b9					call menu 
15b9			 
15b9					cp 0 
15b9					ret z 
15b9			 
15b9					dec a 
15b9			 
15b9			 
15b9					; locate menu option 
15b9			 
15b9					ld hl, scratch 
15b9					call table_lookup 
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALl" 
15b9						CALLMONITOR 
15b9					endif 
15b9					; with the pointer to the menu it, the byte following the zero term is the file id 
15b9			 
15b9					ld a, 0 
15b9					ld bc, 50   ; max of bytes to look at 
15b9					cpir  
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALb" 
15b9						CALLMONITOR 
15b9					endif 
15b9					;inc hl 
15b9			 
15b9					ld a, (hl)   ; file id 
15b9					 
15b9				        ; save bank and file ids 
15b9			 
15b9					push af 
15b9			 
15b9			; TODO need to save to block 0 on bank 1	 
15b9			 
15b9					call storage_get_block_0 
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "AL0" 
15b9						CALLMONITOR 
15b9					endif 
15b9					pop af 
15b9			 
15b9					ld (store_page+STORE_0_FILERUN),a 
15b9					 
15b9					; save bank id 
15b9			 
15b9					ld a,(spi_device) 
15b9					ld (store_page+STORE_0_BANKRUN),a 
15b9			 
15b9					; enable auto run of store file 
15b9			 
15b9					ld a, 1 
15b9					ld (store_page+STORE_0_AUTOFILE),a 
15b9			 
15b9					; save buffer 
15b9			 
15b9					ld hl, 0 
15b9					ld de, store_page 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALw" 
15b9						CALLMONITOR 
15b9					endif 
15b9				call storage_write_block	 ; save update 
15b9			  
15b9			 
15b9			 
15b9			 
15b9					ld hl, scratch 
15b9					call config_fdir 
15b9			 
15b9				else 
15b9			 
15b9				ld hl, prom_notav 
15b9				ld de, prom_empty 
15b9				call info_panel 
15b9			 
15b9				endif 
15b9				ret 
15b9			endif 
15b9			 
15b9			 
15b9			; Select storage bank 
15b9			 
15b9			.selbank: 
15b9			 
15b9			;	if STORAGE_SE 
15b9			;	else 
15b9			 
15b9 21 1d 1c			ld hl, prom_notav 
15bc 11 33 1c			ld de, prom_empty 
15bf cd 3b 0d			call info_panel 
15c2			;	endif 
15c2				 
15c2 c9				ret 
15c3			 
15c3			if STORAGE_SE 
15c3			 
15c3			.config_ldir:   
15c3				; Load storage bank labels into menu array 
15c3			 
15c3				 
15c3			 
15c3			 
15c3 c9				ret 
15c4			 
15c4			 
15c4			endif 
15c4			 
15c4			 
15c4			; Save user words to storage 
15c4			 
15c4			.savetostore: 
15c4			 
15c4			;	if STORAGE_SE 
15c4			; 
15c4			;		call config_dir 
15c4			;	        ld hl, scratch 
15c4			;		ld a, 0 
15c4			;		call menu 
15c4			;		 
15c4			;		ld hl, scratch 
15c4			;		call config_fdir 
15c4			; 
15c4			;	else 
15c4			 
15c4 21 1d 1c			ld hl, prom_notav 
15c7 11 33 1c			ld de, prom_empty 
15ca cd 3b 0d			call info_panel 
15cd			 
15cd			;	endif 
15cd			 
15cd c9				ret 
15ce			 
15ce			if STARTUP_V2 
15ce			 
15ce			create_startup: 
15ce			 
15ce 3e 00			ld a, 0 
15d0 21 32 17			ld hl, .crstart 
15d3 cd db 0d			call menu 
15d6			 
15d6 fe 00			cp 0 
15d8 c8				ret z 
15d9			 
15d9 fe 01			cp 1 
15db cc 17 16			call z, .genlsword 
15de fe 02			cp 2 
15e0 cc 21 16			call z, .genedword 
15e3			 
15e3 fe 03			cp 3 
15e5 cc 2b 16			call z, .gendemword 
15e8			 
15e8 fe 04			cp 4 
15ea cc 35 16			call z, .genutlword 
15ed fe 05			cp 5 
15ef cc 3f 16			call z, .genspiword 
15f2 fe 06			cp 6 
15f4 cc 49 16			call z, .genkeyword 
15f7 fe 07			cp 7 
15f9 cc 0d 16			call z, .gensoundword 
15fc fe 08			cp 8 
15fe cc 03 16			call z, .genhwword 
1601 18 cb			jr create_startup 
1603			 
1603			.genhwword: 
1603 21 c0 1b			ld hl, crs_hw 
1606 11 96 16			ld de, .hwworddef 
1609 cd 53 16			call .genfile 
160c c9				ret 
160d			.gensoundword: 
160d 21 b4 1b			ld hl, crs_sound 
1610 11 a4 16			ld de, .soundworddef 
1613 cd 53 16			call .genfile 
1616 c9				ret 
1617			.genlsword: 
1617 21 76 1b			ld hl, crs_s1 
161a 11 ca 16			ld de, .lsworddef 
161d cd 53 16			call .genfile 
1620 c9				ret 
1621			 
1621			.genedword: 
1621 11 ce 16			ld de, .edworddef 
1624 21 7f 1b			ld hl, crs_s2 
1627 cd 53 16			call .genfile 
162a c9				ret 
162b			 
162b			.gendemword: 
162b 11 d6 16			ld de, .demoworddef 
162e 21 88 1b			ld hl, crs_s3 
1631 cd 53 16			call .genfile 
1634 c9				ret 
1635			 
1635			.genutlword: 
1635 21 94 1b			ld hl, crs_s4 
1638 11 b8 16			ld de, .utilwordef 
163b cd 53 16			call .genfile 
163e c9				ret 
163f			.genspiword: 
163f 21 9b 1b			ld hl, crs_s5 
1642 11 f8 16			ld de, .spiworddef 
1645 cd 53 16			call .genfile 
1648 c9				ret 
1649			.genkeyword: 
1649 21 a5 1b			ld hl, crs_s6 
164c 11 06 17			ld de, .keyworddef 
164f cd 53 16			call .genfile 
1652 c9				ret 
1653			 
1653			; hl - points to file name 
1653			; de - points to strings to add to file 
1653			 
1653			.genfile: 
1653 e5				push hl 
1654 d5				push de 
1655			 
1655 cd aa 0d			call clear_display 
1658 3e 00			ld a, display_row_1 
165a 11 85 16			ld de, .genfiletxt 
165d cd bd 0d			call str_at_display 
1660 cd cd 0d			call update_display 
1663			 
1663 d1				pop de 
1664 e1				pop hl 
1665			 
1665			 
1665 d5				push de 
1666 cd 77 08			call storage_create 
1669				; id in hl 
1669 d1				pop de   ; table of strings to add 
166a			 
166a			.genloop: 
166a			 
166a e5				push hl ; save id for next time around 
166b d5				push de ; save de for next time around 
166c			 
166c eb				ex de, hl 
166d cd bb 23			call loadwordinhl 
1670 eb				ex de, hl 
1671			 
1671				; need hl to be the id 
1671				; need de to be the string ptr 
1671				 
1671 cd 64 0b			call storage_append 
1674			 
1674 d1				pop de 
1675 e1				pop hl 
1676			 
1676 13				inc de 
1677 13				inc de 
1678			 
1678 1a				ld a,(de) 
1679 fe 00			cp 0 
167b 20 ed			jr nz, .genloop 
167d 13				inc de 
167e 1a				ld a, (de) 
167f 1b				dec de 
1680 fe 00			cp 0 
1682 20 e6			jr nz, .genloop	 
1684			 
1684 c9				ret 
1685			 
1685 .. 00		.genfiletxt:  db "Creating file...",0 
1696			 
1696			.hwworddef: 
1696 3b 68			dw test5 
1698 73 68			dw test6 
169a ab 68			dw test7 
169c bf 68			dw test8 
169e eb 68			dw test9 
16a0 01 69			dw test10 
16a2 00 00			dw 0 
16a4			 
16a4			.soundworddef: 
16a4 26 69			dw sound1 
16a6 4a 69			dw sound2 
16a8 7a 69			dw sound3 
16aa 9f 69			dw sound4 
16ac ac 69			dw sound5 
16ae b9 69			dw sound6 
16b0 c6 69			dw sound7 
16b2 d3 69			dw sound8 
16b4 eb 69			dw sound9 
16b6 00 00			dw 0 
16b8			 
16b8			.utilwordef: 
16b8 61 66			dw strncpy 
16ba 3c 66			dw type 
16bc be 67			dw tuck 
16be 08 66			dw clrstack 
16c0 c1 65			dw longread 
16c2 c2 66			dw start1 
16c4 d2 66			dw start2 
16c6			; duplicated 
16c6			;	dw start3b 
16c6			;	dw start3c 
16c6 d1 67			dw list 
16c8 00 00			dw 0 
16ca			 
16ca			.lsworddef: 
16ca e3 66			dw start3b 
16cc 00 00			dw 0 
16ce			 
16ce			.edworddef: 
16ce 20 62			dw edit1 
16d0 41 62			dw edit2 
16d2 76 62			dw edit3 
16d4 00 00			dw 0 
16d6			 
16d6			.demoworddef: 
16d6 02 6a			dw game1 
16d8 13 6a			dw game1a 
16da 75 6a			dw game1b 
16dc aa 6a			dw game1c 
16de e0 6a			dw game1d 
16e0 11 6b			dw game1s 
16e2 25 6b			dw game1t 
16e4 3a 6b			dw game1f 
16e6 6e 6b			dw game1z 
16e8 b2 6b			dw game1zz 
16ea 1b 6c			dw ssv2 
16ec 51 6c			dw ssv3 
16ee 6d 6c			dw ssv4 
16f0 89 6c			dw ssv5 
16f2 a2 6c			dw ssv1 
16f4 ea 6c			dw ssv1cpm	 
16f6			;	dw game2b 
16f6			;	dw game2bf 
16f6			;	dw game2mba 
16f6			;	dw game2mbas	 
16f6			;	dw game2mbht 
16f6			;	dw game2mbms 
16f6			;	dw game2mb 
16f6			;	dw game3w 
16f6			;	dw game3p 
16f6			;	dw game3sc 
16f6			;	dw game3vsi 
16f6			;	dw game3vs 
16f6 00 00			dw 0 
16f8			 
16f8			 
16f8			.spiworddef: 
16f8			 
16f8 ae 62		    dw spi1 
16fa 07 63		    dw spi2 
16fc 3b 63		    dw spi2b 
16fe bf 63		    dw spi3 
1700 69 63		    dw spi4 
1702 92 63		    dw spi5 
1704			;    dw spi6 
1704			;    dw spi7 
1704			 
1704			;    dw spi8 
1704			;    dw spi9 
1704			;    dw spi10 
1704 00 00		    dw 0 
1706			 
1706			.keyworddef: 
1706			 
1706 41 6d			dw keyup 
1708 4f 6d			dw keydown 
170a 5f 6d			dw keyleft 
170c 6f 6d			dw keyright 
170e 80 6d			dw 	keyf1 
1710 8e 6d			dw keyf2 
1712 9c 6d			dw keyf3 
1714 aa 6d			dw keyf4 
1716 b8 6d			dw keyf5 
1718 c6 6d			dw keyf6 
171a d4 6d			dw keyf7 
171c e2 6d			dw keyf8 
171e f0 6d			dw keyf9 
1720 fe 6d			dw keyf10 
1722 0d 6e			dw keyf11 
1724 1c 6e			dw keyf12 
1726 2b 6e			dw keytab 
1728 3a 6e			dw keycr 
172a 48 6e			dw keyhome 
172c 58 6e			dw keyend 
172e 67 6e			dw keybs 
1730 00 00			dw 0 
1732			 
1732			.crstart: 
1732 76 1b			dw crs_s1 
1734 7f 1b			dw crs_s2 
1736 88 1b			dw crs_s3 
1738 94 1b			dw crs_s4 
173a 9b 1b			dw crs_s5 
173c a5 1b			dw crs_s6 
173e b4 1b			dw crs_sound 
1740 c0 1b			dw crs_hw 
1742 00 00			dw 0 
1744			 
1744			endif 
1744			 
1744			 
1744			if STORAGE_SE 
1744			 
1744			config_fdir: 
1744				; using the scratch dir go through and release the memory allocated for each string 
1744				 
1744 21 f6 f0			ld hl, scratch 
1747 5e			.cfdir:	ld e,(hl) 
1748 23				inc hl 
1749 56				ld d,(hl) 
174a 23				inc hl 
174b			 
174b eb				ex de, hl 
174c cd 07 10			call ishlzero 
174f c8				ret z     ; return on null pointer 
1750 cd 83 14			call free 
1753 eb				ex de, hl 
1754 18 f1			jr .cfdir 
1756			 
1756			 
1756 c9				ret 
1757			 
1757			 
1757			config_dir: 
1757			 
1757				; for the config menus that need to build a directory of storage call this routine 
1757				; it will construct a menu in scratch to pass to menu 
1757			 
1757				; open storage device 
1757			 
1757				; execute DIR to build a list of files and their ids into scratch in menu format 
1757				; once the menu has finished then will need to call config_fdir to release the strings 
1757				 
1757				; c = number items 
1757			 
1757				 
1757 cd 25 05			call storage_get_block_0 
175a			 
175a 21 af f9			ld hl, store_page     ; get current id count 
175d 46				ld b, (hl) 
175e 0e 00			ld c, 0    ; count of files   
1760			 
1760			 
1760 21 f6 f0			ld hl, scratch 
1763 22 a6 f9			ld (store_tmp2), hl    ; location to poke strings 
1766			 
1766				; check for empty drive 
1766			 
1766 3e 00			ld a, 0 
1768 b8				cp b 
1769 ca 03 18			jp z, .dirdone 
176c			 
176c				 
176c					if DEBUG_FORTH_WORDS 
176c						DMARK "Cdc" 
176c f5				push af  
176d 3a 81 17			ld a, (.dmark)  
1770 32 a0 fd			ld (debug_mark),a  
1773 3a 82 17			ld a, (.dmark+1)  
1776 32 a1 fd			ld (debug_mark+1),a  
1779 3a 83 17			ld a, (.dmark+2)  
177c 32 a2 fd			ld (debug_mark+2),a  
177f 18 03			jr .pastdmark  
1781 ..			.dmark: db "Cdc"  
1784 f1			.pastdmark: pop af  
1785			endm  
# End of macro DMARK
1785						CALLMONITOR 
1785 cd aa fd			call debug_vector  
1788				endm  
# End of macro CALLMONITOR
1788					endif 
1788			 
1788			 
1788			.diritem:	 
1788 c5				push bc 
1789				; for each of the current ids do a search for them and if found push to stack 
1789			 
1789 21 40 00				ld hl, STORE_BLOCK_PHY 
178c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
178e 58					ld e,b 
178f			 
178f cd a7 07				call storage_findnextid 
1792			 
1792			 
1792					; if found hl will be non zero 
1792			 
1792 cd 07 10				call ishlzero 
1795 28 69				jr z, .dirnotfound 
1797			 
1797					; increase count 
1797			 
1797 c1					pop bc	 
1798 0c					inc c 
1799 c5					push bc 
179a					 
179a			 
179a					; get file header and push the file name 
179a			 
179a 11 af f9				ld de, store_page 
179d cd 74 04				call storage_read_block 
17a0			 
17a0					; push file id to stack 
17a0				 
17a0 3a af f9				ld a, (store_page) 
17a3 26 00				ld h, 0 
17a5 6f					ld l, a 
17a6			 
17a6					;call forth_push_numhl 
17a6					; TODO store id 
17a6			 
17a6 e5					push hl 
17a7			 
17a7					; push extent count to stack  
17a7				 
17a7 21 b2 f9				ld hl, store_page+3 
17aa			 
17aa					; get file name length 
17aa			 
17aa cd 44 13				call strlenz   
17ad			 
17ad 23					inc hl   ; cover zero term 
17ae 23					inc hl  ; stick the id at the end of the area 
17af			 
17af e5					push hl 
17b0 c1					pop bc    ; move length to bc 
17b1			 
17b1 cd b9 13				call malloc 
17b4			 
17b4					; TODO save malloc area to scratch 
17b4			 
17b4 eb					ex de, hl 
17b5 2a a6 f9				ld hl, (store_tmp2) 
17b8 73					ld (hl), e 
17b9 23					inc hl 
17ba 72					ld (hl), d 
17bb 23					inc hl 
17bc 22 a6 f9				ld (store_tmp2), hl 
17bf			 
17bf					 
17bf			 
17bf					;pop hl   ; get source 
17bf			;		ex de, hl    ; swap aronund	 
17bf			 
17bf 21 b2 f9				ld hl, store_page+3 
17c2					if DEBUG_FORTH_WORDS 
17c2						DMARK "CFd" 
17c2 f5				push af  
17c3 3a d7 17			ld a, (.dmark)  
17c6 32 a0 fd			ld (debug_mark),a  
17c9 3a d8 17			ld a, (.dmark+1)  
17cc 32 a1 fd			ld (debug_mark+1),a  
17cf 3a d9 17			ld a, (.dmark+2)  
17d2 32 a2 fd			ld (debug_mark+2),a  
17d5 18 03			jr .pastdmark  
17d7 ..			.dmark: db "CFd"  
17da f1			.pastdmark: pop af  
17db			endm  
# End of macro DMARK
17db						CALLMONITOR 
17db cd aa fd			call debug_vector  
17de				endm  
# End of macro CALLMONITOR
17de					endif 
17de ed b0				ldir 
17e0			 
17e0					; de is past string, move back one and store id 
17e0					 
17e0 1b					dec de 
17e1			 
17e1					; store file id 
17e1			 
17e1 e1					pop hl 
17e2 eb					ex de,hl 
17e3 73					ld (hl), e 
17e4			 
17e4					if DEBUG_FORTH_WORDS 
17e4						DMARK "Cdi" 
17e4 f5				push af  
17e5 3a f9 17			ld a, (.dmark)  
17e8 32 a0 fd			ld (debug_mark),a  
17eb 3a fa 17			ld a, (.dmark+1)  
17ee 32 a1 fd			ld (debug_mark+1),a  
17f1 3a fb 17			ld a, (.dmark+2)  
17f4 32 a2 fd			ld (debug_mark+2),a  
17f7 18 03			jr .pastdmark  
17f9 ..			.dmark: db "Cdi"  
17fc f1			.pastdmark: pop af  
17fd			endm  
# End of macro DMARK
17fd						CALLMONITOR 
17fd cd aa fd			call debug_vector  
1800				endm  
# End of macro CALLMONITOR
1800					endif 
1800					 
1800			.dirnotfound: 
1800 c1					pop bc     
1801 10 85				djnz .diritem 
1803				 
1803			.dirdone:	 
1803			 
1803 3e 00				ld a, 0 
1805 2a a6 f9				ld hl, (store_tmp2) 
1808 77					ld (hl), a 
1809 23					inc hl 
180a 77					ld (hl), a 
180b 23					inc hl 
180c					; push a count of the dir items found 
180c			 
180c			;		ld h, 0 
180c			;		ld l, c 
180c			 
180c c9				ret 
180d			 
180d			endif 
180d			 
180d			 
180d			; Settings 
180d			; Run  
180d			 
180d			 
180d			 
180d			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
180d			;;hd_menu2:   db "        2: Editor",0   
180d			;hd_menu2:   db "        2: Editor       6: Menu",0   
180d			;hd_menu3:   db "        3: Storage",0 
180d			;hd_menu4:   db "0=quit  4: Debug",0 
180d			;hd_don:     db "ON",0 
180d			;hd_doff:     db "OFF",0 
180d			; 
180d			; 
180d			; 
180d			;hardware_diags_old:       
180d			; 
180d			;.diagmenu: 
180d			;	call clear_display 
180d			;	ld a, display_row_1 
180d			;	ld de, hd_menu1 
180d			;	call str_at_display 
180d			; 
180d			;	ld a, display_row_2 
180d			;	ld de, hd_menu2 
180d			;	call str_at_display 
180d			; 
180d			;	ld a, display_row_3 
180d			;	ld de, hd_menu3 
180d			;	call str_at_display 
180d			; 
180d			;	ld a,  display_row_4 
180d			;	ld de, hd_menu4 
180d			;	call str_at_display 
180d			; 
180d			;	; display debug state 
180d			; 
180d			;	ld de, hd_don 
180d			;	ld a, (os_view_disable) 
180d			;	cp 0 
180d			;	jr z, .distog 
180d			;	ld de, hd_doff 
180d			;.distog: ld a, display_row_4+17 
180d			;	call str_at_display 
180d			; 
180d			;	call update_display 
180d			; 
180d			;	call cin_wait 
180d			; 
180d			; 
180d			; 
180d			;	cp '4' 
180d			;	jr nz, .diagn1 
180d			; 
180d			;	; debug toggle 
180d			; 
180d			;	ld a, (os_view_disable) 
180d			;	ld b, '*' 
180d			;	cp 0 
180d			;	jr z, .debtog 
180d			;	ld b, 0 
180d			;.debtog:	 
180d			;	ld a,b 
180d			;	ld (os_view_disable),a 
180d			; 
180d			;.diagn1: cp '0' 
180d			;	 ret z 
180d			; 
180d			;;	cp '1' 
180d			;;       jp z, matrix	 
180d			;;   TODO keyboard matrix test 
180d			; 
180d			;	cp '2' 
180d			;	jp z, .diagedit 
180d			; 
180d			;;	cp '6' 
180d			;;	jp z, .menutest 
180d			;;if ENABLE_BASIC 
180d			;;	cp '6' 
180d			;;	jp z, basic 
180d			;;endif 
180d			 ; 
180d			;	jp .diagmenu 
180d			; 
180d			; 
180d			;	ret 
180d			 
180d			 
180d			.debug_tog: 
180d 21 57 18			ld hl, .menudebug 
1810				 
1810			;	ld a, (os_view_disable) 
1810			;	cp '*' 
1810 3a aa fd			ld a,(debug_vector) 
1813 fe c9			cp $C9   ; RET 
1815 20 04			jr nz,.tdon  
1817 3e 01			ld a, 1 
1819 18 02			jr .tog1 
181b 3e 00		.tdon: ld a, 0 
181d			 
181d			.tog1: 
181d cd db 0d			call menu 
1820 fe 00			cp 0 
1822 c8				ret z 
1823 fe 01			cp 1    ; disable debug 
1825 28 04			jr z, .dtog0 
1827 3e 2a			ld a, '*' 
1829 18 05			jr .dtogset 
182b			.dtog0:  
182b				;ld a, 0 
182b cd 49 19			call bp_on 
182e 18 dd			jr .debug_tog 
1830			.dtogset:  
1830				; ld (os_view_disable), a 
1830 cd 55 19			call bp_off 
1833 c3 0d 18			jp .debug_tog 
1836			 
1836			 
1836			hardware_diags:       
1836			 
1836			.diagm: 
1836 21 49 18			ld hl, .menuitems 
1839 3e 00			ld a, 0 
183b cd db 0d			call menu 
183e			 
183e fe 00		         cp 0 
1840 c8				 ret z 
1841			 
1841 fe 02			cp 2 
1843 ca a2 18			jp z, .diagedit 
1846			 
1846			;	cp '6' 
1846			;	jp z, .menutest 
1846			;if ENABLE_BASIC 
1846			;	cp '6' 
1846			;	jp z, basic 
1846			;endif 
1846			  
1846 c3 36 18			jp .diagm 
1849			 
1849				 
1849 5d 18		.menuitems:   	dw .m1 
184b 68 18				dw .m2 
184d 6f 18				dw .m3 
184f 77 18				dw .m5 
1851 7d 18				dw .m5a 
1853 86 18				dw .m5b 
1855 00 00				dw 0 
1857			 
1857			.menudebug: 
1857 8f 18				dw .m6 
1859 98 18				dw .m7 
185b 00 00				dw 0 
185d			 
185d .. 00		.m1:   db "Key Matrix",0 
1868 .. 00		.m2:   db "Editor",0 
186f .. 00		.m3:   db "Storage",0 
1877 .. 00		.m5:   db "Sound",0 
187d .. 00		.m5a:  db "RAM Test",0 
1886 .. 00		.m5b:  db "LCD Test",0 
188f			 
188f .. 00		.m6:   db "Debug ON",0 
1898 .. 00		.m7:   db "Debug OFF",0 
18a2			 
18a2			; debug editor 
18a2			 
18a2			.diagedit: 
18a2			 
18a2 21 f6 f0			ld hl, scratch 
18a5			;	ld bc, 250 
18a5			;	ldir 
18a5				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18a5 3e 00			ld a, 0 
18a7 77				ld (hl), a 
18a8 23				inc hl 
18a9 77				ld (hl), a 
18aa 23				inc hl 
18ab 77				ld (hl), a 
18ac			 
18ac cd aa 0d		        call clear_display 
18af cd cd 0d			call update_display 
18b2				;ld a, 1 
18b2				;ld (hardware_diag), a 
18b2			.diloop: 
18b2 3e 00			ld a, display_row_1 
18b4 0e 00			ld c, 0 
18b6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18b8 1e 28			ld e, 40 
18ba			 
18ba 21 f6 f0			ld hl, scratch	 
18bd cd 0b 10			call input_str 
18c0			 
18c0 3e 28			ld a, display_row_2 
18c2 11 f6 f0			ld de, scratch 
18c5 cd bd 0d			call str_at_display 
18c8 cd cd 0d			call update_display 
18cb			 
18cb c3 b2 18			jp .diloop 
18ce			 
18ce			 
18ce			; pass word in hl 
18ce			; a has display location 
18ce			display_word_at: 
18ce f5				push af 
18cf e5				push hl 
18d0 7c				ld a,h 
18d1 21 fb f3			ld hl, os_word_scratch 
18d4 cd e7 11			call hexout 
18d7 e1				pop hl 
18d8 7d				ld a,l 
18d9 21 fd f3			ld hl, os_word_scratch+2 
18dc cd e7 11			call hexout 
18df 21 ff f3			ld hl, os_word_scratch+4 
18e2 3e 00			ld a,0 
18e4 77				ld (hl),a 
18e5 11 fb f3			ld de,os_word_scratch 
18e8 f1				pop af 
18e9 cd bd 0d				call str_at_display 
18ec c9				ret 
18ed			 
18ed			display_ptr_state: 
18ed			 
18ed				; to restore afterwards 
18ed			 
18ed d5				push de 
18ee c5				push bc 
18ef e5				push hl 
18f0 f5				push af 
18f1			 
18f1				; for use in here 
18f1			 
18f1			;	push bc 
18f1			;	push de 
18f1			;	push hl 
18f1			;	push af 
18f1			 
18f1 cd aa 0d			call clear_display 
18f4			 
18f4 11 cc 1a			ld de, .ptrstate 
18f7 3e 00			ld a, display_row_1 
18f9 cd bd 0d			call str_at_display 
18fc			 
18fc				; display debug step 
18fc			 
18fc			 
18fc 11 a0 fd			ld de, debug_mark 
18ff 3e 26			ld a, display_row_1+display_cols-2 
1901 cd bd 0d			call str_at_display 
1904			 
1904				; display a 
1904 11 d6 1a			ld de, .ptrcliptr 
1907 3e 28			ld a, display_row_2 
1909 cd bd 0d			call str_at_display 
190c			 
190c f1				pop af 
190d 2a 75 f9			ld hl,(cli_ptr) 
1910 3e 30			ld a, display_row_2+8 
1912 cd ce 18			call display_word_at 
1915			 
1915			 
1915				; display hl 
1915			 
1915			 
1915 11 de 1a			ld de, .ptrclioptr 
1918 3e 32			ld a, display_row_2+10 
191a cd bd 0d			call str_at_display 
191d			; 
191d			;	pop hl 
191d 3e 35			ld a, display_row_2+13 
191f 2a 73 f9			ld hl,(cli_origptr) 
1922 cd ce 18			call display_word_at 
1925			; 
1925			;	 
1925			;	; display de 
1925			 
1925			;	ld de, .regstatede 
1925			;	ld a, display_row_3 
1925			;	call str_at_display 
1925			 
1925			;	pop de 
1925			;	ld h,d 
1925			;	ld l, e 
1925			;	ld a, display_row_3+3 
1925			;	call display_word_at 
1925			 
1925			 
1925				; display bc 
1925			 
1925			;	ld de, .regstatebc 
1925			;	ld a, display_row_3+10 
1925			;	call str_at_display 
1925			 
1925			;	pop bc 
1925			;	ld h,b 
1925			;	ld l, c 
1925			;	ld a, display_row_3+13 
1925			;	call display_word_at 
1925			 
1925			 
1925				; display dsp 
1925			 
1925			;	ld de, .regstatedsp 
1925			;	ld a, display_row_4 
1925			;	call str_at_display 
1925			 
1925				 
1925			;	ld hl,(cli_data_sp) 
1925			;	ld a, display_row_4+4 
1925			;	call display_word_at 
1925			 
1925				; display rsp 
1925			 
1925 11 0d 1b			ld de, .regstatersp 
1928 3e 82			ld a, display_row_4+10 
192a cd bd 0d			call str_at_display 
192d			 
192d				 
192d 2a 27 f9			ld hl,(cli_ret_sp) 
1930 3e 86			ld a, display_row_4+14 
1932 cd ce 18			call display_word_at 
1935			 
1935 cd cd 0d			call update_display 
1938			 
1938 cd ed 0c			call delay1s 
193b cd ed 0c			call delay1s 
193e cd ed 0c			call delay1s 
1941			 
1941			 
1941 cd c0 1f			call next_page_prompt 
1944			 
1944				; restore  
1944			 
1944 f1				pop af 
1945 e1				pop hl 
1946 c1				pop bc 
1947 d1				pop de 
1948 c9				ret 
1949			 
1949			; Update the break point vector so that the user can hook a new routine 
1949			 
1949			bp_on: 
1949 3e c3			ld a, $c3    ; JP 
194b 32 aa fd			ld (debug_vector), a 
194e 21 5b 19			ld hl, break_point_state 
1951 22 ab fd			ld (debug_vector+1), hl 
1954 c9				ret 
1955			 
1955			bp_off: 
1955 3e c9			ld a, $c9    ; RET 
1957 32 aa fd			ld (debug_vector), a 
195a c9				ret 
195b			 
195b			 
195b			break_point_state: 
195b			;	push af 
195b			; 
195b			;	; see if disabled 
195b			; 
195b			;	ld a, (os_view_disable) 
195b			;	cp '*' 
195b			;	jr nz, .bpsgo 
195b			;	pop af 
195b			;	ret 
195b			 
195b			.bpsgo: 
195b			;	pop af 
195b f5				push af 
195c 22 d8 f0			ld (os_view_hl), hl 
195f ed 53 d6 f0		ld (os_view_de), de 
1963 ed 43 d4 f0		ld (os_view_bc), bc 
1967 e5				push hl 
1968 6f				ld l, a 
1969 26 00			ld h, 0 
196b 22 da f0			ld (os_view_af),hl 
196e			 
196e 21 e6 fc				ld hl, display_fb0 
1971 22 01 fb				ld (display_fb_active), hl 
1974 e1				pop hl	 
1975			 
1975 3e 31			ld a, '1' 
1977 fe 2a		.bps1:  cp '*' 
1979 cc 55 19			call z, bp_off 
197c			;	jr nz, .bps1b 
197c			;	ld (os_view_disable),a 
197c fe 31		.bps1b:  cp '1' 
197e 20 14			jr nz, .bps2 
1980			 
1980				; display reg 
1980			 
1980				 
1980			 
1980 3a da f0			ld a, (os_view_af) 
1983 2a d8 f0			ld hl, (os_view_hl) 
1986 ed 5b d6 f0		ld de, (os_view_de) 
198a ed 4b d4 f0		ld bc, (os_view_bc) 
198e cd 28 1a			call display_reg_state 
1991 c3 14 1a			jp .bpschk 
1994			 
1994 fe 32		.bps2:  cp '2' 
1996 20 08			jr nz, .bps3 
1998				 
1998				; display hl 
1998 2a d8 f0			ld hl, (os_view_hl) 
199b cd 12 1b			call display_dump_at_hl 
199e			 
199e 18 74			jr .bpschk 
19a0			 
19a0 fe 33		.bps3:  cp '3' 
19a2 20 08			jr nz, .bps4 
19a4			 
19a4			        ; display de 
19a4 2a d6 f0			ld hl, (os_view_de) 
19a7 cd 12 1b			call display_dump_at_hl 
19aa			 
19aa 18 68			jr .bpschk 
19ac fe 34		.bps4:  cp '4' 
19ae 20 08			jr nz, .bps5 
19b0			 
19b0			        ; display bc 
19b0 2a d4 f0			ld hl, (os_view_bc) 
19b3 cd 12 1b			call display_dump_at_hl 
19b6			 
19b6 18 5c			jr .bpschk 
19b8 fe 35		.bps5:  cp '5' 
19ba 20 08		        jr nz, .bps7 
19bc			 
19bc				; display cur ptr 
19bc 2a 75 f9			ld hl, (cli_ptr) 
19bf cd 12 1b			call display_dump_at_hl 
19c2			 
19c2 18 50			jr .bpschk 
19c4 fe 36		.bps7:  cp '6' 
19c6 20 08			jr nz, .bps8b 
19c8				 
19c8				; display cur orig ptr 
19c8 2a 73 f9			ld hl, (cli_origptr) 
19cb cd 12 1b			call display_dump_at_hl 
19ce 18 44			jr .bpschk 
19d0 fe 37		.bps8b:  cp '7' 
19d2 20 08			jr nz, .bps9 
19d4				 
19d4				; display dsp 
19d4 2a 23 f9			ld hl, (cli_data_sp) 
19d7 cd 12 1b			call display_dump_at_hl 
19da			 
19da 18 38			jr .bpschk 
19dc fe 39		.bps9:  cp '9' 
19de 20 05			jr nz, .bps8c 
19e0				 
19e0				; display SP 
19e0			;	ld hl, sp 
19e0 cd 12 1b			call display_dump_at_hl 
19e3			 
19e3 18 2f			jr .bpschk 
19e5 fe 38		.bps8c:  cp '8' 
19e7 20 08			jr nz, .bps8d 
19e9				 
19e9				; display rsp 
19e9 2a 27 f9			ld hl, (cli_ret_sp) 
19ec cd 12 1b			call display_dump_at_hl 
19ef			 
19ef 18 23			jr .bpschk 
19f1 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
19f3 20 05			jr nz, .bps8 
19f5 cd 7a 1d			call monitor 
19f8			 
19f8 18 1a			jr .bpschk 
19fa fe 30		.bps8:  cp '0' 
19fc 20 16			jr nz, .bpschk 
19fe			 
19fe 21 45 fc				ld hl, display_fb1 
1a01 22 01 fb				ld (display_fb_active), hl 
1a04 cd cd 0d				call update_display 
1a07			 
1a07				;ld a, (os_view_af) 
1a07 2a d8 f0			ld hl, (os_view_hl) 
1a0a ed 5b d6 f0		ld de, (os_view_de) 
1a0e ed 4b d4 f0		ld bc, (os_view_bc) 
1a12 f1				pop af 
1a13 c9				ret 
1a14			 
1a14			.bpschk:   
1a14 cd ed 0c			call delay1s 
1a17 3e 9f		ld a,display_row_4 + display_cols - 1 
1a19 11 be 1f		        ld de, endprg 
1a1c cd bd 0d			call str_at_display 
1a1f cd cd 0d			call update_display 
1a22 cd eb 75			call cin_wait 
1a25			 
1a25 c3 77 19			jp .bps1 
1a28			 
1a28			 
1a28			display_reg_state: 
1a28			 
1a28				; to restore afterwards 
1a28			 
1a28 d5				push de 
1a29 c5				push bc 
1a2a e5				push hl 
1a2b f5				push af 
1a2c			 
1a2c				; for use in here 
1a2c			 
1a2c c5				push bc 
1a2d d5				push de 
1a2e e5				push hl 
1a2f f5				push af 
1a30			 
1a30 cd aa 0d			call clear_display 
1a33			 
1a33 11 e8 1a			ld de, .regstate 
1a36 3e 00			ld a, display_row_1 
1a38 cd bd 0d			call str_at_display 
1a3b			 
1a3b				; display debug step 
1a3b			 
1a3b			 
1a3b 11 a0 fd			ld de, debug_mark 
1a3e 3e 25			ld a, display_row_1+display_cols-3 
1a40 cd bd 0d			call str_at_display 
1a43			 
1a43				; display a 
1a43 11 04 1b			ld de, .regstatea 
1a46 3e 28			ld a, display_row_2 
1a48 cd bd 0d			call str_at_display 
1a4b			 
1a4b e1				pop hl 
1a4c			;	ld h,0 
1a4c			;	ld l, a 
1a4c 3e 2b			ld a, display_row_2+3 
1a4e cd ce 18			call display_word_at 
1a51			 
1a51			 
1a51				; display hl 
1a51			 
1a51			 
1a51 11 f8 1a			ld de, .regstatehl 
1a54 3e 32			ld a, display_row_2+10 
1a56 cd bd 0d			call str_at_display 
1a59			 
1a59 e1				pop hl 
1a5a 3e 35			ld a, display_row_2+13 
1a5c cd ce 18			call display_word_at 
1a5f			 
1a5f				 
1a5f				; display de 
1a5f			 
1a5f 11 fc 1a			ld de, .regstatede 
1a62 3e 50			ld a, display_row_3 
1a64 cd bd 0d			call str_at_display 
1a67			 
1a67 e1				pop hl 
1a68			;	ld h,d 
1a68			;	ld l, e 
1a68 3e 53			ld a, display_row_3+3 
1a6a cd ce 18			call display_word_at 
1a6d			 
1a6d			 
1a6d				; display bc 
1a6d			 
1a6d 11 00 1b			ld de, .regstatebc 
1a70 3e 5a			ld a, display_row_3+10 
1a72 cd bd 0d			call str_at_display 
1a75			 
1a75 e1				pop hl 
1a76			;	ld h,b 
1a76			;	ld l, c 
1a76 3e 5d			ld a, display_row_3+13 
1a78 cd ce 18			call display_word_at 
1a7b			 
1a7b			 
1a7b				; display dsp 
1a7b			 
1a7b 11 08 1b			ld de, .regstatedsp 
1a7e 3e 78			ld a, display_row_4 
1a80 cd bd 0d			call str_at_display 
1a83			 
1a83				 
1a83 2a 23 f9			ld hl,(cli_data_sp) 
1a86 3e 7c			ld a, display_row_4+4 
1a88 cd ce 18			call display_word_at 
1a8b			 
1a8b				; display rsp 
1a8b			 
1a8b 11 0d 1b			ld de, .regstatersp 
1a8e 3e 82			ld a, display_row_4+10 
1a90 cd bd 0d			call str_at_display 
1a93			 
1a93				 
1a93 2a 27 f9			ld hl,(cli_ret_sp) 
1a96 3e 86			ld a, display_row_4+14 
1a98 cd ce 18			call display_word_at 
1a9b			 
1a9b cd cd 0d			call update_display 
1a9e			 
1a9e			;	call delay1s 
1a9e			;	call delay1s 
1a9e			;	call delay1s 
1a9e			 
1a9e			 
1a9e			;	call next_page_prompt 
1a9e			 
1a9e				; restore  
1a9e			 
1a9e f1				pop af 
1a9f e1				pop hl 
1aa0 c1				pop bc 
1aa1 d1				pop de 
1aa2 c9				ret 
1aa3			 
1aa3 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ab7 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1acc .. 00		.ptrstate:	db "Ptr State",0 
1ad6 .. 00		.ptrcliptr:     db "cli_ptr",0 
1ade .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1ae8 .. 00		.regstate:	db "Reg State (1/0)",0 
1af8 .. 00		.regstatehl:	db "HL:",0 
1afc .. 00		.regstatede:	db "DE:",0 
1b00 .. 00		.regstatebc:	db "BC:",0 
1b04 .. 00		.regstatea:	db "A :",0 
1b08 .. 00		.regstatedsp:	db "DSP:",0 
1b0d .. 00		.regstatersp:	db "RSP:",0 
1b12			 
1b12			display_dump_at_hl: 
1b12 e5				push hl 
1b13 d5				push de 
1b14 c5				push bc 
1b15 f5				push af 
1b16			 
1b16 22 19 f4			ld (os_cur_ptr),hl	 
1b19 cd aa 0d			call clear_display 
1b1c cd c8 1e			call dumpcont 
1b1f			;	call delay1s 
1b1f			;	call next_page_prompt 
1b1f			 
1b1f			 
1b1f f1				pop af 
1b20 c1				pop bc 
1b21 d1				pop de 
1b22 e1				pop hl 
1b23 c9				ret 
1b24			 
1b24			;if ENABLE_BASIC 
1b24			;	include "nascombasic.asm" 
1b24			;	basic: 
1b24			;	include "forth/FORTH.ASM" 
1b24			;endif 
1b24			 
1b24			; eof 
1b24			 
1b24			 
# End of file firmware_diags.asm
1b24			  
1b24			include "firmware_prompts.asm"  
1b24			; Prompts  
1b24			 
1b24			; boot messages 
1b24			 
1b24 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1b39 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1b49			 
1b49			 
1b49			; config menus 
1b49			 
1b49			;prom_c3: db "Add Dictionary To File",0 
1b49			 
1b49			if STARTUP_V1 
1b49			prom_c2: db "Select Autoload File",0 
1b49			prom_c2a: db "Disable Autoload File", 0 
1b49			endif 
1b49			 
1b49			if STARTUP_V2 
1b49 .. 00		prom_c2: db "Enable Autoload Files",0 
1b5f .. 00		prom_c2a: db "Disable Autoload Files", 0 
1b76			 
1b76 .. 00		crs_s1: db "*ls-word", 0 
1b7f .. 00		crs_s2: db "*ed-word", 0 
1b88 .. 00		crs_s3: db "*Demo-Games", 0 
1b94 .. 00		crs_s4: db "*Utils", 0 
1b9b .. 00		crs_s5: db "*SPI-Util", 0 
1ba5 .. 00		crs_s6: db "*Key-Constants", 0 
1bb4 .. 00		crs_sound: db "*Sound-Util", 0 
1bc0 .. 00		crs_hw: db "*Hello-World",0 
1bcd			 
1bcd			 
1bcd			 
1bcd			endif 
1bcd			;prom_c2b: db "Select Storage Bank",0 
1bcd .. 00		prom_c4: db "Settings",0 
1bd6 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1bf1 .. 00		prom_m4b:   db "Monitor",0 
1bf9 .. 00		prom_c1: db "Hardware Diags",0 
1c08			 
1c08			 
1c08			if STARTUP_V2 
1c08 .. 00		prom_c9: db "Create Startup Files",0 
1c1d			endif 
1c1d			 
1c1d .. 00		prom_notav:    db "Feature not available",0 
1c33 .. 00		prom_empty:    db "",0 
1c34			 
1c34			; eof 
1c34			 
# End of file firmware_prompts.asm
1c34			  
1c34			  
1c34			; eof  
1c34			  
# End of file firmware.asm
1c34			 
1c34			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1c34			;if BASE_KEV  
1c34			;baseram: equ 08000h 
1c34			;endif 
1c34			 
1c34			;if BASE_SC114 
1c34			;baseram:     equ    endofcode 
1c34			;endif 
1c34			 
1c34			 
1c34			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1c34			 
1c34			; start system 
1c34			 
1c34			coldstart: 
1c34				; set sp 
1c34				; di/ei 
1c34			 
1c34 f3				di 
1c35 31 fd ff			ld sp, tos 
1c38 cd 72 72			call init_nmi 
1c3b			;	ei 
1c3b			 
1c3b				; init spinner 
1c3b 3e 00			ld a,0 
1c3d 32 fb fa			ld (display_active), a 
1c40			 
1c40				; disable breakpoint by default 
1c40			 
1c40				;ld a,'*' 
1c40			;	ld a,' ' 
1c40			;	ld (os_view_disable),a 
1c40			 
1c40				; set break point vector as new break point on or off 
1c40 cd 55 19			call bp_off 
1c43			 
1c43				; init hardware 
1c43			 
1c43				; init keyboard and screen hardware 
1c43			 
1c43 cd 6c 00			call hardware_init 
1c46			 
1c46			 
1c46 cd ed 0c			call delay1s 
1c49 3e 58			ld a, display_row_3+8 
1c4b 11 03 00			ld de, buildtime 
1c4e cd bd 0d			call str_at_display 
1c51 cd cd 0d			call update_display 
1c54			 
1c54 cd ed 0c			call delay1s 
1c57 cd ed 0c			call delay1s 
1c5a cd ed 0c			call delay1s 
1c5d			 
1c5d				; detect if any keys are held down to enable breakpoints at start up 
1c5d			 
1c5d cd fc 75			call cin  
1c60 fe 00			cp 0 
1c62 28 03			jr z, .nokeys 
1c64			 
1c64				;call hardware_diags 
1c64 cd 52 15			call config 
1c67			 
1c67			;	ld de, .bpen 
1c67			;	ld a, display_row_4 
1c67			;	call str_at_display 
1c67			;	call update_display 
1c67			; 
1c67			;	ld a,0 
1c67			;	ld (os_view_disable),a 
1c67			; 
1c67			;.bpwait: 
1c67			;	call cin 
1c67			;	cp 0 
1c67			;	jr z, .bpwait 
1c67			;	jr .nokeys 
1c67			; 
1c67			; 
1c67			;.bpen:  db "Break points enabled!",0 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			.nokeys: 
1c67			 
1c67			 
1c67				 
1c67			 
1c67			;jp  testkey 
1c67			 
1c67			;call storage_get_block_0 
1c67			; 
1c67			;ld hl, 0 
1c67			;ld de, store_page 
1c67			;call storage_read_block 
1c67			 
1c67				 
1c67			;ld hl, 10 
1c67			;ld de, store_page 
1c67			;call storage_read_block 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			;stop:	nop 
1c67			;	jp stop 
1c67			 
1c67			 
1c67			 
1c67			main: 
1c67 cd aa 0d			call clear_display 
1c6a cd cd 0d			call update_display 
1c6d			 
1c6d			 
1c6d			 
1c6d			;	call testlcd 
1c6d			 
1c6d			 
1c6d			 
1c6d cd 09 24			call forth_init 
1c70			 
1c70			 
1c70			warmstart: 
1c70 cd df 23			call forth_warmstart 
1c73			 
1c73				; run startup word load 
1c73			        ; TODO prevent this running at warmstart after crash  
1c73			 
1c73				if STARTUP_ENABLE 
1c73			 
1c73					if STARTUP_V1 
1c73			 
1c73						if STORAGE_SE 
1c73							call forth_autoload 
1c73						endif 
1c73						call forth_startup 
1c73					endif 
1c73			 
1c73					if STARTUP_V2 
1c73			 
1c73						if STORAGE_SE 
1c73 cd a0 70						call forth_autoload 
1c76						else 
1c76							call forth_startup 
1c76						endif 
1c76			 
1c76			 
1c76					endif 
1c76			 
1c76				endif 
1c76			 
1c76			warmstart_afterauto: 
1c76			 
1c76				; show free memory after boot 
1c76 11 15 1d			ld de, freeram 
1c79 3e 00			ld a, display_row_1 
1c7b cd bd 0d			call str_at_display 
1c7e			 
1c7e				; get current heap start after loading any uwords 
1c7e			 
1c7e				;ld de, (os_last_new_uword) 
1c7e				;ex de, hl 
1c7e			 
1c7e			; Or use heap_size word???? 
1c7e				;ld hl, heap_end 
1c7e				;ld hl, heap_size 
1c7e				;ld de, topusermem 
1c7e				;ld de, heap_start 
1c7e ed 5b 0a 80			ld de, (free_list )      
1c82 21 d1 f0				ld hl, heap_end 
1c85 ed 52			sbc hl, de 
1c87				;push hl 
1c87				;ld a,h	         	 
1c87				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c87				;call hexout 
1c87			   	;pop hl 
1c87			; 
1c87			;	ld a,l 
1c87			;	ld hl, os_word_scratch+2 
1c87			;	call hexout 
1c87			;	ld hl, os_word_scratch+4 
1c87			;	ld a, 0 
1c87			;	ld (hl),a 
1c87 eb				ex de, hl 
1c88 21 fb f3			ld hl, os_word_scratch 
1c8b cd f3 12			call uitoa_16 
1c8e			 
1c8e			 
1c8e 11 fb f3			ld de, os_word_scratch 
1c91 3e 0d			ld a, display_row_1 + 13 
1c93 cd bd 0d			call str_at_display 
1c96 cd cd 0d			call update_display 
1c99			 
1c99			 
1c99				;call demo 
1c99			 
1c99			 
1c99				; init scratch input area for cli commands 
1c99			 
1c99 21 1d f4			ld hl, os_cli_cmd 
1c9c 3e 00			ld a,0 
1c9e 77				ld (hl),a 
1c9f 23				inc hl 
1ca0 77				ld (hl),a 
1ca1			 
1ca1 3e 00			ld a,0 
1ca3 32 1c f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1ca6			 
1ca6 32 19 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1ca9 32 1a f4			ld (os_cur_ptr+1),a	 
1cac			 
1cac 32 fb f3			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1caf 32 fc f3			ld (os_word_scratch+1),a	 
1cb2				 
1cb2			 
1cb2				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cb2 21 1d f4			ld hl, os_cli_cmd 
1cb5			 
1cb5 3e 00			ld a, 0		 ; init cli input 
1cb7 77				ld (hl), a 
1cb8 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cba			cli: 
1cba				; show cli prompt 
1cba				;push af 
1cba				;ld a, 0 
1cba				;ld de, prompt 
1cba				;call str_at_display 
1cba			 
1cba				;call update_display 
1cba				;pop af 
1cba				;inc a 
1cba				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1cba			 
1cba			.lastrecall: 
1cba			 
1cba 0e 00			ld c, 0 
1cbc 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1cbe 1e 28			ld e, 40 
1cc0			 
1cc0 21 1d f4			ld hl, os_cli_cmd 
1cc3			 
1cc3				STACKFRAME OFF $fefe $9f9f 
1cc3				if DEBUG_STACK_IMB 
1cc3					if OFF 
1cc3						exx 
1cc3						ld de, $fefe 
1cc3						ld a, d 
1cc3						ld hl, curframe 
1cc3						call hexout 
1cc3						ld a, e 
1cc3						ld hl, curframe+2 
1cc3						call hexout 
1cc3						ld hl, $fefe 
1cc3						push hl 
1cc3						ld hl, $9f9f 
1cc3						push hl 
1cc3						exx 
1cc3					endif 
1cc3				endif 
1cc3			endm 
# End of macro STACKFRAME
1cc3			 
1cc3 cd 0b 10			call input_str 
1cc6			 
1cc6				STACKFRAMECHK OFF $fefe $9f9f 
1cc6				if DEBUG_STACK_IMB 
1cc6					if OFF 
1cc6						exx 
1cc6						ld hl, $9f9f 
1cc6						pop de   ; $9f9f 
1cc6						call cmp16 
1cc6						jr nz, .spnosame 
1cc6						ld hl, $fefe 
1cc6						pop de   ; $fefe 
1cc6						call cmp16 
1cc6						jr z, .spfrsame 
1cc6						.spnosame: call showsperror 
1cc6						.spfrsame: nop 
1cc6						exx 
1cc6					endif 
1cc6				endif 
1cc6			endm 
# End of macro STACKFRAMECHK
1cc6			 
1cc6			 
1cc6				; check to see if last line recall has been requested 
1cc6			 
1cc6			if EDIT_V2 
1cc6 fe 05			cp KEY_UP 
1cc8 20 0f			jr nz, .noexecline 
1cca			 
1cca 11 1d f4			ld de, os_cli_cmd 
1ccd 21 1c f5			ld hl, os_last_cmd 
1cd0 01 ff 00			ld bc, 255 
1cd3 ed b0			ldir 
1cd5 3e 00			ld a, 0 
1cd7 18 e1			jr .lastrecall 
1cd9			endif 
1cd9			 
1cd9			.noexecline: 
1cd9				; no so exec the line		 
1cd9			 
1cd9				; copy input to last command 
1cd9			 
1cd9 21 1d f4			ld hl, os_cli_cmd 
1cdc 11 1c f5			ld de, os_last_cmd 
1cdf 01 ff 00			ld bc, 255 
1ce2 ed b0			ldir 
1ce4			 
1ce4				; wipe current buffer 
1ce4			 
1ce4			;	ld a, 0 
1ce4			;	ld hl, os_cli_cmd 
1ce4			;	ld de, os_cli_cmd+1 
1ce4			;	ld bc, 254 
1ce4			;	ldir 
1ce4				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1ce4			;	call strcpy 
1ce4			;	ld a, 0 
1ce4			;	ld (hl), a 
1ce4			;	inc hl 
1ce4			;	ld (hl), a 
1ce4			;	inc hl 
1ce4			;	ld (hl), a 
1ce4			 
1ce4				; switch frame buffer to program  
1ce4			 
1ce4 21 45 fc				ld hl, display_fb1 
1ce7 22 01 fb				ld (display_fb_active), hl 
1cea			 
1cea			;	nop 
1cea				STACKFRAME ON $fbfe $8f9f 
1cea				if DEBUG_STACK_IMB 
1cea					if ON 
1cea						exx 
1cea						ld de, $fbfe 
1cea						ld a, d 
1cea						ld hl, curframe 
1cea						call hexout 
1cea						ld a, e 
1cea						ld hl, curframe+2 
1cea						call hexout 
1cea						ld hl, $fbfe 
1cea						push hl 
1cea						ld hl, $8f9f 
1cea						push hl 
1cea						exx 
1cea					endif 
1cea				endif 
1cea			endm 
# End of macro STACKFRAME
1cea				; first time into the parser so pass over the current scratch pad 
1cea 21 1d f4			ld hl,os_cli_cmd 
1ced				; tokenise the entered statement(s) in HL 
1ced cd 83 24			call forthparse 
1cf0			        ; exec forth statements in top of return stack 
1cf0 cd bf 24			call forthexec 
1cf3				;call forthexec_cleanup 
1cf3			;	call parsenext 
1cf3			 
1cf3				STACKFRAMECHK ON $fbfe $8f9f 
1cf3				if DEBUG_STACK_IMB 
1cf3					if ON 
1cf3						exx 
1cf3						ld hl, $8f9f 
1cf3						pop de   ; $8f9f 
1cf3						call cmp16 
1cf3						jr nz, .spnosame 
1cf3						ld hl, $fbfe 
1cf3						pop de   ; $fbfe 
1cf3						call cmp16 
1cf3						jr z, .spfrsame 
1cf3						.spnosame: call showsperror 
1cf3						.spfrsame: nop 
1cf3						exx 
1cf3					endif 
1cf3				endif 
1cf3			endm 
# End of macro STACKFRAMECHK
1cf3				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1cf3			 
1cf3 3e 78			ld a, display_row_4 
1cf5 11 26 1d			ld de, endprog 
1cf8			 
1cf8 cd cd 0d			call update_display		 
1cfb			 
1cfb cd c0 1f			call next_page_prompt 
1cfe			 
1cfe				; switch frame buffer to cli 
1cfe			 
1cfe 21 e6 fc				ld hl, display_fb0 
1d01 22 01 fb				ld (display_fb_active), hl 
1d04			 
1d04			 
1d04 cd aa 0d		        call clear_display 
1d07 cd cd 0d			call update_display		 
1d0a			 
1d0a 21 1d f4			ld hl, os_cli_cmd 
1d0d			 
1d0d 3e 00			ld a, 0		 ; init cli input 
1d0f 77				ld (hl), a 
1d10			 
1d10				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1d10			 
1d10				; now on last line 
1d10			 
1d10				; TODO scroll screen up 
1d10			 
1d10				; TODO instead just clear screen and place at top of screen 
1d10			 
1d10			;	ld a, 0 
1d10			;	ld (f_cursor_ptr),a 
1d10			 
1d10				;call clear_display 
1d10				;call update_display 
1d10			 
1d10				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d10 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d12 c3 ba 1c			jp cli 
1d15			 
1d15 .. 00		freeram: db "Free bytes: ",0 
1d22 ..			asc: db "1A2F" 
1d26 .. 00		endprog: db "End prog...",0 
1d32			 
1d32			testenter2:   
1d32 21 28 f1			ld hl,scratch+50 
1d35 22 19 f4			ld (os_cur_ptr),hl 
1d38 c3 ba 1c			jp cli 
1d3b			 
1d3b			testenter:  
1d3b			 
1d3b 21 22 1d			ld hl,asc 
1d3e			;	ld a,(hl) 
1d3e			;	call nibble2val 
1d3e cd 3d 12			call get_byte 
1d41			 
1d41			 
1d41			;	ld a,(hl) 
1d41			;	call atohex 
1d41			 
1d41			;	call fourehexhl 
1d41 32 28 f1			ld (scratch+50),a 
1d44			 
1d44			 
1d44			 
1d44 21 24 1d			ld hl,asc+2 
1d47			;	ld a, (hl) 
1d47			;	call nibble2val 
1d47 cd 3d 12			call get_byte 
1d4a			 
1d4a			;	call fourehexhl 
1d4a 32 2a f1			ld (scratch+52),a 
1d4d				 
1d4d 21 28 f1			ld hl,scratch+50 
1d50 22 19 f4			ld (os_cur_ptr),hl 
1d53 c3 ba 1c			jp cli 
1d56			 
1d56			enter:	 
1d56 3a fa f0			ld a,(scratch+4) 
1d59 fe 00			cp 0 
1d5b 28 0c			jr z, .entercont 
1d5d				; no, not a null term line so has an address to work out.... 
1d5d			 
1d5d 21 f8 f0			ld hl,scratch+2 
1d60 cd 9d 12			call get_word_hl 
1d63			 
1d63 22 19 f4			ld (os_cur_ptr),hl	 
1d66 c3 ba 1c			jp cli 
1d69			 
1d69			 
1d69			.entercont:  
1d69			 
1d69 21 f8 f0			ld hl, scratch+2 
1d6c cd 3d 12			call get_byte 
1d6f			 
1d6f 2a 19 f4		   	ld hl,(os_cur_ptr) 
1d72 77					ld (hl),a 
1d73 23					inc hl 
1d74 22 19 f4				ld (os_cur_ptr),hl 
1d77				 
1d77			; get byte  
1d77			 
1d77			 
1d77 c3 ba 1c			jp cli 
1d7a			 
1d7a			 
1d7a			; basic monitor support 
1d7a			 
1d7a			monitor: 
1d7a				;  
1d7a cd aa 0d			call clear_display 
1d7d 3e 00			ld a, 0 
1d7f 11 d3 1d			ld de, .monprompt 
1d82 cd bd 0d			call str_at_display 
1d85 cd cd 0d			call update_display 
1d88			 
1d88				; get a monitor command 
1d88			 
1d88 0e 00			ld c, 0     ; entry at top left 
1d8a 16 64			ld d, 100   ; max buffer size 
1d8c 1e 0f			ld e, 15    ; input scroll area 
1d8e 3e 00			ld a, 0     ; init string 
1d90 21 f4 f2			ld hl, os_input 
1d93 77				ld (hl), a 
1d94 23				inc hl 
1d95 77				ld (hl), a 
1d96 21 f4 f2			ld hl, os_input 
1d99 3e 01			ld a, 1     ; init string 
1d9b cd 0b 10			call input_str 
1d9e			 
1d9e cd aa 0d		        call clear_display 
1da1 cd cd 0d			call update_display		 
1da4			 
1da4 3a f4 f2			ld a, (os_input) 
1da7 cd 3b 13			call toUpper 
1daa fe 48		        cp 'H' 
1dac ca 47 1e		        jp z, .monhelp 
1daf fe 44			cp 'D'		; dump 
1db1 ca 7a 1e			jp z, .mondump	 
1db4 fe 43			cp 'C'		; dump 
1db6 ca 94 1e			jp z, .moncdump	 
1db9 fe 4d			cp 'M'		; dump 
1dbb ca d5 1d			jp z, .moneditstart 
1dbe fe 55			cp 'U'		; dump 
1dc0 ca e1 1d			jp z, .monedit	 
1dc3 fe 47			cp 'G'		; dump 
1dc5 ca 70 1e			jp z, .monjump 
1dc8 fe 42			cp 'B'		; forth breakpoint 
1dca cc 5b 19			call z, break_point_state 
1dcd fe 51			cp 'Q'		; dump 
1dcf c8				ret z	 
1dd0			 
1dd0			 
1dd0				; TODO "S" to access symbol by name and not need the address 
1dd0				; TODO "F" to find a string in memory 
1dd0			 
1dd0 c3 7a 1d			jp monitor 
1dd3			 
1dd3 .. 00		.monprompt: db ">", 0 
1dd5			 
1dd5			.moneditstart: 
1dd5				; get starting address 
1dd5			 
1dd5 21 f6 f2			ld hl,os_input+2 
1dd8 cd 9d 12			call get_word_hl 
1ddb			 
1ddb 22 19 f4			ld (os_cur_ptr),hl	 
1dde			 
1dde c3 7a 1d			jp monitor 
1de1			 
1de1			.monedit: 
1de1				; get byte to load 
1de1			 
1de1 21 f6 f2			ld hl,os_input+2 
1de4 cd 3d 12			call get_byte 
1de7			 
1de7				; get address to update 
1de7 2a 19 f4			ld hl, (os_cur_ptr) 
1dea			 
1dea				; update byte 
1dea			 
1dea 77				ld (hl), a 
1deb			 
1deb				; move to next address and save it 
1deb			 
1deb 23				inc hl 
1dec 22 19 f4			ld (os_cur_ptr),hl	 
1def			 
1def c3 7a 1d			jp monitor 
1df2			 
1df2			 
1df2 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1e06 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1e22 .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
1e40 .. 00		.monhelptext4:  db "Q-Quit",0 
1e47			        
1e47			.monhelp: 
1e47 3e 00			ld a, display_row_1 
1e49 11 f2 1d		        ld de, .monhelptext1 
1e4c			 
1e4c cd bd 0d			call str_at_display 
1e4f 3e 28			ld a, display_row_2 
1e51 11 06 1e		        ld de, .monhelptext2 
1e54					 
1e54 cd bd 0d			call str_at_display 
1e57 3e 50			ld a, display_row_3 
1e59 11 22 1e		        ld de, .monhelptext3 
1e5c					 
1e5c cd bd 0d			call str_at_display 
1e5f 3e 78			ld a, display_row_4 
1e61 11 40 1e		        ld de, .monhelptext4 
1e64 cd bd 0d			call str_at_display 
1e67			 
1e67 cd cd 0d			call update_display		 
1e6a			 
1e6a cd c0 1f			call next_page_prompt 
1e6d c3 7a 1d			jp monitor 
1e70			 
1e70			.monjump:    
1e70 21 f6 f2			ld hl,os_input+2 
1e73 cd 9d 12			call get_word_hl 
1e76			 
1e76 e9				jp (hl) 
1e77 c3 7a 1d			jp monitor 
1e7a			 
1e7a			.mondump:    
1e7a 21 f6 f2			ld hl,os_input+2 
1e7d cd 9d 12			call get_word_hl 
1e80			 
1e80 22 19 f4			ld (os_cur_ptr),hl	 
1e83 cd c8 1e			call dumpcont 
1e86 3e 78			ld a, display_row_4 
1e88 11 26 1d			ld de, endprog 
1e8b			 
1e8b cd cd 0d			call update_display		 
1e8e			 
1e8e cd c0 1f			call next_page_prompt 
1e91 c3 7a 1d			jp monitor 
1e94			.moncdump: 
1e94 cd c8 1e			call dumpcont 
1e97 3e 78			ld a, display_row_4 
1e99 11 26 1d			ld de, endprog 
1e9c			 
1e9c cd cd 0d			call update_display		 
1e9f			 
1e9f cd c0 1f			call next_page_prompt 
1ea2 c3 7a 1d			jp monitor 
1ea5			 
1ea5			 
1ea5			; TODO symbol access  
1ea5			 
1ea5			.symbols:     ;; A list of symbols that can be called up  
1ea5 e6 fc			dw display_fb0 
1ea7 .. 00			db "fb0",0  
1eab af f9		     	dw store_page 
1ead .. 00			db "store_page",0 
1eb8			 
1eb8			 
1eb8			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1eb8			 
1eb8 3a f7 f0			ld a,(scratch+1) 
1ebb fe 00			cp 0 
1ebd 28 09			jr z, dumpcont 
1ebf			 
1ebf				; no, not a null term line so has an address to work out.... 
1ebf			 
1ebf 21 f8 f0			ld hl,scratch+2 
1ec2 cd 9d 12			call get_word_hl 
1ec5			 
1ec5 22 19 f4			ld (os_cur_ptr),hl	 
1ec8			 
1ec8			 
1ec8			 
1ec8			dumpcont: 
1ec8			 
1ec8				; dump bytes at ptr 
1ec8			 
1ec8			 
1ec8 3e 00			ld a, display_row_1 
1eca 2a 01 fb			ld hl, (display_fb_active) 
1ecd cd de 0f			call addatohl 
1ed0 cd f8 1e			call .dumpbyterow 
1ed3			 
1ed3 3e 28			ld a, display_row_2 
1ed5 2a 01 fb			ld hl, (display_fb_active) 
1ed8 cd de 0f			call addatohl 
1edb cd f8 1e			call .dumpbyterow 
1ede			 
1ede			 
1ede 3e 50			ld a, display_row_3 
1ee0 2a 01 fb			ld hl, (display_fb_active) 
1ee3 cd de 0f			call addatohl 
1ee6 cd f8 1e			call .dumpbyterow 
1ee9			 
1ee9 3e 78			ld a, display_row_4 
1eeb 2a 01 fb			ld hl, (display_fb_active) 
1eee cd de 0f			call addatohl 
1ef1 cd f8 1e			call .dumpbyterow 
1ef4			 
1ef4 cd cd 0d			call update_display 
1ef7			;		jp cli 
1ef7 c9				ret 
1ef8			 
1ef8			.dumpbyterow: 
1ef8			 
1ef8				;push af 
1ef8			 
1ef8 e5				push hl 
1ef9			 
1ef9				; calc where to poke the ascii 
1ef9			if display_cols == 20 
1ef9				ld a, 16 
1ef9			else 
1ef9 3e 1f			ld a, 31 
1efb			endif 
1efb			 
1efb cd de 0f			call addatohl 
1efe 22 fb f3			ld (os_word_scratch),hl  		; save pos for later 
1f01			 
1f01			 
1f01			; display decoding address 
1f01 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f04			 
1f04 7c				ld a,h 
1f05 e1				pop hl 
1f06 e5				push hl 
1f07			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1f07 cd e7 11			call hexout 
1f0a 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f0d			 
1f0d 7d				ld a,l 
1f0e e1				pop hl 
1f0f 23				inc hl 
1f10 23				inc hl 
1f11 e5				push hl 
1f12			;	ld hl, os_word_scratch+2 
1f12 cd e7 11			call hexout 
1f15 e1				pop hl 
1f16 23				inc hl 
1f17 23				inc hl 
1f18				;ld hl, os_word_scratch+4 
1f18 3e 3a			ld a, ':' 
1f1a 77				ld (hl),a 
1f1b 23				inc hl 
1f1c				;ld a, 0 
1f1c				;ld (hl),a 
1f1c				;ld de, os_word_scratch 
1f1c				;pop af 
1f1c				;push af 
1f1c			;		ld a, display_row_2 
1f1c			;		call str_at_display 
1f1c			;		call update_display 
1f1c			 
1f1c			 
1f1c			;pop af 
1f1c			;	add 5 
1f1c			 
1f1c			if display_cols == 20 
1f1c				ld b, 4 
1f1c			else 
1f1c 06 08			ld b, 8 
1f1e			endif	 
1f1e			 
1f1e			.dumpbyte: 
1f1e c5				push bc 
1f1f e5				push hl 
1f20			 
1f20			 
1f20 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f23 7e					ld a,(hl) 
1f24			 
1f24					; poke the ascii to display 
1f24 2a fb f3				ld hl,(os_word_scratch) 
1f27 77					ld (hl),a 
1f28 23					inc hl 
1f29 22 fb f3				ld (os_word_scratch),hl 
1f2c			 
1f2c					 
1f2c			 
1f2c			 
1f2c e1					pop hl 
1f2d e5					push hl 
1f2e			 
1f2e cd e7 11				call hexout 
1f31			 
1f31					 
1f31 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f34 23				inc hl 
1f35 22 19 f4		   	ld (os_cur_ptr),hl 
1f38			 
1f38 e1					pop hl 
1f39 23					inc hl 
1f3a 23					inc hl 
1f3b 23					inc hl 
1f3c			 
1f3c			 
1f3c			 
1f3c					;ld a,0 
1f3c					;ld (os_word_scratch+2),a 
1f3c					;pop af 
1f3c					;push af 
1f3c			 
1f3c					;ld de, os_word_scratch 
1f3c					;call str_at_display 
1f3c			;		call update_display 
1f3c			;		pop af 
1f3c c1					pop bc 
1f3d c6 03				add 3 
1f3f 10 dd			djnz .dumpbyte 
1f41			 
1f41				 
1f41			 
1f41 c9				ret 
1f42			 
1f42			jump:	 
1f42			 
1f42 21 f8 f0			ld hl,scratch+2 
1f45 cd 9d 12			call get_word_hl 
1f48				;ld hl,(scratch+2) 
1f48				;call fourehexhl 
1f48			 
1f48 22 19 f4			ld (os_cur_ptr),hl	 
1f4b			 
1f4b e9				jp (hl) 
1f4c			 
1f4c			 
1f4c			 
1f4c			; TODO implement a basic monitor mode to start with 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			; testing and demo code during development 
1f4c			 
1f4c			 
1f4c .. 00		str1: db "Enter some text...",0 
1f5f .. 00		clear: db "                    ",0 
1f74			 
1f74			demo: 
1f74			 
1f74			 
1f74			 
1f74			;	call update_display 
1f74			 
1f74				; init scratch input area for testing 
1f74 21 f6 f0			ld hl, scratch	 
1f77 3e 00			ld a,0 
1f79 77				ld (hl),a 
1f7a			 
1f7a			 
1f7a 3e 28		            LD   A, display_row_2 
1f7c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f7c 11 4c 1f		            LD   DE, str1 
1f7f cd bd 0d			call str_at_display 
1f82			 
1f82			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f82			cloop:	 
1f82 3e 50		            LD   A, display_row_3 
1f84			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f84 11 5f 1f		            LD   DE, clear 
1f87			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1f87 cd bd 0d				call str_at_display 
1f8a 3e 78			ld a, display_row_4 
1f8c 11 bc 1f			ld de, prompt 
1f8f			 
1f8f cd bd 0d				call str_at_display 
1f92 cd cd 0d			call update_display 
1f95			 
1f95 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1f97 16 0a			ld d, 10 
1f99 21 f6 f0			ld hl, scratch	 
1f9c cd 0b 10			call input_str 
1f9f			 
1f9f			;	call clear_display 
1f9f			;'	call update_display 
1f9f			 
1f9f 3e 00		            LD   A, display_row_1 
1fa1			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fa1 11 5f 1f		            LD   DE, clear 
1fa4 cd bd 0d				call str_at_display 
1fa7			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fa7 3e 00		            LD   A, display_row_1 
1fa9			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fa9 11 f6 f0		            LD   DE, scratch 
1fac			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fac cd bd 0d				call str_at_display 
1faf cd cd 0d			call update_display 
1fb2			 
1fb2 3e 00				ld a,0 
1fb4 21 f6 f0			ld hl, scratch 
1fb7 77				ld (hl),a 
1fb8			 
1fb8 00				nop 
1fb9 c3 82 1f			jp cloop 
1fbc			 
1fbc			 
1fbc			 
1fbc			; OS Prompt 
1fbc			 
1fbc .. 00		prompt: db ">",0 
1fbe .. 00		endprg: db "?",0 
1fc0			 
1fc0			 
1fc0			; handy next page prompt 
1fc0			next_page_prompt: 
1fc0 e5				push hl 
1fc1 d5				push de 
1fc2 f5				push af 
1fc3 c5				push bc 
1fc4			 
1fc4 3e 9f			ld a,display_row_4 + display_cols - 1 
1fc6 11 be 1f		        ld de, endprg 
1fc9 cd bd 0d			call str_at_display 
1fcc cd cd 0d			call update_display 
1fcf cd eb 75			call cin_wait 
1fd2 c1				pop bc 
1fd3 f1				pop af 
1fd4 d1				pop de 
1fd5 e1				pop hl 
1fd6			 
1fd6			 
1fd6 c9				ret 
1fd7			 
1fd7			 
1fd7			; forth parser 
1fd7			 
1fd7			; My forth kernel 
1fd7			include "forth_kernel.asm" 
1fd7			; 
1fd7			; kernel to the forth OS 
1fd7			 
1fd7			DS_TYPE_STR: equ 1     ; string type 
1fd7			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1fd7			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1fd7			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1fd7			 
1fd7			FORTH_PARSEV1: equ 0 
1fd7			FORTH_PARSEV2: equ 0 
1fd7			FORTH_PARSEV3: equ 0 
1fd7			FORTH_PARSEV4: equ 0 
1fd7			FORTH_PARSEV5: equ 0 
1fd7			FORTH_PARSEV6: equ 1 
1fd7			 
1fd7			;if FORTH_PARSEV5 
1fd7			;	FORTH_END_BUFFER: equ 0 
1fd7			;else 
1fd7			FORTH_END_BUFFER: equ 127 
1fd7			;endif 
1fd7			 
1fd7			FORTH_TRUE: equ 1 
1fd7			FORTH_FALSE: equ 0 
1fd7			 
1fd7			if FORTH_PARSEV4 
1fd7			include "forth_stackops.asm" 
1fd7			endif 
1fd7			 
1fd7			if FORTH_PARSEV5 
1fd7			include "forth_stackopsv5.asm" 
1fd7			endif 
1fd7			 
1fd7			if FORTH_PARSEV6 
1fd7			include "forth_stackopsv5.asm" 
1fd7			 
1fd7			; Stack operations for v5 parser on wards 
1fd7			; * DATA stack 
1fd7			; * LOOP stack 
1fd7			; * RETURN stack 
1fd7			 
1fd7			 
1fd7			 
1fd7			FORTH_CHK_DSP_UNDER: macro 
1fd7				push hl 
1fd7				push de 
1fd7				ld hl,(cli_data_sp) 
1fd7				ld de, cli_data_stack 
1fd7				call cmp16 
1fd7				jp c, fault_dsp_under 
1fd7				pop de 
1fd7				pop hl 
1fd7				endm 
1fd7			 
1fd7			 
1fd7			FORTH_CHK_RSP_UNDER: macro 
1fd7				push hl 
1fd7				push de 
1fd7				ld hl,(cli_ret_sp) 
1fd7				ld de, cli_ret_stack 
1fd7				call cmp16 
1fd7				jp c, fault_rsp_under 
1fd7				pop de 
1fd7				pop hl 
1fd7				endm 
1fd7			 
1fd7			FORTH_CHK_LOOP_UNDER: macro 
1fd7				push hl 
1fd7				push de 
1fd7				ld hl,(cli_loop_sp) 
1fd7				ld de, cli_loop_stack 
1fd7				call cmp16 
1fd7				jp c, fault_loop_under 
1fd7				pop de 
1fd7				pop hl 
1fd7				endm 
1fd7			 
1fd7			FORTH_ERR_TOS_NOTSTR: macro 
1fd7				; TOSO might need more for checks when used 
1fd7				push af 
1fd7				ld a,(hl) 
1fd7				cp DS_TYPE_STR 
1fd7				jp nz, type_faultn   
1fd7				pop af 
1fd7				endm 
1fd7			 
1fd7			FORTH_ERR_TOS_NOTNUM: macro 
1fd7				push af 
1fd7				ld a,(hl) 
1fd7				cp DS_TYPE_INUM 
1fd7				jp nz, type_faultn   
1fd7				pop af 
1fd7				endm 
1fd7			 
1fd7			 
1fd7			; increase data stack pointer and save hl to it 
1fd7				 
1fd7			FORTH_DSP_NEXT: macro 
1fd7				call macro_forth_dsp_next 
1fd7				endm 
1fd7			 
1fd7			 
1fd7			macro_forth_dsp_next: 
1fd7				if DEBUG_FORTH_STACK_GUARD 
1fd7 cd 8f 6e				call check_stacks 
1fda				endif 
1fda e5				push hl 
1fdb d5				push de 
1fdc eb				ex de,hl 
1fdd 2a 23 f9			ld hl,(cli_data_sp) 
1fe0 23				inc hl 
1fe1 23				inc hl 
1fe2			 
1fe2			; PARSEV5 
1fe2 23				inc hl 
1fe3 22 23 f9			ld (cli_data_sp),hl 
1fe6 73				ld (hl), e 
1fe7 23				inc hl 
1fe8 72				ld (hl), d 
1fe9 d1				pop de 
1fea e1				pop hl 
1feb				if DEBUG_FORTH_STACK_GUARD 
1feb cd 8f 6e				call check_stacks 
1fee				endif 
1fee c9				ret 
1fef			 
1fef			 
1fef			; increase ret stack pointer and save hl to it 
1fef				 
1fef			FORTH_RSP_NEXT: macro 
1fef				call macro_forth_rsp_next 
1fef				endm 
1fef			 
1fef			macro_forth_rsp_next: 
1fef				if DEBUG_FORTH_STACK_GUARD 
1fef cd 8f 6e				call check_stacks 
1ff2				endif 
1ff2 e5				push hl 
1ff3 d5				push de 
1ff4 eb				ex de,hl 
1ff5 2a 27 f9			ld hl,(cli_ret_sp) 
1ff8 23				inc hl 
1ff9 23				inc hl 
1ffa 22 27 f9			ld (cli_ret_sp),hl 
1ffd 73				ld (hl), e 
1ffe 23				inc hl 
1fff 72				ld (hl), d 
2000 d1				pop de 
2001 e1				pop hl 
2002				if DEBUG_FORTH_STACK_GUARD 
2002 cd 8f 6e				call check_stacks 
2005				endif 
2005 c9				ret 
2006			 
2006			; get current ret stack pointer and save to hl  
2006				 
2006			FORTH_RSP_TOS: macro 
2006				call macro_forth_rsp_tos 
2006				endm 
2006			 
2006			macro_forth_rsp_tos: 
2006				;push de 
2006 2a 27 f9			ld hl,(cli_ret_sp) 
2009 cd 41 20			call loadhlptrtohl 
200c				;ld e, (hl) 
200c				;inc hl 
200c				;ld d, (hl) 
200c				;ex de, hl 
200c					if DEBUG_FORTH_WORDS 
200c			;			DMARK "RST" 
200c						CALLMONITOR 
200c cd aa fd			call debug_vector  
200f				endm  
# End of macro CALLMONITOR
200f					endif 
200f				;pop de 
200f c9				ret 
2010			 
2010			; pop ret stack pointer 
2010				 
2010			FORTH_RSP_POP: macro 
2010				call macro_forth_rsp_pop 
2010				endm 
2010			 
2010			 
2010			macro_forth_rsp_pop: 
2010				if DEBUG_FORTH_STACK_GUARD 
2010			;		DMARK "RPP" 
2010 cd 8f 6e				call check_stacks 
2013					FORTH_CHK_RSP_UNDER 
2013 e5				push hl 
2014 d5				push de 
2015 2a 27 f9			ld hl,(cli_ret_sp) 
2018 11 e1 f8			ld de, cli_ret_stack 
201b cd fc 0f			call cmp16 
201e da a6 6f			jp c, fault_rsp_under 
2021 d1				pop de 
2022 e1				pop hl 
2023				endm 
# End of macro FORTH_CHK_RSP_UNDER
2023				endif 
2023 e5				push hl 
2024 2a 27 f9			ld hl,(cli_ret_sp) 
2027			 
2027			 
2027				if FORTH_ENABLE_FREE 
2027			 
2027					; get pointer 
2027			 
2027					push de 
2027					push hl 
2027			 
2027					ld e, (hl) 
2027					inc hl 
2027					ld d, (hl) 
2027			 
2027					ex de, hl 
2027					call free 
2027			 
2027					pop hl 
2027					pop de 
2027			 
2027			 
2027				endif 
2027			 
2027			 
2027 2b				dec hl 
2028 2b				dec hl 
2029 22 27 f9			ld (cli_ret_sp), hl 
202c				; do stack underflow checks 
202c e1				pop hl 
202d				if DEBUG_FORTH_STACK_GUARD 
202d cd 8f 6e				call check_stacks 
2030					FORTH_CHK_RSP_UNDER 
2030 e5				push hl 
2031 d5				push de 
2032 2a 27 f9			ld hl,(cli_ret_sp) 
2035 11 e1 f8			ld de, cli_ret_stack 
2038 cd fc 0f			call cmp16 
203b da a6 6f			jp c, fault_rsp_under 
203e d1				pop de 
203f e1				pop hl 
2040				endm 
# End of macro FORTH_CHK_RSP_UNDER
2040				endif 
2040 c9				ret 
2041			 
2041			 
2041			 
2041			; routine to load word pointed to by hl into hl 
2041			 
2041			loadhlptrtohl: 
2041			 
2041 d5				push de 
2042 5e				ld e, (hl) 
2043 23				inc hl 
2044 56				ld d, (hl) 
2045 eb				ex de, hl 
2046 d1				pop de 
2047			 
2047 c9				ret 
2048			 
2048			 
2048			 
2048			 
2048			 
2048			; push a number held in HL onto the data stack 
2048			; entry point for pushing a value when already in hl used in function above 
2048			 
2048			forth_push_numhl: 
2048			 
2048 e5				push hl    ; save value to push 
2049			 
2049			if DEBUG_FORTH_PUSH 
2049				; see if disabled 
2049			 
2049			 
2049 f5				push af 
204a 3a aa fd			ld a,(debug_vector) 
204d fe c9			cp $c9   ; ret 
204f			;	ld a, (os_view_disable) 
204f			;	cp '*' 
204f 28 34			jr z, .pskip2 
2051 e5				push hl 
2052 e5			push hl 
2053 cd aa 0d			call clear_display 
2056 e1			pop hl 
2057 7c				ld a,h 
2058 21 fb f3			ld hl, os_word_scratch 
205b cd e7 11			call hexout 
205e e1				pop hl 
205f 7d				ld a,l 
2060 21 fd f3			ld hl, os_word_scratch+2 
2063 cd e7 11			call hexout 
2066			 
2066 21 ff f3			ld hl, os_word_scratch+4 
2069 3e 00			ld a,0 
206b 77				ld (hl),a 
206c 11 fb f3			ld de,os_word_scratch 
206f 3e 28				ld a, display_row_2 
2071 cd bd 0d				call str_at_display 
2074 11 88 60			ld de, .push_num 
2077 3e 00			ld a, display_row_1 
2079			 
2079 cd bd 0d				call str_at_display 
207c			 
207c			 
207c cd cd 0d			call update_display 
207f cd ed 0c			call delay1s 
2082 cd ed 0c			call delay1s 
2085			.pskip2:  
2085			 
2085 f1				pop af 
2086			endif	 
2086			 
2086			 
2086				FORTH_DSP_NEXT 
2086 cd d7 1f			call macro_forth_dsp_next 
2089				endm 
# End of macro FORTH_DSP_NEXT
2089			 
2089 2a 23 f9			ld hl, (cli_data_sp) 
208c			 
208c				; save item type 
208c 3e 02			ld a,  DS_TYPE_INUM 
208e 77				ld (hl), a 
208f 23				inc hl 
2090			 
2090				; get word off stack 
2090 d1				pop de 
2091 7b				ld a,e 
2092 77				ld (hl), a 
2093 23				inc hl 
2094 7a				ld a,d 
2095 77				ld (hl), a 
2096			 
2096			if DEBUG_FORTH_PUSH 
2096 2b				dec hl 
2097 2b				dec hl 
2098 2b				dec hl 
2099						DMARK "PH5" 
2099 f5				push af  
209a 3a ae 20			ld a, (.dmark)  
209d 32 a0 fd			ld (debug_mark),a  
20a0 3a af 20			ld a, (.dmark+1)  
20a3 32 a1 fd			ld (debug_mark+1),a  
20a6 3a b0 20			ld a, (.dmark+2)  
20a9 32 a2 fd			ld (debug_mark+2),a  
20ac 18 03			jr .pastdmark  
20ae ..			.dmark: db "PH5"  
20b1 f1			.pastdmark: pop af  
20b2			endm  
# End of macro DMARK
20b2				CALLMONITOR 
20b2 cd aa fd			call debug_vector  
20b5				endm  
# End of macro CALLMONITOR
20b5			endif	 
20b5			 
20b5 c9				ret 
20b6			 
20b6			 
20b6			; Push a string to stack pointed to by hl 
20b6			 
20b6			forth_push_str: 
20b6			 
20b6			if DEBUG_FORTH_PUSH 
20b6						DMARK "PSQ" 
20b6 f5				push af  
20b7 3a cb 20			ld a, (.dmark)  
20ba 32 a0 fd			ld (debug_mark),a  
20bd 3a cc 20			ld a, (.dmark+1)  
20c0 32 a1 fd			ld (debug_mark+1),a  
20c3 3a cd 20			ld a, (.dmark+2)  
20c6 32 a2 fd			ld (debug_mark+2),a  
20c9 18 03			jr .pastdmark  
20cb ..			.dmark: db "PSQ"  
20ce f1			.pastdmark: pop af  
20cf			endm  
# End of macro DMARK
20cf				CALLMONITOR 
20cf cd aa fd			call debug_vector  
20d2				endm  
# End of macro CALLMONITOR
20d2			endif	 
20d2			 
20d2			 
20d2			    
20d2 e5				push hl 
20d3 e5				push hl 
20d4			 
20d4			;	ld a, 0   ; find end of string 
20d4 cd 44 13			call strlenz 
20d7			if DEBUG_FORTH_PUSH 
20d7						DMARK "PQ2" 
20d7 f5				push af  
20d8 3a ec 20			ld a, (.dmark)  
20db 32 a0 fd			ld (debug_mark),a  
20de 3a ed 20			ld a, (.dmark+1)  
20e1 32 a1 fd			ld (debug_mark+1),a  
20e4 3a ee 20			ld a, (.dmark+2)  
20e7 32 a2 fd			ld (debug_mark+2),a  
20ea 18 03			jr .pastdmark  
20ec ..			.dmark: db "PQ2"  
20ef f1			.pastdmark: pop af  
20f0			endm  
# End of macro DMARK
20f0				CALLMONITOR 
20f0 cd aa fd			call debug_vector  
20f3				endm  
# End of macro CALLMONITOR
20f3			endif	 
20f3 eb				ex de, hl 
20f4 e1				pop hl   ; get ptr to start of string 
20f5			if DEBUG_FORTH_PUSH 
20f5						DMARK "PQ3" 
20f5 f5				push af  
20f6 3a 0a 21			ld a, (.dmark)  
20f9 32 a0 fd			ld (debug_mark),a  
20fc 3a 0b 21			ld a, (.dmark+1)  
20ff 32 a1 fd			ld (debug_mark+1),a  
2102 3a 0c 21			ld a, (.dmark+2)  
2105 32 a2 fd			ld (debug_mark+2),a  
2108 18 03			jr .pastdmark  
210a ..			.dmark: db "PQ3"  
210d f1			.pastdmark: pop af  
210e			endm  
# End of macro DMARK
210e				CALLMONITOR 
210e cd aa fd			call debug_vector  
2111				endm  
# End of macro CALLMONITOR
2111			endif	 
2111 19				add hl,de 
2112			if DEBUG_FORTH_PUSH 
2112						DMARK "PQE" 
2112 f5				push af  
2113 3a 27 21			ld a, (.dmark)  
2116 32 a0 fd			ld (debug_mark),a  
2119 3a 28 21			ld a, (.dmark+1)  
211c 32 a1 fd			ld (debug_mark+1),a  
211f 3a 29 21			ld a, (.dmark+2)  
2122 32 a2 fd			ld (debug_mark+2),a  
2125 18 03			jr .pastdmark  
2127 ..			.dmark: db "PQE"  
212a f1			.pastdmark: pop af  
212b			endm  
# End of macro DMARK
212b				CALLMONITOR 
212b cd aa fd			call debug_vector  
212e				endm  
# End of macro CALLMONITOR
212e			endif	 
212e			 
212e 2b				dec hl    ; see if there is an optional trailing double quote 
212f 7e				ld a,(hl) 
2130 fe 22			cp '"' 
2132 20 03			jr nz, .strnoq 
2134 3e 00			ld a, 0      ; get rid of double quote 
2136 77				ld (hl), a 
2137 23			.strnoq: inc hl 
2138			 
2138 3e 00			ld a, 0 
213a 77				ld (hl), a     ; add null term and get rid of trailing double quote 
213b			 
213b 13				inc de ; add one for the type string 
213c 13				inc de ; add one for null term??? 
213d			 
213d				; tos is get string pointer again 
213d				; de contains space to allocate 
213d				 
213d d5				push de 
213e			 
213e eb				ex de, hl 
213f			 
213f				;push af 
213f			 
213f			if DEBUG_FORTH_PUSH 
213f						DMARK "PHm" 
213f f5				push af  
2140 3a 54 21			ld a, (.dmark)  
2143 32 a0 fd			ld (debug_mark),a  
2146 3a 55 21			ld a, (.dmark+1)  
2149 32 a1 fd			ld (debug_mark+1),a  
214c 3a 56 21			ld a, (.dmark+2)  
214f 32 a2 fd			ld (debug_mark+2),a  
2152 18 03			jr .pastdmark  
2154 ..			.dmark: db "PHm"  
2157 f1			.pastdmark: pop af  
2158			endm  
# End of macro DMARK
2158				CALLMONITOR 
2158 cd aa fd			call debug_vector  
215b				endm  
# End of macro CALLMONITOR
215b			endif	 
215b cd b9 13			call malloc	; on ret hl now contains allocated memory 
215e				if DEBUG_FORTH_MALLOC_GUARD 
215e cc e0 60				call z,malloc_error 
2161				endif 
2161			 
2161				 
2161 c1				pop bc    ; get length 
2162 d1				pop de   ;  get string start    
2163			 
2163				; hl has destination from malloc 
2163			 
2163 eb				ex de, hl    ; prep for ldir 
2164			 
2164 d5				push de   ; save malloc area for DSP later 
2165				;push hl   ; save malloc area for DSP later 
2165			 
2165			if DEBUG_FORTH_PUSH 
2165						DMARK "PHc" 
2165 f5				push af  
2166 3a 7a 21			ld a, (.dmark)  
2169 32 a0 fd			ld (debug_mark),a  
216c 3a 7b 21			ld a, (.dmark+1)  
216f 32 a1 fd			ld (debug_mark+1),a  
2172 3a 7c 21			ld a, (.dmark+2)  
2175 32 a2 fd			ld (debug_mark+2),a  
2178 18 03			jr .pastdmark  
217a ..			.dmark: db "PHc"  
217d f1			.pastdmark: pop af  
217e			endm  
# End of macro DMARK
217e				CALLMONITOR 
217e cd aa fd			call debug_vector  
2181				endm  
# End of macro CALLMONITOR
2181			endif	 
2181			 
2181			 
2181 ed b0			ldir 
2183			 
2183			 
2183				; push malloc to data stack     macro?????  
2183			 
2183				FORTH_DSP_NEXT 
2183 cd d7 1f			call macro_forth_dsp_next 
2186				endm 
# End of macro FORTH_DSP_NEXT
2186			 
2186				; save value and type 
2186			 
2186 2a 23 f9			ld hl, (cli_data_sp) 
2189			 
2189				; save item type 
2189 3e 01			ld a,  DS_TYPE_STR 
218b 77				ld (hl), a 
218c 23				inc hl 
218d			 
218d				; get malloc word off stack 
218d d1				pop de 
218e 73				ld (hl), e 
218f 23				inc hl 
2190 72				ld (hl), d 
2191			 
2191			 
2191			 
2191			if DEBUG_FORTH_PUSH 
2191 2a 23 f9			ld hl, (cli_data_sp) 
2194						DMARK "PHS" 
2194 f5				push af  
2195 3a a9 21			ld a, (.dmark)  
2198 32 a0 fd			ld (debug_mark),a  
219b 3a aa 21			ld a, (.dmark+1)  
219e 32 a1 fd			ld (debug_mark+1),a  
21a1 3a ab 21			ld a, (.dmark+2)  
21a4 32 a2 fd			ld (debug_mark+2),a  
21a7 18 03			jr .pastdmark  
21a9 ..			.dmark: db "PHS"  
21ac f1			.pastdmark: pop af  
21ad			endm  
# End of macro DMARK
21ad				CALLMONITOR 
21ad cd aa fd			call debug_vector  
21b0				endm  
# End of macro CALLMONITOR
21b0			;	ex de,hl 
21b0			endif	 
21b0				; in case of spaces, skip the ptr past the copied string 
21b0				;pop af 
21b0				;ld (cli_origptr),hl 
21b0			 
21b0 c9				ret 
21b1			 
21b1			 
21b1			 
21b1			; TODO ascii push input onto stack given hl to start of input 
21b1			 
21b1			; identify type 
21b1			; if starts with a " then a string 
21b1			; otherwise it is a number 
21b1			;  
21b1			; if a string 
21b1			;     scan for ending " to get length of string to malloc for + 1 
21b1			;     malloc 
21b1			;     put pointer to string on stack first byte flags as string 
21b1			; 
21b1			; else a number 
21b1			;    look for number format identifier 
21b1			;    $xx hex 
21b1			;    %xxxxx bin 
21b1			;    xxxxx decimal 
21b1			;    convert number to 16bit word.  
21b1			;    malloc word + 1 with flag to identiy as num 
21b1			;    put pointer to number on stack 
21b1			;   
21b1			;  
21b1			  
21b1			forth_apush: 
21b1				; kernel push 
21b1			 
21b1			if DEBUG_FORTH_PUSH 
21b1						DMARK "PSH" 
21b1 f5				push af  
21b2 3a c6 21			ld a, (.dmark)  
21b5 32 a0 fd			ld (debug_mark),a  
21b8 3a c7 21			ld a, (.dmark+1)  
21bb 32 a1 fd			ld (debug_mark+1),a  
21be 3a c8 21			ld a, (.dmark+2)  
21c1 32 a2 fd			ld (debug_mark+2),a  
21c4 18 03			jr .pastdmark  
21c6 ..			.dmark: db "PSH"  
21c9 f1			.pastdmark: pop af  
21ca			endm  
# End of macro DMARK
21ca				CALLMONITOR 
21ca cd aa fd			call debug_vector  
21cd				endm  
# End of macro CALLMONITOR
21cd			endif	 
21cd				; identify input type 
21cd			 
21cd 7e				ld a,(hl) 
21ce			 
21ce fe 23			cp '#' 
21d0 ca 0a 22			jp z, .fapdec 
21d3			 
21d3			 
21d3 fe 22			cp '"' 
21d5 28 0a			jr z, .fapstr 
21d7 fe 24			cp '$' 
21d9 ca 01 22			jp z, .faphex 
21dc fe 25			cp '%' 
21de ca e9 21			jp z, .fapbin 
21e1			;	cp 'b' 
21e1			;	jp z, .fabin 
21e1				; else decimal 
21e1			 
21e1				; TODO do decimal conversion 
21e1				; decimal is stored as a 16bit word 
21e1			 
21e1				; by default everything is a string if type is not detected 
21e1			.fapstr: ; 
21e1 fe 22			cp '"' 
21e3 20 01			jr nz, .strnoqu 
21e5 23				inc hl 
21e6			.strnoqu: 
21e6 c3 b6 20			jp forth_push_str 
21e9			 
21e9			 
21e9			 
21e9			.fapbin:    ; push a binary string.  
21e9 11 00 00			ld de, 0   ; hold a 16bit value 
21ec			 
21ec 23			.fapbinshift:	inc hl  
21ed 7e				ld a,(hl) 
21ee fe 00			cp 0     ; done scanning  
21f0 28 0b			jr z, .fapbdone  	; got it in HL so push  
21f2			 
21f2				; left shift de 
21f2 eb				ex de, hl	 
21f3 29				add hl, hl 
21f4			 
21f4				; is 1 
21f4 fe 31			cp '1' 
21f6 20 02			jr nz, .binzero 
21f8 cb 4d			bit 1, l 
21fa			.binzero: 
21fa eb				ex de, hl	 ; save current de 
21fb 18 ef			jr .fapbinshift 
21fd			 
21fd			.fapbdone: 
21fd eb				ex de, hl 
21fe c3 48 20			jp forth_push_numhl 
2201			 
2201			 
2201			.faphex:   ; hex is always stored as a 16bit word 
2201				; skip number prefix 
2201 23				inc hl 
2202				; turn ascii into number 
2202 cd 9d 12			call get_word_hl	; ret 16bit word in hl 
2205			 
2205 c3 48 20			jp forth_push_numhl 
2208			 
2208 00				 nop 
2209			 
2209			.fabin:   ; TODO bin conversion 
2209			 
2209			 
2209 c9				ret 
220a			.fapdec:	 
220a				; string to dec conversion 
220a 23				inc hl 
220b eb				ex de, hl 
220c cd db 12			call string_to_uint16 
220f c3 48 20			jp forth_push_numhl 
2212 c9				ret 
2213				 
2213			;atoui_16: 
2213			 
2213			; get either a string ptr or a 16bit word from the data stack 
2213			 
2213			FORTH_DSP: macro 
2213				call macro_forth_dsp 
2213				endm 
2213			 
2213			macro_forth_dsp: 
2213				; data stack pointer points to current word on tos 
2213			 
2213 2a 23 f9			ld hl,(cli_data_sp) 
2216			 
2216				if DEBUG_FORTH_PUSH 
2216						DMARK "DSP" 
2216 f5				push af  
2217 3a 2b 22			ld a, (.dmark)  
221a 32 a0 fd			ld (debug_mark),a  
221d 3a 2c 22			ld a, (.dmark+1)  
2220 32 a1 fd			ld (debug_mark+1),a  
2223 3a 2d 22			ld a, (.dmark+2)  
2226 32 a2 fd			ld (debug_mark+2),a  
2229 18 03			jr .pastdmark  
222b ..			.dmark: db "DSP"  
222e f1			.pastdmark: pop af  
222f			endm  
# End of macro DMARK
222f			 
222f cd 13 61				call display_data_sp 
2232				;call break_point_state 
2232				;rst 030h 
2232				CALLMONITOR 
2232 cd aa fd			call debug_vector  
2235				endm  
# End of macro CALLMONITOR
2235				endif 
2235			 
2235 c9				ret 
2236			 
2236			; return hl to start of value on stack 
2236			 
2236			FORTH_DSP_VALUE: macro 
2236				call macro_forth_dsp_value 
2236				endm 
2236			 
2236			macro_forth_dsp_value: 
2236			 
2236				FORTH_DSP 
2236 cd 13 22			call macro_forth_dsp 
2239				endm 
# End of macro FORTH_DSP
2239			 
2239 d5				push de 
223a			 
223a 23				inc hl ; skip type 
223b			 
223b 5e				ld e, (hl) 
223c 23				inc hl 
223d 56				ld d, (hl) 
223e eb				ex de,hl  
223f			 
223f d1				pop de 
2240			 
2240 c9				ret 
2241			 
2241			; return hl to start of value to second item on stack 
2241			 
2241			FORTH_DSP_VALUEM1: macro 
2241				call macro_forth_dsp_value_m1 
2241				endm 
2241			 
2241			macro_forth_dsp_value_m1: 
2241			 
2241				FORTH_DSP 
2241 cd 13 22			call macro_forth_dsp 
2244				endm 
# End of macro FORTH_DSP
2244			 
2244 2b				dec hl 
2245 2b				dec hl 
2246			;	dec hl 
2246			 
2246 d5				push de 
2247			 
2247 5e				ld e, (hl) 
2248 23				inc hl 
2249 56				ld d, (hl) 
224a eb				ex de,hl  
224b			 
224b d1				pop de 
224c			 
224c c9				ret 
224d			 
224d				 
224d			 
224d			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
224d			 
224d			FORTH_DSP_POP: macro 
224d				call macro_forth_dsp_pop 
224d				endm 
224d			 
224d			 
224d			; get the tos data type 
224d			 
224d			FORTH_DSP_TYPE:   macro 
224d			 
224d				;FORTH_DSP_VALUE 
224d				FORTH_DSP 
224d				 
224d				; hl points to value 
224d				; check type 
224d			 
224d				ld a,(hl) 
224d			 
224d				endm 
224d			 
224d			; load the tos value into hl 
224d			 
224d			 
224d			FORTH_DSP_VALUEHL:  macro 
224d				call macro_dsp_valuehl 
224d				endm 
224d			 
224d			 
224d			 
224d			macro_dsp_valuehl: 
224d				FORTH_DSP_VALUE 
224d cd 36 22			call macro_forth_dsp_value 
2250				endm 
# End of macro FORTH_DSP_VALUE
2250			 
2250				;FORTH_ERR_TOS_NOTNUM 
2250			 
2250				;inc hl   ; skip type id 
2250			 
2250			;	push de 
2250			; 
2250			;	ld e, (hl) 
2250			;	inc hl 
2250			;	ld d, (hl) 
2250			;	ex de,hl  
2250			 
2250			;	pop de 
2250			 
2250				if DEBUG_FORTH_PUSH 
2250						DMARK "DVL" 
2250 f5				push af  
2251 3a 65 22			ld a, (.dmark)  
2254 32 a0 fd			ld (debug_mark),a  
2257 3a 66 22			ld a, (.dmark+1)  
225a 32 a1 fd			ld (debug_mark+1),a  
225d 3a 67 22			ld a, (.dmark+2)  
2260 32 a2 fd			ld (debug_mark+2),a  
2263 18 03			jr .pastdmark  
2265 ..			.dmark: db "DVL"  
2268 f1			.pastdmark: pop af  
2269			endm  
# End of macro DMARK
2269				CALLMONITOR 
2269 cd aa fd			call debug_vector  
226c				endm  
# End of macro CALLMONITOR
226c				endif 
226c c9				ret 
226d			 
226d			forth_apushstrhl:      
226d				; push of string requires use of cli_origptr 
226d				; bodge use 
226d			 
226d				; get current cli_origptr, save, update with temp pointer  
226d ed 5b 73 f9		ld de, (cli_origptr) 
2271 22 73 f9			ld (cli_origptr), hl 
2274 d5				push de 
2275 cd b1 21			call forth_apush 
2278 d1				pop de 
2279 ed 53 73 f9		ld (cli_origptr), de 
227d c9			        ret	 
227e			 
227e			 
227e			; increase loop stack pointer and save hl to it 
227e				 
227e			FORTH_LOOP_NEXT: macro 
227e				call macro_forth_loop_next 
227e				;nop 
227e				endm 
227e			 
227e			macro_forth_loop_next: 
227e				if DEBUG_FORTH_STACK_GUARD 
227e cd 8f 6e				call check_stacks 
2281				endif 
2281 e5				push hl 
2282 d5				push de 
2283 eb				ex de,hl 
2284 2a 25 f9			ld hl,(cli_loop_sp) 
2287 23				inc hl 
2288 23				inc hl 
2289					if DEBUG_FORTH_WORDS 
2289						DMARK "LNX" 
2289 f5				push af  
228a 3a 9e 22			ld a, (.dmark)  
228d 32 a0 fd			ld (debug_mark),a  
2290 3a 9f 22			ld a, (.dmark+1)  
2293 32 a1 fd			ld (debug_mark+1),a  
2296 3a a0 22			ld a, (.dmark+2)  
2299 32 a2 fd			ld (debug_mark+2),a  
229c 18 03			jr .pastdmark  
229e ..			.dmark: db "LNX"  
22a1 f1			.pastdmark: pop af  
22a2			endm  
# End of macro DMARK
22a2						CALLMONITOR 
22a2 cd aa fd			call debug_vector  
22a5				endm  
# End of macro CALLMONITOR
22a5					endif 
22a5 22 25 f9			ld (cli_loop_sp),hl 
22a8 73				ld (hl), e 
22a9 23				inc hl 
22aa 72				ld (hl), d 
22ab d1				pop de    ; been reversed so save a swap on restore 
22ac e1				pop hl 
22ad				if DEBUG_FORTH_STACK_GUARD 
22ad cd 8f 6e				call check_stacks 
22b0				endif 
22b0 c9				ret 
22b1			 
22b1			; get current ret stack pointer and save to hl  
22b1				 
22b1			FORTH_LOOP_TOS: macro 
22b1				call macro_forth_loop_tos 
22b1				endm 
22b1			 
22b1			macro_forth_loop_tos: 
22b1 d5				push de 
22b2 2a 25 f9			ld hl,(cli_loop_sp) 
22b5 5e				ld e, (hl) 
22b6 23				inc hl 
22b7 56				ld d, (hl) 
22b8 eb				ex de, hl 
22b9 d1				pop de 
22ba c9				ret 
22bb			 
22bb			; pop loop stack pointer 
22bb				 
22bb			FORTH_LOOP_POP: macro 
22bb				call macro_forth_loop_pop 
22bb				endm 
22bb			 
22bb			 
22bb			macro_forth_loop_pop: 
22bb				if DEBUG_FORTH_STACK_GUARD 
22bb					DMARK "LPP" 
22bb f5				push af  
22bc 3a d0 22			ld a, (.dmark)  
22bf 32 a0 fd			ld (debug_mark),a  
22c2 3a d1 22			ld a, (.dmark+1)  
22c5 32 a1 fd			ld (debug_mark+1),a  
22c8 3a d2 22			ld a, (.dmark+2)  
22cb 32 a2 fd			ld (debug_mark+2),a  
22ce 18 03			jr .pastdmark  
22d0 ..			.dmark: db "LPP"  
22d3 f1			.pastdmark: pop af  
22d4			endm  
# End of macro DMARK
22d4 cd 8f 6e				call check_stacks 
22d7					FORTH_CHK_LOOP_UNDER 
22d7 e5				push hl 
22d8 d5				push de 
22d9 2a 25 f9			ld hl,(cli_loop_sp) 
22dc 11 5f f8			ld de, cli_loop_stack 
22df cd fc 0f			call cmp16 
22e2 da ac 6f			jp c, fault_loop_under 
22e5 d1				pop de 
22e6 e1				pop hl 
22e7				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22e7				endif 
22e7 e5				push hl 
22e8 2a 25 f9			ld hl,(cli_loop_sp) 
22eb 2b				dec hl 
22ec 2b				dec hl 
22ed 22 25 f9			ld (cli_loop_sp), hl 
22f0				; TODO do stack underflow checks 
22f0 e1				pop hl 
22f1				if DEBUG_FORTH_STACK_GUARD 
22f1 cd 8f 6e				call check_stacks 
22f4					FORTH_CHK_LOOP_UNDER 
22f4 e5				push hl 
22f5 d5				push de 
22f6 2a 25 f9			ld hl,(cli_loop_sp) 
22f9 11 5f f8			ld de, cli_loop_stack 
22fc cd fc 0f			call cmp16 
22ff da ac 6f			jp c, fault_loop_under 
2302 d1				pop de 
2303 e1				pop hl 
2304				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2304				endif 
2304 c9				ret 
2305			 
2305			macro_forth_dsp_pop: 
2305			 
2305 e5				push hl 
2306			 
2306				; release malloc data 
2306			 
2306				if DEBUG_FORTH_STACK_GUARD 
2306 cd 8f 6e				call check_stacks 
2309					FORTH_CHK_DSP_UNDER 
2309 e5				push hl 
230a d5				push de 
230b 2a 23 f9			ld hl,(cli_data_sp) 
230e 11 5d f6			ld de, cli_data_stack 
2311 cd fc 0f			call cmp16 
2314 da a0 6f			jp c, fault_dsp_under 
2317 d1				pop de 
2318 e1				pop hl 
2319				endm 
# End of macro FORTH_CHK_DSP_UNDER
2319				endif 
2319				;ld hl,(cli_data_sp) 
2319			if DEBUG_FORTH_DOT 
2319				DMARK "DPP" 
2319 f5				push af  
231a 3a 2e 23			ld a, (.dmark)  
231d 32 a0 fd			ld (debug_mark),a  
2320 3a 2f 23			ld a, (.dmark+1)  
2323 32 a1 fd			ld (debug_mark+1),a  
2326 3a 30 23			ld a, (.dmark+2)  
2329 32 a2 fd			ld (debug_mark+2),a  
232c 18 03			jr .pastdmark  
232e ..			.dmark: db "DPP"  
2331 f1			.pastdmark: pop af  
2332			endm  
# End of macro DMARK
2332				CALLMONITOR 
2332 cd aa fd			call debug_vector  
2335				endm  
# End of macro CALLMONITOR
2335			endif	 
2335			 
2335			 
2335			if FORTH_ENABLE_DSPPOPFREE 
2335			 
2335				FORTH_DSP 
2335 cd 13 22			call macro_forth_dsp 
2338				endm 
# End of macro FORTH_DSP
2338			 
2338 7e				ld a, (hl) 
2339 fe 01			cp DS_TYPE_STR 
233b 20 23			jr nz, .skippopfree 
233d			 
233d				FORTH_DSP_VALUEHL 
233d cd 4d 22			call macro_dsp_valuehl 
2340				endm 
# End of macro FORTH_DSP_VALUEHL
2340 00				nop 
2341			if DEBUG_FORTH_DOT 
2341				DMARK "DPf" 
2341 f5				push af  
2342 3a 56 23			ld a, (.dmark)  
2345 32 a0 fd			ld (debug_mark),a  
2348 3a 57 23			ld a, (.dmark+1)  
234b 32 a1 fd			ld (debug_mark+1),a  
234e 3a 58 23			ld a, (.dmark+2)  
2351 32 a2 fd			ld (debug_mark+2),a  
2354 18 03			jr .pastdmark  
2356 ..			.dmark: db "DPf"  
2359 f1			.pastdmark: pop af  
235a			endm  
# End of macro DMARK
235a				CALLMONITOR 
235a cd aa fd			call debug_vector  
235d				endm  
# End of macro CALLMONITOR
235d			endif	 
235d cd 83 14			call free 
2360			.skippopfree: 
2360				 
2360			 
2360			endif 
2360			 
2360			if DEBUG_FORTH_DOT_KEY 
2360				DMARK "DP2" 
2360				CALLMONITOR 
2360			endif	 
2360			 
2360				; move pointer down 
2360			 
2360 2a 23 f9			ld hl,(cli_data_sp) 
2363 2b				dec hl 
2364 2b				dec hl 
2365			; PARSEV5 
2365 2b				dec hl 
2366 22 23 f9			ld (cli_data_sp), hl 
2369			 
2369				if DEBUG_FORTH_STACK_GUARD 
2369 cd 8f 6e				call check_stacks 
236c					FORTH_CHK_DSP_UNDER 
236c e5				push hl 
236d d5				push de 
236e 2a 23 f9			ld hl,(cli_data_sp) 
2371 11 5d f6			ld de, cli_data_stack 
2374 cd fc 0f			call cmp16 
2377 da a0 6f			jp c, fault_dsp_under 
237a d1				pop de 
237b e1				pop hl 
237c				endm 
# End of macro FORTH_CHK_DSP_UNDER
237c				endif 
237c			 
237c e1				pop hl 
237d			 
237d c9				ret 
237e			 
237e			getwordathl: 
237e				; hl points to an address 
237e				; load hl with the word at that address 
237e			 
237e d5				push de 
237f			 
237f 5e				ld e, (hl) 
2380 23				inc hl 
2381 56				ld d, (hl) 
2382 eb				ex de, hl 
2383			 
2383 d1				pop de 
2384 c9				ret 
2385			 
2385			 
2385			; functions to manuplite stack pointers 
2385			 
2385			; generate fragment to set hl to be pointer to a stack item 
2385			 
2385			FORTH_DSP_PTR: macro  x 
2385				ld hl,(cli_data_sp) 
2385				ld de, x * 3 
2385				sbc hl, de 
2385				endm 
2385			 
2385			 
2385			 
2385			; copy point in hl to stack tmp storage slots 1-4 
2385			hltostack1: 
2385 11 f3 f0			ld de, os_stack_1  
2388 c3 b3 23			jp hltostackmv 
238b			 
238b			hltostack2:  
238b 11 f0 f0			ld de, os_stack_2 
238e c3 b3 23			jp hltostackmv 
2391			 
2391			hltostack3:  
2391 11 ed f0			ld de, os_stack_3 
2394 c3 b3 23			jp hltostackmv 
2397			 
2397			hltostack4:  
2397 11 ea f0			ld de, os_stack_4  
239a c3 b3 23			jp hltostackmv 
239d			 
239d			; copy to point in hl from stack tmp storage slots 1-4 
239d			hlfromstack1: 
239d 11 f3 f0			ld de, os_stack_1 
23a0 c3 b2 23			jp hlfromsttackmv 
23a3			 
23a3			hlfromstack2:  
23a3 11 f0 f0			ld de, os_stack_2 
23a6 c3 b2 23			jp hlfromsttackmv 
23a9			 
23a9			hlfromstack3:  
23a9 11 ed f0			ld de, os_stack_3 
23ac c3 b2 23			jp hlfromsttackmv 
23af			 
23af			hlfromstack4:  
23af 11 ea f0			ld de, os_stack_4 
23b2			 
23b2			hlfromsttackmv: 
23b2 eb				ex de, hl 
23b3			 
23b3			hltostackmv: 
23b3			 
23b3				; do stack move 
23b3 c5				push bc 
23b4 01 03 00			ld bc, 3 
23b7 ed b0			ldir  
23b9 c1				pop bc	 
23ba c9				ret 
23bb			 
23bb			; eof 
23bb			 
# End of file forth_stackopsv5.asm
23bb			endif 
23bb			loadwordinhl:	 
23bb			 
23bb d5				push de 
23bc			 
23bc 5e				ld e, (hl) 
23bd 23				inc hl 
23be 56				ld d, (hl) 
23bf eb				ex de,hl  
23c0			 
23c0 d1				pop de 
23c1			 
23c1 c9				ret 
23c2			 
23c2			user_word_eol:  
23c2				; hl contains the pointer to where to create a linked list item from the end 
23c2				; of the user dict to continue on at the system word dict 
23c2				 
23c2				; poke the stub of the word list linked list to repoint to rom words 
23c2			 
23c2				; stub format 
23c2				; db   word id 
23c2				; dw    link to next word 
23c2			        ; db char length of token 
23c2				; db string + 0 term 
23c2				; db exec code....  
23c2			 
23c2 3e 00			ld a, WORD_SYS_ROOT     ; root word 
23c4 77				ld (hl), a		; word id 
23c5 23				inc hl 
23c6			 
23c6 11 7d 25			ld de, sysdict 
23c9 73				ld (hl), e		; next word link ie system dict 
23ca 23				inc hl 
23cb 72				ld (hl), d		; next word link ie system dict 
23cc 23				inc hl	 
23cd			 
23cd			;	ld (hl), sysdict		; next word link ie system dict 
23cd			;	inc hl 
23cd			;	inc hl 
23cd			 
23cd			;	inc hl 
23cd			;	inc hl 
23cd			 
23cd 3e 02			ld a, 2			; word length is 0 
23cf 77				ld (hl), a	 
23d0 23				inc hl 
23d1			 
23d1 3e 7e			ld a, '~'			; word length is 0 
23d3 77				ld (hl), a	 
23d4 23				inc hl 
23d5 3e 00			ld a, 0			; save empty word 
23d7 77				ld (hl), a 
23d8			 
23d8 c9				ret 
23d9			 
23d9				 
23d9			 
23d9			forthexec_cleanup: 
23d9				FORTH_RSP_POP 
23d9 cd 10 20			call macro_forth_rsp_pop 
23dc				endm 
# End of macro FORTH_RSP_POP
23dc c9				ret 
23dd			 
23dd			forth_call_hl: 
23dd				; taking hl 
23dd e5				push hl 
23de c9				ret 
23df			 
23df			; this is called to reset Forth system but keep existing uwords etc 
23df			 
23df			forth_warmstart: 
23df				; setup stack over/under flow checks 
23df				if DEBUG_FORTH_STACK_GUARD 
23df cd 75 6e				call chk_stk_init 
23e2				endif 
23e2			 
23e2				; init stack pointers  - * these stacks go upwards *  
23e2 21 e1 f8			ld hl, cli_ret_stack 
23e5 22 27 f9			ld (cli_ret_sp), hl	 
23e8				; set bottom of stack 
23e8 3e 00			ld a,0 
23ea 77				ld (hl),a 
23eb 23				inc hl 
23ec 77				ld (hl),a 
23ed			 
23ed 21 5d f6			ld hl, cli_data_stack 
23f0 22 23 f9			ld (cli_data_sp), hl	 
23f3				; set bottom of stack 
23f3 3e 00			ld a,0 
23f5 77				ld (hl),a 
23f6 23				inc hl 
23f7 77				ld (hl),a 
23f8			 
23f8 21 5f f8			ld hl, cli_loop_stack 
23fb 22 25 f9			ld (cli_loop_sp), hl	 
23fe				; set bottom of stack 
23fe 3e 00			ld a,0 
2400 77				ld (hl),a 
2401 23				inc hl 
2402 77				ld (hl),a 
2403			 
2403				; init extent of current open file 
2403			 
2403 3e 00			ld a, 0 
2405 32 9f f9			ld (store_openext), a 
2408			 
2408 c9				ret 
2409			 
2409			 
2409			 
2409			; Cold Start - this is called to setup the whole Forth system 
2409			 
2409			forth_init: 
2409			 
2409				; setup stack over/under flow checks 
2409			 
2409			;	if DEBUG_FORTH_STACK_GUARD 
2409			;		call chk_stk_init 
2409			;	endif 
2409			 
2409				; enable auto display updates (slow.....) 
2409			 
2409 3e 01			ld a, 1 
240b 32 71 f9			ld (cli_autodisplay), a 
240e			 
240e				; if storage is in use disable long reads for now 
240e 3e 00			ld a, 0 
2410 32 aa f9			ld (store_longread), a 
2413			 
2413			 
2413				; show start up screen 
2413			 
2413 cd aa 0d			call clear_display 
2416			 
2416 3e 00			ld a,0 
2418 32 93 f9			ld (f_cursor_ptr), a 
241b			 
241b				; set start of word list in start of ram - for use when creating user words 
241b			 
241b 21 00 80			ld hl, baseram 
241e 22 f3 f3			ld (os_last_new_uword), hl 
2421 cd c2 23			call user_word_eol 
2424				 
2424			;		call display_data_sp 
2424			;		call next_page_prompt 
2424			 
2424			 
2424			 
2424			 
2424 c9				ret 
2425			 
2425 .. 00		.bootforth: db " Forth Kernel Init ",0 
2439			 
2439			; TODO push to stack 
2439			 
2439			;  
2439			 
2439			if FORTH_PARSEV2 
2439			 
2439			 
2439				include "forth_parserv2.asm" 
2439			 
2439			endif 
2439			 
2439			 
2439			; parse cli version 1 
2439			 
2439			if FORTH_PARSEV1 
2439			 
2439			 
2439			 
2439			      include "forth_parserv1.asm" 
2439			endif 
2439				 
2439			if FORTH_PARSEV3 
2439			      include "forth_parserv3.asm" 
2439				include "forth_wordsv3.asm" 
2439			endif 
2439			 
2439			if FORTH_PARSEV4 
2439			      include "forth_parserv4.asm" 
2439				include "forth_wordsv4.asm" 
2439			endif 
2439			 
2439			if FORTH_PARSEV5 
2439			      include "forth_parserv5.asm" 
2439				include "forth_wordsv4.asm" 
2439			endif 
2439			 
2439			if FORTH_PARSEV6 
2439			      include "forth_parserv6.asm" 
2439			 
2439			 
2439			; A better parser without using malloc and string copies all over the place.  
2439			; Exec in situ should be faster 
2439			 
2439			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2439			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2439			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2439			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2439			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2439			WORD_SYS_END: equ 0   ; Opcode for all user words 
2439			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2439			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2439			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2439			 
2439			; Core word preamble macro 
2439			 
2439			CWHEAD:   macro nxtword opcode lit len opflags 
2439				db WORD_SYS_CORE+opcode             
2439				; internal op code number 
2439				dw nxtword            
2439				; link to next dict word block 
2439				db len + 1 
2439				; literal length of dict word inc zero term 
2439				db lit,0              
2439				; literal dict word 
2439			        ; TODO db opflags        
2439				endm 
2439			 
2439			 
2439			NEXTW: macro  
2439				jp macro_next 
2439				endm 
2439			 
2439			macro_next: 
2439			if DEBUG_FORTH_PARSE_EXEC 
2439				DMARK "NXT" 
2439				CALLMONITOR 
2439			endif	 
2439			;	inc hl  ; skip token null term  
2439 ed 4b 75 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
243d ed 5b 73 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2441 2a f7 f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2444			if DEBUG_FORTH_PARSE_EXEC 
2444				DMARK "}AA" 
2444				CALLMONITOR 
2444			endif	 
2444 c3 33 25			jp execnext 
2447				;jp exec1 
2447			       
2447			 
2447			 
2447			; Another go at the parser to compile  
2447			 
2447			 
2447			; TODO rework parser to change all of the string words to byte tokens 
2447			; TODO do a search for  
2447			 
2447			; TODO first run normal parser to zero term sections 
2447			; TODO for each word do a token look up to get the op code 
2447			; TODO need some means to flag to the exec that this is a byte code form    
2447			 
2447			 
2447			forthcompile: 
2447			 
2447			; 
2447			; line parse: 
2447			;       parse raw input buffer 
2447			;       tokenise the words 
2447			;       malloc new copy (for looping etc) 
2447			;       copy to malloc + current pc in line to start of string and add line term 
2447			;       save on new rsp 
2447			; 
2447			 
2447			; hl to point to the line to tokenise 
2447			 
2447			;	push hl 
2447 22 f7 f3			ld (os_tok_ptr), hl  ; save ptr to string 
244a			 
244a			;	ld a,0		; string term on input 
244a			;	call strlent 
244a			 
244a			;	ld (os_tok_len), hl	 ; save string length 
244a			 
244a			;if DEBUG_FORTH_TOK 
244a			;	ex de,hl		 
244a			;endif 
244a			 
244a			;	pop hl 		; get back string pointer 
244a			 
244a			if DEBUG_FORTH_TOK 
244a						DMARK "TOc" 
244a				CALLMONITOR 
244a			endif 
244a 7e			.cptoken2:    ld a,(hl) 
244b 23				inc hl 
244c fe 7f			cp FORTH_END_BUFFER 
244e 28 29			jr z, .cptokendone2 
2450 fe 00			cp 0 
2452 28 25			jr z, .cptokendone2 
2454 fe 22			cp '"' 
2456 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2458 fe 20			cp ' ' 
245a 20 ee			jr nz,  .cptoken2 
245c			 
245c			; TODO consume comments held between ( and ) 
245c			 
245c				; we have a space so change to zero term for dict match later 
245c 2b				dec hl 
245d 3e 00			ld a,0 
245f 77				ld (hl), a 
2460 23				inc hl 
2461 18 e7			jr .cptoken2 
2463				 
2463			 
2463			.cptokenstr2: 
2463				; skip all white space until either eol (because forgot to term) or end double quote 
2463			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2463				;inc hl ; skip current double quote 
2463 7e				ld a,(hl) 
2464 23				inc hl 
2465 fe 22			cp '"' 
2467 28 e1			jr z, .cptoken2 
2469 fe 7f			cp FORTH_END_BUFFER 
246b 28 0c			jr z, .cptokendone2 
246d fe 00			cp 0 
246f 28 08			jr z, .cptokendone2 
2471 fe 20			cp ' ' 
2473 28 02			jr z, .cptmp2 
2475 18 ec			jr .cptokenstr2 
2477			 
2477			.cptmp2:	; we have a space so change to zero term for dict match later 
2477				;dec hl 
2477				;ld a,"-"	; TODO remove this when working 
2477				;ld (hl), a 
2477				;inc hl 
2477 18 ea			jr .cptokenstr2 
2479			 
2479			.cptokendone2: 
2479				;inc hl 
2479 3e 7f			ld a, FORTH_END_BUFFER 
247b 77				ld (hl),a 
247c			;	inc hl 
247c			;	ld a, '!' 
247c			;	ld (hl),a 
247c			 
247c 2a f7 f3			ld hl,(os_tok_ptr) 
247f			         
247f			if DEBUG_FORTH_TOK 
247f						DMARK "Tc1" 
247f				CALLMONITOR 
247f			endif 
247f			 
247f				; push exec string to top of return stack 
247f				FORTH_RSP_NEXT 
247f cd ef 1f			call macro_forth_rsp_next 
2482				endm 
# End of macro FORTH_RSP_NEXT
2482 c9				ret 
2483			 
2483			; Another go at the parser need to simplify the process 
2483			 
2483			forthparse: 
2483			 
2483			; 
2483			; line parse: 
2483			;       parse raw input buffer 
2483			;       tokenise the words 
2483			;       malloc new copy (for looping etc) 
2483			;       copy to malloc + current pc in line to start of string and add line term 
2483			;       save on new rsp 
2483			; 
2483			 
2483			; hl to point to the line to tokenise 
2483			 
2483			;	push hl 
2483 22 f7 f3			ld (os_tok_ptr), hl  ; save ptr to string 
2486			 
2486			;	ld a,0		; string term on input 
2486			;	call strlent 
2486			 
2486			;	ld (os_tok_len), hl	 ; save string length 
2486			 
2486			;if DEBUG_FORTH_TOK 
2486			;	ex de,hl		 
2486			;endif 
2486			 
2486			;	pop hl 		; get back string pointer 
2486			 
2486			if DEBUG_FORTH_TOK 
2486						DMARK "TOK" 
2486				CALLMONITOR 
2486			endif 
2486 7e			.ptoken2:    ld a,(hl) 
2487 23				inc hl 
2488 fe 7f			cp FORTH_END_BUFFER 
248a 28 29			jr z, .ptokendone2 
248c fe 00			cp 0 
248e 28 25			jr z, .ptokendone2 
2490 fe 22			cp '"' 
2492 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2494 fe 20			cp ' ' 
2496 20 ee			jr nz,  .ptoken2 
2498			 
2498			; TODO consume comments held between ( and ) 
2498			 
2498				; we have a space so change to zero term for dict match later 
2498 2b				dec hl 
2499 3e 00			ld a,0 
249b 77				ld (hl), a 
249c 23				inc hl 
249d 18 e7			jr .ptoken2 
249f				 
249f			 
249f			.ptokenstr2: 
249f				; skip all white space until either eol (because forgot to term) or end double quote 
249f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
249f				;inc hl ; skip current double quote 
249f 7e				ld a,(hl) 
24a0 23				inc hl 
24a1 fe 22			cp '"' 
24a3 28 e1			jr z, .ptoken2 
24a5 fe 7f			cp FORTH_END_BUFFER 
24a7 28 0c			jr z, .ptokendone2 
24a9 fe 00			cp 0 
24ab 28 08			jr z, .ptokendone2 
24ad fe 20			cp ' ' 
24af 28 02			jr z, .ptmp2 
24b1 18 ec			jr .ptokenstr2 
24b3			 
24b3			.ptmp2:	; we have a space so change to zero term for dict match later 
24b3				;dec hl 
24b3				;ld a,"-"	; TODO remove this when working 
24b3				;ld (hl), a 
24b3				;inc hl 
24b3 18 ea			jr .ptokenstr2 
24b5			 
24b5			.ptokendone2: 
24b5				;inc hl 
24b5 3e 7f			ld a, FORTH_END_BUFFER 
24b7 77				ld (hl),a 
24b8			;	inc hl 
24b8			;	ld a, '!' 
24b8			;	ld (hl),a 
24b8			 
24b8 2a f7 f3			ld hl,(os_tok_ptr) 
24bb			         
24bb			if DEBUG_FORTH_TOK 
24bb						DMARK "TK1" 
24bb				CALLMONITOR 
24bb			endif 
24bb			 
24bb				; push exec string to top of return stack 
24bb				FORTH_RSP_NEXT 
24bb cd ef 1f			call macro_forth_rsp_next 
24be				endm 
# End of macro FORTH_RSP_NEXT
24be c9				ret 
24bf			 
24bf			; 
24bf			;	; malloc size + buffer pointer + if is loop flag 
24bf			;	ld hl,(os_tok_len) 		 ; get string length 
24bf			; 
24bf			;	ld a,l 
24bf			; 
24bf			;	cp 0			; we dont want to use a null string 
24bf			;	ret z 
24bf			; 
24bf			;;	add 3    ; prefix malloc with buffer for current word ptr 
24bf			; 
24bf			;	add 5     ; TODO when certain not over writing memory remove 
24bf			; 
24bf			;		 
24bf			; 
24bf			;if DEBUG_FORTH_TOK 
24bf			;			DMARK "TKE" 
24bf			;	CALLMONITOR 
24bf			;endif 
24bf			; 
24bf			;	ld l,a 
24bf			;	ld h,0 
24bf			;;	push hl   ; save required space for the copy later 
24bf			;	call malloc 
24bf			;if DEBUG_FORTH_TOK 
24bf			;			DMARK "TKM" 
24bf			;	CALLMONITOR 
24bf			;endif 
24bf			;	if DEBUG_FORTH_MALLOC_GUARD 
24bf			;		push af 
24bf			;		call ishlzero 
24bf			;;		ld a, l 
24bf			;;		add h 
24bf			;;		cp 0 
24bf			;		pop af 
24bf			;		 
24bf			;		call z,malloc_error 
24bf			;	endif 
24bf			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
24bf			; 
24bf			; 
24bf			;if DEBUG_FORTH_TOK 
24bf			;			DMARK "TKR" 
24bf			;	CALLMONITOR 
24bf			;endif 
24bf			; 
24bf			;	FORTH_RSP_NEXT 
24bf			; 
24bf			;	;inc hl	 ; go past current buffer pointer 
24bf			;	;inc hl 
24bf			;	;inc hl   ; and past if loop flag 
24bf			;		; TODO Need to set flag  
24bf			; 
24bf			;	 
24bf			;	 
24bf			;	ex de,hl	; malloc is dest 
24bf			;	ld hl, (os_tok_len) 
24bf			;;	pop bc 
24bf			;	ld c, l                
24bf			;	ld b,0 
24bf			;	ld hl, (os_tok_ptr) 
24bf			; 
24bf			;if DEBUG_FORTH_TOK 
24bf			;			DMARK "TKT" 
24bf			;	CALLMONITOR 
24bf			;endif 
24bf			; 
24bf			;	; do str cpy 
24bf			; 
24bf			;	ldir      ; copy byte in hl to de 
24bf			; 
24bf			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
24bf			; 
24bf			;if DEBUG_FORTH_TOK 
24bf			; 
24bf			;			DMARK "TKY" 
24bf			;	CALLMONITOR 
24bf			;endif 
24bf			;	;ld a,0 
24bf			;	;ld a,FORTH_END_BUFFER 
24bf			;	ex de, hl 
24bf			;	;dec hl			 ; go back over the space delim at the end of word 
24bf			;	;ld (hl),a 
24bf			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
24bf			;	ld a,FORTH_END_BUFFER 
24bf			;	ld (hl),a 
24bf			;	inc hl 
24bf			;	ld a,FORTH_END_BUFFER 
24bf			;	ld (hl),a 
24bf			; 
24bf			;	; init the malloc area data 
24bf			;	; set pc for in current area 
24bf			;	;ld hl, (os_tok_malloc) 
24bf			;	;inc hl 
24bf			;	;inc hl 
24bf			;	;inc hl 
24bf			;	;ex de,hl 
24bf			;	;ld hl, (os_tok_malloc) 
24bf			;	;ld (hl),e 
24bf			;	;inc hl 
24bf			;	;ld (hl),d 
24bf			; 
24bf			; 
24bf			;	ld hl,(os_tok_malloc) 
24bf			;if DEBUG_FORTH_PARSE_KEY 
24bf			;			DMARK "TKU" 
24bf			;	CALLMONITOR 
24bf			;endif 
24bf			; 
24bf			;	ret 
24bf			 
24bf			forthexec: 
24bf			 
24bf			; line exec: 
24bf			; forth parser 
24bf			 
24bf			; 
24bf			;       get current exec line on rsp 
24bf			 
24bf				FORTH_RSP_TOS 
24bf cd 06 20			call macro_forth_rsp_tos 
24c2				endm 
# End of macro FORTH_RSP_TOS
24c2			 
24c2			;       restore current pc - hl points to malloc of data 
24c2			 
24c2				;ld e, (hl) 
24c2				;inc hl 
24c2				;ld d, (hl) 
24c2				;ex de,hl 
24c2			 
24c2			 
24c2			exec1: 
24c2 22 f7 f3			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
24c5			 
24c5				; copy our PC to working vars  
24c5 22 75 f9			ld (cli_ptr), hl                    ; here 
24c8 22 73 f9			ld (cli_origptr), hl                ; here 
24cb			 
24cb 7e				ld a,(hl)                           ; here make hl be the ram ptr 
24cc fe 7f			cp FORTH_END_BUFFER 
24ce c8				ret z 
24cf			 
24cf				; skip any nulls 
24cf			 
24cf fe 00			cp 0 
24d1 20 03			jr nz, .execword 
24d3 23				inc hl 
24d4 18 ec			jr exec1 
24d6			 
24d6			 
24d6			.execword: 
24d6			 
24d6			 
24d6			 
24d6			if DEBUG_FORTH_PARSE_EXEC 
24d6						DMARK "KYQ" 
24d6				CALLMONITOR 
24d6			endif 
24d6			;       while at start of word: 
24d6			; get start of dict (in user area first) 
24d6			 
24d6 21 00 80		ld hl, baseram 
24d9			;ld hl, sysdict 
24d9 22 77 f9		ld (cli_nextword),hl                            ; here do we need to do this? 
24dc			;           match word at pc 
24dc			;           exec word 
24dc			;           or push to dsp 
24dc			;           forward to next token 
24dc			;           if line term pop rsp and exit 
24dc			;        
24dc			 
24dc			if DEBUG_FORTH_PARSE_EXEC 
24dc						DMARK "KYq" 
24dc				CALLMONITOR 
24dc			endif 
24dc			 
24dc			; 
24dc			; word comp 
24dc			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
24dc			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
24dc			;    move to start of word  
24dc			;    compare word to cli_token 
24dc			 
24dc			.execpnword:	; HL at start of a word in the dictionary to check 
24dc			 
24dc 2a 77 f9			ld hl,(cli_nextword)                  ; here remove the need to store???? 
24df			 
24df cd 76 25			call forth_tok_next 
24e2			; tok next end here 
24e2 22 77 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
24e5 eb				ex de, hl 
24e6			 
24e6			 
24e6				; save the pointer of the current token - 1 to check against 
24e6				 
24e6 22 7b f9			ld (cli_token), hl   
24e9				; TODO maybe remove below save if no debug 
24e9				; save token string ptr for any debug later 
24e9 23				inc hl  
24ea 22 7d f9			ld (cli_origtoken), hl 
24ed 2b				dec hl 
24ee				; save pointer to the start of the next dictionay word 
24ee 7e				ld a,(hl)   ; get string length 
24ef 47				ld b,a 
24f0			.execpnwordinc:  
24f0 23				inc hl 
24f1 10 fd			djnz .execpnwordinc 
24f3 22 79 f9			ld (cli_execword), hl      ; save start of this words code 
24f6			 
24f6				; now check the word token against the string being parsed 
24f6			 
24f6 2a 7b f9			ld hl,(cli_token) 
24f9 23				inc hl     ; skip string length (use zero term instead to end) 
24fa				;ld (cli_token), hl 
24fa			 
24fa			.execpnchar:    ; compare char between token and string to parse 
24fa			 
24fa			 
24fa				;ld hl, (cli_token)     ; the dict word  
24fa ed 5b 75 f9		ld de, (cli_ptr)     ; cli to parse 
24fe			 
24fe			 
24fe			.execpncharl:    ; compare char between token and string to parse (loop) 
24fe			 
24fe 1a				ld a,(de) 
24ff cd 3b 13			call toUpper 		; make sure the input string matches case 
2502 be				cp (hl) 
2503			 
2503 c2 1c 25			jp nz, .execpnskipword	 ; no match so move to next word 
2506				 
2506			;    if same 
2506			;       scan for string terms 0 for token and 32 for input 
2506 46				ld b,(hl) 
2507 80				add b			 
2508 23				inc hl 
2509 13				inc de 
250a fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
250c							; TODO need to make sure last word in zero term string is accounted for 
250c 20 f0			jr nz, .execpncharl 		 ; not at end of strings yet 
250e			 
250e			 
250e				; at end of both strings so both are exact match 
250e			 
250e			;       skip ptr for next word 
250e			 
250e 2a 75 f9			ld hl,(cli_ptr) 	; at input string term 
2511 23				inc hl			 ; at next char 
2512 22 75 f9			ld (cli_ptr), hl     ; save for next round of the parser 
2515 22 73 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2518				 
2518				 
2518			 
2518			 
2518			 
2518			;       exec code block 
2518			if DEBUG_FORTH_JP 
2518				call clear_display 
2518				call update_display 
2518				call delay1s 
2518				ld hl, (cli_execword)     ; save for next check if no match on this word 
2518				ld a,h 
2518				ld hl, os_word_scratch 
2518				call hexout 
2518				ld hl, (cli_execword)     ; save for next check if no match on this word 
2518				ld a,l 
2518				ld hl, os_word_scratch+2 
2518				call hexout 
2518				ld hl, os_word_scratch+4 
2518				ld a,0 
2518				ld (hl),a 
2518				ld de,os_word_scratch 
2518				call str_at_display 
2518					ld a, display_row_2 
2518					call str_at_display 
2518				ld de, (cli_origtoken) 
2518				ld a, display_row_1+10 
2518					call str_at_display 
2518			 
2518				ld a,display_row_1 
2518				ld de, .foundword 
2518				ld a, display_row_3 
2518				call str_at_display 
2518				call update_display 
2518				call delay1s 
2518				call delay1s 
2518				call delay1s 
2518			endif 
2518			 
2518			if DEBUG_FORTH_PARSE_EXEC 
2518						DMARK "KYj" 
2518			endif 
2518				; TODO save the word pointer in this exec 
2518			 
2518 2a 79 f9			ld hl,(cli_execword) 
251b e9				jp (hl) 
251c			 
251c			 
251c			;    if not same 
251c			;	scan for zero term 
251c			;	get ptr for next word 
251c			;	goto word comp 
251c			 
251c			.execpnskipword:	; get pointer to next word 
251c 2a 77 f9			ld hl,(cli_nextword) 
251f			 
251f 7e				ld a,(hl) 
2520 fe 00			cp WORD_SYS_END 
2522			;	cp 0 
2522 28 09			jr z, .execendofdict			 ; at end of words 
2524			 
2524			if DEBUG_FORTH_PARSE_EXEC 
2524						DMARK "KY4" 
2524			endif 
2524			if DEBUG_FORTH_PARSE_EXEC 
2524			 
2524				; see if disabled 
2524			 
2524			;	ld a, (os_view_disable) 
2524			;	cp '*' 
2524				ld a,(debug_vector) 
2524				cp $c9   ; RET 
2524				jr z, .noskip 
2524			 
2524			 
2524				ld de, .nowordfound 
2524				ld a, display_row_3 
2524				call str_at_display 
2524				call update_display 
2524				ld a, 100 
2524				call aDelayInMS 
2524				 
2524				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2524					call delay250ms 
2524				endif 
2524			.noskip:  
2524			 
2524			endif	 
2524			 
2524 2a 73 f9			ld hl,(cli_origptr) 
2527 22 75 f9			ld (cli_ptr),hl 
252a			 
252a			if DEBUG_FORTH_PARSE_EXEC 
252a						DMARK "KY5" 
252a			endif 
252a c3 dc 24			jp .execpnword			; else go to next word 
252d			 
252d			.execendofdict:  
252d			 
252d			if DEBUG_FORTH_PARSE_EXEC 
252d						DMARK "KYe" 
252d			endif 
252d			if DEBUG_FORTH_PARSE_EXEC 
252d				; see if disabled 
252d			 
252d			;	ld a, (os_view_disable) 
252d			;	cp '*' 
252d				ld a,(debug_vector) 
252d				cp $c9   ; ret 
252d				jr z, .ispskip 
252d			 
252d				call clear_display 
252d				call update_display 
252d				call delay1s 
252d				ld de, (cli_origptr) 
252d				ld a, display_row_1 
252d				call str_at_display 
252d				 
252d				ld de, .enddict 
252d				ld a, display_row_3 
252d				call str_at_display 
252d				call update_display 
252d				ld a, 100 
252d				call aDelayInMS 
252d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
252d				call delay1s 
252d				call delay1s 
252d				call delay1s 
252d				endif 
252d			.ispskip:  
252d				 
252d			endif	 
252d			 
252d			 
252d			 
252d				; if the word is not a keyword then must be a literal so push it to stack 
252d			 
252d			; push token to stack to end of word 
252d			 
252d				STACKFRAME ON $1efe $2f9f 
252d				if DEBUG_STACK_IMB 
252d					if ON 
252d						exx 
252d						ld de, $1efe 
252d						ld a, d 
252d						ld hl, curframe 
252d						call hexout 
252d						ld a, e 
252d						ld hl, curframe+2 
252d						call hexout 
252d						ld hl, $1efe 
252d						push hl 
252d						ld hl, $2f9f 
252d						push hl 
252d						exx 
252d					endif 
252d				endif 
252d			endm 
# End of macro STACKFRAME
252d			 
252d 2a f7 f3		ld hl,(os_tok_ptr) 
2530 cd b1 21		call forth_apush 
2533			 
2533				STACKFRAMECHK ON $1efe $2f9f 
2533				if DEBUG_STACK_IMB 
2533					if ON 
2533						exx 
2533						ld hl, $2f9f 
2533						pop de   ; $2f9f 
2533						call cmp16 
2533						jr nz, .spnosame 
2533						ld hl, $1efe 
2533						pop de   ; $1efe 
2533						call cmp16 
2533						jr z, .spfrsame 
2533						.spnosame: call showsperror 
2533						.spfrsame: nop 
2533						exx 
2533					endif 
2533				endif 
2533			endm 
# End of macro STACKFRAMECHK
2533			 
2533			execnext: 
2533			 
2533			if DEBUG_FORTH_PARSE_EXEC 
2533						DMARK "KY>" 
2533			endif 
2533			; move past token to next word 
2533			 
2533 2a f7 f3		ld hl, (os_tok_ptr) 
2536 3e 00		ld a, 0 
2538 01 ff 00		ld bc, 255     ; input buffer size 
253b ed b1		cpir 
253d			 
253d			if DEBUG_FORTH_PARSE_EXEC 
253d						DMARK "KY!" 
253d				CALLMONITOR 
253d			endif	 
253d			; TODO this might place hl on the null, so will need to forward on??? 
253d			;inc hl   ; see if this gets onto the next item 
253d			 
253d			 
253d			; TODO pass a pointer to the buffer to push 
253d			; TODO call function to push 
253d			 
253d			; look for end of input 
253d			 
253d			;inc hl 
253d			;ld a,(hl) 
253d			;cp FORTH_END_BUFFER 
253d			;ret z 
253d			 
253d			 
253d c3 c2 24		jp exec1 
2540			 
2540			 
2540			 
2540			 
2540			 
2540			 
2540			 
2540			 
2540			 
2540			findnexttok: 
2540			 
2540				; hl is pointer to move 
2540				; de is the token to locate 
2540			 
2540					if DEBUG_FORTH 
2540						DMARK "NTK" 
2540						CALLMONITOR 
2540					endif 
2540 d5				push de 
2541			 
2541			.fnt1:	 
2541				; find first char of token to locate 
2541			 
2541 1a				ld a, (de) 
2542 4f				ld c,a 
2543 7e				ld a,(hl) 
2544 cd 3b 13			call toUpper 
2547					if DEBUG_FORTH 
2547						DMARK "NT1" 
2547						CALLMONITOR 
2547					endif 
2547 b9				cp c 
2548			 
2548 28 03			jr z, .fnt2cmpmorefirst	 
254a			 
254a				; first char not found move to next char 
254a			 
254a 23				inc hl 
254b 18 f4			jr .fnt1 
254d			 
254d			.fnt2cmpmorefirst:	 
254d				; first char of token found.  
254d			 
254d e5				push hl     ; save start of token just in case it is the right one 
254e d9				exx 
254f e1				pop hl        ; save it to hl' 
2550 d9				exx 
2551			 
2551			 
2551			.fnt2cmpmore:	 
2551				; compare the rest 
2551				 
2551 23				inc hl 
2552 13				inc de 
2553				 
2553 1a				ld a, (de) 
2554 4f				ld c,a 
2555 7e				ld a,(hl) 
2556 cd 3b 13			call toUpper 
2559			 
2559					if DEBUG_FORTH 
2559						DMARK "NT2" 
2559						CALLMONITOR 
2559					endif 
2559				; c has the token to find char 
2559				; a has the mem to scan char 
2559			 
2559 b9				cp c 
255a 28 04			jr z,.fntmatch1 
255c			 
255c				; they are not the same 
255c			 
255c					if DEBUG_FORTH 
255c						DMARK "NT3" 
255c						CALLMONITOR 
255c					endif 
255c d1				pop de	; reset de token to look for 
255d d5				push de 
255e 18 e1			jr .fnt1 
2560				 
2560			.fntmatch1: 
2560			 
2560				; is the same char a null which means we might have a full hit? 
2560					if DEBUG_FORTH 
2560						DMARK "NT4" 
2560						CALLMONITOR 
2560					endif 
2560			 
2560 fe 00			cp 0 
2562 28 0b			jr z, .fntmatchyes 
2564			 
2564				; are we at the end of the token to find? 
2564			 
2564					if DEBUG_FORTH 
2564						DMARK "NT5" 
2564						CALLMONITOR 
2564					endif 
2564 3e 00			ld a, 0 
2566 b9				cp c 
2567			 
2567 c2 51 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
256a			 
256a					if DEBUG_FORTH 
256a						DMARK "NT6" 
256a						CALLMONITOR 
256a					endif 
256a				; token to find is exhusted but no match to stream 
256a			 
256a				; restore tok pointer and continue on 
256a d1				pop de 
256b d5				push de 
256c c3 41 25			jp .fnt1 
256f			 
256f			 
256f			.fntmatchyes: 
256f			 
256f				; hl now contains the end of the found token 
256f			 
256f				; get rid of saved token pointer to find 
256f			 
256f d1				pop de 
2570			 
2570					if DEBUG_FORTH 
2570						DMARK "NT9" 
2570						CALLMONITOR 
2570					endif 
2570			 
2570				; hl will be on the null term so forward on 
2570			 
2570				; get back the saved start of the token 
2570			 
2570 d9				exx 
2571 e5				push hl     ; save start of token just in case it is the right one 
2572 d9				exx 
2573 e1				pop hl        ; save it to hl 
2574			 
2574 c9				ret 
2575			 
2575			 
2575			; LIST needs to find a specific token   
2575			; FORGET needs to find a spefici token 
2575			 
2575			; SAVE needs to find all tokens by flag 
2575			; WORDS just needs to scan through all  by flag 
2575			; UWORDS needs to scan through all by flag 
2575			 
2575			 
2575			; given hl as pointer to start of dict look up string 
2575			; return hl as pointer to start of word block 
2575			; or 0 if not found 
2575			 
2575			forth_find_tok: 
2575 c9				ret 
2576			 
2576			; given hl as pointer to dict structure 
2576			; move to the next dict block structure 
2576			 
2576			forth_tok_next: 
2576				; hl now points to the address of the next word pointer  
2576				; TODO skip compiled symbol for now 
2576			;	push de 
2576 23				inc hl 
2577 5e				ld e, (hl) 
2578 23				inc hl 
2579 56				ld d, (hl) 
257a 23				inc hl 
257b			 
257b eb				ex de,hl 
257c			if DEBUG_FORTH_PARSE_NEXTWORD 
257c				push bc 
257c				ld bc, (cli_nextword) 
257c						DMARK "NXW" 
257c				CALLMONITOR 
257c				pop bc 
257c			endif 
257c			;	pop de	 
257c c9				ret 
257d			 
257d			 
257d			 
257d			; eof 
# End of file forth_parserv6.asm
257d				include "forth_wordsv4.asm" 
257d			 
257d			; the core word dictionary v4 
257d			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
257d			 
257d			; this is a linked list for each of the system words used 
257d			; user defined words will follow the same format but will be in ram 
257d			 
257d			 
257d			; 
257d			; 
257d			; define linked list: 
257d			; 
257d			; 1. compiled byte op code 
257d			; 2. len of text word 
257d			; 3. text word 
257d			; 4. ptr to next dictionary word 
257d			; 5. asm, calls etc for the word 
257d			; 
257d			;  if 1 == 0 then last word in dict  
257d			;   
257d			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
257d			;  
257d			;  
257d			; create basic standard set of words 
257d			; 
257d			;  
257d			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
257d			; 2DUP 2DROP 2SWAP  
257d			; @ C@ - get byte  
257d			; ! C! - store byte 
257d			; 0< true if less than zero 
257d			; 0= true if zero 
257d			; < >  
257d			; = true if same 
257d			; variables 
257d			 
257d			 
257d			; Hardware specific words I may need 
257d			; 
257d			; IN OUT  
257d			; calls to key util functions 
257d			; calls to hardward abstraction stuff 
257d			; easy control of frame buffers and lcd i/o 
257d			; keyboard  
257d			 
257d			 
257d			;DICT: macro 
257d			; op_code, len, word, next 
257d			;    word: 
257d			;    db op_code 
257d			;    ds word zero term 
257d			;    dw next 
257d			;    endm 
257d			 
257d			 
257d			 
257d			 
257d			; op code 1 is a flag for user define words which are to be handled differently 
257d			 
257d			 
257d			; 
257d			; 
257d			;    TODO on entry to a word this should be the expected environment 
257d			;    hl - tos value if number then held, if string this is the ptr 
257d			;    de -  
257d			 
257d			 
257d			; opcode ranges 
257d			; 0 - end of word dict 
257d			; 255 - user define words 
257d			 
257d			sysdict: 
257d			include "forth_opcodes.asm" 
257d			; op codes for forth keywords 
257d			 
257d			; Changing use of opcodes to flag is the word exists in compiled form or not.  
257d			; This provides a means to compile uwords if required for higher performance 
257d			; by avoiding the use of the keyword parser and just jumping directly to the code 
257d			; Actually there is already a flag for if the code exists as binary thinking about it... 
257d			 
257d			 
257d			 
257d			 
257d			 
257d			; free to use code 0  
257d				OPCODE_HEAP: equ  1 
257d				OPCODE_EXEC: equ 2 
257d				OPCODE_DUP: equ 3 
257d				OPCODE_SWAP: equ 4 
257d				OPCODE_COLN: equ 5 
257d				OPCODE_SCOLN: equ 6 
257d				OPCODE_DROP: equ 7 
257d				OPCODE_DUP2: equ 8 
257d				OPCODE_DROP2: equ 9 
257d				OPCODE_SWAP2: equ 10 
257d				OPCODE_AT: equ 11 
257d				OPCODE_CAT: equ 12 
257d				OPCODE_BANG: equ 13 
257d				OPCODE_CBANG: equ 14 
257d				OPCODE_SCALL: equ 15 
257d				OPCODE_DEPTH: equ 16 
257d				OPCODE_OVER: equ 17 
257d				OPCODE_PAUSE: equ 18 
257d				OPCODE_PAUSES: equ 19 
257d				OPCODE_ROT: equ 20 
257d			;free to reuse	OPCODE_WORDS: equ 21 
257d			        OPCODE_NOT: equ 21 
257d				OPCODE_UWORDS: equ 22 
257d				OPCODE_BP: equ 23 
257d				OPCODE_MONITOR: equ 24  
257d				OPCODE_MALLOC: equ 25 
257d				OPCODE_FREE: equ 26 
257d				OPCODE_LIST: equ 27 
257d				OPCODE_FORGET: equ 28 
257d				OPCODE_NOP: equ 29 
257d				OPCODE_COMO: equ 30 
257d				OPCODE_COMC: equ 31 
257d			;free to reuse	OPCODE_ENDCORE: equ 32 
257d				OPCODE_AFTERSOUND: equ 33 
257d				OPCODE_GP2: equ 34 
257d				OPCODE_GP3: equ 35 
257d				OPCODE_GP4: equ 36 
257d				OPCODE_SIN: equ 37 
257d				OPCODE_SOUT: equ 38 
257d				OPCODE_SPIO: equ 39 
257d				OPCODE_SPICEH: equ 40 
257d				OPCODE_SPIOb: equ 41 
257d				OPCODE_SPII: equ 42 
257d				OPCODE_SESEL: equ 43 
257d				OPCODE_CARTDEV: equ 44 
257d			; free to reuse	OPCODE_ENDDEVICE: equ 45 
257d				OPCODE_FB: equ 46 
257d				OPCODE_EMIT: equ 47 
257d				OPCODE_DOTH: equ 48 
257d				OPCODE_DOTF: equ 49 
257d				OPCODE_DOT: equ 50 
257d				OPCODE_CLS: equ 51 
257d				OPCODE_DRAW: equ 52 
257d				OPCODE_DUMP: equ 53 
257d				OPCODE_CDUMP: equ 54 
257d				OPCODE_DAT: equ 55 
257d				OPCODE_HOME: equ 56 
257d				OPCODE_SPACE: equ 57 
257d				OPCODE_SPACES: equ 58 
257d				OPCODE_SCROLL: equ 59 
257d				OPCODE_ATQ: equ 60 
257d				OPCODE_AUTODSP: equ 61 
257d				OPCODE_MENU: equ 62 
257d			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
257d				OPCODE_THEN: equ 64 
257d				OPCODE_ELSE: equ 65 
257d				OPCODE_DO: equ 66 
257d				OPCODE_LOOP: equ 67 
257d				OPCODE_I: equ 68 
257d				OPCODE_DLOOP: equ 69  
257d				OPCODE_REPEAT: equ 70  
257d				OPCODE_UNTIL: equ 71 
257d				OPCODE_ENDFLOW: equ 72 
257d				OPCODE_WAITK: equ 73 
257d				OPCODE_ACCEPT: equ 74 
257d				OPCODE_EDIT: equ 75 
257d			;free to reuse	OPCODE_ENDKEY: equ 76 
257d				OPCODE_LZERO: equ 77 
257d				OPCODE_TZERO: equ 78 
257d				OPCODE_LESS: equ 79 
257d				OPCODE_GT: equ 80 
257d				OPCODE_EQUAL: equ 81  
257d			;free to reuse	OPCODE_ENDLOGIC: equ 82 
257d				OPCODE_NEG: equ 83 
257d				OPCODE_DIV: equ 84 
257d				OPCODE_MUL: equ 85 
257d				OPCODE_MIN: equ 86 
257d				OPCODE_MAX: equ 87 
257d				OPCODE_RND16: equ 88 
257d				OPCODE_RND8: equ 89 
257d				OPCODE_RND: equ 90 
257d			;free to reuse	OPCODE_ENDMATHS: equ 91  
257d				OPCODE_BYNAME: equ 92 
257d				OPCODE_DIR: equ 93 
257d				OPCODE_SAVE: equ 94 
257d				OPCODE_LOAD: equ 95 
257d				OPCODE_BSAVE: equ 96 
257d				OPCODE_BLOAD: equ 97 
257d				OPCODE_SEO: equ 98  
257d				OPCODE_SEI: equ 99 
257d				OPCODE_SFREE: equ 100 
257d				OPCODE_SIZE: equ 101 
257d				OPCODE_CREATE: equ 102 
257d				OPCODE_APPEND: equ 103 
257d				OPCODE_SDEL: equ 104 
257d				OPCODE_OPEN: equ 105 
257d				OPCODE_READ: equ 106 
257d				OPCODE_EOF: equ 106 
257d				OPCODE_FORMAT: equ 107 
257d				OPCODE_LABEL: equ 108 
257d				OPCODE_LABELS: equ 109 
257d			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
257d				OPCODE_UPPER: equ 111 
257d				OPCODE_LOWER: equ 112 
257d				OPCODE_SUBSTR: equ 113 
257d				OPCODE_LEFT: equ 114 
257d				OPCODE_RIGHT: equ 115 
257d				OPCODE_STR2NUM: equ 116 
257d				OPCODE_NUM2STR: equ 117 
257d				OPCODE_CONCAT: equ 118 
257d				OPCODE_FIND: equ 119 
257d				OPCODE_LEN: equ 120 
257d				OPCODE_CHAR: equ 121 
257d			; free to reuse	OPCODE_STRLEN: equ 122 
257d			; free to reuse	OPCODE_ENDSTR: equ 123 
257d				OPCODE_V0S: equ 124 
257d				OPCODE_V0Q: equ 125 
257d				OPCODE_V1S: equ 126 
257d				OPCODE_V1Q: equ 127 
257d				OPCODE_V2S: equ 128 
257d				OPCODE_V2Q: equ 129 
257d				OPCODE_V3S: equ 130 
257d				OPCODE_V3Q: equ 131 
257d			;free to reuse	OPCODE_END: equ 132 
257d				OPCODE_ZDUP: equ 133 
257d			 
257d			; eof 
# End of file forth_opcodes.asm
257d			 
257d			include "forth_words_core.asm" 
257d			 
257d			; | ## Core Words 
257d			 
257d			;if MALLOC_4 
257d			 
257d			.HEAP: 
257d			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
257d 15				db WORD_SYS_CORE+OPCODE_HEAP             
257e bc 25			dw .EXEC            
2580 05				db 4 + 1 
2581 .. 00			db "HEAP",0              
2586				endm 
# End of macro CWHEAD
2586			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2586			; | | u1 - Current number of bytes in the heap 
2586			; | | u2 - Remaining bytes left on the heap 
2586			; | |  
2586			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2586			 
2586			 
2586				if DEBUG_FORTH_WORDS_KEY 
2586					DMARK "HEP" 
2586 f5				push af  
2587 3a 9b 25			ld a, (.dmark)  
258a 32 a0 fd			ld (debug_mark),a  
258d 3a 9c 25			ld a, (.dmark+1)  
2590 32 a1 fd			ld (debug_mark+1),a  
2593 3a 9d 25			ld a, (.dmark+2)  
2596 32 a2 fd			ld (debug_mark+2),a  
2599 18 03			jr .pastdmark  
259b ..			.dmark: db "HEP"  
259e f1			.pastdmark: pop af  
259f			endm  
# End of macro DMARK
259f					CALLMONITOR 
259f cd aa fd			call debug_vector  
25a2				endm  
# End of macro CALLMONITOR
25a2				endif 
25a2 2a 0a 80			ld hl, (free_list )      
25a5 11 0e 80			ld de, heap_start 
25a8			 
25a8 ed 52			sbc hl, de  
25aa			 
25aa cd 48 20			call forth_push_numhl 
25ad			 
25ad			 
25ad ed 5b 0a 80		ld de, (free_list )      
25b1 21 d1 f0			ld hl, heap_end 
25b4			 
25b4 ed 52			sbc hl, de 
25b6			 
25b6 cd 48 20			call forth_push_numhl 
25b9				 
25b9			 
25b9				 
25b9			 
25b9			 
25b9			 
25b9				NEXTW 
25b9 c3 39 24			jp macro_next 
25bc				endm 
# End of macro NEXTW
25bc			;endif 
25bc			 
25bc			.EXEC: 
25bc			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
25bc			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
25bc			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
25bc			;; > > 
25bc			;; > >   
25bc			;	STACKFRAME OFF $5efe $5f9f 
25bc			; 
25bc			;		if DEBUG_FORTH_WORDS_KEY 
25bc			;			DMARK "EXE" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			; 
25bc			;	FORTH_DSP_VALUEHL 
25bc			; 
25bc			;	FORTH_DSP_POP 
25bc			; 
25bc			;		if DEBUG_FORTH_WORDS 
25bc			;			DMARK "EX1" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			;;	ld e,(hl) 
25bc			;;	inc hl 
25bc			;;	ld d,(hl) 
25bc			;;	ex de,hl 
25bc			; 
25bc			;;		if DEBUG_FORTH_WORDS 
25bc			;;			DMARK "EX2" 
25bc			;;			CALLMONITOR 
25bc			;;		endif 
25bc			;	push hl 
25bc			; 
25bc			;	;ld a, 0 
25bc			;	;ld a, FORTH_END_BUFFER 
25bc			;	call strlenz 
25bc			;	inc hl   ; include zero term to copy 
25bc			;	inc hl   ; include term 
25bc			;	inc hl   ; include term 
25bc			;	ld b,0 
25bc			;	ld c,l 
25bc			;	pop hl 
25bc			;	ld de, execscratch 
25bc			;		if DEBUG_FORTH_WORDS 
25bc			;			DMARK "EX3" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			;	ldir 
25bc			; 
25bc			; 
25bc			;	ld hl, execscratch 
25bc			; 
25bc			;		if DEBUG_FORTH_WORDS 
25bc			;			DMARK "EXe" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			; 
25bc			;	call forthparse 
25bc			;	call forthexec 
25bc			;;	call forthexec_cleanup 
25bc			;;	call forthparse 
25bc			;;	call forthexec 
25bc			; 
25bc			;	STACKFRAMECHK OFF $5efe $5f9f 
25bc			; 
25bc			;	; an immediate word so no need to process any more words 
25bc			;	ret 
25bc			;	NEXTW 
25bc			 
25bc			; dead code - old version  
25bc			;	FORTH_RSP_NEXT 
25bc			 
25bc			;  
25bc			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
25bc			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
25bc			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
25bc			;	push hl 
25bc			;	push de 
25bc			;	push bc 
25bc			; 
25bc			; 
25bc			;		if DEBUG_FORTH_WORDS_KEY 
25bc			;			DMARK "EXR" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			; 
25bc			; 
25bc			; 
25bc			;	;v5 FORTH_DSP_VALUE 
25bc			;	FORTH_DSP_VALUEHL 
25bc			; 
25bc			;	; TODO do string type checks 
25bc			; 
25bc			;;v5	inc hl   ; skip type 
25bc			; 
25bc			;	push hl  ; source code  
25bc			;		if DEBUG_FORTH_WORDS 
25bc			;			DMARK "EX1" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			;	ld a, 0 
25bc			;	call strlent 
25bc			; 
25bc			;	inc hl 
25bc			;	inc hl 
25bc			;	inc hl 
25bc			;	inc hl 
25bc			; 
25bc			;	push hl    ; size 
25bc			; 
25bc			;		if DEBUG_FORTH_WORDS 
25bc			;			DMARK "EX2" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			;	call malloc 
25bc			; 
25bc			;	ex de, hl    ; de now contains malloc area 
25bc			;	pop bc   	; get byte count 
25bc			;	pop hl      ; get string to copy 
25bc			; 
25bc			;	push de     ; save malloc for free later 
25bc			; 
25bc			;		if DEBUG_FORTH_WORDS 
25bc			;			DMARK "EX3" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			;	ldir       ; duplicate string 
25bc			; 
25bc			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
25bc			;	 
25bc			;	; TODO fix the parse would be better than this...  
25bc			;	ex de, hl 
25bc			;	dec hl 
25bc			;	ld a, 0 
25bc			;	ld (hl), a 
25bc			;	dec hl 
25bc			;	ld a, ' ' 
25bc			;	ld (hl), a 
25bc			;	dec hl 
25bc			;	ld (hl), a 
25bc			; 
25bc			;	dec hl 
25bc			;	ld (hl), a 
25bc			; 
25bc			; 
25bc			;	FORTH_DSP_POP  
25bc			; 
25bc			;	pop hl     
25bc			;	push hl    ; save malloc area 
25bc			; 
25bc			;		if DEBUG_FORTH_WORDS 
25bc			;			DMARK "EX4" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			; 
25bc			;	call forthparse 
25bc			;	call forthexec 
25bc			;	 
25bc			;	pop hl 
25bc			;	if DEBUG_FORTH_WORDS 
25bc			;		DMARK "EX5" 
25bc			;		CALLMONITOR 
25bc			;	endif 
25bc			; 
25bc			;	if FORTH_ENABLE_FREE 
25bc			;	call free 
25bc			;	endif 
25bc			; 
25bc			;	if DEBUG_FORTH_WORDS 
25bc			;		DMARK "EX6" 
25bc			;		CALLMONITOR 
25bc			;	endif 
25bc			; 
25bc			;	pop bc 
25bc			;	pop de 
25bc			;	pop hl 
25bc			;;	FORTH_RSP_POP	  
25bc			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
25bc			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
25bc			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
25bc			; 
25bc			;	if DEBUG_FORTH_WORDS 
25bc			;		DMARK "EX7" 
25bc			;		CALLMONITOR 
25bc			;	endif 
25bc			;	NEXTW 
25bc			 
25bc			;.STKEXEC: 
25bc			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
25bc			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
25bc			; 
25bc			; 
25bc			;		if DEBUG_FORTH_WORDS_KEY 
25bc			;			DMARK "STX" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			; 
25bc			;	FORTH_DSP_VALUEHL 
25bc			; 
25bc			;	ld (store_tmp1), hl    ; count 
25bc			; 
25bc			;	FORTH_DSP_POP 
25bc			;.stkexec1: 
25bc			;	ld hl, (store_tmp1)   ; count 
25bc			;	ld a, 0 
25bc			;	cp l 
25bc			;	ret z 
25bc			; 
25bc			;	dec hl 
25bc			;	ld (store_tmp1), hl    ; count 
25bc			;	 
25bc			;	FORTH_DSP_VALUEHL 
25bc			;	push hl 
25bc			;	 
25bc			;		if DEBUG_FORTH_WORDS 
25bc			;			DMARK "EXp" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			;	FORTH_DSP_POP 
25bc			; 
25bc			;	call strlenz 
25bc			;	inc hl   ; include zero term to copy 
25bc			;	inc hl   ; include zero term to copy 
25bc			;	inc hl   ; include zero term to copy 
25bc			;	ld b,0 
25bc			;	ld c,l 
25bc			;	pop hl 
25bc			;	ld de, execscratch 
25bc			;		if DEBUG_FORTH_WORDS 
25bc			;			DMARK "EX3" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			;	ldir 
25bc			; 
25bc			; 
25bc			;	ld hl, execscratch 
25bc			; 
25bc			;		if DEBUG_FORTH_WORDS 
25bc			;			DMARK "EXP" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			; 
25bc			;	call forthparse 
25bc			;	ld hl, execscratch 
25bc			;		if DEBUG_FORTH_WORDS 
25bc			;			DMARK "EXx" 
25bc			;			CALLMONITOR 
25bc			;		endif 
25bc			;	call forthexec 
25bc			; 
25bc			;	jp .stkexec1 
25bc			; 
25bc			;	ret 
25bc			 
25bc			 
25bc			.DUP: 
25bc			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
25bc 17				db WORD_SYS_CORE+OPCODE_DUP             
25bd 32 26			dw .ZDUP            
25bf 04				db 3 + 1 
25c0 .. 00			db "DUP",0              
25c4				endm 
# End of macro CWHEAD
25c4			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
25c4			 
25c4				if DEBUG_FORTH_WORDS_KEY 
25c4					DMARK "DUP" 
25c4 f5				push af  
25c5 3a d9 25			ld a, (.dmark)  
25c8 32 a0 fd			ld (debug_mark),a  
25cb 3a da 25			ld a, (.dmark+1)  
25ce 32 a1 fd			ld (debug_mark+1),a  
25d1 3a db 25			ld a, (.dmark+2)  
25d4 32 a2 fd			ld (debug_mark+2),a  
25d7 18 03			jr .pastdmark  
25d9 ..			.dmark: db "DUP"  
25dc f1			.pastdmark: pop af  
25dd			endm  
# End of macro DMARK
25dd					CALLMONITOR 
25dd cd aa fd			call debug_vector  
25e0				endm  
# End of macro CALLMONITOR
25e0				endif 
25e0			 
25e0				FORTH_DSP 
25e0 cd 13 22			call macro_forth_dsp 
25e3				endm 
# End of macro FORTH_DSP
25e3			 
25e3 7e				ld a, (HL) 
25e4 fe 01			cp DS_TYPE_STR 
25e6 20 25			jr nz, .dupinum 
25e8			 
25e8				; push another string 
25e8			 
25e8				FORTH_DSP_VALUEHL     		 
25e8 cd 4d 22			call macro_dsp_valuehl 
25eb				endm 
# End of macro FORTH_DSP_VALUEHL
25eb			 
25eb			if DEBUG_FORTH_WORDS 
25eb				DMARK "DUs" 
25eb f5				push af  
25ec 3a 00 26			ld a, (.dmark)  
25ef 32 a0 fd			ld (debug_mark),a  
25f2 3a 01 26			ld a, (.dmark+1)  
25f5 32 a1 fd			ld (debug_mark+1),a  
25f8 3a 02 26			ld a, (.dmark+2)  
25fb 32 a2 fd			ld (debug_mark+2),a  
25fe 18 03			jr .pastdmark  
2600 ..			.dmark: db "DUs"  
2603 f1			.pastdmark: pop af  
2604			endm  
# End of macro DMARK
2604				CALLMONITOR 
2604 cd aa fd			call debug_vector  
2607				endm  
# End of macro CALLMONITOR
2607			endif 
2607 cd b6 20			call forth_push_str 
260a			 
260a				NEXTW 
260a c3 39 24			jp macro_next 
260d				endm 
# End of macro NEXTW
260d			 
260d			 
260d			.dupinum: 
260d				 
260d			 
260d			 
260d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
260d cd 4d 22			call macro_dsp_valuehl 
2610				endm 
# End of macro FORTH_DSP_VALUEHL
2610			 
2610			; TODO add floating point number detection 
2610			 
2610			if DEBUG_FORTH_WORDS 
2610				DMARK "DUi" 
2610 f5				push af  
2611 3a 25 26			ld a, (.dmark)  
2614 32 a0 fd			ld (debug_mark),a  
2617 3a 26 26			ld a, (.dmark+1)  
261a 32 a1 fd			ld (debug_mark+1),a  
261d 3a 27 26			ld a, (.dmark+2)  
2620 32 a2 fd			ld (debug_mark+2),a  
2623 18 03			jr .pastdmark  
2625 ..			.dmark: db "DUi"  
2628 f1			.pastdmark: pop af  
2629			endm  
# End of macro DMARK
2629				CALLMONITOR 
2629 cd aa fd			call debug_vector  
262c				endm  
# End of macro CALLMONITOR
262c			endif 
262c			 
262c cd 48 20			call forth_push_numhl 
262f				NEXTW 
262f c3 39 24			jp macro_next 
2632				endm 
# End of macro NEXTW
2632			.ZDUP: 
2632			CWHEAD .LSHIFT OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2632 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2633 6a 26			dw .LSHIFT            
2635 05				db 4 + 1 
2636 .. 00			db "?DUP",0              
263b				endm 
# End of macro CWHEAD
263b			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
263b			 
263b				if DEBUG_FORTH_WORDS_KEY 
263b					DMARK "qDU" 
263b f5				push af  
263c 3a 50 26			ld a, (.dmark)  
263f 32 a0 fd			ld (debug_mark),a  
2642 3a 51 26			ld a, (.dmark+1)  
2645 32 a1 fd			ld (debug_mark+1),a  
2648 3a 52 26			ld a, (.dmark+2)  
264b 32 a2 fd			ld (debug_mark+2),a  
264e 18 03			jr .pastdmark  
2650 ..			.dmark: db "qDU"  
2653 f1			.pastdmark: pop af  
2654			endm  
# End of macro DMARK
2654					CALLMONITOR 
2654 cd aa fd			call debug_vector  
2657				endm  
# End of macro CALLMONITOR
2657				endif 
2657				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2657 cd 4d 22			call macro_dsp_valuehl 
265a				endm 
# End of macro FORTH_DSP_VALUEHL
265a			 
265a e5				push hl 
265b			 
265b				; is it a zero? 
265b			 
265b 3e 00			ld a, 0 
265d 84				add h 
265e 85				add l 
265f			 
265f e1				pop hl 
2660			 
2660 fe 00			cp 0 
2662 28 03			jr z, .dup2orig 
2664			 
2664			 
2664 cd 48 20			call forth_push_numhl 
2667			 
2667			 
2667			; TODO add floating point number detection 
2667			 
2667			.dup2orig: 
2667			 
2667				NEXTW 
2667 c3 39 24			jp macro_next 
266a				endm 
# End of macro NEXTW
266a			.LSHIFT: 
266a			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
266a 99				db WORD_SYS_CORE+OPCODE_ZDUP             
266b 9e 26			dw .RSHIFT            
266d 07				db 6 + 1 
266e .. 00			db "LSHIFT",0              
2675				endm 
# End of macro CWHEAD
2675			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
2675				if DEBUG_FORTH_WORDS_KEY 
2675					DMARK "LSH" 
2675 f5				push af  
2676 3a 8a 26			ld a, (.dmark)  
2679 32 a0 fd			ld (debug_mark),a  
267c 3a 8b 26			ld a, (.dmark+1)  
267f 32 a1 fd			ld (debug_mark+1),a  
2682 3a 8c 26			ld a, (.dmark+2)  
2685 32 a2 fd			ld (debug_mark+2),a  
2688 18 03			jr .pastdmark  
268a ..			.dmark: db "LSH"  
268d f1			.pastdmark: pop af  
268e			endm  
# End of macro DMARK
268e					CALLMONITOR 
268e cd aa fd			call debug_vector  
2691				endm  
# End of macro CALLMONITOR
2691				endif 
2691				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2691 cd 4d 22			call macro_dsp_valuehl 
2694				endm 
# End of macro FORTH_DSP_VALUEHL
2694				FORTH_DSP_POP 
2694 cd 05 23			call macro_forth_dsp_pop 
2697				endm 
# End of macro FORTH_DSP_POP
2697			 
2697 29				add hl, hl 
2698 cd 48 20			call forth_push_numhl 
269b				NEXTW 
269b c3 39 24			jp macro_next 
269e				endm 
# End of macro NEXTW
269e			.RSHIFT: 
269e			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
269e 99				db WORD_SYS_CORE+OPCODE_ZDUP             
269f d5 26			dw .SWAP            
26a1 07				db 6 + 1 
26a2 .. 00			db "RSHIFT",0              
26a9				endm 
# End of macro CWHEAD
26a9			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
26a9				if DEBUG_FORTH_WORDS_KEY 
26a9					DMARK "RSH" 
26a9 f5				push af  
26aa 3a be 26			ld a, (.dmark)  
26ad 32 a0 fd			ld (debug_mark),a  
26b0 3a bf 26			ld a, (.dmark+1)  
26b3 32 a1 fd			ld (debug_mark+1),a  
26b6 3a c0 26			ld a, (.dmark+2)  
26b9 32 a2 fd			ld (debug_mark+2),a  
26bc 18 03			jr .pastdmark  
26be ..			.dmark: db "RSH"  
26c1 f1			.pastdmark: pop af  
26c2			endm  
# End of macro DMARK
26c2					CALLMONITOR 
26c2 cd aa fd			call debug_vector  
26c5				endm  
# End of macro CALLMONITOR
26c5				endif 
26c5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c5 cd 4d 22			call macro_dsp_valuehl 
26c8				endm 
# End of macro FORTH_DSP_VALUEHL
26c8				FORTH_DSP_POP 
26c8 cd 05 23			call macro_forth_dsp_pop 
26cb				endm 
# End of macro FORTH_DSP_POP
26cb cb 3c			srl h 
26cd cb 1d			rr l 
26cf cd 48 20			call forth_push_numhl 
26d2				NEXTW 
26d2 c3 39 24			jp macro_next 
26d5				endm 
# End of macro NEXTW
26d5			.SWAP: 
26d5			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
26d5 18				db WORD_SYS_CORE+OPCODE_SWAP             
26d6 29 27			dw .COLN            
26d8 05				db 4 + 1 
26d9 .. 00			db "SWAP",0              
26de				endm 
# End of macro CWHEAD
26de			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
26de				if DEBUG_FORTH_WORDS_KEY 
26de					DMARK "SWP" 
26de f5				push af  
26df 3a f3 26			ld a, (.dmark)  
26e2 32 a0 fd			ld (debug_mark),a  
26e5 3a f4 26			ld a, (.dmark+1)  
26e8 32 a1 fd			ld (debug_mark+1),a  
26eb 3a f5 26			ld a, (.dmark+2)  
26ee 32 a2 fd			ld (debug_mark+2),a  
26f1 18 03			jr .pastdmark  
26f3 ..			.dmark: db "SWP"  
26f6 f1			.pastdmark: pop af  
26f7			endm  
# End of macro DMARK
26f7					CALLMONITOR 
26f7 cd aa fd			call debug_vector  
26fa				endm  
# End of macro CALLMONITOR
26fa				endif 
26fa			 
26fa			; DONE Use os stack swap memory 
26fa			 
26fa				FORTH_DSP_PTR 0     ; TOS 
26fa 2a 23 f9			ld hl,(cli_data_sp) 
26fd 11 00 00			ld de, 0 * 3 
2700 ed 52			sbc hl, de 
2702				endm 
# End of macro FORTH_DSP_PTR
2702 cd 85 23			call hltostack1 
2705			  
2705				FORTH_DSP_PTR 1     ; TOS 
2705 2a 23 f9			ld hl,(cli_data_sp) 
2708 11 03 00			ld de, 1 * 3 
270b ed 52			sbc hl, de 
270d				endm 
# End of macro FORTH_DSP_PTR
270d cd 8b 23			call hltostack2 
2710			 
2710				FORTH_DSP_PTR 0     ; TOS 
2710 2a 23 f9			ld hl,(cli_data_sp) 
2713 11 00 00			ld de, 0 * 3 
2716 ed 52			sbc hl, de 
2718				endm 
# End of macro FORTH_DSP_PTR
2718 cd a3 23			call hlfromstack2 
271b			 
271b				FORTH_DSP_PTR 1     ; TOS 
271b 2a 23 f9			ld hl,(cli_data_sp) 
271e 11 03 00			ld de, 1 * 3 
2721 ed 52			sbc hl, de 
2723				endm 
# End of macro FORTH_DSP_PTR
2723 cd 9d 23			call hlfromstack1 
2726			;	FORTH_DSP_VALUEHL 
2726			;	push hl     ; w2 
2726			; 
2726			;	FORTH_DSP_POP 
2726			; 
2726			;	FORTH_DSP_VALUEHL 
2726			; 
2726			;	FORTH_DSP_POP 
2726			; 
2726			;	pop de     ; w2	, hl = w1 
2726			; 
2726			;	ex de, hl 
2726			;	push de 
2726			; 
2726			;	call forth_push_numhl 
2726			; 
2726			;	pop hl 
2726			; 
2726			;	call forth_push_numhl 
2726				 
2726			 
2726				NEXTW 
2726 c3 39 24			jp macro_next 
2729				endm 
# End of macro NEXTW
2729			.COLN: 
2729			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2729 19				db WORD_SYS_CORE+OPCODE_COLN             
272a b5 28			dw .SCOLN            
272c 02				db 1 + 1 
272d .. 00			db ":",0              
272f				endm 
# End of macro CWHEAD
272f			; | : ( -- )         Create new word | DONE 
272f			 
272f				if DEBUG_FORTH_WORDS_KEY 
272f					DMARK "CLN" 
272f f5				push af  
2730 3a 44 27			ld a, (.dmark)  
2733 32 a0 fd			ld (debug_mark),a  
2736 3a 45 27			ld a, (.dmark+1)  
2739 32 a1 fd			ld (debug_mark+1),a  
273c 3a 46 27			ld a, (.dmark+2)  
273f 32 a2 fd			ld (debug_mark+2),a  
2742 18 03			jr .pastdmark  
2744 ..			.dmark: db "CLN"  
2747 f1			.pastdmark: pop af  
2748			endm  
# End of macro DMARK
2748					CALLMONITOR 
2748 cd aa fd			call debug_vector  
274b				endm  
# End of macro CALLMONITOR
274b				endif 
274b			STACKFRAME OFF $8efe $989f 
274b				if DEBUG_STACK_IMB 
274b					if OFF 
274b						exx 
274b						ld de, $8efe 
274b						ld a, d 
274b						ld hl, curframe 
274b						call hexout 
274b						ld a, e 
274b						ld hl, curframe+2 
274b						call hexout 
274b						ld hl, $8efe 
274b						push hl 
274b						ld hl, $989f 
274b						push hl 
274b						exx 
274b					endif 
274b				endif 
274b			endm 
# End of macro STACKFRAME
274b			; get parser buffer length  of new word 
274b			 
274b			 
274b			 
274b				; move tok past this to start of name defintition 
274b				; TODO get word to define 
274b				; TODO Move past word token 
274b				; TODO get length of string up to the ';' 
274b			 
274b 2a f7 f3		ld hl, (os_tok_ptr) 
274e 23			inc hl 
274f 23			inc hl 
2750			 
2750 3e 3b		ld a, ';' 
2752 cd 4f 13		call strlent 
2755			 
2755 7d			ld a,l 
2756 32 e6 f0		ld (os_new_parse_len), a 
2759			 
2759			 
2759			if DEBUG_FORTH_UWORD 
2759 ed 5b f7 f3	ld de, (os_tok_ptr) 
275d					DMARK ":01" 
275d f5				push af  
275e 3a 72 27			ld a, (.dmark)  
2761 32 a0 fd			ld (debug_mark),a  
2764 3a 73 27			ld a, (.dmark+1)  
2767 32 a1 fd			ld (debug_mark+1),a  
276a 3a 74 27			ld a, (.dmark+2)  
276d 32 a2 fd			ld (debug_mark+2),a  
2770 18 03			jr .pastdmark  
2772 ..			.dmark: db ":01"  
2775 f1			.pastdmark: pop af  
2776			endm  
# End of macro DMARK
2776			CALLMONITOR 
2776 cd aa fd			call debug_vector  
2779				endm  
# End of macro CALLMONITOR
2779			endif 
2779			 
2779			; 
2779			;  new word memory layout: 
2779			;  
2779			;    : adg 6666 ;  
2779			; 
2779			;    db   1     ; user defined word  
2779 23			inc hl    
277a			;    dw   sysdict 
277a 23			inc hl 
277b 23			inc hl 
277c			;    db <word len>+1 (for null) 
277c 23			inc hl 
277d			;    db .... <word> 
277d			; 
277d			 
277d 23			inc hl    ; some extras for the word preamble before the above 
277e 23			inc hl 
277f 23			inc hl 
2780 23			inc hl 
2781 23			inc hl 
2782 23			inc hl 
2783 23			inc hl  
2784 23			inc hl 
2785 23			inc hl 
2786 23			inc hl 
2787 23			inc hl 
2788 23			inc hl 
2789 23			inc hl 
278a 23			inc hl     ; TODO how many do we really need?     maybe only 6 
278b			;       exec word buffer 
278b			;	<ptr word>   
278b 23			inc hl 
278c 23			inc hl 
278d			;       <word list><null term> 7F final term 
278d			 
278d			 
278d			if DEBUG_FORTH_UWORD 
278d					DMARK ":02" 
278d f5				push af  
278e 3a a2 27			ld a, (.dmark)  
2791 32 a0 fd			ld (debug_mark),a  
2794 3a a3 27			ld a, (.dmark+1)  
2797 32 a1 fd			ld (debug_mark+1),a  
279a 3a a4 27			ld a, (.dmark+2)  
279d 32 a2 fd			ld (debug_mark+2),a  
27a0 18 03			jr .pastdmark  
27a2 ..			.dmark: db ":02"  
27a5 f1			.pastdmark: pop af  
27a6			endm  
# End of macro DMARK
27a6			CALLMONITOR 
27a6 cd aa fd			call debug_vector  
27a9				endm  
# End of macro CALLMONITOR
27a9			endif 
27a9			 
27a9			 
27a9				; malloc the size 
27a9			 
27a9 cd b9 13			call malloc 
27ac 22 e8 f0			ld (os_new_malloc), hl     ; save malloc start 
27af			 
27af			;    db   1     ; user defined word  
27af 3e 01			ld a, WORD_SYS_UWORD  
27b1 77				ld (hl), a 
27b2			 
27b2 23			inc hl    
27b3			;    dw   sysdict 
27b3 11 7d 25		ld de, sysdict       ; continue on with the scan to the system dict 
27b6 73			ld (hl), e 
27b7 23			inc hl 
27b8 72			ld (hl), d 
27b9 23			inc hl 
27ba			 
27ba			 
27ba			;    Setup dict word 
27ba			 
27ba 23			inc hl 
27bb 22 e2 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
27be			 
27be			; 1. get length of dict word 
27be			 
27be			 
27be 2a f7 f3		ld hl, (os_tok_ptr) 
27c1 23			inc hl 
27c2 23			inc hl    ; position to start of dict word 
27c3 3e 00		ld a, 0 
27c5 cd 4f 13		call strlent 
27c8			 
27c8			 
27c8 23			inc hl    ; to include null??? 
27c9			 
27c9			; write length of dict word 
27c9			 
27c9 ed 5b e2 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
27cd 1b			dec de 
27ce eb			ex de, hl 
27cf 73			ld (hl), e 
27d0 eb			ex de, hl 
27d1			 
27d1			 
27d1			 
27d1			; copy  
27d1 4d			ld c, l 
27d2 06 00		ld b, 0 
27d4 ed 5b e2 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
27d8 2a f7 f3		ld hl, (os_tok_ptr) 
27db 23			inc hl 
27dc 23			inc hl    ; position to start of dict word 
27dd			 
27dd			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27dd			 
27dd			; TODO need to convert word to upper case 
27dd			 
27dd			ucasetok:	 
27dd 7e			ld a,(hl) 
27de cd 3b 13		call toUpper 
27e1 77			ld (hl),a 
27e2 ed a0		ldi 
27e4 f2 dd 27		jp p, ucasetok 
27e7			 
27e7			 
27e7			 
27e7			; de now points to start of where the word body code should be placed 
27e7 ed 53 e2 f0	ld (os_new_work_ptr), de 
27eb			; hl now points to the words to throw at forthexec which needs to be copied 
27eb 22 e0 f0		ld (os_new_src_ptr), hl 
27ee			 
27ee			; TODO add 'call to forthexec' 
27ee			 
27ee			if DEBUG_FORTH_UWORD 
27ee c5			push bc 
27ef ed 4b e8 f0	ld bc, (os_new_malloc) 
27f3					DMARK ":0x" 
27f3 f5				push af  
27f4 3a 08 28			ld a, (.dmark)  
27f7 32 a0 fd			ld (debug_mark),a  
27fa 3a 09 28			ld a, (.dmark+1)  
27fd 32 a1 fd			ld (debug_mark+1),a  
2800 3a 0a 28			ld a, (.dmark+2)  
2803 32 a2 fd			ld (debug_mark+2),a  
2806 18 03			jr .pastdmark  
2808 ..			.dmark: db ":0x"  
280b f1			.pastdmark: pop af  
280c			endm  
# End of macro DMARK
280c			CALLMONITOR 
280c cd aa fd			call debug_vector  
280f				endm  
# End of macro CALLMONITOR
280f c1			pop bc 
2810			endif 
2810			 
2810			 
2810			; create word preamble which should be: 
2810			 
2810			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2810			 
2810			;    ld hl, <word code> 
2810			;    jp user_exec 
2810			;    <word code bytes> 
2810			 
2810			 
2810			;	inc de     ; TODO ??? or are we already past the word's null 
2810 eb			ex de, hl 
2811			 
2811 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2813			 
2813 23			inc hl 
2814 22 dc f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2817 23			inc hl 
2818			 
2818 23			inc hl 
2819 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
281b			 
281b 01 0e 60		ld bc, user_exec 
281e 23			inc hl 
281f 71			ld (hl), c     ; poke address of user_exec 
2820 23			inc hl 
2821 70			ld (hl), b     
2822			; 
2822			;	inc hl 
2822			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2822			; 
2822			; 
2822			;	ld bc, macro_forth_rsp_next 
2822			;	inc hl 
2822			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2822			;	inc hl 
2822			;	ld (hl), b     
2822			; 
2822			;	inc hl 
2822			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2822			; 
2822			; 
2822			;	inc hl 
2822			;	ld bc, forthexec 
2822			;	ld (hl), c     ; poke address of forthexec 
2822			;	inc hl 
2822			;	ld (hl), b      
2822			; 
2822			;	inc hl 
2822			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2822			; 
2822			;	ld bc, user_dict_next 
2822			;	inc hl 
2822			;	ld (hl), c     ; poke address of forthexec 
2822			;	inc hl 
2822			;	ld (hl), b      
2822			 
2822			; hl is now where we need to copy the word byte data to save this 
2822			 
2822 23			inc hl 
2823 22 de f0		ld (os_new_exec), hl 
2826			 
2826			; copy definition 
2826			 
2826 eb			ex de, hl 
2827			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2827			;	inc de    ; skip the PC for this parse 
2827 3a e6 f0		ld a, (os_new_parse_len) 
282a 4f			ld c, a 
282b 06 00		ld b, 0 
282d ed b0		ldir		 ; copy defintion 
282f			 
282f			 
282f			; poke the address of where the new word bytes live for forthexec 
282f			 
282f 2a dc f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2832			 
2832 ed 5b de f0	ld de, (os_new_exec)      
2836			 
2836 73			ld (hl), e 
2837 23			inc hl 
2838 72			ld (hl), d 
2839			 
2839				; TODO copy last user dict word next link to this word 
2839				; TODO update last user dict word to point to this word 
2839			; 
2839			; hl f923 de 812a ; bc 811a 
2839			 
2839			if DEBUG_FORTH_UWORD 
2839 c5			push bc 
283a ed 4b e8 f0	ld bc, (os_new_malloc) 
283e					DMARK ":0A" 
283e f5				push af  
283f 3a 53 28			ld a, (.dmark)  
2842 32 a0 fd			ld (debug_mark),a  
2845 3a 54 28			ld a, (.dmark+1)  
2848 32 a1 fd			ld (debug_mark+1),a  
284b 3a 55 28			ld a, (.dmark+2)  
284e 32 a2 fd			ld (debug_mark+2),a  
2851 18 03			jr .pastdmark  
2853 ..			.dmark: db ":0A"  
2856 f1			.pastdmark: pop af  
2857			endm  
# End of macro DMARK
2857			CALLMONITOR 
2857 cd aa fd			call debug_vector  
285a				endm  
# End of macro CALLMONITOR
285a c1			pop bc 
285b			endif 
285b			if DEBUG_FORTH_UWORD 
285b c5			push bc 
285c ed 4b e8 f0	ld bc, (os_new_malloc) 
2860 03			inc bc 
2861 03			inc bc 
2862 03			inc bc 
2863 03			inc bc 
2864 03			inc bc 
2865 03			inc bc 
2866 03			inc bc 
2867 03			inc bc 
2868			 
2868					DMARK ":0B" 
2868 f5				push af  
2869 3a 7d 28			ld a, (.dmark)  
286c 32 a0 fd			ld (debug_mark),a  
286f 3a 7e 28			ld a, (.dmark+1)  
2872 32 a1 fd			ld (debug_mark+1),a  
2875 3a 7f 28			ld a, (.dmark+2)  
2878 32 a2 fd			ld (debug_mark+2),a  
287b 18 03			jr .pastdmark  
287d ..			.dmark: db ":0B"  
2880 f1			.pastdmark: pop af  
2881			endm  
# End of macro DMARK
2881			CALLMONITOR 
2881 cd aa fd			call debug_vector  
2884				endm  
# End of macro CALLMONITOR
2884 c1			pop bc 
2885			endif 
2885			 
2885			; update word dict linked list for new word 
2885			 
2885			 
2885 2a f3 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2888 23			inc hl     ; move to next work linked list ptr 
2889			 
2889 ed 5b e8 f0	ld de, (os_new_malloc)		 ; new next word 
288d 73			ld (hl), e 
288e 23			inc hl 
288f 72			ld (hl), d 
2890			 
2890			if DEBUG_FORTH_UWORD 
2890 ed 4b f3 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2894			endif 
2894			 
2894 ed 53 f3 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
2898			 
2898			 
2898			if DEBUG_FORTH_UWORD 
2898					DMARK ":0+" 
2898 f5				push af  
2899 3a ad 28			ld a, (.dmark)  
289c 32 a0 fd			ld (debug_mark),a  
289f 3a ae 28			ld a, (.dmark+1)  
28a2 32 a1 fd			ld (debug_mark+1),a  
28a5 3a af 28			ld a, (.dmark+2)  
28a8 32 a2 fd			ld (debug_mark+2),a  
28ab 18 03			jr .pastdmark  
28ad ..			.dmark: db ":0+"  
28b0 f1			.pastdmark: pop af  
28b1			endm  
# End of macro DMARK
28b1			CALLMONITOR 
28b1 cd aa fd			call debug_vector  
28b4				endm  
# End of macro CALLMONITOR
28b4			endif 
28b4			 
28b4			STACKFRAMECHK OFF $8efe $989f 
28b4				if DEBUG_STACK_IMB 
28b4					if OFF 
28b4						exx 
28b4						ld hl, $989f 
28b4						pop de   ; $989f 
28b4						call cmp16 
28b4						jr nz, .spnosame 
28b4						ld hl, $8efe 
28b4						pop de   ; $8efe 
28b4						call cmp16 
28b4						jr z, .spfrsame 
28b4						.spnosame: call showsperror 
28b4						.spfrsame: nop 
28b4						exx 
28b4					endif 
28b4				endif 
28b4			endm 
# End of macro STACKFRAMECHK
28b4			 
28b4 c9			ret    ; dont process any remaining parser tokens as they form new word 
28b5			 
28b5			 
28b5			 
28b5			 
28b5			;		NEXT 
28b5			.SCOLN: 
28b5			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
28b5 06			db OPCODE_SCOLN 
28b6 01 29		dw .DROP 
28b8 02			db 2 
28b9 .. 00		db ";",0           
28bb			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
28bb				if DEBUG_FORTH_WORDS_KEY 
28bb					DMARK "SCN" 
28bb f5				push af  
28bc 3a d0 28			ld a, (.dmark)  
28bf 32 a0 fd			ld (debug_mark),a  
28c2 3a d1 28			ld a, (.dmark+1)  
28c5 32 a1 fd			ld (debug_mark+1),a  
28c8 3a d2 28			ld a, (.dmark+2)  
28cb 32 a2 fd			ld (debug_mark+2),a  
28ce 18 03			jr .pastdmark  
28d0 ..			.dmark: db "SCN"  
28d3 f1			.pastdmark: pop af  
28d4			endm  
# End of macro DMARK
28d4					CALLMONITOR 
28d4 cd aa fd			call debug_vector  
28d7				endm  
# End of macro CALLMONITOR
28d7				endif 
28d7				FORTH_RSP_TOS 
28d7 cd 06 20			call macro_forth_rsp_tos 
28da				endm 
# End of macro FORTH_RSP_TOS
28da e5				push hl 
28db				FORTH_RSP_POP 
28db cd 10 20			call macro_forth_rsp_pop 
28de				endm 
# End of macro FORTH_RSP_POP
28de e1				pop hl 
28df			;		ex de,hl 
28df 22 f7 f3			ld (os_tok_ptr),hl 
28e2			 
28e2			if DEBUG_FORTH_UWORD 
28e2					DMARK "SCL" 
28e2 f5				push af  
28e3 3a f7 28			ld a, (.dmark)  
28e6 32 a0 fd			ld (debug_mark),a  
28e9 3a f8 28			ld a, (.dmark+1)  
28ec 32 a1 fd			ld (debug_mark+1),a  
28ef 3a f9 28			ld a, (.dmark+2)  
28f2 32 a2 fd			ld (debug_mark+2),a  
28f5 18 03			jr .pastdmark  
28f7 ..			.dmark: db "SCL"  
28fa f1			.pastdmark: pop af  
28fb			endm  
# End of macro DMARK
28fb			CALLMONITOR 
28fb cd aa fd			call debug_vector  
28fe				endm  
# End of macro CALLMONITOR
28fe			endif 
28fe				NEXTW 
28fe c3 39 24			jp macro_next 
2901				endm 
# End of macro NEXTW
2901			 
2901			.DROP: 
2901			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2901 1b				db WORD_SYS_CORE+OPCODE_DROP             
2902 2c 29			dw .DUP2            
2904 05				db 4 + 1 
2905 .. 00			db "DROP",0              
290a				endm 
# End of macro CWHEAD
290a			; | DROP ( w -- )   drop the TOS item   | DONE 
290a				if DEBUG_FORTH_WORDS_KEY 
290a					DMARK "DRP" 
290a f5				push af  
290b 3a 1f 29			ld a, (.dmark)  
290e 32 a0 fd			ld (debug_mark),a  
2911 3a 20 29			ld a, (.dmark+1)  
2914 32 a1 fd			ld (debug_mark+1),a  
2917 3a 21 29			ld a, (.dmark+2)  
291a 32 a2 fd			ld (debug_mark+2),a  
291d 18 03			jr .pastdmark  
291f ..			.dmark: db "DRP"  
2922 f1			.pastdmark: pop af  
2923			endm  
# End of macro DMARK
2923					CALLMONITOR 
2923 cd aa fd			call debug_vector  
2926				endm  
# End of macro CALLMONITOR
2926				endif 
2926				FORTH_DSP_POP 
2926 cd 05 23			call macro_forth_dsp_pop 
2929				endm 
# End of macro FORTH_DSP_POP
2929				NEXTW 
2929 c3 39 24			jp macro_next 
292c				endm 
# End of macro NEXTW
292c			.DUP2: 
292c			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
292c 1c				db WORD_SYS_CORE+OPCODE_DUP2             
292d 71 29			dw .DROP2            
292f 05				db 4 + 1 
2930 .. 00			db "2DUP",0              
2935				endm 
# End of macro CWHEAD
2935			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
2935				if DEBUG_FORTH_WORDS_KEY 
2935					DMARK "2DU" 
2935 f5				push af  
2936 3a 4a 29			ld a, (.dmark)  
2939 32 a0 fd			ld (debug_mark),a  
293c 3a 4b 29			ld a, (.dmark+1)  
293f 32 a1 fd			ld (debug_mark+1),a  
2942 3a 4c 29			ld a, (.dmark+2)  
2945 32 a2 fd			ld (debug_mark+2),a  
2948 18 03			jr .pastdmark  
294a ..			.dmark: db "2DU"  
294d f1			.pastdmark: pop af  
294e			endm  
# End of macro DMARK
294e					CALLMONITOR 
294e cd aa fd			call debug_vector  
2951				endm  
# End of macro CALLMONITOR
2951				endif 
2951				FORTH_DSP_VALUEHL 
2951 cd 4d 22			call macro_dsp_valuehl 
2954				endm 
# End of macro FORTH_DSP_VALUEHL
2954 e5				push hl      ; 2 
2955			 
2955				FORTH_DSP_POP 
2955 cd 05 23			call macro_forth_dsp_pop 
2958				endm 
# End of macro FORTH_DSP_POP
2958				 
2958				FORTH_DSP_VALUEHL 
2958 cd 4d 22			call macro_dsp_valuehl 
295b				endm 
# End of macro FORTH_DSP_VALUEHL
295b			;		push hl      ; 1 
295b			 
295b				FORTH_DSP_POP 
295b cd 05 23			call macro_forth_dsp_pop 
295e				endm 
# End of macro FORTH_DSP_POP
295e			 
295e			;		pop hl       ; 1 
295e d1				pop de       ; 2 
295f			 
295f cd 48 20			call forth_push_numhl 
2962 eb				ex de, hl 
2963 cd 48 20			call forth_push_numhl 
2966			 
2966				 
2966 eb				ex de, hl 
2967			 
2967 cd 48 20			call forth_push_numhl 
296a eb				ex de, hl 
296b cd 48 20			call forth_push_numhl 
296e			 
296e			 
296e				NEXTW 
296e c3 39 24			jp macro_next 
2971				endm 
# End of macro NEXTW
2971			.DROP2: 
2971			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2971 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2972 a0 29			dw .PICK            
2974 06				db 5 + 1 
2975 .. 00			db "2DROP",0              
297b				endm 
# End of macro CWHEAD
297b			; | 2DROP ( w w -- )    Double drop | DONE 
297b				if DEBUG_FORTH_WORDS_KEY 
297b					DMARK "2DR" 
297b f5				push af  
297c 3a 90 29			ld a, (.dmark)  
297f 32 a0 fd			ld (debug_mark),a  
2982 3a 91 29			ld a, (.dmark+1)  
2985 32 a1 fd			ld (debug_mark+1),a  
2988 3a 92 29			ld a, (.dmark+2)  
298b 32 a2 fd			ld (debug_mark+2),a  
298e 18 03			jr .pastdmark  
2990 ..			.dmark: db "2DR"  
2993 f1			.pastdmark: pop af  
2994			endm  
# End of macro DMARK
2994					CALLMONITOR 
2994 cd aa fd			call debug_vector  
2997				endm  
# End of macro CALLMONITOR
2997				endif 
2997				FORTH_DSP_POP 
2997 cd 05 23			call macro_forth_dsp_pop 
299a				endm 
# End of macro FORTH_DSP_POP
299a				FORTH_DSP_POP 
299a cd 05 23			call macro_forth_dsp_pop 
299d				endm 
# End of macro FORTH_DSP_POP
299d				NEXTW 
299d c3 39 24			jp macro_next 
29a0				endm 
# End of macro NEXTW
29a0			.PICK: 
29a0			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
29a0 77				db WORD_SYS_CORE+99             
29a1 df 29			dw .SWAP2            
29a3 05				db 4 + 1 
29a4 .. 00			db "PICK",0              
29a9				endm 
# End of macro CWHEAD
29a9			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | TODO 
29a9				if DEBUG_FORTH_WORDS_KEY 
29a9					DMARK "PIK" 
29a9 f5				push af  
29aa 3a be 29			ld a, (.dmark)  
29ad 32 a0 fd			ld (debug_mark),a  
29b0 3a bf 29			ld a, (.dmark+1)  
29b3 32 a1 fd			ld (debug_mark+1),a  
29b6 3a c0 29			ld a, (.dmark+2)  
29b9 32 a2 fd			ld (debug_mark+2),a  
29bc 18 03			jr .pastdmark  
29be ..			.dmark: db "PIK"  
29c1 f1			.pastdmark: pop af  
29c2			endm  
# End of macro DMARK
29c2					CALLMONITOR 
29c2 cd aa fd			call debug_vector  
29c5				endm  
# End of macro CALLMONITOR
29c5				endif 
29c5			 
29c5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29c5 cd 4d 22			call macro_dsp_valuehl 
29c8				endm 
# End of macro FORTH_DSP_VALUEHL
29c8				 
29c8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29c8 cd 05 23			call macro_forth_dsp_pop 
29cb				endm 
# End of macro FORTH_DSP_POP
29cb			 
29cb				; init from TOS 
29cb 45				ld b, l 
29cc 21 23 f9			ld hl, cli_data_sp 
29cf			.pkl: 
29cf 2b				dec hl 
29d0 2b				dec hl 
29d1 2b				dec hl 
29d2			 
29d2 10 fb			djnz .pkl 
29d4			 
29d4				 
29d4				; TODO do type check with correct push 
29d4			 
29d4 23				inc hl 
29d5				;call loadwordinhl 
29d5 5e				ld e, (hl) 
29d6 23				inc hl 
29d7 56				ld d, (hl) 
29d8 eb				ex de,hl 
29d9 cd 48 20			call forth_push_numhl 
29dc			 
29dc				NEXTW 
29dc c3 39 24			jp macro_next 
29df				endm 
# End of macro NEXTW
29df			.SWAP2: 
29df			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
29df 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
29e0 60 2a			dw .AT            
29e2 06				db 5 + 1 
29e3 .. 00			db "2SWAP",0              
29e9				endm 
# End of macro CWHEAD
29e9			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
29e9				if DEBUG_FORTH_WORDS_KEY 
29e9					DMARK "2SW" 
29e9 f5				push af  
29ea 3a fe 29			ld a, (.dmark)  
29ed 32 a0 fd			ld (debug_mark),a  
29f0 3a ff 29			ld a, (.dmark+1)  
29f3 32 a1 fd			ld (debug_mark+1),a  
29f6 3a 00 2a			ld a, (.dmark+2)  
29f9 32 a2 fd			ld (debug_mark+2),a  
29fc 18 03			jr .pastdmark  
29fe ..			.dmark: db "2SW"  
2a01 f1			.pastdmark: pop af  
2a02			endm  
# End of macro DMARK
2a02					CALLMONITOR 
2a02 cd aa fd			call debug_vector  
2a05				endm  
# End of macro CALLMONITOR
2a05				endif 
2a05			; TODO Use os stack swap memory 
2a05			 
2a05				FORTH_DSP_PTR 0     ; TOS    w4 
2a05 2a 23 f9			ld hl,(cli_data_sp) 
2a08 11 00 00			ld de, 0 * 3 
2a0b ed 52			sbc hl, de 
2a0d				endm 
# End of macro FORTH_DSP_PTR
2a0d cd 85 23			call hltostack1 
2a10			  
2a10				FORTH_DSP_PTR 1     ; TOS    w3 
2a10 2a 23 f9			ld hl,(cli_data_sp) 
2a13 11 03 00			ld de, 1 * 3 
2a16 ed 52			sbc hl, de 
2a18				endm 
# End of macro FORTH_DSP_PTR
2a18 cd 8b 23			call hltostack2 
2a1b			 
2a1b			 
2a1b			 
2a1b				FORTH_DSP_PTR 2     ; TOS    w2 
2a1b 2a 23 f9			ld hl,(cli_data_sp) 
2a1e 11 06 00			ld de, 2 * 3 
2a21 ed 52			sbc hl, de 
2a23				endm 
# End of macro FORTH_DSP_PTR
2a23 cd 91 23			call hltostack3 
2a26			 
2a26				FORTH_DSP_PTR 3     ; TOS   w1 
2a26 2a 23 f9			ld hl,(cli_data_sp) 
2a29 11 09 00			ld de, 3 * 3 
2a2c ed 52			sbc hl, de 
2a2e				endm 
# End of macro FORTH_DSP_PTR
2a2e cd 97 23			call hltostack4 
2a31			 
2a31			 
2a31			 
2a31			 
2a31				FORTH_DSP_PTR 0     ; TOS 
2a31 2a 23 f9			ld hl,(cli_data_sp) 
2a34 11 00 00			ld de, 0 * 3 
2a37 ed 52			sbc hl, de 
2a39				endm 
# End of macro FORTH_DSP_PTR
2a39 cd a9 23			call hlfromstack3 
2a3c			 
2a3c				FORTH_DSP_PTR 1     ; TOS 
2a3c 2a 23 f9			ld hl,(cli_data_sp) 
2a3f 11 03 00			ld de, 1 * 3 
2a42 ed 52			sbc hl, de 
2a44				endm 
# End of macro FORTH_DSP_PTR
2a44 cd af 23			call hlfromstack4 
2a47			 
2a47			 
2a47			 
2a47				FORTH_DSP_PTR 2     ; TOS 
2a47 2a 23 f9			ld hl,(cli_data_sp) 
2a4a 11 06 00			ld de, 2 * 3 
2a4d ed 52			sbc hl, de 
2a4f				endm 
# End of macro FORTH_DSP_PTR
2a4f cd 9d 23			call hlfromstack1 
2a52			 
2a52				FORTH_DSP_PTR 3     ; TOS 
2a52 2a 23 f9			ld hl,(cli_data_sp) 
2a55 11 09 00			ld de, 3 * 3 
2a58 ed 52			sbc hl, de 
2a5a				endm 
# End of macro FORTH_DSP_PTR
2a5a cd a3 23			call hlfromstack2 
2a5d			 
2a5d				NEXTW 
2a5d c3 39 24			jp macro_next 
2a60				endm 
# End of macro NEXTW
2a60			.AT: 
2a60			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2a60 1f				db WORD_SYS_CORE+OPCODE_AT             
2a61 92 2a			dw .CAT            
2a63 02				db 1 + 1 
2a64 .. 00			db "@",0              
2a66				endm 
# End of macro CWHEAD
2a66			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2a66			 
2a66				if DEBUG_FORTH_WORDS_KEY 
2a66					DMARK "AT." 
2a66 f5				push af  
2a67 3a 7b 2a			ld a, (.dmark)  
2a6a 32 a0 fd			ld (debug_mark),a  
2a6d 3a 7c 2a			ld a, (.dmark+1)  
2a70 32 a1 fd			ld (debug_mark+1),a  
2a73 3a 7d 2a			ld a, (.dmark+2)  
2a76 32 a2 fd			ld (debug_mark+2),a  
2a79 18 03			jr .pastdmark  
2a7b ..			.dmark: db "AT."  
2a7e f1			.pastdmark: pop af  
2a7f			endm  
# End of macro DMARK
2a7f					CALLMONITOR 
2a7f cd aa fd			call debug_vector  
2a82				endm  
# End of macro CALLMONITOR
2a82				endif 
2a82			.getbyteat:	 
2a82				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a82 cd 4d 22			call macro_dsp_valuehl 
2a85				endm 
# End of macro FORTH_DSP_VALUEHL
2a85				 
2a85			;		push hl 
2a85			 
2a85				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a85 cd 05 23			call macro_forth_dsp_pop 
2a88				endm 
# End of macro FORTH_DSP_POP
2a88			 
2a88			;		pop hl 
2a88			 
2a88 7e				ld a, (hl) 
2a89			 
2a89 6f				ld l, a 
2a8a 26 00			ld h, 0 
2a8c cd 48 20			call forth_push_numhl 
2a8f			 
2a8f				NEXTW 
2a8f c3 39 24			jp macro_next 
2a92				endm 
# End of macro NEXTW
2a92			.CAT: 
2a92			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2a92 20				db WORD_SYS_CORE+OPCODE_CAT             
2a93 bb 2a			dw .BANG            
2a95 03				db 2 + 1 
2a96 .. 00			db "C@",0              
2a99				endm 
# End of macro CWHEAD
2a99			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2a99				if DEBUG_FORTH_WORDS_KEY 
2a99					DMARK "CAA" 
2a99 f5				push af  
2a9a 3a ae 2a			ld a, (.dmark)  
2a9d 32 a0 fd			ld (debug_mark),a  
2aa0 3a af 2a			ld a, (.dmark+1)  
2aa3 32 a1 fd			ld (debug_mark+1),a  
2aa6 3a b0 2a			ld a, (.dmark+2)  
2aa9 32 a2 fd			ld (debug_mark+2),a  
2aac 18 03			jr .pastdmark  
2aae ..			.dmark: db "CAA"  
2ab1 f1			.pastdmark: pop af  
2ab2			endm  
# End of macro DMARK
2ab2					CALLMONITOR 
2ab2 cd aa fd			call debug_vector  
2ab5				endm  
# End of macro CALLMONITOR
2ab5				endif 
2ab5 c3 82 2a			jp .getbyteat 
2ab8				NEXTW 
2ab8 c3 39 24			jp macro_next 
2abb				endm 
# End of macro NEXTW
2abb			.BANG: 
2abb			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2abb 21				db WORD_SYS_CORE+OPCODE_BANG             
2abc f1 2a			dw .CBANG            
2abe 02				db 1 + 1 
2abf .. 00			db "!",0              
2ac1				endm 
# End of macro CWHEAD
2ac1			; | ! ( x w -- ) Store x at address w      | DONE 
2ac1				if DEBUG_FORTH_WORDS_KEY 
2ac1					DMARK "BNG" 
2ac1 f5				push af  
2ac2 3a d6 2a			ld a, (.dmark)  
2ac5 32 a0 fd			ld (debug_mark),a  
2ac8 3a d7 2a			ld a, (.dmark+1)  
2acb 32 a1 fd			ld (debug_mark+1),a  
2ace 3a d8 2a			ld a, (.dmark+2)  
2ad1 32 a2 fd			ld (debug_mark+2),a  
2ad4 18 03			jr .pastdmark  
2ad6 ..			.dmark: db "BNG"  
2ad9 f1			.pastdmark: pop af  
2ada			endm  
# End of macro DMARK
2ada					CALLMONITOR 
2ada cd aa fd			call debug_vector  
2add				endm  
# End of macro CALLMONITOR
2add				endif 
2add			 
2add			.storebyteat:		 
2add				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2add cd 4d 22			call macro_dsp_valuehl 
2ae0				endm 
# End of macro FORTH_DSP_VALUEHL
2ae0				 
2ae0 e5				push hl 
2ae1			 
2ae1				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ae1 cd 05 23			call macro_forth_dsp_pop 
2ae4				endm 
# End of macro FORTH_DSP_POP
2ae4			 
2ae4				; get byte to poke 
2ae4			 
2ae4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ae4 cd 4d 22			call macro_dsp_valuehl 
2ae7				endm 
# End of macro FORTH_DSP_VALUEHL
2ae7 e5				push hl 
2ae8			 
2ae8			 
2ae8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ae8 cd 05 23			call macro_forth_dsp_pop 
2aeb				endm 
# End of macro FORTH_DSP_POP
2aeb			 
2aeb			 
2aeb d1				pop de 
2aec e1				pop hl 
2aed			 
2aed 73				ld (hl),e 
2aee			 
2aee			 
2aee				NEXTW 
2aee c3 39 24			jp macro_next 
2af1				endm 
# End of macro NEXTW
2af1			.CBANG: 
2af1			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2af1 22				db WORD_SYS_CORE+OPCODE_CBANG             
2af2 1a 2b			dw .SCALL            
2af4 03				db 2 + 1 
2af5 .. 00			db "C!",0              
2af8				endm 
# End of macro CWHEAD
2af8			; | C!  ( x w -- ) Store x at address w  | DONE 
2af8				if DEBUG_FORTH_WORDS_KEY 
2af8					DMARK "CBA" 
2af8 f5				push af  
2af9 3a 0d 2b			ld a, (.dmark)  
2afc 32 a0 fd			ld (debug_mark),a  
2aff 3a 0e 2b			ld a, (.dmark+1)  
2b02 32 a1 fd			ld (debug_mark+1),a  
2b05 3a 0f 2b			ld a, (.dmark+2)  
2b08 32 a2 fd			ld (debug_mark+2),a  
2b0b 18 03			jr .pastdmark  
2b0d ..			.dmark: db "CBA"  
2b10 f1			.pastdmark: pop af  
2b11			endm  
# End of macro DMARK
2b11					CALLMONITOR 
2b11 cd aa fd			call debug_vector  
2b14				endm  
# End of macro CALLMONITOR
2b14				endif 
2b14 c3 dd 2a			jp .storebyteat 
2b17				NEXTW 
2b17 c3 39 24			jp macro_next 
2b1a				endm 
# End of macro NEXTW
2b1a			.SCALL: 
2b1a			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2b1a 23				db WORD_SYS_CORE+OPCODE_SCALL             
2b1b 4e 2b			dw .DEPTH            
2b1d 05				db 4 + 1 
2b1e .. 00			db "CALL",0              
2b23				endm 
# End of macro CWHEAD
2b23			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2b23				if DEBUG_FORTH_WORDS_KEY 
2b23					DMARK "CLL" 
2b23 f5				push af  
2b24 3a 38 2b			ld a, (.dmark)  
2b27 32 a0 fd			ld (debug_mark),a  
2b2a 3a 39 2b			ld a, (.dmark+1)  
2b2d 32 a1 fd			ld (debug_mark+1),a  
2b30 3a 3a 2b			ld a, (.dmark+2)  
2b33 32 a2 fd			ld (debug_mark+2),a  
2b36 18 03			jr .pastdmark  
2b38 ..			.dmark: db "CLL"  
2b3b f1			.pastdmark: pop af  
2b3c			endm  
# End of macro DMARK
2b3c					CALLMONITOR 
2b3c cd aa fd			call debug_vector  
2b3f				endm  
# End of macro CALLMONITOR
2b3f				endif 
2b3f			 
2b3f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b3f cd 4d 22			call macro_dsp_valuehl 
2b42				endm 
# End of macro FORTH_DSP_VALUEHL
2b42			 
2b42			;		push hl 
2b42			 
2b42				; destroy value TOS 
2b42			 
2b42				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b42 cd 05 23			call macro_forth_dsp_pop 
2b45				endm 
# End of macro FORTH_DSP_POP
2b45			 
2b45					 
2b45			;		pop hl 
2b45			 
2b45				; how to do a call with hl???? save SP? 
2b45 cd dd 23			call forth_call_hl 
2b48			 
2b48			 
2b48				; TODO push value back onto stack for another op etc 
2b48			 
2b48 cd 48 20			call forth_push_numhl 
2b4b				NEXTW 
2b4b c3 39 24			jp macro_next 
2b4e				endm 
# End of macro NEXTW
2b4e			.DEPTH: 
2b4e			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2b4e 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2b4f 8b 2b			dw .OVER            
2b51 06				db 5 + 1 
2b52 .. 00			db "DEPTH",0              
2b58				endm 
# End of macro CWHEAD
2b58			; | DEPTH ( -- u ) Push count of stack | DONE 
2b58				; take current TOS and remove from base value div by two to get count 
2b58				if DEBUG_FORTH_WORDS_KEY 
2b58					DMARK "DEP" 
2b58 f5				push af  
2b59 3a 6d 2b			ld a, (.dmark)  
2b5c 32 a0 fd			ld (debug_mark),a  
2b5f 3a 6e 2b			ld a, (.dmark+1)  
2b62 32 a1 fd			ld (debug_mark+1),a  
2b65 3a 6f 2b			ld a, (.dmark+2)  
2b68 32 a2 fd			ld (debug_mark+2),a  
2b6b 18 03			jr .pastdmark  
2b6d ..			.dmark: db "DEP"  
2b70 f1			.pastdmark: pop af  
2b71			endm  
# End of macro DMARK
2b71					CALLMONITOR 
2b71 cd aa fd			call debug_vector  
2b74				endm  
# End of macro CALLMONITOR
2b74				endif 
2b74			 
2b74			 
2b74 2a 23 f9		ld hl, (cli_data_sp) 
2b77 11 5d f6		ld de, cli_data_stack 
2b7a ed 52		sbc hl,de 
2b7c			 
2b7c			; div by size of stack item 
2b7c			 
2b7c 5d			ld e,l 
2b7d 0e 03		ld c, 3 
2b7f cd 6e 0f		call Div8 
2b82			 
2b82 6f			ld l,a 
2b83 26 00		ld h,0 
2b85			 
2b85			;srl h 
2b85			;rr l 
2b85			 
2b85 cd 48 20			call forth_push_numhl 
2b88				NEXTW 
2b88 c3 39 24			jp macro_next 
2b8b				endm 
# End of macro NEXTW
2b8b			.OVER: 
2b8b			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2b8b 42				db WORD_SYS_CORE+46             
2b8c d2 2b			dw .PAUSE            
2b8e 05				db 4 + 1 
2b8f .. 00			db "OVER",0              
2b94				endm 
# End of macro CWHEAD
2b94			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | TOFIX 
2b94				if DEBUG_FORTH_WORDS_KEY 
2b94					DMARK "OVR" 
2b94 f5				push af  
2b95 3a a9 2b			ld a, (.dmark)  
2b98 32 a0 fd			ld (debug_mark),a  
2b9b 3a aa 2b			ld a, (.dmark+1)  
2b9e 32 a1 fd			ld (debug_mark+1),a  
2ba1 3a ab 2b			ld a, (.dmark+2)  
2ba4 32 a2 fd			ld (debug_mark+2),a  
2ba7 18 03			jr .pastdmark  
2ba9 ..			.dmark: db "OVR"  
2bac f1			.pastdmark: pop af  
2bad			endm  
# End of macro DMARK
2bad					CALLMONITOR 
2bad cd aa fd			call debug_vector  
2bb0				endm  
# End of macro CALLMONITOR
2bb0				endif 
2bb0			 
2bb0			; TODO Use os stack swap memory 
2bb0			 
2bb0				; work out what type we are looking at 
2bb0			 
2bb0				FORTH_DSP_PTR 1 
2bb0 2a 23 f9			ld hl,(cli_data_sp) 
2bb3 11 03 00			ld de, 1 * 3 
2bb6 ed 52			sbc hl, de 
2bb8				endm 
# End of macro FORTH_DSP_PTR
2bb8			 
2bb8 7e				ld a, (hl) 
2bb9				 
2bb9 f5				push af 
2bba				; whatever the type lets get the pointer or word 
2bba 23				inc hl 
2bbb			;; 
2bbb			 
2bbb				; type check now to decide on how to push  
2bbb			 
2bbb cd bb 23			call loadwordinhl 
2bbe f1				pop af 
2bbf fe 01			cp DS_TYPE_STR 
2bc1 28 06			jr z, .ovstr 
2bc3			 
2bc3				; we have a numeric so load the word and push 
2bc3			;	ld e, (hl) 
2bc3			;	inc hl 
2bc3			;	ld d, (hl) 
2bc3			;	ex de, hl 
2bc3 cd 48 20			call forth_push_numhl 
2bc6				NEXTW 
2bc6 c3 39 24			jp macro_next 
2bc9				endm 
# End of macro NEXTW
2bc9			 
2bc9			.ovstr: 
2bc9				; ok, a string so get the pointer and push as a string 
2bc9			 
2bc9			;	call loadwordinhl 
2bc9 cd b6 20			call forth_push_str 
2bcc				NEXTW 
2bcc c3 39 24			jp macro_next 
2bcf				endm 
# End of macro NEXTW
2bcf			 
2bcf			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bcf			;	push hl    ; n2 
2bcf			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bcf			; 
2bcf			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bcf			;	push hl    ; n1 
2bcf			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bcf			; 
2bcf			;	pop de     ; n1 
2bcf			;	pop hl     ; n2 
2bcf			; 
2bcf			;	push de 
2bcf			;	push hl 
2bcf			;	push de 
2bcf			 
2bcf				; push back  
2bcf			 
2bcf			;	pop hl 
2bcf			;	call forth_push_numhl 
2bcf			;	pop hl 
2bcf			;	call forth_push_numhl 
2bcf			;	pop hl 
2bcf			;	call forth_push_numhl 
2bcf				NEXTW 
2bcf c3 39 24			jp macro_next 
2bd2				endm 
# End of macro NEXTW
2bd2			 
2bd2			.PAUSE: 
2bd2			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2bd2 43				db WORD_SYS_CORE+47             
2bd3 07 2c			dw .PAUSES            
2bd5 08				db 7 + 1 
2bd6 .. 00			db "PAUSEMS",0              
2bde				endm 
# End of macro CWHEAD
2bde			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2bde				if DEBUG_FORTH_WORDS_KEY 
2bde					DMARK "PMS" 
2bde f5				push af  
2bdf 3a f3 2b			ld a, (.dmark)  
2be2 32 a0 fd			ld (debug_mark),a  
2be5 3a f4 2b			ld a, (.dmark+1)  
2be8 32 a1 fd			ld (debug_mark+1),a  
2beb 3a f5 2b			ld a, (.dmark+2)  
2bee 32 a2 fd			ld (debug_mark+2),a  
2bf1 18 03			jr .pastdmark  
2bf3 ..			.dmark: db "PMS"  
2bf6 f1			.pastdmark: pop af  
2bf7			endm  
# End of macro DMARK
2bf7					CALLMONITOR 
2bf7 cd aa fd			call debug_vector  
2bfa				endm  
# End of macro CALLMONITOR
2bfa				endif 
2bfa				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bfa cd 4d 22			call macro_dsp_valuehl 
2bfd				endm 
# End of macro FORTH_DSP_VALUEHL
2bfd			;		push hl    ; n2 
2bfd				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bfd cd 05 23			call macro_forth_dsp_pop 
2c00				endm 
# End of macro FORTH_DSP_POP
2c00			;		pop hl 
2c00			 
2c00 7d				ld a, l 
2c01 cd d2 0c			call aDelayInMS 
2c04			       NEXTW 
2c04 c3 39 24			jp macro_next 
2c07				endm 
# End of macro NEXTW
2c07			.PAUSES:  
2c07			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2c07 44				db WORD_SYS_CORE+48             
2c08 76 2c			dw .ROT            
2c0a 06				db 5 + 1 
2c0b .. 00			db "PAUSE",0              
2c11				endm 
# End of macro CWHEAD
2c11			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2c11				if DEBUG_FORTH_WORDS_KEY 
2c11					DMARK "PAU" 
2c11 f5				push af  
2c12 3a 26 2c			ld a, (.dmark)  
2c15 32 a0 fd			ld (debug_mark),a  
2c18 3a 27 2c			ld a, (.dmark+1)  
2c1b 32 a1 fd			ld (debug_mark+1),a  
2c1e 3a 28 2c			ld a, (.dmark+2)  
2c21 32 a2 fd			ld (debug_mark+2),a  
2c24 18 03			jr .pastdmark  
2c26 ..			.dmark: db "PAU"  
2c29 f1			.pastdmark: pop af  
2c2a			endm  
# End of macro DMARK
2c2a					CALLMONITOR 
2c2a cd aa fd			call debug_vector  
2c2d				endm  
# End of macro CALLMONITOR
2c2d				endif 
2c2d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c2d cd 4d 22			call macro_dsp_valuehl 
2c30				endm 
# End of macro FORTH_DSP_VALUEHL
2c30			;		push hl    ; n2 
2c30				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c30 cd 05 23			call macro_forth_dsp_pop 
2c33				endm 
# End of macro FORTH_DSP_POP
2c33			;		pop hl 
2c33 45				ld b, l 
2c34				if DEBUG_FORTH_WORDS 
2c34					DMARK "PAU" 
2c34 f5				push af  
2c35 3a 49 2c			ld a, (.dmark)  
2c38 32 a0 fd			ld (debug_mark),a  
2c3b 3a 4a 2c			ld a, (.dmark+1)  
2c3e 32 a1 fd			ld (debug_mark+1),a  
2c41 3a 4b 2c			ld a, (.dmark+2)  
2c44 32 a2 fd			ld (debug_mark+2),a  
2c47 18 03			jr .pastdmark  
2c49 ..			.dmark: db "PAU"  
2c4c f1			.pastdmark: pop af  
2c4d			endm  
# End of macro DMARK
2c4d					CALLMONITOR 
2c4d cd aa fd			call debug_vector  
2c50				endm  
# End of macro CALLMONITOR
2c50				endif 
2c50 c5			.pauses1:	push bc 
2c51 cd ed 0c			call delay1s 
2c54 c1				pop bc 
2c55				if DEBUG_FORTH_WORDS 
2c55					DMARK "PA1" 
2c55 f5				push af  
2c56 3a 6a 2c			ld a, (.dmark)  
2c59 32 a0 fd			ld (debug_mark),a  
2c5c 3a 6b 2c			ld a, (.dmark+1)  
2c5f 32 a1 fd			ld (debug_mark+1),a  
2c62 3a 6c 2c			ld a, (.dmark+2)  
2c65 32 a2 fd			ld (debug_mark+2),a  
2c68 18 03			jr .pastdmark  
2c6a ..			.dmark: db "PA1"  
2c6d f1			.pastdmark: pop af  
2c6e			endm  
# End of macro DMARK
2c6e					CALLMONITOR 
2c6e cd aa fd			call debug_vector  
2c71				endm  
# End of macro CALLMONITOR
2c71				endif 
2c71 10 dd			djnz .pauses1 
2c73			 
2c73			       NEXTW 
2c73 c3 39 24			jp macro_next 
2c76				endm 
# End of macro NEXTW
2c76			.ROT: 
2c76			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2c76 45				db WORD_SYS_CORE+49             
2c77 df 2c			dw .UWORDS            
2c79 04				db 3 + 1 
2c7a .. 00			db "ROT",0              
2c7e				endm 
# End of macro CWHEAD
2c7e			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | TOFIX 
2c7e				if DEBUG_FORTH_WORDS_KEY 
2c7e					DMARK "ROT" 
2c7e f5				push af  
2c7f 3a 93 2c			ld a, (.dmark)  
2c82 32 a0 fd			ld (debug_mark),a  
2c85 3a 94 2c			ld a, (.dmark+1)  
2c88 32 a1 fd			ld (debug_mark+1),a  
2c8b 3a 95 2c			ld a, (.dmark+2)  
2c8e 32 a2 fd			ld (debug_mark+2),a  
2c91 18 03			jr .pastdmark  
2c93 ..			.dmark: db "ROT"  
2c96 f1			.pastdmark: pop af  
2c97			endm  
# End of macro DMARK
2c97					CALLMONITOR 
2c97 cd aa fd			call debug_vector  
2c9a				endm  
# End of macro CALLMONITOR
2c9a				endif 
2c9a			 
2c9a			; DONE Use os stack swap memory 
2c9a			 
2c9a				FORTH_DSP_PTR 0     ; u3 
2c9a 2a 23 f9			ld hl,(cli_data_sp) 
2c9d 11 00 00			ld de, 0 * 3 
2ca0 ed 52			sbc hl, de 
2ca2				endm 
# End of macro FORTH_DSP_PTR
2ca2 cd 85 23			call hltostack1     
2ca5			  
2ca5				FORTH_DSP_PTR 1     ; u2 
2ca5 2a 23 f9			ld hl,(cli_data_sp) 
2ca8 11 03 00			ld de, 1 * 3 
2cab ed 52			sbc hl, de 
2cad				endm 
# End of macro FORTH_DSP_PTR
2cad cd 8b 23			call hltostack2      
2cb0			 
2cb0				FORTH_DSP_PTR 2     ; u1 
2cb0 2a 23 f9			ld hl,(cli_data_sp) 
2cb3 11 06 00			ld de, 2 * 3 
2cb6 ed 52			sbc hl, de 
2cb8				endm 
# End of macro FORTH_DSP_PTR
2cb8 cd 91 23			call hltostack3 
2cbb			 
2cbb			 
2cbb				FORTH_DSP_PTR 0     ;  
2cbb 2a 23 f9			ld hl,(cli_data_sp) 
2cbe 11 00 00			ld de, 0 * 3 
2cc1 ed 52			sbc hl, de 
2cc3				endm 
# End of macro FORTH_DSP_PTR
2cc3 cd a9 23			call hlfromstack3 
2cc6			 
2cc6				FORTH_DSP_PTR 1     ; TOS 
2cc6 2a 23 f9			ld hl,(cli_data_sp) 
2cc9 11 03 00			ld de, 1 * 3 
2ccc ed 52			sbc hl, de 
2cce				endm 
# End of macro FORTH_DSP_PTR
2cce cd 9d 23			call hlfromstack1 
2cd1			 
2cd1				FORTH_DSP_PTR 2     ; TOS 
2cd1 2a 23 f9			ld hl,(cli_data_sp) 
2cd4 11 06 00			ld de, 2 * 3 
2cd7 ed 52			sbc hl, de 
2cd9				endm 
# End of macro FORTH_DSP_PTR
2cd9 cd a3 23			call hlfromstack2 
2cdc			 
2cdc			 
2cdc			;	FORTH_DSP_VALUEHL 
2cdc			;	push hl    ; u3  
2cdc			; 
2cdc			;	FORTH_DSP_POP 
2cdc			; 
2cdc			;	FORTH_DSP_VALUEHL 
2cdc			;	push hl     ; u2 
2cdc			; 
2cdc			;	FORTH_DSP_POP 
2cdc			; 
2cdc			;	FORTH_DSP_VALUEHL 
2cdc			;	push hl     ; u1 
2cdc			; 
2cdc			;	FORTH_DSP_POP 
2cdc			; 
2cdc			;	pop bc      ; u1 
2cdc			;	pop hl      ; u2 
2cdc			;	pop de      ; u3 
2cdc			; 
2cdc			; 
2cdc			;	push bc 
2cdc			;	push de 
2cdc			;	push hl 
2cdc			; 
2cdc			; 
2cdc			;	pop hl 
2cdc			;	call forth_push_numhl 
2cdc			; 
2cdc			;	pop hl 
2cdc			;	call forth_push_numhl 
2cdc			; 
2cdc			;	pop hl 
2cdc			;	call forth_push_numhl 
2cdc				 
2cdc			 
2cdc			 
2cdc			 
2cdc			 
2cdc			 
2cdc			       NEXTW 
2cdc c3 39 24			jp macro_next 
2cdf				endm 
# End of macro NEXTW
2cdf			 
2cdf			.UWORDS: 
2cdf			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2cdf 50				db WORD_SYS_CORE+60             
2ce0 a1 2d			dw .BP            
2ce2 07				db 6 + 1 
2ce3 .. 00			db "UWORDS",0              
2cea				endm 
# End of macro CWHEAD
2cea			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2cea			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2cea			; | | Following the count are the individual words. 
2cea			; | | 
2cea			; | | e.g. UWORDS 
2cea			; | | BOX DIRLIST 2 
2cea			; | |  
2cea			; | | Can be used to save the words to storage via: 
2cea			; | | UWORDS $01 DO $01 APPEND LOOP 
2cea			if DEBUG_FORTH_WORDS_KEY 
2cea				DMARK "UWR" 
2cea f5				push af  
2ceb 3a ff 2c			ld a, (.dmark)  
2cee 32 a0 fd			ld (debug_mark),a  
2cf1 3a 00 2d			ld a, (.dmark+1)  
2cf4 32 a1 fd			ld (debug_mark+1),a  
2cf7 3a 01 2d			ld a, (.dmark+2)  
2cfa 32 a2 fd			ld (debug_mark+2),a  
2cfd 18 03			jr .pastdmark  
2cff ..			.dmark: db "UWR"  
2d02 f1			.pastdmark: pop af  
2d03			endm  
# End of macro DMARK
2d03				CALLMONITOR 
2d03 cd aa fd			call debug_vector  
2d06				endm  
# End of macro CALLMONITOR
2d06			endif 
2d06 21 00 80			ld hl, baseram 
2d09				;ld hl, baseusermem 
2d09 01 00 00			ld bc, 0    ; start a counter 
2d0c			 
2d0c			; skip dict stub 
2d0c			 
2d0c cd 76 25			call forth_tok_next 
2d0f			 
2d0f			 
2d0f			; while we have words to look for 
2d0f			 
2d0f 7e			.douscan:	ld a, (hl)      
2d10			if DEBUG_FORTH_WORDS 
2d10				DMARK "UWs" 
2d10 f5				push af  
2d11 3a 25 2d			ld a, (.dmark)  
2d14 32 a0 fd			ld (debug_mark),a  
2d17 3a 26 2d			ld a, (.dmark+1)  
2d1a 32 a1 fd			ld (debug_mark+1),a  
2d1d 3a 27 2d			ld a, (.dmark+2)  
2d20 32 a2 fd			ld (debug_mark+2),a  
2d23 18 03			jr .pastdmark  
2d25 ..			.dmark: db "UWs"  
2d28 f1			.pastdmark: pop af  
2d29			endm  
# End of macro DMARK
2d29				CALLMONITOR 
2d29 cd aa fd			call debug_vector  
2d2c				endm  
# End of macro CALLMONITOR
2d2c			endif 
2d2c fe 00			cp WORD_SYS_END 
2d2e 28 4d			jr z, .udone 
2d30 fe 01			cp WORD_SYS_UWORD 
2d32 20 44			jr nz, .nuword 
2d34			 
2d34			if DEBUG_FORTH_WORDS 
2d34				DMARK "UWu" 
2d34 f5				push af  
2d35 3a 49 2d			ld a, (.dmark)  
2d38 32 a0 fd			ld (debug_mark),a  
2d3b 3a 4a 2d			ld a, (.dmark+1)  
2d3e 32 a1 fd			ld (debug_mark+1),a  
2d41 3a 4b 2d			ld a, (.dmark+2)  
2d44 32 a2 fd			ld (debug_mark+2),a  
2d47 18 03			jr .pastdmark  
2d49 ..			.dmark: db "UWu"  
2d4c f1			.pastdmark: pop af  
2d4d			endm  
# End of macro DMARK
2d4d				CALLMONITOR 
2d4d cd aa fd			call debug_vector  
2d50				endm  
# End of macro CALLMONITOR
2d50			endif 
2d50				; we have a uword so push its name to the stack 
2d50			 
2d50 e5				push hl  ; save so we can move to next dict block 
2d51			 
2d51				; skip opcode 
2d51 23				inc hl  
2d52				; skip next ptr 
2d52 23				inc hl  
2d53 23				inc hl 
2d54				; skip len 
2d54 23				inc hl 
2d55			if DEBUG_FORTH_WORDS 
2d55				DMARK "UWt" 
2d55 f5				push af  
2d56 3a 6a 2d			ld a, (.dmark)  
2d59 32 a0 fd			ld (debug_mark),a  
2d5c 3a 6b 2d			ld a, (.dmark+1)  
2d5f 32 a1 fd			ld (debug_mark+1),a  
2d62 3a 6c 2d			ld a, (.dmark+2)  
2d65 32 a2 fd			ld (debug_mark+2),a  
2d68 18 03			jr .pastdmark  
2d6a ..			.dmark: db "UWt"  
2d6d f1			.pastdmark: pop af  
2d6e			endm  
# End of macro DMARK
2d6e				CALLMONITOR 
2d6e cd aa fd			call debug_vector  
2d71				endm  
# End of macro CALLMONITOR
2d71			endif 
2d71 03				inc bc 
2d72			 
2d72 c5				push bc 
2d73 cd b6 20			call forth_push_str 
2d76 c1				pop bc 
2d77			 
2d77 e1				pop hl 	 
2d78			 
2d78 cd 76 25		.nuword:	call forth_tok_next 
2d7b 18 92			jr .douscan  
2d7d			 
2d7d			.udone:		 ; push count of uwords found 
2d7d c5				push bc 
2d7e e1				pop hl 
2d7f			 
2d7f			if DEBUG_FORTH_WORDS 
2d7f				DMARK "UWc" 
2d7f f5				push af  
2d80 3a 94 2d			ld a, (.dmark)  
2d83 32 a0 fd			ld (debug_mark),a  
2d86 3a 95 2d			ld a, (.dmark+1)  
2d89 32 a1 fd			ld (debug_mark+1),a  
2d8c 3a 96 2d			ld a, (.dmark+2)  
2d8f 32 a2 fd			ld (debug_mark+2),a  
2d92 18 03			jr .pastdmark  
2d94 ..			.dmark: db "UWc"  
2d97 f1			.pastdmark: pop af  
2d98			endm  
# End of macro DMARK
2d98				CALLMONITOR 
2d98 cd aa fd			call debug_vector  
2d9b				endm  
# End of macro CALLMONITOR
2d9b			endif 
2d9b cd 48 20			call forth_push_numhl 
2d9e			 
2d9e			 
2d9e			       NEXTW 
2d9e c3 39 24			jp macro_next 
2da1				endm 
# End of macro NEXTW
2da1			 
2da1			.BP: 
2da1			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2da1 54				db WORD_SYS_CORE+64             
2da2 db 2d			dw .MONITOR            
2da4 03				db 2 + 1 
2da5 .. 00			db "BP",0              
2da8				endm 
# End of macro CWHEAD
2da8			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2da8			; | | $00 Will enable the break points within specific code paths 
2da8			; | | $01 Will disable break points 
2da8			; | |  
2da8			; | | By default break points are off. Either the above can be used to enable them 
2da8			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2da8			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2da8			; | | can disable break points. Exiting will then continue boot process. 
2da8				; get byte count 
2da8				if DEBUG_FORTH_WORDS_KEY 
2da8					DMARK "BP." 
2da8 f5				push af  
2da9 3a bd 2d			ld a, (.dmark)  
2dac 32 a0 fd			ld (debug_mark),a  
2daf 3a be 2d			ld a, (.dmark+1)  
2db2 32 a1 fd			ld (debug_mark+1),a  
2db5 3a bf 2d			ld a, (.dmark+2)  
2db8 32 a2 fd			ld (debug_mark+2),a  
2dbb 18 03			jr .pastdmark  
2dbd ..			.dmark: db "BP."  
2dc0 f1			.pastdmark: pop af  
2dc1			endm  
# End of macro DMARK
2dc1					CALLMONITOR 
2dc1 cd aa fd			call debug_vector  
2dc4				endm  
# End of macro CALLMONITOR
2dc4				endif 
2dc4			 
2dc4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2dc4 cd 4d 22			call macro_dsp_valuehl 
2dc7				endm 
# End of macro FORTH_DSP_VALUEHL
2dc7			 
2dc7			;		push hl 
2dc7			 
2dc7				; destroy value TOS 
2dc7			 
2dc7				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2dc7 cd 05 23			call macro_forth_dsp_pop 
2dca				endm 
# End of macro FORTH_DSP_POP
2dca			 
2dca			;		pop hl 
2dca			 
2dca 3e 00			ld a,0 
2dcc bd				cp l 
2dcd 28 06			jr z, .bpset 
2dcf			;		ld a, '*' 
2dcf cd 55 19			call bp_off 
2dd2				NEXTW 
2dd2 c3 39 24			jp macro_next 
2dd5				endm 
# End of macro NEXTW
2dd5			 
2dd5			.bpset:	 
2dd5				;	ld (os_view_disable), a 
2dd5 cd 49 19			call bp_on 
2dd8			 
2dd8			 
2dd8				NEXTW 
2dd8 c3 39 24			jp macro_next 
2ddb				endm 
# End of macro NEXTW
2ddb			 
2ddb			 
2ddb			.MONITOR: 
2ddb			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2ddb 55				db WORD_SYS_CORE+65             
2ddc 0c 2e			dw .MALLOC            
2dde 08				db 7 + 1 
2ddf .. 00			db "MONITOR",0              
2de7				endm 
# End of macro CWHEAD
2de7			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2de7			; | | At start the current various registers will be displayed with contents. 
2de7			; | | Top right corner will show the most recent debug marker seen. 
2de7			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2de7			; | | and the return stack pointer (RSP). 
2de7			; | | Pressing: 
2de7			; | |    1 - Initial screen 
2de7			; | |    2 - Display a data dump of HL 
2de7			; | |    3 - Display a data dump of DE 
2de7			; | |    4 - Display a data dump of BC 
2de7			; | |    5 - Display a data dump of HL 
2de7			; | |    6 - Display a data dump of DSP 
2de7			; | |    7 - Display a data dump of RSP 
2de7			; | |    8 - Display a data dump of what is at DSP 
2de7			; | |    9 - Display a data dump of what is at RSP 
2de7			; | |    0 - Exit monitor and continue running. This will also enable break points 
2de7			; | |    * - Disable break points 
2de7			; | |    # - Enter traditional monitor mode 
2de7			; | | 
2de7			; | | Monitor Mode 
2de7			; | | ------------ 
2de7			; | | A prompt of '>' will be shown for various commands: 
2de7			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2de7			; | |    C - Continue display a data dump from the last set address 
2de7			; | |    M xxxx - Set start of memory edit at address xx 
2de7			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2de7			; | |    G xxxx - Exec code at specific address 
2de7			; | |    Q - Return to previous 
2de7				if DEBUG_FORTH_WORDS_KEY 
2de7					DMARK "MON" 
2de7 f5				push af  
2de8 3a fc 2d			ld a, (.dmark)  
2deb 32 a0 fd			ld (debug_mark),a  
2dee 3a fd 2d			ld a, (.dmark+1)  
2df1 32 a1 fd			ld (debug_mark+1),a  
2df4 3a fe 2d			ld a, (.dmark+2)  
2df7 32 a2 fd			ld (debug_mark+2),a  
2dfa 18 03			jr .pastdmark  
2dfc ..			.dmark: db "MON"  
2dff f1			.pastdmark: pop af  
2e00			endm  
# End of macro DMARK
2e00					CALLMONITOR 
2e00 cd aa fd			call debug_vector  
2e03				endm  
# End of macro CALLMONITOR
2e03				endif 
2e03			;		ld a, 0 
2e03			;		ld (os_view_disable), a 
2e03 cd 49 19			call bp_on 
2e06			 
2e06				CALLMONITOR 
2e06 cd aa fd			call debug_vector  
2e09				endm  
# End of macro CALLMONITOR
2e09			 
2e09			;	call monitor 
2e09			 
2e09				NEXTW 
2e09 c3 39 24			jp macro_next 
2e0c				endm 
# End of macro NEXTW
2e0c			 
2e0c			 
2e0c			.MALLOC: 
2e0c			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2e0c 56				db WORD_SYS_CORE+66             
2e0d 35 2e			dw .MALLOC2            
2e0f 06				db 5 + 1 
2e10 .. 00			db "ALLOT",0              
2e16				endm 
# End of macro CWHEAD
2e16			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2e16				if DEBUG_FORTH_WORDS_KEY 
2e16					DMARK "ALL" 
2e16 f5				push af  
2e17 3a 2b 2e			ld a, (.dmark)  
2e1a 32 a0 fd			ld (debug_mark),a  
2e1d 3a 2c 2e			ld a, (.dmark+1)  
2e20 32 a1 fd			ld (debug_mark+1),a  
2e23 3a 2d 2e			ld a, (.dmark+2)  
2e26 32 a2 fd			ld (debug_mark+2),a  
2e29 18 03			jr .pastdmark  
2e2b ..			.dmark: db "ALL"  
2e2e f1			.pastdmark: pop af  
2e2f			endm  
# End of macro DMARK
2e2f					CALLMONITOR 
2e2f cd aa fd			call debug_vector  
2e32				endm  
# End of macro CALLMONITOR
2e32				endif 
2e32 c3 5c 2e			jp .mallocc 
2e35			.MALLOC2: 
2e35			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2e35 56				db WORD_SYS_CORE+66             
2e36 73 2e			dw .FREE            
2e38 07				db 6 + 1 
2e39 .. 00			db "MALLOC",0              
2e40				endm 
# End of macro CWHEAD
2e40			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2e40				; get byte count 
2e40				if DEBUG_FORTH_WORDS_KEY 
2e40					DMARK "MAL" 
2e40 f5				push af  
2e41 3a 55 2e			ld a, (.dmark)  
2e44 32 a0 fd			ld (debug_mark),a  
2e47 3a 56 2e			ld a, (.dmark+1)  
2e4a 32 a1 fd			ld (debug_mark+1),a  
2e4d 3a 57 2e			ld a, (.dmark+2)  
2e50 32 a2 fd			ld (debug_mark+2),a  
2e53 18 03			jr .pastdmark  
2e55 ..			.dmark: db "MAL"  
2e58 f1			.pastdmark: pop af  
2e59			endm  
# End of macro DMARK
2e59					CALLMONITOR 
2e59 cd aa fd			call debug_vector  
2e5c				endm  
# End of macro CALLMONITOR
2e5c				endif 
2e5c			.mallocc: 
2e5c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e5c cd 4d 22			call macro_dsp_valuehl 
2e5f				endm 
# End of macro FORTH_DSP_VALUEHL
2e5f			 
2e5f			;		push hl 
2e5f			 
2e5f				; destroy value TOS 
2e5f			 
2e5f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e5f cd 05 23			call macro_forth_dsp_pop 
2e62				endm 
# End of macro FORTH_DSP_POP
2e62			 
2e62			;		pop hl 
2e62 cd b9 13			call malloc 
2e65			if DEBUG_FORTH_MALLOC_GUARD 
2e65 f5				push af 
2e66 cd 07 10			call ishlzero 
2e69			;		ld a, l 
2e69			;		add h 
2e69			;		cp 0 
2e69 f1				pop af 
2e6a				 
2e6a cc e0 60			call z,malloc_error 
2e6d			endif 
2e6d			 
2e6d cd 48 20			call forth_push_numhl 
2e70				NEXTW 
2e70 c3 39 24			jp macro_next 
2e73				endm 
# End of macro NEXTW
2e73			 
2e73			.FREE: 
2e73			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2e73 57				db WORD_SYS_CORE+67             
2e74 a4 2e			dw .LIST            
2e76 05				db 4 + 1 
2e77 .. 00			db "FREE",0              
2e7c				endm 
# End of macro CWHEAD
2e7c			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2e7c				if DEBUG_FORTH_WORDS_KEY 
2e7c					DMARK "FRE" 
2e7c f5				push af  
2e7d 3a 91 2e			ld a, (.dmark)  
2e80 32 a0 fd			ld (debug_mark),a  
2e83 3a 92 2e			ld a, (.dmark+1)  
2e86 32 a1 fd			ld (debug_mark+1),a  
2e89 3a 93 2e			ld a, (.dmark+2)  
2e8c 32 a2 fd			ld (debug_mark+2),a  
2e8f 18 03			jr .pastdmark  
2e91 ..			.dmark: db "FRE"  
2e94 f1			.pastdmark: pop af  
2e95			endm  
# End of macro DMARK
2e95					CALLMONITOR 
2e95 cd aa fd			call debug_vector  
2e98				endm  
# End of macro CALLMONITOR
2e98				endif 
2e98				; get address 
2e98			 
2e98				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e98 cd 4d 22			call macro_dsp_valuehl 
2e9b				endm 
# End of macro FORTH_DSP_VALUEHL
2e9b			 
2e9b			;		push hl 
2e9b			 
2e9b				; destroy value TOS 
2e9b			 
2e9b				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e9b cd 05 23			call macro_forth_dsp_pop 
2e9e				endm 
# End of macro FORTH_DSP_POP
2e9e			 
2e9e			;		pop hl 
2e9e			if FORTH_ENABLE_MALLOCFREE 
2e9e cd 83 14			call free 
2ea1			endif 
2ea1				NEXTW 
2ea1 c3 39 24			jp macro_next 
2ea4				endm 
# End of macro NEXTW
2ea4			.LIST: 
2ea4			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2ea4 5c				db WORD_SYS_CORE+72             
2ea5 a0 30			dw .FORGET            
2ea7 05				db 4 + 1 
2ea8 .. 00			db "LIST",0              
2ead				endm 
# End of macro CWHEAD
2ead			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2ead			; | | The quoted word must be in upper case. 
2ead			if DEBUG_FORTH_WORDS_KEY 
2ead				DMARK "LST" 
2ead f5				push af  
2eae 3a c2 2e			ld a, (.dmark)  
2eb1 32 a0 fd			ld (debug_mark),a  
2eb4 3a c3 2e			ld a, (.dmark+1)  
2eb7 32 a1 fd			ld (debug_mark+1),a  
2eba 3a c4 2e			ld a, (.dmark+2)  
2ebd 32 a2 fd			ld (debug_mark+2),a  
2ec0 18 03			jr .pastdmark  
2ec2 ..			.dmark: db "LST"  
2ec5 f1			.pastdmark: pop af  
2ec6			endm  
# End of macro DMARK
2ec6				CALLMONITOR 
2ec6 cd aa fd			call debug_vector  
2ec9				endm  
# End of macro CALLMONITOR
2ec9			endif 
2ec9			 
2ec9				FORTH_DSP_VALUEHL 
2ec9 cd 4d 22			call macro_dsp_valuehl 
2ecc				endm 
# End of macro FORTH_DSP_VALUEHL
2ecc			 
2ecc e5				push hl 
2ecd				FORTH_DSP_POP 
2ecd cd 05 23			call macro_forth_dsp_pop 
2ed0				endm 
# End of macro FORTH_DSP_POP
2ed0 c1				pop bc 
2ed1			 
2ed1			; Start format of scratch string 
2ed1			 
2ed1 21 f6 f0			ld hl, scratch 
2ed4			 
2ed4 3e 3a			ld a, ':' 
2ed6 77				ld (hl),a 
2ed7 23				inc hl 
2ed8 3e 20			ld a, ' ' 
2eda 77				ld (hl), a 
2edb			 
2edb				; Get ptr to the word we need to look up 
2edb			 
2edb			;		FORTH_DSP_VALUEHL 
2edb				;v5 FORTH_DSP_VALUE 
2edb			; TODO type check 
2edb			;		inc hl    ; Skip type check  
2edb			;		push hl 
2edb			;		ex de, hl    ; put into DE 
2edb			 
2edb			 
2edb 21 00 80			ld hl, baseram 
2ede				;ld hl, baseusermem 
2ede			 
2ede e5			push hl   ; sacreifical push 
2edf			 
2edf			.ldouscanm: 
2edf e1			pop hl 
2ee0			.ldouscan: 
2ee0			if DEBUG_FORTH_WORDS 
2ee0				DMARK "LSs" 
2ee0 f5				push af  
2ee1 3a f5 2e			ld a, (.dmark)  
2ee4 32 a0 fd			ld (debug_mark),a  
2ee7 3a f6 2e			ld a, (.dmark+1)  
2eea 32 a1 fd			ld (debug_mark+1),a  
2eed 3a f7 2e			ld a, (.dmark+2)  
2ef0 32 a2 fd			ld (debug_mark+2),a  
2ef3 18 03			jr .pastdmark  
2ef5 ..			.dmark: db "LSs"  
2ef8 f1			.pastdmark: pop af  
2ef9			endm  
# End of macro DMARK
2ef9				CALLMONITOR 
2ef9 cd aa fd			call debug_vector  
2efc				endm  
# End of macro CALLMONITOR
2efc			endif 
2efc			; skip dict stub 
2efc cd 76 25			call forth_tok_next 
2eff			 
2eff			 
2eff			; while we have words to look for 
2eff			 
2eff 7e			ld a, (hl)      
2f00			if DEBUG_FORTH_WORDS 
2f00				DMARK "LSk" 
2f00 f5				push af  
2f01 3a 15 2f			ld a, (.dmark)  
2f04 32 a0 fd			ld (debug_mark),a  
2f07 3a 16 2f			ld a, (.dmark+1)  
2f0a 32 a1 fd			ld (debug_mark+1),a  
2f0d 3a 17 2f			ld a, (.dmark+2)  
2f10 32 a2 fd			ld (debug_mark+2),a  
2f13 18 03			jr .pastdmark  
2f15 ..			.dmark: db "LSk"  
2f18 f1			.pastdmark: pop af  
2f19			endm  
# End of macro DMARK
2f19				CALLMONITOR 
2f19 cd aa fd			call debug_vector  
2f1c				endm  
# End of macro CALLMONITOR
2f1c			endif 
2f1c				;cp WORD_SYS_END 
2f1c				;jp z, .lunotfound 
2f1c			 
2f1c					; if we hit non uwords then gone too far 
2f1c fe 01				cp WORD_SYS_UWORD 
2f1e c2 5c 30				jp nz, .lunotfound 
2f21			 
2f21				if DEBUG_FORTH_WORDS 
2f21					DMARK "LSu" 
2f21 f5				push af  
2f22 3a 36 2f			ld a, (.dmark)  
2f25 32 a0 fd			ld (debug_mark),a  
2f28 3a 37 2f			ld a, (.dmark+1)  
2f2b 32 a1 fd			ld (debug_mark+1),a  
2f2e 3a 38 2f			ld a, (.dmark+2)  
2f31 32 a2 fd			ld (debug_mark+2),a  
2f34 18 03			jr .pastdmark  
2f36 ..			.dmark: db "LSu"  
2f39 f1			.pastdmark: pop af  
2f3a			endm  
# End of macro DMARK
2f3a					CALLMONITOR 
2f3a cd aa fd			call debug_vector  
2f3d				endm  
# End of macro CALLMONITOR
2f3d				endif 
2f3d			 
2f3d					; found a uword but is it the one we want... 
2f3d			 
2f3d c5					push bc     ; uword to find is on bc 
2f3e d1					pop de 
2f3f			 
2f3f e5					push hl  ; to save the ptr 
2f40			 
2f40					; skip opcode 
2f40 23					inc hl  
2f41					; skip next ptr 
2f41 23					inc hl  
2f42 23					inc hl 
2f43					; skip len 
2f43 23					inc hl 
2f44			 
2f44				if DEBUG_FORTH_WORDS 
2f44					DMARK "LSc" 
2f44 f5				push af  
2f45 3a 59 2f			ld a, (.dmark)  
2f48 32 a0 fd			ld (debug_mark),a  
2f4b 3a 5a 2f			ld a, (.dmark+1)  
2f4e 32 a1 fd			ld (debug_mark+1),a  
2f51 3a 5b 2f			ld a, (.dmark+2)  
2f54 32 a2 fd			ld (debug_mark+2),a  
2f57 18 03			jr .pastdmark  
2f59 ..			.dmark: db "LSc"  
2f5c f1			.pastdmark: pop af  
2f5d			endm  
# End of macro DMARK
2f5d					CALLMONITOR 
2f5d cd aa fd			call debug_vector  
2f60				endm  
# End of macro CALLMONITOR
2f60				endif 
2f60			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2f60			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2f60			; Nope that has gone the other way. It needs to be exact not on first zero 
2f60			;		call strcmp 
2f60 c5					push bc 
2f61 cd 89 13				call StrictStrCmp 
2f64 c1					pop bc 
2f65 c2 df 2e				jp nz, .ldouscanm 
2f68				 
2f68			 
2f68			 
2f68					; we have a uword so push its name to the stack 
2f68			 
2f68			;	   	push hl  ; save so we can move to next dict block 
2f68 e1			pop hl 
2f69			 
2f69				if DEBUG_FORTH_WORDS 
2f69					DMARK "LSm" 
2f69 f5				push af  
2f6a 3a 7e 2f			ld a, (.dmark)  
2f6d 32 a0 fd			ld (debug_mark),a  
2f70 3a 7f 2f			ld a, (.dmark+1)  
2f73 32 a1 fd			ld (debug_mark+1),a  
2f76 3a 80 2f			ld a, (.dmark+2)  
2f79 32 a2 fd			ld (debug_mark+2),a  
2f7c 18 03			jr .pastdmark  
2f7e ..			.dmark: db "LSm"  
2f81 f1			.pastdmark: pop af  
2f82			endm  
# End of macro DMARK
2f82					CALLMONITOR 
2f82 cd aa fd			call debug_vector  
2f85				endm  
# End of macro CALLMONITOR
2f85				endif 
2f85			 
2f85					; skip opcode 
2f85 23					inc hl  
2f86					; skip next ptr 
2f86 23					inc hl  
2f87 23					inc hl 
2f88					; skip len 
2f88 7e					ld a, (hl)   ; save length to add 
2f89				if DEBUG_FORTH_WORDS 
2f89					DMARK "LS2" 
2f89 f5				push af  
2f8a 3a 9e 2f			ld a, (.dmark)  
2f8d 32 a0 fd			ld (debug_mark),a  
2f90 3a 9f 2f			ld a, (.dmark+1)  
2f93 32 a1 fd			ld (debug_mark+1),a  
2f96 3a a0 2f			ld a, (.dmark+2)  
2f99 32 a2 fd			ld (debug_mark+2),a  
2f9c 18 03			jr .pastdmark  
2f9e ..			.dmark: db "LS2"  
2fa1 f1			.pastdmark: pop af  
2fa2			endm  
# End of macro DMARK
2fa2					CALLMONITOR 
2fa2 cd aa fd			call debug_vector  
2fa5				endm  
# End of macro CALLMONITOR
2fa5				endif 
2fa5			 
2fa5					; save this location 
2fa5				 
2fa5 e5					push hl 
2fa6			 
2fa6 23					inc hl 
2fa7 11 f8 f0				ld de, scratch+2 
2faa 4f					ld c, a 
2fab 06 00				ld b, 0 
2fad			 
2fad				if DEBUG_FORTH_WORDS 
2fad					DMARK "LSn" 
2fad f5				push af  
2fae 3a c2 2f			ld a, (.dmark)  
2fb1 32 a0 fd			ld (debug_mark),a  
2fb4 3a c3 2f			ld a, (.dmark+1)  
2fb7 32 a1 fd			ld (debug_mark+1),a  
2fba 3a c4 2f			ld a, (.dmark+2)  
2fbd 32 a2 fd			ld (debug_mark+2),a  
2fc0 18 03			jr .pastdmark  
2fc2 ..			.dmark: db "LSn"  
2fc5 f1			.pastdmark: pop af  
2fc6			endm  
# End of macro DMARK
2fc6					CALLMONITOR 
2fc6 cd aa fd			call debug_vector  
2fc9				endm  
# End of macro CALLMONITOR
2fc9				endif 
2fc9			 
2fc9					; copy uword name to scratch 
2fc9			 
2fc9			;		ldir 
2fc9			.licplw:	; copy uword name to scratch converting to lower case as we go 
2fc9 ed a0				ldi 
2fcb 1b					dec de 
2fcc 1a					ld a, (de) 
2fcd cd 5c 12				call to_lower 
2fd0 12					ld (de),a 
2fd1 13					inc de 
2fd2 3e 00				ld a, 0 
2fd4 b9					cp c 
2fd5 20 f2				jr nz, .licplw 
2fd7			 
2fd7			 
2fd7			 
2fd7 1b					dec de 
2fd8 3e 20				ld a, ' '    ; change null to space 
2fda 12					ld (de), a 
2fdb			 
2fdb 13					inc de 
2fdc			 
2fdc d5					push de 
2fdd c1					pop bc     ; move scratch pointer to end of word name and save it 
2fde			 
2fde e1					pop hl 
2fdf 7e					ld a, (hl) 
2fe0					;inc hl 
2fe0					; skip word string 
2fe0 cd de 0f				call addatohl 
2fe3			 
2fe3 23					inc hl 
2fe4			 
2fe4				if DEBUG_FORTH_WORDS 
2fe4					DMARK "LS3" 
2fe4 f5				push af  
2fe5 3a f9 2f			ld a, (.dmark)  
2fe8 32 a0 fd			ld (debug_mark),a  
2feb 3a fa 2f			ld a, (.dmark+1)  
2fee 32 a1 fd			ld (debug_mark+1),a  
2ff1 3a fb 2f			ld a, (.dmark+2)  
2ff4 32 a2 fd			ld (debug_mark+2),a  
2ff7 18 03			jr .pastdmark  
2ff9 ..			.dmark: db "LS3"  
2ffc f1			.pastdmark: pop af  
2ffd			endm  
# End of macro DMARK
2ffd					CALLMONITOR 
2ffd cd aa fd			call debug_vector  
3000				endm  
# End of macro CALLMONITOR
3000				endif 
3000					; should now be at the start of the machine code to setup the eval of the uword 
3000					; now locate the ptr to the string defintion 
3000			 
3000					; skip ld hl, 
3000					; then load the ptr 
3000			; TODO use get from hl ptr 
3000 23					inc hl 
3001 5e					ld e, (hl) 
3002 23					inc hl 
3003 56					ld d, (hl) 
3004 eb					ex de, hl 
3005			 
3005			 
3005				if DEBUG_FORTH_WORDS 
3005					DMARK "LSt" 
3005 f5				push af  
3006 3a 1a 30			ld a, (.dmark)  
3009 32 a0 fd			ld (debug_mark),a  
300c 3a 1b 30			ld a, (.dmark+1)  
300f 32 a1 fd			ld (debug_mark+1),a  
3012 3a 1c 30			ld a, (.dmark+2)  
3015 32 a2 fd			ld (debug_mark+2),a  
3018 18 03			jr .pastdmark  
301a ..			.dmark: db "LSt"  
301d f1			.pastdmark: pop af  
301e			endm  
# End of macro DMARK
301e					CALLMONITOR 
301e cd aa fd			call debug_vector  
3021				endm  
# End of macro CALLMONITOR
3021				endif 
3021			 
3021			; cant push right now due to tokenised strings  
3021			 
3021			; get the destination of where to copy this definition to. 
3021			 
3021 c5					push bc 
3022 d1					pop de 
3023			 
3023 7e			.listl:         ld a,(hl) 
3024 fe 00				cp 0 
3026 28 09				jr z, .lreplsp     ; replace zero with space 
3028					;cp FORTH_END_BUFFER 
3028 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
302a 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
302c				 
302c					; just copy this char as is then 
302c			 
302c 12					ld (de), a 
302d			 
302d 23			.listnxt:	inc hl 
302e 13					inc de 
302f 18 f2				jr .listl 
3031			 
3031 3e 20		.lreplsp:	ld a,' ' 
3033 12					ld (de), a 
3034 18 f7				jr .listnxt 
3036			 
3036			; close up uword def 
3036			 
3036			.listdone: 
3036 12					ld (de), a 
3037 13					inc de 
3038 3e 00				ld a, 0 
303a 12					ld (de), a 
303b			 
303b			; now have def so clean up and push to stack 
303b			 
303b 21 f6 f0				ld hl, scratch 
303e				if DEBUG_FORTH_WORDS 
303e					DMARK "Ltp" 
303e f5				push af  
303f 3a 53 30			ld a, (.dmark)  
3042 32 a0 fd			ld (debug_mark),a  
3045 3a 54 30			ld a, (.dmark+1)  
3048 32 a1 fd			ld (debug_mark+1),a  
304b 3a 55 30			ld a, (.dmark+2)  
304e 32 a2 fd			ld (debug_mark+2),a  
3051 18 03			jr .pastdmark  
3053 ..			.dmark: db "Ltp"  
3056 f1			.pastdmark: pop af  
3057			endm  
# End of macro DMARK
3057					CALLMONITOR 
3057 cd aa fd			call debug_vector  
305a				endm  
# End of macro CALLMONITOR
305a				endif 
305a			 
305a 18 1f			jr .listpush 
305c			 
305c			;.lnuword:	pop hl 
305c			;		call forth_tok_next 
305c			;		jp .ldouscan  
305c			 
305c			.lunotfound:		  
305c			 
305c				if DEBUG_FORTH_WORDS 
305c					DMARK "LSn" 
305c f5				push af  
305d 3a 71 30			ld a, (.dmark)  
3060 32 a0 fd			ld (debug_mark),a  
3063 3a 72 30			ld a, (.dmark+1)  
3066 32 a1 fd			ld (debug_mark+1),a  
3069 3a 73 30			ld a, (.dmark+2)  
306c 32 a2 fd			ld (debug_mark+2),a  
306f 18 03			jr .pastdmark  
3071 ..			.dmark: db "LSn"  
3074 f1			.pastdmark: pop af  
3075			endm  
# End of macro DMARK
3075					CALLMONITOR 
3075 cd aa fd			call debug_vector  
3078				endm  
# End of macro CALLMONITOR
3078				endif 
3078			 
3078					 
3078			;		FORTH_DSP_POP 
3078			;		ld hl, .luno 
3078			 
3078					NEXTW			 
3078 c3 39 24			jp macro_next 
307b				endm 
# End of macro NEXTW
307b			 
307b			.listpush: 
307b				if DEBUG_FORTH_WORDS 
307b					DMARK "LS>" 
307b f5				push af  
307c 3a 90 30			ld a, (.dmark)  
307f 32 a0 fd			ld (debug_mark),a  
3082 3a 91 30			ld a, (.dmark+1)  
3085 32 a1 fd			ld (debug_mark+1),a  
3088 3a 92 30			ld a, (.dmark+2)  
308b 32 a2 fd			ld (debug_mark+2),a  
308e 18 03			jr .pastdmark  
3090 ..			.dmark: db "LS>"  
3093 f1			.pastdmark: pop af  
3094			endm  
# End of macro DMARK
3094					CALLMONITOR 
3094 cd aa fd			call debug_vector  
3097				endm  
# End of macro CALLMONITOR
3097				endif 
3097 cd b6 20				call forth_push_str 
309a			 
309a			 
309a			 
309a					NEXTW 
309a c3 39 24			jp macro_next 
309d				endm 
# End of macro NEXTW
309d			 
309d			;.luno:    db "Word not found",0 
309d			 
309d			 
309d			 
309d			 
309d			 
309d			;		push hl   ; save pointer to start of uword def string 
309d			; 
309d			;; look for FORTH_EOL_LINE 
309d			;		ld a, FORTH_END_BUFFER 
309d			;		call strlent 
309d			; 
309d			;		inc hl		 ; space for coln def 
309d			;		inc hl 
309d			;		inc hl          ; space for terms 
309d			;		inc hl 
309d			; 
309d			;		ld a, 20   ; TODO get actual length 
309d			;		call addatohl    ; include a random amount of room for the uword name 
309d			; 
309d			;		 
309d			;	if DEBUG_FORTH_WORDS 
309d			;		DMARK "Lt1" 
309d			;		CALLMONITOR 
309d			;	endif 
309d			;		 
309d			; 
309d			;; malloc space for the string because we cant change it 
309d			; 
309d			;		call malloc 
309d			;	if DEBUG_FORTH_MALLOC_GUARD 
309d			;		push af 
309d			;		call ishlzero 
309d			;		pop af 
309d			;		 
309d			;		call z,malloc_error 
309d			;	endif 
309d			; 
309d			;	if DEBUG_FORTH_WORDS 
309d			;		DMARK "Lt2" 
309d			;		CALLMONITOR 
309d			;	endif 
309d			;		pop de 
309d			;		push hl    ; push the malloc to release later 
309d			;		push hl   ;  push back a copy for the later stack push 
309d			;		 
309d			;; copy the string swapping out the zero terms for spaces 
309d			; 
309d			;		; de has our source 
309d			;		; hl has our dest 
309d			; 
309d			;; add the coln def 
309d			; 
309d			;		ld a, ':' 
309d			;		ld (hl), a 
309d			;		inc hl 
309d			;		ld a, ' ' 
309d			;		ld (hl), a 
309d			;		inc hl 
309d			; 
309d			;; add the uname word 
309d			;		push de   ; save our string for now 
309d			;		ex de, hl 
309d			; 
309d			;		FORTH_DSP_VALUE 
309d			;		;v5 FORTH_DSP_VALUE 
309d			; 
309d			;		inc hl   ; skip type but we know by now this is OK 
309d			; 
309d			;.luword:	ld a,(hl) 
309d			;		cp 0 
309d			;		jr z, .luword2 
309d			;		ld (de), a 
309d			;		inc de 
309d			;		inc hl 
309d			;		jr .luword 
309d			; 
309d			;.luword2:	ld a, ' ' 
309d			;		ld (de), a 
309d			;;		inc hl 
309d			;;		inc de 
309d			;;		ld (de), a 
309d			;;		inc hl 
309d			;		inc de 
309d			; 
309d			;		ex de, hl 
309d			;		pop de 
309d			;		 
309d			;		 
309d			; 
309d			;; detoken that string and copy it 
309d			; 
309d			;	if DEBUG_FORTH_WORDS 
309d			;		DMARK "Lt2" 
309d			;		CALLMONITOR 
309d			;	endif 
309d			;.ldetok:	ld a, (de) 
309d			;		cp FORTH_END_BUFFER 
309d			;		jr z, .ldetokend 
309d			;		; swap out any zero term for space 
309d			;		cp 0 
309d			;		jr nz, .ldetoknext 
309d			;		ld a, ' ' 
309d			; 
309d			;	if DEBUG_FORTH_WORDS 
309d			;		DMARK "LtS" 
309d			;		CALLMONITOR 
309d			;	endif 
309d			;.ldetoknext:	ld (hl), a 
309d			;		inc de 
309d			;		inc hl 
309d			;		jr .ldetok 
309d			; 
309d			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
309d			;		ld (hl), a  
309d			; 
309d			;; free that temp malloc 
309d			; 
309d			;		pop hl    
309d			; 
309d			;	if DEBUG_FORTH_WORDS 
309d			;		DMARK "Lt4" 
309d			;		CALLMONITOR 
309d			;	endif 
309d			;		call forth_apushstrhl 
309d			; 
309d			;		; get rid of temp malloc area 
309d			; 
309d			;		pop hl 
309d			;		call free 
309d			; 
309d			;		jr .ludone 
309d			; 
309d			;.lnuword:	pop hl 
309d			;		call forth_tok_next 
309d			;		jp .ldouscan  
309d			; 
309d			;.ludone:		 pop hl 
309d			; 
309d					NEXTW 
309d c3 39 24			jp macro_next 
30a0				endm 
# End of macro NEXTW
30a0			 
30a0			.FORGET: 
30a0				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
30a0 5d				db WORD_SYS_CORE+73             
30a1 19 31			dw .NOP            
30a3 07				db 6 + 1 
30a4 .. 00			db "FORGET",0              
30ab				endm 
# End of macro CWHEAD
30ab			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
30ab			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
30ab			; | |  
30ab			; | | e.g. "MORE" forget 
30ab					if DEBUG_FORTH_WORDS_KEY 
30ab						DMARK "FRG" 
30ab f5				push af  
30ac 3a c0 30			ld a, (.dmark)  
30af 32 a0 fd			ld (debug_mark),a  
30b2 3a c1 30			ld a, (.dmark+1)  
30b5 32 a1 fd			ld (debug_mark+1),a  
30b8 3a c2 30			ld a, (.dmark+2)  
30bb 32 a2 fd			ld (debug_mark+2),a  
30be 18 03			jr .pastdmark  
30c0 ..			.dmark: db "FRG"  
30c3 f1			.pastdmark: pop af  
30c4			endm  
# End of macro DMARK
30c4						CALLMONITOR 
30c4 cd aa fd			call debug_vector  
30c7				endm  
# End of macro CALLMONITOR
30c7					endif 
30c7			 
30c7				; find uword 
30c7			        ; update start of word with "_" 
30c7				; replace uword with deleted flag 
30c7			 
30c7			 
30c7			;	if DEBUG_FORTH_WORDS 
30c7			;		DMARK "FOG" 
30c7			;		CALLMONITOR 
30c7			;	endif 
30c7			 
30c7			 
30c7					; Get ptr to the word we need to look up 
30c7			 
30c7					FORTH_DSP_VALUEHL 
30c7 cd 4d 22			call macro_dsp_valuehl 
30ca				endm 
# End of macro FORTH_DSP_VALUEHL
30ca					;v5 FORTH_DSP_VALUE 
30ca				; TODO type check 
30ca			;		inc hl    ; Skip type check  
30ca e5					push hl 
30cb c1					pop bc 
30cc			;		ex de, hl    ; put into DE 
30cc			 
30cc			 
30cc 21 00 80				ld hl, baseram 
30cf					;ld hl, baseusermem 
30cf			 
30cf				; skip dict stub 
30cf			;	call forth_tok_next 
30cf e5			push hl   ; sacreifical push 
30d0			 
30d0			.fldouscanm: 
30d0 e1				pop hl 
30d1			.fldouscan: 
30d1			;	if DEBUG_FORTH_WORDS 
30d1			;		DMARK "LSs" 
30d1			;		CALLMONITOR 
30d1			;	endif 
30d1				; skip dict stub 
30d1 cd 76 25				call forth_tok_next 
30d4			 
30d4			 
30d4			; while we have words to look for 
30d4			 
30d4 7e				ld a, (hl)      
30d5			;	if DEBUG_FORTH_WORDS 
30d5			;		DMARK "LSk" 
30d5			;		CALLMONITOR 
30d5			;	endif 
30d5 fe 00				cp WORD_SYS_END 
30d7 ca 13 31				jp z, .flunotfound 
30da fe 01				cp WORD_SYS_UWORD 
30dc c2 d1 30				jp nz, .fldouscan 
30df			 
30df			;	if DEBUG_FORTH_WORDS 
30df			;		DMARK "LSu" 
30df			;		CALLMONITOR 
30df			;	endif 
30df			 
30df					; found a uword but is it the one we want... 
30df			 
30df c5					push bc     ; uword to find is on bc 
30e0 d1					pop de 
30e1			 
30e1 e5					push hl  ; to save the ptr 
30e2			 
30e2					; skip opcode 
30e2 23					inc hl  
30e3					; skip next ptr 
30e3 23					inc hl  
30e4 23					inc hl 
30e5					; skip len 
30e5 23					inc hl 
30e6			 
30e6			;	if DEBUG_FORTH_WORDS 
30e6			;		DMARK "LSc" 
30e6			;		CALLMONITOR 
30e6			;	endif 
30e6 cd 7c 13				call strcmp 
30e9 c2 d0 30				jp nz, .fldouscanm 
30ec			; 
30ec			; 
30ec			;; while we have words to look for 
30ec			; 
30ec			;.fdouscan:	ld a, (hl)      
30ec			;	if DEBUG_FORTH_WORDS 
30ec			;		DMARK "LSs" 
30ec			;		CALLMONITOR 
30ec			;	endif 
30ec			;		cp WORD_SYS_END 
30ec			;		jp z, .fudone 
30ec			;		cp WORD_SYS_UWORD 
30ec			;		jp nz, .fnuword 
30ec			; 
30ec			;	if DEBUG_FORTH_WORDS 
30ec			;		DMARK "FGu" 
30ec			;		CALLMONITOR 
30ec			;	endif 
30ec			; 
30ec			;		; found a uword but is it the one we want... 
30ec			; 
30ec			; 
30ec			;	        pop de   ; get back the dsp name 
30ec			;		push de 
30ec			; 
30ec			;		push hl  ; to save the ptr 
30ec			; 
30ec			;		; skip opcode 
30ec			;		inc hl  
30ec			;		; skip next ptr 
30ec			;		inc hl  
30ec			;		inc hl 
30ec			;		; skip len 
30ec			;		inc hl 
30ec			; 
30ec			;	if DEBUG_FORTH_WORDS 
30ec			;		DMARK "FGc" 
30ec			;		CALLMONITOR 
30ec			;	endif 
30ec			;		call strcmp 
30ec			;		jp nz, .fnuword 
30ec			 
30ec			 
30ec e1			pop hl 
30ed			 
30ed				 
30ed				if DEBUG_FORTH_WORDS 
30ed					DMARK "FGm" 
30ed f5				push af  
30ee 3a 02 31			ld a, (.dmark)  
30f1 32 a0 fd			ld (debug_mark),a  
30f4 3a 03 31			ld a, (.dmark+1)  
30f7 32 a1 fd			ld (debug_mark+1),a  
30fa 3a 04 31			ld a, (.dmark+2)  
30fd 32 a2 fd			ld (debug_mark+2),a  
3100 18 03			jr .pastdmark  
3102 ..			.dmark: db "FGm"  
3105 f1			.pastdmark: pop af  
3106			endm  
# End of macro DMARK
3106					CALLMONITOR 
3106 cd aa fd			call debug_vector  
3109				endm  
# End of macro CALLMONITOR
3109				endif 
3109			 
3109			 
3109			 
3109					; we have a uword so push its name to the stack 
3109			 
3109			;	   	push hl  ; save so we can move to next dict block 
3109			;pop hl 
3109			 
3109					; update opcode to deleted 
3109 3e 03				ld a, WORD_SYS_DELETED 
310b 77					ld (hl), a 
310c			 
310c 23					inc hl  
310d					; skip next ptr 
310d 23					inc hl  
310e 23					inc hl 
310f					; skip len 
310f 23					inc hl 
3110			 
3110					; TODO change parser to skip deleted words but for now mark it out 
3110 3e 5f				ld a, "_" 
3112 77					ld  (hl),a 
3113			 
3113			;		jr .fudone 
3113			; 
3113			;.fnuword:	pop hl 
3113			;		call forth_tok_next 
3113			;		jp .fdouscan  
3113			 
3113			.flunotfound:		  
3113			 
3113			 
3113					 
3113					FORTH_DSP_POP 
3113 cd 05 23			call macro_forth_dsp_pop 
3116				endm 
# End of macro FORTH_DSP_POP
3116			;		ld hl, .luno 
3116			;.fudone:		 pop hl 
3116					NEXTW 
3116 c3 39 24			jp macro_next 
3119				endm 
# End of macro NEXTW
3119			.NOP: 
3119				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
3119 61				db WORD_SYS_CORE+77             
311a 40 31			dw .COMO            
311c 04				db 3 + 1 
311d .. 00			db "NOP",0              
3121				endm 
# End of macro CWHEAD
3121			; | NOP (  --  ) Do nothing | DONE 
3121					if DEBUG_FORTH_WORDS_KEY 
3121						DMARK "NOP" 
3121 f5				push af  
3122 3a 36 31			ld a, (.dmark)  
3125 32 a0 fd			ld (debug_mark),a  
3128 3a 37 31			ld a, (.dmark+1)  
312b 32 a1 fd			ld (debug_mark+1),a  
312e 3a 38 31			ld a, (.dmark+2)  
3131 32 a2 fd			ld (debug_mark+2),a  
3134 18 03			jr .pastdmark  
3136 ..			.dmark: db "NOP"  
3139 f1			.pastdmark: pop af  
313a			endm  
# End of macro DMARK
313a						CALLMONITOR 
313a cd aa fd			call debug_vector  
313d				endm  
# End of macro CALLMONITOR
313d					endif 
313d				       NEXTW 
313d c3 39 24			jp macro_next 
3140				endm 
# End of macro NEXTW
3140			.COMO: 
3140				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
3140 6e				db WORD_SYS_CORE+90             
3141 92 31			dw .COMC            
3143 02				db 1 + 1 
3144 .. 00			db "(",0              
3146				endm 
# End of macro CWHEAD
3146			; | ( ( -- )  Start of comment | DONE 
3146			 
3146			 
3146 2a f7 f3				ld hl, ( os_tok_ptr) 
3149 11 8d 31			ld de, .closepar 
314c					 
314c					if DEBUG_FORTH_WORDS 
314c						DMARK ").." 
314c f5				push af  
314d 3a 61 31			ld a, (.dmark)  
3150 32 a0 fd			ld (debug_mark),a  
3153 3a 62 31			ld a, (.dmark+1)  
3156 32 a1 fd			ld (debug_mark+1),a  
3159 3a 63 31			ld a, (.dmark+2)  
315c 32 a2 fd			ld (debug_mark+2),a  
315f 18 03			jr .pastdmark  
3161 ..			.dmark: db ").."  
3164 f1			.pastdmark: pop af  
3165			endm  
# End of macro DMARK
3165						CALLMONITOR 
3165 cd aa fd			call debug_vector  
3168				endm  
# End of macro CALLMONITOR
3168					endif 
3168 cd 40 25			call findnexttok  
316b			 
316b					if DEBUG_FORTH_WORDS 
316b						DMARK "IF5" 
316b f5				push af  
316c 3a 80 31			ld a, (.dmark)  
316f 32 a0 fd			ld (debug_mark),a  
3172 3a 81 31			ld a, (.dmark+1)  
3175 32 a1 fd			ld (debug_mark+1),a  
3178 3a 82 31			ld a, (.dmark+2)  
317b 32 a2 fd			ld (debug_mark+2),a  
317e 18 03			jr .pastdmark  
3180 ..			.dmark: db "IF5"  
3183 f1			.pastdmark: pop af  
3184			endm  
# End of macro DMARK
3184						CALLMONITOR 
3184 cd aa fd			call debug_vector  
3187				endm  
# End of macro CALLMONITOR
3187					endif 
3187				; replace below with ) exec using tok_ptr 
3187 22 f7 f3			ld (os_tok_ptr), hl 
318a c3 c2 24			jp exec1 
318d			 
318d .. 00			.closepar:   db ")",0 
318f			 
318f				       NEXTW 
318f c3 39 24			jp macro_next 
3192				endm 
# End of macro NEXTW
3192			.COMC: 
3192				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
3192 6f				db WORD_SYS_CORE+91             
3193 9b 31			dw .SCRATCH            
3195 02				db 1 + 1 
3196 .. 00			db ")",0              
3198				endm 
# End of macro CWHEAD
3198			; | ) ( -- )  End of comment |  DONE  
3198				       NEXTW 
3198 c3 39 24			jp macro_next 
319b				endm 
# End of macro NEXTW
319b			 
319b			.SCRATCH: 
319b				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
319b 6f				db WORD_SYS_CORE+91             
319c d6 31			dw .INC            
319e 08				db 7 + 1 
319f .. 00			db "SCRATCH",0              
31a7				endm 
# End of macro CWHEAD
31a7			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
31a7			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
31a7			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
31a7			; | |  
31a7			; | | e.g.    : score $00 scratch ; 
31a7			; | |  
31a7			; | | $00 score ! 
31a7			; | | $01 score +! 
31a7			; | |  
31a7			; | | e.g.   : varword $0a scratch ;  
31a7			; | | 
31a7			; | | $8000 varword ! 
31a7					if DEBUG_FORTH_WORDS_KEY 
31a7						DMARK "SCR" 
31a7 f5				push af  
31a8 3a bc 31			ld a, (.dmark)  
31ab 32 a0 fd			ld (debug_mark),a  
31ae 3a bd 31			ld a, (.dmark+1)  
31b1 32 a1 fd			ld (debug_mark+1),a  
31b4 3a be 31			ld a, (.dmark+2)  
31b7 32 a2 fd			ld (debug_mark+2),a  
31ba 18 03			jr .pastdmark  
31bc ..			.dmark: db "SCR"  
31bf f1			.pastdmark: pop af  
31c0			endm  
# End of macro DMARK
31c0						CALLMONITOR 
31c0 cd aa fd			call debug_vector  
31c3				endm  
# End of macro CALLMONITOR
31c3					endif 
31c3			 
31c3					FORTH_DSP_VALUEHL 
31c3 cd 4d 22			call macro_dsp_valuehl 
31c6				endm 
# End of macro FORTH_DSP_VALUEHL
31c6				 
31c6					FORTH_DSP_POP 
31c6 cd 05 23			call macro_forth_dsp_pop 
31c9				endm 
# End of macro FORTH_DSP_POP
31c9			 
31c9 7d					ld a, l 
31ca 21 1b f6				ld hl, os_var_array 
31cd cd de 0f				call addatohl 
31d0			 
31d0 cd 48 20				call forth_push_numhl 
31d3			 
31d3				       NEXTW 
31d3 c3 39 24			jp macro_next 
31d6				endm 
# End of macro NEXTW
31d6			 
31d6			.INC: 
31d6				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
31d6 6f				db WORD_SYS_CORE+91             
31d7 2c 32			dw .DEC            
31d9 03				db 2 + 1 
31da .. 00			db "+!",0              
31dd				endm 
# End of macro CWHEAD
31dd			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
31dd					if DEBUG_FORTH_WORDS_KEY 
31dd						DMARK "+s_" 
31dd f5				push af  
31de 3a f2 31			ld a, (.dmark)  
31e1 32 a0 fd			ld (debug_mark),a  
31e4 3a f3 31			ld a, (.dmark+1)  
31e7 32 a1 fd			ld (debug_mark+1),a  
31ea 3a f4 31			ld a, (.dmark+2)  
31ed 32 a2 fd			ld (debug_mark+2),a  
31f0 18 03			jr .pastdmark  
31f2 ..			.dmark: db "+s_"  
31f5 f1			.pastdmark: pop af  
31f6			endm  
# End of macro DMARK
31f6						CALLMONITOR 
31f6 cd aa fd			call debug_vector  
31f9				endm  
# End of macro CALLMONITOR
31f9					endif 
31f9			 
31f9					FORTH_DSP_VALUEHL 
31f9 cd 4d 22			call macro_dsp_valuehl 
31fc				endm 
# End of macro FORTH_DSP_VALUEHL
31fc			 
31fc e5					push hl   ; save address 
31fd			 
31fd					FORTH_DSP_POP 
31fd cd 05 23			call macro_forth_dsp_pop 
3200				endm 
# End of macro FORTH_DSP_POP
3200			 
3200					FORTH_DSP_VALUEHL 
3200 cd 4d 22			call macro_dsp_valuehl 
3203				endm 
# End of macro FORTH_DSP_VALUEHL
3203			 
3203 e5					push hl 
3204					FORTH_DSP_POP 
3204 cd 05 23			call macro_forth_dsp_pop 
3207				endm 
# End of macro FORTH_DSP_POP
3207 e1					pop hl 
3208			 
3208					; hl contains value to add to byte at a 
3208				 
3208 eb					ex de, hl 
3209			 
3209 e1					pop hl 
320a			 
320a					if DEBUG_FORTH_WORDS 
320a						DMARK "INC" 
320a f5				push af  
320b 3a 1f 32			ld a, (.dmark)  
320e 32 a0 fd			ld (debug_mark),a  
3211 3a 20 32			ld a, (.dmark+1)  
3214 32 a1 fd			ld (debug_mark+1),a  
3217 3a 21 32			ld a, (.dmark+2)  
321a 32 a2 fd			ld (debug_mark+2),a  
321d 18 03			jr .pastdmark  
321f ..			.dmark: db "INC"  
3222 f1			.pastdmark: pop af  
3223			endm  
# End of macro DMARK
3223						CALLMONITOR 
3223 cd aa fd			call debug_vector  
3226				endm  
# End of macro CALLMONITOR
3226					endif 
3226			 
3226 7e					ld a,(hl) 
3227 83					add e 
3228 77					ld (hl),a 
3229			 
3229			 
3229			 
3229				       NEXTW 
3229 c3 39 24			jp macro_next 
322c				endm 
# End of macro NEXTW
322c			 
322c			.DEC: 
322c				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
322c 6f				db WORD_SYS_CORE+91             
322d 80 32			dw .INC2            
322f 03				db 2 + 1 
3230 .. 00			db "-!",0              
3233				endm 
# End of macro CWHEAD
3233			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
3233					if DEBUG_FORTH_WORDS_KEY 
3233						DMARK "-s_" 
3233 f5				push af  
3234 3a 48 32			ld a, (.dmark)  
3237 32 a0 fd			ld (debug_mark),a  
323a 3a 49 32			ld a, (.dmark+1)  
323d 32 a1 fd			ld (debug_mark+1),a  
3240 3a 4a 32			ld a, (.dmark+2)  
3243 32 a2 fd			ld (debug_mark+2),a  
3246 18 03			jr .pastdmark  
3248 ..			.dmark: db "-s_"  
324b f1			.pastdmark: pop af  
324c			endm  
# End of macro DMARK
324c						CALLMONITOR 
324c cd aa fd			call debug_vector  
324f				endm  
# End of macro CALLMONITOR
324f					endif 
324f			 
324f					FORTH_DSP_VALUEHL 
324f cd 4d 22			call macro_dsp_valuehl 
3252				endm 
# End of macro FORTH_DSP_VALUEHL
3252			 
3252 e5					push hl   ; save address 
3253			 
3253					FORTH_DSP_POP 
3253 cd 05 23			call macro_forth_dsp_pop 
3256				endm 
# End of macro FORTH_DSP_POP
3256			 
3256					FORTH_DSP_VALUEHL 
3256 cd 4d 22			call macro_dsp_valuehl 
3259				endm 
# End of macro FORTH_DSP_VALUEHL
3259			 
3259					; hl contains value to add to byte at a 
3259				 
3259 eb					ex de, hl 
325a			 
325a e1					pop hl 
325b			 
325b					if DEBUG_FORTH_WORDS 
325b						DMARK "DEC" 
325b f5				push af  
325c 3a 70 32			ld a, (.dmark)  
325f 32 a0 fd			ld (debug_mark),a  
3262 3a 71 32			ld a, (.dmark+1)  
3265 32 a1 fd			ld (debug_mark+1),a  
3268 3a 72 32			ld a, (.dmark+2)  
326b 32 a2 fd			ld (debug_mark+2),a  
326e 18 03			jr .pastdmark  
3270 ..			.dmark: db "DEC"  
3273 f1			.pastdmark: pop af  
3274			endm  
# End of macro DMARK
3274						CALLMONITOR 
3274 cd aa fd			call debug_vector  
3277				endm  
# End of macro CALLMONITOR
3277					endif 
3277			 
3277 7e					ld a,(hl) 
3278 93					sub e 
3279 77					ld (hl),a 
327a			 
327a			 
327a					FORTH_DSP_POP 
327a cd 05 23			call macro_forth_dsp_pop 
327d				endm 
# End of macro FORTH_DSP_POP
327d			 
327d				       NEXTW 
327d c3 39 24			jp macro_next 
3280				endm 
# End of macro NEXTW
3280			 
3280			.INC2: 
3280				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
3280 6f				db WORD_SYS_CORE+91             
3281 2d 33			dw .DEC2            
3283 04				db 3 + 1 
3284 .. 00			db "+2!",0              
3288				endm 
# End of macro CWHEAD
3288			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3288			 
3288					if DEBUG_FORTH_WORDS_KEY 
3288						DMARK "+2s" 
3288 f5				push af  
3289 3a 9d 32			ld a, (.dmark)  
328c 32 a0 fd			ld (debug_mark),a  
328f 3a 9e 32			ld a, (.dmark+1)  
3292 32 a1 fd			ld (debug_mark+1),a  
3295 3a 9f 32			ld a, (.dmark+2)  
3298 32 a2 fd			ld (debug_mark+2),a  
329b 18 03			jr .pastdmark  
329d ..			.dmark: db "+2s"  
32a0 f1			.pastdmark: pop af  
32a1			endm  
# End of macro DMARK
32a1						CALLMONITOR 
32a1 cd aa fd			call debug_vector  
32a4				endm  
# End of macro CALLMONITOR
32a4					endif 
32a4			 
32a4					; Address 
32a4			 
32a4					FORTH_DSP_VALUEHL 
32a4 cd 4d 22			call macro_dsp_valuehl 
32a7				endm 
# End of macro FORTH_DSP_VALUEHL
32a7			 
32a7 e5					push hl    ; save address 
32a8			 
32a8					; load content into de 
32a8			 
32a8 5e					ld e,(hl) 
32a9 23					inc hl 
32aa 56					ld d, (hl) 
32ab			 
32ab					if DEBUG_FORTH_WORDS 
32ab						DMARK "+2a" 
32ab f5				push af  
32ac 3a c0 32			ld a, (.dmark)  
32af 32 a0 fd			ld (debug_mark),a  
32b2 3a c1 32			ld a, (.dmark+1)  
32b5 32 a1 fd			ld (debug_mark+1),a  
32b8 3a c2 32			ld a, (.dmark+2)  
32bb 32 a2 fd			ld (debug_mark+2),a  
32be 18 03			jr .pastdmark  
32c0 ..			.dmark: db "+2a"  
32c3 f1			.pastdmark: pop af  
32c4			endm  
# End of macro DMARK
32c4						CALLMONITOR 
32c4 cd aa fd			call debug_vector  
32c7				endm  
# End of macro CALLMONITOR
32c7					endif 
32c7			 
32c7					FORTH_DSP_POP 
32c7 cd 05 23			call macro_forth_dsp_pop 
32ca				endm 
# End of macro FORTH_DSP_POP
32ca			 
32ca					; Get value to add 
32ca			 
32ca					FORTH_DSP_VALUE 
32ca cd 36 22			call macro_forth_dsp_value 
32cd				endm 
# End of macro FORTH_DSP_VALUE
32cd			 
32cd					if DEBUG_FORTH_WORDS 
32cd						DMARK "+2v" 
32cd f5				push af  
32ce 3a e2 32			ld a, (.dmark)  
32d1 32 a0 fd			ld (debug_mark),a  
32d4 3a e3 32			ld a, (.dmark+1)  
32d7 32 a1 fd			ld (debug_mark+1),a  
32da 3a e4 32			ld a, (.dmark+2)  
32dd 32 a2 fd			ld (debug_mark+2),a  
32e0 18 03			jr .pastdmark  
32e2 ..			.dmark: db "+2v"  
32e5 f1			.pastdmark: pop af  
32e6			endm  
# End of macro DMARK
32e6						CALLMONITOR 
32e6 cd aa fd			call debug_vector  
32e9				endm  
# End of macro CALLMONITOR
32e9					endif 
32e9			 
32e9 19					add hl, de 
32ea			 
32ea					if DEBUG_FORTH_WORDS 
32ea						DMARK "+2+" 
32ea f5				push af  
32eb 3a ff 32			ld a, (.dmark)  
32ee 32 a0 fd			ld (debug_mark),a  
32f1 3a 00 33			ld a, (.dmark+1)  
32f4 32 a1 fd			ld (debug_mark+1),a  
32f7 3a 01 33			ld a, (.dmark+2)  
32fa 32 a2 fd			ld (debug_mark+2),a  
32fd 18 03			jr .pastdmark  
32ff ..			.dmark: db "+2+"  
3302 f1			.pastdmark: pop af  
3303			endm  
# End of macro DMARK
3303						CALLMONITOR 
3303 cd aa fd			call debug_vector  
3306				endm  
# End of macro CALLMONITOR
3306					endif 
3306			 
3306					; move result to de 
3306			 
3306 eb					ex de, hl 
3307			 
3307					; Address 
3307			 
3307 e1					pop hl 
3308			 
3308					; save it back 
3308			 
3308 73					ld (hl), e 
3309 23					inc hl 
330a 72					ld (hl), d 
330b			 
330b					if DEBUG_FORTH_WORDS 
330b						DMARK "+2e" 
330b f5				push af  
330c 3a 20 33			ld a, (.dmark)  
330f 32 a0 fd			ld (debug_mark),a  
3312 3a 21 33			ld a, (.dmark+1)  
3315 32 a1 fd			ld (debug_mark+1),a  
3318 3a 22 33			ld a, (.dmark+2)  
331b 32 a2 fd			ld (debug_mark+2),a  
331e 18 03			jr .pastdmark  
3320 ..			.dmark: db "+2e"  
3323 f1			.pastdmark: pop af  
3324			endm  
# End of macro DMARK
3324						CALLMONITOR 
3324 cd aa fd			call debug_vector  
3327				endm  
# End of macro CALLMONITOR
3327					endif 
3327			 
3327			 
3327			 
3327					FORTH_DSP_POP 
3327 cd 05 23			call macro_forth_dsp_pop 
332a				endm 
# End of macro FORTH_DSP_POP
332a			 
332a			 
332a				       NEXTW 
332a c3 39 24			jp macro_next 
332d				endm 
# End of macro NEXTW
332d			 
332d			.DEC2: 
332d				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
332d 6f				db WORD_SYS_CORE+91             
332e dc 33			dw .GET2            
3330 04				db 3 + 1 
3331 .. 00			db "-2!",0              
3335				endm 
# End of macro CWHEAD
3335			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3335			 
3335			 
3335					if DEBUG_FORTH_WORDS_KEY 
3335						DMARK "-2s" 
3335 f5				push af  
3336 3a 4a 33			ld a, (.dmark)  
3339 32 a0 fd			ld (debug_mark),a  
333c 3a 4b 33			ld a, (.dmark+1)  
333f 32 a1 fd			ld (debug_mark+1),a  
3342 3a 4c 33			ld a, (.dmark+2)  
3345 32 a2 fd			ld (debug_mark+2),a  
3348 18 03			jr .pastdmark  
334a ..			.dmark: db "-2s"  
334d f1			.pastdmark: pop af  
334e			endm  
# End of macro DMARK
334e						CALLMONITOR 
334e cd aa fd			call debug_vector  
3351				endm  
# End of macro CALLMONITOR
3351					endif 
3351			 
3351					; Address 
3351			 
3351					FORTH_DSP_VALUEHL 
3351 cd 4d 22			call macro_dsp_valuehl 
3354				endm 
# End of macro FORTH_DSP_VALUEHL
3354			 
3354 e5					push hl    ; save address 
3355			 
3355					; load content into de 
3355			 
3355 5e					ld e,(hl) 
3356 23					inc hl 
3357 56					ld d, (hl) 
3358			 
3358					if DEBUG_FORTH_WORDS 
3358						DMARK "-2a" 
3358 f5				push af  
3359 3a 6d 33			ld a, (.dmark)  
335c 32 a0 fd			ld (debug_mark),a  
335f 3a 6e 33			ld a, (.dmark+1)  
3362 32 a1 fd			ld (debug_mark+1),a  
3365 3a 6f 33			ld a, (.dmark+2)  
3368 32 a2 fd			ld (debug_mark+2),a  
336b 18 03			jr .pastdmark  
336d ..			.dmark: db "-2a"  
3370 f1			.pastdmark: pop af  
3371			endm  
# End of macro DMARK
3371						CALLMONITOR 
3371 cd aa fd			call debug_vector  
3374				endm  
# End of macro CALLMONITOR
3374					endif 
3374			 
3374					FORTH_DSP_POP 
3374 cd 05 23			call macro_forth_dsp_pop 
3377				endm 
# End of macro FORTH_DSP_POP
3377			 
3377					; Get value to remove 
3377			 
3377					FORTH_DSP_VALUE 
3377 cd 36 22			call macro_forth_dsp_value 
337a				endm 
# End of macro FORTH_DSP_VALUE
337a			 
337a					if DEBUG_FORTH_WORDS 
337a						DMARK "-2v" 
337a f5				push af  
337b 3a 8f 33			ld a, (.dmark)  
337e 32 a0 fd			ld (debug_mark),a  
3381 3a 90 33			ld a, (.dmark+1)  
3384 32 a1 fd			ld (debug_mark+1),a  
3387 3a 91 33			ld a, (.dmark+2)  
338a 32 a2 fd			ld (debug_mark+2),a  
338d 18 03			jr .pastdmark  
338f ..			.dmark: db "-2v"  
3392 f1			.pastdmark: pop af  
3393			endm  
# End of macro DMARK
3393						CALLMONITOR 
3393 cd aa fd			call debug_vector  
3396				endm  
# End of macro CALLMONITOR
3396					endif 
3396			 
3396 eb					ex de, hl 
3397 ed 52				sbc hl, de 
3399			 
3399					if DEBUG_FORTH_WORDS 
3399						DMARK "-2d" 
3399 f5				push af  
339a 3a ae 33			ld a, (.dmark)  
339d 32 a0 fd			ld (debug_mark),a  
33a0 3a af 33			ld a, (.dmark+1)  
33a3 32 a1 fd			ld (debug_mark+1),a  
33a6 3a b0 33			ld a, (.dmark+2)  
33a9 32 a2 fd			ld (debug_mark+2),a  
33ac 18 03			jr .pastdmark  
33ae ..			.dmark: db "-2d"  
33b1 f1			.pastdmark: pop af  
33b2			endm  
# End of macro DMARK
33b2						CALLMONITOR 
33b2 cd aa fd			call debug_vector  
33b5				endm  
# End of macro CALLMONITOR
33b5					endif 
33b5			 
33b5					; move result to de 
33b5			 
33b5 eb					ex de, hl 
33b6			 
33b6					; Address 
33b6			 
33b6 e1					pop hl 
33b7			 
33b7					; save it back 
33b7			 
33b7 73					ld (hl), e 
33b8 23					inc hl 
33b9 72					ld (hl), d 
33ba			 
33ba					if DEBUG_FORTH_WORDS 
33ba						DMARK "-2e" 
33ba f5				push af  
33bb 3a cf 33			ld a, (.dmark)  
33be 32 a0 fd			ld (debug_mark),a  
33c1 3a d0 33			ld a, (.dmark+1)  
33c4 32 a1 fd			ld (debug_mark+1),a  
33c7 3a d1 33			ld a, (.dmark+2)  
33ca 32 a2 fd			ld (debug_mark+2),a  
33cd 18 03			jr .pastdmark  
33cf ..			.dmark: db "-2e"  
33d2 f1			.pastdmark: pop af  
33d3			endm  
# End of macro DMARK
33d3						CALLMONITOR 
33d3 cd aa fd			call debug_vector  
33d6				endm  
# End of macro CALLMONITOR
33d6					endif 
33d6			 
33d6			 
33d6					FORTH_DSP_POP 
33d6 cd 05 23			call macro_forth_dsp_pop 
33d9				endm 
# End of macro FORTH_DSP_POP
33d9			 
33d9			 
33d9			 
33d9				       NEXTW 
33d9 c3 39 24			jp macro_next 
33dc				endm 
# End of macro NEXTW
33dc			.GET2: 
33dc				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
33dc 6f				db WORD_SYS_CORE+91             
33dd 11 34			dw .BANG2            
33df 03				db 2 + 1 
33e0 .. 00			db "2@",0              
33e3				endm 
# End of macro CWHEAD
33e3			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
33e3					if DEBUG_FORTH_WORDS_KEY 
33e3						DMARK "2A_" 
33e3 f5				push af  
33e4 3a f8 33			ld a, (.dmark)  
33e7 32 a0 fd			ld (debug_mark),a  
33ea 3a f9 33			ld a, (.dmark+1)  
33ed 32 a1 fd			ld (debug_mark+1),a  
33f0 3a fa 33			ld a, (.dmark+2)  
33f3 32 a2 fd			ld (debug_mark+2),a  
33f6 18 03			jr .pastdmark  
33f8 ..			.dmark: db "2A_"  
33fb f1			.pastdmark: pop af  
33fc			endm  
# End of macro DMARK
33fc						CALLMONITOR 
33fc cd aa fd			call debug_vector  
33ff				endm  
# End of macro CALLMONITOR
33ff					endif 
33ff			 
33ff					FORTH_DSP_VALUEHL 
33ff cd 4d 22			call macro_dsp_valuehl 
3402				endm 
# End of macro FORTH_DSP_VALUEHL
3402			 
3402 e5					push hl   ; save address 
3403			 
3403					FORTH_DSP_POP 
3403 cd 05 23			call macro_forth_dsp_pop 
3406				endm 
# End of macro FORTH_DSP_POP
3406			 
3406 e1					pop hl 
3407			 
3407 5e					ld e, (hl) 
3408 23					inc hl 
3409 56					ld d, (hl) 
340a			 
340a eb					ex de, hl 
340b			 
340b cd 48 20				call forth_push_numhl 
340e			 
340e				       NEXTW 
340e c3 39 24			jp macro_next 
3411				endm 
# End of macro NEXTW
3411			.BANG2: 
3411				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
3411 6f				db WORD_SYS_CORE+91             
3412 49 34			dw .CONFIG            
3414 03				db 2 + 1 
3415 .. 00			db "2!",0              
3418				endm 
# End of macro CWHEAD
3418			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3418					if DEBUG_FORTH_WORDS_KEY 
3418						DMARK "2S_" 
3418 f5				push af  
3419 3a 2d 34			ld a, (.dmark)  
341c 32 a0 fd			ld (debug_mark),a  
341f 3a 2e 34			ld a, (.dmark+1)  
3422 32 a1 fd			ld (debug_mark+1),a  
3425 3a 2f 34			ld a, (.dmark+2)  
3428 32 a2 fd			ld (debug_mark+2),a  
342b 18 03			jr .pastdmark  
342d ..			.dmark: db "2S_"  
3430 f1			.pastdmark: pop af  
3431			endm  
# End of macro DMARK
3431						CALLMONITOR 
3431 cd aa fd			call debug_vector  
3434				endm  
# End of macro CALLMONITOR
3434					endif 
3434			 
3434					FORTH_DSP_VALUEHL 
3434 cd 4d 22			call macro_dsp_valuehl 
3437				endm 
# End of macro FORTH_DSP_VALUEHL
3437			 
3437 e5					push hl   ; save address 
3438			 
3438			 
3438					FORTH_DSP_POP 
3438 cd 05 23			call macro_forth_dsp_pop 
343b				endm 
# End of macro FORTH_DSP_POP
343b			 
343b					 
343b					FORTH_DSP_VALUEHL 
343b cd 4d 22			call macro_dsp_valuehl 
343e				endm 
# End of macro FORTH_DSP_VALUEHL
343e			 
343e					FORTH_DSP_POP 
343e cd 05 23			call macro_forth_dsp_pop 
3441				endm 
# End of macro FORTH_DSP_POP
3441			 
3441 eb					ex de, hl    ; value now in de 
3442			 
3442 e1					pop hl 
3443			 
3443 73					ld (hl), e 
3444			 
3444 23					inc hl 
3445			 
3445 72					ld (hl), d 
3446			 
3446			 
3446				       NEXTW 
3446 c3 39 24			jp macro_next 
3449				endm 
# End of macro NEXTW
3449			.CONFIG: 
3449				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
3449 6f				db WORD_SYS_CORE+91             
344a 5a 34			dw .ADTOS            
344c 07				db 6 + 1 
344d .. 00			db "CONFIG",0              
3454				endm 
# End of macro CWHEAD
3454			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3454			 
3454 cd 52 15				call config 
3457					NEXTW 
3457 c3 39 24			jp macro_next 
345a				endm 
# End of macro NEXTW
345a			 
345a			.ADTOS: 
345a				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
345a 6f				db WORD_SYS_CORE+91             
345b 70 34			dw .SBTOS            
345d 03				db 2 + 1 
345e .. 00			db "1+",0              
3461				endm 
# End of macro CWHEAD
3461			; | 1+ ( u -- u )  Increment value on TOS | DONE 
3461			 
3461					FORTH_DSP_VALUEHL 
3461 cd 4d 22			call macro_dsp_valuehl 
3464				endm 
# End of macro FORTH_DSP_VALUEHL
3464 e5					push hl 
3465			 
3465					FORTH_DSP_POP 
3465 cd 05 23			call macro_forth_dsp_pop 
3468				endm 
# End of macro FORTH_DSP_POP
3468 e1					pop hl 
3469			 
3469 23					inc hl 
346a cd 48 20				call forth_push_numhl 
346d					 
346d					NEXTW 
346d c3 39 24			jp macro_next 
3470				endm 
# End of macro NEXTW
3470			.SBTOS: 
3470				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
3470 6f				db WORD_SYS_CORE+91             
3471 86 34			dw .ADSTORE            
3473 03				db 2 + 1 
3474 .. 00			db "1-",0              
3477				endm 
# End of macro CWHEAD
3477			; | 1- ( u -- u )  Decrement value on TOS | DONE 
3477			 
3477					FORTH_DSP_VALUEHL 
3477 cd 4d 22			call macro_dsp_valuehl 
347a				endm 
# End of macro FORTH_DSP_VALUEHL
347a e5					push hl 
347b			 
347b					FORTH_DSP_POP 
347b cd 05 23			call macro_forth_dsp_pop 
347e				endm 
# End of macro FORTH_DSP_POP
347e e1					pop hl 
347f			 
347f 2b					dec hl 
3480 cd 48 20				call forth_push_numhl 
3483					 
3483					NEXTW 
3483 c3 39 24			jp macro_next 
3486				endm 
# End of macro NEXTW
3486			.ADSTORE: 
3486				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
3486 6f				db WORD_SYS_CORE+91             
3487 9c 34			dw .ADWSTORE            
3489 04				db 3 + 1 
348a .. 00			db "1+!",0              
348e				endm 
# End of macro CWHEAD
348e			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
348e			 
348e					FORTH_DSP_VALUEHL 
348e cd 4d 22			call macro_dsp_valuehl 
3491				endm 
# End of macro FORTH_DSP_VALUEHL
3491 e5					push hl 
3492			 
3492					FORTH_DSP_POP 
3492 cd 05 23			call macro_forth_dsp_pop 
3495				endm 
# End of macro FORTH_DSP_POP
3495 e1					pop hl 
3496			 
3496 7e					ld a, (hl) 
3497 3c					inc a 
3498 77					ld (hl), a 
3499					 
3499					NEXTW 
3499 c3 39 24			jp macro_next 
349c				endm 
# End of macro NEXTW
349c			.ADWSTORE: 
349c				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
349c 6f				db WORD_SYS_CORE+91             
349d ba 34			dw .SBSTORE            
349f 05				db 4 + 1 
34a0 .. 00			db "1+2!",0              
34a5				endm 
# End of macro CWHEAD
34a5			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
34a5			 
34a5					FORTH_DSP_VALUEHL 
34a5 cd 4d 22			call macro_dsp_valuehl 
34a8				endm 
# End of macro FORTH_DSP_VALUEHL
34a8 e5					push hl 
34a9			 
34a9					FORTH_DSP_POP 
34a9 cd 05 23			call macro_forth_dsp_pop 
34ac				endm 
# End of macro FORTH_DSP_POP
34ac e1					pop hl 
34ad			 
34ad e5					push hl 
34ae			 
34ae cd bb 23				call loadwordinhl 
34b1 23					inc hl 
34b2			 
34b2 d1					pop de 
34b3 eb					ex de, hl 
34b4 73					ld (hl), e 
34b5 23					inc hl 
34b6 72					ld (hl), d 
34b7					 
34b7					NEXTW 
34b7 c3 39 24			jp macro_next 
34ba				endm 
# End of macro NEXTW
34ba			.SBSTORE: 
34ba				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
34ba 6f				db WORD_SYS_CORE+91             
34bb d0 34			dw .SBWSTORE            
34bd 04				db 3 + 1 
34be .. 00			db "1-!",0              
34c2				endm 
# End of macro CWHEAD
34c2			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
34c2			 
34c2					FORTH_DSP_VALUEHL 
34c2 cd 4d 22			call macro_dsp_valuehl 
34c5				endm 
# End of macro FORTH_DSP_VALUEHL
34c5 e5					push hl 
34c6			 
34c6					FORTH_DSP_POP 
34c6 cd 05 23			call macro_forth_dsp_pop 
34c9				endm 
# End of macro FORTH_DSP_POP
34c9 e1					pop hl 
34ca			 
34ca 7e					ld a, (hl) 
34cb 3d					dec a 
34cc 77					ld (hl), a 
34cd					 
34cd					NEXTW 
34cd c3 39 24			jp macro_next 
34d0				endm 
# End of macro NEXTW
34d0			.SBWSTORE: 
34d0				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
34d0 6f				db WORD_SYS_CORE+91             
34d1 ee 34			dw .ENDCORE            
34d3 05				db 4 + 1 
34d4 .. 00			db "1-2!",0              
34d9				endm 
# End of macro CWHEAD
34d9			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
34d9			 
34d9					FORTH_DSP_VALUEHL 
34d9 cd 4d 22			call macro_dsp_valuehl 
34dc				endm 
# End of macro FORTH_DSP_VALUEHL
34dc e5					push hl 
34dd			 
34dd					FORTH_DSP_POP 
34dd cd 05 23			call macro_forth_dsp_pop 
34e0				endm 
# End of macro FORTH_DSP_POP
34e0 e1					pop hl 
34e1			 
34e1 e5					push hl 
34e2			 
34e2 cd bb 23				call loadwordinhl 
34e5 2b					dec hl 
34e6			 
34e6 d1					pop de 
34e7 eb					ex de, hl 
34e8 73					ld (hl), e 
34e9 23					inc hl 
34ea 72					ld (hl), d 
34eb					 
34eb					NEXTW 
34eb c3 39 24			jp macro_next 
34ee				endm 
# End of macro NEXTW
34ee			.ENDCORE: 
34ee			 
34ee			; eof 
34ee			 
34ee			 
# End of file forth_words_core.asm
34ee			include "forth_words_flow.asm" 
34ee			 
34ee			; | ## Program Flow Words 
34ee			 
34ee			.IF: 
34ee				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
34ee 1e				db WORD_SYS_CORE+10             
34ef e3 35			dw .THEN            
34f1 03				db 2 + 1 
34f2 .. 00			db "IF",0              
34f5				endm 
# End of macro CWHEAD
34f5			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
34f5			; 
34f5					if DEBUG_FORTH_WORDS_KEY 
34f5						DMARK "IF." 
34f5 f5				push af  
34f6 3a 0a 35			ld a, (.dmark)  
34f9 32 a0 fd			ld (debug_mark),a  
34fc 3a 0b 35			ld a, (.dmark+1)  
34ff 32 a1 fd			ld (debug_mark+1),a  
3502 3a 0c 35			ld a, (.dmark+2)  
3505 32 a2 fd			ld (debug_mark+2),a  
3508 18 03			jr .pastdmark  
350a ..			.dmark: db "IF."  
350d f1			.pastdmark: pop af  
350e			endm  
# End of macro DMARK
350e						CALLMONITOR 
350e cd aa fd			call debug_vector  
3511				endm  
# End of macro CALLMONITOR
3511					endif 
3511			; eval TOS 
3511			 
3511				FORTH_DSP_VALUEHL 
3511 cd 4d 22			call macro_dsp_valuehl 
3514				endm 
# End of macro FORTH_DSP_VALUEHL
3514			 
3514			;	push hl 
3514				FORTH_DSP_POP 
3514 cd 05 23			call macro_forth_dsp_pop 
3517				endm 
# End of macro FORTH_DSP_POP
3517			;	pop hl 
3517			 
3517					if DEBUG_FORTH_WORDS 
3517						DMARK "IF1" 
3517 f5				push af  
3518 3a 2c 35			ld a, (.dmark)  
351b 32 a0 fd			ld (debug_mark),a  
351e 3a 2d 35			ld a, (.dmark+1)  
3521 32 a1 fd			ld (debug_mark+1),a  
3524 3a 2e 35			ld a, (.dmark+2)  
3527 32 a2 fd			ld (debug_mark+2),a  
352a 18 03			jr .pastdmark  
352c ..			.dmark: db "IF1"  
352f f1			.pastdmark: pop af  
3530			endm  
# End of macro DMARK
3530						CALLMONITOR 
3530 cd aa fd			call debug_vector  
3533				endm  
# End of macro CALLMONITOR
3533					endif 
3533 b7				or a        ; clear carry flag 
3534 11 00 00			ld de, 0 
3537 eb				ex de,hl 
3538 ed 52			sbc hl, de 
353a c2 c4 35			jp nz, .iftrue 
353d			 
353d					if DEBUG_FORTH_WORDS 
353d						DMARK "IF2" 
353d f5				push af  
353e 3a 52 35			ld a, (.dmark)  
3541 32 a0 fd			ld (debug_mark),a  
3544 3a 53 35			ld a, (.dmark+1)  
3547 32 a1 fd			ld (debug_mark+1),a  
354a 3a 54 35			ld a, (.dmark+2)  
354d 32 a2 fd			ld (debug_mark+2),a  
3550 18 03			jr .pastdmark  
3552 ..			.dmark: db "IF2"  
3555 f1			.pastdmark: pop af  
3556			endm  
# End of macro DMARK
3556						CALLMONITOR 
3556 cd aa fd			call debug_vector  
3559				endm  
# End of macro CALLMONITOR
3559					endif 
3559			 
3559			; if not true then skip to THEN 
3559			 
3559				; TODO get tok_ptr 
3559				; TODO consume toks until we get to THEN 
3559			 
3559 2a f7 f3			ld hl, (os_tok_ptr) 
355c					if DEBUG_FORTH_WORDS 
355c						DMARK "IF3" 
355c f5				push af  
355d 3a 71 35			ld a, (.dmark)  
3560 32 a0 fd			ld (debug_mark),a  
3563 3a 72 35			ld a, (.dmark+1)  
3566 32 a1 fd			ld (debug_mark+1),a  
3569 3a 73 35			ld a, (.dmark+2)  
356c 32 a2 fd			ld (debug_mark+2),a  
356f 18 03			jr .pastdmark  
3571 ..			.dmark: db "IF3"  
3574 f1			.pastdmark: pop af  
3575			endm  
# End of macro DMARK
3575						CALLMONITOR 
3575 cd aa fd			call debug_vector  
3578				endm  
# End of macro CALLMONITOR
3578						 
3578					endif 
3578 11 bf 35			ld de, .ifthen 
357b					if DEBUG_FORTH_WORDS 
357b						DMARK "IF4" 
357b f5				push af  
357c 3a 90 35			ld a, (.dmark)  
357f 32 a0 fd			ld (debug_mark),a  
3582 3a 91 35			ld a, (.dmark+1)  
3585 32 a1 fd			ld (debug_mark+1),a  
3588 3a 92 35			ld a, (.dmark+2)  
358b 32 a2 fd			ld (debug_mark+2),a  
358e 18 03			jr .pastdmark  
3590 ..			.dmark: db "IF4"  
3593 f1			.pastdmark: pop af  
3594			endm  
# End of macro DMARK
3594						CALLMONITOR 
3594 cd aa fd			call debug_vector  
3597				endm  
# End of macro CALLMONITOR
3597					endif 
3597 cd 40 25			call findnexttok  
359a			 
359a					if DEBUG_FORTH_WORDS 
359a						DMARK "IF5" 
359a f5				push af  
359b 3a af 35			ld a, (.dmark)  
359e 32 a0 fd			ld (debug_mark),a  
35a1 3a b0 35			ld a, (.dmark+1)  
35a4 32 a1 fd			ld (debug_mark+1),a  
35a7 3a b1 35			ld a, (.dmark+2)  
35aa 32 a2 fd			ld (debug_mark+2),a  
35ad 18 03			jr .pastdmark  
35af ..			.dmark: db "IF5"  
35b2 f1			.pastdmark: pop af  
35b3			endm  
# End of macro DMARK
35b3						CALLMONITOR 
35b3 cd aa fd			call debug_vector  
35b6				endm  
# End of macro CALLMONITOR
35b6					endif 
35b6				; TODO replace below with ; exec using tok_ptr 
35b6 22 f7 f3			ld (os_tok_ptr), hl 
35b9 c3 c2 24			jp exec1 
35bc				NEXTW 
35bc c3 39 24			jp macro_next 
35bf				endm 
# End of macro NEXTW
35bf			 
35bf .. 00		.ifthen:  db "THEN",0 
35c4			 
35c4			.iftrue:		 
35c4				; Exec next words normally 
35c4			 
35c4				; if true then exec following IF as normal 
35c4					if DEBUG_FORTH_WORDS 
35c4						DMARK "IFT" 
35c4 f5				push af  
35c5 3a d9 35			ld a, (.dmark)  
35c8 32 a0 fd			ld (debug_mark),a  
35cb 3a da 35			ld a, (.dmark+1)  
35ce 32 a1 fd			ld (debug_mark+1),a  
35d1 3a db 35			ld a, (.dmark+2)  
35d4 32 a2 fd			ld (debug_mark+2),a  
35d7 18 03			jr .pastdmark  
35d9 ..			.dmark: db "IFT"  
35dc f1			.pastdmark: pop af  
35dd			endm  
# End of macro DMARK
35dd						CALLMONITOR 
35dd cd aa fd			call debug_vector  
35e0				endm  
# End of macro CALLMONITOR
35e0					endif 
35e0			 
35e0					NEXTW 
35e0 c3 39 24			jp macro_next 
35e3				endm 
# End of macro NEXTW
35e3			.THEN: 
35e3				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
35e3 1f				db WORD_SYS_CORE+11             
35e4 0b 36			dw .ELSE            
35e6 05				db 4 + 1 
35e7 .. 00			db "THEN",0              
35ec				endm 
# End of macro CWHEAD
35ec			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
35ec					if DEBUG_FORTH_WORDS_KEY 
35ec						DMARK "THN" 
35ec f5				push af  
35ed 3a 01 36			ld a, (.dmark)  
35f0 32 a0 fd			ld (debug_mark),a  
35f3 3a 02 36			ld a, (.dmark+1)  
35f6 32 a1 fd			ld (debug_mark+1),a  
35f9 3a 03 36			ld a, (.dmark+2)  
35fc 32 a2 fd			ld (debug_mark+2),a  
35ff 18 03			jr .pastdmark  
3601 ..			.dmark: db "THN"  
3604 f1			.pastdmark: pop af  
3605			endm  
# End of macro DMARK
3605						CALLMONITOR 
3605 cd aa fd			call debug_vector  
3608				endm  
# End of macro CALLMONITOR
3608					endif 
3608					NEXTW 
3608 c3 39 24			jp macro_next 
360b				endm 
# End of macro NEXTW
360b			.ELSE: 
360b				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
360b 20				db WORD_SYS_CORE+12             
360c 33 36			dw .DO            
360e 03				db 2 + 1 
360f .. 00			db "ELSE",0              
3614				endm 
# End of macro CWHEAD
3614			; | ELSE ( -- ) Not supported - does nothing | TODO 
3614			 
3614					if DEBUG_FORTH_WORDS_KEY 
3614						DMARK "ELS" 
3614 f5				push af  
3615 3a 29 36			ld a, (.dmark)  
3618 32 a0 fd			ld (debug_mark),a  
361b 3a 2a 36			ld a, (.dmark+1)  
361e 32 a1 fd			ld (debug_mark+1),a  
3621 3a 2b 36			ld a, (.dmark+2)  
3624 32 a2 fd			ld (debug_mark+2),a  
3627 18 03			jr .pastdmark  
3629 ..			.dmark: db "ELS"  
362c f1			.pastdmark: pop af  
362d			endm  
# End of macro DMARK
362d						CALLMONITOR 
362d cd aa fd			call debug_vector  
3630				endm  
# End of macro CALLMONITOR
3630					endif 
3630			 
3630			 
3630					NEXTW 
3630 c3 39 24			jp macro_next 
3633				endm 
# End of macro NEXTW
3633			.DO: 
3633				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3633 21				db WORD_SYS_CORE+13             
3634 5a 37			dw .LOOP            
3636 03				db 2 + 1 
3637 .. 00			db "DO",0              
363a				endm 
# End of macro CWHEAD
363a			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
363a			 
363a					if DEBUG_FORTH_WORDS_KEY 
363a						DMARK "DO." 
363a f5				push af  
363b 3a 4f 36			ld a, (.dmark)  
363e 32 a0 fd			ld (debug_mark),a  
3641 3a 50 36			ld a, (.dmark+1)  
3644 32 a1 fd			ld (debug_mark+1),a  
3647 3a 51 36			ld a, (.dmark+2)  
364a 32 a2 fd			ld (debug_mark+2),a  
364d 18 03			jr .pastdmark  
364f ..			.dmark: db "DO."  
3652 f1			.pastdmark: pop af  
3653			endm  
# End of macro DMARK
3653						CALLMONITOR 
3653 cd aa fd			call debug_vector  
3656				endm  
# End of macro CALLMONITOR
3656					endif 
3656			;  push pc to rsp stack past the DO 
3656			 
3656 2a f7 f3				ld hl, (os_tok_ptr) 
3659 23					inc hl   ; D 
365a 23					inc hl  ; O 
365b 23					inc hl   ; null 
365c					if DEBUG_FORTH_WORDS 
365c						DMARK "DO2" 
365c f5				push af  
365d 3a 71 36			ld a, (.dmark)  
3660 32 a0 fd			ld (debug_mark),a  
3663 3a 72 36			ld a, (.dmark+1)  
3666 32 a1 fd			ld (debug_mark+1),a  
3669 3a 73 36			ld a, (.dmark+2)  
366c 32 a2 fd			ld (debug_mark+2),a  
366f 18 03			jr .pastdmark  
3671 ..			.dmark: db "DO2"  
3674 f1			.pastdmark: pop af  
3675			endm  
# End of macro DMARK
3675						CALLMONITOR 
3675 cd aa fd			call debug_vector  
3678				endm  
# End of macro CALLMONITOR
3678					endif 
3678					FORTH_RSP_NEXT 
3678 cd ef 1f			call macro_forth_rsp_next 
367b				endm 
# End of macro FORTH_RSP_NEXT
367b					if DEBUG_FORTH_WORDS 
367b						DMARK "DO3" 
367b f5				push af  
367c 3a 90 36			ld a, (.dmark)  
367f 32 a0 fd			ld (debug_mark),a  
3682 3a 91 36			ld a, (.dmark+1)  
3685 32 a1 fd			ld (debug_mark+1),a  
3688 3a 92 36			ld a, (.dmark+2)  
368b 32 a2 fd			ld (debug_mark+2),a  
368e 18 03			jr .pastdmark  
3690 ..			.dmark: db "DO3"  
3693 f1			.pastdmark: pop af  
3694			endm  
# End of macro DMARK
3694						CALLMONITOR 
3694 cd aa fd			call debug_vector  
3697				endm  
# End of macro CALLMONITOR
3697					endif 
3697			 
3697					;if DEBUG_FORTH_WORDS 
3697				;		push hl 
3697			;		endif  
3697			 
3697			; get counters from data stack 
3697			 
3697			 
3697					FORTH_DSP_VALUEHL 
3697 cd 4d 22			call macro_dsp_valuehl 
369a				endm 
# End of macro FORTH_DSP_VALUEHL
369a e5					push hl		 ; hl now has starting counter which needs to be tos 
369b			 
369b					if DEBUG_FORTH_WORDS 
369b						DMARK "DO4" 
369b f5				push af  
369c 3a b0 36			ld a, (.dmark)  
369f 32 a0 fd			ld (debug_mark),a  
36a2 3a b1 36			ld a, (.dmark+1)  
36a5 32 a1 fd			ld (debug_mark+1),a  
36a8 3a b2 36			ld a, (.dmark+2)  
36ab 32 a2 fd			ld (debug_mark+2),a  
36ae 18 03			jr .pastdmark  
36b0 ..			.dmark: db "DO4"  
36b3 f1			.pastdmark: pop af  
36b4			endm  
# End of macro DMARK
36b4						CALLMONITOR 
36b4 cd aa fd			call debug_vector  
36b7				endm  
# End of macro CALLMONITOR
36b7					endif 
36b7					FORTH_DSP_POP 
36b7 cd 05 23			call macro_forth_dsp_pop 
36ba				endm 
# End of macro FORTH_DSP_POP
36ba			 
36ba					if DEBUG_FORTH_WORDS 
36ba						DMARK "DO5" 
36ba f5				push af  
36bb 3a cf 36			ld a, (.dmark)  
36be 32 a0 fd			ld (debug_mark),a  
36c1 3a d0 36			ld a, (.dmark+1)  
36c4 32 a1 fd			ld (debug_mark+1),a  
36c7 3a d1 36			ld a, (.dmark+2)  
36ca 32 a2 fd			ld (debug_mark+2),a  
36cd 18 03			jr .pastdmark  
36cf ..			.dmark: db "DO5"  
36d2 f1			.pastdmark: pop af  
36d3			endm  
# End of macro DMARK
36d3						CALLMONITOR 
36d3 cd aa fd			call debug_vector  
36d6				endm  
# End of macro CALLMONITOR
36d6					endif 
36d6			 
36d6					FORTH_DSP_VALUEHL 
36d6 cd 4d 22			call macro_dsp_valuehl 
36d9				endm 
# End of macro FORTH_DSP_VALUEHL
36d9			;		push hl		 ; hl now has starting limit counter 
36d9			 
36d9					if DEBUG_FORTH_WORDS 
36d9						DMARK "DO6" 
36d9 f5				push af  
36da 3a ee 36			ld a, (.dmark)  
36dd 32 a0 fd			ld (debug_mark),a  
36e0 3a ef 36			ld a, (.dmark+1)  
36e3 32 a1 fd			ld (debug_mark+1),a  
36e6 3a f0 36			ld a, (.dmark+2)  
36e9 32 a2 fd			ld (debug_mark+2),a  
36ec 18 03			jr .pastdmark  
36ee ..			.dmark: db "DO6"  
36f1 f1			.pastdmark: pop af  
36f2			endm  
# End of macro DMARK
36f2						CALLMONITOR 
36f2 cd aa fd			call debug_vector  
36f5				endm  
# End of macro CALLMONITOR
36f5					endif 
36f5					FORTH_DSP_POP 
36f5 cd 05 23			call macro_forth_dsp_pop 
36f8				endm 
# End of macro FORTH_DSP_POP
36f8			 
36f8			; put counters on the loop stack 
36f8			 
36f8			;		pop hl			 ; limit counter 
36f8 d1					pop de			; start counter 
36f9			 
36f9					; push limit counter 
36f9			 
36f9					if DEBUG_FORTH_WORDS 
36f9						DMARK "DO7" 
36f9 f5				push af  
36fa 3a 0e 37			ld a, (.dmark)  
36fd 32 a0 fd			ld (debug_mark),a  
3700 3a 0f 37			ld a, (.dmark+1)  
3703 32 a1 fd			ld (debug_mark+1),a  
3706 3a 10 37			ld a, (.dmark+2)  
3709 32 a2 fd			ld (debug_mark+2),a  
370c 18 03			jr .pastdmark  
370e ..			.dmark: db "DO7"  
3711 f1			.pastdmark: pop af  
3712			endm  
# End of macro DMARK
3712						CALLMONITOR 
3712 cd aa fd			call debug_vector  
3715				endm  
# End of macro CALLMONITOR
3715					endif 
3715					FORTH_LOOP_NEXT 
3715 cd 7e 22			call macro_forth_loop_next 
3718				endm 
# End of macro FORTH_LOOP_NEXT
3718			 
3718					; push start counter 
3718			 
3718 eb					ex de, hl 
3719					if DEBUG_FORTH_WORDS 
3719						DMARK "DO7" 
3719 f5				push af  
371a 3a 2e 37			ld a, (.dmark)  
371d 32 a0 fd			ld (debug_mark),a  
3720 3a 2f 37			ld a, (.dmark+1)  
3723 32 a1 fd			ld (debug_mark+1),a  
3726 3a 30 37			ld a, (.dmark+2)  
3729 32 a2 fd			ld (debug_mark+2),a  
372c 18 03			jr .pastdmark  
372e ..			.dmark: db "DO7"  
3731 f1			.pastdmark: pop af  
3732			endm  
# End of macro DMARK
3732						CALLMONITOR 
3732 cd aa fd			call debug_vector  
3735				endm  
# End of macro CALLMONITOR
3735					endif 
3735					FORTH_LOOP_NEXT 
3735 cd 7e 22			call macro_forth_loop_next 
3738				endm 
# End of macro FORTH_LOOP_NEXT
3738			 
3738			 
3738					; init first round of I counter 
3738			 
3738 22 1b f4				ld (os_current_i), hl 
373b			 
373b					if DEBUG_FORTH_WORDS 
373b						DMARK "DO8" 
373b f5				push af  
373c 3a 50 37			ld a, (.dmark)  
373f 32 a0 fd			ld (debug_mark),a  
3742 3a 51 37			ld a, (.dmark+1)  
3745 32 a1 fd			ld (debug_mark+1),a  
3748 3a 52 37			ld a, (.dmark+2)  
374b 32 a2 fd			ld (debug_mark+2),a  
374e 18 03			jr .pastdmark  
3750 ..			.dmark: db "DO8"  
3753 f1			.pastdmark: pop af  
3754			endm  
# End of macro DMARK
3754						CALLMONITOR 
3754 cd aa fd			call debug_vector  
3757				endm  
# End of macro CALLMONITOR
3757					endif 
3757			 
3757					NEXTW 
3757 c3 39 24			jp macro_next 
375a				endm 
# End of macro NEXTW
375a			.LOOP: 
375a				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
375a 22				db WORD_SYS_CORE+14             
375b 72 38			dw .I            
375d 05				db 4 + 1 
375e .. 00			db "LOOP",0              
3763				endm 
# End of macro CWHEAD
3763			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3763			 
3763				; pop tos as current loop count to hl 
3763			 
3763				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3763			 
3763				FORTH_LOOP_TOS 
3763 cd b1 22			call macro_forth_loop_tos 
3766				endm 
# End of macro FORTH_LOOP_TOS
3766 e5				push hl 
3767			 
3767					if DEBUG_FORTH_WORDS_KEY 
3767						DMARK "LOP" 
3767 f5				push af  
3768 3a 7c 37			ld a, (.dmark)  
376b 32 a0 fd			ld (debug_mark),a  
376e 3a 7d 37			ld a, (.dmark+1)  
3771 32 a1 fd			ld (debug_mark+1),a  
3774 3a 7e 37			ld a, (.dmark+2)  
3777 32 a2 fd			ld (debug_mark+2),a  
377a 18 03			jr .pastdmark  
377c ..			.dmark: db "LOP"  
377f f1			.pastdmark: pop af  
3780			endm  
# End of macro DMARK
3780						CALLMONITOR 
3780 cd aa fd			call debug_vector  
3783				endm  
# End of macro CALLMONITOR
3783					endif 
3783				; next item on the stack is the limit. get it 
3783			 
3783			 
3783				FORTH_LOOP_POP 
3783 cd bb 22			call macro_forth_loop_pop 
3786				endm 
# End of macro FORTH_LOOP_POP
3786			 
3786				FORTH_LOOP_TOS 
3786 cd b1 22			call macro_forth_loop_tos 
3789				endm 
# End of macro FORTH_LOOP_TOS
3789			 
3789 d1				pop de		 ; de = i, hl = limit 
378a			 
378a					if DEBUG_FORTH_WORDS 
378a						DMARK "LP1" 
378a f5				push af  
378b 3a 9f 37			ld a, (.dmark)  
378e 32 a0 fd			ld (debug_mark),a  
3791 3a a0 37			ld a, (.dmark+1)  
3794 32 a1 fd			ld (debug_mark+1),a  
3797 3a a1 37			ld a, (.dmark+2)  
379a 32 a2 fd			ld (debug_mark+2),a  
379d 18 03			jr .pastdmark  
379f ..			.dmark: db "LP1"  
37a2 f1			.pastdmark: pop af  
37a3			endm  
# End of macro DMARK
37a3						CALLMONITOR 
37a3 cd aa fd			call debug_vector  
37a6				endm  
# End of macro CALLMONITOR
37a6					endif 
37a6			 
37a6				; go back to previous word 
37a6			 
37a6 d5				push de    ; save I for inc later 
37a7			 
37a7			 
37a7				; get limit 
37a7				;  is I at limit? 
37a7			 
37a7			 
37a7					if DEBUG_FORTH_WORDS 
37a7						DMARK "LP1" 
37a7 f5				push af  
37a8 3a bc 37			ld a, (.dmark)  
37ab 32 a0 fd			ld (debug_mark),a  
37ae 3a bd 37			ld a, (.dmark+1)  
37b1 32 a1 fd			ld (debug_mark+1),a  
37b4 3a be 37			ld a, (.dmark+2)  
37b7 32 a2 fd			ld (debug_mark+2),a  
37ba 18 03			jr .pastdmark  
37bc ..			.dmark: db "LP1"  
37bf f1			.pastdmark: pop af  
37c0			endm  
# End of macro DMARK
37c0						CALLMONITOR 
37c0 cd aa fd			call debug_vector  
37c3				endm  
# End of macro CALLMONITOR
37c3					endif 
37c3			 
37c3 ed 52			sbc hl, de 
37c5			 
37c5			 
37c5				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
37c5			 
37c5 20 26				jr nz, .loopnotdone 
37c7			 
37c7 e1				pop hl   ; get rid of saved I 
37c8				FORTH_LOOP_POP     ; get rid of limit 
37c8 cd bb 22			call macro_forth_loop_pop 
37cb				endm 
# End of macro FORTH_LOOP_POP
37cb			 
37cb				FORTH_RSP_POP     ; get rid of DO ptr 
37cb cd 10 20			call macro_forth_rsp_pop 
37ce				endm 
# End of macro FORTH_RSP_POP
37ce			 
37ce			if DEBUG_FORTH_WORDS 
37ce						DMARK "LP>" 
37ce f5				push af  
37cf 3a e3 37			ld a, (.dmark)  
37d2 32 a0 fd			ld (debug_mark),a  
37d5 3a e4 37			ld a, (.dmark+1)  
37d8 32 a1 fd			ld (debug_mark+1),a  
37db 3a e5 37			ld a, (.dmark+2)  
37de 32 a2 fd			ld (debug_mark+2),a  
37e1 18 03			jr .pastdmark  
37e3 ..			.dmark: db "LP>"  
37e6 f1			.pastdmark: pop af  
37e7			endm  
# End of macro DMARK
37e7				CALLMONITOR 
37e7 cd aa fd			call debug_vector  
37ea				endm  
# End of macro CALLMONITOR
37ea			endif 
37ea			 
37ea					NEXTW 
37ea c3 39 24			jp macro_next 
37ed				endm 
# End of macro NEXTW
37ed				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
37ed			 
37ed			.loopnotdone: 
37ed			 
37ed e1				pop hl    ; get I 
37ee 23				inc hl 
37ef			 
37ef			   	; save new I 
37ef			 
37ef			 
37ef					; set I counter 
37ef			 
37ef 22 1b f4				ld (os_current_i), hl 
37f2			 
37f2					if DEBUG_FORTH_WORDS 
37f2						DMARK "LPN" 
37f2 f5				push af  
37f3 3a 07 38			ld a, (.dmark)  
37f6 32 a0 fd			ld (debug_mark),a  
37f9 3a 08 38			ld a, (.dmark+1)  
37fc 32 a1 fd			ld (debug_mark+1),a  
37ff 3a 09 38			ld a, (.dmark+2)  
3802 32 a2 fd			ld (debug_mark+2),a  
3805 18 03			jr .pastdmark  
3807 ..			.dmark: db "LPN"  
380a f1			.pastdmark: pop af  
380b			endm  
# End of macro DMARK
380b					CALLMONITOR 
380b cd aa fd			call debug_vector  
380e				endm  
# End of macro CALLMONITOR
380e					endif 
380e					 
380e				FORTH_LOOP_NEXT 
380e cd 7e 22			call macro_forth_loop_next 
3811				endm 
# End of macro FORTH_LOOP_NEXT
3811			 
3811			 
3811					if DEBUG_FORTH_WORDS 
3811 eb						ex de,hl 
3812					endif 
3812			 
3812			;	; get DO ptr 
3812			; 
3812					if DEBUG_FORTH_WORDS 
3812						DMARK "LP7" 
3812 f5				push af  
3813 3a 27 38			ld a, (.dmark)  
3816 32 a0 fd			ld (debug_mark),a  
3819 3a 28 38			ld a, (.dmark+1)  
381c 32 a1 fd			ld (debug_mark+1),a  
381f 3a 29 38			ld a, (.dmark+2)  
3822 32 a2 fd			ld (debug_mark+2),a  
3825 18 03			jr .pastdmark  
3827 ..			.dmark: db "LP7"  
382a f1			.pastdmark: pop af  
382b			endm  
# End of macro DMARK
382b					CALLMONITOR 
382b cd aa fd			call debug_vector  
382e				endm  
# End of macro CALLMONITOR
382e					endif 
382e				FORTH_RSP_TOS 
382e cd 06 20			call macro_forth_rsp_tos 
3831				endm 
# End of macro FORTH_RSP_TOS
3831			 
3831					if DEBUG_FORTH_WORDS 
3831						DMARK "LP8" 
3831 f5				push af  
3832 3a 46 38			ld a, (.dmark)  
3835 32 a0 fd			ld (debug_mark),a  
3838 3a 47 38			ld a, (.dmark+1)  
383b 32 a1 fd			ld (debug_mark+1),a  
383e 3a 48 38			ld a, (.dmark+2)  
3841 32 a2 fd			ld (debug_mark+2),a  
3844 18 03			jr .pastdmark  
3846 ..			.dmark: db "LP8"  
3849 f1			.pastdmark: pop af  
384a			endm  
# End of macro DMARK
384a					CALLMONITOR 
384a cd aa fd			call debug_vector  
384d				endm  
# End of macro CALLMONITOR
384d					endif 
384d				;push hl 
384d			 
384d				; not going to DO any more 
384d				; get rid of the RSP pointer as DO will add it back in 
384d				;FORTH_RSP_POP 
384d				;pop hl 
384d			 
384d				;ld hl,(cli_ret_sp) 
384d				;ld e, (hl) 
384d				;inc hl 
384d				;ld d, (hl) 
384d				;ex de,hl 
384d 22 f7 f3			ld (os_tok_ptr), hl 
3850					if DEBUG_FORTH_WORDS 
3850						DMARK "LP<" 
3850 f5				push af  
3851 3a 65 38			ld a, (.dmark)  
3854 32 a0 fd			ld (debug_mark),a  
3857 3a 66 38			ld a, (.dmark+1)  
385a 32 a1 fd			ld (debug_mark+1),a  
385d 3a 67 38			ld a, (.dmark+2)  
3860 32 a2 fd			ld (debug_mark+2),a  
3863 18 03			jr .pastdmark  
3865 ..			.dmark: db "LP<"  
3868 f1			.pastdmark: pop af  
3869			endm  
# End of macro DMARK
3869					CALLMONITOR 
3869 cd aa fd			call debug_vector  
386c				endm  
# End of macro CALLMONITOR
386c				endif 
386c c3 c2 24			jp exec1 
386f			 
386f					 
386f			 
386f			 
386f					NEXTW 
386f c3 39 24			jp macro_next 
3872				endm 
# End of macro NEXTW
3872			.I:  
3872			 
3872				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3872 5e				db WORD_SYS_CORE+74             
3873 9d 38			dw .DLOOP            
3875 02				db 1 + 1 
3876 .. 00			db "I",0              
3878				endm 
# End of macro CWHEAD
3878			; | I ( -- ) Current loop counter | DONE 
3878					if DEBUG_FORTH_WORDS_KEY 
3878						DMARK "I.." 
3878 f5				push af  
3879 3a 8d 38			ld a, (.dmark)  
387c 32 a0 fd			ld (debug_mark),a  
387f 3a 8e 38			ld a, (.dmark+1)  
3882 32 a1 fd			ld (debug_mark+1),a  
3885 3a 8f 38			ld a, (.dmark+2)  
3888 32 a2 fd			ld (debug_mark+2),a  
388b 18 03			jr .pastdmark  
388d ..			.dmark: db "I.."  
3890 f1			.pastdmark: pop af  
3891			endm  
# End of macro DMARK
3891						CALLMONITOR 
3891 cd aa fd			call debug_vector  
3894				endm  
# End of macro CALLMONITOR
3894					endif 
3894			 
3894 2a 1b f4				ld hl,(os_current_i) 
3897 cd 48 20				call forth_push_numhl 
389a			 
389a					NEXTW 
389a c3 39 24			jp macro_next 
389d				endm 
# End of macro NEXTW
389d			.DLOOP: 
389d				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
389d 5f				db WORD_SYS_CORE+75             
389e 7e 39			dw .REPEAT            
38a0 06				db 5 + 1 
38a1 .. 00			db "-LOOP",0              
38a7				endm 
# End of macro CWHEAD
38a7			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
38a7				; pop tos as current loop count to hl 
38a7					if DEBUG_FORTH_WORDS_KEY 
38a7						DMARK "-LP" 
38a7 f5				push af  
38a8 3a bc 38			ld a, (.dmark)  
38ab 32 a0 fd			ld (debug_mark),a  
38ae 3a bd 38			ld a, (.dmark+1)  
38b1 32 a1 fd			ld (debug_mark+1),a  
38b4 3a be 38			ld a, (.dmark+2)  
38b7 32 a2 fd			ld (debug_mark+2),a  
38ba 18 03			jr .pastdmark  
38bc ..			.dmark: db "-LP"  
38bf f1			.pastdmark: pop af  
38c0			endm  
# End of macro DMARK
38c0						CALLMONITOR 
38c0 cd aa fd			call debug_vector  
38c3				endm  
# End of macro CALLMONITOR
38c3					endif 
38c3			 
38c3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
38c3			 
38c3				FORTH_LOOP_TOS 
38c3 cd b1 22			call macro_forth_loop_tos 
38c6				endm 
# End of macro FORTH_LOOP_TOS
38c6 e5				push hl 
38c7			 
38c7					if DEBUG_FORTH_WORDS 
38c7						DMARK "-LP" 
38c7 f5				push af  
38c8 3a dc 38			ld a, (.dmark)  
38cb 32 a0 fd			ld (debug_mark),a  
38ce 3a dd 38			ld a, (.dmark+1)  
38d1 32 a1 fd			ld (debug_mark+1),a  
38d4 3a de 38			ld a, (.dmark+2)  
38d7 32 a2 fd			ld (debug_mark+2),a  
38da 18 03			jr .pastdmark  
38dc ..			.dmark: db "-LP"  
38df f1			.pastdmark: pop af  
38e0			endm  
# End of macro DMARK
38e0						CALLMONITOR 
38e0 cd aa fd			call debug_vector  
38e3				endm  
# End of macro CALLMONITOR
38e3					endif 
38e3				; next item on the stack is the limit. get it 
38e3			 
38e3			 
38e3				FORTH_LOOP_POP 
38e3 cd bb 22			call macro_forth_loop_pop 
38e6				endm 
# End of macro FORTH_LOOP_POP
38e6			 
38e6				FORTH_LOOP_TOS 
38e6 cd b1 22			call macro_forth_loop_tos 
38e9				endm 
# End of macro FORTH_LOOP_TOS
38e9			 
38e9 d1				pop de		 ; de = i, hl = limit 
38ea			 
38ea					if DEBUG_FORTH_WORDS 
38ea						DMARK "-L1" 
38ea f5				push af  
38eb 3a ff 38			ld a, (.dmark)  
38ee 32 a0 fd			ld (debug_mark),a  
38f1 3a 00 39			ld a, (.dmark+1)  
38f4 32 a1 fd			ld (debug_mark+1),a  
38f7 3a 01 39			ld a, (.dmark+2)  
38fa 32 a2 fd			ld (debug_mark+2),a  
38fd 18 03			jr .pastdmark  
38ff ..			.dmark: db "-L1"  
3902 f1			.pastdmark: pop af  
3903			endm  
# End of macro DMARK
3903						CALLMONITOR 
3903 cd aa fd			call debug_vector  
3906				endm  
# End of macro CALLMONITOR
3906					endif 
3906			 
3906				; go back to previous word 
3906			 
3906 d5				push de    ; save I for inc later 
3907			 
3907			 
3907				; get limit 
3907				;  is I at limit? 
3907			 
3907			 
3907					if DEBUG_FORTH_WORDS 
3907						DMARK "-L1" 
3907 f5				push af  
3908 3a 1c 39			ld a, (.dmark)  
390b 32 a0 fd			ld (debug_mark),a  
390e 3a 1d 39			ld a, (.dmark+1)  
3911 32 a1 fd			ld (debug_mark+1),a  
3914 3a 1e 39			ld a, (.dmark+2)  
3917 32 a2 fd			ld (debug_mark+2),a  
391a 18 03			jr .pastdmark  
391c ..			.dmark: db "-L1"  
391f f1			.pastdmark: pop af  
3920			endm  
# End of macro DMARK
3920						CALLMONITOR 
3920 cd aa fd			call debug_vector  
3923				endm  
# End of macro CALLMONITOR
3923					endif 
3923			 
3923 ed 52			sbc hl, de 
3925			 
3925			 
3925				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3925			 
3925 20 26				jr nz, .mloopnotdone 
3927			 
3927 e1				pop hl   ; get rid of saved I 
3928				FORTH_LOOP_POP     ; get rid of limit 
3928 cd bb 22			call macro_forth_loop_pop 
392b				endm 
# End of macro FORTH_LOOP_POP
392b			 
392b				FORTH_RSP_POP     ; get rid of DO ptr 
392b cd 10 20			call macro_forth_rsp_pop 
392e				endm 
# End of macro FORTH_RSP_POP
392e			 
392e			if DEBUG_FORTH_WORDS 
392e						DMARK "-L>" 
392e f5				push af  
392f 3a 43 39			ld a, (.dmark)  
3932 32 a0 fd			ld (debug_mark),a  
3935 3a 44 39			ld a, (.dmark+1)  
3938 32 a1 fd			ld (debug_mark+1),a  
393b 3a 45 39			ld a, (.dmark+2)  
393e 32 a2 fd			ld (debug_mark+2),a  
3941 18 03			jr .pastdmark  
3943 ..			.dmark: db "-L>"  
3946 f1			.pastdmark: pop af  
3947			endm  
# End of macro DMARK
3947				CALLMONITOR 
3947 cd aa fd			call debug_vector  
394a				endm  
# End of macro CALLMONITOR
394a			endif 
394a			 
394a					NEXTW 
394a c3 39 24			jp macro_next 
394d				endm 
# End of macro NEXTW
394d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
394d			 
394d			.mloopnotdone: 
394d			 
394d e1				pop hl    ; get I 
394e 2b				dec hl 
394f			 
394f			   	; save new I 
394f			 
394f			 
394f					; set I counter 
394f			 
394f 22 1b f4				ld (os_current_i), hl 
3952			 
3952					 
3952				FORTH_LOOP_NEXT 
3952 cd 7e 22			call macro_forth_loop_next 
3955				endm 
# End of macro FORTH_LOOP_NEXT
3955			 
3955			 
3955					if DEBUG_FORTH_WORDS 
3955 eb						ex de,hl 
3956					endif 
3956			 
3956			;	; get DO ptr 
3956			; 
3956				FORTH_RSP_TOS 
3956 cd 06 20			call macro_forth_rsp_tos 
3959				endm 
# End of macro FORTH_RSP_TOS
3959			 
3959				;push hl 
3959			 
3959				; not going to DO any more 
3959				; get rid of the RSP pointer as DO will add it back in 
3959				;FORTH_RSP_POP 
3959				;pop hl 
3959			 
3959			 
3959 22 f7 f3			ld (os_tok_ptr), hl 
395c					if DEBUG_FORTH_WORDS 
395c						DMARK "-L<" 
395c f5				push af  
395d 3a 71 39			ld a, (.dmark)  
3960 32 a0 fd			ld (debug_mark),a  
3963 3a 72 39			ld a, (.dmark+1)  
3966 32 a1 fd			ld (debug_mark+1),a  
3969 3a 73 39			ld a, (.dmark+2)  
396c 32 a2 fd			ld (debug_mark+2),a  
396f 18 03			jr .pastdmark  
3971 ..			.dmark: db "-L<"  
3974 f1			.pastdmark: pop af  
3975			endm  
# End of macro DMARK
3975					CALLMONITOR 
3975 cd aa fd			call debug_vector  
3978				endm  
# End of macro CALLMONITOR
3978				endif 
3978 c3 c2 24			jp exec1 
397b			 
397b					 
397b			 
397b			 
397b			 
397b				NEXTW 
397b c3 39 24			jp macro_next 
397e				endm 
# End of macro NEXTW
397e			 
397e			 
397e			 
397e			 
397e			.REPEAT: 
397e				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
397e 71				db WORD_SYS_CORE+93             
397f d1 39			dw .UNTIL            
3981 06				db 5 + 1 
3982 .. 00			db "REPEAT",0              
3989				endm 
# End of macro CWHEAD
3989			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3989			;  push pc to rsp stack past the REPEAT 
3989					if DEBUG_FORTH_WORDS_KEY 
3989						DMARK "REP" 
3989 f5				push af  
398a 3a 9e 39			ld a, (.dmark)  
398d 32 a0 fd			ld (debug_mark),a  
3990 3a 9f 39			ld a, (.dmark+1)  
3993 32 a1 fd			ld (debug_mark+1),a  
3996 3a a0 39			ld a, (.dmark+2)  
3999 32 a2 fd			ld (debug_mark+2),a  
399c 18 03			jr .pastdmark  
399e ..			.dmark: db "REP"  
39a1 f1			.pastdmark: pop af  
39a2			endm  
# End of macro DMARK
39a2						CALLMONITOR 
39a2 cd aa fd			call debug_vector  
39a5				endm  
# End of macro CALLMONITOR
39a5					endif 
39a5			 
39a5 2a f7 f3				ld hl, (os_tok_ptr) 
39a8 23					inc hl   ; R 
39a9 23					inc hl  ; E 
39aa 23					inc hl   ; P 
39ab 23					inc hl   ; E 
39ac 23					inc hl   ; A 
39ad 23					inc hl   ; T 
39ae 23					inc hl   ; zero 
39af					FORTH_RSP_NEXT 
39af cd ef 1f			call macro_forth_rsp_next 
39b2				endm 
# End of macro FORTH_RSP_NEXT
39b2			 
39b2			 
39b2					if DEBUG_FORTH_WORDS 
39b2						DMARK "REP" 
39b2 f5				push af  
39b3 3a c7 39			ld a, (.dmark)  
39b6 32 a0 fd			ld (debug_mark),a  
39b9 3a c8 39			ld a, (.dmark+1)  
39bc 32 a1 fd			ld (debug_mark+1),a  
39bf 3a c9 39			ld a, (.dmark+2)  
39c2 32 a2 fd			ld (debug_mark+2),a  
39c5 18 03			jr .pastdmark  
39c7 ..			.dmark: db "REP"  
39ca f1			.pastdmark: pop af  
39cb			endm  
# End of macro DMARK
39cb						;pop bc    ; TODO BUG ?????? what is this for???? 
39cb						CALLMONITOR 
39cb cd aa fd			call debug_vector  
39ce				endm  
# End of macro CALLMONITOR
39ce					endif 
39ce			 
39ce					NEXTW 
39ce c3 39 24			jp macro_next 
39d1				endm 
# End of macro NEXTW
39d1			;	       NEXTW 
39d1			 
39d1			.UNTIL: 
39d1				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
39d1 72				db WORD_SYS_CORE+94             
39d2 68 3a			dw .ENDFLOW            
39d4 06				db 5 + 1 
39d5 .. 00			db "UNTIL",0              
39db				endm 
# End of macro CWHEAD
39db			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
39db			 
39db				; pop tos as check 
39db			 
39db				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
39db			 
39db				FORTH_DSP_VALUEHL 
39db cd 4d 22			call macro_dsp_valuehl 
39de				endm 
# End of macro FORTH_DSP_VALUEHL
39de			 
39de					if DEBUG_FORTH_WORDS_KEY 
39de						DMARK "UNT" 
39de f5				push af  
39df 3a f3 39			ld a, (.dmark)  
39e2 32 a0 fd			ld (debug_mark),a  
39e5 3a f4 39			ld a, (.dmark+1)  
39e8 32 a1 fd			ld (debug_mark+1),a  
39eb 3a f5 39			ld a, (.dmark+2)  
39ee 32 a2 fd			ld (debug_mark+2),a  
39f1 18 03			jr .pastdmark  
39f3 ..			.dmark: db "UNT"  
39f6 f1			.pastdmark: pop af  
39f7			endm  
# End of macro DMARK
39f7						CALLMONITOR 
39f7 cd aa fd			call debug_vector  
39fa				endm  
# End of macro CALLMONITOR
39fa					endif 
39fa			 
39fa			;	push hl 
39fa				FORTH_DSP_POP 
39fa cd 05 23			call macro_forth_dsp_pop 
39fd				endm 
# End of macro FORTH_DSP_POP
39fd			 
39fd			;	pop hl 
39fd			 
39fd				; test if true 
39fd			 
39fd cd 07 10			call ishlzero 
3a00			;	ld a,l 
3a00			;	add h 
3a00			; 
3a00			;	cp 0 
3a00			 
3a00 20 3e			jr nz, .untilnotdone 
3a02			 
3a02					if DEBUG_FORTH_WORDS 
3a02						DMARK "UNf" 
3a02 f5				push af  
3a03 3a 17 3a			ld a, (.dmark)  
3a06 32 a0 fd			ld (debug_mark),a  
3a09 3a 18 3a			ld a, (.dmark+1)  
3a0c 32 a1 fd			ld (debug_mark+1),a  
3a0f 3a 19 3a			ld a, (.dmark+2)  
3a12 32 a2 fd			ld (debug_mark+2),a  
3a15 18 03			jr .pastdmark  
3a17 ..			.dmark: db "UNf"  
3a1a f1			.pastdmark: pop af  
3a1b			endm  
# End of macro DMARK
3a1b						CALLMONITOR 
3a1b cd aa fd			call debug_vector  
3a1e				endm  
# End of macro CALLMONITOR
3a1e					endif 
3a1e			 
3a1e			 
3a1e			 
3a1e				FORTH_RSP_POP     ; get rid of DO ptr 
3a1e cd 10 20			call macro_forth_rsp_pop 
3a21				endm 
# End of macro FORTH_RSP_POP
3a21			 
3a21			if DEBUG_FORTH_WORDS 
3a21						DMARK "UN>" 
3a21 f5				push af  
3a22 3a 36 3a			ld a, (.dmark)  
3a25 32 a0 fd			ld (debug_mark),a  
3a28 3a 37 3a			ld a, (.dmark+1)  
3a2b 32 a1 fd			ld (debug_mark+1),a  
3a2e 3a 38 3a			ld a, (.dmark+2)  
3a31 32 a2 fd			ld (debug_mark+2),a  
3a34 18 03			jr .pastdmark  
3a36 ..			.dmark: db "UN>"  
3a39 f1			.pastdmark: pop af  
3a3a			endm  
# End of macro DMARK
3a3a				CALLMONITOR 
3a3a cd aa fd			call debug_vector  
3a3d				endm  
# End of macro CALLMONITOR
3a3d			endif 
3a3d			 
3a3d					NEXTW 
3a3d c3 39 24			jp macro_next 
3a40				endm 
# End of macro NEXTW
3a40				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3a40			 
3a40			.untilnotdone: 
3a40			 
3a40			 
3a40			;	; get DO ptr 
3a40			; 
3a40				FORTH_RSP_TOS 
3a40 cd 06 20			call macro_forth_rsp_tos 
3a43				endm 
# End of macro FORTH_RSP_TOS
3a43			 
3a43				;push hl 
3a43			 
3a43				; not going to DO any more 
3a43				; get rid of the RSP pointer as DO will add it back in 
3a43				;FORTH_RSP_POP 
3a43				;pop hl 
3a43			 
3a43			 
3a43 22 f7 f3			ld (os_tok_ptr), hl 
3a46					if DEBUG_FORTH_WORDS 
3a46						DMARK "UN<" 
3a46 f5				push af  
3a47 3a 5b 3a			ld a, (.dmark)  
3a4a 32 a0 fd			ld (debug_mark),a  
3a4d 3a 5c 3a			ld a, (.dmark+1)  
3a50 32 a1 fd			ld (debug_mark+1),a  
3a53 3a 5d 3a			ld a, (.dmark+2)  
3a56 32 a2 fd			ld (debug_mark+2),a  
3a59 18 03			jr .pastdmark  
3a5b ..			.dmark: db "UN<"  
3a5e f1			.pastdmark: pop af  
3a5f			endm  
# End of macro DMARK
3a5f					CALLMONITOR 
3a5f cd aa fd			call debug_vector  
3a62				endm  
# End of macro CALLMONITOR
3a62				endif 
3a62 c3 c2 24			jp exec1 
3a65			 
3a65					 
3a65			 
3a65			 
3a65					NEXTW 
3a65 c3 39 24			jp macro_next 
3a68				endm 
# End of macro NEXTW
3a68			 
3a68			 
3a68			.ENDFLOW: 
3a68			 
3a68			; eof 
3a68			 
# End of file forth_words_flow.asm
3a68			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3a68			include "forth_words_logic.asm" 
3a68			 
3a68			; | ## Logic Words 
3a68			 
3a68			.NOT: 
3a68				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3a68 2d				db WORD_SYS_CORE+25             
3a69 b0 3a			dw .IS            
3a6b 04				db 3 + 1 
3a6c .. 00			db "NOT",0              
3a70				endm 
# End of macro CWHEAD
3a70			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3a70					if DEBUG_FORTH_WORDS_KEY 
3a70						DMARK "NOT" 
3a70 f5				push af  
3a71 3a 85 3a			ld a, (.dmark)  
3a74 32 a0 fd			ld (debug_mark),a  
3a77 3a 86 3a			ld a, (.dmark+1)  
3a7a 32 a1 fd			ld (debug_mark+1),a  
3a7d 3a 87 3a			ld a, (.dmark+2)  
3a80 32 a2 fd			ld (debug_mark+2),a  
3a83 18 03			jr .pastdmark  
3a85 ..			.dmark: db "NOT"  
3a88 f1			.pastdmark: pop af  
3a89			endm  
# End of macro DMARK
3a89						CALLMONITOR 
3a89 cd aa fd			call debug_vector  
3a8c				endm  
# End of macro CALLMONITOR
3a8c					endif 
3a8c					FORTH_DSP 
3a8c cd 13 22			call macro_forth_dsp 
3a8f				endm 
# End of macro FORTH_DSP
3a8f 7e					ld a,(hl)	; get type of value on TOS 
3a90 fe 02				cp DS_TYPE_INUM  
3a92 28 03				jr z, .noti 
3a94					NEXTW 
3a94 c3 39 24			jp macro_next 
3a97				endm 
# End of macro NEXTW
3a97			.noti:          FORTH_DSP_VALUEHL 
3a97 cd 4d 22			call macro_dsp_valuehl 
3a9a				endm 
# End of macro FORTH_DSP_VALUEHL
3a9a			;		push hl 
3a9a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a9a cd 05 23			call macro_forth_dsp_pop 
3a9d				endm 
# End of macro FORTH_DSP_POP
3a9d			;		pop hl 
3a9d 3e 00				ld a,0 
3a9f bd					cp l 
3aa0 28 04				jr z, .not2t 
3aa2 2e 00				ld l, 0 
3aa4 18 02				jr .notip 
3aa6			 
3aa6 2e ff		.not2t:		ld l, 255 
3aa8			 
3aa8 26 00		.notip:		ld h, 0	 
3aaa			 
3aaa cd 48 20				call forth_push_numhl 
3aad					NEXTW 
3aad c3 39 24			jp macro_next 
3ab0				endm 
# End of macro NEXTW
3ab0			 
3ab0			.IS: 
3ab0				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3ab0 2d				db WORD_SYS_CORE+25             
3ab1 d6 3a			dw .LZERO            
3ab3 03				db 2 + 1 
3ab4 .. 00			db "IS",0              
3ab7				endm 
# End of macro CWHEAD
3ab7			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3ab7					if DEBUG_FORTH_WORDS_KEY 
3ab7						DMARK "IS." 
3ab7 f5				push af  
3ab8 3a cc 3a			ld a, (.dmark)  
3abb 32 a0 fd			ld (debug_mark),a  
3abe 3a cd 3a			ld a, (.dmark+1)  
3ac1 32 a1 fd			ld (debug_mark+1),a  
3ac4 3a ce 3a			ld a, (.dmark+2)  
3ac7 32 a2 fd			ld (debug_mark+2),a  
3aca 18 03			jr .pastdmark  
3acc ..			.dmark: db "IS."  
3acf f1			.pastdmark: pop af  
3ad0			endm  
# End of macro DMARK
3ad0						CALLMONITOR 
3ad0 cd aa fd			call debug_vector  
3ad3				endm  
# End of macro CALLMONITOR
3ad3					endif 
3ad3					NEXTW 
3ad3 c3 39 24			jp macro_next 
3ad6				endm 
# End of macro NEXTW
3ad6			.LZERO: 
3ad6				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3ad6 2d				db WORD_SYS_CORE+25             
3ad7 e0 3a			dw .TZERO            
3ad9 03				db 2 + 1 
3ada .. 00			db "0<",0              
3add				endm 
# End of macro CWHEAD
3add			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3add					NEXTW 
3add c3 39 24			jp macro_next 
3ae0				endm 
# End of macro NEXTW
3ae0			.TZERO: 
3ae0				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3ae0 2e				db WORD_SYS_CORE+26             
3ae1 27 3b			dw .LESS            
3ae3 03				db 2 + 1 
3ae4 .. 00			db "0=",0              
3ae7				endm 
# End of macro CWHEAD
3ae7			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3ae7				; TODO add floating point number detection 
3ae7					;v5 FORTH_DSP_VALUE 
3ae7					if DEBUG_FORTH_WORDS_KEY 
3ae7						DMARK "0=." 
3ae7 f5				push af  
3ae8 3a fc 3a			ld a, (.dmark)  
3aeb 32 a0 fd			ld (debug_mark),a  
3aee 3a fd 3a			ld a, (.dmark+1)  
3af1 32 a1 fd			ld (debug_mark+1),a  
3af4 3a fe 3a			ld a, (.dmark+2)  
3af7 32 a2 fd			ld (debug_mark+2),a  
3afa 18 03			jr .pastdmark  
3afc ..			.dmark: db "0=."  
3aff f1			.pastdmark: pop af  
3b00			endm  
# End of macro DMARK
3b00						CALLMONITOR 
3b00 cd aa fd			call debug_vector  
3b03				endm  
# End of macro CALLMONITOR
3b03					endif 
3b03					FORTH_DSP 
3b03 cd 13 22			call macro_forth_dsp 
3b06				endm 
# End of macro FORTH_DSP
3b06 7e					ld a,(hl)	; get type of value on TOS 
3b07 fe 02				cp DS_TYPE_INUM  
3b09 28 00				jr z, .tz_inum 
3b0b			 
3b0b				if FORTH_ENABLE_FLOATMATH 
3b0b					jr .tz_done 
3b0b			 
3b0b				endif 
3b0b					 
3b0b			 
3b0b			.tz_inum: 
3b0b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b0b cd 4d 22			call macro_dsp_valuehl 
3b0e				endm 
# End of macro FORTH_DSP_VALUEHL
3b0e			 
3b0e			;		push hl 
3b0e			 
3b0e					; destroy value TOS 
3b0e			 
3b0e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b0e cd 05 23			call macro_forth_dsp_pop 
3b11				endm 
# End of macro FORTH_DSP_POP
3b11			 
3b11			;		pop hl 
3b11			 
3b11 3e 00				ld a,0 
3b13			 
3b13 bd					cp l 
3b14 20 08				jr nz, .tz_notzero 
3b16			 
3b16 bc					cp h 
3b17			 
3b17 20 05				jr nz, .tz_notzero 
3b19			 
3b19			 
3b19 21 01 00				ld hl, FORTH_TRUE 
3b1c 18 03				jr .tz_done 
3b1e			 
3b1e 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3b21			 
3b21					; push value back onto stack for another op etc 
3b21			 
3b21			.tz_done: 
3b21 cd 48 20				call forth_push_numhl 
3b24			 
3b24					NEXTW 
3b24 c3 39 24			jp macro_next 
3b27				endm 
# End of macro NEXTW
3b27			.LESS: 
3b27				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3b27 2f				db WORD_SYS_CORE+27             
3b28 90 3b			dw .GT            
3b2a 02				db 1 + 1 
3b2b .. 00			db "<",0              
3b2d				endm 
# End of macro CWHEAD
3b2d			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3b2d				; TODO add floating point number detection 
3b2d					if DEBUG_FORTH_WORDS_KEY 
3b2d						DMARK "LES" 
3b2d f5				push af  
3b2e 3a 42 3b			ld a, (.dmark)  
3b31 32 a0 fd			ld (debug_mark),a  
3b34 3a 43 3b			ld a, (.dmark+1)  
3b37 32 a1 fd			ld (debug_mark+1),a  
3b3a 3a 44 3b			ld a, (.dmark+2)  
3b3d 32 a2 fd			ld (debug_mark+2),a  
3b40 18 03			jr .pastdmark  
3b42 ..			.dmark: db "LES"  
3b45 f1			.pastdmark: pop af  
3b46			endm  
# End of macro DMARK
3b46						CALLMONITOR 
3b46 cd aa fd			call debug_vector  
3b49				endm  
# End of macro CALLMONITOR
3b49					endif 
3b49					FORTH_DSP 
3b49 cd 13 22			call macro_forth_dsp 
3b4c				endm 
# End of macro FORTH_DSP
3b4c					;v5 FORTH_DSP_VALUE 
3b4c 7e					ld a,(hl)	; get type of value on TOS 
3b4d fe 02				cp DS_TYPE_INUM  
3b4f 28 00				jr z, .less_inum 
3b51			 
3b51				if FORTH_ENABLE_FLOATMATH 
3b51					jr .less_done 
3b51			 
3b51				endif 
3b51					 
3b51			 
3b51			.less_inum: 
3b51					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b51 cd 4d 22			call macro_dsp_valuehl 
3b54				endm 
# End of macro FORTH_DSP_VALUEHL
3b54			 
3b54 e5					push hl  ; u2 
3b55			 
3b55					; destroy value TOS 
3b55			 
3b55					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b55 cd 05 23			call macro_forth_dsp_pop 
3b58				endm 
# End of macro FORTH_DSP_POP
3b58			 
3b58			 
3b58					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b58 cd 4d 22			call macro_dsp_valuehl 
3b5b				endm 
# End of macro FORTH_DSP_VALUEHL
3b5b			 
3b5b e5					push hl    ; u1 
3b5c			 
3b5c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b5c cd 05 23			call macro_forth_dsp_pop 
3b5f				endm 
# End of macro FORTH_DSP_POP
3b5f			 
3b5f			 
3b5f b7			 or a      ;clear carry flag 
3b60 01 00 00		 ld bc, FORTH_FALSE 
3b63 e1			  pop hl    ; u1 
3b64 d1			  pop de    ; u2 
3b65 ed 52		  sbc hl,de 
3b67 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3b69			 
3b69 01 01 00		 ld bc, FORTH_TRUE 
3b6c			.lscont:  
3b6c c5					push bc 
3b6d e1					pop hl 
3b6e			 
3b6e					if DEBUG_FORTH_WORDS 
3b6e						DMARK "LT1" 
3b6e f5				push af  
3b6f 3a 83 3b			ld a, (.dmark)  
3b72 32 a0 fd			ld (debug_mark),a  
3b75 3a 84 3b			ld a, (.dmark+1)  
3b78 32 a1 fd			ld (debug_mark+1),a  
3b7b 3a 85 3b			ld a, (.dmark+2)  
3b7e 32 a2 fd			ld (debug_mark+2),a  
3b81 18 03			jr .pastdmark  
3b83 ..			.dmark: db "LT1"  
3b86 f1			.pastdmark: pop af  
3b87			endm  
# End of macro DMARK
3b87						CALLMONITOR 
3b87 cd aa fd			call debug_vector  
3b8a				endm  
# End of macro CALLMONITOR
3b8a					endif 
3b8a cd 48 20				call forth_push_numhl 
3b8d			 
3b8d					NEXTW 
3b8d c3 39 24			jp macro_next 
3b90				endm 
# End of macro NEXTW
3b90			.GT: 
3b90				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3b90 30				db WORD_SYS_CORE+28             
3b91 f9 3b			dw .EQUAL            
3b93 02				db 1 + 1 
3b94 .. 00			db ">",0              
3b96				endm 
# End of macro CWHEAD
3b96			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3b96				; TODO add floating point number detection 
3b96					if DEBUG_FORTH_WORDS_KEY 
3b96						DMARK "GRT" 
3b96 f5				push af  
3b97 3a ab 3b			ld a, (.dmark)  
3b9a 32 a0 fd			ld (debug_mark),a  
3b9d 3a ac 3b			ld a, (.dmark+1)  
3ba0 32 a1 fd			ld (debug_mark+1),a  
3ba3 3a ad 3b			ld a, (.dmark+2)  
3ba6 32 a2 fd			ld (debug_mark+2),a  
3ba9 18 03			jr .pastdmark  
3bab ..			.dmark: db "GRT"  
3bae f1			.pastdmark: pop af  
3baf			endm  
# End of macro DMARK
3baf						CALLMONITOR 
3baf cd aa fd			call debug_vector  
3bb2				endm  
# End of macro CALLMONITOR
3bb2					endif 
3bb2					FORTH_DSP 
3bb2 cd 13 22			call macro_forth_dsp 
3bb5				endm 
# End of macro FORTH_DSP
3bb5					;FORTH_DSP_VALUE 
3bb5 7e					ld a,(hl)	; get type of value on TOS 
3bb6 fe 02				cp DS_TYPE_INUM  
3bb8 28 00				jr z, .gt_inum 
3bba			 
3bba				if FORTH_ENABLE_FLOATMATH 
3bba					jr .gt_done 
3bba			 
3bba				endif 
3bba					 
3bba			 
3bba			.gt_inum: 
3bba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bba cd 4d 22			call macro_dsp_valuehl 
3bbd				endm 
# End of macro FORTH_DSP_VALUEHL
3bbd			 
3bbd e5					push hl  ; u2 
3bbe			 
3bbe					; destroy value TOS 
3bbe			 
3bbe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bbe cd 05 23			call macro_forth_dsp_pop 
3bc1				endm 
# End of macro FORTH_DSP_POP
3bc1			 
3bc1			 
3bc1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bc1 cd 4d 22			call macro_dsp_valuehl 
3bc4				endm 
# End of macro FORTH_DSP_VALUEHL
3bc4			 
3bc4 e5					push hl    ; u1 
3bc5			 
3bc5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bc5 cd 05 23			call macro_forth_dsp_pop 
3bc8				endm 
# End of macro FORTH_DSP_POP
3bc8			 
3bc8			 
3bc8 b7			 or a      ;clear carry flag 
3bc9 01 00 00		 ld bc, FORTH_FALSE 
3bcc e1			  pop hl    ; u1 
3bcd d1			  pop de    ; u2 
3bce ed 52		  sbc hl,de 
3bd0 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3bd2			 
3bd2 01 01 00		 ld bc, FORTH_TRUE 
3bd5			.gtcont:  
3bd5 c5					push bc 
3bd6 e1					pop hl 
3bd7			 
3bd7					if DEBUG_FORTH_WORDS 
3bd7						DMARK "GT1" 
3bd7 f5				push af  
3bd8 3a ec 3b			ld a, (.dmark)  
3bdb 32 a0 fd			ld (debug_mark),a  
3bde 3a ed 3b			ld a, (.dmark+1)  
3be1 32 a1 fd			ld (debug_mark+1),a  
3be4 3a ee 3b			ld a, (.dmark+2)  
3be7 32 a2 fd			ld (debug_mark+2),a  
3bea 18 03			jr .pastdmark  
3bec ..			.dmark: db "GT1"  
3bef f1			.pastdmark: pop af  
3bf0			endm  
# End of macro DMARK
3bf0						CALLMONITOR 
3bf0 cd aa fd			call debug_vector  
3bf3				endm  
# End of macro CALLMONITOR
3bf3					endif 
3bf3 cd 48 20				call forth_push_numhl 
3bf6			 
3bf6					NEXTW 
3bf6 c3 39 24			jp macro_next 
3bf9				endm 
# End of macro NEXTW
3bf9			.EQUAL: 
3bf9				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3bf9 31				db WORD_SYS_CORE+29             
3bfa 64 3c			dw .ENDLOGIC            
3bfc 02				db 1 + 1 
3bfd .. 00			db "=",0              
3bff				endm 
# End of macro CWHEAD
3bff			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3bff				; TODO add floating point number detection 
3bff					if DEBUG_FORTH_WORDS_KEY 
3bff						DMARK "EQ." 
3bff f5				push af  
3c00 3a 14 3c			ld a, (.dmark)  
3c03 32 a0 fd			ld (debug_mark),a  
3c06 3a 15 3c			ld a, (.dmark+1)  
3c09 32 a1 fd			ld (debug_mark+1),a  
3c0c 3a 16 3c			ld a, (.dmark+2)  
3c0f 32 a2 fd			ld (debug_mark+2),a  
3c12 18 03			jr .pastdmark  
3c14 ..			.dmark: db "EQ."  
3c17 f1			.pastdmark: pop af  
3c18			endm  
# End of macro DMARK
3c18						CALLMONITOR 
3c18 cd aa fd			call debug_vector  
3c1b				endm  
# End of macro CALLMONITOR
3c1b					endif 
3c1b					FORTH_DSP 
3c1b cd 13 22			call macro_forth_dsp 
3c1e				endm 
# End of macro FORTH_DSP
3c1e					;v5 FORTH_DSP_VALUE 
3c1e 7e					ld a,(hl)	; get type of value on TOS 
3c1f fe 02				cp DS_TYPE_INUM  
3c21 28 00				jr z, .eq_inum 
3c23			 
3c23				if FORTH_ENABLE_FLOATMATH 
3c23					jr .eq_done 
3c23			 
3c23				endif 
3c23					 
3c23			 
3c23			.eq_inum: 
3c23					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c23 cd 4d 22			call macro_dsp_valuehl 
3c26				endm 
# End of macro FORTH_DSP_VALUEHL
3c26			 
3c26 e5					push hl 
3c27			 
3c27					; destroy value TOS 
3c27			 
3c27					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c27 cd 05 23			call macro_forth_dsp_pop 
3c2a				endm 
# End of macro FORTH_DSP_POP
3c2a			 
3c2a			 
3c2a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c2a cd 4d 22			call macro_dsp_valuehl 
3c2d				endm 
# End of macro FORTH_DSP_VALUEHL
3c2d			 
3c2d					; one value on hl get other one back 
3c2d			 
3c2d e5					push hl 
3c2e			 
3c2e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c2e cd 05 23			call macro_forth_dsp_pop 
3c31				endm 
# End of macro FORTH_DSP_POP
3c31			 
3c31 0e 00				ld c, FORTH_FALSE 
3c33			 
3c33 e1					pop hl 
3c34 d1					pop de 
3c35			 
3c35 7b					ld a, e 
3c36 bd					cp l 
3c37			 
3c37 20 06				jr nz, .eq_done 
3c39			 
3c39 7a					ld a, d 
3c3a bc					cp h 
3c3b			 
3c3b 20 02				jr nz, .eq_done 
3c3d			 
3c3d 0e 01				ld c, FORTH_TRUE 
3c3f					 
3c3f			 
3c3f			 
3c3f			.eq_done: 
3c3f			 
3c3f					; TODO push value back onto stack for another op etc 
3c3f			 
3c3f 26 00				ld h, 0 
3c41 69					ld l, c 
3c42					if DEBUG_FORTH_WORDS 
3c42						DMARK "EQ1" 
3c42 f5				push af  
3c43 3a 57 3c			ld a, (.dmark)  
3c46 32 a0 fd			ld (debug_mark),a  
3c49 3a 58 3c			ld a, (.dmark+1)  
3c4c 32 a1 fd			ld (debug_mark+1),a  
3c4f 3a 59 3c			ld a, (.dmark+2)  
3c52 32 a2 fd			ld (debug_mark+2),a  
3c55 18 03			jr .pastdmark  
3c57 ..			.dmark: db "EQ1"  
3c5a f1			.pastdmark: pop af  
3c5b			endm  
# End of macro DMARK
3c5b						CALLMONITOR 
3c5b cd aa fd			call debug_vector  
3c5e				endm  
# End of macro CALLMONITOR
3c5e					endif 
3c5e cd 48 20				call forth_push_numhl 
3c61			 
3c61					NEXTW 
3c61 c3 39 24			jp macro_next 
3c64				endm 
# End of macro NEXTW
3c64			 
3c64			 
3c64			.ENDLOGIC: 
3c64			; eof 
3c64			 
3c64			 
# End of file forth_words_logic.asm
3c64			include "forth_words_maths.asm" 
3c64			 
3c64			; | ## Maths Words 
3c64			 
3c64			.PLUS:	 
3c64				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3c64 15				db WORD_SYS_CORE+1             
3c65 c2 3c			dw .NEG            
3c67 02				db 1 + 1 
3c68 .. 00			db "+",0              
3c6a				endm 
# End of macro CWHEAD
3c6a			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3c6a					if DEBUG_FORTH_WORDS_KEY 
3c6a						DMARK "PLU" 
3c6a f5				push af  
3c6b 3a 7f 3c			ld a, (.dmark)  
3c6e 32 a0 fd			ld (debug_mark),a  
3c71 3a 80 3c			ld a, (.dmark+1)  
3c74 32 a1 fd			ld (debug_mark+1),a  
3c77 3a 81 3c			ld a, (.dmark+2)  
3c7a 32 a2 fd			ld (debug_mark+2),a  
3c7d 18 03			jr .pastdmark  
3c7f ..			.dmark: db "PLU"  
3c82 f1			.pastdmark: pop af  
3c83			endm  
# End of macro DMARK
3c83						CALLMONITOR 
3c83 cd aa fd			call debug_vector  
3c86				endm  
# End of macro CALLMONITOR
3c86					endif 
3c86					; add top two values and push back result 
3c86			 
3c86					;for v5 FORTH_DSP_VALUE 
3c86					FORTH_DSP 
3c86 cd 13 22			call macro_forth_dsp 
3c89				endm 
# End of macro FORTH_DSP
3c89 7e					ld a,(hl)	; get type of value on TOS 
3c8a fe 02				cp DS_TYPE_INUM  
3c8c 28 03				jr z, .dot_inum 
3c8e			 
3c8e					NEXTW 
3c8e c3 39 24			jp macro_next 
3c91				endm 
# End of macro NEXTW
3c91			 
3c91			; float maths 
3c91			 
3c91				if FORTH_ENABLE_FLOATMATH 
3c91						inc hl      ; now at start of numeric as string 
3c91			 
3c91					if DEBUG_FORTH_MATHS 
3c91						DMARK "ADD" 
3c91				CALLMONITOR 
3c91					endif 
3c91			 
3c91					;ld ix, hl 
3c91					call CON 
3c91			 
3c91			 
3c91					push hl 
3c91					 
3c91					 
3c91			 
3c91						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3c91			 
3c91					; get next number 
3c91			 
3c91						FORTH_DSP_VALUE 
3c91			 
3c91						inc hl      ; now at start of numeric as string 
3c91			 
3c91					;ld ix, hl 
3c91					call CON 
3c91			 
3c91					push hl 
3c91			 
3c91			 
3c91						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c91			 
3c91						; TODO do add 
3c91			 
3c91						call IADD 
3c91			 
3c91						; TODO get result back as ascii 
3c91			 
3c91						; TODO push result  
3c91			 
3c91			 
3c91			 
3c91						jr .dot_done 
3c91				endif 
3c91			 
3c91			.dot_inum: 
3c91			 
3c91			 
3c91					if DEBUG_FORTH_DOT 
3c91						DMARK "+IT" 
3c91 f5				push af  
3c92 3a a6 3c			ld a, (.dmark)  
3c95 32 a0 fd			ld (debug_mark),a  
3c98 3a a7 3c			ld a, (.dmark+1)  
3c9b 32 a1 fd			ld (debug_mark+1),a  
3c9e 3a a8 3c			ld a, (.dmark+2)  
3ca1 32 a2 fd			ld (debug_mark+2),a  
3ca4 18 03			jr .pastdmark  
3ca6 ..			.dmark: db "+IT"  
3ca9 f1			.pastdmark: pop af  
3caa			endm  
# End of macro DMARK
3caa				CALLMONITOR 
3caa cd aa fd			call debug_vector  
3cad				endm  
# End of macro CALLMONITOR
3cad					endif 
3cad			 
3cad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cad cd 4d 22			call macro_dsp_valuehl 
3cb0				endm 
# End of macro FORTH_DSP_VALUEHL
3cb0			 
3cb0				; TODO add floating point number detection 
3cb0			 
3cb0 e5					push hl 
3cb1			 
3cb1					; destroy value TOS 
3cb1			 
3cb1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cb1 cd 05 23			call macro_forth_dsp_pop 
3cb4				endm 
# End of macro FORTH_DSP_POP
3cb4			 
3cb4			 
3cb4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cb4 cd 4d 22			call macro_dsp_valuehl 
3cb7				endm 
# End of macro FORTH_DSP_VALUEHL
3cb7			 
3cb7					; one value on hl get other one back 
3cb7			 
3cb7 d1					pop de 
3cb8			 
3cb8					; do the add 
3cb8			 
3cb8 19					add hl,de 
3cb9			 
3cb9					; save it 
3cb9			 
3cb9			;		push hl	 
3cb9			 
3cb9					; 
3cb9			 
3cb9					; destroy value TOS 
3cb9			 
3cb9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cb9 cd 05 23			call macro_forth_dsp_pop 
3cbc				endm 
# End of macro FORTH_DSP_POP
3cbc			 
3cbc					; TODO push value back onto stack for another op etc 
3cbc			 
3cbc			;		pop hl 
3cbc			 
3cbc			.dot_done: 
3cbc cd 48 20				call forth_push_numhl 
3cbf			 
3cbf					NEXTW 
3cbf c3 39 24			jp macro_next 
3cc2				endm 
# End of macro NEXTW
3cc2			.NEG: 
3cc2			 
3cc2				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3cc2 17				db WORD_SYS_CORE+3             
3cc3 05 3d			dw .DIV            
3cc5 02				db 1 + 1 
3cc6 .. 00			db "-",0              
3cc8				endm 
# End of macro CWHEAD
3cc8			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3cc8					if DEBUG_FORTH_WORDS_KEY 
3cc8						DMARK "SUB" 
3cc8 f5				push af  
3cc9 3a dd 3c			ld a, (.dmark)  
3ccc 32 a0 fd			ld (debug_mark),a  
3ccf 3a de 3c			ld a, (.dmark+1)  
3cd2 32 a1 fd			ld (debug_mark+1),a  
3cd5 3a df 3c			ld a, (.dmark+2)  
3cd8 32 a2 fd			ld (debug_mark+2),a  
3cdb 18 03			jr .pastdmark  
3cdd ..			.dmark: db "SUB"  
3ce0 f1			.pastdmark: pop af  
3ce1			endm  
# End of macro DMARK
3ce1						CALLMONITOR 
3ce1 cd aa fd			call debug_vector  
3ce4				endm  
# End of macro CALLMONITOR
3ce4					endif 
3ce4			 
3ce4			 
3ce4				; TODO add floating point number detection 
3ce4					; v5 FORTH_DSP_VALUE 
3ce4					FORTH_DSP 
3ce4 cd 13 22			call macro_forth_dsp 
3ce7				endm 
# End of macro FORTH_DSP
3ce7 7e					ld a,(hl)	; get type of value on TOS 
3ce8 fe 02				cp DS_TYPE_INUM  
3cea 28 03				jr z, .neg_inum 
3cec			 
3cec					NEXTW 
3cec c3 39 24			jp macro_next 
3cef				endm 
# End of macro NEXTW
3cef			 
3cef			; float maths 
3cef			 
3cef				if FORTH_ENABLE_FLOATMATH 
3cef					jr .neg_done 
3cef			 
3cef				endif 
3cef					 
3cef			 
3cef			.neg_inum: 
3cef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cef cd 4d 22			call macro_dsp_valuehl 
3cf2				endm 
# End of macro FORTH_DSP_VALUEHL
3cf2			 
3cf2 e5					push hl 
3cf3			 
3cf3					; destroy value TOS 
3cf3			 
3cf3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cf3 cd 05 23			call macro_forth_dsp_pop 
3cf6				endm 
# End of macro FORTH_DSP_POP
3cf6			 
3cf6			 
3cf6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cf6 cd 4d 22			call macro_dsp_valuehl 
3cf9				endm 
# End of macro FORTH_DSP_VALUEHL
3cf9			 
3cf9					; one value on hl get other one back 
3cf9			 
3cf9 d1					pop de 
3cfa			 
3cfa					; do the sub 
3cfa			;		ex de, hl 
3cfa			 
3cfa ed 52				sbc hl,de 
3cfc			 
3cfc					; save it 
3cfc			 
3cfc			;		push hl	 
3cfc			 
3cfc					; 
3cfc			 
3cfc					; destroy value TOS 
3cfc			 
3cfc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cfc cd 05 23			call macro_forth_dsp_pop 
3cff				endm 
# End of macro FORTH_DSP_POP
3cff			 
3cff					; TODO push value back onto stack for another op etc 
3cff			 
3cff			;		pop hl 
3cff			 
3cff cd 48 20				call forth_push_numhl 
3d02			.neg_done: 
3d02			 
3d02					NEXTW 
3d02 c3 39 24			jp macro_next 
3d05				endm 
# End of macro NEXTW
3d05			.DIV: 
3d05				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3d05 18				db WORD_SYS_CORE+4             
3d06 52 3d			dw .MUL            
3d08 02				db 1 + 1 
3d09 .. 00			db "/",0              
3d0b				endm 
# End of macro CWHEAD
3d0b			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3d0b					if DEBUG_FORTH_WORDS_KEY 
3d0b						DMARK "DIV" 
3d0b f5				push af  
3d0c 3a 20 3d			ld a, (.dmark)  
3d0f 32 a0 fd			ld (debug_mark),a  
3d12 3a 21 3d			ld a, (.dmark+1)  
3d15 32 a1 fd			ld (debug_mark+1),a  
3d18 3a 22 3d			ld a, (.dmark+2)  
3d1b 32 a2 fd			ld (debug_mark+2),a  
3d1e 18 03			jr .pastdmark  
3d20 ..			.dmark: db "DIV"  
3d23 f1			.pastdmark: pop af  
3d24			endm  
# End of macro DMARK
3d24						CALLMONITOR 
3d24 cd aa fd			call debug_vector  
3d27				endm  
# End of macro CALLMONITOR
3d27					endif 
3d27				; TODO add floating point number detection 
3d27					; v5 FORTH_DSP_VALUE 
3d27					FORTH_DSP 
3d27 cd 13 22			call macro_forth_dsp 
3d2a				endm 
# End of macro FORTH_DSP
3d2a 7e					ld a,(hl)	; get type of value on TOS 
3d2b fe 02				cp DS_TYPE_INUM  
3d2d 28 03				jr z, .div_inum 
3d2f			 
3d2f				if FORTH_ENABLE_FLOATMATH 
3d2f					jr .div_done 
3d2f			 
3d2f				endif 
3d2f					NEXTW 
3d2f c3 39 24			jp macro_next 
3d32				endm 
# End of macro NEXTW
3d32			.div_inum: 
3d32			 
3d32					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d32 cd 4d 22			call macro_dsp_valuehl 
3d35				endm 
# End of macro FORTH_DSP_VALUEHL
3d35			 
3d35 e5					push hl    ; to go to bc 
3d36			 
3d36					; destroy value TOS 
3d36			 
3d36					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d36 cd 05 23			call macro_forth_dsp_pop 
3d39				endm 
# End of macro FORTH_DSP_POP
3d39			 
3d39			 
3d39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d39 cd 4d 22			call macro_dsp_valuehl 
3d3c				endm 
# End of macro FORTH_DSP_VALUEHL
3d3c			 
3d3c					; hl to go to de 
3d3c			 
3d3c e5					push hl 
3d3d			 
3d3d c1					pop bc 
3d3e d1					pop de		 
3d3f			 
3d3f			 
3d3f					if DEBUG_FORTH_MATHS 
3d3f						DMARK "DIV" 
3d3f				CALLMONITOR 
3d3f					endif 
3d3f					; one value on hl but move to a get other one back 
3d3f			 
3d3f			        
3d3f cd 3b 0f			call Div16 
3d42			 
3d42			;	push af	 
3d42 e5				push hl 
3d43 c5				push bc 
3d44			 
3d44					if DEBUG_FORTH_MATHS 
3d44						DMARK "DI1" 
3d44				CALLMONITOR 
3d44					endif 
3d44			 
3d44					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d44 cd 05 23			call macro_forth_dsp_pop 
3d47				endm 
# End of macro FORTH_DSP_POP
3d47			 
3d47			 
3d47			 
3d47 e1					pop hl    ; result 
3d48			 
3d48 cd 48 20				call forth_push_numhl 
3d4b			 
3d4b e1					pop hl    ; reminder 
3d4c			;		ld h,0 
3d4c			;		ld l,d 
3d4c			 
3d4c cd 48 20				call forth_push_numhl 
3d4f			.div_done: 
3d4f					NEXTW 
3d4f c3 39 24			jp macro_next 
3d52				endm 
# End of macro NEXTW
3d52			.MUL: 
3d52				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3d52 19				db WORD_SYS_CORE+5             
3d53 97 3d			dw .MIN            
3d55 02				db 1 + 1 
3d56 .. 00			db "*",0              
3d58				endm 
# End of macro CWHEAD
3d58			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3d58				; TODO add floating point number detection 
3d58					if DEBUG_FORTH_WORDS_KEY 
3d58						DMARK "MUL" 
3d58 f5				push af  
3d59 3a 6d 3d			ld a, (.dmark)  
3d5c 32 a0 fd			ld (debug_mark),a  
3d5f 3a 6e 3d			ld a, (.dmark+1)  
3d62 32 a1 fd			ld (debug_mark+1),a  
3d65 3a 6f 3d			ld a, (.dmark+2)  
3d68 32 a2 fd			ld (debug_mark+2),a  
3d6b 18 03			jr .pastdmark  
3d6d ..			.dmark: db "MUL"  
3d70 f1			.pastdmark: pop af  
3d71			endm  
# End of macro DMARK
3d71						CALLMONITOR 
3d71 cd aa fd			call debug_vector  
3d74				endm  
# End of macro CALLMONITOR
3d74					endif 
3d74					FORTH_DSP 
3d74 cd 13 22			call macro_forth_dsp 
3d77				endm 
# End of macro FORTH_DSP
3d77					; v5 FORTH_DSP_VALUE 
3d77 7e					ld a,(hl)	; get type of value on TOS 
3d78 fe 02				cp DS_TYPE_INUM  
3d7a 28 03				jr z, .mul_inum 
3d7c			 
3d7c				if FORTH_ENABLE_FLOATMATH 
3d7c					jr .mul_done 
3d7c			 
3d7c				endif 
3d7c			 
3d7c					NEXTW 
3d7c c3 39 24			jp macro_next 
3d7f				endm 
# End of macro NEXTW
3d7f			.mul_inum:	 
3d7f			 
3d7f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d7f cd 4d 22			call macro_dsp_valuehl 
3d82				endm 
# End of macro FORTH_DSP_VALUEHL
3d82			 
3d82 e5					push hl 
3d83			 
3d83					; destroy value TOS 
3d83			 
3d83					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d83 cd 05 23			call macro_forth_dsp_pop 
3d86				endm 
# End of macro FORTH_DSP_POP
3d86			 
3d86			 
3d86					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d86 cd 4d 22			call macro_dsp_valuehl 
3d89				endm 
# End of macro FORTH_DSP_VALUEHL
3d89			 
3d89					; one value on hl but move to a get other one back 
3d89			 
3d89 7d					ld a, l 
3d8a			 
3d8a d1					pop de 
3d8b			 
3d8b					; do the mull 
3d8b			;		ex de, hl 
3d8b			 
3d8b cd 61 0f				call Mult16 
3d8e					; save it 
3d8e			 
3d8e			;		push hl	 
3d8e			 
3d8e					; 
3d8e			 
3d8e					; destroy value TOS 
3d8e			 
3d8e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d8e cd 05 23			call macro_forth_dsp_pop 
3d91				endm 
# End of macro FORTH_DSP_POP
3d91			 
3d91					; TODO push value back onto stack for another op etc 
3d91			 
3d91			;		pop hl 
3d91			 
3d91 cd 48 20				call forth_push_numhl 
3d94			 
3d94			.mul_done: 
3d94					NEXTW 
3d94 c3 39 24			jp macro_next 
3d97				endm 
# End of macro NEXTW
3d97			 
3d97			 
3d97			 
3d97			 
3d97			.MIN: 
3d97				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3d97 49				db WORD_SYS_CORE+53             
3d98 18 3e			dw .MAX            
3d9a 04				db 3 + 1 
3d9b .. 00			db "MIN",0              
3d9f				endm 
# End of macro CWHEAD
3d9f			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3d9f					if DEBUG_FORTH_WORDS_KEY 
3d9f						DMARK "MIN" 
3d9f f5				push af  
3da0 3a b4 3d			ld a, (.dmark)  
3da3 32 a0 fd			ld (debug_mark),a  
3da6 3a b5 3d			ld a, (.dmark+1)  
3da9 32 a1 fd			ld (debug_mark+1),a  
3dac 3a b6 3d			ld a, (.dmark+2)  
3daf 32 a2 fd			ld (debug_mark+2),a  
3db2 18 03			jr .pastdmark  
3db4 ..			.dmark: db "MIN"  
3db7 f1			.pastdmark: pop af  
3db8			endm  
# End of macro DMARK
3db8						CALLMONITOR 
3db8 cd aa fd			call debug_vector  
3dbb				endm  
# End of macro CALLMONITOR
3dbb					endif 
3dbb					; get u2 
3dbb			 
3dbb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dbb cd 4d 22			call macro_dsp_valuehl 
3dbe				endm 
# End of macro FORTH_DSP_VALUEHL
3dbe			 
3dbe e5					push hl   ; u2 
3dbf			 
3dbf					; destroy value TOS 
3dbf			 
3dbf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dbf cd 05 23			call macro_forth_dsp_pop 
3dc2				endm 
# End of macro FORTH_DSP_POP
3dc2			 
3dc2					; get u1 
3dc2			 
3dc2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dc2 cd 4d 22			call macro_dsp_valuehl 
3dc5				endm 
# End of macro FORTH_DSP_VALUEHL
3dc5			 
3dc5 e5					push hl  ; u1 
3dc6			 
3dc6					; destroy value TOS 
3dc6			 
3dc6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dc6 cd 05 23			call macro_forth_dsp_pop 
3dc9				endm 
# End of macro FORTH_DSP_POP
3dc9			 
3dc9 b7			 or a      ;clear carry flag 
3dca e1			  pop hl    ; u1 
3dcb d1			  pop de    ; u2 
3dcc e5				push hl   ; saved in case hl is lowest 
3dcd ed 52		  sbc hl,de 
3dcf 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3dd1			 
3dd1 e1				pop hl 
3dd2					if DEBUG_FORTH_WORDS 
3dd2						DMARK "MIN" 
3dd2 f5				push af  
3dd3 3a e7 3d			ld a, (.dmark)  
3dd6 32 a0 fd			ld (debug_mark),a  
3dd9 3a e8 3d			ld a, (.dmark+1)  
3ddc 32 a1 fd			ld (debug_mark+1),a  
3ddf 3a e9 3d			ld a, (.dmark+2)  
3de2 32 a2 fd			ld (debug_mark+2),a  
3de5 18 03			jr .pastdmark  
3de7 ..			.dmark: db "MIN"  
3dea f1			.pastdmark: pop af  
3deb			endm  
# End of macro DMARK
3deb						CALLMONITOR 
3deb cd aa fd			call debug_vector  
3dee				endm  
# End of macro CALLMONITOR
3dee					endif 
3dee cd 48 20				call forth_push_numhl 
3df1			 
3df1				       NEXTW 
3df1 c3 39 24			jp macro_next 
3df4				endm 
# End of macro NEXTW
3df4			 
3df4			.mincont:  
3df4 c1				pop bc   ; tidy up 
3df5 eb				ex de , hl  
3df6					if DEBUG_FORTH_WORDS 
3df6						DMARK "MI1" 
3df6 f5				push af  
3df7 3a 0b 3e			ld a, (.dmark)  
3dfa 32 a0 fd			ld (debug_mark),a  
3dfd 3a 0c 3e			ld a, (.dmark+1)  
3e00 32 a1 fd			ld (debug_mark+1),a  
3e03 3a 0d 3e			ld a, (.dmark+2)  
3e06 32 a2 fd			ld (debug_mark+2),a  
3e09 18 03			jr .pastdmark  
3e0b ..			.dmark: db "MI1"  
3e0e f1			.pastdmark: pop af  
3e0f			endm  
# End of macro DMARK
3e0f						CALLMONITOR 
3e0f cd aa fd			call debug_vector  
3e12				endm  
# End of macro CALLMONITOR
3e12					endif 
3e12 cd 48 20				call forth_push_numhl 
3e15			 
3e15				       NEXTW 
3e15 c3 39 24			jp macro_next 
3e18				endm 
# End of macro NEXTW
3e18			.MAX: 
3e18				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3e18 4a				db WORD_SYS_CORE+54             
3e19 99 3e			dw .RND16            
3e1b 04				db 3 + 1 
3e1c .. 00			db "MAX",0              
3e20				endm 
# End of macro CWHEAD
3e20			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3e20					if DEBUG_FORTH_WORDS_KEY 
3e20						DMARK "MAX" 
3e20 f5				push af  
3e21 3a 35 3e			ld a, (.dmark)  
3e24 32 a0 fd			ld (debug_mark),a  
3e27 3a 36 3e			ld a, (.dmark+1)  
3e2a 32 a1 fd			ld (debug_mark+1),a  
3e2d 3a 37 3e			ld a, (.dmark+2)  
3e30 32 a2 fd			ld (debug_mark+2),a  
3e33 18 03			jr .pastdmark  
3e35 ..			.dmark: db "MAX"  
3e38 f1			.pastdmark: pop af  
3e39			endm  
# End of macro DMARK
3e39						CALLMONITOR 
3e39 cd aa fd			call debug_vector  
3e3c				endm  
# End of macro CALLMONITOR
3e3c					endif 
3e3c					; get u2 
3e3c			 
3e3c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e3c cd 4d 22			call macro_dsp_valuehl 
3e3f				endm 
# End of macro FORTH_DSP_VALUEHL
3e3f			 
3e3f e5					push hl   ; u2 
3e40			 
3e40					; destroy value TOS 
3e40			 
3e40					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e40 cd 05 23			call macro_forth_dsp_pop 
3e43				endm 
# End of macro FORTH_DSP_POP
3e43			 
3e43					; get u1 
3e43			 
3e43					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e43 cd 4d 22			call macro_dsp_valuehl 
3e46				endm 
# End of macro FORTH_DSP_VALUEHL
3e46			 
3e46 e5					push hl  ; u1 
3e47			 
3e47					; destroy value TOS 
3e47			 
3e47					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e47 cd 05 23			call macro_forth_dsp_pop 
3e4a				endm 
# End of macro FORTH_DSP_POP
3e4a			 
3e4a b7			 or a      ;clear carry flag 
3e4b e1			  pop hl    ; u1 
3e4c d1			  pop de    ; u2 
3e4d e5				push hl   ; saved in case hl is lowest 
3e4e ed 52		  sbc hl,de 
3e50 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3e52			 
3e52 e1				pop hl 
3e53					if DEBUG_FORTH_WORDS 
3e53						DMARK "MAX" 
3e53 f5				push af  
3e54 3a 68 3e			ld a, (.dmark)  
3e57 32 a0 fd			ld (debug_mark),a  
3e5a 3a 69 3e			ld a, (.dmark+1)  
3e5d 32 a1 fd			ld (debug_mark+1),a  
3e60 3a 6a 3e			ld a, (.dmark+2)  
3e63 32 a2 fd			ld (debug_mark+2),a  
3e66 18 03			jr .pastdmark  
3e68 ..			.dmark: db "MAX"  
3e6b f1			.pastdmark: pop af  
3e6c			endm  
# End of macro DMARK
3e6c						CALLMONITOR 
3e6c cd aa fd			call debug_vector  
3e6f				endm  
# End of macro CALLMONITOR
3e6f					endif 
3e6f cd 48 20				call forth_push_numhl 
3e72			 
3e72				       NEXTW 
3e72 c3 39 24			jp macro_next 
3e75				endm 
# End of macro NEXTW
3e75			 
3e75			.maxcont:  
3e75 c1				pop bc   ; tidy up 
3e76 eb				ex de , hl  
3e77					if DEBUG_FORTH_WORDS 
3e77						DMARK "MA1" 
3e77 f5				push af  
3e78 3a 8c 3e			ld a, (.dmark)  
3e7b 32 a0 fd			ld (debug_mark),a  
3e7e 3a 8d 3e			ld a, (.dmark+1)  
3e81 32 a1 fd			ld (debug_mark+1),a  
3e84 3a 8e 3e			ld a, (.dmark+2)  
3e87 32 a2 fd			ld (debug_mark+2),a  
3e8a 18 03			jr .pastdmark  
3e8c ..			.dmark: db "MA1"  
3e8f f1			.pastdmark: pop af  
3e90			endm  
# End of macro DMARK
3e90						CALLMONITOR 
3e90 cd aa fd			call debug_vector  
3e93				endm  
# End of macro CALLMONITOR
3e93					endif 
3e93 cd 48 20				call forth_push_numhl 
3e96				       NEXTW 
3e96 c3 39 24			jp macro_next 
3e99				endm 
# End of macro NEXTW
3e99			 
3e99			.RND16: 
3e99				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3e99 4e				db WORD_SYS_CORE+58             
3e9a c8 3e			dw .RND8            
3e9c 06				db 5 + 1 
3e9d .. 00			db "RND16",0              
3ea3				endm 
# End of macro CWHEAD
3ea3			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3ea3					if DEBUG_FORTH_WORDS_KEY 
3ea3						DMARK "R16" 
3ea3 f5				push af  
3ea4 3a b8 3e			ld a, (.dmark)  
3ea7 32 a0 fd			ld (debug_mark),a  
3eaa 3a b9 3e			ld a, (.dmark+1)  
3ead 32 a1 fd			ld (debug_mark+1),a  
3eb0 3a ba 3e			ld a, (.dmark+2)  
3eb3 32 a2 fd			ld (debug_mark+2),a  
3eb6 18 03			jr .pastdmark  
3eb8 ..			.dmark: db "R16"  
3ebb f1			.pastdmark: pop af  
3ebc			endm  
# End of macro DMARK
3ebc						CALLMONITOR 
3ebc cd aa fd			call debug_vector  
3ebf				endm  
# End of macro CALLMONITOR
3ebf					endif 
3ebf cd 05 0f				call prng16  
3ec2 cd 48 20				call forth_push_numhl 
3ec5				       NEXTW 
3ec5 c3 39 24			jp macro_next 
3ec8				endm 
# End of macro NEXTW
3ec8			.RND8: 
3ec8				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3ec8 60				db WORD_SYS_CORE+76             
3ec9 fd 3e			dw .RND            
3ecb 05				db 4 + 1 
3ecc .. 00			db "RND8",0              
3ed1				endm 
# End of macro CWHEAD
3ed1			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3ed1					if DEBUG_FORTH_WORDS_KEY 
3ed1						DMARK "RN8" 
3ed1 f5				push af  
3ed2 3a e6 3e			ld a, (.dmark)  
3ed5 32 a0 fd			ld (debug_mark),a  
3ed8 3a e7 3e			ld a, (.dmark+1)  
3edb 32 a1 fd			ld (debug_mark+1),a  
3ede 3a e8 3e			ld a, (.dmark+2)  
3ee1 32 a2 fd			ld (debug_mark+2),a  
3ee4 18 03			jr .pastdmark  
3ee6 ..			.dmark: db "RN8"  
3ee9 f1			.pastdmark: pop af  
3eea			endm  
# End of macro DMARK
3eea						CALLMONITOR 
3eea cd aa fd			call debug_vector  
3eed				endm  
# End of macro CALLMONITOR
3eed					endif 
3eed 2a de fa				ld hl,(xrandc) 
3ef0 23					inc hl 
3ef1 cd 1f 0f				call xrnd 
3ef4 6f					ld l,a	 
3ef5 26 00				ld h,0 
3ef7 cd 48 20				call forth_push_numhl 
3efa				       NEXTW 
3efa c3 39 24			jp macro_next 
3efd				endm 
# End of macro NEXTW
3efd			.RND: 
3efd				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3efd 60				db WORD_SYS_CORE+76             
3efe 03 40			dw .ENDMATHS            
3f00 04				db 3 + 1 
3f01 .. 00			db "RND",0              
3f05				endm 
# End of macro CWHEAD
3f05			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3f05			 
3f05					if DEBUG_FORTH_WORDS_KEY 
3f05						DMARK "RND" 
3f05 f5				push af  
3f06 3a 1a 3f			ld a, (.dmark)  
3f09 32 a0 fd			ld (debug_mark),a  
3f0c 3a 1b 3f			ld a, (.dmark+1)  
3f0f 32 a1 fd			ld (debug_mark+1),a  
3f12 3a 1c 3f			ld a, (.dmark+2)  
3f15 32 a2 fd			ld (debug_mark+2),a  
3f18 18 03			jr .pastdmark  
3f1a ..			.dmark: db "RND"  
3f1d f1			.pastdmark: pop af  
3f1e			endm  
# End of macro DMARK
3f1e						CALLMONITOR 
3f1e cd aa fd			call debug_vector  
3f21				endm  
# End of macro CALLMONITOR
3f21					endif 
3f21					 
3f21					FORTH_DSP_VALUEHL    ; upper range 
3f21 cd 4d 22			call macro_dsp_valuehl 
3f24				endm 
# End of macro FORTH_DSP_VALUEHL
3f24			 
3f24 22 e2 fa				ld (LFSRSeed), hl	 
3f27			 
3f27					if DEBUG_FORTH_WORDS 
3f27						DMARK "RN1" 
3f27 f5				push af  
3f28 3a 3c 3f			ld a, (.dmark)  
3f2b 32 a0 fd			ld (debug_mark),a  
3f2e 3a 3d 3f			ld a, (.dmark+1)  
3f31 32 a1 fd			ld (debug_mark+1),a  
3f34 3a 3e 3f			ld a, (.dmark+2)  
3f37 32 a2 fd			ld (debug_mark+2),a  
3f3a 18 03			jr .pastdmark  
3f3c ..			.dmark: db "RN1"  
3f3f f1			.pastdmark: pop af  
3f40			endm  
# End of macro DMARK
3f40						CALLMONITOR 
3f40 cd aa fd			call debug_vector  
3f43				endm  
# End of macro CALLMONITOR
3f43					endif 
3f43					FORTH_DSP_POP 
3f43 cd 05 23			call macro_forth_dsp_pop 
3f46				endm 
# End of macro FORTH_DSP_POP
3f46			 
3f46					FORTH_DSP_VALUEHL    ; low range 
3f46 cd 4d 22			call macro_dsp_valuehl 
3f49				endm 
# End of macro FORTH_DSP_VALUEHL
3f49			 
3f49					if DEBUG_FORTH_WORDS 
3f49						DMARK "RN2" 
3f49 f5				push af  
3f4a 3a 5e 3f			ld a, (.dmark)  
3f4d 32 a0 fd			ld (debug_mark),a  
3f50 3a 5f 3f			ld a, (.dmark+1)  
3f53 32 a1 fd			ld (debug_mark+1),a  
3f56 3a 60 3f			ld a, (.dmark+2)  
3f59 32 a2 fd			ld (debug_mark+2),a  
3f5c 18 03			jr .pastdmark  
3f5e ..			.dmark: db "RN2"  
3f61 f1			.pastdmark: pop af  
3f62			endm  
# End of macro DMARK
3f62						CALLMONITOR 
3f62 cd aa fd			call debug_vector  
3f65				endm  
# End of macro CALLMONITOR
3f65					endif 
3f65 22 e4 fa				ld (LFSRSeed+2), hl 
3f68			 
3f68					FORTH_DSP_POP 
3f68 cd 05 23			call macro_forth_dsp_pop 
3f6b				endm 
# End of macro FORTH_DSP_POP
3f6b			 
3f6b e5					push hl 
3f6c			 
3f6c e1			.inrange:	pop hl 
3f6d cd 05 0f				call prng16  
3f70					if DEBUG_FORTH_WORDS 
3f70						DMARK "RN3" 
3f70 f5				push af  
3f71 3a 85 3f			ld a, (.dmark)  
3f74 32 a0 fd			ld (debug_mark),a  
3f77 3a 86 3f			ld a, (.dmark+1)  
3f7a 32 a1 fd			ld (debug_mark+1),a  
3f7d 3a 87 3f			ld a, (.dmark+2)  
3f80 32 a2 fd			ld (debug_mark+2),a  
3f83 18 03			jr .pastdmark  
3f85 ..			.dmark: db "RN3"  
3f88 f1			.pastdmark: pop af  
3f89			endm  
# End of macro DMARK
3f89						CALLMONITOR 
3f89 cd aa fd			call debug_vector  
3f8c				endm  
# End of macro CALLMONITOR
3f8c					endif 
3f8c					 
3f8c					; if the range is 8bit knock out the high byte 
3f8c			 
3f8c ed 5b e2 fa			ld de, (LFSRSeed)     ; check high level 
3f90			 
3f90 3e 00				ld a, 0 
3f92 ba					cp d  
3f93 20 1e				jr nz, .hirange 
3f95 26 00				ld h, 0   ; knock it down to 8bit 
3f97			 
3f97					if DEBUG_FORTH_WORDS 
3f97						DMARK "RNk" 
3f97 f5				push af  
3f98 3a ac 3f			ld a, (.dmark)  
3f9b 32 a0 fd			ld (debug_mark),a  
3f9e 3a ad 3f			ld a, (.dmark+1)  
3fa1 32 a1 fd			ld (debug_mark+1),a  
3fa4 3a ae 3f			ld a, (.dmark+2)  
3fa7 32 a2 fd			ld (debug_mark+2),a  
3faa 18 03			jr .pastdmark  
3fac ..			.dmark: db "RNk"  
3faf f1			.pastdmark: pop af  
3fb0			endm  
# End of macro DMARK
3fb0						CALLMONITOR 
3fb0 cd aa fd			call debug_vector  
3fb3				endm  
# End of macro CALLMONITOR
3fb3					endif 
3fb3			.hirange:   
3fb3 e5					push hl  
3fb4 b7					or a  
3fb5 ed 52		                sbc hl, de 
3fb7			 
3fb7					;call cmp16 
3fb7			 
3fb7 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3fb9 e1					pop hl 
3fba e5					push hl 
3fbb			 
3fbb					if DEBUG_FORTH_WORDS 
3fbb						DMARK "RN4" 
3fbb f5				push af  
3fbc 3a d0 3f			ld a, (.dmark)  
3fbf 32 a0 fd			ld (debug_mark),a  
3fc2 3a d1 3f			ld a, (.dmark+1)  
3fc5 32 a1 fd			ld (debug_mark+1),a  
3fc8 3a d2 3f			ld a, (.dmark+2)  
3fcb 32 a2 fd			ld (debug_mark+2),a  
3fce 18 03			jr .pastdmark  
3fd0 ..			.dmark: db "RN4"  
3fd3 f1			.pastdmark: pop af  
3fd4			endm  
# End of macro DMARK
3fd4						CALLMONITOR 
3fd4 cd aa fd			call debug_vector  
3fd7				endm  
# End of macro CALLMONITOR
3fd7					endif 
3fd7 ed 5b e4 fa			ld de, (LFSRSeed+2)   ; check low range 
3fdb					;call cmp16 
3fdb				 
3fdb b7					or a  
3fdc ed 52		                sbc hl, de 
3fde 38 8c				jr c, .inrange 
3fe0			 
3fe0 e1					pop hl 
3fe1					 
3fe1					if DEBUG_FORTH_WORDS 
3fe1						DMARK "RNd" 
3fe1 f5				push af  
3fe2 3a f6 3f			ld a, (.dmark)  
3fe5 32 a0 fd			ld (debug_mark),a  
3fe8 3a f7 3f			ld a, (.dmark+1)  
3feb 32 a1 fd			ld (debug_mark+1),a  
3fee 3a f8 3f			ld a, (.dmark+2)  
3ff1 32 a2 fd			ld (debug_mark+2),a  
3ff4 18 03			jr .pastdmark  
3ff6 ..			.dmark: db "RNd"  
3ff9 f1			.pastdmark: pop af  
3ffa			endm  
# End of macro DMARK
3ffa						CALLMONITOR 
3ffa cd aa fd			call debug_vector  
3ffd				endm  
# End of macro CALLMONITOR
3ffd					endif 
3ffd			 
3ffd			 
3ffd cd 48 20				call forth_push_numhl 
4000				       NEXTW 
4000 c3 39 24			jp macro_next 
4003				endm 
# End of macro NEXTW
4003			 
4003			.ENDMATHS: 
4003			 
4003			; eof 
4003			 
# End of file forth_words_maths.asm
4003			include "forth_words_display.asm" 
4003			 
4003			; | ## Display Words 
4003			 
4003			.ACT: 
4003			 
4003				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
4003 62				db WORD_SYS_CORE+78             
4004 4f 40			dw .INFO            
4006 07				db 6 + 1 
4007 .. 00			db "ACTIVE",0              
400e				endm 
# End of macro CWHEAD
400e			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
400e			;  
400e			; | | To display a pulsing activity indicator in a processing loop do this... 
400e			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
400e			 
400e					if DEBUG_FORTH_WORDS_KEY 
400e						DMARK "ACT" 
400e f5				push af  
400f 3a 23 40			ld a, (.dmark)  
4012 32 a0 fd			ld (debug_mark),a  
4015 3a 24 40			ld a, (.dmark+1)  
4018 32 a1 fd			ld (debug_mark+1),a  
401b 3a 25 40			ld a, (.dmark+2)  
401e 32 a2 fd			ld (debug_mark+2),a  
4021 18 03			jr .pastdmark  
4023 ..			.dmark: db "ACT"  
4026 f1			.pastdmark: pop af  
4027			endm  
# End of macro DMARK
4027						CALLMONITOR 
4027 cd aa fd			call debug_vector  
402a				endm  
# End of macro CALLMONITOR
402a					endif 
402a cd 01 0d				call active 
402d					if DEBUG_FORTH_WORDS 
402d						DMARK "ACp" 
402d f5				push af  
402e 3a 42 40			ld a, (.dmark)  
4031 32 a0 fd			ld (debug_mark),a  
4034 3a 43 40			ld a, (.dmark+1)  
4037 32 a1 fd			ld (debug_mark+1),a  
403a 3a 44 40			ld a, (.dmark+2)  
403d 32 a2 fd			ld (debug_mark+2),a  
4040 18 03			jr .pastdmark  
4042 ..			.dmark: db "ACp"  
4045 f1			.pastdmark: pop af  
4046			endm  
# End of macro DMARK
4046						CALLMONITOR 
4046 cd aa fd			call debug_vector  
4049				endm  
# End of macro CALLMONITOR
4049					endif 
4049 cd b6 20				call forth_push_str 
404c			 
404c					NEXTW 
404c c3 39 24			jp macro_next 
404f				endm 
# End of macro NEXTW
404f			.INFO: 
404f			 
404f				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
404f 62				db WORD_SYS_CORE+78             
4050 6c 40			dw .ATP            
4052 05				db 4 + 1 
4053 .. 00			db "INFO",0              
4058				endm 
# End of macro CWHEAD
4058			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
4058					FORTH_DSP_VALUEHL 
4058 cd 4d 22			call macro_dsp_valuehl 
405b				endm 
# End of macro FORTH_DSP_VALUEHL
405b			 
405b					FORTH_DSP_POP 
405b cd 05 23			call macro_forth_dsp_pop 
405e				endm 
# End of macro FORTH_DSP_POP
405e			 
405e e5					push hl 
405f			 
405f					FORTH_DSP_VALUEHL 
405f cd 4d 22			call macro_dsp_valuehl 
4062				endm 
# End of macro FORTH_DSP_VALUEHL
4062			 
4062					FORTH_DSP_POP 
4062 cd 05 23			call macro_forth_dsp_pop 
4065				endm 
# End of macro FORTH_DSP_POP
4065			 
4065 d1					pop de 
4066			 
4066 cd 3b 0d				call info_panel 
4069			 
4069			 
4069					NEXTW 
4069 c3 39 24			jp macro_next 
406c				endm 
# End of macro NEXTW
406c			.ATP: 
406c				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
406c 62				db WORD_SYS_CORE+78             
406d e3 40			dw .FB            
406f 04				db 3 + 1 
4070 .. 00			db "AT?",0              
4074				endm 
# End of macro CWHEAD
4074			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
4074					if DEBUG_FORTH_WORDS_KEY 
4074						DMARK "AT?" 
4074 f5				push af  
4075 3a 89 40			ld a, (.dmark)  
4078 32 a0 fd			ld (debug_mark),a  
407b 3a 8a 40			ld a, (.dmark+1)  
407e 32 a1 fd			ld (debug_mark+1),a  
4081 3a 8b 40			ld a, (.dmark+2)  
4084 32 a2 fd			ld (debug_mark+2),a  
4087 18 03			jr .pastdmark  
4089 ..			.dmark: db "AT?"  
408c f1			.pastdmark: pop af  
408d			endm  
# End of macro DMARK
408d						CALLMONITOR 
408d cd aa fd			call debug_vector  
4090				endm  
# End of macro CALLMONITOR
4090					endif 
4090 3a 93 f9				ld a, (f_cursor_ptr) 
4093			 
4093			if DEBUG_FORTH_WORDS 
4093				DMARK "AT?" 
4093 f5				push af  
4094 3a a8 40			ld a, (.dmark)  
4097 32 a0 fd			ld (debug_mark),a  
409a 3a a9 40			ld a, (.dmark+1)  
409d 32 a1 fd			ld (debug_mark+1),a  
40a0 3a aa 40			ld a, (.dmark+2)  
40a3 32 a2 fd			ld (debug_mark+2),a  
40a6 18 03			jr .pastdmark  
40a8 ..			.dmark: db "AT?"  
40ab f1			.pastdmark: pop af  
40ac			endm  
# End of macro DMARK
40ac				CALLMONITOR 
40ac cd aa fd			call debug_vector  
40af				endm  
# End of macro CALLMONITOR
40af			endif	 
40af					; count the number of rows 
40af			 
40af 06 00				ld b, 0 
40b1 4f			.atpr:		ld c, a    ; save in case we go below zero 
40b2 d6 28				sub display_cols 
40b4 f2 ba 40				jp p, .atprunder 
40b7 04					inc b 
40b8 18 f7				jr .atpr 
40ba			.atprunder:	 
40ba			if DEBUG_FORTH_WORDS 
40ba				DMARK "A?2" 
40ba f5				push af  
40bb 3a cf 40			ld a, (.dmark)  
40be 32 a0 fd			ld (debug_mark),a  
40c1 3a d0 40			ld a, (.dmark+1)  
40c4 32 a1 fd			ld (debug_mark+1),a  
40c7 3a d1 40			ld a, (.dmark+2)  
40ca 32 a2 fd			ld (debug_mark+2),a  
40cd 18 03			jr .pastdmark  
40cf ..			.dmark: db "A?2"  
40d2 f1			.pastdmark: pop af  
40d3			endm  
# End of macro DMARK
40d3				CALLMONITOR 
40d3 cd aa fd			call debug_vector  
40d6				endm  
# End of macro CALLMONITOR
40d6			endif	 
40d6 26 00				ld h, 0 
40d8 69					ld l, c 
40d9 cd 48 20				call forth_push_numhl 
40dc 68					ld l, b  
40dd cd 48 20				call forth_push_numhl 
40e0			 
40e0			 
40e0				NEXTW 
40e0 c3 39 24			jp macro_next 
40e3				endm 
# End of macro NEXTW
40e3			 
40e3			.FB: 
40e3				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
40e3 1b				db WORD_SYS_CORE+7             
40e4 31 41			dw .EMIT            
40e6 03				db 2 + 1 
40e7 .. 00			db "FB",0              
40ea				endm 
# End of macro CWHEAD
40ea			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
40ea			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
40ea			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
40ea			; | | If automatic display is off then updates will not be shown until DRAW is used. 
40ea					if DEBUG_FORTH_WORDS_KEY 
40ea						DMARK "FB." 
40ea f5				push af  
40eb 3a ff 40			ld a, (.dmark)  
40ee 32 a0 fd			ld (debug_mark),a  
40f1 3a 00 41			ld a, (.dmark+1)  
40f4 32 a1 fd			ld (debug_mark+1),a  
40f7 3a 01 41			ld a, (.dmark+2)  
40fa 32 a2 fd			ld (debug_mark+2),a  
40fd 18 03			jr .pastdmark  
40ff ..			.dmark: db "FB."  
4102 f1			.pastdmark: pop af  
4103			endm  
# End of macro DMARK
4103						CALLMONITOR 
4103 cd aa fd			call debug_vector  
4106				endm  
# End of macro CALLMONITOR
4106					endif 
4106			 
4106					FORTH_DSP_VALUEHL 
4106 cd 4d 22			call macro_dsp_valuehl 
4109				endm 
# End of macro FORTH_DSP_VALUEHL
4109			 
4109 7d					ld a, l 
410a fe 01				cp 1 
410c 20 05				jr nz, .fbn1 
410e 21 45 fc				ld hl, display_fb1 
4111 18 15				jr .fbset 
4113 fe 02		.fbn1:		cp 2 
4115 20 05				jr nz, .fbn2 
4117 21 03 fb				ld hl, display_fb2 
411a 18 0c				jr .fbset 
411c fe 03		.fbn2:		cp 3 
411e 20 05				jr nz, .fbn3 
4120 21 a4 fb				ld hl, display_fb3 
4123 18 03				jr .fbset 
4125			.fbn3:		 ; if invalid number select first 
4125 21 45 fc				ld hl, display_fb1 
4128 22 01 fb		.fbset:		ld (display_fb_active), hl 
412b			 
412b					FORTH_DSP_POP 
412b cd 05 23			call macro_forth_dsp_pop 
412e				endm 
# End of macro FORTH_DSP_POP
412e			 
412e					NEXTW 
412e c3 39 24			jp macro_next 
4131				endm 
# End of macro NEXTW
4131			 
4131			 
4131			.EMIT: 
4131				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
4131 1b				db WORD_SYS_CORE+7             
4132 82 41			dw .DOTH            
4134 05				db 4 + 1 
4135 .. 00			db "EMIT",0              
413a				endm 
# End of macro CWHEAD
413a			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
413a					; get value off TOS and display it 
413a			 
413a					if DEBUG_FORTH_WORDS_KEY 
413a						DMARK "EMT" 
413a f5				push af  
413b 3a 4f 41			ld a, (.dmark)  
413e 32 a0 fd			ld (debug_mark),a  
4141 3a 50 41			ld a, (.dmark+1)  
4144 32 a1 fd			ld (debug_mark+1),a  
4147 3a 51 41			ld a, (.dmark+2)  
414a 32 a2 fd			ld (debug_mark+2),a  
414d 18 03			jr .pastdmark  
414f ..			.dmark: db "EMT"  
4152 f1			.pastdmark: pop af  
4153			endm  
# End of macro DMARK
4153						CALLMONITOR 
4153 cd aa fd			call debug_vector  
4156				endm  
# End of macro CALLMONITOR
4156					endif 
4156			 
4156					FORTH_DSP_VALUEHL 
4156 cd 4d 22			call macro_dsp_valuehl 
4159				endm 
# End of macro FORTH_DSP_VALUEHL
4159			 
4159 7d					ld a,l 
415a			 
415a					; TODO write to display 
415a			 
415a 32 f4 f2				ld (os_input), a 
415d 3e 00				ld a, 0 
415f 32 f5 f2				ld (os_input+1), a 
4162					 
4162 3a 93 f9				ld a, (f_cursor_ptr) 
4165 11 f4 f2				ld de, os_input 
4168 cd bd 0d				call str_at_display 
416b			 
416b			 
416b 3a 71 f9				ld a,(cli_autodisplay) 
416e fe 00				cp 0 
4170 28 03				jr z, .enoupdate 
4172 cd cd 0d						call update_display 
4175					.enoupdate: 
4175			 
4175 3a 93 f9				ld a, (f_cursor_ptr) 
4178 3c					inc a 
4179 32 93 f9				ld (f_cursor_ptr), a   ; save new pos 
417c			 
417c			 
417c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
417c cd 05 23			call macro_forth_dsp_pop 
417f				endm 
# End of macro FORTH_DSP_POP
417f			  
417f			 
417f					NEXTW 
417f c3 39 24			jp macro_next 
4182				endm 
# End of macro NEXTW
4182			.DOTH: 
4182				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
4182 1c				db WORD_SYS_CORE+8             
4183 b2 41			dw .DOTF            
4185 03				db 2 + 1 
4186 .. 00			db ".-",0              
4189				endm 
# End of macro CWHEAD
4189			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
4189					; get value off TOS and display it 
4189					if DEBUG_FORTH_WORDS_KEY 
4189						DMARK "DTD" 
4189 f5				push af  
418a 3a 9e 41			ld a, (.dmark)  
418d 32 a0 fd			ld (debug_mark),a  
4190 3a 9f 41			ld a, (.dmark+1)  
4193 32 a1 fd			ld (debug_mark+1),a  
4196 3a a0 41			ld a, (.dmark+2)  
4199 32 a2 fd			ld (debug_mark+2),a  
419c 18 03			jr .pastdmark  
419e ..			.dmark: db "DTD"  
41a1 f1			.pastdmark: pop af  
41a2			endm  
# End of macro DMARK
41a2						CALLMONITOR 
41a2 cd aa fd			call debug_vector  
41a5				endm  
# End of macro CALLMONITOR
41a5					endif 
41a5 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
41a7 3e 00			ld a, 0 
41a9 32 72 f9			ld (cli_mvdot), a 
41ac c3 09 42			jp .dotgo 
41af				NEXTW 
41af c3 39 24			jp macro_next 
41b2				endm 
# End of macro NEXTW
41b2			.DOTF: 
41b2				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
41b2 1c				db WORD_SYS_CORE+8             
41b3 e0 41			dw .DOT            
41b5 03				db 2 + 1 
41b6 .. 00			db ".>",0              
41b9				endm 
# End of macro CWHEAD
41b9			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
41b9					; get value off TOS and display it 
41b9			        ; TODO BUG adds extra spaces 
41b9			        ; TODO BUG handle numerics? 
41b9					if DEBUG_FORTH_WORDS_KEY 
41b9						DMARK "DTC" 
41b9 f5				push af  
41ba 3a ce 41			ld a, (.dmark)  
41bd 32 a0 fd			ld (debug_mark),a  
41c0 3a cf 41			ld a, (.dmark+1)  
41c3 32 a1 fd			ld (debug_mark+1),a  
41c6 3a d0 41			ld a, (.dmark+2)  
41c9 32 a2 fd			ld (debug_mark+2),a  
41cc 18 03			jr .pastdmark  
41ce ..			.dmark: db "DTC"  
41d1 f1			.pastdmark: pop af  
41d2			endm  
# End of macro DMARK
41d2						CALLMONITOR 
41d2 cd aa fd			call debug_vector  
41d5				endm  
# End of macro CALLMONITOR
41d5					endif 
41d5 3e 01			ld a, 1 
41d7 32 72 f9			ld (cli_mvdot), a 
41da c3 09 42			jp .dotgo 
41dd				NEXTW 
41dd c3 39 24			jp macro_next 
41e0				endm 
# End of macro NEXTW
41e0			 
41e0			.DOT: 
41e0				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
41e0 1c				db WORD_SYS_CORE+8             
41e1 bc 43			dw .CLS            
41e3 02				db 1 + 1 
41e4 .. 00			db ".",0              
41e6				endm 
# End of macro CWHEAD
41e6			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
41e6					; get value off TOS and display it 
41e6			 
41e6					if DEBUG_FORTH_WORDS_KEY 
41e6						DMARK "DOT" 
41e6 f5				push af  
41e7 3a fb 41			ld a, (.dmark)  
41ea 32 a0 fd			ld (debug_mark),a  
41ed 3a fc 41			ld a, (.dmark+1)  
41f0 32 a1 fd			ld (debug_mark+1),a  
41f3 3a fd 41			ld a, (.dmark+2)  
41f6 32 a2 fd			ld (debug_mark+2),a  
41f9 18 03			jr .pastdmark  
41fb ..			.dmark: db "DOT"  
41fe f1			.pastdmark: pop af  
41ff			endm  
# End of macro DMARK
41ff						CALLMONITOR 
41ff cd aa fd			call debug_vector  
4202				endm  
# End of macro CALLMONITOR
4202					endif 
4202 3e 00			ld a, 0 
4204 32 72 f9			ld (cli_mvdot), a 
4207 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4209				 
4209			 
4209			.dotgo: 
4209			 
4209			; move up type to on stack for parserv5 
4209					FORTH_DSP 
4209 cd 13 22			call macro_forth_dsp 
420c				endm 
# End of macro FORTH_DSP
420c				;FORTH_DSP_VALUE  
420c			 
420c			if DEBUG_FORTH_DOT 
420c				DMARK "DOT" 
420c f5				push af  
420d 3a 21 42			ld a, (.dmark)  
4210 32 a0 fd			ld (debug_mark),a  
4213 3a 22 42			ld a, (.dmark+1)  
4216 32 a1 fd			ld (debug_mark+1),a  
4219 3a 23 42			ld a, (.dmark+2)  
421c 32 a2 fd			ld (debug_mark+2),a  
421f 18 03			jr .pastdmark  
4221 ..			.dmark: db "DOT"  
4224 f1			.pastdmark: pop af  
4225			endm  
# End of macro DMARK
4225				CALLMONITOR 
4225 cd aa fd			call debug_vector  
4228				endm  
# End of macro CALLMONITOR
4228			endif	 
4228			;		.print: 
4228			 
4228 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4229 23				inc hl   ; position to the actual value 
422a fe 01			cp DS_TYPE_STR 
422c 20 06			jr nz, .dotnum1  
422e			 
422e			; display string 
422e				FORTH_DSP_VALUE  
422e cd 36 22			call macro_forth_dsp_value 
4231				endm 
# End of macro FORTH_DSP_VALUE
4231 eb				ex de,hl 
4232 18 49			jr .dotwrite 
4234			 
4234			.dotnum1: 
4234 fe 02			cp DS_TYPE_INUM 
4236 20 44			jr nz, .dotflot 
4238			 
4238			 
4238			; display number 
4238			 
4238			;	push hl 
4238			;	call clear_display 
4238			;	pop hl 
4238			 
4238 5e				ld e, (hl) 
4239 23				inc hl 
423a 56				ld d, (hl) 
423b 21 f6 f0			ld hl, scratch 
423e			if DEBUG_FORTH_DOT 
423e				DMARK "DT1" 
423e f5				push af  
423f 3a 53 42			ld a, (.dmark)  
4242 32 a0 fd			ld (debug_mark),a  
4245 3a 54 42			ld a, (.dmark+1)  
4248 32 a1 fd			ld (debug_mark+1),a  
424b 3a 55 42			ld a, (.dmark+2)  
424e 32 a2 fd			ld (debug_mark+2),a  
4251 18 03			jr .pastdmark  
4253 ..			.dmark: db "DT1"  
4256 f1			.pastdmark: pop af  
4257			endm  
# End of macro DMARK
4257				CALLMONITOR 
4257 cd aa fd			call debug_vector  
425a				endm  
# End of macro CALLMONITOR
425a			endif	 
425a			 
425a cd f3 12			call uitoa_16 
425d eb				ex de,hl 
425e			 
425e			if DEBUG_FORTH_DOT 
425e				DMARK "DT2" 
425e f5				push af  
425f 3a 73 42			ld a, (.dmark)  
4262 32 a0 fd			ld (debug_mark),a  
4265 3a 74 42			ld a, (.dmark+1)  
4268 32 a1 fd			ld (debug_mark+1),a  
426b 3a 75 42			ld a, (.dmark+2)  
426e 32 a2 fd			ld (debug_mark+2),a  
4271 18 03			jr .pastdmark  
4273 ..			.dmark: db "DT2"  
4276 f1			.pastdmark: pop af  
4277			endm  
# End of macro DMARK
4277				CALLMONITOR 
4277 cd aa fd			call debug_vector  
427a				endm  
# End of macro CALLMONITOR
427a			endif	 
427a			 
427a			;	ld de, os_word_scratch 
427a 18 01			jr .dotwrite 
427c			 
427c 00			.dotflot:   nop 
427d			; TODO print floating point number 
427d			 
427d			.dotwrite:		 
427d			 
427d					; if c is set then set all '-' to spaces 
427d					; need to also take into account .>  
427d			 
427d 3e 01				ld a, 1 
427f b9					cp c 
4280 20 67				jr nz, .nodashswap 
4282			 
4282					; DE has the string to write, working with HL 
4282			 
4282 06 ff				ld b, 255 
4284 d5					push de 
4285 e1					pop hl 
4286			 
4286			if DEBUG_FORTH_DOT 
4286				DMARK "DT-" 
4286 f5				push af  
4287 3a 9b 42			ld a, (.dmark)  
428a 32 a0 fd			ld (debug_mark),a  
428d 3a 9c 42			ld a, (.dmark+1)  
4290 32 a1 fd			ld (debug_mark+1),a  
4293 3a 9d 42			ld a, (.dmark+2)  
4296 32 a2 fd			ld (debug_mark+2),a  
4299 18 03			jr .pastdmark  
429b ..			.dmark: db "DT-"  
429e f1			.pastdmark: pop af  
429f			endm  
# End of macro DMARK
429f				CALLMONITOR 
429f cd aa fd			call debug_vector  
42a2				endm  
# End of macro CALLMONITOR
42a2			endif	 
42a2 7e			.dashscan:	ld a, (hl) 
42a3 fe 00				cp 0 
42a5 28 42				jr z, .nodashswap 
42a7 fe 2d				cp '-' 
42a9 20 03				jr nz, .dashskip 
42ab 3e 20				ld a, ' ' 
42ad 77					ld (hl), a 
42ae 23			.dashskip:	inc hl 
42af			if DEBUG_FORTH_DOT 
42af				DMARK "D-2" 
42af f5				push af  
42b0 3a c4 42			ld a, (.dmark)  
42b3 32 a0 fd			ld (debug_mark),a  
42b6 3a c5 42			ld a, (.dmark+1)  
42b9 32 a1 fd			ld (debug_mark+1),a  
42bc 3a c6 42			ld a, (.dmark+2)  
42bf 32 a2 fd			ld (debug_mark+2),a  
42c2 18 03			jr .pastdmark  
42c4 ..			.dmark: db "D-2"  
42c7 f1			.pastdmark: pop af  
42c8			endm  
# End of macro DMARK
42c8				CALLMONITOR 
42c8 cd aa fd			call debug_vector  
42cb				endm  
# End of macro CALLMONITOR
42cb			endif	 
42cb 10 d5				djnz .dashscan 
42cd			 
42cd			if DEBUG_FORTH_DOT 
42cd				DMARK "D-1" 
42cd f5				push af  
42ce 3a e2 42			ld a, (.dmark)  
42d1 32 a0 fd			ld (debug_mark),a  
42d4 3a e3 42			ld a, (.dmark+1)  
42d7 32 a1 fd			ld (debug_mark+1),a  
42da 3a e4 42			ld a, (.dmark+2)  
42dd 32 a2 fd			ld (debug_mark+2),a  
42e0 18 03			jr .pastdmark  
42e2 ..			.dmark: db "D-1"  
42e5 f1			.pastdmark: pop af  
42e6			endm  
# End of macro DMARK
42e6				CALLMONITOR 
42e6 cd aa fd			call debug_vector  
42e9				endm  
# End of macro CALLMONITOR
42e9			endif	 
42e9			 
42e9			.nodashswap: 
42e9			 
42e9			if DEBUG_FORTH_DOT 
42e9				DMARK "D-o" 
42e9 f5				push af  
42ea 3a fe 42			ld a, (.dmark)  
42ed 32 a0 fd			ld (debug_mark),a  
42f0 3a ff 42			ld a, (.dmark+1)  
42f3 32 a1 fd			ld (debug_mark+1),a  
42f6 3a 00 43			ld a, (.dmark+2)  
42f9 32 a2 fd			ld (debug_mark+2),a  
42fc 18 03			jr .pastdmark  
42fe ..			.dmark: db "D-o"  
4301 f1			.pastdmark: pop af  
4302			endm  
# End of macro DMARK
4302				CALLMONITOR 
4302 cd aa fd			call debug_vector  
4305				endm  
# End of macro CALLMONITOR
4305			endif	 
4305			 
4305 d5					push de   ; save string start in case we need to advance print 
4306			 
4306 3a 93 f9				ld a, (f_cursor_ptr) 
4309 cd bd 0d				call str_at_display 
430c 3a 71 f9				ld a,(cli_autodisplay) 
430f fe 00				cp 0 
4311 28 03				jr z, .noupdate 
4313 cd cd 0d						call update_display 
4316					.noupdate: 
4316			 
4316			 
4316					; see if we need to advance the print position 
4316			 
4316 e1					pop hl   ; get back string 
4317			;		ex de,hl 
4317			 
4317 3a 72 f9				ld a, (cli_mvdot) 
431a			if DEBUG_FORTH_DOT 
431a			;		ld e,a 
431a				DMARK "D>1" 
431a f5				push af  
431b 3a 2f 43			ld a, (.dmark)  
431e 32 a0 fd			ld (debug_mark),a  
4321 3a 30 43			ld a, (.dmark+1)  
4324 32 a1 fd			ld (debug_mark+1),a  
4327 3a 31 43			ld a, (.dmark+2)  
432a 32 a2 fd			ld (debug_mark+2),a  
432d 18 03			jr .pastdmark  
432f ..			.dmark: db "D>1"  
4332 f1			.pastdmark: pop af  
4333			endm  
# End of macro DMARK
4333				CALLMONITOR 
4333 cd aa fd			call debug_vector  
4336				endm  
# End of macro CALLMONITOR
4336			endif	 
4336 fe 00				cp 0 
4338 28 44				jr z, .noadv 
433a					; yes, lets advance the print position 
433a 3e 00				ld a, 0 
433c cd 4f 13				call strlent 
433f			if DEBUG_FORTH_DOT 
433f				DMARK "D-?" 
433f f5				push af  
4340 3a 54 43			ld a, (.dmark)  
4343 32 a0 fd			ld (debug_mark),a  
4346 3a 55 43			ld a, (.dmark+1)  
4349 32 a1 fd			ld (debug_mark+1),a  
434c 3a 56 43			ld a, (.dmark+2)  
434f 32 a2 fd			ld (debug_mark+2),a  
4352 18 03			jr .pastdmark  
4354 ..			.dmark: db "D-?"  
4357 f1			.pastdmark: pop af  
4358			endm  
# End of macro DMARK
4358				CALLMONITOR 
4358 cd aa fd			call debug_vector  
435b				endm  
# End of macro CALLMONITOR
435b			endif	 
435b 3a 93 f9				ld a, (f_cursor_ptr) 
435e 85					add a,l 
435f					;call addatohl 
435f					;ld a, l 
435f 32 93 f9				ld (f_cursor_ptr), a   ; save new pos 
4362			 
4362			if DEBUG_FORTH_DOT 
4362				DMARK "D->" 
4362 f5				push af  
4363 3a 77 43			ld a, (.dmark)  
4366 32 a0 fd			ld (debug_mark),a  
4369 3a 78 43			ld a, (.dmark+1)  
436c 32 a1 fd			ld (debug_mark+1),a  
436f 3a 79 43			ld a, (.dmark+2)  
4372 32 a2 fd			ld (debug_mark+2),a  
4375 18 03			jr .pastdmark  
4377 ..			.dmark: db "D->"  
437a f1			.pastdmark: pop af  
437b			endm  
# End of macro DMARK
437b				CALLMONITOR 
437b cd aa fd			call debug_vector  
437e				endm  
# End of macro CALLMONITOR
437e			endif	 
437e			 
437e			.noadv:	 
437e			 
437e					if DEBUG_FORTH_DOT_WAIT 
437e							call next_page_prompt 
437e					endif	 
437e			; TODO this pop off the stack causes a crash. i dont know why 
437e			 
437e			 
437e			if DEBUG_FORTH_DOT 
437e				DMARK "DTh" 
437e f5				push af  
437f 3a 93 43			ld a, (.dmark)  
4382 32 a0 fd			ld (debug_mark),a  
4385 3a 94 43			ld a, (.dmark+1)  
4388 32 a1 fd			ld (debug_mark+1),a  
438b 3a 95 43			ld a, (.dmark+2)  
438e 32 a2 fd			ld (debug_mark+2),a  
4391 18 03			jr .pastdmark  
4393 ..			.dmark: db "DTh"  
4396 f1			.pastdmark: pop af  
4397			endm  
# End of macro DMARK
4397				CALLMONITOR 
4397 cd aa fd			call debug_vector  
439a				endm  
# End of macro CALLMONITOR
439a			endif	 
439a			 
439a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
439a cd 05 23			call macro_forth_dsp_pop 
439d				endm 
# End of macro FORTH_DSP_POP
439d			 
439d			if DEBUG_FORTH_DOT 
439d				DMARK "DTi" 
439d f5				push af  
439e 3a b2 43			ld a, (.dmark)  
43a1 32 a0 fd			ld (debug_mark),a  
43a4 3a b3 43			ld a, (.dmark+1)  
43a7 32 a1 fd			ld (debug_mark+1),a  
43aa 3a b4 43			ld a, (.dmark+2)  
43ad 32 a2 fd			ld (debug_mark+2),a  
43b0 18 03			jr .pastdmark  
43b2 ..			.dmark: db "DTi"  
43b5 f1			.pastdmark: pop af  
43b6			endm  
# End of macro DMARK
43b6				CALLMONITOR 
43b6 cd aa fd			call debug_vector  
43b9				endm  
# End of macro CALLMONITOR
43b9			endif	 
43b9			 
43b9			 
43b9					NEXTW 
43b9 c3 39 24			jp macro_next 
43bc				endm 
# End of macro NEXTW
43bc			 
43bc			.CLS: 
43bc				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
43bc 35				db WORD_SYS_CORE+33             
43bd e9 43			dw .DRAW            
43bf 04				db 3 + 1 
43c0 .. 00			db "CLS",0              
43c4				endm 
# End of macro CWHEAD
43c4			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
43c4					if DEBUG_FORTH_WORDS_KEY 
43c4						DMARK "CLS" 
43c4 f5				push af  
43c5 3a d9 43			ld a, (.dmark)  
43c8 32 a0 fd			ld (debug_mark),a  
43cb 3a da 43			ld a, (.dmark+1)  
43ce 32 a1 fd			ld (debug_mark+1),a  
43d1 3a db 43			ld a, (.dmark+2)  
43d4 32 a2 fd			ld (debug_mark+2),a  
43d7 18 03			jr .pastdmark  
43d9 ..			.dmark: db "CLS"  
43dc f1			.pastdmark: pop af  
43dd			endm  
# End of macro DMARK
43dd						CALLMONITOR 
43dd cd aa fd			call debug_vector  
43e0				endm  
# End of macro CALLMONITOR
43e0					endif 
43e0 cd aa 0d				call clear_display 
43e3 c3 f7 44				jp .home		; and home cursor 
43e6					NEXTW 
43e6 c3 39 24			jp macro_next 
43e9				endm 
# End of macro NEXTW
43e9			 
43e9			.DRAW: 
43e9				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
43e9 36				db WORD_SYS_CORE+34             
43ea 14 44			dw .DUMP            
43ec 05				db 4 + 1 
43ed .. 00			db "DRAW",0              
43f2				endm 
# End of macro CWHEAD
43f2			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
43f2					if DEBUG_FORTH_WORDS_KEY 
43f2						DMARK "DRW" 
43f2 f5				push af  
43f3 3a 07 44			ld a, (.dmark)  
43f6 32 a0 fd			ld (debug_mark),a  
43f9 3a 08 44			ld a, (.dmark+1)  
43fc 32 a1 fd			ld (debug_mark+1),a  
43ff 3a 09 44			ld a, (.dmark+2)  
4402 32 a2 fd			ld (debug_mark+2),a  
4405 18 03			jr .pastdmark  
4407 ..			.dmark: db "DRW"  
440a f1			.pastdmark: pop af  
440b			endm  
# End of macro DMARK
440b						CALLMONITOR 
440b cd aa fd			call debug_vector  
440e				endm  
# End of macro CALLMONITOR
440e					endif 
440e cd cd 0d				call update_display 
4411					NEXTW 
4411 c3 39 24			jp macro_next 
4414				endm 
# End of macro NEXTW
4414			 
4414			.DUMP: 
4414				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4414 37				db WORD_SYS_CORE+35             
4415 4c 44			dw .CDUMP            
4417 05				db 4 + 1 
4418 .. 00			db "DUMP",0              
441d				endm 
# End of macro CWHEAD
441d			; | DUMP ( x -- ) With address x display dump   | DONE 
441d			; TODO pop address to use off of the stack 
441d					if DEBUG_FORTH_WORDS_KEY 
441d						DMARK "DUM" 
441d f5				push af  
441e 3a 32 44			ld a, (.dmark)  
4421 32 a0 fd			ld (debug_mark),a  
4424 3a 33 44			ld a, (.dmark+1)  
4427 32 a1 fd			ld (debug_mark+1),a  
442a 3a 34 44			ld a, (.dmark+2)  
442d 32 a2 fd			ld (debug_mark+2),a  
4430 18 03			jr .pastdmark  
4432 ..			.dmark: db "DUM"  
4435 f1			.pastdmark: pop af  
4436			endm  
# End of macro DMARK
4436						CALLMONITOR 
4436 cd aa fd			call debug_vector  
4439				endm  
# End of macro CALLMONITOR
4439					endif 
4439 cd aa 0d				call clear_display 
443c			 
443c					; get address 
443c			 
443c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
443c cd 4d 22			call macro_dsp_valuehl 
443f				endm 
# End of macro FORTH_DSP_VALUEHL
443f				 
443f					; save it for cdump 
443f			 
443f 22 19 f4				ld (os_cur_ptr),hl 
4442			 
4442					; destroy value TOS 
4442			 
4442					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4442 cd 05 23			call macro_forth_dsp_pop 
4445				endm 
# End of macro FORTH_DSP_POP
4445			 
4445 cd c8 1e				call dumpcont	; skip old style of param parsing	 
4448 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4449					NEXTW 
4449 c3 39 24			jp macro_next 
444c				endm 
# End of macro NEXTW
444c			.CDUMP: 
444c				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
444c 38				db WORD_SYS_CORE+36             
444d 7c 44			dw .DAT            
444f 06				db 5 + 1 
4450 .. 00			db "CDUMP",0              
4456				endm 
# End of macro CWHEAD
4456			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
4456					if DEBUG_FORTH_WORDS_KEY 
4456						DMARK "CDP" 
4456 f5				push af  
4457 3a 6b 44			ld a, (.dmark)  
445a 32 a0 fd			ld (debug_mark),a  
445d 3a 6c 44			ld a, (.dmark+1)  
4460 32 a1 fd			ld (debug_mark+1),a  
4463 3a 6d 44			ld a, (.dmark+2)  
4466 32 a2 fd			ld (debug_mark+2),a  
4469 18 03			jr .pastdmark  
446b ..			.dmark: db "CDP"  
446e f1			.pastdmark: pop af  
446f			endm  
# End of macro DMARK
446f						CALLMONITOR 
446f cd aa fd			call debug_vector  
4472				endm  
# End of macro CALLMONITOR
4472					endif 
4472 cd aa 0d				call clear_display 
4475 cd c8 1e				call dumpcont	 
4478 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4479					NEXTW 
4479 c3 39 24			jp macro_next 
447c				endm 
# End of macro NEXTW
447c			 
447c			 
447c			 
447c			 
447c			.DAT: 
447c				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
447c 3d				db WORD_SYS_CORE+41             
447d d2 44			dw .HOME            
447f 03				db 2 + 1 
4480 .. 00			db "AT",0              
4483				endm 
# End of macro CWHEAD
4483			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4483					if DEBUG_FORTH_WORDS_KEY 
4483						DMARK "AT." 
4483 f5				push af  
4484 3a 98 44			ld a, (.dmark)  
4487 32 a0 fd			ld (debug_mark),a  
448a 3a 99 44			ld a, (.dmark+1)  
448d 32 a1 fd			ld (debug_mark+1),a  
4490 3a 9a 44			ld a, (.dmark+2)  
4493 32 a2 fd			ld (debug_mark+2),a  
4496 18 03			jr .pastdmark  
4498 ..			.dmark: db "AT."  
449b f1			.pastdmark: pop af  
449c			endm  
# End of macro DMARK
449c						CALLMONITOR 
449c cd aa fd			call debug_vector  
449f				endm  
# End of macro CALLMONITOR
449f					endif 
449f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
449f cd 4d 22			call macro_dsp_valuehl 
44a2				endm 
# End of macro FORTH_DSP_VALUEHL
44a2			 
44a2			 
44a2					; TODO save cursor row 
44a2 7d					ld a,l 
44a3 fe 02				cp 2 
44a5 20 04				jr nz, .crow3 
44a7 3e 28				ld a, display_row_2 
44a9 18 12				jr .ccol1 
44ab fe 03		.crow3:		cp 3 
44ad 20 04				jr nz, .crow4 
44af 3e 50				ld a, display_row_3 
44b1 18 0a				jr .ccol1 
44b3 fe 04		.crow4:		cp 4 
44b5 20 04				jr nz, .crow1 
44b7 3e 78				ld a, display_row_4 
44b9 18 02				jr .ccol1 
44bb 3e 00		.crow1:		ld a,display_row_1 
44bd f5			.ccol1:		push af			; got row offset 
44be 6f					ld l,a 
44bf 26 00				ld h,0 
44c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44c1 cd 05 23			call macro_forth_dsp_pop 
44c4				endm 
# End of macro FORTH_DSP_POP
44c4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44c4 cd 4d 22			call macro_dsp_valuehl 
44c7				endm 
# End of macro FORTH_DSP_VALUEHL
44c7					; TODO save cursor col 
44c7 f1					pop af 
44c8 85					add l		; add col offset 
44c9 32 93 f9				ld (f_cursor_ptr), a 
44cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44cc cd 05 23			call macro_forth_dsp_pop 
44cf				endm 
# End of macro FORTH_DSP_POP
44cf			 
44cf					; calculate  
44cf			 
44cf					NEXTW 
44cf c3 39 24			jp macro_next 
44d2				endm 
# End of macro NEXTW
44d2			 
44d2			 
44d2			.HOME: 
44d2				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
44d2 41				db WORD_SYS_CORE+45             
44d3 ff 44			dw .CR            
44d5 05				db 4 + 1 
44d6 .. 00			db "HOME",0              
44db				endm 
# End of macro CWHEAD
44db			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
44db					if DEBUG_FORTH_WORDS_KEY 
44db						DMARK "HOM" 
44db f5				push af  
44dc 3a f0 44			ld a, (.dmark)  
44df 32 a0 fd			ld (debug_mark),a  
44e2 3a f1 44			ld a, (.dmark+1)  
44e5 32 a1 fd			ld (debug_mark+1),a  
44e8 3a f2 44			ld a, (.dmark+2)  
44eb 32 a2 fd			ld (debug_mark+2),a  
44ee 18 03			jr .pastdmark  
44f0 ..			.dmark: db "HOM"  
44f3 f1			.pastdmark: pop af  
44f4			endm  
# End of macro DMARK
44f4						CALLMONITOR 
44f4 cd aa fd			call debug_vector  
44f7				endm  
# End of macro CALLMONITOR
44f7					endif 
44f7 3e 00		.home:		ld a, 0		; and home cursor 
44f9 32 93 f9				ld (f_cursor_ptr), a 
44fc					NEXTW 
44fc c3 39 24			jp macro_next 
44ff				endm 
# End of macro NEXTW
44ff			 
44ff			 
44ff			.CR: 
44ff				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
44ff 46				db WORD_SYS_CORE+50             
4500 3a 45			dw .SPACE            
4502 03				db 2 + 1 
4503 .. 00			db "CR",0              
4506				endm 
# End of macro CWHEAD
4506			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
4506					if DEBUG_FORTH_WORDS_KEY 
4506						DMARK "CR." 
4506 f5				push af  
4507 3a 1b 45			ld a, (.dmark)  
450a 32 a0 fd			ld (debug_mark),a  
450d 3a 1c 45			ld a, (.dmark+1)  
4510 32 a1 fd			ld (debug_mark+1),a  
4513 3a 1d 45			ld a, (.dmark+2)  
4516 32 a2 fd			ld (debug_mark+2),a  
4519 18 03			jr .pastdmark  
451b ..			.dmark: db "CR."  
451e f1			.pastdmark: pop af  
451f			endm  
# End of macro DMARK
451f						CALLMONITOR 
451f cd aa fd			call debug_vector  
4522				endm  
# End of macro CALLMONITOR
4522					endif 
4522 3e 0d				ld a, 13 
4524 32 f6 f0				ld (scratch),a 
4527 3e 0a				ld a, 10 
4529 32 f7 f0				ld (scratch+1),a 
452c 3e 00				ld a, 0 
452e 32 f8 f0				ld (scratch+2),a 
4531 21 f6 f0				ld hl, scratch 
4534 cd b6 20				call forth_push_str 
4537					 
4537				       NEXTW 
4537 c3 39 24			jp macro_next 
453a				endm 
# End of macro NEXTW
453a			.SPACE: 
453a				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
453a 46				db WORD_SYS_CORE+50             
453b 70 45			dw .SPACES            
453d 03				db 2 + 1 
453e .. 00			db "BL",0              
4541				endm 
# End of macro CWHEAD
4541			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
4541					if DEBUG_FORTH_WORDS_KEY 
4541						DMARK "BL." 
4541 f5				push af  
4542 3a 56 45			ld a, (.dmark)  
4545 32 a0 fd			ld (debug_mark),a  
4548 3a 57 45			ld a, (.dmark+1)  
454b 32 a1 fd			ld (debug_mark+1),a  
454e 3a 58 45			ld a, (.dmark+2)  
4551 32 a2 fd			ld (debug_mark+2),a  
4554 18 03			jr .pastdmark  
4556 ..			.dmark: db "BL."  
4559 f1			.pastdmark: pop af  
455a			endm  
# End of macro DMARK
455a						CALLMONITOR 
455a cd aa fd			call debug_vector  
455d				endm  
# End of macro CALLMONITOR
455d					endif 
455d 3e 20				ld a, " " 
455f 32 f6 f0				ld (scratch),a 
4562 3e 00				ld a, 0 
4564 32 f7 f0				ld (scratch+1),a 
4567 21 f6 f0				ld hl, scratch 
456a cd b6 20				call forth_push_str 
456d					 
456d				       NEXTW 
456d c3 39 24			jp macro_next 
4570				endm 
# End of macro NEXTW
4570			 
4570			;.blstr: db " ", 0 
4570			 
4570			.SPACES: 
4570				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
4570 47				db WORD_SYS_CORE+51             
4571 0b 46			dw .SCROLL            
4573 07				db 6 + 1 
4574 .. 00			db "SPACES",0              
457b				endm 
# End of macro CWHEAD
457b			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
457b					if DEBUG_FORTH_WORDS_KEY 
457b						DMARK "SPS" 
457b f5				push af  
457c 3a 90 45			ld a, (.dmark)  
457f 32 a0 fd			ld (debug_mark),a  
4582 3a 91 45			ld a, (.dmark+1)  
4585 32 a1 fd			ld (debug_mark+1),a  
4588 3a 92 45			ld a, (.dmark+2)  
458b 32 a2 fd			ld (debug_mark+2),a  
458e 18 03			jr .pastdmark  
4590 ..			.dmark: db "SPS"  
4593 f1			.pastdmark: pop af  
4594			endm  
# End of macro DMARK
4594						CALLMONITOR 
4594 cd aa fd			call debug_vector  
4597				endm  
# End of macro CALLMONITOR
4597					endif 
4597			 
4597			 
4597					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4597 cd 4d 22			call macro_dsp_valuehl 
459a				endm 
# End of macro FORTH_DSP_VALUEHL
459a			 
459a e5					push hl    ; u 
459b					if DEBUG_FORTH_WORDS 
459b						DMARK "SPA" 
459b f5				push af  
459c 3a b0 45			ld a, (.dmark)  
459f 32 a0 fd			ld (debug_mark),a  
45a2 3a b1 45			ld a, (.dmark+1)  
45a5 32 a1 fd			ld (debug_mark+1),a  
45a8 3a b2 45			ld a, (.dmark+2)  
45ab 32 a2 fd			ld (debug_mark+2),a  
45ae 18 03			jr .pastdmark  
45b0 ..			.dmark: db "SPA"  
45b3 f1			.pastdmark: pop af  
45b4			endm  
# End of macro DMARK
45b4						CALLMONITOR 
45b4 cd aa fd			call debug_vector  
45b7				endm  
# End of macro CALLMONITOR
45b7					endif 
45b7			 
45b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45b7 cd 05 23			call macro_forth_dsp_pop 
45ba				endm 
# End of macro FORTH_DSP_POP
45ba e1					pop hl 
45bb 0e 00				ld c, 0 
45bd 45					ld b, l 
45be 21 f6 f0				ld hl, scratch  
45c1			 
45c1					if DEBUG_FORTH_WORDS 
45c1						DMARK "SP2" 
45c1 f5				push af  
45c2 3a d6 45			ld a, (.dmark)  
45c5 32 a0 fd			ld (debug_mark),a  
45c8 3a d7 45			ld a, (.dmark+1)  
45cb 32 a1 fd			ld (debug_mark+1),a  
45ce 3a d8 45			ld a, (.dmark+2)  
45d1 32 a2 fd			ld (debug_mark+2),a  
45d4 18 03			jr .pastdmark  
45d6 ..			.dmark: db "SP2"  
45d9 f1			.pastdmark: pop af  
45da			endm  
# End of macro DMARK
45da						CALLMONITOR 
45da cd aa fd			call debug_vector  
45dd				endm  
# End of macro CALLMONITOR
45dd					endif 
45dd 3e 20				ld a, ' ' 
45df			.spaces1:	 
45df 77					ld (hl),a 
45e0 23					inc hl 
45e1					 
45e1 10 fc				djnz .spaces1 
45e3 3e 00				ld a,0 
45e5 77					ld (hl),a 
45e6 21 f6 f0				ld hl, scratch 
45e9					if DEBUG_FORTH_WORDS 
45e9						DMARK "SP3" 
45e9 f5				push af  
45ea 3a fe 45			ld a, (.dmark)  
45ed 32 a0 fd			ld (debug_mark),a  
45f0 3a ff 45			ld a, (.dmark+1)  
45f3 32 a1 fd			ld (debug_mark+1),a  
45f6 3a 00 46			ld a, (.dmark+2)  
45f9 32 a2 fd			ld (debug_mark+2),a  
45fc 18 03			jr .pastdmark  
45fe ..			.dmark: db "SP3"  
4601 f1			.pastdmark: pop af  
4602			endm  
# End of macro DMARK
4602						CALLMONITOR 
4602 cd aa fd			call debug_vector  
4605				endm  
# End of macro CALLMONITOR
4605					endif 
4605 cd b6 20				call forth_push_str 
4608			 
4608				       NEXTW 
4608 c3 39 24			jp macro_next 
460b				endm 
# End of macro NEXTW
460b			 
460b			 
460b			 
460b			.SCROLL: 
460b				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
460b 53				db WORD_SYS_CORE+63             
460c 38 46			dw .SCROLLD            
460e 07				db 6 + 1 
460f .. 00			db "SCROLL",0              
4616				endm 
# End of macro CWHEAD
4616			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4616					if DEBUG_FORTH_WORDS_KEY 
4616						DMARK "SCR" 
4616 f5				push af  
4617 3a 2b 46			ld a, (.dmark)  
461a 32 a0 fd			ld (debug_mark),a  
461d 3a 2c 46			ld a, (.dmark+1)  
4620 32 a1 fd			ld (debug_mark+1),a  
4623 3a 2d 46			ld a, (.dmark+2)  
4626 32 a2 fd			ld (debug_mark+2),a  
4629 18 03			jr .pastdmark  
462b ..			.dmark: db "SCR"  
462e f1			.pastdmark: pop af  
462f			endm  
# End of macro DMARK
462f						CALLMONITOR 
462f cd aa fd			call debug_vector  
4632				endm  
# End of macro CALLMONITOR
4632					endif 
4632			 
4632 cd 6c 0d			call scroll_up 
4635			;	call update_display 
4635			 
4635					NEXTW 
4635 c3 39 24			jp macro_next 
4638				endm 
# End of macro NEXTW
4638			 
4638			 
4638			 
4638			;		; get dir 
4638			; 
4638			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4638			; 
4638			;		push hl 
4638			; 
4638			;		; destroy value TOS 
4638			; 
4638			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4638			; 
4638			;		; get count 
4638			; 
4638			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4638			; 
4638			;		push hl 
4638			; 
4638			;		; destroy value TOS 
4638			; 
4638			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4638			; 
4638			;		; one value on hl get other one back 
4638			; 
4638			;		pop bc    ; count 
4638			; 
4638			;		pop de   ; dir 
4638			; 
4638			; 
4638			;		ld b, c 
4638			; 
4638			;.scrolldir:     push bc 
4638			;		push de 
4638			; 
4638			;		ld a, 0 
4638			;		cp e 
4638			;		jr z, .scrollup  
4638			;		call scroll_down 
4638			;		jr .scrollnext 
4638			;.scrollup:	call scroll_up 
4638			; 
4638			;		 
4638			;.scrollnext: 
4638			;		pop de 
4638			;		pop bc 
4638			;		djnz .scrolldir 
4638			; 
4638			; 
4638			; 
4638			; 
4638			; 
4638			;		NEXTW 
4638			 
4638			.SCROLLD: 
4638				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4638 53				db WORD_SYS_CORE+63             
4639 66 46			dw .ATQ            
463b 08				db 7 + 1 
463c .. 00			db "SCROLLD",0              
4644				endm 
# End of macro CWHEAD
4644			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4644					if DEBUG_FORTH_WORDS_KEY 
4644						DMARK "SCD" 
4644 f5				push af  
4645 3a 59 46			ld a, (.dmark)  
4648 32 a0 fd			ld (debug_mark),a  
464b 3a 5a 46			ld a, (.dmark+1)  
464e 32 a1 fd			ld (debug_mark+1),a  
4651 3a 5b 46			ld a, (.dmark+2)  
4654 32 a2 fd			ld (debug_mark+2),a  
4657 18 03			jr .pastdmark  
4659 ..			.dmark: db "SCD"  
465c f1			.pastdmark: pop af  
465d			endm  
# End of macro DMARK
465d						CALLMONITOR 
465d cd aa fd			call debug_vector  
4660				endm  
# End of macro CALLMONITOR
4660					endif 
4660			 
4660 cd 90 0d			call scroll_down 
4663			;	call update_display 
4663			 
4663					NEXTW 
4663 c3 39 24			jp macro_next 
4666				endm 
# End of macro NEXTW
4666			 
4666			 
4666			.ATQ: 
4666				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4666 62				db WORD_SYS_CORE+78             
4667 c4 46			dw .AUTODSP            
4669 04				db 3 + 1 
466a .. 00			db "AT@",0              
466e				endm 
# End of macro CWHEAD
466e			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
466e					if DEBUG_FORTH_WORDS_KEY 
466e						DMARK "ATA" 
466e f5				push af  
466f 3a 83 46			ld a, (.dmark)  
4672 32 a0 fd			ld (debug_mark),a  
4675 3a 84 46			ld a, (.dmark+1)  
4678 32 a1 fd			ld (debug_mark+1),a  
467b 3a 85 46			ld a, (.dmark+2)  
467e 32 a2 fd			ld (debug_mark+2),a  
4681 18 03			jr .pastdmark  
4683 ..			.dmark: db "ATA"  
4686 f1			.pastdmark: pop af  
4687			endm  
# End of macro DMARK
4687						CALLMONITOR 
4687 cd aa fd			call debug_vector  
468a				endm  
# End of macro CALLMONITOR
468a					endif 
468a			 
468a			 
468a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
468a cd 4d 22			call macro_dsp_valuehl 
468d				endm 
# End of macro FORTH_DSP_VALUEHL
468d			 
468d					; TODO save cursor row 
468d 7d					ld a,l 
468e fe 02				cp 2 
4690 20 04				jr nz, .crow3aq 
4692 3e 28				ld a, display_row_2 
4694 18 12				jr .ccol1aq 
4696 fe 03		.crow3aq:		cp 3 
4698 20 04				jr nz, .crow4aq 
469a 3e 50				ld a, display_row_3 
469c 18 0a				jr .ccol1aq 
469e fe 04		.crow4aq:		cp 4 
46a0 20 04				jr nz, .crow1aq 
46a2 3e 78				ld a, display_row_4 
46a4 18 02				jr .ccol1aq 
46a6 3e 00		.crow1aq:		ld a,display_row_1 
46a8 f5			.ccol1aq:		push af			; got row offset 
46a9 6f					ld l,a 
46aa 26 00				ld h,0 
46ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46ac cd 05 23			call macro_forth_dsp_pop 
46af				endm 
# End of macro FORTH_DSP_POP
46af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46af cd 4d 22			call macro_dsp_valuehl 
46b2				endm 
# End of macro FORTH_DSP_VALUEHL
46b2					; TODO save cursor col 
46b2 f1					pop af 
46b3 85					add l		; add col offset 
46b4			 
46b4					; add current frame buffer address 
46b4 2a 01 fb				ld hl, (display_fb_active) 
46b7 cd de 0f				call addatohl 
46ba			 
46ba			 
46ba			 
46ba			 
46ba					; get char frame buffer location offset in hl 
46ba			 
46ba 7e					ld a,(hl) 
46bb 26 00				ld h, 0 
46bd 6f					ld l, a 
46be			 
46be cd 48 20				call forth_push_numhl 
46c1			 
46c1			 
46c1					NEXTW 
46c1 c3 39 24			jp macro_next 
46c4				endm 
# End of macro NEXTW
46c4			 
46c4			.AUTODSP: 
46c4				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
46c4 63				db WORD_SYS_CORE+79             
46c5 da 46			dw .MENU            
46c7 05				db 4 + 1 
46c8 .. 00			db "ADSP",0              
46cd				endm 
# End of macro CWHEAD
46cd			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
46cd			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
46cd			 
46cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46cd cd 4d 22			call macro_dsp_valuehl 
46d0				endm 
# End of macro FORTH_DSP_VALUEHL
46d0			 
46d0			;		push hl 
46d0			 
46d0					; destroy value TOS 
46d0			 
46d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46d0 cd 05 23			call macro_forth_dsp_pop 
46d3				endm 
# End of macro FORTH_DSP_POP
46d3			 
46d3			;		pop hl 
46d3			 
46d3 7d					ld a,l 
46d4 32 71 f9				ld (cli_autodisplay), a 
46d7				       NEXTW 
46d7 c3 39 24			jp macro_next 
46da				endm 
# End of macro NEXTW
46da			 
46da			.MENU: 
46da				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
46da 70				db WORD_SYS_CORE+92             
46db 83 47			dw .ENDDISPLAY            
46dd 05				db 4 + 1 
46de .. 00			db "MENU",0              
46e3				endm 
# End of macro CWHEAD
46e3			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
46e3			 
46e3			;		; get number of items on the stack 
46e3			; 
46e3				 
46e3					FORTH_DSP_VALUEHL 
46e3 cd 4d 22			call macro_dsp_valuehl 
46e6				endm 
# End of macro FORTH_DSP_VALUEHL
46e6				 
46e6					if DEBUG_FORTH_WORDS_KEY 
46e6						DMARK "MNU" 
46e6 f5				push af  
46e7 3a fb 46			ld a, (.dmark)  
46ea 32 a0 fd			ld (debug_mark),a  
46ed 3a fc 46			ld a, (.dmark+1)  
46f0 32 a1 fd			ld (debug_mark+1),a  
46f3 3a fd 46			ld a, (.dmark+2)  
46f6 32 a2 fd			ld (debug_mark+2),a  
46f9 18 03			jr .pastdmark  
46fb ..			.dmark: db "MNU"  
46fe f1			.pastdmark: pop af  
46ff			endm  
# End of macro DMARK
46ff						CALLMONITOR 
46ff cd aa fd			call debug_vector  
4702				endm  
# End of macro CALLMONITOR
4702					endif 
4702			 
4702 45					ld b, l	 
4703 05					dec b 
4704			 
4704					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4704 cd 05 23			call macro_forth_dsp_pop 
4707				endm 
# End of macro FORTH_DSP_POP
4707			 
4707			 
4707					; go directly through the stack to pluck out the string pointers and build an array 
4707			 
4707			;		FORTH_DSP 
4707			 
4707					; hl contains top most stack item 
4707				 
4707 11 f6 f0				ld de, scratch 
470a			 
470a			.mbuild: 
470a			 
470a					FORTH_DSP_VALUEHL 
470a cd 4d 22			call macro_dsp_valuehl 
470d				endm 
# End of macro FORTH_DSP_VALUEHL
470d			 
470d					if DEBUG_FORTH_WORDS 
470d						DMARK "MN3" 
470d f5				push af  
470e 3a 22 47			ld a, (.dmark)  
4711 32 a0 fd			ld (debug_mark),a  
4714 3a 23 47			ld a, (.dmark+1)  
4717 32 a1 fd			ld (debug_mark+1),a  
471a 3a 24 47			ld a, (.dmark+2)  
471d 32 a2 fd			ld (debug_mark+2),a  
4720 18 03			jr .pastdmark  
4722 ..			.dmark: db "MN3"  
4725 f1			.pastdmark: pop af  
4726			endm  
# End of macro DMARK
4726						CALLMONITOR 
4726 cd aa fd			call debug_vector  
4729				endm  
# End of macro CALLMONITOR
4729					endif 
4729 eb					ex de, hl 
472a 73					ld (hl), e 
472b 23					inc hl 
472c 72					ld (hl), d 
472d 23					inc hl 
472e eb					ex de, hl 
472f			 
472f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
472f cd 05 23			call macro_forth_dsp_pop 
4732				endm 
# End of macro FORTH_DSP_POP
4732			 
4732 10 d6				djnz .mbuild 
4734			 
4734					; done add term 
4734			 
4734 eb					ex de, hl 
4735 36 00				ld (hl), 0 
4737 23					inc hl 
4738 36 00				ld (hl), 0 
473a			 
473a				 
473a					 
473a 21 f6 f0				ld hl, scratch 
473d			 
473d					if DEBUG_FORTH_WORDS 
473d						DMARK "MNx" 
473d f5				push af  
473e 3a 52 47			ld a, (.dmark)  
4741 32 a0 fd			ld (debug_mark),a  
4744 3a 53 47			ld a, (.dmark+1)  
4747 32 a1 fd			ld (debug_mark+1),a  
474a 3a 54 47			ld a, (.dmark+2)  
474d 32 a2 fd			ld (debug_mark+2),a  
4750 18 03			jr .pastdmark  
4752 ..			.dmark: db "MNx"  
4755 f1			.pastdmark: pop af  
4756			endm  
# End of macro DMARK
4756						CALLMONITOR 
4756 cd aa fd			call debug_vector  
4759				endm  
# End of macro CALLMONITOR
4759					endif 
4759			 
4759			 
4759			 
4759 3e 00				ld a, 0 
475b cd db 0d				call menu 
475e			 
475e			 
475e 6f					ld l, a 
475f 26 00				ld h, 0 
4761			 
4761					if DEBUG_FORTH_WORDS 
4761						DMARK "MNr" 
4761 f5				push af  
4762 3a 76 47			ld a, (.dmark)  
4765 32 a0 fd			ld (debug_mark),a  
4768 3a 77 47			ld a, (.dmark+1)  
476b 32 a1 fd			ld (debug_mark+1),a  
476e 3a 78 47			ld a, (.dmark+2)  
4771 32 a2 fd			ld (debug_mark+2),a  
4774 18 03			jr .pastdmark  
4776 ..			.dmark: db "MNr"  
4779 f1			.pastdmark: pop af  
477a			endm  
# End of macro DMARK
477a						CALLMONITOR 
477a cd aa fd			call debug_vector  
477d				endm  
# End of macro CALLMONITOR
477d					endif 
477d			 
477d cd 48 20				call forth_push_numhl 
4780			 
4780			 
4780			 
4780			 
4780				       NEXTW 
4780 c3 39 24			jp macro_next 
4783				endm 
# End of macro NEXTW
4783			 
4783			 
4783			.ENDDISPLAY: 
4783			 
4783			; eof 
# End of file forth_words_display.asm
4783			include "forth_words_str.asm" 
4783			 
4783			; | ## String Words 
4783			 
4783			.SPLIT:   
4783			 
4783				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
4783 48				db WORD_SYS_CORE+52             
4784 78 48			dw .PTR            
4786 06				db 5 + 1 
4787 .. 00			db "SPLIT",0              
478d				endm 
# End of macro CWHEAD
478d			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
478d					if DEBUG_FORTH_WORDS_KEY 
478d						DMARK "SPT" 
478d f5				push af  
478e 3a a2 47			ld a, (.dmark)  
4791 32 a0 fd			ld (debug_mark),a  
4794 3a a3 47			ld a, (.dmark+1)  
4797 32 a1 fd			ld (debug_mark+1),a  
479a 3a a4 47			ld a, (.dmark+2)  
479d 32 a2 fd			ld (debug_mark+2),a  
47a0 18 03			jr .pastdmark  
47a2 ..			.dmark: db "SPT"  
47a5 f1			.pastdmark: pop af  
47a6			endm  
# End of macro DMARK
47a6						CALLMONITOR 
47a6 cd aa fd			call debug_vector  
47a9				endm  
# End of macro CALLMONITOR
47a9					endif 
47a9			 
47a9					; get delim 
47a9					FORTH_DSP_VALUEHL 
47a9 cd 4d 22			call macro_dsp_valuehl 
47ac				endm 
# End of macro FORTH_DSP_VALUEHL
47ac			 
47ac					FORTH_DSP_POP 
47ac cd 05 23			call macro_forth_dsp_pop 
47af				endm 
# End of macro FORTH_DSP_POP
47af					 
47af			 
47af 45					ld b, l    ; move delim to b 
47b0 0e 01				ld c, 1   ; count of poritions 
47b2			 
47b2 c5					push bc 
47b3			 
47b3					if DEBUG_FORTH_WORDS 
47b3						DMARK "SPa" 
47b3 f5				push af  
47b4 3a c8 47			ld a, (.dmark)  
47b7 32 a0 fd			ld (debug_mark),a  
47ba 3a c9 47			ld a, (.dmark+1)  
47bd 32 a1 fd			ld (debug_mark+1),a  
47c0 3a ca 47			ld a, (.dmark+2)  
47c3 32 a2 fd			ld (debug_mark+2),a  
47c6 18 03			jr .pastdmark  
47c8 ..			.dmark: db "SPa"  
47cb f1			.pastdmark: pop af  
47cc			endm  
# End of macro DMARK
47cc						CALLMONITOR 
47cc cd aa fd			call debug_vector  
47cf				endm  
# End of macro CALLMONITOR
47cf					endif 
47cf					; get pointer to string to chop up 
47cf					FORTH_DSP_VALUEHL 
47cf cd 4d 22			call macro_dsp_valuehl 
47d2				endm 
# End of macro FORTH_DSP_VALUEHL
47d2			 
47d2			;		push hl 
47d2 11 f6 f0				ld de, scratch 
47d5			.spllop: 
47d5 c1					pop bc 
47d6 c5					push bc 
47d7			;		pop hl 
47d7					if DEBUG_FORTH_WORDS 
47d7						DMARK "SPl" 
47d7 f5				push af  
47d8 3a ec 47			ld a, (.dmark)  
47db 32 a0 fd			ld (debug_mark),a  
47de 3a ed 47			ld a, (.dmark+1)  
47e1 32 a1 fd			ld (debug_mark+1),a  
47e4 3a ee 47			ld a, (.dmark+2)  
47e7 32 a2 fd			ld (debug_mark+2),a  
47ea 18 03			jr .pastdmark  
47ec ..			.dmark: db "SPl"  
47ef f1			.pastdmark: pop af  
47f0			endm  
# End of macro DMARK
47f0						CALLMONITOR 
47f0 cd aa fd			call debug_vector  
47f3				endm  
# End of macro CALLMONITOR
47f3					endif 
47f3 7e					ld a, (hl) 
47f4 b8					cp b 
47f5 28 08				jr z, .splnxt 
47f7 fe 00				cp 0 
47f9 28 34				jr z, .splend 
47fb ed a0				ldi 
47fd 18 d6				jr .spllop 
47ff			 
47ff					; hit dlim 
47ff			 
47ff			.splnxt: 
47ff					if DEBUG_FORTH_WORDS 
47ff						DMARK "SPx" 
47ff f5				push af  
4800 3a 14 48			ld a, (.dmark)  
4803 32 a0 fd			ld (debug_mark),a  
4806 3a 15 48			ld a, (.dmark+1)  
4809 32 a1 fd			ld (debug_mark+1),a  
480c 3a 16 48			ld a, (.dmark+2)  
480f 32 a2 fd			ld (debug_mark+2),a  
4812 18 03			jr .pastdmark  
4814 ..			.dmark: db "SPx"  
4817 f1			.pastdmark: pop af  
4818			endm  
# End of macro DMARK
4818						CALLMONITOR 
4818 cd aa fd			call debug_vector  
481b				endm  
# End of macro CALLMONITOR
481b					endif 
481b 3e 00				ld a, 0 
481d 12					ld (de), a 
481e					;ex de, hl 
481e e5					push hl 
481f 21 f6 f0				ld hl, scratch 
4822 cd b6 20				call forth_push_str 
4825 e1					pop hl 
4826					;ex de, hl 
4826 23					inc hl 
4827 c1					pop bc 
4828 0c					inc c 
4829 c5					push bc 
482a 11 f6 f0				ld de, scratch 
482d 18 a6				jr .spllop 
482f			 
482f			.splend:		 
482f					if DEBUG_FORTH_WORDS 
482f						DMARK "SPe" 
482f f5				push af  
4830 3a 44 48			ld a, (.dmark)  
4833 32 a0 fd			ld (debug_mark),a  
4836 3a 45 48			ld a, (.dmark+1)  
4839 32 a1 fd			ld (debug_mark+1),a  
483c 3a 46 48			ld a, (.dmark+2)  
483f 32 a2 fd			ld (debug_mark+2),a  
4842 18 03			jr .pastdmark  
4844 ..			.dmark: db "SPe"  
4847 f1			.pastdmark: pop af  
4848			endm  
# End of macro DMARK
4848						CALLMONITOR 
4848 cd aa fd			call debug_vector  
484b				endm  
# End of macro CALLMONITOR
484b					endif 
484b 12					ld (de), a 
484c eb					ex de, hl 
484d			;		push hl 
484d 21 f6 f0				ld hl, scratch 
4850 cd b6 20				call forth_push_str 
4853					 
4853					if DEBUG_FORTH_WORDS 
4853						DMARK "SPc" 
4853 f5				push af  
4854 3a 68 48			ld a, (.dmark)  
4857 32 a0 fd			ld (debug_mark),a  
485a 3a 69 48			ld a, (.dmark+1)  
485d 32 a1 fd			ld (debug_mark+1),a  
4860 3a 6a 48			ld a, (.dmark+2)  
4863 32 a2 fd			ld (debug_mark+2),a  
4866 18 03			jr .pastdmark  
4868 ..			.dmark: db "SPc"  
486b f1			.pastdmark: pop af  
486c			endm  
# End of macro DMARK
486c						CALLMONITOR 
486c cd aa fd			call debug_vector  
486f				endm  
# End of macro CALLMONITOR
486f					endif 
486f			 
486f e1					pop hl    ; get counter from bc which has been push 
4870 26 00				ld h, 0 
4872			;		ld l, c 
4872 cd 48 20				call forth_push_numhl 
4875			 
4875			 
4875				NEXTW 
4875 c3 39 24			jp macro_next 
4878				endm 
# End of macro NEXTW
4878			.PTR:   
4878			 
4878				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4878 48				db WORD_SYS_CORE+52             
4879 a5 48			dw .STYPE            
487b 04				db 3 + 1 
487c .. 00			db "PTR",0              
4880				endm 
# End of macro CWHEAD
4880			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4880			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4880			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4880			 
4880					if DEBUG_FORTH_WORDS_KEY 
4880						DMARK "PTR" 
4880 f5				push af  
4881 3a 95 48			ld a, (.dmark)  
4884 32 a0 fd			ld (debug_mark),a  
4887 3a 96 48			ld a, (.dmark+1)  
488a 32 a1 fd			ld (debug_mark+1),a  
488d 3a 97 48			ld a, (.dmark+2)  
4890 32 a2 fd			ld (debug_mark+2),a  
4893 18 03			jr .pastdmark  
4895 ..			.dmark: db "PTR"  
4898 f1			.pastdmark: pop af  
4899			endm  
# End of macro DMARK
4899						CALLMONITOR 
4899 cd aa fd			call debug_vector  
489c				endm  
# End of macro CALLMONITOR
489c					endif 
489c					FORTH_DSP_VALUEHL 
489c cd 4d 22			call macro_dsp_valuehl 
489f				endm 
# End of macro FORTH_DSP_VALUEHL
489f cd 48 20				call forth_push_numhl 
48a2			 
48a2			 
48a2					NEXTW 
48a2 c3 39 24			jp macro_next 
48a5				endm 
# End of macro NEXTW
48a5			.STYPE: 
48a5				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
48a5 48				db WORD_SYS_CORE+52             
48a6 f4 48			dw .UPPER            
48a8 06				db 5 + 1 
48a9 .. 00			db "STYPE",0              
48af				endm 
# End of macro CWHEAD
48af			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
48af					if DEBUG_FORTH_WORDS_KEY 
48af						DMARK "STY" 
48af f5				push af  
48b0 3a c4 48			ld a, (.dmark)  
48b3 32 a0 fd			ld (debug_mark),a  
48b6 3a c5 48			ld a, (.dmark+1)  
48b9 32 a1 fd			ld (debug_mark+1),a  
48bc 3a c6 48			ld a, (.dmark+2)  
48bf 32 a2 fd			ld (debug_mark+2),a  
48c2 18 03			jr .pastdmark  
48c4 ..			.dmark: db "STY"  
48c7 f1			.pastdmark: pop af  
48c8			endm  
# End of macro DMARK
48c8						CALLMONITOR 
48c8 cd aa fd			call debug_vector  
48cb				endm  
# End of macro CALLMONITOR
48cb					endif 
48cb					FORTH_DSP 
48cb cd 13 22			call macro_forth_dsp 
48ce				endm 
# End of macro FORTH_DSP
48ce					;v5 FORTH_DSP_VALUE 
48ce			 
48ce 7e					ld a, (hl) 
48cf			 
48cf f5					push af 
48d0			 
48d0			; Dont destroy TOS		FORTH_DSP_POP 
48d0			 
48d0 f1					pop af 
48d1			 
48d1 fe 01				cp DS_TYPE_STR 
48d3 28 09				jr z, .typestr 
48d5			 
48d5 fe 02				cp DS_TYPE_INUM 
48d7 28 0a				jr z, .typeinum 
48d9			 
48d9 21 f2 48				ld hl, .tna 
48dc 18 0a				jr .tpush 
48de			 
48de 21 ee 48		.typestr:	ld hl, .tstr 
48e1 18 05				jr .tpush 
48e3 21 f0 48		.typeinum:	ld hl, .tinum 
48e6 18 00				jr .tpush 
48e8			 
48e8			.tpush: 
48e8			 
48e8 cd b6 20				call forth_push_str 
48eb			 
48eb					NEXTW 
48eb c3 39 24			jp macro_next 
48ee				endm 
# End of macro NEXTW
48ee .. 00		.tstr:	db "s",0 
48f0 .. 00		.tinum:  db "i",0 
48f2 .. 00		.tna:   db "?", 0 
48f4			 
48f4			 
48f4			.UPPER: 
48f4				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
48f4 48				db WORD_SYS_CORE+52             
48f5 2f 49			dw .LOWER            
48f7 06				db 5 + 1 
48f8 .. 00			db "UPPER",0              
48fe				endm 
# End of macro CWHEAD
48fe			; | UPPER ( s -- s ) Upper case string s  | DONE 
48fe					if DEBUG_FORTH_WORDS_KEY 
48fe						DMARK "UPR" 
48fe f5				push af  
48ff 3a 13 49			ld a, (.dmark)  
4902 32 a0 fd			ld (debug_mark),a  
4905 3a 14 49			ld a, (.dmark+1)  
4908 32 a1 fd			ld (debug_mark+1),a  
490b 3a 15 49			ld a, (.dmark+2)  
490e 32 a2 fd			ld (debug_mark+2),a  
4911 18 03			jr .pastdmark  
4913 ..			.dmark: db "UPR"  
4916 f1			.pastdmark: pop af  
4917			endm  
# End of macro DMARK
4917						CALLMONITOR 
4917 cd aa fd			call debug_vector  
491a				endm  
# End of macro CALLMONITOR
491a					endif 
491a			 
491a					FORTH_DSP 
491a cd 13 22			call macro_forth_dsp 
491d				endm 
# End of macro FORTH_DSP
491d					 
491d			; TODO check is string type 
491d			 
491d					FORTH_DSP_VALUEHL 
491d cd 4d 22			call macro_dsp_valuehl 
4920				endm 
# End of macro FORTH_DSP_VALUEHL
4920			; get pointer to string in hl 
4920			 
4920 7e			.toup:		ld a, (hl) 
4921 fe 00				cp 0 
4923 28 07				jr z, .toupdone 
4925			 
4925 cd 53 12				call to_upper 
4928			 
4928 77					ld (hl), a 
4929 23					inc hl 
492a 18 f4				jr .toup 
492c			 
492c					 
492c			 
492c			 
492c			; for each char convert to upper 
492c					 
492c			.toupdone: 
492c			 
492c			 
492c					NEXTW 
492c c3 39 24			jp macro_next 
492f				endm 
# End of macro NEXTW
492f			.LOWER: 
492f				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
492f 48				db WORD_SYS_CORE+52             
4930 6a 49			dw .TCASE            
4932 06				db 5 + 1 
4933 .. 00			db "LOWER",0              
4939				endm 
# End of macro CWHEAD
4939			; | LOWER ( s -- s ) Lower case string s  | DONE 
4939					if DEBUG_FORTH_WORDS_KEY 
4939						DMARK "LWR" 
4939 f5				push af  
493a 3a 4e 49			ld a, (.dmark)  
493d 32 a0 fd			ld (debug_mark),a  
4940 3a 4f 49			ld a, (.dmark+1)  
4943 32 a1 fd			ld (debug_mark+1),a  
4946 3a 50 49			ld a, (.dmark+2)  
4949 32 a2 fd			ld (debug_mark+2),a  
494c 18 03			jr .pastdmark  
494e ..			.dmark: db "LWR"  
4951 f1			.pastdmark: pop af  
4952			endm  
# End of macro DMARK
4952						CALLMONITOR 
4952 cd aa fd			call debug_vector  
4955				endm  
# End of macro CALLMONITOR
4955					endif 
4955			 
4955					FORTH_DSP 
4955 cd 13 22			call macro_forth_dsp 
4958				endm 
# End of macro FORTH_DSP
4958					 
4958			; TODO check is string type 
4958			 
4958					FORTH_DSP_VALUEHL 
4958 cd 4d 22			call macro_dsp_valuehl 
495b				endm 
# End of macro FORTH_DSP_VALUEHL
495b			; get pointer to string in hl 
495b			 
495b 7e			.tolow:		ld a, (hl) 
495c fe 00				cp 0 
495e 28 07				jr z, .tolowdone 
4960			 
4960 cd 5c 12				call to_lower 
4963			 
4963 77					ld (hl), a 
4964 23					inc hl 
4965 18 f4				jr .tolow 
4967			 
4967					 
4967			 
4967			 
4967			; for each char convert to low 
4967					 
4967			.tolowdone: 
4967					NEXTW 
4967 c3 39 24			jp macro_next 
496a				endm 
# End of macro NEXTW
496a			.TCASE: 
496a				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
496a 48				db WORD_SYS_CORE+52             
496b a0 4a			dw .SUBSTR            
496d 06				db 5 + 1 
496e .. 00			db "TCASE",0              
4974				endm 
# End of macro CWHEAD
4974			; | TCASE ( s -- s ) Title case string s  | DONE 
4974					if DEBUG_FORTH_WORDS_KEY 
4974						DMARK "TCS" 
4974 f5				push af  
4975 3a 89 49			ld a, (.dmark)  
4978 32 a0 fd			ld (debug_mark),a  
497b 3a 8a 49			ld a, (.dmark+1)  
497e 32 a1 fd			ld (debug_mark+1),a  
4981 3a 8b 49			ld a, (.dmark+2)  
4984 32 a2 fd			ld (debug_mark+2),a  
4987 18 03			jr .pastdmark  
4989 ..			.dmark: db "TCS"  
498c f1			.pastdmark: pop af  
498d			endm  
# End of macro DMARK
498d						CALLMONITOR 
498d cd aa fd			call debug_vector  
4990				endm  
# End of macro CALLMONITOR
4990					endif 
4990			 
4990					FORTH_DSP 
4990 cd 13 22			call macro_forth_dsp 
4993				endm 
# End of macro FORTH_DSP
4993					 
4993			; TODO check is string type 
4993			 
4993					FORTH_DSP_VALUEHL 
4993 cd 4d 22			call macro_dsp_valuehl 
4996				endm 
# End of macro FORTH_DSP_VALUEHL
4996			; get pointer to string in hl 
4996			 
4996					if DEBUG_FORTH_WORDS 
4996						DMARK "TC1" 
4996 f5				push af  
4997 3a ab 49			ld a, (.dmark)  
499a 32 a0 fd			ld (debug_mark),a  
499d 3a ac 49			ld a, (.dmark+1)  
49a0 32 a1 fd			ld (debug_mark+1),a  
49a3 3a ad 49			ld a, (.dmark+2)  
49a6 32 a2 fd			ld (debug_mark+2),a  
49a9 18 03			jr .pastdmark  
49ab ..			.dmark: db "TC1"  
49ae f1			.pastdmark: pop af  
49af			endm  
# End of macro DMARK
49af						CALLMONITOR 
49af cd aa fd			call debug_vector  
49b2				endm  
# End of macro CALLMONITOR
49b2					endif 
49b2			 
49b2					; first time in turn to upper case first char 
49b2			 
49b2 7e					ld a, (hl) 
49b3 c3 3d 4a				jp .totsiptou 
49b6			 
49b6			 
49b6 7e			.tot:		ld a, (hl) 
49b7 fe 00				cp 0 
49b9 ca 81 4a				jp z, .totdone 
49bc			 
49bc					if DEBUG_FORTH_WORDS 
49bc						DMARK "TC2" 
49bc f5				push af  
49bd 3a d1 49			ld a, (.dmark)  
49c0 32 a0 fd			ld (debug_mark),a  
49c3 3a d2 49			ld a, (.dmark+1)  
49c6 32 a1 fd			ld (debug_mark+1),a  
49c9 3a d3 49			ld a, (.dmark+2)  
49cc 32 a2 fd			ld (debug_mark+2),a  
49cf 18 03			jr .pastdmark  
49d1 ..			.dmark: db "TC2"  
49d4 f1			.pastdmark: pop af  
49d5			endm  
# End of macro DMARK
49d5						CALLMONITOR 
49d5 cd aa fd			call debug_vector  
49d8				endm  
# End of macro CALLMONITOR
49d8					endif 
49d8					; check to see if current char is a space 
49d8			 
49d8 fe 20				cp ' ' 
49da 28 21				jr z, .totsp 
49dc cd 5c 12				call to_lower 
49df					if DEBUG_FORTH_WORDS 
49df						DMARK "TC3" 
49df f5				push af  
49e0 3a f4 49			ld a, (.dmark)  
49e3 32 a0 fd			ld (debug_mark),a  
49e6 3a f5 49			ld a, (.dmark+1)  
49e9 32 a1 fd			ld (debug_mark+1),a  
49ec 3a f6 49			ld a, (.dmark+2)  
49ef 32 a2 fd			ld (debug_mark+2),a  
49f2 18 03			jr .pastdmark  
49f4 ..			.dmark: db "TC3"  
49f7 f1			.pastdmark: pop af  
49f8			endm  
# End of macro DMARK
49f8						CALLMONITOR 
49f8 cd aa fd			call debug_vector  
49fb				endm  
# End of macro CALLMONITOR
49fb					endif 
49fb 18 63				jr .totnxt 
49fd			 
49fd			.totsp:         ; on a space, find next char which should be upper 
49fd			 
49fd					if DEBUG_FORTH_WORDS 
49fd						DMARK "TC4" 
49fd f5				push af  
49fe 3a 12 4a			ld a, (.dmark)  
4a01 32 a0 fd			ld (debug_mark),a  
4a04 3a 13 4a			ld a, (.dmark+1)  
4a07 32 a1 fd			ld (debug_mark+1),a  
4a0a 3a 14 4a			ld a, (.dmark+2)  
4a0d 32 a2 fd			ld (debug_mark+2),a  
4a10 18 03			jr .pastdmark  
4a12 ..			.dmark: db "TC4"  
4a15 f1			.pastdmark: pop af  
4a16			endm  
# End of macro DMARK
4a16						CALLMONITOR 
4a16 cd aa fd			call debug_vector  
4a19				endm  
# End of macro CALLMONITOR
4a19					endif 
4a19					;; 
4a19			 
4a19 fe 20				cp ' ' 
4a1b 20 20				jr nz, .totsiptou 
4a1d 23					inc hl 
4a1e 7e					ld a, (hl) 
4a1f					if DEBUG_FORTH_WORDS 
4a1f						DMARK "TC5" 
4a1f f5				push af  
4a20 3a 34 4a			ld a, (.dmark)  
4a23 32 a0 fd			ld (debug_mark),a  
4a26 3a 35 4a			ld a, (.dmark+1)  
4a29 32 a1 fd			ld (debug_mark+1),a  
4a2c 3a 36 4a			ld a, (.dmark+2)  
4a2f 32 a2 fd			ld (debug_mark+2),a  
4a32 18 03			jr .pastdmark  
4a34 ..			.dmark: db "TC5"  
4a37 f1			.pastdmark: pop af  
4a38			endm  
# End of macro DMARK
4a38						CALLMONITOR 
4a38 cd aa fd			call debug_vector  
4a3b				endm  
# End of macro CALLMONITOR
4a3b					endif 
4a3b 18 c0				jr .totsp 
4a3d fe 00		.totsiptou:    cp 0 
4a3f 28 40				jr z, .totdone 
4a41					; not space and not zero term so upper case it 
4a41 cd 53 12				call to_upper 
4a44			 
4a44					if DEBUG_FORTH_WORDS 
4a44						DMARK "TC6" 
4a44 f5				push af  
4a45 3a 59 4a			ld a, (.dmark)  
4a48 32 a0 fd			ld (debug_mark),a  
4a4b 3a 5a 4a			ld a, (.dmark+1)  
4a4e 32 a1 fd			ld (debug_mark+1),a  
4a51 3a 5b 4a			ld a, (.dmark+2)  
4a54 32 a2 fd			ld (debug_mark+2),a  
4a57 18 03			jr .pastdmark  
4a59 ..			.dmark: db "TC6"  
4a5c f1			.pastdmark: pop af  
4a5d			endm  
# End of macro DMARK
4a5d						CALLMONITOR 
4a5d cd aa fd			call debug_vector  
4a60				endm  
# End of macro CALLMONITOR
4a60					endif 
4a60			 
4a60			 
4a60			.totnxt: 
4a60			 
4a60 77					ld (hl), a 
4a61 23					inc hl 
4a62					if DEBUG_FORTH_WORDS 
4a62						DMARK "TC7" 
4a62 f5				push af  
4a63 3a 77 4a			ld a, (.dmark)  
4a66 32 a0 fd			ld (debug_mark),a  
4a69 3a 78 4a			ld a, (.dmark+1)  
4a6c 32 a1 fd			ld (debug_mark+1),a  
4a6f 3a 79 4a			ld a, (.dmark+2)  
4a72 32 a2 fd			ld (debug_mark+2),a  
4a75 18 03			jr .pastdmark  
4a77 ..			.dmark: db "TC7"  
4a7a f1			.pastdmark: pop af  
4a7b			endm  
# End of macro DMARK
4a7b						CALLMONITOR 
4a7b cd aa fd			call debug_vector  
4a7e				endm  
# End of macro CALLMONITOR
4a7e					endif 
4a7e c3 b6 49				jp .tot 
4a81			 
4a81					 
4a81			 
4a81			 
4a81			; for each char convert to low 
4a81					 
4a81			.totdone: 
4a81					if DEBUG_FORTH_WORDS 
4a81						DMARK "TCd" 
4a81 f5				push af  
4a82 3a 96 4a			ld a, (.dmark)  
4a85 32 a0 fd			ld (debug_mark),a  
4a88 3a 97 4a			ld a, (.dmark+1)  
4a8b 32 a1 fd			ld (debug_mark+1),a  
4a8e 3a 98 4a			ld a, (.dmark+2)  
4a91 32 a2 fd			ld (debug_mark+2),a  
4a94 18 03			jr .pastdmark  
4a96 ..			.dmark: db "TCd"  
4a99 f1			.pastdmark: pop af  
4a9a			endm  
# End of macro DMARK
4a9a						CALLMONITOR 
4a9a cd aa fd			call debug_vector  
4a9d				endm  
# End of macro CALLMONITOR
4a9d					endif 
4a9d					NEXTW 
4a9d c3 39 24			jp macro_next 
4aa0				endm 
# End of macro NEXTW
4aa0			 
4aa0			.SUBSTR: 
4aa0				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4aa0 48				db WORD_SYS_CORE+52             
4aa1 fe 4a			dw .LEFT            
4aa3 07				db 6 + 1 
4aa4 .. 00			db "SUBSTR",0              
4aab				endm 
# End of macro CWHEAD
4aab			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4aab			 
4aab					if DEBUG_FORTH_WORDS_KEY 
4aab						DMARK "SST" 
4aab f5				push af  
4aac 3a c0 4a			ld a, (.dmark)  
4aaf 32 a0 fd			ld (debug_mark),a  
4ab2 3a c1 4a			ld a, (.dmark+1)  
4ab5 32 a1 fd			ld (debug_mark+1),a  
4ab8 3a c2 4a			ld a, (.dmark+2)  
4abb 32 a2 fd			ld (debug_mark+2),a  
4abe 18 03			jr .pastdmark  
4ac0 ..			.dmark: db "SST"  
4ac3 f1			.pastdmark: pop af  
4ac4			endm  
# End of macro DMARK
4ac4						CALLMONITOR 
4ac4 cd aa fd			call debug_vector  
4ac7				endm  
# End of macro CALLMONITOR
4ac7					endif 
4ac7			; TODO check string type 
4ac7					FORTH_DSP_VALUEHL 
4ac7 cd 4d 22			call macro_dsp_valuehl 
4aca				endm 
# End of macro FORTH_DSP_VALUEHL
4aca			 
4aca e5					push hl      ; string length 
4acb			 
4acb					FORTH_DSP_POP 
4acb cd 05 23			call macro_forth_dsp_pop 
4ace				endm 
# End of macro FORTH_DSP_POP
4ace			 
4ace					FORTH_DSP_VALUEHL 
4ace cd 4d 22			call macro_dsp_valuehl 
4ad1				endm 
# End of macro FORTH_DSP_VALUEHL
4ad1			 
4ad1 e5					push hl     ; start char 
4ad2			 
4ad2					FORTH_DSP_POP 
4ad2 cd 05 23			call macro_forth_dsp_pop 
4ad5				endm 
# End of macro FORTH_DSP_POP
4ad5			 
4ad5			 
4ad5					FORTH_DSP_VALUE 
4ad5 cd 36 22			call macro_forth_dsp_value 
4ad8				endm 
# End of macro FORTH_DSP_VALUE
4ad8			 
4ad8 d1					pop de    ; get start post offset 
4ad9			 
4ad9 19					add hl, de    ; starting offset 
4ada			 
4ada c1					pop bc 
4adb c5					push bc      ; grab size of string 
4adc			 
4adc e5					push hl    ; save string start  
4add			 
4add 26 00				ld h, 0 
4adf 69					ld l, c 
4ae0 23					inc hl 
4ae1 23					inc hl 
4ae2			 
4ae2 cd b9 13				call malloc 
4ae5				if DEBUG_FORTH_MALLOC_GUARD 
4ae5 cc e0 60				call z,malloc_error 
4ae8				endif 
4ae8			 
4ae8 eb					ex de, hl      ; save malloc area for string copy 
4ae9 e1					pop hl    ; get back source 
4aea c1					pop bc    ; get length of string back 
4aeb			 
4aeb d5					push de    ; save malloc area for after we push 
4aec ed b0				ldir     ; copy substr 
4aee			 
4aee			 
4aee eb					ex de, hl 
4aef 3e 00				ld a, 0 
4af1 77					ld (hl), a   ; term substr 
4af2			 
4af2					 
4af2 e1					pop hl    ; get malloc so we can push it 
4af3 e5					push hl   ; save so we can free it afterwards 
4af4			 
4af4 cd b6 20				call forth_push_str 
4af7			 
4af7 e1					pop hl 
4af8 cd 83 14				call free 
4afb			 
4afb					 
4afb					 
4afb			 
4afb			 
4afb					NEXTW 
4afb c3 39 24			jp macro_next 
4afe				endm 
# End of macro NEXTW
4afe			 
4afe			.LEFT: 
4afe				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4afe 48				db WORD_SYS_CORE+52             
4aff 26 4b			dw .RIGHT            
4b01 05				db 4 + 1 
4b02 .. 00			db "LEFT",0              
4b07				endm 
# End of macro CWHEAD
4b07			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4b07					if DEBUG_FORTH_WORDS_KEY 
4b07						DMARK "LEF" 
4b07 f5				push af  
4b08 3a 1c 4b			ld a, (.dmark)  
4b0b 32 a0 fd			ld (debug_mark),a  
4b0e 3a 1d 4b			ld a, (.dmark+1)  
4b11 32 a1 fd			ld (debug_mark+1),a  
4b14 3a 1e 4b			ld a, (.dmark+2)  
4b17 32 a2 fd			ld (debug_mark+2),a  
4b1a 18 03			jr .pastdmark  
4b1c ..			.dmark: db "LEF"  
4b1f f1			.pastdmark: pop af  
4b20			endm  
# End of macro DMARK
4b20						CALLMONITOR 
4b20 cd aa fd			call debug_vector  
4b23				endm  
# End of macro CALLMONITOR
4b23					endif 
4b23			 
4b23					NEXTW 
4b23 c3 39 24			jp macro_next 
4b26				endm 
# End of macro NEXTW
4b26			.RIGHT: 
4b26				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4b26 48				db WORD_SYS_CORE+52             
4b27 4f 4b			dw .STR2NUM            
4b29 06				db 5 + 1 
4b2a .. 00			db "RIGHT",0              
4b30				endm 
# End of macro CWHEAD
4b30			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4b30					if DEBUG_FORTH_WORDS_KEY 
4b30						DMARK "RIG" 
4b30 f5				push af  
4b31 3a 45 4b			ld a, (.dmark)  
4b34 32 a0 fd			ld (debug_mark),a  
4b37 3a 46 4b			ld a, (.dmark+1)  
4b3a 32 a1 fd			ld (debug_mark+1),a  
4b3d 3a 47 4b			ld a, (.dmark+2)  
4b40 32 a2 fd			ld (debug_mark+2),a  
4b43 18 03			jr .pastdmark  
4b45 ..			.dmark: db "RIG"  
4b48 f1			.pastdmark: pop af  
4b49			endm  
# End of macro DMARK
4b49						CALLMONITOR 
4b49 cd aa fd			call debug_vector  
4b4c				endm  
# End of macro CALLMONITOR
4b4c					endif 
4b4c			 
4b4c					NEXTW 
4b4c c3 39 24			jp macro_next 
4b4f				endm 
# End of macro NEXTW
4b4f			 
4b4f			 
4b4f			.STR2NUM: 
4b4f				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4b4f 48				db WORD_SYS_CORE+52             
4b50 db 4b			dw .NUM2STR            
4b52 08				db 7 + 1 
4b53 .. 00			db "STR2NUM",0              
4b5b				endm 
# End of macro CWHEAD
4b5b			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4b5b			 
4b5b			 
4b5b			; TODO STR type check to do 
4b5b					if DEBUG_FORTH_WORDS_KEY 
4b5b						DMARK "S2N" 
4b5b f5				push af  
4b5c 3a 70 4b			ld a, (.dmark)  
4b5f 32 a0 fd			ld (debug_mark),a  
4b62 3a 71 4b			ld a, (.dmark+1)  
4b65 32 a1 fd			ld (debug_mark+1),a  
4b68 3a 72 4b			ld a, (.dmark+2)  
4b6b 32 a2 fd			ld (debug_mark+2),a  
4b6e 18 03			jr .pastdmark  
4b70 ..			.dmark: db "S2N"  
4b73 f1			.pastdmark: pop af  
4b74			endm  
# End of macro DMARK
4b74						CALLMONITOR 
4b74 cd aa fd			call debug_vector  
4b77				endm  
# End of macro CALLMONITOR
4b77					endif 
4b77			 
4b77					;FORTH_DSP 
4b77					FORTH_DSP_VALUE 
4b77 cd 36 22			call macro_forth_dsp_value 
4b7a				endm 
# End of macro FORTH_DSP_VALUE
4b7a					;inc hl 
4b7a			 
4b7a eb					ex de, hl 
4b7b					if DEBUG_FORTH_WORDS 
4b7b						DMARK "S2a" 
4b7b f5				push af  
4b7c 3a 90 4b			ld a, (.dmark)  
4b7f 32 a0 fd			ld (debug_mark),a  
4b82 3a 91 4b			ld a, (.dmark+1)  
4b85 32 a1 fd			ld (debug_mark+1),a  
4b88 3a 92 4b			ld a, (.dmark+2)  
4b8b 32 a2 fd			ld (debug_mark+2),a  
4b8e 18 03			jr .pastdmark  
4b90 ..			.dmark: db "S2a"  
4b93 f1			.pastdmark: pop af  
4b94			endm  
# End of macro DMARK
4b94						CALLMONITOR 
4b94 cd aa fd			call debug_vector  
4b97				endm  
# End of macro CALLMONITOR
4b97					endif 
4b97 cd db 12				call string_to_uint16 
4b9a			 
4b9a					if DEBUG_FORTH_WORDS 
4b9a						DMARK "S2b" 
4b9a f5				push af  
4b9b 3a af 4b			ld a, (.dmark)  
4b9e 32 a0 fd			ld (debug_mark),a  
4ba1 3a b0 4b			ld a, (.dmark+1)  
4ba4 32 a1 fd			ld (debug_mark+1),a  
4ba7 3a b1 4b			ld a, (.dmark+2)  
4baa 32 a2 fd			ld (debug_mark+2),a  
4bad 18 03			jr .pastdmark  
4baf ..			.dmark: db "S2b"  
4bb2 f1			.pastdmark: pop af  
4bb3			endm  
# End of macro DMARK
4bb3						CALLMONITOR 
4bb3 cd aa fd			call debug_vector  
4bb6				endm  
# End of macro CALLMONITOR
4bb6					endif 
4bb6			;		push hl 
4bb6					FORTH_DSP_POP 
4bb6 cd 05 23			call macro_forth_dsp_pop 
4bb9				endm 
# End of macro FORTH_DSP_POP
4bb9			;		pop hl 
4bb9					 
4bb9					if DEBUG_FORTH_WORDS 
4bb9						DMARK "S2b" 
4bb9 f5				push af  
4bba 3a ce 4b			ld a, (.dmark)  
4bbd 32 a0 fd			ld (debug_mark),a  
4bc0 3a cf 4b			ld a, (.dmark+1)  
4bc3 32 a1 fd			ld (debug_mark+1),a  
4bc6 3a d0 4b			ld a, (.dmark+2)  
4bc9 32 a2 fd			ld (debug_mark+2),a  
4bcc 18 03			jr .pastdmark  
4bce ..			.dmark: db "S2b"  
4bd1 f1			.pastdmark: pop af  
4bd2			endm  
# End of macro DMARK
4bd2						CALLMONITOR 
4bd2 cd aa fd			call debug_vector  
4bd5				endm  
# End of macro CALLMONITOR
4bd5					endif 
4bd5 cd 48 20				call forth_push_numhl	 
4bd8			 
4bd8				 
4bd8				       NEXTW 
4bd8 c3 39 24			jp macro_next 
4bdb				endm 
# End of macro NEXTW
4bdb			.NUM2STR: 
4bdb				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4bdb 48				db WORD_SYS_CORE+52             
4bdc 6d 4c			dw .CONCAT            
4bde 08				db 7 + 1 
4bdf .. 00			db "NUM2STR",0              
4be7				endm 
# End of macro CWHEAD
4be7			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
4be7			 
4be7			;		; malloc a string to target 
4be7			;		ld hl, 10     ; TODO max string size should be fine 
4be7			;		call malloc 
4be7			;		push hl    ; save malloc location 
4be7			; 
4be7			; 
4be7			;; TODO check int type 
4be7					if DEBUG_FORTH_WORDS_KEY 
4be7						DMARK "N2S" 
4be7 f5				push af  
4be8 3a fc 4b			ld a, (.dmark)  
4beb 32 a0 fd			ld (debug_mark),a  
4bee 3a fd 4b			ld a, (.dmark+1)  
4bf1 32 a1 fd			ld (debug_mark+1),a  
4bf4 3a fe 4b			ld a, (.dmark+2)  
4bf7 32 a2 fd			ld (debug_mark+2),a  
4bfa 18 03			jr .pastdmark  
4bfc ..			.dmark: db "N2S"  
4bff f1			.pastdmark: pop af  
4c00			endm  
# End of macro DMARK
4c00						CALLMONITOR 
4c00 cd aa fd			call debug_vector  
4c03				endm  
# End of macro CALLMONITOR
4c03					endif 
4c03			 
4c03					FORTH_DSP_VALUEHL 
4c03 cd 4d 22			call macro_dsp_valuehl 
4c06				endm 
# End of macro FORTH_DSP_VALUEHL
4c06			 
4c06					if DEBUG_FORTH_WORDS 
4c06						DMARK "NS1" 
4c06 f5				push af  
4c07 3a 1b 4c			ld a, (.dmark)  
4c0a 32 a0 fd			ld (debug_mark),a  
4c0d 3a 1c 4c			ld a, (.dmark+1)  
4c10 32 a1 fd			ld (debug_mark+1),a  
4c13 3a 1d 4c			ld a, (.dmark+2)  
4c16 32 a2 fd			ld (debug_mark+2),a  
4c19 18 03			jr .pastdmark  
4c1b ..			.dmark: db "NS1"  
4c1e f1			.pastdmark: pop af  
4c1f			endm  
# End of macro DMARK
4c1f						CALLMONITOR 
4c1f cd aa fd			call debug_vector  
4c22				endm  
# End of macro CALLMONITOR
4c22					endif 
4c22					FORTH_DSP_POP 
4c22 cd 05 23			call macro_forth_dsp_pop 
4c25				endm 
# End of macro FORTH_DSP_POP
4c25			 
4c25 eb					ex de, hl 
4c26 21 f6 f0				ld hl, scratch 
4c29					if DEBUG_FORTH_WORDS 
4c29						DMARK "NS2" 
4c29 f5				push af  
4c2a 3a 3e 4c			ld a, (.dmark)  
4c2d 32 a0 fd			ld (debug_mark),a  
4c30 3a 3f 4c			ld a, (.dmark+1)  
4c33 32 a1 fd			ld (debug_mark+1),a  
4c36 3a 40 4c			ld a, (.dmark+2)  
4c39 32 a2 fd			ld (debug_mark+2),a  
4c3c 18 03			jr .pastdmark  
4c3e ..			.dmark: db "NS2"  
4c41 f1			.pastdmark: pop af  
4c42			endm  
# End of macro DMARK
4c42						CALLMONITOR 
4c42 cd aa fd			call debug_vector  
4c45				endm  
# End of macro CALLMONITOR
4c45					endif 
4c45 cd f3 12				call uitoa_16 
4c48 21 f6 f0				ld hl, scratch 
4c4b					if DEBUG_FORTH_WORDS 
4c4b						DMARK "NS3" 
4c4b f5				push af  
4c4c 3a 60 4c			ld a, (.dmark)  
4c4f 32 a0 fd			ld (debug_mark),a  
4c52 3a 61 4c			ld a, (.dmark+1)  
4c55 32 a1 fd			ld (debug_mark+1),a  
4c58 3a 62 4c			ld a, (.dmark+2)  
4c5b 32 a2 fd			ld (debug_mark+2),a  
4c5e 18 03			jr .pastdmark  
4c60 ..			.dmark: db "NS3"  
4c63 f1			.pastdmark: pop af  
4c64			endm  
# End of macro DMARK
4c64						CALLMONITOR 
4c64 cd aa fd			call debug_vector  
4c67				endm  
# End of macro CALLMONITOR
4c67					endif 
4c67 cd b6 20				call forth_push_str 
4c6a			;		ld a, l 
4c6a			;		call DispAToASCII   
4c6a			;;TODO need to chage above call to dump into string 
4c6a			; 
4c6a			; 
4c6a			 
4c6a				       NEXTW 
4c6a c3 39 24			jp macro_next 
4c6d				endm 
# End of macro NEXTW
4c6d			 
4c6d			.CONCAT: 
4c6d				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4c6d 48				db WORD_SYS_CORE+52             
4c6e 20 4d			dw .FIND            
4c70 07				db 6 + 1 
4c71 .. 00			db "CONCAT",0              
4c78				endm 
# End of macro CWHEAD
4c78			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4c78			 
4c78			; TODO check string type 
4c78			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4c78			 
4c78					if DEBUG_FORTH_WORDS_KEY 
4c78						DMARK "CON" 
4c78 f5				push af  
4c79 3a 8d 4c			ld a, (.dmark)  
4c7c 32 a0 fd			ld (debug_mark),a  
4c7f 3a 8e 4c			ld a, (.dmark+1)  
4c82 32 a1 fd			ld (debug_mark+1),a  
4c85 3a 8f 4c			ld a, (.dmark+2)  
4c88 32 a2 fd			ld (debug_mark+2),a  
4c8b 18 03			jr .pastdmark  
4c8d ..			.dmark: db "CON"  
4c90 f1			.pastdmark: pop af  
4c91			endm  
# End of macro DMARK
4c91						CALLMONITOR 
4c91 cd aa fd			call debug_vector  
4c94				endm  
# End of macro CALLMONITOR
4c94					endif 
4c94			 
4c94			 
4c94					FORTH_DSP_VALUE 
4c94 cd 36 22			call macro_forth_dsp_value 
4c97				endm 
# End of macro FORTH_DSP_VALUE
4c97 e5					push hl   ; s2 
4c98			 
4c98					FORTH_DSP_POP 
4c98 cd 05 23			call macro_forth_dsp_pop 
4c9b				endm 
# End of macro FORTH_DSP_POP
4c9b			 
4c9b					FORTH_DSP_VALUE 
4c9b cd 36 22			call macro_forth_dsp_value 
4c9e				endm 
# End of macro FORTH_DSP_VALUE
4c9e			 
4c9e e5					push hl   ; s1 
4c9f			 
4c9f					FORTH_DSP_POP 
4c9f cd 05 23			call macro_forth_dsp_pop 
4ca2				endm 
# End of macro FORTH_DSP_POP
4ca2					 
4ca2			 
4ca2					; copy s1 
4ca2			 
4ca2				 
4ca2					; save ptr 
4ca2 e1					pop hl  
4ca3 e5					push hl 
4ca4 3e 00				ld a, 0 
4ca6 cd 4f 13				call strlent 
4ca9					;inc hl    ; zer0 
4ca9 06 00				ld b, 0 
4cab 4d					ld c, l 
4cac e1					pop hl		 
4cad 11 f6 f0				ld de, scratch	 
4cb0					if DEBUG_FORTH_WORDS 
4cb0						DMARK "CO1" 
4cb0 f5				push af  
4cb1 3a c5 4c			ld a, (.dmark)  
4cb4 32 a0 fd			ld (debug_mark),a  
4cb7 3a c6 4c			ld a, (.dmark+1)  
4cba 32 a1 fd			ld (debug_mark+1),a  
4cbd 3a c7 4c			ld a, (.dmark+2)  
4cc0 32 a2 fd			ld (debug_mark+2),a  
4cc3 18 03			jr .pastdmark  
4cc5 ..			.dmark: db "CO1"  
4cc8 f1			.pastdmark: pop af  
4cc9			endm  
# End of macro DMARK
4cc9						CALLMONITOR 
4cc9 cd aa fd			call debug_vector  
4ccc				endm  
# End of macro CALLMONITOR
4ccc					endif 
4ccc ed b0				ldir 
4cce			 
4cce e1					pop hl 
4ccf e5					push hl 
4cd0 d5					push de 
4cd1			 
4cd1			 
4cd1 3e 00				ld a, 0 
4cd3 cd 4f 13				call strlent 
4cd6 23					inc hl    ; zer0 
4cd7 23					inc hl 
4cd8 06 00				ld b, 0 
4cda 4d					ld c, l 
4cdb d1					pop de 
4cdc e1					pop hl		 
4cdd					if DEBUG_FORTH_WORDS 
4cdd						DMARK "CO2" 
4cdd f5				push af  
4cde 3a f2 4c			ld a, (.dmark)  
4ce1 32 a0 fd			ld (debug_mark),a  
4ce4 3a f3 4c			ld a, (.dmark+1)  
4ce7 32 a1 fd			ld (debug_mark+1),a  
4cea 3a f4 4c			ld a, (.dmark+2)  
4ced 32 a2 fd			ld (debug_mark+2),a  
4cf0 18 03			jr .pastdmark  
4cf2 ..			.dmark: db "CO2"  
4cf5 f1			.pastdmark: pop af  
4cf6			endm  
# End of macro DMARK
4cf6						CALLMONITOR 
4cf6 cd aa fd			call debug_vector  
4cf9				endm  
# End of macro CALLMONITOR
4cf9					endif 
4cf9 ed b0				ldir 
4cfb			 
4cfb			 
4cfb			 
4cfb 21 f6 f0				ld hl, scratch 
4cfe					if DEBUG_FORTH_WORDS 
4cfe						DMARK "CO5" 
4cfe f5				push af  
4cff 3a 13 4d			ld a, (.dmark)  
4d02 32 a0 fd			ld (debug_mark),a  
4d05 3a 14 4d			ld a, (.dmark+1)  
4d08 32 a1 fd			ld (debug_mark+1),a  
4d0b 3a 15 4d			ld a, (.dmark+2)  
4d0e 32 a2 fd			ld (debug_mark+2),a  
4d11 18 03			jr .pastdmark  
4d13 ..			.dmark: db "CO5"  
4d16 f1			.pastdmark: pop af  
4d17			endm  
# End of macro DMARK
4d17						CALLMONITOR 
4d17 cd aa fd			call debug_vector  
4d1a				endm  
# End of macro CALLMONITOR
4d1a					endif 
4d1a			 
4d1a cd b6 20				call forth_push_str 
4d1d			 
4d1d			 
4d1d			 
4d1d			 
4d1d				       NEXTW 
4d1d c3 39 24			jp macro_next 
4d20				endm 
# End of macro NEXTW
4d20			 
4d20			 
4d20			.FIND: 
4d20				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4d20 4b				db WORD_SYS_CORE+55             
4d21 de 4d			dw .LEN            
4d23 05				db 4 + 1 
4d24 .. 00			db "FIND",0              
4d29				endm 
# End of macro CWHEAD
4d29			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4d29			 
4d29					if DEBUG_FORTH_WORDS_KEY 
4d29						DMARK "FND" 
4d29 f5				push af  
4d2a 3a 3e 4d			ld a, (.dmark)  
4d2d 32 a0 fd			ld (debug_mark),a  
4d30 3a 3f 4d			ld a, (.dmark+1)  
4d33 32 a1 fd			ld (debug_mark+1),a  
4d36 3a 40 4d			ld a, (.dmark+2)  
4d39 32 a2 fd			ld (debug_mark+2),a  
4d3c 18 03			jr .pastdmark  
4d3e ..			.dmark: db "FND"  
4d41 f1			.pastdmark: pop af  
4d42			endm  
# End of macro DMARK
4d42						CALLMONITOR 
4d42 cd aa fd			call debug_vector  
4d45				endm  
# End of macro CALLMONITOR
4d45					endif 
4d45			 
4d45			; TODO check string type 
4d45					FORTH_DSP_VALUE 
4d45 cd 36 22			call macro_forth_dsp_value 
4d48				endm 
# End of macro FORTH_DSP_VALUE
4d48			 
4d48 e5					push hl    
4d49 7e					ld a,(hl)    ; char to find   
4d4a			; TODO change char to substr 
4d4a			 
4d4a f5					push af 
4d4b					 
4d4b			 
4d4b			 
4d4b					if DEBUG_FORTH_WORDS 
4d4b						DMARK "FN1" 
4d4b f5				push af  
4d4c 3a 60 4d			ld a, (.dmark)  
4d4f 32 a0 fd			ld (debug_mark),a  
4d52 3a 61 4d			ld a, (.dmark+1)  
4d55 32 a1 fd			ld (debug_mark+1),a  
4d58 3a 62 4d			ld a, (.dmark+2)  
4d5b 32 a2 fd			ld (debug_mark+2),a  
4d5e 18 03			jr .pastdmark  
4d60 ..			.dmark: db "FN1"  
4d63 f1			.pastdmark: pop af  
4d64			endm  
# End of macro DMARK
4d64						CALLMONITOR 
4d64 cd aa fd			call debug_vector  
4d67				endm  
# End of macro CALLMONITOR
4d67					endif 
4d67			 
4d67					FORTH_DSP_POP 
4d67 cd 05 23			call macro_forth_dsp_pop 
4d6a				endm 
# End of macro FORTH_DSP_POP
4d6a			 
4d6a					; string to search 
4d6a			 
4d6a					FORTH_DSP_VALUE 
4d6a cd 36 22			call macro_forth_dsp_value 
4d6d				endm 
# End of macro FORTH_DSP_VALUE
4d6d			 
4d6d d1					pop de  ; d is char to find  
4d6e			 
4d6e					if DEBUG_FORTH_WORDS 
4d6e						DMARK "FN2" 
4d6e f5				push af  
4d6f 3a 83 4d			ld a, (.dmark)  
4d72 32 a0 fd			ld (debug_mark),a  
4d75 3a 84 4d			ld a, (.dmark+1)  
4d78 32 a1 fd			ld (debug_mark+1),a  
4d7b 3a 85 4d			ld a, (.dmark+2)  
4d7e 32 a2 fd			ld (debug_mark+2),a  
4d81 18 03			jr .pastdmark  
4d83 ..			.dmark: db "FN2"  
4d86 f1			.pastdmark: pop af  
4d87			endm  
# End of macro DMARK
4d87						CALLMONITOR 
4d87 cd aa fd			call debug_vector  
4d8a				endm  
# End of macro CALLMONITOR
4d8a					endif 
4d8a					 
4d8a 01 00 00				ld bc, 0 
4d8d 7e			.findchar:      ld a,(hl) 
4d8e fe 00				cp 0   		 
4d90 28 27				jr z, .finddone     
4d92 ba					cp d 
4d93 28 20				jr z, .foundchar 
4d95 03					inc bc 
4d96 23					inc hl 
4d97					if DEBUG_FORTH_WORDS 
4d97						DMARK "FN3" 
4d97 f5				push af  
4d98 3a ac 4d			ld a, (.dmark)  
4d9b 32 a0 fd			ld (debug_mark),a  
4d9e 3a ad 4d			ld a, (.dmark+1)  
4da1 32 a1 fd			ld (debug_mark+1),a  
4da4 3a ae 4d			ld a, (.dmark+2)  
4da7 32 a2 fd			ld (debug_mark+2),a  
4daa 18 03			jr .pastdmark  
4dac ..			.dmark: db "FN3"  
4daf f1			.pastdmark: pop af  
4db0			endm  
# End of macro DMARK
4db0						CALLMONITOR 
4db0 cd aa fd			call debug_vector  
4db3				endm  
# End of macro CALLMONITOR
4db3					endif 
4db3 18 d8				jr .findchar 
4db5			 
4db5			 
4db5 c5			.foundchar:	push bc 
4db6 e1					pop hl 
4db7 18 03				jr .findexit 
4db9			 
4db9			 
4db9							 
4db9			 
4db9			.finddone:     ; got to end of string with no find 
4db9 21 00 00				ld hl, 0 
4dbc			.findexit: 
4dbc			 
4dbc					if DEBUG_FORTH_WORDS 
4dbc						DMARK "FNd" 
4dbc f5				push af  
4dbd 3a d1 4d			ld a, (.dmark)  
4dc0 32 a0 fd			ld (debug_mark),a  
4dc3 3a d2 4d			ld a, (.dmark+1)  
4dc6 32 a1 fd			ld (debug_mark+1),a  
4dc9 3a d3 4d			ld a, (.dmark+2)  
4dcc 32 a2 fd			ld (debug_mark+2),a  
4dcf 18 03			jr .pastdmark  
4dd1 ..			.dmark: db "FNd"  
4dd4 f1			.pastdmark: pop af  
4dd5			endm  
# End of macro DMARK
4dd5						CALLMONITOR 
4dd5 cd aa fd			call debug_vector  
4dd8				endm  
# End of macro CALLMONITOR
4dd8					endif 
4dd8 cd 48 20			call forth_push_numhl 
4ddb			 
4ddb				       NEXTW 
4ddb c3 39 24			jp macro_next 
4dde				endm 
# End of macro NEXTW
4dde			 
4dde			.LEN: 
4dde				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4dde 4c				db WORD_SYS_CORE+56             
4ddf 48 4e			dw .ASC            
4de1 06				db 5 + 1 
4de2 .. 00			db "COUNT",0              
4de8				endm 
# End of macro CWHEAD
4de8			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4de8			 
4de8					if DEBUG_FORTH_WORDS_KEY 
4de8						DMARK "CNT" 
4de8 f5				push af  
4de9 3a fd 4d			ld a, (.dmark)  
4dec 32 a0 fd			ld (debug_mark),a  
4def 3a fe 4d			ld a, (.dmark+1)  
4df2 32 a1 fd			ld (debug_mark+1),a  
4df5 3a ff 4d			ld a, (.dmark+2)  
4df8 32 a2 fd			ld (debug_mark+2),a  
4dfb 18 03			jr .pastdmark  
4dfd ..			.dmark: db "CNT"  
4e00 f1			.pastdmark: pop af  
4e01			endm  
# End of macro DMARK
4e01						CALLMONITOR 
4e01 cd aa fd			call debug_vector  
4e04				endm  
# End of macro CALLMONITOR
4e04					endif 
4e04			; TODO check string type 
4e04					FORTH_DSP_VALUE 
4e04 cd 36 22			call macro_forth_dsp_value 
4e07				endm 
# End of macro FORTH_DSP_VALUE
4e07			 
4e07			 
4e07					if DEBUG_FORTH_WORDS 
4e07						DMARK "CN?" 
4e07 f5				push af  
4e08 3a 1c 4e			ld a, (.dmark)  
4e0b 32 a0 fd			ld (debug_mark),a  
4e0e 3a 1d 4e			ld a, (.dmark+1)  
4e11 32 a1 fd			ld (debug_mark+1),a  
4e14 3a 1e 4e			ld a, (.dmark+2)  
4e17 32 a2 fd			ld (debug_mark+2),a  
4e1a 18 03			jr .pastdmark  
4e1c ..			.dmark: db "CN?"  
4e1f f1			.pastdmark: pop af  
4e20			endm  
# End of macro DMARK
4e20						CALLMONITOR 
4e20 cd aa fd			call debug_vector  
4e23				endm  
# End of macro CALLMONITOR
4e23					endif 
4e23 cd 44 13				call strlenz 
4e26					if DEBUG_FORTH_WORDS 
4e26						DMARK "CNl" 
4e26 f5				push af  
4e27 3a 3b 4e			ld a, (.dmark)  
4e2a 32 a0 fd			ld (debug_mark),a  
4e2d 3a 3c 4e			ld a, (.dmark+1)  
4e30 32 a1 fd			ld (debug_mark+1),a  
4e33 3a 3d 4e			ld a, (.dmark+2)  
4e36 32 a2 fd			ld (debug_mark+2),a  
4e39 18 03			jr .pastdmark  
4e3b ..			.dmark: db "CNl"  
4e3e f1			.pastdmark: pop af  
4e3f			endm  
# End of macro DMARK
4e3f						CALLMONITOR 
4e3f cd aa fd			call debug_vector  
4e42				endm  
# End of macro CALLMONITOR
4e42					endif 
4e42			 
4e42 cd 48 20				call forth_push_numhl 
4e45			 
4e45			 
4e45			 
4e45				       NEXTW 
4e45 c3 39 24			jp macro_next 
4e48				endm 
# End of macro NEXTW
4e48			.ASC: 
4e48				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4e48 4d				db WORD_SYS_CORE+57             
4e49 b6 4e			dw .CHR            
4e4b 04				db 3 + 1 
4e4c .. 00			db "ASC",0              
4e50				endm 
# End of macro CWHEAD
4e50			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4e50					if DEBUG_FORTH_WORDS_KEY 
4e50						DMARK "ASC" 
4e50 f5				push af  
4e51 3a 65 4e			ld a, (.dmark)  
4e54 32 a0 fd			ld (debug_mark),a  
4e57 3a 66 4e			ld a, (.dmark+1)  
4e5a 32 a1 fd			ld (debug_mark+1),a  
4e5d 3a 67 4e			ld a, (.dmark+2)  
4e60 32 a2 fd			ld (debug_mark+2),a  
4e63 18 03			jr .pastdmark  
4e65 ..			.dmark: db "ASC"  
4e68 f1			.pastdmark: pop af  
4e69			endm  
# End of macro DMARK
4e69						CALLMONITOR 
4e69 cd aa fd			call debug_vector  
4e6c				endm  
# End of macro CALLMONITOR
4e6c					endif 
4e6c					FORTH_DSP_VALUE 
4e6c cd 36 22			call macro_forth_dsp_value 
4e6f				endm 
# End of macro FORTH_DSP_VALUE
4e6f					;v5 FORTH_DSP_VALUE 
4e6f			;		inc hl      ; now at start of numeric as string 
4e6f			 
4e6f e5					push hl 
4e70			 
4e70					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e70 cd 05 23			call macro_forth_dsp_pop 
4e73				endm 
# End of macro FORTH_DSP_POP
4e73			 
4e73 e1					pop hl 
4e74			 
4e74					if DEBUG_FORTH_WORDS 
4e74						DMARK "AS1" 
4e74 f5				push af  
4e75 3a 89 4e			ld a, (.dmark)  
4e78 32 a0 fd			ld (debug_mark),a  
4e7b 3a 8a 4e			ld a, (.dmark+1)  
4e7e 32 a1 fd			ld (debug_mark+1),a  
4e81 3a 8b 4e			ld a, (.dmark+2)  
4e84 32 a2 fd			ld (debug_mark+2),a  
4e87 18 03			jr .pastdmark  
4e89 ..			.dmark: db "AS1"  
4e8c f1			.pastdmark: pop af  
4e8d			endm  
# End of macro DMARK
4e8d						CALLMONITOR 
4e8d cd aa fd			call debug_vector  
4e90				endm  
# End of macro CALLMONITOR
4e90					endif 
4e90					; push the content of a onto the stack as a value 
4e90			 
4e90 7e					ld a,(hl)   ; get char 
4e91 26 00				ld h,0 
4e93 6f					ld l,a 
4e94					if DEBUG_FORTH_WORDS 
4e94						DMARK "AS2" 
4e94 f5				push af  
4e95 3a a9 4e			ld a, (.dmark)  
4e98 32 a0 fd			ld (debug_mark),a  
4e9b 3a aa 4e			ld a, (.dmark+1)  
4e9e 32 a1 fd			ld (debug_mark+1),a  
4ea1 3a ab 4e			ld a, (.dmark+2)  
4ea4 32 a2 fd			ld (debug_mark+2),a  
4ea7 18 03			jr .pastdmark  
4ea9 ..			.dmark: db "AS2"  
4eac f1			.pastdmark: pop af  
4ead			endm  
# End of macro DMARK
4ead						CALLMONITOR 
4ead cd aa fd			call debug_vector  
4eb0				endm  
# End of macro CALLMONITOR
4eb0					endif 
4eb0 cd 48 20				call forth_push_numhl 
4eb3			 
4eb3				       NEXTW 
4eb3 c3 39 24			jp macro_next 
4eb6				endm 
# End of macro NEXTW
4eb6			 
4eb6			.CHR: 
4eb6				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4eb6 4d				db WORD_SYS_CORE+57             
4eb7 f2 4e			dw .ENDSTR            
4eb9 04				db 3 + 1 
4eba .. 00			db "CHR",0              
4ebe				endm 
# End of macro CWHEAD
4ebe			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4ebe					if DEBUG_FORTH_WORDS_KEY 
4ebe						DMARK "CHR" 
4ebe f5				push af  
4ebf 3a d3 4e			ld a, (.dmark)  
4ec2 32 a0 fd			ld (debug_mark),a  
4ec5 3a d4 4e			ld a, (.dmark+1)  
4ec8 32 a1 fd			ld (debug_mark+1),a  
4ecb 3a d5 4e			ld a, (.dmark+2)  
4ece 32 a2 fd			ld (debug_mark+2),a  
4ed1 18 03			jr .pastdmark  
4ed3 ..			.dmark: db "CHR"  
4ed6 f1			.pastdmark: pop af  
4ed7			endm  
# End of macro DMARK
4ed7						CALLMONITOR 
4ed7 cd aa fd			call debug_vector  
4eda				endm  
# End of macro CALLMONITOR
4eda					endif 
4eda					FORTH_DSP_VALUEHL 
4eda cd 4d 22			call macro_dsp_valuehl 
4edd				endm 
# End of macro FORTH_DSP_VALUEHL
4edd			 
4edd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4edd cd 05 23			call macro_forth_dsp_pop 
4ee0				endm 
# End of macro FORTH_DSP_POP
4ee0			 
4ee0					; save asci byte as a zero term string and push string 
4ee0			 
4ee0 7d					ld a,l 
4ee1 32 f6 f0				ld (scratch), a 
4ee4			 
4ee4 3e 00				ld a, 0 
4ee6 32 f7 f0				ld (scratch+1), a 
4ee9			 
4ee9 21 f6 f0				ld hl, scratch 
4eec cd b6 20				call forth_push_str 
4eef			 
4eef			 
4eef				       NEXTW 
4eef c3 39 24			jp macro_next 
4ef2				endm 
# End of macro NEXTW
4ef2			 
4ef2			 
4ef2			 
4ef2			 
4ef2			.ENDSTR: 
4ef2			; eof 
4ef2			 
# End of file forth_words_str.asm
4ef2			include "forth_words_key.asm" 
4ef2			 
4ef2			; | ## Keyboard Words 
4ef2			 
4ef2			.KEY: 
4ef2				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
4ef2 3e				db WORD_SYS_CORE+42             
4ef3 22 4f			dw .KEYDB            
4ef5 04				db 3 + 1 
4ef6 .. 00			db "KEY",0              
4efa				endm 
# End of macro CWHEAD
4efa			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
4efa			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4efa			; | | Can use something like this to process: 
4efa			; | | > repeat active . key ?dup if emit then #1 until  
4efa			 
4efa					if DEBUG_FORTH_WORDS_KEY 
4efa						DMARK "KEY" 
4efa f5				push af  
4efb 3a 0f 4f			ld a, (.dmark)  
4efe 32 a0 fd			ld (debug_mark),a  
4f01 3a 10 4f			ld a, (.dmark+1)  
4f04 32 a1 fd			ld (debug_mark+1),a  
4f07 3a 11 4f			ld a, (.dmark+2)  
4f0a 32 a2 fd			ld (debug_mark+2),a  
4f0d 18 03			jr .pastdmark  
4f0f ..			.dmark: db "KEY"  
4f12 f1			.pastdmark: pop af  
4f13			endm  
# End of macro DMARK
4f13						CALLMONITOR 
4f13 cd aa fd			call debug_vector  
4f16				endm  
# End of macro CALLMONITOR
4f16					endif 
4f16			; TODO currently waits 
4f16 cd 10 76				call cinndb 
4f19					;call cin_wait 
4f19 6f					ld l, a 
4f1a 26 00				ld h, 0 
4f1c cd 48 20				call forth_push_numhl 
4f1f					NEXTW 
4f1f c3 39 24			jp macro_next 
4f22				endm 
# End of macro NEXTW
4f22			.KEYDB: 
4f22				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
4f22 3e				db WORD_SYS_CORE+42             
4f23 54 4f			dw .WAITK            
4f25 06				db 5 + 1 
4f26 .. 00			db "KEYDB",0              
4f2c				endm 
# End of macro CWHEAD
4f2c			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
4f2c			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4f2c			; | | Can use something like this to process: 
4f2c			; | | > repeat active . key ?dup if emit then #1 until  
4f2c			 
4f2c					if DEBUG_FORTH_WORDS_KEY 
4f2c						DMARK "KEB" 
4f2c f5				push af  
4f2d 3a 41 4f			ld a, (.dmark)  
4f30 32 a0 fd			ld (debug_mark),a  
4f33 3a 42 4f			ld a, (.dmark+1)  
4f36 32 a1 fd			ld (debug_mark+1),a  
4f39 3a 43 4f			ld a, (.dmark+2)  
4f3c 32 a2 fd			ld (debug_mark+2),a  
4f3f 18 03			jr .pastdmark  
4f41 ..			.dmark: db "KEB"  
4f44 f1			.pastdmark: pop af  
4f45			endm  
# End of macro DMARK
4f45						CALLMONITOR 
4f45 cd aa fd			call debug_vector  
4f48				endm  
# End of macro CALLMONITOR
4f48					endif 
4f48			; TODO currently waits 
4f48 cd fc 75				call cin 
4f4b					;call cin_wait 
4f4b 6f					ld l, a 
4f4c 26 00				ld h, 0 
4f4e cd 48 20				call forth_push_numhl 
4f51					NEXTW 
4f51 c3 39 24			jp macro_next 
4f54				endm 
# End of macro NEXTW
4f54			.WAITK: 
4f54				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4f54 3f				db WORD_SYS_CORE+43             
4f55 86 4f			dw .ACCEPT            
4f57 06				db 5 + 1 
4f58 .. 00			db "WAITK",0              
4f5e				endm 
# End of macro CWHEAD
4f5e			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4f5e					if DEBUG_FORTH_WORDS_KEY 
4f5e						DMARK "WAI" 
4f5e f5				push af  
4f5f 3a 73 4f			ld a, (.dmark)  
4f62 32 a0 fd			ld (debug_mark),a  
4f65 3a 74 4f			ld a, (.dmark+1)  
4f68 32 a1 fd			ld (debug_mark+1),a  
4f6b 3a 75 4f			ld a, (.dmark+2)  
4f6e 32 a2 fd			ld (debug_mark+2),a  
4f71 18 03			jr .pastdmark  
4f73 ..			.dmark: db "WAI"  
4f76 f1			.pastdmark: pop af  
4f77			endm  
# End of macro DMARK
4f77						CALLMONITOR 
4f77 cd aa fd			call debug_vector  
4f7a				endm  
# End of macro CALLMONITOR
4f7a					endif 
4f7a cd eb 75				call cin_wait 
4f7d 6f					ld l, a 
4f7e 26 00				ld h, 0 
4f80 cd 48 20				call forth_push_numhl 
4f83					NEXTW 
4f83 c3 39 24			jp macro_next 
4f86				endm 
# End of macro NEXTW
4f86			.ACCEPT: 
4f86				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4f86 40				db WORD_SYS_CORE+44             
4f87 e4 4f			dw .EDIT            
4f89 07				db 6 + 1 
4f8a .. 00			db "ACCEPT",0              
4f91				endm 
# End of macro CWHEAD
4f91			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4f91					; TODO crashes on push 
4f91					if DEBUG_FORTH_WORDS_KEY 
4f91						DMARK "ACC" 
4f91 f5				push af  
4f92 3a a6 4f			ld a, (.dmark)  
4f95 32 a0 fd			ld (debug_mark),a  
4f98 3a a7 4f			ld a, (.dmark+1)  
4f9b 32 a1 fd			ld (debug_mark+1),a  
4f9e 3a a8 4f			ld a, (.dmark+2)  
4fa1 32 a2 fd			ld (debug_mark+2),a  
4fa4 18 03			jr .pastdmark  
4fa6 ..			.dmark: db "ACC"  
4fa9 f1			.pastdmark: pop af  
4faa			endm  
# End of macro DMARK
4faa						CALLMONITOR 
4faa cd aa fd			call debug_vector  
4fad				endm  
# End of macro CALLMONITOR
4fad					endif 
4fad 21 f4 f2				ld hl, os_input 
4fb0 3e 00				ld a, 0 
4fb2 77					ld (hl),a 
4fb3 3a 93 f9				ld a,(f_cursor_ptr) 
4fb6 16 64				ld d, 100 
4fb8 0e 00				ld c, 0 
4fba 1e 28				ld e, 40 
4fbc cd 0b 10				call input_str 
4fbf					; TODO perhaps do a type check and wrap in quotes if not a number 
4fbf 21 f4 f2				ld hl, os_input 
4fc2					if DEBUG_FORTH_WORDS 
4fc2						DMARK "AC1" 
4fc2 f5				push af  
4fc3 3a d7 4f			ld a, (.dmark)  
4fc6 32 a0 fd			ld (debug_mark),a  
4fc9 3a d8 4f			ld a, (.dmark+1)  
4fcc 32 a1 fd			ld (debug_mark+1),a  
4fcf 3a d9 4f			ld a, (.dmark+2)  
4fd2 32 a2 fd			ld (debug_mark+2),a  
4fd5 18 03			jr .pastdmark  
4fd7 ..			.dmark: db "AC1"  
4fda f1			.pastdmark: pop af  
4fdb			endm  
# End of macro DMARK
4fdb						CALLMONITOR 
4fdb cd aa fd			call debug_vector  
4fde				endm  
# End of macro CALLMONITOR
4fde					endif 
4fde cd b6 20				call forth_push_str 
4fe1					NEXTW 
4fe1 c3 39 24			jp macro_next 
4fe4				endm 
# End of macro NEXTW
4fe4			 
4fe4			.EDIT: 
4fe4				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4fe4 40				db WORD_SYS_CORE+44             
4fe5 86 50			dw .DEDIT            
4fe7 05				db 4 + 1 
4fe8 .. 00			db "EDIT",0              
4fed				endm 
# End of macro CWHEAD
4fed			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4fed			 
4fed					; TODO does not copy from stack 
4fed					if DEBUG_FORTH_WORDS_KEY 
4fed						DMARK "EDT" 
4fed f5				push af  
4fee 3a 02 50			ld a, (.dmark)  
4ff1 32 a0 fd			ld (debug_mark),a  
4ff4 3a 03 50			ld a, (.dmark+1)  
4ff7 32 a1 fd			ld (debug_mark+1),a  
4ffa 3a 04 50			ld a, (.dmark+2)  
4ffd 32 a2 fd			ld (debug_mark+2),a  
5000 18 03			jr .pastdmark  
5002 ..			.dmark: db "EDT"  
5005 f1			.pastdmark: pop af  
5006			endm  
# End of macro DMARK
5006						CALLMONITOR 
5006 cd aa fd			call debug_vector  
5009				endm  
# End of macro CALLMONITOR
5009					endif 
5009			 
5009					;FORTH_DSP 
5009					FORTH_DSP_VALUEHL 
5009 cd 4d 22			call macro_dsp_valuehl 
500c				endm 
# End of macro FORTH_DSP_VALUEHL
500c			;		inc hl    ; TODO do type check 
500c			 
500c			;		call get_word_hl 
500c e5					push hl 
500d					if DEBUG_FORTH_WORDS 
500d						DMARK "EDp" 
500d f5				push af  
500e 3a 22 50			ld a, (.dmark)  
5011 32 a0 fd			ld (debug_mark),a  
5014 3a 23 50			ld a, (.dmark+1)  
5017 32 a1 fd			ld (debug_mark+1),a  
501a 3a 24 50			ld a, (.dmark+2)  
501d 32 a2 fd			ld (debug_mark+2),a  
5020 18 03			jr .pastdmark  
5022 ..			.dmark: db "EDp"  
5025 f1			.pastdmark: pop af  
5026			endm  
# End of macro DMARK
5026						CALLMONITOR 
5026 cd aa fd			call debug_vector  
5029				endm  
# End of macro CALLMONITOR
5029					endif 
5029				;	ld a, 0 
5029 cd 44 13				call strlenz 
502c 23					inc hl 
502d			 
502d 06 00				ld b, 0 
502f 4d					ld c, l 
5030			 
5030 e1					pop hl 
5031 11 f4 f2				ld de, os_input 
5034					if DEBUG_FORTH_WORDS_KEY 
5034						DMARK "EDc" 
5034 f5				push af  
5035 3a 49 50			ld a, (.dmark)  
5038 32 a0 fd			ld (debug_mark),a  
503b 3a 4a 50			ld a, (.dmark+1)  
503e 32 a1 fd			ld (debug_mark+1),a  
5041 3a 4b 50			ld a, (.dmark+2)  
5044 32 a2 fd			ld (debug_mark+2),a  
5047 18 03			jr .pastdmark  
5049 ..			.dmark: db "EDc"  
504c f1			.pastdmark: pop af  
504d			endm  
# End of macro DMARK
504d						CALLMONITOR 
504d cd aa fd			call debug_vector  
5050				endm  
# End of macro CALLMONITOR
5050					endif 
5050 ed b0				ldir 
5052			 
5052			 
5052 21 f4 f2				ld hl, os_input 
5055					;ld a, 0 
5055					;ld (hl),a 
5055 3a 93 f9				ld a,(f_cursor_ptr) 
5058 16 64				ld d, 100 
505a 0e 00				ld c, 0 
505c 1e 28				ld e, 40 
505e cd 0b 10				call input_str 
5061					; TODO perhaps do a type check and wrap in quotes if not a number 
5061 21 f4 f2				ld hl, os_input 
5064					if DEBUG_FORTH_WORDS 
5064						DMARK "ED1" 
5064 f5				push af  
5065 3a 79 50			ld a, (.dmark)  
5068 32 a0 fd			ld (debug_mark),a  
506b 3a 7a 50			ld a, (.dmark+1)  
506e 32 a1 fd			ld (debug_mark+1),a  
5071 3a 7b 50			ld a, (.dmark+2)  
5074 32 a2 fd			ld (debug_mark+2),a  
5077 18 03			jr .pastdmark  
5079 ..			.dmark: db "ED1"  
507c f1			.pastdmark: pop af  
507d			endm  
# End of macro DMARK
507d						CALLMONITOR 
507d cd aa fd			call debug_vector  
5080				endm  
# End of macro CALLMONITOR
5080					endif 
5080 cd b6 20				call forth_push_str 
5083					NEXTW 
5083 c3 39 24			jp macro_next 
5086				endm 
# End of macro NEXTW
5086			 
5086			.DEDIT: 
5086				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
5086 40				db WORD_SYS_CORE+44             
5087 e8 50			dw .ENDKEY            
5089 06				db 5 + 1 
508a .. 00			db "DEDIT",0              
5090				endm 
# End of macro CWHEAD
5090			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
5090			 
5090					; TODO does not copy from stack 
5090					if DEBUG_FORTH_WORDS_KEY 
5090						DMARK "DED" 
5090 f5				push af  
5091 3a a5 50			ld a, (.dmark)  
5094 32 a0 fd			ld (debug_mark),a  
5097 3a a6 50			ld a, (.dmark+1)  
509a 32 a1 fd			ld (debug_mark+1),a  
509d 3a a7 50			ld a, (.dmark+2)  
50a0 32 a2 fd			ld (debug_mark+2),a  
50a3 18 03			jr .pastdmark  
50a5 ..			.dmark: db "DED"  
50a8 f1			.pastdmark: pop af  
50a9			endm  
# End of macro DMARK
50a9						CALLMONITOR 
50a9 cd aa fd			call debug_vector  
50ac				endm  
# End of macro CALLMONITOR
50ac					endif 
50ac			 
50ac					;FORTH_DSP 
50ac					FORTH_DSP_VALUEHL 
50ac cd 4d 22			call macro_dsp_valuehl 
50af				endm 
# End of macro FORTH_DSP_VALUEHL
50af			;		inc hl    ; TODO do type check 
50af			 
50af			;		call get_word_hl 
50af e5					push hl 
50b0 e5					push hl 
50b1					FORTH_DSP_POP 
50b1 cd 05 23			call macro_forth_dsp_pop 
50b4				endm 
# End of macro FORTH_DSP_POP
50b4 e1					pop hl 
50b5					if DEBUG_FORTH_WORDS 
50b5						DMARK "EDp" 
50b5 f5				push af  
50b6 3a ca 50			ld a, (.dmark)  
50b9 32 a0 fd			ld (debug_mark),a  
50bc 3a cb 50			ld a, (.dmark+1)  
50bf 32 a1 fd			ld (debug_mark+1),a  
50c2 3a cc 50			ld a, (.dmark+2)  
50c5 32 a2 fd			ld (debug_mark+2),a  
50c8 18 03			jr .pastdmark  
50ca ..			.dmark: db "EDp"  
50cd f1			.pastdmark: pop af  
50ce			endm  
# End of macro DMARK
50ce						CALLMONITOR 
50ce cd aa fd			call debug_vector  
50d1				endm  
# End of macro CALLMONITOR
50d1					endif 
50d1				;	ld a, 0 
50d1 cd 44 13				call strlenz 
50d4 23					inc hl 
50d5			 
50d5 06 00				ld b, 0 
50d7 4d					ld c, l 
50d8			 
50d8 e1					pop hl 
50d9			 
50d9					;ld a, 0 
50d9					;ld (hl),a 
50d9 3a 93 f9				ld a,(f_cursor_ptr) 
50dc 16 64				ld d, 100 
50de 0e 00				ld c, 0 
50e0 1e 28				ld e, 40 
50e2 cd 0b 10				call input_str 
50e5					; TODO perhaps do a type check and wrap in quotes if not a number 
50e5					NEXTW 
50e5 c3 39 24			jp macro_next 
50e8				endm 
# End of macro NEXTW
50e8			 
50e8			 
50e8			.ENDKEY: 
50e8			; eof 
50e8			 
# End of file forth_words_key.asm
50e8			include "forth_words_const.asm" 
50e8			 
50e8			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
50e8			 
50e8			 
50e8			.SPITIME: 
50e8				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
50e8 77				db WORD_SYS_CORE+99             
50e9 fd 50			dw .VA            
50eb 08				db 7 + 1 
50ec .. 00			db "SPITIME",0              
50f4				endm 
# End of macro CWHEAD
50f4			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
50f4			; 
50f4			; | | If using BANK devices then leave as is. 
50f4			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
50f4			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
50f4			 
50f4 21 99 f9				ld hl, spi_clktime  
50f7 cd 48 20				call forth_push_numhl 
50fa			 
50fa					NEXTW 
50fa c3 39 24			jp macro_next 
50fd				endm 
# End of macro NEXTW
50fd			 
50fd			 
50fd			.VA: 
50fd				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
50fd 77				db WORD_SYS_CORE+99             
50fe 0d 51			dw .SYMBOL            
5100 03				db 2 + 1 
5101 .. 00			db "VA",0              
5104				endm 
# End of macro CWHEAD
5104			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
5104 21 5d f9				ld hl, cli_var_array 
5107 cd 48 20				call forth_push_numhl 
510a			 
510a					NEXTW 
510a c3 39 24			jp macro_next 
510d				endm 
# End of macro NEXTW
510d			 
510d			.SYMBOL: 
510d				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
510d 77				db WORD_SYS_CORE+99             
510e 17 52			dw .ENDCONST            
5110 07				db 6 + 1 
5111 .. 00			db "SYMBOL",0              
5118				endm 
# End of macro CWHEAD
5118			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
5118			; | 
5118			; | | The value is the number reference and the final address is pushed to stack 
5118			 
5118			; | | ``` 
5118			; | | dw sym_table 
5118			; | | dw nmi_vector 
5118			; | | dw cli_autodisplay 
5118			; | | dw cli_data_sp 
5118			; | | dw cli_data_stack 
5118			; | | dw cli_loop_sp 
5118			; | | dw cli_loop_stack 
5118			; | | dw cli_var_array 
5118			; | | dw cursor_col 
5118			; | | dw cursor_ptr 
5118			; | | ; 10 
5118			; | | dw cursor_row 
5118			; | | dw debug_mark 
5118			; | | dw display_fb0 
5118			; | | dw display_fb1 
5118			; | | dw display_fb2 
5118			; | | dw display_fb3 
5118			; | | dw display_fb_active 
5118			; | | dw execscratch 
5118			; | | dw f_cursor_ptr 
5118			; | | dw hardware_word 
5118			; | | ;20 
5118			; | | dw input_at_cursor 
5118			; | | dw input_at_pos 
5118			; | | dw input_cur_flash 
5118			; | | dw input_cur_onoff 
5118			; | | dw input_cursor 
5118			; | | dw input_display_size 
5118			; | | dw input_len 
5118			; | | dw input_ptr 
5118			; | | dw input_size 
5118			; | | dw input_start 
5118			; | | ; 30 
5118			; | | dw input_str 
5118			; | | dw input_under_cursor 
5118			; | | dw os_cli_cmd 
5118			; | | dw os_cur_ptr 
5118			; | | dw os_current_i 
5118			; | | dw os_input 
5118			; | | dw os_last_cmd 
5118			; | | dw os_last_new_uword 
5118			; | | dw debug_vector 
5118			; | | dw os_view_hl 
5118			; | | ;40 
5118			; | | dw os_word_scratch 
5118			; | | dw portbctl 
5118			; | | dw portbdata 
5118			; | | dw spi_cartdev 
5118			; | | dw spi_cartdev2 
5118			; | | dw spi_clktime 
5118			; | | dw spi_device 
5118			; | | dw spi_device_id 
5118			; | | dw spi_portbyte 
5118			; | | dw stackstore 
5118			; | | ; 50 
5118			; | | if STORAGE_SE 
5118			; | | dw storage_actl 
5118			; | | dw storage_adata 
5118			; | | else 
5118			; | | dw 0 
5118			; | | dw 0 
5118			; | | endif 
5118			; | | dw storage_append 
5118			; | | if STORAGE_SE 
5118			; | | dw storage_bctl 
5118			; | | else 
5118			; | | dw 0 
5118			; | | endif 
5118			; | | dw store_bank_active 
5118			; | | dw store_filecache 
5118			; | | dw store_longread 
5118			; | | dw store_openaddr 
5118			; | | dw store_openext 
5118			; | | dw store_openmaxext 
5118			; | | ; 60 
5118			; | | dw store_page 
5118			; | | dw store_readbuf 
5118			; | | dw store_readcont 
5118			; | | dw store_readptr 
5118			; | | dw store_tmpext 
5118			; | | dw store_tmpid 
5118			; | | dw store_tmppageid 
5118			; | | dw malloc 
5118			; | | dw free 
5118			; | | dw cin 
5118			; | | ; 70 
5118			; | | dw cin_wait 
5118			; | | dw forth_push_numhl 
5118			; | | dw forth_push_str 
5118			; | | ``` 
5118			 
5118					if DEBUG_FORTH_WORDS_KEY 
5118						DMARK "SYM" 
5118 f5				push af  
5119 3a 2d 51			ld a, (.dmark)  
511c 32 a0 fd			ld (debug_mark),a  
511f 3a 2e 51			ld a, (.dmark+1)  
5122 32 a1 fd			ld (debug_mark+1),a  
5125 3a 2f 51			ld a, (.dmark+2)  
5128 32 a2 fd			ld (debug_mark+2),a  
512b 18 03			jr .pastdmark  
512d ..			.dmark: db "SYM"  
5130 f1			.pastdmark: pop af  
5131			endm  
# End of macro DMARK
5131						CALLMONITOR 
5131 cd aa fd			call debug_vector  
5134				endm  
# End of macro CALLMONITOR
5134					endif 
5134			 
5134					FORTH_DSP_VALUEHL 
5134 cd 4d 22			call macro_dsp_valuehl 
5137				endm 
# End of macro FORTH_DSP_VALUEHL
5137			 
5137 7d					ld a, l     
5138			 
5138			 
5138					if DEBUG_FORTH_WORDS 
5138						DMARK "SY1" 
5138 f5				push af  
5139 3a 4d 51			ld a, (.dmark)  
513c 32 a0 fd			ld (debug_mark),a  
513f 3a 4e 51			ld a, (.dmark+1)  
5142 32 a1 fd			ld (debug_mark+1),a  
5145 3a 4f 51			ld a, (.dmark+2)  
5148 32 a2 fd			ld (debug_mark+2),a  
514b 18 03			jr .pastdmark  
514d ..			.dmark: db "SY1"  
5150 f1			.pastdmark: pop af  
5151			endm  
# End of macro DMARK
5151						CALLMONITOR 
5151 cd aa fd			call debug_vector  
5154				endm  
# End of macro CALLMONITOR
5154					endif 
5154					 
5154 f5					push af	 
5155					FORTH_DSP_POP 
5155 cd 05 23			call macro_forth_dsp_pop 
5158				endm 
# End of macro FORTH_DSP_POP
5158 f1					pop af 
5159			 
5159 cb 27				sla a  
515b				 
515b					 
515b					if DEBUG_FORTH_WORDS 
515b						DMARK "SY" 
515b f5				push af  
515c 3a 70 51			ld a, (.dmark)  
515f 32 a0 fd			ld (debug_mark),a  
5162 3a 71 51			ld a, (.dmark+1)  
5165 32 a1 fd			ld (debug_mark+1),a  
5168 3a 72 51			ld a, (.dmark+2)  
516b 32 a2 fd			ld (debug_mark+2),a  
516e 18 02			jr .pastdmark  
5170 ..			.dmark: db "SY"  
5172 f1			.pastdmark: pop af  
5173			endm  
# End of macro DMARK
5173						CALLMONITOR 
5173 cd aa fd			call debug_vector  
5176				endm  
# End of macro CALLMONITOR
5176					endif 
5176			 
5176 21 85 51				ld hl, sym_table 
5179 cd de 0f				call addatohl 
517c cd bb 23				call loadwordinhl 
517f cd 48 20				call forth_push_numhl 
5182			 
5182			 
5182				       NEXTW 
5182 c3 39 24			jp macro_next 
5185				endm 
# End of macro NEXTW
5185			 
5185			sym_table: 
5185			 
5185			; 0 
5185 85 51		dw sym_table 
5187 ad fd		dw nmi_vector 
5189 71 f9		dw cli_autodisplay 
518b 23 f9		dw cli_data_sp 
518d 5d f6		dw cli_data_stack 
518f 25 f9		dw cli_loop_sp 
5191 5f f8		dw cli_loop_stack 
5193 5d f9		dw cli_var_array 
5195 fa fa		dw cursor_col 
5197 f8 fa		dw cursor_ptr 
5199			; 10 
5199 f9 fa		dw cursor_row 
519b a0 fd		dw debug_mark 
519d e6 fc		dw display_fb0 
519f 45 fc		dw display_fb1 
51a1 03 fb		dw display_fb2 
51a3 a4 fb		dw display_fb3 
51a5 01 fb		dw display_fb_active 
51a7 f5 f1		dw execscratch 
51a9 93 f9		dw f_cursor_ptr 
51ab b0 fd		dw hardware_word 
51ad			;20 
51ad 97 fd		dw input_at_cursor 
51af 99 fd		dw input_at_pos 
51b1 95 fd		dw input_cur_flash 
51b3 94 fd		dw input_cur_onoff 
51b5 8a fd		dw input_cursor 
51b7 9a fd		dw input_display_size 
51b9 8f fd		dw input_len 
51bb 9e fd		dw input_ptr 
51bd 9b fd		dw input_size 
51bf 9c fd		dw input_start 
51c1			; 30 
51c1 0b 10		dw input_str 
51c3 98 fd		dw input_under_cursor 
51c5 1d f4		dw os_cli_cmd 
51c7 19 f4		dw os_cur_ptr 
51c9 1b f4		dw os_current_i 
51cb f4 f2		dw os_input 
51cd 1c f5		dw os_last_cmd 
51cf f3 f3		dw os_last_new_uword 
51d1 aa fd		dw debug_vector 
51d3 d8 f0		dw os_view_hl 
51d5			;40 
51d5 fb f3		dw os_word_scratch 
51d7 c3 00		dw portbctl 
51d9 c1 00		dw portbdata 
51db 98 f9		dw spi_cartdev 
51dd 97 f9		dw spi_cartdev2 
51df 99 f9		dw spi_clktime 
51e1 95 f9		dw spi_device 
51e3 94 f9		dw spi_device_id 
51e5 96 f9		dw spi_portbyte 
51e7 dc fa		dw stackstore 
51e9			; 50 
51e9			if STORAGE_SE 
51e9 82 00		dw storage_actl 
51eb 80 00		dw storage_adata 
51ed			else 
51ed			dw 0 
51ed			dw 0 
51ed			endif 
51ed 64 0b		dw storage_append 
51ef			if STORAGE_SE 
51ef 83 00		dw storage_bctl 
51f1			else 
51f1			dw 0 
51f1			endif 
51f1 c8 fa		dw store_bank_active 
51f3 9c f9		dw store_filecache 
51f5 aa f9		dw store_longread 
51f7 a0 f9		dw store_openaddr 
51f9 9f f9		dw store_openext 
51fb 9e f9		dw store_openmaxext 
51fd			; 60 
51fd af f9		dw store_page 
51ff ab f9		dw store_readbuf 
5201 a2 f9		dw store_readcont 
5203 ad f9		dw store_readptr 
5205 a2 f9		dw store_tmpext 
5207 a3 f9		dw store_tmpid 
5209 9a f9		dw store_tmppageid 
520b b9 13		dw malloc 
520d 83 14		dw free 
520f fc 75		dw cin 
5211			; 70 
5211 eb 75		dw cin_wait 
5213 48 20		dw forth_push_numhl 
5215 b6 20		dw forth_push_str 
5217			 
5217			 
5217			.ENDCONST: 
5217			 
5217			; eof 
5217			 
5217			 
# End of file forth_words_const.asm
5217			 
5217			if STORAGE_SE 
5217			   	include "forth_words_storage.asm" 
5217			 
5217			; | ## Fixed Storage Words 
5217			 
5217			.RENAME: 
5217			  
5217				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
5217 3a				db WORD_SYS_CORE+38             
5218 0d 53			dw .RECORD            
521a 07				db 6 + 1 
521b .. 00			db "RENAME",0              
5222				endm 
# End of macro CWHEAD
5222			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
5222			; | | > [!NOTE] 
5222			; | | > Compatible with PicoSPINet  
5222					if DEBUG_FORTH_WORDS_KEY 
5222						DMARK "REN" 
5222 f5				push af  
5223 3a 37 52			ld a, (.dmark)  
5226 32 a0 fd			ld (debug_mark),a  
5229 3a 38 52			ld a, (.dmark+1)  
522c 32 a1 fd			ld (debug_mark+1),a  
522f 3a 39 52			ld a, (.dmark+2)  
5232 32 a2 fd			ld (debug_mark+2),a  
5235 18 03			jr .pastdmark  
5237 ..			.dmark: db "REN"  
523a f1			.pastdmark: pop af  
523b			endm  
# End of macro DMARK
523b						CALLMONITOR 
523b cd aa fd			call debug_vector  
523e				endm  
# End of macro CALLMONITOR
523e					endif 
523e			 
523e			 
523e					; preserve some internal vars used by other file handing routines 
523e			 
523e 2a a0 f9				ld hl, (store_openaddr) 
5241 e5					push hl 
5242 3a a2 f9				ld a, (store_readcont) 
5245 f5					push af 
5246			 
5246					FORTH_DSP_VALUEHL 
5246 cd 4d 22			call macro_dsp_valuehl 
5249				endm 
# End of macro FORTH_DSP_VALUEHL
5249			 
5249					; move ext and id around for the file header 
5249			 
5249 65					ld h, l 
524a 2e 00				ld l, 0 
524c			 
524c e5					push hl    ; id 
524d			 
524d					FORTH_DSP_POP 
524d cd 05 23			call macro_forth_dsp_pop 
5250				endm 
# End of macro FORTH_DSP_POP
5250			 
5250					; Locate the file header 
5250			 
5250 e1					pop hl 
5251 e5					push hl 
5252 11 af f9				ld de, store_page      ; get block zero of file 
5255					if DEBUG_FORTH_WORDS 
5255						DMARK "REr" 
5255 f5				push af  
5256 3a 6a 52			ld a, (.dmark)  
5259 32 a0 fd			ld (debug_mark),a  
525c 3a 6b 52			ld a, (.dmark+1)  
525f 32 a1 fd			ld (debug_mark+1),a  
5262 3a 6c 52			ld a, (.dmark+2)  
5265 32 a2 fd			ld (debug_mark+2),a  
5268 18 03			jr .pastdmark  
526a ..			.dmark: db "REr"  
526d f1			.pastdmark: pop af  
526e			endm  
# End of macro DMARK
526e						CALLMONITOR 
526e cd aa fd			call debug_vector  
5271				endm  
# End of macro CALLMONITOR
5271					endif 
5271 cd cd 09				call storage_read 
5274			 
5274 cd 07 10			call ishlzero 
5277 20 05			jr nz, .rnfound 
5279			 
5279				; file does not exist so indicate with 255 extents in use 
5279			 
5279 3e ff			ld a, 255 
527b e1				pop hl ; clear dup hl 
527c 18 7b			jr .skiprneof 
527e			 
527e			 
527e			.rnfound: 
527e					; file found so rename 
527e			 
527e					FORTH_DSP_VALUEHL 
527e cd 4d 22			call macro_dsp_valuehl 
5281				endm 
# End of macro FORTH_DSP_VALUEHL
5281			 
5281 e5				push hl 
5282 3e 00			ld a, 0 
5284 cd 4f 13			call strlent 
5287 23				inc hl   ; cover zero term 
5288 06 00			ld b,0 
528a 4d				ld c,l 
528b e1				pop hl 
528c 11 b2 f9				ld de, store_page + 3 
528f ed b0				ldir 
5291			 
5291 11 af f9				ld de, store_page 
5294					if DEBUG_FORTH_WORDS 
5294						DMARK "RER" 
5294 f5				push af  
5295 3a a9 52			ld a, (.dmark)  
5298 32 a0 fd			ld (debug_mark),a  
529b 3a aa 52			ld a, (.dmark+1)  
529e 32 a1 fd			ld (debug_mark+1),a  
52a1 3a ab 52			ld a, (.dmark+2)  
52a4 32 a2 fd			ld (debug_mark+2),a  
52a7 18 03			jr .pastdmark  
52a9 ..			.dmark: db "RER"  
52ac f1			.pastdmark: pop af  
52ad			endm  
# End of macro DMARK
52ad						CALLMONITOR 
52ad cd aa fd			call debug_vector  
52b0				endm  
# End of macro CALLMONITOR
52b0					endif 
52b0			 
52b0 e1					pop hl    ; get orig file id and mangle it for find id 
52b1 55					ld d, l 
52b2 5c					ld e, h 
52b3			 
52b3 21 00 00				ld hl, 0 
52b6					if DEBUG_FORTH_WORDS 
52b6						DMARK "REf" 
52b6 f5				push af  
52b7 3a cb 52			ld a, (.dmark)  
52ba 32 a0 fd			ld (debug_mark),a  
52bd 3a cc 52			ld a, (.dmark+1)  
52c0 32 a1 fd			ld (debug_mark+1),a  
52c3 3a cd 52			ld a, (.dmark+2)  
52c6 32 a2 fd			ld (debug_mark+2),a  
52c9 18 03			jr .pastdmark  
52cb ..			.dmark: db "REf"  
52ce f1			.pastdmark: pop af  
52cf			endm  
# End of macro DMARK
52cf						CALLMONITOR 
52cf cd aa fd			call debug_vector  
52d2				endm  
# End of macro CALLMONITOR
52d2					endif 
52d2 cd a7 07				call storage_findnextid 
52d5 11 af f9				ld de, store_page 
52d8					if DEBUG_FORTH_WORDS 
52d8						DMARK "REw" 
52d8 f5				push af  
52d9 3a ed 52			ld a, (.dmark)  
52dc 32 a0 fd			ld (debug_mark),a  
52df 3a ee 52			ld a, (.dmark+1)  
52e2 32 a1 fd			ld (debug_mark+1),a  
52e5 3a ef 52			ld a, (.dmark+2)  
52e8 32 a2 fd			ld (debug_mark+2),a  
52eb 18 03			jr .pastdmark  
52ed ..			.dmark: db "REw"  
52f0 f1			.pastdmark: pop af  
52f1			endm  
# End of macro DMARK
52f1						CALLMONITOR 
52f1 cd aa fd			call debug_vector  
52f4				endm  
# End of macro CALLMONITOR
52f4					endif 
52f4 cd d9 04				call storage_write_block 
52f7			 
52f7 3e 00				ld a, 0 
52f9			.skiprneof: 
52f9					; drop file name 
52f9					FORTH_DSP_POP 
52f9 cd 05 23			call macro_forth_dsp_pop 
52fc				endm 
# End of macro FORTH_DSP_POP
52fc			 
52fc 6f					ld l, a 
52fd 26 00				ld h, 0 
52ff cd 48 20				call forth_push_numhl 
5302			 
5302			 
5302 f1					pop af 
5303 32 a2 f9				ld (store_readcont),a 
5306 e1					pop hl 
5307 22 a0 f9				ld (store_openaddr), hl 
530a						 
530a				NEXTW 
530a c3 39 24			jp macro_next 
530d				endm 
# End of macro NEXTW
530d			.RECORD: 
530d			  
530d				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
530d 3a				db WORD_SYS_CORE+38             
530e b1 53			dw .BREAD            
5310 07				db 6 + 1 
5311 .. 00			db "RECORD",0              
5318				endm 
# End of macro CWHEAD
5318			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
5318			; | | > [!NOTE] 
5318			; | | > Compatible with PicoSPINet  
5318			 
5318					if DEBUG_FORTH_WORDS_KEY 
5318						DMARK "REC" 
5318 f5				push af  
5319 3a 2d 53			ld a, (.dmark)  
531c 32 a0 fd			ld (debug_mark),a  
531f 3a 2e 53			ld a, (.dmark+1)  
5322 32 a1 fd			ld (debug_mark+1),a  
5325 3a 2f 53			ld a, (.dmark+2)  
5328 32 a2 fd			ld (debug_mark+2),a  
532b 18 03			jr .pastdmark  
532d ..			.dmark: db "REC"  
5330 f1			.pastdmark: pop af  
5331			endm  
# End of macro DMARK
5331						CALLMONITOR 
5331 cd aa fd			call debug_vector  
5334				endm  
# End of macro CALLMONITOR
5334					endif 
5334			 
5334					FORTH_DSP_VALUEHL 
5334 cd 4d 22			call macro_dsp_valuehl 
5337				endm 
# End of macro FORTH_DSP_VALUEHL
5337			 
5337 e5					push hl    ; id 
5338			 
5338					FORTH_DSP_POP 
5338 cd 05 23			call macro_forth_dsp_pop 
533b				endm 
# End of macro FORTH_DSP_POP
533b			 
533b					FORTH_DSP_VALUEHL 
533b cd 4d 22			call macro_dsp_valuehl 
533e				endm 
# End of macro FORTH_DSP_VALUEHL
533e			 
533e					FORTH_DSP_POP 
533e cd 05 23			call macro_forth_dsp_pop 
5341				endm 
# End of macro FORTH_DSP_POP
5341			 
5341 d1					pop de     ; get file id 
5342			 
5342					; e = file id 
5342					; l = file extent 
5342			 
5342			 
5342					; construct request to access file extent 
5342			 
5342			;		ld a, e 
5342 63					ld h, e 
5343					 
5343					 
5343					 
5343			 
5343					; e has id 
5343			 
5343 11 af f9			ld de, store_page 
5346					if DEBUG_FORTH_WORDS 
5346						DMARK "REr" 
5346 f5				push af  
5347 3a 5b 53			ld a, (.dmark)  
534a 32 a0 fd			ld (debug_mark),a  
534d 3a 5c 53			ld a, (.dmark+1)  
5350 32 a1 fd			ld (debug_mark+1),a  
5353 3a 5d 53			ld a, (.dmark+2)  
5356 32 a2 fd			ld (debug_mark+2),a  
5359 18 03			jr .pastdmark  
535b ..			.dmark: db "REr"  
535e f1			.pastdmark: pop af  
535f			endm  
# End of macro DMARK
535f						CALLMONITOR 
535f cd aa fd			call debug_vector  
5362				endm  
# End of macro CALLMONITOR
5362					endif 
5362 cd cd 09				call storage_read 
5365 cd 07 10			call ishlzero 
5368 28 22			jr z, .recnotfound 
536a			 
536a			 
536a					if DEBUG_FORTH_WORDS 
536a						DMARK "REe" 
536a f5				push af  
536b 3a 7f 53			ld a, (.dmark)  
536e 32 a0 fd			ld (debug_mark),a  
5371 3a 80 53			ld a, (.dmark+1)  
5374 32 a1 fd			ld (debug_mark+1),a  
5377 3a 81 53			ld a, (.dmark+2)  
537a 32 a2 fd			ld (debug_mark+2),a  
537d 18 03			jr .pastdmark  
537f ..			.dmark: db "REe"  
5382 f1			.pastdmark: pop af  
5383			endm  
# End of macro DMARK
5383						CALLMONITOR 
5383 cd aa fd			call debug_vector  
5386				endm  
# End of macro CALLMONITOR
5386					endif 
5386 cd b6 20			call forth_push_str 
5389			 
5389					NEXTW 
5389 c3 39 24			jp macro_next 
538c				endm 
# End of macro NEXTW
538c			 
538c			.recnotfound: 
538c					if DEBUG_FORTH_WORDS 
538c						DMARK "REf" 
538c f5				push af  
538d 3a a1 53			ld a, (.dmark)  
5390 32 a0 fd			ld (debug_mark),a  
5393 3a a2 53			ld a, (.dmark+1)  
5396 32 a1 fd			ld (debug_mark+1),a  
5399 3a a3 53			ld a, (.dmark+2)  
539c 32 a2 fd			ld (debug_mark+2),a  
539f 18 03			jr .pastdmark  
53a1 ..			.dmark: db "REf"  
53a4 f1			.pastdmark: pop af  
53a5			endm  
# End of macro DMARK
53a5						CALLMONITOR 
53a5 cd aa fd			call debug_vector  
53a8				endm  
# End of macro CALLMONITOR
53a8					endif 
53a8 21 ff 00			ld hl, 255 
53ab cd 48 20			call forth_push_numhl 
53ae				NEXTW 
53ae c3 39 24			jp macro_next 
53b1				endm 
# End of macro NEXTW
53b1			 
53b1			 
53b1			.BREAD: 
53b1			  
53b1				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
53b1 3a				db WORD_SYS_CORE+38             
53b2 34 54			dw .BWRITE            
53b4 06				db 5 + 1 
53b5 .. 00			db "BREAD",0              
53bb				endm 
# End of macro CWHEAD
53bb			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
53bb			; | | > [!NOTE] 
53bb			; | | > Compatible with PicoSPINet  
53bb				 
53bb					if DEBUG_FORTH_WORDS_KEY 
53bb						DMARK "BRD" 
53bb f5				push af  
53bc 3a d0 53			ld a, (.dmark)  
53bf 32 a0 fd			ld (debug_mark),a  
53c2 3a d1 53			ld a, (.dmark+1)  
53c5 32 a1 fd			ld (debug_mark+1),a  
53c8 3a d2 53			ld a, (.dmark+2)  
53cb 32 a2 fd			ld (debug_mark+2),a  
53ce 18 03			jr .pastdmark  
53d0 ..			.dmark: db "BRD"  
53d3 f1			.pastdmark: pop af  
53d4			endm  
# End of macro DMARK
53d4						CALLMONITOR 
53d4 cd aa fd			call debug_vector  
53d7				endm  
# End of macro CALLMONITOR
53d7					endif 
53d7			 
53d7				FORTH_DSP_VALUEHL 
53d7 cd 4d 22			call macro_dsp_valuehl 
53da				endm 
# End of macro FORTH_DSP_VALUEHL
53da			 
53da				FORTH_DSP_POP 
53da cd 05 23			call macro_forth_dsp_pop 
53dd				endm 
# End of macro FORTH_DSP_POP
53dd			 
53dd				; calc block address 
53dd			 
53dd eb				ex de, hl 
53de 3e 40			ld a, STORE_BLOCK_PHY 
53e0 cd 61 0f			call Mult16 
53e3			 
53e3			 
53e3 11 af f9			ld de, store_page 
53e6			 
53e6					if DEBUG_FORTH_WORDS 
53e6						DMARK "BR1" 
53e6 f5				push af  
53e7 3a fb 53			ld a, (.dmark)  
53ea 32 a0 fd			ld (debug_mark),a  
53ed 3a fc 53			ld a, (.dmark+1)  
53f0 32 a1 fd			ld (debug_mark+1),a  
53f3 3a fd 53			ld a, (.dmark+2)  
53f6 32 a2 fd			ld (debug_mark+2),a  
53f9 18 03			jr .pastdmark  
53fb ..			.dmark: db "BR1"  
53fe f1			.pastdmark: pop af  
53ff			endm  
# End of macro DMARK
53ff						CALLMONITOR 
53ff cd aa fd			call debug_vector  
5402				endm  
# End of macro CALLMONITOR
5402					endif 
5402			 
5402 cd 74 04			call storage_read_block 
5405			 
5405 cd 07 10			call ishlzero 
5408 20 05			jr nz, .brfound 
540a			 
540a cd 48 20			call forth_push_numhl 
540d 18 22			jr .brdone 
540f			 
540f			 
540f			.brfound: 
540f 21 b1 f9		        ld hl, store_page+2 
5412			 
5412					if DEBUG_FORTH_WORDS 
5412						DMARK "BR2" 
5412 f5				push af  
5413 3a 27 54			ld a, (.dmark)  
5416 32 a0 fd			ld (debug_mark),a  
5419 3a 28 54			ld a, (.dmark+1)  
541c 32 a1 fd			ld (debug_mark+1),a  
541f 3a 29 54			ld a, (.dmark+2)  
5422 32 a2 fd			ld (debug_mark+2),a  
5425 18 03			jr .pastdmark  
5427 ..			.dmark: db "BR2"  
542a f1			.pastdmark: pop af  
542b			endm  
# End of macro DMARK
542b						CALLMONITOR 
542b cd aa fd			call debug_vector  
542e				endm  
# End of macro CALLMONITOR
542e					endif 
542e			 
542e cd b6 20			call forth_push_str 
5431			 
5431			 
5431			.brdone: 
5431			 
5431					NEXTW 
5431 c3 39 24			jp macro_next 
5434				endm 
# End of macro NEXTW
5434			.BWRITE: 
5434				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
5434 3a				db WORD_SYS_CORE+38             
5435 c9 54			dw .BUPD            
5437 07				db 6 + 1 
5438 .. 00			db "BWRITE",0              
543f				endm 
# End of macro CWHEAD
543f			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
543f			; | | > [!NOTE] 
543f			; | | > Compatible with PicoSPINet  
543f			 
543f					if DEBUG_FORTH_WORDS_KEY 
543f						DMARK "BWR" 
543f f5				push af  
5440 3a 54 54			ld a, (.dmark)  
5443 32 a0 fd			ld (debug_mark),a  
5446 3a 55 54			ld a, (.dmark+1)  
5449 32 a1 fd			ld (debug_mark+1),a  
544c 3a 56 54			ld a, (.dmark+2)  
544f 32 a2 fd			ld (debug_mark+2),a  
5452 18 03			jr .pastdmark  
5454 ..			.dmark: db "BWR"  
5457 f1			.pastdmark: pop af  
5458			endm  
# End of macro DMARK
5458						CALLMONITOR 
5458 cd aa fd			call debug_vector  
545b				endm  
# End of macro CALLMONITOR
545b					endif 
545b			 
545b				FORTH_DSP_VALUEHL 
545b cd 4d 22			call macro_dsp_valuehl 
545e				endm 
# End of macro FORTH_DSP_VALUEHL
545e			 
545e				; calc block address 
545e			 
545e eb				ex de, hl 
545f 3e 40			ld a, STORE_BLOCK_PHY 
5461 cd 61 0f			call Mult16 
5464			 
5464 e5				push hl         ; address 
5465			 
5465				FORTH_DSP_POP 
5465 cd 05 23			call macro_forth_dsp_pop 
5468				endm 
# End of macro FORTH_DSP_POP
5468			 
5468				FORTH_DSP_VALUEHL 
5468 cd 4d 22			call macro_dsp_valuehl 
546b				endm 
# End of macro FORTH_DSP_VALUEHL
546b			 
546b				FORTH_DSP_POP 
546b cd 05 23			call macro_forth_dsp_pop 
546e				endm 
# End of macro FORTH_DSP_POP
546e			 
546e cd b0 0c			call storage_clear_page 
5471			 
5471				; copy string to store page 
5471			 
5471 e5				push hl     ; save string address 
5472			 
5472 3e 00			ld a, 0 
5474 cd 4f 13			call strlent 
5477			 
5477 23				inc hl 
5478			 
5478 4d				ld c, l 
5479 06 00			ld b, 0 
547b			 
547b e1				pop hl 
547c 11 b1 f9			ld de, store_page + 2 
547f					if DEBUG_FORTH_WORDS 
547f						DMARK "BW1" 
547f f5				push af  
5480 3a 94 54			ld a, (.dmark)  
5483 32 a0 fd			ld (debug_mark),a  
5486 3a 95 54			ld a, (.dmark+1)  
5489 32 a1 fd			ld (debug_mark+1),a  
548c 3a 96 54			ld a, (.dmark+2)  
548f 32 a2 fd			ld (debug_mark+2),a  
5492 18 03			jr .pastdmark  
5494 ..			.dmark: db "BW1"  
5497 f1			.pastdmark: pop af  
5498			endm  
# End of macro DMARK
5498						CALLMONITOR 
5498 cd aa fd			call debug_vector  
549b				endm  
# End of macro CALLMONITOR
549b					endif 
549b ed b0			ldir 
549d			 
549d			 
549d				; poke the start of the block with flags to prevent high level file ops hitting the block 
549d			 
549d 21 ff ff			ld hl, $ffff 
54a0			 
54a0 22 af f9			ld (store_page), hl	 
54a3				 
54a3 e1				pop hl    ; get address 
54a4 11 af f9			ld de, store_page 
54a7			 
54a7					if DEBUG_FORTH_WORDS 
54a7						DMARK "BW2" 
54a7 f5				push af  
54a8 3a bc 54			ld a, (.dmark)  
54ab 32 a0 fd			ld (debug_mark),a  
54ae 3a bd 54			ld a, (.dmark+1)  
54b1 32 a1 fd			ld (debug_mark+1),a  
54b4 3a be 54			ld a, (.dmark+2)  
54b7 32 a2 fd			ld (debug_mark+2),a  
54ba 18 03			jr .pastdmark  
54bc ..			.dmark: db "BW2"  
54bf f1			.pastdmark: pop af  
54c0			endm  
# End of macro DMARK
54c0						CALLMONITOR 
54c0 cd aa fd			call debug_vector  
54c3				endm  
# End of macro CALLMONITOR
54c3					endif 
54c3			 
54c3 cd d9 04			call storage_write_block 
54c6			 
54c6					NEXTW 
54c6 c3 39 24			jp macro_next 
54c9				endm 
# End of macro NEXTW
54c9			 
54c9			.BUPD: 
54c9				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
54c9 3a				db WORD_SYS_CORE+38             
54ca 1f 55			dw .BYID            
54cc 05				db 4 + 1 
54cd .. 00			db "BUPD",0              
54d2				endm 
# End of macro CWHEAD
54d2			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
54d2			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
54d2			; | | or completely different file system structure. 
54d2			; | | > [!NOTE] 
54d2			; | | > Compatible with PicoSPINet  
54d2			 
54d2					if DEBUG_FORTH_WORDS_KEY 
54d2						DMARK "BUD" 
54d2 f5				push af  
54d3 3a e7 54			ld a, (.dmark)  
54d6 32 a0 fd			ld (debug_mark),a  
54d9 3a e8 54			ld a, (.dmark+1)  
54dc 32 a1 fd			ld (debug_mark+1),a  
54df 3a e9 54			ld a, (.dmark+2)  
54e2 32 a2 fd			ld (debug_mark+2),a  
54e5 18 03			jr .pastdmark  
54e7 ..			.dmark: db "BUD"  
54ea f1			.pastdmark: pop af  
54eb			endm  
# End of macro DMARK
54eb						CALLMONITOR 
54eb cd aa fd			call debug_vector  
54ee				endm  
# End of macro CALLMONITOR
54ee					endif 
54ee			 
54ee				FORTH_DSP_VALUEHL 
54ee cd 4d 22			call macro_dsp_valuehl 
54f1				endm 
# End of macro FORTH_DSP_VALUEHL
54f1			 
54f1				; calc block address 
54f1			 
54f1 eb				ex de, hl 
54f2 3e 40			ld a, STORE_BLOCK_PHY 
54f4 cd 61 0f			call Mult16 
54f7			 
54f7				FORTH_DSP_POP 
54f7 cd 05 23			call macro_forth_dsp_pop 
54fa				endm 
# End of macro FORTH_DSP_POP
54fa			 
54fa			 
54fa 11 af f9			ld de, store_page 
54fd			 
54fd					if DEBUG_FORTH_WORDS 
54fd						DMARK "BUe" 
54fd f5				push af  
54fe 3a 12 55			ld a, (.dmark)  
5501 32 a0 fd			ld (debug_mark),a  
5504 3a 13 55			ld a, (.dmark+1)  
5507 32 a1 fd			ld (debug_mark+1),a  
550a 3a 14 55			ld a, (.dmark+2)  
550d 32 a2 fd			ld (debug_mark+2),a  
5510 18 03			jr .pastdmark  
5512 ..			.dmark: db "BUe"  
5515 f1			.pastdmark: pop af  
5516			endm  
# End of macro DMARK
5516						CALLMONITOR 
5516 cd aa fd			call debug_vector  
5519				endm  
# End of macro CALLMONITOR
5519					endif 
5519			 
5519 cd d9 04			call storage_write_block 
551c			 
551c					NEXTW 
551c c3 39 24			jp macro_next 
551f				endm 
# End of macro NEXTW
551f			 
551f			.BYID: 
551f			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
551f			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
551f			; 
551f			;		 
551f			;		if DEBUG_FORTH_WORDS_KEY 
551f			;			DMARK "BYID" 
551f			;			CALLMONITOR 
551f			;		endif 
551f			; 
551f			;		; get direct address 
551f			; 
551f			;		FORTH_DSP_VALUEHL 
551f			; 
551f			;		FORTH_DSP_POP 
551f			; 
551f			;	; calc block address 
551f			; 
551f			;	ex de, hl 
551f			;	ld a, STORE_BLOCK_PHY 
551f			;	call Mult16 
551f			;	;	do BREAD with number as param 
551f			;	; push the file name	 
551f			;	ld de, store_page 
551f			;	call storage_read_block 
551f			 ;       ld hl, store_page+2 
551f			; 
551f			; 
551f			;		NEXTW 
551f			;.BYNAME: 
551f				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
551f 3a				db WORD_SYS_CORE+38             
5520 38 55			dw .DIR            
5522 06				db 5 + 1 
5523 .. 00			db "GETID",0              
5529				endm 
# End of macro CWHEAD
5529			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
5529			; | | > [!NOTE] 
5529			; | | > Compatible with PicoSPINet  
5529			 
5529					; get pointer to file name to seek 
5529			 
5529					FORTH_DSP_VALUEHL 
5529 cd 4d 22			call macro_dsp_valuehl 
552c				endm 
# End of macro FORTH_DSP_VALUEHL
552c			 
552c			 
552c cd 9b 03				call storage_getid  
552f			 
552f					FORTH_DSP_POP 
552f cd 05 23			call macro_forth_dsp_pop 
5532				endm 
# End of macro FORTH_DSP_POP
5532			 
5532 cd 48 20				call forth_push_numhl 
5535			 
5535					NEXTW 
5535 c3 39 24			jp macro_next 
5538				endm 
# End of macro NEXTW
5538			; 
5538			.DIR: 
5538				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
5538 3a				db WORD_SYS_CORE+38             
5539 3c 56			dw .SAVE            
553b 04				db 3 + 1 
553c .. 00			db "DIR",0              
5540				endm 
# End of macro CWHEAD
5540			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5540			; | | > [!NOTE] 
5540			; | | > Compatible with PicoSPINet  
5540			 
5540					if DEBUG_FORTH_WORDS_KEY 
5540						DMARK "DIR" 
5540 f5				push af  
5541 3a 55 55			ld a, (.dmark)  
5544 32 a0 fd			ld (debug_mark),a  
5547 3a 56 55			ld a, (.dmark+1)  
554a 32 a1 fd			ld (debug_mark+1),a  
554d 3a 57 55			ld a, (.dmark+2)  
5550 32 a2 fd			ld (debug_mark+2),a  
5553 18 03			jr .pastdmark  
5555 ..			.dmark: db "DIR"  
5558 f1			.pastdmark: pop af  
5559			endm  
# End of macro DMARK
5559						CALLMONITOR 
5559 cd aa fd			call debug_vector  
555c				endm  
# End of macro CALLMONITOR
555c					endif 
555c cd 25 05			call storage_get_block_0 
555f			 
555f 21 af f9			ld hl, store_page     ; get current id count 
5562 46				ld b, (hl) 
5563 0e 00			ld c, 0    ; count of files   
5565					if DEBUG_FORTH_WORDS 
5565						DMARK "DI1" 
5565 f5				push af  
5566 3a 7a 55			ld a, (.dmark)  
5569 32 a0 fd			ld (debug_mark),a  
556c 3a 7b 55			ld a, (.dmark+1)  
556f 32 a1 fd			ld (debug_mark+1),a  
5572 3a 7c 55			ld a, (.dmark+2)  
5575 32 a2 fd			ld (debug_mark+2),a  
5578 18 03			jr .pastdmark  
557a ..			.dmark: db "DI1"  
557d f1			.pastdmark: pop af  
557e			endm  
# End of macro DMARK
557e						CALLMONITOR 
557e cd aa fd			call debug_vector  
5581				endm  
# End of macro CALLMONITOR
5581					endif 
5581			 
5581				; check for empty drive 
5581			 
5581 3e 00			ld a, 0 
5583 b8				cp b 
5584 ca f2 55			jp z, .dirdone 
5587			 
5587				; for each of the current ids do a search for them and if found push to stack 
5587			 
5587 c5			.diritem:	push bc 
5588 21 40 00				ld hl, STORE_BLOCK_PHY 
558b 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
558d 58					ld e,b 
558e			 
558e			;		if DEBUG_FORTH_WORDS 
558e			;			DMARK "DI2" 
558e			;			CALLMONITOR 
558e			;		endif 
558e			 
558e cd a7 07				call storage_findnextid 
5591			 
5591			;		if DEBUG_FORTH_WORDS 
5591			;			DMARK "DI3" 
5591			;			CALLMONITOR 
5591			;		endif 
5591			 
5591					; if found hl will be non zero 
5591			 
5591 cd 07 10				call ishlzero 
5594			;		ld a, l 
5594			;		add h 
5594			; 
5594			;		cp 0 
5594 28 59				jr z, .dirnotfound 
5596			 
5596					; increase count 
5596			 
5596 c1					pop bc	 
5597 0c					inc c 
5598 c5					push bc 
5599					 
5599			 
5599					; get file header and push the file name 
5599			 
5599 11 af f9				ld de, store_page 
559c cd 74 04				call storage_read_block 
559f			 
559f					; push file id to stack 
559f				 
559f 3a af f9				ld a, (store_page) 
55a2 26 00				ld h, 0 
55a4 6f					ld l, a 
55a5 cd 48 20				call forth_push_numhl 
55a8			 
55a8					; push extent count to stack  
55a8				 
55a8 3a b1 f9				ld a, (store_page+2) 
55ab 26 00				ld h, 0 
55ad 6f					ld l, a 
55ae cd 48 20				call forth_push_numhl 
55b1			 
55b1					; push file name 
55b1			 
55b1 21 b2 f9				ld hl, store_page+3 
55b4					if DEBUG_FORTH_WORDS 
55b4						DMARK "DI5" 
55b4 f5				push af  
55b5 3a c9 55			ld a, (.dmark)  
55b8 32 a0 fd			ld (debug_mark),a  
55bb 3a ca 55			ld a, (.dmark+1)  
55be 32 a1 fd			ld (debug_mark+1),a  
55c1 3a cb 55			ld a, (.dmark+2)  
55c4 32 a2 fd			ld (debug_mark+2),a  
55c7 18 03			jr .pastdmark  
55c9 ..			.dmark: db "DI5"  
55cc f1			.pastdmark: pop af  
55cd			endm  
# End of macro DMARK
55cd						CALLMONITOR 
55cd cd aa fd			call debug_vector  
55d0				endm  
# End of macro CALLMONITOR
55d0					endif 
55d0 cd b6 20				call forth_push_str 
55d3					if DEBUG_FORTH_WORDS 
55d3						DMARK "DI6" 
55d3 f5				push af  
55d4 3a e8 55			ld a, (.dmark)  
55d7 32 a0 fd			ld (debug_mark),a  
55da 3a e9 55			ld a, (.dmark+1)  
55dd 32 a1 fd			ld (debug_mark+1),a  
55e0 3a ea 55			ld a, (.dmark+2)  
55e3 32 a2 fd			ld (debug_mark+2),a  
55e6 18 03			jr .pastdmark  
55e8 ..			.dmark: db "DI6"  
55eb f1			.pastdmark: pop af  
55ec			endm  
# End of macro DMARK
55ec						CALLMONITOR 
55ec cd aa fd			call debug_vector  
55ef				endm  
# End of macro CALLMONITOR
55ef					endif 
55ef			.dirnotfound: 
55ef c1					pop bc     
55f0 10 95				djnz .diritem 
55f2				 
55f2			.dirdone:	 
55f2					if DEBUG_FORTH_WORDS 
55f2						DMARK "DI7" 
55f2 f5				push af  
55f3 3a 07 56			ld a, (.dmark)  
55f6 32 a0 fd			ld (debug_mark),a  
55f9 3a 08 56			ld a, (.dmark+1)  
55fc 32 a1 fd			ld (debug_mark+1),a  
55ff 3a 09 56			ld a, (.dmark+2)  
5602 32 a2 fd			ld (debug_mark+2),a  
5605 18 03			jr .pastdmark  
5607 ..			.dmark: db "DI7"  
560a f1			.pastdmark: pop af  
560b			endm  
# End of macro DMARK
560b						CALLMONITOR 
560b cd aa fd			call debug_vector  
560e				endm  
# End of macro CALLMONITOR
560e					endif 
560e			 
560e					; push a count of the dir items found 
560e			 
560e 26 00				ld h, 0 
5610 69					ld l, c 
5611 cd 48 20				call forth_push_numhl 
5614			 
5614					; push the bank label 
5614			 
5614 cd 25 05				call storage_get_block_0 
5617			 
5617				 
5617 21 b2 f9		 		ld hl, store_page+3 
561a			 
561a					if DEBUG_FORTH_WORDS 
561a						DMARK "DI8" 
561a f5				push af  
561b 3a 2f 56			ld a, (.dmark)  
561e 32 a0 fd			ld (debug_mark),a  
5621 3a 30 56			ld a, (.dmark+1)  
5624 32 a1 fd			ld (debug_mark+1),a  
5627 3a 31 56			ld a, (.dmark+2)  
562a 32 a2 fd			ld (debug_mark+2),a  
562d 18 03			jr .pastdmark  
562f ..			.dmark: db "DI8"  
5632 f1			.pastdmark: pop af  
5633			endm  
# End of macro DMARK
5633						CALLMONITOR 
5633 cd aa fd			call debug_vector  
5636				endm  
# End of macro CALLMONITOR
5636					endif 
5636 cd b6 20				call forth_push_str 
5639			 
5639			 
5639				 
5639					NEXTW 
5639 c3 39 24			jp macro_next 
563c				endm 
# End of macro NEXTW
563c			.SAVE: 
563c			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
563c			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
563c			;		NEXTW 
563c			;.LOAD: 
563c			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
563c			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
563c			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
563c			;; > > The LOAD command can not be used in any user words or compound lines. 
563c			; 
563c			;		; store_openext use it. If zero it is EOF 
563c			; 
563c			;		; read block from current stream id 
563c			;		; if the block does not contain zero term keep reading blocks until zero found 
563c			;		; push the block to stack 
563c			;		; save the block id to stream 
563c			; 
563c			; 
563c			;		FORTH_DSP_VALUEHL 
563c			; 
563c			;;		push hl 
563c			; 
563c			;	if DEBUG_STORESE 
563c			;		DMARK "LOA" 
563c			;		CALLMONITOR 
563c			;	endif 
563c			;		FORTH_DSP_POP 
563c			; 
563c			;;		pop hl 
563c			; 
563c			;		ld h, l 
563c			;		ld l, 0 
563c			; 
563c			;		push hl     ; stack holds current file id and extent to work with 
563c			; 
563c			; 
563c			;		ld de, store_page      ; get block zero of file 
563c			;	if DEBUG_STORESE 
563c			;		DMARK "LO0" 
563c			;		CALLMONITOR 
563c			;	endif 
563c			;		call storage_read 
563c			; 
563c			;		ld a, (store_page+2)    ; max extents for this file 
563c			;		ld  (store_openmaxext),a   ; get our limit 
563c			; 
563c			;	if DEBUG_STORESE 
563c			;		DMARK "LOE" 
563c			;		CALLMONITOR 
563c			;	endif 
563c			; 
563c			;; TODO dont know why max extents are not present 
563c			;;		cp 0 
563c			;;		jp z, .loadeof     ; dont read past eof 
563c			; 
563c			;;		ld a, 1   ; start from the head of the file 
563c			; 
563c			;.loadline:	pop hl 
563c			;		inc hl 
563c			;		ld  a, (store_openmaxext)   ; get our limit 
563c			;	if DEBUG_STORESE 
563c			;		DMARK "LOx" 
563c			;		CALLMONITOR 
563c			;	endif 
563c			;		inc a 
563c			;		cp l 
563c			;		jp z, .loadeof 
563c			;		push hl    ; save current extent 
563c			; 
563c			;		ld de, store_page 
563c			; 
563c			;	if DEBUG_STORESE 
563c			;		DMARK "LO1" 
563c			;		CALLMONITOR 
563c			;	endif 
563c			;		call storage_read 
563c			; 
563c			;	if DEBUG_STORESE 
563c			;		DMARK "LO2" 
563c			;		CALLMONITOR 
563c			;	endif 
563c			;	call ishlzero 
563c			;	ld a, l 
563c			;	add h 
563c			;	cp 0 
563c			;	jr z, .loadeof 
563c			; 
563c			;	; not eof so hl should point to data to exec 
563c			; 
563c			;	; will need to add the FORTH_END_BUFFER flag 
563c			 ; 
563c			;	ld hl, store_page+2 
563c			;	ld bc, 255 
563c			;	ld a, 0 
563c			;	cpir 
563c			;	if DEBUG_STORESE 
563c			;		DMARK "LOt" 
563c			;		CALLMONITOR 
563c			;	endif 
563c			;	dec hl 
563c			;	ld a, ' ' 
563c			;	ld (hl), a 
563c			;	inc hl 
563c			;	ld (hl), a 
563c			;	inc hl 
563c			;	ld (hl), a 
563c			;	inc hl 
563c			;	ld a, FORTH_END_BUFFER 
563c			;	ld (hl), a 
563c			; 
563c			;	; TODO handle more than a single block read 
563c			; 
563c			; 
563c			;	ld hl, store_page+2 
563c			; 
563c			;	ld (os_tok_ptr), hl 
563c			; 
563c			;	if DEBUG_STORESE 
563c			;		DMARK "LO3" 
563c			;		CALLMONITOR 
563c			;	endif 
563c			; 
563c			;	call forthparse 
563c			;	call forthexec 
563c			;	call forthexec_cleanup 
563c			; 
563c			;	; go to next extent 
563c			; 
563c			;	; get next block  or mark as eof 
563c			;	jp .loadline 
563c			; 
563c			; 
563c			; 
563c			;	       NEXTW 
563c			;.loadeof:	ld a, 0 
563c			;		ld (store_openext), a 
563c			; 
563c			;	if DEBUG_STORESE 
563c			;		DMARK "LOF" 
563c			;		CALLMONITOR 
563c			;	endif 
563c			;		ret 
563c			;		;NEXTW 
563c			;.BSAVE:   
563c			; 
563c			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
563c			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
563c			;		NEXTW 
563c			;.BLOAD: 
563c			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
563c			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
563c			;		NEXTW 
563c			;;;; counter gap 
563c			 
563c			 
563c			.SEO: 
563c				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
563c 64				db WORD_SYS_CORE+80             
563d 5b 56			dw .SEI            
563f 04				db 3 + 1 
5640 .. 00			db "SEO",0              
5644				endm 
# End of macro CWHEAD
5644			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5644			 
5644					; get port 
5644			 
5644					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5644 cd 4d 22			call macro_dsp_valuehl 
5647				endm 
# End of macro FORTH_DSP_VALUEHL
5647			 
5647 e5					push hl    ; u2 - byte 
5648			 
5648					; destroy value TOS 
5648			 
5648					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5648 cd 05 23			call macro_forth_dsp_pop 
564b				endm 
# End of macro FORTH_DSP_POP
564b			 
564b					; get byte to send 
564b			 
564b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
564b cd 4d 22			call macro_dsp_valuehl 
564e				endm 
# End of macro FORTH_DSP_VALUEHL
564e			 
564e e5					push hl    ; u1 - addr 
564f			 
564f					; destroy value TOS 
564f			 
564f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
564f cd 05 23			call macro_forth_dsp_pop 
5652				endm 
# End of macro FORTH_DSP_POP
5652			 
5652					; one value on hl get other one back 
5652			 
5652 d1					pop de   ; u1 - byte 
5653			 
5653 e1					pop hl   ; u2 - addr 
5654			 
5654					; TODO Send SPI byte 
5654			 
5654			 
5654 7b					ld a, e 
5655 cd 79 02				call se_writebyte 
5658			 
5658					 
5658			 
5658					NEXTW 
5658 c3 39 24			jp macro_next 
565b				endm 
# End of macro NEXTW
565b			 
565b			.SEI: 
565b				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
565b 65				db WORD_SYS_CORE+81             
565c 75 56			dw .SFREE            
565e 04				db 3 + 1 
565f .. 00			db "SEI",0              
5663				endm 
# End of macro CWHEAD
5663			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5663			 
5663					; get port 
5663			 
5663					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5663 cd 4d 22			call macro_dsp_valuehl 
5666				endm 
# End of macro FORTH_DSP_VALUEHL
5666			 
5666			;		push hl 
5666			 
5666					; destroy value TOS 
5666			 
5666					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5666 cd 05 23			call macro_forth_dsp_pop 
5669				endm 
# End of macro FORTH_DSP_POP
5669			 
5669					; one value on hl get other one back 
5669			 
5669			;		pop hl 
5669			 
5669			 
5669					; TODO Get SPI byte 
5669			 
5669 cd 1b 03				call se_readbyte 
566c			 
566c 26 00				ld h, 0 
566e 6f					ld l, a 
566f cd 48 20				call forth_push_numhl 
5672			 
5672					NEXTW 
5672 c3 39 24			jp macro_next 
5675				endm 
# End of macro NEXTW
5675			 
5675			.SFREE: 
5675				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5675 67				db WORD_SYS_CORE+83             
5676 a4 56			dw .SIZE            
5678 06				db 5 + 1 
5679 .. 00			db "FFREE",0              
567f				endm 
# End of macro CWHEAD
567f			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
567f			; | | > [!NOTE] 
567f			; | | > Compatible with PicoSPINet  
567f					if DEBUG_FORTH_WORDS_KEY 
567f						DMARK "FFR" 
567f f5				push af  
5680 3a 94 56			ld a, (.dmark)  
5683 32 a0 fd			ld (debug_mark),a  
5686 3a 95 56			ld a, (.dmark+1)  
5689 32 a1 fd			ld (debug_mark+1),a  
568c 3a 96 56			ld a, (.dmark+2)  
568f 32 a2 fd			ld (debug_mark+2),a  
5692 18 03			jr .pastdmark  
5694 ..			.dmark: db "FFR"  
5697 f1			.pastdmark: pop af  
5698			endm  
# End of macro DMARK
5698						CALLMONITOR 
5698 cd aa fd			call debug_vector  
569b				endm  
# End of macro CALLMONITOR
569b					endif 
569b			 
569b cd 41 08				call storage_freeblocks 
569e			 
569e cd 48 20				call forth_push_numhl 
56a1			 
56a1				       NEXTW 
56a1 c3 39 24			jp macro_next 
56a4				endm 
# End of macro NEXTW
56a4			.SIZE: 
56a4				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
56a4 67				db WORD_SYS_CORE+83             
56a5 d8 56			dw .CREATE            
56a7 05				db 4 + 1 
56a8 .. 00			db "SIZE",0              
56ad				endm 
# End of macro CWHEAD
56ad			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
56ad			; | | > [!NOTE] 
56ad			; | | > Compatible with PicoSPINet  
56ad					if DEBUG_FORTH_WORDS_KEY 
56ad						DMARK "SIZ" 
56ad f5				push af  
56ae 3a c2 56			ld a, (.dmark)  
56b1 32 a0 fd			ld (debug_mark),a  
56b4 3a c3 56			ld a, (.dmark+1)  
56b7 32 a1 fd			ld (debug_mark+1),a  
56ba 3a c4 56			ld a, (.dmark+2)  
56bd 32 a2 fd			ld (debug_mark+2),a  
56c0 18 03			jr .pastdmark  
56c2 ..			.dmark: db "SIZ"  
56c5 f1			.pastdmark: pop af  
56c6			endm  
# End of macro DMARK
56c6						CALLMONITOR 
56c6 cd aa fd			call debug_vector  
56c9				endm  
# End of macro CALLMONITOR
56c9					endif 
56c9			 
56c9					FORTH_DSP_VALUEHL 
56c9 cd 4d 22			call macro_dsp_valuehl 
56cc				endm 
# End of macro FORTH_DSP_VALUEHL
56cc			;		push hl 
56cc					FORTH_DSP_POP 
56cc cd 05 23			call macro_forth_dsp_pop 
56cf				endm 
# End of macro FORTH_DSP_POP
56cf			;		pop hl 
56cf cd a3 04				call storage_file_size 
56d2			 
56d2 cd 48 20				call forth_push_numhl 
56d5			  
56d5			 
56d5				       NEXTW 
56d5 c3 39 24			jp macro_next 
56d8				endm 
# End of macro NEXTW
56d8			 
56d8			.CREATE: 
56d8				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
56d8 68				db WORD_SYS_CORE+84             
56d9 46 57			dw .APPEND            
56db 07				db 6 + 1 
56dc .. 00			db "CREATE",0              
56e3				endm 
# End of macro CWHEAD
56e3			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
56e3			; | | e.g.  
56e3			; | | TestProgram CREATE 
56e3			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
56e3			; | |  
56e3			; | | Max file IDs are 255. 
56e3			; | |  
56e3			; | | > [!NOTE] 
56e3			; | | > Compatible with PicoSPINet  
56e3					 
56e3					if DEBUG_FORTH_WORDS_KEY 
56e3						DMARK "CRT" 
56e3 f5				push af  
56e4 3a f8 56			ld a, (.dmark)  
56e7 32 a0 fd			ld (debug_mark),a  
56ea 3a f9 56			ld a, (.dmark+1)  
56ed 32 a1 fd			ld (debug_mark+1),a  
56f0 3a fa 56			ld a, (.dmark+2)  
56f3 32 a2 fd			ld (debug_mark+2),a  
56f6 18 03			jr .pastdmark  
56f8 ..			.dmark: db "CRT"  
56fb f1			.pastdmark: pop af  
56fc			endm  
# End of macro DMARK
56fc						CALLMONITOR 
56fc cd aa fd			call debug_vector  
56ff				endm  
# End of macro CALLMONITOR
56ff					endif 
56ff			;		call storage_get_block_0 
56ff			 
56ff					; TODO pop hl 
56ff			 
56ff					;v5 FORTH_DSP_VALUE 
56ff					FORTH_DSP_VALUE 
56ff cd 36 22			call macro_forth_dsp_value 
5702				endm 
# End of macro FORTH_DSP_VALUE
5702			 
5702				if DEBUG_STORESE 
5702					DMARK "CR1" 
5702 f5				push af  
5703 3a 17 57			ld a, (.dmark)  
5706 32 a0 fd			ld (debug_mark),a  
5709 3a 18 57			ld a, (.dmark+1)  
570c 32 a1 fd			ld (debug_mark+1),a  
570f 3a 19 57			ld a, (.dmark+2)  
5712 32 a2 fd			ld (debug_mark+2),a  
5715 18 03			jr .pastdmark  
5717 ..			.dmark: db "CR1"  
571a f1			.pastdmark: pop af  
571b			endm  
# End of macro DMARK
571b					CALLMONITOR 
571b cd aa fd			call debug_vector  
571e				endm  
# End of macro CALLMONITOR
571e				endif 
571e			;		push hl 
571e			;		FORTH_DSP_POP 
571e			;		pop hl 
571e			 
571e			;		inc hl   ; move past the type marker 
571e			 
571e cd 77 08				call storage_create 
5721			 
5721				if DEBUG_STORESE 
5721					DMARK "CT1" 
5721 f5				push af  
5722 3a 36 57			ld a, (.dmark)  
5725 32 a0 fd			ld (debug_mark),a  
5728 3a 37 57			ld a, (.dmark+1)  
572b 32 a1 fd			ld (debug_mark+1),a  
572e 3a 38 57			ld a, (.dmark+2)  
5731 32 a2 fd			ld (debug_mark+2),a  
5734 18 03			jr .pastdmark  
5736 ..			.dmark: db "CT1"  
5739 f1			.pastdmark: pop af  
573a			endm  
# End of macro DMARK
573a					CALLMONITOR 
573a cd aa fd			call debug_vector  
573d				endm  
# End of macro CALLMONITOR
573d				endif 
573d			;		push hl 
573d					FORTH_DSP_POP 
573d cd 05 23			call macro_forth_dsp_pop 
5740				endm 
# End of macro FORTH_DSP_POP
5740			;		pop hl 
5740					; push file id to stack 
5740 cd 48 20				call forth_push_numhl 
5743			 
5743			 
5743			 
5743				       NEXTW 
5743 c3 39 24			jp macro_next 
5746				endm 
# End of macro NEXTW
5746			 
5746			.APPEND: 
5746				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5746 69				db WORD_SYS_CORE+85             
5747 d7 57			dw .SDEL            
5749 07				db 6 + 1 
574a .. 00			db "APPEND",0              
5751				endm 
# End of macro CWHEAD
5751			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5751			; | | e.g. 
5751			; | | Test CREATE      -> $01 
5751			; | | "A string to add to file" $01 APPEND 
5751			; | |  
5751			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5751			; | | > [!NOTE] 
5751			; | | > Compatible with PicoSPINet  
5751					if DEBUG_FORTH_WORDS_KEY 
5751						DMARK "APP" 
5751 f5				push af  
5752 3a 66 57			ld a, (.dmark)  
5755 32 a0 fd			ld (debug_mark),a  
5758 3a 67 57			ld a, (.dmark+1)  
575b 32 a1 fd			ld (debug_mark+1),a  
575e 3a 68 57			ld a, (.dmark+2)  
5761 32 a2 fd			ld (debug_mark+2),a  
5764 18 03			jr .pastdmark  
5766 ..			.dmark: db "APP"  
5769 f1			.pastdmark: pop af  
576a			endm  
# End of macro DMARK
576a						CALLMONITOR 
576a cd aa fd			call debug_vector  
576d				endm  
# End of macro CALLMONITOR
576d					endif 
576d			 
576d					FORTH_DSP_VALUEHL 
576d cd 4d 22			call macro_dsp_valuehl 
5770				endm 
# End of macro FORTH_DSP_VALUEHL
5770 e5					push hl 	; save file id 
5771			 
5771				if DEBUG_STORESE 
5771					DMARK "AP1" 
5771 f5				push af  
5772 3a 86 57			ld a, (.dmark)  
5775 32 a0 fd			ld (debug_mark),a  
5778 3a 87 57			ld a, (.dmark+1)  
577b 32 a1 fd			ld (debug_mark+1),a  
577e 3a 88 57			ld a, (.dmark+2)  
5781 32 a2 fd			ld (debug_mark+2),a  
5784 18 03			jr .pastdmark  
5786 ..			.dmark: db "AP1"  
5789 f1			.pastdmark: pop af  
578a			endm  
# End of macro DMARK
578a					CALLMONITOR 
578a cd aa fd			call debug_vector  
578d				endm  
# End of macro CALLMONITOR
578d				endif 
578d					FORTH_DSP_POP 
578d cd 05 23			call macro_forth_dsp_pop 
5790				endm 
# End of macro FORTH_DSP_POP
5790			 
5790					FORTH_DSP_VALUEHL 
5790 cd 4d 22			call macro_dsp_valuehl 
5793				endm 
# End of macro FORTH_DSP_VALUEHL
5793					;v5 FORTH_DSP_VALUE 
5793 e5					push hl 	; save ptr to string to save 
5794			 
5794				if DEBUG_STORESE 
5794					DMARK "AP1" 
5794 f5				push af  
5795 3a a9 57			ld a, (.dmark)  
5798 32 a0 fd			ld (debug_mark),a  
579b 3a aa 57			ld a, (.dmark+1)  
579e 32 a1 fd			ld (debug_mark+1),a  
57a1 3a ab 57			ld a, (.dmark+2)  
57a4 32 a2 fd			ld (debug_mark+2),a  
57a7 18 03			jr .pastdmark  
57a9 ..			.dmark: db "AP1"  
57ac f1			.pastdmark: pop af  
57ad			endm  
# End of macro DMARK
57ad					CALLMONITOR 
57ad cd aa fd			call debug_vector  
57b0				endm  
# End of macro CALLMONITOR
57b0				endif 
57b0					FORTH_DSP_POP 
57b0 cd 05 23			call macro_forth_dsp_pop 
57b3				endm 
# End of macro FORTH_DSP_POP
57b3			 
57b3 d1					pop de 
57b4 e1					pop hl 
57b5				if DEBUG_STORESE 
57b5					DMARK "AP2" 
57b5 f5				push af  
57b6 3a ca 57			ld a, (.dmark)  
57b9 32 a0 fd			ld (debug_mark),a  
57bc 3a cb 57			ld a, (.dmark+1)  
57bf 32 a1 fd			ld (debug_mark+1),a  
57c2 3a cc 57			ld a, (.dmark+2)  
57c5 32 a2 fd			ld (debug_mark+2),a  
57c8 18 03			jr .pastdmark  
57ca ..			.dmark: db "AP2"  
57cd f1			.pastdmark: pop af  
57ce			endm  
# End of macro DMARK
57ce					CALLMONITOR 
57ce cd aa fd			call debug_vector  
57d1				endm  
# End of macro CALLMONITOR
57d1				endif 
57d1					;inc de ; skip var type indicator 
57d1			 
57d1					; TODO how to append numerics???? 
57d1			 
57d1 cd 64 0b				call storage_append		 
57d4			 
57d4				       NEXTW 
57d4 c3 39 24			jp macro_next 
57d7				endm 
# End of macro NEXTW
57d7			.SDEL: 
57d7				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
57d7 6a				db WORD_SYS_CORE+86             
57d8 23 58			dw .OPEN            
57da 05				db 4 + 1 
57db .. 00			db "ERA",0              
57df				endm 
# End of macro CWHEAD
57df			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
57df			; | | > [!NOTE] 
57df			; | | > Compatible with PicoSPINet  
57df					FORTH_DSP_VALUEHL 
57df cd 4d 22			call macro_dsp_valuehl 
57e2				endm 
# End of macro FORTH_DSP_VALUEHL
57e2			;		push hl 	; save file id 
57e2			 
57e2					if DEBUG_FORTH_WORDS_KEY 
57e2						DMARK "ERA" 
57e2 f5				push af  
57e3 3a f7 57			ld a, (.dmark)  
57e6 32 a0 fd			ld (debug_mark),a  
57e9 3a f8 57			ld a, (.dmark+1)  
57ec 32 a1 fd			ld (debug_mark+1),a  
57ef 3a f9 57			ld a, (.dmark+2)  
57f2 32 a2 fd			ld (debug_mark+2),a  
57f5 18 03			jr .pastdmark  
57f7 ..			.dmark: db "ERA"  
57fa f1			.pastdmark: pop af  
57fb			endm  
# End of macro DMARK
57fb						CALLMONITOR 
57fb cd aa fd			call debug_vector  
57fe				endm  
# End of macro CALLMONITOR
57fe					endif 
57fe				if DEBUG_STORESE 
57fe					DMARK "ER1" 
57fe f5				push af  
57ff 3a 13 58			ld a, (.dmark)  
5802 32 a0 fd			ld (debug_mark),a  
5805 3a 14 58			ld a, (.dmark+1)  
5808 32 a1 fd			ld (debug_mark+1),a  
580b 3a 15 58			ld a, (.dmark+2)  
580e 32 a2 fd			ld (debug_mark+2),a  
5811 18 03			jr .pastdmark  
5813 ..			.dmark: db "ER1"  
5816 f1			.pastdmark: pop af  
5817			endm  
# End of macro DMARK
5817					CALLMONITOR 
5817 cd aa fd			call debug_vector  
581a				endm  
# End of macro CALLMONITOR
581a				endif 
581a					FORTH_DSP_POP 
581a cd 05 23			call macro_forth_dsp_pop 
581d				endm 
# End of macro FORTH_DSP_POP
581d			 
581d			;		pop hl 
581d			 
581d cd b6 06				call storage_erase 
5820				       NEXTW 
5820 c3 39 24			jp macro_next 
5823				endm 
# End of macro NEXTW
5823			 
5823			.OPEN: 
5823				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5823 6b				db WORD_SYS_CORE+87             
5824 b7 58			dw .READ            
5826 05				db 4 + 1 
5827 .. 00			db "OPEN",0              
582c				endm 
# End of macro CWHEAD
582c			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
582c			; | | e.g. 
582c			; | | $01 OPEN $01 DO $01 READ . LOOP 
582c			; | | 
582c			; | | Will return with 255 blocks if the file does not exist 
582c			; | | > [!NOTE] 
582c			; | | > Compatible with PicoSPINet  
582c			 
582c					if DEBUG_FORTH_WORDS_KEY 
582c						DMARK "OPN" 
582c f5				push af  
582d 3a 41 58			ld a, (.dmark)  
5830 32 a0 fd			ld (debug_mark),a  
5833 3a 42 58			ld a, (.dmark+1)  
5836 32 a1 fd			ld (debug_mark+1),a  
5839 3a 43 58			ld a, (.dmark+2)  
583c 32 a2 fd			ld (debug_mark+2),a  
583f 18 03			jr .pastdmark  
5841 ..			.dmark: db "OPN"  
5844 f1			.pastdmark: pop af  
5845			endm  
# End of macro DMARK
5845						CALLMONITOR 
5845 cd aa fd			call debug_vector  
5848				endm  
# End of macro CALLMONITOR
5848					endif 
5848					; TODO handle multiple file opens 
5848			 
5848 3e 01			       	ld a, 1 
584a 32 9f f9				ld (store_openext), a 
584d			 
584d					; get max extents for this file 
584d				 
584d								 
584d					FORTH_DSP_VALUEHL 
584d cd 4d 22			call macro_dsp_valuehl 
5850				endm 
# End of macro FORTH_DSP_VALUEHL
5850			 
5850 65					ld h, l 
5851 2e 00				ld l, 0 
5853			 
5853					; store file id 
5853			 
5853 7c					ld a, h 
5854 32 9c f9				ld (store_filecache), a 
5857			 
5857				if DEBUG_STORESE 
5857					DMARK "OPN" 
5857 f5				push af  
5858 3a 6c 58			ld a, (.dmark)  
585b 32 a0 fd			ld (debug_mark),a  
585e 3a 6d 58			ld a, (.dmark+1)  
5861 32 a1 fd			ld (debug_mark+1),a  
5864 3a 6e 58			ld a, (.dmark+2)  
5867 32 a2 fd			ld (debug_mark+2),a  
586a 18 03			jr .pastdmark  
586c ..			.dmark: db "OPN"  
586f f1			.pastdmark: pop af  
5870			endm  
# End of macro DMARK
5870					CALLMONITOR 
5870 cd aa fd			call debug_vector  
5873				endm  
# End of macro CALLMONITOR
5873				endif 
5873			;		push hl 
5873					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5873 cd 05 23			call macro_forth_dsp_pop 
5876				endm 
# End of macro FORTH_DSP_POP
5876			;		pop hl 
5876						 
5876 11 af f9				ld de, store_page      ; get block zero of file 
5879 cd cd 09				call storage_read 
587c cd 07 10			call ishlzero 
587f 20 04			jr nz, .opfound 
5881			 
5881				; file does not exist so indicate with 255 extents in use 
5881			 
5881 3e ff			ld a, 255 
5883 18 29			jr .skipopeneof 
5885			 
5885			 
5885			.opfound: 
5885			 
5885			 
5885 3a b1 f9				ld a, (store_page+2)    ; max extents for this file 
5888 32 9e f9				ld  (store_openmaxext), a   ; get our limit and push 
588b					 
588b				if DEBUG_STORESE 
588b					DMARK "OPx" 
588b f5				push af  
588c 3a a0 58			ld a, (.dmark)  
588f 32 a0 fd			ld (debug_mark),a  
5892 3a a1 58			ld a, (.dmark+1)  
5895 32 a1 fd			ld (debug_mark+1),a  
5898 3a a2 58			ld a, (.dmark+2)  
589b 32 a2 fd			ld (debug_mark+2),a  
589e 18 03			jr .pastdmark  
58a0 ..			.dmark: db "OPx"  
58a3 f1			.pastdmark: pop af  
58a4			endm  
# End of macro DMARK
58a4					CALLMONITOR 
58a4 cd aa fd			call debug_vector  
58a7				endm  
# End of macro CALLMONITOR
58a7				endif 
58a7 fe 00				cp 0 
58a9 20 03				jr nz, .skipopeneof 
58ab					; have opened an empty file 
58ab					 
58ab 32 9f f9				ld (store_openext), a 
58ae			 
58ae			.skipopeneof: 
58ae			 
58ae 6f					ld l, a 
58af 26 00				ld h, 0 
58b1 cd 48 20				call forth_push_numhl 
58b4			 
58b4			 
58b4				       NEXTW 
58b4 c3 39 24			jp macro_next 
58b7				endm 
# End of macro NEXTW
58b7			.READ: 
58b7				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
58b7 6c				db WORD_SYS_CORE+88             
58b8 e1 59			dw .EOF            
58ba 05				db 4 + 1 
58bb .. 00			db "READ",0              
58c0				endm 
# End of macro CWHEAD
58c0			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
58c0			; | | e.g. 
58c0			; | | $01 OPEN $01 DO READ . LOOP 
58c0			; | | 
58c0			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
58c0			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
58c0			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
58c0			; | | two bytes contain the file id and extent. 
58c0			; | |  
58c0			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
58c0			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
58c0			; | | > [!NOTE] 
58c0			; | | > Compatible with PicoSPINet  
58c0			 
58c0					if DEBUG_FORTH_WORDS_KEY 
58c0						DMARK "REA" 
58c0 f5				push af  
58c1 3a d5 58			ld a, (.dmark)  
58c4 32 a0 fd			ld (debug_mark),a  
58c7 3a d6 58			ld a, (.dmark+1)  
58ca 32 a1 fd			ld (debug_mark+1),a  
58cd 3a d7 58			ld a, (.dmark+2)  
58d0 32 a2 fd			ld (debug_mark+2),a  
58d3 18 03			jr .pastdmark  
58d5 ..			.dmark: db "REA"  
58d8 f1			.pastdmark: pop af  
58d9			endm  
# End of macro DMARK
58d9						CALLMONITOR 
58d9 cd aa fd			call debug_vector  
58dc				endm  
# End of macro CALLMONITOR
58dc					endif 
58dc					; store_openext use it. If zero it is EOF 
58dc			 
58dc					; read block from current stream id 
58dc					; if the block does not contain zero term keep reading blocks until zero found 
58dc					; push the block to stack 
58dc					; save the block id to stream 
58dc			 
58dc			 
58dc cd 0e 5a				call .testeof 
58df 3e 01				ld a, 1 
58e1 bd					cp l 
58e2 ca bd 59				jp z, .ateof 
58e5			 
58e5			 
58e5			;		FORTH_DSP_VALUEHL 
58e5			 
58e5			;		push hl 
58e5			 
58e5			;	if DEBUG_STORESE 
58e5			;		DMARK "REA" 
58e5			;		CALLMONITOR 
58e5			;	endif 
58e5			;		FORTH_DSP_POP 
58e5			 
58e5			;		pop hl 
58e5				 
58e5 3a 9c f9				ld a, (store_filecache) 
58e8 67					ld h,a 
58e9			 
58e9 3a 9f f9				ld a, (store_openext) 
58ec 6f					ld l, a 
58ed					 
58ed fe 00				cp 0 
58ef ca bd 59				jp z, .ateof     ; dont read past eof 
58f2			 
58f2 cd b0 0c				call storage_clear_page 
58f5			 
58f5 11 af f9				ld de, store_page 
58f8				if DEBUG_STORESE 
58f8					DMARK "RE1" 
58f8 f5				push af  
58f9 3a 0d 59			ld a, (.dmark)  
58fc 32 a0 fd			ld (debug_mark),a  
58ff 3a 0e 59			ld a, (.dmark+1)  
5902 32 a1 fd			ld (debug_mark+1),a  
5905 3a 0f 59			ld a, (.dmark+2)  
5908 32 a2 fd			ld (debug_mark+2),a  
590b 18 03			jr .pastdmark  
590d ..			.dmark: db "RE1"  
5910 f1			.pastdmark: pop af  
5911			endm  
# End of macro DMARK
5911					CALLMONITOR 
5911 cd aa fd			call debug_vector  
5914				endm  
# End of macro CALLMONITOR
5914				endif 
5914 cd cd 09				call storage_read 
5917			 
5917				if DEBUG_STORESE 
5917					DMARK "RE2" 
5917 f5				push af  
5918 3a 2c 59			ld a, (.dmark)  
591b 32 a0 fd			ld (debug_mark),a  
591e 3a 2d 59			ld a, (.dmark+1)  
5921 32 a1 fd			ld (debug_mark+1),a  
5924 3a 2e 59			ld a, (.dmark+2)  
5927 32 a2 fd			ld (debug_mark+2),a  
592a 18 03			jr .pastdmark  
592c ..			.dmark: db "RE2"  
592f f1			.pastdmark: pop af  
5930			endm  
# End of macro DMARK
5930					CALLMONITOR 
5930 cd aa fd			call debug_vector  
5933				endm  
# End of macro CALLMONITOR
5933				endif 
5933 cd 07 10			call ishlzero 
5936			;	ld a, l 
5936			;	add h 
5936			;	cp 0 
5936 ca bd 59			jp z, .readeof 
5939			 
5939				; not eof so hl should point to data to push to stack 
5939			 
5939				if DEBUG_STORESE 
5939					DMARK "RE3" 
5939 f5				push af  
593a 3a 4e 59			ld a, (.dmark)  
593d 32 a0 fd			ld (debug_mark),a  
5940 3a 4f 59			ld a, (.dmark+1)  
5943 32 a1 fd			ld (debug_mark+1),a  
5946 3a 50 59			ld a, (.dmark+2)  
5949 32 a2 fd			ld (debug_mark+2),a  
594c 18 03			jr .pastdmark  
594e ..			.dmark: db "RE3"  
5951 f1			.pastdmark: pop af  
5952			endm  
# End of macro DMARK
5952					CALLMONITOR 
5952 cd aa fd			call debug_vector  
5955				endm  
# End of macro CALLMONITOR
5955				endif 
5955 cd b6 20			call forth_push_str 
5958			 
5958				if DEBUG_STORESE 
5958					DMARK "RE4" 
5958 f5				push af  
5959 3a 6d 59			ld a, (.dmark)  
595c 32 a0 fd			ld (debug_mark),a  
595f 3a 6e 59			ld a, (.dmark+1)  
5962 32 a1 fd			ld (debug_mark+1),a  
5965 3a 6f 59			ld a, (.dmark+2)  
5968 32 a2 fd			ld (debug_mark+2),a  
596b 18 03			jr .pastdmark  
596d ..			.dmark: db "RE4"  
5970 f1			.pastdmark: pop af  
5971			endm  
# End of macro DMARK
5971					CALLMONITOR 
5971 cd aa fd			call debug_vector  
5974				endm  
# End of macro CALLMONITOR
5974				endif 
5974				; get next block  or mark as eof 
5974			 
5974 3a 9e f9			ld a, (store_openmaxext)   ; get our limit 
5977 4f				ld c, a	 
5978 3a 9f f9			ld a, (store_openext) 
597b			 
597b				if DEBUG_STORESE 
597b					DMARK "RE5" 
597b f5				push af  
597c 3a 90 59			ld a, (.dmark)  
597f 32 a0 fd			ld (debug_mark),a  
5982 3a 91 59			ld a, (.dmark+1)  
5985 32 a1 fd			ld (debug_mark+1),a  
5988 3a 92 59			ld a, (.dmark+2)  
598b 32 a2 fd			ld (debug_mark+2),a  
598e 18 03			jr .pastdmark  
5990 ..			.dmark: db "RE5"  
5993 f1			.pastdmark: pop af  
5994			endm  
# End of macro DMARK
5994					CALLMONITOR 
5994 cd aa fd			call debug_vector  
5997				endm  
# End of macro CALLMONITOR
5997				endif 
5997 b9				cp c 
5998 28 23			jr z, .readeof     ; at last extent 
599a			 
599a 3c					inc a 
599b 32 9f f9				ld (store_openext), a 
599e			 
599e				if DEBUG_STORESE 
599e					DMARK "RE6" 
599e f5				push af  
599f 3a b3 59			ld a, (.dmark)  
59a2 32 a0 fd			ld (debug_mark),a  
59a5 3a b4 59			ld a, (.dmark+1)  
59a8 32 a1 fd			ld (debug_mark+1),a  
59ab 3a b5 59			ld a, (.dmark+2)  
59ae 32 a2 fd			ld (debug_mark+2),a  
59b1 18 03			jr .pastdmark  
59b3 ..			.dmark: db "RE6"  
59b6 f1			.pastdmark: pop af  
59b7			endm  
# End of macro DMARK
59b7					CALLMONITOR 
59b7 cd aa fd			call debug_vector  
59ba				endm  
# End of macro CALLMONITOR
59ba				endif 
59ba			 
59ba			 
59ba				       NEXTW 
59ba c3 39 24			jp macro_next 
59bd				endm 
# End of macro NEXTW
59bd			.ateof: 
59bd				;	ld hl, .showeof 
59bd				;	call forth_push_str 
59bd 3e 00		.readeof:	ld a, 0 
59bf 32 9f f9				ld (store_openext), a 
59c2			 
59c2					 
59c2				if DEBUG_STORESE 
59c2					DMARK "REF" 
59c2 f5				push af  
59c3 3a d7 59			ld a, (.dmark)  
59c6 32 a0 fd			ld (debug_mark),a  
59c9 3a d8 59			ld a, (.dmark+1)  
59cc 32 a1 fd			ld (debug_mark+1),a  
59cf 3a d9 59			ld a, (.dmark+2)  
59d2 32 a2 fd			ld (debug_mark+2),a  
59d5 18 03			jr .pastdmark  
59d7 ..			.dmark: db "REF"  
59da f1			.pastdmark: pop af  
59db			endm  
# End of macro DMARK
59db					CALLMONITOR 
59db cd aa fd			call debug_vector  
59de				endm  
# End of macro CALLMONITOR
59de				endif 
59de				       NEXTW 
59de c3 39 24			jp macro_next 
59e1				endm 
# End of macro NEXTW
59e1			 
59e1			;.showeof:   db "eof", 0 
59e1			 
59e1			 
59e1			.EOF: 
59e1				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
59e1 6d				db WORD_SYS_CORE+89             
59e2 23 5a			dw .FORMAT            
59e4 04				db 3 + 1 
59e5 .. 00			db "EOF",0              
59e9				endm 
# End of macro CWHEAD
59e9			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
59e9			; | | e.g. 
59e9			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
59e9			; | | > [!NOTE] 
59e9			; | | > Compatible with PicoSPINet  
59e9					; TODO if current block id for stream is zero then push true else false 
59e9			 
59e9					if DEBUG_FORTH_WORDS_KEY 
59e9						DMARK "EOF" 
59e9 f5				push af  
59ea 3a fe 59			ld a, (.dmark)  
59ed 32 a0 fd			ld (debug_mark),a  
59f0 3a ff 59			ld a, (.dmark+1)  
59f3 32 a1 fd			ld (debug_mark+1),a  
59f6 3a 00 5a			ld a, (.dmark+2)  
59f9 32 a2 fd			ld (debug_mark+2),a  
59fc 18 03			jr .pastdmark  
59fe ..			.dmark: db "EOF"  
5a01 f1			.pastdmark: pop af  
5a02			endm  
# End of macro DMARK
5a02						CALLMONITOR 
5a02 cd aa fd			call debug_vector  
5a05				endm  
# End of macro CALLMONITOR
5a05					endif 
5a05			 
5a05					; TODO handlue multiple file streams 
5a05			 
5a05			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5a05 cd 0e 5a				call .testeof 
5a08 cd 48 20				call forth_push_numhl 
5a0b			 
5a0b			 
5a0b				       NEXTW 
5a0b c3 39 24			jp macro_next 
5a0e				endm 
# End of macro NEXTW
5a0e			 
5a0e			.testeof: 
5a0e 2e 01				ld l, 1 
5a10 3a 9e f9				ld a, (store_openmaxext) 
5a13 fe 00				cp 0 
5a15 28 09				jr  z, .eofdone   ; empty file 
5a17 3a 9f f9				ld a, (store_openext) 
5a1a fe 00				cp 0 
5a1c 28 02				jr  z, .eofdone 
5a1e 2e 00				ld l, 0 
5a20 26 00		.eofdone:	ld h, 0 
5a22 c9					ret 
5a23			 
5a23			 
5a23			 
5a23			 
5a23			.FORMAT: 
5a23				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5a23 6d				db WORD_SYS_CORE+89             
5a24 74 5a			dw .LABEL            
5a26 07				db 6 + 1 
5a27 .. 00			db "FORMAT",0              
5a2e				endm 
# End of macro CWHEAD
5a2e			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5a2e			; | | > [!NOTE] 
5a2e			; | | > Compatible with PicoSPINet  
5a2e					; TODO if current block id for stream is zero then push true else false 
5a2e				 
5a2e				if DEBUG_STORESE 
5a2e					DMARK "FOR" 
5a2e f5				push af  
5a2f 3a 43 5a			ld a, (.dmark)  
5a32 32 a0 fd			ld (debug_mark),a  
5a35 3a 44 5a			ld a, (.dmark+1)  
5a38 32 a1 fd			ld (debug_mark+1),a  
5a3b 3a 45 5a			ld a, (.dmark+2)  
5a3e 32 a2 fd			ld (debug_mark+2),a  
5a41 18 03			jr .pastdmark  
5a43 ..			.dmark: db "FOR"  
5a46 f1			.pastdmark: pop af  
5a47			endm  
# End of macro DMARK
5a47					CALLMONITOR 
5a47 cd aa fd			call debug_vector  
5a4a				endm  
# End of macro CALLMONITOR
5a4a				endif 
5a4a					; Wipes the bank check flags to cause a reformat on next block 0 read 
5a4a			 
5a4a 21 01 00				ld hl, 1 
5a4d 3e 00				ld a, 0 
5a4f cd 79 02				call se_writebyte 
5a52			 
5a52				if DEBUG_STORESE 
5a52					DMARK "FO0" 
5a52 f5				push af  
5a53 3a 67 5a			ld a, (.dmark)  
5a56 32 a0 fd			ld (debug_mark),a  
5a59 3a 68 5a			ld a, (.dmark+1)  
5a5c 32 a1 fd			ld (debug_mark+1),a  
5a5f 3a 69 5a			ld a, (.dmark+2)  
5a62 32 a2 fd			ld (debug_mark+2),a  
5a65 18 03			jr .pastdmark  
5a67 ..			.dmark: db "FO0"  
5a6a f1			.pastdmark: pop af  
5a6b			endm  
# End of macro DMARK
5a6b					CALLMONITOR 
5a6b cd aa fd			call debug_vector  
5a6e				endm  
# End of macro CALLMONITOR
5a6e				endif 
5a6e					; force bank init 
5a6e			 
5a6e cd 25 05				call storage_get_block_0 
5a71					 
5a71				       NEXTW 
5a71 c3 39 24			jp macro_next 
5a74				endm 
# End of macro NEXTW
5a74			.LABEL: 
5a74				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5a74 6d				db WORD_SYS_CORE+89             
5a75 c2 5a			dw .STOREPAGE            
5a77 06				db 5 + 1 
5a78 .. 00			db "LABEL",0              
5a7e				endm 
# End of macro CWHEAD
5a7e			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5a7e			; | | > [!NOTE] 
5a7e			; | | > Compatible with PicoSPINet  
5a7e					; TODO test to see if bank is selected 
5a7e				 
5a7e					if DEBUG_FORTH_WORDS_KEY 
5a7e						DMARK "LBL" 
5a7e f5				push af  
5a7f 3a 93 5a			ld a, (.dmark)  
5a82 32 a0 fd			ld (debug_mark),a  
5a85 3a 94 5a			ld a, (.dmark+1)  
5a88 32 a1 fd			ld (debug_mark+1),a  
5a8b 3a 95 5a			ld a, (.dmark+2)  
5a8e 32 a2 fd			ld (debug_mark+2),a  
5a91 18 03			jr .pastdmark  
5a93 ..			.dmark: db "LBL"  
5a96 f1			.pastdmark: pop af  
5a97			endm  
# End of macro DMARK
5a97						CALLMONITOR 
5a97 cd aa fd			call debug_vector  
5a9a				endm  
# End of macro CALLMONITOR
5a9a					endif 
5a9a			;	if DEBUG_STORESE 
5a9a			;		DMARK "LBL" 
5a9a			;		CALLMONITOR 
5a9a			;	endif 
5a9a					FORTH_DSP_VALUEHL 
5a9a cd 4d 22			call macro_dsp_valuehl 
5a9d				endm 
# End of macro FORTH_DSP_VALUEHL
5a9d					;v5FORTH_DSP_VALUE 
5a9d					 
5a9d			;		push hl 
5a9d					FORTH_DSP_POP 
5a9d cd 05 23			call macro_forth_dsp_pop 
5aa0				endm 
# End of macro FORTH_DSP_POP
5aa0			;		pop hl 
5aa0			 
5aa0			;v5		inc hl   ; move past the type marker 
5aa0			 
5aa0				if DEBUG_STORESE 
5aa0					DMARK "LBl" 
5aa0 f5				push af  
5aa1 3a b5 5a			ld a, (.dmark)  
5aa4 32 a0 fd			ld (debug_mark),a  
5aa7 3a b6 5a			ld a, (.dmark+1)  
5aaa 32 a1 fd			ld (debug_mark+1),a  
5aad 3a b7 5a			ld a, (.dmark+2)  
5ab0 32 a2 fd			ld (debug_mark+2),a  
5ab3 18 03			jr .pastdmark  
5ab5 ..			.dmark: db "LBl"  
5ab8 f1			.pastdmark: pop af  
5ab9			endm  
# End of macro DMARK
5ab9					CALLMONITOR 
5ab9 cd aa fd			call debug_vector  
5abc				endm  
# End of macro CALLMONITOR
5abc				endif 
5abc cd 49 06				call storage_label 
5abf			 
5abf				       NEXTW 
5abf c3 39 24			jp macro_next 
5ac2				endm 
# End of macro NEXTW
5ac2			.STOREPAGE: 
5ac2				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5ac2 6d				db WORD_SYS_CORE+89             
5ac3 f5 5a			dw .LABELS            
5ac5 0a				db 9 + 1 
5ac6 .. 00			db "STOREPAGE",0              
5ad0				endm 
# End of macro CWHEAD
5ad0			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5ad0			; | | > [!NOTE] 
5ad0			; | | > Compatible with PicoSPINet  
5ad0					; TODO test to see if bank is selected 
5ad0				 
5ad0					if DEBUG_FORTH_WORDS_KEY 
5ad0						DMARK "STP" 
5ad0 f5				push af  
5ad1 3a e5 5a			ld a, (.dmark)  
5ad4 32 a0 fd			ld (debug_mark),a  
5ad7 3a e6 5a			ld a, (.dmark+1)  
5ada 32 a1 fd			ld (debug_mark+1),a  
5add 3a e7 5a			ld a, (.dmark+2)  
5ae0 32 a2 fd			ld (debug_mark+2),a  
5ae3 18 03			jr .pastdmark  
5ae5 ..			.dmark: db "STP"  
5ae8 f1			.pastdmark: pop af  
5ae9			endm  
# End of macro DMARK
5ae9						CALLMONITOR 
5ae9 cd aa fd			call debug_vector  
5aec				endm  
# End of macro CALLMONITOR
5aec					endif 
5aec			;	if DEBUG_STORESE 
5aec			;		DMARK "STP" 
5aec			;		CALLMONITOR 
5aec			;	endif 
5aec			 
5aec 21 af f9			ld hl, store_page 
5aef cd 48 20			call forth_push_numhl 
5af2			 
5af2			 
5af2				       NEXTW 
5af2 c3 39 24			jp macro_next 
5af5				endm 
# End of macro NEXTW
5af5			.LABELS: 
5af5				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5af5 6d				db WORD_SYS_CORE+89             
5af6 7f 5b			dw .SCONST1            
5af8 07				db 6 + 1 
5af9 .. 00			db "LABELS",0              
5b00				endm 
# End of macro CWHEAD
5b00			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
5b00			; | | > [!CAUTION] 
5b00			; | | > *NOT* Compatible with PicoSPINet  
5b00					;  
5b00			 
5b00					; save the current device selected to restore afterwards 
5b00				 
5b00 3a 95 f9				ld a, (spi_device) 
5b03 f5					push af 
5b04			 
5b04			 
5b04					; run through each of the banks 
5b04			 
5b04 21 01 00				ld hl, 1 
5b07 cd 48 20				call forth_push_numhl 
5b0a 3e ff				ld a, SPI_CE_HIGH 
5b0c cb 87				res SPI_CE0, a 
5b0e 32 95 f9				ld (spi_device), a 
5b11 cd 25 05				call storage_get_block_0 
5b14 21 b2 f9				ld hl, store_page+3 
5b17 cd b6 20				call forth_push_str 
5b1a			 
5b1a					 
5b1a 21 02 00				ld hl, 2 
5b1d cd 48 20				call forth_push_numhl 
5b20 3e ff				ld a, SPI_CE_HIGH 
5b22 cb 8f				res SPI_CE1, a 
5b24 32 95 f9				ld (spi_device), a 
5b27 cd 25 05				call storage_get_block_0 
5b2a 21 b2 f9				ld hl, store_page+3 
5b2d cd b6 20				call forth_push_str 
5b30			 
5b30					 
5b30 21 03 00				ld hl, 3 
5b33 cd 48 20				call forth_push_numhl 
5b36 3e ff				ld a, SPI_CE_HIGH 
5b38 cb 97				res SPI_CE2, a 
5b3a 32 95 f9				ld (spi_device), a 
5b3d cd 25 05				call storage_get_block_0 
5b40 21 b2 f9				ld hl, store_page+3 
5b43 cd b6 20				call forth_push_str 
5b46			 
5b46			 
5b46 21 04 00				ld hl, 4 
5b49 cd 48 20				call forth_push_numhl 
5b4c 3e ff				ld a, SPI_CE_HIGH 
5b4e cb 9f				res SPI_CE3, a 
5b50 32 95 f9				ld (spi_device), a 
5b53 cd 25 05				call storage_get_block_0 
5b56 21 b2 f9				ld hl, store_page+3 
5b59 cd b6 20				call forth_push_str 
5b5c			 
5b5c					 
5b5c			 
5b5c 21 05 00				ld hl, 5 
5b5f cd 48 20				call forth_push_numhl 
5b62 3e ff				ld a, SPI_CE_HIGH 
5b64 cb a7				res SPI_CE4, a 
5b66 32 95 f9				ld (spi_device), a 
5b69 cd 25 05				call storage_get_block_0 
5b6c 21 b2 f9				ld hl, store_page+3 
5b6f cd b6 20				call forth_push_str 
5b72			 
5b72					 
5b72					; push fixed count of storage devices (on board) for now 
5b72			 
5b72 21 05 00				ld hl, 5 
5b75 cd 48 20				call forth_push_numhl 
5b78			 
5b78					; restore selected device  
5b78				 
5b78 f1					pop af 
5b79 32 95 f9				ld (spi_device), a 
5b7c			 
5b7c				       NEXTW 
5b7c c3 39 24			jp macro_next 
5b7f				endm 
# End of macro NEXTW
5b7f			 
5b7f			.SCONST1: 
5b7f				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5b7f 6d				db WORD_SYS_CORE+89             
5b80 96 5b			dw .SCONST2            
5b82 07				db 6 + 1 
5b83 .. 00			db "FILEID",0              
5b8a				endm 
# End of macro CWHEAD
5b8a			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5b8a			; | | > [!NOTE] 
5b8a			; | | > Compatible with PicoSPINet  
5b8a 3a 9c f9				ld a, (store_filecache) 
5b8d 26 00				ld h, 0 
5b8f 6f					ld l, a 
5b90 cd 48 20				call forth_push_numhl 
5b93					NEXTW 
5b93 c3 39 24			jp macro_next 
5b96				endm 
# End of macro NEXTW
5b96			.SCONST2: 
5b96				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5b96 6d				db WORD_SYS_CORE+89             
5b97 ae 5b			dw .SCONST3            
5b99 08				db 7 + 1 
5b9a .. 00			db "FILEEXT",0              
5ba2				endm 
# End of macro CWHEAD
5ba2			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5ba2			; | | > [!NOTE] 
5ba2			; | | > Compatible with PicoSPINet  
5ba2 3a 9f f9				ld a, (store_openext) 
5ba5 26 00				ld h, 0 
5ba7 6f					ld l, a 
5ba8 cd 48 20				call forth_push_numhl 
5bab					NEXTW 
5bab c3 39 24			jp macro_next 
5bae				endm 
# End of macro NEXTW
5bae			.SCONST3: 
5bae				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5bae 6d				db WORD_SYS_CORE+89             
5baf c6 5b			dw .SCONST4            
5bb1 08				db 7 + 1 
5bb2 .. 00			db "FILEMAX",0              
5bba				endm 
# End of macro CWHEAD
5bba			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5bba			; | | > [!NOTE] 
5bba			; | | > Compatible with PicoSPINet  
5bba 3a 9e f9				ld a, (store_openmaxext) 
5bbd 26 00				ld h, 0 
5bbf 6f					ld l, a 
5bc0 cd 48 20				call forth_push_numhl 
5bc3					NEXTW 
5bc3 c3 39 24			jp macro_next 
5bc6				endm 
# End of macro NEXTW
5bc6			.SCONST4: 
5bc6				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5bc6 6d				db WORD_SYS_CORE+89             
5bc7 dc 5b			dw .SCONST5            
5bc9 09				db 8 + 1 
5bca .. 00			db "FILEADDR",0              
5bd3				endm 
# End of macro CWHEAD
5bd3			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
5bd3			; | | > [!NOTE] 
5bd3			; | | > Compatible with PicoSPINet  
5bd3 2a a0 f9				ld hl, (store_openaddr) 
5bd6 cd 48 20				call forth_push_numhl 
5bd9					NEXTW 
5bd9 c3 39 24			jp macro_next 
5bdc				endm 
# End of macro NEXTW
5bdc			.SCONST5: 
5bdc				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5bdc 6d				db WORD_SYS_CORE+89             
5bdd fd 5b			dw .SCONST6            
5bdf 09				db 8 + 1 
5be0 .. 00			db "FILEPAGE",0              
5be9				endm 
# End of macro CWHEAD
5be9			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
5be9			; | | > [!NOTE] 
5be9			; | | > Compatible with PicoSPINet  
5be9 2a a0 f9				ld hl, (store_openaddr) 
5bec e5					push hl 
5bed c1					pop bc 
5bee 16 00				ld d, 0 
5bf0 1e 40				ld e, STORE_BLOCK_PHY 
5bf2 cd 3b 0f				call Div16 
5bf5 c5					push bc 
5bf6 e1					pop hl 
5bf7 cd 48 20				call forth_push_numhl 
5bfa					NEXTW 
5bfa c3 39 24			jp macro_next 
5bfd				endm 
# End of macro NEXTW
5bfd			.SCONST6: 
5bfd				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5bfd 6d				db WORD_SYS_CORE+89             
5bfe 16 5c			dw .ENDSTORAGE            
5c00 09				db 8 + 1 
5c01 .. 00			db "READCONT",0              
5c0a				endm 
# End of macro CWHEAD
5c0a			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5c0a			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5c0a			; | | a further read should, if applicable, be CONCAT to the previous read. 
5c0a			; | | > [!NOTE] 
5c0a			; | | > Compatible with PicoSPINet  
5c0a 3a a2 f9				ld a, (store_readcont) 
5c0d 26 00				ld h, 0 
5c0f 6f					ld l, a 
5c10 cd 48 20				call forth_push_numhl 
5c13					NEXTW 
5c13 c3 39 24			jp macro_next 
5c16				endm 
# End of macro NEXTW
5c16			.ENDSTORAGE: 
5c16			; eof 
# End of file forth_words_storage.asm
5c16			endif 
5c16				include "forth_words_device.asm" 
5c16			; Device related words 
5c16			 
5c16			; | ## Device Words 
5c16			 
5c16			;if SOUND_ENABLE 
5c16			;.NOTE: 
5c16			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5c16			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
5c16			;		if DEBUG_FORTH_WORDS_KEY 
5c16			;			DMARK "NTE" 
5c16			;			CALLMONITOR 
5c16			;		endif 
5c16			; 
5c16			;	 
5c16			; 
5c16			;		NEXTW 
5c16			;.AFTERSOUND: 
5c16			;endif 
5c16			 
5c16			 
5c16			USE_GPIO: equ 0 
5c16			 
5c16			if USE_GPIO 
5c16			.GP1: 
5c16				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5c16			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
5c16					NEXTW 
5c16			.GP2: 
5c16				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5c16			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
5c16			 
5c16					NEXTW 
5c16			 
5c16			.GP3: 
5c16				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5c16			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
5c16			 
5c16					NEXTW 
5c16			 
5c16			.GP4: 
5c16				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5c16			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
5c16			 
5c16					NEXTW 
5c16			.SIN: 
5c16			 
5c16			 
5c16			endif 
5c16			 
5c16			 
5c16				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5c16 33				db WORD_SYS_CORE+31             
5c17 4b 5c			dw .SOUT            
5c19 03				db 2 + 1 
5c1a .. 00			db "IN",0              
5c1d				endm 
# End of macro CWHEAD
5c1d			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5c1d					if DEBUG_FORTH_WORDS_KEY 
5c1d						DMARK "IN." 
5c1d f5				push af  
5c1e 3a 32 5c			ld a, (.dmark)  
5c21 32 a0 fd			ld (debug_mark),a  
5c24 3a 33 5c			ld a, (.dmark+1)  
5c27 32 a1 fd			ld (debug_mark+1),a  
5c2a 3a 34 5c			ld a, (.dmark+2)  
5c2d 32 a2 fd			ld (debug_mark+2),a  
5c30 18 03			jr .pastdmark  
5c32 ..			.dmark: db "IN."  
5c35 f1			.pastdmark: pop af  
5c36			endm  
# End of macro DMARK
5c36						CALLMONITOR 
5c36 cd aa fd			call debug_vector  
5c39				endm  
# End of macro CALLMONITOR
5c39					endif 
5c39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c39 cd 4d 22			call macro_dsp_valuehl 
5c3c				endm 
# End of macro FORTH_DSP_VALUEHL
5c3c			 
5c3c e5					push hl 
5c3d			 
5c3d					; destroy value TOS 
5c3d			 
5c3d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c3d cd 05 23			call macro_forth_dsp_pop 
5c40				endm 
# End of macro FORTH_DSP_POP
5c40			 
5c40					; one value on hl get other one back 
5c40			 
5c40 c1					pop bc 
5c41			 
5c41					; do the sub 
5c41			;		ex de, hl 
5c41			 
5c41 ed 68				in l,(c) 
5c43			 
5c43					; save it 
5c43			 
5c43 26 00				ld h,0 
5c45			 
5c45					; TODO push value back onto stack for another op etc 
5c45			 
5c45 cd 48 20				call forth_push_numhl 
5c48					NEXTW 
5c48 c3 39 24			jp macro_next 
5c4b				endm 
# End of macro NEXTW
5c4b			.SOUT: 
5c4b				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5c4b 34				db WORD_SYS_CORE+32             
5c4c 9e 5c			dw .SPIO            
5c4e 04				db 3 + 1 
5c4f .. 00			db "OUT",0              
5c53				endm 
# End of macro CWHEAD
5c53			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5c53					if DEBUG_FORTH_WORDS_KEY 
5c53						DMARK "OUT" 
5c53 f5				push af  
5c54 3a 68 5c			ld a, (.dmark)  
5c57 32 a0 fd			ld (debug_mark),a  
5c5a 3a 69 5c			ld a, (.dmark+1)  
5c5d 32 a1 fd			ld (debug_mark+1),a  
5c60 3a 6a 5c			ld a, (.dmark+2)  
5c63 32 a2 fd			ld (debug_mark+2),a  
5c66 18 03			jr .pastdmark  
5c68 ..			.dmark: db "OUT"  
5c6b f1			.pastdmark: pop af  
5c6c			endm  
# End of macro DMARK
5c6c						CALLMONITOR 
5c6c cd aa fd			call debug_vector  
5c6f				endm  
# End of macro CALLMONITOR
5c6f					endif 
5c6f			 
5c6f					; get port 
5c6f			 
5c6f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c6f cd 4d 22			call macro_dsp_valuehl 
5c72				endm 
# End of macro FORTH_DSP_VALUEHL
5c72			 
5c72 e5					push hl 
5c73			 
5c73					; destroy value TOS 
5c73			 
5c73					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c73 cd 05 23			call macro_forth_dsp_pop 
5c76				endm 
# End of macro FORTH_DSP_POP
5c76			 
5c76					; get byte to send 
5c76			 
5c76					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c76 cd 4d 22			call macro_dsp_valuehl 
5c79				endm 
# End of macro FORTH_DSP_VALUEHL
5c79			 
5c79			;		push hl 
5c79			 
5c79					; destroy value TOS 
5c79			 
5c79					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c79 cd 05 23			call macro_forth_dsp_pop 
5c7c				endm 
# End of macro FORTH_DSP_POP
5c7c			 
5c7c					; one value on hl get other one back 
5c7c			 
5c7c			;		pop hl 
5c7c			 
5c7c c1					pop bc 
5c7d			 
5c7d					if DEBUG_FORTH_WORDS 
5c7d						DMARK "OUT" 
5c7d f5				push af  
5c7e 3a 92 5c			ld a, (.dmark)  
5c81 32 a0 fd			ld (debug_mark),a  
5c84 3a 93 5c			ld a, (.dmark+1)  
5c87 32 a1 fd			ld (debug_mark+1),a  
5c8a 3a 94 5c			ld a, (.dmark+2)  
5c8d 32 a2 fd			ld (debug_mark+2),a  
5c90 18 03			jr .pastdmark  
5c92 ..			.dmark: db "OUT"  
5c95 f1			.pastdmark: pop af  
5c96			endm  
# End of macro DMARK
5c96						CALLMONITOR 
5c96 cd aa fd			call debug_vector  
5c99				endm  
# End of macro CALLMONITOR
5c99					endif 
5c99			 
5c99 ed 69				out (c), l 
5c9b			 
5c9b					NEXTW 
5c9b c3 39 24			jp macro_next 
5c9e				endm 
# End of macro NEXTW
5c9e			 
5c9e			 
5c9e			.SPIO: 
5c9e			 
5c9e			if STORAGE_SE 
5c9e				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5c9e 51				db WORD_SYS_CORE+61             
5c9f af 5c			dw .SPICEH            
5ca1 07				db 6 + 1 
5ca2 .. 00			db "SPICEL",0              
5ca9				endm 
# End of macro CWHEAD
5ca9			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5ca9			 
5ca9 cd 22 02				call spi_ce_low 
5cac			    NEXTW 
5cac c3 39 24			jp macro_next 
5caf				endm 
# End of macro NEXTW
5caf			 
5caf			.SPICEH: 
5caf				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5caf 51				db WORD_SYS_CORE+61             
5cb0 c0 5c			dw .SPIOb            
5cb2 07				db 6 + 1 
5cb3 .. 00			db "SPICEH",0              
5cba				endm 
# End of macro CWHEAD
5cba			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5cba			 
5cba cd 11 02				call spi_ce_high 
5cbd			    NEXTW 
5cbd c3 39 24			jp macro_next 
5cc0				endm 
# End of macro NEXTW
5cc0			 
5cc0			 
5cc0			.SPIOb: 
5cc0			 
5cc0				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5cc0 51				db WORD_SYS_CORE+61             
5cc1 f2 5c			dw .SPII            
5cc3 05				db 4 + 1 
5cc4 .. 00			db "SPIO",0              
5cc9				endm 
# End of macro CWHEAD
5cc9			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5cc9			 
5cc9					if DEBUG_FORTH_WORDS_KEY 
5cc9						DMARK "SPo" 
5cc9 f5				push af  
5cca 3a de 5c			ld a, (.dmark)  
5ccd 32 a0 fd			ld (debug_mark),a  
5cd0 3a df 5c			ld a, (.dmark+1)  
5cd3 32 a1 fd			ld (debug_mark+1),a  
5cd6 3a e0 5c			ld a, (.dmark+2)  
5cd9 32 a2 fd			ld (debug_mark+2),a  
5cdc 18 03			jr .pastdmark  
5cde ..			.dmark: db "SPo"  
5ce1 f1			.pastdmark: pop af  
5ce2			endm  
# End of macro DMARK
5ce2						CALLMONITOR 
5ce2 cd aa fd			call debug_vector  
5ce5				endm  
# End of macro CALLMONITOR
5ce5					endif 
5ce5					; get port 
5ce5			 
5ce5			 
5ce5					; get byte to send 
5ce5			 
5ce5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ce5 cd 4d 22			call macro_dsp_valuehl 
5ce8				endm 
# End of macro FORTH_DSP_VALUEHL
5ce8			 
5ce8			;		push hl    ; u1  
5ce8			 
5ce8					; destroy value TOS 
5ce8			 
5ce8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ce8 cd 05 23			call macro_forth_dsp_pop 
5ceb				endm 
# End of macro FORTH_DSP_POP
5ceb			 
5ceb					; one value on hl get other one back 
5ceb			 
5ceb			;		pop hl   ; u2 - addr 
5ceb			 
5ceb					; TODO Send SPI byte 
5ceb			 
5ceb			;		push hl 
5ceb			;		call spi_ce_low 
5ceb			;		pop hl 
5ceb 7d					ld a, l 
5cec cd 10 01				call spi_send_byte 
5cef			;		call spi_ce_high 
5cef			 
5cef					NEXTW 
5cef c3 39 24			jp macro_next 
5cf2				endm 
# End of macro NEXTW
5cf2			 
5cf2			.SPII: 
5cf2				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5cf2 52				db WORD_SYS_CORE+62             
5cf3 5b 5d			dw .SESEL            
5cf5 06				db 5 + 1 
5cf6 .. 00			db "SPII",0              
5cfb				endm 
# End of macro CWHEAD
5cfb			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5cfb					if DEBUG_FORTH_WORDS_KEY 
5cfb						DMARK "SPi" 
5cfb f5				push af  
5cfc 3a 10 5d			ld a, (.dmark)  
5cff 32 a0 fd			ld (debug_mark),a  
5d02 3a 11 5d			ld a, (.dmark+1)  
5d05 32 a1 fd			ld (debug_mark+1),a  
5d08 3a 12 5d			ld a, (.dmark+2)  
5d0b 32 a2 fd			ld (debug_mark+2),a  
5d0e 18 03			jr .pastdmark  
5d10 ..			.dmark: db "SPi"  
5d13 f1			.pastdmark: pop af  
5d14			endm  
# End of macro DMARK
5d14						CALLMONITOR 
5d14 cd aa fd			call debug_vector  
5d17				endm  
# End of macro CALLMONITOR
5d17					endif 
5d17			 
5d17					; TODO Get SPI byte 
5d17			 
5d17 cd 37 01				call spi_read_byte 
5d1a			 
5d1a					if DEBUG_FORTH_WORDS 
5d1a						DMARK "Si2" 
5d1a f5				push af  
5d1b 3a 2f 5d			ld a, (.dmark)  
5d1e 32 a0 fd			ld (debug_mark),a  
5d21 3a 30 5d			ld a, (.dmark+1)  
5d24 32 a1 fd			ld (debug_mark+1),a  
5d27 3a 31 5d			ld a, (.dmark+2)  
5d2a 32 a2 fd			ld (debug_mark+2),a  
5d2d 18 03			jr .pastdmark  
5d2f ..			.dmark: db "Si2"  
5d32 f1			.pastdmark: pop af  
5d33			endm  
# End of macro DMARK
5d33						CALLMONITOR 
5d33 cd aa fd			call debug_vector  
5d36				endm  
# End of macro CALLMONITOR
5d36					endif 
5d36 26 00				ld h, 0 
5d38 6f					ld l, a 
5d39					if DEBUG_FORTH_WORDS 
5d39						DMARK "Si3" 
5d39 f5				push af  
5d3a 3a 4e 5d			ld a, (.dmark)  
5d3d 32 a0 fd			ld (debug_mark),a  
5d40 3a 4f 5d			ld a, (.dmark+1)  
5d43 32 a1 fd			ld (debug_mark+1),a  
5d46 3a 50 5d			ld a, (.dmark+2)  
5d49 32 a2 fd			ld (debug_mark+2),a  
5d4c 18 03			jr .pastdmark  
5d4e ..			.dmark: db "Si3"  
5d51 f1			.pastdmark: pop af  
5d52			endm  
# End of macro DMARK
5d52						CALLMONITOR 
5d52 cd aa fd			call debug_vector  
5d55				endm  
# End of macro CALLMONITOR
5d55					endif 
5d55 cd 48 20				call forth_push_numhl 
5d58			 
5d58					NEXTW 
5d58 c3 39 24			jp macro_next 
5d5b				endm 
# End of macro NEXTW
5d5b			 
5d5b			 
5d5b			 
5d5b			.SESEL: 
5d5b				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5d5b 66				db WORD_SYS_CORE+82             
5d5c 04 5e			dw .CARTDEV            
5d5e 05				db 4 + 1 
5d5f .. 00			db "BANK",0              
5d64				endm 
# End of macro CWHEAD
5d64			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5d64					if DEBUG_FORTH_WORDS_KEY 
5d64						DMARK "BNK" 
5d64 f5				push af  
5d65 3a 79 5d			ld a, (.dmark)  
5d68 32 a0 fd			ld (debug_mark),a  
5d6b 3a 7a 5d			ld a, (.dmark+1)  
5d6e 32 a1 fd			ld (debug_mark+1),a  
5d71 3a 7b 5d			ld a, (.dmark+2)  
5d74 32 a2 fd			ld (debug_mark+2),a  
5d77 18 03			jr .pastdmark  
5d79 ..			.dmark: db "BNK"  
5d7c f1			.pastdmark: pop af  
5d7d			endm  
# End of macro DMARK
5d7d						CALLMONITOR 
5d7d cd aa fd			call debug_vector  
5d80				endm  
# End of macro CALLMONITOR
5d80					endif 
5d80			 
5d80 3e ff				ld a, 255 
5d82 32 98 f9				ld (spi_cartdev), a 
5d85			 
5d85					; get bank 
5d85			 
5d85					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d85 cd 4d 22			call macro_dsp_valuehl 
5d88				endm 
# End of macro FORTH_DSP_VALUEHL
5d88			 
5d88			;		push hl 
5d88			 
5d88					; destroy value TOS 
5d88			 
5d88					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d88 cd 05 23			call macro_forth_dsp_pop 
5d8b				endm 
# End of macro FORTH_DSP_POP
5d8b			 
5d8b					; one value on hl get other one back 
5d8b			 
5d8b			;		pop hl 
5d8b			 
5d8b			 
5d8b 0e ff				ld c, SPI_CE_HIGH 
5d8d 06 30				ld b, '0'    ; human readable bank number 
5d8f			 
5d8f 7d					ld a, l 
5d90			 
5d90					if DEBUG_FORTH_WORDS 
5d90						DMARK "BNK" 
5d90 f5				push af  
5d91 3a a5 5d			ld a, (.dmark)  
5d94 32 a0 fd			ld (debug_mark),a  
5d97 3a a6 5d			ld a, (.dmark+1)  
5d9a 32 a1 fd			ld (debug_mark+1),a  
5d9d 3a a7 5d			ld a, (.dmark+2)  
5da0 32 a2 fd			ld (debug_mark+2),a  
5da3 18 03			jr .pastdmark  
5da5 ..			.dmark: db "BNK"  
5da8 f1			.pastdmark: pop af  
5da9			endm  
# End of macro DMARK
5da9						CALLMONITOR 
5da9 cd aa fd			call debug_vector  
5dac				endm  
# End of macro CALLMONITOR
5dac					endif 
5dac			 
5dac					; active low 
5dac			 
5dac fe 00				cp 0 
5dae 28 28				jr z, .bset 
5db0 fe 01				cp 1 
5db2 20 04				jr nz, .b2 
5db4 cb 81				res 0, c 
5db6 06 31				ld b, '1'    ; human readable bank number 
5db8 fe 02		.b2:		cp 2 
5dba 20 04				jr nz, .b3 
5dbc cb 89				res 1, c 
5dbe 06 32				ld b, '2'    ; human readable bank number 
5dc0 fe 03		.b3:		cp 3 
5dc2 20 04				jr nz, .b4 
5dc4 cb 91				res 2, c 
5dc6 06 33				ld b, '3'    ; human readable bank number 
5dc8 fe 04		.b4:		cp 4 
5dca 20 04				jr nz, .b5 
5dcc cb 99				res 3, c 
5dce 06 34				ld b, '4'    ; human readable bank number 
5dd0 fe 05		.b5:		cp 5 
5dd2 20 04				jr nz, .bset 
5dd4 cb a1				res 4, c 
5dd6 06 35				ld b, '5'    ; human readable bank number 
5dd8			 
5dd8			.bset: 
5dd8 79					ld a, c 
5dd9 32 95 f9				ld (spi_device),a 
5ddc 78					ld a, b 
5ddd 32 94 f9				ld (spi_device_id),a 
5de0					if DEBUG_FORTH_WORDS 
5de0						DMARK "BN2" 
5de0 f5				push af  
5de1 3a f5 5d			ld a, (.dmark)  
5de4 32 a0 fd			ld (debug_mark),a  
5de7 3a f6 5d			ld a, (.dmark+1)  
5dea 32 a1 fd			ld (debug_mark+1),a  
5ded 3a f7 5d			ld a, (.dmark+2)  
5df0 32 a2 fd			ld (debug_mark+2),a  
5df3 18 03			jr .pastdmark  
5df5 ..			.dmark: db "BN2"  
5df8 f1			.pastdmark: pop af  
5df9			endm  
# End of macro DMARK
5df9						CALLMONITOR 
5df9 cd aa fd			call debug_vector  
5dfc				endm  
# End of macro CALLMONITOR
5dfc					endif 
5dfc			 
5dfc					; set default SPI clk pulse time as disabled for BANK use 
5dfc			 
5dfc 3e 00				ld a, 0 
5dfe 32 99 f9				ld (spi_clktime), a 
5e01			 
5e01					NEXTW 
5e01 c3 39 24			jp macro_next 
5e04				endm 
# End of macro NEXTW
5e04			 
5e04			.CARTDEV: 
5e04				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5e04 66				db WORD_SYS_CORE+82             
5e05 b2 5e			dw .ENDDEVICE            
5e07 08				db 7 + 1 
5e08 .. 00			db "CARTDEV",0              
5e10				endm 
# End of macro CWHEAD
5e10			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5e10					if DEBUG_FORTH_WORDS_KEY 
5e10						DMARK "CDV" 
5e10 f5				push af  
5e11 3a 25 5e			ld a, (.dmark)  
5e14 32 a0 fd			ld (debug_mark),a  
5e17 3a 26 5e			ld a, (.dmark+1)  
5e1a 32 a1 fd			ld (debug_mark+1),a  
5e1d 3a 27 5e			ld a, (.dmark+2)  
5e20 32 a2 fd			ld (debug_mark+2),a  
5e23 18 03			jr .pastdmark  
5e25 ..			.dmark: db "CDV"  
5e28 f1			.pastdmark: pop af  
5e29			endm  
# End of macro DMARK
5e29						CALLMONITOR 
5e29 cd aa fd			call debug_vector  
5e2c				endm  
# End of macro CALLMONITOR
5e2c					endif 
5e2c			 
5e2c					; disable se storage bank selection 
5e2c			 
5e2c 3e ff				ld a, SPI_CE_HIGH		; ce high 
5e2e 32 95 f9				ld (spi_device), a 
5e31			 
5e31					; get bank 
5e31			 
5e31					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5e31 cd 4d 22			call macro_dsp_valuehl 
5e34				endm 
# End of macro FORTH_DSP_VALUEHL
5e34			 
5e34			;		push hl 
5e34			 
5e34					; destroy value TOS 
5e34			 
5e34					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5e34 cd 05 23			call macro_forth_dsp_pop 
5e37				endm 
# End of macro FORTH_DSP_POP
5e37			 
5e37					; one value on hl get other one back 
5e37			 
5e37			;		pop hl 
5e37			 
5e37					; active low 
5e37			 
5e37 0e ff				ld c, 255 
5e39			 
5e39 7d					ld a, l 
5e3a					if DEBUG_FORTH_WORDS 
5e3a						DMARK "CDV" 
5e3a f5				push af  
5e3b 3a 4f 5e			ld a, (.dmark)  
5e3e 32 a0 fd			ld (debug_mark),a  
5e41 3a 50 5e			ld a, (.dmark+1)  
5e44 32 a1 fd			ld (debug_mark+1),a  
5e47 3a 51 5e			ld a, (.dmark+2)  
5e4a 32 a2 fd			ld (debug_mark+2),a  
5e4d 18 03			jr .pastdmark  
5e4f ..			.dmark: db "CDV"  
5e52 f1			.pastdmark: pop af  
5e53			endm  
# End of macro DMARK
5e53						CALLMONITOR 
5e53 cd aa fd			call debug_vector  
5e56				endm  
# End of macro CALLMONITOR
5e56					endif 
5e56 fe 00				cp 0 
5e58 28 30				jr z, .cset 
5e5a fe 01				cp 1 
5e5c 20 02				jr nz, .c2 
5e5e cb 81				res 0, c 
5e60 fe 02		.c2:		cp 2 
5e62 20 02				jr nz, .c3 
5e64 cb 89				res 1, c 
5e66 fe 03		.c3:		cp 3 
5e68 20 02				jr nz, .c4 
5e6a cb 91				res 2, c 
5e6c fe 04		.c4:		cp 4 
5e6e 20 02				jr nz, .c5 
5e70 cb 99				res 3, c 
5e72 fe 05		.c5:		cp 5 
5e74 20 02				jr nz, .c6 
5e76 cb a1				res 4, c 
5e78 fe 06		.c6:		cp 6 
5e7a 20 02				jr nz, .c7 
5e7c cb a9				res 5, c 
5e7e fe 07		.c7:		cp 7 
5e80 20 02				jr nz, .c8 
5e82 cb b1				res 6, c 
5e84 fe 08		.c8:		cp 8 
5e86 20 02				jr nz, .cset 
5e88 cb b9				res 7, c 
5e8a 79			.cset:		ld a, c 
5e8b 32 98 f9				ld (spi_cartdev),a 
5e8e			 
5e8e					if DEBUG_FORTH_WORDS 
5e8e						DMARK "CD2" 
5e8e f5				push af  
5e8f 3a a3 5e			ld a, (.dmark)  
5e92 32 a0 fd			ld (debug_mark),a  
5e95 3a a4 5e			ld a, (.dmark+1)  
5e98 32 a1 fd			ld (debug_mark+1),a  
5e9b 3a a5 5e			ld a, (.dmark+2)  
5e9e 32 a2 fd			ld (debug_mark+2),a  
5ea1 18 03			jr .pastdmark  
5ea3 ..			.dmark: db "CD2"  
5ea6 f1			.pastdmark: pop af  
5ea7			endm  
# End of macro DMARK
5ea7						CALLMONITOR 
5ea7 cd aa fd			call debug_vector  
5eaa				endm  
# End of macro CALLMONITOR
5eaa					endif 
5eaa			 
5eaa					; set default SPI clk pulse time as 10ms for CARTDEV use 
5eaa			 
5eaa 3e 0a				ld a, $0a 
5eac 32 99 f9				ld (spi_clktime), a 
5eaf					NEXTW 
5eaf c3 39 24			jp macro_next 
5eb2				endm 
# End of macro NEXTW
5eb2			endif 
5eb2			 
5eb2			.ENDDEVICE: 
5eb2			; eof 
5eb2			 
# End of file forth_words_device.asm
5eb2			 
5eb2			; var handler 
5eb2			 
5eb2			 
5eb2			.VARS: 
5eb2				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5eb2 77				db WORD_SYS_CORE+99             
5eb3 63 5f			dw .V0            
5eb5 04				db 3 + 1 
5eb6 .. 00			db "VAR",0              
5eba				endm 
# End of macro CWHEAD
5eba			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5eba			;| 
5eba			;| The variable name should consist of a single letter. e.g. "a" 
5eba			;! If a full string is passed then only the first char is looked at 
5eba			;| Any other char could exceed bounds checks!  
5eba			 
5eba					if DEBUG_FORTH_WORDS_KEY 
5eba						DMARK "VAR" 
5eba f5				push af  
5ebb 3a cf 5e			ld a, (.dmark)  
5ebe 32 a0 fd			ld (debug_mark),a  
5ec1 3a d0 5e			ld a, (.dmark+1)  
5ec4 32 a1 fd			ld (debug_mark+1),a  
5ec7 3a d1 5e			ld a, (.dmark+2)  
5eca 32 a2 fd			ld (debug_mark+2),a  
5ecd 18 03			jr .pastdmark  
5ecf ..			.dmark: db "VAR"  
5ed2 f1			.pastdmark: pop af  
5ed3			endm  
# End of macro DMARK
5ed3						CALLMONITOR 
5ed3 cd aa fd			call debug_vector  
5ed6				endm  
# End of macro CALLMONITOR
5ed6					endif 
5ed6			 
5ed6					FORTH_DSP_VALUEHL 
5ed6 cd 4d 22			call macro_dsp_valuehl 
5ed9				endm 
# End of macro FORTH_DSP_VALUEHL
5ed9			 
5ed9 7e					ld a, (hl)    ; get first char on of the string 
5eda			 
5eda			 
5eda					if DEBUG_FORTH_WORDS 
5eda						DMARK "VR1" 
5eda f5				push af  
5edb 3a ef 5e			ld a, (.dmark)  
5ede 32 a0 fd			ld (debug_mark),a  
5ee1 3a f0 5e			ld a, (.dmark+1)  
5ee4 32 a1 fd			ld (debug_mark+1),a  
5ee7 3a f1 5e			ld a, (.dmark+2)  
5eea 32 a2 fd			ld (debug_mark+2),a  
5eed 18 03			jr .pastdmark  
5eef ..			.dmark: db "VR1"  
5ef2 f1			.pastdmark: pop af  
5ef3			endm  
# End of macro DMARK
5ef3						CALLMONITOR 
5ef3 cd aa fd			call debug_vector  
5ef6				endm  
# End of macro CALLMONITOR
5ef6					endif 
5ef6					 
5ef6 f5					push af	 
5ef7					FORTH_DSP_POP 
5ef7 cd 05 23			call macro_forth_dsp_pop 
5efa				endm 
# End of macro FORTH_DSP_POP
5efa f1					pop af 
5efb			 
5efb					; convert to upper 
5efb			 
5efb cd 53 12				call to_upper 
5efe					if DEBUG_FORTH_WORDS 
5efe						DMARK "Vaa" 
5efe f5				push af  
5eff 3a 13 5f			ld a, (.dmark)  
5f02 32 a0 fd			ld (debug_mark),a  
5f05 3a 14 5f			ld a, (.dmark+1)  
5f08 32 a1 fd			ld (debug_mark+1),a  
5f0b 3a 15 5f			ld a, (.dmark+2)  
5f0e 32 a2 fd			ld (debug_mark+2),a  
5f11 18 03			jr .pastdmark  
5f13 ..			.dmark: db "Vaa"  
5f16 f1			.pastdmark: pop af  
5f17			endm  
# End of macro DMARK
5f17						CALLMONITOR 
5f17 cd aa fd			call debug_vector  
5f1a				endm  
# End of macro CALLMONITOR
5f1a					endif 
5f1a 06 41				ld b, 'A' 
5f1c 90					sub b			; set offset 
5f1d					if DEBUG_FORTH_WORDS 
5f1d						DMARK "Vbb" 
5f1d f5				push af  
5f1e 3a 32 5f			ld a, (.dmark)  
5f21 32 a0 fd			ld (debug_mark),a  
5f24 3a 33 5f			ld a, (.dmark+1)  
5f27 32 a1 fd			ld (debug_mark+1),a  
5f2a 3a 34 5f			ld a, (.dmark+2)  
5f2d 32 a2 fd			ld (debug_mark+2),a  
5f30 18 03			jr .pastdmark  
5f32 ..			.dmark: db "Vbb"  
5f35 f1			.pastdmark: pop af  
5f36			endm  
# End of macro DMARK
5f36						CALLMONITOR 
5f36 cd aa fd			call debug_vector  
5f39				endm  
# End of macro CALLMONITOR
5f39					endif 
5f39 cb 27				sla a  
5f3b				 
5f3b					 
5f3b					if DEBUG_FORTH_WORDS 
5f3b						DMARK "VR2" 
5f3b f5				push af  
5f3c 3a 50 5f			ld a, (.dmark)  
5f3f 32 a0 fd			ld (debug_mark),a  
5f42 3a 51 5f			ld a, (.dmark+1)  
5f45 32 a1 fd			ld (debug_mark+1),a  
5f48 3a 52 5f			ld a, (.dmark+2)  
5f4b 32 a2 fd			ld (debug_mark+2),a  
5f4e 18 03			jr .pastdmark  
5f50 ..			.dmark: db "VR2"  
5f53 f1			.pastdmark: pop af  
5f54			endm  
# End of macro DMARK
5f54						CALLMONITOR 
5f54 cd aa fd			call debug_vector  
5f57				endm  
# End of macro CALLMONITOR
5f57					endif 
5f57			 
5f57 21 29 f9				ld hl, cli_var_array2 
5f5a cd de 0f				call addatohl 
5f5d cd 48 20				call forth_push_numhl 
5f60			 
5f60			 
5f60				       NEXTW 
5f60 c3 39 24			jp macro_next 
5f63				endm 
# End of macro NEXTW
5f63			.V0: 
5f63				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5f63 78				db WORD_SYS_CORE+100             
5f64 7b 5f			dw .V0Q            
5f66 04				db 3 + 1 
5f67 .. 00			db "V0!",0              
5f6b				endm 
# End of macro CWHEAD
5f6b			;| V0! ( u1 -- )  Store value to v0  | DONE 
5f6b			 
5f6b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5f6b cd 4d 22			call macro_dsp_valuehl 
5f6e				endm 
# End of macro FORTH_DSP_VALUEHL
5f6e			 
5f6e 11 5d f9				ld de, cli_var_array 
5f71			 
5f71 eb					ex de, hl 
5f72 73					ld (hl), e 
5f73 23					inc hl 
5f74 72					ld (hl), d 
5f75			 
5f75					; destroy value TOS 
5f75			 
5f75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5f75 cd 05 23			call macro_forth_dsp_pop 
5f78				endm 
# End of macro FORTH_DSP_POP
5f78			 
5f78				       NEXTW 
5f78 c3 39 24			jp macro_next 
5f7b				endm 
# End of macro NEXTW
5f7b			.V0Q: 
5f7b				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5f7b 79				db WORD_SYS_CORE+101             
5f7c 8c 5f			dw .V1S            
5f7e 04				db 3 + 1 
5f7f .. 00			db "V0@",0              
5f83				endm 
# End of macro CWHEAD
5f83			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5f83 2a 5d f9				ld hl, (cli_var_array) 
5f86 cd 48 20				call forth_push_numhl 
5f89			 
5f89				       NEXTW 
5f89 c3 39 24			jp macro_next 
5f8c				endm 
# End of macro NEXTW
5f8c			.V1S: 
5f8c				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5f8c 7a				db WORD_SYS_CORE+102             
5f8d a4 5f			dw .V1Q            
5f8f 04				db 3 + 1 
5f90 .. 00			db "V1!",0              
5f94				endm 
# End of macro CWHEAD
5f94			;| V1! ( u1 -- )  Store value to v1 | DONE 
5f94					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5f94 cd 4d 22			call macro_dsp_valuehl 
5f97				endm 
# End of macro FORTH_DSP_VALUEHL
5f97			 
5f97 11 5f f9				ld de, cli_var_array+2 
5f9a				 
5f9a eb					ex de, hl 
5f9b 73					ld (hl), e 
5f9c 23					inc hl 
5f9d 72					ld (hl), d 
5f9e			 
5f9e					; destroy value TOS 
5f9e			 
5f9e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5f9e cd 05 23			call macro_forth_dsp_pop 
5fa1				endm 
# End of macro FORTH_DSP_POP
5fa1				       NEXTW 
5fa1 c3 39 24			jp macro_next 
5fa4				endm 
# End of macro NEXTW
5fa4			.V1Q: 
5fa4				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5fa4 7b				db WORD_SYS_CORE+103             
5fa5 b5 5f			dw .V2S            
5fa7 04				db 3 + 1 
5fa8 .. 00			db "V1@",0              
5fac				endm 
# End of macro CWHEAD
5fac			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5fac 2a 5f f9				ld hl, (cli_var_array+2) 
5faf cd 48 20				call forth_push_numhl 
5fb2				       NEXTW 
5fb2 c3 39 24			jp macro_next 
5fb5				endm 
# End of macro NEXTW
5fb5			.V2S: 
5fb5				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5fb5 7c				db WORD_SYS_CORE+104             
5fb6 cd 5f			dw .V2Q            
5fb8 04				db 3 + 1 
5fb9 .. 00			db "V2!",0              
5fbd				endm 
# End of macro CWHEAD
5fbd			;| V2! ( u1 -- )  Store value to v2 | DONE 
5fbd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5fbd cd 4d 22			call macro_dsp_valuehl 
5fc0				endm 
# End of macro FORTH_DSP_VALUEHL
5fc0			 
5fc0 11 61 f9				ld de, cli_var_array+4 
5fc3				 
5fc3 eb					ex de, hl 
5fc4 73					ld (hl), e 
5fc5 23					inc hl 
5fc6 72					ld (hl), d 
5fc7			 
5fc7					; destroy value TOS 
5fc7			 
5fc7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5fc7 cd 05 23			call macro_forth_dsp_pop 
5fca				endm 
# End of macro FORTH_DSP_POP
5fca				       NEXTW 
5fca c3 39 24			jp macro_next 
5fcd				endm 
# End of macro NEXTW
5fcd			.V2Q: 
5fcd				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5fcd 7d				db WORD_SYS_CORE+105             
5fce de 5f			dw .V3S            
5fd0 04				db 3 + 1 
5fd1 .. 00			db "V2@",0              
5fd5				endm 
# End of macro CWHEAD
5fd5			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5fd5 2a 61 f9				ld hl, (cli_var_array+4) 
5fd8 cd 48 20				call forth_push_numhl 
5fdb				       NEXTW 
5fdb c3 39 24			jp macro_next 
5fde				endm 
# End of macro NEXTW
5fde			.V3S: 
5fde				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5fde 7c				db WORD_SYS_CORE+104             
5fdf f6 5f			dw .V3Q            
5fe1 04				db 3 + 1 
5fe2 .. 00			db "V3!",0              
5fe6				endm 
# End of macro CWHEAD
5fe6			;| V3! ( u1 -- )  Store value to v3 | DONE 
5fe6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5fe6 cd 4d 22			call macro_dsp_valuehl 
5fe9				endm 
# End of macro FORTH_DSP_VALUEHL
5fe9			 
5fe9 11 63 f9				ld de, cli_var_array+6 
5fec				 
5fec eb					ex de, hl 
5fed 73					ld (hl), e 
5fee 23					inc hl 
5fef 72					ld (hl), d 
5ff0			 
5ff0					; destroy value TOS 
5ff0			 
5ff0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ff0 cd 05 23			call macro_forth_dsp_pop 
5ff3				endm 
# End of macro FORTH_DSP_POP
5ff3				       NEXTW 
5ff3 c3 39 24			jp macro_next 
5ff6				endm 
# End of macro NEXTW
5ff6			.V3Q: 
5ff6				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5ff6 7d				db WORD_SYS_CORE+105             
5ff7 07 60			dw .END            
5ff9 04				db 3 + 1 
5ffa .. 00			db "V3@",0              
5ffe				endm 
# End of macro CWHEAD
5ffe			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5ffe 2a 63 f9				ld hl, (cli_var_array+6) 
6001 cd 48 20				call forth_push_numhl 
6004				       NEXTW 
6004 c3 39 24			jp macro_next 
6007				endm 
# End of macro NEXTW
6007			 
6007			 
6007			 
6007			 
6007			 
6007			; end of dict marker 
6007			 
6007 00			.END:    db WORD_SYS_END 
6008 00 00			dw 0 
600a 00				db 0 
600b			 
600b			; use to jp here for user dict words to save on macro expansion  
600b			 
600b			user_dict_next: 
600b				NEXTW 
600b c3 39 24			jp macro_next 
600e				endm 
# End of macro NEXTW
600e			 
600e			 
600e			user_exec: 
600e				;    ld hl, <word code> 
600e				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
600e				;    call forthexec 
600e				;    jp user_dict_next   (NEXT) 
600e			        ;    <word code bytes> 
600e eb				ex de, hl 
600f 2a f7 f3			ld hl,(os_tok_ptr) 
6012				 
6012				FORTH_RSP_NEXT 
6012 cd ef 1f			call macro_forth_rsp_next 
6015				endm 
# End of macro FORTH_RSP_NEXT
6015			 
6015			if DEBUG_FORTH_UWORD 
6015						DMARK "UEX" 
6015 f5				push af  
6016 3a 2a 60			ld a, (.dmark)  
6019 32 a0 fd			ld (debug_mark),a  
601c 3a 2b 60			ld a, (.dmark+1)  
601f 32 a1 fd			ld (debug_mark+1),a  
6022 3a 2c 60			ld a, (.dmark+2)  
6025 32 a2 fd			ld (debug_mark+2),a  
6028 18 03			jr .pastdmark  
602a ..			.dmark: db "UEX"  
602d f1			.pastdmark: pop af  
602e			endm  
# End of macro DMARK
602e				CALLMONITOR 
602e cd aa fd			call debug_vector  
6031				endm  
# End of macro CALLMONITOR
6031			endif 
6031			 
6031			 
6031			 
6031 eb				ex de, hl 
6032 22 f7 f3			ld (os_tok_ptr), hl 
6035				 
6035				; Don't use next - Skips the first word in uword. 
6035			 
6035 c3 c2 24			jp exec1 
6038			;	NEXT 
6038			 
6038			 
6038			; eof 
# End of file forth_wordsv4.asm
6038			endif 
6038			;;;;;;;;;;;;;; Debug code 
6038			 
6038			 
6038			;if DEBUG_FORTH_PARSE 
6038 .. 00		.nowordfound: db "No match",0 
6041 .. 00		.compword:	db "Comparing word ",0 
6051 .. 00		.nextwordat:	db "Next word at",0 
605e .. 00		.charmatch:	db "Char match",0 
6069			;endif 
6069			if DEBUG_FORTH_JP 
6069			.foundword:	db "Word match. Exec..",0 
6069			endif 
6069			;if DEBUG_FORTH_PUSH 
6069 .. 00		.enddict:	db "Dict end. Push.",0 
6079 .. 00		.push_str:	db "Pushing string",0 
6088 .. 00		.push_num:	db "Pushing number",0 
6097 .. 00		.data_sp:	db "SP:",0 
609b .. 00		.wordinhl:	db "Word in HL (2/0):",0 
60ad .. 00		.wordinde:	db "Word in DE (3/0):",0 
60bf .. 00		.wordinbc:	db "Word in BC (4/0):",0 
60d1			;endif 
60d1			;if DEBUG_FORTH_MALLOC 
60d1 .. 00		.push_malloc:	db "Malloc address",0 
60e0			;endif 
60e0			 
60e0			 
60e0			 
60e0			; display malloc address and current data stack pointer  
60e0			 
60e0			malloc_error: 
60e0 d5				push de 
60e1 f5				push af 
60e2 e5				push hl 
60e3 cd aa 0d			call clear_display 
60e6 11 06 61			ld de, .mallocerr 
60e9 3e 00			ld a,0 
60eb			;	ld de,os_word_scratch 
60eb cd bd 0d			call str_at_display 
60ee 3e 11			ld a, display_row_1+17 
60f0 11 a0 fd			ld de, debug_mark 
60f3 cd bd 0d			call str_at_display 
60f6 cd cd 0d			call update_display 
60f9				;call break_point_state 
60f9 cd eb 75			call cin_wait 
60fc			 
60fc			;	ld a, ' ' 
60fc			;	ld (os_view_disable), a 
60fc cd 49 19			call bp_on 
60ff e1				pop hl 
6100 f1				pop af 
6101 d1				pop de	 
6102				CALLMONITOR 
6102 cd aa fd			call debug_vector  
6105				endm  
# End of macro CALLMONITOR
6105 c9				ret 
6106			 
6106 .. 00		.mallocerr: 	db "Malloc Error",0 
6113			;if DEBUG_FORTH_PUSH 
6113			display_data_sp: 
6113 f5				push af 
6114			 
6114				; see if disabled 
6114			 
6114			 
6114 3a aa fd			ld a, (debug_vector) 
6117 fe c9			cp $C9  ; RET 
6119				;ld a, (os_view_disable) 
6119				;cp '*' 
6119 28 67			jr z, .skipdsp 
611b			 
611b e5				push hl 
611c e5				push hl 
611d e5			push hl 
611e cd aa 0d			call clear_display 
6121 e1			pop hl 
6122 7c				ld a,h 
6123 21 fb f3			ld hl, os_word_scratch 
6126 cd e7 11			call hexout 
6129 e1				pop hl 
612a 7d				ld a,l 
612b 21 fd f3			ld hl, os_word_scratch+2 
612e cd e7 11			call hexout 
6131 21 ff f3			ld hl, os_word_scratch+4 
6134 3e 00			ld a,0 
6136 77				ld (hl),a 
6137 11 fb f3			ld de,os_word_scratch 
613a 3e 28				ld a, display_row_2 
613c cd bd 0d				call str_at_display 
613f 11 9b 60			ld de, .wordinhl 
6142 3e 00			ld a, display_row_1 
6144			 
6144 cd bd 0d				call str_at_display 
6147 11 a0 fd			ld de, debug_mark 
614a 3e 11			ld a, display_row_1+17 
614c			 
614c cd bd 0d				call str_at_display 
614f			 
614f				; display current data stack pointer 
614f 11 97 60			ld de,.data_sp 
6152 3e 30				ld a, display_row_2 + 8 
6154 cd bd 0d				call str_at_display 
6157			 
6157 2a 23 f9			ld hl,(cli_data_sp) 
615a e5				push hl 
615b 7c				ld a,h 
615c 21 fb f3			ld hl, os_word_scratch 
615f cd e7 11			call hexout 
6162 e1				pop hl 
6163 7d				ld a,l 
6164 21 fd f3			ld hl, os_word_scratch+2 
6167 cd e7 11			call hexout 
616a 21 ff f3			ld hl, os_word_scratch+4 
616d 3e 00			ld a,0 
616f 77				ld (hl),a 
6170 11 fb f3			ld de,os_word_scratch 
6173 3e 33				ld a, display_row_2 + 11 
6175 cd bd 0d				call str_at_display 
6178			 
6178			 
6178 cd cd 0d			call update_display 
617b cd ed 0c			call delay1s 
617e cd ed 0c			call delay1s 
6181 e1				pop hl 
6182			.skipdsp: 
6182 f1				pop af 
6183 c9				ret 
6184			 
6184			display_data_malloc: 
6184			 
6184 f5				push af 
6185 e5				push hl 
6186 e5				push hl 
6187 e5			push hl 
6188 cd aa 0d			call clear_display 
618b e1			pop hl 
618c 7c				ld a,h 
618d 21 fb f3			ld hl, os_word_scratch 
6190 cd e7 11			call hexout 
6193 e1				pop hl 
6194 7d				ld a,l 
6195 21 fd f3			ld hl, os_word_scratch+2 
6198 cd e7 11			call hexout 
619b 21 ff f3			ld hl, os_word_scratch+4 
619e 3e 00			ld a,0 
61a0 77				ld (hl),a 
61a1 11 fb f3			ld de,os_word_scratch 
61a4 3e 28				ld a, display_row_2 
61a6 cd bd 0d				call str_at_display 
61a9 11 d1 60			ld de, .push_malloc 
61ac 3e 00			ld a, display_row_1 
61ae			 
61ae cd bd 0d				call str_at_display 
61b1			 
61b1				; display current data stack pointer 
61b1 11 97 60			ld de,.data_sp 
61b4 3e 30				ld a, display_row_2 + 8 
61b6 cd bd 0d				call str_at_display 
61b9			 
61b9 2a 23 f9			ld hl,(cli_data_sp) 
61bc e5				push hl 
61bd 7c				ld a,h 
61be 21 fb f3			ld hl, os_word_scratch 
61c1 cd e7 11			call hexout 
61c4 e1				pop hl 
61c5 7d				ld a,l 
61c6 21 fd f3			ld hl, os_word_scratch+2 
61c9 cd e7 11			call hexout 
61cc 21 ff f3			ld hl, os_word_scratch+4 
61cf 3e 00			ld a,0 
61d1 77				ld (hl),a 
61d2 11 fb f3			ld de,os_word_scratch 
61d5 3e 33				ld a, display_row_2 + 11 
61d7 cd bd 0d				call str_at_display 
61da			 
61da cd cd 0d			call update_display 
61dd cd ed 0c			call delay1s 
61e0 cd ed 0c			call delay1s 
61e3 e1				pop hl 
61e4 f1				pop af 
61e5 c9				ret 
61e6			;endif 
61e6			 
61e6			include "forth_autostart.asm" 
61e6			; list of commands to perform at system start up 
61e6			 
61e6			startcmds: 
61e6			;	dw test11 
61e6			;	dw test12 
61e6			;	dw test13 
61e6			;	dw test14 
61e6			;	dw test15 
61e6			;	dw test16 
61e6			;	dw test17 
61e6			;	dw ifthtest1 
61e6			;	dw ifthtest2 
61e6			;	dw ifthtest3 
61e6			;	dw mmtest1 
61e6			;	dw mmtest2 
61e6			;	dw mmtest3 
61e6			;	dw mmtest4 
61e6			;	dw mmtest5 
61e6			;	dw mmtest6 
61e6			;	dw iftest1 
61e6			;	dw iftest2 
61e6			;	dw iftest3 
61e6			;	dw looptest1 
61e6			;	dw looptest2 
61e6			;	dw test1 
61e6			;	dw test2 
61e6			;	dw test3 
61e6			;	dw test4 
61e6			;	dw game2r 
61e6			;	dw game2b1 
61e6			;	dw game2b2 
61e6			 
61e6				; start up words that are actually useful 
61e6			 
61e6			;    dw spi1 
61e6			;    dw spi2 
61e6			;    dw spi3 
61e6			;    dw spi4 
61e6			;    dw spi5 
61e6			;    dw spi6 
61e6			;    dw spi7 
61e6			; 
61e6			;    dw spi8 
61e6			;    dw spi9 
61e6			;    dw spi10 
61e6			 
61e6			; file editor 
61e6			;	dw edit1 
61e6			;	dw edit2 
61e6			;	dw edit3 
61e6			 
61e6			;	dw longread 
61e6 08 66			dw clrstack 
61e8 3c 66			dw type 
61ea			;	dw stest 
61ea 61 66			dw strncpy 
61ec d1 67			dw list 
61ee c2 66			dw start1 
61f0 d2 66			dw start2 
61f2			;	dw start3 
61f2			;	dw start3b 
61f2			;	dw start3c 
61f2			 
61f2				; (unit) testing words 
61f2			 
61f2			;	dw mtesta 
61f2			;	dw mtestb 
61f2			;	dw mtestc 
61f2			;	dw mtestd 
61f2			;	dw mteste 
61f2			 
61f2				; demo/game words 
61f2			 
61f2			;        dw game3w 
61f2			;        dw game3p 
61f2			;        dw game3sc 
61f2			;        dw game3vsi 
61f2			;        dw game3vs 
61f2				 
61f2			;	dw game2b 
61f2			;	dw game2bf 
61f2			;	dw game2mba 
61f2			;	dw game2mbas 
61f2			;	dw game2mb 
61f2			 
61f2 02 6a			dw game1 
61f4 13 6a			dw game1a 
61f6 75 6a			dw game1b 
61f8 aa 6a			dw game1c 
61fa e0 6a			dw game1d 
61fc 11 6b			dw game1s 
61fe 25 6b			dw game1t 
6200 3a 6b			dw game1f 
6202 6e 6b			dw game1z 
6204 b2 6b			dw game1zz 
6206			 
6206 3b 68			dw test5 
6208 73 68			dw test6 
620a ab 68			dw test7 
620c bf 68			dw test8 
620e eb 68			dw test9 
6210 01 69			dw test10 
6212				 
6212 89 6c		        dw ssv5 
6214 6d 6c		        dw ssv4 
6216 51 6c		        dw ssv3 
6218 1b 6c		        dw ssv2 
621a a2 6c		        dw ssv1 
621c ea 6c		        dw ssv1cpm 
621e			;	dw keyup 
621e			;	dw keydown 
621e			;	dw keyleft 
621e			;	dw keyright 
621e			;	dw 	keyf1 
621e			;	dw keyf2 
621e			;	dw keyf3 
621e			;	dw keyf4 
621e			;	dw keyf5 
621e			;	dw keyf6 
621e			;	dw keyf7 
621e			;	dw keyf8 
621e			;	dw keyf9 
621e			;	dw keyf10 
621e			;	dw keyf11 
621e			;	dw keyf12 
621e			;	dw keytab 
621e			;	dw keycr 
621e			;	dw keyhome 
621e			;	dw keyend 
621e			;	dw keybs 
621e 00 00			db 0, 0	 
6220			 
6220			 
6220			; File Editor 
6220			 
6220			; ( id - ) use 'e' to edit the displayed line 
6220 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
6241 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
6276			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
6276 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
62ae			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
62ae			 
62ae			; SPI Net support words 
62ae			 
62ae			; v0! = node to send to 
62ae			; ( str count - ) 
62ae .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
6307			 
6307			; spiputc ( char node - ) 
6307 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
633b			; spiputc ( u node - ) 
633b .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
6369			 
6369			; spigetc ( - n ) 
6369 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
6392			 
6392			; getnode ( - n ) 
6392 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
63bf			 
63bf			; ( str node - )  
63bf .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
6425			; store string ( str i - ) 
6425			 
6425			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
6425 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
647a			 
647a			; get string ( addr i -  )    TO FIX 
647a			 
647a .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
64d2			 
64d2			 
64d2			; NETCHAT (TODO) 
64d2			; Program to allow two nodes to chat with eachother 
64d2			; 
64d2			; v0 - target node 
64d2			;  
64d2			; accept input at 0,0 
64d2			; if input is string send spitype to target node 
64d2			; starting at row 2,0 , while spigetchr is not zero ->  
64d2			; 
64d2			; 
64d2			; TODO add paging of get request 
64d2			 
64d2			; ( node - ) 
64d2 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
64f1 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
6549 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
65c1			 
65c1			 
65c1			; Long read of currently open file 
65c1 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
6608			 
6608			; clear stack  
6608			 
6608 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
663c			 
663c			; type ( addr count - ) 
663c .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6661			 
6661			; some direct memory words 
6661			; strncpy ( len t f -- t ) 
6661			 
6661 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
66c2			 
66c2 .. 00		start1:     	db ": bpon $00 bp ;",0 
66d2 .. 00		start2:     	db ": bpoff $01 bp ;",0 
66e3 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
675e .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
67be			 
67be .. 00		tuck:         db ": tuck swap over ;", 0 
67d1			 
67d1			; a handy word to list items on the stack 
67d1			 
67d1 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
683b			 
683b			 
683b			; test stack  
683b			; rnd8 stest 
683b			 
683b			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
683b			 
683b			; random malloc and free cycles 
683b			 
683b			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
683b			 
683b			; fixed malloc and free cycles 
683b			 
683b			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
683b			 
683b			; fixed double string push and drop cycle  
683b			 
683b			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
683b			 
683b			; consistent fixed string push and drop cycle  
683b			 
683b			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
683b			 
683b			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
683b			 
683b			;test1:		db ": aa 1 2 3 ;", 0 
683b			;test2:     	db "111 aa 888 999",0 
683b			;test3:     	db ": bb 77 ;",0 
683b			;test4:     	db "$02 $01 do i . loop bb",0 
683b			 
683b .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6873 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
68ab .. 00		test7:     	db ": box hline vline ;",0 
68bf .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
68eb .. 00		test9:     	db ": sw $01 adsp world ;",0 
6901 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6926			;test11:     	db "hello create .",0 
6926			;test12:     	db "hello2 create .",0 
6926			 
6926			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6926			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6926			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6926			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6926			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6926			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6926			 
6926			;iftest1:     	db "$0001 IF cls .",0 
6926			;iftest2:     	db "$0000 IF cls .",0 
6926			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6926			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6926			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6926			 
6926			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6926			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6926			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6926			 
6926			 
6926 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
694a .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
697a .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
699f .. 00		sound4: db ": cha $00 ; ",0 
69ac .. 00		sound5: db ": chb $20 ; ",0 
69b9 .. 00		sound6: db ": chc $40 ; ",0 
69c6 .. 00		sound7: db ": chd $60 ; ",0 
69d3 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
69eb .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6a02			 
6a02			 
6a02			 
6a02			 
6a02			; a small guess the number game 
6a02			 
6a02 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6a13 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6a75			 
6a75 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6aaa .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6ae0 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6b11 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6b25 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6b3a .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6b6e .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6bb2			 
6bb2			; Using 'ga' save a high score across multiple runs using external storage 
6bb2			 
6bb2 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6c1b			 
6c1b			 
6c1b			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6c1b			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6c1b			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6c1b			 
6c1b			; simple screen saver to test code memory reuse to destruction 
6c1b			 
6c1b .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6c51 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6c6d .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6c89 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6ca2 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6cea .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6d41			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6d41			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6d41			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6d41			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6d41			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6d41			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6d41			 
6d41			 
6d41			 
6d41			; minesweeper/battleship finding game 
6d41			; draws a game board of random ship/mine positions 
6d41			; user enters coords to see if it hits on 
6d41			; game ends when all are hit 
6d41			; when hit or miss says how many may be in the area 
6d41			 
6d41			; setup the game board and then hide it 
6d41			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6d41			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6d41			;; prompt for where to target 
6d41			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6d41			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6d41			;; TODO see if the entered coords hits or misses pushes char hit of miss 
6d41			;game2mbht:      db ": mbckht nop ;",0 
6d41			;game2mbms:      db ": mbcms nop ;",0 
6d41			; TODO how many might be near by 
6d41			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6d41			 
6d41			; Game 3 
6d41			 
6d41			; Vert scroller ski game - avoid the trees! 
6d41			 
6d41			; v0 score (ie turns) 
6d41			; v1 player pos 
6d41			; v2 left wall 
6d41			; v3 right wall 
6d41			 
6d41			; Draw side walls randomly 
6d41			 
6d41			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6d41			 
6d41			; Draw player 
6d41			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6d41			 
6d41			; TODO Get Key 
6d41			 
6d41			; TODO Move left right 
6d41			 
6d41			; scroll and move walls a bit 
6d41			 
6d41			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6d41			 
6d41			; main game loop 
6d41			 
6d41			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6d41			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6d41			 
6d41			; key board defs 
6d41			 
6d41 .. 00		keyup:       db ": keyup $05 ;",0 
6d4f .. 00		keydown:       db ": keydown $0a ;",0 
6d5f .. 00		keyleft:       db ": keyleft $0b ;",0 
6d6f .. 00		keyright:       db ": keyright $0c ;",0 
6d80 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6d8e .. 00		keyf2:       db ": keyf2 $11 ;",0 
6d9c .. 00		keyf3:       db ": keyf3 $12 ;",0 
6daa .. 00		keyf4:       db ": keyf4 $13 ;",0 
6db8 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6dc6 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6dd4 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6de2 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6df0 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6dfe .. 00		keyf10:       db ": keyf10 $19 ;",0 
6e0d .. 00		keyf11:       db ": keyf11 $1a ;",0 
6e1c .. 00		keyf12:       db ": keyf12 $1b ;",0 
6e2b			 
6e2b .. 00		keytab:       db ": keytab $09 ;",0 
6e3a .. 00		keycr:       db ": keycr $0d ;",0 
6e48 .. 00		keyhome:       db ": keyhome $0e ;",0 
6e58 .. 00		keyend:       db ": keyend $0f ;",0 
6e67 .. 00		keybs:       db ": keybs $08 ;",0 
6e75			 
6e75			   
6e75			 
6e75			 
6e75			 
6e75			; eof 
# End of file forth_autostart.asm
6e75			 
6e75			 
6e75			 
6e75			; stack over and underflow checks 
6e75			 
6e75			; init the words to detect the under/overflow 
6e75			 
6e75			chk_stk_init: 
6e75				; a vague random number to check so we dont get any "lucky" hits 
6e75 3e 2d			ld a, 45 
6e77 6f				ld l, a 
6e78 00				nop 
6e79 3e 17			ld a, 23 
6e7b 67				ld h, a 
6e7c			 
6e7c 22 d2 f0			ld (chk_word), hl     ; the word we need to check against 
6e7f			 
6e7f			;	ld (chk_stund), hl	; stack points.... 
6e7f 22 3b fe			ld (chk_stovr), hl 
6e82 22 21 f9			ld (chk_ret_und), hl 
6e85 22 df f8			ld (chk_ret_ovr), hl 
6e88 22 5d f8			ld (chk_loop_ovr), hl 
6e8b 22 5b f6			ld (chk_data_ovr), hl 
6e8e c9				ret 
6e8f				 
6e8f			check_stacks: 
6e8f				; check all stack words 
6e8f			 
6e8f e5				push hl 
6e90 d5				push de 
6e91			 
6e91			;	ld de,(chk_word) 
6e91			;	ld hl, (chk_stund)	; stack points.... 
6e91			;	if DEBUG_STK_FAULT 
6e91			;		DMARK "FAa" 
6e91			;		CALLMONITOR 
6e91			;	endif 
6e91			;	call cmp16 
6e91			;	jp z, .chk_faulta 
6e91			; 
6e91			;	ld de, sfaultsu 
6e91			;	jp .chk_fault 
6e91			 
6e91 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
6e94 ed 5b d2 f0		ld de,(chk_word) 
6e98				if DEBUG_STK_FAULT 
6e98					DMARK "FAb" 
6e98					CALLMONITOR 
6e98				endif 
6e98 cd fc 0f			call cmp16 
6e9b 28 06			jr z, .chk_fault1 
6e9d 11 41 6f			ld de, sfaultso 
6ea0 c3 f2 6e			jp .chk_fault 
6ea3			.chk_fault1:  
6ea3 2a 21 f9			ld hl, (chk_ret_und) 
6ea6 ed 5b d2 f0		ld de,(chk_word) 
6eaa				if DEBUG_STK_FAULT 
6eaa					DMARK "FAU" 
6eaa					CALLMONITOR 
6eaa				endif 
6eaa cd fc 0f			call cmp16 
6ead ca b6 6e			jp z, .chk_fault2 
6eb0 11 51 6f			ld de, sfaultru 
6eb3 c3 f2 6e			jp .chk_fault 
6eb6			.chk_fault2:  
6eb6 2a df f8			ld hl, (chk_ret_ovr) 
6eb9 ed 5b d2 f0		ld de,(chk_word) 
6ebd				if DEBUG_STK_FAULT 
6ebd					DMARK "FA1" 
6ebd					CALLMONITOR 
6ebd				endif 
6ebd cd fc 0f			call cmp16 
6ec0 ca c9 6e			jp z, .chk_fault3 
6ec3 11 5f 6f			ld de, sfaultro 
6ec6 c3 f2 6e			jp .chk_fault 
6ec9			.chk_fault3:  
6ec9 2a 5d f8			ld hl, (chk_loop_ovr) 
6ecc ed 5b d2 f0		ld de,(chk_word) 
6ed0				if DEBUG_STK_FAULT 
6ed0					DMARK "FA2" 
6ed0					CALLMONITOR 
6ed0				endif 
6ed0 cd fc 0f			call cmp16 
6ed3 ca dc 6e			jp z, .chk_fault4 
6ed6 11 79 6f			ld de, sfaultlo 
6ed9 c3 f2 6e			jp .chk_fault 
6edc			.chk_fault4:  
6edc 2a 5b f6			ld hl, (chk_data_ovr) 
6edf ed 5b d2 f0		ld de,(chk_word) 
6ee3				if DEBUG_STK_FAULT 
6ee3					DMARK "FA3" 
6ee3					CALLMONITOR 
6ee3				endif 
6ee3 cd fc 0f			call cmp16 
6ee6 ca ef 6e			jp z, .chk_fault5 
6ee9 11 93 6f			ld de, sfaultdo 
6eec c3 f2 6e			jp .chk_fault 
6eef			 
6eef			 
6eef			.chk_fault5:  
6eef d1				pop de 
6ef0 e1				pop hl 
6ef1			 
6ef1 c9				ret 
6ef2			 
6ef2 cd aa 0d		.chk_fault: 	call clear_display 
6ef5 3e 28				ld a, display_row_2 
6ef7 cd bd 0d				call str_at_display 
6efa 11 23 6f				   ld de, .stackfault 
6efd 3e 00				ld a, display_row_1 
6eff cd bd 0d				call str_at_display 
6f02 11 a0 fd				    ld de, debug_mark 
6f05 3e 11				ld a, display_row_1+17 
6f07 cd bd 0d				call str_at_display 
6f0a cd cd 0d				call update_display 
6f0d			 
6f0d				; prompt before entering montior for investigating issue 
6f0d			 
6f0d 3e 78			ld a, display_row_4 
6f0f 11 26 1d			ld de, endprog 
6f12			 
6f12 cd cd 0d			call update_display		 
6f15			 
6f15 cd c0 1f			call next_page_prompt 
6f18			 
6f18 d1				pop de 
6f19 e1				pop hl 
6f1a cd 7a 1d				call monitor 
6f1d cd df 23				call forth_warmstart 
6f20 c3 76 1c				jp warmstart_afterauto 
6f23					;jp 0 
6f23					;halt 
6f23			 
6f23			 
6f23			 
6f23 .. 00		.stackfault: 	db "Stack fault:",0 
6f30			 
6f30 .. 00		sfaultsu: 	db	"Stack under flow",0 
6f41 .. 00		sfaultso: 	db	"Stack over flow",0 
6f51 .. 00		sfaultru:	db "RTS underflow",0 
6f5f .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6f79 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6f93 .. 00		sfaultdo:	db "DTS overflow", 0 
6fa0			 
6fa0			 
6fa0			fault_dsp_under: 
6fa0 11 b2 6f			ld de, .dsp_under 
6fa3 c3 68 70			jp .show_fault 
6fa6			 
6fa6			fault_rsp_under: 
6fa6 11 c0 6f			ld de, .rsp_under 
6fa9 c3 68 70			jp .show_fault 
6fac			fault_loop_under: 
6fac 11 ce 6f			ld de, .loop_under 
6faf c3 68 70			jp .show_fault 
6fb2			 
6fb2 .. 00		.dsp_under: db "DSP Underflow",0 
6fc0 .. 00		.rsp_under: db "RSP Underflow",0 
6fce .. 00		.loop_under: db "LOOP Underflow",0 
6fdd			 
6fdd			 
6fdd d5			type_faultn: 	push de 
6fde e5					push hl 
6fdf cd aa 0d				call clear_display 
6fe2 11 0c 70				   ld de, .typefaultn 
6fe5 3e 00				ld a, display_row_1 
6fe7 cd bd 0d				call str_at_display 
6fea 11 a0 fd				    ld de, debug_mark 
6fed 3e 11				ld a, display_row_1+17 
6fef cd bd 0d				call str_at_display 
6ff2 cd cd 0d				call update_display 
6ff5			 
6ff5				; prompt before entering montior for investigating issue 
6ff5			 
6ff5 3e 78			ld a, display_row_4 
6ff7 11 26 1d			ld de, endprog 
6ffa			 
6ffa cd cd 0d			call update_display		 
6ffd			 
6ffd cd c0 1f			call next_page_prompt 
7000			 
7000 e5					push hl 
7001 d5					push de 
7002 cd 7a 1d				call monitor 
7005 cd df 23				call forth_warmstart 
7008 c3 76 1c				jp warmstart_afterauto 
700b 76					halt 
700c			 
700c			 
700c .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
7023			 
7023 d5			type_faults: 	push de 
7024 e5					push hl 
7025 cd aa 0d				call clear_display 
7028 11 51 70				   ld de, .typefaults 
702b 3e 00				ld a, display_row_1 
702d cd bd 0d				call str_at_display 
7030 11 a0 fd				    ld de, debug_mark 
7033 3e 11				ld a, display_row_1+17 
7035 cd bd 0d				call str_at_display 
7038 cd cd 0d				call update_display 
703b			 
703b				; prompt before entering montior for investigating issue 
703b			 
703b 3e 78			ld a, display_row_4 
703d 11 26 1d			ld de, endprog 
7040			 
7040 cd cd 0d			call update_display		 
7043			 
7043 cd c0 1f			call next_page_prompt 
7046			 
7046 e1					pop hl 
7047 d1					pop de 
7048 cd 7a 1d				call monitor 
704b cd df 23				call forth_warmstart 
704e c3 76 1c				jp warmstart_afterauto 
7051			 
7051			 
7051 .. 00		.typefaults: db "STR Type Expected TOS!",0 
7068			 
7068			.show_fault: 	 
7068 d5					push de 
7069 cd aa 0d				call clear_display 
706c d1					pop de 
706d 3e 00				ld a, display_row_1 
706f cd bd 0d				call str_at_display 
7072 11 a0 fd				    ld de, debug_mark 
7075 3e 11				ld a, display_row_1+17 
7077 cd bd 0d				call str_at_display 
707a cd cd 0d				call update_display 
707d			 
707d				; prompt before entering montior for investigating issue 
707d			 
707d 3e 78			ld a, display_row_4 
707f 11 26 1d			ld de, endprog 
7082			 
7082 cd cd 0d			call update_display		 
7085			 
7085 cd c0 1f			call next_page_prompt 
7088			 
7088 e1					pop hl 
7089 d1					pop de 
708a cd 7a 1d				call monitor 
708d			; do a dump to cli and not warmstart so we preserve all of the uwords.  
708d			; TODO Make optional fault restart to cli or warm boot? 
708d					;jp warmstart 
708d c3 ba 1c				jp cli 
7090 76					halt 
7091			 
7091			 
7091			; handle the auto run of code from files in storage 
7091			 
7091			 
7091			include "forth_startup.asm" 
7091			; Which startup method to use? 
7091			; 
7091			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
7091			; followed by loading of a list of scripts in eeprom 
7091			 
7091			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
7091			; from eeprom 
7091			 
7091			; Select with define in main stubs 
7091			 
7091			if STARTUP_V1 
7091				include "forth_startupv1.asm" 
7091			endif 
7091			if STARTUP_V2 
7091				include "forth_startupv2.asm" 
7091			; Version 2 of the startup  
7091			;  
7091			; Auto load any files in bank 1 that start with a '*' 
7091			; If no se storage then revert to using eprom 
7091			 
7091			 
7091			if STORAGE_SE = 0 
7091			 
7091			sprompt1: db "Startup load...",0 
7091			sprompt2: db "Run? 1=No *=End #=All",0 
7091			 
7091			 
7091			 
7091			 
7091			forth_startup: 
7091				ld hl, startcmds 
7091				ld a, 0 
7091				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
7091			 
7091			.start1:	push hl 
7091				call clear_display 
7091				ld de, sprompt1 
7091			        ld a, display_row_1 
7091				call str_at_display 
7091				ld de, sprompt2 
7091			        ld a, display_row_2 
7091				call str_at_display 
7091				pop hl 
7091				push hl 
7091				ld e,(hl) 
7091				inc hl 
7091				ld d,(hl) 
7091			        ld a, display_row_3 
7091				call str_at_display 
7091				call update_display 
7091			 
7091			 
7091				ld a, (os_last_cmd) 
7091				cp 0 
7091				jr z, .startprompt 
7091				call delay250ms 
7091				jr .startdo 
7091				 
7091				 
7091			 
7091			.startprompt: 
7091			 
7091				ld a,display_row_4 + display_cols - 1 
7091			        ld de, endprg 
7091				call str_at_display 
7091				call update_display 
7091				call delay1s 
7091				call cin_wait 
7091						 
7091				cp '*' 
7091				jr z, .startupend1 
7091				cp '#' 
7091				jr nz, .startno 
7091				ld a, 1 
7091				ld (os_last_cmd),a 
7091				jr .startdo 
7091			.startno:	cp '1' 
7091				jr z,.startnxt  
7091			 
7091				; exec startup line 
7091			.startdo:	 
7091				pop hl 
7091				push hl 
7091				 
7091				ld e,(hl) 
7091				inc hl 
7091				ld d,(hl) 
7091				ex de,hl 
7091			 
7091				push hl 
7091			 
7091				ld a, 0 
7091				;ld a, FORTH_END_BUFFER 
7091				call strlent 
7091				inc hl   ; include zero term to copy 
7091				ld b,0 
7091				ld c,l 
7091				pop hl 
7091				ld de, scratch 
7091				ldir 
7091			 
7091			 
7091				ld hl, scratch 
7091				call forthparse 
7091				call forthexec 
7091				call forthexec_cleanup 
7091			 
7091				ld a, display_row_4 
7091				ld de, endprog 
7091			 
7091				call update_display		 
7091			 
7091				ld a, (os_last_cmd) 
7091				cp 0 
7091				jr nz, .startnxt 
7091				call next_page_prompt 
7091			        call clear_display 
7091				call update_display		 
7091			 
7091				; move onto next startup line? 
7091			.startnxt: 
7091			 
7091				call delay250ms 
7091				pop hl 
7091			 
7091				inc hl 
7091				inc hl 
7091			 
7091				push hl 
7091				ld e, (hl) 
7091				inc hl 
7091				ld d, (hl) 
7091				pop hl 
7091				; TODO replace 0 test 
7091			 
7091				ex de, hl 
7091				call ishlzero 
7091			;	ld a,e 
7091			;	add d 
7091			;	cp 0    ; any left to do? 
7091				ex de, hl 
7091				jp nz, .start1 
7091				jr .startupend 
7091			 
7091			.startupend1: pop hl 
7091			.startupend: 
7091			 
7091				call clear_display 
7091				call update_display 
7091				ret 
7091			endif 
7091			 
7091			 
7091			if STORAGE_SE 
7091			 
7091			;sprompt3: db "Loading from start-up file:",0 
7091 .. 00		sprompt3: db "  Searching...",0 
70a0			;sprompt4: db "(Any key to stop)",0 
70a0			 
70a0			 
70a0			forth_autoload: 
70a0			 
70a0				; load block 0 of store 1 
70a0				 
70a0 3e fe			ld a, $fe      ; bit 0 clear 
70a2 32 95 f9			ld (spi_device), a 
70a5			 
70a5 cd 25 05			call storage_get_block_0 
70a8			 
70a8 3a d0 f9			ld a, (store_page+STORE_0_AUTOFILE) 
70ab			 
70ab fe 00			cp 0 
70ad c8				ret z     ; auto start not enabled 
70ae			 
70ae cd aa 0d			call clear_display 
70b1			 
70b1				; set bank 
70b1			 
70b1 3a d2 f9				ld a, (store_page+STORE_0_BANKRUN) 
70b4 32 95 f9				ld (spi_device), a 
70b7			 
70b7			 
70b7				; generate a directory of bank 1 and search for flagged files 
70b7			 
70b7					if DEBUG_FORTH_WORDS_KEY 
70b7						DMARK "DIR" 
70b7 f5				push af  
70b8 3a cc 70			ld a, (.dmark)  
70bb 32 a0 fd			ld (debug_mark),a  
70be 3a cd 70			ld a, (.dmark+1)  
70c1 32 a1 fd			ld (debug_mark+1),a  
70c4 3a ce 70			ld a, (.dmark+2)  
70c7 32 a2 fd			ld (debug_mark+2),a  
70ca 18 03			jr .pastdmark  
70cc ..			.dmark: db "DIR"  
70cf f1			.pastdmark: pop af  
70d0			endm  
# End of macro DMARK
70d0						CALLMONITOR 
70d0 cd aa fd			call debug_vector  
70d3				endm  
# End of macro CALLMONITOR
70d3					endif 
70d3			 
70d3 cd 25 05			call storage_get_block_0 
70d6			 
70d6 21 af f9			ld hl, store_page     ; get current id count 
70d9 46				ld b, (hl) 
70da 0e 00			ld c, 0    ; count of files   
70dc					if DEBUG_FORTH_WORDS 
70dc						DMARK "DI1" 
70dc f5				push af  
70dd 3a f1 70			ld a, (.dmark)  
70e0 32 a0 fd			ld (debug_mark),a  
70e3 3a f2 70			ld a, (.dmark+1)  
70e6 32 a1 fd			ld (debug_mark+1),a  
70e9 3a f3 70			ld a, (.dmark+2)  
70ec 32 a2 fd			ld (debug_mark+2),a  
70ef 18 03			jr .pastdmark  
70f1 ..			.dmark: db "DI1"  
70f4 f1			.pastdmark: pop af  
70f5			endm  
# End of macro DMARK
70f5						CALLMONITOR 
70f5 cd aa fd			call debug_vector  
70f8				endm  
# End of macro CALLMONITOR
70f8					endif 
70f8			 
70f8				; check for empty drive 
70f8			 
70f8 3e 00			ld a, 0 
70fa b8				cp b 
70fb ca 48 71			jp z, .dirdone 
70fe			 
70fe				; for each of the current ids do a search for them and if found push to stack 
70fe			 
70fe c5			.diritem:	push bc 
70ff 21 40 00				ld hl, STORE_BLOCK_PHY 
7102 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
7104 58					ld e,b 
7105			 
7105 d5					push de 
7106 e5					push hl 
7107 cd aa 0d			call clear_display 
710a 3e 32			ld a, display_row_2 + 10 
710c 11 91 70			ld de, sprompt3 
710f cd bd 0d			call str_at_display 
7112 cd 01 0d			call active 
7115 eb				ex de, hl 
7116 3e 2f			ld a, display_row_2 + 7 
7118 cd bd 0d			call str_at_display 
711b cd cd 0d			call update_display 
711e e1				pop hl 
711f d1				pop de 
7120			 
7120			;		if DEBUG_FORTH_WORDS 
7120			;			DMARK "DI2" 
7120			;			CALLMONITOR 
7120			;		endif 
7120			 
7120 cd a7 07				call storage_findnextid 
7123			 
7123			;		if DEBUG_FORTH_WORDS 
7123			;			DMARK "DI3" 
7123			;			CALLMONITOR 
7123			;		endif 
7123			 
7123					; if found hl will be non zero 
7123			 
7123 cd 07 10				call ishlzero 
7126			;		ld a, l 
7126			;		add h 
7126			; 
7126			;		cp 0 
7126 28 1d				jr z, .dirnotfound 
7128			 
7128					; increase count 
7128			 
7128 c1					pop bc	 
7129 0c					inc c 
712a c5					push bc 
712b					 
712b			 
712b					; get file header and push the file name 
712b			 
712b 11 af f9				ld de, store_page 
712e cd 74 04				call storage_read_block 
7131			 
7131					; push file id to stack 
7131				 
7131			 
7131					; is this a file we want to run? 
7131			 
7131 21 b2 f9				ld hl, store_page+3 
7134 7e					ld a,(hl) 
7135 fe 2a				cp '*' 
7137 20 0c				jr nz,  .dirnotfound 
7139					 
7139			 
7139			 
7139 3a af f9				ld a, (store_page) 
713c d5					push de 
713d e5					push hl 
713e c5					push bc 
713f cd 6b 71				call .autorunf 
7142 c1					pop bc 
7143 e1					pop hl 
7144 d1					pop de 
7145			 
7145			 
7145			 
7145				; save this extent 
7145			 
7145					; push file name 
7145			;display file name to run 
7145			 
7145			;		ld hl, store_page+3 
7145			;		if DEBUG_FORTH_WORDS 
7145			;			DMARK "DI5" 
7145			;			CALLMONITOR 
7145			;		endif 
7145			; 
7145			;		 
7145			; 
7145			;		call forth_push_str 
7145			;		if DEBUG_FORTH_WORDS 
7145			;			DMARK "DI6" 
7145			;			CALLMONITOR 
7145			;		endif 
7145			.dirnotfound: 
7145 c1					pop bc     
7146 10 b6				djnz .diritem 
7148				 
7148			.dirdone:	 
7148					if DEBUG_FORTH_WORDS 
7148						DMARK "DI7" 
7148 f5				push af  
7149 3a 5d 71			ld a, (.dmark)  
714c 32 a0 fd			ld (debug_mark),a  
714f 3a 5e 71			ld a, (.dmark+1)  
7152 32 a1 fd			ld (debug_mark+1),a  
7155 3a 5f 71			ld a, (.dmark+2)  
7158 32 a2 fd			ld (debug_mark+2),a  
715b 18 03			jr .pastdmark  
715d ..			.dmark: db "DI7"  
7160 f1			.pastdmark: pop af  
7161			endm  
# End of macro DMARK
7161						CALLMONITOR 
7161 cd aa fd			call debug_vector  
7164				endm  
# End of macro CALLMONITOR
7164					endif 
7164			 
7164 cd aa 0d				call clear_display 
7167 cd cd 0d				call update_display 
716a			 
716a c9					ret 
716b			 
716b			 
716b			 
716b			 
716b			 
716b			.autorunf: 
716b			 
716b			 
716b				; get file id to load from and get the file name to display 
716b			 
716b			;		ld a, (store_page+STORE_0_FILERUN) 
716b			 
716b 2e 00				ld l, 0 
716d 67					ld h, a 
716e 11 af f9				ld de, store_page 
7171			 
7171					if DEBUG_FORTH_WORDS 
7171						DMARK "ASp" 
7171 f5				push af  
7172 3a 86 71			ld a, (.dmark)  
7175 32 a0 fd			ld (debug_mark),a  
7178 3a 87 71			ld a, (.dmark+1)  
717b 32 a1 fd			ld (debug_mark+1),a  
717e 3a 88 71			ld a, (.dmark+2)  
7181 32 a2 fd			ld (debug_mark+2),a  
7184 18 03			jr .pastdmark  
7186 ..			.dmark: db "ASp"  
7189 f1			.pastdmark: pop af  
718a			endm  
# End of macro DMARK
718a						CALLMONITOR 
718a cd aa fd			call debug_vector  
718d				endm  
# End of macro CALLMONITOR
718d					endif 
718d cd cd 09				call storage_read 
7190			 
7190					if DEBUG_FORTH_WORDS 
7190						DMARK "ASr" 
7190 f5				push af  
7191 3a a5 71			ld a, (.dmark)  
7194 32 a0 fd			ld (debug_mark),a  
7197 3a a6 71			ld a, (.dmark+1)  
719a 32 a1 fd			ld (debug_mark+1),a  
719d 3a a7 71			ld a, (.dmark+2)  
71a0 32 a2 fd			ld (debug_mark+2),a  
71a3 18 03			jr .pastdmark  
71a5 ..			.dmark: db "ASr"  
71a8 f1			.pastdmark: pop af  
71a9			endm  
# End of macro DMARK
71a9						CALLMONITOR 
71a9 cd aa fd			call debug_vector  
71ac				endm  
# End of macro CALLMONITOR
71ac					endif 
71ac			 
71ac cd 07 10				call ishlzero 
71af c8					ret z             ; file not found 
71b0			 
71b0					; display file name we are loading 
71b0			 
71b0 cd aa 0d				call clear_display 
71b3			 
71b3 3e 32				ld a, display_row_2 + 10 
71b5 11 b2 f9				ld de, store_page+3 
71b8 cd bd 0d				call str_at_display 
71bb				 
71bb			; 
71bb			 
71bb			;	ld a, display_row_1+5 
71bb			;	ld de, sprompt3 
71bb			;	call str_at_display 
71bb			;	ld a, display_row_2+7 
71bb			;	call active 
71bb			;	ex de, hl 
71bb			;;	ld de, sprompt4 
71bb			;	call str_at_display 
71bb			; 
71bb cd cd 0d			call update_display 
71be			 
71be			;	call cin_wait 
71be			;	cp 'n' 
71be			;	ret z 
71be			;	cp 'N' 
71be			;	ret z 
71be			 
71be			;	call delay1s 
71be			 
71be 3a b1 f9			ld a, (store_page+2) 
71c1 32 9e f9			ld (store_openmaxext), a    ; save count of ext 
71c4 3e 01			ld a, 1  
71c6 32 9f f9			ld (store_openext), a    ; save count of ext 
71c9			 
71c9			.autof: 
71c9				; begin to read a line from file 
71c9			 
71c9 21 1d f4			ld hl, os_cli_cmd 
71cc 22 1b f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
71cf			  
71cf			.readext: 
71cf 3a 9f f9			ld a, (store_openext) 
71d2 6f				ld l , a 
71d3				 
71d3 3a af f9			ld a, (store_page) 
71d6 67				ld h, a	 
71d7 11 af f9			ld de, store_page 
71da					if DEBUG_FORTH_WORDS 
71da						DMARK "ASl" 
71da f5				push af  
71db 3a ef 71			ld a, (.dmark)  
71de 32 a0 fd			ld (debug_mark),a  
71e1 3a f0 71			ld a, (.dmark+1)  
71e4 32 a1 fd			ld (debug_mark+1),a  
71e7 3a f1 71			ld a, (.dmark+2)  
71ea 32 a2 fd			ld (debug_mark+2),a  
71ed 18 03			jr .pastdmark  
71ef ..			.dmark: db "ASl"  
71f2 f1			.pastdmark: pop af  
71f3			endm  
# End of macro DMARK
71f3						CALLMONITOR 
71f3 cd aa fd			call debug_vector  
71f6				endm  
# End of macro CALLMONITOR
71f6					endif 
71f6 cd cd 09				call storage_read 
71f9 cd 07 10			call ishlzero 
71fc c8				ret z 
71fd			 
71fd			; TODO copy to exec buffer 
71fd			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
71fd			 
71fd				; copy the record buffer to the cli buffer 
71fd			 
71fd ed 5b 1b f6		ld de, (os_var_array) 
7201 21 b1 f9			ld hl, store_page+2 
7204			;	ex de, hl 
7204 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
7207 ed b0			ldir 
7209 ed 53 1b f6		ld (os_var_array), de 
720d				 
720d 3a 9f f9			ld a, (store_openext) 
7210 3c				inc a 
7211 32 9f f9			ld (store_openext), a    ; save count of ext 
7214			 
7214			 
7214			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7214				 
7214 3a a2 f9			ld a, (store_readcont) 
7217 fe 00			cp 0 
7219 20 b4			jr nz, .readext 
721b			 
721b			;	jr z, .autoend 
721b			 
721b					if DEBUG_FORTH_WORDS 
721b						DMARK "ASc" 
721b f5				push af  
721c 3a 30 72			ld a, (.dmark)  
721f 32 a0 fd			ld (debug_mark),a  
7222 3a 31 72			ld a, (.dmark+1)  
7225 32 a1 fd			ld (debug_mark+1),a  
7228 3a 32 72			ld a, (.dmark+2)  
722b 32 a2 fd			ld (debug_mark+2),a  
722e 18 03			jr .pastdmark  
7230 ..			.dmark: db "ASc"  
7233 f1			.pastdmark: pop af  
7234			endm  
# End of macro DMARK
7234						CALLMONITOR 
7234 cd aa fd			call debug_vector  
7237				endm  
# End of macro CALLMONITOR
7237					endif 
7237 e5				push hl	 
7238 d5				push de 
7239 cd 01 0d			call active 
723c eb				ex de, hl 
723d 3e 2f			ld a, display_row_2 + 7 
723f cd bd 0d			call str_at_display 
7242			 
7242 cd cd 0d			call update_display 
7245 d1				pop de  
7246 e1				pop hl 
7247			;	call delay250ms 
7247			 
7247			 
7247			 
7247			 
7247			.autoexec: 
7247			 
7247			 
7247 21 1d f4			ld hl, os_cli_cmd 
724a					if DEBUG_FORTH_WORDS 
724a						DMARK "ASx" 
724a f5				push af  
724b 3a 5f 72			ld a, (.dmark)  
724e 32 a0 fd			ld (debug_mark),a  
7251 3a 60 72			ld a, (.dmark+1)  
7254 32 a1 fd			ld (debug_mark+1),a  
7257 3a 61 72			ld a, (.dmark+2)  
725a 32 a2 fd			ld (debug_mark+2),a  
725d 18 03			jr .pastdmark  
725f ..			.dmark: db "ASx"  
7262 f1			.pastdmark: pop af  
7263			endm  
# End of macro DMARK
7263						CALLMONITOR 
7263 cd aa fd			call debug_vector  
7266				endm  
# End of macro CALLMONITOR
7266					endif 
7266 cd 83 24			call forthparse 
7269 cd bf 24			call forthexec 
726c cd d9 23			call forthexec_cleanup 
726f			 
726f			 
726f			 
726f c3 c9 71			jp .autof 
7272			;.autofdone: 
7272			; 
7272			;		if DEBUG_FORTH_WORDS 
7272			;			DMARK "ASx" 
7272			;			CALLMONITOR 
7272			;		endif 
7272			;;	call clear_display 
7272			;	ret 
7272			 
7272			 
7272			 
7272			endif 
# End of file forth_startupv2.asm
7272			endif 
7272			 
# End of file forth_startup.asm
7272			 
7272			; eof 
# End of file forth_kernel.asm
7272			;include "nascombasic.asm" 
7272			 
7272			 
7272			; find out where the code ends if loaded into RAM (for SC114) 
7272			;endofcode:  
7272			;	nop 
7272			 
7272			 
7272			; jump to nmi vector 
7272			 
7272			init_nmi: 
7272 3e c9			ld a, $c9   ; RET 
7274 32 ad fd			ld (nmi_vector), a 
7277 c9				ret 
7278			nmi: 
7278 e5				push hl 
7279 d5				push de 
727a c5				push bc 
727b f5				push af 
727c cd ad fd			call nmi_vector 
727f f5				push af 
7280 c5				push bc 
7281 d5				push de 
7282 e5				push hl 
7283 ed 4d			reti 
7285			 
7285			 
7285			; eof 
7285			 
# End of file main.asm
7285			include "firmware_lcd_4x40.asm" 
7285			; **********************************************************************  
7285			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
7285			; **********************************************************************  
7285			;  
7285			; **  Written as a Small Computer Monitor App  
7285			; **  www.scc.me.uk  
7285			;  
7285			; History  
7285			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
7285			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
7285			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
7285			;  
7285			; **********************************************************************  
7285			;  
7285			; This program is an example of one of the methods of interfacing an   
7285			; alphanumeric LCD module.   
7285			;  
7285			; In this example the display is connected to either a Z80 PIO or a   
7285			; simple 8-bit output port.   
7285			;  
7285			; This interfacing method uses 4-bit data mode and uses time delays  
7285			; rather than polling the display's ready status. As a result the   
7285			; interface only requires 6 simple output lines:  
7285			;   Output bit 0 = not used  
7285			;   Output bit 1 = not used  
7285			;   Output bit 2 = RS         High = data, Low = instruction  
7285			;   Output bit 3 = E          Active high  
7285			;   Output bit 4 = DB4  
7285			;   Output bit 5 = DB5  
7285			;   Output bit 6 = DB6  
7285			;   Output bit 7 = DB7  
7285			; Display's R/W is connected to 0v so it is always in write mode  
7285			;  
7285			; This set up should work with any system supporting the RC2014 bus  
7285			  
7285			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
7285			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
7285			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
7285			;  
7285			; **********************************************************************  
7285			  
7285			; Additonal for 4x40. E1 and E2 instead of just E   
7285			; TODO swipe vidout signal on port a to activate E2  
7285			  
7285			; **********************************************************************  
7285			; **  Constants  
7285			; **********************************************************************  
7285			; LCD constants required by LCD support module  
7285			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
7285			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
7285			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
7285			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
7285			; TODO Decide which E is being set  
7285			kLCDWidth:  EQU display_cols             ;Width in characters  
7285			  
7285			; **********************************************************************  
7285			; **  Code library usage  
7285			; **********************************************************************  
7285			  
7285			; send character to current cursor position  
7285			; wraps and/or scrolls screen automatically  
7285			  
7285			  
7285			  
7285			lcd_init:  
7285			  
7285			; SCMonAPI functions used  
7285			  
7285			; Alphanumeric LCD functions used  
7285			; no need to specify specific functions for this module  
7285			  
7285 3e cf		            LD   A, 11001111b  
7287 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7289 3e 00		            LD   A, 00000000b  
728b d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
728d			  
728d			; Initialise alphanumeric LCD module  
728d 3e 00				ld a, 0  
728f 32 00 fb				ld (display_lcde1e2), a  
7292 cd 13 73		            CALL fLCD_Init      ;Initialise LCD module  
7295 3e 01				ld a, 1  
7297 32 00 fb				ld (display_lcde1e2), a  
729a cd 13 73		            CALL fLCD_Init      ;Initialise LCD module  
729d			  
729d c9				ret  
729e			  
729e			;  
729e			;;  
729e			; lcd functions  
729e			;  
729e			;  
729e			  
729e			; what is at cursor position   
729e			  
729e			;get_cursor:	ld de, (cursor_row)   ;  row + col  
729e			;		call curptr  
729e			;		ret  
729e			  
729e			  
729e			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
729e			  
729e			curptr:  
729e c5				push bc  
729f 21 e6 fc			ld hl, display_fb0  
72a2			cpr:	  
72a2				; loop for cursor whole row  
72a2 0e 28			ld c, display_cols  
72a4 23			cpr1:	inc hl  
72a5 0d				dec c  
72a6 20 fc			jr nz, cpr1  
72a8 05				dec b  
72a9 20 f7			jr nz, cpr  
72ab			  
72ab				; add col	  
72ab			  
72ab 23			cpr2:	inc hl  
72ac 1d				dec e  
72ad 20 fc			jr nz, cpr2  
72af			  
72af c1				pop bc  
72b0 c9				ret  
72b1				  
72b1			  
72b1			  
72b1			  
72b1			  
72b1			; write the frame buffer given in hl to hardware   
72b1 22 fe fa		write_display: ld (display_write_tmp), hl 	   
72b4 3e 00			ld a, kLCD_Line1  
72b6 cd c0 73		            CALL fLCD_Pos       ;Position cursor to location in A  
72b9 06 28			ld b, display_cols  
72bb ed 5b fe fa		ld de, (display_write_tmp)  
72bf cd 0b 73			call write_len_string  
72c2				  
72c2				  
72c2 2a fe fa			ld hl, (display_write_tmp)  
72c5 11 28 00			ld de, display_cols  
72c8 19				add hl,de  
72c9 22 fe fa			ld (display_write_tmp),hl  
72cc			  
72cc				  
72cc 3e 28			ld a, kLCD_Line2  
72ce cd c0 73		            CALL fLCD_Pos       ;Position cursor to location in A  
72d1 06 28			ld b, display_cols  
72d3 ed 5b fe fa		ld de, (display_write_tmp)  
72d7 cd 0b 73			call write_len_string  
72da				  
72da 2a fe fa			ld hl, (display_write_tmp)  
72dd 11 28 00			ld de, display_cols  
72e0 19				add hl,de  
72e1 22 fe fa			ld (display_write_tmp),hl  
72e4			  
72e4				  
72e4 3e 50			ld a, kLCD_Line3  
72e6 cd c0 73		            CALL fLCD_Pos       ;Position cursor to location in A  
72e9 06 28			ld b, display_cols  
72eb ed 5b fe fa		ld de, (display_write_tmp)  
72ef cd 0b 73			call write_len_string  
72f2				  
72f2 2a fe fa			ld hl, (display_write_tmp)  
72f5 11 28 00			ld de, display_cols  
72f8 19				add hl,de  
72f9 22 fe fa			ld (display_write_tmp),hl  
72fc			  
72fc				  
72fc 3e 78			ld a, kLCD_Line4  
72fe cd c0 73		            CALL fLCD_Pos       ;Position cursor to location in A  
7301 06 28			ld b, display_cols  
7303 ed 5b fe fa		ld de, (display_write_tmp)  
7307 cd 0b 73			call write_len_string  
730a c9					ret  
730b				  
730b				; write out a fixed length string given in b from de  
730b			  
730b 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
730c cd 78 73		            CALL fLCD_Data      ;Write character to display  
730f 13				inc de  
7310 10 f9			djnz write_len_string  
7312 c9				ret  
7313			  
7313			; Some other things to do  
7313			;            LD   A, kLCD_Clear ;Display clear  
7313			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
7313			;            LD   A, kLCD_Under ;Display on with underscore cursor  
7313			;            LD   A, kLCD_On     ;Display on with no cursor  
7313			;            ;LD   A, kLCD_Off   ;Display off  
7313			;            CALL fLCD_Inst      ;Send instruction to display  
7313			;  
7313			;  
7313			;            halt  
7313			;  
7313			;  
7313			;MsgHello:   DB  "Hello World!",0  
7313			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
7313			  
7313			; Custom characters 5 pixels wide by 8 pixels high  
7313			; Up to 8 custom characters can be defined  
7313			;BitMaps:      
7313			;; Character 0x00 = Battery icon  
7313			;            DB  01110b  
7313			;            DB  11011b  
7313			;            DB  10001b  
7313			;            DB  10001b  
7313			;            DB  11111b  
7313			;            DB  11111b  
7313			;            DB  11111b  
7313			;            DB  11111b  
7313			;; Character 0x01 = Bluetooth icon  
7313			;            DB  01100b  
7313			;            DB  01010b  
7313			;            DB  11100b  
7313			;            DB  01000b  
7313			;            DB  11100b  
7313			;            DB  01010b  
7313			;            DB  01100b  
7313			;            DB  00000b  
7313			;  
7313			  
7313			  
7313			; **********************************************************************  
7313			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
7313			; **********************************************************************  
7313			;  
7313			; **  Written as a Small Computer Monitor App   
7313			; **  Version 0.1 SCC 2018-05-16  
7313			; **  www.scc.me.uk  
7313			;  
7313			; **********************************************************************  
7313			;  
7313			; This module provides support for alphanumeric LCD modules using with  
7313			; *  HD44780 (or compatible) controller  
7313			; *  5 x 7 pixel fonts  
7313			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
7313			; *  Interface via six digital outputs to the display (see below)  
7313			;  
7313			; LCD module pinout:  
7313			;   1  Vss   0v supply  
7313			;   2  Vdd   5v supply  
7313			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
7313			;   4  RS    High = data, Low = instruction  
7313			;   5  R/W   High = Read, Low = Write  
7313			;   6  E     Enable signal (active high)  
7313			;   7  DB0   Data bit 0  
7313			;   8  DB1   Data bit 1  
7313			;   9  DB2   Data bit 2  
7313			;  10  DB3   Data bit 3  
7313			;  11  DB4   Data bit 4  
7313			;  12  DB5   Data bit 5  
7313			;  13  DB6   Data bit 6  
7313			;  14  DB7   Data bit 7  
7313			;  15  A     Backlight anode (+)  
7313			;  16  K     Backlight cathode (-)  
7313			;  
7313			; This interfacing method uses 4-bit data mode and uses time delays  
7313			; rather than polling the display's ready status. As a result the   
7313			; interface only requires 6 simple output lines:  
7313			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
7313			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
7313			;   LCD DB4 = Microcomputer output port bit 4  
7313			;   LCD DB5 = Microcomputer output port bit 5  
7313			;   LCD DB6 = Microcomputer output port bit 6  
7313			;   LCD DB7 = Microcomputer output port bit 7  
7313			; Display's R/W is connected to 0v so it is always in write mode  
7313			; All 6 connections must be on the same port address <kLCDPrt>  
7313			; This method also allows a decent length of cable from micro to LCD  
7313			;  
7313			; **********************************************************************  
7313			;  
7313			; To include the code for any given function provided by this module,   
7313			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
7313			; the parent source file.  
7313			; For example:  #REQUIRES   uHexPrefix  
7313			;  
7313			; Also #INCLUDE this file at some point after the #REQUIRES statements  
7313			; in the parent source file.  
7313			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
7313			;  
7313			; These are the function names provided by this module:  
7313			; fLCD_Init                     ;Initialise LCD  
7313			; fLCD_Inst                     ;Send instruction to LCD  
7313			; fLCD_Data                     ;Send data byte to LCD  
7313			; fLCD_Pos                      ;Position cursor  
7313			; fLCD_Str                      ;Display string  
7313			; fLCD_Def                      ;Define custom character  
7313			;  
7313			; **********************************************************************  
7313			;  
7313			; Requires SCMonAPI.asm to also be included in the project  
7313			;  
7313			  
7313			  
7313			; **********************************************************************  
7313			; **  Constants  
7313			; **********************************************************************  
7313			  
7313			; Constants that must be defined externally  
7313			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
7313			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
7313			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
7313			;kLCDWidth: EQU 20             ;Width in characters  
7313			  
7313			; general line offsets in any frame buffer  
7313			  
7313			  
7313			display_row_1: equ 0  
7313			display_row_2: equ display_row_1+display_cols  
7313			display_row_3: equ display_row_2 + display_cols  
7313			display_row_4: equ display_row_3 + display_cols  
7313			;display_row_4_eol:   
7313			  
7313			  
7313			; Cursor position values for the start of each line  
7313			  
7313			; E  
7313			kLCD_Line1: EQU 0x00   
7313			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
7313			; E1  
7313			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
7313			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
7313			  
7313			; Instructions to send as A register to fLCD_Inst  
7313			kLCD_Clear: EQU 00000001b     ;LCD clear  
7313			kLCD_Off:   EQU 00001000b     ;LCD off  
7313			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
7313			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
7313			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
7313			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
7313			  
7313			; Constants used by this code module  
7313			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
7313			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
7313			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
7313			  
7313			  
7313			  
7313			; **********************************************************************  
7313			; **  LCD support functions  
7313			; **********************************************************************  
7313			  
7313			; Initialise alphanumeric LCD module  
7313			; LCD control register codes:  
7313			;   DL   0 = 4-bit mode        1 = 8-bit mode  
7313			;   N    0 = 1-line mode       1 = 2-line mode  
7313			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
7313			;   D    0 = Display off       1 = Display on  
7313			;   C    0 = Cursor off        1 = Cursor on  
7313			;   B    0 = Blinking off      1 = Blinking on  
7313			;   ID   0 = Decrement mode    1 = Increment mode  
7313			;   SH   0 = Entire shift off  1 = Entire shift on  
7313 3e 28		fLCD_Init:  LD   A, 40  
7315 cd 3a 74		            CALL LCDDelay       ;Delay 40ms after power up  
7318			; For reliable reset set 8-bit mode - 3 times  
7318 cd 0a 74		            CALL WrFn8bit       ;Function = 8-bit mode  
731b cd 0a 74		            CALL WrFn8bit       ;Function = 8-bit mode  
731e cd 0a 74		            CALL WrFn8bit       ;Function = 8-bit mode  
7321			; Set 4-bit mode  
7321 cd 06 74		            CALL WrFn4bit       ;Function = 4-bit mode  
7324 cd 38 74		            CALL LCDDelay1      ;Delay 37 us or more  
7327			; Function set  
7327 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7329 cd 3c 73		            CALL fLCD_Inst      ;2 line, display on  
732c			; Display On/Off control  
732c 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
732e cd 3c 73		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7331			; Display Clear  
7331 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7333 cd 3c 73		            CALL fLCD_Inst      ;Clear display  
7336			; Entry mode  
7336 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7338 cd 3c 73		            CALL fLCD_Inst      ;Increment mode, shift off  
733b			; Display module now initialised  
733b c9			            RET  
733c			; ok to here  
733c			  
733c			; Write instruction to LCD  
733c			;   On entry: A = Instruction byte to be written  
733c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
733c f5			fLCD_Inst:  PUSH AF  
733d f5			            PUSH AF  
733e cd 50 73		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
7341 f1			            POP  AF  
7342 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7343 17			            RLA  
7344 17			            RLA  
7345 17			            RLA  
7346 cd 50 73		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7349 3e 02		            LD   A, 2  
734b cd 3a 74		            CALL LCDDelay       ;Delay 2 ms to complete   
734e f1			            POP  AF  
734f c9			            RET  
7350			Wr4bits:   
7350 f5					push af  
7351 3a 00 fb				ld a, (display_lcde1e2)  
7354 fe 00				cp 0     ; e  
7356 20 10				jr nz, .wea2	  
7358 f1					pop af  
7359 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
735b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
735d cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
735f cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7361 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7363 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
7365 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7367 c9			            RET  
7368 f1			.wea2:		pop af  
7369 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
736b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
736d cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
736f cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7371 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7373 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7375 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7377 c9			            RET  
7378			  
7378			  
7378			; Write data to LCD  
7378			;   On entry: A = Data byte to be written  
7378			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7378 f5			fLCD_Data:  PUSH AF  
7379 f5			            PUSH AF  
737a cd 8c 73		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
737d f1			            POP  AF  
737e 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
737f 17			            RLA  
7380 17			            RLA  
7381 17			            RLA  
7382 cd 8c 73		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7385 3e 96		            LD   A, 150  
7387 3d			Wait:      DEC  A              ;Wait a while to allow data   
7388 20 fd		            JR   NZ, Wait      ;  write to complete  
738a f1			            POP  AF  
738b c9			            RET  
738c			Wr4bitsa:     
738c f5					push af  
738d 3a 00 fb				ld a, (display_lcde1e2)  
7390 fe 00				cp 0     ; e1  
7392 20 16				jr nz, .we2	  
7394 f1					pop af  
7395 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7397 cb d7		            SET  kLCDBitRS, A  
7399 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
739b cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
739d cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
739f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
73a1 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
73a3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
73a5 cb 97		            RES  kLCDBitRS, A  
73a7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
73a9 c9			            RET  
73aa f1			.we2:		pop af  
73ab e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
73ad cb d7		            SET  kLCDBitRS, A  
73af d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
73b1 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
73b3 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
73b5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
73b7 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
73b9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
73bb cb 97		            RES  kLCDBitRS, A  
73bd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
73bf c9			            RET  
73c0			  
73c0			  
73c0			; Position cursor to specified location  
73c0			;   On entry: A = Cursor position  
73c0			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
73c0 f5			fLCD_Pos:   PUSH AF  
73c1					; at this point set the E1 or E2 flag depending on position  
73c1			  
73c1 c5					push bc  
73c2			;		push af  
73c2 06 00				ld b, 0  
73c4 4f					ld c, a  
73c5 3e 4f				ld a, kLCD_Line3-1  
73c7 b7			 		or a      ;clear carry flag  
73c8 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
73c9 38 04				jr c, .pe1  
73cb			  
73cb					; E selection  
73cb cb 80				res 0, b         ; bit 0 unset e  
73cd			;		pop af    ; before line 3 so recover orig pos  
73cd			;		ld c, a    ; save for poking back  
73cd 18 06				jr .peset	          
73cf			.pe1:          	; E2 selection  
73cf cb c0				set 0, b         ; bit 0 set e1  
73d1 79					ld a, c  
73d2 de 4f				sbc a, kLCD_Line3-1  
73d4 4f					ld c, a	         ; save caculated offset  
73d5			;		pop af     ; bin this original value now we have calculated form  
73d5			  
73d5			.peset:		; set bit  
73d5 78					ld a, b  
73d6 32 00 fb				ld (display_lcde1e2), a 	  
73d9 79					ld a, c  
73da c1					pop bc  
73db			  
73db f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
73dd cd 3c 73		            CALL fLCD_Inst      ;Write instruction to LCD  
73e0 f1			            POP  AF  
73e1 c9			            RET  
73e2			  
73e2			  
73e2			; Output text string to LCD  
73e2			;   On entry: DE = Pointer to null terminated text string  
73e2			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
73e2 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
73e3 b7			            OR   A              ;Null terminator?  
73e4 c8			            RET  Z              ;Yes, so finished  
73e5 cd 78 73		            CALL fLCD_Data      ;Write character to display  
73e8 13			            INC  DE             ;Point to next character  
73e9 18 f7		            JR   fLCD_Str       ;Repeat  
73eb c9					ret  
73ec			  
73ec			; Define custom character  
73ec			;   On entry: A = Character number (0 to 7)  
73ec			;             DE = Pointer to character bitmap data  
73ec			;   On exit:  A = Next character number  
73ec			;             DE = Next location following bitmap  
73ec			;             BC HL IX IY I AF' BC' DE' HL' preserved  
73ec			; Character is   
73ec c5			fLCD_Def:   PUSH BC  
73ed f5			            PUSH AF  
73ee 07			            RLCA                ;Calculate location  
73ef 07			            RLCA                ;  for bitmap data  
73f0 07			            RLCA                ;  = 8 x CharacterNumber  
73f1 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
73f3 cd 3c 73		            CALL fLCD_Inst      ;Write instruction to LCD  
73f6 06 00		            LD   B, 0  
73f8 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
73f9 cd 78 73		            CALL fLCD_Data      ;Write byte to display  
73fc 13			            INC  DE             ;Point to next byte  
73fd 04			            INC  B              ;Count bytes  
73fe cb 58		            BIT  3, B           ;Finish all 8 bytes?  
7400 28 f6		            JR   Z, Loop       ;No, so repeat  
7402 f1			            POP  AF  
7403 3c			            INC  A              ;Increment character number  
7404 c1			            POP  BC  
7405 c9			            RET  
7406			  
7406			  
7406			; **********************************************************************  
7406			; **  Private functions  
7406			; **********************************************************************  
7406			  
7406			; Write function to LCD  
7406			;   On entry: A = Function byte to be written  
7406			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7406 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7408 18 02		            JR   WrFunc  
740a 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
740c f5			WrFunc:     PUSH AF  
740d f5					push af  
740e 3a 00 fb				ld a, (display_lcde1e2)  
7411 fe 00				cp 0     ; e1  
7413 20 0f				jr nz, .wfea2	  
7415 f1					pop af  
7416 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7418 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
741a cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
741c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
741e cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7420 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7422 18 0d			jr .wfskip  
7424 f1			.wfea2:		pop af  
7425 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7427 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7429 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
742b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
742d cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
742f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7431 3e 05		.wfskip:            LD  A, 5  
7433 cd 3a 74		            CALL LCDDelay       ;Delay 5 ms to complete  
7436 f1			            POP  AF  
7437 c9			            RET  
7438			  
7438			  
7438			; Delay in milliseconds  
7438			;   On entry: A = Number of milliseconds delay  
7438			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7438 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
743a d5			LCDDelay:   PUSH DE  
743b 5f			            LD   E, A           ;Delay by 'A' ms  
743c 16 00		            LD   D, 0  
743e cd d2 0c		            CALL aDelayInMS  
7441 d1			            POP  DE  
7442 c9			            RET  
7443			  
7443			  
7443			testlcd:  
7443 3e 00			ld a, kLCD_Line1  
7445 cd c0 73			call fLCD_Pos  
7448 06 28			ld b, 40  
744a 11 78 74			ld de, .ttext1  
744d cd 0b 73			call write_len_string  
7450			  
7450 3e 28			ld a, kLCD_Line2  
7452 cd c0 73			call fLCD_Pos  
7455 06 28			ld b, 40  
7457 11 a1 74			ld de, .ttext2  
745a cd 0b 73			call write_len_string  
745d 3e 50			ld a, kLCD_Line3  
745f cd c0 73			call fLCD_Pos  
7462 06 28			ld b, 40  
7464 11 ca 74			ld de, .ttext3  
7467 cd 0b 73			call write_len_string  
746a 3e 78			ld a, kLCD_Line4  
746c cd c0 73			call fLCD_Pos  
746f 06 28			ld b, 40  
7471 11 f3 74			ld de, .ttext4  
7474 cd 0b 73			call write_len_string  
7477			  
7477 76				halt  
7478			  
7478			  
7478 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
74a1 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
74ca .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
74f3 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
751c			   
751c			  
751c			  
751c			; eof  
751c			  
# End of file firmware_lcd_4x40.asm
751c			;include "firmware_lcd_4x20.asm" 
751c			include "firmware_key_5x10.asm" 
751c			; 5 x 10 decade counter scanner  
751c			  
751c			  
751c			; TODO do cursor shape change for shift keys  
751c			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
751c			  
751c			  
751c			; bit mask for each scan column and row for teing the matrix  
751c			  
751c			  
751c			key_init:  
751c			  
751c			; SCMonAPI functions used  
751c			  
751c			; Alphanumeric LCD functions used  
751c			; no need to specify specific functions for this module  
751c			  
751c			  
751c 3e cf		            LD   A, 11001111b  
751e d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
7520			;            LD   A, 00000000b  
7520 3e 1f		            LD   A, 00011111b  
7522 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7524			  
7524			  
7524				; TODO Configure cursor shapes  
7524			  
7524				; Load cursor shapes   
7524 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7526 11 36 75		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7529 06 02		            LD   B, 2           ;Number of characters to define  
752b cd ec 73		.DefLoop:   CALL fLCD_Def       ;Define custom character  
752e 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7530			  
7530 3e 01				ld a, 1  
7532 32 f6 fa			ld (cursor_shape),a  
7535 c9				ret  
7536			  
7536			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7536			; Up to 8 custom characters can be defined  
7536			.cursor_shapes:      
7536			;; Character 0x00 = Normal  
7536 1f			            DB  11111b  
7537 1f			            DB  11111b  
7538 1f			            DB  11111b  
7539 1f			            DB  11111b  
753a 1f			            DB  11111b  
753b 1f			            DB  11111b  
753c 1f			            DB  11111b  
753d 1f			            DB  11111b  
753e			;; Character 0x01 = Modifier  
753e 1f			            DB  11111b  
753f 1b			            DB  11011b  
7540 1b			            DB  11011b  
7541 1b			            DB  11011b  
7542 1b			            DB  11011b  
7543 1f			            DB  11111b  
7544 1b			            DB  11011b  
7545 1f			            DB  11111b  
7546			  
7546			  
7546			  
7546			  
7546			; Display custom character 0  
7546			;            LD   A, kLCD_Line1+14  
7546			;            CALL fLCD_Pos       ;Position cursor to location in A  
7546			;            LD   A, 0  
7546			;            CALL fLCD_Data      ;Write character in A at cursor  
7546			  
7546			; Display custom character 1  
7546			;            LD   A, kLCD_Line2+14  
7546			;            CALL fLCD_Pos      ;Position cursor to location in A  
7546			;            LD   A, 1  
7546			;            CALL fLCD_Data     ;Write character in A at cursor  
7546			  
7546			; keyboard scanning   
7546			  
7546			; character in from keyboard  
7546			  
7546			; mapping for the pcb layout  
7546			  
7546			.matrix_to_char:  
7546 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7551 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
755c 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7567 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7572 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
757d			.matrix_to_shift:  
757d			  
757d .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7588 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7593 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
759e 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
75a9 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
75b4			  
75b4			.matrix_to_symbolshift:  
75b4			  
75b4 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
75bf .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
75ca 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
75d5			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
75d5 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
75e0 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
75eb			  
75eb			  
75eb			  
75eb			; mapping for a simple straight through breadboard layout  
75eb			  
75eb			;.matrix_to_char:  
75eb			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
75eb			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
75eb			;		db "asdfghjkl",KEY_CR,0  
75eb			;		db "qwertyuiop",0  
75eb			;		 db "1234567890",0  
75eb			;.matrix_to_shift:  
75eb			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
75eb			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
75eb			;		db "ASDFGHJKL",KEY_CR,0  
75eb			;		db "QWERTYUIOP",0  
75eb			;		 db "!",'"',"#$%^&*()",0  
75eb			;.matrix_to_symbolshift:  
75eb			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
75eb			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
75eb			;		db "_?*fghjk=",KEY_CR,0  
75eb			;		db "-/+*[]{}@#",0  
75eb			;		 db "1234567890",0  
75eb			  
75eb			;.matrix_to_char: db "D#0*C987B654A321"  
75eb			  
75eb			  
75eb				  
75eb			  
75eb			; add cin and cin_wait  
75eb			  
75eb cd fc 75		cin_wait: 	call cin  
75ee						if DEBUG_KEYCINWAIT  
75ee							push af  
75ee							  
75ee							ld hl,key_repeat_ct  
75ee							ld (hl),a  
75ee							inc hl  
75ee							call hexout  
75ee							ld hl,key_repeat_ct+3  
75ee							ld a,0  
75ee							ld (hl),a  
75ee			  
75ee							    LD   A, kLCD_Line1+11  
75ee							    CALL fLCD_Pos       ;Position cursor to location in A  
75ee							    LD   DE, key_repeat_ct  
75ee							    ;LD   DE, MsgHello  
75ee							    CALL fLCD_Str       ;Display string pointed to by DE  
75ee			  
75ee			  
75ee			  
75ee							pop af  
75ee						endif  
75ee fe 00			cp 0  
75f0 28 f9			jr z, cin_wait   ; block until key press  
75f2			  
75f2							if DEBUG_KEYCINWAIT  
75f2								push af  
75f2			  
75f2								ld a, 'A'	  
75f2								ld hl,key_repeat_ct  
75f2								ld (hl),a  
75f2								inc hl  
75f2								ld a,0  
75f2								ld (hl),a  
75f2			  
75f2								    LD   A, kLCD_Line2+11  
75f2								    CALL fLCD_Pos       ;Position cursor to location in A  
75f2								    LD   DE, key_repeat_ct  
75f2								    ;LD   DE, MsgHello  
75f2								    CALL fLCD_Str       ;Display string pointed to by DE  
75f2			  
75f2							call delay500ms  
75f2			  
75f2								pop af  
75f2							endif  
75f2 f5				push af   ; save key pressed  
75f3			  
75f3			.cin_wait1:	  
75f3							if DEBUG_KEYCINWAIT  
75f3								push af  
75f3			  
75f3								ld a, 'b'	  
75f3								ld hl,key_repeat_ct  
75f3								ld (hl),a  
75f3								inc hl  
75f3								ld a,0  
75f3								ld (hl),a  
75f3			  
75f3								    LD   A, kLCD_Line2+11  
75f3								    CALL fLCD_Pos       ;Position cursor to location in A  
75f3								    LD   DE, key_repeat_ct  
75f3								    ;LD   DE, MsgHello  
75f3								    CALL fLCD_Str       ;Display string pointed to by DE  
75f3			  
75f3			  
75f3							call delay500ms  
75f3			  
75f3								pop af  
75f3							endif  
75f3			  
75f3 cd fc 75		call cin  
75f6 fe 00			cp 0  
75f8 20 f9			jr nz, .cin_wait1  	; wait for key release  
75fa			if DEBUG_KEYCINWAIT  
75fa				push af  
75fa			  
75fa				ld a, '3'	  
75fa				ld hl,key_repeat_ct  
75fa				ld (hl),a  
75fa				inc hl  
75fa				ld a,0  
75fa				ld (hl),a  
75fa			  
75fa			            LD   A, kLCD_Line2+11  
75fa			            CALL fLCD_Pos       ;Position cursor to location in A  
75fa			            LD   DE, key_repeat_ct  
75fa			            ;LD   DE, MsgHello  
75fa			            CALL fLCD_Str       ;Display string pointed to by DE  
75fa			  
75fa			  
75fa			call delay500ms  
75fa			  
75fa				pop af  
75fa			endif  
75fa			  
75fa f1				pop af   ; get key  
75fb c9				ret  
75fc			  
75fc			  
75fc			; cin - key non-blocking except for keybounce release  
75fc			  
75fc cd 1a 76		cin: 	call .mtoc  
75ff			  
75ff			if DEBUG_KEYCIN  
75ff				push af  
75ff				  
75ff				ld hl,key_repeat_ct  
75ff				ld (hl),a  
75ff				inc hl  
75ff				call hexout  
75ff				ld hl,key_repeat_ct+3  
75ff				ld a,0  
75ff				ld (hl),a  
75ff			  
75ff			            LD   A, kLCD_Line3+15  
75ff			            CALL fLCD_Pos       ;Position cursor to location in A  
75ff			            LD   DE, key_repeat_ct  
75ff			            ;LD   DE, MsgHello  
75ff			            CALL fLCD_Str       ;Display string pointed to by DE  
75ff			  
75ff			  
75ff			call delay500ms  
75ff			  
75ff				pop af  
75ff			endif  
75ff			  
75ff			  
75ff				; no key held  
75ff fe 00			cp 0  
7601 c8				ret z  
7602			  
7602			if DEBUG_KEYCIN  
7602				push af  
7602			  
7602				ld a, '1'	  
7602				ld hl,key_repeat_ct  
7602				ld (hl),a  
7602				inc hl  
7602				ld a,0  
7602				ld (hl),a  
7602			  
7602			            LD   A, kLCD_Line4+15  
7602			            CALL fLCD_Pos       ;Position cursor to location in A  
7602			            LD   DE, key_repeat_ct  
7602			            ;LD   DE, MsgHello  
7602			            CALL fLCD_Str       ;Display string pointed to by DE  
7602			  
7602			  
7602			call delay500ms  
7602			  
7602				pop af  
7602			endif  
7602			  
7602				; stop key bounce  
7602			  
7602 32 c6 fd			ld (key_held),a		 ; save it  
7605 47				ld b, a  
7606			  
7606 c5			.cina1:	push bc  
7607			if DEBUG_KEYCIN  
7607				push af  
7607			  
7607				ld hl,key_repeat_ct  
7607				inc hl  
7607				call hexout  
7607				ld hl,key_repeat_ct+3  
7607				ld a,0  
7607				ld (hl),a  
7607				ld hl,key_repeat_ct  
7607				ld a, '2'	  
7607				ld (hl),a  
7607			  
7607			            LD   A, kLCD_Line4+15  
7607			            CALL fLCD_Pos       ;Position cursor to location in A  
7607			            LD   DE, key_repeat_ct  
7607			            ;LD   DE, MsgHello  
7607			            CALL fLCD_Str       ;Display string pointed to by DE  
7607			  
7607				pop af  
7607			endif  
7607 cd 1a 76			call .mtoc  
760a c1				pop bc  
760b b8				cp b  
760c 28 f8			jr z, .cina1  
760e 78				ld a,b		  
760f			if DEBUG_KEYCIN  
760f				push af  
760f			  
760f				ld hl,key_repeat_ct  
760f				inc hl  
760f				call hexout  
760f				ld hl,key_repeat_ct+3  
760f				ld a,0  
760f				ld (hl),a  
760f				ld hl,key_repeat_ct  
760f				ld a, '3'	  
760f				ld (hl),a  
760f			  
760f			            LD   A, kLCD_Line4+15  
760f			            CALL fLCD_Pos       ;Position cursor to location in A  
760f			            LD   DE, key_repeat_ct  
760f			            ;LD   DE, MsgHello  
760f			            CALL fLCD_Str       ;Display string pointed to by DE  
760f			  
760f				pop af  
760f			endif  
760f c9				ret  
7610			  
7610			; cinndb - key non-blocking without keybounce release  
7610			  
7610 cd 1a 76		cinndb: 	call .mtoc  
7613			  
7613			if DEBUG_KEYCIN  
7613				push af  
7613				  
7613				ld hl,key_repeat_ct  
7613				ld (hl),a  
7613				inc hl  
7613				call hexout  
7613				ld hl,key_repeat_ct+3  
7613				ld a,0  
7613				ld (hl),a  
7613			  
7613			            LD   A, kLCD_Line3+15  
7613			            CALL fLCD_Pos       ;Position cursor to location in A  
7613			            LD   DE, key_repeat_ct  
7613			            ;LD   DE, MsgHello  
7613			            CALL fLCD_Str       ;Display string pointed to by DE  
7613			  
7613			  
7613			call delay500ms  
7613			  
7613				pop af  
7613			endif  
7613			  
7613			  
7613				; no key held  
7613 fe 00			cp 0  
7615 c8				ret z  
7616			  
7616			if DEBUG_KEYCIN  
7616				push af  
7616			  
7616				ld a, '1'	  
7616				ld hl,key_repeat_ct  
7616				ld (hl),a  
7616				inc hl  
7616				ld a,0  
7616				ld (hl),a  
7616			  
7616			            LD   A, kLCD_Line4+15  
7616			            CALL fLCD_Pos       ;Position cursor to location in A  
7616			            LD   DE, key_repeat_ct  
7616			            ;LD   DE, MsgHello  
7616			            CALL fLCD_Str       ;Display string pointed to by DE  
7616			  
7616			  
7616			call delay500ms  
7616			  
7616				pop af  
7616			endif  
7616			  
7616 32 c6 fd			ld (key_held),a		 ; save it  
7619			  
7619			if DEBUG_KEYCIN  
7619				push af  
7619			  
7619				ld hl,key_repeat_ct  
7619				inc hl  
7619				call hexout  
7619				ld hl,key_repeat_ct+3  
7619				ld a,0  
7619				ld (hl),a  
7619				ld hl,key_repeat_ct  
7619				ld a, '3'	  
7619				ld (hl),a  
7619			  
7619			            LD   A, kLCD_Line4+15  
7619			            CALL fLCD_Pos       ;Position cursor to location in A  
7619			            LD   DE, key_repeat_ct  
7619			            ;LD   DE, MsgHello  
7619			            CALL fLCD_Str       ;Display string pointed to by DE  
7619			  
7619				pop af  
7619			endif  
7619 c9				ret  
761a			; detect keyboard modifier key press and apply new overlay to the face key held  
761a			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
761a			  
761a			;.cin_map_modifier:   
761a			;	ld a, (hl)  
761a			;	and 255  
761a			;	ret NZ		; modifier key not flagged  
761a			;  
761a			;	; get key face  
761a			;  
761a			;	ld b,(key_face_held)  
761a			;  
761a			;	ld b, key_cols * key_rows  
761a			;  
761a			;	push de  
761a			;	pop hl  
761a			;  
761a			;.mmod1: ld a,(hl)   ; get map test  
761a			;	cp b  
761a			;	jr z, .mmod2  
761a			;  
761a			;  
761a			;  
761a			;.mmod2: inc hl    ;   
761a			;  
761a			;	  
761a			;  
761a			;	  
761a			;  
761a			;	ld hl,key_actual_pressed  
761a			;	ld (hl),a,  
761a			;	ret  
761a			  
761a			; map matrix key held to char on face of key  
761a			  
761a			.mtoc:  
761a			  
761a			; test decade counter strobes  
761a			  
761a			;.decadetest1:  
761a			  
761a			; reset counter  
761a			;ld a, 128  
761a			;out (portbdata),a  
761a			  
761a			  
761a			;ld b, 5  
761a			;.dec1:  
761a			;ld a, 0  
761a			;out (portbdata),a  
761a			;call delay1s  
761a			  
761a			;ld a, 32  
761a			;out (portbdata),a  
761a			;call delay1s  
761a			;call delay1s  
761a			;call delay1s  
761a			;  
761a			;ld a, 64+32  
761a			;out (portbdata),a  
761a			;call delay1s  
761a			;;djnz .dec1  
761a			;  
761a			;jp .decadetest1  
761a			  
761a			  
761a			  
761a			  
761a			  
761a			  
761a			  
761a			  
761a			  
761a			  
761a				; scan keyboard matrix and generate raw scan map  
761a cd ad 76			call matrix  
761d			  
761d				; reuse c bit 0 left modifer button - ie shift  
761d			        ; reuse c bit 1 for right modifer button - ie symbol shift  
761d				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
761d			  
761d 0e 00			ld c, 0  
761f			  
761f				; TODO set flags for modifer key presses   
761f				; TODO do a search for modifer key...  
761f			  
761f				;ld hl,keyscan_table_row4  
761f 21 25 fe			ld hl,keyscan_table_row2  
7622			  
7622 7e				ld a, (hl)  
7623 fe 23			cp '#'  
7625 20 07			jr nz, .nextmodcheck  
7627 cb c1			set 0, c  
7629 21 7d 75			ld hl, .matrix_to_shift  
762c 18 21			jr .dokeymap  
762e				; TODO for now igonre  
762e			.nextmodcheck:  
762e 21 1a fe			ld hl,keyscan_table_row3  
7631			  
7631 7e				ld a, (hl)  
7632 fe 23			cp '#'  
7634 20 07			jr nz, .nextmodcheck2  
7636 cb c9			set 1, c   
7638 21 b4 75			ld hl, .matrix_to_symbolshift  
763b 18 12			jr .dokeymap  
763d			.nextmodcheck2:  
763d 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
7640			  
7640 7e				ld a, (hl)  
7641 fe 23			cp '#'  
7643 20 07			jr nz, .donemodcheck  
7645 cb c9			set 1, c   
7647 21 7d 75			ld hl, .matrix_to_shift  
764a 18 03			jr .dokeymap  
764c			  
764c				; no modifer found so just map to normal keys  
764c				; get mtoc map matrix to respective keys  
764c			;	ld hl, .matrix_to_char  
764c			;	ld hl, .matrix_to_char  
764c			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
764c			;	ld a, KEY_SHIFT  
764c			;	call findchar  
764c			;  
764c			;	; got offset to key modifer in b  
764c			;  
764c			;	ld hl,keyscan_table_row5  
764c			;  
764c			;	ld a,b  
764c			;	call addatohl  
764c			;	ld a,(hl)  
764c			;  
764c			;	cp '#'  
764c			;	jr nz, .nextmodcheck  
764c			;	set 0, c  
764c			;	ld hl, .matrix_to_char  
764c			;	jr .dokeymap  
764c			;	; TODO for now igonre  
764c			;.nextmodcheck:  
764c			;	ld hl, .matrix_to_symbolshift  
764c			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
764c			;	ld a, KEY_SYMBOLSHIFT  
764c			;	call findchar  
764c			;  
764c			;  
764c			;	; got offset to key modifer in b  
764c			;  
764c			;	ld hl,keyscan_table_row5  
764c			;  
764c			;	ld a,b  
764c			;	call addatohl  
764c			;	ld a,(hl)  
764c			;  
764c			;	cp '#'  
764c			;	jr nz, .donemodcheck  
764c			;	set 1, c   
764c			;	ld hl, .matrix_to_symbolshift  
764c			;	jr .dokeymap  
764c			  
764c			  
764c			  
764c			.donemodcheck:  
764c				; no modifer found so just map to normal keys  
764c				; get mtoc map matrix to respective keys  
764c 21 46 75			ld hl, .matrix_to_char  
764f			  
764f			.dokeymap:  
764f				;ld (key_fa), c   
764f cd 68 76			call .mapkeys  
7652			  
7652			  
7652			if DEBUG_KEY  
7652			  
7652			; Display text on first line  
7652			            LD   A, kLCD_Line1  
7652			            CALL fLCD_Pos       ;Position cursor to location in A  
7652			            LD   DE, keyscan_table_row1  
7652			            ;LD   DE, MsgHello  
7652			            CALL fLCD_Str       ;Display string pointed to by DE  
7652			  
7652			; Display text on second line  
7652			            LD   A, kLCD_Line2  
7652			            CALL fLCD_Pos       ;Position cursor to location in A  
7652			            LD   DE, keyscan_table_row2  
7652			            CALL fLCD_Str       ;Display string pointed to by DE  
7652			            LD   A, kLCD_Line3  
7652			            CALL fLCD_Pos       ;Position cursor to location in A  
7652			            LD   DE, keyscan_table_row3  
7652			            CALL fLCD_Str       ;Display string pointed to by DE  
7652			            LD   A, kLCD_Line4  
7652			            CALL fLCD_Pos       ;Position cursor to location in A  
7652			            LD   DE, keyscan_table_row4  
7652			            CALL fLCD_Str       ;Display string pointed to by DE  
7652			            LD   A, kLCD_Line1+10  
7652			            CALL fLCD_Pos       ;Position cursor to location in A  
7652			            LD   DE, keyscan_table_row5  
7652			            CALL fLCD_Str       ;Display string pointed to by DE  
7652			  
7652				;call delay250ms  
7652			endif  
7652			;	jp testkey  
7652			  
7652			; get first char reported  
7652			  
7652 21 04 fe			ld hl,keyscan_table_row5  
7655			  
7655				;ld b, 46   ; 30 keys to remap + 8 nulls   
7655 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7657			.findkey:  
7657 7e				ld a,(hl)  
7658 fe 00			cp 0  
765a 28 04			jr z, .nextkey  
765c fe 7e			cp KEY_MATRIX_NO_PRESS  
765e 20 06			jr nz, .foundkey  
7660			.nextkey:  
7660 23				inc hl  
7661 10 f4			djnz .findkey  
7663 3e 00			ld a,0  
7665 c9				ret  
7666			.foundkey:  
7666 7e				ld a,(hl)  
7667 c9				ret  
7668				  
7668			  
7668			; convert the raw key map given hl for destination key  
7668			.mapkeys:  
7668 11 04 fe			ld de,keyscan_table_row5  
766b			  
766b 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
766d			.remap:  
766d 1a				ld a,(de)  
766e fe 23			cp '#'  
7670 20 02			jr nz, .remapnext  
7672				;CALLMONITOR  
7672 7e				ld a,(hl)  
7673 12				ld (de),a  
7674			  
7674			  
7674			  
7674			.remapnext:  
7674 23				inc hl  
7675 13				inc de  
7676 10 f5			djnz .remap  
7678				  
7678 c9				ret  
7679			  
7679			  
7679			  
7679			.mtocold2:  
7679			  
7679			;	; flag if key D is held down and remove from reporting  
7679			;	ld bc, .key_map_fd    
7679			;	ld hl, keyscan_table  
7679			;	ld de, key_fd  
7679			;	call .key_shift_hold  
7679			;	cp 255  
7679			;	jr z, .cinmap  
7679			;	; flag if key C is held down and remove from reporting  
7679			;	ld bc, .key_map_fc    
7679			;	ld hl, keyscan_table+key_cols  
7679			;	ld de, key_fc  
7679			;	call .key_shift_hold  
7679			;	cp 255  
7679			;	jr z, .cinmap  
7679			;	; flag if key B is held down and remove from reporting  
7679			;	ld bc, .key_map_fb    
7679			;	ld hl, keyscan_table+(key_cols*2)  
7679			;	ld de, key_fb  
7679			;	call .key_shift_hold  
7679			;	cp 255  
7679			;	jr z, .cinmap  
7679			;	; flag if key A is held down and remove from reporting  
7679			;	ld bc, .key_map_fa    
7679			;	ld hl, keyscan_table+(key_cols*3)  
7679			;	ld de, key_fa  
7679			;	call .key_shift_hold  
7679			;	cp 255  
7679			;	jr z, .cinmap  
7679			  
7679 11 46 75			ld de, .matrix_to_char  
767c			  
767c			  
767c			.cinmap1:   
767c				if DEBUG_KEY  
767c			            LD   A, kLCD_Line4  
767c			            CALL fLCD_Pos       ;Position cursor to location in A  
767c					push de  
767c			            LD   DE, keyscan_table  
767c			            CALL fLCD_Str       ;Display string pointed to by DE  
767c					pop de  
767c				endif  
767c			  
767c				; scan key matrix table for any held key  
767c			  
767c				; de holds either the default matrix or one selected above  
767c			  
767c 21 d1 fd			ld hl, keyscan_table  
767f 06 32			ld b,key_cols*key_rows  
7681			  
7681 7e			.cin11:	ld a,(hl)  
7682 fe 23			cp '#'  
7684 28 08			jr z, .cinhit1  
7686 23				inc hl  
7687 13				inc de  
7688 05				dec b  
7689 20 f6			jr nz, .cin11  
768b				; no key found held  
768b 3e 00			ld a,0  
768d c9				ret  
768e d5			.cinhit1: push de  
768f e1				pop hl  
7690 7e				ld a,(hl)  
7691 c9				ret  
7692			  
7692			; flag a control key is held   
7692			; hl is key pin, de is flag indicator  
7692			  
7692			.key_shift_hold1:  
7692 c5				push bc  
7693 3e 01			ld a, 1  
7695 32 f6 fa			ld (cursor_shape),a  
7698 06 00			ld b, 0  
769a 7e				ld a, (hl)  
769b fe 2e			cp '.'  
769d 28 0a			jr z, .key_shift11  
769f 06 ff			ld b, 255  
76a1 3e 2b			ld a, '+'    ; hide key from later scans  
76a3 77				ld (hl),a  
76a4 3e 02			ld a, 2  
76a6 32 f6 fa			ld (cursor_shape),a  
76a9			.key_shift11:  
76a9				; write flag indicator  
76a9 78				ld a,b  
76aa 12				ld (de),a  
76ab			  
76ab d1				pop de    ; de now holds the key map ptr  
76ac c9				ret  
76ad			  
76ad				  
76ad			  
76ad			; scans keyboard matrix and flags key press in memory array	  
76ad				  
76ad			matrix:  
76ad				;call matrix  
76ad				; TODO optimise the code....  
76ad			  
76ad			  
76ad			;ld hl, keyscan_table_row1  
76ad			;ld de, keyscan_table_row1+1  
76ad			;ld bc,46  
76ad			;ld a,KEY_MATRIX_NO_PRESS  
76ad			;ldir  
76ad			  
76ad			  
76ad			  
76ad			; reset counter  
76ad 3e 80		ld a, 128  
76af d3 c1		out (portbdata),a  
76b1			  
76b1 06 0a		ld b, 10  
76b3 0e 00		ld c, 0       ; current clock toggle  
76b5			  
76b5			.colscan:  
76b5			  
76b5			; set current column  
76b5			; disable clock enable and set clock low  
76b5			  
76b5			;ld a, 0  
76b5			;out (portbdata),a  
76b5			  
76b5			; For each column scan for switches  
76b5			  
76b5 c5			push bc  
76b6 21 c7 fd		ld hl, keyscan_scancol  
76b9 cd c2 77		call .rowscan  
76bc c1			pop bc  
76bd			  
76bd			  
76bd			; get back current column  
76bd			  
76bd			; translate the row scan  
76bd			  
76bd			;   
76bd			; row 1  
76bd			  
76bd 78			ld a,b  
76be			  
76be 21 3a fe		LD   hl, keyscan_table_row1+10  
76c1			  
76c1 cd f0 0f		call subafromhl  
76c4			;call addatohl  
76c4			  
76c4 11 c7 fd		ld de, keyscan_scancol  
76c7			  
76c7 1a			ld a,(de)  
76c8 77			ld (hl),a  
76c9			  
76c9			  
76c9			  
76c9			  
76c9			; row 2  
76c9			  
76c9 78			ld a,b  
76ca			  
76ca 21 2f fe		LD   hl, keyscan_table_row2+10  
76cd			  
76cd			;call addatohl  
76cd cd f0 0f		call subafromhl  
76d0			  
76d0			  
76d0 11 c8 fd		ld de, keyscan_scancol+1  
76d3			  
76d3 1a			ld a,(de)  
76d4 77			ld (hl),a  
76d5			  
76d5			  
76d5			; row 3  
76d5			  
76d5 78			ld a,b  
76d6			  
76d6 21 24 fe		LD   hl, keyscan_table_row3+10  
76d9			  
76d9			;call addatohl  
76d9 cd f0 0f		call subafromhl  
76dc			  
76dc 11 c9 fd		ld de, keyscan_scancol+2  
76df			  
76df 1a			ld a,(de)  
76e0 77			ld (hl),a  
76e1			  
76e1			  
76e1			  
76e1			; row 4  
76e1			  
76e1 78			ld a,b  
76e2			  
76e2 21 19 fe		LD   hl, keyscan_table_row4+10  
76e5			  
76e5			;call addatohl  
76e5 cd f0 0f		call subafromhl  
76e8			  
76e8 11 ca fd		ld de, keyscan_scancol+3  
76eb			  
76eb 1a			ld a,(de)  
76ec 77			ld (hl),a  
76ed			  
76ed			; row 5  
76ed			  
76ed 78			ld a,b  
76ee			  
76ee 21 0e fe		LD   hl, keyscan_table_row5+10  
76f1			  
76f1			;call addatohl  
76f1 cd f0 0f		call subafromhl  
76f4			  
76f4 11 cb fd		ld de, keyscan_scancol+4  
76f7			  
76f7 1a			ld a,(de)  
76f8 77			ld (hl),a  
76f9			  
76f9			; handshake next column  
76f9			  
76f9			  
76f9 3e 40		ld a, 64  
76fb d3 c1		out (portbdata),a  
76fd			  
76fd 3e 00		ld a, 0  
76ff d3 c1		out (portbdata),a  
7701			  
7701			; toggle clk and move to next column  
7701			;ld a, 64  
7701			;cp c  
7701			;  
7701			;jr z, .coltoglow  
7701			;ld c, a  
7701			;jr .coltog  
7701			;.coltoglow:  
7701			;ld c, 0  
7701			;.coltog:  
7701			;ld a, c  
7701			;out (portbdata),a  
7701			  
7701 10 b2		djnz .colscan  
7703			  
7703 3e 0a		ld a,10  
7705 21 30 fe		LD   hl, keyscan_table_row1  
7708 cd de 0f		call addatohl  
770b 3e 00		ld a, 0  
770d 77			ld (hl), a  
770e			  
770e			  
770e 3e 0a		ld a,10  
7710 21 25 fe		LD   hl, keyscan_table_row2  
7713 cd de 0f		call addatohl  
7716 3e 00		ld a, 0  
7718 77			ld (hl), a  
7719			  
7719 3e 0a		ld a,10  
771b 21 1a fe		LD   hl, keyscan_table_row3  
771e cd de 0f		call addatohl  
7721 3e 00		ld a, 0  
7723 77			ld (hl), a  
7724			  
7724 3e 0a		ld a,10  
7726 21 0f fe		LD   hl, keyscan_table_row4  
7729 cd de 0f		call addatohl  
772c 3e 00		ld a, 0  
772e 77			ld (hl), a  
772f			  
772f 3e 0a		ld a,10  
7731 21 04 fe		LD   hl, keyscan_table_row5  
7734 cd de 0f		call addatohl  
7737 3e 00		ld a, 0  
7739 77			ld (hl), a  
773a			  
773a			if DEBUG_KEY_MATRIX  
773a			  
773a			; Display text on first line  
773a			            LD   A, kLCD_Line1  
773a			            CALL fLCD_Pos       ;Position cursor to location in A  
773a			            LD   DE, keyscan_table_row1  
773a			            ;LD   DE, MsgHello  
773a			            CALL fLCD_Str       ;Display string pointed to by DE  
773a			  
773a			; Display text on second line  
773a			            LD   A, kLCD_Line2  
773a			            CALL fLCD_Pos       ;Position cursor to location in A  
773a			            LD   DE, keyscan_table_row2  
773a			            CALL fLCD_Str       ;Display string pointed to by DE  
773a			            LD   A, kLCD_Line3  
773a			            CALL fLCD_Pos       ;Position cursor to location in A  
773a			            LD   DE, keyscan_table_row3  
773a			            CALL fLCD_Str       ;Display string pointed to by DE  
773a			            LD   A, kLCD_Line4  
773a			            CALL fLCD_Pos       ;Position cursor to location in A  
773a			            LD   DE, keyscan_table_row4  
773a			            CALL fLCD_Str       ;Display string pointed to by DE  
773a			            LD   A, kLCD_Line4+10  
773a			            CALL fLCD_Pos       ;Position cursor to location in A  
773a			            LD   DE, keyscan_table_row5  
773a			            CALL fLCD_Str       ;Display string pointed to by DE  
773a			  
773a			;call delay250ms  
773a				jp matrix  
773a			endif  
773a c9			ret  
773b			  
773b			; using decade counter....  
773b			  
773b			  
773b			; TODO reset decade counter to start of scan  
773b			  
773b			; reset 15  
773b			; clock 14  
773b			; ce 13  
773b			  
773b			; 1 - q5  
773b			; 2 - q1  
773b			; 3 - q0  
773b			; 4 - q2  
773b			; 5 - q6  
773b			; 6 - q7  
773b			; 7 - q3  
773b			; 8 - vss  
773b			; 9 - q8  
773b			; 10 - q4  
773b			; 11 - q9  
773b			; 12 - cout  
773b			; 16 - vdd  
773b			  
773b			; clock      ce       reset     output  
773b			; 0          x        0         n  
773b			; x          1        0         n  
773b			; x          x        1         q0  
773b			; rising     0        0         n+1  
773b			; falling    x        0         n  
773b			; x          rising   0         n  
773b			; 1          falling  0         x+1  
773b			;  
773b			; x = dont care, if n < 5 carry = 1 otherwise 0  
773b			  
773b			;   
773b			; reset   
773b			; 13=0, 14=0, 15=1 .. 15=0  
773b			;  
773b			; handshake line  
773b			; 14=1.... read line 14=0  
773b			  
773b			  
773b			  
773b			  
773b			  
773b			; TODO hand shake clock for next column scan  
773b			; TODO detect each row  
773b			  
773b			  
773b			  
773b			  
773b			; reset 128  
773b			; clock 64  
773b			; ce 32  
773b			  
773b			  
773b			.cyclestart:  
773b			  
773b			; reset counter  
773b 3e 80		ld a, 128  
773d d3 c1		out (portbdata),a  
773f			  
773f			; loop leds  
773f 06 0a		ld b,10  
7741			  
7741			.cycle1:  
7741 c5			push bc  
7742 3e 00		ld a, 0  
7744 d3 c1		out (portbdata),a  
7746 cd e1 0c		call delay250ms  
7749			  
7749 3e 40		ld a, 64  
774b d3 c1		out (portbdata),a  
774d cd e1 0c		call delay250ms  
7750			  
7750 3e 00		ld a, 0  
7752 d3 c1		out (portbdata),a  
7754 cd e1 0c		call delay250ms  
7757			  
7757 c1			pop bc  
7758 10 e7		djnz .cycle1  
775a			  
775a			  
775a 18 df		jr .cyclestart  
775c			  
775c			  
775c			  
775c			  
775c			  
775c			  
775c			  
775c			  
775c			  
775c			; map matrix key held to char on face of key  
775c			  
775c			;.mtocold:  
775c			;  
775c			;  
775c			;; reset counter  
775c			;ld a, 128  
775c			;out (portbdata),a  
775c			;  
775c			;  
775c			;; scan keyboard row 1  
775c			;ld a, 0  
775c			;out (portbdata),a  
775c			;;ld a, 64  
775c			;;out (portbdata),a  
775c			;  
775c			;  
775c			;	ld a, 128  
775c			;	ld hl, keyscan_table  
775c			;	call .rowscan  
775c			;  
775c			;;ld a, 0  
775c			;;out (portbdata),a  
775c			;ld a, 64  
775c			;out (portbdata),a  
775c			;  
775c			;	ld a, 64  
775c			;	ld hl, keyscan_table+key_cols  
775c			;	call .rowscan  
775c			;  
775c			;ld a, 0  
775c			;out (portbdata),a  
775c			;;ld a, 64  
775c			;;out (portbdata),a  
775c			;	ld a, 32  
775c			;	ld hl, keyscan_table+(key_cols*2)  
775c			;	call .rowscan  
775c			;  
775c			;  
775c			;;ld a, 0  
775c			;;out (portbdata),a  
775c			;ld a, 64  
775c			;out (portbdata),a  
775c			;  
775c			;	ld a, 16  
775c			;	ld hl, keyscan_table+(key_cols*3)  
775c			;	call .rowscan  
775c			;  
775c			;  
775c			;	; flag if key D is held down and remove from reporting  
775c			;	ld bc, .key_map_fd    
775c			;	ld hl, keyscan_table  
775c			;	ld de, key_fd  
775c			;	call .key_shift_hold  
775c			;	cp 255  
775c			;	jr z, .cinmap  
775c			;	; flag if key C is held down and remove from reporting  
775c			;	ld bc, .key_map_fc    
775c			;	ld hl, keyscan_table+key_cols  
775c			;	ld de, key_fc  
775c			;	call .key_shift_hold  
775c			;	cp 255  
775c			;	jr z, .cinmap  
775c			;	; flag if key B is held down and remove from reporting  
775c			;	ld bc, .key_map_fb    
775c			;	ld hl, keyscan_table+(key_cols*2)  
775c			;	ld de, key_fb  
775c			;	call .key_shift_hold  
775c			;	cp 255  
775c			;	jr z, .cinmap  
775c			;	; flag if key A is held down and remove from reporting  
775c			;	ld bc, .key_map_fa    
775c			;	ld hl, keyscan_table+(key_cols*3)  
775c			;	ld de, key_fa  
775c			;	call .key_shift_hold  
775c			;	cp 255  
775c			;	jr z, .cinmap  
775c			;  
775c			;	ld de, .matrix_to_char  
775c			;  
775c			;  
775c			;.cinmap:   
775c			;	if DEBUG_KEY  
775c			;            LD   A, kLCD_Line4  
775c			;            CALL fLCD_Pos       ;Position cursor to location in A  
775c			;		push de  
775c			;            LD   DE, keyscan_table  
775c			;            CALL fLCD_Str       ;Display string pointed to by DE  
775c			;		pop de  
775c			;	endif  
775c			  
775c				; scan key matrix table for any held key  
775c			  
775c				; de holds either the default matrix or one selected above  
775c			  
775c			;	ld hl, keyscan_table  
775c			;	ld b,key_cols*key_rows  
775c			;  
775c			;.cin1:	ld a,(hl)  
775c			;	cp '#'  
775c			;	jr z, .cinhit  
775c			;	inc hl  
775c			;	inc de  
775c			;	dec b  
775c			;	jr nz, .cin1  
775c			;	; no key found held  
775c			;	ld a,0  
775c			;	ret  
775c			;.cinhit: push de  
775c			;	pop hl  
775c			;	ld a,(hl)  
775c			;	ret  
775c			  
775c			; flag a control key is held   
775c			; hl is key pin, de is flag indicator  
775c			  
775c			;.key_shift_hold:  
775c			;	push bc  
775c			;	ld a, 1  
775c			;	ld (cursor_shape),a  
775c			;	ld b, 0  
775c			;	ld a, (hl)  
775c			;	cp '.'  
775c			;	jr z, .key_shift1  
775c			;	ld b, 255  
775c			;	ld a, '+'    ; hide key from later scans  
775c			;	ld (hl),a  
775c			;	ld a, 2  
775c			;	ld (cursor_shape),a  
775c			;.key_shift1:  
775c			;	; write flag indicator  
775c			;	ld a,b  
775c			;	ld (de),a  
775c			;  
775c			;	pop de    ; de now holds the key map ptr  
775c			;	ret  
775c			  
775c				  
775c				  
775c			  
775c			  
775c			  
775c			  
775c			  
775c			  
775c			  
775c			  
775c			  
775c			  
775c			  
775c			;	push hl  
775c			;	push de  
775c			;	push bc  
775c			;	call keyscan  
775c			;	; map key matrix to ascii value of key face  
775c			;  
775c			;	ld hl, key_face_map  
775c			;	ld de, keyscan_table  
775c			;  
775c			;	; get how many keys to look at  
775c			;	ld b, keyscan_table_len  
775c			;	  
775c			;  
775c			;	; at this stage fall out on first key hit  
775c			;	; TODO handle multiple key press  
775c			;  
775c			;map1:	ld a,(hl)  
775c			;	cp '#'  
775c			;	jr z, keyhit  
775c			;	inc hl  
775c			;	inc de  
775c			;	dec b  
775c			;	jr nz, map1  
775c			;nohit:	ld a, 0  
775c			;	jr keydone  
775c			;keyhit: push de  
775c			;	pop hl  
775c			;	ld a,(hl)  
775c			;keydone:  
775c			;	push bc  
775c			;	push de  
775c			; 	push hl  
775c			;	ret   
775c			;  
775c			  
775c			  
775c			  
775c			  
775c			; scan physical key matrix  
775c			  
775c			  
775c			;keyscan:  
775c			;  
775c			;; for each key_row use keyscanr bit mask for out  
775c			;; then read in for keyscanc bitmask  
775c			;; save result of row scan to keyscantable  
775c			;  
775c			;; scan keyboard row 1  
775c			;  
775c			;	ld b, key_rows  
775c			;	ld hl, key_scanr  
775c			;	ld de, keyscan_table  
775c			;  
775c			;rowloop:  
775c			;  
775c			;	ld a,(hl)		; out bit mask to energise keyboard row  
775c			;	call rowscan  
775c			;	inc hl  
775c			;	dec b  
775c			;	jr nz, rowloop  
775c			;  
775c			;	ret  
775c			;  
775c			;  
775c			;; pass a out bitmask, b row number  
775c			;arowscan:   
775c			;	push bc  
775c			;  
775c			;	ld d, b  
775c			;  
775c			;	; calculate buffer location for this row  
775c			;  
775c			;	ld hl, keyscan_table	  
775c			;kbufr:  ld e, key_cols  
775c			;kbufc:	inc hl  
775c			;	dec e  
775c			;	jr nz, kbufc  
775c			;	dec d  
775c			;	jr nz, kbufr  
775c			;  
775c			;	; energise row and read columns  
775c			;  
775c			;	out (portbdata),a  
775c			;	in a,(portbdata)  
775c			;	ld c,a  
775c			;  
775c			;  
775c			;	; save buffer loc  
775c			;  
775c			;	ld (keybufptr), hl  
775c			;  
775c			;	ld hl, key_scanc  
775c			;	ld d, key_cols  
775c			;  
775c			;	; for each column check each bit mask  
775c			;  
775c			;colloop:  
775c			;	  
775c			;  
775c			;	; reset flags for the row   
775c			;  
775c			;	ld b,'.'  
775c			;	and (hl)  
775c			;	jr z, maskskip  
775c			;	ld b,'#'  
775c			;maskskip:  
775c			;	; save  key state  
775c			;	push hl  
775c			;	ld hl, (keybufptr)  
775c			;	ld (hl), b  
775c			;	inc hl  
775c			;	ld (keybufptr), hl  
775c			;  
775c			;	; move to next bit mask  
775c			;	pop hl  
775c			;	inc hl  
775c			;  
775c			;	dec d  
775c			;	jr nz, colloop  
775c			;  
775c			;	ret  
775c			;  
775c			;  
775c			;;  
775c			; lcd functions  
775c			;  
775c			;  
775c			  
775c			;if DEBUG_KEY_MATRIX  
775c			  
775c			; test function to display hardware view of matrix state  
775c			  
775c			matrixold:  
775c			  
775c			  
775c			  
775c			; reset counter  
775c 3e 80		ld a, 128  
775e d3 c1		out (portbdata),a  
7760			; scan keyboard row 1  
7760 3e 00		ld a, 0  
7762 d3 c1		out (portbdata),a  
7764			;ld a, 64  
7764			;out (portbdata),a  
7764 3e 80			ld a, 128  
7766 21 30 fe			ld hl, keyscan_table_row1  
7769 cd c2 77			call .rowscan  
776c			  
776c			;ld a, 0  
776c			;out (portbdata),a  
776c 3e 40		ld a, 64  
776e d3 c1		out (portbdata),a  
7770 3e 40			ld a, 64  
7772 21 25 fe			ld hl, keyscan_table_row2  
7775 cd c2 77			call .rowscan  
7778			  
7778 3e 00		ld a, 0  
777a d3 c1		out (portbdata),a  
777c			;ld a, 64  
777c			;out (portbdata),a  
777c 3e 20			ld a, 32  
777e 21 1a fe			ld hl, keyscan_table_row3  
7781 cd c2 77			call .rowscan  
7784			  
7784			;ld a, 0  
7784			;out (portbdata),a  
7784 3e 40		ld a, 64  
7786 d3 c1		out (portbdata),a  
7788 3e 10			ld a, 16  
778a 21 0f fe			ld hl, keyscan_table_row4  
778d cd c2 77			call .rowscan  
7790			  
7790			; Display text on first line  
7790 3e 00		            LD   A, kLCD_Line1  
7792 cd c0 73		            CALL fLCD_Pos       ;Position cursor to location in A  
7795 11 30 fe		            LD   DE, keyscan_table_row1  
7798			            ;LD   DE, MsgHello  
7798 cd e2 73		            CALL fLCD_Str       ;Display string pointed to by DE  
779b			  
779b			; Display text on second line  
779b 3e 28		            LD   A, kLCD_Line2  
779d cd c0 73		            CALL fLCD_Pos       ;Position cursor to location in A  
77a0 11 25 fe		            LD   DE, keyscan_table_row2  
77a3 cd e2 73		            CALL fLCD_Str       ;Display string pointed to by DE  
77a6 3e 50		            LD   A, kLCD_Line3  
77a8 cd c0 73		            CALL fLCD_Pos       ;Position cursor to location in A  
77ab 11 1a fe		            LD   DE, keyscan_table_row3  
77ae cd e2 73		            CALL fLCD_Str       ;Display string pointed to by DE  
77b1 3e 78		            LD   A, kLCD_Line4  
77b3 cd c0 73		            CALL fLCD_Pos       ;Position cursor to location in A  
77b6 11 0f fe		            LD   DE, keyscan_table_row4  
77b9 cd e2 73		            CALL fLCD_Str       ;Display string pointed to by DE  
77bc			  
77bc cd e1 0c			call delay250ms  
77bf c3 ad 76			jp matrix  
77c2			  
77c2			; pass de as row display flags  
77c2			.rowscan:   
77c2			;	out (portbdata),a  
77c2 db c1			in a,(portbdata)  
77c4 4f				ld c,a  
77c5				; reset flags for the row   
77c5 06 7e			ld b,KEY_MATRIX_NO_PRESS  
77c7 e6 01			and 1  
77c9 28 02			jr z, .p1on  
77cb 06 23			ld b,'#'  
77cd			.p1on:  
77cd 70				ld (hl), b  
77ce 23				inc hl  
77cf			  
77cf 06 7e			ld b,KEY_MATRIX_NO_PRESS  
77d1 79				ld a,c  
77d2 e6 02			and 2  
77d4			;	bit 0,a  
77d4 28 02			jr z, .p2on  
77d6 06 23			ld b,'#'  
77d8			.p2on:  
77d8 70				ld (hl), b  
77d9 23				inc hl  
77da			;  
77da 06 7e			ld b,KEY_MATRIX_NO_PRESS  
77dc 79				ld a,c  
77dd e6 04			and 4  
77df			;;	bit 0,a  
77df 28 02			jr z, .p3on  
77e1 06 23			ld b,'#'  
77e3			.p3on:  
77e3 70				ld (hl), b  
77e4 23				inc hl  
77e5			;;  
77e5 06 7e			ld b,KEY_MATRIX_NO_PRESS  
77e7			;;	bit 0,a  
77e7 79				ld a,c  
77e8 e6 08			and 8  
77ea 28 02			jr z, .p4on  
77ec 06 23			ld b,'#'  
77ee			.p4on:  
77ee 70				ld (hl), b  
77ef 23				inc hl  
77f0			  
77f0 06 7e			ld b,KEY_MATRIX_NO_PRESS  
77f2			;;	bit 0,a  
77f2 79				ld a,c  
77f3 e6 10			and 16  
77f5 28 02			jr z, .p5on  
77f7 06 23			ld b,'#'  
77f9			.p5on:  
77f9 70				ld (hl), b  
77fa 23				inc hl  
77fb			; zero term  
77fb 06 00			ld b,0  
77fd 70				ld (hl), b  
77fe			  
77fe c9			.rscandone: ret  
77ff			  
77ff			;addatohl:  
77ff			;  
77ff			 ;add   a, l    ; A = A+L  
77ff			  ;  ld    l, a    ; L = A+L  
77ff			   ; adc   a, h    ; A = A+L+H+carry  
77ff			   ; sub   l       ; A = H+carry  
77ff			   ; ld    h, a    ; H = H+carry  
77ff			  
77ff			;ret  
77ff			; eof  
# End of file firmware_key_5x10.asm
77ff			;include "firmware_key_4x10.asm" 
77ff			 
77ff			heap_size:    equ heap_end - heap_start 
77ff			;eof 
# End of file os_mega.asm
77ff
